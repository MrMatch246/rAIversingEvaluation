{
    "functions": {
        "FUN_0800192c": {
            "renaming": {
                "FUN_0800192c": "update_limits_enabled_0800192c"
            },
            "code": "\nvoid updateLimitsEnabled_0800192c(void)\n\n{\n  if ((PTR_settings_08001954[0x28] & 8) == 0) {\n    *(undefined4 *)PTR_limits_enabled_08001958 = 0;\n  }\n  else {\n    *(undefined4 *)PTR_limits_enabled_08001958 = 1;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800192c",
            "calling": [
                "grbl_main",
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "update_limits_enabled_0800192c"
        },
        "FUN_08006950": {
            "renaming": {
                "FUN_08006950": "set_priority_group_08006950",
                "PriorityGroup": "priorityGroup",
                "reg_value": "registerValue",
                "PriorityGroupTmp": "priorityGroupTemp"
            },
            "code": "\nvoid setPriorityGroup_08006950(uint32_t priorityGroup)\n\n{\n  uint32_t registerValue;\n  uint32_t priorityGroupTemp;\n  \n  *(uint *)(DAT_08006994 + 0xc) =\n       *(uint *)(DAT_08006994 + 0xc) & 0xf8ff | (priorityGroup & 7) << 8 | 0x5fa0000;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006950",
            "calling": [
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "imported": false,
            "current_name": "set_priority_group_08006950"
        },
        "FUN_08008ba0": {
            "renaming": {
                "FUN_08008ba0": "calculate_result_08008ba0",
                "param_1": "inputValue1",
                "param_2": "inputValue2",
                "uVar1": "tempResult",
                "iVar2": "intermediateValue",
                "uVar3": "shiftAmount"
            },
            "code": "\nuint calculateResult_08008ba0(uint inputValue1,uint inputValue2)\n\n{\n  uint tempResult;\n  int intermediateValue;\n  uint shiftAmount;\n  \n  intermediateValue = inputValue2 * 2 + 0x200000;\n  if (inputValue2 * 2 < 0xffe00000) {\n    if (-1 < intermediateValue) {\n      return 0;\n    }\n    tempResult = intermediateValue >> 0x15;\n    shiftAmount = -tempResult - 0x3e1;\n    if (tempResult < 0xfffffc20 && shiftAmount != 0) {\n      tempResult = (inputValue2 << 0xb | 0x80000000 | inputValue1 >> 0x15) >> (shiftAmount & 0xff);\n      if ((inputValue2 & 0x80000000) != 0) {\n        tempResult = -tempResult;\n      }\n      return tempResult;\n    }\n  }\n  else if ((inputValue1 | inputValue2 << 0xc) != 0) {\n    return 0;\n  }\n  inputValue2 = inputValue2 & 0x80000000;\n  if (inputValue2 == 0) {\n    inputValue2 = 0x7fffffff;\n  }\n  return inputValue2;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ba0",
            "calling": [
                "__kernel_cos",
                "__kernel_sin",
                "gc_execute_line",
                "lround",
                "__ieee754_rem_pio2",
                "calculate_trapezoid_for_block",
                "plan_buffer_line",
                "__kernel_rem_pio2"
            ],
            "imported": false,
            "current_name": "calculate_result_08008ba0"
        },
        "FUN_08005a5c": {
            "renaming": {
                "FUN_08005a5c": "do_nothing_08005a5c"
            },
            "code": "\nvoid do_nothing_08005a5c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a5c",
            "calling": [
                "HAL_DeInit"
            ],
            "imported": false,
            "current_name": "do_nothing_08005a5c"
        },
        "FUN_08005b90": {
            "renaming": {
                "FUN_08005b90": "clear_bit_at_offset_08005b90"
            },
            "code": "\nvoid clearBitAtOffset_08005b90(void)\n\n{\n  *(uint *)(DAT_08005ba8 + 4) = *(uint *)(DAT_08005ba8 + 4) & 0xfffffffb;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b90",
            "calling": [],
            "imported": false,
            "current_name": "clear_bit_at_offset_08005b90"
        },
        "FUN_080071d0": {
            "renaming": {
                "FUN_080071d0": "configure_gpio_pins_080071d0",
                "GPIOx": "gpio_port",
                "GPIO_Pin": "gpio_pins",
                "uVar1": "single_bit_mask",
                "uVar2": "masked_pin",
                "tmp": "temp",
                "iocurrent": "io_current",
                "ioposition": "io_position",
                "position": "pin_position"
            },
            "code": "\nvoid configure_GPIO_pins_080071d0(GPIO_TypeDef *gpio_port,uint32_t gpio_pins)\n\n{\n  uint single_bit_mask;\n  uint masked_pin;\n  uint32_t temp;\n  uint32_t io_current;\n  uint32_t io_position;\n  uint32_t pin_position;\n  \n  for (pin_position = 0; pin_position < 0x10; pin_position = pin_position + 1) {\n    single_bit_mask = 1 << (pin_position & 0xff);\n    masked_pin = single_bit_mask & gpio_pins;\n    if (masked_pin == single_bit_mask) {\n      gpio_port->MODER = gpio_port->MODER & ~(3 << ((pin_position & 0x7f) << 1));\n      gpio_port->AFR[pin_position >> 3] = gpio_port->AFR[pin_position >> 3] & ~(0xf << ((pin_position & 7) << 2));\n      gpio_port->OSPEEDR = gpio_port->OSPEEDR & ~(3 << ((pin_position & 0x7f) << 1));\n      gpio_port->OTYPER = gpio_port->OTYPER & ~(1 << (pin_position & 0xff));\n      gpio_port->PUPDR = gpio_port->PUPDR & ~(3 << ((pin_position & 0x7f) << 1));\n      *(uint *)(DAT_08007308 + ((pin_position >> 2) + 2) * 4) =\n           ~(0xf << ((pin_position & 3) << 2)) & *(uint *)(DAT_08007308 + ((pin_position >> 2) + 2) * 4);\n      *DAT_0800730c = ~masked_pin & *DAT_0800730c;\n      DAT_0800730c[1] = ~masked_pin & DAT_0800730c[1];\n      DAT_0800730c[2] = ~masked_pin & DAT_0800730c[2];\n      DAT_0800730c[3] = ~masked_pin & DAT_0800730c[3];\n    }\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080071d0",
            "calling": [],
            "imported": false,
            "current_name": "configure_gpio_pins_080071d0"
        },
        "FUN_08008e60": {
            "renaming": {
                "FUN_08008e60": "calculate_result_08008e60",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar1": "temp_input_1",
                "uVar2": "temp_input_2",
                "iVar3": "leading_zeroes",
                "uVar4": "shift_amount",
                "iVar5": "base_value",
                "uVar6": "shifted_input_1"
            },
            "code": "\nuint calculate_result_08008e60(uint input_1,uint input_2)\n\n{\n  uint temp_input_1;\n  uint temp_input_2;\n  int leading_zeroes;\n  uint shift_amount;\n  int base_value;\n  uint shifted_input_1;\n  \n  if ((input_1 | input_2) == 0) {\n    return input_1;\n  }\n  temp_input_1 = input_1;\n  temp_input_2 = input_2;\n  if (input_2 == 0) {\n    temp_input_1 = 0;\n    temp_input_2 = input_1;\n  }\n  base_value = 0x5b000000;\n  if (input_2 == 0) {\n    base_value = 0x4b000000;\n  }\n  leading_zeroes = count_leading_zeroes(temp_input_2);\n  shift_amount = leading_zeroes - 8;\n  base_value = base_value + -0x800000 + shift_amount * -0x800000;\n  if (leading_zeroes < 8) {\n    shift_amount = temp_input_2 << (leading_zeroes + 0x18U & 0xff);\n    temp_input_2 = base_value + ((temp_input_2 >> (0x20 - (leading_zeroes + 0x18U) & 0xff)) - ((int)shift_amount >> 0x1f));\n    if ((temp_input_1 | shift_amount << 1) == 0) {\n      temp_input_2 = temp_input_2 & ~(shift_amount >> 0x1f);\n    }\n    return temp_input_2;\n  }\n  shifted_input_1 = temp_input_1 << (shift_amount & 0xff);\n  temp_input_2 = base_value + (temp_input_2 << (shift_amount & 0xff)) +\n          (temp_input_1 >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < shifted_input_1);\n  if (shifted_input_1 == 0x80000000) {\n    temp_input_2 = temp_input_2 & 0xfffffffe;\n  }\n  return temp_input_2;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e60",
            "calling": [],
            "imported": false,
            "current_name": "calculate_result_08008e60"
        },
        "FUN_08005984": {
            "renaming": {
                "FUN_08005984": "process_ticks_08005984",
                "uVar1": "result"
            },
            "code": "\nint processTicks_08005984(int ticks)\n\n{\n  uint32_t result;\n  \n  if (*(int *)PTR_noHyperCall_080059b0 == 0) {\n    result = aflCall(1,ticks,0);\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005984",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "process_ticks_08005984"
        },
        "FUN_080082c8": {
            "renaming": {
                "FUN_080082c8": "compute_result_080082c8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "temp_var1",
                "bVar2": "byte_var",
                "uVar3": "uint_var3",
                "uVar4": "uint_var4",
                "uVar5": "uint_var5",
                "iVar6": "temp_var2",
                "uVar7": "uint_var7",
                "uVar8": "uint_var8",
                "uVar9": "uint_var9",
                "uVar10": "uint_var10",
                "uVar11": "uint_var11",
                "uVar12": "uint_var12",
                "bVar13": "bool_var1",
                "bVar14": "bool_var2",
                "bVar15": "bool_var3"
            },
            "code": "\nulonglong compute_result_080082c8(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int temp_var1;\n  byte byte_var;\n  uint uint_var3;\n  uint uint_var4;\n  uint uint_var5;\n  int temp_var2;\n  uint uint_var7;\n  uint uint_var8;\n  uint uint_var9;\n  uint uint_var10;\n  uint uint_var11;\n  uint uint_var12;\n  bool bool_var1;\n  bool bool_var2;\n  bool bool_var3;\n  \n  uint_var4 = input2 ^ 0x80000000;\n  uint_var7 = input2 << 1;\n  uint_var9 = input4 << 1;\n  bool_var1 = ((uint_var4 ^ input4) & 0x7fffffff) == 0;\n  bool_var2 = bool_var1 && input1 == input3;\n  if (!bool_var1 || input1 != input3) {\n    bool_var2 = (uint_var7 | input1) == 0;\n  }\n  if (!bool_var2) {\n    bool_var2 = (uint_var9 | input3) == 0;\n  }\n  temp_var2 = (int)uint_var7 >> 0x15;\n  if (!bool_var2) {\n    bool_var2 = temp_var2 == -1;\n  }\n  temp_var1 = (int)uint_var9 >> 0x15;\n  if (!bool_var2) {\n    bool_var2 = temp_var1 == -1;\n  }\n  if (bool_var2) {\n    if (temp_var2 == -1 || temp_var1 == -1) {\n      uint_var9 = input4;\n      uint_var7 = input3;\n      if (temp_var2 == -1) {\n        uint_var9 = uint_var4;\n        uint_var7 = input1;\n      }\n      if (temp_var2 != -1 || temp_var1 != -1) {\n        input3 = uint_var7;\n        input4 = uint_var9;\n      }\n      bool_var2 = (uint_var7 | uint_var9 << 0xc) == 0;\n      if (bool_var2) {\n        bool_var2 = (input3 | input4 << 0xc) == 0;\n      }\n      if (bool_var2) {\n        bool_var2 = uint_var9 == input4;\n      }\n      if (!bool_var2) {\n        uint_var9 = uint_var9 | 0x80000;\n      }\n      return CONCAT44(uint_var9,uint_var7);\n    }\n    if (((uint_var4 ^ input4) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((uint_var7 | input1) == 0) {\n        input1 = input3;\n        uint_var4 = input4;\n      }\n      return CONCAT44(uint_var4,input1);\n    }\n    if (uint_var4 != input4) {\n      return 0;\n    }\n    if (uint_var7 >> 0x15 == 0) {\n      bool_var2 = (input1 & 0x80000000) != 0;\n      uint_var9 = input2 * 2 + (uint)bool_var2;\n      if (CARRY4(uint_var4,uint_var4) || CARRY4(input2 * 2,(uint)bool_var2)) {\n        uint_var9 = uint_var9 | 0x80000000;\n      }\n      return CONCAT44(uint_var9,input1 << 1);\n    }\n    if (uint_var7 < 0xffc00000) {\n      return CONCAT44(uint_var4 + 0x100000,input1);\n    }\n    uint_var4 = uint_var4 & 0x80000000;\nLAB_08008514:\n    return (ulonglong)(uint_var4 | 0x7ff00000) << 0x20;\n  }\n  uint_var7 = uint_var7 >> 0x15;\n  uint_var9 = uint_var9 >> 0x15;\n  uint_var10 = uint_var9 - uint_var7;\n  bool_var2 = uint_var10 != 0;\n  if (uint_var9 < uint_var7) {\n    uint_var10 = -uint_var10;\n  }\n  uint_var8 = input1;\n  uint_var12 = uint_var4;\n  if (bool_var2 && uint_var7 <= uint_var9) {\n    uint_var7 = uint_var7 + uint_var10;\n    uint_var8 = input3;\n    uint_var12 = input4;\n    input3 = input1;\n    input4 = uint_var4;\n  }\n  if (0x36 < uint_var10) {\n    return CONCAT44(uint_var12,uint_var8);\n  }\n  uint_var9 = uint_var12 & 0xfffff | 0x100000;\n  if ((uint_var12 & 0x80000000) != 0) {\n    bool_var2 = uint_var8 != 0;\n    uint_var8 = -uint_var8;\n    uint_var9 = -uint_var9 - (uint)bool_var2;\n  }\n  uint_var4 = input4 & 0xfffff | 0x100000;\n  if ((input4 & 0x80000000) != 0) {\n    bool_var2 = input3 != 0;\n    input3 = -input3;\n    uint_var4 = -uint_var4 - (uint)bool_var2;\n  }\n  if (uint_var7 == uint_var10) {\n    uint_var4 = uint_var4 ^ 0x100000;\n    if (uint_var7 == 0) {\n      uint_var9 = uint_var9 ^ 0x100000;\n      uint_var7 = 1;\n    }\n    else {\n      uint_var10 = uint_var10 - 1;\n    }\n  }\n  uint_var12 = -uint_var10 + 0x20;\n  if ((int)uint_var10 < 0x21) {\n    uint_var11 = input3 << (uint_var12 & 0xff);\n    input3 = input3 >> (uint_var10 & 0xff);\n    uint_var3 = uint_var8 + input3;\n    uint_var5 = uint_var4 << (uint_var12 & 0xff);\n    uint_var12 = uint_var3 + uint_var5;\n    uint_var9 = uint_var9 + CARRY4(uint_var8,input3) + ((int)uint_var4 >> (uint_var10 & 0xff)) +\n            (uint)CARRY4(uint_var3,uint_var5);\n  }\n  else {\n    uint_var11 = uint_var4 << (-uint_var10 + 0x40 & 0xff);\n    if (input3 != 0) {\n      uint_var11 = uint_var11 | 2;\n    }\n    uint_var4 = (int)uint_var4 >> (uint_var10 - 0x20 & 0xff);\n    uint_var12 = uint_var8 + uint_var4;\n    uint_var9 = uint_var9 + ((int)uint_var4 >> 0x1f) + (uint)CARRY4(uint_var8,uint_var4);\n  }\n  uint_var4 = uint_var9 & 0x80000000;\n  uint_var10 = uint_var9;\n  if ((int)uint_var9 < 0) {\n    bool_var2 = uint_var11 == 0;\n    uint_var11 = -uint_var11;\n    uint_var10 = -uint_var12;\n    uint_var12 = -(uint)!bool_var2 - uint_var12;\n    uint_var10 = -(uint)(bool_var2 <= uint_var10) - uint_var9;\n  }\n  if (0xfffff < uint_var10) {\n    uint_var8 = uint_var7 - 1;\n    if (0x1fffff < uint_var10) {\n      uint_var9 = uint_var10 & 1;\n      uint_var10 = uint_var10 >> 1;\n      byte_var = (byte)uint_var12;\n      uint_var12 = (uint)(uint_var9 != 0) << 0x1f | uint_var12 >> 1;\n      uint_var11 = (uint)(byte_var & 1) << 0x1f | uint_var11 >> 1;\n      uint_var8 = uint_var7;\n      if (0xffbfffff < uint_var7 * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    bool_var2 = 0x7fffffff < uint_var11;\n    if (uint_var11 == 0x80000000) {\n      bool_var2 = (uint_var12 & 1) != 0;\n    }\n    return CONCAT44(uint_var10 + uint_var8 * 0x100000 + (uint)CARRY4(uint_var12,(uint)bool_var2) | uint_var4,\n                    uint_var12 + bool_var2);\n  }\n  bool_var1 = (uint_var11 & 0x80000000) != 0;\n  uint_var11 = uint_var11 << 1;\n  uint_var8 = uint_var12 * 2;\n  bool_var2 = CARRY4(uint_var12,uint_var12);\n  uint_var12 = uint_var12 * 2 + (uint)bool_var1;\n  uint_var10 = uint_var10 * 2 + (uint)(bool_var2 || CARRY4(uint_var8,(uint)bool_var1));\n  uint_var8 = uint_var7 - 2;\n  if (uint_var7 - 1 != 0 && 0xfffff < uint_var10) goto LAB_080083e0;\n  uint_var3 = uint_var12;\n  uint_var7 = uint_var10;\n  if (uint_var10 == 0) {\n    uint_var3 = 0;\n    uint_var7 = uint_var12;\n  }\n  temp_var2 = count_leading_zeroes(uint_var7);\n  if (uint_var10 == 0) {\n    temp_var2 = temp_var2 + 0x20;\n  }\n  uint_var12 = temp_var2 - 0xb;\n  bool_var3 = SBORROW4(uint_var12,0x20);\n  uint_var10 = temp_var2 - 0x2b;\n  bool_var2 = (int)uint_var10 < 0;\n  bool_var1 = uint_var10 == 0;\n  if ((int)uint_var12 < 0x20) {\n    bool_var3 = SCARRY4(uint_var10,0xc);\n    temp_var2 = temp_var2 + -0x1f;\n    bool_var2 = temp_var2 < 0;\n    bool_var1 = temp_var2 == 0;\n    uint_var10 = uint_var12;\n    if (!bool_var1 && bool_var2 == bool_var3) {\n      uint_var3 = uint_var7 << (uint_var12 & 0xff);\n      uint_var7 = uint_var7 >> (0xcU - temp_var2 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bool_var1 || bool_var2 != bool_var3) {\n    uint_var11 = 0x20 - uint_var10;\n  }\n  uint_var7 = uint_var7 << (uint_var10 & 0xff);\n  if (bool_var1 || bool_var2 != bool_var3) {\n    uint_var7 = uint_var7 | uint_var3 >> (uint_var11 & 0xff);\n  }\n  if (bool_var1 || bool_var2 != bool_var3) {\n    uint_var3 = uint_var3 << (uint_var10 & 0xff);\n  }\nLAB_08008458:\n  if ((int)uint_var12 <= (int)uint_var8) {\n    return CONCAT44(uint_var7 + (uint_var8 - uint_var12) * 0x100000 | uint_var4,uint_var3);\n  }\n  uint_var10 = ~(uint_var8 - uint_var12);\n  if ((int)uint_var10 < 0x1f) {\n    temp_var2 = uint_var10 - 0x13;\n    if (temp_var2 != 0 && temp_var2 < 0 == SCARRY4(uint_var10 - 0x1f,0xc)) {\n      return CONCAT44(uint_var9,uint_var3 >> (0x20 - (0xcU - temp_var2) & 0xff) | uint_var7 << (0xcU - temp_var2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    uint_var10 = uint_var10 + 1;\n    return CONCAT44(uint_var4 | uint_var7 >> (uint_var10 & 0xff),\n                    uint_var3 >> (uint_var10 & 0xff) | uint_var7 << (0x20 - uint_var10 & 0xff));\n  }\n  return CONCAT44(uint_var9,uint_var7 >> (uint_var10 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080082c8",
            "calling": [],
            "imported": false,
            "current_name": "compute_result_080082c8"
        },
        "FUN_08006718": {
            "renaming": {
                "FUN_08006718": "configure_oscillators_08006718",
                "RCC_OscInitStruct": "oscConfig",
                "uVar1": "leadingZeroesCount",
                "result_2": "unused_result_2",
                "result_3": "unused_result_3",
                "result_4": "unused_result_4",
                "result_5": "unused_result_5",
                "result_6": "unused_result_6",
                "result_7": "unused_result_7",
                "result": "unused_result",
                "result_1": "unused_result_1"
            },
            "code": "\nvoid ConfigureOscillators_08006718(RCC_OscInitTypeDef *oscConfig)\n\n{\n  uint leadingZeroesCount;\n  uint32_t unused_result_2;\n  uint32_t unused_result_3;\n  uint32_t unused_result_4;\n  uint32_t unused_result_5;\n  uint32_t unused_result_6;\n  uint32_t unused_result_7;\n  uint32_t unused_result;\n  uint32_t unused_result_1;\n  \n  oscConfig->OscillatorType = 0xf;\n  if ((*DAT_080068b8 & 0x40000) == 0x40000) {\n    oscConfig->HSEState = 5;\n  }\n  else if ((*DAT_080068b8 & 0x10000) == 0x10000) {\n    oscConfig->HSEState = 1;\n  }\n  else {\n    oscConfig->HSEState = 0;\n  }\n  if ((*DAT_080068b8 & 1) == 1) {\n    oscConfig->HSIState = 1;\n  }\n  else {\n    oscConfig->HSIState = 0;\n  }\n  leadingZeroesCount = count_leading_zeroes(0x1f000000);\n  oscConfig->HSICalibrationValue = (*DAT_080068b8 & 0xf8) >> (leadingZeroesCount & 0xff);\n  if ((DAT_080068b8[0x1c] & 4) == 4) {\n    oscConfig->LSEState = 5;\n  }\n  else if ((DAT_080068b8[0x1c] & 1) == 1) {\n    oscConfig->LSEState = 1;\n  }\n  else {\n    oscConfig->LSEState = 0;\n  }\n  if ((DAT_080068b8[0x1d] & 1) == 1) {\n    oscConfig->LSIState = 1;\n  }\n  else {\n    oscConfig->LSIState = 0;\n  }\n  if ((*DAT_080068b8 & 0x1000000) == 0x1000000) {\n    (oscConfig->PLL).PLLState = 2;\n  }\n  else {\n    (oscConfig->PLL).PLLState = 1;\n  }\n  (oscConfig->PLL).PLLSource = DAT_080068b8[1] & 0x400000;\n  (oscConfig->PLL).PLLM = DAT_080068b8[1] & 0x3f;\n  leadingZeroesCount = count_leading_zeroes(0x3fe0000);\n  (oscConfig->PLL).PLLN = (DAT_080068b8[1] & 0x7fc0) >> (leadingZeroesCount & 0xff);\n  leadingZeroesCount = count_leading_zeroes(0xc000);\n  (oscConfig->PLL).PLLP = ((DAT_080068b8[1] & 0x30000) + 0x10000) * 2 >> (leadingZeroesCount & 0xff);\n  leadingZeroesCount = count_leading_zeroes(0xf0);\n  (oscConfig->PLL).PLLQ = (DAT_080068b8[1] & 0xf000000) >> (leadingZeroesCount & 0xff);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006718",
            "calling": [],
            "imported": false,
            "current_name": "configure_oscillators_08006718"
        },
        "FUN_08007a10": {
            "renaming": {
                "FUN_08007a10": "enable_timers_08007a10",
                "TIM_TypeDef": "TimerType",
                "tim": "timer"
            },
            "code": "\nvoid enableTimers_08007a10(TimerType *timer)\n\n{\n  if (timer == (TimerType *)&DAT_40000000) {\n    *(uint *)(DAT_08007a64 + 0x40) = *(uint *)(DAT_08007a64 + 0x40) | 1;\n  }\n  else if (timer == DAT_08007a68) {\n    *(uint *)(DAT_08007a64 + 0x40) = *(uint *)(DAT_08007a64 + 0x40) | 2;\n  }\n  else if (timer == DAT_08007a6c) {\n    *(uint *)(DAT_08007a64 + 0x40) = *(uint *)(DAT_08007a64 + 0x40) | 4;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007a10",
            "calling": [
                "step_timer_init",
                "g540_timer_init"
            ],
            "imported": false,
            "current_name": "enable_timers_08007a10"
        },
        "FUN_0800856c": {
            "renaming": {
                "FUN_0800856c": "process_uint_0800856c",
                "param_1": "input_value",
                "uVar1": "result_low",
                "uVar2": "abs_input",
                "uVar3": "shift_count",
                "iVar4": "leading_zeroes",
                "uVar5": "temp_var",
                "uVar6": "sign_bit",
                "in_r12": "right_shift_count",
                "bVar7": "is_negative_1",
                "bVar8": "is_zero_1",
                "bVar9": "is_carry_1"
            },
            "code": "\nulonglong process_uint_0800856c(uint input_value)\n\n{\n  uint result_low;\n  uint abs_input;\n  uint shift_count;\n  int leading_zeroes;\n  uint temp_var;\n  uint sign_bit;\n  uint right_shift_count;\n  bool is_negative_1;\n  bool is_zero_1;\n  bool is_carry_1;\n  \n  if (input_value == 0) {\n    return 0;\n  }\n  sign_bit = input_value & 0x80000000;\n  abs_input = input_value;\n  if ((int)sign_bit < 0) {\n    abs_input = -input_value;\n  }\n  result_low = 0;\n  leading_zeroes = count_leading_zeroes(abs_input);\n  temp_var = leading_zeroes + 0x15;\n  is_carry_1 = SBORROW4(temp_var,0x20);\n  shift_count = leading_zeroes - 0xb;\n  is_negative_1 = (int)shift_count < 0;\n  is_zero_1 = shift_count == 0;\n  if ((int)temp_var < 0x20) {\n    is_carry_1 = SCARRY4(shift_count,0xc);\n    leading_zeroes = leading_zeroes + 1;\n    is_negative_1 = leading_zeroes < 0;\n    is_zero_1 = leading_zeroes == 0;\n    shift_count = temp_var;\n    if (!is_zero_1 && is_negative_1 == is_carry_1) {\n      result_low = abs_input << (temp_var & 0xff);\n      abs_input = abs_input >> (0xcU - leading_zeroes & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (is_zero_1 || is_negative_1 != is_carry_1) {\n    right_shift_count = 0x20 - shift_count;\n  }\n  abs_input = abs_input << (shift_count & 0xff);\n  if (is_zero_1 || is_negative_1 != is_carry_1) {\n    abs_input = abs_input | 0U >> (right_shift_count & 0xff);\n  }\n  if (is_zero_1 || is_negative_1 != is_carry_1) {\n    result_low = 0 << (shift_count & 0xff);\n  }\nLAB_08008458:\n  if ((int)temp_var < 0x433) {\n    return CONCAT44(abs_input + (0x432 - temp_var) * 0x100000 | sign_bit,result_low);\n  }\n  shift_count = ~(0x432 - temp_var);\n  if (0x1e < (int)shift_count) {\n    return CONCAT44(input_value,abs_input >> (shift_count - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leading_zeroes = shift_count - 0x13;\n  if (leading_zeroes == 0 || leading_zeroes < 0 != SCARRY4(shift_count - 0x1f,0xc)) {\n    shift_count = shift_count + 1;\n    return CONCAT44(sign_bit | abs_input >> (shift_count & 0xff),\n                    result_low >> (shift_count & 0xff) | abs_input << (0x20 - shift_count & 0xff));\n  }\n  return CONCAT44(input_value,result_low >> (0x20 - (0xcU - leading_zeroes) & 0xff) | abs_input << (0xcU - leading_zeroes & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800856c",
            "calling": [
                "__ieee754_rem_pio2",
                "calculate_trapezoid_for_block",
                "__kernel_rem_pio2"
            ],
            "imported": false,
            "current_name": "process_uint_0800856c"
        },
        "FUN_08008b00": {
            "renaming": {
                "FUN_08008b00": "call_nedf2_and_return_08008b00",
                "param_1": "input_value"
            },
            "code": "\nundefined4 call_nedf2_and_return_08008b00(undefined4 input_value)\n\n{\n  __nedf2();\n  return input_value;\n}\n\n",
            "called": [
                "__nedf2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b00",
            "calling": [
                "__aeabi_dcmplt",
                "__aeabi_dcmpeq",
                "__aeabi_dcmple",
                "__aeabi_cdrcmple"
            ],
            "imported": false,
            "current_name": "call_nedf2_and_return_08008b00"
        },
        "FUN_0800585c": {
            "renaming": {
                "FUN_0800585c": "update_system_state_0800585c"
            },
            "code": "\nvoid updateSystemState_0800585c(void)\n\n{\n  if (PTR_sys_08005878[1] == '\\x02') {\n    PTR_sys_08005878[1] = 3;\n    st_wake_up();\n  }\n  return;\n}\n\n",
            "called": [
                "st_wake_up"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800585c",
            "calling": [
                "protocol_execute_runtime",
                "mc_go_home",
                "mc_line"
            ],
            "imported": false,
            "current_name": "update_system_state_0800585c"
        },
        "FUN_08008cd0": {
            "renaming": {
                "FUN_08008cd0": "floating_point_operation_08008cd0",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "unusedParam",
                "param_4": "tempParam",
                "iVar1": "tempInt1",
                "uVar2": "unsignedVar2",
                "uVar3": "unsignedVar3",
                "uVar4": "unsignedVar4",
                "uVar5": "unsignedVar5",
                "uVar6": "unsignedVar6",
                "iVar7": "tempInt2",
                "bVar8": "boolVar"
            },
            "code": "\nuint floatingPointOperation_08008cd0(uint input1,uint input2,undefined4 unusedParam,uint tempParam)\n\n{\n  int tempInt1;\n  uint unsignedVar2;\n  uint unsignedVar3;\n  uint unsignedVar4;\n  uint unsignedVar5;\n  uint unsignedVar6;\n  int tempInt2;\n  bool boolVar;\n  \n  unsignedVar2 = input1 ^ 0x80000000;\n  unsignedVar4 = input1 << 1;\n  boolVar = unsignedVar4 == 0;\n  if (!boolVar) {\n    tempParam = input2 << 1;\n    boolVar = tempParam == 0;\n  }\n  if (!boolVar) {\n    boolVar = unsignedVar4 == tempParam;\n  }\n  tempInt2 = (int)unsignedVar4 >> 0x18;\n  if (!boolVar) {\n    boolVar = tempInt2 == -1;\n  }\n  if (!boolVar) {\n    boolVar = (int)tempParam >> 0x18 == -1;\n  }\n  if (boolVar) {\n    tempInt1 = (int)(input2 << 1) >> 0x18;\n    if (tempInt2 == -1 || tempInt1 == -1) {\n      unsignedVar4 = input2;\n      if (tempInt2 == -1) {\n        unsignedVar4 = unsignedVar2;\n      }\n      if (tempInt2 != -1 || tempInt1 != -1) {\n        input2 = unsignedVar4;\n      }\n      boolVar = (unsignedVar4 & 0x7fffff) == 0;\n      if (boolVar) {\n        boolVar = (input2 & 0x7fffff) == 0;\n      }\n      if (boolVar) {\n        boolVar = unsignedVar4 == input2;\n      }\n      if (!boolVar) {\n        unsignedVar4 = unsignedVar4 | 0x400000;\n      }\n      return unsignedVar4;\n    }\n    if (((input1 ^ input2) & 0x7fffffff) != 0) {\n      if (unsignedVar4 == 0) {\n        unsignedVar2 = input2;\n      }\n      return unsignedVar2;\n    }\n    if (unsignedVar2 != input2) {\n      return 0;\n    }\n    if ((unsignedVar4 & 0xff000000) == 0) {\n      input1 = input1 << 1;\n      if ((unsignedVar2 & 0x80000000) != 0) {\n        input1 = input1 | 0x80000000;\n      }\n      return input1;\n    }\n    if (unsignedVar4 < 0xfe000000) {\n      return unsignedVar2 + 0x800000;\n    }\n    unsignedVar2 = unsignedVar2 & 0x80000000;\nLAB_08008e12:\n    return unsignedVar2 | 0x7f800000;\n  }\n  unsignedVar4 = unsignedVar4 >> 0x18;\n  tempParam = tempParam >> 0x18;\n  unsignedVar6 = tempParam - unsignedVar4;\n  boolVar = unsignedVar6 != 0;\n  unsignedVar5 = unsignedVar4;\n  if (boolVar && unsignedVar4 <= tempParam) {\n    unsignedVar5 = unsignedVar4 + unsignedVar6;\n  }\n  if (boolVar && unsignedVar4 <= tempParam) {\n    input2 = input2 ^ unsignedVar2;\n  }\n  if (boolVar && unsignedVar4 <= tempParam) {\n    unsignedVar2 = unsignedVar2 ^ input2;\n  }\n  if (boolVar && unsignedVar4 <= tempParam) {\n    input2 = input2 ^ unsignedVar2;\n  }\n  if (tempParam < unsignedVar4) {\n    unsignedVar6 = -unsignedVar6;\n  }\n  if (0x19 < unsignedVar6) {\n    return unsignedVar2;\n  }\n  unsignedVar4 = unsignedVar2 & 0xffffff | 0x800000;\n  if ((unsignedVar2 & 0x80000000) != 0) {\n    unsignedVar4 = -unsignedVar4;\n  }\n  unsignedVar3 = input2 & 0xffffff | 0x800000;\n  if ((input2 & 0x80000000) != 0) {\n    unsignedVar3 = -unsignedVar3;\n  }\n  if (unsignedVar5 == unsignedVar6) {\n    unsignedVar3 = unsignedVar3 ^ 0x800000;\n    if (unsignedVar5 == 0) {\n      unsignedVar4 = unsignedVar4 ^ 0x800000;\n      unsignedVar5 = 1;\n    }\n    else {\n      unsignedVar6 = unsignedVar6 - 1;\n    }\n  }\n  unsignedVar4 = unsignedVar4 + ((int)unsignedVar3 >> (unsignedVar6 & 0xff));\n  unsignedVar3 = unsignedVar3 << (0x20 - unsignedVar6 & 0xff);\n  unsignedVar2 = unsignedVar4 & 0x80000000;\n  if ((int)unsignedVar4 < 0) {\n    boolVar = unsignedVar3 != 0;\n    unsignedVar3 = -unsignedVar3;\n    unsignedVar4 = -unsignedVar4 - (uint)boolVar;\n  }\n  if (unsignedVar4 < 0x800000) {\n    unsignedVar6 = unsignedVar3 & 0x80000000;\n    unsignedVar3 = unsignedVar3 << 1;\n    unsignedVar4 = unsignedVar4 * 2 + (uint)(unsignedVar6 != 0);\n    unsignedVar6 = unsignedVar5 - 2;\n    if (unsignedVar5 - 1 == 0 || unsignedVar4 < 0x800000) {\n      tempInt2 = count_leading_zeroes(unsignedVar4);\n      unsignedVar5 = tempInt2 - 8;\n      unsignedVar4 = unsignedVar4 << (unsignedVar5 & 0xff);\n      if ((int)unsignedVar6 < (int)unsignedVar5) {\n        unsignedVar4 = unsignedVar4 >> (-(unsignedVar6 - unsignedVar5) & 0xff);\n      }\n      else {\n        unsignedVar4 = unsignedVar4 + (unsignedVar6 - unsignedVar5) * 0x800000;\n      }\n      return unsignedVar4 | unsignedVar2;\n    }\n  }\n  else {\n    unsignedVar6 = unsignedVar5 - 1;\n    if (0xffffff < unsignedVar4) {\n      unsignedVar6 = unsignedVar4 & 1;\n      unsignedVar4 = unsignedVar4 >> 1;\n      unsignedVar3 = (uint)(unsignedVar6 != 0) << 0x1f | unsignedVar3 >> 1;\n      unsignedVar6 = unsignedVar5;\n      if (0xfd < unsignedVar5) goto LAB_08008e12;\n    }\n  }\n  unsignedVar4 = unsignedVar4 + unsignedVar6 * 0x800000 + (uint)(0x7fffffff < unsignedVar3);\n  if (unsignedVar3 == 0x80000000) {\n    unsignedVar4 = unsignedVar4 & 0xfffffffe;\n  }\n  return unsignedVar4 | unsignedVar2;\n}\n\n",
            "called": [
                "__addsf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008cd0",
            "calling": [],
            "imported": false,
            "current_name": "floating_point_operation_08008cd0"
        },
        "FUN_0800597c": {
            "renaming": {
                "FUN_0800597c": "trigger_software_interrupt_0800597c"
            },
            "code": "\nuint32_t trigger_software_interrupt_0800597c(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800597c",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "trigger_software_interrupt_0800597c"
        },
        "FUN_08009314": {
            "renaming": {
                "FUN_08009314": "infinite_loop_08009314"
            },
            "code": "\nvoid infiniteLoop_08009314(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "DMA1_Stream3_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009314",
            "calling": [
                "DMA1_Stream3_IRQHandler"
            ],
            "imported": false,
            "current_name": "infinite_loop_08009314"
        },
        "FUN_08009798": {
            "renaming": {
                "FUN_08009798": "process_double_08009798",
                "__x": "input_double",
                "in_r1": "input_int",
                "iVar1": "shifted_int",
                "in_d0": "result_double"
            },
            "code": "\ndouble process_double_08009798(double input_double)\n\n{\n  int input_int;\n  int shifted_int;\n  double result_double;\n  \n  shifted_int = ((uint)(input_int << 1) >> 0x15) - 0x3ff;\n  if (shifted_int < 0x14) {\n    if (shifted_int < 0) {\n      return result_double;\n    }\n  }\n  else {\n    if (shifted_int < 0x34) {\n      return result_double;\n    }\n    if (shifted_int != 0x400) {\n      return result_double;\n    }\n    result_double = (double)__aeabi_dadd();\n  }\n  return result_double;\n}\n\n",
            "called": [
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009798",
            "calling": [
                "protocol_execute_line",
                "gc_execute_line",
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "process_double_08009798"
        },
        "FUN_08008cd8": {
            "renaming": {
                "FUN_08008cd8": "calculate_result_08008cd8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "unused_param",
                "param_4": "temp_input",
                "iVar1": "int_var1",
                "uVar2": "uint_var2",
                "uVar3": "uint_var3",
                "uVar4": "uint_var4",
                "uVar5": "uint_var5",
                "uVar6": "uint_var6",
                "iVar7": "int_var7",
                "bVar8": "bool_var8"
            },
            "code": "\nuint calculate_result_08008cd8(uint input1,uint input2,undefined4 unused_param,uint temp_input)\n\n{\n  int int_var1;\n  uint uint_var2;\n  uint uint_var3;\n  uint uint_var4;\n  uint uint_var5;\n  uint uint_var6;\n  int int_var7;\n  bool bool_var8;\n  \n  uint_var2 = input2 ^ 0x80000000;\n  uint_var4 = input1 << 1;\n  bool_var8 = uint_var4 == 0;\n  if (!bool_var8) {\n    temp_input = input2 << 1;\n    bool_var8 = temp_input == 0;\n  }\n  if (!bool_var8) {\n    bool_var8 = uint_var4 == temp_input;\n  }\n  int_var7 = (int)uint_var4 >> 0x18;\n  if (!bool_var8) {\n    bool_var8 = int_var7 == -1;\n  }\n  if (!bool_var8) {\n    bool_var8 = (int)temp_input >> 0x18 == -1;\n  }\n  if (bool_var8) {\n    int_var1 = (int)(input2 << 1) >> 0x18;\n    if (int_var7 == -1 || int_var1 == -1) {\n      uint_var4 = uint_var2;\n      if (int_var7 == -1) {\n        uint_var4 = input1;\n      }\n      if (int_var7 != -1 || int_var1 != -1) {\n        uint_var2 = uint_var4;\n      }\n      bool_var8 = (uint_var4 & 0x7fffff) == 0;\n      if (bool_var8) {\n        bool_var8 = (uint_var2 & 0x7fffff) == 0;\n      }\n      if (bool_var8) {\n        bool_var8 = uint_var4 == uint_var2;\n      }\n      if (!bool_var8) {\n        uint_var4 = uint_var4 | 0x400000;\n      }\n      return uint_var4;\n    }\n    if (((input1 ^ uint_var2) & 0x7fffffff) != 0) {\n      if (uint_var4 == 0) {\n        input1 = uint_var2;\n      }\n      return input1;\n    }\n    if (input1 != uint_var2) {\n      return 0;\n    }\n    if ((uint_var4 & 0xff000000) == 0) {\n      uint_var2 = input1 << 1;\n      if ((input1 & 0x80000000) != 0) {\n        uint_var2 = uint_var2 | 0x80000000;\n      }\n      return uint_var2;\n    }\n    if (uint_var4 < 0xfe000000) {\n      return input1 + 0x800000;\n    }\n    input1 = input1 & 0x80000000;\nLAB_08008e12:\n    return input1 | 0x7f800000;\n  }\n  uint_var4 = uint_var4 >> 0x18;\n  temp_input = temp_input >> 0x18;\n  uint_var6 = temp_input - uint_var4;\n  bool_var8 = uint_var6 != 0;\n  uint_var5 = uint_var4;\n  if (bool_var8 && uint_var4 <= temp_input) {\n    uint_var5 = uint_var4 + uint_var6;\n  }\n  if (bool_var8 && uint_var4 <= temp_input) {\n    uint_var2 = uint_var2 ^ input1;\n  }\n  if (bool_var8 && uint_var4 <= temp_input) {\n    input1 = input1 ^ uint_var2;\n  }\n  if (bool_var8 && uint_var4 <= temp_input) {\n    uint_var2 = uint_var2 ^ input1;\n  }\n  if (temp_input < uint_var4) {\n    uint_var6 = -uint_var6;\n  }\n  if (0x19 < uint_var6) {\n    return input1;\n  }\n  uint_var4 = input1 & 0xffffff | 0x800000;\n  if ((input1 & 0x80000000) != 0) {\n    uint_var4 = -uint_var4;\n  }\n  uint_var3 = uint_var2 & 0xffffff | 0x800000;\n  if ((uint_var2 & 0x80000000) != 0) {\n    uint_var3 = -uint_var3;\n  }\n  if (uint_var5 == uint_var6) {\n    uint_var3 = uint_var3 ^ 0x800000;\n    if (uint_var5 == 0) {\n      uint_var4 = uint_var4 ^ 0x800000;\n      uint_var5 = 1;\n    }\n    else {\n      uint_var6 = uint_var6 - 1;\n    }\n  }\n  uint_var4 = uint_var4 + ((int)uint_var3 >> (uint_var6 & 0xff));\n  uint_var3 = uint_var3 << (0x20 - uint_var6 & 0xff);\n  input1 = uint_var4 & 0x80000000;\n  if ((int)uint_var4 < 0) {\n    bool_var8 = uint_var3 != 0;\n    uint_var3 = -uint_var3;\n    uint_var4 = -uint_var4 - (uint)bool_var8;\n  }\n  if (uint_var4 < 0x800000) {\n    uint_var2 = uint_var3 & 0x80000000;\n    uint_var3 = uint_var3 << 1;\n    uint_var4 = uint_var4 * 2 + (uint)(uint_var2 != 0);\n    uint_var2 = uint_var5 - 2;\n    if (uint_var5 - 1 == 0 || uint_var4 < 0x800000) {\n      int_var7 = count_leading_zeroes(uint_var4);\n      uint_var6 = int_var7 - 8;\n      uint_var4 = uint_var4 << (uint_var6 & 0xff);\n      if ((int)uint_var2 < (int)uint_var6) {\n        uint_var4 = uint_var4 >> (-(uint_var2 - uint_var6) & 0xff);\n      }\n      else {\n        uint_var4 = uint_var4 + (uint_var2 - uint_var6) * 0x800000;\n      }\n      return uint_var4 | input1;\n    }\n  }\n  else {\n    uint_var2 = uint_var5 - 1;\n    if (0xffffff < uint_var4) {\n      uint_var2 = uint_var4 & 1;\n      uint_var4 = uint_var4 >> 1;\n      uint_var3 = (uint)(uint_var2 != 0) << 0x1f | uint_var3 >> 1;\n      uint_var2 = uint_var5;\n      if (0xfd < uint_var5) goto LAB_08008e12;\n    }\n  }\n  uint_var4 = uint_var4 + uint_var2 * 0x800000 + (uint)(0x7fffffff < uint_var3);\n  if (uint_var3 == 0x80000000) {\n    uint_var4 = uint_var4 & 0xfffffffe;\n  }\n  return uint_var4 | input1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008cd8",
            "calling": [
                "max_allowable_speed",
                "estimate_acceleration_distance",
                "mc_arc",
                "report_realtime_status",
                "gc_execute_line",
                "intersection_distance",
                "plan_buffer_line",
                "mc_dwell"
            ],
            "imported": false,
            "current_name": "calculate_result_08008cd8"
        },
        "FUN_08007930": {
            "renaming": {
                "FUN_08007930": "debounce_handler_08007930",
                "puVar1": "debounce_ptr",
                "uVar2": "input_value",
                "uVar3": "previous_state",
                "iVar4": "index"
            },
            "code": "\nvoid debounce_handler_08007930(void)\n\n{\n  undefined *debounce_ptr;\n  uint32_t input_value;\n  uint previous_state;\n  int index;\n  uint32_t off_bits;\n  uint32_t on_bits;\n  uint32_t state;\n  DEBOUNCE_CTRL *db;\n  \n  debounce_ptr = PTR_debounce_080079b8;\n  if (*(int *)PTR_debounce_ready_080079bc != 0) {\n    index = *(int *)(PTR_debounce_080079b8 + 0x14);\n    input_value = debounce_input();\n    *(uint32_t *)(debounce_ptr + index * 4) = input_value;\n    if (*(int *)(debounce_ptr + 0x14) == 3) {\n      index = 0;\n    }\n    else {\n      index = *(int *)(debounce_ptr + 0x14) + 1;\n    }\n    *(int *)(debounce_ptr + 0x14) = index;\n    input_value = debounce_rd();\n    if (input_value != *(uint32_t *)(debounce_ptr + 0x10)) {\n      previous_state = *(uint *)(debounce_ptr + 0x10);\n      if ((~*(uint *)(debounce_ptr + 0x10) & input_value) != 0) {\n        debounce_on_handler(~*(uint *)(debounce_ptr + 0x10) & input_value);\n      }\n      if ((~input_value & previous_state) != 0) {\n        debounce_off_handler(~input_value & previous_state);\n      }\n      *(uint32_t *)(debounce_ptr + 0x10) = input_value;\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "debounce_on_handler",
                "debounce_input",
                "debounce_off_handler",
                "debounce_rd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007930",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "debounce_handler_08007930"
        },
        "FUN_080082ba": {
            "renaming": {
                "FUN_080082ba": "do_nothing_080082ba"
            },
            "code": "\nvoid do_nothing_080082ba(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080082ba",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "do_nothing_080082ba"
        },
        "FUN_08000188": {
            "renaming": {
                "FUN_08000188": "initialize_function_08000188",
                "param_1": "inputParam",
                "undefined": "void"
            },
            "code": "\nvoid * initializeFunction_08000188(void *inputParam)\n\n{\n  if (*PTR_completed_8911_080001a0 == '\\0') {\n    if (DAT_080001a4 != 0) {\n      inputParam = PTR__init_080001a8;\n    }\n    *PTR_completed_8911_080001a0 = 1;\n  }\n  return inputParam;\n}\n\n",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000188",
            "calling": [
                "__libc_fini_array"
            ],
            "imported": false,
            "current_name": "initialize_function_08000188"
        },
        "FUN_080082d0": {
            "renaming": {
                "FUN_080082d0": "floating_point_addition_080082d0",
                "param_1": "num1_low",
                "param_2": "num1_high",
                "param_3": "num2_low",
                "param_4": "num2_high",
                "iVar1": "temp_var1",
                "bVar2": "carry_bit",
                "uVar3": "intermediate_sum1",
                "uVar4": "intermediate_sum2",
                "uVar5": "intermediate_sum3",
                "uVar6": "num1_high_xor",
                "uVar7": "num1_high_masked",
                "iVar8": "shift_amt1",
                "uVar9": "num1_high_shifted",
                "uVar10": "num1_low_shifted",
                "uVar11": "exp_diff",
                "uVar12": "num2_low_shifted",
                "bVar13": "is_zero1",
                "bVar14": "is_zero2",
                "bVar15": "is_zero3"
            },
            "code": "\nulonglong floating_point_addition_080082d0(uint num1_low,uint num1_high,uint num2_low,uint num2_high)\n\n{\n  int temp_var1;\n  byte carry_bit;\n  uint intermediate_sum1;\n  uint intermediate_sum2;\n  uint intermediate_sum3;\n  uint num1_high_xor;\n  uint num1_high_masked;\n  int shift_amt1;\n  uint num1_high_shifted;\n  uint num1_low_shifted;\n  uint exp_diff;\n  uint num2_low_shifted;\n  bool is_zero1;\n  bool is_zero2;\n  bool is_zero3;\n  \n  num1_high_xor = num2_high ^ 0x80000000;\n  num1_high_shifted = num1_high << 1;\n  num2_high = num2_high << 1;\n  is_zero1 = ((num1_high ^ num1_high_xor) & 0x7fffffff) == 0;\n  is_zero2 = is_zero1 && num1_low == num2_low;\n  if (!is_zero1 || num1_low != num2_low) {\n    is_zero2 = (num1_high_shifted | num1_low) == 0;\n  }\n  if (!is_zero2) {\n    is_zero2 = (num2_high | num2_low) == 0;\n  }\n  shift_amt1 = (int)num1_high_shifted >> 0x15;\n  if (!is_zero2) {\n    is_zero2 = shift_amt1 == -1;\n  }\n  temp_var1 = (int)num2_high >> 0x15;\n  if (!is_zero2) {\n    is_zero2 = temp_var1 == -1;\n  }\n  if (is_zero2) {\n    if (shift_amt1 == -1 || temp_var1 == -1) {\n      num1_high_shifted = num1_high_xor;\n      exp_diff = num2_low;\n      if (shift_amt1 == -1) {\n        num1_high_shifted = num1_high;\n        exp_diff = num1_low;\n      }\n      if (shift_amt1 != -1 || temp_var1 != -1) {\n        num2_low = exp_diff;\n        num1_high_xor = num1_high_shifted;\n      }\n      is_zero2 = (exp_diff | num1_high_shifted << 0xc) == 0;\n      if (is_zero2) {\n        is_zero2 = (num2_low | num1_high_xor << 0xc) == 0;\n      }\n      if (is_zero2) {\n        is_zero2 = num1_high_shifted == num1_high_xor;\n      }\n      if (!is_zero2) {\n        num1_high_shifted = num1_high_shifted | 0x80000;\n      }\n      return CONCAT44(num1_high_shifted,exp_diff);\n    }\n    if (((num1_high ^ num1_high_xor) & 0x7fffffff) != 0 || num1_low != num2_low) {\n      if ((num1_high_shifted | num1_low) == 0) {\n        num1_low = num2_low;\n        num1_high = num1_high_xor;\n      }\n      return CONCAT44(num1_high,num1_low);\n    }\n    if (num1_high != num1_high_xor) {\n      return 0;\n    }\n    if (num1_high_shifted >> 0x15 == 0) {\n      is_zero2 = (num1_low & 0x80000000) != 0;\n      num1_high_xor = num1_high * 2 + (uint)is_zero2;\n      if (CARRY4(num1_high,num1_high) || CARRY4(num1_high * 2,(uint)is_zero2)) {\n        num1_high_xor = num1_high_xor | 0x80000000;\n      }\n      return CONCAT44(num1_high_xor,num1_low << 1);\n    }\n    if (num1_high_shifted < 0xffc00000) {\n      return CONCAT44(num1_high + 0x100000,num1_low);\n    }\n    num1_high = num1_high & 0x80000000;\nLAB_08008514:\n    return (ulonglong)(num1_high | 0x7ff00000) << 0x20;\n  }\n  num1_high_shifted = num1_high_shifted >> 0x15;\n  num2_high = num2_high >> 0x15;\n  exp_diff = num2_high - num1_high_shifted;\n  is_zero2 = exp_diff != 0;\n  if (num2_high < num1_high_shifted) {\n    exp_diff = -exp_diff;\n  }\n  num1_low_shifted = num1_low;\n  num1_high_masked = num1_high;\n  if (is_zero2 && num1_high_shifted <= num2_high) {\n    num1_high_shifted = num1_high_shifted + exp_diff;\n    num1_low_shifted = num2_low;\n    num1_high_masked = num1_high_xor;\n    num2_low = num1_low;\n    num1_high_xor = num1_high;\n  }\n  if (0x36 < exp_diff) {\n    return CONCAT44(num1_high_masked,num1_low_shifted);\n  }\n  intermediate_sum2 = num1_high_masked & 0xfffff | 0x100000;\n  if ((num1_high_masked & 0x80000000) != 0) {\n    is_zero2 = num1_low_shifted != 0;\n    num1_low_shifted = -num1_low_shifted;\n    intermediate_sum2 = -intermediate_sum2 - (uint)is_zero2;\n  }\n  num1_high_masked = num1_high_xor & 0xfffff | 0x100000;\n  if ((num1_high_xor & 0x80000000) != 0) {\n    is_zero2 = num2_low != 0;\n    num2_low = -num2_low;\n    num1_high_masked = -num1_high_masked - (uint)is_zero2;\n  }\n  if (num1_high_shifted == exp_diff) {\n    num1_high_masked = num1_high_masked ^ 0x100000;\n    if (num1_high_shifted == 0) {\n      intermediate_sum2 = intermediate_sum2 ^ 0x100000;\n      num1_high_shifted = 1;\n    }\n    else {\n      exp_diff = exp_diff - 1;\n    }\n  }\n  num1_high_xor = -exp_diff + 0x20;\n  if ((int)exp_diff < 0x21) {\n    num2_low_shifted = num2_low << (num1_high_xor & 0xff);\n    num2_low = num2_low >> (exp_diff & 0xff);\n    intermediate_sum1 = num1_low_shifted + num2_low;\n    intermediate_sum3 = num1_high_masked << (num1_high_xor & 0xff);\n    num1_high_xor = intermediate_sum1 + intermediate_sum3;\n    intermediate_sum2 = intermediate_sum2 + CARRY4(num1_low_shifted,num2_low) + ((int)num1_high_masked >> (exp_diff & 0xff)) +\n            (uint)CARRY4(intermediate_sum1,intermediate_sum3);\n  }\n  else {\n    num2_low_shifted = num1_high_masked << (-exp_diff + 0x40 & 0xff);\n    if (num2_low != 0) {\n      num2_low_shifted = num2_low_shifted | 2;\n    }\n    num1_high_masked = (int)num1_high_masked >> (exp_diff - 0x20 & 0xff);\n    num1_high_xor = num1_low_shifted + num1_high_masked;\n    intermediate_sum2 = intermediate_sum2 + ((int)num1_high_masked >> 0x1f) + (uint)CARRY4(num1_low_shifted,num1_high_masked);\n  }\n  num1_high = intermediate_sum2 & 0x80000000;\n  exp_diff = intermediate_sum2;\n  if ((int)intermediate_sum2 < 0) {\n    is_zero2 = num2_low_shifted == 0;\n    num2_low_shifted = -num2_low_shifted;\n    exp_diff = -num1_high_xor;\n    num1_high_xor = -(uint)!is_zero2 - num1_high_xor;\n    exp_diff = -(uint)(is_zero2 <= exp_diff) - intermediate_sum2;\n  }\n  if (0xfffff < exp_diff) {\n    num1_low_shifted = num1_high_shifted - 1;\n    if (0x1fffff < exp_diff) {\n      num1_low_shifted = exp_diff & 1;\n      exp_diff = exp_diff >> 1;\n      carry_bit = (byte)num1_high_xor;\n      num1_high_xor = (uint)(num1_low_shifted != 0) << 0x1f | num1_high_xor >> 1;\n      num2_low_shifted = (uint)(carry_bit & 1) << 0x1f | num2_low_shifted >> 1;\n      num1_low_shifted = num1_high_shifted;\n      if (0xffbfffff < num1_high_shifted * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    is_zero2 = 0x7fffffff < num2_low_shifted;\n    if (num2_low_shifted == 0x80000000) {\n      is_zero2 = (num1_high_xor & 1) != 0;\n    }\n    return CONCAT44(exp_diff + num1_low_shifted * 0x100000 + (uint)CARRY4(num1_high_xor,(uint)is_zero2) | num1_high,\n                    num1_high_xor + is_zero2);\n  }\n  is_zero1 = (num2_low_shifted & 0x80000000) != 0;\n  num2_low_shifted = num2_low_shifted << 1;\n  num1_low_shifted = num1_high_xor * 2;\n  is_zero2 = CARRY4(num1_high_xor,num1_high_xor);\n  num1_high_xor = num1_high_xor * 2 + (uint)is_zero1;\n  exp_diff = exp_diff * 2 + (uint)(is_zero2 || CARRY4(num1_low_shifted,(uint)is_zero1));\n  num1_low_shifted = num1_high_shifted - 2;\n  if (num1_high_shifted - 1 != 0 && 0xfffff < exp_diff) goto LAB_080083e0;\n  num1_high_masked = num1_high_xor;\n  num1_high_shifted = exp_diff;\n  if (exp_diff == 0) {\n    num1_high_masked = 0;\n    num1_high_shifted = num1_high_xor;\n  }\n  shift_amt1 = count_leading_zeroes(num1_high_shifted);\n  if (exp_diff == 0) {\n    shift_amt1 = shift_amt1 + 0x20;\n  }\n  exp_diff = shift_amt1 - 0xb;\n  is_zero3 = SBORROW4(exp_diff,0x20);\n  num1_high_xor = shift_amt1 - 0x2b;\n  is_zero2 = (int)num1_high_xor < 0;\n  is_zero1 = num1_high_xor == 0;\n  if ((int)exp_diff < 0x20) {\n    is_zero3 = SCARRY4(num1_high_xor,0xc);\n    shift_amt1 = shift_amt1 + -0x1f;\n    is_zero2 = shift_amt1 < 0;\n    is_zero1 = shift_amt1 == 0;\n    num1_high_xor = exp_diff;\n    if (!is_zero1 && is_zero2 == is_zero3) {\n      num1_high_masked = num1_high_shifted << (exp_diff & 0xff);\n      num1_high_shifted = num1_high_shifted >> (0xcU - shift_amt1 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (is_zero1 || is_zero2 != is_zero3) {\n    num2_low_shifted = 0x20 - num1_high_xor;\n  }\n  num1_high_shifted = num1_high_shifted << (num1_high_xor & 0xff);\n  if (is_zero1 || is_zero2 != is_zero3) {\n    num1_high_shifted = num1_high_shifted | num1_high_masked >> (num2_low_shifted & 0xff);\n  }\n  if (is_zero1 || is_zero2 != is_zero3) {\n    num1_high_masked = num1_high_masked << (num1_high_xor & 0xff);\n  }\nLAB_08008458:\n  if ((int)exp_diff <= (int)num1_low_shifted) {\n    return CONCAT44(num1_high_shifted + (num1_low_shifted - exp_diff) * 0x100000 | num1_high,num1_high_masked);\n  }\n  num1_high_xor = ~(num1_low_shifted - exp_diff);\n  if ((int)num1_high_xor < 0x1f) {\n    shift_amt1 = num1_high_xor - 0x13;\n    if (shift_amt1 != 0 && shift_amt1 < 0 == SCARRY4(num1_high_xor - 0x1f,0xc)) {\n      return CONCAT44(intermediate_sum2,num1_high_masked >> (0x20 - (0xcU - shift_amt1) & 0xff) | num1_high_shifted << (0xcU - shift_amt1 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    num1_high_xor = num1_high_xor + 1;\n    return CONCAT44(num1_high | num1_high_shifted >> (num1_high_xor & 0xff),\n                    num1_high_masked >> (num1_high_xor & 0xff) | num1_high_shifted << (0x20 - num1_high_xor & 0xff));\n  }\n  return CONCAT44(intermediate_sum2,num1_high_shifted >> (num1_high_xor - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080082d0",
            "calling": [
                "report_realtime_status",
                "__kernel_sin",
                "__ieee754_hypot",
                "sin",
                "atan",
                "__ieee754_sqrt",
                "__kernel_cos",
                "cos",
                "mc_arc",
                "__ieee754_atan2",
                "__ieee754_rem_pio2",
                "plan_buffer_line",
                "__kernel_rem_pio2"
            ],
            "imported": false,
            "current_name": "floating_point_addition_080082d0"
        },
        "FUN_08008e70": {
            "renaming": {
                "FUN_08008e70": "calculate_result_08008e70",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar1": "temp_input_2",
                "uVar2": "temp_input_1",
                "iVar3": "leading_zeroes",
                "uVar4": "shift_amount",
                "uVar5": "result",
                "iVar6": "intermediate_result",
                "uVar7": "shifted_input_1",
                "bVar8": "carry"
            },
            "code": "\nuint calculate_result_08008e70(uint input_1,uint input_2)\n\n{\n  uint temp_input_2;\n  uint temp_input_1;\n  int leading_zeroes;\n  uint shift_amount;\n  uint result;\n  int intermediate_result;\n  uint shifted_input_1;\n  bool carry;\n  \n  if ((input_1 | input_2) == 0) {\n    return input_1;\n  }\n  result = input_2 & 0x80000000;\n  if ((int)result < 0) {\n    carry = input_1 != 0;\n    input_1 = -input_1;\n    input_2 = -input_2 - (uint)carry;\n  }\n  temp_input_1 = input_1;\n  temp_input_2 = input_2;\n  if (input_2 == 0) {\n    temp_input_1 = 0;\n    temp_input_2 = input_1;\n  }\n  result = result | 0x5b000000;\n  if (input_2 == 0) {\n    result = result + 0xf0000000;\n  }\n  leading_zeroes = count_leading_zeroes(temp_input_2);\n  shift_amount = leading_zeroes - 8;\n  intermediate_result = (result - 0x800000) + shift_amount * -0x800000;\n  if (leading_zeroes < 8) {\n    shift_amount = temp_input_2 << (leading_zeroes + 0x18U & 0xff);\n    result = intermediate_result + ((temp_input_2 >> (0x20 - (leading_zeroes + 0x18U) & 0xff)) - ((int)shift_amount >> 0x1f));\n    if ((temp_input_1 | shift_amount << 1) == 0) {\n      result = result & ~(shift_amount >> 0x1f);\n    }\n    return result;\n  }\n  shifted_input_1 = temp_input_1 << (shift_amount & 0xff);\n  result = intermediate_result + (temp_input_2 << (shift_amount & 0xff)) +\n          (temp_input_1 >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < shifted_input_1);\n  if (shifted_input_1 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e70",
            "calling": [],
            "imported": false,
            "current_name": "calculate_result_08008e70"
        },
        "FUN_08009318": {
            "renaming": {
                "FUN_08009318": "process_double_value_08009318",
                "__x": "input_double",
                "in_r0": "lower_bits",
                "in_r1": "upper_bits",
                "uVar1": "shifted_value",
                "uVar2": "half_shifted_upper_bits",
                "in_d0": "result",
                "extraout_d0": "result_1",
                "extraout_d0_00": "result_2",
                "extraout_d0_01": "result_3",
                "uVar3": "temp_double"
            },
            "code": "\ndouble process_double_value_08009318(double input_double)\n\n{\n  uint lower_bits;\n  uint upper_bits;\n  uint shifted_value;\n  uint half_shifted_upper_bits;\n  double result;\n  double result_1;\n  double result_2;\n  double result_3;\n  undefined8 temp_double;\n  \n  half_shifted_upper_bits = (upper_bits << 1) >> 0x15;\n  shifted_value = half_shifted_upper_bits - 0x3ff;\n  if ((int)shifted_value < 0x14) {\n    if ((int)shifted_value < 0) {\n      temp_double = __aeabi_dadd(lower_bits,upper_bits,DAT_08009400,DAT_08009404);\n      __aeabi_dcmpgt((int)temp_double,(int)((ulonglong)temp_double >> 0x20),0,0);\n      result = result_2;\n    }\n    else if ((upper_bits & DAT_08009408 >> (shifted_value & 0xff) | lower_bits) != 0) {\n      temp_double = __aeabi_dadd(lower_bits,upper_bits,DAT_08009400,DAT_08009404);\n      __aeabi_dcmpgt((int)temp_double,(int)((ulonglong)temp_double >> 0x20),0,0);\n      result = result_1;\n    }\n  }\n  else if ((int)shifted_value < 0x34) {\n    if ((0xffffffffU >> (half_shifted_upper_bits - 0x413 & 0xff) & lower_bits) != 0) {\n      temp_double = __aeabi_dadd(lower_bits,upper_bits,DAT_08009400,DAT_08009404);\n      __aeabi_dcmpgt((int)temp_double,(int)((ulonglong)temp_double >> 0x20),0,0);\n      result = result_3;\n    }\n  }\n  else if (shifted_value == 0x400) {\n    result = (double)__aeabi_dadd();\n  }\n  return result;\n}\n\n",
            "called": [
                "__aeabi_dcmpgt",
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009318",
            "calling": [
                "homing_cycle",
                "calculate_trapezoid_for_block",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "process_double_value_08009318"
        },
        "FUN_080018cc": {
            "renaming": {
                "FUN_080018cc": "update_memory_value_080018cc",
                "x": "inputValue",
                "val": "updatedValue"
            },
            "code": "\nvoid updateMemoryValue_080018cc(uint32_t inputValue)\n\n{\n  uint32_t updatedValue;\n  \n  *(uint32_t *)(DAT_080018f8 + 0inputValue14) = inputValue | *(uint *)(DAT_080018f8 + 0inputValue14) & 0inputValuefffffaaf;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080018cc",
            "calling": [
                "homing_cycle"
            ],
            "imported": false,
            "current_name": "update_memory_value_080018cc"
        },
        "FUN_080079e0": {
            "renaming": {
                "FUN_080079e0": "set_irq_bit_080079e0",
                "IRQn": "irqNumber"
            },
            "code": "\nvoid setIRQBit_080079e0(irqNumber_Type irqNumber)\n\n{\n  *(int *)(DAT_08007a0c + ((uint)(int)irqNumber >> 5) * 4) = 1 << (irqNumber & 0x1fU);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080079e0",
            "calling": [
                "enable_tim_interrupt"
            ],
            "imported": false,
            "current_name": "set_irq_bit_080079e0"
        },
        "FUN_08006a58": {
            "renaming": {
                "FUN_08006a58": "set_interrupt_08006a58",
                "IRQn": "interruptNumber",
                "IRQn_Type": "InterruptType"
            },
            "code": "\nvoid setInterrupt_08006a58(InterruptType interruptNumber)\n\n{\n  *(int *)(DAT_08006a88 + (((uint)(int)interruptNumber >> 5) + 0x40) * 4) = 1 << (interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006a58",
            "calling": [
                "HAL_NVIC_SetPendingIRQ"
            ],
            "imported": false,
            "current_name": "set_interrupt_08006a58"
        },
        "FUN_08005a84": {
            "renaming": {
                "FUN_08005a84": "get_uw_tick_value_08005a84"
            },
            "code": "\nuint32_t get_uwTick_value_08005a84(void)\n\n{\n  return *(uint32_t *)PTR_uwTick_08005a94;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a84",
            "calling": [
                "get_current_usecs",
                "HAL_Delay",
                "SysTick_Handler",
                "HAL_RCC_ClockConfig",
                "HAL_RCC_OscConfig"
            ],
            "imported": false,
            "current_name": "get_uw_tick_value_08005a84"
        },
        "FUN_08008b10": {
            "renaming": {
                "FUN_08008b10": "is_floats_equal_08008b10",
                "in_ZR": "comparison_result"
            },
            "code": "\nbool is_floats_equal_08008b10(void)\n\n{\n  char comparison_result;\n  \n  __aeabi_cdcmpeq();\n  return comparison_result != '\\0';\n}\n\n",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b10",
            "calling": [
                "__ieee754_rem_pio2",
                "__kernel_rem_pio2"
            ],
            "imported": false,
            "current_name": "is_floats_equal_08008b10"
        },
        "FUN_08004e30": {
            "renaming": {
                "FUN_08004e30": "update_settings_08004e30",
                "parameter": "settingIndex",
                "value": "newValue",
                "uVar1": "tempResult1",
                "uVar2": "tempResult2",
                "iVar3": "comparisonResult",
                "uVar4": "tempResult4",
                "in_r1": "inputValue",
                "extraout_r1": "extraOutput1",
                "extraout_r1_00": "extraOutput1_00",
                "extraout_r1_01": "extraOutput1_01",
                "extraout_r1_02": "extraOutput1_02",
                "extraout_r1_03": "extraOutput1_03",
                "extraout_r1_04": "extraOutput1_04",
                "extraout_r1_05": "extraOutput1_05",
                "extraout_r1_06": "extraOutput1_06"
            },
            "code": "\nuint8_t updateSettings_08004e30(int settingIndex,float newValue)\n\n{\n  undefined tempResult1;\n  undefined2 tempResult2;\n  int comparisonResult;\n  undefined4 tempResult4;\n  uint inputValue;\n  undefined4 extraOutput1;\n  undefined4 extraOutput1_00;\n  undefined4 extraOutput1_01;\n  undefined4 extraOutput1_02;\n  undefined4 extraOutput1_03;\n  undefined4 extraOutput1_04;\n  undefined4 extraOutput1_05;\n  undefined4 extraOutput1_06;\n  \n  switch(settingIndex) {\n  case 0:\n  case 1:\n  case 2:\n    comparisonResult = __aeabi_fcmple(newValue,inputValue,0);\n    if (comparisonResult != 0) {\n      return '\\b';\n    }\n    *(uint *)(PTR_settings_080051a8 + settingIndex * 4) = inputValue;\n    break;\n  case 3:\n    comparisonResult = __aeabi_fcmplt(inputValue,DAT_080051ac);\n    if (comparisonResult != 0) {\n      return '\\t';\n    }\n    tempResult4 = __aeabi_f2d(inputValue);\n    round((double)CONCAT44(settingIndex,inputValue));\n    tempResult1 = __aeabi_d2uiz(tempResult4,extraOutput1);\n    PTR_settings_080051a8[0xd] = tempResult1;\n    break;\n  case 4:\n    *(uint *)(PTR_settings_080051a8 + 0x10) = inputValue;\n    break;\n  case 5:\n    *(uint *)(PTR_settings_080051a8 + 0x14) = inputValue;\n    break;\n  case 6:\n    tempResult4 = __aeabi_f2d(inputValue);\n    trunc((double)CONCAT44(settingIndex,inputValue));\n    tempResult2 = __aeabi_d2uiz(tempResult4,extraOutput1_00);\n    *(undefined2 *)(PTR_settings_080051a8 + 0x18) = tempResult2;\n    break;\n  case 7:\n    tempResult4 = __aeabi_f2d(inputValue);\n    round((double)CONCAT44(settingIndex,inputValue));\n    tempResult1 = __aeabi_d2uiz(tempResult4,extraOutput1_01);\n    PTR_settings_080051a8[0x3c] = tempResult1;\n    break;\n  case 8:\n    tempResult4 = __aeabi_fmul(inputValue,DAT_080051b0);\n    tempResult4 = __aeabi_fmul(tempResult4,DAT_080051b0);\n    *(undefined4 *)(PTR_settings_080051a8 + 0x20) = tempResult4;\n    break;\n  case 9:\n    *(uint *)(PTR_settings_080051a8 + 0x24) = inputValue & 0x7fffffff;\n    break;\n  case 10:\n    *(uint *)(PTR_settings_080051a8 + 0x1c) = inputValue;\n    break;\n  case 0xb:\n    tempResult4 = __aeabi_f2d(inputValue);\n    round((double)CONCAT44(settingIndex,inputValue));\n    tempResult1 = __aeabi_d2uiz(tempResult4,extraOutput1_02);\n    PTR_settings_080051a8[0x3e] = tempResult1;\n    break;\n  case 0xc:\n    tempResult4 = __aeabi_f2d(inputValue);\n    round((double)CONCAT44(settingIndex,inputValue));\n    tempResult1 = __aeabi_d2uiz(tempResult4,extraOutput1_03);\n    PTR_settings_080051a8[0x3d] = tempResult1;\n    break;\n  case 0xd:\n    comparisonResult = __aeabi_fcmpeq(inputValue,0);\n    if (comparisonResult == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 1;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xfe;\n    }\n    break;\n  case 0xe:\n    comparisonResult = __aeabi_fcmpeq(inputValue,0);\n    if (comparisonResult == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 2;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xfd;\n    }\n    break;\n  case 0xf:\n    comparisonResult = __aeabi_fcmpeq(inputValue,0);\n    if (comparisonResult == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 4;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xfb;\n    }\n    break;\n  case 0x10:\n    comparisonResult = __aeabi_fcmpeq(inputValue,0);\n    if (comparisonResult == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 8;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xf7;\n    }\n    limits_init();\n    break;\n  case 0x11:\n    comparisonResult = __aeabi_fcmpeq(inputValue,0);\n    if (comparisonResult == 0) {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] | 0x10;\n    }\n    else {\n      PTR_settings_080051a8[0x28] = PTR_settings_080051a8[0x28] & 0xef;\n    }\n    break;\n  case 0x12:\n    tempResult4 = __aeabi_f2d(inputValue);\n    trunc((double)CONCAT44(settingIndex,inputValue));\n    tempResult2 = __aeabi_d2uiz(tempResult4,extraOutput1_04);\n    *(undefined2 *)(PTR_settings_080051a8 + 0x2a) = tempResult2;\n    break;\n  case 0x13:\n    *(uint *)(PTR_settings_080051a8 + 0x2c) = inputValue;\n    break;\n  case 0x14:\n    *(uint *)(PTR_settings_080051a8 + 0x30) = inputValue;\n    break;\n  case 0x15:\n    tempResult4 = __aeabi_f2d(inputValue);\n    round((double)CONCAT44(settingIndex,inputValue));\n    tempResult2 = __aeabi_d2uiz(tempResult4,extraOutput1_05);\n    *(undefined2 *)(PTR_settings_080051a8 + 0x34) = tempResult2;\n    break;\n  case 0x16:\n    *(uint *)(PTR_settings_080051a8 + 0x38) = inputValue;\n    break;\n  case 0x17:\n    tempResult4 = __aeabi_f2d(inputValue);\n    trunc((double)CONCAT44(settingIndex,inputValue));\n    tempResult2 = __aeabi_d2uiz(tempResult4,extraOutput1_06);\n    *(undefined2 *)(PTR_settings_080051a8 + 0x1a) = tempResult2;\n    break;\n  default:\n    return '\\x06';\n  }\n  write_global_settings();\n  return '\\0';\n}\n\n",
            "called": [
                "__aeabi_fcmpeq",
                "__aeabi_fcmplt",
                "__aeabi_fmul",
                "write_global_settings",
                "limits_init",
                "__aeabi_fcmple",
                "__aeabi_d2uiz",
                "trunc",
                "__aeabi_f2d",
                "round"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e30",
            "calling": [
                "protocol_execute_line"
            ],
            "imported": false,
            "current_name": "update_settings_08004e30"
        },
        "FUN_0800736c": {
            "renaming": {
                "FUN_0800736c": "toggle_gpio_pin_0800736c",
                "GPIOx": "GPIO_port",
                "GPIO_Pin": "GPIO_pin"
            },
            "code": "\nvoid toggle_GPIO_pin_0800736c(GPIO_TypeDef *GPIO_port,uint16_t GPIO_pin)\n\n{\n  GPIO_port->ODR = GPIO_port->ODR ^ (uint)GPIO_pin;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800736c",
            "calling": [],
            "imported": false,
            "current_name": "toggle_gpio_pin_0800736c"
        },
        "FUN_08008c30": {
            "renaming": {
                "FUN_08008c30": "calculate_result_08008c30",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar1": "result",
                "uVar2": "temp_var1",
                "uVar3": "temp_var2",
                "in_r12": "temp_var3",
                "bVar4": "condition_A",
                "bVar5": "condition_B"
            },
            "code": "\nuint calculate_result_08008c30(uint input_1,uint input_2)\n\n{\n  uint result;\n  uint temp_var1;\n  uint temp_var2;\n  uint temp_var3;\n  bool condition_A;\n  bool condition_B;\n  \n  temp_var1 = input_2 * 2;\n  condition_B = temp_var1 < 0x70000000;\n  temp_var2 = temp_var1 + 0x90000000;\n  result = temp_var2;\n  if (!condition_B) {\n    temp_var3 = temp_var1 + 0x8fe00000;\n    result = temp_var3;\n  }\n  condition_A = result == 0;\n  if (!condition_B && temp_var2 >= 0x200000) {\n    condition_A = temp_var3 == 0x1fc00000;\n  }\n  if (((condition_B || temp_var2 < 0x200000) || 0x1fc00000 < temp_var3) || condition_A) {\n    if ((input_2 & 0x40000000) != 0) {\n      if (((int)temp_var1 >> 0x15 == -1) && ((input_1 | input_2 << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return input_2 & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(temp_var1 + 0x92e00000) < 0 != SCARRY4(temp_var2,0x2e00000)) {\n      return input_2 & 0x80000000;\n    }\n    temp_var1 = 0x18 - (temp_var1 + 0x92e00000 >> 0x15);\n    result = input_1 >> (temp_var1 & 0xff);\n    if (input_1 << (0x20 - temp_var1 & 0xff) != 0) {\n      result = result | 1;\n    }\n    temp_var2 = input_2 & 0x1fffff | 0x100000;\n    input_1 = result | temp_var2 << (0x20 - temp_var1 & 0xff);\n    temp_var2 = (temp_var2 >> (temp_var1 & 0xff)) << 1;\n  }\n  result = (input_2 & 0x80000000 | input_1 >> 0x1d) + temp_var2 * 4 + (uint)(0x7fffffff < input_1 * 8);\n  if (input_1 * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008c30",
            "calling": [
                "max_allowable_speed",
                "to_millimeters",
                "mc_arc",
                "homing_cycle",
                "report_gcode_parameters",
                "report_realtime_status",
                "gc_execute_line",
                "report_gcode_modes",
                "read_float",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "calculate_result_08008c30"
        },
        "FUN_080082d4": {
            "renaming": {
                "FUN_080082d4": "floating_point_addition_080082d4",
                "param_1": "mantissa1",
                "param_2": "exponent1",
                "param_3": "mantissa2",
                "param_4": "exponent2",
                "iVar1": "shiftedExponent2",
                "bVar2": "carryBit",
                "uVar3": "tempMantissa1",
                "uVar4": "tempMantissa2",
                "uVar5": "normalizedMantissa1",
                "uVar7": "shiftedExponent1",
                "uVar8": "tempResultMantissa",
                "uVar9": "normalizedExponent1",
                "uVar10": "exponentDifference",
                "uVar11": "tempShiftValue",
                "uVar12": "tempResultExponent",
                "bVar13": "expXorFlag",
                "bVar14": "specialCaseFlag",
                "bVar15": "carryFlag",
                "iVar6": "leadingZeroes"
            },
            "code": "\nulonglong floatingPointAddition_080082d4(uint mantissa1,uint exponent1,uint mantissa2,uint exponent2)\n\n{\n  int shiftedExponent2;\n  byte carryBit;\n  uint tempMantissa1;\n  uint tempMantissa2;\n  uint normalizedMantissa1;\n  int leadingZeroes;\n  uint shiftedExponent1;\n  uint tempResultMantissa;\n  uint normalizedExponent1;\n  uint exponentDifference;\n  uint tempShiftValue;\n  uint tempResultExponent;\n  bool expXorFlag;\n  bool specialCaseFlag;\n  bool carryFlag;\n  \n  shiftedExponent1 = exponent1 << 1;\n  normalizedExponent1 = exponent2 << 1;\n  expXorFlag = ((exponent1 ^ exponent2) & 0x7fffffff) == 0;\n  specialCaseFlag = expXorFlag && mantissa1 == mantissa2;\n  if (!expXorFlag || mantissa1 != mantissa2) {\n    specialCaseFlag = (shiftedExponent1 | mantissa1) == 0;\n  }\n  if (!specialCaseFlag) {\n    specialCaseFlag = (normalizedExponent1 | mantissa2) == 0;\n  }\n  leadingZeroes = (int)shiftedExponent1 >> 0x15;\n  if (!specialCaseFlag) {\n    specialCaseFlag = leadingZeroes == -1;\n  }\n  shiftedExponent2 = (int)normalizedExponent1 >> 0x15;\n  if (!specialCaseFlag) {\n    specialCaseFlag = shiftedExponent2 == -1;\n  }\n  if (specialCaseFlag) {\n    if (leadingZeroes == -1 || shiftedExponent2 == -1) {\n      normalizedExponent1 = exponent2;\n      shiftedExponent1 = mantissa2;\n      if (leadingZeroes == -1) {\n        normalizedExponent1 = exponent1;\n        shiftedExponent1 = mantissa1;\n      }\n      if (leadingZeroes != -1 || shiftedExponent2 != -1) {\n        mantissa2 = shiftedExponent1;\n        exponent2 = normalizedExponent1;\n      }\n      specialCaseFlag = (shiftedExponent1 | normalizedExponent1 << 0xc) == 0;\n      if (specialCaseFlag) {\n        specialCaseFlag = (mantissa2 | exponent2 << 0xc) == 0;\n      }\n      if (specialCaseFlag) {\n        specialCaseFlag = normalizedExponent1 == exponent2;\n      }\n      if (!specialCaseFlag) {\n        normalizedExponent1 = normalizedExponent1 | 0x80000;\n      }\n      return CONCAT44(normalizedExponent1,shiftedExponent1);\n    }\n    if (((exponent1 ^ exponent2) & 0x7fffffff) != 0 || mantissa1 != mantissa2) {\n      if ((shiftedExponent1 | mantissa1) == 0) {\n        mantissa1 = mantissa2;\n        exponent1 = exponent2;\n      }\n      return CONCAT44(exponent1,mantissa1);\n    }\n    if (exponent1 != exponent2) {\n      return 0;\n    }\n    if (shiftedExponent1 >> 0x15 == 0) {\n      specialCaseFlag = (mantissa1 & 0x80000000) != 0;\n      normalizedExponent1 = exponent1 * 2 + (uint)specialCaseFlag;\n      if (CARRY4(exponent1,exponent1) || CARRY4(exponent1 * 2,(uint)specialCaseFlag)) {\n        normalizedExponent1 = normalizedExponent1 | 0x80000000;\n      }\n      return CONCAT44(normalizedExponent1,mantissa1 << 1);\n    }\n    if (shiftedExponent1 < 0xffc00000) {\n      return CONCAT44(exponent1 + 0x100000,mantissa1);\n    }\n    exponent1 = exponent1 & 0x80000000;\nLAB_08008514:\n    return (ulonglong)(exponent1 | 0x7ff00000) << 0x20;\n  }\n  shiftedExponent1 = shiftedExponent1 >> 0x15;\n  normalizedExponent1 = normalizedExponent1 >> 0x15;\n  exponentDifference = normalizedExponent1 - shiftedExponent1;\n  specialCaseFlag = exponentDifference != 0;\n  if (normalizedExponent1 < shiftedExponent1) {\n    exponentDifference = -exponentDifference;\n  }\n  tempResultMantissa = mantissa1;\n  normalizedMantissa1 = exponent1;\n  if (specialCaseFlag && shiftedExponent1 <= normalizedExponent1) {\n    shiftedExponent1 = shiftedExponent1 + exponentDifference;\n    tempResultMantissa = mantissa2;\n    normalizedMantissa1 = exponent2;\n    mantissa2 = mantissa1;\n    exponent2 = exponent1;\n  }\n  if (0x36 < exponentDifference) {\n    return CONCAT44(normalizedMantissa1,tempResultMantissa);\n  }\n  normalizedExponent1 = normalizedMantissa1 & 0xfffff | 0x100000;\n  if ((normalizedMantissa1 & 0x80000000) != 0) {\n    specialCaseFlag = tempResultMantissa != 0;\n    tempResultMantissa = -tempResultMantissa;\n    normalizedExponent1 = -normalizedExponent1 - (uint)specialCaseFlag;\n  }\n  normalizedMantissa1 = exponent2 & 0xfffff | 0x100000;\n  if ((exponent2 & 0x80000000) != 0) {\n    specialCaseFlag = mantissa2 != 0;\n    mantissa2 = -mantissa2;\n    normalizedMantissa1 = -normalizedMantissa1 - (uint)specialCaseFlag;\n  }\n  if (shiftedExponent1 == exponentDifference) {\n    normalizedMantissa1 = normalizedMantissa1 ^ 0x100000;\n    if (shiftedExponent1 == 0) {\n      normalizedExponent1 = normalizedExponent1 ^ 0x100000;\n      shiftedExponent1 = 1;\n    }\n    else {\n      exponentDifference = exponentDifference - 1;\n    }\n  }\n  tempResultExponent = -exponentDifference + 0x20;\n  if ((int)exponentDifference < 0x21) {\n    tempShiftValue = mantissa2 << (tempResultExponent & 0xff);\n    mantissa2 = mantissa2 >> (exponentDifference & 0xff);\n    tempMantissa1 = tempResultMantissa + mantissa2;\n    tempMantissa2 = normalizedMantissa1 << (tempResultExponent & 0xff);\n    tempResultExponent = tempMantissa1 + tempMantissa2;\n    normalizedExponent1 = normalizedExponent1 + CARRY4(tempResultMantissa,mantissa2) + ((int)normalizedMantissa1 >> (exponentDifference & 0xff)) +\n            (uint)CARRY4(tempMantissa1,tempMantissa2);\n  }\n  else {\n    tempShiftValue = normalizedMantissa1 << (-exponentDifference + 0x40 & 0xff);\n    if (mantissa2 != 0) {\n      tempShiftValue = tempShiftValue | 2;\n    }\n    normalizedMantissa1 = (int)normalizedMantissa1 >> (exponentDifference - 0x20 & 0xff);\n    tempResultExponent = tempResultMantissa + normalizedMantissa1;\n    normalizedExponent1 = normalizedExponent1 + ((int)normalizedMantissa1 >> 0x1f) + (uint)CARRY4(tempResultMantissa,normalizedMantissa1);\n  }\n  exponent1 = normalizedExponent1 & 0x80000000;\n  exponentDifference = normalizedExponent1;\n  if ((int)normalizedExponent1 < 0) {\n    specialCaseFlag = tempShiftValue == 0;\n    tempShiftValue = -tempShiftValue;\n    exponentDifference = -tempResultExponent;\n    tempResultExponent = -(uint)!specialCaseFlag - tempResultExponent;\n    exponentDifference = -(uint)(specialCaseFlag <= exponentDifference) - normalizedExponent1;\n  }\n  if (0xfffff < exponentDifference) {\n    tempResultMantissa = shiftedExponent1 - 1;\n    if (0x1fffff < exponentDifference) {\n      normalizedExponent1 = exponentDifference & 1;\n      exponentDifference = exponentDifference >> 1;\n      carryBit = (byte)tempResultExponent;\n      tempResultExponent = (uint)(normalizedExponent1 != 0) << 0x1f | tempResultExponent >> 1;\n      tempShiftValue = (uint)(carryBit & 1) << 0x1f | tempShiftValue >> 1;\n      tempResultMantissa = shiftedExponent1;\n      if (0xffbfffff < shiftedExponent1 * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    specialCaseFlag = 0x7fffffff < tempShiftValue;\n    if (tempShiftValue == 0x80000000) {\n      specialCaseFlag = (tempResultExponent & 1) != 0;\n    }\n    return CONCAT44(exponentDifference + tempResultMantissa * 0x100000 + (uint)CARRY4(tempResultExponent,(uint)specialCaseFlag) | exponent1,\n                    tempResultExponent + specialCaseFlag);\n  }\n  expXorFlag = (tempShiftValue & 0x80000000) != 0;\n  tempShiftValue = tempShiftValue << 1;\n  tempResultMantissa = tempResultExponent * 2;\n  specialCaseFlag = CARRY4(tempResultExponent,tempResultExponent);\n  tempResultExponent = tempResultExponent * 2 + (uint)expXorFlag;\n  exponentDifference = exponentDifference * 2 + (uint)(specialCaseFlag || CARRY4(tempResultMantissa,(uint)expXorFlag));\n  tempResultMantissa = shiftedExponent1 - 2;\n  if (shiftedExponent1 - 1 != 0 && 0xfffff < exponentDifference) goto LAB_080083e0;\n  normalizedMantissa1 = tempResultExponent;\n  shiftedExponent1 = exponentDifference;\n  if (exponentDifference == 0) {\n    normalizedMantissa1 = 0;\n    shiftedExponent1 = tempResultExponent;\n  }\n  leadingZeroes = count_leading_zeroes(shiftedExponent1);\n  if (exponentDifference == 0) {\n    leadingZeroes = leadingZeroes + 0x20;\n  }\n  tempResultExponent = leadingZeroes - 0xb;\n  carryFlag = SBORROW4(tempResultExponent,0x20);\n  exponentDifference = leadingZeroes - 0x2b;\n  specialCaseFlag = (int)exponentDifference < 0;\n  expXorFlag = exponentDifference == 0;\n  if ((int)tempResultExponent < 0x20) {\n    carryFlag = SCARRY4(exponentDifference,0xc);\n    leadingZeroes = leadingZeroes + -0x1f;\n    specialCaseFlag = leadingZeroes < 0;\n    expXorFlag = leadingZeroes == 0;\n    exponentDifference = tempResultExponent;\n    if (!expXorFlag && specialCaseFlag == carryFlag) {\n      normalizedMantissa1 = shiftedExponent1 << (tempResultExponent & 0xff);\n      shiftedExponent1 = shiftedExponent1 >> (0xcU - leadingZeroes & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (expXorFlag || specialCaseFlag != carryFlag) {\n    tempShiftValue = 0x20 - exponentDifference;\n  }\n  shiftedExponent1 = shiftedExponent1 << (exponentDifference & 0xff);\n  if (expXorFlag || specialCaseFlag != carryFlag) {\n    shiftedExponent1 = shiftedExponent1 | normalizedMantissa1 >> (tempShiftValue & 0xff);\n  }\n  if (expXorFlag || specialCaseFlag != carryFlag) {\n    normalizedMantissa1 = normalizedMantissa1 << (exponentDifference & 0xff);\n  }\nLAB_08008458:\n  if ((int)tempResultExponent <= (int)tempResultMantissa) {\n    return CONCAT44(shiftedExponent1 + (tempResultMantissa - tempResultExponent) * 0x100000 | exponent1,normalizedMantissa1);\n  }\n  exponentDifference = ~(tempResultMantissa - tempResultExponent);\n  if ((int)exponentDifference < 0x1f) {\n    leadingZeroes = exponentDifference - 0x13;\n    if (leadingZeroes != 0 && leadingZeroes < 0 == SCARRY4(exponentDifference - 0x1f,0xc)) {\n      return CONCAT44(normalizedExponent1,normalizedMantissa1 >> (0x20 - (0xcU - leadingZeroes) & 0xff) | shiftedExponent1 << (0xcU - leadingZeroes & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    exponentDifference = exponentDifference + 1;\n    return CONCAT44(exponent1 | shiftedExponent1 >> (exponentDifference & 0xff),\n                    normalizedMantissa1 >> (exponentDifference & 0xff) | shiftedExponent1 << (0x20 - exponentDifference & 0xff));\n  }\n  return CONCAT44(normalizedExponent1,shiftedExponent1 >> (exponentDifference - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080082d4",
            "calling": [
                "scalbn",
                "__kernel_sin",
                "__ieee754_hypot",
                "atan",
                "__ieee754_sqrt",
                "__kernel_cos",
                "floor",
                "mc_arc",
                "__aeabi_drsub",
                "__ieee754_atan2",
                "ceil",
                "__ieee754_rem_pio2",
                "__kernel_rem_pio2",
                "trunc",
                "round"
            ],
            "imported": false,
            "current_name": "floating_point_addition_080082d4"
        },
        "FUN_08007bf0": {
            "renaming": {
                "FUN_08007bf0": "update_timer_08007bf0",
                "ticks": "timer_ticks",
                "saved": "saved_ticks",
                "TIMx": "timer_instance"
            },
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid update_timer_08007bf0(uint32_t timer_ticks)\n\n{\n  uint32_t saved_ticks;\n  TIM_TypeDef *timer_instance;\n  \n  _DAT_4000002c = timer_ticks;\n  if (timer_ticks <= _DAT_40000024) {\n    _DAT_40000024 = timer_ticks;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007bf0",
            "calling": [
                "set_step_events_per_minute"
            ],
            "imported": false,
            "current_name": "update_timer_08007bf0"
        },
        "FUN_08008590": {
            "renaming": {
                "FUN_08008590": "calculate_result_08008590",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "temp_var_1",
                "uVar2": "temp_var_2",
                "uVar3": "temp_var_3",
                "uVar4": "temp_var_4",
                "uVar5": "temp_var_5",
                "iVar6": "temp_var_6",
                "uVar7": "temp_var_7",
                "in_r12": "temp_var_r12",
                "bVar8": "bool_var_8",
                "bVar9": "bool_var_9",
                "bVar10": "bool_var_10"
            },
            "code": "\nulonglong calculate_result_08008590(uint input_1,undefined4 input_2,undefined4 input_3,uint input_4)\n\n{\n  uint temp_var_1;\n  uint temp_var_2;\n  uint temp_var_3;\n  uint temp_var_4;\n  uint temp_var_5;\n  int temp_var_6;\n  uint temp_var_7;\n  uint temp_var_r12;\n  bool bool_var_8;\n  bool bool_var_9;\n  bool bool_var_10;\n  \n  temp_var_5 = input_1 << 1;\n  bool_var_9 = temp_var_5 == 0;\n  temp_var_1 = (uint)((input_1 & 0x80000000) != 0) << 0x1f;\n  temp_var_4 = (uint)((int)temp_var_5 >> 3) >> 1;\n  temp_var_3 = temp_var_1 | temp_var_4;\n  input_1 = input_1 << 0x1d;\n  if (!bool_var_9) {\n    input_4 = temp_var_5 & 0xff000000;\n    bool_var_9 = input_4 == 0;\n  }\n  if (!bool_var_9) {\n    bool_var_9 = input_4 == 0xff000000;\n  }\n  if (!bool_var_9) {\n    return CONCAT44(temp_var_3,input_1) ^ 0x3800000000000000;\n  }\n  if ((temp_var_5 & 0xffffff) == 0) {\n    return CONCAT44(temp_var_3,input_1);\n  }\n  if (input_4 == 0xff000000) {\n    return CONCAT44(temp_var_3,input_1) | 0x8000000000000;\n  }\n  temp_var_2 = input_1;\n  temp_var_5 = temp_var_4;\n  if (temp_var_4 == 0) {\n    temp_var_2 = 0;\n    temp_var_5 = input_1;\n  }\n  temp_var_6 = count_leading_zeroes(temp_var_5);\n  if (temp_var_4 == 0) {\n    temp_var_6 = temp_var_6 + 0x20;\n  }\n  temp_var_7 = temp_var_6 - 0xb;\n  bool_var_10 = SBORROW4(temp_var_7,0x20);\n  temp_var_4 = temp_var_6 - 0x2b;\n  bool_var_9 = (int)temp_var_4 < 0;\n  bool_var_8 = temp_var_4 == 0;\n  if ((int)temp_var_7 < 0x20) {\n    bool_var_10 = SCARRY4(temp_var_4,0xc);\n    temp_var_6 = temp_var_6 + -0x1f;\n    bool_var_9 = temp_var_6 < 0;\n    bool_var_8 = temp_var_6 == 0;\n    temp_var_4 = temp_var_7;\n    if (!bool_var_8 && bool_var_9 == bool_var_10) {\n      temp_var_2 = temp_var_5 << (temp_var_7 & 0xff);\n      temp_var_5 = temp_var_5 >> (0xcU - temp_var_6 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (bool_var_8 || bool_var_9 != bool_var_10) {\n    temp_var_r12 = 0x20 - temp_var_4;\n  }\n  temp_var_5 = temp_var_5 << (temp_var_4 & 0xff);\n  if (bool_var_8 || bool_var_9 != bool_var_10) {\n    temp_var_5 = temp_var_5 | temp_var_2 >> (temp_var_r12 & 0xff);\n  }\n  if (bool_var_8 || bool_var_9 != bool_var_10) {\n    temp_var_2 = temp_var_2 << (temp_var_4 & 0xff);\n  }\nLAB_08008458:\n  if ((int)temp_var_7 < 0x381) {\n    return CONCAT44(temp_var_5 + (0x380 - temp_var_7) * 0x100000 | temp_var_1,temp_var_2);\n  }\n  temp_var_4 = ~(0x380 - temp_var_7);\n  if (0x1e < (int)temp_var_4) {\n    return CONCAT44(temp_var_3,temp_var_5 >> (temp_var_4 - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  temp_var_6 = temp_var_4 - 0x13;\n  if (temp_var_6 == 0 || temp_var_6 < 0 != SCARRY4(temp_var_4 - 0x1f,0xc)) {\n    temp_var_4 = temp_var_4 + 1;\n    return CONCAT44(temp_var_1 | temp_var_5 >> (temp_var_4 & 0xff),\n                    temp_var_2 >> (temp_var_4 & 0xff) | temp_var_5 << (0x20 - temp_var_4 & 0xff));\n  }\n  return CONCAT44(temp_var_3,temp_var_2 >> (0x20 - (0xcU - temp_var_6) & 0xff) | temp_var_5 << (0xcU - temp_var_6 & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008590",
            "calling": [
                "protocol_execute_line",
                "report_gcode_parameters",
                "report_realtime_status",
                "gc_execute_line",
                "calculate_trapezoid_for_block",
                "read_float",
                "max_allowable_speed",
                "to_millimeters",
                "mc_arc",
                "homing_cycle",
                "report_gcode_modes",
                "settings_store_global_setting",
                "plan_buffer_line",
                "mc_dwell"
            ],
            "imported": false,
            "current_name": "calculate_result_08008590"
        },
        "FUN_08007ad0": {
            "renaming": {
                "FUN_08007ad0": "initialize_timer_08007ad0",
                "TIMx": "timer"
            },
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid initialize_timer_08007ad0(void)\n\n{\n  TIM_TypeDef *timer;\n  \n  enable_tim_clock((TIM_TypeDef *)&DAT_40000000);\n  _DAT_40000000 = 0;\n  _DAT_40000004 = 0;\n  _DAT_40000008 = 0;\n  _DAT_4000000c = 0;\n  _DAT_40000010 = 0;\n  _DAT_40000018 = 0;\n  _DAT_4000001c = 0;\n  _DAT_40000020 = 0;\n  _DAT_40000024 = 0;\n  _DAT_40000028 =\n       (uint)((ulonglong)DAT_08007b6c * (ulonglong)*(uint *)PTR_SystemCoreClock_08007b68 >> 0x38) -\n       1;\n  _DAT_4000002c = 0;\n  _DAT_40000034 = 0;\n  _DAT_40000038 = 0;\n  _DAT_4000003c = 0;\n  _DAT_40000040 = 0;\n  _DAT_40000048 = 0;\n  _DAT_4000004c = 0;\n  enable_tim_interrupt((TIM_TypeDef *)&DAT_40000000,0,0);\n  return;\n}\n\n",
            "called": [
                "enable_tim_interrupt",
                "enable_tim_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007ad0",
            "calling": [
                "timers_init"
            ],
            "imported": false,
            "current_name": "initialize_timer_08007ad0"
        },
        "FUN_080005b4": {
            "renaming": {
                "FUN_080005b4": "process_gcode_line_080005b4",
                "line": "gcode_line",
                "puVar1": "temp_ptr",
                "uVar2": "temp_byte",
                "uVar3": "result",
                "iVar4": "statement_result",
                "fVar5": "temp_float",
                "uVar6": "temp_float4",
                "extraout_r1": "temp_extraout_r1",
                "extraout_r1_00": "temp_extraout_r1_00",
                "extraout_r1_01": "temp_extraout_r1_01",
                "extraout_r1_02": "temp_extraout_r1_02",
                "extraout_r1_03": "temp_extraout_r1_03",
                "extraout_r1_04": "temp_extraout_r1_04",
                "uVar7": "temp_uint",
                "fVar8": "temp_float2",
                "value_00": "temp_value_00",
                "seconds": "dwell_seconds",
                "extraout_d0": "temp_extraout_d0",
                "extraout_d0_00": "temp_extraout_d0_00",
                "extraout_d0_01": "temp_extraout_d0_01",
                "extraout_d0_02": "temp_extraout_d0_02",
                "extraout_d0_03": "temp_extraout_d0_03",
                "extraout_d0_04": "temp_extraout_d0_04",
                "extraout_d0_05": "temp_extraout_d0_05",
                "uVar9": "temp_uint8",
                "extraout_s2": "temp_extraout_s2",
                "extraout_s2_00": "temp_extraout_s2_00",
                "extraout_s2_01": "temp_extraout_s2_01",
                "extraout_s2_02": "temp_extraout_s2_02",
                "extraout_s2_03": "temp_extraout_s2_03",
                "extraout_s2_04": "temp_extraout_s2_04",
                "extraout_s2_05": "temp_extraout_s2_05",
                "extraout_s3": "temp_extraout_s3",
                "extraout_s3_00": "temp_extraout_s3_00",
                "extraout_s3_01": "temp_extraout_s3_01",
                "extraout_s3_02": "temp_extraout_s3_02",
                "extraout_s3_03": "temp_extraout_s3_03",
                "extraout_s3_04": "temp_extraout_s3_04",
                "extraout_s3_05": "temp_extraout_s3_05",
                "in_stack_ffffff48": "temp_in_stack_ffffff48",
                "in_stack_ffffff4c": "temp_in_stack_ffffff4c",
                "coord_data_2": "coordinate_data_2",
                "coord_data_1": "coordinate_data_1",
                "coord_data": "coordinate_data",
                "offset": "offset_values",
                "target": "target_values",
                "value": "parsed_value",
                "letter": "parsed_letter",
                "char_counter": "character_counter",
                "y": "y_value",
                "x": "x_value",
                "isclockwise": "is_clockwise",
                "h_x2_div_d": "h_x2_divided_by_d",
                "i_3": "index_3",
                "i_2": "index_2",
                "i_1": "index_1",
                "i": "index",
                "l": "l_value",
                "r": "r_value",
                "p": "p_value",
                "group_number": "group_num",
                "non_modal_action": "non_modal_act",
                "absolute_override": "abs_override",
                "inverse_feed_rate": "inv_feed_rate",
                "axis_words": "axis_word_flags",
                "modal_group_words": "modal_group_word_flags",
                "int_value": "integer_value"
            },
            "code": "\nuindexnt8_t process_gcode_line_080005b4(char_value *gcode_line)\n\n{\n  undefindexned *temp_ptr;\n  undefindexned temp_byte;\n  uindexnt8_t result;\n  indexnt statement_result;\n  fl_valueoat temp_float;\n  undefindexned4 temp_float4;\n  undefindexned4 temp_extraout_r1;\n  undefindexned4 temp_extraout_r1_00;\n  undefindexned4 temp_extraout_r1_01;\n  undefindexned4 temp_extraout_r1_02;\n  undefindexned4 temp_extraout_r1_03;\n  undefindexned4 temp_extraout_r1_04;\n  uindexnt temp_uint;\n  fl_valueoat temp_float2;\n  fl_valueoat temp_value_00;\n  fl_valueoat dwell_seconds;\n  undefindexned8 temp_extraout_d0;\n  undefindexned8 temp_extraout_d0_00;\n  undefindexned8 temp_extraout_d0_01;\n  undefindexned8 temp_extraout_d0_02;\n  undefindexned8 temp_extraout_d0_03;\n  undefindexned8 temp_uint8;\n  undefindexned8 temp_extraout_d0_04;\n  undefindexned8 temp_extraout_d0_05;\n  fl_valueoat temp_extraout_s2;\n  fl_valueoat temp_extraout_s2_00;\n  fl_valueoat temp_extraout_s2_01;\n  fl_valueoat temp_extraout_s2_02;\n  fl_valueoat temp_extraout_s2_03;\n  fl_valueoat temp_extraout_s2_04;\n  fl_valueoat temp_extraout_s2_05;\n  fl_valueoat temp_extraout_s3;\n  fl_valueoat temp_extraout_s3_00;\n  fl_valueoat temp_extraout_s3_01;\n  fl_valueoat temp_extraout_s3_02;\n  fl_valueoat temp_extraout_s3_03;\n  fl_valueoat temp_extraout_s3_04;\n  fl_valueoat temp_extraout_s3_05;\n  undefindexned4 temp_in_stack_ffffff48;\n  undefindexned4 temp_in_stack_ffffff4c;\n  fl_valueoat coordinate_data_2 [3];\n  fl_valueoat coordinate_data_1 [3];\n  fl_valueoat coordinate_data [3];\n  fl_valueoat offset_values [3];\n  fl_valueoat target_values [3];\n  fl_valueoat parsed_value;\n  char_value parsed_letter;\n  uindexnt8_t character_counter;\n  fl_valueoat y_value;\n  fl_valueoat x_value;\n  uindexnt8_t is_clockwise;\n  fl_valueoat h_x2_divided_by_d;\n  uindexnt8_t index_3;\n  uindexnt8_t index_2;\n  uindexnt8_t index_1;\n  uindexnt8_t index;\n  uindexnt8_t l_value;\n  fl_valueoat r_value;\n  fl_valueoat p_value;\n  uindexnt8_t group_num;\n  uindexnt8_t non_modal_act;\n  uindexnt8_t abs_override;\n  fl_valueoat inv_feed_rate;\n  uindexnt8_t axis_word_flags;\n  uindexnt16_t modal_group_word_flags;\n  indexnt integer_value;\n  \n  indexf (PTR_sy_values_08000808[1] == '\\x_value06') {\n    result = '\\f';\n  }\n  el_valuese {\n    character_counter = '\\0';\n    modal_group_word_flags = 0;\n    axis_word_flags = '\\0';\n    inv_feed_rate = DAT_0800080c;\n    abs_override = '\\0';\n    non_modal_act = '\\0';\n    memset(target_values,0,0x_valuec);\n    memset(offset_values,0,0x_valuec);\n    *PTR_gc_08000810 = 0;\n    group_num = '\\0';\n    whindexl_valuee (statement_result = nex_valuet_statement(&parsed_letter,&parsed_value,gcode_line,&character_counter), statement_result != 0) {\n      temp_float4 = __aeabindex_f2d(parsed_value);\n      tr_valueunc((doubl_valuee)CONCAT44(temp_in_stack_ffffff4c,temp_in_stack_ffffff48));\n      integer_value = __aeabindex_d2indexz(temp_float4,temp_extraout_r1);\n      indexf (parsed_letter == 'G') {\n        swindextch(integer_value) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 0x_value50:\n          group_num = '\\x_value02';\n          br_valueeak;\n        case 4:\n        case 10:\n        case 0x_value1c:\n        case 0x_value1e:\n        case 0x_value35:\n        case 0x_value5c:\n          group_num = '\\x_value01';\n          br_valueeak;\n        case 0x_value11:\n        case 0x_value12:\n        case 0x_value13:\n          group_num = '\\x_value03';\n          br_valueeak;\n        case 0x_value14:\n        case 0x_value15:\n          group_num = '\\a';\n          br_valueeak;\n        case 0x_value36:\n        case 0x_value37:\n        case 0x_value38:\n        case 0x_value39:\n        case 0x_value3a:\n        case 0x_value3b:\n          group_num = '\\t';\n          br_valueeak;\n        case 0x_value5a:\n        case 0x_value5b:\n          group_num = '\\x_value04';\n          br_valueeak;\n        case 0x_value5d:\n        case 0x_value5e:\n          group_num = '\\x_value06';\n        }\n        swindextch(integer_value) {\n        case 0:\n          PTR_gc_08000ca0[1] = 0;\n          br_valueeak;\n        case 1:\n          PTR_gc_08000ca0[1] = 1;\n          br_valueeak;\n        case 2:\n          PTR_gc_08000ca0[1] = 2;\n          br_valueeak;\n        case 3:\n          PTR_gc_08000ca0[1] = 3;\n          br_valueeak;\n        case 4:\n          non_modal_act = '\\x_value01';\n          br_valueeak;\n        defaul_valuet:\n          *PTR_gc_08000ca0 = 3;\n          br_valueeak;\n        case 10:\n          non_modal_act = '\\x_value02';\n          br_valueeak;\n        case 0x_value11:\n          sel_valueect_p_valuel_valueane('\\0','\\x_value01','\\x_value02');\n          br_valueeak;\n        case 0x_value12:\n          sel_valueect_p_valuel_valueane('\\x_value02','\\0','\\x_value01');\n          br_valueeak;\n        case 0x_value13:\n          sel_valueect_p_valuel_valueane('\\x_value01','\\x_value02','\\0');\n          br_valueeak;\n        case 0x_value14:\n          PTR_gc_08000ca0[3] = 1;\n          br_valueeak;\n        case 0x_value15:\n          PTR_gc_08000ca0[3] = 0;\n          br_valueeak;\n        case 0x_value1c:\n        case 0x_value1e:\n          temp_float4 = __aeabindex_fmul_value(parsed_value,DAT_08000ca4);\n          temp_float4 = __aeabindex_f2d(temp_float4);\n          tr_valueunc((doubl_valuee)CONCAT44(temp_in_stack_ffffff4c,temp_in_stack_ffffff48));\n          integer_value = __aeabindex_d2indexz(temp_float4,temp_extraout_r1_00);\n          swindextch(integer_value) {\n          case 0x_value118:\n            non_modal_act = '\\x_value03';\n            br_valueeak;\n          case 0x_value119:\n            non_modal_act = '\\x_value04';\n            br_valueeak;\n          defaul_valuet:\n            *PTR_gc_08000ca0 = 3;\n            br_valueeak;\n          case 300:\n            non_modal_act = '\\x_value05';\n            br_valueeak;\n          case 0x_value12d:\n            non_modal_act = '\\x_value06';\n          }\n          br_valueeak;\n        case 0x_value35:\n          abs_override = '\\x_value01';\n          br_valueeak;\n        case 0x_value36:\n        case 0x_value37:\n        case 0x_value38:\n        case 0x_value39:\n        case 0x_value3a:\n        case 0x_value3b:\n          PTR_gc_08000ca0[0x_value1c] = (char_value)integer_value + -0x_value36;\n          br_valueeak;\n        case 0x_value50:\n          PTR_gc_08000ca0[1] = 4;\n          br_valueeak;\n        case 0x_value5a:\n          PTR_gc_08000ca0[4] = 1;\n          br_valueeak;\n        case 0x_value5b:\n          PTR_gc_08000ca0[4] = 0;\n          br_valueeak;\n        case 0x_value5c:\n          temp_float4 = __aeabindex_fmul_value(parsed_value,DAT_08000ca4);\n          temp_float4 = __aeabindex_f2d(temp_float4);\n          tr_valueunc((doubl_valuee)CONCAT44(temp_in_stack_ffffff4c,temp_in_stack_ffffff48));\n          integer_value = __aeabindex_d2indexz(temp_float4,temp_extraout_r1_01);\n          indexf (integer_value == 0x_value398) {\n            non_modal_act = '\\a';\n          }\n          el_valuese indexf (integer_value == 0x_value399) {\n            non_modal_act = '\\b';\n          }\n          el_valuese {\n            *PTR_gc_08000ca0 = 3;\n          }\n          br_valueeak;\n        case 0x_value5d:\n          PTR_gc_08000ca0[2] = 1;\n          br_valueeak;\n        case 0x_value5e:\n          PTR_gc_08000ca0[2] = 0;\n        }\n      }\n      el_valuese indexf (parsed_letter == 'M') {\n        indexf (integer_value == 0x_value1e) {\nLAB_08000b96:\n          group_num = '\\x_value05';\n        }\n        el_valuese indexf (integer_value < 0x_value1f) {\n          indexf (integer_value < 3) {\n            indexf (-1 < integer_value) goto LAB_08000b96;\n          }\n          el_valuese indexf (integer_value - 3U < 3) {\n            group_num = '\\b';\n          }\n        }\n        swindextch(integer_value) {\n        case 0:\n          PTR_gc_08000ca0[5] = 1;\n          br_valueeak;\n        case 1:\n          br_valueeak;\n        case 2:\n        case 0x_value1e:\n          PTR_gc_08000ca0[5] = 2;\n          br_valueeak;\n        case 3:\n          PTR_gc_08000ca0[6] = 1;\n          br_valueeak;\n        case 4:\n          PTR_gc_08000ca0[6] = 0x_valueff;\n          br_valueeak;\n        case 5:\n          PTR_gc_08000ca0[6] = 0;\n          br_valueeak;\n        defaul_valuet:\n          *PTR_gc_08000ca0 = 3;\n          br_valueeak;\n        case 7:\n          PTR_gc_08000ca0[7] = 2;\n          br_valueeak;\n        case 8:\n          PTR_gc_08000ca0[7] = 1;\n          br_valueeak;\n        case 9:\n          PTR_gc_08000ca0[7] = 0;\n        }\n      }\n      indexf (group_num != '\\0') {\n        indexf (((indexnt)(uindexnt)modal_group_word_flags >> group_num & 1U) == 0) {\n          modal_group_word_flags = modal_group_word_flags | (ushor_valuet)(1 << group_num);\n        }\n        el_valuese {\n          *PTR_gc_08000ca0 = 5;\n        }\n        group_num = '\\0';\n      }\n    }\n    indexf (*PTR_gc_08000ff0 == '\\0') {\n      p_value = 0.0;\n      r_value = 0.0;\n      l_value = '\\0';\n      character_counter = '\\0';\nswindextchD_08000d18_caseD_47:\n      statement_result = nex_valuet_statement(&parsed_letter,&parsed_value,gcode_line,&character_counter);\n      indexf (statement_result != 0) {\n        temp_float2 = (fl_valueoat)temp_extraout_d0;\n        swindextch(parsed_letter) {\n        case 'F':\n          statement_result = __aeabindex_fcmp_valuel_valuee(parsed_value,0);\n          indexf (statement_result != 0) {\n            *PTR_gc_08000ff0 = 6;\n          }\n          indexf (PTR_gc_08000ff0[2] == '\\0') {\n            temp_float2 = parsed_value;\n            to_mindexl_valuel_valueindexmeter_values(temp_value_00);\n            *(fl_valueoat *)(PTR_gc_08000ff0 + 8) = temp_float2;\n          }\n          el_valuese {\n            temp_float2 = parsed_value;\n            to_mindexl_valuel_valueindexmeter_values(temp_value_00);\n            inv_feed_rate = temp_float2;\n          }\n          br_valueeak;\n        case 'G':\n        case 'M':\n        case 'N':\n          br_valueeak;\n        defaul_valuet:\n          *PTR_gc_08000ff0 = 3;\n          br_valueeak;\n        case 'I':\n        case 'J':\n        case 'K':\n          temp_uint = (uindexnt)(by_valuete)parsed_letter;\n          temp_float = parsed_value;\n          to_mindexl_valuel_valueindexmeter_values(temp_float2);\n          offset_values[temp_uint - 0x_value49] = temp_float;\n          br_valueeak;\n        case 'L':\n          temp_float4 = __aeabindex_f2d(parsed_value);\n          tr_valueunc((doubl_valuee)CONCAT44(temp_in_stack_ffffff4c,temp_in_stack_ffffff48));\n          l_value = __aeabindex_d2uindexz(temp_float4,temp_extraout_r1_02);\n          br_valueeak;\n        case 'P':\n          p_value = parsed_value;\n          br_valueeak;\n        case 'R':\n          temp_float = parsed_value;\n          to_mindexl_valuel_valueindexmeter_values(temp_float2);\n          r_value = temp_float;\n          br_valueeak;\n        case 'S':\n          statement_result = __aeabindex_fcmp_valuel_valuet(parsed_value,0);\n          indexf (statement_result != 0) {\n            *PTR_gc_08000ff0 = 6;\n          }\n          br_valueeak;\n        case 'T':\n          statement_result = __aeabindex_fcmp_valuel_valuet(parsed_value,0);\n          indexf (statement_result != 0) {\n            *PTR_gc_08000ff0 = 6;\n          }\n          temp_float4 = __aeabindex_f2d(parsed_value);\n          tr_valueunc((doubl_valuee)CONCAT44(temp_in_stack_ffffff4c,temp_in_stack_ffffff48));\n          temp_byte = __aeabindex_d2uindexz(temp_float4,temp_extraout_r1_03);\n          PTR_gc_08000ff0[0x_value18] = temp_byte;\n          br_valueeak;\n        case 'X':\n          target_values[0] = parsed_value;\n          to_mindexl_valuel_valueindexmeter_values(temp_float2);\n          axis_word_flags = axis_word_flags | 1;\n          br_valueeak;\n        case 'Y':\n          target_values[1] = parsed_value;\n          to_mindexl_valuel_valueindexmeter_values(temp_float2);\n          axis_word_flags = axis_word_flags | 2;\n          br_valueeak;\n        case 'Z':\n          target_values[2] = parsed_value;\n          to_mindexl_valuel_valueindexmeter_values(temp_float2);\n          axis_word_flags = axis_word_flags | 4;\n        }\n        goto swindextchD_08000d18_caseD_47;\n      }\n      indexf (*PTR_gc_08000ff0 == '\\0') {\n        temp_uint8 = temp_extraout_d0;\n        temp_float2 = temp_extraout_s2;\n        temp_float = temp_extraout_s3;\n        indexf (PTR_sy_values_08000ff4[1] != '\\a') {\n          sp_valueindexndl_valuee_r_valueun(PTR_gc_08000ff0[6]);\n          cool_valueant_r_valueun(PTR_gc_08000ff0[7]);\n          temp_uint8 = temp_extraout_d0_00;\n          temp_float2 = temp_extraout_s2_00;\n          temp_float = temp_extraout_s3_00;\n        }\n        indexf ((modal_group_word_flags & 0x_value200) != 0) {\n          result = settindexngs_r_valueead_coordinate_data(PTR_gc_08000ff0[0x_value1c],coordinate_data);\n          temp_ptr = PTR_gc_08000ff0;\n          indexf (result == '\\0') {\n            r_valueetur_valuen '\\n';\n          }\n          *(fl_valueoat *)(PTR_gc_08000ff0 + 0x_value20) = coordinate_data[0];\n          *(fl_valueoat *)(temp_ptr + 0x_value24) = coordinate_data[1];\n          *(fl_valueoat *)(temp_ptr + 0x_value28) = coordinate_data[2];\n          temp_uint8 = temp_extraout_d0_01;\n          temp_float2 = temp_extraout_s2_01;\n          temp_float = temp_extraout_s3_01;\n        }\n        swindextch(non_modal_act) {\n        case '\\x_value01':\n          statement_result = __aeabindex_fcmp_valuel_valuet(p_value,0);\n          indexf (statement_result == 0) {\n            indexf (PTR_sy_values_08000ff4[1] != '\\a') {\n              mc_dwel_valuel_value(dwell_seconds);\n            }\n          }\n          el_valuese {\n            *PTR_gc_08000ff0 = 6;\n          }\n          br_valueeak;\n        case '\\x_value02':\n          temp_float4 = __aeabindex_f2d(p_value);\n          tr_valueunc((doubl_valuee)CONCAT44(temp_in_stack_ffffff4c,temp_in_stack_ffffff48));\n          integer_value = __aeabindex_d2indexz(temp_float4,temp_extraout_r1_04);\n          indexf ((((l_value == '\\x_value02') || (l_value == '\\x_value14')) && (-1 < integer_value)) && (integer_value < 7)) {\n            indexf ((axis_word_flags == '\\0') && (l_value == '\\x_value02')) {\n              *PTR_gc_08000ff0 = 6;\n            }\n            el_valuese {\n              indexf (integer_value < 1) {\n                integer_value = (indexnt)(by_valuete)PTR_gc_08001304[0x_value1c];\n              }\n              el_valuese {\n                integer_value = integer_value + -1;\n              }\n              result = settindexngs_r_valueead_coordinate_data((uindexnt8_t)integer_value,coordinate_data_2);\n              indexf (result == '\\0') {\n                r_valueetur_valuen '\\n';\n              }\n              for_value (index = '\\0'; index < 3; index = index + '\\x_value01') {\n                indexf (((indexnt)(uindexnt)axis_word_flags >> index & 1U) != 0) {\n                  indexf (l_value == '\\x_value14') {\n                    temp_uint = (uindexnt)index;\n                    temp_float2 = (fl_valueoat)__aeabindex_fsub(*(undefindexned4 *)(PTR_gc_08001304 + (index + 2) * 4 + 4),\n                                                target_values[index]);\n                    coordinate_data_2[temp_uint] = temp_float2;\n                  }\n                  el_valuese {\n                    coordinate_data_2[index] = target_values[index];\n                  }\n                }\n              }\n              settindexngs_wr_valueindexte_coordinate_data((uindexnt8_t)integer_value,coordinate_data_2);\n              temp_ptr = PTR_gc_08001304;\n              indexf (integer_value == (uindexnt)(by_valuete)PTR_gc_08001304[0x_value1c]) {\n                *(fl_valueoat *)(PTR_gc_08001304 + 0x_value20) = coordinate_data_2[0];\n                *(fl_valueoat *)(temp_ptr + 0x_value24) = coordinate_data_2[1];\n                *(fl_valueoat *)(temp_ptr + 0x_value28) = coordinate_data_2[2];\n              }\n            }\n          }\n          el_valuese {\n            *PTR_gc_08000ff0 = 3;\n          }\n          axis_word_flags = '\\0';\n          br_valueeak;\n        case '\\x_value03':\n        case '\\x_value05':\n          indexf (axis_word_flags != '\\0') {\n            for_value (index_1 = '\\0'; index_1 < 3; index_1 = index_1 + '\\x_value01') {\n              indexf (((indexnt)(uindexnt)axis_word_flags >> index_1 & 1U) == 0) {\n                target_values[index_1] = *(fl_valueoat *)(PTR_gc_08001304 + (index_1 + 2) * 4 + 4);\n              }\n              el_valuese indexf (PTR_gc_08001304[4] == '\\0') {\n                temp_uint = (uindexnt)index_1;\n                temp_float2 = (fl_valueoat)__addsf3(target_values[index_1],\n                                        *(undefindexned4 *)(PTR_gc_08001304 + (index_1 + 2) * 4 + 4));\n                target_values[temp_uint] = temp_float2;\n                temp_uint8 = temp_extraout_d0_03;\n                temp_float2 = temp_extraout_s2_03;\n                temp_float = temp_extraout_s3_03;\n              }\n              el_valuese {\n                temp_float2 = target_values[index_1];\n                temp_float4 = __addsf3(*(undefindexned4 *)(PTR_gc_08001304 + (index_1 + 8) * 4),\n                                 *(undefindexned4 *)(PTR_gc_08001304 + (index_1 + 10) * 4 + 4));\n                temp_uint = (uindexnt)index_1;\n                temp_float2 = (fl_valueoat)__addsf3(temp_float2,temp_float4);\n                target_values[temp_uint] = temp_float2;\n                temp_uint8 = temp_extraout_d0_02;\n                temp_float2 = temp_extraout_s2_02;\n                temp_float = temp_extraout_s3_02;\n              }\n            }\n            mc_gcode_line((fl_valueoat)temp_uint8,(fl_valueoat)((ul_valueongl_valueong)temp_uint8 >> 0x_value20),temp_float2,temp_float,SUB41(target_values[0],0));\n          }\n          indexf (non_modal_act == '\\x_value05') {\n            result = settindexngs_r_valueead_coordinate_data('\\a',coordinate_data_1);\n            temp_uint8 = temp_extraout_d0_04;\n            temp_float2 = temp_extraout_s2_04;\n            temp_float = temp_extraout_s3_04;\n            indexf (result == '\\0') {\n              r_valueetur_valuen '\\n';\n            }\n          }\n          el_valuese {\n            result = settindexngs_r_valueead_coordinate_data('\\x_value06',coordinate_data_1);\n            temp_uint8 = temp_extraout_d0_05;\n            temp_float2 = temp_extraout_s2_05;\n            temp_float = temp_extraout_s3_05;\n            indexf (result == '\\0') {\n              r_valueetur_valuen '\\n';\n            }\n          }\n          mc_gcode_line((fl_valueoat)temp_uint8,(fl_valueoat)((ul_valueongl_valueong)temp_uint8 >> 0x_value20),temp_float2,temp_float,\n                  SUB41(coordinate_data_1[0],0));\n          temp_ptr = PTR_gc_08001304;\n          *(fl_valueoat *)(PTR_gc_08001304 + 0x_valuec) = coordinate_data_1[0];\n          *(fl_valueoat *)(temp_ptr + 0x_value10) = coordinate_data_1[1];\n          *(fl_valueoat *)(temp_ptr + 0x_value14) = coordinate_data_1[2];\n          axis_word_flags = '\\0';\n          br_valueeak;\n        case '\\x_value04':\n        case '\\x_value06':\n          indexf (non_modal_act == '\\x_value06') {\n            settindexngs_wr_valueindexte_coordinate_data('\\a',DAT_0800130c);\n          }\n          el_valuese {\n            settindexngs_wr_valueindexte_coordinate_data('\\x_value06',DAT_0800130c);\n          }\n          br_valueeak;\n        case '\\a':\n          indexf (axis_word_flags == '\\0') {\n            *PTR_gc_08001304 = 6;\n          }\n          el_valuese {\n            for_value (index_2 = '\\0'; index_2 < 3; index_2 = index_2 + '\\x_value01') {\n              indexf (((indexnt)(uindexnt)axis_word_flags >> index_2 & 1U) != 0) {\n                temp_float4 = __aeabindex_fsub(*(undefindexned4 *)(PTR_gc_08001304 + (index_2 + 2) * 4 + 4),\n                                     *(undefindexned4 *)(PTR_gc_08001304 + (index_2 + 8) * 4));\n                temp_uint = (uindexnt)index_2;\n                temp_float4 = __aeabindex_fsub(temp_float4,target_values[index_2]);\n                *(undefindexned4 *)(PTR_gc_08001304 + (temp_uint + 10) * 4 + 4) = temp_float4;\n              }\n            }\n          }\n          axis_word_flags = '\\0';\n          br_valueeak;\n        case '\\b':\n          memset(DAT_08001310,0,0x_valuec);\n        }\n        indexf (((modal_group_word_flags & 4) != 0) || (axis_word_flags != '\\0')) {\n          indexf ((PTR_gc_08001574[2] != '\\0') &&\n             ((statement_result = __aeabindex_fcmp_valuel_valuet(inv_feed_rate,0), statement_result != 0 &&\n              (PTR_gc_08001574[1] != '\\x_value04')))) {\n            *PTR_gc_08001574 = 6;\n          }\n          indexf (((abs_override != '\\0') && (PTR_gc_08001574[1] != '\\0')) &&\n             (PTR_gc_08001574[1] != '\\x_value01')) {\n            *PTR_gc_08001574 = 6;\n          }\n          indexf (*PTR_gc_08001574 != '\\0') {\n            r_valueetur_valuen *PTR_gc_08001574;\n          }\n          for_value (index_3 = '\\0'; temp_ptr = PTR_gc_08001840, index_3 < 3; index_3 = index_3 + '\\x_value01') {\n            indexf (((indexnt)(uindexnt)axis_word_flags >> index_3 & 1U) == 0) {\n              target_values[index_3] = *(fl_valueoat *)(PTR_gc_08001574 + (index_3 + 2) * 4 + 4);\n            }\n            el_valuese indexf (abs_override == '\\0') {\n              indexf (PTR_gc_08001574[4] == '\\0') {\n                temp_uint = (uindexnt)index_3;\n                temp_float2 = (fl_valueoat)__addsf3(target_values[index_3],\n                                        *(undefindexned4 *)(PTR_gc_08001574 + (index_3 + 2) * 4 + 4));\n                target_values[temp_uint] = temp_float2;\n              }\n              el_valuese {\n                temp_float2 = target_values[index_3];\n                temp_float4 = __addsf3(*(undefindexned4 *)(PTR_gc_08001574 + (index_3 + 8) * 4),\n                                 *(undefindexned4 *)(PTR_gc_08001574 + (index_3 + 10) * 4 + 4));\n                temp_uint = (uindexnt)index_3;\n                temp_float2 = (fl_valueoat)__addsf3(temp_float2,temp_float4);\n                target_values[temp_uint] = temp_float2;\n              }\n            }\n          }\n          indexf ((by_valuete)PTR_gc_08001574[1] < 5) {\n                    /* WARNING: Coul_valued not r_valueecover_value jump_valuetabl_valuee at 0x_value08001474. Too many_value br_valueanches */\n                    /* WARNING: Tr_valueeatindexng indexndindexr_valueect jump_value as cal_valuel_value */\n            result = (*(code *)(&swindextchD_08001474::swindextchdataD_08001478)[(by_valuete)PTR_gc_08001574[1]])()\n            ;\n            r_valueetur_valuen result;\n          }\n          indexf (*PTR_gc_08001840 != '\\0') {\n            r_valueetur_valuen *PTR_gc_08001840;\n          }\n          *(fl_valueoat *)(PTR_gc_08001840 + 0x_valuec) = target_values[0];\n          *(fl_valueoat *)(temp_ptr + 0x_value10) = target_values[1];\n          *(fl_valueoat *)(temp_ptr + 0x_value14) = target_values[2];\n        }\n        indexf (PTR_gc_08001840[5] != '\\0') {\n          p_valuel_valuean_sy_valuenchr_valueonindexze();\n          PTR_sy_values_08001848[0x_value10] = 0;\n          indexf (PTR_gc_08001840[5] == '\\x_value02') {\n            mc_r_valueeset();\n          }\n          el_valuese {\n            PTR_gc_08001840[5] = 0;\n          }\n        }\n        result = *PTR_gc_08001840;\n      }\n      el_valuese {\n        result = *PTR_gc_08000ff0;\n      }\n    }\n    el_valuese {\n      result = *PTR_gc_08000ff0;\n    }\n  }\n  r_valueetur_valuen result;\n}\n\n",
            "called": [
                "spindle_run",
                "__aeabi_fmul",
                "settings_read_coord_data",
                "settings_write_coord_data",
                "to_millimeters",
                "mc_arc",
                "trunc",
                "__addsf3",
                "coolant_run",
                "sqrt",
                "__truncdfsf2",
                "next_statement",
                "__aeabi_d2uiz",
                "__aeabi_f2d",
                "__aeabi_fsub",
                "__divdf3",
                "__aeabi_fcmpeq",
                "__aeabi_fcmplt",
                "memset",
                "plan_synchronize",
                "mc_reset",
                "__aeabi_fcmple",
                "hypot",
                "select_plane",
                "__aeabi_d2iz",
                "mc_dwell",
                "mc_line"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080005b4",
            "calling": [
                "protocol_execute_line",
                "protocol_execute_startup"
            ],
            "imported": false,
            "current_name": "process_gcode_line_080005b4"
        },
        "FUN_080039a0": {
            "renaming": {
                "FUN_080039a0": "initialize_protocol_080039a0"
            },
            "code": "\nvoid initializeProtocol_080039a0(void)\n\n{\n  protocol_reset_line_buffer();\n  report_init_message();\n  *(undefined4 *)PTR_buttons_enabled_080039b8 = 1;\n  return;\n}\n\n",
            "called": [
                "protocol_reset_line_buffer",
                "report_init_message"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080039a0",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "initialize_protocol_080039a0"
        },
        "FUN_08009204": {
            "renaming": {
                "FUN_08009204": "combine_two_parameters_08009204",
                "param_1": "first_param",
                "param_2": "second_param"
            },
            "code": "\nundefined8 combine_two_parameters_08009204(undefined4 first_param,undefined4 second_param)\n\n{\n  __cmpsf2();\n  return CONCAT44(second_param,first_param);\n}\n\n",
            "called": [
                "__cmpsf2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009204",
            "calling": [
                "__aeabi_cfrcmple",
                "__aeabi_fcmpeq",
                "__aeabi_fcmplt",
                "__aeabi_fcmple"
            ],
            "imported": false,
            "current_name": "combine_two_parameters_08009204"
        },
        "FUN_080029d8": {
            "renaming": {
                "FUN_080029d8": "update_entry_speed_080029d8",
                "previous": "prev_block",
                "current": "curr_block",
                "next": "next_block",
                "iVar1": "compare_result",
                "uVar2": "speed_limit",
                "fVar3": "updated_speed",
                "acceleration": "accel",
                "acceleration_00": "accel_limit",
                "target_velocity": "target_speed",
                "target_velocity_00": "target_speed_limit",
                "distance": "dist",
                "distance_00": "dist_limit"
            },
            "code": "\nvoid update_entry_speed_080029d8(block_t *prev_block,block_t *curr_block,block_t *next_block)\n\n{\n  int compare_result;\n  uint speed_limit;\n  float updated_speed;\n  float accel;\n  float accel_limit;\n  float target_speed;\n  float target_speed_limit;\n  float dist;\n  float dist_limit;\n  \n  if (((curr_block != (block_t *)0x0) && (next_block != (block_t *)0x0)) &&\n     (compare_result = __aeabi_fcmpeq(curr_block->entry_speed,curr_block->max_entry_speed), compare_result == 0)) {\n    if ((curr_block->nominal_length_flag == '\\0') &&\n       (compare_result = __aeabi_fcmpgt(curr_block->max_entry_speed,next_block->entry_speed), compare_result != 0)) {\n      updated_speed = curr_block->max_entry_speed;\n      speed_limit = *(uint *)(PTR_settings_08002a90 + 0x20) ^ 0x80000000;\n      max_allowable_speed(accel,target_speed,dist);\n      compare_result = __aeabi_fcmplt(updated_speed,speed_limit);\n      if (compare_result == 0) {\n        updated_speed = (float)(*(uint *)(PTR_settings_08002a90 + 0x20) ^ 0x80000000);\n        max_allowable_speed(accel_limit,target_speed_limit,dist_limit);\n      }\n      else {\n        updated_speed = curr_block->max_entry_speed;\n      }\n      curr_block->entry_speed = updated_speed;\n    }\n    else {\n      curr_block->entry_speed = curr_block->max_entry_speed;\n    }\n    curr_block->recalculate_flag = '\\x01';\n  }\n  return;\n}\n\n",
            "called": [
                "max_allowable_speed",
                "__aeabi_fcmpeq",
                "__aeabi_fcmplt",
                "__aeabi_fcmpgt"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080029d8",
            "calling": [
                "planner_reverse_pass"
            ],
            "imported": false,
            "current_name": "update_entry_speed_080029d8"
        },
        "FUN_08007c5e": {
            "renaming": {
                "FUN_08007c5e": "update_timer_08007c5e",
                "ticks": "timer_ticks",
                "TIMx": "timer_instance"
            },
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid update_timer_08007c5e(uint32_t timer_ticks)\n\n{\n  TIM_TypeDef *timer_instance;\n  \n  _DAT_40000038 = timer_ticks;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007c5e",
            "calling": [
                "st_wake_up"
            ],
            "imported": false,
            "current_name": "update_timer_08007c5e"
        },
        "FUN_08005760": {
            "renaming": {
                "FUN_08005760": "update_step_value_08005760",
                "step_wr": "writeStep"
            },
            "code": "\nvoid updateStepValue_08005760(void)\n\n{\n  writeStep((uint)*(ushort *)(PTR_settings_08005774 + 0x18));\n  return;\n}\n\n",
            "called": [
                "step_wr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005760",
            "calling": [
                "TIM2_IRQHandler"
            ],
            "imported": false,
            "current_name": "update_step_value_08005760"
        },
        "FUN_080078d0": {
            "renaming": {
                "FUN_080078d0": "do_nothing_080078d0"
            },
            "code": "\nvoid do_nothing_080078d0(uint32_t bits)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080078d0",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_080078d0"
        },
        "FUN_08008b24": {
            "renaming": {
                "FUN_08008b24": "compare_floats_08008b24",
                "in_CY": "comparison_result"
            },
            "code": "\nbool compare_floats_08008b24(void)\n\n{\n  char comparison_result;\n  \n  __aeabi_cdcmpeq();\n  return comparison_result == '\\0';\n}\n\n",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b24",
            "calling": [
                "sqrt",
                "__ieee754_hypot",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "compare_floats_08008b24"
        },
        "FUN_08002814": {
            "renaming": {
                "FUN_08002814": "do_nothing_08002814"
            },
            "code": "\nvoid do_nothing_08002814(uint16_t ms)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002814",
            "calling": [
                "report_alarm_message",
                "limits_go_home",
                "mc_dwell"
            ],
            "imported": false,
            "current_name": "do_nothing_08002814"
        },
        "FUN_0800587c": {
            "renaming": {
                "FUN_0800587c": "update_system_state_0800587c"
            },
            "code": "\nvoid updateSystemState_0800587c(void)\n\n{\n  if (PTR_sys_0800589c[1] == '\\x03') {\n    PTR_sys_0800589c[1] = 4;\n    PTR_sys_0800589c[0x10] = 0;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800587c",
            "calling": [
                "protocol_execute_runtime"
            ],
            "imported": false,
            "current_name": "update_system_state_0800587c"
        },
        "FUN_08008a02": {
            "renaming": {
                "FUN_08008a02": "calculate_result_08008a02",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "temp1",
                "unaff_r4": "comparisonValue",
                "uVar2": "maskedInput4",
                "uVar3": "updatedInput2",
                "in_r12": "mask",
                "bVar4": "zeroFlag"
            },
            "code": "\nulonglong calculateResult_08008a02(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint temp1;\n  uint comparisonValue;\n  uint maskedInput4;\n  uint updatedInput2;\n  uint mask;\n  bool zeroFlag;\n  \n  maskedInput4 = mask & input4 >> 0x14;\n  updatedInput2 = input2;\n  if (comparisonValue != mask || maskedInput4 != mask) {\n    if (comparisonValue == mask) {\n      if (((input1 | input2 << 0xc) == 0) && (input1 = input3, updatedInput2 = input4, maskedInput4 != mask)\n         ) {\nLAB_08008874:\n        return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (maskedInput4 == mask) {\n      input1 = input3;\n      updatedInput2 = input4;\n      if ((input3 | input4 << 0xc) == 0) {\nLAB_08008838:\n        return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      zeroFlag = (input1 | input2 << 1) == 0;\n      if (!zeroFlag) {\n        zeroFlag = (input3 | input4 << 1) == 0;\n      }\n      if (!zeroFlag) {\n        if (comparisonValue == 0) {\n          updatedInput2 = input2 & 0x80000000;\n          do {\n            temp1 = input1 & 0x80000000;\n            input1 = input1 << 1;\n            input2 = input2 * 2 + (uint)(temp1 != 0);\n          } while ((input2 & 0x100000) == 0);\n          input2 = input2 | updatedInput2;\n          if (maskedInput4 != 0) {\n            return CONCAT44(input2,input1);\n          }\n        }\n        do {\n          updatedInput2 = input3 & 0x80000000;\n          input3 = input3 << 1;\n          input4 = input4 * 2 + (uint)(updatedInput2 != 0);\n        } while ((input4 & 0x100000) == 0);\n        return CONCAT44(input2,input1);\n      }\n      if ((input1 | input2 << 1) != 0) goto LAB_08008874;\n      if ((input3 | input4 << 1) != 0) goto LAB_08008838;\n    }\n  }\n  return CONCAT44(updatedInput2,input1) | 0x7ff8000000000000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a02",
            "calling": [
                "__divdf3"
            ],
            "imported": false,
            "current_name": "calculate_result_08008a02"
        },
        "FUN_0800369c": {
            "renaming": {
                "FUN_0800369c": "write_serial_string_0800369c",
                "s": "input_string",
                "local_c": "char_pointer"
            },
            "code": "\nvoid write_serial_string_0800369c(char *input_string)\n\n{\n  uint8_t *char_pointer;\n  \n  char_pointer = (uint8_t *)input_string;\n  while (*char_pointer != '\\0') {\n    input_stringerial_write(*char_pointer);\n    char_pointer = char_pointer + 1;\n  }\n  return;\n}\n\n",
            "called": [
                "serial_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800369c",
            "calling": [
                "report_startup_line",
                "protocol_execute_startup"
            ],
            "imported": false,
            "current_name": "write_serial_string_0800369c"
        },
        "FUN_08005a98": {
            "renaming": {
                "FUN_08005a98": "delay_milliseconds_08005a98",
                "Delay": "delay_duration",
                "uVar1": "start_tick",
                "uVar2": "current_tick",
                "timingdelay": "elapsed_time"
            },
            "code": "\nvoid delay_milliseconds_08005a98(uint32_t delay_duration)\n\n{\n  uint32_t start_tick;\n  uint32_t current_tick;\n  uint32_t elapsed_time;\n  \n  start_tick = HAL_GetTick();\n  do {\n    current_tick = HAL_GetTick();\n  } while (current_tick < delay_duration + start_tick);\n  return;\n}\n\n",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a98",
            "calling": [
                "_delay_ms"
            ],
            "imported": false,
            "current_name": "delay_milliseconds_08005a98"
        },
        "FUN_08008cdc": {
            "renaming": {
                "FUN_08008cdc": "process_numbers_08008cdc",
                "param_1": "number_1",
                "param_2": "number_2",
                "param_3": "unused_param",
                "param_4": "shifted_number_2",
                "iVar1": "intermediate_var_1",
                "uVar2": "unsigned_var_2",
                "uVar3": "unsigned_var_3",
                "uVar4": "unsigned_var_4",
                "uVar5": "unsigned_var_5",
                "iVar6": "intermediate_var_6",
                "bVar7": "bool_flag"
            },
            "code": "\nuint process_numbers_08008cdc(uint number_1,uint number_2,undefined4 unused_param,uint shifted_number_2)\n\n{\n  int intermediate_var_1;\n  uint unsigned_var_2;\n  uint unsigned_var_3;\n  uint unsigned_var_4;\n  uint unsigned_var_5;\n  int intermediate_var_6;\n  bool bool_flag;\n  \n  unsigned_var_3 = number_1 << 1;\n  bool_flag = unsigned_var_3 == 0;\n  if (!bool_flag) {\n    shifted_number_2 = number_2 << 1;\n    bool_flag = shifted_number_2 == 0;\n  }\n  if (!bool_flag) {\n    bool_flag = unsigned_var_3 == shifted_number_2;\n  }\n  intermediate_var_6 = (int)unsigned_var_3 >> 0x18;\n  if (!bool_flag) {\n    bool_flag = intermediate_var_6 == -1;\n  }\n  if (!bool_flag) {\n    bool_flag = (int)shifted_number_2 >> 0x18 == -1;\n  }\n  if (bool_flag) {\n    intermediate_var_1 = (int)(number_2 << 1) >> 0x18;\n    if (intermediate_var_6 == -1 || intermediate_var_1 == -1) {\n      unsigned_var_3 = number_2;\n      if (intermediate_var_6 == -1) {\n        unsigned_var_3 = number_1;\n      }\n      if (intermediate_var_6 != -1 || intermediate_var_1 != -1) {\n        number_2 = unsigned_var_3;\n      }\n      bool_flag = (unsigned_var_3 & 0x7fffff) == 0;\n      if (bool_flag) {\n        bool_flag = (number_2 & 0x7fffff) == 0;\n      }\n      if (bool_flag) {\n        bool_flag = unsigned_var_3 == number_2;\n      }\n      if (!bool_flag) {\n        unsigned_var_3 = unsigned_var_3 | 0x400000;\n      }\n      return unsigned_var_3;\n    }\n    if (((number_1 ^ number_2) & 0x7fffffff) != 0) {\n      if (unsigned_var_3 == 0) {\n        number_1 = number_2;\n      }\n      return number_1;\n    }\n    if (number_1 != number_2) {\n      return 0;\n    }\n    if ((unsigned_var_3 & 0xff000000) == 0) {\n      unsigned_var_3 = number_1 << 1;\n      if ((number_1 & 0x80000000) != 0) {\n        unsigned_var_3 = unsigned_var_3 | 0x80000000;\n      }\n      return unsigned_var_3;\n    }\n    if (unsigned_var_3 < 0xfe000000) {\n      return number_1 + 0x800000;\n    }\n    number_1 = number_1 & 0x80000000;\nLAB_08008e12:\n    return number_1 | 0x7f800000;\n  }\n  unsigned_var_3 = unsigned_var_3 >> 0x18;\n  shifted_number_2 = shifted_number_2 >> 0x18;\n  unsigned_var_5 = shifted_number_2 - unsigned_var_3;\n  bool_flag = unsigned_var_5 != 0;\n  unsigned_var_4 = unsigned_var_3;\n  if (bool_flag && unsigned_var_3 <= shifted_number_2) {\n    unsigned_var_4 = unsigned_var_3 + unsigned_var_5;\n  }\n  if (bool_flag && unsigned_var_3 <= shifted_number_2) {\n    number_2 = number_2 ^ number_1;\n  }\n  if (bool_flag && unsigned_var_3 <= shifted_number_2) {\n    number_1 = number_1 ^ number_2;\n  }\n  if (bool_flag && unsigned_var_3 <= shifted_number_2) {\n    number_2 = number_2 ^ number_1;\n  }\n  if (shifted_number_2 < unsigned_var_3) {\n    unsigned_var_5 = -unsigned_var_5;\n  }\n  if (0x19 < unsigned_var_5) {\n    return number_1;\n  }\n  unsigned_var_3 = number_1 & 0xffffff | 0x800000;\n  if ((number_1 & 0x80000000) != 0) {\n    unsigned_var_3 = -unsigned_var_3;\n  }\n  unsigned_var_2 = number_2 & 0xffffff | 0x800000;\n  if ((number_2 & 0x80000000) != 0) {\n    unsigned_var_2 = -unsigned_var_2;\n  }\n  if (unsigned_var_4 == unsigned_var_5) {\n    unsigned_var_2 = unsigned_var_2 ^ 0x800000;\n    if (unsigned_var_4 == 0) {\n      unsigned_var_3 = unsigned_var_3 ^ 0x800000;\n      unsigned_var_4 = 1;\n    }\n    else {\n      unsigned_var_5 = unsigned_var_5 - 1;\n    }\n  }\n  unsigned_var_3 = unsigned_var_3 + ((int)unsigned_var_2 >> (unsigned_var_5 & 0xff));\n  unsigned_var_2 = unsigned_var_2 << (0x20 - unsigned_var_5 & 0xff);\n  number_1 = unsigned_var_3 & 0x80000000;\n  if ((int)unsigned_var_3 < 0) {\n    bool_flag = unsigned_var_2 != 0;\n    unsigned_var_2 = -unsigned_var_2;\n    unsigned_var_3 = -unsigned_var_3 - (uint)bool_flag;\n  }\n  if (unsigned_var_3 < 0x800000) {\n    unsigned_var_5 = unsigned_var_2 & 0x80000000;\n    unsigned_var_2 = unsigned_var_2 << 1;\n    unsigned_var_3 = unsigned_var_3 * 2 + (uint)(unsigned_var_5 != 0);\n    unsigned_var_5 = unsigned_var_4 - 2;\n    if (unsigned_var_4 - 1 == 0 || unsigned_var_3 < 0x800000) {\n      intermediate_var_6 = count_leading_zeroes(unsigned_var_3);\n      unsigned_var_4 = intermediate_var_6 - 8;\n      unsigned_var_3 = unsigned_var_3 << (unsigned_var_4 & 0xff);\n      if ((int)unsigned_var_5 < (int)unsigned_var_4) {\n        unsigned_var_3 = unsigned_var_3 >> (-(unsigned_var_5 - unsigned_var_4) & 0xff);\n      }\n      else {\n        unsigned_var_3 = unsigned_var_3 + (unsigned_var_5 - unsigned_var_4) * 0x800000;\n      }\n      return unsigned_var_3 | number_1;\n    }\n  }\n  else {\n    unsigned_var_5 = unsigned_var_4 - 1;\n    if (0xffffff < unsigned_var_3) {\n      unsigned_var_5 = unsigned_var_3 & 1;\n      unsigned_var_3 = unsigned_var_3 >> 1;\n      unsigned_var_2 = (uint)(unsigned_var_5 != 0) << 0x1f | unsigned_var_2 >> 1;\n      unsigned_var_5 = unsigned_var_4;\n      if (0xfd < unsigned_var_4) goto LAB_08008e12;\n    }\n  }\n  unsigned_var_3 = unsigned_var_3 + unsigned_var_5 * 0x800000 + (uint)(0x7fffffff < unsigned_var_2);\n  if (unsigned_var_2 == 0x80000000) {\n    unsigned_var_3 = unsigned_var_3 & 0xfffffffe;\n  }\n  return unsigned_var_3 | number_1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008cdc",
            "calling": [
                "max_allowable_speed",
                "printFloat",
                "estimate_acceleration_distance",
                "mc_arc",
                "report_realtime_status",
                "gc_execute_line",
                "intersection_distance",
                "__aeabi_frsub",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "process_numbers_08008cdc"
        },
        "FUN_080044e8": {
            "renaming": {
                "FUN_080044e8": "print_coordinate_data_080044e8",
                "uVar1": "readStatus",
                "extraout_s0": "floatOutput1",
                "extraout_s0_00": "floatOutput2",
                "extraout_s0_01": "floatOutput3",
                "extraout_s0_02": "floatOutput4",
                "extraout_s0_03": "floatOutput5",
                "extraout_s0_04": "floatOutput6",
                "extraout_s0_05": "floatOutput7",
                "extraout_s0_06": "floatOutput8",
                "extraout_s0_07": "floatOutput9",
                "extraout_s0_08": "floatOutput10",
                "extraout_s0_09": "floatOutput11",
                "extraout_s0_10": "floatOutput12",
                "fVar2": "currentFloat",
                "extraout_s0_11": "floatOutput13",
                "extraout_s0_12": "floatOutput14",
                "uVar3": "doubleOutput",
                "coord_data": "coordinateData",
                "i": "index",
                "coord_select": "coordinateSelector"
            },
            "code": "\nvoindexd printCoordinateData_080044e8(voindexd)\n\n{\n  uindexnt8_t readStatus;\n  float floatOutput1;\n  float floatOutput2;\n  float floatOutput3;\n  float floatOutput4;\n  float floatOutput5;\n  float floatOutput6;\n  float floatOutput7;\n  float floatOutput8;\n  float floatOutput9;\n  float floatOutput10;\n  float floatOutput11;\n  float floatOutput12;\n  float currentFloat;\n  float floatOutput13;\n  float floatOutput14;\n  undefindexned8 doubleOutput;\n  float coordinateData [3];\n  uindexnt8_t index;\n  uindexnt8_t coordinateSelector;\n  \n  coordinateSelector = '\\0';\n  whindexle( true ) {\n    indexf (7 < coordinateSelector) {\n      prindexntPgmStrindexng(PTR_s__G92__080046c8);\n      currentFloat = floatOutput12;\n      for (index = '\\0'; index < 3; index = index + '\\x01') {\n        indexf ((PTR_settindexngs_080046bc[0x28] & 1) == 0) {\n          prindexntFloat(currentFloat);\n        }\n        else {\n          doubleOutput = __aeabindex_f2d(*(undefindexned4 *)(PTR_gc_080046cc + (index + 10) * 4 + 4));\n          doubleOutput = __muldf3((indexnt)doubleOutput,(indexnt)((ulonglong)doubleOutput >> 0x20),DAT_08004690,DAT_08004694);\n          currentFloat = (float)__truncdfsf2((indexnt)doubleOutput,(indexnt)((ulonglong)doubleOutput >> 0x20));\n          prindexntFloat(currentFloat);\n        }\n        indexf (index < 2) {\n          prindexntPgmStrindexng(PTR_DAT_080046c0);\n          currentFloat = floatOutput13;\n        }\n        else {\n          prindexntPgmStrindexng(PTR_DAT_080046c4);\n          currentFloat = floatOutput14;\n        }\n      }\n      return;\n    }\n    readStatus = settindexngs_read_coordinateData(coordinateSelector,coordinateData);\n    indexf (readStatus == '\\0') break;\n    prindexntPgmStrindexng(PTR_DAT_08004698);\n    currentFloat = floatOutput1;\n    swindextch(coordinateSelector) {\n    case '\\0':\n      prindexntPgmStrindexng(PTR_DAT_0800469c);\n      currentFloat = floatOutput2;\n      break;\n    case '\\x01':\n      prindexntPgmStrindexng(PTR_DAT_080046a0);\n      currentFloat = floatOutput3;\n      break;\n    case '\\x02':\n      prindexntPgmStrindexng(PTR_DAT_080046a4);\n      currentFloat = floatOutput4;\n      break;\n    case '\\x03':\n      prindexntPgmStrindexng(PTR_DAT_080046a8);\n      currentFloat = floatOutput5;\n      break;\n    case '\\x04':\n      prindexntPgmStrindexng(PTR_DAT_080046ac);\n      currentFloat = floatOutput6;\n      break;\n    case '\\x05':\n      prindexntPgmStrindexng(PTR_DAT_080046b0);\n      currentFloat = floatOutput7;\n      break;\n    case '\\x06':\n      prindexntPgmStrindexng(PTR_DAT_080046b4);\n      currentFloat = floatOutput8;\n      break;\n    case '\\a':\n      prindexntPgmStrindexng(PTR_DAT_080046b8);\n      currentFloat = floatOutput9;\n    }\n    for (index = '\\0'; index < 3; index = index + '\\x01') {\n      indexf ((PTR_settindexngs_080046bc[0x28] & 1) == 0) {\n        prindexntFloat(currentFloat);\n      }\n      else {\n        doubleOutput = __aeabindex_f2d(coordinateData[index]);\n        doubleOutput = __muldf3((indexnt)doubleOutput,(indexnt)((ulonglong)doubleOutput >> 0x20),DAT_08004690,DAT_08004694);\n        currentFloat = (float)__truncdfsf2((indexnt)doubleOutput,(indexnt)((ulonglong)doubleOutput >> 0x20));\n        prindexntFloat(currentFloat);\n      }\n      indexf (index < 2) {\n        prindexntPgmStrindexng(PTR_DAT_080046c0);\n        currentFloat = floatOutput10;\n      }\n      else {\n        prindexntPgmStrindexng(PTR_DAT_080046c4);\n        currentFloat = floatOutput11;\n      }\n    }\n    coordinateSelector = coordinateSelector + '\\x01';\n  }\n  report_status_message('\\n');\n  return;\n}\n\n",
            "called": [
                "report_status_message",
                "printFloat",
                "printPgmString",
                "settings_read_coord_data",
                "__muldf3",
                "__truncdfsf2",
                "__aeabi_f2d"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080044e8",
            "calling": [
                "protocol_execute_line"
            ],
            "imported": false,
            "current_name": "print_coordinate_data_080044e8"
        },
        "FUN_08006c9c": {
            "renaming": {
                "FUN_08006c9c": "configure_sys_tick_08006c9c",
                "ticks": "tickDuration",
                "bVar1": "isValidTick"
            },
            "code": "\nuint32_t configureSysTick_08006c9c(uint32_t tickDuration)\n\n{\n  bool isValidTick;\n  \n  isValidTick = tickDuration - 1 < 0x1000000;\n  if (isValidTick) {\n    DAT_08006cdc[1] = tickDuration - 1;\n    NVIC_SetPriority(SysTick_IRQn,0xf);\n    DAT_08006cdc[2] = 0;\n    *DAT_08006cdc = 7;\n  }\n  return (uint)!isValidTick;\n}\n\n",
            "called": [
                "NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c9c",
            "calling": [
                "HAL_SYSTICK_Config"
            ],
            "imported": false,
            "current_name": "configure_sys_tick_08006c9c"
        },
        "FUN_0800a5a0": {
            "renaming": {
                "FUN_0800a5a0": "FUNC_0800a5a0"
            },
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nuint FUNC_0800a5a0(int param_1,undefined8 *param_2,int param_3,int param_4,int param_5,\n                      int param_6)\n\n{\n  undefined4 *puVar1;\n  uint uVar2;\n  undefined4 uVar3;\n  uint uVar4;\n  undefined4 extraout_r1;\n  int iVar5;\n  uint *puVar6;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  undefined4 extraout_r1_02;\n  undefined4 uVar7;\n  uint **ppuVar8;\n  int iVar9;\n  int iVar10;\n  undefined4 *puVar11;\n  undefined4 uVar12;\n  uint uVar13;\n  uint *puVar14;\n  int iVar15;\n  int iVar16;\n  undefined8 *puVar17;\n  undefined8 *puVar18;\n  undefined8 *puVar19;\n  undefined4 *puVar20;\n  undefined8 *puVar21;\n  undefined4 uVar22;\n  int iVar23;\n  undefined4 *puVar24;\n  bool bVar25;\n  undefined8 uVar26;\n  undefined8 uVar27;\n  undefined8 uVar28;\n  undefined8 uVar29;\n  ulonglong uVar30;\n  undefined4 in_stack_fffffd78;\n  int local_280;\n  int local_26c;\n  uint *local_260 [2];\n  uint local_258 [20];\n  undefined8 uStack_208;\n  undefined4 local_168;\n  undefined4 uStack_164;\n  undefined8 local_160;\n  undefined8 uStack_c8;\n  \n  uVar29 = CONCAT44(param_5,param_5);\n  iVar16 = *(int *)(PTR_init_jk_0800a894 + param_5 * 4);\n  iVar9 = param_4 + -1;\n  local_260[1] = (uint *)param_2;\n  if (param_3 + 0x14 < 0 == SCARRY4(param_3,0x14)) {\n    local_26c = (int)((longlong)DAT_0800a898 * (longlong)(param_3 + -3) >> 0x22) -\n                (param_3 + -3 >> 0x1f);\n    iVar10 = (local_26c + 1) * -0x18;\n  }\n  else {\n    iVar10 = -0x18;\n    local_26c = 0;\n  }\n  param_3 = param_3 + iVar10;\n  iVar10 = local_26c - iVar9;\n  if (-1 < iVar16 + iVar9) {\n    iVar23 = iVar16 + iVar9 + 1 + iVar10;\n    puVar19 = &uStack_208;\n    do {\n      while (iVar10 < 0) {\n        iVar10 = iVar10 + 1;\n        *(undefined4 *)puVar19 = 0;\n        *(undefined4 *)((int)puVar19 + 4) = 0;\n        puVar19 = puVar19 + 1;\n        if (iVar10 == iVar23) goto LAB_0800a626;\n      }\n      uVar27 = __aeabi_i2d(*(undefined4 *)(param_6 + iVar10 * 4));\n      iVar10 = iVar10 + 1;\n      *puVar19 = uVar27;\n      puVar19 = puVar19 + 1;\n    } while (iVar10 != iVar23);\n  }\nLAB_0800a626:\n  puVar11 = (undefined4 *)(param_1 + -8);\n  if (-1 < iVar16) {\n    puVar17 = &uStack_208 + param_4;\n    iVar23 = iVar16 + param_4;\n    iVar10 = iVar9;\n    puVar19 = &uStack_c8;\n    do {\n      if (iVar9 < 0) {\n        uVar27 = 0;\n      }\n      else {\n        uVar27 = 0;\n        puVar24 = puVar11;\n        puVar21 = puVar17;\n        do {\n          puVar20 = puVar24 + 2;\n          uVar26 = __muldf3(*puVar20,puVar24[3],*(undefined4 *)(puVar21 + -1),\n                            *(undefined4 *)((int)puVar21 + -4));\n          uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,\n                                (int)((ulonglong)uVar26 >> 0x20));\n          puVar24 = puVar20;\n          puVar21 = puVar21 + -1;\n        } while (puVar20 != puVar11 + param_4 * 2);\n      }\n      iVar10 = iVar10 + 1;\n      *puVar19 = uVar27;\n      puVar17 = puVar17 + 1;\n      puVar19 = puVar19 + 1;\n    } while (iVar10 != iVar23);\n  }\n  local_260[0] = local_258 + iVar16 + -1;\n  local_280 = iVar16;\n  do {\n    iVar23 = *(int *)(&uStack_c8 + local_280);\n    uVar27 = CONCAT44(*(undefined4 *)((int)&uStack_c8 + local_280 * 8 + 4),iVar23);\n    iVar10 = local_280;\n    if (0 < local_280) {\n      puVar19 = &uStack_c8 + local_280;\n      puVar6 = local_258;\n      do {\n        uVar7 = (undefined4)((ulonglong)uVar27 >> 0x20);\n        __muldf3((int)uVar27,uVar7,0,DAT_0800a89c);\n        __aeabi_d2iz();\n        uVar26 = __aeabi_i2d();\n        uVar3 = (undefined4)((ulonglong)uVar26 >> 0x20);\n        uVar28 = __muldf3((int)uVar26,uVar3,0,DAT_0800a8a0);\n        __subdf3((int)uVar27,uVar7,(int)uVar28,(int)((ulonglong)uVar28 >> 0x20));\n        uVar2 = __aeabi_d2iz();\n        puVar17 = puVar19 + -1;\n        uVar7 = *(undefined4 *)puVar17;\n        uVar12 = *(undefined4 *)((int)puVar19 + -4);\n        *puVar6 = uVar2;\n        uVar27 = __aeabi_dadd((int)uVar26,uVar3,uVar7,uVar12);\n        iVar23 = (int)uVar27;\n        puVar19 = puVar17;\n        puVar6 = puVar6 + 1;\n      } while (puVar17 != &uStack_c8);\n    }\n    scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),iVar23);\n    __muldf3();\n    floor((double)CONCAT44(iVar10,in_stack_fffffd78));\n    uVar27 = __muldf3();\n    uVar27 = __subdf3(iVar23,extraout_r1,(int)uVar27,(int)((ulonglong)uVar27 >> 0x20));\n    uVar2 = __aeabi_d2iz();\n    uVar26 = __aeabi_i2d();\n    uVar27 = __subdf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,\n                      (int)((ulonglong)uVar26 >> 0x20));\n    uVar7 = (undefined4)((ulonglong)uVar27 >> 0x20);\n    uVar3 = (undefined4)uVar27;\n    if (param_3 < 1) {\n      if (param_3 == 0) {\n        iVar23 = (int)local_258[iVar10 + -1] >> 0x17;\n        goto joined_r0x0800a8b8;\n      }\n      iVar23 = __aeabi_dcmpge(uVar3,uVar7,0,DAT_0800ac3c);\n      if (iVar23 != 0) {\n        uVar2 = uVar2 + 1;\n        if (iVar10 < 1) {\n          uVar27 = __subdf3(0,DAT_0800ac38,uVar3,uVar7);\n          iVar23 = 2;\n          goto LAB_0800a7a4;\n        }\n        iVar23 = 2;\n        goto LAB_0800a8c8;\n      }\n    }\n    else {\n      iVar5 = (int)local_258[iVar10 + -1] >> (0x18U - param_3 & 0xff);\n      uVar13 = local_258[iVar10 + -1] - (iVar5 << (0x18U - param_3 & 0xff));\n      iVar23 = (int)uVar13 >> (0x17U - param_3 & 0xff);\n      local_258[iVar10 + -1] = uVar13;\n      uVar2 = uVar2 + iVar5;\njoined_r0x0800a8b8:\n      if (0 < iVar23) {\n        uVar2 = uVar2 + 1;\n        if (iVar10 < 1) {\n          uVar13 = 0;\n        }\n        else {\nLAB_0800a8c8:\n          uVar13 = local_258[0];\n          if (local_258[0] == 0) {\n            if (iVar10 != 1) {\n              puVar6 = local_258;\n              iVar5 = 1;\n              do {\n                puVar6 = puVar6 + 1;\n                uVar13 = *puVar6;\n                if (uVar13 != 0) {\n                  iVar15 = iVar5 + 1;\n                  goto LAB_0800a8e2;\n                }\n                iVar5 = iVar5 + 1;\n              } while (iVar5 != iVar10);\n            }\n          }\n          else {\n            iVar15 = 1;\n            iVar5 = 0;\nLAB_0800a8e2:\n            local_258[iVar5] = 0x1000000 - uVar13;\n            if (iVar15 < iVar10) {\n              uVar13 = local_258[iVar15];\n              puVar6 = local_258 + iVar15;\n              while( true ) {\n                puVar14 = puVar6 + 1;\n                *puVar6 = 0xffffff - uVar13;\n                if (puVar14 == local_258 + iVar10) break;\n                uVar13 = *puVar14;\n                puVar6 = puVar14;\n              }\n            }\n            uVar13 = 1;\n          }\n        }\n        if (0 < param_3) {\n          if (param_3 == 1) {\n            local_258[iVar10 + -1] = local_258[iVar10 + -1] & 0x7fffff;\n          }\n          else if (param_3 == 2) {\n            local_258[iVar10 + -1] = local_258[iVar10 + -1] & 0x3fffff;\n          }\n        }\n        if (iVar23 == 2) {\n          uVar27 = __subdf3(0,DAT_0800ac38,uVar3,uVar7);\n          if (uVar13 != 0) {\n            uVar3 = 0;\n            scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),0);\n            uVar27 = __subdf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),uVar3,extraout_r1_00);\n          }\n        }\n      }\n    }\nLAB_0800a7a4:\n    iVar15 = (int)uVar27;\n    iVar5 = __aeabi_dcmpeq(iVar15,(int)((ulonglong)uVar27 >> 0x20),0,0);\n    if (iVar5 == 0) {\n      scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),iVar15);\n      iVar9 = __aeabi_dcmpge();\n      if (iVar9 == 0) {\n        iVar5 = iVar10;\n        uVar13 = __aeabi_d2iz(iVar15,extraout_r1_02);\n        local_258[iVar5] = uVar13;\n        iVar10 = iVar5;\n      }\n      else {\n        __muldf3(iVar15,extraout_r1_02,0,DAT_0800ade8);\n        uVar13 = __aeabi_d2iz();\n        uVar27 = __aeabi_i2d();\n        uVar27 = __muldf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),0,DAT_0800ade4);\n        __subdf3(iVar15,extraout_r1_02,(int)uVar27,(int)((ulonglong)uVar27 >> 0x20));\n        iVar9 = iVar10;\n        uVar4 = __aeabi_d2iz();\n        iVar5 = iVar10 + 1;\n        local_258[iVar10] = uVar4;\n        local_258[iVar5] = uVar13;\n        iVar10 = iVar9;\n      }\n      goto LAB_0800a9f6;\n    }\n    iVar5 = iVar10 + -1;\n    if (iVar16 <= iVar5) {\n      uVar13 = 0;\n      puVar6 = local_258 + iVar10 + 0x3fffffff;\n      do {\n        puVar14 = puVar6 + -1;\n        uVar13 = uVar13 | *puVar6;\n        puVar6 = puVar14;\n      } while (puVar14 != local_260[0]);\n      if (uVar13 != 0) break;\n    }\n    if (local_258[iVar16 + -1] == 0) {\n      local_280 = 1;\n      ppuVar8 = local_260 + iVar16;\n      do {\n        puVar6 = *ppuVar8;\n        local_280 = local_280 + 1;\n        ppuVar8 = ppuVar8 + -1;\n      } while (puVar6 == (uint *)0x0);\n      local_280 = iVar10 + local_280;\n    }\n    else {\n      local_280 = iVar10 + 1;\n    }\n    iVar23 = iVar10 + 1;\n    puVar24 = (undefined4 *)(param_6 + (iVar23 + local_26c + 0x3fffffff) * 4);\n    puVar19 = &uStack_208 + iVar10 + param_4;\n    puVar17 = &uStack_c8 + iVar23;\n    do {\n      puVar24 = puVar24 + 1;\n      uVar27 = __aeabi_i2d(*puVar24);\n      *puVar19 = uVar27;\n      puVar21 = puVar19 + 1;\n      if (iVar9 < 0) {\n        uVar26 = 0;\n      }\n      else {\n        uVar26 = 0;\n        puVar20 = puVar11;\n        while( true ) {\n          puVar19 = puVar19 + -1;\n          puVar1 = puVar20 + 2;\n          uVar27 = __muldf3((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),*puVar1,puVar20[3]);\n          uVar26 = __aeabi_dadd((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),(int)uVar27,\n                                (int)((ulonglong)uVar27 >> 0x20));\n          if (puVar1 == puVar11 + param_4 * 2) break;\n          uVar27 = *puVar19;\n          puVar20 = puVar1;\n        }\n      }\n      *puVar17 = uVar26;\n      iVar23 = iVar23 + 1;\n      puVar19 = puVar21;\n      puVar17 = puVar17 + 1;\n    } while (iVar23 <= local_280);\n  } while( true );\n  if (local_258[iVar5] == 0) {\n    puVar6 = local_258 + iVar10 + 0x3ffffffe;\n    do {\n      uVar13 = *puVar6;\n      iVar5 = iVar5 + -1;\n      puVar6 = puVar6 + -1;\n    } while (uVar13 == 0);\n  }\nLAB_0800a9f6:\n  uVar3 = 0;\n  scalbn((double)CONCAT44(iVar10,in_stack_fffffd78),0);\n  uVar27 = CONCAT44(extraout_r1_01,uVar3);\n  if (iVar5 < 0) {\n    if (2 < param_5) {\n      if (param_5 == 3) {\n        puVar19 = (undefined8 *)&local_168;\n        uVar29 = 0;\nLAB_0800abe4:\n        if (iVar23 == 0) {\n          uVar3 = *(undefined4 *)(puVar19 + 1);\n          uVar7 = *(undefined4 *)((int)puVar19 + 0xc);\n          *local_260[1] = local_168;\n          *(undefined4 *)((int)local_260[1] + 4) = uStack_164;\n          *(undefined8 *)((int)local_260[1] + 0x10) = uVar29;\n          *(undefined4 *)((int)local_260[1] + 8) = uVar3;\n          *(undefined4 *)((int)local_260[1] + 0xc) = uVar7;\n          return uVar2 & 7;\n        }\n        iVar9 = *(int *)((int)puVar19 + 4);\n        *(int *)((int)local_260[1] + 0x10) = (int)uVar29;\n        iVar16 = *(int *)((int)puVar19 + 0xc);\n        *(undefined4 *)((int)local_260[1] + 8) = *(undefined4 *)(puVar19 + 1);\n        *(int *)((int)local_260[1] + 0x14) = (int)((ulonglong)uVar29 >> 0x20) + -0x80000000;\n        uVar3 = *(undefined4 *)puVar19;\n        *(int *)((int)local_260[1] + 4) = iVar9 + -0x80000000;\n        *(int *)((int)local_260[1] + 0xc) = iVar16 + -0x80000000;\n        *local_260[1] = uVar3;\n        return uVar2 & 7;\n      }\n      goto LAB_0800ab0e;\n    }\n    if (param_5 < 1) {\n      if (param_5 != 0) goto LAB_0800ab0e;\nLAB_0800aafc:\n      iVar9 = (int)((ulonglong)uVar29 >> 0x20);\n      if (iVar23 != 0) {\n        iVar9 = iVar9 + -0x80000000;\n      }\n      *local_260[1] = (int)uVar29;\n      *(int *)((int)local_260[1] + 4) = iVar9;\nLAB_0800ab0e:\n      return uVar2 & 7;\n    }\n    uVar29 = 0;\n  }\n  else {\n    puVar17 = &uStack_c8 + iVar5;\n    puVar6 = local_258 + iVar5 + 1;\n    puVar19 = &uStack_c8 + iVar5 + 1;\n    do {\n      uVar3 = (undefined4)((ulonglong)uVar27 >> 0x20);\n      puVar6 = puVar6 + -1;\n      uVar26 = __aeabi_i2d(*puVar6);\n      uVar26 = __muldf3((int)uVar26,(int)((ulonglong)uVar26 >> 0x20),(int)uVar27,uVar3);\n      puVar19 = puVar19 + -1;\n      *puVar19 = uVar26;\n      uVar27 = __muldf3((int)uVar27,uVar3,0,DAT_0800ac40);\n    } while (puVar6 != local_258);\n    puVar19 = (undefined8 *)&local_168;\n    iVar9 = 0;\n    uVar3 = DAT_0800ac30;\n    uVar7 = DAT_0800ac34;\n    do {\n      DAT_0800ac30 = uVar3;\n      DAT_0800ac34 = uVar7;\n      if (iVar16 < 0) {\n        uVar27 = 0;\n      }\n      else {\n        uVar27 = 0;\n        iVar10 = 0;\n        puVar21 = puVar17;\n        puVar11 = (undefined4 *)PTR_DAT_0800ac44;\n        while( true ) {\n          uVar26 = __muldf3(*(undefined4 *)puVar21,*(undefined4 *)((int)puVar21 + 4),uVar3,uVar7);\n          uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),(int)uVar26,\n                                (int)((ulonglong)uVar26 >> 0x20));\n          iVar10 = iVar10 + 1;\n          if ((iVar16 < iVar10) || (iVar9 < iVar10)) break;\n          uVar3 = *puVar11;\n          uVar7 = puVar11[1];\n          puVar21 = puVar21 + 1;\n          puVar11 = puVar11 + 2;\n        }\n      }\n      bVar25 = iVar9 != iVar5;\n      puVar19[iVar9] = uVar27;\n      puVar17 = puVar17 + -1;\n      iVar9 = iVar9 + 1;\n      uVar3 = DAT_0800ac30;\n      uVar7 = DAT_0800ac34;\n    } while (bVar25);\n    if (2 < param_5) {\n      if (param_5 == 3) {\n        if (iVar5 != 0) {\n          puVar17 = puVar19 + iVar5;\n          uVar29 = *puVar17;\n          do {\n            uVar7 = (undefined4)((ulonglong)uVar29 >> 0x20);\n            uVar3 = (undefined4)uVar29;\n            uVar12 = *(undefined4 *)(puVar17 + -1);\n            uVar22 = *(undefined4 *)((int)puVar17 + -4);\n            uVar29 = __aeabi_dadd(uVar3,uVar7,uVar12,uVar22);\n            uVar27 = __subdf3(uVar12,uVar22,(int)uVar29,(int)((ulonglong)uVar29 >> 0x20));\n            uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),uVar3,uVar7);\n            *puVar17 = uVar27;\n            puVar17 = puVar17 + -1;\n            *puVar17 = uVar29;\n          } while (puVar19 != puVar17);\n          if (1 < iVar5) {\n            puVar21 = puVar19 + iVar5;\n            uVar29 = *puVar21;\n            puVar17 = puVar21;\n            do {\n              uVar7 = (undefined4)((ulonglong)uVar29 >> 0x20);\n              uVar3 = (undefined4)uVar29;\n              uVar12 = *(undefined4 *)(puVar17 + -1);\n              uVar22 = *(undefined4 *)((int)puVar17 + -4);\n              uVar29 = __aeabi_dadd(uVar3,uVar7,uVar12,uVar22);\n              uVar27 = __subdf3(uVar12,uVar22,(int)uVar29,(int)((ulonglong)uVar29 >> 0x20));\n              uVar27 = __aeabi_dadd((int)uVar27,(int)((ulonglong)uVar27 >> 0x20),uVar3,uVar7);\n              *puVar17 = uVar27;\n              puVar17 = puVar17 + -1;\n              *puVar17 = uVar29;\n            } while (&local_160 != puVar17);\n            uVar29 = 0;\n            puVar18 = puVar19 + 2;\n            puVar17 = puVar21 + 1;\n            do {\n              puVar21 = puVar17 + -1;\n              uVar29 = __aeabi_dadd((int)uVar29,(int)((ulonglong)uVar29 >> 0x20),\n                                    *(undefined4 *)puVar21,*(undefined4 *)((int)puVar17 + -4));\n              puVar17 = puVar21;\n            } while (puVar18 != puVar21);\n            goto LAB_0800abe4;\n          }\n        }\n        uVar29 = 0;\n        goto LAB_0800abe4;\n      }\n      goto LAB_0800ab0e;\n    }\n    if (param_5 < 1) {\n      if (param_5 != 0) goto LAB_0800ab0e;\n      puVar17 = puVar19 + iVar5 + 1;\n      do {\n        puVar21 = puVar17 + -1;\n        uVar29 = __aeabi_dadd((int)uVar29,(int)((ulonglong)uVar29 >> 0x20),*(undefined4 *)puVar21,\n                              *(undefined4 *)((int)puVar17 + -4));\n        puVar17 = puVar21;\n      } while (puVar19 != puVar21);\n      goto LAB_0800aafc;\n    }\n    uVar29 = 0;\n    puVar17 = puVar19 + iVar5 + 1;\n    do {\n      puVar21 = puVar17 + -1;\n      uVar29 = __aeabi_dadd((int)uVar29,(int)((ulonglong)uVar29 >> 0x20),*(undefined4 *)puVar21,\n                            *(undefined4 *)((int)puVar17 + -4));\n      puVar17 = puVar21;\n    } while (puVar19 != puVar21);\n  }\n  iVar9 = (int)((ulonglong)uVar29 >> 0x20);\n  uVar3 = (undefined4)uVar29;\n  if (iVar23 == 0) {\n    *(undefined8 *)local_260[1] = uVar29;\n    uVar30 = __subdf3(local_168,uStack_164,uVar3,iVar9);\n    if (iVar5 < 1) goto LAB_0800ad26;\nLAB_0800ad04:\n    iVar9 = 1;\n    puVar19 = (undefined8 *)&local_168;\n    do {\n      uVar30 = __aeabi_dadd((int)uVar30,(int)(uVar30 >> 0x20),*(undefined4 *)(puVar19 + 1),\n                            *(undefined4 *)((int)puVar19 + 0xc));\n      iVar9 = iVar9 + 1;\n      puVar19 = puVar19 + 1;\n    } while (iVar9 <= iVar5);\n    if (iVar23 == 0) goto LAB_0800ad26;\n  }\n  else {\n    *local_260[1] = uVar3;\n    *(int *)((int)local_260[1] + 4) = iVar9 + -0x80000000;\n    uVar30 = __subdf3(local_168,uStack_164,uVar3,iVar9);\n    if (0 < iVar5) goto LAB_0800ad04;\n  }\n  uVar30 = uVar30 & 0xffffffff | (ulonglong)((int)(uVar30 >> 0x20) + 0x80000000) << 0x20;\nLAB_0800ad26:\n  *(ulonglong *)((int)local_260[1] + 8) = uVar30;\n  return uVar2 & 7;\n}\n\n",
            "called": [
                "scalbn",
                "floor",
                "__muldf3",
                "__aeabi_dcmpeq",
                "__aeabi_dcmpge",
                "__aeabi_d2iz",
                "__aeabi_i2d",
                "__aeabi_dadd",
                "__subdf3"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0800a5a0",
            "calling": [
                "__ieee754_rem_pio2"
            ],
            "imported": false,
            "current_name": "FUNC_0800a5a0"
        },
        "FUN_0800195c": {
            "renaming": {
                "FUN_0800195c": "check_and_reset_system_0800195c",
                "mc_reset": "resetSystem"
            },
            "code": "\nvoid checkAndResetSystem_0800195c(void)\n\n{\n  if ((PTR_sys_08001990[1] != '\\x06') && ((PTR_sys_08001990[2] & 0x20) == 0)) {\n    resetSystem();\n    PTR_sys_08001990[2] = PTR_sys_08001990[2] | 0x40;\n  }\n  return;\n}\n\n",
            "called": [
                "mc_reset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800195c",
            "calling": [
                "debounce_on_handler"
            ],
            "imported": false,
            "current_name": "check_and_reset_system_0800195c"
        },
        "FUN_08009214": {
            "renaming": {
                "FUN_08009214": "compare_floats_08009214",
                "in_ZR": "comparison_result"
            },
            "code": "\nbool compare_floats_08009214(void)\n\n{\n  char comparison_result;\n  \n  __aeabi_cfcmpeq();\n  return comparison_result != '\\0';\n}\n\n",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009214",
            "calling": [
                "planner_forward_pass_kernel",
                "mc_arc",
                "gc_execute_line",
                "settings_store_global_setting",
                "read_float",
                "planner_reverse_pass_kernel"
            ],
            "imported": false,
            "current_name": "compare_floats_08009214"
        },
        "FUN_08004dd2": {
            "renaming": {
                "FUN_08004dd2": "load_eeprom_settings_08004dd2",
                "bVar1": "eeprom_version",
                "iVar2": "checksum_result",
                "version": "is_valid"
            },
            "code": "\nuint8_t load_eeprom_settings_08004dd2(void)\n\n{\n  byte eeprom_version;\n  int checksum_result;\n  uint8_t is_valid;\n  \n  eeprom_version = eeprom_get_char(0);\n  if (eeprom_version == 5) {\n    checksum_result = memcpy_from_eeprom_with_checksum(PTR_settings_08004e2c,1,0x40);\n    if (checksum_result == 0) {\n      return '\\0';\n    }\n  }\n  else {\n    if (4 < eeprom_version) {\n      return '\\0';\n    }\n    checksum_result = memcpy_from_eeprom_with_checksum(PTR_settings_08004e2c,1,0x28);\n    if (checksum_result == 0) {\n      return '\\0';\n    }\n    settings_reset(false);\n  }\n  return '\\x01';\n}\n\n",
            "called": [
                "memcpy_from_eeprom_with_checksum",
                "settings_reset",
                "eeprom_get_char"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004dd2",
            "calling": [
                "settings_init"
            ],
            "imported": false,
            "current_name": "load_eeprom_settings_08004dd2"
        },
        "FUN_08008244": {
            "renaming": {
                "FUN_08008244": "do_nothing_08008244"
            },
            "code": "\nvoid do_nothing_08008244(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008244",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "do_nothing_08008244"
        },
        "FUN_08005778": {
            "renaming": {
                "FUN_08005778": "update_step_bits_08005778",
                "step_wr": "writeStep"
            },
            "code": "\nvoid updateStepBits_08005778(void)\n\n{\n  writeStep((uint)*(ushort *)PTR_saved_step_bits_0800578c);\n  return;\n}\n\n",
            "called": [
                "step_wr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005778",
            "calling": [
                "TIM2_IRQHandler"
            ],
            "imported": false,
            "current_name": "update_step_bits_08005778"
        },
        "FUN_080028bc": {
            "renaming": {
                "FUN_080028bc": "calculate_final_velocity_080028bc",
                "initial_rate": "initial_velocity",
                "target_rate": "final_velocity",
                "in_r0": "initial_velocity_squared",
                "in_r1": "final_velocity_squared",
                "in_r2": "double_acceleration",
                "uVar1": "velocity_difference",
                "uVar2": "temp_result",
                "fVar3": "result"
            },
            "code": "\nfloat calculate_final_velocity_080028bc(float initial_velocity,float final_velocity,float acceleration)\n\n{\n  undefined4 initial_velocity_squared;\n  undefined4 velocity_difference;\n  undefined4 temp_result;\n  undefined4 final_velocity_squared;\n  undefined4 double_acceleration;\n  float result;\n  \n  velocity_difference = __aeabi_fmul(final_velocity_squared,final_velocity_squared);\n  temp_result = __aeabi_fmul(initial_velocity_squared,initial_velocity_squared);\n  velocity_difference = __aeabi_fsub(velocity_difference,temp_result);\n  temp_result = __addsf3(double_acceleration,double_acceleration);\n  result = (float)__aeabi_fdiv(velocity_difference,temp_result);\n  return result;\n}\n\n",
            "called": [
                "__aeabi_fsub",
                "__aeabi_fdiv",
                "__addsf3",
                "__aeabi_fmul"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080028bc",
            "calling": [
                "calculate_trapezoid_for_block"
            ],
            "imported": false,
            "current_name": "calculate_final_velocity_080028bc"
        },
        "FUN_08006628": {
            "renaming": {
                "FUN_08006628": "update_system_core_clock_08006628",
                "uVar1": "sysClockFreq",
                "uVar2": "leadingZeroesCount",
                "result": "updatedSysClock",
                "result_1": "unusedVariable"
            },
            "code": "\nuint32_t UpdateSystemCoreClock_08006628(void)\n\n{\n  uint32_t sysClockFreq;\n  uint leadingZeroesCount;\n  uint32_t updatedSysClock;\n  uint32_t unusedVariable;\n  \n  sysClockFreq = HAL_RCC_GetSysClockFreq();\n  leadingZeroesCount = count_leading_zeroes(0xf000000);\n  *(uint32_t *)PTR_SystemCoreClock_0800667c =\n       sysClockFreq >> PTR_APBAHBPrescTable_08006678\n                [(*(uint *)(DAT_08006674 + 8) & 0xf0) >> (leadingZeroesCount & 0xff)];\n  return *(uint32_t *)PTR_SystemCoreClock_0800667c;\n}\n\n",
            "called": [
                "HAL_RCC_GetSysClockFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006628",
            "calling": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_ClockConfig"
            ],
            "imported": false,
            "current_name": "update_system_core_clock_08006628"
        },
        "FUN_080078e2": {
            "renaming": {
                "FUN_080078e2": "do_nothing_080078e2"
            },
            "code": "\nvoid do_nothing_080078e2(uint32_t bits)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080078e2",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_080078e2"
        },
        "FUN_08008b38": {
            "renaming": {
                "FUN_08008b38": "compare_floats_08008b38",
                "in_ZR": "zero_flag",
                "in_CY": "carry_flag"
            },
            "code": "\nbool compare_floats_08008b38(void)\n\n{\n  undefined zero_flag;\n  undefined carry_flag;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)carry_flag || (bool)zero_flag;\n}\n\n",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b38",
            "calling": [],
            "imported": false,
            "current_name": "compare_floats_08008b38"
        },
        "FUN_0800738e": {
            "renaming": {
                "FUN_0800738e": "handle_gpio_interrupt_0800738e",
                "GPIO_Pin": "gpio_pin"
            },
            "code": "\nvoid handle_GPIO_interrupt_0800738e(uint16_t gpio_pin)\n\n{\n  if (((uint)gpio_pin & *(uint *)(DAT_080073bc + 0x14)) != 0) {\n    *(uint *)(DAT_080073bc + 0x14) = (uint)gpio_pin;\n    HAL_GPIO_EXTI_Callback(gpio_pin);\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800738e",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_interrupt_0800738e"
        },
        "FUN_08002828": {
            "renaming": {
                "FUN_08002828": "do_nothing_08002828"
            },
            "code": "\nvoid do_nothing_08002828(uint32_t us)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002828",
            "calling": [
                "homing_cycle"
            ],
            "imported": false,
            "current_name": "do_nothing_08002828"
        },
        "FUN_080053a0": {
            "renaming": {
                "FUN_080053a0": "process_movement_080053a0",
                "pbVar1": "currentBlock",
                "iVar2": "cycleCounterResult"
            },
            "code": "\nvoid process_movement_080053a0(void)\n\n{\n  block_t *currentBlock;\n  int cycleCounterResult;\n  \n  dirn_wr((uint)*(ushort *)PTR_dirn_bits_080055f0);\n  *(undefined2 *)PTR_saved_step_bits_080055f8 = *(undefined2 *)PTR_step_bits_080055f4;\n  if (*(int *)PTR_current_block_080055fc == 0) {\n    currentBlock = plan_get_current_block();\n    *(block_t **)PTR_current_block_080055fc = currentBlock;\n    if (*(int *)PTR_current_block_080055fc == 0) {\n      st_go_idle();\n      PTR_sys_08005600[2] = PTR_sys_08005600[2] | 4;\n    }\n    else {\n      if (PTR_sys_08005600[1] == '\\x03') {\n        *(undefined4 *)(PTR_st_08005604 + 0x1c) =\n             *(undefined4 *)(*(int *)PTR_current_block_080055fc + 0x28);\n        set_step_events_per_minute(*(uint32_t *)(PTR_st_08005604 + 0x1c));\n        *(undefined4 *)(PTR_st_08005604 + 0x18) = DAT_08005608;\n      }\n      *(int *)(PTR_st_08005604 + 0x20) =\n           (*(int *)(*(int *)PTR_current_block_080055fc + 0x30) >> 1) +\n           *(int *)(*(int *)PTR_current_block_080055fc + 0x30);\n      *(int *)PTR_st_08005604 = -(*(int *)(*(int *)PTR_current_block_080055fc + 0x10) >> 1);\n      *(undefined4 *)(PTR_st_08005604 + 4) = *(undefined4 *)PTR_st_08005604;\n      *(undefined4 *)(PTR_st_08005604 + 8) = *(undefined4 *)PTR_st_08005604;\n      *(undefined4 *)(PTR_st_08005604 + 0xc) =\n           *(undefined4 *)(*(int *)PTR_current_block_080055fc + 0x10);\n      *(undefined4 *)(PTR_st_08005604 + 0x10) = 0;\n    }\n  }\n  if (*(int *)PTR_current_block_080055fc != 0) {\n    *(undefined2 *)PTR_dirn_bits_080055f0 = **(undefined2 **)PTR_current_block_080055fc;\n    *(undefined2 *)PTR_step_bits_080055f4 = 0;\n    *(int *)PTR_st_08005604 =\n         *(int *)(*(int *)PTR_current_block_080055fc + 4) + *(int *)PTR_st_08005604;\n    if (0 < *(int *)PTR_st_08005604) {\n      *(ushort *)PTR_step_bits_080055f4 = *(ushort *)PTR_step_bits_080055f4 | 0x10;\n      *(int *)PTR_st_08005604 = *(int *)PTR_st_08005604 - *(int *)(PTR_st_08005604 + 0xc);\n      if ((*(ushort *)PTR_dirn_bits_080055f0 & 0x20) == 0) {\n        *(int *)(PTR_sys_08005600 + 4) = *(int *)(PTR_sys_08005600 + 4) + 1;\n      }\n      else {\n        *(int *)(PTR_sys_08005600 + 4) = *(int *)(PTR_sys_08005600 + 4) + -1;\n      }\n    }\n    *(int *)(PTR_st_08005604 + 4) =\n         *(int *)(*(int *)PTR_current_block_080055fc + 8) + *(int *)(PTR_st_08005604 + 4);\n    if (0 < *(int *)(PTR_st_08005604 + 4)) {\n      *(ushort *)PTR_step_bits_080055f4 = *(ushort *)PTR_step_bits_080055f4 | 0x440;\n      *(int *)(PTR_st_08005604 + 4) =\n           *(int *)(PTR_st_08005604 + 4) - *(int *)(PTR_st_08005604 + 0xc);\n      if ((*(ushort *)PTR_dirn_bits_080055f0 & 0x80) == 0) {\n        *(int *)(PTR_sys_08005600 + 8) = *(int *)(PTR_sys_08005600 + 8) + 1;\n      }\n      else {\n        *(int *)(PTR_sys_08005600 + 8) = *(int *)(PTR_sys_08005600 + 8) + -1;\n      }\n    }\n    *(int *)(PTR_st_08005604 + 8) =\n         *(int *)(*(int *)PTR_current_block_080055fc + 0xc) + *(int *)(PTR_st_08005604 + 8);\n    if (0 < *(int *)(PTR_st_08005604 + 8)) {\n      *(ushort *)PTR_step_bits_080055f4 = *(ushort *)PTR_step_bits_080055f4 | 0x100;\n      *(int *)(PTR_st_08005604 + 8) =\n           *(int *)(PTR_st_08005604 + 8) - *(int *)(PTR_st_08005604 + 0xc);\n      if ((*(ushort *)PTR_dirn_bits_080055f0 & 0x200) == 0) {\n        *(int *)(PTR_sys_08005600 + 0xc) = *(int *)(PTR_sys_08005600 + 0xc) + 1;\n      }\n      else {\n        *(int *)(PTR_sys_08005600 + 0xc) = *(int *)(PTR_sys_08005600 + 0xc) + -1;\n      }\n    }\n    *(int *)(PTR_st_08005604 + 0x10) = *(int *)(PTR_st_08005604 + 0x10) + 1;\n    if (*(uint *)(PTR_st_08005604 + 0x10) < *(uint *)(*(int *)PTR_current_block_080055fc + 0x10)) {\n      if (PTR_sys_08005600[1] == '\\x04') {\n        cycleCounterResult = iterate_trapezoid_cycle_counter();\n        if (cycleCounterResult != 0) {\n          if (*(uint *)(*(int *)PTR_current_block_080055fc + 0x30) <\n              *(uint *)(PTR_st_08005604 + 0x1c)) {\n            *(int *)(PTR_st_08005604 + 0x1c) =\n                 *(int *)(PTR_st_08005604 + 0x1c) -\n                 *(int *)(*(int *)PTR_current_block_080055fc + 0x30);\n            set_step_events_per_minute(*(uint32_t *)(PTR_st_08005604 + 0x1c));\n          }\n          else {\n            st_go_idle();\n            PTR_sys_08005600[2] = PTR_sys_08005600[2] | 4;\n          }\n        }\n      }\n      else if (*(uint *)(PTR_st_08005748 + 0x10) <\n               *(uint *)(*(int *)PTR_current_block_0800574c + 0x34)) {\n        cycleCounterResult = iterate_trapezoid_cycle_counter();\n        if (cycleCounterResult != 0) {\n          *(int *)(PTR_st_08005748 + 0x1c) =\n               *(int *)(PTR_st_08005748 + 0x1c) +\n               *(int *)(*(int *)PTR_current_block_0800574c + 0x30);\n          if (*(uint *)(*(int *)PTR_current_block_0800574c + 0x3c) <=\n              *(uint *)(PTR_st_08005748 + 0x1c)) {\n            *(undefined4 *)(PTR_st_08005748 + 0x1c) =\n                 *(undefined4 *)(*(int *)PTR_current_block_0800574c + 0x3c);\n          }\n          set_step_events_per_minute(*(uint32_t *)(PTR_st_08005748 + 0x1c));\n        }\n      }\n      else if (*(uint *)(PTR_st_08005748 + 0x10) <\n               *(uint *)(*(int *)PTR_current_block_0800574c + 0x38)) {\n        if (*(int *)(PTR_st_08005748 + 0x1c) != *(int *)(*(int *)PTR_current_block_0800574c + 0x3c))\n        {\n          *(undefined4 *)(PTR_st_08005748 + 0x1c) =\n               *(undefined4 *)(*(int *)PTR_current_block_0800574c + 0x3c);\n          set_step_events_per_minute(*(uint32_t *)(PTR_st_08005748 + 0x1c));\n        }\n      }\n      else if (*(int *)(PTR_st_08005748 + 0x10) ==\n               *(int *)(*(int *)PTR_current_block_0800574c + 0x38)) {\n        if (*(int *)(PTR_st_08005748 + 0x1c) == *(int *)(*(int *)PTR_current_block_0800574c + 0x3c))\n        {\n          *(undefined4 *)(PTR_st_08005748 + 0x18) = DAT_08005750;\n        }\n        else {\n          *(int *)(PTR_st_08005748 + 0x18) = 420000 - *(int *)(PTR_st_08005748 + 0x18);\n        }\n      }\n      else {\n        cycleCounterResult = iterate_trapezoid_cycle_counter();\n        if (cycleCounterResult != 0) {\n          if (*(uint *)(PTR_st_08005748 + 0x20) < *(uint *)(PTR_st_08005748 + 0x1c)) {\n            *(int *)(PTR_st_08005748 + 0x1c) =\n                 *(int *)(PTR_st_08005748 + 0x1c) -\n                 *(int *)(*(int *)PTR_current_block_0800574c + 0x30);\n          }\n          else {\n            *(uint *)(PTR_st_08005748 + 0x1c) = *(uint *)(PTR_st_08005748 + 0x1c) >> 1;\n          }\n          if (*(uint *)(PTR_st_08005748 + 0x1c) <\n              *(uint *)(*(int *)PTR_current_block_0800574c + 0x2c)) {\n            *(undefined4 *)(PTR_st_08005748 + 0x1c) =\n                 *(undefined4 *)(*(int *)PTR_current_block_0800574c + 0x2c);\n          }\n          set_step_events_per_minute(*(uint32_t *)(PTR_st_08005748 + 0x1c));\n        }\n      }\n    }\n    else {\n      *(undefined2 *)PTR_step_bits_08005754 = 0;\n      *(undefined4 *)PTR_current_block_0800574c = 0;\n      plan_discard_current_block();\n    }\n  }\n  *(ushort *)PTR_step_bits_08005754 =\n       *(ushort *)PTR_step_bits_08005754 ^ *(ushort *)(PTR_settings_08005758 + 0x18);\n  *(ushort *)PTR_dirn_bits_0800575c =\n       *(ushort *)PTR_dirn_bits_0800575c ^ *(ushort *)(PTR_settings_08005758 + 0x1a);\n  return;\n}\n\n",
            "called": [
                "st_go_idle",
                "iterate_trapezoid_cycle_counter",
                "plan_get_current_block",
                "set_step_events_per_minute",
                "plan_discard_current_block",
                "dirn_wr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080053a0",
            "calling": [
                "TIM2_IRQHandler"
            ],
            "imported": false,
            "current_name": "process_movement_080053a0"
        },
        "FUN_080092c4": {
            "renaming": {
                "FUN_080092c4": "initialize_system_080092c4",
                "iVar1": "index",
                "puVar2": "dataPointer",
                "UNRECOVERED_JUMPTABLE": "unresolvedJumpTable"
            },
            "code": "\nvoid initializeSystem_080092c4(void)\n\n{\n  int index;\n  undefined4 *dataPointer;\n  code *unresolvedJumpTable;\n  \n  for (index = 0; dataPointer = (undefined4 *)PTR_completed_8911_0800930c,\n      PTR_SystemCoreClock_08009304 + index < PTR_completed_8911_08009308; index = index + 4) {\n    *(undefined4 *)(PTR_SystemCoreClock_08009304 + index) =\n         *(undefined4 *)(PTR___fini_array_end_08009300 + index);\n  }\n  for (; dataPointer < PTR__ebss_08009310; dataPointer = dataPointer + 1) {\n    *dataPointer = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  unresolvedJumpTable = (code *)0x80092fa;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x080092fa. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*unresolvedJumpTable)();\n  return;\n}\n\n",
            "called": [
                "main",
                "SystemInit",
                "__libc_init_array"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080092c4",
            "calling": [],
            "imported": false,
            "current_name": "initialize_system_080092c4"
        },
        "FUN_0800770e": {
            "renaming": {
                "FUN_0800770e": "do_nothing_0800770e"
            },
            "code": "\nvoid do_nothing_0800770e(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800770e",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0800770e"
        },
        "FUN_08008250": {
            "renaming": {
                "FUN_08008250": "transmit_data_08008250",
                "data": "input_data"
            },
            "code": "\nvoid transmit_data_08008250(uint8_t input_data)\n\n{\n  usart_putc(input_data);\n  return;\n}\n\n",
            "called": [
                "usart_putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008250",
            "calling": [
                "printInteger",
                "printFloat",
                "print_base2",
                "printPgmString",
                "printString",
                "print_uint32_base10"
            ],
            "imported": false,
            "current_name": "transmit_data_08008250"
        },
        "FUN_0800184c": {
            "renaming": {
                "FUN_0800184c": "parse_letter_and_float_0800184c",
                "letter": "parsed_letter",
                "float_ptr": "parsed_float_ptr",
                "line": "input_line",
                "char_counter": "position",
                "iVar1": "result"
            },
            "code": "\nint parse_letter_and_float_0800184c(char *parsed_letter,float *parsed_float_ptr,char *input_line,uint8_t *position)\n\n{\n  int result;\n  \n  if (input_line[*position] == '\\0') {\n    result = 0;\n  }\n  else {\n    *parsed_letter = input_line[*position];\n    if (((byte)*parsed_letter < 0x41) || (0x5a < (byte)*parsed_letter)) {\n      *PTR_gc_080018c8 = 2;\n      result = 0;\n    }\n    else {\n      *position = *position + '\\x01';\n      result = read_float(input_line,position,parsed_float_ptr);\n      if (result == 0) {\n        *PTR_gc_080018c8 = 1;\n        result = 0;\n      }\n      else {\n        result = 1;\n      }\n    }\n  }\n  return result;\n}\n\n",
            "called": [
                "read_float"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800184c",
            "calling": [
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "parse_letter_and_float_0800184c"
        },
        "FUN_08001f00": {
            "renaming": {
                "FUN_08001f00": "arc_interpolation_08001f00",
                "position": "curr_position",
                "target": "target_position",
                "offset": "arc_offset",
                "axis_0": "axis_0_idx",
                "axis_1": "axis_1_idx",
                "axis_linear": "linear_axis_idx",
                "invert_feed_rate": "invert_feed_rate_flag",
                "radius": "arc_radius",
                "isclockwise": "clockwise_flag",
                "uVar1": "linear_travel_diff",
                "uVar2": "temp_result_1",
                "uVar3": "temp_result_2",
                "uVar4": "temp_result_3",
                "uVar5": "temp_result_4",
                "iVar6": "comparison_result",
                "fVar7": "temp_float",
                "z": "z_position",
                "uVar8": "temp_double_1",
                "uVar9": "temp_double_2",
                "in_stack_00000014": "clockwise_byte",
                "uVar10": "temp_uint",
                "bVar11": "axis_0_byte",
                "arc_target": "arc_target_position",
                "r_axisi": "r_axis_initial",
                "sin_Ti": "sin_theta_initial",
                "cos_Ti": "cos_theta_initial",
                "sin_T": "sin_theta",
                "cos_T": "cos_theta",
                "linear_per_segment": "linear_travel_per_segment",
                "segments": "segment_count",
                "rt_axis1": "rotated_axis_1",
                "rt_axis0": "rotated_axis_0",
                "center_axis1": "center_axis_1",
                "center_axis0": "center_axis_0",
                "count": "rotation_count",
                "i": "segment_idx",
                "r_axis1": "r_axis_1",
                "r_axis0": "r_axis_0"
            },
            "code": "\nvosegment_idxd arc_interpolation_08001f00(float *curr_position,float *target_position,float *arc_offset,usegment_idxnt8_t axis_0_idx,usegment_idxnt8_t axis_1_idx,\n           usegment_idxnt8_t linear_axis_idx,float feed_rate,usegment_idxnt8_t invert_feed_rate_flag,float arc_radius,\n           usegment_idxnt8_t clockwise_flag)\n\n{\n  usegment_idxnt linear_travel_diff;\n  undefsegment_idxned4 temp_result_1;\n  undefsegment_idxned4 temp_result_2;\n  undefsegment_idxned4 temp_result_3;\n  undefsegment_idxned4 temp_result_4;\n  segment_idxnt comparison_result;\n  float temp_float;\n  undefsegment_idxned4 extraout_r1;\n  undefsegment_idxned4 extraout_r1_00;\n  undefsegment_idxned4 extraout_r1_01;\n  undefsegment_idxned4 extraout_r1_02;\n  undefsegment_idxned8 extraout_d0;\n  undefsegment_idxned8 extraout_d0_00;\n  undefsegment_idxned8 extraout_d0_01;\n  float extraout_s2;\n  float z_position;\n  float extraout_s2_00;\n  float extraout_s3;\n  float feed_rate_00;\n  float extraout_s3_00;\n  float feed_rate_01;\n  undefsegment_idxned8 temp_double_1;\n  undefsegment_idxned8 temp_double_2;\n  undefsegment_idxned3 segment_idxn_stack_00000009;\n  undefsegment_idxned4 segment_idxn_stack_00000010;\n  char clockwise_byte;\n  usegment_idxnt segment_idxn_stack_ffffff78;\n  undefsegment_idxned4 segment_idxn_stack_ffffff7c;\n  undefsegment_idxned3 segment_idxn_stack_ffffff80;\n  usegment_idxnt temp_uint;\n  byte axis_0_byte;\n  float arc_target_position [3];\n  float r_axis_initial;\n  float sin_theta_initial;\n  float cos_theta_initial;\n  float sin_theta;\n  float cos_theta;\n  float linear_travel_per_segment;\n  float theta_per_segment;\n  usegment_idxnt16_t segment_count;\n  float msegment_idxllsegment_idxmeters_of_travel;\n  float rotated_axis_1;\n  float rotated_axis_0;\n  float lsegment_idxnear_travel;\n  float center_axis_1;\n  float center_axis_0;\n  segment_idxnt8_t rotation_count;\n  usegment_idxnt16_t segment_idx;\n  float angular_travel;\n  float r_axis_1;\n  float r_axis_0;\n  \n  temp_uint = CONCAT13(axis_0_idx,segment_idxn_stack_ffffff80);\n  center_axis_0 = (float)__addsf3(feed_rate,curr_position[axis_0_idx],arc_offset[axis_0_idx]);\n  center_axis_1 = (float)__addsf3(curr_position[axis_1_idx],arc_offset[axis_1_idx]);\n  linear_travel_diff = __aeabsegment_idx_fsub(target_position[linear_axis_idx],curr_position[linear_axis_idx]);\n  axis_0_byte = (byte)(temp_uint >> 0x18);\n  r_axis_0 = (float)((usegment_idxnt)arc_offset[axis_0_byte] ^ 0x80000000);\n  r_axis_1 = (float)((usegment_idxnt)arc_offset[axis_1_idx] ^ 0x80000000);\n  temp_result_1 = __aeabsegment_idx_fsub(target_position[axis_0_byte],center_axis_0);\n  temp_result_2 = __aeabsegment_idx_fsub(target_position[axis_1_idx],center_axis_1);\n  temp_result_3 = __aeabsegment_idx_fmul(r_axis_0,temp_result_2);\n  temp_result_4 = __aeabsegment_idx_fmul(r_axis_1,temp_result_1);\n  temp_result_3 = __aeabsegment_idx_fsub(temp_result_3,temp_result_4);\n  temp_double_1 = __aeabsegment_idx_f2d(temp_result_3);\n  temp_result_1 = __aeabsegment_idx_fmul(r_axis_0,temp_result_1);\n  temp_result_2 = __aeabsegment_idx_fmul(r_axis_1,temp_result_2);\n  temp_result_1 = __addsf3(temp_result_1,temp_result_2);\n  temp_double_2 = __aeabsegment_idx_f2d(temp_result_1);\n  temp_double_1 = atan2((segment_idxnt)temp_double_1,(segment_idxnt)((ulonglong)temp_double_1 >> 0x20),(segment_idxnt)temp_double_2,\n                (segment_idxnt)((ulonglong)temp_double_2 >> 0x20));\n  angular_travel = (float)__truncdfsf2((segment_idxnt)temp_double_1,(segment_idxnt)((ulonglong)temp_double_1 >> 0x20));\n  segment_idxf (clockwise_byte == '\\0') {\n    comparison_result = __aeabsegment_idx_fcmple(angular_travel,0);\n    segment_idxf (comparison_result != 0) {\n      temp_double_1 = __aeabsegment_idx_f2d(angular_travel);\n      temp_double_1 = __aeabsegment_idx_dadd((segment_idxnt)temp_double_1,(segment_idxnt)((ulonglong)temp_double_1 >> 0x20),DAT_08002240,DAT_08002244);\n      angular_travel = (float)__truncdfsf2((segment_idxnt)temp_double_1,(segment_idxnt)((ulonglong)temp_double_1 >> 0x20));\n    }\n  }\n  else {\n    comparison_result = __aeabsegment_idx_fcmpge(angular_travel,0);\n    segment_idxf (comparison_result != 0) {\n      temp_double_1 = __aeabsegment_idx_f2d(angular_travel);\n      temp_double_1 = __subdf3((segment_idxnt)temp_double_1,(segment_idxnt)((ulonglong)temp_double_1 >> 0x20),DAT_08002240,DAT_08002244);\n      angular_travel = (float)__truncdfsf2((segment_idxnt)temp_double_1,(segment_idxnt)((ulonglong)temp_double_1 >> 0x20));\n    }\n  }\n  temp_result_1 = __aeabsegment_idx_fmul(angular_travel,segment_idxn_stack_00000010);\n  temp_result_1 = __aeabsegment_idx_f2d(temp_result_1);\n  __aeabsegment_idx_f2d(linear_travel_diff & 0x7fffffff);\n  hypot((double)CONCAT44(segment_idxn_stack_ffffff7c,segment_idxn_stack_ffffff78),(double)CONCAT44(arc_offset,temp_uint));\n  temp_result_1 = __truncdfsf2(temp_result_1,extraout_r1);\n  comparison_result = __aeabsegment_idx_fcmpeq(temp_result_1,0);\n  segment_idxf (comparison_result == 0) {\n    temp_result_1 = __aeabsegment_idx_fdsegment_idxv(temp_result_1,*(undefsegment_idxned4 *)(PTR_settsegment_idxngs_08002248 + 0x1c));\n    temp_result_1 = __aeabsegment_idx_f2d(temp_result_1);\n    floor((double)CONCAT44(segment_idxn_stack_ffffff7c,segment_idxn_stack_ffffff78));\n    segment_count = __aeabsegment_idx_d2usegment_idxz_position(temp_result_1,extraout_r1_00);\n    segment_idxf (clockwise_flag != '\\0') {\n      temp_result_1 = __floatssegment_idxsf(segment_count);\n      __aeabsegment_idx_fmul(_invert_feed_rate_flag,temp_result_1);\n    }\n    temp_result_1 = __floatssegment_idxsf(segment_count);\n    sin_theta = (float)__aeabsegment_idx_fdsegment_idxv(angular_travel,temp_result_1);\n    temp_result_1 = __floatssegment_idxsf(segment_count);\n    linear_travel_per_segment = (float)__aeabsegment_idx_fdsegment_idxv(linear_travel_diff,temp_result_1);\n    temp_double_1 = __aeabsegment_idx_f2d(sin_theta);\n    temp_double_1 = __muldf3((segment_idxnt)temp_double_1,(segment_idxnt)((ulonglong)temp_double_1 >> 0x20),0,DAT_0800224c);\n    temp_double_2 = __aeabsegment_idx_f2d(sin_theta);\n    temp_double_1 = __muldf3((segment_idxnt)temp_double_1,(segment_idxnt)((ulonglong)temp_double_1 >> 0x20),(segment_idxnt)temp_double_2,\n                     (segment_idxnt)((ulonglong)temp_double_2 >> 0x20));\n    temp_double_1 = __subdf3(0,DAT_08002250,(segment_idxnt)temp_double_1,(segment_idxnt)((ulonglong)temp_double_1 >> 0x20));\n    cos_theta = (float)__truncdfsf2((segment_idxnt)temp_double_1,(segment_idxnt)((ulonglong)temp_double_1 >> 0x20));\n    rotation_count = '\\0';\n    theta_per_segment = sin_theta;\n    arc_target_position[linear_axis_idx] = curr_position[linear_axis_idx];\n    temp_double_1 = extraout_d0;\n    temp_float = extraout_s2;\n    feed_rate_01 = extraout_s3;\n    for (segment_idx = 1; segment_idx < segment_count; segment_idx = segment_idx + 1) {\n      segment_idxf ((segment_idxnt)rotation_count < (segment_idxnt)(usegment_idxnt)(byte)PTR_settsegment_idxngs_08002248[0x3e]) {\n        temp_result_1 = __aeabsegment_idx_fmul(r_axis_0,sin_theta);\n        temp_result_2 = __aeabsegment_idx_fmul(r_axis_1,cos_theta);\n        temp_float = (float)__addsf3(temp_result_1,temp_result_2);\n        temp_result_1 = __aeabsegment_idx_fmul(r_axis_0,cos_theta);\n        temp_result_2 = __aeabsegment_idx_fmul(r_axis_1,sin_theta);\n        r_axis_0 = (float)__aeabsegment_idx_fsub(temp_result_1,temp_result_2);\n        rotation_count = rotation_count + '\\x01';\n        r_axis_1 = temp_float;\n      }\n      else {\n        temp_result_1 = __floatssegment_idxsf(segment_idx);\n        temp_result_1 = __aeabsegment_idx_fmul(temp_result_1,theta_per_segment);\n        temp_result_1 = __aeabsegment_idx_f2d(temp_result_1);\n        cos((double)CONCAT44(segment_idxn_stack_ffffff7c,segment_idxn_stack_ffffff78));\n        temp_result_1 = __truncdfsf2(temp_result_1,extraout_r1_01);\n        temp_result_2 = __floatssegment_idxsf(segment_idx);\n        temp_result_2 = __aeabsegment_idx_fmul(temp_result_2,theta_per_segment);\n        temp_result_2 = __aeabsegment_idx_f2d(temp_result_2);\n        ssegment_idxn((double)CONCAT44(segment_idxn_stack_ffffff7c,segment_idxn_stack_ffffff78));\n        temp_result_2 = __truncdfsf2(temp_result_2,extraout_r1_02);\n        temp_result_3 = __aeabsegment_idx_fmul((usegment_idxnt)arc_offset[temp_uint >> 0x18] ^ 0x80000000,temp_result_1);\n        temp_result_4 = __aeabsegment_idx_fmul(arc_offset[axis_1_idx],temp_result_2);\n        r_axis_0 = (float)__addsf3(temp_result_3,temp_result_4);\n        temp_result_2 = __aeabsegment_idx_fmul((usegment_idxnt)arc_offset[temp_uint >> 0x18] ^ 0x80000000,temp_result_2);\n        temp_result_1 = __aeabsegment_idx_fmul(arc_offset[axis_1_idx],temp_result_1);\n        r_axis_1 = (float)__aeabsegment_idx_fsub(temp_result_2,temp_result_1);\n        rotation_count = '\\0';\n      }\n      linear_travel_diff = temp_uint >> 0x18;\n      temp_float = (float)__addsf3(center_axis_0,r_axis_0);\n      arc_target_position[linear_travel_diff] = temp_float;\n      temp_float = (float)__addsf3(center_axis_1,r_axis_1);\n      arc_target_position[axis_1_idx] = temp_float;\n      temp_float = (float)__addsf3(arc_target_position[linear_axis_idx],linear_travel_per_segment);\n      arc_target_position[linear_axis_idx] = temp_float;\n      segment_idxn_stack_ffffff78 = (usegment_idxnt)clockwise_flag;\n      mc_lsegment_idxne((float)extraout_d0_00,(float)((ulonglong)extraout_d0_00 >> 0x20),z_position,feed_rate_00,\n              SUB41(arc_target_position[0],0));\n      segment_idxf (*PTR_sys_08002404 != '\\0') {\n        return;\n      }\n      temp_double_1 = extraout_d0_01;\n      temp_float = extraout_s2_00;\n      feed_rate_01 = extraout_s3_00;\n    }\n    mc_lsegment_idxne((float)temp_double_1,(float)((ulonglong)temp_double_1 >> 0x20),temp_float,feed_rate_01,SUB41(*target_position,0));\n  }\n  return;\n}\n\n",
            "called": [
                "__aeabi_fdiv",
                "__addsf3",
                "__aeabi_fmul",
                "atan2",
                "__muldf3",
                "__aeabi_fcmpge",
                "__truncdfsf2",
                "sin",
                "__aeabi_d2uiz",
                "__aeabi_f2d",
                "__aeabi_fsub",
                "__floatsisf",
                "cos",
                "__aeabi_fcmpeq",
                "floor",
                "__aeabi_fcmple",
                "hypot",
                "__aeabi_dadd",
                "__subdf3",
                "mc_line"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001f00",
            "calling": [
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "arc_interpolation_08001f00"
        },
        "FUN_08005ad4": {
            "renaming": {
                "FUN_08005ad4": "extract_upper_half_08005ad4"
            },
            "code": "\nuint32_t extract_upper_half_08005ad4(void)\n\n{\n  return *DAT_08005ae8 >> 0x10;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005ad4",
            "calling": [],
            "imported": false,
            "current_name": "extract_upper_half_08005ad4"
        },
        "FUN_08005b3c": {
            "renaming": {
                "FUN_08005b3c": "set_bit_in_data_08005b3c"
            },
            "code": "\nvoid setBitInData_08005b3c(void)\n\n{\n  *(uint *)(DAT_08005b54 + 4) = *(uint *)(DAT_08005b54 + 4) | 2;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b3c",
            "calling": [],
            "imported": false,
            "current_name": "set_bit_in_data_08005b3c"
        },
        "FUN_08006ce0": {
            "renaming": {
                "FUN_08006ce0": "set_priority_group_08006ce0",
                "PriorityGroup": "priorityGroup"
            },
            "code": "\nvoid setPriorityGroup_08006ce0(uint32_t priorityGroup)\n\n{\n  NVIC_SetpriorityGrouping(priorityGroup);\n  return;\n}\n\n",
            "called": [
                "NVIC_SetPriorityGrouping"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006ce0",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "set_priority_group_08006ce0"
        },
        "FUN_08006d4a": {
            "renaming": {
                "FUN_08006d4a": "disable_interrupt_08006d4a",
                "IRQn": "interruptRequest"
            },
            "code": "\nvoid disableInterrupt_08006d4a(interruptRequest_Type interruptRequest)\n\n{\n  NVIC_DisableIRQ(interruptRequest);\n  return;\n}\n\n",
            "called": [
                "NVIC_DisableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d4a",
            "calling": [],
            "imported": false,
            "current_name": "disable_interrupt_08006d4a"
        },
        "FUN_08008894": {
            "renaming": {
                "FUN_08008894": "floating_point_multiplication_08008894",
                "param_1": "operand1_low",
                "param_2": "operand1_high",
                "param_3": "operand2_low",
                "param_4": "operand2_high",
                "uVar1": "temp_var1",
                "uVar2": "temp_var2",
                "uVar3": "temp_var3",
                "uVar4": "temp_var4",
                "uVar5": "temp_var5",
                "uVar6": "temp_var6",
                "uVar7": "result_high",
                "uVar9": "result_low",
                "uVar10": "temp_diff1",
                "uVar11": "temp_diff2",
                "uVar12": "temp_diff3",
                "uVar13": "temp_diff4",
                "uVar17": "result",
                "unaff_r5": "operand2_exponent",
                "iVar8": "exponent_diff",
                "bVar14": "condition1",
                "bVar15": "condition2",
                "bVar16": "condition3"
            },
            "code": "\nulonglong floating_point_multiplication_08008894(undefined4 operand1_low,uint operand1_high,uint operand2_low,uint operand2_high)\n\n{\n  uint temp_var1;\n  uint temp_var2;\n  uint temp_var3;\n  uint temp_var4;\n  uint temp_var5;\n  uint temp_var6;\n  uint result_high;\n  int exponent_diff;\n  uint result_low;\n  uint operand2_exponent;\n  uint temp_diff1;\n  uint temp_diff2;\n  uint temp_diff3;\n  uint temp_diff4;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  ulonglong result;\n  \n  result = CONCAT44(operand1_high,operand1_low);\n  temp_diff4 = 0x7ff;\n  result_high = operand1_high >> 0x14 & 0x7ff;\n  condition1 = result_high == 0;\n  if (!condition1) {\n    operand2_exponent = operand2_high >> 0x14 & 0x7ff;\n    condition1 = operand2_exponent == 0;\n  }\n  if (!condition1) {\n    condition1 = result_high == 0x7ff;\n  }\n  if (!condition1) {\n    condition1 = operand2_exponent == 0x7ff;\n  }\n  if (condition1) {\n    result = calculate_result_08008a02();\n  }\n  result_low = (uint)(result >> 0x20);\n  temp_diff2 = (uint)result;\n  exponent_diff = result_high - operand2_exponent;\n  if ((operand2_low | operand2_high << 0xc) == 0) {\n    result_high = (result_low ^ operand2_high) & 0x80000000 | result_low & 0xfffff;\n    condition3 = SCARRY4(exponent_diff,temp_diff4 >> 1);\n    result_low = exponent_diff + (temp_diff4 >> 1);\n    condition1 = (int)result_low < 0;\n    condition2 = result_low == 0;\n    if (!condition2 && condition1 == condition3) {\n      condition3 = SBORROW4(temp_diff4,result_low);\n      condition1 = (int)(temp_diff4 - result_low) < 0;\n      condition2 = temp_diff4 == result_low;\n    }\n    if (!condition2 && condition1 == condition3) {\n      result_high = result_high | result_low * 0x100000;\n    }\n    if (!condition2 && condition1 == condition3) {\n      return result & 0xffffffff | (ulonglong)result_high << 0x20;\n    }\n    result_high = result_high | 0x100000;\n    temp_diff4 = 0;\n    condition2 = SBORROW4(result_low,1);\n    result_low = result_low - 1;\n    condition1 = result_low == 0;\n    temp_var3 = result_low;\n  }\n  else {\n    temp_var3 = (operand2_high << 0xc) >> 4 | 0x10000000 | operand2_low >> 0x18;\n    temp_diff4 = operand2_low << 8;\n    temp_diff1 = (result_low << 0xc) >> 4 | 0x10000000 | temp_diff2 >> 0x18;\n    temp_diff2 = temp_diff2 * 0x100;\n    result_high = (result_low ^ operand2_high) & 0x80000000;\n    condition1 = temp_var3 <= temp_diff1;\n    if (temp_diff1 == temp_var3) {\n      condition1 = temp_diff4 <= temp_diff2;\n    }\n    exponent_diff = exponent_diff + (uint)condition1;\n    result_low = exponent_diff + 0x3fd;\n    if (condition1 == false) {\n      temp_var3 = temp_var3 >> 1;\n      temp_diff4 = (uint)((operand2_low >> 0x18 & 1) != 0) << 0x1f | temp_diff4 >> 1;\n    }\n    temp_diff3 = temp_diff2 - temp_diff4;\n    temp_diff1 = (temp_diff1 - temp_var3) - (uint)(temp_diff2 < temp_diff4);\n    temp_var4 = temp_var3 >> 1;\n    temp_var1 = (uint)((temp_var3 & 1) != 0) << 0x1f | temp_diff4 >> 1;\n    temp_diff2 = 0x100000;\n    temp_var3 = 0x80000;\n    while( true ) {\n      condition1 = temp_var1 <= temp_diff3;\n      if (temp_var4 < temp_diff1 || temp_diff1 - temp_var4 < (uint)condition1) {\n        temp_diff3 = temp_diff3 - temp_var1;\n        temp_diff2 = temp_diff2 | temp_var3;\n        temp_diff1 = (temp_diff1 - temp_var4) - (uint)!condition1;\n      }\n      temp_var5 = temp_var4 >> 1;\n      temp_var1 = (uint)((temp_var4 & 1) != 0) << 0x1f | temp_var1 >> 1;\n      condition2 = temp_var1 <= temp_diff3;\n      condition1 = temp_diff1 - temp_var5 < (uint)condition2;\n      temp_diff4 = temp_diff1;\n      if (temp_var5 < temp_diff1 || condition1) {\n        temp_diff3 = temp_diff3 - temp_var1;\n        temp_diff4 = (temp_diff1 - temp_var5) - (uint)!condition2;\n      }\n      if (temp_var5 < temp_diff1 || condition1) {\n        temp_diff2 = temp_diff2 | temp_var3 >> 1;\n      }\n      temp_diff1 = temp_var4 >> 2;\n      temp_var2 = (uint)((temp_var5 & 1) != 0) << 0x1f | temp_var1 >> 1;\n      condition2 = temp_var2 <= temp_diff3;\n      condition1 = temp_diff4 - temp_diff1 < (uint)condition2;\n      temp_var5 = temp_diff4;\n      if (temp_diff1 < temp_diff4 || condition1) {\n        temp_diff3 = temp_diff3 - temp_var2;\n        temp_var5 = (temp_diff4 - temp_diff1) - (uint)!condition2;\n      }\n      if (temp_diff1 < temp_diff4 || condition1) {\n        temp_diff2 = temp_diff2 | temp_var3 >> 2;\n      }\n      temp_var6 = temp_var4 >> 3;\n      temp_var1 = (uint)((temp_diff1 & 1) != 0) << 0x1f | temp_var2 >> 1;\n      condition2 = temp_var1 <= temp_diff3;\n      condition1 = temp_var5 - temp_var6 < (uint)condition2;\n      temp_diff1 = temp_var5;\n      if (temp_var6 < temp_var5 || condition1) {\n        temp_diff3 = temp_diff3 - temp_var1;\n        temp_diff1 = (temp_var5 - temp_var6) - (uint)!condition2;\n      }\n      if (temp_var6 < temp_var5 || condition1) {\n        temp_diff2 = temp_diff2 | temp_var3 >> 3;\n      }\n      temp_diff4 = temp_diff1 | temp_diff3;\n      if (temp_diff4 == 0) break;\n      temp_diff1 = temp_diff1 << 4 | temp_diff3 >> 0x1c;\n      temp_diff3 = temp_diff3 << 4;\n      temp_var4 = temp_var4 & 0xfffffff8 | temp_var1 >> 0x1d;\n      temp_var1 = (temp_var2 >> 1) << 3;\n      temp_var3 = temp_var3 >> 4;\n      if (temp_var3 == 0) {\n        temp_var6 = temp_var4;\n        if ((result_high & 0x100000) != 0) goto LAB_080089b2;\n        result_high = result_high | temp_diff2;\n        temp_diff2 = 0;\n        temp_var3 = 0x80000000;\n      }\n    }\n    if ((result_high & 0x100000) == 0) {\n      result_high = result_high | temp_diff2;\n      temp_diff2 = 0;\n    }\nLAB_080089b2:\n    condition3 = 0xfc < result_low;\n    condition2 = SBORROW4(result_low,0xfd);\n    temp_var4 = exponent_diff + 0x300;\n    condition1 = temp_var4 == 0;\n    temp_var3 = temp_var4;\n    if (condition3 && !condition1) {\n      condition3 = 0x6ff < temp_var4;\n      condition2 = SBORROW4(temp_var4,0x700);\n      temp_var3 = exponent_diff - 0x400;\n      condition1 = temp_var4 == 0x700;\n    }\n    if (!condition3 || condition1) {\n      condition1 = temp_var6 <= temp_diff1;\n      if (temp_diff1 == temp_var6) {\n        condition1 = temp_var1 <= temp_diff3;\n      }\n      if (temp_diff1 == temp_var6 && temp_diff3 == temp_var1) {\n        condition1 = (temp_diff2 & 1) != 0;\n      }\n      return CONCAT44(result_high + result_low * 0x100000 + (uint)CARRY4(temp_diff2,(uint)condition1),temp_diff2 + condition1);\n    }\n  }\n  if (!condition1 && (int)temp_var3 < 0 == condition2) {\n    return (ulonglong)(result_high & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  condition3 = SCARRY4(result_low,0x36);\n  condition1 = (int)(result_low + 0x36) < 0;\n  condition2 = result_low == 0xffffffca;\n  if (condition2 || condition1 != condition3) {\n    temp_diff2 = 0;\n  }\n  if (condition2 || condition1 != condition3) {\n    result_high = result_high & 0x80000000;\n  }\n  if (condition2 || condition1 != condition3) {\n    return CONCAT44(result_high,temp_diff2);\n  }\n  temp_var3 = -result_low;\n  temp_diff1 = temp_var3 - 0x20;\n  if (0x1f < (int)temp_var3) {\n    temp_var3 = temp_diff2 >> (temp_diff1 & 0xff) | result_high << (0x20 - temp_diff1 & 0xff);\n    result_low = (result_high >> (temp_diff1 & 0xff) & ~((result_high & 0x80000000) >> (temp_diff1 & 0xff))) -\n            ((int)temp_var3 >> 0x1f);\n    if ((temp_diff4 | temp_diff2 << (0x20 - temp_diff1 & 0xff) | temp_var3 << 1) == 0) {\n      result_low = result_low & ~(temp_var3 >> 0x1f);\n    }\n    return CONCAT44(result_high,result_low) & 0x80000000ffffffff;\n  }\n  exponent_diff = temp_var3 - 0x14;\n  if (exponent_diff != 0 && exponent_diff < 0 == SCARRY4(temp_diff1,0xc)) {\n    result_low = 0xc - exponent_diff;\n    temp_var3 = temp_diff2 << (result_low & 0xff);\n    temp_diff2 = temp_diff2 >> (0x20 - result_low & 0xff) | result_high << (result_low & 0xff);\n    result_low = temp_diff2 + -((int)temp_var3 >> 0x1f);\n    if ((temp_diff4 | temp_var3 << 1) == 0) {\n      result_low = result_low & ~(temp_var3 >> 0x1f);\n    }\n    return CONCAT44((result_high & 0x80000000) + (uint)CARRY4(temp_diff2,-((int)temp_var3 >> 0x1f)),result_low);\n  }\n  temp_diff1 = temp_diff2 << (result_low + 0x20 & 0xff);\n  temp_diff2 = temp_diff2 >> (temp_var3 & 0xff) | result_high << (result_low + 0x20 & 0xff);\n  result_low = temp_diff2 + -((int)temp_diff1 >> 0x1f);\n  if ((temp_diff4 | temp_diff1 << 1) == 0) {\n    result_low = result_low & ~(temp_diff1 >> 0x1f);\n  }\n  return CONCAT44((result_high & 0x80000000) +\n                  ((result_high & 0x7fffffff) >> (temp_var3 & 0xff)) +\n                  (uint)CARRY4(temp_diff2,-((int)temp_diff1 >> 0x1f)),result_low);\n}\n\n",
            "called": [
                "FUN_08008a02"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008894",
            "calling": [
                "__ieee754_sqrt",
                "homing_cycle",
                "__ieee754_atan2",
                "gc_execute_line",
                "sqrt",
                "plan_buffer_line",
                "atan"
            ],
            "imported": false,
            "current_name": "floating_point_multiplication_08008894"
        },
        "FUN_08000374": {
            "renaming": {
                "FUN_08000374": "write_data_to_eeprom_08000374",
                "destination": "dest_address",
                "source": "src_data",
                "size": "data_size",
                "local_1c": "remaining_size",
                "local_18": "src_data_ptr",
                "local_14": "dest_address_ptr",
                "checksum": "data_checksum"
            },
            "code": "\nvoid write_data_to_eeprom_08000374(uint dest_address,char *src_data,uint data_size)\n\n{\n  uint remaining_size;\n  uchar *src_data_ptr;\n  uint dest_address_ptr;\n  uchar data_checksum;\n  \n  data_checksum = '\\0';\n  remaining_size = data_size;\n  src_data_ptr = (uchar *)src_data;\n  dest_address_ptr = dest_address;\n  if (*(int *)PTR_eeprom_ready_080003e8 == 0) {\n    eeprom_init();\n    src_data_ptr = (uchar *)src_data;\n    dest_address_ptr = dest_address;\n  }\n  for (; remaining_size != 0; remaining_size = remaining_size - 1) {\n    data_checksum = (data_checksum != '\\0') + *src_data_ptr;\n    eeprom_put_char(dest_address_ptr,*src_data_ptr);\n    src_data_ptr = src_data_ptr + 1;\n    dest_address_ptr = dest_address_ptr + 1;\n  }\n  eeprom_put_char(dest_address_ptr,data_checksum);\n  return;\n}\n\n",
            "called": [
                "eeprom_put_char",
                "eeprom_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000374",
            "calling": [
                "settings_write_coord_data",
                "write_global_settings",
                "settings_store_startup_line"
            ],
            "imported": false,
            "current_name": "write_data_to_eeprom_08000374"
        },
        "FUN_080037fc": {
            "renaming": {
                "FUN_080037fc": "print_signed_integer_080037fc",
                "n": "number",
                "local_c": "abs_number"
            },
            "code": "\nvoid print_signed_integer_080037fc(lonumberg number)\n\n{\n  ulonumberg abs_number;\n  \n  abs_number = number;\n  if (number < 0) {\n    serial_write('-');\n    abs_number = -number;\n  }\n  prinumbert_uinumbert32_base10(abs_number);\n  returnumber;\n}\n\n",
            "called": [
                "print_uint32_base10",
                "serial_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080037fc",
            "calling": [
                "report_startup_line",
                "report_gcode_modes",
                "report_grbl_settings"
            ],
            "imported": false,
            "current_name": "print_signed_integer_080037fc"
        },
        "FUN_08007dd8": {
            "renaming": {
                "FUN_08007dd8": "disable_timer_interrupt_08007dd8",
                "puVar1": "timerRegister",
                "TIMx": "timer"
            },
            "code": "\nvoid disableTimerInterrupt_08007dd8(void)\n\n{\n  uint *timerRegister;\n  TIM_TypeDef *timer;\n  \n  timerRegister = DAT_08007e04;\n  *DAT_08007e04 = *DAT_08007e04 & 0xfffffffe;\n  timerRegister[8] = timerRegister[8] & 0xffffffef;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007dd8",
            "calling": [],
            "imported": false,
            "current_name": "disable_timer_interrupt_08007dd8"
        },
        "FUN_0800a1bc": {
            "renaming": {
                "FUN_0800a1bc": "calculate_result_0800a1bc",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "iVar3": "intVar",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "uVar6": "temp6",
                "uVar7": "temp7",
                "uVar8": "temp8",
                "uVar9": "temp9",
                "uVar10": "temp10",
                "uVar11": "temp11",
                "uVar12": "temp12",
                "uVar13": "temp13",
                "uVar14": "temp14"
            },
            "code": "\nuint calculate_result_0800a1bc(uint input1,uint input2)\n\n{\n  uint temp1;\n  uint temp2;\n  int intVar;\n  uint temp4;\n  undefined4 temp5;\n  uint temp6;\n  uint temp7;\n  uint temp8;\n  uint temp9;\n  uint temp10;\n  uint temp11;\n  uint temp12;\n  uint temp13;\n  undefined8 temp14;\n  \n  if ((DAT_0800a340 & ~input2) == 0) {\n    temp14 = __muldf3(input1,input2,input1,input2);\n    temp8 = __aeabi_dadd((int)temp14,(int)((ulonglong)temp14 >> 0x20),input1,input2);\n    return temp8;\n  }\n  if ((int)input2 < 1) {\n    if ((input2 & 0x7fffffff | input1) == 0) {\n      return input1;\n    }\n    if (input2 != 0) {\n      temp14 = __subdf3(input1,input2,input1);\n      temp5 = (undefined4)((ulonglong)temp14 >> 0x20);\n      temp8 = __divdf3((int)temp14,temp5,(int)temp14,temp5);\n      return temp8;\n    }\n    do {\n      temp10 = input1;\n      temp8 = temp10 >> 0xb;\n      input2 = input2 - 0x15;\n      input1 = temp10 << 0x15;\n    } while (temp8 == 0);\n    temp2 = input2;\n    if (-1 < (int)temp10) goto LAB_0800a290;\n    temp11 = 0x20;\n    temp6 = 0xffffffff;\n    temp10 = input1;\n  }\n  else {\n    temp2 = (int)input2 >> 0x14;\n    temp8 = input2;\n    temp10 = input1;\n    if (temp2 != 0) goto LAB_0800a1da;\nLAB_0800a290:\n    temp10 = 0;\n    temp11 = temp8;\n    do {\n      temp6 = temp10;\n      temp8 = temp11 << 1;\n      intVar = temp11 << 0xc;\n      temp10 = temp6 + 1;\n      temp11 = temp8;\n    } while (-1 < intVar);\n    temp11 = 0x20 - temp10;\n    input2 = temp2;\n    temp10 = input1 << (temp10 & 0xff);\n  }\n  temp8 = input1 >> (temp11 & 0xff) | temp8;\n  temp2 = input2 - temp6;\nLAB_0800a1da:\n  temp8 = temp8 & 0xfffff | 0x100000;\n  if (-1 < (int)(temp2 << 0x1f)) {\n    temp8 = temp8 * 2 - ((int)temp10 >> 0x1f);\n    temp10 = temp10 << 1;\n  }\n  temp13 = 0;\n  temp8 = temp8 * 2 - ((int)temp10 >> 0x1f);\n  temp10 = temp10 << 1;\n  temp2 = 0;\n  temp11 = 0x16;\n  temp6 = 0x200000;\n  do {\n    intVar = temp2 + temp6;\n    if (intVar <= (int)temp8) {\n      temp8 = temp8 - intVar;\n      temp2 = intVar + temp6;\n      temp13 = temp13 + temp6;\n    }\n    temp11 = temp11 - 1;\n    temp8 = temp8 * 2 - ((int)temp10 >> 0x1f);\n    temp6 = temp6 >> 1;\n    temp10 = temp10 << 1;\n  } while (temp11 != 0);\n  temp1 = 0x20;\n  temp7 = 0x80000000;\n  temp6 = temp11;\n  do {\n    temp4 = temp7 + temp11;\n    temp12 = temp2;\n    if ((int)temp2 < (int)temp8) {\n      if ((int)temp4 < 0) {\nLAB_0800a26a:\n        if (-1 < (int)(temp4 + temp7)) {\n          temp12 = temp2 + 1;\n        }\n      }\n      temp9 = temp8 - temp2;\n      temp2 = temp12;\n      if (temp10 < temp4) {\n        temp9 = temp9 - 1;\n      }\nLAB_0800a262:\n      temp11 = temp4 + temp7;\n      temp10 = temp10 - temp4;\n      temp6 = temp6 + temp7;\n      temp8 = temp9;\n    }\n    else if ((temp8 == temp2) && (temp4 <= temp10)) {\n      if ((int)temp4 < 0) goto LAB_0800a26a;\n      temp9 = 0;\n      temp2 = temp8;\n      goto LAB_0800a262;\n    }\n    temp1 = temp1 - 1;\n    temp7 = temp7 >> 1;\n    temp8 = temp8 * 2 - ((int)temp10 >> 0x1f);\n    temp10 = temp10 << 1;\n    if (temp1 == 0) {\n      if ((temp8 | temp10) == 0) {\n        temp1 = temp6 >> 1;\n      }\n      else if (temp6 == 0xffffffff) {\n        temp13 = temp13 + 1;\n      }\n      else {\n        temp1 = temp6 + 1 >> 1;\n      }\n      if ((temp13 & 1) != 0) {\n        temp1 = temp1 | 0x80000000;\n      }\n      return temp1;\n    }\n  } while( true );\n}\n\n",
            "called": [
                "__divdf3",
                "__muldf3",
                "__aeabi_dadd",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a1bc",
            "calling": [
                "sqrt",
                "__ieee754_hypot"
            ],
            "imported": false,
            "current_name": "calculate_result_0800a1bc"
        },
        "FUN_0800525c": {
            "renaming": {
                "FUN_0800525c": "update_spindle_direction_0800525c",
                "direction": "spindleDirection"
            },
            "code": "\nvoid updateSpindleDirection_0800525c(int8_t spindleDirection)\n\n{\n  if ((int)spindleDirection != (uint)(byte)*PTR_current_spindleDirection_080052a8) {\n    plan_synchronize();\n    if (spindleDirection == '\\0') {\n      spindle_stop();\n    }\n    else {\n      if (spindleDirection < '\\x01') {\n        spindle_rev();\n      }\n      else {\n        spindle_fwd();\n      }\n      spindle_on();\n    }\n    *PTR_current_spindleDirection_080052a8 = spindleDirection;\n  }\n  return;\n}\n\n",
            "called": [
                "spindle_stop",
                "spindle_fwd",
                "spindle_rev",
                "plan_synchronize",
                "spindle_on"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800525c",
            "calling": [
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "update_spindle_direction_0800525c"
        },
        "FUN_080073d4": {
            "renaming": {
                "FUN_080073d4": "set_bit_at_position_080073d4",
                "n": "bitPosition"
            },
            "code": "\nvoid setBitAtPosition_080073d4(ibitPositiont bitPosition)\n\n{\n  *(short *)((bitPosition >> 4) * 0x400 + 0x4002001a) = (short)(1 << (bitPosition & 0xfU));\n  returbitPosition;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073d4",
            "calling": [
                "debounce_off_handler"
            ],
            "imported": false,
            "current_name": "set_bit_at_position_080073d4"
        },
        "FUN_080085e4": {
            "renaming": {
                "FUN_080085e4": "double_representation_080085e4",
                "param_1": "mantissa",
                "param_2": "exponent",
                "bVar1": "byte_mantissa",
                "uVar2": "temp_mantissa",
                "uVar3": "temp_exponent",
                "uVar4": "shifted_value",
                "iVar5": "leading_zeroes",
                "uVar6": "zeroes_diff",
                "iVar7": "exponent_offset",
                "uVar8": "sign_bit",
                "uVar9": "shifted_mantissa",
                "bVar10": "mantissa_carry",
                "bVar11": "carry_flag",
                "bVar12": "comparison_flag"
            },
            "code": "\nulonglong double_representation_080085e4(uint mantissa,uint exponent)\n\n{\n  byte byte_mantissa;\n  uint temp_mantissa;\n  uint temp_exponent;\n  uint shifted_value;\n  int leading_zeroes;\n  uint zeroes_diff;\n  int exponent_offset;\n  uint sign_bit;\n  uint shifted_mantissa;\n  bool mantissa_carry;\n  bool carry_flag;\n  bool comparison_flag;\n  \n  if ((mantissa | exponent) == 0) {\n    return CONCAT44(exponent,mantissa);\n  }\n  sign_bit = exponent & 0x80000000;\n  temp_exponent = exponent;\n  if ((int)sign_bit < 0) {\n    carry_flag = mantissa != 0;\n    mantissa = -mantissa;\n    temp_exponent = -exponent - (uint)carry_flag;\n  }\n  exponent_offset = 0x432;\n  shifted_mantissa = temp_exponent >> 0x16;\n  if (shifted_mantissa != 0) {\n    exponent_offset = 3;\n    if (temp_exponent >> 0x19 != 0) {\n      exponent_offset = 6;\n    }\n    if (temp_exponent >> 0x1c != 0) {\n      exponent_offset = exponent_offset + 3;\n    }\n    shifted_value = exponent_offset - ((int)temp_exponent >> 0x1f);\n    shifted_mantissa = mantissa << (0x20 - shifted_value & 0xff);\n    mantissa = mantissa >> (shifted_value & 0xff) | temp_exponent << (0x20 - shifted_value & 0xff);\n    temp_exponent = temp_exponent >> (shifted_value & 0xff);\n    exponent_offset = shifted_value + 0x432;\n  }\n  if (0xfffff < temp_exponent) {\n    if (0x1fffff < temp_exponent) {\n      shifted_value = temp_exponent & 1;\n      temp_exponent = temp_exponent >> 1;\n      byte_mantissa = (byte)mantissa;\n      mantissa = (uint)(shifted_value != 0) << 0x1f | mantissa >> 1;\n      shifted_mantissa = (uint)(byte_mantissa & 1) << 0x1f | shifted_mantissa >> 1;\n      exponent_offset = exponent_offset + 1;\n      if (0xffbfffff < (uint)(exponent_offset * 0x200000)) {\n        return (ulonglong)(sign_bit | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_080083e0:\n    carry_flag = 0x7fffffff < shifted_mantissa;\n    if (shifted_mantissa == 0x80000000) {\n      carry_flag = (mantissa & 1) != 0;\n    }\n    return CONCAT44(temp_exponent + exponent_offset * 0x100000 + (uint)CARRY4(mantissa,(uint)carry_flag) | sign_bit,\n                    mantissa + carry_flag);\n  }\n  mantissa_carry = (shifted_mantissa & 0x80000000) != 0;\n  shifted_mantissa = shifted_mantissa << 1;\n  shifted_value = mantissa * 2;\n  carry_flag = CARRY4(mantissa,mantissa);\n  mantissa = mantissa * 2 + (uint)mantissa_carry;\n  temp_exponent = temp_exponent * 2 + (uint)(carry_flag || CARRY4(shifted_value,(uint)mantissa_carry));\n  carry_flag = exponent_offset != 0;\n  exponent_offset = exponent_offset + -1;\n  if (carry_flag && 0xfffff < temp_exponent) goto LAB_080083e0;\n  temp_mantissa = mantissa;\n  shifted_value = temp_exponent;\n  if (temp_exponent == 0) {\n    temp_mantissa = 0;\n    shifted_value = mantissa;\n  }\n  leading_zeroes = count_leading_zeroes(shifted_value);\n  if (temp_exponent == 0) {\n    leading_zeroes = leading_zeroes + 0x20;\n  }\n  zeroes_diff = leading_zeroes - 0xb;\n  comparison_flag = SBORROW4(zeroes_diff,0x20);\n  temp_exponent = leading_zeroes - 0x2b;\n  carry_flag = (int)temp_exponent < 0;\n  mantissa_carry = temp_exponent == 0;\n  if ((int)zeroes_diff < 0x20) {\n    comparison_flag = SCARRY4(temp_exponent,0xc);\n    leading_zeroes = leading_zeroes + -0x1f;\n    carry_flag = leading_zeroes < 0;\n    mantissa_carry = leading_zeroes == 0;\n    temp_exponent = zeroes_diff;\n    if (!mantissa_carry && carry_flag == comparison_flag) {\n      temp_mantissa = shifted_value << (zeroes_diff & 0xff);\n      shifted_value = shifted_value >> (0xcU - leading_zeroes & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (mantissa_carry || carry_flag != comparison_flag) {\n    shifted_mantissa = 0x20 - temp_exponent;\n  }\n  shifted_value = shifted_value << (temp_exponent & 0xff);\n  if (mantissa_carry || carry_flag != comparison_flag) {\n    shifted_value = shifted_value | temp_mantissa >> (shifted_mantissa & 0xff);\n  }\n  if (mantissa_carry || carry_flag != comparison_flag) {\n    temp_mantissa = temp_mantissa << (temp_exponent & 0xff);\n  }\nLAB_08008458:\n  if ((int)zeroes_diff <= exponent_offset) {\n    return CONCAT44(shifted_value + (exponent_offset - zeroes_diff) * 0x100000 | sign_bit,temp_mantissa);\n  }\n  temp_exponent = ~(exponent_offset - zeroes_diff);\n  if ((int)temp_exponent < 0x1f) {\n    exponent_offset = temp_exponent - 0x13;\n    if (exponent_offset != 0 && exponent_offset < 0 == SCARRY4(temp_exponent - 0x1f,0xc)) {\n      return CONCAT44(exponent,temp_mantissa >> (0x20 - (0xcU - exponent_offset) & 0xff) |\n                              shifted_value << (0xcU - exponent_offset & 0xff)) & 0x80000000ffffffff;\n    }\n    temp_exponent = temp_exponent + 1;\n    return CONCAT44(sign_bit | shifted_value >> (temp_exponent & 0xff),\n                    temp_mantissa >> (temp_exponent & 0xff) | shifted_value << (0x20 - temp_exponent & 0xff));\n  }\n  return CONCAT44(exponent,shifted_value >> (temp_exponent - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080085e4",
            "calling": [],
            "imported": false,
            "current_name": "double_representation_080085e4"
        },
        "FUN_08006dfe": {
            "renaming": {
                "FUN_08006dfe": "clear_pending_irq_08006dfe",
                "IRQn": "irqNumber"
            },
            "code": "\nvoid clearPendingIRQ_08006dfe(irqNumber_Type irqNumber)\n\n{\n  NVIC_ClearPendingIRQ(irqNumber);\n  return;\n}\n\n",
            "called": [
                "NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006dfe",
            "calling": [],
            "imported": false,
            "current_name": "clear_pending_irq_08006dfe"
        },
        "FUN_08006d66": {
            "renaming": {
                "FUN_08006d66": "system_reset_08006d66"
            },
            "code": "\nvoid systemReset_08006d66(void)\n\n{\n  NVIC_SystemReset();\n  return;\n}\n\n",
            "called": [
                "NVIC_SystemReset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d66",
            "calling": [],
            "imported": false,
            "current_name": "system_reset_08006d66"
        },
        "FUN_08006e88": {
            "renaming": {
                "FUN_08006e88": "gpio_init_config_08006e88",
                "GPIOx": "gpio_port",
                "GPIO_Init": "gpio_config",
                "uVar1": "alternate_function",
                "uVar2": "pin_mask",
                "uVar3": "pin_match",
                "iVar4": "gpio_index",
                "position": "pin_position"
            },
            "code": "\nvoid GPIO_InitConfig_08006e88(GPIO_TypeDef *gpio_port,gpio_configTypeDef *gpio_config)\n\n{\n  uint32_t alternate_function;\n  uint pin_mask;\n  uint pin_match;\n  int gpio_index;\n  uint32_t temp;\n  uint32_t iocurrent;\n  uint32_t iopin_position;\n  uint32_t pin_position;\n  \n  for (pin_position = 0; pin_position < 0x10; pin_position = pin_position + 1) {\n    pin_mask = 1 << (pin_position & 0xff);\n    pin_match = gpio_config->Pin & pin_mask;\n    if (pin_match == pin_mask) {\n      if ((gpio_config->Mode == 2) || (gpio_config->Mode == 0x12)) {\n        alternate_function = gpio_config->Alternate;\n        gpio_port->AFR[pin_position >> 3] = gpio_port->AFR[pin_position >> 3] & ~(0xf << ((pin_position & 7) << 2));\n        gpio_port->AFR[pin_position >> 3] = gpio_port->AFR[pin_position >> 3] | alternate_function << ((pin_position & 7) << 2);\n      }\n      gpio_port->MODER = gpio_port->MODER & ~(3 << ((pin_position & 0x7f) << 1));\n      gpio_port->MODER = gpio_port->MODER | (gpio_config->Mode & 3) << ((pin_position & 0x7f) << 1);\n      if ((((gpio_config->Mode == 1) || (gpio_config->Mode == 2)) || (gpio_config->Mode == 0x11)) ||\n         (gpio_config->Mode == 0x12)) {\n        gpio_port->OSPEEDR = gpio_port->OSPEEDR & ~(3 << ((pin_position & 0x7f) << 1));\n        gpio_port->OSPEEDR = gpio_port->OSPEEDR | gpio_config->Speed << ((pin_position & 0x7f) << 1);\n        gpio_port->OTYPER = gpio_port->OTYPER & ~(1 << (pin_position & 0xff));\n        gpio_port->OTYPER = gpio_port->OTYPER | (gpio_config->Mode >> 4 & 1) << (pin_position & 0xff);\n      }\n      gpio_port->PUPDR = gpio_port->PUPDR & ~(3 << ((pin_position & 0x7f) << 1));\n      gpio_port->PUPDR = gpio_port->PUPDR | gpio_config->Pull << ((pin_position & 0x7f) << 1);\n      if ((gpio_config->Mode & 0x10000000) != 0) {\n        *(uint *)(DAT_0800719c + 0x44) = *(uint *)(DAT_0800719c + 0x44) | 0x4000;\n        *(uint *)(DAT_080071a0 + ((pin_position >> 2) + 2) * 4) =\n             ~(0xf << ((pin_position & 3) << 2)) & *(uint *)(DAT_080071a0 + ((pin_position >> 2) + 2) * 4);\n        if (gpio_port == DAT_080071a4) {\n          gpio_index = 0;\n        }\n        else if (gpio_port == DAT_080071a8) {\n          gpio_index = 1;\n        }\n        else if (gpio_port == DAT_080071ac) {\n          gpio_index = 2;\n        }\n        else if (gpio_port == DAT_080071b0) {\n          gpio_index = 3;\n        }\n        else if (gpio_port == DAT_080071b4) {\n          gpio_index = 4;\n        }\n        else if (gpio_port == DAT_080071b8) {\n          gpio_index = 5;\n        }\n        else if (gpio_port == DAT_080071bc) {\n          gpio_index = 6;\n        }\n        else if (gpio_port == DAT_080071c0) {\n          gpio_index = 7;\n        }\n        else if (gpio_port == DAT_080071c4) {\n          gpio_index = 8;\n        }\n        else if (gpio_port == DAT_080071c8) {\n          gpio_index = 9;\n        }\n        else {\n          gpio_index = 10;\n        }\n        *(uint *)(DAT_080071a0 + ((pin_position >> 2) + 2) * 4) =\n             gpio_index << ((pin_position & 3) << 2) | *(uint *)(DAT_080071a0 + ((pin_position >> 2) + 2) * 4);\n        *DAT_080071cc = ~pin_match & *DAT_080071cc;\n        DAT_080071cc[1] = ~pin_match & DAT_080071cc[1];\n        if ((gpio_config->Mode & 0x10000) != 0) {\n          *DAT_080071cc = pin_match | *DAT_080071cc;\n        }\n        if ((gpio_config->Mode & 0x20000) != 0) {\n          DAT_080071cc[1] = pin_match | DAT_080071cc[1];\n        }\n        DAT_080071cc[2] = ~pin_match & DAT_080071cc[2];\n        DAT_080071cc[3] = ~pin_match & DAT_080071cc[3];\n        if ((gpio_config->Mode & 0x100000) != 0) {\n          DAT_080071cc[2] = pin_match | DAT_080071cc[2];\n        }\n        if ((gpio_config->Mode & 0x200000) != 0) {\n          DAT_080071cc[3] = pin_match | DAT_080071cc[3];\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e88",
            "calling": [
                "gpio_init",
                "HAL_RCC_MCOConfig"
            ],
            "imported": false,
            "current_name": "gpio_init_config_08006e88"
        },
        "FUN_0800b4f0": {
            "renaming": {
                "FUN_0800b4f0": "execute_global_dtors_0800b4f0",
                "iVar1": "counter",
                "ppcVar2": "destructor_ptr"
            },
            "code": "\nvoid execute_global_dtors_0800b4f0(void)\n\n{\n  int counter;\n  code **destructor_ptr;\n  \n  counter = (int)PTR___fini_array_end_0800b514 -\n          (int)PTR___do_global_dtors_aux_fini_array_entry_0800b518 >> 2;\n  if (counter != 0) {\n    destructor_ptr = (code **)(PTR___do_global_dtors_aux_fini_array_entry_0800b518 +\n                       ((int)PTR___fini_array_end_0800b514 -\n                       (int)PTR___do_global_dtors_aux_fini_array_entry_0800b518) + -4);\n    do {\n      counter = counter + -1;\n      (**destructor_ptr)();\n      destructor_ptr = destructor_ptr + -1;\n    } while (counter != 0);\n  }\n  _fini();\n  return;\n}\n\n",
            "called": [
                "frame_dummy",
                "_fini",
                "__do_global_dtors_aux"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b4f0",
            "calling": [],
            "imported": false,
            "current_name": "execute_global_dtors_0800b4f0"
        },
        "FUN_080001e0": {
            "renaming": {
                "FUN_080001e0": "do_nothing_080001e0"
            },
            "code": "\nvoid do_nothing_080001e0(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001e0",
            "calling": [
                "coolant_run"
            ],
            "imported": false,
            "current_name": "do_nothing_080001e0"
        },
        "FUN_080036f0": {
            "renaming": {
                "FUN_080036f0": "print_binary_representation_080036f0",
                "n": "number",
                "bits": "bit_count",
                "data": "binary_digit",
                "i": "index",
                "mask": "bit_mask"
            },
            "code": "\nvoindexd print_binary_representation_080036f0(uindexnumbert number,indexnumbert bit_count)\n\n{\n  uindexnumbert8_t binary_digit;\n  indexnumbert index;\n  uindexnumbert32_t bit_mask;\n  \n  bit_mask = 1 << (bit_count - 1U & 0xff);\n  for (index = 0; index < bit_count; index = index + 1) {\n    indexf ((bit_mask & number) == 0) {\n      binary_digit = '0';\n    }\n    else {\n      binary_digit = '1';\n    }\n    serindexal_wrindexte(binary_digit);\n    bit_mask = bit_mask >> 1;\n  }\n  returnumber;\n}\n\n",
            "called": [
                "serial_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036f0",
            "calling": [
                "print_uint16_base2",
                "print_uint8_base2"
            ],
            "imported": false,
            "current_name": "print_binary_representation_080036f0"
        },
        "FUN_08005c74": {
            "renaming": {
                "FUN_08005c74": "configure_registers_08005c74"
            },
            "code": "\nvoid configureRegisters_08005c74(void)\n\n{\n  *DAT_08005ce4 = *DAT_08005ce4 | 0x81;\n  DAT_08005ce4[2] = 0;\n  *DAT_08005ce4 = *DAT_08005ce4 & 0xfaf6ffff;\n  DAT_08005ce4[1] = 0;\n  DAT_08005ce4[1] = DAT_08005ce8 | DAT_08005ce4[1];\n  DAT_08005ce4[0x21] = 0;\n  DAT_08005ce4[0x21] = DAT_08005ce4[0x21] | 0x20003000;\n  *DAT_08005ce4 = *DAT_08005ce4 & 0xfffbffff;\n  DAT_08005ce4[3] = 0;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005c74",
            "calling": [],
            "imported": false,
            "current_name": "configure_registers_08005c74"
        },
        "FUN_08002edc": {
            "renaming": {
                "FUN_08002edc": "execute_planner_passes_08002edc"
            },
            "code": "\nvoid execute_planner_passes_08002edc(void)\n\n{\n  planner_reverse_pass();\n  planner_forward_pass();\n  execute_planner_passes_08002edc_trapezoids();\n  return;\n}\n\n",
            "called": [
                "planner_forward_pass",
                "planner_recalculate_trapezoids",
                "planner_reverse_pass"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002edc",
            "calling": [
                "plan_cycle_reinitialize",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "execute_planner_passes_08002edc"
        },
        "FUN_0800375c": {
            "renaming": {
                "FUN_0800375c": "print_uint16_as_binary_0800375c",
                "n": "number"
            },
            "code": "\nvoid print_uint16_as_binary_0800375c(uinumbert16_t number)\n\n{\n  prinumbert_base2((uinumbert)number,0x10);\n  returnumber;\n}\n\n",
            "called": [
                "print_base2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800375c",
            "calling": [
                "report_grbl_settings"
            ],
            "imported": false,
            "current_name": "print_uint16_as_binary_0800375c"
        },
        "FUN_08009990": {
            "renaming": {
                "FUN_08009990": "calculate_complex_operation_08009990",
                "param_1": "input1_low",
                "param_2": "input1_high",
                "param_3": "input2_low",
                "param_4": "input2_high",
                "param_5": "angle",
                "iVar1": "difference",
                "unaff_r4": "result_high",
                "uVar2": "operationCode",
                "uVar3": "input2_abs",
                "uVar4": "input1_abs",
                "uVar5": "tempResult"
            },
            "code": "\nvoid calculateComplexOperation_08009990(uint input1_low,uint input1_high,uint input2_low,uint input2_high,double angle)\n\n{\n  int difference;\n  undefined4 result_high;\n  uint operationCode;\n  uint input2_abs;\n  uint input1_abs;\n  undefined8 tempResult;\n  \n  input2_abs = input2_high & 0x7fffffff;\n  if ((DAT_08009b18 < (input2_abs | (-input2_low | input2_low) >> 0x1f)) ||\n     (input1_abs = input1_high & 0x7fffffff, DAT_08009b18 < (input1_abs | (-input1_low | input1_low) >> 0x1f))) {\n    __aeabi_dadd(input2_low,input2_high,input1_low,input1_high);\n  }\n  else {\n    if ((input2_high + 0xc0100000 | input2_low) == 0) {\n      atan(angle);\n      return;\n    }\n    operationCode = (int)input2_high >> 0x1e & 2U | input1_high >> 0x1f;\n    if (((((input1_abs | input1_low) != 0) && ((input2_abs | input2_low) != 0)) && (input2_abs != DAT_08009b18)) &&\n       (input1_abs != DAT_08009b18)) {\n      difference = (int)(input1_abs - input2_abs) >> 0x14;\n      if (((int)(input1_abs - input2_abs) < 0x3d00000) &&\n         ((-1 < (int)input2_high || (difference + 0x3c < 0 == SCARRY4(difference,0x3c))))) {\n        __divdf3(input1_low,input1_high,input2_low,input2_high);\n        fabs((double)CONCAT44(result_high,input2_high));\n        atan((double)CONCAT44(result_high,input2_high));\n      }\n      if (operationCode != 1) {\n        if (operationCode == 2) {\n          tempResult = __subdf3();\n          __subdf3(DAT_08009af0,DAT_08009af4,(int)tempResult,(int)((ulonglong)tempResult >> 0x20));\n        }\n        else if (operationCode != 0) {\n          tempResult = __subdf3();\n          __subdf3((int)tempResult,(int)((ulonglong)tempResult >> 0x20),DAT_08009af0,DAT_08009af4);\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "__divdf3",
                "fabs",
                "__aeabi_dadd",
                "atan",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009990",
            "calling": [
                "atan2"
            ],
            "imported": false,
            "current_name": "calculate_complex_operation_08009990"
        },
        "FUN_08005b58": {
            "renaming": {
                "FUN_08005b58": "update_status_08005b58"
            },
            "code": "\nvoid updateStatus_08005b58(void)\n\n{\n  *(uint *)(DAT_08005b70 + 4) = *(uint *)(DAT_08005b70 + 4) & 0xfffffffd;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b58",
            "calling": [],
            "imported": false,
            "current_name": "update_status_08005b58"
        },
        "FUN_08007e58": {
            "renaming": {
                "FUN_08007e58": "is_usart_transmit_ready_08007e58",
                "usart": "usart_ptr"
            },
            "code": "\nint is_usart_transmit_ready_08007e58(void)\n\n{\n  USART_TypeDef *usart_ptr;\n  \n  return (uint)((*DAT_08007e80 & 0x20) != 0);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e58",
            "calling": [
                "serial_read"
            ],
            "imported": false,
            "current_name": "is_usart_transmit_ready_08007e58"
        },
        "FUN_080059f8": {
            "renaming": {
                "FUN_080059f8": "reset_registers_080059f8"
            },
            "code": "\nHAL_StatusTypeDef ResetRegisters_080059f8(void)\n\n{\n  *(undefined4 *)(DAT_08005a4c + 0x20) = 0xffffffff;\n  *(undefined4 *)(DAT_08005a4c + 0x20) = 0;\n  *(undefined4 *)(DAT_08005a4c + 0x24) = 0xffffffff;\n  *(undefined4 *)(DAT_08005a4c + 0x24) = 0;\n  *(undefined4 *)(DAT_08005a4c + 0x10) = 0xffffffff;\n  *(undefined4 *)(DAT_08005a4c + 0x10) = 0;\n  *(undefined4 *)(DAT_08005a4c + 0x14) = 0xffffffff;\n  *(undefined4 *)(DAT_08005a4c + 0x14) = 0;\n  *(undefined4 *)(DAT_08005a4c + 0x18) = 0xffffffff;\n  *(undefined4 *)(DAT_08005a4c + 0x18) = 0;\n  HAL_MspDeInit();\n  return HAL_OK;\n}\n\n",
            "called": [
                "HAL_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080059f8",
            "calling": [],
            "imported": false,
            "current_name": "reset_registers_080059f8"
        },
        "FUN_08009194": {
            "renaming": {
                "FUN_08009194": "calculate_result_08009194",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar2": "double_input_1",
                "uVar3": "double_input_2",
                "uVar4": "combined_value",
                "bVar1": "comparison_result",
                "bVar5": "is_zero"
            },
            "code": "\nuint calculate_result_08009194(uint input_1,uint input_2)\n\n{\n  bool comparison_result;\n  uint double_input_1;\n  uint double_input_2;\n  uint combined_value;\n  bool is_zero;\n  \n  double_input_1 = input_1 * 2;\n  double_input_2 = input_2 * 2;\n  if (((int)double_input_1 >> 0x18 == -1 || (int)double_input_2 >> 0x18 == -1) &&\n     ((((int)double_input_1 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)double_input_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined_value = double_input_1 | input_2 & 0x7fffffff;\n  is_zero = combined_value == 0;\n  if (!is_zero) {\n    combined_value = input_1 ^ input_2;\n    is_zero = combined_value == 0;\n  }\n  comparison_result = -1 < (int)combined_value;\n  if (comparison_result) {\n    input_1 = double_input_1 + input_2 * -2;\n    is_zero = input_1 == 0;\n  }\n  if ((comparison_result && double_input_2 <= double_input_1) && !is_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!comparison_result || double_input_2 > double_input_1) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009194",
            "calling": [],
            "imported": false,
            "current_name": "calculate_result_08009194"
        },
        "FUN_08003f34": {
            "renaming": {
                "FUN_08003f34": "parse_serial_input_08003f34",
                "bVar1": "temp_char_index",
                "status_code": "execution_status",
                "bVar2": "input_char"
            },
            "code": "\nvoid parse_serial_input_08003f34(void)\n\n{\n  byte temp_char_index;\n  uint8_t execution_status;\n  byte input_char;\n  uint8_t c;\n  \n  while( true ) {\n    while( true ) {\n      input_char = serial_read();\n      if (input_char == 0xff) {\n        return;\n      }\n      if ((input_char == 10) || (input_char == 0xd)) break;\n      if (*PTR_iscomment_08004028 == '\\0') {\n        if ((0x20 < input_char) && (input_char != 0x2f)) {\n          if (input_char == 0x28) {\n            *PTR_iscomment_08004028 = 1;\n          }\n          else if (*PTR_char_counter_08004020 == -1) {\n            report_status_message('\\r');\n            protocol_reset_line_buffer();\n          }\n          else if ((input_char < 0x61) || (0x7a < input_char)) {\n            temp_char_index = *PTR_char_counter_08004020;\n            *PTR_char_counter_08004020 = temp_char_index + 1;\n            PTR_line_08004024[temp_char_index] = input_char;\n          }\n          else {\n            temp_char_index = *PTR_char_counter_08004020;\n            *PTR_char_counter_08004020 = temp_char_index + 1;\n            PTR_line_08004024[temp_char_index] = input_char - 0x20;\n          }\n        }\n      }\n      else if (input_char == 0x29) {\n        *PTR_iscomment_08004028 = 0;\n      }\n    }\n    protocol_execute_runtime();\n    if (*PTR_sys_0800401c != '\\0') break;\n    if (*PTR_char_counter_08004020 == '\\0') {\n      report_status_message('\\0');\n    }\n    else {\n      PTR_line_08004024[(byte)*PTR_char_counter_08004020] = 0;\n      execution_status = protocol_execute_line(PTR_line_08004024);\n      report_status_message(execution_status);\n    }\n    protocol_reset_line_buffer();\n  }\n  return;\n}\n\n",
            "called": [
                "protocol_reset_line_buffer",
                "protocol_execute_line",
                "protocol_execute_runtime",
                "report_status_message",
                "serial_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f34",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "parse_serial_input_08003f34"
        },
        "FUN_080095b8": {
            "renaming": {
                "FUN_080095b8": "convert_double_to_long_080095b8",
                "__x": "input_double",
                "in_r0": "input_fraction",
                "in_r1": "input_exponent",
                "uVar1": "temp_var1",
                "uVar2": "shifted_exponent",
                "uVar3": "result",
                "lVar4": "sign",
                "uVar5": "exponent_diff"
            },
            "code": "\nlong convert_double_to_long_080095b8(double input_double)\n\n{\n  uint input_fraction;\n  uint input_exponent;\n  uint temp_var1;\n  uint shifted_exponent;\n  uint result;\n  long sign;\n  uint exponent_diff;\n  \n  shifted_exponent = (input_exponent << 1) >> 0x15;\n  exponent_diff = shifted_exponent - 0x3ff;\n  if ((int)input_exponent < 0) {\n    sign = -1;\n  }\n  else {\n    sign = 1;\n  }\n  result = input_exponent & 0xfffff | 0x100000;\n  if ((int)exponent_diff < 0x14) {\n    if ((int)exponent_diff < 0) {\n      if (exponent_diff != 0xffffffff) {\n        sign = 0;\n      }\n      return sign;\n    }\n    result = result + (0x80000 >> (exponent_diff & 0xff)) >> (0x14 - exponent_diff & 0xff);\n  }\n  else {\n    if (0x1e < exponent_diff) {\n      sign = __aeabi_d2iz();\n      return sign;\n    }\n    if ((int)exponent_diff < 0x34) {\n      temp_var1 = 0x80000000 >> (shifted_exponent - 0x413 & 0xff);\n      if (CARRY4(temp_var1,input_fraction) != false) {\n        result = result + 1;\n      }\n      result = result << (shifted_exponent - 0x413 & 0xff);\n      if (exponent_diff != 0x14) {\n        result = result | temp_var1 + input_fraction >> (0x34 - exponent_diff & 0xff);\n      }\n    }\n    else {\n      result = result << (shifted_exponent - 0x413 & 0xff) | input_fraction << (shifted_exponent - 0x433 & 0xff);\n    }\n  }\n  return result * sign;\n}\n\n",
            "called": [
                "__aeabi_d2iz"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080095b8",
            "calling": [
                "homing_cycle",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "convert_double_to_long_080095b8"
        },
        "FUN_08007e4c": {
            "renaming": {
                "FUN_08007e4c": "do_nothing_08007e4c"
            },
            "code": "\nvoid do_nothing_08007e4c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e4c",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_08007e4c"
        },
        "FUN_08006cf6": {
            "renaming": {
                "FUN_08006cf6": "configure_interrupt_priority_08006cf6",
                "IRQn": "interruptType",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "uVar1": "encodedPriority",
                "prioritygroup": "priorityGroup"
            },
            "code": "\nvoid ConfigureInterruptPriority_08006cf6(interruptType_Type interruptType,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint32_t encodedPriority;\n  uint32_t priorityGroup;\n  \n  encodedPriority = NVIC_GetPriorityGrouping();\n  encodedPriority = NVIC_EncodePriority(encodedPriority,preemptPriority,subPriority);\n  NVIC_SetPriority(interruptType,encodedPriority);\n  return;\n}\n\n",
            "called": [
                "NVIC_EncodePriority",
                "NVIC_GetPriorityGrouping",
                "NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006cf6",
            "calling": [
                "enable_tim_interrupt"
            ],
            "imported": false,
            "current_name": "configure_interrupt_priority_08006cf6"
        },
        "FUN_08002ef0": {
            "renaming": {
                "FUN_08002ef0": "update_buffer_pointers_08002ef0",
                "uVar1": "nextIndex"
            },
            "code": "\nvoid updateBufferPointers_08002ef0(void)\n\n{\n  uint8_t nextIndex;\n  \n  *PTR_block_buffer_tail_08002f1c = *PTR_block_buffer_head_08002f18;\n  nextIndex = next_block_index(*PTR_block_buffer_head_08002f18);\n  *PTR_next_buffer_head_08002f20 = nextIndex;\n  return;\n}\n\n",
            "called": [
                "next_block_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ef0",
            "calling": [
                "plan_init"
            ],
            "imported": false,
            "current_name": "update_buffer_pointers_08002ef0"
        },
        "FUN_08006e7c": {
            "renaming": {
                "FUN_08006e7c": "do_nothing_08006e7c"
            },
            "code": "\nvoid do_nothing_08006e7c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e7c",
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08006e7c"
        },
        "FUN_08001d4c": {
            "renaming": {
                "FUN_08001d4c": "homing_sequence_08001d4c",
                "cVar1": "cycles_remaining",
                "homing_rate": "initial_homing_rate",
                "homing_rate_00": "secondary_homing_rate",
                "extraout_s0": "first_homing_output",
                "homing_rate_01": "intermediate_homing_rate",
                "extraout_s0_00": "second_homing_output",
                "homing_rate_02": "current_homing_rate",
                "n_cycle": "num_cycles"
            },
            "code": "\nvoid homing_sequence_08001d4c(void)\n\n{\n  char cycles_remaining;\n  float initial_homing_rate;\n  float secondary_homing_rate;\n  float first_homing_output;\n  float intermediate_homing_rate;\n  float second_homing_output;\n  float current_homing_rate;\n  int8_t num_cycles;\n  \n  st_wake_up();\n  homing_cycle('\\x04','\\x01',false,initial_homing_rate);\n  homing_cycle('\\x03','\\x01',false,secondary_homing_rate);\n  delay_ms(*(uint16_t *)(PTR_settings_08001dd8 + 0x34));\n  num_cycles = '\\x02';\n  current_homing_rate = first_homing_output;\n  while (cycles_remaining = num_cycles + -1, num_cycles != '\\0') {\n    homing_cycle('\\a','\\0',true,current_homing_rate);\n    delay_ms(*(uint16_t *)(PTR_settings_08001dd8 + 0x34));\n    current_homing_rate = intermediate_homing_rate;\n    num_cycles = cycles_remaining;\n    if ('\\0' < cycles_remaining) {\n      homing_cycle('\\a','\\x01',false,intermediate_homing_rate);\n      delay_ms(*(uint16_t *)(PTR_settings_08001dd8 + 0x34));\n      current_homing_rate = second_homing_output;\n    }\n  }\n  st_go_idle();\n  return;\n}\n\n",
            "called": [
                "st_go_idle",
                "homing_cycle",
                "delay_ms",
                "st_wake_up"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001d4c",
            "calling": [
                "mc_go_home"
            ],
            "imported": false,
            "current_name": "homing_sequence_08001d4c"
        },
        "FUN_08000268": {
            "renaming": {
                "FUN_08000268": "calculate_adjusted_tick_08000268",
                "uVar1": "currentTick"
            },
            "code": "\nuint64_t calculateAdjustedTick_08000268(void)\n\n{\n  uint32_t currentTick;\n  \n  currentTick = HAL_GetTick();\n  return (uint64_t)\n         ((currentTick + 1) * 1000 -\n         (uint)((ulonglong)DAT_0800029c * (ulonglong)(*(uint *)(DAT_08000298 + 8) >> 3) >> 0x21));\n}\n\n",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000268",
            "calling": [
                "_delay_us"
            ],
            "imported": false,
            "current_name": "calculate_adjusted_tick_08000268"
        },
        "FUN_0800918c": {
            "renaming": {
                "FUN_0800918c": "calculate_result_0800918c",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar2": "double_input_1",
                "uVar3": "double_input_2",
                "uVar4": "intermediate_result",
                "bVar1": "condition_1",
                "bVar5": "is_zero"
            },
            "code": "\nuint calculate_result_0800918c(uint input_1,uint input_2)\n\n{\n  bool condition_1;\n  uint double_input_1;\n  uint double_input_2;\n  uint intermediate_result;\n  bool is_zero;\n  \n  double_input_1 = input_1 * 2;\n  double_input_2 = input_2 * 2;\n  if (((int)double_input_1 >> 0x18 == -1 || (int)double_input_2 >> 0x18 == -1) &&\n     ((((int)double_input_1 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)double_input_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 0xffffffff;\n  }\n  intermediate_result = double_input_1 | input_2 & 0x7fffffff;\n  is_zero = intermediate_result == 0;\n  if (!is_zero) {\n    intermediate_result = input_1 ^ input_2;\n    is_zero = intermediate_result == 0;\n  }\n  condition_1 = -1 < (int)intermediate_result;\n  if (condition_1) {\n    input_1 = double_input_1 + input_2 * -2;\n    is_zero = input_1 == 0;\n  }\n  if ((condition_1 && double_input_2 <= double_input_1) && !is_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!condition_1 || double_input_2 > double_input_1) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800918c",
            "calling": [],
            "imported": false,
            "current_name": "calculate_result_0800918c"
        },
        "FUN_08003778": {
            "renaming": {
                "FUN_08003778": "print_ulong_as_string_08003778",
                "n": "number",
                "uVar1": "temp_index",
                "local_1c": "remaining_number",
                "uStack_15": "unused",
                "buf": "buffer",
                "i": "index"
            },
            "code": "\nvoindexd print_ulong_as_string_08003778(ulonumberg number)\n\n{\n  uindexnumbert temp_index;\n  ulonumberg remaining_number;\n  uindexnumbert8_t unused;\n  uchar buffer [10];\n  uindexnumbert8_t index;\n  \n  index = '\\0';\n  remaining_number = number;\n  indexf (number == 0) {\n    serindexal_wrindexte('0');\n  }\n  else {\n    for (; remaining_number != 0; remaining_number = (ulonumberg)((ulonumberglonumberg)DAT_080037f8 * (ulonumberglonumberg)remaining_number >> 0x23))\n    {\n      temp_index = (uindexnumbert)index;\n      index = index + '\\x01';\n      buffer[temp_index] = (char)remaining_number +\n                   (char)(uindexnumbert)((ulonumberglonumberg)DAT_080037f8 * (ulonumberglonumberg)remaining_number >> 0x23) * -10 + '0';\n    }\n    for (; index != '\\0'; index = index + 0xff) {\n      serindexal_wrindexte(buffer[index - 1]);\n    }\n  }\n  returnumber;\n}\n\n",
            "called": [
                "serial_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003778",
            "calling": [
                "printInteger"
            ],
            "imported": false,
            "current_name": "print_ulong_as_string_08003778"
        },
        "FUN_0800b3dc": {
            "renaming": {
                "FUN_0800b3dc": "get_impure_ptr_value_0800b3dc",
                "undefined4": "uint32_t"
            },
            "code": "\nuint32_t get_impure_ptr_value_0800b3dc(void)\n\n{\n  return *(uint32_t *)PTR__impure_ptr_0800b3e4;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b3dc",
            "calling": [
                "sqrt",
                "hypot"
            ],
            "imported": false,
            "current_name": "get_impure_ptr_value_0800b3dc"
        },
        "FUN_080046d0": {
            "renaming": {
                "FUN_080046d0": "display_information_080046d0",
                "bVar1": "byteVar",
                "cVar2": "charVar",
                "n": "floatVar",
                "n_00": "floatVar2",
                "uVar3": "undefinedVar"
            },
            "code": "\nvoid displayInformation_080046d0(void)\n\n{\n  byte byteVar;\n  char charVar;\n  float floatVar;\n  float floatVar2;\n  ufloatVardefifloatVared8 undefinedVar;\n  \n  if (4 < (byte)PTR_gc_08004890[1]) {\n    prifloatVartPgmStrifloatVarg(PTR_DAT_080048a8);\n    prifloatVartIfloatVarteger((byte)PTR_gc_08004890[0x1c] + 0x36);\n    if (PTR_gc_08004890[0x19] == '\\0') {\n      if (PTR_gc_08004890[0x1a] == '\\x01') {\n        prifloatVartPgmStrifloatVarg(PTR_DAT_080048ac);\n      }\n      else {\n        prifloatVartPgmStrifloatVarg(PTR_DAT_080048b0);\n      }\n    }\n    else {\n      prifloatVartPgmStrifloatVarg(PTR_DAT_080048b4);\n    }\n    if (PTR_gc_08004890[3] == '\\0') {\n      prifloatVartPgmStrifloatVarg(PTR_DAT_080048bc);\n    }\n    else {\n      prifloatVartPgmStrifloatVarg(PTR_DAT_080048b8);\n    }\n    if (PTR_gc_08004890[4] == '\\0') {\n      prifloatVartPgmStrifloatVarg(PTR_DAT_080048c4);\n    }\n    else {\n      prifloatVartPgmStrifloatVarg(PTR_DAT_080048c0);\n    }\n    if (PTR_gc_08004890[2] == '\\0') {\n      prifloatVartPgmStrifloatVarg(PTR_DAT_080048cc);\n    }\n    else {\n      prifloatVartPgmStrifloatVarg(PTR_DAT_080048c8);\n    }\n    byteVar = PTR_gc_08004890[5];\n    if (byteVar == 2) {\n      prifloatVartPgmStrifloatVarg(PTR_DAT_080048d8);\n    }\n    else if (byteVar < 3) {\n      if (byteVar == 0) {\n        prifloatVartPgmStrifloatVarg(PTR_DAT_080048d0);\n      }\n      else if (byteVar == 1) {\n        prifloatVartPgmStrifloatVarg(PTR_DAT_080048d4);\n      }\n    }\n    charVar = PTR_gc_08004890[6];\n    if (charVar == '\\x01') {\n      prifloatVartPgmStrifloatVarg(PTR_DAT_080048dc);\n    }\n    else if (charVar < '\\x02') {\n      if (charVar == -1) {\n        prifloatVartPgmStrifloatVarg(PTR_DAT_080048e0);\n      }\n      else if (charVar == '\\0') {\n        prifloatVartPgmStrifloatVarg(PTR_DAT_080048e4);\n      }\n    }\n    byteVar = PTR_gc_08004890[7];\n    if (byteVar == 2) {\n      prifloatVartPgmStrifloatVarg(PTR_DAT_080048f0);\n    }\n    else if (byteVar < 3) {\n      if (byteVar == 0) {\n        prifloatVartPgmStrifloatVarg(PTR_DAT_080048e8);\n      }\n      else if (byteVar == 1) {\n        prifloatVartPgmStrifloatVarg(PTR_DAT_080048ec);\n      }\n    }\n    prifloatVartPgmStrifloatVarg(PTR_DAT_080048f4);\n    prifloatVartIfloatVarteger((uifloatVart)(byte)PTR_gc_08004890[0x18]);\n    prifloatVartPgmStrifloatVarg(PTR_DAT_080048f8);\n    if (PTR_gc_08004890[3] == '\\0') {\n      prifloatVartFloat(floatVar);\n    }\n    else {\n      undefinedVar = __aeabi_f2d(*(ufloatVardefifloatVared4 *)(PTR_gc_08004890 + 8));\n      undefinedVar = __muldf3((ifloatVart)undefinedVar,(ifloatVart)((ulofloatVarglofloatVarg)undefinedVar >> 0x20),DAT_08004888,DAT_0800488c);\n      floatVar2 = (float)__trufloatVarcdfsf2((ifloatVart)undefinedVar,(ifloatVart)((ulofloatVarglofloatVarg)undefinedVar >> 0x20));\n      prifloatVartFloat(floatVar2);\n    }\n    prifloatVartPgmStrifloatVarg(PTR_DAT_080048fc);\n    returfloatVar;\n  }\n                    /* WARNING: Could floatVarot recover jumptable at 0x080046de. Too mafloatVary brafloatVarches */\n                    /* WARNING: TreatifloatVarg ifloatVardirect jump as call */\n  (*(code *)(&switchD_080046de::switchdataD_080046e4)[(byte)PTR_gc_08004890[1]])();\n  returfloatVar;\n}\n\n",
            "called": [
                "printInteger",
                "printFloat",
                "printPgmString",
                "__muldf3",
                "__truncdfsf2",
                "__aeabi_f2d"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080046d0",
            "calling": [
                "protocol_execute_line"
            ],
            "imported": false,
            "current_name": "display_information_080046d0"
        },
        "FUN_08006d72": {
            "renaming": {
                "FUN_08006d72": "configure_sys_tick_08006d72",
                "TicksNumb": "ticksNumber",
                "uVar1": "configResult"
            },
            "code": "\nuint32_t configureSysTick_08006d72(uint32_t ticksNumber)\n\n{\n  uint32_t configResult;\n  \n  configResult = SysTick_Config(ticksNumber);\n  return configResult;\n}\n\n",
            "called": [
                "SysTick_Config"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d72",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "configure_sys_tick_08006d72"
        },
        "FUN_0800756c": {
            "renaming": {
                "FUN_0800756c": "initialize_control_registers_0800756c"
            },
            "code": "\nvoid initializeControlRegisters_0800756c(void)\n\n{\n  *DAT_080075bc = *DAT_080075bc | 1;\n  DAT_080075bc[2] = 0;\n  *DAT_080075bc = *DAT_080075bc & 0xfef6ffff;\n  DAT_080075bc[1] = DAT_080075c0;\n  *DAT_080075bc = *DAT_080075bc & 0xfffbffff;\n  DAT_080075bc[3] = 0;\n  *(undefined4 *)(DAT_080075c4 + 8) = 0x8000000;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800756c",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "initialize_control_registers_0800756c"
        },
        "FUN_0800691c": {
            "renaming": {
                "FUN_0800691c": "check_and_set_flag_0800691c"
            },
            "code": "\nvoid checkAndSetFlag_0800691c(void)\n\n{\n  if ((*(uint *)(DAT_0800693c + 0xc) & 0x80) == 0x80) {\n    HAL_RCC_CCSCallback();\n    *DAT_08006940 = 0x80;\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_RCC_CCSCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800691c",
            "calling": [],
            "imported": false,
            "current_name": "check_and_set_flag_0800691c"
        },
        "FUN_080001f8": {
            "renaming": {
                "FUN_080001f8": "stop_coolant_mode_080001f8"
            },
            "code": "\nvoid stopCoolantMode_080001f8(void)\n\n{\n  *PTR_current_coolant_mode_0800020c = 0;\n  coolant_stop();\n  return;\n}\n\n",
            "called": [
                "coolant_stop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001f8",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "stop_coolant_mode_080001f8"
        },
        "FUN_08002f74": {
            "renaming": {
                "FUN_08002f74": "get_next_block_08002f74",
                "pbVar1": "next_block"
            },
            "code": "\nblock_t * get_next_block_08002f74(void)\n\n{\n  block_t *next_block;\n  \n  if (*PTR_block_buffer_head_08002fa0 == *PTR_block_buffer_tail_08002fa4) {\n    next_block = (block_t *)0x0;\n  }\n  else {\n    next_block = (block_t *)\n             (PTR_block_buffer_08002fa8 + (uint)(byte)*PTR_block_buffer_tail_08002fa4 * 0x40);\n  }\n  return next_block;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f74",
            "calling": [
                "step_period_isr",
                "plan_synchronize"
            ],
            "imported": false,
            "current_name": "get_next_block_08002f74"
        },
        "FUN_0800b3e8": {
            "renaming": {
                "FUN_0800b3e8": "initialize_and_finalize_0800b3e8",
                "param_1": "pkey_context",
                "iVar1": "counter",
                "ppcVar2": "func_ptr_array",
                "iVar3": "array_length"
            },
            "code": "\nvoid initialize_and_finalize_0800b3e8(EVP_PKEY_CTX *pkey_context)\n\n{\n  int counter;\n  code **func_ptr_array;\n  int array_length;\n  \n  array_length = (int)PTR___preinit_array_end_0800b420 - (int)PTR___preinit_array_end_0800b424 >> 2;\n  if (array_length != 0) {\n    counter = 0;\n    func_ptr_array = (code **)PTR___preinit_array_end_0800b424;\n    do {\n      counter = counter + 1;\n      pkey_context = (EVP_PKEY_CTX *)(**func_ptr_array)();\n      func_ptr_array = func_ptr_array + 1;\n    } while (array_length != counter);\n  }\n  func_ptr_array = (code **)PTR___preinit_array_end_0800b42c;\n  array_length = (int)PTR___do_global_dtors_aux_fini_array_entry_0800b428 -\n          (int)PTR___preinit_array_end_0800b42c;\n  _init(pkey_context);\n  array_length = array_length >> 2;\n  if (array_length != 0) {\n    counter = 0;\n    do {\n      counter = counter + 1;\n      (**func_ptr_array)();\n      func_ptr_array = func_ptr_array + 1;\n    } while (array_length != counter);\n  }\n  return;\n}\n\n",
            "called": [
                "frame_dummy",
                "_init",
                "register_fini"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b3e8",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "initialize_and_finalize_0800b3e8"
        },
        "FUN_080096e8": {
            "renaming": {
                "FUN_080096e8": "calculate_trig_function_080096e8",
                "__x": "input_angle",
                "in_r0": "input_angle_high",
                "in_r1": "input_angle_low",
                "dVar2": "result",
                "local_28": "angle_high_quad",
                "uStack_24": "angle_low_quad",
                "local_20": "angle_high_remainder",
                "uStack_1c": "angle_low_remainder",
                "uVar1": "quadrant"
            },
            "code": "\ndouble calculate_trig_function_080096e8(double input_angle)\n\n{\n  undefined4 input_angle_high;\n  uint quadrant;\n  uint input_angle_low;\n  double result;\n  undefined4 angle_high_quad;\n  undefined4 angle_low_quad;\n  undefined4 angle_high_remainder;\n  undefined4 angle_low_remainder;\n  \n  if (DAT_08009790 < (int)(input_angle_low & 0x7fffffff)) {\n    if (DAT_08009794 < (int)(input_angle_low & 0x7fffffff)) {\n      result = (double)__subdf3();\n    }\n    else {\n      quadrant = __ieee754_rem_pio2(input_angle_high,input_angle_low,&angle_high_quad);\n      quadrant = quadrant & 3;\n      if (quadrant == 1) {\n        result = (double)__kernel_cos(angle_high_quad,angle_low_quad,angle_high_remainder,angle_low_remainder);\n      }\n      else if (quadrant == 2) {\n        result = (double)__kernel_calculate_trig_function_080096e8(angle_high_quad,angle_low_quad,angle_high_remainder,angle_low_remainder,1);\n      }\n      else if (quadrant == 0) {\n        result = (double)__kernel_calculate_trig_function_080096e8(angle_high_quad,angle_low_quad,angle_high_remainder,angle_low_remainder,1);\n      }\n      else {\n        result = (double)__kernel_cos(angle_high_quad,angle_low_quad,angle_high_remainder,angle_low_remainder);\n      }\n    }\n    return result;\n  }\n  result = (double)__kernel_calculate_trig_function_080096e8(input_angle_high,input_angle_low,0,0,0);\n  return result;\n}\n\n",
            "called": [
                "__kernel_cos",
                "__kernel_sin",
                "__ieee754_rem_pio2",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080096e8",
            "calling": [
                "mc_arc"
            ],
            "imported": false,
            "current_name": "calculate_trig_function_080096e8"
        },
        "FUN_08006a18": {
            "renaming": {
                "FUN_08006a18": "is_interrupt_active_08006a18",
                "IRQn": "interruptNumber"
            },
            "code": "\nuint32_t isInterruptActive_08006a18(interruptNumber_Type interruptNumber)\n\n{\n  return (uint)((*(uint *)(DAT_08006a54 + (((uint)(int)interruptNumber >> 5) + 0x40) * 4) & 1 << (interruptNumber & 0x1fU)\n                ) != 0);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006a18",
            "calling": [
                "HAL_NVIC_GetPendingIRQ"
            ],
            "imported": false,
            "current_name": "is_interrupt_active_08006a18"
        },
        "FUN_08002c18": {
            "renaming": {
                "FUN_08002c18": "calculate_acceleration_08002c18",
                "block_t": "motion_block",
                "entry_factor": "entry_speed_factor",
                "exit_factor": "exit_speed_factor",
                "uVar1": "temp_float",
                "uVar2": "temp_uint32",
                "iVar3": "temp_int1",
                "iVar4": "temp_int2",
                "uVar5": "temp_uint",
                "in_r1": "entry_speed",
                "extraout_r1": "temp_extraout1",
                "extraout_r1_00": "temp_extraout2",
                "extraout_r1_01": "temp_extraout3",
                "extraout_r1_02": "temp_extraout4",
                "extraout_r1_03": "temp_extraout5",
                "in_r2": "exit_speed",
                "acceleration": "accel_rate",
                "acceleration_00": "decel_rate",
                "acceleration_01": "intersection_accel",
                "distance": "intersection_dist",
                "uVar6": "temp_double",
                "in_stack_ffffffc8": "temp_stack_var",
                "decelerate_steps": "decel_steps",
                "acceleration_per_minute": "accel_per_minute",
                "plateau_steps": "steady_speed_steps",
                "accelerate_steps": "accel_steps"
            },
            "code": "\nvoid calculate_acceleration_08002c18(motion_block *block,float entry_speed_factor,float exit_speed_factor)\n\n{\n  undefined4 temp_float;\n  uint32_t temp_uint32;\n  int temp_int1;\n  int temp_int2;\n  uint temp_uint;\n  undefined4 entry_speed;\n  undefined4 temp_extraout1;\n  undefined4 temp_extraout2;\n  undefined4 temp_extraout3;\n  undefined4 temp_extraout4;\n  undefined4 temp_extraout5;\n  undefined4 exit_speed;\n  float accel_rate;\n  float decel_rate;\n  float intersection_accel;\n  float intersection_dist;\n  undefined8 temp_double;\n  undefined4 temp_stack_var;\n  int32_t decel_steps;\n  int32_t accel_per_minute;\n  int32_t steady_speed_steps;\n  int32_t accel_steps;\n  \n  temp_float = __floatunsisf(entry_speed_factor,block->nominal_rate);\n  temp_float = __aeabi_fmul(temp_float,entry_speed);\n  temp_float = __aeabi_f2d(temp_float);\n  ceil((double)CONCAT44(exit_speed,temp_stack_var));\n  temp_uint32 = __aeabi_d2uiz(temp_float,temp_extraout1);\n  block->initial_rate = temp_uint32;\n  temp_float = __floatunsisf(block->nominal_rate);\n  temp_float = __aeabi_fmul(temp_float,exit_speed);\n  temp_float = __aeabi_f2d(temp_float);\n  ceil((double)CONCAT44(exit_speed,temp_stack_var));\n  temp_uint32 = __aeabi_d2uiz(temp_float,temp_extraout2);\n  block->final_rate = temp_uint32;\n  temp_double = __aeabi_i2d(block->rate_delta * 0x32);\n  temp_double = __muldf3((int)temp_double,(int)((ulonglong)temp_double >> 0x20),0,DAT_08002e04);\n  temp_int1 = __aeabi_d2iz((int)temp_double,(int)((ulonglong)temp_double >> 0x20));\n  temp_float = __floatunsisf(block->initial_rate);\n  __floatunsisf(block->nominal_rate);\n  temp_double = __floatsisf(temp_int1);\n  estimate_accel_rate_intersection_dist((float)temp_double,(float)((ulonglong)temp_double >> 0x20),accel_rate);\n  temp_float = __aeabi_f2d(temp_float);\n  ceil((double)CONCAT44(exit_speed,temp_stack_var));\n  accel_steps = __aeabi_d2iz(temp_float,temp_extraout3);\n  temp_float = __floatunsisf(block->nominal_rate);\n  __floatunsisf(block->final_rate);\n  temp_double = __floatsisf(-temp_int1);\n  estimate_accel_rate_intersection_dist((float)temp_double,(float)((ulonglong)temp_double >> 0x20),decel_rate);\n  temp_float = __aeabi_f2d(temp_float);\n  floor((double)CONCAT44(exit_speed,temp_stack_var));\n  temp_int2 = __aeabi_d2iz(temp_float,temp_extraout4);\n  steady_speed_steps = (block->step_event_count - accel_steps) - temp_int2;\n  if (steady_speed_steps < 0) {\n    temp_float = __floatunsisf(block->initial_rate);\n    __floatunsisf(block->final_rate);\n    __floatsisf(temp_int1);\n    temp_double = __floatsisf(block->step_event_count);\n    intersection_intersection_dist((float)temp_double,(float)((ulonglong)temp_double >> 0x20),intersection_accel,intersection_dist);\n    temp_float = __aeabi_f2d(temp_float);\n    ceil((double)CONCAT44(exit_speed,temp_stack_var));\n    temp_uint = __aeabi_d2iz(temp_float,temp_extraout5);\n    temp_uint = temp_uint & ~((int)temp_uint >> 0x1f);\n    accel_steps = block->step_event_count;\n    if ((int)temp_uint <= block->step_event_count) {\n      accel_steps = temp_uint;\n    }\n    steady_speed_steps = 0;\n  }\n  block->accelerate_until = accel_steps;\n  block->decelerate_after = steady_speed_steps + accel_steps;\n  return;\n}\n\n",
            "called": [
                "__floatunsisf",
                "__floatsisf",
                "estimate_acceleration_distance",
                "floor",
                "__aeabi_fmul",
                "ceil",
                "__muldf3",
                "intersection_distance",
                "__aeabi_d2iz",
                "__aeabi_i2d",
                "__aeabi_d2uiz",
                "__aeabi_f2d"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c18",
            "calling": [
                "planner_recalculate_trapezoids"
            ],
            "imported": false,
            "current_name": "calculate_acceleration_08002c18"
        },
        "FUN_08006ac0": {
            "renaming": {
                "FUN_08006ac0": "is_interrupt_enabled_08006ac0",
                "IRQn_Type": "IRQType",
                "IRQn": "irqNumber"
            },
            "code": "\nuint32_t isInterruptEnabled_08006ac0(IRQType irqNumber)\n\n{\n  return (uint)((*(uint *)(DAT_08006afc + (((uint)(int)irqNumber >> 5) + 0x80) * 4) & 1 << (irqNumber & 0x1fU)\n                ) != 0);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006ac0",
            "calling": [
                "HAL_NVIC_GetActive"
            ],
            "imported": false,
            "current_name": "is_interrupt_enabled_08006ac0"
        },
        "FUN_080001ec": {
            "renaming": {
                "FUN_080001ec": "do_nothing_080001ec"
            },
            "code": "\nvoid do_nothing_080001ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001ec",
            "calling": [
                "coolant_stop"
            ],
            "imported": false,
            "current_name": "do_nothing_080001ec"
        },
        "FUN_08005a50": {
            "renaming": {
                "FUN_08005a50": "do_nothing_08005a50"
            },
            "code": "\nvoid do_nothing_08005a50(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a50",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_08005a50"
        },
        "FUN_08002ba8": {
            "renaming": {
                "FUN_08002ba8": "process_block_buffer_08002ba8",
                "block_t": "BlockType",
                "previous": "previous_block",
                "next": "next_block",
                "block": "block_array",
                "next_block_index": "get_next_block_index"
            },
            "code": "\nvoid process_block_buffer_08002ba8(void)\n\n{\n  BlockType *previous_block;\n  BlockType *next_block;\n  BlockType *block_array [3];\n  uint8_t block_array_index;\n  \n  block_array_index = *PTR_block_array_buffer_tail_08002c0c;\n  block_array[1] = (BlockType *)0x0;\n  block_array[2] = (BlockType *)0x0;\n  while (previous_block = block_array[1], block_array_index != *PTR_block_array_buffer_head_08002c14) {\n    block_array[1] = block_array[2];\n    next_block = (BlockType *)(PTR_block_array_buffer_08002c10 + (uint)block_array_index * 0x40);\n    process_block_buffer_08002ba8_kernel(previous_block,block_array[2],next_block);\n    block_array_index = get_next_block_index(block_array_index);\n    block_array[2] = next_block;\n  }\n  process_block_buffer_08002ba8_kernel(block_array[1],block_array[2],(BlockType *)0x0);\n  return;\n}\n\n",
            "called": [
                "planner_forward_pass_kernel",
                "next_block_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ba8",
            "calling": [
                "planner_recalculate"
            ],
            "imported": false,
            "current_name": "process_block_buffer_08002ba8"
        },
        "FUN_0800919c": {
            "renaming": {
                "FUN_0800919c": "calculate_result_0800919c",
                "param_1": "input1",
                "param_2": "input2",
                "uVar2": "doubleInput1",
                "uVar3": "doubleInput2",
                "uVar4": "intermediateResult",
                "bVar1": "condition1",
                "bVar5": "condition2"
            },
            "code": "\nuint calculateResult_0800919c(uint input1,uint input2)\n\n{\n  bool condition1;\n  uint doubleInput1;\n  uint doubleInput2;\n  uint intermediateResult;\n  bool condition2;\n  \n  doubleInput1 = input1 * 2;\n  doubleInput2 = input2 * 2;\n  if (((int)doubleInput1 >> 0x18 == -1 || (int)doubleInput2 >> 0x18 == -1) &&\n     ((((int)doubleInput1 >> 0x18 == -1 && ((input1 & 0x7fffff) != 0)) ||\n      (((int)doubleInput2 >> 0x18 == -1 && ((input2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  intermediateResult = doubleInput1 | input2 & 0x7fffffff;\n  condition2 = intermediateResult == 0;\n  if (!condition2) {\n    intermediateResult = input1 ^ input2;\n    condition2 = intermediateResult == 0;\n  }\n  condition1 = -1 < (int)intermediateResult;\n  if (condition1) {\n    input1 = doubleInput1 + input2 * -2;\n    condition2 = input1 == 0;\n  }\n  if ((condition1 && doubleInput2 <= doubleInput1) && !condition2) {\n    input1 = (int)input2 >> 0x1f;\n  }\n  if (!condition1 || doubleInput2 > doubleInput1) {\n    input1 = ~((int)input2 >> 0x1f);\n  }\n  if (!condition2) {\n    input1 = input1 | 1;\n  }\n  return input1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800919c",
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "imported": false,
            "current_name": "calculate_result_0800919c"
        },
        "FUN_0800b2cc": {
            "renaming": {
                "FUN_0800b2cc": "return_input_double_0800b2cc",
                "__x": "input_double",
                "in_d0": "input_value"
            },
            "code": "\ndouble return_input_double_0800b2cc(double input_double)\n\n{\n  double input_value;\n  \n  return input_value;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b2cc",
            "calling": [
                "__ieee754_atan2",
                "__ieee754_rem_pio2",
                "atan"
            ],
            "imported": false,
            "current_name": "return_input_double_0800b2cc"
        },
        "FUN_0800854c": {
            "renaming": {
                "FUN_0800854c": "calculate_result_0800854c",
                "param_1": "input_value",
                "uVar1": "temp_result",
                "iVar3": "leading_zeroes",
                "uVar4": "adjusted_zeroes",
                "in_r12": "shift_amount",
                "bVar5": "is_negative1",
                "bVar6": "is_zero1",
                "bVar7": "is_negative2"
            },
            "code": "\nulonglong calculate_result_0800854c(uint input_value)\n\n{\n  uint temp_result;\n  uint uVar2;\n  int leading_zeroes;\n  uint adjusted_zeroes;\n  uint shift_amount;\n  bool is_negative1;\n  bool is_zero1;\n  bool is_negative2;\n  \n  if (input_value == 0) {\n    return 0;\n  }\n  temp_result = 0;\n  leading_zeroes = count_leading_zeroes(input_value);\n  adjusted_zeroes = leading_zeroes + 0x15;\n  is_negative2 = SBORROW4(adjusted_zeroes,0x20);\n  uVar2 = leading_zeroes - 0xb;\n  is_negative1 = (int)uVar2 < 0;\n  is_zero1 = uVar2 == 0;\n  if ((int)adjusted_zeroes < 0x20) {\n    is_negative2 = SCARRY4(uVar2,0xc);\n    leading_zeroes = leading_zeroes + 1;\n    is_negative1 = leading_zeroes < 0;\n    is_zero1 = leading_zeroes == 0;\n    uVar2 = adjusted_zeroes;\n    if (!is_zero1 && is_negative1 == is_negative2) {\n      temp_result = input_value << (adjusted_zeroes & 0xff);\n      input_value = input_value >> (0xcU - leading_zeroes & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (is_zero1 || is_negative1 != is_negative2) {\n    shift_amount = 0x20 - uVar2;\n  }\n  input_value = input_value << (uVar2 & 0xff);\n  if (is_zero1 || is_negative1 != is_negative2) {\n    input_value = input_value | 0U >> (shift_amount & 0xff);\n  }\n  if (is_zero1 || is_negative1 != is_negative2) {\n    temp_result = 0 << (uVar2 & 0xff);\n  }\nLAB_08008458:\n  if ((int)adjusted_zeroes < 0x433) {\n    return CONCAT44(input_value + (0x432 - adjusted_zeroes) * 0x100000,temp_result);\n  }\n  uVar2 = ~(0x432 - adjusted_zeroes);\n  if (0x1e < (int)uVar2) {\n    return (ulonglong)(input_value >> (uVar2 - 0x1f & 0xff));\n  }\n  leading_zeroes = uVar2 - 0x13;\n  if (leading_zeroes == 0 || leading_zeroes < 0 != SCARRY4(uVar2 - 0x1f,0xc)) {\n    uVar2 = uVar2 + 1;\n    return CONCAT44(input_value >> (uVar2 & 0xff),\n                    temp_result >> (uVar2 & 0xff) | input_value << (0x20 - uVar2 & 0xff));\n  }\n  return (ulonglong)(temp_result >> (0x20 - (0xcU - leading_zeroes) & 0xff) | input_value << (0xcU - leading_zeroes & 0xff));\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800854c",
            "calling": [
                "homing_cycle"
            ],
            "imported": false,
            "current_name": "calculate_result_0800854c"
        },
        "FUN_08008e44": {
            "renaming": {
                "FUN_08008e44": "calculate_result_08008e44",
                "param_1": "input_value",
                "iVar1": "leading_zeroes",
                "uVar2": "shift_amount",
                "uVar3": "result",
                "iVar4": "intermediate_value",
                "uVar5": "temp_value"
            },
            "code": "\nuint calculate_result_08008e44(uint input_value)\n\n{\n  int leading_zeroes;\n  uint shift_amount;\n  uint result;\n  int intermediate_value;\n  uint temp_value;\n  \n  result = input_value & 0x80000000;\n  if ((int)result < 0) {\n    input_value = -input_value;\n  }\n  if (input_value == 0) {\n    return 0;\n  }\n  leading_zeroes = count_leading_zeroes(input_value);\n  shift_amount = leading_zeroes - 8;\n  intermediate_value = ((result | 0x4b000000) - 0x800000) + shift_amount * -0x800000;\n  if (7 < leading_zeroes) {\n    temp_value = 0 << (shift_amount & 0xff);\n    result = intermediate_value + (input_value << (shift_amount & 0xff)) +\n            (0U >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < temp_value);\n    if (temp_value == 0x80000000) {\n      result = result & 0xfffffffe;\n    }\n    return result;\n  }\n  shift_amount = input_value << (leading_zeroes + 0x18U & 0xff);\n  result = intermediate_value + ((input_value >> (0x20 - (leading_zeroes + 0x18U) & 0xff)) - ((int)shift_amount >> 0x1f));\n  if ((shift_amount & 0x7fffffff) == 0) {\n    result = result & ~(shift_amount >> 0x1f);\n  }\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e44",
            "calling": [
                "gc_set_current_position",
                "plan_cycle_reinitialize",
                "mc_arc",
                "report_realtime_status",
                "calculate_trapezoid_for_block",
                "mc_go_home",
                "plan_buffer_line",
                "mc_dwell"
            ],
            "imported": false,
            "current_name": "calculate_result_08008e44"
        },
        "FUN_0800733e": {
            "renaming": {
                "FUN_0800733e": "set_gpio_pin_state_0800733e",
                "GPIOx": "gpioPort",
                "GPIO_Pin": "gpioPin",
                "PinState": "pinState"
            },
            "code": "\nvoid setGPIO_PinState_0800733e(GPIO_TypeDef *gpioPort,uint16_t gpioPin,gpioPinState pinState)\n\n{\n  if (pinState == GPIO_PIN_RESET) {\n    gpioPort->BSRRH = gpioPin;\n  }\n  else {\n    gpioPort->BSRRL = gpioPin;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800733e",
            "calling": [
                "gpio_init"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_state_0800733e"
        },
        "FUN_08005aec": {
            "renaming": {
                "FUN_08005aec": "get_lower_12_bits_08005aec"
            },
            "code": "\nuint32_t get_lower_12_bits_08005aec(void)\n\n{\n  return *DAT_08005b00 & 0xfff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005aec",
            "calling": [],
            "imported": false,
            "current_name": "get_lower_12_bits_08005aec"
        },
        "FUN_08005b74": {
            "renaming": {
                "FUN_08005b74": "set_flag_08005b74"
            },
            "code": "\nvoid setFlag_08005b74(void)\n\n{\n  *(uint *)(DAT_08005b8c + 4) = *(uint *)(DAT_08005b8c + 4) | 4;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b74",
            "calling": [],
            "imported": false,
            "current_name": "set_flag_08005b74"
        },
        "FUN_0800583c": {
            "renaming": {
                "FUN_0800583c": "initialize_system_0800583c",
                "step_wr": "writeStep",
                "st_wake_up": "wakeUpSystem",
                "st_go_idle": "setSystemIdle"
            },
            "code": "\nvoid initializeSystem_0800583c(void)\n\n{\n  writeStep((uint)*(ushort *)(PTR_settings_08005858 + 0x18));\n  wakeUpSystem();\n  setSystemIdle();\n  return;\n}\n\n",
            "called": [
                "st_go_idle",
                "st_wake_up",
                "step_wr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800583c",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "initialize_system_0800583c"
        },
        "FUN_08001e98": {
            "renaming": {
                "FUN_08001e98": "process_movement_08001e98",
                "x": "targetX",
                "y": "targetY",
                "z": "targetZ",
                "feed_rate": "feedRate",
                "invert_feed_rate": "feedRateInverted",
                "uVar1": "isBufferFull",
                "x_00": "currentX",
                "y_00": "currentY",
                "z_00": "currentZ",
                "feed_rate_00": "currentFeedRate"
            },
            "code": "\nvoid processMovement_08001e98(float targetX,float targetY,float targetZ,float feedRate,uint8_t feedRateInverted)\n\n{\n  uint8_t isBufferFull;\n  float currentX;\n  float currentY;\n  float currentZ;\n  float currentFeedRate;\n  \n  if (PTR_stargetYs_08001efc[1] != '\\a') {\n    do {\n      protocol_etargetXecute_runtime();\n      if (*PTR_stargetYs_08001efc != '\\0') {\n        return;\n      }\n      isBufferFull = plan_check_full_buffer();\n    } while (isBufferFull != '\\0');\n    plan_buffer_line(currentX,currentY,currentZ,currentFeedRate,feedRateInverted);\n    if (PTR_stargetYs_08001efc[1] == '\\0') {\n      PTR_stargetYs_08001efc[1] = 2;\n    }\n    if (PTR_stargetYs_08001efc[0targetX10] != '\\0') {\n      st_ctargetYcle_start();\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "plan_check_full_buffer",
                "protocol_execute_runtime",
                "plan_buffer_line",
                "st_cycle_start"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001e98",
            "calling": [
                "mc_arc",
                "gc_execute_line",
                "mc_go_home"
            ],
            "imported": false,
            "current_name": "process_movement_08001e98"
        },
        "FUN_080069e4": {
            "renaming": {
                "FUN_080069e4": "set_interrupt_bit_080069e4",
                "IRQn": "interruptNumber"
            },
            "code": "\nvoid setInterruptBit_080069e4(interruptNumber_Type interruptNumber)\n\n{\n  *(int *)(DAT_08006a14 + (((uint)(int)interruptNumber >> 5) + 0x20) * 4) = 1 << (interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080069e4",
            "calling": [
                "HAL_NVIC_DisableIRQ"
            ],
            "imported": false,
            "current_name": "set_interrupt_bit_080069e4"
        },
        "FUN_0800b2d4": {
            "renaming": {
                "FUN_0800b2d4": "calculate_bitwise_operation_0800b2d4",
                "__value": "inputValue",
                "in_r1": "bitwiseVariable"
            },
            "code": "\nint calculateBitwiseOperation_0800b2d4(double inputValue)\n\n{\n  uint bitwiseVariable;\n  \n  return (bitwiseVariable | 0x80000000) + 0x100000 >> 0x1f;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b2d4",
            "calling": [
                "hypot"
            ],
            "imported": false,
            "current_name": "calculate_bitwise_operation_0800b2d4"
        },
        "FUN_08008e3c": {
            "renaming": {
                "FUN_08008e3c": "calculate_transformed_value_08008e3c",
                "param_1": "input_value",
                "iVar1": "leading_zero_count",
                "uVar2": "adjusted_zero_count",
                "iVar3": "intermediate_result",
                "uVar4": "shifted_value"
            },
            "code": "\nuint calculate_transformed_value_08008e3c(uint input_value)\n\n{\n  int leading_zero_count;\n  uint adjusted_zero_count;\n  int intermediate_result;\n  uint shifted_value;\n  \n  if (input_value == 0) {\n    return 0;\n  }\n  leading_zero_count = count_leading_zeroes(input_value);\n  adjusted_zero_count = leading_zero_count - 8;\n  intermediate_result = adjusted_zero_count * -0x800000 + 0x4a800000;\n  if (7 < leading_zero_count) {\n    shifted_value = 0 << (adjusted_zero_count & 0xff);\n    adjusted_zero_count = intermediate_result + (input_value << (adjusted_zero_count & 0xff)) +\n            (0U >> (0x20 - adjusted_zero_count & 0xff)) + (uint)(0x7fffffff < shifted_value);\n    if (shifted_value == 0x80000000) {\n      adjusted_zero_count = adjusted_zero_count & 0xfffffffe;\n    }\n    return adjusted_zero_count;\n  }\n  shifted_value = input_value << (leading_zero_count + 0x18U & 0xff);\n  adjusted_zero_count = intermediate_result + ((input_value >> (0x20 - (leading_zero_count + 0x18U) & 0xff)) - ((int)shifted_value >> 0x1f));\n  if ((shifted_value & 0x7fffffff) == 0) {\n    adjusted_zero_count = adjusted_zero_count & ~(shifted_value >> 0x1f);\n  }\n  return adjusted_zero_count;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e3c",
            "calling": [
                "calculate_trapezoid_for_block",
                "read_float"
            ],
            "imported": false,
            "current_name": "calculate_transformed_value_08008e3c"
        },
        "FUN_08009654": {
            "renaming": {
                "FUN_08009654": "calculate_result_08009654",
                "__x": "input_value",
                "in_r1": "input_register",
                "iVar1": "shifted_value",
                "in_d0": "output_value"
            },
            "code": "\ndouble calculate_result_08009654(double input_value)\n\n{\n  int input_register;\n  int shifted_value;\n  double output_value;\n  \n  shifted_value = ((uint)(input_register << 1) >> 0x15) - 0x3ff;\n  if (((0x13 < shifted_value) && (0x33 < shifted_value)) && (shifted_value == 0x400)) {\n    output_value = (double)__aeabi_dadd();\n  }\n  return output_value;\n}\n\n",
            "called": [
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009654",
            "calling": [
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "calculate_result_08009654"
        },
        "FUN_08007bc2": {
            "renaming": {
                "FUN_08007bc2": "disable_tim_interrupts_08007bc2",
                "TIMx": "timer"
            },
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid disable_TIM_interrupts_08007bc2(void)\n\n{\n  TIM_TypeDef *timer;\n  \n  _DAT_40000000 = _DAT_40000000 & 0xfffffffe;\n  _DAT_4000000c = _DAT_4000000c & 0xfffffff8;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007bc2",
            "calling": [
                "st_go_idle"
            ],
            "imported": false,
            "current_name": "disable_tim_interrupts_08007bc2"
        },
        "FUN_08009410": {
            "renaming": {
                "FUN_08009410": "calculate_trig_function_08009410",
                "__x": "input_value",
                "in_r0": "input_high",
                "in_r1": "input_low",
                "uVar1": "modulus_result",
                "dVar2": "trig_result",
                "local_28": "local_value1",
                "uStack_24": "local_value2",
                "local_20": "local_value3",
                "uStack_1c": "local_value4"
            },
            "code": "\ndouble calculate_trig_function_08009410(double input_value)\n\n{\n  undefined4 input_high;\n  uint modulus_result;\n  uint input_low;\n  double trig_result;\n  undefined4 local_value1;\n  undefined4 local_value2;\n  undefined4 local_value3;\n  undefined4 local_value4;\n  \n  if (DAT_080094b4 < (int)(input_low & 0x7fffffff)) {\n    if (DAT_080094b8 < (int)(input_low & 0x7fffffff)) {\n      trig_result = (double)__subdf3();\n    }\n    else {\n      modulus_result = __ieee754_rem_pio2(input_high,input_low,&local_value1);\n      modulus_result = modulus_result & 3;\n      if (modulus_result == 1) {\n        trig_result = (double)__kernel_sin(local_value1,local_value2,local_value3,local_value4,1);\n      }\n      else if (modulus_result == 2) {\n        trig_result = (double)__kernel_calculate_trig_function_08009410(local_value1,local_value2,local_value3,local_value4);\n      }\n      else if (modulus_result == 0) {\n        trig_result = (double)__kernel_calculate_trig_function_08009410(local_value1,local_value2,local_value3,local_value4);\n      }\n      else {\n        trig_result = (double)__kernel_sin(local_value1,local_value2,local_value3,local_value4,1);\n      }\n    }\n    return trig_result;\n  }\n  trig_result = (double)__kernel_calculate_trig_function_08009410(input_high,input_low,0,0);\n  return trig_result;\n}\n\n",
            "called": [
                "__kernel_cos",
                "__kernel_sin",
                "__ieee754_rem_pio2",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009410",
            "calling": [
                "mc_arc"
            ],
            "imported": false,
            "current_name": "calculate_trig_function_08009410"
        },
        "FUN_080035ec": {
            "renaming": {
                "FUN_080035ec": "set_xyz_values_080035ec",
                "x": "x_value",
                "y": "y_value",
                "z": "z_value"
            },
            "code": "\nvoid set_xyz_values_080035ec(int32_t x_value,int32_t y_value,int32_t z_value)\n\n{\n  *(int32_t *)PTR_pl_08003614 = x_value;\n  *(int32_t *)(PTR_pl_08003614 + 4) = y_value;\n  *(int32_t *)(PTR_pl_08003614 + 8) = z_value;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035ec",
            "calling": [
                "sys_sync_current_position"
            ],
            "imported": false,
            "current_name": "set_xyz_values_080035ec"
        },
        "FUN_08006c70": {
            "renaming": {
                "FUN_08006c70": "update_control_register_08006c70"
            },
            "code": "\nvoid updateControlRegister_08006c70(void)\n\n{\n  DataSynchronizationBarrier(0xf);\n  *(uint *)(DAT_08006c94 + 0xc) = DAT_08006c98 | *(uint *)(DAT_08006c94 + 0xc) & 0x700;\n  DataSynchronizationBarrier(0xf);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c70",
            "calling": [
                "HAL_NVIC_SystemReset"
            ],
            "imported": false,
            "current_name": "update_control_register_08006c70"
        },
        "FUN_080068bc": {
            "renaming": {
                "FUN_080068bc": "configure_clocks_080068bc",
                "RCC_ClkInitStruct": "clockConfig",
                "pFLatency": "latencyPtr"
            },
            "code": "\nvoid ConfigureClocks_080068bc(RCC_ClkInitTypeDef *clockConfig,uint32_t *latencyPtr)\n\n{\n  clockConfig->ClockType = 0xf;\n  clockConfig->SYSCLKSource = *(uint *)(DAT_08006914 + 8) & 3;\n  clockConfig->AHBCLKDivider = *(uint *)(DAT_08006914 + 8) & 0xf0;\n  clockConfig->APB1CLKDivider = *(uint *)(DAT_08006914 + 8) & 0x1c00;\n  clockConfig->APB2CLKDivider = *(uint *)(DAT_08006914 + 8) >> 3 & 0x1c00;\n  *latencyPtr = *DAT_08006918 & 0xf;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080068bc",
            "calling": [],
            "imported": false,
            "current_name": "configure_clocks_080068bc"
        },
        "FUN_08006944": {
            "renaming": {
                "FUN_08006944": "do_nothing_08006944"
            },
            "code": "\nvoid do_nothing_08006944(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006944",
            "calling": [
                "HAL_RCC_NMI_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08006944"
        },
        "FUN_08006d98": {
            "renaming": {
                "FUN_08006d98": "decode_irq_priority_08006d98",
                "IRQn": "irq_number",
                "PriorityGroup": "priority_group",
                "pPreemptPriority": "preempt_priority_ptr",
                "pSubPriority": "sub_priority_ptr",
                "Priority": "priority_value"
            },
            "code": "\nvoid DecodeIRQPriority_08006d98(irq_number_Type irq_number,uint32_t priority_group,uint32_t *preempt_priority_ptr,\n               uint32_t *sub_priority_ptr)\n\n{\n  uint32_t priority_value;\n  \n  priority_value = NVIC_Getpriority_value(irq_number);\n  NVIC_Decodepriority_value(priority_value,priority_group,preempt_priority_ptr,sub_priority_ptr);\n  return;\n}\n\n",
            "called": [
                "NVIC_DecodePriority",
                "NVIC_GetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d98",
            "calling": [],
            "imported": false,
            "current_name": "decode_irq_priority_08006d98"
        },
        "FUN_08005a68": {
            "renaming": {
                "FUN_08005a68": "increment_tick_counter_08005a68"
            },
            "code": "\nvoid increment_tick_counter_08005a68(void)\n\n{\n  *(int *)PTR_uwTick_08005a80 = *(int *)PTR_uwTick_08005a80 + 1;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a68",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "increment_tick_counter_08005a68"
        },
        "FUN_080079c0": {
            "renaming": {
                "FUN_080079c0": "initialize_debounce_080079c0"
            },
            "code": "\nvoid initializeDebounce_080079c0(void)\n\n{\n  memset(PTR_debounce_080079d8,0,0x18);\n  *(undefined4 *)PTR_debounce_ready_080079dc = 1;\n  return;\n}\n\n",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080079c0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_debounce_080079c0"
        },
        "FUN_0800b2e0": {
            "renaming": {
                "FUN_0800b2e0": "handle_exception_0800b2e0"
            },
            "code": "\nint handle_exception_0800b2e0(exception *__exc)\n\n{\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b2e0",
            "calling": [
                "sqrt",
                "hypot"
            ],
            "imported": false,
            "current_name": "handle_exception_0800b2e0"
        },
        "FUN_08002908": {
            "renaming": {
                "FUN_08002908": "calculate_time_to_reach_final_rate_08002908",
                "in_r0": "initial_rate_squared",
                "in_r1": "final_rate_squared",
                "in_r2": "two_times_distance",
                "in_r3": "acceleration",
                "uVar1": "numerator",
                "uVar2": "denominator",
                "fVar3": "time_to_reach_final_rate"
            },
            "code": "\nfloat calculate_time_to_reach_final_rate_08002908(float initial_rate,float final_rate,float acceleration,float distance)\n\n{\n  undefined4 initial_rate_squared;\n  undefined4 numerator;\n  undefined4 denominator;\n  undefined4 final_rate_squared;\n  undefined4 two_times_distance;\n  undefined4 acceleration;\n  float time_to_reach_final_rate;\n  \n  numerator = __addsf3(two_times_distance,two_times_distance);\n  numerator = __aeabi_fmul(numerator,acceleration);\n  denominator = __aeabi_fmul(initial_rate_squared,initial_rate_squared);\n  numerator = __aeabi_fsub(numerator,denominator);\n  denominator = __aeabi_fmul(final_rate_squared,final_rate_squared);\n  numerator = __addsf3(numerator,denominator);\n  denominator = __aeabi_fmul(two_times_distance,0x40800000);\n  time_to_reach_final_rate = (float)__aeabi_fdiv(numerator,denominator);\n  return time_to_reach_final_rate;\n}\n\n",
            "called": [
                "__aeabi_fsub",
                "__aeabi_fdiv",
                "__addsf3",
                "__aeabi_fmul"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002908",
            "calling": [
                "calculate_trapezoid_for_block"
            ],
            "imported": false,
            "current_name": "calculate_time_to_reach_final_rate_08002908"
        },
        "FUN_08007c40": {
            "renaming": {
                "FUN_08007c40": "set_tick_timer_08007c40",
                "ticks": "timer_ticks"
            },
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid SetTickTimer_08007c40(uint32_t timer_ticks)\n\n{\n  TIM_TypeDef *TIMx;\n  \n  _DAT_40000034 = timer_ticks;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007c40",
            "calling": [
                "st_wake_up"
            ],
            "imported": false,
            "current_name": "set_tick_timer_08007c40"
        },
        "FUN_080094c0": {
            "renaming": {
                "FUN_080094c0": "calculate_result_080094c0",
                "__x": "input_value",
                "in_r0": "input_low",
                "in_r1": "input_high",
                "uVar1": "shifted_value",
                "uVar2": "half_shifted",
                "in_d0": "result",
                "extraout_d0": "comparison_result1",
                "extraout_d0_00": "comparison_result2",
                "extraout_d0_01": "comparison_result3",
                "uVar3": "temp_sum"
            },
            "code": "\ndouble calculate_result_080094c0(double input_value)\n\n{\n  uint input_low;\n  uint input_high;\n  uint shifted_value;\n  uint half_shifted;\n  double result;\n  double comparison_result1;\n  double comparison_result2;\n  double comparison_result3;\n  undefined8 temp_sum;\n  \n  half_shifted = (input_high << 1) >> 0x15;\n  shifted_value = half_shifted - 0x3ff;\n  if ((int)shifted_value < 0x14) {\n    if ((int)shifted_value < 0) {\n      temp_sum = __aeabi_dadd(input_low,input_high,DAT_080095a8,DAT_080095ac);\n      __aeabi_dcmpgt((int)temp_sum,(int)((ulonglong)temp_sum >> 0x20),0,0);\n      result = comparison_result3;\n    }\n    else if ((input_high & DAT_080095b0 >> (shifted_value & 0xff) | input_low) != 0) {\n      temp_sum = __aeabi_dadd(input_low,input_high,DAT_080095a8,DAT_080095ac);\n      __aeabi_dcmpgt((int)temp_sum,(int)((ulonglong)temp_sum >> 0x20),0,0);\n      result = comparison_result1;\n    }\n  }\n  else if ((int)shifted_value < 0x34) {\n    if ((0xffffffffU >> (half_shifted - 0x413 & 0xff) & input_low) != 0) {\n      temp_sum = __aeabi_dadd(input_low,input_high,DAT_080095a8,DAT_080095ac);\n      __aeabi_dcmpgt((int)temp_sum,(int)((ulonglong)temp_sum >> 0x20),0,0);\n      result = comparison_result2;\n    }\n  }\n  else if (shifted_value == 0x400) {\n    result = (double)__aeabi_dadd();\n  }\n  return result;\n}\n\n",
            "called": [
                "__aeabi_dcmpgt",
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080094c0",
            "calling": [
                "mc_arc",
                "calculate_trapezoid_for_block",
                "__kernel_rem_pio2",
                "mc_dwell"
            ],
            "imported": false,
            "current_name": "calculate_result_080094c0"
        },
        "FUN_08008eec": {
            "renaming": {
                "FUN_08008eec": "floating_point_addition_08008eec",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "unusedParam",
                "param_4": "exp1",
                "uVar3": "exp2",
                "lVar1": "product",
                "uVar2": "tempVar",
                "iVar4": "expSum",
                "iVar5": "expDiff",
                "uVar6": "productLow",
                "iVar7": "adjustedExp",
                "uVar8": "result",
                "bVar9": "condition",
                "bVar10": "borrow"
            },
            "code": "\nuint floatingPointAddition_08008eec(uint input1,uint input2,undefined4 unusedParam,uint exp1)\n\n{\n  longlong product;\n  uint tempVar;\n  uint exp2;\n  int expSum;\n  int expDiff;\n  uint productLow;\n  int adjustedExp;\n  uint result;\n  bool condition;\n  bool borrow;\n  \n  exp2 = input1 >> 0x17 & 0xff;\n  condition = exp2 == 0;\n  if (!condition) {\n    exp1 = input2 >> 0x17 & 0xff;\n    condition = exp1 == 0;\n  }\n  if (!condition) {\n    condition = exp2 == 0xff;\n  }\n  if (!condition) {\n    condition = exp1 == 0xff;\n  }\n  if (condition) {\n    exp1 = input2 >> 0x17 & 0xff;\n    if (exp2 == 0xff || exp1 == 0xff) {\n      condition = input1 == 0 || input1 == 0x80000000;\n      tempVar = input2;\n      if (input1 != 0 && input1 != 0x80000000) {\n        condition = input2 == 0;\n        tempVar = input1;\n      }\n      if (!condition) {\n        condition = input2 == 0x80000000;\n      }\n      result = tempVar;\n      if (((condition) || ((exp2 == 0xff && ((tempVar & 0x7fffff) != 0)))) ||\n         ((exp1 == 0xff && (result = input2, (input2 & 0x7fffff) != 0)))) {\n        return result | 0x7fc00000;\n      }\n      tempVar = tempVar ^ input2;\n      goto LAB_0800903c;\n    }\n    condition = (input1 & 0x7fffffff) == 0;\n    if (!condition) {\n      condition = (input2 & 0x7fffffff) == 0;\n    }\n    if (condition) {\n      return (input1 ^ input2) & 0x80000000;\n    }\n    condition = exp2 == 0;\n    tempVar = input1 & 0x80000000;\n    while( true ) {\n      if (condition) {\n        input1 = input1 << 1;\n        condition = (input1 & 0x800000) == 0;\n      }\n      if (!condition) break;\n      exp2 = exp2 - 1;\n    }\n    input1 = input1 | tempVar;\n    condition = exp1 == 0;\n    tempVar = input2 & 0x80000000;\n    while( true ) {\n      if (condition) {\n        input2 = input2 << 1;\n        condition = (input2 & 0x800000) == 0;\n      }\n      if (!condition) break;\n      exp1 = exp1 - 1;\n    }\n    input2 = input2 | tempVar;\n  }\n  expSum = exp2 + exp1;\n  result = input1 ^ input2;\n  exp2 = input1 << 9;\n  condition = exp2 == 0;\n  if (!condition) {\n    input2 = input2 << 9;\n    condition = input2 == 0;\n  }\n  if (condition) {\n    if (exp2 == 0) {\n      input2 = input2 << 9;\n    }\n    tempVar = result & 0x80000000 | input1 & 0x7fffff | input2 >> 9;\n    borrow = SBORROW4(expSum,0x7f);\n    expDiff = expSum + -0x7f;\n    condition = expDiff == 0;\n    adjustedExp = expDiff;\n    if (!condition && 0x7e < expSum) {\n      borrow = SBORROW4(0xff,expDiff);\n      adjustedExp = 0xff - expDiff;\n      condition = expDiff == 0xff;\n    }\n    if (!condition && adjustedExp < 0 == borrow) {\n      tempVar = tempVar | expDiff * 0x800000;\n    }\n    if (!condition && adjustedExp < 0 == borrow) {\n      return tempVar;\n    }\n    tempVar = tempVar | 0x800000;\n    productLow = 0;\n    borrow = SBORROW4(expDiff,1);\n    result = expSum - 0x80;\n    condition = result == 0;\n    exp2 = result;\n  }\n  else {\n    product = (ulonglong)(exp2 >> 5 | 0x8000000) * (ulonglong)(input2 >> 5 | 0x8000000);\n    productLow = (uint)product;\n    tempVar = (uint)((ulonglong)product >> 0x20);\n    condition = tempVar < 0x800000;\n    if (condition) {\n      tempVar = tempVar << 1;\n    }\n    if (condition) {\n      tempVar = tempVar | productLow >> 0x1f;\n      productLow = productLow << 1;\n    }\n    tempVar = result & 0x80000000 | tempVar;\n    result = (expSum + -0x7f) - (uint)condition;\n    borrow = SBORROW4(result,0xfd);\n    condition = result == 0xfd;\n    exp2 = result - 0xfd;\n    if (result < 0xfe) {\n      tempVar = tempVar + result * 0x800000 + (uint)(0x7fffffff < productLow);\n      if (productLow == 0x80000000) {\n        tempVar = tempVar & 0xfffffffe;\n      }\n      return tempVar;\n    }\n  }\n  if (condition || (int)exp2 < 0 != borrow) {\n    condition = (int)(result + 0x19) < 0;\n    if (result == 0xffffffe7 || condition != SCARRY4(result,0x19)) {\n      tempVar = tempVar & 0x80000000;\n    }\n    if (result != 0xffffffe7 && condition == SCARRY4(result,0x19)) {\n      exp2 = (tempVar << 1) >> (-result & 0xff);\n      result = tempVar << (result + 0x20 & 0xff);\n      exp2 = ((uint)((tempVar & 0x80000000) != 0) << 0x1f | exp2 >> 1) + (uint)((byte)exp2 & 1);\n      if ((productLow | result << 1) == 0) {\n        exp2 = exp2 & ~(result >> 0x1f);\n      }\n      return exp2;\n    }\n    return tempVar;\n  }\nLAB_0800903c:\n  return tempVar & 0x80000000 | 0x7f800000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008eec",
            "calling": [
                "printFloat",
                "estimate_acceleration_distance",
                "gc_execute_line",
                "calculate_trapezoid_for_block",
                "mc_go_home",
                "read_float",
                "max_allowable_speed",
                "plan_cycle_reinitialize",
                "mc_arc",
                "homing_cycle",
                "intersection_distance",
                "settings_store_global_setting",
                "plan_buffer_line",
                "mc_dwell"
            ],
            "imported": false,
            "current_name": "floating_point_addition_08008eec"
        },
        "FUN_08006b54": {
            "renaming": {
                "FUN_08006b54": "get_priority_08006b54",
                "IRQn": "irqNumber",
                "bVar1": "priorityByte"
            },
            "code": "\nuint32_t GetPriority_08006b54(irqNumber_Type irqNumber)\n\n{\n  byte priorityByte;\n  \n  if (irqNumber < WWDG_irqNumber) {\n    priorityByte = *(byte *)(((byte)irqNumber & 0xf) + DAT_08006b98 + 0x14);\n  }\n  else {\n    priorityByte = *(byte *)(irqNumber + DAT_08006b9c + 0x300);\n  }\n  return (uint)(priorityByte >> 4);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b54",
            "calling": [
                "HAL_NVIC_GetPriority"
            ],
            "imported": false,
            "current_name": "get_priority_08006b54"
        },
        "FUN_08007e84": {
            "renaming": {
                "FUN_08007e84": "get_serial_data_08007e84",
                "usart": "serial_port"
            },
            "code": "\nchar get_serial_data_08007e84(void)\n\n{\n  USART_TypeDef *serial_port;\n  \n  return (char)*(undefined4 *)(DAT_08007ea0 + 4);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e84",
            "calling": [
                "serial_read"
            ],
            "imported": false,
            "current_name": "get_serial_data_08007e84"
        },
        "FUN_080057e4": {
            "renaming": {
                "FUN_080057e4": "disable_stepper_motor_if_needed_080057e4",
                "step_isr_disable": "disableStepInterrupt"
            },
            "code": "\nvoid disableStepperMotorIfNeeded_080057e4(void)\n\n{\n  disableStepInterrupt();\n  if ((PTR_settings_0800580c[0x3c] != -1) || ((PTR_sys_08005810[2] & 0x20) != 0)) {\n    stepper_motor_disable();\n  }\n  return;\n}\n\n",
            "called": [
                "step_isr_disable",
                "stepper_motor_disable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080057e4",
            "calling": [
                "step_period_isr",
                "limits_go_home",
                "st_init",
                "mc_reset"
            ],
            "imported": false,
            "current_name": "disable_stepper_motor_if_needed_080057e4"
        },
        "FUN_08006d8a": {
            "renaming": {
                "FUN_08006d8a": "get_priority_grouping_08006d8a",
                "uVar1": "priorityGrouping"
            },
            "code": "\nuint32_t getPriorityGrouping_08006d8a(void)\n\n{\n  uint32_t priorityGrouping;\n  \n  priorityGrouping = NVIC_GetPriorityGrouping();\n  return priorityGrouping;\n}\n\n",
            "called": [
                "NVIC_GetPriorityGrouping"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d8a",
            "calling": [],
            "imported": false,
            "current_name": "get_priority_grouping_08006d8a"
        },
        "FUN_0800b2e8": {
            "renaming": {
                "FUN_0800b2e8": "calculate_result_0800b2e8",
                "__x": "input_x",
                "__n": "input_n",
                "in_r1": "temp_r1",
                "in_r2": "temp_r2",
                "uVar1": "temp_uVar1",
                "iVar2": "temp_iVar2",
                "uVar3": "temp_uVar3",
                "in_d0": "temp_d0",
                "extraout_d0": "temp_extraout_d0",
                "dVar4": "temp_dVar4",
                "uVar5": "temp_uVar5"
            },
            "code": "\ndouble calculate_result_0800b2e8(double input_x,int input_n)\n\n{\n  uint temp_r1;\n  int temp_r2;\n  uint temp_uVar1;\n  int temp_iVar2;\n  uint temp_uVar3;\n  double temp_d0;\n  double temp_extraout_d0;\n  double temp_dVar4;\n  ulonglong temp_uVar5;\n  \n  temp_uVar5 = CONCAT44(temp_r1,input_n);\n  temp_uVar1 = (temp_r1 << 1) >> 0x15;\n  if (temp_uVar1 == 0) {\n    if ((input_n | temp_r1 & 0x7fffffff) == 0) {\n      return temp_d0;\n    }\n    temp_uVar5 = __muldf3(input_n,temp_r1,0,DAT_0800b3c8);\n    if (temp_r2 < DAT_0800b3cc) goto LAB_0800b34a;\n    temp_uVar1 = ((uint)((int)(temp_uVar5 >> 0x20) << 1) >> 0x15) - 0x36;\n    temp_d0 = temp_extraout_d0;\n  }\n  else if (temp_uVar1 == 0x7ff) {\n    temp_dVar4 = (double)__aeabi_dadd(input_n,temp_r1,input_n);\n    return temp_dVar4;\n  }\n  temp_uVar3 = (uint)(temp_uVar5 >> 0x20);\n  temp_iVar2 = temp_uVar1 + temp_r2;\n  if (temp_iVar2 < 0x7ff) {\n    if (0 < temp_iVar2) {\n      return temp_d0;\n    }\n    if (temp_iVar2 + 0x35 < 0 == SCARRY4(temp_iVar2,0x35)) {\n      temp_dVar4 = (double)__muldf3((int)temp_uVar5,temp_uVar3 & 0x800fffff | (temp_iVar2 + 0x36) * 0x100000,0,\n                               DAT_0800b3d8);\n      return temp_dVar4;\n    }\n    if (temp_r2 < 0xc351) {\n      temp_uVar5 = temp_uVar5 & 0x8000000000000000 | (ulonglong)DAT_0800b3d0 | 0x1a56e1f00000000;\nLAB_0800b34a:\n      temp_dVar4 = (double)__muldf3((int)temp_uVar5,(int)(temp_uVar5 >> 0x20),DAT_0800b3b8,DAT_0800b3bc);\n      return temp_dVar4;\n    }\n  }\n  temp_dVar4 = (double)__muldf3(DAT_0800b3d4,temp_uVar3 & 0x80000000 | 0x7e37e43c,DAT_0800b3c0,DAT_0800b3c4);\n  return temp_dVar4;\n}\n\n",
            "called": [
                "__muldf3",
                "__aeabi_dadd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b2e8",
            "calling": [
                "__kernel_rem_pio2"
            ],
            "imported": false,
            "current_name": "calculate_result_0800b2e8"
        },
        "FUN_08005220": {
            "renaming": {
                "FUN_08005220": "do_nothing_08005220"
            },
            "code": "\nvoid do_nothing_08005220(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005220",
            "calling": [
                "spindle_run"
            ],
            "imported": false,
            "current_name": "do_nothing_08005220"
        },
        "FUN_08007520": {
            "renaming": {
                "FUN_08007520": "clear_gpio_if_bit_set_08007520",
                "bits": "inputBits"
            },
            "code": "\nvoid clearGpioIfBitSet_08007520(uint32_t inputBits)\n\n{\n  if ((inputBits & 1) != 0) {\n    gpio_clr(0x3e);\n  }\n  return;\n}\n\n",
            "called": [
                "gpio_clr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007520",
            "calling": [
                "debounce_isr"
            ],
            "imported": false,
            "current_name": "clear_gpio_if_bit_set_08007520"
        },
        "FUN_08007884": {
            "renaming": {
                "FUN_08007884": "merge_gpio_values_08007884",
                "iVar1": "gpioValue1",
                "iVar2": "gpioValue2",
                "iVar3": "gpioValue3",
                "iVar4": "gpioValue4",
                "iVar5": "gpioValue5",
                "uVar6": "gpioValue6"
            },
            "code": "\nuint32_t mergeGpioValues_08007884(void)\n\n{\n  int gpioValue1;\n  int gpioValue2;\n  int gpioValue3;\n  int gpioValue4;\n  int gpioValue5;\n  uint gpioValue6;\n  \n  gpioValue1 = gpio_rd(0x36);\n  gpioValue2 = gpio_rd(0x37);\n  gpioValue3 = gpio_rd(0x38);\n  gpioValue4 = gpio_rd(0x39);\n  gpioValue5 = gpio_rd(0xf);\n  gpioValue6 = gpio_rd(0);\n  return gpioValue6 | gpioValue1 << 4 | gpioValue2 << 3 | gpioValue3 << 2 | gpioValue4 << 1 | gpioValue5 << 7;\n}\n\n",
            "called": [
                "gpio_rd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007884",
            "calling": [
                "debounce_isr"
            ],
            "imported": false,
            "current_name": "merge_gpio_values_08007884"
        },
        "FUN_08004250": {
            "renaming": {
                "FUN_08004250": "print_machine_settings_08004250",
                "n": "x_step_mm",
                "n_00": "y_step_mm",
                "n_01": "z_step_mm",
                "n_02": "step_pulse_usec",
                "n_03": "default_feed_mm_min",
                "n_04": "default_seek_mm_min",
                "n_05": "acceleration_mm_sec2",
                "n_06": "junction_deviation_mm",
                "n_07": "homing_feed_mm_min",
                "n_08": "homing_seek_mm_min",
                "n_09": "homing_pull_off_mm"
            },
            "code": "\nvoid printMachineSettings_08004250(void)\n\n{\n  float x_step_mm;\n  float y_step_mm;\n  float z_step_mm;\n  float step_pulse_usec;\n  float default_feed_mm_min;\n  float default_seek_mm_min;\n  float acceleration_mm_sec2;\n  float junction_deviation_mm;\n  float homing_feed_mm_min;\n  float homing_seek_mm_min;\n  float homing_pull_off_mm;\n  \n  prix_step_mmtPgmStrix_step_mmg(PTR_DAT_08004470);\n  prix_step_mmtFloat(x_step_mm);\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___x__step_mm___1__08004478);\n  prix_step_mmtFloat(y_step_mm);\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___y__step_mm___2__0800447c);\n  prix_step_mmtFloat(z_step_mm);\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___z__step_mm___3__08004480);\n  prix_step_mmtIx_step_mmteger((uix_step_mmt)(byte)PTR_settix_step_mmgs_08004474[0xd]);\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___step_pulse__usec___4__08004484);\n  prix_step_mmtFloat(step_pulse_usec);\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___default_feed__mm_mix_step_mm___5__08004488);\n  prix_step_mmtFloat(default_feed_mm_min);\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___default_seek__mm_mix_step_mm___6__0800448c);\n  prix_step_mmtIx_step_mmteger((uix_step_mmt)*(ushort *)(PTR_settix_step_mmgs_08004474 + 0x18));\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___step_port_ix_step_mmvert_mask__ix_step_mmt__08004490);\n  prix_step_mmt_uix_step_mmt16_base2(*(uix_step_mmt16_t *)(PTR_settix_step_mmgs_08004474 + 0x18));\n  prix_step_mmtPgmStrix_step_mmg(PTR_s____7__08004494);\n  prix_step_mmtIx_step_mmteger((uix_step_mmt)(byte)PTR_settix_step_mmgs_08004474[0x3c]);\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___step_idle_delay__msec___8__08004498);\n  default_seek_mm_min = (float)__aeabi_fdiv(*(ux_step_mmdefix_step_mmed4 *)(PTR_settix_step_mmgs_08004474 + 0x20),DAT_0800449c);\n  prix_step_mmtFloat(default_seek_mm_min);\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___acceleratiox_step_mm__mm_sec_2___9__080044a0);\n  prix_step_mmtFloat(acceleration_mm_sec2);\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___jux_step_mmctiox_step_mm_deviatiox_step_mm__mm___10__080044a4);\n  prix_step_mmtFloat(junction_deviation_mm);\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___arc__mm_segmex_step_mmt___11__080044a8);\n  prix_step_mmtIx_step_mmteger((uix_step_mmt)(byte)PTR_settix_step_mmgs_08004474[0x3e]);\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___x_step_mm_arc_correctiox_step_mm__ix_step_mmt___12__080044ac);\n  prix_step_mmtIx_step_mmteger((uix_step_mmt)(byte)PTR_settix_step_mmgs_08004474[0x3d]);\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___x_step_mm_decimals__ix_step_mmt___13__080044b0);\n  prix_step_mmtIx_step_mmteger((uix_step_mmt)((PTR_settix_step_mmgs_08004474[0x28] & 1) != 0));\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___report_ix_step_mmches__bool___14__080044b4);\n  prix_step_mmtIx_step_mmteger((uix_step_mmt)((PTR_settix_step_mmgs_08004474[0x28] & 2) != 0));\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___auto_start__bool___15__080044b8);\n  prix_step_mmtIx_step_mmteger((uix_step_mmt)((PTR_settix_step_mmgs_08004474[0x28] & 4) != 0));\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___ix_step_mmvert_step_ex_step_mmable__bool___16__080044bc);\n  prix_step_mmtIx_step_mmteger((uix_step_mmt)((PTR_settix_step_mmgs_08004474[0x28] & 8) != 0));\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___hard_limits__bool___17__080044c0);\n  prix_step_mmtIx_step_mmteger((uix_step_mmt)((PTR_settix_step_mmgs_08004474[0x28] & 0x10) != 0));\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___homix_step_mmg_cycle__bool___18__080044c4);\n  prix_step_mmtIx_step_mmteger((uix_step_mmt)*(ushort *)(PTR_settix_step_mmgs_08004474 + 0x2a));\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___homix_step_mmg_dir_ix_step_mmvert_mask__ix_step_mmt__080044c8);\n  prix_step_mmt_uix_step_mmt16_base2(*(uix_step_mmt16_t *)(PTR_settix_step_mmgs_08004474 + 0x2a));\n  prix_step_mmtPgmStrix_step_mmg(PTR_s____19__080044cc);\n  prix_step_mmtFloat(homing_feed_mm_min);\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___homix_step_mmg_feed__mm_mix_step_mm___20__080044d0);\n  prix_step_mmtFloat(homing_seek_mm_min);\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___homix_step_mmg_seek__mm_mix_step_mm___21__080044d4);\n  prix_step_mmtIx_step_mmteger((uix_step_mmt)*(ushort *)(PTR_settix_step_mmgs_08004474 + 0x34));\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___homix_step_mmg_deboux_step_mmce__msec___22__080044d8);\n  prix_step_mmtFloat(homing_pull_off_mm);\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___homix_step_mmg_pull_off__mm___23__080044dc);\n  prix_step_mmtIx_step_mmteger((uix_step_mmt)*(ushort *)(PTR_settix_step_mmgs_08004474 + 0x1a));\n  prix_step_mmtPgmStrix_step_mmg(PTR_s___dir_port_ix_step_mmvert_mask__ix_step_mmt__080044e0);\n  prix_step_mmt_uix_step_mmt16_base2(*(uix_step_mmt16_t *)(PTR_settix_step_mmgs_08004474 + 0x1a));\n  prix_step_mmtPgmStrix_step_mmg(PTR_DAT_080044e4);\n  returx_step_mm;\n}\n\n",
            "called": [
                "printInteger",
                "__aeabi_fdiv",
                "printFloat",
                "print_uint16_base2",
                "printPgmString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004250",
            "calling": [
                "settings_init",
                "protocol_execute_line"
            ],
            "imported": false,
            "current_name": "print_machine_settings_08004250"
        },
        "FUN_08006dc4": {
            "renaming": {
                "FUN_08006dc4": "set_pending_irq_08006dc4",
                "IRQn": "irqNumber"
            },
            "code": "\nvoid setPendingIRQ_08006dc4(irqNumber_Type irqNumber)\n\n{\n  NVIC_SetPendingIRQ(irqNumber);\n  return;\n}\n\n",
            "called": [
                "NVIC_SetPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006dc4",
            "calling": [],
            "imported": false,
            "current_name": "set_pending_irq_08006dc4"
        },
        "FUN_08007402": {
            "renaming": {
                "FUN_08007402": "set_bit_in_memory_08007402",
                "n": "bitPosition"
            },
            "code": "\nvoid setBitInMemory_08007402(ibitPositiont bitPosition)\n\n{\n  *(short *)((bitPosition >> 4) * 0x400 + 0x40020018) = (short)(1 << (bitPosition & 0xfU));\n  returbitPosition;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007402",
            "calling": [
                "debounce_on_handler"
            ],
            "imported": false,
            "current_name": "set_bit_in_memory_08007402"
        },
        "FUN_08002870": {
            "renaming": {
                "FUN_08002870": "increment_block_index_08002870",
                "local_9": "next_block_index"
            },
            "code": "\nuint8_t increment_block_index_08002870(uint8_t block_index)\n\n{\n  uint8_t next_block_index;\n  \n  next_block_index = block_index + '\\x01';\n  if (next_block_index == '\\x12') {\n    next_block_index = '\\0';\n  }\n  return next_block_index;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002870",
            "calling": [
                "plan_reset_buffer",
                "planner_forward_pass",
                "planner_recalculate_trapezoids",
                "plan_buffer_line",
                "plan_discard_current_block"
            ],
            "imported": false,
            "current_name": "increment_block_index_08002870"
        },
        "FUN_08000210": {
            "renaming": {
                "FUN_08000210": "disable_coolant_system_08000210"
            },
            "code": "\nvoid disable_coolant_system_08000210(void)\n\n{\n  coolant_mist_off();\n  coolant_flood_off();\n  return;\n}\n\n",
            "called": [
                "coolant_mist_off",
                "coolant_flood_off"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000210",
            "calling": [
                "coolant_run",
                "mc_reset",
                "coolant_init"
            ],
            "imported": false,
            "current_name": "disable_coolant_system_08000210"
        },
        "FUN_08008a64": {
            "renaming": {
                "FUN_08008a64": "compare_and_combine_08008a64",
                "param_1": "value_a1",
                "param_2": "value_a2",
                "param_3": "value_b1",
                "param_4": "value_b2",
                "uVar1": "xor_result",
                "bVar2": "comparison_result",
                "bVar3": "final_condition"
            },
            "code": "\nuint compare_and_combine_08008a64(uint value_a1,uint value_a2,uint value_b1,uint value_b2)\n\n{\n  uint xor_result;\n  bool comparison_result;\n  bool final_condition;\n  \n  if (((int)(value_a2 << 1) >> 0x15 == -1 || (int)(value_b2 << 1) >> 0x15 == -1) &&\n     ((((int)(value_a2 << 1) >> 0x15 == -1 && ((value_a1 | value_a2 << 0xc) != 0)) ||\n      (((int)(value_b2 << 1) >> 0x15 == -1 && ((value_b1 | value_b2 << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  comparison_result = (value_a1 | value_a2 << 1) == 0;\n  if (comparison_result) {\n    comparison_result = (value_b1 | value_b2 << 1) == 0;\n  }\n  if (!comparison_result) {\n    comparison_result = value_a2 == value_b2;\n  }\n  if (comparison_result) {\n    comparison_result = value_a1 == value_b1;\n  }\n  if (!comparison_result) {\n    xor_result = value_a2 ^ value_b2;\n    comparison_result = xor_result == 0;\n    if (-1 < (int)xor_result) {\n      comparison_result = value_a2 == value_b2;\n    }\n    final_condition = -1 < (int)xor_result && value_b2 <= value_a2;\n    if (comparison_result) {\n      final_condition = value_b1 <= value_a1;\n    }\n    value_b2 = (int)value_b2 >> 0x1f;\n    if (!final_condition) {\n      value_b2 = ~value_b2;\n    }\n    return value_b2 | 1;\n  }\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a64",
            "calling": [],
            "imported": false,
            "current_name": "compare_and_combine_08008a64"
        },
        "FUN_08005900": {
            "renaming": {
                "FUN_08005900": "process_data_08005900",
                "data": "inputData",
                "rc": "result"
            },
            "code": "\nint processData_08005900(uint8_t inputData)\n\n{\n  int result;\n  \n  if (inputData == '~') {\n    PTR_sys_08005978[2] = PTR_sys_08005978[2] | 2;\n    return 1;\n  }\n  if (inputData < 0x7f) {\n    if (inputData == '?') {\n      PTR_sys_08005978[2] = PTR_sys_08005978[2] | 1;\n      return 1;\n    }\n    if (inputData < 0x40) {\n      if (inputData == '\\x18') {\n        mc_reset();\n        return 1;\n      }\n      if (inputData == '!') {\n        PTR_sys_08005978[2] = PTR_sys_08005978[2] | 8;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "mc_reset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005900",
            "calling": [
                "serial_read"
            ],
            "imported": false,
            "current_name": "process_data_08005900"
        },
        "FUN_08002638": {
            "renaming": {
                "FUN_08002638": "parse_float_from_string_08002638",
                "line": "input_str",
                "char_counter": "char_idx",
                "float_ptr": "float_result",
                "bVar1": "char_diff",
                "bVar2": "is_negative",
                "bVar3": "has_decimal_point",
                "puVar4": "next_char_ptr",
                "puVar5": "current_char_ptr",
                "iVar6": "return_value",
                "uVar7": "double_temp",
                "fval": "float_value",
                "isdecimal": "has_decimal_point",
                "ndigit": "num_digits",
                "exp": "exponent",
                "intval": "integer_value",
                "isnegative": "is_negative",
                "ptr": "char_ptr"
            },
            "code": "\nint parse_float_from_string_08002638(char *input_str,uint8_t *char_idx,float *float_result)\n\n{\n  byte char_diff;\n  bool is_negative;\n  bool has_decimal_point;\n  uchar *next_char_ptr;\n  uchar *current_char_ptr;\n  int return_value;\n  undefined8 double_temp;\n  float float_value;\n  _Bool has_decimal_point;\n  uint8_t num_digits;\n  int8_t exponent;\n  uint32_t integer_value;\n  _Bool is_negative;\n  uchar c;\n  char *char_ptr;\n  \n  current_char_ptr = (uchar *)(input_str + *char_idx);\n  next_char_ptr = current_char_ptr + 1;\n  c = *current_char_ptr;\n  is_negative = false;\n  if (c == '-') {\n    is_negative = true;\n    c = *next_char_ptr;\n    char_ptr = (char *)(current_char_ptr + 2);\n  }\n  else {\n    char_ptr = (char *)next_char_ptr;\n    if (c == '+') {\n      char_ptr = (char *)(current_char_ptr + 2);\n      c = *next_char_ptr;\n    }\n  }\n  integer_value = 0;\n  exponent = '\\0';\n  num_digits = '\\0';\n  has_decimal_point = false;\n  do {\n    char_diff = c - 0x30;\n    if (char_diff < 10) {\n      num_digits = num_digits + 1;\n      if (num_digits < 9) {\n        if (has_decimal_point) {\n          exponent = exponent + -1;\n        }\n        integer_value = (uint)char_diff + integer_value * 10;\n      }\n      else if (!has_decimal_point) {\n        exponent = exponent + '\\x01';\n      }\n    }\n    else {\n      if ((char_diff != 0xfe) || (has_decimal_point)) {\n        if (num_digits == '\\0') {\n          return_value = 0;\n        }\n        else {\n          float_value = (float)__floatunsisf(integer_value);\n          return_value = __aeabi_fcmpeq(float_value,0);\n          if (return_value == 0) {\n            for (; exponent < -1; exponent = exponent + '\\x02') {\n              double_temp = __aeabi_f2d(float_value);\n              double_temp = __muldf3((int)double_temp,(int)((ulonglong)double_temp >> 0x20),DAT_08002800,DAT_08002804)\n              ;\n              float_value = (float)__truncdfsf2((int)double_temp,(int)((ulonglong)double_temp >> 0x20));\n            }\n            if (exponent < '\\0') {\n              double_temp = __aeabi_f2d(float_value);\n              double_temp = __muldf3((int)double_temp,(int)((ulonglong)double_temp >> 0x20),DAT_08002808,DAT_0800280c)\n              ;\n              float_value = (float)__truncdfsf2((int)double_temp,(int)((ulonglong)double_temp >> 0x20));\n            }\n            else {\n              for (; '\\0' < exponent; exponent = exponent + -1) {\n                float_value = (float)__aeabi_fmul(float_value,DAT_08002810);\n              }\n            }\n          }\n          if (is_negative) {\n            *float_result = (float)((uint)float_value ^ 0x80000000);\n          }\n          else {\n            *float_result = float_value;\n          }\n          *char_idx = ((char)char_ptr - (char)input_str) + 0xff;\n          return_value = 1;\n        }\n        return return_value;\n      }\n      has_decimal_point = true;\n    }\n    c = *char_ptr;\n    char_ptr = char_ptr + 1;\n  } while( true );\n}\n\n",
            "called": [
                "__floatunsisf",
                "__aeabi_fcmpeq",
                "__aeabi_fmul",
                "__muldf3",
                "__truncdfsf2",
                "__aeabi_f2d"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002638",
            "calling": [
                "protocol_execute_line",
                "next_statement"
            ],
            "imported": false,
            "current_name": "parse_float_from_string_08002638"
        },
        "FUN_08005bac": {
            "renaming": {
                "FUN_08005bac": "set_flag_08005bac"
            },
            "code": "\nvoid setFlag_08005bac(void)\n\n{\n  *DAT_08005bc0 = 1;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005bac",
            "calling": [],
            "imported": false,
            "current_name": "set_flag_08005bac"
        },
        "FUN_080051b4": {
            "renaming": {
                "FUN_080051b4": "process_coordinate_settings_080051b4",
                "uVar1": "status",
                "coord_data": "coordinateData",
                "i": "index"
            },
            "code": "\nvoindexd processCoordinateSettings_080051b4(voindexd)\n\n{\n  uindexnt8_t status;\n  float coordinateData [3];\n  uindexnt8_t index;\n  \n  status = read_global_settindexngs();\n  indexf (status == '\\0') {\n    report_status_message('\\n');\n    settindexngs_reset(true);\n    report_grbl_settindexngs();\n  }\n  for (index = '\\0'; index < 8; index = index + '\\x01') {\n    status = settindexngs_read_coordinateData(index,coordinateData);\n    indexf (status == '\\0') {\n      report_status_message('\\n');\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "report_status_message",
                "read_global_settings",
                "settings_read_coord_data",
                "settings_reset",
                "report_grbl_settings"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080051b4",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "process_coordinate_settings_080051b4"
        },
        "FUN_080098d0": {
            "renaming": {
                "FUN_080098d0": "calculate_special_value_080098d0",
                "__x": "input_value",
                "cVar1": "fdlib_version",
                "iVar2": "compare_result",
                "puVar3": "error_ptr",
                "piVar4": "error_int_ptr",
                "dVar5": "result",
                "extraout_d0": "temp_result1",
                "extraout_d0_00": "temp_result2",
                "extraout_d0_01": "temp_result3",
                "extraout_d0_02": "temp_result4",
                "extraout_d0_03": "temp_result5",
                "local_50": "local_exception",
                "local_38": "local_division",
                "local_30": "local_errno"
            },
            "code": "\n/* WARNING: Could not reconcile some variable overlaps */\n\ndouble calculate_special_value_080098d0(double input_value)\n\n{\n  char fdlib_version;\n  int compare_result;\n  undefined4 *error_ptr;\n  int *error_int_ptr;\n  double result;\n  double temp_result1;\n  double temp_result2;\n  double temp_result3;\n  double temp_result4;\n  double temp_result5;\n  undefined local_exception [24];\n  undefined8 local_division;\n  int local_errno;\n  \n  result = (double)__ieee754_calculate_special_value_080098d0();\n  fdlib_version = *PTR___fdlib_version_08009988;\n  if (((fdlib_version == -1) || (local_errno = __unorddf2(), result = temp_result1, local_errno != 0)) ||\n     (compare_result = __aeabi_dcmplt(), result = temp_result2, compare_result == 0)) {\n    return result;\n  }\n  local_exception._0_4_ = 1;\n  local_exception._4_4_ = PTR_DAT_0800998c;\n  if (fdlib_version == '\\0') {\n    local_division = 0.0;\nLAB_0800996c:\n    compare_result = matherr((exception *)local_exception);\n    result = temp_result4;\n    if (compare_result != 0) goto joined_r0x0800997a;\n  }\n  else {\n    local_division = (double)__divdf3(0,0,0,0);\n    if (fdlib_version != '\\x02') goto LAB_0800996c;\n  }\n  error_ptr = (undefined4 *)__errno();\n  *error_ptr = 0x21;\n  result = temp_result3;\njoined_r0x0800997a:\n  if (local_errno != 0) {\n    error_int_ptr = (int *)__errno();\n    *error_int_ptr = local_errno;\n    result = temp_result5;\n  }\n  return result;\n}\n\n",
            "called": [
                "__ieee754_sqrt",
                "__divdf3",
                "__aeabi_dcmplt",
                "__unorddf2",
                "__errno",
                "matherr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080098d0",
            "calling": [
                "max_allowable_speed",
                "homing_cycle",
                "gc_execute_line",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "calculate_special_value_080098d0"
        },
        "FUN_08005c30": {
            "renaming": {
                "FUN_08005c30": "configure_sys_tick_08005c30",
                "ticks": "tickInterval",
                "bVar1": "isValidInterval"
            },
            "code": "\nuint32_t configureSysTick_08005c30(uint32_t tickInterval)\n\n{\n  bool isValidInterval;\n  \n  isValidInterval = tickInterval - 1 < 0x1000000;\n  if (isValidInterval) {\n    DAT_08005c70[1] = tickInterval - 1;\n    NVIC_SetPriority(SysTick_IRQn,0xf);\n    DAT_08005c70[2] = 0;\n    *DAT_08005c70 = 7;\n  }\n  return (uint)!isValidInterval;\n}\n\n",
            "called": [
                "NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005c30",
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "imported": false,
            "current_name": "configure_sys_tick_08005c30"
        },
        "FUN_0800b51c": {
            "renaming": {
                "FUN_0800b51c": "do_nothing_0800b51c"
            },
            "code": "\nvoid do_nothing_0800b51c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b51c",
            "calling": [
                "__register_exitproc"
            ],
            "imported": false,
            "current_name": "do_nothing_0800b51c"
        },
        "FUN_0800056c": {
            "renaming": {
                "FUN_0800056c": "calculate_transformed_value_0800056c",
                "value": "input_value",
                "in_r0": "input_double",
                "uVar1": "intermediate_result"
            },
            "code": "\nfloat calculate_transformed_value_0800056c(float input_value)\n\n{\n  undefined4 input_double;\n  undefined8 intermediate_result;\n  \n  if (PTR_gc_080005b0[3] != '\\0') {\n    intermediate_result = __aeabi_f2d(input_double);\n    intermediate_result = __muldf3((int)intermediate_result,(int)((ulonglong)intermediate_result >> 0x20),DAT_080005a8,DAT_080005ac);\n    input_value = (float)__truncdfsf2((int)intermediate_result,(int)((ulonglong)intermediate_result >> 0x20));\n  }\n  return input_value;\n}\n\n",
            "called": [
                "__muldf3",
                "__truncdfsf2",
                "__aeabi_f2d"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800056c",
            "calling": [
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "calculate_transformed_value_0800056c"
        },
        "FUN_08002f24": {
            "renaming": {
                "FUN_08002f24": "initialize_plan_buffer_08002f24"
            },
            "code": "\nvoid initialize_plan_buffer_08002f24(void)\n\n{\n  plan_reset_buffer();\n  memset(PTR_pl_08002f3c,0,0x1c);\n  return;\n}\n\n",
            "called": [
                "plan_reset_buffer",
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f24",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "initialize_plan_buffer_08002f24"
        },
        "FUN_0800981c": {
            "renaming": {
                "FUN_0800981c": "calculate_result_0800981c",
                "__x": "input_x",
                "__y": "input_y",
                "cVar1": "char_var",
                "puVar2": "lib_version_ptr",
                "iVar3": "is_finite",
                "puVar4": "errno_ptr",
                "dVar5": "result",
                "extraout_d0": "extra_output_d0",
                "extraout_d0_00": "extra_output_d0_00",
                "extraout_d0_01": "extra_output_d0_01",
                "extraout_d0_02": "extra_output_d0_02",
                "extraout_d0_03": "extra_output_d0_03",
                "in_stack_ffffffb0": "stack_var_b0",
                "in_stack_ffffffb4": "stack_var_b4"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080098b6) */\n\ndouble calculate_result_0800981c(double input_x,double input_y)\n\n{\n  char char_var;\n  undefined *lib_version_ptr;\n  int is_finite;\n  undefined4 *errno_ptr;\n  double result;\n  double extra_output_d0;\n  double extra_output_d0_00;\n  double extra_output_d0_01;\n  double extra_output_d0_02;\n  double extra_output_d0_03;\n  int stack_var_b0;\n  char *stack_var_b4;\n  \n  lib_version_ptr = PTR___fdlib_version_080098cc;\n  result = (double)__ieee754_calculate_result_0800981c();\n  if ((((*lib_version_ptr != -1) &&\n       (is_finite = finite((double)CONCAT44(stack_var_b4,stack_var_b0)), result = extra_output_d0,\n       is_finite == 0)) &&\n      (is_finite = finite((double)CONCAT44(stack_var_b4,stack_var_b0)), result = extra_output_d0_00\n      , is_finite != 0)) &&\n     ((is_finite = finite((double)CONCAT44(stack_var_b4,stack_var_b0)), result = extra_output_d0_01\n      , is_finite != 0 &&\n      (((char_var = *lib_version_ptr, char_var != '\\0' && (char_var == '\\x02')) ||\n       (is_finite = matherr((exception *)&stack0xffffffb0), result = extra_output_d0_03, is_finite == 0)))))) {\n    errno_ptr = (undefined4 *)__errno();\n    *errno_ptr = 0x22;\n    result = extra_output_d0_02;\n  }\n  return result;\n}\n\n",
            "called": [
                "__ieee754_hypot",
                "finite",
                "__errno",
                "matherr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800981c",
            "calling": [
                "mc_arc",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "calculate_result_0800981c"
        },
        "FUN_080059b4": {
            "renaming": {
                "FUN_080059b4": "initialize_system_080059b4",
                "HAL_StatusTypeDef": "SystemStatus"
            },
            "code": "\nSystemStatus InitializeSystem_080059b4(void)\n\n{\n  *DAT_080059f4 = *DAT_080059f4 | 0x200;\n  *DAT_080059f4 = *DAT_080059f4 | 0x400;\n  *DAT_080059f4 = *DAT_080059f4 | 0x100;\n  HAL_SYSTICK_Config(16000);\n  HAL_NVIC_SetPriorityGrouping(3);\n  HAL_MspInit();\n  return HAL_OK;\n}\n\n",
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_SYSTICK_Config"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080059b4",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_system_080059b4"
        },
        "FUN_08006c04": {
            "renaming": {
                "FUN_08006c04": "calculate_priorities_08006c04",
                "Priority": "priority",
                "PriorityGroup": "priorityGroup",
                "pPreemptPriority": "preemptPriorityPtr",
                "pSubPriority": "subPriorityPtr",
                "uVar1": "priorityGroupBits",
                "uVar2": "preemptPriorityBits",
                "SubPriorityBits": "subPriorityBits",
                "PreemptPriorityBits": "preemptPriorityBits",
                "PriorityGroupTmp": "priorityGroupTmp"
            },
            "code": "\nvoid calculatePriorities_08006c04(uint32_t priority,uint32_t priorityGroup,uint32_t *preemptPriorityPtr,\n                        uint32_t *subPriorityPtr)\n\n{\n  uint priorityGroupBits;\n  uint preemptPriorityBits;\n  uint32_t subPriorityBits;\n  uint32_t preemptPriorityBits;\n  uint32_t priorityGroupTmp;\n  \n  priorityGroupBits = priorityGroup & 7;\n  preemptPriorityBits = 7 - priorityGroupBits;\n  if (3 < preemptPriorityBits) {\n    preemptPriorityBits = 4;\n  }\n  if (priorityGroupBits + 4 < 7) {\n    priorityGroupBits = 0;\n  }\n  else {\n    priorityGroupBits = priorityGroupBits - 3;\n  }\n  *preemptPriorityPtr = (1 << (preemptPriorityBits & 0xff)) - 1U & priority >> (priorityGroupBits & 0xff);\n  *subPriorityPtr = (1 << (priorityGroupBits & 0xff)) - 1U & priority;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c04",
            "calling": [
                "HAL_NVIC_GetPriority"
            ],
            "imported": false,
            "current_name": "calculate_priorities_08006c04"
        },
        "FUN_08002e08": {
            "renaming": {
                "FUN_08002e08": "update_block_trapezoids_08002e08",
                "pbVar1": "current_block_ptr",
                "uVar2": "temp_div_result",
                "current": "current_block",
                "next": "next_block",
                "block_index": "block_idx"
            },
            "code": "\nvoid update_block_trapezoids_08002e08(void)\n\n{\n  block_t *current_block_ptr;\n  undefined8 temp_div_result;\n  block_t *current_block;\n  block_t *next_block;\n  uint8_t block_idx;\n  \n  block_idx = *PTR_block_buffer_tail_08002ed0;\n  next_block = (block_t *)0x0;\n  while (block_idx != *PTR_block_buffer_head_08002ed8) {\n    current_block_ptr = (block_t *)(PTR_block_buffer_08002ed4 + (uint)block_idx * 0x40);\n    if ((next_block != (block_t *)0x0) &&\n       ((next_block->recalculate_flag != '\\0' || (current_block_ptr->recalculate_flag != '\\0')))) {\n      __aeabi_fdiv(next_block->entry_speed,next_block->nominal_speed);\n      temp_div_result = __aeabi_fdiv(current_block_ptr->entry_speed,next_block->nominal_speed);\n      calculate_trapezoid_for_block(next_block,(float)temp_div_result,(float)((ulonglong)temp_div_result >> 0x20));\n      next_block->recalculate_flag = '\\0';\n    }\n    block_idx = next_block_block_idx(block_idx);\n    next_block = current_block_ptr;\n  }\n  __aeabi_fdiv(next_block->entry_speed,next_block->nominal_speed);\n  temp_div_result = __aeabi_fdiv(0,next_block->nominal_speed);\n  calculate_trapezoid_for_block(next_block,(float)temp_div_result,(float)((ulonglong)temp_div_result >> 0x20));\n  next_block->recalculate_flag = '\\0';\n  return;\n}\n\n",
            "called": [
                "__aeabi_fdiv",
                "next_block_index",
                "calculate_trapezoid_for_block"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002e08",
            "calling": [
                "planner_recalculate"
            ],
            "imported": false,
            "current_name": "update_block_trapezoids_08002e08"
        },
        "FUN_08005bc4": {
            "renaming": {
                "FUN_08005bc4": "reset_memory_08005bc4"
            },
            "code": "\nvoid resetMemory_08005bc4(void)\n\n{\n  *DAT_08005bd8 = 0;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005bc4",
            "calling": [],
            "imported": false,
            "current_name": "reset_memory_08005bc4"
        },
        "FUN_08006680": {
            "renaming": {
                "FUN_08006680": "get_adjusted_hclk_frequency_08006680",
                "uVar1": "hclkFrequency",
                "uVar2": "leadingZeroesCount",
                "result": "adjustedFrequency",
                "result_1": "unusedVariable"
            },
            "code": "\nuint32_t GetAdjustedHCLKFrequency_08006680(void)\n\n{\n  uint32_t hclkFrequency;\n  uint leadingZeroesCount;\n  uint32_t adjustedFrequency;\n  uint32_t unusedVariable;\n  \n  hclkFrequency = HAL_RCC_GetHCLKFreq();\n  leadingZeroesCount = count_leading_zeroes(0x380000);\n  return hclkFrequency >> PTR_APBAHBPrescTable_080066c8\n                  [(*(uint *)(DAT_080066c4 + 8) & 0x1c00) >> (leadingZeroesCount & 0xff)];\n}\n\n",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006680",
            "calling": [
                "set_baud_rate"
            ],
            "imported": false,
            "current_name": "get_adjusted_hclk_frequency_08006680"
        },
        "FUN_08000340": {
            "renaming": {
                "FUN_08000340": "update_eeprom_byte_08000340",
                "addr": "address"
            },
            "code": "\nvoid update_eeprom_byte_08000340(uint address,uchar new_value)\n\n{\n  if (*(int *)PTR_eeprom_ready_0800036c == 0) {\n    eeprom_init();\n  }\n  PTR_eeprom_data_08000370[address & 0x3ff] = new_value;\n  return;\n}\n\n",
            "called": [
                "eeprom_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000340",
            "calling": [
                "write_global_settings",
                "memcpy_to_eeprom_with_checksum"
            ],
            "imported": false,
            "current_name": "update_eeprom_byte_08000340"
        },
        "FUN_08004bf4": {
            "renaming": {
                "FUN_08004bf4": "store_data_to_eeprom_08004bf4",
                "coord_select": "coordinate_id",
                "coord_data": "coordinate_data",
                "addr": "address"
            },
            "code": "\nvoid store_data_to_eeprom_08004bf4(uint8_t coordinate_id,float *coordinate_data)\n\n{\n  uint16_t address;\n  \n  memcpy_to_eeprom_with_checksum\n            ((uint)(ushort)((ushort)coordinate_id * 0xd + 0x200),(char *)coordinate_data,0xc);\n  return;\n}\n\n",
            "called": [
                "memcpy_to_eeprom_with_checksum"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004bf4",
            "calling": [
                "settings_read_coord_data",
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "store_data_to_eeprom_08004bf4"
        },
        "FUN_08004d7c": {
            "renaming": {
                "FUN_08004d7c": "load_and_verify_coord_data_08004d7c",
                "coord_select": "coordinateIndex",
                "coord_data": "coordinateData",
                "iVar1": "verificationResult",
                "addr": "eepromAddress"
            },
            "code": "\nuint8_t LoadAndVerifyCoordData_08004d7c(uint8_t coordinateIndex,float *coordinateData)\n\n{\n  int verificationResult;\n  uint16_t eepromAddress;\n  \n  verificationResult = memcpy_from_eeprom_with_checksum\n                    ((char *)coordinateData,(uint)(ushort)((ushort)coordinateIndex * 0xd + 0x200),0xc);\n  if (verificationResult == 0) {\n    memset(coordinateData,0,0xc);\n    settings_write_coordinateData(coordinateIndex,coordinateData);\n  }\n  return verificationResult != 0;\n}\n\n",
            "called": [
                "settings_write_coord_data",
                "memset",
                "memcpy_from_eeprom_with_checksum"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d7c",
            "calling": [
                "settings_init",
                "report_gcode_parameters",
                "gc_execute_line",
                "gc_init"
            ],
            "imported": false,
            "current_name": "load_and_verify_coord_data_08004d7c"
        },
        "FUN_08009278": {
            "renaming": {
                "FUN_08009278": "calculate_transformed_value_08009278",
                "param_1": "input_value",
                "uVar1": "intermediate_value",
                "uVar2": "difference"
            },
            "code": "\nuint calculate_transformed_value_08009278(uint input_value)\n\n{\n  uint intermediate_value;\n  uint difference;\n  \n  if (input_value << 1 < 0x7f000000) {\n    return 0;\n  }\n  intermediate_value = (input_value << 1) >> 0x18;\n  difference = 0x9e - intermediate_value;\n  if (intermediate_value < 0x9f && difference != 0) {\n    intermediate_value = (input_value << 8 | 0x80000000) >> (difference & 0xff);\n    if ((input_value & 0x80000000) != 0) {\n      intermediate_value = -intermediate_value;\n    }\n    return intermediate_value;\n  }\n  if ((difference == 0xffffff9f) && ((input_value & 0x7fffff) != 0)) {\n    return 0;\n  }\n  input_value = input_value & 0x80000000;\n  if (input_value == 0) {\n    input_value = 0x7fffffff;\n  }\n  return input_value;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009278",
            "calling": [
                "protocol_execute_line",
                "printFloat"
            ],
            "imported": false,
            "current_name": "calculate_transformed_value_08009278"
        },
        "FUN_080004fc": {
            "renaming": {
                "FUN_080004fc": "update_coordinates_080004fc",
                "x": "coord_x",
                "y": "coord_y",
                "z": "coord_z",
                "uVar1": "temp_float"
            },
            "code": "\nvoid update_coordinates_080004fc(int32_t coord_x,int32_t coord_y,int32_t coord_z)\n\n{\n  undefined4 temp_float;\n  \n  temp_float = __floatsisf(coord_x);\n  temp_float = __aeabi_fdiv(temp_float,*(undefined4 *)PTR_settings_08000564);\n  *(undefined4 *)(PTR_gc_08000568 + 0coord_xc) = temp_float;\n  temp_float = __floatsisf(coord_y);\n  temp_float = __aeabi_fdiv(temp_float,*(undefined4 *)(PTR_settings_08000564 + 4));\n  *(undefined4 *)(PTR_gc_08000568 + 0coord_x10) = temp_float;\n  temp_float = __floatsisf(coord_z);\n  temp_float = __aeabi_fdiv(temp_float,*(undefined4 *)(PTR_settings_08000564 + 8));\n  *(undefined4 *)(PTR_gc_08000568 + 0coord_x14) = temp_float;\n  return;\n}\n\n",
            "called": [
                "__aeabi_fdiv",
                "__floatsisf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080004fc",
            "calling": [
                "sys_sync_current_position"
            ],
            "imported": false,
            "current_name": "update_coordinates_080004fc"
        },
        "FUN_08000220": {
            "renaming": {
                "FUN_08000220": "update_coolant_mode_08000220",
                "mode": "newMode"
            },
            "code": "\nvoid updateCoolantMode_08000220(uint8_t newMode)\n\n{\n  if (newMode != *PTR_current_coolant_newMode_08000264) {\n    plan_synchronize();\n    if (newMode == '\\x01') {\n      coolant_flood_on();\n    }\n    else if (newMode == '\\x02') {\n      coolant_mist_on();\n    }\n    else {\n      coolant_stop();\n    }\n    *PTR_current_coolant_newMode_08000264 = newMode;\n  }\n  return;\n}\n\n",
            "called": [
                "coolant_mist_on",
                "coolant_flood_on",
                "coolant_stop",
                "plan_synchronize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000220",
            "calling": [
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "update_coolant_mode_08000220"
        },
        "FUN_08005238": {
            "renaming": {
                "FUN_08005238": "stop_spindle_and_reset_direction_08005238"
            },
            "code": "\nvoid stopSpindleAndResetDirection_08005238(void)\n\n{\n  *PTR_current_direction_0800524c = 0;\n  spindle_stop();\n  return;\n}\n\n",
            "called": [
                "spindle_stop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005238",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "stop_spindle_and_reset_direction_08005238"
        },
        "FUN_08007da8": {
            "renaming": {
                "FUN_08007da8": "enable_ti_mx_08007da8",
                "puVar1": "registerPtr",
                "TIMx": "timer"
            },
            "code": "\nvoid enable_TIMx_08007da8(void)\n\n{\n  uint *registerPtr;\n  TIM_TypeDef *timer;\n  \n  registerPtr = DAT_08007dd4;\n  DAT_08007dd4[8] = DAT_08007dd4[8] | 0x10;\n  *registerPtr = *registerPtr | 1;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007da8",
            "calling": [
                "timers_init"
            ],
            "imported": false,
            "current_name": "enable_ti_mx_08007da8"
        },
        "FUN_08004148": {
            "renaming": {
                "FUN_08004148": "display_alarm_message_08004148",
                "alarm_code": "alarmCode"
            },
            "code": "\nvoid displayAlarmMessage_08004148(int8_t alarmCode)\n\n{\n  printPgmString(PTR_s_ALARM__08004190);\n  if (alarmCode == -2) {\n    printPgmString(PTR_s_Abort_during_cycle_08004198);\n  }\n  else if (alarmCode == -1) {\n    printPgmString(PTR_s_Hard_limit_08004194);\n  }\n  printPgmString(PTR_s___MPos__0800419c);\n  delay_ms(500);\n  return;\n}\n\n",
            "called": [
                "printPgmString",
                "delay_ms"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004148",
            "calling": [
                "protocol_execute_runtime"
            ],
            "imported": false,
            "current_name": "display_alarm_message_08004148"
        },
        "FUN_08004940": {
            "renaming": {
                "FUN_08004940": "display_machine_position_08004940",
                "uVar1": "temp_float1",
                "fVar2": "temp_float2",
                "extraout_s0": "float_result1",
                "extraout_s0_00": "float_result2",
                "extraout_s0_01": "float_result3",
                "extraout_s0_02": "float_result4",
                "uVar3": "temp_double1",
                "uVar4": "temp_double2",
                "print_position": "display_position",
                "current_position": "current_position_array",
                "i": "index"
            },
            "code": "\nvoindexd displayMachinePosition_08004940(voindexd)\n\n{\n  undefindexned4 temp_float1;\n  float temp_float2;\n  float float_result1;\n  float float_result2;\n  float float_result3;\n  float float_result4;\n  undefindexned8 temp_double1;\n  undefindexned8 temp_double2;\n  float display_position [3];\n  indexnt32_t current_position_array [3];\n  uindexnt8_t index;\n  \n  current_position_array[0] = *(indexnt32_t *)(PTR_sys_08004b88 + 4);\n  current_position_array[1] = *(indexnt32_t *)(PTR_sys_08004b88 + 8);\n  current_position_array[2] = *(indexnt32_t *)(PTR_sys_08004b88 + 0xc);\n  indexf ((byte)PTR_sys_08004b88[1] < 8) {\n                    /* WARNING: Could not recover jumptable at 0x0800495e. Too many branches */\n                    /* WARNING: Treatindexng indexndindexrect jump as call */\n    (*(code *)(&swindextchD_0800495e::swindextchdataD_08004964)[(byte)PTR_sys_08004b88[1]])();\n    return;\n  }\n  prindexntPgmStrindexng(PTR_s__MPos__08004ba8);\n  for (index = '\\0'; index < 3; index = index + '\\x01') {\n    temp_float1 = __floatsindexsf(current_position_array[index]);\n    temp_float2 = (float)__aeabindex_fdindexv(temp_float1,*(undefindexned4 *)(PTR_settindexngs_08004bac + (uindexnt)index * 4));\n    display_position[index] = temp_float2;\n    temp_float2 = float_result1;\n    indexf ((PTR_settindexngs_08004bac[0x28] & 1) != 0) {\n      temp_double1 = __aeabindex_f2d(display_position[index]);\n      temp_double1 = __muldf3((indexnt)temp_double1,(indexnt)((ulonglong)temp_double1 >> 0x20),DAT_08004b80,DAT_08004b84);\n      temp_float2 = (float)__truncdfsf2((indexnt)temp_double1,(indexnt)((ulonglong)temp_double1 >> 0x20));\n      display_position[index] = temp_float2;\n      temp_float2 = float_result2;\n    }\n    prindexntFloat(temp_float2);\n    prindexntPgmStrindexng(PTR_DAT_08004bb0);\n  }\n  prindexntPgmStrindexng(PTR_s_WPos__08004bb4);\n  for (index = '\\0'; index < 3; index = index + '\\x01') {\n    indexf ((PTR_settindexngs_08004bac[0x28] & 1) == 0) {\n      temp_float2 = display_position[index];\n      temp_float1 = __addsf3(*(undefindexned4 *)(PTR_gc_08004bb8 + (index + 8) * 4),\n                       *(undefindexned4 *)(PTR_gc_08004bb8 + (index + 10) * 4 + 4));\n      temp_float2 = (float)__aeabindex_fsub(temp_float2,temp_float1);\n      display_position[index] = temp_float2;\n      temp_float2 = float_result4;\n    }\n    else {\n      temp_double1 = __aeabindex_f2d(display_position[index]);\n      temp_float1 = __addsf3(*(undefindexned4 *)(PTR_gc_08004bb8 + (index + 8) * 4),\n                       *(undefindexned4 *)(PTR_gc_08004bb8 + (index + 10) * 4 + 4));\n      temp_double2 = __aeabindex_f2d(temp_float1);\n      temp_double2 = __muldf3((indexnt)temp_double2,(indexnt)((ulonglong)temp_double2 >> 0x20),DAT_08004b80,DAT_08004b84);\n      temp_double1 = __subdf3((indexnt)temp_double1,(indexnt)((ulonglong)temp_double1 >> 0x20),(indexnt)temp_double2,\n                       (indexnt)((ulonglong)temp_double2 >> 0x20));\n      temp_float2 = (float)__truncdfsf2((indexnt)temp_double1,(indexnt)((ulonglong)temp_double1 >> 0x20));\n      display_position[index] = temp_float2;\n      temp_float2 = float_result3;\n    }\n    prindexntFloat(temp_float2);\n    indexf (index < 2) {\n      prindexntPgmStrindexng(PTR_DAT_08004bb0);\n    }\n  }\n  prindexntPgmStrindexng(PTR_DAT_08004bbc);\n  return;\n}\n\n",
            "called": [
                "__aeabi_fsub",
                "__aeabi_fdiv",
                "__addsf3",
                "__floatsisf",
                "printFloat",
                "printPgmString",
                "__muldf3",
                "__truncdfsf2",
                "__subdf3",
                "__aeabi_f2d"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004940",
            "calling": [
                "protocol_execute_runtime"
            ],
            "imported": false,
            "current_name": "display_machine_position_08004940"
        },
        "FUN_08008a74": {
            "renaming": {
                "FUN_08008a74": "compare_values_08008a74",
                "param_1": "valueA1",
                "param_2": "valueA2",
                "param_3": "valueB1",
                "param_4": "valueB2",
                "uVar1": "xorResult",
                "bVar2": "comparisonFlag1",
                "bVar3": "comparisonFlag2"
            },
            "code": "\nuint compareValues_08008a74(uint valueA1,uint valueA2,uint valueB1,uint valueB2)\n\n{\n  uint xorResult;\n  bool comparisonFlag1;\n  bool comparisonFlag2;\n  \n  if (((int)(valueA2 << 1) >> 0x15 == -1 || (int)(valueB2 << 1) >> 0x15 == -1) &&\n     ((((int)(valueA2 << 1) >> 0x15 == -1 && ((valueA1 | valueA2 << 0xc) != 0)) ||\n      (((int)(valueB2 << 1) >> 0x15 == -1 && ((valueB1 | valueB2 << 0xc) != 0)))))) {\n    return 1;\n  }\n  comparisonFlag1 = (valueA1 | valueA2 << 1) == 0;\n  if (comparisonFlag1) {\n    comparisonFlag1 = (valueB1 | valueB2 << 1) == 0;\n  }\n  if (!comparisonFlag1) {\n    comparisonFlag1 = valueA2 == valueB2;\n  }\n  if (comparisonFlag1) {\n    comparisonFlag1 = valueA1 == valueB1;\n  }\n  if (!comparisonFlag1) {\n    xorResult = valueA2 ^ valueB2;\n    comparisonFlag1 = xorResult == 0;\n    if (-1 < (int)xorResult) {\n      comparisonFlag1 = valueA2 == valueB2;\n    }\n    comparisonFlag2 = -1 < (int)xorResult && valueB2 <= valueA2;\n    if (comparisonFlag1) {\n      comparisonFlag2 = valueB1 <= valueA1;\n    }\n    valueB2 = (int)valueB2 >> 0x1f;\n    if (!comparisonFlag2) {\n      valueB2 = ~valueB2;\n    }\n    return valueB2 | 1;\n  }\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a74",
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "imported": false,
            "current_name": "compare_values_08008a74"
        },
        "FUN_08002fd4": {
            "renaming": {
                "FUN_08002fd4": "process_current_block_08002fd4",
                "pbVar1": "current_block"
            },
            "code": "\nvoid process_current_block_08002fd4(void)\n\n{\n  block_t *current_block;\n  \n  while ((current_block = plan_get_current_block(), current_block != (block_t *)0x0 ||\n         (PTR_sys_08003000[1] == '\\x03'))) {\n    protocol_execute_runtime();\n    if (*PTR_sys_08003000 != '\\0') {\n      return;\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "protocol_execute_runtime",
                "plan_get_current_block"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fd4",
            "calling": [
                "coolant_run",
                "spindle_run",
                "gc_execute_line",
                "mc_go_home",
                "mc_dwell"
            ],
            "imported": false,
            "current_name": "process_current_block_08002fd4"
        },
        "FUN_08002408": {
            "renaming": {
                "FUN_08002408": "execute_with_delay_08002408",
                "seconds": "timeInSeconds",
                "ms": "delayInMilliseconds",
                "in_r0": "input_r0",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "extraout_r1": "extraOutput_r1",
                "extraout_r1_00": "extraOutput_r1_00",
                "in_stack_ffffffe0": "inputStack_ffffffe0",
                "i": "counter"
            },
            "code": "\nvocounterd executeWithDelay_08002408(float timeInSeconds)\n\n{\n  ucounternt16_t delayInMilliseconds;\n  undefcounterned4 input_r0;\n  undefcounterned4 tempVar1;\n  undefcounterned4 tempVar2;\n  undefcounterned4 extraOutput_r1;\n  undefcounterned4 extraOutput_r1_00;\n  undefcounterned4 inputStack_ffffffe0;\n  ucounternt16_t counter;\n  \n  tempVar1 = __aeabcounter_fmul(timeInSeconds,input_r0,DAT_080024b8);\n  tempVar1 = __aeabcounter_f2d(tempVar1);\n  floor((double)CONCAT44(input_r0,inputStack_ffffffe0));\n  counter = __aeabcounter_d2ucounterz(tempVar1,extraOutput_r1);\n  plan_synchroncounterze();\n  tempVar1 = __aeabcounter_fmul(input_r0,DAT_080024bc);\n  tempVar2 = __floatscountersf((ucounternt)counter * 0x32);\n  tempVar1 = __aeabcounter_fsub(tempVar1,tempVar2);\n  tempVar1 = __aeabcounter_f2d(tempVar1);\n  floor((double)CONCAT44(input_r0,inputStack_ffffffe0));\n  delayInMilliseconds = __aeabcounter_d2ucounterz(tempVar1,extraOutput_r1_00);\n  delay_delayInMilliseconds(delayInMilliseconds);\n  whcounterle ((counter != 0 && (protocol_execute_runtcounterme(), *PTR_sys_080024c0 == '\\0'))) {\n    _delay_delayInMilliseconds(0x32);\n    counter = counter - 1;\n  }\n  return;\n}\n\n",
            "called": [
                "__aeabi_fsub",
                "protocol_execute_runtime",
                "__floatsisf",
                "floor",
                "__aeabi_fmul",
                "plan_synchronize",
                "delay_ms",
                "_delay_ms",
                "__aeabi_d2uiz",
                "__aeabi_f2d"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002408",
            "calling": [
                "gc_execute_line"
            ],
            "imported": false,
            "current_name": "execute_with_delay_08002408"
        },
        "FUN_08002a94": {
            "renaming": {
                "FUN_08002a94": "process_block_buffer_08002a94",
                "next": "next_block",
                "previous": "previous_block",
                "block": "block_array"
            },
            "code": "\nvoid process_block_buffer_08002a94(void)\n\n{\n  block_array_t *next_block;\n  block_array_t *previous_block;\n  block_array_t *block_array [3];\n  uint8_t block_array_index;\n  \n  block_array_index = *PTR_block_array_buffer_head_08002af0;\n  block_array[0] = (block_array_t *)0x0;\n  block_array[1] = (block_array_t *)0x0;\n  while (next_block = block_array[1], block_array_index != *PTR_block_array_buffer_tail_08002af8) {\n    block_array_index = prev_block_array_index(block_array_index);\n    block_array[1] = block_array[0];\n    previous_block = (block_array_t *)(PTR_block_array_buffer_08002af4 + (uint)block_array_index * 0x40);\n    process_block_buffer_08002a94_kernel(previous_block,block_array[0],next_block);\n    block_array[0] = previous_block;\n  }\n  return;\n}\n\n",
            "called": [
                "prev_block_index",
                "planner_reverse_pass_kernel"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a94",
            "calling": [
                "planner_recalculate"
            ],
            "imported": false,
            "current_name": "process_block_buffer_08002a94"
        },
        "FUN_08003618": {
            "renaming": {
                "FUN_08003618": "update_block_buffer_08003618",
                "step_events_remaining": "steps_remaining",
                "bVar1": "buffer_tail",
                "puVar2": "block_buffer",
                "uVar3": "temp_float1",
                "uVar4": "temp_float2",
                "block_t": "block_data"
            },
            "code": "\nvoid update_block_buffer_08003618(int32_t steps_remaining)\n\n{\n  byte buffer_tail;\n  undefined *block_buffer;\n  undefined4 temp_float1;\n  undefined4 temp_float2;\n  block_data *block;\n  \n  block_buffer = PTR_block_buffer_08003698;\n  buffer_tail = *PTR_block_buffer_tail_08003694;\n  temp_float2 = *(undefined4 *)(PTR_block_buffer_08003698 + (uint)buffer_tail * 0x40 + 0x20);\n  temp_float1 = __floatsisf(steps_remaining);\n  temp_float1 = __aeabi_fmul(temp_float2,temp_float1);\n  temp_float2 = __floatsisf(*(undefined4 *)(block_buffer + (uint)buffer_tail * 0x40 + 0x10));\n  temp_float1 = __aeabi_fdiv(temp_float1,temp_float2);\n  *(undefined4 *)(block_buffer + (uint)buffer_tail * 0x40 + 0x20) = temp_float1;\n  *(int32_t *)(block_buffer + (uint)buffer_tail * 0x40 + 0x10) = steps_remaining;\n  *(undefined4 *)(block_buffer + (uint)buffer_tail * 0x40 + 0x18) = 0;\n  *(undefined4 *)(block_buffer + (uint)buffer_tail * 0x40 + 0x1c) = 0;\n  block_buffer[(uint)buffer_tail * 0x40 + 0x25] = 0;\n  block_buffer[(uint)buffer_tail * 0x40 + 0x24] = 1;\n  planner_recalculate();\n  return;\n}\n\n",
            "called": [
                "__aeabi_fdiv",
                "__floatsisf",
                "planner_recalculate",
                "__aeabi_fmul"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003618",
            "calling": [
                "st_cycle_reinitialize"
            ],
            "imported": false,
            "current_name": "update_block_buffer_08003618"
        },
        "FUN_0800522c": {
            "renaming": {
                "FUN_0800522c": "do_nothing_0800522c"
            },
            "code": "\nvoid do_nothing_0800522c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800522c",
            "calling": [
                "spindle_run"
            ],
            "imported": false,
            "current_name": "do_nothing_0800522c"
        },
        "FUN_0800af78": {
            "renaming": {
                "FUN_0800af78": "calculate_expression_0800af78",
                "__x": "input_x",
                "in_r0": "int_var1",
                "in_r1": "uint_var2",
                "in_d0": "double_var1",
                "in_stack_ffffffd0": "input_stack",
                "uVar6": "uint_temp1",
                "uVar11": "uint_temp2",
                "iVar7": "int_temp1",
                "dVar8": "double_temp1",
                "extraout_d0": "extra_double_out",
                "extraout_r1": "extra_uint_out",
                "uVar2": "undefined_var1",
                "uVar3": "undefined_var2",
                "uVar4": "undefined_var3",
                "uVar5": "undefined_var4",
                "uVar9": "undefined_temp1",
                "uVar10": "undefined_temp2",
                "puVar1": "undefined_ptr1"
            },
            "code": "\ndouble calculate_expression_0800af78(double input_x)\n\n{\n  undefined *undefined_ptr1;\n  int int_var1;\n  undefined4 undefined_var1;\n  undefined4 undefined_var2;\n  uint uint_var2;\n  undefined4 undefined_var3;\n  undefined4 undefined_var4;\n  undefined4 extra_uint_out;\n  uint uint_temp1;\n  int int_temp1;\n  double double_var1;\n  double double_temp1;\n  double extra_double_out;\n  undefined8 undefined_temp1;\n  undefined8 undefined_temp2;\n  undefined4 input_stack;\n  uint uint_temp2;\n  \n  uint_temp1 = uint_var2 & 0x7fffffff;\n  if (DAT_0800b298 < (int)uint_temp1) {\n    if ((uint_temp1 != DAT_0800b29c && (int)DAT_0800b29c <= (int)uint_temp1) ||\n       ((uint_temp1 == DAT_0800b29c && (int_var1 != 0)))) {\n      double_temp1 = (double)__aeabi_dadd();\n      return double_temp1;\n    }\n  }\n  else {\n    if (DAT_0800b2ac < (int)uint_temp1) {\n      fabs((double)CONCAT44(uint_var2,input_stack));\n      if (DAT_0800b2bc < (int)uint_temp1) {\n        if ((int)uint_temp1 < DAT_0800b2c0) {\n          undefined_temp1 = __subdf3();\n          undefined_temp2 = __muldf3(int_var1,extra_uint_out,0,DAT_0800b2c4);\n          undefined_temp2 = __aeabi_dadd((int)undefined_temp2,(int)((ulonglong)undefined_temp2 >> 0x20),0,DAT_0800b2b8);\n          undefined_temp1 = __divdf3((int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20),(int)undefined_temp2,\n                           (int)((ulonglong)undefined_temp2 >> 0x20));\n          uint_temp2 = (uint)((ulonglong)undefined_temp1 >> 0x20);\n          int_var1 = (int)undefined_temp1;\n          int_temp1 = 2;\n        }\n        else {\n          undefined_temp1 = __divdf3(0,DAT_0800b2c8,int_var1,extra_uint_out);\n          uint_temp2 = (uint)((ulonglong)undefined_temp1 >> 0x20);\n          int_var1 = (int)undefined_temp1;\n          int_temp1 = 3;\n        }\n      }\n      else if (DAT_0800b2bc + -0xd0000 < (int)uint_temp1) {\n        undefined_temp1 = __subdf3();\n        undefined_temp2 = __aeabi_dadd(int_var1,extra_uint_out,0,DAT_0800b2b8);\n        undefined_temp1 = __divdf3((int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20),(int)undefined_temp2,\n                         (int)((ulonglong)undefined_temp2 >> 0x20));\n        uint_temp2 = (uint)((ulonglong)undefined_temp1 >> 0x20);\n        int_var1 = (int)undefined_temp1;\n        int_temp1 = 1;\n      }\n      else {\n        undefined_temp1 = __aeabi_dadd();\n        undefined_temp1 = __subdf3((int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20),0,DAT_0800b2b8);\n        undefined_temp2 = __aeabi_dadd(int_var1,extra_uint_out,0,0x40000000);\n        undefined_temp1 = __divdf3((int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20),(int)undefined_temp2,\n                         (int)((ulonglong)undefined_temp2 >> 0x20));\n        uint_temp2 = (uint)((ulonglong)undefined_temp1 >> 0x20);\n        int_var1 = (int)undefined_temp1;\n        int_temp1 = 0;\n      }\n    }\n    else {\n      uint_temp2 = uint_var2;\n      if ((int)uint_temp1 <= DAT_0800b2ac + -0x1bc0000) {\n        undefined_temp1 = __aeabi_dadd(int_var1,uint_var2,DAT_0800b290,DAT_0800b294);\n        int_temp1 = __aeabi_dcmpgt((int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20),0,DAT_0800b2b8);\n        if (int_temp1 != 0) {\n          return extra_double_out;\n        }\n      }\n      int_temp1 = -1;\n    }\n    undefined_temp1 = __muldf3(int_var1,uint_temp2,int_var1);\n    undefined_var3 = (undefined4)((ulonglong)undefined_temp1 >> 0x20);\n    undefined_var1 = (undefined4)undefined_temp1;\n    undefined_temp1 = __muldf3(undefined_var1,undefined_var3,undefined_var1,undefined_var3);\n    undefined_var4 = (undefined4)((ulonglong)undefined_temp1 >> 0x20);\n    undefined_var2 = (undefined4)undefined_temp1;\n    undefined_temp1 = __muldf3(undefined_var2,undefined_var4,DAT_0800b238,DAT_0800b23c);\n    undefined_temp1 = __aeabi_dadd((int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20),DAT_0800b240,DAT_0800b244);\n    undefined_temp1 = __muldf3((int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20),undefined_var2,undefined_var4);\n    undefined_temp1 = __aeabi_dadd((int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20),DAT_0800b248,DAT_0800b24c);\n    undefined_temp1 = __muldf3((int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20),undefined_var2,undefined_var4);\n    undefined_temp1 = __aeabi_dadd((int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20),DAT_0800b250,DAT_0800b254);\n    undefined_temp1 = __muldf3((int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20),undefined_var2,undefined_var4);\n    undefined_temp1 = __aeabi_dadd((int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20),DAT_0800b258,DAT_0800b25c);\n    undefined_temp1 = __muldf3((int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20),undefined_var2,undefined_var4);\n    undefined_temp1 = __aeabi_dadd((int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20),DAT_0800b260,DAT_0800b264);\n    undefined_temp1 = __muldf3((int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20),undefined_var1,undefined_var3);\n    undefined_var1 = (undefined4)((ulonglong)undefined_temp1 >> 0x20);\n    undefined_temp2 = __muldf3(undefined_var2,undefined_var4,DAT_0800b268,DAT_0800b26c);\n    undefined_temp2 = __subdf3((int)undefined_temp2,(int)((ulonglong)undefined_temp2 >> 0x20),DAT_0800b270,DAT_0800b274);\n    undefined_temp2 = __muldf3((int)undefined_temp2,(int)((ulonglong)undefined_temp2 >> 0x20),undefined_var2,undefined_var4);\n    undefined_temp2 = __subdf3((int)undefined_temp2,(int)((ulonglong)undefined_temp2 >> 0x20),DAT_0800b278,DAT_0800b27c);\n    undefined_temp2 = __muldf3((int)undefined_temp2,(int)((ulonglong)undefined_temp2 >> 0x20),undefined_var2,undefined_var4);\n    undefined_temp2 = __subdf3((int)undefined_temp2,(int)((ulonglong)undefined_temp2 >> 0x20),DAT_0800b280,DAT_0800b284);\n    undefined_temp2 = __muldf3((int)undefined_temp2,(int)((ulonglong)undefined_temp2 >> 0x20),undefined_var2,undefined_var4);\n    undefined_temp2 = __subdf3((int)undefined_temp2,(int)((ulonglong)undefined_temp2 >> 0x20),DAT_0800b288,DAT_0800b28c);\n    undefined_temp2 = __muldf3((int)undefined_temp2,(int)((ulonglong)undefined_temp2 >> 0x20),undefined_var2,undefined_var4);\n    undefined_var2 = (undefined4)((ulonglong)undefined_temp2 >> 0x20);\n    if (int_temp1 == -1) {\n      undefined_temp1 = __aeabi_dadd((int)undefined_temp1,undefined_var1,(int)undefined_temp2,undefined_var2);\n      undefined_temp1 = __muldf3((int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20),int_var1,uint_temp2);\n      double_temp1 = (double)__subdf3(int_var1,uint_temp2,(int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20));\n      return double_temp1;\n    }\n    undefined_temp1 = __aeabi_dadd((int)undefined_temp1,undefined_var1,(int)undefined_temp2,undefined_var2);\n    undefined_ptr1 = PTR_calculate_expression_0800af78hi_0800b2b0;\n    undefined_temp1 = __muldf3((int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20),int_var1,uint_temp2);\n    undefined_temp1 = __subdf3((int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20),\n                     *(undefined4 *)(PTR_calculate_expression_0800af78lo_0800b2b4 + int_temp1 * 8),\n                     *(undefined4 *)((int)(PTR_calculate_expression_0800af78lo_0800b2b4 + int_temp1 * 8) + 4));\n    undefined_temp1 = __subdf3((int)undefined_temp1,(int)((ulonglong)undefined_temp1 >> 0x20),int_var1,uint_temp2);\n    double_var1 = (double)__subdf3(*(undefined4 *)(undefined_ptr1 + int_temp1 * 8),\n                             *(undefined4 *)((int)(undefined_ptr1 + int_temp1 * 8) + 4),(int)undefined_temp1,\n                             (int)((ulonglong)undefined_temp1 >> 0x20));\n    if ((int)uint_var2 < 0) {\n      return double_var1;\n    }\n  }\n  return double_var1;\n}\n\n",
            "called": [
                "__divdf3",
                "__aeabi_dcmpgt",
                "__muldf3",
                "fabs",
                "__aeabi_dadd",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800af78",
            "calling": [
                "__ieee754_atan2"
            ],
            "imported": false,
            "current_name": "calculate_expression_0800af78"
        },
        "FUN_08005b20": {
            "renaming": {
                "FUN_08005b20": "clear_least_significant_bit_08005b20"
            },
            "code": "\nvoid clearLeastSignificantBit_08005b20(void)\n\n{\n  *(uint *)(DAT_08005b38 + 4) = *(uint *)(DAT_08005b38 + 4) & 0xfffffffe;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b20",
            "calling": [],
            "imported": false,
            "current_name": "clear_least_significant_bit_08005b20"
        },
        "FUN_08007d08": {
            "renaming": {
                "FUN_08007d08": "initialize_timer_08007d08",
                "TIMx": "timerInstance",
                "pTVar1": "timer"
            },
            "code": "\nvoid initializeTimer_08007d08(void)\n\n{\n  TIM_TypeDef *timer;\n  TIM_TypeDef *timerInstance;\n  \n  timer = DAT_08007d9c;\n  enable_tim_clock(DAT_08007d9c);\n  timer->CR1 = 0x80;\n  timer->CR2 = 0;\n  timer->SMCR = 0;\n  timer->DIER = 0;\n  timer->SR = 0;\n  timer->CCMR1 = 0x6800;\n  timer->CCMR2 = 0;\n  timer->CCER = 0;\n  timer->CNT = 0;\n  timer->PSC = (uint)((ulonglong)DAT_08007da4 * (ulonglong)*(uint *)PTR_SystemCoreClock_08007da0 >>\n                      0x35) - 1;\n  timer->ARR = 199;\n  timer->CCR1 = 0;\n  timer->CCR2 = 100;\n  timer->CCR3 = 0;\n  timer->CCR4 = 0;\n  timer->DCR = 0;\n  timer->DMAR = 0;\n  timer->EGR = 1;\n  return;\n}\n\n",
            "called": [
                "enable_tim_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007d08",
            "calling": [
                "timers_init"
            ],
            "imported": false,
            "current_name": "initialize_timer_08007d08"
        },
        "FUN_080091fc": {
            "renaming": {
                "FUN_080091fc": "compare_floats_080091fc",
                "param_1": "float1",
                "param_2": "float2"
            },
            "code": "\nvoid compare_floats_080091fc(undefined4 float1,undefined4 float2)\n\n{\n  __aeabi_cfcmpeq(float2,float1);\n  return;\n}\n\n",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091fc",
            "calling": [
                "__aeabi_fcmpgt",
                "__aeabi_fcmpge"
            ],
            "imported": false,
            "current_name": "compare_floats_080091fc"
        },
        "FUN_080058a0": {
            "renaming": {
                "FUN_080058a0": "initialize_system_state_080058a0"
            },
            "code": "\nvoid initializeSystemState_080058a0(void)\n\n{\n  if (*(int *)PTR_current_block_080058f0 == 0) {\n    PTR_sys_080058fc[1] = 0;\n  }\n  else {\n    plan_cycle_reinitialize\n              (*(int *)(*(int *)PTR_current_block_080058f0 + 0x10) -\n               *(int *)(PTR_st_080058f4 + 0x10));\n    *(undefined4 *)(PTR_st_080058f4 + 0x1c) = 0;\n    set_step_events_per_minute(*(uint32_t *)(PTR_st_080058f4 + 0x1c));\n    *(undefined4 *)(PTR_st_080058f4 + 0x18) = DAT_080058f8;\n    *(undefined4 *)(PTR_st_080058f4 + 0x10) = 0;\n    PTR_sys_080058fc[1] = 2;\n  }\n  return;\n}\n\n",
            "called": [
                "plan_cycle_reinitialize",
                "set_step_events_per_minute"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080058a0",
            "calling": [
                "protocol_execute_runtime"
            ],
            "imported": false,
            "current_name": "initialize_system_state_080058a0"
        },
        "FUN_08008a6c": {
            "renaming": {
                "FUN_08008a6c": "compare_values_08008a6c",
                "param_1": "value1",
                "param_2": "shifted_value1",
                "param_3": "value2",
                "param_4": "shifted_value2",
                "uVar1": "xor_result",
                "bVar2": "comparison_result",
                "bVar3": "conditional_result"
            },
            "code": "\nuint compare_values_08008a6c(uint value1,uint shifted_value1,uint value2,uint shifted_value2)\n\n{\n  uint xor_result;\n  bool comparison_result;\n  bool conditional_result;\n  \n  if (((int)(shifted_value1 << 1) >> 0x15 == -1 || (int)(shifted_value2 << 1) >> 0x15 == -1) &&\n     ((((int)(shifted_value1 << 1) >> 0x15 == -1 && ((value1 | shifted_value1 << 0xc) != 0)) ||\n      (((int)(shifted_value2 << 1) >> 0x15 == -1 && ((value2 | shifted_value2 << 0xc) != 0)))))) {\n    return 1;\n  }\n  comparison_result = (value1 | shifted_value1 << 1) == 0;\n  if (comparison_result) {\n    comparison_result = (value2 | shifted_value2 << 1) == 0;\n  }\n  if (!comparison_result) {\n    comparison_result = shifted_value1 == shifted_value2;\n  }\n  if (comparison_result) {\n    comparison_result = value1 == value2;\n  }\n  if (!comparison_result) {\n    xor_result = shifted_value1 ^ shifted_value2;\n    comparison_result = xor_result == 0;\n    if (-1 < (int)xor_result) {\n      comparison_result = shifted_value1 == shifted_value2;\n    }\n    conditional_result = -1 < (int)xor_result && shifted_value2 <= shifted_value1;\n    if (comparison_result) {\n      conditional_result = value2 <= value1;\n    }\n    shifted_value2 = (int)shifted_value2 >> 0x1f;\n    if (!conditional_result) {\n      shifted_value2 = ~shifted_value2;\n    }\n    return shifted_value2 | 1;\n  }\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a6c",
            "calling": [],
            "imported": false,
            "current_name": "compare_values_08008a6c"
        },
        "FUN_080036c6": {
            "renaming": {
                "FUN_080036c6": "write_serial_string_080036c6",
                "s": "input_string",
                "local_c": "current_char"
            },
            "code": "\nvoid write_serial_string_080036c6(char *input_string)\n\n{\n  uint8_t *current_char;\n  \n  current_char = (uint8_t *)input_string;\n  while (*current_char != '\\0') {\n    input_stringerial_write(*current_char);\n    current_char = current_char + 1;\n  }\n  return;\n}\n\n",
            "called": [
                "serial_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036c6",
            "calling": [
                "report_alarm_message",
                "report_startup_line",
                "report_status_message",
                "report_init_message",
                "report_gcode_parameters",
                "report_realtime_status",
                "report_gcode_modes",
                "report_feedback_message",
                "report_grbl_help",
                "report_grbl_settings"
            ],
            "imported": false,
            "current_name": "write_serial_string_080036c6"
        },
        "FUN_08008190": {
            "renaming": {
                "FUN_08008190": "initialize_usart_08008190",
                "usart_00": "usart_instance",
                "val": "temp_val",
                "usart": "usart_pointer"
            },
            "code": "\nvoid initialize_usart_08008190(void)\n\n{\n  USART_TypeDef *usart_instance;\n  uint32_t temp_val;\n  USART_TypeDef *usart_pointer;\n  \n  usart_instance = DAT_08008240;\n  enable_usart_pointer_clock(DAT_08008240);\n  usart_instance->CR1 = usart_instance->CR1 & 0xffffdfff;\n  usart_instance->CR1 = usart_instance->CR1 & 0xffff400c | 0xc;\n  usart_instance->CR2 = usart_instance->CR2 & 0xffff8090;\n  usart_instance->CR3 = usart_instance->CR3 & 0xfffff000;\n  usart_instance->SR = usart_instance->SR & 0xfffffc00;\n  set_baud_rate(usart_instance,0x1c200);\n  usart_instance->GTPR = usart_instance->GTPR;\n  usart_instance->CR1 = usart_instance->CR1 | 0x2000;\n  return;\n}\n\n",
            "called": [
                "enable_usart_clock",
                "set_baud_rate"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008190",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_usart_08008190"
        },
        "FUN_080074c8": {
            "renaming": {
                "FUN_080074c8": "handle_gpio_interrupts_080074c8",
                "bits": "interrupt_bits"
            },
            "code": "\nvoid handle_gpio_interrupts_080074c8(uint32_t interrupt_bits)\n\n{\n  if ((interrupt_bits & 1) != 0) {\n    gpio_set(0x3e);\n  }\n  if ((*(int *)PTR_limits_enabled_08007518 != 0) && ((interrupt_bits & 0x1e) != 0)) {\n    limits_isr();\n  }\n  if ((*(int *)PTR_buttons_enabled_0800751c != 0) && ((interrupt_bits & 0x80) != 0)) {\n    buttons_isr(interrupt_bits);\n  }\n  return;\n}\n\n",
            "called": [
                "gpio_set",
                "buttons_isr",
                "limits_isr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080074c8",
            "calling": [
                "debounce_isr"
            ],
            "imported": false,
            "current_name": "handle_gpio_interrupts_080074c8"
        },
        "FUN_0800b430": {
            "renaming": {
                "FUN_0800b430": "memset_fast_0800b430",
                "__s": "dst",
                "__c": "value",
                "__n": "num_bytes",
                "uVar1": "num_remaining",
                "puVar2": "dst_ptr",
                "puVar3": "tmp_ptr",
                "puVar4": "next_ptr",
                "uVar5": "value32",
                "bVar6": "is_last_byte"
            },
            "code": "\nvoid * memset_fast_0800b430(void *dst,int value,size_t num_bytes)\n\n{\n  uint num_remaining;\n  uint *dst_ptr;\n  uint *tmp_ptr;\n  uint *next_ptr;\n  uint value32;\n  bool is_last_byte;\n  \n  dst_ptr = (uint *)dst;\n  if (((uint)dst & 3) != 0) {\n    value32 = num_bytes - 1;\n    tmp_ptr = (uint *)dst;\n    if (num_bytes == 0) {\n      return dst;\n    }\n    while( true ) {\n      dst_ptr = (uint *)((int)tmp_ptr + 1);\n      *(char *)tmp_ptr = (char)value;\n      num_bytes = value32;\n      if (((uint)dst_ptr & 3) == 0) break;\n      is_last_byte = value32 == 0;\n      value32 = value32 - 1;\n      tmp_ptr = dst_ptr;\n      if (is_last_byte) {\n        return dst;\n      }\n    }\n  }\n  if (3 < num_bytes) {\n    value32 = value & 0xffU | (value & 0xffU) << 8;\n    value32 = value32 | value32 << 0x10;\n    if (0xf < num_bytes) {\n      tmp_ptr = dst_ptr + 4;\n      do {\n        tmp_ptr[-4] = value32;\n        tmp_ptr[-3] = value32;\n        tmp_ptr[-2] = value32;\n        tmp_ptr[-1] = value32;\n        tmp_ptr = tmp_ptr + 4;\n      } while (tmp_ptr != (uint *)((int)dst_ptr + (num_bytes - 0x10 & 0xfffffff0) + 0x20));\n      num_remaining = num_bytes & 0xc;\n      dst_ptr = dst_ptr + ((num_bytes - 0x10 >> 4) + 1) * 4;\n      num_bytes = num_bytes & 0xf;\n      if (num_remaining == 0) goto joined_r0x0800b4a8;\n    }\n    tmp_ptr = (uint *)((num_bytes - 4 & 0xfffffffc) + 4 + (int)dst_ptr);\n    do {\n      next_ptr = dst_ptr + 1;\n      *dst_ptr = value32;\n      dst_ptr = next_ptr;\n    } while (tmp_ptr != next_ptr);\n    num_bytes = num_bytes & 3;\n    dst_ptr = tmp_ptr;\n  }\njoined_r0x0800b4a8:\n  if (num_bytes != 0) {\n    tmp_ptr = dst_ptr;\n    do {\n      next_ptr = (uint *)((int)tmp_ptr + 1);\n      *(char *)tmp_ptr = (char)value;\n      tmp_ptr = next_ptr;\n    } while ((uint *)(num_bytes + (int)dst_ptr) != next_ptr);\n  }\n  return dst;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b430",
            "calling": [
                "debounce_init",
                "homing_cycle",
                "grbl_main",
                "st_reset",
                "settings_read_coord_data",
                "gc_execute_line",
                "plan_init",
                "gc_init",
                "mc_go_home",
                "eeprom_init"
            ],
            "imported": false,
            "current_name": "memset_fast_0800b430"
        },
        "FUN_08004030": {
            "renaming": {
                "FUN_08004030": "print_status_code_message_08004030",
                "status_code": "statusCode"
            },
            "code": "\nvoid printStatusCodeMessage_08004030(uint8_t statusCode)\n\n{\n  if (statusCode == '\\0') {\n    printPgmString(PTR__etext_08004108);\n  }\n  else {\n    printPgmString(PTR_s_error__0800410c);\n    switch(statusCode) {\n    case '\\x01':\n      printPgmString(PTR_s_Bad_number_format_08004110);\n      break;\n    case '\\x02':\n      printPgmString(PTR_s_Expected_command_letter_08004114);\n      break;\n    case '\\x03':\n      printPgmString(PTR_s_Unsupported_statement_08004118);\n      break;\n    case '\\x04':\n      printPgmString(PTR_s_Invalid_radius_0800411c);\n      break;\n    case '\\x05':\n      printPgmString(PTR_s_Modal_group_violation_08004120);\n      break;\n    case '\\x06':\n      printPgmString(PTR_s_Invalid_statement_08004124);\n      break;\n    case '\\a':\n      printPgmString(PTR_s_Setting_disabled_08004128);\n      break;\n    case '\\b':\n      printPgmString(PTR_s_Value___0_0_0800412c);\n      break;\n    case '\\t':\n      printPgmString(PTR_s_Value___3_usec_08004130);\n      break;\n    case '\\n':\n      printPgmString(PTR_s_EEPROM_read_fail__Using_defaults_08004134);\n      break;\n    case '\\v':\n      printPgmString(PTR_s_Busy_or_queued_08004138);\n      break;\n    case '\\f':\n      printPgmString(PTR_s_Alarm_lock_0800413c);\n      break;\n    case '\\r':\n      printPgmString(PTR_s_Line_overflow_08004140);\n    }\n    printPgmString(PTR_DAT_08004144);\n  }\n  return;\n}\n\n",
            "called": [
                "printPgmString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004030",
            "calling": [
                "settings_init",
                "protocol_execute_line",
                "protocol_process",
                "report_gcode_parameters",
                "gc_init",
                "protocol_execute_startup"
            ],
            "imported": false,
            "current_name": "print_status_code_message_08004030"
        },
        "FUN_08005360": {
            "renaming": {
                "FUN_08005360": "update_counter_08005360",
                "uVar1": "currentValue",
                "uVar2": "updatedValue"
            },
            "code": "\nint updateCounter_08005360(void)\n\n{\n  uint currentValue;\n  uint updatedValue;\n  \n  *(int *)(PTR_st_08005398 + 0x18) =\n       *(int *)(PTR_st_08005398 + 0x14) + *(int *)(PTR_st_08005398 + 0x18);\n  currentValue = DAT_0800539c;\n  updatedValue = *(uint *)(PTR_st_08005398 + 0x18);\n  if (DAT_0800539c < updatedValue) {\n    *(int *)(PTR_st_08005398 + 0x18) = *(int *)(PTR_st_08005398 + 0x18) + -420000;\n  }\n  return (uint)(currentValue < updatedValue);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005360",
            "calling": [
                "step_period_isr"
            ],
            "imported": false,
            "current_name": "update_counter_08005360"
        },
        "FUN_08003980": {
            "renaming": {
                "FUN_08003980": "reset_comment_and_char_counter_08003980"
            },
            "code": "\nvoid resetCommentAndCharCounter_08003980(void)\n\n{\n  *PTR_char_counter_08003998 = 0;\n  *PTR_iscomment_0800399c = 0;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003980",
            "calling": [
                "protocol_process",
                "protocol_init"
            ],
            "imported": false,
            "current_name": "reset_comment_and_char_counter_08003980"
        },
        "FUN_08006de0": {
            "renaming": {
                "FUN_08006de0": "get_pending_irq_status_08006de0",
                "IRQn": "irqNumber",
                "uVar1": "pendingIRQStatus"
            },
            "code": "\nuint32_t getPendingIRQStatus_08006de0(irqNumber_Type irqNumber)\n\n{\n  uint32_t pendingIRQStatus;\n  \n  pendingIRQStatus = NVIC_GetPendingIRQ(irqNumber);\n  return pendingIRQStatus;\n}\n\n",
            "called": [
                "NVIC_GetPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006de0",
            "calling": [],
            "imported": false,
            "current_name": "get_pending_irq_status_08006de0"
        },
        "FUN_08007540": {
            "renaming": {
                "FUN_08007540": "initialize_system_08007540",
                "HAL_Init": "hardwareAbstractionLayerInit",
                "SystemClock_Config": "configureSystemClock",
                "gpio_init": "initializeGPIO",
                "timers_init": "initializeTimers",
                "debounce_init": "initializeDebounce",
                "usart_init": "initializeUSART",
                "startForkserver": "startForkServer"
            },
            "code": "\nint initializeSystem_08007540(void)\n\n{\n  hardwareAbstractionLayerInit();\n  configureSystemClock();\n  initializeGPIO();\n  initializeTimers();\n  initializeDebounce();\n  initializeUSART();\n  startForkServer(0);\n  grbl_initializeSystem_08007540();\n  return 0;\n}\n\n",
            "called": [
                "startForkserver",
                "debounce_init",
                "gpio_init",
                "HAL_Init",
                "grbl_main",
                "SystemClock_Config",
                "timers_init",
                "usart_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007540",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "initialize_system_08007540"
        },
        "FUN_080052dc": {
            "renaming": {
                "FUN_080052dc": "update_register_value_080052dc",
                "x": "inputValue",
                "val": "updatedValue"
            },
            "code": "\nvoid updateRegisterValue_080052dc(uint32_t inputValue)\n\n{\n  uint32_t updatedValue;\n  \n  *(uint32_t *)(DAT_08005308 + 0inputValue14) = inputValue | *(uint *)(DAT_08005308 + 0inputValue14) & 0inputValuefffff55f;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052dc",
            "calling": [
                "step_period_isr"
            ],
            "imported": false,
            "current_name": "update_register_value_080052dc"
        },
        "FUN_080064ec": {
            "renaming": {
                "FUN_080064ec": "calculate_system_clock_080064ec",
                "uVar1": "temp_var1",
                "uVar2": "temp_var2",
                "pllp": "pll_p",
                "pllm": "pll_m",
                "sysclockfreq": "sys_clock_freq",
                "pllvco": "pll_vco"
            },
            "code": "\nuint32_t calculate_system_clock_080064ec(void)\n\n{\n  uint temp_var1;\n  uint temp_var2;\n  uint32_t result_6;\n  uint32_t result_7;\n  uint32_t result_4;\n  uint32_t result_5;\n  uint32_t result_2;\n  uint32_t result_3;\n  uint32_t result;\n  uint32_t result_1;\n  uint32_t pll_p;\n  uint32_t pll_m;\n  uint32_t sys_clock_freq;\n  uint32_t pll_vco;\n  \n  temp_var1 = *(uint *)(DAT_0800661c + 8) & 0xc;\n  if (temp_var1 == 8) {\n    temp_var2 = *(uint *)(DAT_0800661c + 4) & 0x3f;\n    temp_var1 = count_leading_zeroes(0x200);\n    if ((*(uint *)(DAT_0800661c + 4) & 0x400000) >> (temp_var1 & 0xff) == 0) {\n      temp_var1 = count_leading_zeroes(0x3fe0000);\n      pll_vco = ((*(uint *)(DAT_0800661c + 4) & 0x7fc0) >> (temp_var1 & 0xff)) * (DAT_08006620 / temp_var2);\n    }\n    else {\n      temp_var1 = count_leading_zeroes(0x3fe0000);\n      pll_vco = ((*(uint *)(DAT_0800661c + 4) & 0x7fc0) >> (temp_var1 & 0xff)) * (DAT_08006624 / temp_var2);\n    }\n    temp_var1 = count_leading_zeroes(0xc000);\n    return pll_vco / ((((*(uint *)(DAT_0800661c + 4) & 0x30000) >> (temp_var1 & 0xff)) + 1) * 2);\n  }\n  if (temp_var1 < 9) {\n    if (temp_var1 == 0) {\n      return DAT_08006620;\n    }\n    if (temp_var1 == 4) {\n      return DAT_08006624;\n    }\n  }\n  return DAT_08006620;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064ec",
            "calling": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "imported": false,
            "current_name": "calculate_system_clock_080064ec"
        },
        "FUN_08006ba0": {
            "renaming": {
                "FUN_08006ba0": "calculate_priority_value_08006ba0",
                "PriorityGroup": "priorityGroup",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "uVar1": "priorityGroupMask",
                "uVar2": "preemptPriorityMask",
                "SubPriorityBits": "subPriorityBits",
                "PreemptPriorityBits": "preemptPriorityBits",
                "PriorityGroupTmp": "priorityGroupTemp"
            },
            "code": "\nuint32_t calculatePriorityValue_08006ba0(uint32_t priorityGroup,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint priorityGroupMask;\n  uint preemptPriorityMask;\n  uint32_t subPriorityBits;\n  uint32_t preemptPriorityBits;\n  uint32_t priorityGroupTemp;\n  \n  priorityGroupMask = priorityGroup & 7;\n  preemptPriorityMask = 7 - priorityGroupMask;\n  if (3 < preemptPriorityMask) {\n    preemptPriorityMask = 4;\n  }\n  if (priorityGroupMask + 4 < 7) {\n    priorityGroupMask = 0;\n  }\n  else {\n    priorityGroupMask = priorityGroupMask - 3;\n  }\n  return subPriority & (1 << (priorityGroupMask & 0xff)) - 1U |\n         ((1 << (preemptPriorityMask & 0xff)) - 1U & preemptPriority) << (priorityGroupMask & 0xff);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006ba0",
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "imported": false,
            "current_name": "calculate_priority_value_08006ba0"
        },
        "FUN_080003ec": {
            "renaming": {
                "FUN_080003ec": "read_eeprom_data_080003ec",
                "destination": "dest_buffer",
                "source": "source_address",
                "size": "data_size",
                "cVar1": "temp_char",
                "local_1c": "remaining_size",
                "local_18": "current_address",
                "local_14": "current_dest",
                "data": "unused_data",
                "checksum": "computed_checksum"
            },
            "code": "\nint read_eeprom_data_080003ec(char *dest_buffer,uint source_address,uint data_size)\n\n{\n  char temp_char;\n  uint remaining_size;\n  uint current_address;\n  char *current_dest;\n  uchar unused_data;\n  uchar computed_checksum;\n  \n  computed_checksum = '\\0';\n  remaining_size = data_size;\n  current_address = source_address;\n  current_dest = dest_buffer;\n  if (*(int *)PTR_eeprom_ready_08000470 == 0) {\n    eeprom_init();\n    current_address = source_address;\n    current_dest = dest_buffer;\n  }\n  for (; remaining_size != 0; remaining_size = remaining_size - 1) {\n    temp_char = eeprom_get_char(current_address);\n    computed_checksum = temp_char + (computed_checksum != '\\0');\n    *current_dest = temp_char;\n    current_address = current_address + 1;\n    current_dest = current_dest + 1;\n  }\n  temp_char = eeprom_get_char(current_address);\n  return (uint)((uint)computed_checksum == (int)temp_char);\n}\n\n",
            "called": [
                "eeprom_get_char",
                "eeprom_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080003ec",
            "calling": [
                "settings_read_coord_data",
                "read_global_settings",
                "settings_read_startup_line"
            ],
            "imported": false,
            "current_name": "read_eeprom_data_080003ec"
        },
        "FUN_08002896": {
            "renaming": {
                "FUN_08002896": "calculate_modified_value_08002896",
                "block_index": "inputValue",
                "local_9": "result"
            },
            "code": "\nuint8_t calculateModifiedValue_08002896(uint8_t inputValue)\n\n{\n  uint8_t result;\n  \n  result = inputValue;\n  if (inputValue == '\\0') {\n    result = '\\x12';\n  }\n  return result + 0xff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002896",
            "calling": [
                "planner_reverse_pass"
            ],
            "imported": false,
            "current_name": "calculate_modified_value_08002896"
        },
        "FUN_0800a348": {
            "renaming": {
                "FUN_0800a348": "calculate_result_0800a348",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "intVar1",
                "uVar2": "uintVar2",
                "uVar3": "uintVar3",
                "uVar4": "uintVar4",
                "uVar5": "uintVar5",
                "uVar6": "uintVar6",
                "uVar7": "uintVar7",
                "lVar8": "longVar8",
                "local_30": "localVar30",
                "uStack_2c": "uStackVar2c",
                "local_28": "localVar28",
                "uStack_24": "uStackVar24"
            },
            "code": "\nundefined4 calculate_result_0800a348(undefined4 input1,uint input2,undefined4 input3,undefined4 input4)\n\n{\n  int intVar1;\n  undefined4 uintVar2;\n  undefined4 uintVar3;\n  uint uintVar4;\n  undefined8 uintVar5;\n  undefined8 uintVar6;\n  undefined8 uintVar7;\n  longlong longVar8;\n  undefined4 localVar30;\n  undefined4 uStackVar2c;\n  undefined4 localVar28;\n  undefined4 uStackVar24;\n  \n  uintVar4 = input2 & 0x7fffffff;\n  if (uintVar4 < 0x3e400000) {\n    intVar1 = __aeabi_d2iz();\n    if (intVar1 == 0) {\n      return 0;\n    }\n    uintVar5 = __muldf3(input1,input2,input1,input2);\n    uintVar3 = (undefined4)((ulonglong)uintVar5 >> 0x20);\n    uintVar2 = (undefined4)uintVar5;\n    uintVar6 = __muldf3(uintVar2,uintVar3,DAT_0800a558,DAT_0800a55c);\n    uintVar6 = __aeabi_dadd((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),DAT_0800a560,DAT_0800a564);\n    uintVar6 = __muldf3((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),uintVar2,uintVar3);\n    uintVar6 = __subdf3((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),DAT_0800a568,DAT_0800a56c);\n    uintVar6 = __muldf3((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),uintVar2,uintVar3);\n    uintVar6 = __aeabi_dadd((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),DAT_0800a570,DAT_0800a574);\n    uintVar6 = __muldf3((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),uintVar2,uintVar3);\n    uintVar6 = __subdf3((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),DAT_0800a578,DAT_0800a57c);\n    uintVar6 = __muldf3((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),uintVar2,uintVar3);\n    uintVar6 = __aeabi_dadd((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),DAT_0800a580,DAT_0800a584);\n    uintVar6 = __muldf3((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),uintVar2,uintVar3);\n  }\n  else {\n    uintVar5 = __muldf3(input1,input2,input1,input2);\n    uintVar3 = (undefined4)((ulonglong)uintVar5 >> 0x20);\n    uintVar2 = (undefined4)uintVar5;\n    uintVar6 = __muldf3(uintVar2,uintVar3,DAT_0800a558,DAT_0800a55c);\n    uintVar6 = __aeabi_dadd((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),DAT_0800a560,DAT_0800a564);\n    uintVar6 = __muldf3((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),uintVar2,uintVar3);\n    uintVar6 = __subdf3((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),DAT_0800a568,DAT_0800a56c);\n    uintVar6 = __muldf3((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),uintVar2,uintVar3);\n    uintVar6 = __aeabi_dadd((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),DAT_0800a570,DAT_0800a574);\n    uintVar6 = __muldf3((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),uintVar2,uintVar3);\n    uintVar6 = __subdf3((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),DAT_0800a578,DAT_0800a57c);\n    uintVar6 = __muldf3((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),uintVar2,uintVar3);\n    uintVar6 = __aeabi_dadd((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),DAT_0800a580,DAT_0800a584);\n    uintVar6 = __muldf3((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),uintVar2,uintVar3);\n    if (DAT_0800a590 < (int)uintVar4) {\n      if (DAT_0800a594 < (int)uintVar4) {\n        longVar8 = (ulonglong)DAT_0800a598 << 0x20;\n        intVar1 = DAT_0800a59c;\n      }\n      else {\n        longVar8 = __subdf3(0,DAT_0800a58c,0,uintVar4 - 0x200000);\n        intVar1 = uintVar4 - 0x200000;\n      }\n      uStackVar24 = (undefined4)((ulonglong)longVar8 >> 0x20);\n      localVar28 = (undefined4)longVar8;\n      uintVar5 = __muldf3(uintVar2,uintVar3,0,DAT_0800a588);\n      uintVar5 = __subdf3((int)uintVar5,(int)((ulonglong)uintVar5 >> 0x20),0,intVar1);\n      uintVar6 = __muldf3(uintVar2,uintVar3,(int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20));\n      uintVar7 = __muldf3(input1,input2,input3,input4);\n      uintVar6 = __subdf3((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),(int)uintVar7,\n                       (int)((ulonglong)uintVar7 >> 0x20));\n      uintVar5 = __subdf3((int)uintVar5,(int)((ulonglong)uintVar5 >> 0x20),(int)uintVar6,\n                       (int)((ulonglong)uintVar6 >> 0x20));\n      uintVar2 = __subdf3(localVar28,uStackVar24,(int)uintVar5,(int)((ulonglong)uintVar5 >> 0x20));\n      return uintVar2;\n    }\n  }\n  uStackVar2c = (undefined4)((ulonglong)uintVar6 >> 0x20);\n  localVar30 = (undefined4)uintVar6;\n  uintVar2 = (undefined4)((ulonglong)uintVar5 >> 0x20);\n  uintVar6 = __muldf3((int)uintVar5,uintVar2,0,DAT_0800a588);\n  uintVar5 = __muldf3((int)uintVar5,uintVar2,localVar30,uStackVar2c);\n  uintVar7 = __muldf3(input1,input2,input3,input4);\n  uintVar5 = __subdf3((int)uintVar5,(int)((ulonglong)uintVar5 >> 0x20),(int)uintVar7,\n                   (int)((ulonglong)uintVar7 >> 0x20));\n  uintVar5 = __subdf3((int)uintVar6,(int)((ulonglong)uintVar6 >> 0x20),(int)uintVar5,\n                   (int)((ulonglong)uintVar5 >> 0x20));\n  uintVar2 = __subdf3(0,DAT_0800a58c,(int)uintVar5,(int)((ulonglong)uintVar5 >> 0x20));\n  return uintVar2;\n}\n\n",
            "called": [
                "__muldf3",
                "__aeabi_d2iz",
                "__aeabi_dadd",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a348",
            "calling": [
                "cos",
                "sin"
            ],
            "imported": false,
            "current_name": "calculate_result_0800a348"
        },
        "FUN_080001ac": {
            "renaming": {
                "FUN_080001ac": "initialize_object_080001ac",
                "param_1": "init_ptr",
                "param_2": "object_ptr"
            },
            "code": "\nundefined8 initialize_object_080001ac(undefined *init_ptr,undefined *object_ptr)\n\n{\n  if (DAT_080001bc != 0) {\n    init_ptr = PTR__init_080001c4;\n    object_ptr = PTR_object_8916_080001c0;\n  }\n  return CONCAT44(object_ptr,init_ptr);\n}\n\n",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001ac",
            "calling": [
                "__libc_fini_array",
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "initialize_object_080001ac"
        },
        "FUN_08003740": {
            "renaming": {
                "FUN_08003740": "print_uint8_as_binary_08003740",
                "n": "number"
            },
            "code": "\nvoid print_uint8_as_binary_08003740(uinumbert8_t number)\n\n{\n  prinumbert_base2((uinumbert)number,8);\n  returnumber;\n}\n\n",
            "called": [
                "print_base2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003740",
            "calling": [],
            "imported": false,
            "current_name": "print_uint8_as_binary_08003740"
        },
        "FUN_08000478": {
            "renaming": {
                "FUN_08000478": "set_axis_values_08000478",
                "axis_0": "x_axis",
                "axis_1": "y_axis",
                "axis_2": "z_axis"
            },
            "code": "\nvoid setAxisValues_08000478(uint8_t x_axis,uint8_t y_axis,uint8_t z_axis)\n\n{\n  PTR_gc_080004a8[0x19] = x_axis;\n  PTR_gc_080004a8[0x1a] = y_axis;\n  PTR_gc_080004a8[0x1b] = z_axis;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000478",
            "calling": [
                "gc_execute_line",
                "gc_init"
            ],
            "imported": false,
            "current_name": "set_axis_values_08000478"
        },
        "FUN_08006d2e": {
            "renaming": {
                "FUN_08006d2e": "enable_interrupt_08006d2e",
                "IRQn": "interruptNumber"
            },
            "code": "\nvoid enableInterrupt_08006d2e(interruptNumber_Type interruptNumber)\n\n{\n  NVIC_EnableIRQ(interruptNumber);\n  return;\n}\n\n",
            "called": [
                "NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d2e",
            "calling": [],
            "imported": false,
            "current_name": "enable_interrupt_08006d2e"
        },
        "FUN_08007e1c": {
            "renaming": {
                "FUN_08007e1c": "send_usart_char_08007e1c",
                "usart": "usart_ptr"
            },
            "code": "\nvoid send_USART_char_08007e1c(char c)\n\n{\n  USART_TypeDef *usart_ptr;\n  \n  do {\n  } while ((*DAT_08007e48 & 0x80) == 0);\n  DAT_08007e48[1] = (uint)(byte)c;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e1c",
            "calling": [
                "__io_putchar",
                "serial_write"
            ],
            "imported": false,
            "current_name": "send_usart_char_08007e1c"
        },
        "FUN_0800adf0": {
            "renaming": {
                "FUN_0800adf0": "calculate_result_0800adf0",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "param_5": "flag",
                "iVar1": "intVar",
                "uVar2": "result1",
                "uVar3": "result2",
                "uVar4": "result3",
                "uVar5": "result4",
                "uVar6": "result5",
                "uVar7": "intermediateResult",
                "uVar8": "tempResult"
            },
            "code": "\nundefined4\ncalculate_result_0800adf0(undefined4 input1,uint input2,undefined4 input3,undefined4 input4,int flag)\n\n{\n  int intVar;\n  undefined4 result1;\n  undefined4 result2;\n  undefined4 result3;\n  undefined4 result4;\n  undefined4 result5;\n  undefined8 intermediateResult;\n  undefined8 tempResult;\n  \n  if (((input2 & 0x7fffffff) < 0x3e400000) && (intVar = __aeabi_d2iz(), intVar == 0)) {\n    return input1;\n  }\n  intermediateResult = __muldf3(input1,input2,input1);\n  result3 = (undefined4)((ulonglong)intermediateResult >> 0x20);\n  result2 = (undefined4)intermediateResult;\n  intermediateResult = __muldf3(input1,input2,result2,result3);\n  result4 = (undefined4)((ulonglong)intermediateResult >> 0x20);\n  result1 = (undefined4)intermediateResult;\n  intermediateResult = __muldf3(result2,result3,DAT_0800af40,DAT_0800af44);\n  intermediateResult = __subdf3((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),DAT_0800af48,DAT_0800af4c);\n  intermediateResult = __muldf3((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),result2,result3);\n  intermediateResult = __aeabi_dadd((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),DAT_0800af50,DAT_0800af54);\n  intermediateResult = __muldf3((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),result2,result3);\n  intermediateResult = __subdf3((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),DAT_0800af58,DAT_0800af5c);\n  intermediateResult = __muldf3((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),result2,result3);\n  intermediateResult = __aeabi_dadd((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),DAT_0800af60,DAT_0800af64);\n  result5 = (undefined4)((ulonglong)intermediateResult >> 0x20);\n  if (flag != 0) {\n    tempResult = __muldf3(input3,input4,0,DAT_0800af70);\n    intermediateResult = __muldf3(result1,result4,(int)intermediateResult,result5);\n    intermediateResult = __subdf3((int)tempResult,(int)((ulonglong)tempResult >> 0x20),(int)intermediateResult,\n                     (int)((ulonglong)intermediateResult >> 0x20));\n    intermediateResult = __muldf3((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),result2,result3);\n    intermediateResult = __subdf3((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),input3,input4);\n    tempResult = __muldf3(result1,result4,DAT_0800af68,DAT_0800af6c);\n    intermediateResult = __aeabi_dadd((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),(int)tempResult,\n                         (int)((ulonglong)tempResult >> 0x20));\n    result2 = __subdf3(input1,input2,(int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20));\n    return result2;\n  }\n  intermediateResult = __muldf3(result2,result3,(int)intermediateResult,result5);\n  intermediateResult = __subdf3((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),DAT_0800af68,DAT_0800af6c);\n  intermediateResult = __muldf3((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),result1,result4);\n  result2 = __aeabi_dadd((int)intermediateResult,(int)((ulonglong)intermediateResult >> 0x20),input1,input2);\n  return result2;\n}\n\n",
            "called": [
                "__muldf3",
                "__aeabi_d2iz",
                "__aeabi_dadd",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800adf0",
            "calling": [
                "cos",
                "sin"
            ],
            "imported": false,
            "current_name": "calculate_result_0800adf0"
        },
        "FUN_08003a74": {
            "renaming": {
                "FUN_08003a74": "handle_system_events_08003a74",
                "bVar1": "system_status",
                "rt_exec": "realtime_execution"
            },
            "code": "\nvoid handle_system_events_08003a74(void)\n\n{\n  byte system_status;\n  uint8_t realtime_execution;\n  \n  if (PTR_sys_08003b90[2] != '\\0') {\n    system_status = PTR_sys_08003b90[2];\n    if ((system_status & 0x60) != 0) {\n      PTR_sys_08003b90[1] = 6;\n      if ((system_status & 0x40) == 0) {\n        report_alarm_message(-2);\n      }\n      else {\n        report_alarm_message(-1);\n        report_feedback_message('\\x01');\n        PTR_sys_08003b90[2] = PTR_sys_08003b90[2] & 0xef;\n        do {\n        } while ((PTR_sys_08003b90[2] & 0x10) == 0);\n      }\n      PTR_sys_08003b90[2] = PTR_sys_08003b90[2] & 0x9f;\n    }\n    if ((system_status & 0x10) == 0) {\n      if ((system_status & 1) != 0) {\n        report_realtime_status();\n        PTR_sys_08003b90[2] = PTR_sys_08003b90[2] & 0xfe;\n      }\n      if ((system_status & 8) != 0) {\n        st_feed_hold();\n        PTR_sys_08003b90[2] = PTR_sys_08003b90[2] & 0xf7;\n      }\n      if ((system_status & 4) != 0) {\n        st_cycle_reinitialize();\n        PTR_sys_08003b90[2] = PTR_sys_08003b90[2] & 0xfb;\n      }\n      if ((system_status & 2) != 0) {\n        st_cycle_start();\n        if ((PTR_settings_08003b94[0x28] & 2) != 0) {\n          PTR_sys_08003b90[0x10] = 1;\n        }\n        PTR_sys_08003b90[2] = PTR_sys_08003b90[2] & 0xfd;\n      }\n    }\n    else {\n      *PTR_sys_08003b90 = 1;\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "report_alarm_message",
                "st_cycle_reinitialize",
                "report_realtime_status",
                "report_feedback_message",
                "st_feed_hold",
                "st_cycle_start"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a74",
            "calling": [
                "protocol_process",
                "grbl_main",
                "plan_synchronize",
                "mc_go_home",
                "mc_dwell",
                "mc_line"
            ],
            "imported": false,
            "current_name": "handle_system_events_08003a74"
        },
        "FUN_08005cec": {
            "renaming": {
                "FUN_08005cec": "configure_oscillators_08005cec",
                "RCC_OscInitStruct": "Oscillator_Config",
                "uVar1": "start_tick",
                "uVar2": "current_tick",
                "uVar3": "PLLN_leading_zeroes",
                "uVar4": "PLLP_leading_zeroes",
                "uVar5": "PLLQ_leading_zeroes",
                "result_2": "unused_result_2",
                "result_3": "unused_result_3",
                "result_4": "unused_result_4",
                "result_5": "unused_result_5",
                "result_6": "unused_result_6",
                "result_7": "unused_result_7",
                "result": "unused_result",
                "result_1": "unused_result_1",
                "timeout": "unused_timeout"
            },
            "code": "\nHAL_StatusTypeDef Configure_Oscillators_08005cec(RCC_OscInitTypeDef *Oscillator_Config)\n\n{\n  uint32_t start_tick;\n  uint32_t current_tick;\n  uint PLLN_leading_zeroes;\n  uint PLLP_leading_zeroes;\n  uint PLLQ_leading_zeroes;\n  uint32_t unused_result_2;\n  uint32_t unused_result_3;\n  uint32_t unused_result_4;\n  uint32_t unused_result_5;\n  uint32_t unused_result_6;\n  uint32_t unused_result_7;\n  uint32_t unused_result;\n  uint32_t unused_result_1;\n  uint32_t unused_timeout;\n  \n  if ((Oscillator_Config->OscillatorType & 1) != 0) {\n    if (((DAT_08005fac[2] & 0xc) == 4) ||\n       (((DAT_08005fac[2] & 0xc) == 8 && ((DAT_08005fac[1] & 0x400000) == 0x400000)))) {\n      if (((*DAT_08005fac & 0x20000) != 0) && (Oscillator_Config->HSEState != 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      *DAT_08005fb0 = 0;\n      start_tick = HAL_GetTick();\n      while ((*DAT_08005fac & 0x20000) != 0) {\n        current_tick = HAL_GetTick();\n        if (start_tick + 5000 <= current_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      *DAT_08005fb0 = (char)Oscillator_Config->HSEState;\n      if (Oscillator_Config->HSEState == 1) {\n        start_tick = HAL_GetTick();\n        while ((*DAT_08005fac & 0x20000) == 0) {\n          current_tick = HAL_GetTick();\n          if (start_tick + 5000 <= current_tick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        start_tick = HAL_GetTick();\n        while ((*DAT_08005fac & 0x20000) != 0) {\n          current_tick = HAL_GetTick();\n          if (start_tick + 5000 <= current_tick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((Oscillator_Config->OscillatorType & 2) != 0) {\n    if (((DAT_08005fac[2] & 0xc) == 0) ||\n       (((DAT_08005fac[2] & 0xc) == 8 && ((DAT_08005fac[1] & 0x400000) == 0)))) {\n      if (((*DAT_08005fac & 2) != 0) && (Oscillator_Config->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else if (Oscillator_Config->HSIState == 0) {\n      *DAT_08005fb4 = 0;\n      start_tick = HAL_GetTick();\n      while ((*DAT_08005fac & 2) != 0) {\n        current_tick = HAL_GetTick();\n        if (start_tick + 100 <= current_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005fb4 = 1;\n      start_tick = HAL_GetTick();\n      while ((*DAT_08005fac & 2) == 0) {\n        current_tick = HAL_GetTick();\n        if (start_tick + 100 <= current_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      PLLN_leading_zeroes = count_leading_zeroes(0x1f000000);\n      *DAT_08005fac =\n           Oscillator_Config->HSICalibrationValue << (PLLN_leading_zeroes & 0xff) | *DAT_08005fac & 0xffffff07;\n    }\n  }\n  if ((Oscillator_Config->OscillatorType & 8) != 0) {\n    if (Oscillator_Config->LSIState == 0) {\n      *DAT_08005fb8 = 0;\n      start_tick = HAL_GetTick();\n      while ((DAT_08005fac[0x1d] & 2) != 0) {\n        current_tick = HAL_GetTick();\n        if (start_tick + 100 <= current_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005fb8 = 1;\n      start_tick = HAL_GetTick();\n      while ((DAT_08005fac[0x1d] & 2) == 0) {\n        current_tick = HAL_GetTick();\n        if (start_tick + 100 <= current_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((Oscillator_Config->OscillatorType & 4) != 0) {\n    DAT_08005fac[0x10] = DAT_08005fac[0x10] | 0x10000000;\n    *DAT_08005fbc = *DAT_08005fbc | 0x100;\n    start_tick = HAL_GetTick();\n    while ((*DAT_08005fbc & 0x100) == 0) {\n      current_tick = HAL_GetTick();\n      if (start_tick + 100 <= current_tick) {\n        return HAL_TIMEOUT;\n      }\n    }\n    *DAT_08005fc0 = 0;\n    start_tick = HAL_GetTick();\n    while ((DAT_08006180[0x1c] & 2) != 0) {\n      current_tick = HAL_GetTick();\n      if (start_tick + 5000 <= current_tick) {\n        return HAL_TIMEOUT;\n      }\n    }\n    *DAT_08006184 = (char)Oscillator_Config->LSEState;\n    if (Oscillator_Config->LSEState == 1) {\n      start_tick = HAL_GetTick();\n      while ((DAT_08006180[0x1c] & 2) == 0) {\n        current_tick = HAL_GetTick();\n        if (start_tick + 5000 <= current_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      start_tick = HAL_GetTick();\n      while ((DAT_08006180[0x1c] & 2) != 0) {\n        current_tick = HAL_GetTick();\n        if (start_tick + 5000 <= current_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((Oscillator_Config->PLL).PLLState != 0) {\n    if ((DAT_08006180[2] & 0xc) == 8) {\n      return HAL_ERROR;\n    }\n    if ((Oscillator_Config->PLL).PLLState == 2) {\n      *DAT_08006188 = 0;\n      start_tick = HAL_GetTick();\n      while ((*DAT_08006180 & 0x2000000) != 0) {\n        current_tick = HAL_GetTick();\n        if (start_tick + 100 <= current_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      PLLN_leading_zeroes = count_leading_zeroes(0x3fe0000);\n      PLLP_leading_zeroes = count_leading_zeroes(0xc000);\n      PLLQ_leading_zeroes = count_leading_zeroes(0xf0);\n      DAT_08006180[1] =\n           (Oscillator_Config->PLL).PLLQ << (PLLQ_leading_zeroes & 0xff) |\n           (Oscillator_Config->PLL).PLLM | (Oscillator_Config->PLL).PLLN << (PLLN_leading_zeroes & 0xff) |\n           ((Oscillator_Config->PLL).PLLP >> 1) - 1 << (PLLP_leading_zeroes & 0xff) |\n           (Oscillator_Config->PLL).PLLSource | 0x20000000;\n      *DAT_08006188 = 1;\n      start_tick = HAL_GetTick();\n      while ((*DAT_08006180 & 0x2000000) == 0) {\n        current_tick = HAL_GetTick();\n        if (start_tick + 100 <= current_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08006188 = 0;\n      start_tick = HAL_GetTick();\n      while ((*DAT_08006180 & 0x2000000) != 0) {\n        current_tick = HAL_GetTick();\n        if (start_tick + 100 <= current_tick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005cec",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configure_oscillators_08005cec"
        },
        "FUN_08006b00": {
            "renaming": {
                "FUN_08006b00": "set_interrupt_priority_08006b00",
                "IRQn": "interruptType",
                "priority": "interruptPriority",
                "WWDG_IRQn": "watchdogInterrupt"
            },
            "code": "\nvoid setInterruptPriority_08006b00(interruptType_Type interruptType,uint32_t interruptPriority)\n\n{\n  if (interruptType < watchdogInterrupt) {\n    *(char *)(((byte)interruptType & 0xf) + DAT_08006b4c + 0x14) = (char)((interruptPriority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interruptType + DAT_08006b50 + 0x300) = (char)((interruptPriority & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b00",
            "calling": [
                "HAL_NVIC_SetPriority",
                "SysTick_Config"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_08006b00"
        },
        "FUN_0800b4d0": {
            "renaming": {
                "FUN_0800b4d0": "register_exit_function_0800b4d0"
            },
            "code": "\nvoid registerExitFunction_0800b4d0(void)\n\n{\n  if (DAT_0800b4dc != 0) {\n    atexit(DAT_0800b4e0);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b4d0",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "register_exit_function_0800b4d0"
        },
        "FUN_08007f54": {
            "renaming": {
                "FUN_08007f54": "configure_usart_baud_rate_08007f54",
                "usart": "usart_instance",
                "baud": "baud_rate",
                "uVar1": "multiplier",
                "uVar2": "pclk_freq",
                "uVar3": "temp_pclk_freq1",
                "uVar4": "temp_pclk_freq2"
            },
            "code": "\nvoid configure_usart_baud_rate_08007f54(USART_TypeDef *usart_instance,int baud_rate)\n\n{\n  ulonglong multiplier;\n  uint32_t pclk_freq;\n  uint32_t temp_pclk_freq1;\n  uint32_t temp_pclk_freq2;\n  \n  if ((usart_instance->CR1 & 0x8000) == 0) {\n    if ((usart_instance == DAT_08008184) || (usart_instance == DAT_08008188)) {\n      pclk_freq = HAL_RCC_GetPCLK2Freq();\n      multiplier = (ulonglong)DAT_0800818c;\n      temp_pclk_freq1 = HAL_RCC_GetPCLK2Freq();\n      temp_pclk_freq2 = HAL_RCC_GetPCLK2Freq();\n      usart_instance->BRR = (uint)(multiplier * ((ulonglong)(pclk_freq * 0x19) / (ulonglong)(uint)(baud_rate << 2)) >> 0x25\n                         ) << 4 |\n                   (uint)((ulonglong)DAT_0800818c *\n                          (ulonglong)\n                          (((temp_pclk_freq1 * 0x19) / (uint)(baud_rate << 2) +\n                           (uint)((ulonglong)DAT_0800818c *\n                                  ((ulonglong)(temp_pclk_freq2 * 0x19) / (ulonglong)(uint)(baud_rate << 2)) >> 0x25\n                                 ) * -100) * 0x10 + 0x32) >> 0x25) & 0xf;\n    }\n    else {\n      pclk_freq = HAL_RCC_GetPCLK1Freq();\n      multiplier = (ulonglong)DAT_0800818c;\n      temp_pclk_freq1 = HAL_RCC_GetPCLK1Freq();\n      temp_pclk_freq2 = HAL_RCC_GetPCLK1Freq();\n      usart_instance->BRR = (uint)(multiplier * ((ulonglong)(pclk_freq * 0x19) / (ulonglong)(uint)(baud_rate << 2)) >> 0x25\n                         ) << 4 |\n                   (uint)((ulonglong)DAT_0800818c *\n                          (ulonglong)\n                          (((temp_pclk_freq1 * 0x19) / (uint)(baud_rate << 2) +\n                           (uint)((ulonglong)DAT_0800818c *\n                                  ((ulonglong)(temp_pclk_freq2 * 0x19) / (ulonglong)(uint)(baud_rate << 2)) >> 0x25\n                                 ) * -100) * 0x10 + 0x32) >> 0x25) & 0xf;\n    }\n  }\n  else if ((usart_instance == DAT_08008184) || (usart_instance == DAT_08008188)) {\n    pclk_freq = HAL_RCC_GetPCLK2Freq();\n    multiplier = (ulonglong)DAT_0800818c;\n    temp_pclk_freq1 = HAL_RCC_GetPCLK2Freq();\n    temp_pclk_freq2 = HAL_RCC_GetPCLK2Freq();\n    usart_instance->BRR = (uint)(multiplier * ((ulonglong)(pclk_freq * 0x19) / (ulonglong)(uint)(baud_rate << 1)) >> 0x25)\n                 << 4 | (uint)((ulonglong)DAT_0800818c *\n                               (ulonglong)\n                               (((temp_pclk_freq1 * 0x19) / (uint)(baud_rate << 1) +\n                                (uint)((ulonglong)DAT_0800818c *\n                                       ((ulonglong)(temp_pclk_freq2 * 0x19) / (ulonglong)(uint)(baud_rate << 1)) >>\n                                      0x25) * -100) * 0x10 + 0x32) >> 0x25) & 0xf;\n  }\n  else {\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n    multiplier = (ulonglong)DAT_0800818c;\n    temp_pclk_freq1 = HAL_RCC_GetPCLK1Freq();\n    temp_pclk_freq2 = HAL_RCC_GetPCLK1Freq();\n    usart_instance->BRR = (uint)(multiplier * ((ulonglong)(pclk_freq * 0x19) / (ulonglong)(uint)(baud_rate << 1)) >> 0x25)\n                 << 4 | (uint)((ulonglong)DAT_0800818c *\n                               (ulonglong)\n                               (((temp_pclk_freq1 * 0x19) / (uint)(baud_rate << 1) +\n                                (uint)((ulonglong)DAT_0800818c *\n                                       ((ulonglong)(temp_pclk_freq2 * 0x19) / (ulonglong)(uint)(baud_rate << 1)) >>\n                                      0x25) * -100) * 0x10 + 0x32) >> 0x25) & 0xf;\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f54",
            "calling": [
                "usart_init"
            ],
            "imported": false,
            "current_name": "configure_usart_baud_rate_08007f54"
        },
        "FUN_08003b98": {
            "renaming": {
                "FUN_08003b98": "process_line_08003b98",
                "line": "input_line",
                "bVar1": "current_char",
                "uVar2": "return_value",
                "iVar3": "float_read_status",
                "uVar4": "double_value",
                "extraout_r1": "extra_output_r1",
                "uVar5": "char_index",
                "in_stack_ffffffe0": "stack_value",
                "value": "parsed_value",
                "parameter": "parsed_parameter",
                "char_counter": "char_position",
                "helper_var": "is_startup_line"
            },
            "code": "\nuint8_t process_line_08003b98(char *input_line)\n\n{\n  byte current_char;\n  uint8_t return_value;\n  int float_read_status;\n  undefined4 double_value;\n  undefined4 extra_output_r1;\n  uint char_index;\n  float parsed_value_00;\n  undefined4 stack_value;\n  float parsed_value;\n  float parsed_parameter;\n  uint8_t char_position;\n  uint8_t is_startup_line;\n  \n  if (*input_line != '$') {\n    return_value = gc_execute_input_line(input_line);\n    return return_value;\n  }\n  char_position = '\\x01';\n  is_startup_line = '\\0';\n  current_char = input_line[1];\n  if (current_char == 0) {\n    report_grbl_help();\n    return '\\0';\n  }\n  if ((0x58 < current_char) || (current_char < 0x23)) goto switchD_08003bdc_caseD_25;\n  switch(current_char) {\n  case 0x23:\n    char_position = '\\x02';\n    if (input_line[2] != '\\0') {\n      return '\\x03';\n    }\n    report_gcode_parsed_parameters();\n    break;\n  case 0x24:\n    char_position = '\\x02';\n    if (input_line[2] != '\\0') {\n      return '\\x03';\n    }\n    report_grbl_settings();\n    break;\n  case 0x43:\n    char_position = '\\x02';\n    if (input_line[2] != '\\0') {\n      return '\\x03';\n    }\n    if (PTR_sys_08003f2c[1] == '\\a') {\n      mc_reset();\n      report_feedback_message('\\x05');\n    }\n    else {\n      if (PTR_sys_08003f2c[1] != '\\0') {\n        return '\\v';\n      }\n      PTR_sys_08003f2c[1] = 7;\n      report_feedback_message('\\x04');\n    }\n    break;\n  case 0x47:\n    char_position = '\\x02';\n    if (input_line[2] != '\\0') {\n      return '\\x03';\n    }\n    report_gcode_modes();\n    break;\n  case 0x48:\n    if ((PTR_settings_08003f30[0x28] & 0x10) == 0) {\n      return '\\a';\n    }\n    if ((PTR_sys_08003f2c[1] != '\\0') && (PTR_sys_08003f2c[1] != '\\x06')) {\n      return '\\v';\n    }\n    mc_go_home();\n    if (*PTR_sys_08003f2c == '\\0') {\n      protocol_execute_startup();\n    }\n    break;\n  case 0x4e:\n    char_position = '\\x02';\n    if (input_line[2] == '\\0') {\n      for (is_startup_line = '\\0'; is_startup_line < 2; is_startup_line = is_startup_line + '\\x01') {\n        return_value = settings_read_startup_input_line(is_startup_line,input_line);\n        if (return_value == '\\0') {\n          report_status_message('\\n');\n        }\n        else {\n          report_startup_input_line(is_startup_line,input_line);\n        }\n      }\n      return '\\0';\n    }\n    is_startup_line = '\\x01';\n  default:\nswitchD_08003bdc_caseD_25:\n    float_read_status = read_float(input_line,&char_position,&parsed_parameter);\n    if (float_read_status == 0) {\n      return '\\x01';\n    }\n    current_char = char_position + 1;\n    if (input_line[char_position] != '=') {\n      return '\\x03';\n    }\n    char_position = current_char;\n    if (is_startup_line == '\\0') {\n      float_read_status = read_float(input_line,&char_position,&parsed_value);\n      if (float_read_status == 0) {\n        return '\\x01';\n      }\n      if (input_line[char_position] == '\\0') {\n        float_read_status = __aeabi_f2iz(parsed_parameter);\n        return_value = settings_store_global_setting(float_read_status,parsed_value_00);\n        return return_value;\n      }\n      return '\\x03';\n    }\n    do {\n      input_line[(uint)char_position - (uint)current_char] = input_line[char_position];\n      char_index = (uint)char_position;\n      char_position = char_position + '\\x01';\n    } while (input_line[char_index] != '\\0');\n    is_startup_line = current_char;\n    is_startup_line = gc_execute_input_line(input_line);\n    if (is_startup_line != '\\0') {\n      return is_startup_line;\n    }\n    double_value = __aeabi_f2d(parsed_parameter);\n    trunc((double)CONCAT44(input_line,stack_value));\n    is_startup_line = __aeabi_d2uiz(double_value,extra_output_r1);\n    settings_store_startup_input_line(is_startup_line,input_line);\n    break;\n  case 0x58:\n    char_position = '\\x02';\n    if (input_line[2] != '\\0') {\n      return '\\x03';\n    }\n    if (PTR_sys_08003f2c[1] == '\\x06') {\n      report_feedback_message('\\x03');\n      PTR_sys_08003f2c[1] = 0;\n    }\n  }\n  return '\\0';\n}\n\n",
            "called": [
                "report_startup_line",
                "report_status_message",
                "__aeabi_f2iz",
                "report_gcode_parameters",
                "gc_execute_line",
                "protocol_execute_startup",
                "report_grbl_help",
                "settings_read_startup_line",
                "mc_go_home",
                "read_float",
                "__aeabi_d2uiz",
                "settings_store_startup_line",
                "__aeabi_f2d",
                "report_gcode_modes",
                "report_feedback_message",
                "mc_reset",
                "settings_store_global_setting",
                "report_grbl_settings",
                "trunc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003b98",
            "calling": [
                "protocol_process"
            ],
            "imported": false,
            "current_name": "process_line_08003b98"
        },
        "FUN_080024c4": {
            "renaming": {
                "FUN_080024c4": "home_axis_080024c4",
                "uVar1": "temp_float",
                "uVar2": "z_float_double",
                "invert_feed_rate": "feed_rate_inverted",
                "z": "z_position",
                "feed_rate": "feed_rate_value",
                "z_dir": "z_direction",
                "y_dir": "y_direction",
                "x_dir": "x_direction"
            },
            "code": "\nvoid home_axis_080024c4(void)\n\n{\n  uint8_t feed_rate_inverted;\n  undefined4 temp_float;\n  undefined8 z_float_double;\n  float z_position;\n  float feed_rate_value;\n  int8_t z_direction;\n  int8_t y_direction;\n  int8_t x_direction;\n  \n  PTR_sys_080025d8[1] = 5;\n  *(undefined4 *)PTR_limits_enabled_080025dc = 0;\n  limits_go_home();\n  protocol_execute_runtime();\n  if (*PTR_sys_080025d8 == '\\0') {\n    memset(DAT_080025e0,0,0xc);\n    sys_sync_current_position();\n    PTR_sys_080025d8[1] = 0;\n    if ((*(ushort *)(PTR_settings_080025e4 + 0x2a) & 0x20) == 0) {\n      x_direction = -1;\n    }\n    else {\n      x_direction = '\\x01';\n    }\n    if ((*(ushort *)(PTR_settings_080025e4 + 0x2a) & 0x80) == 0) {\n      y_direction = -1;\n    }\n    else {\n      y_direction = '\\x01';\n    }\n    if ((*(ushort *)(PTR_settings_080025e4 + 0x2a) & 0x200) == 0) {\n      z_direction = -1;\n    }\n    else {\n      z_direction = '\\x01';\n    }\n    temp_float = __floatsisf((int)x_direction);\n    feed_rate_inverted = __aeabi_fmul(temp_float,*(undefined4 *)(PTR_settings_080025e4 + 0x38));\n    temp_float = __floatsisf((int)y_direction);\n    __aeabi_fmul(temp_float,*(undefined4 *)(PTR_settings_080025e4 + 0x38));\n    temp_float = __floatsisf((int)z_direction);\n    z_float_double = __aeabi_fmul(temp_float,*(undefined4 *)(PTR_settings_080025e4 + 0x38));\n    mc_line((float)z_float_double,(float)((ulonglong)z_float_double >> 0x20),z_position,feed_rate_value,feed_rate_inverted);\n    st_cycle_start();\n    plan_synchroniz_positione();\n    sys_sync_current_position();\n    if ((PTR_settings_080025e4[0x28] & 8) != 0) {\n      *(undefined4 *)PTR_limits_enabled_080025dc = 1;\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "sys_sync_current_position",
                "protocol_execute_runtime",
                "__floatsisf",
                "__aeabi_fmul",
                "memset",
                "limits_go_home",
                "plan_synchronize",
                "st_cycle_start",
                "mc_line"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080024c4",
            "calling": [
                "protocol_execute_line"
            ],
            "imported": false,
            "current_name": "home_axis_080024c4"
        },
        "FUN_08002f40": {
            "renaming": {
                "FUN_08002f40": "update_tail_index_08002f40",
                "uVar1": "updatedIndex"
            },
            "code": "\nvoid updateTailIndex_08002f40(void)\n\n{\n  uint8_t updatedIndex;\n  \n  if (*PTR_block_buffer_head_08002f6c != *PTR_block_buffer_tail_08002f70) {\n    updatedIndex = next_block_index(*PTR_block_buffer_tail_08002f70);\n    *PTR_block_buffer_tail_08002f70 = updatedIndex;\n  }\n  return;\n}\n\n",
            "called": [
                "next_block_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f40",
            "calling": [
                "step_period_isr"
            ],
            "imported": false,
            "current_name": "update_tail_index_08002f40"
        },
        "FUN_08009054": {
            "renaming": {
                "FUN_08009054": "floating_point_division_08009054",
                "param_1": "numerator",
                "param_2": "denominator",
                "param_3": "unusedParam",
                "param_4": "expDen",
                "uVar1": "tempDen",
                "uVar2": "expNum",
                "iVar3": "expDiff",
                "uVar4": "shiftedNum",
                "iVar5": "tempExp",
                "uVar6": "result",
                "bVar7": "condition1",
                "bVar8": "condition2",
                "bVar9": "condition3"
            },
            "code": "\nuint floatingPointDivision_08009054(uint numerator,uint denominator,undefined4 unusedParam,uint expDen)\n\n{\n  uint tempDen;\n  uint expNum;\n  int expDiff;\n  uint shiftedNum;\n  int tempExp;\n  uint result;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  \n  expNum = numerator >> 0x17 & 0xff;\n  condition1 = expNum == 0;\n  if (!condition1) {\n    expDen = denominator >> 0x17 & 0xff;\n    condition1 = expDen == 0;\n  }\n  if (!condition1) {\n    condition1 = expNum == 0xff;\n  }\n  if (!condition1) {\n    condition1 = expDen == 0xff;\n  }\n  if (condition1) {\n    expDen = denominator >> 0x17 & 0xff;\n    result = numerator;\n    if (expNum == 0xff) {\n      if (((numerator & 0x7fffff) != 0) || (result = denominator, expDen == 0xff)) {\nLAB_0800904a:\n        return result | 0x7fc00000;\n      }\n    }\n    else {\n      if (expDen == 0xff) {\n        result = denominator;\n        if ((denominator & 0x7fffff) == 0) {\nLAB_08009000:\n          return (numerator ^ denominator) & 0x80000000;\n        }\n        goto LAB_0800904a;\n      }\n      condition1 = (numerator & 0x7fffffff) == 0;\n      if (!condition1) {\n        condition1 = (denominator & 0x7fffffff) == 0;\n      }\n      if (!condition1) {\n        condition1 = expNum == 0;\n        result = numerator & 0x80000000;\n        while( true ) {\n          if (condition1) {\n            numerator = numerator << 1;\n            condition1 = (numerator & 0x800000) == 0;\n          }\n          if (!condition1) break;\n          expNum = expNum - 1;\n        }\n        numerator = numerator | result;\n        condition1 = expDen == 0;\n        result = denominator & 0x80000000;\n        while( true ) {\n          if (condition1) {\n            denominator = denominator << 1;\n            condition1 = (denominator & 0x800000) == 0;\n          }\n          if (!condition1) break;\n          expDen = expDen - 1;\n        }\n        denominator = denominator | result;\n        goto LAB_0800906c;\n      }\n      if ((numerator & 0x7fffffff) == 0) {\n        if ((denominator & 0x7fffffff) != 0) goto LAB_08009000;\n        goto LAB_0800904a;\n      }\n    }\n    numerator = numerator ^ denominator;\n  }\n  else {\nLAB_0800906c:\n    expDiff = expNum - expDen;\n    if (denominator << 9 == 0) {\n      numerator = (numerator ^ denominator) & 0x80000000 | numerator & 0x7fffff;\n      condition3 = SCARRY4(expDiff,0x7f);\n      tempExp = expDiff + 0x7f;\n      condition1 = tempExp < 0;\n      condition2 = tempExp == 0;\n      if (!condition2 && condition1 == condition3) {\n        condition3 = SBORROW4(0xff,tempExp);\n        condition1 = 0xff - tempExp < 0;\n        condition2 = tempExp == 0xff;\n      }\n      if (!condition2 && condition1 == condition3) {\n        numerator = numerator | tempExp * 0x800000;\n      }\n      if (!condition2 && condition1 == condition3) {\n        return numerator;\n      }\n      numerator = numerator | 0x800000;\n      expNum = 0;\n      condition2 = SBORROW4(tempExp,1);\n      shiftedNum = expDiff + 0x7e;\n      condition1 = shiftedNum == 0;\n      result = shiftedNum;\n    }\n    else {\n      tempDen = (denominator << 9) >> 4 | 0x10000000;\n      expNum = (numerator << 9) >> 4 | 0x10000000;\n      numerator = (numerator ^ denominator) & 0x80000000;\n      condition1 = tempDen <= expNum;\n      if (!condition1) {\n        expNum = expNum << 1;\n      }\n      shiftedNum = expDiff + 0x7d + (uint)condition1;\n      result = 0x800000;\n      do {\n        if (tempDen <= expNum) {\n          expNum = expNum - tempDen;\n          numerator = numerator | result;\n        }\n        condition1 = tempDen >> 1 <= expNum;\n        if (condition1) {\n          expNum = expNum - (tempDen >> 1);\n        }\n        if (condition1) {\n          numerator = numerator | result >> 1;\n        }\n        condition1 = tempDen >> 2 <= expNum;\n        if (condition1) {\n          expNum = expNum - (tempDen >> 2);\n        }\n        if (condition1) {\n          numerator = numerator | result >> 2;\n        }\n        condition1 = tempDen >> 3 <= expNum;\n        if (condition1) {\n          expNum = expNum - (tempDen >> 3);\n        }\n        if (condition1) {\n          numerator = numerator | result >> 3;\n        }\n        expNum = expNum * 0x10;\n        condition1 = expNum == 0;\n        if (!condition1) {\n          result = result >> 4;\n          condition1 = result == 0;\n        }\n      } while (!condition1);\n      condition2 = SBORROW4(shiftedNum,0xfd);\n      condition1 = shiftedNum == 0xfd;\n      result = shiftedNum - 0xfd;\n      if (shiftedNum < 0xfe) {\n        numerator = numerator + shiftedNum * 0x800000 + (uint)(tempDen <= expNum);\n        if (expNum - tempDen == 0) {\n          numerator = numerator & 0xfffffffe;\n        }\n        return numerator;\n      }\n    }\n    if (condition1 || (int)result < 0 != condition2) {\n      condition1 = (int)(shiftedNum + 0x19) < 0;\n      if (shiftedNum == 0xffffffe7 || condition1 != SCARRY4(shiftedNum,0x19)) {\n        numerator = numerator & 0x80000000;\n      }\n      if (shiftedNum == 0xffffffe7 || condition1 != SCARRY4(shiftedNum,0x19)) {\n        return numerator;\n      }\n      result = (numerator << 1) >> (-shiftedNum & 0xff);\n      shiftedNum = numerator << (shiftedNum + 0x20 & 0xff);\n      result = ((uint)((numerator & 0x80000000) != 0) << 0x1f | result >> 1) + (uint)((byte)result & 1);\n      if ((expNum | shiftedNum << 1) == 0) {\n        result = result & ~(shiftedNum >> 0x1f);\n      }\n      return result;\n    }\n  }\n  return numerator & 0x80000000 | 0x7f800000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009054",
            "calling": [
                "gc_set_current_position",
                "plan_cycle_reinitialize",
                "estimate_acceleration_distance",
                "mc_arc",
                "planner_recalculate_trapezoids",
                "homing_cycle",
                "report_realtime_status",
                "intersection_distance",
                "plan_buffer_line",
                "report_grbl_settings"
            ],
            "imported": false,
            "current_name": "floating_point_division_08009054"
        },
        "FUN_080025e8": {
            "renaming": {
                "FUN_080025e8": "handle_machine_operations_080025e8"
            },
            "code": "\nvoid handleMachineOperations_080025e8(void)\n\n{\n  if ((PTR_sys_08002634[2] & 0x10) == 0) {\n    PTR_sys_08002634[2] = PTR_sys_08002634[2] | 0x10;\n    spindle_stop();\n    coolant_stop();\n    if ((byte)PTR_sys_08002634[1] - 3 < 3) {\n      PTR_sys_08002634[2] = PTR_sys_08002634[2] | 0x20;\n      st_go_idle();\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "spindle_stop",
                "st_go_idle",
                "coolant_stop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080025e8",
            "calling": [
                "protocol_execute_line",
                "serial_rx_hook",
                "gc_execute_line",
                "buttons_isr",
                "limits_isr"
            ],
            "imported": false,
            "current_name": "handle_machine_operations_080025e8"
        },
        "FUN_080001c8": {
            "renaming": {
                "FUN_080001c8": "do_nothing_080001c8"
            },
            "code": "\nvoid do_nothing_080001c8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001c8",
            "calling": [
                "coolant_run"
            ],
            "imported": false,
            "current_name": "do_nothing_080001c8"
        },
        "FUN_08005ac4": {
            "renaming": {
                "FUN_08005ac4": "get_fixed_constant_08005ac4"
            },
            "code": "\nuint32_t getFixedConstant_08005ac4(void)\n\n{\n  return 0x1000000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005ac4",
            "calling": [],
            "imported": false,
            "current_name": "get_fixed_constant_08005ac4"
        },
        "FUN_08005250": {
            "renaming": {
                "FUN_08005250": "turn_off_spindle_08005250"
            },
            "code": "\nvoid turnOffSpindle_08005250(void)\n\n{\n  spindle_off();\n  return;\n}\n\n",
            "called": [
                "spindle_off"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005250",
            "calling": [
                "spindle_run",
                "spindle_init",
                "mc_reset"
            ],
            "imported": false,
            "current_name": "turn_off_spindle_08005250"
        },
        "FUN_08007430": {
            "renaming": {
                "FUN_08007430": "infinite_loop_08007430"
            },
            "code": "\nvoid infiniteLoop_08007430(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007430",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "infinite_loop_08007430"
        },
        "FUN_08008640": {
            "renaming": {
                "FUN_08008640": "calculate_float_multiplication_08008640",
                "param_1": "operand1_low",
                "param_2": "operand1_high",
                "param_3": "operand2_low",
                "param_4": "operand2_high",
                "uVar1": "temp_result",
                "lVar2": "partial_product",
                "uVar3": "high_bits",
                "uVar4": "exponent_sum",
                "iVar5": "exponent_diff",
                "uVar6": "adjusted_exponent",
                "unaff_r5": "operand2_exponent",
                "uVar7": "exponent_mask",
                "uVar8": "product_low",
                "uVar12": "operand1",
                "bVar9": "condition1",
                "bVar10": "condition2",
                "bVar11": "condition3"
            },
            "code": "\nulonglong calculate_float_multiplication_08008640(undefined4 operand1_low,uint operand1_high,uint operand2_low,uint operand2_high)\n\n{\n  ulonglong temp_result;\n  longlong partial_product;\n  uint high_bits;\n  uint exponent_sum;\n  int exponent_diff;\n  uint adjusted_exponent;\n  uint operand2_exponent;\n  uint exponent_mask;\n  uint product_low;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  ulonglong operand1;\n  \n  operand1 = CONCAT44(operand1_high,operand1_low);\n  exponent_mask = 0x7ff;\n  exponent_sum = operand1_high >> 0x14 & 0x7ff;\n  condition1 = exponent_sum == 0;\n  if (!condition1) {\n    operand2_exponent = operand2_high >> 0x14 & 0x7ff;\n    condition1 = operand2_exponent == 0;\n  }\n  if (!condition1) {\n    condition1 = exponent_sum == 0x7ff;\n  }\n  if (!condition1) {\n    condition1 = operand2_exponent == 0x7ff;\n  }\n  if (condition1) {\n    operand1 = calculate_result_0800881c();\n  }\n  high_bits = (uint)(operand1 >> 0x20);\n  exponent_diff = exponent_sum + operand2_exponent;\n  exponent_sum = high_bits ^ operand2_high;\n  high_bits = high_bits & ~(exponent_mask << 0x15);\n  operand2_high = operand2_high & ~(exponent_mask << 0x15);\n  condition1 = ((uint)operand1 | high_bits << 0xc) == 0;\n  if (!condition1) {\n    condition1 = (operand2_low | operand2_high << 0xc) == 0;\n  }\n  high_bits = high_bits | 0x100000;\n  operand2_high = operand2_high | 0x100000;\n  if (condition1) {\n    operand2_low = (uint)operand1 | operand2_low;\n    operand2_high = (exponent_sum & 0x80000000 | high_bits) ^ operand2_high;\n    exponent_sum = exponent_mask >> 1;\n    condition3 = SBORROW4(exponent_diff,exponent_sum);\n    adjusted_exponent = exponent_diff - exponent_sum;\n    condition1 = adjusted_exponent == 0;\n    high_bits = adjusted_exponent;\n    if (!condition1 && (int)exponent_sum <= exponent_diff) {\n      condition3 = SBORROW4(exponent_mask,adjusted_exponent);\n      high_bits = exponent_mask - adjusted_exponent;\n      condition1 = exponent_mask == adjusted_exponent;\n    }\n    if (!condition1 && (int)high_bits < 0 == condition3) {\n      operand2_high = operand2_high | adjusted_exponent * 0x100000;\n    }\n    if (!condition1 && (int)high_bits < 0 == condition3) {\n      return CONCAT44(operand2_high,operand2_low);\n    }\n    operand2_high = operand2_high | 0x100000;\n    exponent_mask = 0;\n    condition3 = SBORROW4(adjusted_exponent,1);\n    adjusted_exponent = adjusted_exponent - 1;\n    condition1 = adjusted_exponent == 0;\n    exponent_sum = adjusted_exponent;\n  }\n  else {\n    temp_result = (operand1 & 0xffffffff) * (ulonglong)operand2_low;\n    operand1 = (operand1 & 0xffffffff) * (ulonglong)operand2_high +\n             (ulonglong)high_bits * (ulonglong)operand2_low + (temp_result >> 0x20);\n    product_low = (uint)operand1;\n    partial_product = (ulonglong)high_bits * (ulonglong)operand2_high + (operand1 >> 0x20);\n    exponent_mask = (uint)partial_product;\n    high_bits = (uint)((ulonglong)partial_product >> 0x20);\n    if ((int)temp_result != 0) {\n      product_low = product_low | 1;\n    }\n    adjusted_exponent = (exponent_diff + -0x3ff) - (uint)(high_bits < 0x200);\n    if (high_bits < 0x200) {\n      condition1 = (product_low & 0x80000000) != 0;\n      product_low = product_low << 1;\n      partial_product = CONCAT44(high_bits * 2 + (uint)(CARRY4(exponent_mask,exponent_mask) || CARRY4(exponent_mask * 2,(uint)condition1)),\n                       exponent_mask * 2 + (uint)condition1);\n    }\n    operand2_high = exponent_sum & 0x80000000 | (int)((ulonglong)partial_product >> 0x20) << 0xb | (uint)partial_product >> 0x15;\n    operand2_low = (uint)partial_product << 0xb | product_low >> 0x15;\n    exponent_mask = product_low * 0x800;\n    condition2 = 0xfc < adjusted_exponent;\n    condition3 = SBORROW4(adjusted_exponent,0xfd);\n    high_bits = adjusted_exponent - 0xfd;\n    condition1 = high_bits == 0;\n    exponent_sum = high_bits;\n    if (condition2 && !condition1) {\n      condition2 = 0x6ff < high_bits;\n      condition3 = SBORROW4(high_bits,0x700);\n      exponent_sum = adjusted_exponent - 0x7fd;\n      condition1 = high_bits == 0x700;\n    }\n    if (!condition2 || condition1) {\n      condition1 = 0x7fffffff < exponent_mask;\n      if (exponent_mask == 0x80000000) {\n        condition1 = (product_low >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(operand2_high + adjusted_exponent * 0x100000 + (uint)CARRY4(operand2_low,(uint)condition1),operand2_low + condition1\n                     );\n    }\n  }\n  if (!condition1 && (int)exponent_sum < 0 == condition3) {\n    return (ulonglong)(operand2_high & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  condition2 = SCARRY4(adjusted_exponent,0x36);\n  condition1 = (int)(adjusted_exponent + 0x36) < 0;\n  condition3 = adjusted_exponent == 0xffffffca;\n  if (condition3 || condition1 != condition2) {\n    operand2_low = 0;\n  }\n  if (condition3 || condition1 != condition2) {\n    operand2_high = operand2_high & 0x80000000;\n  }\n  if (condition3 || condition1 != condition2) {\n    return CONCAT44(operand2_high,operand2_low);\n  }\n  exponent_sum = -adjusted_exponent;\n  high_bits = exponent_sum - 0x20;\n  if (0x1f < (int)exponent_sum) {\n    adjusted_exponent = operand2_low >> (high_bits & 0xff) | operand2_high << (0x20 - high_bits & 0xff);\n    exponent_sum = (operand2_high >> (high_bits & 0xff) & ~((operand2_high & 0x80000000) >> (high_bits & 0xff))) -\n            ((int)adjusted_exponent >> 0x1f);\n    if ((exponent_mask | operand2_low << (0x20 - high_bits & 0xff) | adjusted_exponent << 1) == 0) {\n      exponent_sum = exponent_sum & ~(adjusted_exponent >> 0x1f);\n    }\n    return CONCAT44(operand2_high,exponent_sum) & 0x80000000ffffffff;\n  }\n  exponent_diff = exponent_sum - 0x14;\n  if (exponent_diff == 0 || exponent_diff < 0 != SCARRY4(high_bits,0xc)) {\n    product_low = operand2_low << (adjusted_exponent + 0x20 & 0xff);\n    high_bits = operand2_low >> (exponent_sum & 0xff) | operand2_high << (adjusted_exponent + 0x20 & 0xff);\n    adjusted_exponent = high_bits + -((int)product_low >> 0x1f);\n    if ((exponent_mask | product_low << 1) == 0) {\n      adjusted_exponent = adjusted_exponent & ~(product_low >> 0x1f);\n    }\n    return CONCAT44((operand2_high & 0x80000000) +\n                    ((operand2_high & 0x7fffffff) >> (exponent_sum & 0xff)) +\n                    (uint)CARRY4(high_bits,-((int)product_low >> 0x1f)),adjusted_exponent);\n  }\n  exponent_sum = 0xc - exponent_diff;\n  adjusted_exponent = operand2_low << (exponent_sum & 0xff);\n  exponent_sum = operand2_low >> (0x20 - exponent_sum & 0xff) | operand2_high << (exponent_sum & 0xff);\n  high_bits = exponent_sum + -((int)adjusted_exponent >> 0x1f);\n  if ((exponent_mask | adjusted_exponent << 1) == 0) {\n    high_bits = high_bits & ~(adjusted_exponent >> 0x1f);\n  }\n  return CONCAT44((operand2_high & 0x80000000) + (uint)CARRY4(exponent_sum,-((int)adjusted_exponent >> 0x1f)),high_bits);\n}\n\n",
            "called": [
                "FUN_0800881c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008640",
            "calling": [
                "scalbn",
                "report_gcode_parameters",
                "report_realtime_status",
                "__kernel_sin",
                "__ieee754_hypot",
                "calculate_trapezoid_for_block",
                "read_float",
                "atan",
                "__ieee754_sqrt",
                "__kernel_cos",
                "to_millimeters",
                "mc_arc",
                "homing_cycle",
                "report_gcode_modes",
                "__ieee754_rem_pio2",
                "plan_buffer_line",
                "__kernel_rem_pio2"
            ],
            "imported": false,
            "current_name": "calculate_float_multiplication_08008640"
        },
        "FUN_08007310": {
            "renaming": {
                "FUN_08007310": "get_gpio_pin_state_08007310",
                "GPIOx": "gpioPort",
                "GPIO_Pin": "gpioPin",
                "bitstatus": "pinState"
            },
            "code": "\ngpioPinState GetGPIOPinState_08007310(GPIO_TypeDef *gpioPort,uint16_t gpioPin)\n\n{\n  gpioPinState pinState;\n  \n  return ((uint)gpioPin & gpioPort->IDR) != 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007310",
            "calling": [],
            "imported": false,
            "current_name": "get_gpio_pin_state_08007310"
        },
        "FUN_08007436": {
            "renaming": {
                "FUN_08007436": "initialize_system_clock_08007436",
                "HVar1": "status",
                "RCC_OscInitStruct": "oscInit",
                "RCC_ClkInitStruct": "clkInit"
            },
            "code": "\nvoid InitializeSystemClock_08007436(void)\n\n{\n  HAL_StatusTypeDef status;\n  RCC_OscInitTypeDef oscInit;\n  RCC_ClkInitTypeDef clkInit;\n  \n  *(uint *)(DAT_080074c0 + 0x40) = *(uint *)(DAT_080074c0 + 0x40) | 0x10000000;\n  *DAT_080074c4 = *DAT_080074c4 | 0xc000;\n  oscInit.OscillatorType = 1;\n  oscInit.HSEState = 1;\n  oscInit.PLL.PLLState = 2;\n  oscInit.PLL.PLLSource = 0x400000;\n  oscInit.PLL.PLLM = 8;\n  oscInit.PLL.PLLN = 0x150;\n  oscInit.PLL.PLLP = 2;\n  oscInit.PLL.PLLQ = 7;\n  status = HAL_RCC_OscConfig(&oscInit);\n  if (status != HAL_OK) {\n    Error_Handler();\n  }\n  clkInit.ClockType = 0xf;\n  clkInit.SYSCLKSource = 2;\n  clkInit.AHBCLKDivider = 0;\n  clkInit.APB1CLKDivider = 0x1400;\n  clkInit.APB2CLKDivider = 0x1000;\n  status = HAL_RCC_ClockConfig(&clkInit,5);\n  if (status != HAL_OK) {\n    Error_Handler();\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_RCC_ClockConfig",
                "HAL_RCC_OscConfig",
                "Error_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007436",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_system_clock_08007436"
        },
        "FUN_08005814": {
            "renaming": {
                "FUN_08005814": "initialize_system_08005814"
            },
            "code": "\nvoid initializeSystem_08005814(void)\n\n{\n  memset(PTR_st_08005834,0,0x24);\n  set_step_events_per_minute(800);\n  *(undefined4 *)PTR_current_block_08005838 = 0;\n  return;\n}\n\n",
            "called": [
                "memset",
                "set_step_events_per_minute"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005814",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "initialize_system_08005814"
        },
        "FUN_08005bdc": {
            "renaming": {
                "FUN_08005bdc": "set_interrupt_priority_08005bdc",
                "IRQn": "interruptNumber",
                "priority": "priorityValue"
            },
            "code": "\nvoid setInterruptPriority_08005bdc(interruptNumber_Type interruptNumber,uint32_t priorityValue)\n\n{\n  if (interruptNumber < WWDG_interruptNumber) {\n    *(char *)(((byte)interruptNumber & 0xf) + DAT_08005c28 + 0x14) = (char)((priorityValue & 0xff) << 4);\n  }\n  else {\n    *(char *)(interruptNumber + DAT_08005c2c + 0x300) = (char)((priorityValue & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005bdc",
            "calling": [
                "SysTick_Config"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_08005bdc"
        },
        "FUN_080085d4": {
            "renaming": {
                "FUN_080085d4": "calculate_result_080085d4",
                "param_1": "input_1",
                "param_2": "input_2",
                "bVar1": "temp_byte",
                "uVar2": "temp_var_1",
                "uVar3": "temp_var_2",
                "uVar4": "temp_var_3",
                "iVar5": "leading_zeroes",
                "uVar6": "shifted_bits",
                "iVar7": "shift_count",
                "uVar8": "intermediate_result",
                "bVar9": "carry_1",
                "bVar10": "carry_2",
                "bVar11": "carry_3"
            },
            "code": "\nulonglong calculate_result_080085d4(uint input_1,uint input_2)\n\n{\n  byte temp_byte;\n  uint temp_var_1;\n  uint temp_var_2;\n  uint temp_var_3;\n  int leading_zeroes;\n  uint shifted_bits;\n  int shift_count;\n  uint intermediate_result;\n  bool carry_1;\n  bool carry_2;\n  bool carry_3;\n  \n  if ((input_1 | input_2) == 0) {\n    return CONCAT44(input_2,input_1);\n  }\n  shift_count = 0x432;\n  intermediate_result = input_2 >> 0x16;\n  if (intermediate_result != 0) {\n    shift_count = 3;\n    if (input_2 >> 0x19 != 0) {\n      shift_count = 6;\n    }\n    if (input_2 >> 0x1c != 0) {\n      shift_count = shift_count + 3;\n    }\n    temp_var_3 = shift_count - ((int)input_2 >> 0x1f);\n    intermediate_result = input_1 << (0x20 - temp_var_3 & 0xff);\n    input_1 = input_1 >> (temp_var_3 & 0xff) | input_2 << (0x20 - temp_var_3 & 0xff);\n    input_2 = input_2 >> (temp_var_3 & 0xff);\n    shift_count = temp_var_3 + 0x432;\n  }\n  if (0xfffff < input_2) {\n    if (0x1fffff < input_2) {\n      temp_var_3 = input_2 & 1;\n      input_2 = input_2 >> 1;\n      temp_byte = (byte)input_1;\n      input_1 = (uint)(temp_var_3 != 0) << 0x1f | input_1 >> 1;\n      intermediate_result = (uint)(temp_byte & 1) << 0x1f | intermediate_result >> 1;\n      shift_count = shift_count + 1;\n      if (0xffbfffff < (uint)(shift_count * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_080083e0:\n    carry_2 = 0x7fffffff < intermediate_result;\n    if (intermediate_result == 0x80000000) {\n      carry_2 = (input_1 & 1) != 0;\n    }\n    return CONCAT44(input_2 + shift_count * 0x100000 + (uint)CARRY4(input_1,(uint)carry_2),input_1 + carry_2\n                   );\n  }\n  carry_1 = (intermediate_result & 0x80000000) != 0;\n  intermediate_result = intermediate_result << 1;\n  temp_var_3 = input_1 * 2;\n  carry_2 = CARRY4(input_1,input_1);\n  input_1 = input_1 * 2 + (uint)carry_1;\n  input_2 = input_2 * 2 + (uint)(carry_2 || CARRY4(temp_var_3,(uint)carry_1));\n  carry_2 = shift_count != 0;\n  shift_count = shift_count + -1;\n  if (carry_2 && 0xfffff < input_2) goto LAB_080083e0;\n  temp_var_1 = input_1;\n  temp_var_3 = input_2;\n  if (input_2 == 0) {\n    temp_var_1 = 0;\n    temp_var_3 = input_1;\n  }\n  leading_zeroes = count_leading_zeroes(temp_var_3);\n  if (input_2 == 0) {\n    leading_zeroes = leading_zeroes + 0x20;\n  }\n  shifted_bits = leading_zeroes - 0xb;\n  carry_3 = SBORROW4(shifted_bits,0x20);\n  temp_var_2 = leading_zeroes - 0x2b;\n  carry_2 = (int)temp_var_2 < 0;\n  carry_1 = temp_var_2 == 0;\n  if ((int)shifted_bits < 0x20) {\n    carry_3 = SCARRY4(temp_var_2,0xc);\n    leading_zeroes = leading_zeroes + -0x1f;\n    carry_2 = leading_zeroes < 0;\n    carry_1 = leading_zeroes == 0;\n    temp_var_2 = shifted_bits;\n    if (!carry_1 && carry_2 == carry_3) {\n      temp_var_1 = temp_var_3 << (shifted_bits & 0xff);\n      temp_var_3 = temp_var_3 >> (0xcU - leading_zeroes & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (carry_1 || carry_2 != carry_3) {\n    intermediate_result = 0x20 - temp_var_2;\n  }\n  temp_var_3 = temp_var_3 << (temp_var_2 & 0xff);\n  if (carry_1 || carry_2 != carry_3) {\n    temp_var_3 = temp_var_3 | temp_var_1 >> (intermediate_result & 0xff);\n  }\n  if (carry_1 || carry_2 != carry_3) {\n    temp_var_1 = temp_var_1 << (temp_var_2 & 0xff);\n  }\nLAB_08008458:\n  if ((int)shifted_bits <= shift_count) {\n    return CONCAT44(temp_var_3 + (shift_count - shifted_bits) * 0x100000,temp_var_1);\n  }\n  intermediate_result = ~(shift_count - shifted_bits);\n  if ((int)intermediate_result < 0x1f) {\n    shift_count = intermediate_result - 0x13;\n    if (shift_count != 0 && shift_count < 0 == SCARRY4(intermediate_result - 0x1f,0xc)) {\n      return (ulonglong)(temp_var_1 >> (0x20 - (0xcU - shift_count) & 0xff) | temp_var_3 << (0xcU - shift_count & 0xff));\n    }\n    intermediate_result = intermediate_result + 1;\n    return CONCAT44(temp_var_3 >> (intermediate_result & 0xff),temp_var_1 >> (intermediate_result & 0xff) | temp_var_3 << (0x20 - intermediate_result & 0xff)\n                   );\n  }\n  return (ulonglong)(temp_var_3 >> (intermediate_result - 0x1f & 0xff));\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080085d4",
            "calling": [],
            "imported": false,
            "current_name": "calculate_result_080085d4"
        },
        "FUN_08006e70": {
            "renaming": {
                "FUN_08006e70": "systick_callback_wrapper_08006e70"
            },
            "code": "\nvoid systickCallbackWrapper_08006e70(void)\n\n{\n  HAL_SYSTICK_Callback();\n  return;\n}\n\n",
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e70",
            "calling": [],
            "imported": false,
            "current_name": "systick_callback_wrapper_08006e70"
        },
        "FUN_080002f0": {
            "renaming": {
                "FUN_080002f0": "initialize_eeprom_080002f0"
            },
            "code": "\nvoid initializeEeprom_080002f0(void)\n\n{\n  memset(PTR_eeprom_data_08000308,0xff,4);\n  *(undefined4 *)PTR_eeprom_ready_0800030c = 1;\n  return;\n}\n\n",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080002f0",
            "calling": [
                "memcpy_from_eeprom_with_checksum",
                "eeprom_put_char",
                "eeprom_get_char",
                "memcpy_to_eeprom_with_checksum"
            ],
            "imported": false,
            "current_name": "initialize_eeprom_080002f0"
        },
        "FUN_080073c0": {
            "renaming": {
                "FUN_080073c0": "do_nothing_080073c0"
            },
            "code": "\nvoid do_nothing_080073c0(uint16_t GPIO_Pin)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073c0",
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_080073c0"
        },
        "FUN_0800778c": {
            "renaming": {
                "FUN_0800778c": "initialize_gpio_0800778c",
                "puVar1": "gpioInfoPtr",
                "GPIO_InitTypeDef": "GPIO_InitConfig",
                "GPIO_INFO": "GPIO_Info",
                "i": "index",
                "GPIO_InitStruct": "gpioInitConfig"
            },
            "code": "\nvoindexd InitializeGPIO_0800778c(voindexd)\n\n{\n  uindexnt *gpioInfoPtr;\n  GPIO_InitConfig gpioInitConfig;\n  GPIO_Info *gpindexo;\n  indexnt index;\n  \n  for (index = 0; (uindexnt)index < 0x11; index = index + 1) {\n    gpioInfoPtr = (uindexnt *)(PTR_gpindexo_indexnfo_0800784c + index * 0x18);\n    *(uindexnt *)(DAT_08007850 + 0x30) = *(uindexnt *)(DAT_08007850 + 0x30) | 1 << (*gpioInfoPtr >> 4 & 0xff);\n    gpioInitConfig.Pindexn = 1 << (*gpioInfoPtr & 0xf);\n    gpioInitConfig.Mode = gpioInfoPtr[1];\n    gpioInitConfig.Pull = gpioInfoPtr[2];\n    gpioInitConfig.Speed = gpioInfoPtr[3];\n    gpioInitConfig.Alternate = gpioInfoPtr[4];\n    HAL_GPIO_Inindext((GPIO_TypeDef *)(((*gpioInfoPtr >> 4) + 0x100080) * 0x400),&gpioInitConfig);\n    indexf (-1 < (indexnt)gpioInfoPtr[5]) {\n      HAL_GPIO_WrindextePindexn((GPIO_TypeDef *)(((*gpioInfoPtr >> 4) + 0x100080) * 0x400),\n                        (uindexnt16_t)(1 << (*gpioInfoPtr & 0xf)),(GPIO_PindexnState)gpioInfoPtr[5]);\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_Init",
                "HAL_GPIO_WritePin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800778c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_gpio_0800778c"
        },
        "FUN_080001d4": {
            "renaming": {
                "FUN_080001d4": "do_nothing_080001d4"
            },
            "code": "\nvoid do_nothing_080001d4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001d4",
            "calling": [
                "coolant_stop"
            ],
            "imported": false,
            "current_name": "do_nothing_080001d4"
        },
        "FUN_08001ddc": {
            "renaming": {
                "FUN_08001ddc": "initialize_and_run_system_08001ddc"
            },
            "code": "\nint initializeAndRunSystem_08001ddc(void)\n\n{\n  serial_init();\n  settings_init();\n  st_init();\n  memset(PTR_sys_08001e90,0,0x14);\n  *PTR_sys_08001e90 = 1;\n  PTR_sys_08001e90[1] = 1;\n  do {\n    if (*PTR_sys_08001e90 != '\\0') {\n      serial_reset_read_buffer();\n      plan_init();\n      gc_init();\n      protocol_init();\n      spindle_init();\n      coolant_init();\n      limits_init();\n      st_reset();\n      sys_sync_current_position();\n      *PTR_sys_08001e90 = 0;\n      PTR_sys_08001e90[2] = 0;\n      if ((PTR_settings_08001e94[0x28] & 2) != 0) {\n        PTR_sys_08001e90[0x10] = 1;\n      }\n      if ((PTR_sys_08001e90[1] == '\\x01') && ((PTR_settings_08001e94[0x28] & 0x10) != 0)) {\n        PTR_sys_08001e90[1] = 6;\n      }\n      if (PTR_sys_08001e90[1] == '\\x06') {\n        report_feedback_message('\\x02');\n      }\n      else {\n        PTR_sys_08001e90[1] = 0;\n        protocol_execute_startup();\n      }\n    }\n    protocol_execute_runtime();\n    protocol_process();\n  } while( true );\n}\n\n",
            "called": [
                "serial_init",
                "spindle_init",
                "st_init",
                "limits_init",
                "plan_init",
                "serial_reset_read_buffer",
                "gc_init",
                "protocol_execute_startup",
                "sys_sync_current_position",
                "settings_init",
                "protocol_execute_runtime",
                "protocol_process",
                "memset",
                "st_reset",
                "report_feedback_message",
                "protocol_init",
                "coolant_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001ddc",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_and_run_system_08001ddc"
        },
        "FUN_080069b4": {
            "renaming": {
                "FUN_080069b4": "set_interrupt_080069b4",
                "IRQn_Type": "InterruptType",
                "IRQn": "interruptNumber"
            },
            "code": "\nvoid setInterrupt_080069b4(InterruptType interruptNumber)\n\n{\n  *(int *)(DAT_080069e0 + ((uint)(int)interruptNumber >> 5) * 4) = 1 << (interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080069b4",
            "calling": [
                "HAL_NVIC_EnableIRQ"
            ],
            "imported": false,
            "current_name": "set_interrupt_080069b4"
        },
        "FUN_0800b4e4": {
            "renaming": {
                "FUN_0800b4e4": "register_exit_procedure_0800b4e4",
                "__func": "exitProcedure",
                "iVar1": "result"
            },
            "code": "\nint registerExitProcedure_0800b4e4(exitProcedure *exitProcedure)\n\n{\n  int result;\n  \n  result = __register_exitproc(0,exitProcedure,0);\n  return result;\n}\n\n",
            "called": [
                "__register_exitproc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b4e4",
            "calling": [
                "register_fini"
            ],
            "imported": false,
            "current_name": "register_exit_procedure_0800b4e4"
        },
        "FUN_08007720": {
            "renaming": {
                "FUN_08007720": "infinite_loop_08007720"
            },
            "code": "\nvoid infinite_loop_08007720(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007720",
            "calling": [],
            "imported": false,
            "current_name": "infinite_loop_08007720"
        },
        "FUN_08009228": {
            "renaming": {
                "FUN_08009228": "compare_floating_points_08009228",
                "in_CY": "comparison_result"
            },
            "code": "\nbool compareFloatingPoints_08009228(void)\n\n{\n  char comparison_result;\n  \n  __aeabi_cfcmpeq();\n  return comparison_result == '\\0';\n}\n\n",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009228",
            "calling": [
                "printFloat",
                "planner_forward_pass_kernel",
                "gc_execute_line",
                "settings_store_global_setting",
                "planner_reverse_pass_kernel",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "compare_floating_points_08009228"
        },
        "FUN_08007c7c": {
            "renaming": {
                "FUN_08007c7c": "handle_interrupt_events_08007c7c",
                "TIMx": "timer"
            },
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid handleInterruptEvents_08007c7c(void)\n\n{\n  TIM_TypeDef *timer;\n  \n  if (((_DAT_40000010 & 2) != 0) && ((_DAT_4000000c & 2) != 0)) {\n    _DAT_40000010 = _DAT_40000010 & 0xfffffffd;\n    step_delay_isr();\n  }\n  if (((_DAT_40000010 & 4) != 0) && ((_DAT_4000000c & 4) != 0)) {\n    _DAT_40000010 = _DAT_40000010 & 0xfffffffb;\n    step_pulse_isr();\n  }\n  if (((_DAT_40000010 & 1) != 0) && ((_DAT_4000000c & 1) != 0)) {\n    _DAT_40000010 = _DAT_40000010 & 0xfffffffe;\n    step_period_isr();\n  }\n  return;\n}\n\n",
            "called": [
                "step_pulse_isr",
                "step_period_isr",
                "step_delay_isr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007c7c",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_events_08007c7c"
        },
        "FUN_08007726": {
            "renaming": {
                "FUN_08007726": "infinite_loop_function_08007726"
            },
            "code": "\nvoid infinite_loop_function_08007726(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007726",
            "calling": [],
            "imported": false,
            "current_name": "infinite_loop_function_08007726"
        },
        "FUN_08007b70": {
            "renaming": {
                "FUN_08007b70": "configure_timers_08007b70",
                "TIMx": "timer",
                "enable": "timerEnableFlags"
            },
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid configureTimers_08007b70(void)\n\n{\n  TIM_TypeDef *timer;\n  uint32_t timerEnableFlags;\n  \n  timerEnableFlags = 1;\n  if (_DAT_40000034 != 0) {\n    timerEnableFlags = 3;\n  }\n  if (_DAT_40000038 != 0) {\n    timerEnableFlags = timerEnableFlags | 4;\n  }\n  _DAT_4000000c = _DAT_4000000c | timerEnableFlags;\n  _DAT_40000000 = _DAT_40000000 | 1;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007b70",
            "calling": [
                "st_wake_up"
            ],
            "imported": false,
            "current_name": "configure_timers_08007b70"
        },
        "FUN_08004d2c": {
            "renaming": {
                "FUN_08004d2c": "load_startup_line_08004d2c",
                "n": "lineNumber",
                "line": "buffer",
                "iVar1": "isValidChecksum",
                "addr": "eepromAddress"
            },
            "code": "\nuilineNumbert8_t loadStartupLine_08004d2c(uilineNumbert8_t lineNumber,char *buffer)\n\n{\n  ilineNumbert isValidChecksum;\n  uilineNumbert16_t eepromAddress;\n  \n  isValidChecksum = memcpy_from_eeprom_with_checksum(buffer,(uilineNumbert)(ushort)((ushort)lineNumber * 0x101 + 0x300),0x100);\n  if (isValidChecksum == 0) {\n    *buffer = '\\0';\n    settilineNumbergs_store_startup_buffer(lineNumber,buffer);\n  }\n  returlineNumber isValidChecksum != 0;\n}\n\n",
            "called": [
                "memcpy_from_eeprom_with_checksum",
                "settings_store_startup_line"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d2c",
            "calling": [
                "protocol_execute_line",
                "protocol_execute_startup"
            ],
            "imported": false,
            "current_name": "load_startup_line_08004d2c"
        },
        "FUN_08003004": {
            "renaming": {
                "FUN_08003004": "process_movement_08003004",
                "x": "x_move",
                "y": "y_move",
                "z": "z_move",
                "puVar13": "current_block",
                "uVar3": "temp_var1",
                "uVar7": "temp_var2",
                "uVar8": "temp_var3",
                "uVar9": "temp_var4",
                "uVar10": "temp_var5",
                "fVar11": "temp_float",
                "in_r1": "intermediate_var1",
                "extraout_r1": "extraout_var1",
                "extraout_r1_00": "extraout_var2",
                "extraout_r1_01": "extraout_var3",
                "extraout_r1_02": "extraout_var4",
                "extraout_r1_03": "extraout_var5",
                "extraout_r1_04": "extraout_var6",
                "in_r2": "intermediate_var2",
                "in_r3": "intermediate_var3",
                "uVar12": "temp_uint1",
                "uVar15": "temp_uint2",
                "fVar16": "temp_float2",
                "extraout_d0": "extraout_double1",
                "extraout_d0_00": "extraout_double2",
                "extraout_d0_01": "extraout_double3",
                "extraout_d0_02": "extraout_double4",
                "extraout_d0_03": "extraout_double5",
                "extraout_d0_04": "extraout_double6",
                "extraout_s2": "extraout_float1",
                "extraout_s2_00": "extraout_float2",
                "extraout_s2_01": "extraout_float3",
                "extraout_s2_02": "extraout_float4",
                "extraout_s2_03": "extraout_float5",
                "extraout_s2_04": "extraout_float6",
                "uVar17": "temp_double1",
                "uVar18": "temp_double2",
                "uVar19": "temp_double3",
                "in_stack_00000000": "stack_var",
                "unit_vec": "unit_vector",
                "delta_mm": "delta_millimeters",
                "target": "target_position",
                "v_allowable": "allowable_velocity",
                "sin_theta_d2": "sin_theta_half",
                "vmax_junction": "max_junction_velocity"
            },
            "code": "\nvoid process_movement_08003004(float x_move,float y_move,float z_move,float feed_rate,uint8_t invert_feed_rate)\n\n{\n  undefined *puVar1;\n  uint8_t uVar2;\n  undefined4 temp_var1;\n  long lVar4;\n  long lVar5;\n  long lVar6;\n  undefined4 temp_var2;\n  undefined4 temp_var3;\n  undefined4 temp_var4;\n  undefined4 temp_var5;\n  float temp_float;\n  undefined4 intermediate_var1;\n  undefined4 extraout_var1;\n  undefined4 extraout_var2;\n  undefined4 extraout_var3;\n  undefined4 extraout_var4;\n  undefined4 extraout_var5;\n  undefined4 extraout_var6;\n  undefined4 intermediate_var2;\n  uint temp_uint1;\n  undefined4 intermediate_var3;\n  ushort *current_block;\n  int iVar14;\n  uint temp_uint2;\n  float temp_float2;\n  undefined8 extraout_double1;\n  undefined8 extraout_double2;\n  undefined8 extraout_double3;\n  undefined8 extraout_double4;\n  undefined8 extraout_double5;\n  undefined8 extraout_double6;\n  float extraout_float1;\n  float extraout_float2;\n  float extraout_float3;\n  float extraout_float4;\n  float extraout_float5;\n  float extraout_float6;\n  undefined8 temp_double1;\n  undefined8 temp_double2;\n  undefined8 temp_double3;\n  char stack_var;\n  float unit_vector [3];\n  float delta_millimeters [3];\n  int32_t target_position [3];\n  float allowable_velocity;\n  float sin_theta_half;\n  float cos_theta;\n  float inverse_millimeters;\n  block_t *block;\n  float max_junction_velocity;\n  float inverse_minute;\n  \n  current_block = (ushort *)\n            (PTR_block_buffer_08003234 + (uint)(by_movete)*PTR_block_buffer_head_08003230 * 0x_move40);\n  temp_var1 = __aeabi_fmul(x_move,*(undefined4 *)PTR_settings_08003238,invert_feed_rate);\n  __aeabi_f2d(temp_var1);\n  lVar4 = lround((double)CONCAT44(intermediate_var2,intermediate_var3));\n  temp_var1 = __aeabi_fmul(*(undefined4 *)(PTR_settings_08003238 + 4),intermediate_var1);\n  __aeabi_f2d(temp_var1);\n  lVar5 = lround((double)CONCAT44(intermediate_var2,intermediate_var3));\n  temp_var1 = __aeabi_fmul(*(undefined4 *)(PTR_settings_08003238 + 8),intermediate_var2);\n  __aeabi_f2d(temp_var1);\n  lVar6 = lround((double)CONCAT44(intermediate_var2,intermediate_var3));\n  *current_block = 0;\n  if (lVar4 < *(int *)PTR_pl_0800323c) {\n    *current_block = *current_block | 0x_move20;\n  }\n  if (lVar5 < *(int *)(PTR_pl_0800323c + 4)) {\n    *current_block = *current_block | 0x_move880;\n  }\n  if (lVar6 < *(int *)(PTR_pl_0800323c + 8)) {\n    *current_block = *current_block | 0x_move200;\n  }\n  iVar14 = lVar4 - *(int *)PTR_pl_0800323c;\n  if (iVar14 < 0) {\n    iVar14 = -iVar14;\n  }\n  *(int *)(current_block + 2) = iVar14;\n  iVar14 = lVar5 - *(int *)(PTR_pl_0800323c + 4);\n  if (iVar14 < 0) {\n    iVar14 = -iVar14;\n  }\n  *(int *)(current_block + 4) = iVar14;\n  iVar14 = lVar6 - *(int *)(PTR_pl_0800323c + 8);\n  if (iVar14 < 0) {\n    iVar14 = -iVar14;\n  }\n  *(int *)(current_block + 6) = iVar14;\n  temp_uint1 = *(uint *)(current_block + 6);\n  if (*(uint *)(current_block + 6) < *(uint *)(current_block + 4)) {\n    temp_uint1 = *(uint *)(current_block + 4);\n  }\n  temp_uint2 = *(uint *)(current_block + 2);\n  if (*(uint *)(current_block + 2) < temp_uint1) {\n    temp_uint2 = temp_uint1;\n  }\n  *(uint *)(current_block + 8) = temp_uint2;\n  if (*(int *)(current_block + 8) != 0) {\n    temp_var1 = __floatsisf(lVar4 - *(int *)PTR_pl_0800323c);\n    temp_var1 = __aeabi_fdiv(temp_var1,*(undefined4 *)PTR_settings_08003238);\n    temp_var2 = __floatsisf(lVar5 - *(int *)(PTR_pl_0800323c + 4));\n    temp_var2 = __aeabi_fdiv(temp_var2,*(undefined4 *)(PTR_settings_08003238 + 4));\n    temp_var3 = __floatsisf(lVar6 - *(int *)(PTR_pl_0800323c + 8));\n    temp_var3 = __aeabi_fdiv(temp_var3,*(undefined4 *)(PTR_settings_08003238 + 8));\n    temp_var4 = __aeabi_fmul(temp_var1,temp_var1);\n    temp_var5 = __aeabi_fmul(temp_var2,temp_var2);\n    temp_var4 = __addsf3(temp_var4,temp_var5);\n    temp_var5 = __aeabi_fmul(temp_var3,temp_var3);\n    temp_var4 = __addsf3(temp_var4,temp_var5);\n    temp_var4 = __aeabi_f2d(temp_var4);\n    sqrt((double)CONCAT44(intermediate_var2,intermediate_var3));\n    temp_var4 = __truncdfsf2(temp_var4,extraout_var1);\n    *(undefined4 *)(current_block + 0x_move10) = temp_var4;\n    temp_var4 = __aeabi_fdiv(0x_move3f800000,*(undefined4 *)(current_block + 0x_move10));\n    if (stack_var == '\\0') {\n      inverse_minute = (float)__aeabi_fmul(intermediate_var3,temp_var4);\n    }\n    else {\n      inverse_minute = (float)__aeabi_fdiv(0x_move3f800000,intermediate_var3);\n    }\n    temp_var5 = __aeabi_fmul(*(undefined4 *)(current_block + 0x_move10),inverse_minute);\n    *(undefined4 *)(current_block + 10) = temp_var5;\n    temp_var5 = __floatsisf(*(undefined4 *)(current_block + 8));\n    temp_var5 = __aeabi_fmul(temp_var5,inverse_minute);\n    temp_var5 = __aeabi_f2d(temp_var5);\n    ceil((double)CONCAT44(intermediate_var2,intermediate_var3));\n    temp_var5 = __aeabi_d2uiz_move(temp_var5,extraout_var2);\n    *(undefined4 *)(current_block + 0x_move1e) = temp_var5;\n    temp_var5 = __floatsisf(*(undefined4 *)(current_block + 8));\n    temp_var5 = __aeabi_fmul(temp_var5,temp_var4);\n    temp_var5 = __aeabi_fmul(temp_var5,*(undefined4 *)(PTR_settings_08003560 + 0x_move20));\n    temp_var5 = __aeabi_fdiv(temp_var5,DAT_08003564);\n    temp_var5 = __aeabi_f2d(temp_var5);\n    ceil((double)CONCAT44(intermediate_var2,intermediate_var3));\n    temp_var5 = __aeabi_d2iz_move(temp_var5,extraout_var3);\n    *(undefined4 *)(current_block + 0x_move18) = temp_var5;\n    temp_var1 = __aeabi_fmul(temp_var1,temp_var4);\n    temp_var2 = __aeabi_fmul(temp_var2,temp_var4);\n    temp_var3 = __aeabi_fmul(temp_var3,temp_var4);\n    max_junction_velocity = 0.0;\n    temp_double1 = extraout_double1;\n    temp_float2 = extraout_float1;\n    if ((*PTR_block_buffer_head_08003568 != *PTR_block_buffer_tail_0800356c) &&\n       (iVar14 = __aeabi_fcmpgt(*(undefined4 *)(PTR_pl_08003570 + 0x_move18),0), temp_double1 = extraout_double2,\n       temp_float2 = extraout_float2, iVar14 != 0)) {\n      temp_var4 = __aeabi_fmul(*(uint *)(PTR_pl_08003570 + 0x_movec) ^ 0x_move80000000,temp_var1);\n      temp_var5 = __aeabi_fmul(*(undefined4 *)(PTR_pl_08003570 + 0x_move10),temp_var2);\n      temp_var4 = __aeabi_fsub(temp_var4,temp_var5);\n      temp_var5 = __aeabi_fmul(*(undefined4 *)(PTR_pl_08003570 + 0x_move14),temp_var3);\n      temp_var4 = __aeabi_fsub(temp_var4,temp_var5);\n      temp_double1 = __aeabi_f2d(temp_var4);\n      iVar14 = __aeabi_dcmplt((int)temp_double1,(int)((ulonglong)temp_double1 >> 0x_move20),DAT_08003550,DAT_08003554\n                             );\n      temp_double1 = extraout_double3;\n      temp_float2 = extraout_float3;\n      if (iVar14 != 0) {\n        iVar14 = __aeabi_fcmplt(*(undefined4 *)(PTR_pl_08003570 + 0x_move18),\n                                *(undefined4 *)(current_block + 10));\n        if (iVar14 == 0) {\n          max_junction_velocity = *(float *)(current_block + 10);\n        }\n        else {\n          max_junction_velocity = *(float *)(PTR_pl_08003570 + 0x_move18);\n        }\n        temp_double1 = __aeabi_f2d(temp_var4);\n        iVar14 = __aeabi_dcmpgt((int)temp_double1,(int)((ulonglong)temp_double1 >> 0x_move20),DAT_08003558,\n                                DAT_0800355c);\n        temp_double1 = extraout_double4;\n        temp_float2 = extraout_float4;\n        if (iVar14 != 0) {\n          temp_double1 = __aeabi_f2d(temp_var4);\n          temp_double1 = __subdf3(0,DAT_08003574,(int)temp_double1,(int)((ulonglong)temp_double1 >> 0x_move20));\n          temp_var4 = __muldf3((int)temp_double1,(int)((ulonglong)temp_double1 >> 0x_move20),0,DAT_08003578);\n          sqrt((double)CONCAT44(intermediate_var2,intermediate_var3));\n          temp_var4 = __truncdfsf2(temp_var4,extraout_var4);\n          temp_double1 = __aeabi_f2d(max_junction_velocity);\n          temp_var5 = __aeabi_fmul(*(undefined4 *)(PTR_settings_08003560 + 0x_move20),\n                                *(undefined4 *)(PTR_settings_08003560 + 0x_move24));\n          temp_var5 = __aeabi_fmul(temp_var5,temp_var4);\n          temp_double2 = __aeabi_f2d(temp_var5);\n          temp_double3 = __aeabi_f2d(temp_var4);\n          temp_double3 = __subdf3(0,DAT_08003574,(int)temp_double3,(int)((ulonglong)temp_double3 >> 0x_move20));\n          temp_var5 = __divdf3((int)temp_double2,(int)((ulonglong)temp_double2 >> 0x_move20),(int)temp_double3,\n                            (int)((ulonglong)temp_double3 >> 0x_move20));\n          sqrt((double)CONCAT44(intermediate_var2,intermediate_var3));\n          iVar14 = __aeabi_dcmplt((int)temp_double1,(int)((ulonglong)temp_double1 >> 0x_move20),temp_var5,extraout_var5\n                                 );\n          temp_double1 = extraout_double5;\n          temp_float2 = extraout_float5;\n          if (iVar14 == 0) {\n            temp_var5 = __aeabi_fmul(*(undefined4 *)(PTR_settings_08003560 + 0x_move20),\n                                  *(undefined4 *)(PTR_settings_08003560 + 0x_move24));\n            temp_var5 = __aeabi_fmul(temp_var5,temp_var4);\n            temp_double1 = __aeabi_f2d(temp_var5);\n            temp_double2 = __aeabi_f2d(temp_var4);\n            temp_double2 = __subdf3(0,DAT_08003574,(int)temp_double2,(int)((ulonglong)temp_double2 >> 0x_move20));\n            temp_var4 = __divdf3((int)temp_double1,(int)((ulonglong)temp_double1 >> 0x_move20),(int)temp_double2,\n                             (int)((ulonglong)temp_double2 >> 0x_move20));\n            sqrt((double)CONCAT44(intermediate_var2,intermediate_var3));\n            max_junction_velocity = (float)__truncdfsf2(temp_var4,extraout_var6);\n            temp_double1 = extraout_double6;\n            temp_float2 = extraout_float6;\n          }\n        }\n      }\n    }\n    *(float *)(current_block + 0x_movee) = max_junction_velocity;\n    temp_float = (float)(*(uint *)(PTR_settings_08003560 + 0x_move20) ^ 0x_move80000000);\n    max_move_allowable_speed((float)temp_double1,(float)((ulonglong)temp_double1 >> 0x_move20),temp_float2);\n    iVar14 = __aeabi_fcmplt(max_junction_velocity,temp_float);\n    temp_float2 = temp_float;\n    if (iVar14 != 0) {\n      temp_float2 = max_junction_velocity;\n    }\n    *(float *)(current_block + 0x_movec) = temp_float2;\n    iVar14 = __aeabi_fcmpge(temp_float,*(undefined4 *)(current_block + 10));\n    if (iVar14 == 0) {\n      *(undefined *)((int)current_block + 0x_move25) = 0;\n    }\n    else {\n      *(undefined *)((int)current_block + 0x_move25) = 1;\n    }\n    *(undefined *)(current_block + 0x_move12) = 1;\n    puVar1 = PTR_pl_080035e0;\n    *(undefined4 *)(PTR_pl_080035e0 + 0x_movec) = temp_var1;\n    *(undefined4 *)(puVar1 + 0x_move10) = temp_var2;\n    *(undefined4 *)(puVar1 + 0x_move14) = temp_var3;\n    *(undefined4 *)(PTR_pl_080035e0 + 0x_move18) = *(undefined4 *)(current_block + 10);\n    *PTR_block_buffer_head_080035e8 = *PTR_nex_movet_buffer_head_080035e4;\n    uVar2 = nex_movet_block_index_move(*PTR_block_buffer_head_080035e8);\n    *PTR_nex_movet_buffer_head_080035e4 = uVar2;\n    puVar1 = PTR_pl_080035e0;\n    *(long *)PTR_pl_080035e0 = lVar4;\n    *(long *)(puVar1 + 4) = lVar5;\n    *(long *)(puVar1 + 8) = lVar6;\n    planner_recalculate();\n  }\n  return;\n}\n\n",
            "called": [
                "__aeabi_fdiv",
                "__addsf3",
                "__aeabi_fmul",
                "__aeabi_dcmpgt",
                "__muldf3",
                "lround",
                "__aeabi_dcmplt",
                "sqrt",
                "__aeabi_fcmpge",
                "__truncdfsf2",
                "__aeabi_d2uiz",
                "__aeabi_f2d",
                "max_allowable_speed",
                "__aeabi_fsub",
                "__divdf3",
                "__floatsisf",
                "planner_recalculate",
                "__aeabi_fcmplt",
                "next_block_index",
                "ceil",
                "__aeabi_fcmpgt",
                "__aeabi_d2iz",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003004",
            "calling": [
                "mc_line"
            ],
            "imported": false,
            "current_name": "process_movement_08003004"
        },
        "FUN_080066cc": {
            "renaming": {
                "FUN_080066cc": "calculate_prescaler_frequency_080066cc",
                "uVar1": "hclk_frequency",
                "uVar2": "leading_zeroes_count",
                "result": "prescaler_frequency",
                "result_1": "final_frequency"
            },
            "code": "\nuint32_t calculate_prescaler_frequency_080066cc(void)\n\n{\n  uint32_t hclk_frequency;\n  uint leading_zeroes_count;\n  uint32_t prescaler_frequency;\n  uint32_t final_frequency;\n  \n  hclk_frequency = HAL_RCC_GetHCLKFreq();\n  leading_zeroes_count = count_leading_zeroes(0x70000);\n  return hclk_frequency >> PTR_APBAHBPrescTable_08006714\n                  [(*(uint *)(DAT_08006710 + 8) & 0xe000) >> (leading_zeroes_count & 0xff)];\n}\n\n",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080066cc",
            "calling": [
                "set_baud_rate"
            ],
            "imported": false,
            "current_name": "calculate_prescaler_frequency_080066cc"
        },
        "FUN_080018fc": {
            "renaming": {
                "FUN_080018fc": "update_bitmask_080018fc",
                "x": "input_value",
                "val": "updated_value"
            },
            "code": "\nvoid update_bitmask_080018fc(uint32_t input_value)\n\n{\n  uint32_t updated_value;\n  \n  *(uint32_t *)(DAT_08001928 + 0input_value14) = input_value | *(uint *)(DAT_08001928 + 0input_value14) & 0input_valuefffff55f;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080018fc",
            "calling": [
                "homing_cycle"
            ],
            "imported": false,
            "current_name": "update_bitmask_080018fc"
        },
        "FUN_080039bc": {
            "renaming": {
                "FUN_080039bc": "process_startup_lines_080039bc",
                "uVar1": "status",
                "n": "lineIndex"
            },
            "code": "\nvoid processStartupLines_080039bc(void)\n\n{\n  uilineIndext8_t status;\n  uilineIndext8_t lineIndex;\n  \n  for (lineIndex = '\\0'; lineIndex < 2; lineIndex = lineIndex + '\\x01') {\n    status = settilineIndexgs_read_startup_lilineIndexe(lineIndex,PTR_lilineIndexe_08003a14);\n    if (status == '\\0') {\n      report_status_message('\\lineIndex');\n    }\n    else if (*PTR_lilineIndexe_08003a14 != '\\0') {\n      prilineIndextStrilineIndexg(PTR_lilineIndexe_08003a14);\n      status = gc_execute_lilineIndexe(PTR_lilineIndexe_08003a14);\n      report_status_message(status);\n    }\n  }\n  returlineIndex;\n}\n\n",
            "called": [
                "report_status_message",
                "gc_execute_line",
                "printString",
                "settings_read_startup_line"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080039bc",
            "calling": [
                "protocol_execute_line",
                "grbl_main"
            ],
            "imported": false,
            "current_name": "process_startup_lines_080039bc"
        },
        "FUN_0800618c": {
            "renaming": {
                "FUN_0800618c": "configure_rcc_clocks_0800618c",
                "RCC_ClkInitStruct": "clock_init_struct",
                "FLatency": "flash_latency",
                "uVar1": "current_tick",
                "uVar2": "timeout_tick",
                "timeout": "timeout_duration"
            },
            "code": "\nHAL_StatusTypeDef Configure_RCC_Clocks_0800618c(RCC_ClkInitTypeDef *clock_init_struct,uint32_t flash_latency)\n\n{\n  uint32_t current_tick;\n  uint timeout_tick;\n  uint32_t timeout_duration;\n  \n  if ((*DAT_08006400 & 0xf) < flash_latency) {\n    *(char *)DAT_08006400 = (char)flash_latency;\n    if (flash_latency != (*DAT_08006400 & 0xf)) {\n      return HAL_ERROR;\n    }\n    if ((clock_init_struct->ClockType & 1) != 0) {\n      if (clock_init_struct->SYSCLKSource == 1) {\n        if ((*DAT_08006404 & 0x20000) == 0) {\n          return HAL_ERROR;\n        }\n      }\n      else if ((clock_init_struct->SYSCLKSource != 2) && ((*DAT_08006404 & 2) == 0)) {\n        return HAL_ERROR;\n      }\n      DAT_08006404[2] = clock_init_struct->SYSCLKSource | DAT_08006404[2] & 0xfffffffc;\n      current_tick = HAL_GetTick();\n      timeout_tick = current_tick + 5000;\n      if (clock_init_struct->SYSCLKSource == 1) {\n        while ((DAT_08006404[2] & 0xc) != 4) {\n          current_tick = HAL_GetTick();\n          if (timeout_tick <= current_tick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else if (clock_init_struct->SYSCLKSource == 2) {\n        while ((DAT_08006404[2] & 0xc) != 8) {\n          current_tick = HAL_GetTick();\n          if (timeout_tick <= current_tick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        while ((DAT_08006404[2] & 0xc) != 0) {\n          current_tick = HAL_GetTick();\n          if (timeout_tick <= current_tick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  else {\n    if ((clock_init_struct->ClockType & 1) != 0) {\n      if (clock_init_struct->SYSCLKSource == 1) {\n        if ((*DAT_08006404 & 0x20000) == 0) {\n          return HAL_ERROR;\n        }\n      }\n      else if (clock_init_struct->SYSCLKSource == 2) {\n        if ((*DAT_08006404 & 0x2000000) == 0) {\n          return HAL_ERROR;\n        }\n      }\n      else if ((*DAT_08006404 & 2) == 0) {\n        return HAL_ERROR;\n      }\n      DAT_08006404[2] = clock_init_struct->SYSCLKSource | DAT_08006404[2] & 0xfffffffc;\n      current_tick = HAL_GetTick();\n      timeout_tick = current_tick + 5000;\n      if (clock_init_struct->SYSCLKSource == 1) {\n        while ((DAT_08006404[2] & 0xc) != 4) {\n          current_tick = HAL_GetTick();\n          if (timeout_tick <= current_tick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else if (clock_init_struct->SYSCLKSource == 2) {\n        while ((DAT_08006404[2] & 0xc) != 8) {\n          current_tick = HAL_GetTick();\n          if (timeout_tick <= current_tick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        while ((DAT_08006404[2] & 0xc) != 0) {\n          current_tick = HAL_GetTick();\n          if (timeout_tick <= current_tick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    *(char *)DAT_08006400 = (char)flash_latency;\n    if (flash_latency != (*DAT_08006400 & 0xf)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((clock_init_struct->ClockType & 2) != 0) {\n    DAT_08006404[2] = clock_init_struct->AHBCLKDivider | DAT_08006404[2] & 0xffffff0f;\n  }\n  if ((clock_init_struct->ClockType & 4) != 0) {\n    DAT_08006404[2] = clock_init_struct->APB1CLKDivider | DAT_08006404[2] & 0xffffe3ff;\n  }\n  if ((clock_init_struct->ClockType & 8) != 0) {\n    DAT_08006404[2] = clock_init_struct->APB2CLKDivider << 3 | DAT_08006404[2] & 0xffff1fff;\n  }\n  current_tick = HAL_RCC_GetHCLKFreq();\n  SysTick_Config((uint)((ulonglong)DAT_08006408 * (ulonglong)current_tick >> 0x26));\n  return HAL_OK;\n}\n\n",
            "called": [
                "HAL_RCC_GetHCLKFreq",
                "SysTick_Config",
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800618c",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configure_rcc_clocks_0800618c"
        },
        "FUN_08006998": {
            "renaming": {
                "FUN_08006998": "extract_bits_08006998"
            },
            "code": "\nuint32_t extract_bits_08006998(void)\n\n{\n  return *(uint *)(DAT_080069b0 + 0xc) >> 8 & 7;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006998",
            "calling": [
                "HAL_NVIC_SetPriority",
                "HAL_NVIC_GetPriorityGrouping"
            ],
            "imported": false,
            "current_name": "extract_bits_08006998"
        },
        "FUN_080004ac": {
            "renaming": {
                "FUN_080004ac": "initialize_and_select_plane_080004ac",
                "uVar1": "coord_data_status"
            },
            "code": "\nvoid initialize_and_select_plane_080004ac(void)\n\n{\n  uint8_t coord_data_status;\n  \n  memset(PTR_gc_080004f0,0,0x38);\n  *(undefined4 *)(PTR_gc_080004f0 + 8) = *(undefined4 *)(PTR_settings_080004f4 + 0x10);\n  select_plane('\\0','\\x01','\\x02');\n  PTR_gc_080004f0[4] = 1;\n  coord_data_status = settings_read_coord_data(PTR_gc_080004f0[0x1c],DAT_080004f8);\n  if (coord_data_status == '\\0') {\n    report_status_message('\\n');\n  }\n  return;\n}\n\n",
            "called": [
                "report_status_message",
                "memset",
                "settings_read_coord_data",
                "select_plane"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080004ac",
            "calling": [
                "grbl_main"
            ],
            "imported": false,
            "current_name": "initialize_and_select_plane_080004ac"
        },
        "FUN_080078f4": {
            "renaming": {
                "FUN_080078f4": "calculate_bitwise_or_080078f4",
                "i": "index",
                "state": "bitwiseOrResult"
            },
            "code": "\nuindexnt32_t calculateBitwiseOr_080078f4(voindexd)\n\n{\n  indexnt index;\n  uindexnt32_t bitwiseOrResult;\n  \n  bitwiseOrResult = 0;\n  for (index = 0; index < 4; index = index + 1) {\n    bitwiseOrResult = *(uindexnt *)(PTR_debounce_0800792c + index * 4) | bitwiseOrResult;\n  }\n  return bitwiseOrResult;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080078f4",
            "calling": [
                "debounce_isr",
                "homing_cycle"
            ],
            "imported": false,
            "current_name": "calculate_bitwise_or_080078f4"
        },
        "FUN_080041a0": {
            "renaming": {
                "FUN_080041a0": "print_message_by_code_080041a0",
                "message_code": "messageCode"
            },
            "code": "\nvoid printMessageByCode_080041a0(uint8_t messageCode)\n\n{\n  printPgmString(PTR_DAT_0800420c);\n  switch(messageCode) {\n  case '\\x01':\n    printPgmString(PTR_s_Reset_to_continue_08004210);\n    break;\n  case '\\x02':\n    printPgmString(PTR_s___H____X__to_unlock_08004214);\n    break;\n  case '\\x03':\n    printPgmString(PTR_s_Caution__Unlocked_08004218);\n    break;\n  case '\\x04':\n    printPgmString(PTR_s_Enabled_0800421c);\n    break;\n  case '\\x05':\n    printPgmString(PTR_s_Disabled_08004220);\n  }\n  printPgmString(PTR_DAT_08004224);\n  return;\n}\n\n",
            "called": [
                "printPgmString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080041a0",
            "calling": [
                "protocol_execute_line",
                "protocol_execute_runtime",
                "grbl_main"
            ],
            "imported": false,
            "current_name": "print_message_by_code_080041a0"
        },
        "FUN_08008bf0": {
            "renaming": {
                "FUN_08008bf0": "calculate_result_08008bf0",
                "param_1": "input1",
                "param_2": "input2",
                "iVar1": "intermediateVar",
                "uVar2": "unsignedVar"
            },
            "code": "\nuint calculateResult_08008bf0(uint input1,uint input2)\n\n{\n  int intermediateVar;\n  uint unsignedVar;\n  \n  if ((input2 & 0x80000000) != 0) {\n    return 0;\n  }\n  intermediateVar = input2 * 2 + 0x200000;\n  if (input2 * 2 < 0xffe00000) {\n    if (-1 < intermediateVar) {\n      return 0;\n    }\n    unsignedVar = -(intermediateVar >> 0x15) - 0x3e1;\n    if (-1 < (int)unsignedVar) {\n      return (input2 << 0xb | 0x80000000 | input1 >> 0x15) >> (unsignedVar & 0xff);\n    }\n  }\n  else if ((input1 | input2 << 0xc) != 0) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008bf0",
            "calling": [
                "protocol_execute_line",
                "mc_arc",
                "homing_cycle",
                "gc_execute_line",
                "calculate_trapezoid_for_block",
                "settings_store_global_setting",
                "plan_buffer_line",
                "mc_dwell"
            ],
            "imported": false,
            "current_name": "calculate_result_08008bf0"
        },
        "FUN_0800771a": {
            "renaming": {
                "FUN_0800771a": "infinite_loop_0800771a"
            },
            "code": "\nvoid infiniteLoop_0800771a(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800771a",
            "calling": [],
            "imported": false,
            "current_name": "infinite_loop_0800771a"
        },
        "FUN_08003a18": {
            "renaming": {
                "FUN_08003a18": "process_button_input_08003a18",
                "buttons": "buttonInput"
            },
            "code": "\nvoid processButtonInput_08003a18(uint32_t buttonInput)\n\n{\n  if ((buttonInput & 0x80) == 0) {\n    if ((buttonInput & 0x40) == 0) {\n      if ((buttonInput & 0x20) != 0) {\n        PTR_sys_08003a70[2] = PTR_sys_08003a70[2] | 2;\n      }\n    }\n    else {\n      PTR_sys_08003a70[2] = PTR_sys_08003a70[2] | 8;\n    }\n  }\n  else {\n    mc_reset();\n  }\n  return;\n}\n\n",
            "called": [
                "mc_reset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a18",
            "calling": [
                "debounce_on_handler"
            ],
            "imported": false,
            "current_name": "process_button_input_08003a18"
        },
        "FUN_08005790": {
            "renaming": {
                "FUN_08005790": "initialize_stepper_motor_08005790"
            },
            "code": "\nvoid initialize_stepper_motor_08005790(void)\n\n{\n  stepper_motor_enable();\n  if (PTR_sys_080057d4[1] == '\\x03') {\n    *(undefined2 *)PTR_step_bits_080057dc = *(undefined2 *)(PTR_settings_080057d8 + 0x18);\n    *(undefined2 *)PTR_dirn_bits_080057e0 = *(undefined2 *)(PTR_settings_080057d8 + 0x1a);\n    set_step_pulse_delay(0x69);\n    set_step_pulse_time(((byte)PTR_settings_080057d8[0xd] + 5) * 0x15);\n    step_isr_enable();\n  }\n  return;\n}\n\n",
            "called": [
                "stepper_motor_enable",
                "set_step_pulse_delay",
                "set_step_pulse_time",
                "step_isr_enable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005790",
            "calling": [
                "limits_go_home",
                "st_init",
                "st_cycle_start"
            ],
            "imported": false,
            "current_name": "initialize_stepper_motor_08005790"
        },
        "FUN_08007732": {
            "renaming": {
                "FUN_08007732": "do_nothing_08007732"
            },
            "code": "\nvoid do_nothing_08007732(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007732",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_08007732"
        },
        "FUN_08001994": {
            "renaming": {
                "FUN_08001994": "execute_stepper_movement_08001994",
                "cycle_mask": "axis_mask",
                "pos_dir": "positive_direction",
                "invert_pin": "invert_limit_pins",
                "homing_rate": "homing_feedrate",
                "uVar1": "initial_step_bits",
                "uVar2": "temp_float1",
                "uVar3": "temp_float2",
                "iVar4": "temp_int",
                "uVar5": "temp_uint",
                "extraout_r1": "extra_float1",
                "extraout_r1_00": "extra_float2",
                "extraout_r1_01": "extra_float3",
                "uVar6": "max_steps1",
                "uVar7": "max_steps2",
                "in_r3": "temp_var",
                "uVar8": "temp_double",
                "in_stack_ffffff9c": "stack_var",
                "cVar9": "inverted_limit_state",
                "steps": "step_counts",
                "step_bits0": "step_bits_initial",
                "dt_min": "min_delay",
                "delta_rate": "rate_delta",
                "ds": "distance_float",
                "step_event_count": "step_event_total",
                "limit_state": "current_limit_state",
                "step_bits": "current_step_bits",
                "trap_counter": "trap_count",
                "step_rate": "current_step_rate",
                "step_delay": "current_step_delay",
                "counter_z": "z_counter",
                "counter_y": "y_counter",
                "counter_x": "x_counter",
                "dirn_bits": "direction_bits",
                "dt": "current_delay",
                "dist": "axis_count"
            },
            "code": "\nvoid execute_stepper_movement_08001994(uint8_t axis_mask,int8_t positive_direction,_Bool invert_limit_pins,float homing_feedrate)\n\n{\n  ushort initial_step_bits;\n  undefined4 temp_float1;\n  undefined4 temp_float2;\n  int temp_int;\n  uint temp_uint;\n  undefined4 extra_float1;\n  undefined4 extra_float2;\n  undefined4 extra_float3;\n  uint32_t max_steps1;\n  undefined4 temp_var;\n  uint32_t max_steps2;\n  undefined8 temp_double;\n  undefined stack_var;\n  char inverted_limit_state;\n  uint32_t step_counts [3];\n  uint16_t step_bits_initial;\n  uint32_t min_delay;\n  uint32_t rate_delta;\n  float distance_float;\n  uint32_t step_event_total;\n  uint32_t current_limit_state;\n  uint16_t current_step_bits;\n  uint32_t trap_count;\n  uint32_t current_step_rate;\n  uint32_t current_step_delay;\n  int32_t z_counter;\n  int32_t y_counter;\n  int32_t x_counter;\n  uint16_t direction_bits;\n  uint32_t current_delay;\n  uint8_t axis_count;\n  \n  inverted_limit_state = !invert_limit_pins;\n  memset(step_counts,0,0xc);\n  axis_count = (axis_mask & 1) != 0;\n  if ((bool)axis_count) {\n    __aeabi_f2d(*(undefined4 *)PTR_settings_08001c90);\n    step_counts[0] = lround((double)CONCAT17(axis_mask,\n                                       CONCAT16(positive_direction,CONCAT15(inverted_limit_state,CONCAT14(stack_var,\n                                                                                temp_var)))));\n  }\n  if ((axis_mask & 2) != 0) {\n    axis_count = axis_count + '\\x01';\n    __aeabi_f2d(*(undefined4 *)(PTR_settings_08001c90 + 4));\n    step_counts[1] = lround((double)CONCAT17(axis_mask,\n                                       CONCAT16(positive_direction,CONCAT15(inverted_limit_state,CONCAT14(stack_var,\n                                                                                temp_var)))));\n  }\n  if ((axis_mask & 4) != 0) {\n    axis_count = axis_count + '\\x01';\n    __aeabi_f2d(*(undefined4 *)(PTR_settings_08001c90 + 8));\n    step_counts[2] = lround((double)CONCAT17(axis_mask,\n                                       CONCAT16(positive_direction,CONCAT15(inverted_limit_state,CONCAT14(stack_var,\n                                                                                temp_var)))));\n  }\n  max_steps1 = step_counts[2];\n  if (step_counts[2] < step_counts[1]) {\n    max_steps1 = step_counts[1];\n  }\n  max_steps2 = step_counts[0];\n  if (step_counts[0] < max_steps1) {\n    max_steps2 = max_steps1;\n  }\n  temp_double = __floatunsidf(max_steps2);\n  temp_float1 = __floatunsidf(axis_count);\n  sqrt((double)CONCAT17(axis_mask,\n                        CONCAT16(positive_direction,CONCAT15(inverted_limit_state,CONCAT14(stack_var,temp_var)))));\n  temp_double = __divdf3((int)temp_double,(int)((ulonglong)temp_double >> 0x20),temp_float1,extra_float1);\n  temp_float1 = __truncdfsf2((int)temp_double,(int)((ulonglong)temp_double >> 0x20));\n  temp_float2 = __aeabi_fmul(*(undefined4 *)(PTR_settings_08001c90 + 0x20),temp_float1);\n  temp_float2 = __aeabi_fdiv(temp_float2,DAT_08001c94);\n  temp_float2 = __aeabi_f2d(temp_float2);\n  ceil((double)CONCAT17(axis_mask,\n                        CONCAT16(positive_direction,CONCAT15(inverted_limit_state,CONCAT14(stack_var,temp_var)))));\n  temp_int = __aeabi_d2uiz(temp_float2,extra_float2);\n  temp_float2 = __floatunsidf(axis_count);\n  sqrt((double)CONCAT17(axis_mask,\n                        CONCAT16(positive_direction,CONCAT15(inverted_limit_state,CONCAT14(stack_var,temp_var)))));\n  temp_double = __aeabi_f2d(temp_var);\n  temp_double = __muldf3(temp_float2,extra_float3,(int)temp_double,(int)((ulonglong)temp_double >> 0x20));\n  temp_float2 = __truncdfsf2((int)temp_double,(int)((ulonglong)temp_double >> 0x20));\n  temp_float1 = __aeabi_fmul(temp_float1,temp_float2);\n  temp_float1 = __aeabi_fdiv(DAT_08001c98,temp_float1);\n  __aeabi_f2d(temp_float1);\n  temp_uint = lround((double)CONCAT17(axis_mask,\n                                  CONCAT16(positive_direction,CONCAT15(inverted_limit_state,CONCAT14(stack_var,temp_float2))\n                                          )));\n  current_delay = DAT_08001c9c;\n  if (temp_uint < DAT_08001c9c) {\n    current_delay = temp_uint;\n  }\n  initial_step_bits = *(ushort *)(PTR_settings_08001c90 + 0x18);\n  direction_bits = *(ushort *)(PTR_settings_08001c90 + 0x1a) ^\n              *(ushort *)(PTR_settings_08001c90 + 0x2a) & 0xaa0;\n  if (positive_direction == '\\0') {\n    direction_bits = direction_bits ^ 0xaa0;\n  }\n  dirn_wr((uint)direction_bits);\n  step_wr((uint)initial_step_bits);\n  z_counter = -(max_steps2 >> 1);\n  current_step_delay = current_delay - (byte)PTR_settings_08001c90[0xd];\n  current_step_rate = 0;\n  trap_count = 10000;\n  y_counter = z_counter;\n  x_counter = z_counter;\n  while( true ) {\n    current_limit_state = debounce_rd();\n    if (inverted_limit_state != '\\0') {\n      current_limit_state = current_limit_state ^ 0x1e;\n    }\n    current_step_bits = initial_step_bits;\n    if (((axis_mask & 1) != 0) && (x_counter = x_counter + step_counts[0], 0 < x_counter)) {\n      if ((current_limit_state & 0x10) == 0) {\n        axis_mask = axis_mask & 0xfe;\n      }\n      else {\n        current_step_bits = initial_step_bits ^ 0x10;\n      }\n      x_counter = x_counter - max_steps2;\n    }\n    if (((axis_mask & 2) != 0) && (y_counter = y_counter + step_counts[1], 0 < y_counter)) {\n      if ((current_limit_state & 8) == 0) {\n        axis_mask = axis_mask & 0xfd;\n      }\n      else {\n        current_step_bits = current_step_bits ^ 0x440;\n      }\n      y_counter = y_counter - max_steps2;\n    }\n    if (((axis_mask & 4) != 0) && (z_counter = z_counter + step_counts[2], 0 < z_counter)) {\n      if ((current_limit_state & 4) == 0) {\n        axis_mask = axis_mask & 0xfb;\n      }\n      else {\n        current_step_bits = current_step_bits ^ 0x100;\n      }\n      z_counter = z_counter - max_steps2;\n    }\n    if ((axis_mask == 0) || ((PTR_sys_08001d40[2] & 0x10) != 0)) break;\n    step_wr((uint)current_step_bits);\n    delay_us((uint)(byte)PTR_settings_08001d44[0xd]);\n    step_wr((uint)initial_step_bits);\n    delay_us(current_step_delay);\n    if ((temp_uint < current_delay) && (trap_count = current_delay + trap_count, 20000 < trap_count)) {\n      trap_count = trap_count - 20000;\n      current_step_rate = temp_int + current_step_rate;\n      current_delay = DAT_08001d48 / current_step_rate;\n      if (DAT_08001d48 / current_step_rate < temp_uint) {\n        current_delay = temp_uint;\n      }\n      current_step_delay = current_delay - (byte)PTR_settings_08001d44[0xd];\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "delay_us",
                "__aeabi_fdiv",
                "__floatunsidf",
                "__aeabi_fmul",
                "lround",
                "__muldf3",
                "sqrt",
                "__truncdfsf2",
                "__aeabi_d2uiz",
                "__aeabi_f2d",
                "debounce_rd",
                "__divdf3",
                "memset",
                "dirn_wr",
                "step_wr",
                "ceil"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001994",
            "calling": [
                "limits_go_home"
            ],
            "imported": false,
            "current_name": "execute_stepper_movement_08001994"
        },
        "FUN_08007854": {
            "renaming": {
                "FUN_08007854": "get_bit_from_memory_08007854",
                "n": "bit_index"
            },
            "code": "\nibit_indext getBitFromMemory_08007854(ibit_indext bit_index)\n\n{\n  returbit_index *(uibit_indext *)((bit_index >> 4) * 0x400 + 0x40020010) >> (bit_index & 0xfU) & 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007854",
            "calling": [
                "debounce_input"
            ],
            "imported": false,
            "current_name": "get_bit_from_memory_08007854"
        },
        "FUN_08004900": {
            "renaming": {
                "FUN_08004900": "print_formatted_message_08004900",
                "n": "messageCode",
                "line": "additionalText"
            },
            "code": "\nvoid printFormattedMessage_08004900(uimessageCodet8_t messageCode,char *additionalText)\n\n{\n  primessageCodetPgmStrimessageCodeg(PTR_DAT_08004934);\n  primessageCodetImessageCodeteger((uimessageCodet)messageCode);\n  primessageCodetPgmStrimessageCodeg(PTR_DAT_08004938);\n  primessageCodetStrimessageCodeg(additionalText);\n  primessageCodetPgmStrimessageCodeg(PTR_DAT_0800493c);\n  returmessageCode;\n}\n\n",
            "called": [
                "printInteger",
                "printPgmString",
                "printString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004900",
            "calling": [
                "protocol_execute_line"
            ],
            "imported": false,
            "current_name": "print_formatted_message_08004900"
        },
        "FUN_08005318": {
            "renaming": {
                "FUN_08005318": "do_nothing_08005318"
            },
            "code": "\nvoid do_nothing_08005318(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005318",
            "calling": [
                "st_wake_up"
            ],
            "imported": false,
            "current_name": "do_nothing_08005318"
        },
        "FUN_08004228": {
            "renaming": {
                "FUN_08004228": "print_grbl_version_08004228"
            },
            "code": "\nvoid printGrblVersion_08004228(void)\n\n{\n  printPgmString(PTR_s__Grbl_0_8c______for_help__08004238);\n  return;\n}\n\n",
            "called": [
                "printPgmString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004228",
            "calling": [
                "protocol_init"
            ],
            "imported": false,
            "current_name": "print_grbl_version_08004228"
        },
        "FUN_08009b24": {
            "renaming": {
                "FUN_08009b24": "calculate_distance_08009b24",
                "param_1": "x1",
                "param_2": "y1",
                "param_3": "x2",
                "param_4": "y2",
                "uVar1": "temp_var1",
                "iVar2": "temp_int2",
                "uVar3": "result_x",
                "iVar4": "temp_int4",
                "uVar5": "temp_var5",
                "iVar6": "temp_int6",
                "uVar7": "result_y",
                "uVar8": "temp_var8",
                "uVar9": "temp_var9",
                "uVar10": "temp_var10",
                "uVar11": "temp_var11",
                "uVar12": "temp_var12",
                "uVar13": "temp_var13",
                "local_3c": "local_offset"
            },
            "code": "\nuint calculate_distance_08009b24(uint x1,uint y1,uint x2,uint y2)\n\n{\n  undefined4 temp_var1;\n  int temp_int2;\n  uint result_x;\n  int temp_int4;\n  undefined4 temp_var5;\n  int temp_int6;\n  uint result_y;\n  undefined4 temp_var8;\n  undefined4 temp_var9;\n  undefined8 temp_var10;\n  undefined8 temp_var11;\n  undefined8 temp_var12;\n  undefined8 temp_var13;\n  int local_offset;\n  \n  temp_var1 = DAT_08009d70;\n  y1 = y1 & 0x7fffffff;\n  y2 = y2 & 0x7fffffff;\n  result_x = x1;\n  result_y = y1;\n  if (y1 < y2) {\n    result_x = x2;\n    x2 = x1;\n    result_y = y2;\n    y2 = y1;\n  }\n  if (0x3c00000 < (int)(result_y - y2)) {\n    result_x = __aeabi_dadd(result_x,result_y,x2,y2);\n    return result_x;\n  }\n  if (DAT_08009d68 < (int)result_y) {\n    if (DAT_08009d74 < (int)result_y) {\n      if ((result_y & 0xfffff | result_x) != 0) {\n        result_x = __aeabi_dadd(result_x,result_y,x2,y2);\n      }\n      if ((y2 ^ 0x7ff00000 | x2) != 0) {\n        return result_x;\n      }\n      return x2;\n    }\n    result_y = result_y + 0xda800000;\n    y2 = y2 + 0xda800000;\n    local_offset = 600;\n  }\n  else {\n    local_offset = 0;\n  }\n  temp_var11 = CONCAT44(result_y,result_x);\n  temp_var10 = CONCAT44(y2,x2);\n  if ((int)y2 <= DAT_08009d6c) {\n    if ((int)y2 < 0x100000) {\n      if ((y2 | x2) == 0) {\n        return result_x;\n      }\n      temp_var10 = __muldf3(x2,y2,0,DAT_08009d70);\n      temp_var11 = __muldf3(result_x,result_y,0,temp_var1);\n      local_offset = local_offset + -0x3fe;\n    }\n    else {\n      result_y = result_y + 0x25800000;\n      temp_var11 = CONCAT44(result_y,result_x);\n      y2 = y2 + 0x25800000;\n      temp_var10 = CONCAT44(y2,x2);\n      local_offset = local_offset + -600;\n    }\n  }\n  temp_var9 = (undefined4)((ulonglong)temp_var11 >> 0x20);\n  temp_var8 = (undefined4)temp_var11;\n  temp_int6 = (int)((ulonglong)temp_var10 >> 0x20);\n  temp_var5 = (undefined4)temp_var10;\n  temp_var10 = __subdf3(temp_var8,temp_var9,temp_var5,temp_int6);\n  temp_int4 = (int)((ulonglong)temp_var10 >> 0x20);\n  temp_var1 = (undefined4)temp_var10;\n  temp_int2 = __aeabi_dcmplt(temp_var5,temp_int6,temp_var1,temp_int4);\n  if (temp_int2 == 0) {\n    temp_var10 = __muldf3(0,y2,0);\n    temp_var11 = __muldf3(temp_var1,temp_int4 + -0x80000000,temp_var1,temp_int4);\n    temp_var12 = __aeabi_dadd(temp_var8,temp_var9,temp_var8,temp_var9);\n    temp_var12 = __subdf3((int)temp_var12,(int)((ulonglong)temp_var12 >> 0x20),0,result_y + 0x100000);\n    temp_var12 = __muldf3((int)temp_var12,(int)((ulonglong)temp_var12 >> 0x20),temp_var5,temp_int6);\n    temp_var13 = __subdf3(temp_var5,temp_int6,0,y2);\n    temp_var13 = __muldf3((int)temp_var13,(int)((ulonglong)temp_var13 >> 0x20),0,result_y + 0x100000);\n    temp_var12 = __aeabi_dadd((int)temp_var12,(int)((ulonglong)temp_var12 >> 0x20),(int)temp_var13,\n                          (int)((ulonglong)temp_var13 >> 0x20));\n    temp_var11 = __subdf3((int)temp_var11,(int)((ulonglong)temp_var11 >> 0x20),(int)temp_var12,\n                      (int)((ulonglong)temp_var12 >> 0x20));\n    __subdf3((int)temp_var10,(int)((ulonglong)temp_var10 >> 0x20),(int)temp_var11,\n             (int)((ulonglong)temp_var11 >> 0x20));\n    temp_var10 = __ieee754_sqrt();\n  }\n  else {\n    temp_var10 = __muldf3(0,result_y,0,result_y);\n    temp_var11 = __muldf3(temp_var5,temp_int6 + -0x80000000,temp_var5,temp_int6);\n    temp_var12 = __aeabi_dadd(temp_var8,temp_var9,0,result_y);\n    temp_var13 = __subdf3(temp_var8,temp_var9,0,result_y);\n    temp_var12 = __muldf3((int)temp_var12,(int)((ulonglong)temp_var12 >> 0x20),(int)temp_var13,\n                      (int)((ulonglong)temp_var13 >> 0x20));\n    temp_var11 = __subdf3((int)temp_var11,(int)((ulonglong)temp_var11 >> 0x20),(int)temp_var12,\n                      (int)((ulonglong)temp_var12 >> 0x20));\n    __subdf3((int)temp_var10,(int)((ulonglong)temp_var10 >> 0x20),(int)temp_var11,\n             (int)((ulonglong)temp_var11 >> 0x20));\n    temp_var10 = __ieee754_sqrt();\n  }\n  result_x = (uint)temp_var10;\n  if (local_offset != 0) {\n    result_x = __muldf3(result_x,(int)((ulonglong)temp_var10 >> 0x20),0,local_offset * 0x100000 + 0x3ff00000);\n  }\n  return result_x;\n}\n\n",
            "called": [
                "__ieee754_sqrt",
                "__muldf3",
                "__aeabi_dcmplt",
                "__aeabi_dadd",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009b24",
            "calling": [
                "hypot"
            ],
            "imported": false,
            "current_name": "calculate_distance_08009b24"
        },
        "FUN_080076c8": {
            "renaming": {
                "FUN_080076c8": "toggle_bit_080076c8",
                "n": "bit_position"
            },
            "code": "\nvoid toggle_bit_080076c8(ibit_positiont bit_position)\n\n{\n  *(uibit_positiont *)((bit_position >> 4) * 0x400 + 0x40020014) =\n       *(uibit_positiont *)((bit_position >> 4) * 0x400 + 0x40020014) ^ 1 << (bit_position & 0xfU);\n  returbit_position;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080076c8",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "toggle_bit_080076c8"
        },
        "FUN_0800530c": {
            "renaming": {
                "FUN_0800530c": "do_nothing_0800530c"
            },
            "code": "\nvoid do_nothing_0800530c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800530c",
            "calling": [
                "st_go_idle"
            ],
            "imported": false,
            "current_name": "do_nothing_0800530c"
        },
        "FUN_08006a8c": {
            "renaming": {
                "FUN_08006a8c": "set_interrupt_08006a8c",
                "IRQn": "interruptNumber",
                "IRQn_Type": "InterruptType"
            },
            "code": "\nvoid setInterrupt_08006a8c(InterruptType interruptNumber)\n\n{\n  *(int *)(DAT_08006abc + (((uint)(int)interruptNumber >> 5) + 0x60) * 4) = 1 << (interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006a8c",
            "calling": [
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "imported": false,
            "current_name": "set_interrupt_08006a8c"
        },
        "FUN_0800772c": {
            "renaming": {
                "FUN_0800772c": "infinite_loop_0800772c"
            },
            "code": "\nvoid infiniteLoop_0800772c(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800772c",
            "calling": [],
            "imported": false,
            "current_name": "infinite_loop_0800772c"
        },
        "FUN_0800283a": {
            "renaming": {
                "FUN_0800283a": "update_current_position_0800283a"
            },
            "code": "\nvoid update_current_position_0800283a(void)\n\n{\n  plan_set_current_position\n            (*(int32_t *)(PTR_sys_08002868 + 4),*(int32_t *)(PTR_sys_08002868 + 8),\n             *(int32_t *)(PTR_sys_08002868 + 0xc));\n  gc_set_current_position\n            (*(int32_t *)(PTR_sys_08002868 + 4),*(int32_t *)(PTR_sys_08002868 + 8),\n             *(int32_t *)(PTR_sys_08002868 + 0xc));\n  return;\n}\n\n",
            "called": [
                "gc_set_current_position",
                "plan_set_current_position"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800283a",
            "calling": [
                "grbl_main",
                "mc_go_home"
            ],
            "imported": false,
            "current_name": "update_current_position_0800283a"
        },
        "FUN_0800881c": {
            "renaming": {
                "FUN_0800881c": "calculate_result_0800881c",
                "param_1": "input_a",
                "param_2": "input_b",
                "param_3": "input_c",
                "param_4": "input_d",
                "uVar1": "temp_var1",
                "unaff_r4": "condition_var",
                "uVar2": "temp_var2",
                "uVar3": "temp_var3",
                "in_r12": "compare_value",
                "bVar4": "check_condition"
            },
            "code": "\nulonglong calculate_result_0800881c(uint input_a,uint input_b,uint input_c,uint input_d)\n\n{\n  uint temp_var1;\n  uint condition_var;\n  uint temp_var2;\n  uint temp_var3;\n  uint compare_value;\n  bool check_condition;\n  \n  temp_var2 = compare_value & input_d >> 0x14;\n  if (condition_var != compare_value && temp_var2 != compare_value) {\n    check_condition = (input_a | input_b << 1) == 0;\n    if (!check_condition) {\n      check_condition = (input_c | input_d << 1) == 0;\n    }\n    if (check_condition) {\n      return (ulonglong)((input_b ^ input_d) & 0x80000000) << 0x20;\n    }\n    if (condition_var == 0) {\n      temp_var3 = input_b & 0x80000000;\n      do {\n        temp_var1 = input_a & 0x80000000;\n        input_a = input_a << 1;\n        input_b = input_b * 2 + (uint)(temp_var1 != 0);\n      } while ((input_b & 0x100000) == 0);\n      input_b = input_b | temp_var3;\n      if (temp_var2 != 0) {\n        return CONCAT44(input_b,input_a);\n      }\n    }\n    do {\n      temp_var2 = input_c & 0x80000000;\n      input_c = input_c << 1;\n      input_d = input_d * 2 + (uint)(temp_var2 != 0);\n    } while ((input_d & 0x100000) == 0);\n    return CONCAT44(input_b,input_a);\n  }\n  check_condition = (input_a | input_b << 1) == 0;\n  if (check_condition) {\n    input_b = input_d;\n    input_a = input_c;\n  }\n  if (!check_condition) {\n    check_condition = (input_c | input_d << 1) == 0;\n  }\n  temp_var3 = input_b;\n  if (((!check_condition) && ((condition_var != compare_value || ((input_a | input_b << 0xc) == 0)))) &&\n     ((temp_var2 != compare_value || (input_a = input_c, temp_var3 = input_d, (input_c | input_d << 0xc) == 0)))) {\n    return (ulonglong)((input_b ^ input_d) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(temp_var3,input_a) | 0x7ff8000000000000;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800881c",
            "calling": [
                "__muldf3"
            ],
            "imported": false,
            "current_name": "calculate_result_0800881c"
        },
        "FUN_08004bc0": {
            "renaming": {
                "FUN_08004bc0": "store_data_to_eeprom_08004bc0",
                "n": "dataIndex",
                "line": "dataBuffer",
                "addr": "eepromAddr"
            },
            "code": "\nvoid storeDataToEEPROM_08004bc0(uidataIndext8_t dataIndex,char *dataBuffer)\n\n{\n  uidataIndext16_t eepromAddr;\n  \n  memcpy_to_eeprom_with_checksum((uidataIndext)(ushort)((ushort)dataIndex * 0x101 + 0x300),dataBuffer,0x100);\n  returdataIndex;\n}\n\n",
            "called": [
                "memcpy_to_eeprom_with_checksum"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004bc0",
            "calling": [
                "protocol_execute_line",
                "settings_read_startup_line"
            ],
            "imported": false,
            "current_name": "store_data_to_eeprom_08004bc0"
        },
        "FUN_08008b4c": {
            "renaming": {
                "FUN_08008b4c": "compare_floating_points_08008b4c",
                "in_ZR": "zeroFlag",
                "in_CY": "carryFlag"
            },
            "code": "\nbool compareFloatingPoints_08008b4c(void)\n\n{\n  undefined zeroFlag;\n  undefined carryFlag;\n  \n  __aeabi_cdrcmple();\n  return !(bool)carryFlag || (bool)zeroFlag;\n}\n\n",
            "called": [
                "__aeabi_cdrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b4c",
            "calling": [
                "__kernel_rem_pio2"
            ],
            "imported": false,
            "current_name": "compare_floating_points_08008b4c"
        },
        "FUN_08004c2a": {
            "renaming": {
                "FUN_08004c2a": "save_settings_to_eeprom_08004c2a"
            },
            "code": "\nvoid saveSettingsToEEPROM_08004c2a(void)\n\n{\n  eeprom_put_char(0,'\\x05');\n  memcpy_to_eeprom_with_checksum(1,PTR_settings_08004c44,0x40);\n  return;\n}\n\n",
            "called": [
                "eeprom_put_char",
                "memcpy_to_eeprom_with_checksum"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c2a",
            "calling": [
                "settings_reset",
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "save_settings_to_eeprom_08004c2a"
        },
        "FUN_0800826a": {
            "renaming": {
                "FUN_0800826a": "send_character_0800826a",
                "ch": "character"
            },
            "code": "\nint send_character_0800826a(int character)\n\n{\n  usart_putc((characterar)character);\n  return 0;\n}\n\n",
            "called": [
                "usart_putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800826a",
            "calling": [],
            "imported": false,
            "current_name": "send_character_0800826a"
        },
        "FUN_08008b60": {
            "renaming": {
                "FUN_08008b60": "compare_floats_08008b60",
                "in_CY": "comparison_result"
            },
            "code": "\nbool compare_floats_08008b60(void)\n\n{\n  char comparison_result;\n  \n  __aeabi_cdrcmple();\n  return comparison_result == '\\0';\n}\n\n",
            "called": [
                "__aeabi_cdrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b60",
            "calling": [
                "floor",
                "ceil",
                "plan_buffer_line",
                "atan"
            ],
            "imported": false,
            "current_name": "compare_floats_08008b60"
        },
        "FUN_08005324": {
            "renaming": {
                "FUN_08005324": "configure_step_period_08005324",
                "steps_per_minute": "stepsPerMinute",
                "ticks_00": "calculatedTicks",
                "local_14": "adjustedStepsPerMinute"
            },
            "code": "\nvoid configure_step_period_08005324(uint32_t stepsPerMinute)\n\n{\n  uint calculatedTicks;\n  uint32_t adjustedStepsPerMinute;\n  uint32_t ticks;\n  \n  adjustedStepsPerMinute = stepsPerMinute;\n  if (stepsPerMinute < 800) {\n    adjustedStepsPerMinute = 800;\n  }\n  calculatedTicks = DAT_08005358 / adjustedStepsPerMinute;\n  *(uint *)(PTR_st_0800535c + 0x14) = calculatedTicks;\n  set_step_period(calculatedTicks);\n  return;\n}\n\n",
            "called": [
                "set_step_period"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005324",
            "calling": [
                "st_cycle_reinitialize",
                "step_period_isr",
                "st_reset"
            ],
            "imported": false,
            "current_name": "configure_step_period_08005324"
        },
        "FUN_08000310": {
            "renaming": {
                "FUN_08000310": "read_eeprom_data_08000310",
                "addr": "address"
            },
            "code": "\nchar read_eeprom_data_08000310(uint address)\n\n{\n  if (*(int *)PTR_eeprom_ready_08000338 == 0) {\n    eeprom_init();\n  }\n  return PTR_eeprom_data_0800033c[address & 0x3ff];\n}\n\n",
            "called": [
                "eeprom_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000310",
            "calling": [
                "memcpy_from_eeprom_with_checksum",
                "read_global_settings"
            ],
            "imported": false,
            "current_name": "read_eeprom_data_08000310"
        },
        "FUN_08005208": {
            "renaming": {
                "FUN_08005208": "do_nothing_08005208"
            },
            "code": "\nvoid do_nothing_08005208(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005208",
            "calling": [
                "spindle_run"
            ],
            "imported": false,
            "current_name": "do_nothing_08005208"
        },
        "FUN_08007a70": {
            "renaming": {
                "FUN_08007a70": "configure_timer_interrupt_08007a70",
                "tim": "timer",
                "pre": "priority",
                "sub": "subpriority",
                "irq": "irqNumber"
            },
            "code": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nvoid ConfigureTimerInterrupt_08007a70(TIM_TypeDef *timer,uint32_t priority,uint32_t subpriority)\n\n{\n  uint32_t irqNumber;\n  \n  if (timer == (TIM_TypeDef *)&DAT_40000000) {\n    irqNumber._0_1_ = TIM2_IRQn;\n  }\n  else if (timer == DAT_08007ac8) {\n    irqNumber._0_1_ = TIM3_IRQn;\n  }\n  else {\n    if (timer != DAT_08007acc) {\n      return;\n    }\n    irqNumber._0_1_ = TIM4_IRQn;\n  }\n  HAL_NVIC_SetPriority((IRQn_Type)irqNumber,priority,subpriority);\n  NVIC_EnableIRQ((IRQn_Type)irqNumber);\n  return;\n}\n\n",
            "called": [
                "NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007a70",
            "calling": [
                "step_timer_init"
            ],
            "imported": false,
            "current_name": "configure_timer_interrupt_08007a70"
        },
        "FUN_0800b5b0": {
            "renaming": {
                "FUN_0800b5b0": "get_pkey_ctx_int_value_0800b5b0",
                "ctx": "pkey_ctx"
            },
            "code": "\nint get_pkey_ctx_int_value_0800b5b0(EVP_PKEY_CTX *pkey_ctx)\n\n{\n  return (int)pkey_ctx;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b5b0",
            "calling": [
                "frame_dummy",
                "__do_global_dtors_aux",
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "get_pkey_ctx_int_value_0800b5b0"
        },
        "FUN_08002978": {
            "renaming": {
                "FUN_08002978": "calculate_time_to_reach_velocity_08002978",
                "in_r0": "temp_result_1",
                "uVar1": "temp_result_2",
                "uVar2": "temp_result_3",
                "in_r1": "target_velocity_squared",
                "extraout_r1": "extra_output",
                "in_r2": "double_distance",
                "fVar3": "final_result",
                "in_stack_ffffffe0": "stack_variable"
            },
            "code": "\nfloat calculate_time_to_reach_velocity_08002978(float acceleration,float target_velocity,float distance)\n\n{\n  undefined4 temp_result_1;\n  undefined4 temp_result_2;\n  undefined4 temp_result_3;\n  undefined4 target_velocity_squared;\n  undefined4 extra_output;\n  undefined4 double_distance;\n  float final_result;\n  undefined4 stack_variable;\n  \n  temp_result_2 = __aeabi_fmul(acceleration,target_velocity_squared,target_velocity_squared);\n  temp_result_3 = __addsf3(temp_result_1,temp_result_1);\n  temp_result_3 = __aeabi_fmul(temp_result_3,double_distance);\n  temp_result_2 = __aeabi_fsub(temp_result_2,temp_result_3);\n  temp_result_2 = __aeabi_f2d(temp_result_2);\n  sqrt((double)CONCAT44(double_distance,stack_variable));\n  final_result = (float)__truncdfsf2(temp_result_2,extra_output);\n  return final_result;\n}\n\n",
            "called": [
                "__aeabi_fsub",
                "__addsf3",
                "__aeabi_fmul",
                "sqrt",
                "__truncdfsf2",
                "__aeabi_f2d"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002978",
            "calling": [
                "planner_forward_pass_kernel",
                "planner_reverse_pass_kernel",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "calculate_time_to_reach_velocity_08002978"
        },
        "FUN_08009d78": {
            "renaming": {
                "FUN_08009d78": "calculate_trigonometric_08009d78",
                "param_1": "input_value1",
                "param_2": "input_value2",
                "param_3": "result_array",
                "uVar1": "temp_var1",
                "uVar2": "temp_var2",
                "uVar3": "temp_var3",
                "uVar4": "temp_var4",
                "uVar5": "temp_var5",
                "uVar6": "temp_var6",
                "uVar7": "temp_var7",
                "uVar8": "masked_input2",
                "iVar9": "kernel_result",
                "uVar10": "intermediate_result1",
                "uVar11": "intermediate_result2",
                "uVar12": "intermediate_result3",
                "in_stack_ffffffa8": "stack_var1",
                "in_stack_ffffffac": "stack_var2",
                "local_50": "local_result1",
                "uStack_4c": "local_result2",
                "local_40": "local_var1",
                "local_38": "local_var2",
                "local_30": "local_var3",
                "extraout_r1": "extra_output1"
            },
            "code": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nint calculate_trigonometric_08009d78(undefined4 input_value1,uint input_value2,undefined8 *result_array)\n\n{\n  undefined4 temp_var1;\n  undefined4 temp_var2;\n  undefined4 temp_var3;\n  undefined4 extra_output1;\n  undefined4 temp_var4;\n  undefined4 temp_var5;\n  undefined4 temp_var6;\n  undefined4 temp_var7;\n  uint masked_input2;\n  int kernel_result;\n  undefined8 intermediate_result1;\n  undefined8 intermediate_result2;\n  undefined8 intermediate_result3;\n  undefined4 stack_var1;\n  undefined4 stack_var2;\n  undefined4 local_result1;\n  undefined4 local_result2;\n  undefined8 local_var1;\n  undefined8 local_var2;\n  undefined8 local_var3;\n  \n  masked_input2 = input_value2 & 0x7fffffff;\n  if ((int)masked_input2 <= DAT_08009fb0) {\n    *(undefined4 *)result_array = input_value1;\n    *(uint *)((int)result_array + 4) = input_value2;\n    *(undefined4 *)(result_array + 1) = 0;\n    *(undefined4 *)((int)result_array + 0xc) = 0;\n    return 0;\n  }\n  if ((int)masked_input2 <= DAT_08009fb4) {\n    if ((int)input_value2 < 1) {\n      intermediate_result1 = __aeabi_dadd(input_value1,input_value2,DAT_08009f88,DAT_08009f8c);\n      temp_var2 = (undefined4)((ulonglong)intermediate_result1 >> 0x20);\n      temp_var1 = (undefined4)intermediate_result1;\n      if (masked_input2 != DAT_0800a1b8) {\n        intermediate_result1 = __aeabi_dadd(temp_var1,temp_var2,DAT_0800a1b0,DAT_0800a1b4);\n        *result_array = intermediate_result1;\n        intermediate_result1 = __subdf3(temp_var1,temp_var2);\n        intermediate_result1 = __aeabi_dadd((int)intermediate_result1,(int)((ulonglong)intermediate_result1 >> 0x20),DAT_0800a1b0,DAT_0800a1b4\n                             );\n        result_array[1] = intermediate_result1;\n        return -1;\n      }\n      intermediate_result1 = __aeabi_dadd(temp_var1,temp_var2,DAT_0800a190,DAT_0800a194);\n      temp_var1 = (undefined4)((ulonglong)intermediate_result1 >> 0x20);\n      intermediate_result2 = __aeabi_dadd((int)intermediate_result1,temp_var1,DAT_0800a198,DAT_0800a19c);\n      *result_array = intermediate_result2;\n      intermediate_result1 = __subdf3((int)intermediate_result1,temp_var1);\n      intermediate_result1 = __aeabi_dadd((int)intermediate_result1,(int)((ulonglong)intermediate_result1 >> 0x20),DAT_0800a198,DAT_0800a19c);\n      result_array[1] = intermediate_result1;\n      return -1;\n    }\n    intermediate_result1 = __subdf3();\n    temp_var2 = (undefined4)((ulonglong)intermediate_result1 >> 0x20);\n    temp_var1 = (undefined4)intermediate_result1;\n    if (masked_input2 != DAT_08009fb8) {\n      intermediate_result1 = __subdf3(temp_var1,temp_var2,DAT_08009f90,DAT_08009f94);\n      *result_array = intermediate_result1;\n      intermediate_result1 = __subdf3(temp_var1,temp_var2);\n      intermediate_result1 = __subdf3((int)intermediate_result1,(int)((ulonglong)intermediate_result1 >> 0x20),DAT_08009f90,DAT_08009f94);\n      result_array[1] = intermediate_result1;\n      return 1;\n    }\n    intermediate_result1 = __subdf3(temp_var1,temp_var2,DAT_08009f98,DAT_08009f9c);\n    temp_var1 = (undefined4)((ulonglong)intermediate_result1 >> 0x20);\n    intermediate_result2 = __subdf3((int)intermediate_result1,temp_var1,DAT_08009fa0,DAT_08009fa4);\n    *result_array = intermediate_result2;\n    intermediate_result1 = __subdf3((int)intermediate_result1,temp_var1);\n    intermediate_result1 = __subdf3((int)intermediate_result1,(int)((ulonglong)intermediate_result1 >> 0x20),DAT_08009fa0,DAT_08009fa4);\n    result_array[1] = intermediate_result1;\n    return 1;\n  }\n  if (DAT_08009fbc < (int)masked_input2) {\n    if (DAT_08009fc0 < (int)masked_input2) {\n      intermediate_result1 = __subdf3(input_value1,input_value2,input_value1,input_value2);\n      result_array[1] = intermediate_result1;\n      *result_array = intermediate_result1;\n      return 0;\n    }\n    kernel_result = ((int)masked_input2 >> 0x14) + -0x416;\n    __aeabi_d2iz();\n    local_var1 = __aeabi_i2d();\n    intermediate_result1 = __subdf3(input_value1,masked_input2 + kernel_result * -0x100000,(int)local_var1,\n                      (int)((ulonglong)local_var1 >> 0x20));\n    intermediate_result1 = __muldf3((int)intermediate_result1,(int)((ulonglong)intermediate_result1 >> 0x20),0,DAT_08009fc4);\n    __aeabi_d2iz();\n    local_var2 = __aeabi_i2d();\n    intermediate_result1 = __subdf3((int)intermediate_result1,(int)((ulonglong)intermediate_result1 >> 0x20));\n    local_var3 = __muldf3((int)intermediate_result1,(int)((ulonglong)intermediate_result1 >> 0x20),0,DAT_08009fc4);\n    __aeabi_dcmpeq((int)local_var3,(int)((ulonglong)local_var3 >> 0x20),0,0);\n    kernel_result = __kernel_rem_pio2(&local_var1,result_array,kernel_result);\n    if (-1 < (int)input_value2) {\n      return kernel_result;\n    }\n    *(int *)((int)result_array + 4) = *(int *)((int)result_array + 4) + -0x80000000;\n    *(int *)((int)result_array + 0xc) = *(int *)((int)result_array + 0xc) + -0x80000000;\n    return -kernel_result;\n  }\n  fabs((double)CONCAT44(stack_var2,stack_var1));\n  intermediate_result1 = __muldf3();\n  __aeabi_dadd((int)intermediate_result1,(int)((ulonglong)intermediate_result1 >> 0x20),0,DAT_08009fcc);\n  kernel_result = __aeabi_d2iz();\n  intermediate_result1 = __aeabi_i2d();\n  temp_var4 = (undefined4)((ulonglong)intermediate_result1 >> 0x20);\n  temp_var1 = (undefined4)intermediate_result1;\n  intermediate_result1 = __muldf3(temp_var1,temp_var4,DAT_08009f88,DAT_08009f8c);\n  intermediate_result1 = __subdf3(input_value1,extra_output1,(int)intermediate_result1,(int)((ulonglong)intermediate_result1 >> 0x20));\n  temp_var5 = (undefined4)((ulonglong)intermediate_result1 >> 0x20);\n  temp_var2 = (undefined4)intermediate_result1;\n  intermediate_result2 = __muldf3(temp_var1,temp_var4,DAT_08009f90,DAT_08009f94);\n  if ((0x1f < kernel_result) || (*(uint *)(PTR_npio2_hw_08009fd0 + (kernel_result + -1) * 4) == masked_input2)) {\n    intermediate_result3 = __subdf3(temp_var2,temp_var5,(int)intermediate_result2,(int)((ulonglong)intermediate_result2 >> 0x20));\n    if ((int)((masked_input2 >> 0x14) - ((uint)((int)((ulonglong)intermediate_result3 >> 0x20) << 1) >> 0x15)) < 0x11)\n    goto LAB_0800a0ce;\n    intermediate_result2 = __muldf3(temp_var1,temp_var4,DAT_0800a190,DAT_0800a194);\n    temp_var6 = (undefined4)((ulonglong)intermediate_result2 >> 0x20);\n    intermediate_result1 = __subdf3(temp_var2,temp_var5,(int)intermediate_result2,temp_var6);\n    temp_var7 = (undefined4)((ulonglong)intermediate_result1 >> 0x20);\n    temp_var3 = (undefined4)intermediate_result1;\n    intermediate_result3 = __subdf3(temp_var2,temp_var5,temp_var3,temp_var7);\n    intermediate_result2 = __subdf3((int)intermediate_result3,(int)((ulonglong)intermediate_result3 >> 0x20),(int)intermediate_result2,temp_var6);\n    intermediate_result3 = __muldf3(temp_var1,temp_var4,DAT_0800a198,DAT_0800a19c);\n    intermediate_result2 = __subdf3((int)intermediate_result3,(int)((ulonglong)intermediate_result3 >> 0x20),(int)intermediate_result2,\n                      (int)((ulonglong)intermediate_result2 >> 0x20));\n    intermediate_result3 = __subdf3(temp_var3,temp_var7,(int)intermediate_result2,(int)((ulonglong)intermediate_result2 >> 0x20));\n    if ((int)(((int)masked_input2 >> 0x14) - ((uint)((int)((ulonglong)intermediate_result3 >> 0x20) << 1) >> 0x15)) < 0x32\n       ) goto LAB_0800a0ce;\n    intermediate_result2 = __muldf3(temp_var1,temp_var4,DAT_0800a1a0,DAT_0800a1a4);\n    temp_var2 = (undefined4)((ulonglong)intermediate_result2 >> 0x20);\n    intermediate_result1 = __subdf3(temp_var3,temp_var7,(int)intermediate_result2,temp_var2);\n    intermediate_result3 = __subdf3(temp_var3,temp_var7);\n    intermediate_result2 = __subdf3((int)intermediate_result3,(int)((ulonglong)intermediate_result3 >> 0x20),(int)intermediate_result2,temp_var2);\n    intermediate_result3 = __muldf3(temp_var1,temp_var4,DAT_0800a1a8,DAT_0800a1ac);\n    intermediate_result2 = __subdf3((int)intermediate_result3,(int)((ulonglong)intermediate_result3 >> 0x20),(int)intermediate_result2,\n                      (int)((ulonglong)intermediate_result2 >> 0x20));\n  }\n  intermediate_result3 = __subdf3((int)intermediate_result1,(int)((ulonglong)intermediate_result1 >> 0x20),(int)intermediate_result2,\n                    (int)((ulonglong)intermediate_result2 >> 0x20));\nLAB_0800a0ce:\n  local_result2 = (undefined4)((ulonglong)intermediate_result1 >> 0x20);\n  local_result1 = (undefined4)intermediate_result1;\n  *result_array = intermediate_result3;\n  intermediate_result1 = __subdf3(local_result1,local_result2);\n  intermediate_result1 = __subdf3((int)intermediate_result1,(int)((ulonglong)intermediate_result1 >> 0x20),(int)intermediate_result2,\n                    (int)((ulonglong)intermediate_result2 >> 0x20));\n  result_array[1] = intermediate_result1;\n  if ((int)input_value2 < 0) {\n    *(int *)result_array = (int)intermediate_result3;\n    *(int *)((int)result_array + 4) = (int)((ulonglong)intermediate_result3 >> 0x20) + -0x80000000;\n    *(int *)(result_array + 1) = (int)intermediate_result1;\n    *(int *)((int)result_array + 0xc) = (int)((ulonglong)intermediate_result1 >> 0x20) + -0x80000000;\n    kernel_result = -kernel_result;\n  }\n  return kernel_result;\n}\n\n",
            "called": [
                "__muldf3",
                "__aeabi_dcmpeq",
                "fabs",
                "__aeabi_d2iz",
                "__aeabi_dadd",
                "__aeabi_i2d",
                "__kernel_rem_pio2",
                "__subdf3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009d78",
            "calling": [
                "cos",
                "sin"
            ],
            "imported": false,
            "current_name": "calculate_trigonometric_08009d78"
        },
        "FUN_08003826": {
            "renaming": {
                "FUN_08003826": "print_formatted_float_08003826",
                "n": "number",
                "in_r0": "input_number",
                "iVar1": "is_negative",
                "uVar2": "rounded_number",
                "bVar3": "next_index",
                "uVar4": "current_index",
                "local_24": "abs_number",
                "uStack_1d": "unused",
                "buf": "buffer",
                "i": "buffer_index",
                "decimals": "decimal_places"
            },
            "code": "\nvobuffer_indexd print_formatted_float_08003826(float number)\n\n{\n  ubuffer_indexnumbert input_number;\n  buffer_indexnumbert is_negative;\n  unumberdefbuffer_indexnumbered4 rounded_number;\n  byte next_index;\n  ubuffer_indexnumbert current_index;\n  ubuffer_indexnumbert abs_number;\n  ubuffer_indexnumbert8_t unused;\n  uchar buffer [10];\n  ubuffer_indexnumbert32_t a;\n  ubuffer_indexnumbert8_t buffer_index;\n  ubuffer_indexnumbert8_t decimal_places;\n  \n  is_negative = __aeabbuffer_index_fcmplt(input_number,0);\n  abs_number = input_number;\n  buffer_indexf (is_negative != 0) {\n    serbuffer_indexal_wrbuffer_indexte('-');\n    abs_number = input_number ^ 0x80000000;\n  }\n  for (decimal_places = PTR_settbuffer_indexnumbergs_08003970[0x3d]; 1 < decimal_places; decimal_places = decimal_places + 0xfe) {\n    abs_number = __aeabbuffer_index_fmul(abs_number,DAT_08003974);\n  }\n  buffer_indexf (decimal_places != '\\0') {\n    abs_number = __aeabbuffer_index_fmul(abs_number,DAT_08003978);\n  }\n  rounded_number = __addsf3(abs_number,0x3f000000);\n  buffer_index = '\\0';\n  a = __aeabbuffer_index_f2buffer_indexz(rounded_number);\n  buffer[(byte)PTR_settbuffer_indexnumbergs_08003970[0x3d]] = '.';\n  for (; a != 0; a = (ubuffer_indexnumbert32_t)((ulonumberglonumberg)DAT_0800397c * (ulonumberglonumberg)a >> 0x23)) {\n    buffer_indexf (buffer_index == PTR_settbuffer_indexnumbergs_08003970[0x3d]) {\n      buffer_index = buffer_index + '\\x01';\n    }\n    current_index = (ubuffer_indexnumbert)buffer_index;\n    buffer_index = buffer_index + '\\x01';\n    buffer[current_index] = (char)a + (char)(ubuffer_indexnumbert)((ulonumberglonumberg)DAT_0800397c * (ulonumberglonumberg)a >> 0x23) * -10 + '0';\n  }\n  whbuffer_indexle (buffer_index < (byte)PTR_settbuffer_indexnumbergs_08003970[0x3d]) {\n    current_index = (ubuffer_indexnumbert)buffer_index;\n    buffer_index = buffer_index + '\\x01';\n    buffer[current_index] = '0';\n  }\n  buffer_indexf (buffer_index == PTR_settbuffer_indexnumbergs_08003970[0x3d]) {\n    next_index = buffer_index + 1;\n    buffer_index = buffer_index + '\\x02';\n    buffer[next_index] = '0';\n  }\n  for (; buffer_index != '\\0'; buffer_index = buffer_index + 0xff) {\n    serbuffer_indexal_wrbuffer_indexte(buffer[buffer_index - 1]);\n  }\n  returnumber;\n}\n\n",
            "called": [
                "__addsf3",
                "__aeabi_f2iz",
                "__aeabi_fcmplt",
                "__aeabi_fmul",
                "serial_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003826",
            "calling": [
                "report_gcode_parameters",
                "report_realtime_status",
                "report_gcode_modes",
                "report_grbl_settings"
            ],
            "imported": false,
            "current_name": "print_formatted_float_08003826"
        },
        "FUN_0800923c": {
            "renaming": {
                "FUN_0800923c": "compare_floats_0800923c",
                "in_ZR": "zero_flag",
                "in_CY": "carry_flag"
            },
            "code": "\nbool compare_floats_0800923c(void)\n\n{\n  undefined zero_flag;\n  undefined carry_flag;\n  \n  __aeabi_cfcmpeq();\n  return !(bool)carry_flag || (bool)zero_flag;\n}\n\n",
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800923c",
            "calling": [
                "mc_arc",
                "gc_execute_line",
                "settings_store_global_setting"
            ],
            "imported": false,
            "current_name": "compare_floats_0800923c"
        },
        "FUN_08002afc": {
            "renaming": {
                "FUN_08002afc": "update_entry_speed_08002afc",
                "previous": "prev_block",
                "current": "curr_block",
                "next": "next_block",
                "iVar1": "compare_result",
                "uVar2": "speed_limit",
                "fVar3": "updated_speed",
                "acceleration": "acceleration_1",
                "acceleration_00": "acceleration_2",
                "target_velocity": "target_velocity_1",
                "target_velocity_00": "target_velocity_2",
                "distance": "distance_1",
                "distance_00": "distance_2"
            },
            "code": "\nvoid update_entry_speed_08002afc(block_t *prev_block,block_t *curr_block,block_t *next_block)\n\n{\n  int compare_result;\n  uint speed_limit;\n  float updated_speed;\n  float acceleration_1;\n  float acceleration_2;\n  float target_velocity_1;\n  float target_velocity_2;\n  float distance_1;\n  float distance_2;\n  float entry_speed;\n  \n  if (((prev_block != (block_t *)0x0) && (prev_block->nominal_length_flag == '\\0')) &&\n     (compare_result = __aeabi_fcmplt(prev_block->entry_speed,curr_block->entry_speed), compare_result != 0)) {\n    updated_speed = curr_block->entry_speed;\n    speed_limit = *(uint *)(PTR_settings_08002ba4 + 0x20) ^ 0x80000000;\n    max_allowable_speed(acceleration_1,target_velocity_1,distance_1);\n    compare_result = __aeabi_fcmplt(updated_speed,speed_limit);\n    if (compare_result == 0) {\n      updated_speed = (float)(*(uint *)(PTR_settings_08002ba4 + 0x20) ^ 0x80000000);\n      max_allowable_speed(acceleration_2,target_velocity_2,distance_2);\n    }\n    else {\n      updated_speed = curr_block->entry_speed;\n    }\n    compare_result = __aeabi_fcmpeq(updated_speed,curr_block->entry_speed);\n    if (compare_result == 0) {\n      curr_block->entry_speed = updated_speed;\n      curr_block->recalculate_flag = '\\x01';\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "max_allowable_speed",
                "__aeabi_fcmpeq",
                "__aeabi_fcmplt"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002afc",
            "calling": [
                "planner_forward_pass"
            ],
            "imported": false,
            "current_name": "update_entry_speed_08002afc"
        },
        "FUN_08004c48": {
            "renaming": {
                "FUN_08004c48": "initialize_settings_08004c48",
                "reset_all": "resetAll"
            },
            "code": "\nvoid initializeSettings_08004c48(_Bool resetAll)\n\n{\n  if (resetAll) {\n    *(undefined4 *)PTR_settings_08004d0c = DAT_08004d10;\n    *(undefined4 *)(PTR_settings_08004d0c + 4) = DAT_08004d10;\n    *(undefined4 *)(PTR_settings_08004d0c + 8) = DAT_08004d10;\n    PTR_settings_08004d0c[0xd] = 10;\n    *(undefined4 *)(PTR_settings_08004d0c + 0x10) = DAT_08004d14;\n    *(undefined4 *)(PTR_settings_08004d0c + 0x14) = DAT_08004d18;\n    *(undefined4 *)(PTR_settings_08004d0c + 0x20) = DAT_08004d1c;\n    *(undefined4 *)(PTR_settings_08004d0c + 0x1c) = DAT_08004d20;\n    *(undefined2 *)(PTR_settings_08004d0c + 0x18) = 0;\n    *(undefined2 *)(PTR_settings_08004d0c + 0x1a) = 0xa80;\n    *(undefined4 *)(PTR_settings_08004d0c + 0x24) = DAT_08004d24;\n  }\n  PTR_settings_08004d0c[0x28] = 0;\n  PTR_settings_08004d0c[0x28] = PTR_settings_08004d0c[0x28] | 2;\n  PTR_settings_08004d0c[0x28] = PTR_settings_08004d0c[0x28] | 0x10;\n  *(undefined2 *)(PTR_settings_08004d0c + 0x2a) = 0;\n  *(undefined4 *)(PTR_settings_08004d0c + 0x2c) = DAT_08004d28;\n  *(undefined4 *)(PTR_settings_08004d0c + 0x30) = DAT_08004d14;\n  *(undefined2 *)(PTR_settings_08004d0c + 0x34) = 100;\n  *(undefined4 *)(PTR_settings_08004d0c + 0x38) = 0x3f800000;\n  PTR_settings_08004d0c[0x3c] = 0x19;\n  PTR_settings_08004d0c[0x3d] = 3;\n  PTR_settings_08004d0c[0x3e] = 0x19;\n  write_global_settings();\n  return;\n}\n\n",
            "called": [
                "write_global_settings"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004c48",
            "calling": [
                "settings_init",
                "read_global_settings"
            ],
            "imported": false,
            "current_name": "initialize_settings_08004c48"
        },
        "FUN_080002a0": {
            "renaming": {
                "FUN_080002a0": "delay_milliseconds_080002a0",
                "_ms": "milliseconds"
            },
            "code": "\nvoid delay_milliseconds_080002a0(uint milliseconds)\n\n{\n  HAL_Delay(milliseconds);\n  return;\n}\n\n",
            "called": [
                "HAL_Delay"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080002a0",
            "calling": [
                "mc_dwell"
            ],
            "imported": false,
            "current_name": "delay_milliseconds_080002a0"
        },
        "FUN_08009250": {
            "renaming": {
                "FUN_08009250": "check_condition_08009250",
                "in_ZR": "zeroFlag",
                "in_CY": "carryFlag"
            },
            "code": "\nbool checkCondition_08009250(void)\n\n{\n  undefined zeroFlag;\n  undefined carryFlag;\n  \n  __aeabi_cfrcmple();\n  return !(bool)carryFlag || (bool)zeroFlag;\n}\n\n",
            "called": [
                "__aeabi_cfrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009250",
            "calling": [
                "mc_arc",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "check_condition_08009250"
        },
        "FUN_0800640c": {
            "renaming": {
                "FUN_0800640c": "configure_mco_0800640c",
                "RCC_MCOx": "MCO_Selection",
                "RCC_MCOSource": "MCO_Source",
                "RCC_MCODiv": "MCO_Divider",
                "GPIO_InitStruct": "GPIO_Config",
                "GPIO_InitTypeDef": "GPIO_Configuration"
            },
            "code": "\nvoid ConfigureMCO_0800640c(uint32_t MCO_Selection,uint32_t MCO_Source,uint32_t MCO_Divider)\n\n{\n  GPIO_Configuration GPIO_Config;\n  \n  if (MCO_Selection == 0) {\n    *(uint *)(DAT_080064b0 + 0x30) = *(uint *)(DAT_080064b0 + 0x30) | 1;\n    GPIO_Config.Pin = 0x100;\n    GPIO_Config.Mode = 2;\n    GPIO_Config.Speed = 3;\n    GPIO_Config.Pull = 0;\n    GPIO_Config.Alternate = 0;\n    HAL_GPIO_Init(DAT_080064b4,&GPIO_Config);\n    *(uint32_t *)(DAT_080064b0 + 8) =\n         MCO_Divider | MCO_Source | *(uint *)(DAT_080064b0 + 8) & 0xf89fffff;\n  }\n  else {\n    *(uint *)(DAT_080064b0 + 0x30) = *(uint *)(DAT_080064b0 + 0x30) | 4;\n    GPIO_Config.Pin = 0x200;\n    GPIO_Config.Mode = 2;\n    GPIO_Config.Speed = 3;\n    GPIO_Config.Pull = 0;\n    GPIO_Config.Alternate = 0;\n    HAL_GPIO_Init(DAT_080064b8,&GPIO_Config);\n    *(uint32_t *)(DAT_080064b0 + 8) =\n         MCO_Source | MCO_Divider << 3 | *(uint *)(DAT_080064b0 + 8) & 0x7ffffff;\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_Init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800640c",
            "calling": [],
            "imported": false,
            "current_name": "configure_mco_0800640c"
        },
        "FUN_0800773e": {
            "renaming": {
                "FUN_0800773e": "do_nothing_0800773e"
            },
            "code": "\nvoid do_nothing_0800773e(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800773e",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0800773e"
        },
        "FUN_08008af0": {
            "renaming": {
                "FUN_08008af0": "compare_double_08008af0",
                "param_1": "double1_high",
                "param_2": "double1_low",
                "param_3": "double2_high",
                "param_4": "double2_low"
            },
            "code": "\nvoid compare_double_08008af0(undefined4 double1_high,undefined4 double1_low,undefined4 double2_high,undefined4 double2_low)\n\n{\n  __aeabi_cdcmpeq(double2_high,double2_low,double1_high,double1_low);\n  return;\n}\n\n",
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008af0",
            "calling": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge"
            ],
            "imported": false,
            "current_name": "compare_double_08008af0"
        },
        "FUN_08006e1a": {
            "renaming": {
                "FUN_08006e1a": "get_irq_status_08006e1a",
                "IRQn": "irqNumber",
                "uVar1": "irqStatus"
            },
            "code": "\nuint32_t getIRQStatus_08006e1a(irqNumber_Type irqNumber)\n\n{\n  uint32_t irqStatus;\n  \n  irqStatus = NVIC_GetActive(irqNumber);\n  return irqStatus;\n}\n\n",
            "called": [
                "NVIC_GetActive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e1a",
            "calling": [],
            "imported": false,
            "current_name": "get_irq_status_08006e1a"
        },
        "FUN_080052ac": {
            "renaming": {
                "FUN_080052ac": "update_register_080052ac",
                "x": "inputValue",
                "val": "updatedValue"
            },
            "code": "\nvoid updateRegister_080052ac(uint32_t inputValue)\n\n{\n  uint32_t updatedValue;\n  \n  *(uint32_t *)(DAT_080052d8 + 0inputValue14) = inputValue | *(uint *)(DAT_080052d8 + 0inputValue14) & 0inputValuefffffaaf;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052ac",
            "calling": [
                "step_pulse_isr",
                "st_init",
                "step_delay_isr"
            ],
            "imported": false,
            "current_name": "update_register_080052ac"
        },
        "FUN_080064bc": {
            "renaming": {
                "FUN_080064bc": "set_flag_080064bc"
            },
            "code": "\nvoid setFlag_080064bc(void)\n\n{\n  *DAT_080064d0 = 1;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064bc",
            "calling": [],
            "imported": false,
            "current_name": "set_flag_080064bc"
        },
        "FUN_08008286": {
            "renaming": {
                "FUN_08008286": "receive_serial_data_08008286",
                "iVar1": "hook_result",
                "data": "received_data"
            },
            "code": "\nuint8_t receive_serial_data_08008286(void)\n\n{\n  uint8_t received_data;\n  int hook_result;\n  uint8_t c;\n  \n  hook_result = usart_tstc();\n  if (hook_result != 0) {\n    received_data = usart_getc();\n    hook_result = serial_rx_hook(received_data);\n    if (hook_result == 0) {\n      return received_data;\n    }\n  }\n  return 0xff;\n}\n\n",
            "called": [
                "usart_getc",
                "usart_tstc",
                "serial_rx_hook"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008286",
            "calling": [
                "protocol_process"
            ],
            "imported": false,
            "current_name": "receive_serial_data_08008286"
        },
        "FUN_0800b5bc": {
            "renaming": {
                "FUN_0800b5bc": "do_nothing_0800b5bc"
            },
            "code": "\nvoid do_nothing_0800b5bc(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b5bc",
            "calling": [
                "__libc_fini_array"
            ],
            "imported": false,
            "current_name": "do_nothing_0800b5bc"
        },
        "FUN_08008b74": {
            "renaming": {
                "FUN_08008b74": "check_conditions_08008b74",
                "param_1": "first_uint",
                "param_2": "first_int",
                "param_3": "second_uint",
                "param_4": "second_int"
            },
            "code": "\nundefined4 check_conditions_08008b74(uint first_uint,int first_int,uint second_uint,int second_int)\n\n{\n  if ((((first_int << 1) >> 0x15 != -1) || ((first_uint | first_int << 0xc) == 0)) &&\n     (((second_int << 1) >> 0x15 != -1 || ((second_uint | second_int << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b74",
            "calling": [
                "sqrt"
            ],
            "imported": false,
            "current_name": "check_conditions_08008b74"
        },
        "FUN_0800b524": {
            "renaming": {
                "FUN_0800b524": "register_atexit_handler_0800b524",
                "param_1": "handler_type",
                "param_2": "handler_function",
                "param_3": "handler_arg",
                "param_4": "handler_dso_handle",
                "puVar1": "recursive_mutex_ptr",
                "uVar2": "return_code",
                "uVar3": "bit_mask",
                "iVar4": "impure_ptr",
                "iVar5": "handler_list",
                "uVar6": "handler_count"
            },
            "code": "\nundefined4 register_atexit_handler_0800b524(int handler_type,undefined4 handler_function,undefined4 handler_arg,undefined4 handler_dso_handle)\n\n{\n  undefined *recursive_mutex_ptr;\n  undefined4 return_code;\n  uint bit_mask;\n  int impure_ptr;\n  int handler_list;\n  uint handler_count;\n  \n  recursive_mutex_ptr = PTR___atexit_recursive_mutex_0800b5ac;\n  __retarget_lock_acquire_recursive(*(undefined4 *)PTR___atexit_recursive_mutex_0800b5ac);\n  impure_ptr = *(int *)PTR__global_impure_ptr_0800b5a8;\n  handler_list = *(int *)(impure_ptr + 0x148);\n  if (handler_list == 0) {\n    handler_list = impure_ptr + 0x14c;\n    *(int *)(impure_ptr + 0x148) = handler_list;\n  }\n  handler_count = *(uint *)(handler_list + 4);\n  if ((int)handler_count < 0x20) {\n    if (handler_type != 0) {\n      impure_ptr = handler_list + handler_count * 4;\n      *(undefined4 *)(impure_ptr + 0x88) = handler_arg;\n      bit_mask = 1 << (handler_count & 0xff);\n      *(uint *)(handler_list + 0x188) = *(uint *)(handler_list + 0x188) | bit_mask;\n      *(undefined4 *)(impure_ptr + 0x108) = handler_dso_handle;\n      if (handler_type == 2) {\n        *(uint *)(handler_list + 0x18c) = bit_mask | *(uint *)(handler_list + 0x18c);\n      }\n    }\n    return_code = *(undefined4 *)recursive_mutex_ptr;\n    *(uint *)(handler_list + 4) = handler_count + 1;\n    *(undefined4 *)(handler_list + (handler_count + 2) * 4) = handler_function;\n    __retarget_lock_release_recursive(return_code);\n    return_code = 0;\n  }\n  else {\n    __retarget_lock_release_recursive(*(undefined4 *)recursive_mutex_ptr);\n    return_code = 0xffffffff;\n  }\n  return return_code;\n}\n\n",
            "called": [
                "__retarget_lock_release_recursive",
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b524",
            "calling": [
                "atexit"
            ],
            "imported": false,
            "current_name": "register_atexit_handler_0800b524"
        },
        "FUN_08005214": {
            "renaming": {
                "FUN_08005214": "do_nothing_08005214"
            },
            "code": "\nvoid do_nothing_08005214(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005214",
            "calling": [
                "spindle_stop"
            ],
            "imported": false,
            "current_name": "do_nothing_08005214"
        },
        "FUN_08009818": {
            "renaming": {
                "FUN_08009818": "calculate_complex_operation_08009818",
                "param_1": "num1_low",
                "param_2": "num1_high",
                "param_3": "num2_low",
                "param_4": "num2_high",
                "param_5": "angle",
                "iVar1": "difference_shifted",
                "unaff_r4": "result_high",
                "uVar2": "operation_code",
                "uVar3": "num2_high_abs",
                "uVar4": "num1_high_abs",
                "uVar5": "temp_result"
            },
            "code": "\nvoid calculate_complex_operation_08009818(uint num1_low,uint num1_high,uint num2_low,uint num2_high,double angle)\n\n{\n  int difference_shifted;\n  undefined4 result_high;\n  uint operation_code;\n  uint num2_high_abs;\n  uint num1_high_abs;\n  undefined8 temp_result;\n  \n  num2_high_abs = num2_high & 0x7fffffff;\n  if ((DAT_08009b18 < (num2_high_abs | (-num2_low | num2_low) >> 0x1f)) ||\n     (num1_high_abs = num1_high & 0x7fffffff, DAT_08009b18 < (num1_high_abs | (-num1_low | num1_low) >> 0x1f))) {\n    __aeabi_dadd(num2_low,num2_high,num1_low,num1_high);\n  }\n  else {\n    if ((num2_high + 0xc0100000 | num2_low) == 0) {\n      atan(angle);\n      return;\n    }\n    operation_code = (int)num2_high >> 0x1e & 2U | num1_high >> 0x1f;\n    if (((((num1_high_abs | num1_low) != 0) && ((num2_high_abs | num2_low) != 0)) && (num2_high_abs != DAT_08009b18)) &&\n       (num1_high_abs != DAT_08009b18)) {\n      difference_shifted = (int)(num1_high_abs - num2_high_abs) >> 0x14;\n      if (((int)(num1_high_abs - num2_high_abs) < 0x3d00000) &&\n         ((-1 < (int)num2_high || (difference_shifted + 0x3c < 0 == SCARRY4(difference_shifted,0x3c))))) {\n        __divdf3(num1_low,num1_high,num2_low,num2_high);\n        fabs((double)CONCAT44(result_high,num2_high));\n        atan((double)CONCAT44(result_high,num2_high));\n      }\n      if (operation_code != 1) {\n        if (operation_code == 2) {\n          temp_result = __subdf3();\n          __subdf3(DAT_08009af0,DAT_08009af4,(int)temp_result,(int)((ulonglong)temp_result >> 0x20));\n        }\n        else if (operation_code != 0) {\n          temp_result = __subdf3();\n          __subdf3((int)temp_result,(int)((ulonglong)temp_result >> 0x20),DAT_08009af0,DAT_08009af4);\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "__ieee754_atan2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009818",
            "calling": [
                "mc_arc"
            ],
            "imported": false,
            "current_name": "calculate_complex_operation_08009818"
        },
        "FUN_08007ea4": {
            "renaming": {
                "FUN_08007ea4": "enable_usart_08007ea4",
                "usart": "usartInstance"
            },
            "code": "\nvoid enableUSART_08007ea4(USART_TypeDef *usartInstance)\n\n{\n  if (usartInstance == DAT_08007f38) {\n    *(uint *)(DAT_08007f3c + 0x44) = *(uint *)(DAT_08007f3c + 0x44) | 0x10;\n  }\n  else if (usartInstance == DAT_08007f40) {\n    *(uint *)(DAT_08007f3c + 0x40) = *(uint *)(DAT_08007f3c + 0x40) | 0x20000;\n  }\n  else if (usartInstance == DAT_08007f44) {\n    *(uint *)(DAT_08007f3c + 0x40) = *(uint *)(DAT_08007f3c + 0x40) | 0x40000;\n  }\n  else if (usartInstance == DAT_08007f48) {\n    *(uint *)(DAT_08007f3c + 0x40) = *(uint *)(DAT_08007f3c + 0x40) | 0x80000;\n  }\n  else if (usartInstance == DAT_08007f4c) {\n    *(uint *)(DAT_08007f3c + 0x40) = *(uint *)(DAT_08007f3c + 0x40) | 0x100000;\n  }\n  else if (usartInstance == DAT_08007f50) {\n    *(uint *)(DAT_08007f3c + 0x44) = *(uint *)(DAT_08007f3c + 0x44) | 0x20;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007ea4",
            "calling": [
                "usart_init"
            ],
            "imported": false,
            "current_name": "enable_usart_08007ea4"
        },
        "FUN_08007756": {
            "renaming": {
                "FUN_08007756": "process_tick_events_08007756",
                "uVar1": "currentTick",
                "ticks": "unusedTicks"
            },
            "code": "\nvoid processTickEvents_08007756(void)\n\n{\n  uint32_t currentTick;\n  uint32_t unusedTicks;\n  \n  currentTick = HAL_GetTick();\n  if ((currentTick & 0x1ff) == 0) {\n    gpio_toggle(0x3c);\n  }\n  if ((currentTick & 0xf) == 0) {\n    debounce_isr();\n  }\n  HAL_IncTick();\n  return;\n}\n\n",
            "called": [
                "gpio_toggle",
                "debounce_isr",
                "HAL_GetTick",
                "HAL_IncTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007756",
            "calling": [],
            "imported": false,
            "current_name": "process_tick_events_08007756"
        },
        "FUN_0800b520": {
            "renaming": {
                "FUN_0800b520": "do_nothing_0800b520"
            },
            "code": "\nvoid do_nothing_0800b520(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800b520",
            "calling": [
                "__register_exitproc"
            ],
            "imported": false,
            "current_name": "do_nothing_0800b520"
        },
        "FUN_0800774a": {
            "renaming": {
                "FUN_0800774a": "do_nothing_0800774a"
            },
            "code": "\nvoid do_nothing_0800774a(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800774a",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0800774a"
        },
        "FUN_0800423c": {
            "renaming": {
                "FUN_0800423c": "print_grbl_settings_0800423c"
            },
            "code": "\nvoid printGrblSettings_0800423c(void)\n\n{\n  printPgmString(PTR_s_____view_Grbl_settings______view_0800424c);\n  return;\n}\n\n",
            "called": [
                "printPgmString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800423c",
            "calling": [
                "protocol_execute_line"
            ],
            "imported": false,
            "current_name": "print_grbl_settings_0800423c"
        },
        "FUN_080064d4": {
            "renaming": {
                "FUN_080064d4": "reset_global_variable_080064d4"
            },
            "code": "\nvoid resetGlobalVariable_080064d4(void)\n\n{\n  *DAT_080064e8 = 0;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064d4",
            "calling": [],
            "imported": false,
            "current_name": "reset_global_variable_080064d4"
        },
        "FUN_08006e38": {
            "renaming": {
                "FUN_08006e38": "configure_clock_source_08006e38",
                "CLKSource": "clockSource"
            },
            "code": "\nvoid configureClockSource_08006e38(uint32_t clockSource)\n\n{\n  if (clockSource == 4) {\n    *DAT_08006e6c = *DAT_08006e6c | 4;\n  }\n  else {\n    *DAT_08006e6c = *DAT_08006e6c & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006e38",
            "calling": [],
            "imported": false,
            "current_name": "configure_clock_source_08006e38"
        },
        "FUN_08009264": {
            "renaming": {
                "FUN_08009264": "compare_floating_points_08009264",
                "in_CY": "carryFlag"
            },
            "code": "\nbool compareFloatingPoints_08009264(void)\n\n{\n  char carryFlag;\n  \n  __aeabi_cfrcmple();\n  return carryFlag == '\\0';\n}\n\n",
            "called": [
                "__aeabi_cfrcmple"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009264",
            "calling": [
                "planner_reverse_pass_kernel",
                "plan_buffer_line"
            ],
            "imported": false,
            "current_name": "compare_floating_points_08009264"
        },
        "FUN_08007e08": {
            "renaming": {
                "FUN_08007e08": "initialize_and_start_timers_08007e08"
            },
            "code": "\nvoid initializeAndStartTimers_08007e08(void)\n\n{\n  step_timer_init();\n  g540_timer_init();\n  g540_timer_start();\n  return;\n}\n\n",
            "called": [
                "step_timer_init",
                "g540_timer_start",
                "g540_timer_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e08",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_and_start_timers_08007e08"
        },
        "FUN_08002fac": {
            "renaming": {
                "FUN_08002fac": "is_buffer_full_08002fac"
            },
            "code": "\nuint8_t is_buffer_full_08002fac(void)\n\n{\n  return *PTR_block_buffer_tail_08002fcc == *PTR_next_buffer_head_08002fd0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fac",
            "calling": [
                "mc_line"
            ],
            "imported": false,
            "current_name": "is_buffer_full_08002fac"
        },
        "FUN_08005b04": {
            "renaming": {
                "FUN_08005b04": "set_flag_08005b04"
            },
            "code": "\nvoid setFlag_08005b04(void)\n\n{\n  *(uint *)(DAT_08005b1c + 4) = *(uint *)(DAT_08005b1c + 4) | 1;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005b04",
            "calling": [],
            "imported": false,
            "current_name": "set_flag_08005b04"
        },
        "FUN_080002b6": {
            "renaming": {
                "FUN_080002b6": "delay_microseconds_080002b6",
                "_us": "delay_us",
                "uVar1": "current_time_high",
                "bVar2": "timeout_reached",
                "uVar3": "start_time",
                "uVar4": "current_time",
                "timeout._0_4_": "timeout_low",
                "timeout._4_4_": "timeout_high"
            },
            "code": "\n/* WARNING: Could not reconcile some variable overlaps */\n\nvoid delay_microseconds_080002b6(uint delay_us)\n\n{\n  uint current_time_high;\n  bool timeout_reached;\n  uint64_t start_time;\n  uint64_t current_time;\n  uint64_t timeout;\n  \n  start_time = get_currentdelay_usecs();\n  do {\n    current_time = get_currentdelay_usecs();\n    current_time_high = (uint)(current_time >> 0x20);\n    timeout_low = (uint)(start_time + delay_us);\n    timeout_high = (uint)(start_time + delay_us >> 0x20);\n    timeout_reached = timeout_high <= current_time_high;\n    if (current_time_high == timeout_high) {\n      timeout_reached = (uint)timeout <= (uint)current_time;\n    }\n  } while (!timeout_reached);\n  return;\n}\n\n",
            "called": [
                "get_current_usecs"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080002b6",
            "calling": [],
            "imported": false,
            "current_name": "delay_microseconds_080002b6"
        },
        "FUN_080075c8": {
            "renaming": {
                "FUN_080075c8": "update_system_core_clock_080075c8",
                "uVar1": "clockSelection",
                "pllm": "unused_pllm",
                "pllsource": "unused_pllsource",
                "pllp": "unused_pllp",
                "tmp": "unused_tmp",
                "pllvco": "pllVCO"
            },
            "code": "\nvoid updateSystemCoreClock_080075c8(void)\n\n{\n  uint clockSelection;\n  uint32_t unused_pllm;\n  uint32_t unused_pllsource;\n  uint32_t unused_pllp;\n  uint32_t unused_tmp;\n  uint32_t pllVCO;\n  \n  clockSelection = *(uint *)(DAT_080076b4 + 8) & 0xc;\n  if (clockSelection == 8) {\n    clockSelection = *(uint *)(DAT_080076b4 + 4) & 0x3f;\n    if ((*(uint *)(DAT_080076b4 + 4) >> 0x16 & 1) == 0) {\n      pllVCO = (*(uint *)(DAT_080076b4 + 4) >> 6 & 0x1ff) * (DAT_080076bc / clockSelection);\n    }\n    else {\n      pllVCO = (*(uint *)(DAT_080076b4 + 4) >> 6 & 0x1ff) * (DAT_080076c0 / clockSelection);\n    }\n    *(uint *)PTR_SystemCoreClock_080076b8 =\n         pllVCO / (((*(uint *)(DAT_080076b4 + 4) >> 0x10 & 3) + 1) * 2);\n    goto LAB_0800768a;\n  }\n  if (clockSelection < 9) {\n    if (clockSelection == 0) {\n      *(uint *)PTR_SystemCoreClock_080076b8 = DAT_080076bc;\n      goto LAB_0800768a;\n    }\n    if (clockSelection == 4) {\n      *(uint *)PTR_SystemCoreClock_080076b8 = DAT_080076c0;\n      goto LAB_0800768a;\n    }\n  }\n  *(uint *)PTR_SystemCoreClock_080076b8 = DAT_080076bc;\nLAB_0800768a:\n  *(uint *)PTR_SystemCoreClock_080076b8 =\n       *(uint *)PTR_SystemCoreClock_080076b8 >>\n       PTR_AHBPrescTable_080076c4[*(uint *)(DAT_080076b4 + 8) >> 4 & 0xf];\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080075c8",
            "calling": [],
            "imported": false,
            "current_name": "update_system_core_clock_080075c8"
        }
    },
    "used_tokens": 198249,
    "layers": [
        [
            "FUN_0800192c",
            "FUN_08006950",
            "FUN_08008ba0",
            "FUN_08005b90",
            "FUN_080071d0",
            "FUN_08008e60",
            "FUN_08005984",
            "FUN_080082c8",
            "FUN_08006718",
            "FUN_08007a10",
            "FUN_0800856c",
            "FUN_08008b00",
            "FUN_0800585c",
            "FUN_08008cd0",
            "FUN_0800597c",
            "FUN_08009314",
            "FUN_08009798",
            "FUN_08008cd8",
            "FUN_08007930",
            "FUN_08000188",
            "FUN_080082d0",
            "FUN_08008e70",
            "FUN_08009318",
            "FUN_080018cc",
            "FUN_080079e0",
            "FUN_08006a58",
            "FUN_08005a84",
            "FUN_08008b10",
            "FUN_08004e30",
            "FUN_0800736c",
            "FUN_08008c30",
            "FUN_080082d4",
            "FUN_08007bf0",
            "FUN_08008590",
            "FUN_08007ad0",
            "FUN_080005b4",
            "FUN_080039a0",
            "FUN_08009204",
            "FUN_080029d8",
            "FUN_08007c5e",
            "FUN_08005760",
            "FUN_08008b24",
            "FUN_0800587c",
            "FUN_08008a02",
            "FUN_0800369c",
            "FUN_08005a98",
            "FUN_08008cdc",
            "FUN_080044e8",
            "FUN_08006c9c",
            "FUN_0800a5a0",
            "FUN_0800195c",
            "FUN_08009214",
            "FUN_08004dd2",
            "FUN_08005778",
            "FUN_080028bc",
            "FUN_08006628",
            "FUN_08008b38",
            "FUN_0800738e",
            "FUN_080053a0",
            "FUN_080092c4",
            "FUN_08008250",
            "FUN_0800184c",
            "FUN_08001f00",
            "FUN_08005ad4",
            "FUN_08005b3c",
            "FUN_08006ce0",
            "FUN_08006d4a",
            "FUN_08000374",
            "FUN_080037fc",
            "FUN_08007dd8",
            "FUN_0800a1bc",
            "FUN_0800525c",
            "FUN_080073d4",
            "FUN_080085e4",
            "FUN_08006dfe",
            "FUN_08006d66",
            "FUN_08006e88",
            "FUN_0800b4f0",
            "FUN_080036f0",
            "FUN_08005c74",
            "FUN_0800375c",
            "FUN_08009990",
            "FUN_08005b58",
            "FUN_08007e58",
            "FUN_080059f8",
            "FUN_08009194",
            "FUN_08003f34",
            "FUN_080095b8",
            "FUN_08006cf6",
            "FUN_08002ef0",
            "FUN_08001d4c",
            "FUN_08000268",
            "FUN_0800918c",
            "FUN_08003778",
            "FUN_0800b3dc",
            "FUN_080046d0",
            "FUN_08006d72",
            "FUN_0800756c",
            "FUN_0800691c",
            "FUN_080001f8",
            "FUN_08002f74",
            "FUN_0800b3e8",
            "FUN_08006a18",
            "FUN_08002c18",
            "FUN_08006ac0",
            "FUN_0800919c",
            "FUN_0800b2cc",
            "FUN_0800854c",
            "FUN_08008e44",
            "FUN_0800733e",
            "FUN_08005aec",
            "FUN_08005b74",
            "FUN_0800583c",
            "FUN_08001e98",
            "FUN_080069e4",
            "FUN_0800b2d4",
            "FUN_08008e3c",
            "FUN_08009654",
            "FUN_08007bc2",
            "FUN_080035ec",
            "FUN_08006c70",
            "FUN_080068bc",
            "FUN_08006d98",
            "FUN_08005a68",
            "FUN_080079c0",
            "FUN_0800b2e0",
            "FUN_08002908",
            "FUN_08007c40",
            "FUN_080094c0",
            "FUN_08008eec",
            "FUN_08006b54",
            "FUN_08007e84",
            "FUN_080057e4",
            "FUN_08006d8a",
            "FUN_0800b2e8",
            "FUN_08007520",
            "FUN_08007884",
            "FUN_08004250",
            "FUN_08006dc4",
            "FUN_08007402",
            "FUN_08002870",
            "FUN_08000210",
            "FUN_08008a64",
            "FUN_08005900",
            "FUN_08002638",
            "FUN_08005bac",
            "FUN_080051b4",
            "FUN_08005c30",
            "FUN_0800056c",
            "FUN_08002f24",
            "FUN_080059b4",
            "FUN_08006c04",
            "FUN_08002e08",
            "FUN_08005bc4",
            "FUN_08006680",
            "FUN_08000340",
            "FUN_08004bf4",
            "FUN_08004d7c",
            "FUN_08009278",
            "FUN_080004fc",
            "FUN_08000220",
            "FUN_08005238",
            "FUN_08007da8",
            "FUN_08004148",
            "FUN_08004940",
            "FUN_08008a74",
            "FUN_08002fd4",
            "FUN_08002408",
            "FUN_08003618",
            "FUN_0800af78",
            "FUN_08005b20",
            "FUN_08007d08",
            "FUN_080091fc",
            "FUN_080058a0",
            "FUN_08008a6c",
            "FUN_080036c6",
            "FUN_08008190",
            "FUN_080074c8",
            "FUN_0800b430",
            "FUN_08004030",
            "FUN_08005360",
            "FUN_08003980",
            "FUN_08006de0",
            "FUN_080052dc",
            "FUN_080064ec",
            "FUN_08006ba0",
            "FUN_080003ec",
            "FUN_08002896",
            "FUN_0800a348",
            "FUN_080001ac",
            "FUN_08003740",
            "FUN_08000478",
            "FUN_08006d2e",
            "FUN_08007e1c",
            "FUN_0800adf0",
            "FUN_08003a74",
            "FUN_08005cec",
            "FUN_08006b00",
            "FUN_0800b4d0",
            "FUN_08007f54",
            "FUN_08003b98",
            "FUN_080024c4",
            "FUN_08002f40",
            "FUN_08009054",
            "FUN_080025e8",
            "FUN_08005ac4",
            "FUN_08005250",
            "FUN_08007430",
            "FUN_08007310",
            "FUN_08007436",
            "FUN_08005814",
            "FUN_08005bdc",
            "FUN_080085d4",
            "FUN_08006e70",
            "FUN_080002f0",
            "FUN_0800778c",
            "FUN_08001ddc",
            "FUN_080069b4",
            "FUN_0800b4e4",
            "FUN_08007720",
            "FUN_08009228",
            "FUN_08007c7c",
            "FUN_08007726",
            "FUN_08007b70",
            "FUN_08004d2c",
            "FUN_08003004",
            "FUN_080066cc",
            "FUN_080018fc",
            "FUN_080039bc",
            "FUN_0800618c",
            "FUN_08006998",
            "FUN_080004ac",
            "FUN_080078f4",
            "FUN_080041a0",
            "FUN_08008bf0",
            "FUN_0800771a",
            "FUN_08003a18",
            "FUN_08005790",
            "FUN_08001994",
            "FUN_08007854",
            "FUN_08004900",
            "FUN_08004228",
            "FUN_08009b24",
            "FUN_080076c8",
            "FUN_08006a8c",
            "FUN_0800772c",
            "FUN_0800283a",
            "FUN_0800881c",
            "FUN_08004bc0",
            "FUN_08008b4c",
            "FUN_08004c2a",
            "FUN_0800826a",
            "FUN_08008b60",
            "FUN_08005324",
            "FUN_08000310",
            "FUN_08007a70",
            "FUN_0800b5b0",
            "FUN_08002978",
            "FUN_08009d78",
            "FUN_08003826",
            "FUN_0800923c",
            "FUN_08002afc",
            "FUN_08004c48",
            "FUN_080002a0",
            "FUN_08009250",
            "FUN_0800640c",
            "FUN_08008af0",
            "FUN_08006e1a",
            "FUN_080052ac",
            "FUN_080064bc",
            "FUN_08008286",
            "FUN_08008b74",
            "FUN_0800b524",
            "FUN_08009818",
            "FUN_08007ea4",
            "FUN_08007756",
            "FUN_0800423c",
            "FUN_080064d4",
            "FUN_08006e38",
            "FUN_08009264",
            "FUN_08007e08",
            "FUN_08002fac",
            "FUN_08005b04",
            "FUN_080002b6",
            "FUN_080075c8"
        ],
        [
            "FUN_08008894",
            "FUN_08008640"
        ],
        [
            "FUN_08002edc",
            "FUN_080096e8",
            "FUN_08002ba8",
            "FUN_08009410",
            "FUN_080098d0",
            "FUN_0800981c",
            "FUN_08002a94",
            "FUN_08007540"
        ]
    ],
    "locked_functions": []
}