{
    "functions": {
        "FUN_00113dfe": {
            "renaming": {
                "FUN_00113dfe": "update_data_00113dfe",
                "param_1": "dataLength",
                "param_2": "newData",
                "lVar1": "dataPointer"
            },
            "code": "\nvoid updateData_00113dfe(undefined4 dataLength,undefined newData)\n\n{\n  long dataPointer;\n  \n  dataPointer = initialize_data_00112904(3,dataLength);\n  if (dataPointer != 0) {\n    *(undefined *)(dataPointer + 0x10) = newData;\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113dfe",
            "calling": [
                "FUN_0010c2d2",
                "FUN_0010c95e",
                "FUN_0010ee3f",
                "FUN_0010b0fa",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "update_data_00113dfe"
        },
        "bfd_get_mach": {
            "renaming": {},
            "code": "\nvoid bfd_get_mach(void)\n\n{\n  bfd_get_mach();\n  return;\n}\n\n",
            "called": [
                "bfd_get_mach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104650",
            "calling": [
                "FUN_00107976",
                "FUN_00105828"
            ],
            "imported": false,
            "current_name": "bfd_get_mach"
        },
        "bfd_close_all_done": {
            "renaming": {},
            "code": "\nvoid bfd_close_all_done(void)\n\n{\n  bfd_close_all_done();\n  return;\n}\n\n",
            "called": [
                "bfd_close_all_done"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104900",
            "calling": [
                "FUN_00104ea2",
                "FUN_00114690",
                "FUN_00119f70"
            ],
            "imported": false,
            "current_name": "bfd_close_all_done"
        },
        "bfd_get_section_contents": {
            "renaming": {},
            "code": "\nvoid bfd_get_section_contents(void)\n\n{\n  bfd_get_section_contents();\n  return;\n}\n\n",
            "called": [
                "bfd_get_section_contents"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104260",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_get_section_contents"
        },
        "FUN_0010ab4d": {
            "renaming": {
                "FUN_0010ab4d": "append_string_to_variable_0010ab4d",
                "param_1": "baseAddress",
                "param_2": "stringToAdd",
                "param_3": "unknownValue1",
                "param_4": "unknownValue2",
                "uVar1": "basePointer",
                "lVar2": "tempValue",
                "auVar3": "returnValue",
                "sVar4": "stringLength1",
                "pcVar5": "dynamicString",
                "sVar6": "stringLength2",
                "auVar7": "modifiedReturnValue"
            },
            "code": "\nundefined  [16] appendStringToVariable_0010ab4d(long baseAddress,char *stringToAdd,undefined8 unknownValue1,undefined8 unknownValue2)\n\n{\n  ulong basePointer;\n  long tempValue;\n  undefined returnValue [16];\n  size_t stringLength1;\n  char *dynamicString;\n  size_t stringLength2;\n  undefined modifiedReturnValue [16];\n  \n  basePointer = *(ulong *)(baseAddress + 0x60);\n  if ((basePointer != 0) && (*(long *)(basePointer + 0x20) != 0)) {\n    dynamicString = *(char **)(basePointer + 0x30);\n    stringLength1 = strlen(stringToAdd);\n    if (dynamicString == (char *)0x0) {\n      dynamicString = (char *)xmalloc(stringLength1 + 3);\n      *dynamicString = '\\0';\n    }\n    else {\n      stringLength2 = strlen(dynamicString);\n      dynamicString = (char *)xrealloc(dynamicString,stringLength1 + 4 + stringLength2);\n    }\n    stringLength1 = strlen(dynamicString);\n    sprintf(dynamicString + stringLength1,\"%s::\",stringToAdd);\n    tempValue = *(long *)(baseAddress + 0x60);\n    *(char **)(tempValue + 0x30) = dynamicString;\n    modifiedReturnValue._1_7_ = (undefined7)((ulong)tempValue >> 8);\n    modifiedReturnValue[0] = 1;\n    modifiedReturnValue._8_8_ = unknownValue2;\n    return modifiedReturnValue;\n  }\n  returnValue._8_8_ = 0;\n  returnValue._0_8_ = basePointer;\n  return returnValue << 0x40;\n}\n\n",
            "called": [
                "xrealloc",
                "strlen",
                "xmalloc",
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010ab4d",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "append_string_to_variable_0010ab4d"
        },
        "FUN_0010c218": {
            "renaming": {
                "FUN_0010c218": "initialize_data_structure_0010c218",
                "param_1": "file_ptr",
                "param_2": "data_size",
                "param_3": "current_file",
                "uVar1": "error_message",
                "lVar2": "data_ptr",
                "pauVar3": "data_structure",
                "lVar4": "result"
            },
            "code": "\n\n\nlong initialize_data_structure_0010c218(long file_ptr,long data_size,long current_file)\n\n{\n  undefined8 error_message;\n  long data_ptr;\n  undefined (*data_structure) [16];\n  long result;\n  \n  if ((data_size != 0) && (current_file != 0)) {\n    if ((*(long *)(file_ptr + 8) == 0) || (*(long *)(file_ptr + 0x10) == 0)) {\n      error_message = dcgettext(0,\"debug_name_type: no current file\",5);\n      fprintf(_stderr,\"%s\\n\",error_message);\n    }\n    else {\n      data_ptr = initialize_data_00112904(0x16,0);\n      if (data_ptr != 0) {\n        data_structure = (undefined (*) [16])xmalloc(0x10);\n        result = *(long *)(file_ptr + 0x10);\n        *data_structure = ZEXT816(0);\n        *(long *)(*data_structure + 8) = current_file;\n        *(undefined (**) [16])(data_ptr + 0x10) = data_structure;\n        result = initialize_data_structure_0010c218_00112925(result + 0x10,data_size,0,3);\n        if (result != 0) {\n          *(long *)(result + 0x20) = data_ptr;\n          *(long *)*data_structure = result;\n          return data_ptr;\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00112925",
                "fprintf",
                "dcgettext",
                "xmalloc",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c218",
            "calling": [
                "FUN_00112a33",
                "FUN_0011173a",
                "FUN_0010c2d2",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "initialize_data_structure_0010c218"
        },
        "strncmp": {
            "renaming": {},
            "code": "\n\n\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = strncmp(__s1,__s2,__n);\n  return iVar1;\n}\n\n",
            "called": [
                "strncmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001040e0",
            "calling": [
                "FUN_00113fb0",
                "FUN_0010ee3f",
                "FUN_0010b0fa"
            ],
            "imported": false,
            "current_name": "strncmp"
        },
        "FUN_00116b90": {
            "renaming": {
                "FUN_00116b90": "FUNC_00116b90"
            },
            "code": "\n\n\nuint FUNC_00116b90(uint param_1,char **param_2)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  bool bVar4;\n  bool bVar5;\n  undefined *puVar6;\n  byte bVar7;\n  char cVar8;\n  int iVar9;\n  uint uVar10;\n  int iVar11;\n  undefined4 uVar12;\n  int iVar13;\n  FILE *pFVar14;\n  size_t sVar15;\n  byte *__s;\n  size_t sVar16;\n  byte *__ptr;\n  long lVar17;\n  char **ppcVar18;\n  long *__src;\n  char **ppcVar19;\n  undefined8 *puVar20;\n  char *__template;\n  FILE *pFVar21;\n  undefined8 uVar22;\n  FILE **ppFVar23;\n  undefined8 uVar24;\n  int *piVar25;\n  char *pcVar26;\n  ulong uVar27;\n  byte *pbVar28;\n  undefined **ppuVar29;\n  long lVar30;\n  byte *pbVar31;\n  char *pcVar32;\n  FILE *pFVar33;\n  char *pcVar34;\n  FILE *unaff_R12;\n  int iVar35;\n  uint uVar36;\n  char *unaff_R13;\n  byte bVar37;\n  FILE *pFVar38;\n  bool bVar39;\n  FILE *local_130;\n  FILE *local_120;\n  size_t local_118;\n  ulong local_110;\n  long *local_108;\n  FILE *local_d8;\n  FILE *local_d0;\n  undefined local_c8 [152];\n  \n  setlocale(5,\"\");\n  setlocale(0,\"\");\n  bindtextdomain(\"binutils\",\"/usr/share/locale\");\n  textdomain(\"binutils\");\n  DAT_001275e0 = *param_2;\n  xmalloc_set_program_name();\n  ppcVar18 = param_2;\n  if (1 < (int)param_1) {\n    local_120 = (FILE *)0x7d0;\n    unaff_R13 = (char *)(ulong)param_1;\n    unaff_R12 = (FILE *)0x1;\n    iVar11 = 0;\n    do {\n      iVar13 = (int)unaff_R12;\n      lVar30 = (long)iVar13;\n      iVar35 = (int)unaff_R13;\n      if (*ppcVar18[lVar30] == '@') {\n        uVar10 = (int)local_120 - 1;\n        local_120 = (FILE *)(ulong)uVar10;\n        if (uVar10 == 0) {\n          pcVar32 = *ppcVar18;\n          pcVar26 = \"%s: error: too many @-files encountered\\n\";\nLAB_00118365:\n          fprintf(_stderr,pcVar26,pcVar32);\n                    \n          xexit(1);\n        }\n        pcVar32 = ppcVar18[lVar30] + 1;\n        iVar9 = stat(pcVar32,(stat *)local_c8);\n        if (iVar9 < 0) goto LAB_00116fd0;\n        if ((local_c8._24_4_ & 0xf000) == 0x4000) {\n          pcVar32 = *ppcVar18;\n          pcVar26 = \"%s: error: @-file refers to a directory\\n\";\n          goto LAB_00118365;\n        }\n        pFVar14 = fopen(pcVar32,\"r\");\n        if (pFVar14 == (FILE *)0x0) goto LAB_00116fd0;\n        iVar9 = fseek(pFVar14,0,2);\n        if (((iVar9 == -1) || (sVar15 = ftell(pFVar14), sVar15 == 0xffffffffffffffff)) ||\n           (iVar9 = fseek(pFVar14,0,0), iVar9 == -1)) {\nLAB_00117070:\n          fclose(pFVar14);\n          if (iVar13 + 1 < iVar35) goto LAB_00116fde;\n          goto LAB_00117086;\n        }\n        __s = (byte *)xmalloc(sVar15 + 1);\n        sVar16 = fread(__s,1,sVar15,pFVar14);\n        if ((sVar15 != sVar16) && (iVar9 = ferror(pFVar14), iVar9 != 0)) {\n          free(__s);\n          goto LAB_00117070;\n        }\n        __s[sVar16] = 0;\n        bVar7 = *__s;\n        pbVar28 = __s;\n        if (bVar7 != 0) {\nLAB_00116d58:\n          if (((&_sch_istable)[(ulong)bVar7 * 2] & 0x40) != 0) goto LAB_00116d48;\n          sVar15 = strlen((char *)__s);\n          __ptr = (byte *)xmalloc(sVar15 + 1);\n          __src = (long *)0x0;\n          iVar9 = 0;\n          bVar39 = false;\n          bVar5 = false;\n          bVar4 = false;\n          local_110 = 0;\n          pbVar28 = __s;\n          do {\n            while (((&_sch_istable)[(ulong)*pbVar28 * 2] & 0x40) != 0) {\n              pbVar28 = pbVar28 + 1;\n            }\n            if ((iVar9 == 0) || (iVar9 + -1 <= (int)local_110)) {\n              if (__src == (long *)0x0) {\n                iVar9 = 8;\n                __src = (long *)xmalloc(0x40);\n                local_108 = __src + local_110;\n                *local_108 = 0;\n              }\n              else {\n                iVar9 = iVar9 * 2;\n                __src = (long *)xrealloc(__src,(long)iVar9 << 3);\n                local_108 = __src + local_110;\n                *local_108 = 0;\n              }\n            }\n            else {\n              local_108 = __src + local_110;\n            }\n            bVar7 = *pbVar28;\n            pbVar31 = __ptr;\n            while (bVar7 != 0) {\n              while( true ) {\n                if ((((&_sch_istable)[(ulong)bVar7 * 2] & 0x40) != 0) &&\n                   (!(bool)(bVar5 | bVar4 | bVar39))) {\n                  bVar4 = false;\n                  bVar39 = false;\n                  bVar5 = false;\n                  goto LAB_00116e3f;\n                }\n                if (!bVar4) break;\n                pbVar28 = pbVar28 + 1;\n                *pbVar31 = bVar7;\n                pbVar31 = pbVar31 + 1;\n                bVar4 = false;\n                bVar7 = *pbVar28;\n                if (bVar7 == 0) goto LAB_00116e3f;\n              }\n              if (bVar7 == 0x5c) {\n                bVar4 = true;\n              }\n              else if (bVar5) {\n                if (bVar7 == 0x27) {\n                  bVar5 = false;\n                }\n                else {\nLAB_00116fb1:\n                  *pbVar31 = bVar7;\n                  pbVar31 = pbVar31 + 1;\n                }\n              }\n              else if (bVar39) {\n                if (bVar7 != 0x22) goto LAB_00116fb1;\n                bVar39 = false;\n              }\n              else if (bVar7 == 0x27) {\n                bVar5 = true;\n              }\n              else {\n                if (bVar7 != 0x22) goto LAB_00116fb1;\n                bVar39 = true;\n              }\n              pbVar1 = pbVar28 + 1;\n              pbVar28 = pbVar28 + 1;\n              bVar7 = *pbVar1;\n            }\nLAB_00116e3f:\n            *pbVar31 = 0;\n            lVar17 = xstrdup(__ptr);\n            *local_108 = lVar17;\n            __src[local_110 + 1] = 0;\n            bVar7 = *pbVar28;\n            bVar2 = (&_sch_istable)[(ulong)bVar7 * 2];\n            while ((bVar2 & 0x40) != 0) {\n              bVar7 = pbVar28[1];\n              pbVar28 = pbVar28 + 1;\n              bVar2 = (&_sch_istable)[(ulong)bVar7 * 2];\n            }\n            local_110 = local_110 + 1;\n          } while (bVar7 != 0);\n          free(__ptr);\n          ppcVar19 = ppcVar18;\n          if (param_2 == ppcVar18) goto LAB_001172ad;\n          goto LAB_00116ed7;\n        }\nLAB_0011728f:\n        __src = (long *)xmalloc(8);\n        *__src = 0;\n        if (param_2 == ppcVar18) {\nLAB_001172ad:\n          if (*ppcVar18 == (char *)0x0) {\n            iVar9 = 0;\n          }\n          else {\n            lVar17 = 1;\n            do {\n              iVar9 = (int)lVar17;\n              ppcVar19 = ppcVar18 + lVar17;\n              lVar17 = lVar17 + 1;\n            } while (*ppcVar19 != (char *)0x0);\n          }\n          lVar17 = 0;\n          ppcVar19 = (char **)xmalloc((long)(iVar9 + 1) << 3);\n          pcVar32 = *ppcVar18;\n          while (pcVar32 != (char *)0x0) {\n            uVar24 = xstrdup();\n            *(undefined8 *)((long)ppcVar19 + lVar17) = uVar24;\n            lVar17 = lVar17 + 8;\n            pcVar32 = *(char **)((long)ppcVar18 + lVar17);\n          }\n          *(undefined8 *)((long)ppcVar19 + lVar17) = 0;\nLAB_00116ed7:\n          ppcVar18 = ppcVar19;\n          if (*__src == 0) goto LAB_00117768;\n          lVar17 = 0;\n          do {\n            lVar17 = lVar17 + 1;\n          } while (__src[lVar17] != 0);\n          local_118 = lVar17 * 8;\n        }\n        else {\nLAB_00117768:\n          lVar17 = 0;\n          local_118 = 0;\n        }\n        free(ppcVar18[lVar30]);\n        ppcVar18 = (char **)xrealloc(ppcVar18,(lVar17 + 1 + (long)iVar35) * 8);\n        uVar36 = iVar35 + -1 + (int)lVar17;\n        unaff_R13 = (char *)(ulong)uVar36;\n        memmove(ppcVar18 + lVar30 + lVar17,ppcVar18 + 1 + lVar30,(long)(iVar35 - iVar13) << 3);\n        memcpy(ppcVar18 + lVar30,__src,local_118);\n        free(__src);\n        free(__s);\n        fclose(pFVar14);\n        uVar10 = iVar11 + 1;\n        unaff_R12 = (FILE *)(lVar30 * 8);\n        if ((int)uVar36 <= (int)uVar10) goto LAB_00117086;\n      }\n      else {\nLAB_00116fd0:\n        if (iVar35 <= iVar13 + 1) goto LAB_00117086;\nLAB_00116fde:\n        uVar10 = iVar13 + 1;\n        iVar11 = iVar13;\n      }\n      unaff_R12 = (FILE *)(ulong)uVar10;\n    } while( true );\n  }\nLAB_0011708b:\n  DAT_00127a2c = 0;\n  DAT_00127a28 = 0;\n  iVar11 = bfd_init();\n  pcVar32 = \"fatal error: libbfd ABI mismatch\";\n  if (iVar11 != 0x118) {\nLAB_00117aed:\n    uVar24 = dcgettext(0,pcVar32,5);\n                    \n    print_error_and_exit_00119dd0(uVar24);\n  }\n  pcVar32 = \"x86_64-pc-linux-gnu\";\n  bVar7 = bfd_set_default_target(\"x86_64-pc-linux-gnu\",\"fatal error: libbfd ABI mismatch\",5);\n  pcVar26 = DAT_001275e0;\n  if (bVar7 == 0) {\n    uVar12 = bfd_get_error();\n    pcVar26 = (char *)bfd_errmsg(uVar12);\n    pcVar34 = \"can\\'t set BFD default target to `%s\\': %s\";\nLAB_00118de6:\n    uVar24 = dcgettext(0,pcVar34,5);\n                    \n    print_error_and_exit_00119dd0(uVar24,pcVar32,pcVar26);\n  }\n  uVar10 = _DAT_00127a24;\n  if ((int)_DAT_00127a24 < 0) {\n    sVar15 = strlen(DAT_001275e0);\n    uVar10 = 0;\n    if (4 < (int)sVar15) {\n      iVar11 = filename_cmp(pcVar26 + (long)(int)sVar15 + -5,\"strip\");\n      uVar10 = (uint)(iVar11 == 0);\n    }\n  }\n  _DAT_00127a24 = uVar10;\n  DAT_001279f8 = initialize_hash_table_00113f20();\n  DAT_001279f0 = initialize_hash_table_00113f20();\n  DAT_00127a08 = initialize_hash_table_00113f20();\n  DAT_001279e8 = initialize_hash_table_00113f20();\n  DAT_001279e0 = initialize_hash_table_00113f20();\n  DAT_001279d8 = initialize_hash_table_00113f20();\n  DAT_001279d0 = initialize_hash_table_00113f20();\n  DAT_001278d0 = htab_create_alloc(0x10,hash_string_00108800,compare_strings_00108898);\n  DAT_001278c8 = initialize_hash_table_00113f20();\n  puVar6 = PTR_DAT_001264c0;\n  if (__xexit_cleanup == (code *)0x0) {\n    __xexit_cleanup = execute_reverse_functions_0011a390;\n  }\n  if (0x1f < *(int *)(PTR_DAT_001264c0 + 8)) {\n    puVar20 = (undefined8 *)malloc(0x110);\n    if (puVar20 == (undefined8 *)0x0) goto LAB_001171a7;\n    *puVar20 = puVar6;\n    *(undefined4 *)(puVar20 + 1) = 0;\n    PTR_DAT_001264c0 = (undefined *)puVar20;\n  }\n  puVar6 = PTR_DAT_001264c0;\n  iVar11 = *(int *)(PTR_DAT_001264c0 + 8);\n  *(int *)(PTR_DAT_001264c0 + 8) = iVar11 + 1;\n  *(code **)(puVar6 + (long)iVar11 * 8 + 0x10) = cleanup_hash_table_001054af;\nLAB_001171a7:\n  bfd_set_error_program_name(*ppcVar18);\n  if (_DAT_00127a24 != 0) {\n    local_130 = (FILE *)0x0;\n    unaff_R12 = (FILE *)0x0;\n    ppuVar29 = (undefined **)(FILE *)0x0;\n    pFVar14 = (FILE *)0x0;\n    bVar37 = 0;\n    bVar2 = 0;\nswitchD_001177df_caseD_0:\n    do {\n      uVar12 = getopt_long(param_1,ppcVar18,\"I:O:F:K:MN:R:o:sSpdgxXHhVvwDU\",\n                           &PTR_s_disable_deterministic_archives_001264e0);\n      pFVar21 = _optarg;\n      switch(uVar12) {\n      case 0x44:\n        _DAT_001264b0 = 1;\n        break;\n      case 0x48:\n      case 0x68:\n        print_usage_and_exit_00108a2a(_stdout,0);\n      case 0x46:\n        local_130 = _optarg;\n        pFVar14 = _optarg;\n        break;\n      case 0x49:\n        local_130 = _optarg;\n        break;\n      case 0x4b:\n        local_120 = _optarg;\n        ppFVar23 = (FILE **)htab_find_slot(DAT_00127a08,_optarg,1);\n        *ppFVar23 = pFVar21;\n        break;\n      case 0x4d:\n        DAT_00127a00 = bVar7;\n        bVar2 = bVar7;\n        break;\n      case 0x4e:\n        local_120 = _optarg;\n        ppFVar23 = (FILE **)htab_find_slot(DAT_001279f8,_optarg,1);\n        *ppFVar23 = pFVar21;\n        break;\n      case 0x4f:\n        pFVar14 = _optarg;\n        break;\n      case 0x52:\n        initialize_and_parse_rules_00114c20(_optarg);\n        break;\n      case 0x53:\n      case 100:\n      case 0x67:\n        DAT_00127a2c = 2;\n        break;\n      case 0x55:\n        _DAT_001264b0 = 0;\n        break;\n      case 0x56:\n        unaff_R12 = (FILE *)(ulong)bVar7;\n        break;\n      case 0x58:\n        DAT_00127a28 = 1;\n        break;\n      case 0x6f:\n        ppuVar29 = (undefined **)_optarg;\n        break;\n      case 0x70:\n        DAT_001279cb = 1;\n        break;\n      case 0x73:\n        DAT_00127a2c = 7;\n        break;\n      case 0x76:\n        DAT_001279c9 = 1;\n        break;\n      case 0x77:\n        DAT_001279ca = 1;\n        break;\n      case 0x78:\n        DAT_00127a28 = 2;\n        break;\n      case 0xa9:\n        bVar37 = bVar7;\n        break;\n      case 0xb2:\n        DAT_00127a18 = 1;\n        break;\n      case 0xb3:\n        parse_rules_00114190(_optarg,1,4);\n        break;\n      case 0xb5:\n        DAT_00127939 = 1;\n        break;\n      case 0xba:\n        DAT_00127a00 = 0;\n        bVar2 = bVar7;\n        break;\n      case 0xbc:\n        DAT_00127a2c = 4;\n        break;\n      case 0xc6:\n        parse_rules_00114190(_optarg,1,0x100);\n        break;\n      case 0xd0:\n        DAT_00127a2c = 5;\n        break;\n      case 0xd2:\n        goto switchD_001177df_caseD_d2;\n      default:\n        if (((bVar2 == 0) && (DAT_00127a2c < 8)) &&\n           ((-0xdaL >> ((byte)DAT_00127a2c & 0x3f) & 1U) == 0)) {\n          DAT_00127a00 = 1;\n        }\n        if (bVar37 != 0) goto LAB_00118a4c;\n        if ((char)unaff_R12 != '\\0') {\n          print_version_info_00119970(\"strip\");\n          goto LAB_001189a2;\n        }\n        if (_DAT_001264b0 < 0) {\n          _DAT_001264b0 = 1;\n        }\n        if (((DAT_00127a2c | DAT_00127a28) == 0) &&\n           (lVar30 = htab_elements(DAT_001279f8), lVar30 == 0)) {\n          DAT_00127a2c = 7;\n        }\n        if (pFVar14 == (FILE *)0x0) {\n          pFVar14 = local_130;\n        }\n        unaff_R12 = (FILE *)(long)(int)_optind;\n        if ((_optind != param_1) &&\n           (((FILE *)ppuVar29 == (FILE *)0x0 || ((int)param_1 <= (int)(_optind + 1)))))\n        goto LAB_00117888;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n      case 0x21:\n      case 0x22:\n      case 0x23:\n      case 0x24:\n      case 0x25:\n      case 0x26:\n      case 0x27:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n      case 0x3f:\n      case 0x40:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x45:\n      case 0x47:\n      case 0x4a:\n      case 0x4c:\n      case 0x50:\n      case 0x51:\n      case 0x54:\n      case 0x57:\n      case 0x59:\n      case 0x5a:\n      case 0x5b:\n      case 0x5c:\n      case 0x5d:\n      case 0x5e:\n      case 0x5f:\n      case 0x60:\n      case 0x61:\n      case 0x62:\n      case 99:\n      case 0x65:\n      case 0x66:\n      case 0x69:\n      case 0x6a:\n      case 0x6b:\n      case 0x6c:\n      case 0x6d:\n      case 0x6e:\n      case 0x71:\n      case 0x72:\n      case 0x74:\n      case 0x75:\n      case 0x79:\n      case 0x7a:\n      case 0x7b:\n      case 0x7c:\n      case 0x7d:\n      case 0x7e:\n      case 0x7f:\n      case 0x80:\n      case 0x81:\n      case 0x82:\n      case 0x83:\n      case 0x84:\n      case 0x85:\n      case 0x86:\n      case 0x87:\n      case 0x88:\n      case 0x89:\n      case 0x8a:\n      case 0x8b:\n      case 0x8c:\n      case 0x8d:\n      case 0x8e:\n      case 0x8f:\n      case 0x90:\n      case 0x91:\n      case 0x92:\n      case 0x93:\n      case 0x94:\n      case 0x95:\n      case 0x96:\n      case 0x97:\n      case 0x98:\n      case 0x99:\n      case 0x9a:\n      case 0x9b:\n      case 0x9c:\n      case 0x9d:\n      case 0x9e:\n      case 0x9f:\n      case 0xa0:\n      case 0xa1:\n      case 0xa2:\n      case 0xa3:\n      case 0xa4:\n      case 0xa5:\n      case 0xa6:\n      case 0xa7:\n      case 0xa8:\n      case 0xaa:\n      case 0xab:\n      case 0xac:\n      case 0xad:\n      case 0xae:\n      case 0xaf:\n      case 0xb0:\n      case 0xb1:\n      case 0xb4:\n      case 0xb6:\n      case 0xb7:\n      case 0xb8:\n      case 0xb9:\n      case 0xbb:\n      case 0xbd:\n      case 0xbe:\n      case 0xbf:\n      case 0xc0:\n      case 0xc1:\n      case 0xc2:\n      case 0xc3:\n      case 0xc4:\n      case 0xc5:\n      case 199:\n      case 200:\n      case 0xc9:\n      case 0xca:\n      case 0xcb:\n      case 0xcc:\n      case 0xcd:\n      case 0xce:\n      case 0xcf:\n      case 0xd1:\n        print_usage_and_exit_00108a2a(_stderr,1);\n        unaff_R13 = (char *)&PTR_s_disable_deterministic_archives_001264e0;\n        goto switchD_00117234_caseD_c1;\n      }\n    } while( true );\n  }\n  local_108 = (long *)0x0;\n  local_d8 = (FILE *)0x0;\n  local_d0 = (FILE *)0x0;\n  local_130 = (FILE *)(ulong)bVar7;\n  local_120 = (FILE *)0x0;\n  local_118 = 0;\n  local_110 = 0;\n  ppuVar29 = (undefined **)(FILE *)0x0;\n  bVar2 = 0;\nswitchD_00117234_caseD_0:\n  uVar36 = getopt_long(param_1,ppcVar18,\"b:B:i:I:j:K:MN:s:O:d:F:L:G:R:SpgxXHhVvW:wDU\",\n                       &PTR_s_add_gnu_debuglink_001268e0);\n  pFVar14 = _optarg;\n  uVar10 = DAT_001278e8;\n  pcVar26 = (char *)(ulong)uVar36;\n  if (uVar36 != 0xffffffff) goto code_r0x00117223;\n  if (bVar2 != 0) {\n    pcVar32 = \"--globalize-symbol(s) is incompatible with -G/--keep-global-symbol(s)\";\n    if ((char)local_108 != '\\0') goto LAB_00117aed;\n  }\n  if ((char)local_118 != '\\0') {\nLAB_00118a4c:\n    print_binary_file_info_001199d0();\n    return DAT_00127a20;\n  }\n  if ((char)local_110 != '\\0') {\n    print_version_info_00119970(\"objcopy\");\n    goto LAB_00118398;\n  }\n  if ((DAT_00127a1c != 0) && (DAT_001264bc == -1)) {\n    pcVar32 = \"interleave start byte must be set with --byte\";\n    goto LAB_00117aed;\n  }\n  if (DAT_00127a1c <= DAT_001264bc) {\n    pcVar32 = \"byte number must be less than interleave\";\n    goto LAB_00117aed;\n  }\n  pcVar32 = \"interleave width must be less than or equal to interleave - byte`\";\n  if (DAT_00127a1c - DAT_001264bc < DAT_001264b8) goto LAB_00117aed;\n  if ((_optind == param_1) || ((int)(_optind + 2) < (int)param_1)) goto switchD_00117234_caseD_1;\n  pcVar32 = ppcVar18[(int)_optind];\n  if ((int)(_optind + 1) < (int)param_1) {\n    pcVar34 = ppcVar18[(long)(int)_optind + 1];\n  }\n  else {\n    pcVar34 = (char *)0x0;\n  }\n  if (_DAT_001264b0 < 0) {\n    _DAT_001264b0 = 1;\n  }\n  if ((DAT_00127a2c | DAT_00127a28) == 0) {\n    DAT_00127a2c = 1;\n  }\n  if (local_d0 == (FILE *)0x0) {\n    local_d0 = local_d8;\n    if (local_d8 != (FILE *)0x0) {\nLAB_00117661:\n      cVar8 = compare_strings_00113fb0(local_d8,&DAT_0011b300);\n      if (cVar8 != '\\0') {\n        iVar11 = parse_config_00108c86(&local_d8);\n        if (iVar11 < 0) {\n          pcVar32 = \"unknown input EFI target: %s\";\n          pFVar14 = local_d8;\n          goto LAB_001176c2;\n        }\n        if (local_d0 == (FILE *)0x0) goto LAB_0011743e;\n      }\n      goto LAB_001175b1;\n    }\n  }\n  else {\n    if (local_d8 != (FILE *)0x0) goto LAB_00117661;\nLAB_001175b1:\n    cVar8 = compare_strings_00113fb0(local_d0,&DAT_0011b300);\n    if (cVar8 != '\\0') {\n      iVar11 = parse_config_00108c86(&local_d0);\n      if (iVar11 < 0) {\n        pcVar32 = \"unknown output EFI target: %s\";\n        pFVar14 = local_d0;\n        goto LAB_001176c2;\n      }\n      if (DAT_00126474 == -1) {\n        DAT_00126474 = (short)iVar11;\n      }\n      if (DAT_001264a8 == -1) {\n        DAT_001264a8 = 0x200;\n      }\n      if (DAT_00126488 == -1) {\n        DAT_00126488 = 0x1000;\n      }\n    }\n  }\nLAB_0011743e:\n  if ((pcVar34 == (char *)0x0) || (uVar10 = filename_cmp(pcVar32,pcVar34), uVar10 == 0)) {\n    __template = (char *)allocate_file_path_00114cf0(pcVar32);\n    uVar36 = mkstemp(__template);\n    if (uVar36 == 0xffffffff) {\n      free(__template);\n      piVar25 = __errno_location();\n      pcVar26 = strerror(*piVar25);\n      pcVar34 = \"warning: could not create temporary file whilst copying \\'%s\\', (error: %s)\";\n      goto LAB_00118de6;\n    }\n    uVar10 = uVar36;\n    if (-1 < (int)uVar36) {\n      uVar10 = dup(uVar36);\n      pcVar26 = (char *)(ulong)uVar10;\n    }\n  }\n  else {\n    uVar36 = 0xffffffff;\n    __template = pcVar34;\n  }\n  copy_archive_00114690(pcVar32,__template,uVar36,local_c8,local_d8,local_d0,local_120,uVar10);\n  if (DAT_00127a20 == 0) {\n    if (pcVar34 != (char *)0x0) {\n      pcVar32 = pcVar34;\n    }\n    iVar11 = copy_and_delete_file_00115970(__template,pcVar32,pcVar26,local_c8,DAT_001279cb);\n    DAT_00127a20 = (uint)(iVar11 != 0);\n  }\n  else {\n    if (-1 < (int)pcVar26) {\n      close((int)pcVar26);\n    }\n    unlink_if_ordinary(__template);\n  }\n  if (pcVar34 != __template) {\n    free(__template);\n  }\n  puVar20 = DAT_001278e0;\n  if ((char)local_130 != '\\0') {\n    for (; puVar20 != (undefined8 *)0x0; puVar20 = (undefined8 *)*puVar20) {\n      if (*(char *)(puVar20 + 2) == '\\0') {\n        uVar10 = *(uint *)((long)puVar20 + 0x14);\n        if ((uVar10 & 0x18) != 0) {\n          uVar24 = puVar20[3];\n          uVar3 = puVar20[1];\n          uVar22 = dcgettext(0,\"%s %s%c0x%lx never used\",5);\n          print_error_message_00119ed0(uVar22,\"--change-section-vma\",uVar3,\n                       (-(uint)((uVar10 & 8) == 0) & 0xffffffee) + 0x3d,uVar24);\n          uVar10 = *(uint *)((long)puVar20 + 0x14);\n        }\n        if ((uVar10 & 0x60) != 0) {\n          uVar24 = puVar20[4];\n          uVar3 = puVar20[1];\n          uVar22 = dcgettext(0,\"%s %s%c0x%lx never used\",5);\n          print_error_message_00119ed0(uVar22,\"--change-section-lma\",uVar3,\n                       (-(uint)((uVar10 & 0x20) == 0) & 0xffffffee) + 0x3d,uVar24);\n        }\n      }\n    }\n  }\n  free(DAT_00127950);\n  free(DAT_00127948);\n  free(DAT_00127940);\n  free(DAT_00127930);\n  free(DAT_00127928);\n  free(DAT_00127920);\n  free(DAT_00127918);\n  return DAT_00127a20;\nLAB_00116d48:\n  bVar7 = pbVar28[1];\n  pbVar28 = pbVar28 + 1;\n  if (bVar7 == 0) goto LAB_0011728f;\n  goto LAB_00116d58;\nLAB_00117086:\n  param_1 = (uint)unaff_R13;\n  goto LAB_0011708b;\nLAB_00117888:\n  uVar10 = DAT_00127a20;\n  if ((int)param_1 <= (int)unaff_R12) {\n    return DAT_00127a20;\n  }\n  lVar30 = check_file_properties_00113f50(ppcVar18[(long)unaff_R12]);\n  if (lVar30 < 1) {\nLAB_00118edb:\n    DAT_00127a20 = 1;\n  }\n  else {\n    pcVar32 = ppcVar18[(long)unaff_R12];\n    if ((FILE *)ppuVar29 == (FILE *)0x0) {\nLAB_001178b9:\n      pFVar21 = (FILE *)allocate_file_path_00114cf0(pcVar32);\n      iVar11 = mkstemp((char *)pFVar21);\n      if (iVar11 == -1) {\n        free(pFVar21);\n        uVar24 = dcgettext(0,\"could not create temporary file to hold stripped copy\",5);\n        display_error_001126c0(ppcVar18[(long)unaff_R12],0,0,uVar24);\n        goto LAB_00118edb;\n      }\n      iVar13 = -1;\n      if (-1 < iVar11) {\n        iVar13 = dup(iVar11);\n      }\n    }\n    else {\n      iVar11 = filename_cmp(pcVar32,ppuVar29);\n      if (iVar11 == 0) {\n        pcVar32 = ppcVar18[(long)unaff_R12];\n        goto LAB_001178b9;\n      }\n      iVar11 = -1;\n      iVar13 = -1;\n      pFVar21 = (FILE *)ppuVar29;\n    }\n    DAT_00127a20 = 0;\n    copy_archive_00114690(ppcVar18[(long)unaff_R12],pFVar21,iVar11,local_c8,local_130,pFVar14,0);\n    if (DAT_00127a20 == 0) {\n      pFVar33 = (FILE *)ppuVar29;\n      if ((FILE *)ppuVar29 == (FILE *)0x0) {\n        pFVar33 = (FILE *)ppcVar18[(long)unaff_R12];\n      }\n      iVar11 = copy_and_delete_file_00115970(pFVar21,pFVar33,iVar13,local_c8,DAT_001279cb);\n      DAT_00127a20 = uVar10;\n      if (iVar11 != 0) {\n        DAT_00127a20 = 1;\n      }\n    }\n    else {\n      if (-1 < iVar13) {\n        close(iVar13);\n      }\n      unlink_if_ordinary(pFVar21);\n    }\n    if ((FILE *)ppuVar29 != pFVar21) {\n      free(pFVar21);\n    }\n  }\n  unaff_R12 = (FILE *)((long)&unaff_R12->_flags + 1);\n  goto LAB_00117888;\nswitchD_001177df_caseD_d2:\n  DAT_00127a2c = 3;\n  goto switchD_001177df_caseD_0;\nLAB_001189a2:\n  pcVar32 = \"bad format for --set-section-alignment: numeric argument needed\";\n  goto LAB_00117aed;\nLAB_00119858:\n  if (iVar13 == 10) goto LAB_0011902d;\n  if (iVar13 == 0xd) goto LAB_00119866;\n  if (iVar13 + 1U < 2) goto LAB_001198cd;\n  if ((iVar13 != 0x20) && (iVar13 != 9)) {\n    if (iVar13 != 0x23) goto LAB_001198d6;\n    goto LAB_001198ec;\n  }\n  iVar13 = getc((FILE *)ppuVar29);\n  goto LAB_00119858;\nLAB_0011902d:\n  if (iVar13 == 0xd) {\nLAB_00119866:\n    iVar13 = getc((FILE *)ppuVar29);\n    if (iVar13 == 10) {\n      if (*(char *)(int *)unaff_R13 != '\\0') {\n        check_symbol_redefinition_00108d9a(pFVar14,unaff_R13,\n                     (undefined *)((long)&unaff_R12->_flags + (long)(int *)unaff_R13));\n      }\n      goto LAB_0011988e;\n    }\nLAB_001198cd:\n    if (iVar13 != -1) {\nLAB_001198d6:\n      pcVar32 = \"%s:%d: garbage found at end of line\";\nLAB_00119756:\n      uVar24 = dcgettext(0,pcVar32,5);\n                    \n      print_error_and_exit_00119dd0(uVar24,pFVar14,iVar11 + -1);\n    }\n  }\n  else {\n    iVar13 = 10;\n  }\nLAB_0011903b:\n  if (*(char *)(int *)unaff_R13 != '\\0') {\n    check_symbol_redefinition_00108d9a(pFVar14,unaff_R13,(undefined *)((long)&unaff_R12->_flags + (long)(int *)unaff_R13))\n    ;\n  }\n  unaff_R12 = (FILE *)ppuVar29;\n  if (iVar13 == -1) goto LAB_00119065;\nLAB_0011988e:\n  iVar13 = getc((FILE *)ppuVar29);\n  iVar11 = iVar11 + 1;\n  goto LAB_00118ace;\nswitchD_00117234_caseD_c7:\n  pcVar32 = strchr((char *)_optarg,0x3d);\n  if ((pcVar32 != (char *)0x0) && ((int)pcVar32 != iVar11)) {\n    uVar27 = (long)pcVar32 - (long)pFVar14 & 0xffffffff;\n    pcVar34 = pcVar32 + 1;\n    pcVar26 = (char *)xmalloc((int)((long)pcVar32 - (long)pFVar14) + 1);\n    strncpy(pcVar26,(char *)_optarg,uVar27);\n    pcVar26[uVar27] = '\\0';\n    pcVar32 = strchr(pcVar34,0x2c);\n    if (pcVar32 == (char *)0x0) {\n      unaff_R12 = (FILE *)0xffffffff;\n      sVar15 = strlen(pcVar34);\n      sVar15 = sVar15 & 0xffffffff;\n    }\n    else {\n      sVar15 = (size_t)(uint)((int)pcVar32 - (int)pcVar34);\n      uVar10 = parse_flags_00113fe0(pcVar32 + 1);\n      unaff_R12 = (FILE *)(ulong)uVar10;\n    }\n    if ((int)sVar15 != 0) {\n      unaff_R13 = (char *)xmalloc((int)sVar15 + 1);\n      strncpy(unaff_R13,pcVar34,sVar15);\n      *(undefined *)((long)(int *)unaff_R13 + sVar15) = 0;\n      ppuVar29 = (undefined **)DAT_001278d8;\n      goto LAB_00117f6f;\n    }\n  }\n  uVar24 = dcgettext(0,\"bad format for %s\",5);\n                    \n  print_error_and_exit_00119dd0(uVar24,\"--rename-section\");\ncode_r0x00117223:\n  iVar11 = (int)_optarg;\n  switch(pcVar26) {\n  case (char *)0x0:\n    goto switchD_00117234_caseD_0;\n  default:\nswitchD_00117234_caseD_1:\n    print_usage_00108916(_stderr,1);\n    do {\n      iVar11 = strcmp(*ppuVar29,pcVar26);\n      if (iVar11 == 0) {\n        iVar11 = strcmp(*(char **)((long)ppuVar29 + 8),unaff_R13);\n        if ((iVar11 != 0) || ((int)unaff_R12 != *(int *)((long)ppuVar29 + 0x10))) {\n          uVar24 = dcgettext(0,\"Multiple renames of section %s\",5);\n                    \n          print_error_and_exit_00119dd0(uVar24,pcVar26);\n        }\n        goto switchD_00117234_caseD_0;\n      }\n      ppuVar29 = (undefined **)*(FILE **)((long)ppuVar29 + 0x18);\nLAB_00117f6f:\n    } while ((FILE *)ppuVar29 != (FILE *)0x0);\n    pFVar14 = (FILE *)xmalloc(0x20);\n    *(char **)pFVar14 = pcVar26;\n    pFVar14->_IO_read_ptr = unaff_R13;\n    *(int *)&pFVar14->_IO_read_end = (int)unaff_R12;\n    pFVar14->_IO_read_base = (char *)DAT_001278d8;\n    DAT_001278d8 = pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x42:\n    ppuVar29 = (undefined **)&optarg;\n    local_120 = (FILE *)bfd_scan_arch(_optarg);\n    if (local_120 != (FILE *)0x0) goto switchD_00117234_caseD_0;\n    pcVar32 = \"architecture %s unknown\";\n    pFVar14 = _optarg;\n    break;\n  case (char *)0x44:\n    _DAT_001264b0 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x46:\n    local_d0 = _optarg;\n    local_d8 = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x47:\n    ppFVar23 = (FILE **)htab_find_slot(DAT_001279d8,_optarg,1);\n    *ppFVar23 = pFVar14;\n    local_108 = (long *)(ulong)bVar7;\n    ppuVar29 = (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x48:\n  case (char *)0x68:\n    print_usage_00108916(_stdout,0);\n  case (char *)0xcd:\n    _bfd_srec_forceS3 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x49:\n  case (char *)0x73:\n    local_d8 = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4b:\n    ppFVar23 = (FILE **)htab_find_slot(DAT_00127a08,_optarg,1);\n    *ppFVar23 = pFVar14;\n    ppuVar29 = (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4c:\n    ppFVar23 = (FILE **)htab_find_slot(DAT_001279e8,_optarg,1);\n    *ppFVar23 = pFVar14;\n    ppuVar29 = (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4d:\n    DAT_00127a00 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4e:\n    ppFVar23 = (FILE **)htab_find_slot(DAT_001279f8,_optarg,1);\n    *ppFVar23 = pFVar14;\n    ppuVar29 = (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4f:\n  case (char *)0x64:\n    local_d0 = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x52:\n    initialize_and_parse_rules_00114c20(_optarg);\n    goto switchD_00117234_caseD_0;\n  case (char *)0x53:\n    DAT_00127a2c = 7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x55:\n    _DAT_001264b0 = 0;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x56:\n    local_110 = (ulong)bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x57:\n    ppFVar23 = (FILE **)htab_find_slot(DAT_001279d0,_optarg,1);\n    *ppFVar23 = pFVar14;\n    ppuVar29 = (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x58:\n    DAT_00127a28 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x62:\n    lVar30 = strtol((char *)_optarg,(char **)0x0,10);\n    DAT_001264bc = (int)lVar30;\n    if (DAT_001264bc < 0) {\n      pcVar32 = \"byte number must be non-negative\";\n      goto LAB_00117aed;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0x67:\n    DAT_00127a2c = 2;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x69:\n    if (_optarg == (FILE *)0x0) {\n      DAT_00127a1c = 4;\n    }\n    else {\n      lVar30 = strtol((char *)_optarg,(char **)0x0,10);\n      DAT_00127a1c = (int)lVar30;\n      if (DAT_00127a1c < 1) {\n        pcVar32 = \"interleave must be positive\";\n        goto LAB_00117aed;\n      }\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0x6a:\n    parse_rules_00114190(_optarg,1,2);\n    DAT_00127a19 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x70:\n    DAT_001279cb = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x76:\n    DAT_001279c9 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x77:\n    DAT_001279ca = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x78:\n    DAT_00127a28 = 2;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x96:\n    DAT_001279c0 = extract_parameter_values_00114c80(_optarg,DAT_001279c0,\"--add-section\");\n    read_and_allocate_file_00114d60(DAT_001279c0);\n    goto switchD_00117234_caseD_0;\n  case (char *)0x97:\n    DAT_001264b4 = 1;\n    DAT_00127a10 = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x98:\n    puVar20 = (undefined8 *)xmalloc(0x30);\n    *puVar20 = 0;\n    unaff_R13 = (char *)_optarg;\n    pcVar32 = strchr((char *)_optarg,0x3d);\n    if (pcVar32 == (char *)0x0) {\n      uVar24 = dcgettext(0,\"bad format for %s\",5);\n                    \n      print_error_and_exit_00119dd0(uVar24,\"--add-symbol\");\n    }\n    ppuVar29 = (undefined **)(pcVar32 + 1);\n    pcVar32 = strchr((char *)ppuVar29,0x3a);\n    uVar24 = copy_string_and_null_terminate_0011a480(unaff_R13);\n    puVar20[1] = uVar24;\n    if (pcVar32 == (char *)0x0) {\n      puVar20[4] = 0;\n      lVar30 = strtol((char *)ppuVar29,(char **)0x0,0);\n    }\n    else {\n      uVar24 = copy_string_and_null_terminate_0011a480(ppuVar29);\n      puVar20[4] = uVar24;\n      lVar30 = strtol((char *)(FILE *)(pcVar32 + 1),(char **)0x0,0);\n      ppuVar29 = (undefined **)(FILE *)(pcVar32 + 1);\n    }\n    puVar20[2] = lVar30;\n    pcVar32 = strchr((char *)ppuVar29,0x2c);\n    puVar20[5] = 0;\n    if (pcVar32 == (char *)0x0) {\n      *(undefined4 *)(puVar20 + 3) = 2;\n      unaff_R12 = (FILE *)0x0;\n    }\n    else {\n      ppuVar29 = (undefined **)0x0;\n      pFVar14 = (FILE *)(pcVar32 + 1);\n      do {\n        unaff_R12 = pFVar14;\n        pcVar32 = strchr((char *)unaff_R12,0x2c);\n        if (pcVar32 == (char *)0x0) {\n          sVar15 = strlen((char *)unaff_R12);\n          pFVar14 = (FILE *)0x0;\n        }\n        else {\n          pFVar14 = (FILE *)(pcVar32 + 1);\n          sVar15 = (long)pcVar32 - (long)unaff_R12;\n        }\n        uVar10 = (uint)ppuVar29;\n        if (sVar15 == 5) {\n          iVar11 = strncasecmp(\"local\",(char *)unaff_R12,5);\n          if (iVar11 == 0) {\n            ppuVar29 = (undefined **)(ulong)(uVar10 | 1);\n          }\n          else {\n            iVar11 = strncasecmp(\"debug\",(char *)unaff_R12,5);\n            if (iVar11 != 0) goto LAB_001186b2;\n            ppuVar29 = (undefined **)(ulong)(uVar10 | 4);\n          }\n        }\n        else if (sVar15 == 6) {\n          iVar11 = strncasecmp(\"global\",(char *)unaff_R12,6);\n          if ((iVar11 == 0) || (iVar11 = strncasecmp(\"export\",(char *)unaff_R12,6), iVar11 == 0)) {\n            ppuVar29 = (undefined **)(ulong)(uVar10 | 2);\n          }\n          else {\n            iVar11 = strncasecmp(\"object\",(char *)unaff_R12,6);\n            if (iVar11 != 0) goto LAB_001186b2;\n            ppuVar29 = (undefined **)(ulong)(uVar10 | 0x10000);\n          }\n        }\n        else if (sVar15 == 8) {\n          iVar11 = strncasecmp(\"function\",(char *)unaff_R12,8);\n          if (iVar11 == 0) {\n            ppuVar29 = (undefined **)(ulong)(uVar10 | 8);\n          }\n          else {\n            iVar11 = strncasecmp(\"indirect\",(char *)unaff_R12,8);\n            if (iVar11 != 0) goto LAB_0011862f;\n            ppuVar29 = (undefined **)((ulong)ppuVar29 | 0x2000);\n          }\n        }\n        else if (sVar15 == 4) {\n          iVar11 = strncasecmp(\"weak\",(char *)unaff_R12,4);\n          if (iVar11 == 0) {\n            ppuVar29 = (undefined **)((ulong)ppuVar29 | 0x80);\n          }\n          else {\n            iVar11 = strncasecmp(\"file\",(char *)unaff_R12,4);\n            if (iVar11 != 0) goto LAB_001186b2;\n            ppuVar29 = (undefined **)((ulong)ppuVar29 | 0x4000);\n          }\n        }\n        else if (sVar15 == 7) {\n          iVar11 = strncasecmp(\"section\",(char *)unaff_R12,7);\n          if (iVar11 == 0) {\n            ppuVar29 = (undefined **)((ulong)ppuVar29 | 0x100);\n          }\n          else {\n            iVar11 = strncasecmp(\"warning\",(char *)unaff_R12,7);\n            if (iVar11 != 0) goto LAB_001186b2;\n            ppuVar29 = (undefined **)((ulong)ppuVar29 | 0x1000);\n          }\n        }\n        else {\n          if (sVar15 == 0xb) {\n            iVar11 = strncasecmp(\"constructor\",(char *)unaff_R12,0xb);\n            if (iVar11 == 0) {\n              ppuVar29 = (undefined **)((ulong)ppuVar29 | 0x800);\n              goto LAB_00117e3d;\n            }\n          }\n          else if (sVar15 == 9) {\n            iVar11 = strncasecmp(\"synthetic\",(char *)unaff_R12,9);\n            if (iVar11 == 0) {\n              ppuVar29 = (undefined **)(ulong)(uVar10 | 0x200000);\n              goto LAB_00117e3d;\n            }\n          }\n          else if (sVar15 == 0x11) {\n            iVar11 = strncasecmp(\"indirect-function\",(char *)unaff_R12,0x11);\n            if (iVar11 == 0) {\n              ppuVar29 = (undefined **)(ulong)(uVar10 | 0x400008);\n              goto LAB_00117e3d;\n            }\n          }\n          else if (sVar15 == 0xd) {\n            iVar11 = strncasecmp(\"unique-object\",(char *)unaff_R12,0xd);\n            if (iVar11 == 0) {\n              ppuVar29 = (undefined **)(ulong)(uVar10 | 0x810000);\n              goto LAB_00117e3d;\n            }\n          }\n          else if (sVar15 < 8) goto LAB_001186b2;\nLAB_0011862f:\n          iVar11 = strncasecmp(\"before=\",(char *)unaff_R12,7);\n          if (iVar11 != 0) {\nLAB_001186b2:\n            pcVar32 = (char *)xmalloc(sVar15 + 1);\n            strncpy(pcVar32,(char *)unaff_R12,sVar15);\n            pcVar32[sVar15] = '\\0';\n            uVar24 = dcgettext(0,\"unrecognized symbol flag `%s\\'\",5);\n            print_error_message_00119ed0(uVar24,pcVar32);\n            uVar24 = dcgettext(0,\"supported flags: %s\",5);\n                    \n            print_error_and_exit_00119dd0(uVar24,\n                         \"local, global, export, debug, function, weak, section, constructor, warning, indirect, file, object, synthetic, indirect-function, unique-object, before=<othersym>\"\n                        );\n          }\n          uVar24 = copy_string_and_null_terminate_0011a480(&unaff_R12->field_0x7,sVar15 - 7);\n          puVar20[5] = uVar24;\n        }\nLAB_00117e3d:\n      } while (pFVar14 != (FILE *)0x0);\n      *(int *)(puVar20 + 3) = (int)ppuVar29;\n      unaff_R13 = (char *)0x0;\n      if (puVar20[5] != 0) {\n        *puVar20 = DAT_001279a8;\n        bVar39 = DAT_001279a8 == (undefined8 *)0x0;\n        DAT_001279a8 = puVar20;\n        if (bVar39) {\n          PTR_DAT_001275a0 = (undefined *)puVar20;\n        }\n        goto LAB_00117e65;\n      }\n    }\n    *(undefined8 **)PTR_DAT_001275a0 = puVar20;\n    PTR_DAT_001275a0 = (undefined *)puVar20;\nLAB_00117e65:\n    DAT_001279a0 = DAT_001279a0 + 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x99:\n    DAT_00127910 = strtoul((char *)_optarg,(char **)0x0,0);\n    if (DAT_00127910 == 0) {\n      pcVar32 = \"unable to parse alternative machine code\";\n      goto LAB_00117aed;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0x9a:\n    _DAT_00127990 = check_and_print_error_00119940(_optarg,\"--change-addresses\");\n    DAT_00127998 = _DAT_00127990;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x9b:\n    DAT_00127988 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x9c:\n  case (char *)0x9d:\n  case (char *)0x9e:\n    ppuVar29 = (undefined **)strchr((char *)_optarg,0x3d);\n    if (uVar36 == 0x9d) {\n      uVar12 = 0x40;\n      unaff_R13 = \"--change-section-lma\";\n      if ((FILE *)ppuVar29 != (FILE *)0x0) {\n        uVar12 = 0x20;\n        goto LAB_00117a19;\n      }\n    }\n    else if (uVar36 == 0x9e) {\n      if ((FILE *)ppuVar29 != (FILE *)0x0) {\n        unaff_R13 = \"--change-section-vma\";\n        uVar12 = 8;\n        goto LAB_00117a19;\n      }\n      uVar12 = 0x10;\n      unaff_R13 = \"--change-section-vma\";\n    }\n    else {\n      unaff_R13 = \"--change-section-address\";\n      uVar12 = 0x28;\n      if ((FILE *)ppuVar29 != (FILE *)0x0) goto LAB_00117a19;\n      uVar12 = 0x50;\n    }\n    ppuVar29 = (undefined **)strchr((char *)pFVar14,0x2b);\n    if (((FILE *)ppuVar29 == (FILE *)0x0) &&\n       (ppuVar29 = (undefined **)strchr((char *)pFVar14,0x2d), (FILE *)ppuVar29 == (FILE *)0x0)) {\n      uVar24 = dcgettext(0,\"bad format for %s\",5);\n                    \n      print_error_and_exit_00119dd0(uVar24,unaff_R13);\n    }\nLAB_00117a19:\n    iVar11 = (int)ppuVar29 - iVar11;\n    pcVar32 = (char *)xmalloc((long)(iVar11 + 1));\n    unaff_R12 = (FILE *)(long)iVar11;\n    pcVar32 = strncpy(pcVar32,(char *)_optarg,(size_t)unaff_R12);\n    pcVar32[(long)unaff_R12] = '\\0';\n    lVar30 = parse_rules_00114190(pcVar32,1,uVar12);\n    lVar17 = check_and_print_error_00119940((undefined *)((long)(int *)ppuVar29 + 1),unaff_R13);\n    if (*(char *)(int *)ppuVar29 == '-') {\n      lVar17 = -lVar17;\n    }\n    if ((uVar36 == 0x9d) || (*(long *)(lVar30 + 0x18) = lVar17, uVar36 != 0x9e)) {\n      *(long *)(lVar30 + 0x20) = lVar17;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0x9f:\n    DAT_00127998 = check_and_print_error_00119940(_optarg,\"--change-start\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa0:\n    local_130 = (FILE *)(ulong)bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa1:\n    ppuVar29 = (undefined **)_optarg;\n    if (_optarg == (FILE *)0x0) {\nLAB_00118398:\n      DAT_00127984 = 1;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcasecmp((char *)_optarg,\"none\");\n    if (iVar11 == 0) {\n      DAT_00127984 = 0x20;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcasecmp((char *)pFVar14,\"zlib\");\n    if (iVar11 == 0) {\n      DAT_00127984 = 3;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcasecmp((char *)pFVar14,\"zlib-gnu\");\n    if (iVar11 == 0) {\n      DAT_00127984 = 5;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcasecmp((char *)pFVar14,\"zlib-gabi\");\n    if (iVar11 == 0) {\n      DAT_00127984 = 9;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcasecmp((char *)pFVar14,\"zstd\");\n    if (iVar11 == 0) {\n      DAT_00127984 = 0x11;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    pcVar32 = \"unrecognized --compress-debug-sections type `%s\\'\";\n    break;\n  case (char *)0xa2:\n    DAT_00127980 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa3:\n    DAT_00127984 = 0x20;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa4:\n    DAT_001279b0 = extract_parameter_values_00114c80(_optarg,DAT_001279b0,\"--dump-section\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa5:\n    iVar11 = strcasecmp((char *)_optarg,\"yes\");\n    if (iVar11 == 0) {\n      DAT_0012797c = 1;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcasecmp((char *)pFVar14,\"no\");\n    if (iVar11 == 0) {\n      DAT_0012797c = 2;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    pcVar32 = \"unrecognized --elf-stt-common= option `%s\\'\";\n    break;\n  case (char *)0xa6:\n    DAT_00127a2c = 6;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa7:\n    DAT_001278ec = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa8:\n    DAT_001264a8 = check_and_print_error_00119940(_optarg,\"--file-alignment\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa9:\n    local_118 = (size_t)bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xaa:\n    ppuVar29 = (undefined **)check_and_print_error_00119940(_optarg,\"--gap-fill\");\n    DAT_00127979 = SUB81(ppuVar29,0);\n    if ((FILE *)0xff < ppuVar29) {\n      uVar24 = dcgettext(0,\"Warning: truncating gap-fill from 0x%lx to 0x%x\",5);\n      print_error_message_00119ed0(uVar24,ppuVar29,(ulong)ppuVar29 & 0xff);\n    }\n    DAT_00127978 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xab:\n    ppFVar23 = (FILE **)htab_find_slot(DAT_001279e0,_optarg,1);\n    *ppFVar23 = pFVar14;\n    ppuVar29 = (undefined **)pFVar14;\n    bVar2 = bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xac:\n    load_and_parse_file_00114460(_optarg,DAT_001279e0,&DAT_00127928);\n    bVar2 = bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xad:\n    DAT_001264a0 = strtoul((char *)_optarg,(char **)(FILE *)local_c8,0);\n    unaff_R12 = _optarg;\n    ppuVar29 = (undefined **)(FILE *)local_c8;\n    if ((FILE *)local_c8._0_8_ != _optarg) {\n      if (*(char *)(int *)local_c8._0_8_ == '.') {\n        DAT_00126498 = strtoul((char *)((long)(int *)local_c8._0_8_ + 1),(char **)(FILE *)local_c8,0\n                              );\n        pFVar14 = _optarg;\n        if (*(char *)(int *)local_c8._0_8_ != '\\0') {\n          uVar24 = dcgettext(0,\"%s: invalid commit value for --heap\",5);\n          print_error_message_00119ed0(uVar24,pFVar14);\n          ppuVar29 = (undefined **)pFVar14;\n        }\n        goto switchD_00117234_caseD_0;\n      }\n      if (*(char *)(int *)local_c8._0_8_ == '\\0') goto switchD_00117234_caseD_0;\n    }\n    uVar24 = dcgettext(0,\"%s: invalid reserve value for --heap\",5);\n    print_error_message_00119ed0(uVar24,unaff_R12);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xae:\n    DAT_00126490 = check_and_print_error_00119940(_optarg,\"--image-base\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xaf:\n    DAT_001278f0 = DAT_001278f0 | 0x100;\n    DAT_001278f4 = DAT_001278f4 & 0xfffffeff;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb0:\n    lVar30 = strtol((char *)_optarg,(char **)0x0,10);\n    DAT_001264b8 = (int)lVar30;\n    if (DAT_001264b8 < 1) {\n      pcVar32 = \"interleave width must be positive\";\n      goto LAB_00117aed;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb1:\n    load_and_parse_file_00114460(_optarg,DAT_001279d8,&DAT_00127920);\n    local_108 = (long *)(ulong)bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb2:\n    DAT_00127a18 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb3:\n    parse_rules_00114190(_optarg,1,4);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb4:\n    load_and_parse_file_00114460(_optarg,DAT_00127a08,&DAT_00127940);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb5:\n    DAT_00127939 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb6:\n    DAT_00127938 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb7:\n    load_and_parse_file_00114460(_optarg,DAT_001279e8,&DAT_00127930);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb8:\n    iVar11 = strcmp(\"enable\",(char *)_optarg);\n    if (iVar11 == 0) {\n      DAT_001264b4 = 1;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcmp(\"disable\",(char *)pFVar14);\n    if (iVar11 == 0) {\n      DAT_001264b4 = 0;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcmp(\"keep\",(char *)pFVar14);\n    if (iVar11 == 0) {\n      DAT_001264b4 = 2;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    pcVar32 = \"unknown long section names option \\'%s\\'\";\n    break;\n  case (char *)0xba:\n    DAT_00127a00 = 0;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbb:\n    local_130 = (FILE *)0x0;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbc:\n    DAT_00127a2c = 4;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbd:\n    DAT_00127970 = check_and_print_error_00119940(_optarg,\"--pad-to\");\n    DAT_00127969 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbe:\n    DAT_001278f8 = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbf:\n    DAT_00127900 = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc0:\n    DAT_00127908 = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc1:\nswitchD_00117234_caseD_c1:\n    DAT_001278f4 = DAT_001278f4 | 0x100;\n    DAT_001278f0 = DAT_001278f0 & 0xfffffeff;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc2:\n    DAT_001278f4 = DAT_001278f4 | 0x80;\n    DAT_001278f0 = DAT_001278f0 & 0xffffff7f;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc3:\n    unaff_R13 = &optarg;\n    pcVar32 = strchr((char *)_optarg,0x3d);\n    if (pcVar32 == (char *)0x0) {\n      uVar24 = dcgettext(0,\"bad format for %s\",5);\n                    \n      print_error_and_exit_00119dd0(uVar24,\"--redefine-sym\");\n    }\n    ppuVar29 = (undefined **)(pcVar32 + 1);\n    iVar11 = (int)pcVar32 - iVar11;\n    pcVar32 = (char *)xmalloc((long)(iVar11 + 1));\n    strncpy(pcVar32,(char *)_optarg,(long)iVar11);\n    pcVar32[iVar11] = '\\0';\n    sVar15 = strlen((char *)ppuVar29);\n    unaff_R12 = (FILE *)xmalloc((long)((int)sVar15 + 1));\n    strcpy((char *)unaff_R12,(char *)ppuVar29);\n    check_symbol_redefinition_00108d9a(\"--redefine-sym\",pcVar32,unaff_R12);\n    free(pcVar32);\n    free(unaff_R12);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc4:\n    ppuVar29 = (undefined **)fopen((char *)_optarg,\"r\");\n    if ((FILE *)ppuVar29 == (FILE *)0x0) {\n      piVar25 = __errno_location();\n      pcVar32 = strerror(*piVar25);\n      uVar24 = dcgettext(0,\"couldn\\'t open symbol redefinition file %s (error: %s)\",5);\n                    \n      print_error_and_exit_00119dd0(uVar24,pFVar14,pcVar32);\n    }\n    pFVar21 = (FILE *)0x64;\n    unaff_R13 = (char *)xmalloc(0x65);\n    iVar13 = getc((FILE *)ppuVar29);\n    iVar11 = 2;\nLAB_00118ace:\n    unaff_R12 = (FILE *)ppuVar29;\n    if (iVar13 != -1) {\n      pFVar33 = (FILE *)0x0;\n      while ((iVar13 != 0x20 && (iVar13 != 9))) {\n        if ((iVar13 == 10) || (iVar13 == 0xd)) {\n          *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n          goto LAB_00118faa;\n        }\n        if (iVar13 == 0) break;\n        if (iVar13 == -1) {\n          *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n          unaff_R12 = (FILE *)((long)&pFVar33->_flags + 1);\n          goto LAB_00119803;\n        }\n        unaff_R12 = pFVar33;\n        if (iVar13 == 0x23) goto LAB_00119745;\n        pFVar38 = (FILE *)((long)&pFVar33->_flags + 1);\n        *(char *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = (char)iVar13;\n        if (pFVar21 <= pFVar38) {\n          pFVar21 = (FILE *)((long)pFVar21 * 2);\n          unaff_R13 = (char *)xrealloc(unaff_R13,(undefined *)((long)&pFVar21->_flags + 1));\n        }\n        iVar13 = getc((FILE *)ppuVar29);\n        pFVar33 = pFVar38;\n      }\n      unaff_R12 = (FILE *)((long)&pFVar33->_flags + 1);\n      *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n      while ((iVar13 == 0x20 || (iVar13 == 9))) {\n        iVar13 = getc((FILE *)ppuVar29);\n      }\n      if (iVar13 == 0x23) {\nLAB_00119745:\n        if (unaff_R12 != (FILE *)0x0) goto LAB_0011974a;\n        pFVar33 = (FILE *)0x0;\n        unaff_R12 = (FILE *)0x0;\nLAB_001197ca:\n        *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n        while ((iVar13 != 10 && (iVar13 != -1))) {\n          iVar13 = getc((FILE *)ppuVar29);\n        }\n        goto LAB_0011903b;\n      }\nLAB_00118faa:\n      unaff_R12 = (FILE *)((long)&pFVar33->_flags + 1);\n      if (((iVar13 == 10) || (iVar13 == 0xd)) || (iVar13 == 0)) goto LAB_00119745;\n      pFVar38 = unaff_R12;\n      if (iVar13 != -1) {\n        do {\n          pFVar33 = (FILE *)((long)&pFVar38->_flags + 1);\n          *(char *)((long)&pFVar38->_flags + (long)(int *)unaff_R13) = (char)iVar13;\n          if (pFVar21 <= pFVar33) {\n            pFVar21 = (FILE *)((long)pFVar21 * 2);\n            unaff_R13 = (char *)xrealloc(unaff_R13,(undefined *)((long)&pFVar21->_flags + 1));\n          }\n          iVar13 = getc((FILE *)ppuVar29);\n          if ((iVar13 == 0x20) || (iVar13 == 9)) {\nLAB_001198b6:\n            *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n            pFVar33 = (FILE *)((long)&pFVar38->_flags + 2);\n            goto LAB_00119858;\n          }\n          if ((iVar13 == 10) || (iVar13 == 0xd)) {\n            *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n            goto LAB_0011902d;\n          }\n          if (iVar13 == 0) goto LAB_001198b6;\n          if (iVar13 == -1) {\n            *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n            unaff_R12 = (FILE *)((long)&pFVar38->_flags + 2);\n            goto LAB_00119803;\n          }\n          pFVar38 = pFVar33;\n        } while (iVar13 != 0x23);\nLAB_001198ec:\n        if ((pFVar33 == (FILE *)0x0) || ((unaff_R12 != (FILE *)0x0 && (unaff_R12 != pFVar33)))) {\n          iVar13 = 0x23;\n          goto LAB_001197ca;\n        }\nLAB_0011974a:\n        pcVar32 = \"%s:%d: missing new symbol name\";\n        goto LAB_00119756;\n      }\nLAB_00119803:\n      if (unaff_R12 != (FILE *)0x0) {\n        pcVar32 = \"%s:%d: premature end of file\";\n        goto LAB_00119756;\n      }\n    }\nLAB_00119065:\n    free(unaff_R13);\n    fclose((FILE *)ppuVar29);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc5:\n    DAT_00127968 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc6:\n    parse_rules_00114190(_optarg,1,0x100);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc7:\n    goto switchD_00117234_caseD_c7;\n  case (char *)0xc8:\n    ppuVar29 = (undefined **)(ulong)DAT_001278e8;\n    uVar27 = strtol((char *)_optarg,(char **)0x0,10);\n    DAT_001278e8 = (uint)uVar27;\n    if (((int)DAT_001278e8 < 1) || ((uVar27 & 1) != 0)) {\n      pcVar32 = \"number of bytes to reverse must be positive and even\";\n      goto LAB_00117aed;\n    }\n    if ((uVar10 != DAT_001278e8) && (uVar10 != 0)) {\n      uVar24 = dcgettext(0,\"Warning: ignoring previous --reverse-bytes value of %d\",5);\n      print_error_message_00119ed0(uVar24,uVar10);\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc9:\n    DAT_00126488 = check_and_print_error_00119940(_optarg,\"--section-alignment\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xca:\n    unaff_R12 = (FILE *)strchr((char *)_optarg,0x3d);\n    if (unaff_R12 == (FILE *)0x0) {\n      uVar24 = dcgettext(0,\"bad format for %s\",5);\n                    \n      print_error_and_exit_00119dd0(uVar24,\"--set-section-flags\");\n    }\n    iVar11 = (int)unaff_R12 - iVar11;\n    pcVar32 = (char *)xmalloc((long)(iVar11 + 1));\n    pcVar32 = strncpy(pcVar32,(char *)_optarg,(long)iVar11);\n    pcVar32[iVar11] = '\\0';\n    ppuVar29 = (undefined **)parse_rules_00114190(pcVar32,1,0x80);\n    uVar12 = parse_flags_00113fe0((undefined *)((long)&unaff_R12->_flags + 1));\n    *(undefined4 *)((long)ppuVar29 + 0x28) = uVar12;\n    unaff_R13 = (char *)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xcb:\n    pcVar32 = strchr((char *)_optarg,0x3d);\n    if (pcVar32 == (char *)0x0) {\n      pcVar32 = \"bad format for --set-section-alignment: argument needed\";\n      goto LAB_00117aed;\n    }\n    uVar27 = strtol(pcVar32 + 1,(char **)0x0,10);\n    if ((int)uVar27 < 1) goto LAB_001189a2;\n    unaff_R12 = (FILE *)0x0;\n    while( true ) {\n      if ((uVar27 & 1) != 0) break;\n      uVar27 = (ulong)(uint)((int)uVar27 >> 1);\n      unaff_R12 = (FILE *)(ulong)((int)unaff_R12 + 1);\n    }\n    if ((int)uVar27 != 1) {\n      pcVar32 = \"bad format for --set-section-alignment: alignment is not a power of two\";\n      goto LAB_00117aed;\n    }\n    iVar11 = (int)pcVar32 - (int)_optarg;\n    ppuVar29 = (undefined **)(long)iVar11;\n    pcVar32 = (char *)xmalloc((long)(iVar11 + 1));\n    pcVar32 = strncpy(pcVar32,(char *)_optarg,(size_t)ppuVar29);\n    pcVar32[(long)ppuVar29] = '\\0';\n    lVar30 = parse_rules_00114190(pcVar32,1,0x200);\n    if (lVar30 != 0) {\n      *(int *)(lVar30 + 0x2c) = (int)unaff_R12;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xcc:\n    _DAT_00127960 = check_and_print_error_00119940(_optarg,\"--set-start\");\n    DAT_00127958 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xce:\n    __bfd_srec_len = check_and_print_error_00119940(_optarg,\"--srec-len\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xcf:\n    DAT_00126480 = strtoul((char *)_optarg,(char **)(FILE *)local_c8,0);\n    unaff_R12 = _optarg;\n    ppuVar29 = (undefined **)(FILE *)local_c8;\n    if ((FILE *)local_c8._0_8_ != _optarg) {\n      if (*(char *)(int *)local_c8._0_8_ == '.') {\n        DAT_00126478 = strtoul((char *)((long)(int *)local_c8._0_8_ + 1),(char **)(FILE *)local_c8,0\n                              );\n        pFVar14 = _optarg;\n        if (*(char *)(int *)local_c8._0_8_ != '\\0') {\n          uVar24 = dcgettext(0,\"%s: invalid commit value for --stack\",5);\n          print_error_message_00119ed0(uVar24,pFVar14);\n          ppuVar29 = (undefined **)pFVar14;\n        }\n        goto switchD_00117234_caseD_0;\n      }\n      if (*(char *)(int *)local_c8._0_8_ == '\\0') goto switchD_00117234_caseD_0;\n    }\n    uVar24 = dcgettext(0,\"%s: invalid reserve value for --stack\",5);\n    print_error_message_00119ed0(uVar24,unaff_R12);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd0:\n    DAT_00127a2c = 5;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd1:\n    load_and_parse_file_00114460(_optarg,DAT_001279f8,&DAT_00127950);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd2:\n    DAT_00127a2c = 3;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd3:\n    ppFVar23 = (FILE **)htab_find_slot(DAT_001279f0,_optarg,1);\n    *ppFVar23 = pFVar14;\n    ppuVar29 = (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd4:\n    load_and_parse_file_00114460(_optarg,DAT_001279f0,&DAT_00127948);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd5:\n    pcVar32 = strchr((char *)_optarg,0x3a);\n    pFVar21 = pFVar14;\n    if (pcVar32 != (char *)0x0) {\n      pFVar21 = (FILE *)xstrdup(pFVar14);\n      lVar30 = (long)((int)pcVar32 - iVar11);\n      *(undefined *)((long)&pFVar21->_flags + lVar30) = 0;\n      local_c8._0_8_ = pFVar21;\n      uVar27 = strtoul((char *)((long)&pFVar21->_flags + lVar30 + 1),(char **)local_c8,0);\n      DAT_00126472 = (undefined2)uVar27;\n      if (*(char *)(int *)local_c8._0_8_ == '.') {\n        uVar27 = strtoul((char *)((long)(int *)local_c8._0_8_ + 1),(char **)local_c8,0);\n        DAT_00126470 = (undefined2)uVar27;\n      }\n      if (*(char *)(int *)local_c8._0_8_ != '\\0') {\n        uVar24 = dcgettext(0,\"%s: bad version in PE subsystem\",5);\n        print_error_message_00119ed0(uVar24,pFVar14);\n      }\n    }\n    lVar30 = strtol((char *)pFVar21,(char **)local_c8,0);\n    if (*(char *)(int *)local_c8._0_8_ == '\\0') {\n      lVar17 = 0;\n      while ((short)lVar30 != (&DAT_00125caa)[lVar17 * 8]) {\n        lVar17 = lVar17 + 1;\n        if (lVar17 == 10) goto LAB_00119248;\n      }\n      ppuVar29 = &PTR_s_native_00125ca0;\n      cVar8 = (&DAT_00125ca8)[lVar17 * 0x10];\n      DAT_00126474 = (short)lVar30;\n    }\n    else {\n      unaff_R13 = (char *)0x0;\n      while( true ) {\n        iVar11 = strcmp((char *)pFVar21,(&PTR_s_native_00125ca0)[(long)unaff_R13 * 2]);\n        if (iVar11 == 0) break;\n        unaff_R13 = (char *)((long)(int *)unaff_R13 + 1);\n        if ((FILE *)unaff_R13 == (FILE *)0xa) goto LAB_00119248;\n      }\n      ppuVar29 = &PTR_s_native_00125ca0 + (long)unaff_R13 * 2;\n      DAT_00126474 = (&DAT_00125caa)[(long)unaff_R13 * 8];\n      cVar8 = (&DAT_00125ca8)[(long)unaff_R13 * 0x10];\n    }\n    if (cVar8 == -1) {\nLAB_00119248:\n      uVar24 = dcgettext(0,\"unknown PE subsystem: %s\",5);\n                    \n      print_error_and_exit_00119dd0(uVar24,pFVar14);\n    }\n    if (cVar8 != '\\0') {\n      if (DAT_001264a8 == -1) {\n        DAT_001264a8 = 0x200;\n      }\n      if (DAT_00126488 == -1) {\n        DAT_00126488 = 0x1000;\n      }\n    }\n    unaff_R12 = pFVar14;\n    if (pFVar14 != pFVar21) {\n      free(pFVar21);\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd6:\n    DAT_001279b8 = extract_parameter_values_00114c80(_optarg,DAT_001279b8,\"--update-section\");\n    read_and_allocate_file_00114d60(DAT_001279b8);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd7:\n    _VerilogDataWidth = check_and_print_error_00119940(_optarg,\"--verilog-data-width\");\n    if ((0x10 < _VerilogDataWidth) || ((0x10116UL >> ((byte)_VerilogDataWidth & 0x3f) & 1) == 0)) {\n      pcVar32 = \"error: verilog data width must be 1, 2, 4, 8 or 16\";\n      goto LAB_00117aed;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd8:\n    DAT_001279c8 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd9:\n    load_and_parse_file_00114460(_optarg,DAT_001279d0,&DAT_00127918);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xda:\n    DAT_001278f0 = DAT_001278f0 | 0x80;\n    DAT_001278f4 = DAT_001278f4 & 0xffffff7f;\n    goto switchD_00117234_caseD_0;\n  }\nLAB_001176c2:\n  uVar24 = dcgettext(0,pcVar32,5);\n                    \n  print_error_and_exit_00119dd0(uVar24,pFVar14);\n}\n\n",
            "called": [
                "setlocale",
                "strncpy",
                "FUN_001054af",
                "FUN_00119940",
                "strcasecmp",
                "htab_create_alloc",
                "fopen",
                "FUN_00114cf0",
                "FUN_00114d60",
                "__errno_location",
                "FUN_00108800",
                "strchr",
                "FUN_00114c20",
                "FUN_00108d9a",
                "strerror",
                "textdomain",
                "FUN_001126c0",
                "FUN_00114190",
                "FUN_0011a480",
                "FUN_00114c80",
                "xexit",
                "strcmp",
                "FUN_00113fb0",
                "FUN_00114460",
                "strlen",
                "fprintf",
                "FUN_00108c86",
                "htab_elements",
                "FUN_00108a2a",
                "FUN_00113fe0",
                "xstrdup",
                "unlink_if_ordinary",
                "memcpy",
                "FUN_00114690",
                "strtoul",
                "xcalloc",
                "FUN_00119970",
                "stat",
                "bfd_set_error_program_name",
                "getc",
                "FUN_00113f50",
                "close",
                "free",
                "xmalloc",
                "bfd_set_default_target",
                "malloc",
                "htab_find_slot",
                "FUN_00108916",
                "strncasecmp",
                "memmove",
                "fclose",
                "ftell",
                "xrealloc",
                "FUN_00113f20",
                "getopt_long",
                "FUN_00119ed0",
                "FUN_001199d0",
                "strcpy",
                "FUN_00119dd0",
                "ferror",
                "bfd_errmsg",
                "dcgettext",
                "FUN_00115970",
                "mkstemp",
                "xmalloc_set_program_name",
                "bfd_init",
                "strtol",
                "dup",
                "bfd_scan_arch",
                "bindtextdomain",
                "free",
                "FUN_00108898",
                "FUN_0011a390",
                "filename_cmp",
                "bfd_get_error",
                "fread",
                "fseek"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00116b90",
            "calling": [
                "entry"
            ],
            "imported": false,
            "current_name": "FUNC_00116b90"
        },
        "FUN_0010be88": {
            "renaming": {
                "FUN_0010be88": "start_debug_block_0010be88",
                "param_1": "blockAddress",
                "param_2": "param1",
                "param_3": "param2",
                "param_4": "param3",
                "puVar1": "currentPointer",
                "uVar2": "result",
                "puVar3": "allocatedMemory",
                "puVar4": "tempPointer",
                "lVar5": "tempValue",
                "puVar6": "lastPointer",
                "puVar7": "allocatedMemoryCopy",
                "bVar8": "flag",
                "auVar9": "returnValue"
            },
            "code": "\n\n\nundefined  [16] startDebugBlock_0010be88(long blockAddress,undefined8 param1,undefined8 param2,undefined8 param3)\n\n{\n  undefined8 *currentPointer;\n  undefined8 result;\n  undefined4 *allocatedMemory;\n  undefined8 *tempPointer;\n  long tempValue;\n  undefined8 *lastPointer;\n  undefined4 *allocatedMemoryCopy;\n  byte flag;\n  undefined returnValue [16];\n  \n  flag = 0;\n  if ((*(long *)(blockAddress + 8) == 0) || (*(long *)(blockAddress + 0x20) == 0)) {\n    result = dcgettext(0,\"debug_start_block: no current block\",5);\n    fprintf(_stderr,\"%s\\n\",result);\n    result = 0;\n  }\n  else {\n    allocatedMemory = (undefined4 *)xmalloc(0x30);\n    allocatedMemoryCopy = allocatedMemory;\n    for (tempValue = 0xc; tempValue != 0; tempValue = tempValue + -1) {\n      *allocatedMemoryCopy = 0;\n      allocatedMemoryCopy = allocatedMemoryCopy + (ulong)flag * -2 + 1;\n    }\n    tempValue = *(long *)(blockAddress + 0x20);\n    *(undefined8 *)(allocatedMemory + 6) = param1;\n    *(undefined8 *)(allocatedMemory + 8) = 0xffffffffffffffff;\n    *(long *)(allocatedMemory + 2) = tempValue;\n    currentPointer = *(undefined8 **)(tempValue + 0x10);\n    lastPointer = (undefined8 *)(tempValue + 0x10);\n    while (tempPointer = currentPointer, tempPointer != (undefined8 *)0x0) {\n      lastPointer = tempPointer;\n      currentPointer = (undefined8 *)*tempPointer;\n    }\n    *lastPointer = allocatedMemory;\n    result = 1;\n    *(undefined4 **)(blockAddress + 0x20) = allocatedMemory;\n  }\n  returnValue._8_8_ = param3;\n  returnValue._0_8_ = result;\n  return returnValue;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010be88",
            "calling": [
                "FUN_0011173a",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "start_debug_block_0010be88"
        },
        "bfd_get_error": {
            "renaming": {},
            "code": "\nvoid bfd_get_error(void)\n\n{\n  bfd_get_error();\n  return;\n}\n\n",
            "called": [
                "bfd_get_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104370",
            "calling": [
                "FUN_0010554f",
                "FUN_0010e07c",
                "FUN_00115dc0",
                "FUN_0011378f",
                "FUN_001083b7",
                "FUN_0010e6a8",
                "FUN_00119f70",
                "FUN_0010dac0",
                "FUN_0011a110",
                "FUN_00116b90",
                "FUN_00114690",
                "FUN_001126c0",
                "FUN_0010e2f0"
            ],
            "imported": false,
            "current_name": "bfd_get_error"
        },
        "bfd_fdopenw": {
            "renaming": {},
            "code": "\nvoid bfd_fdopenw(void)\n\n{\n  bfd_fdopenw();\n  return;\n}\n\n",
            "called": [
                "bfd_fdopenw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048d0",
            "calling": [
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "bfd_fdopenw"
        },
        "FUN_0010ba08": {
            "renaming": {
                "FUN_0010ba08": "generate_warning_message_0010ba08",
                "param_1": "paramList",
                "param_2": "fieldName",
                "param_3": "param3",
                "param_4": "fieldSize",
                "param_5": "flag",
                "cVar1": "charFlag",
                "iVar2": "intVar",
                "lVar3": "longVar",
                "__s": "listItem",
                "sVar4": "param2Len",
                "sVar5": "fieldNameLen",
                "sVar6": "listItemLen",
                "__s_00": "mallocedString",
                "uVar7": "warningText",
                "uVar8": "returnValue",
                "pcVar9": "flagString"
            },
            "code": "\nundefined8\ngenerateWarningMessage_0010ba08(undefined8 *paramList,char *fieldName,undefined8 param3,ulong fieldSize,int flag)\n\n{\n  char charFlag;\n  int intVar;\n  long longVar;\n  char *listItem;\n  size_t param2Len;\n  size_t fieldNameLen;\n  size_t listItemLen;\n  char *mallocedString;\n  undefined8 warningText;\n  undefined8 returnValue;\n  char *flagString;\n  \n  charFlag = *(char *)(paramList[0xc] + 0x1c);\n  intVar = *(int *)(paramList[0xc] + 0x18);\n  listItem = (char *)extract_list_item_00109b2f();\n  if (*(char **)(paramList[0xc] + 0x20) == (char *)0x0) {\n    returnValue = 0;\n  }\n  else {\n    param2Len = strlen(*(char **)(paramList[0xc] + 0x20));\n    fieldNameLen = strlen(fieldName);\n    listItemLen = strlen(listItem);\n    mallocedString = (char *)xmalloc(param2Len + 0x32 + fieldNameLen + listItemLen);\n    if (flag == 1) {\n      flagString = \"/1\";\n    }\n    else {\n      flagString = \"/0\";\n      if ((flag != 2) && (flagString = \"\", flag != 0)) {\n                    \n        abort();\n      }\n    }\n    if ((fieldSize == 0) && (fieldSize = (ulong)(uint)(intVar * 8), fieldSize == 0)) {\n      returnValue = *(undefined8 *)*paramList;\n      warningText = dcgettext(0,\"%s: warning: unknown size for field `%s\\' in struct\",5);\n      print_error_message_00119ed0(warningText,returnValue,fieldName);\n    }\n    sprintf(mallocedString,\"%s%s:%s%s,%ld,%ld;\",*(undefined8 *)(paramList[0xc] + 0x20),fieldName,flagString,listItem,\n            param3,fieldSize);\n    free(*(void **)(paramList[0xc] + 0x20));\n    longVar = paramList[0xc];\n    *(char **)(longVar + 0x20) = mallocedString;\n    if (charFlag != '\\0') {\n      *(undefined *)(longVar + 0x1c) = 1;\n    }\n    returnValue = CONCAT71((int7)((ulong)longVar >> 8),1);\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "abort",
                "strlen",
                "free",
                "dcgettext",
                "xmalloc",
                "FUN_00119ed0",
                "sprintf",
                "FUN_00109b2f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010ba08",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "generate_warning_message_0010ba08"
        },
        "FUN_0010aa53": {
            "renaming": {
                "FUN_0010aa53": "format_and_store_data_0010aa53",
                "param_1": "dataStructAddress",
                "param_2": "paramValue",
                "param_3": "charValue",
                "param_4": "condition",
                "cVar1": "charVar1",
                "lVar2": "dataStruct",
                "cVar3": "charVar2",
                "uVar4": "counter",
                "__s": "listItem",
                "sVar5": "listItemLength",
                "pcVar6": "formattedData",
                "lVar7": "newDataStruct",
                "uVar8": "returnValue",
                "uVar9": "tempCounter",
                "uVar10": "lastCounter"
            },
            "code": "\nundefined8 formatAndStoreData_0010aa53(long dataStructAddress,undefined8 paramValue,char charValue,int condition)\n\n{\n  char charVar1;\n  long dataStruct;\n  char charVar2;\n  uint counter;\n  char *listItem;\n  size_t listItemLength;\n  char *formattedData;\n  long newDataStruct;\n  undefined8 returnValue;\n  ulong tempCounter;\n  ulong lastCounter;\n  \n  charVar1 = *(char *)(*(long *)(dataStructAddress + 0x60) + 0x1c);\n  listItem = (char *)extract_list_item_00109b2f();\n  listItemLength = strlen(listItem);\n  formattedData = (char *)xmalloc(listItemLength + 0x19);\n  *formattedData = charValue + '0';\n  if (condition == 1) {\n    charVar2 = '1';\n  }\n  else {\n    charVar2 = '0';\n    if ((condition != 2) && (charVar2 = '2', condition != 0)) {\n                    \n      abort();\n    }\n  }\n  formattedData[1] = charVar2;\n  sprintf(formattedData + 2,\"%ld,%s;\",paramValue);\n  free(listItem);\n  dataStruct = *(long *)(dataStructAddress + 0x60);\n  returnValue = 0;\n  if ((dataStruct != 0) && (*(long *)(dataStruct + 0x20) != 0)) {\n    dataStruct = *(long *)(dataStruct + 0x28);\n    lastCounter = 0;\n    if (dataStruct != 0) {\n      counter = 0;\n      do {\n        tempCounter = (ulong)counter;\n        lastCounter = (ulong)counter;\n        counter = counter + 1;\n      } while (*(long *)(dataStruct + tempCounter * 8) != 0);\n    }\n    newDataStruct = xrealloc(dataStruct,(ulong)((int)lastCounter + 2) << 3);\n    *(char **)(newDataStruct + lastCounter * 8) = formattedData;\n    *(undefined8 *)(newDataStruct + (ulong)((int)lastCounter + 1) * 8) = 0;\n    dataStruct = *(long *)(dataStructAddress + 0x60);\n    *(long *)(dataStruct + 0x28) = newDataStruct;\n    if (charVar1 != '\\0') {\n      *(undefined *)(dataStruct + 0x1c) = 1;\n    }\n    returnValue = 1;\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "abort",
                "xrealloc",
                "strlen",
                "free",
                "xmalloc",
                "sprintf",
                "FUN_00109b2f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010aa53",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "format_and_store_data_0010aa53"
        },
        "FUN_0011173a": {
            "renaming": {
                "FUN_0011173a": "process_debug_info_0011173a",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6",
                "cVar1": "charVar1",
                "bVar2": "byteVar2",
                "__ptr": "ptr",
                "cVar3": "charVar3",
                "uVar4": "undefinedVar1",
                "iVar5": "intVar1",
                "puVar6": "ptrVar1",
                "plVar7": "ptrVar2",
                "pcVar8": "charPtr1",
                "uVar9": "undefinedVar2",
                "lVar10": "ptrValue1",
                "lVar11": "ptrValue2",
                "lVar12": "ptrValue3",
                "pplVar13": "ptrPtrVar1",
                "uVar14": "ulongVar1",
                "uVar15": "ulongVar2",
                "pcVar16": "charPtr2",
                "uVar17": "uintVar1",
                "dVar19": "doubleVar1",
                "local_48": "localCharPtr1",
                "local_40": "localPtrVar1"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0011244f) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nundefined processDebugInfo_0011173a(undefined8 param1,long *param2,int param3,int param4,ulong param5,\n                      char *param6)\n\n{\n  char charVar1;\n  byte byteVar2;\n  void *ptr;\n  char charVar3;\n  undefined undefinedVar1;\n  int intVar1;\n  undefined8 *ptrVar1;\n  long *ptrVar2;\n  char *charPtr1;\n  undefined8 undefinedVar2;\n  long ptrValue1;\n  long ptrValue2;\n  long ptrValue3;\n  long **ptrPtrVar1;\n  ulong ulongVar1;\n  ulong ulongVar2;\n  char *charPtr2;\n  uint uintVar1;\n  long **pplVar18;\n  double doubleVar1;\n  char *localCharPtr1;\n  long **localPtrVar1 [2];\n  \n  if (param2[4] != 0) {\n    if (((param3 == 100) && (*param6 != '\\0')) && (param2[5] == param5)) goto LAB_00111a06;\n    charVar3 = initialize_debug_info_0010bbd3(param1);\n    if (charVar3 == '\\0') {\n      return 0;\n    }\n    *(undefined *)((long)param2 + 0x44) = 0;\n    *(undefined4 *)(param2 + 8) = 0;\n    param2[9] = param2[4];\n    if (*(char *)(param2 + 1) == '\\0') {\n      param2[6] = param2[5];\n    }\n    *(undefined4 *)(param2 + 0x10) = 1;\n    ptrVar1 = (undefined8 *)xmalloc(8);\n    param2[0x11] = (long)ptrVar1;\n    *ptrVar1 = 0;\n    param2[4] = 0;\n  }\n  strlen(param6);\n  if (param3 == 0x84) {\nLAB_00111ab7:\n    undefinedVar1 = add_debug_source_file_00108f08(param1,param6);\n    return undefinedVar1;\n  }\n  if (param3 < 0x85) {\n    if (param3 == 0x3c) {\n      intVar1 = strcmp(param6,\"gcc2_compiled.\");\n      if (intVar1 == 0) {\n        *(undefined4 *)(param2 + 8) = 2;\n        return 1;\n      }\n      intVar1 = strcmp(param6,\"gcc_compiled.\");\n      if (intVar1 == 0) {\n        *(undefined4 *)(param2 + 8) = 1;\n        return 1;\n      }\n      *(undefined *)((long)param2 + 0x44) = 1;\n      return 1;\n    }\n    if (param3 < 0x3d) {\n      if (param3 == 0x24) {\n        if (*param6 == '\\0') {\n          if (*(char *)(param2 + 0xc) == '\\0') {\n            return 1;\n          }\n          if (*(char *)(param2 + 1) != '\\0') {\n            param5 = param5 + param2[7];\n          }\n          charVar3 = clear_pointer_chain_0010c1c6(param1,param2);\n          if (charVar3 != '\\0') {\n            charVar3 = end_debugging_function_0010be1a(param1,param5);\n            if (charVar3 != '\\0') {\n              *(undefined *)(param2 + 0xc) = 0;\n              param2[0xd] = -1;\n              return 1;\n            }\n            return 0;\n          }\n          return 0;\n        }\n        if ((*(char *)(param2 + 0xc) != '\\0') &&\n           ((param5 < (ulong)param2[0xd] || (param2[0xd] == 0xffffffffffffffff)))) {\n          param2[0xd] = param5;\n        }\n      }\n      else if (param3 < 0x25) {\n        if (param3 == 0xc) {\n          return 1;\n        }\n        if (param3 - 0x1eU < 2) {\n          return 1;\n        }\n      }\n      else {\n        if (param3 == 0x2a) {\n          return 1;\n        }\n        if (param3 == 0x38) {\n          return 1;\n        }\n      }\n    }\n    else {\n      if (param3 == 100) {\nLAB_00111a06:\n        if (*(char *)(param2 + 0xc) != '\\0') {\n          ulongVar1 = param5;\n          if (((*param6 != '\\0') && (ulongVar2 = param2[0xd], ulongVar2 != 0xffffffffffffffff)) &&\n             (ulongVar1 = ulongVar2, param5 < ulongVar2)) {\n            ulongVar1 = param5;\n          }\n          charVar3 = clear_pointer_chain_0010c1c6(param1,param2);\n          if (charVar3 == '\\0') {\n            return 0;\n          }\n          charVar3 = end_debugging_function_0010be1a(param1,ulongVar1);\n          if (charVar3 == '\\0') {\n            return 0;\n          }\n          *(undefined *)(param2 + 0xc) = 0;\n          param2[0xd] = -1;\n        }\n        if (*param6 == '\\0') {\n          return 1;\n        }\n        ptr = (void *)param2[4];\n        if (ptr == (void *)0x0) {\n          ptrValue3 = xstrdup(param6);\n          param2[4] = ptrValue3;\n        }\n        else {\n          if (*param6 == '/') {\n            ptrValue3 = xstrdup(param6);\n          }\n          else {\n            ptrValue3 = concat(ptr,param6,0);\n          }\n          param2[4] = ptrValue3;\n          free(ptr);\n        }\n        param2[5] = param5;\n        return 1;\n      }\n      if (param3 < 0x65) {\n        if (param3 == 0x44) {\n          ptrValue3 = 0;\n          if (*(char *)(param2 + 0xc) != '\\0') {\n            ptrValue3 = param2[7];\n          }\n          undefinedVar1 = record_line_info_0010bf86(param1,(long)param4,ptrValue3 + param5);\n          return undefinedVar1;\n        }\n        if (param3 == 0x62) {\n          return 1;\n        }\n      }\n      else if (param3 == 0x82) {\n        ptrVar2 = (long *)xmalloc();\n        intVar1 = *(int *)(param2 + 0x10);\n        ptrValue1 = param2[10];\n        ptrValue2 = param2[0xb];\n        ptrVar2[5] = 0;\n        ptrValue3 = param2[0x11];\n        *(int *)(ptrVar2 + 4) = intVar1;\n        uintVar1 = intVar1 + 1;\n        *(uint *)(param2 + 0x10) = uintVar1;\n        *ptrVar2 = ptrValue2;\n        ptrVar2[1] = ptrValue1;\n        ptrVar2[2] = (long)param6;\n        ptrVar2[3] = param5;\n        param2[10] = (long)ptrVar2;\n        param2[0xb] = (long)ptrVar2;\n        ptrValue3 = xrealloc(ptrValue3,(ulong)uintVar1 << 3);\n        uintVar1 = *(uint *)(ptrVar2 + 4);\n        param2[0x11] = ptrValue3;\n        *(undefined8 *)(ptrValue3 + (ulong)uintVar1 * 8) = 0;\n        goto LAB_00111ab7;\n      }\n    }\nLAB_00111c29:\n    charPtr1 = strchr(param6,0x3a);\n    if ((charPtr1 != (char *)0x0) && ((charPtr1[1] & 0xdfU) == 0x46)) {\n      if (*(char *)(param2 + 0xc) != '\\0') {\n        ulongVar1 = param2[0xd];\n        ulongVar2 = param5;\n        if ((ulongVar1 != 0xffffffffffffffff) && (ulongVar2 = ulongVar1, param5 < ulongVar1)) {\n          ulongVar2 = param5;\n        }\n        charVar3 = clear_pointer_chain_0010c1c6(param1,param2);\n        if (charVar3 == '\\0') {\n          return 0;\n        }\n        charVar3 = end_debugging_function_0010be1a(param1,ulongVar2);\n        if (charVar3 == '\\0') {\n          return 0;\n        }\n        param2[0xd] = -1;\n      }\n      if (*(char *)(param2 + 1) != '\\0') {\n        param2[7] = param5;\n      }\n      *(undefined *)(param2 + 0xc) = 1;\n    }\n    localCharPtr1 = strchr(param6,0x3a);\n    if (localCharPtr1 == (char *)0x0) {\n      return 1;\n    }\nLAB_00111cbc:\n    if (localCharPtr1[1] == ':') goto code_r0x00111cc7;\n    if (*param6 == '$') {\n      charVar3 = param6[1];\n      charPtr2 = \"eh_throw\";\n      if (charVar3 != 'e') {\n        if (charVar3 < 'f') {\n          if ((charVar3 != 'X') && (charVar3 != '_')) {\nLAB_00111d1a:\n            undefinedVar2 = dcgettext(0,\"unknown C++ encoded name\",5);\n            print_warning_00108fe8(param6,undefinedVar2);\n          }\n        }\n        else {\n          charPtr2 = \"this\";\n          if (charVar3 == 't') goto LAB_00111d62;\n          if (charVar3 != 'v') goto LAB_00111d1a;\n        }\n        goto LAB_00111d38;\n      }\n    }\n    else {\nLAB_00111d38:\n      charPtr2 = (char *)0x0;\n      if ((param6 != localCharPtr1) && ((*param6 != ' ' || (localCharPtr1 != param6 + 1)))) {\n        charPtr2 = (char *)copy_and_null_terminate_00109a0b(param6,(int)localCharPtr1 - (int)param6);\n      }\n    }\nLAB_00111d62:\n    byteVar2 = localCharPtr1[1];\n    charPtr1 = localCharPtr1 + 1;\n    if (((byte)(*(ushort *)(&_sch_istable + (ulong)byteVar2 * 2) >> 2) & 1 |\n        (byteVar2 == 0x2d || byteVar2 == 0x28)) != 0) {\nswitchD_00111de5_caseD_58:\n      localCharPtr1 = charPtr1;\n      ptrValue3 = FUNC_0010ee3f(param1,param2,0,&localCharPtr1,0);\n      if (ptrValue3 == 0) {\n        return 0;\n      }\n      undefinedVar2 = 4;\n      goto LAB_001123e8;\n    }\n    if (byteVar2 == 0) goto switchD_00111de5_caseD_44;\n    charPtr1 = localCharPtr1 + 2;\n    charVar3 = localCharPtr1[1];\n    switch(charVar3) {\n    case 'C':\n      localCharPtr1 = charPtr1;\n      ptrValue3 = FUNC_0010ee3f(param1,param2,0,&localCharPtr1,0);\n      charPtr1 = \"debug_record_label: not implemented\";\n      if (ptrValue3 == 0) {\n        return 0;\n      }\n      goto LAB_00111b96;\n    default:\n      goto switchD_00111de5_caseD_44;\n    case 'F':\n    case 'f':\n      localCharPtr1 = charPtr1;\n      ptrValue3 = FUNC_0010ee3f(param1,param2,0,&localCharPtr1,0);\n      if (ptrValue3 == 0) {\n        return 0;\n      }\n      charVar3 = initialize_debug_record_0010bc80(param1,charPtr2,ptrValue3,charVar3 == 'F',param5);\n      if (charVar3 != '\\0') {\n        do {\n          if (*localCharPtr1 != ';') {\n            return 1;\n          }\n          localCharPtr1 = localCharPtr1 + 1;\n          ptrValue3 = FUNC_0010ee3f(param1,param2,0,&localCharPtr1,0);\n        } while (ptrValue3 != 0);\n        return 0;\n      }\n      return 0;\n    case 'G':\n      localCharPtr1 = charPtr1;\n      ptrValue3 = FUNC_0010ee3f(param1,param2,0,&localCharPtr1,0);\n      if (ptrValue3 == 0) {\n        return 0;\n      }\n      if (charPtr2 == (char *)0x0) goto LAB_0011208f;\n      ptrValue1 = param2[3];\n      ptrVar2 = (long *)param2[2];\n      charVar3 = *(char *)(*(long *)(*param2 + 8) + 0x1c);\n      goto LAB_00112045;\n    case 'P':\n      if (param3 == 0x24) {\n        localCharPtr1 = charPtr1;\n        do {\n          if (*localCharPtr1 != ';') {\n            return 1;\n          }\n          localCharPtr1 = localCharPtr1 + 1;\n          ptrValue3 = FUNC_0010ee3f(param1,param2,0,&localCharPtr1,0);\n        } while (ptrValue3 != 0);\n        return 0;\n      }\n    case 'R':\n      localCharPtr1 = charPtr1;\n      ptrValue3 = FUNC_0010ee3f(param1,param2,0,&localCharPtr1,0);\n      if (ptrValue3 == 0) {\n        return 0;\n      }\n      undefinedVar2 = 2;\n      break;\n    case 'S':\n      localCharPtr1 = charPtr1;\n      ptrValue3 = FUNC_0010ee3f(param1,param2,0,&localCharPtr1,0);\n      if (ptrValue3 == 0) {\n        return 0;\n      }\n      undefinedVar2 = 2;\n      goto LAB_001121c4;\n    case 'T':\n      charVar3 = localCharPtr1[2];\n      if (charVar3 == 't') {\n        charPtr1 = localCharPtr1 + 3;\n      }\n      localCharPtr1 = charPtr1;\n      ptrValue3 = FUNC_0010ee3f(param1,param2,charPtr2,&localCharPtr1,localPtrVar1);\n      if (ptrValue3 == 0) {\n        return 0;\n      }\n      if (charPtr2 == (char *)0x0) {\n        return 1;\n      }\n      charVar1 = *(char *)(param2 + 0x35);\n      ptrVar2 = (long *)process_debug_tag_0010c6be(param1,charPtr2,ptrValue3);\n      if (ptrVar2 == (long *)0x0) {\n        return 0;\n      }\n      if (localPtrVar1[0] != (long **)0x0) {\n        *localPtrVar1[0] = ptrVar2;\n      }\n      if (charVar1 != '\\0') goto LAB_001122f0;\n      ptrPtrVar1 = (long **)(param2 + 0x34);\n      pplVar18 = (long **)param2[0x34];\n      goto LAB_001122b2;\n    case 'V':\n      localCharPtr1 = charPtr1;\n      ptrValue3 = FUNC_0010ee3f(param1,param2,0,&localCharPtr1,0);\n      if (ptrValue3 == 0) {\n        return 0;\n      }\n      undefinedVar2 = 3;\n      goto LAB_001123e8;\n    case 'X':\n    case 'l':\n    case 's':\n      goto switchD_00111de5_caseD_58;\n    case 'Y':\n      charPtr1 = localCharPtr1 + 3;\n      if (((localCharPtr1[2] != '\\0') && (charPtr1 = localCharPtr1 + 4, localCharPtr1[3] == 'n')) &&\n         (charPtr1 = localCharPtr1 + 5, charPtr2 = localCharPtr1 + 4, localCharPtr1 = charPtr1, *charPtr2 == '0')) {\n        for (; charPtr1 = localCharPtr1, *localCharPtr1 != '\\0'; localCharPtr1 = localCharPtr1 + 1) {\n          if (*localCharPtr1 == ';') {\n            return 1;\n          }\n        }\n      }\n      goto switchD_00111de5_caseD_44;\n    case 'a':\n      localCharPtr1 = charPtr1;\n      ptrValue3 = FUNC_0010ee3f(param1,param2,0,&localCharPtr1,0);\n      if (ptrValue3 == 0) {\n        return 0;\n      }\n      undefinedVar2 = 4;\n      break;\n    case 'c':\n      if (localCharPtr1[2] == '=') {\n        charPtr1 = localCharPtr1 + 4;\n        charVar3 = localCharPtr1[3];\n        localCharPtr1 = charPtr1;\n        if (charVar3 == 'i') {\n          ptrValue3 = strtol(charPtr1,(char **)0x0,10);\n          if (charPtr2 == (char *)0x0) {\n            return 0;\n          }\n          ptrValue1 = initialize_data_structure_00112996(param1,charPtr2,4);\n          if (ptrValue1 != 0) {\n            *(long *)(ptrValue1 + 0x20) = (long)(int)ptrValue3;\n            return 1;\n          }\n          return 0;\n        }\n        if (charVar3 == 'r') {\n          doubleVar1 = strtod(charPtr1,(char **)0x0);\n          if (charPtr2 == (char *)0x0) {\n            return 0;\n          }\n          ptrValue3 = initialize_data_structure_00112996(param1,charPtr2,5);\n          if (ptrValue3 != 0) {\n            *(double *)(ptrValue3 + 0x20) = doubleVar1;\n            return 1;\n          }\n          return 0;\n        }\n        if (charVar3 == 'e') {\n          ptrValue3 = FUNC_0010ee3f(param1,param2,0,&localCharPtr1,0);\n          if (ptrValue3 == 0) {\n            return 0;\n          }\n          charPtr1 = localCharPtr1;\n          if (*localCharPtr1 == ',') {\n            ptrValue1 = strtol(localCharPtr1,(char **)0x0,10);\n            if (charPtr2 == (char *)0x0) {\n              return 0;\n            }\n            ptrValue2 = initialize_data_structure_00112996(param1,charPtr2,6);\n            if (ptrValue2 != 0) {\n              ptrVar2 = (long *)xmalloc(0x10);\n              *ptrVar2 = ptrValue3;\n              ptrVar2[1] = (long)(int)ptrValue1;\n              *(long **)(ptrValue2 + 0x20) = ptrVar2;\n              return 1;\n            }\n            return 0;\n          }\n        }\n      }\n      goto switchD_00111de5_caseD_44;\n    case 'p':\n      if (localCharPtr1[2] == 'F') {\n        localCharPtr1 = localCharPtr1 + 3;\n        ptrValue3 = FUNC_0010ee3f(param1,param2,0,&localCharPtr1,0);\n        if (ptrValue3 == 0) {\n          return 0;\n        }\n        undefinedVar2 = initialize_and_store_data_00113ce0(ptrValue3,0,0);\n        ptrValue3 = initialize_data_00113d3a(undefinedVar2);\n      }\n      else {\n        localCharPtr1 = charPtr1;\n        ptrValue3 = FUNC_0010ee3f(param1,param2,0,&localCharPtr1,0);\n      }\n      if (ptrValue3 == 0) {\n        return 0;\n      }\n      undefinedVar2 = 1;\n      break;\n    case 'r':\n      localCharPtr1 = charPtr1;\n      ptrValue3 = FUNC_0010ee3f(param1,param2,0,&localCharPtr1,0);\n      if (ptrValue3 == 0) {\n        return 0;\n      }\n      undefinedVar2 = 5;\nLAB_001123e8:\n      charVar3 = update_variable_data_0010c139(param1,param2,charPtr2,ptrValue3,undefinedVar2,param5);\n      goto joined_r0x001123f8;\n    case 't':\n      localCharPtr1 = charPtr1;\n      ptrValue3 = FUNC_0010ee3f(param1,param2,charPtr2,&localCharPtr1,localPtrVar1);\n      if (ptrValue3 == 0) {\n        return 0;\n      }\n      if (charPtr2 == (char *)0x0) {\n        return 1;\n      }\n      ptrVar2 = (long *)initialize_data_structure_0010c218(param1,charPtr2,ptrValue3);\n      if (ptrVar2 == (long *)0x0) {\n        return 0;\n      }\n      if (localPtrVar1[0] == (long **)0x0) {\n        return 1;\n      }\n      *localPtrVar1[0] = ptrVar2;\n      return 1;\n    case 'v':\n      localCharPtr1 = charPtr1;\n      ptrValue3 = FUNC_0010ee3f(param1,param2,0,&localCharPtr1,0);\n      if (ptrValue3 == 0) {\n        return 0;\n      }\n      undefinedVar2 = 3;\n    }\n    charVar3 = record_parameter_0010bd62(param1,charPtr2,ptrValue3,undefinedVar2,param5);\n    goto joined_r0x001123f8;\n  }\n  if (param3 == 0xe0) {\n    if ((*(char *)((long)param2 + 0x44) != '\\0') && (param4 == 1)) {\n      return 1;\n    }\n    charVar3 = clear_pointer_chain_0010c1c6(param1,param2);\n    if (charVar3 == '\\0') {\n      return 0;\n    }\n    charVar3 = debug_end_block_check_0010bf20(param1,param2[7] + param2[6] + param5);\n    if (charVar3 == '\\0') {\n      return 0;\n    }\n    param2 = param2 + 0xe;\n    *(int *)param2 = *(int *)param2 + -1;\n    charPtr1 = \"Too many N_RBRACs\\n\";\n    if (-1 < *(int *)param2) {\n      return 1;\n    }\n  }\n  else {\n    if (0xe0 < param3) {\n      if (param3 == 0xe2) {\n        charPtr1 = \"debug_start_common_block: not implemented\";\n      }\n      else {\n        charPtr1 = \"debug_end_common_block: not implemented\";\n        if (param3 != 0xe4) goto LAB_00111c29;\n      }\nLAB_00111b96:\n      undefinedVar2 = dcgettext(0,charPtr1,5);\n      fprintf(_stderr,\"%s\\n\",undefinedVar2);\n      return 0;\n    }\n    if (param3 != 0xc0) {\n      if (param3 == 0xc2) {\n        intVar1 = *(int *)(param2 + 0x10);\n        *(uint *)(param2 + 0x10) = intVar1 + 1U;\n        ptrValue3 = xrealloc(param2[0x11],(ulong)(intVar1 + 1U) << 3);\n        ptrVar1 = (undefined8 *)param2[0xb];\n        param2[0x11] = ptrValue3;\n        while( true ) {\n          if (ptrVar1 == (undefined8 *)0x0) {\n            undefinedVar2 = dcgettext(0,\"Undefined N_EXCL\",5);\n            print_warning_00108fe8(param6,undefinedVar2);\n            *(undefined8 *)(param2[0x11] + (ulong)(*(int *)(param2 + 0x10) - 1) * 8) = 0;\n            return 1;\n          }\n          if ((param5 == ptrVar1[3]) && (intVar1 = strcmp((char *)ptrVar1[2],param6), intVar1 == 0))\n          break;\n          ptrVar1 = (undefined8 *)*ptrVar1;\n        }\n        *(undefined8 *)(ptrValue3 + (ulong)(*(int *)(param2 + 0x10) - 1) * 8) = ptrVar1[5];\n        return 1;\n      }\n      if (param3 == 0xa2) {\n        ptrValue3 = param2[10];\n        if (ptrValue3 != 0) {\n          ptrValue1 = *(long *)(ptrValue3 + 8);\n          uintVar1 = *(uint *)(ptrValue3 + 0x20);\n          param2[10] = ptrValue1;\n          if ((uintVar1 < *(uint *)(param2 + 0x10)) &&\n             (*(undefined8 *)(ptrValue3 + 0x28) = *(undefined8 *)(param2[0x11] + (ulong)uintVar1 * 8),\n             ptrValue1 != 0)) {\n            param6 = *(char **)(ptrValue1 + 0x10);\n            goto LAB_00111ab7;\n          }\n        }\n        param6 = (char *)param2[9];\n        goto LAB_00111ab7;\n      }\n      goto LAB_00111c29;\n    }\n    if ((*(char *)((long)param2 + 0x44) != '\\0') && (param4 == 1)) {\n      return 1;\n    }\n    if (*(char *)(param2 + 0xc) != '\\0') {\n      charVar3 = start_debug_block_0010be88(param1,param2[7] + param2[6] + param5);\n      if (charVar3 == '\\0') {\n        return 0;\n      }\n      charVar3 = clear_pointer_chain_0010c1c6(param1,param2);\n      if (charVar3 != '\\0') {\n        *(int *)(param2 + 0xe) = *(int *)(param2 + 0xe) + 1;\n        return 1;\n      }\n      return 0;\n    }\n    charPtr1 = \"N_LBRAC not within function\\n\";\n  }\n  charPtr1 = (char *)dcgettext(0,charPtr1,5);\n  fprintf(_stderr,charPtr1);\n  return 0;\ncode_r0x00111cc7:\n  localCharPtr1 = localCharPtr1 + 2;\n  localCharPtr1 = strchr(localCharPtr1,0x3a);\n  if (localCharPtr1 == (char *)0x0) {\n    charPtr1 = (char *)0x0;\nswitchD_00111de5_caseD_44:\n    localCharPtr1 = charPtr1;\n    print_bad_stab_00108fb9(param6);\n    return 0;\n  }\n  goto LAB_00111cbc;\nLAB_001122b2:\n  if (pplVar18 == (long **)0x0) {\nLAB_001122f0:\n    if (charVar3 != 't') {\n      return 1;\n    }\n    ptrVar2 = (long *)initialize_data_structure_0010c218(param1,charPtr2,ptrVar2);\n    if (ptrVar2 != (long *)0x0) {\n      if (localPtrVar1[0] == (long **)0x0) {\n        return 1;\n      }\n      *localPtrVar1[0] = ptrVar2;\n      return 1;\n    }\n    return 0;\n  }\n  if ((*(char *)pplVar18[1] == *charPtr2) &&\n     (intVar1 = strcmp((char *)pplVar18[1],charPtr2), intVar1 == 0)) {\n    pplVar18[3] = ptrVar2;\n    *ptrPtrVar1 = *pplVar18;\n    goto LAB_001122f0;\n  }\n  ptrPtrVar1 = pplVar18;\n  pplVar18 = (long **)*pplVar18;\n  goto LAB_001122b2;\nLAB_00112045:\n  if (ptrValue1 < 1) {\nLAB_0011208f:\n    undefinedVar2 = 1;\nLAB_001121c4:\n    charVar3 = record_variable_data_0010c05d(param1,charPtr2,ptrValue3,undefinedVar2,param5);\njoined_r0x001123f8:\n    if (charVar3 != '\\0') {\n      return 1;\n    }\n    return 0;\n  }\n  charPtr1 = *(char **)(*ptrVar2 + 8);\n  if ((charVar3 != '\\0') && (charVar3 == *charPtr1)) {\n    charPtr1 = charPtr1 + 1;\n  }\n  if ((*charPtr1 == *charPtr2) && (intVar1 = strcmp(charPtr1,charPtr2), intVar1 == 0)) {\n    param5 = *(long *)(*ptrVar2 + 0x10) + *(long *)(*(long *)(*ptrVar2 + 0x20) + 0x30);\n    goto LAB_0011208f;\n  }\n  ptrValue1 = ptrValue1 + -1;\n  ptrVar2 = ptrVar2 + 1;\n  goto LAB_00112045;\n}\n\n",
            "called": [
                "strtod",
                "FUN_0010be88",
                "FUN_00108fe8",
                "FUN_0010bbd3",
                "FUN_0010bf86",
                "FUN_00113d3a",
                "xmalloc",
                "FUN_00112996",
                "FUN_0010bf20",
                "xrealloc",
                "strchr",
                "FUN_0010c1c6",
                "concat",
                "FUN_0010c05d",
                "strcmp",
                "FUN_00108f08",
                "strlen",
                "fprintf",
                "dcgettext",
                "FUN_00113ce0",
                "FUN_0010be1a",
                "FUN_00108fb9",
                "FUN_0010c139",
                "strtol",
                "FUN_00109a0b",
                "xstrdup",
                "FUN_0010c218",
                "FUN_0010ee3f",
                "free",
                "FUN_0010c6be",
                "FUN_0010bd62",
                "FUN_0010bc80"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011173a",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "process_debug_info_0011173a"
        },
        "FUN_00115dc0": {
            "renaming": {
                "FUN_00115dc0": "process_section_data_00115dc0",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "cVar1": "sectionDataCheck",
                "iVar2": "errorCode",
                "uVar3": "result",
                "lVar4": "relocUpperBound",
                "puVar5": "relocArray",
                "uVar6": "relocCount",
                "UNRECOVERED_JUMPTABLE": "jumptable",
                "puVar7": "newRelocArray",
                "puVar8": "currentReloc",
                "uVar9": "currentRelocIndex",
                "uStack_38": "stackVar"
            },
            "code": "\nvoid processSectionData_00115dc0(undefined8 param1,undefined8 *param2,long param3)\n\n{\n  char sectionDataCheck;\n  int errorCode;\n  undefined8 result;\n  long relocUpperBound;\n  undefined8 *relocArray;\n  ulong relocCount;\n  code *jumptable;\n  undefined8 *newRelocArray;\n  undefined8 *currentReloc;\n  ulong currentRelocIndex;\n  undefined8 stackVar;\n  \n  sectionDataCheck = check_section_data_00115f50(param1,param2,0);\n  if (sectionDataCheck != '\\0') {\n    return;\n  }\n  result = param2[0xc];\n  if ((((*(byte *)(param3 + 0x48) & 7) != 3) && (DAT_00127a2c != 6)) &&\n     (relocUpperBound = parse_rules_00114190(*param2,0,0x100), relocUpperBound == 0)) {\n    relocUpperBound = bfd_get_reloc_upper_bound(param1,param2);\n    if (relocUpperBound < 0) {\n      if ((relocUpperBound != -1) || (errorCode = bfd_get_error(), errorCode != 5)) {\n        DAT_00127a20 = 1;\n        result = 0;\nLAB_00108315:\n        display_error_001126c0(0,param1,param2,result,stackVar);\n        return;\n      }\n    }\n    else if (relocUpperBound != 0) {\n      relocArray = (undefined8 *)param2[0xe];\n      if (relocArray == (undefined8 *)0x0) {\n        relocArray = (undefined8 *)bfd_alloc(param3);\n        if (relocArray == (undefined8 *)0x0) {\n          print_error_message_0011a110(0);\n                    \n          xexit(1);\n        }\n        relocCount = bfd_canonicalize_reloc(param1,param2,relocArray,DAT_001278b0);\n        if ((long)relocCount < 0) {\n          DAT_00127a20 = 1;\n          result = dcgettext(0,\"relocation count is negative\",5);\n          goto LAB_00108315;\n        }\n      }\n      else {\n        relocCount = (ulong)*(uint *)(param2 + 0xf);\n      }\n      if (DAT_00127a2c == 7) {\n        newRelocArray = relocArray;\n        for (currentRelocIndex = 0; currentRelocIndex != relocCount; currentRelocIndex = currentRelocIndex + 1) {\n          currentReloc = newRelocArray;\n          if (((*(long **)relocArray[currentRelocIndex] != (long *)0x0) &&\n              (relocUpperBound = **(long **)relocArray[currentRelocIndex], relocUpperBound != 0)) &&\n             (sectionDataCheck = find_value_00115d70(*(undefined8 *)(relocUpperBound + 8),DAT_00127a08), sectionDataCheck != '\\0')) {\n            currentReloc = newRelocArray + 1;\n            *newRelocArray = relocArray[currentRelocIndex];\n          }\n          newRelocArray = currentReloc;\n        }\n        *newRelocArray = 0;\n        relocCount = (long)newRelocArray - (long)relocArray >> 3;\n      }\n      jumptable = *(code **)(*(long *)(param3 + 8) + 0x288);\n      if (relocCount == 0) {\n        relocCount = 0;\n        relocArray = (undefined8 *)0x0;\n      }\n      else {\n        relocCount = relocCount & 0xffffffff;\n      }\n      goto LAB_00115e9a;\n    }\n  }\n  relocCount = 0;\n  relocArray = (undefined8 *)0x0;\n  jumptable = *(code **)(*(long *)(param3 + 8) + 0x288);\nLAB_00115e9a:\n                    /* WARNING: Could not recover jumptable at 0x00115eae. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumptable)(param3,result,relocArray,relocCount);\n  return;\n}\n\n",
            "called": [
                "FUN_0011a110",
                "bfd_canonicalize_reloc",
                "FUN_001082df",
                "bfd_alloc",
                "dcgettext",
                "bfd_get_reloc_upper_bound",
                "bfd_get_error",
                "FUN_00115f50",
                "FUN_001126c0",
                "FUN_00114190",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115dc0",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "process_section_data_00115dc0"
        },
        "concat": {
            "renaming": {},
            "code": "\nvoid concat(void)\n\n{\n  concat();\n  return;\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104320",
            "calling": [
                "FUN_0011173a",
                "FUN_0010554f",
                "FUN_00104ea2",
                "FUN_0010ee3f",
                "FUN_0010d21c"
            ],
            "imported": false,
            "current_name": "concat"
        },
        "FUN_0010d559": {
            "renaming": {
                "FUN_0010d559": "parse_and_validate_input_0010d559",
                "param_1": "output_data",
                "param_2": "input_data",
                "param_3": "match_count",
                "bVar1": "first_byte",
                "pbVar2": "current_byte",
                "cVar3": "result",
                "uVar4": "parsed_integer",
                "iVar5": "comparison_result",
                "ppcVar6": "temporary_data",
                "sVar7": "string_length",
                "lVar8": "current_match",
                "plVar9": "data_pointers",
                "pcVar10": "extracted_string",
                "__s1": "binary_string",
                "__ptr": "copied_string",
                "pbVar11": "next_byte",
                "uVar12": "type_value",
                "local_64": "counter",
                "local_40": "match_strings"
            },
            "code": "\nundefined8 parse_and_validate_input_0010d559(undefined8 *output_data,byte **input_data,long *match_count)\n\n{\n  byte first_byte;\n  byte *current_byte;\n  char result;\n  uint parsed_integer;\n  int comparison_result;\n  char **temporary_data;\n  size_t string_length;\n  long current_match;\n  long *data_pointers;\n  char *extracted_string;\n  char *binary_string;\n  void *copied_string;\n  byte *next_byte;\n  undefined8 type_value;\n  byte *__nptr;\n  int counter;\n  char *match_strings [2];\n  \n  current_byte = *input_data;\n  first_byte = current_byte[1];\n  if ((char)first_byte < ':') {\n    if ((char)first_byte < '1') goto LAB_0010d5d8;\n    counter = (char)first_byte + -0x30;\n    if (current_byte[2] == 0x5f) {\n      *input_data = current_byte + 1;\n    }\n    next_byte = *input_data + 2;\n  }\n  else {\n    if (((first_byte != 0x5f) || (((&_sch_istable)[(ulong)current_byte[2] * 2] & 4) == 0)) ||\n       (current_byte[2] == 0x30)) goto LAB_0010d5d8;\n    __nptr = current_byte + 2;\n    current_match = strtol((char *)__nptr,(char **)0x0,10);\n    counter = (int)current_match;\n    while (((&_sch_istable)[(ulong)*__nptr * 2] & 4) != 0) {\n      __nptr = __nptr + 1;\n    }\n    next_byte = __nptr + 1;\n    if (*__nptr != 0x5f) goto LAB_0010d5d8;\n  }\n  *input_data = next_byte;\n  temporary_data = (char **)0x0;\n  if (match_count != (long *)0x0) {\n    temporary_data = match_strings;\n  }\n  current_match = 0;\n  while( true ) {\n    while( true ) {\n      counter = counter + -1;\n      if (counter == -1) {\n        if (match_count != (long *)0x0) {\n          *match_count = current_match;\n        }\n        return 1;\n      }\n      if (**input_data == 0x5f) {\n        *input_data = *input_data + 1;\n      }\n      if (**input_data != 0x74) break;\n      result = parse_and_validate_input_0010d559_0010d21c(output_data,input_data,temporary_data);\n      extracted_string = match_strings[0];\n      if (result == '\\0') {\n        return 0;\n      }\n      if (match_count != (long *)0x0) {\n        string_length = strlen(match_strings[0]);\n        current_match = find_match_and_free_0010afd5(*output_data,output_data[1],extracted_string,string_length & 0xffffffff,9);\n        free(extracted_string);\n        if (current_match == 0) {\n          return 0;\n        }\n      }\n    }\n    parsed_integer = parse_integer_00108e76(input_data);\n    string_length = strlen((char *)*input_data);\n    if (string_length < parsed_integer) break;\n    if (match_count != (long *)0x0) {\n      if ((current_match != 0) && (data_pointers = (long *)extract_data_from_binary_00113b1e(current_match), data_pointers != (long *)0x0)) {\n        extracted_string = (char *)copy_and_null_terminate_00109a0b(*input_data,parsed_integer);\n        for (; current_match = *data_pointers, current_match != 0; data_pointers = data_pointers + 1) {\n          current_match = *(long *)(current_match + 8);\n          if (current_match == 0) {\n            free(extracted_string);\n            return 0;\n          }\n          binary_string = (char *)extract_data_from_binary_001129f4(current_match);\n          if ((binary_string != (char *)0x0) && (comparison_result = strcmp(binary_string,extracted_string), comparison_result == 0)) break;\n        }\n        free(extracted_string);\n        if (current_match != 0) goto LAB_0010d7ad;\n      }\n      type_value = 9;\n      if (counter == 0) {\n        copied_string = (void *)copy_and_null_terminate_00109a0b(*input_data,parsed_integer);\n        current_match = find_named_type_0010914e(*output_data,copied_string);\n        free(copied_string);\n        if (current_match != 0) goto LAB_0010d7ad;\n        type_value = 0;\n      }\n      current_match = find_match_and_free_0010afd5(*output_data,output_data[1],*input_data,parsed_integer,type_value);\n      if (current_match == 0) {\n        return 0;\n      }\n    }\nLAB_0010d7ad:\n    *input_data = *input_data + parsed_integer;\n  }\nLAB_0010d5d8:\n  print_error_message_0010911f(current_byte);\n  return 0;\n}\n\n",
            "called": [
                "strcmp",
                "FUN_00108e76",
                "strlen",
                "FUN_00113b1e",
                "free",
                "FUN_001129f4",
                "FUN_0010914e",
                "FUN_0010afd5",
                "FUN_0010d21c",
                "FUN_00109a0b",
                "strtol",
                "FUN_0010911f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010d559",
            "calling": [
                "FUN_0010c95e",
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "parse_and_validate_input_0010d559"
        },
        "FUN_00119e70": {
            "renaming": {
                "FUN_00119e70": "print_error_message_00119e70",
                "param_1": "message",
                "param_2": "arguments",
                "_stdout": "standardOutput",
                "_stderr": "standardError"
            },
            "code": "\n\n\nvoid printErrorMessage_00119e70(char *message,__gnuc_va_list arguments)\n\n{\n  fflush(standardOutput);\n  fprintf(standardError,\"%s: \",DAT_001275e0);\n  vfprintf(standardError,message,arguments);\n  putc(10,standardError);\n  return;\n}\n\n",
            "called": [
                "fflush",
                "fprintf",
                "vfprintf",
                "putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00119e70",
            "calling": [
                "FUN_00119dd0",
                "FUN_00119ed0"
            ],
            "imported": false,
            "current_name": "print_error_message_00119e70"
        },
        "FUN_00108466": {
            "renaming": {
                "FUN_00108466": "cleanup_and_display_error_00108466",
                "param_7": "pointerToBeFreed"
            },
            "code": "\nvoid cleanupAndDisplayError_00108466(void)\n\n{\n  void *pointerToBeFreed;\n  \n  DAT_00127a20 = 1;\n  display_error_001126c0(0);\n  free(pointerToBeFreed);\n  return;\n}\n\n",
            "called": [
                "free",
                "FUN_001126c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108466",
            "calling": [
                "FUN_00116110"
            ],
            "imported": false,
            "current_name": "cleanup_and_display_error_00108466"
        },
        "mkstemps": {
            "renaming": {},
            "code": "\n\n\nint mkstemps(char *__template,int __suffixlen)\n\n{\n  int iVar1;\n  \n  iVar1 = mkstemps(__template,__suffixlen);\n  return iVar1;\n}\n\n",
            "called": [
                "mkstemps"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104030",
            "calling": [
                "FUN_001199d0"
            ],
            "imported": false,
            "current_name": "mkstemps"
        },
        "setlocale": {
            "renaming": {},
            "code": "\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = setlocale(__category,__locale);\n  return pcVar1;\n}\n\n",
            "called": [
                "setlocale"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104680",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "setlocale"
        },
        "FUN_00108e76": {
            "renaming": {
                "FUN_00108e76": "parse_integer_00108e76",
                "param_1": "byteArray",
                "bVar1": "currentByte",
                "iVar2": "result"
            },
            "code": "\nint parseInteger_00108e76(byte **byteArray)\n\n{\n  byte currentByte;\n  int result;\n  \n  result = 0;\n  while( true ) {\n    currentByte = **byteArray;\n    if (((&_sch_istable)[(ulong)currentByte * 2] & 4) == 0) break;\n    *byteArray = *byteArray + 1;\n    result = result * 10 + -0x30 + (int)(char)currentByte;\n  }\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108e76",
            "calling": [
                "FUN_0010d559",
                "FUN_0010c95e",
                "FUN_0010ee3f",
                "FUN_0010d21c"
            ],
            "imported": false,
            "current_name": "parse_integer_00108e76"
        },
        "FUN_0010bb52": {
            "renaming": {
                "FUN_0010bb52": "create_hash_function_0010bb52",
                "param_1": "inputSize",
                "param_2": "param2",
                "param_3": "param3",
                "lVar1": "hashFunction"
            },
            "code": "\nlong createHashFunction_0010bb52(long inputSize,undefined8 param2,undefined8 param3)\n\n{\n  long hashFunction;\n  \n  if (((inputSize != 0) || (inputSize = bfd_hash_allocate(param2,0x30), inputSize != 0)) &&\n     (hashFunction = bfd_hash_newfunc(inputSize,param2,param3), hashFunction != 0)) {\n    *(undefined8 *)(hashFunction + 0x20) = 0xffffffffffffffff;\n    *(undefined8 *)(hashFunction + 0x18) = 0;\n    *(undefined4 *)(hashFunction + 0x28) = 0;\n    return hashFunction;\n  }\n  return 0;\n}\n\n",
            "called": [
                "bfd_hash_allocate",
                "bfd_hash_newfunc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bb52",
            "calling": [
                "FUN_0011378f"
            ],
            "imported": false,
            "current_name": "create_hash_function_0010bb52"
        },
        "thunk_FUN_0010e439": {
            "renaming": {
                "thunk_FUN_0010e439": "update_param_and_process_string_thunk_0010e439",
                "param_1": "input_address",
                "param_2": "new_value",
                "process_string_0010e2f0": "process_string"
            },
            "code": "\nvoid update_param_and_process_string_thunk_0010e439(long input_address,undefined8 new_value)\n\n{\n  *(undefined8 *)(input_address + 0x210) = new_value;\n  process_string(input_address,0x84,0,0,new_value);\n  return;\n}\n\n",
            "called": [
                "FUN_0010e439"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e451",
            "calling": [
                "FUN_0011378f"
            ],
            "imported": false,
            "current_name": "update_param_and_process_string_thunk_0010e439"
        },
        "FUN_0011283f": {
            "renaming": {
                "FUN_0011283f": "check_directory_access_0011283f",
                "param_1": "file_path",
                "param_2": "directory_path",
                "iVar1": "access_result",
                "sStack_a8": "file_info"
            },
            "code": "\nchar * check_directory_access_0011283f(char *file_path,char *directory_path)\n\n{\n  int access_result;\n  stat file_info;\n  \n  if ((directory_path == (char *)0x0) && (file_path != (char *)0x0)) {\n    access_result = access(file_path,7);\n    if (access_result == 0) {\n      access_result = stat(file_path,&file_info);\n      if ((access_result == 0) && ((file_info.st_mode & 0xf000) == 0x4000)) {\n        directory_path = file_path;\n      }\n    }\n  }\n  return directory_path;\n}\n\n",
            "called": [
                "stat",
                "access"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011283f",
            "calling": [
                "FUN_001199d0"
            ],
            "imported": false,
            "current_name": "check_directory_access_0011283f"
        },
        "_DT_INIT": {
            "renaming": {},
            "code": "\nvoid _DT_INIT(void)\n\n{\n  __gmon_start__();\n  return;\n}\n\n",
            "called": [
                "__gmon_start__"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104000",
            "calling": [],
            "imported": false,
            "current_name": "_DT_INIT"
        },
        "bfd_set_section_size": {
            "renaming": {},
            "code": "\nvoid bfd_set_section_size(void)\n\n{\n  bfd_set_section_size();\n  return;\n}\n\n",
            "called": [
                "bfd_set_section_size"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001045f0",
            "calling": [
                "FUN_00115530",
                "FUN_0010554f",
                "FUN_00116110",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "bfd_set_section_size"
        },
        "FUN_00108237": {
            "renaming": {
                "FUN_00108237": "close_file_and_return_error_00108237",
                "piVar2": "errno_ptr",
                "iVar1": "previous_errno",
                "unaff_R12D": "file_descriptor"
            },
            "code": "\nundefined8 close_file_and_return_error_00108237(void)\n\n{\n  int previous_errno;\n  int *errno_ptr;\n  int file_descriptor;\n  \n  errno_ptr = __errno_location();\n  previous_errno = *errno_ptr;\n  close(file_descriptor);\n  *errno_ptr = previous_errno;\n  return 0xffffffff;\n}\n\n",
            "called": [
                "__errno_location",
                "close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108237",
            "calling": [
                "FUN_00115a90"
            ],
            "imported": false,
            "current_name": "close_file_and_return_error_00108237"
        },
        "bfd_hash_allocate": {
            "renaming": {},
            "code": "\nvoid bfd_hash_allocate(void)\n\n{\n  bfd_hash_allocate();\n  return;\n}\n\n",
            "called": [
                "bfd_hash_allocate"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104450",
            "calling": [
                "FUN_0010bb52"
            ],
            "imported": false,
            "current_name": "bfd_hash_allocate"
        },
        "close": {
            "renaming": {},
            "code": "\n\n\nint close(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = close(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043c0",
            "calling": [
                "FUN_00116b90",
                "FUN_00115a90",
                "FUN_00114690",
                "FUN_00108237",
                "FUN_001199d0"
            ],
            "imported": false,
            "current_name": "close"
        },
        "getenv": {
            "renaming": {},
            "code": "\n\n\nchar * getenv(char *__name)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = getenv(__name);\n  return pcVar1;\n}\n\n",
            "called": [
                "getenv"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104040",
            "calling": [
                "FUN_001199d0"
            ],
            "imported": false,
            "current_name": "getenv"
        },
        "fnmatch": {
            "renaming": {},
            "code": "\n\n\nint fnmatch(char *__pattern,char *__name,int __flags)\n\n{\n  int iVar1;\n  \n  iVar1 = fnmatch(__pattern,__name,__flags);\n  return iVar1;\n}\n\n",
            "called": [
                "fnmatch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104340",
            "calling": [
                "FUN_0011a170",
                "FUN_00114190"
            ],
            "imported": false,
            "current_name": "fnmatch"
        },
        "FUN_0010bc80": {
            "renaming": {
                "FUN_0010bc80": "initialize_debug_record_0010bc80",
                "param_1": "file_handle",
                "param_2": "filename",
                "param_3": "record_size",
                "param_4": "record_type",
                "uVar1": "error_message",
                "plVar2": "record",
                "puVar3": "data_structure",
                "lVar4": "result",
                "puVar5": "tmp_ptr",
                "pcVar6": "default_filename",
                "bVar7": "flag",
                "auVar8": "result_struct"
            },
            "code": "\n\n\nundefined  [16]\ninitialize_debug_record_0010bc80(long file_handle,char *filename,long record_size,uint record_type,undefined8 param_5,\n            undefined8 param_6)\n\n{\n  undefined8 error_message;\n  long *record;\n  undefined4 *data_structure;\n  long result;\n  undefined4 *tmp_ptr;\n  char *default_filename;\n  byte flag;\n  undefined result_struct [16];\n  \n  flag = 0;\n  default_filename = \"\";\n  if (filename != (char *)0x0) {\n    default_filename = filename;\n  }\n  if (record_size != 0) {\n    if (*(long *)(file_handle + 8) == 0) {\n      error_message = dcgettext(0,\"debug_record_function: no debug_set_filename call\",5);\n      fprintf(_stderr,\"%s\\n\",error_message);\n    }\n    else {\n      record = (long *)xmalloc(0x18);\n      *record = record_size;\n      *(undefined (*) [16])(record + 1) = ZEXT816(0);\n      data_structure = (undefined4 *)xmalloc(0x30);\n      *(long **)(file_handle + 0x18) = record;\n      record[2] = (long)data_structure;\n      tmp_ptr = data_structure;\n      for (result = 0xc; result != 0; result = result + -1) {\n        *tmp_ptr = 0;\n        tmp_ptr = tmp_ptr + (ulong)flag * -2 + 1;\n      }\n      *(undefined4 **)(file_handle + 0x20) = data_structure;\n      result = *(long *)(file_handle + 0x10);\n      *(undefined8 *)(data_structure + 6) = param_5;\n      *(undefined8 *)(data_structure + 8) = 0xffffffffffffffff;\n      result = initialize_data_structure_00112925(result + 0x10,default_filename,3,(record_type & 0xff) + 1);\n      if (result != 0) {\n        *(long **)(result + 0x20) = record;\n        error_message = CONCAT71((int7)((ulong)result >> 8),1);\n        goto LAB_0010bd56;\n      }\n    }\n  }\n  error_message = 0;\nLAB_0010bd56:\n  result_struct._8_8_ = param_6;\n  result_struct._0_8_ = error_message;\n  return result_struct;\n}\n\n",
            "called": [
                "FUN_00112925",
                "fprintf",
                "xmalloc",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bc80",
            "calling": [
                "FUN_0011173a",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "initialize_debug_record_0010bc80"
        },
        "fchmod": {
            "renaming": {},
            "code": "\n\n\nint fchmod(int __fd,__mode_t __mode)\n\n{\n  int iVar1;\n  \n  iVar1 = fchmod(__fd,__mode);\n  return iVar1;\n}\n\n",
            "called": [
                "fchmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001046c0",
            "calling": [
                "FUN_00115a90"
            ],
            "imported": false,
            "current_name": "fchmod"
        },
        "FUN_001152b6": {
            "renaming": {
                "FUN_001152b6": "FUNC_001152b6"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong FUNC_001152b6(void)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  undefined *puVar3;\n  long *plVar4;\n  code *pcVar5;\n  long *plVar6;\n  ulong uVar7;\n  ulong uVar8;\n  char *__s;\n  char cVar9;\n  char cVar10;\n  uint uVar11;\n  int iVar12;\n  uint uVar13;\n  undefined4 uVar14;\n  int iVar15;\n  long *plVar16;\n  long lVar17;\n  undefined8 uVar18;\n  undefined8 uVar19;\n  size_t sVar20;\n  size_t sVar21;\n  char *pcVar22;\n  void *__ptr;\n  void *__ptr_00;\n  ulong uVar23;\n  long lVar24;\n  ulong uVar25;\n  int *piVar26;\n  long lVar27;\n  ulong uVar28;\n  FILE *__s_00;\n  long **pplVar29;\n  undefined4 unaff_EBX;\n  long **__ptr_01;\n  char *pcVar30;\n  undefined8 *puVar31;\n  ulong uVar32;\n  int iVar33;\n  long **pplVar34;\n  long unaff_RBP;\n  char *pcVar35;\n  undefined4 *puVar36;\n  undefined8 *puVar37;\n  int unaff_R12D;\n  char **ppcVar38;\n  void *pvVar39;\n  undefined8 *unaff_R14;\n  undefined **ppuVar40;\n  bool bVar41;\n  byte bVar42;\n  long param_7;\n  ulong uStack0000000000000010;\n  char in_stack_00000018;\n  undefined4 *puStack0000000000000020;\n  char *pcStack0000000000000038;\n  uint uStack0000000000000048;\n  int iStack000000000000006c;\n  long lStack0000000000000078;\n  long lStack0000000000000088;\n  char *pcStack0000000000000090;\n  long lStack00000000000000a0;\n  long *in_stack_000000c0;\n  ulong in_stack_000000c8;\n  long in_stack_000000d0;\n  long in_stack_000000d8;\n  void *in_stack_000000e0;\n  long in_stack_000000f0;\n  undefined8 in_stack_000000f8;\n  byte bStack0000000000000100;\n  byte bStack0000000000000101;\n  undefined8 in_stack_00000110;\n  ushort in_stack_00000118;\n  char *in_stack_00000140;\n  char cStack0000000000000148;\n  char *in_stack_00000150;\n  undefined uStack0000000000000158;\n  short sStack000000000000015a;\n  \n  bVar42 = 0;\n  if (unaff_R12D == 0) {\n    unaff_R12D = *(int *)(unaff_RBP + 0xc);\n    unaff_EBX = *(undefined4 *)(unaff_RBP + 0x10);\n    if (((unaff_R12D == 0) && (*(int *)(unaff_R14[1] + 8) != 5)) &&\n       (*(int *)(*(long *)(param_7 + 8) + 8) == 5)) {\n      uVar28 = FUNC_00107880();\n      return uVar28;\n    }\n  }\n  else {\n    uVar19 = get_formatted_string_001125fa();\n    uVar18 = dcgettext(0,\"Input file `%s\\' ignores binary architecture parameter.\",5);\n    print_error_message_00119ed0(uVar18,uVar19);\n  }\n  cVar10 = (**(code **)(*(long *)(param_7 + 8) + 0x2a0))(param_7,unaff_R12D,unaff_EBX);\n  if (cVar10 == '\\0') {\n    if ((*(byte *)(unaff_R14 + 9) & 0x40) != 0) {\n      iVar12 = bfd_get_arch();\n      if (iVar12 == 0) {\n        uVar19 = get_formatted_string_001125fa();\n        uVar18 = dcgettext(0,\"Unable to recognise the format of the input file `%s\\'\",5);\n        print_error_message_00119ed0(uVar18,uVar19);\n        return 0;\n      }\n      uVar19 = bfd_get_mach();\n      uVar14 = bfd_get_arch();\n      uVar19 = bfd_printable_arch_mach(uVar14,uVar19);\n      uVar18 = dcgettext(0,\"Output file cannot represent architecture `%s\\'\",5);\n      print_error_message_00119ed0(uVar18,uVar19);\n      return 0;\n    }\n    iVar12 = bfd_get_arch();\n    iVar33 = bfd_get_arch(param_7);\n    if (iVar12 != iVar33) {\n      uVar28 = check_file_architecture_00105828();\n      return uVar28;\n    }\n  }\n  cVar10 = bfd_set_format(param_7,*(byte *)(unaff_R14 + 9) & 7);\n  if (cVar10 == '\\0') {\nLAB_00107a82:\n    display_error_001126c0(0);\n    return 0;\n  }\n  if ((*(int *)(*(undefined8 **)(param_7 + 8) + 1) == 2) &&\n     (cVar10 = compare_strings_00113fb0(**(undefined8 **)(param_7 + 8),&DAT_0011b503), cVar10 != '\\0')) {\n    lVar27 = *(long *)(param_7 + 0x110);\n    if ((*(int *)((undefined8 *)unaff_R14[1] + 1) == 2) &&\n       (cVar10 = compare_strings_00113fb0(*(undefined8 *)unaff_R14[1],&DAT_0011b503), cVar10 != '\\0')) {\n      lVar17 = unaff_R14[0x22];\n      bVar41 = DAT_001279cb == '\\0';\n      puVar31 = (undefined8 *)(lVar17 + 200);\n      puVar37 = (undefined8 *)(lVar27 + 200);\n      for (lVar24 = 0x32; lVar24 != 0; lVar24 = lVar24 + -1) {\n        *puVar37 = *puVar31;\n        puVar31 = puVar31 + (ulong)bVar42 * -2 + 1;\n        puVar37 = puVar37 + (ulong)bVar42 * -2 + 1;\n      }\n      if (bVar41) {\n        *(undefined4 *)(lVar27 + 0x2a4) = 0xffffffff;\n      }\n      else {\n        *(int *)(lVar27 + 0x2a4) = (int)*(undefined8 *)(lVar17 + 0xa8);\n      }\n    }\n    uVar28 = DAT_001264a8;\n    if (DAT_001264a8 == 0xffffffffffffffff) {\n      DAT_001264a8 = 0x200;\n      uVar28 = 0x200;\n    }\n    else {\n      *(int *)(lVar27 + 0x10c) = (int)DAT_001264a8;\n    }\n    if (DAT_00126498 != -1) {\n      *(long *)(lVar27 + 0x148) = DAT_00126498;\n    }\n    if (DAT_001264a0 != -1) {\n      *(long *)(lVar27 + 0x148) = DAT_001264a0;\n    }\n    if (DAT_00126490 != -1) {\n      *(long *)(lVar27 + 0x100) = DAT_00126490;\n    }\n    uVar23 = DAT_00126488;\n    if (DAT_00126488 == 0xffffffffffffffff) {\n      DAT_00126488 = 0x1000;\n      uVar23 = 0x1000;\n    }\n    else {\n      *(int *)(lVar27 + 0x108) = (int)DAT_00126488;\n    }\n    if (DAT_00126478 != -1) {\n      *(long *)(lVar27 + 0x138) = DAT_00126478;\n    }\n    if (DAT_00126480 != -1) {\n      *(long *)(lVar27 + 0x138) = DAT_00126480;\n    }\n    if (DAT_00126474 != -1) {\n      *(short *)(lVar27 + 300) = DAT_00126474;\n    }\n    if (DAT_00126472 != -1) {\n      *(short *)(lVar27 + 0x118) = DAT_00126472;\n    }\n    if (DAT_00126470 != -1) {\n      *(short *)(lVar27 + 0x11a) = DAT_00126470;\n    }\n    if (uVar23 < uVar28) {\n      uVar19 = dcgettext(0,\"warning: file alignment (0x%lx) > section alignment (0x%lx)\",5);\n      print_error_message_00119ed0(uVar19,uVar28,uVar23);\n    }\n  }\n  plVar6 = DAT_001278b0;\n  free(DAT_001278b0);\n  if (plVar6 == DAT_001278a8) {\n    DAT_001278b0 = (long *)0x0;\n    DAT_001278a8 = (long *)0x0;\n    lVar27 = (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  else {\n    free(DAT_001278a8);\n    DAT_001278b0 = (long *)0x0;\n    DAT_001278a8 = (long *)0x0;\n    lVar27 = (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  if (lVar27 < 0) goto LAB_00107a82;\n  DAT_001278a8 = (long *)xmalloc();\n  DAT_001278b0 = DAT_001278a8;\n  uStack0000000000000010 = (**(code **)(unaff_R14[1] + 0x200))();\n  if ((long)uStack0000000000000010 < 0) goto LAB_00107a82;\n  if (uStack0000000000000010 == 0) {\n    free(DAT_001278b0);\n    DAT_001278b0 = (long *)0x0;\n    DAT_001278a8 = (long *)0x0;\n  }\n  bfd_map_over_sections();\n  puVar31 = DAT_001279c0;\n  if ((DAT_001278ec == '\\0') &&\n     (cVar10 = (**(code **)(*(long *)(param_7 + 8) + 0x168))(), puVar31 = DAT_001279c0,\n     cVar10 == '\\0')) {\n    DAT_00127a20 = 1;\n    dcgettext(0,\"error in private header data\",5);\n    display_error_001126c0(0);\n    puVar31 = DAT_001279c0;\n  }\n  for (; puVar37 = DAT_001279b8, puVar31 != (undefined8 *)0x0; puVar31 = (undefined8 *)*puVar31) {\n    uVar11 = 0x128;\n    lVar27 = parse_rules_00114190(puVar31[1],0,0x80);\n    if (lVar27 != 0) {\n      uVar11 = drop_share_flag_if_not_coff_00115f30(*(uint *)(lVar27 + 0x28) | 0x100,param_7,puVar31[1]);\n    }\n    lVar27 = bfd_get_section_by_name(param_7,puVar31[1]);\n    if (lVar27 != 0) {\n      uVar19 = puVar31[1];\n      uVar18 = dcgettext(0,\"can\\'t add section \\'%s\\'\",5);\n      display_error_001126c0(0,param_7,0,uVar18,uVar19);\n      return 0;\n    }\n    lVar27 = bfd_make_section_with_flags(param_7,puVar31[1],uVar11 | 0x100000);\n    puVar31[5] = lVar27;\n    if (lVar27 == 0) {\n      uVar19 = puVar31[1];\n      uVar18 = dcgettext(0,\"can\\'t create section `%s\\'\",5);\n      display_error_001126c0(0,param_7,0,uVar18,uVar19);\n      return 0;\n    }\n    cVar10 = bfd_set_section_size();\n    if (cVar10 == '\\0') {\n      display_error_001126c0(0,param_7,puVar31[5],0);\n      return 0;\n    }\n    lVar27 = parse_rules_00114190(puVar31[1],0,0x18);\n    if (lVar27 != 0) {\n      uVar19 = *(undefined8 *)(lVar27 + 0x18);\n      lVar27 = puVar31[5];\n      *(byte *)(lVar27 + 0x28) = *(byte *)(lVar27 + 0x28) | 1;\n      *(undefined8 *)(lVar27 + 0x30) = uVar19;\n      *(undefined8 *)(lVar27 + 0x38) = uVar19;\n    }\n    lVar27 = parse_rules_00114190(puVar31[1],0,0x60);\n    if (lVar27 != 0) {\n      lVar17 = puVar31[5];\n      *(undefined8 *)(lVar17 + 0x38) = *(undefined8 *)(lVar27 + 0x20);\n      if (0x3e < *(uint *)(lVar17 + 0x7c)) {\n        display_error_001126c0(0,param_7,lVar17,0);\n        return 0;\n      }\n    }\n  }\n  for (; puVar37 != (undefined8 *)0x0; puVar37 = (undefined8 *)*puVar37) {\n    lVar27 = bfd_get_section_by_name();\n    puVar37[5] = lVar27;\n    if (lVar27 == 0) {\n      uVar19 = puVar37[1];\n      uVar18 = dcgettext(0,\"error: %s not found, can\\'t be updated\",5);\n      print_error_message_00119ed0(uVar18,uVar19);\n      return 0;\n    }\n    uVar19 = *(undefined8 *)(lVar27 + 0x60);\n    cVar10 = bfd_set_section_size(uVar19);\n    if (cVar10 == '\\0') {\n      display_error_001126c0(0,param_7,uVar19,0);\n      return 0;\n    }\n  }\n  puVar31 = DAT_001279b0;\n  if (DAT_00127a00 == '\\0') {\n    __ptr_01 = (long **)0x0;\n  }\n  else {\n    pplVar34 = (long **)unaff_R14[0x12];\n    __ptr_01 = pplVar34;\n    if (pplVar34 != (long **)0x0) {\n      __ptr_01 = (long **)0x0;\nLAB_001151ab:\n      if (DAT_00127a00 != '\\0') goto LAB_00115187;\n      for (plVar6 = pplVar34[1]; puVar31 = DAT_001279b0, plVar6 != (long *)0x0;\n          plVar6 = (long *)plVar6[1]) {\n      }\n    }\n  }\njoined_r0x001151c7:\n  for (; puVar31 != (undefined8 *)0x0; puVar31 = (undefined8 *)*puVar31) {\n    lVar27 = bfd_get_section_by_name();\n    if (lVar27 == 0) {\n      dcgettext(0,\"can\\'t dump section \\'%s\\' - it does not exist\",5);\n      display_error_001126c0(0);\n    }\n    else if ((*(byte *)(lVar27 + 0x25) & 1) == 0) {\n      dcgettext(0,\"can\\'t dump section - it has no contents\",5);\n      display_error_001126c0(0);\n    }\n    else {\n      sVar20 = *(size_t *)(lVar27 + 0x40);\n      __s_00 = fopen((char *)puVar31[2],\"w\");\n      if (__s_00 == (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        display_error_001126c0(puVar31[2],0,0);\n      }\n      else {\n        cVar10 = bfd_malloc_and_get_section();\n        if (cVar10 == '\\0') {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          display_error_001126c0(0);\n        }\n        else if ((sVar20 != 0) &&\n                (sVar21 = fwrite(in_stack_00000140,1,sVar20,__s_00), sVar21 != sVar20)) {\n          piVar26 = __errno_location();\n          pcVar35 = strerror(*piVar26);\n          uVar19 = puVar31[2];\n          uVar18 = dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          print_error_message_00119ed0(uVar18,uVar19,pcVar35);\n          free(in_stack_00000140);\n          fclose(__s_00);\n          return 0;\n        }\n        fclose(__s_00);\n        free(in_stack_00000140);\n      }\n    }\n  }\n  if (DAT_00127a10 == 0) {\nLAB_0010790a:\n    lStack0000000000000078 = 0;\n  }\n  else {\n    lVar27 = bfd_get_section_by_name(param_7,\".gnu_debuglink\");\n    if (lVar27 != 0) {\n      uVar19 = dcgettext(0,\"%s: debuglink section already exists\",5);\n      print_error_message_00119ed0(uVar19);\n      DAT_00127a10 = 0;\n      goto LAB_0010790a;\n    }\n    lStack0000000000000078 = bfd_create_gnu_debuglink_section(param_7);\n    lVar27 = DAT_00127a10;\n    if (lStack0000000000000078 == 0) {\n      uVar19 = dcgettext(0,\"cannot create debug link section `%s\\'\",5);\n      display_error_001126c0(0,param_7,0,uVar19,lVar27);\n      return 0;\n    }\n    if (*(int *)(*(long *)(param_7 + 8) + 8) == 2) {\n      uVar23 = 0;\n      for (uVar28 = *(ulong *)(param_7 + 0x90); uVar28 != 0; uVar28 = *(ulong *)(uVar28 + 8)) {\n        uVar25 = *(ulong *)(uVar28 + 0x30);\n        uVar32 = uVar23;\n        uVar7 = uVar28;\n        uVar8 = uVar23;\n        if (uVar25 != 0) {\n          while ((uVar32 = uVar7, uVar8 != 0 &&\n                 (uVar32 = uVar28, uVar25 <= *(ulong *)(uVar23 + 0x30)))) {\n            uVar28 = *(ulong *)(uVar28 + 8);\n            if (uVar28 == 0) goto LAB_00107db8;\n            uVar25 = *(ulong *)(uVar28 + 0x30);\n            uVar7 = uVar23;\n            uVar8 = uVar25;\n          }\n        }\n        uVar23 = uVar32;\n      }\nLAB_00107db8:\n      if (uVar23 == 0) {\n        uVar28 = 0x1000;\n      }\n      else {\n        uVar23 = *(long *)(uVar23 + 0x40) + *(long *)(uVar23 + 0x30);\n        uVar28 = 0xffffffffffffffff;\n        if (uVar23 < 0xfffffffffffff001) {\n          uVar28 = uVar23 + 0xfff & 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(lStack0000000000000078 + 0x28) = *(byte *)(lStack0000000000000078 + 0x28) | 1;\n      *(ulong *)(lStack0000000000000078 + 0x30) = uVar28;\n      *(ulong *)(lStack0000000000000078 + 0x38) = uVar28;\n    }\n  }\n  plVar6 = DAT_001278b0;\n  iStack000000000000006c = *(int *)(param_7 + 0xa0);\n  if (iStack000000000000006c != 0) {\n    uVar28 = process_debug_info_0010554f();\n    return uVar28;\n  }\n  if (DAT_00127980 == '\\0') {\nLAB_00105588:\n    puStack0000000000000020 = (undefined4 *)0x0;\n  }\n  else {\n    ppuVar40 = &PTR_s__stab_00125c60;\n    puStack0000000000000020 = (undefined4 *)xmalloc(0x60);\n    puVar36 = puStack0000000000000020;\n    for (lVar27 = 0x18; lVar27 != 0; lVar27 = lVar27 + -1) {\n      *puVar36 = 0;\n      puVar36 = puVar36 + (ulong)bVar42 * -2 + 1;\n    }\n    pcStack0000000000000038 = (char *)0x0;\n    do {\n      puVar3 = *ppuVar40;\n      lVar27 = bfd_get_section_by_name();\n      lVar17 = bfd_get_section_by_name();\n      if ((lVar27 != 0) && (lVar17 != 0)) {\n        lVar27 = *(long *)(lVar27 + 0x40);\n        __ptr = (void *)xmalloc(lVar27);\n        cVar10 = bfd_get_section_contents();\n        if (cVar10 == '\\0') {\n          uVar14 = bfd_get_error();\n          bfd_errmsg(uVar14);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n          free(pcStack0000000000000038);\n          free(__ptr);\n        }\n        else {\n          uVar28 = *(ulong *)(lVar17 + 0x40);\n          __ptr_00 = (void *)xmalloc(uVar28 + 1);\n          in_stack_00000018 = bfd_get_section_contents();\n          if (in_stack_00000018 == '\\0') {\n            uVar14 = bfd_get_error();\n            bfd_errmsg(uVar14);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n            free(pcStack0000000000000038);\n          }\n          else {\n            *(undefined *)((long)__ptr_00 + uVar28) = 0;\n            if ((pcStack0000000000000038 != (char *)0x0) ||\n               (pcStack0000000000000038 = (char *)initialize_data_structure_00112894(),\n               pcStack0000000000000038 != (char *)0x0)) {\n              lStack00000000000000a0 = 0;\n              lStack0000000000000088 = 0;\n              for (pvVar39 = __ptr; pvVar39 <= (void *)((long)__ptr + lVar27 + -0xc);\n                  pvVar39 = (void *)((long)pvVar39 + 0xc)) {\n                uVar23 = (**(code **)(unaff_R14[1] + 0x40))(pvVar39);\n                bVar2 = *(byte *)((long)pvVar39 + 4);\n                uVar14 = (**(code **)(unaff_R14[1] + 0x58))((long)pvVar39 + 6);\n                lVar17 = (**(code **)(unaff_R14[1] + 0x40))((long)pvVar39 + 8);\n                if (bVar2 == 0) {\n                  lStack0000000000000088 = lStack00000000000000a0;\n                  lStack00000000000000a0 = lStack00000000000000a0 + lVar17;\n                }\n                else {\n                  uVar25 = (uVar23 & 0xffffffff) + lStack0000000000000088;\n                  if (uVar25 < uVar28) {\n                    pcVar35 = (char *)((long)__ptr_00 + uVar25);\n                    pcStack0000000000000090 = (char *)0x0;\n                    while( true ) {\n                      sVar20 = strlen(pcVar35);\n                      if (((sVar20 == 0) || (pcVar30 = pcVar35 + (sVar20 - 1), *pcVar30 != '\\\\')) ||\n                         ((ulong)((long)__ptr + lVar27) < (long)pvVar39 + 0x10U)) goto LAB_001077fb;\n                      *pcVar30 = '\\0';\n                      pvVar39 = (void *)((long)pvVar39 + 0xc);\n                      iVar12 = (**(code **)(unaff_R14[1] + 0x40))(pvVar39);\n                      uVar23 = (ulong)(uint)(iVar12 + (int)lStack0000000000000088);\n                      if (uVar28 <= uVar23) break;\n                      pcVar35 = (char *)concat(pcVar35,(long)__ptr_00 + uVar23,0);\n                      *pcVar30 = '\\\\';\n                      free(pcStack0000000000000090);\n                      pcStack0000000000000090 = pcVar35;\n                    }\n                    uVar19 = *unaff_R14;\n                    pcVar30 = (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar30,uVar19,puVar3,((long)pvVar39 - (long)__ptr) / 0xc);\nLAB_001077fb:\n                    update_data_entry_001088ae((ulong)bVar2,uVar14,lVar17,pcVar35);\n                    cVar10 = process_debug_info_0011173a(puStack0000000000000020,pcStack0000000000000038,bVar2);\n                    if (cVar10 == '\\0') {\n                      print_stab_entries_00108b3e();\n                      free_memory_and_reset_00108863();\n                      free(pcStack0000000000000090);\n                      free(pcStack0000000000000038);\n                      free(__ptr);\n                      free(__ptr_00);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar19 = *unaff_R14;\n                    pcVar35 = (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar35,uVar19,puVar3,((long)pvVar39 - (long)__ptr) / 0xc,\n                            uVar23 & 0xffffffff,(ulong)bVar2,((long)pvVar39 - (long)__ptr) % 0xc);\n                  }\n                }\n              }\n              free_memory_and_reset_00108863();\n              free(__ptr);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_00);\n          free(__ptr);\n        }\n        goto LAB_00105981;\n      }\nLAB_001058eb:\n      ppuVar40 = ppuVar40 + 2;\n    } while (ppuVar40 != (undefined **)&DAT_00125c90);\n    if ((pcStack0000000000000038 != (char *)0x0) && (cVar10 = process_debug_info_0010c892(), cVar10 == '\\0')) {\nLAB_00105981:\n      free(puStack0000000000000020);\n      goto LAB_00105588;\n    }\n    if (*(int *)(unaff_R14[1] + 8) == 1) {\n      lVar27 = 0;\n      for (plVar16 = plVar6; plVar16 < plVar6 + uStack0000000000000010; plVar16 = plVar16 + 1) {\n        (**(code **)(unaff_R14[1] + 0x218))();\n        if (cStack0000000000000148 == '-') {\n          if (((lVar27 == 0) && (lVar27 = initialize_data_structure_00112894(), lVar27 == 0)) ||\n             ((in_stack_00000150 == (char *)0x0 || (*in_stack_00000150 == '\\0'))))\n          goto LAB_00105981;\n          pcVar35 = (char *)0x0;\n          pcVar30 = in_stack_00000150;\n          while (((*pcVar30 != '\\0' && (sVar20 = strlen(pcVar30), pcVar30[sVar20 - 1] == '\\\\')) &&\n                 (plVar16 + 1 < plVar6 + uStack0000000000000010))) {\n            pcVar22 = (char *)xstrdup(pcVar30);\n            sVar20 = strlen(pcVar22);\n            pcVar22[sVar20 - 1] = '\\0';\n            pcVar30 = (char *)concat(pcVar22,*(undefined8 *)(plVar16[1] + 8),0);\n            free(pcVar22);\n            free(pcVar35);\n            plVar16 = plVar16 + 1;\n            pcVar35 = pcVar30;\n          }\n          update_data_entry_001088ae(uStack0000000000000158,(int)sStack000000000000015a,in_stack_00000140,pcVar30)\n          ;\n          in_stack_00000018 = process_debug_info_0011173a(puStack0000000000000020,lVar27,uStack0000000000000158);\n          if (in_stack_00000018 == '\\0') {\n            print_stab_entries_00108b3e();\n            free_memory_and_reset_00108863();\n            goto LAB_00105981;\n          }\n        }\n      }\n      free_memory_and_reset_00108863();\n      if ((lVar27 != 0) && (cVar10 = process_debug_info_0010c892(), cVar10 == '\\0')) goto LAB_00105981;\n    }\n    if (in_stack_00000018 == '\\0') {\n      if ((*(int *)(unaff_R14[1] + 8) == 2) && (uStack0000000000000010 != 0)) {\n        in_stack_00000140 = (char *)0x0;\n        in_stack_000000c0 = plVar6;\n        in_stack_000000d0 = 0;\n        in_stack_000000d8 = 0;\n        puVar31 = (undefined8 *)&stack0x00000148;\n        for (lVar27 = 0x22; lVar27 != 0; lVar27 = lVar27 + -1) {\n          *(undefined4 *)puVar31 = 0;\n          puVar31 = (undefined8 *)((long)puVar31 + (ulong)bVar42 * -8 + 4);\n        }\n        cVar10 = '\\0';\n        _uStack0000000000000048 = (int *)0x0;\n        pcStack0000000000000038 = (char *)0x0;\n        pcStack0000000000000090 = (char *)0xffffffffffffffff;\n        in_stack_000000c8 = uStack0000000000000010;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((long)uStack0000000000000010 <= in_stack_000000d0) goto LAB_00105590;\n            lVar27 = plVar6[in_stack_000000d0];\n            cVar9 = bfd_coff_get_syment();\n            lVar17 = in_stack_000000d8;\n            if (cVar9 == '\\0') {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar35 = \"bfd_coff_get_syment failed: %s\";\n              goto LAB_00105968;\n            }\n            pcVar35 = *(char **)(lVar27 + 8);\n            in_stack_000000d0 = in_stack_000000d0 + 1;\n            in_stack_000000d8 = (ulong)bStack0000000000000101 + 1 + in_stack_000000d8;\n            if ((bStack0000000000000101 != 0) && (cVar9 = bfd_coff_get_auxent(), cVar9 == '\\0')) {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar35 = \"bfd_coff_get_auxent failed: %s\";\n              goto LAB_00105968;\n            }\n            if (pcStack0000000000000090 != (char *)lVar17) break;\n            if (bStack0000000000000100 != 0x67) {\n              cVar9 = initialize_debug_info_0010bbd3(puStack0000000000000020);\n              if (cVar9 != '\\0') break;\n              goto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            pcStack0000000000000090 = (char *)in_stack_000000f0;\n            cVar9 = initialize_debug_info_0010bbd3(puStack0000000000000020);\n            if (cVar9 == '\\0') goto LAB_00105981;\n          }\n          if ((char)bStack0000000000000100 < '\\0') {\n            if (bStack0000000000000100 == 0xff) goto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            lVar24 = parse_and_initialize_data_0010dac0();\n            if (lVar24 == 0) break;\n            cVar9 = process_parameter_00112a33(&stack0x00000140,lVar27,lVar17);\n          }\n          else {\n            if (bStack0000000000000100 < 100) {\n              switch(bStack0000000000000100) {\n              case 3:\n                if (in_stack_000000f8._6_2_ == 0) goto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulong)((uint)in_stack_000000f8._6_2_ & *(uint *)(unaff_R14[0x22] + 0x40)) !=\n                    2L << ((byte)*(undefined4 *)(unaff_R14[0x22] + 0x3c) & 0x3f)) goto LAB_0010700a;\n                _uStack0000000000000048 = (int *)(**(code **)(unaff_R14[1] + 0x238))();\n                pcStack0000000000000038 = pcVar35;\n                goto switchD_00106e1a_caseD_68;\n              default:\n                goto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                goto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(bStack0000000000000100) {\n            case 100:\n              iVar12 = strcmp(pcVar35,\".bb\");\n              if (iVar12 == 0) {\n                cVar9 = start_debug_block_0010be88(puStack0000000000000020);\n              }\n              else {\n                iVar12 = strcmp(pcVar35,\".eb\");\n                if (iVar12 != 0) goto switchD_00106e1a_caseD_68;\n                cVar9 = debug_end_block_check_0010bf20(puStack0000000000000020);\n              }\n              break;\n            case 0x65:\n              iVar12 = strcmp(pcVar35,\".bf\");\n              if (iVar12 == 0) {\n                if (pcStack0000000000000038 != (char *)0x0) {\n                  lVar17 = parse_and_initialize_data_0010dac0();\n                  if ((lVar17 == 0) ||\n                     (cVar10 = initialize_debug_record_0010bc80(puStack0000000000000020), cVar10 == '\\0'))\n                  goto LAB_00105981;\n                  if (_uStack0000000000000048 != (int *)0x0) {\n                    iVar12 = 0;\n                    if (bStack0000000000000101 != 0) {\n                      iVar12 = in_stack_00000118 - 1;\n                    }\n                    lVar27 = *(long *)(*(long *)(lVar27 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar33 = _uStack0000000000000048[4];\n                      if (iVar33 == 0) break;\n                      cVar9 = record_line_info_0010bf86(puStack0000000000000020,iVar12 + iVar33,\n                                           *(long *)(_uStack0000000000000048 + 6) + lVar27);\n                      _uStack0000000000000048 = _uStack0000000000000048 + 4;\n                      if (cVar9 == '\\0') goto LAB_00105981;\n                    }\n                  }\n                  _uStack0000000000000048 = (int *)0x0;\n                  pcStack0000000000000038 = (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar35 = \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar12 = strcmp(pcVar35,\".ef\");\n                if (iVar12 != 0) goto switchD_00106e1a_caseD_68;\n                if (cVar10 != '\\0') {\n                  cVar10 = end_debugging_function_0010be1a(puStack0000000000000020);\n                  if (cVar10 == '\\0') goto LAB_00105981;\n                  cVar10 = '\\0';\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar35 = \"%ld: unexpected .ef\\n\";\n              }\n              uVar19 = dcgettext(0,pcVar35,5);\n              print_error_message_00119ed0(uVar19);\n              goto LAB_00105981;\n            default:\n              goto LAB_0010700a;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (cVar9 != '\\0');\n      }\n      else {\n        pcVar35 = \"%s: no recognized debugging information\";\nLAB_00105968:\n        uVar19 = dcgettext(0,pcVar35,5);\n        print_error_message_00119ed0(uVar19);\n      }\n      goto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)(param_7 + 0x44) & 0x42) != 0) && ((*(uint *)(param_7 + 0x44) & 1) == 0)) {\n    if ((*(char *)(*(long *)(param_7 + 8) + 0x20) == '\\0') && (DAT_00127939 == '\\0')) {\n      if (uStack0000000000000010 != 0) {\n        plVar6 = DAT_001278b0 + uStack0000000000000010;\n        plVar16 = DAT_001278b0;\n        do {\n          uVar11 = *(uint *)(*plVar16 + 0x18);\n          if ((uVar11 & 0x1000000) != 0) {\n            *(uint *)(*plVar16 + 0x18) = uVar11 & 0xfeffffff;\n          }\n          plVar16 = plVar16 + 1;\n        } while (plVar6 != plVar16);\n      }\n    }\n    else {\n      for (lVar27 = *(long *)(param_7 + 0x90); lVar27 != 0; lVar27 = *(long *)(lVar27 + 8)) {\n        if (*(long *)(lVar27 + 0xe8) != 0) {\n          puVar1 = (uint *)(*(long *)(lVar27 + 0xe8) + 0x18);\n          *puVar1 = *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((DAT_00127a2c == 2) || (DAT_00127a2c == 7)) {\nLAB_001059fe:\n    if (DAT_00127a2c == 7) {\nLAB_00105a3b:\n      plVar16 = (long *)xmalloc();\n      plVar6 = DAT_001278b0;\n      uStack0000000000000048 = *(uint *)((long)unaff_R14 + 0x44) & 0x42;\n      DAT_001278a8 = plVar16;\n      if (uStack0000000000000010 == 0) {\n        uVar28 = 0;\n      }\n      else {\n        uVar28 = 0;\n        _in_stack_00000018 = 0;\n        do {\n          iVar12 = DAT_001279a0;\n          plVar4 = (long *)plVar6[_in_stack_00000018];\n          pcVar5 = (code *)plVar4[4];\n          uVar11 = *(uint *)(plVar4 + 3);\n          pcVar35 = (char *)plVar4[1];\n          pcVar30 = pcVar35;\n          if (DAT_001279a8 != (undefined8 *)0x0) {\n            iVar33 = 0;\n            puVar31 = DAT_001279a8;\n            while ((iVar33 < iVar12 && (pcVar22 = (char *)puVar31[5], pcVar22 != (char *)0x0))) {\n              if (pcVar22 != \"\") {\n                iVar15 = strcmp(pcVar22,pcVar35);\n                if (iVar15 == 0) {\n                  free(pcVar22);\n                  uVar23 = uVar28 + 1;\n                  puVar31[5] = \"\";\n                  lVar27 = update_section_info_0011a2e0(puVar31);\n                  uVar19 = DAT_001278d0;\n                  plVar16[uVar28] = lVar27;\n                  lVar27 = htab_elements(uVar19);\n                  if ((lVar27 != 0) || (DAT_001278d8 != (char **)0x0)) goto LAB_001064eb;\n                  goto LAB_00105af8;\n                }\n                puVar31 = (undefined8 *)*puVar31;\n              }\n              iVar33 = iVar33 + 1;\n            }\n          }\n          lVar27 = htab_elements(DAT_001278d0);\n          uVar23 = uVar28;\n          if ((lVar27 != 0) || (DAT_001278d8 != (char **)0x0)) {\n            if (pcVar35 != (char *)0x0) {\nLAB_001064eb:\n              if (((*pcVar35 == '_') && (pcVar35[1] == '_')) &&\n                 (iVar12 = strcmp(pcVar35 + (pcVar35[2] == '_'),\"__gnu_lto_slim\"), iVar12 == 0)) {\n                uVar19 = dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\"\n                                   ,5);\n                    \n                print_error_and_exit_00119dd0(uVar19);\n              }\n            }\n            _cStack0000000000000148 = 0;\n            in_stack_00000140 = pcVar35;\n            lVar27 = htab_find(DAT_001278d0);\n            if (((lVar27 == 0) || (pcVar30 = *(char **)(lVar27 + 8), pcVar35 == pcVar30)) &&\n               (pcVar30 = pcVar35, ppcVar38 = DAT_001278d8, (uVar11 & 0x100) != 0)) {\n              for (; ppcVar38 != (char **)0x0; ppcVar38 = (char **)ppcVar38[3]) {\n                iVar12 = strcmp(*ppcVar38,pcVar35);\n                if (iVar12 == 0) {\n                  pcVar30 = ppcVar38[1];\n                  break;\n                }\n              }\n            }\n            plVar4[1] = (long)pcVar30;\n            cVar10 = *pcVar30;\n            if (cVar10 != '\\0') goto LAB_00105b11;\nLAB_00106557:\n            pcVar35 = DAT_00127908;\n            if ((DAT_00127988 != '\\0') && (*(char *)(*(long *)(param_7 + 8) + 0x1c) != '\\0')) {\n              lVar27 = unaff_R14[1];\n              cVar10 = '\\0';\n              goto LAB_0010668d;\n            }\n            goto joined_r0x00106565;\n          }\nLAB_00105af8:\n          cVar10 = *pcVar35;\n          if (cVar10 == '\\0') goto LAB_00106557;\nLAB_00105b11:\n          pcVar35 = DAT_00127908;\n          lVar27 = unaff_R14[1];\n          if (*(char *)(lVar27 + 0x1c) == cVar10) {\n            if (DAT_00127988 == '\\0') {\n              if ((DAT_00127968 == '\\0') ||\n                 ((((uVar11 & 0x82) == 0 && (pcVar5 != bfd_map_over_sections)) &&\n                  ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n              pcVar30 = pcVar30 + 1;\n              plVar4[1] = (long)pcVar30;\n              goto joined_r0x00106565;\n            }\n            cVar10 = *(char *)(*(long *)(param_7 + 8) + 0x1c);\n            if (cVar10 == '\\0') goto LAB_0010677d;\n            if (DAT_00127908 != (char *)0x0) {\n              pcVar30 = pcVar30 + 1;\n              plVar4[1] = (long)pcVar30;\n              sVar20 = strlen(pcVar30);\n              lVar27 = sVar20 + 2;\nLAB_001066bc:\n              sVar20 = strlen(pcVar35);\n              pcVar35 = (char *)xmalloc(sVar20 + lVar27);\n              goto LAB_001066d0;\n            }\n            *pcVar30 = cVar10;\n            plVar4[1] = (long)pcVar30;\n            uVar28 = uVar23;\n          }\n          else {\n            if ((DAT_00127988 == '\\0') || (*(char *)(*(long *)(param_7 + 8) + 0x1c) == '\\0')) {\njoined_r0x00106565:\n              uVar28 = uVar23;\n              if (pcVar35 == (char *)0x0) goto LAB_00105b32;\n              sVar20 = strlen(pcVar30);\n              sVar21 = strlen(pcVar35);\n              pcVar22 = (char *)xmalloc(sVar21 + sVar20 + 1);\n              pcVar35 = pcVar22;\n            }\n            else {\nLAB_0010668d:\n              pcVar35 = DAT_00127908;\n              if ((*(char *)(lVar27 + 0x1c) != '\\0') && (cVar10 != *(char *)(lVar27 + 0x1c)))\n              goto joined_r0x00106565;\n              sVar20 = strlen(pcVar30);\n              lVar27 = sVar20 + 2;\n              if (pcVar35 != (char *)0x0) goto LAB_001066bc;\n              pcVar35 = (char *)xmalloc(lVar27);\nLAB_001066d0:\n              pcVar22 = pcVar35 + 1;\n              *pcVar35 = *(char *)(*(long *)(param_7 + 8) + 0x1c);\n            }\n            __s = DAT_00127908;\n            if (DAT_00127908 != (char *)0x0) {\n              strcpy(pcVar22,DAT_00127908);\n              sVar20 = strlen(__s);\n              pcVar22 = pcVar22 + sVar20;\n            }\n            strcpy(pcVar22,pcVar30);\n            plVar4[1] = (long)pcVar35;\n            pcVar30 = pcVar35;\n            uVar28 = uVar23;\n          }\nLAB_00105b32:\n          if (DAT_00127a2c == 7) goto LAB_001067a8;\n          if (((uVar11 & 0x20) == 0) &&\n             (((uVar11 & 0x100) == 0 ||\n              ((*(byte *)(**(long **)(plVar4[4] + 0xf0) + 0x18) & 0x20) == 0)))) {\n            if (((uStack0000000000000048 == 0) &&\n                (((uVar11 & 0x82) != 0 || ((*(byte *)(plVar4[4] + 0x25) & 0x10) != 0)))) ||\n               (iVar12 = bfd_decode_symclass(plVar4), iVar12 == 0x49)) {\nLAB_00105be2:\n              if (DAT_001279ca == '\\0') {\n                lVar27 = htab_find();\n                if (lVar27 == 0) goto LAB_00105c07;\n              }\n              else {\n                _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n                in_stack_00000140 = pcVar30;\n                htab_traverse(DAT_001279f8,pattern_match_0011a170,&stack0x00000140);\n                if (cStack0000000000000148 == '\\0') goto LAB_00105c07;\n              }\n            }\n            else if ((((uVar11 & 0x82) == 0) && (pcVar5 != bfd_map_over_sections)) &&\n                    ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)) {\n              if ((uVar11 & 4) == 0) {\n                if (((*(int *)(unaff_R14[1] + 8) != 2) ||\n                    (lVar27 = *(long *)(plVar4[4] + 0xd0), lVar27 == 0)) ||\n                   (*(long *)(lVar27 + 0x40) == 0)) {\n                  if ((DAT_00127a2c == 3) || (DAT_00127a28 == 2)) goto LAB_001067a8;\n                  if (DAT_00127a28 == 1) {\n                    cVar10 = bfd_is_local_label(unaff_R14);\n                    goto joined_r0x00106a11;\n                  }\n                }\n                goto LAB_00105be2;\n              }\n              cVar10 = DAT_00127980;\n              if (1 < DAT_00127a2c - 2U) {\njoined_r0x00106a11:\n                if (cVar10 == '\\0') goto LAB_00105be2;\n              }\n            }\n            else if (DAT_00127a2c != 3) goto LAB_00105be2;\n            goto LAB_001067a8;\n          }\n          if (DAT_001279ca == '\\0') {\n            lVar27 = htab_find();\n            if (lVar27 != 0) {\nLAB_0010687f:\n              uVar19 = dcgettext(0,\"not stripping symbol `%s\\' because it is named in a relocation\",\n                                 5);\n              print_error_message_00119ed0(uVar19);\n              DAT_00127a20 = 1;\n            }\n          }\n          else {\n            _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n            in_stack_00000140 = pcVar30;\n            htab_traverse(DAT_001279f8,pattern_match_0011a170,&stack0x00000140);\n            if (cStack0000000000000148 != '\\0') goto LAB_0010687f;\n          }\n          if ((uVar11 & 0x20) == 0) {\nLAB_00105c07:\n            if (DAT_001279ca != '\\0') {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              in_stack_00000140 = pcVar30;\n              htab_traverse(DAT_001279f0,pattern_match_0011a170,&stack0x00000140);\n              if (cStack0000000000000148 != '\\0') goto LAB_001067a8;\n              goto LAB_00105c2c;\n            }\n            lVar27 = htab_find();\n            if (lVar27 == 0) goto LAB_00105c2c;\nLAB_001067a8:\n            if ((DAT_00127a18 != '\\0') && ((uVar11 & 0x4000) != 0)) goto LAB_00105c2c;\n            if (DAT_001279ca == '\\0') {\n              lVar27 = htab_find();\n              if (lVar27 != 0) goto LAB_00105c2c;\n            }\n            else {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              in_stack_00000140 = pcVar30;\n              htab_traverse(DAT_00127a08,pattern_match_0011a170,&stack0x00000140);\n              if (cStack0000000000000148 != '\\0') goto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            cVar10 = process_section_data_001159d0(plVar4[4]);\n            if (cVar10 == '\\0') {\n              if (((uVar11 & 0x800002) == 0) && (pcVar5 != bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uVar11 & 0x82) != 0) {\n                  cVar10 = find_value_00115d70(pcVar30);\n                  if ((cVar10 == '\\0') &&\n                     ((lVar27 = htab_elements(DAT_001279d8), lVar27 == 0 ||\n                      (cVar10 = find_value_00115d70(pcVar30), cVar10 != '\\0')))) {\n                    if (((((DAT_00127938 == '\\0') ||\n                          (uVar13 = *(uint *)(plVar4 + 3), (uVar13 & 0x200000) != 0)) ||\n                         (lVar27 = *plVar4, lVar27 == 0)) ||\n                        ((*(int *)(*(long *)(lVar27 + 8) + 8) != 5 ||\n                         (*(long *)(lVar27 + 0x110) == 0)))) ||\n                       (1 < (*(byte *)((long)plVar4 + 0x49) & 3) - 1)) goto joined_r0x00105ca2;\n                  }\n                  else {\n                    uVar13 = *(uint *)(plVar4 + 3);\n                  }\n                  *(uint *)(plVar4 + 3) = uVar13 & 0xffffff7d | 1;\n                }\njoined_r0x00105ca2:\n                if (((uVar11 & 1) != 0) && (cVar10 = find_value_00115d70(pcVar30), cVar10 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((DAT_001279c8 != '\\0') || (cVar10 = find_value_00115d70(pcVar30), cVar10 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xff7ffffd | 0x80;\n                }\n                if (pcVar5 != bfd_map_over_sections) goto LAB_00105c5f;\n              }\n              plVar16[uVar28] = (long)plVar4;\n              uVar28 = uVar28 + 1;\n            }\n          }\n          _in_stack_00000018 = _in_stack_00000018 + 1;\n        } while (uStack0000000000000010 != _in_stack_00000018);\n      }\n      if (DAT_001279a8 != (undefined8 *)0x0) {\n        puVar31 = DAT_001279a8;\n        iVar12 = DAT_001279a0;\n        for (lVar27 = 0; lVar27 < iVar12; lVar27 = lVar27 + 1) {\n          pcVar35 = (char *)puVar31[5];\n          if (pcVar35 == (char *)0x0) {\n            plVar6 = plVar16 + uVar28;\n            uVar28 = uVar28 + 1;\n            lVar17 = update_section_info_0011a2e0(puVar31,param_7);\n            *plVar6 = lVar17;\n            iVar12 = DAT_001279a0;\n          }\n          else if (pcVar35 != \"\") {\n            uVar19 = dcgettext(0,\"\\'before=%s\\' not found\",5);\n                    \n            print_error_and_exit_00119dd0(uVar19,pcVar35);\n          }\n          puVar31 = (undefined8 *)*puVar31;\n        }\n      }\n      bVar41 = DAT_00127980 == '\\0';\n      plVar16[uVar28] = 0;\n      if ((bVar41) || (puStack0000000000000020 == (undefined4 *)0x0)) {\nLAB_00105cfa:\n        uStack0000000000000010 = uVar28 & 0xffffffff;\n        goto LAB_00105710;\n      }\n      iVar12 = *(int *)(*(undefined8 **)(param_7 + 8) + 1);\n      if ((iVar12 == 5) || (iVar12 == 2)) {\n        in_stack_000000e0 = (void *)0x0;\n        cVar10 = extract_binary_data_0011378f(param_7,puStack0000000000000020,&stack0x000000c0,&stack0x00000110,\n                              &stack0x000000e0,&stack0x00000140);\n        if (cVar10 != '\\0') {\n          lVar27 = bfd_make_section_with_flags(param_7,\".stab\",0x2108);\n          lVar17 = bfd_make_section_with_flags(param_7,\".stabstr\",0x2108);\n          if ((((lVar27 == 0) || (lVar17 == 0)) ||\n              (cVar10 = bfd_set_section_size(lVar27,in_stack_00000110), cVar10 == '\\0')) ||\n             (cVar10 = bfd_set_section_size(lVar17,in_stack_00000140), cVar10 == '\\0')) {\n            pcVar35 = \"can\\'t create debugging section\";\n          }\n          else {\n            *(undefined4 *)(lVar27 + 0x7c) = 2;\n            *(undefined4 *)(lVar17 + 0x7c) = 0;\n            cVar10 = bfd_set_section_contents(param_7,lVar27,in_stack_000000c0,0,in_stack_00000110);\n            if ((cVar10 != '\\0') &&\n               (cVar10 = bfd_set_section_contents\n                                   (param_7,lVar17,in_stack_000000e0,0,in_stack_00000140),\n               cVar10 != '\\0')) {\n              free(puStack0000000000000020);\n              goto LAB_00105cfa;\n            }\n            pcVar35 = \"can\\'t set debugging section contents\";\n          }\n          uVar19 = dcgettext(0,pcVar35,5);\n          display_error_001126c0(0,param_7,0,uVar19);\n          free(in_stack_000000e0);\n          free(puStack0000000000000020);\n          goto LAB_00105d96;\n        }\n      }\n      else {\n        uVar19 = **(undefined8 **)(param_7 + 8);\n        uVar18 = dcgettext(0,\"don\\'t know how to write debugging information for %s\",5);\n        display_error_001126c0(0,param_7,0,uVar18,uVar19);\n      }\n      free(puStack0000000000000020);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections();\n      iVar12 = bfd_get_error();\n      if (iVar12 == 0) goto LAB_00105a3b;\n    }\nLAB_00105d96:\n    DAT_00127a20 = 1;\n  }\n  else {\n    if ((DAT_00127a2c - 3U < 4) || ((DAT_00127a28 != 0 || (DAT_00127938 != '\\0'))))\n    goto LAB_00105a07;\n    lVar27 = htab_elements(DAT_001279f8);\n    if (((lVar27 != 0) ||\n        (((((((lVar27 = htab_elements(DAT_00127a08), lVar27 != 0 ||\n              (lVar27 = htab_elements(DAT_001279e8), lVar27 != 0)) ||\n             (lVar27 = htab_elements(DAT_001279e0), lVar27 != 0)) ||\n            ((lVar27 = htab_elements(DAT_001279d8), lVar27 != 0 ||\n             (lVar27 = htab_elements(DAT_001279d0), lVar27 != 0)))) ||\n           (lVar27 = htab_elements(DAT_001278d0), lVar27 != 0)) ||\n          (((DAT_00127908 != (char *)0x0 || (DAT_001278b8 != '\\0')) ||\n           ((DAT_00127a19 != '\\0' ||\n            (((DAT_00127980 != '\\0' || (DAT_00127988 != '\\0')) || (DAT_00127968 != '\\0')))))))) ||\n         ((DAT_001278d8 != (char **)0x0 || (DAT_001279c8 != '\\0')))))) || (DAT_001279a0 != 0))\n    goto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(param_7,DAT_001278a8,uStack0000000000000010 & 0xffffffff);\n    bfd_map_over_sections(unaff_R14,process_section_data_00115dc0,param_7);\n    bfd_map_over_sections(unaff_R14,reverse_section_contents_00116110,param_7);\n    for (puVar31 = DAT_001279c0; puVar37 = DAT_001279b8, puVar31 != (undefined8 *)0x0;\n        puVar31 = (undefined8 *)*puVar31) {\n      cVar10 = bfd_set_section_contents(param_7,puVar31[5],puVar31[4],0,puVar31[3]);\n      if (cVar10 == '\\0') {\n        display_error_001126c0(0,param_7,puVar31[5],0);\n        return 0;\n      }\n    }\n    for (; puVar37 != (undefined8 *)0x0; puVar37 = (undefined8 *)*puVar37) {\n      uVar19 = *(undefined8 *)(puVar37[5] + 0x60);\n      cVar10 = bfd_set_section_contents(param_7,uVar19,puVar37[4],0,puVar37[3]);\n      if (cVar10 == '\\0') {\n        display_error_001126c0(0,param_7,uVar19,0);\n        return 0;\n      }\n    }\n    if (__ptr_01 == (long **)0x0) {\n      if ((DAT_00127a00 != '\\0') && (_DAT_00127a24 == 0)) {\n        uVar19 = *unaff_R14;\n        uVar18 = dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n        print_error_message_00119ed0(uVar18,uVar19);\n      }\n    }\n    else {\n      pplVar34 = (long **)0x0;\n      for (puVar31 = *(undefined8 **)(param_7 + 0x90); puVar31 != (undefined8 *)0x0;\n          puVar31 = (undefined8 *)puVar31[1]) {\n        if (((DAT_00127a00 != '\\0') && (*(int *)(*(long *)(param_7 + 8) + 8) == 5)) &&\n           ((*(int *)(puVar31[0x1a] + 4) == 7 &&\n            (cVar10 = compare_strings_00113fb0(*puVar31,\".gnu.build.attributes\"), cVar10 != '\\0')))) {\n          if (pplVar34 == (long **)0x0) {\n            pplVar34 = __ptr_01;\n          }\n          pplVar29 = __ptr_01;\n          if ((undefined8 *)(*pplVar34)[0xc] == puVar31) {\nLAB_0010625f:\n            pcVar35 = \"error: failed to merge notes\";\n            if (pplVar34[1] != (long *)0x0) {\n              cVar10 = bfd_set_section_contents(param_7,puVar31,pplVar34[1],0,pplVar34[2]);\n              if (cVar10 == '\\0') {\n                uVar19 = dcgettext(0,\"error: failed to copy merged notes into output\",5);\n                display_error_001126c0(0,param_7,puVar31,uVar19);\n                return 0;\n              }\n              pplVar34 = (long **)pplVar34[3];\n              goto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              pplVar34 = pplVar29;\n              if ((undefined8 *)(*pplVar29)[0xc] == puVar31) goto LAB_0010625f;\n              pplVar34 = (long **)pplVar29[3];\n              pplVar29 = pplVar34;\n            } while (pplVar34 != (long **)0x0);\n            pcVar35 = \"error: failed to locate merged notes\";\n          }\n          uVar19 = dcgettext(0,pcVar35,5);\n          display_error_001126c0(0,param_7,puVar31,uVar19);\n        }\nLAB_001061be:\n      }\n      do {\n        pplVar34 = (long **)__ptr_01[3];\n        free(__ptr_01[1]);\n        free(__ptr_01);\n        __ptr_01 = pplVar34;\n      } while (pplVar34 != (long **)0x0);\n    }\n    if ((DAT_00127a10 == 0) ||\n       (cVar10 = bfd_fill_in_gnu_debuglink_section(param_7,lStack0000000000000078),\n       lVar27 = DAT_00127a10, cVar10 != '\\0')) {\n      uVar11 = (**(code **)(*(long *)(param_7 + 8) + 0x140))(unaff_R14);\n      uVar28 = (ulong)uVar11;\n      if ((char)uVar11 != '\\0') {\n        if (DAT_00127910 == 0) {\n          return uVar28;\n        }\n        cVar10 = bfd_alt_mach_code(param_7,DAT_00127910 & 0xffffffff);\n        uVar23 = DAT_00127910;\n        if (cVar10 == '\\0') {\n          uVar19 = dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n          print_error_message_00119ed0(uVar19,uVar23);\n          if (*(int *)(*(long *)(param_7 + 8) + 8) == 5) {\n            uVar19 = dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n            print_error_message_00119ed0(uVar19);\n            *(short *)(*(long *)(param_7 + 0x110) + 0x3a) = (short)DAT_00127910;\n            return uVar28;\n          }\n          uVar19 = dcgettext(0,\"ignoring the alternative value\",5);\n          print_error_message_00119ed0(uVar19);\n          return uVar28;\n        }\n        return uVar28;\n      }\n      uVar19 = dcgettext(0,\"error copying private BFD data\",5);\n      display_error_001126c0(0,param_7,0,uVar19);\n    }\n    else {\n      uVar19 = dcgettext(0,\"cannot fill debug link section `%s\\'\",5);\n      display_error_001126c0(0,param_7,0,uVar19,lVar27);\n    }\n  }\n  return 0;\nLAB_00115187:\n  if ((((*(int *)(unaff_R14[1] + 8) == 5) && (*(int *)((long)pplVar34[0x1a] + 4) == 7)) &&\n      (cVar10 = compare_strings_00113fb0(*pplVar34), cVar10 != '\\0')) &&\n     ((pplVar34[0xc] != (long *)0x0 && (plVar6 = pplVar34[8], plVar6 != (long *)0x0)))) {\n    pplVar29 = (long **)xmalloc(0x20);\n    pplVar29[1] = (long *)0x0;\n    cVar10 = bfd_get_full_section_contents();\n    if (cVar10 == '\\0') {\n      dcgettext(0,\"warning: could not load note section\",5);\n      display_error_001126c0(0);\n      free(pplVar29);\n    }\n    else {\n      plVar16 = (long *)parse_gnu_build_attribute_notes_001163d0();\n      pplVar29[2] = plVar16;\n      if ((plVar16 == plVar6) || (cVar10 = bfd_set_section_size(pplVar34[0xc]), cVar10 != '\\0')) {\n        pplVar29[3] = (long *)__ptr_01;\n        *pplVar29 = (long *)pplVar34;\n        __ptr_01 = pplVar29;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        display_error_001126c0(0,param_7,pplVar34);\n        free(pplVar29[1]);\n        free(pplVar29);\n      }\n    }\n  }\n  pplVar34 = (long **)pplVar34[1];\n  puVar31 = DAT_001279b0;\n  if (pplVar34 == (long **)0x0) goto joined_r0x001151c7;\n  goto LAB_001151ab;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00119ed0",
                "FUN_001125fa",
                "FUN_00107880"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x001152b6",
            "calling": [
                "FUN_00107976"
            ],
            "imported": false,
            "current_name": "FUNC_001152b6"
        },
        "FUN_00114cf0": {
            "renaming": {
                "FUN_00114cf0": "allocate_file_path_00114cf0",
                "param_1": "path",
                "pcVar1": "lastSlash",
                "lVar2": "pathLength",
                "lVar3": "allocateLength",
                "lVar4": "slashIndex",
                "pcVar5": "dest",
                "bVar6": "isSlash"
            },
            "code": "\nvoid allocateFilePath_00114cf0(char *path)\n\n{\n  char *lastSlash;\n  long pathLength;\n  long allocateLength;\n  long slashIndex;\n  char *dest;\n  byte isSlash;\n  \n  isSlash = 0;\n  lastSlash = strrchr(path,0x2f);\n  if (lastSlash == (char *)0x0) {\n    lastSlash = (char *)xmalloc(9);\n    allocateLength = 0;\n  }\n  else {\n    slashIndex = (long)lastSlash - (long)path;\n    lastSlash = (char *)xmalloc(slashIndex + 0xb);\n    allocateLength = slashIndex + 1;\n    dest = lastSlash;\n    for (pathLength = slashIndex; pathLength != 0; pathLength = pathLength + -1) {\n      *dest = *path;\n      path = path + (ulong)isSlash * -2 + 1;\n      dest = dest + (ulong)isSlash * -2 + 1;\n    }\n    lastSlash[slashIndex] = '/';\n  }\n  *(undefined8 *)(lastSlash + allocateLength) = 0x5858585858587473;\n  *(undefined *)((long)(lastSlash + allocateLength) + 8) = 0;\n  return;\n}\n\n",
            "called": [
                "xmalloc",
                "strrchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114cf0",
            "calling": [
                "FUN_0011a0e0",
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "allocate_file_path_00114cf0"
        },
        "FUN_0010a181": {
            "renaming": {
                "FUN_0010a181": "process_data_0010a181",
                "param_1": "dataStruct",
                "param_2": "start",
                "param_3": "end",
                "param_4": "option",
                "cVar1": "itemFlag",
                "__s": "item1",
                "__s_00": "item2",
                "sVar5": "size1",
                "sVar6": "size2",
                "__s_01": "newData",
                "lVar7": "counter",
                "local_41": "flag",
                "iVar2": "factor",
                "iVar3": "total",
                "uVar4": "result"
            },
            "code": "\nundefined4 processData_0010a181(long dataStruct,long start,long end,byte option)\n\n{\n  char itemFlag;\n  int factor;\n  int total;\n  undefined4 result;\n  char *item1;\n  char *item2;\n  size_t size1;\n  size_t size2;\n  char *newData;\n  long counter;\n  byte flag;\n  \n  itemFlag = *(char *)(*(long *)(dataStruct + 0x60) + 0x1c);\n  item1 = (char *)extract_list_item_00109b2f();\n  flag = 1;\n  if (itemFlag == '\\0') {\n    flag = *(byte *)(*(long *)(dataStruct + 0x60) + 0x1c);\n  }\n  factor = *(int *)(*(long *)(dataStruct + 0x60) + 0x18);\n  item2 = (char *)extract_list_item_00109b2f(dataStruct);\n  size1 = strlen(item1);\n  size2 = strlen(item2);\n  newData = (char *)xmalloc(size1 + 100 + size2);\n  if (option == 0) {\n    *newData = '\\0';\n    counter = 0;\n    flag = flag & 1;\n  }\n  else {\n    counter = *(long *)(dataStruct + 0x68);\n    *(long *)(dataStruct + 0x68) = counter + 1;\n    sprintf(newData,\"%ld=@S;\",counter);\n    flag = option;\n  }\n  size1 = strlen(newData);\n  sprintf(newData + size1,\"ar%s;%ld;%ld;%s\",item1,start,end,item2);\n  free(item1);\n  free(item2);\n  total = 0;\n  if (start <= end) {\n    total = factor * (((int)end - (int)start) + 1);\n  }\n  result = allocate_and_initialize_data_00109b52(dataStruct,newData,counter,flag,total);\n  if ((char)result != '\\0') {\n    free(newData);\n  }\n  return result;\n}\n\n",
            "called": [
                "strlen",
                "free",
                "xmalloc",
                "sprintf",
                "FUN_00109b2f",
                "FUN_00109b52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a181",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "process_data_0010a181"
        },
        "memcpy": {
            "renaming": {},
            "code": "\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memcpy(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104540",
            "calling": [
                "FUN_00116b90",
                "FUN_0011a480"
            ],
            "imported": false,
            "current_name": "memcpy"
        },
        "FUN_001199d0": {
            "renaming": {
                "FUN_001199d0": "print_binary_file_info_001199d0",
                "iVar1": "columns",
                "iVar2": "archIndex",
                "iVar3": "comparedResult",
                "pcVar4": "headerString",
                "sVar5": "headerLen",
                "pcVar6": "tempFileTemplate",
                "uVar7": "result",
                "piVar8": "errorCode",
                "iVar9": "targetIndex",
                "lVar10": "i",
                "lVar11": "j",
                "ppcVar12": "targetData",
                "uVar13": "maxArchNameLen",
                "uVar14": "len",
                "local_70": "errMsg"
            },
            "code": "\n\n\nvoid printBinaryFileInfo_001199d0(void)\n\n{\n  int columns;\n  int archIndex;\n  int comparedResult;\n  char *headerString;\n  size_t headerLen;\n  char *tempFileTemplate;\n  undefined8 result;\n  int *errorCode;\n  int targetIndex;\n  long i;\n  long j;\n  char **targetData;\n  uint maxArchNameLen;\n  ulong len;\n  int errMsg;\n  \n  headerString = (char *)dcgettext(0,\"BFD header file version %s\\n\",5);\n  printf(headerString,\"(GNU Binutils for Debian) 2.40\");\n  if (DAT_001278c0 == (char *)0x0) {\n    headerString = getenv(\"TMPDIR\");\n    result = check_directory_access_0011283f(headerString,0);\n    headerString = getenv(\"TMP\");\n    result = check_directory_access_0011283f(headerString,result);\n    headerString = getenv(\"TEMP\");\n    result = check_directory_access_0011283f(headerString,result);\n    result = check_directory_access_0011283f(&DAT_0011b39a,result);\n    result = check_directory_access_0011283f(\"/var/tmp\",result);\n    headerString = (char *)check_directory_access_0011283f(&DAT_00120324,result);\n    if (headerString == (char *)0x0) {\n      headerString = \".\";\n    }\n    headerLen = strlen(headerString);\n    tempFileTemplate = (char *)xmalloc((int)headerLen + 2);\n    DAT_001278c0 = strcpy(tempFileTemplate,headerString);\n    DAT_001278c0[headerLen & 0xffffffff] = '/';\n    DAT_001278c0[(int)headerLen + 1] = '\\0';\n  }\n  headerString = DAT_001278c0;\n  headerLen = strlen(DAT_001278c0);\n  i = (long)(int)headerLen;\n  tempFileTemplate = (char *)xmalloc(i + 9);\n  strcpy(tempFileTemplate,headerString);\n  *(undefined2 *)(tempFileTemplate + i) = 0x6363;\n  *(undefined4 *)(tempFileTemplate + i + 2) = 0x58585858;\n  *(undefined4 *)((long)(tempFileTemplate + i + 2) + 3) = 0x585858;\n  tempFileTemplate[i + 8] = '\\0';\n  archIndex = mkstemps(tempFileTemplate,0);\n  if (archIndex == -1) {\n    errorCode = __errno_location();\n    tempFileTemplate = strerror(*errorCode);\n    fprintf(_stderr,\"Cannot create temporary file in %s: %s\\n\",headerString,tempFileTemplate);\n                    \n    abort();\n  }\n  archIndex = close(archIndex);\n  if (archIndex != 0) {\n                    \n    abort();\n  }\n  maxArchNameLen = 0;\n  archIndex = 2;\n  bfd_iterate_over_targets(process_input_data_00119f70);\n  unlink(tempFileTemplate);\n  free(tempFileTemplate);\n  errMsg = 0;\n  do {\n    headerString = (char *)bfd_printable_arch_mach(archIndex);\n    headerLen = strlen(headerString);\n    if ((int)maxArchNameLen < (int)(uint)headerLen) {\n      maxArchNameLen = (uint)headerLen;\n    }\n    archIndex = archIndex + 1;\n  } while (archIndex != 0x57);\n  headerString = getenv(\"COLUMNS\");\n  archIndex = errMsg;\n  if (headerString != (char *)0x0) {\n    i = strtol(headerString,(char **)0x0,10);\n    columns = (int)i;\n    if (columns != 0) goto LAB_00119b11;\n  }\n  columns = 0x50;\nLAB_00119b11:\n  do {\n    errMsg = archIndex;\n    if (-1 < errMsg) {\n      return;\n    }\n    j = (long)errMsg;\n    targetIndex = (columns - maxArchNameLen) + -1;\n    i = j;\n    do {\n      archIndex = (int)i;\n      if (-1 < archIndex) break;\n      headerLen = strlen(*(char **)(i * 0x60));\n      i = i + 1;\n      targetIndex = (targetIndex - (int)headerLen) + -1;\n    } while (-1 < targetIndex);\n    printf(\"\\n%*s\",(ulong)(maxArchNameLen + 1),&DAT_0011b4a1);\n    for (targetData = (char **)(j * 0x60);\n        ((ulong)(uint)(archIndex - errMsg) + j) * 0x60 - (long)targetData != 0;\n        targetData = targetData + 0xc) {\n      printf(\"%s \",*targetData);\n    }\n    targetIndex = 2;\n    putc(10,_stdout);\n    do {\n      headerString = (char *)bfd_printable_arch_mach(targetIndex,0);\n      comparedResult = strcmp(headerString,\"UNKNOWN!\");\n      if (comparedResult != 0) {\n        result = bfd_printable_arch_mach(targetIndex,0);\n        printf(\"%*s \",(ulong)maxArchNameLen,result);\n        targetData = (char **)(j * 0x60);\n        comparedResult = errMsg;\n        while (archIndex != comparedResult) {\n          if (*(char *)((long)targetData + (ulong)(targetIndex - 2) + 8) == '\\0') {\n            headerLen = strlen(*targetData);\n            for (len = headerLen & 0xffffffff; (int)len != 0; len = (ulong)((int)len - 1)) {\n              putc(0x2d,_stdout);\n            }\n          }\n          else {\n            fputs(*targetData,_stdout);\n          }\n          comparedResult = comparedResult + 1;\n          if (archIndex != comparedResult) {\n            putc(0x20,_stdout);\n          }\n          targetData = targetData + 0xc;\n        }\n        putc(10,_stdout);\n      }\n      targetIndex = targetIndex + 1;\n    } while (targetIndex != 0x57);\n  } while( true );\n}\n\n",
            "called": [
                "close",
                "abort",
                "getenv",
                "strlen",
                "fprintf",
                "bfd_printable_arch_mach",
                "xmalloc",
                "dcgettext",
                "FUN_00104943",
                "FUN_00119f70",
                "__errno_location",
                "unlink",
                "FUN_0011283f",
                "free",
                "strerror",
                "mkstemps",
                "bfd_iterate_over_targets",
                "strcpy",
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001199d0",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "print_binary_file_info_001199d0"
        },
        "FUN_0010847a": {
            "renaming": {
                "FUN_0010847a": "initialize_system_0010847a"
            },
            "code": "\nvoid initializeSystem_0010847a(void)\n\n{\n  parse_gnu_build_attribute_notes_00116490();\n  return;\n}\n\n",
            "called": [
                "FUN_00116490"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010847a",
            "calling": [
                "FUN_001086af"
            ],
            "imported": false,
            "current_name": "initialize_system_0010847a",
            "code_backup": "\nvoid FUN_0010847a(void)\n\n{\n  FUNC_00116490();\n  return;\n}\n\n"
        },
        "FUN_0010d21c": {
            "renaming": {
                "FUN_0010d21c": "parse_and_validate_input_0010d21c",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "bVar1": "byte1",
                "pbVar2": "currentByte",
                "bVar3": "byte3",
                "cVar4": "char1",
                "bVar5": "byte5",
                "uVar6": "result",
                "iVar7": "intVar",
                "uVar8": "uintVar",
                "sVar9": "strLength",
                "pbVar10": "strPointer",
                "__ptr": "ptr1",
                "__ptr_00": "ptr2",
                "__haystack": "haystackStr",
                "pcVar11": "pcVar1",
                "uVar12": "result",
                "pcVar13": "pcVar2",
                "bVar14": "byte14",
                "pcVar15": "pcVar3",
                "bVar16": "byte16",
                "bVar17": "byte17",
                "bVar18": "byte18",
                "bVar19": "byte19",
                "uVar20": "loopCounter",
                "uVar21": "ulongVar",
                "local_3c": "arrayOfThreeUInts"
            },
            "code": "\nundefined4 parseAndValidateInput_0010d21c(undefined8 param1,byte **param2,undefined8 *param3)\n\n{\n  byte byte1;\n  byte *currentByte;\n  byte byte3;\n  char char1;\n  byte byte5;\n  undefined4 result;\n  int intVar;\n  uint uintVar;\n  size_t strLength;\n  byte *strPointer;\n  void *ptr1;\n  void *ptr2;\n  char *haystackStr;\n  char *pcVar1;\n  undefined8 result;\n  char *pcVar2;\n  byte byte14;\n  char *pcVar3;\n  byte byte16;\n  byte byte17;\n  byte byte18;\n  byte byte19;\n  uint loopCounter;\n  ulong ulongVar;\n  uint arrayOfThreeUInts [3];\n  \n  currentByte = *param2;\n  *param2 = currentByte + 1;\n  arrayOfThreeUInts[0] = parse_integer_00108e76(param2);\n  ulongVar = (ulong)arrayOfThreeUInts[0];\n  if (arrayOfThreeUInts[0] != 0) {\n    strPointer = *param2;\n    strLength = strlen((char *)strPointer);\n    if (ulongVar <= strLength) {\n      *param2 = strPointer + ulongVar;\n      loopCounter = 0;\n      result = parse_integer_00108ea1(param2,arrayOfThreeUInts);\n      if ((char)result != '\\0') {\nLAB_0010d2b4:\n        if (arrayOfThreeUInts[0] <= loopCounter) {\n          if (param3 == (undefined8 *)0x0) {\n            return result;\n          }\n          ptr1 = (void *)copy_and_null_terminate_00109a0b(currentByte,(int)*param2 - (int)currentByte);\n          ptr2 = (void *)concat(\"NoSuchStrinG__\",ptr1,0);\n          free(ptr1);\n          haystackStr = (char *)cplus_demangle(ptr2,2);\n          free(ptr2);\n          if ((haystackStr != (char *)0x0) &&\n             (pcVar1 = strstr(haystackStr,\"::NoSuchStrinG\"), pcVar2 = haystackStr,\n             pcVar3 = haystackStr, pcVar1 != (char *)0x0)) {\n            for (; pcVar2 != pcVar1; pcVar2 = pcVar2 + 1) {\n              if ((*pcVar2 != ' ') ||\n                 (((pcVar2[1] == '>' && (haystackStr < pcVar2)) && (pcVar2[-1] == '>')))) {\n                *pcVar3 = *pcVar2;\n                pcVar3 = pcVar3 + 1;\n              }\n            }\n            result = copy_and_null_terminate_00109a0b(haystackStr,(int)pcVar3 - (int)haystackStr);\n            *param3 = result;\n            free(haystackStr);\n            return result;\n          }\n          print_error_message_0010911f(currentByte);\n          free(haystackStr);\n          return 0;\n        }\n        strPointer = *param2;\n        if (*strPointer != 0x5a) {\n          byte5 = parse_initialize_data_0010c95e(param1,param2,0);\n          if (byte5 == 0) {\n            return 0;\n          }\n          byte3 = 0;\n          byte14 = 0;\n          byte18 = 0;\n          byte17 = 0;\n          byte19 = 0;\nLAB_0010d2e9:\n          do {\n            do {\n              byte16 = byte3;\n              byte1 = *strPointer;\n              if ((byte14 | byte1 == 0) != 0) {\n                byte5 = 0;\n                goto switchD_0010d329_caseD_70;\n              }\n              byte3 = byte5;\n              byte14 = byte5;\n            } while ('v' < (char)byte1);\n            if ((char)byte1 < 'b') {\n              if ((char)byte1 < 'U') {\n                if ((char)byte1 < 'C') goto LAB_0010d2e9;\n                ulongVar = 1L << (byte1 + 0xbd & 0x3f);\n                if ((ulongVar & 0x11409) == 0) {\n                  if ((ulongVar & 0xa000) != 0) goto switchD_0010d329_caseD_70;\n                  if (byte1 == 0x54) goto switchD_0010d329_caseD_76;\n                  goto LAB_0010d2e9;\n                }\n              }\n              else if (1 < (byte)(byte1 + 0xab)) goto LAB_0010d2e9;\n              strPointer = strPointer + 1;\n              byte3 = byte16;\n              byte14 = 0;\n              goto LAB_0010d2e9;\n            }\n            switch(byte1) {\n            case 0x62:\n              byte3 = byte16;\n              byte18 = byte5;\n              break;\n            case 99:\n              byte3 = byte16;\n              byte19 = byte5;\n              break;\n            case 100:\n            case 0x66:\n            case 0x72:\n              byte3 = byte16;\n              byte17 = byte5;\n              break;\n            case 0x70:\n              goto switchD_0010d329_caseD_70;\n            case 0x76:\nswitchD_0010d329_caseD_76:\n                    \n              abort();\n            }\n          } while( true );\n        }\n        *param2 = strPointer + 1;\n        char1 = parse_initialize_data_0010c95e(param1,param2,0);\n        if (char1 == '\\0') {\n          return 0;\n        }\n        goto LAB_0010d2b1;\n      }\n    }\n  }\nLAB_0010d280:\n  print_error_message_0010911f(currentByte);\n  return 0;\nswitchD_0010d329_caseD_70:\n  if (byte16 == 0) {\n    if (byte19 == 0) {\n      if (byte18 == 0) {\n        if (byte17 == 0) {\n          if (byte5 != 0) {\n            uintVar = parse_integer_00108e76(param2);\n            if (uintVar == 0) goto LAB_0010d280;\n            *param2 = *param2 + uintVar;\n          }\n        }\n        else {\n          if (**param2 == 0x6d) {\n            *param2 = *param2 + 1;\n          }\n          while( true ) {\n            strPointer = *param2;\n            if (((&_sch_istable)[(ulong)*strPointer * 2] & 4) == 0) break;\n            *param2 = strPointer + 1;\n          }\n          if (*strPointer == 0x2e) {\n            do {\n              strPointer = strPointer + 1;\n              *param2 = strPointer;\n            } while (((&_sch_istable)[(ulong)*strPointer * 2] & 4) != 0);\n          }\n          strPointer = *param2;\n          if (*strPointer == 0x65) {\n            do {\n              strPointer = strPointer + 1;\n              *param2 = strPointer;\n            } while (((&_sch_istable)[(ulong)*strPointer * 2] & 4) != 0);\n          }\n        }\n      }\n      else {\n        uintVar = parse_integer_00108e76(param2);\n        if (1 < uintVar) goto LAB_0010d280;\n      }\n    }\n    else {\n      if (**param2 == 0x6d) {\n        *param2 = *param2 + 1;\n      }\n      intVar = parse_integer_00108e76(param2);\n      if (intVar == 0) goto LAB_0010d280;\n    }\n  }\n  else {\n    if (**param2 == 0x6d) {\n      *param2 = *param2 + 1;\n    }\n    while (((&_sch_istable)[(ulong)**param2 * 2] & 4) != 0) {\n      *param2 = *param2 + 1;\n    }\n  }\nLAB_0010d2b1:\n  loopCounter = loopCounter + 1;\n  goto LAB_0010d2b4;\n}\n\n",
            "called": [
                "FUN_00108e76",
                "abort",
                "FUN_0010c95e",
                "strlen",
                "free",
                "cplus_demangle",
                "FUN_00109a0b",
                "FUN_00108ea1",
                "concat",
                "strstr",
                "FUN_0010911f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010d21c",
            "calling": [
                "FUN_0010d559",
                "FUN_0010c95e",
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "parse_and_validate_input_0010d21c",
            "code_backup": "\nundefined4 FUN_0010d21c(undefined8 param_1,byte **param_2,undefined8 *param_3)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  byte bVar3;\n  char cVar4;\n  byte bVar5;\n  undefined4 uVar6;\n  int iVar7;\n  uint uVar8;\n  size_t sVar9;\n  byte *pbVar10;\n  void *__ptr;\n  void *__ptr_00;\n  char *__haystack;\n  char *pcVar11;\n  undefined8 uVar12;\n  char *pcVar13;\n  byte bVar14;\n  char *pcVar15;\n  byte bVar16;\n  byte bVar17;\n  byte bVar18;\n  byte bVar19;\n  uint uVar20;\n  ulong uVar21;\n  uint local_3c [3];\n  \n  pbVar2 = *param_2;\n  *param_2 = pbVar2 + 1;\n  local_3c[0] = parse_integer_00108e76(param_2);\n  uVar21 = (ulong)local_3c[0];\n  if (local_3c[0] != 0) {\n    pbVar10 = *param_2;\n    sVar9 = strlen((char *)pbVar10);\n    if (uVar21 <= sVar9) {\n      *param_2 = pbVar10 + uVar21;\n      uVar20 = 0;\n      uVar6 = parse_integer_00108ea1(param_2,local_3c);\n      if ((char)uVar6 != '\\0') {\nLAB_0010d2b4:\n        if (local_3c[0] <= uVar20) {\n          if (param_3 == (undefined8 *)0x0) {\n            return uVar6;\n          }\n          __ptr = (void *)copy_and_null_terminate_00109a0b(pbVar2,(int)*param_2 - (int)pbVar2);\n          __ptr_00 = (void *)concat(\"NoSuchStrinG__\",__ptr,0);\n          free(__ptr);\n          __haystack = (char *)cplus_demangle(__ptr_00,2);\n          free(__ptr_00);\n          if ((__haystack != (char *)0x0) &&\n             (pcVar11 = strstr(__haystack,\"::NoSuchStrinG\"), pcVar13 = __haystack,\n             pcVar15 = __haystack, pcVar11 != (char *)0x0)) {\n            for (; pcVar13 != pcVar11; pcVar13 = pcVar13 + 1) {\n              if ((*pcVar13 != ' ') ||\n                 (((pcVar13[1] == '>' && (__haystack < pcVar13)) && (pcVar13[-1] == '>')))) {\n                *pcVar15 = *pcVar13;\n                pcVar15 = pcVar15 + 1;\n              }\n            }\n            uVar12 = copy_and_null_terminate_00109a0b(__haystack,(int)pcVar15 - (int)__haystack);\n            *param_3 = uVar12;\n            free(__haystack);\n            return uVar6;\n          }\n          print_error_message_0010911f(pbVar2);\n          free(__haystack);\n          return 0;\n        }\n        pbVar10 = *param_2;\n        if (*pbVar10 != 0x5a) {\n          bVar5 = FUNC_0010c95e(param_1,param_2,0);\n          if (bVar5 == 0) {\n            return 0;\n          }\n          bVar3 = 0;\n          bVar14 = 0;\n          bVar18 = 0;\n          bVar17 = 0;\n          bVar19 = 0;\nLAB_0010d2e9:\n          do {\n            do {\n              bVar16 = bVar3;\n              bVar1 = *pbVar10;\n              if ((bVar14 | bVar1 == 0) != 0) {\n                bVar5 = 0;\n                goto switchD_0010d329_caseD_70;\n              }\n              bVar3 = bVar5;\n              bVar14 = bVar5;\n            } while ('v' < (char)bVar1);\n            if ((char)bVar1 < 'b') {\n              if ((char)bVar1 < 'U') {\n                if ((char)bVar1 < 'C') goto LAB_0010d2e9;\n                uVar21 = 1L << (bVar1 + 0xbd & 0x3f);\n                if ((uVar21 & 0x11409) == 0) {\n                  if ((uVar21 & 0xa000) != 0) goto switchD_0010d329_caseD_70;\n                  if (bVar1 == 0x54) goto switchD_0010d329_caseD_76;\n                  goto LAB_0010d2e9;\n                }\n              }\n              else if (1 < (byte)(bVar1 + 0xab)) goto LAB_0010d2e9;\n              pbVar10 = pbVar10 + 1;\n              bVar3 = bVar16;\n              bVar14 = 0;\n              goto LAB_0010d2e9;\n            }\n            switch(bVar1) {\n            case 0x62:\n              bVar3 = bVar16;\n              bVar18 = bVar5;\n              break;\n            case 99:\n              bVar3 = bVar16;\n              bVar19 = bVar5;\n              break;\n            case 100:\n            case 0x66:\n            case 0x72:\n              bVar3 = bVar16;\n              bVar17 = bVar5;\n              break;\n            case 0x70:\n              goto switchD_0010d329_caseD_70;\n            case 0x76:\nswitchD_0010d329_caseD_76:\n                    \n              abort();\n            }\n          } while( true );\n        }\n        *param_2 = pbVar10 + 1;\n        cVar4 = FUNC_0010c95e(param_1,param_2,0);\n        if (cVar4 == '\\0') {\n          return 0;\n        }\n        goto LAB_0010d2b1;\n      }\n    }\n  }\nLAB_0010d280:\n  print_error_message_0010911f(pbVar2);\n  return 0;\nswitchD_0010d329_caseD_70:\n  if (bVar16 == 0) {\n    if (bVar19 == 0) {\n      if (bVar18 == 0) {\n        if (bVar17 == 0) {\n          if (bVar5 != 0) {\n            uVar8 = parse_integer_00108e76(param_2);\n            if (uVar8 == 0) goto LAB_0010d280;\n            *param_2 = *param_2 + uVar8;\n          }\n        }\n        else {\n          if (**param_2 == 0x6d) {\n            *param_2 = *param_2 + 1;\n          }\n          while( true ) {\n            pbVar10 = *param_2;\n            if (((&_sch_istable)[(ulong)*pbVar10 * 2] & 4) == 0) break;\n            *param_2 = pbVar10 + 1;\n          }\n          if (*pbVar10 == 0x2e) {\n            do {\n              pbVar10 = pbVar10 + 1;\n              *param_2 = pbVar10;\n            } while (((&_sch_istable)[(ulong)*pbVar10 * 2] & 4) != 0);\n          }\n          pbVar10 = *param_2;\n          if (*pbVar10 == 0x65) {\n            do {\n              pbVar10 = pbVar10 + 1;\n              *param_2 = pbVar10;\n            } while (((&_sch_istable)[(ulong)*pbVar10 * 2] & 4) != 0);\n          }\n        }\n      }\n      else {\n        uVar8 = parse_integer_00108e76(param_2);\n        if (1 < uVar8) goto LAB_0010d280;\n      }\n    }\n    else {\n      if (**param_2 == 0x6d) {\n        *param_2 = *param_2 + 1;\n      }\n      iVar7 = parse_integer_00108e76(param_2);\n      if (iVar7 == 0) goto LAB_0010d280;\n    }\n  }\n  else {\n    if (**param_2 == 0x6d) {\n      *param_2 = *param_2 + 1;\n    }\n    while (((&_sch_istable)[(ulong)**param_2 * 2] & 4) != 0) {\n      *param_2 = *param_2 + 1;\n    }\n  }\nLAB_0010d2b1:\n  uVar20 = uVar20 + 1;\n  goto LAB_0010d2b4;\n}\n\n"
        },
        "FUN_001054af": {
            "renaming": {
                "FUN_001054af": "cleanup_hash_table_001054af",
                "param_1": "unusedParam1",
                "param_2": "unusedParam2",
                "in_RAX": "returnValue"
            },
            "code": "\nvoid cleanupHashTable_001054af(undefined8 unusedParam1,undefined8 unusedParam2)\n\n{\n  undefined8 returnValue;\n  \n  htab_delete(DAT_001279f8);\n  htab_delete(DAT_001279f0);\n  htab_delete(DAT_00127a08);\n  htab_delete(DAT_001279e8);\n  htab_delete(DAT_001279e0);\n  htab_delete(DAT_001279d8);\n  htab_delete(DAT_001279d0);\n  htab_delete(DAT_001278d0);\n  htab_delete(DAT_001278c8,unusedParam2,returnValue);\n  return;\n}\n\n",
            "called": [
                "htab_delete"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001054af",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "cleanup_hash_table_001054af"
        },
        "FUN_0010c139": {
            "renaming": {
                "FUN_0010c139": "update_variable_data_0010c139",
                "param_1": "dataBuffer",
                "param_2": "record",
                "param_3": "newValue",
                "param_4": "dataType",
                "param_5": "flag",
                "param_6": "address",
                "uVar1": "tempVar1",
                "cVar2": "flagChar",
                "uVar3": "result",
                "puVar4": "newRecord",
                "in_R10": "optionalParam",
                "unaff_R15": "unusedParam"
            },
            "code": "\nulong updateVariableData_0010c139(undefined8 dataBuffer,long record,undefined8 newValue,undefined8 dataType,\n                  undefined4 flag,undefined8 address)\n\n{\n  undefined8 tempVar1;\n  char flagChar;\n  ulong result;\n  undefined8 *newRecord;\n  undefined8 optionalParam;\n  undefined8 unusedParam;\n  \n  flagChar = *(char *)(record + 0x60);\n  if ((flagChar != '\\0') && ((*(int *)(record + 0x40) != 0 || (*(char *)(record + 0x44) == '\\0')))) {\n    newRecord = (undefined8 *)xmalloc(0x28);\n    tempVar1 = *(undefined8 *)(record + 0x78);\n    *(undefined8 *)((long)newRecord + 0x1c) = 0;\n    newRecord[2] = dataType;\n    *(undefined4 *)(newRecord + 3) = flag;\n    newRecord[4] = address;\n    *(undefined8 **)(record + 0x78) = newRecord;\n    *newRecord = tempVar1;\n    newRecord[1] = newValue;\n    return CONCAT71((int7)((ulong)unusedParam >> 8),flagChar) & 0xffffffff;\n  }\n  result = record_variable_data_0010c05d(dataBuffer,newValue,dataType,flag,address,optionalParam);\n  return result;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_0010c05d"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c139",
            "calling": [
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "update_variable_data_0010c139"
        },
        "FUN_0010e439": {
            "renaming": {
                "FUN_0010e439": "update_string_and_process_0010e439",
                "param_1": "baseAddress",
                "param_2": "newString"
            },
            "code": "\nvoid updateStringAndProcess_0010e439(long baseAddress,undefined8 newString)\n\n{\n  *(undefined8 *)(baseAddress + 0x210) = newString;\n  process_string_0010e2f0(baseAddress,0x84,0,0,newString);\n  return;\n}\n\n",
            "called": [
                "FUN_0010e2f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e439",
            "calling": [
                "thunk_FUN_0010e439",
                "FUN_0011378f"
            ],
            "imported": false,
            "current_name": "update_string_and_process_0010e439"
        },
        "sprintf": {
            "renaming": {},
            "code": "\n\n\nint sprintf(char *__s,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = sprintf(__s,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047e0",
            "calling": [
                "FUN_00109cf4",
                "FUN_0010e5db",
                "FUN_0010e842",
                "FUN_0010a0e9",
                "FUN_00109d97",
                "FUN_0010ae0e",
                "FUN_0010ebb0",
                "FUN_0010abdd",
                "FUN_0010ba08",
                "FUN_0010a77a",
                "FUN_00109e76",
                "FUN_0010e453",
                "FUN_0010e7c2",
                "FUN_0010b948",
                "FUN_0010a2b9",
                "FUN_0010aa53",
                "FUN_0010e8a9",
                "FUN_0010a94e",
                "FUN_0010ab4d",
                "FUN_0010e918",
                "FUN_0010a83e",
                "FUN_0010a181",
                "FUN_0010e9a0",
                "FUN_0010e6a8",
                "FUN_0010a424",
                "FUN_0010a377",
                "FUN_0010eafe",
                "FUN_0010ee3f",
                "FUN_00109dfe",
                "FUN_0010a69a",
                "FUN_001125fa",
                "FUN_0010b800",
                "FUN_00109ed3"
            ],
            "imported": false,
            "current_name": "sprintf"
        },
        "strlen": {
            "renaming": {},
            "code": "\n\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(__s);\n  return sVar1;\n}\n\n",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104270",
            "calling": [
                "FUN_0010554f",
                "FUN_00113ede",
                "FUN_0010e5db",
                "FUN_00104ad6",
                "FUN_0010e842",
                "FUN_0010a0e9",
                "FUN_0010c95e",
                "FUN_00104943",
                "FUN_0010ae0e",
                "FUN_0010ebb0",
                "FUN_0010abdd",
                "FUN_0010ba08",
                "FUN_0011378f",
                "FUN_0010a77a",
                "FUN_0011173a",
                "FUN_0010e453",
                "FUN_0010e7c2",
                "FUN_0010a2b9",
                "FUN_001199d0",
                "FUN_0010aa53",
                "FUN_0010e8a9",
                "FUN_00115530",
                "FUN_00113fb0",
                "FUN_00109bbb",
                "FUN_0010a94e",
                "FUN_0010ab4d",
                "FUN_0010e918",
                "FUN_0010a83e",
                "FUN_0010a181",
                "FUN_00108c86",
                "FUN_0010d21c",
                "FUN_0010e9a0",
                "FUN_0010e6a8",
                "FUN_0010a424",
                "FUN_0010d559",
                "FUN_00116b90",
                "FUN_0010a377",
                "FUN_0010eafe",
                "FUN_0010ee3f",
                "FUN_0010a69a",
                "FUN_0010b0fa",
                "FUN_001125fa",
                "FUN_0010b800",
                "FUN_00109ed3",
                "FUN_0010e2f0"
            ],
            "imported": false,
            "current_name": "strlen"
        },
        "memcmp": {
            "renaming": {},
            "code": "\n\n\nint memcmp(void *__s1,void *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = memcmp(__s1,__s2,__n);\n  return iVar1;\n}\n\n",
            "called": [
                "memcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104420",
            "calling": [
                "FUN_0011a1b0",
                "FUN_00116852"
            ],
            "imported": false,
            "current_name": "memcmp"
        },
        "FUN_00109d3e": {
            "renaming": {
                "FUN_00109d3e": "initialize_with_data_00109d3e",
                "param_1": "dataPointer",
                "param_2": "dataSize",
                "uVar1": "defaultValue"
            },
            "code": "\nvoid initializeWithData_00109d3e(undefined8 dataPointer,int dataSize)\n\n{\n  undefined8 defaultValue;\n  \n  defaultValue = 0xfffffffffffffff0;\n  if (dataSize - 1U < 8) {\n    defaultValue = *(undefined8 *)(&DAT_00121360 + (ulong)(dataSize - 1U) * 8);\n  }\n  initialize_data_00109cf4(dataPointer,defaultValue,dataSize);\n  return;\n}\n\n",
            "called": [
                "FUN_00109cf4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109d3e",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "initialize_with_data_00109d3e"
        },
        "FUN_00112502": {
            "renaming": {
                "FUN_00112502": "process_files_00112502",
                "param_1": "fileDataPtr",
                "param_2": "filePtr",
                "param_3": "fileSize",
                "uVar1": "fileIndex",
                "puVar2": "nextFile",
                "uVar3": "currentFile",
                "cVar4": "isProcessed"
            },
            "code": "\nundefined processFiles_00112502(long fileDataPtr,undefined8 filePtr,ulong fileSize)\n\n{\n  uint fileIndex;\n  undefined8 *nextFile;\n  undefined8 currentFile;\n  char isProcessed;\n  \n  do {\n    nextFile = *(undefined8 **)(fileDataPtr + 0x40);\n    if (nextFile == (undefined8 *)0x0) {\n      return 1;\n    }\n    while ((fileIndex = *(uint *)(fileDataPtr + 0x48), fileIndex < 10 && (nextFile[(ulong)fileIndex + 2] != -1))) {\n      if (fileSize <= (ulong)nextFile[(ulong)fileIndex + 0xc]) {\n        return 1;\n      }\n      isProcessed = process_file_0010edb4(filePtr,*(undefined8 *)(nextFile[1] + 8));\n      if (isProcessed == '\\0') {\n        return 0;\n      }\n      *(int *)(fileDataPtr + 0x48) = *(int *)(fileDataPtr + 0x48) + 1;\n    }\n    currentFile = *nextFile;\n    *(undefined4 *)(fileDataPtr + 0x48) = 0;\n    *(undefined8 *)(fileDataPtr + 0x40) = currentFile;\n  } while( true );\n}\n\n",
            "called": [
                "FUN_0010edb4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112502",
            "calling": [
                "FUN_001135a5",
                "FUN_00113a4d",
                "FUN_0011378f"
            ],
            "imported": false,
            "current_name": "process_files_00112502"
        },
        "bfd_fill_in_gnu_debuglink_section": {
            "renaming": {},
            "code": "\nvoid bfd_fill_in_gnu_debuglink_section(void)\n\n{\n  bfd_fill_in_gnu_debuglink_section();\n  return;\n}\n\n",
            "called": [
                "bfd_fill_in_gnu_debuglink_section"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104600",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_fill_in_gnu_debuglink_section"
        },
        "FUN_00104cc1": {
            "renaming": {
                "FUN_00104cc1": "parse_and_store_lines_00104cc1",
                "uVar1": "errorString",
                "ppbVar2": "slotPointer",
                "pbVar3": "currentByte",
                "bVar4": "currentChar",
                "unaff_RBX": "remainingBytes",
                "pbVar5": "startByte",
                "unaff_EBP": "lineNumber",
                "in_R10": "linePointer",
                "unaff_R13": "returnAddress",
                "unaff_R14": "tempPointer",
                "unaff_R15": "endPointer",
                "param_7": "additionalParam1",
                "param_8": "additionalParam2",
                "param_9": "inputParam"
            },
            "code": "\nvoid parseAndStoreLines_00104cc1(void)\n\n{\n  undefined8 errorString;\n  byte **slotPointer;\n  byte *currentByte;\n  byte currentChar;\n  byte *remainingBytes;\n  byte *startByte;\n  int lineNumber;\n  byte *linePointer;\n  undefined8 returnAddress;\n  byte *tempPointer;\n  byte *endPointer;\n  undefined8 additionalParam1;\n  undefined8 *additionalParam2;\n  byte *inputParam;\n  \ncode_r0x00104cc1:\n  inputParam = linePointer;\n  errorString = dcgettext(0,\"%s:%d: Ignoring rubbish found on this line\",5);\n  print_error_message_00119ed0(errorString,additionalParam1,lineNumber);\n  startByte = remainingBytes;\n  linePointer = inputParam;\nLAB_00114599:\n  do {\n    *linePointer = 0;\n    if (endPointer < linePointer) {\n      slotPointer = (byte **)htab_find_slot();\n      *slotPointer = endPointer;\n    }\n    lineNumber = lineNumber + 1;\n    currentByte = startByte;\n    if (tempPointer[1] == 0) {\n      *additionalParam2 = returnAddress;\n      return;\n    }\n    for (; currentChar = *currentByte, tempPointer = currentByte, currentChar != 10; currentByte = currentByte + 1) {\n      if ((char)currentChar < '\\v') {\n        if (currentChar == 0) {\n          remainingBytes = currentByte + 1;\n          goto LAB_00114553;\n        }\n      }\n      else {\n        if (currentChar == 0xd) {\n          *currentByte = 0;\n          remainingBytes = currentByte + 1;\n          if (currentByte[1] == 10) {\n            remainingBytes = currentByte + 2;\n            tempPointer = currentByte + 1;\n          }\n          goto LAB_00114553;\n        }\n        if (currentChar == 0x23) {\n          parse_lines_00104d1c();\n          return;\n        }\n      }\n    }\n    *currentByte = 0;\n    if (currentByte[1] == 0xd) {\n      tempPointer = currentByte + 1;\n      remainingBytes = currentByte + 2;\n    }\n    else {\n      remainingBytes = currentByte + 1;\n    }\nLAB_00114553:\n    currentChar = *startByte;\n    endPointer = startByte;\n    while ((currentChar == 0x20 || (linePointer = endPointer, currentChar == 9))) {\n      startByte = endPointer + 1;\n      endPointer = endPointer + 1;\n      currentChar = *startByte;\n    }\n    do {\n      startByte = remainingBytes;\n      if ((currentChar == 10) || (currentChar == 0xd)) goto LAB_00114676;\n      if (currentChar == 0) goto LAB_00114599;\n      currentChar = linePointer[1];\n      linePointer = linePointer + 1;\n    } while ((currentChar != 0x20) && (currentChar != 9));\n    if ((char)currentChar < '\\x0e') {\nLAB_00114676:\n      if ((-0x2402L >> (currentChar & 0x3f) & 1U) == 0) goto LAB_00114599;\n    }\n    currentChar = linePointer[1];\n    if ((((((currentChar == 9) || (currentChar == 0x20)) && ((currentChar = linePointer[2], currentChar == 9 || (currentChar == 0x20)))\n          ) && ((currentChar = linePointer[3], currentChar == 9 || (currentChar == 0x20)))) &&\n        ((currentChar = linePointer[4], currentChar == 9 || (currentChar == 0x20)))) &&\n       ((currentChar = linePointer[5], currentChar == 9 || (currentChar == 0x20)))) {\n      currentChar = linePointer[6];\n      currentByte = linePointer + 6;\n      if ((currentChar == 9) || (currentChar == 0x20)) {\n        do {\n          do {\n            currentChar = currentByte[1];\n            currentByte = currentByte + 1;\n          } while (currentChar == 0x20);\n        } while (currentChar == 9);\n      }\n    }\n    if ((0xd < currentChar) || ((-0x2402L >> (currentChar & 0x3f) & 1U) != 0)) goto code_r0x00104cc1;\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00104cc1",
                "dcgettext",
                "FUN_00104c36",
                "FUN_00119ed0",
                "htab_find_slot",
                "FUN_00104d1c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104cc1",
            "calling": [
                "FUN_00104cc1"
            ],
            "imported": false,
            "current_name": "parse_and_store_lines_00104cc1"
        },
        "xrealloc": {
            "renaming": {},
            "code": "\nvoid xrealloc(void)\n\n{\n  xrealloc();\n  return;\n}\n\n",
            "called": [
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001042b0",
            "calling": [
                "FUN_00109c2e",
                "FUN_0010ab4d",
                "FUN_0010e07c",
                "FUN_00114dc7",
                "FUN_0010abdd",
                "FUN_0010d7d4",
                "FUN_00119f70",
                "FUN_0010dac0",
                "FUN_0011173a",
                "FUN_00116b90",
                "FUN_0010b6ea",
                "FUN_0010ee3f",
                "FUN_00109be3",
                "FUN_0010aa53",
                "FUN_00109ed3",
                "FUN_0010e2f0"
            ],
            "imported": false,
            "current_name": "xrealloc"
        },
        "FUN_00113bfa": {
            "renaming": {
                "FUN_00113bfa": "initialize_and_allocate_00113bfa",
                "param_1": "input_1",
                "param_2": "input_2",
                "lVar1": "data_ptr",
                "plVar2": "allocated_ptr"
            },
            "code": "\nlong initialize_and_allocate_00113bfa(long input_1,long input_2)\n\n{\n  long data_ptr;\n  long *allocated_ptr;\n  \n  if (((input_1 != 0) && (input_2 != 0)) && (data_ptr = initialize_data_00112904(0x12,0), data_ptr != 0)) {\n    allocated_ptr = (long *)xmalloc(0x10);\n    *allocated_ptr = input_1;\n    allocated_ptr[1] = input_2;\n    *(long **)(data_ptr + 0x10) = allocated_ptr;\n    return data_ptr;\n  }\n  return 0;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113bfa",
            "calling": [
                "FUN_0010c95e",
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "initialize_and_allocate_00113bfa"
        },
        "FUN_00108375": {
            "renaming": {
                "FUN_00108375": "validate_and_print_error_00108375",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "uVar1": "value1",
                "uVar2": "value2",
                "unaff_EBX": "flag"
            },
            "code": "\nuint validate_and_print_error_00108375(undefined8 param1,undefined8 *param2,undefined8 param3)\n\n{\n  undefined8 value1;\n  undefined8 value2;\n  uint flag;\n  \n  if (*(int *)(param2[1] + 8) != 2) {\n    value1 = *param2;\n    flag = flag & 0xf7ffffff;\n    value2 = dcgettext(0,\"%s[%s]: Note - dropping \\'share\\' flag as output format is not COFF\",5);\n    print_error_message_00119ed0(value2,value1,param3);\n  }\n  return flag;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00119ed0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108375",
            "calling": [
                "FUN_00115f30"
            ],
            "imported": false,
            "current_name": "validate_and_print_error_00108375"
        },
        "bfd_get_arch": {
            "renaming": {},
            "code": "\nvoid bfd_get_arch(void)\n\n{\n  bfd_get_arch();\n  return;\n}\n\n",
            "called": [
                "bfd_get_arch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104570",
            "calling": [
                "FUN_00104ea2",
                "FUN_00107976",
                "FUN_00105828",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "bfd_get_arch"
        },
        "FUN_00109e76": {
            "renaming": {
                "FUN_00109e76": "update_and_allocate_data_00109e76",
                "param_1": "dataPointer",
                "param_2": "value",
                "lVar1": "previousValue",
                "local_5a": "formattedString"
            },
            "code": "\nvoid updateAndAllocateData_00109e76(long dataPointer,uint value)\n\n{\n  long previousValue;\n  char formattedString [58];\n  \n  previousValue = *(long *)(dataPointer + 0x68);\n  *(long *)(dataPointer + 0x68) = previousValue + 1;\n  sprintf(formattedString,\"%ld=r%ld;%u;0;\",previousValue,previousValue,(ulong)value);\n  allocate_and_initialize_data_00109b52(dataPointer,formattedString,previousValue,1,value * 2);\n  return;\n}\n\n",
            "called": [
                "sprintf",
                "FUN_00109b52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109e76",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "update_and_allocate_data_00109e76"
        },
        "FUN_001088ae": {
            "renaming": {
                "FUN_001088ae": "update_data_entry_001088ae",
                "param_1": "newValue1",
                "param_2": "newValue2",
                "param_3": "newValue3",
                "param_4": "newValue4",
                "iVar1": "newIndex",
                "lVar2": "currentIndex",
                "lVar3": "offset",
                "uVar4": "duplicatedString"
            },
            "code": "\nulong updateDataEntry_001088ae(undefined4 newValue1,undefined4 newValue2,undefined8 newValue3,undefined8 newValue4)\n\n{\n  int newIndex;\n  long currentIndex;\n  long offset;\n  undefined8 duplicatedString;\n  \n  currentIndex = (long)DAT_001278a0;\n  offset = currentIndex * 0x18;\n  free((void *)(&DAT_00127730)[currentIndex * 3]);\n  *(undefined4 *)(&DAT_00127720 + offset) = newValue1;\n  *(undefined4 *)(&DAT_00127724 + offset) = newValue2;\n  *(undefined8 *)(&DAT_00127728 + offset) = newValue3;\n  duplicatedString = xstrdup(newValue4);\n  (&DAT_00127730)[currentIndex * 3] = duplicatedString;\n  newIndex = DAT_001278a0 + 1;\n  DAT_001278a0 = newIndex % 0x10;\n  return (long)newIndex / 0x10 & 0xffffffff;\n}\n\n",
            "called": [
                "xstrdup",
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001088ae",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "update_data_entry_001088ae"
        },
        "_DT_FINI": {
            "renaming": {},
            "code": "\nvoid _DT_FINI(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a4b4",
            "calling": [],
            "imported": false,
            "current_name": "_DT_FINI"
        },
        "FUN_0010afd5": {
            "renaming": {
                "FUN_0010afd5": "find_match_and_free_0010afd5",
                "param_1": "node",
                "param_2": "data",
                "param_3": "str",
                "param_4": "str_len",
                "__s2": "str_copy",
                "puVar2": "current_node",
                "uVar3": "result",
                "lVar4": "match_length",
                "puVar5": "match_node",
                "puVar6": "ptr",
                "bVar7": "flag",
                "auVar8": "return_value"
            },
            "code": "\nundefined  [16]\nfindMatchAndFree_0010afd5(undefined8 *node,long data,undefined8 str,undefined4 str_len,\n            undefined4 param_5,undefined8 param_6)\n\n{\n  int iVar1;\n  char *str_copy;\n  undefined8 *current_node;\n  undefined8 result;\n  long match_length;\n  undefined8 *match_node;\n  undefined4 *ptr;\n  byte flag;\n  undefined return_value [16];\n  \n  flag = 0;\n  str_copy = (char *)copy_and_null_terminate_00109a0b(str,str_len);\n  for (node = (undefined8 *)*node; node != (undefined8 *)0x0;\n      node = (undefined8 *)*node) {\n    for (current_node = (undefined8 *)node[1]; current_node != (undefined8 *)0x0;\n        current_node = (undefined8 *)*current_node) {\n      if ((undefined8 *)current_node[2] != (undefined8 *)0x0) {\n        for (match_node = *(undefined8 **)(undefined8 *)current_node[2]; match_node != (undefined8 *)0x0;\n            match_node = (undefined8 *)*match_node) {\n          if ((*(int *)((long)match_node + 0x14) == 1) && (*(char *)match_node[1] == *str_copy)) {\n            iVar1 = strcmp((char *)match_node[1],str_copy);\n            if (iVar1 == 0) {\n              match_length = match_node[4];\n              if (match_length == 0) goto LAB_0010b05b;\n              free(str_copy);\n              goto LAB_0010b0eb;\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010b05b:\n  current_node = *(undefined8 **)(data + 0x1a0);\n  do {\n    if (current_node == (undefined8 *)0x0) {\n      current_node = (undefined8 *)xmalloc(0x28);\n      result = *(undefined8 *)(data + 0x1a0);\n      ptr = (undefined4 *)((long)current_node + 0x14);\n      for (match_length = 5; match_length != 0; match_length = match_length + -1) {\n        *ptr = 0;\n        ptr = ptr + (ulong)flag * -2 + 1;\n      }\n      *(undefined4 *)(current_node + 2) = param_5;\n      *current_node = result;\n      current_node[1] = str_copy;\n      result = initialize_data_00113e23(current_node + 3,str_copy);\n      *(undefined8 **)(data + 0x1a0) = current_node;\n      current_node[4] = result;\nLAB_0010b0e7:\n      match_length = current_node[4];\nLAB_0010b0eb:\n      return_value._8_8_ = param_6;\n      return_value._0_8_ = match_length;\n      return return_value;\n    }\n    if (*(char *)current_node[1] == *str_copy) {\n      iVar1 = strcmp((char *)current_node[1],str_copy);\n      if (iVar1 == 0) {\n        if (*(int *)(current_node + 2) == 0) {\n          *(undefined4 *)(current_node + 2) = param_5;\n        }\n        free(str_copy);\n        goto LAB_0010b0e7;\n      }\n    }\n    current_node = (undefined8 *)*current_node;\n  } while( true );\n}\n\n",
            "called": [
                "strcmp",
                "free",
                "xmalloc",
                "FUN_00113e23",
                "FUN_00109a0b"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010afd5",
            "calling": [
                "FUN_0010d559",
                "FUN_0010c95e",
                "FUN_0010ee3f",
                "FUN_0010b0fa"
            ],
            "imported": false,
            "current_name": "find_match_and_free_0010afd5"
        },
        "FUN_0010ee3f": {
            "renaming": {
                "FUN_0010ee3f": "FUNC_0010ee3f"
            },
            "code": "\n\n\nvoid * FUNC_0010ee3f(undefined8 param_1,long param_2,char *param_3,byte **param_4,undefined8 *param_5\n                   ,byte *param_6)\n\n{\n  byte bVar1;\n  byte bVar2;\n  byte *pbVar3;\n  long lVar4;\n  byte *pbVar5;\n  char cVar6;\n  byte bVar7;\n  char cVar8;\n  byte bVar9;\n  int iVar10;\n  undefined4 uVar11;\n  uint uVar12;\n  undefined4 uVar13;\n  int iVar14;\n  undefined8 uVar15;\n  char *pcVar16;\n  void *pvVar17;\n  void **ppvVar18;\n  long lVar19;\n  long lVar20;\n  int *piVar21;\n  undefined *puVar22;\n  char **ppcVar23;\n  void *pvVar24;\n  void *pvVar25;\n  ulong uVar26;\n  byte *pbVar27;\n  byte *pbVar28;\n  char *pcVar29;\n  size_t sVar30;\n  byte *pbVar31;\n  undefined8 *puVar32;\n  size_t sVar33;\n  byte **ppbVar34;\n  void **ppvVar35;\n  undefined8 uVar36;\n  undefined8 uVar37;\n  long lVar38;\n  long *plVar39;\n  char *pcVar40;\n  bool bVar41;\n  byte *pbVar42;\n  char cVar43;\n  undefined uVar44;\n  ulong uVar45;\n  char *pcVar46;\n  byte bVar47;\n  byte bVar48;\n  ulong uVar49;\n  byte *pbVar50;\n  bool bVar51;\n  bool bVar52;\n  undefined auVar53 [16];\n  undefined auVar54 [16];\n  void *local_158;\n  char *local_150;\n  byte *local_140;\n  char local_138;\n  char local_130;\n  uint local_12c;\n  char *local_128;\n  byte *local_120;\n  void *local_118;\n  byte *local_110;\n  undefined4 local_100;\n  uint local_fc;\n  uint local_f0;\n  uint local_ec;\n  uint local_e0;\n  int local_d0;\n  char local_a9;\n  undefined8 local_a8;\n  byte *local_a0;\n  undefined8 local_98;\n  long local_90;\n  long local_88;\n  char local_80;\n  undefined7 uStack_7f;\n  void *local_78;\n  undefined4 local_70;\n  int local_6c;\n  void *local_68;\n  int local_5c;\n  \n  bVar48 = 0;\n  if (param_5 != (undefined8 *)0x0) {\n    *param_5 = 0;\n  }\n  pbVar3 = *param_4;\n  if (param_6 <= pbVar3) {\n    return (void *)0x0;\n  }\n  *(undefined *)(param_2 + 0x1a8) = 0;\n  bVar9 = *pbVar3;\n  if (((bVar9 != 0x28 && bVar9 != 0x2d) &\n      ((byte)(*(ushort *)(&_sch_istable + (ulong)bVar9 * 2) >> 2) ^ 1)) == 0) {\n    cVar6 = parse_arguments_00109ab1(param_4,&local_a8,param_6);\n    if (cVar6 == '\\0') {\n      return (void *)0x0;\n    }\n    if (**param_4 != 0x3d) {\n      pvVar17 = (void *)initialize_data_structure_0010c2d2(param_1,param_2,&local_a8);\n      return pvVar17;\n    }\n    if (param_5 != (undefined8 *)0x0) {\n      if (-1 < (int)((uint)local_a8 | local_a8._4_4_)) {\n        uVar15 = validate_and_get_subsection_00109022(param_2);\n        *param_5 = uVar15;\n      }\n    }\n    *param_4 = *param_4 + 1;\n    local_12c = 0xffffffff;\n    cVar8 = '\\0';\n    do {\n      while( true ) {\n        do {\n          cVar43 = cVar8;\n          pbVar27 = *param_4;\n          if (((*pbVar27 != 0x40) ||\n              (bVar9 = pbVar27[1], ((&_sch_istable)[(ulong)bVar9 * 2] & 4) != 0)) ||\n             (pbVar50 = pbVar27, bVar9 == 0x28 || bVar9 == 0x2d)) goto LAB_0010efe0;\n          while( true ) {\n            bVar9 = pbVar50[1];\n            if (bVar9 == 0x3b) break;\n            pbVar50 = pbVar50 + 1;\n            if (bVar9 == 0) goto switchD_0010f055_caseD_24;\n          }\n          *param_4 = pbVar50 + 2;\n          bVar9 = pbVar27[1];\n          cVar8 = cVar6;\n        } while (bVar9 == 0x53);\n        cVar8 = cVar43;\n        if (bVar9 != 0x73) break;\n        lVar38 = strtol((char *)(pbVar27 + 2),(char **)0x0,10);\n        local_12c = 0xffffffff;\n        if (7 < (int)lVar38) {\n          local_12c = (int)lVar38 >> 3;\n        }\n      }\n    } while (bVar9 != 0);\n    goto switchD_0010f055_caseD_24;\n  }\n  local_12c = 0xffffffff;\n  cVar43 = '\\0';\n  local_a8 = 0xffffffffffffffff;\nLAB_0010efe0:\n  pbVar50 = *param_4;\n  bVar9 = *pbVar50;\n  pbVar27 = pbVar50 + 1;\n  *param_4 = pbVar27;\n  if ('x' < (char)bVar9) goto switchD_0010f055_caseD_24;\n  if ((char)bVar9 < 'a') {\n    if (bVar9 == 0x40) {\n      lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      if (lVar38 == 0) {\n        return (void *)0x0;\n      }\n      if (**param_4 != 0x2c) goto switchD_0010f055_caseD_24;\n      *param_4 = *param_4 + 1;\n      lVar19 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      if (lVar19 == 0) {\n        return (void *)0x0;\n      }\n      pvVar17 = (void *)initialize_and_allocate_00113bfa(lVar38,lVar19);\n    }\n    else if ((char)bVar9 < 'A') {\n      if ('-' < (char)bVar9) {\n        if (9 < (byte)(bVar9 - 0x30)) goto switchD_0010f055_caseD_24;\nswitchD_0010f055_caseD_28:\n        *param_4 = pbVar50;\n        cVar6 = parse_arguments_00109ab1(param_4,&local_98,param_6);\n        if (cVar6 == '\\0') {\n          return (void *)0x0;\n        }\n        iVar10 = (uint)local_a8;\n        if ((uint)local_a8 == (uint)local_98) {\n          if (local_a8._4_4_ == local_98._4_4_) {\n            pvVar17 = (void *)initialize_data_00113e17();\n            if (iVar10 != -1) {\n              ppvVar18 = (void **)validate_and_get_subsection_00109022(param_2,&local_a8);\n              if (ppvVar18 == (void **)0x0) {\n                return (void *)0x0;\n              }\n              *ppvVar18 = pvVar17;\n            }\n            goto LAB_001115e2;\n          }\n        }\n        *param_4 = pbVar50;\n        pvVar17 = (void *)FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n        if (pvVar17 == (void *)0x0) {\n          return (void *)0x0;\n        }\n        if (iVar10 != -1) {\n          ppvVar18 = (void **)validate_and_get_subsection_00109022(param_2,&local_a8);\n          if (ppvVar18 == (void **)0x0) {\n            return (void *)0x0;\n          }\n          *ppvVar18 = pvVar17;\n        }\n        goto LAB_001115eb;\n      }\n      if ((char)bVar9 < '#') goto switchD_0010f055_caseD_24;\n      switch(bVar9) {\n      case 0x23:\n        if (pbVar50[1] == 0x23) {\n          *param_4 = pbVar50 + 2;\n          lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n          if (lVar38 == 0) {\n            return (void *)0x0;\n          }\n          if (**param_4 != 0x3b) goto switchD_0010f055_caseD_24;\n          *param_4 = *param_4 + 1;\n          pvVar17 = (void *)initialize_data_and_allocate_memory_00113b98(lVar38,0,0,0);\n        }\n        else {\n          lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n          if (lVar38 == 0) {\n            return (void *)0x0;\n          }\n          if (**param_4 != 0x2c) goto switchD_0010f055_caseD_24;\n          *param_4 = *param_4 + 1;\n          lVar19 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n          if (lVar19 == 0) {\n            return (void *)0x0;\n          }\n          uVar45 = 10;\n          uVar49 = 0;\n          auVar53 = xmalloc(0x50);\n          while( true ) {\n            lVar20 = auVar53._0_8_;\n            pbVar27 = *param_4;\n            iVar10 = (int)uVar49;\n            if (*pbVar27 == 0x3b) break;\n            if (*pbVar27 != 0x2c) {\n              print_bad_stab_00108fb9(pbVar3);\n              return (void *)0x0;\n            }\n            *param_4 = pbVar27 + 1;\n            if ((uint)uVar45 <= iVar10 + 1U) {\n              uVar45 = (ulong)((uint)uVar45 + 10);\n              lVar20 = xrealloc(lVar20,uVar45 << 3);\n            }\n            auVar54 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n            auVar53._8_8_ = auVar54._8_8_;\n            auVar53._0_8_ = lVar20;\n            *(long *)(lVar20 + uVar49 * 8) = auVar54._0_8_;\n            if (auVar54._0_8_ == 0) {\n              return (void *)0x0;\n            }\n            uVar49 = (ulong)(iVar10 + 1U);\n          }\n          uVar15 = 1;\n          *param_4 = pbVar27 + 1;\n          uVar45 = uVar49;\n          if (iVar10 != 0) {\n            uVar45 = (ulong)(iVar10 - 1);\n            lVar4 = *(long *)(lVar20 + uVar45 * 8);\n            if (((lVar4 == 0) ||\n                (piVar21 = (int *)check_debug_information_00112b6e(lVar4,0,0x3b,1), piVar21 == (int *)0x0)) ||\n               (*piVar21 != 2)) {\n              uVar15 = 1;\n              uVar45 = uVar49;\n            }\n            else {\n              uVar15 = 0;\n            }\n          }\n          *(undefined8 *)(lVar20 + uVar45 * 8) = 0;\n          pvVar17 = (void *)initialize_data_and_allocate_memory_00113b98(lVar19,lVar38,lVar20,uVar15);\n        }\n        break;\n      default:\n        goto switchD_0010f055_caseD_24;\n      case 0x26:\n        uVar15 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n        pvVar17 = (void *)initialize_data_00113cb9(uVar15);\n        break;\n      case 0x28:\n      case 0x2d:\n        goto switchD_0010f055_caseD_28;\n      case 0x2a:\n        uVar15 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n        pvVar17 = (void *)initialize_data_00113d3a(uVar15);\n      }\n    }\n    else if (bVar9 == 0x52) {\n      if (param_6 <= pbVar27) {\n        return (void *)0x0;\n      }\n      lVar38 = parse_strtoul_and_check_overflow_00109a32(param_4,0,param_6);\n      if ((**param_4 != 0x3b) || (uVar11 = parse_strtoul_and_check_overflow_00109a32(param_4,0,param_6), **param_4 != 0x3b))\n      goto LAB_0010fb4c;\n      if (lVar38 - 3U < 3) {\n        pvVar17 = (void *)initialize_data_00112904(5);\n      }\n      else {\n        pvVar17 = (void *)initialize_data_00113df2(uVar11);\n      }\n    }\n    else {\n      if (bVar9 == 0x53) {\n        lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n        if (lVar38 == 0) {\n          return (void *)0x0;\n        }\n        pvVar17 = (void *)initialize_data_00112904(0x11,0);\n        if (pvVar17 == (void *)0x0) {\n          return (void *)0x0;\n        }\n        plVar39 = (long *)xmalloc(0x10);\n        *(undefined4 *)((long)plVar39 + 9) = 0;\n        *plVar39 = lVar38;\n        *(undefined4 *)((long)plVar39 + 0xc) = 0;\n        *(char *)(plVar39 + 1) = cVar43;\n        *(long **)((long)pvVar17 + 0x10) = plVar39;\n        goto LAB_001115eb;\n      }\n      if (bVar9 != 0x42) goto switchD_0010f055_caseD_24;\n      uVar15 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      pvVar17 = (void *)initialize_data_00113b4a(uVar15);\n    }\n  }\n  else {\n    switch(bVar9) {\n    case 0x61:\n      if (pbVar50[1] != 0x72) goto switchD_0010f055_caseD_24;\n      pbVar50 = pbVar50 + 2;\n      *param_4 = pbVar50;\n      if (param_6 <= pbVar50) {\n        return (void *)0x0;\n      }\n      local_a0 = pbVar50;\n      cVar6 = parse_arguments_00109ab1(&local_a0,&local_98,param_6);\n      if (cVar6 == '\\0') {\n        return (void *)0x0;\n      }\n      if ((((uint)local_98 | local_98._4_4_) == 0) && (**param_4 != 0x3d)) {\n        lVar38 = find_named_type_0010914e(param_1,\"int\");\n        if ((lVar38 == 0) && (lVar38 = update_data_00113dfe(4,0), lVar38 == 0)) {\n          return (void *)0x0;\n        }\n        *param_4 = local_a0;\n      }\n      else {\n        lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      }\n      pbVar3 = *param_4;\n      if (*pbVar3 != 0x3b) {\nLAB_0011151b:\n        print_bad_stab_00108fb9(pbVar50);\n        return (void *)0x0;\n      }\n      *param_4 = pbVar3 + 1;\n      bVar48 = pbVar3[1];\n      bVar48 = (bVar48 != 0x2d && bVar48 != 0) &\n               ((byte)(*(ushort *)(&_sch_istable + (ulong)bVar48 * 2) >> 2) ^ 1);\n      if (bVar48 != 0) {\n        *param_4 = pbVar3 + 2;\n      }\n      uVar15 = parse_strtoul_and_check_overflow_00109a32(param_4,0,param_6);\n      pbVar3 = *param_4;\n      if (*pbVar3 != 0x3b) goto LAB_0011151b;\n      *param_4 = pbVar3 + 1;\n      bVar9 = pbVar3[1];\n      bVar9 = (bVar9 != 0x2d && bVar9 != 0) &\n              ((byte)(*(ushort *)(&_sch_istable + (ulong)bVar9 * 2) >> 2) ^ 1);\n      if (bVar9 != 0) {\n        *param_4 = pbVar3 + 2;\n        bVar48 = bVar9;\n      }\n      uVar36 = parse_strtoul_and_check_overflow_00109a32(param_4,0,param_6);\n      if (**param_4 != 0x3b) goto LAB_0011151b;\n      *param_4 = *param_4 + 1;\n      lVar19 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      if (lVar19 == 0) {\n        return (void *)0x0;\n      }\n      if (bVar48 != 0) {\n        uVar15 = 0;\n      }\n      uVar37 = 0xffffffffffffffff;\n      if (bVar48 == 0) {\n        uVar37 = uVar36;\n      }\n      pvVar17 = (void *)initialize_and_store_data_00113c43(lVar19,lVar38,uVar15,uVar37,cVar43);\n      break;\n    case 0x62:\n      if (param_6 <= pbVar27) {\n        return (void *)0x0;\n      }\n      if (pbVar50[1] == 0x73) {\n        uVar44 = 0;\n      }\n      else {\n        if (pbVar50[1] != 0x75) goto LAB_0010fb4c;\n        uVar44 = 1;\n      }\n      *param_4 = pbVar50 + 2;\n      if (((byte)(pbVar50[2] + 0x9e) < 2) || (pbVar50[2] == 0x76)) {\n        *param_4 = pbVar50 + 3;\n      }\n      parse_strtoul_and_check_overflow_00109a32(param_4,0,param_6);\n      if (**param_4 != 0x3b) goto LAB_0010fb4c;\n      *param_4 = *param_4 + 1;\n      parse_strtoul_and_check_overflow_00109a32(param_4,0,param_6);\n      if (**param_4 != 0x3b) goto LAB_0010fb4c;\n      *param_4 = *param_4 + 1;\n      uVar49 = parse_strtoul_and_check_overflow_00109a32(param_4,0,param_6);\n      if (**param_4 == 0x3b) {\n        *param_4 = *param_4 + 1;\n      }\n      if (uVar49 != 0) {\n        pvVar17 = (void *)update_data_00113dfe(uVar49 >> 3 & 0xffffffff,uVar44);\n        break;\n      }\nLAB_0010fa8f:\n      pvVar17 = (void *)initialize_data_00113e17();\n      break;\n    default:\n      goto switchD_0010f055_caseD_24;\n    case 0x65:\n      if (param_6 <= pbVar27) {\n        return (void *)0x0;\n      }\n      if (pbVar50[1] == 0x2d) {\n        while( true ) {\n          pbVar3 = *param_4;\n          if (*pbVar3 == 0x3a) break;\n          if (*pbVar3 == 0) goto LAB_0010fb4c;\n          *param_4 = pbVar3 + 1;\n        }\n        *param_4 = pbVar3 + 1;\n      }\n      uVar45 = 10;\n      pvVar17 = (void *)xmalloc(0x50);\n      pvVar24 = (void *)xmalloc(0x50);\n      uVar49 = 0;\n      while( true ) {\n        pbVar3 = *param_4;\n        pbVar50 = pbVar3;\n        if ((*pbVar3 < 0x3c) && ((-0x800100000000002 >> (*pbVar3 & 0x3f) & 1U) == 0)) break;\n        for (; *pbVar50 != 0x3a; pbVar50 = pbVar50 + 1) {\n          if (*pbVar50 == 0) {\n            print_bad_stab_00108fb9(pbVar27);\n            free(pvVar17);\n            free(pvVar24);\n            return (void *)0x0;\n          }\n        }\n        pvVar25 = (void *)copy_and_null_terminate_00109a0b(pbVar3,(int)pbVar50 - (int)pbVar3);\n        *param_4 = pbVar50 + 1;\n        uVar15 = parse_strtoul_and_check_overflow_00109a32(param_4,0,param_6);\n        if (**param_4 != 0x2c) {\n          print_bad_stab_00108fb9(pbVar27);\n          free(pvVar25);\n          free(pvVar17);\n          free(pvVar24);\n          return (void *)0x0;\n        }\n        uVar12 = (int)uVar49 + 1;\n        *param_4 = *param_4 + 1;\n        if ((uint)uVar45 <= uVar12) {\n          uVar45 = (ulong)((uint)uVar45 + 10);\n          pvVar17 = (void *)xrealloc(pvVar17,uVar45 << 3);\n          pvVar24 = (void *)xrealloc(pvVar24,uVar45 << 3);\n        }\n        *(void **)((long)pvVar17 + uVar49 * 8) = pvVar25;\n        *(undefined8 *)((long)pvVar24 + uVar49 * 8) = uVar15;\n        uVar49 = (ulong)uVar12;\n      }\n      *(undefined8 *)((long)pvVar17 + uVar49 * 8) = 0;\n      *(undefined8 *)((long)pvVar24 + uVar49 * 8) = 0;\n      if (**param_4 == 0x3b) {\n        *param_4 = *param_4 + 1;\n      }\n      pvVar17 = (void *)initialize_data_with_pointers_00113d6e(pvVar17,pvVar24);\n      break;\n    case 0x66:\n      uVar15 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      pvVar17 = (void *)initialize_and_store_data_00113ce0(uVar15,0,0);\n      break;\n    case 0x6b:\n      uVar15 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      pvVar17 = (void *)initialize_data_00113b71(uVar15);\n      break;\n    case 0x72:\n      if (param_6 <= pbVar27) {\n        return (void *)0x0;\n      }\n      cVar6 = parse_arguments_00109ab1(param_4,&local_98,param_6);\n      if (cVar6 == '\\0') {\n        return (void *)0x0;\n      }\n      bVar51 = false;\n      if ((uint)local_98 == (uint)local_a8) {\n        bVar51 = local_98._4_4_ == local_a8._4_4_;\n      }\n      lVar38 = 0;\n      if (**param_4 == 0x3d) {\n        *param_4 = pbVar27;\n        lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n        if (lVar38 == 0) {\n          return (void *)0x0;\n        }\n      }\n      if (**param_4 == 0x3b) {\n        *param_4 = *param_4 + 1;\n      }\n      pbVar3 = *param_4;\n      uVar49 = parse_strtoul_and_check_overflow_00109a32(param_4,&local_a9,param_6);\n      if (**param_4 != 0x3b) goto LAB_0010fb4c;\n      pbVar50 = *param_4 + 1;\n      *param_4 = pbVar50;\n      uVar45 = parse_strtoul_and_check_overflow_00109a32(param_4,&local_a0,param_6);\n      cVar6 = local_a9;\n      if (**param_4 != 0x3b) goto LAB_0010fb4c;\n      *param_4 = *param_4 + 1;\n      if ((local_a9 == '\\0') && ((char)local_a0 == '\\0')) {\nLAB_0010f700:\n        if (lVar38 != 0) goto LAB_0010f956;\n        if ((!bVar51) || (uVar49 != 0)) {\n          bVar52 = uVar45 != 0;\n          if ((!bVar51) || (bVar52)) {\n            if (((long)uVar49 < 1) || (bVar52)) {\n              if ((uVar45 == 0xffffffffffffffff) && (uVar49 == 0)) goto LAB_0010f788;\n              if (uVar49 == 0) goto LAB_0010f829;\n              if ((-1 < (long)uVar49) || (bVar52)) goto LAB_0010f8cd;\n              if ((uVar49 == 0xfffffffffffffff8) || (bVar51)) goto LAB_0010f89d;\n              if (uVar49 != 0xffffffffffffffff) {\n                if (uVar49 != 1) goto LAB_0010f956;\n                goto LAB_0010f8eb;\n              }\nLAB_0010f8ff:\n              if (uVar45 == 0x7f) goto LAB_0010f810;\n              if (uVar45 == 0x7fff) {\nLAB_0010f912:\n                pvVar17 = (void *)update_data_00113dfe(2,0);\n              }\n              else {\n                if (uVar45 != 0x7fffffff) {\n                  if (uVar45 == 0x7fffffffffffffff) goto LAB_0010f7a5;\n                  goto LAB_0010f956;\n                }\nLAB_0010f92f:\n                pvVar17 = (void *)update_data_00113dfe(4,0);\n              }\n            }\n            else {\n              pvVar17 = (void *)initialize_data_00113df2(uVar49 & 0xffffffff);\n            }\n          }\n          else if ((long)uVar49 < 1) {\n            if (-1 < (long)uVar49) {\nLAB_0010f8cd:\n              if (uVar49 == ~uVar45) goto LAB_0010f8ff;\n              if (uVar49 == uVar45 + 1) {\n                if (uVar45 == 0x7f) goto LAB_0010f810;\nLAB_0010f8eb:\n                if (uVar45 == 0x7fff) goto LAB_0010f912;\n                if (uVar45 == 0x7fffffff) goto LAB_0010f92f;\n              }\nLAB_0010f956:\n              if (bVar51) {\nLAB_0010fb4c:\n                print_bad_stab_00108fb9(pbVar27);\n                return (void *)0x0;\n              }\n              lVar38 = initialize_data_structure_0010c2d2(param_1,param_2,&local_98);\n              if (lVar38 == 0) {\n                uVar15 = dcgettext(0,\"missing index type\",5);\n                print_warning_00108fe8(pbVar27,uVar15);\n                lVar38 = update_data_00113dfe(4,0);\n                if (lVar38 == 0) {\n                  return (void *)0x0;\n                }\n              }\n              pvVar17 = (void *)initialize_data_00112904(0xf,0);\n              if (pvVar17 == (void *)0x0) {\n                return (void *)0x0;\n              }\n              plVar39 = (long *)xmalloc(0x18);\n              *plVar39 = lVar38;\n              plVar39[1] = uVar49;\n              plVar39[2] = uVar45;\n              *(long **)((long)pvVar17 + 0x10) = plVar39;\n              goto LAB_001115eb;\n            }\nLAB_0010f89d:\n            pvVar17 = (void *)update_data_00113dfe(-(int)uVar49,1);\n          }\n          else {\n            pvVar17 = (void *)initialize_data_00112904(5,uVar49 & 0xffffffff);\n          }\n        }\n        else {\n          if (uVar45 == 0) goto LAB_0010fa8f;\n          if (uVar45 == 0xffffffffffffffff) {\nLAB_0010f788:\n            if (param_3 != (char *)0x0) {\n              iVar10 = strcmp(param_3,\"long long int\");\n              if (iVar10 == 0) goto LAB_0010f7a5;\n              iVar10 = strcmp(param_3,\"long long unsigned int\");\n              if (iVar10 == 0) goto LAB_0010f7ce;\n            }\nLAB_0010f7f3:\n            pvVar17 = (void *)update_data_00113dfe(4,1);\n          }\n          else if (uVar45 == 0x7f) {\nLAB_0010f810:\n            pvVar17 = (void *)update_data_00113dfe(1,0);\n          }\n          else {\nLAB_0010f829:\n            if ((long)uVar45 < 0) {\n              pvVar17 = (void *)update_data_00113dfe(-(int)uVar45,1);\n            }\n            else if (uVar45 == 0xff) {\n              pvVar17 = (void *)update_data_00113dfe(1,1);\n            }\n            else {\n              if (uVar45 != 0xffff) {\n                if (uVar45 != 0xffffffff) goto LAB_0010f956;\n                goto LAB_0010f7f3;\n              }\n              pvVar17 = (void *)update_data_00113dfe(2,1);\n            }\n          }\n        }\n      }\n      else {\n        if (lVar38 != 0) {\nLAB_0010f6e2:\n          uVar15 = dcgettext(0,\"numeric overflow\",5);\n          print_warning_00108fe8(pbVar27,uVar15);\n          goto LAB_0010f700;\n        }\n        cVar8 = compare_strings_00113fb0(pbVar3,\"01000000000000000000000;\");\n        if ((cVar8 == '\\0') ||\n           (cVar8 = compare_strings_00113fb0(pbVar50,\"0777777777777777777777;\"), cVar8 == '\\0')) {\n          if ((cVar6 == '\\x01') ||\n             ((uVar49 != 0 ||\n              (cVar6 = compare_strings_00113fb0(pbVar50,\"01777777777777777777777;\"), cVar6 == '\\0'))))\n          goto LAB_0010f6e2;\nLAB_0010f7ce:\n          pvVar17 = (void *)update_data_00113dfe(8,1);\n        }\n        else {\nLAB_0010f7a5:\n          pvVar17 = (void *)update_data_00113dfe(8,0);\n        }\n      }\n      break;\n    case 0x73:\n    case 0x75:\n      uVar49 = parse_strtoul_and_check_overflow_00109a32(param_4,0,param_6);\n      pbVar3 = *param_4;\n      if (pbVar3 < param_6) {\n        local_118 = (void *)0x0;\n        if (*pbVar3 == 0x21) {\n          *param_4 = pbVar3 + 1;\n          uVar12 = parse_strtoul_and_check_overflow_00109a32(param_4,0,param_6);\n          if (**param_4 != 0x2c) {\nLAB_0010fe26:\n            print_bad_stab_00108fb9(pbVar3);\n            goto LAB_0010fe2e;\n          }\n          *param_4 = *param_4 + 1;\n          lVar38 = 0;\n          local_118 = (void *)xmalloc();\n          while ((uint)lVar38 < uVar12) {\n            bVar1 = **param_4;\n            if (bVar1 == 0x30) {\nLAB_0010fe06:\n              uVar44 = 0;\n            }\n            else {\n              if (bVar1 != 0x31) {\n                if (bVar1 != 0) {\n                  uVar15 = dcgettext(0,\"unknown virtual character for baseclass\",5);\n                  print_warning_00108fe8(pbVar3,uVar15);\n                  goto LAB_0010fe06;\n                }\n                goto LAB_0010fe26;\n              }\n              uVar44 = 1;\n            }\n            pbVar27 = *param_4;\n            *param_4 = pbVar27 + 1;\n            bVar1 = pbVar27[1];\n            if (bVar1 == 0x31) {\n              uVar11 = 1;\n            }\n            else {\n              if ((char)bVar1 < '2') {\n                if (bVar1 == 0) goto LAB_0010fe26;\n                uVar11 = 2;\n                if (bVar1 == 0x30) goto LAB_0010fd53;\nLAB_0010fe6c:\n                uVar15 = dcgettext(0,\"unknown visibility character for baseclass\",5);\n                print_warning_00108fe8(pbVar3,uVar15);\n              }\n              else if (bVar1 != 0x32) goto LAB_0010fe6c;\n              uVar11 = 0;\n            }\nLAB_0010fd53:\n            *param_4 = *param_4 + 1;\n            uVar13 = parse_strtoul_and_check_overflow_00109a32(param_4,0,param_6);\n            if (**param_4 != 0x2c) goto LAB_0010fe26;\n            *param_4 = *param_4 + 1;\n            lVar19 = FUNC_0010ee3f(param_1,param_2,0,param_4);\n            if (lVar19 == 0) goto LAB_0010fe2e;\n            plVar39 = (long *)xmalloc();\n            *(undefined8 *)((long)plVar39 + 0xd) = 0;\n            *(undefined4 *)(plVar39 + 1) = uVar13;\n            *(undefined4 *)((long)plVar39 + 0x14) = 0;\n            *plVar39 = lVar19;\n            *(long **)((long)local_118 + lVar38 * 8) = plVar39;\n            lVar38 = lVar38 + 1;\n            *(undefined *)((long)plVar39 + 0xc) = uVar44;\n            *(undefined4 *)(plVar39 + 2) = uVar11;\n            if (**param_4 != 0x3b) goto LAB_0010fe2e;\n            *param_4 = *param_4 + 1;\n          }\n          *(undefined8 *)((long)local_118 + lVar38 * 8) = 0;\n        }\n        pbVar3 = *param_4;\n        if (pbVar3 < param_6) {\n          uVar45 = 0;\n          local_158 = (void *)xmalloc(0x50);\n          bVar51 = false;\n          local_150._0_4_ = 10;\n          while (pbVar27 = *param_4, *pbVar27 != 0x3b) {\n            uVar12 = (int)uVar45 + 1;\n            if ((uint)local_150 <= uVar12) {\n              local_150._0_4_ = (uint)local_150 + 10;\n              local_158 = (void *)xrealloc(local_158);\n            }\n            if (((*pbVar27 == 0x24) || (*pbVar27 == 0x2e)) && (pbVar27[1] != 0x5f)) {\n              *param_4 = *param_4 + 1;\n              plVar39 = (long *)((long)local_158 + uVar45 * 8);\n              *plVar39 = 0;\n              pbVar27 = *param_4;\n              if (pbVar27 < param_6) {\n                if (*pbVar27 == 0x76) {\n                  *param_4 = pbVar27 + 1;\n                  bVar1 = pbVar27[1];\n                  if (bVar1 != 0) {\n                    *param_4 = pbVar27 + 2;\n                    lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n                    if (lVar38 == 0) goto LAB_001102dc;\n                    if (bVar1 == 0x62) {\n                      puVar22 = (undefined *)extract_data_from_binary_001129f4();\n                      if (puVar22 == (undefined *)0x0) {\n                        uVar15 = dcgettext(0,\"unnamed $vb type\",5);\n                        print_warning_00108fe8(pbVar27,uVar15);\n                        puVar22 = &DAT_001206ea;\n                      }\n                      pcVar40 = (char *)concat(&DAT_0012077e,puVar22,0);\n                    }\n                    else {\n                      pcVar40 = \"_vptr$\";\n                      if (bVar1 != 0x66) {\n                        uVar15 = dcgettext(0,\"unrecognized C++ abbreviation\",5);\n                        pcVar40 = \"INVALID_CPLUSPLUS_ABBREV\";\n                        print_warning_00108fe8(pbVar27,uVar15);\n                      }\n                    }\n                    if (**param_4 == 0x3a) {\n                      *param_4 = *param_4 + 1;\n                      pcVar16 = (char *)FUNC_0010ee3f(param_1,param_2,0);\n                      if (**param_4 == 0x2c) {\n                        *param_4 = *param_4 + 1;\n                        uVar11 = parse_strtoul_and_check_overflow_00109a32(param_4,0,param_6);\n                        if (**param_4 == 0x3b) {\n                          *param_4 = *param_4 + 1;\n                          ppcVar23 = (char **)xmalloc(0x20);\n                          *(undefined8 *)((long)ppcVar23 + 0x14) = 0;\n                          *(undefined4 *)((long)ppcVar23 + 0x1c) = 0;\n                          *ppcVar23 = pcVar40;\n                          ppcVar23[1] = pcVar16;\n                          *(undefined4 *)(ppcVar23 + 3) = uVar11;\n                          *(undefined4 *)(ppcVar23 + 2) = 2;\n                          *plVar39 = (long)ppcVar23;\n                          goto LAB_001102eb;\n                        }\n                      }\n                    }\n                  }\n                }\n                print_bad_stab_00108fb9(pbVar27);\n              }\nLAB_001102dc:\n              free(local_158);\n              goto LAB_0010fe2e;\n            }\n            pcVar40 = strchr((char *)pbVar27,0x3a);\n            if (pcVar40 == (char *)0x0) {\n              print_bad_stab_00108fb9(pbVar3);\n              free(local_158);\n              goto LAB_0010fe2e;\n            }\n            if (pcVar40[1] == ':') break;\n            pbVar27 = *param_4;\n            if (param_6 <= pbVar27) goto LAB_001102dc;\n            pvVar17 = (void *)copy_and_null_terminate_00109a0b(pbVar27,(int)pcVar40 - (int)pbVar27);\n            *param_4 = (byte *)(pcVar40 + 1);\n            if (pcVar40[1] == '/') {\n              *param_4 = (byte *)(pcVar40 + 2);\n              cVar6 = pcVar40[2];\n              if (cVar6 == '1') {\n                uVar11 = 1;\n              }\n              else if (cVar6 < '2') {\n                if (cVar6 == '\\0') {\n                  print_bad_stab_00108fb9(pbVar27);\n                  goto LAB_001102dc;\n                }\n                uVar11 = 2;\n                if (cVar6 != '0') goto LAB_00110152;\n              }\n              else {\n                if (cVar6 != '2') {\nLAB_00110152:\n                  uVar15 = dcgettext(0,\"unknown visibility character for field\",5);\n                  print_warning_00108fe8(pbVar27,uVar15);\n                }\n                uVar11 = 0;\n              }\n              *param_4 = *param_4 + 1;\n            }\n            else {\n              uVar11 = 0;\n            }\n            pvVar24 = (void *)FUNC_0010ee3f(param_1,param_2,0,param_4);\n            if (pvVar24 == (void *)0x0) {\nLAB_001101e1:\n              free(pvVar17);\n              goto LAB_001102dc;\n            }\n            puVar32 = (undefined8 *)((long)local_158 + uVar45 * 8);\n            pbVar50 = *param_4;\n            if (*pbVar50 != 0x3a) {\n              if (*pbVar50 == 0x2c) {\n                *param_4 = pbVar50 + 1;\n                uVar45 = parse_strtoul_and_check_overflow_00109a32(param_4,0,param_6);\n                if (**param_4 == 0x2c) {\n                  *param_4 = *param_4 + 1;\n                  uVar26 = parse_strtoul_and_check_overflow_00109a32(param_4,0,param_6);\n                  if (**param_4 == 0x3b) {\n                    *param_4 = *param_4 + 1;\n                    if ((uVar45 | uVar26) == 0) {\n                      uVar11 = 3;\n                    }\n                    ppvVar18 = (void **)xmalloc(0x20);\n                    *(undefined8 *)((long)ppvVar18 + 0x14) = 0;\n                    *ppvVar18 = pvVar17;\n                    ppvVar18[1] = pvVar24;\n                    *(int *)(ppvVar18 + 3) = (int)uVar45;\n                    *(int *)((long)ppvVar18 + 0x1c) = (int)uVar26;\n                    *(undefined4 *)(ppvVar18 + 2) = uVar11;\n                    *puVar32 = ppvVar18;\n                    goto LAB_001102eb;\n                  }\n                }\n              }\nLAB_001101d9:\n              print_bad_stab_00108fb9(pbVar27);\n              goto LAB_001101e1;\n            }\n            pbVar50 = pbVar50 + 1;\n            *param_4 = pbVar50;\n            pcVar40 = strchr((char *)pbVar50,0x3b);\n            if (pcVar40 == (char *)0x0) goto LAB_001101d9;\n            pvVar25 = (void *)copy_and_null_terminate_00109a0b(pbVar50);\n            *param_4 = (byte *)(pcVar40 + 1);\n            ppvVar18 = (void **)xmalloc(0x20);\n            bVar51 = true;\n            *(undefined8 *)((long)ppvVar18 + 0x15) = 0;\n            *ppvVar18 = pvVar17;\n            ppvVar18[1] = pvVar24;\n            *(undefined *)((long)ppvVar18 + 0x14) = 1;\n            ppvVar18[3] = pvVar25;\n            *(undefined4 *)(ppvVar18 + 2) = uVar11;\n            *puVar32 = ppvVar18;\nLAB_001102eb:\n            uVar45 = (ulong)uVar12;\n          }\n          *(undefined8 *)((long)local_158 + uVar45 * 8) = 0;\n          pbVar3 = *param_4;\n          if (param_6 <= pbVar3) goto LAB_001112f3;\n          local_128 = (char *)0x0;\n          pbVar27 = (byte *)0x0;\n          pvVar24 = (void *)0x0;\n          local_150 = (char *)0x0;\n          local_e0 = 0;\n          local_fc = 0;\nLAB_00110345:\n          pbVar50 = *param_4;\n          bVar1 = *pbVar50;\n          if (((bVar1 != 0x3b) && (pcVar40 = strchr((char *)pbVar50,0x3a), pcVar40 != (char *)0x0))\n             && (pcVar40[1] == ':')) {\n            pbVar28 = (byte *)(pcVar40 + 2);\n            if (((bVar1 == 0x6f) && (pbVar50[1] == 0x70)) && (pbVar50[2] == 0x24)) {\n              *param_4 = pbVar28;\n              for (pbVar50 = pbVar28; *pbVar50 != 0x2e; pbVar50 = pbVar50 + 1) {\n                if (*pbVar50 == 0) goto LAB_00110788;\n              }\n              pbVar50 = pbVar50 + 1;\n              local_150 = (char *)copy_and_null_terminate_00109a0b(pbVar28);\n            }\n            else {\n              local_150 = (char *)copy_and_null_terminate_00109a0b(pbVar50);\n              pbVar50 = pbVar28;\n            }\n            *param_4 = pbVar50;\n            local_128 = (char *)xmalloc();\n            local_ec = 10;\n            local_140 = (byte *)0x0;\n            local_f0 = 0;\nLAB_00110406:\n            pbVar50 = local_140;\n            if (local_140 == (byte *)0x0) {\n              pbVar50 = (byte *)FUNC_0010ee3f(param_1,param_2,0);\n              if (pbVar50 == (byte *)0x0) goto LAB_001111e9;\n              if (**param_4 != 0x3a) goto LAB_00110788;\n            }\n            pbVar28 = *param_4;\n            *param_4 = pbVar28 + 1;\n            pcVar40 = strchr((char *)(pbVar28 + 1),0x3b);\n            if (pcVar40 == (char *)0x0) goto LAB_00110788;\n            piVar21 = (int *)check_debug_information_00112b6e(pbVar50,0);\n            bVar52 = false;\n            if ((piVar21 != (int *)0x0) && (bVar52 = false, *piVar21 == 0x13)) {\n              bVar52 = true;\n              piVar21 = (int *)check_debug_information_00112b6e(pbVar50,0);\n              if (piVar21 != (int *)0x0) {\n                if (*piVar21 == 0xd) {\n                  lVar38 = *(long *)(*(long *)(piVar21 + 4) + 8);\n                }\n                else {\n                  if (*piVar21 != 0x13) goto LAB_001104b1;\n                  lVar38 = *(long *)(*(long *)(piVar21 + 4) + 0x10);\n                }\n                bVar52 = lVar38 == 0;\n              }\n            }\nLAB_001104b1:\n            pbVar27 = (byte *)copy_and_null_terminate_00109a0b(*param_4,(int)pcVar40 - (int)*param_4);\n            *param_4 = (byte *)(pcVar40 + 1);\n            cVar6 = pcVar40[1];\n            if (cVar6 == '0') {\n              local_100 = 2;\n            }\n            else if (cVar6 == '1') {\n              local_100 = 1;\n            }\n            else {\n              if (cVar6 == '\\0') goto LAB_00110788;\n              local_100 = 0;\n            }\n            *param_4 = (byte *)(pcVar40 + 2);\n            bVar1 = pcVar40[2];\n            if ('D' < (char)bVar1) {\nswitchD_00110537_caseD_40:\n              uVar15 = dcgettext(0,\"const/volatile indicator missing\",5);\n              print_warning_00108fe8(pbVar3,uVar15);\n              goto switchD_00110537_caseD_3f;\n            }\n            if ((char)bVar1 < '?') {\n              if ((bVar1 & 0xfb) != 0x2a) goto switchD_00110537_caseD_40;\n              goto switchD_00110537_caseD_3f;\n            }\n            switch(bVar1) {\n            default:\n              goto switchD_00110537_caseD_40;\n            case 0x41:\n              *param_4 = (byte *)(pcVar40 + 3);\n            case 0x3f:\nswitchD_00110537_caseD_3f:\n              local_130 = '\\0';\n              local_138 = '\\0';\n              break;\n            case 0x42:\n              local_130 = '\\0';\n              *param_4 = (byte *)(pcVar40 + 3);\n              local_138 = '\\x01';\n              break;\n            case 0x43:\n              local_130 = '\\x01';\n              *param_4 = (byte *)(pcVar40 + 3);\n              local_138 = '\\0';\n              break;\n            case 0x44:\n              local_130 = '\\x01';\n              *param_4 = (byte *)(pcVar40 + 3);\n              local_138 = '\\x01';\n            }\n            pbVar28 = *param_4;\n            bVar1 = *pbVar28;\n            pbVar31 = pbVar27;\n            if (bVar1 == 0x2e) {\n              *param_4 = pbVar28 + 1;\nLAB_001106bd:\n              bVar41 = false;\n              local_120 = (byte *)0x0;\n              local_110 = (byte *)0x0;\n              local_140 = (byte *)0x0;\n            }\n            else {\n              if (bVar1 == 0x3f) {\n                *param_4 = pbVar28 + 1;\n                sVar33 = strlen(local_150);\n                iVar10 = strncmp((char *)pbVar27,local_150,sVar33);\n                if (iVar10 == 0) {\n                  bVar41 = true;\n                  local_120 = (byte *)0x0;\n                  local_110 = (byte *)0x0;\n                  local_140 = (byte *)0x0;\n                  goto LAB_00110703;\n                }\n                bVar41 = true;\n                local_140 = (byte *)0x0;\n                local_120 = (byte *)0x0;\n                local_110 = (byte *)0x0;\nLAB_0011072b:\n                lVar38 = initialize_data_structure_0010c2d2(param_1,param_2,&local_a8);\n                if (lVar38 == 0) goto LAB_001111e9;\n                piVar21 = (int *)check_debug_information_00112b6e(pbVar50,0);\n                if ((piVar21 == (int *)0x0) ||\n                   (((*piVar21 != 0xd && (*piVar21 != 0x13)) ||\n                    (lVar19 = **(long **)(piVar21 + 4), lVar19 == 0)))) goto LAB_00110788;\n                bVar1 = *pbVar27;\n                if (((bVar1 == 0x5f) && (pbVar27[1] == 0x5f)) &&\n                   ((bVar47 = pbVar27[2], ((&_sch_istable)[(ulong)bVar47 * 2] & 4) != 0 ||\n                    (bVar47 == 0x51 || bVar47 == 0x74)))) {\n                  bVar52 = true;\n                  bVar47 = 1;\nLAB_00110827:\n                  bVar2 = pbVar27[1];\n                  if ((bVar2 == 0x24) || (bVar2 == 0x2e)) {\n                    if (pbVar27[2] != 0x5f) goto LAB_0011085d;\n                    goto LAB_00110a69;\n                  }\n                  bVar7 = compare_strings_00113fb0(pbVar27,&DAT_001207c3);\n                  if (bVar2 != 0x5a) goto LAB_0011086f;\n                  if ((bVar47 | bVar7) != 0) goto LAB_00110a58;\n                  uVar45 = 0;\nLAB_00110a9d:\n                  local_a0 = pbVar31;\n                  if ((*pbVar31 == 0x5f) && (pbVar31[1] == 0x5a)) {\n                    sVar33 = strlen((char *)pbVar31);\n                    cplus_demangle_init_info(pbVar31,3,sVar33,&local_98);\n                    pvVar17 = malloc((long)local_6c << 5);\n                    local_78 = pvVar17;\n                    pvVar25 = malloc((long)local_5c << 3);\n                    local_68 = pvVar25;\n                    if ((pvVar17 == (void *)0x0) || (pvVar25 == (void *)0x0)) {\n                      free(pvVar17);\n                      free(pvVar25);\n                    }\n                    else {\n                      piVar21 = (int *)cplus_demangle_mangled_name(&local_98,1);\n                      if (*(char *)CONCAT71(uStack_7f,local_80) == '\\0') {\n                        free(local_68);\n                        pvVar17 = local_78;\n                        if (piVar21 != (int *)0x0) {\n                          if ((*piVar21 == 3) && (**(int **)(piVar21 + 6) == 0x29)) {\n                            lVar20 = extract_arglist_demangled_values_0010b6ea(param_1,param_2,\n                                                  *(undefined8 *)(*(int **)(piVar21 + 6) + 6),\n                                                  &local_a9);\n                            free(pvVar17);\n                            goto LAB_001110a9;\n                          }\n                          pcVar40 = (char *)dcgettext(0,\"Demangled name is not a function\\n\",5);\n                          fprintf(_stderr,pcVar40);\n                          free(pvVar17);\n                          goto LAB_001111e9;\n                        }\n                      }\n                      else {\n                        free(local_68);\n                      }\n                      free(local_78);\n                    }\n                    print_error_message_0010911f(pbVar31);\n                  }\n                  else {\n                    local_80 = '\\0';\n                    local_88 = 0;\n                    local_6c = 10;\n                    local_98 = param_1;\n                    local_90 = param_2;\n                    local_78 = (void *)xmalloc(0xa0);\n                    pbVar50 = local_a0;\n                    local_70 = 0;\n                    pbVar28 = local_a0;\n                    if ((int)uVar45 == 0) {\n                      do {\n                        pbVar42 = (byte *)strchr((char *)pbVar28,0x5f);\n                        if (pbVar42 == (byte *)0x0) {\n                          print_error_message_0010911f(pbVar50);\n                          goto LAB_00111097;\n                        }\n                        pbVar28 = pbVar42 + 1;\n                      } while (pbVar42[1] != 0x5f);\n                      sVar33 = strspn((char *)pbVar42,\"_\");\n                      if (2 < (uint)sVar33) {\n                        pbVar42 = pbVar42 + ((uint)sVar33 - 2);\n                      }\n                    }\n                    else {\n                      pbVar42 = local_a0 + uVar45;\n                    }\n                    bVar1 = pbVar42[2];\n                    if (local_a0 == pbVar42) {\n                      if ((((&_sch_istable)[(ulong)bVar1 * 2] & 4) != 0) ||\n                         (pbVar50 = pbVar42, bVar1 == 0x51 || bVar1 == 0x74)) {\n                        local_a0 = pbVar42 + 2;\nLAB_00110d86:\n                        pbVar50 = local_a0;\n                        if (*local_a0 != 0) {\n                          pbVar28 = (byte *)0x0;\n                          cVar8 = '\\0';\n                          cVar6 = '\\0';\n                          while (pbVar42 = local_a0, bVar1 = *local_a0, bVar1 != 0) {\n                            if (bVar1 == 0x51) {\n                              cVar6 = parse_and_validate_input_0010d559(&local_98,&local_a0,0);\n                              if (cVar6 != '\\0') {\n                                cVar6 = resize_and_add_to_buffer_00109be3(&local_98,pbVar42,(int)local_a0 - (int)pbVar42)\n                                ;\njoined_r0x00110fbc:\n                                if (cVar6 != '\\0') {\n                                  pbVar28 = (byte *)0x0;\n                                  goto LAB_0011100c;\n                                }\n                              }\n                              goto LAB_00111097;\n                            }\n                            if ('Q' < (char)bVar1) {\n                              if (bVar1 == 0x5f) {\n                                print_error_message_0010911f(pbVar50);\n                              }\n                              else {\n                                if (bVar1 != 0x74) {\n                                  if (bVar1 != 0x53) goto LAB_00110fd7;\n                                  goto LAB_00110ead;\n                                }\n                                if (pbVar28 == (byte *)0x0) {\n                                  pbVar28 = local_a0;\n                                }\n                                cVar6 = parse_and_validate_input_0010d21c(&local_98,&local_a0,0);\n                                if (cVar6 != '\\0') {\n                                  cVar6 = resize_and_add_to_buffer_00109be3(&local_98,pbVar28,\n                                                       (int)local_a0 - (int)pbVar28);\n                                  goto joined_r0x00110fbc;\n                                }\n                              }\n                              goto LAB_00111097;\n                            }\n                            if (bVar1 != 0x43) {\n                              if ((char)bVar1 < 'D') {\n                                if ((byte)(bVar1 - 0x30) < 10) {\n                                  if (pbVar28 == (byte *)0x0) {\n                                    pbVar28 = local_a0;\n                                  }\n                                  uVar12 = parse_integer_00108e76(&local_a0);\n                                  pbVar5 = local_a0;\n                                  sVar33 = strlen((char *)local_a0);\n                                  if (uVar12 <= sVar33) {\n                                    local_a0 = pbVar5 + uVar12;\n                                    cVar6 = resize_and_add_to_buffer_00109be3(&local_98,pbVar28,\n                                                         (int)local_a0 - (int)pbVar28);\n                                    goto joined_r0x00110fbc;\n                                  }\n                                  print_error_message_0010911f(pbVar42);\n                                  goto LAB_00111097;\n                                }\n                              }\n                              else if (bVar1 == 0x46) {\n                                local_a0 = local_a0 + 1;\n                                cVar8 = parse_input_0010d882(&local_98,&local_a0,&local_88,&local_80);\n                                if (cVar8 != '\\0') {\n                                  pbVar28 = (byte *)0x0;\n                                  pbVar42 = local_a0;\n                                  goto LAB_00111004;\n                                }\n                                goto LAB_00111097;\n                              }\nLAB_00110fd7:\n                              cVar8 = parse_input_0010d882(&local_98,&local_a0,&local_88,&local_80);\n                              pbVar42 = local_a0;\n                              if (cVar8 != '\\0') goto LAB_00111004;\n                              goto LAB_00111097;\n                            }\nLAB_00110ead:\n                            pbVar42 = local_a0 + 1;\n                            if (pbVar28 == (byte *)0x0) {\n                              pbVar28 = local_a0;\n                            }\nLAB_00111004:\n                            local_a0 = pbVar42;\n                            if (cVar6 != '\\0') {\nLAB_0011100c:\n                              cVar8 = parse_input_0010d882(&local_98,&local_a0,&local_88,&local_80);\n                              cVar6 = cVar8;\n                              if (cVar8 == '\\0') goto LAB_00111097;\n                            }\n                          }\n                          if ((cVar8 == '\\0') &&\n                             (cVar6 = parse_input_0010d882(&local_98,&local_a0,&local_88,&local_80),\n                             cVar6 == '\\0')) goto LAB_00111097;\n                        }\n                        free(local_78);\n                        local_78 = (void *)0x0;\n                        if (local_88 == 0) {\n                          pcVar40 = (char *)dcgettext(0,\"no argument types in mangled string\\n\",5);\n                          fprintf(_stderr,pcVar40);\n                        }\n                        local_a9 = local_80;\n                        lVar20 = local_88;\nLAB_001110a9:\n                        if (lVar20 != 0) {\n                          pbVar50 = (byte *)initialize_data_and_allocate_memory_00113b98(lVar19,lVar38,lVar20,local_a9);\n                          goto LAB_001110d5;\n                        }\n                        goto LAB_001111e9;\n                      }\n                      for (; *pbVar50 == 0x5f; pbVar50 = pbVar50 + 1) {\n                      }\n                      pcVar40 = strstr((char *)pbVar50,\"__\");\n                      if ((pcVar40 != (char *)0x0) && (pcVar40[2] != '\\0')) {\n                        cVar6 = validate_and_execute_00113e5e(&local_98,&local_a0,pcVar40);\n                        goto LAB_00110d7e;\n                      }\n                      print_error_message_0010911f(pbVar42);\n                    }\n                    else if (bVar1 == 0) {\n                      print_error_message_0010911f(local_a0);\n                    }\n                    else {\n                      cVar6 = validate_and_execute_00113e5e(&local_98,&local_a0,pbVar42);\nLAB_00110d7e:\n                      if (cVar6 != '\\0') goto LAB_00110d86;\n                    }\nLAB_00111097:\n                    free(local_78);\n                  }\n                  goto LAB_001111e9;\n                }\n                cVar6 = compare_strings_00113fb0(pbVar27,&DAT_001207be);\n                if (cVar6 == '\\0') {\n                  if (param_3 == (char *)0x0) {\n                    bVar47 = 0;\n                    bVar52 = false;\n                  }\n                  else {\n                    iVar10 = strcmp(local_150,param_3);\n                    bVar52 = iVar10 == 0;\n                    bVar47 = 0;\n                  }\n                }\n                else {\n                  bVar47 = 1;\n                  bVar52 = true;\n                }\n                if (bVar1 == 0x5f) goto LAB_00110827;\nLAB_0011085d:\n                bVar7 = compare_strings_00113fb0(pbVar27,&DAT_001207c3);\nLAB_0011086f:\n                if ((bVar47 | bVar7) == 0) {\n                  pcVar40 = param_3;\n                  if (param_3 == (char *)0x0) {\n                    if (local_138 == '\\0') {\n                      pcVar16 = \"\";\n                      if (local_130 != '\\0') {\n                        pcVar16 = \"V\";\n                      }\n                      pcVar46 = \"\";\n                    }\n                    else {\n                      pcVar16 = \"\";\n                      if (local_130 != '\\0') {\n                        pcVar16 = \"V\";\n                      }\n                      pcVar46 = \"C\";\n                    }\nLAB_00110917:\n                    iVar10 = 0;\n                    sprintf((char *)&local_98,\"__%s%s\",pcVar46,pcVar16);\n                  }\n                  else {\n                    pcVar46 = \"C\";\n                    pcVar16 = \"V\";\n                    sVar33 = strlen(param_3);\n                    iVar10 = (int)sVar33;\n                    if (local_138 == '\\0') {\n                      pcVar46 = \"\";\n                    }\n                    if (local_130 == '\\0') {\n                      pcVar16 = \"\";\n                    }\n                    if (iVar10 == 0) goto LAB_00110917;\n                    pcVar29 = strchr(param_3,0x3c);\n                    if (pcVar29 == (char *)0x0) {\n                      sprintf((char *)&local_98,\"__%s%s%d\",pcVar46,pcVar16);\n                    }\n                    else {\n                      iVar10 = 0;\n                      sprintf((char *)&local_98,\"__%s%s\",pcVar46,pcVar16);\n                      pcVar40 = (char *)0x0;\n                    }\n                  }\n                  iVar14 = 0;\n                  if (!bVar52) {\n                    sVar33 = strlen(local_150);\n                    iVar14 = (int)sVar33;\n                  }\n                  sVar33 = strlen((char *)&local_98);\n                  sVar30 = strlen((char *)pbVar27);\n                  local_d0 = (int)sVar33;\n                  if (((*local_150 == 'o') && (local_150[1] == 'p')) &&\n                     ((local_150[2] == '$' || (local_150[2] == '.')))) goto LAB_001111e9;\n                  pbVar31 = (byte *)xmalloc(iVar10 + 1 + iVar14 + local_d0 + (int)sVar30);\n                  if (bVar52) {\n                    *pbVar31 = 0;\n                  }\n                  else {\n                    strcpy((char *)pbVar31,local_150);\n                  }\n                  sVar33 = strlen((char *)pbVar31);\n                  uVar45 = sVar33 & 0xffffffff;\n                  strcpy((char *)(pbVar31 + sVar33),(char *)&local_98);\n                  if (pcVar40 != (char *)0x0) {\n                    strcat((char *)pbVar31,pcVar40);\n                  }\n                  strcat((char *)pbVar31,(char *)pbVar27);\n                  if (*pbVar27 != 0) goto LAB_00110a9d;\n                }\n                else {\nLAB_00110a58:\n                  if ((bVar1 != 0) && ((bVar7 & 1) == 0)) {\n                    uVar45 = 0;\n                    goto LAB_00110a9d;\n                  }\n                }\nLAB_00110a69:\n                puVar32 = (undefined8 *)xmalloc(8);\n                *puVar32 = 0;\n                pbVar50 = (byte *)initialize_data_and_allocate_memory_00113b98(lVar19,lVar38,puVar32,0);\nLAB_001110d5:\n                if (pbVar50 == (byte *)0x0) goto LAB_001111e9;\n                goto LAB_001110de;\n              }\n              if (bVar1 != 0x2a) {\n                print_warning_00108fe8(pbVar3,\"member function type missing\");\n                goto LAB_001106bd;\n              }\n              *param_4 = pbVar28 + 1;\n              uVar12 = parse_strtoul_and_check_overflow_00109a32(param_4,0,param_6);\n              pbVar28 = *param_4;\n              if (*pbVar28 != 0x3b) goto LAB_00110788;\n              local_110 = (byte *)(ulong)(uVar12 & 0x7fffffff);\n              *param_4 = pbVar28 + 1;\n              bVar41 = pbVar28[1] == 0x3b || pbVar28[1] == 0;\n              if (bVar41) {\n                bVar41 = false;\n                local_120 = (byte *)0x0;\n                local_140 = (byte *)0x0;\n              }\n              else {\n                pbVar28 = (byte *)FUNC_0010ee3f(param_1,param_2,0,param_4);\n                bVar1 = **param_4;\n                if (bVar1 != 0x3a) {\n                  if (bVar1 == 0x3b) {\n                    *param_4 = *param_4 + 1;\n                    local_140 = (byte *)0x0;\n                    local_120 = pbVar28;\n                    goto LAB_00110703;\n                  }\n                  goto LAB_00110788;\n                }\n                local_120 = (byte *)0x0;\n                local_140 = pbVar28;\n              }\n            }\nLAB_00110703:\n            if (bVar52) goto LAB_0011072b;\nLAB_001110de:\n            uVar12 = local_f0 + 1;\n            if (local_ec <= uVar12) {\n              local_ec = local_ec + 10;\n              local_128 = (char *)xrealloc(local_128,(ulong)local_ec << 3);\n            }\n            if (bVar41) {\n              ppbVar34 = (byte **)xmalloc(0x28);\n              puVar22 = (undefined *)((long)ppbVar34 + 0x16);\n              for (lVar38 = 0x12; lVar38 != 0; lVar38 = lVar38 + -1) {\n                *puVar22 = 0;\n                puVar22 = puVar22 + (ulong)bVar48 * -2 + 1;\n              }\n              *ppbVar34 = pbVar31;\n              ppbVar34[1] = pbVar50;\n              *(undefined4 *)(ppbVar34 + 2) = local_100;\n              ppbVar34[3] = (byte *)0xffffffffffffffff;\n              *(char *)((long)ppbVar34 + 0x14) = local_138;\n              *(char *)((long)ppbVar34 + 0x15) = local_130;\n            }\n            else {\n              ppbVar34 = (byte **)xmalloc(0x28);\n              puVar22 = (undefined *)((long)ppbVar34 + 0x16);\n              for (lVar38 = 0x12; lVar38 != 0; lVar38 = lVar38 + -1) {\n                *puVar22 = 0;\n                puVar22 = puVar22 + (ulong)bVar48 * -2 + 1;\n              }\n              *ppbVar34 = pbVar31;\n              ppbVar34[1] = pbVar50;\n              *(undefined4 *)(ppbVar34 + 2) = local_100;\n              *(char *)((long)ppbVar34 + 0x14) = local_138;\n              *(char *)((long)ppbVar34 + 0x15) = local_130;\n              ppbVar34[3] = local_110;\n              ppbVar34[4] = local_120;\n            }\n            *(byte ***)(local_128 + (ulong)local_f0 * 8) = ppbVar34;\n            pbVar50 = *param_4;\n            if ((*pbVar50 == 0x3b) || (local_f0 = uVar12, *pbVar50 == 0)) goto LAB_00111678;\n            goto LAB_00110406;\n          }\n          if (pvVar24 != (void *)0x0) {\n            *(undefined8 *)((long)pvVar24 + (ulong)local_fc * 8) = 0;\n          }\n          pbVar3 = *param_4;\n          if (param_6 <= pbVar3) goto LAB_001112f3;\n          if (*pbVar3 == 0x3b) {\n            *param_4 = pbVar3 + 1;\n          }\n          pbVar27 = *param_4;\n          if (*pbVar27 == 0x7e) {\n            *param_4 = pbVar27 + 1;\n            if (((pbVar27[1] & 0xef) == 0x2d) || (pbVar27[1] == 0x2b)) {\n              *param_4 = pbVar27 + 2;\n            }\n            if (**param_4 != 0x25) goto LAB_001112ee;\n            pbVar27 = *param_4 + 1;\n            *param_4 = pbVar27;\n            cVar6 = parse_arguments_00109ab1(param_4,&local_98,param_6);\n            if (cVar6 == '\\0') goto LAB_001112f3;\n            if ((uint)local_98 != (uint)local_a8) {\nLAB_001112a2:\n              *param_4 = pbVar27;\n              pvVar25 = (void *)FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n              for (pbVar27 = *param_4; *pbVar27 != 0x3b; pbVar27 = pbVar27 + 1) {\n                if (*pbVar27 == 0) {\n                  print_bad_stab_00108fb9(pbVar3);\n                  goto LAB_001112f3;\n                }\n              }\n              *param_4 = pbVar27 + 1;\n              goto LAB_00111307;\n            }\n            if (local_98._4_4_ != local_a8._4_4_) goto LAB_001112a2;\n            pvVar25 = (void *)0x0;\n          }\n          else {\nLAB_001112ee:\n            pvVar25 = (void *)0x0;\nLAB_00111307:\n            if ((((ulong)local_118 | (ulong)pvVar24 | (ulong)pvVar25) == 0) && (!bVar51)) {\n              pvVar17 = (void *)initialize_data_with_offset_00113da9(bVar9 == 0x73,uVar49,local_158);\n              break;\n            }\n            cVar6 = '\\0';\n          }\n          pvVar17 = (void *)initialize_data_00112904((bVar9 != 0x73) + '\\t',uVar49 & 0xffffffff);\n          if (pvVar17 == (void *)0x0) {\n            return (void *)0x0;\n          }\n          ppvVar35 = (void **)xmalloc(0x28);\n          lVar38 = 8;\n          ppvVar18 = ppvVar35 + 1;\n          if (cVar6 != '\\0') {\n            pvVar25 = pvVar17;\n          }\n          for (; lVar38 != 0; lVar38 = lVar38 + -1) {\n            *(undefined4 *)ppvVar18 = 0;\n            ppvVar18 = (void **)((long)ppvVar18 + (ulong)bVar48 * -8 + 4);\n          }\n          ppvVar35[3] = pvVar24;\n          ppvVar35[4] = pvVar25;\n          *ppvVar35 = local_158;\n          ppvVar35[2] = local_118;\n          *(void ***)((long)pvVar17 + 0x10) = ppvVar35;\n          goto LAB_001115eb;\n        }\n      }\nLAB_0010fe2e:\n      local_158 = (void *)0x0;\nLAB_001112f3:\n      free(local_158);\n      return (void *)0x0;\n    case 0x78:\n      bVar48 = pbVar50[1];\n      if (bVar48 == 0x73) {\nLAB_0010f0fd:\n        uVar15 = 7;\n      }\n      else if ((char)bVar48 < 't') {\n        if (bVar48 == 0) goto switchD_0010f055_caseD_24;\n        uVar15 = 0xb;\n        if (bVar48 != 0x65) goto LAB_0010f0df;\n      }\n      else {\n        uVar15 = 8;\n        if (bVar48 != 0x75) {\nLAB_0010f0df:\n          uVar15 = dcgettext(0,\"unrecognized cross reference type\",5);\n          print_warning_00108fe8(pbVar3,uVar15);\n          goto LAB_0010f0fd;\n        }\n      }\n      pbVar27 = *param_4 + 1;\n      *param_4 = pbVar27;\n      pcVar16 = strchr((char *)pbVar27,0x3c);\n      pcVar40 = strchr((char *)pbVar27,0x3a);\n      if (pcVar40 == (char *)0x0) {\nswitchD_0010f055_caseD_24:\n        print_bad_stab_00108fb9(pbVar3);\n        return (void *)0x0;\n      }\n      if (((pcVar16 != (char *)0x0) && (pcVar16 < pcVar40)) && (pcVar40[1] == ':')) {\n        iVar10 = 0;\n        for (; cVar6 = *pcVar16, cVar6 != '\\0'; pcVar16 = pcVar16 + 1) {\n          if (cVar6 == '<') {\n            iVar10 = iVar10 + 1;\n          }\n          else if (cVar6 == '>') {\n            iVar10 = iVar10 + -1;\n          }\n          else if ((iVar10 == 0) && (pcVar40 = pcVar16, cVar6 == ':')) goto LAB_0010f176;\n        }\n        goto switchD_0010f055_caseD_24;\n      }\nLAB_0010f176:\n      uVar49 = (long)pcVar40 - (long)pbVar27;\n      if ((param_3 != (char *)0x0) &&\n         ((iVar10 = strncmp(param_3,(char *)pbVar27,uVar49), iVar10 == 0 &&\n          (param_3[uVar49] == '\\0')))) {\n        *(undefined *)(param_2 + 0x1a8) = 1;\n      }\n      pvVar17 = (void *)find_match_and_free_0010afd5(param_1,param_2,pbVar27,uVar49 & 0xffffffff,uVar15);\n      *param_4 = (byte *)(pcVar40 + 1);\n    }\n  }\nLAB_001115e2:\n  if (pvVar17 == (void *)0x0) {\n    return (void *)0x0;\n  }\nLAB_001115eb:\n  if ((uint)local_a8 != -1) {\n    ppvVar18 = (void **)validate_and_get_subsection_00109022(param_2,&local_a8);\n    if (ppvVar18 == (void **)0x0) {\n      return (void *)0x0;\n    }\n    *ppvVar18 = pvVar17;\n  }\n  if (local_12c != 0xffffffff) {\n    uVar12 = *(uint *)((long)pvVar17 + 4);\n    if ((uVar12 != 0) && (local_12c != uVar12)) {\n      pcVar40 = (char *)dcgettext(0,\"Warning: changing type size from %d to %d\\n\",5);\n      fprintf(_stderr,pcVar40,(ulong)uVar12,(ulong)local_12c);\n    }\n    *(uint *)((long)pvVar17 + 4) = local_12c;\n    return pvVar17;\n  }\n  return pvVar17;\nLAB_00110788:\n  print_bad_stab_00108fb9(pbVar3);\nLAB_001111e9:\n  free(local_150);\n  free(local_128);\n  free(pbVar27);\n  goto LAB_001112f3;\nLAB_00111678:\n  *(undefined8 *)(local_128 + (ulong)uVar12 * 8) = 0;\n  if (*pbVar50 != 0) {\n    *param_4 = pbVar50 + 1;\n  }\n  if (local_e0 <= local_fc + 1) {\n    local_e0 = local_e0 + 10;\n    pvVar24 = (void *)xrealloc(pvVar24,(ulong)local_e0 << 3);\n  }\n  ppcVar23 = (char **)xmalloc(0x10);\n  *ppcVar23 = local_150;\n  ppcVar23[1] = local_128;\n  *(char ***)((long)pvVar24 + (ulong)local_fc * 8) = ppcVar23;\n  local_fc = local_fc + 1;\n  goto LAB_00110345;\n}\n\n",
            "called": [
                "cplus_demangle_init_info",
                "FUN_00108fe8",
                "FUN_00113d3a",
                "FUN_00108e76",
                "strchr",
                "concat",
                "FUN_00113fb0",
                "strcmp",
                "FUN_00113b98",
                "strlen",
                "fprintf",
                "FUN_001129f4",
                "FUN_00109ab1",
                "FUN_00113ce0",
                "FUN_00113c43",
                "FUN_00108fb9",
                "FUN_00109022",
                "FUN_00113b71",
                "FUN_0010911f",
                "FUN_0010d559",
                "strncmp",
                "FUN_0010ee3f",
                "FUN_00112b6e",
                "FUN_00109be3",
                "FUN_00113dfe",
                "FUN_00113e17",
                "FUN_00113cb9",
                "strstr",
                "FUN_00112904",
                "FUN_0010c2d2",
                "xmalloc",
                "malloc",
                "FUN_00113bfa",
                "FUN_00113d6e",
                "FUN_00113da9",
                "xrealloc",
                "strspn",
                "FUN_0010afd5",
                "sprintf",
                "FUN_00109a32",
                "cplus_demangle_mangled_name",
                "strcpy",
                "dcgettext",
                "FUN_0010914e",
                "FUN_0010d21c",
                "FUN_00109a0b",
                "strtol",
                "FUN_00113b4a",
                "FUN_0010b6ea",
                "strcat",
                "FUN_0010d882",
                "free",
                "FUN_00113df2",
                "FUN_00113e5e"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0010ee3f",
            "calling": [
                "FUN_0011173a",
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "FUNC_0010ee3f"
        },
        "strerror": {
            "renaming": {},
            "code": "\n\n\nchar * strerror(int __errnum)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strerror(__errnum);\n  return pcVar1;\n}\n\n",
            "called": [
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104890",
            "calling": [
                "FUN_00104966",
                "FUN_00104ea2",
                "FUN_00116b90",
                "FUN_0010882c",
                "FUN_00108200",
                "FUN_00114460",
                "FUN_0010543c",
                "FUN_00114690",
                "FUN_001199d0",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "strerror"
        },
        "bfd_decode_symclass": {
            "renaming": {},
            "code": "\nvoid bfd_decode_symclass(void)\n\n{\n  bfd_decode_symclass();\n  return;\n}\n\n",
            "called": [
                "bfd_decode_symclass"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104490",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_decode_symclass"
        },
        "FUN_00108b3e": {
            "renaming": {
                "FUN_00108b3e": "print_stab_entries_00108b3e",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "__format": "formatStr",
                "lVar1": "stabName",
                "lVar2": "index",
                "lVar3": "offset",
                "piVar4": "stabEntry",
                "iVar5": "counter"
            },
            "code": "\n\n\nundefined8 printStabEntries_00108b3e(undefined8 param1,undefined8 param2,undefined8 param3)\n\n{\n  char *formatStr;\n  long stabName;\n  long index;\n  long offset;\n  int *stabEntry;\n  int counter;\n  \n  formatStr = (char *)dcgettext(0,\"Last stabs entries before error:\\n\",5);\n  fprintf(_stderr,formatStr);\n  fwrite(\"n_type n_desc n_value  string\\n\",1,0x1e,_stderr);\n  counter = DAT_001278a0;\n  do {\n    index = (long)counter;\n    offset = index * 0x18;\n    stabEntry = (int *)(&DAT_00127720 + offset);\n    if ((&DAT_00127730)[index * 3] != 0) {\n      stabName = bfd_get_stab_name(*stabEntry);\n      if (stabName == 0) {\n        if (*stabEntry == 0) {\n          fwrite(\"HdrSym\",1,6,_stderr);\n        }\n        else {\n          fprintf(_stderr,\"%-6d\");\n        }\n      }\n      else {\n        fprintf(_stderr,\"%-6s\",stabName);\n      }\n      fprintf(_stderr,\" %-6d \",(ulong)*(uint *)(&DAT_00127724 + offset));\n      fprintf(_stderr,\"%08lx\",*(undefined8 *)(&DAT_00127728 + offset));\n      if (*stabEntry != 0) {\n        fprintf(_stderr,\" %s\",(&DAT_00127730)[index * 3]);\n      }\n      fputc(10,_stderr);\n    }\n    counter = (counter + 1) % 0x10;\n  } while (DAT_001278a0 != counter);\n  return param3;\n}\n\n",
            "called": [
                "fputc",
                "fprintf",
                "dcgettext",
                "fwrite",
                "bfd_get_stab_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108b3e",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "print_stab_entries_00108b3e"
        },
        "FUN_0010a083": {
            "renaming": {
                "FUN_0010a083": "process_and_update_data_0010a083",
                "param_1": "data_address",
                "process_data_00109ed3": "process_data_and_update"
            },
            "code": "\nvoid process_and_update_data_0010a083(long data_address)\n\n{\n  process_data_and_update(data_address,0x2a,4,data_address + 0x178,data_address + 0x180);\n  return;\n}\n\n",
            "called": [
                "FUN_00109ed3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a083",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "process_and_update_data_0010a083"
        },
        "strstr": {
            "renaming": {},
            "code": "\n\n\nchar * strstr(char *__haystack,char *__needle)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strstr(__haystack,__needle);\n  return pcVar1;\n}\n\n",
            "called": [
                "strstr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048c0",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010d21c"
            ],
            "imported": false,
            "current_name": "strstr"
        },
        "FUN_00109c2e": {
            "renaming": {
                "FUN_00109c2e": "resize_array_00109c2e",
                "param_1": "array",
                "param_2": "element",
                "param_3": "newSize",
                "param_4": "flag",
                "param_5": "dataPointer",
                "param_6": "extraArg",
                "lVar1": "currentSize",
                "plVar2": "lastElement",
                "lVar3": "difference",
                "puVar4": "currentPointer",
                "uVar5": "oldSize",
                "bVar6": "boolVar",
                "auVar7": "returnValue"
            },
            "code": "\nundefined  [16]\nresizeArray_00109c2e(long array,long element,ulong newSize,int flag,undefined4 *dataPointer,\n            undefined8 extraArg)\n\n{\n  long currentSize;\n  long *lastElement;\n  long difference;\n  undefined *currentPointer;\n  ulong oldSize;\n  byte boolVar;\n  undefined returnValue [16];\n  \n  boolVar = 0;\n  newSize = newSize & 0xffffffff;\n  oldSize = *(ulong *)(array + 0x1b0);\n  if (oldSize <= newSize) {\n    if (oldSize == 0) {\n      oldSize = 10;\n    }\n    for (; oldSize <= newSize; oldSize = oldSize * 2) {\n    }\n    currentSize = xrealloc(*(undefined8 *)(array + 0x1a8),oldSize * 0x18);\n    *(long *)(array + 0x1a8) = currentSize;\n    currentPointer = (undefined *)(*(long *)(array + 0x1b0) * 0x18 + currentSize);\n    for (difference = (oldSize - *(long *)(array + 0x1b0)) * 0x18; difference != 0; difference = difference + -1) {\n      *currentPointer = 0;\n      currentPointer = currentPointer + (ulong)boolVar * -2 + 1;\n    }\n    *(ulong *)(array + 0x1b0) = oldSize;\n  }\n  lastElement = (long *)(newSize * 0x18 + *(long *)(array + 0x1a8));\n  if (*lastElement == 0) {\n    currentSize = *(long *)(array + 0x68);\n    *lastElement = currentSize;\n    *(long *)(array + 0x68) = currentSize + 1;\n    lastElement[1] = element;\n    *(int *)(lastElement + 2) = flag;\n  }\n  if (flag == 0) {\n    *(undefined4 *)(lastElement + 2) = 0;\n    *(undefined4 *)((long)lastElement + 0x14) = *dataPointer;\n  }\n  else {\n    *dataPointer = *(undefined4 *)((long)lastElement + 0x14);\n  }\n  returnValue._8_8_ = extraArg;\n  returnValue._0_8_ = *lastElement;\n  return returnValue;\n}\n\n",
            "called": [
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109c2e",
            "calling": [
                "FUN_00109d5c",
                "FUN_0010a69a"
            ],
            "imported": false,
            "current_name": "resize_array_00109c2e"
        },
        "FUN_001053b5": {
            "renaming": {
                "FUN_001053b5": "print_error_message_001053b5",
                "uVar1": "errorMessage",
                "dcgettext": "getLocalizedMessage"
            },
            "code": "\nvoid printErrorMessage_001053b5(void)\n\n{\n  undefined8 errorMessage;\n  \n  errorMessage = dcgettext(0,\"bad format for %s\",5);\n                    \n  print_error_and_exit_00119dd0(errorMessage);\n}\n\n",
            "called": [
                "FUN_00119dd0",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001053b5",
            "calling": [
                "FUN_00114c80"
            ],
            "imported": false,
            "current_name": "print_error_message_001053b5"
        },
        "FUN_00112996": {
            "renaming": {
                "FUN_00112996": "initialize_data_structure_00112996",
                "param_1": "structure_ptr",
                "uVar1": "result",
                "lVar2": "offset",
                "_stderr": "error_stream"
            },
            "code": "\n\n\nundefined8 initialize_data_structure_00112996(long structure_ptr,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 result;\n  long offset;\n  \n  if ((*(long *)(structure_ptr + 8) != 0) && (*(long *)(structure_ptr + 0x10) != 0)) {\n    offset = *(long *)(structure_ptr + 0x10) + 0x10;\n    if (*(long *)(structure_ptr + 0x20) != 0) {\n      offset = *(long *)(structure_ptr + 0x20) + 0x28;\n    }\n    result = initialize_data_structure_00112996_00112925(offset,param_2,param_3,3);\n    return result;\n  }\n  result = dcgettext(0,\"debug_add_to_current_namespace: no current file\",5);\n  fprintf(error_stream,\"%s\\n\",result);\n  return 0;\n}\n\n",
            "called": [
                "FUN_00112925",
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112996",
            "calling": [
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "initialize_data_structure_00112996"
        },
        "FUN_0010c7a0": {
            "renaming": {
                "FUN_0010c7a0": "set_class_id_0010c7a0",
                "param_1": "classID",
                "param_2": "className",
                "param_3": "type",
                "param_4": "param4",
                "uVar1": "result",
                "uVar2": "newIndex",
                "lVar3": "typeDetail",
                "piVar4": "tempPtr",
                "__s1": "storedClassName",
                "cVar5": "isEquivalent",
                "iVar6": "counter",
                "puVar7": "currentPtr",
                "auVar8": "returnValue"
            },
            "code": "\nundefined  [16] setClassID_0010c7a0(long classID,char *className,int *type,undefined8 param4)\n\n{\n  undefined8 result;\n  uint newIndex;\n  long typeDetail;\n  int *tempPtr;\n  char *storedClassName;\n  char isEquivalent;\n  int counter;\n  undefined8 *currentPtr;\n  undefined returnValue [16];\n  \n  if (3 < *type - 7U) {\n                    \n    __assert_fail(\"type->kind == DEBUG_KIND_STRUCT || type->kind == DEBUG_KIND_UNION || type->kind == DEBUG_KIND_CLASS || type->kind == DEBUG_KIND_UNION_CLASS\"\n                  ,\"../../binutils/debug.c\",0xb87,\"debug_set_class_id\");\n  }\n  typeDetail = *(long *)(type + 4);\n  currentPtr = (undefined8 *)(ulong)*(uint *)(typeDetail + 0xc);\n  if (*(uint *)(typeDetail + 0xc) <= *(uint *)(classID + 0x38)) {\n    for (currentPtr = *(undefined8 **)(classID + 0x50); currentPtr != (undefined8 *)0x0;\n        currentPtr = (undefined8 *)*currentPtr) {\n      tempPtr = (int *)currentPtr[1];\n      if (*tempPtr == *type) {\n        storedClassName = (char *)currentPtr[2];\n        if (className == (char *)0x0) {\n          if (storedClassName == (char *)0x0) {\nLAB_0010c82c:\n            isEquivalent = check_equivalence_recursive_0010922b(classID,tempPtr,type);\n            if (isEquivalent != '\\0') {\n              newIndex = *(uint *)(*(long *)(currentPtr[1] + 0x10) + 0xc);\n              currentPtr = (undefined8 *)(ulong)newIndex;\n              *(uint *)(typeDetail + 0xc) = newIndex;\n              goto LAB_0010c884;\n            }\n          }\n        }\n        else if (((storedClassName != (char *)0x0) && (*storedClassName == *className)) &&\n                (counter = strcmp(storedClassName,className), counter == 0)) goto LAB_0010c82c;\n      }\n    }\n    counter = *(int *)(classID + 0x34) + 1;\n    *(int *)(classID + 0x34) = counter;\n    *(int *)(typeDetail + 0xc) = counter;\n    currentPtr = (undefined8 *)xmalloc(0x18);\n    result = *(undefined8 *)(classID + 0x50);\n    currentPtr[2] = className;\n    *(undefined8 **)(classID + 0x50) = currentPtr;\n    *currentPtr = result;\n    currentPtr[1] = type;\n  }\nLAB_0010c884:\n  returnValue._1_7_ = (undefined7)((ulong)currentPtr >> 8);\n  returnValue[0] = 1;\n  returnValue._8_8_ = param4;\n  return returnValue;\n}\n\n",
            "called": [
                "strcmp",
                "FUN_0010922b",
                "xmalloc",
                "__assert_fail"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c7a0",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "set_class_id_0010c7a0"
        },
        "htab_create_alloc": {
            "renaming": {},
            "code": "\nvoid htab_create_alloc(void)\n\n{\n  htab_create_alloc();\n  return;\n}\n\n",
            "called": [
                "htab_create_alloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104720",
            "calling": [
                "FUN_00116b90",
                "FUN_00113f20"
            ],
            "imported": false,
            "current_name": "htab_create_alloc"
        },
        "FUN_0010922b": {
            "renaming": {
                "FUN_0010922b": "check_equivalence_recursive_0010922b",
                "param_1": "function_context",
                "param_2": "pointer_1",
                "param_3": "pointer_2",
                "uVar1": "value_1",
                "uVar2": "value_2",
                "pplVar3": "pointer_pointer_1",
                "ppcVar4": "pointer_pointer_char_1",
                "ppcVar5": "pointer_pointer_char_2",
                "lVar6": "local_variable_1",
                "lVar7": "local_variable_2",
                "lVar8": "local_variable_3",
                "pcVar9": "pointer_char_1",
                "pcVar10": "pointer_char_2",
                "cVar11": "comparison_result",
                "bVar12": "is_equal",
                "iVar13": "comparison_result_2",
                "uVar14": "result_1",
                "uVar15": "result_2",
                "puVar16": "pointer_1_8",
                "puVar17": "pointer_2_8",
                "plVar18": "pointer_long_1",
                "lVar19": "local_variable_4",
                "plVar20": "pointer_long_2",
                "plVar21": "pointer_long_3",
                "lVar22": "loop_variable_1",
                "local_70": "pointer_long_4",
                "local_58": "pointer_8",
                "plStack_50": "pointer_long_5",
                "local_48": "pointer_long_6"
            },
            "code": "\nbyte check_equivalence_recursive_0010922b(long function_context,long *pointer_1,long *pointer_2)\n\n{\n  uint value_1;\n  uint value_2;\n  long **pointer_pointer_1;\n  char **pointer_pointer_char_1;\n  char **pointer_pointer_char_2;\n  long local_variable_1;\n  long local_variable_2;\n  long local_variable_3;\n  char *pointer_char_1;\n  char *pointer_char_2;\n  char comparison_result;\n  byte is_equal;\n  int comparison_result_2;\n  undefined8 result_1;\n  undefined8 result_2;\n  undefined8 *pointer_1_8;\n  undefined8 *pointer_2_8;\n  long *pointer_long_1;\n  long local_variable_4;\n  long *pointer_long_2;\n  long *pointer_long_3;\n  long loop_variable_1;\n  long *pointer_long_4;\n  undefined8 *pointer_8;\n  long *pointer_long_5;\n  long *pointer_long_6;\n  \n  pointer_long_1 = pointer_2;\n  if (pointer_1 == (long *)0x0) {\nLAB_00109241:\n    return pointer_2 == (long *)0x0;\n  }\njoined_r0x00109255:\n  if (pointer_long_1 == (long *)0x0) {\n    return false;\n  }\n  while( true ) {\n    value_1 = *(uint *)pointer_1;\n    if (value_1 == 1) goto code_r0x00109263;\n    while (value_2 = *(uint *)pointer_2, value_2 == 1) {\n      pointer_2 = **(long ***)pointer_2[2];\n      if (pointer_2 == (long *)0x0) {\n        return false;\n      }\n    }\n    if (pointer_1 == pointer_2) {\n      return true;\n    }\n    if (value_1 != 0x16) break;\n    if (value_2 != 0x17) goto LAB_001092cb;\n    pointer_1 = *(long **)(pointer_1[2] + 8);\n    if (pointer_1 == (long *)0x0) goto LAB_00109241;\n  }\n  if ((value_1 == 0x17) && (value_2 == 0x16)) {\n    pointer_2 = *(long **)(pointer_2[2] + 8);\n    pointer_long_1 = pointer_2;\n    goto joined_r0x00109255;\n  }\nLAB_001092cb:\n  if (*pointer_1 != *pointer_2) {\n    return false;\n  }\n  if (value_1 == 3) {\n    return *(char *)(pointer_1 + 2) == *(char *)(pointer_2 + 2);\n  }\n  if (value_1 < 4) {\n    if (value_1 == 2) {\n      return true;\n    }\n  }\n  else if (value_1 - 4 < 3) {\n    return true;\n  }\n  pointer_8 = *(undefined8 **)(function_context + 0x58);\n  for (pointer_2_8 = pointer_8; pointer_2_8 != (undefined8 *)0x0; pointer_2_8 = (undefined8 *)*pointer_2_8) {\n    if (((long *)pointer_2_8[1] == pointer_1) && ((long *)pointer_2_8[2] == pointer_2)) {\n      return true;\n    }\n  }\n  *(undefined8 ***)(function_context + 0x58) = &pointer_8;\n  pointer_long_5 = pointer_1;\n  pointer_long_6 = pointer_2;\n  switch(value_1) {\n  case 7:\n  case 8:\n  case 9:\n  case 10:\n    pointer_long_1 = (long *)pointer_1[2];\n    pointer_pointer_1 = (long **)pointer_2[2];\n    if (pointer_long_1 == (long *)0x0) {\n      is_equal = pointer_pointer_1 == (long **)0x0;\n      goto LAB_001099c4;\n    }\n    if (pointer_pointer_1 == (long **)0x0) goto LAB_00109382;\n    if ((*(uint *)(function_context + 0x38) < *(uint *)((long)pointer_long_1 + 0xc)) &&\n       (*(uint *)((long)pointer_long_1 + 0xc) == *(uint *)((long)pointer_pointer_1 + 0xc))) goto LAB_001097af;\n    pointer_2_8 = (undefined8 *)*pointer_long_1;\n    pointer_long_4 = *pointer_pointer_1;\n    if (((pointer_2_8 == (undefined8 *)0x0) == (pointer_long_4 == (long *)0x0)) &&\n       ((((pointer_long_1[2] == 0) == (pointer_pointer_1[2] == (long *)0x0) &&\n         ((pointer_long_1[3] == 0) == (pointer_pointer_1[3] == (long *)0x0))) &&\n        ((pointer_long_1[4] == 0) == (pointer_pointer_1[4] == (long *)0x0))))) {\n      if (pointer_2_8 == (undefined8 *)0x0) {\nLAB_001093fd:\n        if ((pointer_long_1[4] != 0) &&\n           (comparison_result = check_equivalence_recursive_0010922b(function_context,pointer_long_1[4],pointer_pointer_1[4]), comparison_result == '\\0'))\n        goto LAB_00109382;\n        pointer_long_3 = (long *)pointer_long_1[2];\n        if (pointer_long_3 == (long *)0x0) {\nLAB_00109540:\n          pointer_2_8 = (undefined8 *)pointer_long_1[3];\n          if (pointer_2_8 == (undefined8 *)0x0) goto LAB_001097af;\n          pointer_long_1 = pointer_pointer_1[3];\n          while( true ) {\n            pointer_pointer_char_2 = (char **)*pointer_2_8;\n            if (pointer_pointer_char_2 == (char **)0x0) {\n              is_equal = *pointer_long_1 == 0;\n              goto LAB_001099c4;\n            }\n            pointer_pointer_char_1 = (char **)*pointer_long_1;\n            if (pointer_pointer_char_1 == (char **)0x0) break;\n            if ((**pointer_pointer_char_2 != **pointer_pointer_char_1) || (comparison_result_2 = strcmp(*pointer_pointer_char_2,*pointer_pointer_char_1), comparison_result_2 != 0))\n            break;\n            pointer_char_1 = pointer_pointer_char_2[1];\n            pointer_char_2 = pointer_pointer_char_1[1];\n            if ((pointer_char_1 == (char *)0x0) != (pointer_char_2 == (char *)0x0)) break;\n            if (pointer_char_1 != (char *)0x0) {\n              loop_variable_1 = 0;\n              while( true ) {\n                pointer_pointer_char_2 = *(char ***)(pointer_char_1 + loop_variable_1);\n                pointer_pointer_char_1 = *(char ***)(pointer_char_2 + loop_variable_1);\n                if (pointer_pointer_char_2 == (char **)0x0) break;\n                if (pointer_pointer_char_1 == (char **)0x0) goto LAB_00109382;\n                if ((((**pointer_pointer_char_2 != **pointer_pointer_char_1) ||\n                     ((((ulong)pointer_pointer_char_2[2] ^ (ulong)pointer_pointer_char_1[2]) & 0xffffffffffff) != 0)) ||\n                    ((pointer_pointer_char_2[3] != pointer_pointer_char_1[3] ||\n                     ((((pointer_pointer_char_2[4] == (char *)0x0) != (pointer_pointer_char_1[4] == (char *)0x0) ||\n                       (comparison_result_2 = strcmp(*pointer_pointer_char_2,*pointer_pointer_char_1), comparison_result_2 != 0)) ||\n                      (comparison_result = check_equivalence_recursive_0010922b(function_context,pointer_pointer_char_2[1],pointer_pointer_char_1[1]), comparison_result == '\\0')))))) ||\n                   ((pointer_pointer_char_2[4] != (char *)0x0 &&\n                    (comparison_result = check_equivalence_recursive_0010922b(function_context,pointer_pointer_char_2[4],pointer_pointer_char_1[4]), comparison_result == '\\0'))))\n                goto LAB_00109382;\n                loop_variable_1 = loop_variable_1 + 8;\n              }\n              if (pointer_pointer_char_1 == (char **)0x0) goto LAB_001095f1;\n              break;\n            }\nLAB_001095f1:\n            pointer_2_8 = pointer_2_8 + 1;\n            pointer_long_1 = pointer_long_1 + 1;\n          }\n        }\n        else {\n          pointer_long_2 = pointer_pointer_1[2];\n          for (; pointer_2_8 = (undefined8 *)*pointer_long_3, pointer_2_8 != (undefined8 *)0x0;\n              pointer_long_3 = pointer_long_3 + 1) {\n            pointer_1_8 = (undefined8 *)*pointer_long_2;\n            if ((((pointer_1_8 == (undefined8 *)0x0) ||\n                 (((pointer_2_8[1] ^ pointer_1_8[1]) & 0xffffffffff) != 0)) ||\n                (*(int *)(pointer_2_8 + 2) != *(int *)(pointer_1_8 + 2))) ||\n               (comparison_result = check_equivalence_recursive_0010922b(function_context,*pointer_2_8,*pointer_1_8), comparison_result == '\\0'))\n            goto LAB_00109382;\n            pointer_long_2 = pointer_long_2 + 1;\n          }\n          if (*pointer_long_2 == 0) goto LAB_00109540;\n        }\n      }\n      else {\n        for (; pointer_pointer_char_2 = (char **)*pointer_2_8, pointer_pointer_char_2 != (char **)0x0; pointer_2_8 = pointer_2_8 + 1) {\n          pointer_pointer_char_1 = (char **)*pointer_long_4;\n          if (pointer_pointer_char_1 == (char **)0x0) goto LAB_00109382;\n          pointer_char_1 = *pointer_pointer_char_1;\n          pointer_char_2 = *pointer_pointer_char_2;\n          if ((*pointer_char_2 != *pointer_char_1) ||\n             ((((ulong)pointer_pointer_char_2[2] ^ (ulong)pointer_pointer_char_1[2]) & 0xffffffffff) != 0)) goto LAB_00109382;\n          if (*(char *)((long)pointer_pointer_char_2 + 0x14) == '\\0') {\n            if (pointer_pointer_char_2[3] == pointer_pointer_char_1[3]) goto LAB_00109480;\n            goto LAB_00109382;\n          }\n          comparison_result_2 = strcmp(pointer_pointer_char_2[3],pointer_pointer_char_1[3]);\n          if (comparison_result_2 != 0) goto LAB_00109382;\nLAB_00109480:\n          comparison_result_2 = strcmp(pointer_char_2,pointer_char_1);\n          if (((comparison_result_2 != 0) || (pointer_pointer_char_2[1] == (char *)0x0)) || (pointer_pointer_char_1[1] == (char *)0x0))\n          goto LAB_00109382;\n          result_1 = check_debug_information_00112b6e(pointer_pointer_char_1[1],0);\n          result_2 = check_debug_information_00112b6e(pointer_pointer_char_2[1],0);\n          comparison_result = check_equivalence_recursive_0010922b(function_context,result_2,result_1);\n          if (comparison_result == '\\0') goto LAB_00109382;\n          pointer_long_4 = pointer_long_4 + 1;\n        }\n        if (*pointer_long_4 == 0) goto LAB_001093fd;\n      }\n    }\n    goto LAB_00109382;\n  case 0xb:\n    pointer_long_1 = (long *)pointer_1[2];\n    pointer_long_3 = (long *)pointer_2[2];\n    if (pointer_long_1 == (long *)0x0) {\n      is_equal = pointer_long_3 == (long *)0x0;\n      goto LAB_001099c4;\n    }\n    if (pointer_long_3 == (long *)0x0) goto LAB_00109382;\n    loop_variable_1 = *pointer_long_1;\n    local_variable_1 = *pointer_long_3;\n    local_variable_4 = 0;\n    local_variable_2 = pointer_long_1[1];\n    local_variable_3 = pointer_long_3[1];\n    do {\n      pointer_char_1 = *(char **)(loop_variable_1 + local_variable_4);\n      if (pointer_char_1 == (char *)0x0) {\n        is_equal = *(long *)(local_variable_1 + local_variable_4) == 0;\n        goto LAB_001099c1;\n      }\n      pointer_char_2 = *(char **)(local_variable_1 + local_variable_4);\n      if (((pointer_char_2 == (char *)0x0) || (*pointer_char_1 != *pointer_char_2)) ||\n         (*(long *)(local_variable_2 + local_variable_4) != *(long *)(local_variable_3 + local_variable_4))) break;\n      comparison_result_2 = strcmp(pointer_char_1,pointer_char_2);\n      local_variable_4 = local_variable_4 + 8;\n    } while (comparison_result_2 == 0);\nLAB_00109964:\n    is_equal = 0;\n    break;\n  case 0xc:\n  case 0xe:\n  case 0x14:\n  case 0x15:\n    is_equal = check_equivalence_recursive_0010922b(function_context,pointer_1[2],pointer_2[2]);\n    goto LAB_001099c4;\n  case 0xd:\n    if ((*(char *)((undefined8 *)pointer_1[2] + 2) == *(char *)((undefined8 *)pointer_2[2] + 2)) &&\n       (comparison_result = check_equivalence_recursive_0010922b(function_context,*(undefined8 *)pointer_1[2],*(undefined8 *)pointer_2[2]),\n       comparison_result != '\\0')) {\n      pointer_long_1 = *(long **)(pointer_1[2] + 8);\n      pointer_long_3 = *(long **)(pointer_2[2] + 8);\n      if ((pointer_long_1 == (long *)0x0) == (pointer_long_3 == (long *)0x0)) {\n        if (pointer_long_1 == (long *)0x0) goto LAB_001097af;\n        while (((*pointer_long_1 != 0 && (*pointer_long_3 != 0)) &&\n               (comparison_result = check_equivalence_recursive_0010922b(function_context), comparison_result != '\\0'))) {\n          pointer_long_1 = pointer_long_1 + 1;\n          pointer_long_3 = pointer_long_3 + 1;\n        }\nLAB_0010995d:\n        if (*pointer_long_1 != 0) goto LAB_00109964;\n        is_equal = *pointer_long_3 == 0;\n        break;\n      }\n    }\n    goto LAB_00109382;\n  case 0xf:\n    pointer_2_8 = (undefined8 *)pointer_2[2];\n    pointer_1_8 = (undefined8 *)pointer_1[2];\n    is_equal = 0;\n    if ((pointer_1_8[1] == pointer_2_8[1]) && (pointer_1_8[2] == pointer_2_8[2])) {\nLAB_00109862:\n      is_equal = check_equivalence_recursive_0010922b(function_context,*pointer_1_8,*pointer_2_8);\n    }\n    break;\n  case 0x10:\n    pointer_2_8 = (undefined8 *)pointer_2[2];\n    pointer_1_8 = (undefined8 *)pointer_1[2];\n    is_equal = 0;\n    if (((pointer_1_8[2] == pointer_2_8[2]) && (pointer_1_8[3] == pointer_2_8[3])) &&\n       (*(char *)(pointer_1_8 + 4) == *(char *)(pointer_2_8 + 4))) goto LAB_00109862;\n    break;\n  case 0x11:\n    pointer_2_8 = (undefined8 *)pointer_2[2];\n    pointer_1_8 = (undefined8 *)pointer_1[2];\n    is_equal = 0;\n    if (*(char *)(pointer_1_8 + 1) == *(char *)(pointer_2_8 + 1)) goto LAB_00109862;\n    break;\n  case 0x12:\n    comparison_result = check_equivalence_recursive_0010922b(function_context,*(undefined8 *)pointer_1[2],*(undefined8 *)pointer_2[2]);\n    is_equal = 0;\n    if (comparison_result != '\\0') {\n      is_equal = check_equivalence_recursive_0010922b(function_context,*(undefined8 *)(pointer_1[2] + 8),*(undefined8 *)(pointer_2[2] + 8))\n      ;\n    }\n    break;\n  case 0x13:\n    if (((*(char *)((undefined8 *)pointer_1[2] + 3) == *(char *)((undefined8 *)pointer_2[2] + 3)) &&\n        (comparison_result = check_equivalence_recursive_0010922b(function_context,*(undefined8 *)pointer_1[2],*(undefined8 *)pointer_2[2]),\n        comparison_result != '\\0')) &&\n       (comparison_result = check_equivalence_recursive_0010922b(function_context,*(undefined8 *)(pointer_1[2] + 8),\n                              *(undefined8 *)(pointer_2[2] + 8)), comparison_result != '\\0')) {\n      pointer_long_1 = *(long **)(pointer_1[2] + 0x10);\n      pointer_long_3 = *(long **)(pointer_2[2] + 0x10);\n      if ((pointer_long_1 == (long *)0x0) == (pointer_long_3 == (long *)0x0)) {\n        if (pointer_long_1 != (long *)0x0) {\n          while (((*pointer_long_1 != 0 && (*pointer_long_3 != 0)) &&\n                 (comparison_result = check_equivalence_recursive_0010922b(function_context), comparison_result != '\\0'))) {\n            pointer_long_1 = pointer_long_1 + 1;\n            pointer_long_3 = pointer_long_3 + 1;\n          }\n          goto LAB_0010995d;\n        }\nLAB_001097af:\n        is_equal = 1;\n        goto LAB_001099c4;\n      }\n    }\nLAB_00109382:\n    is_equal = 0;\n    goto LAB_001099c4;\n  case 0x16:\n  case 0x17:\n    pointer_long_1 = (long *)pointer_2[2];\n    pointer_long_3 = (long *)pointer_1[2];\n    comparison_result_2 = strcmp(*(char **)(*pointer_long_3 + 8),*(char **)(*pointer_long_1 + 8));\n    is_equal = 0;\n    if (comparison_result_2 == 0) {\n      is_equal = check_equivalence_recursive_0010922b(function_context,pointer_long_3[1],pointer_long_1[1]);\n    }\n    break;\n  default:\n                    \n    abort();\n  }\nLAB_001099c1:\n  is_equal = is_equal & 1;\nLAB_001099c4:\n  *(undefined8 **)(function_context + 0x58) = pointer_8;\n  return is_equal;\ncode_r0x00109263:\n  pointer_1 = **(long ***)pointer_1[2];\n  pointer_long_1 = pointer_1;\n  goto joined_r0x00109255;\n}\n\n",
            "called": [
                "strcmp",
                "abort",
                "FUN_0010922b",
                "FUN_00112b6e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010922b",
            "calling": [
                "FUN_0010c7a0",
                "FUN_0010922b"
            ],
            "imported": false,
            "current_name": "check_equivalence_recursive_0010922b"
        },
        "mkstemp": {
            "renaming": {},
            "code": "\n\n\nint mkstemp(char *__template)\n\n{\n  int iVar1;\n  \n  iVar1 = mkstemp(__template);\n  return iVar1;\n}\n\n",
            "called": [
                "mkstemp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104640",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "mkstemp"
        },
        "ftell": {
            "renaming": {},
            "code": "\n\n\nlong ftell(FILE *__stream)\n\n{\n  long lVar1;\n  \n  lVar1 = ftell(__stream);\n  return lVar1;\n}\n\n",
            "called": [
                "ftell"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001044c0",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "ftell"
        },
        "FUN_001052a2": {
            "renaming": {
                "FUN_001052a2": "copy_archive_001052a2",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "cVar1": "check",
                "iVar2": "index",
                "iVar3": "result",
                "ppcVar4": "pointerArray",
                "lVar5": "length",
                "uVar6": "temp",
                "__format": "messageFormat",
                "puVar7": "pointerVar",
                "piVar8": "errorVar",
                "uVar9": "textVar",
                "in_RAX": "value",
                "pcVar10": "currentChar",
                "ppcVar11": "pointerArray2",
                "lVar12": "size",
                "pvVar13": "pointerVar2",
                "pcVar14": "closeFunction",
                "lVar15": "tempSize",
                "pcVar16": "currentChar2",
                "psVar17": "statVar",
                "unaff_R14": "unaffPointer",
                "unaff_R15": "unaffPointer2",
                "bVar18": "byteVar",
                "unaff_retaddr": "returnAddress",
                "in_stack_00000008": "stackVar1",
                "in_stack_00000010": "stackVar2",
                "in_stack_00000018": "stackVar3",
                "in_stack_00000020": "stackPointer",
                "in_stack_00000028": "stackVar4",
                "in_stack_00000030": "stackVar5",
                "in_stack_000000f8": "stackVar6",
                "in_stack_00000110": "stackVar7"
            },
            "code": "\nvoid copyArchive_001052a2(undefined8 param1,undefined8 param2,char *param3)\n\n{\n  char check;\n  int index;\n  int result;\n  char **pointerArray;\n  long length;\n  undefined8 temp;\n  char *messageFormat;\n  undefined8 *pointerVar;\n  int *errorVar;\n  undefined8 textVar;\n  long value;\n  char *currentChar;\n  char **pointerArray2;\n  long size;\n  void *pointerVar2;\n  code *closeFunction;\n  long tempSize;\n  char *currentChar2;\n  stat *statVar;\n  undefined8 *unaffPointer;\n  char **unaffPointer2;\n  byte byteVar;\n  undefined8 returnAddress;\n  undefined8 *stackVar1;\n  long *stackVar2;\n  char *stackVar3;\n  undefined8 *stackPointer;\n  undefined8 stackVar4;\n  undefined8 stackVar5;\n  uint stackVar6;\n  long stackVar7;\n  \n  byteVar = 0;\n  currentChar = (char *)(value + 1);\n  do {\n    if (*currentChar == '/') {\n      copyArchive_001052a2();\n      return;\n    }\n    while (*currentChar == '\\0') {\n      currentChar = (char *)concat(stackVar3,&DAT_0011b47d);\n      result = stat(currentChar,(stat *)&stack0x00000050);\n      pointerVar = unaffPointer;\n      if (-1 < result) {\n        size = create_temp_directory_0011a0e0(currentChar);\n        free(currentChar);\n        if (size == 0) {\n          errorVar = __errno_location();\n          currentChar = strerror(*errorVar);\n          textVar = dcgettext(0,\"cannot create tempdir for archive copying (error: %s)\",5);\n          print_error_message_00119ed0(textVar,currentChar);\n          goto LAB_00104e93;\n        }\n        pointerVar = (undefined8 *)xmalloc(0x18);\n        currentChar = *unaffPointer2;\n        *pointerVar = unaffPointer;\n        pointerVar[2] = 0;\n        pointerVar[1] = size;\n        currentChar = (char *)concat(size,&DAT_0011b47d,currentChar);\n      }\n      result = 0;\n      if (DAT_001279cb != '\\0') {\n        statVar = (stat *)&stack0x00000050;\n        for (size = 0x24; size != 0; size = size + -1) {\n          *(undefined4 *)&statVar->st_dev = 0;\n          statVar = (stat *)((long)statVar + (ulong)byteVar * -8 + 4);\n        }\n        pointerArray2 = (char **)unaffPointer2[0x1d];\n        if ((char **)unaffPointer2[0x1d] == (char **)0x0) {\n          pointerArray2 = unaffPointer2;\n        }\n        result = (**(code **)(pointerArray2[1] + 0x1e8))(unaffPointer2,(stat *)&stack0x00000050);\n        if (result != 0) {\n          currentChar2 = *unaffPointer2;\n          textVar = dcgettext(0,\"internal stat error on %s\",5);\n          print_error_message_00119ed0(textVar,currentChar2);\n        }\n      }\n      unaffPointer = (undefined8 *)xmalloc(0x18);\n      unaffPointer[1] = currentChar;\n      *unaffPointer = pointerVar;\n      unaffPointer[2] = 0;\n      check = bfd_check_format(unaffPointer2,1);\n      if (check == '\\0') {\n        textVar = dcgettext(0,\"Unable to recognise the format of file\",5);\n        display_error_001126c0(0,unaffPointer2,0,textVar);\n        pointerArray2 = (char **)bfd_openw(currentChar,stackVar4);\n        if (pointerArray2 == (char **)0x0) goto LAB_00104e80;\nLAB_00104d75:\n        pointerArray = (char **)unaffPointer2[0x1d];\n        if ((char **)unaffPointer2[0x1d] == (char **)0x0) {\n          pointerArray = unaffPointer2;\n        }\n        index = (**(code **)(pointerArray[1] + 0x1e8))(unaffPointer2,&stack0x000000e0);\n        size = stackVar7;\n        if (index == 0) {\n          if (stackVar7 < 0) {\n            textVar = get_formatted_string_001125fa(unaffPointer2);\n            temp = dcgettext(0,\"stat returns negative size for `%s\\'\",5);\n            print_error_message_00119ed0(temp,textVar);\n          }\n          else {\n            index = bfd_seek(unaffPointer2,0,0);\n            if (index == 0) {\n              if (DAT_001279c9 != '\\0') {\n                currentChar2 = *pointerArray2;\n                textVar = get_formatted_string_001125fa(unaffPointer2);\n                messageFormat = (char *)dcgettext(0,\"copy from `%s\\' [unknown] to `%s\\' [unknown]\\n\",5);\n                printf(messageFormat,textVar,currentChar2);\n              }\n              pointerVar2 = (void *)xmalloc(0x2000);\n              for (; size != 0; size = size - tempSize) {\n                tempSize = 0x2000;\n                if (size < 0x2001) {\n                  tempSize = size;\n                }\n                length = bfd_bread(pointerVar2,tempSize,unaffPointer2);\n                pointerArray = unaffPointer2;\n                if ((tempSize != length) ||\n                   (length = bfd_bwrite(pointerVar2,tempSize,pointerArray2), pointerArray = pointerArray2, tempSize != length\n                   )) {\n                  display_error_001126c0(0,pointerArray,0,0);\n                  free(pointerVar2);\n                  goto LAB_00104f00;\n                }\n              }\n              chmod(*pointerArray2,stackVar6 | 0x100);\n              free(pointerVar2);\n              check = bfd_close_all_done(pointerArray2);\n              if (check == '\\0') {\n                display_error_001126c0(currentChar,0,0,0);\n                DAT_00127a20 = 1;\n              }\n              goto LAB_00114a86;\n            }\n            textVar = get_formatted_string_001125fa(unaffPointer2);\n            print_error_message_0011a110(textVar);\n          }\n        }\n        else {\n          display_error_001126c0(0,unaffPointer2,0,0);\n        }\nLAB_00104f00:\n        check = bfd_close_all_done(pointerArray2);\n        if (check == '\\0') {\n          display_error_001126c0(currentChar,0,0,0);\n        }\nLAB_00104ec9:\n        unlink(currentChar);\n        DAT_00127a20 = 1;\n      }\n      else {\n        if (stackVar5._7_1_ == '\\0') {\n          pointerArray2 = (char **)bfd_openw(currentChar,*(undefined8 *)unaffPointer2[1]);\n        }\n        else {\n          pointerArray2 = (char **)bfd_openw(currentChar,stackVar4);\n        }\n        if (pointerArray2 == (char **)0x0) {\nLAB_00104e80:\n          display_error_001126c0(currentChar,0,0,0);\n          goto LAB_00104e93;\n        }\n        check = FUNC_00114e50(unaffPointer2,pointerArray2,returnAddress);\n        if (check == '\\0') {\n          index = bfd_get_arch(unaffPointer2);\n          if (index == 0) goto LAB_00104d75;\n          check = bfd_close_all_done(pointerArray2);\n          if (check == '\\0') {\n            display_error_001126c0(currentChar,0,0,0);\n          }\n          goto LAB_00104ec9;\n        }\n        check = bfd_close(pointerArray2);\n        if (check == '\\0') {\n          display_error_001126c0(currentChar,0,0,0);\n          DAT_00127a20 = 1;\n        }\nLAB_00114a86:\n        if ((DAT_001279cb != '\\0') && (result == 0)) {\n          set_file_time_0011a350(currentChar,(stat *)&stack0x00000050);\n        }\n        size = bfd_openr(currentChar,stackVar4);\n        unaffPointer[2] = size;\n        *stackVar2 = size;\n        stackVar2 = (long *)(size + 0xf0);\n        pointerArray2 = (char **)bfd_openr_next_archived_file(stackPointer,unaffPointer2);\n        bfd_close(unaffPointer2);\n        unaffPointer2 = pointerArray2;\n      }\n      if ((DAT_00127a20 != 0) || (unaffPointer2 == (char **)0x0)) {\n        *stackVar2 = 0;\n        pointerVar2 = (void *)xstrdup(*stackVar1);\n        if (DAT_00127a20 == 0) {\n          closeFunction = bfd_close;\n        }\n        else {\n          closeFunction = bfd_close_all_done;\n        }\n        check = (*closeFunction)(stackVar1);\n        if (check == '\\0') {\n          DAT_00127a20 = 1;\n          display_error_001126c0(pointerVar2,0,0,0);\n        }\n        free(pointerVar2);\n        pointerVar2 = (void *)xstrdup(*stackPointer);\n        check = bfd_close(stackPointer);\n        if (check == '\\0') {\n          DAT_00127a20 = 1;\n          display_error_001126c0(pointerVar2,0,0,0);\n        }\n        free(pointerVar2);\n        goto LAB_00114b4b;\n      }\n      currentChar = *unaffPointer2;\n      param3 = currentChar;\n      if (*currentChar == '/') goto LAB_0010527d;\n    }\n    currentChar2 = currentChar;\n    if ((*currentChar == '.') && (currentChar2 = currentChar + 1, currentChar[1] == '.')) {\n      currentChar2 = currentChar + 2;\n      if ((currentChar[2] == '\\0') || (currentChar[2] == '/')) {\nLAB_0010527d:\n        textVar = dcgettext(0,\"illegal pathname found in archive member: %s\",5);\n        print_error_message_00119ed0(textVar,param3);\nLAB_00104e93:\n        DAT_00127a20 = 1;\nLAB_00114b4b:\n        while (unaffPointer != (undefined8 *)0x0) {\n          if (unaffPointer[2] == 0) {\n            rmdir((char *)unaffPointer[1]);\n          }\n          else {\n            bfd_close();\n            unlink((char *)unaffPointer[1]);\n          }\n          free((void *)unaffPointer[1]);\n          pointerVar = (undefined8 *)*unaffPointer;\n          free(unaffPointer);\n          unaffPointer = pointerVar;\n        }\n        rmdir(stackVar3);\n        free(stackVar3);\n        return;\n      }\n    }\n    for (; (currentChar = currentChar2, *currentChar2 != '\\0' && (*currentChar2 != '/')); currentChar2 = currentChar2 + 1) {\n    }\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001052a2",
            "calling": [
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "copy_archive_001052a2"
        },
        "FUN_0010e453": {
            "renaming": {
                "FUN_0010e453": "allocate_and_initialize_data_0010e453",
                "param_1": "data_offset",
                "param_2": "string",
                "param_3": "string_array",
                "lVar1": "pointer",
                "cVar2": "result",
                "sVar3": "string_length",
                "__s": "formatted_string",
                "uVar4": "success",
                "lVar5": "total_length",
                "ppcVar6": "current_string",
                "lVar7": "current_offset"
            },
            "code": "\nundefined8 allocate_and_initialize_data_0010e453(long data_offset,char *string,char **string_array)\n\n{\n  long pointer;\n  char result;\n  size_t string_length;\n  undefined2 *formatted_string;\n  undefined8 success;\n  long total_length;\n  char **current_string;\n  long current_offset;\n  \n  if (string_array == (char **)0x0) {\n    if (string != (char *)0x0) {\n      string_length = strlen(string);\n      formatted_string = (undefined2 *)xmalloc(string_length + 10);\n      sprintf((char *)formatted_string,\"xe%s:\",string);\nLAB_0010e578:\n      result = allocate_and_initialize_data_0010e453_00109b52(data_offset,formatted_string,0,0,4);\n      if (result != '\\0') goto LAB_0010e58b;\n    }\nLAB_0010e475:\n    success = 0;\n  }\n  else {\n    total_length = 10;\n    current_string = string_array;\n    if (string != (char *)0x0) {\n      string_length = strlen(string);\n      total_length = string_length + 10;\n    }\n    for (; *current_string != (char *)0x0; current_string = current_string + 1) {\n      string_length = strlen(*current_string);\n      total_length = total_length + 0x14 + string_length;\n    }\n    formatted_string = (undefined2 *)xmalloc(total_length);\n    if (string == (char *)0x0) {\n      *formatted_string = 0x65;\n      total_length = 0;\n    }\n    else {\n      total_length = *(long *)(data_offset + 0x68);\n      *(long *)(data_offset + 0x68) = total_length + 1;\n      sprintf((char *)formatted_string,\"%s:T%ld=e\",string,total_length);\n    }\n    current_offset = 0;\n    while( true ) {\n      pointer = *(long *)((long)string_array + current_offset);\n      string_length = strlen((char *)formatted_string);\n      if (pointer == 0) break;\n      current_offset = current_offset + 8;\n      sprintf((char *)(undefined2 *)((long)formatted_string + string_length),\"%s:%ld,\");\n    }\n    *(undefined2 *)((long)formatted_string + string_length) = 0x3b;\n    if (string == (char *)0x0) goto LAB_0010e578;\n    result = process_string_0010e2f0(data_offset,0x80,0,0,formatted_string);\n    if ((result == '\\0') || (result = initialize_data_00109cf4(data_offset,total_length,4), result == '\\0'))\n    goto LAB_0010e475;\nLAB_0010e58b:\n    free(formatted_string);\n    success = 1;\n  }\n  return success;\n}\n\n",
            "called": [
                "FUN_00109cf4",
                "strlen",
                "free",
                "xmalloc",
                "sprintf",
                "FUN_00109b52",
                "FUN_0010e2f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e453",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_data_0010e453"
        },
        "FUN_00109d5c": {
            "renaming": {
                "FUN_00109d5c": "initialize_and_resize_array_00109d5c",
                "param_1": "input_param",
                "lVar1": "arraySize",
                "uVar2": "result"
            },
            "code": "\nundefined8 initializeAndResizeArray_00109d5c(undefined8 input_param)\n\n{\n  long arraySize;\n  undefined8 result;\n  \n  arraySize = resize_array_00109c2e();\n  if (-1 < arraySize) {\n    result = initialize_data_00109cf4(input_param,arraySize,0);\n    return result;\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00109cf4",
                "FUN_00109c2e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109d5c",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "initialize_and_resize_array_00109d5c"
        },
        "FUN_0010ed2c": {
            "renaming": {
                "FUN_0010ed2c": "update_parameter_0010ed2c",
                "param_1": "data_ptr",
                "param_2": "new_value",
                "param_3": "extra_param",
                "cVar1": "result",
                "iVar2": "count",
                "extraout_RDX": "temp",
                "uVar3": "max_value",
                "in_R10": "auxiliary",
                "auVar4": "result_value"
            },
            "code": "\nundefined  [16] update_parameter_0010ed2c(long data_ptr,ulong new_value,undefined8 extra_param)\n\n{\n  char result;\n  int count;\n  undefined8 temp;\n  ulong max_value;\n  undefined8 auxiliary;\n  undefined result_value [16];\n  \n  if (*(ulong *)(data_ptr + 0x1f0) < new_value) {\n    *(ulong *)(data_ptr + 0x1f0) = new_value;\n  }\n  if (*(long *)(data_ptr + 0x208) == -1) {\nLAB_0010ed78:\n    if (*(int *)(data_ptr + 0x1f8) != 0) {\n      count = *(int *)(data_ptr + 0x1f8) + -1;\n      max_value = CONCAT71((int7)((ulong)extra_param >> 8),1);\n      *(int *)(data_ptr + 0x1f8) = count;\n      if (count != 0) {\n        result_value = process_string_0010e2f0(data_ptr,0xe0,0,new_value - *(long *)(data_ptr + 0x200),0,auxiliary);\n        return result_value;\n      }\n      goto LAB_0010edae;\n    }\n  }\n  else {\n    result = process_string_0010e2f0(data_ptr,0xc0,0,*(long *)(data_ptr + 0x208),0);\n    if (result != '\\0') {\n      *(undefined8 *)(data_ptr + 0x208) = 0xffffffffffffffff;\n      extra_param = temp;\n      goto LAB_0010ed78;\n    }\n  }\n  max_value = 0;\nLAB_0010edae:\n  result_value._0_8_ = max_value & 0xffffffff;\n  result_value._8_8_ = auxiliary;\n  return result_value;\n}\n\n",
            "called": [
                "FUN_0010e2f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010ed2c",
            "calling": [
                "FUN_00113a4d"
            ],
            "imported": false,
            "current_name": "update_parameter_0010ed2c"
        },
        "FUN_0011a1b0": {
            "renaming": {
                "FUN_0011a1b0": "compare_and_select_smaller_0011a1b0",
                "param_1": "array1",
                "param_2": "array2",
                "param_3": "value1",
                "param_4": "value2",
                "uVar1": "size1",
                "uVar2": "size2",
                "iVar3": "comparisonResult",
                "extraout_var": "extraOutVar",
                "uVar4": "combinedResult",
                "auVar5": "result"
            },
            "code": "\nundefined  [16] compareAndSelectSmaller_0011a1b0(ulong *array1,ulong *array2,undefined8 value1,undefined8 value2)\n\n{\n  ulong size1;\n  ulong size2;\n  int comparisonResult;\n  undefined4 extraOutVar;\n  ulong combinedResult;\n  undefined result [16];\n  \n  combinedResult = *array1;\n  if (*array2 <= *array1) {\n    combinedResult = *array2;\n  }\n  comparisonResult = memcmp((void *)(array1[3] + 3),(void *)(array2[3] + 3),combinedResult - 3);\n  combinedResult = CONCAT44(extraOutVar,comparisonResult);\n  if (comparisonResult == 0) {\n    size1 = array1[8];\n    if (size1 < array2[7]) {\n      combinedResult = 0xffffffff;\n    }\n    else {\n      size2 = array2[8];\n      if (size2 < array1[7]) {\n        combinedResult = 1;\n      }\n      else {\n        combinedResult = 0xffffffff;\n        if (array2[7] <= array1[7]) {\n          if (size2 < size1) {\n            combinedResult = 1;\n          }\n          else {\n            combinedResult = 0xffffffff;\n            if (size2 <= size1) {\n              if (array1[2] == 0x100) {\n                combinedResult = (ulong)-(uint)(array2[2] != 0x100);\n              }\n              else {\n                combinedResult = (ulong)(array2[2] == 0x100);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  result._8_8_ = value2;\n  result._0_8_ = combinedResult;\n  return result;\n}\n\n",
            "called": [
                "FUN_001087da",
                "memcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a1b0",
            "calling": [
                "FUN_001086af"
            ],
            "imported": false,
            "current_name": "compare_and_select_smaller_0011a1b0"
        },
        "FUN_001163d0": {
            "renaming": {
                "FUN_001163d0": "parse_gnu_build_attribute_notes_001163d0",
                "param_1": "object_file",
                "param_2": "header",
                "param_3": "section_size",
                "param_4": "result_buffer",
                "uVar1": "size_upper_bound",
                "uVar2": "first_object_file",
                "uVar3": "first_header",
                "uVar7": "error_message",
                "bVar4": "invalid_flag",
                "puVar5": "current_record",
                "iVar6": "memcmp_result",
                "lVar8": "error_message",
                "__ptr": "reloc_buffer",
                "uVar9": "current_record_index",
                "uVar10": "record_length",
                "uVar11": "note_type",
                "uVar12": "record_description_size",
                "uVar13": "aligned_length",
                "uVar14": "previous_record_length",
                "uVar15": "buffer_offset",
                "uVar16": "remaining_section_size",
                "puVar17": "record_pointer",
                "puVar18": "name_ptr",
                "cVar19": "flag_char",
                "puVar20": "name_buffer_ptr",
                "iVar21": "loop_counter",
                "puVar22": "note_body_ptr",
                "puVar23": "record_array_ptr",
                "uVar24": "previous_record_description_size",
                "__nmemb": "array_size",
                "puVar25": "current_record_in_array",
                "bVar26": "boolean_flag",
                "local_88": "version_2_note_offset",
                "uStack_80": "version_3_note_offset",
                "local_70": "version_2_note_value",
                "local_68": "return_value",
                "local_60": "record_array"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x001166ef) */\n/* WARNING: Removing unreachable block (ram,0x001166df) */\n/* WARNING: Removing unreachable block (ram,0x001166d7) */\n/* WARNING: Removing unreachable block (ram,0x001166ea) */\n/* WARNING: Removing unreachable block (ram,0x00116716) */\n/* WARNING: Removing unreachable block (ram,0x0010858b) */\n\n\nulong parse_gnu_build_attribute_notes_001163d0(undefined8 *object_file,undefined8 *header,ulong section_size,undefined *result_buffer)\n\n{\n  ulong size_upper_bound;\n  undefined8 first_object_file;\n  undefined8 first_header;\n  bool invalid_flag;\n  ulong *current_record;\n  int memcmp_result;\n  undefined8 error_message;\n  long error_message;\n  void *reloc_buffer;\n  ulong current_record_index;\n  ulong record_length;\n  ulong note_type;\n  ulong record_description_size;\n  undefined *reloc_buffer_00;\n  ulong aligned_length;\n  ulong previous_record_length;\n  ulong buffer_offset;\n  ulong remaining_section_size;\n  ulong *record_pointer;\n  undefined *name_ptr;\n  char flag_char;\n  undefined *name_buffer_ptr;\n  int loop_counter;\n  undefined *note_body_ptr;\n  ulong *record_array_ptr;\n  ulong previous_record_description_size;\n  size_t array_size;\n  ulong *current_record_in_array;\n  byte boolean_flag;\n  ulong version_2_note_offset;\n  ulong version_3_note_offset;\n  ulong version_2_note_value;\n  ulong return_value;\n  ulong *record_array;\n  \n  boolean_flag = 0;\n  error_message = bfd_get_reloc_upper_bound();\n  return_value = section_size;\n  if (0 < error_message) {\n    reloc_buffer = (void *)xmalloc(error_message);\n    error_message = bfd_canonicalize_reloc(object_file,header,reloc_buffer,DAT_001278b0);\n    free(reloc_buffer);\n    if (error_message != 0) {\n      if (_DAT_00127a24 == 0) {\n        first_object_file = *object_file;\n        first_header = *header;\n        error_message = dcgettext(0,\"%s[%s]: Cannot merge - there are relocations against this section\",5);\n        print_error_message_00119ed0(error_message,first_object_file,first_header);\n      }\n      record_array = (ulong *)0x0;\n      goto LAB_001166f8;\n    }\n  }\n  record_array = (ulong *)xcalloc(section_size / 0xc,0x48,section_size % 0xc);\n  version_2_note_offset = 0;\n  version_2_note_value = 0;\n  remaining_section_size = section_size;\n  buffer_offset = 0;\n  record_array_ptr = record_array;\n  previous_record_length = 0;\n  note_body_ptr = result_buffer;\n  while (0xb < remaining_section_size) {\n    record_length = (**(code **)(object_file[1] + 0x40))(note_body_ptr);\n    *record_array_ptr = record_length;\n    record_length = (**(code **)(object_file[1] + 0x40))(note_body_ptr + 4);\n    record_array_ptr[1] = record_length;\n    note_type = (**(code **)(object_file[1] + 0x40))(note_body_ptr + 8);\n    record_length = *record_array_ptr;\n    record_array_ptr[2] = note_type;\n    record_description_size = record_array_ptr[1];\n    aligned_length = record_length + 3 & 0xfffffffffffffffc;\n    record_array_ptr[6] = aligned_length;\n    if (record_description_size != (record_description_size + 3 & 0xfffffffffffffffc)) {\n      error_message = dcgettext(0,\"corrupt GNU build attribute note: description size not a factor of 4\",5);\n      goto LAB_0010849a;\n    }\n    if (1 < note_type - 0x100) {\n      error_message = dcgettext(0,\"corrupt GNU build attribute note: wrong note type\",5);\n      goto LAB_0010849a;\n    }\n    size_upper_bound = aligned_length + record_description_size + 0xc;\n    if (remaining_section_size < size_upper_bound) {\n      error_message = dcgettext(0,\"corrupt GNU build attribute note: note too big\",5);\n      goto LAB_0010849a;\n    }\n    if (record_length < 2) {\n      error_message = dcgettext(0,\"corrupt GNU build attribute note: name too small\",5);\n      goto LAB_0010849a;\n    }\n    record_array_ptr[3] = (ulong)(note_body_ptr + 0xc);\n    record_array_ptr[4] = (ulong)(note_body_ptr + aligned_length + 0xc);\n    remaining_section_size = remaining_section_size + (-0xc - (aligned_length + record_description_size));\n    if (record_length != 2) {\n      if (note_body_ptr[0xc] == '$') {\n        if ((note_body_ptr[0xd] == '\\x01') && (note_body_ptr[0xe] == '1')) {\n          remaining_section_size = parse_gnu_build_attribute_notes_001163d0_00116490();\n          return remaining_section_size;\n        }\n      }\n      else if ((((4 < record_length) && (note_body_ptr[0xc] == 'G')) && (note_body_ptr[0xd] == 'A')) &&\n              ((note_body_ptr[0xe] == '$' && (note_body_ptr[0xf] == '\\x01')))) {\n        if (note_body_ptr[0x10] == '2') {\n          remaining_section_size = parse_gnu_build_attribute_notes_001163d0_00116490();\n          return remaining_section_size;\n        }\n        if (note_body_ptr[0x10] == '3') {\n          remaining_section_size = parse_gnu_build_attribute_notes_001163d0_00116490();\n          return remaining_section_size;\n        }\n        error_message = dcgettext(0,\"corrupt GNU build attribute note: unsupported version\",5);\n        goto LAB_0010849a;\n      }\n    }\n    current_record_index = buffer_offset;\n    previous_record_description_size = previous_record_length;\n    if (record_description_size == 0) {\n      if (note_type == 0x100) {\n        record_array_ptr[7] = version_2_note_offset;\nLAB_001164af:\n        record_description_size = previous_record_length;\n        previous_record_description_size = previous_record_length;\n      }\n      else {\n        record_array_ptr[7] = version_2_note_value;\nLAB_0011669e:\n        current_record_index = buffer_offset;\n        record_description_size = buffer_offset;\n      }\n    }\n    else {\n      if (record_description_size != 0x10) {\n        if (record_description_size < 0x11) {\n          if (record_description_size == 4) {\n            note_type = (**(code **)(object_file[1] + 0x40))();\n            record_description_size = 0xffffffffffffffff;\n            goto LAB_00116631;\n          }\n          if (record_description_size == 8) {\n            remaining_section_size = parse_gnu_build_attribute_notes_001163d0_001086af();\n            return remaining_section_size;\n          }\n        }\n        error_message = dcgettext(0,\"corrupt GNU build attribute note: bad description size\",5);\n        goto LAB_0010849a;\n      }\n      note_type = (**(code **)(object_file[1] + 0x28))(note_body_ptr + aligned_length + 0xc);\n      record_description_size = (**(code **)(object_file[1] + 0x28))();\n      if (record_description_size < note_type) {\n        note_type = record_description_size;\n      }\nLAB_00116631:\n      if (record_array_ptr[2] == 0x100) {\n        if (note_type == 0) {\n          note_type = version_2_note_offset;\n        }\n        record_length = *record_array_ptr;\n        record_array_ptr[7] = note_type;\n        previous_record_description_size = record_description_size;\n        version_2_note_offset = note_type;\n        if (record_description_size == 0) goto LAB_001164af;\n      }\n      else {\n        if (note_type == 0) {\n          note_type = version_2_note_value;\n        }\n        record_length = *record_array_ptr;\n        record_array_ptr[7] = note_type;\n        current_record_index = record_description_size;\n        version_2_note_value = note_type;\n        if (record_description_size == 0) goto LAB_0011669e;\n      }\n    }\n    record_array_ptr[8] = record_description_size;\n    if (*(char *)((record_array_ptr[3] - 1) + record_length) != '\\0') {\n      error_message = dcgettext(0,\"corrupt GNU build attribute note: name not NUL terminated\",5);\n      goto LAB_0010849a;\n    }\n    record_array_ptr = record_array_ptr + 9;\n    buffer_offset = current_record_index;\n    previous_record_length = previous_record_description_size;\n    note_body_ptr = note_body_ptr + size_upper_bound;\n  }\n  if (remaining_section_size == 0) {\n    first_object_file = *object_file;\n    first_header = *header;\n    error_message = dcgettext(0,\"%s[%s]: Warning: version note missing - assuming version 3\",5);\n    print_error_message_00119ed0(error_message,first_object_file,first_header);\n    array_size = ((long)record_array_ptr - (long)record_array >> 3) * -0x71c71c71c71c71c7;\n    qsort(record_array,array_size,0x48,compare_and_select_smaller_0011a1b0);\n    for (record_pointer = record_array; record_pointer < record_array_ptr; record_pointer = record_pointer + 9) {\n      remaining_section_size = record_pointer[2];\n      if (remaining_section_size != 0) {\n        buffer_offset = record_pointer[7];\n        previous_record_length = record_pointer[8];\n        current_record_in_array = record_pointer;\n        loop_counter = 0;\n        if (buffer_offset == previous_record_length) {\n          record_pointer[2] = 0;\n        }\n        else {\n          do {\n            do {\n              current_record = current_record_in_array;\n              current_record_in_array = current_record + -9;\n              if (current_record_in_array < record_array) goto LAB_001167f5;\n              record_length = current_record[-7];\n            } while (record_length == 0);\n            if ((*current_record_in_array != *record_pointer) ||\n               (memcmp_result = memcmp((void *)current_record[-6],(void *)record_pointer[3],*record_pointer), memcmp_result != 0)) break;\n            record_description_size = current_record[-2];\n            note_type = current_record[-1];\n            if (buffer_offset == record_description_size) {\n              if (previous_record_length == note_type) {\n                record_pointer[2] = 0;\n                break;\n              }\nLAB_001167a6:\n              if (previous_record_length <= note_type) {\n                record_pointer[2] = 0;\n                break;\n              }\n              if (note_type < buffer_offset) {\nLAB_0010852c:\n                if ((0xfffffffffffffff0 < note_type) || (buffer_offset <= (note_type + 0xf & 0xfffffffffffffff0))\n                   ) goto process_data_00116852;\n              }\nLAB_001167b8:\n              if ((remaining_section_size == 0x101) == (record_length == 0x101)) {\n                if (note_type <= previous_record_length) {\n                  note_type = previous_record_length;\n                }\n                if (record_description_size < buffer_offset) {\n                  buffer_offset = record_description_size;\n                }\n                current_record[-1] = note_type;\n                current_record[-2] = buffer_offset;\n                record_pointer[2] = 0;\n                break;\n              }\n            }\n            else {\n              if (record_description_size <= buffer_offset) goto LAB_001167a6;\n              if (note_type < buffer_offset) goto LAB_0010852c;\n              if (previous_record_length < buffer_offset) {\n                if ((0xfffffffffffffff0 < previous_record_length) || (record_description_size <= (previous_record_length + 0xf & 0xfffffffffffffff0))\n                   ) goto process_data_00116852;\n                goto LAB_001167b8;\n              }\n              if (previous_record_length != note_type) goto LAB_001167b8;\n            }\nprocess_data_00116852:\n            invalid_flag = loop_counter < 0x11;\n            loop_counter = loop_counter + 1;\n          } while (invalid_flag);\n        }\n      }\nLAB_001167f5:\n    }\n    qsort(record_array,array_size,0x48,compare_records_0011a250);\n    reloc_buffer_00 = (undefined *)xmalloc(section_size * 2);\n    version_3_note_offset = 0;\n    version_2_note_value = 0;\n    note_body_ptr = reloc_buffer_00;\n    for (record_pointer = record_array; record_pointer < record_array_ptr; record_pointer = record_pointer + 9) {\n      if (record_pointer[2] != 0) {\n        name_ptr = note_body_ptr + 0xc;\n        if ((record_pointer[7] == version_2_note_value) && (record_pointer[8] == version_3_note_offset)) {\n          (**(code **)(object_file[1] + 0x50))(*record_pointer,note_body_ptr);\n          (**(code **)(object_file[1] + 0x50))(0,note_body_ptr + 4);\n          (**(code **)(object_file[1] + 0x50))(record_pointer[2],note_body_ptr + 8);\n          buffer_offset = record_pointer[6];\n          remaining_section_size = *record_pointer;\n          note_body_ptr = (undefined *)record_pointer[3];\n          name_buffer_ptr = name_ptr;\n          for (previous_record_length = remaining_section_size; previous_record_length != 0; previous_record_length = previous_record_length - 1) {\n            *name_buffer_ptr = *note_body_ptr;\n            note_body_ptr = note_body_ptr + (ulong)boolean_flag * -2 + 1;\n            name_buffer_ptr = name_buffer_ptr + (ulong)boolean_flag * -2 + 1;\n          }\n          if (remaining_section_size < buffer_offset) {\n            for (error_message = buffer_offset - remaining_section_size; error_message != 0; error_message = error_message + -1) {\n              *name_buffer_ptr = 0;\n              name_buffer_ptr = name_buffer_ptr + (ulong)boolean_flag * -2 + 1;\n            }\n          }\n          note_body_ptr = name_ptr + buffer_offset;\n        }\n        else {\n          (**(code **)(object_file[1] + 0x50))();\n          if (*(int *)(object_file[1] + 8) == 5) {\n            flag_char = (*(char *)(object_file[0x22] + 4) == '\\x02') * '\\b' + '\\b';\n          }\n          else {\n            flag_char = '\\b';\n          }\n          (**(code **)(object_file[1] + 0x50))(flag_char,note_body_ptr + 4);\n          (**(code **)(object_file[1] + 0x50))(record_pointer[2],note_body_ptr + 8);\n          remaining_section_size = *record_pointer;\n          note_body_ptr = (undefined *)record_pointer[3];\n          name_buffer_ptr = name_ptr;\n          for (buffer_offset = remaining_section_size; buffer_offset != 0; buffer_offset = buffer_offset - 1) {\n            *name_buffer_ptr = *note_body_ptr;\n            note_body_ptr = note_body_ptr + (ulong)boolean_flag * -2 + 1;\n            name_buffer_ptr = name_buffer_ptr + (ulong)boolean_flag * -2 + 1;\n          }\n          buffer_offset = record_pointer[6];\n          if (remaining_section_size < buffer_offset) {\n            for (error_message = buffer_offset - remaining_section_size; error_message != 0; error_message = error_message + -1) {\n              *name_buffer_ptr = 0;\n              name_buffer_ptr = name_buffer_ptr + (ulong)boolean_flag * -2 + 1;\n            }\n          }\n          error_message = object_file[1];\n          name_ptr = name_ptr + buffer_offset;\n          note_body_ptr = name_ptr + 8;\n          if ((*(int *)(error_message + 8) == 5) && (*(char *)(object_file[0x22] + 4) == '\\x02')) {\n            (**(code **)(error_message + 0x38))(record_pointer[7],name_ptr);\n            (**(code **)(object_file[1] + 0x38))(record_pointer[8],note_body_ptr);\n            note_body_ptr = name_ptr + 0x10;\n          }\n          else {\n            (**(code **)(error_message + 0x50))(record_pointer[7],name_ptr);\n            (**(code **)(object_file[1] + 0x50))(record_pointer[8],name_ptr + 4);\n          }\n          version_2_note_value = record_pointer[7];\n          version_3_note_offset = record_pointer[8];\n        }\n      }\n    }\n    buffer_offset = (long)note_body_ptr - (long)reloc_buffer_00;\n    remaining_section_size = buffer_offset;\n    note_body_ptr = reloc_buffer_00;\n    return_value = section_size;\n    if (buffer_offset < section_size) {\n      for (; return_value = buffer_offset, remaining_section_size != 0; remaining_section_size = remaining_section_size - 1) {\n        *result_buffer = *note_body_ptr;\n        note_body_ptr = note_body_ptr + (ulong)boolean_flag * -2 + 1;\n        result_buffer = result_buffer + (ulong)boolean_flag * -2 + 1;\n      }\n    }\n    free(reloc_buffer_00);\n  }\n  else {\n    error_message = dcgettext(0,\"corrupt GNU build attribute notes: excess data at end\",5);\nLAB_0010849a:\n    if (error_message != 0) {\n      bfd_set_error(0x11);\n      display_error_001126c0(0,object_file,header,error_message);\n      DAT_00127a20 = 1;\n    }\n  }\nLAB_001166f8:\n  free(record_array);\n  return return_value;\n}\n\n",
            "called": [
                "bfd_canonicalize_reloc",
                "xcalloc",
                "free",
                "xmalloc",
                "dcgettext",
                "bfd_get_reloc_upper_bound",
                "FUN_00119ed0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001163d0",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "parse_gnu_build_attribute_notes_001163d0"
        },
        "FUN_00108a2a": {
            "renaming": {
                "FUN_00108a2a": "print_usage_and_exit_00108a2a",
                "param_1": "output_file",
                "param_2": "exit_code",
                "uVar1": "version_number",
                "pcVar2": "localized_string"
            },
            "code": "\nvoid print_usage_and_exit_00108a2a(FILE *output_file,int exit_code)\n\n{\n  undefined8 version_number;\n  char *localized_string;\n  \n  version_number = DAT_001275e0;\n  localized_string = (char *)dcgettext(0,\"Usage: %s <option(s)> in-file(s)\\n\",5);\n  fprintf(output_file,localized_string,version_number);\n  localized_string = (char *)dcgettext(0,\" Removes symbols and sections from files\\n\",5);\n  fprintf(output_file,localized_string);\n  localized_string = (char *)dcgettext(0,\" The options are:\\n\",5);\n  fprintf(output_file,localized_string);\n  localized_string = (char *)dcgettext(0,\n                             \"  -I --input-target=<bfdname>      Assume input file is in format <bfdname>\\n  -O --output-target=<bfdname>     Create an output file in format <bfdname>\\n  -F --target=<bfdname>            Set both input and output format to <bfdname>\\n  -p --preserve-dates              Copy modified/access timestamps to the output\\n\"\n                             ,5);\n  fprintf(output_file,localized_string);\n  localized_string = (char *)dcgettext(0,\n                             \"  -D --enable-deterministic-archives\\n                                   Produce deterministic output when stripping archives (default)\\n  -U --disable-deterministic-archives\\n                                   Disable -D behavior\\n\"\n                             ,5);\n  fprintf(output_file,localized_string);\n  localized_string = (char *)dcgettext(0,\n                             \"  -R --remove-section=<name>       Also remove section <name> from the output\\n     --remove-relocations <name>   Remove relocations from section <name>\\n  -s --strip-all                   Remove all symbol and relocation information\\n  -g -S -d --strip-debug           Remove all debugging symbols & sections\\n     --strip-dwo                   Remove all DWO sections\\n     --strip-unneeded              Remove all symbols not needed by relocations\\n     --only-keep-debug             Strip everything but the debug information\\n  -M  --merge-notes                Remove redundant entries in note sections (default)\\n      --no-merge-notes             Do not attempt to remove redundant notes\\n  -N --strip-symbol=<name>         Do not copy symbol <name>\\n     --keep-section=<name>         Do not strip section <name>\\n  -K --keep-symbol=<name>          Do not strip symbol <name>\\n     --keep-section-symbols        Do not strip section symbols\\n     --keep-file-symbols           Do not strip file symbol(s)\\n  -w --wildcard                    Permit wildcard in symbol comparison\\n  -x --discard-all                 Remove all non-global symbols\\n  -X --discard-locals              Remove any compiler-generated symbols\\n  -v --verbose                     List all object files modified\\n  -V --version                     Display this program\\'s version number\\n  -h --help                        Display this output\\n     --info                        List object formats & architectures supported\\n  -o <file>                        Place stripped output into <file>\\n\"\n                             ,5);\n  fprintf(output_file,localized_string);\n  print_supported_targets_00104a35(DAT_001275e0,output_file);\n  if (exit_code == 0) {\n    localized_string = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(output_file,localized_string,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  exit(exit_code);\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext",
                "FUN_00104a35",
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108a2a",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "print_usage_and_exit_00108a2a"
        },
        "FUN_00108c86": {
            "renaming": {
                "FUN_00108c86": "parse_config_00108c86",
                "param_1": "config",
                "cVar1": "result",
                "iVar2": "comparisonResult",
                "sVar3": "strLength",
                "puVar4": "parsedConfig",
                "lVar5": "offset",
                "__s": "configString",
                "__s1": "architecture",
                "puVar6": "parsedConfigPtr",
                "uVar7": "returnValue",
                "bVar8": "bFlag"
            },
            "code": "\nundefined8 parseConfig_00108c86(long *config)\n\n{\n  char result;\n  int comparisonResult;\n  size_t strLength;\n  undefined2 *parsedConfig;\n  long offset;\n  char *configString;\n  char *architecture;\n  undefined2 *parsedConfigPtr;\n  undefined8 returnValue;\n  byte bFlag;\n  \n  bFlag = 0;\n  offset = *config;\n  configString = (char *)(offset + 4);\n  result = compare_strings_00113fb0(configString,&DAT_0011b73b);\n  if (result == '\\0') {\n    result = compare_strings_00113fb0(configString,\"bsdrv-\");\n    if (result == '\\0') {\n      result = compare_strings_00113fb0(configString,\"rtdrv-\");\n      if (result == '\\0') {\n        return 0xffffffff;\n      }\n      configString = (char *)(offset + 6);\n      returnValue = 0xc;\n    }\n    else {\n      configString = (char *)(offset + 6);\n      returnValue = 0xb;\n    }\n  }\n  else {\n    returnValue = 10;\n  }\n  strLength = strlen(configString);\n  parsedConfig = (undefined2 *)xmalloc(strLength + 8);\n  architecture = configString + 4;\n  parsedConfigPtr = parsedConfig;\n  for (offset = strLength + 1; offset != 0; offset = offset + -1) {\n    *(char *)parsedConfigPtr = *configString;\n    configString = configString + (ulong)bFlag * -2 + 1;\n    parsedConfigPtr = (undefined2 *)((long)parsedConfigPtr + (ulong)bFlag * -2 + 1);\n  }\n  *(undefined *)(parsedConfig + 1) = 0x69;\n  *parsedConfig = 0x6570;\n  comparisonResult = strcmp(architecture,\"ia32\");\n  if (comparisonResult == 0) {\n    *(undefined *)((long)parsedConfig + 7) = 0x36;\n    *(undefined2 *)((long)parsedConfig + 5) = 0x3833;\n  }\n  else {\n    comparisonResult = strcmp(architecture,\"x86_64\");\n    if (comparisonResult == 0) {\n      *(undefined *)((long)parsedConfig + 7) = 0x2d;\n    }\n    else {\n      comparisonResult = strcmp(architecture,\"aarch64\");\n      if (comparisonResult == 0) {\n        *(undefined8 *)((long)parsedConfig + 0xb) = 0x656c7474696c2d;\n      }\n    }\n  }\n  *config = (long)parsedConfig;\n  return returnValue;\n}\n\n",
            "called": [
                "strcmp",
                "FUN_00113fb0",
                "strlen",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108c86",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "parse_config_00108c86"
        },
        "FUN_0010911f": {
            "renaming": {
                "FUN_0010911f": "print_error_message_0010911f",
                "param_1": "message",
                "__format": "formatString"
            },
            "code": "\n\n\nvoid printErrorMessage_0010911f(undefined8 message)\n\n{\n  char *formatString;\n  \n  formatString = (char *)dcgettext(0,\"bad mangled name `%s\\'\\n\",5);\n  fprintf(_stderr,formatString,message);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010911f",
            "calling": [
                "FUN_0010d559",
                "FUN_0010c95e",
                "FUN_0010ee3f",
                "FUN_0010d882",
                "FUN_0010d21c"
            ],
            "imported": false,
            "current_name": "print_error_message_0010911f"
        },
        "bfd_get_stab_name": {
            "renaming": {},
            "code": "\nvoid bfd_get_stab_name(void)\n\n{\n  bfd_get_stab_name();\n  return;\n}\n\n",
            "called": [
                "bfd_get_stab_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104110",
            "calling": [
                "FUN_00108b3e"
            ],
            "imported": false,
            "current_name": "bfd_get_stab_name"
        },
        "FUN_001053d5": {
            "renaming": {
                "FUN_001053d5": "print_and_close_001053d5",
                "unaff_R12": "pointer",
                "unaff_R14": "messagePointer"
            },
            "code": "\nundefined4 printAndClose_001053d5(void)\n\n{\n  long pointer;\n  undefined8 *messagePointer;\n  \n  print_error_message_0011a110(*messagePointer);\n  *(undefined4 *)(pointer + 8) = 1;\n  bfd_close_all_done();\n  return *(undefined4 *)(pointer + 8);\n}\n\n",
            "called": [
                "FUN_0011a110"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001053d5",
            "calling": [
                "FUN_00119f70"
            ],
            "imported": false,
            "current_name": "print_and_close_001053d5"
        },
        "FUN_00104bba": {
            "renaming": {
                "FUN_00104bba": "check_error_00104bba",
                "in_EAX": "eax_value",
                "uVar1": "error_message",
                "unaff_EBP": "ebp_value",
                "unaff_R14": "r14_value"
            },
            "code": "\nvoid check_error_00104bba(void)\n\n{\n  uint eax_value;\n  undefined8 error_message;\n  uint ebp_value;\n  long r14_value;\n  \n  if ((eax_value & 2) != 0) {\n    error_message = dcgettext(0,\"error: %s both copied and removed\",5);\n                    \n    print_error_and_exit_00119dd0(error_message);\n  }\n  if ((((eax_value & 8) == 0) || ((ebp_value & 0x10) == 0)) && ((ebp_value & 0x18) != 0x18)) {\n    if ((((eax_value & 0x20) == 0) || ((ebp_value & 0x40) == 0)) && ((ebp_value & 0x60) != 0x60)) {\n      *(uint *)(r14_value + 0x14) = eax_value | ebp_value;\n      return;\n    }\n    error_message = dcgettext(0,\"error: %s both sets and alters LMA\",5);\n                    \n    print_error_and_exit_00119dd0(error_message);\n  }\n  error_message = dcgettext(0,\"error: %s both sets and alters VMA\",5);\n                    \n  print_error_and_exit_00119dd0(error_message);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104bba",
            "calling": [
                "FUN_00114190"
            ],
            "imported": false,
            "current_name": "check_error_00104bba"
        },
        "FUN_00109a0b": {
            "renaming": {
                "FUN_00109a0b": "copy_and_null_terminate_00109a0b",
                "param_1": "source",
                "param_2": "size",
                "puVar1": "destination",
                "lVar2": "loopCounter",
                "puVar3": "destinationPointer",
                "bVar4": "byteFlag"
            },
            "code": "\nvoid copyAndNullTerminate_00109a0b(undefined *source,int size)\n\n{\n  undefined *destination;\n  long loopCounter;\n  undefined *destinationPointer;\n  byte byteFlag;\n  \n  byteFlag = 0;\n  destination = (undefined *)xmalloc((long)(size + 1));\n  destinationPointer = destination;\n  for (loopCounter = (long)size; loopCounter != 0; loopCounter = loopCounter + -1) {\n    *destinationPointer = *source;\n    source = source + (ulong)byteFlag * -2 + 1;\n    destinationPointer = destinationPointer + (ulong)byteFlag * -2 + 1;\n  }\n  destination[size] = 0;\n  return;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109a0b",
            "calling": [
                "FUN_0011173a",
                "FUN_0010d559",
                "FUN_0010c95e",
                "FUN_0010ee3f",
                "FUN_0010afd5",
                "FUN_0010d21c"
            ],
            "imported": false,
            "current_name": "copy_and_null_terminate_00109a0b"
        },
        "bfd_coff_get_syment": {
            "renaming": {},
            "code": "\nvoid bfd_coff_get_syment(void)\n\n{\n  bfd_coff_get_syment();\n  return;\n}\n\n",
            "called": [
                "bfd_coff_get_syment"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001046a0",
            "calling": [
                "FUN_0010554f",
                "FUN_0010e07c",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "bfd_coff_get_syment"
        },
        "FUN_0010da0b": {
            "renaming": {
                "FUN_0010da0b": "allocate_and_initialize_slot_0010da0b",
                "param_1": "slotPointer",
                "param_2": "slotIndex",
                "param_3": "unknown1",
                "param_4": "unknown2",
                "uVar1": "errorString",
                "plVar2": "slot",
                "lVar3": "adjustedSlotIndex",
                "lVar4": "loopCounter",
                "uVar5": "remainingSlots",
                "bVar6": "bitwiseShift",
                "auVar7": "result"
            },
            "code": "\nundefined  [16] allocateAndInitializeSlot_0010da0b(long **slotPointer,ulong slotIndex,undefined8 unknown1,undefined8 unknown2)\n\n{\n  undefined8 errorString;\n  long *slot;\n  long adjustedSlotIndex;\n  long loopCounter;\n  ulong remainingSlots;\n  byte bitwiseShift;\n  undefined result [16];\n  \n  bitwiseShift = 0;\n  remainingSlots = slotIndex;\n  if ((long)slotIndex < 0x3e90) {\n    for (; 0xf < (long)remainingSlots; remainingSlots = remainingSlots - 0x10) {\n      if (*slotPointer == (long *)0x0) {\n        slot = (long *)xmalloc(0x88);\n        *slotPointer = slot;\n        for (adjustedSlotIndex = 0x22; adjustedSlotIndex != 0; adjustedSlotIndex = adjustedSlotIndex + -1) {\n          *(undefined4 *)slot = 0;\n          slot = (long *)((long)slot + (ulong)bitwiseShift * -8 + 4);\n        }\n      }\n      slotPointer = (long **)*slotPointer;\n    }\n    adjustedSlotIndex = (slotIndex >> 4) * -0x10;\n    if ((long)slotIndex < 0) {\n      adjustedSlotIndex = 0;\n    }\n    if (*slotPointer == (long *)0x0) {\n      slot = (long *)xmalloc(0x88);\n      *slotPointer = slot;\n      for (loopCounter = 0x22; loopCounter != 0; loopCounter = loopCounter + -1) {\n        *(undefined4 *)slot = 0;\n        slot = (long *)((long)slot + (ulong)bitwiseShift * -8 + 4);\n      }\n    }\n    result._8_8_ = unknown2;\n    result._0_8_ = *slotPointer + slotIndex + adjustedSlotIndex + 1;\n    return result;\n  }\n  errorString = dcgettext(0,\"Excessively large slot index: %lx\",5);\n                    \n  print_error_and_exit_00119dd0(errorString,slotIndex);\n}\n\n",
            "called": [
                "FUN_00119dd0",
                "dcgettext",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010da0b",
            "calling": [
                "FUN_00112a33",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_slot_0010da0b"
        },
        "FUN_00112894": {
            "renaming": {
                "FUN_00112894": "initialize_data_structure_00112894",
                "param_1": "inputValue1",
                "param_2": "inputValue2",
                "param_3": "inputValue3",
                "param_4": "inputValue4",
                "puVar1": "dataStructure",
                "puVar2": "ptr",
                "lVar3": "counter",
                "bVar4": "byteValue"
            },
            "code": "\nundefined8 *\ninitializeDataStructure_00112894(undefined8 inputValue1,undefined inputValue2,undefined8 inputValue3,undefined8 inputValue4)\n\n{\n  undefined8 *dataStructure;\n  undefined8 *ptr;\n  long counter;\n  byte byteValue;\n  \n  byteValue = 0;\n  dataStructure = (undefined8 *)xmalloc(0x1b0);\n  ptr = dataStructure;\n  for (counter = 0x6c; counter != 0; counter = counter + -1) {\n    *(undefined4 *)ptr = 0;\n    ptr = (undefined8 *)((long)ptr + (ulong)byteValue * -8 + 4);\n  }\n  *dataStructure = inputValue1;\n  *(undefined *)(dataStructure + 1) = inputValue2;\n  dataStructure[2] = inputValue3;\n  dataStructure[3] = inputValue4;\n  *(undefined4 *)(dataStructure + 0x10) = 1;\n  ptr = (undefined8 *)xmalloc(8);\n  dataStructure[0xd] = 0xffffffffffffffff;\n  dataStructure[0x11] = ptr;\n  *ptr = 0;\n  return dataStructure;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112894",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "initialize_data_structure_00112894"
        },
        "FUN_00109b2f": {
            "renaming": {
                "FUN_00109b2f": "extract_list_item_00109b2f",
                "param_1": "start_address",
                "__ptr": "current_item",
                "puVar1": "next_item"
            },
            "code": "\nundefined8 * extract_list_item_00109b2f(long start_address)\n\n{\n  undefined8 *current_item;\n  undefined8 *next_item;\n  \n  current_item = *(undefined8 **)(start_address + 0x60);\n  if (current_item != (undefined8 *)0x0) {\n    next_item = (undefined8 *)current_item[1];\n    *(undefined8 *)(start_address + 0x60) = *current_item;\n    free(current_item);\n    return next_item;\n  }\n  return current_item;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109b2f",
            "calling": [
                "FUN_0010e5db",
                "FUN_0010a94e",
                "FUN_0010a0e9",
                "FUN_0010e918",
                "FUN_0010a83e",
                "FUN_0010a181",
                "FUN_0010ebb0",
                "FUN_0010abdd",
                "FUN_0010ba08",
                "FUN_0010e9a0",
                "FUN_0010e6a8",
                "FUN_0010a77a",
                "FUN_0010a424",
                "FUN_0010a377",
                "FUN_0010e7c2",
                "FUN_0010b948",
                "FUN_0010eafe",
                "FUN_0010a2b9",
                "FUN_0010aa53",
                "FUN_00109ed3"
            ],
            "imported": false,
            "current_name": "extract_list_item_00109b2f"
        },
        "strdup": {
            "renaming": {},
            "code": "\n\n\nchar * strdup(char *__s)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strdup(__s);\n  return pcVar1;\n}\n\n",
            "called": [
                "strdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104880",
            "calling": [
                "FUN_00108d9a"
            ],
            "imported": false,
            "current_name": "strdup"
        },
        "FUN_00108d9a": {
            "renaming": {
                "FUN_00108d9a": "check_symbol_redefinition_00108d9a",
                "param_1": "symbol",
                "param_2": "prev_symbol",
                "param_3": "cur_symbol",
                "param_4": "result",
                "ppcVar1": "symbols",
                "pcVar2": "prev_symbol_dup",
                "lVar3": "symbol_found",
                "uVar4": "error_msg",
                "plVar5": "symbol_slot"
            },
            "code": "\nundefined8 check_symbol_redefinition_00108d9a(undefined8 symbol,char *prev_symbol,char *cur_symbol,undefined8 result)\n\n{\n  char **symbols;\n  char *prev_symbol_dup;\n  long symbol_found;\n  undefined8 error_msg;\n  long *symbol_slot;\n  \n  symbols = (char **)xmalloc(0x10);\n  prev_symbol_dup = strdup(prev_symbol);\n  *symbols = prev_symbol_dup;\n  prev_symbol_dup = strdup(cur_symbol);\n  error_msg = DAT_001278d0;\n  symbols[1] = prev_symbol_dup;\n  symbol_found = htab_find(error_msg,symbols);\n  if (symbol_found != 0) {\n    error_msg = dcgettext(0,\"%s: Multiple redefinition of symbol \\\"%s\\\"\",5);\n                    \n    print_error_and_exit_00119dd0(error_msg,symbol,prev_symbol);\n  }\n  symbol_found = htab_find(DAT_001278c8,cur_symbol);\n  if (symbol_found != 0) {\n    error_msg = dcgettext(0,\"%s: Symbol \\\"%s\\\" is target of more than one redefinition\",5);\n                    \n    print_error_and_exit_00119dd0(error_msg,symbol,cur_symbol);\n  }\n  symbol_slot = (long *)htab_find_slot(DAT_001278d0,symbols,1);\n  error_msg = DAT_001278c8;\n  *symbol_slot = (long)symbols;\n  prev_symbol_dup = symbols[1];\n  symbols = (char **)htab_find_slot(error_msg,prev_symbol_dup,1);\n  *symbols = prev_symbol_dup;\n  return result;\n}\n\n",
            "called": [
                "htab_find",
                "FUN_00119dd0",
                "xmalloc",
                "dcgettext",
                "strdup",
                "htab_find_slot"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108d9a",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "check_symbol_redefinition_00108d9a"
        },
        "FUN_0010e9a0": {
            "renaming": {
                "FUN_0010e9a0": "process_string_0010e9a0",
                "param_1": "num",
                "param_2": "str1",
                "param_3": "option",
                "param_4": "value",
                "lVar1": "count",
                "uVar2": "result",
                "__s": "item",
                "__s_00": "newItem",
                "sVar3": "strLen1",
                "sVar4": "strLen2",
                "__s_01": "formattedStr",
                "pcVar5": "flag",
                "uVar6": "flagValue"
            },
            "code": "\nundefined4 processString_0010e9a0(long num,char *str1,undefined4 option,undefined8 value)\n\n{\n  long count;\n  undefined4 result;\n  byte *item;\n  byte *newItem;\n  size_t strLen1;\n  size_t strLen2;\n  char *formattedStr;\n  char *flag;\n  undefined8 flagValue;\n  \n  item = (byte *)extract_list_item_00109b2f();\n  switch(option) {\n  case 1:\n    flag = \"G\";\n    flagValue = 0x20;\n    break;\n  case 2:\n    flag = \"S\";\n    flagValue = 0x26;\n    break;\n  case 3:\n    flag = \"V\";\n    flagValue = 0x26;\n    break;\n  case 4:\n    flag = \"\";\n    flagValue = 0x80;\n    if (((&_sch_istable)[(ulong)*item * 2] & 4) == 0) {\n      count = *(long *)(num + 0x68);\n      *(long *)(num + 0x68) = count + 1;\n      strLen1 = strlen((char *)item);\n      newItem = (byte *)xmalloc(strLen1 + 0x14);\n      sprintf((char *)newItem,\"%ld=%s\",count,item);\n      free(item);\n      item = newItem;\n    }\n    break;\n  case 5:\n    flag = \"r\";\n    flagValue = 0x40;\n    break;\n  default:\n                    \n    abort();\n  }\n  strLen1 = strlen(str1);\n  strLen2 = strlen((char *)item);\n  formattedStr = (char *)xmalloc(strLen1 + 3 + strLen2);\n  sprintf(formattedStr,\"%s:%s%s\",str1,flag,item);\n  free(item);\n  result = process_string_0010e2f0(num,flagValue,0,value,formattedStr);\n  if ((char)result != '\\0') {\n    free(formattedStr);\n  }\n  return result;\n}\n\n",
            "called": [
                "abort",
                "strlen",
                "free",
                "xmalloc",
                "sprintf",
                "FUN_00109b2f",
                "FUN_0010e2f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e9a0",
            "calling": [
                "FUN_001135a5"
            ],
            "imported": false,
            "current_name": "process_string_0010e9a0"
        },
        "FUN_0010827b": {
            "renaming": {
                "FUN_0010827b": "print_error_and_exit_0010827b",
                "unaff_RBX": "section",
                "uVar1": "section_value",
                "uVar2": "error_message"
            },
            "code": "\nvoid print_error_and_exit_0010827b(void)\n\n{\n  undefined8 section_value;\n  undefined8 error_message;\n  undefined8 *section;\n  \n  section_value = *section;\n  error_message = dcgettext(0,\"error: section %s matches both remove and copy options\",5);\n                    \n  print_error_and_exit_0010827b_00119dd0(error_message,section_value);\n}\n\n",
            "called": [
                "FUN_00119dd0",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010827b",
            "calling": [
                "FUN_00115b70"
            ],
            "imported": false,
            "current_name": "print_error_and_exit_0010827b"
        },
        "bfd_set_symtab": {
            "renaming": {},
            "code": "\nvoid bfd_set_symtab(void)\n\n{\n  bfd_set_symtab();\n  return;\n}\n\n",
            "called": [
                "bfd_set_symtab"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104460",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_set_symtab"
        },
        "FUN_00104920": {
            "renaming": {
                "FUN_00104920": "handle_bad_number_00104920",
                "uVar1": "error_message",
                "dcgettext": "retrieve_error_message",
                "print_error_and_exit_00119dd0": "print_error_and_exit"
            },
            "code": "\nvoid handle_bad_number_00104920(void)\n\n{\n  undefined8 error_message;\n  \n  error_message = dcgettext(0,\"%s: bad number: %s\",5);\n                    \n  print_error_and_exit(error_message);\n}\n\n",
            "called": [
                "FUN_00119dd0",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104920",
            "calling": [
                "FUN_00119940"
            ],
            "imported": false,
            "current_name": "handle_bad_number_00104920"
        },
        "FUN_00113f20": {
            "renaming": {
                "FUN_00113f20": "initialize_hash_table_00113f20",
                "htab_create_alloc": "createHashTable",
                "htab_hash_string": "hashString",
                "htab_eq_string": "compareStrings",
                "xcalloc": "allocateMemory",
                "free": "deallocateMemory"
            },
            "code": "\nvoid initializeHashTable_00113f20(void)\n\n{\n  htab_create_alloc(0x10,htab_hash_string,compareStrings,0,xcalloc,free);\n  return;\n}\n\n",
            "called": [
                "htab_eq_string",
                "free",
                "htab_hash_string",
                "htab_create_alloc",
                "xcalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113f20",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "initialize_hash_table_00113f20"
        },
        "htab_find_slot": {
            "renaming": {},
            "code": "\nvoid htab_find_slot(void)\n\n{\n  htab_find_slot();\n  return;\n}\n\n",
            "called": [
                "htab_find_slot"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001044a0",
            "calling": [
                "FUN_00104cc1",
                "FUN_00116b90",
                "FUN_00108d9a"
            ],
            "imported": false,
            "current_name": "htab_find_slot"
        },
        "mkdtemp": {
            "renaming": {},
            "code": "\n\n\nchar * mkdtemp(char *__template)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = mkdtemp(__template);\n  return pcVar1;\n}\n\n",
            "called": [
                "mkdtemp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104670",
            "calling": [
                "FUN_0011a0e0"
            ],
            "imported": false,
            "current_name": "mkdtemp"
        },
        "vfprintf": {
            "renaming": {},
            "code": "\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n  int iVar1;\n  \n  iVar1 = vfprintf(__s,__format,__arg);\n  return iVar1;\n}\n\n",
            "called": [
                "vfprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104770",
            "calling": [
                "FUN_00119e70",
                "FUN_001126c0"
            ],
            "imported": false,
            "current_name": "vfprintf"
        },
        "bfd_set_default_target": {
            "renaming": {},
            "code": "\nvoid bfd_set_default_target(void)\n\n{\n  bfd_set_default_target();\n  return;\n}\n\n",
            "called": [
                "bfd_set_default_target"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104150",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "bfd_set_default_target"
        },
        "write": {
            "renaming": {},
            "code": "\n\n\nssize_t write(int __fd,void *__buf,size_t __n)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = write(__fd,__buf,__n);\n  return sVar1;\n}\n\n",
            "called": [
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001041c0",
            "calling": [
                "FUN_00115a90"
            ],
            "imported": false,
            "current_name": "write"
        },
        "FUN_00108179": {
            "renaming": {
                "FUN_00108179": "initialize_alignment_00108179",
                "unaff_RBX": "pointer1",
                "unaff_RBP": "pointer2",
                "unaff_R12": "pointer3",
                "unaff_R14B": "booleanFlag",
                "unaff_R15": "pointer4",
                "lVar4": "errorString",
                "lVar1": "arrayElement1",
                "lVar2": "arrayElement2",
                "lVar5": "foundElement",
                "cVar3": "charVar",
                "find_element_in_array_00115d00": "findElementInArray",
                "copy_private_data_0010808f": "copyPrivateData",
                "display_error_001126c0": "displayError"
            },
            "code": "\nvoid initializeAlignment_00108179(void)\n\n{\n  long arrayElement1;\n  long arrayElement2;\n  char charVar;\n  long errorString;\n  long foundElement;\n  long pointer1;\n  long pointer2;\n  long pointer3;\n  char booleanFlag;\n  long pointer4;\n  \n  errorString = dcgettext(0,\"failed to set alignment\",5);\n  *(undefined4 *)(pointer4 + 0xb4) = *(undefined4 *)(pointer1 + 0xb4);\n  *(byte *)(pointer4 + 0x28) =\n       *(byte *)(pointer4 + 0x28) & 0xcf | *(byte *)(pointer1 + 0x28) & 0x30;\n  *(long *)(pointer1 + 0x60) = pointer4;\n  *(undefined8 *)(pointer1 + 0x58) = 0;\n  if ((*(byte *)(pointer1 + 0x27) & 2) != 0) {\n    arrayElement1 = *(long *)(pointer1 + 0xd0);\n    foundElement = findElementInArray(arrayElement1,*(undefined8 *)(pointer1 + 0xe0));\n    if ((foundElement != 0) &&\n       (arrayElement2 = *(long *)(pointer3 + 8), *(uint *)(foundElement + 0x18) = *(uint *)(foundElement + 0x18) | 0x20,\n       *(int *)(arrayElement2 + 8) == 5)) {\n      *(long *)(arrayElement1 + 0xb0) = foundElement;\n      charVar = (**(code **)(*(long *)(pointer2 + 8) + 0x158))();\n      if (charVar == '\\0') {\n        copyPrivateData();\n        return;\n      }\n      goto LAB_0011571e;\n    }\n  }\n  charVar = (**(code **)(*(long *)(pointer2 + 8) + 0x158))();\n  if (charVar == '\\0') {\n    copyPrivateData();\n    return;\n  }\nLAB_0011571e:\n  if (booleanFlag != '\\0') {\n    *(undefined4 *)(*(long *)(pointer4 + 0xd0) + 4) = 8;\n  }\n  if (errorString != 0) {\n    DAT_00127a20 = 1;\n    displayError(0);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00115d00",
                "dcgettext",
                "FUN_0010808f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108179",
            "calling": [
                "FUN_00108072"
            ],
            "imported": false,
            "current_name": "initialize_alignment_00108179"
        },
        "FUN_00109022": {
            "renaming": {
                "FUN_00109022": "validate_and_get_subsection_00109022",
                "param_1": "file_descriptor",
                "param_2": "subsections",
                "param_3": "unknown_param_1",
                "param_4": "unknown_param_2",
                "uVar1": "subsections_length",
                "pcVar2": "warning_message",
                "plVar3": "current_subsection",
                "lVar4": "loop_counter",
                "uVar5": "subsections_index",
                "pplVar6": "subsections_array",
                "bVar7": "zero",
                "auVar8": "function_result"
            },
            "code": "\n\n\nundefined  [16] validate_and_get_subsection_00109022(long file_descriptor,uint *subsections,undefined8 unknown_param_1,undefined8 unknown_param_2)\n\n{\n  uint subsections_length;\n  char *warning_message;\n  long *current_subsection;\n  long loop_counter;\n  uint subsections_index;\n  long **subsections_array;\n  byte zero;\n  undefined function_result [16];\n  \n  zero = 0;\n  subsections_index = *subsections;\n  subsections_length = subsections[1];\n  if (((int)subsections_index < 0) || (*(uint *)(file_descriptor + 0x80) <= subsections_index)) {\n    warning_message = (char *)dcgettext(0,\"Type file number %d out of range\\n\",5);\n    fprintf(_stderr,warning_message,(ulong)subsections_index);\n  }\n  else {\n    if (-1 < (int)subsections_length) {\n      subsections_array = (long **)(*(long *)(file_descriptor + 0x88) + (long)(int)subsections_index * 8);\n      for (subsections_index = subsections_length; 0xf < (int)subsections_index; subsections_index = subsections_index - 0x10) {\n        if (*subsections_array == (long *)0x0) {\n          current_subsection = (long *)xmalloc(0x88);\n          *subsections_array = current_subsection;\n          for (loop_counter = 0x22; loop_counter != 0; loop_counter = loop_counter + -1) {\n            *(undefined4 *)current_subsection = 0;\n            current_subsection = (long *)((long)current_subsection + (ulong)zero * -8 + 4);\n          }\n        }\n        subsections_array = (long **)*subsections_array;\n      }\n      if (*subsections_array == (long *)0x0) {\n        current_subsection = (long *)xmalloc(0x88);\n        *subsections_array = current_subsection;\n        for (loop_counter = 0x22; loop_counter != 0; loop_counter = loop_counter + -1) {\n          *(undefined4 *)current_subsection = 0;\n          current_subsection = (long *)((long)current_subsection + (ulong)zero * -8 + 4);\n        }\n      }\n      current_subsection = *subsections_array + (long)(int)((subsections_length >> 4) * -0x10 + subsections_length) + 1;\n      goto LAB_00109117;\n    }\n    warning_message = (char *)dcgettext(0,\"Type index number %d out of range\\n\",5);\n    fprintf(_stderr,warning_message,(ulong)subsections_length);\n  }\n  current_subsection = (long *)0x0;\nLAB_00109117:\n  function_result._8_8_ = unknown_param_2;\n  function_result._0_8_ = current_subsection;\n  return function_result;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109022",
            "calling": [
                "FUN_0010c2d2",
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "validate_and_get_subsection_00109022"
        },
        "__cxa_finalize": {
            "renaming": {},
            "code": "\nvoid __cxa_finalize(void)\n\n{\n  __cxa_finalize();\n  return;\n}\n\n",
            "called": [
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104910",
            "calling": [
                "_FINI_0"
            ],
            "imported": false,
            "current_name": "__cxa_finalize"
        },
        "FUN_0010c05d": {
            "renaming": {
                "FUN_0010c05d": "record_variable_data_0010c05d",
                "param_1": "filePtr",
                "param_2": "recordType",
                "param_3": "recordSize",
                "param_4": "variableType",
                "param_6": "resultCode",
                "auVar1": "output",
                "auVar9": "result",
                "piVar3": "allocatedMemPtr",
                "bVar8": "bVar",
                "cVar4": "isNewVariable",
                "lVar5": "loopCounter",
                "lVar6": "dataStructurePtr",
                "uVar2": "returnValue"
            },
            "code": "\n\n\nundefined  [16]\nrecordVariableData_0010c05d(long filePtr,long recordType,ulong recordSize,int variableType,undefined8 param_5,\n            undefined8 resultCode)\n\n{\n  undefined output [16];\n  undefined8 returnValue;\n  int *allocatedMemPtr;\n  char isNewVariable;\n  long loopCounter;\n  long dataStructurePtr;\n  int *piVar7;\n  byte bVar;\n  undefined result [16];\n  \n  bVar = 0;\n  if (recordType == 0) {\n    output._8_8_ = 0;\n    output._0_8_ = recordSize;\n    return output << 0x40;\n  }\n  if (recordSize != 0) {\n    if ((*(long *)(filePtr + 8) == 0) || (dataStructurePtr = *(long *)(filePtr + 0x10), dataStructurePtr == 0)) {\n      returnValue = dcgettext(0,\"debug_record_variable: no current file\",5);\n      fprintf(_stderr,\"%s\\n\",returnValue);\n    }\n    else {\n      if (variableType - 1U < 2) {\n        dataStructurePtr = dataStructurePtr + 0x10;\n        isNewVariable = (variableType == 1) + '\\x01';\n      }\n      else if (*(long *)(filePtr + 0x20) == 0) {\n        dataStructurePtr = dataStructurePtr + 0x10;\n        isNewVariable = '\\0';\n      }\n      else {\n        dataStructurePtr = *(long *)(filePtr + 0x20) + 0x28;\n        isNewVariable = '\\0';\n      }\n      dataStructurePtr = initialize_data_structure_00112925(dataStructurePtr,recordType,2,isNewVariable);\n      if (dataStructurePtr != 0) {\n        allocatedMemPtr = (int *)xmalloc(0x18);\n        piVar7 = allocatedMemPtr + 1;\n        for (loopCounter = 5; loopCounter != 0; loopCounter = loopCounter + -1) {\n          *piVar7 = 0;\n          piVar7 = piVar7 + (ulong)bVar * -2 + 1;\n        }\n        *allocatedMemPtr = variableType;\n        returnValue = 1;\n        *(ulong *)(allocatedMemPtr + 2) = recordSize;\n        *(undefined8 *)(allocatedMemPtr + 4) = param_5;\n        *(int **)(dataStructurePtr + 0x20) = allocatedMemPtr;\n        goto LAB_0010c12e;\n      }\n    }\n  }\n  returnValue = 0;\nLAB_0010c12e:\n  result._8_8_ = resultCode;\n  result._0_8_ = returnValue;\n  return result;\n}\n\n",
            "called": [
                "FUN_00112925",
                "fprintf",
                "xmalloc",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c05d",
            "calling": [
                "FUN_00112a33",
                "FUN_0011173a",
                "FUN_0010c139",
                "FUN_0010c1c6"
            ],
            "imported": false,
            "current_name": "record_variable_data_0010c05d"
        },
        "FUN_00109d97": {
            "renaming": {
                "FUN_00109d97": "initialize_or_increment_variable_00109d97",
                "param_1": "input",
                "lVar1": "count",
                "local_40": "formattedString"
            },
            "code": "\nvoid initializeOrIncrementVariable_00109d97(long input)\n\n{\n  long count;\n  char formattedString [40];\n  \n  if (*(long *)(input + 0x70) != 0) {\n    initialize_data_00109cf4(input,*(long *)(input + 0x70),0);\n    return;\n  }\n  count = *(long *)(input + 0x68);\n  *(long *)(input + 0x68) = count + 1;\n  sprintf(formattedString,\"%ld=%ld\",count,count);\n  allocate_and_initialize_data_00109b52(input,formattedString,count,0,0);\n  return;\n}\n\n",
            "called": [
                "FUN_00109cf4",
                "sprintf",
                "FUN_00109b52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109d97",
            "calling": [
                "FUN_00112c1f",
                "FUN_0010a424"
            ],
            "imported": false,
            "current_name": "initialize_or_increment_variable_00109d97"
        },
        "FUN_001086af": {
            "renaming": {
                "FUN_001086af": "parse_gnu_build_attribute_notes_001086af",
                "unaff_RBX": "num_records",
                "unaff_RBP": "max_desc_size",
                "unaff_R13": "max_name_size",
                "unaff_R12": "records",
                "unaff_retaddr": "version",
                "param_7": "name",
                "param_9": "version_number",
                "param_10": "description_size",
                "param_11": "sorted_records",
                "param_13": "tag_version",
                "param_14": "message_param",
                "in_RCX": "size",
                "in_stack_00000030": "output",
                "in_stack_00000038": "param_flags",
                "param_8": "version_note"
            },
            "code": "\nulong parse_gnu_build_attribute_notes_001086af(void)\n\n{\n  ulong uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  bool bVar4;\n  ulong *puVar5;\n  int iVar6;\n  long lVar7;\n  undefined8 uVar8;\n  ulong uVar9;\n  ulong uVar10;\n  ulong uVar11;\n  undefined *__ptr;\n  ulong size;\n  ulong uVar12;\n  ulong uVar13;\n  ulong uVar14;\n  ulong num_records;\n  ulong max_desc_size;\n  ulong *puVar15;\n  undefined *puVar16;\n  char cVar17;\n  undefined *puVar18;\n  undefined *puVar19;\n  ulong *records;\n  ulong max_name_size;\n  ulong uVar20;\n  size_t __nmemb;\n  undefined8 *unaff_R14;\n  ulong *puVar21;\n  byte bVar22;\n  int iVar23;\n  ulong version;\n  ulong name;\n  uint version_note;\n  ulong version_number;\n  ulong description_size;\n  ulong *sorted_records;\n  undefined *output;\n  uint param_flags;\n  uint tag_version;\n  undefined8 *message_param;\n  \n  bVar22 = 0;\n  name = size;\n  uVar9 = (**(code **)(unaff_R14[1] + 0x40))();\n  uVar10 = (**(code **)(unaff_R14[1] + 0x40))(records[4] + 4);\nLAB_0011662a:\n  uVar13 = max_desc_size;\n  uVar20 = max_name_size;\n  if (uVar10 < uVar9) {\n    uVar9 = uVar10;\n  }\n  do {\n    uVar11 = name;\n    uVar12 = name;\n    puVar15 = records;\n    if (records[2] == 0x100) {\n      if (uVar9 == 0) {\n        uVar9 = version;\n      }\n      uVar14 = *records;\n      records[7] = uVar9;\n      max_desc_size = uVar13;\n      max_name_size = uVar10;\n      version = uVar9;\n      if (uVar10 == 0) goto LAB_001164af;\n    }\n    else {\n      if (uVar9 == 0) {\n        uVar9 = version_number;\n      }\n      uVar14 = *records;\n      records[7] = uVar9;\n      max_desc_size = uVar10;\n      max_name_size = uVar20;\n      version_number = uVar9;\n      if (uVar10 == 0) goto LAB_0011669e;\n    }\nLAB_001164bb:\n    puVar15[8] = uVar10;\n    if (*(char *)((puVar15[3] - 1) + uVar14) != '\\0') {\n      lVar7 = dcgettext(0,\"corrupt GNU build attribute note: name not NUL terminated\",5);\n      goto LAB_0010849a;\n    }\n    records = puVar15 + 9;\n    if (num_records < 0xc) {\n      if (num_records != 0) {\n        lVar7 = dcgettext(0,\"corrupt GNU build attribute notes: excess data at end\",5);\n        goto LAB_0010849a;\n      }\n      if ((param_flags | tag_version | version_note) != 0) {\n        if (((tag_version | version_note) == 0) || (param_flags == 0)) {\n          if (tag_version == 0) {\n            if (version_note != 0) goto LAB_0011671b;\n            goto LAB_001166f8;\n          }\n          if (version_note == 0) goto LAB_001166f8;\n        }\n        lVar7 = dcgettext(0,\"bad GNU build attribute notes: multiple different versions\",5);\n        goto LAB_0010849a;\n      }\n      uVar2 = *unaff_R14;\n      uVar3 = *message_param;\n      uVar8 = dcgettext(0,\"%s[%s]: Warning: version note missing - assuming version 3\",5);\n      print_error_message_00119ed0(uVar8,uVar2,uVar3);\nLAB_0011671b:\n      __nmemb = ((long)records - (long)sorted_records >> 3) * -0x71c71c71c71c71c7;\n      qsort(sorted_records,__nmemb,0x48,compare_and_select_smaller_0011a1b0);\n      puVar15 = sorted_records;\n      goto LAB_001167f9;\n    }\n    uVar10 = (**(code **)(unaff_R14[1] + 0x40))(uVar12);\n    *records = uVar10;\n    uVar10 = (**(code **)(unaff_R14[1] + 0x40))(uVar12 + 4);\n    puVar15[10] = uVar10;\n    uVar9 = (**(code **)(unaff_R14[1] + 0x40))(uVar12 + 8);\n    uVar14 = *records;\n    puVar15[0xb] = uVar9;\n    uVar10 = puVar15[10];\n    uVar13 = uVar14 + 3 & 0xfffffffffffffffc;\n    puVar15[0xf] = uVar13;\n    if (uVar10 != (uVar10 + 3 & 0xfffffffffffffffc)) {\n      lVar7 = dcgettext(0,\"corrupt GNU build attribute note: description size not a factor of 4\",5);\n      goto LAB_0010849a;\n    }\n    if (1 < uVar9 - 0x100) {\n      lVar7 = dcgettext(0,\"corrupt GNU build attribute note: wrong note type\",5);\n      goto LAB_0010849a;\n    }\n    uVar11 = uVar13 + uVar10 + 0xc;\n    if (num_records < uVar11) {\n      lVar7 = dcgettext(0,\"corrupt GNU build attribute note: note too big\",5);\n      goto LAB_0010849a;\n    }\n    if (uVar14 < 2) {\n      lVar7 = dcgettext(0,\"corrupt GNU build attribute note: name too small\",5);\n      goto LAB_0010849a;\n    }\n    puVar15[0xc] = uVar12 + 0xc;\n    uVar1 = uVar12 + 0xc + uVar13;\n    puVar15[0xd] = uVar1;\n    num_records = num_records + (-0xc - (uVar13 + uVar10));\n    uVar11 = uVar12 + uVar11;\n    if (uVar14 != 2) {\n      if (*(char *)(uVar12 + 0xc) == '$') {\n        if ((*(char *)(uVar12 + 0xd) == '\\x01') && (*(char *)(uVar12 + 0xe) == '1')) {\n          uVar10 = parse_gnu_build_attribute_notes_001086af_00116490();\n          return uVar10;\n        }\n      }\n      else if ((((4 < uVar14) && (*(char *)(uVar12 + 0xc) == 'G')) &&\n               (*(char *)(uVar12 + 0xd) == 'A')) &&\n              ((*(char *)(uVar12 + 0xe) == '$' && (*(char *)(uVar12 + 0xf) == '\\x01')))) {\n        if (*(char *)(uVar12 + 0x10) == '2') {\n          uVar10 = parse_gnu_build_attribute_notes_001086af_00116490();\n          return uVar10;\n        }\n        if (*(char *)(uVar12 + 0x10) == '3') {\n          uVar10 = parse_gnu_build_attribute_notes_001086af_00116490();\n          return uVar10;\n        }\n        lVar7 = dcgettext(0,\"corrupt GNU build attribute note: unsupported version\",5);\n        goto LAB_0010849a;\n      }\n    }\n    uVar13 = max_desc_size;\n    uVar20 = max_name_size;\n    if (uVar10 == 0) {\n      if (uVar9 == 0x100) {\n        puVar15[0x10] = version;\nLAB_001164af:\n        uVar12 = uVar11;\n        uVar10 = uVar20;\n        puVar15 = records;\n        max_name_size = uVar20;\n      }\n      else {\n        puVar15[0x10] = version_number;\nLAB_0011669e:\n        max_desc_size = uVar13;\n        uVar12 = uVar11;\n        uVar10 = uVar13;\n        puVar15 = records;\n        max_name_size = uVar20;\n      }\n      goto LAB_001164bb;\n    }\n    if (uVar10 == 0x10) break;\n    if (0x10 < uVar10) {\nLAB_00116679:\n      lVar7 = dcgettext(0,\"corrupt GNU build attribute note: bad description size\",5);\nLAB_0010849a:\n      if (lVar7 != 0) {\n        bfd_set_error(0x11);\n        display_error_001126c0(0,unaff_R14,message_param,lVar7);\n        DAT_00127a20 = 1;\n      }\n      goto LAB_001166f8;\n    }\n    if (uVar10 != 4) {\n      if (uVar10 == 8) {\n        uVar10 = parse_gnu_build_attribute_notes_001086af();\n        return uVar10;\n      }\n      goto LAB_00116679;\n    }\n    name = uVar11;\n    uVar9 = (**(code **)(unaff_R14[1] + 0x40))();\n    uVar10 = 0xffffffffffffffff;\n  } while( true );\n  name = uVar11;\n  uVar9 = (**(code **)(unaff_R14[1] + 0x28))(uVar1);\n  uVar10 = (**(code **)(unaff_R14[1] + 0x28))();\n  goto LAB_0011662a;\nLAB_001167f9:\n  if (records <= puVar15) {\n    qsort(sorted_records,__nmemb,0x48,compare_records_0011a250);\n    __ptr = (undefined *)xmalloc(description_size * 2);\n    name = 0;\n    version_number = 0;\n    puVar19 = __ptr;\n    for (puVar15 = sorted_records; puVar15 < records; puVar15 = puVar15 + 9) {\n      if (puVar15[2] != 0) {\n        puVar18 = puVar19 + 4;\n        puVar16 = puVar19 + 0xc;\n        if ((puVar15[7] == version_number) && (puVar15[8] == name)) {\n          (**(code **)(unaff_R14[1] + 0x50))(*puVar15,puVar19);\n          (**(code **)(unaff_R14[1] + 0x50))(0,puVar18);\n          (**(code **)(unaff_R14[1] + 0x50))(puVar15[2],puVar19 + 8);\n          uVar9 = puVar15[6];\n          uVar10 = *puVar15;\n          puVar19 = (undefined *)puVar15[3];\n          puVar18 = puVar16;\n          for (uVar13 = uVar10; uVar13 != 0; uVar13 = uVar13 - 1) {\n            *puVar18 = *puVar19;\n            puVar19 = puVar19 + (ulong)bVar22 * -2 + 1;\n            puVar18 = puVar18 + (ulong)bVar22 * -2 + 1;\n          }\n          if (uVar10 < uVar9) {\n            for (lVar7 = uVar9 - uVar10; lVar7 != 0; lVar7 = lVar7 + -1) {\n              *puVar18 = 0;\n              puVar18 = puVar18 + (ulong)bVar22 * -2 + 1;\n            }\n          }\n          puVar19 = puVar16 + uVar9;\n        }\n        else {\n          (**(code **)(unaff_R14[1] + 0x50))();\n          if (*(int *)(unaff_R14[1] + 8) == 5) {\n            cVar17 = (*(char *)(unaff_R14[0x22] + 4) == '\\x02') * '\\b' + '\\b';\n          }\n          else {\n            cVar17 = '\\b';\n          }\n          (**(code **)(unaff_R14[1] + 0x50))(cVar17,puVar18);\n          (**(code **)(unaff_R14[1] + 0x50))(puVar15[2],puVar19 + 8);\n          uVar10 = *puVar15;\n          puVar19 = (undefined *)puVar15[3];\n          puVar18 = puVar16;\n          for (uVar9 = uVar10; uVar9 != 0; uVar9 = uVar9 - 1) {\n            *puVar18 = *puVar19;\n            puVar19 = puVar19 + (ulong)bVar22 * -2 + 1;\n            puVar18 = puVar18 + (ulong)bVar22 * -2 + 1;\n          }\n          uVar9 = puVar15[6];\n          if (uVar10 < uVar9) {\n            for (lVar7 = uVar9 - uVar10; lVar7 != 0; lVar7 = lVar7 + -1) {\n              *puVar18 = 0;\n              puVar18 = puVar18 + (ulong)bVar22 * -2 + 1;\n            }\n          }\n          lVar7 = unaff_R14[1];\n          puVar16 = puVar16 + uVar9;\n          puVar19 = puVar16 + 8;\n          if ((*(int *)(lVar7 + 8) == 5) && (*(char *)(unaff_R14[0x22] + 4) == '\\x02')) {\n            (**(code **)(lVar7 + 0x38))(puVar15[7],puVar16);\n            (**(code **)(unaff_R14[1] + 0x38))(puVar15[8],puVar19);\n            puVar19 = puVar16 + 0x10;\n          }\n          else {\n            (**(code **)(lVar7 + 0x50))(puVar15[7],puVar16);\n            (**(code **)(unaff_R14[1] + 0x50))(puVar15[8],puVar16 + 4);\n          }\n          version_number = puVar15[7];\n          name = puVar15[8];\n        }\n      }\n    }\n    uVar9 = (long)puVar19 - (long)__ptr;\n    uVar10 = uVar9;\n    puVar19 = __ptr;\n    if (uVar9 < description_size) {\n      for (; description_size = uVar9, uVar10 != 0; uVar10 = uVar10 - 1) {\n        *output = *puVar19;\n        puVar19 = puVar19 + (ulong)bVar22 * -2 + 1;\n        output = output + (ulong)bVar22 * -2 + 1;\n      }\n    }\n    free(__ptr);\nLAB_001166f8:\n    free(sorted_records);\n    return description_size;\n  }\n  if (puVar15[2] != 0) {\n    uVar10 = puVar15[7];\n    uVar9 = puVar15[8];\n    uVar13 = puVar15[2];\n    puVar21 = puVar15;\n    iVar23 = 0;\n    if (uVar10 == uVar9) {\n      puVar15[2] = 0;\n    }\n    else {\n      do {\n        do {\n          puVar5 = puVar21;\n          puVar21 = puVar5 + -9;\n          if (puVar21 < sorted_records) goto LAB_001167f5;\n          uVar20 = puVar5[-7];\n        } while (uVar20 == 0);\n        name = uVar13;\n        if ((*puVar21 != *puVar15) ||\n           (iVar6 = memcmp((void *)puVar5[-6],(void *)puVar15[3],*puVar15), iVar6 != 0)) break;\n        uVar13 = puVar5[-2];\n        uVar11 = puVar5[-1];\n        if (uVar10 == uVar13) {\n          if (uVar9 == uVar11) {\n            puVar15[2] = 0;\n            break;\n          }\nLAB_001167a6:\n          if (uVar9 <= uVar11) {\n            puVar15[2] = 0;\n            break;\n          }\n          if (uVar11 < uVar10) {\nLAB_0010852c:\n            if ((0xfffffffffffffff0 < uVar11) || (uVar10 <= (uVar11 + 0xf & 0xfffffffffffffff0)))\n            goto process_data_00116852;\n          }\nLAB_001167b8:\n          if ((name == 0x101) == (uVar20 == 0x101)) {\n            if (uVar11 <= uVar9) {\n              uVar11 = uVar9;\n            }\n            if (uVar13 < uVar10) {\n              uVar10 = uVar13;\n            }\n            puVar5[-1] = uVar11;\n            puVar5[-2] = uVar10;\n            puVar15[2] = 0;\n            break;\n          }\n        }\n        else {\n          if (uVar13 <= uVar10) goto LAB_001167a6;\n          if (uVar11 < uVar10) goto LAB_0010852c;\n          if (uVar9 < uVar10) {\n            if ((0xfffffffffffffff0 < uVar9) || (uVar13 <= (uVar9 + 0xf & 0xfffffffffffffff0)))\n            goto process_data_00116852;\n            goto LAB_001167b8;\n          }\n          if (uVar9 != uVar11) goto LAB_001167b8;\n        }\nprocess_data_00116852:\n        bVar4 = iVar23 < 0x11;\n        uVar13 = name;\n        iVar23 = iVar23 + 1;\n      } while (bVar4);\n    }\n  }\nLAB_001167f5:\n  puVar15 = puVar15 + 9;\n  goto LAB_001167f9;\n}\n\n",
            "called": [
                "FUN_0011a1b0",
                "qsort",
                "FUN_00116490",
                "dcgettext",
                "FUN_00119ed0",
                "FUN_001126c0",
                "FUN_0010847a",
                "bfd_set_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001086af",
            "calling": [
                "FUN_00116490"
            ],
            "imported": false,
            "current_name": "parse_gnu_build_attribute_notes_001086af"
        },
        "bfd_octets_per_byte": {
            "renaming": {},
            "code": "\nvoid bfd_octets_per_byte(void)\n\n{\n  bfd_octets_per_byte();\n  return;\n}\n\n",
            "called": [
                "bfd_octets_per_byte"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104520",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_octets_per_byte"
        },
        "FUN_0010add5": {
            "renaming": {
                "FUN_0010add5": "initialize_string_data_0010add5",
                "format_and_store_string_data_0010abdd": "formatAndStoreStringData"
            },
            "code": "\nvoid initializeStringData_0010add5(void)\n\n{\n  formatAndStoreStringData();\n  return;\n}\n\n",
            "called": [
                "FUN_0010abdd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010add5",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "initialize_string_data_0010add5"
        },
        "FUN_00113e17": {
            "renaming": {
                "FUN_00113e17": "initialize_data_00113e17",
                "initialize_data_00112904": "dataInitializer"
            },
            "code": "\nvoid initializeData_00113e17(void)\n\n{\n  dataInitializer(2,0);\n  return;\n}\n\n",
            "called": [
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113e17",
            "calling": [
                "FUN_0010c2d2",
                "FUN_0010c95e",
                "FUN_0010ee3f",
                "FUN_0010b0fa",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "initialize_data_00113e17"
        },
        "FUN_00109b52": {
            "renaming": {
                "FUN_00109b52": "allocate_and_initialize_data_00109b52",
                "param_1": "input_data",
                "param_2": "str_param",
                "param_3": "data_param",
                "param_4": "char_param",
                "param_5": "int_param",
                "uVar1": "temp_var1",
                "puVar2": "allocated_data",
                "uVar3": "duplicated_str",
                "xmalloc": "allocate_memory",
                "xstrdup": "duplicate_string"
            },
            "code": "\nundefined allocate_and_initialize_data_00109b52(long input_data,undefined8 str_param,undefined8 data_param,undefined char_param,\n                      undefined4 int_param)\n\n{\n  undefined8 temp_var1;\n  undefined8 *allocated_data;\n  undefined8 duplicated_str;\n  \n  allocated_data = (undefined8 *)xmalloc(0x40);\n  duplicated_str = xstrdup(str_param);\n  allocated_data[2] = data_param;\n  *(undefined (*) [16])(allocated_data + 4) = ZEXT816(0);\n  *(undefined (*) [16])(allocated_data + 6) = ZEXT816(0);\n  temp_var1 = *(undefined8 *)(input_data + 0x60);\n  *(undefined *)((long)allocated_data + 0x1c) = char_param;\n  *(undefined4 *)(allocated_data + 3) = int_param;\n  *(undefined8 **)(input_data + 0x60) = allocated_data;\n  *allocated_data = temp_var1;\n  allocated_data[1] = duplicated_str;\n  return 1;\n}\n\n",
            "called": [
                "xstrdup",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109b52",
            "calling": [
                "FUN_00109cf4",
                "FUN_0010a0e9",
                "FUN_0010a181",
                "FUN_00109d97",
                "FUN_0010a77a",
                "FUN_00109e76",
                "FUN_0010a424",
                "FUN_0010a377",
                "FUN_0010e453",
                "FUN_0010b948",
                "FUN_00109dfe",
                "FUN_0010a69a",
                "FUN_0010a2b9",
                "FUN_0010b800",
                "FUN_00109ed3"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_data_00109b52"
        },
        "FUN_00109a32": {
            "renaming": {
                "FUN_00109a32": "parse_strtoul_and_check_overflow_00109a32",
                "param_1": "string_ptr",
                "param_2": "error_flag_ptr",
                "param_3": "end_ptr",
                "param_4": "unknown_param_4",
                "param_5": "unknown_param_5",
                "__nptr": "current_ptr",
                "piVar1": "errno_ptr",
                "uVar2": "converted_value",
                "uVar3": "error_msg",
                "auVar4": "result"
            },
            "code": "\nundefined  [16]\nparse_strtoul_and_check_overflow_00109a32(char **string_ptr,undefined *error_flag_ptr,char *end_ptr,undefined8 unknown_param_4,undefined8 unknown_param_5)\n\n{\n  char *current_ptr;\n  int *errno_ptr;\n  ulong converted_value;\n  undefined8 error_msg;\n  undefined result [16];\n  \n  if (error_flag_ptr != (undefined *)0x0) {\n    *error_flag_ptr = 0;\n  }\n  current_ptr = *string_ptr;\n  if ((current_ptr < end_ptr) && (*current_ptr != '\\0')) {\n    errno_ptr = __errno_location();\n    *errno_ptr = 0;\n    converted_value = strtoul(current_ptr,string_ptr,0);\n    if ((converted_value != 0xffffffffffffffff) || (*errno_ptr == 0)) goto LAB_00109aa9;\n    if (error_flag_ptr == (undefined *)0x0) {\n      error_msg = dcgettext(0,\"numeric overflow\",5);\n      print_warning_00108fe8(current_ptr,error_msg);\n    }\n    else {\n      *error_flag_ptr = 1;\n    }\n  }\n  converted_value = 0;\nLAB_00109aa9:\n  result._8_8_ = unknown_param_5;\n  result._0_8_ = converted_value;\n  return result;\n}\n\n",
            "called": [
                "__errno_location",
                "FUN_00108fe8",
                "dcgettext",
                "strtoul"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109a32",
            "calling": [
                "FUN_0010ee3f",
                "FUN_00109ab1"
            ],
            "imported": false,
            "current_name": "parse_strtoul_and_check_overflow_00109a32"
        },
        "FUN_0010c6be": {
            "renaming": {
                "FUN_0010c6be": "process_debug_tag_0010c6be",
                "param_1": "filePointer",
                "param_2": "tagName",
                "param_3": "debugTag",
                "iVar1": "comparisonResult",
                "uVar2": "translatedString",
                "piVar3": "initializedData",
                "pauVar4": "dataArray",
                "lVar5": "offset",
                "pcVar6": "errorMessage"
            },
            "code": "\n\n\nint * processDebugTag_0010c6be(long filePointer,char *tagName,int *debugTag)\n\n{\n  int comparisonResult;\n  undefined8 translatedString;\n  int *initializedData;\n  undefined (*dataArray) [16];\n  long offset;\n  char *errorMessage;\n  \n  if ((tagName != (char *)0x0) && (debugTag != (int *)0x0)) {\n    if (*(long *)(filePointer + 0x10) == 0) {\n      errorMessage = \"debug_tag_type: no current file\";\n    }\n    else {\n      if (*debugTag != 0x17) {\n        initializedData = (int *)initialize_data_00112904(0x17,0);\n        if (initializedData == (int *)0x0) {\n          return (int *)0x0;\n        }\n        dataArray = (undefined (*) [16])xmalloc(0x10);\n        offset = *(long *)(filePointer + 0x10);\n        *dataArray = ZEXT816(0);\n        *(int **)(*dataArray + 8) = debugTag;\n        *(undefined (**) [16])(initializedData + 4) = dataArray;\n        offset = initialize_data_structure_00112925(offset + 0x10,tagName,1,3);\n        if (offset == 0) {\n          return (int *)0x0;\n        }\n        *(int **)(offset + 0x20) = initializedData;\n        *(long *)*dataArray = offset;\n        return initializedData;\n      }\n      comparisonResult = strcmp(*(char **)(**(long **)(debugTag + 4) + 8),tagName);\n      errorMessage = \"debug_tag_type: extra tag attempted\";\n      if (comparisonResult == 0) {\n        return debugTag;\n      }\n    }\n    translatedString = dcgettext(0,errorMessage,5);\n    fprintf(_stderr,\"%s\\n\",translatedString);\n  }\n  return (int *)0x0;\n}\n\n",
            "called": [
                "strcmp",
                "FUN_00112925",
                "fprintf",
                "dcgettext",
                "xmalloc",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c6be",
            "calling": [
                "FUN_00112a33",
                "FUN_0011173a",
                "FUN_0010c892"
            ],
            "imported": false,
            "current_name": "process_debug_tag_0010c6be"
        },
        "exit": {
            "renaming": {},
            "code": "\n\n\nvoid exit(int __status)\n\n{\n                    \n  exit(__status);\n}\n\n",
            "called": [
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047f0",
            "calling": [
                "FUN_00119970",
                "FUN_00108a2a",
                "FUN_00108916"
            ],
            "imported": false,
            "current_name": "exit"
        },
        "FUN_0010b6ea": {
            "renaming": {
                "FUN_0010b6ea": "extract_arglist_demangled_values_0010b6ea",
                "param_1": "ptr_param_1",
                "param_2": "ptr_param_2",
                "param_3": "ptr_arglist",
                "param_4": "ptr_error",
                "__ptr": "result_array",
                "__format": "error_message",
                "lVar1": "demangled_value",
                "uVar2": "value_count",
                "uVar3": "array_size",
                "uVar4": "index",
                "local_39": "temp_buffer"
            },
            "code": "\n\n\nvoid * extract_arglist_demangled_values_0010b6ea(undefined8 ptr_param_1,undefined8 ptr_param_2,int *ptr_arglist,undefined *ptr_error)\n\n{\n  void *result_array;\n  char *error_message;\n  long demangled_value;\n  ulong value_count;\n  ulong array_size;\n  uint index;\n  char temp_buffer [9];\n  \n  array_size = 10;\n  value_count = 0;\n  result_array = (void *)xmalloc(0x50);\n  *ptr_error = 0;\n  for (; ptr_arglist != (int *)0x0; ptr_arglist = *(int **)(ptr_arglist + 6)) {\n    if (*ptr_arglist != 0x2e) {\n      error_message = (char *)dcgettext(0,\"Unexpected type in v3 arglist demangling\\n\",5);\n      fprintf(_stderr,error_message);\n      free(result_array);\n      return (void *)0x0;\n    }\n    if (*(long *)(ptr_arglist + 4) == 0) break;\n    demangled_value = extract_and_initialize_data_0010b0fa(ptr_param_1,ptr_param_2,*(long *)(ptr_arglist + 4),0,temp_buffer);\n    if (demangled_value == 0) {\n      if (temp_buffer[0] == '\\0') {\n        free(result_array);\n        return (void *)0x0;\n      }\n      *ptr_error = 1;\n    }\n    else {\n      index = (int)value_count + 1;\n      if ((uint)array_size <= index) {\n        array_size = (ulong)((uint)array_size + 10);\n        result_array = (void *)xrealloc(result_array,array_size << 3);\n      }\n      *(long *)((long)result_array + value_count * 8) = demangled_value;\n      value_count = (ulong)index;\n    }\n  }\n  *(undefined8 *)((long)result_array + value_count * 8) = 0;\n  return result_array;\n}\n\n",
            "called": [
                "xrealloc",
                "fprintf",
                "free",
                "dcgettext",
                "FUN_0010b0fa",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010b6ea",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010b0fa"
            ],
            "imported": false,
            "current_name": "extract_arglist_demangled_values_0010b6ea",
            "code_backup": "\n\n\nvoid * FUN_0010b6ea(undefined8 param_1,undefined8 param_2,int *param_3,undefined *param_4)\n\n{\n  void *__ptr;\n  char *__format;\n  long lVar1;\n  ulong uVar2;\n  ulong uVar3;\n  uint uVar4;\n  char local_39 [9];\n  \n  uVar3 = 10;\n  uVar2 = 0;\n  __ptr = (void *)xmalloc(0x50);\n  *param_4 = 0;\n  for (; param_3 != (int *)0x0; param_3 = *(int **)(param_3 + 6)) {\n    if (*param_3 != 0x2e) {\n      __format = (char *)dcgettext(0,\"Unexpected type in v3 arglist demangling\\n\",5);\n      fprintf(_stderr,__format);\n      free(__ptr);\n      return (void *)0x0;\n    }\n    if (*(long *)(param_3 + 4) == 0) break;\n    lVar1 = FUNC_0010b0fa(param_1,param_2,*(long *)(param_3 + 4),0,local_39);\n    if (lVar1 == 0) {\n      if (local_39[0] == '\\0') {\n        free(__ptr);\n        return (void *)0x0;\n      }\n      *param_4 = 1;\n    }\n    else {\n      uVar4 = (int)uVar2 + 1;\n      if ((uint)uVar3 <= uVar4) {\n        uVar3 = (ulong)((uint)uVar3 + 10);\n        __ptr = (void *)xrealloc(__ptr,uVar3 << 3);\n      }\n      *(long *)((long)__ptr + uVar2 * 8) = lVar1;\n      uVar2 = (ulong)uVar4;\n    }\n  }\n  *(undefined8 *)((long)__ptr + uVar2 * 8) = 0;\n  return __ptr;\n}\n\n"
        },
        "FUN_0011a2e0": {
            "renaming": {
                "FUN_0011a2e0": "update_section_info_0011a2e0",
                "param_1": "sectionInfo",
                "param_2": "binary",
                "uVar1": "errorSection",
                "uVar2": "errorString",
                "lVar3": "newSectionInfo",
                "lVar4": "sectionByName"
            },
            "code": "\nlong updateSectionInfo_0011a2e0(long sectionInfo,long binary)\n\n{\n  undefined8 errorSection;\n  undefined8 errorString;\n  long newSectionInfo;\n  long sectionByName;\n  \n  newSectionInfo = (**(code **)(*(long *)(binary + 8) + 0x208))(binary);\n  sectionByName = *(long *)(sectionInfo + 0x20);\n  *(undefined8 *)(newSectionInfo + 8) = *(undefined8 *)(sectionInfo + 8);\n  *(undefined8 *)(newSectionInfo + 0x10) = *(undefined8 *)(sectionInfo + 0x10);\n  *(undefined4 *)(newSectionInfo + 0x18) = *(undefined4 *)(sectionInfo + 0x18);\n  if (sectionByName == 0) {\n    sectionByName = 0x128598;\n  }\n  else {\n    sectionByName = bfd_get_section_by_name(binary);\n    if (sectionByName == 0) {\n      errorSection = *(undefined8 *)(sectionInfo + 0x20);\n      errorString = dcgettext(0,\"Section %s not found\",5);\n                    \n      print_error_and_exit_00119dd0(errorString,errorSection);\n    }\n  }\n  *(long *)(newSectionInfo + 0x20) = sectionByName;\n  return newSectionInfo;\n}\n\n",
            "called": [
                "bfd_get_section_by_name",
                "FUN_00108808"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a2e0",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "update_section_info_0011a2e0"
        },
        "FUN_0010e8a9": {
            "renaming": {
                "FUN_0010e8a9": "process_and_check_string_0010e8a9",
                "param_1": "input_string",
                "param_2": "output_string",
                "param_3": "additional_data",
                "uVar1": "result",
                "sVar2": "additional_data_length",
                "__s": "extended_string"
            },
            "code": "\nundefined4 process_and_check_string_0010e8a9(undefined8 input_string,undefined8 output_string,char *additional_data)\n\n{\n  undefined4 result;\n  size_t additional_data_length;\n  char *extended_string;\n  \n  additional_data_length = strlen(additional_data);\n  extended_string = (char *)xmalloc(additional_data_length + 0x14);\n  sprintf(extended_string,\"%s:c=f%g\",input_string,additional_data);\n  result = process_string_0010e2f0(output_string,0x80,0,0,extended_string);\n  if ((char)result != '\\0') {\n    free(extended_string);\n  }\n  return result;\n}\n\n",
            "called": [
                "strlen",
                "free",
                "xmalloc",
                "sprintf",
                "FUN_0010e2f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e8a9",
            "calling": [
                "FUN_001135a5"
            ],
            "imported": false,
            "current_name": "process_and_check_string_0010e8a9"
        },
        "FUN_00104ad6": {
            "renaming": {
                "FUN_00104ad6": "parse_section_flags_00104ad6",
                "unaff_RBP": "currentFlag",
                "__s": "sectionFlag",
                "sVar4": "flagLength",
                "iVar5": "flagLengthInt",
                "unaff_R14D": "sectionFlags",
                "unaff_R15": "currentSection",
                "auVar6": "result",
                "unaff_retaddr": "returnAddress",
                "iVar1": "comparisonResult",
                "pcVar3": "commaPosition",
                "uVar2": "errorMessage"
            },
            "code": "\nundefined  [16] parseSectionFlags_00104ad6(void)\n\n{\n  int comparisonResult;\n  undefined8 errorMessage;\n  char *commaPosition;\n  char *currentFlag;\n  char *sectionFlag;\n  size_t flagLength;\n  int flagLengthInt;\n  uint sectionFlags;\n  char *currentSection;\n  undefined result [16];\n  undefined8 returnAddress;\n  \n  do {\n    sectionFlags = sectionFlags | 0x2000;\n    sectionFlag = currentFlag;\n    while( true ) {\n      while( true ) {\n        while( true ) {\n          while( true ) {\n            while( true ) {\n              if (sectionFlag == (char *)0x0) {\n                result._4_4_ = 0;\n                result._0_4_ = sectionFlags;\n                result._8_8_ = returnAddress;\n                return result;\n              }\n              commaPosition = strchr(sectionFlag,0x2c);\n              if (commaPosition == (char *)0x0) {\n                flagLength = strlen(sectionFlag);\n                flagLengthInt = (int)flagLength;\n                currentFlag = (char *)0x0;\n              }\n              else {\n                currentFlag = commaPosition + 1;\n                flagLengthInt = (int)commaPosition - (int)sectionFlag;\n              }\n              flagLength = (size_t)flagLengthInt;\n              comparisonResult = strncasecmp(currentSection,sectionFlag,flagLength);\n              if (comparisonResult != 0) break;\n              sectionFlags = sectionFlags | 1;\n              sectionFlag = currentFlag;\n            }\n            comparisonResult = strncasecmp(\"load\",sectionFlag,flagLength);\n            if (comparisonResult != 0) break;\n            sectionFlags = sectionFlags | 2;\n            sectionFlag = currentFlag;\n          }\n          comparisonResult = strncasecmp(\"noload\",sectionFlag,flagLength);\n          if (comparisonResult != 0) break;\n          sectionFlags = sectionFlags | 0x200;\n          sectionFlag = currentFlag;\n        }\n        comparisonResult = strncasecmp(\"readonly\",sectionFlag,flagLength);\n        if (comparisonResult != 0) break;\n        sectionFlags = sectionFlags | 8;\n        sectionFlag = currentFlag;\n      }\n      comparisonResult = strncasecmp(\"debug\",sectionFlag,flagLength);\n      if (comparisonResult == 0) break;\n      comparisonResult = strncasecmp(\"code\",sectionFlag,flagLength);\n      if (comparisonResult == 0) {\n        sectionFlags = sectionFlags | 0x10;\n        sectionFlag = currentFlag;\n      }\n      else {\n        comparisonResult = strncasecmp(\"data\",sectionFlag,flagLength);\n        if (comparisonResult == 0) {\n          sectionFlags = sectionFlags | 0x20;\n          sectionFlag = currentFlag;\n        }\n        else {\n          comparisonResult = strncasecmp(\"rom\",sectionFlag,flagLength);\n          if (comparisonResult == 0) {\n            sectionFlags = sectionFlags | 0x40;\n            sectionFlag = currentFlag;\n          }\n          else {\n            comparisonResult = strncasecmp(\"exclude\",sectionFlag,flagLength);\n            if (comparisonResult == 0) {\n              sectionFlags = sectionFlags | 0x8000;\n              sectionFlag = currentFlag;\n            }\n            else {\n              comparisonResult = strncasecmp(\"share\",sectionFlag,flagLength);\n              if (comparisonResult == 0) {\n                sectionFlags = sectionFlags | 0x8000000;\n                sectionFlag = currentFlag;\n              }\n              else {\n                comparisonResult = strncasecmp(\"contents\",sectionFlag,flagLength);\n                if (comparisonResult == 0) {\n                  sectionFlags = sectionFlags | 0x100;\n                  sectionFlag = currentFlag;\n                }\n                else {\n                  comparisonResult = strncasecmp(\"merge\",sectionFlag,flagLength);\n                  if (comparisonResult == 0) {\n                    sectionFlags = sectionFlags | 0x800000;\n                    sectionFlag = currentFlag;\n                  }\n                  else {\n                    comparisonResult = strncasecmp(\"strings\",sectionFlag,flagLength);\n                    if (comparisonResult != 0) {\n                      commaPosition = (char *)xmalloc((long)(flagLengthInt + 1));\n                      strncpy(commaPosition,sectionFlag,flagLength);\n                      commaPosition[flagLength] = '\\0';\n                      errorMessage = dcgettext(0,\"unrecognized section flag `%s\\'\",5);\n                      print_error_message_00119ed0(errorMessage,commaPosition);\n                      errorMessage = dcgettext(0,\"supported flags: %s\",5);\n                    \n                      print_error_and_exit_00119dd0(errorMessage,\n                                   \"alloc, load, noload, readonly, debug, code, data, rom, exclude, share, contents, merge, strings\"\n                                  );\n                    }\n                    sectionFlags = sectionFlags | 0x1000000;\n                    sectionFlag = currentFlag;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } while( true );\n}\n\n",
            "called": [
                "strncasecmp",
                "FUN_00104ad6",
                "FUN_00119dd0",
                "strncpy",
                "strlen",
                "dcgettext",
                "strchr",
                "xmalloc",
                "FUN_00119ed0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104ad6",
            "calling": [
                "FUN_00104ad6"
            ],
            "imported": false,
            "current_name": "parse_section_flags_00104ad6"
        },
        "htab_find": {
            "renaming": {},
            "code": "\nvoid htab_find(void)\n\n{\n  htab_find();\n  return;\n}\n\n",
            "called": [
                "htab_find"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047d0",
            "calling": [
                "FUN_0010554f",
                "FUN_00115d70",
                "FUN_00108d9a"
            ],
            "imported": false,
            "current_name": "htab_find"
        },
        "FUN_001087da": {
            "renaming": {
                "FUN_001087da": "check_rax_value_001087da",
                "in_RAX": "inputValue",
                "auVar1": "result",
                "unaff_retaddr": "returnAddress"
            },
            "code": "\nundefined  [16] checkRAXValue_001087da(void)\n\n{\n  long inputValue;\n  undefined result [16];\n  undefined8 returnAddress;\n  \n  result._1_7_ = 0;\n  result[0] = inputValue == 0x100;\n  result._8_8_ = returnAddress;\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001087da",
            "calling": [
                "FUN_0011a1b0"
            ],
            "imported": false,
            "current_name": "check_rax_value_001087da"
        },
        "__assert_fail": {
            "renaming": {},
            "code": "\n\n\nvoid __assert_fail(char *__assertion,char *__file,uint __line,char *__function)\n\n{\n                    \n  __assert_fail(__assertion,__file,__line,__function);\n}\n\n",
            "called": [
                "__assert_fail"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104300",
            "calling": [
                "FUN_0010c7a0",
                "FUN_0010bbd3",
                "FUN_00112c1f",
                "FUN_001125fa"
            ],
            "imported": false,
            "current_name": "__assert_fail"
        },
        "FUN_0010914e": {
            "renaming": {
                "FUN_0010914e": "find_named_type_0010914e",
                "param_1": "compilation_unit",
                "param_2": "type_name",
                "param_3": "unknown_value_1",
                "param_4": "unknown_value_2",
                "lVar1": "current_unit_data",
                "iVar2": "comparison_result",
                "uVar3": "error_message",
                "puVar4": "current_ptr",
                "lVar5": "data_ptr",
                "puVar6": "unit_ptr"
            },
            "code": "\n\n\nundefined  [16] find_named_type_0010914e(long compilation_unit,char *type_name,undefined8 unknown_value_1,undefined8 unknown_value_2)\n\n{\n  long current_unit_data;\n  int comparison_result;\n  undefined8 error_message;\n  undefined8 *current_ptr;\n  long data_ptr;\n  undefined8 *unit_ptr;\n  undefined auVar7 [16];\n  \n  current_unit_data = *(long *)(compilation_unit + 8);\n  if (current_unit_data == 0) {\n    error_message = dcgettext(0,\"debug_find_named_type_0010914e: no current compilation unit\",5);\n    fprintf(_stderr,\"%s\\n\",error_message);\n  }\n  else {\n    for (data_ptr = *(long *)(compilation_unit + 0x20); data_ptr != 0; data_ptr = *(long *)(data_ptr + 8)) {\n      if (*(undefined8 **)(data_ptr + 0x28) != (undefined8 *)0x0) {\n        for (current_ptr = (undefined8 *)**(undefined8 **)(data_ptr + 0x28); current_ptr != (undefined8 *)0x0;\n            current_ptr = (undefined8 *)*current_ptr) {\n          if (*(int *)((long)current_ptr + 0x14) == 0) {\n            if (*(char *)current_ptr[1] == *type_name) {\n              comparison_result = strcmp((char *)current_ptr[1],type_name);\n              if (comparison_result == 0) goto LAB_00109216;\n            }\n          }\n        }\n      }\n    }\n    for (unit_ptr = *(undefined8 **)(current_unit_data + 8); unit_ptr != (undefined8 *)0x0;\n        unit_ptr = (undefined8 *)*unit_ptr) {\n      if ((undefined8 *)unit_ptr[2] != (undefined8 *)0x0) {\n        for (current_ptr = *(undefined8 **)(undefined8 *)unit_ptr[2]; current_ptr != (undefined8 *)0x0;\n            current_ptr = (undefined8 *)*current_ptr) {\n          if (*(int *)((long)current_ptr + 0x14) == 0) {\n            if (*(char *)current_ptr[1] == *type_name) {\n              comparison_result = strcmp((char *)current_ptr[1],type_name);\n              if (comparison_result == 0) goto LAB_00109216;\n            }\n          }\n        }\n      }\n    }\n  }\n  error_message = 0;\nLAB_00109223:\n  auVar7._8_8_ = unknown_value_2;\n  auVar7._0_8_ = error_message;\n  return auVar7;\nLAB_00109216:\n  error_message = current_ptr[4];\n  goto LAB_00109223;\n}\n\n",
            "called": [
                "strcmp",
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010914e",
            "calling": [
                "FUN_0010d559",
                "FUN_0010c95e",
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "find_named_type_0010914e"
        },
        "FUN_0010829e": {
            "renaming": {
                "FUN_0010829e": "determine_action_based_on_input_0010829e",
                "unaff_EBP": "input",
                "uVar1": "result"
            },
            "code": "\nundefined8 determineActionBasedOnInput_0010829e(void)\n\n{\n  undefined8 result;\n  int input;\n  \n  if (input == 5) {\n    result = check_string_length_00113ede();\n    return result;\n  }\n  if ((input != 4) && (input == 6)) {\n    result = check_and_invert_string_length_001082b3();\n    return result;\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00113ede",
                "FUN_001082b3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010829e",
            "calling": [
                "FUN_00115b70"
            ],
            "imported": false,
            "current_name": "determine_action_based_on_input_0010829e"
        },
        "bfd_set_error": {
            "renaming": {},
            "code": "\nvoid bfd_set_error(void)\n\n{\n  bfd_set_error();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043a0",
            "calling": [
                "FUN_0010554f",
                "FUN_001086af",
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "bfd_set_error"
        },
        "bindtextdomain": {
            "renaming": {},
            "code": "\nvoid bindtextdomain(void)\n\n{\n  bindtextdomain();\n  return;\n}\n\n",
            "called": [
                "bindtextdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104220",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "bindtextdomain"
        },
        "filename_cmp": {
            "renaming": {},
            "code": "\nvoid filename_cmp(void)\n\n{\n  filename_cmp();\n  return;\n}\n\n",
            "called": [
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001041a0",
            "calling": [
                "FUN_00116b90",
                "FUN_00108f08",
                "FUN_0010edb4"
            ],
            "imported": false,
            "current_name": "filename_cmp"
        },
        "FUN_00104943": {
            "renaming": {
                "FUN_00104943": "print_binary_info_00104943",
                "in_RAX": "binaryPath",
                "lVar3": "convertedValue",
                "iVar1": "defaultValue",
                "iVar2": "archIndex",
                "pcVar5": "archString",
                "uVar6": "printableArch",
                "iVar7": "archIterator",
                "lVar8": "fileIndex",
                "iVar9": "rowIndex",
                "unaff_R15D": "columnIndex",
                "uVar10": "stringLength",
                "uVar11": "archOffset",
                "param_7": "maxRows",
                "uStack000000000000000c": "paddingWidth",
                "param_11": "binaryData",
                "param_13": "fileData"
            },
            "code": "\n\n\nvoid printBinaryInfo_00104943(void)\n\n{\n  int defaultValue;\n  int archIndex;\n  char *binaryPath;\n  long convertedValue;\n  size_t sVar4;\n  char *archString;\n  undefined8 printableArch;\n  int archIterator;\n  long fileIndex;\n  int rowIndex;\n  uint columnIndex;\n  ulong stringLength;\n  uint archOffset;\n  int maxRows;\n  uint paddingWidth;\n  undefined8 binaryData;\n  long fileData;\n  \n  convertedValue = strtol(binaryPath,(char **)0x0,10);\n  defaultValue = (int)convertedValue;\n  rowIndex = maxRows;\n  paddingWidth = columnIndex;\n  if (defaultValue == 0) {\n    defaultValue = 0x50;\n  }\n  do {\n    maxRows = rowIndex;\n    if (binaryData._4_4_ <= maxRows) {\n      return;\n    }\n    fileIndex = (long)maxRows;\n    archIterator = (defaultValue - paddingWidth) + -1;\n    convertedValue = fileIndex;\n    do {\n      rowIndex = (int)convertedValue;\n      if (binaryData._4_4_ <= rowIndex) break;\n      sVar4 = strlen(*(char **)(fileData + convertedValue * 0x60));\n      convertedValue = convertedValue + 1;\n      archIterator = (archIterator - (int)sVar4) + -1;\n    } while (-1 < archIterator);\n    printf(\"\\n%*s\",(ulong)(paddingWidth + 1),&DAT_0011b4a1);\n    for (convertedValue = fileIndex * 0x60; ((ulong)(uint)(rowIndex - maxRows) + fileIndex) * 0x60 - convertedValue != 0;\n        convertedValue = convertedValue + 0x60) {\n      printf(\"%s \",*(undefined8 *)(fileData + convertedValue));\n    }\n    archIterator = 2;\n    putc(10,_stdout);\n    do {\n      archString = (char *)bfd_printable_arch_mach(archIterator,0);\n      archIndex = strcmp(archString,\"UNKNOWN!\");\n      if (archIndex != 0) {\n        printableArch = bfd_printable_arch_mach(archIterator,0);\n        printf(\"%*s \",(ulong)paddingWidth,printableArch);\n        archOffset = archIterator - 2;\n        convertedValue = fileIndex * 0x60;\n        archIndex = maxRows;\n        while (rowIndex != archIndex) {\n          archString = *(char **)(fileData + convertedValue);\n          if (*(char *)((long)(char **)(fileData + convertedValue) + (ulong)archOffset + 8) == '\\0') {\n            sVar4 = strlen(archString);\n            for (stringLength = sVar4 & 0xffffffff; (int)stringLength != 0; stringLength = (ulong)((int)stringLength - 1)) {\n              putc(0x2d,_stdout);\n            }\n          }\n          else {\n            fputs(archString,_stdout);\n          }\n          archIndex = archIndex + 1;\n          if (rowIndex != archIndex) {\n            putc(0x20,_stdout);\n          }\n          convertedValue = convertedValue + 0x60;\n        }\n        putc(10,_stdout);\n      }\n      archIterator = archIterator + 1;\n    } while (archIterator != 0x57);\n  } while( true );\n}\n\n",
            "called": [
                "strcmp",
                "fputs",
                "strlen",
                "bfd_printable_arch_mach",
                "strtol",
                "printf",
                "putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104943",
            "calling": [
                "FUN_001199d0"
            ],
            "imported": false,
            "current_name": "print_binary_info_00104943"
        },
        "bfd_set_error_program_name": {
            "renaming": {},
            "code": "\nvoid bfd_set_error_program_name(void)\n\n{\n  bfd_set_error_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001046e0",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "bfd_set_error_program_name"
        },
        "FUN_00113e23": {
            "renaming": {
                "FUN_00113e23": "initialize_data_00113e23",
                "param_1": "data_1",
                "param_2": "data_2",
                "lVar1": "initialized_data",
                "puVar2": "allocated_data"
            },
            "code": "\nlong initialize_data_00113e23(undefined8 data_1,undefined8 data_2)\n\n{\n  long initialized_data;\n  undefined8 *allocated_data;\n  \n  initialized_data = initialize_data_00113e23_00112904(1,0);\n  if (initialized_data != 0) {\n    allocated_data = (undefined8 *)xmalloc(0x10);\n    *allocated_data = data_1;\n    allocated_data[1] = data_2;\n    *(undefined8 **)(initialized_data + 0x10) = allocated_data;\n  }\n  return initialized_data;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113e23",
            "calling": [
                "FUN_0010c2d2",
                "FUN_0010afd5",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "initialize_data_00113e23"
        },
        "fputc": {
            "renaming": {},
            "code": "\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043f0",
            "calling": [
                "FUN_00108b3e",
                "FUN_0011256b",
                "FUN_00104a35"
            ],
            "imported": false,
            "current_name": "fputc"
        },
        "bfd_scan_arch": {
            "renaming": {},
            "code": "\nvoid bfd_scan_arch(void)\n\n{\n  bfd_scan_arch();\n  return;\n}\n\n",
            "called": [
                "bfd_scan_arch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104710",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "bfd_scan_arch"
        },
        "FUN_00108fb9": {
            "renaming": {
                "FUN_00108fb9": "print_bad_stab_00108fb9",
                "param_1": "errorMessage",
                "__format": "formatString"
            },
            "code": "\n\n\nvoid printBadStab_00108fb9(undefined8 errorMessage)\n\n{\n  char *formatString;\n  \n  formatString = (char *)dcgettext(0,\"Bad stab: %s\\n\",5);\n  fprintf(_stderr,formatString,errorMessage);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108fb9",
            "calling": [
                "FUN_0011173a",
                "FUN_0010ee3f",
                "FUN_00109ab1"
            ],
            "imported": false,
            "current_name": "print_bad_stab_00108fb9"
        },
        "xcalloc": {
            "renaming": {},
            "code": "\nvoid xcalloc(void)\n\n{\n  xcalloc();\n  return;\n}\n\n",
            "called": [
                "xcalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104918",
            "calling": [
                "FUN_001163d0"
            ],
            "imported": false,
            "current_name": "xcalloc"
        },
        "FUN_00108ea1": {
            "renaming": {
                "FUN_00108ea1": "parse_integer_00108ea1",
                "param_1": "input",
                "param_2": "output",
                "iVar1": "accumulator",
                "pbVar2": "ptr_input",
                "pbVar3": "ptr_current",
                "uVar4": "result"
            },
            "code": "\nulong parse_integer_00108ea1(byte **input,int *output)\n\n{\n  int accumulator;\n  byte *ptr_input;\n  byte *ptr_current;\n  ulong result;\n  \n  ptr_input = *input;\n  result = 0;\n  if (((&_sch_istable)[(ulong)*ptr_input * 2] & 4) != 0) {\n    ptr_current = ptr_input + 1;\n    accumulator = (char)*ptr_input + -0x30;\n    *output = accumulator;\n    *input = ptr_current;\n    if (((&_sch_istable)[(ulong)ptr_input[1] * 2] & 4) != 0) {\n      do {\n        ptr_input = ptr_current;\n        accumulator = accumulator * 10 + -0x30 + (int)(char)*ptr_input;\n        ptr_current = ptr_input + 1;\n      } while (((&_sch_istable)[(ulong)ptr_input[1] * 2] & 4) != 0);\n      if (ptr_input[1] == 0x5f) {\n        ptr_current = ptr_input + 2;\n        *input = ptr_current;\n        *output = accumulator;\n      }\n    }\n    result = CONCAT71((int7)((ulong)ptr_current >> 8),1);\n  }\n  return result & 0xffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108ea1",
            "calling": [
                "FUN_0010c95e",
                "FUN_0010d882",
                "FUN_0010d21c"
            ],
            "imported": false,
            "current_name": "parse_integer_00108ea1"
        },
        "FUN_00108072": {
            "renaming": {
                "FUN_00108072": "set_alignment_and_size_00108072",
                "uVar2": "pointer",
                "cVar3": "status",
                "uVar4": "alignment",
                "lVar5": "errorMessage",
                "lVar6": "rule1Result",
                "lVar7": "rule2Result",
                "lVar8": "rule3Result",
                "unaff_RBX": "functionArguments",
                "unaff_RBP": "basePointer",
                "unaff_R12": "register12",
                "unaff_R14B": "flag",
                "unaff_R15": "register15",
                "bVar1": "byteValue"
            },
            "code": "\n\n\nvoid setAlignmentAndSize_00108072(void)\n\n{\n  byte byteValue;\n  undefined8 pointer;\n  char status;\n  uint alignment;\n  long errorMessage;\n  long rule1Result;\n  long rule2Result;\n  undefined8 *functionArguments;\n  long basePointer;\n  long register12;\n  long rule3Result;\n  char flag;\n  long register15;\n  \n  errorMessage = dcgettext(0,\"failed to set size\",5);\n  rule3Result = functionArguments[6];\n  rule1Result = parse_rules_00114190(*functionArguments,0,0x18);\n  if (rule1Result == 0) {\n    *(byte *)(register15 + 0x28) = *(byte *)(register15 + 0x28) | 1;\n    pointer = *functionArguments;\n    rule3Result = rule3Result + _DAT_00127990;\n    *(long *)(register15 + 0x30) = rule3Result;\n    *(long *)(register15 + 0x38) = rule3Result;\n    rule3Result = functionArguments[7];\n    rule1Result = parse_rules_00114190(pointer,0,0x60);\n    if (rule1Result == 0) goto LAB_00115695;\nLAB_00115860:\n    rule2Result = *(long *)(rule1Result + 0x20);\n    if ((*(byte *)(rule1Result + 0x14) & 0x40) != 0) {\n      rule2Result = rule2Result + rule3Result;\n    }\n    *(long *)(register15 + 0x38) = rule2Result;\n    rule3Result = parse_rules_00114190(*functionArguments,0,0x200);\n    if (rule3Result != 0) goto LAB_00115889;\nLAB_001156b8:\n    alignment = *(uint *)((long)functionArguments + 0x7c);\n    if (alignment < 0x3f) goto LAB_001156c4;\n    errorMessage = dcgettext(0,\"failed to set alignment\",5);\n    *(undefined4 *)(register15 + 0xb4) = *(undefined4 *)((long)functionArguments + 0xb4);\n    *(byte *)(register15 + 0x28) =\n         *(byte *)(register15 + 0x28) & 0xcf | *(byte *)(functionArguments + 5) & 0x30;\n    functionArguments[0xc] = register15;\n    functionArguments[0xb] = 0;\n    byteValue = *(byte *)((long)functionArguments + 0x27);\n  }\n  else {\n    rule2Result = *(long *)(rule1Result + 0x18);\n    if ((*(byte *)(rule1Result + 0x14) & 8) == 0) {\n      rule2Result = rule2Result + rule3Result;\n    }\n    *(byte *)(register15 + 0x28) = *(byte *)(register15 + 0x28) | 1;\n    pointer = *functionArguments;\n    *(long *)(register15 + 0x30) = rule2Result;\n    *(long *)(register15 + 0x38) = rule2Result;\n    rule3Result = functionArguments[7];\n    rule1Result = parse_rules_00114190(pointer,0,0x60);\n    if (rule1Result != 0) goto LAB_00115860;\nLAB_00115695:\n    pointer = *functionArguments;\n    *(long *)(register15 + 0x38) = rule3Result + _DAT_00127990;\n    rule3Result = parse_rules_00114190(pointer,0,0x200);\n    if (rule3Result == 0) goto LAB_001156b8;\nLAB_00115889:\n    alignment = *(uint *)(rule3Result + 0x2c);\n    if (0x3e < alignment) {\n      initialize_alignment_00108179();\n      return;\n    }\nLAB_001156c4:\n    *(uint *)(register15 + 0x7c) = alignment;\n    *(undefined4 *)(register15 + 0xb4) = *(undefined4 *)((long)functionArguments + 0xb4);\n    *(byte *)(register15 + 0x28) =\n         *(byte *)(register15 + 0x28) & 0xcf | *(byte *)(functionArguments + 5) & 0x30;\n    functionArguments[0xc] = register15;\n    functionArguments[0xb] = 0;\n    byteValue = *(byte *)((long)functionArguments + 0x27);\n  }\n  if ((byteValue & 2) != 0) {\n    rule3Result = functionArguments[0x1a];\n    rule1Result = find_element_in_array_00115d00(rule3Result,functionArguments[0x1c]);\n    if ((rule1Result != 0) &&\n       (rule2Result = *(long *)(register12 + 8), *(uint *)(rule1Result + 0x18) = *(uint *)(rule1Result + 0x18) | 0x20,\n       *(int *)(rule2Result + 8) == 5)) {\n      *(long *)(rule3Result + 0xb0) = rule1Result;\n      status = (**(code **)(*(long *)(basePointer + 8) + 0x158))();\n      if (status == '\\0') {\n        copy_private_data_0010808f();\n        return;\n      }\n      goto LAB_0011571e;\n    }\n  }\n  status = (**(code **)(*(long *)(basePointer + 8) + 0x158))();\n  if (status == '\\0') {\n    copy_private_data_0010808f();\n    return;\n  }\nLAB_0011571e:\n  if (flag != '\\0') {\n    *(undefined4 *)(*(long *)(register15 + 0xd0) + 4) = 8;\n  }\n  if (errorMessage != 0) {\n    DAT_00127a20 = 1;\n    display_error_001126c0(0);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00108179",
                "dcgettext",
                "FUN_00114190"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108072",
            "calling": [
                "FUN_00115530"
            ],
            "imported": false,
            "current_name": "set_alignment_and_size_00108072"
        },
        "htab_hash_string": {
            "renaming": {},
            "code": "\nvoid htab_hash_string(void)\n\n{\n  htab_hash_string();\n  return;\n}\n\n",
            "called": [
                "htab_hash_string"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048f8",
            "calling": [
                "FUN_00108800"
            ],
            "imported": false,
            "current_name": "htab_hash_string"
        },
        "FUN_0010a2b9": {
            "renaming": {
                "FUN_0010a2b9": "reverse_and_allocate_data_0010a2b9",
                "param_1": "binary_address",
                "param_2": "flag",
                "cVar1": "char_value",
                "__s": "list_item",
                "sVar2": "list_item_length",
                "__s_00": "allocated_string",
                "lVar3": "count",
                "auVar4": "result"
            },
            "code": "\nundefined  [16] reverse_and_allocate_data_0010a2b9(long binary_address,char flag,undefined8 param_3,undefined8 param_4)\n\n{\n  char char_value;\n  char *list_item;\n  size_t list_item_length;\n  char *allocated_string;\n  long count;\n  undefined result [16];\n  \n  char_value = *(char *)(*(long *)(binary_address + 0x60) + 0x1c);\n  list_item = (char *)extract_list_item_00109b2f();\n  list_item_length = strlen(list_item);\n  allocated_string = (char *)xmalloc(list_item_length + 0x1e);\n  if (flag == '\\0') {\n    *allocated_string = '\\0';\n    count = 0;\n    flag = char_value;\n  }\n  else {\n    count = *(long *)(binary_address + 0x68);\n    *(long *)(binary_address + 0x68) = count + 1;\n    sprintf(allocated_string,\"%ld=@S;\",count);\n  }\n  list_item_length = strlen(allocated_string);\n  sprintf(allocated_string + list_item_length,\"S%s\",list_item);\n  free(list_item);\n  result._0_4_ = allocate_and_initialize_data_00109b52(binary_address,allocated_string,count,flag,0);\n  result._4_4_ = 0;\n  if ((char)result._0_4_ != '\\0') {\n    free(allocated_string);\n  }\n  result._8_8_ = param_4;\n  return result;\n}\n\n",
            "called": [
                "strlen",
                "free",
                "xmalloc",
                "sprintf",
                "FUN_00109b2f",
                "FUN_00109b52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a2b9",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "reverse_and_allocate_data_0010a2b9"
        },
        "bfd_set_section_contents": {
            "renaming": {},
            "code": "\nvoid bfd_set_section_contents(void)\n\n{\n  bfd_set_section_contents();\n  return;\n}\n\n",
            "called": [
                "bfd_set_section_contents"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104330",
            "calling": [
                "FUN_0010554f",
                "FUN_00116110"
            ],
            "imported": false,
            "current_name": "bfd_set_section_contents"
        },
        "malloc": {
            "renaming": {},
            "code": "\n\n\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "malloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001045c0",
            "calling": [
                "FUN_00116b90",
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "malloc"
        },
        "FUN_00116ad0": {
            "renaming": {
                "FUN_00116ad0": "FUNC_00116ad0"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00116ae3) */\n/* WARNING: Removing unreachable block (ram,0x00116aef) */\n\nvoid FUNC_00116ad0(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_deregisterTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00116ad0",
            "calling": [
                "_FINI_0"
            ],
            "imported": false,
            "current_name": "FUNC_00116ad0"
        },
        "FUN_0010ec73": {
            "renaming": {
                "FUN_0010ec73": "process_data_0010ec73",
                "param_1": "data_array",
                "param_2": "value",
                "param_3": "arg1",
                "param_4": "arg2",
                "param_5": "arg3",
                "param_6": "arg4",
                "iVar1": "count",
                "cVar2": "result"
            },
            "code": "\nundefined process_data_0010ec73(long *data_array,long value,undefined8 arg1,undefined8 arg2,\n                      undefined8 arg3,undefined8 arg4)\n\n{\n  int count;\n  char result;\n  \n  if (data_array[0x3c] != -1) {\n    (**(code **)(*(long *)(*data_array + 8) + 0x50))(value,data_array[1] + 8 + data_array[0x3c]);\n    data_array[0x3c] = -1;\n  }\n  if (data_array[0x3d] != -1) {\n    (**(code **)(*(long *)(*data_array + 8) + 0x50))(value,data_array[1] + 8 + data_array[0x3d]);\n    data_array[0x3d] = -1;\n  }\n  count = *(int *)(data_array + 0x3f);\n  *(int *)(data_array + 0x3f) = count + 1;\n  if (count == 0) {\n    data_array[0x40] = value;\n  }\n  else {\n    if ((data_array[0x41] != -1) &&\n       (result = process_string_0010e2f0(data_array,0xc0,0,data_array[0x41],0,arg4,arg2), result == '\\0')) {\n      return 0;\n    }\n    data_array[0x41] = value - data_array[0x40];\n  }\n  return 1;\n}\n\n",
            "called": [
                "FUN_0010e2f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010ec73",
            "calling": [
                "FUN_00113a4d"
            ],
            "imported": false,
            "current_name": "process_data_0010ec73"
        },
        "FUN_00114e00": {
            "renaming": {
                "FUN_00114e00": "get_endianness_type_00114e00",
                "param_1": "endiannessType",
                "dcgettext": "getText"
            },
            "code": "\nvoid getEndiannessType_00114e00(int endiannessType)\n\n{\n  if (endiannessType == 0) {\n    dcgettext(0,\"big endian\",5);\n    return;\n  }\n  if (endiannessType == 1) {\n    dcgettext(0,\"little endian\",5);\n    return;\n  }\n  dcgettext(0,\"endianness unknown\",5);\n  return;\n}\n\n",
            "called": [
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114e00",
            "calling": [
                "FUN_00119f70"
            ],
            "imported": false,
            "current_name": "get_endianness_type_00114e00"
        },
        "FUN_00115970": {
            "renaming": {
                "FUN_00115970": "copy_and_delete_file_00115970",
                "param_1": "sourceFilePath",
                "param_2": "destinationFilePath",
                "param_3": "bufferSize",
                "param_4": "filePermissions",
                "param_5": "setFileTimeFlag",
                "param_6": "errorFlag",
                "uVar1": "copyStatus",
                "piVar2": "errorCodePointer",
                "pcVar3": "errorString",
                "uVar4": "errorMessage",
                "uVar5": "numCopiedBytes",
                "auVar6": "returnValue"
            },
            "code": "\nundefined  [16]\ncopyAndDeleteFile_00115970(char *sourceFilePath,char *destinationFilePath,undefined4 bufferSize,undefined8 filePermissions,char setFileTimeFlag,\n            undefined8 errorFlag)\n\n{\n  uint copyStatus;\n  int *errorCodePointer;\n  char *errorString;\n  undefined8 errorMessage;\n  ulong numCopiedBytes;\n  undefined returnValue [16];\n  \n  if (destinationFilePath == sourceFilePath) {\n    numCopiedBytes = 0;\n  }\n  else {\n    copyStatus = copy_file_00115a90(bufferSize,destinationFilePath,filePermissions);\n    numCopiedBytes = (ulong)copyStatus;\n    if (copyStatus != 0) {\n      errorCodePointer = __errno_location();\n      errorString = strerror(*errorCodePointer);\n      errorMessage = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n      print_error_message_00119ed0(errorMessage,destinationFilePath,errorString);\n    }\n    unlink(sourceFilePath);\n  }\n  if (setFileTimeFlag != '\\0') {\n    set_file_time_0011a350(destinationFilePath,filePermissions);\n  }\n  returnValue._8_8_ = errorFlag;\n  returnValue._0_8_ = numCopiedBytes;\n  return returnValue;\n}\n\n",
            "called": [
                "FUN_00108200",
                "FUN_00115a90"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115970",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "copy_and_delete_file_00115970"
        },
        "FUN_0010adf2": {
            "renaming": {
                "FUN_0010adf2": "store_string_data_0010adf2",
                "format_and_store_string_data_0010abdd": "format_and_store_string_data"
            },
            "code": "\nvoid store_string_data_0010adf2(void)\n\n{\n  format_and_store_string_data_0010adf2();\n  return;\n}\n\n",
            "called": [
                "FUN_0010abdd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010adf2",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "store_string_data_0010adf2"
        },
        "fputs": {
            "renaming": {},
            "code": "\n\n\nint fputs(char *__s,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputs(__s,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputs"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104310",
            "calling": [
                "FUN_00104943",
                "FUN_001126c0"
            ],
            "imported": false,
            "current_name": "fputs"
        },
        "FUN_0010d7d4": {
            "renaming": {
                "FUN_0010d7d4": "resize_and_add_to_buffer_0010d7d4",
                "param_1": "buffer",
                "param_2": "current_ptr",
                "param_3": "buffer_data",
                "param_4": "counter",
                "param_5": "max_count",
                "uVar1": "start",
                "cVar2": "result",
                "uVar3": "success",
                "lVar4": "buffer_ptr",
                "plVar5": "temp_buffer",
                "local_40": "temp_buffer_data",
                "uVar6": "temp_count"
            },
            "code": "\nundefined4\nresize_and_add_to_buffer_0010d7d4(undefined8 buffer,undefined8 *current_ptr,long *buffer_data,uint *counter,uint *max_count)\n\n{\n  undefined8 start;\n  char result;\n  undefined4 success;\n  long buffer_ptr;\n  long *temp_buffer;\n  uint temp_count;\n  long temp_buffer_data [2];\n  \n  start = *current_ptr;\n  temp_buffer = temp_buffer_data;\n  if (buffer_data == (long *)0x0) {\n    temp_buffer = (long *)0x0;\n  }\n  result = parse_initialize_data_0010c95e(buffer,current_ptr,temp_buffer);\n  if ((result != '\\0') &&\n     (success = resize_and_add_to_buffer_0010d7d4_00109be3(buffer,start,(int)*current_ptr - (int)start), (char)success != '\\0')) {\n    if (buffer_data == (long *)0x0) {\n      return success;\n    }\n    if (temp_buffer_data[0] != 0) {\n      if (*max_count <= *counter + 1) {\n        temp_count = *max_count + 10;\n        buffer_ptr = *buffer_data;\n        *max_count = temp_count;\n        buffer_ptr = xrealloc(buffer_ptr,(ulong)temp_count << 3);\n        *buffer_data = buffer_ptr;\n      }\n      temp_count = *counter;\n      *(long *)(*buffer_data + (ulong)temp_count * 8) = temp_buffer_data[0];\n      *counter = temp_count + 1;\n      return success;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_0010c95e",
                "xrealloc",
                "FUN_00109be3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010d7d4",
            "calling": [
                "FUN_0010d882"
            ],
            "imported": false,
            "current_name": "resize_and_add_to_buffer_0010d7d4",
            "code_backup": "\nundefined4\nFUN_0010d7d4(undefined8 param_1,undefined8 *param_2,long *param_3,uint *param_4,uint *param_5)\n\n{\n  undefined8 uVar1;\n  char cVar2;\n  undefined4 uVar3;\n  long lVar4;\n  long *plVar5;\n  uint uVar6;\n  long local_40 [2];\n  \n  uVar1 = *param_2;\n  plVar5 = local_40;\n  if (param_3 == (long *)0x0) {\n    plVar5 = (long *)0x0;\n  }\n  cVar2 = FUNC_0010c95e(param_1,param_2,plVar5);\n  if ((cVar2 != '\\0') &&\n     (uVar3 = resize_and_add_to_buffer_00109be3(param_1,uVar1,(int)*param_2 - (int)uVar1), (char)uVar3 != '\\0')) {\n    if (param_3 == (long *)0x0) {\n      return uVar3;\n    }\n    if (local_40[0] != 0) {\n      if (*param_5 <= *param_4 + 1) {\n        uVar6 = *param_5 + 10;\n        lVar4 = *param_3;\n        *param_5 = uVar6;\n        lVar4 = xrealloc(lVar4,(ulong)uVar6 << 3);\n        *param_3 = lVar4;\n      }\n      uVar6 = *param_4;\n      *(long *)(*param_3 + (ulong)uVar6 * 8) = local_40[0];\n      *param_4 = uVar6 + 1;\n      return uVar3;\n    }\n  }\n  return 0;\n}\n\n"
        },
        "FUN_00113f50": {
            "renaming": {
                "FUN_00113f50": "check_file_properties_00113f50",
                "param_1": "file_path",
                "iVar1": "status",
                "piVar2": "errno_location",
                "uVar3": "error_message",
                "pcVar4": "reason",
                "sStack_a8": "file_stat"
            },
            "code": "\nlong check_file_properties_00113f50(char *file_path)\n\n{\n  int status;\n  int *errno_location;\n  undefined8 error_message;\n  char *reason;\n  stat file_stat;\n  \n  if (file_path != (char *)0x0) {\n    status = stat(file_path,&file_stat);\n    if (status < 0) {\n      errno_location = __errno_location();\n      if (*errno_location == 2) {\n        error_message = dcgettext(0,\"\\'%s\\': No such file\",5);\n        print_error_message_00119ed0(error_message,file_path);\n      }\n      else {\n        reason = strerror(*errno_location);\n        error_message = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n        print_error_message_00119ed0(error_message,file_path,reason);\n      }\n    }\n    else if ((file_stat.st_mode & 0xf000) == 0x4000) {\n      error_message = dcgettext(0,\"Warning: \\'%s\\' is a directory\",5);\n      print_error_message_00119ed0(error_message,file_path);\n    }\n    else if ((file_stat.st_mode & 0xf000) == 0x8000) {\n      if (-1 < file_stat.st_size) {\n        return file_stat.st_size;\n      }\n      error_message = dcgettext(0,\"Warning: \\'%s\\' has negative size, probably it is too large\",5);\n      print_error_message_00119ed0(error_message,file_path);\n    }\n    else {\n      error_message = dcgettext(0,\"Warning: \\'%s\\' is not an ordinary file\",5);\n      print_error_message_00119ed0(error_message,file_path);\n    }\n  }\n  return -1;\n}\n\n",
            "called": [
                "FUN_00104966",
                "stat",
                "dcgettext",
                "FUN_00119ed0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113f50",
            "calling": [
                "FUN_00116b90",
                "FUN_00114460",
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "check_file_properties_00113f50"
        },
        "FUN_001087fd": {
            "renaming": {
                "FUN_001087fd": "initialize_function_001087fd"
            },
            "code": "\nundefined8 initialize_function_001087fd(void)\n\n{\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001087fd",
            "calling": [
                "FUN_0011a250"
            ],
            "imported": false,
            "current_name": "initialize_function_001087fd"
        },
        "FUN_0011256b": {
            "renaming": {
                "FUN_0011256b": "print_matched_formats_0011256b",
                "param_1": "formatStrings",
                "uVar1": "defaultValue",
                "__format": "formatMessage",
                "plVar2": "currentFormat",
                "_stdout": "standardOutput",
                "_stderr": "standardError"
            },
            "code": "\n\n\nvoid printMatchedFormats_0011256b(long *formatStrings)\n\n{\n  undefined8 defaultValue;\n  char *formatMessage;\n  long *currentFormat;\n  \n  fflush(standardOutput);\n  defaultValue = DAT_001275e0;\n  formatMessage = (char *)dcgettext(0,\"%s: Matching formats:\",5);\n  fprintf(standardError,formatMessage,defaultValue);\n  for (currentFormat = formatStrings; *currentFormat != 0; currentFormat = currentFormat + 1) {\n    fprintf(standardError,\" %s\");\n  }\n  free(formatStrings);\n  fputc(10,standardError);\n  return;\n}\n\n",
            "called": [
                "fputc",
                "fflush",
                "free",
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011256b",
            "calling": [
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "print_matched_formats_0011256b"
        },
        "fflush": {
            "renaming": {},
            "code": "\n\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fflush(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001045e0",
            "calling": [
                "FUN_0010871c",
                "FUN_0011256b",
                "FUN_00119e70",
                "FUN_001126c0"
            ],
            "imported": false,
            "current_name": "fflush"
        },
        "FUN_0011378f": {
            "renaming": {
                "FUN_0011378f": "extract_binary_data_0011378f",
                "param_1": "output",
                "param_2": "stats",
                "param_3": "result",
                "param_4": "info",
                "param_5": "strings",
                "param_6": "context",
                "auVar1": "temp1",
                "cVar2": "success",
                "uVar3": "error",
                "uVar4": "errorMessage",
                "puVar5": "newString",
                "sVar6": "stringLength",
                "lVar7": "loopIndex",
                "puVar8": "fileList",
                "puVar9": "array",
                "__dest": "destination",
                "puVar10": "file",
                "plVar11": "pointer",
                "bVar12": "flag",
                "local_258": "input",
                "local_250": "buffer",
                "local_248": "value1",
                "uStack_244": "value2",
                "uStack_240": "value3",
                "uStack_23c": "value4",
                "local_238": "array1",
                "local_228": "value5",
                "local_220": "array2",
                "local_1f8": "value6",
                "local_1f0": "value7",
                "local_1e8": "array3",
                "local_a0": "array4",
                "local_78": "value8",
                "uStack_70": "value9",
                "local_68": "value10",
                "local_60": "value11",
                "local_58": "value12",
                "uStack_54": "value13",
                "uStack_50": "value14",
                "uStack_4c": "value15"
            },
            "code": "\nundefined4\nextractBinaryData_0011378f(undefined8 *output,undefined8 *stats,long *result,undefined8 *info,\n            undefined8 *strings,undefined8 *context)\n\n{\n  undefined temp1 [16];\n  char success;\n  undefined4 error;\n  undefined8 errorMessage;\n  undefined *newString;\n  size_t stringLength;\n  long loopIndex;\n  undefined8 *fileList;\n  undefined4 *array;\n  char *destination;\n  undefined8 *file;\n  long *pointer;\n  byte flag;\n  undefined8 *input;\n  long buffer;\n  undefined4 value1;\n  undefined4 value2;\n  undefined4 value3;\n  undefined4 value4;\n  undefined array1 [16];\n  undefined8 value5;\n  undefined array2 [40];\n  undefined8 value6;\n  undefined8 value7;\n  undefined4 array3 [82];\n  undefined array4 [40];\n  undefined value8 [8];\n  undefined8 value9;\n  undefined8 value10;\n  undefined4 value11;\n  undefined4 value12;\n  undefined4 value13;\n  undefined4 value14;\n  undefined4 value15;\n  \n  flag = 0;\n  value1 = 0;\n  value2 = 0;\n  value3 = 500;\n  value4 = 0;\n  input = output;\n  buffer = xmalloc(500);\n  value5 = 1;\n  array1 = ZEXT816(0);\n  success = bfd_hash_table_init(array2,create_hash_function_0010bb52,0x30);\n  if ((success == '\\0') || (success = bfd_hash_table_init(array4,create_hash_function_0010bb52,0x30), success == '\\0')) {\n    error = bfd_get_error();\n    errorMessage = bfd_errmsg(error);\n    print_error_message_00119ed0(\"bfd_hash_table_init_failed: %s\",errorMessage);\n  }\n  else {\n    value6 = 0;\n    unique0x100000e9 = 0xffffffff;\n    value8 = (undefined  [8])0xffffffffffffffff;\n    unique0x100000ed = 0xffffffff;\n    array = array3;\n    for (loopIndex = 0x52; loopIndex != 0; loopIndex = loopIndex + -1) {\n      *array = 0;\n      array = array + (ulong)flag * -2 + 1;\n    }\n    value10 = 0;\n    value11 = 0;\n    value7 = 1;\n    value12 = 0;\n    value13 = 0;\n    value14 = 0xffffffff;\n    value15 = 0xffffffff;\n    success = process_string_0010e2f0(&input,0,0,0,0);\n    temp1 = _value8;\n    if (success != '\\0') {\n      value8._4_4_ = value2;\n      value8._0_4_ = value1;\n      value9 = temp1._8_8_;\n      success = process_string_0010e2f0(&input,100,0,0,*output);\n      if (success != '\\0') {\n        *(int *)(stats + 6) = *(int *)(stats + 6) + 1;\n        stats[10] = 0;\n        file = (undefined8 *)*stats;\n        *(undefined4 *)(stats + 7) = *(undefined4 *)((long)stats + 0x34);\n        for (; file != (undefined8 *)0x0; file = (undefined8 *)*file) {\n          stats[8] = file[2];\n          *(undefined4 *)(stats + 9) = 0;\n          success = thunk_update_string_and_process_0010e439(&input,*(undefined8 *)(file[1] + 8));\n          if (success == '\\0') {\n            return 0;\n          }\n          pointer = (long *)file[1];\n          if (pointer != (long *)0x0) {\n            while( true ) {\n              if ((undefined8 *)pointer[2] != (undefined8 *)0x0) {\n                for (fileList = *(undefined8 **)(undefined8 *)pointer[2]; fileList != (undefined8 *)0x0;\n                    fileList = (undefined8 *)*fileList) {\n                  success = process_data_001135a5(stats,&input);\n                  if (success == '\\0') {\n                    return 0;\n                  }\n                }\n              }\n              pointer = (long *)*pointer;\n              if (pointer == (long *)0x0) break;\n              success = update_string_and_process_0010e439(&input,pointer[1]);\n              if (success == '\\0') {\n                return 0;\n              }\n            }\n          }\n          success = process_files_00112502(stats,&input,0xffffffffffffffff);\n          if (success == '\\0') {\n            return 0;\n          }\n        }\n        if ((CONCAT44(value15,value14) == -1) &&\n           (error = process_string_0010e2f0(&input,100,0,value10,0), (char)error != '\\0')) {\n          (**(code **)(output[1] + 0x50))(value5,buffer + 8);\n          *result = buffer;\n          *info = CONCAT44(value2,value1);\n          *context = value5;\n          newString = (undefined *)xmalloc();\n          *newString = 0;\n          destination = newString + 1;\n          *strings = newString;\n          for (loopIndex = array1._0_8_; loopIndex != 0; loopIndex = *(long *)(loopIndex + 0x18)) {\n            strcpy(destination,*(char **)(loopIndex + 8));\n            stringLength = strlen(destination);\n            destination = destination + stringLength + 1;\n          }\n          return error;\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_001135a5",
                "FUN_0010e439",
                "thunk_FUN_0010e439",
                "bfd_errmsg",
                "bfd_hash_table_init",
                "strlen",
                "xmalloc",
                "FUN_0010bb52",
                "bfd_get_error",
                "FUN_00119ed0",
                "FUN_00112502",
                "strcpy",
                "FUN_0010e2f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011378f",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "extract_binary_data_0011378f",
            "code_backup": "\nundefined4\nFUN_0011378f(undefined8 *param_1,undefined8 *param_2,long *param_3,undefined8 *param_4,\n            undefined8 *param_5,undefined8 *param_6)\n\n{\n  undefined auVar1 [16];\n  char cVar2;\n  undefined4 uVar3;\n  undefined8 uVar4;\n  undefined *puVar5;\n  size_t sVar6;\n  long lVar7;\n  undefined8 *puVar8;\n  undefined4 *puVar9;\n  char *__dest;\n  undefined8 *puVar10;\n  long *plVar11;\n  byte bVar12;\n  undefined8 *local_258;\n  long local_250;\n  undefined4 local_248;\n  undefined4 uStack_244;\n  undefined4 uStack_240;\n  undefined4 uStack_23c;\n  undefined local_238 [16];\n  undefined8 local_228;\n  undefined local_220 [40];\n  undefined8 local_1f8;\n  undefined8 local_1f0;\n  undefined4 local_1e8 [82];\n  undefined local_a0 [40];\n  undefined local_78 [8];\n  undefined8 uStack_70;\n  undefined8 local_68;\n  undefined4 local_60;\n  undefined4 local_58;\n  undefined4 uStack_54;\n  undefined4 uStack_50;\n  undefined4 uStack_4c;\n  \n  bVar12 = 0;\n  local_248 = 0;\n  uStack_244 = 0;\n  uStack_240 = 500;\n  uStack_23c = 0;\n  local_258 = param_1;\n  local_250 = xmalloc(500);\n  local_228 = 1;\n  local_238 = ZEXT816(0);\n  cVar2 = bfd_hash_table_init(local_220,create_hash_function_0010bb52,0x30);\n  if ((cVar2 == '\\0') || (cVar2 = bfd_hash_table_init(local_a0,create_hash_function_0010bb52,0x30), cVar2 == '\\0')) {\n    uVar3 = bfd_get_error();\n    uVar4 = bfd_errmsg(uVar3);\n    print_error_message_00119ed0(\"bfd_hash_table_init_failed: %s\",uVar4);\n  }\n  else {\n    local_1f8 = 0;\n    unique0x100000e9 = 0xffffffff;\n    local_78 = (undefined  [8])0xffffffffffffffff;\n    unique0x100000ed = 0xffffffff;\n    puVar9 = local_1e8;\n    for (lVar7 = 0x52; lVar7 != 0; lVar7 = lVar7 + -1) {\n      *puVar9 = 0;\n      puVar9 = puVar9 + (ulong)bVar12 * -2 + 1;\n    }\n    local_68 = 0;\n    local_60 = 0;\n    local_1f0 = 1;\n    local_58 = 0;\n    uStack_54 = 0;\n    uStack_50 = 0xffffffff;\n    uStack_4c = 0xffffffff;\n    cVar2 = process_string_0010e2f0(&local_258,0,0,0,0);\n    auVar1 = _local_78;\n    if (cVar2 != '\\0') {\n      local_78._4_4_ = uStack_244;\n      local_78._0_4_ = local_248;\n      uStack_70 = auVar1._8_8_;\n      cVar2 = process_string_0010e2f0(&local_258,100,0,0,*param_1);\n      if (cVar2 != '\\0') {\n        *(int *)(param_2 + 6) = *(int *)(param_2 + 6) + 1;\n        param_2[10] = 0;\n        puVar10 = (undefined8 *)*param_2;\n        *(undefined4 *)(param_2 + 7) = *(undefined4 *)((long)param_2 + 0x34);\n        for (; puVar10 != (undefined8 *)0x0; puVar10 = (undefined8 *)*puVar10) {\n          param_2[8] = puVar10[2];\n          *(undefined4 *)(param_2 + 9) = 0;\n          cVar2 = thunk_update_string_and_process_0010e439(&local_258,*(undefined8 *)(puVar10[1] + 8));\n          if (cVar2 == '\\0') {\n            return 0;\n          }\n          plVar11 = (long *)puVar10[1];\n          if (plVar11 != (long *)0x0) {\n            while( true ) {\n              if ((undefined8 *)plVar11[2] != (undefined8 *)0x0) {\n                for (puVar8 = *(undefined8 **)(undefined8 *)plVar11[2]; puVar8 != (undefined8 *)0x0;\n                    puVar8 = (undefined8 *)*puVar8) {\n                  cVar2 = FUNC_001135a5(param_2,&local_258);\n                  if (cVar2 == '\\0') {\n                    return 0;\n                  }\n                }\n              }\n              plVar11 = (long *)*plVar11;\n              if (plVar11 == (long *)0x0) break;\n              cVar2 = update_string_and_process_0010e439(&local_258,plVar11[1]);\n              if (cVar2 == '\\0') {\n                return 0;\n              }\n            }\n          }\n          cVar2 = process_files_00112502(param_2,&local_258,0xffffffffffffffff);\n          if (cVar2 == '\\0') {\n            return 0;\n          }\n        }\n        if ((CONCAT44(uStack_4c,uStack_50) == -1) &&\n           (uVar3 = process_string_0010e2f0(&local_258,100,0,local_68,0), (char)uVar3 != '\\0')) {\n          (**(code **)(param_1[1] + 0x50))(local_228,local_250 + 8);\n          *param_3 = local_250;\n          *param_4 = CONCAT44(uStack_244,local_248);\n          *param_6 = local_228;\n          puVar5 = (undefined *)xmalloc();\n          *puVar5 = 0;\n          __dest = puVar5 + 1;\n          *param_5 = puVar5;\n          for (lVar7 = local_238._0_8_; lVar7 != 0; lVar7 = *(long *)(lVar7 + 0x18)) {\n            strcpy(__dest,*(char **)(lVar7 + 8));\n            sVar6 = strlen(__dest);\n            __dest = __dest + sVar6 + 1;\n          }\n          return uVar3;\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n"
        },
        "FUN_00104966": {
            "renaming": {
                "FUN_00104966": "handle_file_error_00104966",
                "piVar1": "errno_ptr",
                "uVar2": "error_message",
                "dcgettext": "get_error_message",
                "print_error_message_00119ed0": "print_error_message"
            },
            "code": "\nundefined8 handle_file_error_00104966(void)\n\n{\n  int *errno_ptr;\n  undefined8 error_message;\n  \n  errno_ptr = __errno_location();\n  if (*errno_ptr == 2) {\n    error_message = dcgettext(0,\"\\'%s\\': No such file\",5);\n    print_error_message(error_message);\n  }\n  else {\n    strerror(*errno_ptr);\n    error_message = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n    print_error_message(error_message);\n  }\n  return 0xffffffffffffffff;\n}\n\n",
            "called": [
                "__errno_location",
                "dcgettext",
                "FUN_00119ed0",
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104966",
            "calling": [
                "FUN_00113f50"
            ],
            "imported": false,
            "current_name": "handle_file_error_00104966"
        },
        "FUN_0010a0a0": {
            "renaming": {
                "FUN_0010a0a0": "process_data_0010a0a0",
                "param_1": "data"
            },
            "code": "\nvoid process_data_0010a0a0(long data)\n\n{\n  process_data_0010a0a0_00109ed3(data,0x26,4,data + 0x198,data + 0x1a0);\n  return;\n}\n\n",
            "called": [
                "FUN_00109ed3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a0a0",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "process_data_0010a0a0"
        },
        "FUN_00119ed0": {
            "renaming": {
                "FUN_00119ed0": "print_error_message_00119ed0",
                "param_1": "dataType",
                "param_2": "errorCode",
                "param_3": "param1",
                "param_4": "param2",
                "param_5": "param3",
                "param_6": "param4",
                "param_7": "param5",
                "param_8": "param6",
                "param_9": "errorMsg",
                "param_10": "param7",
                "param_11": "param8",
                "param_12": "param9",
                "param_13": "param10",
                "param_14": "param11",
                "in_AL": "someFlag",
                "local_d8": "bufferSize",
                "local_d4": "loopIndex",
                "local_d0": "bufferStart",
                "local_c8": "bufferPtr",
                "local_b8": "buffer",
                "local_b0": "param12",
                "local_a8": "param13",
                "local_a0": "param14",
                "local_98": "param15",
                "local_90": "param16",
                "local_88": "localParam1",
                "local_78": "localParam2",
                "local_68": "localParam3",
                "local_58": "localParam4",
                "local_48": "localParam5",
                "local_38": "localParam6",
                "local_28": "localParam7",
                "local_18": "localParam8"
            },
            "code": "\nvoid print_error_message_00119ed0(undefined4 dataType,undefined4 errorCode,undefined4 param1,undefined4 param2,\n                 undefined4 param3,undefined4 param4,undefined4 param5,undefined4 param6,\n                 undefined8 errorMsg,undefined8 param7,undefined8 param8,undefined8 param9,\n                 undefined8 param10,undefined8 param11)\n\n{\n  char someFlag;\n  undefined4 bufferSize;\n  undefined4 loopIndex;\n  undefined *bufferStart;\n  undefined *bufferPtr;\n  undefined buffer [8];\n  undefined8 param12;\n  undefined8 param13;\n  undefined8 param14;\n  undefined8 param15;\n  undefined8 param16;\n  undefined4 localParam1;\n  undefined4 localParam2;\n  undefined4 localParam3;\n  undefined4 localParam4;\n  undefined4 localParam5;\n  undefined4 localParam6;\n  undefined4 localParam7;\n  undefined4 localParam8;\n  \n  if (someFlag != '\\0') {\n    localParam1 = dataType;\n    localParam2 = errorCode;\n    localParam3 = param1;\n    localParam4 = param2;\n    localParam5 = param3;\n    localParam6 = param4;\n    localParam7 = param5;\n    localParam8 = param6;\n  }\n  bufferStart = &stack0x00000008;\n  bufferSize = 8;\n  bufferPtr = buffer;\n  loopIndex = 0x30;\n  param12 = param7;\n  param13 = param8;\n  param14 = param9;\n  param15 = param10;\n  param16 = param11;\n  print_error_message_00119ed0_00119e70(errorMsg,&bufferSize);\n  return;\n}\n\n",
            "called": [
                "FUN_00119e70"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00119ed0",
            "calling": [
                "FUN_00104966",
                "FUN_0010554f",
                "FUN_0010882c",
                "FUN_00108200",
                "FUN_00104ad6",
                "FUN_00113f50",
                "FUN_0010e07c",
                "FUN_001152b6",
                "FUN_0010ba08",
                "FUN_0011378f",
                "FUN_0010e6a8",
                "FUN_0010dac0",
                "FUN_00104cc1",
                "FUN_001163d0",
                "FUN_00104ea2",
                "FUN_00116b90",
                "FUN_001086af",
                "FUN_00108375",
                "FUN_00114e50",
                "FUN_00114690",
                "FUN_00105828",
                "FUN_0010b800",
                "FUN_00107880",
                "FUN_0010e2f0"
            ],
            "imported": false,
            "current_name": "print_error_message_00119ed0"
        },
        "FUN_00112c1f": {
            "renaming": {
                "FUN_00112c1f": "FUNC_00112c1f"
            },
            "code": "\n\n\nundefined8 FUNC_00112c1f(ulong param_1,undefined8 param_2,int *param_3,long param_4)\n\n{\n  long *plVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  undefined8 *puVar4;\n  char cVar5;\n  int *piVar6;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  int iVar9;\n  undefined4 uVar10;\n  undefined8 uVar11;\n  ulong uVar12;\n  uint uVar13;\n  bool bVar14;\n  uint local_3c;\n  \n  uVar12 = param_1;\nLAB_00112c39:\n  if (param_3 != (int *)0x0) {\n    iVar9 = *param_3;\n    if (iVar9 - 0x16U < 2) {\n      do {\n        plVar1 = *(long **)(param_3 + 4);\n        uVar13 = *(uint *)(param_1 + 0x30);\n        uVar12 = (ulong)uVar13;\n        lVar2 = *plVar1;\n        if (*(uint *)(lVar2 + 0x10) == uVar13) {\n          if (iVar9 == 0x16) {\n            uVar7 = find_valid_data_0010bba1(param_2,*(undefined8 *)(lVar2 + 8));\n            return uVar7;\n          }\nLAB_00112c94:\n          piVar6 = (int *)check_debug_information_00112b6e(param_3,0);\n          if (piVar6 == (int *)0x0) goto LAB_00112dd6;\n          if ((*piVar6 - 7U < 4) && (*(long *)(piVar6 + 4) != 0)) {\n            if ((*(uint *)(*(long *)(piVar6 + 4) + 0xc) <= *(uint *)(param_1 + 0x38)) &&\n               (cVar5 = set_class_id_0010c7a0(param_1,*(undefined8 *)(**(long **)(param_3 + 4) + 8),piVar6),\n               cVar5 == '\\0')) {\n              return 0;\n            }\n            uVar13 = *(uint *)(*(long *)(piVar6 + 4) + 0xc);\n          }\n          else {\n            uVar13 = 0;\n          }\n          iVar9 = *piVar6;\n          uVar7 = *(undefined8 *)(**(long **)(param_3 + 4) + 8);\n          goto LAB_00112ed2;\n        }\n        if (iVar9 == 0x17) {\n          if (lVar2 != param_4) goto LAB_00112c94;\n          *(uint *)(param_4 + 0x10) = uVar13;\n          param_4 = *plVar1;\n          param_3 = (int *)plVar1[1];\n          goto LAB_00112c39;\n        }\n        if (param_4 != 0) {\n          *(uint *)(param_4 + 0x10) = uVar13;\n        }\n        param_3 = (int *)plVar1[1];\n        if (param_3 == (int *)0x0) goto LAB_00112dd6;\n        iVar9 = *param_3;\n        param_4 = 0;\n      } while (iVar9 - 0x16U < 2);\nLAB_00112d74:\n      uVar7 = 0;\n    }\n    else {\n      if (param_4 == 0) goto LAB_00112d74;\n      *(undefined4 *)(param_4 + 0x10) = *(undefined4 *)(param_1 + 0x30);\n      if (*(int *)(param_4 + 0x14) != 1) {\n                    \n        __assert_fail(\"name->kind == DEBUG_OBJECT_TAG\",\"../../binutils/debug.c\",0x9b3,\n                      \"debug_write_type\");\n      }\n      uVar7 = *(undefined8 *)(param_4 + 8);\n    }\n    switch(iVar9) {\n    case 0:\n      uVar7 = dcgettext(0,\"debug_write_type: illegal type encountered\",5);\n      fprintf(_stderr,\"%s\\n\",uVar7);\n      return 0;\n    case 1:\n      goto switchD_00112d8e_caseD_1;\n    case 2:\n      uVar7 = initialize_or_allocate_data_00109dfe(param_2);\n      return uVar7;\n    case 3:\n      uVar7 = process_stab_int_type_0010b800(param_2,param_3[1],*(undefined *)(param_3 + 4));\n      return uVar7;\n    case 4:\n      uVar7 = initialize_or_extract_data_0010b948(param_2,param_3[1]);\n      return uVar7;\n    case 5:\n      uVar7 = update_and_allocate_data_00109e76(param_2,param_3[1]);\n      return uVar7;\n    case 6:\n      uVar7 = initialize_with_data_00109d3e(param_2,param_3[1]);\n      return uVar7;\n    case 7:\n    case 8:\n      if (*(long *)(param_3 + 4) != 0) {\n        if ((*(uint *)(*(long *)(param_3 + 4) + 0xc) <= *(uint *)(param_1 + 0x38)) &&\n           (cVar5 = set_class_id_0010c7a0(param_1,uVar7,param_3), cVar5 == '\\0')) {\n          return 0;\n        }\n        lVar2 = *(long *)(param_3 + 4);\n        if (*(int *)(param_1 + 0x30) == *(int *)(lVar2 + 8)) {\n          uVar13 = *(uint *)(lVar2 + 0xc);\n          if (uVar13 <= *(uint *)(param_1 + 0x38)) {\n                    \n            __assert_fail(\"type->u.kclass->id > info->base_id\",\"../../binutils/debug.c\",0x9db,\n                          \"debug_write_type\");\n          }\n          iVar9 = *param_3;\nLAB_00112ed2:\n          uVar7 = initialize_and_resize_array_00109d5c(param_2,uVar7,uVar13,iVar9);\n          return uVar7;\n        }\n        *(int *)(lVar2 + 8) = *(int *)(param_1 + 0x30);\n      }\n      uVar10 = 0;\n      if (*(long *)(param_3 + 4) != 0) {\n        uVar10 = *(undefined4 *)(*(long *)(param_3 + 4) + 0xc);\n      }\n      cVar5 = format_and_allocate_data_0010a69a(param_2,uVar7,uVar10,*param_3 == 7,param_3[1]);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      if ((*(long **)(param_3 + 4) != (long *)0x0) && (uVar12 = 0, **(long **)(param_3 + 4) != 0)) {\n        while( true ) {\n          puVar4 = *(undefined8 **)(**(long **)(param_3 + 4) + uVar12 * 8);\n          if (puVar4 == (undefined8 *)0x0) break;\n          cVar5 = FUNC_00112c1f(param_1,param_2,puVar4[1],0);\n          if (cVar5 == '\\0') {\n            return 0;\n          }\n          cVar5 = generate_warning_message_0010ba08(param_2,*puVar4,*(undefined4 *)(puVar4 + 3),\n                               *(undefined4 *)((long)puVar4 + 0x1c),*(undefined4 *)(puVar4 + 2));\n          if (cVar5 == '\\0') {\n            return 0;\n          }\n          uVar12 = (ulong)((int)uVar12 + 1);\n        }\n      }\n      uVar7 = extract_and_allocate_data_0010a77a(param_2);\n      return uVar7;\n    case 9:\n    case 10:\n      if (*(long *)(param_3 + 4) == 0) {\n        uVar13 = 0;\n        piVar6 = (int *)0x0;\n      }\n      else {\n        if ((*(uint *)(*(long *)(param_3 + 4) + 0xc) <= *(uint *)(param_1 + 0x38)) &&\n           (uVar12 = param_1, cVar5 = set_class_id_0010c7a0(param_1,uVar7,param_3), cVar5 == '\\0')) {\n          return 0;\n        }\n        lVar2 = *(long *)(param_3 + 4);\n        uVar13 = *(uint *)(lVar2 + 0xc);\n        if (*(int *)(param_1 + 0x30) == *(int *)(lVar2 + 8)) {\n          if (uVar13 <= *(uint *)(param_1 + 0x38)) {\n                    \n            __assert_fail(\"type->u.kclass->id > info->base_id\",\"../../binutils/debug.c\",0xa87,\n                          \"debug_write_class_type\");\n          }\n          iVar9 = *param_3;\n          goto LAB_00112ed2;\n        }\n        piVar6 = *(int **)(lVar2 + 0x20);\n        *(int *)(lVar2 + 8) = *(int *)(param_1 + 0x30);\n        if (((piVar6 != (int *)0x0) && (param_3 != piVar6)) &&\n           (uVar12 = param_1, cVar5 = FUNC_00112c1f(param_1,param_2,piVar6,0), cVar5 == '\\0')) {\n          return 0;\n        }\n      }\n      cVar5 = format_data_and_allocate_0010a83e(param_2,uVar7,uVar13,*param_3 == 9,param_3[1],piVar6 != (int *)0x0,\n                           param_3 == piVar6,uVar12);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      if (*(long **)(param_3 + 4) != (long *)0x0) {\n        uVar13 = 0;\n        if (**(long **)(param_3 + 4) != 0) {\n          while (puVar4 = *(undefined8 **)(**(long **)(param_3 + 4) + (ulong)uVar13 * 8),\n                puVar4 != (undefined8 *)0x0) {\n            cVar5 = FUNC_00112c1f(param_1,param_2,puVar4[1],0);\n            if (cVar5 == '\\0') {\n              return 0;\n            }\n            if (*(char *)((long)puVar4 + 0x14) == '\\0') {\n              cVar5 = generate_warning_message_0010ba08(param_2,*puVar4,*(undefined4 *)(puVar4 + 3));\n            }\n            else {\n              cVar5 = build_request_0010a94e(param_2,*puVar4,puVar4[3]);\n            }\n            if (cVar5 == '\\0') {\n              return 0;\n            }\n            uVar13 = uVar13 + 1;\n          }\n        }\n        uVar13 = 0;\n        if (*(long *)(*(long *)(param_3 + 4) + 0x10) != 0) {\n          while (puVar4 = *(undefined8 **)\n                           (*(long *)(*(long *)(param_3 + 4) + 0x10) + (ulong)uVar13 * 8),\n                puVar4 != (undefined8 *)0x0) {\n            cVar5 = FUNC_00112c1f(param_1,param_2,*puVar4,0);\n            if (cVar5 == '\\0') {\n              return 0;\n            }\n            cVar5 = format_and_store_data_0010aa53(param_2,*(undefined4 *)(puVar4 + 1),\n                                 *(undefined *)((long)puVar4 + 0xc));\n            if (cVar5 == '\\0') {\n              return 0;\n            }\n            uVar13 = uVar13 + 1;\n          }\n        }\n        local_3c = 0;\n        if (*(long *)(*(long *)(param_3 + 4) + 0x18) != 0) {\n          while (puVar4 = *(undefined8 **)\n                           (*(long *)(*(long *)(param_3 + 4) + 0x18) + (ulong)local_3c * 8),\n                puVar4 != (undefined8 *)0x0) {\n            cVar5 = append_string_to_variable_0010ab4d(param_2,*puVar4);\n            if (cVar5 == '\\0') {\n              return 0;\n            }\n            uVar13 = 0;\n            while (puVar3 = *(undefined8 **)(puVar4[1] + (ulong)uVar13 * 8),\n                  puVar3 != (undefined8 *)0x0) {\n              if ((puVar3[4] != 0) &&\n                 (cVar5 = FUNC_00112c1f(param_1,param_2,puVar3[4],0), cVar5 == '\\0')) {\n                return 0;\n              }\n              cVar5 = FUNC_00112c1f(param_1,param_2,puVar3[1],0);\n              if (cVar5 == '\\0') {\n                return 0;\n              }\n              if (puVar3[3] == -1) {\n                cVar5 = store_string_data_0010adf2(param_2,*puVar3,*(undefined4 *)(puVar3 + 2),\n                                     *(undefined *)((long)puVar3 + 0x14),\n                                     *(undefined *)((long)puVar3 + 0x15));\n              }\n              else {\n                cVar5 = initialize_string_data_0010add5(param_2);\n              }\n              if (cVar5 == '\\0') {\n                return 0;\n              }\n              uVar13 = uVar13 + 1;\n            }\n            cVar5 = append_semicolon_if_not_null_00109bbb(param_2);\n            if (cVar5 == '\\0') {\n              return 0;\n            }\n            local_3c = local_3c + 1;\n          }\n        }\n      }\n      uVar7 = process_binary_data_0010ae0e(param_2);\n      return uVar7;\n    case 0xb:\n      puVar4 = *(undefined8 **)(param_3 + 4);\n      if (puVar4 == (undefined8 *)0x0) {\n        uVar8 = 0;\n        uVar11 = 0;\n      }\n      else {\n        uVar8 = puVar4[1];\n        uVar11 = *puVar4;\n      }\n      uVar7 = allocate_and_initialize_data_0010e453(param_2,uVar7,uVar11,uVar8);\n      return uVar7;\n    case 0xc:\n      cVar5 = FUNC_00112c1f(param_1,param_2,*(undefined8 *)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      uVar7 = process_and_update_data_0010a083(param_2);\n      return uVar7;\n    case 0xd:\n      cVar5 = FUNC_00112c1f(param_1,param_2,**(undefined8 **)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      uVar12 = 0;\n      if (*(long *)(*(long *)(param_3 + 4) + 8) == 0) {\n        uVar12 = 0xffffffff;\n      }\n      else {\n        while (lVar2 = *(long *)(*(long *)(*(long *)(param_3 + 4) + 8) + uVar12 * 8), lVar2 != 0) {\n          uVar12 = uVar12 + 1;\n          cVar5 = FUNC_00112c1f(param_1,param_2,lVar2,0);\n          if (cVar5 == '\\0') {\n            return 0;\n          }\n        }\n        uVar12 = uVar12 & 0xffffffff;\n      }\n      uVar7 = extract_data_from_list_0010e5db(param_2,uVar12,*(undefined *)(*(long *)(param_3 + 4) + 0x10));\n      return uVar7;\n    case 0xe:\n      cVar5 = FUNC_00112c1f(param_1,param_2,*(undefined8 *)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      uVar7 = process_data_0010a0a0(param_2);\n      return uVar7;\n    case 0xf:\n      cVar5 = FUNC_00112c1f(param_1,param_2,**(undefined8 **)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      uVar7 = generate_data_0010a0e9(param_2,*(undefined8 *)(*(long *)(param_3 + 4) + 8),\n                           *(undefined8 *)(*(long *)(param_3 + 4) + 0x10));\n      return uVar7;\n    case 0x10:\n      cVar5 = FUNC_00112c1f(param_1,param_2,**(undefined8 **)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      cVar5 = FUNC_00112c1f(param_1,param_2,*(undefined8 *)(*(long *)(param_3 + 4) + 8),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      lVar2 = *(long *)(param_3 + 4);\n      uVar7 = process_data_0010a181(param_2,*(undefined8 *)(lVar2 + 0x10),*(undefined8 *)(lVar2 + 0x18),\n                           *(undefined *)(lVar2 + 0x20));\n      return uVar7;\n    case 0x11:\n      cVar5 = FUNC_00112c1f(param_1,param_2,**(undefined8 **)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      uVar7 = reverse_and_allocate_data_0010a2b9(param_2,*(undefined *)(*(long *)(param_3 + 4) + 8));\n      return uVar7;\n    case 0x12:\n      cVar5 = FUNC_00112c1f(param_1,param_2,**(undefined8 **)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      cVar5 = FUNC_00112c1f(param_1,param_2,*(undefined8 *)(*(long *)(param_3 + 4) + 8),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      uVar7 = construct_data_string_0010a377(param_2);\n      return uVar7;\n    case 0x13:\n      cVar5 = FUNC_00112c1f(param_1,param_2,**(undefined8 **)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      uVar12 = 0;\n      if (*(long *)(*(long *)(param_3 + 4) + 0x10) == 0) {\n        uVar12 = 0xffffffff;\n      }\n      else {\n        while (lVar2 = *(long *)(*(long *)(*(long *)(param_3 + 4) + 0x10) + uVar12 * 8), lVar2 != 0)\n        {\n          uVar12 = uVar12 + 1;\n          cVar5 = FUNC_00112c1f(param_1,param_2,lVar2,0);\n          if (cVar5 == '\\0') {\n            return 0;\n          }\n        }\n      }\n      if ((*(long *)(*(long *)(param_3 + 4) + 8) != 0) &&\n         (cVar5 = FUNC_00112c1f(param_1,param_2,*(long *)(*(long *)(param_3 + 4) + 8),0),\n         cVar5 == '\\0')) {\n        return 0;\n      }\n      uVar7 = generate_formatted_string_0010a424(param_2,*(long *)(*(long *)(param_3 + 4) + 8) != 0,uVar12 & 0xffffffff,\n                           *(undefined *)(*(long *)(param_3 + 4) + 0x18));\n      return uVar7;\n    case 0x14:\n      cVar5 = FUNC_00112c1f(param_1,param_2,*(undefined8 *)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      uVar7 = process_and_send_data_0010a0bd(param_2);\n      return uVar7;\n    case 0x15:\n      cVar5 = FUNC_00112c1f(param_1,param_2,*(undefined8 *)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      uVar7 = process_data_0010a0d3(param_2);\n      return uVar7;\n    default:\n                    \n      abort();\n    }\n  }\n  goto LAB_00112dd6;\nswitchD_00112d8e_caseD_1:\n  bVar14 = *(int **)**(undefined8 **)(param_3 + 4) == param_3;\n  param_3 = *(int **)**(undefined8 **)(param_3 + 4);\n  if (bVar14) {\nLAB_00112dd6:\n    uVar7 = initialize_or_increment_variable_00109d97(param_2);\n    return uVar7;\n  }\n  goto LAB_00112c39;\n}\n\n",
            "called": [
                "FUN_0010adf2",
                "FUN_0010e5db",
                "abort",
                "FUN_0010a0e9",
                "FUN_00109d5c",
                "FUN_0010a0bd",
                "FUN_0010ae0e",
                "FUN_00109d97",
                "FUN_0010ba08",
                "FUN_0010a77a",
                "FUN_00109e76",
                "FUN_0010e453",
                "FUN_0010b948",
                "FUN_0010a2b9",
                "FUN_0010aa53",
                "FUN_00109bbb",
                "FUN_0010a94e",
                "FUN_0010ab4d",
                "FUN_0010c7a0",
                "FUN_0010a83e",
                "FUN_0010a181",
                "fprintf",
                "dcgettext",
                "FUN_0010a0a0",
                "FUN_0010a083",
                "FUN_0010a424",
                "FUN_0010add5",
                "FUN_0010a0d3",
                "FUN_0010a377",
                "FUN_00112c1f",
                "FUN_00109dfe",
                "FUN_00112b6e",
                "FUN_0010a69a",
                "__assert_fail",
                "FUN_0010b800",
                "FUN_00109d3e",
                "FUN_0010bba1"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00112c1f",
            "calling": [
                "FUN_001135a5",
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "FUNC_00112c1f"
        },
        "xmalloc_set_program_name": {
            "renaming": {},
            "code": "\nvoid xmalloc_set_program_name(void)\n\n{\n  xmalloc_set_program_name();\n  return;\n}\n\n",
            "called": [
                "xmalloc_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043b0",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "xmalloc_set_program_name"
        },
        "bfd_malloc_and_get_section": {
            "renaming": {},
            "code": "\nvoid bfd_malloc_and_get_section(void)\n\n{\n  bfd_malloc_and_get_section();\n  return;\n}\n\n",
            "called": [
                "bfd_malloc_and_get_section"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001041e0",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "bfd_malloc_and_get_section"
        },
        "FUN_0010808f": {
            "renaming": {
                "FUN_0010808f": "copy_private_data_0010808f",
                "unaff_R14B": "flag",
                "unaff_R15": "baseAddress",
                "lVar1": "errorMessage",
                "dcgettext": "getErrorMessage",
                "display_error_001126c0": "displayError"
            },
            "code": "\nvoid copyPrivateData_0010808f(void)\n\n{\n  long errorMessage;\n  char flag;\n  long baseAddress;\n  \n  errorMessage = dcgettext(0,\"failed to copy private data\",5);\n  if (flag != '\\0') {\n    *(undefined4 *)(*(long *)(baseAddress + 0xd0) + 4) = 8;\n  }\n  if (errorMessage != 0) {\n    DAT_00127a20 = 1;\n    displayError(0);\n  }\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_001126c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010808f",
            "calling": [
                "FUN_00108179"
            ],
            "imported": false,
            "current_name": "copy_private_data_0010808f"
        },
        "read": {
            "renaming": {},
            "code": "\n\n\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = read(__fd,__buf,__nbytes);\n  return sVar1;\n}\n\n",
            "called": [
                "read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104410",
            "calling": [
                "FUN_00115a90"
            ],
            "imported": false,
            "current_name": "read"
        },
        "FUN_00108fe8": {
            "renaming": {
                "FUN_00108fe8": "print_warning_00108fe8",
                "param_1": "message",
                "param_2": "source",
                "in_RAX": "returnValue",
                "__format": "formatString"
            },
            "code": "\n\n\nvoid printWarning_00108fe8(undefined8 message,undefined8 source)\n\n{\n  undefined8 returnValue;\n  char *formatString;\n  \n  formatString = (char *)dcgettext(0,\"Warning: %s: %s\\n\",5);\n  fprintf(_stderr,formatString,source,message,returnValue);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108fe8",
            "calling": [
                "FUN_0011173a",
                "FUN_0010ee3f",
                "FUN_00109a32"
            ],
            "imported": false,
            "current_name": "print_warning_00108fe8"
        },
        "bfd_alloc": {
            "renaming": {},
            "code": "\nvoid bfd_alloc(void)\n\n{\n  bfd_alloc();\n  return;\n}\n\n",
            "called": [
                "bfd_alloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104250",
            "calling": [
                "FUN_00115dc0"
            ],
            "imported": false,
            "current_name": "bfd_alloc"
        },
        "FUN_00105828": {
            "renaming": {
                "FUN_00105828": "check_file_architecture_00105828",
                "iVar1": "arch",
                "uVar2": "formatted_arch",
                "uVar3": "formatted_string",
                "uVar4": "error_message"
            },
            "code": "\nundefined8 check_file_architecture_00105828(void)\n\n{\n  int arch;\n  undefined4 formatted_arch;\n  undefined8 formatted_string;\n  undefined8 error_message;\n  \n  arch = bfd_get_arch();\n  if (arch == 0) {\n    formatted_string = get_formatted_string_001125fa();\n    error_message = dcgettext(0,\"Unable to recognise the format of the input file `%s\\'\",5);\n    print_error_message_00119ed0(error_message,formatted_string);\n  }\n  else {\n    formatted_string = bfd_get_mach();\n    formatted_arch = bfd_get_arch();\n    formatted_string = bfd_printable_arch_mach(formatted_arch,formatted_string);\n    error_message = dcgettext(0,\"Output file cannot represent architecture `%s\\'\",5);\n    print_error_message_00119ed0(error_message,formatted_string);\n  }\n  return 0;\n}\n\n",
            "called": [
                "bfd_get_mach",
                "bfd_printable_arch_mach",
                "dcgettext",
                "FUN_00119ed0",
                "FUN_001125fa",
                "bfd_get_arch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105828",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "check_file_architecture_00105828"
        },
        "memset": {
            "renaming": {},
            "code": "\n\n\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memset(__s,__c,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104360",
            "calling": [
                "FUN_00119f70"
            ],
            "imported": false,
            "current_name": "memset"
        },
        "entry": {
            "renaming": {},
            "code": "\nvoid processEntry entry(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_8 [8];\n  \n  __libc_start_main(FUNC_00116b90,param_2,&stack0x00000008,0,0,param_1,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00116b90",
                "__libc_start_main"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116aa0",
            "calling": [],
            "imported": false,
            "current_name": "entry"
        },
        "FUN_0011a0e0": {
            "renaming": {
                "FUN_0011a0e0": "create_temp_directory_0011a0e0",
                "__template": "file_path",
                "pcVar1": "result"
            },
            "code": "\nchar * create_temp_directory_0011a0e0(void)\n\n{\n  char *file_path;\n  char *result;\n  \n  file_path = (char *)allocate_file_path_00114cf0();\n  result = mkdtemp(file_path);\n  if (result == (char *)0x0) {\n    free(file_path);\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_001081e9",
                "mkdtemp",
                "FUN_00114cf0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a0e0",
            "calling": [
                "FUN_00104ea2",
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "create_temp_directory_0011a0e0"
        },
        "FUN_0010bba1": {
            "renaming": {
                "FUN_0010bba1": "find_valid_data_0010bba1",
                "param_1": "inputAddress",
                "param_2": "key",
                "lVar1": "lookupResult",
                "uVar2": "dataInitializationResult"
            },
            "code": "\nundefined8 findValidData_0010bba1(long inputAddress,undefined8 key)\n\n{\n  long lookupResult;\n  undefined8 dataInitializationResult;\n  \n  lookupResult = bfd_hash_lookup(inputAddress + 0x1b8,key,0,0);\n  if ((lookupResult != 0) && (0 < *(long *)(lookupResult + 0x20))) {\n    dataInitializationResult = initialize_data_00109cf4(inputAddress,*(long *)(lookupResult + 0x20),*(undefined4 *)(lookupResult + 0x28));\n    return dataInitializationResult;\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00109cf4",
                "bfd_hash_lookup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bba1",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "find_valid_data_0010bba1"
        },
        "bfd_check_format_matches": {
            "renaming": {},
            "code": "\nvoid bfd_check_format_matches(void)\n\n{\n  bfd_check_format_matches();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format_matches"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104780",
            "calling": [
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "bfd_check_format_matches"
        },
        "FUN_0010e6a8": {
            "renaming": {
                "FUN_0010e6a8": "process_and_store_string_0010e6a8",
                "param_1": "data_structure",
                "param_2": "input_string",
                "param_3": "unused_param_1",
                "param_4": "unused_param_2",
                "__s": "extracted_string",
                "sVar3": "input_string_length",
                "sVar4": "extracted_string_length",
                "__s_00": "processed_string",
                "lVar8": "string_index",
                "uVar1": "string_processing_result",
                "uVar2": "error_code",
                "lVar5": "lookup_result",
                "uVar6": "error_message",
                "uVar7": "translation",
                "uVar9": "return_value",
                "auVar10": "return_data"
            },
            "code": "\nundefined  [16] process_and_store_string_0010e6a8(long data_structure,char *input_string,undefined8 unused_param_1,undefined8 unused_param_2)\n\n{\n  uint string_processing_result;\n  undefined4 error_code;\n  char *extracted_string;\n  size_t input_string_length;\n  size_t extracted_string_length;\n  char *processed_string;\n  long lookup_result;\n  undefined8 error_message;\n  undefined8 translation;\n  long string_index;\n  ulong return_value;\n  undefined return_data [16];\n  \n  string_index = *(long *)(*(long *)(data_structure + 0x60) + 0x10);\n  error_code = *(undefined4 *)(*(long *)(data_structure + 0x60) + 0x18);\n  extracted_string = (char *)extract_list_item_00109b2f();\n  input_string_length = strlen(input_string);\n  extracted_string_length = strlen(extracted_string);\n  processed_string = (char *)xmalloc(input_string_length + 0x14 + extracted_string_length);\n  if (string_index < 1) {\n    string_index = *(long *)(data_structure + 0x68);\n    *(long *)(data_structure + 0x68) = string_index + 1;\n    sprintf(processed_string,\"%s:t%ld=%s\",input_string,string_index,extracted_string);\n  }\n  else {\n    sprintf(processed_string,\"%s:t%s\",input_string,extracted_string);\n  }\n  free(extracted_string);\n  string_processing_result = process_string_0010e2f0(data_structure,0x80,0,0,processed_string);\n  return_value = (ulong)string_processing_result;\n  if ((char)string_processing_result != '\\0') {\n    free(processed_string);\n    lookup_result = bfd_hash_lookup(data_structure + 0x1b8,input_string,1,0);\n    if (lookup_result != 0) {\n      *(long *)(lookup_result + 0x20) = string_index;\n      *(undefined4 *)(lookup_result + 0x28) = error_code;\n      goto LAB_0010e7b3;\n    }\n    error_code = bfd_get_error();\n    error_message = bfd_errmsg(error_code);\n    translation = dcgettext(0,\"string_hash_lookup failed: %s\",5);\n    print_error_message_00119ed0(translation,error_message);\n  }\n  return_value = 0;\nLAB_0010e7b3:\n  return_data._8_8_ = unused_param_2;\n  return_data._0_8_ = return_value;\n  return return_data;\n}\n\n",
            "called": [
                "bfd_errmsg",
                "strlen",
                "free",
                "xmalloc",
                "dcgettext",
                "FUN_00119ed0",
                "bfd_get_error",
                "bfd_hash_lookup",
                "sprintf",
                "FUN_00109b2f",
                "FUN_0010e2f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e6a8",
            "calling": [
                "FUN_001135a5"
            ],
            "imported": false,
            "current_name": "process_and_store_string_0010e6a8"
        },
        "FUN_0010e7c2": {
            "renaming": {
                "FUN_0010e7c2": "format_and_process_string_0010e7c2",
                "param_1": "param1",
                "param_2": "input_string",
                "param_3": "param3",
                "param_4": "param4",
                "__s": "extracted_list_item",
                "sVar1": "input_length",
                "sVar2": "extracted_length",
                "__s_00": "formatted_str",
                "auVar3": "result"
            },
            "code": "\nundefined  [16] format_and_process_string_0010e7c2(undefined8 param1,char *input_string,undefined8 param3,undefined8 param4)\n\n{\n  char *extracted_list_item;\n  size_t input_length;\n  size_t extracted_length;\n  char *formatted_str;\n  undefined result [16];\n  \n  extracted_list_item = (char *)extract_list_item_00109b2f();\n  input_length = strlen(input_string);\n  extracted_length = strlen(extracted_list_item);\n  formatted_str = (char *)xmalloc(input_length + 3 + extracted_length);\n  sprintf(formatted_str,\"%s:T%s\",input_string,extracted_list_item);\n  free(extracted_list_item);\n  result._0_4_ = process_string_0010e2f0(param1,0x80,0,0,formatted_str);\n  result._4_4_ = 0;\n  if ((char)result._0_4_ != '\\0') {\n    free(formatted_str);\n  }\n  result._8_8_ = param4;\n  return result;\n}\n\n",
            "called": [
                "strlen",
                "free",
                "xmalloc",
                "sprintf",
                "FUN_00109b2f",
                "FUN_0010e2f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e7c2",
            "calling": [
                "FUN_001135a5"
            ],
            "imported": false,
            "current_name": "format_and_process_string_0010e7c2"
        },
        "FUN_00119dd0": {
            "renaming": {
                "FUN_00119dd0": "print_error_and_exit_00119dd0",
                "param_1": "error_code",
                "param_9": "error_message",
                "in_AL": "condition",
                "local_d8": "buffer_size",
                "local_d4": "local_variable_1",
                "local_d0": "buffer_pointer",
                "local_c8": "local_variable_2",
                "local_b8": "local_array",
                "local_b0": "param_10_copy",
                "local_a8": "param_11_copy",
                "local_a0": "param_12_copy",
                "local_98": "param_13_copy",
                "local_90": "param_14_copy",
                "local_88": "local_var_1",
                "local_78": "local_var_2",
                "local_68": "local_var_3",
                "local_58": "local_var_4",
                "local_48": "local_var_5",
                "local_38": "local_var_6",
                "local_28": "local_var_7",
                "local_18": "local_var_8"
            },
            "code": "\nvoid print_error_and_exit_00119dd0(undefined4 error_code,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                 undefined8 error_message,undefined8 error_code0,undefined8 error_code1,undefined8 error_code2,\n                 undefined8 error_code3,undefined8 error_code4)\n\n{\n  char condition;\n  undefined4 buffer_size;\n  undefined4 local_variable_1;\n  undefined *buffer_pointer;\n  undefined *local_variable_2;\n  undefined local_array [8];\n  undefined8 param_10_copy;\n  undefined8 param_11_copy;\n  undefined8 param_12_copy;\n  undefined8 param_13_copy;\n  undefined8 param_14_copy;\n  undefined4 local_var_1;\n  undefined4 local_var_2;\n  undefined4 local_var_3;\n  undefined4 local_var_4;\n  undefined4 local_var_5;\n  undefined4 local_var_6;\n  undefined4 local_var_7;\n  undefined4 local_var_8;\n  \n  if (condition != '\\0') {\n    local_var_1 = error_code;\n    local_var_2 = param_2;\n    local_var_3 = param_3;\n    local_var_4 = param_4;\n    local_var_5 = param_5;\n    local_var_6 = param_6;\n    local_var_7 = param_7;\n    local_var_8 = param_8;\n  }\n  buffer_pointer = &stack0x00000008;\n  buffer_size = 8;\n  local_variable_2 = local_array;\n  local_variable_1 = 0x30;\n  param_10_copy = error_code0;\n  param_11_copy = error_code1;\n  param_12_copy = error_code2;\n  param_13_copy = error_code3;\n  param_14_copy = error_code4;\n  print_error_message_00119e70(error_message,&buffer_size);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "FUN_00119e70",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00119dd0",
            "calling": [
                "FUN_001083de",
                "FUN_0010554f",
                "FUN_00104ad6",
                "FUN_00114460",
                "FUN_0010543c",
                "FUN_00114dc7",
                "FUN_0010827b",
                "FUN_00108808",
                "FUN_00116b90",
                "FUN_00114690",
                "FUN_001053b5",
                "FUN_00108d9a",
                "FUN_00115b70",
                "FUN_00114190",
                "FUN_00104920",
                "FUN_0010da0b"
            ],
            "imported": false,
            "current_name": "print_error_and_exit_00119dd0"
        },
        "bfd_iterate_over_targets": {
            "renaming": {},
            "code": "\nvoid bfd_iterate_over_targets(void)\n\n{\n  bfd_iterate_over_targets();\n  return;\n}\n\n",
            "called": [
                "bfd_iterate_over_targets"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104620",
            "calling": [
                "FUN_001199d0"
            ],
            "imported": false,
            "current_name": "bfd_iterate_over_targets"
        },
        "bfd_get_full_section_contents": {
            "renaming": {},
            "code": "\nvoid bfd_get_full_section_contents(void)\n\n{\n  bfd_get_full_section_contents();\n  return;\n}\n\n",
            "called": [
                "bfd_get_full_section_contents"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104440",
            "calling": [
                "FUN_00116110",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "bfd_get_full_section_contents"
        },
        "bfd_hash_newfunc": {
            "renaming": {},
            "code": "\nvoid bfd_hash_newfunc(void)\n\n{\n  bfd_hash_newfunc();\n  return;\n}\n\n",
            "called": [
                "bfd_hash_newfunc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104200",
            "calling": [
                "FUN_0010bb52"
            ],
            "imported": false,
            "current_name": "bfd_hash_newfunc"
        },
        "FUN_001083b7": {
            "renaming": {
                "FUN_001083b7": "handle_error_001083b7",
                "param_1": "error_code",
                "unaff_RBP": "error_message",
                "unaff_retaddr": "return_address",
                "iVar1": "bfd_error"
            },
            "code": "\nundefined8 handle_error_001083b7(long error_code)\n\n{\n  int bfd_error;\n  undefined8 *error_message;\n  undefined8 return_address;\n  \n  if (error_code == -1) {\n    bfd_error = bfd_get_error();\n    if (bfd_error == 5) {\n      return return_address;\n    }\n  }\n  print_error_message_0011a110(*error_message);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "FUN_0011a110",
                "bfd_get_error",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001083b7",
            "calling": [
                "FUN_00116030"
            ],
            "imported": false,
            "current_name": "handle_error_001083b7"
        },
        "FUN_00116852": {
            "renaming": {
                "FUN_00116852": "process_data_00116852",
                "in_RCX": "array",
                "in_R11": "arrayLength",
                "in_R10": "currentIndex",
                "unaff_RBP": "currentRecord",
                "unaff_RBX": "minSize",
                "unaff_R13": "arrayStart",
                "unaff_R14": "currentRecordPtr",
                "unaff_R15": "maxSize",
                "param_7": "currentSize",
                "param_9": "targetSize",
                "param_10": "finalSize",
                "param_11": "recordArray",
                "param_12": "output",
                "param_13": "context",
                "param_14": "recordCount",
                "bVar14": "byteFlag",
                "uVar4": "counter",
                "uVar5": "currentRecordSize",
                "uVar6": "currentMaxSize",
                "uVar8": "currentMinSize",
                "sVar1": "currentRecordType",
                "iVar3": "comparisonResult",
                "lVar7": "loopIndex",
                "__ptr": "dynamicArray"
            },
            "code": "\nulong processData_00116852(void)\n\n{\n  size_t currentRecordType;\n  code *pcVar2;\n  int comparisonResult;\n  uint counter;\n  undefined *dynamicArray;\n  size_t *array;\n  ulong currentRecordSize;\n  ulong currentMaxSize;\n  long loopIndex;\n  ulong currentMinSize;\n  size_t minSize;\n  size_t *currentRecord;\n  undefined *puVar9;\n  char cVar10;\n  undefined *puVar11;\n  ulong currentIndex;\n  undefined *puVar12;\n  size_t arrayLength;\n  size_t *arrayStart;\n  size_t *currentRecordPtr;\n  size_t maxSize;\n  size_t *pcurrentRecordType3;\n  byte byteFlag;\n  size_t currentSize;\n  size_t targetSize;\n  ulong finalSize;\n  size_t *recordArray;\n  undefined *output;\n  long context;\n  size_t recordCount;\n  \n  byteFlag = 0;\ncode_r0x00116852:\n  counter = (int)currentIndex + 1;\n  if (0x10 < (int)currentIndex) goto LAB_001167f5;\nLAB_00116863:\n  currentRecordPtr = currentRecordPtr + -9;\n  do {\n    if (arrayStart <= currentRecordPtr) {\n      currentRecordType = currentRecordPtr[2];\n      if (currentRecordType == 0) goto LAB_00116863;\n      currentMinSize = (ulong)counter;\n      if ((*currentRecordPtr == *currentRecord) &&\n         (comparisonResult = memcmp((void *)currentRecordPtr[3],(void *)currentRecord[3],*currentRecord), comparisonResult == 0)) {\n        currentMaxSize = currentRecordPtr[7];\n        currentRecordSize = currentRecordPtr[8];\n        currentIndex = currentMinSize & 0xffffffff;\n        if (maxSize == currentMaxSize) {\n          if (minSize != currentRecordSize) goto LAB_001167a6;\n          currentRecord[2] = 0;\n        }\n        else {\n          if (maxSize < currentMaxSize) {\n            if (currentRecordSize < maxSize) {\nLAB_0010852c:\n              if ((0xfffffffffffffff0 < currentRecordSize) || (maxSize <= (currentRecordSize + 0xf & 0xfffffffffffffff0)))\n              goto code_r0x00116852;\n            }\n            else if (minSize < maxSize) {\n              if ((0xfffffffffffffff0 < minSize) ||\n                 (currentMaxSize <= (minSize + 0xf & 0xfffffffffffffff0))) goto code_r0x00116852;\n            }\n            else if (minSize == currentRecordSize) goto code_r0x00116852;\n          }\n          else {\nLAB_001167a6:\n            if (minSize <= currentRecordSize) {\n              currentRecord[2] = 0;\n              goto LAB_001167f5;\n            }\n            if (currentRecordSize < maxSize) goto LAB_0010852c;\n          }\n          if ((arrayLength == 0x101) != (currentRecordType == 0x101)) goto code_r0x00116852;\n          if (currentRecordSize <= minSize) {\n            currentRecordSize = minSize;\n          }\n          if (currentMaxSize < maxSize) {\n            maxSize = currentMaxSize;\n          }\n          currentRecordPtr[8] = currentRecordSize;\n          currentRecordPtr[7] = maxSize;\n          currentRecord[2] = 0;\n        }\n      }\n    }\nLAB_001167f5:\n    while( true ) {\n      do {\n        currentRecordPtr = currentRecord;\n        currentRecord = currentRecordPtr + 9;\n        if (array <= currentRecord) {\n          qsort(recordArray,recordCount,0x48,compare_records_0011a250);\n          dynamicArray = (undefined *)xmalloc(finalSize * 2);\n          currentSize = 0;\n          puVar12 = dynamicArray;\n          for (pcurrentRecordType3 = recordArray; pcurrentRecordType3 < array; pcurrentRecordType3 = pcurrentRecordType3 + 9) {\n            if (pcurrentRecordType3[2] != 0) {\n              puVar11 = puVar12 + 4;\n              puVar9 = puVar12 + 0xc;\n              pcVar2 = *(code **)(*(long *)(context + 8) + 0x50);\n              if ((pcurrentRecordType3[7] == targetSize) && (pcurrentRecordType3[8] == currentSize)) {\n                (*pcVar2)(*pcurrentRecordType3,puVar12);\n                (**(code **)(*(long *)(context + 8) + 0x50))(0,puVar11);\n                (**(code **)(*(long *)(context + 8) + 0x50))(pcurrentRecordType3[2],puVar12 + 8);\n                currentMaxSize = pcurrentRecordType3[6];\n                currentMinSize = *pcurrentRecordType3;\n                puVar12 = (undefined *)pcurrentRecordType3[3];\n                puVar11 = puVar9;\n                for (currentRecordSize = currentMinSize; currentRecordSize != 0; currentRecordSize = currentRecordSize - 1) {\n                  *puVar11 = *puVar12;\n                  puVar12 = puVar12 + (ulong)byteFlag * -2 + 1;\n                  puVar11 = puVar11 + (ulong)byteFlag * -2 + 1;\n                }\n                if (currentMinSize < currentMaxSize) {\n                  for (loopIndex = currentMaxSize - currentMinSize; loopIndex != 0; loopIndex = loopIndex + -1) {\n                    *puVar11 = 0;\n                    puVar11 = puVar11 + (ulong)byteFlag * -2 + 1;\n                  }\n                }\n                puVar12 = puVar9 + currentMaxSize;\n              }\n              else {\n                (*pcVar2)();\n                if (*(int *)(*(long *)(context + 8) + 8) == 5) {\n                  cVar10 = (*(char *)(*(long *)(context + 0x110) + 4) == '\\x02') * '\\b' + '\\b';\n                }\n                else {\n                  cVar10 = '\\b';\n                }\n                (**(code **)(*(long *)(context + 8) + 0x50))(cVar10,puVar11);\n                (**(code **)(*(long *)(context + 8) + 0x50))(pcurrentRecordType3[2],puVar12 + 8);\n                currentMinSize = *pcurrentRecordType3;\n                puVar12 = (undefined *)pcurrentRecordType3[3];\n                puVar11 = puVar9;\n                for (currentMaxSize = currentMinSize; currentMaxSize != 0; currentMaxSize = currentMaxSize - 1) {\n                  *puVar11 = *puVar12;\n                  puVar12 = puVar12 + (ulong)byteFlag * -2 + 1;\n                  puVar11 = puVar11 + (ulong)byteFlag * -2 + 1;\n                }\n                currentMaxSize = pcurrentRecordType3[6];\n                if (currentMinSize < currentMaxSize) {\n                  for (loopIndex = currentMaxSize - currentMinSize; loopIndex != 0; loopIndex = loopIndex + -1) {\n                    *puVar11 = 0;\n                    puVar11 = puVar11 + (ulong)byteFlag * -2 + 1;\n                  }\n                }\n                loopIndex = *(long *)(context + 8);\n                puVar9 = puVar9 + currentMaxSize;\n                puVar12 = puVar9 + 8;\n                if ((*(int *)(loopIndex + 8) == 5) &&\n                   (*(char *)(*(long *)(context + 0x110) + 4) == '\\x02')) {\n                  (**(code **)(loopIndex + 0x38))(pcurrentRecordType3[7],puVar9);\n                  (**(code **)(*(long *)(context + 8) + 0x38))(pcurrentRecordType3[8],puVar12);\n                  puVar12 = puVar9 + 0x10;\n                }\n                else {\n                  (**(code **)(loopIndex + 0x50))(pcurrentRecordType3[7],puVar9);\n                  (**(code **)(*(long *)(context + 8) + 0x50))(pcurrentRecordType3[8],puVar9 + 4);\n                }\n                targetSize = pcurrentRecordType3[7];\n                currentSize = pcurrentRecordType3[8];\n              }\n            }\n          }\n          currentMaxSize = (long)puVar12 - (long)dynamicArray;\n          currentMinSize = currentMaxSize;\n          puVar12 = dynamicArray;\n          if (currentMaxSize < finalSize) {\n            for (; finalSize = currentMaxSize, currentMinSize != 0; currentMinSize = currentMinSize - 1) {\n              *output = *puVar12;\n              puVar12 = puVar12 + (ulong)byteFlag * -2 + 1;\n              output = output + (ulong)byteFlag * -2 + 1;\n            }\n          }\n          free(dynamicArray);\n          free(recordArray);\n          return finalSize;\n        }\n        arrayLength = currentRecordPtr[0xb];\n      } while (arrayLength == 0);\n      maxSize = currentRecordPtr[0x10];\n      minSize = currentRecordPtr[0x11];\n      counter = 0;\n      if (maxSize != minSize) break;\n      currentRecordPtr[0xb] = 0;\n    }\n  } while( true );\n}\n\n",
            "called": [
                "qsort",
                "FUN_00116852",
                "free",
                "xmalloc",
                "memcmp",
                "FUN_0011a250"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116852",
            "calling": [
                "FUN_00116852"
            ],
            "imported": false,
            "current_name": "process_data_00116852"
        },
        "FUN_00113d3a": {
            "renaming": {
                "FUN_00113d3a": "initialize_data_00113d3a",
                "param_1": "input",
                "lVar1": "result"
            },
            "code": "\nlong initialize_data_00113d3a(long input)\n\n{\n  long result;\n  \n  if (input != 0) {\n    result = *(long *)(input + 8);\n    if (result == 0) {\n      result = initialize_data_00113d3a_00112904(0xc,0);\n      if (result == 0) {\n        result = 0;\n      }\n      else {\n        *(long *)(result + 0x10) = input;\n        *(long *)(input + 8) = result;\n      }\n    }\n    return result;\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113d3a",
            "calling": [
                "FUN_0011173a",
                "FUN_0010c95e",
                "FUN_0010ee3f",
                "FUN_0010b0fa",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "initialize_data_00113d3a"
        },
        "bfd_hash_lookup": {
            "renaming": {},
            "code": "\nvoid bfd_hash_lookup(void)\n\n{\n  bfd_hash_lookup();\n  return;\n}\n\n",
            "called": [
                "bfd_hash_lookup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104560",
            "calling": [
                "FUN_0010e6a8",
                "FUN_0010e2f0",
                "FUN_0010bba1"
            ],
            "imported": false,
            "current_name": "bfd_hash_lookup"
        },
        "chmod": {
            "renaming": {},
            "code": "\n\n\nint chmod(char *__file,__mode_t __mode)\n\n{\n  int iVar1;\n  \n  iVar1 = chmod(__file,__mode);\n  return iVar1;\n}\n\n",
            "called": [
                "chmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001046d0",
            "calling": [
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "chmod"
        },
        "htab_delete": {
            "renaming": {},
            "code": "\nvoid htab_delete(void)\n\n{\n  htab_delete();\n  return;\n}\n\n",
            "called": [
                "htab_delete"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104090",
            "calling": [
                "FUN_001054af"
            ],
            "imported": false,
            "current_name": "htab_delete"
        },
        "htab_traverse": {
            "renaming": {},
            "code": "\nvoid htab_traverse(void)\n\n{\n  htab_traverse();\n  return;\n}\n\n",
            "called": [
                "htab_traverse"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104580",
            "calling": [
                "FUN_0010554f",
                "FUN_00115d70"
            ],
            "imported": false,
            "current_name": "htab_traverse"
        },
        "FUN_0010a0d3": {
            "renaming": {
                "FUN_0010a0d3": "process_data_0010a0d3",
                "param_1": "data"
            },
            "code": "\nvoid process_data_0010a0d3(long data)\n\n{\n  process_data_0010a0d3_00109ed3(data,0x42,*(undefined4 *)(*(long *)(data + 0x60) + 0x18),0,0);\n  return;\n}\n\n",
            "called": [
                "FUN_00109ed3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a0d3",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "process_data_0010a0d3"
        },
        "FUN_00115530": {
            "renaming": {
                "FUN_00115530": "parse_and_create_output_section_00115530",
                "param_1": "param",
                "param_2": "sectionData",
                "param_3": "outputFile",
                "lVar1": "sectionIndex",
                "pcVar2": "sectionName",
                "ppcVar3": "sharedLibraryData",
                "cVar4": "result",
                "iVar5": "comparisonResult",
                "uVar6": "updatedFlag",
                "sVar7": "sectionNameLength",
                "sVar8": "localNameLength",
                "lVar9": "parsedRules",
                "pcVar10": "outputSection",
                "pcVar11": "sectionElement",
                "pcVar12": "processedSection",
                "uVar13": "sectionFlags",
                "bVar14": "conditionFlag",
                "local_50": "errorMessage",
                "local_48": "processedSectionName",
                "local_40": "sectionSize"
            },
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\n\nvoid parseAndCreateOutputSection_00115530(long param,char **sectionData,long outputFile)\n\n{\n  long sectionIndex;\n  char *sectionName;\n  char **sharedLibraryData;\n  char result;\n  int comparisonResult;\n  uint updatedFlag;\n  size_t sectionNameLength;\n  size_t localNameLength;\n  long parsedRules;\n  char *outputSection;\n  char *sectionElement;\n  char *processedSection;\n  uint sectionFlags;\n  bool conditionFlag;\n  long errorMessage;\n  char *processedSectionName;\n  long sectionSize [2];\n  \n  result = process_section_data_001159d0(sectionData);\n  if (result != '\\0') {\n    return;\n  }\n  outputSection = *sectionData;\n  sectionFlags = *(uint *)((long)sectionData + 0x24);\n  processedSectionName = outputSection;\n  sharedLibraryData = DAT_001278d8;\n  if (*(int *)(*(long *)(param + 8) + 8) != *(int *)(*(long *)(outputFile + 8) + 8)) {\n    sectionFlags = sectionFlags & *(uint *)(*(long *)(param + 8) + 0x18) &\n             *(uint *)(*(long *)(outputFile + 8) + 0x18);\n  }\n  for (; sharedLibraryData != (char **)0x0; sharedLibraryData = (char **)sharedLibraryData[3]) {\n    comparisonResult = strcmp(*sharedLibraryData,outputSection);\n    if (comparisonResult == 0) {\n      if (*(uint *)(sharedLibraryData + 2) != 0xffffffff) {\n        sectionFlags = *(uint *)(sharedLibraryData + 2);\n      }\n      if (outputSection != sharedLibraryData[1]) {\n        processedSectionName = sharedLibraryData[1];\n        sectionFlags = drop_share_flag_if_not_coff_00115f30(sectionFlags,outputFile);\n      }\n      break;\n    }\n  }\n  if (((DAT_001278f8 != (char *)0x0) &&\n      (outputSection = DAT_001278f8, (*(byte *)((long)sectionData + 0x24) & 1) != 0)) ||\n     (outputSection = DAT_00127900, DAT_00127900 != (char *)0x0)) {\n    sectionNameLength = strlen(outputSection);\n    localNameLength = strlen(processedSectionName);\n    processedSection = (char *)xmalloc(sectionNameLength + 1 + localNameLength);\n    outputSection = strcpy(processedSection,outputSection);\n    processedSectionName = strcat(outputSection,processedSectionName);\n  }\n  parsedRules = parse_rules_00114190(*sectionData,0,0x80);\n  conditionFlag = false;\n  if (parsedRules == 0) {\n    if ((DAT_00127a2c == 4) && ((sectionFlags & 0x2000001) != 0)) {\n      comparisonResult = *(int *)(*(long *)(param + 8) + 8);\n      if (comparisonResult == 5) {\n        if (*(int *)(sectionData[0x1a] + 4) != 7) {\nLAB_00115771:\n          if (*(int *)(*(long *)(outputFile + 8) + 8) == 5) {\n            conditionFlag = (sectionFlags & 0x2000000) == 0;\n            updatedFlag = ~((-(uint)((sectionFlags & 0x2000000) == 0) & 0x2000100) + 2);\n            *(uint *)((long)sectionData + 0x24) = *(uint *)((long)sectionData + 0x24) & updatedFlag;\n          }\n          else {\n            updatedFlag = 0xfdfffefd;\n          }\n          sectionFlags = sectionFlags & updatedFlag;\n        }\n      }\n      else if ((comparisonResult != 2) || (comparisonResult = strcmp(*sectionData,\".buildid\"), comparisonResult != 0)) goto LAB_00115771;\n    }\n  }\n  else {\n    sectionFlags = drop_share_flag_if_not_coff_00115f30(sectionFlags & 0x104 | *(uint *)(parsedRules + 0x28),outputFile,*sectionData);\n  }\n  result = bfd_convert_section_setup(param,sectionData,outputFile,&processedSectionName,sectionSize);\n  if (result == '\\0') {\n    outputSection = (char *)0x0;\n    errorMessage = dcgettext(0,\"failed to create output section\",5);\n    goto LAB_001080d1;\n  }\n  outputSection = (char *)bfd_make_section_anyway_with_flags(outputFile,processedSectionName,sectionFlags);\n  if (outputSection == (char *)0x0) {\n    errorMessage = dcgettext(0,\"failed to create output section\",5);\n    goto LAB_001080d1;\n  }\n  if (DAT_001264bc < 0) {\n    if (DAT_001278ec != '\\0') {\n      sectionSize[0] = 0;\n      goto LAB_001158e7;\n    }\n    result = bfd_set_section_size(outputSection,sectionSize[0]);\n    if (result == '\\0') {\n      set_alignment_and_size_00108072();\n      return;\n    }\n  }\n  else {\n    sectionSize[0] = ((((long)DAT_00127a1c - 1U) + sectionSize[0]) / (ulong)(long)DAT_00127a1c) *\n                  (long)DAT_001264b8;\nLAB_001158e7:\n    result = bfd_set_section_size(outputSection);\n    if (result == '\\0') {\n      set_alignment_and_size_00108072();\n      return;\n    }\n  }\n  errorMessage = 0;\n  processedSection = sectionData[6];\n  parsedRules = parse_rules_00114190(*sectionData,0,0x18);\n  if (parsedRules == 0) {\n    outputSection[0x28] = outputSection[0x28] | 1;\n    sectionElement = *sectionData;\n    processedSection = processedSection + _DAT_00127990;\n    *(char **)(outputSection + 0x30) = processedSection;\n    *(char **)(outputSection + 0x38) = processedSection;\n    processedSection = sectionData[7];\n    parsedRules = parse_rules_00114190(sectionElement,0,0x60);\n    if (parsedRules == 0) goto LAB_00115695;\nLAB_00115860:\n    sectionElement = *(char **)(parsedRules + 0x20);\n    if ((*(byte *)(parsedRules + 0x14) & 0x40) != 0) {\n      sectionElement = sectionElement + (long)processedSection;\n    }\n    *(char **)(outputSection + 0x38) = sectionElement;\n    parsedRules = parse_rules_00114190(*sectionData,0,0x200);\n    if (parsedRules != 0) goto LAB_00115889;\nLAB_001156b8:\n    sectionFlags = *(uint *)((long)sectionData + 0x7c);\n    if (sectionFlags < 0x3f) goto LAB_001156c4;\n    errorMessage = dcgettext(0,\"failed to set alignment\",5);\n    *(undefined4 *)(outputSection + 0xb4) = *(undefined4 *)((long)sectionData + 0xb4);\n    outputSection[0x28] = outputSection[0x28] & 0xcfU | *(byte *)(sectionData + 5) & 0x30;\n    sectionData[0xc] = outputSection;\n    sectionData[0xb] = (char *)0x0;\n    if ((*(byte *)((long)sectionData + 0x27) & 2) != 0) goto LAB_001157c8;\nLAB_00115700:\n    result = (**(code **)(*(long *)(outputFile + 8) + 0x158))(param,sectionData,outputFile,outputSection);\n    if (result == '\\0') {\n      copy_private_data_0010808f();\n      return;\n    }\n  }\n  else {\n    sectionElement = *(char **)(parsedRules + 0x18);\n    if ((*(byte *)(parsedRules + 0x14) & 8) == 0) {\n      sectionElement = sectionElement + (long)processedSection;\n    }\n    outputSection[0x28] = outputSection[0x28] | 1;\n    sectionName = *sectionData;\n    *(char **)(outputSection + 0x30) = sectionElement;\n    *(char **)(outputSection + 0x38) = sectionElement;\n    processedSection = sectionData[7];\n    parsedRules = parse_rules_00114190(sectionName,0,0x60);\n    if (parsedRules != 0) goto LAB_00115860;\nLAB_00115695:\n    sectionElement = *sectionData;\n    *(char **)(outputSection + 0x38) = processedSection + _DAT_00127990;\n    parsedRules = parse_rules_00114190(sectionElement,0,0x200);\n    if (parsedRules == 0) goto LAB_001156b8;\nLAB_00115889:\n    sectionFlags = *(uint *)(parsedRules + 0x2c);\n    if (0x3e < sectionFlags) {\n      initialize_alignment_00108179();\n      return;\n    }\nLAB_001156c4:\n    *(uint *)(outputSection + 0x7c) = sectionFlags;\n    *(undefined4 *)(outputSection + 0xb4) = *(undefined4 *)((long)sectionData + 0xb4);\n    outputSection[0x28] = outputSection[0x28] & 0xcfU | *(byte *)(sectionData + 5) & 0x30;\n    sectionData[0xc] = outputSection;\n    sectionData[0xb] = (char *)0x0;\n    if ((*(byte *)((long)sectionData + 0x27) & 2) == 0) goto LAB_00115700;\nLAB_001157c8:\n    processedSection = sectionData[0x1a];\n    parsedRules = find_element_in_array_00115d00(processedSection,sectionData[0x1c]);\n    if ((parsedRules == 0) ||\n       (sectionIndex = *(long *)(param + 8), *(uint *)(parsedRules + 0x18) = *(uint *)(parsedRules + 0x18) | 0x20,\n       *(int *)(sectionIndex + 8) != 5)) goto LAB_00115700;\n    *(long *)(processedSection + 0xb0) = parsedRules;\n    result = (**(code **)(*(long *)(outputFile + 8) + 0x158))(param,sectionData,outputFile,outputSection);\n    if (result == '\\0') {\n      copy_private_data_0010808f();\n      return;\n    }\n  }\n  if (conditionFlag) {\n    *(undefined4 *)(*(long *)(outputSection + 0xd0) + 4) = 8;\n  }\n  if (errorMessage == 0) {\n    return;\n  }\nLAB_001080d1:\n  DAT_00127a20 = 1;\n  display_error_001126c0(0,outputFile,outputSection,errorMessage);\n  return;\n}\n\n",
            "called": [
                "strcmp",
                "FUN_00115f30",
                "strlen",
                "dcgettext",
                "xmalloc",
                "bfd_convert_section_setup",
                "strcat",
                "FUN_00108072",
                "bfd_make_section_anyway_with_flags",
                "FUN_001159d0",
                "strcpy",
                "FUN_00114190",
                "bfd_set_section_size"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115530",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "parse_and_create_output_section_00115530"
        },
        "FUN_0010a0bd": {
            "renaming": {
                "FUN_0010a0bd": "process_and_send_data_0010a0bd",
                "param_1": "data_ptr",
                "process_data_00109ed3": "process_data"
            },
            "code": "\nvoid process_and_send_data_0010a0bd(long data_ptr)\n\n{\n  process_data(data_ptr,0x6b,*(undefined4 *)(*(long *)(data_ptr + 0x60) + 0x18),0,0);\n  return;\n}\n\n",
            "called": [
                "FUN_00109ed3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a0bd",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "process_and_send_data_0010a0bd"
        },
        "FUN_00113e5e": {
            "renaming": {
                "FUN_00113e5e": "validate_and_execute_00113e5e",
                "param_1": "input",
                "param_2": "argv",
                "param_3": "arg_count",
                "cVar1": "comparison_result",
                "local_20": "temp"
            },
            "code": "\nundefined8 validate_and_execute_00113e5e(undefined8 input,char **argv,long arg_count)\n\n{\n  char comparison_result;\n  char *temp [2];\n  \n  temp[0] = *argv;\n  *argv = (char *)(arg_count + 2);\n  if ((((long)(char *)(arg_count + 2) - (long)temp[0] < 5) ||\n      (comparison_result = compare_strings_00113fb0(temp[0],\"type\"), comparison_result == '\\0')) ||\n     ((temp[0][4] != '$' && (temp[0][4] != '.')))) {\n    if (*temp[0] != '_') {\n      return 1;\n    }\n    if (temp[0][1] != '_') {\n      return 1;\n    }\n    if (temp[0][2] != 'o') {\n      return 1;\n    }\n    if (temp[0][3] != 'p') {\n      return 1;\n    }\n    temp[0] = temp[0] + 4;\n  }\n  else {\n    temp[0] = temp[0] + 5;\n  }\n  comparison_result = parse_initialize_data_0010c95e(input,temp,0);\n  if (comparison_result != '\\0') {\n    return 1;\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00113fb0",
                "FUN_0010c95e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113e5e",
            "calling": [
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "validate_and_execute_00113e5e",
            "code_backup": "\nundefined8 FUN_00113e5e(undefined8 param_1,char **param_2,long param_3)\n\n{\n  char cVar1;\n  char *local_20 [2];\n  \n  local_20[0] = *param_2;\n  *param_2 = (char *)(param_3 + 2);\n  if ((((long)(char *)(param_3 + 2) - (long)local_20[0] < 5) ||\n      (cVar1 = compare_strings_00113fb0(local_20[0],\"type\"), cVar1 == '\\0')) ||\n     ((local_20[0][4] != '$' && (local_20[0][4] != '.')))) {\n    if (*local_20[0] != '_') {\n      return 1;\n    }\n    if (local_20[0][1] != '_') {\n      return 1;\n    }\n    if (local_20[0][2] != 'o') {\n      return 1;\n    }\n    if (local_20[0][3] != 'p') {\n      return 1;\n    }\n    local_20[0] = local_20[0] + 4;\n  }\n  else {\n    local_20[0] = local_20[0] + 5;\n  }\n  cVar1 = FUNC_0010c95e(param_1,local_20,0);\n  if (cVar1 != '\\0') {\n    return 1;\n  }\n  return 0;\n}\n\n"
        },
        "FUN_0010abdd": {
            "renaming": {
                "FUN_0010abdd": "format_and_store_string_data_0010abdd",
                "param_1": "paramPointer",
                "param_2": "string1",
                "param_3": "stringIndex",
                "param_4": "flag1",
                "param_5": "flag2",
                "param_6": "flag3",
                "param_7": "param7",
                "param_8": "flag4",
                "lVar1": "localVar1",
                "pcVar2": "string2",
                "bVar3": "byteVar",
                "pcVar4": "string3",
                "__s": "additionalString",
                "sVar5": "length1",
                "sVar6": "length2",
                "sVar7": "length3",
                "sVar8": "additionalStringLength",
                "uVar9": "result",
                "cVar10": "charVar1",
                "cVar11": "charVar2",
                "local_52": "localByteVar"
            },
            "code": "\nundefined8\nformatAndStoreStringData_0010abdd(long paramPointer,char *string1,uint stringIndex,char flag1,char flag2,char flag3,\n            undefined8 param7,char flag4)\n\n{\n  long localVar1;\n  char *string2;\n  byte byteVar;\n  char *string3;\n  char *additionalString;\n  size_t length1;\n  size_t length2;\n  size_t length3;\n  size_t additionalStringLength;\n  undefined8 result;\n  char charVar1;\n  char charVar2;\n  byte localByteVar;\n  \n  additionalString = (char *)0x0;\n  localByteVar = *(byte *)(*(long *)(paramPointer + 0x60) + 0x1c);\n  string3 = (char *)extract_list_item_00109b2f();\n  if (flag4 != '\\0') {\n    byteVar = 1;\n    if (localByteVar == 0) {\n      byteVar = *(byte *)(*(long *)(paramPointer + 0x60) + 0x1c);\n    }\n    localByteVar = byteVar & 1;\n    additionalString = (char *)extract_list_item_00109b2f(paramPointer);\n  }\n  localVar1 = *(long *)(paramPointer + 0x60);\n  if ((localVar1 == 0) || (string2 = *(char **)(localVar1 + 0x30), string2 == (char *)0x0)) {\n    result = 0;\n  }\n  else {\n    if (2 < stringIndex) {\n                    \n      abort();\n    }\n    if (flag2 == '\\0') {\n      charVar2 = (-(flag3 == '\\0') & 0xfeU) + 0x43;\n    }\n    else {\n      charVar2 = (-(flag3 == '\\0') & 0xfeU) + 0x44;\n    }\n    charVar1 = '?';\n    if (flag1 == '\\0') {\n      charVar1 = (-(flag4 == '\\0') & 4U) + 0x2a;\n    }\n    length1 = strlen(string2);\n    length2 = strlen(string3);\n    length3 = strlen(string1);\n    additionalStringLength = 0;\n    if (flag4 != '\\0') {\n      additionalStringLength = strlen(additionalString);\n    }\n    result = xrealloc(string2,length3 + length1 + 0x28 + length2 + additionalStringLength);\n    *(undefined8 *)(localVar1 + 0x30) = result;\n    string2 = *(char **)(*(long *)(paramPointer + 0x60) + 0x30);\n    length1 = strlen(string2);\n    sprintf(string2 + length1,\"%s:%s;%c%c%c\",string3,string1,(ulong)(byte)(0x32 - (char)stringIndex),\n            (ulong)(uint)(int)charVar2,(ulong)(uint)(int)charVar1,length1);\n    free(string3);\n    if (flag4 != '\\0') {\n      string3 = *(char **)(*(long *)(paramPointer + 0x60) + 0x30);\n      length1 = strlen(string3);\n      sprintf(string3 + length1,\"%ld;%s;\",param7,additionalString);\n      free(additionalString);\n    }\n    if (localByteVar != 0) {\n      *(undefined *)(*(long *)(paramPointer + 0x60) + 0x1c) = 1;\n    }\n    result = 1;\n  }\n  return result;\n}\n\n",
            "called": [
                "abort",
                "xrealloc",
                "strlen",
                "free",
                "sprintf",
                "FUN_00109b2f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010abdd",
            "calling": [
                "FUN_0010add5",
                "FUN_0010adf2"
            ],
            "imported": false,
            "current_name": "format_and_store_string_data_0010abdd"
        },
        "FUN_00115f30": {
            "renaming": {
                "FUN_00115f30": "drop_share_flag_if_not_coff_00115f30",
                "param_1": "flags",
                "param_2": "pointers",
                "param_3": "value",
                "uVar1": "param_2_value",
                "uVar2": "errorMessage",
                "print_error_message_00119ed0": "printErrorMessage",
                "dcgettext": "translateText"
            },
            "code": "\nuint dropShareFlagIfNotCOFF_00115f30(uint flags,undefined8 *pointers,undefined8 value)\n\n{\n  undefined8 param_2_value;\n  undefined8 errorMessage;\n  \n  if (((flags & 0x8000000) != 0) && (*(int *)(pointers[1] + 8) != 2)) {\n    param_2_value = *pointers;\n    flags = flags & 0xf7ffffff;\n    errorMessage = dcgettext(0,\"%s[%s]: Note - dropping \\'share\\' flag as output format is not COFF\",5);\n    printErrorMessage(errorMessage,param_2_value,value);\n  }\n  return flags;\n}\n\n",
            "called": [
                "FUN_00108375"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115f30",
            "calling": [
                "FUN_00115530",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "drop_share_flag_if_not_coff_00115f30"
        },
        "dup": {
            "renaming": {},
            "code": "\n\n\nint dup(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = dup(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "dup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001042d0",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "dup"
        },
        "cplus_demangle_print": {
            "renaming": {},
            "code": "\nvoid cplus_demangle_print(void)\n\n{\n  cplus_demangle_print();\n  return;\n}\n\n",
            "called": [
                "cplus_demangle_print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104050",
            "calling": [
                "FUN_0010b0fa"
            ],
            "imported": false,
            "current_name": "cplus_demangle_print"
        },
        "bfd_close": {
            "renaming": {},
            "code": "\nvoid bfd_close(void)\n\n{\n  bfd_close();\n  return;\n}\n\n",
            "called": [
                "bfd_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104908",
            "calling": [
                "FUN_00104ea2",
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "bfd_close"
        },
        "_FINI_0": {
            "renaming": {},
            "code": "\nvoid _FINI_0(void)\n\n{\n  if (DAT_001275c0 != '\\0') {\n    return;\n  }\n  __cxa_finalize(PTR_LOOP_00126468);\n  FUNC_00116ad0();\n  DAT_001275c0 = 1;\n  return;\n}\n\n",
            "called": [
                "__cxa_finalize",
                "FUN_00116ad0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116b40",
            "calling": [],
            "imported": false,
            "current_name": "_FINI_0"
        },
        "FUN_001129f4": {
            "renaming": {
                "FUN_001129f4": "extract_data_from_binary_001129f4",
                "param_1": "input",
                "puVar1": "dataPointer",
                "piVar2": "currPointer"
            },
            "code": "\nundefined8 extractDataFromBinary_001129f4(int *input)\n\n{\n  undefined8 *dataPointer;\n  int *currPointer;\n  \n  do {\n    if (*input != 1) {\n      if (1 < *input - 0x16U) {\n        return 0;\n      }\n      return *(undefined8 *)(**(long **)(input + 4) + 8);\n    }\n    dataPointer = (undefined8 *)(input + 4);\n    currPointer = **(int ***)(undefined8 *)*dataPointer;\n  } while ((input != currPointer) && (input = currPointer, currPointer != (int *)0x0));\n  return ((undefined8 *)*dataPointer)[1];\n}\n\n",
            "called": [
                "FUN_001129f4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001129f4",
            "calling": [
                "FUN_0010d559",
                "FUN_0010ee3f",
                "FUN_001129f4",
                "FUN_00112b6e",
                "FUN_0010b0fa"
            ],
            "imported": false,
            "current_name": "extract_data_from_binary_001129f4"
        },
        "strchr": {
            "renaming": {},
            "code": "\n\n\nchar * strchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strchr(__s,__c);\n  return pcVar1;\n}\n\n",
            "called": [
                "strchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104290",
            "calling": [
                "FUN_0011173a",
                "FUN_00116b90",
                "FUN_00104ad6",
                "FUN_0010ee3f",
                "FUN_00114c80"
            ],
            "imported": false,
            "current_name": "strchr"
        },
        "rmdir": {
            "renaming": {},
            "code": "\n\n\nint rmdir(char *__path)\n\n{\n  int iVar1;\n  \n  iVar1 = rmdir(__path);\n  return iVar1;\n}\n\n",
            "called": [
                "rmdir"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104230",
            "calling": [
                "FUN_00114b84",
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "rmdir"
        },
        "fseek": {
            "renaming": {},
            "code": "\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 = fseek(__stream,__off,__whence);\n  return iVar1;\n}\n\n",
            "called": [
                "fseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104660",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "fseek"
        },
        "FUN_001082b3": {
            "renaming": {
                "FUN_001082b3": "check_and_invert_string_length_001082b3",
                "uVar1": "string_length",
                "check_string_length_00113ede": "get_string_length"
            },
            "code": "\nuint check_and_invert_string_length_001082b3(void)\n\n{\n  uint string_length;\n  \n  string_length = get_string_length();\n  return string_length ^ 1;\n}\n\n",
            "called": [
                "FUN_00113ede"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001082b3",
            "calling": [
                "FUN_0010829e"
            ],
            "imported": false,
            "current_name": "check_and_invert_string_length_001082b3"
        },
        "FUN_00114690": {
            "renaming": {
                "FUN_00114690": "copy_archive_00114690",
                "param_1": "inputFilePath",
                "param_2": "outputFilePath",
                "param_3": "fileDescriptor",
                "param_4": "status",
                "param_5": "target",
                "param_6": "mode",
                "param_7": "conditionalFunction",
                "bVar1": "byteVar1",
                "cVar2": "charVar2",
                "cVar3": "charVar3",
                "iVar4": "intVar",
                "iVar5": "secondIntVar",
                "ppcVar6": "doublePointerCharVar",
                "pvVar7": "pointerVoidVar",
                "lVar8": "longVar",
                "puVar9": "pointerUndefVar",
                "piVar10": "pointerIntVar",
                "uVar11": "undefinedVar1",
                "uVar12": "undefinedVar2",
                "lVar13": "longVar2",
                "puVar14": "pointerUndefVar2",
                "pcVar15": "pointerCharVar1",
                "pcVar17": "pointerCharVar2",
                "pcVar18": "pointerCharVar3",
                "pcVar23": "pointerCharVar4",
                "psVar24": "pointerStatVar",
                "bVar25": "boolVar",
                "bVar26": "byteVar2",
                "local_1a0": "localPointerUndefVar",
                "local_198": "localLongVar",
                "local_158": "localStatTypeVar",
                "local_c8": "localPointerVoidArrVar",
                "uStack_b0": "localUIntVar1",
                "lStack_98": "localLongVar2"
            },
            "code": "\n\n\nvoid copyArchive_00114690(undefined8 inputFilePath,undefined8 outputFilePath,int fileDescriptor,undefined8 status,\n                 undefined8 target,long mode,undefined8 conditionalFunction)\n\n{\n  byte byteVar1;\n  char charVar2;\n  char charVar3;\n  int intVar;\n  int secondIntVar;\n  char **doublePointerCharVar;\n  void *pointerVoidVar;\n  long longVar;\n  undefined8 *pointerUndefVar;\n  int *pointerIntVar;\n  undefined8 undefinedVar1;\n  undefined8 undefinedVar2;\n  long longVar2;\n  undefined8 *pointerUndefVar2;\n  char *pointerCharVar1;\n  char **ppcVar16;\n  char *pointerCharVar2;\n  char *pointerCharVar3;\n  undefined8 *__ptr;\n  char **ppcVar19;\n  code *pcharVar20;\n  long lVar21;\n  uint uVar22;\n  char *pointerCharVar4;\n  stat *pointerStatVar;\n  bool boolVar;\n  byte byteVar2;\n  undefined8 *localPointerUndefVar;\n  long *localLongVar;\n  stat localStatTypeVar;\n  void *localPointerVoidArrVar [3];\n  uint localUIntVar1;\n  long localLongVar2;\n  \n  byteVar2 = 0;\n  longVar2 = check_file_properties_00113f50();\n  if (longVar2 < 1) {\n    if (longVar2 == 0) {\n      undefinedVar2 = dcgettext(0,\"error: the input file \\'%s\\' is empty\",5);\n      print_error_message_00119ed0(undefinedVar2,inputFilePath);\n    }\n    DAT_00127a20 = 1;\n    return;\n  }\n  pointerUndefVar2 = (undefined8 *)bfd_openr(inputFilePath,target);\n  if ((pointerUndefVar2 == (undefined8 *)0x0) || (secondIntVar = bfd_stat(pointerUndefVar2,status), secondIntVar != 0)) {\n    display_error_001126c0(inputFilePath,0,0,0);\n    DAT_00127a20 = 1;\n    return;\n  }\n  switch(DAT_00127984) {\n  case 1:\n  case 3:\n  case 9:\n    *(uint *)((long)pointerUndefVar2 + 0x44) = *(uint *)((long)pointerUndefVar2 + 0x44) | 0x24000;\n    break;\n  case 5:\n    *(uint *)((long)pointerUndefVar2 + 0x44) = *(uint *)((long)pointerUndefVar2 + 0x44) | 0x4000;\n    break;\n  case 0x11:\n    *(uint *)((long)pointerUndefVar2 + 0x44) = *(uint *)((long)pointerUndefVar2 + 0x44) | 0x424000;\n    break;\n  case 0x20:\n    *(uint *)((long)pointerUndefVar2 + 0x44) = *(uint *)((long)pointerUndefVar2 + 0x44) | 0x8000;\n  }\n  if (DAT_0012797c == 1) {\n    *(uint *)((long)pointerUndefVar2 + 0x44) = *(uint *)((long)pointerUndefVar2 + 0x44) | 0xc0000;\n  }\n  else if (DAT_0012797c == 2) {\n    *(uint *)((long)pointerUndefVar2 + 0x44) = *(uint *)((long)pointerUndefVar2 + 0x44) | 0x40000;\n  }\n  charVar2 = bfd_check_format(pointerUndefVar2,2);\n  if (charVar2 != '\\0') {\n    if (mode == 0) {\n      charVar2 = '\\0';\n      mode = *(long *)pointerUndefVar2[1];\n    }\n    if (fileDescriptor < 0) {\n      localPointerUndefVar = (undefined8 *)bfd_openw(outputFilePath,mode);\n    }\n    else {\n      localPointerUndefVar = (undefined8 *)bfd_fdopenw(outputFilePath,mode,fileDescriptor);\n    }\n    if (localPointerUndefVar != (undefined8 *)0x0) {\n      if (DAT_00127a10 != 0) {\n        undefinedVar2 = *pointerUndefVar2;\n        undefinedVar1 = dcgettext(0,\"--add-gnu-debuglink ignored for archive %s\",5);\n        print_error_message_00119ed0(undefinedVar1,undefinedVar2);\n        DAT_00127a10 = 0;\n      }\n      execute_conditional_function_00114d50(localPointerUndefVar,pointerUndefVar2,DAT_001264b4);\n      localLongVar = localPointerUndefVar + 0x1f;\n      if ((*(byte *)((long)pointerUndefVar2 + 0x49) & 0x10) != 0) {\n        DAT_00127a20 = 1;\n        bfd_set_error(5);\n        undefinedVar2 = dcgettext(0,\"sorry: copying thin archives is not currently supported\",5);\n        display_error_001126c0(0,pointerUndefVar2,0,undefinedVar2);\n        return;\n      }\n      pointerCharVar1 = (char *)create_temp_directory_0011a0e0(*localPointerUndefVar);\n      if (pointerCharVar1 == (char *)0x0) {\n        pointerIntVar = __errno_location();\n        pointerCharVar1 = strerror(*pointerIntVar);\n        undefinedVar2 = dcgettext(0,\"cannot create tempdir for archive copying (error: %s)\",5);\n                    \n        print_error_and_exit_00119dd0(undefinedVar2,pointerCharVar1);\n      }\n      if (DAT_00127a2c == 7) {\n        byteVar1 = *(byte *)((long)pointerUndefVar2 + 0x49);\n        uVar22 = 0;\n      }\n      else {\n        byteVar1 = *(byte *)((long)pointerUndefVar2 + 0x49);\n        uVar22 = byteVar1 >> 3 & 1;\n      }\n      boolVar = _DAT_001264b0 != 0;\n      *(byte *)((long)localPointerUndefVar + 0x49) =\n           byteVar1 & 0x10 | (byte)(uVar22 << 3) | *(byte *)((long)localPointerUndefVar + 0x49) & 0xe7;\n      if (boolVar) {\n        *(uint *)((long)localPointerUndefVar + 0x44) = *(uint *)((long)localPointerUndefVar + 0x44) | 0x2000;\n      }\n      __ptr = (undefined8 *)0x0;\n      ppcVar16 = (char **)bfd_openr_next_archived_file(pointerUndefVar2,0);\n      charVar3 = bfd_set_format(localPointerUndefVar,*(byte *)(pointerUndefVar2 + 9) & 7);\n      if (charVar3 == '\\0') {\n        DAT_00127a20 = 1;\n        display_error_001126c0(0,localPointerUndefVar,0,0);\n        remove_and_free_directory_00114b84();\n        return;\n      }\n      while ((DAT_00127a20 == 0 && (ppcVar16 != (char **)0x0))) {\n        pointerCharVar3 = *ppcVar16;\n        pointerCharVar2 = pointerCharVar3;\n        if (*pointerCharVar3 == '/') {\nLAB_0010527d:\n          undefinedVar2 = dcgettext(0,\"illegal pathname found in archive member: %s\",5);\n          print_error_message_00119ed0(undefinedVar2,pointerCharVar3);\nLAB_00104e93:\n          DAT_00127a20 = 1;\n          goto LAB_00114b4b;\n        }\n        while (*pointerCharVar2 != '\\0') {\n          pointerCharVar4 = pointerCharVar2;\n          if ((*pointerCharVar2 == '.') && (pointerCharVar4 = pointerCharVar2 + 1, pointerCharVar2[1] == '.')) {\n            pointerCharVar4 = pointerCharVar2 + 2;\n            if ((pointerCharVar2[2] == '\\0') || (pointerCharVar2[2] == '/')) goto LAB_0010527d;\n          }\n          for (; (*pointerCharVar4 != '\\0' && (*pointerCharVar4 != '/')); pointerCharVar4 = pointerCharVar4 + 1) {\n          }\n          pointerCharVar2 = pointerCharVar4;\n          if (*pointerCharVar4 == '/') {\n            copy_archive_001052a2();\n            return;\n          }\n        }\n        pointerCharVar3 = (char *)concat(pointerCharVar1,&DAT_0011b47d);\n        secondIntVar = stat(pointerCharVar3,&localStatTypeVar);\n        pointerUndefVar = __ptr;\n        if (-1 < secondIntVar) {\n          longVar2 = create_temp_directory_0011a0e0(pointerCharVar3);\n          free(pointerCharVar3);\n          if (longVar2 == 0) {\n            pointerIntVar = __errno_location();\n            pointerCharVar3 = strerror(*pointerIntVar);\n            undefinedVar2 = dcgettext(0,\"cannot create tempdir for archive copying (error: %s)\",5);\n            print_error_message_00119ed0(undefinedVar2,pointerCharVar3);\n            goto LAB_00104e93;\n          }\n          pointerUndefVar = (undefined8 *)xmalloc(0x18);\n          pointerCharVar3 = *ppcVar16;\n          *pointerUndefVar = __ptr;\n          pointerUndefVar[2] = 0;\n          pointerUndefVar[1] = longVar2;\n          pointerCharVar3 = (char *)concat(longVar2,&DAT_0011b47d,pointerCharVar3);\n        }\n        secondIntVar = 0;\n        if (DAT_001279cb != '\\0') {\n          pointerStatVar = &localStatTypeVar;\n          for (longVar2 = 0x24; longVar2 != 0; longVar2 = longVar2 + -1) {\n            *(undefined4 *)&pointerStatVar->st_dev = 0;\n            pointerStatVar = (stat *)((long)pointerStatVar + (ulong)byteVar2 * -8 + 4);\n          }\n          ppcVar19 = (char **)ppcVar16[0x1d];\n          if ((char **)ppcVar16[0x1d] == (char **)0x0) {\n            ppcVar19 = ppcVar16;\n          }\n          secondIntVar = (**(code **)(ppcVar19[1] + 0x1e8))(ppcVar16,&localStatTypeVar);\n          if (secondIntVar != 0) {\n            pointerCharVar2 = *ppcVar16;\n            undefinedVar2 = dcgettext(0,\"internal stat error on %s\",5);\n            print_error_message_00119ed0(undefinedVar2,pointerCharVar2);\n          }\n        }\n        __ptr = (undefined8 *)xmalloc(0x18);\n        __ptr[1] = pointerCharVar3;\n        *__ptr = pointerUndefVar;\n        __ptr[2] = 0;\n        charVar3 = bfd_check_format(ppcVar16,1);\n        if (charVar3 == '\\0') {\n          undefinedVar2 = dcgettext(0,\"Unable to recognise the format of file\",5);\n          display_error_001126c0(0,ppcVar16,0,undefinedVar2);\n          ppcVar19 = (char **)bfd_openw(pointerCharVar3,mode);\n          if (ppcVar19 == (char **)0x0) {\nLAB_00104e80:\n            display_error_001126c0(pointerCharVar3,0,0,0);\n            goto LAB_00104e93;\n          }\nLAB_00104d75:\n          doublePointerCharVar = (char **)ppcVar16[0x1d];\n          if ((char **)ppcVar16[0x1d] == (char **)0x0) {\n            doublePointerCharVar = ppcVar16;\n          }\n          intVar = (**(code **)(doublePointerCharVar[1] + 0x1e8))(ppcVar16);\n          longVar2 = localLongVar2;\n          if (intVar == 0) {\n            if (localLongVar2 < 0) {\n              get_formatted_string_001125fa(ppcVar16);\n              undefinedVar2 = dcgettext(0,\"stat returns negative size for `%s\\'\",5);\n              print_error_message_00119ed0(undefinedVar2);\n            }\n            else {\n              intVar = bfd_seek(ppcVar16,0,0);\n              if (intVar == 0) {\n                if (DAT_001279c9 != '\\0') {\n                  pointerCharVar2 = *ppcVar19;\n                  undefinedVar2 = get_formatted_string_001125fa(ppcVar16);\n                  pointerCharVar4 = (char *)dcgettext(0,\"copy from `%s\\' [unknown] to `%s\\' [unknown]\\n\",5);\n                  printf(pointerCharVar4,undefinedVar2,pointerCharVar2);\n                }\n                pointerVoidVar = (void *)xmalloc(0x2000);\n                for (; longVar2 != 0; longVar2 = longVar2 - lVar21) {\n                  lVar21 = 0x2000;\n                  if (longVar2 < 0x2001) {\n                    lVar21 = longVar2;\n                  }\n                  longVar = bfd_bread(pointerVoidVar,lVar21,ppcVar16);\n                  doublePointerCharVar = ppcVar16;\n                  if ((lVar21 != longVar) ||\n                     (longVar = bfd_bwrite(pointerVoidVar,lVar21,ppcVar19), doublePointerCharVar = ppcVar19,\n                     lVar21 != longVar)) {\n                    display_error_001126c0(0,doublePointerCharVar,0,0);\n                    free(pointerVoidVar);\n                    goto LAB_00104f00;\n                  }\n                }\n                chmod(*ppcVar19,localUIntVar1 | 0x100);\n                free(pointerVoidVar);\n                charVar3 = bfd_close_all_done(ppcVar19);\n                if (charVar3 == '\\0') {\n                  display_error_001126c0(pointerCharVar3,0,0,0);\n                  DAT_00127a20 = 1;\n                }\n                goto LAB_00114a86;\n              }\n              undefinedVar2 = get_formatted_string_001125fa(ppcVar16);\n              print_error_message_0011a110(undefinedVar2);\n            }\n          }\n          else {\n            display_error_001126c0(0,ppcVar16,0,0);\n          }\nLAB_00104f00:\n          charVar3 = bfd_close_all_done(ppcVar19);\n          if (charVar3 == '\\0') {\n            display_error_001126c0(pointerCharVar3,0,0,0);\n          }\nLAB_00104ec9:\n          unlink(pointerCharVar3);\n          DAT_00127a20 = 1;\n        }\n        else {\n          if (charVar2 == '\\0') {\n            ppcVar19 = (char **)bfd_openw(pointerCharVar3,*(undefined8 *)ppcVar16[1]);\n          }\n          else {\n            ppcVar19 = (char **)bfd_openw(pointerCharVar3,mode);\n          }\n          if (ppcVar19 == (char **)0x0) goto LAB_00104e80;\n          charVar3 = FUNC_00114e50(ppcVar16,ppcVar19,conditionalFunction);\n          if (charVar3 == '\\0') {\n            intVar = bfd_get_arch(ppcVar16);\n            if (intVar == 0) goto LAB_00104d75;\n            charVar3 = bfd_close_all_done(ppcVar19);\n            if (charVar3 == '\\0') {\n              display_error_001126c0(pointerCharVar3,0,0,0);\n            }\n            goto LAB_00104ec9;\n          }\n          charVar3 = bfd_close(ppcVar19);\n          if (charVar3 == '\\0') {\n            display_error_001126c0(pointerCharVar3,0,0,0);\n            DAT_00127a20 = 1;\n          }\nLAB_00114a86:\n          if ((DAT_001279cb != '\\0') && (secondIntVar == 0)) {\n            set_file_time_0011a350(pointerCharVar3,&localStatTypeVar);\n          }\n          longVar2 = bfd_openr(pointerCharVar3,mode);\n          __ptr[2] = longVar2;\n          *localLongVar = longVar2;\n          localLongVar = (long *)(longVar2 + 0xf0);\n          ppcVar19 = (char **)bfd_openr_next_archived_file(pointerUndefVar2);\n          bfd_close(ppcVar16);\n          ppcVar16 = ppcVar19;\n        }\n      }\n      *localLongVar = 0;\n      pointerVoidVar = (void *)xstrdup(*localPointerUndefVar);\n      if (DAT_00127a20 == 0) {\n        pcharVar20 = bfd_close;\n      }\n      else {\n        pcharVar20 = bfd_close_all_done;\n      }\n      charVar2 = (*pcharVar20)(localPointerUndefVar);\n      if (charVar2 == '\\0') {\n        DAT_00127a20 = 1;\n        display_error_001126c0(pointerVoidVar,0,0,0);\n      }\n      free(pointerVoidVar);\n      pointerVoidVar = (void *)xstrdup(*pointerUndefVar2);\n      charVar2 = bfd_close(pointerUndefVar2);\n      if (charVar2 == '\\0') {\n        DAT_00127a20 = 1;\n        display_error_001126c0(pointerVoidVar,0,0,0);\n      }\n      free(pointerVoidVar);\nLAB_00114b4b:\n      while (__ptr != (undefined8 *)0x0) {\n        if (__ptr[2] == 0) {\n          rmdir((char *)__ptr[1]);\n        }\n        else {\n          bfd_close();\n          unlink((char *)__ptr[1]);\n        }\n        free((void *)__ptr[1]);\n        pointerUndefVar2 = (undefined8 *)*__ptr;\n        free(__ptr);\n        __ptr = pointerUndefVar2;\n      }\n      rmdir(pointerCharVar1);\n      free(pointerCharVar1);\n      return;\n    }\nLAB_00105231:\n    close(fileDescriptor);\n    display_error_001126c0(outputFilePath,0,0,0);\n    DAT_00127a20 = 1;\n    return;\n  }\n  charVar2 = bfd_check_format_matches(pointerUndefVar2,1,localPointerVoidArrVar);\n  if (charVar2 == '\\0') {\n    secondIntVar = bfd_get_error();\n    charVar2 = bfd_check_format_matches(pointerUndefVar2,3,&localStatTypeVar);\n    if (charVar2 == '\\0') {\n      intVar = bfd_get_error();\n      if (secondIntVar != intVar) {\n        bfd_set_error(secondIntVar);\n      }\n      display_error_001126c0(inputFilePath,0,0,0);\n      if (secondIntVar == 0xd) {\n        print_matched_formats_0011256b(localPointerVoidArrVar[0]);\n      }\n      if (intVar != 0xd) {\n        DAT_00127a20 = 1;\n        return;\n      }\n      print_matched_formats_0011256b(localStatTypeVar.st_dev);\n      DAT_00127a20 = 1;\n      return;\n    }\n    if (secondIntVar == 0xd) {\n      free(localPointerVoidArrVar[0]);\n    }\n  }\n  if (mode == 0) {\n    mode = *(long *)pointerUndefVar2[1];\n  }\n  if (fileDescriptor < 0) {\n    longVar2 = bfd_openw(outputFilePath,mode);\n  }\n  else {\n    longVar2 = bfd_fdopenw(outputFilePath,mode,fileDescriptor);\n  }\n  if (longVar2 == 0) goto LAB_00105231;\n  execute_conditional_function_00114d50(longVar2,pointerUndefVar2,DAT_001264b4);\n  charVar2 = FUNC_00114e50(pointerUndefVar2,longVar2,conditionalFunction);\n  if (charVar2 == '\\0') {\n    DAT_00127a20 = 1;\n  }\n  else if (DAT_00127a20 == 0) {\n    charVar2 = bfd_close(longVar2);\n    goto LAB_001147d5;\n  }\n  charVar2 = bfd_close_all_done(longVar2);\nLAB_001147d5:\n  if (charVar2 != '\\x01') {\n    DAT_00127a20 = 1;\n    display_error_001126c0(outputFilePath,0,0,0);\n    return;\n  }\n  charVar2 = bfd_close(pointerUndefVar2);\n  if (charVar2 == '\\0') {\n    DAT_00127a20 = 1;\n    display_error_001126c0(inputFilePath,0,0,0);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "close",
                "FUN_00113f50",
                "bfd_stat",
                "bfd_set_error",
                "bfd_openw",
                "bfd_close",
                "__errno_location",
                "FUN_00114e50",
                "FUN_00119ed0",
                "strerror",
                "FUN_001126c0",
                "bfd_set_format",
                "FUN_00114d50",
                "FUN_0011a0e0",
                "FUN_00119dd0",
                "FUN_00104d25",
                "dcgettext",
                "bfd_close_all_done",
                "bfd_fdopenw",
                "bfd_openr_next_archived_file",
                "FUN_0011256b",
                "bfd_check_format",
                "free",
                "bfd_get_error",
                "bfd_check_format_matches",
                "bfd_openr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114690",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "copy_archive_00114690"
        },
        "FUN_0010b800": {
            "renaming": {
                "FUN_0010b800": "process_stab_int_type_0010b800",
                "param_1": "data",
                "param_2": "size",
                "param_3": "flag",
                "plVar1": "ptrValue",
                "uVar2": "result",
                "sVar3": "stringLength",
                "lVar4": "tempData",
                "lVar5": "bitMask",
                "local_8c": "outputString",
                "auStack_8a": "stackArray"
            },
            "code": "\nundefined8 processStabIntType_0010b800(long data,int size,char flag)\n\n{\n  long *ptrValue;\n  undefined8 result;\n  size_t stringLength;\n  long tempData;\n  long bitMask;\n  undefined2 outputString;\n  undefined4 stackArray [24];\n  \n  if (size - 1U < 8) {\n    tempData = data + 0xb8;\n    if (flag != '\\0') {\n      tempData = data + 0x78;\n    }\n    ptrValue = (long *)(tempData + (ulong)(size - 1U) * 8);\n    tempData = *ptrValue;\n    if (tempData != 0) {\n      result = initialize_data_00109cf4(data,tempData,size);\n      return result;\n    }\n    tempData = *(long *)(data + 0x68);\n    *(long *)(data + 0x68) = tempData + 1;\n    *ptrValue = tempData;\n    sprintf((char *)&outputString,\"%ld=r%ld;\",tempData,tempData);\n    if (flag == '\\0') {\n      bitMask = 1L << ((char)size * '\\b' - 1U & 0x3f);\n      stringLength = strlen((char *)&outputString);\n      sprintf((char *)((long)&outputString + stringLength),\"%ld;%ld;\",-bitMask,bitMask + -1);\n    }\n    else {\n      stringLength = strlen((char *)&outputString);\n      *(undefined2 *)((long)&outputString + stringLength) = 0x3b30;\n      *(undefined *)((long)&outputString + stringLength + 2) = 0;\n      if (size == 8) {\n        *(undefined4 *)((long)&outputString + stringLength + 2) = 0x3b312d;\n      }\n      else {\n        sprintf((char *)((long)&outputString + stringLength + 2),\"%ld;\",\n                (1L << ((char)size * '\\b' & 0x3fU)) + -1);\n      }\n    }\n    result = allocate_and_initialize_data_00109b52(data,&outputString,tempData,1,size);\n  }\n  else {\n    result = dcgettext(0,\"stab_int_type: bad size %u\",5);\n    print_error_message_00119ed0(result,size);\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_00109cf4",
                "strlen",
                "dcgettext",
                "FUN_00119ed0",
                "sprintf",
                "FUN_00109b52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010b800",
            "calling": [
                "FUN_0010b948",
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "process_stab_int_type_0010b800"
        },
        "FUN_00109ed3": {
            "renaming": {
                "FUN_00109ed3": "process_data_00109ed3",
                "param_1": "inputPtr",
                "param_2": "character",
                "param_3": "flag",
                "param_4": "dataPtr",
                "param_5": "countPtr",
                "uVar1": "dataCount",
                "uVar2": "newDataCount",
                "cVar3": "result",
                "pcVar4": "extractedItem",
                "sVar5": "extractedItemLength",
                "__s": "newString",
                "lVar6": "itemIndex",
                "__ptr": "extractedPtr",
                "uVar7": "initResult",
                "uVar8": "useFlag",
                "lVar9": "loopCounter",
                "uVar10": "newCount",
                "puVar11": "dataPtrPtr",
                "bVar12": "byteVar"
            },
            "code": "\nundefined8 processData_00109ed3(long inputPtr,uint character,undefined4 flag,long *dataPtr,ulong *countPtr)\n\n{\n  ulong dataCount;\n  ulong newDataCount;\n  char result;\n  char *extractedItem;\n  size_t extractedItemLength;\n  char *newString;\n  long itemIndex;\n  void *extractedPtr;\n  undefined8 initResult;\n  undefined useFlag;\n  long loopCounter;\n  ulong newCount;\n  undefined *dataPtrPtr;\n  byte byteVar;\n  \n  byteVar = 0;\n  itemIndex = *(long *)(inputPtr + 0x60);\n  if (itemIndex != 0) {\n    dataCount = *(ulong *)(itemIndex + 0x10);\n    if (((long)dataCount < 1) || (dataPtr == (long *)0x0)) {\n      useFlag = *(undefined *)(itemIndex + 0x1c);\n      extractedItem = (char *)extract_list_item_00109b2f(inputPtr);\n      extractedItemLength = strlen(extractedItem);\n      newString = (char *)xmalloc(extractedItemLength + 2);\n      sprintf(newString,\"%c%s\",(ulong)character,extractedItem);\n      free(extractedItem);\n      itemIndex = 0;\n    }\n    else {\n      newCount = *countPtr;\n      if (newCount <= dataCount) {\n        if (newCount == 0) {\n          newCount = 10;\n        }\n        for (; newCount <= dataCount; newCount = newCount * 2) {\n        }\n        itemIndex = xrealloc(*dataPtr,newCount * 8);\n        newDataCount = *countPtr;\n        *dataPtr = itemIndex;\n        dataPtrPtr = (undefined *)(itemIndex + newDataCount * 8);\n        for (loopCounter = (newCount - newDataCount) * 8; loopCounter != 0; loopCounter = loopCounter + -1) {\n          *dataPtrPtr = 0;\n          dataPtrPtr = dataPtrPtr + (ulong)byteVar * -2 + 1;\n        }\n        *countPtr = newCount;\n      }\n      itemIndex = *(long *)(*dataPtr + dataCount * 8);\n      if ((itemIndex != 0) && (*(char *)(*(long *)(inputPtr + 0x60) + 0x1c) == '\\0')) {\n        extractedPtr = (void *)extract_list_item_00109b2f(inputPtr);\n        free(extractedPtr);\n        initResult = initialize_data_00109cf4(inputPtr,itemIndex,flag);\n        return initResult;\n      }\n      itemIndex = *(long *)(inputPtr + 0x68);\n      *(long *)(inputPtr + 0x68) = itemIndex + 1;\n      extractedItem = (char *)extract_list_item_00109b2f(inputPtr);\n      extractedItemLength = strlen(extractedItem);\n      newString = (char *)xmalloc(extractedItemLength + 0x14);\n      sprintf(newString,\"%ld=%c%s\",itemIndex,(ulong)character,extractedItem);\n      free(extractedItem);\n      useFlag = 1;\n      *(long *)(*dataPtr + dataCount * 8) = itemIndex;\n    }\n    result = allocate_and_initialize_data_00109b52(inputPtr,newString,itemIndex,useFlag,flag);\n    if (result != '\\0') {\n      free(newString);\n      return 1;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00109cf4",
                "xrealloc",
                "strlen",
                "free",
                "xmalloc",
                "sprintf",
                "FUN_00109b2f",
                "FUN_00109b52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109ed3",
            "calling": [
                "FUN_0010a0d3",
                "FUN_0010e5db",
                "FUN_0010a0bd",
                "FUN_0010a0a0",
                "FUN_0010a083"
            ],
            "imported": false,
            "current_name": "process_data_00109ed3"
        },
        "xmalloc": {
            "renaming": {},
            "code": "\nvoid xmalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104390",
            "calling": [
                "FUN_00112925",
                "FUN_0010bf86",
                "FUN_0010e07c",
                "FUN_0010ba08",
                "FUN_0011378f",
                "FUN_0010a77a",
                "FUN_00114cf0",
                "FUN_00116852",
                "FUN_0010e453",
                "FUN_00114d60",
                "FUN_0010a2b9",
                "FUN_00108d9a",
                "FUN_00114190",
                "FUN_0011a480",
                "FUN_00114c80",
                "FUN_00115530",
                "FUN_00113b98",
                "FUN_0010ab4d",
                "FUN_0010c7a0",
                "FUN_0010e918",
                "FUN_00114460",
                "FUN_0010a181",
                "FUN_00113c43",
                "FUN_00113ce0",
                "FUN_00108c86",
                "FUN_0010c139",
                "FUN_0010e9a0",
                "FUN_00109022",
                "FUN_001163d0",
                "FUN_00116b90",
                "FUN_0010a377",
                "FUN_0010eafe",
                "FUN_0010c218",
                "FUN_0010ee3f",
                "FUN_0010a69a",
                "FUN_0010bd62",
                "FUN_001125fa",
                "FUN_00109ed3",
                "FUN_00112904",
                "FUN_0010554f",
                "FUN_0010e5db",
                "FUN_00104ad6",
                "FUN_0010e842",
                "FUN_0010be88",
                "FUN_0010a0e9",
                "FUN_0010bbd3",
                "FUN_0010ae0e",
                "FUN_0010ebb0",
                "FUN_00109b52",
                "FUN_0010dac0",
                "FUN_0011173a",
                "FUN_00113bfa",
                "FUN_00113d6e",
                "FUN_00113da9",
                "FUN_0010e7c2",
                "FUN_0010afd5",
                "FUN_001199d0",
                "FUN_0010c05d",
                "FUN_0010aa53",
                "FUN_0010da0b",
                "FUN_0010e8a9",
                "FUN_0010a94e",
                "FUN_00108f08",
                "FUN_0010a83e",
                "FUN_00116110",
                "FUN_00113e23",
                "FUN_00109a0b",
                "FUN_0010e6a8",
                "FUN_0010a424",
                "FUN_00116030",
                "FUN_00104ea2",
                "FUN_0010b6ea",
                "FUN_0010d882",
                "FUN_0010c6be",
                "FUN_00112894",
                "FUN_0010bc80",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "xmalloc"
        },
        "FUN_0010bbd3": {
            "renaming": {
                "FUN_0010bbd3": "initialize_debug_info_0010bbd3",
                "param_1": "info",
                "param_2": "filename",
                "param_3": "val1",
                "param_4": "val2",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "puVar3": "ptr3",
                "lVar4": "count",
                "puVar5": "ptr4",
                "pcVar6": "tempFilename",
                "bVar7": "byteVar",
                "auVar8": "result"
            },
            "code": "\nundefined  [16] initializeDebugInfo_0010bbd3(long *info,char *filename,undefined8 val1,undefined8 val2)\n\n{\n  undefined8 *ptr1;\n  undefined4 *ptr2;\n  undefined4 *ptr3;\n  long count;\n  undefined4 *ptr4;\n  char *tempFilename;\n  byte byteVar;\n  undefined result [16];\n  \n  byteVar = 0;\n  tempFilename = \"\";\n  if (filename != (char *)0x0) {\n    tempFilename = filename;\n  }\n  ptr2 = (undefined4 *)xmalloc(0x18);\n  ptr4 = ptr2;\n  for (count = 6; count != 0; count = count + -1) {\n    *ptr4 = 0;\n    ptr4 = ptr4 + (ulong)byteVar * -2 + 1;\n  }\n  *(char **)(ptr2 + 2) = tempFilename;\n  ptr3 = (undefined4 *)xmalloc(0x18);\n  info[2] = (long)ptr2;\n  ptr4 = ptr3;\n  for (count = 6; count != 0; count = count + -1) {\n    *ptr4 = 0;\n    ptr4 = ptr4 + (ulong)byteVar * -2 + 1;\n  }\n  ptr1 = (undefined8 *)info[1];\n  *(undefined4 **)(ptr3 + 2) = ptr2;\n  if (ptr1 == (undefined8 *)0x0) {\n    if (*info != 0) {\n                    \n      __assert_fail(\"info->units == NULL\",\"../../binutils/debug.c\",699,\"debug_set_filename\");\n    }\n    *info = (long)ptr3;\n  }\n  else {\n    *ptr1 = ptr3;\n  }\n  info[1] = (long)ptr3;\n  info[5] = 0;\n  *(undefined (*) [16])(info + 3) = ZEXT816(0);\n  result._8_8_ = val2;\n  result._0_8_ = 1;\n  return result;\n}\n\n",
            "called": [
                "xmalloc",
                "__assert_fail"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bbd3",
            "calling": [
                "FUN_0011173a",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "initialize_debug_info_0010bbd3"
        },
        "FUN_00114e50": {
            "renaming": {
                "FUN_00114e50": "FUNC_00114e50"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong FUNC_00114e50(undefined8 *param_1,long param_2,long param_3)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  undefined *puVar3;\n  long *plVar4;\n  code *pcVar5;\n  long *plVar6;\n  ulong uVar7;\n  ulong uVar8;\n  char *__s;\n  ushort uVar9;\n  char cVar10;\n  char cVar11;\n  int iVar12;\n  int iVar13;\n  undefined4 uVar14;\n  long *plVar15;\n  long lVar16;\n  undefined8 uVar17;\n  undefined8 uVar18;\n  size_t sVar19;\n  size_t sVar20;\n  char *pcVar21;\n  void *__ptr;\n  void *__ptr_00;\n  ulong uVar22;\n  long lVar23;\n  ulong uVar24;\n  int *piVar25;\n  ulong uVar26;\n  FILE *__s_00;\n  long **pplVar27;\n  uint uVar28;\n  long **__ptr_01;\n  char *pcVar29;\n  undefined8 *puVar30;\n  ulong uVar31;\n  int iVar32;\n  long **pplVar33;\n  char *pcVar34;\n  long lVar35;\n  undefined4 *puVar36;\n  ulong *puVar37;\n  undefined8 *puVar38;\n  uint uVar39;\n  char **ppcVar40;\n  void *pvVar41;\n  undefined **ppuVar42;\n  bool bVar43;\n  byte bVar44;\n  ulong uStack_1f8;\n  ulong local_1f0;\n  undefined4 *puStack_1e8;\n  char *pcStack_1d0;\n  int *piStack_1c0;\n  long lStack_190;\n  long lStack_180;\n  char *pcStack_178;\n  long lStack_168;\n  long *plStack_148;\n  ulong uStack_140;\n  long lStack_138;\n  long lStack_130;\n  void *apvStack_128 [2];\n  long lStack_118;\n  ushort uStack_10a;\n  byte bStack_108;\n  byte bStack_107;\n  undefined8 uStack_f8;\n  ushort uStack_f0;\n  char *pcStack_c8;\n  ulong uStack_c0;\n  char *pcStack_b8;\n  undefined uStack_b0;\n  short sStack_ae;\n  \n  bVar44 = 0;\n  iVar13 = *(int *)(*(long *)(param_2 + 8) + 0xc);\n  local_1f0._0_1_ =\n       (*(int *)(param_1[1] + 0xc) != iVar13 && *(int *)(param_1[1] + 0xc) != 2) && iVar13 != 2;\n  if ((bool)(char)local_1f0) {\n    uVar18 = get_formatted_string_001125fa();\n    uVar17 = dcgettext(0,\"unable to change endianness of \\'%s\\'\",5);\n    print_error_message_00119ed0(uVar17,uVar18);\n    return 0;\n  }\n  if ((*(byte *)((long)param_1 + 0x4a) & 0x20) != 0) {\n    uVar18 = get_formatted_string_001125fa();\n    uVar17 = dcgettext(0,\"unable to modify \\'%s\\' due to errors\",5);\n    print_error_message_00119ed0(uVar17,uVar18);\n    return 0;\n  }\n  cVar11 = bfd_set_format(param_2,*(byte *)(param_1 + 9) & 7);\n  if (cVar11 == '\\0') {\n    display_error_001126c0(0,param_2,0,0);\n    return 0;\n  }\n  if (param_1[0x12] == 0) {\n    uVar18 = get_formatted_string_001125fa(param_1);\n    uVar17 = dcgettext(0,\"error: the input file \\'%s\\' has no sections\",5);\n    print_error_message_00119ed0(uVar17,uVar18);\n    return 0;\n  }\n  _VerilogDataEndianness = *(undefined4 *)(param_1[1] + 0xc);\n  if (*(int *)(param_1[1] + 8) == 5) {\n    if (DAT_001279c9 != '\\0') {\n      uVar26 = FUNC_00107976();\n      return uVar26;\n    }\n  }\n  else {\n    if ((DAT_00127984 != 1) && ((DAT_00127984 & 1) != 0)) {\n      uVar18 = get_formatted_string_001125fa(param_1);\n      uVar17 = dcgettext(0,\n                         \"--compress-debug-sections=[zlib|zlib-gnu|zlib-gabi|zstd] is unsupported on `%s\\'\"\n                         ,5);\n      print_error_message_00119ed0(uVar17,uVar18);\n      return 0;\n    }\n    if (DAT_0012797c != 0) {\n      uVar18 = get_formatted_string_001125fa(param_1);\n      uVar17 = dcgettext(0,\"--elf-stt-common=[yes|no] is unsupported on `%s\\'\",5);\n      print_error_message_00119ed0(uVar17,uVar18);\n      return 0;\n    }\n    if (DAT_001279c9 != '\\0') {\n      uVar26 = FUNC_00107976();\n      return uVar26;\n    }\n  }\n  if (DAT_001278ec == '\\0') {\n    if (DAT_00127958 == '\\0') {\n      lVar35 = DAT_00127998 + param_1[0x17];\n    }\n    else {\n      lVar35 = DAT_00127998 + _DAT_00127960;\n    }\n  }\n  else {\n    lVar35 = 0;\n  }\n  if ((*(byte *)(param_2 + 0x48) & 7) == 3) {\n    iVar13 = bfd_get_arch(param_1,lVar35);\n    uVar14 = bfd_get_mach(param_1);\n    if (param_3 != 0) {\n      uVar26 = FUNC_001152b6();\n      return uVar26;\n    }\n    goto LAB_00114f9a;\n  }\n  uVar28 = ~DAT_001278f0 & *(uint *)(*(long *)(param_2 + 8) + 0x14) &\n           (DAT_001278f4 | *(uint *)((long)param_1 + 0x44));\n  if (DAT_00127a2c == 7) {\n    uVar28 = uVar28 & 0xfffffffe;\n    cVar11 = bfd_set_start_address(param_2);\n  }\n  else {\n    cVar11 = bfd_set_start_address(param_2);\n  }\n  if ((cVar11 == '\\0') || (cVar11 = bfd_set_file_flags(param_2,uVar28), cVar11 == '\\0'))\n  goto LAB_00107a82;\n  iVar13 = bfd_get_arch(param_1);\n  uVar14 = bfd_get_mach(param_1);\n  if (param_3 == 0) {\nLAB_00114f9a:\n    if (((iVar13 == 0) && (*(int *)(param_1[1] + 8) != 5)) &&\n       (*(int *)(*(long *)(param_2 + 8) + 8) == 5)) {\n      uVar26 = FUNC_00107880();\n      return uVar26;\n    }\n  }\n  else {\n    if (iVar13 == 0) {\n      iVar13 = *(int *)(param_3 + 0xc);\n      uVar14 = *(undefined4 *)(param_3 + 0x10);\n      goto LAB_00114f9a;\n    }\n    uVar18 = get_formatted_string_001125fa(param_1);\n    uVar17 = dcgettext(0,\"Input file `%s\\' ignores binary architecture parameter.\",5);\n    print_error_message_00119ed0(uVar17,uVar18);\n  }\n  cVar11 = (**(code **)(*(long *)(param_2 + 8) + 0x2a0))(param_2,iVar13,uVar14);\n  if (cVar11 == '\\0') {\n    if ((*(byte *)(param_1 + 9) & 0x40) != 0) {\n      iVar13 = bfd_get_arch(param_1);\n      if (iVar13 == 0) {\n        uVar18 = get_formatted_string_001125fa(param_1);\n        uVar17 = dcgettext(0,\"Unable to recognise the format of the input file `%s\\'\",5);\n        print_error_message_00119ed0(uVar17,uVar18);\n        return 0;\n      }\n      uVar18 = bfd_get_mach(param_1);\n      uVar14 = bfd_get_arch(param_1);\n      uVar18 = bfd_printable_arch_mach(uVar14,uVar18);\n      uVar17 = dcgettext(0,\"Output file cannot represent architecture `%s\\'\",5);\n      print_error_message_00119ed0(uVar17,uVar18);\n      return 0;\n    }\n    iVar13 = bfd_get_arch(param_1);\n    iVar32 = bfd_get_arch(param_2);\n    if (iVar13 != iVar32) {\n      uVar26 = check_file_architecture_00105828();\n      return uVar26;\n    }\n  }\n  cVar11 = bfd_set_format(param_2,*(byte *)(param_1 + 9) & 7);\n  if (cVar11 == '\\0') {\nLAB_00107a82:\n    display_error_001126c0(0,param_1,0,0);\n    return 0;\n  }\n  if ((*(int *)(*(undefined8 **)(param_2 + 8) + 1) == 2) &&\n     (cVar11 = compare_strings_00113fb0(**(undefined8 **)(param_2 + 8),&DAT_0011b503), cVar11 != '\\0')) {\n    lVar35 = *(long *)(param_2 + 0x110);\n    if ((*(int *)((undefined8 *)param_1[1] + 1) == 2) &&\n       (cVar11 = compare_strings_00113fb0(*(undefined8 *)param_1[1],&DAT_0011b503), cVar11 != '\\0')) {\n      lVar16 = param_1[0x22];\n      bVar43 = DAT_001279cb == '\\0';\n      puVar30 = (undefined8 *)(lVar16 + 200);\n      puVar38 = (undefined8 *)(lVar35 + 200);\n      for (lVar23 = 0x32; lVar23 != 0; lVar23 = lVar23 + -1) {\n        *puVar38 = *puVar30;\n        puVar30 = puVar30 + (ulong)bVar44 * -2 + 1;\n        puVar38 = puVar38 + (ulong)bVar44 * -2 + 1;\n      }\n      if (bVar43) {\n        *(undefined4 *)(lVar35 + 0x2a4) = 0xffffffff;\n      }\n      else {\n        *(int *)(lVar35 + 0x2a4) = (int)*(undefined8 *)(lVar16 + 0xa8);\n      }\n    }\n    uVar26 = DAT_001264a8;\n    if (DAT_001264a8 == 0xffffffffffffffff) {\n      DAT_001264a8 = 0x200;\n      uVar26 = 0x200;\n    }\n    else {\n      *(int *)(lVar35 + 0x10c) = (int)DAT_001264a8;\n    }\n    if (DAT_00126498 != -1) {\n      *(long *)(lVar35 + 0x148) = DAT_00126498;\n    }\n    if (DAT_001264a0 != -1) {\n      *(long *)(lVar35 + 0x148) = DAT_001264a0;\n    }\n    if (DAT_00126490 != -1) {\n      *(long *)(lVar35 + 0x100) = DAT_00126490;\n    }\n    uVar22 = DAT_00126488;\n    if (DAT_00126488 == 0xffffffffffffffff) {\n      DAT_00126488 = 0x1000;\n      uVar22 = 0x1000;\n    }\n    else {\n      *(int *)(lVar35 + 0x108) = (int)DAT_00126488;\n    }\n    if (DAT_00126478 != -1) {\n      *(long *)(lVar35 + 0x138) = DAT_00126478;\n    }\n    if (DAT_00126480 != -1) {\n      *(long *)(lVar35 + 0x138) = DAT_00126480;\n    }\n    if (DAT_00126474 != -1) {\n      *(short *)(lVar35 + 300) = DAT_00126474;\n    }\n    if (DAT_00126472 != -1) {\n      *(short *)(lVar35 + 0x118) = DAT_00126472;\n    }\n    if (DAT_00126470 != -1) {\n      *(short *)(lVar35 + 0x11a) = DAT_00126470;\n    }\n    if (uVar22 < uVar26) {\n      uVar18 = dcgettext(0,\"warning: file alignment (0x%lx) > section alignment (0x%lx)\",5);\n      print_error_message_00119ed0(uVar18,uVar26,uVar22);\n    }\n  }\n  plVar6 = DAT_001278b0;\n  free(DAT_001278b0);\n  if (plVar6 == DAT_001278a8) {\n    DAT_001278b0 = (long *)0x0;\n    DAT_001278a8 = (long *)0x0;\n    lVar35 = (**(code **)(param_1[1] + 0x1f8))(param_1);\n  }\n  else {\n    free(DAT_001278a8);\n    DAT_001278b0 = (long *)0x0;\n    DAT_001278a8 = (long *)0x0;\n    lVar35 = (**(code **)(param_1[1] + 0x1f8))(param_1);\n  }\n  if (lVar35 < 0) goto LAB_00107a82;\n  DAT_001278a8 = (long *)xmalloc();\n  DAT_001278b0 = DAT_001278a8;\n  uStack_1f8 = (**(code **)(param_1[1] + 0x200))(param_1,DAT_001278a8);\n  if ((long)uStack_1f8 < 0) goto LAB_00107a82;\n  if (uStack_1f8 == 0) {\n    free(DAT_001278b0);\n    DAT_001278b0 = (long *)0x0;\n    DAT_001278a8 = (long *)0x0;\n  }\n  bfd_map_over_sections(param_1,parse_and_create_output_section_00115530,param_2);\n  puVar30 = DAT_001279c0;\n  if ((DAT_001278ec == '\\0') &&\n     (cVar11 = (**(code **)(*(long *)(param_2 + 8) + 0x168))(param_1), puVar30 = DAT_001279c0,\n     cVar11 == '\\0')) {\n    DAT_00127a20 = 1;\n    dcgettext(0,\"error in private header data\",5);\n    display_error_001126c0(0,param_1,0);\n    puVar30 = DAT_001279c0;\n  }\n  for (; puVar38 = DAT_001279b8, puVar30 != (undefined8 *)0x0; puVar30 = (undefined8 *)*puVar30) {\n    uVar28 = 0x128;\n    lVar35 = parse_rules_00114190(puVar30[1],0,0x80);\n    if (lVar35 != 0) {\n      uVar28 = drop_share_flag_if_not_coff_00115f30(*(uint *)(lVar35 + 0x28) | 0x100,param_2,puVar30[1]);\n    }\n    lVar35 = bfd_get_section_by_name(param_2,puVar30[1]);\n    if (lVar35 != 0) {\n      uVar18 = puVar30[1];\n      uVar17 = dcgettext(0,\"can\\'t add section \\'%s\\'\",5);\n      display_error_001126c0(0,param_2,0,uVar17,uVar18);\n      return 0;\n    }\n    lVar35 = bfd_make_section_with_flags(param_2,puVar30[1],uVar28 | 0x100000);\n    puVar30[5] = lVar35;\n    if (lVar35 == 0) {\n      uVar18 = puVar30[1];\n      uVar17 = dcgettext(0,\"can\\'t create section `%s\\'\",5);\n      display_error_001126c0(0,param_2,0,uVar17,uVar18);\n      return 0;\n    }\n    cVar11 = bfd_set_section_size();\n    if (cVar11 == '\\0') {\n      display_error_001126c0(0,param_2,puVar30[5],0);\n      return 0;\n    }\n    lVar35 = parse_rules_00114190(puVar30[1],0,0x18);\n    if (lVar35 != 0) {\n      uVar18 = *(undefined8 *)(lVar35 + 0x18);\n      lVar35 = puVar30[5];\n      *(byte *)(lVar35 + 0x28) = *(byte *)(lVar35 + 0x28) | 1;\n      *(undefined8 *)(lVar35 + 0x30) = uVar18;\n      *(undefined8 *)(lVar35 + 0x38) = uVar18;\n    }\n    lVar35 = parse_rules_00114190(puVar30[1],0,0x60);\n    if (lVar35 != 0) {\n      lVar16 = puVar30[5];\n      *(undefined8 *)(lVar16 + 0x38) = *(undefined8 *)(lVar35 + 0x20);\n      if (0x3e < *(uint *)(lVar16 + 0x7c)) {\n        display_error_001126c0(0,param_2,lVar16,0);\n        return 0;\n      }\n    }\n  }\n  for (; puVar38 != (undefined8 *)0x0; puVar38 = (undefined8 *)*puVar38) {\n    lVar35 = bfd_get_section_by_name(param_1,puVar38[1]);\n    puVar38[5] = lVar35;\n    if (lVar35 == 0) {\n      uVar18 = puVar38[1];\n      uVar17 = dcgettext(0,\"error: %s not found, can\\'t be updated\",5);\n      print_error_message_00119ed0(uVar17,uVar18);\n      return 0;\n    }\n    uVar18 = *(undefined8 *)(lVar35 + 0x60);\n    cVar11 = bfd_set_section_size(uVar18);\n    if (cVar11 == '\\0') {\n      display_error_001126c0(0,param_2,uVar18,0);\n      return 0;\n    }\n  }\n  puVar30 = DAT_001279b0;\n  if (DAT_00127a00 == '\\0') {\n    __ptr_01 = (long **)0x0;\n  }\n  else {\n    pplVar33 = (long **)param_1[0x12];\n    __ptr_01 = pplVar33;\n    if (pplVar33 != (long **)0x0) {\n      __ptr_01 = (long **)0x0;\nLAB_001151ab:\n      if (DAT_00127a00 != '\\0') goto LAB_00115187;\n      for (plVar6 = pplVar33[1]; puVar30 = DAT_001279b0, plVar6 != (long *)0x0;\n          plVar6 = (long *)plVar6[1]) {\n      }\n    }\n  }\njoined_r0x001151c7:\n  for (; puVar30 != (undefined8 *)0x0; puVar30 = (undefined8 *)*puVar30) {\n    lVar35 = bfd_get_section_by_name(param_1,puVar30[1]);\n    if (lVar35 == 0) {\n      dcgettext(0,\"can\\'t dump section \\'%s\\' - it does not exist\",5);\n      display_error_001126c0(0,param_1,0);\n    }\n    else if ((*(byte *)(lVar35 + 0x25) & 1) == 0) {\n      dcgettext(0,\"can\\'t dump section - it has no contents\",5);\n      display_error_001126c0(0,param_1,lVar35);\n    }\n    else {\n      sVar19 = *(size_t *)(lVar35 + 0x40);\n      __s_00 = fopen((char *)puVar30[2],\"w\");\n      if (__s_00 == (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        display_error_001126c0(puVar30[2],0,0);\n      }\n      else {\n        cVar11 = bfd_malloc_and_get_section(param_1,lVar35,&pcStack_c8);\n        if (cVar11 == '\\0') {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          display_error_001126c0(0,param_1,lVar35);\n        }\n        else if ((sVar19 != 0) && (sVar20 = fwrite(pcStack_c8,1,sVar19,__s_00), sVar20 != sVar19)) {\n          piVar25 = __errno_location();\n          pcVar34 = strerror(*piVar25);\n          uVar18 = puVar30[2];\n          uVar17 = dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          print_error_message_00119ed0(uVar17,uVar18,pcVar34);\n          free(pcStack_c8);\n          fclose(__s_00);\n          return 0;\n        }\n        fclose(__s_00);\n        free(pcStack_c8);\n      }\n    }\n  }\n  if (DAT_00127a10 == 0) {\nLAB_0010790a:\n    lStack_190 = 0;\n  }\n  else {\n    lVar35 = bfd_get_section_by_name(param_2,\".gnu_debuglink\");\n    if (lVar35 != 0) {\n      uVar18 = dcgettext(0,\"%s: debuglink section already exists\",5);\n      print_error_message_00119ed0(uVar18);\n      DAT_00127a10 = 0;\n      goto LAB_0010790a;\n    }\n    lStack_190 = bfd_create_gnu_debuglink_section(param_2);\n    lVar35 = DAT_00127a10;\n    if (lStack_190 == 0) {\n      uVar18 = dcgettext(0,\"cannot create debug link section `%s\\'\",5);\n      display_error_001126c0(0,param_2,0,uVar18,lVar35);\n      return 0;\n    }\n    if (*(int *)(*(long *)(param_2 + 8) + 8) == 2) {\n      uVar22 = 0;\n      for (uVar26 = *(ulong *)(param_2 + 0x90); uVar26 != 0; uVar26 = *(ulong *)(uVar26 + 8)) {\n        uVar24 = *(ulong *)(uVar26 + 0x30);\n        uVar31 = uVar22;\n        uVar7 = uVar26;\n        uVar8 = uVar22;\n        if (uVar24 != 0) {\n          while ((uVar31 = uVar7, uVar8 != 0 &&\n                 (uVar31 = uVar26, uVar24 <= *(ulong *)(uVar22 + 0x30)))) {\n            uVar26 = *(ulong *)(uVar26 + 8);\n            if (uVar26 == 0) goto LAB_00107db8;\n            uVar24 = *(ulong *)(uVar26 + 0x30);\n            uVar7 = uVar22;\n            uVar8 = uVar24;\n          }\n        }\n        uVar22 = uVar31;\n      }\nLAB_00107db8:\n      if (uVar22 == 0) {\n        uVar26 = 0x1000;\n      }\n      else {\n        uVar22 = *(long *)(uVar22 + 0x40) + *(long *)(uVar22 + 0x30);\n        uVar26 = 0xffffffffffffffff;\n        if (uVar22 < 0xfffffffffffff001) {\n          uVar26 = uVar22 + 0xfff & 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(lStack_190 + 0x28) = *(byte *)(lStack_190 + 0x28) | 1;\n      *(ulong *)(lStack_190 + 0x30) = uVar26;\n      *(ulong *)(lStack_190 + 0x38) = uVar26;\n    }\n  }\n  plVar6 = DAT_001278b0;\n  if (*(int *)(param_2 + 0xa0) != 0) {\n    uVar26 = process_debug_info_0010554f();\n    return uVar26;\n  }\n  if (DAT_00127980 == '\\0') {\nLAB_00105588:\n    puStack_1e8 = (undefined4 *)0x0;\n  }\n  else {\n    ppuVar42 = &PTR_s__stab_00125c60;\n    puStack_1e8 = (undefined4 *)xmalloc(0x60);\n    puVar36 = puStack_1e8;\n    for (lVar35 = 0x18; lVar35 != 0; lVar35 = lVar35 + -1) {\n      *puVar36 = 0;\n      puVar36 = puVar36 + (ulong)bVar44 * -2 + 1;\n    }\n    pcStack_1d0 = (char *)0x0;\n    do {\n      puVar3 = *ppuVar42;\n      lVar35 = bfd_get_section_by_name(param_1,puVar3);\n      lVar16 = bfd_get_section_by_name();\n      if ((lVar35 != 0) && (lVar16 != 0)) {\n        lVar23 = *(long *)(lVar35 + 0x40);\n        __ptr = (void *)xmalloc(lVar23);\n        cVar11 = bfd_get_section_contents(param_1,lVar35,__ptr,0,lVar23);\n        if (cVar11 == '\\0') {\n          uVar14 = bfd_get_error();\n          bfd_errmsg(uVar14);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*param_1);\n          free(pcStack_1d0);\n          free(__ptr);\n        }\n        else {\n          uVar26 = *(ulong *)(lVar16 + 0x40);\n          __ptr_00 = (void *)xmalloc(uVar26 + 1);\n          local_1f0._0_1_ = bfd_get_section_contents(param_1,lVar16,__ptr_00,0);\n          if ((char)local_1f0 == '\\0') {\n            uVar14 = bfd_get_error();\n            bfd_errmsg(uVar14);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*param_1);\n            free(pcStack_1d0);\n          }\n          else {\n            *(undefined *)((long)__ptr_00 + uVar26) = 0;\n            if ((pcStack_1d0 != (char *)0x0) ||\n               (pcStack_1d0 = (char *)initialize_data_structure_00112894(param_1,1,plVar6), pcStack_1d0 != (char *)0x0)) {\n              lStack_168 = 0;\n              lStack_180 = 0;\n              for (pvVar41 = __ptr; pvVar41 <= (void *)((long)__ptr + lVar23 + -0xc);\n                  pvVar41 = (void *)((long)pvVar41 + 0xc)) {\n                uVar22 = (**(code **)(param_1[1] + 0x40))(pvVar41);\n                bVar2 = *(byte *)((long)pvVar41 + 4);\n                uVar14 = (**(code **)(param_1[1] + 0x58))((long)pvVar41 + 6);\n                lVar35 = (**(code **)(param_1[1] + 0x40))((long)pvVar41 + 8);\n                if (bVar2 == 0) {\n                  lStack_180 = lStack_168;\n                  lStack_168 = lStack_168 + lVar35;\n                }\n                else {\n                  uVar24 = (uVar22 & 0xffffffff) + lStack_180;\n                  if (uVar24 < uVar26) {\n                    pcVar34 = (char *)((long)__ptr_00 + uVar24);\n                    pcStack_178 = (char *)0x0;\n                    while( true ) {\n                      sVar19 = strlen(pcVar34);\n                      if (((sVar19 == 0) || (pcVar29 = pcVar34 + (sVar19 - 1), *pcVar29 != '\\\\')) ||\n                         ((ulong)((long)__ptr + lVar23) < (long)pvVar41 + 0x10U)) goto LAB_001077fb;\n                      *pcVar29 = '\\0';\n                      pvVar41 = (void *)((long)pvVar41 + 0xc);\n                      iVar13 = (**(code **)(param_1[1] + 0x40))(pvVar41);\n                      uVar22 = (ulong)(uint)(iVar13 + (int)lStack_180);\n                      if (uVar26 <= uVar22) break;\n                      pcVar34 = (char *)concat(pcVar34,(long)__ptr_00 + uVar22,0);\n                      *pcVar29 = '\\\\';\n                      free(pcStack_178);\n                      pcStack_178 = pcVar34;\n                    }\n                    uVar18 = *param_1;\n                    pcVar29 = (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar29,uVar18,puVar3,((long)pvVar41 - (long)__ptr) / 0xc);\nLAB_001077fb:\n                    update_data_entry_001088ae((ulong)bVar2,uVar14,lVar35,pcVar34);\n                    cVar11 = process_debug_info_0011173a(puStack_1e8,pcStack_1d0,bVar2);\n                    if (cVar11 == '\\0') {\n                      print_stab_entries_00108b3e();\n                      free_memory_and_reset_00108863();\n                      free(pcStack_178);\n                      free(pcStack_1d0);\n                      free(__ptr);\n                      free(__ptr_00);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar18 = *param_1;\n                    pcVar34 = (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar34,uVar18,puVar3,((long)pvVar41 - (long)__ptr) / 0xc,\n                            uVar22 & 0xffffffff,(ulong)bVar2,((long)pvVar41 - (long)__ptr) % 0xc);\n                  }\n                }\n              }\n              free_memory_and_reset_00108863();\n              free(__ptr);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_00);\n          free(__ptr);\n        }\n        goto LAB_00105981;\n      }\nLAB_001058eb:\n      ppuVar42 = ppuVar42 + 2;\n    } while (ppuVar42 != (undefined **)&DAT_00125c90);\n    if ((pcStack_1d0 != (char *)0x0) && (cVar11 = process_debug_info_0010c892(), cVar11 == '\\0')) {\nLAB_00105981:\n      free(puStack_1e8);\n      goto LAB_00105588;\n    }\n    if (*(int *)(param_1[1] + 8) == 1) {\n      lVar35 = 0;\n      for (plVar15 = plVar6; plVar15 < plVar6 + uStack_1f8; plVar15 = plVar15 + 1) {\n        (**(code **)(param_1[1] + 0x218))(param_1,*plVar15,&pcStack_c8);\n        if ((char)uStack_c0 == '-') {\n          if (((lVar35 == 0) && (lVar35 = initialize_data_structure_00112894(param_1,0,plVar6), lVar35 == 0)) ||\n             ((pcStack_b8 == (char *)0x0 || (*pcStack_b8 == '\\0')))) goto LAB_00105981;\n          pcVar34 = (char *)0x0;\n          pcVar29 = pcStack_b8;\n          while (((*pcVar29 != '\\0' && (sVar19 = strlen(pcVar29), pcVar29[sVar19 - 1] == '\\\\')) &&\n                 (plVar15 + 1 < plVar6 + uStack_1f8))) {\n            pcVar21 = (char *)xstrdup(pcVar29);\n            sVar19 = strlen(pcVar21);\n            pcVar21[sVar19 - 1] = '\\0';\n            pcVar29 = (char *)concat(pcVar21,*(undefined8 *)(plVar15[1] + 8),0);\n            free(pcVar21);\n            free(pcVar34);\n            plVar15 = plVar15 + 1;\n            pcVar34 = pcVar29;\n          }\n          update_data_entry_001088ae(uStack_b0,(int)sStack_ae,pcStack_c8,pcVar29);\n          local_1f0._0_1_ = process_debug_info_0011173a(puStack_1e8,lVar35,uStack_b0);\n          if ((char)local_1f0 == '\\0') {\n            print_stab_entries_00108b3e();\n            free_memory_and_reset_00108863();\n            goto LAB_00105981;\n          }\n        }\n      }\n      free_memory_and_reset_00108863();\n      if ((lVar35 != 0) && (cVar11 = process_debug_info_0010c892(), cVar11 == '\\0')) goto LAB_00105981;\n    }\n    if ((char)local_1f0 == '\\0') {\n      if ((*(int *)(param_1[1] + 8) == 2) && (uStack_1f8 != 0)) {\n        pcStack_c8 = (char *)0x0;\n        plStack_148 = plVar6;\n        lStack_138 = 0;\n        lStack_130 = 0;\n        puVar37 = &uStack_c0;\n        for (lVar35 = 0x22; lVar35 != 0; lVar35 = lVar35 + -1) {\n          *(undefined4 *)puVar37 = 0;\n          puVar37 = (ulong *)((long)puVar37 + (ulong)bVar44 * -8 + 4);\n        }\n        cVar11 = '\\0';\n        piStack_1c0 = (int *)0x0;\n        uVar28 = 0;\n        pcStack_1d0 = (char *)0x0;\n        pcStack_178 = (char *)0xffffffffffffffff;\n        uStack_140 = uStack_1f8;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((long)uStack_1f8 <= lStack_138) goto LAB_00105590;\n            lVar35 = plVar6[lStack_138];\n            cVar10 = bfd_coff_get_syment(param_1,lVar35,apvStack_128);\n            lVar16 = lStack_130;\n            if (cVar10 == '\\0') {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar34 = \"bfd_coff_get_syment failed: %s\";\n              goto LAB_00105968;\n            }\n            pcVar34 = *(char **)(lVar35 + 8);\n            puVar30 = (undefined8 *)0x0;\n            lStack_138 = lStack_138 + 1;\n            lStack_130 = (ulong)bStack_107 + 1 + lStack_130;\n            if (bStack_107 != 0) {\n              puVar30 = &uStack_f8;\n              cVar10 = bfd_coff_get_auxent(param_1,lVar35,0);\n              if (cVar10 == '\\0') {\n                uVar14 = bfd_get_error();\n                bfd_errmsg(uVar14);\n                pcVar34 = \"bfd_coff_get_auxent failed: %s\";\n                goto LAB_00105968;\n              }\n            }\n            if (pcStack_178 != (char *)lVar16) break;\n            if (bStack_108 != 0x67) {\n              cVar10 = initialize_debug_info_0010bbd3(puStack_1e8);\n              if (cVar10 != '\\0') break;\n              goto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            pcStack_178 = (char *)lStack_118;\n            cVar10 = initialize_debug_info_0010bbd3(puStack_1e8);\n            if (cVar10 == '\\0') goto LAB_00105981;\n          }\n          uVar9 = uStack_10a;\n          if ((char)bStack_108 < '\\0') {\n            if (bStack_108 == 0xff) goto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            lVar23 = parse_and_initialize_data_0010dac0(param_1,&plStack_148,&pcStack_c8);\n            if (lVar23 == 0) break;\n            cVar10 = process_parameter_00112a33(&pcStack_c8,lVar35,lVar16);\n          }\n          else {\n            if (bStack_108 < 100) {\n              switch(bStack_108) {\n              case 3:\n                if (uStack_10a == 0) goto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulong)((uint)uStack_10a & *(uint *)(param_1[0x22] + 0x40)) !=\n                    2L << ((byte)*(undefined4 *)(param_1[0x22] + 0x3c) & 0x3f)) goto LAB_0010700a;\n                piStack_1c0 = (int *)(**(code **)(param_1[1] + 0x238))(param_1);\n                uVar28 = (uint)uVar9;\n                pcStack_1d0 = pcVar34;\n                goto switchD_00106e1a_caseD_68;\n              default:\n                goto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                goto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(bStack_108) {\n            case 100:\n              iVar13 = strcmp(pcVar34,\".bb\");\n              if (iVar13 == 0) {\n                cVar10 = start_debug_block_0010be88(puStack_1e8);\n              }\n              else {\n                iVar13 = strcmp(pcVar34,\".eb\");\n                if (iVar13 != 0) goto switchD_00106e1a_caseD_68;\n                cVar10 = debug_end_block_check_0010bf20(puStack_1e8);\n              }\n              break;\n            case 0x65:\n              iVar13 = strcmp(pcVar34,\".bf\");\n              if (iVar13 == 0) {\n                if (pcStack_1d0 != (char *)0x0) {\n                  uVar39 = (int)uVar28 >> ((byte)*(undefined4 *)(param_1[0x22] + 0x44) & 0x1f);\n                  lVar16 = parse_and_initialize_data_0010dac0(param_1,&plStack_148,&pcStack_c8,lVar16,\n                                        uVar39 ^ (uVar28 ^ uVar39) & *(uint *)(param_1[0x22] + 0x38)\n                                        ,puVar30,0,puStack_1e8);\n                  if ((lVar16 == 0) || (cVar11 = initialize_debug_record_0010bc80(puStack_1e8), cVar11 == '\\0'))\n                  goto LAB_00105981;\n                  if (piStack_1c0 != (int *)0x0) {\n                    iVar13 = 0;\n                    if (bStack_107 != 0) {\n                      iVar13 = uStack_f0 - 1;\n                    }\n                    lVar35 = *(long *)(*(long *)(lVar35 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar32 = piStack_1c0[4];\n                      if (iVar32 == 0) break;\n                      cVar10 = record_line_info_0010bf86(puStack_1e8,iVar13 + iVar32,\n                                            *(long *)(piStack_1c0 + 6) + lVar35);\n                      piStack_1c0 = piStack_1c0 + 4;\n                      if (cVar10 == '\\0') goto LAB_00105981;\n                    }\n                  }\n                  uVar28 = 0;\n                  piStack_1c0 = (int *)0x0;\n                  pcStack_1d0 = (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar34 = \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar13 = strcmp(pcVar34,\".ef\");\n                if (iVar13 != 0) goto switchD_00106e1a_caseD_68;\n                if (cVar11 != '\\0') {\n                  cVar11 = end_debugging_function_0010be1a(puStack_1e8);\n                  if (cVar11 == '\\0') goto LAB_00105981;\n                  cVar11 = '\\0';\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar34 = \"%ld: unexpected .ef\\n\";\n              }\n              uVar18 = dcgettext(0,pcVar34,5);\n              print_error_message_00119ed0(uVar18);\n              goto LAB_00105981;\n            default:\n              goto LAB_0010700a;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (cVar10 != '\\0');\n      }\n      else {\n        pcVar34 = \"%s: no recognized debugging information\";\nLAB_00105968:\n        uVar18 = dcgettext(0,pcVar34,5);\n        print_error_message_00119ed0(uVar18);\n      }\n      goto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)(param_2 + 0x44) & 0x42) != 0) && ((*(uint *)(param_2 + 0x44) & 1) == 0)) {\n    if ((*(char *)(*(long *)(param_2 + 8) + 0x20) == '\\0') && (DAT_00127939 == '\\0')) {\n      if (uStack_1f8 != 0) {\n        plVar6 = DAT_001278b0 + uStack_1f8;\n        plVar15 = DAT_001278b0;\n        do {\n          uVar28 = *(uint *)(*plVar15 + 0x18);\n          if ((uVar28 & 0x1000000) != 0) {\n            *(uint *)(*plVar15 + 0x18) = uVar28 & 0xfeffffff;\n          }\n          plVar15 = plVar15 + 1;\n        } while (plVar6 != plVar15);\n      }\n    }\n    else {\n      for (lVar35 = *(long *)(param_2 + 0x90); lVar35 != 0; lVar35 = *(long *)(lVar35 + 8)) {\n        if (*(long *)(lVar35 + 0xe8) != 0) {\n          puVar1 = (uint *)(*(long *)(lVar35 + 0xe8) + 0x18);\n          *puVar1 = *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((DAT_00127a2c == 2) || (DAT_00127a2c == 7)) {\nLAB_001059fe:\n    if (DAT_00127a2c == 7) {\nLAB_00105a3b:\n      plVar15 = (long *)xmalloc();\n      plVar6 = DAT_001278b0;\n      piStack_1c0._0_4_ = *(uint *)((long)param_1 + 0x44) & 0x42;\n      DAT_001278a8 = plVar15;\n      if (uStack_1f8 == 0) {\n        uVar26 = 0;\n      }\n      else {\n        uVar26 = 0;\n        local_1f0 = 0;\n        do {\n          iVar13 = DAT_001279a0;\n          plVar4 = (long *)plVar6[local_1f0];\n          pcVar5 = (code *)plVar4[4];\n          uVar28 = *(uint *)(plVar4 + 3);\n          pcVar34 = (char *)plVar4[1];\n          pcVar29 = pcVar34;\n          if (DAT_001279a8 != (undefined8 *)0x0) {\n            iVar32 = 0;\n            puVar30 = DAT_001279a8;\n            while ((iVar32 < iVar13 && (pcVar21 = (char *)puVar30[5], pcVar21 != (char *)0x0))) {\n              if (pcVar21 != \"\") {\n                iVar12 = strcmp(pcVar21,pcVar34);\n                if (iVar12 == 0) {\n                  free(pcVar21);\n                  uVar22 = uVar26 + 1;\n                  puVar30[5] = \"\";\n                  lVar35 = update_section_info_0011a2e0(puVar30);\n                  uVar18 = DAT_001278d0;\n                  plVar15[uVar26] = lVar35;\n                  lVar35 = htab_elements(uVar18);\n                  if ((lVar35 != 0) || (DAT_001278d8 != (char **)0x0)) goto LAB_001064eb;\n                  goto LAB_00105af8;\n                }\n                puVar30 = (undefined8 *)*puVar30;\n              }\n              iVar32 = iVar32 + 1;\n            }\n          }\n          lVar35 = htab_elements(DAT_001278d0);\n          uVar22 = uVar26;\n          if ((lVar35 != 0) || (DAT_001278d8 != (char **)0x0)) {\n            if (pcVar34 != (char *)0x0) {\nLAB_001064eb:\n              if (((*pcVar34 == '_') && (pcVar34[1] == '_')) &&\n                 (iVar13 = strcmp(pcVar34 + (pcVar34[2] == '_'),\"__gnu_lto_slim\"), iVar13 == 0)) {\n                uVar18 = dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\"\n                                   ,5);\n                    \n                print_error_and_exit_00119dd0(uVar18);\n              }\n            }\n            uStack_c0 = 0;\n            pcStack_c8 = pcVar34;\n            lVar35 = htab_find(DAT_001278d0);\n            if (((lVar35 == 0) || (pcVar29 = *(char **)(lVar35 + 8), pcVar34 == pcVar29)) &&\n               (pcVar29 = pcVar34, ppcVar40 = DAT_001278d8, (uVar28 & 0x100) != 0)) {\n              for (; ppcVar40 != (char **)0x0; ppcVar40 = (char **)ppcVar40[3]) {\n                iVar13 = strcmp(*ppcVar40,pcVar34);\n                if (iVar13 == 0) {\n                  pcVar29 = ppcVar40[1];\n                  break;\n                }\n              }\n            }\n            plVar4[1] = (long)pcVar29;\n            cVar11 = *pcVar29;\n            if (cVar11 != '\\0') goto LAB_00105b11;\nLAB_00106557:\n            pcVar34 = DAT_00127908;\n            if ((DAT_00127988 != '\\0') && (*(char *)(*(long *)(param_2 + 8) + 0x1c) != '\\0')) {\n              lVar35 = param_1[1];\n              cVar11 = '\\0';\n              goto LAB_0010668d;\n            }\n            goto joined_r0x00106565;\n          }\nLAB_00105af8:\n          cVar11 = *pcVar34;\n          if (cVar11 == '\\0') goto LAB_00106557;\nLAB_00105b11:\n          pcVar34 = DAT_00127908;\n          lVar35 = param_1[1];\n          if (*(char *)(lVar35 + 0x1c) == cVar11) {\n            if (DAT_00127988 == '\\0') {\n              if ((DAT_00127968 == '\\0') ||\n                 ((((uVar28 & 0x82) == 0 && (pcVar5 != bfd_map_over_sections)) &&\n                  ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n              pcVar29 = pcVar29 + 1;\n              plVar4[1] = (long)pcVar29;\n              goto joined_r0x00106565;\n            }\n            cVar11 = *(char *)(*(long *)(param_2 + 8) + 0x1c);\n            if (cVar11 == '\\0') goto LAB_0010677d;\n            if (DAT_00127908 != (char *)0x0) {\n              pcVar29 = pcVar29 + 1;\n              plVar4[1] = (long)pcVar29;\n              sVar19 = strlen(pcVar29);\n              lVar35 = sVar19 + 2;\nLAB_001066bc:\n              sVar19 = strlen(pcVar34);\n              pcVar34 = (char *)xmalloc(sVar19 + lVar35);\n              goto LAB_001066d0;\n            }\n            *pcVar29 = cVar11;\n            plVar4[1] = (long)pcVar29;\n            uVar26 = uVar22;\n          }\n          else {\n            if ((DAT_00127988 == '\\0') || (*(char *)(*(long *)(param_2 + 8) + 0x1c) == '\\0')) {\njoined_r0x00106565:\n              uVar26 = uVar22;\n              if (pcVar34 == (char *)0x0) goto LAB_00105b32;\n              sVar19 = strlen(pcVar29);\n              sVar20 = strlen(pcVar34);\n              pcVar21 = (char *)xmalloc(sVar20 + sVar19 + 1);\n              pcVar34 = pcVar21;\n            }\n            else {\nLAB_0010668d:\n              pcVar34 = DAT_00127908;\n              if ((*(char *)(lVar35 + 0x1c) != '\\0') && (cVar11 != *(char *)(lVar35 + 0x1c)))\n              goto joined_r0x00106565;\n              sVar19 = strlen(pcVar29);\n              lVar35 = sVar19 + 2;\n              if (pcVar34 != (char *)0x0) goto LAB_001066bc;\n              pcVar34 = (char *)xmalloc(lVar35);\nLAB_001066d0:\n              pcVar21 = pcVar34 + 1;\n              *pcVar34 = *(char *)(*(long *)(param_2 + 8) + 0x1c);\n            }\n            __s = DAT_00127908;\n            if (DAT_00127908 != (char *)0x0) {\n              strcpy(pcVar21,DAT_00127908);\n              sVar19 = strlen(__s);\n              pcVar21 = pcVar21 + sVar19;\n            }\n            strcpy(pcVar21,pcVar29);\n            plVar4[1] = (long)pcVar34;\n            pcVar29 = pcVar34;\n            uVar26 = uVar22;\n          }\nLAB_00105b32:\n          if (DAT_00127a2c == 7) goto LAB_001067a8;\n          if (((uVar28 & 0x20) == 0) &&\n             (((uVar28 & 0x100) == 0 ||\n              ((*(byte *)(**(long **)(plVar4[4] + 0xf0) + 0x18) & 0x20) == 0)))) {\n            if ((((uint)piStack_1c0 == 0) &&\n                (((uVar28 & 0x82) != 0 || ((*(byte *)(plVar4[4] + 0x25) & 0x10) != 0)))) ||\n               (iVar13 = bfd_decode_symclass(plVar4), iVar13 == 0x49)) {\nLAB_00105be2:\n              if (DAT_001279ca == '\\0') {\n                lVar35 = htab_find();\n                if (lVar35 == 0) goto LAB_00105c07;\n              }\n              else {\n                uStack_c0 = uStack_c0 & 0xffffffffffffff00;\n                pcStack_c8 = pcVar29;\n                htab_traverse(DAT_001279f8,pattern_match_0011a170,&pcStack_c8);\n                if ((char)uStack_c0 == '\\0') goto LAB_00105c07;\n              }\n            }\n            else if ((((uVar28 & 0x82) == 0) && (pcVar5 != bfd_map_over_sections)) &&\n                    ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)) {\n              if ((uVar28 & 4) == 0) {\n                if (((*(int *)(param_1[1] + 8) != 2) ||\n                    (lVar35 = *(long *)(plVar4[4] + 0xd0), lVar35 == 0)) ||\n                   (*(long *)(lVar35 + 0x40) == 0)) {\n                  if ((DAT_00127a2c == 3) || (DAT_00127a28 == 2)) goto LAB_001067a8;\n                  if (DAT_00127a28 == 1) {\n                    cVar11 = bfd_is_local_label(param_1);\n                    goto joined_r0x00106a11;\n                  }\n                }\n                goto LAB_00105be2;\n              }\n              cVar11 = DAT_00127980;\n              if (1 < DAT_00127a2c - 2U) {\njoined_r0x00106a11:\n                if (cVar11 == '\\0') goto LAB_00105be2;\n              }\n            }\n            else if (DAT_00127a2c != 3) goto LAB_00105be2;\n            goto LAB_001067a8;\n          }\n          if (DAT_001279ca == '\\0') {\n            lVar35 = htab_find();\n            if (lVar35 != 0) {\nLAB_0010687f:\n              uVar18 = dcgettext(0,\"not stripping symbol `%s\\' because it is named in a relocation\",\n                                 5);\n              print_error_message_00119ed0(uVar18);\n              DAT_00127a20 = 1;\n            }\n          }\n          else {\n            uStack_c0 = uStack_c0 & 0xffffffffffffff00;\n            pcStack_c8 = pcVar29;\n            htab_traverse(DAT_001279f8,pattern_match_0011a170,&pcStack_c8);\n            if ((char)uStack_c0 != '\\0') goto LAB_0010687f;\n          }\n          if ((uVar28 & 0x20) == 0) {\nLAB_00105c07:\n            if (DAT_001279ca != '\\0') {\n              uStack_c0 = uStack_c0 & 0xffffffffffffff00;\n              pcStack_c8 = pcVar29;\n              htab_traverse(DAT_001279f0,pattern_match_0011a170,&pcStack_c8);\n              if ((char)uStack_c0 != '\\0') goto LAB_001067a8;\n              goto LAB_00105c2c;\n            }\n            lVar35 = htab_find();\n            if (lVar35 == 0) goto LAB_00105c2c;\nLAB_001067a8:\n            if ((DAT_00127a18 != '\\0') && ((uVar28 & 0x4000) != 0)) goto LAB_00105c2c;\n            if (DAT_001279ca == '\\0') {\n              lVar35 = htab_find();\n              if (lVar35 != 0) goto LAB_00105c2c;\n            }\n            else {\n              uStack_c0 = uStack_c0 & 0xffffffffffffff00;\n              pcStack_c8 = pcVar29;\n              htab_traverse(DAT_00127a08,pattern_match_0011a170,&pcStack_c8);\n              if ((char)uStack_c0 != '\\0') goto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            cVar11 = process_section_data_001159d0(plVar4[4]);\n            if (cVar11 == '\\0') {\n              if (((uVar28 & 0x800002) == 0) && (pcVar5 != bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uVar28 & 0x82) != 0) {\n                  cVar11 = find_value_00115d70(pcVar29);\n                  if ((cVar11 == '\\0') &&\n                     ((lVar35 = htab_elements(DAT_001279d8), lVar35 == 0 ||\n                      (cVar11 = find_value_00115d70(pcVar29), cVar11 != '\\0')))) {\n                    if (((((DAT_00127938 == '\\0') ||\n                          (uVar39 = *(uint *)(plVar4 + 3), (uVar39 & 0x200000) != 0)) ||\n                         (lVar35 = *plVar4, lVar35 == 0)) ||\n                        ((*(int *)(*(long *)(lVar35 + 8) + 8) != 5 ||\n                         (*(long *)(lVar35 + 0x110) == 0)))) ||\n                       (1 < (*(byte *)((long)plVar4 + 0x49) & 3) - 1)) goto joined_r0x00105ca2;\n                  }\n                  else {\n                    uVar39 = *(uint *)(plVar4 + 3);\n                  }\n                  *(uint *)(plVar4 + 3) = uVar39 & 0xffffff7d | 1;\n                }\njoined_r0x00105ca2:\n                if (((uVar28 & 1) != 0) && (cVar11 = find_value_00115d70(pcVar29), cVar11 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((DAT_001279c8 != '\\0') || (cVar11 = find_value_00115d70(pcVar29), cVar11 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xff7ffffd | 0x80;\n                }\n                if (pcVar5 != bfd_map_over_sections) goto LAB_00105c5f;\n              }\n              plVar15[uVar26] = (long)plVar4;\n              uVar26 = uVar26 + 1;\n            }\n          }\n          local_1f0 = local_1f0 + 1;\n        } while (uStack_1f8 != local_1f0);\n      }\n      if (DAT_001279a8 != (undefined8 *)0x0) {\n        puVar30 = DAT_001279a8;\n        iVar13 = DAT_001279a0;\n        for (lVar35 = 0; lVar35 < iVar13; lVar35 = lVar35 + 1) {\n          pcVar34 = (char *)puVar30[5];\n          if (pcVar34 == (char *)0x0) {\n            plVar6 = plVar15 + uVar26;\n            uVar26 = uVar26 + 1;\n            lVar16 = update_section_info_0011a2e0(puVar30,param_2);\n            *plVar6 = lVar16;\n            iVar13 = DAT_001279a0;\n          }\n          else if (pcVar34 != \"\") {\n            uVar18 = dcgettext(0,\"\\'before=%s\\' not found\",5);\n                    \n            print_error_and_exit_00119dd0(uVar18,pcVar34);\n          }\n          puVar30 = (undefined8 *)*puVar30;\n        }\n      }\n      bVar43 = DAT_00127980 == '\\0';\n      plVar15[uVar26] = 0;\n      if ((bVar43) || (puStack_1e8 == (undefined4 *)0x0)) {\nLAB_00105cfa:\n        uStack_1f8 = uVar26 & 0xffffffff;\n        goto LAB_00105710;\n      }\n      iVar13 = *(int *)(*(undefined8 **)(param_2 + 8) + 1);\n      if ((iVar13 == 5) || (iVar13 == 2)) {\n        apvStack_128[0] = (void *)0x0;\n        cVar11 = extract_binary_data_0011378f(param_2,puStack_1e8,&plStack_148,&uStack_f8,apvStack_128,&pcStack_c8);\n        if (cVar11 != '\\0') {\n          lVar35 = bfd_make_section_with_flags(param_2,\".stab\",0x2108);\n          lVar16 = bfd_make_section_with_flags(param_2,\".stabstr\",0x2108);\n          if ((((lVar35 == 0) || (lVar16 == 0)) ||\n              (cVar11 = bfd_set_section_size(lVar35,uStack_f8), cVar11 == '\\0')) ||\n             (cVar11 = bfd_set_section_size(lVar16,pcStack_c8), cVar11 == '\\0')) {\n            pcVar34 = \"can\\'t create debugging section\";\n          }\n          else {\n            *(undefined4 *)(lVar35 + 0x7c) = 2;\n            *(undefined4 *)(lVar16 + 0x7c) = 0;\n            cVar11 = bfd_set_section_contents(param_2,lVar35,plStack_148,0,uStack_f8);\n            if ((cVar11 != '\\0') &&\n               (cVar11 = bfd_set_section_contents(param_2,lVar16,apvStack_128[0],0,pcStack_c8),\n               cVar11 != '\\0')) {\n              free(puStack_1e8);\n              goto LAB_00105cfa;\n            }\n            pcVar34 = \"can\\'t set debugging section contents\";\n          }\n          uVar18 = dcgettext(0,pcVar34,5);\n          display_error_001126c0(0,param_2,0,uVar18);\n          free(apvStack_128[0]);\n          free(puStack_1e8);\n          goto LAB_00105d96;\n        }\n      }\n      else {\n        uVar18 = **(undefined8 **)(param_2 + 8);\n        uVar17 = dcgettext(0,\"don\\'t know how to write debugging information for %s\",5);\n        display_error_001126c0(0,param_2,0,uVar17,uVar18);\n      }\n      free(puStack_1e8);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections(param_1,process_reloc_table_00116030,DAT_001278b0);\n      iVar13 = bfd_get_error();\n      if (iVar13 == 0) goto LAB_00105a3b;\n    }\nLAB_00105d96:\n    DAT_00127a20 = 1;\n  }\n  else {\n    if ((DAT_00127a2c - 3U < 4) || ((DAT_00127a28 != 0 || (DAT_00127938 != '\\0'))))\n    goto LAB_00105a07;\n    lVar35 = htab_elements(DAT_001279f8);\n    if (((lVar35 != 0) ||\n        (((((((lVar35 = htab_elements(DAT_00127a08), lVar35 != 0 ||\n              (lVar35 = htab_elements(DAT_001279e8), lVar35 != 0)) ||\n             (lVar35 = htab_elements(DAT_001279e0), lVar35 != 0)) ||\n            ((lVar35 = htab_elements(DAT_001279d8), lVar35 != 0 ||\n             (lVar35 = htab_elements(DAT_001279d0), lVar35 != 0)))) ||\n           (lVar35 = htab_elements(DAT_001278d0), lVar35 != 0)) ||\n          (((DAT_00127908 != (char *)0x0 || (DAT_001278b8 != '\\0')) ||\n           ((DAT_00127a19 != '\\0' ||\n            (((DAT_00127980 != '\\0' || (DAT_00127988 != '\\0')) || (DAT_00127968 != '\\0')))))))) ||\n         ((DAT_001278d8 != (char **)0x0 || (DAT_001279c8 != '\\0')))))) || (DAT_001279a0 != 0))\n    goto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(param_2,DAT_001278a8,uStack_1f8 & 0xffffffff);\n    bfd_map_over_sections(param_1,process_section_data_00115dc0,param_2);\n    bfd_map_over_sections(param_1,reverse_section_contents_00116110,param_2);\n    for (puVar30 = DAT_001279c0; puVar38 = DAT_001279b8, puVar30 != (undefined8 *)0x0;\n        puVar30 = (undefined8 *)*puVar30) {\n      cVar11 = bfd_set_section_contents(param_2,puVar30[5],puVar30[4],0,puVar30[3]);\n      if (cVar11 == '\\0') {\n        display_error_001126c0(0,param_2,puVar30[5],0);\n        return 0;\n      }\n    }\n    for (; puVar38 != (undefined8 *)0x0; puVar38 = (undefined8 *)*puVar38) {\n      uVar18 = *(undefined8 *)(puVar38[5] + 0x60);\n      cVar11 = bfd_set_section_contents(param_2,uVar18,puVar38[4],0,puVar38[3]);\n      if (cVar11 == '\\0') {\n        display_error_001126c0(0,param_2,uVar18,0);\n        return 0;\n      }\n    }\n    if (__ptr_01 == (long **)0x0) {\n      if ((DAT_00127a00 != '\\0') && (_DAT_00127a24 == 0)) {\n        uVar18 = *param_1;\n        uVar17 = dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n        print_error_message_00119ed0(uVar17,uVar18);\n      }\n    }\n    else {\n      pplVar33 = (long **)0x0;\n      for (puVar30 = *(undefined8 **)(param_2 + 0x90); puVar30 != (undefined8 *)0x0;\n          puVar30 = (undefined8 *)puVar30[1]) {\n        if (((DAT_00127a00 != '\\0') && (*(int *)(*(long *)(param_2 + 8) + 8) == 5)) &&\n           ((*(int *)(puVar30[0x1a] + 4) == 7 &&\n            (cVar11 = compare_strings_00113fb0(*puVar30,\".gnu.build.attributes\"), cVar11 != '\\0')))) {\n          if (pplVar33 == (long **)0x0) {\n            pplVar33 = __ptr_01;\n          }\n          pplVar27 = __ptr_01;\n          if ((undefined8 *)(*pplVar33)[0xc] == puVar30) {\nLAB_0010625f:\n            pcVar34 = \"error: failed to merge notes\";\n            if (pplVar33[1] != (long *)0x0) {\n              cVar11 = bfd_set_section_contents(param_2,puVar30,pplVar33[1],0,pplVar33[2]);\n              if (cVar11 == '\\0') {\n                uVar18 = dcgettext(0,\"error: failed to copy merged notes into output\",5);\n                display_error_001126c0(0,param_2,puVar30,uVar18);\n                return 0;\n              }\n              pplVar33 = (long **)pplVar33[3];\n              goto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              pplVar33 = pplVar27;\n              if ((undefined8 *)(*pplVar27)[0xc] == puVar30) goto LAB_0010625f;\n              pplVar33 = (long **)pplVar27[3];\n              pplVar27 = pplVar33;\n            } while (pplVar33 != (long **)0x0);\n            pcVar34 = \"error: failed to locate merged notes\";\n          }\n          uVar18 = dcgettext(0,pcVar34,5);\n          display_error_001126c0(0,param_2,puVar30,uVar18);\n        }\nLAB_001061be:\n      }\n      do {\n        pplVar33 = (long **)__ptr_01[3];\n        free(__ptr_01[1]);\n        free(__ptr_01);\n        __ptr_01 = pplVar33;\n      } while (pplVar33 != (long **)0x0);\n    }\n    if ((DAT_00127a10 == 0) ||\n       (cVar11 = bfd_fill_in_gnu_debuglink_section(param_2,lStack_190), lVar35 = DAT_00127a10,\n       cVar11 != '\\0')) {\n      uVar28 = (**(code **)(*(long *)(param_2 + 8) + 0x140))(param_1);\n      uVar26 = (ulong)uVar28;\n      if ((char)uVar28 != '\\0') {\n        if (DAT_00127910 == 0) {\n          return uVar26;\n        }\n        cVar11 = bfd_alt_mach_code(param_2,DAT_00127910 & 0xffffffff);\n        uVar22 = DAT_00127910;\n        if (cVar11 == '\\0') {\n          uVar18 = dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n          print_error_message_00119ed0(uVar18,uVar22);\n          if (*(int *)(*(long *)(param_2 + 8) + 8) == 5) {\n            uVar18 = dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n            print_error_message_00119ed0(uVar18);\n            *(short *)(*(long *)(param_2 + 0x110) + 0x3a) = (short)DAT_00127910;\n            return uVar26;\n          }\n          uVar18 = dcgettext(0,\"ignoring the alternative value\",5);\n          print_error_message_00119ed0(uVar18);\n          return uVar26;\n        }\n        return uVar26;\n      }\n      uVar18 = dcgettext(0,\"error copying private BFD data\",5);\n      display_error_001126c0(0,param_2,0,uVar18);\n    }\n    else {\n      uVar18 = dcgettext(0,\"cannot fill debug link section `%s\\'\",5);\n      display_error_001126c0(0,param_2,0,uVar18,lVar35);\n    }\n  }\n  return 0;\nLAB_00115187:\n  if ((((*(int *)(param_1[1] + 8) == 5) && (*(int *)((long)pplVar33[0x1a] + 4) == 7)) &&\n      (cVar11 = compare_strings_00113fb0(*pplVar33), cVar11 != '\\0')) &&\n     ((pplVar33[0xc] != (long *)0x0 && (plVar6 = pplVar33[8], plVar6 != (long *)0x0)))) {\n    pplVar27 = (long **)xmalloc(0x20);\n    pplVar27[1] = (long *)0x0;\n    cVar11 = bfd_get_full_section_contents(param_1,pplVar33,pplVar27 + 1);\n    if (cVar11 == '\\0') {\n      dcgettext(0,\"warning: could not load note section\",5);\n      display_error_001126c0(0,param_1,pplVar33);\n      free(pplVar27);\n    }\n    else {\n      plVar15 = (long *)parse_gnu_build_attribute_notes_001163d0(param_1,pplVar33,plVar6);\n      pplVar27[2] = plVar15;\n      if ((plVar15 == plVar6) || (cVar11 = bfd_set_section_size(pplVar33[0xc]), cVar11 != '\\0')) {\n        pplVar27[3] = (long *)__ptr_01;\n        *pplVar27 = (long *)pplVar33;\n        __ptr_01 = pplVar27;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        display_error_001126c0(0,param_2,pplVar33);\n        free(pplVar27[1]);\n        free(pplVar27);\n      }\n    }\n  }\n  pplVar33 = (long **)pplVar33[1];\n  puVar30 = DAT_001279b0;\n  if (pplVar33 == (long **)0x0) goto joined_r0x001151c7;\n  goto LAB_001151ab;\n}\n\n",
            "called": [
                "bfd_set_format",
                "dcgettext",
                "FUN_00119ed0",
                "FUN_00107976",
                "FUN_001125fa",
                "FUN_001126c0"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00114e50",
            "calling": [
                "FUN_00104ea2",
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "FUNC_00114e50"
        },
        "FUN_00115d00": {
            "renaming": {
                "FUN_00115d00": "find_element_in_array_00115d00",
                "param_1": "array",
                "param_2": "data_structure",
                "uVar1": "element_count",
                "lVar2": "result"
            },
            "code": "\nlong find_element_in_array_00115d00(long array,long data_structure)\n\n{\n  uint element_count;\n  long result;\n  \n  result = DAT_001278b0;\n  if (DAT_001278b0 != 0) {\n    if (*(int *)(*(long *)(data_structure + 8) + 8) == 5) {\n      if (*(int *)(array + 0x28) == *(int *)(*(long *)(data_structure + 0x110) + 0xd40)) {\n        element_count = *(uint *)(array + 0x2c);\n        if (element_count == 0) {\n          result = 0;\n        }\n        else if ((ulong)element_count <\n                 *(ulong *)(*(long *)(data_structure + 0x110) + 0x88) /\n                 (ulong)*(byte *)(*(long *)(*(long *)(*(long *)(data_structure + 8) + 0x380) + 0x340) + 5))\n        {\n          result = *(long *)(DAT_001278b0 + (ulong)(element_count - 1) * 8);\n        }\n        else {\n          result = 0;\n        }\n      }\n      else {\n        result = 0;\n      }\n    }\n    else {\n      result = 0;\n    }\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_001082c3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115d00",
            "calling": [
                "FUN_00108179",
                "FUN_001159d0"
            ],
            "imported": false,
            "current_name": "find_element_in_array_00115d00"
        },
        "FUN_00113c43": {
            "renaming": {
                "FUN_00113c43": "initialize_and_store_data_00113c43",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "param_5": "input_5",
                "param_6": "input_6",
                "lVar1": "data_ptr",
                "plVar2": "allocated_ptr",
                "auVar3": "result",
                "initialize_data_00112904": "initialize_data",
                "xmalloc": "allocate_memory"
            },
            "code": "\nundefined  [16]\ninitialize_and_store_data_00113c43(long input_1,long input_2,long input_3,long input_4,undefined input_5,\n            undefined8 input_6)\n\n{\n  long data_ptr;\n  long *allocated_ptr;\n  undefined result [16];\n  \n  if ((input_1 != 0) && (input_2 != 0)) {\n    data_ptr = initialize_data(0x10,0);\n    if (data_ptr != 0) {\n      allocated_ptr = (long *)xmalloc(0x28);\n      *(undefined4 *)((long)allocated_ptr + 0x21) = 0;\n      *allocated_ptr = input_1;\n      *(undefined4 *)((long)allocated_ptr + 0x24) = 0;\n      allocated_ptr[1] = input_2;\n      allocated_ptr[2] = input_3;\n      allocated_ptr[3] = input_4;\n      *(undefined *)(allocated_ptr + 4) = input_5;\n      *(long **)(data_ptr + 0x10) = allocated_ptr;\n      goto LAB_00113caa;\n    }\n  }\n  data_ptr = 0;\nLAB_00113caa:\n  result._8_8_ = input_6;\n  result._0_8_ = data_ptr;\n  return result;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113c43",
            "calling": [
                "FUN_0010c95e",
                "FUN_0010ee3f",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "initialize_and_store_data_00113c43"
        },
        "FUN_00112a33": {
            "renaming": {
                "FUN_00112a33": "process_parameter_00112a33",
                "param_1": "paramPointer",
                "param_2": "paramAddress",
                "param_3": "paramStruct",
                "param_4": "paramFlag",
                "param_5": "paramData",
                "param_6": "paramValue",
                "param_7": "paramMask",
                "uVar1": "returnValue",
                "lVar2": "tempVariable",
                "plVar3": "pointerToLongVariable"
            },
            "code": "\nbool processParameter_00112a33(undefined8 paramPointer,long paramAddress,undefined8 paramStruct,byte paramFlag,undefined8 paramData\n                 ,undefined8 paramValue,uint paramMask)\n\n{\n  undefined returnValue;\n  long tempVariable;\n  long *pointerToLongVariable;\n  \n  if (paramFlag < 0x12) {\n    if (paramFlag != 0) {\n      switch(paramFlag) {\n      case 1:\n        returnValue = record_variable_data_0010c05d(paramData,*(undefined8 *)(paramAddress + 8),paramValue,4,\n                             *(long *)(paramAddress + 0x10) + *(long *)(*(long *)(paramAddress + 0x20) + 0x30)\n                            );\n        return (bool)returnValue;\n      case 2:\n        goto switchD_00112a73_caseD_2;\n      case 3:\n        returnValue = record_variable_data_0010c05d(paramData,*(undefined8 *)(paramAddress + 8),paramValue,(paramMask & 0xff) + 2,\n                             *(long *)(paramAddress + 0x10) + *(long *)(*(long *)(paramAddress + 0x20) + 0x30)\n                            );\n        return (bool)returnValue;\n      case 4:\n        returnValue = record_variable_data_0010c05d(paramData,*(undefined8 *)(paramAddress + 8),paramValue,5,\n                             *(long *)(paramAddress + 0x10) + *(long *)(*(long *)(paramAddress + 0x20) + 0x30)\n                            );\n        return (bool)returnValue;\n      case 9:\n        returnValue = record_parameter_0010bd62(paramData,*(undefined8 *)(paramAddress + 8),paramValue,1,\n                             *(long *)(paramAddress + 0x10) + *(long *)(*(long *)(paramAddress + 0x20) + 0x30)\n                            );\n        return (bool)returnValue;\n      case 10:\n      case 0xc:\n      case 0xf:\n        tempVariable = process_debug_tag_0010c6be(paramData,*(undefined8 *)(paramAddress + 8));\n        if (tempVariable == 0) {\n          return false;\n        }\n        pointerToLongVariable = (long *)allocate_and_initialize_slot_0010da0b(paramPointer,paramStruct);\n        *pointerToLongVariable = tempVariable;\n        break;\n      case 0xd:\n        tempVariable = initialize_data_structure_0010c218(paramData,*(undefined8 *)(paramAddress + 8));\n        return tempVariable != 0;\n      case 0x11:\n        returnValue = record_parameter_0010bd62(paramData,*(undefined8 *)(paramAddress + 8),paramValue,2,\n                             *(long *)(paramAddress + 0x10) + *(long *)(*(long *)(paramAddress + 0x20) + 0x30)\n                            );\n        return (bool)returnValue;\n      }\n    }\n  }\n  else if (paramFlag == 0x7f) {\nswitchD_00112a73_caseD_2:\n    returnValue = record_variable_data_0010c05d(paramData,*(undefined8 *)(paramAddress + 8),paramValue,1,\n                         *(long *)(paramAddress + 0x10) + *(long *)(*(long *)(paramAddress + 0x20) + 0x30));\n    return (bool)returnValue;\n  }\n  return true;\n}\n\n",
            "called": [
                "FUN_0010c218",
                "FUN_0010c6be",
                "FUN_0010bd62",
                "FUN_0010c05d",
                "FUN_0010da0b"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112a33",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "process_parameter_00112a33"
        },
        "bfd_hash_table_init": {
            "renaming": {},
            "code": "\nvoid bfd_hash_table_init(void)\n\n{\n  bfd_hash_table_init();\n  return;\n}\n\n",
            "called": [
                "bfd_hash_table_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104830",
            "calling": [
                "FUN_0011378f"
            ],
            "imported": false,
            "current_name": "bfd_hash_table_init"
        },
        "FUN_0010c2d2": {
            "renaming": {
                "FUN_0010c2d2": "initialize_data_structure_0010c2d2",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "uVar1": "typeId",
                "pcVar2": "typeName",
                "uVar3": "dataValue",
                "lVar4": "result",
                "plVar5": "subsection"
            },
            "code": "\n\n\nlong initializeDataStructure_0010c2d2(undefined8 param1,long param2,int *param3)\n\n{\n  uint typeId;\n  char *typeName;\n  undefined8 dataValue;\n  long result;\n  long *subsection;\n  uint uVar6;\n  \n  if ((*param3 == 0) && (typeId = param3[1], (int)typeId < 0)) {\n    uVar6 = ~typeId;\n    if (uVar6 < 0x22) {\n      result = *(long *)(param2 + 0x90 + (ulong)uVar6 * 8);\n      if (result == 0) {\n        switch(uVar6) {\n        case 1:\n          dataValue = update_data_00113dfe(1,0);\n          typeName = \"char\";\n          break;\n        case 2:\n          dataValue = update_data_00113dfe(2,0);\n          typeName = \"short\";\n          break;\n        case 3:\n          dataValue = update_data_00113dfe(4,0);\n          typeName = \"long\";\n          break;\n        case 4:\n          dataValue = update_data_00113dfe(1,1);\n          typeName = \"unsigned char\";\n          break;\n        case 5:\n          dataValue = update_data_00113dfe(1,0);\n          typeName = \"signed char\";\n          break;\n        case 6:\n          dataValue = update_data_00113dfe(2,1);\n          typeName = \"unsigned short\";\n          break;\n        case 7:\n          dataValue = update_data_00113dfe(4,1);\n          typeName = \"unsigned int\";\n          break;\n        case 8:\n          dataValue = update_data_00113dfe(4,1);\n          typeName = \"unsigned\";\n          break;\n        case 9:\n          dataValue = update_data_00113dfe(4,1);\n          typeName = \"unsigned long\";\n          break;\n        case 10:\n          dataValue = initialize_data_00113e17();\n          typeName = \"void\";\n          break;\n        case 0xb:\n          dataValue = initialize_data_00113df2(4);\n          typeName = \"float\";\n          break;\n        case 0xc:\n          dataValue = initialize_data_00113df2(8);\n          typeName = \"double\";\n          break;\n        case 0xd:\n          dataValue = initialize_data_00113df2(8);\n          typeName = \"long double\";\n          break;\n        case 0xe:\n          dataValue = update_data_00113dfe(4,0);\n          typeName = \"integer\";\n          break;\n        case 0xf:\n          dataValue = initialize_data_00112904(6,4);\n          typeName = \"boolean\";\n          break;\n        case 0x10:\n          dataValue = initialize_data_00113df2(4);\n          typeName = \"short real\";\n          break;\n        case 0x11:\n          dataValue = initialize_data_00113df2(8);\n          typeName = \"real\";\n          break;\n        case 0x12:\n          typeName = \"stringptr\";\n          dataValue = 0;\n          break;\n        case 0x13:\n          dataValue = update_data_00113dfe(1,1);\n          typeName = \"character\";\n          break;\n        case 0x14:\n          dataValue = initialize_data_00112904(6,1);\n          typeName = \"logical*1\";\n          break;\n        case 0x15:\n          dataValue = initialize_data_00112904(6,2);\n          typeName = \"logical*2\";\n          break;\n        case 0x16:\n          dataValue = initialize_data_00112904(6,4);\n          typeName = \"logical*4\";\n          break;\n        case 0x17:\n          dataValue = initialize_data_00112904(6,4);\n          typeName = \"logical\";\n          break;\n        case 0x18:\n          dataValue = initialize_data_00112904(5,8);\n          typeName = \"complex\";\n          break;\n        case 0x19:\n          dataValue = initialize_data_00112904(5,0x10);\n          typeName = \"double complex\";\n          break;\n        case 0x1a:\n          dataValue = update_data_00113dfe(1,0);\n          typeName = \"integer*1\";\n          break;\n        case 0x1b:\n          dataValue = update_data_00113dfe(2,0);\n          typeName = \"integer*2\";\n          break;\n        case 0x1c:\n          dataValue = update_data_00113dfe(4,0);\n          typeName = \"integer*4\";\n          break;\n        case 0x1d:\n          dataValue = update_data_00113dfe(2,0);\n          typeName = \"wchar\";\n          break;\n        case 0x1e:\n          dataValue = update_data_00113dfe(8,0);\n          typeName = \"long long\";\n          break;\n        case 0x1f:\n          dataValue = update_data_00113dfe(8,1);\n          typeName = \"unsigned long long\";\n          break;\n        case 0x20:\n          dataValue = initialize_data_00112904(6,8);\n          typeName = \"logical*8\";\n          break;\n        case 0x21:\n          dataValue = update_data_00113dfe(8,0);\n          typeName = \"integer*8\";\n          break;\n        default:\n          dataValue = update_data_00113dfe(4,0);\n          typeName = \"int\";\n        }\n        result = initialize_data_structure_0010c218(param1,typeName,dataValue);\n        *(long *)(param2 + 0x90 + (ulong)uVar6 * 8) = result;\n        return result;\n      }\n      return result;\n    }\n    typeName = (char *)dcgettext(0,\"Unrecognized XCOFF type %d\\n\",5);\n    fprintf(_stderr,typeName,(ulong)typeId);\n  }\n  else {\n    subsection = (long *)validate_and_get_subsection_00109022(param2);\n    if (subsection != (long *)0x0) {\n      if (*subsection == 0) {\n        result = initialize_data_00113e23(subsection,0);\n        return result;\n      }\n      return *subsection;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_0010c218",
                "fprintf",
                "dcgettext",
                "FUN_00113df2",
                "FUN_00113e23",
                "FUN_00113dfe",
                "FUN_00113e17",
                "FUN_00109022",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c2d2",
            "calling": [
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "initialize_data_structure_0010c2d2"
        },
        "FUN_0010e07c": {
            "renaming": {
                "FUN_0010e07c": "process_binary_data_0010e07c",
                "param_2": "data_array",
                "param_5": "header_offset",
                "lVar1": "current_symbol_offset",
                "lVar2": "symbol_offset",
                "lVar3": "data_offset",
                "cVar4": "result",
                "uVar5": "error_code",
                "__ptr": "symbol_data",
                "uVar6": "data_value",
                "uVar7": "error_message",
                "puVar8": "symbol",
                "pcVar9": "error_format",
                "puVar10": "aux_data",
                "uVar11": "value",
                "lVar12": "symbol_count",
                "iVar13": "data_offset",
                "iVar14": "symbol_capacity",
                "local_a8": "local_arg_1",
                "uStack_a4": "local_arg_2",
                "uStack_a0": "local_arg_3",
                "uStack_9c": "local_arg_4",
                "local_88": "symbol_info",
                "local_6a": "another_info",
                "local_68": "type_info",
                "local_67": "flag",
                "local_60": "extra_info",
                "local_56": "offset",
                "print_error_message_00119ed0": "print_error_message",
                "xmalloc": "allocate_memory",
                "xrealloc": "reallocate_memory",
                "initialize_data_with_offset_00113da9": "initialize_data_with_offset"
            },
            "code": "\nundefined8\nprocess_binary_data_0010e07c(undefined8 param_1,long *data_array,undefined8 param_3,int param_4,long header_offset,\n            undefined8 param_6)\n\n{\n  long current_symbol_offset;\n  long symbol_offset;\n  long data_offset;\n  char result;\n  undefined4 error_code;\n  void *symbol_data;\n  undefined8 data_value;\n  undefined8 error_message;\n  undefined4 *symbol;\n  char *error_format;\n  undefined *aux_data;\n  uint value;\n  long symbol_count;\n  int data_offset;\n  int symbol_capacity;\n  undefined4 local_arg_1;\n  undefined4 local_arg_2;\n  undefined4 local_arg_3;\n  undefined4 local_arg_4;\n  undefined symbol_info [30];\n  undefined2 another_info;\n  byte type_info;\n  byte flag;\n  undefined extra_info [10];\n  ushort offset;\n  \n  symbol_capacity = 10;\n  symbol_count = 0;\n  current_symbol_offset = *(long *)(header_offset + 0x18);\n  symbol_data = (void *)xmalloc(0x50);\n  while ((data_array[3] < current_symbol_offset && (data_array[2] < data_array[1]))) {\n    symbol_offset = *(long *)(*data_array + data_array[2] * 8);\n    result = bfd_coff_get_syment(param_1,symbol_offset,symbol_info);\n    if (result == '\\0') {\n      error_code = bfd_get_error();\n      data_value = bfd_errmsg(error_code);\n      error_format = \"bfd_coff_get_syment failed: %s\";\nLAB_0010e18d:\n      error_message = dcgettext(0,error_format,5);\n      print_error_message(error_message,data_value);\n      free(symbol_data);\n      return 0;\n    }\n    data_offset = data_array[3];\n    aux_data = (undefined *)0x0;\n    data_array[2] = data_array[2] + 1;\n    data_array[3] = data_offset + 1 + (ulong)flag;\n    if (flag != 0) {\n      aux_data = extra_info;\n      result = bfd_coff_get_auxent(param_1,symbol_offset,0,aux_data);\n      if (result == '\\0') {\n        error_code = bfd_get_error();\n        data_value = bfd_errmsg(error_code);\n        error_format = \"bfd_coff_get_auxent failed: %s\";\n        goto LAB_0010e18d;\n      }\n    }\n    if (type_info == 0x12) {\n      value = (uint)offset;\n      data_offset = (int)*(undefined8 *)(symbol_offset + 0x10) +\n               (int)*(undefined8 *)(*(long *)(symbol_offset + 0x20) + 0x30);\n    }\n    else {\n      if (type_info < 0x13) {\n        if ((type_info == 8) || (type_info == 0xb)) {\n          value = 0;\n          data_offset = ((int)*(undefined8 *)(symbol_offset + 0x10) +\n                   (int)*(undefined8 *)(*(long *)(symbol_offset + 0x20) + 0x30)) * 8;\n          goto LAB_0010e214;\n        }\n      }\n      else if (type_info == 0x66) break;\n      value = 0;\n      data_offset = 0;\n    }\nLAB_0010e214:\n    error_message = parse_and_initialize_data_0010dac0(param_1,data_array,param_3,data_offset,another_info,aux_data,1);\n    data_value = *(undefined8 *)(symbol_offset + 8);\n    symbol = (undefined4 *)xmalloc(0x20);\n    local_arg_1 = (undefined4)data_value;\n    local_arg_2 = (undefined4)((ulong)data_value >> 0x20);\n    local_arg_3 = (undefined4)error_message;\n    local_arg_4 = (undefined4)((ulong)error_message >> 0x20);\n    *(undefined8 *)(symbol + 5) = 0;\n    symbol[6] = data_offset;\n    symbol[7] = value;\n    symbol[4] = 0;\n    *symbol = local_arg_1;\n    symbol[1] = local_arg_2;\n    symbol[2] = local_arg_3;\n    symbol[3] = local_arg_4;\n    if (symbol_capacity <= (int)symbol_count + 1) {\n      symbol_capacity = symbol_capacity + 10;\n      symbol_data = (void *)xrealloc(symbol_data,(long)symbol_capacity << 3,symbol,0,param_6);\n    }\n    *(undefined4 **)((long)symbol_data + symbol_count * 8) = symbol;\n    symbol_count = symbol_count + 1;\n  }\n  *(undefined8 *)((long)symbol_data + (long)(int)symbol_count * 8) = 0;\n  data_value = initialize_data_with_offset(param_4 == 8,*(undefined2 *)(header_offset + 10),symbol_data);\n  return data_value;\n}\n\n",
            "called": [
                "FUN_00113da9",
                "xrealloc",
                "bfd_errmsg",
                "free",
                "dcgettext",
                "xmalloc",
                "bfd_coff_get_syment",
                "FUN_00119ed0",
                "bfd_get_error",
                "bfd_coff_get_auxent",
                "FUN_0010dac0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e07c",
            "calling": [
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "process_binary_data_0010e07c",
            "code_backup": "\nundefined8\nFUN_0010e07c(undefined8 param_1,long *param_2,undefined8 param_3,int param_4,long param_5,\n            undefined8 param_6)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  char cVar4;\n  undefined4 uVar5;\n  void *__ptr;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  undefined4 *puVar8;\n  char *pcVar9;\n  undefined *puVar10;\n  uint uVar11;\n  long lVar12;\n  int iVar13;\n  int iVar14;\n  undefined4 local_a8;\n  undefined4 uStack_a4;\n  undefined4 uStack_a0;\n  undefined4 uStack_9c;\n  undefined local_88 [30];\n  undefined2 local_6a;\n  byte local_68;\n  byte local_67;\n  undefined local_60 [10];\n  ushort local_56;\n  \n  iVar14 = 10;\n  lVar12 = 0;\n  lVar1 = *(long *)(param_5 + 0x18);\n  __ptr = (void *)xmalloc(0x50);\n  while ((param_2[3] < lVar1 && (param_2[2] < param_2[1]))) {\n    lVar2 = *(long *)(*param_2 + param_2[2] * 8);\n    cVar4 = bfd_coff_get_syment(param_1,lVar2,local_88);\n    if (cVar4 == '\\0') {\n      uVar5 = bfd_get_error();\n      uVar6 = bfd_errmsg(uVar5);\n      pcVar9 = \"bfd_coff_get_syment failed: %s\";\nLAB_0010e18d:\n      uVar7 = dcgettext(0,pcVar9,5);\n      print_error_message_00119ed0(uVar7,uVar6);\n      free(__ptr);\n      return 0;\n    }\n    lVar3 = param_2[3];\n    puVar10 = (undefined *)0x0;\n    param_2[2] = param_2[2] + 1;\n    param_2[3] = lVar3 + 1 + (ulong)local_67;\n    if (local_67 != 0) {\n      puVar10 = local_60;\n      cVar4 = bfd_coff_get_auxent(param_1,lVar2,0,puVar10);\n      if (cVar4 == '\\0') {\n        uVar5 = bfd_get_error();\n        uVar6 = bfd_errmsg(uVar5);\n        pcVar9 = \"bfd_coff_get_auxent failed: %s\";\n        goto LAB_0010e18d;\n      }\n    }\n    if (local_68 == 0x12) {\n      uVar11 = (uint)local_56;\n      iVar13 = (int)*(undefined8 *)(lVar2 + 0x10) +\n               (int)*(undefined8 *)(*(long *)(lVar2 + 0x20) + 0x30);\n    }\n    else {\n      if (local_68 < 0x13) {\n        if ((local_68 == 8) || (local_68 == 0xb)) {\n          uVar11 = 0;\n          iVar13 = ((int)*(undefined8 *)(lVar2 + 0x10) +\n                   (int)*(undefined8 *)(*(long *)(lVar2 + 0x20) + 0x30)) * 8;\n          goto LAB_0010e214;\n        }\n      }\n      else if (local_68 == 0x66) break;\n      uVar11 = 0;\n      iVar13 = 0;\n    }\nLAB_0010e214:\n    uVar7 = FUNC_0010dac0(param_1,param_2,param_3,lVar3,local_6a,puVar10,1);\n    uVar6 = *(undefined8 *)(lVar2 + 8);\n    puVar8 = (undefined4 *)xmalloc(0x20);\n    local_a8 = (undefined4)uVar6;\n    uStack_a4 = (undefined4)((ulong)uVar6 >> 0x20);\n    uStack_a0 = (undefined4)uVar7;\n    uStack_9c = (undefined4)((ulong)uVar7 >> 0x20);\n    *(undefined8 *)(puVar8 + 5) = 0;\n    puVar8[6] = iVar13;\n    puVar8[7] = uVar11;\n    puVar8[4] = 0;\n    *puVar8 = local_a8;\n    puVar8[1] = uStack_a4;\n    puVar8[2] = uStack_a0;\n    puVar8[3] = uStack_9c;\n    if (iVar14 <= (int)lVar12 + 1) {\n      iVar14 = iVar14 + 10;\n      __ptr = (void *)xrealloc(__ptr,(long)iVar14 << 3,puVar8,0,param_6);\n    }\n    *(undefined4 **)((long)__ptr + lVar12 * 8) = puVar8;\n    lVar12 = lVar12 + 1;\n  }\n  *(undefined8 *)((long)__ptr + (long)(int)lVar12 * 8) = 0;\n  uVar6 = initialize_data_with_offset_00113da9(param_4 == 8,*(undefined2 *)(param_5 + 10),__ptr);\n  return uVar6;\n}\n\n"
        },
        "bfd_is_local_label": {
            "renaming": {},
            "code": "\nvoid bfd_is_local_label(void)\n\n{\n  bfd_is_local_label();\n  return;\n}\n\n",
            "called": [
                "bfd_is_local_label"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048a0",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_is_local_label"
        },
        "FUN_001082c3": {
            "renaming": {
                "FUN_001082c3": "initialize_application_001082c3",
                "undefined8": "void"
            },
            "code": "\nvoid initializeApplication_001082c3(void)\n\n{\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001082c3",
            "calling": [
                "FUN_00115d00"
            ],
            "imported": false,
            "current_name": "initialize_application_001082c3"
        },
        "FUN_00114460": {
            "renaming": {
                "FUN_00114460": "load_and_parse_file_00114460",
                "param_1": "file_path",
                "param_2": "hash_table",
                "param_3": "file_content",
                "iVar1": "line_number",
                "piVar2": "error_code",
                "pcVar3": "error_msg",
                "uVar4": "error",
                "__n": "file_size",
                "__ptr": "buffer",
                "__stream": "file",
                "sVar5": "bytes_read",
                "ppbVar6": "hash_slot",
                "pbVar7": "line",
                "bVar8": "current_byte",
                "pbVar9": "next_byte",
                "pbVar10": "current_pos",
                "pbVar11": "line_start",
                "pbVar12": "line_end"
            },
            "code": "\nvoid loadAndParseFile_00114460(char *file_path,undefined8 hash_table,byte **file_content)\n\n{\n  int line_number;\n  int *error_code;\n  char *error_msg;\n  undefined8 error;\n  size_t file_size;\n  byte *buffer;\n  FILE *file;\n  size_t bytes_read;\n  byte **hash_slot;\n  byte *line;\n  byte current_byte;\n  byte *next_byte;\n  byte *current_pos;\n  byte *line_start;\n  byte *line_end;\n  \n  file_size = check_file_properties_00113f50();\n  if (file_size == 0) {\n    DAT_00127a20 = 1;\n  }\n  else {\n    buffer = (byte *)xmalloc(file_size + 2);\n    file = fopen(file_path,\"r\");\n    if (file == (FILE *)0x0) {\n      error_code = __errno_location();\n      error_msg = strerror(*error_code);\n      error = dcgettext(0,\"cannot open \\'%s\\': %s\",5);\n                    \n      print_error_and_exit_00119dd0(error,file_path,error_msg);\n    }\n    bytes_read = fread(buffer,1,file_size,file);\n    if ((bytes_read == 0) || (line_number = ferror(file), line_number != 0)) {\n      error = dcgettext(0,\"%s: fread failed\",5);\n                    \n      print_error_and_exit_00119dd0(error,file_path);\n    }\n    line_number = 1;\n    fclose(file);\n    *(undefined2 *)(buffer + file_size) = 10;\n    current_byte = *buffer;\n    line_end = buffer;\n    while (current_pos = line_end, current_byte != 0) {\n      for (; current_byte = *current_pos, line_start = current_pos, current_byte != 10; current_pos = current_pos + 1) {\n        if ((char)current_byte < '\\v') {\n          if (current_byte == 0) {\n            next_byte = current_pos + 1;\n            goto LAB_00114553;\n          }\n        }\n        else {\n          if (current_byte == 0xd) {\n            *current_pos = 0;\n            next_byte = current_pos + 1;\n            if (current_pos[1] == 10) {\n              next_byte = current_pos + 2;\n              line_start = current_pos + 1;\n            }\n            goto LAB_00114553;\n          }\n          if (current_byte == 0x23) {\n            parse_lines_00104d1c();\n            return;\n          }\n        }\n      }\n      *current_pos = 0;\n      if (current_pos[1] == 0xd) {\n        line_start = current_pos + 1;\n        next_byte = current_pos + 2;\n      }\n      else {\n        next_byte = current_pos + 1;\n      }\nLAB_00114553:\n      current_byte = *line_end;\n      while ((current_byte == 0x20 || (current_pos = line_end, current_byte == 9))) {\n        current_pos = line_end + 1;\n        line_end = line_end + 1;\n        current_byte = *current_pos;\n      }\n      do {\n        if ((current_byte == 10) || (current_byte == 0xd)) goto LAB_00114676;\n        if (current_byte == 0) goto LAB_00114599;\n        current_byte = current_pos[1];\n        current_pos = current_pos + 1;\n      } while ((current_byte != 0x20) && (current_byte != 9));\n      if ((char)current_byte < '\\x0e') {\nLAB_00114676:\n        if ((-0x2402L >> (current_byte & 0x3f) & 1U) != 0) goto LAB_001145e6;\n      }\n      else {\nLAB_001145e6:\n        current_byte = current_pos[1];\n        if ((((((current_byte == 9) || (current_byte == 0x20)) &&\n              ((current_byte = current_pos[2], current_byte == 9 || (current_byte == 0x20)))) &&\n             ((current_byte = current_pos[3], current_byte == 9 || (current_byte == 0x20)))) &&\n            ((current_byte = current_pos[4], current_byte == 9 || (current_byte == 0x20)))) &&\n           ((current_byte = current_pos[5], current_byte == 9 || (current_byte == 0x20)))) {\n          current_byte = current_pos[6];\n          line = current_pos + 6;\n          if ((current_byte == 9) || (current_byte == 0x20)) {\n            do {\n              do {\n                current_byte = line[1];\n                line = line + 1;\n              } while (current_byte == 0x20);\n            } while (current_byte == 9);\n          }\n        }\n        if ((0xd < current_byte) || ((-0x2402L >> (current_byte & 0x3f) & 1U) != 0)) {\n          error = dcgettext(0,\"%s:%d: Ignoring rubbish found on this line\",5);\n          print_error_message_00119ed0(error,file_path,line_number);\n        }\n      }\nLAB_00114599:\n      *current_pos = 0;\n      if (line_end < current_pos) {\n        hash_slot = (byte **)htab_find_slot(hash_table,line_end,1);\n        *hash_slot = line_end;\n      }\n      line_number = line_number + 1;\n      line_end = next_byte;\n      current_byte = line_start[1];\n    }\n    *file_content = buffer;\n  }\n  return;\n}\n\n",
            "called": [
                "fclose",
                "ferror",
                "FUN_00119dd0",
                "__errno_location",
                "FUN_00113f50",
                "dcgettext",
                "xmalloc",
                "strerror",
                "fread",
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114460",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "load_and_parse_file_00114460"
        },
        "FUN_0010a94e": {
            "renaming": {
                "FUN_0010a94e": "build_request_0010a94e",
                "param_1": "requestStruct",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "cVar1": "itemFlag",
                "__s": "listItem",
                "sVar3": "len1",
                "sVar4": "len2",
                "sVar5": "len3",
                "sVar6": "len4",
                "pcVar7": "newStr",
                "uVar8": "result",
                "pcVar9": "flagStr",
                "lVar2": "ptr"
            },
            "code": "\nundefined8 buildRequest_0010a94e(long requestStruct,char *param2,char *param3,int param4)\n\n{\n  char itemFlag;\n  long ptr;\n  char *listItem;\n  size_t len1;\n  size_t len2;\n  size_t len3;\n  size_t len4;\n  char *newStr;\n  undefined8 result;\n  char *flagStr;\n  \n  itemFlag = *(char *)(*(long *)(requestStruct + 0x60) + 0x1c);\n  listItem = (char *)extract_list_item_00109b2f();\n  newStr = *(char **)(*(long *)(requestStruct + 0x60) + 0x20);\n  if (newStr == (char *)0x0) {\n    result = 0;\n  }\n  else {\n    len1 = strlen(newStr);\n    len2 = strlen(param2);\n    len3 = strlen(listItem);\n    len4 = strlen(param3);\n    newStr = (char *)xmalloc(len1 + 10 + len2 + len3 + len4);\n    if (param4 == 1) {\n      flagStr = \"/1\";\n    }\n    else {\n      flagStr = \"/0\";\n      if ((param4 != 2) && (flagStr = \"\", param4 != 0)) {\n                    \n        abort();\n      }\n    }\n    sprintf(newStr,\"%s%s:%s%s:%s;\",*(undefined8 *)(*(long *)(requestStruct + 0x60) + 0x20),param2,flagStr,\n            listItem,param3,*(long *)(requestStruct + 0x60));\n    free(*(void **)(*(long *)(requestStruct + 0x60) + 0x20));\n    ptr = *(long *)(requestStruct + 0x60);\n    *(char **)(ptr + 0x20) = newStr;\n    if (itemFlag != '\\0') {\n      *(undefined *)(ptr + 0x1c) = 1;\n    }\n    result = CONCAT71((int7)((ulong)ptr >> 8),1);\n  }\n  return result;\n}\n\n",
            "called": [
                "abort",
                "strlen",
                "free",
                "xmalloc",
                "sprintf",
                "FUN_00109b2f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a94e",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "build_request_0010a94e"
        },
        "bfd_set_file_flags": {
            "renaming": {},
            "code": "\nvoid bfd_set_file_flags(void)\n\n{\n  bfd_set_file_flags();\n  return;\n}\n\n",
            "called": [
                "bfd_set_file_flags"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104630",
            "calling": [
                "FUN_00107976"
            ],
            "imported": false,
            "current_name": "bfd_set_file_flags"
        },
        "bfd_create_gnu_debuglink_section": {
            "renaming": {},
            "code": "\nvoid bfd_create_gnu_debuglink_section(void)\n\n{\n  bfd_create_gnu_debuglink_section();\n  return;\n}\n\n",
            "called": [
                "bfd_create_gnu_debuglink_section"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104180",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "bfd_create_gnu_debuglink_section"
        },
        "FUN_00113b1e": {
            "renaming": {
                "FUN_00113b1e": "extract_data_from_binary_00113b1e",
                "param_1": "binaryAddress",
                "param_3": "binaryDataOffset",
                "auVar1": "result1",
                "piVar2": "debugInfoPtr",
                "uVar3": "result2",
                "auVar4": "result3"
            },
            "code": "\nundefined  [16] extractDataFromBinary_00113b1e(long binaryAddress,undefined8 param_2,ulong binaryDataOffset,undefined8 param_4)\n\n{\n  undefined result1 [16];\n  int *debugInfoPtr;\n  undefined8 result2;\n  undefined result3 [16];\n  \n  if (binaryAddress != 0) {\n    debugInfoPtr = (int *)check_debug_information_00112b6e(binaryAddress,0);\n    if ((debugInfoPtr == (int *)0x0) || (3 < *debugInfoPtr - 7U)) {\n      result2 = 0;\n    }\n    else {\n      result2 = **(undefined8 **)(debugInfoPtr + 4);\n    }\n    result3._8_8_ = param_4;\n    result3._0_8_ = result2;\n    return result3;\n  }\n  result1._8_8_ = 0;\n  result1._0_8_ = binaryDataOffset;\n  return result1 << 0x40;\n}\n\n",
            "called": [
                "FUN_00112b6e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113b1e",
            "calling": [
                "FUN_0010d559",
                "FUN_0010b0fa"
            ],
            "imported": false,
            "current_name": "extract_data_from_binary_00113b1e"
        },
        "FUN_0010a0e9": {
            "renaming": {
                "FUN_0010a0e9": "generate_data_0010a0e9",
                "param_1": "data_address",
                "param_2": "value_1",
                "param_3": "value_2",
                "uVar1": "data_byte",
                "uVar2": "result",
                "__s": "extracted_string",
                "sVar3": "string_length",
                "__s_00": "allocated_string"
            },
            "code": "\nundefined4 generate_data_0010a0e9(long data_address,undefined8 value_1,undefined8 value_2)\n\n{\n  undefined data_byte;\n  undefined4 result;\n  char *extracted_string;\n  size_t string_length;\n  char *allocated_string;\n  \n  data_byte = *(undefined *)(*(long *)(data_address + 0x60) + 0x1c);\n  result = *(undefined4 *)(*(long *)(data_address + 0x60) + 0x18);\n  extracted_string = (char *)extract_list_item_00109b2f();\n  string_length = strlen(extracted_string);\n  allocated_string = (char *)xmalloc(string_length + 100);\n  sprintf(allocated_string,\"r%s;%ld;%ld;\",extracted_string,value_1,value_2);\n  free(extracted_string);\n  result = allocate_and_initialize_data_00109b52(data_address,allocated_string,0,data_byte,result);\n  if ((char)result != '\\0') {\n    free(allocated_string);\n  }\n  return result;\n}\n\n",
            "called": [
                "strlen",
                "free",
                "xmalloc",
                "sprintf",
                "FUN_00109b2f",
                "FUN_00109b52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a0e9",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "generate_data_0010a0e9"
        },
        "FUN_00114c20": {
            "renaming": {
                "FUN_00114c20": "initialize_and_parse_rules_00114c20",
                "param_1": "dataAddress",
                "cVar1": "comparisonResult",
                "pcVar2": "stringPointer"
            },
            "code": "\nvoid initializeAndParseRules_00114c20(long dataAddress)\n\n{\n  char comparisonResult;\n  char *stringPointer;\n  \n  parse_rules_00114190(dataAddress,1,1);\n  comparisonResult = compare_strings_00113fb0(dataAddress,&DAT_0011b499);\n  if (comparisonResult != '\\0') {\n    stringPointer = (char *)(dataAddress + 5);\n    if (*(char *)(dataAddress + 4) != 'a') {\n      stringPointer = (char *)(dataAddress + 4);\n    }\n    if (*stringPointer != '\\0') {\n      parse_rules_00114190(stringPointer,1,0x100);\n    }\n  }\n  DAT_001278b8 = 1;\n  return;\n}\n\n",
            "called": [
                "FUN_00113fb0",
                "FUN_00114190"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114c20",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "initialize_and_parse_rules_00114c20"
        },
        "FUN_00115f50": {
            "renaming": {
                "FUN_00115f50": "check_section_data_00115f50",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "__s1": "str",
                "uVar1": "result",
                "uVar2": "extra",
                "extraout_EDX": "extra2",
                "plVar3": "ptr",
                "auVar4": "comparisonResult"
            },
            "code": "\nuint checkSectionData_00115f50(long arg1,char **arg2,char arg3)\n\n{\n  char *str;\n  uint result;\n  undefined4 extra;\n  undefined4 extra2;\n  long *ptr;\n  undefined comparisonResult [12];\n  \n  if ((DAT_00127a20 != 0) || (DAT_001278ec != '\\0')) {\n    return 1;\n  }\n  comparisonResult = process_section_data_001159d0(arg2);\n  if (comparisonResult[0] == '\\0') {\n    if (DAT_001279b8 != (long *)0x0) {\n      str = *arg2;\n      ptr = DAT_001279b8;\n      do {\n        result = strcmp(str,(char *)ptr[1]);\n        comparisonResult._4_4_ = 0;\n        comparisonResult._0_4_ = result;\n        comparisonResult._8_4_ = extra2;\n        if (result == 0) {\n          return 1;\n        }\n        ptr = (long *)*ptr;\n      } while (ptr != (long *)0x0);\n    }\n    extra = comparisonResult._8_4_;\n    if (((((arg3 == '\\0') || (DAT_00127a00 == '\\0')) ||\n         (comparisonResult._8_4_ = extra, comparisonResult._0_8_ = *(long *)(arg1 + 8),\n         *(int *)(*(long *)(arg1 + 8) + 8) != 5)) ||\n        ((comparisonResult._0_8_ = (ulong)arg2[0x1a], *(int *)(arg2[0x1a] + 4) != 7 ||\n         (comparisonResult = compare_strings_00113fb0(*arg2,\".gnu.build.attributes\"), comparisonResult[0] == '\\0')))) &&\n       ((*(byte *)((long)arg2 + 0x27) & 2) == 0)) {\n      return (uint)CONCAT71(comparisonResult._1_7_,arg2[8] == (char *)0x0) |\n             CONCAT31(comparisonResult._9_3_,arg2[0xc] == (char *)0x0);\n    }\n  }\n  return 1;\n}\n\n",
            "called": [
                "FUN_00113fb0",
                "strcmp",
                "FUN_001159d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115f50",
            "calling": [
                "FUN_00116110",
                "FUN_00115dc0"
            ],
            "imported": false,
            "current_name": "check_section_data_00115f50"
        },
        "FUN_001083de": {
            "renaming": {
                "FUN_001083de": "print_error_and_exit_001083de",
                "unaff_RBX": "section",
                "unaff_EBP": "length",
                "uVar1": "section_length",
                "uVar2": "error_message"
            },
            "code": "\nvoid print_error_and_exit_001083de(void)\n\n{\n  undefined8 section_length;\n  undefined8 error_message;\n  undefined8 *section;\n  undefined4 length;\n  \n  section_length = *section;\n  error_message = dcgettext(0,\"cannot reverse bytes: length of section %s must be evenly divisible by %d\",5)\n  ;\n                    \n  print_error_and_exit_001083de_00119dd0(error_message,section_length,length);\n}\n\n",
            "called": [
                "FUN_00119dd0",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001083de",
            "calling": [
                "FUN_00116110"
            ],
            "imported": false,
            "current_name": "print_error_and_exit_001083de"
        },
        "bfd_get_section_by_name": {
            "renaming": {},
            "code": "\nvoid bfd_get_section_by_name(void)\n\n{\n  bfd_get_section_by_name();\n  return;\n}\n\n",
            "called": [
                "bfd_get_section_by_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104400",
            "calling": [
                "FUN_0010554f",
                "FUN_00107880",
                "FUN_0011a2e0"
            ],
            "imported": false,
            "current_name": "bfd_get_section_by_name"
        },
        "FUN_0010b948": {
            "renaming": {
                "FUN_0010b948": "initialize_or_extract_data_0010b948",
                "param_1": "binaryAddress",
                "param_2": "count",
                "lVar1": "temporaryVar",
                "cVar2": "conditionalResult",
                "__ptr": "extractedItem",
                "uVar3": "countAsUnsigned",
                "uVar4": "decrementedCount",
                "local_5a": "formattedString"
            },
            "code": "\nvoid initializeOrExtractData_0010b948(long binaryAddress,uint count)\n\n{\n  long temporaryVar;\n  char conditionalResult;\n  void *extractedItem;\n  ulong countAsUnsigned;\n  uint decrementedCount;\n  char formattedString [50];\n  \n  decrementedCount = count - 1;\n  countAsUnsigned = (ulong)count;\n  if ((decrementedCount < 0x10) && (temporaryVar = *(long *)(binaryAddress + 0xf8 + (ulong)decrementedCount * 8), temporaryVar != 0)) {\n    initialize_data_00109cf4(binaryAddress,temporaryVar,countAsUnsigned);\n    return;\n  }\n  conditionalResult = process_stab_int_type_0010b800(binaryAddress,4,0);\n  if (conditionalResult != '\\0') {\n    extractedItem = (void *)extract_list_item_00109b2f(binaryAddress);\n    temporaryVar = *(long *)(binaryAddress + 0x68);\n    *(long *)(binaryAddress + 0x68) = temporaryVar + 1;\n    if (decrementedCount < 0x10) {\n      *(long *)(binaryAddress + 0xf8 + (ulong)decrementedCount * 8) = temporaryVar;\n    }\n    sprintf(formattedString,\"%ld=r%s;%u;0;\",temporaryVar,extractedItem,countAsUnsigned);\n    free(extractedItem);\n    allocate_and_initialize_data_00109b52(binaryAddress,formattedString,temporaryVar,1,countAsUnsigned);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00109cf4",
                "free",
                "sprintf",
                "FUN_00109b2f",
                "FUN_0010b800",
                "FUN_00109b52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010b948",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "initialize_or_extract_data_0010b948"
        },
        "access": {
            "renaming": {},
            "code": "\n\n\nint access(char *__name,int __type)\n\n{\n  int iVar1;\n  \n  iVar1 = access(__name,__type);\n  return iVar1;\n}\n\n",
            "called": [
                "access"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104740",
            "calling": [
                "FUN_0011283f"
            ],
            "imported": false,
            "current_name": "access"
        },
        "dcgettext": {
            "renaming": {},
            "code": "\nvoid dcgettext(void)\n\n{\n  dcgettext();\n  return;\n}\n\n",
            "called": [
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104240",
            "calling": [
                "FUN_00104966",
                "FUN_00116490",
                "FUN_0010bf86",
                "FUN_00108fe8",
                "FUN_0010e07c",
                "FUN_0010ba08",
                "FUN_0010827b",
                "FUN_00104cc1",
                "FUN_0010bf20",
                "FUN_00108b3e",
                "FUN_00108072",
                "FUN_00114e50",
                "FUN_00104a35",
                "FUN_00107976",
                "FUN_001053b5",
                "FUN_00108d9a",
                "FUN_001126c0",
                "FUN_00114190",
                "FUN_001083de",
                "FUN_00115530",
                "FUN_00114460",
                "FUN_00114dc7",
                "FUN_00108fb9",
                "FUN_00115dc0",
                "FUN_00109022",
                "FUN_00108a2a",
                "FUN_0010911f",
                "FUN_001163d0",
                "FUN_00116b90",
                "FUN_0011256b",
                "FUN_0010c218",
                "FUN_0010ee3f",
                "FUN_00112c1f",
                "FUN_00112b6e",
                "FUN_0010bd62",
                "FUN_0010c892",
                "FUN_00114690",
                "FUN_00115b70",
                "FUN_0010e2f0",
                "FUN_00119970",
                "FUN_0010554f",
                "FUN_0010c2d2",
                "FUN_0010882c",
                "FUN_00104ad6",
                "FUN_00113f50",
                "FUN_0010be88",
                "FUN_0010543c",
                "FUN_001152b6",
                "FUN_00114e00",
                "FUN_00112996",
                "FUN_0010dac0",
                "FUN_00108916",
                "FUN_00108808",
                "FUN_0011173a",
                "FUN_0010871c",
                "FUN_001086af",
                "FUN_00109a32",
                "FUN_001199d0",
                "FUN_0010c05d",
                "FUN_0010808f",
                "FUN_0010da0b",
                "FUN_00108200",
                "FUN_0010551d",
                "FUN_00108f08",
                "FUN_0010914e",
                "FUN_0010be1a",
                "FUN_0010e6a8",
                "FUN_00119f70",
                "FUN_00104ea2",
                "FUN_0010b6ea",
                "FUN_00108375",
                "FUN_00108179",
                "FUN_0010c6be",
                "FUN_0010b0fa",
                "FUN_0010bc80",
                "FUN_00105828",
                "FUN_0010b800",
                "FUN_00107880",
                "FUN_00104920"
            ],
            "imported": false,
            "current_name": "dcgettext"
        },
        "bfd_set_format": {
            "renaming": {},
            "code": "\nvoid bfd_set_format(void)\n\n{\n  bfd_set_format();\n  return;\n}\n\n",
            "called": [
                "bfd_set_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104500",
            "calling": [
                "FUN_00114e50",
                "FUN_00114690",
                "FUN_00119f70",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "bfd_set_format"
        },
        "FUN_00112b6e": {
            "renaming": {
                "FUN_00112b6e": "check_debug_information_00112b6e",
                "param_1": "inputArray",
                "param_2": "debugInformation",
                "iVar1": "value",
                "__format": "formatString",
                "piVar3": "resultArray",
                "plVar4": "currentPointer",
                "bVar5": "isCircular",
                "local_18": "debugInfoList",
                "local_10": "currentArray"
            },
            "code": "\n\n\nint * checkDebugInformation_00112b6e(int *inputArray,long *debugInformation)\n\n{\n  int value;\n  undefined8 uVar2;\n  char *formatString;\n  int *resultArray;\n  long *currentPointer;\n  bool isCircular;\n  long *debugInfoList;\n  int *currentArray;\n  \n  value = *inputArray;\n  if ((value != 1) && (1 < value - 0x16U)) {\n    return inputArray;\n  }\n  currentPointer = debugInformation;\n  while (currentPointer != (long *)0x0) {\n    if ((inputArray == (int *)currentPointer[1]) ||\n       (isCircular = currentPointer == (long *)*currentPointer, currentPointer = (long *)*currentPointer, isCircular)) {\n      uVar2 = extract_data_from_binary_001129f4(inputArray,\"debug_get_real_type: circular debug information for %s\\n\");\n      formatString = (char *)dcgettext(0);\n      fprintf(_stderr,formatString,uVar2);\n      return (int *)0x0;\n    }\n  }\n  debugInfoList = debugInformation;\n  currentArray = inputArray;\n  if (value - 0x16U < 2) {\n    resultArray = (int *)checkDebugInformation_00112b6e((*(undefined8 **)(inputArray + 4))[1],&debugInfoList);\n    return resultArray;\n  }\n  resultArray = *(int **)**(undefined8 **)(inputArray + 4);\n  if (inputArray == resultArray) {\n    return inputArray;\n  }\n  if (resultArray == (int *)0x0) {\n    return inputArray;\n  }\n  resultArray = (int *)checkDebugInformation_00112b6e(resultArray,&debugInfoList);\n  return resultArray;\n}\n\n",
            "called": [
                "fprintf",
                "FUN_001129f4",
                "FUN_00112b6e",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112b6e",
            "calling": [
                "FUN_0010922b",
                "FUN_00113b1e",
                "FUN_0010ee3f",
                "FUN_00112c1f",
                "FUN_00112b6e"
            ],
            "imported": false,
            "current_name": "check_debug_information_00112b6e"
        },
        "FUN_0010a83e": {
            "renaming": {
                "FUN_0010a83e": "format_data_and_allocate_0010a83e",
                "param_1": "inputData",
                "param_2": "param2",
                "param_3": "parameter3",
                "param_4": "parameter4",
                "param_5": "parameter5",
                "param_6": "flag1",
                "param_7": "flag2",
                "uVar1": "result",
                "__s": "string1",
                "__s_00": "string2",
                "sVar2": "stringLength",
                "cVar3": "flag3"
            },
            "code": "\nundefined4\nformatDataAndAllocate_0010a83e(long inputData,undefined8 param2,ulong parameter3,undefined parameter4,ulong parameter5,\n            byte flag1,byte flag2)\n\n{\n  undefined4 result;\n  char *string1;\n  char *string2;\n  size_t stringLength;\n  char flag3;\n  \n  if (((flag2 ^ 1) & flag1) == 0) {\n    string1 = (char *)0x0;\n    flag3 = '\\0';\n  }\n  else {\n    flag3 = *(char *)(*(long *)(inputData + 0x60) + 0x1c);\n    string1 = (char *)extract_list_item_00109b2f();\n    parameter5 = parameter5 & 0xffffffff;\n    parameter3 = parameter3 & 0xffffffff;\n  }\n  result = format_and_allocate_data_0010a69a(inputData,param2,parameter3,parameter4,parameter5);\n  if ((char)result != '\\0') {\n    if (flag1 == 0) {\n      return result;\n    }\n    if (flag2 == 0) {\n      if (string1 == (char *)0x0) {\n        return 0;\n      }\n      stringLength = strlen(string1);\n      string2 = (char *)xmalloc(stringLength + 3);\n      sprintf(string2,\"~%%%s\",string1);\n      free(string1);\n      if (flag3 != '\\0') {\n        *(undefined *)(*(long *)(inputData + 0x60) + 0x1c) = 1;\n      }\n    }\n    else {\n      if (*(long *)(*(long *)(inputData + 0x60) + 0x10) < 1) {\n        return 0;\n      }\n      string2 = (char *)xmalloc(0x14);\n      sprintf(string2,\"~%%%ld\",*(undefined8 *)(*(long *)(inputData + 0x60) + 0x10));\n    }\n    *(char **)(*(long *)(inputData + 0x60) + 0x38) = string2;\n    return result;\n  }\n  return result;\n}\n\n",
            "called": [
                "strlen",
                "free",
                "xmalloc",
                "FUN_0010a69a",
                "sprintf",
                "FUN_00109b2f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a83e",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "format_data_and_allocate_0010a83e"
        },
        "FUN_00113d6e": {
            "renaming": {
                "FUN_00113d6e": "initialize_data_with_pointers_00113d6e",
                "param_1": "input_value_1",
                "param_2": "input_value_2",
                "lVar1": "data_initializer",
                "puVar2": "pointer",
                "xmalloc": "allocate_memory"
            },
            "code": "\nlong initialize_data_with_pointers_00113d6e(undefined8 input_value_1,undefined8 input_value_2)\n\n{\n  long data_initializer;\n  undefined8 *pointer;\n  \n  data_initializer = initialize_data_00112904(0xb,0);\n  if (data_initializer != 0) {\n    pointer = (undefined8 *)xmalloc(0x10);\n    *pointer = input_value_1;\n    pointer[1] = input_value_2;\n    *(undefined8 **)(data_initializer + 0x10) = pointer;\n  }\n  return data_initializer;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113d6e",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "initialize_data_with_pointers_00113d6e"
        },
        "bfd_make_section_with_flags": {
            "renaming": {},
            "code": "\nvoid bfd_make_section_with_flags(void)\n\n{\n  bfd_make_section_with_flags();\n  return;\n}\n\n",
            "called": [
                "bfd_make_section_with_flags"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104120",
            "calling": [
                "FUN_0010554f",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "bfd_make_section_with_flags"
        },
        "free": {
            "renaming": {},
            "code": "\n\n\nvoid free(void *__ptr)\n\n{\n  free(__ptr);\n  return;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048f0",
            "calling": [
                "FUN_0010c95e",
                "FUN_0010e07c",
                "FUN_0010ba08",
                "FUN_0010a77a",
                "FUN_00116852",
                "FUN_0010e453",
                "FUN_0010b948",
                "FUN_0010a2b9",
                "FUN_00104a35",
                "FUN_0010c1c6",
                "FUN_00109b2f",
                "FUN_0010e918",
                "FUN_0010a181",
                "FUN_0010e9a0",
                "FUN_00108466",
                "FUN_001163d0",
                "FUN_0010d559",
                "FUN_00116b90",
                "FUN_0010a377",
                "FUN_0011256b",
                "FUN_0010eafe",
                "FUN_001081e9",
                "FUN_0010ee3f",
                "FUN_00114690",
                "FUN_001125fa",
                "FUN_001088ae",
                "FUN_00109ed3",
                "FUN_0010554f",
                "FUN_0010e5db",
                "FUN_0010e842",
                "FUN_0010a0e9",
                "FUN_0010ae0e",
                "FUN_0010ebb0",
                "FUN_0010abdd",
                "FUN_0010dac0",
                "FUN_0011173a",
                "FUN_0010e7c2",
                "FUN_0010afd5",
                "FUN_001199d0",
                "FUN_0010aa53",
                "FUN_0010e8a9",
                "FUN_00114b84",
                "FUN_0010a94e",
                "FUN_0010551d",
                "FUN_0010a83e",
                "FUN_00116110",
                "FUN_0010d21c",
                "FUN_00108863",
                "FUN_0010e6a8",
                "FUN_0010a424",
                "FUN_00116030",
                "FUN_00104ea2",
                "FUN_0010b6ea",
                "FUN_0010b0fa",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "free"
        },
        "FUN_00114d50": {
            "renaming": {
                "FUN_00114d50": "execute_conditional_function_00114d50",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "condition"
            },
            "code": "\nvoid executeConditionalFunction_00114d50(long input_1,long input_2,uint condition)\n\n{\n  if (*(int *)(*(long *)(input_1 + 8) + 8) != 2) {\n    return;\n  }\n  if ((condition == 2) && (*(int *)(*(long *)(input_2 + 8) + 8) == 2)) {\n    condition = (uint)*(byte *)(*(long *)(*(long *)(input_2 + 8) + 0x380) + 0x71);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00105422. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (**(code **)(*(long *)(*(long *)(input_1 + 8) + 0x380) + 0x78))(input_1,condition != 0);\n  return;\n}\n\n",
            "called": [
                "FUN_0010540e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114d50",
            "calling": [
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "execute_conditional_function_00114d50"
        },
        "fopen": {
            "renaming": {},
            "code": "\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 = fopen(__filename,__modes);\n  return pFVar1;\n}\n\n",
            "called": [
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104750",
            "calling": [
                "FUN_00116b90",
                "FUN_00114d60",
                "FUN_00114460",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "fopen"
        },
        "stat": {
            "renaming": {},
            "code": "\n\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = stat(__file,__buf);\n  return iVar1;\n}\n\n",
            "called": [
                "stat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001044f0",
            "calling": [
                "FUN_00104ea2",
                "FUN_00116b90",
                "FUN_00113f50",
                "FUN_0011283f"
            ],
            "imported": false,
            "current_name": "stat"
        },
        "FUN_00108916": {
            "renaming": {
                "FUN_00108916": "print_usage_00108916",
                "param_1": "file",
                "param_2": "exitCode",
                "uVar1": "defaultMessage",
                "pcVar2": "message"
            },
            "code": "\nvoid printUsage_00108916(FILE *file,int exitCode)\n\n{\n  undefined8 defaultMessage;\n  char *message;\n  \n  defaultMessage = DAT_001275e0;\n  message = (char *)dcgettext(0,\"Usage: %s [option(s)] in-file [out-file]\\n\",5);\n  fprintf(file,message,defaultMessage);\n  message = (char *)dcgettext(0,\" Copies a binary file, possibly transforming it in the process\\n\",5)\n  ;\n  fprintf(file,message);\n  message = (char *)dcgettext(0,\" The options are:\\n\",5);\n  fprintf(file,message);\n  message = (char *)dcgettext(0,\n                             \"  -I --input-target <bfdname>      Assume input file is in format <bfdname>\\n  -O --output-target <bfdname>     Create an output file in format <bfdname>\\n  -B --binary-architecture <arch>  Set output arch, when input is arch-less\\n  -F --target <bfdname>            Set both input and output format to <bfdname>\\n     --debugging                   Convert debugging information, if possible\\n  -p --preserve-dates              Copy modified/access timestamps to the output\\n\"\n                             ,5);\n  fprintf(file,message);\n  message = (char *)dcgettext(0,\n                             \"  -D --enable-deterministic-archives\\n                                   Produce deterministic output when stripping archives (default)\\n  -U --disable-deterministic-archives\\n                                   Disable -D behavior\\n\"\n                             ,5);\n  fprintf(file,message);\n  message = (char *)dcgettext(0,\n                             \"  -j --only-section <name>         Only copy section <name> into the output\\n     --add-gnu-debuglink=<file>    Add section .gnu_debuglink linking to <file>\\n  -R --remove-section <name>       Remove section <name> from the output\\n     --remove-relocations <name>   Remove relocations from section <name>\\n  -S --strip-all                   Remove all symbol and relocation information\\n  -g --strip-debug                 Remove all debugging symbols & sections\\n     --strip-dwo                   Remove all DWO sections\\n     --strip-unneeded              Remove all symbols not needed by relocations\\n  -N --strip-symbol <name>         Do not copy symbol <name>\\n     --strip-unneeded-symbol <name>\\n                                   Do not copy symbol <name> unless needed by\\n                                     relocations\\n     --only-keep-debug             Strip everything but the debug information\\n     --extract-dwo                 Copy only DWO sections\\n     --extract-symbol              Remove section contents but keep symbols\\n     --keep-section <name>         Do not strip section <name>\\n  -K --keep-symbol <name>          Do not strip symbol <name>\\n     --keep-section-symbols        Do not strip section symbols\\n     --keep-file-symbols           Do not strip file symbol(s)\\n     --localize-hidden             Turn all ELF hidden symbols into locals\\n  -L --localize-symbol <name>      Force symbol <name> to be marked as a local\\n     --globalize-symbol <name>     Force symbol <name> to be marked as a global\\n  -G --keep-global-symbol <name>   Localize all symbols except <name>\\n  -W --weaken-symbol <name>        Force symbol <name> to be marked as a weak\\n     --weaken                      Force all global symbols to be marked as weak\\n  -w --wildcard                    Permit wildcard in symbol comparison\\n  -x --discard-all                 Remove all non-global symbols\\n  -X --discard-locals              Remove any compiler-generated symbols\\n  -i --interleave[=<number>]       Only copy N out of every <number> bytes\\n     --interlea...\" /* TRUNCATED STRING LITERAL */\n                             ,5);\n  fprintf(file,message);\n  print_supported_targets_00104a35(DAT_001275e0,file);\n  if (exitCode == 0) {\n    message = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(file,message,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  exit(exitCode);\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext",
                "FUN_00104a35",
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108916",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "print_usage_00108916"
        },
        "FUN_001126c0": {
            "renaming": {
                "FUN_001126c0": "display_error_001126c0",
                "param_1": "errorCode",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6",
                "param_7": "param7",
                "param_8": "param8",
                "param_9": "errorMsgPtr",
                "param_10": "errorCodeFlag",
                "param_11": "errorStatus",
                "param_12": "formatStr",
                "param_13": "reservedParam1",
                "param_14": "reservedParam2",
                "in_AL": "ignoreFlag",
                "iVar1": "errorType",
                "uVar2": "errorMessage",
                "local_100": "byteCount",
                "local_fc": "hexCount",
                "local_f8": "stackPtr",
                "local_f0": "localBuffer",
                "local_e8": "tempBuffer",
                "local_c8": "tempParam1",
                "local_c0": "tempParam2",
                "local_b8": "tempParam3",
                "local_a8": "tempParam4",
                "local_98": "tempParam5",
                "local_88": "tempParam6",
                "local_78": "tempParam7",
                "local_68": "tempParam8",
                "local_58": "tempParam9",
                "local_48": "tempParam10"
            },
            "code": "\n\n\nvoid displayError_001126c0(undefined4 errorCode,undefined4 param2,undefined4 param3,undefined4 param4,\n                 undefined4 param5,undefined4 param6,undefined4 param7,undefined4 param8,\n                 long errorMsgPtr,long errorCodeFlag,long *errorStatus,char *formatStr,undefined8 reservedParam1,\n                 undefined8 reservedParam2)\n\n{\n  char ignoreFlag;\n  int errorType;\n  undefined8 errorMessage;\n  undefined4 byteCount;\n  undefined4 hexCount;\n  undefined *stackPtr;\n  undefined *localBuffer;\n  undefined tempBuffer [32];\n  undefined8 tempParam1;\n  undefined8 tempParam2;\n  undefined4 tempParam3;\n  undefined4 tempParam4;\n  undefined4 tempParam5;\n  undefined4 tempParam6;\n  undefined4 tempParam7;\n  undefined4 tempParam8;\n  undefined4 tempParam9;\n  undefined4 tempParam10;\n  \n  if (ignoreFlag != '\\0') {\n    tempParam3 = errorCode;\n    tempParam4 = param2;\n    tempParam5 = param3;\n    tempParam6 = param4;\n    tempParam7 = param5;\n    tempParam8 = param6;\n    tempParam9 = param7;\n    tempParam10 = param8;\n  }\n  tempParam1 = reservedParam1;\n  tempParam2 = reservedParam2;\n  errorType = bfd_get_error();\n  if (errorType == 0) {\n    errorMessage = dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    errorMessage = bfd_errmsg();\n  }\n  fflush(_stdout);\n  fputs(DAT_001275e0,_stderr);\n  if (errorCodeFlag != 0) {\n    if (errorMsgPtr == 0) {\n      errorMsgPtr = get_formatted_string_001125fa(errorCodeFlag);\n    }\n    if ((errorStatus != (long *)0x0) && (*errorStatus != 0)) {\n      fprintf(_stderr,\": %s[%s]\",errorMsgPtr);\n      goto LAB_001127c1;\n    }\n  }\n  fprintf(_stderr,\": %s\",errorMsgPtr);\nLAB_001127c1:\n  if (formatStr != (char *)0x0) {\n    stackPtr = &stack0x00000008;\n    localBuffer = tempBuffer;\n    byteCount = 0x20;\n    hexCount = 0x30;\n    fwrite(&DAT_0011b4a0,1,2,_stderr);\n    vfprintf(_stderr,formatStr,&byteCount);\n  }\n  fprintf(_stderr,\": %s\\n\",errorMessage);\n  return;\n}\n\n",
            "called": [
                "fputs",
                "bfd_errmsg",
                "fprintf",
                "fflush",
                "dcgettext",
                "fwrite",
                "bfd_get_error",
                "vfprintf",
                "FUN_001125fa"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001126c0",
            "calling": [
                "FUN_0010554f",
                "FUN_00104d25",
                "FUN_0010551d",
                "FUN_00116110",
                "FUN_00115dc0",
                "FUN_00108466",
                "FUN_00104ea2",
                "FUN_00116b90",
                "FUN_001086af",
                "FUN_00114e50",
                "FUN_00114690",
                "FUN_0010808f",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "display_error_001126c0"
        },
        "xstrdup": {
            "renaming": {},
            "code": "\nvoid xstrdup(void)\n\n{\n  xstrdup();\n  return;\n}\n\n",
            "called": [
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043d0",
            "calling": [
                "FUN_0011173a",
                "FUN_0010554f",
                "FUN_00104ea2",
                "FUN_00116b90",
                "FUN_001088ae",
                "FUN_00109b52"
            ],
            "imported": false,
            "current_name": "xstrdup"
        },
        "FUN_00113b4a": {
            "renaming": {
                "FUN_00113b4a": "initialize_data_00113b4a",
                "param_1": "input_param",
                "lVar1": "data_ptr"
            },
            "code": "\nlong initialize_data_00113b4a(long input_param)\n\n{\n  long data_ptr;\n  \n  if (input_param != 0) {\n    data_ptr = initialize_data_00113b4a_00112904(0x15,0);\n    if (data_ptr == 0) {\n      data_ptr = 0;\n    }\n    else {\n      *(long *)(data_ptr + 0x10) = input_param;\n    }\n    return data_ptr;\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113b4a",
            "calling": [
                "FUN_0010c95e",
                "FUN_0010ee3f",
                "FUN_0010b0fa"
            ],
            "imported": false,
            "current_name": "initialize_data_00113b4a"
        },
        "FUN_0010edb4": {
            "renaming": {
                "FUN_0010edb4": "process_file_0010edb4",
                "param_1": "fileStruct",
                "param_2": "filename",
                "param_3": "flag",
                "param_4": "fileSize",
                "cVar1": "result",
                "iVar2": "cmpResult",
                "uVar3": "returnValue",
                "in_R10": "additionalParam"
            },
            "code": "\nundefined8 processFile_0010edb4(long fileStruct,undefined8 filename,undefined4 flag,ulong fileSize)\n\n{\n  char result;\n  int cmpResult;\n  undefined8 returnValue;\n  undefined8 additionalParam;\n  \n  if (*(long *)(fileStruct + 0x210) == 0) {\n    return 0;\n  }\n  if (*(ulong *)(fileStruct + 0x1f0) < fileSize) {\n    *(ulong *)(fileStruct + 0x1f0) = fileSize;\n  }\n  cmpResult = filename_cmp(filename);\n  if (cmpResult != 0) {\n    result = process_string_0010e2f0(fileStruct,0x84,0,fileSize,filename);\n    if (result == '\\0') {\n      return 0;\n    }\n    *(undefined8 *)(fileStruct + 0x210) = filename;\n  }\n  returnValue = process_string_0010e2f0(fileStruct,0x44,flag,fileSize - *(long *)(fileStruct + 0x200),0,additionalParam);\n  return returnValue;\n}\n\n",
            "called": [
                "filename_cmp",
                "FUN_0010e2f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010edb4",
            "calling": [
                "FUN_00112502"
            ],
            "imported": false,
            "current_name": "process_file_0010edb4"
        },
        "fprintf": {
            "renaming": {},
            "code": "\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = fprintf(__stream,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001044b0",
            "calling": [
                "FUN_0010554f",
                "FUN_0010c2d2",
                "FUN_0010be88",
                "FUN_0010bf86",
                "FUN_00108fe8",
                "FUN_00112996",
                "FUN_00108916",
                "FUN_0011173a",
                "FUN_0010bf20",
                "FUN_0010871c",
                "FUN_00108b3e",
                "FUN_00104a35",
                "FUN_001126c0",
                "FUN_001199d0",
                "FUN_0010c05d",
                "FUN_00108f08",
                "FUN_0010914e",
                "FUN_0010be1a",
                "FUN_00108fb9",
                "FUN_00109022",
                "FUN_00108a2a",
                "FUN_0010911f",
                "FUN_00116b90",
                "FUN_0010b6ea",
                "FUN_0011256b",
                "FUN_00119e70",
                "FUN_0010c218",
                "FUN_0010ee3f",
                "FUN_00112c1f",
                "FUN_0010c6be",
                "FUN_00112b6e",
                "FUN_0010b0fa",
                "FUN_0010bd62",
                "FUN_0010c892",
                "FUN_0010bc80"
            ],
            "imported": false,
            "current_name": "fprintf"
        },
        "FUN_0010e5db": {
            "renaming": {
                "FUN_0010e5db": "extract_data_from_list_0010e5db",
                "param_1": "list_pointer",
                "param_2": "iteration_limit",
                "cVar1": "result",
                "__ptr": "extracted_item",
                "__s": "extracted_string",
                "sVar2": "string_length",
                "__s_00": "new_string",
                "in_R10": "unused_variable",
                "iVar3": "iteration_count",
                "auVar4": "processed_data"
            },
            "code": "\nundefined  [16] extract_data_from_list_0010e5db(long list_pointer,int iteration_limit)\n\n{\n  char result;\n  void *extracted_item;\n  char *extracted_string;\n  size_t string_length;\n  char *new_string;\n  ulong unused_variable;\n  int iteration_count;\n  undefined processed_data [16];\n  \n  iteration_count = 0;\n  do {\n    if (iteration_limit <= iteration_count) {\n      processed_data = process_data_00109ed3(list_pointer,0x66,0,list_pointer + 0x188,list_pointer + 400,unused_variable);\n      return processed_data;\n    }\n    if (*(char *)(*(long *)(list_pointer + 0x60) + 0x1c) == '\\0') {\n      extracted_item = (void *)extract_list_item_00109b2f(list_pointer);\n      free(extracted_item);\n    }\n    else {\n      extracted_string = (char *)extract_list_item_00109b2f(list_pointer);\n      string_length = strlen(extracted_string);\n      new_string = (char *)xmalloc(string_length + 3);\n      sprintf(new_string,\":t%s\",extracted_string);\n      free(extracted_string);\n      result = process_string_0010e2f0(list_pointer,0x80,0,0,new_string);\n      if (result == '\\0') {\n        processed_data._8_8_ = 0;\n        processed_data._0_8_ = unused_variable;\n        return processed_data << 0x40;\n      }\n      free(new_string);\n    }\n    iteration_count = iteration_count + 1;\n  } while( true );\n}\n\n",
            "called": [
                "strlen",
                "free",
                "xmalloc",
                "sprintf",
                "FUN_00109b2f",
                "FUN_00109ed3",
                "FUN_0010e2f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e5db",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "extract_data_from_list_0010e5db"
        },
        "FUN_00104d25": {
            "renaming": {
                "FUN_00104d25": "initialize_program_00104d25",
                "param_7": "inputParameter",
                "display_error_001126c0": "displayErrorMessage",
                "remove_and_free_directory_00114b84": "removeAndFreeDirectory"
            },
            "code": "\nvoid initializeProgram_00104d25(void)\n\n{\n  undefined8 inputParameter;\n  \n  DAT_00127a20 = 1;\n  displayErrorMessage(0,inputParameter,0,0);\n  removeAndFreeDirectory();\n  return;\n}\n\n",
            "called": [
                "FUN_00114b84",
                "FUN_001126c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104d25",
            "calling": [
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "initialize_program_00104d25"
        },
        "FUN_0010551d": {
            "renaming": {
                "FUN_0010551d": "parse_binary_file_0010551d",
                "puVar1": "ptr",
                "bVar2": "byteVal",
                "puVar3": "ptr",
                "pcVar4": "codePtr",
                "puVar5": "ptr",
                "uVar6": "ulongVal1",
                "uVar7": "ulongVal2",
                "__s": "strPtr",
                "cVar8": "charVal",
                "cVar9": "charVal",
                "uVar10": "uintVal",
                "iVar11": "intVal",
                "uVar12": "uintVal",
                "uVar13": "uintVal",
                "iVar14": "intVal",
                "plVar15": "ptr",
                "uVar16": "ulongVal",
                "uVar17": "ulongVal",
                "sVar18": "sizeVal",
                "pcVar19": "strPtr",
                "pcVar28": "strPtr",
                "uVar20": "ulongVal",
                "lVar21": "longVal",
                "uVar22": "ulongVal",
                "uVar24": "ulongVal",
                "lVar25": "longVal",
                "lVar27": "longVal",
                "__s_00": "strPtr",
                "in_stack_00000150": "strPtr",
                "in_stack_00000018": "charVal",
                "in_stack_00000140": "strPtr",
                "in_stack_00000118": "ushortVal",
                "iVar31": "intVal",
                "_uStack0000000000000048": "intArrayPtr",
                "cStack0000000000000148": "charVal",
                "in_stack_000000e0": "ptr",
                "bStack0000000000000101": "byteVal",
                "bStack0000000000000100": "byteVal",
                "bVar38": "boolVal"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong parseBinaryFile_0010551d(void)\n\n{\n  uint *ptr;\n  byte byteVal;\n  undefined *ptr;\n  code *codePtr;\n  undefined8 *ptr;\n  ulong ulongVal1;\n  ulong ulongVal2;\n  char *strPtr;\n  char charVal;\n  char charVal;\n  uint uintVal;\n  int intVal;\n  uint uintVal;\n  undefined4 uintVal;\n  int intVal;\n  long *ptr;\n  undefined8 ulongVal;\n  undefined8 ulongVal;\n  size_t sizeVal;\n  char *strPtr;\n  void *__ptr;\n  void *__ptr_00;\n  ulong ulongVal;\n  long longVal;\n  ulong ulongVal;\n  int *piVar23;\n  ulong ulongVal;\n  long longVal;\n  FILE *strPtr;\n  size_t sVar26;\n  long longVal;\n  long *unaff_RBX;\n  char *strPtr;\n  undefined8 *puVar29;\n  ulong uVar30;\n  int intVal;\n  long unaff_RBP;\n  long *plVar32;\n  char *pcVar33;\n  undefined4 *ptr4;\n  char **ppcVar35;\n  long *unaff_R13;\n  void *pvVar36;\n  undefined8 *unaff_R14;\n  undefined **pptr7;\n  bool boolVal;\n  byte bVar39;\n  long in_stack_00000008;\n  ulong in_stack_00000010;\n  char charVal;\n  undefined4 *puStack0000000000000020;\n  char *pcStack0000000000000038;\n  uint uStack0000000000000048;\n  int iStack000000000000006c;\n  long lStack0000000000000078;\n  long lStack0000000000000088;\n  char *pcStack0000000000000090;\n  long lStack00000000000000a0;\n  long *in_stack_000000c0;\n  ulong in_stack_000000c8;\n  long in_stack_000000d0;\n  long in_stack_000000d8;\n  void *ptr;\n  long in_stack_000000f0;\n  undefined8 in_stack_000000f8;\n  byte byteVal;\n  byte byteVal;\n  undefined8 in_stack_00000110;\n  ushort ushortVal;\n  char *strPtr;\n  char charVal;\n  char *strPtr;\n  undefined uStack0000000000000158;\n  short sStack000000000000015a;\n  \n  bVar39 = 0;\ncode_r0x0010551d:\n  dcgettext(0,\"warning: could not load note section\",5);\n  display_error_001126c0(0);\n  free(unaff_RBX);\nLAB_001151a2:\n  unaff_RBP = *(long *)(unaff_RBP + 8);\n  puVar29 = DAT_001279b0;\n  if (unaff_RBP == 0) goto joined_r0x001151c7;\n  if (DAT_00127a00 != '\\0') {\n    if ((((*(int *)(unaff_R14[1] + 8) != 5) || (*(int *)(*(long *)(unaff_RBP + 0xd0) + 4) != 7)) ||\n        (charVal = compare_strings_00113fb0(), charVal == '\\0')) ||\n       ((*(long *)(unaff_RBP + 0x60) == 0 || (longVal = *(long *)(unaff_RBP + 0x40), longVal == 0))))\n    goto LAB_001151a2;\n    unaff_RBX = (long *)xmalloc(0x20);\n    unaff_RBX[1] = 0;\n    charVal = bfd_get_full_section_contents();\n    if (charVal != '\\0') {\n      longVal = parse_gnu_build_attribute_notes_001163d0();\n      unaff_RBX[2] = longVal;\n      if ((longVal == longVal) || (charVal = bfd_set_section_size(), charVal != '\\0')) {\n        unaff_RBX[3] = (long)unaff_R13;\n        *unaff_RBX = unaff_RBP;\n        unaff_R13 = unaff_RBX;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        display_error_001126c0(0,in_stack_00000008,unaff_RBP);\n        free((void *)unaff_RBX[1]);\n        free(unaff_RBX);\n      }\n      goto LAB_001151a2;\n    }\n    goto code_r0x0010551d;\n  }\n  for (longVal = *(long *)(unaff_RBP + 8); longVal != 0; longVal = *(long *)(longVal + 8)) {\n  }\njoined_r0x001151c7:\n  for (; puVar29 != (undefined8 *)0x0; puVar29 = (undefined8 *)*puVar29) {\n    longVal = bfd_get_section_by_name();\n    if (longVal == 0) {\n      dcgettext(0,\"can\\'t dump section \\'%s\\' - it does not exist\",5);\n      display_error_001126c0(0);\n    }\n    else if ((*(byte *)(longVal + 0x25) & 1) == 0) {\n      dcgettext(0,\"can\\'t dump section - it has no contents\",5);\n      display_error_001126c0(0);\n    }\n    else {\n      sizeVal = *(size_t *)(longVal + 0x40);\n      strPtr = fopen((char *)puVar29[2],\"w\");\n      if (strPtr == (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        display_error_001126c0(puVar29[2],0,0);\n      }\n      else {\n        charVal = bfd_malloc_and_get_section();\n        if (charVal == '\\0') {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          display_error_001126c0(0);\n        }\n        else if ((sizeVal != 0) &&\n                (sVar26 = fwrite(strPtr,1,sizeVal,strPtr), sVar26 != sizeVal)) {\n          piVar23 = __errno_location();\n          pcVar33 = strerror(*piVar23);\n          ulongVal = puVar29[2];\n          ulongVal = dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          print_error_message_00119ed0(ulongVal,ulongVal,pcVar33);\n          free(strPtr);\n          fclose(strPtr);\n          return 0;\n        }\n        fclose(strPtr);\n        free(strPtr);\n      }\n    }\n  }\n  if (DAT_00127a10 == 0) {\nLAB_0010790a:\n    lStack0000000000000078 = 0;\n  }\n  else {\n    longVal = bfd_get_section_by_name(in_stack_00000008,\".gnu_debuglink\");\n    if (longVal != 0) {\n      ulongVal = dcgettext(0,\"%s: debuglink section already exists\",5);\n      print_error_message_00119ed0(ulongVal);\n      DAT_00127a10 = 0;\n      goto LAB_0010790a;\n    }\n    lStack0000000000000078 = bfd_create_gnu_debuglink_section(in_stack_00000008);\n    longVal = DAT_00127a10;\n    if (lStack0000000000000078 == 0) {\n      ulongVal = dcgettext(0,\"cannot create debug link section `%s\\'\",5);\n      display_error_001126c0(0,in_stack_00000008,0,ulongVal,longVal);\n      return 0;\n    }\n    if (*(int *)(*(long *)(in_stack_00000008 + 8) + 8) == 2) {\n      ulongVal = 0;\n      for (ulongVal = *(ulong *)(in_stack_00000008 + 0x90); ulongVal != 0;\n          ulongVal = *(ulong *)(ulongVal + 8)) {\n        ulongVal = *(ulong *)(ulongVal + 0x30);\n        uVar30 = ulongVal;\n        ulongVal1 = ulongVal;\n        ulongVal2 = ulongVal;\n        if (ulongVal != 0) {\n          while ((uVar30 = ulongVal1, ulongVal2 != 0 &&\n                 (uVar30 = ulongVal, ulongVal <= *(ulong *)(ulongVal + 0x30)))) {\n            ulongVal = *(ulong *)(ulongVal + 8);\n            if (ulongVal == 0) goto LAB_00107db8;\n            ulongVal = *(ulong *)(ulongVal + 0x30);\n            ulongVal1 = ulongVal;\n            ulongVal2 = ulongVal;\n          }\n        }\n        ulongVal = uVar30;\n      }\nLAB_00107db8:\n      if (ulongVal == 0) {\n        ulongVal = 0x1000;\n      }\n      else {\n        ulongVal = *(long *)(ulongVal + 0x40) + *(long *)(ulongVal + 0x30);\n        ulongVal = 0xffffffffffffffff;\n        if (ulongVal < 0xfffffffffffff001) {\n          ulongVal = ulongVal + 0xfff & 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(lStack0000000000000078 + 0x28) = *(byte *)(lStack0000000000000078 + 0x28) | 1;\n      *(ulong *)(lStack0000000000000078 + 0x30) = ulongVal;\n      *(ulong *)(lStack0000000000000078 + 0x38) = ulongVal;\n    }\n  }\n  plVar32 = DAT_001278b0;\n  iStack000000000000006c = *(int *)(in_stack_00000008 + 0xa0);\n  if (iStack000000000000006c != 0) {\n    ulongVal = process_debug_info_0010554f();\n    return ulongVal;\n  }\n  if (DAT_00127980 == '\\0') {\nLAB_00105588:\n    puStack0000000000000020 = (undefined4 *)0x0;\n  }\n  else {\n    pptr7 = &PTR_sstrPtrtab_00125c60;\n    puStack0000000000000020 = (undefined4 *)xmalloc(0x60);\n    ptr4 = puStack0000000000000020;\n    for (longVal = 0x18; longVal != 0; longVal = longVal + -1) {\n      *ptr4 = 0;\n      ptr4 = ptr4 + (ulong)bVar39 * -2 + 1;\n    }\n    pcStack0000000000000038 = (char *)0x0;\n    do {\n      ptr = *pptr7;\n      longVal = bfd_get_section_by_name();\n      longVal = bfd_get_section_by_name();\n      if ((longVal != 0) && (longVal != 0)) {\n        longVal = *(long *)(longVal + 0x40);\n        __ptr = (void *)xmalloc(longVal);\n        charVal = bfd_get_section_contents();\n        if (charVal == '\\0') {\n          uintVal = bfd_get_error();\n          bfd_errmsg(uintVal);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n          free(pcStack0000000000000038);\n          free(__ptr);\n        }\n        else {\n          ulongVal = *(ulong *)(longVal + 0x40);\n          __ptr_00 = (void *)xmalloc(ulongVal + 1);\n          charVal = bfd_get_section_contents();\n          if (charVal == '\\0') {\n            uintVal = bfd_get_error();\n            bfd_errmsg(uintVal);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n            free(pcStack0000000000000038);\n          }\n          else {\n            *(undefined *)((long)__ptr_00 + ulongVal) = 0;\n            if ((pcStack0000000000000038 != (char *)0x0) ||\n               (pcStack0000000000000038 = (char *)initialize_data_structure_00112894(),\n               pcStack0000000000000038 != (char *)0x0)) {\n              lStack00000000000000a0 = 0;\n              lStack0000000000000088 = 0;\n              for (pvVar36 = __ptr; pvVar36 <= (void *)((long)__ptr + longVal + -0xc);\n                  pvVar36 = (void *)((long)pvVar36 + 0xc)) {\n                ulongVal = (**(code **)(unaff_R14[1] + 0x40))(pvVar36);\n                byteVal = *(byte *)((long)pvVar36 + 4);\n                uintVal = (**(code **)(unaff_R14[1] + 0x58))((long)pvVar36 + 6);\n                longVal = (**(code **)(unaff_R14[1] + 0x40))((long)pvVar36 + 8);\n                if (byteVal == 0) {\n                  lStack0000000000000088 = lStack00000000000000a0;\n                  lStack00000000000000a0 = lStack00000000000000a0 + longVal;\n                }\n                else {\n                  ulongVal = (ulongVal & 0xffffffff) + lStack0000000000000088;\n                  if (ulongVal < ulongVal) {\n                    pcVar33 = (char *)((long)__ptr_00 + ulongVal);\n                    pcStack0000000000000090 = (char *)0x0;\n                    while( true ) {\n                      sizeVal = strlen(pcVar33);\n                      if (((sizeVal == 0) || (strPtr = pcVar33 + (sizeVal - 1), *strPtr != '\\')) ||\n                         ((ulong)((long)__ptr + longVal) < (long)pvVar36 + 0x10U)) goto LAB_001077fb;\n                      *strPtr = '\\0';\n                      pvVar36 = (void *)((long)pvVar36 + 0xc);\n                      intVal = (**(code **)(unaff_R14[1] + 0x40))(pvVar36);\n                      ulongVal = (ulong)(uint)(intVal + (int)lStack0000000000000088);\n                      if (ulongVal <= ulongVal) break;\n                      pcVar33 = (char *)concat(pcVar33,(long)__ptr_00 + ulongVal,0);\n                      *strPtr = '\\';\n                      free(pcStack0000000000000090);\n                      pcStack0000000000000090 = pcVar33;\n                    }\n                    ulongVal = *unaff_R14;\n                    strPtr = (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,strPtr,ulongVal,ptr,((long)pvVar36 - (long)__ptr) / 0xc);\nLAB_001077fb:\n                    update_data_entry_001088ae((ulong)byteVal,uintVal,longVal,pcVar33);\n                    charVal = process_debug_info_0011173a(puStack0000000000000020,pcStack0000000000000038,byteVal);\n                    if (charVal == '\\0') {\n                      print_stab_entries_00108b3e();\n                      free_memory_and_reset_00108863();\n                      free(pcStack0000000000000090);\n                      free(pcStack0000000000000038);\n                      free(__ptr);\n                      free(__ptr_00);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    ulongVal = *unaff_R14;\n                    pcVar33 = (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar33,ulongVal,ptr,((long)pvVar36 - (long)__ptr) / 0xc,\n                            ulongVal & 0xffffffff,(ulong)byteVal,((long)pvVar36 - (long)__ptr) % 0xc);\n                  }\n                }\n              }\n              free_memory_and_reset_00108863();\n              free(__ptr);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_00);\n          free(__ptr);\n        }\nLAB_00105981:\n        free(puStack0000000000000020);\n        goto LAB_00105588;\n      }\nLAB_001058eb:\n      pptr7 = pptr7 + 2;\n    } while (pptr7 != (undefined **)&DAT_00125c90);\n    if ((pcStack0000000000000038 != (char *)0x0) && (charVal = process_debug_info_0010c892(), charVal == '\\0'))\n    goto LAB_00105981;\n    if (*(int *)(unaff_R14[1] + 8) == 1) {\n      longVal = 0;\n      for (ptr = plVar32; ptr < plVar32 + in_stack_00000010; ptr = ptr + 1) {\n        (**(code **)(unaff_R14[1] + 0x218))();\n        if (charVal == '-') {\n          if (((longVal != 0) || (longVal = initialize_data_structure_00112894(), longVal != 0)) &&\n             ((strPtr != (char *)0x0 && (*strPtr != '\\0')))) {\n            pcVar33 = (char *)0x0;\n            strPtr = strPtr;\n            while (((*strPtr != '\\0' && (sizeVal = strlen(strPtr), strPtr[sizeVal - 1] == '\\')) &&\n                   (ptr + 1 < plVar32 + in_stack_00000010))) {\n              strPtr = (char *)xstrdup(strPtr);\n              sizeVal = strlen(strPtr);\n              strPtr[sizeVal - 1] = '\\0';\n              strPtr = (char *)concat(strPtr,*(undefined8 *)(ptr[1] + 8),0);\n              free(strPtr);\n              free(pcVar33);\n              ptr = ptr + 1;\n              pcVar33 = strPtr;\n            }\n            update_data_entry_001088ae(uStack0000000000000158,(int)sStack000000000000015a,strPtr,\n                         strPtr);\n            charVal = process_debug_info_0011173a(puStack0000000000000020,longVal,uStack0000000000000158);\n            if (charVal != '\\0') goto LAB_00106cac;\n            print_stab_entries_00108b3e();\n            free_memory_and_reset_00108863();\n          }\n          goto LAB_00105981;\n        }\nLAB_00106cac:\n      }\n      free_memory_and_reset_00108863();\n      if ((longVal != 0) && (charVal = process_debug_info_0010c892(), charVal == '\\0')) goto LAB_00105981;\n    }\n    if (charVal == '\\0') {\n      if ((*(int *)(unaff_R14[1] + 8) != 2) || (in_stack_00000010 == 0)) {\n        pcVar33 = \"%s: no recognized debugging information\";\n        goto LAB_00105968;\n      }\n      strPtr = (char *)0x0;\n      in_stack_000000c0 = plVar32;\n      in_stack_000000d0 = 0;\n      in_stack_000000c8 = in_stack_00000010;\n      in_stack_000000d8 = 0;\n      puVar29 = (undefined8 *)&stack0x00000148;\n      for (longVal = 0x22; longVal != 0; longVal = longVal + -1) {\n        *(undefined4 *)puVar29 = 0;\n        puVar29 = (undefined8 *)((long)puVar29 + (ulong)bVar39 * -8 + 4);\n      }\n      charVal = '\\0';\n      intArrayPtr = (int *)0x0;\n      pcStack0000000000000038 = (char *)0x0;\n      pcStack0000000000000090 = (char *)0xffffffffffffffff;\nswitchD_00106e1a_caseD_68:\n      do {\n        if ((long)in_stack_00000010 <= in_stack_000000d0) break;\n        longVal = plVar32[in_stack_000000d0];\n        charVal = bfd_coff_get_syment();\n        longVal = in_stack_000000d8;\n        if (charVal == '\\0') {\n          uintVal = bfd_get_error();\n          bfd_errmsg(uintVal);\n          pcVar33 = \"bfd_coff_get_syment failed: %s\";\nLAB_00105968:\n          ulongVal = dcgettext(0,pcVar33,5);\n          print_error_message_00119ed0(ulongVal);\n          goto LAB_00105981;\n        }\n        pcVar33 = *(char **)(longVal + 8);\n        in_stack_000000d0 = in_stack_000000d0 + 1;\n        in_stack_000000d8 = (ulong)byteVal + 1 + in_stack_000000d8;\n        if ((byteVal != 0) && (charVal = bfd_coff_get_auxent(), charVal == '\\0')) {\n          uintVal = bfd_get_error();\n          bfd_errmsg(uintVal);\n          pcVar33 = \"bfd_coff_get_auxent failed: %s\";\n          goto LAB_00105968;\n        }\n        if (pcStack0000000000000090 == (char *)longVal) {\n          if (byteVal != 0x67) {\n            charVal = initialize_debug_info_0010bbd3(puStack0000000000000020);\n            if (charVal == '\\0') goto LAB_00105981;\n            goto LAB_00106de4;\n          }\nswitchD_00106e1a_caseD_67:\n          pcStack0000000000000090 = (char *)in_stack_000000f0;\n          charVal = initialize_debug_info_0010bbd3(puStack0000000000000020);\n        }\n        else {\nLAB_00106de4:\n          if ((char)byteVal < '\\0') {\n            if (byteVal == 0xff) goto switchD_00106e1a_caseD_68;\n          }\n          else if (byteVal < 100) {\n            switch(byteVal) {\n            case 3:\n              if (in_stack_000000f8._6_2_ == 0) goto switchD_00106e1a_caseD_68;\n            case 2:\nswitchD_00106e1a_caseD_7f:\n              if ((ulong)((uint)in_stack_000000f8._6_2_ & *(uint *)(unaff_R14[0x22] + 0x40)) ==\n                  2L << ((byte)*(undefined4 *)(unaff_R14[0x22] + 0x3c) & 0x3f)) {\n                intArrayPtr = (int *)(**(code **)(unaff_R14[1] + 0x238))();\n                pcStack0000000000000038 = pcVar33;\n                goto switchD_00106e1a_caseD_68;\n              }\n              break;\n            default:\n              break;\n            case 5:\n            case 7:\n            case 0xe:\n              goto switchD_00106e1a_caseD_68;\n            }\n          }\n          else {\n            switch(byteVal) {\n            case 100:\n              intVal = strcmp(pcVar33,\".bb\");\n              if (intVal == 0) {\n                charVal = start_debug_block_0010be88(puStack0000000000000020);\n                goto joined_r0x00107247;\n              }\n              intVal = strcmp(pcVar33,\".eb\");\n              if (intVal == 0) {\n                charVal = debug_end_block_check_0010bf20(puStack0000000000000020);\n                goto joined_r0x00107247;\n              }\n              goto switchD_00106e1a_caseD_68;\n            case 0x65:\n              intVal = strcmp(pcVar33,\".bf\");\n              if (intVal == 0) {\n                if (pcStack0000000000000038 != (char *)0x0) {\n                  longVal = parse_and_initialize_data_0010dac0();\n                  if ((longVal == 0) ||\n                     (charVal = initialize_debug_record_0010bc80(puStack0000000000000020), charVal == '\\0'))\n                  goto LAB_00105981;\n                  if (intArrayPtr != (int *)0x0) {\n                    intVal = 0;\n                    if (byteVal != 0) {\n                      intVal = ushortVal - 1;\n                    }\n                    longVal = *(long *)(*(long *)(longVal + 0x20) + 0x30);\n                    while( true ) {\n                      intVal = intArrayPtr[4];\n                      if (intVal == 0) break;\n                      charVal = record_line_info_0010bf86(puStack0000000000000020,intVal + intVal,\n                                           *(long *)(intArrayPtr + 6) + longVal);\n                      intArrayPtr = intArrayPtr + 4;\n                      if (charVal == '\\0') goto LAB_00105981;\n                    }\n                  }\n                  intArrayPtr = (int *)0x0;\n                  pcStack0000000000000038 = (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar33 = \"%ld: .bf without preceding function\";\n              }\n              else {\n                intVal = strcmp(pcVar33,\".ef\");\n                if (intVal != 0) goto switchD_00106e1a_caseD_68;\n                if (charVal != '\\0') {\n                  charVal = end_debugging_function_0010be1a(puStack0000000000000020);\n                  if (charVal == '\\0') goto LAB_00105981;\n                  charVal = '\\0';\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar33 = \"%ld: unexpected .ef\\n\";\n              }\n              ulongVal = dcgettext(0,pcVar33,5);\n              print_error_message_00119ed0(ulongVal);\n              goto LAB_00105981;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n          longVal = parse_and_initialize_data_0010dac0();\n          if (longVal == 0) goto LAB_00105981;\n          charVal = process_parameter_00112a33(&stack0x00000140,longVal,longVal);\n        }\njoined_r0x00107247:\n        if (charVal == '\\0') goto LAB_00105981;\n      } while( true );\n    }\n  }\n  if (((*(uint *)(in_stack_00000008 + 0x44) & 0x42) != 0) &&\n     ((*(uint *)(in_stack_00000008 + 0x44) & 1) == 0)) {\n    if ((*(char *)(*(long *)(in_stack_00000008 + 8) + 0x20) == '\\0') && (DAT_00127939 == '\\0')) {\n      if (in_stack_00000010 != 0) {\n        plVar32 = DAT_001278b0 + in_stack_00000010;\n        ptr = DAT_001278b0;\n        do {\n          uintVal = *(uint *)(*ptr + 0x18);\n          if ((uintVal & 0x1000000) != 0) {\n            *(uint *)(*ptr + 0x18) = uintVal & 0xfeffffff;\n          }\n          ptr = ptr + 1;\n        } while (plVar32 != ptr);\n      }\n    }\n    else {\n      for (longVal = *(long *)(in_stack_00000008 + 0x90); longVal != 0; longVal = *(long *)(longVal + 8)\n          ) {\n        if (*(long *)(longVal + 0xe8) != 0) {\n          ptr = (uint *)(*(long *)(longVal + 0xe8) + 0x18);\n          *ptr = *ptr | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((DAT_00127a2c == 2) || (DAT_00127a2c == 7)) {\nLAB_001059fe:\n    if (DAT_00127a2c != 7) {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections();\n      intVal = bfd_get_error();\n      if (intVal != 0) {\n        DAT_00127a20 = 1;\n        return 0;\n      }\n    }\n    longVal = xmalloc();\n    plVar32 = DAT_001278b0;\n    uStack0000000000000048 = *(uint *)((long)unaff_R14 + 0x44) & 0x42;\n    DAT_001278a8 = longVal;\n    if (in_stack_00000010 == 0) {\n      ulongVal = 0;\n    }\n    else {\n      ulongVal = 0;\n      _charVal = 0;\n      do {\n        intVal = DAT_001279a0;\n        ptr = (long *)plVar32[_charVal];\n        codePtr = (code *)ptr[4];\n        uintVal = *(uint *)(ptr + 3);\n        pcVar33 = (char *)ptr[1];\n        strPtr = pcVar33;\n        if (DAT_001279a8 != (undefined8 *)0x0) {\n          intVal = 0;\n          puVar29 = DAT_001279a8;\n          while( true ) {\n            if ((intVal <= intVal) || (strPtr = (char *)puVar29[5], strPtr == (char *)0x0))\n            goto LAB_00105ad5;\n            if (strPtr != \"\") break;\nLAB_0010750b:\n            intVal = intVal + 1;\n          }\n          intVal = strcmp(strPtr,pcVar33);\n          if (intVal != 0) {\n            puVar29 = (undefined8 *)*puVar29;\n            goto LAB_0010750b;\n          }\n          free(strPtr);\n          ulongVal = ulongVal + 1;\n          puVar29[5] = \"\";\n          ulongVal = update_section_info_0011a2e0(puVar29);\n          ulongVal = DAT_001278d0;\n          *(undefined8 *)(longVal + ulongVal * 8) = ulongVal;\n          longVal = htab_elements(ulongVal);\n          if ((longVal != 0) || (DAT_001278d8 != (char **)0x0)) goto LAB_001064eb;\nLAB_00105af8:\n          charVal = *pcVar33;\n          if (charVal != '\\0') goto LAB_00105b11;\nLAB_00106557:\n          pcVar33 = DAT_00127908;\n          if ((DAT_00127988 != '\\0') && (*(char *)(*(long *)(in_stack_00000008 + 8) + 0x1c) != '\\0')\n             ) {\n            longVal = unaff_R14[1];\n            charVal = '\\0';\n            goto LAB_0010668d;\n          }\n          goto joined_r0x00106565;\n        }\nLAB_00105ad5:\n        longVal = htab_elements(DAT_001278d0);\n        ulongVal = ulongVal;\n        if ((longVal == 0) && (DAT_001278d8 == (char **)0x0)) goto LAB_00105af8;\n        if (pcVar33 != (char *)0x0) {\nLAB_001064eb:\n          if (((*pcVar33 == '_') && (pcVar33[1] == '_')) &&\n             (intVal = strcmp(pcVar33 + (pcVar33[2] == '_'),\"__gnu_lto_slim\"), intVal == 0)) {\n            ulongVal = dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\",5);\n                    \n            print_error_and_exit_00119dd0(ulongVal);\n          }\n        }\n        _charVal = 0;\n        strPtr = pcVar33;\n        longVal = htab_find(DAT_001278d0);\n        if (((longVal == 0) || (strPtr = *(char **)(longVal + 8), pcVar33 == strPtr)) &&\n           (strPtr = pcVar33, ppcVar35 = DAT_001278d8, (uintVal & 0x100) != 0)) {\n          for (; ppcVar35 != (char **)0x0; ppcVar35 = (char **)ppcVar35[3]) {\n            intVal = strcmp(*ppcVar35,pcVar33);\n            if (intVal == 0) {\n              strPtr = ppcVar35[1];\n              break;\n            }\n          }\n        }\n        ptr[1] = (long)strPtr;\n        charVal = *strPtr;\n        if (charVal == '\\0') goto LAB_00106557;\nLAB_00105b11:\n        pcVar33 = DAT_00127908;\n        longVal = unaff_R14[1];\n        if (*(char *)(longVal + 0x1c) == charVal) {\n          if (DAT_00127988 == '\\0') {\n            if ((DAT_00127968 == '\\0') ||\n               ((((uintVal & 0x82) == 0 && (codePtr != bfd_map_over_sections)) &&\n                ((*(byte *)(ptr[4] + 0x25) & 0x10) == 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n            strPtr = strPtr + 1;\n            ptr[1] = (long)strPtr;\n            goto joined_r0x00106565;\n          }\n          charVal = *(char *)(*(long *)(in_stack_00000008 + 8) + 0x1c);\n          if (charVal == '\\0') goto LAB_0010677d;\n          if (DAT_00127908 != (char *)0x0) {\n            strPtr = strPtr + 1;\n            ptr[1] = (long)strPtr;\n            sizeVal = strlen(strPtr);\n            longVal = sizeVal + 2;\n            goto LAB_001066bc;\n          }\n          *strPtr = charVal;\n          ptr[1] = (long)strPtr;\n          ulongVal = ulongVal;\n        }\n        else {\n          if ((DAT_00127988 == '\\0') || (*(char *)(*(long *)(in_stack_00000008 + 8) + 0x1c) == '\\0')\n             ) {\njoined_r0x00106565:\n            ulongVal = ulongVal;\n            if (pcVar33 == (char *)0x0) goto LAB_00105b32;\n            sizeVal = strlen(strPtr);\n            sVar26 = strlen(pcVar33);\n            pcVar33 = (char *)xmalloc(sVar26 + sizeVal + 1);\n            strPtr = pcVar33;\n          }\n          else {\nLAB_0010668d:\n            pcVar33 = DAT_00127908;\n            if ((*(char *)(longVal + 0x1c) != '\\0') && (charVal != *(char *)(longVal + 0x1c)))\n            goto joined_r0x00106565;\n            sizeVal = strlen(strPtr);\n            longVal = sizeVal + 2;\n            if (pcVar33 == (char *)0x0) {\n              strPtr = (char *)xmalloc(longVal);\n            }\n            else {\nLAB_001066bc:\n              sizeVal = strlen(pcVar33);\n              strPtr = (char *)xmalloc(sizeVal + longVal);\n            }\n            pcVar33 = strPtr + 1;\n            *strPtr = *(char *)(*(long *)(in_stack_00000008 + 8) + 0x1c);\n          }\n          strPtr = DAT_00127908;\n          if (DAT_00127908 != (char *)0x0) {\n            strcpy(pcVar33,DAT_00127908);\n            sizeVal = strlen(strPtr);\n            pcVar33 = pcVar33 + sizeVal;\n          }\n          strcpy(pcVar33,strPtr);\n          ptr[1] = (long)strPtr;\n          strPtr = strPtr;\n          ulongVal = ulongVal;\n        }\nLAB_00105b32:\n        if (DAT_00127a2c == 7) goto LAB_001067a8;\n        if (((uintVal & 0x20) == 0) &&\n           (((uintVal & 0x100) == 0 ||\n            ((*(byte *)(**(long **)(ptr[4] + 0xf0) + 0x18) & 0x20) == 0)))) {\n          if (((uStack0000000000000048 == 0) &&\n              (((uintVal & 0x82) != 0 || ((*(byte *)(ptr[4] + 0x25) & 0x10) != 0)))) ||\n             (intVal = bfd_decode_symclass(ptr), intVal == 0x49)) {\nLAB_00105be2:\n            if (DAT_001279ca == '\\0') {\n              longVal = htab_find();\n              if (longVal == 0) goto LAB_00105c07;\n            }\n            else {\n              _charVal = _charVal & 0xffffffffffffff00;\n              strPtr = strPtr;\n              htab_traverse(DAT_001279f8,pattern_match_0011a170,&stack0x00000140);\n              if (charVal == '\\0') goto LAB_00105c07;\n            }\n          }\n          else if ((((uintVal & 0x82) == 0) && (codePtr != bfd_map_over_sections)) &&\n                  ((*(byte *)(ptr[4] + 0x25) & 0x10) == 0)) {\n            if ((uintVal & 4) == 0) {\n              if (((*(int *)(unaff_R14[1] + 8) != 2) ||\n                  (longVal = *(long *)(ptr[4] + 0xd0), longVal == 0)) ||\n                 (*(long *)(longVal + 0x40) == 0)) {\n                if ((DAT_00127a2c == 3) || (DAT_00127a28 == 2)) goto LAB_001067a8;\n                if (DAT_00127a28 == 1) {\n                  charVal = bfd_is_local_label(unaff_R14);\n                  goto joined_r0x00106a11;\n                }\n              }\n              goto LAB_00105be2;\n            }\n            charVal = DAT_00127980;\n            if (1 < DAT_00127a2c - 2U) {\njoined_r0x00106a11:\n              if (charVal == '\\0') goto LAB_00105be2;\n            }\n          }\n          else if (DAT_00127a2c != 3) goto LAB_00105be2;\n          goto LAB_001067a8;\n        }\n        if (DAT_001279ca == '\\0') {\n          longVal = htab_find();\n          if (longVal != 0) {\nLAB_0010687f:\n            ulongVal = dcgettext(0,\"not stripping symbol `%s\\' because it is named in a relocation\",5)\n            ;\n            print_error_message_00119ed0(ulongVal);\n            DAT_00127a20 = 1;\n          }\n        }\n        else {\n          _charVal = _charVal & 0xffffffffffffff00;\n          strPtr = strPtr;\n          htab_traverse(DAT_001279f8,pattern_match_0011a170,&stack0x00000140);\n          if (charVal != '\\0') goto LAB_0010687f;\n        }\n        if ((uintVal & 0x20) == 0) {\nLAB_00105c07:\n          if (DAT_001279ca != '\\0') {\n            _charVal = _charVal & 0xffffffffffffff00;\n            strPtr = strPtr;\n            htab_traverse(DAT_001279f0,pattern_match_0011a170,&stack0x00000140);\n            if (charVal != '\\0') goto LAB_001067a8;\n            goto LAB_00105c2c;\n          }\n          longVal = htab_find();\n          if (longVal == 0) goto LAB_00105c2c;\nLAB_001067a8:\n          if ((DAT_00127a18 != '\\0') && ((uintVal & 0x4000) != 0)) goto LAB_00105c2c;\n          if (DAT_001279ca == '\\0') {\n            longVal = htab_find();\n            if (longVal != 0) goto LAB_00105c2c;\n          }\n          else {\n            _charVal = _charVal & 0xffffffffffffff00;\n            strPtr = strPtr;\n            htab_traverse(DAT_00127a08,pattern_match_0011a170,&stack0x00000140);\n            if (charVal != '\\0') goto LAB_00105c2c;\n          }\n        }\n        else {\nLAB_00105c2c:\n          charVal = process_section_data_001159d0(ptr[4]);\n          if (charVal == '\\0') {\n            if (((uintVal & 0x800002) == 0) && (codePtr != bfd_map_over_sections)) {\nLAB_00105c5f:\n              if ((uintVal & 0x82) != 0) {\n                charVal = find_value_00115d70(strPtr);\n                if ((charVal == '\\0') &&\n                   ((longVal = htab_elements(DAT_001279d8), longVal == 0 ||\n                    (charVal = find_value_00115d70(strPtr), charVal != '\\0')))) {\n                  if (((((DAT_00127938 == '\\0') ||\n                        (uintVal = *(uint *)(ptr + 3), (uintVal & 0x200000) != 0)) ||\n                       (longVal = *ptr, longVal == 0)) ||\n                      ((*(int *)(*(long *)(longVal + 8) + 8) != 5 || (*(long *)(longVal + 0x110) == 0)\n                       ))) || (1 < (*(byte *)((long)ptr + 0x49) & 3) - 1))\n                  goto joined_r0x00105ca2;\n                }\n                else {\n                  uintVal = *(uint *)(ptr + 3);\n                }\n                *(uint *)(ptr + 3) = uintVal & 0xffffff7d | 1;\n              }\njoined_r0x00105ca2:\n              if (((uintVal & 1) != 0) && (charVal = find_value_00115d70(strPtr), charVal != '\\0')) {\n                *(uint *)(ptr + 3) = *(uint *)(ptr + 3) & 0xfffffffe | 2;\n              }\n            }\n            else {\n              if ((DAT_001279c8 != '\\0') || (charVal = find_value_00115d70(strPtr), charVal != '\\0')) {\n                *(uint *)(ptr + 3) = *(uint *)(ptr + 3) & 0xff7ffffd | 0x80;\n              }\n              if (codePtr != bfd_map_over_sections) goto LAB_00105c5f;\n            }\n            *(long **)(longVal + ulongVal * 8) = ptr;\n            ulongVal = ulongVal + 1;\n          }\n        }\n        _charVal = _charVal + 1;\n      } while (in_stack_00000010 != _charVal);\n    }\n    if (DAT_001279a8 != (undefined8 *)0x0) {\n      puVar29 = DAT_001279a8;\n      intVal = DAT_001279a0;\n      for (longVal = 0; longVal < intVal; longVal = longVal + 1) {\n        pcVar33 = (char *)puVar29[5];\n        if (pcVar33 == (char *)0x0) {\n          longVal = ulongVal * 8;\n          ulongVal = ulongVal + 1;\n          ulongVal = update_section_info_0011a2e0(puVar29,in_stack_00000008);\n          *(undefined8 *)(longVal + longVal) = ulongVal;\n          intVal = DAT_001279a0;\n        }\n        else if (pcVar33 != \"\") {\n          ulongVal = dcgettext(0,\"\\'before=%s\\' not found\",5);\n                    \n          print_error_and_exit_00119dd0(ulongVal,pcVar33);\n        }\n        puVar29 = (undefined8 *)*puVar29;\n      }\n    }\n    boolVal = DAT_00127980 != '\\0';\n    *(undefined8 *)(longVal + ulongVal * 8) = 0;\n    if ((boolVal) && (puStack0000000000000020 != (undefined4 *)0x0)) {\n      intVal = *(int *)(*(undefined8 **)(in_stack_00000008 + 8) + 1);\n      if ((intVal != 5) && (intVal != 2)) {\n        ulongVal = **(undefined8 **)(in_stack_00000008 + 8);\n        ulongVal = dcgettext(0,\"don\\'t know how to write debugging information for %s\",5);\n        display_error_001126c0(0,in_stack_00000008,0,ulongVal,ulongVal);\nLAB_00105d8c:\n        free(puStack0000000000000020);\n        DAT_00127a20 = 1;\n        return 0;\n      }\n      ptr = (void *)0x0;\n      charVal = extract_binary_data_0011378f(in_stack_00000008,puStack0000000000000020,&stack0x000000c0,\n                           &stack0x00000110,&stack0x000000e0,&stack0x00000140);\n      if (charVal == '\\0') goto LAB_00105d8c;\n      longVal = bfd_make_section_with_flags(in_stack_00000008,\".stab\",0x2108);\n      longVal = bfd_make_section_with_flags(in_stack_00000008,\".stabstr\",0x2108);\n      if ((((longVal == 0) || (longVal == 0)) ||\n          (charVal = bfd_set_section_size(longVal,in_stack_00000110), charVal == '\\0')) ||\n         (charVal = bfd_set_section_size(longVal,strPtr), charVal == '\\0')) {\n        pcVar33 = \"can\\'t create debugging section\";\nLAB_00105eb4:\n        ulongVal = dcgettext(0,pcVar33,5);\n        display_error_001126c0(0,in_stack_00000008,0,ulongVal);\n        free(ptr);\n        free(puStack0000000000000020);\n        DAT_00127a20 = 1;\n        return 0;\n      }\n      *(undefined4 *)(longVal + 0x7c) = 2;\n      *(undefined4 *)(longVal + 0x7c) = 0;\n      charVal = bfd_set_section_contents\n                        (in_stack_00000008,longVal,in_stack_000000c0,0,in_stack_00000110);\n      if ((charVal == '\\0') ||\n         (charVal = bfd_set_section_contents\n                            (in_stack_00000008,longVal,ptr,0,strPtr),\n         charVal == '\\0')) {\n        pcVar33 = \"can\\'t set debugging section contents\";\n        goto LAB_00105eb4;\n      }\n      free(puStack0000000000000020);\n    }\n    in_stack_00000010 = ulongVal & 0xffffffff;\n  }\n  else {\n    if ((DAT_00127a2c - 3U < 4) || ((DAT_00127a28 != 0 || (DAT_00127938 != '\\0'))))\n    goto LAB_00105a07;\n    longVal = htab_elements(DAT_001279f8);\n    if (((longVal != 0) ||\n        (((((((longVal = htab_elements(DAT_00127a08), longVal != 0 ||\n              (longVal = htab_elements(DAT_001279e8), longVal != 0)) ||\n             (longVal = htab_elements(DAT_001279e0), longVal != 0)) ||\n            ((longVal = htab_elements(DAT_001279d8), longVal != 0 ||\n             (longVal = htab_elements(DAT_001279d0), longVal != 0)))) ||\n           (longVal = htab_elements(DAT_001278d0), longVal != 0)) ||\n          (((DAT_00127908 != (char *)0x0 || (DAT_001278b8 != '\\0')) ||\n           ((DAT_00127a19 != '\\0' ||\n            (((DAT_00127980 != '\\0' || (DAT_00127988 != '\\0')) || (DAT_00127968 != '\\0')))))))) ||\n         ((DAT_001278d8 != (char **)0x0 || (DAT_001279c8 != '\\0')))))) || (DAT_001279a0 != 0))\n    goto LAB_001059fe;\n  }\n  bfd_set_symtab(in_stack_00000008,DAT_001278a8,in_stack_00000010 & 0xffffffff);\n  bfd_map_over_sections(unaff_R14,process_section_data_00115dc0,in_stack_00000008);\n  bfd_map_over_sections(unaff_R14,reverse_section_contents_00116110,in_stack_00000008);\n  for (puVar29 = DAT_001279c0; ptr = DAT_001279b8, puVar29 != (undefined8 *)0x0;\n      puVar29 = (undefined8 *)*puVar29) {\n    charVal = bfd_set_section_contents(in_stack_00000008,puVar29[5],puVar29[4],0,puVar29[3]);\n    if (charVal == '\\0') {\n      display_error_001126c0(0,in_stack_00000008,puVar29[5],0);\n      return 0;\n    }\n  }\n  for (; ptr != (undefined8 *)0x0; ptr = (undefined8 *)*ptr) {\n    ulongVal = *(undefined8 *)(ptr[5] + 0x60);\n    charVal = bfd_set_section_contents(in_stack_00000008,ulongVal,ptr[4],0,ptr[3]);\n    if (charVal == '\\0') {\n      display_error_001126c0(0,in_stack_00000008,ulongVal,0);\n      return 0;\n    }\n  }\n  if (unaff_R13 == (long *)0x0) {\n    if ((DAT_00127a00 != '\\0') && (_DAT_00127a24 == 0)) {\n      ulongVal = *unaff_R14;\n      ulongVal = dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n      print_error_message_00119ed0(ulongVal,ulongVal);\n    }\nLAB_0010578f:\n    if ((DAT_00127a10 == 0) ||\n       (charVal = bfd_fill_in_gnu_debuglink_section(in_stack_00000008,lStack0000000000000078),\n       longVal = DAT_00127a10, charVal != '\\0')) {\n      uintVal = (**(code **)(*(long *)(in_stack_00000008 + 8) + 0x140))(unaff_R14);\n      ulongVal = (ulong)uintVal;\n      if ((char)uintVal != '\\0') {\n        if (DAT_00127910 == 0) {\n          return ulongVal;\n        }\n        charVal = bfd_alt_mach_code(in_stack_00000008,DAT_00127910 & 0xffffffff);\n        ulongVal = DAT_00127910;\n        if (charVal != '\\0') {\n          return ulongVal;\n        }\n        ulongVal = dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n        print_error_message_00119ed0(ulongVal,ulongVal);\n        if (*(int *)(*(long *)(in_stack_00000008 + 8) + 8) != 5) {\n          ulongVal = dcgettext(0,\"ignoring the alternative value\",5);\n          print_error_message_00119ed0(ulongVal);\n          return ulongVal;\n        }\n        ulongVal = dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n        print_error_message_00119ed0(ulongVal);\n        *(short *)(*(long *)(in_stack_00000008 + 0x110) + 0x3a) = (short)DAT_00127910;\n        return ulongVal;\n      }\n      ulongVal = dcgettext(0,\"error copying private BFD data\",5);\n      display_error_001126c0(0,in_stack_00000008,0,ulongVal);\n    }\n    else {\n      ulongVal = dcgettext(0,\"cannot fill debug link section `%s\\'\",5);\n      display_error_001126c0(0,in_stack_00000008,0,ulongVal,longVal);\n    }\n    return 0;\n  }\n  plVar32 = (long *)0x0;\n  puVar29 = *(undefined8 **)(in_stack_00000008 + 0x90);\n  do {\n    if (puVar29 == (undefined8 *)0x0) {\n      do {\n        plVar32 = (long *)unaff_R13[3];\n        free((void *)unaff_R13[1]);\n        free(unaff_R13);\n        unaff_R13 = plVar32;\n      } while (plVar32 != (long *)0x0);\n      goto LAB_0010578f;\n    }\n    if ((((DAT_00127a00 != '\\0') && (*(int *)(*(long *)(in_stack_00000008 + 8) + 8) == 5)) &&\n        (*(int *)(puVar29[0x1a] + 4) == 7)) &&\n       (charVal = compare_strings_00113fb0(*puVar29,\".gnu.build.attributes\"), charVal != '\\0')) {\n      if (plVar32 == (long *)0x0) {\n        plVar32 = unaff_R13;\n      }\n      ptr = unaff_R13;\n      if (*(undefined8 **)(*plVar32 + 0x60) == puVar29) {\nLAB_0010625f:\n        pcVar33 = \"error: failed to merge notes\";\n        if (plVar32[1] != 0) {\n          charVal = bfd_set_section_contents(in_stack_00000008,puVar29,plVar32[1],0,plVar32[2]);\n          if (charVal == '\\0') {\n            ulongVal = dcgettext(0,\"error: failed to copy merged notes into output\",5);\n            display_error_001126c0(0,in_stack_00000008,puVar29,ulongVal);\n            return 0;\n          }\n          plVar32 = (long *)plVar32[3];\n          goto LAB_001061be;\n        }\n      }\n      else {\n        do {\n          plVar32 = ptr;\n          if (*(undefined8 **)(*ptr + 0x60) == puVar29) goto LAB_0010625f;\n          plVar32 = (long *)ptr[3];\n          ptr = plVar32;\n        } while (plVar32 != (long *)0x0);\n        pcVar33 = \"error: failed to locate merged notes\";\n      }\n      ulongVal = dcgettext(0,pcVar33,5);\n      display_error_001126c0(0,in_stack_00000008,puVar29,ulongVal);\n    }\nLAB_001061be:\n    puVar29 = (undefined8 *)puVar29[1];\n  } while( true );\n}\n\n",
            "called": [
                "free",
                "dcgettext",
                "FUN_001126c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010551d",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "parse_binary_file_0010551d"
        },
        "bfd_printable_arch_mach": {
            "renaming": {},
            "code": "\nvoid bfd_printable_arch_mach(void)\n\n{\n  bfd_printable_arch_mach();\n  return;\n}\n\n",
            "called": [
                "bfd_printable_arch_mach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001045a0",
            "calling": [
                "FUN_00104943",
                "FUN_00105828",
                "FUN_001199d0",
                "FUN_00119f70"
            ],
            "imported": false,
            "current_name": "bfd_printable_arch_mach"
        },
        "FUN_00108800": {
            "renaming": {
                "FUN_00108800": "hash_string_00108800",
                "param_1": "string_ptr"
            },
            "code": "\nvoid hash_string_00108800(undefined8 *string_ptr)\n\n{\n  htab_hash_string_00108800(*string_ptr);\n  return;\n}\n\n",
            "called": [
                "htab_hash_string"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108800",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "hash_string_00108800"
        },
        "FUN_0010c1c6": {
            "renaming": {
                "FUN_0010c1c6": "clear_pointer_chain_0010c1c6",
                "param_1": "param",
                "param_2": "baseAddress",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6",
                "puVar1": "nextPointer",
                "cVar2": "charValue",
                "__ptr": "currentPointer"
            },
            "code": "\nundefined clearPointerChain_0010c1c6(undefined8 param,long baseAddress,undefined8 param3,undefined8 param4,\n                      undefined8 param5,undefined8 param6)\n\n{\n  undefined8 *nextPointer;\n  char charValue;\n  undefined8 *currentPointer;\n  \n  currentPointer = *(undefined8 **)(baseAddress + 0x78);\n  while( true ) {\n    if (currentPointer == (undefined8 *)0x0) {\n      *(undefined8 *)(baseAddress + 0x78) = 0;\n      return 1;\n    }\n    charValue = record_variable_data_0010c05d(param,currentPointer[1],currentPointer[2],*(undefined4 *)(currentPointer + 3),currentPointer[4],param6,\n                         param5);\n    if (charValue == '\\0') break;\n    nextPointer = (undefined8 *)*currentPointer;\n    free(currentPointer);\n    currentPointer = nextPointer;\n  }\n  return 0;\n}\n\n",
            "called": [
                "free",
                "FUN_0010c05d"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c1c6",
            "calling": [
                "FUN_0011173a",
                "FUN_0010c892"
            ],
            "imported": false,
            "current_name": "clear_pointer_chain_0010c1c6"
        },
        "FUN_001082df": {
            "renaming": {
                "FUN_001082df": "process_data_001082df",
                "unaff_RBX": "ptrData",
                "unaff_RBP": "ptrFunction",
                "unaff_R13": "ptrArray",
                "uVar1": "arraySize",
                "lVar2": "value",
                "cVar3": "foundValue",
                "puVar4": "newArray",
                "puVar5": "nextItem",
                "uVar6": "index"
            },
            "code": "\nvoid processData_001082df(void)\n\n{\n  uint arraySize;\n  long value;\n  char foundValue;\n  long ptrData;\n  undefined8 *newArray;\n  undefined8 *nextItem;\n  long ptrFunction;\n  ulong index;\n  undefined8 *ptrArray;\n  \n  arraySize = *(uint *)(ptrData + 0x78);\n  if (DAT_00127a2c == 7) {\n    newArray = ptrArray;\n    for (index = 0; index != arraySize; index = index + 1) {\n      nextItem = newArray;\n      if (((*(long **)ptrArray[index] != (long *)0x0) &&\n          (value = **(long **)ptrArray[index], value != 0)) &&\n         (foundValue = find_value_00115d70(*(undefined8 *)(value + 8),DAT_00127a08), foundValue != '\\0')) {\n        nextItem = newArray + 1;\n        *newArray = ptrArray[index];\n      }\n      newArray = nextItem;\n    }\n    *newArray = 0;\n  }\n                    /* WARNING: Could not recover jumptable at 0x00115eae. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (**(code **)(*(long *)(ptrFunction + 8) + 0x288))();\n  return;\n}\n\n",
            "called": [
                "FUN_00115d70"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001082df",
            "calling": [
                "FUN_00115dc0"
            ],
            "imported": false,
            "current_name": "process_data_001082df"
        },
        "open": {
            "renaming": {},
            "code": "\n\n\nint open(char *__file,int __oflag,...)\n\n{\n  int iVar1;\n  \n  iVar1 = open(__file,__oflag);\n  return iVar1;\n}\n\n",
            "called": [
                "open"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104730",
            "calling": [
                "FUN_00115a90"
            ],
            "imported": false,
            "current_name": "open"
        },
        "FUN_00114d60": {
            "renaming": {
                "FUN_00114d60": "read_and_allocate_file_00114d60",
                "param_1": "fileInfo",
                "iVar1": "eofStatus",
                "piVar2": "errnoLocation",
                "pcVar3": "errorMessage",
                "uVar4": "translatedErrorMessage",
                "__stream": "fileStream",
                "uVar5": "allocatedMemory",
                "sVar6": "bytesRead",
                "lVar7": "currentPosition",
                "lVar8": "bufferSize"
            },
            "code": "\nvoid readAndAllocateFile_00114d60(long fileInfo)\n\n{\n  int eofStatus;\n  int *errnoLocation;\n  char *errorMessage;\n  undefined8 translatedErrorMessage;\n  FILE *fileStream;\n  undefined8 allocatedMemory;\n  size_t bytesRead;\n  long currentPosition;\n  long bufferSize;\n  \n  fileStream = fopen(*(char **)(fileInfo + 0x10),\"r\");\n  if (fileStream == (FILE *)0x0) {\n    errnoLocation = __errno_location();\n    errorMessage = strerror(*errnoLocation);\n    allocatedMemory = *(undefined8 *)(fileInfo + 0x10);\n    translatedErrorMessage = dcgettext(0,\"cannot open: %s: %s\",5);\n                    \n    print_error_and_exit_00119dd0(translatedErrorMessage,allocatedMemory,errorMessage);\n  }\n  bufferSize = 0x1000;\n  currentPosition = 0;\n  allocatedMemory = xmalloc(0x1000);\n  *(undefined8 *)(fileInfo + 0x20) = allocatedMemory;\n  while( true ) {\n    eofStatus = feof(fileStream);\n    if (eofStatus != 0) {\n      *(long *)(fileInfo + 0x18) = currentPosition;\n      fclose(fileStream);\n      return;\n    }\n    if (currentPosition == bufferSize) {\n      bufferSize = currentPosition * 2;\n      allocatedMemory = xrealloc(*(undefined8 *)(fileInfo + 0x20),bufferSize);\n      *(undefined8 *)(fileInfo + 0x20) = allocatedMemory;\n    }\n    bytesRead = fread((void *)(*(long *)(fileInfo + 0x20) + currentPosition),1,bufferSize - currentPosition,fileStream);\n    eofStatus = ferror(fileStream);\n    if (eofStatus != 0) break;\n    currentPosition = currentPosition + bytesRead;\n  }\n  allocatedMemory = *(undefined8 *)(fileInfo + 0x10);\n  translatedErrorMessage = dcgettext(0,\"%s: fread failed\",5);\n                    \n  print_error_and_exit_00119dd0(translatedErrorMessage,allocatedMemory);\n}\n\n",
            "called": [
                "FUN_0010543c",
                "xmalloc",
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114d60",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "read_and_allocate_file_00114d60"
        },
        "FUN_00108808": {
            "renaming": {
                "FUN_00108808": "print_error_and_exit_section_not_found_00108808",
                "unaff_RBP": "base_pointer",
                "uVar1": "section_address",
                "uVar2": "error_message"
            },
            "code": "\nvoid print_error_and_exit_section_not_found_00108808(void)\n\n{\n  undefined8 section_address;\n  undefined8 error_message;\n  long base_pointer;\n  \n  section_address = *(undefined8 *)(base_pointer + 0x20);\n  error_message = dcgettext(0,\"Section %s not found\",5);\n                    \n  print_error_and_exit_00119dd0(error_message,section_address);\n}\n\n",
            "called": [
                "FUN_00119dd0",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108808",
            "calling": [
                "FUN_0011a2e0"
            ],
            "imported": false,
            "current_name": "print_error_and_exit_section_not_found_00108808"
        },
        "bfd_openr_next_archived_file": {
            "renaming": {},
            "code": "\nvoid bfd_openr_next_archived_file(void)\n\n{\n  bfd_openr_next_archived_file();\n  return;\n}\n\n",
            "called": [
                "bfd_openr_next_archived_file"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104820",
            "calling": [
                "FUN_00104ea2",
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "bfd_openr_next_archived_file"
        },
        "FUN_00104d1c": {
            "renaming": {
                "FUN_00104d1c": "parse_lines_00104d1c",
                "unaff_EBP": "current_line_number",
                "unaff_R13": "error_message",
                "in_stack_00000008": "filename",
                "in_stack_00000010": "result_pointer",
                "unaff_R14": "current_line",
                "unaff_R15": "current_position",
                "uVar1": "error_message_ptr",
                "ppbVar2": "hash_table_slot",
                "pbVar3": "rubbish_position",
                "bVar4": "current_char",
                "pbVar5": "next_line",
                "pbVar6": "position_pointer",
                "pbVar7": "line_end"
            },
            "code": "\nvoid parse_lines_00104d1c(void)\n\n{\n  undefined8 error_message_ptr;\n  byte **hash_table_slot;\n  byte *rubbish_position;\n  byte current_char;\n  byte *next_line;\n  int current_line_number;\n  byte *position_pointer;\n  undefined8 error_message;\n  byte *line_end;\n  byte *current_line;\n  byte *current_position;\n  undefined8 filename;\n  undefined8 *result_pointer;\n  \n  *current_line = 0;\nLAB_00114520:\n  current_line = current_line + 1;\n  do {\n    current_char = *current_line;\n    line_end = current_line;\n    if (current_char == 10) {\n      *current_line = 0;\n      if (current_line[1] == 0xd) {\n        line_end = current_line + 1;\n        next_line = current_line + 2;\n      }\n      else {\n        next_line = current_line + 1;\n      }\n    }\n    else if ((char)current_char < '\\v') {\n      if (current_char != 0) goto LAB_00114520;\n      next_line = current_line + 1;\n    }\n    else {\n      if (current_char != 0xd) break;\n      *current_line = 0;\n      next_line = current_line + 1;\n      if (current_line[1] == 10) {\n        next_line = current_line + 2;\n        line_end = current_line + 1;\n      }\n    }\n    current_char = *current_position;\n    while ((current_char == 0x20 || (position_pointer = current_position, current_char == 9))) {\n      position_pointer = current_position + 1;\n      current_position = current_position + 1;\n      current_char = *position_pointer;\n    }\n    do {\n      if ((current_char == 10) || (current_char == 0xd)) goto LAB_00114676;\n      if (current_char == 0) goto LAB_00114599;\n      current_char = position_pointer[1];\n      position_pointer = position_pointer + 1;\n    } while ((current_char != 0x20) && (current_char != 9));\n    if ((char)current_char < '\\x0e') {\nLAB_00114676:\n      if ((-0x2402L >> (current_char & 0x3f) & 1U) != 0) goto LAB_001145e6;\n    }\n    else {\nLAB_001145e6:\n      current_char = position_pointer[1];\n      if ((((((current_char == 9) || (current_char == 0x20)) &&\n            ((current_char = position_pointer[2], current_char == 9 || (current_char == 0x20)))) &&\n           ((current_char = position_pointer[3], current_char == 9 || (current_char == 0x20)))) &&\n          ((current_char = position_pointer[4], current_char == 9 || (current_char == 0x20)))) &&\n         ((current_char = position_pointer[5], current_char == 9 || (current_char == 0x20)))) {\n        current_char = position_pointer[6];\n        rubbish_position = position_pointer + 6;\n        if ((current_char == 9) || (current_char == 0x20)) {\n          do {\n            do {\n              current_char = rubbish_position[1];\n              rubbish_position = rubbish_position + 1;\n            } while (current_char == 0x20);\n          } while (current_char == 9);\n        }\n      }\n      if ((0xd < current_char) || ((-0x2402L >> (current_char & 0x3f) & 1U) != 0)) {\n        error_message_ptr = dcgettext(0,\"%s:%d: Ignoring rubbish found on this line\",5);\n        print_error_message_00119ed0(error_message_ptr,filename,current_line_number);\n      }\n    }\nLAB_00114599:\n    *position_pointer = 0;\n    if (current_position < position_pointer) {\n      hash_table_slot = (byte **)htab_find_slot();\n      *hash_table_slot = current_position;\n    }\n    current_line_number = current_line_number + 1;\n    current_line = next_line;\n    current_position = next_line;\n    if (line_end[1] == 0) {\n      *result_pointer = error_message;\n      return;\n    }\n  } while( true );\n  if (current_char == 0x23) {\n    parse_lines_00104d1c();\n    return;\n  }\n  goto LAB_00114520;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104d1c",
            "calling": [
                "FUN_00104cc1"
            ],
            "imported": false,
            "current_name": "parse_lines_00104d1c"
        },
        "FUN_00119940": {
            "renaming": {
                "FUN_00119940": "check_and_print_error_00119940",
                "param_1": "address",
                "param_2": "message",
                "uVar1": "error_message",
                "local_20": "scanned_address"
            },
            "code": "\nvoid check_and_print_error_00119940(undefined8 address,undefined8 message)\n\n{\n  undefined8 error_message;\n  char *scanned_address [2];\n  \n  bfd_scan_vma(address,scanned_address,0);\n  if (*scanned_address[0] == '\\0') {\n    return;\n  }\n  error_message = dcgettext(0,\"%s: bad number: %s\",5);\n                    \n  print_error_and_exit_00119dd0(error_message,message,address);\n}\n\n",
            "called": [
                "bfd_scan_vma",
                "FUN_00104920"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00119940",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "check_and_print_error_00119940"
        },
        "bfd_map_over_sections": {
            "renaming": {},
            "code": "\nvoid bfd_map_over_sections(void)\n\n{\n  bfd_map_over_sections();\n  return;\n}\n\n",
            "called": [
                "bfd_map_over_sections"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104850",
            "calling": [
                "FUN_0010554f",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "bfd_map_over_sections"
        },
        "FUN_0010540e": {
            "renaming": {
                "FUN_0010540e": "execute_code_0010540e",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "in_RAX": "rax"
            },
            "code": "\nvoid executeCode_0010540e(undefined8 param1,long param2,uint param3)\n\n{\n  long rax;\n  \n  if ((param3 == 2) && (*(int *)(*(long *)(param2 + 8) + 8) == 2)) {\n    param3 = (uint)*(byte *)(*(long *)(*(long *)(param2 + 8) + 0x380) + 0x71);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00105422. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (**(code **)(*(long *)(rax + 0x380) + 0x78))(param1,param3 != 0);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010540e",
            "calling": [
                "FUN_00114d50"
            ],
            "imported": false,
            "current_name": "execute_code_0010540e"
        },
        "bfd_stat": {
            "renaming": {},
            "code": "\nvoid bfd_stat(void)\n\n{\n  bfd_stat();\n  return;\n}\n\n",
            "called": [
                "bfd_stat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001041b0",
            "calling": [
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "bfd_stat"
        },
        "bfd_scan_vma": {
            "renaming": {},
            "code": "\nvoid bfd_scan_vma(void)\n\n{\n  bfd_scan_vma();\n  return;\n}\n\n",
            "called": [
                "bfd_scan_vma"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104070",
            "calling": [
                "FUN_00119940"
            ],
            "imported": false,
            "current_name": "bfd_scan_vma"
        },
        "FUN_00113a4d": {
            "renaming": {
                "FUN_00113a4d": "process_and_update_data_00113a4d",
                "param_1": "data_1",
                "param_2": "data_2",
                "param_3": "data_3",
                "param_4": "data_4",
                "param_5": "data_5",
                "cVar1": "file_processed",
                "uVar2": "result",
                "puVar3": "file_data",
                "auVar4": "file_processing_result"
            },
            "code": "\nundefined8\nprocess_and_update_data_00113a4d(undefined8 data_1,undefined8 data_2,long data_3,undefined8 data_4,\n            undefined8 data_5)\n\n{\n  char file_processed;\n  undefined8 result;\n  undefined8 *file_data;\n  undefined file_processing_result [16];\n  \n  file_processed = process_files_00112502(data_1,data_2,*(undefined8 *)(data_3 + 0x18));\n  if ((file_processed != '\\0') &&\n     (((*(long *)(data_3 + 0x28) == 0 && (*(long *)(data_3 + 8) != 0)) ||\n      (file_processed = process_data_0010ec73(data_2,*(undefined8 *)(data_3 + 0x18)), file_processed != '\\0')))) {\n    if (*(undefined8 **)(data_3 + 0x28) != (undefined8 *)0x0) {\n      for (file_data = (undefined8 *)**(undefined8 **)(data_3 + 0x28); file_data != (undefined8 *)0x0;\n          file_data = (undefined8 *)*file_data) {\n        file_processed = process_data_001135a5(data_1,data_2,file_data);\n        if (file_processed == '\\0') {\n          return 0;\n        }\n      }\n    }\n    for (file_data = *(undefined8 **)(data_3 + 0x10); file_data != (undefined8 *)0x0;\n        file_data = (undefined8 *)*file_data) {\n      file_processed = process_and_update_data_00113a4d(data_1,data_2,file_data);\n      if (file_processed == '\\0') {\n        return 0;\n      }\n    }\n    file_processing_result = process_files_00112502(data_1,data_2,*(undefined8 *)(data_3 + 0x20));\n    if (file_processing_result[0] != '\\0') {\n      if ((*(long *)(data_3 + 0x28) == 0) && (*(long *)(data_3 + 8) != 0)) {\n        return file_processing_result._0_8_;\n      }\n      result = update_parameter_0010ed2c(data_2,*(undefined8 *)(data_3 + 0x20),file_processing_result._8_8_,data_5);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_001135a5",
                "FUN_00113a4d",
                "FUN_0010ed2c",
                "FUN_00112502",
                "FUN_0010ec73"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113a4d",
            "calling": [
                "FUN_001135a5",
                "FUN_00113a4d"
            ],
            "imported": false,
            "current_name": "process_and_update_data_00113a4d"
        },
        "FUN_001081e9": {
            "renaming": {
                "FUN_001081e9": "dealloc_and_return_001081e9",
                "in_RAX": "return_value",
                "unaff_RBX": "memory_block"
            },
            "code": "\nundefined8 dealloc_and_return_001081e9(void)\n\n{\n  undefined8 return_value;\n  void *memory_block;\n  undefined8 param_7;\n  \n  param_7 = return_value;\n  free(memory_block);\n  return param_7;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001081e9",
            "calling": [
                "FUN_0011a0e0"
            ],
            "imported": false,
            "current_name": "dealloc_and_return_001081e9"
        },
        "bfd_init": {
            "renaming": {},
            "code": "\nvoid bfd_init(void)\n\n{\n  bfd_init();\n  return;\n}\n\n",
            "called": [
                "bfd_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104430",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "bfd_init"
        },
        "ferror": {
            "renaming": {},
            "code": "\n\n\nint ferror(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = ferror(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "ferror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104130",
            "calling": [
                "FUN_00116b90",
                "FUN_00114460",
                "FUN_00114dc7"
            ],
            "imported": false,
            "current_name": "ferror"
        },
        "bfd_seek": {
            "renaming": {},
            "code": "\nvoid bfd_seek(void)\n\n{\n  bfd_seek();\n  return;\n}\n\n",
            "called": [
                "bfd_seek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048e0",
            "calling": [
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "bfd_seek"
        },
        "abort": {
            "renaming": {},
            "code": "\n\n\nvoid abort(void)\n\n{\n                    \n  abort();\n}\n\n",
            "called": [
                "abort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001040a0",
            "calling": [
                "FUN_001135a5",
                "FUN_0010a94e",
                "FUN_0010922b",
                "FUN_00112c1f",
                "FUN_0010b0fa",
                "FUN_0010ebb0",
                "FUN_0010abdd",
                "FUN_0010ba08",
                "FUN_0010d21c",
                "FUN_0010e9a0",
                "FUN_001199d0",
                "FUN_0010aa53"
            ],
            "imported": false,
            "current_name": "abort"
        },
        "FUN_00113b71": {
            "renaming": {
                "FUN_00113b71": "initialize_data_00113b71",
                "param_1": "data",
                "lVar1": "data_ptr"
            },
            "code": "\nlong initialize_data_00113b71(long data)\n\n{\n  long data_ptr;\n  \n  if (data != 0) {\n    data_ptr = initialize_data_00113b71_00112904(0x14,0);\n    if (data_ptr == 0) {\n      data_ptr = 0;\n    }\n    else {\n      *(long *)(data_ptr + 0x10) = data;\n    }\n    return data_ptr;\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113b71",
            "calling": [
                "FUN_0010c95e",
                "FUN_0010ee3f",
                "FUN_0010b0fa"
            ],
            "imported": false,
            "current_name": "initialize_data_00113b71"
        },
        "FUN_00109dfe": {
            "renaming": {
                "FUN_00109dfe": "initialize_or_allocate_data_00109dfe",
                "param_1": "dataPointer",
                "local_40": "formattedString",
                "lVar1": "previousValue",
                "initialize_data_00109cf4": "initializeData",
                "sprintf": "formatAndAssign",
                "allocate_and_initialize_data_00109b52": "allocateAndInitializeData"
            },
            "code": "\nvoid initializeOrAllocateData_00109dfe(long dataPointer)\n\n{\n  long previousValue;\n  char formattedString [40];\n  \n  if (*(long *)(dataPointer + 0x70) != 0) {\n    initializeData(dataPointer,*(long *)(dataPointer + 0x70),0);\n    return;\n  }\n  previousValue = *(long *)(dataPointer + 0x68);\n  *(long *)(dataPointer + 0x68) = previousValue + 1;\n  *(long *)(dataPointer + 0x70) = previousValue;\n  sprintf(formattedString,\"%ld=%ld\",previousValue,previousValue);\n  allocateAndInitializeData(dataPointer,formattedString,previousValue,1,0);\n  return;\n}\n\n",
            "called": [
                "FUN_00109cf4",
                "sprintf",
                "FUN_00109b52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109dfe",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "initialize_or_allocate_data_00109dfe"
        },
        "FUN_00109bbb": {
            "renaming": {
                "FUN_00109bbb": "append_semicolon_if_not_null_00109bbb",
                "param_1": "ptr",
                "__s": "str",
                "sVar1": "stringLength"
            },
            "code": "\nbool appendSemicolonIfNotNull_00109bbb(long ptr)\n\n{\n  char *str;\n  size_t stringLength;\n  \n  if (*(long *)(ptr + 0x60) != 0) {\n    str = *(char **)(*(long *)(ptr + 0x60) + 0x30);\n    if (str != (char *)0x0) {\n      stringLength = strlen(str);\n      *(undefined2 *)(str + stringLength) = 0x3b;\n    }\n    return str != (char *)0x0;\n  }\n  return false;\n}\n\n",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109bbb",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "append_semicolon_if_not_null_00109bbb"
        },
        "cplus_demangle_mangled_name": {
            "renaming": {},
            "code": "\nvoid cplus_demangle_mangled_name(void)\n\n{\n  cplus_demangle_mangled_name();\n  return;\n}\n\n",
            "called": [
                "cplus_demangle_mangled_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104700",
            "calling": [
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "cplus_demangle_mangled_name"
        },
        "lseek": {
            "renaming": {},
            "code": "\n\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  __off_t _Var1;\n  \n  _Var1 = lseek(__fd,__offset,__whence);\n  return _Var1;\n}\n\n",
            "called": [
                "lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001042e0",
            "calling": [
                "FUN_00115a90"
            ],
            "imported": false,
            "current_name": "lseek"
        },
        "FUN_0010ae0e": {
            "renaming": {
                "FUN_0010ae0e": "process_binary_data_0010ae0e",
                "param_1": "binaryData",
                "lVar1": "ptrStruct",
                "lVar2": "ptrArray",
                "__ptr": "tempPointer",
                "pcVar3": "tempString",
                "sVar4": "strLen1",
                "sVar5": "strLen2",
                "pcVar6": "newString",
                "uVar7": "returnValue",
                "lVar8": "finalStringLength",
                "uVar9": "counter",
                "uVar10": "numStrings"
            },
            "code": "\nundefined8 processBinaryData_0010ae0e(long binaryData)\n\n{\n  long ptrStruct;\n  long ptrArray;\n  void *tempPointer;\n  char *tempString;\n  size_t strLen1;\n  size_t strLen2;\n  char *newString;\n  undefined8 returnValue;\n  long finalStringLength;\n  uint counter;\n  ulong numStrings;\n  \n  returnValue = 0;\n  ptrStruct = *(long *)(binaryData + 0x60);\n  if (((ptrStruct != 0) && (*(char **)(ptrStruct + 8) != (char *)0x0)) &&\n     (newString = *(char **)(ptrStruct + 0x20), newString != (char *)0x0)) {\n    strLen1 = strlen(*(char **)(ptrStruct + 8));\n    strLen2 = strlen(newString);\n    ptrArray = *(long *)(ptrStruct + 0x28);\n    if (ptrArray == 0) {\n      finalStringLength = strLen1 + strLen2 + 10;\n      numStrings = 0;\n    }\n    else {\n      finalStringLength = strLen1 + strLen2 + 0x1e;\n      numStrings = 0;\n      while( true ) {\n        newString = *(char **)(ptrArray + numStrings * 8);\n        if (newString == (char *)0x0) break;\n        strLen1 = strlen(newString);\n        numStrings = (ulong)((int)numStrings + 1);\n        finalStringLength = finalStringLength + strLen1;\n      }\n    }\n    if (*(char **)(ptrStruct + 0x30) != (char *)0x0) {\n      strLen1 = strlen(*(char **)(ptrStruct + 0x30));\n      finalStringLength = finalStringLength + strLen1;\n    }\n    if (*(char **)(ptrStruct + 0x38) != (char *)0x0) {\n      strLen1 = strlen(*(char **)(ptrStruct + 0x38));\n      finalStringLength = finalStringLength + strLen1;\n    }\n    newString = (char *)xmalloc(finalStringLength);\n    ptrStruct = *(long *)(binaryData + 0x60);\n    strcpy(newString,*(char **)(ptrStruct + 8));\n    if (*(long *)(ptrStruct + 0x28) != 0) {\n      counter = 0;\n      strLen1 = strlen(newString);\n      sprintf(newString + strLen1,\"!%u,\",numStrings);\n      while( true ) {\n        ptrStruct = *(long *)(binaryData + 0x60);\n        numStrings = (ulong)counter;\n        tempPointer = *(void **)(ptrStruct + 0x28);\n        tempString = *(char **)((long)tempPointer + numStrings * 8);\n        if (tempString == (char *)0x0) break;\n        counter = counter + 1;\n        strcat(newString,tempString);\n        free(*(void **)(*(long *)(ptrStruct + 0x28) + numStrings * 8));\n      }\n      free(tempPointer);\n      *(undefined8 *)(*(long *)(binaryData + 0x60) + 0x28) = 0;\n    }\n    ptrStruct = *(long *)(binaryData + 0x60);\n    strcat(newString,*(char **)(ptrStruct + 0x20));\n    free(*(void **)(ptrStruct + 0x20));\n    ptrStruct = *(long *)(binaryData + 0x60);\n    *(undefined8 *)(ptrStruct + 0x20) = 0;\n    if (*(char **)(ptrStruct + 0x30) != (char *)0x0) {\n      strcat(newString,*(char **)(ptrStruct + 0x30));\n      free(*(void **)(ptrStruct + 0x30));\n      *(undefined8 *)(*(long *)(binaryData + 0x60) + 0x30) = 0;\n    }\n    strLen1 = strlen(newString);\n    ptrStruct = *(long *)(binaryData + 0x60);\n    *(undefined2 *)(newString + strLen1) = 0x3b;\n    tempString = *(char **)(ptrStruct + 0x38);\n    if (tempString != (char *)0x0) {\n      strcpy(newString + strLen1 + 1,tempString);\n      free(*(void **)(ptrStruct + 0x38));\n      *(undefined8 *)(*(long *)(binaryData + 0x60) + 0x38) = 0;\n    }\n    free(*(void **)(*(long *)(binaryData + 0x60) + 8));\n    ptrStruct = *(long *)(binaryData + 0x60);\n    *(char **)(ptrStruct + 8) = newString;\n    returnValue = CONCAT71((int7)((ulong)ptrStruct >> 8),1);\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "strcat",
                "strlen",
                "free",
                "xmalloc",
                "sprintf",
                "strcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010ae0e",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "process_binary_data_0010ae0e"
        },
        "FUN_001135a5": {
            "renaming": {
                "FUN_001135a5": "process_data_001135a5",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "data",
                "iVar1": "result",
                "cVar2": "isValid",
                "uVar3": "output",
                "puVar4": "currentItem",
                "puVar5": "currentNode"
            },
            "code": "\nundefined8 processData_001135a5(undefined8 input1,undefined8 input2,long data)\n\n{\n  int result;\n  char isValid;\n  undefined8 output;\n  undefined8 *currentItem;\n  undefined8 *currentNode;\n  \n  if (6 < *(uint *)(data + 0x14)) {\n                    \n    abort();\n  }\n  switch(*(undefined4 *)(data + 0x14)) {\n  case 0:\n    isValid = FUNC_00112c1f(input1,input2,*(undefined8 *)(data + 0x20),data);\n    if (isValid != '\\0') {\n      output = process_and_store_string_0010e6a8(input2,*(undefined8 *)(data + 8));\n      return output;\n    }\n    break;\n  case 1:\n    isValid = FUNC_00112c1f(input1,input2,*(undefined8 *)(data + 0x20),data);\n    if (isValid != '\\0') {\n      output = format_and_process_string_0010e7c2(input2,*(undefined8 *)(data + 8));\n      return output;\n    }\n    break;\n  case 2:\n    isValid = FUNC_00112c1f(input1,input2,*(undefined8 *)(*(long *)(data + 0x20) + 8),0);\n    if (isValid != '\\0') {\n      output = process_string_0010e9a0(input2,*(undefined8 *)(data + 8),**(undefined4 **)(data + 0x20),\n                           *(undefined8 *)(*(undefined4 **)(data + 0x20) + 4));\n      return output;\n    }\n    break;\n  case 3:\n    currentNode = *(undefined8 **)(data + 0x20);\n    result = *(int *)(data + 0x18);\n    output = *(undefined8 *)(data + 8);\n    isValid = process_files_00112502(input1,input2,*(undefined8 *)(currentNode[2] + 0x18));\n    if (((isValid != '\\0') && (isValid = FUNC_00112c1f(input1,input2,*currentNode,0), isValid != '\\0')) &&\n       (isValid = process_extracted_string_0010eafe(input2,output,result == 2), isValid != '\\0')) {\n      for (currentItem = (undefined8 *)currentNode[1]; currentItem != (undefined8 *)0x0;\n          currentItem = (undefined8 *)*currentItem) {\n        isValid = FUNC_00112c1f(input1,input2,currentItem[2],0);\n        if (isValid == '\\0') {\n          return 0;\n        }\n        isValid = process_extracted_item_0010ebb0(input2,currentItem[1],*(undefined4 *)(currentItem + 3));\n        if (isValid == '\\0') {\n          return 0;\n        }\n      }\n      currentNode = (undefined8 *)currentNode[2];\n      while( true ) {\n        if (currentNode == (undefined8 *)0x0) {\n          output = get_one_00108f05(input2);\n          return output;\n        }\n        isValid = process_and_update_data_00113a4d(input1,input2,currentNode);\n        if (isValid == '\\0') break;\n        currentNode = (undefined8 *)*currentNode;\n      }\n    }\n    break;\n  case 4:\n    output = process_and_format_string_0010e842(input2,*(undefined8 *)(data + 8),*(undefined8 *)(data + 0x20));\n    return output;\n  case 5:\n    output = process_and_check_string_0010e8a9(*(undefined8 *)(data + 0x20),input2,*(undefined8 *)(data + 8));\n    return output;\n  case 6:\n    isValid = FUNC_00112c1f(input1,input2,**(undefined8 **)(data + 0x20),0);\n    if (isValid != '\\0') {\n      output = process_string_with_parameters_0010e918(input2,*(undefined8 *)(data + 8),\n                           *(undefined8 *)(*(long *)(data + 0x20) + 8));\n      return output;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_0010e8a9",
                "FUN_0010e842",
                "abort",
                "FUN_0010e918",
                "FUN_0010ebb0",
                "FUN_0010e9a0",
                "FUN_0010e6a8",
                "FUN_00108f05",
                "FUN_0010e7c2",
                "FUN_00113a4d",
                "FUN_0010eafe",
                "FUN_00112c1f",
                "FUN_00112502"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001135a5",
            "calling": [
                "FUN_00113a4d",
                "FUN_0011378f"
            ],
            "imported": false,
            "current_name": "process_data_001135a5",
            "code_backup": "\nundefined8 FUN_001135a5(undefined8 param_1,undefined8 param_2,long param_3)\n\n{\n  int iVar1;\n  char cVar2;\n  undefined8 uVar3;\n  undefined8 *puVar4;\n  undefined8 *puVar5;\n  \n  if (6 < *(uint *)(param_3 + 0x14)) {\n                    \n    abort();\n  }\n  switch(*(undefined4 *)(param_3 + 0x14)) {\n  case 0:\n    cVar2 = FUNC_00112c1f(param_1,param_2,*(undefined8 *)(param_3 + 0x20),param_3);\n    if (cVar2 != '\\0') {\n      uVar3 = process_and_store_string_0010e6a8(param_2,*(undefined8 *)(param_3 + 8));\n      return uVar3;\n    }\n    break;\n  case 1:\n    cVar2 = FUNC_00112c1f(param_1,param_2,*(undefined8 *)(param_3 + 0x20),param_3);\n    if (cVar2 != '\\0') {\n      uVar3 = format_and_process_string_0010e7c2(param_2,*(undefined8 *)(param_3 + 8));\n      return uVar3;\n    }\n    break;\n  case 2:\n    cVar2 = FUNC_00112c1f(param_1,param_2,*(undefined8 *)(*(long *)(param_3 + 0x20) + 8),0);\n    if (cVar2 != '\\0') {\n      uVar3 = process_string_0010e9a0(param_2,*(undefined8 *)(param_3 + 8),**(undefined4 **)(param_3 + 0x20),\n                           *(undefined8 *)(*(undefined4 **)(param_3 + 0x20) + 4));\n      return uVar3;\n    }\n    break;\n  case 3:\n    puVar5 = *(undefined8 **)(param_3 + 0x20);\n    iVar1 = *(int *)(param_3 + 0x18);\n    uVar3 = *(undefined8 *)(param_3 + 8);\n    cVar2 = process_files_00112502(param_1,param_2,*(undefined8 *)(puVar5[2] + 0x18));\n    if (((cVar2 != '\\0') && (cVar2 = FUNC_00112c1f(param_1,param_2,*puVar5,0), cVar2 != '\\0')) &&\n       (cVar2 = process_extracted_string_0010eafe(param_2,uVar3,iVar1 == 2), cVar2 != '\\0')) {\n      for (puVar4 = (undefined8 *)puVar5[1]; puVar4 != (undefined8 *)0x0;\n          puVar4 = (undefined8 *)*puVar4) {\n        cVar2 = FUNC_00112c1f(param_1,param_2,puVar4[2],0);\n        if (cVar2 == '\\0') {\n          return 0;\n        }\n        cVar2 = process_extracted_item_0010ebb0(param_2,puVar4[1],*(undefined4 *)(puVar4 + 3));\n        if (cVar2 == '\\0') {\n          return 0;\n        }\n      }\n      puVar5 = (undefined8 *)puVar5[2];\n      while( true ) {\n        if (puVar5 == (undefined8 *)0x0) {\n          uVar3 = get_one_00108f05(param_2);\n          return uVar3;\n        }\n        cVar2 = FUNC_00113a4d(param_1,param_2,puVar5);\n        if (cVar2 == '\\0') break;\n        puVar5 = (undefined8 *)*puVar5;\n      }\n    }\n    break;\n  case 4:\n    uVar3 = process_and_format_string_0010e842(param_2,*(undefined8 *)(param_3 + 8),*(undefined8 *)(param_3 + 0x20));\n    return uVar3;\n  case 5:\n    uVar3 = process_and_check_string_0010e8a9(*(undefined8 *)(param_3 + 0x20),param_2,*(undefined8 *)(param_3 + 8));\n    return uVar3;\n  case 6:\n    cVar2 = FUNC_00112c1f(param_1,param_2,**(undefined8 **)(param_3 + 0x20),0);\n    if (cVar2 != '\\0') {\n      uVar3 = process_string_with_parameters_0010e918(param_2,*(undefined8 *)(param_3 + 8),\n                           *(undefined8 *)(*(long *)(param_3 + 0x20) + 8));\n      return uVar3;\n    }\n  }\n  return 0;\n}\n\n"
        },
        "FUN_00107976": {
            "renaming": {
                "FUN_00107976": "FUNC_00107976"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong FUNC_00107976(void)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  undefined *puVar3;\n  long *plVar4;\n  code *pcVar5;\n  long *plVar6;\n  ulong uVar7;\n  ulong uVar8;\n  char *__s;\n  char cVar9;\n  char cVar10;\n  uint uVar11;\n  int iVar12;\n  int iVar13;\n  undefined4 uVar14;\n  long *plVar15;\n  long lVar16;\n  undefined8 uVar17;\n  undefined8 uVar18;\n  size_t sVar19;\n  size_t sVar20;\n  char *pcVar21;\n  void *__ptr;\n  void *__ptr_00;\n  ulong uVar22;\n  long lVar23;\n  ulong uVar24;\n  undefined8 *in_RAX;\n  undefined8 uVar25;\n  char *pcVar26;\n  int *piVar27;\n  long lVar28;\n  ulong uVar29;\n  FILE *__s_00;\n  long **pplVar30;\n  uint uVar31;\n  long **__ptr_01;\n  char *pcVar32;\n  undefined8 *puVar33;\n  ulong uVar34;\n  int iVar35;\n  long **pplVar36;\n  long unaff_RBP;\n  undefined4 *puVar37;\n  undefined8 *puVar38;\n  char **ppcVar39;\n  void *pvVar40;\n  undefined8 *unaff_R14;\n  undefined **ppuVar41;\n  bool bVar42;\n  byte bVar43;\n  undefined8 *param_7;\n  ulong param_8;\n  char in_stack_00000018;\n  undefined4 *puStack0000000000000020;\n  char *pcStack0000000000000038;\n  uint uStack0000000000000048;\n  int iStack000000000000006c;\n  long lStack0000000000000078;\n  long lStack0000000000000088;\n  char *pcStack0000000000000090;\n  long lStack00000000000000a0;\n  long *in_stack_000000c0;\n  ulong in_stack_000000c8;\n  long in_stack_000000d0;\n  long in_stack_000000d8;\n  void *in_stack_000000e0;\n  long in_stack_000000f0;\n  undefined8 in_stack_000000f8;\n  byte bStack0000000000000100;\n  byte bStack0000000000000101;\n  undefined8 in_stack_00000110;\n  ushort in_stack_00000118;\n  char *in_stack_00000140;\n  char cStack0000000000000148;\n  char *in_stack_00000150;\n  undefined uStack0000000000000158;\n  short sStack000000000000015a;\n  \n  bVar43 = 0;\n  uVar18 = *in_RAX;\n  uVar17 = *param_7;\n  uVar25 = get_formatted_string_001125fa();\n  pcVar26 = (char *)dcgettext(0,\"copy from `%s\\' [%s] to `%s\\' [%s]\\n\",5);\n  printf(pcVar26,uVar25,uVar18,uVar17);\n  if ((*(byte *)(param_7 + 9) & 7) == 3) {\n    iVar13 = bfd_get_arch();\n    uVar14 = bfd_get_mach();\n    if (unaff_RBP != 0) {\n      uVar29 = FUNC_001152b6();\n      return uVar29;\n    }\n    goto LAB_00114f9a;\n  }\n  uVar31 = ~DAT_001278f0 & *(uint *)(param_7[1] + 0x14) &\n           (DAT_001278f4 | *(uint *)((long)unaff_R14 + 0x44));\n  if (DAT_00127a2c == 7) {\n    uVar31 = uVar31 & 0xfffffffe;\n    cVar10 = bfd_set_start_address(param_7);\n  }\n  else {\n    cVar10 = bfd_set_start_address(param_7);\n  }\n  if ((cVar10 == '\\0') || (cVar10 = bfd_set_file_flags(param_7,uVar31), cVar10 == '\\0'))\n  goto LAB_00107a82;\n  iVar13 = bfd_get_arch();\n  uVar14 = bfd_get_mach();\n  if (unaff_RBP == 0) {\nLAB_00114f9a:\n    if (((iVar13 == 0) && (*(int *)(unaff_R14[1] + 8) != 5)) && (*(int *)(param_7[1] + 8) == 5)) {\n      uVar29 = FUNC_00107880();\n      return uVar29;\n    }\n  }\n  else {\n    if (iVar13 == 0) {\n      iVar13 = *(int *)(unaff_RBP + 0xc);\n      uVar14 = *(undefined4 *)(unaff_RBP + 0x10);\n      goto LAB_00114f9a;\n    }\n    uVar18 = get_formatted_string_001125fa();\n    uVar17 = dcgettext(0,\"Input file `%s\\' ignores binary architecture parameter.\",5);\n    print_error_message_00119ed0(uVar17,uVar18);\n  }\n  cVar10 = (**(code **)(param_7[1] + 0x2a0))(param_7,iVar13,uVar14);\n  if (cVar10 == '\\0') {\n    if ((*(byte *)(unaff_R14 + 9) & 0x40) != 0) {\n      iVar13 = bfd_get_arch();\n      if (iVar13 == 0) {\n        uVar18 = get_formatted_string_001125fa();\n        uVar17 = dcgettext(0,\"Unable to recognise the format of the input file `%s\\'\",5);\n        print_error_message_00119ed0(uVar17,uVar18);\n        return 0;\n      }\n      uVar18 = bfd_get_mach();\n      uVar14 = bfd_get_arch();\n      uVar18 = bfd_printable_arch_mach(uVar14,uVar18);\n      uVar17 = dcgettext(0,\"Output file cannot represent architecture `%s\\'\",5);\n      print_error_message_00119ed0(uVar17,uVar18);\n      return 0;\n    }\n    iVar13 = bfd_get_arch();\n    iVar35 = bfd_get_arch(param_7);\n    if (iVar13 != iVar35) {\n      uVar29 = check_file_architecture_00105828();\n      return uVar29;\n    }\n  }\n  cVar10 = bfd_set_format(param_7,*(byte *)(unaff_R14 + 9) & 7);\n  if (cVar10 == '\\0') {\nLAB_00107a82:\n    display_error_001126c0(0);\n    return 0;\n  }\n  if ((*(int *)((undefined8 *)param_7[1] + 1) == 2) &&\n     (cVar10 = compare_strings_00113fb0(*(undefined8 *)param_7[1],&DAT_0011b503), cVar10 != '\\0')) {\n    lVar28 = param_7[0x22];\n    if ((*(int *)((undefined8 *)unaff_R14[1] + 1) == 2) &&\n       (cVar10 = compare_strings_00113fb0(*(undefined8 *)unaff_R14[1],&DAT_0011b503), cVar10 != '\\0')) {\n      lVar16 = unaff_R14[0x22];\n      bVar42 = DAT_001279cb == '\\0';\n      puVar33 = (undefined8 *)(lVar16 + 200);\n      puVar38 = (undefined8 *)(lVar28 + 200);\n      for (lVar23 = 0x32; lVar23 != 0; lVar23 = lVar23 + -1) {\n        *puVar38 = *puVar33;\n        puVar33 = puVar33 + (ulong)bVar43 * -2 + 1;\n        puVar38 = puVar38 + (ulong)bVar43 * -2 + 1;\n      }\n      if (bVar42) {\n        *(undefined4 *)(lVar28 + 0x2a4) = 0xffffffff;\n      }\n      else {\n        *(int *)(lVar28 + 0x2a4) = (int)*(undefined8 *)(lVar16 + 0xa8);\n      }\n    }\n    uVar29 = DAT_001264a8;\n    if (DAT_001264a8 == 0xffffffffffffffff) {\n      DAT_001264a8 = 0x200;\n      uVar29 = 0x200;\n    }\n    else {\n      *(int *)(lVar28 + 0x10c) = (int)DAT_001264a8;\n    }\n    if (DAT_00126498 != -1) {\n      *(long *)(lVar28 + 0x148) = DAT_00126498;\n    }\n    if (DAT_001264a0 != -1) {\n      *(long *)(lVar28 + 0x148) = DAT_001264a0;\n    }\n    if (DAT_00126490 != -1) {\n      *(long *)(lVar28 + 0x100) = DAT_00126490;\n    }\n    uVar22 = DAT_00126488;\n    if (DAT_00126488 == 0xffffffffffffffff) {\n      DAT_00126488 = 0x1000;\n      uVar22 = 0x1000;\n    }\n    else {\n      *(int *)(lVar28 + 0x108) = (int)DAT_00126488;\n    }\n    if (DAT_00126478 != -1) {\n      *(long *)(lVar28 + 0x138) = DAT_00126478;\n    }\n    if (DAT_00126480 != -1) {\n      *(long *)(lVar28 + 0x138) = DAT_00126480;\n    }\n    if (DAT_00126474 != -1) {\n      *(short *)(lVar28 + 300) = DAT_00126474;\n    }\n    if (DAT_00126472 != -1) {\n      *(short *)(lVar28 + 0x118) = DAT_00126472;\n    }\n    if (DAT_00126470 != -1) {\n      *(short *)(lVar28 + 0x11a) = DAT_00126470;\n    }\n    if (uVar22 < uVar29) {\n      uVar18 = dcgettext(0,\"warning: file alignment (0x%lx) > section alignment (0x%lx)\",5);\n      print_error_message_00119ed0(uVar18,uVar29,uVar22);\n    }\n  }\n  plVar6 = DAT_001278b0;\n  free(DAT_001278b0);\n  if (plVar6 == DAT_001278a8) {\n    DAT_001278b0 = (long *)0x0;\n    DAT_001278a8 = (long *)0x0;\n    lVar28 = (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  else {\n    free(DAT_001278a8);\n    DAT_001278b0 = (long *)0x0;\n    DAT_001278a8 = (long *)0x0;\n    lVar28 = (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  if (lVar28 < 0) goto LAB_00107a82;\n  DAT_001278a8 = (long *)xmalloc();\n  DAT_001278b0 = DAT_001278a8;\n  param_8 = (**(code **)(unaff_R14[1] + 0x200))();\n  if ((long)param_8 < 0) goto LAB_00107a82;\n  if (param_8 == 0) {\n    free(DAT_001278b0);\n    DAT_001278b0 = (long *)0x0;\n    DAT_001278a8 = (long *)0x0;\n  }\n  bfd_map_over_sections();\n  puVar33 = DAT_001279c0;\n  if ((DAT_001278ec == '\\0') &&\n     (cVar10 = (**(code **)(param_7[1] + 0x168))(), puVar33 = DAT_001279c0, cVar10 == '\\0')) {\n    DAT_00127a20 = 1;\n    dcgettext(0,\"error in private header data\",5);\n    display_error_001126c0(0);\n    puVar33 = DAT_001279c0;\n  }\n  for (; puVar38 = DAT_001279b8, puVar33 != (undefined8 *)0x0; puVar33 = (undefined8 *)*puVar33) {\n    uVar31 = 0x128;\n    lVar28 = parse_rules_00114190(puVar33[1],0,0x80);\n    if (lVar28 != 0) {\n      uVar31 = drop_share_flag_if_not_coff_00115f30(*(uint *)(lVar28 + 0x28) | 0x100,param_7,puVar33[1]);\n    }\n    lVar28 = bfd_get_section_by_name(param_7,puVar33[1]);\n    if (lVar28 != 0) {\n      uVar18 = puVar33[1];\n      uVar17 = dcgettext(0,\"can\\'t add section \\'%s\\'\",5);\n      display_error_001126c0(0,param_7,0,uVar17,uVar18);\n      return 0;\n    }\n    lVar28 = bfd_make_section_with_flags(param_7,puVar33[1],uVar31 | 0x100000);\n    puVar33[5] = lVar28;\n    if (lVar28 == 0) {\n      uVar18 = puVar33[1];\n      uVar17 = dcgettext(0,\"can\\'t create section `%s\\'\",5);\n      display_error_001126c0(0,param_7,0,uVar17,uVar18);\n      return 0;\n    }\n    cVar10 = bfd_set_section_size();\n    if (cVar10 == '\\0') {\n      display_error_001126c0(0,param_7,puVar33[5],0);\n      return 0;\n    }\n    lVar28 = parse_rules_00114190(puVar33[1],0,0x18);\n    if (lVar28 != 0) {\n      uVar18 = *(undefined8 *)(lVar28 + 0x18);\n      lVar28 = puVar33[5];\n      *(byte *)(lVar28 + 0x28) = *(byte *)(lVar28 + 0x28) | 1;\n      *(undefined8 *)(lVar28 + 0x30) = uVar18;\n      *(undefined8 *)(lVar28 + 0x38) = uVar18;\n    }\n    lVar28 = parse_rules_00114190(puVar33[1],0,0x60);\n    if (lVar28 != 0) {\n      lVar16 = puVar33[5];\n      *(undefined8 *)(lVar16 + 0x38) = *(undefined8 *)(lVar28 + 0x20);\n      if (0x3e < *(uint *)(lVar16 + 0x7c)) {\n        display_error_001126c0(0,param_7,lVar16,0);\n        return 0;\n      }\n    }\n  }\n  for (; puVar38 != (undefined8 *)0x0; puVar38 = (undefined8 *)*puVar38) {\n    lVar28 = bfd_get_section_by_name();\n    puVar38[5] = lVar28;\n    if (lVar28 == 0) {\n      uVar18 = puVar38[1];\n      uVar17 = dcgettext(0,\"error: %s not found, can\\'t be updated\",5);\n      print_error_message_00119ed0(uVar17,uVar18);\n      return 0;\n    }\n    uVar18 = *(undefined8 *)(lVar28 + 0x60);\n    cVar10 = bfd_set_section_size(uVar18);\n    if (cVar10 == '\\0') {\n      display_error_001126c0(0,param_7,uVar18,0);\n      return 0;\n    }\n  }\n  puVar33 = DAT_001279b0;\n  if (DAT_00127a00 == '\\0') {\n    __ptr_01 = (long **)0x0;\n  }\n  else {\n    pplVar36 = (long **)unaff_R14[0x12];\n    __ptr_01 = pplVar36;\n    if (pplVar36 != (long **)0x0) {\n      __ptr_01 = (long **)0x0;\nLAB_001151ab:\n      if (DAT_00127a00 != '\\0') goto LAB_00115187;\n      for (plVar6 = pplVar36[1]; puVar33 = DAT_001279b0, plVar6 != (long *)0x0;\n          plVar6 = (long *)plVar6[1]) {\n      }\n    }\n  }\njoined_r0x001151c7:\n  for (; puVar33 != (undefined8 *)0x0; puVar33 = (undefined8 *)*puVar33) {\n    lVar28 = bfd_get_section_by_name();\n    if (lVar28 == 0) {\n      dcgettext(0,\"can\\'t dump section \\'%s\\' - it does not exist\",5);\n      display_error_001126c0(0);\n    }\n    else if ((*(byte *)(lVar28 + 0x25) & 1) == 0) {\n      dcgettext(0,\"can\\'t dump section - it has no contents\",5);\n      display_error_001126c0(0);\n    }\n    else {\n      sVar19 = *(size_t *)(lVar28 + 0x40);\n      __s_00 = fopen((char *)puVar33[2],\"w\");\n      if (__s_00 == (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        display_error_001126c0(puVar33[2],0,0);\n      }\n      else {\n        cVar10 = bfd_malloc_and_get_section();\n        if (cVar10 == '\\0') {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          display_error_001126c0(0);\n        }\n        else if ((sVar19 != 0) &&\n                (sVar20 = fwrite(in_stack_00000140,1,sVar19,__s_00), sVar20 != sVar19)) {\n          piVar27 = __errno_location();\n          pcVar26 = strerror(*piVar27);\n          uVar18 = puVar33[2];\n          uVar17 = dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          print_error_message_00119ed0(uVar17,uVar18,pcVar26);\n          free(in_stack_00000140);\n          fclose(__s_00);\n          return 0;\n        }\n        fclose(__s_00);\n        free(in_stack_00000140);\n      }\n    }\n  }\n  if (DAT_00127a10 == 0) {\nLAB_0010790a:\n    lStack0000000000000078 = 0;\n  }\n  else {\n    lVar28 = bfd_get_section_by_name(param_7,\".gnu_debuglink\");\n    if (lVar28 != 0) {\n      uVar18 = dcgettext(0,\"%s: debuglink section already exists\",5);\n      print_error_message_00119ed0(uVar18);\n      DAT_00127a10 = 0;\n      goto LAB_0010790a;\n    }\n    lStack0000000000000078 = bfd_create_gnu_debuglink_section(param_7);\n    lVar28 = DAT_00127a10;\n    if (lStack0000000000000078 == 0) {\n      uVar18 = dcgettext(0,\"cannot create debug link section `%s\\'\",5);\n      display_error_001126c0(0,param_7,0,uVar18,lVar28);\n      return 0;\n    }\n    if (*(int *)(param_7[1] + 8) == 2) {\n      uVar22 = 0;\n      for (uVar29 = param_7[0x12]; uVar29 != 0; uVar29 = *(ulong *)(uVar29 + 8)) {\n        uVar24 = *(ulong *)(uVar29 + 0x30);\n        uVar34 = uVar22;\n        uVar7 = uVar29;\n        uVar8 = uVar22;\n        if (uVar24 != 0) {\n          while ((uVar34 = uVar7, uVar8 != 0 &&\n                 (uVar34 = uVar29, uVar24 <= *(ulong *)(uVar22 + 0x30)))) {\n            uVar29 = *(ulong *)(uVar29 + 8);\n            if (uVar29 == 0) goto LAB_00107db8;\n            uVar24 = *(ulong *)(uVar29 + 0x30);\n            uVar7 = uVar22;\n            uVar8 = uVar24;\n          }\n        }\n        uVar22 = uVar34;\n      }\nLAB_00107db8:\n      if (uVar22 == 0) {\n        uVar29 = 0x1000;\n      }\n      else {\n        uVar22 = *(long *)(uVar22 + 0x40) + *(long *)(uVar22 + 0x30);\n        uVar29 = 0xffffffffffffffff;\n        if (uVar22 < 0xfffffffffffff001) {\n          uVar29 = uVar22 + 0xfff & 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(lStack0000000000000078 + 0x28) = *(byte *)(lStack0000000000000078 + 0x28) | 1;\n      *(ulong *)(lStack0000000000000078 + 0x30) = uVar29;\n      *(ulong *)(lStack0000000000000078 + 0x38) = uVar29;\n    }\n  }\n  plVar6 = DAT_001278b0;\n  iStack000000000000006c = *(int *)(param_7 + 0x14);\n  if (iStack000000000000006c != 0) {\n    uVar29 = process_debug_info_0010554f();\n    return uVar29;\n  }\n  if (DAT_00127980 == '\\0') {\nLAB_00105588:\n    puStack0000000000000020 = (undefined4 *)0x0;\n  }\n  else {\n    ppuVar41 = &PTR_s__stab_00125c60;\n    puStack0000000000000020 = (undefined4 *)xmalloc(0x60);\n    puVar37 = puStack0000000000000020;\n    for (lVar28 = 0x18; lVar28 != 0; lVar28 = lVar28 + -1) {\n      *puVar37 = 0;\n      puVar37 = puVar37 + (ulong)bVar43 * -2 + 1;\n    }\n    pcStack0000000000000038 = (char *)0x0;\n    do {\n      puVar3 = *ppuVar41;\n      lVar28 = bfd_get_section_by_name();\n      lVar16 = bfd_get_section_by_name();\n      if ((lVar28 != 0) && (lVar16 != 0)) {\n        lVar28 = *(long *)(lVar28 + 0x40);\n        __ptr = (void *)xmalloc(lVar28);\n        cVar10 = bfd_get_section_contents();\n        if (cVar10 == '\\0') {\n          uVar14 = bfd_get_error();\n          bfd_errmsg(uVar14);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n          free(pcStack0000000000000038);\n          free(__ptr);\n        }\n        else {\n          uVar29 = *(ulong *)(lVar16 + 0x40);\n          __ptr_00 = (void *)xmalloc(uVar29 + 1);\n          in_stack_00000018 = bfd_get_section_contents();\n          if (in_stack_00000018 == '\\0') {\n            uVar14 = bfd_get_error();\n            bfd_errmsg(uVar14);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n            free(pcStack0000000000000038);\n          }\n          else {\n            *(undefined *)((long)__ptr_00 + uVar29) = 0;\n            if ((pcStack0000000000000038 != (char *)0x0) ||\n               (pcStack0000000000000038 = (char *)initialize_data_structure_00112894(),\n               pcStack0000000000000038 != (char *)0x0)) {\n              lStack00000000000000a0 = 0;\n              lStack0000000000000088 = 0;\n              for (pvVar40 = __ptr; pvVar40 <= (void *)((long)__ptr + lVar28 + -0xc);\n                  pvVar40 = (void *)((long)pvVar40 + 0xc)) {\n                uVar22 = (**(code **)(unaff_R14[1] + 0x40))(pvVar40);\n                bVar2 = *(byte *)((long)pvVar40 + 4);\n                uVar14 = (**(code **)(unaff_R14[1] + 0x58))((long)pvVar40 + 6);\n                lVar16 = (**(code **)(unaff_R14[1] + 0x40))((long)pvVar40 + 8);\n                if (bVar2 == 0) {\n                  lStack0000000000000088 = lStack00000000000000a0;\n                  lStack00000000000000a0 = lStack00000000000000a0 + lVar16;\n                }\n                else {\n                  uVar24 = (uVar22 & 0xffffffff) + lStack0000000000000088;\n                  if (uVar24 < uVar29) {\n                    pcVar26 = (char *)((long)__ptr_00 + uVar24);\n                    pcStack0000000000000090 = (char *)0x0;\n                    while( true ) {\n                      sVar19 = strlen(pcVar26);\n                      if (((sVar19 == 0) || (pcVar32 = pcVar26 + (sVar19 - 1), *pcVar32 != '\\\\')) ||\n                         ((ulong)((long)__ptr + lVar28) < (long)pvVar40 + 0x10U)) goto LAB_001077fb;\n                      *pcVar32 = '\\0';\n                      pvVar40 = (void *)((long)pvVar40 + 0xc);\n                      iVar13 = (**(code **)(unaff_R14[1] + 0x40))(pvVar40);\n                      uVar22 = (ulong)(uint)(iVar13 + (int)lStack0000000000000088);\n                      if (uVar29 <= uVar22) break;\n                      pcVar26 = (char *)concat(pcVar26,(long)__ptr_00 + uVar22,0);\n                      *pcVar32 = '\\\\';\n                      free(pcStack0000000000000090);\n                      pcStack0000000000000090 = pcVar26;\n                    }\n                    uVar18 = *unaff_R14;\n                    pcVar32 = (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar32,uVar18,puVar3,((long)pvVar40 - (long)__ptr) / 0xc);\nLAB_001077fb:\n                    update_data_entry_001088ae((ulong)bVar2,uVar14,lVar16,pcVar26);\n                    cVar10 = process_debug_info_0011173a(puStack0000000000000020,pcStack0000000000000038,bVar2);\n                    if (cVar10 == '\\0') {\n                      print_stab_entries_00108b3e();\n                      free_memory_and_reset_00108863();\n                      free(pcStack0000000000000090);\n                      free(pcStack0000000000000038);\n                      free(__ptr);\n                      free(__ptr_00);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar18 = *unaff_R14;\n                    pcVar26 = (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar26,uVar18,puVar3,((long)pvVar40 - (long)__ptr) / 0xc,\n                            uVar22 & 0xffffffff,(ulong)bVar2,((long)pvVar40 - (long)__ptr) % 0xc);\n                  }\n                }\n              }\n              free_memory_and_reset_00108863();\n              free(__ptr);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_00);\n          free(__ptr);\n        }\n        goto LAB_00105981;\n      }\nLAB_001058eb:\n      ppuVar41 = ppuVar41 + 2;\n    } while (ppuVar41 != (undefined **)&DAT_00125c90);\n    if ((pcStack0000000000000038 != (char *)0x0) && (cVar10 = process_debug_info_0010c892(), cVar10 == '\\0')) {\nLAB_00105981:\n      free(puStack0000000000000020);\n      goto LAB_00105588;\n    }\n    if (*(int *)(unaff_R14[1] + 8) == 1) {\n      lVar28 = 0;\n      for (plVar15 = plVar6; plVar15 < plVar6 + param_8; plVar15 = plVar15 + 1) {\n        (**(code **)(unaff_R14[1] + 0x218))();\n        if (cStack0000000000000148 == '-') {\n          if (((lVar28 == 0) && (lVar28 = initialize_data_structure_00112894(), lVar28 == 0)) ||\n             ((in_stack_00000150 == (char *)0x0 || (*in_stack_00000150 == '\\0'))))\n          goto LAB_00105981;\n          pcVar26 = (char *)0x0;\n          pcVar32 = in_stack_00000150;\n          while (((*pcVar32 != '\\0' && (sVar19 = strlen(pcVar32), pcVar32[sVar19 - 1] == '\\\\')) &&\n                 (plVar15 + 1 < plVar6 + param_8))) {\n            pcVar21 = (char *)xstrdup(pcVar32);\n            sVar19 = strlen(pcVar21);\n            pcVar21[sVar19 - 1] = '\\0';\n            pcVar32 = (char *)concat(pcVar21,*(undefined8 *)(plVar15[1] + 8),0);\n            free(pcVar21);\n            free(pcVar26);\n            plVar15 = plVar15 + 1;\n            pcVar26 = pcVar32;\n          }\n          update_data_entry_001088ae(uStack0000000000000158,(int)sStack000000000000015a,in_stack_00000140,pcVar32)\n          ;\n          in_stack_00000018 = process_debug_info_0011173a(puStack0000000000000020,lVar28,uStack0000000000000158);\n          if (in_stack_00000018 == '\\0') {\n            print_stab_entries_00108b3e();\n            free_memory_and_reset_00108863();\n            goto LAB_00105981;\n          }\n        }\n      }\n      free_memory_and_reset_00108863();\n      if ((lVar28 != 0) && (cVar10 = process_debug_info_0010c892(), cVar10 == '\\0')) goto LAB_00105981;\n    }\n    if (in_stack_00000018 == '\\0') {\n      if ((*(int *)(unaff_R14[1] + 8) == 2) && (param_8 != 0)) {\n        in_stack_00000140 = (char *)0x0;\n        in_stack_000000c0 = plVar6;\n        in_stack_000000d0 = 0;\n        in_stack_000000d8 = 0;\n        puVar33 = (undefined8 *)&stack0x00000148;\n        for (lVar28 = 0x22; lVar28 != 0; lVar28 = lVar28 + -1) {\n          *(undefined4 *)puVar33 = 0;\n          puVar33 = (undefined8 *)((long)puVar33 + (ulong)bVar43 * -8 + 4);\n        }\n        cVar10 = '\\0';\n        _uStack0000000000000048 = (int *)0x0;\n        pcStack0000000000000038 = (char *)0x0;\n        pcStack0000000000000090 = (char *)0xffffffffffffffff;\n        in_stack_000000c8 = param_8;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((long)param_8 <= in_stack_000000d0) goto LAB_00105590;\n            lVar28 = plVar6[in_stack_000000d0];\n            cVar9 = bfd_coff_get_syment();\n            lVar16 = in_stack_000000d8;\n            if (cVar9 == '\\0') {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar26 = \"bfd_coff_get_syment failed: %s\";\n              goto LAB_00105968;\n            }\n            pcVar26 = *(char **)(lVar28 + 8);\n            in_stack_000000d0 = in_stack_000000d0 + 1;\n            in_stack_000000d8 = (ulong)bStack0000000000000101 + 1 + in_stack_000000d8;\n            if ((bStack0000000000000101 != 0) && (cVar9 = bfd_coff_get_auxent(), cVar9 == '\\0')) {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar26 = \"bfd_coff_get_auxent failed: %s\";\n              goto LAB_00105968;\n            }\n            if (pcStack0000000000000090 != (char *)lVar16) break;\n            if (bStack0000000000000100 != 0x67) {\n              cVar9 = initialize_debug_info_0010bbd3(puStack0000000000000020);\n              if (cVar9 != '\\0') break;\n              goto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            pcStack0000000000000090 = (char *)in_stack_000000f0;\n            cVar9 = initialize_debug_info_0010bbd3(puStack0000000000000020);\n            if (cVar9 == '\\0') goto LAB_00105981;\n          }\n          if ((char)bStack0000000000000100 < '\\0') {\n            if (bStack0000000000000100 == 0xff) goto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            lVar23 = parse_and_initialize_data_0010dac0();\n            if (lVar23 == 0) break;\n            cVar9 = process_parameter_00112a33(&stack0x00000140,lVar28,lVar16);\n          }\n          else {\n            if (bStack0000000000000100 < 100) {\n              switch(bStack0000000000000100) {\n              case 3:\n                if (in_stack_000000f8._6_2_ == 0) goto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulong)((uint)in_stack_000000f8._6_2_ & *(uint *)(unaff_R14[0x22] + 0x40)) !=\n                    2L << ((byte)*(undefined4 *)(unaff_R14[0x22] + 0x3c) & 0x3f)) goto LAB_0010700a;\n                _uStack0000000000000048 = (int *)(**(code **)(unaff_R14[1] + 0x238))();\n                pcStack0000000000000038 = pcVar26;\n                goto switchD_00106e1a_caseD_68;\n              default:\n                goto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                goto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(bStack0000000000000100) {\n            case 100:\n              iVar13 = strcmp(pcVar26,\".bb\");\n              if (iVar13 == 0) {\n                cVar9 = start_debug_block_0010be88(puStack0000000000000020);\n              }\n              else {\n                iVar13 = strcmp(pcVar26,\".eb\");\n                if (iVar13 != 0) goto switchD_00106e1a_caseD_68;\n                cVar9 = debug_end_block_check_0010bf20(puStack0000000000000020);\n              }\n              break;\n            case 0x65:\n              iVar13 = strcmp(pcVar26,\".bf\");\n              if (iVar13 == 0) {\n                if (pcStack0000000000000038 != (char *)0x0) {\n                  lVar16 = parse_and_initialize_data_0010dac0();\n                  if ((lVar16 == 0) ||\n                     (cVar10 = initialize_debug_record_0010bc80(puStack0000000000000020), cVar10 == '\\0'))\n                  goto LAB_00105981;\n                  if (_uStack0000000000000048 != (int *)0x0) {\n                    iVar13 = 0;\n                    if (bStack0000000000000101 != 0) {\n                      iVar13 = in_stack_00000118 - 1;\n                    }\n                    lVar28 = *(long *)(*(long *)(lVar28 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar35 = _uStack0000000000000048[4];\n                      if (iVar35 == 0) break;\n                      cVar9 = record_line_info_0010bf86(puStack0000000000000020,iVar13 + iVar35,\n                                           *(long *)(_uStack0000000000000048 + 6) + lVar28);\n                      _uStack0000000000000048 = _uStack0000000000000048 + 4;\n                      if (cVar9 == '\\0') goto LAB_00105981;\n                    }\n                  }\n                  _uStack0000000000000048 = (int *)0x0;\n                  pcStack0000000000000038 = (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar26 = \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar13 = strcmp(pcVar26,\".ef\");\n                if (iVar13 != 0) goto switchD_00106e1a_caseD_68;\n                if (cVar10 != '\\0') {\n                  cVar10 = end_debugging_function_0010be1a(puStack0000000000000020);\n                  if (cVar10 == '\\0') goto LAB_00105981;\n                  cVar10 = '\\0';\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar26 = \"%ld: unexpected .ef\\n\";\n              }\n              uVar18 = dcgettext(0,pcVar26,5);\n              print_error_message_00119ed0(uVar18);\n              goto LAB_00105981;\n            default:\n              goto LAB_0010700a;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (cVar9 != '\\0');\n      }\n      else {\n        pcVar26 = \"%s: no recognized debugging information\";\nLAB_00105968:\n        uVar18 = dcgettext(0,pcVar26,5);\n        print_error_message_00119ed0(uVar18);\n      }\n      goto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)((long)param_7 + 0x44) & 0x42) != 0) &&\n     ((*(uint *)((long)param_7 + 0x44) & 1) == 0)) {\n    if ((*(char *)(param_7[1] + 0x20) == '\\0') && (DAT_00127939 == '\\0')) {\n      if (param_8 != 0) {\n        plVar6 = DAT_001278b0 + param_8;\n        plVar15 = DAT_001278b0;\n        do {\n          uVar31 = *(uint *)(*plVar15 + 0x18);\n          if ((uVar31 & 0x1000000) != 0) {\n            *(uint *)(*plVar15 + 0x18) = uVar31 & 0xfeffffff;\n          }\n          plVar15 = plVar15 + 1;\n        } while (plVar6 != plVar15);\n      }\n    }\n    else {\n      for (lVar28 = param_7[0x12]; lVar28 != 0; lVar28 = *(long *)(lVar28 + 8)) {\n        if (*(long *)(lVar28 + 0xe8) != 0) {\n          puVar1 = (uint *)(*(long *)(lVar28 + 0xe8) + 0x18);\n          *puVar1 = *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((DAT_00127a2c == 2) || (DAT_00127a2c == 7)) {\nLAB_001059fe:\n    if (DAT_00127a2c == 7) {\nLAB_00105a3b:\n      plVar15 = (long *)xmalloc();\n      plVar6 = DAT_001278b0;\n      uStack0000000000000048 = *(uint *)((long)unaff_R14 + 0x44) & 0x42;\n      DAT_001278a8 = plVar15;\n      if (param_8 == 0) {\n        uVar29 = 0;\n      }\n      else {\n        uVar29 = 0;\n        _in_stack_00000018 = 0;\n        do {\n          iVar13 = DAT_001279a0;\n          plVar4 = (long *)plVar6[_in_stack_00000018];\n          pcVar5 = (code *)plVar4[4];\n          uVar31 = *(uint *)(plVar4 + 3);\n          pcVar26 = (char *)plVar4[1];\n          pcVar32 = pcVar26;\n          if (DAT_001279a8 != (undefined8 *)0x0) {\n            iVar35 = 0;\n            puVar33 = DAT_001279a8;\n            while ((iVar35 < iVar13 && (pcVar21 = (char *)puVar33[5], pcVar21 != (char *)0x0))) {\n              if (pcVar21 != \"\") {\n                iVar12 = strcmp(pcVar21,pcVar26);\n                if (iVar12 == 0) {\n                  free(pcVar21);\n                  uVar22 = uVar29 + 1;\n                  puVar33[5] = \"\";\n                  lVar28 = update_section_info_0011a2e0(puVar33);\n                  uVar18 = DAT_001278d0;\n                  plVar15[uVar29] = lVar28;\n                  lVar28 = htab_elements(uVar18);\n                  if ((lVar28 != 0) || (DAT_001278d8 != (char **)0x0)) goto LAB_001064eb;\n                  goto LAB_00105af8;\n                }\n                puVar33 = (undefined8 *)*puVar33;\n              }\n              iVar35 = iVar35 + 1;\n            }\n          }\n          lVar28 = htab_elements(DAT_001278d0);\n          uVar22 = uVar29;\n          if ((lVar28 == 0) && (DAT_001278d8 == (char **)0x0)) {\nLAB_00105af8:\n            cVar10 = *pcVar26;\n            if (cVar10 != '\\0') goto LAB_00105b11;\nLAB_00106557:\n            pcVar26 = DAT_00127908;\n            if ((DAT_00127988 != '\\0') && (*(char *)(param_7[1] + 0x1c) != '\\0')) {\n              lVar28 = unaff_R14[1];\n              cVar10 = '\\0';\n              goto LAB_0010668d;\n            }\n            goto joined_r0x00106565;\n          }\n          if (pcVar26 != (char *)0x0) {\nLAB_001064eb:\n            if (((*pcVar26 == '_') && (pcVar26[1] == '_')) &&\n               (iVar13 = strcmp(pcVar26 + (pcVar26[2] == '_'),\"__gnu_lto_slim\"), iVar13 == 0)) {\n              uVar18 = dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\",5\n                                );\n                    \n              print_error_and_exit_00119dd0(uVar18);\n            }\n          }\n          _cStack0000000000000148 = 0;\n          in_stack_00000140 = pcVar26;\n          lVar28 = htab_find(DAT_001278d0);\n          if (((lVar28 == 0) || (pcVar32 = *(char **)(lVar28 + 8), pcVar26 == pcVar32)) &&\n             (pcVar32 = pcVar26, ppcVar39 = DAT_001278d8, (uVar31 & 0x100) != 0)) {\n            for (; ppcVar39 != (char **)0x0; ppcVar39 = (char **)ppcVar39[3]) {\n              iVar13 = strcmp(*ppcVar39,pcVar26);\n              if (iVar13 == 0) {\n                pcVar32 = ppcVar39[1];\n                break;\n              }\n            }\n          }\n          plVar4[1] = (long)pcVar32;\n          cVar10 = *pcVar32;\n          if (cVar10 == '\\0') goto LAB_00106557;\nLAB_00105b11:\n          pcVar26 = DAT_00127908;\n          lVar28 = unaff_R14[1];\n          if (*(char *)(lVar28 + 0x1c) == cVar10) {\n            if (DAT_00127988 == '\\0') {\n              if ((DAT_00127968 == '\\0') ||\n                 ((((uVar31 & 0x82) == 0 && (pcVar5 != bfd_map_over_sections)) &&\n                  ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n              pcVar32 = pcVar32 + 1;\n              plVar4[1] = (long)pcVar32;\n              goto joined_r0x00106565;\n            }\n            if (*(char *)(param_7[1] + 0x1c) == '\\0') goto LAB_0010677d;\n            if (DAT_00127908 != (char *)0x0) {\n              pcVar32 = pcVar32 + 1;\n              plVar4[1] = (long)pcVar32;\n              sVar19 = strlen(pcVar32);\n              lVar28 = sVar19 + 2;\nLAB_001066bc:\n              sVar19 = strlen(pcVar26);\n              pcVar26 = (char *)xmalloc(sVar19 + lVar28);\n              goto LAB_001066d0;\n            }\n            *pcVar32 = *(char *)(param_7[1] + 0x1c);\n            plVar4[1] = (long)pcVar32;\n            uVar29 = uVar22;\n          }\n          else {\n            if ((DAT_00127988 == '\\0') || (*(char *)(param_7[1] + 0x1c) == '\\0')) {\njoined_r0x00106565:\n              uVar29 = uVar22;\n              if (pcVar26 == (char *)0x0) goto LAB_00105b32;\n              sVar19 = strlen(pcVar32);\n              sVar20 = strlen(pcVar26);\n              pcVar21 = (char *)xmalloc(sVar20 + sVar19 + 1);\n              pcVar26 = pcVar21;\n            }\n            else {\nLAB_0010668d:\n              pcVar26 = DAT_00127908;\n              if ((*(char *)(lVar28 + 0x1c) != '\\0') && (cVar10 != *(char *)(lVar28 + 0x1c)))\n              goto joined_r0x00106565;\n              sVar19 = strlen(pcVar32);\n              lVar28 = sVar19 + 2;\n              if (pcVar26 != (char *)0x0) goto LAB_001066bc;\n              pcVar26 = (char *)xmalloc(lVar28);\nLAB_001066d0:\n              pcVar21 = pcVar26 + 1;\n              *pcVar26 = *(char *)(param_7[1] + 0x1c);\n            }\n            __s = DAT_00127908;\n            if (DAT_00127908 != (char *)0x0) {\n              strcpy(pcVar21,DAT_00127908);\n              sVar19 = strlen(__s);\n              pcVar21 = pcVar21 + sVar19;\n            }\n            strcpy(pcVar21,pcVar32);\n            plVar4[1] = (long)pcVar26;\n            pcVar32 = pcVar26;\n            uVar29 = uVar22;\n          }\nLAB_00105b32:\n          if (DAT_00127a2c == 7) goto LAB_001067a8;\n          if (((uVar31 & 0x20) == 0) &&\n             (((uVar31 & 0x100) == 0 ||\n              ((*(byte *)(**(long **)(plVar4[4] + 0xf0) + 0x18) & 0x20) == 0)))) {\n            if (((uStack0000000000000048 == 0) &&\n                (((uVar31 & 0x82) != 0 || ((*(byte *)(plVar4[4] + 0x25) & 0x10) != 0)))) ||\n               (iVar13 = bfd_decode_symclass(plVar4), iVar13 == 0x49)) {\nLAB_00105be2:\n              if (DAT_001279ca == '\\0') {\n                lVar28 = htab_find();\n                if (lVar28 == 0) goto LAB_00105c07;\n              }\n              else {\n                _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n                in_stack_00000140 = pcVar32;\n                htab_traverse(DAT_001279f8,pattern_match_0011a170,&stack0x00000140);\n                if (cStack0000000000000148 == '\\0') goto LAB_00105c07;\n              }\n            }\n            else if ((((uVar31 & 0x82) == 0) && (pcVar5 != bfd_map_over_sections)) &&\n                    ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)) {\n              if ((uVar31 & 4) == 0) {\n                if (((*(int *)(unaff_R14[1] + 8) != 2) ||\n                    (lVar28 = *(long *)(plVar4[4] + 0xd0), lVar28 == 0)) ||\n                   (*(long *)(lVar28 + 0x40) == 0)) {\n                  if ((DAT_00127a2c == 3) || (DAT_00127a28 == 2)) goto LAB_001067a8;\n                  if (DAT_00127a28 == 1) {\n                    cVar10 = bfd_is_local_label(unaff_R14);\n                    goto joined_r0x00106a11;\n                  }\n                }\n                goto LAB_00105be2;\n              }\n              cVar10 = DAT_00127980;\n              if (1 < DAT_00127a2c - 2U) {\njoined_r0x00106a11:\n                if (cVar10 == '\\0') goto LAB_00105be2;\n              }\n            }\n            else if (DAT_00127a2c != 3) goto LAB_00105be2;\n            goto LAB_001067a8;\n          }\n          if (DAT_001279ca == '\\0') {\n            lVar28 = htab_find();\n            if (lVar28 != 0) {\nLAB_0010687f:\n              uVar18 = dcgettext(0,\"not stripping symbol `%s\\' because it is named in a relocation\",\n                                 5);\n              print_error_message_00119ed0(uVar18);\n              DAT_00127a20 = 1;\n            }\n          }\n          else {\n            _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n            in_stack_00000140 = pcVar32;\n            htab_traverse(DAT_001279f8,pattern_match_0011a170,&stack0x00000140);\n            if (cStack0000000000000148 != '\\0') goto LAB_0010687f;\n          }\n          if ((uVar31 & 0x20) == 0) {\nLAB_00105c07:\n            if (DAT_001279ca != '\\0') {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              in_stack_00000140 = pcVar32;\n              htab_traverse(DAT_001279f0,pattern_match_0011a170,&stack0x00000140);\n              if (cStack0000000000000148 != '\\0') goto LAB_001067a8;\n              goto LAB_00105c2c;\n            }\n            lVar28 = htab_find();\n            if (lVar28 == 0) goto LAB_00105c2c;\nLAB_001067a8:\n            if ((DAT_00127a18 != '\\0') && ((uVar31 & 0x4000) != 0)) goto LAB_00105c2c;\n            if (DAT_001279ca == '\\0') {\n              lVar28 = htab_find();\n              if (lVar28 != 0) goto LAB_00105c2c;\n            }\n            else {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              in_stack_00000140 = pcVar32;\n              htab_traverse(DAT_00127a08,pattern_match_0011a170,&stack0x00000140);\n              if (cStack0000000000000148 != '\\0') goto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            cVar10 = process_section_data_001159d0(plVar4[4]);\n            if (cVar10 == '\\0') {\n              if (((uVar31 & 0x800002) == 0) && (pcVar5 != bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uVar31 & 0x82) != 0) {\n                  cVar10 = find_value_00115d70(pcVar32);\n                  if ((cVar10 == '\\0') &&\n                     ((lVar28 = htab_elements(DAT_001279d8), lVar28 == 0 ||\n                      (cVar10 = find_value_00115d70(pcVar32), cVar10 != '\\0')))) {\n                    if (((((DAT_00127938 == '\\0') ||\n                          (uVar11 = *(uint *)(plVar4 + 3), (uVar11 & 0x200000) != 0)) ||\n                         (lVar28 = *plVar4, lVar28 == 0)) ||\n                        ((*(int *)(*(long *)(lVar28 + 8) + 8) != 5 ||\n                         (*(long *)(lVar28 + 0x110) == 0)))) ||\n                       (1 < (*(byte *)((long)plVar4 + 0x49) & 3) - 1)) goto joined_r0x00105ca2;\n                  }\n                  else {\n                    uVar11 = *(uint *)(plVar4 + 3);\n                  }\n                  *(uint *)(plVar4 + 3) = uVar11 & 0xffffff7d | 1;\n                }\njoined_r0x00105ca2:\n                if (((uVar31 & 1) != 0) && (cVar10 = find_value_00115d70(pcVar32), cVar10 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((DAT_001279c8 != '\\0') || (cVar10 = find_value_00115d70(pcVar32), cVar10 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xff7ffffd | 0x80;\n                }\n                if (pcVar5 != bfd_map_over_sections) goto LAB_00105c5f;\n              }\n              plVar15[uVar29] = (long)plVar4;\n              uVar29 = uVar29 + 1;\n            }\n          }\n          _in_stack_00000018 = _in_stack_00000018 + 1;\n        } while (param_8 != _in_stack_00000018);\n      }\n      if (DAT_001279a8 != (undefined8 *)0x0) {\n        puVar33 = DAT_001279a8;\n        iVar13 = DAT_001279a0;\n        for (lVar28 = 0; lVar28 < iVar13; lVar28 = lVar28 + 1) {\n          pcVar26 = (char *)puVar33[5];\n          if (pcVar26 == (char *)0x0) {\n            plVar6 = plVar15 + uVar29;\n            uVar29 = uVar29 + 1;\n            lVar16 = update_section_info_0011a2e0(puVar33,param_7);\n            *plVar6 = lVar16;\n            iVar13 = DAT_001279a0;\n          }\n          else if (pcVar26 != \"\") {\n            uVar18 = dcgettext(0,\"\\'before=%s\\' not found\",5);\n                    \n            print_error_and_exit_00119dd0(uVar18,pcVar26);\n          }\n          puVar33 = (undefined8 *)*puVar33;\n        }\n      }\n      bVar42 = DAT_00127980 == '\\0';\n      plVar15[uVar29] = 0;\n      if ((bVar42) || (puStack0000000000000020 == (undefined4 *)0x0)) {\nLAB_00105cfa:\n        param_8 = uVar29 & 0xffffffff;\n        goto LAB_00105710;\n      }\n      iVar13 = *(int *)((undefined8 *)param_7[1] + 1);\n      if ((iVar13 == 5) || (iVar13 == 2)) {\n        in_stack_000000e0 = (void *)0x0;\n        cVar10 = extract_binary_data_0011378f(param_7,puStack0000000000000020,&stack0x000000c0,&stack0x00000110,\n                              &stack0x000000e0,&stack0x00000140);\n        if (cVar10 != '\\0') {\n          lVar28 = bfd_make_section_with_flags(param_7,\".stab\",0x2108);\n          lVar16 = bfd_make_section_with_flags(param_7,\".stabstr\",0x2108);\n          if ((((lVar28 == 0) || (lVar16 == 0)) ||\n              (cVar10 = bfd_set_section_size(lVar28,in_stack_00000110), cVar10 == '\\0')) ||\n             (cVar10 = bfd_set_section_size(lVar16,in_stack_00000140), cVar10 == '\\0')) {\n            pcVar26 = \"can\\'t create debugging section\";\n          }\n          else {\n            *(undefined4 *)(lVar28 + 0x7c) = 2;\n            *(undefined4 *)(lVar16 + 0x7c) = 0;\n            cVar10 = bfd_set_section_contents(param_7,lVar28,in_stack_000000c0,0,in_stack_00000110);\n            if ((cVar10 != '\\0') &&\n               (cVar10 = bfd_set_section_contents\n                                   (param_7,lVar16,in_stack_000000e0,0,in_stack_00000140),\n               cVar10 != '\\0')) {\n              free(puStack0000000000000020);\n              goto LAB_00105cfa;\n            }\n            pcVar26 = \"can\\'t set debugging section contents\";\n          }\n          uVar18 = dcgettext(0,pcVar26,5);\n          display_error_001126c0(0,param_7,0,uVar18);\n          free(in_stack_000000e0);\n          free(puStack0000000000000020);\n          goto LAB_00105d96;\n        }\n      }\n      else {\n        uVar18 = *(undefined8 *)param_7[1];\n        uVar17 = dcgettext(0,\"don\\'t know how to write debugging information for %s\",5);\n        display_error_001126c0(0,param_7,0,uVar17,uVar18);\n      }\n      free(puStack0000000000000020);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections();\n      iVar13 = bfd_get_error();\n      if (iVar13 == 0) goto LAB_00105a3b;\n    }\nLAB_00105d96:\n    DAT_00127a20 = 1;\n  }\n  else {\n    if ((DAT_00127a2c - 3U < 4) || ((DAT_00127a28 != 0 || (DAT_00127938 != '\\0'))))\n    goto LAB_00105a07;\n    lVar28 = htab_elements(DAT_001279f8);\n    if (((lVar28 != 0) ||\n        (((((((lVar28 = htab_elements(DAT_00127a08), lVar28 != 0 ||\n              (lVar28 = htab_elements(DAT_001279e8), lVar28 != 0)) ||\n             (lVar28 = htab_elements(DAT_001279e0), lVar28 != 0)) ||\n            ((lVar28 = htab_elements(DAT_001279d8), lVar28 != 0 ||\n             (lVar28 = htab_elements(DAT_001279d0), lVar28 != 0)))) ||\n           (lVar28 = htab_elements(DAT_001278d0), lVar28 != 0)) ||\n          (((DAT_00127908 != (char *)0x0 || (DAT_001278b8 != '\\0')) ||\n           ((DAT_00127a19 != '\\0' ||\n            (((DAT_00127980 != '\\0' || (DAT_00127988 != '\\0')) || (DAT_00127968 != '\\0')))))))) ||\n         ((DAT_001278d8 != (char **)0x0 || (DAT_001279c8 != '\\0')))))) || (DAT_001279a0 != 0))\n    goto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(param_7,DAT_001278a8,param_8 & 0xffffffff);\n    bfd_map_over_sections(unaff_R14,process_section_data_00115dc0,param_7);\n    bfd_map_over_sections(unaff_R14,reverse_section_contents_00116110,param_7);\n    for (puVar33 = DAT_001279c0; puVar38 = DAT_001279b8, puVar33 != (undefined8 *)0x0;\n        puVar33 = (undefined8 *)*puVar33) {\n      cVar10 = bfd_set_section_contents(param_7,puVar33[5],puVar33[4],0,puVar33[3]);\n      if (cVar10 == '\\0') {\n        display_error_001126c0(0,param_7,puVar33[5],0);\n        return 0;\n      }\n    }\n    for (; puVar38 != (undefined8 *)0x0; puVar38 = (undefined8 *)*puVar38) {\n      uVar18 = *(undefined8 *)(puVar38[5] + 0x60);\n      cVar10 = bfd_set_section_contents(param_7,uVar18,puVar38[4],0,puVar38[3]);\n      if (cVar10 == '\\0') {\n        display_error_001126c0(0,param_7,uVar18,0);\n        return 0;\n      }\n    }\n    if (__ptr_01 == (long **)0x0) {\n      if ((DAT_00127a00 != '\\0') && (_DAT_00127a24 == 0)) {\n        uVar18 = *unaff_R14;\n        uVar17 = dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n        print_error_message_00119ed0(uVar17,uVar18);\n      }\n    }\n    else {\n      pplVar36 = (long **)0x0;\n      for (puVar33 = (undefined8 *)param_7[0x12]; puVar33 != (undefined8 *)0x0;\n          puVar33 = (undefined8 *)puVar33[1]) {\n        if (((DAT_00127a00 != '\\0') && (*(int *)(param_7[1] + 8) == 5)) &&\n           ((*(int *)(puVar33[0x1a] + 4) == 7 &&\n            (cVar10 = compare_strings_00113fb0(*puVar33,\".gnu.build.attributes\"), cVar10 != '\\0')))) {\n          if (pplVar36 == (long **)0x0) {\n            pplVar36 = __ptr_01;\n          }\n          pplVar30 = __ptr_01;\n          if ((undefined8 *)(*pplVar36)[0xc] == puVar33) {\nLAB_0010625f:\n            pcVar26 = \"error: failed to merge notes\";\n            if (pplVar36[1] != (long *)0x0) {\n              cVar10 = bfd_set_section_contents(param_7,puVar33,pplVar36[1],0,pplVar36[2]);\n              if (cVar10 == '\\0') {\n                uVar18 = dcgettext(0,\"error: failed to copy merged notes into output\",5);\n                display_error_001126c0(0,param_7,puVar33,uVar18);\n                return 0;\n              }\n              pplVar36 = (long **)pplVar36[3];\n              goto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              pplVar36 = pplVar30;\n              if ((undefined8 *)(*pplVar30)[0xc] == puVar33) goto LAB_0010625f;\n              pplVar36 = (long **)pplVar30[3];\n              pplVar30 = pplVar36;\n            } while (pplVar36 != (long **)0x0);\n            pcVar26 = \"error: failed to locate merged notes\";\n          }\n          uVar18 = dcgettext(0,pcVar26,5);\n          display_error_001126c0(0,param_7,puVar33,uVar18);\n        }\nLAB_001061be:\n      }\n      do {\n        pplVar36 = (long **)__ptr_01[3];\n        free(__ptr_01[1]);\n        free(__ptr_01);\n        __ptr_01 = pplVar36;\n      } while (pplVar36 != (long **)0x0);\n    }\n    if ((DAT_00127a10 == 0) ||\n       (cVar10 = bfd_fill_in_gnu_debuglink_section(param_7,lStack0000000000000078),\n       lVar28 = DAT_00127a10, cVar10 != '\\0')) {\n      uVar31 = (**(code **)(param_7[1] + 0x140))(unaff_R14);\n      uVar29 = (ulong)uVar31;\n      if ((char)uVar31 != '\\0') {\n        if (DAT_00127910 == 0) {\n          return uVar29;\n        }\n        cVar10 = bfd_alt_mach_code(param_7,DAT_00127910 & 0xffffffff);\n        uVar22 = DAT_00127910;\n        if (cVar10 == '\\0') {\n          uVar18 = dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n          print_error_message_00119ed0(uVar18,uVar22);\n          if (*(int *)(param_7[1] + 8) == 5) {\n            uVar18 = dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n            print_error_message_00119ed0(uVar18);\n            *(short *)(param_7[0x22] + 0x3a) = (short)DAT_00127910;\n            return uVar29;\n          }\n          uVar18 = dcgettext(0,\"ignoring the alternative value\",5);\n          print_error_message_00119ed0(uVar18);\n          return uVar29;\n        }\n        return uVar29;\n      }\n      uVar18 = dcgettext(0,\"error copying private BFD data\",5);\n      display_error_001126c0(0,param_7,0,uVar18);\n    }\n    else {\n      uVar18 = dcgettext(0,\"cannot fill debug link section `%s\\'\",5);\n      display_error_001126c0(0,param_7,0,uVar18,lVar28);\n    }\n  }\n  return 0;\nLAB_00115187:\n  if ((((*(int *)(unaff_R14[1] + 8) == 5) && (*(int *)((long)pplVar36[0x1a] + 4) == 7)) &&\n      (cVar10 = compare_strings_00113fb0(*pplVar36), cVar10 != '\\0')) &&\n     ((pplVar36[0xc] != (long *)0x0 && (plVar6 = pplVar36[8], plVar6 != (long *)0x0)))) {\n    pplVar30 = (long **)xmalloc(0x20);\n    pplVar30[1] = (long *)0x0;\n    cVar10 = bfd_get_full_section_contents();\n    if (cVar10 == '\\0') {\n      dcgettext(0,\"warning: could not load note section\",5);\n      display_error_001126c0(0);\n      free(pplVar30);\n    }\n    else {\n      plVar15 = (long *)parse_gnu_build_attribute_notes_001163d0();\n      pplVar30[2] = plVar15;\n      if ((plVar15 == plVar6) || (cVar10 = bfd_set_section_size(pplVar36[0xc]), cVar10 != '\\0')) {\n        pplVar30[3] = (long *)__ptr_01;\n        *pplVar30 = (long *)pplVar36;\n        __ptr_01 = pplVar30;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        display_error_001126c0(0,param_7,pplVar36);\n        free(pplVar30[1]);\n        free(pplVar30);\n      }\n    }\n  }\n  pplVar36 = (long **)pplVar36[1];\n  puVar33 = DAT_001279b0;\n  if (pplVar36 == (long **)0x0) goto joined_r0x001151c7;\n  goto LAB_001151ab;\n}\n\n",
            "called": [
                "bfd_get_mach",
                "bfd_set_file_flags",
                "dcgettext",
                "FUN_001152b6",
                "FUN_001125fa",
                "bfd_get_arch",
                "printf",
                "bfd_set_start_address"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00107976",
            "calling": [
                "FUN_00114e50"
            ],
            "imported": false,
            "current_name": "FUNC_00107976"
        },
        "printf": {
            "renaming": {},
            "code": "\n\n\nint printf(char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = printf(__format);\n  return iVar1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001042a0",
            "calling": [
                "FUN_00119970",
                "FUN_00104ea2",
                "FUN_00104943",
                "FUN_00107976",
                "FUN_001199d0",
                "FUN_00119f70"
            ],
            "imported": false,
            "current_name": "printf"
        },
        "strcat": {
            "renaming": {},
            "code": "\n\n\nchar * strcat(char *__dest,char *__src)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strcat(__dest,__src);\n  return pcVar1;\n}\n\n",
            "called": [
                "strcat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047c0",
            "calling": [
                "FUN_00115530",
                "FUN_0010ee3f",
                "FUN_0010ae0e"
            ],
            "imported": false,
            "current_name": "strcat"
        },
        "FUN_0010b0fa": {
            "renaming": {
                "FUN_0010b0fa": "extract_and_initialize_data_0010b0fa",
                "param_1": "source_param",
                "param_2": "destination_param",
                "param_3": "data_array",
                "param_4": "binary_data",
                "param_5": "error_flag",
                "uVar1": "data_value",
                "iVar2": "comparison_result",
                "pcVar3": "result",
                "plVar4": "data_pointer",
                "pcVar5": "error_message",
                "sVar6": "string_length",
                "__ptr": "allocated_pointer",
                "lVar7": "arglist_value",
                "local_40": "local_array"
            },
            "code": "\n\n\nchar * extractAndInitializeData_0010b0fa(undefined8 source_param,undefined8 destination_param,uint *data_array,long binary_data,\n                   undefined *error_flag)\n\n{\n  uint data_value;\n  int comparison_result;\n  char *result;\n  long *data_pointer;\n  char *error_message;\n  size_t string_length;\n  void *allocated_pointer;\n  long arglist_value;\n  undefined local_array [16];\n  \n  if (error_flag != (undefined *)0x0) {\n    *error_flag = 0;\n  }\n  while( true ) {\n    data_value = *data_array;\n    if (0x29 < data_value) break;\n    if (0x17 < data_value) {\n      switch(data_value) {\n      case 0x18:\n        goto switchD_0010b158_caseD_18;\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x22:\n      case 0x23:\n        result = (char *)extractAndInitializeData_0010b0fa(source_param,destination_param,*(undefined8 *)(data_array + 4),0,0);\n        if (result != (char *)0x0) {\n          switch(*data_array) {\n          case 0x19:\n            goto switchD_0010b2de_caseD_19;\n          case 0x1a:\n            result = (char *)initialize_data_00113b4a(result);\n            return result;\n          case 0x1b:\n            result = (char *)initialize_data_00113b71(result);\n            return result;\n          default:\n                    \n            abort();\n          case 0x22:\n            result = (char *)initialize_data_00113d3a(result);\n            return result;\n          case 0x23:\n            result = (char *)initialize_data_00113cb9(result);\n            return result;\n          }\n        }\n        goto LAB_0010b38c;\n      case 0x27:\n        result = (char *)cplus_demangle_print(3,data_array,0x14,local_array);\n        if (result == (char *)0x0) {\n          error_message = \"Couldn\\'t get demangled builtin type\\n\";\n          result = (char *)0x0;\n          goto LAB_0010b3d3;\n        }\n        comparison_result = strcmp(result,\"signed char\");\n        if (comparison_result == 0) {\nLAB_0010b406:\n          error_message = (char *)update_data_00113dfe(1,0);\n          goto LAB_0010b6c6;\n        }\n        comparison_result = strcmp(result,\"bool\");\n        if (comparison_result == 0) {\n          error_message = (char *)initialize_data_00112904(6,1);\n          goto LAB_0010b6c6;\n        }\n        comparison_result = strcmp(result,\"char\");\n        if (comparison_result == 0) goto LAB_0010b406;\n        comparison_result = strcmp(result,\"double\");\n        if ((comparison_result == 0) || (comparison_result = strcmp(result,\"long double\"), comparison_result == 0)) {\n          error_message = (char *)initialize_data_00113df2(8);\n          goto LAB_0010b6c6;\n        }\n        comparison_result = strcmp(result,\"float\");\n        if (comparison_result == 0) {\n          error_message = (char *)initialize_data_00113df2(4);\n          goto LAB_0010b6c6;\n        }\n        comparison_result = strcmp(result,\"__float128\");\n        if (comparison_result == 0) {\n          error_message = (char *)initialize_data_00113df2(0x10);\n          goto LAB_0010b6c6;\n        }\n        comparison_result = strcmp(result,\"unsigned char\");\n        if (comparison_result == 0) {\n          error_message = (char *)update_data_00113dfe(1,1);\n          goto LAB_0010b6c6;\n        }\n        comparison_result = strcmp(result,\"int\");\n        if (comparison_result == 0) {\nLAB_0010b504:\n          error_message = (char *)update_data_00113dfe(4,0);\n          goto LAB_0010b6c6;\n        }\n        comparison_result = strcmp(result,\"unsigned int\");\n        if (comparison_result == 0) {\nLAB_0010b528:\n          error_message = (char *)update_data_00113dfe(4,1);\n          goto LAB_0010b6c6;\n        }\n        comparison_result = strcmp(result,\"long\");\n        if (comparison_result == 0) goto LAB_0010b504;\n        comparison_result = strcmp(result,\"unsigned long\");\n        if (comparison_result == 0) goto LAB_0010b528;\n        comparison_result = strcmp(result,\"__int128\");\n        if (comparison_result == 0) {\n          error_message = (char *)update_data_00113dfe(0x10,0);\n          goto LAB_0010b6c6;\n        }\n        comparison_result = strcmp(result,\"unsigned __int128\");\n        if (comparison_result == 0) {\n          error_message = (char *)update_data_00113dfe(0x10,1);\n          goto LAB_0010b6c6;\n        }\n        comparison_result = strcmp(result,\"short\");\n        if (comparison_result == 0) {\n          error_message = (char *)update_data_00113dfe(2,0);\n          goto LAB_0010b6c6;\n        }\n        comparison_result = strcmp(result,\"unsigned short\");\n        if (comparison_result == 0) {\n          error_message = (char *)update_data_00113dfe(2,1);\n          goto LAB_0010b6c6;\n        }\n        comparison_result = strcmp(result,\"void\");\n        if (comparison_result == 0) {\n          error_message = (char *)initialize_data_00113e17();\n          goto LAB_0010b6c6;\n        }\n        comparison_result = strcmp(result,\"wchar_t\");\n        if (comparison_result == 0) goto LAB_0010b528;\n        comparison_result = strcmp(result,\"long long\");\n        if (comparison_result == 0) {\n          error_message = (char *)update_data_00113dfe(8,0);\n          goto LAB_0010b6c6;\n        }\n        comparison_result = strcmp(result,\"unsigned long long\");\n        if (comparison_result == 0) {\n          error_message = (char *)update_data_00113dfe(8,1);\n          goto LAB_0010b6c6;\n        }\n        comparison_result = strcmp(result,\"...\");\n        if (comparison_result == 0) {\n          error_message = \"Unexpected demangled varargs\\n\";\n          if (error_flag == (undefined *)0x0) goto LAB_0010b6a9;\n          *error_flag = 1;\n        }\n        else {\n          error_message = \"Unrecognized demangled builtin type\\n\";\nLAB_0010b6a9:\n          error_message = (char *)dcgettext(0,error_message,5);\n          fprintf(_stderr,error_message);\n        }\n        error_message = (char *)0x0;\nLAB_0010b6c6:\n        free(result);\n        return error_message;\n      case 0x29:\n        if (*(long *)(data_array + 4) == 0) {\n          allocated_pointer = (void *)initialize_data_00113e17();\n        }\n        else {\n          allocated_pointer = (void *)extractAndInitializeData_0010b0fa(source_param,destination_param,*(long *)(data_array + 4),0,0);\n        }\n        if (allocated_pointer != (void *)0x0) {\n          arglist_value = extract_arglist_demangled_values_0010b6ea(source_param,destination_param,*(undefined8 *)(data_array + 6),local_array);\n          if (arglist_value != 0) {\n            result = (char *)initialize_and_store_data_00113ce0(allocated_pointer,arglist_value,local_array[0]);\n            return result;\n          }\n          free(allocated_pointer);\n        }\n        goto LAB_0010b38c;\n      }\n      break;\n    }\n    if (data_value != 1) {\n      if (data_value == 4) {\n        result = (char *)cplus_demangle_print(3,data_array,0x14,local_array);\n        error_message = \"Failed to print demangled template\\n\";\n        if (result != (char *)0x0) {\n          string_length = strlen(result);\n          error_message = (char *)find_match_and_free_0010afd5(source_param,destination_param,result,string_length & 0xffffffff,9);\n          free(result);\n          return error_message;\n        }\nLAB_0010b3d3:\n        error_message = (char *)dcgettext(0,error_message,5);\n        fprintf(_stderr,error_message);\n        return result;\n      }\n      if (data_value == 0) {\n        if ((binary_data == 0) || (data_pointer = (long *)extract_data_from_binary_00113b1e(binary_data), data_pointer == (long *)0x0))\n        goto switchD_0010b158_caseD_18;\n        goto LAB_0010b1a5;\n      }\n      break;\n    }\n    binary_data = extractAndInitializeData_0010b0fa(source_param,destination_param,*(undefined8 *)(data_array + 4),binary_data,0);\n    if (binary_data == 0) goto LAB_0010b38c;\n    data_array = *(uint **)(data_array + 6);\n    error_flag = (undefined *)0x0;\n  }\n  result = (char *)dcgettext(0,\"Unrecognized demangle component %d\\n\",5);\n  fprintf(_stderr,result,(ulong)data_value);\nLAB_0010b38c:\n  result = (char *)0x0;\nswitchD_0010b2de_caseD_19:\n  return result;\nLAB_0010b1a5:\n  if (*data_pointer == 0) {\nswitchD_0010b158_caseD_18:\n    result = (char *)find_match_and_free_0010afd5(source_param,destination_param,*(undefined8 *)(data_array + 4),data_array[6],0);\n    return result;\n  }\n  result = *(char **)(*data_pointer + 8);\n  if (result == (char *)0x0) goto LAB_0010b38c;\n  error_message = (char *)extract_data_from_binary_001129f4(result);\n  if (error_message != (char *)0x0) {\n    string_length = strlen(error_message);\n    if ((data_array[6] == (uint)string_length) &&\n       (comparison_result = strncmp(error_message,*(char **)(data_array + 4),(long)(int)data_array[6]), comparison_result == 0)) {\n      return result;\n    }\n  }\n  data_pointer = data_pointer + 1;\n  goto LAB_0010b1a5;\n}\n\n",
            "called": [
                "strcmp",
                "abort",
                "FUN_00113d3a",
                "strlen",
                "fprintf",
                "FUN_001129f4",
                "dcgettext",
                "FUN_00113ce0",
                "FUN_00113b71",
                "cplus_demangle_print",
                "FUN_00113b4a",
                "FUN_0010b6ea",
                "strncmp",
                "FUN_00113b1e",
                "free",
                "FUN_0010b0fa",
                "FUN_0010afd5",
                "FUN_00113df2",
                "FUN_00113dfe",
                "FUN_00113e17",
                "FUN_00113cb9",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010b0fa",
            "calling": [
                "FUN_0010b6ea",
                "FUN_0010b0fa"
            ],
            "imported": false,
            "current_name": "extract_and_initialize_data_0010b0fa"
        },
        "FUN_00104c36": {
            "renaming": {
                "FUN_00104c36": "parse_input_lines_00104c36",
                "uVar1": "errorMsg",
                "ppbVar2": "slotPtr",
                "pbVar3": "tempPtr",
                "in_CL": "currentChar",
                "bVar4": "nextChar",
                "unaff_RBX": "linePtr",
                "unaff_EBP": "lineCount",
                "pbVar5": "tempPtr2",
                "unaff_R13": "savedR13",
                "unaff_R14": "tempPtr3",
                "unaff_R15": "tempPtr4",
                "in_stack_00000008": "formatStr",
                "in_stack_00000010": "savedR13Ptr"
            },
            "code": "\nvoid parseInputLines_00104c36(void)\n\n{\n  undefined8 errorMsg;\n  byte **slotPtr;\n  byte *tempPtr;\n  byte currentChar;\n  byte nextChar;\n  byte *linePtr;\n  int lineCount;\n  byte *tempPtr2;\n  undefined8 savedR13;\n  byte *tempPtr3;\n  byte *tempPtr4;\n  undefined8 formatStr;\n  undefined8 *savedR13Ptr;\n  \n  do {\n    tempPtr2 = tempPtr4;\n    if (currentChar == 9) goto LAB_00104c3f;\n    do {\n      if ((currentChar == 10) || (currentChar == 0xd)) goto LAB_00114676;\n      if (currentChar == 0) goto LAB_00114599;\n      currentChar = tempPtr2[1];\n      tempPtr2 = tempPtr2 + 1;\n    } while ((currentChar != 0x20) && (currentChar != 9));\n    if ((char)currentChar < '\\x0e') {\nLAB_00114676:\n      if ((-0x2402L >> (currentChar & 0x3f) & 1U) != 0) goto LAB_001145e6;\n    }\n    else {\nLAB_001145e6:\n      nextChar = tempPtr2[1];\n      if ((((((nextChar == 9) || (nextChar == 0x20)) &&\n            ((nextChar = tempPtr2[2], nextChar == 9 || (nextChar == 0x20)))) &&\n           ((nextChar = tempPtr2[3], nextChar == 9 || (nextChar == 0x20)))) &&\n          ((nextChar = tempPtr2[4], nextChar == 9 || (nextChar == 0x20)))) &&\n         ((nextChar = tempPtr2[5], nextChar == 9 || (nextChar == 0x20)))) {\n        nextChar = tempPtr2[6];\n        tempPtr = tempPtr2 + 6;\n        if ((nextChar == 9) || (nextChar == 0x20)) {\n          do {\n            do {\n              nextChar = tempPtr[1];\n              tempPtr = tempPtr + 1;\n            } while (nextChar == 0x20);\n          } while (nextChar == 9);\n        }\n      }\n      if ((0xd < nextChar) || ((-0x2402L >> (nextChar & 0x3f) & 1U) != 0)) {\n        errorMsg = dcgettext(0,\"%s:%d: Ignoring rubbish found on this line\",5);\n        print_error_message_00119ed0(errorMsg,formatStr,lineCount);\n      }\n    }\nLAB_00114599:\n    *tempPtr2 = 0;\n    if (tempPtr4 < tempPtr2) {\n      slotPtr = (byte **)htab_find_slot();\n      *slotPtr = tempPtr4;\n    }\n    lineCount = lineCount + 1;\n    tempPtr2 = linePtr;\n    if (tempPtr3[1] == 0) {\n      *savedR13Ptr = savedR13;\n      return;\n    }\n    for (; nextChar = *tempPtr2, tempPtr3 = tempPtr2, nextChar != 10; tempPtr2 = tempPtr2 + 1) {\n      if ((char)nextChar < '\\v') {\n        if (nextChar == 0) {\n          tempPtr = tempPtr2 + 1;\n          goto LAB_00114553;\n        }\n      }\n      else {\n        if (nextChar == 0xd) {\n          *tempPtr2 = 0;\n          tempPtr = tempPtr2 + 1;\n          if (tempPtr2[1] == 10) {\n            tempPtr = tempPtr2 + 2;\n            tempPtr3 = tempPtr2 + 1;\n          }\n          goto LAB_00114553;\n        }\n        if (nextChar == 0x23) {\n          FUN_00104d1c();\n          return;\n        }\n      }\n    }\n    *tempPtr2 = 0;\n    if (tempPtr2[1] == 0xd) {\n      tempPtr3 = tempPtr2 + 1;\n      tempPtr = tempPtr2 + 2;\n    }\n    else {\n      tempPtr = tempPtr2 + 1;\n    }\nLAB_00114553:\n    currentChar = *linePtr;\n    tempPtr4 = linePtr;\n    while (linePtr = tempPtr, currentChar == 0x20) {\nLAB_00104c3f:\n      tempPtr2 = tempPtr4 + 1;\n      tempPtr4 = tempPtr4 + 1;\n      tempPtr = linePtr;\n      currentChar = *tempPtr2;\n    }\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104c36",
            "calling": [
                "FUN_00104cc1"
            ],
            "imported": false,
            "current_name": "parse_input_lines_00104c36"
        },
        "FUN_0010554f": {
            "renaming": {
                "FUN_0010554f": "process_debug_info_0010554f",
                "param_7": "binary",
                "param_8": "numSections",
                "param_12": "sectionSize",
                "param_14": "sectionContent",
                "param_17": "sectionList",
                "param_21": "alternativeMachineCode"
            },
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\n\nundefined4 processDebugInfo_0010554f(void)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  code *pcVar3;\n  undefined8 *puVar4;\n  undefined uVar5;\n  ushort uVar6;\n  char cVar7;\n  char cVar8;\n  undefined4 uVar9;\n  int iVar10;\n  int iVar11;\n  uint uVar12;\n  uint uVar13;\n  long lVar14;\n  long *plVar15;\n  undefined8 uVar16;\n  undefined *__ptr;\n  undefined8 uVar17;\n  size_t sVar18;\n  size_t sVar19;\n  long *__dest;\n  long *plVar20;\n  void *__ptr_00;\n  void *__ptr_01;\n  ulong uVar21;\n  char *__s;\n  char *pcVar22;\n  long lVar23;\n  ulong uVar24;\n  long *plVar25;\n  undefined8 *puVar26;\n  int iVar27;\n  long *plVar28;\n  ulong uVar29;\n  ulong *puVar30;\n  char *pcVar31;\n  undefined4 *puVar32;\n  undefined *puVar33;\n  long *in_R10;\n  char **ppcVar34;\n  void *pvVar35;\n  undefined8 *unaff_R14;\n  undefined **ppuVar36;\n  long lVar37;\n  bool bVar38;\n  byte bVar39;\n  long binary;\n  ulong numSections;\n  char param_9;\n  undefined4 *__ptr_02;\n  ulong sectionSize;\n  char *param_13;\n  undefined *sectionContent;\n  uint param_15;\n  long *sectionList;\n  undefined8 in_stack_00000068;\n  undefined8 alternativeMachineCode;\n  long param_23;\n  char *param_24;\n  long param_26;\n  long *param_30;\n  ulong param_31;\n  long param_32;\n  long in_stack_000000d8;\n  void *param_33;\n  long param_34;\n  undefined8 in_stack_000000f8;\n  byte param_36;\n  byte param_37;\n  undefined8 param_38;\n  ushort param_39;\n  long *param_40;\n  char param_41;\n  char *param_42;\n  undefined param_43;\n  short param_44;\n  \n  bVar39 = 0;\n  if ((DAT_00127978 == '\\0') && (DAT_00127969 == '\\0')) {\n    sectionSize = 0;\n    sectionContent = (undefined *)0x0;\n    sectionList = (long *)0x0;\n    uVar29 = sectionSize;\n  }\n  else {\n    lVar14 = (ulong)in_stack_00000068._4_4_ * 8;\n    sectionList = (long *)xmalloc(lVar14);\n    param_40 = sectionList;\n    bfd_map_over_sections(binary,assign_param_and_increment_0010870e,&stack0x00000140);\n    qsort(sectionList,(ulong)in_stack_00000068._4_4_,8,compare_records_0010875d);\n    sectionContent = (undefined *)xmalloc(lVar14);\n    bVar38 = DAT_00127978 != '\\0';\n    puVar33 = sectionContent;\n    for (; lVar14 != 0; lVar14 = lVar14 + -1) {\n      *puVar33 = 0;\n      puVar33 = puVar33 + (ulong)bVar39 * -2 + 1;\n    }\n    if (bVar38) {\n      uVar29 = 0;\n      sectionSize = 0;\n      do {\n        puVar30 = (ulong *)(sectionContent + uVar29 * 8);\n        plVar28 = sectionList + uVar29;\n        uVar21 = sectionSize;\n        do {\n          sectionSize = uVar21;\n          if (in_stack_00000068._4_4_ - 1 <= (uint)uVar29) goto LAB_00107cd1;\n          uVar29 = (ulong)((uint)uVar29 + 1);\n          uVar12 = bfd_octets_per_byte(binary,*plVar28);\n          uVar13 = bfd_octets_per_byte(binary);\n          lVar14 = *plVar28;\n          if ((*(uint *)(lVar14 + 0x24) & 0x102) != 0x102) break;\n          uVar21 = (ulong)uVar13 * *(long *)(plVar28[1] + 0x38);\n          uVar24 = (ulong)uVar12 * *(long *)(lVar14 + 0x38) + *(long *)(lVar14 + 0x40);\n          if (uVar21 <= uVar24) break;\n          uVar21 = uVar21 - uVar24;\n          cVar7 = bfd_set_section_size();\n          if (cVar7 == '\\0') {\n            dcgettext(0,\"Can\\'t fill gap after section\",5);\n            display_error_001126c0(0,binary,*plVar28);\n            DAT_00127a20 = 1;\n            goto LAB_00107cd1;\n          }\n          *puVar30 = uVar21;\n          plVar28 = plVar28 + 1;\n          puVar30 = puVar30 + 1;\n        } while (sectionSize < uVar21);\n      } while( true );\n    }\n    sectionSize = 0;\nLAB_00107cd1:\n    uVar29 = sectionSize;\n    if (DAT_00127969 != '\\0') {\n      uVar12 = bfd_octets_per_byte(binary);\n      lVar14 = sectionList[in_stack_00000068._4_4_ - 1];\n      uVar21 = DAT_00127970 * (ulong)uVar12;\n      uVar24 = *(long *)(lVar14 + 0x40) + (ulong)uVar12 * *(long *)(lVar14 + 0x38);\n      if (uVar24 < uVar21) {\n        cVar7 = bfd_set_section_size();\n        if (cVar7 == '\\0') {\n          dcgettext(0,\"can\\'t add padding\",5);\n          display_error_001126c0(0,binary,sectionList[in_stack_00000068._4_4_ - 1]);\n          DAT_00127a20 = 1;\n        }\n        else {\n          uVar29 = uVar21 - uVar24;\n          *(ulong *)(sectionContent + (ulong)(in_stack_00000068._4_4_ - 1) * 8) = uVar29;\n          if (uVar29 <= sectionSize) {\n            uVar29 = sectionSize;\n          }\n        }\n      }\n    }\n  }\n  sectionSize = uVar29;\n  plVar28 = DAT_001278b0;\n  if (DAT_00127980 == '\\0') {\nLAB_00105588:\n    __ptr_02 = (undefined4 *)0x0;\n  }\n  else {\n    ppuVar36 = &PTR_s__stab_00125c60;\n    __ptr_02 = (undefined4 *)xmalloc(0x60);\n    puVar32 = __ptr_02;\n    for (lVar14 = 0x18; lVar14 != 0; lVar14 = lVar14 + -1) {\n      *puVar32 = 0;\n      puVar32 = puVar32 + (ulong)bVar39 * -2 + 1;\n    }\n    param_13 = (char *)0x0;\n    do {\n      puVar33 = *ppuVar36;\n      lVar14 = bfd_get_section_by_name(unaff_R14,puVar33);\n      lVar37 = bfd_get_section_by_name();\n      if ((lVar14 != 0) && (lVar37 != 0)) {\n        lVar23 = *(long *)(lVar14 + 0x40);\n        __ptr_00 = (void *)xmalloc(lVar23);\n        cVar7 = bfd_get_section_contents(unaff_R14,lVar14,__ptr_00,0,lVar23);\n        if (cVar7 == '\\0') {\n          uVar9 = bfd_get_error();\n          bfd_errmsg(uVar9);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n          free(param_13);\n          free(__ptr_00);\n        }\n        else {\n          uVar29 = *(ulong *)(lVar37 + 0x40);\n          __ptr_01 = (void *)xmalloc(uVar29 + 1);\n          param_9 = bfd_get_section_contents(unaff_R14,lVar37,__ptr_01,0);\n          if (param_9 == '\\0') {\n            uVar9 = bfd_get_error();\n            bfd_errmsg(uVar9);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n            free(param_13);\n          }\n          else {\n            *(undefined *)((long)__ptr_01 + uVar29) = 0;\n            if ((param_13 != (char *)0x0) ||\n               (param_13 = (char *)initialize_data_structure_00112894(unaff_R14,1,plVar28), param_13 != (char *)0x0)) {\n              param_26 = 0;\n              param_23 = 0;\n              for (pvVar35 = __ptr_00; pvVar35 <= (void *)((long)__ptr_00 + lVar23 + -0xc);\n                  pvVar35 = (void *)((long)pvVar35 + 0xc)) {\n                uVar21 = (**(code **)(unaff_R14[1] + 0x40))(pvVar35);\n                bVar2 = *(byte *)((long)pvVar35 + 4);\n                uVar9 = (**(code **)(unaff_R14[1] + 0x58))((long)pvVar35 + 6);\n                lVar14 = (**(code **)(unaff_R14[1] + 0x40))((long)pvVar35 + 8);\n                if (bVar2 == 0) {\n                  param_23 = param_26;\n                  param_26 = param_26 + lVar14;\n                }\n                else {\n                  uVar24 = (uVar21 & 0xffffffff) + param_23;\n                  if (uVar24 < uVar29) {\n                    pcVar31 = (char *)((long)__ptr_01 + uVar24);\n                    param_24 = (char *)0x0;\n                    while( true ) {\n                      sVar18 = strlen(pcVar31);\n                      if (((sVar18 == 0) || (pcVar22 = pcVar31 + (sVar18 - 1), *pcVar22 != '\\')) ||\n                         ((ulong)((long)__ptr_00 + lVar23) < (long)pvVar35 + 0x10U))\n                      goto LAB_001077fb;\n                      *pcVar22 = '\\0';\n                      pvVar35 = (void *)((long)pvVar35 + 0xc);\n                      iVar10 = (**(code **)(unaff_R14[1] + 0x40))(pvVar35);\n                      uVar21 = (ulong)(uint)(iVar10 + (int)param_23);\n                      if (uVar29 <= uVar21) break;\n                      pcVar31 = (char *)concat(pcVar31,(long)__ptr_01 + uVar21,0);\n                      *pcVar22 = '\\';\n                      free(param_24);\n                      param_24 = pcVar31;\n                    }\n                    uVar17 = *unaff_R14;\n                    pcVar22 = (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar22,uVar17,puVar33,((long)pvVar35 - (long)__ptr_00) / 0xc);\nLAB_001077fb:\n                    update_data_entry_001088ae((ulong)bVar2,uVar9,lVar14,pcVar31);\n                    cVar7 = process_debug_info_0011173a(__ptr_02,param_13,bVar2);\n                    if (cVar7 == '\\0') {\n                      print_stab_entries_00108b3e();\n                      free_memory_and_reset_00108863();\n                      free(param_24);\n                      free(param_13);\n                      free(__ptr_00);\n                      free(__ptr_01);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar17 = *unaff_R14;\n                    pcVar31 = (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar31,uVar17,puVar33,((long)pvVar35 - (long)__ptr_00) / 0xc,\n                            uVar21 & 0xffffffff,(ulong)bVar2,((long)pvVar35 - (long)__ptr_00) % 0xc)\n                    ;\n                  }\n                }\n              }\n              free_memory_and_reset_00108863();\n              free(__ptr_00);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_01);\n          free(__ptr_00);\n        }\n        goto LAB_00105981;\n      }\nLAB_001058eb:\n      ppuVar36 = ppuVar36 + 2;\n    } while (ppuVar36 != (undefined **)&DAT_00125c90);\n    if ((param_13 != (char *)0x0) && (cVar7 = process_debug_info_0010c892(), cVar7 == '\\0')) {\nLAB_00105981:\n      free(__ptr_02);\n      goto LAB_00105588;\n    }\n    if (*(int *)(unaff_R14[1] + 8) == 1) {\n      lVar14 = 0;\n      for (plVar15 = plVar28; plVar15 < plVar28 + numSections; plVar15 = plVar15 + 1) {\n        (**(code **)(unaff_R14[1] + 0x218))(unaff_R14,*plVar15,&stack0x00000140);\n        if (param_41 == '-') {\n          if (((lVar14 == 0) && (lVar14 = initialize_data_structure_00112894(unaff_R14,0,plVar28), lVar14 == 0)) ||\n             ((param_42 == (char *)0x0 || (*param_42 == '\\0')))) goto LAB_00105981;\n          pcVar31 = (char *)0x0;\n          pcVar22 = param_42;\n          while (((*pcVar22 != '\\0' && (sVar18 = strlen(pcVar22), pcVar22[sVar18 - 1] == '\\')) &&\n                 (plVar15 + 1 < plVar28 + numSections))) {\n            __s = (char *)xstrdup(pcVar22);\n            sVar18 = strlen(__s);\n            __s[sVar18 - 1] = '\\0';\n            pcVar22 = (char *)concat(__s,*(undefined8 *)(plVar15[1] + 8),0);\n            free(__s);\n            free(pcVar31);\n            plVar15 = plVar15 + 1;\n            pcVar31 = pcVar22;\n          }\n          update_data_entry_001088ae(param_43,(int)param_44,param_40,pcVar22);\n          param_9 = process_debug_info_0011173a(__ptr_02,lVar14,param_43);\n          if (param_9 == '\\0') {\n            print_stab_entries_00108b3e();\n            free_memory_and_reset_00108863();\n            goto LAB_00105981;\n          }\n        }\n      }\n      free_memory_and_reset_00108863();\n      if ((lVar14 != 0) && (cVar7 = process_debug_info_0010c892(), cVar7 == '\\0')) goto LAB_00105981;\n    }\n    if (param_9 == '\\0') {\n      if ((*(int *)(unaff_R14[1] + 8) == 2) && (numSections != 0)) {\n        param_40 = (long *)0x0;\n        param_30 = plVar28;\n        param_32 = 0;\n        param_31 = numSections;\n        in_stack_000000d8 = 0;\n        puVar26 = (undefined8 *)&stack0x00000148;\n        for (lVar14 = 0x22; lVar14 != 0; lVar14 = lVar14 + -1) {\n          *(undefined4 *)puVar26 = 0;\n          puVar26 = (undefined8 *)((long)puVar26 + (ulong)bVar39 * -8 + 4);\n        }\n        cVar7 = '\\0';\n        _param_15 = (int *)0x0;\n        uVar12 = 0;\n        param_13 = (char *)0x0;\n        param_24 = (char *)0xffffffffffffffff;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((long)numSections <= param_32) goto LAB_00105590;\n            lVar14 = plVar28[param_32];\n            cVar8 = bfd_coff_get_syment(unaff_R14,lVar14,&stack0x000000e0);\n            lVar37 = in_stack_000000d8;\n            if (cVar8 == '\\0') {\n              uVar9 = bfd_get_error();\n              bfd_errmsg(uVar9);\n              pcVar31 = \"bfd_coff_get_syment failed: %s\";\n              goto LAB_00105968;\n            }\n            pcVar31 = *(char **)(lVar14 + 8);\n            puVar26 = (undefined8 *)0x0;\n            param_32 = param_32 + 1;\n            in_stack_000000d8 = (ulong)param_37 + 1 + in_stack_000000d8;\n            if (param_37 != 0) {\n              puVar26 = &stack0x00000110;\n              cVar8 = bfd_coff_get_auxent(unaff_R14,lVar14,0);\n              if (cVar8 == '\\0') {\n                uVar9 = bfd_get_error();\n                bfd_errmsg(uVar9);\n                pcVar31 = \"bfd_coff_get_auxent failed: %s\";\n                goto LAB_00105968;\n              }\n            }\n            if (param_24 != (char *)lVar37) break;\n            if (param_36 != 0x67) {\n              cVar8 = initialize_debug_info_0010bbd3(__ptr_02);\n              if (cVar8 != '\\0') break;\n              goto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            param_24 = (char *)param_34;\n            cVar8 = initialize_debug_info_0010bbd3(__ptr_02);\n            if (cVar8 == '\\0') goto LAB_00105981;\n          }\n          uVar6 = in_stack_000000f8._6_2_;\n          if ((char)param_36 < '\\0') {\n            if (param_36 == 0xff) goto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            lVar23 = parse_and_initialize_data_0010dac0(unaff_R14,&stack0x000000c0,&stack0x00000140);\n            if (lVar23 == 0) break;\n            cVar8 = process_parameter_00112a33(&stack0x00000140,lVar14,lVar37);\n          }\n          else {\n            if (param_36 < 100) {\n              switch(param_36) {\n              case 3:\n                if (in_stack_000000f8._6_2_ == 0) goto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulong)((uint)in_stack_000000f8._6_2_ & *(uint *)(unaff_R14[0x22] + 0x40)) !=\n                    2L << ((byte)*(undefined4 *)(unaff_R14[0x22] + 0x3c) & 0x3f)) goto LAB_0010700a;\n                _param_15 = (int *)(**(code **)(unaff_R14[1] + 0x238))(unaff_R14);\n                uVar12 = (uint)uVar6;\n                param_13 = pcVar31;\n                goto switchD_00106e1a_caseD_68;\n              default:\n                goto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                goto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(param_36) {\n            case 100:\n              iVar10 = strcmp(pcVar31,\".bb\");\n              if (iVar10 == 0) {\n                cVar8 = start_debug_block_0010be88(__ptr_02);\n              }\n              else {\n                iVar10 = strcmp(pcVar31,\".eb\");\n                if (iVar10 != 0) goto switchD_00106e1a_caseD_68;\n                cVar8 = debug_end_block_check_0010bf20(__ptr_02);\n              }\n              break;\n            case 0x65:\n              iVar10 = strcmp(pcVar31,\".bf\");\n              if (iVar10 == 0) {\n                if (param_13 != (char *)0x0) {\n                  uVar13 = (int)uVar12 >> ((byte)*(undefined4 *)(unaff_R14[0x22] + 0x44) & 0x1f);\n                  lVar37 = parse_and_initialize_data_0010dac0(unaff_R14,&stack0x000000c0,&stack0x00000140,lVar37,\n                                        uVar13 ^ (uVar12 ^ uVar13) &\n                                                 *(uint *)(unaff_R14[0x22] + 0x38),puVar26,0,\n                                        __ptr_02);\n                  if ((lVar37 == 0) || (cVar7 = initialize_debug_record_0010bc80(__ptr_02), cVar7 == '\\0'))\n                  goto LAB_00105981;\n                  if (_param_15 != (int *)0x0) {\n                    iVar10 = 0;\n                    if (param_37 != 0) {\n                      iVar10 = param_39 - 1;\n                    }\n                    lVar14 = *(long *)(*(long *)(lVar14 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar27 = _param_15[4];\n                      if (iVar27 == 0) break;\n                      cVar8 = record_line_info_0010bf86(__ptr_02,iVar10 + iVar27,\n                                           *(long *)(_param_15 + 6) + lVar14);\n                      _param_15 = _param_15 + 4;\n                      if (cVar8 == '\\0') goto LAB_00105981;\n                    }\n                  }\n                  uVar12 = 0;\n                  _param_15 = (int *)0x0;\n                  param_13 = (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar31 = \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar10 = strcmp(pcVar31,\".ef\");\n                if (iVar10 != 0) goto switchD_00106e1a_caseD_68;\n                if (cVar7 != '\\0') {\n                  cVar7 = end_debugging_function_0010be1a(__ptr_02);\n                  if (cVar7 == '\\0') goto LAB_00105981;\n                  cVar7 = '\\0';\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar31 = \"%ld: unexpected .ef\\n\";\n              }\n              uVar17 = dcgettext(0,pcVar31,5);\n              print_error_message_00119ed0(uVar17);\n              goto LAB_00105981;\n            default:\n              goto LAB_0010700a;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (cVar8 != '\\0');\n      }\n      else {\n        pcVar31 = \"%s: no recognized debugging information\";\nLAB_00105968:\n        uVar17 = dcgettext(0,pcVar31,5);\n        print_error_message_00119ed0(uVar17);\n      }\n      goto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)(binary + 0x44) & 0x42) != 0) && ((*(uint *)(binary + 0x44) & 1) == 0)) {\n    if ((*(char *)(*(long *)(binary + 8) + 0x20) == '\\0') && (DAT_00127939 == '\\0')) {\n      if (numSections != 0) {\n        plVar28 = DAT_001278b0 + numSections;\n        plVar15 = DAT_001278b0;\n        do {\n          uVar12 = *(uint *)(*plVar15 + 0x18);\n          if ((uVar12 & 0x1000000) != 0) {\n            *(uint *)(*plVar15 + 0x18) = uVar12 & 0xfeffffff;\n          }\n          plVar15 = plVar15 + 1;\n        } while (plVar28 != plVar15);\n      }\n    }\n    else {\n      for (lVar14 = *(long *)(binary + 0x90); lVar14 != 0; lVar14 = *(long *)(lVar14 + 8)) {\n        if (*(long *)(lVar14 + 0xe8) != 0) {\n          puVar1 = (uint *)(*(long *)(lVar14 + 0xe8) + 0x18);\n          *puVar1 = *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((DAT_00127a2c == 2) || (DAT_00127a2c == 7)) {\nLAB_001059fe:\n    if (DAT_00127a2c == 7) {\nLAB_00105a3b:\n      lVar14 = xmalloc();\n      plVar28 = DAT_001278b0;\n      param_15 = *(uint *)((long)unaff_R14 + 0x44) & 0x42;\n      DAT_001278a8 = lVar14;\n      if (numSections == 0) {\n        uVar29 = 0;\n      }\n      else {\n        uVar29 = 0;\n        _param_9 = 0;\n        do {\n          iVar10 = DAT_001279a0;\n          plVar15 = (long *)plVar28[_param_9];\n          pcVar3 = (code *)plVar15[4];\n          uVar12 = *(uint *)(plVar15 + 3);\n          plVar20 = (long *)plVar15[1];\n          plVar25 = plVar20;\n          if (DAT_001279a8 != (undefined8 *)0x0) {\n            iVar27 = 0;\n            puVar26 = DAT_001279a8;\n            while ((iVar27 < iVar10 && (pcVar31 = (char *)puVar26[5], pcVar31 != (char *)0x0))) {\n              if (pcVar31 != \"\") {\n                iVar11 = strcmp(pcVar31,(char *)plVar20);\n                if (iVar11 == 0) {\n                  free(pcVar31);\n                  uVar21 = uVar29 + 1;\n                  puVar26[5] = \"\";\n                  uVar16 = update_section_info_0011a2e0(puVar26);\n                  uVar17 = DAT_001278d0;\n                  *(undefined8 *)(lVar14 + uVar29 * 8) = uVar16;\n                  lVar37 = htab_elements(uVar17);\n                  if ((lVar37 != 0) || (DAT_001278d8 != (char **)0x0)) goto LAB_001064eb;\n                  goto LAB_00105af8;\n                }\n                puVar26 = (undefined8 *)*puVar26;\n              }\n              iVar27 = iVar27 + 1;\n            }\n          }\n          lVar37 = htab_elements(DAT_001278d0);\n          uVar21 = uVar29;\n          if ((lVar37 != 0) || (DAT_001278d8 != (char **)0x0)) {\n            if (plVar20 != (long *)0x0) {\nLAB_001064eb:\n              if (((*(char *)plVar20 == '_') && (*(char *)((long)plVar20 + 1) == '_')) &&\n                 (iVar10 = strcmp((char *)((ulong)(*(char *)((long)plVar20 + 2) == '_') +\n                                          (long)plVar20),\"__gnu_lto_slim\"), iVar10 == 0)) {\n                uVar17 = dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\"\n                                   ,5);\n                    \n                print_error_and_exit_00119dd0(uVar17);\n              }\n            }\n            _param_41 = 0;\n            param_40 = plVar20;\n            lVar37 = htab_find(DAT_001278d0);\n            if (((lVar37 == 0) || (plVar25 = *(long **)(lVar37 + 8), plVar20 == plVar25)) &&\n               (plVar25 = plVar20, ppcVar34 = DAT_001278d8, (uVar12 & 0x100) != 0)) {\n              for (; ppcVar34 != (char **)0x0; ppcVar34 = (char **)ppcVar34[3]) {\n                iVar10 = strcmp(*ppcVar34,(char *)plVar20);\n                if (iVar10 == 0) {\n                  plVar25 = (long *)ppcVar34[1];\n                  break;\n                }\n              }\n            }\n            plVar15[1] = (long)plVar25;\n            cVar7 = *(char *)plVar25;\n            if (cVar7 != '\\0') goto LAB_00105b11;\nLAB_00106557:\n            pcVar31 = DAT_00127908;\n            if ((DAT_00127988 != '\\0') && (*(char *)(*(long *)(binary + 8) + 0x1c) != '\\0')) {\n              lVar37 = unaff_R14[1];\n              cVar7 = '\\0';\n              goto LAB_0010668d;\n            }\n            goto joined_r0x00106565;\n          }\nLAB_00105af8:\n          cVar7 = *(char *)plVar20;\n          if (cVar7 == '\\0') goto LAB_00106557;\nLAB_00105b11:\n          pcVar31 = DAT_00127908;\n          lVar37 = unaff_R14[1];\n          if (*(char *)(lVar37 + 0x1c) == cVar7) {\n            if (DAT_00127988 == '\\0') {\n              if ((DAT_00127968 == '\\0') ||\n                 ((((uVar12 & 0x82) == 0 && (pcVar3 != bfd_map_over_sections)) &&\n                  ((*(byte *)(plVar15[4] + 0x25) & 0x10) == 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n              plVar25 = (long *)((long)plVar25 + 1);\n              plVar15[1] = (long)plVar25;\n              goto joined_r0x00106565;\n            }\n            cVar7 = *(char *)(*(long *)(binary + 8) + 0x1c);\n            if (cVar7 == '\\0') goto LAB_0010677d;\n            if (DAT_00127908 != (char *)0x0) {\n              plVar25 = (long *)((long)plVar25 + 1);\n              plVar15[1] = (long)plVar25;\n              sVar18 = strlen((char *)plVar25);\n              lVar37 = sVar18 + 2;\nLAB_001066bc:\n              sVar18 = strlen(pcVar31);\n              plVar20 = (long *)xmalloc(sVar18 + lVar37);\n              goto LAB_001066d0;\n            }\n            *(char *)plVar25 = cVar7;\n            plVar15[1] = (long)plVar25;\n            uVar29 = uVar21;\n          }\n          else {\n            if ((DAT_00127988 == '\\0') || (*(char *)(*(long *)(binary + 8) + 0x1c) == '\\0')) {\njoined_r0x00106565:\n              uVar29 = uVar21;\n              if (pcVar31 == (char *)0x0) goto LAB_00105b32;\n              sVar18 = strlen((char *)plVar25);\n              sVar19 = strlen(pcVar31);\n              __dest = (long *)xmalloc(sVar19 + sVar18 + 1);\n              plVar20 = __dest;\n            }\n            else {\nLAB_0010668d:\n              pcVar31 = DAT_00127908;\n              if ((*(char *)(lVar37 + 0x1c) != '\\0') && (cVar7 != *(char *)(lVar37 + 0x1c)))\n              goto joined_r0x00106565;\n              sVar18 = strlen((char *)plVar25);\n              lVar37 = sVar18 + 2;\n              if (pcVar31 != (char *)0x0) goto LAB_001066bc;\n              plVar20 = (long *)xmalloc(lVar37);\nLAB_001066d0:\n              __dest = (long *)((long)plVar20 + 1);\n              *(char *)plVar20 = *(char *)(*(long *)(binary + 8) + 0x1c);\n            }\n            pcVar31 = DAT_00127908;\n            if (DAT_00127908 != (char *)0x0) {\n              strcpy((char *)__dest,DAT_00127908);\n              sVar18 = strlen(pcVar31);\n              __dest = (long *)((long)__dest + sVar18);\n            }\n            strcpy((char *)__dest,(char *)plVar25);\n            plVar15[1] = (long)plVar20;\n            plVar25 = plVar20;\n            uVar29 = uVar21;\n          }\nLAB_00105b32:\n          if (DAT_00127a2c == 7) goto LAB_001067a8;\n          if (((uVar12 & 0x20) == 0) &&\n             (((uVar12 & 0x100) == 0 ||\n              ((*(byte *)(**(long **)(plVar15[4] + 0xf0) + 0x18) & 0x20) == 0)))) {\n            if (((param_15 == 0) &&\n                (((uVar12 & 0x82) != 0 || ((*(byte *)(plVar15[4] + 0x25) & 0x10) != 0)))) ||\n               (iVar10 = bfd_decode_symclass(plVar15), iVar10 == 0x49)) {\nLAB_00105be2:\n              if (DAT_001279ca == '\\0') {\n                lVar37 = htab_find();\n                if (lVar37 == 0) goto LAB_00105c07;\n              }\n              else {\n                _param_41 = _param_41 & 0xffffffffffffff00;\n                param_40 = plVar25;\n                htab_traverse(DAT_001279f8,pattern_match_0011a170,&stack0x00000140);\n                if (param_41 == '\\0') goto LAB_00105c07;\n              }\n            }\n            else if ((((uVar12 & 0x82) == 0) && (pcVar3 != bfd_map_over_sections)) &&\n                    ((*(byte *)(plVar15[4] + 0x25) & 0x10) == 0)) {\n              if ((uVar12 & 4) == 0) {\n                if (((*(int *)(unaff_R14[1] + 8) != 2) ||\n                    (lVar37 = *(long *)(plVar15[4] + 0xd0), lVar37 == 0)) ||\n                   (*(long *)(lVar37 + 0x40) == 0)) {\n                  if ((DAT_00127a2c == 3) || (DAT_00127a28 == 2)) goto LAB_001067a8;\n                  if (DAT_00127a28 == 1) {\n                    cVar7 = bfd_is_local_label(unaff_R14);\n                    goto joined_r0x00106a11;\n                  }\n                }\n                goto LAB_00105be2;\n              }\n              cVar7 = DAT_00127980;\n              if (1 < DAT_00127a2c - 2U) {\njoined_r0x00106a11:\n                if (cVar7 == '\\0') goto LAB_00105be2;\n              }\n            }\n            else if (DAT_00127a2c != 3) goto LAB_00105be2;\n            goto LAB_001067a8;\n          }\n          if (DAT_001279ca == '\\0') {\n            lVar37 = htab_find();\n            if (lVar37 != 0) {\nLAB_0010687f:\n              uVar17 = dcgettext(0,\"not stripping symbol `%s\\' because it is named in a relocation\",\n                                 5);\n              print_error_message_00119ed0(uVar17);\n              DAT_00127a20 = 1;\n            }\n          }\n          else {\n            _param_41 = _param_41 & 0xffffffffffffff00;\n            param_40 = plVar25;\n            htab_traverse(DAT_001279f8,pattern_match_0011a170,&stack0x00000140);\n            if (param_41 != '\\0') goto LAB_0010687f;\n          }\n          if ((uVar12 & 0x20) == 0) {\nLAB_00105c07:\n            if (DAT_001279ca != '\\0') {\n              _param_41 = _param_41 & 0xffffffffffffff00;\n              param_40 = plVar25;\n              htab_traverse(DAT_001279f0,pattern_match_0011a170,&stack0x00000140);\n              if (param_41 != '\\0') goto LAB_001067a8;\n              goto LAB_00105c2c;\n            }\n            lVar37 = htab_find();\n            if (lVar37 == 0) goto LAB_00105c2c;\nLAB_001067a8:\n            if ((DAT_00127a18 != '\\0') && ((uVar12 & 0x4000) != 0)) goto LAB_00105c2c;\n            if (DAT_001279ca == '\\0') {\n              lVar37 = htab_find();\n              if (lVar37 != 0) goto LAB_00105c2c;\n            }\n            else {\n              _param_41 = _param_41 & 0xffffffffffffff00;\n              param_40 = plVar25;\n              htab_traverse(DAT_00127a08,pattern_match_0011a170,&stack0x00000140);\n              if (param_41 != '\\0') goto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            cVar7 = process_section_data_001159d0(plVar15[4]);\n            if (cVar7 == '\\0') {\n              if (((uVar12 & 0x800002) == 0) && (pcVar3 != bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uVar12 & 0x82) != 0) {\n                  cVar7 = find_value_00115d70(plVar25);\n                  if ((cVar7 == '\\0') &&\n                     ((lVar37 = htab_elements(DAT_001279d8), lVar37 == 0 ||\n                      (cVar7 = find_value_00115d70(plVar25), cVar7 != '\\0')))) {\n                    if (((((DAT_00127938 == '\\0') ||\n                          (uVar13 = *(uint *)(plVar15 + 3), (uVar13 & 0x200000) != 0)) ||\n                         (lVar37 = *plVar15, lVar37 == 0)) ||\n                        ((*(int *)(*(long *)(lVar37 + 8) + 8) != 5 ||\n                         (*(long *)(lVar37 + 0x110) == 0)))) ||\n                       (1 < (*(byte *)((long)plVar15 + 0x49) & 3) - 1)) goto joined_r0x00106920;\n                  }\n                  else {\n                    uVar13 = *(uint *)(plVar15 + 3);\n                  }\n                  *(uint *)(plVar15 + 3) = uVar13 & 0xffffff7d | 1;\n                }\njoined_r0x00106920:\n                if (((uVar12 & 1) != 0) && (cVar7 = find_value_00115d70(plVar25), cVar7 != '\\0')) {\n                  *(uint *)(plVar15 + 3) = *(uint *)(plVar15 + 3) & 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((DAT_001279c8 != '\\0') || (cVar7 = find_value_00115d70(plVar25), cVar7 != '\\0')) {\n                  *(uint *)(plVar15 + 3) = *(uint *)(plVar15 + 3) & 0xff7ffffd | 0x80;\n                }\n                if (pcVar3 != bfd_map_over_sections) goto LAB_00105c5f;\n              }\n              *(long **)(lVar14 + uVar29 * 8) = plVar15;\n              uVar29 = uVar29 + 1;\n            }\n          }\n          _param_9 = _param_9 + 1;\n        } while (numSections != _param_9);\n      }\n      if (DAT_001279a8 != (undefined8 *)0x0) {\n        puVar26 = DAT_001279a8;\n        iVar10 = DAT_001279a0;\n        for (lVar37 = 0; lVar37 < iVar10; lVar37 = lVar37 + 1) {\n          pcVar31 = (char *)puVar26[5];\n          if (pcVar31 == (char *)0x0) {\n            lVar23 = uVar29 * 8;\n            uVar29 = uVar29 + 1;\n            uVar17 = update_section_info_0011a2e0(puVar26,binary);\n            *(undefined8 *)(lVar14 + lVar23) = uVar17;\n            iVar10 = DAT_001279a0;\n          }\n          else if (pcVar31 != \"\") {\n            uVar17 = dcgettext(0,\"\\'before=%s\\' not found\",5);\n                    \n            print_error_and_exit_00119dd0(uVar17,pcVar31);\n          }\n          puVar26 = (undefined8 *)*puVar26;\n        }\n      }\n      bVar38 = DAT_00127980 == '\\0';\n      *(undefined8 *)(lVar14 + uVar29 * 8) = 0;\n      if ((bVar38) || (__ptr_02 == (undefined4 *)0x0)) {\nLAB_00105cfa:\n        numSections = uVar29 & 0xffffffff;\n        goto LAB_00105710;\n      }\n      iVar10 = *(int *)(*(undefined8 **)(binary + 8) + 1);\n      if ((iVar10 == 5) || (iVar10 == 2)) {\n        param_33 = (void *)0x0;\n        cVar7 = extract_binary_data_0011378f(binary,__ptr_02,&stack0x000000c0,&stack0x00000110,&stack0x000000e0,\n                             &stack0x00000140);\n        if (cVar7 != '\\0') {\n          lVar14 = bfd_make_section_with_flags(binary,\".stab\",0x2108);\n          lVar37 = bfd_make_section_with_flags(binary,\".stabstr\",0x2108);\n          if ((((lVar14 == 0) || (lVar37 == 0)) ||\n              (cVar7 = bfd_set_section_size(lVar14,param_38), cVar7 == '\\0')) ||\n             (cVar7 = bfd_set_section_size(lVar37,param_40), cVar7 == '\\0')) {\n            pcVar31 = \"can\\'t create debugging section\";\n          }\n          else {\n            *(undefined4 *)(lVar14 + 0x7c) = 2;\n            *(undefined4 *)(lVar37 + 0x7c) = 0;\n            cVar7 = bfd_set_section_contents(binary,lVar14,param_30,0,param_38);\n            if ((cVar7 != '\\0') &&\n               (cVar7 = bfd_set_section_contents(binary,lVar37,param_33,0,param_40), cVar7 != '\\0')\n               ) {\n              free(__ptr_02);\n              goto LAB_00105cfa;\n            }\n            pcVar31 = \"can\\'t set debugging section contents\";\n          }\n          uVar17 = dcgettext(0,pcVar31,5);\n          display_error_001126c0(0,binary,0,uVar17);\n          free(param_33);\n          free(__ptr_02);\n          goto LAB_00105d96;\n        }\n      }\n      else {\n        uVar17 = **(undefined8 **)(binary + 8);\n        uVar16 = dcgettext(0,\"don\\'t know how to write debugging information for %s\",5);\n        display_error_001126c0(0,binary,0,uVar16,uVar17);\n      }\n      free(__ptr_02);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections(unaff_R14,process_reloc_table_00116030,DAT_001278b0);\n      iVar10 = bfd_get_error();\n      if (iVar10 == 0) goto LAB_00105a3b;\n    }\nLAB_00105d96:\n    DAT_00127a20 = 1;\n  }\n  else {\n    if ((DAT_00127a2c - 3U < 4) || ((DAT_00127a28 != 0 || (DAT_00127938 != '\\0'))))\n    goto LAB_00105a07;\n    lVar14 = htab_elements(DAT_001279f8);\n    if (((lVar14 != 0) ||\n        ((((lVar14 = htab_elements(DAT_00127a08), lVar14 != 0 ||\n           (lVar14 = htab_elements(DAT_001279e8), lVar14 != 0)) ||\n          (lVar14 = htab_elements(DAT_001279e0), lVar14 != 0)) ||\n         ((lVar14 = htab_elements(DAT_001279d8), lVar14 != 0 ||\n          (lVar14 = htab_elements(DAT_001279d0), lVar14 != 0)))))) ||\n       ((((lVar14 = htab_elements(DAT_001278d0), lVar14 != 0 ||\n          ((DAT_00127908 != (char *)0x0 || (DAT_001278b8 != '\\0')))) || (DAT_00127a19 != '\\0')) ||\n        ((((DAT_00127980 != '\\0' || (DAT_00127988 != '\\0')) || (DAT_00127968 != '\\0')) ||\n         (((DAT_001278d8 != (char **)0x0 || (DAT_001279c8 != '\\0')) || (DAT_001279a0 != 0))))))))\n    goto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(binary,DAT_001278a8,numSections & 0xffffffff);\n    bfd_map_over_sections(unaff_R14,process_section_data_00115dc0,binary);\n    bfd_map_over_sections(unaff_R14,reverse_section_contents_00116110,binary);\n    for (puVar26 = DAT_001279c0; puVar4 = DAT_001279b8, puVar26 != (undefined8 *)0x0;\n        puVar26 = (undefined8 *)*puVar26) {\n      cVar7 = bfd_set_section_contents(binary,puVar26[5],puVar26[4],0,puVar26[3]);\n      if (cVar7 == '\\0') {\n        display_error_001126c0(0,binary,puVar26[5],0);\n        return 0;\n      }\n    }\n    for (; puVar4 != (undefined8 *)0x0; puVar4 = (undefined8 *)*puVar4) {\n      uVar17 = *(undefined8 *)(puVar4[5] + 0x60);\n      cVar7 = bfd_set_section_contents(binary,uVar17,puVar4[4],0,puVar4[3]);\n      if (cVar7 == '\\0') {\n        display_error_001126c0(0,binary,uVar17,0);\n        return 0;\n      }\n    }\n    if (in_R10 == (long *)0x0) {\n      if ((DAT_00127a00 != '\\0') && (_DAT_00127a24 == 0)) {\n        uVar17 = *unaff_R14;\n        uVar16 = dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n        print_error_message_00119ed0(uVar16,uVar17);\n      }\n    }\n    else {\n      plVar28 = (long *)0x0;\n      for (puVar26 = *(undefined8 **)(binary + 0x90); puVar26 != (undefined8 *)0x0;\n          puVar26 = (undefined8 *)puVar26[1]) {\n        if (((DAT_00127a00 != '\\0') && (*(int *)(*(long *)(binary + 8) + 8) == 5)) &&\n           ((*(int *)(puVar26[0x1a] + 4) == 7 &&\n            (cVar7 = compare_strings_00113fb0(*puVar26,\".gnu.build.attributes\"), cVar7 != '\\0')))) {\n          if (plVar28 == (long *)0x0) {\n            plVar28 = in_R10;\n          }\n          plVar15 = in_R10;\n          if (*(undefined8 **)(*plVar28 + 0x60) == puVar26) {\nLAB_0010625f:\n            pcVar31 = \"error: failed to merge notes\";\n            if (plVar28[1] != 0) {\n              cVar7 = bfd_set_section_contents(binary,puVar26,plVar28[1],0,plVar28[2]);\n              if (cVar7 == '\\0') {\n                uVar17 = dcgettext(0,\"error: failed to copy merged notes into output\",5);\n                display_error_001126c0(0,binary,puVar26,uVar17);\n                return 0;\n              }\n              plVar28 = (long *)plVar28[3];\n              goto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              plVar28 = plVar15;\n              if (*(undefined8 **)(*plVar15 + 0x60) == puVar26) goto LAB_0010625f;\n              plVar28 = (long *)plVar15[3];\n              plVar15 = plVar28;\n            } while (plVar28 != (long *)0x0);\n            pcVar31 = \"error: failed to locate merged notes\";\n          }\n          uVar17 = dcgettext(0,pcVar31,5);\n          display_error_001126c0(0,binary,puVar26,uVar17);\n        }\nLAB_001061be:\n      }\n      do {\n        plVar28 = (long *)in_R10[3];\n        free((void *)in_R10[1]);\n        free(in_R10);\n        in_R10 = plVar28;\n      } while (plVar28 != (long *)0x0);\n    }\n    if ((DAT_00127a10 == 0) ||\n       (cVar7 = bfd_fill_in_gnu_debuglink_section(binary,alternativeMachineCode), lVar14 = DAT_00127a10,\n       cVar7 != '\\0')) {\n      if (sectionContent != (undefined *)0x0) {\n        if (0x2000 < sectionSize) {\n          sectionSize = 0x2000;\n        }\n        lVar14 = 0;\n        __ptr = (undefined *)xmalloc(sectionSize);\n        uVar5 = DAT_00127979;\n        puVar33 = __ptr;\n        for (sectionSize = sectionSize & 0xffffffff; sectionSize != 0; sectionSize = sectionSize - 1) {\n          *puVar33 = uVar5;\n          puVar33 = puVar33 + (ulong)bVar39 * -2 + 1;\n        }\n        for (; (uint)lVar14 < in_stack_00000068._4_4_; lVar14 = lVar14 + 1) {\n          uVar29 = *(ulong *)(sectionContent + lVar14 * 8);\n          if (uVar29 != 0) {\n            lVar37 = *(long *)(*sectionList + 0x40) - uVar29;\n            do {\n              uVar21 = 0x2000;\n              if (uVar29 < 0x2001) {\n                uVar21 = uVar29;\n              }\n              cVar7 = bfd_set_section_contents(binary,*sectionList,__ptr,lVar37,uVar21);\n              if (cVar7 == '\\0') {\n                display_error_001126c0(0,binary,*sectionList,0);\n                free(__ptr);\n                return 0;\n              }\n              lVar37 = lVar37 + uVar21;\n              uVar29 = uVar29 - uVar21;\n            } while (uVar29 != 0);\n          }\n          sectionList = sectionList + 1;\n        }\n        free(__ptr);\n        free(sectionContent);\n      }\n      uVar9 = (**(code **)(*(long *)(binary + 8) + 0x140))(unaff_R14);\n      if ((char)uVar9 != '\\0') {\n        if (DAT_00127910 == 0) {\n          return uVar9;\n        }\n        cVar7 = bfd_alt_mach_code(binary,DAT_00127910 & 0xffffffff);\n        uVar29 = DAT_00127910;\n        if (cVar7 == '\\0') {\n          uVar17 = dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n          print_error_message_00119ed0(uVar17,uVar29);\n          if (*(int *)(*(long *)(binary + 8) + 8) == 5) {\n            uVar17 = dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n            print_error_message_00119ed0(uVar17);\n            *(short *)(*(long *)(binary + 0x110) + 0x3a) = (short)DAT_00127910;\n            return uVar9;\n          }\n          uVar17 = dcgettext(0,\"ignoring the alternative value\",5);\n          print_error_message_00119ed0(uVar17);\n          return uVar9;\n        }\n        return uVar9;\n      }\n      uVar17 = dcgettext(0,\"error copying private BFD data\",5);\n      display_error_001126c0(0,binary,0,uVar17);\n    }\n    else {\n      uVar17 = dcgettext(0,\"cannot fill debug link section `%s\\'\",5);\n      display_error_001126c0(0,binary,0,uVar17,lVar14);\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "htab_find",
                "FUN_0010bf86",
                "FUN_0011a170",
                "FUN_00115d70",
                "FUN_0011378f",
                "bfd_set_error",
                "FUN_0010bf20",
                "qsort",
                "FUN_00108b3e",
                "bfd_coff_get_syment",
                "bfd_make_section_with_flags",
                "FUN_001126c0",
                "FUN_001159d0",
                "concat",
                "bfd_set_section_size",
                "strcmp",
                "FUN_00113fb0",
                "strlen",
                "fprintf",
                "FUN_00115dc0",
                "htab_elements",
                "xstrdup",
                "bfd_get_section_by_name",
                "FUN_0010870e",
                "FUN_0010c892",
                "bfd_is_local_label",
                "FUN_001088ae",
                "htab_traverse",
                "FUN_0010be88",
                "FUN_0010bbd3",
                "bfd_map_over_sections",
                "xmalloc",
                "FUN_0010dac0",
                "FUN_0011173a",
                "FUN_00112a33",
                "bfd_map_over_sections",
                "FUN_00119ed0",
                "bfd_get_section_contents",
                "strcpy",
                "bfd_set_section_contents",
                "bfd_fill_in_gnu_debuglink_section",
                "FUN_00119dd0",
                "bfd_alt_mach_code",
                "bfd_errmsg",
                "dcgettext",
                "FUN_00116110",
                "FUN_0010be1a",
                "FUN_00108863",
                "FUN_0011a2e0",
                "FUN_00116030",
                "FUN_0010875d",
                "bfd_set_symtab",
                "free",
                "FUN_00112894",
                "bfd_get_error",
                "bfd_octets_per_byte",
                "FUN_0010bc80",
                "bfd_coff_get_auxent",
                "bfd_decode_symclass"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010554f",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "process_debug_info_0010554f"
        },
        "FUN_00109cf4": {
            "renaming": {
                "FUN_00109cf4": "initialize_data_00109cf4",
                "param_1": "target",
                "param_2": "value",
                "param_3": "option",
                "local_3c": "value_string"
            },
            "code": "\nvoid initialize_data_00109cf4(undefined8 target,undefined8 value,undefined4 option)\n\n{\n  char value_string [28];\n  \n  sprintf(value_string,\"%ld\",value);\n  allocate_and_initialize_data_00109cf4_00109b52(target,value_string,value,0,option);\n  return;\n}\n\n",
            "called": [
                "sprintf",
                "FUN_00109b52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109cf4",
            "calling": [
                "FUN_0010e453",
                "FUN_0010b948",
                "FUN_00109d5c",
                "FUN_00109dfe",
                "FUN_00109d97",
                "FUN_00109d3e",
                "FUN_0010b800",
                "FUN_00109ed3",
                "FUN_0010bba1"
            ],
            "imported": false,
            "current_name": "initialize_data_00109cf4"
        },
        "FUN_00109ab1": {
            "renaming": {
                "FUN_00109ab1": "parse_arguments_00109ab1",
                "param_1": "arg_ptr",
                "param_2": "result_ptr",
                "uVar1": "parsed_value",
                "pcVar2": "current_char",
                "uVar3": "return_value",
                "auVar4": "return_array"
            },
            "code": "\nundefined  [16]\nparse_arguments_00109ab1(char **arg_ptr,undefined4 *result_ptr,undefined8 param_3,undefined8 param_4,\n            undefined8 param_5)\n\n{\n  undefined4 parsed_value;\n  char *current_char;\n  undefined8 return_value;\n  undefined return_array [16];\n  \n  current_char = *arg_ptr;\n  if (*current_char == '(') {\n    *arg_ptr = current_char + 1;\n    parsed_value = parse_strtoul_and_check_overflow_00109a32(arg_ptr,0);\n    *result_ptr = parsed_value;\n    if (**arg_ptr == ',') {\n      *arg_ptr = *arg_ptr + 1;\n      parsed_value = parse_strtoul_and_check_overflow_00109a32(arg_ptr,0,param_3);\n      result_ptr[1] = parsed_value;\n      if (**arg_ptr == ')') {\n        current_char = *arg_ptr + 1;\n        *arg_ptr = current_char;\n        goto LAB_00109b25;\n      }\n    }\n    print_bad_stab_00108fb9(current_char);\n    return_value = 0;\n  }\n  else {\n    *result_ptr = 0;\n    current_char = (char *)parse_strtoul_and_check_overflow_00109a32(arg_ptr,0);\n    result_ptr[1] = (int)current_char;\nLAB_00109b25:\n    return_value = CONCAT71((int7)((ulong)current_char >> 8),1);\n  }\n  return_array._8_8_ = param_5;\n  return_array._0_8_ = return_value;\n  return return_array;\n}\n\n",
            "called": [
                "FUN_00108fb9",
                "FUN_00109a32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109ab1",
            "calling": [
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "parse_arguments_00109ab1"
        },
        "FUN_001159d0": {
            "renaming": {
                "FUN_001159d0": "process_section_data_001159d0",
                "param_1": "sectionData",
                "uVar1": "value1",
                "cVar2": "flag",
                "uVar3": "result",
                "lVar4": "element",
                "lVar5": "currentElement"
            },
            "code": "\nundefined4 processSectionData_001159d0(long sectionData)\n\n{\n  undefined8 value1;\n  char flag;\n  undefined4 result;\n  long element;\n  long currentElement;\n  \n  result = process_section_data_00115b70();\n  if ((char)result == '\\0') {\n    if ((*(byte *)(sectionData + 0x27) & 2) == 0) {\n      return result;\n    }\n    element = find_element_in_array_00115d00(*(undefined8 *)(sectionData + 0xd0),*(undefined8 *)(sectionData + 0xe0));\n    if ((element != 0) &&\n       (((value1 = *(undefined8 *)(element + 8), DAT_00127a2c != 7 ||\n         (flag = find_value_00115d70(value1,DAT_00127a08), flag != '\\0')) &&\n        (flag = find_value_00115d70(value1,DAT_001279f8), flag == '\\0')))) {\n      element = *(long *)(*(long *)(sectionData + 0xd0) + 0xc0);\n      currentElement = element;\n      do {\n        if (currentElement == 0) {\n          return 1;\n        }\n        flag = process_section_data_00115b70(currentElement);\n        if (flag == '\\0') {\n          return result;\n        }\n        currentElement = *(long *)(*(long *)(currentElement + 0xd0) + 0xc0);\n      } while (element != currentElement);\n    }\n  }\n  return 1;\n}\n\n",
            "called": [
                "FUN_00115d00",
                "FUN_00115d70",
                "FUN_00115b70"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001159d0",
            "calling": [
                "FUN_00115530",
                "FUN_0010554f",
                "FUN_00115f50"
            ],
            "imported": false,
            "current_name": "process_section_data_001159d0"
        },
        "FUN_0010a77a": {
            "renaming": {
                "FUN_0010a77a": "extract_and_allocate_data_0010a77a",
                "param_1": "input",
                "uVar1": "flag",
                "lVar2": "data_ptr",
                "__s": "string1",
                "uVar3": "value",
                "uVar4": "result",
                "__s_00": "string2",
                "sVar5": "length1",
                "sVar6": "length2",
                "__s_01": "new_string"
            },
            "code": "\nundefined4 extract_and_allocate_data_0010a77a(long input)\n\n{\n  undefined flag;\n  long data_ptr;\n  char *string1;\n  undefined8 value;\n  undefined4 result;\n  char *string2;\n  size_t length1;\n  size_t length2;\n  char *new_string;\n  \n  data_ptr = *(long *)(input + 0x60);\n  if ((data_ptr != 0) && (string1 = *(char **)(data_ptr + 0x20), string1 != (char *)0x0)) {\n    result = *(undefined4 *)(data_ptr + 0x18);\n    flag = *(undefined *)(data_ptr + 0x1c);\n    value = *(undefined8 *)(data_ptr + 0x10);\n    string2 = (char *)extract_list_item_00109b2f();\n    length1 = strlen(string2);\n    length2 = strlen(string1);\n    new_string = (char *)xmalloc(length1 + 2 + length2);\n    sprintf(new_string,\"%s%s;\",string2,string1);\n    free(string2);\n    free(string1);\n    result = allocate_and_initialize_data_00109b52(input,new_string,value,flag,result);\n    if ((char)result != '\\0') {\n      free(new_string);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "strlen",
                "free",
                "xmalloc",
                "sprintf",
                "FUN_00109b2f",
                "FUN_00109b52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a77a",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "extract_and_allocate_data_0010a77a"
        },
        "fclose": {
            "renaming": {},
            "code": "\n\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fclose(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fclose"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104210",
            "calling": [
                "FUN_00116b90",
                "FUN_00114460",
                "FUN_00114dc7",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "fclose"
        },
        "FUN_0010543c": {
            "renaming": {
                "FUN_0010543c": "print_error_and_exit_0010543c",
                "piVar2": "ptrErrno",
                "pcVar3": "ptrStrError",
                "uVar1": "var1",
                "uVar4": "var4",
                "unaff_RBP": "varRBP"
            },
            "code": "\nvoid printErrorAndExit_0010543c(void)\n\n{\n  undefined8 var1;\n  int *ptrErrno;\n  char *ptrStrError;\n  undefined8 var4;\n  long varRBP;\n  \n  ptrErrno = __errno_location();\n  ptrStrError = strerror(*ptrErrno);\n  var1 = *(undefined8 *)(varRBP + 0x10);\n  var4 = dcgettext(0,\"cannot open: %s: %s\",5);\n                    \n  print_error_and_exit_00119dd0(var4,var1,ptrStrError);\n}\n\n",
            "called": [
                "FUN_00119dd0",
                "__errno_location",
                "dcgettext",
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010543c",
            "calling": [
                "FUN_00114d60"
            ],
            "imported": false,
            "current_name": "print_error_and_exit_0010543c"
        },
        "bfd_coff_get_auxent": {
            "renaming": {},
            "code": "\nvoid bfd_coff_get_auxent(void)\n\n{\n  bfd_coff_get_auxent();\n  return;\n}\n\n",
            "called": [
                "bfd_coff_get_auxent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001045b0",
            "calling": [
                "FUN_0010554f",
                "FUN_0010e07c"
            ],
            "imported": false,
            "current_name": "bfd_coff_get_auxent"
        },
        "FUN_0010a424": {
            "renaming": {
                "FUN_0010a424": "generate_formatted_string_0010a424",
                "param_1": "data",
                "param_2": "flag",
                "param_3": "count",
                "param_4": "initialize",
                "cVar1": "result",
                "bVar2": "byteValue",
                "iVar3": "index",
                "uVar4": "returnValue",
                "pcVar5": "item1",
                "__ptr": "itemList",
                "uVar6": "itemValue",
                "__s": "item2",
                "sVar7": "length1",
                "sVar8": "length2",
                "__s_00": "formattedString",
                "lVar9": "loopIndex1",
                "bVar10": "loopFlag",
                "lVar11": "loopIndex2"
            },
            "code": "\nundefined4 generateFormattedString_0010a424(long data,char flag,int count,char initialize)\n\n{\n  char result;\n  byte byteValue;\n  int index;\n  undefined4 returnValue;\n  char *item1;\n  undefined8 *itemList;\n  undefined8 itemValue;\n  char *item2;\n  size_t length1;\n  size_t length2;\n  char *formattedString;\n  long loopIndex1;\n  byte loopFlag;\n  long loopIndex2;\n  undefined uVar12;\n  \n  if ((flag == '\\0') && (result = initialize_or_increment_variable_00109d97(), result == '\\0')) {\n    return 0;\n  }\n  loopFlag = *(byte *)(*(long *)(data + 0x60) + 0x1c);\n  item1 = (char *)extract_list_item_00109b2f(data);\n  if (count < 0) {\n    itemList = (undefined8 *)0x0;\n    count = 0;\nLAB_0010a582:\n    uVar12 = 1;\n    if (loopFlag != 0) goto LAB_0010a596;\n  }\n  else {\n    if (count != 0) {\n      index = count + 1;\n      itemList = (undefined8 *)xmalloc((long)index * 8);\n      loopIndex1 = (long)(count + -1);\n      do {\n        byteValue = 1;\n        if (loopFlag == 0) {\n          byteValue = *(byte *)(*(long *)(data + 0x60) + 0x1c);\n        }\n        itemValue = extract_list_item_00109b2f(data);\n        loopFlag = byteValue & 1;\n        itemList[loopIndex1] = itemValue;\n        loopIndex1 = loopIndex1 + -1;\n      } while ((int)loopIndex1 != -1);\n      if (initialize == '\\0') {\n        result = initialize_or_increment_variable_00109d97(data);\n        if (result == '\\0') {\n          return 0;\n        }\n        byteValue = 1;\n        if (loopFlag == 0) {\n          byteValue = *(byte *)(*(long *)(data + 0x60) + 0x1c);\n        }\n        loopFlag = byteValue & 1;\n        itemValue = extract_list_item_00109b2f(data);\n        itemList[(long)index + -1] = itemValue;\n        count = index;\n      }\n      goto LAB_0010a582;\n    }\n    itemList = (undefined8 *)0x0;\n    if (initialize != '\\0') goto LAB_0010a582;\n    itemList = (undefined8 *)xmalloc(8);\n    result = initialize_or_increment_variable_00109d97(data);\n    if (result == '\\0') {\n      return 0;\n    }\n    if ((loopFlag != 0) || (*(char *)(*(long *)(data + 0x60) + 0x1c) != '\\0')) {\n      itemValue = extract_list_item_00109b2f(data);\n      count = 1;\n      uVar12 = 1;\n      *itemList = itemValue;\n      goto LAB_0010a596;\n    }\n    itemValue = extract_list_item_00109b2f(data);\n    count = 1;\n    *itemList = itemValue;\n  }\n  uVar12 = *(undefined *)(*(long *)(data + 0x60) + 0x1c);\nLAB_0010a596:\n  item2 = (char *)extract_list_item_00109b2f(data);\n  length1 = strlen(item1);\n  length2 = strlen(item2);\n  loopIndex1 = length1 + 10 + length2;\n  for (loopIndex2 = 0; (int)loopIndex2 < count; loopIndex2 = loopIndex2 + 1) {\n    length1 = strlen((char *)itemList[loopIndex2]);\n    loopIndex1 = loopIndex1 + length1;\n  }\n  formattedString = (char *)xmalloc(loopIndex1);\n  sprintf(formattedString,\"#%s,%s\",item1,item2);\n  loopIndex1 = 0;\n  free(item1);\n  free(item2);\n  while( true ) {\n    length1 = strlen(formattedString);\n    if (count <= (int)loopIndex1) break;\n    *(undefined2 *)(formattedString + length1) = 0x2c;\n    item1 = (char *)itemList[loopIndex1];\n    loopIndex1 = loopIndex1 + 1;\n    strcpy(formattedString + length1 + 1,item1);\n    free(item1);\n  }\n  *(undefined2 *)(formattedString + length1) = 0x3b;\n  free(itemList);\n  returnValue = allocate_and_initialize_data_00109b52(data,formattedString,0,uVar12,0);\n  if ((char)returnValue == '\\0') {\n    return 0;\n  }\n  free(formattedString);\n  return returnValue;\n}\n\n",
            "called": [
                "strlen",
                "free",
                "xmalloc",
                "FUN_00109d97",
                "sprintf",
                "FUN_00109b2f",
                "strcpy",
                "FUN_00109b52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a424",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "generate_formatted_string_0010a424"
        },
        "FUN_00119970": {
            "renaming": {
                "FUN_00119970": "print_version_info_00119970",
                "param_1": "versionString",
                "pcVar1": "licenseText"
            },
            "code": "\nvoid printVersionInfo_00119970(undefined8 versionString)\n\n{\n  char *licenseText;\n  \n  printf(\"GNU %s %s\\n\",versionString,\"(GNU Binutils for Debian) 2.40\");\n  licenseText = (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n  printf(licenseText);\n  licenseText = (char *)dcgettext(0,\n                             \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                             ,5);\n  printf(licenseText);\n                    \n  exit(0);\n}\n\n",
            "called": [
                "dcgettext",
                "printf",
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00119970",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "print_version_info_00119970"
        },
        "FUN_00114c80": {
            "renaming": {
                "FUN_00114c80": "extract_parameter_values_00114c80",
                "param_1": "input_string",
                "param_2": "value_1",
                "param_3": "error_message",
                "param_4": "value_2",
                "pcVar1": "equal_sign_position",
                "uVar2": "format_error_message",
                "auVar3": "modified_parameter_values"
            },
            "code": "\nundefined  [16] extract_parameter_values_00114c80(char *input_string,undefined8 value_1,undefined8 error_message,undefined8 value_2)\n\n{\n  char *equal_sign_position;\n  undefined8 format_error_message;\n  undefined modified_parameter_values [16];\n  \n  equal_sign_position = strchr(input_string,0x3d);\n  if (equal_sign_position != (char *)0x0) {\n    modified_parameter_values._0_8_ = (undefined8 *)xmalloc(0x30);\n    format_error_message = copy_string_and_null_terminate_0011a480(input_string,(long)equal_sign_position - (long)input_string);\n    modified_parameter_values._0_8_[2] = equal_sign_position + 1;\n    modified_parameter_values._0_8_[1] = format_error_message;\n    modified_parameter_values._0_8_[4] = 0;\n    modified_parameter_values._0_8_[3] = 0;\n    *modified_parameter_values._0_8_ = value_1;\n    modified_parameter_values._8_8_ = value_2;\n    return modified_parameter_values;\n  }\n  format_error_message = dcgettext(0,\"bad format for %s\",5);\n                    \n  print_error_and_exit_00119dd0(format_error_message,error_message);\n}\n\n",
            "called": [
                "xmalloc",
                "strchr",
                "FUN_001053b5",
                "FUN_0011a480"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114c80",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "extract_parameter_values_00114c80"
        },
        "FUN_0010870e": {
            "renaming": {
                "FUN_0010870e": "assign_param_and_increment_0010870e",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "paramArray",
                "puVar1": "ptrToValue"
            },
            "code": "\nvoid assignParamAndIncrement_0010870e(undefined8 input1,undefined8 input2,long *paramArray)\n\n{\n  undefined8 *ptrToValue;\n  \n  ptrToValue = (undefined8 *)*paramArray;\n  *ptrToValue = input2;\n  *paramArray = (long)(ptrToValue + 1);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010870e",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "assign_param_and_increment_0010870e"
        },
        "unlink_if_ordinary": {
            "renaming": {},
            "code": "\nvoid unlink_if_ordinary(void)\n\n{\n  unlink_if_ordinary();\n  return;\n}\n\n",
            "called": [
                "unlink_if_ordinary"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104610",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "unlink_if_ordinary"
        },
        "FUN_0010dac0": {
            "renaming": {
                "FUN_0010dac0": "parse_and_initialize_data_0010dac0",
                "param_1": "inputParam1",
                "param_2": "inputParam2",
                "param_3": "inputParam3",
                "param_4": "inputParam4",
                "param_5": "inputParam5",
                "param_6": "inputParam6",
                "param_7": "inputParam7",
                "param_8": "inputParam8",
                "lVar1": "tempVar1",
                "cVar2": "tempVar2",
                "uVar3": "tempVar3",
                "uVar4": "tempVar4",
                "lVar5": "resultVar",
                "uVar6": "tempVar6",
                "plVar7": "ptrVar1",
                "__ptr": "ptrVar2",
                "__ptr_00": "ptrVar3",
                "bVar8": "tempVar8",
                "iVar9": "tempVar9",
                "pcVar10": "tempVar10",
                "uVar11": "tempVar11",
                "lVar12": "tempVar12",
                "uVar13": "tempVar13",
                "uVar14": "tempVar14",
                "uVar15": "tempVar15",
                "local_68": "localArray1",
                "local_48": "localVar1",
                "local_47": "localVar2"
            },
            "code": "\nlong parseAndInitializeData_0010dac0(long inputParam1,long *inputParam2,long inputParam3,undefined8 inputParam4,uint inputParam5,\n                 long *inputParam6,char inputParam7,undefined8 inputParam8)\n\n{\n  long tempVar1;\n  char tempVar2;\n  undefined4 tempVar3;\n  undefined8 tempVar4;\n  long resultVar;\n  undefined8 tempVar6;\n  long *ptrVar1;\n  void *ptrVar2;\n  void *ptrVar3;\n  byte tempVar8;\n  int tempVar9;\n  char *tempVar10;\n  ulong tempVar11;\n  long tempVar12;\n  uint tempVar13;\n  uint tempVar14;\n  undefined8 tempVar15;\n  undefined localArray1 [32];\n  char localVar1;\n  byte localVar2;\n  \n  resultVar = *(long *)(inputParam1 + 0x110);\n  if ((~*(uint *)(resultVar + 0x38) & inputParam5) != 0) {\n    tempVar13 = (int)inputParam5 >> ((byte)*(undefined4 *)(resultVar + 0x44) & 0x1f);\n    tempVar11 = (ulong)(inputParam5 & *(uint *)(resultVar + 0x40));\n    tempVar8 = (byte)*(undefined4 *)(resultVar + 0x3c);\n    tempVar13 = (tempVar13 ^ inputParam5) & *(uint *)(resultVar + 0x38) ^ tempVar13;\n    if (tempVar11 == 1L << (tempVar8 & 0x3f)) {\n      tempVar4 = parseAndInitializeData_0010dac0(inputParam1,inputParam2,inputParam3,inputParam4,tempVar13,inputParam6,inputParam7,inputParam8);\n      resultVar = initialize_data_00113d3a(tempVar4);\n      return resultVar;\n    }\n    if (tempVar11 != 2L << (tempVar8 & 0x3f)) {\n      if (tempVar11 != 3L << (tempVar8 & 0x3f)) {\n        tempVar4 = dcgettext(0,\"parse_coff_type: Bad type code 0x%x\",5,*(undefined4 *)(resultVar + 0x3c),\n                          tempVar13);\n        print_error_message_00119ed0(tempVar4,inputParam5);\n        return 0;\n      }\n      tempVar14 = 0;\n      if (inputParam6 != (long *)0x0) {\n        tempVar14 = (uint)*(ushort *)(inputParam6 + 2);\n        ptrVar1 = inputParam6 + 2;\n        for (tempVar9 = 0; (*(short *)ptrVar1 != 0 && (tempVar9 != 3)); tempVar9 = tempVar9 + 1) {\n          *(short *)ptrVar1 = *(short *)((long)ptrVar1 + 2);\n          ptrVar1 = (long *)((long)ptrVar1 + 2);\n        }\n        *(short *)ptrVar1 = 0;\n      }\n      tempVar15 = 0;\n      tempVar4 = inputParam8;\n      tempVar6 = parseAndInitializeData_0010dac0(inputParam1,inputParam2,inputParam3,inputParam4,tempVar13,inputParam6,0);\n      resultVar = *(long *)(inputParam3 + 0x28);\n      if (resultVar == 0) {\n        tempVar4 = update_data_00113dfe(4,0,tempVar15,tempVar4);\n        resultVar = initialize_data_structure_0010c218(inputParam8,\"int\",tempVar4);\n        *(long *)(inputParam3 + 0x28) = resultVar;\n      }\n      resultVar = initialize_and_store_data_00113c43(tempVar6,resultVar,0,(long)(int)(tempVar14 - 1),0);\n      return resultVar;\n    }\n    tempVar4 = parseAndInitializeData_0010dac0(inputParam1,inputParam2,inputParam3,inputParam4,tempVar13,inputParam6,inputParam7,inputParam8);\n    resultVar = initialize_and_store_data_00113ce0(tempVar4,0,0);\n    return resultVar;\n  }\n  if ((inputParam6 != (long *)0x0) && (0 < *inputParam6)) {\n    ptrVar1 = (long *)allocate_and_initialize_slot_0010da0b(inputParam3);\n    if (*ptrVar1 != 0) {\n      return *ptrVar1;\n    }\n    resultVar = initialize_data_00113e23(ptrVar1,0);\n    return resultVar;\n  }\n  if (inputParam7 == '\\0') {\n    inputParam6 = (long *)0x0;\n  }\n  if (0x10 < inputParam5) {\n    resultVar = initialize_data_00113e17();\n    return resultVar;\n  }\n  resultVar = *(long *)(inputParam3 + 8 + (long)(int)inputParam5 * 8);\n  if (resultVar != 0) {\n    return resultVar;\n  }\n  switch(inputParam5) {\n  default:\n    tempVar4 = initialize_data_00113e17();\n    tempVar10 = \"void\";\n    break;\n  case 2:\n    tempVar4 = update_data_00113dfe(1,0);\n    tempVar10 = \"char\";\n    break;\n  case 3:\n    tempVar4 = update_data_00113dfe(2,0);\n    tempVar10 = \"short\";\n    break;\n  case 4:\n    tempVar4 = update_data_00113dfe(4,0);\n    tempVar10 = \"int\";\n    break;\n  case 5:\n    tempVar4 = update_data_00113dfe(4,0);\n    tempVar10 = \"long\";\n    break;\n  case 6:\n    tempVar4 = initialize_data_00113df2(4);\n    tempVar10 = \"float\";\n    break;\n  case 7:\n    tempVar4 = initialize_data_00113df2(8);\n    tempVar10 = \"double\";\n    break;\n  case 8:\n    if (inputParam6 == (long *)0x0) {\n      resultVar = initialize_data_with_offset_00113da9(1,0,0);\n      goto LAB_0010e046;\n    }\n    tempVar4 = 8;\n    goto LAB_0010de7a;\n  case 9:\n    if (inputParam6 == (long *)0x0) {\n      resultVar = initialize_data_with_offset_00113da9(0,0,0);\n      goto LAB_0010e046;\n    }\n    tempVar4 = 9;\nLAB_0010de7a:\n    resultVar = process_binary_data_0010e07c(inputParam1,inputParam2,inputParam3,tempVar4,inputParam6,inputParam8);\nLAB_0010e046:\n    ptrVar1 = (long *)allocate_and_initialize_slot_0010da0b(inputParam3,inputParam4);\n    *ptrVar1 = resultVar;\n    return resultVar;\n  case 10:\n    if (inputParam6 == (long *)0x0) {\n      resultVar = initialize_data_with_pointers_00113d6e(0,0);\n    }\n    else {\n      resultVar = inputParam6[3];\n      ptrVar2 = (void *)xmalloc(0x50);\n      ptrVar3 = (void *)xmalloc(0x50);\n      tempVar12 = 0;\n      do {\n        while( true ) {\n          if ((resultVar <= inputParam2[3]) || (inputParam2[1] <= inputParam2[2])) goto LAB_0010e032;\n          tempVar9 = (int)tempVar12;\n          tempVar1 = *(long *)(*inputParam2 + inputParam2[2] * 8);\n          tempVar2 = bfd_coff_get_syment(inputParam1,tempVar1,localArray1);\n          tempVar12 = (long)tempVar9;\n          if (tempVar2 == '\\0') {\n            tempVar3 = bfd_get_error();\n            tempVar4 = bfd_errmsg(tempVar3);\n            tempVar6 = dcgettext(0,\"bfd_coff_get_syment failed: %s\",5);\n            print_error_message_00119ed0(tempVar6,tempVar4);\n            free(ptrVar2);\n            free(ptrVar3);\n            resultVar = 0;\n            goto LAB_0010e046;\n          }\n          inputParam2[2] = inputParam2[2] + 1;\n          inputParam2[3] = (ulong)localVar2 + 1 + inputParam2[3];\n          if (localVar1 != '\\x10') break;\n          if ((int)inputParam5 <= tempVar9 + 1) {\n            inputParam5 = inputParam5 + 10;\n            ptrVar2 = (void *)xrealloc(ptrVar2);\n            ptrVar3 = (void *)xrealloc(ptrVar3,(long)(int)inputParam5 << 3);\n          }\n          tempVar12 = *(long *)(tempVar1 + 0x20);\n          *(undefined8 *)((long)ptrVar2 + (long)tempVar9 * 8) = *(undefined8 *)(tempVar1 + 8);\n          *(long *)((long)ptrVar3 + (long)tempVar9 * 8) =\n               *(long *)(tempVar1 + 0x10) + *(long *)(tempVar12 + 0x30);\n          tempVar12 = (long)(tempVar9 + 1);\n        }\n      } while (localVar1 != 'f');\nLAB_0010e032:\n      *(undefined8 *)((long)ptrVar2 + tempVar12 * 8) = 0;\n      resultVar = initialize_data_with_pointers_00113d6e(ptrVar2,ptrVar3);\n    }\n    goto LAB_0010e046;\n  case 0xb:\n    resultVar = initialize_data_00113e17();\n    goto LAB_0010e065;\n  case 0xc:\n    tempVar4 = update_data_00113dfe(1,1);\n    tempVar10 = \"unsigned char\";\n    break;\n  case 0xd:\n    tempVar4 = update_data_00113dfe(2,1);\n    tempVar10 = \"unsigned short\";\n    break;\n  case 0xe:\n    tempVar4 = update_data_00113dfe(4,1);\n    tempVar10 = \"unsigned int\";\n    break;\n  case 0xf:\n    tempVar4 = update_data_00113dfe(4,1);\n    tempVar10 = \"unsigned long\";\n    break;\n  case 0x10:\n    tempVar4 = initialize_data_00113df2(0xc);\n    tempVar10 = \"long double\";\n  }\n  resultVar = initialize_data_structure_0010c218(inputParam8,tempVar10,tempVar4);\nLAB_0010e065:\n  *(long *)(inputParam3 + 8 + (long)(int)inputParam5 * 8) = resultVar;\n  return resultVar;\n}\n\n",
            "called": [
                "bfd_errmsg",
                "FUN_00113d3a",
                "FUN_0010e07c",
                "FUN_00113c43",
                "dcgettext",
                "FUN_00113ce0",
                "xmalloc",
                "FUN_00113e23",
                "FUN_0010dac0",
                "FUN_00113d6e",
                "FUN_00113da9",
                "xrealloc",
                "FUN_0010c218",
                "free",
                "bfd_coff_get_syment",
                "bfd_get_error",
                "FUN_00119ed0",
                "FUN_00113df2",
                "FUN_00113dfe",
                "FUN_00113e17",
                "FUN_0010da0b"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010dac0",
            "calling": [
                "FUN_0010554f",
                "FUN_0010e07c",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "parse_and_initialize_data_0010dac0"
        },
        "FUN_00113fb0": {
            "renaming": {
                "FUN_00113fb0": "compare_strings_00113fb0",
                "param_1": "string1",
                "param_2": "string2",
                "iVar1": "comparisonResult",
                "in_RAX": "returnValue",
                "__n": "length",
                "extraout_var": "extraOutput",
                "auVar2": "result"
            },
            "code": "\nundefined  [16] compareStrings_00113fb0(char *string1,char *string2)\n\n{\n  int comparisonResult;\n  undefined8 returnValue;\n  size_t length;\n  undefined4 extraOutput;\n  undefined result [16];\n  \n  length = strlen(string2);\n  comparisonResult = strncmp(string1,string2,length);\n  result._1_7_ = (undefined7)(CONCAT44(extraOutput,comparisonResult) >> 8);\n  result[0] = comparisonResult == 0;\n  result._8_8_ = returnValue;\n  return result;\n}\n\n",
            "called": [
                "strncmp",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113fb0",
            "calling": [
                "FUN_0010554f",
                "FUN_00116b90",
                "FUN_00113ede",
                "FUN_0010ee3f",
                "FUN_00108c86",
                "FUN_00113e5e",
                "FUN_00114c20",
                "FUN_00115f50",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "compare_strings_00113fb0"
        },
        "FUN_0010882c": {
            "renaming": {
                "FUN_0010882c": "print_error_message_0010882c",
                "piVar1": "errnoLocation",
                "uVar2": "errorText"
            },
            "code": "\nvoid printErrorMessage_0010882c(void)\n\n{\n  int *errnoLocation;\n  undefined8 errorText;\n  \n  errnoLocation = __errno_location();\n  strerror(*errnoLocation);\n  errorText = dcgettext(0,\"%s: cannot set time: %s\",5);\n  print_error_message_00119ed0(errorText);\n  return;\n}\n\n",
            "called": [
                "__errno_location",
                "dcgettext",
                "FUN_00119ed0",
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010882c",
            "calling": [
                "FUN_0011a350"
            ],
            "imported": false,
            "current_name": "print_error_message_0010882c"
        },
        "FUN_0010ebb0": {
            "renaming": {
                "FUN_0010ebb0": "process_extracted_item_0010ebb0",
                "param_1": "param1",
                "param_2": "inputString",
                "param_3": "stringLength",
                "param_4": "param4",
                "__s": "extractedString",
                "uVar2": "strLenMinusOne",
                "uVar3": "returnValue",
                "__s_00": "processedString",
                "cVar1": "charValue",
                "sVar4": "inputStringLength",
                "sVar5": "extractedStringLength"
            },
            "code": "\nundefined4 processExtractedItem_0010ebb0(undefined8 param1,char *inputString,int stringLength,undefined8 param4)\n\n{\n  char charValue;\n  uint strLenMinusOne;\n  undefined4 returnValue;\n  char *extractedString;\n  size_t inputStringLength;\n  size_t extractedStringLength;\n  char *processedString;\n  \n  extractedString = (char *)extract_list_item_00109b2f();\n  strLenMinusOne = stringLength - 1;\n  if (strLenMinusOne < 4) {\n    returnValue = *(undefined4 *)(&DAT_00121340 + (ulong)strLenMinusOne * 4);\n    charValue = (&DAT_00121334)[strLenMinusOne];\n    inputStringLength = strlen(inputString);\n    extractedStringLength = strlen(extractedString);\n    processedString = (char *)xmalloc(inputStringLength + 3 + extractedStringLength);\n    sprintf(processedString,\"%s:%c%s\",inputString,(ulong)(uint)(int)charValue,extractedString);\n    free(extractedString);\n    returnValue = process_string_0010e2f0(param1,returnValue,0,param4,processedString);\n    if ((char)returnValue != '\\0') {\n      free(processedString);\n    }\n    return returnValue;\n  }\n                    \n  abort();\n}\n\n",
            "called": [
                "abort",
                "strlen",
                "free",
                "xmalloc",
                "sprintf",
                "FUN_00109b2f",
                "FUN_0010e2f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010ebb0",
            "calling": [
                "FUN_001135a5"
            ],
            "imported": false,
            "current_name": "process_extracted_item_0010ebb0"
        },
        "feof": {
            "renaming": {},
            "code": "\n\n\nint feof(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = feof(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "feof"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001044d0",
            "calling": [
                "FUN_00114dc7"
            ],
            "imported": false,
            "current_name": "feof"
        },
        "FUN_00116b00": {
            "renaming": {
                "FUN_00116b00": "FUNC_00116b00"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00116b24) */\n/* WARNING: Removing unreachable block (ram,0x00116b30) */\n\nvoid FUNC_00116b00(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_registerTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00116b00",
            "calling": [
                "_INIT_0"
            ],
            "imported": false,
            "current_name": "FUNC_00116b00"
        },
        "FUN_00113b98": {
            "renaming": {
                "FUN_00113b98": "initialize_data_and_allocate_memory_00113b98",
                "param_1": "input_param",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "lVar1": "allocated_memory",
                "plVar2": "allocated_pointer",
                "initialize_data_00112904": "initialize_data",
                "xmalloc": "allocate_memory",
                "plVar2[1]": "set_param2",
                "plVar2[2]": "set_param3"
            },
            "code": "\nlong initialize_data_and_allocate_memory_00113b98(long input_param,long param2,long param3,undefined param4)\n\n{\n  long allocated_memory;\n  long *allocated_pointer;\n  \n  if ((input_param != 0) && (allocated_memory = initialize_data(0x13,0), allocated_memory != 0)) {\n    allocated_pointer = (long *)xmalloc(0x20);\n    *(undefined4 *)((long)allocated_pointer + 0x19) = 0;\n    *allocated_pointer = input_param;\n    *(undefined4 *)((long)allocated_pointer + 0x1c) = 0;\n    set_param2 = param2;\n    set_param3 = param3;\n    *(undefined *)(allocated_pointer + 3) = param4;\n    *(long **)(allocated_memory + 0x10) = allocated_pointer;\n    return allocated_memory;\n  }\n  return 0;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113b98",
            "calling": [
                "FUN_0010c95e",
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "initialize_data_and_allocate_memory_00113b98"
        },
        "FUN_00115d70": {
            "renaming": {
                "FUN_00115d70": "find_value_00115d70",
                "param_1": "key",
                "param_2": "table",
                "lVar1": "result",
                "local_18": "key_copy",
                "local_10": "found"
            },
            "code": "\nundefined find_value_00115d70(undefined8 key,undefined8 table)\n\n{\n  long result;\n  undefined8 key_copy;\n  undefined found;\n  \n  if (DAT_001279ca == '\\0') {\n    result = htab_find(table,key);\n    found = result != 0;\n  }\n  else {\n    found = 0;\n    key_copy = key;\n    htab_traverse(table,pattern_match_0011a170,&key_copy);\n  }\n  return found;\n}\n\n",
            "called": [
                "htab_find",
                "htab_traverse",
                "FUN_0011a170"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115d70",
            "calling": [
                "FUN_0010554f",
                "FUN_001082df",
                "FUN_001159d0"
            ],
            "imported": false,
            "current_name": "find_value_00115d70"
        },
        "FUN_00109be3": {
            "renaming": {
                "FUN_00109be3": "resize_and_add_to_buffer_00109be3",
                "param_1": "buffer",
                "param_2": "data",
                "param_3": "length",
                "uVar1": "resizedBuffer",
                "puVar2": "bufferPtr",
                "uVar3": "bufferSize"
            },
            "code": "\nundefined8 resizeAndAddToBuffer_00109be3(long buffer,undefined8 data,undefined4 length)\n\n{\n  undefined8 resizedBuffer;\n  undefined8 *bufferPtr;\n  uint bufferSize;\n  \n  if (*(uint *)(buffer + 0x2c) <= *(uint *)(buffer + 0x28)) {\n    bufferSize = *(uint *)(buffer + 0x2c) + 10;\n    *(uint *)(buffer + 0x2c) = bufferSize;\n    resizedBuffer = xrealloc(*(undefined8 *)(buffer + 0x20),(ulong)bufferSize << 4);\n    *(undefined8 *)(buffer + 0x20) = resizedBuffer;\n  }\n  bufferSize = *(uint *)(buffer + 0x28);\n  bufferPtr = (undefined8 *)((ulong)bufferSize * 0x10 + *(long *)(buffer + 0x20));\n  *bufferPtr = data;\n  *(undefined4 *)(bufferPtr + 1) = length;\n  *(uint *)(buffer + 0x28) = bufferSize + 1;\n  return CONCAT71((int7)((ulong)bufferPtr >> 8),1);\n}\n\n",
            "called": [
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109be3",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010d7d4"
            ],
            "imported": false,
            "current_name": "resize_and_add_to_buffer_00109be3"
        },
        "putc": {
            "renaming": {},
            "code": "\n\n\nint putc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = putc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104480",
            "calling": [
                "FUN_00119e70",
                "FUN_00104943"
            ],
            "imported": false,
            "current_name": "putc"
        },
        "FUN_0011a480": {
            "renaming": {
                "FUN_0011a480": "copy_string_and_null_terminate_0011a480",
                "param_1": "sourceString",
                "param_2": "maxLength",
                "__n": "stringLength",
                "__dest": "destinationString"
            },
            "code": "\nvoid copyStringAndNullTerminate_0011a480(char *sourceString,size_t maxLength)\n\n{\n  size_t stringLength;\n  void *destinationString;\n  \n  stringLength = strnlen(sourceString,maxLength);\n  destinationString = (void *)xmalloc(stringLength + 1);\n  *(undefined *)((long)destinationString + stringLength) = 0;\n  memcpy(destinationString,sourceString,stringLength);\n  return;\n}\n\n",
            "called": [
                "strnlen",
                "memcpy",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a480",
            "calling": [
                "FUN_00116b90",
                "FUN_00114c80"
            ],
            "imported": false,
            "current_name": "copy_string_and_null_terminate_0011a480"
        },
        "FUN_0010e918": {
            "renaming": {
                "FUN_0010e918": "process_string_with_parameters_0010e918",
                "param_1": "param_first",
                "param_2": "input_string",
                "param_3": "param_third",
                "__s": "extracted_item",
                "sVar2": "input_string_length",
                "sVar3": "extracted_item_length",
                "__s_00": "allocated_string"
            },
            "code": "\nundefined4 process_string_with_parameters_0010e918(undefined8 param_first,char *input_string,undefined8 param_third)\n\n{\n  undefined4 uVar1;\n  char *extracted_item;\n  size_t input_string_length;\n  size_t extracted_item_length;\n  char *allocated_string;\n  \n  extracted_item = (char *)extract_list_item_00109b2f();\n  input_string_length = strlen(input_string);\n  extracted_item_length = strlen(extracted_item);\n  allocated_string = (char *)xmalloc(input_string_length + 0x14 + extracted_item_length);\n  sprintf(allocated_string,\"%s:c=e%s,%ld\",input_string,extracted_item,param_third);\n  free(extracted_item);\n  uVar1 = process_string_0010e2f0(param_first,0x80,0,0,allocated_string);\n  if ((char)uVar1 != '\\0') {\n    free(allocated_string);\n  }\n  return uVar1;\n}\n\n",
            "called": [
                "strlen",
                "free",
                "xmalloc",
                "sprintf",
                "FUN_00109b2f",
                "FUN_0010e2f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e918",
            "calling": [
                "FUN_001135a5"
            ],
            "imported": false,
            "current_name": "process_string_with_parameters_0010e918"
        },
        "bfd_bread": {
            "renaming": {},
            "code": "\nvoid bfd_bread(void)\n\n{\n  bfd_bread();\n  return;\n}\n\n",
            "called": [
                "bfd_bread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104870",
            "calling": [
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "bfd_bread"
        },
        "strcpy": {
            "renaming": {},
            "code": "\n\n\nchar * strcpy(char *__dest,char *__src)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strcpy(__dest,__src);\n  return pcVar1;\n}\n\n",
            "called": [
                "strcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104100",
            "calling": [
                "FUN_00115530",
                "FUN_0010554f",
                "FUN_00116b90",
                "FUN_0010ee3f",
                "FUN_0010ae0e",
                "FUN_001199d0",
                "FUN_0011378f",
                "FUN_0010a424"
            ],
            "imported": false,
            "current_name": "strcpy"
        },
        "FUN_00116110": {
            "renaming": {
                "FUN_00116110": "reverse_section_contents_00116110",
                "param_1": "inputBinary",
                "param_2": "sectionHeaders",
                "param_3": "outputBinary",
                "uVar1": "tempByte",
                "uVar2": "sectionHeader",
                "lVar3": "sectionHeaderOffset",
                "iVar4": "ruleSize",
                "iVar5": "remainder",
                "cVar6": "result",
                "uVar7": "errorMessage",
                "__ptr": "buffer",
                "lVar8": "i",
                "uVar9": "j",
                "iVar10": "byteSize",
                "uVar11": "startOffset",
                "puVar12": "tempPtr",
                "lVar13": "bufferSize",
                "puVar14": "alignedBufferPtr",
                "puVar15": "ptrWithOffset",
                "pvVar16": "destPtr",
                "uVar17": "endOffset",
                "uVar18": "alignment",
                "uVar19": "tempOffset",
                "bVar20": "isAligned",
                "local_38": "bufferSize",
                "local_30": "sourceContent"
            },
            "code": "\nvoid reverseSectionContents_00116110(undefined8 inputBinary,undefined8 *sectionHeaders,undefined8 outputBinary)\n\n{\n  undefined tempByte;\n  undefined8 sectionHeader;\n  long sectionHeaderOffset;\n  int ruleSize;\n  int remainder;\n  char result;\n  undefined8 errorMessage;\n  undefined8 *buffer;\n  long i;\n  ulong j;\n  int byteSize;\n  ulong startOffset;\n  undefined *tempPtr;\n  long bufferSize;\n  undefined8 *alignedBufferPtr;\n  undefined8 *ptrWithOffset;\n  void *destPtr;\n  ulong endOffset;\n  ulong alignment;\n  ulong tempOffset;\n  byte isAligned;\n  ulong bufferSize;\n  void *sourceContent;\n  \n  isAligned = 0;\n  result = check_section_data_00115f50(inputBinary,sectionHeaders,1);\n  if (result != '\\0') {\n    return;\n  }\n  bufferSize = sectionHeaders[8];\n  sectionHeaderOffset = sectionHeaders[0xc];\n  if (((*(byte *)((long)sectionHeaders + 0x25) & 1) == 0) || ((*(byte *)(sectionHeaderOffset + 0x25) & 1) == 0)) {\n    bufferSize = parse_rules_00114190(*sectionHeaders,0,0x80);\n    if (bufferSize == 0) {\n      return;\n    }\n    if ((*(byte *)(bufferSize + 0x29) & 1) == 0) {\n      return;\n    }\n    buffer = (undefined8 *)xmalloc(bufferSize);\n    ptrWithOffset = buffer;\n    if (7 < bufferSize) {\n      for (alignment = bufferSize >> 3; alignment != 0; alignment = alignment - 1) {\n        *ptrWithOffset = 0;\n        ptrWithOffset = ptrWithOffset + (ulong)isAligned * -2 + 1;\n      }\n    }\n    alignedBufferPtr = ptrWithOffset;\n    if ((bufferSize & 4) != 0) {\n      alignedBufferPtr = (undefined8 *)((long)ptrWithOffset + (ulong)isAligned * -8 + 4);\n      *(undefined4 *)ptrWithOffset = 0;\n    }\n    ptrWithOffset = alignedBufferPtr;\n    if ((bufferSize & 2) != 0) {\n      ptrWithOffset = (undefined8 *)((long)alignedBufferPtr + (ulong)isAligned * -4 + 2);\n      *(undefined2 *)alignedBufferPtr = 0;\n    }\n    if ((bufferSize & 1) != 0) {\n      *(undefined *)ptrWithOffset = 0;\n    }\n    result = bfd_set_section_contents(outputBinary,sectionHeaderOffset,buffer,0);\n    if (result != '\\0') {\n      free(buffer);\n      return;\n    }\n    DAT_00127a20 = 1;\n    display_error_001126c0(0,outputBinary,sectionHeaderOffset,0);\n    free(buffer);\n    return;\n  }\n  sourceContent = (void *)0x0;\n  result = bfd_get_full_section_contents(inputBinary,sectionHeaders,&sourceContent);\n  if ((result == '\\0') ||\n     (result = bfd_convert_section_contents(inputBinary,sectionHeaders,outputBinary,&sourceContent,&bufferSize),\n     byteSize = DAT_001278e8, result == '\\0')) {\n    bfd_set_section_size(sectionHeaderOffset,0);\n    DAT_00127a20 = 1;\n    display_error_001126c0(0,inputBinary,sectionHeaders,0);\n    free(sourceContent);\n    return;\n  }\n  ruleSize = DAT_001264b8;\n  remainder = DAT_001264bc;\n  if (DAT_001278e8 != 0) {\n    alignment = (ulong)DAT_001278e8;\n    if (bufferSize % alignment != 0) {\n      sectionHeader = *sectionHeaders;\n      errorMessage = dcgettext(0,\n                        \"cannot reverse bytes: length of section %s must be evenly divisible by %d\",\n                        5);\n                    \n      print_error_and_exit_00119dd0(errorMessage,sectionHeader,byteSize);\n    }\n    byteSize = DAT_001278e8 / 2;\n    startOffset = 0;\n    while (tempOffset = startOffset, ruleSize = DAT_001264b8, remainder = DAT_001264bc, tempOffset < bufferSize) {\n      startOffset = alignment + tempOffset;\n      endOffset = startOffset;\n      for (j = 0; j < (ulong)(long)byteSize; j = j + 1) {\n        endOffset = endOffset - 1;\n        tempPtr = (undefined *)(tempOffset + j + (long)sourceContent);\n        tempByte = *tempPtr;\n        *tempPtr = *(undefined *)((long)sourceContent + endOffset);\n        *(undefined *)((long)sourceContent + endOffset) = tempByte;\n      }\n    }\n  }\n  DAT_001264b8 = ruleSize;\n  DAT_001264bc = remainder;\n  if (-1 < remainder) {\n    alignment = (ulong)DAT_00127a1c;\n    byteSize = (int)((ulong)sectionHeaders[7] % alignment);\n    startOffset = ((long)remainder - (long)byteSize) + (long)sourceContent;\n    if (remainder < byteSize) {\n      startOffset = startOffset + alignment;\n    }\n    bufferSize = (bufferSize + (long)sourceContent) - startOffset;\n    destPtr = sourceContent;\n    for (; startOffset < bufferSize + (long)sourceContent; startOffset = startOffset + alignment) {\n      for (i = 0; ((int)i < ruleSize && (i != bufferSize)); i = i + 1) {\n        *(undefined *)((long)destPtr + i) = *(undefined *)(startOffset + i);\n      }\n      destPtr = (void *)((long)destPtr + i);\n      bufferSize = bufferSize - alignment;\n    }\n    bufferSize = ((((alignment - 1) + bufferSize) - (long)remainder) / alignment) * (long)ruleSize;\n    alignment = *(ulong *)(sectionHeaderOffset + 0x38) / alignment;\n    *(ulong *)(sectionHeaderOffset + 0x38) = alignment;\n    if (remainder < byteSize) {\n      *(ulong *)(sectionHeaderOffset + 0x38) = alignment + 1;\n      result = bfd_set_section_contents(outputBinary,sectionHeaderOffset,sourceContent,0,bufferSize);\n      if (result == '\\0') {\n        cleanup_and_display_error_00108466();\n        return;\n      }\n      goto LAB_001161d8;\n    }\n  }\n  result = bfd_set_section_contents(outputBinary,sectionHeaderOffset,sourceContent,0,bufferSize);\n  if (result == '\\0') {\n    cleanup_and_display_error_00108466();\n    return;\n  }\nLAB_001161d8:\n  free(sourceContent);\n  return;\n}\n\n",
            "called": [
                "FUN_001083de",
                "bfd_get_full_section_contents",
                "bfd_set_section_contents",
                "bfd_convert_section_contents",
                "free",
                "xmalloc",
                "FUN_00115f50",
                "FUN_001126c0",
                "FUN_00108466",
                "FUN_00114190",
                "bfd_set_section_size"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116110",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "reverse_section_contents_00116110"
        },
        "FUN_0010871c": {
            "renaming": {
                "FUN_0010871c": "print_error_message_0010871c",
                "unaff_RBX": "errorCode",
                "unaff_retaddr": "returnAddress",
                "uVar1": "errorMessage",
                "dcgettext": "getErrorMessage",
                "fflush": "flushOutput",
                "_stdout": "standardOutput",
                "_stderr": "standardError",
                "fprintf": "printFormatted"
            },
            "code": "\n\n\nvoid printErrorMessage_0010871c(void)\n\n{\n  undefined8 errorMessage;\n  long errorCode;\n  undefined8 returnAddress;\n  \n  errorMessage = dcgettext(0,\"cause of error unknown\",5);\n  fflush(standardOutput);\n  if (errorCode != 0) {\n    fprintf(standardError,\"%s: %s: %s\\n\",DAT_001275e0);\n    return;\n  }\n  fprintf(standardError,\"%s: %s\\n\",DAT_001275e0,errorMessage,returnAddress);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fflush",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010871c",
            "calling": [
                "FUN_0011a110"
            ],
            "imported": false,
            "current_name": "print_error_message_0010871c"
        },
        "FUN_0010bf20": {
            "renaming": {
                "FUN_0010bf20": "debug_end_block_check_0010bf20",
                "param_1": "block_ptr",
                "param_2": "new_param_2",
                "param_3": "new_param_3",
                "param_4": "new_param_4",
                "lVar1": "current_block",
                "uVar2": "result",
                "pcVar3": "error_message",
                "auVar4": "return_value"
            },
            "code": "\n\n\nundefined  [16] debug_end_block_check_0010bf20(long block_ptr,undefined8 new_param_2,undefined8 new_param_3,undefined8 new_param_4)\n\n{\n  long current_block;\n  undefined8 result;\n  char *error_message;\n  undefined return_value [16];\n  \n  if ((*(long *)(block_ptr + 8) == 0) || (current_block = *(long *)(block_ptr + 0x20), current_block == 0)) {\n    error_message = \"debug_end_block: no current block\";\n  }\n  else {\n    if (*(long *)(current_block + 8) != 0) {\n      *(undefined8 *)(current_block + 0x20) = new_param_2;\n      result = CONCAT71((int7)((ulong)current_block >> 8),1);\n      *(long *)(block_ptr + 0x20) = *(long *)(current_block + 8);\n      goto LAB_0010bf84;\n    }\n    error_message = \"debug_end_block: attempt to close top level block\";\n  }\n  result = dcgettext(0,error_message,5);\n  fprintf(_stderr,\"%s\\n\",result);\n  result = 0;\nLAB_0010bf84:\n  return_value._8_8_ = new_param_4;\n  return_value._0_8_ = result;\n  return return_value;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bf20",
            "calling": [
                "FUN_0011173a",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "debug_end_block_check_0010bf20"
        },
        "bfd_make_section_anyway_with_flags": {
            "renaming": {},
            "code": "\nvoid bfd_make_section_anyway_with_flags(void)\n\n{\n  bfd_make_section_anyway_with_flags();\n  return;\n}\n\n",
            "called": [
                "bfd_make_section_anyway_with_flags"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104190",
            "calling": [
                "FUN_00115530"
            ],
            "imported": false,
            "current_name": "bfd_make_section_anyway_with_flags"
        },
        "FUN_0010c95e": {
            "renaming": {
                "FUN_0010c95e": "parse_initialize_data_0010c95e",
                "param_1": "data",
                "param_2": "input",
                "param_3": "result",
                "bVar1": "byte1",
                "bVar2": "byte2",
                "pbVar3": "currentByte",
                "bVar4": "isSignedChar",
                "bVar5": "isUnsignedChar",
                "bVar6": "isFloat",
                "cVar7": "parseResult",
                "uVar8": "parsedInteger",
                "pbVar9": "nextByte",
                "lVar10": "typeData",
                "uVar11": "parseAndValidateResult",
                "pcVar12": "type",
                "sVar13": "length",
                "uVar14": "unsignedParsedInteger",
                "__ptr": "copiedString",
                "lVar15": "dataValue",
                "puVar16": "parsedValue",
                "puVar17": "parsedValue_2",
                "ppcVar18": "parsedInput",
                "pcVar19": "typeName",
                "local_49": "localVariable_1",
                "local_48": "localVariable_2",
                "local_40": "localStringArray"
            },
            "code": "\nundefined8 parseInitializeData_0010c95e(undefined8 *data,byte **input,long *result)\n\n{\n  byte byte1;\n  byte byte2;\n  byte *currentByte;\n  bool isSignedChar;\n  bool isUnsignedChar;\n  bool isFloat;\n  char parseResult;\n  uint parsedInteger;\n  byte *nextByte;\n  long typeData;\n  undefined8 parseAndValidateResult;\n  char *type;\n  size_t length;\n  ulong unsignedParsedInteger;\n  void *copiedString;\n  long dataValue;\n  ulong *parsedValue;\n  undefined *parsedValue_2;\n  char **parsedInput;\n  char *typeName;\n  byte *pbyte20;\n  undefined localVariable_1;\n  ulong localVariable_2;\n  char *localStringArray [2];\n  \n  while( true ) {\n    pbyte20 = *input;\n    byte1 = *pbyte20;\n    if ('T' < (char)byte1) break;\n    if ((char)byte1 < 'A') goto switchD_0010c9b2_caseD_42;\n    switch(byte1) {\n    case 0x41:\n      dataValue = 0;\n      currentByte = pbyte20;\n      goto LAB_0010ca26;\n    default:\n      goto switchD_0010c9b2_caseD_42;\n    case 0x43:\n      *input = pbyte20 + 1;\n      parseResult = parseInitializeData_0010c95e(data,input,result);\n      if (parseResult == '\\0') {\n        return 0;\n      }\n      if (result == (long *)0x0) {\n        return 1;\n      }\n      dataValue = initialize_data_00113b71(*result);\n      *result = dataValue;\n      return 1;\n    case 0x46:\n      *input = pbyte20 + 1;\n      if (result == (long *)0x0) {\n        parsedValue = (ulong *)0x0;\n        parsedInput = (char **)0x0;\n      }\n      else {\n        parsedValue = &localVariable_2;\n        parsedInput = localStringArray;\n      }\n      parseResult = parse_input_0010d882(data,input,parsedInput,parsedValue);\n      if (parseResult == '\\0') {\n        return 0;\n      }\n      if (**input == 0x5f) {\n        *input = *input + 1;\n        parseResult = parseInitializeData_0010c95e(data,input,result);\n        if (parseResult == '\\0') {\n          return 0;\n        }\n        if (result == (long *)0x0) {\n          return 1;\n        }\n        dataValue = initialize_and_store_data_00113ce0(*result,localStringArray[0],localVariable_2 & 0xff);\n        *result = dataValue;\n        return 1;\n      }\n      goto switchD_0010cdf9_caseD_60;\n    case 0x47:\n      *input = pbyte20 + 1;\n      break;\n    case 0x4d:\n    case 0x4f:\n      localVariable_1 = 0;\n      localStringArray[0] = (char *)0x0;\n      localVariable_2 = 0;\n      *input = pbyte20 + 1;\n      if (((&_sch_istable)[(ulong)pbyte20[1] * 2] & 4) == 0) {\n        if (pbyte20[1] != 0x51) goto switchD_0010cdf9_caseD_60;\n        parsedInput = localStringArray;\n        if (result == (long *)0x0) {\n          parsedInput = (char **)0x0;\n        }\n        parseResult = parse_and_validate_input_0010d559(data,input,parsedInput);\n        if (parseResult == '\\0') {\n          return 0;\n        }\n      }\n      else {\n        parsedInteger = parse_integer_00108e76(input);\n        currentByte = *input;\n        length = strlen((char *)currentByte);\n        if (length < parsedInteger) goto switchD_0010cdf9_caseD_60;\n        *input = currentByte + parsedInteger;\n        if ((result != (long *)0x0) &&\n           (localStringArray[0] = (char *)find_match_and_free_0010afd5(*data,data[1],currentByte,parsedInteger,9),\n           localStringArray[0] == (char *)0x0)) {\n          return 0;\n        }\n      }\n      byte2 = **input;\n      if (byte1 == 0x4d) {\n        if ((byte2 == 0x43) || (byte2 == 0x56)) {\n          *input = *input + 1;\n        }\n        if (**input != 0x46) goto switchD_0010cdf9_caseD_60;\n        *input = *input + 1;\n        if (result == (long *)0x0) {\n          parsedValue_2 = (undefined *)0x0;\n          parsedValue = (ulong *)0x0;\n        }\n        else {\n          parsedValue_2 = &localVariable_1;\n          parsedValue = &localVariable_2;\n        }\n        parseResult = parse_input_0010d882(data,input,parsedValue,parsedValue_2);\n        if (parseResult == '\\0') {\n          return 0;\n        }\n      }\n      if (**input == 0x5f) {\n        *input = *input + 1;\n        parseResult = parseInitializeData_0010c95e(data,input,result);\n        if (parseResult == '\\0') {\n          return 0;\n        }\n        if (result == (long *)0x0) {\n          return 1;\n        }\n        if (byte1 != 0x4d) {\n          dataValue = initialize_and_allocate_00113bfa(localStringArray[0],*result);\n          *result = dataValue;\n          return 1;\n        }\n        dataValue = initialize_data_and_allocate_memory_00113b98(*result,localStringArray[0],localVariable_2,localVariable_1);\n        *result = dataValue;\n        return 1;\n      }\n      goto switchD_0010cdf9_caseD_60;\n    case 0x50:\n      goto switchD_0010c9b2_caseD_50;\n    case 0x51:\n      parseAndValidateResult = parse_and_validate_input_0010d559(data,input,result);\n      return parseAndValidateResult;\n    case 0x52:\n      *input = pbyte20 + 1;\n      parseResult = parseInitializeData_0010c95e(data,input,result);\n      if (parseResult == '\\0') {\n        return 0;\n      }\n      if (result == (long *)0x0) {\n        return 1;\n      }\n      dataValue = initialize_data_00113cb9(*result);\n      *result = dataValue;\n      return 1;\n    case 0x54:\n      *input = pbyte20 + 1;\n      parseResult = parse_integer_00108ea1(input,&localVariable_2);\n      if (parseResult != '\\0') {\n        if ((uint)localVariable_2 < *(uint *)(data + 5)) {\n          localStringArray[0] = *(char **)((localVariable_2 & 0xffffffff) * 0x10 + data[4]);\n          parseResult = parseInitializeData_0010c95e(data,localStringArray,result);\n          if (parseResult == '\\0') {\n            return 0;\n          }\n          return 1;\n        }\n      }\n      goto switchD_0010cdf9_caseD_60;\n    }\n  }\n  if (byte1 == 0x70) {\nswitchD_0010c9b2_caseD_50:\n    *input = pbyte20 + 1;\n    parseResult = parseInitializeData_0010c95e(data,input,result);\n    if (parseResult == '\\0') {\n      return 0;\n    }\n    if (result == (long *)0x0) {\n      return 1;\n    }\n    dataValue = initialize_data_00113d3a(*result);\n    *result = dataValue;\n    return 1;\n  }\nswitchD_0010c9b2_caseD_42:\n  isFloat = false;\n  isSignedChar = false;\n  parseResult = '\\0';\n  isUnsignedChar = false;\n  do {\n    currentByte = *input;\n    byte1 = *currentByte;\n    if (byte1 == 0x55) {\n      parseResult = '\\x01';\n      goto LAB_0010cd84;\n    }\n    if ('U' < (char)byte1) {\n      if (byte1 == 0x56) {\n        isFloat = true;\n        goto LAB_0010cd84;\n      }\n      if ('x' < (char)byte1) goto switchD_0010cdf9_caseD_60;\n      if ((char)byte1 < '_') goto LAB_0010cdfb;\n      switch(byte1) {\n      case 0x5f:\n        goto switchD_0010cdf9_caseD_5f;\n      default:\n        goto switchD_0010cdf9_caseD_60;\n      case 0x62:\n        if (result == (long *)0x0) {\nLAB_0010d0aa:\n          *input = currentByte + 1;\n          return 1;\n        }\n        dataValue = find_named_type_0010914e(*data,&DAT_00120436);\n        *result = dataValue;\n        if (dataValue == 0) {\n          dataValue = initialize_data_00112904(6,4);\n          *result = dataValue;\n          *input = *input + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 99:\n        if (result == (long *)0x0) goto LAB_0010d0aa;\n        typeName = \"unsigned char\";\n        if ((parseResult == '\\0') && (typeName = \"char\", isSignedChar)) {\n          typeName = \"signed char\";\n        }\n        dataValue = find_named_type_0010914e(*data,typeName);\n        *result = dataValue;\n        if (dataValue == 0) {\n          dataValue = update_data_00113dfe(1,parseResult);\n          *result = dataValue;\n          *input = *input + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 100:\n        if (result == (long *)0x0) goto LAB_0010d0aa;\n        typeName = \"double\";\n        goto LAB_0010d046;\n      case 0x66:\n        if (result == (long *)0x0) goto LAB_0010d0aa;\n        dataValue = find_named_type_0010914e(*data,\"float\");\n        *result = dataValue;\n        if (dataValue == 0) {\n          dataValue = initialize_data_00113df2(4);\n          *result = dataValue;\n          *input = *input + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x69:\n        if (result == (long *)0x0) goto LAB_0010d0aa;\n        typeName = \"unsigned int\";\n        type = \"int\";\n        goto LAB_0010ced2;\n      case 0x6c:\n        if (result == (long *)0x0) goto LAB_0010d0aa;\n        typeName = \"long unsigned int\";\n        type = \"long int\";\nLAB_0010ced2:\n        if (parseResult == '\\0') {\n          typeName = type;\n        }\n        dataValue = find_named_type_0010914e(*data,typeName);\n        *result = dataValue;\n        if (dataValue == 0) {\n          dataValue = update_data_00113dfe(4,parseResult);\n          *result = dataValue;\n          *input = *input + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x72:\n        typeName = \"long double\";\n        if (result == (long *)0x0) goto LAB_0010d0aa;\nLAB_0010d046:\n        dataValue = find_named_type_0010914e(*data,typeName);\n        *result = dataValue;\n        if (dataValue == 0) {\n          dataValue = initialize_data_00113df2(8);\n          *result = dataValue;\n          *input = *input + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x73:\n        if (result == (long *)0x0) goto LAB_0010d0aa;\n        typeName = \"short unsigned int\";\n        if (parseResult == '\\0') {\n          typeName = \"short int\";\n        }\n        dataValue = find_named_type_0010914e(*data,typeName);\n        *result = dataValue;\n        if (dataValue == 0) {\n          dataValue = update_data_00113dfe(2,parseResult);\n          *result = dataValue;\n          *input = *input + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x74:\n        parsedInput = localStringArray;\n        if (result == (long *)0x0) {\n          parsedInput = (char **)0x0;\n        }\n        parseResult = parse_and_validate_input_0010d21c(data,input,parsedInput);\n        if (parseResult == '\\0') {\n          return 0;\n        }\n        if (result == (long *)0x0) {\n          return 1;\n        }\n        length = strlen(localStringArray[0]);\n        dataValue = find_match_and_free_0010afd5(*data,data[1],localStringArray[0],length & 0xffffffff,9);\n        *result = dataValue;\n        free(localStringArray[0]);\n        dataValue = *result;\n        goto joined_r0x0010d1d8;\n      case 0x76:\n        if (result == (long *)0x0) goto LAB_0010d0aa;\n        dataValue = find_named_type_0010914e(*data,&DAT_00120495);\n        *result = dataValue;\n        if (dataValue == 0) {\n          dataValue = initialize_data_00113e17();\n          *result = dataValue;\n          *input = *input + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x77:\n        if (result == (long *)0x0) goto LAB_0010d0aa;\n        dataValue = find_named_type_0010914e(*data,\"__wchar_t\");\n        *result = dataValue;\n        if (dataValue == 0) {\n          dataValue = update_data_00113dfe(2,1);\n          *result = dataValue;\n          *input = *input + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x78:\n        if (result == (long *)0x0) goto LAB_0010d0aa;\n        typeName = \"long long unsigned int\";\n        if (parseResult == '\\0') {\n          typeName = \"long long int\";\n        }\n        dataValue = find_named_type_0010914e(*data,typeName);\n        *result = dataValue;\n        if (dataValue == 0) {\n          dataValue = update_data_00113dfe(8,parseResult);\n          *result = dataValue;\n        }\n      }\n      *input = *input + 1;\n      goto LAB_0010d1de;\n    }\n    if (byte1 == 0x43) {\n      isUnsignedChar = true;\n      goto LAB_0010cd84;\n    }\n    if (byte1 != 0x53) goto LAB_0010cdc5;\n    isSignedChar = true;\nLAB_0010cd84:\n    *input = currentByte + 1;\n  } while( true );\nLAB_0010ca26:\n  nextByte = currentByte + 1;\n  *input = nextByte;\n  byte1 = *nextByte;\n  if (byte1 == 0) goto switchD_0010cdf9_caseD_60;\n  if (byte1 == 0x5f) {\n    *input = currentByte + 2;\n    parseResult = parseInitializeData_0010c95e(data,input,result);\n    if (parseResult == '\\0') {\n      return 0;\n    }\n    if (result == (long *)0x0) {\n      return 1;\n    }\n    typeData = find_named_type_0010914e(*data,\"int\");\n    if (typeData == 0) {\n      typeData = update_data_00113dfe(4,0);\n    }\n    dataValue = initialize_and_store_data_00113c43(*result,typeData,0,dataValue,0);\n    *result = dataValue;\n    return 1;\n  }\n  if (((&_sch_istable)[(ulong)byte1 * 2] & 4) == 0) goto switchD_0010cdf9_caseD_60;\n  dataValue = dataValue * 10 + (long)((char)byte1 + -0x30);\n  currentByte = nextByte;\n  goto LAB_0010ca26;\nLAB_0010cdc5:\n  if ((char)byte1 < ':') {\n    if ((char)byte1 < '0') {\n      if (byte1 != 0) goto switchD_0010cdf9_caseD_60;\nswitchD_0010cdf9_caseD_5f:\n      print_error_message_0010911f(pbyte20);\n      if (result == (long *)0x0) {\n        return 1;\n      }\n      goto LAB_0010d1de;\n    }\n  }\n  else {\nLAB_0010cdfb:\n    if ((byte1 != 0x47) || (*input = currentByte + 1, ((&_sch_istable)[(ulong)currentByte[1] * 2] & 4) == 0)\n       ) goto switchD_0010cdf9_caseD_60;\n  }\n  pbyte20 = *input;\n  parsedInteger = parse_integer_00108e76(input);\n  currentByte = *input;\n  length = strlen((char *)currentByte);\n  unsignedParsedInteger = (ulong)parsedInteger;\n  if (unsignedParsedInteger <= length) {\n    *input = currentByte + unsignedParsedInteger;\n    if (result == (long *)0x0) {\n      return 1;\n    }\n    copiedString = (void *)copy_and_null_terminate_00109a0b(currentByte,unsignedParsedInteger);\n    dataValue = find_named_type_0010914e(*data,copiedString);\n    *result = dataValue;\n    free(copiedString);\n    if (*result == 0) {\n      dataValue = find_match_and_free_0010afd5(*data,data[1],currentByte,(int)*input - (int)currentByte,0);\n      *result = dataValue;\njoined_r0x0010d1d8:\n      if (dataValue == 0) {\n        return 0;\n      }\n    }\nLAB_0010d1de:\n    if (isUnsignedChar) {\n      dataValue = initialize_data_00113b71(*result);\n      *result = dataValue;\n    }\n    if (isFloat) {\n      dataValue = initialize_data_00113b4a(*result);\n      *result = dataValue;\n    }\n    return 1;\n  }\nswitchD_0010cdf9_caseD_60:\n  print_error_message_0010911f(pbyte20);\n  return 0;\n}\n\n",
            "called": [
                "FUN_00113b98",
                "FUN_0010c95e",
                "strlen",
                "FUN_00113d3a",
                "FUN_0010914e",
                "FUN_00113c43",
                "FUN_00113ce0",
                "FUN_0010d21c",
                "FUN_00109a0b",
                "FUN_00113b71",
                "FUN_0010911f",
                "FUN_00113b4a",
                "FUN_0010d559",
                "FUN_00113bfa",
                "FUN_00108e76",
                "FUN_0010d882",
                "free",
                "FUN_0010afd5",
                "FUN_00113df2",
                "FUN_00113dfe",
                "FUN_00113cb9",
                "FUN_00113e17",
                "FUN_00108ea1",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c95e",
            "calling": [
                "FUN_0010c95e",
                "FUN_00113e5e",
                "FUN_0010d21c",
                "FUN_0010d7d4"
            ],
            "imported": false,
            "current_name": "parse_initialize_data_0010c95e"
        },
        "FUN_00107880": {
            "renaming": {
                "FUN_00107880": "FUNC_00107880"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong FUNC_00107880(void)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  undefined *puVar3;\n  long *plVar4;\n  code *pcVar5;\n  long *plVar6;\n  ulong uVar7;\n  ulong uVar8;\n  char *__s;\n  char cVar9;\n  char cVar10;\n  uint uVar11;\n  int iVar12;\n  uint uVar13;\n  undefined4 uVar14;\n  int iVar15;\n  long *plVar16;\n  long lVar17;\n  undefined8 uVar18;\n  undefined8 uVar19;\n  size_t sVar20;\n  size_t sVar21;\n  char *pcVar22;\n  void *__ptr;\n  void *__ptr_00;\n  ulong uVar23;\n  long lVar24;\n  ulong uVar25;\n  long in_RAX;\n  int *piVar26;\n  long lVar27;\n  ulong uVar28;\n  FILE *__s_00;\n  long **pplVar29;\n  long **__ptr_01;\n  char *pcVar30;\n  undefined8 *puVar31;\n  ulong uVar32;\n  int iVar33;\n  long **pplVar34;\n  char *pcVar35;\n  undefined4 *puVar36;\n  undefined8 *puVar37;\n  char **ppcVar38;\n  void *pvVar39;\n  undefined8 *unaff_R14;\n  undefined **ppuVar40;\n  bool bVar41;\n  byte bVar42;\n  long param_7;\n  ulong param_8;\n  char param_9;\n  undefined4 *param_10;\n  char *pcStack0000000000000038;\n  uint uStack0000000000000048;\n  int param_11;\n  long param_12;\n  long lStack0000000000000088;\n  char *pcStack0000000000000090;\n  long lStack00000000000000a0;\n  long *in_stack_000000c0;\n  ulong in_stack_000000c8;\n  long in_stack_000000d0;\n  long in_stack_000000d8;\n  void *in_stack_000000e0;\n  long in_stack_000000f0;\n  undefined8 in_stack_000000f8;\n  byte bStack0000000000000100;\n  byte bStack0000000000000101;\n  undefined8 in_stack_00000110;\n  ushort in_stack_00000118;\n  char *param_13;\n  char cStack0000000000000148;\n  char *in_stack_00000150;\n  undefined uStack0000000000000158;\n  short sStack000000000000015a;\n  \n  bVar42 = 0;\n  cVar10 = (**(code **)(*(long *)(param_7 + 8) + 0x2a0))\n                     (param_7,**(undefined4 **)(in_RAX + 0x380),0);\n  if (cVar10 == '\\0') {\n    if ((*(byte *)(unaff_R14 + 9) & 0x40) != 0) {\n      iVar12 = bfd_get_arch();\n      if (iVar12 == 0) {\n        uVar19 = get_formatted_string_001125fa();\n        uVar18 = dcgettext(0,\"Unable to recognise the format of the input file `%s\\'\",5);\n        print_error_message_00119ed0(uVar18,uVar19);\n        return 0;\n      }\n      uVar19 = bfd_get_mach();\n      uVar14 = bfd_get_arch();\n      uVar19 = bfd_printable_arch_mach(uVar14,uVar19);\n      uVar18 = dcgettext(0,\"Output file cannot represent architecture `%s\\'\",5);\n      print_error_message_00119ed0(uVar18,uVar19);\n      return 0;\n    }\n    iVar12 = bfd_get_arch();\n    iVar33 = bfd_get_arch(param_7);\n    if (iVar12 != iVar33) {\n      uVar28 = check_file_architecture_00105828();\n      return uVar28;\n    }\n  }\n  cVar10 = bfd_set_format(param_7,*(byte *)(unaff_R14 + 9) & 7);\n  if (cVar10 == '\\0') {\nLAB_00107a82:\n    display_error_001126c0(0);\n    return 0;\n  }\n  if ((*(int *)(*(undefined8 **)(param_7 + 8) + 1) == 2) &&\n     (cVar10 = compare_strings_00113fb0(**(undefined8 **)(param_7 + 8),&DAT_0011b503), cVar10 != '\\0')) {\n    lVar27 = *(long *)(param_7 + 0x110);\n    if ((*(int *)((undefined8 *)unaff_R14[1] + 1) == 2) &&\n       (cVar10 = compare_strings_00113fb0(*(undefined8 *)unaff_R14[1],&DAT_0011b503), cVar10 != '\\0')) {\n      lVar17 = unaff_R14[0x22];\n      bVar41 = DAT_001279cb == '\\0';\n      puVar31 = (undefined8 *)(lVar17 + 200);\n      puVar37 = (undefined8 *)(lVar27 + 200);\n      for (lVar24 = 0x32; lVar24 != 0; lVar24 = lVar24 + -1) {\n        *puVar37 = *puVar31;\n        puVar31 = puVar31 + (ulong)bVar42 * -2 + 1;\n        puVar37 = puVar37 + (ulong)bVar42 * -2 + 1;\n      }\n      if (bVar41) {\n        *(undefined4 *)(lVar27 + 0x2a4) = 0xffffffff;\n      }\n      else {\n        *(int *)(lVar27 + 0x2a4) = (int)*(undefined8 *)(lVar17 + 0xa8);\n      }\n    }\n    uVar28 = DAT_001264a8;\n    if (DAT_001264a8 == 0xffffffffffffffff) {\n      DAT_001264a8 = 0x200;\n      uVar28 = 0x200;\n    }\n    else {\n      *(int *)(lVar27 + 0x10c) = (int)DAT_001264a8;\n    }\n    if (DAT_00126498 != -1) {\n      *(long *)(lVar27 + 0x148) = DAT_00126498;\n    }\n    if (DAT_001264a0 != -1) {\n      *(long *)(lVar27 + 0x148) = DAT_001264a0;\n    }\n    if (DAT_00126490 != -1) {\n      *(long *)(lVar27 + 0x100) = DAT_00126490;\n    }\n    uVar23 = DAT_00126488;\n    if (DAT_00126488 == 0xffffffffffffffff) {\n      DAT_00126488 = 0x1000;\n      uVar23 = 0x1000;\n    }\n    else {\n      *(int *)(lVar27 + 0x108) = (int)DAT_00126488;\n    }\n    if (DAT_00126478 != -1) {\n      *(long *)(lVar27 + 0x138) = DAT_00126478;\n    }\n    if (DAT_00126480 != -1) {\n      *(long *)(lVar27 + 0x138) = DAT_00126480;\n    }\n    if (DAT_00126474 != -1) {\n      *(short *)(lVar27 + 300) = DAT_00126474;\n    }\n    if (DAT_00126472 != -1) {\n      *(short *)(lVar27 + 0x118) = DAT_00126472;\n    }\n    if (DAT_00126470 != -1) {\n      *(short *)(lVar27 + 0x11a) = DAT_00126470;\n    }\n    if (uVar23 < uVar28) {\n      uVar19 = dcgettext(0,\"warning: file alignment (0x%lx) > section alignment (0x%lx)\",5);\n      print_error_message_00119ed0(uVar19,uVar28,uVar23);\n    }\n  }\n  plVar6 = DAT_001278b0;\n  free(DAT_001278b0);\n  if (plVar6 == DAT_001278a8) {\n    DAT_001278b0 = (long *)0x0;\n    DAT_001278a8 = (long *)0x0;\n    lVar27 = (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  else {\n    free(DAT_001278a8);\n    DAT_001278b0 = (long *)0x0;\n    DAT_001278a8 = (long *)0x0;\n    lVar27 = (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  if (lVar27 < 0) goto LAB_00107a82;\n  DAT_001278a8 = (long *)xmalloc();\n  DAT_001278b0 = DAT_001278a8;\n  param_8 = (**(code **)(unaff_R14[1] + 0x200))();\n  if ((long)param_8 < 0) goto LAB_00107a82;\n  if (param_8 == 0) {\n    free(DAT_001278b0);\n    DAT_001278b0 = (long *)0x0;\n    DAT_001278a8 = (long *)0x0;\n  }\n  bfd_map_over_sections();\n  puVar31 = DAT_001279c0;\n  if ((DAT_001278ec == '\\0') &&\n     (cVar10 = (**(code **)(*(long *)(param_7 + 8) + 0x168))(), puVar31 = DAT_001279c0,\n     cVar10 == '\\0')) {\n    DAT_00127a20 = 1;\n    dcgettext(0,\"error in private header data\",5);\n    display_error_001126c0(0);\n    puVar31 = DAT_001279c0;\n  }\n  for (; puVar37 = DAT_001279b8, puVar31 != (undefined8 *)0x0; puVar31 = (undefined8 *)*puVar31) {\n    uVar11 = 0x128;\n    lVar27 = parse_rules_00114190(puVar31[1],0,0x80);\n    if (lVar27 != 0) {\n      uVar11 = drop_share_flag_if_not_coff_00115f30(*(uint *)(lVar27 + 0x28) | 0x100,param_7,puVar31[1]);\n    }\n    lVar27 = bfd_get_section_by_name(param_7,puVar31[1]);\n    if (lVar27 != 0) {\n      uVar19 = puVar31[1];\n      uVar18 = dcgettext(0,\"can\\'t add section \\'%s\\'\",5);\n      display_error_001126c0(0,param_7,0,uVar18,uVar19);\n      return 0;\n    }\n    lVar27 = bfd_make_section_with_flags(param_7,puVar31[1],uVar11 | 0x100000);\n    puVar31[5] = lVar27;\n    if (lVar27 == 0) {\n      uVar19 = puVar31[1];\n      uVar18 = dcgettext(0,\"can\\'t create section `%s\\'\",5);\n      display_error_001126c0(0,param_7,0,uVar18,uVar19);\n      return 0;\n    }\n    cVar10 = bfd_set_section_size();\n    if (cVar10 == '\\0') {\n      display_error_001126c0(0,param_7,puVar31[5],0);\n      return 0;\n    }\n    lVar27 = parse_rules_00114190(puVar31[1],0,0x18);\n    if (lVar27 != 0) {\n      uVar19 = *(undefined8 *)(lVar27 + 0x18);\n      lVar27 = puVar31[5];\n      *(byte *)(lVar27 + 0x28) = *(byte *)(lVar27 + 0x28) | 1;\n      *(undefined8 *)(lVar27 + 0x30) = uVar19;\n      *(undefined8 *)(lVar27 + 0x38) = uVar19;\n    }\n    lVar27 = parse_rules_00114190(puVar31[1],0,0x60);\n    if (lVar27 != 0) {\n      lVar17 = puVar31[5];\n      *(undefined8 *)(lVar17 + 0x38) = *(undefined8 *)(lVar27 + 0x20);\n      if (0x3e < *(uint *)(lVar17 + 0x7c)) {\n        display_error_001126c0(0,param_7,lVar17,0);\n        return 0;\n      }\n    }\n  }\n  for (; puVar37 != (undefined8 *)0x0; puVar37 = (undefined8 *)*puVar37) {\n    lVar27 = bfd_get_section_by_name();\n    puVar37[5] = lVar27;\n    if (lVar27 == 0) {\n      uVar19 = puVar37[1];\n      uVar18 = dcgettext(0,\"error: %s not found, can\\'t be updated\",5);\n      print_error_message_00119ed0(uVar18,uVar19);\n      return 0;\n    }\n    uVar19 = *(undefined8 *)(lVar27 + 0x60);\n    cVar10 = bfd_set_section_size(uVar19);\n    if (cVar10 == '\\0') {\n      display_error_001126c0(0,param_7,uVar19,0);\n      return 0;\n    }\n  }\n  puVar31 = DAT_001279b0;\n  if (DAT_00127a00 == '\\0') {\n    __ptr_01 = (long **)0x0;\n  }\n  else {\n    pplVar34 = (long **)unaff_R14[0x12];\n    __ptr_01 = pplVar34;\n    if (pplVar34 != (long **)0x0) {\n      __ptr_01 = (long **)0x0;\nLAB_001151ab:\n      if (DAT_00127a00 != '\\0') goto LAB_00115187;\n      for (plVar6 = pplVar34[1]; puVar31 = DAT_001279b0, plVar6 != (long *)0x0;\n          plVar6 = (long *)plVar6[1]) {\n      }\n    }\n  }\njoined_r0x001151c7:\n  for (; puVar31 != (undefined8 *)0x0; puVar31 = (undefined8 *)*puVar31) {\n    lVar27 = bfd_get_section_by_name();\n    if (lVar27 == 0) {\n      dcgettext(0,\"can\\'t dump section \\'%s\\' - it does not exist\",5);\n      display_error_001126c0(0);\n    }\n    else if ((*(byte *)(lVar27 + 0x25) & 1) == 0) {\n      dcgettext(0,\"can\\'t dump section - it has no contents\",5);\n      display_error_001126c0(0);\n    }\n    else {\n      sVar20 = *(size_t *)(lVar27 + 0x40);\n      __s_00 = fopen((char *)puVar31[2],\"w\");\n      if (__s_00 == (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        display_error_001126c0(puVar31[2],0,0);\n      }\n      else {\n        cVar10 = bfd_malloc_and_get_section();\n        if (cVar10 == '\\0') {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          display_error_001126c0(0);\n        }\n        else if ((sVar20 != 0) && (sVar21 = fwrite(param_13,1,sVar20,__s_00), sVar21 != sVar20)) {\n          piVar26 = __errno_location();\n          pcVar35 = strerror(*piVar26);\n          uVar19 = puVar31[2];\n          uVar18 = dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          print_error_message_00119ed0(uVar18,uVar19,pcVar35);\n          free(param_13);\n          fclose(__s_00);\n          return 0;\n        }\n        fclose(__s_00);\n        free(param_13);\n      }\n    }\n  }\n  if (DAT_00127a10 == 0) {\nLAB_0010790a:\n    param_12 = 0;\n  }\n  else {\n    lVar27 = bfd_get_section_by_name(param_7,\".gnu_debuglink\");\n    if (lVar27 != 0) {\n      uVar19 = dcgettext(0,\"%s: debuglink section already exists\",5);\n      print_error_message_00119ed0(uVar19);\n      DAT_00127a10 = 0;\n      goto LAB_0010790a;\n    }\n    param_12 = bfd_create_gnu_debuglink_section(param_7);\n    lVar27 = DAT_00127a10;\n    if (param_12 == 0) {\n      uVar19 = dcgettext(0,\"cannot create debug link section `%s\\'\",5);\n      display_error_001126c0(0,param_7,0,uVar19,lVar27);\n      return 0;\n    }\n    if (*(int *)(*(long *)(param_7 + 8) + 8) == 2) {\n      uVar23 = 0;\n      for (uVar28 = *(ulong *)(param_7 + 0x90); uVar28 != 0; uVar28 = *(ulong *)(uVar28 + 8)) {\n        uVar25 = *(ulong *)(uVar28 + 0x30);\n        uVar32 = uVar23;\n        uVar7 = uVar28;\n        uVar8 = uVar23;\n        if (uVar25 != 0) {\n          while ((uVar32 = uVar7, uVar8 != 0 &&\n                 (uVar32 = uVar28, uVar25 <= *(ulong *)(uVar23 + 0x30)))) {\n            uVar28 = *(ulong *)(uVar28 + 8);\n            if (uVar28 == 0) goto LAB_00107db8;\n            uVar25 = *(ulong *)(uVar28 + 0x30);\n            uVar7 = uVar23;\n            uVar8 = uVar25;\n          }\n        }\n        uVar23 = uVar32;\n      }\nLAB_00107db8:\n      if (uVar23 == 0) {\n        uVar28 = 0x1000;\n      }\n      else {\n        uVar23 = *(long *)(uVar23 + 0x40) + *(long *)(uVar23 + 0x30);\n        uVar28 = 0xffffffffffffffff;\n        if (uVar23 < 0xfffffffffffff001) {\n          uVar28 = uVar23 + 0xfff & 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(param_12 + 0x28) = *(byte *)(param_12 + 0x28) | 1;\n      *(ulong *)(param_12 + 0x30) = uVar28;\n      *(ulong *)(param_12 + 0x38) = uVar28;\n    }\n  }\n  plVar6 = DAT_001278b0;\n  param_11 = *(int *)(param_7 + 0xa0);\n  if (param_11 != 0) {\n    uVar28 = process_debug_info_0010554f();\n    return uVar28;\n  }\n  if (DAT_00127980 == '\\0') {\nLAB_00105588:\n    param_10 = (undefined4 *)0x0;\n  }\n  else {\n    ppuVar40 = &PTR_s__stab_00125c60;\n    param_10 = (undefined4 *)xmalloc(0x60);\n    puVar36 = param_10;\n    for (lVar27 = 0x18; lVar27 != 0; lVar27 = lVar27 + -1) {\n      *puVar36 = 0;\n      puVar36 = puVar36 + (ulong)bVar42 * -2 + 1;\n    }\n    pcStack0000000000000038 = (char *)0x0;\n    do {\n      puVar3 = *ppuVar40;\n      lVar27 = bfd_get_section_by_name();\n      lVar17 = bfd_get_section_by_name();\n      if ((lVar27 != 0) && (lVar17 != 0)) {\n        lVar27 = *(long *)(lVar27 + 0x40);\n        __ptr = (void *)xmalloc(lVar27);\n        cVar10 = bfd_get_section_contents();\n        if (cVar10 == '\\0') {\n          uVar14 = bfd_get_error();\n          bfd_errmsg(uVar14);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n          free(pcStack0000000000000038);\n          free(__ptr);\n        }\n        else {\n          uVar28 = *(ulong *)(lVar17 + 0x40);\n          __ptr_00 = (void *)xmalloc(uVar28 + 1);\n          param_9 = bfd_get_section_contents();\n          if (param_9 == '\\0') {\n            uVar14 = bfd_get_error();\n            bfd_errmsg(uVar14);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n            free(pcStack0000000000000038);\n          }\n          else {\n            *(undefined *)((long)__ptr_00 + uVar28) = 0;\n            if ((pcStack0000000000000038 != (char *)0x0) ||\n               (pcStack0000000000000038 = (char *)initialize_data_structure_00112894(),\n               pcStack0000000000000038 != (char *)0x0)) {\n              lStack00000000000000a0 = 0;\n              lStack0000000000000088 = 0;\n              for (pvVar39 = __ptr; pvVar39 <= (void *)((long)__ptr + lVar27 + -0xc);\n                  pvVar39 = (void *)((long)pvVar39 + 0xc)) {\n                uVar23 = (**(code **)(unaff_R14[1] + 0x40))(pvVar39);\n                bVar2 = *(byte *)((long)pvVar39 + 4);\n                uVar14 = (**(code **)(unaff_R14[1] + 0x58))((long)pvVar39 + 6);\n                lVar17 = (**(code **)(unaff_R14[1] + 0x40))((long)pvVar39 + 8);\n                if (bVar2 == 0) {\n                  lStack0000000000000088 = lStack00000000000000a0;\n                  lStack00000000000000a0 = lStack00000000000000a0 + lVar17;\n                }\n                else {\n                  uVar25 = (uVar23 & 0xffffffff) + lStack0000000000000088;\n                  if (uVar25 < uVar28) {\n                    pcVar35 = (char *)((long)__ptr_00 + uVar25);\n                    pcStack0000000000000090 = (char *)0x0;\n                    while( true ) {\n                      sVar20 = strlen(pcVar35);\n                      if (((sVar20 == 0) || (pcVar30 = pcVar35 + (sVar20 - 1), *pcVar30 != '\\\\')) ||\n                         ((ulong)((long)__ptr + lVar27) < (long)pvVar39 + 0x10U)) goto LAB_001077fb;\n                      *pcVar30 = '\\0';\n                      pvVar39 = (void *)((long)pvVar39 + 0xc);\n                      iVar12 = (**(code **)(unaff_R14[1] + 0x40))(pvVar39);\n                      uVar23 = (ulong)(uint)(iVar12 + (int)lStack0000000000000088);\n                      if (uVar28 <= uVar23) break;\n                      pcVar35 = (char *)concat(pcVar35,(long)__ptr_00 + uVar23,0);\n                      *pcVar30 = '\\\\';\n                      free(pcStack0000000000000090);\n                      pcStack0000000000000090 = pcVar35;\n                    }\n                    uVar19 = *unaff_R14;\n                    pcVar30 = (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar30,uVar19,puVar3,((long)pvVar39 - (long)__ptr) / 0xc);\nLAB_001077fb:\n                    update_data_entry_001088ae((ulong)bVar2,uVar14,lVar17,pcVar35);\n                    cVar10 = process_debug_info_0011173a(param_10,pcStack0000000000000038,bVar2);\n                    if (cVar10 == '\\0') {\n                      print_stab_entries_00108b3e();\n                      free_memory_and_reset_00108863();\n                      free(pcStack0000000000000090);\n                      free(pcStack0000000000000038);\n                      free(__ptr);\n                      free(__ptr_00);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar19 = *unaff_R14;\n                    pcVar35 = (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar35,uVar19,puVar3,((long)pvVar39 - (long)__ptr) / 0xc,\n                            uVar23 & 0xffffffff,(ulong)bVar2,((long)pvVar39 - (long)__ptr) % 0xc);\n                  }\n                }\n              }\n              free_memory_and_reset_00108863();\n              free(__ptr);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_00);\n          free(__ptr);\n        }\n        goto LAB_00105981;\n      }\nLAB_001058eb:\n      ppuVar40 = ppuVar40 + 2;\n    } while (ppuVar40 != (undefined **)&DAT_00125c90);\n    if ((pcStack0000000000000038 != (char *)0x0) && (cVar10 = process_debug_info_0010c892(), cVar10 == '\\0')) {\nLAB_00105981:\n      free(param_10);\n      goto LAB_00105588;\n    }\n    if (*(int *)(unaff_R14[1] + 8) == 1) {\n      lVar27 = 0;\n      for (plVar16 = plVar6; plVar16 < plVar6 + param_8; plVar16 = plVar16 + 1) {\n        (**(code **)(unaff_R14[1] + 0x218))();\n        if (cStack0000000000000148 == '-') {\n          if (((lVar27 == 0) && (lVar27 = initialize_data_structure_00112894(), lVar27 == 0)) ||\n             ((in_stack_00000150 == (char *)0x0 || (*in_stack_00000150 == '\\0'))))\n          goto LAB_00105981;\n          pcVar35 = (char *)0x0;\n          pcVar30 = in_stack_00000150;\n          while (((*pcVar30 != '\\0' && (sVar20 = strlen(pcVar30), pcVar30[sVar20 - 1] == '\\\\')) &&\n                 (plVar16 + 1 < plVar6 + param_8))) {\n            pcVar22 = (char *)xstrdup(pcVar30);\n            sVar20 = strlen(pcVar22);\n            pcVar22[sVar20 - 1] = '\\0';\n            pcVar30 = (char *)concat(pcVar22,*(undefined8 *)(plVar16[1] + 8),0);\n            free(pcVar22);\n            free(pcVar35);\n            plVar16 = plVar16 + 1;\n            pcVar35 = pcVar30;\n          }\n          update_data_entry_001088ae(uStack0000000000000158,(int)sStack000000000000015a,param_13,pcVar30);\n          param_9 = process_debug_info_0011173a(param_10,lVar27,uStack0000000000000158);\n          if (param_9 == '\\0') {\n            print_stab_entries_00108b3e();\n            free_memory_and_reset_00108863();\n            goto LAB_00105981;\n          }\n        }\n      }\n      free_memory_and_reset_00108863();\n      if ((lVar27 != 0) && (cVar10 = process_debug_info_0010c892(), cVar10 == '\\0')) goto LAB_00105981;\n    }\n    if (param_9 == '\\0') {\n      if ((*(int *)(unaff_R14[1] + 8) == 2) && (param_8 != 0)) {\n        param_13 = (char *)0x0;\n        in_stack_000000c0 = plVar6;\n        in_stack_000000d0 = 0;\n        in_stack_000000d8 = 0;\n        puVar31 = (undefined8 *)&stack0x00000148;\n        for (lVar27 = 0x22; lVar27 != 0; lVar27 = lVar27 + -1) {\n          *(undefined4 *)puVar31 = 0;\n          puVar31 = (undefined8 *)((long)puVar31 + (ulong)bVar42 * -8 + 4);\n        }\n        cVar10 = '\\0';\n        _uStack0000000000000048 = (int *)0x0;\n        pcStack0000000000000038 = (char *)0x0;\n        pcStack0000000000000090 = (char *)0xffffffffffffffff;\n        in_stack_000000c8 = param_8;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((long)param_8 <= in_stack_000000d0) goto LAB_00105590;\n            lVar27 = plVar6[in_stack_000000d0];\n            cVar9 = bfd_coff_get_syment();\n            lVar17 = in_stack_000000d8;\n            if (cVar9 == '\\0') {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar35 = \"bfd_coff_get_syment failed: %s\";\n              goto LAB_00105968;\n            }\n            pcVar35 = *(char **)(lVar27 + 8);\n            in_stack_000000d0 = in_stack_000000d0 + 1;\n            in_stack_000000d8 = (ulong)bStack0000000000000101 + 1 + in_stack_000000d8;\n            if ((bStack0000000000000101 != 0) && (cVar9 = bfd_coff_get_auxent(), cVar9 == '\\0')) {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar35 = \"bfd_coff_get_auxent failed: %s\";\n              goto LAB_00105968;\n            }\n            if (pcStack0000000000000090 != (char *)lVar17) break;\n            if (bStack0000000000000100 != 0x67) {\n              cVar9 = initialize_debug_info_0010bbd3(param_10);\n              if (cVar9 != '\\0') break;\n              goto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            pcStack0000000000000090 = (char *)in_stack_000000f0;\n            cVar9 = initialize_debug_info_0010bbd3(param_10);\n            if (cVar9 == '\\0') goto LAB_00105981;\n          }\n          if ((char)bStack0000000000000100 < '\\0') {\n            if (bStack0000000000000100 == 0xff) goto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            lVar24 = parse_and_initialize_data_0010dac0();\n            if (lVar24 == 0) break;\n            cVar9 = process_parameter_00112a33(&stack0x00000140,lVar27,lVar17);\n          }\n          else {\n            if (bStack0000000000000100 < 100) {\n              switch(bStack0000000000000100) {\n              case 3:\n                if (in_stack_000000f8._6_2_ == 0) goto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulong)((uint)in_stack_000000f8._6_2_ & *(uint *)(unaff_R14[0x22] + 0x40)) !=\n                    2L << ((byte)*(undefined4 *)(unaff_R14[0x22] + 0x3c) & 0x3f)) goto LAB_0010700a;\n                _uStack0000000000000048 = (int *)(**(code **)(unaff_R14[1] + 0x238))();\n                pcStack0000000000000038 = pcVar35;\n                goto switchD_00106e1a_caseD_68;\n              default:\n                goto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                goto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(bStack0000000000000100) {\n            case 100:\n              iVar12 = strcmp(pcVar35,\".bb\");\n              if (iVar12 == 0) {\n                cVar9 = start_debug_block_0010be88(param_10);\n              }\n              else {\n                iVar12 = strcmp(pcVar35,\".eb\");\n                if (iVar12 != 0) goto switchD_00106e1a_caseD_68;\n                cVar9 = debug_end_block_check_0010bf20(param_10);\n              }\n              break;\n            case 0x65:\n              iVar12 = strcmp(pcVar35,\".bf\");\n              if (iVar12 == 0) {\n                if (pcStack0000000000000038 != (char *)0x0) {\n                  lVar17 = parse_and_initialize_data_0010dac0();\n                  if ((lVar17 == 0) || (cVar10 = initialize_debug_record_0010bc80(param_10), cVar10 == '\\0'))\n                  goto LAB_00105981;\n                  if (_uStack0000000000000048 != (int *)0x0) {\n                    iVar12 = 0;\n                    if (bStack0000000000000101 != 0) {\n                      iVar12 = in_stack_00000118 - 1;\n                    }\n                    lVar27 = *(long *)(*(long *)(lVar27 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar33 = _uStack0000000000000048[4];\n                      if (iVar33 == 0) break;\n                      cVar9 = record_line_info_0010bf86(param_10,iVar12 + iVar33,\n                                           *(long *)(_uStack0000000000000048 + 6) + lVar27);\n                      _uStack0000000000000048 = _uStack0000000000000048 + 4;\n                      if (cVar9 == '\\0') goto LAB_00105981;\n                    }\n                  }\n                  _uStack0000000000000048 = (int *)0x0;\n                  pcStack0000000000000038 = (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar35 = \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar12 = strcmp(pcVar35,\".ef\");\n                if (iVar12 != 0) goto switchD_00106e1a_caseD_68;\n                if (cVar10 != '\\0') {\n                  cVar10 = end_debugging_function_0010be1a(param_10);\n                  if (cVar10 == '\\0') goto LAB_00105981;\n                  cVar10 = '\\0';\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar35 = \"%ld: unexpected .ef\\n\";\n              }\n              uVar19 = dcgettext(0,pcVar35,5);\n              print_error_message_00119ed0(uVar19);\n              goto LAB_00105981;\n            default:\n              goto LAB_0010700a;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (cVar9 != '\\0');\n      }\n      else {\n        pcVar35 = \"%s: no recognized debugging information\";\nLAB_00105968:\n        uVar19 = dcgettext(0,pcVar35,5);\n        print_error_message_00119ed0(uVar19);\n      }\n      goto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)(param_7 + 0x44) & 0x42) != 0) && ((*(uint *)(param_7 + 0x44) & 1) == 0)) {\n    if ((*(char *)(*(long *)(param_7 + 8) + 0x20) == '\\0') && (DAT_00127939 == '\\0')) {\n      if (param_8 != 0) {\n        plVar6 = DAT_001278b0 + param_8;\n        plVar16 = DAT_001278b0;\n        do {\n          uVar11 = *(uint *)(*plVar16 + 0x18);\n          if ((uVar11 & 0x1000000) != 0) {\n            *(uint *)(*plVar16 + 0x18) = uVar11 & 0xfeffffff;\n          }\n          plVar16 = plVar16 + 1;\n        } while (plVar6 != plVar16);\n      }\n    }\n    else {\n      for (lVar27 = *(long *)(param_7 + 0x90); lVar27 != 0; lVar27 = *(long *)(lVar27 + 8)) {\n        if (*(long *)(lVar27 + 0xe8) != 0) {\n          puVar1 = (uint *)(*(long *)(lVar27 + 0xe8) + 0x18);\n          *puVar1 = *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((DAT_00127a2c == 2) || (DAT_00127a2c == 7)) {\nLAB_001059fe:\n    if (DAT_00127a2c == 7) {\nLAB_00105a3b:\n      plVar16 = (long *)xmalloc();\n      plVar6 = DAT_001278b0;\n      uStack0000000000000048 = *(uint *)((long)unaff_R14 + 0x44) & 0x42;\n      DAT_001278a8 = plVar16;\n      if (param_8 == 0) {\n        uVar28 = 0;\n      }\n      else {\n        uVar28 = 0;\n        _param_9 = 0;\n        do {\n          iVar12 = DAT_001279a0;\n          plVar4 = (long *)plVar6[_param_9];\n          pcVar5 = (code *)plVar4[4];\n          uVar11 = *(uint *)(plVar4 + 3);\n          pcVar35 = (char *)plVar4[1];\n          pcVar30 = pcVar35;\n          if (DAT_001279a8 != (undefined8 *)0x0) {\n            iVar33 = 0;\n            puVar31 = DAT_001279a8;\n            while ((iVar33 < iVar12 && (pcVar22 = (char *)puVar31[5], pcVar22 != (char *)0x0))) {\n              if (pcVar22 != \"\") {\n                iVar15 = strcmp(pcVar22,pcVar35);\n                if (iVar15 == 0) {\n                  free(pcVar22);\n                  uVar23 = uVar28 + 1;\n                  puVar31[5] = \"\";\n                  lVar27 = update_section_info_0011a2e0(puVar31);\n                  uVar19 = DAT_001278d0;\n                  plVar16[uVar28] = lVar27;\n                  lVar27 = htab_elements(uVar19);\n                  if ((lVar27 != 0) || (DAT_001278d8 != (char **)0x0)) goto LAB_001064eb;\n                  goto LAB_00105af8;\n                }\n                puVar31 = (undefined8 *)*puVar31;\n              }\n              iVar33 = iVar33 + 1;\n            }\n          }\n          lVar27 = htab_elements(DAT_001278d0);\n          uVar23 = uVar28;\n          if ((lVar27 != 0) || (DAT_001278d8 != (char **)0x0)) {\n            if (pcVar35 != (char *)0x0) {\nLAB_001064eb:\n              if (((*pcVar35 == '_') && (pcVar35[1] == '_')) &&\n                 (iVar12 = strcmp(pcVar35 + (pcVar35[2] == '_'),\"__gnu_lto_slim\"), iVar12 == 0)) {\n                uVar19 = dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\"\n                                   ,5);\n                    \n                print_error_and_exit_00119dd0(uVar19);\n              }\n            }\n            _cStack0000000000000148 = 0;\n            param_13 = pcVar35;\n            lVar27 = htab_find(DAT_001278d0);\n            if (((lVar27 == 0) || (pcVar30 = *(char **)(lVar27 + 8), pcVar35 == pcVar30)) &&\n               (pcVar30 = pcVar35, ppcVar38 = DAT_001278d8, (uVar11 & 0x100) != 0)) {\n              for (; ppcVar38 != (char **)0x0; ppcVar38 = (char **)ppcVar38[3]) {\n                iVar12 = strcmp(*ppcVar38,pcVar35);\n                if (iVar12 == 0) {\n                  pcVar30 = ppcVar38[1];\n                  break;\n                }\n              }\n            }\n            plVar4[1] = (long)pcVar30;\n            cVar10 = *pcVar30;\n            if (cVar10 != '\\0') goto LAB_00105b11;\nLAB_00106557:\n            pcVar35 = DAT_00127908;\n            if ((DAT_00127988 != '\\0') && (*(char *)(*(long *)(param_7 + 8) + 0x1c) != '\\0')) {\n              lVar27 = unaff_R14[1];\n              cVar10 = '\\0';\n              goto LAB_0010668d;\n            }\n            goto joined_r0x00106565;\n          }\nLAB_00105af8:\n          cVar10 = *pcVar35;\n          if (cVar10 == '\\0') goto LAB_00106557;\nLAB_00105b11:\n          pcVar35 = DAT_00127908;\n          lVar27 = unaff_R14[1];\n          if (*(char *)(lVar27 + 0x1c) == cVar10) {\n            if (DAT_00127988 == '\\0') {\n              if ((DAT_00127968 == '\\0') ||\n                 ((((uVar11 & 0x82) == 0 && (pcVar5 != bfd_map_over_sections)) &&\n                  ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n              pcVar30 = pcVar30 + 1;\n              plVar4[1] = (long)pcVar30;\n              goto joined_r0x00106565;\n            }\n            cVar10 = *(char *)(*(long *)(param_7 + 8) + 0x1c);\n            if (cVar10 == '\\0') goto LAB_0010677d;\n            if (DAT_00127908 != (char *)0x0) {\n              pcVar30 = pcVar30 + 1;\n              plVar4[1] = (long)pcVar30;\n              sVar20 = strlen(pcVar30);\n              lVar27 = sVar20 + 2;\nLAB_001066bc:\n              sVar20 = strlen(pcVar35);\n              pcVar35 = (char *)xmalloc(sVar20 + lVar27);\n              goto LAB_001066d0;\n            }\n            *pcVar30 = cVar10;\n            plVar4[1] = (long)pcVar30;\n            uVar28 = uVar23;\n          }\n          else {\n            if ((DAT_00127988 == '\\0') || (*(char *)(*(long *)(param_7 + 8) + 0x1c) == '\\0')) {\njoined_r0x00106565:\n              uVar28 = uVar23;\n              if (pcVar35 == (char *)0x0) goto LAB_00105b32;\n              sVar20 = strlen(pcVar30);\n              sVar21 = strlen(pcVar35);\n              pcVar22 = (char *)xmalloc(sVar21 + sVar20 + 1);\n              pcVar35 = pcVar22;\n            }\n            else {\nLAB_0010668d:\n              pcVar35 = DAT_00127908;\n              if ((*(char *)(lVar27 + 0x1c) != '\\0') && (cVar10 != *(char *)(lVar27 + 0x1c)))\n              goto joined_r0x00106565;\n              sVar20 = strlen(pcVar30);\n              lVar27 = sVar20 + 2;\n              if (pcVar35 != (char *)0x0) goto LAB_001066bc;\n              pcVar35 = (char *)xmalloc(lVar27);\nLAB_001066d0:\n              pcVar22 = pcVar35 + 1;\n              *pcVar35 = *(char *)(*(long *)(param_7 + 8) + 0x1c);\n            }\n            __s = DAT_00127908;\n            if (DAT_00127908 != (char *)0x0) {\n              strcpy(pcVar22,DAT_00127908);\n              sVar20 = strlen(__s);\n              pcVar22 = pcVar22 + sVar20;\n            }\n            strcpy(pcVar22,pcVar30);\n            plVar4[1] = (long)pcVar35;\n            pcVar30 = pcVar35;\n            uVar28 = uVar23;\n          }\nLAB_00105b32:\n          if (DAT_00127a2c == 7) goto LAB_001067a8;\n          if (((uVar11 & 0x20) == 0) &&\n             (((uVar11 & 0x100) == 0 ||\n              ((*(byte *)(**(long **)(plVar4[4] + 0xf0) + 0x18) & 0x20) == 0)))) {\n            if (((uStack0000000000000048 == 0) &&\n                (((uVar11 & 0x82) != 0 || ((*(byte *)(plVar4[4] + 0x25) & 0x10) != 0)))) ||\n               (iVar12 = bfd_decode_symclass(plVar4), iVar12 == 0x49)) {\nLAB_00105be2:\n              if (DAT_001279ca == '\\0') {\n                lVar27 = htab_find();\n                if (lVar27 == 0) goto LAB_00105c07;\n              }\n              else {\n                _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n                param_13 = pcVar30;\n                htab_traverse(DAT_001279f8,pattern_match_0011a170,&stack0x00000140);\n                if (cStack0000000000000148 == '\\0') goto LAB_00105c07;\n              }\n            }\n            else if ((((uVar11 & 0x82) == 0) && (pcVar5 != bfd_map_over_sections)) &&\n                    ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)) {\n              if ((uVar11 & 4) == 0) {\n                if (((*(int *)(unaff_R14[1] + 8) != 2) ||\n                    (lVar27 = *(long *)(plVar4[4] + 0xd0), lVar27 == 0)) ||\n                   (*(long *)(lVar27 + 0x40) == 0)) {\n                  if ((DAT_00127a2c == 3) || (DAT_00127a28 == 2)) goto LAB_001067a8;\n                  if (DAT_00127a28 == 1) {\n                    cVar10 = bfd_is_local_label(unaff_R14);\n                    goto joined_r0x00106a11;\n                  }\n                }\n                goto LAB_00105be2;\n              }\n              cVar10 = DAT_00127980;\n              if (1 < DAT_00127a2c - 2U) {\njoined_r0x00106a11:\n                if (cVar10 == '\\0') goto LAB_00105be2;\n              }\n            }\n            else if (DAT_00127a2c != 3) goto LAB_00105be2;\n            goto LAB_001067a8;\n          }\n          if (DAT_001279ca == '\\0') {\n            lVar27 = htab_find();\n            if (lVar27 != 0) {\nLAB_0010687f:\n              uVar19 = dcgettext(0,\"not stripping symbol `%s\\' because it is named in a relocation\",\n                                 5);\n              print_error_message_00119ed0(uVar19);\n              DAT_00127a20 = 1;\n            }\n          }\n          else {\n            _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n            param_13 = pcVar30;\n            htab_traverse(DAT_001279f8,pattern_match_0011a170,&stack0x00000140);\n            if (cStack0000000000000148 != '\\0') goto LAB_0010687f;\n          }\n          if ((uVar11 & 0x20) == 0) {\nLAB_00105c07:\n            if (DAT_001279ca != '\\0') {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              param_13 = pcVar30;\n              htab_traverse(DAT_001279f0,pattern_match_0011a170,&stack0x00000140);\n              if (cStack0000000000000148 != '\\0') goto LAB_001067a8;\n              goto LAB_00105c2c;\n            }\n            lVar27 = htab_find();\n            if (lVar27 == 0) goto LAB_00105c2c;\nLAB_001067a8:\n            if ((DAT_00127a18 != '\\0') && ((uVar11 & 0x4000) != 0)) goto LAB_00105c2c;\n            if (DAT_001279ca == '\\0') {\n              lVar27 = htab_find();\n              if (lVar27 != 0) goto LAB_00105c2c;\n            }\n            else {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              param_13 = pcVar30;\n              htab_traverse(DAT_00127a08,pattern_match_0011a170,&stack0x00000140);\n              if (cStack0000000000000148 != '\\0') goto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            cVar10 = process_section_data_001159d0(plVar4[4]);\n            if (cVar10 == '\\0') {\n              if (((uVar11 & 0x800002) == 0) && (pcVar5 != bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uVar11 & 0x82) != 0) {\n                  cVar10 = find_value_00115d70(pcVar30);\n                  if ((cVar10 == '\\0') &&\n                     ((lVar27 = htab_elements(DAT_001279d8), lVar27 == 0 ||\n                      (cVar10 = find_value_00115d70(pcVar30), cVar10 != '\\0')))) {\n                    if (((((DAT_00127938 == '\\0') ||\n                          (uVar13 = *(uint *)(plVar4 + 3), (uVar13 & 0x200000) != 0)) ||\n                         (lVar27 = *plVar4, lVar27 == 0)) ||\n                        ((*(int *)(*(long *)(lVar27 + 8) + 8) != 5 ||\n                         (*(long *)(lVar27 + 0x110) == 0)))) ||\n                       (1 < (*(byte *)((long)plVar4 + 0x49) & 3) - 1)) goto joined_r0x00105ca2;\n                  }\n                  else {\n                    uVar13 = *(uint *)(plVar4 + 3);\n                  }\n                  *(uint *)(plVar4 + 3) = uVar13 & 0xffffff7d | 1;\n                }\njoined_r0x00105ca2:\n                if (((uVar11 & 1) != 0) && (cVar10 = find_value_00115d70(pcVar30), cVar10 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((DAT_001279c8 != '\\0') || (cVar10 = find_value_00115d70(pcVar30), cVar10 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xff7ffffd | 0x80;\n                }\n                if (pcVar5 != bfd_map_over_sections) goto LAB_00105c5f;\n              }\n              plVar16[uVar28] = (long)plVar4;\n              uVar28 = uVar28 + 1;\n            }\n          }\n          _param_9 = _param_9 + 1;\n        } while (param_8 != _param_9);\n      }\n      if (DAT_001279a8 != (undefined8 *)0x0) {\n        puVar31 = DAT_001279a8;\n        iVar12 = DAT_001279a0;\n        for (lVar27 = 0; lVar27 < iVar12; lVar27 = lVar27 + 1) {\n          pcVar35 = (char *)puVar31[5];\n          if (pcVar35 == (char *)0x0) {\n            plVar6 = plVar16 + uVar28;\n            uVar28 = uVar28 + 1;\n            lVar17 = update_section_info_0011a2e0(puVar31,param_7);\n            *plVar6 = lVar17;\n            iVar12 = DAT_001279a0;\n          }\n          else if (pcVar35 != \"\") {\n            uVar19 = dcgettext(0,\"\\'before=%s\\' not found\",5);\n                    \n            print_error_and_exit_00119dd0(uVar19,pcVar35);\n          }\n          puVar31 = (undefined8 *)*puVar31;\n        }\n      }\n      bVar41 = DAT_00127980 == '\\0';\n      plVar16[uVar28] = 0;\n      if ((bVar41) || (param_10 == (undefined4 *)0x0)) {\nLAB_00105cfa:\n        param_8 = uVar28 & 0xffffffff;\n        goto LAB_00105710;\n      }\n      iVar12 = *(int *)(*(undefined8 **)(param_7 + 8) + 1);\n      if ((iVar12 == 5) || (iVar12 == 2)) {\n        in_stack_000000e0 = (void *)0x0;\n        cVar10 = extract_binary_data_0011378f(param_7,param_10,&stack0x000000c0,&stack0x00000110,&stack0x000000e0,\n                              &stack0x00000140);\n        if (cVar10 != '\\0') {\n          lVar27 = bfd_make_section_with_flags(param_7,\".stab\",0x2108);\n          lVar17 = bfd_make_section_with_flags(param_7,\".stabstr\",0x2108);\n          if ((((lVar27 == 0) || (lVar17 == 0)) ||\n              (cVar10 = bfd_set_section_size(lVar27,in_stack_00000110), cVar10 == '\\0')) ||\n             (cVar10 = bfd_set_section_size(lVar17,param_13), cVar10 == '\\0')) {\n            pcVar35 = \"can\\'t create debugging section\";\n          }\n          else {\n            *(undefined4 *)(lVar27 + 0x7c) = 2;\n            *(undefined4 *)(lVar17 + 0x7c) = 0;\n            cVar10 = bfd_set_section_contents(param_7,lVar27,in_stack_000000c0,0,in_stack_00000110);\n            if ((cVar10 != '\\0') &&\n               (cVar10 = bfd_set_section_contents(param_7,lVar17,in_stack_000000e0,0,param_13),\n               cVar10 != '\\0')) {\n              free(param_10);\n              goto LAB_00105cfa;\n            }\n            pcVar35 = \"can\\'t set debugging section contents\";\n          }\n          uVar19 = dcgettext(0,pcVar35,5);\n          display_error_001126c0(0,param_7,0,uVar19);\n          free(in_stack_000000e0);\n          free(param_10);\n          goto LAB_00105d96;\n        }\n      }\n      else {\n        uVar19 = **(undefined8 **)(param_7 + 8);\n        uVar18 = dcgettext(0,\"don\\'t know how to write debugging information for %s\",5);\n        display_error_001126c0(0,param_7,0,uVar18,uVar19);\n      }\n      free(param_10);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections();\n      iVar12 = bfd_get_error();\n      if (iVar12 == 0) goto LAB_00105a3b;\n    }\nLAB_00105d96:\n    DAT_00127a20 = 1;\n  }\n  else {\n    if ((DAT_00127a2c - 3U < 4) || ((DAT_00127a28 != 0 || (DAT_00127938 != '\\0'))))\n    goto LAB_00105a07;\n    lVar27 = htab_elements(DAT_001279f8);\n    if (((lVar27 != 0) ||\n        (((((((lVar27 = htab_elements(DAT_00127a08), lVar27 != 0 ||\n              (lVar27 = htab_elements(DAT_001279e8), lVar27 != 0)) ||\n             (lVar27 = htab_elements(DAT_001279e0), lVar27 != 0)) ||\n            ((lVar27 = htab_elements(DAT_001279d8), lVar27 != 0 ||\n             (lVar27 = htab_elements(DAT_001279d0), lVar27 != 0)))) ||\n           (lVar27 = htab_elements(DAT_001278d0), lVar27 != 0)) ||\n          (((DAT_00127908 != (char *)0x0 || (DAT_001278b8 != '\\0')) ||\n           ((DAT_00127a19 != '\\0' ||\n            (((DAT_00127980 != '\\0' || (DAT_00127988 != '\\0')) || (DAT_00127968 != '\\0')))))))) ||\n         ((DAT_001278d8 != (char **)0x0 || (DAT_001279c8 != '\\0')))))) || (DAT_001279a0 != 0))\n    goto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(param_7,DAT_001278a8,param_8 & 0xffffffff);\n    bfd_map_over_sections(unaff_R14,process_section_data_00115dc0,param_7);\n    bfd_map_over_sections(unaff_R14,reverse_section_contents_00116110,param_7);\n    for (puVar31 = DAT_001279c0; puVar37 = DAT_001279b8, puVar31 != (undefined8 *)0x0;\n        puVar31 = (undefined8 *)*puVar31) {\n      cVar10 = bfd_set_section_contents(param_7,puVar31[5],puVar31[4],0,puVar31[3]);\n      if (cVar10 == '\\0') {\n        display_error_001126c0(0,param_7,puVar31[5],0);\n        return 0;\n      }\n    }\n    for (; puVar37 != (undefined8 *)0x0; puVar37 = (undefined8 *)*puVar37) {\n      uVar19 = *(undefined8 *)(puVar37[5] + 0x60);\n      cVar10 = bfd_set_section_contents(param_7,uVar19,puVar37[4],0,puVar37[3]);\n      if (cVar10 == '\\0') {\n        display_error_001126c0(0,param_7,uVar19,0);\n        return 0;\n      }\n    }\n    if (__ptr_01 == (long **)0x0) {\n      if ((DAT_00127a00 != '\\0') && (_DAT_00127a24 == 0)) {\n        uVar19 = *unaff_R14;\n        uVar18 = dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n        print_error_message_00119ed0(uVar18,uVar19);\n      }\n    }\n    else {\n      pplVar34 = (long **)0x0;\n      for (puVar31 = *(undefined8 **)(param_7 + 0x90); puVar31 != (undefined8 *)0x0;\n          puVar31 = (undefined8 *)puVar31[1]) {\n        if (((DAT_00127a00 != '\\0') && (*(int *)(*(long *)(param_7 + 8) + 8) == 5)) &&\n           ((*(int *)(puVar31[0x1a] + 4) == 7 &&\n            (cVar10 = compare_strings_00113fb0(*puVar31,\".gnu.build.attributes\"), cVar10 != '\\0')))) {\n          if (pplVar34 == (long **)0x0) {\n            pplVar34 = __ptr_01;\n          }\n          pplVar29 = __ptr_01;\n          if ((undefined8 *)(*pplVar34)[0xc] == puVar31) {\nLAB_0010625f:\n            pcVar35 = \"error: failed to merge notes\";\n            if (pplVar34[1] != (long *)0x0) {\n              cVar10 = bfd_set_section_contents(param_7,puVar31,pplVar34[1],0,pplVar34[2]);\n              if (cVar10 == '\\0') {\n                uVar19 = dcgettext(0,\"error: failed to copy merged notes into output\",5);\n                display_error_001126c0(0,param_7,puVar31,uVar19);\n                return 0;\n              }\n              pplVar34 = (long **)pplVar34[3];\n              goto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              pplVar34 = pplVar29;\n              if ((undefined8 *)(*pplVar29)[0xc] == puVar31) goto LAB_0010625f;\n              pplVar34 = (long **)pplVar29[3];\n              pplVar29 = pplVar34;\n            } while (pplVar34 != (long **)0x0);\n            pcVar35 = \"error: failed to locate merged notes\";\n          }\n          uVar19 = dcgettext(0,pcVar35,5);\n          display_error_001126c0(0,param_7,puVar31,uVar19);\n        }\nLAB_001061be:\n      }\n      do {\n        pplVar34 = (long **)__ptr_01[3];\n        free(__ptr_01[1]);\n        free(__ptr_01);\n        __ptr_01 = pplVar34;\n      } while (pplVar34 != (long **)0x0);\n    }\n    if ((DAT_00127a10 == 0) ||\n       (cVar10 = bfd_fill_in_gnu_debuglink_section(param_7,param_12), lVar27 = DAT_00127a10,\n       cVar10 != '\\0')) {\n      uVar11 = (**(code **)(*(long *)(param_7 + 8) + 0x140))(unaff_R14);\n      uVar28 = (ulong)uVar11;\n      if ((char)uVar11 != '\\0') {\n        if (DAT_00127910 == 0) {\n          return uVar28;\n        }\n        cVar10 = bfd_alt_mach_code(param_7,DAT_00127910 & 0xffffffff);\n        uVar23 = DAT_00127910;\n        if (cVar10 == '\\0') {\n          uVar19 = dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n          print_error_message_00119ed0(uVar19,uVar23);\n          if (*(int *)(*(long *)(param_7 + 8) + 8) == 5) {\n            uVar19 = dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n            print_error_message_00119ed0(uVar19);\n            *(short *)(*(long *)(param_7 + 0x110) + 0x3a) = (short)DAT_00127910;\n            return uVar28;\n          }\n          uVar19 = dcgettext(0,\"ignoring the alternative value\",5);\n          print_error_message_00119ed0(uVar19);\n          return uVar28;\n        }\n        return uVar28;\n      }\n      uVar19 = dcgettext(0,\"error copying private BFD data\",5);\n      display_error_001126c0(0,param_7,0,uVar19);\n    }\n    else {\n      uVar19 = dcgettext(0,\"cannot fill debug link section `%s\\'\",5);\n      display_error_001126c0(0,param_7,0,uVar19,lVar27);\n    }\n  }\n  return 0;\nLAB_00115187:\n  if ((((*(int *)(unaff_R14[1] + 8) == 5) && (*(int *)((long)pplVar34[0x1a] + 4) == 7)) &&\n      (cVar10 = compare_strings_00113fb0(*pplVar34), cVar10 != '\\0')) &&\n     ((pplVar34[0xc] != (long *)0x0 && (plVar6 = pplVar34[8], plVar6 != (long *)0x0)))) {\n    pplVar29 = (long **)xmalloc(0x20);\n    pplVar29[1] = (long *)0x0;\n    cVar10 = bfd_get_full_section_contents();\n    if (cVar10 == '\\0') {\n      dcgettext(0,\"warning: could not load note section\",5);\n      display_error_001126c0(0);\n      free(pplVar29);\n    }\n    else {\n      plVar16 = (long *)parse_gnu_build_attribute_notes_001163d0();\n      pplVar29[2] = plVar16;\n      if ((plVar16 == plVar6) || (cVar10 = bfd_set_section_size(pplVar34[0xc]), cVar10 != '\\0')) {\n        pplVar29[3] = (long *)__ptr_01;\n        *pplVar29 = (long *)pplVar34;\n        __ptr_01 = pplVar29;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        display_error_001126c0(0,param_7,pplVar34);\n        free(pplVar29[1]);\n        free(pplVar29);\n      }\n    }\n  }\n  pplVar34 = (long **)pplVar34[1];\n  puVar31 = DAT_001279b0;\n  if (pplVar34 == (long **)0x0) goto joined_r0x001151c7;\n  goto LAB_001151ab;\n}\n\n",
            "called": [
                "FUN_0010554f",
                "xmalloc",
                "fopen",
                "bfd_get_full_section_contents",
                "fclose",
                "bfd_map_over_sections",
                "__errno_location",
                "fwrite",
                "bfd_make_section_with_flags",
                "FUN_00119ed0",
                "strerror",
                "FUN_001126c0",
                "FUN_00114190",
                "bfd_set_section_size",
                "bfd_create_gnu_debuglink_section",
                "FUN_00115530",
                "bfd_set_format",
                "FUN_00113fb0",
                "FUN_0010551d",
                "FUN_00115f30",
                "dcgettext",
                "bfd_get_arch",
                "FUN_001163d0",
                "bfd_get_section_by_name",
                "bfd_malloc_and_get_section",
                "free",
                "FUN_00105828"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00107880",
            "calling": [
                "FUN_001152b6"
            ],
            "imported": false,
            "current_name": "FUNC_00107880"
        },
        "FUN_0011a350": {
            "renaming": {
                "FUN_0011a350": "set_file_time_0011a350",
                "param_1": "filePath",
                "param_2": "fileInfoPtr",
                "iVar1": "result",
                "piVar2": "errnoPtr",
                "pcVar3": "errorStr",
                "uVar4": "errorMessage",
                "local_38": "timeSpec1",
                "uStack_34": "timeSpec2",
                "uStack_30": "timeSpec3",
                "uStack_2c": "timeSpec4",
                "local_28": "filePath1",
                "uStack_24": "filePath2",
                "uStack_20": "filePath3",
                "uStack_1c": "filePath4"
            },
            "code": "\nvoid setFileTime_0011a350(char *filePath,long fileInfoPtr)\n\n{\n  int result;\n  int *errnoPtr;\n  char *errorStr;\n  undefined8 errorMessage;\n  undefined4 timeSpec1;\n  undefined4 timeSpec2;\n  undefined4 timeSpec3;\n  undefined4 timeSpec4;\n  undefined4 filePath1;\n  undefined4 filePath2;\n  undefined4 filePath3;\n  undefined4 filePath4;\n  \n  filePath1 = *(undefined4 *)(fileInfoPtr + 0x58);\n  filePath2 = *(undefined4 *)(fileInfoPtr + 0x5c);\n  filePath3 = *(undefined4 *)(fileInfoPtr + 0x60);\n  filePath4 = *(undefined4 *)(fileInfoPtr + 100);\n  timeSpec1 = *(undefined4 *)(fileInfoPtr + 0x48);\n  timeSpec2 = *(undefined4 *)(fileInfoPtr + 0x4c);\n  timeSpec3 = *(undefined4 *)(fileInfoPtr + 0x50);\n  timeSpec4 = *(undefined4 *)(fileInfoPtr + 0x54);\n  result = utimensat(-100,filePath,(timespec *)&timeSpec1,0);\n  if (result != 0) {\n    errnoPtr = __errno_location();\n    errorStr = strerror(*errnoPtr);\n    errorMessage = dcgettext(0,\"%s: cannot set time: %s\",5);\n    print_error_message_00119ed0(errorMessage,filePath,errorStr);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_0010882c",
                "utimensat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a350",
            "calling": [
                "FUN_00104ea2",
                "FUN_00108200"
            ],
            "imported": false,
            "current_name": "set_file_time_0011a350"
        },
        "FUN_0011a110": {
            "renaming": {
                "FUN_0011a110": "print_error_message_0011a110",
                "param_1": "errorCode",
                "iVar1": "bfdError",
                "uVar2": "errorMessage",
                "in_R10": "additionalInfo"
            },
            "code": "\n\n\nvoid printErrorMessage_0011a110(long errorCode)\n\n{\n  int bfdError;\n  undefined8 errorMessage;\n  undefined8 additionalInfo;\n  \n  bfdError = bfd_get_error();\n  if (bfdError == 0) {\n    errorMessage = dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    errorMessage = bfd_errmsg(bfdError);\n  }\n  fflush(_stdout);\n  if (errorCode != 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",DAT_001275e0,errorCode,errorMessage,additionalInfo);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",DAT_001275e0,errorMessage,additionalInfo);\n  return;\n}\n\n",
            "called": [
                "FUN_0010871c",
                "bfd_errmsg",
                "bfd_get_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a110",
            "calling": [
                "FUN_00116030",
                "FUN_00104ea2",
                "FUN_00115dc0",
                "FUN_001083b7",
                "FUN_00119f70",
                "FUN_001053d5"
            ],
            "imported": false,
            "current_name": "print_error_message_0011a110"
        },
        "FUN_0010e2f0": {
            "renaming": {
                "FUN_0010e2f0": "process_string_0010e2f0",
                "param_1": "hashTable",
                "param_2": "undefinedVal",
                "param_3": "integerVal",
                "param_4": "paramString",
                "param_5": "inputString",
                "lVar1": "tempVar1",
                "uVar2": "errorVal",
                "lVar3": "tempVar2",
                "uVar4": "errorMsg",
                "uVar5": "translatedMsg",
                "sVar6": "strLength",
                "lVar7": "result",
                "local_44": "localVar1",
                "uStack_40": "stackVar1",
                "uStack_3f": "stackVar2",
                "uStack_3e": "stackVar3",
                "local_3c": "localVar2"
            },
            "code": "\nundefined8\nprocessString_0010e2f0(long *hashTable,undefined undefinedVal,int integerVal,undefined8 paramString,char *inputString)\n\n{\n  long tempVar1;\n  undefined4 errorVal;\n  long tempVar2;\n  undefined8 errorMsg;\n  undefined8 translatedMsg;\n  size_t strLength;\n  long result;\n  undefined4 localVar1;\n  undefined stackVar1;\n  undefined stackVar2;\n  undefined2 stackVar3;\n  undefined4 localVar2 [3];\n  \n  if (inputString == (char *)0x0) {\n    result = 0;\n  }\n  else {\n    tempVar2 = bfd_hash_lookup(hashTable + 7,inputString,1,1);\n    if (tempVar2 == 0) {\n      errorVal = bfd_get_error();\n      errorMsg = bfd_errmsg(errorVal);\n      translatedMsg = dcgettext(0,\"string_hash_lookup failed: %s\",5);\n      print_error_message_00119ed0(translatedMsg,errorMsg);\n      return 0;\n    }\n    result = *(long *)(tempVar2 + 0x20);\n    if (result == -1) {\n      result = hashTable[6];\n      tempVar1 = hashTable[5];\n      *(long *)(tempVar2 + 0x20) = result;\n      if (tempVar1 == 0) {\n        hashTable[4] = tempVar2;\n      }\n      else {\n        *(long *)(tempVar1 + 0x18) = tempVar2;\n      }\n      hashTable[5] = tempVar2;\n      strLength = strlen(inputString);\n      hashTable[6] = result + 1 + strLength;\n    }\n  }\n  (**(code **)(*(long *)(*hashTable + 8) + 0x50))(result,&localVar1);\n  stackVar2 = 0;\n  stackVar1 = undefinedVal;\n  (**(code **)(*(long *)(*hashTable + 8) + 0x68))((long)integerVal,&stackVar3);\n  (**(code **)(*(long *)(*hashTable + 8) + 0x50))(paramString,localVar2);\n  if ((ulong)hashTable[3] < hashTable[2] + 0xcU) {\n    hashTable[3] = hashTable[3] * 2;\n    result = xrealloc(hashTable[1]);\n    hashTable[1] = result;\n  }\n  result = hashTable[2];\n  tempVar2 = hashTable[1];\n  *(ulong *)(tempVar2 + result) = CONCAT26(stackVar3,CONCAT15(stackVar2,CONCAT14(stackVar1,localVar1)));\n  *(undefined4 *)(tempVar2 + 8 + result) = localVar2[0];\n  hashTable[2] = hashTable[2] + 0xc;\n  return CONCAT71((int7)((ulong)result >> 8),1);\n}\n\n",
            "called": [
                "xrealloc",
                "bfd_errmsg",
                "strlen",
                "dcgettext",
                "FUN_00119ed0",
                "bfd_get_error",
                "bfd_hash_lookup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e2f0",
            "calling": [
                "FUN_0010e8a9",
                "FUN_0010e5db",
                "FUN_0010e439",
                "FUN_0010e842",
                "FUN_0010e918",
                "FUN_0010ed2c",
                "FUN_0010ebb0",
                "FUN_0010ec73",
                "FUN_0010e9a0",
                "FUN_0011378f",
                "FUN_0010edb4",
                "FUN_0010e6a8",
                "FUN_0010e453",
                "FUN_0010e7c2",
                "FUN_0010eafe"
            ],
            "imported": false,
            "current_name": "process_string_0010e2f0"
        },
        "FUN_00113fe0": {
            "renaming": {
                "FUN_00113fe0": "parse_flags_00113fe0",
                "param_1": "flagString",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "iVar1": "result",
                "uVar2": "errorMessage",
                "pcVar3": "delimiter",
                "pcVar4": "nextFlag",
                "sVar5": "flagLength",
                "iVar6": "offset",
                "uVar7": "flags",
                "auVar8": "resultStruct"
            },
            "code": "\nundefined  [16] parseFlags_00113fe0(char *flagString,undefined8 param2,undefined8 param3,undefined8 param4)\n\n{\n  int result;\n  undefined8 errorMessage;\n  char *delimiter;\n  char *nextFlag;\n  size_t flagLength;\n  int offset;\n  uint flags;\n  undefined resultStruct [16];\n  \n  flags = 0;\n  do {\n    delimiter = strchr(flagString,0x2c);\n    if (delimiter == (char *)0x0) {\n      flagLength = strlen(flagString);\n      offset = (int)flagLength;\n      nextFlag = (char *)0x0;\n    }\n    else {\n      nextFlag = delimiter + 1;\n      offset = (int)delimiter - (int)flagString;\n    }\n    flagLength = (size_t)offset;\n    result = strncasecmp(\"alloc\",flagString,flagLength);\n    if (result == 0) {\n      flags = flags | 1;\n    }\n    else {\n      result = strncasecmp(\"load\",flagString,flagLength);\n      if (result == 0) {\n        flags = flags | 2;\n      }\n      else {\n        result = strncasecmp(\"noload\",flagString,flagLength);\n        if (result == 0) {\n          flags = flags | 0x200;\n        }\n        else {\n          result = strncasecmp(\"readonly\",flagString,flagLength);\n          if (result == 0) {\n            flags = flags | 8;\n          }\n          else {\n            result = strncasecmp(\"debug\",flagString,flagLength);\n            if (result == 0) {\n              flags = flags | 0x2000;\n            }\n            else {\n              result = strncasecmp(\"code\",flagString,flagLength);\n              if (result == 0) {\n                flags = flags | 0x10;\n              }\n              else {\n                result = strncasecmp(\"data\",flagString,flagLength);\n                if (result == 0) {\n                  flags = flags | 0x20;\n                }\n                else {\n                  result = strncasecmp(\"rom\",flagString,flagLength);\n                  if (result == 0) {\n                    flags = flags | 0x40;\n                  }\n                  else {\n                    result = strncasecmp(\"exclude\",flagString,flagLength);\n                    if (result == 0) {\n                      flags = flags | 0x8000;\n                    }\n                    else {\n                      result = strncasecmp(\"share\",flagString,flagLength);\n                      if (result == 0) {\n                        flags = flags | 0x8000000;\n                      }\n                      else {\n                        result = strncasecmp(\"contents\",flagString,flagLength);\n                        if (result == 0) {\n                          flags = flags | 0x100;\n                        }\n                        else {\n                          result = strncasecmp(\"merge\",flagString,flagLength);\n                          if (result == 0) {\n                            flags = flags | 0x800000;\n                          }\n                          else {\n                            result = strncasecmp(\"strings\",flagString,flagLength);\n                            if (result != 0) {\n                              delimiter = (char *)xmalloc((long)(offset + 1));\n                              strncpy(delimiter,flagString,flagLength);\n                              delimiter[flagLength] = '\\0';\n                              errorMessage = dcgettext(0,\"unrecognized section flag `%s\\'\",5);\n                              print_error_message_00119ed0(errorMessage,delimiter);\n                              errorMessage = dcgettext(0,\"supported flags: %s\",5);\n                    \n                              print_error_and_exit_00119dd0(errorMessage,\n                                           \"alloc, load, noload, readonly, debug, code, data, rom, exclude, share, contents, merge, strings\"\n                                          );\n                            }\n                            flags = flags | 0x1000000;\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    flagString = nextFlag;\n  } while (nextFlag != (char *)0x0);\n  resultStruct._4_4_ = 0;\n  resultStruct._0_4_ = flags;\n  resultStruct._8_8_ = param4;\n  return resultStruct;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113fe0",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "parse_flags_00113fe0"
        },
        "textdomain": {
            "renaming": {},
            "code": "\nvoid textdomain(void)\n\n{\n  textdomain();\n  return;\n}\n\n",
            "called": [
                "textdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001041d0",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "textdomain"
        },
        "bfd_set_start_address": {
            "renaming": {},
            "code": "\nvoid bfd_set_start_address(void)\n\n{\n  bfd_set_start_address();\n  return;\n}\n\n",
            "called": [
                "bfd_set_start_address"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104860",
            "calling": [
                "FUN_00107976"
            ],
            "imported": false,
            "current_name": "bfd_set_start_address"
        },
        "FUN_001125fa": {
            "renaming": {
                "FUN_001125fa": "get_formatted_string_001125fa",
                "param_1": "arguments",
                "uVar1": "totalLength",
                "ppcVar2": "ptrToByte",
                "sVar3": "length1",
                "sVar4": "length2",
                "__s": "originalString"
            },
            "code": "\nchar * getFormattedString_001125fa(char **arguments)\n\n{\n  ulong totalLength;\n  char **ptrToByte;\n  size_t length1;\n  size_t length2;\n  char *originalString;\n  \n  if (arguments == (char **)0x0) {\n                    \n    __assert_fail(\"abfd != NULL\",\"../../binutils/bucomm.c\",0x298,\"bfd_get_archive_filename\");\n  }\n  ptrToByte = (char **)arguments[0x1d];\n  originalString = *arguments;\n  if ((ptrToByte != (char **)0x0) && ((*(byte *)((long)ptrToByte + 0x49) & 0x10) == 0)) {\n    length1 = strlen(*ptrToByte);\n    length2 = strlen(originalString);\n    totalLength = length1 + 3 + length2;\n    if (DAT_00127a38 < totalLength) {\n      if (DAT_00127a38 != 0) {\n        free(DAT_00127a30);\n      }\n      DAT_00127a38 = (totalLength >> 1) + totalLength;\n      DAT_00127a30 = (char *)xmalloc();\n    }\n    sprintf(DAT_00127a30,\"%s(%s)\",*(undefined8 *)arguments[0x1d],*arguments);\n    originalString = DAT_00127a30;\n  }\n  return originalString;\n}\n\n",
            "called": [
                "strlen",
                "free",
                "xmalloc",
                "sprintf",
                "__assert_fail"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001125fa",
            "calling": [
                "FUN_00104ea2",
                "FUN_00114e50",
                "FUN_00107976",
                "FUN_001152b6",
                "FUN_001126c0",
                "FUN_00105828"
            ],
            "imported": false,
            "current_name": "get_formatted_string_001125fa"
        },
        "fread": {
            "renaming": {},
            "code": "\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fread(__ptr,__size,__n,__stream);\n  return sVar1;\n}\n\n",
            "called": [
                "fread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104160",
            "calling": [
                "FUN_00116b90",
                "FUN_00114460",
                "FUN_00114dc7"
            ],
            "imported": false,
            "current_name": "fread"
        },
        "bfd_check_format": {
            "renaming": {},
            "code": "\nvoid bfd_check_format(void)\n\n{\n  bfd_check_format();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104810",
            "calling": [
                "FUN_00104ea2",
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "bfd_check_format"
        },
        "strspn": {
            "renaming": {},
            "code": "\n\n\nsize_t strspn(char *__s,char *__accept)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strspn(__s,__accept);\n  return sVar1;\n}\n\n",
            "called": [
                "strspn"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043e0",
            "calling": [
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "strspn"
        },
        "FUN_00108f05": {
            "renaming": {
                "FUN_00108f05": "get_one_00108f05"
            },
            "code": "\nundefined getOne_00108f05(void)\n\n{\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108f05",
            "calling": [
                "FUN_001135a5"
            ],
            "imported": false,
            "current_name": "get_one_00108f05"
        },
        "bfd_convert_section_setup": {
            "renaming": {},
            "code": "\nvoid bfd_convert_section_setup(void)\n\n{\n  bfd_convert_section_setup();\n  return;\n}\n\n",
            "called": [
                "bfd_convert_section_setup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001040f0",
            "calling": [
                "FUN_00115530"
            ],
            "imported": false,
            "current_name": "bfd_convert_section_setup"
        },
        "FUN_00108863": {
            "renaming": {
                "FUN_00108863": "free_memory_and_reset_00108863",
                "puVar1": "currentPtr",
                "puVar2": "nextPtr"
            },
            "code": "\nvoid freeMemoryAndReset_00108863(void)\n\n{\n  undefined4 *currentPtr;\n  undefined4 *nextPtr;\n  \n  currentPtr = (undefined4 *)&DAT_00127720;\n  do {\n    nextPtr = currentPtr + 6;\n    free(*(void **)(currentPtr + 4));\n    *(undefined8 *)(currentPtr + 4) = 0;\n    currentPtr = nextPtr;\n  } while (nextPtr != &DAT_001278a0);\n  DAT_001278a0 = 0;\n  return;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108863",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "free_memory_and_reset_00108863"
        },
        "FUN_00104020": {
            "renaming": {
                "FUN_00104020": "execute_indirect_function_00104020",
                "undefined": "indirectFunctionPointer"
            },
            "code": "\nvoid executeIndirectFunction_00104020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(indirectFunctionPointer *)0x0)();\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104020",
            "calling": [],
            "imported": false,
            "current_name": "execute_indirect_function_00104020"
        },
        "FUN_00108f08": {
            "renaming": {
                "FUN_00108f08": "add_debug_source_file_00108f08",
                "param_1": "sourceFilePtr",
                "param_2": "filename",
                "iVar1": "filenameComparison",
                "uVar2": "result",
                "puVar3": "currentNode",
                "puVar4": "nextNode",
                "lVar5": "loopCounter",
                "puVar6": "sourceFilesList",
                "pcVar7": "currentFilename",
                "puVar8": "lastNode",
                "bVar9": "isFirstIteration"
            },
            "code": "\n\n\nundefined8 addDebugSourceFile_00108f08(long sourceFilePtr,char *filename)\n\n{\n  int filenameComparison;\n  undefined8 result;\n  undefined8 *currentNode;\n  undefined8 *nextNode;\n  long loopCounter;\n  undefined8 *sourceFilesList;\n  char *currentFilename;\n  undefined8 *lastNode;\n  byte isFirstIteration;\n  \n  isFirstIteration = 0;\n  currentFilename = \"\";\n  if (filename != (char *)0x0) {\n    currentFilename = filename;\n  }\n  if (*(long *)(sourceFilePtr + 8) == 0) {\n    result = dcgettext(0,\"debug_start_source: no debug_set_filename call\",5);\n    fprintf(_stderr,\"%s\\n\",result);\n    result = 0;\n  }\n  else {\n    for (currentNode = *(undefined8 **)(*(long *)(sourceFilePtr + 8) + 8); currentNode != (undefined8 *)0x0;\n        currentNode = (undefined8 *)*currentNode) {\n      filenameComparison = filename_cmp(currentNode[1],currentFilename);\n      if (filenameComparison == 0) goto LAB_00108fad;\n    }\n    currentNode = (undefined8 *)xmalloc(0x18);\n    sourceFilesList = *(undefined8 **)(sourceFilePtr + 0x10);\n    lastNode = currentNode;\n    for (loopCounter = 6; loopCounter != 0; loopCounter = loopCounter + -1) {\n      *(undefined4 *)lastNode = 0;\n      lastNode = (undefined8 *)((long)lastNode + (ulong)isFirstIteration * -8 + 4);\n    }\n    currentNode[1] = currentFilename;\n    lastNode = (undefined8 *)*sourceFilesList;\n    while (nextNode = lastNode, nextNode != (undefined8 *)0x0) {\n      sourceFilesList = nextNode;\n      lastNode = (undefined8 *)*nextNode;\n    }\n    *sourceFilesList = currentNode;\nLAB_00108fad:\n    *(undefined8 **)(sourceFilePtr + 0x10) = currentNode;\n    result = 1;\n  }\n  return result;\n}\n\n",
            "called": [
                "fprintf",
                "xmalloc",
                "dcgettext",
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108f08",
            "calling": [
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "add_debug_source_file_00108f08"
        },
        "FUN_00114b84": {
            "renaming": {
                "FUN_00114b84": "remove_and_free_directory_00114b84",
                "param_9": "directory_path"
            },
            "code": "\nvoid remove_and_free_directory_00114b84(void)\n\n{\n  char *directory_path;\n  \n  rmdir(directory_path);\n  free(directory_path);\n  return;\n}\n\n",
            "called": [
                "free",
                "rmdir"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114b84",
            "calling": [
                "FUN_00104ea2",
                "FUN_00104d25"
            ],
            "imported": false,
            "current_name": "remove_and_free_directory_00114b84"
        },
        "strnlen": {
            "renaming": {},
            "code": "\n\n\nsize_t strnlen(char *__string,size_t __maxlen)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strnlen(__string,__maxlen);\n  return sVar1;\n}\n\n",
            "called": [
                "strnlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104380",
            "calling": [
                "FUN_0011a480"
            ],
            "imported": false,
            "current_name": "strnlen"
        },
        "FUN_00114190": {
            "renaming": {
                "FUN_00114190": "parse_rules_00114190",
                "param_1": "input_string",
                "param_2": "is_exclusion",
                "param_3": "flags",
                "uVar1": "flags_check",
                "plVar2": "rule",
                "pplVar3": "next_rule",
                "iVar4": "fnmatch_result",
                "uVar5": "error_message",
                "pplVar6": "current_rule",
                "pplVar7": "rule_list",
                "pplVar8": "next_rule_list"
            },
            "code": "\nlong ** parse_rules_00114190(long *input_string,char is_exclusion,uint flags)\n\n{\n  uint flags_check;\n  long *rule;\n  long **next_rule;\n  int fnmatch_result;\n  undefined8 error_message;\n  long **current_rule;\n  long **rule_list;\n  long **next_rule_list;\n  \n  rule_list = DAT_001278e0;\n  if (DAT_001278e0 == (long **)0x0) {\n    if (is_exclusion == '\\0') {\n      return (long **)0x0;\n    }\n    goto LAB_001142a9;\n  }\n  if (is_exclusion == '\\0') {\n    if ((flags & *(uint *)((long)DAT_001278e0 + 0x14)) == 0) {\nLAB_001141e5:\n      current_rule = (long **)*rule_list;\n      if (current_rule == (long **)0x0) {\n        return (long **)0x0;\n      }\n      rule_list = (long **)0x0;\n    }\n    else {\n      rule = DAT_001278e0[1];\n      if (*(char *)rule == '!') {\n        fnmatch_result = fnmatch((char *)((long)rule + 1),(char *)input_string,0);\n        current_rule = rule_list;\n        if (fnmatch_result == 0) goto LAB_0011438e;\n        goto LAB_001141e5;\n      }\n      fnmatch_result = fnmatch((char *)rule,(char *)input_string,0);\n      if (fnmatch_result != 0) goto LAB_001141e5;\n      current_rule = (long **)*rule_list;\n      if (current_rule == (long **)0x0) goto LAB_00114245;\n    }\n    if ((flags & *(uint *)((long)current_rule + 0x14)) != 0) {\n      rule = current_rule[1];\n      if (*(char *)rule == '!') {\n        fnmatch_result = fnmatch((char *)((long)rule + 1),(char *)input_string,0);\n        if (fnmatch_result == 0) {\nLAB_0011438e:\n          *(undefined *)(current_rule + 2) = 1;\n          return (long **)0x0;\n        }\n      }\n      else {\n        fnmatch_result = fnmatch((char *)rule,(char *)input_string,0);\n        if ((rule_list == (long **)0x0) && (fnmatch_result == 0)) {\n          next_rule_list = (long **)*current_rule;\n          rule_list = current_rule;\n          if (next_rule_list == (long **)0x0) goto LAB_00114245;\n          goto LAB_00114288;\n        }\n      }\n    }\n    next_rule_list = (long **)*current_rule;\n    current_rule = rule_list;\n    if (next_rule_list != (long **)0x0) goto LAB_00114288;\n  }\n  else {\n    fnmatch_result = strcmp((char *)DAT_001278e0[1],(char *)input_string);\n    if (fnmatch_result == 0) {\nLAB_001143cd:\n      flags_check = *(uint *)((long)rule_list + 0x14);\n      if ((((flags_check & 1) != 0) && ((flags & 2) != 0)) ||\n         (((flags & 1) != 0 && ((flags_check & 2) != 0)))) {\n        error_message = dcgettext(0,\"error: %s both copied and removed\",5);\n                    \n        print_error_and_exit_00119dd0(error_message,input_string);\n      }\n      if ((((flags_check & 8) != 0) && ((flags & 0x10) != 0)) || ((flags & 0x18) == 0x18)) {\n        error_message = dcgettext(0,\"error: %s both sets and alters VMA\",5);\n                    \n        print_error_and_exit_00119dd0(error_message,input_string);\n      }\n      if ((((flags_check & 0x20) == 0) || ((flags & 0x40) == 0)) && ((flags & 0x60) != 0x60)) {\n        *(uint *)((long)rule_list + 0x14) = flags_check | flags;\n        return rule_list;\n      }\n      error_message = dcgettext(0,\"error: %s both sets and alters LMA\",5);\n                    \n      print_error_and_exit_00119dd0(error_message,input_string);\n    }\n    rule_list = (long **)*rule_list;\n    if (rule_list == (long **)0x0) goto LAB_001142a9;\n    fnmatch_result = strcmp((char *)rule_list[1],(char *)input_string);\n    if (fnmatch_result == 0) goto LAB_001143cd;\n    next_rule_list = (long **)*rule_list;\n    current_rule = (long **)0x0;\n    if (next_rule_list == (long **)0x0) goto LAB_001142a9;\nLAB_00114288:\n    do {\n      rule_list = current_rule;\n      if (is_exclusion == '\\0') {\n        while (current_rule = next_rule_list, next_rule = rule_list, next_rule_list = current_rule,\n              (flags & *(uint *)((long)current_rule + 0x14)) != 0) {\n          rule = current_rule[1];\n          if (*(char *)rule == '!') {\n            fnmatch_result = fnmatch((char *)((long)rule + 1),(char *)input_string,0);\n            if (fnmatch_result == 0) goto LAB_0011438e;\n            next_rule_list = (long **)*current_rule;\n            if ((long **)*current_rule == (long **)0x0) goto LAB_001142a1;\n          }\n          else {\n            fnmatch_result = fnmatch((char *)rule,(char *)input_string,0);\n            if ((rule_list == (long **)0x0) && (fnmatch_result == 0)) {\n              rule_list = current_rule;\n              next_rule_list = (long **)*current_rule;\n              if ((long **)*current_rule == (long **)0x0) goto LAB_00114245;\n            }\n            else {\n              next_rule_list = (long **)*current_rule;\n              if ((long **)*current_rule == (long **)0x0) goto LAB_00114212;\n            }\n          }\n        }\n      }\n      else {\n        fnmatch_result = strcmp((char *)next_rule_list[1],(char *)input_string);\n        next_rule = current_rule;\n        rule_list = next_rule_list;\n        if (fnmatch_result == 0) goto LAB_001143cd;\n      }\n      current_rule = next_rule;\n      next_rule_list = (long **)*next_rule_list;\n      rule_list = current_rule;\n    } while (next_rule_list != (long **)0x0);\nLAB_001142a1:\n    if (is_exclusion != '\\0') {\nLAB_001142a9:\n      current_rule = (long **)xmalloc(0x30);\n      *(undefined (*) [16])(current_rule + 3) = (undefined  [16])0x0;\n      *(undefined *)(current_rule + 2) = 0;\n      *(uint *)((long)current_rule + 0x14) = flags;\n      current_rule[5] = (long *)0x0;\n      rule_list = current_rule;\n      *current_rule = (long *)DAT_001278e0;\n      DAT_001278e0 = rule_list;\n      current_rule[1] = input_string;\n      return current_rule;\n    }\n  }\nLAB_00114212:\n  if (rule_list == (long **)0x0) {\n    return (long **)0x0;\n  }\nLAB_00114245:\n  *(undefined *)(rule_list + 2) = 1;\n  return rule_list;\n}\n\n",
            "called": [
                "fnmatch",
                "strcmp",
                "FUN_00119dd0",
                "FUN_00104bba",
                "xmalloc",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114190",
            "calling": [
                "FUN_00115530",
                "FUN_00116b90",
                "FUN_00108072",
                "FUN_00116110",
                "FUN_00115dc0",
                "FUN_00114c20",
                "FUN_00115b70",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "parse_rules_00114190"
        },
        "FUN_00116490": {
            "renaming": {
                "FUN_00116490": "parse_gnu_build_attribute_notes_00116490",
                "param_1": "param",
                "param_2": "notesSize",
                "param_3": "notesData",
                "param_4": "notesOffset",
                "uVar1": "var1",
                "uVar2": "var2",
                "uVar3": "var3",
                "bVar4": "var4",
                "puVar5": "ptr5",
                "iVar6": "var6",
                "lVar7": "var7",
                "uVar8": "var8",
                "in_RAX": "noteType",
                "uVar9": "var9",
                "uVar10": "var10",
                "uVar11": "var11",
                "uVar12": "var12",
                "__ptr": "ptr",
                "uVar13": "var13",
                "unaff_RBX": "tempRBX",
                "unaff_RBP": "tempRBP",
                "puVar14": "ptr14",
                "puVar15": "ptr15",
                "cVar16": "var16",
                "puVar17": "ptr17",
                "puVar18": "ptr18",
                "in_R11": "noteDescSize",
                "unaff_R12": "noteDesc",
                "puVar19": "ptr19",
                "unaff_R13": "tempR13",
                "__nmemb": "nmemb",
                "unaff_R14": "ptr14",
                "puVar20": "ptr20",
                "bVar21": "var21",
                "iVar22": "var22",
                "unaff_retaddr": "retAddr",
                "param_7": "version",
                "param_8": "hasVersionNote",
                "param_9": "versionNoteOffset",
                "in_stack_00000020": "maxNotes",
                "in_stack_00000028": "parsedNotes",
                "in_stack_00000030": "noteDataPtr",
                "in_stack_00000038": "hasOtherNotes",
                "in_stack_00000040": "hasExcessData",
                "in_stack_00000048": "errorBuffer"
            },
            "code": "\nulong parseGNUBuildAttributeNotes_00116490(undefined8 param,ulong notesSize,ulong notesData,long notesOffset)\n\n{\n  undefined8 var1;\n  undefined8 var2;\n  ulong var3;\n  bool var4;\n  ulong *ptr5;\n  int var6;\n  long var7;\n  undefined8 var8;\n  ulong noteType;\n  ulong var9;\n  ulong var10;\n  ulong var11;\n  ulong var12;\n  undefined *ptr;\n  ulong var13;\n  ulong tempRBX;\n  ulong tempRBP;\n  ulong *ptr14;\n  undefined *ptr15;\n  char var16;\n  undefined *ptr17;\n  undefined *ptr18;\n  ulong noteDescSize;\n  ulong *noteDesc;\n  ulong *ptr19;\n  ulong tempR13;\n  size_t nmemb;\n  undefined8 *ptr14;\n  ulong *ptr20;\n  byte var21;\n  int var22;\n  ulong retAddr;\n  ulong version;\n  uint hasVersionNote;\n  ulong versionNoteOffset;\n  ulong maxNotes;\n  ulong *parsedNotes;\n  undefined *noteDataPtr;\n  uint hasOtherNotes;\n  uint hasExcessData;\n  undefined8 *errorBuffer;\n  \n  var21 = 0;\ncode_r0x00116490:\n  var7 = notesOffset;\n  var10 = tempRBP;\n  var13 = tempR13;\n  if (noteType == 0) {\n    if (notesSize == 0x100) {\n      noteDesc[7] = retAddr;\n      var11 = retAddr;\nLAB_001164af:\n      var9 = tempR13;\n      var13 = tempR13;\n      retAddr = var11;\n    }\n    else {\n      noteDesc[7] = versionNoteOffset;\nLAB_0011669e:\n      var10 = tempRBP;\n      var9 = tempRBP;\n    }\nLAB_001164bb:\n    noteDesc[8] = var9;\n    if (*(char *)((noteDesc[3] - 1) + notesData) != '\\0') {\n      var7 = dcgettext(0,\"corrupt GNU build attribute note: name not NUL terminated\",5);\n      goto LAB_0010849a;\n    }\n    ptr19 = noteDesc + 9;\n    if (0xb < tempRBX) {\n      var9 = (**(code **)(ptr14[1] + 0x40))(var7);\n      *ptr19 = var9;\n      var9 = (**(code **)(ptr14[1] + 0x40))(var7 + 4);\n      noteDesc[10] = var9;\n      notesSize = (**(code **)(ptr14[1] + 0x40))(var7 + 8);\n      notesData = *ptr19;\n      noteDesc[0xb] = notesSize;\n      noteType = noteDesc[10];\n      var9 = notesData + 3 & 0xfffffffffffffffc;\n      noteDesc[0xf] = var9;\n      if (noteType != (noteType + 3 & 0xfffffffffffffffc)) {\n        var7 = dcgettext(0,\"corrupt GNU build attribute note: description size not a factor of 4\",5\n                         );\n        goto LAB_0010849a;\n      }\n      if (1 < notesSize - 0x100) {\n        var7 = dcgettext(0,\"corrupt GNU build attribute note: wrong note type\",5);\n        goto LAB_0010849a;\n      }\n      var11 = var9 + noteType + 0xc;\n      if (tempRBX < var11) {\n        var7 = dcgettext(0,\"corrupt GNU build attribute note: note too big\",5);\n        goto LAB_0010849a;\n      }\n      if (notesData < 2) {\n        var7 = dcgettext(0,\"corrupt GNU build attribute note: name too small\",5);\n        goto LAB_0010849a;\n      }\n      noteDesc[0xc] = var7 + 0xc;\n      noteDescSize = var7 + 0xc + var9;\n      noteDesc[0xd] = noteDescSize;\n      tempRBX = tempRBX + (-0xc - (var9 + noteType));\n      notesOffset = var7 + var11;\n      tempRBP = var10;\n      noteDesc = ptr19;\n      tempR13 = var13;\n      if (notesData != 2) {\n        if (*(char *)(var7 + 0xc) == '$') {\n          if ((*(char *)(var7 + 0xd) == '\\x01') && (*(char *)(var7 + 0xe) == '1')) {\n            var10 = parseGNUBuildAttributeNotes_00116490();\n            return var10;\n          }\n        }\n        else if ((((4 < notesData) && (*(char *)(var7 + 0xc) == 'G')) &&\n                 (*(char *)(var7 + 0xd) == 'A')) &&\n                ((*(char *)(var7 + 0xe) == '$' && (*(char *)(var7 + 0xf) == '\\x01')))) {\n          if (*(char *)(var7 + 0x10) == '2') {\n            var10 = parseGNUBuildAttributeNotes_00116490();\n            return var10;\n          }\n          if (*(char *)(var7 + 0x10) == '3') {\n            var10 = parseGNUBuildAttributeNotes_00116490();\n            return var10;\n          }\n          var7 = dcgettext(0,\"corrupt GNU build attribute note: unsupported version\",5);\n          goto LAB_0010849a;\n        }\n      }\n      goto code_r0x00116490;\n    }\n    if (tempRBX != 0) {\n      var7 = dcgettext(0,\"corrupt GNU build attribute notes: excess data at end\",5);\n      goto LAB_0010849a;\n    }\n    if ((hasOtherNotes | hasExcessData | hasVersionNote) == 0) {\n      var1 = *ptr14;\n      var2 = *errorBuffer;\n      var8 = dcgettext(0,\"%s[%s]: Warning: version note missing - assuming version 3\",5);\n      print_error_message_00119ed0(var8,var1,var2);\nLAB_0011671b:\n      nmemb = ((long)ptr19 - (long)parsedNotes >> 3) * -0x71c71c71c71c71c7;\n      qsort(parsedNotes,nmemb,0x48,compare_and_select_smaller_0011a1b0);\n      for (ptr14 = parsedNotes; ptr14 < ptr19; ptr14 = ptr14 + 9) {\n        var10 = ptr14[2];\n        if (var10 != 0) {\n          var13 = ptr14[7];\n          var9 = ptr14[8];\n          ptr20 = ptr14;\n          var22 = 0;\n          if (var13 == var9) {\n            ptr14[2] = 0;\n          }\n          else {\n            do {\n              do {\n                ptr5 = ptr20;\n                ptr20 = ptr5 + -9;\n                if (ptr20 < parsedNotes) goto LAB_001167f5;\n                var11 = ptr5[-7];\n              } while (var11 == 0);\n              if ((*ptr20 != *ptr14) ||\n                 (var6 = memcmp((void *)ptr5[-6],(void *)ptr14[3],*ptr14), var6 != 0))\n              break;\n              var3 = ptr5[-2];\n              var12 = ptr5[-1];\n              if (var13 == var3) {\n                if (var9 == var12) {\n                  ptr14[2] = 0;\n                  break;\n                }\nLAB_001167a6:\n                if (var9 <= var12) {\n                  ptr14[2] = 0;\n                  break;\n                }\n                if (var12 < var13) {\nLAB_0010852c:\n                  if ((0xfffffffffffffff0 < var12) ||\n                     (var13 <= (var12 + 0xf & 0xfffffffffffffff0))) goto process_data_00116852;\n                }\nLAB_001167b8:\n                if ((var10 == 0x101) == (var11 == 0x101)) {\n                  if (var12 <= var9) {\n                    var12 = var9;\n                  }\n                  if (var3 < var13) {\n                    var13 = var3;\n                  }\n                  ptr5[-1] = var12;\n                  ptr5[-2] = var13;\n                  ptr14[2] = 0;\n                  break;\n                }\n              }\n              else {\n                if (var3 <= var13) goto LAB_001167a6;\n                if (var12 < var13) goto LAB_0010852c;\n                if (var9 < var13) {\n                  if ((0xfffffffffffffff0 < var9) || (var3 <= (var9 + 0xf & 0xfffffffffffffff0)))\n                  goto process_data_00116852;\n                  goto LAB_001167b8;\n                }\n                if (var9 != var12) goto LAB_001167b8;\n              }\nprocess_data_00116852:\n              var4 = var22 < 0x11;\n              var22 = var22 + 1;\n            } while (var4);\n          }\n        }\nLAB_001167f5:\n      }\n      qsort(parsedNotes,nmemb,0x48,compare_records_0011a250);\n      ptr = (undefined *)xmalloc(maxNotes * 2);\n      version = 0;\n      versionNoteOffset = 0;\n      ptr18 = ptr;\n      for (ptr14 = parsedNotes; ptr14 < ptr19; ptr14 = ptr14 + 9) {\n        if (ptr14[2] != 0) {\n          ptr17 = ptr18 + 4;\n          ptr15 = ptr18 + 0xc;\n          if ((ptr14[7] == versionNoteOffset) && (ptr14[8] == version)) {\n            (**(code **)(ptr14[1] + 0x50))(*ptr14,ptr18);\n            (**(code **)(ptr14[1] + 0x50))(0,ptr17);\n            (**(code **)(ptr14[1] + 0x50))(ptr14[2],ptr18 + 8);\n            var13 = ptr14[6];\n            var10 = *ptr14;\n            ptr18 = (undefined *)ptr14[3];\n            ptr17 = ptr15;\n            for (var9 = var10; var9 != 0; var9 = var9 - 1) {\n              *ptr17 = *ptr18;\n              ptr18 = ptr18 + (ulong)var21 * -2 + 1;\n              ptr17 = ptr17 + (ulong)var21 * -2 + 1;\n            }\n            if (var10 < var13) {\n              for (var7 = var13 - var10; var7 != 0; var7 = var7 + -1) {\n                *ptr17 = 0;\n                ptr17 = ptr17 + (ulong)var21 * -2 + 1;\n              }\n            }\n            ptr18 = ptr15 + var13;\n          }\n          else {\n            (**(code **)(ptr14[1] + 0x50))();\n            if (*(int *)(ptr14[1] + 8) == 5) {\n              var16 = (*(char *)(ptr14[0x22] + 4) == '\\x02') * '\\b' + '\\b';\n            }\n            else {\n              var16 = '\\b';\n            }\n            (**(code **)(ptr14[1] + 0x50))(var16,ptr17);\n            (**(code **)(ptr14[1] + 0x50))(ptr14[2],ptr18 + 8);\n            var10 = *ptr14;\n            ptr18 = (undefined *)ptr14[3];\n            ptr17 = ptr15;\n            for (var13 = var10; var13 != 0; var13 = var13 - 1) {\n              *ptr17 = *ptr18;\n              ptr18 = ptr18 + (ulong)var21 * -2 + 1;\n              ptr17 = ptr17 + (ulong)var21 * -2 + 1;\n            }\n            var13 = ptr14[6];\n            if (var10 < var13) {\n              for (var7 = var13 - var10; var7 != 0; var7 = var7 + -1) {\n                *ptr17 = 0;\n                ptr17 = ptr17 + (ulong)var21 * -2 + 1;\n              }\n            }\n            var7 = ptr14[1];\n            ptr15 = ptr15 + var13;\n            ptr18 = ptr15 + 8;\n            if ((*(int *)(var7 + 8) == 5) && (*(char *)(ptr14[0x22] + 4) == '\\x02')) {\n              (**(code **)(var7 + 0x38))(ptr14[7],ptr15);\n              (**(code **)(ptr14[1] + 0x38))(ptr14[8],ptr18);\n              ptr18 = ptr15 + 0x10;\n            }\n            else {\n              (**(code **)(var7 + 0x50))(ptr14[7],ptr15);\n              (**(code **)(ptr14[1] + 0x50))(ptr14[8],ptr15 + 4);\n            }\n            versionNoteOffset = ptr14[7];\n            version = ptr14[8];\n          }\n        }\n      }\n      var13 = (long)ptr18 - (long)ptr;\n      var10 = var13;\n      ptr18 = ptr;\n      if (var13 < maxNotes) {\n        for (; maxNotes = var13, var10 != 0; var10 = var10 - 1) {\n          *noteDataPtr = *ptr18;\n          ptr18 = ptr18 + (ulong)var21 * -2 + 1;\n          noteDataPtr = noteDataPtr + (ulong)var21 * -2 + 1;\n        }\n      }\n      free(ptr);\nLAB_001166f8:\n      free(parsedNotes);\n      return maxNotes;\n    }\n    if (((hasExcessData | hasVersionNote) == 0) || (hasOtherNotes == 0)) {\n      if (hasExcessData == 0) {\n        if (hasVersionNote != 0) goto LAB_0011671b;\n        goto LAB_001166f8;\n      }\n      if (hasVersionNote == 0) goto LAB_001166f8;\n    }\n    var7 = dcgettext(0,\"bad GNU build attribute notes: multiple different versions\",5);\n  }\n  else {\n    if (noteType == 0x10) {\n      var11 = (**(code **)(ptr14[1] + 0x28))(noteDescSize);\n      var9 = (**(code **)(ptr14[1] + 0x28))(noteDesc[4] + 8);\n      if (var9 < var11) {\n        var11 = var9;\n      }\nLAB_00116631:\n      if (noteDesc[2] == 0x100) {\n        if (var11 == 0) {\n          var11 = retAddr;\n        }\n        notesData = *noteDesc;\n        noteDesc[7] = var11;\n        var13 = var9;\n        retAddr = var11;\n        if (var9 == 0) goto LAB_001164af;\n      }\n      else {\n        if (var11 == 0) {\n          var11 = versionNoteOffset;\n        }\n        notesData = *noteDesc;\n        noteDesc[7] = var11;\n        var10 = var9;\n        versionNoteOffset = var11;\n        if (var9 == 0) goto LAB_0011669e;\n      }\n      goto LAB_001164bb;\n    }\n    if (noteType < 0x11) {\n      if (noteType == 4) {\n        var11 = (**(code **)(ptr14[1] + 0x40))(noteDescSize);\n        var9 = 0xffffffffffffffff;\n        goto LAB_00116631;\n      }\n      if (noteType == 8) {\n        var10 = parse_gnu_build_attribute_notes_001086af();\n        return var10;\n      }\n    }\n    var7 = dcgettext(0,\"corrupt GNU build attribute note: bad description size\",5);\n  }\nLAB_0010849a:\n  if (var7 != 0) {\n    bfd_set_error(0x11);\n    display_error_001126c0(0,ptr14,errorBuffer,var7);\n    DAT_00127a20 = 1;\n  }\n  goto LAB_001166f8;\n}\n\n",
            "called": [
                "FUN_001086af",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116490",
            "calling": [
                "FUN_001086af",
                "FUN_0010847a"
            ],
            "imported": false,
            "current_name": "parse_gnu_build_attribute_notes_00116490",
            "code_backup": "\nulong FUN_00116490(undefined8 param_1,ulong param_2,ulong param_3,long param_4)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  ulong uVar3;\n  bool bVar4;\n  ulong *puVar5;\n  int iVar6;\n  long lVar7;\n  undefined8 uVar8;\n  ulong in_RAX;\n  ulong uVar9;\n  ulong uVar10;\n  ulong uVar11;\n  ulong uVar12;\n  undefined *__ptr;\n  ulong uVar13;\n  ulong unaff_RBX;\n  ulong unaff_RBP;\n  ulong *puVar14;\n  undefined *puVar15;\n  char cVar16;\n  undefined *puVar17;\n  undefined *puVar18;\n  ulong in_R11;\n  ulong *unaff_R12;\n  ulong *puVar19;\n  ulong unaff_R13;\n  size_t __nmemb;\n  undefined8 *unaff_R14;\n  ulong *puVar20;\n  byte bVar21;\n  int iVar22;\n  ulong unaff_retaddr;\n  ulong param_7;\n  uint param_8;\n  ulong param_9;\n  ulong in_stack_00000020;\n  ulong *in_stack_00000028;\n  undefined *in_stack_00000030;\n  uint in_stack_00000038;\n  uint in_stack_00000040;\n  undefined8 *in_stack_00000048;\n  \n  bVar21 = 0;\ncode_r0x00116490:\n  lVar7 = param_4;\n  uVar10 = unaff_RBP;\n  uVar13 = unaff_R13;\n  if (in_RAX == 0) {\n    if (param_2 == 0x100) {\n      unaff_R12[7] = unaff_retaddr;\n      uVar11 = unaff_retaddr;\nLAB_001164af:\n      uVar9 = unaff_R13;\n      uVar13 = unaff_R13;\n      unaff_retaddr = uVar11;\n    }\n    else {\n      unaff_R12[7] = param_9;\nLAB_0011669e:\n      uVar10 = unaff_RBP;\n      uVar9 = unaff_RBP;\n    }\nLAB_001164bb:\n    unaff_R12[8] = uVar9;\n    if (*(char *)((unaff_R12[3] - 1) + param_3) != '\\0') {\n      lVar7 = dcgettext(0,\"corrupt GNU build attribute note: name not NUL terminated\",5);\n      goto LAB_0010849a;\n    }\n    puVar19 = unaff_R12 + 9;\n    if (0xb < unaff_RBX) {\n      uVar9 = (**(code **)(unaff_R14[1] + 0x40))(lVar7);\n      *puVar19 = uVar9;\n      uVar9 = (**(code **)(unaff_R14[1] + 0x40))(lVar7 + 4);\n      unaff_R12[10] = uVar9;\n      param_2 = (**(code **)(unaff_R14[1] + 0x40))(lVar7 + 8);\n      param_3 = *puVar19;\n      unaff_R12[0xb] = param_2;\n      in_RAX = unaff_R12[10];\n      uVar9 = param_3 + 3 & 0xfffffffffffffffc;\n      unaff_R12[0xf] = uVar9;\n      if (in_RAX != (in_RAX + 3 & 0xfffffffffffffffc)) {\n        lVar7 = dcgettext(0,\"corrupt GNU build attribute note: description size not a factor of 4\",5\n                         );\n        goto LAB_0010849a;\n      }\n      if (1 < param_2 - 0x100) {\n        lVar7 = dcgettext(0,\"corrupt GNU build attribute note: wrong note type\",5);\n        goto LAB_0010849a;\n      }\n      uVar11 = uVar9 + in_RAX + 0xc;\n      if (unaff_RBX < uVar11) {\n        lVar7 = dcgettext(0,\"corrupt GNU build attribute note: note too big\",5);\n        goto LAB_0010849a;\n      }\n      if (param_3 < 2) {\n        lVar7 = dcgettext(0,\"corrupt GNU build attribute note: name too small\",5);\n        goto LAB_0010849a;\n      }\n      unaff_R12[0xc] = lVar7 + 0xc;\n      in_R11 = lVar7 + 0xc + uVar9;\n      unaff_R12[0xd] = in_R11;\n      unaff_RBX = unaff_RBX + (-0xc - (uVar9 + in_RAX));\n      param_4 = lVar7 + uVar11;\n      unaff_RBP = uVar10;\n      unaff_R12 = puVar19;\n      unaff_R13 = uVar13;\n      if (param_3 != 2) {\n        if (*(char *)(lVar7 + 0xc) == '$') {\n          if ((*(char *)(lVar7 + 0xd) == '\\x01') && (*(char *)(lVar7 + 0xe) == '1')) {\n            uVar10 = FUN_00116490();\n            return uVar10;\n          }\n        }\n        else if ((((4 < param_3) && (*(char *)(lVar7 + 0xc) == 'G')) &&\n                 (*(char *)(lVar7 + 0xd) == 'A')) &&\n                ((*(char *)(lVar7 + 0xe) == '$' && (*(char *)(lVar7 + 0xf) == '\\x01')))) {\n          if (*(char *)(lVar7 + 0x10) == '2') {\n            uVar10 = FUN_00116490();\n            return uVar10;\n          }\n          if (*(char *)(lVar7 + 0x10) == '3') {\n            uVar10 = FUN_00116490();\n            return uVar10;\n          }\n          lVar7 = dcgettext(0,\"corrupt GNU build attribute note: unsupported version\",5);\n          goto LAB_0010849a;\n        }\n      }\n      goto code_r0x00116490;\n    }\n    if (unaff_RBX != 0) {\n      lVar7 = dcgettext(0,\"corrupt GNU build attribute notes: excess data at end\",5);\n      goto LAB_0010849a;\n    }\n    if ((in_stack_00000038 | in_stack_00000040 | param_8) == 0) {\n      uVar1 = *unaff_R14;\n      uVar2 = *in_stack_00000048;\n      uVar8 = dcgettext(0,\"%s[%s]: Warning: version note missing - assuming version 3\",5);\n      print_error_message_00119ed0(uVar8,uVar1,uVar2);\nLAB_0011671b:\n      __nmemb = ((long)puVar19 - (long)in_stack_00000028 >> 3) * -0x71c71c71c71c71c7;\n      qsort(in_stack_00000028,__nmemb,0x48,compare_and_select_smaller_0011a1b0);\n      for (puVar14 = in_stack_00000028; puVar14 < puVar19; puVar14 = puVar14 + 9) {\n        uVar10 = puVar14[2];\n        if (uVar10 != 0) {\n          uVar13 = puVar14[7];\n          uVar9 = puVar14[8];\n          puVar20 = puVar14;\n          iVar22 = 0;\n          if (uVar13 == uVar9) {\n            puVar14[2] = 0;\n          }\n          else {\n            do {\n              do {\n                puVar5 = puVar20;\n                puVar20 = puVar5 + -9;\n                if (puVar20 < in_stack_00000028) goto LAB_001167f5;\n                uVar11 = puVar5[-7];\n              } while (uVar11 == 0);\n              if ((*puVar20 != *puVar14) ||\n                 (iVar6 = memcmp((void *)puVar5[-6],(void *)puVar14[3],*puVar14), iVar6 != 0))\n              break;\n              uVar3 = puVar5[-2];\n              uVar12 = puVar5[-1];\n              if (uVar13 == uVar3) {\n                if (uVar9 == uVar12) {\n                  puVar14[2] = 0;\n                  break;\n                }\nLAB_001167a6:\n                if (uVar9 <= uVar12) {\n                  puVar14[2] = 0;\n                  break;\n                }\n                if (uVar12 < uVar13) {\nLAB_0010852c:\n                  if ((0xfffffffffffffff0 < uVar12) ||\n                     (uVar13 <= (uVar12 + 0xf & 0xfffffffffffffff0))) goto process_data_00116852;\n                }\nLAB_001167b8:\n                if ((uVar10 == 0x101) == (uVar11 == 0x101)) {\n                  if (uVar12 <= uVar9) {\n                    uVar12 = uVar9;\n                  }\n                  if (uVar3 < uVar13) {\n                    uVar13 = uVar3;\n                  }\n                  puVar5[-1] = uVar12;\n                  puVar5[-2] = uVar13;\n                  puVar14[2] = 0;\n                  break;\n                }\n              }\n              else {\n                if (uVar3 <= uVar13) goto LAB_001167a6;\n                if (uVar12 < uVar13) goto LAB_0010852c;\n                if (uVar9 < uVar13) {\n                  if ((0xfffffffffffffff0 < uVar9) || (uVar3 <= (uVar9 + 0xf & 0xfffffffffffffff0)))\n                  goto process_data_00116852;\n                  goto LAB_001167b8;\n                }\n                if (uVar9 != uVar12) goto LAB_001167b8;\n              }\nprocess_data_00116852:\n              bVar4 = iVar22 < 0x11;\n              iVar22 = iVar22 + 1;\n            } while (bVar4);\n          }\n        }\nLAB_001167f5:\n      }\n      qsort(in_stack_00000028,__nmemb,0x48,compare_records_0011a250);\n      __ptr = (undefined *)xmalloc(in_stack_00000020 * 2);\n      param_7 = 0;\n      param_9 = 0;\n      puVar18 = __ptr;\n      for (puVar14 = in_stack_00000028; puVar14 < puVar19; puVar14 = puVar14 + 9) {\n        if (puVar14[2] != 0) {\n          puVar17 = puVar18 + 4;\n          puVar15 = puVar18 + 0xc;\n          if ((puVar14[7] == param_9) && (puVar14[8] == param_7)) {\n            (**(code **)(unaff_R14[1] + 0x50))(*puVar14,puVar18);\n            (**(code **)(unaff_R14[1] + 0x50))(0,puVar17);\n            (**(code **)(unaff_R14[1] + 0x50))(puVar14[2],puVar18 + 8);\n            uVar13 = puVar14[6];\n            uVar10 = *puVar14;\n            puVar18 = (undefined *)puVar14[3];\n            puVar17 = puVar15;\n            for (uVar9 = uVar10; uVar9 != 0; uVar9 = uVar9 - 1) {\n              *puVar17 = *puVar18;\n              puVar18 = puVar18 + (ulong)bVar21 * -2 + 1;\n              puVar17 = puVar17 + (ulong)bVar21 * -2 + 1;\n            }\n            if (uVar10 < uVar13) {\n              for (lVar7 = uVar13 - uVar10; lVar7 != 0; lVar7 = lVar7 + -1) {\n                *puVar17 = 0;\n                puVar17 = puVar17 + (ulong)bVar21 * -2 + 1;\n              }\n            }\n            puVar18 = puVar15 + uVar13;\n          }\n          else {\n            (**(code **)(unaff_R14[1] + 0x50))();\n            if (*(int *)(unaff_R14[1] + 8) == 5) {\n              cVar16 = (*(char *)(unaff_R14[0x22] + 4) == '\\x02') * '\\b' + '\\b';\n            }\n            else {\n              cVar16 = '\\b';\n            }\n            (**(code **)(unaff_R14[1] + 0x50))(cVar16,puVar17);\n            (**(code **)(unaff_R14[1] + 0x50))(puVar14[2],puVar18 + 8);\n            uVar10 = *puVar14;\n            puVar18 = (undefined *)puVar14[3];\n            puVar17 = puVar15;\n            for (uVar13 = uVar10; uVar13 != 0; uVar13 = uVar13 - 1) {\n              *puVar17 = *puVar18;\n              puVar18 = puVar18 + (ulong)bVar21 * -2 + 1;\n              puVar17 = puVar17 + (ulong)bVar21 * -2 + 1;\n            }\n            uVar13 = puVar14[6];\n            if (uVar10 < uVar13) {\n              for (lVar7 = uVar13 - uVar10; lVar7 != 0; lVar7 = lVar7 + -1) {\n                *puVar17 = 0;\n                puVar17 = puVar17 + (ulong)bVar21 * -2 + 1;\n              }\n            }\n            lVar7 = unaff_R14[1];\n            puVar15 = puVar15 + uVar13;\n            puVar18 = puVar15 + 8;\n            if ((*(int *)(lVar7 + 8) == 5) && (*(char *)(unaff_R14[0x22] + 4) == '\\x02')) {\n              (**(code **)(lVar7 + 0x38))(puVar14[7],puVar15);\n              (**(code **)(unaff_R14[1] + 0x38))(puVar14[8],puVar18);\n              puVar18 = puVar15 + 0x10;\n            }\n            else {\n              (**(code **)(lVar7 + 0x50))(puVar14[7],puVar15);\n              (**(code **)(unaff_R14[1] + 0x50))(puVar14[8],puVar15 + 4);\n            }\n            param_9 = puVar14[7];\n            param_7 = puVar14[8];\n          }\n        }\n      }\n      uVar13 = (long)puVar18 - (long)__ptr;\n      uVar10 = uVar13;\n      puVar18 = __ptr;\n      if (uVar13 < in_stack_00000020) {\n        for (; in_stack_00000020 = uVar13, uVar10 != 0; uVar10 = uVar10 - 1) {\n          *in_stack_00000030 = *puVar18;\n          puVar18 = puVar18 + (ulong)bVar21 * -2 + 1;\n          in_stack_00000030 = in_stack_00000030 + (ulong)bVar21 * -2 + 1;\n        }\n      }\n      free(__ptr);\nLAB_001166f8:\n      free(in_stack_00000028);\n      return in_stack_00000020;\n    }\n    if (((in_stack_00000040 | param_8) == 0) || (in_stack_00000038 == 0)) {\n      if (in_stack_00000040 == 0) {\n        if (param_8 != 0) goto LAB_0011671b;\n        goto LAB_001166f8;\n      }\n      if (param_8 == 0) goto LAB_001166f8;\n    }\n    lVar7 = dcgettext(0,\"bad GNU build attribute notes: multiple different versions\",5);\n  }\n  else {\n    if (in_RAX == 0x10) {\n      uVar11 = (**(code **)(unaff_R14[1] + 0x28))(in_R11);\n      uVar9 = (**(code **)(unaff_R14[1] + 0x28))(unaff_R12[4] + 8);\n      if (uVar9 < uVar11) {\n        uVar11 = uVar9;\n      }\nLAB_00116631:\n      if (unaff_R12[2] == 0x100) {\n        if (uVar11 == 0) {\n          uVar11 = unaff_retaddr;\n        }\n        param_3 = *unaff_R12;\n        unaff_R12[7] = uVar11;\n        uVar13 = uVar9;\n        unaff_retaddr = uVar11;\n        if (uVar9 == 0) goto LAB_001164af;\n      }\n      else {\n        if (uVar11 == 0) {\n          uVar11 = param_9;\n        }\n        param_3 = *unaff_R12;\n        unaff_R12[7] = uVar11;\n        uVar10 = uVar9;\n        param_9 = uVar11;\n        if (uVar9 == 0) goto LAB_0011669e;\n      }\n      goto LAB_001164bb;\n    }\n    if (in_RAX < 0x11) {\n      if (in_RAX == 4) {\n        uVar11 = (**(code **)(unaff_R14[1] + 0x40))(in_R11);\n        uVar9 = 0xffffffffffffffff;\n        goto LAB_00116631;\n      }\n      if (in_RAX == 8) {\n        uVar10 = FUNC_001086af();\n        return uVar10;\n      }\n    }\n    lVar7 = dcgettext(0,\"corrupt GNU build attribute note: bad description size\",5);\n  }\nLAB_0010849a:\n  if (lVar7 != 0) {\n    bfd_set_error(0x11);\n    display_error_001126c0(0,unaff_R14,in_stack_00000048,lVar7);\n    DAT_00127a20 = 1;\n  }\n  goto LAB_001166f8;\n}\n\n"
        },
        "strncasecmp": {
            "renaming": {},
            "code": "\n\n\nint strncasecmp(char *__s1,char *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = strncasecmp(__s1,__s2,__n);\n  return iVar1;\n}\n\n",
            "called": [
                "strncasecmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001045d0",
            "calling": [
                "FUN_00116b90",
                "FUN_00104ad6"
            ],
            "imported": false,
            "current_name": "strncasecmp"
        },
        "bfd_openw": {
            "renaming": {},
            "code": "\nvoid bfd_openw(void)\n\n{\n  bfd_openw();\n  return;\n}\n\n",
            "called": [
                "bfd_openw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104690",
            "calling": [
                "FUN_00104ea2",
                "FUN_00114690",
                "FUN_00119f70"
            ],
            "imported": false,
            "current_name": "bfd_openw"
        },
        "FUN_00104a35": {
            "renaming": {
                "FUN_00104a35": "print_supported_targets_00104a35",
                "param_1": "target",
                "param_2": "outputFile",
                "lVar1": "targetValue",
                "pcVar2": "message",
                "__ptr": "targetList",
                "plVar3": "currentTarget"
            },
            "code": "\nvoid printSupportedTargets_00104a35(long target,FILE *outputFile)\n\n{\n  long targetValue;\n  char *message;\n  long *targetList;\n  long *currentTarget;\n  \n  if (target == 0) {\n    message = (char *)dcgettext(0,\"Supported targets:\",5);\n    fprintf(outputFile,message);\n  }\n  else {\n    message = (char *)dcgettext(0,\"%s: supported targets:\",5);\n    fprintf(outputFile,message,target);\n  }\n  targetList = (long *)bfd_target_list();\n  currentTarget = targetList;\n  while( true ) {\n    targetValue = *currentTarget;\n    currentTarget = currentTarget + 1;\n    if (targetValue == 0) break;\n    fprintf(outputFile,\" %s\");\n  }\n  fputc(10,outputFile);\n  free(targetList);\n  return;\n}\n\n",
            "called": [
                "fputc",
                "fprintf",
                "free",
                "dcgettext",
                "bfd_target_list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104a35",
            "calling": [
                "FUN_00108a2a",
                "FUN_00108916"
            ],
            "imported": false,
            "current_name": "print_supported_targets_00104a35"
        },
        "FUN_0010be1a": {
            "renaming": {
                "FUN_0010be1a": "end_debugging_function_0010be1a",
                "param_1": "functionPtr",
                "param_2": "newRetVal",
                "param_3": "unusedParam",
                "param_4": "message",
                "lVar1": "blockPtr",
                "uVar2": "errorMsg",
                "pcVar3": "errorMessage",
                "auVar4": "returnValue"
            },
            "code": "\n\n\nundefined  [16] endDebuggingFunction_0010be1a(long functionPtr,undefined8 newRetVal,undefined8 unusedParam,undefined8 message)\n\n{\n  long blockPtr;\n  undefined8 errorMsg;\n  char *errorMessage;\n  undefined returnValue [16];\n  \n  if (((*(long *)(functionPtr + 8) == 0) || (blockPtr = *(long *)(functionPtr + 0x20), blockPtr == 0)) ||\n     (*(long *)(functionPtr + 0x18) == 0)) {\n    errorMessage = \"debug_end_function: no current function\";\n  }\n  else {\n    if (*(long *)(blockPtr + 8) == 0) {\n      *(undefined8 *)(blockPtr + 0x20) = newRetVal;\n      errorMsg = CONCAT71((int7)((ulong)blockPtr >> 8),1);\n      *(undefined (*) [16])(functionPtr + 0x18) = ZEXT816(0);\n      goto LAB_0010be86;\n    }\n    errorMessage = \"debug_end_function: some blocks were not closed\";\n  }\n  errorMsg = dcgettext(0,errorMessage,5);\n  fprintf(_stderr,\"%s\\n\",errorMsg);\n  errorMsg = 0;\nLAB_0010be86:\n  returnValue._8_8_ = message;\n  returnValue._0_8_ = errorMsg;\n  return returnValue;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010be1a",
            "calling": [
                "FUN_0011173a",
                "FUN_0010554f",
                "FUN_0010c892"
            ],
            "imported": false,
            "current_name": "end_debugging_function_0010be1a"
        },
        "bfd_openr": {
            "renaming": {},
            "code": "\nvoid bfd_openr(void)\n\n{\n  bfd_openr();\n  return;\n}\n\n",
            "called": [
                "bfd_openr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001041f0",
            "calling": [
                "FUN_00104ea2",
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "bfd_openr"
        },
        "strtol": {
            "renaming": {},
            "code": "\n\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n  long lVar1;\n  \n  lVar1 = strtol(__nptr,__endptr,__base);\n  return lVar1;\n}\n\n",
            "called": [
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104510",
            "calling": [
                "FUN_0011173a",
                "FUN_0010d559",
                "FUN_00116b90",
                "FUN_0010ee3f",
                "FUN_00104943"
            ],
            "imported": false,
            "current_name": "strtol"
        },
        "bfd_target_list": {
            "renaming": {},
            "code": "\nvoid bfd_target_list(void)\n\n{\n  bfd_target_list();\n  return;\n}\n\n",
            "called": [
                "bfd_target_list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104350",
            "calling": [
                "FUN_00104a35"
            ],
            "imported": false,
            "current_name": "bfd_target_list"
        },
        "cplus_demangle_init_info": {
            "renaming": {},
            "code": "\nvoid cplus_demangle_init_info(void)\n\n{\n  cplus_demangle_init_info();\n  return;\n}\n\n",
            "called": [
                "cplus_demangle_init_info"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104550",
            "calling": [
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "cplus_demangle_init_info"
        },
        "bfd_canonicalize_reloc": {
            "renaming": {},
            "code": "\nvoid bfd_canonicalize_reloc(void)\n\n{\n  bfd_canonicalize_reloc();\n  return;\n}\n\n",
            "called": [
                "bfd_canonicalize_reloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047b0",
            "calling": [
                "FUN_001163d0",
                "FUN_00116030",
                "FUN_00115dc0"
            ],
            "imported": false,
            "current_name": "bfd_canonicalize_reloc"
        },
        "xexit": {
            "renaming": {},
            "code": "\nvoid xexit(void)\n\n{\n                    \n  xexit();\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104760",
            "calling": [
                "FUN_00116030",
                "FUN_00116b90",
                "FUN_00119dd0",
                "FUN_00115dc0",
                "FUN_001083b7"
            ],
            "imported": false,
            "current_name": "xexit"
        },
        "FUN_00113da9": {
            "renaming": {
                "FUN_00113da9": "initialize_data_with_offset_00113da9",
                "param_1": "offset",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "puVar1": "ptr1",
                "lVar2": "loopCounter",
                "puVar3": "ptr2",
                "bVar4": "byteVar",
                "auVar5": "result"
            },
            "code": "\nundefined  [16] initializeDataWithOffset_00113da9(byte offset,undefined8 param2,undefined8 param3,undefined8 param4)\n\n{\n  undefined8 *ptr1;\n  long loopCounter;\n  undefined8 *ptr2;\n  byte byteVar;\n  undefined result [16];\n  \n  byteVar = 0;\n  result._0_8_ = initialize_data_00112904(8 - (uint)offset);\n  if (result._0_8_ != 0) {\n    ptr1 = (undefined8 *)xmalloc(0x28);\n    ptr2 = ptr1 + 1;\n    for (loopCounter = 8; loopCounter != 0; loopCounter = loopCounter + -1) {\n      *(undefined4 *)ptr2 = 0;\n      ptr2 = (undefined8 *)((long)ptr2 + (ulong)byteVar * -8 + 4);\n    }\n    *ptr1 = param3;\n    *(undefined8 **)(result._0_8_ + 0x10) = ptr1;\n  }\n  result._8_8_ = param4;\n  return result;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113da9",
            "calling": [
                "FUN_0010e07c",
                "FUN_0010ee3f",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "initialize_data_with_offset_00113da9"
        },
        "FUN_0011a250": {
            "renaming": {
                "FUN_0011a250": "compare_records_0011a250",
                "param_1": "record1",
                "param_2": "record2",
                "uVar1": "record1Flag"
            },
            "code": "\nint compareRecords_0011a250(ulong *record1,ulong *record2)\n\n{\n  ulong record1Flag;\n  \n  record1Flag = record1[2];\n  if (record1Flag == record2[2]) {\n    if (record2[7] <= record1[7]) {\n      if (record1[7] <= record2[7]) {\n        if (record2[8] < record1[8]) {\n          return -1;\n        }\n        if (record2[8] <= record1[8]) {\n          if ((4 < *record1) && (4 < *record2)) {\n            if (*(char *)(record1[3] + 3) != *(char *)(record2[3] + 3)) {\n              return (int)*(char *)(record1[3] + 3) - (int)*(char *)(record2[3] + 3);\n            }\n          }\n          return 0;\n        }\n      }\n      return 1;\n    }\n  }\n  else if ((record1Flag == 0) || ((record1Flag != 0x100 && (record2[2] != 0)))) {\n    return 1;\n  }\n  return -1;\n}\n\n",
            "called": [
                "FUN_001087fd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a250",
            "calling": [
                "FUN_00116852"
            ],
            "imported": false,
            "current_name": "compare_records_0011a250"
        },
        "getopt_long": {
            "renaming": {},
            "code": "\nvoid getopt_long(void)\n\n{\n  getopt_long();\n  return;\n}\n\n",
            "called": [
                "getopt_long"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104280",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "getopt_long"
        },
        "FUN_0010a69a": {
            "renaming": {
                "FUN_0010a69a": "format_and_allocate_data_0010a69a",
                "param_1": "dataPointer",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "uVar1": "result",
                "lVar2": "arraySize",
                "sVar3": "stringLength",
                "uVar4": "allocatedMemory",
                "uVar5": "isResized",
                "local_60": "formattedString"
            },
            "code": "\nundefined4 formatAndAllocateData_0010a69a(long dataPointer,undefined8 param2,int param3,char param4,uint param5)\n\n{\n  undefined4 result;\n  long arraySize;\n  size_t stringLength;\n  undefined8 allocatedMemory;\n  undefined isResized;\n  char formattedString [48];\n  \n  if (param3 == 0) {\n    formattedString[0] = '\\0';\n    isResized = 0;\n    arraySize = 0;\n  }\n  else {\n    arraySize = resize_array_00109c2e();\n    if (arraySize < 0) {\n      return 0;\n    }\n    isResized = 1;\n    sprintf(formattedString,\"%ld=\",arraySize);\n  }\n  stringLength = strlen(formattedString);\n  sprintf(formattedString + stringLength,\"%c%u\",(ulong)((-(uint)(param4 == '\\0') & 2) + 0x73),(ulong)param5);\n  result = allocate_and_initialize_data_00109b52(dataPointer,formattedString,arraySize,isResized,param5);\n  if ((char)result == '\\0') {\n    return 0;\n  }\n  arraySize = *(long *)(dataPointer + 0x60);\n  allocatedMemory = xmalloc(1);\n  *(undefined8 *)(arraySize + 0x20) = allocatedMemory;\n  **(undefined **)(*(long *)(dataPointer + 0x60) + 0x20) = 0;\n  return result;\n}\n\n",
            "called": [
                "FUN_00109c2e",
                "strlen",
                "xmalloc",
                "sprintf",
                "FUN_00109b52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a69a",
            "calling": [
                "FUN_0010a83e",
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "format_and_allocate_data_0010a69a"
        },
        "FUN_00115b70": {
            "renaming": {
                "FUN_00115b70": "process_section_data_00115b70",
                "param_1": "sectionData",
                "pcVar1": "sectionName",
                "iVar2": "comparisonResult",
                "iVar3": "sectionType",
                "lVar4": "parsedValue1",
                "lVar5": "parsedValue2",
                "uVar6": "returnValue",
                "plVar7": "ruleList"
            },
            "code": "\nundefined8 processSectionData_00115b70(char **sectionData)\n\n{\n  char *sectionName;\n  int comparisonResult;\n  int sectionType;\n  long parsedValue1;\n  long parsedValue2;\n  undefined8 returnValue;\n  long *ruleList;\n  \n  parsedValue1 = parse_rules_00114190(*sectionData,0,4);\n  if (parsedValue1 == 0) {\n    if ((DAT_001278b8 != '\\0') || (DAT_00127a19 != '\\0')) {\n      parsedValue1 = parse_rules_00114190(*sectionData,0,1);\n      parsedValue2 = parse_rules_00114190(*sectionData,0,2);\n      if (parsedValue1 != 0) {\n        if (parsedValue2 != 0) {\n          sectionName = *sectionData;\n          returnValue = dcgettext(0,\"error: section %s matches both remove and copy options\",5);\n                    \n          print_error_and_exit_00119dd0(returnValue,sectionName);\n        }\n        if (parsedValue1 != 0) {\n          if (DAT_001279b8 == (long *)0x0) {\n            return 1;\n          }\n          sectionName = *sectionData;\n          ruleList = DAT_001279b8;\n          do {\n            sectionType = strcmp(sectionName,(char *)ruleList[1]);\n            if (sectionType == 0) {\n              returnValue = dcgettext(0,\"error: section %s matches both update and remove options\",5);\n                    \n              print_error_and_exit_00119dd0(returnValue,sectionName);\n            }\n            ruleList = (long *)*ruleList;\n          } while (ruleList != (long *)0x0);\n          return 1;\n        }\n      }\n      if ((DAT_00127a19 != '\\0') && (parsedValue2 == 0)) {\n        return 1;\n      }\n    }\n    sectionType = DAT_00127a2c;\n    if ((*(byte *)((long)sectionData + 0x25) & 0x20) != 0) {\n      if ((((DAT_00127a2c - 2U < 2) || (DAT_00127a2c == 7)) || (DAT_00127a28 == 2)) ||\n         (DAT_00127980 != '\\0')) {\n        sectionName = *sectionData;\n        comparisonResult = strcmp(sectionName,\".gnu_debugaltlink\");\n        if ((comparisonResult != 0) && (comparisonResult = strcmp(sectionName,\".gnu_debuglink\"), comparisonResult != 0)) {\n          sectionType = strcmp(sectionName,\".reloc\");\n          if (sectionType != 0) {\n            return 1;\n          }\n          returnValue = determine_action_based_on_input_0010829e();\n          return returnValue;\n        }\n      }\n      if (sectionType == 5) {\n        returnValue = check_string_length_00113ede(sectionData);\n        return returnValue;\n      }\n      if (sectionType == 4) {\n        return 0;\n      }\n    }\n    if (sectionType == 6) {\n      returnValue = check_and_invert_string_length_001082b3();\n      return returnValue;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "strcmp",
                "FUN_00119dd0",
                "dcgettext",
                "FUN_0010829e",
                "FUN_00114190",
                "FUN_0010827b"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115b70",
            "calling": [
                "FUN_001159d0"
            ],
            "imported": false,
            "current_name": "process_section_data_00115b70"
        },
        "strrchr": {
            "renaming": {},
            "code": "\n\n\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strrchr(__s,__c);\n  return pcVar1;\n}\n\n",
            "called": [
                "strrchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001042c0",
            "calling": [
                "FUN_00114cf0"
            ],
            "imported": false,
            "current_name": "strrchr"
        },
        "bfd_get_reloc_upper_bound": {
            "renaming": {},
            "code": "\nvoid bfd_get_reloc_upper_bound(void)\n\n{\n  bfd_get_reloc_upper_bound();\n  return;\n}\n\n",
            "called": [
                "bfd_get_reloc_upper_bound"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104840",
            "calling": [
                "FUN_001163d0",
                "FUN_00116030",
                "FUN_00115dc0"
            ],
            "imported": false,
            "current_name": "bfd_get_reloc_upper_bound"
        },
        "FUN_00116030": {
            "renaming": {
                "FUN_00116030": "process_reloc_table_00116030",
                "param_1": "config_ptr",
                "param_2": "data_ptr",
                "plVar1": "reloc_entry_ptr",
                "lVar2": "reloc_entry_value",
                "lVar3": "var1",
                "lVar4": "var2",
                "iVar5": "error_code",
                "in_RAX": "return_value",
                "lVar6": "upper_bound",
                "__ptr": "reloc_data",
                "lVar7": "reloc_count",
                "extraout_RAX": "extra_return_value",
                "lVar8": "index",
                "uStack_28": "stack_variable"
            },
            "code": "\n\n\nundefined8 process_reloc_table_00116030(undefined8 *config_ptr,long data_ptr)\n\n{\n  long *reloc_entry_ptr;\n  long reloc_entry_value;\n  long var1;\n  long var2;\n  int error_code;\n  undefined8 return_value;\n  long upper_bound;\n  void *reloc_data;\n  long reloc_count;\n  undefined8 extra_return_value;\n  long index;\n  undefined8 stack_variable;\n  \n  if (*(long *)(data_ptr + 0x60) == 0) {\n    return return_value;\n  }\n  upper_bound = bfd_get_reloc_upper_bound();\n  if (upper_bound < 0) {\n    if ((upper_bound != -1) || (error_code = bfd_get_error(), error_code != 5)) {\n      print_error_message_0011a110(*config_ptr);\n                    \n      xexit(1);\n    }\n  }\n  else if (upper_bound != 0) {\n    reloc_data = (void *)xmalloc();\n    reloc_count = bfd_canonicalize_reloc(config_ptr,data_ptr,reloc_data);\n    var2 = _DAT_00128680;\n    var1 = _DAT_00128568;\n    upper_bound = _fwrite;\n    if (reloc_count < 0) {\n      print_error_message_0011a110(*config_ptr);\n                    \n      xexit(1);\n    }\n    if (reloc_count != 0) {\n      index = 0;\n      do {\n        reloc_entry_ptr = **(long ***)((long)reloc_data + index * 8);\n        if ((((reloc_entry_ptr != (long *)0x0) && (reloc_entry_value = *reloc_entry_ptr, reloc_entry_value != 0)) && (reloc_entry_value != upper_bound)) &&\n           ((reloc_entry_value != var2 && (reloc_entry_value != var1)))) {\n          *(uint *)(reloc_entry_value + 0x18) = *(uint *)(reloc_entry_value + 0x18) | 0x20;\n        }\n        index = index + 1;\n      } while (reloc_count != index);\n    }\n    free(reloc_data);\n    return extra_return_value;\n  }\n  return stack_variable;\n}\n\n",
            "called": [
                "FUN_0011a110",
                "bfd_canonicalize_reloc",
                "fwrite",
                "free",
                "bfd_get_reloc_upper_bound",
                "xmalloc",
                "FUN_001083b7",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116030",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "process_reloc_table_00116030"
        },
        "FUN_00113ede": {
            "renaming": {
                "FUN_00113ede": "check_string_length_00113ede",
                "param_1": "string_array",
                "__s": "current_string",
                "sVar1": "string_length",
                "uVar2": "comparison_result"
            },
            "code": "\nundefined8 check_string_length_00113ede(char **string_array)\n\n{\n  char *current_string;\n  size_t string_length;\n  undefined8 comparison_result;\n  \n  if (string_array == (char **)0x0) {\n    return 0;\n  }\n  current_string = *string_array;\n  if (current_string != (char *)0x0) {\n    string_length = strlen(current_string);\n    if (4 < (int)string_length) {\n      comparison_result = compare_strings_00113fb0(current_string + (long)(int)string_length + -4,&DAT_0012142b);\n      return comparison_result;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00113fb0",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113ede",
            "calling": [
                "FUN_001082b3",
                "FUN_0010829e"
            ],
            "imported": false,
            "current_name": "check_string_length_00113ede"
        },
        "bfd_convert_section_contents": {
            "renaming": {},
            "code": "\nvoid bfd_convert_section_contents(void)\n\n{\n  bfd_convert_section_contents();\n  return;\n}\n\n",
            "called": [
                "bfd_convert_section_contents"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001042f0",
            "calling": [
                "FUN_00116110"
            ],
            "imported": false,
            "current_name": "bfd_convert_section_contents"
        },
        "FUN_0010875d": {
            "renaming": {
                "FUN_0010875d": "compare_records_0010875d",
                "param_1": "record1",
                "param_2": "record2",
                "lVar1": "value1",
                "lVar2": "value2",
                "iVar3": "result",
                "uVar4": "flag"
            },
            "code": "\nint compareRecords_0010875d(long *record1,long *record2)\n\n{\n  long value1;\n  long value2;\n  int result;\n  uint flag;\n  \n  value1 = *record1;\n  value2 = *record2;\n  flag = *(uint *)(value2 + 0x24) & 0x102;\n  if ((*(uint *)(value1 + 0x24) & 0x102) == 0x102) {\n    if (flag != 0x102) {\n      return 1;\n    }\n  }\n  else if (flag == 0x102) {\n    return -1;\n  }\n  result = 1;\n  if (*(ulong *)(value1 + 0x38) <= *(ulong *)(value2 + 0x38)) {\n    result = -1;\n    if (*(ulong *)(value2 + 0x38) <= *(ulong *)(value1 + 0x38)) {\n      if (*(ulong *)(value2 + 0x40) < *(ulong *)(value1 + 0x40)) {\n        result = 1;\n      }\n      else {\n        result = -1;\n        if (*(ulong *)(value2 + 0x40) <= *(ulong *)(value1 + 0x40)) {\n          result = 1;\n          if (*(uint *)(value1 + 0x18) <= *(uint *)(value2 + 0x18)) {\n            return -(uint)(*(uint *)(value1 + 0x18) < *(uint *)(value2 + 0x18));\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010875d",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "compare_records_0010875d"
        },
        "cplus_demangle": {
            "renaming": {},
            "code": "\nvoid cplus_demangle(void)\n\n{\n  cplus_demangle();\n  return;\n}\n\n",
            "called": [
                "cplus_demangle"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001046b0",
            "calling": [
                "FUN_0010d21c"
            ],
            "imported": false,
            "current_name": "cplus_demangle"
        },
        "_INIT_0": {
            "renaming": {},
            "code": "\nvoid _INIT_0(void)\n\n{\n  FUNC_00116b00();\n  return;\n}\n\n",
            "called": [
                "FUN_00116b00"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116b80",
            "calling": [],
            "imported": false,
            "current_name": "_INIT_0"
        },
        "FUN_0010c892": {
            "renaming": {
                "FUN_0010c892": "process_debug_info_0010c892",
                "param_1": "function_address",
                "param_2": "debug_info_address",
                "cVar1": "clear_chain_success",
                "lVar2": "data_address",
                "lVar3": "debug_tag_address",
                "uVar4": "result",
                "puVar5": "next_debug_info",
                "iVar6": "debug_kind"
            },
            "code": "\n\n\nundefined8 process_debug_info_0010c892(undefined8 function_address,long debug_info_address)\n\n{\n  char clear_chain_success;\n  long data_address;\n  long debug_tag_address;\n  undefined8 result;\n  undefined8 *next_debug_info;\n  int debug_kind;\n  \n  if (*(char *)(debug_info_address + 0x60) == '\\0') {\nLAB_0010c8c7:\n    for (next_debug_info = *(undefined8 **)(debug_info_address + 0x1a0); next_debug_info != (undefined8 *)0x0;\n        next_debug_info = (undefined8 *)*next_debug_info) {\n      debug_kind = *(int *)(next_debug_info + 2);\n      debug_tag_address = next_debug_info[1];\n      if (debug_kind != 0) {\n        if (debug_tag_address != 0) {\n          if (debug_kind - 7U < 5) goto LAB_0010c8d5;\n          result = dcgettext(0,\"debug_make_undefined_type: unsupported kind\",5);\n          fprintf(_stderr,\"%s\\n\",result);\n        }\nLAB_0010c910:\n        next_debug_info[3] = 0;\n        goto LAB_0010c916;\n      }\n      if (debug_tag_address == 0) goto LAB_0010c910;\n      debug_kind = 7;\nLAB_0010c8d5:\n      data_address = initialize_data_00112904(debug_kind,0);\n      if (data_address == 0) goto LAB_0010c910;\n      debug_tag_address = process_debug_tag_0010c6be(function_address,debug_tag_address,data_address);\n      next_debug_info[3] = debug_tag_address;\n      if (debug_tag_address == 0) goto LAB_0010c916;\n    }\n    result = 1;\n  }\n  else {\n    clear_chain_success = clear_pointer_chain_0010c1c6();\n    if (clear_chain_success != '\\0') {\n      clear_chain_success = end_debugging_function_0010be1a(function_address,*(undefined8 *)(debug_info_address + 0x68));\n      if (clear_chain_success != '\\0') {\n        *(undefined *)(debug_info_address + 0x60) = 0;\n        *(undefined8 *)(debug_info_address + 0x68) = 0xffffffffffffffff;\n        goto LAB_0010c8c7;\n      }\n    }\nLAB_0010c916:\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [
                "fprintf",
                "FUN_0010c6be",
                "dcgettext",
                "FUN_0010be1a",
                "FUN_0010c1c6",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c892",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "process_debug_info_0010c892"
        },
        "FUN_00112904": {
            "renaming": {
                "FUN_00112904": "initialize_data_00112904",
                "param_1": "parameter1",
                "param_2": "parameter2",
                "puVar1": "allocatedMemory"
            },
            "code": "\nvoid initializeData_00112904(undefined4 parameter1,undefined4 parameter2)\n\n{\n  undefined4 *allocatedMemory;\n  \n  allocatedMemory = (undefined4 *)xmalloc(0x18);\n  *allocatedMemory = parameter1;\n  allocatedMemory[1] = parameter2;\n  *(undefined (*) [16])(allocatedMemory + 2) = ZEXT816(0);\n  return;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112904",
            "calling": [
                "FUN_0010c2d2",
                "FUN_00113b98",
                "FUN_0010c95e",
                "FUN_00113d3a",
                "FUN_00113c43",
                "FUN_00113ce0",
                "FUN_00113e23",
                "FUN_00113b71",
                "FUN_00113b4a",
                "FUN_00113bfa",
                "FUN_00113d6e",
                "FUN_00113da9",
                "FUN_0010c218",
                "FUN_0010ee3f",
                "FUN_0010c6be",
                "FUN_0010b0fa",
                "FUN_0010c892",
                "FUN_00113df2",
                "FUN_00113dfe",
                "FUN_00113cb9",
                "FUN_00113e17"
            ],
            "imported": false,
            "current_name": "initialize_data_00112904"
        },
        "FUN_00108898": {
            "renaming": {
                "FUN_00108898": "compare_strings_00108898",
                "param_1": "string1",
                "param_2": "string2",
                "iVar1": "stringComparisonResult",
                "in_RAX": "undefinedValue",
                "auVar2": "comparisonResult"
            },
            "code": "\nundefined  [16] compareStrings_00108898(char **string1,char **string2)\n\n{\n  int stringComparisonResult;\n  undefined8 undefinedValue;\n  undefined comparisonResult [16];\n  \n  stringComparisonResult = strcmp(*string1,*string2);\n  comparisonResult._1_7_ = 0;\n  comparisonResult[0] = stringComparisonResult == 0;\n  comparisonResult._8_8_ = undefinedValue;\n  return comparisonResult;\n}\n\n",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108898",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "compare_strings_00108898"
        },
        "__errno_location": {
            "renaming": {},
            "code": "\n\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = __errno_location();\n  return piVar1;\n}\n\n",
            "called": [
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001040b0",
            "calling": [
                "FUN_00104966",
                "FUN_0010882c",
                "FUN_00108200",
                "FUN_00114460",
                "FUN_0010543c",
                "FUN_00104ea2",
                "FUN_00116b90",
                "FUN_00115a90",
                "FUN_00114690",
                "FUN_00109a32",
                "FUN_00108237",
                "FUN_001199d0",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "__errno_location"
        },
        "strcasecmp": {
            "renaming": {},
            "code": "\n\n\nint strcasecmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = strcasecmp(__s1,__s2);\n  return iVar1;\n}\n\n",
            "called": [
                "strcasecmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104080",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "strcasecmp"
        },
        "strcmp": {
            "renaming": {},
            "code": "\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = strcmp(__s1,__s2);\n  return iVar1;\n}\n\n",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104470",
            "calling": [
                "FUN_00115530",
                "FUN_0010554f",
                "FUN_0010c7a0",
                "FUN_0010922b",
                "FUN_00104943",
                "FUN_00108c86",
                "FUN_0010914e",
                "FUN_0011173a",
                "FUN_0010d559",
                "FUN_00116b90",
                "FUN_0010ee3f",
                "FUN_00108898",
                "FUN_0010c6be",
                "FUN_0010b0fa",
                "FUN_0010afd5",
                "FUN_00115f50",
                "FUN_00115b70",
                "FUN_00114190"
            ],
            "imported": false,
            "current_name": "strcmp"
        },
        "FUN_0011a390": {
            "renaming": {
                "FUN_0011a390": "execute_reverse_functions_0011a390",
                "plVar4": "functionPointers",
                "uVar5": "count",
                "lVar1": "index",
                "lVar2": "previousIndex",
                "lVar3": "tempIndex"
            },
            "code": "\nvoid executeReverseFunctions_0011a390(void)\n\n{\n  long index;\n  long previousIndex;\n  long tempIndex;\n  long *functionPointers;\n  uint count;\n  \n  functionPointers = (long *)PTR_DAT_001264c0;\n  if (PTR_DAT_001264c0 != (undefined *)0x0) {\n    do {\n      count = *(int *)(functionPointers + 1) - 1;\n      if (-1 < (int)count) {\n        index = (long)(int)count;\n        count = count & 7;\n        (*(code *)functionPointers[index + 2])();\n        previousIndex = index + -1;\n        if (-1 < (int)previousIndex) {\n          tempIndex = previousIndex;\n          if (count != 0) {\n            if (count != 1) {\n              if (count != 2) {\n                if (count != 3) {\n                  if (count != 4) {\n                    if (count != 5) {\n                      if (count != 6) {\n                        (*(code *)functionPointers[index + 1])();\n                        previousIndex = index + -2;\n                      }\n                      (*(code *)functionPointers[previousIndex + 2])();\n                      previousIndex = previousIndex + -1;\n                    }\n                    (*(code *)functionPointers[previousIndex + 2])();\n                    previousIndex = previousIndex + -1;\n                  }\n                  (*(code *)functionPointers[previousIndex + 2])();\n                  previousIndex = previousIndex + -1;\n                }\n                (*(code *)functionPointers[previousIndex + 2])();\n                previousIndex = previousIndex + -1;\n              }\n              (*(code *)functionPointers[previousIndex + 2])();\n              previousIndex = previousIndex + -1;\n            }\n            (*(code *)functionPointers[previousIndex + 2])();\n            tempIndex = previousIndex + -1;\n            if ((int)(previousIndex + -1) < 0) goto LAB_0011a466;\n          }\n          do {\n            (*(code *)functionPointers[tempIndex + 2])();\n            index = tempIndex + -1;\n            (*(code *)functionPointers[tempIndex + 1])();\n            (*(code *)functionPointers[tempIndex])();\n            (*(code *)functionPointers[index])();\n            (*(code *)functionPointers[tempIndex + -2])();\n            (*(code *)functionPointers[tempIndex + -3])();\n            (*(code *)functionPointers[tempIndex + -4])();\n            (*(code *)functionPointers[tempIndex + -5])();\n            tempIndex = tempIndex + -8;\n          } while (-1 < (int)index + -7);\n        }\n      }\nLAB_0011a466:\n      functionPointers = (long *)*functionPointers;\n    } while (functionPointers != (long *)0x0);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a390",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "execute_reverse_functions_0011a390"
        },
        "FUN_0010e842": {
            "renaming": {
                "FUN_0010e842": "process_and_format_string_0010e842",
                "param_1": "input",
                "param_2": "string",
                "param_3": "count",
                "param_4": "data",
                "__s": "formatted_string",
                "sVar1": "string_length",
                "auVar2": "result"
            },
            "code": "\nundefined  [16] process_and_format_string_0010e842(undefined8 input,char *string,undefined8 count,undefined8 data)\n\n{\n  size_t string_length;\n  char *formatted_string;\n  undefined result [16];\n  \n  string_length = strlen(string);\n  formatted_string = (char *)xmalloc(string_length + 0x14);\n  sprintf(formatted_string,\"%s:c=i%ld\",string,count);\n  result._0_4_ = process_string_0010e2f0(input,0x80,0,0,formatted_string);\n  result._4_4_ = 0;\n  if ((char)result._0_4_ != '\\0') {\n    free(formatted_string);\n  }\n  result._8_8_ = data;\n  return result;\n}\n\n",
            "called": [
                "strlen",
                "free",
                "xmalloc",
                "sprintf",
                "FUN_0010e2f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e842",
            "calling": [
                "FUN_001135a5"
            ],
            "imported": false,
            "current_name": "process_and_format_string_0010e842"
        },
        "strtod": {
            "renaming": {},
            "code": "\n\n\ndouble strtod(char *__nptr,char **__endptr)\n\n{\n  double dVar1;\n  \n  dVar1 = strtod(__nptr,__endptr);\n  return dVar1;\n}\n\n",
            "called": [
                "strtod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104170",
            "calling": [
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "strtod"
        },
        "htab_elements": {
            "renaming": {},
            "code": "\nvoid htab_elements(void)\n\n{\n  htab_elements();\n  return;\n}\n\n",
            "called": [
                "htab_elements"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001044e0",
            "calling": [
                "FUN_0010554f",
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "htab_elements"
        },
        "FUN_00113cb9": {
            "renaming": {
                "FUN_00113cb9": "initialize_data_00113cb9",
                "param_1": "input_value",
                "lVar1": "data_ptr"
            },
            "code": "\nlong initialize_data_00113cb9(long input_value)\n\n{\n  long data_ptr;\n  \n  if (input_value != 0) {\n    data_ptr = initialize_data_00113cb9_00112904(0xe,0);\n    if (data_ptr == 0) {\n      data_ptr = 0;\n    }\n    else {\n      *(long *)(data_ptr + 0x10) = input_value;\n    }\n    return data_ptr;\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113cb9",
            "calling": [
                "FUN_0010c95e",
                "FUN_0010ee3f",
                "FUN_0010b0fa"
            ],
            "imported": false,
            "current_name": "initialize_data_00113cb9"
        },
        "memmove": {
            "renaming": {},
            "code": "\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memmove(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001046f0",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "memmove"
        },
        "FUN_0010eafe": {
            "renaming": {
                "FUN_0010eafe": "process_extracted_string_0010eafe",
                "param_1": "ptr_data",
                "param_2": "str_1",
                "param_3": "char_1",
                "__s": "extracted_str",
                "sVar2": "str_1_length",
                "sVar3": "extracted_str_length",
                "__s_00": "combined_str",
                "uVar1": "result"
            },
            "code": "\nundefined4 process_extracted_string_0010eafe(long ptr_data,char *str_1,char char_1)\n\n{\n  undefined4 result;\n  char *extracted_str;\n  size_t str_1_length;\n  size_t extracted_str_length;\n  char *combined_str;\n  \n  if ((*(int *)(ptr_data + 0x1f8) == 0) && (*(long *)(ptr_data + 0x1e8) == -1)) {\n    extracted_str = (char *)extract_list_item_00109b2f();\n    str_1_length = strlen(str_1);\n    extracted_str_length = strlen(extracted_str);\n    combined_str = (char *)xmalloc(str_1_length + 3 + extracted_str_length);\n    sprintf(combined_str,\"%s:%c%s\",str_1,(ulong)((-(uint)(char_1 == '\\0') & 0x20) + 0x46),extracted_str);\n    *(undefined8 *)(ptr_data + 0x1e8) = *(undefined8 *)(ptr_data + 0x10);\n    result = process_string_0010e2f0(ptr_data,0x24,0,0,combined_str);\n    if ((char)result != '\\0') {\n      free(combined_str);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "strlen",
                "free",
                "xmalloc",
                "sprintf",
                "FUN_00109b2f",
                "FUN_0010e2f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010eafe",
            "calling": [
                "FUN_001135a5"
            ],
            "imported": false,
            "current_name": "process_extracted_string_0010eafe"
        },
        "FUN_00113df2": {
            "renaming": {
                "FUN_00113df2": "initialize_data_00113df2",
                "param_1": "data_size",
                "initialize_data_00112904": "initialize_data_helper"
            },
            "code": "\nvoid initialize_data_00113df2(undefined4 data_size)\n\n{\n  initialize_data_00113df2_helper(4,data_size);\n  return;\n}\n\n",
            "called": [
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113df2",
            "calling": [
                "FUN_0010c2d2",
                "FUN_0010c95e",
                "FUN_0010ee3f",
                "FUN_0010b0fa",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "initialize_data_00113df2"
        },
        "FUN_0010a377": {
            "renaming": {
                "FUN_0010a377": "construct_data_string_0010a377",
                "param_1": "dataPtr",
                "cVar1": "flag",
                "__s": "listItem1",
                "__s_00": "listItem2",
                "sVar3": "length1",
                "sVar4": "length2",
                "__s_01": "combinedString",
                "uVar2": "result",
                "uVar5": "flagValue"
            },
            "code": "\nundefined4 constructDataString_0010a377(long dataPtr)\n\n{\n  char flag;\n  undefined4 result;\n  char *listItem1;\n  char *listItem2;\n  size_t length1;\n  size_t length2;\n  char *combinedString;\n  undefined flagValue;\n  \n  flagValue = 1;\n  flag = *(char *)(*(long *)(dataPtr + 0x60) + 0x1c);\n  listItem1 = (char *)extract_list_item_00109b2f();\n  if (flag == '\\0') {\n    flagValue = *(undefined *)(*(long *)(dataPtr + 0x60) + 0x1c);\n  }\n  listItem2 = (char *)extract_list_item_00109b2f(dataPtr);\n  length1 = strlen(listItem1);\n  length2 = strlen(listItem2);\n  combinedString = (char *)xmalloc(length1 + 3 + length2);\n  sprintf(combinedString,\"@%s,%s\",listItem2,listItem1);\n  free(listItem2);\n  free(listItem1);\n  result = allocate_and_initialize_data_00109b52(dataPtr,combinedString,0,flagValue,0);\n  if ((char)result != '\\0') {\n    free(combinedString);\n  }\n  return result;\n}\n\n",
            "called": [
                "strlen",
                "free",
                "xmalloc",
                "sprintf",
                "FUN_00109b2f",
                "FUN_00109b52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a377",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "construct_data_string_0010a377"
        },
        "FUN_0010d882": {
            "renaming": {
                "FUN_0010d882": "parse_input_0010d882",
                "param_1": "input_ptr",
                "param_2": "input_strings",
                "param_3": "output_ptr",
                "param_4": "is_error",
                "iVar1": "iteration_counter",
                "pcVar2": "current_string",
                "cVar3": "current_char",
                "lVar4": "allocated_ptr",
                "pcVar5": "current_char_ptr",
                "uVar6": "current_index",
                "bVar7": "is_not_zero",
                "local_50": "total_strings",
                "local_4c": "buffer_size",
                "local_48": "integer_part",
                "local_44": "count",
                "local_40": "temp_buffer"
            },
            "code": "\nundefined8 parse_input_0010d882(long input_ptr,char **input_strings,long *output_ptr,undefined *is_error)\n\n{\n  int iteration_counter;\n  char *current_string;\n  char current_char;\n  long allocated_ptr;\n  char *current_char_ptr;\n  ulong current_index;\n  bool is_not_zero;\n  uint total_strings;\n  undefined4 buffer_size;\n  uint integer_part;\n  int count;\n  undefined8 temp_buffer [2];\n  \n  current_string = *input_strings;\n  buffer_size = 10;\n  if (output_ptr != (long *)0x0) {\n    allocated_ptr = xmalloc();\n    *output_ptr = allocated_ptr;\n    *is_error = 0;\n  }\n  total_strings = 0;\n  while( true ) {\n    current_char_ptr = *input_strings;\n    current_char = *current_char_ptr;\n    if ((current_char == '_' || current_char == '\\0') || (current_char == 'e')) break;\n    if ((current_char == 'N') || (current_char == 'T')) {\n      *input_strings = current_char_ptr + 1;\n      if (current_char == 'T') {\n        count = 1;\n      }\n      else {\n        current_char = parse_integer_00108ea1(input_strings,&count);\n        if (current_char == '\\0') goto LAB_0010d958;\n      }\n      current_char = parse_integer_00108ea1(input_strings,&integer_part);\n      if ((current_char == '\\0') || (*(uint *)(input_ptr + 0x28) <= integer_part)) {\nLAB_0010d958:\n        print_error_message_0010911f(current_string);\n        return 0;\n      }\n      current_index = (ulong)integer_part;\n      while (iteration_counter = count + -1, is_not_zero = count != 0, count = iteration_counter, is_not_zero) {\n        temp_buffer[0] = *(undefined8 *)(*(long *)(input_ptr + 0x20) + current_index * 0x10);\n        current_char = resize_and_add_to_buffer_0010d7d4(input_ptr,temp_buffer,output_ptr,&total_strings,&buffer_size);\n        if (current_char == '\\0') {\n          return 0;\n        }\n      }\n    }\n    else {\n      current_char = resize_and_add_to_buffer_0010d7d4(input_ptr,input_strings,output_ptr,&total_strings,&buffer_size);\n      if (current_char == '\\0') {\n        return 0;\n      }\n    }\n  }\n  if (output_ptr == (long *)0x0) {\n    if (current_char != 'e') goto LAB_0010d9fa;\n  }\n  else {\n    *(undefined8 *)(*output_ptr + (ulong)total_strings * 8) = 0;\n    if (*current_char_ptr != 'e') goto LAB_0010d9fa;\n    *is_error = 1;\n  }\n  current_char_ptr = current_char_ptr + 1;\n  *input_strings = current_char_ptr;\nLAB_0010d9fa:\n  return CONCAT71((int7)((ulong)current_char_ptr >> 8),1);\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00108ea1",
                "FUN_0010d7d4",
                "FUN_0010911f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010d882",
            "calling": [
                "FUN_0010c95e",
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "parse_input_0010d882"
        },
        "strtoul": {
            "renaming": {},
            "code": "\n\n\nulong strtoul(char *__nptr,char **__endptr,int __base)\n\n{\n  ulong uVar1;\n  \n  uVar1 = strtoul(__nptr,__endptr,__base);\n  return uVar1;\n}\n\n",
            "called": [
                "strtoul"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104790",
            "calling": [
                "FUN_00116b90",
                "FUN_00109a32"
            ],
            "imported": false,
            "current_name": "strtoul"
        },
        "FUN_00112925": {
            "renaming": {
                "FUN_00112925": "initialize_data_structure_00112925",
                "param_1": "dataStructure",
                "param_2": "value",
                "param_3": "param3",
                "param_4": "param4",
                "puVar1": "ptr",
                "pauVar2": "ptrArray",
                "lVar3": "loopCounter",
                "puVar4": "ptr2",
                "bVar5": "byteVar",
                "ZEXT816": "zeroExtend",
                "xmalloc": "allocateMemory"
            },
            "code": "\nundefined4 *\ninitializeDataStructure_00112925(undefined (**dataStructure) [16],undefined8 value,undefined4 param3,undefined4 param4)\n\n{\n  undefined4 *ptr;\n  undefined (*ptrArray) [16];\n  long loopCounter;\n  undefined4 *ptr2;\n  byte byteVar;\n  \n  byteVar = 0;\n  ptr = (undefined4 *)xmalloc(0x28);\n  ptr2 = ptr;\n  for (loopCounter = 10; loopCounter != 0; loopCounter = loopCounter + -1) {\n    *ptr2 = 0;\n    ptr2 = ptr2 + (ulong)byteVar * -2 + 1;\n  }\n  ptrArray = *dataStructure;\n  *(undefined8 *)(ptr + 2) = value;\n  ptr[5] = param3;\n  ptr[6] = param4;\n  if (ptrArray == (undefined (*) [16])0x0) {\n    ptrArray = (undefined (*) [16])xmalloc(0x10);\n    *ptrArray = zeroExtend(0);\n    *dataStructure = ptrArray;\n    *(undefined (**) [16])(*ptrArray + 8) = ptrArray;\n  }\n  **(undefined8 **)(*ptrArray + 8) = ptr;\n  *(undefined4 **)(*ptrArray + 8) = ptr;\n  return ptr;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112925",
            "calling": [
                "FUN_0010c218",
                "FUN_0010c6be",
                "FUN_0010bc80",
                "FUN_00112996",
                "FUN_0010c05d"
            ],
            "imported": false,
            "current_name": "initialize_data_structure_00112925"
        },
        "FUN_0010bf86": {
            "renaming": {
                "FUN_0010bf86": "record_line_info_0010bf86",
                "param_1": "unitPtr",
                "param_2": "linePtr",
                "param_3": "dataPtr",
                "uVar1": "errMsg",
                "puVar2": "currentUnitPtr",
                "uVar3": "counter",
                "lVar5": "tempVar",
                "puVar4": "xmallocPtr",
                "puVar6": "puVarPtr",
                "bVar7": "byteVar"
            },
            "code": "\n\n\nundefined8 recordLineInfo_0010bf86(long unitPtr,undefined8 linePtr,undefined8 dataPtr)\n\n{\n  undefined8 errMsg;\n  undefined8 *currentUnitPtr;\n  ulong counter;\n  undefined4 *xmallocPtr;\n  long tempVar;\n  undefined4 *puVarPtr;\n  byte byteVar;\n  \n  byteVar = 0;\n  if (*(long *)(unitPtr + 8) == 0) {\n    errMsg = dcgettext(0,\"debug_record_line: no current unit\",5);\n    fprintf(_stderr,\"%s\\n\",errMsg);\n    errMsg = 0;\n  }\n  else {\n    tempVar = *(long *)(unitPtr + 0x28);\n    if ((tempVar != 0) && (*(long *)(tempVar + 8) == *(long *)(unitPtr + 0x10))) {\n      counter = 0;\n      do {\n        if (*(long *)(tempVar + 0x10 + counter * 8) == -1) {\n          currentUnitPtr = (undefined8 *)(counter & 0xffffffff);\n          *(undefined8 *)(tempVar + 0x10 + (long)currentUnitPtr * 8) = linePtr;\n          *(undefined8 *)(tempVar + 0x60 + (long)currentUnitPtr * 8) = dataPtr;\n          goto LAB_0010c056;\n        }\n        counter = counter + 1;\n      } while (counter != 10);\n    }\n    xmallocPtr = (undefined4 *)xmalloc(0xb0);\n    puVarPtr = xmallocPtr;\n    for (tempVar = 0x2c; tempVar != 0; tempVar = tempVar + -1) {\n      *puVarPtr = 0;\n      puVarPtr = puVarPtr + (ulong)byteVar * -2 + 1;\n    }\n    errMsg = *(undefined8 *)(unitPtr + 0x10);\n    *(undefined8 *)(xmallocPtr + 4) = linePtr;\n    *(undefined8 *)(xmallocPtr + 2) = errMsg;\n    *(undefined8 *)(xmallocPtr + 0x18) = dataPtr;\n    puVarPtr = xmallocPtr + 6;\n    for (tempVar = 0x48; tempVar != 0; tempVar = tempVar + -1) {\n      *(undefined *)puVarPtr = 0xff;\n      puVarPtr = (undefined4 *)((long)puVarPtr + (ulong)byteVar * -2 + 1);\n    }\n    currentUnitPtr = *(undefined8 **)(unitPtr + 0x28);\n    if (currentUnitPtr == (undefined8 *)0x0) {\n      currentUnitPtr = *(undefined8 **)(unitPtr + 8);\n      currentUnitPtr[2] = xmallocPtr;\n    }\n    else {\n      *currentUnitPtr = xmallocPtr;\n    }\n    *(undefined4 **)(unitPtr + 0x28) = xmallocPtr;\nLAB_0010c056:\n    errMsg = CONCAT71((int7)((ulong)currentUnitPtr >> 8),1);\n  }\n  return errMsg;\n}\n\n",
            "called": [
                "fprintf",
                "xmalloc",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bf86",
            "calling": [
                "FUN_0011173a",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "record_line_info_0010bf86"
        },
        "qsort": {
            "renaming": {},
            "code": "\n\n\nvoid qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)\n\n{\n  qsort(__base,__nmemb,__size,__compar);\n  return;\n}\n\n",
            "called": [
                "qsort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104140",
            "calling": [
                "FUN_0010554f",
                "FUN_00116852",
                "FUN_001086af"
            ],
            "imported": false,
            "current_name": "qsort"
        },
        "FUN_0011a170": {
            "renaming": {
                "FUN_0011a170": "pattern_match_0011a170",
                "param_1": "pattern",
                "param_2": "input",
                "__pattern": "currentPattern",
                "iVar1": "matchResult"
            },
            "code": "\nint patternMatch_0011a170(char **pattern,char **input)\n\n{\n  char *currentPattern;\n  int matchResult;\n  \n  currentPattern = *pattern;\n  if (*currentPattern == '!') {\n    matchResult = fnmatch(currentPattern + 1,*input,0);\n    if (matchResult == 0) {\n      *(undefined *)(input + 1) = 0;\n      return matchResult;\n    }\n  }\n  else {\n    matchResult = fnmatch(currentPattern,*input,0);\n    if (matchResult == 0) {\n      *(undefined *)(input + 1) = 1;\n    }\n  }\n  return 1;\n}\n\n",
            "called": [
                "fnmatch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a170",
            "calling": [
                "FUN_0010554f",
                "FUN_00115d70"
            ],
            "imported": false,
            "current_name": "pattern_match_0011a170"
        },
        "FUN_0010bd62": {
            "renaming": {
                "FUN_0010bd62": "record_parameter_0010bd62",
                "param_1": "function_ptr",
                "param_2": "param_ptr",
                "param_3": "param_size",
                "param_4": "param_type",
                "param_5": "param_data",
                "puVar1": "current_ptr",
                "uVar2": "error_message",
                "puVar3": "new_param_ptr",
                "puVar7": "temp_ptr",
                "lVar5": "loop_counter",
                "puVar6": "prev_ptr",
                "puVar4": "next_ptr",
                "bVar8": "byte_flag"
            },
            "code": "\n\n\nundefined8\nrecord_parameter_0010bd62(long function_ptr,long param_ptr,long param_size,undefined4 param_type,undefined8 param_data)\n\n{\n  undefined8 *current_ptr;\n  undefined8 error_message;\n  undefined4 *new_param_ptr;\n  undefined8 *next_ptr;\n  long loop_counter;\n  undefined8 *prev_ptr;\n  undefined4 *temp_ptr;\n  byte byte_flag;\n  \n  byte_flag = 0;\n  if (param_ptr == 0) {\n    return 0;\n  }\n  if (param_size != 0) {\n    if ((*(long *)(function_ptr + 8) != 0) && (*(long *)(function_ptr + 0x18) != 0)) {\n      new_param_ptr = (undefined4 *)xmalloc(0x28);\n      temp_ptr = new_param_ptr;\n      for (loop_counter = 10; loop_counter != 0; loop_counter = loop_counter + -1) {\n        *temp_ptr = 0;\n        temp_ptr = temp_ptr + (ulong)byte_flag * -2 + 1;\n      }\n      loop_counter = *(long *)(function_ptr + 0x18);\n      *(long *)(new_param_ptr + 2) = param_ptr;\n      *(long *)(new_param_ptr + 4) = param_size;\n      new_param_ptr[6] = param_type;\n      current_ptr = *(undefined8 **)(loop_counter + 8);\n      *(undefined8 *)(new_param_ptr + 8) = param_data;\n      prev_ptr = (undefined8 *)(loop_counter + 8);\n      while (next_ptr = current_ptr, next_ptr != (undefined8 *)0x0) {\n        prev_ptr = next_ptr;\n        current_ptr = (undefined8 *)*next_ptr;\n      }\n      *prev_ptr = new_param_ptr;\n      return 1;\n    }\n    error_message = dcgettext(0,\"debug_record_parameter_0010bd62: no current function\",5);\n    fprintf(_stderr,\"%s\\n\",error_message);\n  }\n  return 0;\n}\n\n",
            "called": [
                "fprintf",
                "xmalloc",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bd62",
            "calling": [
                "FUN_0011173a",
                "FUN_00112a33"
            ],
            "imported": false,
            "current_name": "record_parameter_0010bd62"
        },
        "FUN_00104ea2": {
            "renaming": {
                "FUN_00104ea2": "copy_and_extract_archive_00104ea2",
                "cVar1": "charFlag",
                "iVar2": "intValue",
                "ppcVar3": "pointerPointerChar",
                "pvVar4": "voidPointer",
                "lVar5": "longValue",
                "ppcVar6": "pointerPointerChar",
                "pcVar7": "pointerChar",
                "puVar8": "undefined8Pointer",
                "piVar9": "pointerInt",
                "pcVar10": "pointerChar",
                "uVar11": "undefined8Value",
                "lVar12": "longValue",
                "pcVar13": "codePointer",
                "lVar14": "longValue",
                "unaff_EBX": "unaffected_EBX",
                "unaff_RBP": "unaffected_RBP",
                "pcVar15": "pointerChar",
                "psVar16": "pointerStat",
                "unaff_R12": "unaffected_R12",
                "unaff_R13": "unaffected_R13",
                "unaff_R15": "unaffected_R15",
                "bVar17": "byteVar",
                "unaff_retaddr": "unaffected_return_address"
            },
            "code": "\nvoid copyAndExtractArchive_00104ea2(void)\n\n{\n  char charFlag;\n  int intValue;\n  char **pointerPointerChar;\n  void *voidPointer;\n  long longValue;\n  char **pointerPointerChar;\n  char *pointerChar;\n  undefined8 *undefined8Pointer;\n  int *pointerInt;\n  char *pointerChar;\n  undefined8 undefined8Value;\n  long longValue;\n  code *codePointer;\n  long longValue;\n  int unaffected_EBX;\n  stat *unaffected_RBP;\n  char *pointerChar;\n  stat *pointerStat;\n  char *unaffected_R12;\n  undefined8 *unaffected_R13;\n  char **unaffected_R15;\n  byte byteVar;\n  undefined8 unaffected_return_address;\n  undefined8 *param_7;\n  long *param_8;\n  char *param_9;\n  undefined8 *param_10;\n  undefined8 param_11;\n  undefined8 in_stack_00000030;\n  uint param_18;\n  long param_19;\n  \n  byteVar = 0;\ncode_r0x00104ea2:\n  pointerPointerChar = (char **)bfd_openw(unaffected_R12,param_11);\n  if (pointerPointerChar == (char **)0x0) {\nLAB_00104e80:\n    display_error_001126c0(unaffected_R12,0,0,0);\nLAB_00104e93:\n    DAT_00127a20 = 1;\n  }\n  else {\nLAB_00114a5f:\n    charFlag = FUNC_00114e50(unaffected_R15,pointerPointerChar,unaffected_return_address);\n    if (charFlag == '\\0') {\n      intValue = bfd_get_arch(unaffected_R15);\n      if (intValue == 0) goto LAB_00104d75;\n      charFlag = bfd_close_all_done(pointerPointerChar);\n      if (charFlag != '\\0') goto LAB_00104ec9;\n      display_error_001126c0(unaffected_R12,0,0,0);\n      goto LAB_00104ec9;\n    }\n    charFlag = bfd_close(pointerPointerChar);\n    pointerPointerChar = unaffected_R15;\n    if (charFlag == '\\0') {\n      display_error_001126c0(unaffected_R12,0,0,0);\n      DAT_00127a20 = 1;\n    }\nLAB_00114a86:\n    if ((DAT_001279cb != '\\0') && (unaffected_EBX == 0)) {\n      set_file_time_0011a350(unaffected_R12,unaffected_RBP);\n    }\n    longValue = bfd_openr(unaffected_R12,param_11);\n    unaffected_R13[2] = longValue;\n    *param_8 = longValue;\n    param_8 = (long *)(longValue + 0xf0);\n    unaffected_R15 = (char **)bfd_openr_next_archived_file(param_10,pointerPointerChar);\n    bfd_close(pointerPointerChar);\n    while ((DAT_00127a20 == 0 && (unaffected_R15 != (char **)0x0))) {\n      pointerChar = *unaffected_R15;\n      pointerChar = pointerChar;\n      if (*pointerChar == '/') {\nLAB_0010527d:\n        undefined8Value = dcgettext(0,\"illegal pathname found in archive member: %s\",5);\n        print_error_message_00119ed0(undefined8Value,pointerChar);\n        goto LAB_00104e93;\n      }\n      while (*pointerChar != '\\0') {\n        pointerChar = pointerChar;\n        if ((*pointerChar == '.') && (pointerChar = pointerChar + 1, pointerChar[1] == '.')) {\n          pointerChar = pointerChar + 2;\n          if ((pointerChar[2] == '\\0') || (pointerChar[2] == '/')) goto LAB_0010527d;\n        }\n        for (; (*pointerChar != '\\0' && (*pointerChar != '/')); pointerChar = pointerChar + 1) {\n        }\n        pointerChar = pointerChar;\n        if (*pointerChar == '/') {\n          copy_archive_001052a2();\n          return;\n        }\n      }\n      unaffected_RBP = (stat *)&stack0x00000050;\n      unaffected_R12 = (char *)concat(param_9,&DAT_0011b47d);\n      intValue = stat(unaffected_R12,unaffected_RBP);\n      undefined8Pointer = unaffected_R13;\n      if (-1 < intValue) {\n        longValue = create_temp_directory_0011a0e0(unaffected_R12);\n        free(unaffected_R12);\n        if (longValue == 0) {\n          pointerInt = __errno_location();\n          pointerChar = strerror(*pointerInt);\n          undefined8Value = dcgettext(0,\"cannot create tempdir for archive copying (error: %s)\",5);\n          print_error_message_00119ed0(undefined8Value,pointerChar);\n          goto LAB_00104e93;\n        }\n        undefined8Pointer = (undefined8 *)xmalloc(0x18);\n        pointerChar = *unaffected_R15;\n        *undefined8Pointer = unaffected_R13;\n        undefined8Pointer[2] = 0;\n        undefined8Pointer[1] = longValue;\n        unaffected_R12 = (char *)concat(longValue,&DAT_0011b47d,pointerChar);\n      }\n      unaffected_EBX = 0;\n      if (DAT_001279cb != '\\0') {\n        pointerStat = unaffected_RBP;\n        for (longValue = 0x24; longValue != 0; longValue = longValue + -1) {\n          *(undefined4 *)&pointerStat->st_dev = 0;\n          pointerStat = (stat *)((long)pointerStat + (ulong)byteVar * -8 + 4);\n        }\n        pointerPointerChar = (char **)unaffected_R15[0x1d];\n        if ((char **)unaffected_R15[0x1d] == (char **)0x0) {\n          pointerPointerChar = unaffected_R15;\n        }\n        unaffected_EBX = (**(code **)(pointerPointerChar[1] + 0x1e8))(unaffected_R15,unaffected_RBP);\n        if (unaffected_EBX != 0) {\n          pointerChar = *unaffected_R15;\n          undefined8Value = dcgettext(0,\"internal stat error on %s\",5);\n          print_error_message_00119ed0(undefined8Value,pointerChar);\n        }\n      }\n      unaffected_R13 = (undefined8 *)xmalloc(0x18);\n      unaffected_R13[1] = unaffected_R12;\n      *unaffected_R13 = undefined8Pointer;\n      unaffected_R13[2] = 0;\n      charFlag = bfd_check_format(unaffected_R15,1);\n      if (charFlag != '\\0') {\n        if (in_stack_00000030._7_1_ != '\\0') goto code_r0x00104ea2;\n        pointerPointerChar = (char **)bfd_openw(unaffected_R12,*(undefined8 *)unaffected_R15[1]);\n        if (pointerPointerChar == (char **)0x0) goto LAB_00104e80;\n        goto LAB_00114a5f;\n      }\n      undefined8Value = dcgettext(0,\"Unable to recognise the format of file\",5);\n      display_error_001126c0(0,unaffected_R15,0,undefined8Value);\n      pointerPointerChar = (char **)bfd_openw(unaffected_R12,param_11);\n      if (pointerPointerChar == (char **)0x0) goto LAB_00104e80;\nLAB_00104d75:\n      pointerPointerChar = (char **)unaffected_R15[0x1d];\n      if ((char **)unaffected_R15[0x1d] == (char **)0x0) {\n        pointerPointerChar = unaffected_R15;\n      }\n      intValue = (**(code **)(pointerPointerChar[1] + 0x1e8))(unaffected_R15);\n      longValue = param_19;\n      if (intValue == 0) {\n        if (param_19 < 0) {\n          get_formatted_string_001125fa(unaffected_R15);\n          undefined8Value = dcgettext(0,\"stat returns negative size for `%s\\'\",5);\n          print_error_message_00119ed0(undefined8Value);\n        }\n        else {\n          intValue = bfd_seek(unaffected_R15,0,0);\n          if (intValue == 0) {\n            if (DAT_001279c9 != '\\0') {\n              pointerChar = *pointerPointerChar;\n              undefined8Value = get_formatted_string_001125fa(unaffected_R15);\n              pointerChar = (char *)dcgettext(0,\"copy from `%s\\' [unknown] to `%s\\' [unknown]\\n\",5);\n              printf(pointerChar,undefined8Value,pointerChar);\n            }\n            voidPointer = (void *)xmalloc(0x2000);\n            while( true ) {\n              if (longValue == 0) {\n                chmod(*pointerPointerChar,param_18 | 0x100);\n                free(voidPointer);\n                charFlag = bfd_close_all_done(pointerPointerChar);\n                pointerPointerChar = unaffected_R15;\n                if (charFlag == '\\0') {\n                  display_error_001126c0(unaffected_R12,0,0,0);\n                  DAT_00127a20 = 1;\n                }\n                goto LAB_00114a86;\n              }\n              longValue = 0x2000;\n              if (longValue < 0x2001) {\n                longValue = longValue;\n              }\n              longValue = bfd_bread(voidPointer,longValue,unaffected_R15);\n              pointerPointerChar = unaffected_R15;\n              if ((longValue != longValue) ||\n                 (longValue = bfd_bwrite(voidPointer,longValue,pointerPointerChar), pointerPointerChar = pointerPointerChar, longValue != longValue))\n              break;\n              longValue = longValue - longValue;\n            }\n            display_error_001126c0(0,pointerPointerChar,0,0);\n            free(voidPointer);\n          }\n          else {\n            undefined8Value = get_formatted_string_001125fa(unaffected_R15);\n            print_error_message_0011a110(undefined8Value);\n          }\n        }\n      }\n      else {\n        display_error_001126c0(0,unaffected_R15,0,0);\n      }\n      charFlag = bfd_close_all_done(pointerPointerChar);\n      if (charFlag == '\\0') {\n        display_error_001126c0(unaffected_R12,0,0,0);\n      }\nLAB_00104ec9:\n      unlink(unaffected_R12);\n      DAT_00127a20 = 1;\n    }\n    *param_8 = 0;\n    voidPointer = (void *)xstrdup(*param_7);\n    if (DAT_00127a20 == 0) {\n      codePointer = bfd_close;\n    }\n    else {\n      codePointer = bfd_close_all_done;\n    }\n    charFlag = (*codePointer)(param_7);\n    if (charFlag == '\\0') {\n      DAT_00127a20 = 1;\n      display_error_001126c0(voidPointer,0,0,0);\n    }\n    free(voidPointer);\n    voidPointer = (void *)xstrdup(*param_10);\n    charFlag = bfd_close(param_10);\n    if (charFlag == '\\0') {\n      DAT_00127a20 = 1;\n      display_error_001126c0(voidPointer,0,0,0);\n    }\n    free(voidPointer);\n  }\n  while (unaffected_R13 != (undefined8 *)0x0) {\n    if (unaffected_R13[2] == 0) {\n      rmdir((char *)unaffected_R13[1]);\n    }\n    else {\n      bfd_close();\n      unlink((char *)unaffected_R13[1]);\n    }\n    free((void *)unaffected_R13[1]);\n    undefined8Pointer = (undefined8 *)*unaffected_R13;\n    free(unaffected_R13);\n    unaffected_R13 = undefined8Pointer;\n  }\n  rmdir(param_9);\n  free(param_9);\n  return;\n}\n\n",
            "called": [
                "bfd_close_all_done",
                "stat",
                "bfd_close",
                "xmalloc",
                "rmdir",
                "bfd_openw",
                "bfd_close",
                "__errno_location",
                "FUN_00114e50",
                "bfd_seek",
                "FUN_00119ed0",
                "strerror",
                "FUN_001126c0",
                "concat",
                "printf",
                "FUN_0011a0e0",
                "FUN_00114b84",
                "FUN_001052a2",
                "chmod",
                "dcgettext",
                "bfd_close_all_done",
                "bfd_bread",
                "bfd_get_arch",
                "FUN_0011a110",
                "FUN_00104ea2",
                "bfd_openr_next_archived_file",
                "bfd_check_format",
                "xstrdup",
                "unlink",
                "free",
                "FUN_0011a350",
                "bfd_bwrite",
                "FUN_001125fa",
                "bfd_openr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104ea2",
            "calling": [
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "copy_and_extract_archive_00104ea2"
        },
        "bfd_errmsg": {
            "renaming": {},
            "code": "\nvoid bfd_errmsg(void)\n\n{\n  bfd_errmsg();\n  return;\n}\n\n",
            "called": [
                "bfd_errmsg"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047a0",
            "calling": [
                "FUN_0011a110",
                "FUN_0010554f",
                "FUN_00116b90",
                "FUN_0010e07c",
                "FUN_001126c0",
                "FUN_0011378f",
                "FUN_0010e6a8",
                "FUN_0010dac0",
                "FUN_0010e2f0"
            ],
            "imported": false,
            "current_name": "bfd_errmsg"
        },
        "fwrite": {
            "renaming": {},
            "code": "\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fwrite(__ptr,__size,__n,__s);\n  return sVar1;\n}\n\n",
            "called": [
                "fwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104800",
            "calling": [
                "FUN_00108b3e",
                "FUN_001126c0",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "fwrite"
        },
        "FUN_00113ce0": {
            "renaming": {
                "FUN_00113ce0": "initialize_and_store_data_00113ce0",
                "param_1": "data_1",
                "param_2": "data_2",
                "param_3": "data_3",
                "param_4": "data_4",
                "param_5": "data_5",
                "lVar1": "initialized_data",
                "plVar2": "allocated_data",
                "auVar3": "result"
            },
            "code": "\nundefined  [16]\ninitialize_and_store_data_00113ce0(long data_1,long data_2,undefined data_3,undefined8 data_4,undefined8 data_5)\n\n{\n  long initialized_data;\n  long *allocated_data;\n  undefined result [16];\n  \n  if (data_1 != 0) {\n    initialized_data = initialize_data_00112904(0xd,0);\n    if (initialized_data != 0) {\n      allocated_data = (long *)xmalloc(0x18);\n      *(undefined4 *)((long)allocated_data + 0x11) = 0;\n      *allocated_data = data_1;\n      *(undefined4 *)((long)allocated_data + 0x14) = 0;\n      allocated_data[1] = data_2;\n      *(undefined *)(allocated_data + 2) = data_3;\n      *(long **)(initialized_data + 0x10) = allocated_data;\n      goto LAB_00113d2f;\n    }\n  }\n  initialized_data = 0;\nLAB_00113d2f:\n  result._8_8_ = data_5;\n  result._0_8_ = initialized_data;\n  return result;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113ce0",
            "calling": [
                "FUN_0011173a",
                "FUN_0010c95e",
                "FUN_0010ee3f",
                "FUN_0010b0fa",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "initialize_and_store_data_00113ce0"
        },
        "FUN_00114dc7": {
            "renaming": {
                "FUN_00114dc7": "read_from_stream_00114dc7",
                "unaff_RBX": "stream",
                "unaff_RBP": "bufferPointer",
                "unaff_R12": "startOffset",
                "unaff_R14": "endOffset",
                "iVar1": "error",
                "sVar4": "bytesRead",
                "uVar2": "errorString",
                "uVar3": "errorMessage"
            },
            "code": "\nvoid readFromStream_00114dc7(void)\n\n{\n  int error;\n  undefined8 errorString;\n  undefined8 errorMessage;\n  size_t bytesRead;\n  FILE *stream;\n  long bufferPointer;\n  long startOffset;\n  long endOffset;\n  \n  while( true ) {\n    bytesRead = fread((void *)(*(long *)(bufferPointer + 0x20) + startOffset),1,endOffset - startOffset,\n                  stream);\n    error = ferror(stream);\n    if (error != 0) {\n      errorMessage = *(undefined8 *)(bufferPointer + 0x10);\n      errorString = dcgettext(0,\"%s: fread failed\",5);\n                    \n      print_error_and_exit_00119dd0(errorString,errorMessage);\n    }\n    startOffset = startOffset + bytesRead;\n    error = feof(stream);\n    if (error != 0) break;\n    if (startOffset == endOffset) {\n      endOffset = startOffset * 2;\n      errorMessage = xrealloc(*(undefined8 *)(bufferPointer + 0x20),endOffset);\n      *(undefined8 *)(bufferPointer + 0x20) = errorMessage;\n    }\n  }\n  *(long *)(bufferPointer + 0x18) = startOffset;\n  fclose(stream);\n  return;\n}\n\n",
            "called": [
                "fclose",
                "ferror",
                "FUN_00119dd0",
                "xrealloc",
                "dcgettext",
                "FUN_00114dc7",
                "fread",
                "feof"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114dc7",
            "calling": [
                "FUN_00114dc7"
            ],
            "imported": false,
            "current_name": "read_from_stream_00114dc7"
        },
        "FUN_00119f70": {
            "renaming": {
                "FUN_00119f70": "process_input_data_00119f70",
                "param_1": "header_data",
                "param_2": "output_file_info",
                "uVar1": "status",
                "cVar2": "char_value",
                "iVar3": "data_index",
                "uVar4": "endianness_header",
                "uVar5": "endianness_data",
                "__format": "format_string",
                "lVar6": "data_size",
                "uVar7": "header_value",
                "lVar8": "realloc_ptr"
            },
            "code": "\nundefined4 process_input_data_00119f70(undefined8 *header_data,undefined8 *output_file_info)\n\n{\n  undefined4 status;\n  char char_value;\n  int data_index;\n  undefined8 endianness_header;\n  undefined8 endianness_data;\n  char *format_string;\n  long data_size;\n  undefined8 header_value;\n  long realloc_ptr;\n  \n  data_index = *(int *)((long)output_file_info + 0xc) + 1;\n  *(int *)((long)output_file_info + 0xc) = data_index;\n  if ((ulong)output_file_info[2] < (ulong)((long)data_index * 0x60)) {\n    data_size = 0x3000;\n    if (0x3f < data_index) {\n      data_size = (long)data_index * 0xc0;\n    }\n    realloc_ptr = xrealloc(output_file_info[3]);\n    output_file_info[3] = realloc_ptr;\n    memset((void *)(realloc_ptr + output_file_info[2]),0,data_size - output_file_info[2]);\n    output_file_info[2] = data_size;\n  }\n  status = *(undefined4 *)((long)header_data + 0xc);\n  *(undefined8 *)((long)*(int *)((long)output_file_info + 0xc) * 0x60 + output_file_info[3] + -0x60) = *header_data;\n  endianness_header = get_endianness_type_00114e00(status);\n  endianness_data = get_endianness_type_00114e00(*(undefined4 *)(header_data + 2));\n  header_value = *header_data;\n  format_string = (char *)dcgettext(0,\"%s\\n (header %s, data %s)\\n\",5);\n  printf(format_string,header_value,endianness_data,endianness_header);\n  data_size = bfd_openw(*output_file_info,*header_data);\n  if (data_size == 0) {\n    print_error_message_0011a110(*output_file_info);\n    *(undefined4 *)(output_file_info + 1) = 1;\n  }\n  else {\n    data_index = 2;\n    char_value = bfd_set_format(data_size,1);\n    if (char_value == '\\0') {\n      data_index = bfd_get_error();\n      if (data_index != 5) {\n        print_error_message_0011a110(*header_data);\n        *(undefined4 *)(output_file_info + 1) = 1;\n      }\n    }\n    else {\n      do {\n        char_value = (**(code **)(*(long *)(data_size + 8) + 0x2a0))(data_size,data_index,0);\n        if (char_value != '\\0') {\n          header_value = bfd_printable_arch_mach(data_index,0);\n          printf(\"  %s\\n\",header_value);\n          *(undefined *)\n           ((long)*(int *)((long)output_file_info + 0xc) * 0x60 + output_file_info[3] + -0x58 + (ulong)(data_index - 2)) =\n               1;\n        }\n        data_index = data_index + 1;\n      } while (data_index != 0x57);\n    }\n    bfd_close_all_done(data_size);\n  }\n  return *(undefined4 *)(output_file_info + 1);\n}\n\n",
            "called": [
                "memset",
                "bfd_set_format",
                "FUN_0011a110",
                "bfd_openw",
                "xrealloc",
                "bfd_printable_arch_mach",
                "dcgettext",
                "bfd_close_all_done",
                "bfd_get_error",
                "FUN_00114e00",
                "printf",
                "FUN_001053d5"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00119f70",
            "calling": [
                "FUN_001199d0"
            ],
            "imported": false,
            "current_name": "process_input_data_00119f70"
        },
        "unlink": {
            "renaming": {},
            "code": "\n\n\nint unlink(char *__name)\n\n{\n  int iVar1;\n  \n  iVar1 = unlink(__name);\n  return iVar1;\n}\n\n",
            "called": [
                "unlink"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001040c0",
            "calling": [
                "FUN_00104ea2",
                "FUN_00108200",
                "FUN_001199d0"
            ],
            "imported": false,
            "current_name": "unlink"
        },
        "FUN_00115a90": {
            "renaming": {
                "FUN_00115a90": "copy_file_00115a90",
                "param_1": "source_file_descriptor",
                "param_2": "destination_filename",
                "param_3": "file_mode_info",
                "iVar1": "original_errno",
                "iVar2": "read_result",
                "__fd": "destination_file_descriptor",
                "_Var3": "file_seek_position",
                "uVar4": "copy_result",
                "sVar5": "write_result",
                "piVar6": "errno_pointer",
                "local_2038": "buffer"
            },
            "code": "\nulong copy_file_00115a90(int source_file_descriptor,char *destination_filename,long file_mode_info)\n\n{\n  int original_errno;\n  int destination_file_descriptor;\n  int read_result;\n  __off_t file_seek_position;\n  ulong copy_result;\n  size_t write_result;\n  int *errno_pointer;\n  undefined buffer [8200];\n  \n  if ((-1 < source_file_descriptor) && (file_seek_position = lseek(source_file_descriptor,0,0), file_seek_position == 0)) {\n    destination_file_descriptor = open(destination_filename,0x201);\n    if (destination_file_descriptor < 0) {\n      copy_result = close_file_and_return_error_00108237();\n      return copy_result;\n    }\n    do {\n      copy_result = read(source_file_descriptor,buffer,0x2000);\n      read_result = (int)copy_result;\n      if (read_result < 1) {\n        errno_pointer = __errno_location();\n        original_errno = *errno_pointer;\n        fchmod(destination_file_descriptor,*(__mode_t *)(file_mode_info + 0x18));\n        close(source_file_descriptor);\n        close(destination_file_descriptor);\n        if (read_result != 0) {\n          *errno_pointer = original_errno;\n          return 0xffffffff;\n        }\n        return copy_result & 0xffffffff;\n      }\n      write_result = write(destination_file_descriptor,buffer,(long)read_result);\n    } while (write_result == (long)read_result);\n    errno_pointer = __errno_location();\n    read_result = *errno_pointer;\n    close(source_file_descriptor);\n    close(destination_file_descriptor);\n    *errno_pointer = read_result;\n  }\n  return 0xffffffff;\n}\n\n",
            "called": [
                "read",
                "close",
                "__errno_location",
                "open",
                "write",
                "fchmod",
                "FUN_00108237",
                "lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115a90",
            "calling": [
                "FUN_00115970"
            ],
            "imported": false,
            "current_name": "copy_file_00115a90"
        },
        "strncpy": {
            "renaming": {},
            "code": "\n\n\nchar * strncpy(char *__dest,char *__src,size_t __n)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strncpy(__dest,__src,__n);\n  return pcVar1;\n}\n\n",
            "called": [
                "strncpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001040d0",
            "calling": [
                "FUN_00116b90",
                "FUN_00104ad6"
            ],
            "imported": false,
            "current_name": "strncpy"
        },
        "bfd_bwrite": {
            "renaming": {},
            "code": "\nvoid bfd_bwrite(void)\n\n{\n  bfd_bwrite();\n  return;\n}\n\n",
            "called": [
                "bfd_bwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104530",
            "calling": [
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "bfd_bwrite"
        },
        "utimensat": {
            "renaming": {},
            "code": "\n\n\nint utimensat(int __fd,char *__path,timespec *__times,int __flags)\n\n{\n  int iVar1;\n  \n  iVar1 = utimensat(__fd,__path,__times,__flags);\n  return iVar1;\n}\n\n",
            "called": [
                "utimensat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104060",
            "calling": [
                "FUN_0011a350"
            ],
            "imported": false,
            "current_name": "utimensat"
        },
        "getc": {
            "renaming": {},
            "code": "\n\n\nint getc(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = getc(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048b0",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "getc"
        },
        "FUN_00108200": {
            "renaming": {
                "FUN_00108200": "copy_and_print_error_00108200",
                "unaff_RBP": "sourceFile",
                "unaff_R12B": "shouldSetTime",
                "unaff_R13": "flags",
                "unaff_retaddr": "returnAddress"
            },
            "code": "\nundefined  [16] copyAndPrintError_00108200(void)\n\n{\n  int *piVar1;\n  undefined8 uVar2;\n  char *sourceFile;\n  char shouldSetTime;\n  ulong flags;\n  undefined auVar3 [16];\n  undefined8 returnAddress;\n  \n  piVar1 = __errno_location();\n  strerror(*piVar1);\n  uVar2 = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n  print_error_message_00119ed0(uVar2);\n  unlink(sourceFile);\n  if (shouldSetTime != '\\0') {\n    set_file_time_0011a350();\n  }\n  auVar3._0_8_ = flags & 0xffffffff;\n  auVar3._8_8_ = returnAddress;\n  return auVar3;\n}\n\n",
            "called": [
                "__errno_location",
                "unlink",
                "dcgettext",
                "FUN_0011a350",
                "FUN_00119ed0",
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108200",
            "calling": [
                "FUN_00115970"
            ],
            "imported": false,
            "current_name": "copy_and_print_error_00108200"
        },
        "bfd_alt_mach_code": {
            "renaming": {},
            "code": "\nvoid bfd_alt_mach_code(void)\n\n{\n  bfd_alt_mach_code();\n  return;\n}\n\n",
            "called": [
                "bfd_alt_mach_code"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104590",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_alt_mach_code"
        }
    },
    "used_tokens": 248006,
    "layers": [
        [
            "FUN_0010ab4d",
            "FUN_0010be88",
            "FUN_00119e70",
            "FUN_00108e76",
            "FUN_0010bb52",
            "FUN_0011283f",
            "FUN_00108237",
            "FUN_00114cf0",
            "FUN_001054af",
            "FUN_001088ae",
            "FUN_00108b3e",
            "FUN_00109c2e",
            "FUN_001052a2",
            "FUN_0011a1b0",
            "FUN_0010911f",
            "FUN_00104bba",
            "FUN_00109a0b",
            "FUN_00112894",
            "FUN_00109b2f",
            "FUN_00113f20",
            "FUN_00109022",
            "FUN_00109b52",
            "FUN_001087da",
            "FUN_0010914e",
            "FUN_00104943",
            "FUN_00108fb9",
            "FUN_00108ea1",
            "FUN_00114e00",
            "FUN_001087fd",
            "FUN_0011256b",
            "FUN_00108fe8",
            "FUN_001129f4",
            "FUN_0010bbd3",
            "FUN_00115d00",
            "FUN_001082c3",
            "FUN_00114d50",
            "FUN_00108800",
            "FUN_00104d1c",
            "FUN_0010540e",
            "FUN_001081e9",
            "FUN_00109bbb",
            "FUN_0010ae0e",
            "FUN_00104c36",
            "FUN_00119970",
            "FUN_0010870e",
            "FUN_00113fb0",
            "FUN_00109be3",
            "FUN_0011a480",
            "FUN_0010871c",
            "FUN_0010bf20",
            "FUN_0011a110",
            "FUN_00113fe0",
            "FUN_001125fa",
            "FUN_00108f05",
            "FUN_00108863",
            "FUN_00104020",
            "FUN_00108f08",
            "FUN_00114b84",
            "FUN_00104a35",
            "FUN_0010be1a",
            "FUN_0011a250",
            "FUN_0010875d",
            "FUN_00112904",
            "FUN_00108898",
            "FUN_0011a390",
            "FUN_00112925",
            "FUN_0010bf86",
            "FUN_0011a170",
            "FUN_0010bd62"
        ],
        [
            "FUN_00113dfe",
            "FUN_0010c218",
            "FUN_0010aa53",
            "FUN_0010bc80",
            "FUN_0010a181",
            "FUN_00113bfa",
            "FUN_00109e76",
            "FUN_00112996",
            "FUN_00108a2a",
            "FUN_00108c86",
            "FUN_001053d5",
            "FUN_0010c05d",
            "FUN_00113e17",
            "FUN_00109a32",
            "FUN_0010c6be",
            "FUN_00113e23",
            "FUN_0010a2b9",
            "FUN_00119ed0",
            "FUN_0011a0e0",
            "FUN_00119dd0",
            "FUN_001083b7",
            "FUN_00116852",
            "FUN_00113d3a",
            "FUN_0010abdd",
            "FUN_00113c43",
            "FUN_0010a94e",
            "FUN_0010a0e9",
            "FUN_00113d6e",
            "FUN_00108916",
            "FUN_001126c0",
            "FUN_00113b4a",
            "FUN_00113b71",
            "FUN_00109cf4",
            "FUN_0010a77a",
            "FUN_00113b98",
            "FUN_00115d70",
            "FUN_00113da9",
            "FUN_0010a69a",
            "FUN_00116030",
            "FUN_00113ede",
            "FUN_00113cb9",
            "FUN_00113df2",
            "FUN_0010a377",
            "FUN_00113ce0",
            "FUN_00119f70",
            "FUN_00115a90"
        ],
        [
            "FUN_0010ba08",
            "FUN_00108466",
            "FUN_001199d0",
            "FUN_0010c139",
            "FUN_00109d3e",
            "FUN_00104cc1",
            "FUN_00108375",
            "FUN_0010afd5",
            "FUN_001053b5",
            "FUN_00109d5c",
            "FUN_0010da0b",
            "FUN_00108d9a",
            "FUN_0010827b",
            "FUN_00104920",
            "FUN_00109d97",
            "FUN_0010add5",
            "FUN_0011a2e0",
            "FUN_00104ad6",
            "FUN_0010adf2",
            "FUN_00113f50",
            "FUN_00104966",
            "FUN_0010808f",
            "FUN_00105828",
            "FUN_0010bba1",
            "FUN_00115f30",
            "FUN_001082b3",
            "FUN_0010b800",
            "FUN_00109ed3",
            "FUN_0010c2d2",
            "FUN_001083de",
            "FUN_0010a83e",
            "FUN_00104d25",
            "FUN_0010c1c6",
            "FUN_001082df",
            "FUN_00114d60",
            "FUN_00108808",
            "FUN_00119940",
            "FUN_00109dfe",
            "FUN_00109ab1",
            "FUN_0010543c",
            "FUN_00114c80",
            "FUN_0010882c",
            "FUN_0011a350",
            "FUN_0010e2f0",
            "FUN_00114190",
            "FUN_00114dc7"
        ],
        [
            "FUN_0011173a",
            "thunk_FUN_0010e439",
            "FUN_0010e439",
            "FUN_0010a083",
            "FUN_0010e453",
            "FUN_0010ed2c",
            "FUN_0010e9a0",
            "FUN_00108179",
            "FUN_0010e8a9",
            "FUN_0010829e",
            "FUN_0010ec73",
            "FUN_00115970",
            "FUN_0010a0a0",
            "FUN_0010e6a8",
            "FUN_0010e7c2",
            "FUN_0010a0d3",
            "FUN_0010a0bd",
            "FUN_00114690",
            "FUN_00112a33",
            "FUN_00114460",
            "FUN_00114c20",
            "FUN_0010b948",
            "FUN_0010edb4",
            "FUN_0010e5db",
            "FUN_0010a424",
            "FUN_0010ebb0",
            "FUN_0010e918",
            "FUN_0010c892",
            "FUN_0010e842",
            "FUN_0010eafe",
            "FUN_00104ea2",
            "FUN_00108200"
        ],
        [
            "FUN_00112502",
            "FUN_00108072",
            "FUN_00115b70"
        ],
        [
            "FUN_001159d0"
        ],
        [
            "FUN_00115530",
            "FUN_00115f50"
        ],
        [
            "FUN_00115dc0",
            "FUN_00116110"
        ],
        [
            "FUN_00112b6e"
        ],
        [
            "FUN_00113b1e"
        ],
        [
            "FUN_0010922b"
        ],
        [
            "FUN_0010c7a0"
        ],
        [
            "FUN_00112c1f"
        ],
        [
            "FUN_0010d21c",
            "FUN_0010d7d4",
            "FUN_00113e5e"
        ],
        [
            "FUN_0010d559",
            "FUN_0010d882"
        ],
        [
            "FUN_0010c95e"
        ],
        [
            "FUN_0010e07c"
        ],
        [
            "FUN_0010dac0"
        ],
        [
            "FUN_0011378f"
        ],
        [
            "FUN_0010554f"
        ],
        [
            "FUN_0010847a"
        ],
        [
            "FUN_001135a5"
        ],
        [
            "FUN_00113a4d"
        ],
        [
            "FUN_0010b6ea"
        ],
        [
            "FUN_0010b0fa"
        ],
        [
            "FUN_00116490"
        ],
        [
            "FUN_001086af"
        ],
        [
            "FUN_001163d0"
        ],
        [
            "FUN_0010551d"
        ]
    ],
    "locked_functions": []
}