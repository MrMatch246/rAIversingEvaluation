{
    "functions": {
        "FUN_00102cd9": {
            "renaming": {
                "FUN_00102cd9": "find_matching_file_pointer_00102cd9",
                "in_EAX": "searchType",
                "iVar1": "comparisonResult",
                "unaff_RBX": "filePointer",
                "param_7": "filename",
                "posname": "param_7"
            },
            "code": "\nlong * findMatchingFilePointer_00102cd9(void)\n\n{\n  int searchType;\n  int comparisonResult;\n  long *filePointer;\n  undefined8 filename;\n  \n  filename = param_7;\n  if (searchType == 3) {\n    for (; *filePointer != 0; filePointer = (long *)(*filePointer + 0xf0)) {\n    }\n  }\n  else {\n    for (; (undefined8 *)*filePointer != (undefined8 *)0x0; filePointer = (long *)(*filePointer + 0xf0)) {\n      comparisonResult = filename_cmp(*(undefined8 *)*filePointer,filename);\n      if (comparisonResult == 0) {\n        if (searchType != 2) {\n          return filePointer;\n        }\n        return (long *)(*filePointer + 0xf0);\n      }\n    }\n  }\n  return filePointer;\n}\n\n",
            "called": [
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102cd9",
            "calling": [
                "get_pos_bfd"
            ],
            "imported": false,
            "current_name": "find_matching_file_pointer_00102cd9"
        },
        "FUN_001021b0": {
            "renaming": {},
            "code": "\nvoid xrealloc(void)\n\n{\n  xrealloc();\n  return;\n}\n\n",
            "called": [
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021b0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001021b0"
        },
        "FUN_001079c0": {
            "renaming": {
                "FUN_001079c0": "print_file_info_001079c0",
                "param_1": "file",
                "param_2": "fileInfo",
                "param_3": "printTime",
                "param_4": "printAddress",
                "iVar1": "returnValue",
                "ppcVar2": "fileInfoPtr",
                "pcVar3": "timeData",
                "uVar4": "fileType",
                "local_100": "currentTimeStamp",
                "uStack_f3": "permission",
                "cStack_f2": "userRead",
                "cStack_f1": "userWrite",
                "cStack_f0": "userExecute",
                "cStack_ef": "groupRead",
                "cStack_ee": "groupWrite",
                "cStack_ed": "groupExecute",
                "cStack_ec": "othersRead",
                "cStack_eb": "othersWrite",
                "cStack_ea": "othersExecute",
                "local_e8": "formattedTime",
                "local_b8": "localBuffer",
                "uStack_a0": "filePermissions",
                "uStack_9c": "fileSizeUpper",
                "uStack_98": "fileSizeLower",
                "uStack_88": "timestamp",
                "local_60": "currentTime"
            },
            "code": "\nvoid printFileInfo_001079c0(FILE *file,char **fileInfo,char printTime,char printAddress)\n\n{\n  int returnValue;\n  char **fileInfoPtr;\n  char *timeData;\n  uint fileType;\n  time_t currentTimeStamp;\n  undefined permission;\n  char userRead;\n  char userWrite;\n  char userExecute;\n  char groupRead;\n  char groupWrite;\n  char groupExecute;\n  char othersRead;\n  char othersWrite;\n  char othersExecute;\n  undefined uStack_e9;\n  char formattedTime [48];\n  undefined localBuffer [24];\n  uint filePermissions;\n  uint fileSizeUpper;\n  uint fileSizeLower;\n  undefined8 timestamp;\n  time_t currentTime;\n  \n  if (printTime != '\\0') {\n    fileInfoPtr = (char **)fileInfo[0x1d];\n    if ((char **)fileInfo[0x1d] == (char **)0x0) {\n      fileInfoPtr = fileInfo;\n    }\n    returnValue = (**(code **)(fileInfoPtr[1] + 0x1e8))(fileInfo,localBuffer);\n    if (returnValue == 0) {\n      currentTimeStamp = currentTime;\n      timeData = ctime(&currentTimeStamp);\n      if (timeData == (char *)0x0) {\n        timeData = (char *)dcgettext(0,\"<time data corrupt>\",5);\n        sprintf(formattedTime,timeData);\n      }\n      else {\n        sprintf(formattedTime,\"%.12s %.4s\",timeData + 4);\n      }\n      fileType = filePermissions & 0xf000;\n      if (fileType == 0x4000) {\n        permission = 100;\n      }\n      else if (fileType == 0xa000) {\n        permission = 0x6c;\n      }\n      else if (fileType == 0x6000) {\n        permission = 0x62;\n      }\n      else if (fileType == 0x2000) {\n        permission = 99;\n      }\n      else if (fileType == 0xc000) {\n        permission = 0x73;\n      }\n      else {\n        permission = 0x70;\n        if (fileType != 0x1000) {\n          permission = 0x2d;\n        }\n      }\n      userRead = (-((filePermissions & 0x100) == 0) & 0xbbU) + 0x72;\n      userWrite = (-((filePermissions & 0x80) == 0) & 0xb6U) + 0x77;\n      userExecute = (-((filePermissions & 0x40) == 0) & 0xb5U) + 0x78;\n      groupRead = (-((filePermissions & 0x20) == 0) & 0xbbU) + 0x72;\n      groupWrite = (-((filePermissions & 0x10) == 0) & 0xb6U) + 0x77;\n      groupExecute = (-((filePermissions & 8) == 0) & 0xb5U) + 0x78;\n      othersRead = (-((filePermissions & 4) == 0) & 0xbbU) + 0x72;\n      othersWrite = (-((filePermissions & 2) == 0) & 0xb6U) + 0x77;\n      othersExecute = (-((filePermissions & 1) == 0) & 0xb5U) + 0x78;\n      if ((filePermissions & 0x800) != 0) {\n        if (userExecute == 'x') {\n          userExecute = 's';\n        }\n        else {\n          userExecute = 'S';\n        }\n      }\n      if ((filePermissions & 0x400) != 0) {\n        if (groupExecute == 'x') {\n          groupExecute = 's';\n        }\n        else {\n          groupExecute = 'S';\n        }\n      }\n      if ((filePermissions & 0x200) != 0) {\n        if (othersExecute == 'x') {\n          othersExecute = 't';\n        }\n        else {\n          othersExecute = 'T';\n        }\n      }\n      uStack_e9 = 0;\n      fprintf(file,\"%s %ld/%ld %6lu %s \",&userRead,(ulong)fileSizeUpper,(ulong)fileSizeLower,timestamp,\n              formattedTime,(ulong)filePermissions);\n    }\n  }\n  fputs(*fileInfo,file);\n  if (printAddress != '\\0') {\n    if ((*(byte *)((long)fileInfo + 0x49) & 0x10) == 0) {\n      if (fileInfo[0xb] != (char *)0x0) {\n        fprintf(file,\" 0x%lx\");\n      }\n    }\n    else if (fileInfo[0xc] != (char *)0x0) {\n      fprintf(file,\" 0x%lx\");\n    }\n  }\n  fputc(10,file);\n  return;\n}\n\n",
            "called": [
                "print_arelt_descr.cold",
                "ctime",
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001079c0",
            "calling": [
                "ar_directory_doer",
                "print_descr"
            ],
            "imported": false,
            "current_name": "print_file_info_001079c0"
        },
        "FUN_00105a68": {
            "renaming": {
                "FUN_00105a68": "initialize_output_file_00105a68",
                "pcVar1": "outputDir",
                "pFVar2": "outputFile",
                "sVar3": "outputDirLength"
            },
            "code": "\nvoid initializeOutputFile_00105a68(void)\n\n{\n  char *outputDir;\n  FILE *outputFile;\n  size_t outputDirLength;\n  \n  outputDir = output_dir;\n  if (output_dir != (char *)0x0) {\n    outputDirLength = strlen(output_dir);\n    if (outputDirLength != 0) {\n      if (outputDir[outputDirLength - 1] == '/') {\n        output_filename = (char *)concat(outputDir,output_filename,0);\n      }\n      else {\n        output_filename = (char *)concat(outputDir,&DAT_00108260,output_filename,0);\n      }\n    }\n  }\n  if (verbose != 0) {\n    printf(\"x - %s\\n\",output_filename);\n  }\n  outputFile = fopen(output_filename,\"w\");\n  if (outputFile != (FILE *)0x0) {\n    return;\n  }\n  perror(output_filename);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "xexit",
                "strlen",
                "open_output_file.isra.0.cold",
                "perror",
                "printf",
                "fopen",
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105a68",
            "calling": [
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "initialize_output_file_00105a68"
        },
        "FUN_001022d0": {
            "renaming": {},
            "code": "\n\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = calloc(__nmemb,__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "calloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022d0",
            "calling": [
                "yyensure_buffer_stack"
            ],
            "imported": false,
            "current_name": "FUN_001022d0"
        },
        "FUN_001023f0": {
            "renaming": {},
            "code": "\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 = fseek(__stream,__off,__whence);\n  return iVar1;\n}\n\n",
            "called": [
                "fseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023f0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001023f0"
        },
        "FUN_001032a8": {
            "renaming": {
                "FUN_001032a8": "extract_files_from_archive_001032a8",
                "param_1": "archive",
                "param_2": "callback",
                "param_3": "fileList",
                "param_4": "result",
                "lVar1": "nextEntry",
                "uVar2": "currentFile",
                "bVar3": "fileFound",
                "plVar4": "currentEntry",
                "iVar5": "comparisonResult",
                "__format": "errorMessage",
                "plVar6": "nextEntry",
                "lVar7": "currentEntry",
                "plVar8": "previousEntry"
            },
            "code": "\n\n\nundefined8 extractFilesFromArchive_001032a8(long *archive,code *callback,undefined8 *fileList,undefined8 result)\n\n{\n  long nextEntry;\n  undefined8 currentFile;\n  bool fileFound;\n  long *currentEntry;\n  int comparisonResult;\n  char *errorMessage;\n  long *nextEntry;\n  long currentEntry;\n  long *previousEntry;\n  \n  currentEntry = archive[0x1e];\n  if (fileList == (undefined8 *)0x0) {\n    while (currentEntry != 0) {\n      nextEntry = *(long *)(currentEntry + 0xf0);\n      (*callback)(currentEntry,0);\n      currentEntry = nextEntry;\n    }\n  }\n  else {\n    do {\n      fileFound = false;\n      currentEntry = (long *)archive[0x1e];\n      previousEntry = archive;\n      while (nextEntry = currentEntry, nextEntry != (long *)0x0) {\n        if (*nextEntry != 0) {\n          comparisonResult = filename_cmp(*fileList);\n          if (comparisonResult == 0) {\n            fileFound = true;\n            (*callback)(nextEntry,previousEntry);\n          }\n        }\n        previousEntry = nextEntry;\n        currentEntry = (long *)nextEntry[0x1e];\n      }\n      if (!fileFound) {\n        currentFile = *fileList;\n        errorMessage = (char *)dcgettext(0,\"No entry %s in archive.\\n\",5);\n        fprintf(_stderr,errorMessage,currentFile);\n      }\n      fileList = (undefined8 *)fileList[1];\n    } while (fileList != (undefined8 *)0x0);\n  }\n  return result;\n}\n\n",
            "called": [
                "filename_cmp",
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001032a8",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "extract_files_from_archive_001032a8"
        },
        "FUN_00102f96": {
            "renaming": {
                "FUN_00102f96": "print_error_message_00102f96",
                "unaff_RBX": "errorCode",
                "unaff_retaddr": "returnAddress",
                "uVar1": "errorMessage"
            },
            "code": "\n\n\nvoid printErrorMessage_00102f96(void)\n\n{\n  undefined8 errorMessage;\n  long errorCode;\n  undefined8 returnAddress;\n  \n  errorMessage = dcgettext(0,\"cause of error unknown\",5);\n  fflush(_stdout);\n  if (errorCode != 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",program_name);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",program_name,errorMessage,returnAddress);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fflush",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f96",
            "calling": [
                "bfd_nonfatal"
            ],
            "imported": false,
            "current_name": "print_error_message_00102f96"
        },
        "FUN_0010342d": {
            "renaming": {
                "FUN_0010342d": "print_usage_0010342d",
                "param_1": "outputMode",
                "uVar1": "programName",
                "pcVar2": "message",
                "__stream": "stream"
            },
            "code": "\n\n\nvoid printUsage_0010342d(uint outputMode)\n\n{\n  undefined8 programName;\n  char *message;\n  FILE *stream;\n  \n  message = (char *)dcgettext(0,\n                             \"Usage: %s [emulation options] [-]{dmpqrstx}[abcDfilMNoOPsSTuvV] [--plugin <name>] [member-name] [count] archive-file file...\\n\"\n                             ,5);\n  stream = _stderr;\n  if (outputMode != 0) {\n    stream = _stdout;\n  }\n  fprintf(stream,message,program_name);\n  programName = program_name;\n  message = (char *)dcgettext(0,\"       %s -M [<mri-script]\\n\",5);\n  fprintf(stream,message,programName);\n  message = (char *)dcgettext(0,\" commands:\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  d            - delete file(s) from the archive\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  m[ab]        - move file(s) in the archive\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  p            - print file(s) found in the archive\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  q[f]         - quick append file(s) to the archive\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\n                             \"  r[ab][f][u]  - replace existing or insert new file(s) into the archive\\n\"\n                             ,5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  s            - act as ranlib\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  t[O][v]      - display contents of the archive\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  x[o]         - extract file(s) from the archive\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\" command specific modifiers:\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  [a]          - put file(s) after [member-name]\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  [b]          - put file(s) before [member-name] (same as [i])\\n\",5\n                            );\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  [D]          - use zero for timestamps and uids/gids (default)\\n\",\n                             5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  [U]          - use actual timestamps and uids/gids\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  [N]          - use instance [count] of name\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  [f]          - truncate inserted file names\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  [P]          - use full path names when matching\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  [o]          - preserve original dates\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  [O]          - display offsets of files in the archive\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\n                             \"  [u]          - only replace files that are newer than current archive contents\\n\"\n                             ,5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\" generic modifiers:\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  [c]          - do not warn if the library had to be created\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  [s]          - create an archive index (cf. ranlib)\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  [l <text> ]  - specify the dependencies of this library\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  [S]          - do not build a symbol table\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  [T]          - deprecated, use --thin instead\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  [v]          - be verbose\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  [V]          - display the version number\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  @<file>      - read options from <file>\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  --target=BFDNAME - specify the target object format as BFDNAME\\n\",\n                             5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\n                             \"  --output=DIRNAME - specify the output directory for extraction operations\\n\"\n                             ,5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\n                             \"  --record-libdeps=<text> - specify the dependencies of this library\\n\"\n                             ,5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  --thin       - make a thin archive\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\" optional:\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  --plugin <p> - load the specified plugin\\n\",5);\n  fprintf(stream,message);\n  ar_emul_default_usage(stream);\n  list_supported_targets(program_name,stream);\n  if (outputMode != 0) {\n    message = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(stream,message,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  xexit(outputMode ^ 1);\n}\n\n",
            "called": [
                "xexit",
                "fprintf",
                "list_supported_targets",
                "ar_emul_default_usage",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010342d",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "print_usage_0010342d"
        },
        "FUN_00102110": {
            "renaming": {},
            "code": "\n\n\nssize_t write(int __fd,void *__buf,size_t __n)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = write(__fd,__buf,__n);\n  return sVar1;\n}\n\n",
            "called": [
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102110",
            "calling": [
                "simple_copy.constprop.0"
            ],
            "imported": false,
            "current_name": "FUN_00102110"
        },
        "FUN_00107920": {
            "renaming": {
                "FUN_00107920": "report_data_00107920",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "param_5": "input5",
                "param_6": "input6",
                "param_7": "input7",
                "param_8": "input8",
                "param_9": "output1",
                "param_10": "output2",
                "param_11": "output3",
                "param_12": "output4",
                "param_13": "output5",
                "param_14": "output6",
                "in_AL": "flag",
                "local_d8": "size",
                "local_d4": "offset",
                "local_d0": "buffer",
                "local_c8": "localBuffer",
                "local_b8": "temporaryBuffer",
                "local_b0": "param10",
                "local_a8": "param11",
                "local_a0": "param12",
                "local_98": "param13",
                "local_90": "param14",
                "local_88": "local1",
                "local_78": "local2",
                "local_68": "local3",
                "local_58": "local4",
                "local_48": "local5",
                "local_38": "local6",
                "local_28": "local7",
                "local_18": "local8"
            },
            "code": "\nvoid reportData_00107920(undefined4 input1,undefined4 input2,undefined4 input3,undefined4 input4,\n                 undefined4 input5,undefined4 input6,undefined4 input7,undefined4 input8,\n                 undefined8 output1,undefined8 output2,undefined8 output3,undefined8 output4,\n                 undefined8 output5,undefined8 output6)\n\n{\n  char flag;\n  undefined4 size;\n  undefined4 offset;\n  undefined *buffer;\n  undefined *localBuffer;\n  undefined temporaryBuffer [8];\n  undefined8 param10;\n  undefined8 param11;\n  undefined8 param12;\n  undefined8 param13;\n  undefined8 param14;\n  undefined4 local1;\n  undefined4 local2;\n  undefined4 local3;\n  undefined4 local4;\n  undefined4 local5;\n  undefined4 local6;\n  undefined4 local7;\n  undefined4 local8;\n  \n  if (flag != '\\0') {\n    local1 = input1;\n    local2 = input2;\n    local3 = input3;\n    local4 = input4;\n    local5 = input5;\n    local6 = input6;\n    local7 = input7;\n    local8 = input8;\n  }\n  buffer = &stack0x00000008;\n  size = 8;\n  localBuffer = temporaryBuffer;\n  offset = 0x30;\n  param10 = output2;\n  param11 = output3;\n  param12 = output4;\n  param13 = output5;\n  param14 = output6;\n  report(output1,&size);\n  return;\n}\n\n",
            "called": [
                "report"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107920",
            "calling": [
                "open_inarch",
                "set_times.cold",
                "get_file_size.cold",
                "smart_rename.constprop.0.cold",
                "get_file_size",
                "main",
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "report_data_00107920"
        },
        "FUN_00102230": {
            "renaming": {},
            "code": "\nvoid xmalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102230",
            "calling": [
                "normalize.cold",
                "make_tempname",
                "print_contents",
                "replace_members.cold",
                "extract_file.cold",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102230"
        },
        "FUN_00102590": {
            "renaming": {},
            "code": "\nvoid __cxa_finalize(void)\n\n{\n  __cxa_finalize();\n  return;\n}\n\n",
            "called": [
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102590",
            "calling": [
                "__do_global_dtors_aux"
            ],
            "imported": false,
            "current_name": "FUN_00102590"
        },
        "FUN_00102350": {
            "renaming": {},
            "code": "\n\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n  long lVar1;\n  \n  lVar1 = strtol(__nptr,__endptr,__base);\n  return lVar1;\n}\n\n",
            "called": [
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102350",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102350"
        },
        "FUN_0010e190": {
            "renaming": {},
            "code": "\n\n\n\nint putc(int __c,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* putc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e190",
            "calling": [
                "putc"
            ],
            "imported": false,
            "current_name": "FUN_0010e190"
        },
        "FUN_00102470": {
            "renaming": {},
            "code": "\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 = fopen(__filename,__modes);\n  return pFVar1;\n}\n\n",
            "called": [
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102470",
            "calling": [
                "FUN_00105a68",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102470"
        },
        "FUN_0010e070": {
            "renaming": {},
            "code": "\n\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fread@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e070",
            "calling": [
                "fread"
            ],
            "imported": false,
            "current_name": "FUN_0010e070"
        },
        "FUN_00102e6f": {
            "renaming": {
                "FUN_00102e6f": "extract_and_save_file_00102e6f",
                "in_RAX": "filePathPtr",
                "pcVar1": "outputDirPtr",
                "uVar2": "basenamePtr",
                "uVar3": "errorMsgPtr",
                "pFVar4": "outputFilePtr",
                "sVar5": "outputDirLength",
                "pcVar6": "fileNamePtr"
            },
            "code": "\nvoid extractAndSaveFile_00102e6f(void)\n\n{\n  char *outputDirPtr;\n  char *filePathPtr;\n  undefined8 basenamePtr;\n  undefined8 errorMsgPtr;\n  FILE *outputFilePtr;\n  size_t outputDirLength;\n  char *fileNamePtr;\n  \n  outputDirPtr = output_dir;\n  do {\n    filePathPtr = filePathPtr + 1;\n    while (*filePathPtr != '/') {\n      if (*filePathPtr == '\\0') {\n        if ((output_dir != (char *)0x0) && (outputDirLength = strlen(output_dir), outputDirLength != 0)) {\n          if (outputDirPtr[outputDirLength - 1] == '/') {\n            output_filename = (char *)concat(outputDirPtr,output_filename,0);\n          }\n          else {\n            output_filename = (char *)concat(outputDirPtr,&DAT_00108260,output_filename,0);\n          }\n        }\n        if (verbose != 0) {\n          printf(\"x - %s\\n\",output_filename);\n        }\n        outputFilePtr = fopen(output_filename,\"w\");\n        if (outputFilePtr == (FILE *)0x0) {\n          perror(output_filename);\n                    \n          xexit(1);\n        }\n        return;\n      }\n      fileNamePtr = filePathPtr;\n      if ((*filePathPtr == '.') && (fileNamePtr = filePathPtr + 1, filePathPtr[1] == '.')) {\n        fileNamePtr = filePathPtr + 2;\n        if ((filePathPtr[2] == '/') || (filePathPtr[2] == '\\0')) {\n          basenamePtr = lbasename();\n          outputDirPtr = output_filename;\n          errorMsgPtr = dcgettext(0,\"illegal output pathname for archive member: %s, using \\'%s\\' instead\"\n                            ,5);\n          non_fatal(errorMsgPtr,outputDirPtr,basenamePtr);\n          output_filename = (char *)basenamePtr;\n          initialize_output_file_00105a68();\n          return;\n        }\n      }\n      for (; (filePathPtr = fileNamePtr, *fileNamePtr != '\\0' && (*fileNamePtr != '/')); fileNamePtr = fileNamePtr + 1) {\n      }\n    }\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00105a68",
                "dcgettext",
                "non_fatal",
                "FUN_00102e6f",
                "lbasename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102e6f",
            "calling": [
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "extract_and_save_file_00102e6f"
        },
        "FUN_001020a0": {
            "renaming": {},
            "code": "\nvoid bfd_make_readable(void)\n\n{\n  bfd_make_readable();\n  return;\n}\n\n",
            "called": [
                "bfd_make_readable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020a0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001020a0"
        },
        "FUN_001021c0": {
            "renaming": {},
            "code": "\n\n\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strrchr(__s,__c);\n  return pcVar1;\n}\n\n",
            "called": [
                "strrchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021c0",
            "calling": [
                "make_tempname"
            ],
            "imported": false,
            "current_name": "FUN_001021c0"
        },
        "FUN_001022e0": {
            "renaming": {},
            "code": "\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = strcmp(__s1,__s2);\n  return iVar1;\n}\n\n",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022e0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001022e0"
        },
        "FUN_001033d6": {
            "renaming": {
                "FUN_001033d6": "create_buffer_001033d6",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "pvVar1": "buffer",
                "pvVar2": "data",
                "auVar3": "result"
            },
            "code": "\nundefined  [16]\ncreateBuffer_001033d6(undefined8 param1,undefined8 param2,undefined8 param3,undefined8 param4)\n\n{\n  void *buffer;\n  void *data;\n  undefined result [16];\n  \n  buffer = malloc(0x40);\n  if (buffer != (void *)0x0) goto LAB_001033f7;\n  do {\n    buffer = (void *)yy_fatal_error(\"out of dynamic memory in yy_create_buffer()\");\nLAB_001033f7:\n    *(undefined4 *)((long)buffer + 0x18) = 0x4000;\n    data = malloc(0x4002);\n    *(void **)((long)buffer + 8) = data;\n  } while (data == (void *)0x0);\n  *(undefined4 *)((long)buffer + 0x20) = 1;\n  yy_init_buffer(buffer,param1);\n  result._8_8_ = param4;\n  result._0_8_ = buffer;\n  return result;\n}\n\n",
            "called": [
                "yy_init_buffer",
                "yy_fatal_error",
                "malloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001033d6",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "create_buffer_001033d6"
        },
        "FUN_00102000": {
            "renaming": {
                "FUN_00102000": "start_function_00102000",
                "ctx": "context",
                "iVar1": "result"
            },
            "code": "\nint startFunction_00102000(EVP_PKEY_CTX *context)\n\n{\n  int result;\n  \n  result = __gmon_start__();\n  return result;\n}\n\n",
            "called": [
                "__gmon_start__"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102000",
            "calling": [],
            "imported": false,
            "current_name": "start_function_00102000"
        },
        "FUN_00102120": {
            "renaming": {},
            "code": "\nvoid textdomain(void)\n\n{\n  textdomain();\n  return;\n}\n\n",
            "called": [
                "textdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102120",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102120"
        },
        "FUN_00102480": {
            "renaming": {},
            "code": "\nvoid xexit(void)\n\n{\n                    \n  xexit();\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102480",
            "calling": [
                "open_inarch",
                "fatal",
                "bfd_fatal",
                "ranlib_only",
                "FUN_00105a68",
                "maybequit",
                "ranlib_usage",
                "write_archive.cold",
                "usage",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102480"
        },
        "FUN_00105870": {
            "renaming": {
                "FUN_00105870": "search_file_00105870",
                "param_1": "fileList",
                "param_2": "fileCount",
                "param_3": "searchTerm",
                "uVar2": "defaultTerm",
                "iVar3": "searchType",
                "iVar1": "cmpResult"
            },
            "code": "\nlong * searchFile_00105870(long *fileList,int fileCount,undefined8 searchTerm)\n\n{\n  int cmpResult;\n  undefined8 defaultTerm;\n  int searchType;\n  \n  defaultTerm = posname;\n  searchType = postype;\n  if (postype == 0) {\n    defaultTerm = searchTerm;\n    searchType = fileCount;\n  }\n  if (searchType == 3) {\n    for (; *fileList != 0; fileList = (long *)(*fileList + 0xf0)) {\n    }\n  }\n  else {\n    for (; (undefined8 *)*fileList != (undefined8 *)0x0; fileList = (long *)(*fileList + 0xf0)) {\n      cmpResult = filename_cmp(*(undefined8 *)*fileList,defaultTerm);\n      if (cmpResult == 0) {\n        if (searchType != 2) {\n          return fileList;\n        }\n        return (long *)(*fileList + 0xf0);\n      }\n    }\n  }\n  return fileList;\n}\n\n",
            "called": [
                "get_pos_bfd.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105870",
            "calling": [
                "replace_members.cold",
                "main"
            ],
            "imported": false,
            "current_name": "search_file_00105870"
        },
        "FUN_00102240": {
            "renaming": {},
            "code": "\nvoid bfd_set_error(void)\n\n{\n  bfd_set_error();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102240",
            "calling": [
                "open_inarch",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102240"
        },
        "FUN_00102360": {
            "renaming": {},
            "code": "\n\n\nvoid clearerr(FILE *__stream)\n\n{\n  clearerr(__stream);\n  return;\n}\n\n",
            "called": [
                "clearerr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102360",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102360"
        },
        "FUN_00103ba8": {
            "renaming": {
                "FUN_00103ba8": "print_command_line_prompt_00103ba8",
                "interactive": "isInteractiveMode",
                "printf": "printString",
                "fflush": "flushOutputStream"
            },
            "code": "\n\n\nvoid printCommandLinePrompt_00103ba8(void)\n\n{\n  if (isInteractiveMode != 0) {\n    printString(\"AR >\");\n    flushOutputStream(_stdout);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "fflush",
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103ba8",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "print_command_line_prompt_00103ba8"
        },
        "FUN_00103ddc": {
            "renaming": {
                "FUN_00103ddc": "print_arelt_descr_with_verbose_00103ddc",
                "param_1": "param",
                "outfile": "out_file",
                "verbose": "is_verbose"
            },
            "code": "\nvoid print_arelt_descr_with_verbose_00103ddc(undefined8 param)\n\n{\n  print_arelt_descr(out_file,param,is_verbose != 0,0);\n  return;\n}\n\n",
            "called": [
                "print_arelt_descr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103ddc",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "print_arelt_descr_with_verbose_00103ddc"
        },
        "FUN_001078c0": {
            "renaming": {
                "FUN_001078c0": "print_error_message_001078c0",
                "param_1": "format_string",
                "param_2": "arguments",
                "_stdout": "standard_output",
                "_stderr": "standard_error",
                "program_name": "executable_name"
            },
            "code": "\n\n\nvoid print_error_message_001078c0(char *format_string,__gnuc_va_list arguments)\n\n{\n  fflush(standard_output);\n  fprintf(standard_error,\"%s: \",executable_name);\n  vfprintf(standard_error,format_string,arguments);\n  putc(10,standard_error);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fflush",
                "putc",
                "vfprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001078c0",
            "calling": [
                "fatal",
                "non_fatal"
            ],
            "imported": false,
            "current_name": "print_error_message_001078c0"
        },
        "FUN_001022f0": {
            "renaming": {},
            "code": "\n\n\nint putc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = putc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022f0",
            "calling": [
                "report"
            ],
            "imported": false,
            "current_name": "FUN_001022f0"
        },
        "FUN_001020b0": {
            "renaming": {},
            "code": "\n\n\nint ferror(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = ferror(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "ferror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020b0",
            "calling": [
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_001020b0"
        },
        "FUN_001021d0": {
            "renaming": {},
            "code": "\n\n\nint dup(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = dup(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "dup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021d0",
            "calling": [
                "write_archive.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_001021d0"
        },
        "FUN_001031a5": {
            "renaming": {
                "FUN_001031a5": "print_syntax_error_001031a5",
                "linenumber": "currentLine",
                "__format": "errorFormat",
                "uVar1": "nextLineNumber"
            },
            "code": "\nvoid printSyntaxError_001031a5(void)\n\n{\n  uint nextLineNumber;\n  char *errorFormat;\n  \n  nextLineNumber = currentLine + 1;\n  errorFormat = (char *)dcgettext(0,\"Syntax error in archive script, line %d\\n\",5);\n  printf(errorFormat,(ulong)nextLineNumber);\n  return;\n}\n\n",
            "called": [
                "printf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001031a5",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "print_syntax_error_001031a5"
        },
        "FUN_0010e098": {
            "renaming": {},
            "code": "\n\n\nvoid textdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* textdomain@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e098",
            "calling": [
                "textdomain"
            ],
            "imported": false,
            "current_name": "FUN_0010e098"
        },
        "FUN_00102370": {
            "renaming": {},
            "code": "\nvoid bfd_bwrite(void)\n\n{\n  bfd_bwrite();\n  return;\n}\n\n",
            "called": [
                "bfd_bwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102370",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102370"
        },
        "FUN_00102490": {
            "renaming": {},
            "code": "\nvoid bfd_close(void)\n\n{\n  bfd_close();\n  return;\n}\n\n",
            "called": [
                "bfd_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102490",
            "calling": [
                "open_inarch",
                "open_inarch.cold",
                "write_archive.cold",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102490"
        },
        "FUN_0010e090": {
            "renaming": {},
            "code": "\n\n\n\nssize_t write(int __fd,void *__buf,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* write@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e090",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "FUN_0010e090"
        },
        "FUN_00102130": {
            "renaming": {},
            "code": "\nvoid bfd_openr(void)\n\n{\n  bfd_openr();\n  return;\n}\n\n",
            "called": [
                "bfd_openr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102130",
            "calling": [
                "open_inarch",
                "open_inarch.cold",
                "ar_open",
                "replace_members.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102130"
        },
        "FUN_00102250": {
            "renaming": {},
            "code": "\nvoid xmalloc_set_program_name(void)\n\n{\n  xmalloc_set_program_name();\n  return;\n}\n\n",
            "called": [
                "xmalloc_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102250",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102250"
        },
        "FUN_00103df9": {
            "renaming": {
                "FUN_00103df9": "ensure_buffer_stack_00103df9",
                "in_RCX": "input_value",
                "lVar1": "loop_counter",
                "lVar2": "new_buffer_stack_max",
                "puVar3": "buffer_start",
                "bVar4": "byte_value",
                "__size": "buffer_size",
                "yy_buffer_stack": "buffer_stack",
                "yy_buffer_stack_max": "buffer_stack_max",
                "yy_buffer_stack_top": "buffer_stack_top"
            },
            "code": "\nundefined8 ensure_buffer_stack_00103df9(void)\n\n{\n  size_t buffer_size;\n  undefined8 input_value;\n  long loop_counter;\n  long new_buffer_stack_max;\n  undefined4 *buffer_start;\n  byte byte_value;\n  \n  byte_value = 0;\n  if (buffer_stack == (void *)0x0) {\n    buffer_stack = calloc(8,1);\n    if (buffer_stack != (void *)0x0) {\n      buffer_stack_max = 1;\n      buffer_stack_top = 0;\n      return input_value;\n    }\n  }\n  else {\n    if (buffer_stack_top < buffer_stack_max - 1U) {\n      return input_value;\n    }\n    new_buffer_stack_max = buffer_stack_max + 8;\n    buffer_size = new_buffer_stack_max * 8;\n    buffer_stack = realloc(buffer_stack,buffer_size);\n    if (buffer_stack != (void *)0x0) {\n      buffer_start = (undefined4 *)((long)buffer_stack + (buffer_size - 0x40));\n      buffer_stack_max = new_buffer_stack_max;\n      for (loop_counter = 0x10; loop_counter != 0; loop_counter = loop_counter + -1) {\n        *buffer_start = 0;\n        buffer_start = buffer_start + (ulong)byte_value * -2 + 1;\n      }\n      return input_value;\n    }\n  }\n  yy_fatal_error(\"out of dynamic memory in yyensure_buffer_stack_00103df9()\");\n  buffer_stack_top = 0;\n  buffer_stack_max = 1;\n  return input_value;\n}\n\n",
            "called": [
                "calloc",
                "yy_fatal_error",
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103df9",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "ensure_buffer_stack_00103df9"
        },
        "FUN_0010e308": {
            "renaming": {},
            "code": "\n\n\nvoid __cxa_finalize(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __cxa_finalize@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e308",
            "calling": [
                "__cxa_finalize"
            ],
            "imported": false,
            "current_name": "FUN_0010e308"
        },
        "FUN_001021e0": {
            "renaming": {},
            "code": "\n\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  __off_t _Var1;\n  \n  _Var1 = lseek(__fd,__offset,__whence);\n  return _Var1;\n}\n\n",
            "called": [
                "lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021e0",
            "calling": [
                "simple_copy.constprop.0"
            ],
            "imported": false,
            "current_name": "FUN_001021e0"
        },
        "FUN_001020c0": {
            "renaming": {},
            "code": "\n\n\nint isatty(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = isatty(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "isatty"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020c0",
            "calling": [
                "yy_init_buffer",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001020c0"
        },
        "FUN_00105da0": {
            "renaming": {},
            "code": "\nvoid register_tm_clones(void)\n\n{\n  register_tm_clones();\n  return;\n}\n\n",
            "called": [
                "register_tm_clones"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105da0",
            "calling": [],
            "imported": false,
            "current_name": "FUN_00105da0"
        },
        "FUN_00102bf5": {
            "renaming": {
                "FUN_00102bf5": "cleanup_output_00102bf5",
                "output_bfd": "outputBuffer",
                "output_file": "outputFile",
                "output_filename": "fileName"
            },
            "code": "\nvoid cleanupOutput_00102bf5(void)\n\n{\n  if (outputBuffer != 0) {\n    bfd_cache_close();\n  }\n  if (outputFile != (FILE *)0x0) {\n    fclose(outputFile);\n  }\n  unlink_if_ordinary(fileName);\n  return;\n}\n\n",
            "called": [
                "unlink_if_ordinary",
                "fclose",
                "bfd_cache_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102bf5",
            "calling": [
                "remove_output"
            ],
            "imported": false,
            "current_name": "cleanup_output_00102bf5"
        },
        "FUN_00102260": {
            "renaming": {},
            "code": "\n\n\nint close(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = close(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102260",
            "calling": [
                "simple_copy.constprop.0.cold",
                "write_archive",
                "simple_copy.constprop.0"
            ],
            "imported": false,
            "current_name": "FUN_00102260"
        },
        "FUN_00102380": {
            "renaming": {},
            "code": "\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memcpy(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102380",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102380"
        },
        "FUN_00102020": {
            "renaming": {
                "FUN_00102020": "execute_indirect_call_00102020"
            },
            "code": "\nvoid execute_indirect_call_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(undefined *)0x0)();\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102020",
            "calling": [],
            "imported": false,
            "current_name": "execute_indirect_call_00102020"
        },
        "FUN_00102140": {
            "renaming": {},
            "code": "\n\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fclose(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fclose"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102140",
            "calling": [
                "extract_file.cold",
                "remove_output.cold",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102140"
        },
        "FUN_00102943": {
            "renaming": {
                "FUN_00102943": "initialize_output_file_name_00102943",
                "output_filename": "outputFileName"
            },
            "code": "\nvoid initializeOutputFileName_00102943(void)\n\n{\n  outputFileName = 0;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102943",
            "calling": [
                "replace_members.cold",
                "replace_members"
            ],
            "imported": false,
            "current_name": "initialize_output_file_name_00102943"
        },
        "FUN_00107c80": {
            "renaming": {
                "FUN_00107c80": "set_file_time_00107c80",
                "param_1": "filePath",
                "param_2": "fileInfo",
                "iVar1": "result",
                "piVar2": "errorNumber",
                "pcVar3": "errorMessage",
                "uVar4": "translatedErrorMessage",
                "local_38": "accessTime",
                "uStack_34": "modificationTime",
                "uStack_30": "changeTime",
                "uStack_2c": "createTime",
                "local_28": "backupAccessTime",
                "uStack_24": "backupModificationTime",
                "uStack_20": "backupChangeTime",
                "uStack_1c": "backupCreateTime"
            },
            "code": "\nvoid setFileTime_00107c80(char *filePath,long fileInfo)\n\n{\n  int result;\n  int *errorNumber;\n  char *errorMessage;\n  undefined8 translatedErrorMessage;\n  undefined4 accessTime;\n  undefined4 modificationTime;\n  undefined4 changeTime;\n  undefined4 createTime;\n  undefined4 backupAccessTime;\n  undefined4 backupModificationTime;\n  undefined4 backupChangeTime;\n  undefined4 backupCreateTime;\n  \n  backupAccessTime = *(undefined4 *)(fileInfo + 0x58);\n  backupModificationTime = *(undefined4 *)(fileInfo + 0x5c);\n  backupChangeTime = *(undefined4 *)(fileInfo + 0x60);\n  backupCreateTime = *(undefined4 *)(fileInfo + 100);\n  accessTime = *(undefined4 *)(fileInfo + 0x48);\n  modificationTime = *(undefined4 *)(fileInfo + 0x4c);\n  changeTime = *(undefined4 *)(fileInfo + 0x50);\n  createTime = *(undefined4 *)(fileInfo + 0x54);\n  result = utimensat(-100,filePath,(timespec *)&accessTime,0);\n  if (result != 0) {\n    errorNumber = __errno_location();\n    errorMessage = strerror(*errorNumber);\n    translatedErrorMessage = dcgettext(0,\"%s: cannot set time: %s\",5);\n    non_fatal(translatedErrorMessage,filePath,errorMessage);\n  }\n  return;\n}\n\n",
            "called": [
                "utimensat",
                "set_times.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c80",
            "calling": [
                "extract_file.cold"
            ],
            "imported": false,
            "current_name": "set_file_time_00107c80"
        },
        "FUN_001020d0": {
            "renaming": {},
            "code": "\nvoid bfd_set_default_target(void)\n\n{\n  bfd_set_default_target();\n  return;\n}\n\n",
            "called": [
                "bfd_set_default_target"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020d0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001020d0"
        },
        "FUN_001021f0": {
            "renaming": {},
            "code": "\n\n\nint fputs(char *__s,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputs(__s,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputs"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021f0",
            "calling": [
                "print_arelt_descr.cold"
            ],
            "imported": false,
            "current_name": "FUN_001021f0"
        },
        "FUN_00102390": {
            "renaming": {},
            "code": "\n\n\nint fileno(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fileno(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fileno"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102390",
            "calling": [
                "yy_init_buffer",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102390"
        },
        "FUN_00102d8c": {
            "renaming": {
                "FUN_00102d8c": "print_file_info_00102d8c",
                "param_19": "filePermissions",
                "param_20": "fileSize",
                "param_22": "modificationTime",
                "__format": "corruptTimeString",
                "unaff_RBX": "fileInfo",
                "unaff_RBP": "filePointer",
                "unaff_R12B": "isExecutable",
                "uStack0000000000000015": "fileType",
                "cStack0000000000000016": "userReadPermission",
                "cStack0000000000000017": "userWritePermission",
                "param_9": "userExecutePermission",
                "cStack0000000000000019": "groupReadPermission",
                "cStack000000000000001a": "groupWritePermission",
                "cStack000000000000001b": "groupExecutePermission",
                "cStack000000000000001c": "otherReadPermission",
                "cStack000000000000001d": "otherWritePermission",
                "cStack000000000000001e": "otherExecutePermission",
                "uStack000000000000001f": "isSpecialFile",
                "uStack000000000000006c": "inode",
                "fprintf": "printFormatted",
                "dcgettext": "getLocaleString",
                "sprintf": "formatString"
            },
            "code": "\nvoid printFileInfo_00102d8c(void)\n\n{\n  char *corruptTimeString;\n  uint uVar1;\n  char **fileInfo;\n  FILE *filePointer;\n  char isExecutable;\n  undefined fileType;\n  char userReadPermission;\n  char userWritePermission;\n  char userExecutePermission;\n  char groupReadPermission;\n  char groupWritePermission;\n  char groupExecutePermission;\n  char otherReadPermission;\n  char otherWritePermission;\n  char otherExecutePermission;\n  undefined isSpecialFile;\n  uint filePermissions;\n  uint inode;\n  uint fileSize;\n  undefined8 modificationTime;\n  \n  corruptTimeString = (char *)getLocaleString(0,\"<time data corrupt>\",5);\n  formatString(&stack0x00000020,corruptTimeString);\n  uVar1 = filePermissions & 0xf000;\n  if (uVar1 == 0x4000) {\n    fileType = 100;\n  }\n  else if (uVar1 == 0xa000) {\n    fileType = 0x6c;\n  }\n  else if (uVar1 == 0x6000) {\n    fileType = 0x62;\n  }\n  else if (uVar1 == 0x2000) {\n    fileType = 99;\n  }\n  else if (uVar1 == 0xc000) {\n    fileType = 0x73;\n  }\n  else {\n    fileType = 0x70;\n    if (uVar1 != 0x1000) {\n      fileType = 0x2d;\n    }\n  }\n  userReadPermission = (-((filePermissions & 0x100) == 0) & 0xbbU) + 0x72;\n  userWritePermission = (-((filePermissions & 0x80) == 0) & 0xb6U) + 0x77;\n  userExecutePermission = (-((filePermissions & 0x40) == 0) & 0xb5U) + 0x78;\n  groupReadPermission = (-((filePermissions & 0x20) == 0) & 0xbbU) + 0x72;\n  groupWritePermission = (-((filePermissions & 0x10) == 0) & 0xb6U) + 0x77;\n  groupExecutePermission = (-((filePermissions & 8) == 0) & 0xb5U) + 0x78;\n  otherReadPermission = (-((filePermissions & 4) == 0) & 0xbbU) + 0x72;\n  otherWritePermission = (-((filePermissions & 2) == 0) & 0xb6U) + 0x77;\n  otherExecutePermission = (-((filePermissions & 1) == 0) & 0xb5U) + 0x78;\n  if ((filePermissions & 0x800) != 0) {\n    if (userExecutePermission == 'x') {\n      userExecutePermission = 's';\n    }\n    else {\n      userExecutePermission = 'S';\n    }\n  }\n  if ((filePermissions & 0x400) != 0) {\n    if (groupExecutePermission == 'x') {\n      groupExecutePermission = 's';\n    }\n    else {\n      groupExecutePermission = 'S';\n    }\n  }\n  if ((filePermissions & 0x200) != 0) {\n    if (otherExecutePermission == 'x') {\n      otherExecutePermission = 't';\n    }\n    else {\n      otherExecutePermission = 'T';\n    }\n  }\n  isSpecialFile = 0;\n  printFormatted(filePointer,\"%s %ld/%ld %6lu %s \",&stack0x00000016,(ulong)inode,\n          (ulong)fileSize,modificationTime,&stack0x00000020,(ulong)filePermissions);\n  fputs(*fileInfo,filePointer);\n  if (isExecutable != '\\0') {\n    if ((*(byte *)((long)fileInfo + 0x49) & 0x10) == 0) {\n      if (fileInfo[0xb] != (char *)0x0) {\n        printFormatted(filePointer,\" 0x%lx\");\n      }\n    }\n    else if (fileInfo[0xc] != (char *)0x0) {\n      printFormatted(filePointer,\" 0x%lx\");\n    }\n  }\n  fputc(10,filePointer);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fputs",
                "fputc",
                "dcgettext",
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102d8c",
            "calling": [
                "print_arelt_descr"
            ],
            "imported": false,
            "current_name": "print_file_info_00102d8c"
        },
        "FUN_00105300": {
            "renaming": {
                "FUN_00105300": "convert_and_open_archive_00105300",
                "param_1": "input_filename",
                "param_2": "archived_files",
                "plVar1": "current_archived_file",
                "pcVar2": "output_filename",
                "bVar3": "is_thin_library",
                "cVar4": "format_result",
                "iVar5": "error_code",
                "uVar6": "error_message",
                "uVar7": "error_message_2",
                "piVar8": "errno_ptr",
                "lVar9": "file_offset",
                "puVar10": "arch_file",
                "local_b0": "formats",
                "local_a8": "file_stats",
                "target": "default_target",
                "operation_alters_arch": "alters_arch_operation",
                "silent_create": "is_silent_create",
                "make_thin_archive": "is_make_thin_archive"
            },
            "code": "\n\n\nundefined8 * convertAndOpenArchive_00105300(char *input_filename,undefined8 *archived_files)\n\n{\n  long *current_archived_file;\n  char *output_filename;\n  byte is_thin_library;\n  char format_result;\n  int error_code;\n  undefined8 error_message;\n  undefined8 error_message_2;\n  int *errno_ptr;\n  long file_offset;\n  undefined8 *arch_file;\n  undefined8 formats;\n  stat file_stats;\n  \n  bfd_set_error(0);\n  if (default_target == (char *)0x0) {\n    default_target = \"plugin\";\n  }\n  error_code = stat(input_filename,&file_stats);\n  output_filename = output_filename;\n  if (error_code == 0) goto LAB_001053be;\n  errno_ptr = __errno_location();\n  if (*errno_ptr == 2) {\n    if (alters_arch_operation == '\\0') {\n      fprintf(_stderr,\"%s: \",program_name);\n      perror(input_filename);\n      maybequit();\n      return (undefined8 *)0x0;\n    }\n    if ((default_target == (char *)0x0) && (archived_files != (undefined8 *)0x0)) {\n      arch_file = (undefined8 *)open_inarch_cold();\n      return arch_file;\n    }\n    archived_files = (undefined8 *)bfd_openw(input_filename,default_target);\n    if (((archived_files != (undefined8 *)0x0) && (format_result = bfd_set_format(archived_files,2), format_result != '\\0')) &&\n       (format_result = bfd_close(archived_files), format_result != '\\0')) {\n      output_filename = input_filename;\n      if (is_silent_create == 0) goto LAB_00102826;\n      goto LAB_001053be;\n    }\n  }\n  bfd_fatal(input_filename);\n  do {\n    is_thin_library = *(byte *)((long)archived_files + 0x49) >> 4 & 1;\n    if (is_make_thin_archive == '\\0') {\n      if (is_thin_library != 0) {\n        error_message_2 = *archived_files;\n        error_message = dcgettext(0,\"Cannot convert existing thin library %s to normal format\",5);\n        fatal(error_message,error_message_2);\n        goto LAB_00102812;\n      }\n    }\n    else if (is_thin_library == 0) {\n      error_message_2 = *archived_files;\n      error_message = dcgettext(0,\"Cannot convert existing library %s to thin format\",5);\n      fatal(error_message,error_message_2);\nLAB_001027cb:\n      bfd_nonfatal(input_filename);\n      error_code = bfd_get_error();\n      if (error_code == 0xd) {\nLAB_00102812:\n        list_matching_formats(formats);\n      }\n                    \n      xexit(1);\n    }\n    do {\n      current_archived_file = archived_files + 0x1e;\n      for (file_offset = bfd_openr_next_archived_file(archived_files,0); file_offset != 0;\n          file_offset = bfd_openr_next_archived_file(archived_files,file_offset)) {\n        *current_archived_file = file_offset;\n        current_archived_file = (long *)(file_offset + 0xf0);\n      }\n      *current_archived_file = 0;\n      error_code = bfd_get_error();\n      if (error_code == 9) {\n        return archived_files;\n      }\n      do {\n        bfd_fatal(input_filename);\nLAB_00102826:\n        error_message_2 = dcgettext(0,\"creating %s\",5);\n        non_fatal(error_message_2,input_filename);\n        output_filename = input_filename;\nLAB_001053be:\n        output_filename = output_filename;\n        archived_files = (undefined8 *)bfd_openr(input_filename,default_target);\n      } while (archived_files == (undefined8 *)0x0);\n      format_result = bfd_check_format_matches(archived_files,2,&formats);\n      if (format_result == '\\0') goto LAB_001027cb;\n    } while (((operation != 2) && (operation != 7)) ||\n            (file_offset = bfd_openr_next_archived_file(archived_files,0), file_offset == 0));\n  } while( true );\n}\n\n",
            "called": [
                "xexit",
                "bfd_openr_next_archived_file",
                "bfd_fatal",
                "fprintf",
                "maybequit",
                "bfd_check_format_matches",
                "bfd_nonfatal",
                "bfd_openr",
                "dcgettext",
                "non_fatal",
                "fatal",
                "stat",
                "open_inarch.cold",
                "list_matching_formats",
                "__errno_location",
                "bfd_openw",
                "bfd_get_error",
                "perror",
                "bfd_close",
                "bfd_set_error",
                "bfd_set_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105300",
            "calling": [
                "ranlib_only",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "convert_and_open_archive_00105300"
        },
        "FUN_00105db0": {
            "renaming": {
                "FUN_00105db0": "decompile_and_improve_00105db0",
                "param_1": "input_flag",
                "param_2": "input_file",
                "pbVar1": "ptr_byte_1",
                "puVar2": "ptr_uint_2",
                "bVar3": "byte_flag_3",
                "plVar4": "ptr_long_4",
                "puVar5": "ptr_ulonglong_5",
                "uVar6": "uint_var_6",
                "uVar7": "uint_var_7",
                "bVar8": "bool_flag_8",
                "bVar9": "bool_flag_9",
                "ppcVar10": "ptr_of_ptr_char_10",
                "piVar11": "ptr_int_11",
                "puVar12": "ptr_undefined_12",
                "bVar13": "byte_var_13",
                "cVar14": "char_var_14",
                "iVar15": "int_var_15",
                "uVar16": "uint_var_16",
                "uVar17": "uint_var_17",
                "pFVar18": "ptr_FILE_18",
                "sVar19": "size_var_19",
                "sVar20": "size_var_20",
                "__ptr": "ptr_byte_21",
                "plVar21": "ptr_long_22",
                "pFVar22": "ptr_FILE_23",
                "pcVar23": "ptr_char_24",
                "lVar24": "long_var_25",
                "uVar25": "ulong_var_26",
                "puVar26": "ptr_ulonglong_27",
                "uVar27": "ulong_var_28",
                "pFVar28": "ptr_FILE_29",
                "pplVar29": "ptr_of_ptr_long_30",
                "uVar30": "ulong_var_31",
                "ppcVar31": "ptr_of_ptr_char_32",
                "extraout_EDX": "uint_extraout_EDX",
                "ppcVar32": "ptr_of_ptr_char_33",
                "pbVar33": "ptr_byte_34",
                "lVar34": "long_var_35",
                "lVar35": "long_var_36",
                "puVar36": "ptr_undefined_37",
                "uVar37": "uint_var_38",
                "unaff_RBP": "ptr_char_39",
                "pbVar38": "ptr_byte_40",
                "pcVar39": "ptr_char_41",
                "uVar40": "ulong_var_42",
                "uVar41": "ulong_var_43",
                "uVar42": "ulong_var_44",
                "uVar44": "uint_var_45",
                "iVar45": "int_var_46",
                "pcVar46": "ptr_char_47",
                "bVar47": "bool_flag_48",
                "bVar48": "byte_flag_49",
                "local_130": "var_local_130",
                "local_128": "var_local_128",
                "local_118": "var_local_118",
                "local_110": "var_local_110",
                "local_108": "var_local_108",
                "local_100": "var_local_100",
                "local_c8": "arr_undefined_120",
                "local_b0": "var_local_b0"
            },
            "code": "\n\n\nvoid decompile_and_improve_00105db0(uint input_flag,FILE *input_file)\n\n{\n  byte *ptr_byte_1;\n  uint *ptr_uint_2;\n  byte byte_flag_3;\n  long *ptr_long_4;\n  undefined8 *ptr_ulonglong_5;\n  undefined4 uint_var_6;\n  undefined4 uint_var_7;\n  bool bool_flag_8;\n  bool bool_flag_9;\n  char **ptr_of_ptr_char_10;\n  int *ptr_int_11;\n  undefined *ptr_undefined_12;\n  byte byte_var_13;\n  char char_var_14;\n  int int_var_15;\n  uint uint_var_16;\n  undefined4 uint_var_17;\n  FILE *ptr_FILE_18;\n  size_t size_var_19;\n  size_t size_var_20;\n  byte *ptr_byte_21;\n  long *ptr_long_22;\n  FILE *ptr_FILE_23;\n  char *ptr_char_24;\n  long long_var_25;\n  ulong ulong_var_26;\n  undefined8 *ptr_ulonglong_27;\n  undefined8 ulong_var_28;\n  FILE *ptr_FILE_29;\n  long **ptr_of_ptr_long_30;\n  undefined8 ulong_var_31;\n  char **ptr_of_ptr_char_32;\n  uint uint_extraout_EDX;\n  char **ptr_of_ptr_char_33;\n  byte *ptr_byte_34;\n  long long_var_35;\n  long long_var_36;\n  undefined1 *ptr_undefined_37;\n  uint uint_var_38;\n  char *ptr_char_39;\n  byte *ptr_byte_40;\n  char *ptr_char_41;\n  ulong ulong_var_42;\n  ulong ulong_var_43;\n  ulong ulong_var_44;\n  FILE *unaff_R12;\n  char *pcVar43;\n  uint uint_var_45;\n  int int_var_46;\n  char *ptr_char_47;\n  bool bool_flag_48;\n  byte byte_flag_49;\n  undefined8 var_local_130;\n  FILE *var_local_128;\n  byte *var_local_118;\n  char **var_local_110;\n  size_t var_local_108;\n  long var_local_100;\n  undefined arr_undefined_120 [2];\n  undefined uStack_c6;\n  undefined5 uStack_c5;\n  uint var_local_b0;\n  \n  byte_flag_49 = 0;\n  ptr_char_47 = (char *)(ulong)input_flag;\n  setlocale(5,\"\");\n  setlocale(0,\"\");\n  bindtextdomain(\"binutils\",\"/usr/share/locale\");\n  textdomain(\"binutils\");\n  program_name = *(long **)input_file;\n  xmalloc_set_program_name();\n  bfd_set_error_program_name(program_name);\n  bfd_plugin_set_program_name(program_name);\n  pcVar43 = (char *)input_file;\n  ptr_FILE_18 = input_file;\n  if ((int)input_flag < 2) goto LAB_001062c6;\n  var_local_110 = (char **)0x7d0;\n  unaff_R12 = (FILE *)0x1;\n  var_local_128 = (FILE *)0x0;\n  ptr_FILE_23 = input_file;\n  do {\n    uint_var_16 = (uint)unaff_R12;\n    ptr_char_39 = (char *)(long)(int)uint_var_16;\n    var_local_130 = (FILE *)((long)ptr_char_39 * 8);\n    pcVar43 = (char *)ptr_FILE_23;\n    if (**(char **)(&ptr_FILE_23->_flags + (long)ptr_char_39 * 2) == '@') {\n      uint_var_45 = (int)var_local_110 - 1;\n      var_local_110 = (char **)(ulong)uint_var_45;\n      if (uint_var_45 == 0) {\n        ptr_long_22 = *(long **)ptr_FILE_23;\n        ptr_char_47 = \"%s: error: too many @-files encountered\\n\";\nLAB_00106ffe:\n        fprintf(_stderr,ptr_char_47,ptr_long_22);\nLAB_0010700f:\n                    \n        xexit(1);\n      }\n      ptr_char_41 = *(char **)(&ptr_FILE_23->_flags + (long)ptr_char_39 * 2) + 1;\n      int_var_15 = stat(ptr_char_41,(stat *)arr_undefined_120);\n      if (-1 < int_var_15) {\n        if ((var_local_b0 & 0xf000) == 0x4000) {\n          ptr_long_22 = *(long **)ptr_FILE_23;\n          ptr_char_47 = \"%s: error: @-file refers to a directory\\n\";\n          goto LAB_00106ffe;\n        }\n        ptr_FILE_18 = fopen(ptr_char_41,\"r\");\n        if (ptr_FILE_18 != (FILE *)0x0) {\n          int_var_15 = fseek(ptr_FILE_18,0,2);\n          if (((int_var_15 != -1) && (size_var_19 = ftell(ptr_FILE_18), size_var_19 != 0xffffffffffffffff)) &&\n             (int_var_15 = fseek(ptr_FILE_18,0,0), int_var_15 != -1)) {\n            var_local_118 = (byte *)xmalloc(size_var_19 + 1);\n            size_var_20 = fread(var_local_118,1,size_var_19,ptr_FILE_18);\n            if ((size_var_19 == size_var_20) || (int_var_15 = ferror(ptr_FILE_18), int_var_15 == 0)) {\n              var_local_118[size_var_20] = 0;\n              byte_var_13 = *var_local_118;\n              ptr_byte_34 = var_local_118;\n              while( true ) {\n                if (byte_var_13 == 0) goto LAB_00106814;\n                if (((&_sch_istable)[(ulong)byte_var_13 * 2] & 0x40) == 0) break;\n                byte_var_13 = ptr_byte_34[1];\n                ptr_byte_34 = ptr_byte_34 + 1;\n              }\n              size_var_19 = strlen((char *)var_local_118);\n              ptr_byte_21 = (byte *)xmalloc(size_var_19 + 1);\n              ptr_FILE_29 = (FILE *)0x0;\n              int_var_15 = 0;\n              bool_flag_9 = false;\n              bool_flag_48 = false;\n              bool_flag_8 = false;\n              var_local_100 = 0;\n              ptr_byte_34 = var_local_118;\n              do {\n                while (((&_sch_istable)[(ulong)*ptr_byte_34 * 2] & 0x40) != 0) {\n                  ptr_byte_34 = ptr_byte_34 + 1;\n                }\n                if ((int_var_15 == 0) || (int_var_15 + -1 <= (int)var_local_100)) {\n                  if (ptr_FILE_29 == (FILE *)0x0) {\n                    int_var_15 = 8;\n                    ptr_FILE_29 = (FILE *)xmalloc(0x40);\n                    ptr_of_ptr_char_32 = (char **)((long)&ptr_FILE_29->_flags + var_local_100 * 8);\n                    *ptr_of_ptr_char_32 = (char *)0x0;\n                  }\n                  else {\n                    int_var_15 = int_var_15 * 2;\n                    ptr_FILE_29 = (FILE *)xrealloc(ptr_FILE_29,(long)int_var_15 << 3);\n                    ptr_of_ptr_char_32 = (char **)((long)&ptr_FILE_29->_flags + var_local_100 * 8);\n                    *ptr_of_ptr_char_32 = (char *)0x0;\n                  }\n                }\n                else {\n                  ptr_of_ptr_char_32 = (char **)((long)&ptr_FILE_29->_flags + var_local_100 * 8);\n                }\n                byte_var_13 = *ptr_byte_34;\n                ptr_byte_40 = ptr_byte_21;\n                while (byte_var_13 != 0) {\n                  while( true ) {\n                    if ((((&_sch_istable)[(ulong)byte_var_13 * 2] & 0x40) != 0) &&\n                       (!(bool)(bool_flag_9 | bool_flag_8 | bool_flag_48))) {\n                      bool_flag_8 = false;\n                      bool_flag_9 = false;\n                      bool_flag_48 = false;\n                      goto LAB_0010606f;\n                    }\n                    if (!bool_flag_8) break;\n                    ptr_byte_34 = ptr_byte_34 + 1;\n                    *ptr_byte_40 = byte_var_13;\n                    ptr_byte_40 = ptr_byte_40 + 1;\n                    bool_flag_8 = false;\n                    byte_var_13 = *ptr_byte_34;\n                    if (byte_var_13 == 0) goto LAB_0010606f;\n                  }\n                  if (byte_var_13 == 0x5c) {\n                    bool_flag_8 = true;\n                  }\n                  else if (bool_flag_48) {\n                    if (byte_var_13 == 0x27) {\n                      bool_flag_48 = false;\n                    }\n                    else {\nLAB_001061f1:\n                      *ptr_byte_40 = byte_var_13;\n                      ptr_byte_40 = ptr_byte_40 + 1;\n                    }\n                  }\n                  else if (bool_flag_9) {\n                    if (byte_var_13 != 0x22) goto LAB_001061f1;\n                    bool_flag_9 = false;\n                  }\n                  else if (byte_var_13 == 0x27) {\n                    bool_flag_48 = true;\n                  }\n                  else {\n                    if (byte_var_13 != 0x22) goto LAB_001061f1;\n                    bool_flag_9 = true;\n                  }\n                  ptr_byte_1 = ptr_byte_34 + 1;\n                  ptr_byte_34 = ptr_byte_34 + 1;\n                  byte_var_13 = *ptr_byte_1;\n                }\nLAB_0010606f:\n                *ptr_byte_40 = 0;\n                ptr_long_22 = (long *)xstrdup(ptr_byte_21);\n                *ptr_of_ptr_char_32 = (char *)ptr_long_22;\n                *(undefined8 *)(ptr_FILE_29->_shortbuf + var_local_100 * 8 + -0x7b) = 0;\n                byte_var_13 = *ptr_byte_34;\n                byte_flag_3 = (&_sch_istable)[(ulong)byte_var_13 * 2];\n                while ((byte_flag_3 & 0x40) != 0) {\n                  byte_var_13 = ptr_byte_34[1];\n                  ptr_byte_34 = ptr_byte_34 + 1;\n                  byte_flag_3 = (&_sch_istable)[(ulong)byte_var_13 * 2];\n                }\n                var_local_100 = var_local_100 + 1;\n                if (byte_var_13 == 0) {\n                  free(ptr_byte_21);\n                  if (ptr_FILE_23 == input_file) goto LAB_00106834;\n                  goto LAB_0010610a;\n                }\n              } while( true );\n            }\n            free(var_local_118);\n          }\n          fclose(ptr_FILE_18);\n        }\n      }\n    }\n    if ((int)ptr_char_47 <= (int)(uint_var_16 + 1)) {\nLAB_001062c6:\n      do {\n        if (is_ranlib < 0) goto LAB_001073cc;\nLAB_001062d3:\n        uint_var_16 = (uint)unaff_R12;\n        int_var_15 = bfd_init();\n        ptr_char_41 = \"fatal error: libbfd ABI mismatch\";\n        if (int_var_15 != 0x118) goto LAB_00106803;\n        ptr_char_41 = \"x86_64-pc-linux-gnu\";\n        uint_var_16 = bfd_set_default_target(\"x86_64-pc-linux-gnu\",\"fatal error: libbfd ABI mismatch\",5);\n        ptr_undefined_12 = xatexit_head;\n        unaff_R12 = (FILE *)(ulong)uint_var_16;\n        if ((char)uint_var_16 != '\\0') {\n          if (__xexit_cleanup == (code *)0x0) {\n            __xexit_cleanup = xatexit_cleanup;\n          }\n          if (*(int *)(xatexit_head + 8) < 0x20) {\nLAB_0010632b:\n            ptr_undefined_12 = xatexit_head;\n            int_var_15 = *(int *)(xatexit_head + 8);\n            *(int *)(xatexit_head + 8) = int_var_15 + 1;\n            *(code **)(ptr_undefined_12 + (long)int_var_15 * 8 + 0x10) = remove_output;\n          }\n          else {\n            ptr_ulonglong_27 = (undefined8 *)malloc(0x110);\n            if (ptr_ulonglong_27 != (undefined8 *)0x0) {\n              *ptr_ulonglong_27 = ptr_undefined_12;\n              *(undefined4 *)(ptr_ulonglong_27 + 1) = 0;\n              xatexit_head = (undefined *)ptr_ulonglong_27;\n              goto LAB_0010632b;\n            }\n          }\n          long_var_25 = 1;\n          do {\n            long_var_36 = long_var_25;\n            int_var_15 = (int)ptr_char_47;\n            if (int_var_15 <= (int)long_var_36) break;\n            char_var_14 = ar_emul_default_parse_arg(*(undefined8 *)((int *)pcVar43 + long_var_36 * 2));\n            long_var_25 = long_var_36 + 1;\n          } while (char_var_14 != '\\0');\n          ptr_char_47 = (char *)((long)pcVar43 + long_var_36 * 8 + -8);\n          uint_var_45 = int_var_15 - ((int)long_var_36 + -1);\n          ptr_FILE_18 = (FILE *)(ulong)uint_var_45;\n          if (is_ranlib != 0) {\n            pcVar43 = \"DhHUvVt\";\n            uint_var_38 = 0;\n            while (int_var_15 = getopt_long(ptr_FILE_18,ptr_char_47,\"DhHUvVt\",long_options), int_var_15 != -1) {\n              if (int_var_15 < 0x77) {\n                if (0x43 < int_var_15) {\n                  switch(int_var_15) {\n                  case 0x44:\n                    deterministic = 1;\n                    break;\n                  case 0x48:\n                  case 0x68:\n                    show_help = 1;\n                    break;\n                  case 0x55:\n                    deterministic = 0;\n                    break;\n                  case 0x56:\n                  case 0x76:\n                    show_version = 1;\n                    break;\n                  case 0x74:\n                    uint_var_38 = uint_var_16;\n                  }\n                }\n              }\n              else if (int_var_15 == 0xc9) {\n                bfd_plugin_set_plugin(_optarg);\n              }\n            }\n            if ((int)uint_var_45 < 2) {\nLAB_00107125:\n              ptr_char_41 = (char *)0x0;\n              ranlib_usage();\n            }\n            else {\n              if (show_help != 0) {\nLAB_0010711b:\n                ranlib_usage();\n                goto LAB_00107125;\n              }\n              if (show_version != 0) {\n                print_version(\"ranlib\");\n                goto LAB_0010711b;\n              }\n              if (deterministic < 0) {\n                deterministic = 1;\n              }\n              unaff_R12 = (FILE *)0x0;\n              pcVar43 = (char *)(long)_optind;\n              while( true ) {\n                if ((int)uint_var_45 <= (int)pcVar43) goto LAB_00106f8b;\n                ptr_char_41 = *(char **)((int *)ptr_char_47 + (long)pcVar43 * 2);\n                if ((char)uint_var_38 != '\\0') break;\n                uint_var_16 = ranlib_only();\n                pcVar43 = (char *)((long)(int *)pcVar43 + 1);\n                unaff_R12 = (FILE *)(ulong)((uint)unaff_R12 | uint_var_16);\n              }\n            }\n            while (long_var_25 = get_file_size(ptr_char_41), long_var_25 < 1) {\n              uint_var_16 = 1;\nLAB_001071c4:\n              ptr_int_11 = (int *)pcVar43;\n              pcVar43 = (char *)((long)ptr_int_11 + 1);\n              unaff_R12 = (FILE *)(ulong)((uint)unaff_R12 | uint_var_16);\n              if ((int)uint_var_45 <= (int)pcVar43) {\nLAB_00106f8b:\n                    \n                xexit(unaff_R12);\n              }\n              ptr_char_41 = *(char **)((char *)((long)ptr_char_47 + 0x83) + (long)ptr_int_11 * 8 + -0x7b);\n            }\n            int_var_15 = open(ptr_char_41,2,0);\n            if (int_var_15 < 0) {\n              bfd_set_error(1);\n              bfd_fatal(ptr_char_41);\nLAB_0010737f:\n              bfd_fatal(ptr_char_41);\nLAB_00107387:\n              bfd_nonfatal(ptr_char_41);\n              int_var_15 = bfd_get_error();\n              if (int_var_15 == 0xd) {\n                list_matching_formats\n                          (CONCAT53(uStack_c5,CONCAT12(uStack_c6,CONCAT11(arr_undefined_120[1],arr_undefined_120[0])))\n                          );\n              }\n              goto LAB_0010700f;\n            }\n            ptr_char_39 = (char *)bfd_fdopenr(ptr_char_41,0);\n            if ((FILE *)ptr_char_39 == (FILE *)0x0) goto LAB_0010737f;\n            char_var_14 = bfd_check_format_matches(ptr_char_39,2,arr_undefined_120);\n            if (char_var_14 == '\\0') goto LAB_00107387;\n            if ((*(byte *)((long)((long)ptr_char_39 + 0x48) + 1) & 8) != 0) {\n              if (deterministic != 0) {\n                ptr_uint_2 = (uint *)((long)((long)ptr_char_39 + 0x40) + 4);\n                *ptr_uint_2 = *ptr_uint_2 | 0x2000;\n              }\n              (**(code **)(*(char **)((long)ptr_char_39 + 8) + 0x1f0))(ptr_char_39);\n              char_var_14 = bfd_close(ptr_char_39);\n              if (char_var_14 != '\\0') {\n                uint_var_16 = 0;\n                goto LAB_001071c4;\n              }\n              goto LAB_0010737f;\n            }\n            ulong_var_28 = dcgettext(0,\"%s: no archive map to update\",5);\n            fatal(ulong_var_28,ptr_char_41);\nLAB_001073cc:\n            ptr_char_41 = (char *)lbasename(program_name);\n            size_var_19 = strlen(ptr_char_41);\n            if ((size_var_19 < 6) ||\n               (int_var_15 = filename_cmp(ptr_char_41 + (size_var_19 - 6),\"ranlib\"), int_var_15 != 0)) {\n              is_ranlib = 0;\n            }\n            else {\n              is_ranlib = 1;\n            }\n            goto LAB_001062d3;\n          }\n          ptr_undefined_37 = long_options;\n          ptr_char_39 = \"hdmpqrtxl:coOVsSuvabiMNfPTDU\";\n          pcVar43 = (char *)&DAT_001096a0;\n          ptr_FILE_23 = (FILE *)ptr_char_39;\n          ptr_FILE_29 = ptr_FILE_18;\n          if ((int)uint_var_45 < 2) goto switchD_00107462_caseD_1;\n          var_local_130 = (FILE *)CONCAT71(var_local_130._1_7_,(char)uint_var_16);\nLAB_001063a3:\n          ptr_FILE_23 = (FILE *)ptr_char_39;\n          if (**(char **)((long)ptr_char_47 + 8) != '-') {\n            arr_undefined_120[0] = 0x2d;\n            uStack_c6 = 0;\n            size_var_19 = strlen(*(char **)((long)ptr_char_47 + 8));\n            int_var_15 = (int)size_var_19 + (int)ptr_FILE_18;\n            unaff_R12 = (FILE *)xmalloc((long)int_var_15 * 8);\n            uint_var_17 = *(undefined4 *)((long)ptr_char_47 + 4);\n            unaff_R12->_flags = *(int *)ptr_char_47;\n            *(undefined4 *)&unaff_R12->field_0x4 = uint_var_17;\n            ptr_of_ptr_char_32 = *(char ***)((long)ptr_char_47 + 8);\n            var_local_128 = (FILE *)((long)ptr_char_47 + 0x10);\n            var_local_110 = ptr_of_ptr_char_32;\n            if (*(char *)ptr_of_ptr_char_32 == '\\0') {\n              ptr_of_ptr_char_33 = &unaff_R12->_IO_read_ptr;\n            }\n            else {\n              var_local_118 = arr_undefined_120;\n              arr_undefined_120[1] = *(char *)ptr_of_ptr_char_32;\n              ptr_char_41 = (char *)xstrdup();\n              ptr_of_ptr_char_33 = &unaff_R12->_IO_read_end;\n              unaff_R12->_IO_read_ptr = ptr_char_41;\n              if (*(char *)((long)ptr_of_ptr_char_32 + 1) != '\\0') {\n                arr_undefined_120[1] = *(char *)((long)ptr_of_ptr_char_32 + 1);\n                ptr_char_41 = (char *)xstrdup(var_local_118);\n                ptr_of_ptr_char_33 = &unaff_R12->_IO_read_base;\n                unaff_R12->_IO_read_end = ptr_char_41;\n                if (*(char *)((long)ptr_of_ptr_char_32 + 2) != '\\0') {\n                  arr_undefined_120[1] = *(char *)((long)ptr_of_ptr_char_32 + 2);\n                  ptr_char_41 = (char *)xstrdup(var_local_118);\n                  ptr_of_ptr_char_33 = &unaff_R12->_IO_write_base;\n                  unaff_R12->_IO_read_base = ptr_char_41;\n                  if (*(char *)((long)ptr_of_ptr_char_32 + 3) != '\\0') {\n                    ptr_of_ptr_char_33 = &unaff_R12->_IO_write_ptr;\n                    arr_undefined_120[1] = *(char *)((long)ptr_of_ptr_char_32 + 3);\n                    ptr_char_41 = (char *)xstrdup(var_local_118);\n                    unaff_R12->_IO_write_base = ptr_char_41;\n                    char_var_14 = *(char *)((long)ptr_of_ptr_char_32 + 4);\n                    var_local_110 = ptr_of_ptr_char_33;\n                    if (char_var_14 != '\\0') {\n                      ptr_char_41 = (char *)((long)ptr_of_ptr_char_32 + 4);\n                      ptr_of_ptr_char_32 = ptr_of_ptr_char_33;\n                      do {\n                        ptr_of_ptr_char_33 = ptr_of_ptr_char_32 + 1;\n                        arr_undefined_120[1] = char_var_14;\n                        ptr_char_24 = (char *)xstrdup(var_local_118);\n                        ptr_char_41 = ptr_char_41 + 1;\n                        *ptr_of_ptr_char_32 = ptr_char_24;\n                        char_var_14 = *ptr_char_41;\n                        ptr_of_ptr_char_32 = ptr_of_ptr_char_33;\n                        var_local_110 = ptr_of_ptr_char_33;\n                      } while (char_var_14 != '\\0');\n                    }\n                  }\n                }\n              }\n            }\n            long_var_25 = (long)(int)ptr_FILE_18;\n            ptr_int_11 = (int *)ptr_char_47 + long_var_25 * 2;\n            if (var_local_128 < ptr_int_11) {\n              ulong_var_26 = long_var_25 * 8 - 0x11;\n              if ((ulong_var_26 < 0x18) || (ptr_of_ptr_char_33 == (char **)((long)ptr_char_47 + 0x18))) {\n                *ptr_of_ptr_char_33 = *(char **)((long)ptr_char_47 + 0x10);\n                if (((char **)((long)ptr_char_47 + 0x18) < ptr_int_11) &&\n                   ((((ptr_of_ptr_char_33[1] = *(char **)((long)ptr_char_47 + 0x18),\n                      (char **)((long)ptr_char_47 + 0x20) < ptr_int_11 &&\n                      (ptr_of_ptr_char_33[2] = *(char **)((long)ptr_char_47 + 0x20),\n                      (char **)((long)ptr_char_47 + 0x28) < ptr_int_11)) &&\n                     (ptr_of_ptr_char_33[3] = *(char **)((long)ptr_char_47 + 0x28),\n                     (char **)((long)ptr_char_47 + 0x30) < ptr_int_11)) &&\n                    (ptr_of_ptr_char_33[4] = *(char **)((long)ptr_char_47 + 0x30),\n                    (char **)((long)ptr_char_47 + 0x38) < ptr_int_11)))) {\n                  ptr_of_ptr_char_33[5] = *(char **)((long)ptr_char_47 + 0x38);\n                  ptr_of_ptr_char_10 = ptr_of_ptr_char_33 + 6;\n                  for (ptr_of_ptr_char_32 = (char **)((long)ptr_char_47 + 0x40); ptr_of_ptr_char_32 < ptr_int_11;\n                      ptr_of_ptr_char_32 = ptr_of_ptr_char_32 + (ulong)byte_flag_49 * -2 + 1) {\n                    *ptr_of_ptr_char_10 = *ptr_of_ptr_char_32;\n                    ptr_of_ptr_char_10 = ptr_of_ptr_char_10 + (ulong)byte_flag_49 * -2 + 1;\n                  }\n                }\n              }\n              else {\n                uint_var_17 = *(undefined4 *)((long)((long)ptr_char_47 + 0x10) + 4);\n                uint_var_6 = *(undefined4 *)((long)ptr_char_47 + 0x18);\n                uint_var_7 = *(undefined4 *)((long)((long)ptr_char_47 + 0x18) + 4);\n                ulong_var_42 = (ulong_var_26 >> 3) + 1;\n                *(undefined4 *)ptr_of_ptr_char_33 = *(undefined4 *)((long)ptr_char_47 + 0x10);\n                *(undefined4 *)((long)ptr_of_ptr_char_33 + 4) = uint_var_17;\n                *(undefined4 *)(ptr_of_ptr_char_33 + 1) = uint_var_6;\n                *(undefined4 *)((long)ptr_of_ptr_char_33 + 0xc) = uint_var_7;\n                uint_var_17 = *(undefined4 *)((long)((long)ptr_char_47 + 0x20) + 4);\n                uint_var_6 = *(undefined4 *)((long)ptr_char_47 + 0x28);\n                uint_var_7 = *(undefined4 *)((long)((long)ptr_char_47 + 0x28) + 4);\n                ulong_var_26 = ulong_var_42 >> 1;\n                *(undefined4 *)(ptr_of_ptr_char_33 + 2) = *(undefined4 *)((long)ptr_char_47 + 0x20);\n                *(undefined4 *)((long)ptr_of_ptr_char_33 + 0x14) = uint_var_17;\n                *(undefined4 *)(ptr_of_ptr_char_33 + 3) = uint_var_6;\n                *(undefined4 *)((long)ptr_of_ptr_char_33 + 0x1c) = uint_var_7;\n                if (ulong_var_26 != 2) {\n                  uint_var_17 = *(undefined4 *)((long)((long)ptr_char_47 + 0x30) + 4);\n                  uint_var_6 = *(undefined4 *)((long)ptr_char_47 + 0x38);\n                  uint_var_7 = *(undefined4 *)((long)((long)ptr_char_47 + 0x38) + 4);\n                  *(undefined4 *)(ptr_of_ptr_char_33 + 4) = *(undefined4 *)((long)ptr_char_47 + 0x30);\n                  *(undefined4 *)((long)ptr_of_ptr_char_33 + 0x24) = uint_var_17;\n                  *(undefined4 *)(ptr_of_ptr_char_33 + 5) = uint_var_6;\n                  *(undefined4 *)((long)ptr_of_ptr_char_33 + 0x2c) = uint_var_7;\n                  if (ulong_var_26 != 3) {\n                    ulong_var_43 = 3;\n                    do {\n                      ulong_var_44 = ulong_var_43 + 1;\n                      ptr_char_41 = (char *)((long)ptr_char_47 + 0x83) + ulong_var_43 * 0x10 + -0x73;\n                      uint_var_17 = *(undefined4 *)(ptr_char_41 + 4);\n                      uint_var_6 = *(undefined4 *)(ptr_char_41 + 8);\n                      uint_var_7 = *(undefined4 *)(ptr_char_41 + 0xc);\n                      ptr_of_ptr_char_32 = ptr_of_ptr_char_33 + ulong_var_43 * 2;\n                      *(undefined4 *)ptr_of_ptr_char_32 = *(undefined4 *)ptr_char_41;\n                      *(undefined4 *)((long)ptr_of_ptr_char_32 + 4) = uint_var_17;\n                      *(undefined4 *)(ptr_of_ptr_char_32 + 1) = uint_var_6;\n                      *(undefined4 *)((long)ptr_of_ptr_char_32 + 0xc) = uint_var_7;\n                      ulong_var_43 = ulong_var_44;\n                    } while (ulong_var_44 != ulong_var_26);\n                  }\n                }\n                if ((ulong_var_42 & 1) != 0) {\n                  ptr_of_ptr_char_33[ulong_var_42 & 0xfffffffffffffffe] =\n                       *(char **)((long)var_local_128 + (ulong_var_42 & 0xfffffffffffffffe) * 8);\n                }\n              }\n              ptr_of_ptr_char_33 = ptr_of_ptr_char_33 + long_var_25 + -2;\n            }\n            ptr_FILE_18 = (FILE *)(ulong)(int_var_15 - 1);\n            *ptr_of_ptr_char_33 = (char *)0x0;\n            ptr_char_47 = (char *)unaff_R12;\n          }\nLAB_001065a2:\n          while( true ) {\n            uint_var_16 = (uint)unaff_R12;\n            uint_var_45 = getopt_long((ulong)ptr_FILE_18 & 0xffffffff,ptr_char_47,ptr_FILE_23,ptr_undefined_37,0);\n            ptr_char_39 = (char *)ptr_FILE_23;\n            if (uint_var_45 == 0xffffffff) break;\n            if (((uint_var_45 - 100 < 0x15) && ((0x117201UL >> ((ulong)(uint_var_45 - 100) & 0x3f) & 1) != 0))\n               && (operation != 0)) goto LAB_001067f7;\n            ptr_FILE_29 = (FILE *)ptr_char_47;\n            if (uint_var_45 < 0xcc) {\n                    /* WARNING: Could not recover jumptable at 0x001065eb. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n              (*(code *)((long)(int *)pcVar43 + (long)((int *)pcVar43)[uint_var_45]))();\n              return;\n            }\nswitchD_00107462_caseD_1:\n            usage(0);\n            ptr_char_47 = (char *)ptr_FILE_29;\nswitchD_00107462_caseD_68:\n            show_help = 1;\n          }\nLAB_00106680:\n          uint_var_45 = operation;\n          ptr_FILE_23 = (FILE *)ptr_char_39;\n          if (operation == 0) {\n            if (((write_armap == 1) || (mri_mode != 0)) ||\n               (((int)ptr_FILE_18 <= _optind || (_optind < 1)))) {\n              uint_var_45 = 0;\n              goto LAB_001066aa;\n            }\n            ptr_char_47 = (char *)((long)ptr_char_47 + (long)_optind * 8 + -8);\n            uint_var_16 = (int)ptr_FILE_18 - (_optind + -1);\n            ptr_FILE_18 = (FILE *)(ulong)uint_var_16;\n            _optind = 0;\n            if (1 < (int)uint_var_16) goto LAB_001063a3;\n            goto LAB_001065a2;\n          }\nLAB_001066aa:\n          unaff_R12 = (FILE *)((ulong)var_local_130 & 0xff);\n          uint_var_16 = (uint)unaff_R12;\n          ptr_undefined_37 = (undefined1 *)((int *)ptr_char_47 + (long)_optind * 2);\n          if (show_help == 0) {\n            if (show_version != 0) {\n              print_version(&DAT_0010807c);\n              goto LAB_00107591;\n            }\n            if (mri_mode == 0) {\n              ptr_FILE_29 = (FILE *)ptr_char_47;\n              if (*(long *)ptr_undefined_37 == 0) goto switchD_00107462_caseD_1;\n              if (operation == 7) {\n                if (write_armap == 0) {\n                  if (uint_var_45 == 3) goto LAB_00106abc;\n                  if (uint_var_45 != 0) goto LAB_00106700;\nLAB_00106eff:\n                  ptr_char_41 = \"no operation specified\";\n                  goto LAB_00106803;\n                }\n                operation = 2;\n                if (newer_only != 0) goto LAB_0010704f;\n              }\n              else if ((uint_var_45 == 3) || (uint_var_45 == 0)) {\n                if (write_armap == 1) {\n                  uint_var_17 = ranlib_only();\n                    \n                  xexit(uint_var_17);\n                }\nLAB_00106abc:\n                if (uint_var_45 == 0) goto LAB_00106eff;\n                if (newer_only != 0) {\nLAB_00106ad1:\n                  ptr_char_41 = \"`u\\' is only meaningful with the `r\\' option.\";\n                  goto LAB_00106803;\n                }\n              }\n              else {\nLAB_00106700:\n                if (newer_only != 0) goto LAB_00107548;\n              }\nLAB_0010670d:\n              if (deterministic < 0) {\n                deterministic = 1;\n              }\nLAB_00106720:\n              ptr_char_39 = (char *)0x0;\n              if (postype != 0) {\n                posname = *(long *)ptr_undefined_37;\n                ptr_char_39 = (char *)0x1;\n                ptr_char_41 = \"missing position arg.\";\n                if (posname == 0) goto LAB_00106803;\n              }\n              if (counted_name_mode != '\\0') {\n                ptr_char_41 = \"`N\\' is only meaningful with the `x\\' and `d\\' options.\";\n                if ((operation & 0xfffffffb) == 1) {\n                  int_var_15 = (int)ptr_char_39;\n                  if (*(char **)((long)ptr_undefined_37 + (long)int_var_15 * 2 * 4) == (char *)0x0) {\n                    ulong_var_28 = dcgettext(0,\"`N\\' missing value.\",5);\n                    fatal(ulong_var_28);\n                    uint_var_45 = uint_extraout_EDX;\nLAB_00107548:\n                    if (uint_var_45 == 2) {\nLAB_0010704f:\n                      ptr_char_41 = \"`u\\' is not meaningful with the `D\\' option.\";\n                      if (deterministic < 1) goto code_r0x00107068;\n                      goto LAB_00106803;\n                    }\n                    goto LAB_00106ad1;\n                  }\n                  ptr_char_39 = (char *)(ulong)(int_var_15 + 1);\n                  long_var_25 = strtol(*(char **)((long)ptr_undefined_37 + (long)int_var_15 * 2 * 4),(char **)0x0,10);\n                  ptr_char_41 = \"Value for `N\\' must be positive.\";\n                  counted_name_counter = (int)long_var_25;\n                  if (0 < counted_name_counter) goto LAB_0010673c;\n                }\n                goto LAB_00106803;\n              }\nLAB_0010673c:\n              long_var_25 = (long)(int)ptr_char_39;\n              ptr_FILE_23 = (FILE *)ptr_char_39;\n              if (*(long *)(int *)((long)ptr_undefined_37 + long_var_25 * 2 * 4) == 0)\n              goto switchD_00107462_caseD_1;\n              ptr_FILE_23 = (FILE *)((long)ptr_undefined_37 + (long_var_25 + 1) * 2 * 4);\n              if (*(FILE **)ptr_FILE_23 == (FILE *)0x0) {\n                pcVar43 = (char *)0x0;\n                ptr_FILE_23 = (FILE *)0x0;\n              }\n              else if (*(long *)((long)ptr_undefined_37 + (long_var_25 + 2) * 2 * 4) == 0) {\n                pcVar43 = (char *)0x1;\n              }\n              else if (*(long *)((long)ptr_undefined_37 + (long_var_25 + 3) * 2 * 4) == 0) {\n                pcVar43 = (char *)0x2;\n              }\n              else if (*(long *)((long)ptr_undefined_37 + (long_var_25 + 4) * 2 * 4) == 0) {\n                pcVar43 = (char *)0x3;\n              }\n              else if (*(long *)((long)ptr_undefined_37 + (long_var_25 + 5) * 2 * 4) == 0) {\n                pcVar43 = (char *)0x4;\n              }\n              else {\n                ptr_FILE_18 = (FILE *)0x5;\n                do {\n                  pcVar43 = (char *)ptr_FILE_18;\n                  ptr_FILE_18 = (FILE *)((long)(int *)pcVar43 + 1);\n                } while (*(long *)((int *)((long)ptr_undefined_37 + long_var_25 * 2 * 4) + (long)ptr_FILE_18 * 2) != 0\n                        );\n              }\n              ptr_ulonglong_27 = (undefined8 *)open_inarch();\n              ptr_FILE_18 = ptr_FILE_23;\n              if (operation == 5) {\n                ptr_char_41 = \"`x\\' cannot be used on thin archives.\";\n                if ((*(byte *)((long)ptr_ulonglong_27 + 0x49) & 0x10) == 0) {\n                  ptr_char_39 = (char *)ptr_FILE_23;\n                  if (libdeps != (char *)0x0) goto LAB_00106d5c;\nswitchD_00106ed8_caseD_5:\n                  map_over_members(ptr_ulonglong_27,extract_file,ptr_char_39,(ulong)pcVar43 & 0xffffffff);\n                  goto LAB_0010696c;\n                }\n                goto LAB_00106803;\n              }\n              if (libdeps != (char *)0x0) {\nLAB_00106d5c:\n                size_var_19 = strlen(libdeps);\n                ptr_char_47 = \"__.LIBDEP\";\n                ptr_char_39 = (char *)(size_var_19 + 1);\n                libdeps_bfd = bfd_create(\"__.LIBDEP\",ptr_ulonglong_27);\n                if (libdeps_bfd == 0) {\n                  ptr_char_41 = \"Cannot create libdeps record.\";\n                }\n                else {\n                  long_var_25 = bfd_find_target(\"binary\",libdeps_bfd);\n                  ptr_char_41 = \"Cannot set libdeps record type to binary.\";\n                  if (long_var_25 != 0) {\n                    char_var_14 = bfd_set_format(libdeps_bfd,1,5);\n                    ptr_char_41 = \"Cannot set libdeps object format.\";\n                    if (char_var_14 == '\\0') goto LAB_00106803;\n                    char_var_14 = bfd_make_writable(libdeps_bfd,\"Cannot set libdeps object format.\",5);\n                    ptr_char_41 = \"Cannot make libdeps object writable.\";\n                    if (char_var_14 == '\\0') goto LAB_00106803;\n                    ptr_FILE_29 = (FILE *)bfd_bwrite(libdeps,ptr_char_39,libdeps_bfd);\n                    ptr_char_41 = \"Cannot write libdeps record.\";\n                    if (ptr_FILE_29 != (FILE *)ptr_char_39) goto LAB_00106803;\n                    char_var_14 = bfd_make_readable(libdeps_bfd,\"Cannot write libdeps record.\",5);\n                    ptr_char_41 = \"Cannot make libdeps object readable.\";\n                    if (char_var_14 == '\\0') goto LAB_00106803;\n                    long_var_25 = bfd_find_target(\"plugin\",libdeps_bfd,5);\n                    ptr_char_41 = \"Cannot reset libdeps record type.\";\n                    if (long_var_25 == 0) goto LAB_00106803;\n                    int_var_15 = (int)pcVar43;\n                    var_local_130 = (FILE *)((long)(int_var_15 + 2) * 8);\n                    ptr_char_39 = (char *)xmalloc(var_local_130,\"Cannot reset libdeps record type.\");\n                    if (int_var_15 == 0) {\n                      long_var_25 = 0;\n                    }\n                    else {\n                      uint_var_17 = *(undefined4 *)&ptr_FILE_23->field_0x4;\n                      *(int *)ptr_char_39 = ptr_FILE_23->_flags;\n                      *(undefined4 *)((long)ptr_char_39 + 4) = uint_var_17;\n                      long_var_25 = 8;\n                      ptr_of_ptr_char_32 = (char **)((long)ptr_char_39 + 8);\n                      for (pcVar43 = var_local_130[-1]._unused2 + 4; pcVar43 != (char *)0x0;\n                          pcVar43 = pcVar43 + -1) {\n                        *(undefined *)ptr_of_ptr_char_32 = *(undefined *)&ptr_FILE_23->_flags;\n                        ptr_FILE_23 = (FILE *)((long)ptr_FILE_23 + (ulong)byte_flag_49 * -2 + 1);\n                        ptr_of_ptr_char_32 = (char **)((long)ptr_of_ptr_char_32 + (ulong)byte_flag_49 * -2 + 1);\n                      }\n                    }\n                    *(char **)((long)(char **)ptr_char_39 + long_var_25) = \"__.LIBDEP\";\n                    pcVar43 = (char *)(ulong)(int_var_15 + 1);\n                    *(undefined8 *)\n                     (((FILE *)((long)ptr_char_39 + -0xd8))->_unused2 + 0xc + (long)var_local_130) = 0;\n                    switch(operation) {\n                    case 1:\n                      goto switchD_00106ed8_caseD_1;\n                    case 2:\n                    case 7:\n                      break;\n                    case 3:\n                      goto switchD_00106ed8_caseD_3;\n                    case 4:\n                      goto switchD_00106ed8_caseD_4;\n                    case 5:\n                      goto switchD_00106ed8_caseD_5;\n                    case 6:\n                      ptr_FILE_23 = (FILE *)ptr_char_39;\n                      if (silent_create == 0) goto LAB_00106afb;\n                      break;\n                    default:\n                      goto switchD_001067e8_caseD_5;\n                    }\n                    goto switchD_00106ed8_caseD_2;\n                  }\n                }\n                goto LAB_00106803;\n              }\n              switch(operation) {\n              case 1:\n                ptr_char_39 = (char *)ptr_FILE_23;\n                if (ptr_FILE_23 == (FILE *)0x0) break;\nswitchD_00106ed8_caseD_1:\n                ptr_FILE_18 = (FILE *)0x0;\n                goto LAB_00106b89;\n              case 2:\n              case 7:\nswitchD_001067e8_caseD_2:\n                ptr_char_39 = (char *)ptr_FILE_23;\n                if ((ptr_FILE_23 != (FILE *)0x0) || (0 < write_armap)) {\nswitchD_00106ed8_caseD_2:\n                  replace_members(ptr_ulonglong_27,ptr_char_39,operation == 7);\n                  goto LAB_0010696c;\n                }\n                break;\n              case 3:\n                ptr_char_39 = (char *)ptr_FILE_23;\nswitchD_00106ed8_caseD_3:\n                map_over_members(ptr_ulonglong_27,print_descr,ptr_char_39,(ulong)pcVar43 & 0xffffffff);\n                goto LAB_0010696c;\n              case 4:\n                ptr_char_39 = (char *)ptr_FILE_23;\nswitchD_00106ed8_caseD_4:\n                map_over_members(ptr_ulonglong_27,print_contents,ptr_char_39,(ulong)pcVar43 & 0xffffffff);\n                goto LAB_0010696c;\n              default:\nswitchD_001067e8_caseD_5:\n                ptr_char_41 = \"internal error -- this option not implemented\";\n                goto LAB_00106803;\n              case 6:\n                if (silent_create != 0) goto switchD_001067e8_caseD_2;\n                if (ptr_FILE_23 == (FILE *)0x0) break;\nLAB_00106afb:\n                ptr_FILE_18 = (FILE *)(ptr_ulonglong_27 + 0x1e);\n                do {\n                  unaff_R12 = ptr_FILE_18;\n                  if (*(FILE **)ptr_FILE_23 == (FILE *)0x0) {\nLAB_00106b9f:\n                    write_archive(ptr_ulonglong_27);\n                    goto LAB_0010696c;\n                  }\n                  while( true ) {\n                    ptr_long_22 = *(long **)unaff_R12;\n                    ptr_char_47 = *(char **)ptr_FILE_23;\n                    if (ptr_long_22 == (long *)0x0) {\n                      ulong_var_28 = *ptr_ulonglong_27;\n                      ulong_var_31 = dcgettext(0,\"no entry %s in archive %s!\",5);\n                      fatal(ulong_var_31,ptr_char_47,ulong_var_28);\n                      pcVar43 = (char *)0x0;\n                      goto LAB_00107293;\n                    }\n                    long_var_25 = *ptr_long_22;\n                    ulong_var_28 = normalize(ptr_char_47,ptr_ulonglong_27);\n                    int_var_15 = filename_cmp(ulong_var_28,long_var_25);\n                    if (int_var_15 == 0) break;\n                    unaff_R12 = (FILE *)(*(long **)unaff_R12 + 0x1e);\n                  }\n                  *(long **)unaff_R12 = (long *)ptr_long_22[0x1e];\n                  ptr_of_ptr_long_30 = (long **)get_pos_bfd(ptr_FILE_18,3,0);\n                  bool_flag_48 = verbose != 0;\n                  ptr_long_4 = *ptr_of_ptr_long_30;\n                  *ptr_of_ptr_long_30 = ptr_long_22;\n                  ptr_long_22[0x1e] = (long)ptr_long_4;\n                  if (bool_flag_48) {\n                    printf(\"m - %s\\n\",*(FILE **)ptr_FILE_23);\n                  }\n                  ptr_FILE_23 = (FILE *)&ptr_FILE_23->_IO_read_ptr;\n                } while( true );\n              }\n              goto LAB_00106d4e;\n            }\n            if (-1 < deterministic) goto LAB_0010755f;\n          }\n          else {\nLAB_00107591:\n            usage(1);\n          }\n          deterministic = 1;\nLAB_0010755f:\n          int_var_15 = fileno(_stdin);\n          interactive = isatty(int_var_15);\n          yyparse_isra_0();\nLAB_0010696c:\n                    \n          xexit(0);\n        }\n        uint_var_17 = bfd_get_error();\n        ptr_FILE_23 = (FILE *)bfd_errmsg(uint_var_17);\n        ulong_var_28 = dcgettext(0,\"can\\'t set BFD default target to `%s\\': %s\",5);\n        int_var_15 = fatal(ulong_var_28,\"x86_64-pc-linux-gnu\",ptr_FILE_23);\nLAB_0010751b:\n        if (operation == 0) {\nLAB_00107447:\n          ptr_undefined_37 = ptr_char_41;\n          ptr_FILE_29 = (FILE *)ptr_char_47;\n          switch(int_var_15) {\n          case 0:\n            goto switchD_00107462_caseD_0;\n          default:\n            goto switchD_00107462_caseD_1;\n          case 0x44:\n            deterministic = 1;\n            goto LAB_001065a2;\n          case 0x4d:\n            mri_mode = 1;\n            goto LAB_001065a2;\n          case 0x4e:\n            counted_name_mode = '\\x01';\n            goto LAB_001065a2;\n          case 0x4f:\n            display_offsets = 1;\n            goto LAB_001065a2;\n          case 0x50:\n            full_pathname = 1;\n            goto LAB_001065a2;\n          case 0x53:\n            write_armap = -1;\n            goto LAB_001065a2;\n          case 0x54:\n            make_thin_archive = 1;\n            goto LAB_001065a2;\n          case 0x55:\n            deterministic = 0;\n            goto LAB_001065a2;\n          case 0x56:\n            show_version = 1;\n            goto LAB_001065a2;\n          case 0x61:\n            postype = 2;\n            goto LAB_001065a2;\n          case 0x62:\n          case 0x69:\n            postype = 1;\n            goto LAB_001065a2;\n          case 99:\n            silent_create = 1;\n            goto LAB_001065a2;\n          case 100:\n            operation = 1;\n            operation_alters_arch = 1;\n            goto LAB_001065a2;\n          case 0x66:\n            ar_truncate = 1;\n            goto LAB_001065a2;\n          case 0x68:\n            goto switchD_00107462_caseD_68;\n          case 0x6c:\n            if (libdeps == (char *)0x0) {\n              libdeps = _optarg;\n              goto LAB_001065a2;\n            }\nLAB_00107293:\n            uint_var_16 = (uint)unaff_R12;\n            ptr_char_41 = \"libdeps specified more than once\";\n            ptr_char_39 = (char *)ptr_FILE_23;\n            break;\n          case 0x6d:\n            operation = 6;\n            operation_alters_arch = 1;\n            goto LAB_001065a2;\n          case 0x6f:\n            preserve_dates = 1;\n            goto LAB_001065a2;\n          case 0x70:\n            operation = 4;\n            goto LAB_001065a2;\n          case 0x71:\n            operation = 7;\n            operation_alters_arch = 1;\n            goto LAB_001065a2;\n          case 0x72:\n            operation = 2;\n            operation_alters_arch = 1;\n            goto LAB_001065a2;\n          case 0x73:\n            write_armap = 1;\n            goto LAB_001065a2;\n          case 0x74:\n            operation = 3;\n            goto LAB_001065a2;\n          case 0x75:\n            newer_only = 1;\n            goto LAB_001065a2;\n          case 0x76:\n            verbose = 1;\n            goto LAB_001065a2;\n          case 0x78:\n            operation = 5;\n            goto LAB_001065a2;\n          case 0xc9:\n            bfd_plugin_set_plugin(_optarg);\n            goto LAB_001065a2;\n          case 0xca:\n            target = _optarg;\n            goto LAB_001065a2;\n          case 0xcb:\n            output_dir = _optarg;\n            goto LAB_001065a2;\n          }\n          goto LAB_00106803;\n        }\nLAB_001067f7:\n        ptr_char_41 = \"two different operation options specified\";\n        ptr_char_39 = (char *)ptr_FILE_23;\nLAB_00106803:\n        ulong_var_28 = dcgettext(0,ptr_char_41,5);\n        fatal(ulong_var_28);\nLAB_00106814:\n        int_var_15 = (int)ptr_char_47;\n        ptr_FILE_29 = (FILE *)xmalloc(8);\n        *(long **)ptr_FILE_29 = (long *)0x0;\n        if ((FILE *)pcVar43 == input_file) {\nLAB_00106834:\n          if (*(long **)pcVar43 == (long *)0x0) {\n            int_var_15 = 0;\n          }\n          else {\n            long_var_25 = 1;\n            do {\n              int_var_15 = (int)long_var_25;\n              long_var_36 = long_var_25 * 2;\n              long_var_25 = long_var_25 + 1;\n            } while (*(long *)((int *)pcVar43 + long_var_36) != 0);\n          }\n          ptr_FILE_23 = (FILE *)xmalloc((long)(int_var_15 + 1) << 3);\n          ptr_long_22 = *(long **)pcVar43;\n          long_var_25 = 0;\n          while (ptr_long_22 != (long *)0x0) {\n            ulong_var_28 = xstrdup();\n            *(undefined8 *)((long)&ptr_FILE_23->_flags + long_var_25) = ulong_var_28;\n            ptr_long_22 = *(long **)((char *)((long)pcVar43 + 0x83) + long_var_25 + -0x7b);\n            long_var_25 = long_var_25 + 8;\n          }\n          *(undefined8 *)((long)&ptr_FILE_23->_flags + long_var_25) = 0;\nLAB_0010610a:\n          int_var_15 = (int)ptr_char_47;\n          pcVar43 = (char *)ptr_FILE_23;\n          if (*(long **)ptr_FILE_29 == (long *)0x0) goto LAB_00106a80;\n          long_var_25 = 0;\n          do {\n            long_var_35 = long_var_25 + 1;\n            long_var_36 = long_var_25 * 8;\n            long_var_25 = long_var_35;\n          } while (*(long *)(ptr_FILE_29->_shortbuf + long_var_36 + -0x7b) != 0);\n          var_local_108 = long_var_35 * 8;\n        }\n        else {\nLAB_00106a80:\n          long_var_35 = 0;\n          var_local_108 = 0;\n        }\n        long_var_25 = (long)ptr_char_39 * 2;\n        ptr_char_39 = (char *)((long)(char **)ptr_char_39 + long_var_35);\n        free(*(void **)((int *)pcVar43 + long_var_25));\n        ptr_FILE_23 = (FILE *)xrealloc(pcVar43,(long_var_35 + 1 + (long)int_var_15) * 8);\n        uint_var_45 = int_var_15 + -1 + (int)long_var_35;\n        ptr_char_47 = (char *)(ulong)uint_var_45;\n        memmove(&ptr_FILE_23->_flags + (long)ptr_char_39 * 2,\n                (void *)((long)&ptr_FILE_23->_IO_read_ptr + (long)var_local_130),\n                (long)(int)(int_var_15 - uint_var_16) << 3);\n        memcpy((void *)((long)&var_local_130->_flags + (long)&ptr_FILE_23->_flags),ptr_FILE_29,var_local_108);\n        free(ptr_FILE_29);\n        free(var_local_118);\n        fclose(ptr_FILE_18);\n        uint_var_16 = (int)var_local_128 + 1;\n        unaff_R12 = var_local_130;\n        pcVar43 = (char *)ptr_FILE_23;\n        var_local_130 = ptr_FILE_29;\n        if ((int)uint_var_16 < (int)uint_var_45) goto LAB_001061ce;\n      } while( true );\n    }\n    uint_var_16 = uint_var_16 + 1;\n    var_local_128 = unaff_R12;\nLAB_001061ce:\n    unaff_R12 = (FILE *)(ulong)uint_var_16;\n  } while( true );\nswitchD_00107462_caseD_0:\n  int_var_15 = getopt_long((ulong)ptr_FILE_18 & 0xffffffff,ptr_char_47,ptr_FILE_23,\"x86_64-pc-linux-gnu\");\n  ptr_char_39 = (char *)ptr_FILE_23;\n  if (int_var_15 == -1) goto LAB_00106680;\n  if ((0x14 < int_var_15 - 100U) || ((0x117201UL >> ((byte)(int_var_15 - 100U) & 0x3f) & 1) == 0))\n  goto LAB_00107447;\n  goto LAB_0010751b;\ncode_r0x00107068:\n  if (deterministic != 0) goto code_r0x0010706e;\n  goto LAB_00106720;\ncode_r0x0010706e:\n  ulong_var_28 = dcgettext(0,\"`u\\' modifier ignored since `D\\' is the default (see `U\\')\",5);\n  non_fatal(ulong_var_28);\n  goto LAB_0010670d;\nLAB_00106b89:\n  if (*(FILE **)ptr_char_39 == (FILE *)0x0) {\n    if ((char)ptr_FILE_18 != '\\0') goto LAB_00106b9f;\nLAB_00106d4e:\n    output_filename = 0;\n    goto LAB_0010696c;\n  }\n  int_var_46 = 0;\n  int_var_15 = strcmp((char *)*(FILE **)ptr_char_39,\"__.SYMDEF\");\n  ptr_ulonglong_5 = ptr_ulonglong_27;\n  if (int_var_15 == 0) {\n    *(byte *)((long)ptr_ulonglong_27 + 0x49) = *(byte *)((long)ptr_ulonglong_27 + 0x49) & 0xf7;\n    write_armap = -1;\n  }\n  else {\n    while( true ) {\n      ptr_long_22 = ptr_ulonglong_5 + 0x1e;\n      if ((undefined8 *)*ptr_long_22 == (undefined8 *)0x0) break;\n      ulong_var_28 = *(undefined8 *)*ptr_long_22;\n      ulong_var_31 = normalize(*(FILE **)ptr_char_39,ptr_ulonglong_27);\n      int_var_15 = filename_cmp(ulong_var_31,ulong_var_28);\n      if ((int_var_15 == 0) &&\n         ((counted_name_mode == '\\0' || (int_var_46 = int_var_46 + 1, int_var_46 == counted_name_counter)))) {\n        if (verbose != 0) {\n          printf(\"d - %s\\n\",*(FILE **)ptr_char_39);\n        }\n        *ptr_long_22 = *(long *)(*ptr_long_22 + 0xf0);\n        ptr_FILE_18 = unaff_R12;\n        goto LAB_00106d38;\n      }\n      ptr_ulonglong_5 = (undefined8 *)*ptr_long_22;\n    }\n    if (verbose != 0) {\n      ptr_FILE_23 = *(FILE **)ptr_char_39;\n      ptr_char_47 = (char *)dcgettext(0,\"No member named `%s\\'\\n\",5);\n      printf(ptr_char_47,ptr_FILE_23);\n    }\n  }\nLAB_00106d38:\n  ptr_char_39 = (char *)((long)ptr_char_39 + 8);\n  goto LAB_00106b89;\n}\n\n",
            "called": [
                "open_inarch",
                "bfd_fatal",
                "fprintf",
                "strtol",
                "fread",
                "fclose",
                "bfd_plugin_set_program_name",
                "bfd_errmsg",
                "bfd_plugin_set_plugin",
                "bfd_nonfatal",
                "dcgettext",
                "non_fatal",
                "strcmp",
                "fatal",
                "xmalloc",
                "memmove",
                "write_archive",
                "bindtextdomain",
                "normalize",
                "setlocale",
                "replace_members",
                "printf",
                "ranlib_usage",
                "bfd_close",
                "fopen",
                "bfd_set_format",
                "print_contents",
                "bfd_make_writable",
                "ar_emul_default_parse_arg",
                "bfd_check_format_matches",
                "memcpy",
                "bfd_find_target",
                "bfd_set_error_program_name",
                "bfd_get_error",
                "print_version",
                "open",
                "bfd_set_error",
                "free",
                "bfd_init",
                "xstrdup",
                "ranlib_only",
                "getopt_long",
                "ferror",
                "map_over_members",
                "get_file_size",
                "fileno",
                "bfd_create",
                "stat",
                "strlen",
                "filename_cmp",
                "bfd_set_default_target",
                "bfd_bwrite",
                "bfd_make_readable",
                "usage",
                "xexit",
                "bfd_fdopenr",
                "ftell",
                "textdomain",
                "fseek",
                "remove_output",
                "yyparse.isra.0",
                "xmalloc_set_program_name",
                "print_descr",
                "get_pos_bfd",
                "list_matching_formats",
                "extract_file",
                "xrealloc",
                "xatexit_cleanup",
                "isatty",
                "malloc",
                "lbasename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105db0",
            "calling": [
                "_start"
            ],
            "imported": false,
            "current_name": "decompile_and_improve_00105db0"
        },
        "FUN_00102150": {
            "renaming": {},
            "code": "\n\n\nchar * ctime(time_t *__timer)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = ctime(__timer);\n  return pcVar1;\n}\n\n",
            "called": [
                "ctime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102150",
            "calling": [
                "print_arelt_descr"
            ],
            "imported": false,
            "current_name": "FUN_00102150"
        },
        "FUN_00102270": {
            "renaming": {},
            "code": "\nvoid xstrdup(void)\n\n{\n  xstrdup();\n  return;\n}\n\n",
            "called": [
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102270",
            "calling": [
                "ar_open",
                "write_archive",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102270"
        },
        "FUN_00103bd1": {
            "renaming": {
                "FUN_00103bd1": "print_matching_formats_00103bd1",
                "param_1": "formatList",
                "uVar1": "programName",
                "__format": "formatString",
                "plVar2": "currentFormat",
                "_stdout": "stdoutStream",
                "_stderr": "stderrStream"
            },
            "code": "\n\n\nvoid printMatchingFormats_00103bd1(long *formatList)\n\n{\n  undefined8 programName;\n  char *formatString;\n  long *currentFormat;\n  \n  fflush(stdoutStream);\n  programName = program_name;\n  formatString = (char *)dcgettext(0,\"%s: Matching formats:\",5);\n  fprintf(stderrStream,formatString,programName);\n  for (currentFormat = formatList; *currentFormat != 0; currentFormat = currentFormat + 1) {\n    fprintf(stderrStream,\" %s\");\n  }\n  free(formatList);\n  fputc(10,stderrStream);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fflush",
                "fputc",
                "free",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103bd1",
            "calling": [
                "open_inarch",
                "main"
            ],
            "imported": false,
            "current_name": "print_matching_formats_00103bd1"
        },
        "FUN_00102030": {
            "renaming": {},
            "code": "\n\n\nvoid free(void *__ptr)\n\n{\n  free(__ptr);\n  return;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102030",
            "calling": [
                "list_matching_formats",
                "print_contents",
                "list_supported_targets",
                "extract_file.cold",
                "write_archive.cold",
                "main",
                "make_tempname.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102030"
        },
        "FUN_00102710": {
            "renaming": {
                "FUN_00102710": "extract_formats_from_binary_00102710",
                "plVar1": "archived_file_ptr",
                "cVar2": "format_check_result",
                "bVar3": "is_thin_archive",
                "iVar4": "error_code",
                "lVar5": "file_descriptor",
                "uVar6": "error_message",
                "uVar7": "library_name",
                "puVar8": "output_file_descriptor",
                "unaff_RBP": "output_filename",
                "in_stack_00000008": "matching_formats",
                "target": "extracted_target"
            },
            "code": "\nundefined8 * extract_formats_from_binary_00102710(void)\n\n{\n  long *archived_file_ptr;\n  char format_check_result;\n  byte is_thin_archive;\n  int error_code;\n  long file_descriptor;\n  undefined8 error_message;\n  undefined8 library_name;\n  undefined8 *output_file_descriptor;\n  undefined8 output_filename;\n  undefined8 matching_formats;\n  \n  file_descriptor = bfd_openr();\n  if (file_descriptor != 0) {\n    format_check_result = bfd_check_format(file_descriptor,1);\n    if (format_check_result != '\\0') {\n      extracted_target = **(undefined8 **)(file_descriptor + 8);\n    }\n    bfd_close(file_descriptor);\n  }\n  output_file_descriptor = (undefined8 *)bfd_openw();\n  if (((output_file_descriptor != (undefined8 *)0x0) && (format_check_result = bfd_set_format(output_file_descriptor,2), format_check_result != '\\0')) &&\n     (format_check_result = bfd_close(output_file_descriptor), format_check_result != '\\0')) {\n    if (silent_create == 0) goto LAB_00102826;\n    goto LAB_001053b7;\n  }\n  bfd_fatal();\n  do {\n    is_thin_archive = *(byte *)((long)output_file_descriptor + 0x49) >> 4 & 1;\n    if (make_thin_archive == '\\0') {\n      if (is_thin_archive != 0) {\n        library_name = *output_file_descriptor;\n        error_message = dcgettext(0,\"Cannot convert existing thin library %s to normal format\",5);\n        fatal(error_message,library_name);\n        goto LAB_00102812;\n      }\n    }\n    else if (is_thin_archive == 0) {\n      library_name = *output_file_descriptor;\n      error_message = dcgettext(0,\"Cannot convert existing library %s to thin format\",5);\n      fatal(error_message,library_name);\nLAB_001027cb:\n      bfd_nonfatal();\n      error_code = bfd_get_error();\n      if (error_code == 0xd) {\nLAB_00102812:\n        list_matching_formats(matching_formats);\n      }\n                    \n      xexit(1);\n    }\n    do {\n      archived_file_ptr = output_file_descriptor + 0x1e;\n      for (file_descriptor = bfd_openr_next_archived_file(output_file_descriptor,0); file_descriptor != 0;\n          file_descriptor = bfd_openr_next_archived_file(output_file_descriptor,file_descriptor)) {\n        *archived_file_ptr = file_descriptor;\n        archived_file_ptr = (long *)(file_descriptor + 0xf0);\n      }\n      *archived_file_ptr = 0;\n      error_code = bfd_get_error();\n      if (error_code == 9) {\n        return output_file_descriptor;\n      }\n      do {\n        bfd_fatal();\nLAB_00102826:\n        library_name = dcgettext(0,\"creating %s\",5);\n        non_fatal(library_name);\nLAB_001053b7:\n        output_filename = output_filename;\n        output_file_descriptor = (undefined8 *)bfd_openr();\n      } while (output_file_descriptor == (undefined8 *)0x0);\n      format_check_result = bfd_check_format_matches(output_file_descriptor,2,&stack0x00000008);\n      if (format_check_result == '\\0') goto LAB_001027cb;\n    } while (((operation != 2) && (operation != 7)) ||\n            (file_descriptor = bfd_openr_next_archived_file(output_file_descriptor,0), file_descriptor == 0));\n  } while( true );\n}\n\n",
            "called": [
                "bfd_check_format",
                "bfd_close",
                "bfd_openr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102710",
            "calling": [
                "open_inarch"
            ],
            "imported": false,
            "current_name": "extract_formats_from_binary_00102710"
        },
        "FUN_0010e2b0": {
            "renaming": {},
            "code": "\n\n\n\nvoid exit(int __status)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* exit@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e2b0",
            "calling": [
                "exit"
            ],
            "imported": false,
            "current_name": "FUN_0010e2b0"
        },
        "FUN_0010e208": {
            "renaming": {},
            "code": "\n\n\n\nint fflush(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fflush@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e208",
            "calling": [
                "fflush"
            ],
            "imported": false,
            "current_name": "FUN_0010e208"
        },
        "FUN_00103e95": {
            "renaming": {
                "FUN_00103e95": "extract_and_parse_00103e95",
                "pplVar1": "pointerToPointerToFile",
                "cVar2": "tempChar",
                "ppFVar3": "pointerToPointerToFile",
                "pFVar4": "pointerToFile",
                "plVar5": "pointerToFile",
                "uVar6": "tempUnsignedVar",
                "pbVar7": "pointerToByte",
                "iVar8": "tempInt",
                "pcVar10": "pointerToChar",
                "uVar11": "tempUnsignedVar",
                "iVar9": "tempInt",
                "plVar12": "pointerToFile",
                "sVar13": "tempSize",
                "pvVar14": "pointerToVoid",
                "pcVar15": "pointerToChar",
                "pcVar16": "pointerToChar",
                "lVar17": "tempLong",
                "lVar18": "tempLong",
                "uVar19": "tempUnsignedVar",
                "uVar20": "tempUnsignedVar",
                "lVar21": "tempLong",
                "puVar22": "pointerToUnsignedVar",
                "puVar23": "pointerToUnsignedVar",
                "uVar24": "tempUnsignedVar",
                "iVar25": "tempInt",
                "uVar26": "tempUnsignedVar",
                "ppcVar27": "pointerToPointerToChar",
                "bVar28": "tempByte",
                "ppcVar29": "pointerToPointerToChar",
                "bVar30": "tempByte",
                "lVar31": "tempLong",
                "pbVar32": "pointerToByte",
                "pbVar33": "pointerToByte",
                "piVar34": "pointerToInt",
                "pbVar35": "pointerToByte",
                "uVar36": "tempUnsignedVar",
                "iVar37": "tempInt",
                "ppcVar38": "pointerToPointerToChar",
                "bVar39": "tempByte"
            },
            "code": "\n\n\nvoid extractAndParse_00103e95(void)\n\n{\n  long **pointerToPointerToFile;\n  char tempChar;\n  FILE **pointerToPointerToFile;\n  FILE *pointerToFile;\n  long *pointerToFile;\n  undefined8 tempUnsignedVar;\n  byte *pointerToByte;\n  int tempInt;\n  char *pointerToChar;\n  undefined8 tempUnsignedVar;\n  int tempInt;\n  long *pointerToFile;\n  size_t tempSize;\n  void *pointerToVoid;\n  char *pointerToChar;\n  char *pointerToChar;\n  long tempLong;\n  long tempLong;\n  ulong tempUnsignedVar;\n  uint tempUnsignedVar;\n  long tempLong;\n  undefined8 *pointerToUnsignedVar;\n  undefined8 *pointerToUnsignedVar;\n  uint tempUnsignedVar;\n  int tempInt;\n  ulong tempUnsignedVar;\n  char **pointerToPointerToChar;\n  bool tempByte;\n  char **pointerToPointerToChar;\n  byte tempByte;\n  long tempLong;\n  byte *pointerToByte;\n  byte *pointerToByte;\n  int *pointerToInt;\n  byte *pointerToByte;\n  uint tempUnsignedVar;\n  int tempInt;\n  char **pointerToPointerToChar;\n  byte tempByte;\n  undefined auVar40 [16];\n  undefined auVar41 [16];\n  char *local_828;\n  char *local_820;\n  long local_818;\n  char **local_810;\n  int local_800;\n  uint local_7fc;\n  byte *local_7f8;\n  stat local_7d0;\n  char local_740 [200];\n  char *local_678 [201];\n  \n  tempByte = 0;\n  tempLong = 0;\n  yychar = -2;\n  pointerToPointerToChar = local_678;\n  local_800 = 0;\n  local_828 = local_740;\n  local_818 = 200;\n  local_820 = local_828;\n  local_810 = pointerToPointerToChar;\nLAB_00103ee9:\n  *local_828 = (char)tempLong;\n  if (local_820 + local_818 + -1 <= local_828) {\n    tempLong = (long)local_828 - (long)local_820;\n    tempLong = tempLong + 1;\n    if (local_818 < 10000) {\n      tempLong = local_818 * 2;\n      local_818 = 10000;\n      if (tempLong < 0x2711) {\n        local_818 = tempLong;\n      }\n      pointerToChar = (char *)malloc(local_818 * 9 + 7);\n      if (pointerToChar != (char *)0x0) {\n        tempLong = tempLong * 8;\n        pointerToChar = local_820;\n        pointerToChar = pointerToChar;\n        for (; tempLong != 0; tempLong = tempLong + -1) {\n          *pointerToChar = *pointerToChar;\n          pointerToChar = pointerToChar + (ulong)tempByte * -2 + 1;\n          pointerToChar = pointerToChar + (ulong)tempByte * -2 + 1;\n        }\n        pointerToPointerToChar = (char **)(pointerToChar + local_818);\n        pointerToPointerToChar = pointerToPointerToChar;\n        for (; tempLong != 0; tempLong = tempLong + -1) {\n          *(undefined *)pointerToPointerToChar = *(undefined *)local_810;\n          local_810 = (char **)((long)local_810 + (ulong)tempByte * -2 + 1);\n          pointerToPointerToChar = (char **)((long)pointerToPointerToChar + (ulong)tempByte * -2 + 1);\n        }\n        if (local_820 != local_740) {\n          free(local_820);\n        }\n        local_828 = pointerToChar + tempLong;\n        pointerToPointerToChar = pointerToPointerToChar + tempLong;\n        local_820 = pointerToChar;\n        local_810 = pointerToPointerToChar;\n        if (pointerToChar + local_818 + -1 <= local_828) goto LAB_00105265;\n        goto LAB_00103fd8;\n      }\n    }\n    yyerror_constprop_0();\nLAB_0010524c:\n    pointerToChar = local_820;\n    if (local_820 == local_740) {\n      return;\n    }\nLAB_00105265:\n    free(pointerToChar);\n    return;\n  }\nLAB_00103fd8:\n  tempInt = (int)tempLong;\n  if (tempInt == 3) goto LAB_0010524c;\n  tempChar = (&yypact)[tempInt];\n  if (tempChar != -0xe) {\n    if (yychar == -2) {\n      if (yy_init == 0) {\n        yy_init = 1;\n        if (yy_start == 0) {\n          yy_start = 1;\n        }\n        if (yyin == (FILE *)0x0) {\n          yyin = _stdin;\n        }\n        if (yyout == (FILE *)0x0) {\n          yyout = _stdout;\n        }\n        if ((yy_buffer_stack == 0) || (*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) == 0)) {\n          yyensure_buffer_stack();\n          pointerToUnsignedVar = (undefined8 *)(yy_buffer_stack + yy_buffer_stack_top * 8);\n          tempUnsignedVar = yy_create_buffer_constprop_0(yyin);\n          *pointerToUnsignedVar = tempUnsignedVar;\n        }\n        yy_load_buffer_state();\n      }\nLAB_001040b1:\n      *yy_c_buf_p = yy_hold_char;\n      pointerToByte = yy_c_buf_p;\n      pointerToByte = yy_c_buf_p;\n      tempUnsignedVar = yy_start;\nLAB_001040d4:\n      tempUnsignedVar = (ulong)tempUnsignedVar;\n      tempUnsignedVar = (ulong)local_7fc;\n      tempByte = false;\n      do {\n        tempByte = yy_ec[*pointerToByte];\n        if (*(short *)(yy_accept + (long)(int)tempUnsignedVar * 2) != 0) {\n          tempByte = true;\n          tempUnsignedVar = tempUnsignedVar & 0xffffffff;\n          local_7f8 = pointerToByte;\n        }\n        while( true ) {\n          tempInt = (int)tempUnsignedVar;\n          tempLong = (long)(int)((int)*(short *)(yy_base + (long)tempInt * 2) + (uint)tempByte);\n          if (tempInt == *(short *)(yy_chk + tempLong * 2)) break;\n          tempUnsignedVar = (ulong)(uint)(int)*(short *)(yy_def + (long)tempInt * 2);\n          if (0xb0 < *(short *)(yy_def + (long)tempInt * 2)) {\n            tempByte = yy_meta[(int)(uint)tempByte];\n          }\n        }\n        pointerToByte = pointerToByte + 1;\n        tempUnsignedVar = (ulong)*(short *)(yy_nxt + tempLong * 2);\n      } while (*(short *)(yy_base + tempUnsignedVar * 2) != 0xc2);\n      local_7fc = (uint)tempUnsignedVar;\n      pointerToByte = pointerToByte;\n      if (tempByte) {\n        yy_last_accepting_cpos = local_7f8;\n        yy_last_accepting_state = local_7fc;\n      }\nLAB_0010419f:\n      tempInt = (int)*(short *)(yy_accept + (long)(int)tempUnsignedVar * 2);\n      if (tempInt == 0) {\n        tempInt = (int)*(short *)(yy_accept + (long)(int)yy_last_accepting_state * 2);\n        pointerToByte = yy_last_accepting_cpos;\n      }\n      yyleng = (int)pointerToByte - (int)pointerToByte;\n      yy_hold_char = *pointerToByte;\n      yy_c_buf_p = pointerToByte;\n      yytext = pointerToByte;\n      *pointerToByte = 0;\nLAB_001041f0:\n      pointerToByte = yytext;\n      tempLong = yy_buffer_stack_top;\n      switch(tempInt) {\n      case 0:\n        goto switchD_00104200_caseD_0;\n      case 1:\n      case 0x10:\n        yychar = 0x105;\n        break;\n      case 2:\n      case 0x11:\n        yychar = 0x107;\n        break;\n      case 3:\n      case 0x12:\n        yychar = 0x108;\n        break;\n      case 4:\n      case 0x13:\n        yychar = 0x109;\n        break;\n      case 5:\n      case 0x14:\n        yychar = 0x10a;\n        break;\n      case 6:\n      case 0x15:\n        yychar = 0x10b;\n        break;\n      case 7:\n      case 0x16:\n        yychar = 0x10c;\n        break;\n      case 8:\n      case 0x17:\n        yychar = 0x10d;\n        break;\n      case 9:\n      case 0x18:\n        yychar = 0x10e;\n        break;\n      case 10:\n      case 0x19:\n        yychar = 0x10f;\n        break;\n      case 0xb:\n      case 0x1a:\n        yychar = 0x106;\n        break;\n      case 0xc:\n      case 0x1b:\n        yychar = 0x113;\n        break;\n      case 0xd:\n      case 0x1c:\n        yychar = 0x111;\n        break;\n      case 0xe:\n      case 0x1d:\n        yychar = 0x103;\n        break;\n      case 0x1f:\n        linenumber = linenumber + 1;\n        goto LAB_001040b1;\n      case 0x20:\n        yychar = 0x28;\n        break;\n      case 0x21:\n        yychar = 0x29;\n        break;\n      case 0x22:\n        yychar = 0x2c;\n        break;\n      case 0x23:\n        yylval = (char *)xstrdup(yytext);\n        yychar = 0x104;\n        break;\n      case 0x24:\n      case 0x25:\n      case 0x26:\n        goto LAB_001040b1;\n      case 0x27:\n        linenumber = linenumber + 1;\n        yychar = 0x102;\n        break;\n      case 0x28:\n        fwrite(yytext,(long)yyleng,1,yyout);\n        goto LAB_001040b1;\n      case 0x29:\n        goto switchD_00104200_caseD_29;\n      case 0x2a:\n        yychar = 0;\n        break;\n      default:\n        yy_fatal_error(\"fatal flex scanner internal error--no action found\");\n      case 0xf:\n      case 0x1e:\n        yychar = 0x112;\n      }\n      tempLong = (long)tempInt;\n    }\n    if (0 < yychar) {\n      if (yychar != 0x100) {\n        tempInt = 2;\n        if (yychar < 0x114) {\n          tempInt = (int)(char)yytranslate[yychar];\n        }\n        goto LAB_0010497d;\n      }\n      yychar = 0x101;\n      goto LAB_001051f0;\n    }\n    tempInt = 0;\n    yychar = 0;\nLAB_0010497d:\n    tempUnsignedVar = tempChar + tempInt;\n    if ((0x22 < tempUnsignedVar) || (tempInt != (char)yycheck[(int)tempUnsignedVar])) goto LAB_001049db;\n    tempChar = yytable[(int)tempUnsignedVar];\n    tempLong = (long)tempChar;\n    if (tempChar < '\\x01') {\n      tempInt = -(int)tempChar;\n      goto LAB_00104a0a;\n    }\n    yychar = -2;\n    local_800 = local_800 + -1 + (uint)(local_800 == 0);\n    pointerToPointerToChar = pointerToPointerToChar + 1;\n    *pointerToPointerToChar = yylval;\n    goto LAB_001049d1;\n  }\nLAB_001049db:\n  tempInt = (int)(char)(&yydefact)[(int)tempLong];\n  if ((&yydefact)[(int)tempLong] == '\\0') {\n    if (local_800 == 0) {\n      yynerrs = yynerrs + 1;\n      yyerror_constprop_0();\nLAB_001051f0:\n      do {\n        if (((((char)(&yypact)[tempLong] != -0xe) &&\n             (tempUnsignedVar = (int)(char)(&yypact)[tempLong] + 1, tempUnsignedVar < 0x23)) &&\n            (yycheck[(int)tempUnsignedVar] == '\\x01')) &&\n           (tempLong = (long)(char)yytable[(int)tempUnsignedVar], '\\0' < (char)yytable[(int)tempUnsignedVar]))\n        goto LAB_00105227;\n        if (local_820 == local_828) goto LAB_0010524c;\n        local_828 = local_828 + -1;\n        pointerToPointerToChar = pointerToPointerToChar + -1;\n        tempLong = (long)*local_828;\n      } while( true );\n    }\n    if (local_800 != 3) goto LAB_001051f0;\n    if (0 < yychar) {\n      yychar = -2;\n      goto LAB_001051f0;\n    }\n    if (yychar != 0) goto LAB_001051f0;\n    goto LAB_0010524c;\n  }\nLAB_00104a0a:\n  tempUnsignedVar = program_name;\n  pointerToPointerToChar = obfd;\n  tempChar = yyr2[tempInt];\n  pointerToPointerToChar = (char **)pointerToPointerToChar[1 - tempChar];\n  switch(tempInt) {\n  case 2:\n  case 6:\n    prompt();\n    break;\n  case 0x13:\n    if (obfd == (char **)0x0) {\n      return;\n    }\n    bfd_cache_close();\n    unlink(*obfd);\n    return;\n  case 0x15:\n    yyerror_constprop_0();\n    break;\n  case 0x17:\n    pointerToUnsignedVar = (undefined8 *)*pointerToPointerToChar;\n    if (obfd == (char **)0x0) {\n      pointerToChar = \"%s: no open archive\\n\";\nLAB_00104b62:\n      pointerToChar = (char *)dcgettext(0,pointerToChar,5);\n      fprintf(_stderr,pointerToChar,tempUnsignedVar);\n      maybequit();\n    }\n    else {\n      for (; pointerToUnsignedVar != (undefined8 *)0x0; pointerToUnsignedVar = (undefined8 *)pointerToUnsignedVar[1]) {\n        for (pointerToUnsignedVar = (undefined8 *)obfd[0x1f]; pointerToUnsignedVar != (undefined8 *)0x0;\n            pointerToUnsignedVar = (undefined8 *)pointerToUnsignedVar[0x1e]) {\n          tempInt = filename_cmp(*pointerToUnsignedVar);\n          if (tempInt == 0) {\n            extract_file();\n            goto LAB_00104adf;\n          }\n        }\n        bfd_openr(*pointerToUnsignedVar,0);\n        tempUnsignedVar = program_name;\n        tempUnsignedVar = *pointerToUnsignedVar;\n        pointerToChar = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,pointerToChar,tempUnsignedVar,tempUnsignedVar);\nLAB_00104adf:\n      }\n    }\n    break;\n  case 0x18:\n    pointerToUnsignedVar = (undefined8 *)*pointerToPointerToChar;\n    if (obfd == (char **)0x0) {\nLAB_00104b4f:\n      pointerToChar = \"%s: no open output archive\\n\";\n      goto LAB_00104b62;\n    }\n    for (; pointerToUnsignedVar != (undefined8 *)0x0; pointerToUnsignedVar = (undefined8 *)pointerToUnsignedVar[1]) {\n      tempByte = false;\n      pointerToPointerToChar = obfd + 0x1f;\n      for (pointerToChar = obfd[0x1f]; pointerToChar != (char *)0x0; pointerToChar = *(char **)(pointerToChar + 0xf0)) {\n        tempInt = filename_cmp();\n        if (tempInt == 0) {\n          pointerToChar = (char *)bfd_openr(*pointerToUnsignedVar,0);\n          tempUnsignedVar = program_name;\n          if (pointerToChar == (char *)0x0) {\n            tempUnsignedVar = *pointerToUnsignedVar;\n            pointerToChar = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n            fprintf(_stderr,pointerToChar,tempUnsignedVar,tempUnsignedVar);\n            maybequit();\n          }\n          else {\n            *pointerToPointerToChar = pointerToChar;\n            tempByte = true;\n            *(undefined8 *)(pointerToChar + 0xf0) = *(undefined8 *)(pointerToChar + 0xf0);\n          }\n        }\n        else {\n          pointerToPointerToChar = (char **)(pointerToChar + 0xf0);\n        }\n      }\n      if (!tempByte) {\n        pointerToChar = (char *)bfd_openr(*pointerToUnsignedVar,0);\n        tempUnsignedVar = program_name;\n        tempUnsignedVar = *pointerToUnsignedVar;\n        pointerToChar = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,pointerToChar,tempUnsignedVar,tempUnsignedVar);\n        tempUnsignedVar = program_name;\n        if (pointerToChar == (char *)0x0) {\n          tempUnsignedVar = *pointerToUnsignedVar;\n          pointerToChar = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n          fprintf(_stderr,pointerToChar,tempUnsignedVar,tempUnsignedVar);\n          maybequit();\n        }\n        else {\n          *pointerToPointerToChar = pointerToChar;\n        }\n      }\n    }\n    break;\n  case 0x19:\n    if (obfd != (char **)0x0) {\n      obfd[0x1f] = (char *)0x0;\n    }\n    break;\n  case 0x1a:\n    pointerToUnsignedVar = (undefined8 *)*pointerToPointerToChar;\n    if (obfd == (char **)0x0) goto LAB_00104b4f;\n    for (; pointerToUnsignedVar != (undefined8 *)0x0; pointerToUnsignedVar = (undefined8 *)pointerToUnsignedVar[1]) {\n      tempByte = false;\n      pointerToPointerToChar = obfd + 0x1f;\n      for (pointerToUnsignedVar = (undefined8 *)obfd[0x1f]; tempUnsignedVar = program_name, pointerToUnsignedVar != (undefined8 *)0x0;\n          pointerToUnsignedVar = (undefined8 *)pointerToUnsignedVar[0x1e]) {\n        tempInt = filename_cmp(*pointerToUnsignedVar,*pointerToUnsignedVar);\n        if (tempInt == 0) {\n          tempByte = true;\n          *pointerToPointerToChar = (char *)pointerToUnsignedVar[0x1e];\n        }\n        else {\n          pointerToPointerToChar = (char **)(pointerToUnsignedVar + 0x1e);\n        }\n      }\n      if (!tempByte) {\n        tempUnsignedVar = *pointerToUnsignedVar;\n        pointerToChar = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,pointerToChar,tempUnsignedVar,tempUnsignedVar);\n        maybequit();\n      }\n    }\n    break;\n  case 0x1b:\n    pointerToUnsignedVar = (undefined8 *)*pointerToPointerToChar;\n    if (obfd == (char **)0x0) goto LAB_00104b4f;\n    for (; pointerToUnsignedVar != (undefined8 *)0x0; pointerToUnsignedVar = (undefined8 *)pointerToUnsignedVar[1]) {\n      pointerToChar = (char *)bfd_openr(*pointerToUnsignedVar,\"plugin\");\n      tempUnsignedVar = program_name;\n      pointerToPointerToChar = obfd;\n      if (pointerToChar == (char *)0x0) {\n        tempUnsignedVar = *pointerToUnsignedVar;\n        pointerToChar = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n        fprintf(_stderr,pointerToChar,tempUnsignedVar,tempUnsignedVar);\n        maybequit();\n      }\n      else {\n        *(char **)(pointerToChar + 0xf0) = obfd[0x1f];\n        pointerToPointerToChar[0x1f] = pointerToChar;\n      }\n    }\n    break;\n  case 0x1c:\n    if (obfd == (char **)0x0) goto LAB_00104b4f;\n    pointerToChar = *obfd;\n    verbose = 1;\n    outfile = _stdout;\n    pointerToChar = (char *)dcgettext(0,\"Current open archive is %s\\n\",5);\n    printf(pointerToChar,pointerToChar);\n    for (pointerToChar = obfd[0x1f]; pointerToChar != (char *)0x0; pointerToChar = *(char **)(pointerToChar + 0xf0)) {\n      ar_directory_doer(pointerToChar,0);\n    }\n    break;\n  case 0x1d:\n    if (obfd == (char **)0x0) goto LAB_00104b4f;\n    if (0 < deterministic) {\n      *(uint *)((long)obfd + 0x44) = *(uint *)((long)obfd + 0x44) | 0x2000;\n    }\n    temp_fd = dup(temp_fd);\n    bfd_close(pointerToPointerToChar);\n    pointerToChar = real_name;\n    tempInt = stat(real_name,&local_7d0);\n    if ((tempInt != 0) && (obfd = (char **)bfd_openw(pointerToChar,0), obfd != (char **)0x0)) {\n      bfd_set_format(obfd,2);\n      bfd_close(obfd);\n    }\n    smart_rename_constprop_0(temp_name,real_name,temp_fd);\n    obfd = (char **)0x0;\n    free(temp_name);\n    free(real_name);\n    break;\n  case 0x1e:\n    ar_open(*pointerToPointerToChar,0);\n    break;\n  case 0x1f:\n    ar_open(*pointerToPointerToChar,1);\n    break;\n  case 0x20:\n    pointerToChar = *pointerToPointerToChar;\n    if (obfd == (char **)0x0) {\n      pointerToChar = \"%s: no output archive specified yet\\n\";\n      goto LAB_00104b62;\n    }\n    tempLong = open_inarch(pointerToPointerToChar[-1],0);\n    if (tempLong != 0) {\n      map_over_list(tempLong,ar_addlib_doer,pointerToChar);\n    }\n    break;\n  case 0x21:\n    pointerToChar = *pointerToPointerToChar;\n    pointerToChar = pointerToPointerToChar[-1];\n    tempUnsignedVar = open_inarch(pointerToPointerToChar[-2],0);\n    if (pointerToChar == (char *)0x0) {\n      outfile = _stdout;\n    }\n    else {\n      outfile = fopen(pointerToChar,\"w\");\n      if (outfile != (FILE *)0x0) {\n        map_over_list(tempUnsignedVar,ar_directory_doer,pointerToChar);\n        bfd_close(tempUnsignedVar);\n        fclose(outfile);\n        break;\n      }\n      outfile = _stdout;\n      pointerToChar = (char *)dcgettext(0,\"Can\\'t open file %s\\n\",5);\n      fprintf(_stderr,pointerToChar,pointerToChar);\n    }\n    map_over_list(tempUnsignedVar,ar_directory_doer,pointerToChar);\n    bfd_close(tempUnsignedVar);\n    break;\n  case 0x22:\n    pointerToPointerToChar = (char **)*pointerToPointerToChar;\n    break;\n  case 0x23:\n  case 0x25:\n  case 0x27:\n    pointerToPointerToChar = (char **)0x0;\n    break;\n  case 0x24:\n    pointerToPointerToChar = (char **)pointerToPointerToChar[-1];\n    break;\n  case 0x26:\n    pointerToPointerToChar = (char **)malloc(0x10);\n    pointerToChar = pointerToPointerToChar[-2];\n    *pointerToPointerToChar = *pointerToPointerToChar;\n    pointerToPointerToChar[1] = pointerToChar;\n    break;\n  case 0x2a:\n    verbose = (uint)(verbose == 0);\n  }\n  tempLong = (long)tempChar;\n  local_828 = local_828 + -tempLong;\n  pointerToPointerToChar[1 - tempLong] = (char *)pointerToPointerToChar;\n  pointerToPointerToChar = pointerToPointerToChar + (1 - tempLong);\n  tempUnsignedVar = (int)(char)yypgoto[(char)yyr1[tempInt] + -0x18] + (int)*local_828;\n  if ((tempUnsignedVar < 0x23) && (*local_828 == yycheck[(int)tempUnsignedVar])) {\n    tempLong = (long)(char)yytable[(int)tempUnsignedVar];\n  }\n  else {\n    tempLong = (long)(char)yydefgoto[(char)yyr1[tempInt] + -0x18];\n  }\n  goto LAB_001049d1;\nswitchD_00104200_caseD_29:\n  tempInt = ((int)pointerToByte - (int)yytext) + -1;\n  *pointerToByte = yy_hold_char;\n  pointerToPointerToFile = (long **)(yy_buffer_stack + tempLong * 8);\n  pointerToPointerToFile = (FILE **)*pointerToPointerToFile;\n  if (*(int *)(pointerToPointerToFile + 7) == 0) {\n    yy_n_chars = *(uint *)((long)pointerToPointerToFile + 0x1c);\n    *(undefined4 *)(pointerToPointerToFile + 7) = 1;\n    *pointerToPointerToFile = yyin;\n  }\n  pointerToByte = yy_c_buf_p;\n  pointerToFile = pointerToPointerToFile[1];\n  auVar40._8_8_ = pointerToFile;\n  auVar40._0_8_ = pointerToPointerToFile;\n  if ((byte *)((long)&pointerToFile->_flags + (long)(int)yy_n_chars) < yy_c_buf_p) {\n    if ((byte *)((long)&pointerToFile->_flags + (long)(int)yy_n_chars + 1) < yy_c_buf_p) {\n      auVar40 = yy_fatal_error();\n    }\n    if (*(int *)(auVar40._0_8_ + 0x34) != 0) {\n      tempUnsignedVar = (int)((long)pointerToByte - (long)pointerToByte) - 1;\n      for (tempLong = 0; (int)tempLong < (int)tempUnsignedVar; tempLong = tempLong + 1) {\n        *(byte *)(auVar40._8_8_ + tempLong) = pointerToByte[tempLong];\n      }\n      pointerToFile = *pointerToPointerToFile;\n      if (*(int *)(pointerToFile + 7) == 2) {\n        yy_n_chars = 0;\n        *(undefined4 *)((long)pointerToFile + 0x1c) = 0;\nLAB_0010475e:\n        pointerToFile = yyin;\n        if (tempUnsignedVar == 0) {\n          if ((yy_buffer_stack == 0) || (*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) == 0))\n          {\n            yyensure_buffer_stack();\n            pointerToUnsignedVar = (undefined8 *)(yy_buffer_stack + yy_buffer_stack_top * 8);\n            tempUnsignedVar = yy_create_buffer_constprop_0(pointerToFile);\n            *pointerToUnsignedVar = tempUnsignedVar;\n          }\n          tempLong = yy_buffer_stack;\n          if (yy_buffer_stack != 0) {\n            tempLong = *(long *)(yy_buffer_stack + yy_buffer_stack_top * 8);\n          }\n          tempInt = 1;\n          yy_init_buffer(tempLong);\n          yy_load_buffer_state();\n        }\n        else {\n          tempInt = 2;\n          *(undefined4 *)(*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) + 0x38) = 2;\n        }\n      }\n      else {\n        while( true ) {\n          pointerToFile = *pointerToPointerToFile;\n          tempUnsignedVar = ~tempUnsignedVar + *(int *)(pointerToFile + 3);\n          if (0 < (int)tempUnsignedVar) break;\n          tempUnsignedVar = (int)yy_c_buf_p - (int)(void *)pointerToFile[1];\n          if (*(int *)(pointerToFile + 4) == 0) {\n            pointerToFile[1] = 0;\nLAB_00104626:\n            yy_fatal_error();\n            break;\n          }\n          tempInt = *(int *)(pointerToFile + 3);\n          tempInt = tempInt;\n          if (tempInt < 1) {\n            tempInt = tempInt / 8;\n          }\n          *(int *)(pointerToFile + 3) = tempInt + tempInt;\n          pointerToVoid = realloc((void *)pointerToFile[1],(long)(tempInt + tempInt + 2));\n          pointerToFile[1] = (long)pointerToVoid;\n          if (pointerToVoid == (void *)0x0) goto LAB_00104626;\n          yy_c_buf_p = (byte *)((long)pointerToVoid + (long)(int)tempUnsignedVar);\n          pointerToFile = *pointerToPointerToFile;\n        }\n        if (0x2000 < (int)tempUnsignedVar) {\n          tempUnsignedVar = 0x2000;\n        }\n        tempUnsignedVar = (ulong)tempUnsignedVar;\n        if (*(int *)((long)pointerToFile + 0x24) == 0) {\n          pointerToInt = __errno_location();\n          tempUnsignedVar = (ulong)(int)tempUnsignedVar;\n          tempUnsignedVar = (ulong)(int)tempUnsignedVar;\n          *pointerToInt = 0;\n          goto LAB_001046c7;\n        }\n        tempUnsignedVar = 0;\n        pointerToInt = (int *)(long)(int)tempUnsignedVar;\n        do {\n          tempInt = getc(yyin);\n          tempUnsignedVar = (uint)tempUnsignedVar;\n          if (tempInt == -1) {\n            tempInt = ferror(yyin);\n            tempUnsignedVar = tempUnsignedVar;\n            if (tempInt != 0) {\n              do {\n                pointerToChar = \"input in flex scanner failed\";\n                yy_fatal_error();\n                do {\n                  *pointerToInt = 0;\n                  clearerr((FILE *)pointerToChar);\nLAB_001046c7:\n                  tempSize = fread((void *)(*(long *)(*(long *)(yy_buffer_stack +\n                                                             yy_buffer_stack_top * 8) + 8) + tempUnsignedVar)\n                                 ,1,tempUnsignedVar,yyin);\n                  pointerToChar = (char *)yyin;\n                  yy_n_chars = (uint)tempSize;\n                  tempUnsignedVar = yy_n_chars;\n                  if ((yy_n_chars != 0) || (tempInt = ferror(yyin), tempUnsignedVar = yy_n_chars, tempInt == 0))\n                  goto LAB_00104738;\n                } while (*pointerToInt == 4);\n              } while( true );\n            }\n            break;\n          }\n          if (tempInt == 10) {\n            *(undefined *)\n             ((long)(int *)(long)(int)tempUnsignedVar +\n             (long)(int)tempUnsignedVar + *(long *)(*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) + 8)\n             ) = 10;\n            tempUnsignedVar = tempUnsignedVar + 1;\n            break;\n          }\n          tempUnsignedVar = (ulong)(tempUnsignedVar + 1);\n          *(char *)(*(long *)(*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) + 8) +\n                   (long)pointerToInt) = (char)tempInt;\n          pointerToInt = (int *)((long)pointerToInt + 1);\n        } while (tempUnsignedVar != tempUnsignedVar + 1);\nLAB_00104738:\n        yy_n_chars = tempUnsignedVar;\n        tempUnsignedVar = yy_n_chars;\n        tempInt = 0;\n        *(uint *)(*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) + 0x1c) = yy_n_chars;\n        if (tempUnsignedVar == 0) goto LAB_0010475e;\n      }\n      pointerToFile = (long *)(yy_buffer_stack + yy_buffer_stack_top * 8);\n      tempLong = *pointerToFile;\n      tempUnsignedVar = tempUnsignedVar + yy_n_chars;\n      if (*(int *)(tempLong + 0x18) < (int)tempUnsignedVar) {\n        tempInt = ((int)yy_n_chars >> 1) + tempUnsignedVar;\n        pointerToVoid = realloc(*(void **)(tempLong + 8),(long)tempInt);\n        *(void **)(tempLong + 8) = pointerToVoid;\n        auVar41._8_8_ = pointerToFile;\n        auVar41._0_8_ = *pointerToFile;\n        if (*(long *)(*pointerToFile + 8) == 0) {\n          auVar41 = yy_fatal_error();\n        }\n        pointerToFile = auVar41._8_8_;\n        *(int *)(auVar41._0_8_ + 0x18) = tempInt + -2;\n      }\n      yy_n_chars = tempUnsignedVar;\n      *(undefined *)(*(long *)(*pointerToFile + 8) + (long)(int)tempUnsignedVar) = 0;\n      *(undefined *)(*(long *)(*pointerToFile + 8) + 1 + (long)(int)tempUnsignedVar) = 0;\n      pointerToByte = *(byte **)(*pointerToFile + 8);\n      yytext = pointerToByte;\n      if (tempInt == 1) goto LAB_001048a4;\n      if (tempInt == 2) goto LAB_001048ca;\n      pointerToByte = pointerToByte + tempInt;\n      yy_c_buf_p = pointerToByte;\n      tempUnsignedVar = yy_get_previous_state();\n      goto LAB_001040d4;\n    }\n    if ((long)pointerToByte - (long)pointerToByte == 1) goto LAB_001048a4;\nLAB_001048ca:\n    pointerToByte = (byte *)((long)(int)yy_n_chars +\n                      *(long *)(*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) + 8));\n    yy_c_buf_p = pointerToByte;\n    tempUnsignedVar = yy_get_previous_state();\n    pointerToByte = yytext;\n    goto LAB_0010419f;\n  }\n  pointerToByte = pointerToByte + tempInt;\n  yy_c_buf_p = pointerToByte;\n  tempUnsignedVar = yy_get_previous_state();\n  if (*(short *)(yy_accept + (long)(int)(uint)tempUnsignedVar * 2) != 0) {\n    yy_last_accepting_cpos = pointerToByte;\n    yy_last_accepting_state = (uint)tempUnsignedVar;\n  }\n  tempUnsignedVar = tempUnsignedVar & 0xffffffff;\n  while( true ) {\n    tempInt = (int)tempUnsignedVar;\n    if (tempInt == *(short *)(yy_chk + (long)(*(short *)(yy_base + (long)tempInt * 2) + 1) * 2)) break;\n    tempUnsignedVar = (ulong)(uint)(int)*(short *)(yy_def + (long)tempInt * 2);\n  }\n  tempUnsignedVar = (uint)*(short *)(yy_nxt + (long)(*(short *)(yy_base + (long)tempInt * 2) + 1) * 2);\n  pointerToByte = pointerToByte;\n  if ((*(short *)(yy_nxt + (long)(*(short *)(yy_base + (long)tempInt * 2) + 1) * 2) == 0) ||\n     (tempUnsignedVar == 0xb0)) goto LAB_0010419f;\n  pointerToByte = pointerToByte + 1;\n  goto LAB_001040d4;\nLAB_001048a4:\n  yy_c_buf_p = yytext;\n  tempInt = (int)(yy_start - 1) / 2 + 0x2a;\n  goto LAB_001041f0;\nswitchD_00104200_caseD_0:\n  *pointerToByte = yy_hold_char;\n  tempUnsignedVar = (ulong)yy_last_accepting_state;\n  pointerToByte = yy_last_accepting_cpos;\n  goto LAB_0010419f;\nLAB_00105227:\n  pointerToPointerToChar = pointerToPointerToChar + 1;\n  local_800 = 3;\n  *pointerToPointerToChar = yylval;\nLAB_001049d1:\n  local_828 = local_828 + 1;\n  goto LAB_00103ee9;\n}\n\n",
            "called": [
                "open_inarch",
                "prompt",
                "smart_rename.constprop.0",
                "fprintf",
                "ferror",
                "fread",
                "fclose",
                "clearerr",
                "maybequit",
                "dcgettext",
                "map_over_list",
                "yy_load_buffer_state",
                "ar_directory_doer",
                "fwrite",
                "stat",
                "ar_open",
                "filename_cmp",
                "__errno_location",
                "yyerror.constprop.0",
                "bfd_openw",
                "dup",
                "ar_addlib_doer",
                "yy_fatal_error",
                "printf",
                "fopen",
                "bfd_close",
                "unlink",
                "bfd_set_format",
                "yy_init_buffer",
                "bfd_cache_close",
                "yy_get_previous_state",
                "bfd_openr",
                "realloc",
                "yyensure_buffer_stack",
                "yy_create_buffer.constprop.0",
                "getc",
                "extract_file",
                "free",
                "malloc",
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103e95",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "extract_and_parse_00103e95"
        },
        "FUN_001020e0": {
            "renaming": {},
            "code": "\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fread(__ptr,__size,__n,__stream);\n  return sVar1;\n}\n\n",
            "called": [
                "fread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020e0",
            "calling": [
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_001020e0"
        },
        "FUN_0010e200": {
            "renaming": {},
            "code": "\n\n\n\nvoid * malloc(size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* malloc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e200",
            "calling": [
                "malloc"
            ],
            "imported": false,
            "current_name": "FUN_0010e200"
        },
        "FUN_00102280": {
            "renaming": {},
            "code": "\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102280",
            "calling": [
                "list_matching_formats",
                "list_supported_targets",
                "print_arelt_descr.cold"
            ],
            "imported": false,
            "current_name": "FUN_00102280"
        },
        "FUN_00107730": {
            "renaming": {
                "FUN_00107730": "cleanup_output_files_00107730",
                "output_bfd": "bfdHandle",
                "output_file": "outputFile",
                "output_filename": "filename"
            },
            "code": "\nvoid cleanupOutputFiles_00107730(void)\n\n{\n  if (filename == 0) {\n    return;\n  }\n  if (bfdHandle != 0) {\n    bfd_cache_close();\n  }\n  if (outputFile != (FILE *)0x0) {\n    fclose(outputFile);\n  }\n  unlink_if_ordinary(filename);\n  return;\n}\n\n",
            "called": [
                "remove_output.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107730",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "cleanup_output_files_00107730"
        },
        "FUN_00102040": {
            "renaming": {},
            "code": "\n\n\nint utimensat(int __fd,char *__path,timespec *__times,int __flags)\n\n{\n  int iVar1;\n  \n  iVar1 = utimensat(__fd,__path,__times,__flags);\n  return iVar1;\n}\n\n",
            "called": [
                "utimensat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102040",
            "calling": [
                "set_times"
            ],
            "imported": false,
            "current_name": "FUN_00102040"
        },
        "FUN_00102160": {
            "renaming": {},
            "code": "\nvoid bindtextdomain(void)\n\n{\n  bindtextdomain();\n  return;\n}\n\n",
            "called": [
                "bindtextdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102160",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102160"
        },
        "FUN_0010e2a8": {
            "renaming": {},
            "code": "\n\n\n\nint sprintf(char *__s,char *__format,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* sprintf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e2a8",
            "calling": [
                "sprintf"
            ],
            "imported": false,
            "current_name": "FUN_0010e2a8"
        },
        "FUN_001020f0": {
            "renaming": {},
            "code": "\nvoid bfd_set_archive_head(void)\n\n{\n  bfd_set_archive_head();\n  return;\n}\n\n",
            "called": [
                "bfd_set_archive_head"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020f0",
            "calling": [
                "write_archive.cold"
            ],
            "imported": false,
            "current_name": "FUN_001020f0"
        },
        "FUN_001031cf": {
            "renaming": {
                "FUN_001031cf": "initialize_file_001031cf",
                "param_1": "filePtr",
                "param_2": "inputFile",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "iVar1": "errnoVal",
                "uVar2": "isTTY",
                "iVar3": "fileNum",
                "piVar4": "errnoLocation",
                "lVar5": "bufferStack"
            },
            "code": "\n\n\nundefined8\ninitializeFile_001031cf(FILE **filePtr,FILE *inputFile,undefined8 param3,undefined8 param4,undefined8 param5)\n\n{\n  int errnoVal;\n  uint isTTY;\n  int fileNum;\n  int *errnoLocation;\n  long bufferStack;\n  \n  errnoLocation = __errno_location();\n  bufferStack = yy_buffer_stack;\n  errnoVal = *errnoLocation;\n  if (filePtr == (FILE **)0x0) {\n    _DAT_00000034 = 1;\n    _DAT_00000000 = inputFile;\n    if (yy_buffer_stack != 0) {\nLAB_00103263:\n      if (filePtr == *(FILE ***)(bufferStack + yy_buffer_stack_top * 8)) goto LAB_0010327b;\n    }\n  }\n  else {\n    *(undefined4 *)((long)filePtr + 0x1c) = 0;\n    *(undefined *)&filePtr[1]->_flags = 0;\n    *(undefined *)((long)&filePtr[1]->_flags + 1) = 0;\n    *(undefined4 *)(filePtr + 5) = 1;\n    filePtr[2] = filePtr[1];\n    *(undefined4 *)(filePtr + 7) = 0;\n    if (bufferStack != 0) {\n      if (filePtr == *(FILE ***)(bufferStack + yy_buffer_stack_top * 8)) {\n        yy_load_buffer_state();\n      }\n      *filePtr = inputFile;\n      *(undefined4 *)((long)filePtr + 0x34) = 1;\n      goto LAB_00103263;\n    }\n    *filePtr = inputFile;\n    *(undefined4 *)((long)filePtr + 0x34) = 1;\n  }\n  *(undefined8 *)((long)filePtr + 0x2c) = 1;\nLAB_0010327b:\n  isTTY = 0;\n  if (inputFile != (FILE *)0x0) {\n    fileNum = fileno(inputFile);\n    fileNum = isatty(fileNum);\n    isTTY = (uint)(0 < fileNum);\n  }\n  *(uint *)((long)filePtr + 0x24) = isTTY;\n  *errnoLocation = errnoVal;\n  return param5;\n}\n\n",
            "called": [
                "yy_load_buffer_state",
                "__errno_location",
                "isatty",
                "fileno"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001031cf",
            "calling": [
                "yy_create_buffer.constprop.0",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "initialize_file_001031cf"
        },
        "FUN_0010312d": {
            "renaming": {
                "FUN_0010312d": "copy_data_0010312d",
                "param_1": "source",
                "param_2": "destination",
                "lVar1": "temp",
                "obfd": "originalDestination"
            },
            "code": "\nvoid copyData_0010312d(long source,long destination)\n\n{\n  long temp;\n  \n  if (destination != 0) {\n    *(undefined8 *)(destination + 0xf0) = *(undefined8 *)(source + 0xf0);\n  }\n  temp = originalDestination;\n  *(undefined8 *)(source + 0xf0) = *(undefined8 *)(originalDestination + 0xf8);\n  *(long *)(temp + 0xf8) = source;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010312d",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "copy_data_0010312d"
        },
        "FUN_00105c00": {
            "renaming": {
                "FUN_00105c00": "copy_file_00105c00",
                "param_1": "sourceFileDescriptor",
                "param_2": "destinationFilePath",
                "iVar1": "originalErrno",
                "__fd": "destinationFileDescriptor",
                "iVar2": "numBytesRead",
                "_Var3": "currentOffset",
                "uVar4": "totalBytesCopied",
                "sVar5": "numBytesWritten",
                "piVar6": "errnoPointer",
                "auStack_2038": "buffer"
            },
            "code": "\nulong copyFile_00105c00(int sourceFileDescriptor,char *destinationFilePath)\n\n{\n  int originalErrno;\n  int destinationFileDescriptor;\n  int numBytesRead;\n  __off_t currentOffset;\n  ulong totalBytesCopied;\n  size_t numBytesWritten;\n  int *errnoPointer;\n  undefined buffer [8200];\n  \n  if ((-1 < sourceFileDescriptor) && (currentOffset = lseek(sourceFileDescriptor,0,0), currentOffset == 0)) {\n    destinationFileDescriptor = open(destinationFilePath,0x201);\n    if (destinationFileDescriptor < 0) {\n      totalBytesCopied = simple_copy_constprop_0_cold();\n      return totalBytesCopied;\n    }\n    do {\n      totalBytesCopied = read(sourceFileDescriptor,buffer,0x2000);\n      numBytesRead = (int)totalBytesCopied;\n      if (numBytesRead < 1) {\n        errnoPointer = __errno_location();\n        originalErrno = *errnoPointer;\n        close(sourceFileDescriptor);\n        close(destinationFileDescriptor);\n        if (numBytesRead != 0) {\n          *errnoPointer = originalErrno;\n          return 0xffffffff;\n        }\n        return totalBytesCopied & 0xffffffff;\n      }\n      numBytesWritten = write(destinationFileDescriptor,buffer,(long)numBytesRead);\n    } while (numBytesWritten == (long)numBytesRead);\n    errnoPointer = __errno_location();\n    numBytesRead = *errnoPointer;\n    close(sourceFileDescriptor);\n    close(destinationFileDescriptor);\n    *errnoPointer = numBytesRead;\n  }\n  return 0xffffffff;\n}\n\n",
            "called": [
                "close",
                "simple_copy.constprop.0.cold",
                "__errno_location",
                "write",
                "open",
                "read",
                "lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105c00",
            "calling": [
                "smart_rename.constprop.0"
            ],
            "imported": false,
            "current_name": "copy_file_00105c00"
        },
        "FUN_00105d20": {
            "renaming": {
                "FUN_00105d20": "FUNC_00105d20"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00105d44) */\n/* WARNING: Removing unreachable block (ram,0x00105d50) */\n\nvoid FUNC_00105d20(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_registerTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00105d20",
            "calling": [
                "frame_dummy"
            ],
            "imported": false,
            "current_name": "FUNC_00105d20"
        },
        "FUN_001052a0": {
            "renaming": {
                "FUN_001052a0": "get_file_info_001052a0",
                "param_1": "file_path",
                "iVar1": "status",
                "piVar2": "errno_ptr",
                "uVar3": "error_message",
                "pcVar4": "error_reason",
                "sStack_a8": "file_stat"
            },
            "code": "\nlong get_file_info_001052a0(char *file_path)\n\n{\n  int status;\n  int *errno_ptr;\n  undefined8 error_message;\n  char *error_reason;\n  stat file_stat;\n  \n  if (file_path != (char *)0x0) {\n    status = stat(file_path,&file_stat);\n    if (status < 0) {\n      errno_ptr = __errno_location();\n      if (*errno_ptr == 2) {\n        error_message = dcgettext(0,\"\\'%s\\': No such file\",5);\n        non_fatal(error_message,file_path);\n      }\n      else {\n        error_reason = strerror(*errno_ptr);\n        error_message = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n        non_fatal(error_message,file_path,error_reason);\n      }\n    }\n    else if ((file_stat.st_mode & 0xf000) == 0x4000) {\n      error_message = dcgettext(0,\"Warning: \\'%s\\' is a directory\",5);\n      non_fatal(error_message,file_path);\n    }\n    else if ((file_stat.st_mode & 0xf000) == 0x8000) {\n      if (-1 < file_stat.st_size) {\n        return file_stat.st_size;\n      }\n      error_message = dcgettext(0,\"Warning: \\'%s\\' has negative size, probably it is too large\",5);\n      non_fatal(error_message,file_path);\n    }\n    else {\n      error_message = dcgettext(0,\"Warning: \\'%s\\' is not an ordinary file\",5);\n      non_fatal(error_message,file_path);\n    }\n  }\n  return -1;\n}\n\n",
            "called": [
                "stat",
                "get_file_size.cold",
                "dcgettext",
                "non_fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001052a0",
            "calling": [
                "ranlib_only",
                "main"
            ],
            "imported": false,
            "current_name": "get_file_info_001052a0"
        },
        "FUN_0010336b": {
            "renaming": {
                "FUN_0010336b": "print_emulation_options_0010336b",
                "param_1": "outputFile",
                "pcVar1": "optionString"
            },
            "code": "\nvoid printEmulationOptions_0010336b(FILE *outputFile)\n\n{\n  char *optionString;\n  \n  optionString = (char *)dcgettext(0,\" emulation options: \\n\",5);\n  fprintf(outputFile,optionString);\n  optionString = (char *)dcgettext(0,\"  No emulation specific options\\n\",5);\n  fprintf(outputFile,optionString);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010336b",
            "calling": [
                "usage"
            ],
            "imported": false,
            "current_name": "print_emulation_options_0010336b"
        },
        "FUN_00103c60": {
            "renaming": {
                "FUN_00103c60": "initialize_archive_00103c60",
                "param_1": "inputArchivePath",
                "param_2": "createNewArchive",
                "cVar1": "isArchiveFormatValid",
                "piVar2": "errorLocation",
                "pcVar3": "errorMessage",
                "lVar4": "inputArchiveHandle",
                "lVar5": "archivedFileHandle",
                "uVar6": "programName",
                "plVar7": "archivedFileHandleArray",
                "real_name": "inputArchiveName",
                "temp_name": "temporaryFileName",
                "temp_fd": "temporaryFileDescriptor",
                "obfd": "outputArchiveHandle",
                "_stderr": "standardErrorStream"
            },
            "code": "\n\n\nvoid initializeArchive_00103c60(char *inputArchivePath,int createNewArchive)\n\n{\n  char isArchiveFormatValid;\n  int *errorLocation;\n  char *errorMessage;\n  long inputArchiveHandle;\n  long archivedFileHandle;\n  undefined8 programName;\n  long *archivedFileHandleArray;\n  \n  inputArchiveName = xstrdup();\n  temporaryFileName = (char *)make_tempname(inputArchiveName,&temporaryFileDescriptor);\n  if (temporaryFileName == (char *)0x0) {\n    errorLocation = __errno_location();\n    inputArchivePath = strerror(*errorLocation);\n    programName = program_name;\n    errorMessage = (char *)dcgettext(0,\"%s: Can\\'t open temporary file (%s)\\n\",5);\n  }\n  else {\n    outputArchiveHandle = bfd_fdopenw(temporaryFileName,0,temporaryFileDescriptor);\n    if (outputArchiveHandle == 0) {\n      errorMessage = \"%s: Can\\'t open output archive %s\\n\";\n      inputArchivePath = temporaryFileName;\n    }\n    else {\n      if (createNewArchive != 0) {\nLAB_00103d02:\n        bfd_set_format(outputArchiveHandle,2);\n        *(byte *)(outputArchiveHandle + 0x49) = *(byte *)(outputArchiveHandle + 0x49) & 0xe7 | 8;\n        return;\n      }\n      inputArchiveHandle = bfd_openr(inputArchivePath,\"plugin\");\n      if (inputArchiveHandle == 0) {\n        errorMessage = \"%s: Can\\'t open input archive %s\\n\";\n      }\n      else {\n        isArchiveFormatValid = bfd_check_format(inputArchiveHandle,2);\n        if (isArchiveFormatValid != '\\0') {\n          archivedFileHandleArray = (long *)(outputArchiveHandle + 0xf8);\n          for (archivedFileHandle = bfd_openr_next_archived_file(inputArchiveHandle,0); archivedFileHandle != 0;\n              archivedFileHandle = bfd_openr_next_archived_file(inputArchiveHandle,archivedFileHandle)) {\n            *archivedFileHandleArray = archivedFileHandle;\n            archivedFileHandleArray = (long *)(archivedFileHandle + 0xf0);\n          }\n          goto LAB_00103d02;\n        }\n        errorMessage = \"%s: file %s is not an archive\\n\";\n      }\n    }\n    programName = program_name;\n    errorMessage = (char *)dcgettext(0,errorMessage,5);\n  }\n  fprintf(standardErrorStream,errorMessage,programName,inputArchivePath);\n  maybequit();\n  return;\n}\n\n",
            "called": [
                "make_tempname",
                "bfd_openr_next_archived_file",
                "__errno_location",
                "strerror",
                "fprintf",
                "bfd_check_format",
                "maybequit",
                "bfd_fdopenw",
                "bfd_openr",
                "dcgettext",
                "bfd_set_format",
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103c60",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "initialize_archive_00103c60"
        },
        "FUN_0010e218": {
            "renaming": {},
            "code": "\n\n\n\nint mkstemp(char *__template)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mkstemp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e218",
            "calling": [
                "mkstemp"
            ],
            "imported": false,
            "current_name": "FUN_0010e218"
        },
        "FUN_00102170": {
            "renaming": {},
            "code": "\nvoid dcgettext(void)\n\n{\n  dcgettext();\n  return;\n}\n\n",
            "called": [
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102170",
            "calling": [
                "open_inarch",
                "print_contents",
                "bfd_nonfatal.cold",
                "replace_members.cold",
                "list_supported_targets",
                "extract_file.cold",
                "ar_emul_default_usage",
                "get_file_size",
                "main",
                "FUN_00102e6f",
                "yyparse.isra.0",
                "map_over_list",
                "ar_open",
                "list_matching_formats",
                "write_archive",
                "set_times.cold",
                "yyerror.constprop.0",
                "get_file_size.cold",
                "map_over_members.cold",
                "print_arelt_descr.cold",
                "smart_rename.constprop.0.cold",
                "print_version",
                "ranlib_usage",
                "usage"
            ],
            "imported": false,
            "current_name": "FUN_00102170"
        },
        "FUN_00102290": {
            "renaming": {},
            "code": "\n\n\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = read(__fd,__buf,__nbytes);\n  return sVar1;\n}\n\n",
            "called": [
                "read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102290",
            "calling": [
                "simple_copy.constprop.0"
            ],
            "imported": false,
            "current_name": "FUN_00102290"
        },
        "FUN_0010300e": {
            "renaming": {
                "FUN_0010300e": "parse_input_0010300e",
                "yy_start": "startState",
                "yytext": "textBuffer",
                "yy_c_buf_p": "bufferPointer",
                "yy_ec": "charClass",
                "yy_accept": "acceptTable",
                "yy_base": "baseTable",
                "yy_chk": "checkTable",
                "yy_def": "defaultTable",
                "yy_meta": "metaTable",
                "yy_nxt": "nextTable",
                "yy_last_accepting_cpos": "lastAcceptingCharPosition",
                "yy_last_accepting_state": "lastAcceptingState"
            },
            "code": "\nvoid parseInput_0010300e(void)\n\n{\n  bool bVar1;\n  int iVar2;\n  long lVar3;\n  byte bVar4;\n  byte *pbVar5;\n  byte *in_R9;\n  int in_R10D;\n  \n  bVar1 = false;\n  iVar2 = startState;\n  for (pbVar5 = textBuffer; pbVar5 < bufferPointer; pbVar5 = pbVar5 + 1) {\n    bVar4 = 1;\n    if (*pbVar5 != 0) {\n      bVar4 = charClass[*pbVar5];\n    }\n    if (*(short *)(acceptTable + (long)iVar2 * 2) != 0) {\n      bVar1 = true;\n      in_R9 = pbVar5;\n      in_R10D = iVar2;\n    }\n    while( true ) {\n      lVar3 = (long)(int)((int)*(short *)(baseTable + (long)iVar2 * 2) + (uint)bVar4);\n      if (*(short *)(checkTable + lVar3 * 2) == iVar2) break;\n      iVar2 = (int)*(short *)(defaultTable + (long)iVar2 * 2);\n      if (0xb0 < iVar2) {\n        bVar4 = metaTable[(int)(uint)bVar4];\n      }\n    }\n    iVar2 = (int)*(short *)(nextTable + lVar3 * 2);\n  }\n  if (bVar1) {\n    lastAcceptingCharPosition = in_R9;\n    lastAcceptingState = in_R10D;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010300e",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "parse_input_0010300e"
        },
        "FUN_00107740": {
            "renaming": {
                "FUN_00107740": "extract_valid_archive_entries_00107740",
                "param_1": "archiveEntries",
                "iVar1": "comparisonResult",
                "iVar2": "internalStatError",
                "piVar3": "errorNumber",
                "pcVar4": "errorString",
                "uVar5": "translatedString",
                "pplVar6": "entryPointer",
                "__ptr": "bufferPointer",
                "__n": "bufferSize",
                "lVar7": "loopCounter",
                "plVar8": "currentEntry",
                "puVar9": "localVariable1",
                "uVar10": "bytesRead",
                "sVar11": "bytesRemaining",
                "local_c8": "localVariable2",
                "_Stack_b0": "permissions",
                "uStack_98": "archiveSize",
                "uStack_80": "timeVariable1",
                "uStack_70": "timeVariable2",
                "output_file": "outputFile",
                "open_output_file_isra_0": "openOutputFile",
                "bfd_seek": "seek",
                "filename_cmp": "compareFilename",
                "output_filename": "outputFilename",
                "strerror": "errorStringFromNumber",
                "chmod": "changePermissions",
                "set_times": "setTimeValues"
            },
            "code": "\nlong * extractValidArchiveEntries_00107740(long **archiveEntries)\n\n{\n  int comparisonResult;\n  int internalStatError;\n  int *errorNumber;\n  char *errorString;\n  undefined8 translatedString;\n  long **entryPointer;\n  void *bufferPointer;\n  size_t bufferSize;\n  long loopCounter;\n  long *currentEntry;\n  undefined4 *localVariable1;\n  ulong bytesRead;\n  size_t bytesRemaining;\n  undefined4 localVariable2 [6];\n  __mode_t permissions;\n  ulong archiveSize;\n  undefined8 timeVariable1;\n  undefined8 timeVariable2;\n  \n  if (preserve_dates != 0) {\n    localVariable1 = localVariable2;\n    for (loopCounter = 0x24; loopCounter != 0; loopCounter = loopCounter + -1) {\n      *localVariable1 = 0;\n      localVariable1 = localVariable1 + 1;\n    }\n  }\n  entryPointer = (long **)archiveEntries[0x1d];\n  if ((long **)archiveEntries[0x1d] == (long **)0x0) {\n    entryPointer = archiveEntries;\n  }\n  internalStatError = (*(code *)entryPointer[1][0x3d])(archiveEntries,localVariable2);\n  if (internalStatError != 0) {\n    currentEntry = *archiveEntries;\n    translatedString = dcgettext(0,\"internal stat error on %s\",5);\n    internalStatError = fatal(translatedString,currentEntry);\n    translatedString = posname;\n    if (internalStatError == 3) {\n      for (; *currentEntry != 0; currentEntry = (long *)(*currentEntry + 0xf0)) {\n      }\n    }\n    else {\n      for (; (undefined8 *)*currentEntry != (undefined8 *)0x0; currentEntry = (long *)(*currentEntry + 0xf0)) {\n        comparisonResult = compareFilename(*(undefined8 *)*currentEntry,translatedString);\n        if (comparisonResult == 0) {\n          if (internalStatError != 2) {\n            return currentEntry;\n          }\n          return (long *)(*currentEntry + 0xf0);\n        }\n      }\n    }\n    return currentEntry;\n  }\n  seek(archiveEntries,0,0);\n  outputFile = (FILE *)0x0;\n  if (archiveSize == 0) {\nLAB_00102ca2:\n    outputFile = (FILE *)openOutputFile(*archiveEntries);\n  }\n  else {\n    bytesRead = 0;\n    bufferPointer = (void *)xmalloc(0x2000);\n    do {\n      bytesRemaining = archiveSize - bytesRead;\n      if (0x2000 < bytesRemaining) {\n        bytesRemaining = 0x2000;\n      }\n      bufferSize = bfd_bread(bufferPointer,bytesRemaining,archiveEntries);\n      if (bytesRemaining != bufferSize) {\nLAB_00102c78:\n        archiveEntries = (long **)*archiveEntries[0x1d];\n        translatedString = dcgettext(0,\"%s is not a valid archive\",5);\n        fatal(translatedString,archiveEntries);\n        goto LAB_00102ca2;\n      }\n      if (outputFile == (FILE *)0x0) {\n        outputFile = (FILE *)openOutputFile(*archiveEntries);\n      }\n      bytesRemaining = fwrite(bufferPointer,1,bufferSize,outputFile);\n      if (bytesRemaining != bufferSize) {\n        errorNumber = __errno_location();\n        errorString = errorStringFromNumber(*errorNumber);\n        fatal(\"%s: %s\",outputFilename,errorString);\n        goto LAB_00102c78;\n      }\n      bytesRead = bytesRead + bufferSize;\n    } while (bytesRead < archiveSize);\n    free(bufferPointer);\n  }\n  fclose(outputFile);\n  errorString = outputFilename;\n  outputFile = (FILE *)0x0;\n  changePermissions(outputFilename,permissions);\n  if (preserve_dates != 0) {\n    timeVariable1 = timeVariable2;\n    setTimeValues(errorString,localVariable2);\n  }\n  outputFilename = (char *)0x0;\n  return (long *)0x0;\n}\n\n",
            "called": [
                "extract_file.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107740",
            "calling": [
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "extract_valid_archive_entries_00107740"
        },
        "FUN_00102050": {
            "renaming": {},
            "code": "\nvoid bfd_cache_close(void)\n\n{\n  bfd_cache_close();\n  return;\n}\n\n",
            "called": [
                "bfd_cache_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102050",
            "calling": [
                "remove_output.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102050"
        },
        "FUN_0010e2b8": {
            "renaming": {},
            "code": "\n\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fwrite@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e2b8",
            "calling": [
                "fwrite"
            ],
            "imported": false,
            "current_name": "FUN_0010e2b8"
        },
        "FUN_001028ed": {
            "renaming": {
                "FUN_001028ed": "process_files_001028ed",
                "param_1": "filename",
                "param_2": "target",
                "uVar1": "thinArchiveFlag",
                "bVar2": "appendResult",
                "iVar3": "comparisonResult",
                "sVar4": "stringLength",
                "piVar5": "errorPointer",
                "pcVar6": "currentFilename",
                "pcVar7": "basename1",
                "ppcVar8": "tempPointer",
                "uVar9": "normalizedFilename",
                "lVar10": "currentPointer",
                "__s": "basename2",
                "__s_00": "basename3",
                "lVar11": "tempPointer",
                "uVar12": "positionFilename",
                "uVar13": "unnamedVariable",
                "unaff_RBX": "positionPointer",
                "ppcVar14": "filePointer",
                "unaff_RBP": "filePointersArray",
                "unaff_R12": "targetFile",
                "unaff_R13D": "postypeFlag",
                "ppcVar15": "tempPointer3",
                "unaff_R14": "filesPointer",
                "bVar16": "verboseFlag",
                "bVar17": "unnamedFlag",
                "param_7": "fileList",
                "param_9": "result",
                "in_stack_00000078": "unnamedVar1",
                "in_stack_00000108": "unnamedVar2"
            },
            "code": "\nundefined8 processFiles_001028ed(undefined8 filename,long target)\n\n{\n  undefined thinArchiveFlag;\n  byte appendResult;\n  int comparisonResult;\n  size_t stringLength;\n  int *errorPointer;\n  char *currentFilename;\n  char *basename1;\n  char **tempPointer;\n  undefined8 normalizedFilename;\n  long currentPointer;\n  char *basename2;\n  char *basename3;\n  long tempPointer;\n  undefined8 positionFilename;\n  ulong unnamedVariable;\n  char *positionPointer;\n  char **filePointer;\n  char **filePointersArray;\n  char **targetFile;\n  uint postypeFlag;\n  char **tempPointer3;\n  long filesPointer;\n  bool verboseFlag;\n  byte unnamedFlag;\n  char **fileList;\n  undefined8 result;\n  long unnamedVar1;\n  long unnamedVar2;\n  \n  unnamedFlag = 0;\ncode_r0x001028ed:\n  bfd_fatal(positionPointer,target);\nLAB_001028f5:\n  positionFilename = posname;\n  if (postypeFlag != 3) {\n    while( true ) {\n      if ((undefined8 *)*targetFile == (undefined8 *)0x0) goto LAB_0010571f;\n      comparisonResult = filename_cmp(*(undefined8 *)*targetFile,positionFilename);\n      if (comparisonResult == 0) break;\n      targetFile = (char **)(*targetFile + 0xf0);\n    }\n    if (postypeFlag != 2) goto LAB_0010571f;\n    targetFile = (char **)(*targetFile + 0xf0);\n    goto LAB_0010571f;\n  }\n  currentPointer = *(long *)(filesPointer + 0xf0);\n  if (*(long *)(filesPointer + 0xf0) == 0) goto LAB_0010571f;\nLAB_00105670:\n  do {\n    tempPointer = currentPointer;\n    currentPointer = *(long *)(tempPointer + 0xf0);\n  } while (currentPointer != 0);\n  targetFile = (char **)(tempPointer + 0xf0);\n  positionPointer = *filePointersArray;\n  if (libdeps_bfd != 0) goto LAB_00105731;\nLAB_00105698:\n  thinArchiveFlag = make_thin_archive;\n  postypeFlag = (uint)(verbose != 0);\n  target = bfd_openr(positionPointer,target);\n  if (target != 0) {\n    filePointersArray = filePointersArray + 1;\n    appendResult = do_ar_emul_append_constprop_0(targetFile,target,postypeFlag,thinArchiveFlag);\n    result._6_1_ = result._6_1_ | appendResult;\n    currentFilename = *filePointersArray;\n    do {\n      if (currentFilename == (char *)0x0) {\n        if (result._6_1_ == 0) {\n          output_filename = 0;\n          return 0;\n        }\n        positionFilename = write_archive();\n        return positionFilename;\n      }\n      filePointer = *(char ***)(filesPointer + 0xf0);\n      targetFile = fileList;\n      if (result._7_1_ == '\\0') {\n        tempPointer3 = fileList;\n        if (filePointer != (char **)0x0) {\n          do {\n            if (full_pathname == '\\0') {\n              basename2 = (char *)lbasename(*filePointer);\n              basename1 = basename2;\n              if (ar_truncate != '\\0') {\n                stringLength = strlen(basename2);\n                unnamedVariable = (ulong)*(byte *)(*(long *)(filesPointer + 8) + 0x1e);\n                if (unnamedVariable < stringLength) {\n                  basename1 = (char *)xmalloc(unnamedVariable + 1);\n                  currentPointer = *(long *)(filesPointer + 8);\n                  currentFilename = basename1;\n                  for (unnamedVariable = (ulong)*(byte *)(currentPointer + 0x1e); unnamedVariable != 0; unnamedVariable = unnamedVariable - 1) {\n                    *currentFilename = *basename2;\n                    basename2 = basename2 + (ulong)unnamedFlag * -2 + 1;\n                    currentFilename = currentFilename + (ulong)unnamedFlag * -2 + 1;\n                  }\n                  basename1[*(byte *)(currentPointer + 0x1e)] = '\\0';\n                }\n                currentFilename = *filePointersArray;\n                basename2 = basename1;\n                if (full_pathname == '\\0') goto LAB_00105611;\n                goto LAB_00102980;\n              }\n              currentFilename = *filePointersArray;\n              if (full_pathname != '\\0') goto LAB_00102980;\nLAB_00105611:\n              basename3 = (char *)lbasename(currentFilename);\n              if (ar_truncate != '\\0') {\n                stringLength = strlen(basename3);\n                unnamedVariable = (ulong)*(byte *)(*(long *)(filesPointer + 8) + 0x1e);\n                currentFilename = basename3;\n                basename2 = basename1;\n                if (unnamedVariable < stringLength) {\n                  currentFilename = (char *)xmalloc(unnamedVariable + 1);\n                  currentPointer = *(long *)(filesPointer + 8);\n                  basename1 = currentFilename;\n                  for (unnamedVariable = (ulong)*(byte *)(currentPointer + 0x1e); unnamedVariable != 0; unnamedVariable = unnamedVariable - 1) {\n                    *basename1 = *basename3;\n                    basename3 = basename3 + (ulong)unnamedFlag * -2 + 1;\n                    basename1 = basename1 + (ulong)unnamedFlag * -2 + 1;\n                  }\n                  currentFilename[*(byte *)(currentPointer + 0x1e)] = '\\0';\n                }\n                goto LAB_00102980;\n              }\n              comparisonResult = filename_cmp(basename3,basename1);\n            }\n            else {\n              currentFilename = *filePointersArray;\n              basename2 = *filePointer;\nLAB_00102980:\n              comparisonResult = filename_cmp(currentFilename,basename2);\n            }\n            if ((comparisonResult == 0) && (filePointer[0x1c] != (char *)0x0)) {\n              if (newer_only != 0) {\n                comparisonResult = stat(*filePointersArray,(stat *)&stack0x000000b0);\n                if (comparisonResult != 0) {\n                  errorPointer = __errno_location();\n                  if (*errorPointer != 2) {\n                    bfd_fatal(*filePointersArray);\nLAB_00102b7e:\n                    currentFilename = *filePointer;\n                    positionFilename = dcgettext(0,\"internal stat error on %s\",5);\n                    fatal(positionFilename,currentFilename);\n                    free(filePointersArray);\n                    return 0;\n                  }\n                  goto LAB_0010577e;\n                }\n                tempPointer = (char **)filePointer[0x1d];\n                if ((char **)filePointer[0x1d] == (char **)0x0) {\n                  tempPointer = filePointer;\n                }\n                comparisonResult = (**(code **)(tempPointer[1] + 0x1e8))(filePointer,&stack0x00000020);\n                if (comparisonResult != 0) goto LAB_00102b7e;\n                if (unnamedVar2 <= unnamedVar1) goto LAB_0010577e;\n              }\n              positionFilename = get_pos_bfd(fileList,2,*filePointer);\n              if (libdeps_bfd == 0) {\nLAB_00102ae2:\n                currentFilename = *filePointersArray;\n                verboseFlag = verbose != 0;\n                currentPointer = bfd_openr(currentFilename,target);\n                if (currentPointer == 0) {\n                  bfd_fatal(currentFilename,0);\n                  goto LAB_00102b3e;\n                }\n                appendResult = ar_emul_default_replace(positionFilename,currentPointer,verboseFlag);\n              }\n              else {\n                normalizedFilename = normalize(*filePointersArray);\n                comparisonResult = filename_cmp(normalizedFilename,\"__.LIBDEP\");\n                if (comparisonResult != 0) goto LAB_00102ae2;\nLAB_00102b3e:\n                appendResult = ar_emul_default_replace(positionFilename,libdeps_bfd,verbose != 0);\n              }\n              if (appendResult != 0) {\n                *tempPointer3 = *(char **)(*tempPointer3 + 0xf0);\n                result._6_1_ = appendResult;\n              }\n              goto LAB_0010577e;\n            }\n            tempPointer3 = filePointer + 0x1e;\n            filePointer = (char **)filePointer[0x1e];\n          } while (filePointer != (char **)0x0);\n          goto LAB_0010564c;\n        }\n        postypeFlag = postype;\n        if (postype != 0) goto LAB_001028f5;\n      }\n      else {\nLAB_0010564c:\n        postypeFlag = postype;\n        if (postype != 0) goto LAB_001028f5;\n        currentPointer = *(long *)(filesPointer + 0xf0);\n        if (*(long *)(filesPointer + 0xf0) != 0) goto LAB_00105670;\n      }\nLAB_0010571f:\n      positionPointer = *filePointersArray;\n      if (libdeps_bfd == 0) goto LAB_00105698;\nLAB_00105731:\n      positionFilename = normalize(positionPointer);\n      comparisonResult = filename_cmp(positionFilename,\"__.LIBDEP\");\n      if (comparisonResult != 0) goto code_r0x0010574f;\n      appendResult = ar_emul_default_append(targetFile,libdeps_bfd,verbose != 0,make_thin_archive);\n      result._6_1_ = appendResult | result._6_1_;\nLAB_0010577e:\n      filePointersArray = filePointersArray + 1;\n      currentFilename = *filePointersArray;\n    } while( true );\n  }\n  goto code_r0x001028ed;\ncode_r0x0010574f:\n  positionPointer = *filePointersArray;\n  goto LAB_00105698;\n}\n\n",
            "called": [
                "do_ar_emul_append.constprop.0",
                "bfd_fatal",
                "replace_members.cold",
                "bfd_openr",
                "dcgettext",
                "ar_emul_default_replace",
                "ar_emul_default_append",
                "xmalloc",
                "fatal",
                "stat",
                "strlen",
                "filename_cmp",
                "get_pos_bfd",
                "__errno_location",
                "write_archive",
                "normalize",
                "FUN_00102943",
                "lbasename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001028ed",
            "calling": [
                "replace_members.cold"
            ],
            "imported": false,
            "current_name": "process_files_001028ed"
        },
        "FUN_0010e1b0": {
            "renaming": {},
            "code": "\n\n\n\nlong ftell(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ftell@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1b0",
            "calling": [
                "ftell"
            ],
            "imported": false,
            "current_name": "FUN_0010e1b0"
        },
        "FUN_0010e228": {
            "renaming": {},
            "code": "\n\n\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* realloc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e228",
            "calling": [
                "realloc"
            ],
            "imported": false,
            "current_name": "FUN_0010e228"
        },
        "FUN_0010e108": {
            "renaming": {},
            "code": "\n\n\n\nint fputs(char *__s,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fputs@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e108",
            "calling": [
                "fputs"
            ],
            "imported": false,
            "current_name": "FUN_0010e108"
        },
        "FUN_00102060": {
            "renaming": {},
            "code": "\n\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = __errno_location();\n  return piVar1;\n}\n\n",
            "called": [
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102060",
            "calling": [
                "yy_init_buffer",
                "open_inarch",
                "simple_copy.constprop.0.cold",
                "ar_open",
                "print_contents",
                "set_times.cold",
                "get_file_size.cold",
                "replace_members.cold",
                "simple_copy.constprop.0",
                "smart_rename.constprop.0.cold",
                "extract_file.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102060"
        },
        "FUN_00102180": {
            "renaming": {},
            "code": "\n\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(__s);\n  return sVar1;\n}\n\n",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102180",
            "calling": [
                "normalize.cold",
                "FUN_00105a68",
                "replace_members.cold",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102180"
        },
        "FUN_001025a0": {
            "renaming": {
                "FUN_001025a0": "handle_file_error_001025a0",
                "piVar1": "errnoPointer",
                "uVar2": "errorMessage"
            },
            "code": "\nundefined8 handleFileError_001025a0(void)\n\n{\n  int *errnoPointer;\n  undefined8 errorMessage;\n  \n  errnoPointer = __errno_location();\n  if (*errnoPointer == 2) {\n    errorMessage = dcgettext(0,\"\\'%s\\': No such file\",5);\n    non_fatal(errorMessage);\n  }\n  else {\n    strerror(*errnoPointer);\n    errorMessage = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n    non_fatal(errorMessage);\n  }\n  return 0xffffffffffffffff;\n}\n\n",
            "called": [
                "__errno_location",
                "strerror",
                "dcgettext",
                "non_fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001025a0",
            "calling": [
                "get_file_size"
            ],
            "imported": false,
            "current_name": "handle_file_error_001025a0"
        },
        "FUN_0010284b": {
            "renaming": {
                "FUN_0010284b": "get_return_value_0010284b",
                "undefined8": "int64_t"
            },
            "code": "\nint64_t getReturnValue_0010284b(void)\n\n{\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010284b",
            "calling": [
                "ranlib_only"
            ],
            "imported": false,
            "current_name": "get_return_value_0010284b"
        },
        "FUN_0010e220": {
            "renaming": {},
            "code": "\n\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fseek@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e220",
            "calling": [
                "fseek"
            ],
            "imported": false,
            "current_name": "FUN_0010e220"
        },
        "FUN_0010e100": {
            "renaming": {},
            "code": "\n\n\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* lseek@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e100",
            "calling": [
                "lseek"
            ],
            "imported": false,
            "current_name": "FUN_0010e100"
        },
        "FUN_00105cc0": {
            "renaming": {
                "FUN_00105cc0": "start_main_loop_00105cc0",
                "param_1": "param1",
                "param_2": "param2",
                "auStack_8": "stack",
                "__libc_start_main": "initializeRuntime",
                "main": "entryPoint"
            },
            "code": "\nvoid processEntry startMainLoop_00105cc0(undefined8 param1,undefined8 param2)\n\n{\n  undefined stack [8];\n  \n  initializeRuntime(entryPoint,param2,&stack0x00000008,0,0,param1,stack);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "__libc_start_main",
                "main"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105cc0",
            "calling": [],
            "imported": false,
            "current_name": "start_main_loop_00105cc0"
        },
        "FUN_00102f08": {
            "renaming": {
                "FUN_00102f08": "print_and_swap_00102f08",
                "unaff_RBX": "string_ptr",
                "unaff_R12": "target_ptr"
            },
            "code": "\nundefined8 print_and_swap_00102f08(void)\n\n{\n  undefined8 *string_ptr;\n  undefined8 *target_ptr;\n  \n  printf(\"a - %s\\n\",*string_ptr);\n  string_ptr[0x1e] = *target_ptr;\n  *target_ptr = string_ptr;\n  return 1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f08",
            "calling": [
                "do_ar_emul_append.constprop.0"
            ],
            "imported": false,
            "current_name": "print_and_swap_00102f08"
        },
        "FUN_00105570": {
            "renaming": {
                "FUN_00105570": "process_files_00105570",
                "param_1": "file_manager",
                "param_2": "file_list",
                "param_3": "is_archiving",
                "ppcVar1": "output_file",
                "uVar2": "undefined_var",
                "bVar3": "byte_var",
                "iVar4": "int_var",
                "sVar5": "size_var",
                "piVar6": "errno_ptr",
                "pcVar7": "current_file",
                "pcVar8": "truncated_file",
                "uVar9": "normalized_file",
                "pcVar10": "file_iterator",
                "__s": "file_basename",
                "lVar11": "current_file_ptr",
                "lVar12": "next_file_ptr",
                "uVar13": "return_value",
                "uVar14": "ulong_var",
                "ppcVar15": "archive_file_ptr",
                "ppcVar16": "current_archive_file_ptr",
                "uVar17": "uint_var",
                "ppcVar18": "previous_file_ptr",
                "bVar19": "bool_var",
                "bVar20": "byte_var_2",
                "local_15a": "local_byte_var",
                "auStack_158": "stack_buffer",
                "lStack_100": "stack_buffer_size",
                "sStack_c8": "file_stats"
            },
            "code": "\nundefined8 process_files_00105570(long file_manager,char **file_list,char is_archiving)\n\n{\n  char **output_file;\n  undefined undefined_var;\n  byte byte_var;\n  int int_var;\n  size_t size_var;\n  int *errno_ptr;\n  char *current_file;\n  char *truncated_file;\n  undefined8 normalized_file;\n  char *file_iterator;\n  char *file_basename;\n  long current_file_ptr;\n  long next_file_ptr;\n  undefined8 return_value;\n  ulong ulong_var;\n  char **archive_file_ptr;\n  char **current_archive_file_ptr;\n  uint uint_var;\n  char **previous_file_ptr;\n  bool bool_var;\n  byte byte_var_2;\n  byte local_byte_var;\n  undefined stack_buffer [88];\n  long stack_buffer_size;\n  stat file_stats;\n  \n  byte_var_2 = 0;\n  output_file = (char **)(file_manager + 0xf0);\n  local_byte_var = 0;\n  if (file_list == (char **)0x0) {\n    return_value = initialize_output_file_name_00102943();\n    return return_value;\n  }\n  do {\n    file_iterator = *file_list;\njoined_r0x001055aa:\n    if (file_iterator == (char *)0x0) {\n      if (local_byte_var != 0) {\n        return_value = write_archive(file_manager);\n        return return_value;\n      }\n      output_filename = 0;\n      return 0;\n    }\n    archive_file_ptr = *(char ***)(file_manager + 0xf0);\n    current_archive_file_ptr = output_file;\n    if (is_archiving != '\\0') {\nLAB_0010564c:\n      uint_var = postype;\n      if (postype != 0) goto LAB_001028f5;\n      next_file_ptr = *(long *)(file_manager + 0xf0);\n      if (*(long *)(file_manager + 0xf0) == 0) goto LAB_0010571f;\nLAB_00105670:\n      do {\n        current_file_ptr = next_file_ptr;\n        next_file_ptr = *(long *)(current_file_ptr + 0xf0);\n      } while (next_file_ptr != 0);\n      current_archive_file_ptr = (char **)(current_file_ptr + 0xf0);\n      file_iterator = *file_list;\n      do {\n        if (libdeps_bfd != 0) {\n          return_value = normalize(file_iterator,file_manager);\n          int_var = filename_cmp(return_value,\"__.LIBDEP\");\n          if (int_var == 0) {\n            byte_var = ar_emul_default_append(current_archive_file_ptr,libdeps_bfd,verbose != 0,make_thin_archive);\n            local_byte_var = byte_var | local_byte_var;\n            goto LAB_0010577e;\n          }\n          file_iterator = *file_list;\n        }\n        undefined_var = make_thin_archive;\n        bool_var = verbose != 0;\n        next_file_ptr = bfd_openr(file_iterator,target);\n        if (next_file_ptr != 0) {\n          file_list = file_list + 1;\n          byte_var = do_ar_emul_append_constprop_0(current_archive_file_ptr,next_file_ptr,(uint)bool_var,undefined_var);\n          local_byte_var = local_byte_var | byte_var;\n          file_iterator = *file_list;\n          goto joined_r0x001055aa;\n        }\n        bfd_fatal(file_iterator,0);\n        uint_var = (uint)bool_var;\nLAB_001028f5:\n        return_value = posname;\n        if (uint_var == 3) {\n          next_file_ptr = *(long *)(file_manager + 0xf0);\n          if (*(long *)(file_manager + 0xf0) != 0) goto LAB_00105670;\n        }\n        else {\n          for (; (undefined8 *)*current_archive_file_ptr != (undefined8 *)0x0;\n              current_archive_file_ptr = (char **)(*current_archive_file_ptr + 0xf0)) {\n            int_var = filename_cmp(*(undefined8 *)*current_archive_file_ptr,return_value);\n            if (int_var == 0) {\n              if (uint_var == 2) {\n                current_archive_file_ptr = (char **)(*current_archive_file_ptr + 0xf0);\n              }\n              break;\n            }\n          }\n        }\nLAB_0010571f:\n        file_iterator = *file_list;\n      } while( true );\n    }\n    previous_file_ptr = output_file;\n    if (archive_file_ptr == (char **)0x0) {\n      uint_var = postype;\n      if (postype == 0) goto LAB_0010571f;\n      goto LAB_001028f5;\n    }\nLAB_001055d8:\n    if (full_pathname == '\\0') {\n      file_iterator = (char *)lbasename(*archive_file_ptr);\n      truncated_file = file_iterator;\n      if (ar_truncate != '\\0') {\n        size_var = strlen(file_iterator);\n        ulong_var = (ulong)*(byte *)(*(long *)(file_manager + 8) + 0x1e);\n        if (ulong_var < size_var) {\n          truncated_file = (char *)xmalloc(ulong_var + 1);\n          next_file_ptr = *(long *)(file_manager + 8);\n          current_file = truncated_file;\n          for (ulong_var = (ulong)*(byte *)(next_file_ptr + 0x1e); ulong_var != 0; ulong_var = ulong_var - 1) {\n            *current_file = *file_iterator;\n            file_iterator = file_iterator + (ulong)byte_var_2 * -2 + 1;\n            current_file = current_file + (ulong)byte_var_2 * -2 + 1;\n          }\n          truncated_file[*(byte *)(next_file_ptr + 0x1e)] = '\\0';\n        }\n        current_file = *file_list;\n        file_iterator = truncated_file;\n        if (full_pathname == '\\0') goto LAB_00105611;\n        goto LAB_00102980;\n      }\n      current_file = *file_list;\n      if (full_pathname != '\\0') goto LAB_00102980;\nLAB_00105611:\n      file_basename = (char *)lbasename(current_file);\n      if (ar_truncate != '\\0') {\n        size_var = strlen(file_basename);\n        ulong_var = (ulong)*(byte *)(*(long *)(file_manager + 8) + 0x1e);\n        current_file = file_basename;\n        file_iterator = truncated_file;\n        if (ulong_var < size_var) {\n          current_file = (char *)xmalloc(ulong_var + 1);\n          next_file_ptr = *(long *)(file_manager + 8);\n          truncated_file = current_file;\n          for (ulong_var = (ulong)*(byte *)(next_file_ptr + 0x1e); ulong_var != 0; ulong_var = ulong_var - 1) {\n            *truncated_file = *file_basename;\n            file_basename = file_basename + (ulong)byte_var_2 * -2 + 1;\n            truncated_file = truncated_file + (ulong)byte_var_2 * -2 + 1;\n          }\n          current_file[*(byte *)(next_file_ptr + 0x1e)] = '\\0';\n        }\n        goto LAB_00102980;\n      }\n      int_var = filename_cmp(file_basename,truncated_file);\n      if (int_var == 0) goto LAB_00102993;\nLAB_00105639:\n      previous_file_ptr = archive_file_ptr + 0x1e;\n      archive_file_ptr = (char **)archive_file_ptr[0x1e];\n      if (archive_file_ptr == (char **)0x0) goto LAB_0010564c;\n      goto LAB_001055d8;\n    }\n    current_file = *file_list;\n    file_iterator = *archive_file_ptr;\nLAB_00102980:\n    int_var = filename_cmp(current_file,file_iterator);\n    if (int_var != 0) goto LAB_00105639;\nLAB_00102993:\n    if (archive_file_ptr[0x1c] == (char *)0x0) goto LAB_00105639;\n    if (newer_only != 0) {\n      int_var = stat(*file_list,&file_stats);\n      if (int_var != 0) {\n        errno_ptr = __errno_location();\n        if (*errno_ptr != 2) {\n          bfd_fatal(*file_list);\nLAB_00102b7e:\n          file_iterator = *archive_file_ptr;\n          return_value = dcgettext(0,\"internal stat error on %s\",5);\n          fatal(return_value,file_iterator);\n          free(file_list);\n          return 0;\n        }\n        goto LAB_0010577e;\n      }\n      current_archive_file_ptr = (char **)archive_file_ptr[0x1d];\n      if ((char **)archive_file_ptr[0x1d] == (char **)0x0) {\n        current_archive_file_ptr = archive_file_ptr;\n      }\n      int_var = (**(code **)(current_archive_file_ptr[1] + 0x1e8))(archive_file_ptr,stack_buffer);\n      if (int_var != 0) goto LAB_00102b7e;\n      if (file_stats.st_mtim.tv_sec <= stack_buffer_size) goto LAB_0010577e;\n    }\n    return_value = get_pos_bfd(output_file,2,*archive_file_ptr);\n    if (libdeps_bfd == 0) {\nLAB_00102ae2:\n      file_iterator = *file_list;\n      bool_var = verbose != 0;\n      next_file_ptr = bfd_openr(file_iterator,target);\n      if (next_file_ptr == 0) {\n        bfd_fatal(file_iterator,0);\n        goto LAB_00102b3e;\n      }\n      byte_var = ar_emul_default_replace(return_value,next_file_ptr,bool_var);\n    }\n    else {\n      normalized_file = normalize(*file_list,file_manager);\n      int_var = filename_cmp(normalized_file,\"__.LIBDEP\");\n      if (int_var != 0) goto LAB_00102ae2;\nLAB_00102b3e:\n      byte_var = ar_emul_default_replace(return_value,libdeps_bfd,verbose != 0);\n    }\n    if (byte_var != 0) {\n      *previous_file_ptr = *(char **)(*previous_file_ptr + 0xf0);\n      local_byte_var = byte_var;\n    }\nLAB_0010577e:\n    file_list = file_list + 1;\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00102943"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105570",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "process_files_00105570"
        },
        "FUN_0010e1a8": {
            "renaming": {},
            "code": "\n\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fprintf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1a8",
            "calling": [
                "fprintf"
            ],
            "imported": false,
            "current_name": "FUN_0010e1a8"
        },
        "FUN_0010e2e8": {
            "renaming": {},
            "code": "\n\n\n\nint getc(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e2e8",
            "calling": [
                "getc"
            ],
            "imported": false,
            "current_name": "FUN_0010e2e8"
        },
        "FUN_0010e1c0": {
            "renaming": {},
            "code": "\n\n\n\nint stat(char *__file,stat *__buf)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* stat@GLIBC_2.33 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1c0",
            "calling": [
                "stat"
            ],
            "imported": false,
            "current_name": "FUN_0010e1c0"
        },
        "FUN_00102500": {
            "renaming": {},
            "code": "\n\n\nvoid exit(int __status)\n\n{\n                    \n  exit(__status);\n}\n\n",
            "called": [
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102500",
            "calling": [
                "print_version",
                "yy_fatal_error"
            ],
            "imported": false,
            "current_name": "FUN_00102500"
        },
        "FUN_0010e2e0": {
            "renaming": {},
            "code": "\n\n\n\nchar * strerror(int __errnum)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strerror@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e2e0",
            "calling": [
                "strerror"
            ],
            "imported": false,
            "current_name": "FUN_0010e2e0"
        },
        "FUN_0010e238": {
            "renaming": {},
            "code": "\n\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* setlocale@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e238",
            "calling": [
                "setlocale"
            ],
            "imported": false,
            "current_name": "FUN_0010e238"
        },
        "FUN_00102190": {
            "renaming": {},
            "code": "\nvoid getopt_long(void)\n\n{\n  getopt_long();\n  return;\n}\n\n",
            "called": [
                "getopt_long"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102190",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102190"
        },
        "FUN_00102070": {
            "renaming": {},
            "code": "\n\n\nint unlink(char *__name)\n\n{\n  int iVar1;\n  \n  iVar1 = unlink(__name);\n  return iVar1;\n}\n\n",
            "called": [
                "unlink"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102070",
            "calling": [
                "smart_rename.constprop.0.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102070"
        },
        "FUN_0010285f": {
            "renaming": {
                "FUN_0010285f": "print_entries_in_archive_0010285f",
                "__format": "messageFormat",
                "lVar2": "entryPointer",
                "plVar3": "nextEntryPointer",
                "uVar4": "entryName",
                "plVar5": "currentEntryPointer",
                "unaff_RBP": "printEntry",
                "unaff_R12": "archivePointer",
                "unaff_R13D": "remainingEntriesCount",
                "unaff_R14": "entryNames",
                "iStack000000000000000c": "counter"
            },
            "code": "\n\n\nvoid printEntriesInArchive_0010285f(void)\n\n{\n  int iVar1;\n  char *messageFormat;\n  long entryPointer;\n  long *nextEntryPointer;\n  undefined8 entryName;\n  long *currentEntryPointer;\n  code *printEntry;\n  long archivePointer;\n  int remainingEntriesCount;\n  undefined8 *entryNames;\n  int counter;\n  \ncode_r0x0010285f:\n  entryName = *entryNames;\n  messageFormat = (char *)dcgettext(0,\"no entry %s in archive\\n\",5);\n  fprintf(_stderr,messageFormat,entryName);\nLAB_0010553e:\n  entryNames = entryNames + 1;\n  remainingEntriesCount = remainingEntriesCount + -1;\n  if (remainingEntriesCount == 0) {\n    return;\n  }\n  currentEntryPointer = *(long **)(archivePointer + 0xf0);\n  counter = 0;\n  do {\n    if (currentEntryPointer == (long *)0x0) goto code_r0x0010285f;\n    if (*(int *)((long)currentEntryPointer + 0xac) == 0) {\n      entryPointer = *currentEntryPointer;\n      if (entryPointer == 0) {\n        nextEntryPointer = (long *)currentEntryPointer[0x1d];\n        if ((long *)currentEntryPointer[0x1d] == (long *)0x0) {\n          nextEntryPointer = currentEntryPointer;\n        }\n        (**(code **)(nextEntryPointer[1] + 0x1e8))(currentEntryPointer,&stack0x00000010);\n      }\n      else if (((*(byte *)(archivePointer + 0x49) & 0x10) == 0) || (entryPointer = normalize(), entryPointer != 0)) {\n        entryName = normalize(*entryNames);\n        iVar1 = filename_cmp(entryName,entryPointer);\n        if ((iVar1 == 0) &&\n           ((counted_name_mode == '\\0' ||\n            (counter = counter + 1,\n            counter == counted_name_counter)))) break;\n      }\n    }\n    currentEntryPointer = (long *)currentEntryPointer[0x1e];\n  } while( true );\n  (*printEntry)();\n  *(undefined4 *)((long)currentEntryPointer + 0xac) = 1;\n  goto LAB_0010553e;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010285f",
            "calling": [
                "map_over_members"
            ],
            "imported": false,
            "current_name": "print_entries_in_archive_0010285f"
        },
        "FUN_0010394a": {
            "renaming": {
                "FUN_0010394a": "print_usage_0010394a",
                "param_1": "isVerbose",
                "uVar1": "programName",
                "pcVar2": "localizedString",
                "__stream": "outputStream"
            },
            "code": "\n\n\nvoid printUsage_0010394a(uint isVerbose)\n\n{\n  undefined8 programName;\n  char *localizedString;\n  FILE *outputStream;\n  \n  programName = program_name;\n  outputStream = _stderr;\n  if (isVerbose != 0) {\n    outputStream = _stdout;\n  }\n  localizedString = (char *)dcgettext(0,\"Usage: %s [options] archive\\n\",5);\n  fprintf(outputStream,localizedString,programName);\n  localizedString = (char *)dcgettext(0,\" Generate an index to speed access to archives\\n\",5);\n  fprintf(outputStream,localizedString);\n  localizedString = (char *)dcgettext(0,\n                             \" The options are:\\n  @<file>                      Read options from <file>\\n\"\n                             ,5);\n  fprintf(outputStream,localizedString);\n  localizedString = (char *)dcgettext(0,\"  --plugin <name>              Load the specified plugin\\n\",5);\n  fprintf(outputStream,localizedString);\n  localizedString = (char *)dcgettext(0,\n                             \"  -D                           Use zero for symbol map timestamp (default)\\n  -U                           Use an actual symbol map timestamp\\n\"\n                             ,5);\n  fprintf(outputStream,localizedString);\n  localizedString = (char *)dcgettext(0,\n                             \"  -t                           Update the archive\\'s symbol map timestamp\\n  -h --help                    Print this help message\\n  -v --version                 Print version information\\n\"\n                             ,5);\n  fprintf(outputStream,localizedString);\n  list_supported_targets(program_name,outputStream);\n  if (isVerbose != 0) {\n    localizedString = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(outputStream,localizedString,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  xexit(isVerbose ^ 1);\n}\n\n",
            "called": [
                "xexit",
                "fprintf",
                "list_supported_targets",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010394a",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "print_usage_0010394a"
        },
        "FUN_00105bb0": {
            "renaming": {
                "FUN_00105bb0": "get_return_value_00105bb0"
            },
            "code": "\nundefined8 getReturnValue_00105bb0(void)\n\n{\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105bb0",
            "calling": [],
            "imported": false,
            "current_name": "get_return_value_00105bb0"
        },
        "FUN_00107640": {
            "renaming": {
                "FUN_00107640": "initialize_00107640"
            },
            "code": "\nundefined8 initialize_00107640(void)\n\n{\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107640",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_00107640"
        },
        "FUN_0010e1d8": {
            "renaming": {},
            "code": "\n\n\n\nvoid clearerr(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* clearerr@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1d8",
            "calling": [
                "clearerr"
            ],
            "imported": false,
            "current_name": "FUN_0010e1d8"
        },
        "FUN_00102510": {
            "renaming": {},
            "code": "\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fwrite(__ptr,__size,__n,__s);\n  return sVar1;\n}\n\n",
            "called": [
                "fwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102510",
            "calling": [
                "print_contents",
                "extract_file.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102510"
        },
        "FUN_0010315d": {
            "renaming": {
                "FUN_0010315d": "handle_non_interactive_mode_0010315d",
                "interactive": "isInteractive",
                "xexit": "exitWithError"
            },
            "code": "\nvoid handleNonInteractiveMode_0010315d(void)\n\n{\n  if (isInteractive == 0) {\n                    \n    exitWithError(9);\n  }\n  return;\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010315d",
            "calling": [
                "open_inarch",
                "ar_open",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "handle_non_interactive_mode_0010315d"
        },
        "FUN_0010e1d0": {
            "renaming": {},
            "code": "\n\n\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strtol@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1d0",
            "calling": [
                "strtol"
            ],
            "imported": false,
            "current_name": "FUN_0010e1d0"
        },
        "FUN_0010e248": {
            "renaming": {},
            "code": "\n\n\n\nint chmod(char *__file,__mode_t __mode)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* chmod@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e248",
            "calling": [
                "chmod"
            ],
            "imported": false,
            "current_name": "FUN_0010e248"
        },
        "FUN_0010e008": {
            "renaming": {},
            "code": "\n\n\n\nint utimensat(int __fd,char *__path,timespec *__times,int __flags)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* utimensat@GLIBC_2.6 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e008",
            "calling": [
                "utimensat"
            ],
            "imported": false,
            "current_name": "FUN_0010e008"
        },
        "FUN_00102080": {
            "renaming": {},
            "code": "\nvoid bfd_make_writable(void)\n\n{\n  bfd_make_writable();\n  return;\n}\n\n",
            "called": [
                "bfd_make_writable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102080",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102080"
        },
        "FUN_00107890": {
            "renaming": {
                "FUN_00107890": "print_arelt_description_00107890",
                "param_1": "output_stream",
                "_stdout": "_output_stream",
                "verbose": "is_verbose",
                "display_offsets": "show_offsets"
            },
            "code": "\n\n\nvoid print_arelt_description_00107890(undefined8 output_stream)\n\n{\n  print_arelt_descr(_output_stream,output_stream,is_verbose != 0,show_offsets != 0);\n  return;\n}\n\n",
            "called": [
                "print_arelt_descr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107890",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "print_arelt_description_00107890"
        },
        "FUN_001024a0": {
            "renaming": {},
            "code": "\n\n\nvoid perror(char *__s)\n\n{\n  perror(__s);\n  return;\n}\n\n",
            "called": [
                "perror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024a0",
            "calling": [
                "open_inarch",
                "FUN_00105a68"
            ],
            "imported": false,
            "current_name": "FUN_001024a0"
        },
        "FUN_0010e000": {
            "renaming": {},
            "code": "\n\n\n\nvoid free(void *__ptr)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* free@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e000",
            "calling": [
                "free"
            ],
            "imported": false,
            "current_name": "FUN_0010e000"
        },
        "FUN_00103172": {
            "renaming": {
                "FUN_00103172": "store_and_print_00103172",
                "param_1": "source",
                "param_2": "destination",
                "param_3": "shouldPrint",
                "param_4": "valueToStore",
                "uVar1": "tempValue",
                "auVar2": "storedData"
            },
            "code": "\nundefined  [16]\nstoreAndPrint_00103172(undefined8 *source,undefined8 *destination,char shouldPrint,undefined8 valueToStore)\n\n{\n  undefined8 tempValue;\n  undefined storedData [16];\n  \n  if (shouldPrint != '\\0') {\n    printf(\"r - %s\\n\",*destination);\n  }\n  tempValue = *source;\n  destination[0x1e] = tempValue;\n  storedData._1_7_ = (undefined7)((ulong)tempValue >> 8);\n  storedData[0] = 1;\n  *source = destination;\n  storedData._8_8_ = valueToStore;\n  return storedData;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103172",
            "calling": [
                "replace_members.cold"
            ],
            "imported": false,
            "current_name": "store_and_print_00103172"
        },
        "FUN_0010e0a8": {
            "renaming": {},
            "code": "\n\n\n\nint fclose(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fclose@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0a8",
            "calling": [
                "fclose"
            ],
            "imported": false,
            "current_name": "FUN_0010e0a8"
        },
        "FUN_001030ed": {
            "renaming": {
                "FUN_001030ed": "initialize_yy_text_001030ed",
                "puVar1": "bufferPointer",
                "yy_buffer_stack": "bufferStack",
                "yy_buffer_stack_top": "bufferStackTop",
                "yy_n_chars": "numChars",
                "yy_c_buf_p": "currentBufferPointer",
                "yytext": "currentText",
                "yyin": "input",
                "yy_hold_char": "holdChar"
            },
            "code": "\nvoid initializeYyText_001030ed(void)\n\n{\n  undefined8 *bufferPointer;\n  \n  bufferPointer = *(undefined8 **)(bufferStack + bufferStackTop * 8);\n  numChars = *(undefined4 *)((long)bufferPointer + 0x1c);\n  currentBufferPointer = (undefined *)bufferPointer[2];\n  currentText = currentBufferPointer;\n  input = *bufferPointer;\n  holdChar = *currentBufferPointer;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001030ed",
            "calling": [
                "yy_init_buffer",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "initialize_yy_text_001030ed"
        },
        "FUN_00105bc0": {
            "renaming": {
                "FUN_00105bc0": "copy_and_unlink_file_00105bc0",
                "param_1": "source_path",
                "param_2": "destination_path",
                "param_3": "file_permissions",
                "param_4": "error_message",
                "uVar1": "copy_result",
                "piVar2": "errno_location_ptr",
                "pcVar3": "error_string",
                "uVar4": "localized_error",
                "uVar5": "unlink_status",
                "auVar6": "result_array"
            },
            "code": "\nundefined  [16] copy_and_unlink_file_00105bc0(char *source_path,char *destination_path,undefined4 file_permissions,undefined8 error_message)\n\n{\n  uint copy_result;\n  int *errno_location_ptr;\n  char *error_string;\n  undefined8 localized_error;\n  ulong unlink_status;\n  undefined result_array [16];\n  \n  if (destination_path == source_path) {\n    unlink_status = 0;\n  }\n  else {\n    copy_result = simple_copy_constprop_0(file_permissions);\n    unlink_status = (ulong)copy_result;\n    if (copy_result != 0) {\n      errno_location_ptr = __errno_location();\n      error_string = strerror(*errno_location_ptr);\n      localized_error = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n      non_fatal(localized_error,destination_path,error_string);\n    }\n    unlink(source_path);\n  }\n  result_array._8_8_ = error_message;\n  result_array._0_8_ = unlink_status;\n  return result_array;\n}\n\n",
            "called": [
                "simple_copy.constprop.0",
                "smart_rename.constprop.0.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105bc0",
            "calling": [
                "write_archive.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "copy_and_unlink_file_00105bc0"
        },
        "FUN_00107650": {
            "renaming": {
                "FUN_00107650": "check_and_write_archive_00107650",
                "param_1": "inputFile",
                "uVar1": "result",
                "lVar2": "fileSize"
            },
            "code": "\nundefined8 checkAndWriteArchive_00107650(undefined8 inputFile)\n\n{\n  undefined8 result;\n  long fileSize;\n  \n  fileSize = get_file_size();\n  if (fileSize < 1) {\n    result = 1;\n  }\n  else {\n    write_armap = 1;\n    fileSize = open_inarch(inputFile,0);\n    if (fileSize == 0) {\n                    \n      xexit(1);\n    }\n    write_archive(fileSize);\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [
                "xexit",
                "open_inarch",
                "write_archive",
                "ranlib_only.cold",
                "get_file_size"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107650",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "check_and_write_archive_00107650"
        },
        "FUN_00102f1e": {
            "renaming": {
                "FUN_00102f1e": "copy_file_with_error_handling_00102f1e",
                "unaff_RBP": "errorCode",
                "unaff_R12": "filePath",
                "unaff_retaddr": "returnAddress",
                "piVar1": "errnoPointer",
                "uVar2": "errorMessage",
                "auVar3": "returnValue"
            },
            "code": "\nundefined  [16] copyFileWithErrorHandling_00102f1e(void)\n\n{\n  int *errnoPointer;\n  undefined8 errorMessage;\n  ulong errorCode;\n  char *filePath;\n  undefined returnValue [16];\n  undefined8 returnAddress;\n  \n  errnoPointer = __errno_location();\n  strerror(*errnoPointer);\n  errorMessage = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n  non_fatal(errorMessage);\n  unlink(filePath);\n  returnValue._0_8_ = errorCode & 0xffffffff;\n  returnValue._8_8_ = returnAddress;\n  return returnValue;\n}\n\n",
            "called": [
                "__errno_location",
                "strerror",
                "unlink",
                "dcgettext",
                "non_fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f1e",
            "calling": [
                "smart_rename.constprop.0"
            ],
            "imported": false,
            "current_name": "copy_file_with_error_handling_00102f1e"
        },
        "FUN_0010e1e8": {
            "renaming": {},
            "code": "\n\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memcpy@GLIBC_2.14 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1e8",
            "calling": [
                "memcpy"
            ],
            "imported": false,
            "current_name": "FUN_0010e1e8"
        },
        "FUN_00102fd7": {
            "renaming": {
                "FUN_00102fd7": "handle_time_setting_error_00102fd7",
                "piVar1": "errorLocation",
                "uVar2": "errorString"
            },
            "code": "\nvoid handleTimeSettingError_00102fd7(void)\n\n{\n  int *errorLocation;\n  undefined8 errorString;\n  \n  errorLocation = __errno_location();\n  strerror(*errorLocation);\n  errorString = dcgettext(0,\"%s: cannot set time: %s\",5);\n  non_fatal(errorString);\n  return;\n}\n\n",
            "called": [
                "__errno_location",
                "strerror",
                "dcgettext",
                "non_fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102fd7",
            "calling": [
                "set_times"
            ],
            "imported": false,
            "current_name": "handle_time_setting_error_00102fd7"
        },
        "FUN_0010e0c8": {
            "renaming": {},
            "code": "\n\n\nvoid dcgettext(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* dcgettext@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0c8",
            "calling": [
                "dcgettext"
            ],
            "imported": false,
            "current_name": "FUN_0010e0c8"
        },
        "FUN_00102400": {
            "renaming": {},
            "code": "\n\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = realloc(__ptr,__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102400",
            "calling": [
                "yyensure_buffer_stack",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102400"
        },
        "FUN_00102520": {
            "renaming": {},
            "code": "\nvoid bfd_check_format(void)\n\n{\n  bfd_check_format();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102520",
            "calling": [
                "open_inarch.cold",
                "do_ar_emul_append.constprop.0",
                "ar_open"
            ],
            "imported": false,
            "current_name": "FUN_00102520"
        },
        "FUN_001024b0": {
            "renaming": {},
            "code": "\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n  int iVar1;\n  \n  iVar1 = vfprintf(__s,__format,__arg);\n  return iVar1;\n}\n\n",
            "called": [
                "vfprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024b0",
            "calling": [
                "report"
            ],
            "imported": false,
            "current_name": "FUN_001024b0"
        },
        "FUN_00107da8": {
            "renaming": {
                "FUN_00107da8": "FUNC_00107da8"
            },
            "code": "\nvoid FUNC_00107da8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00107da8",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_00107da8"
        },
        "FUN_0010e0c0": {
            "renaming": {},
            "code": "\n\n\nvoid bindtextdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* bindtextdomain@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0c0",
            "calling": [
                "bindtextdomain"
            ],
            "imported": false,
            "current_name": "FUN_0010e0c0"
        },
        "FUN_0010e018": {
            "renaming": {},
            "code": "\n\n\nvoid __libc_start_main(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __libc_start_main@GLIBC_2.34 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e018",
            "calling": [
                "_start"
            ],
            "imported": false,
            "current_name": "FUN_0010e018"
        },
        "FUN_00105d60": {
            "renaming": {
                "FUN_00105d60": "initialize_program_00105d60",
                "completed_0": "is_initialized",
                "__cxa_finalize": "cleanup",
                "__dso_handle": "handle",
                "deregister_tm_clones": "cleanup_tm_clones"
            },
            "code": "\nvoid initialize_program_00105d60(void)\n\n{\n  if (is_initialized != '\\0') {\n    return;\n  }\n  cleanup(handle);\n  cleanup_tm_clones();\n  is_initialized = 1;\n  return;\n}\n\n",
            "called": [
                "deregister_tm_clones",
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105d60",
            "calling": [],
            "imported": false,
            "current_name": "initialize_program_00105d60"
        },
        "FUN_001075e0": {
            "renaming": {
                "FUN_001075e0": "print_gnu_info_001075e0",
                "param_1": "version",
                "pcVar1": "copyrightMessage"
            },
            "code": "\nvoid printGNUInfo_001075e0(undefined8 version)\n\n{\n  char *copyrightMessage;\n  \n  printf(\"GNU %s %s\\n\",version,\"(GNU Binutils for Debian) 2.40\");\n  copyrightMessage = (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n  printf(copyrightMessage);\n  copyrightMessage = (char *)dcgettext(0,\n                             \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                             ,5);\n  printf(copyrightMessage);\n                    \n  exit(0);\n}\n\n",
            "called": [
                "exit",
                "printf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001075e0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "print_gnu_info_001075e0"
        },
        "FUN_00105480": {
            "renaming": {
                "FUN_00105480": "process_entries_00105480",
                "param_1": "archive",
                "param_2": "callback",
                "param_3": "entryNames",
                "param_4": "numEntries",
                "iVar1": "result",
                "__format": "errorFormat",
                "lVar2": "currentEntry",
                "plVar3": "tempEntry",
                "uVar4": "normalizedEntry",
                "plVar5": "entryPtr",
                "local_cc": "countedNamesCounter",
                "local_c8": "buffer"
            },
            "code": "\n\n\nvoid processEntries_00105480(long archive,code *callback,undefined8 *entryNames,int numEntries)\n\n{\n  int result;\n  char *errorFormat;\n  long currentEntry;\n  long *tempEntry;\n  undefined8 normalizedEntry;\n  long *entryPtr;\n  int countedNamesCounter;\n  undefined buffer [152];\n  \n  currentEntry = *(long *)(archive + 0xf0);\n  if (numEntries == 0) {\n    for (; currentEntry != 0; currentEntry = *(long *)(currentEntry + 0xf0)) {\n      (*callback)(currentEntry);\n    }\n  }\n  else {\n    for (; currentEntry != 0; currentEntry = *(long *)(currentEntry + 0xf0)) {\n      *(undefined4 *)(currentEntry + 0xac) = 0;\n    }\n    do {\n      entryPtr = *(long **)(archive + 0xf0);\n      countedNamesCounter = 0;\n      for (; entryPtr != (long *)0x0; entryPtr = (long *)entryPtr[0x1e]) {\n        if (*(int *)((long)entryPtr + 0xac) == 0) {\n          currentEntry = *entryPtr;\n          if (currentEntry == 0) {\n            tempEntry = (long *)entryPtr[0x1d];\n            if ((long *)entryPtr[0x1d] == (long *)0x0) {\n              tempEntry = entryPtr;\n            }\n            (**(code **)(tempEntry[1] + 0x1e8))(entryPtr,buffer);\n          }\n          else if (((*(byte *)(archive + 0x49) & 0x10) == 0) ||\n                  (currentEntry = normalize(currentEntry,archive), currentEntry != 0)) {\n            normalizedEntry = normalize(*entryNames,archive);\n            result = filename_cmp(normalizedEntry,currentEntry);\n            if ((result == 0) &&\n               ((counted_name_mode == '\\0' ||\n                (countedNamesCounter = countedNamesCounter + 1, countedNamesCounter == counted_name_counter)))) {\n              (*callback)();\n              *(undefined4 *)((long)entryPtr + 0xac) = 1;\n              goto LAB_0010553e;\n            }\n          }\n        }\n      }\n      normalizedEntry = *entryNames;\n      errorFormat = (char *)dcgettext(0,\"no entry %s in archive\\n\",5);\n      fprintf(_stderr,errorFormat,normalizedEntry);\nLAB_0010553e:\n      entryNames = entryNames + 1;\n      numEntries = numEntries + -1;\n    } while (numEntries != 0);\n  }\n  return;\n}\n\n",
            "called": [
                "filename_cmp",
                "normalize",
                "map_over_members.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105480",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "process_entries_00105480"
        },
        "FUN_00105cf0": {
            "renaming": {
                "FUN_00105cf0": "FUNC_00105cf0"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00105d03) */\n/* WARNING: Removing unreachable block (ram,0x00105d0f) */\n\nvoid FUNC_00105cf0(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_deregisterTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00105cf0",
            "calling": [
                "__do_global_dtors_aux"
            ],
            "imported": false,
            "current_name": "FUNC_00105cf0"
        },
        "FUN_00102090": {
            "renaming": {},
            "code": "\nvoid bfd_plugin_set_plugin(void)\n\n{\n  bfd_plugin_set_plugin();\n  return;\n}\n\n",
            "called": [
                "bfd_plugin_set_plugin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102090",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102090"
        },
        "FUN_0010e258": {
            "renaming": {},
            "code": "\n\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memmove@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e258",
            "calling": [
                "memmove"
            ],
            "imported": false,
            "current_name": "FUN_0010e258"
        },
        "FUN_00102530": {
            "renaming": {},
            "code": "\nvoid bfd_openr_next_archived_file(void)\n\n{\n  bfd_openr_next_archived_file();\n  return;\n}\n\n",
            "called": [
                "bfd_openr_next_archived_file"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102530",
            "calling": [
                "open_inarch",
                "do_ar_emul_append.constprop.0",
                "ar_open"
            ],
            "imported": false,
            "current_name": "FUN_00102530"
        },
        "FUN_0010e0b8": {
            "renaming": {},
            "code": "\n\n\n\nchar * ctime(time_t *__timer)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ctime@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0b8",
            "calling": [
                "ctime"
            ],
            "imported": false,
            "current_name": "FUN_0010e0b8"
        },
        "FUN_0010e0d8": {
            "renaming": {},
            "code": "\n\n\nvoid getopt_long(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getopt_long@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0d8",
            "calling": [
                "getopt_long"
            ],
            "imported": false,
            "current_name": "FUN_0010e0d8"
        },
        "FUN_00102410": {
            "renaming": {},
            "code": "\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = setlocale(__category,__locale);\n  return pcVar1;\n}\n\n",
            "called": [
                "setlocale"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102410",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102410"
        },
        "FUN_00103a78": {
            "renaming": {
                "FUN_00103a78": "extract_and_print_archive_00103a78",
                "param_1": "archive_info",
                "iVar1": "result",
                "__ptr": "buffer",
                "puVar2": "ptr",
                "uVar3": "bytes_read",
                "uVar4": "error_msg",
                "sVar5": "bytes_written",
                "piVar6": "errno_ptr",
                "unaff_RBP": "remaining_bytes",
                "pcVar7": "error_str",
                "unaff_R13": "total_bytes_read",
                "unaff_R14": "file_size",
                "auStack_b8": "temporary_stack",
                "local_88": "max_bytes_to_read"
            },
            "code": "\n\n\nvoid extract_and_print_archive_00103a78(undefined8 *archive_info)\n\n{\n  int result;\n  void *buffer;\n  undefined8 *ptr;\n  ulong bytes_read;\n  undefined8 error_msg;\n  size_t bytes_written;\n  int *errno_ptr;\n  size_t remaining_bytes;\n  char *error_str;\n  ulong total_bytes_read;\n  ulong file_size;\n  undefined temporary_stack [48];\n  ulong max_bytes_to_read;\n  \n  buffer = (void *)xmalloc(0x2000);\n  ptr = (undefined8 *)archive_info[0x1d];\n  if ((undefined8 *)archive_info[0x1d] == (undefined8 *)0x0) {\n    ptr = archive_info;\n  }\n  result = (**(code **)(ptr[1] + 0x1e8))(archive_info,temporary_stack);\n  if (result == 0) {\n    if (verbose != 0) {\n      printf(\"\\n<%s>\\n\\n\",*archive_info);\n    }\n    total_bytes_read = 0;\n    bfd_seek(archive_info,0,0);\n    goto LAB_00103afd;\n  }\n  archive_info = (undefined8 *)*archive_info;\n  error_str = \"internal stat error on %s\";\n  do {\n    error_msg = dcgettext(0,error_str,5);\n    fatal(error_msg,archive_info);\n    max_bytes_to_read = file_size;\n    do {\n      bytes_written = fwrite(buffer,1,remaining_bytes,_stdout);\n      if (bytes_written != remaining_bytes) {\n        errno_ptr = __errno_location();\n        error_str = strerror(*errno_ptr);\n        fatal(\"stdout: %s\",error_str);\nLAB_00103b91:\n        free(buffer);\n        return;\n      }\n      total_bytes_read = total_bytes_read + bytes_written;\nLAB_00103afd:\n      if (max_bytes_to_read <= total_bytes_read) goto LAB_00103b91;\n      remaining_bytes = max_bytes_to_read - total_bytes_read;\n      if (0x2000 < remaining_bytes) {\n        remaining_bytes = 0x2000;\n      }\n      bytes_read = bfd_bread(buffer,remaining_bytes,archive_info);\n    } while (remaining_bytes == bytes_read);\n    error_str = \"%s is not a valid archive\";\n    archive_info = *(undefined8 **)archive_info[0x1d];\n    file_size = max_bytes_to_read;\n  } while( true );\n}\n\n",
            "called": [
                "fwrite",
                "xmalloc",
                "fatal",
                "bfd_seek",
                "__errno_location",
                "strerror",
                "printf",
                "free",
                "dcgettext",
                "bfd_bread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103a78",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "extract_and_print_archive_00103a78"
        },
        "FUN_0010e1f0": {
            "renaming": {},
            "code": "\n\n\n\nint fileno(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fileno@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1f0",
            "calling": [
                "fileno"
            ],
            "imported": false,
            "current_name": "FUN_0010e1f0"
        },
        "FUN_001023a0": {
            "renaming": {},
            "code": "\nvoid bfd_plugin_set_program_name(void)\n\n{\n  bfd_plugin_set_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_plugin_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023a0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001023a0"
        },
        "FUN_0010e0d0": {
            "renaming": {},
            "code": "\n\n\n\nsize_t strlen(char *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strlen@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0d0",
            "calling": [
                "strlen"
            ],
            "imported": false,
            "current_name": "FUN_0010e0d0"
        },
        "FUN_001024c0": {
            "renaming": {},
            "code": "\nvoid bfd_check_format_matches(void)\n\n{\n  bfd_check_format_matches();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format_matches"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024c0",
            "calling": [
                "open_inarch",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001024c0"
        },
        "FUN_0010e028": {
            "renaming": {},
            "code": "\n\n\n\nint unlink(char *__name)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* unlink@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e028",
            "calling": [
                "unlink"
            ],
            "imported": false,
            "current_name": "FUN_0010e028"
        },
        "FUN_0010e268": {
            "renaming": {},
            "code": "\n\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fopen@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e268",
            "calling": [
                "fopen"
            ],
            "imported": false,
            "current_name": "FUN_0010e268"
        },
        "FUN_0010e148": {
            "renaming": {},
            "code": "\n\n\n\nint close(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* close@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e148",
            "calling": [
                "close"
            ],
            "imported": false,
            "current_name": "FUN_0010e148"
        },
        "FUN_0010e020": {
            "renaming": {},
            "code": "\n\n\n\nint * __errno_location(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __errno_location@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e020",
            "calling": [
                "__errno_location"
            ],
            "imported": false,
            "current_name": "FUN_0010e020"
        },
        "FUN_001058b0": {
            "renaming": {
                "FUN_001058b0": "write_archive_to_temp_file_001058b0",
                "param_1": "archivePaths",
                "cVar1": "returnValue",
                "uVar2": "flags",
                "iVar3": "tempFd",
                "uVar4": "timeData",
                "__format": "errorMessage",
                "__ptr": "tempFileName",
                "__stream": "tempFile",
                "ppcVar5": "outputBfd",
                "uStack0000000000000020": "filePermission",
                "in_stack_00000028": "fileOwner",
                "in_stack_00000038": "fileGroup",
                "local_3c": "tempFileNameIndexes",
                "uStack_33": "fileTypeCharacter",
                "cStack_32": "setgidBitCharacter",
                "cStack_31": "setuidBitCharacter"
            },
            "code": "\nvoid writeArchiveToTempFile_001058b0(undefined8 *archivePaths)\n\n{\n  char returnValue;\n  uint flags;\n  int tempFd;\n  undefined8 timeData;\n  char *errorMessage;\n  void *tempFileName;\n  FILE *tempFile;\n  char **outputBfd;\n  uint filePermission;\n  uint fileOwner;\n  undefined8 fileGroup;\n  int tempFileNameIndexes [2];\n  undefined fileTypeCharacter;\n  char setgidBitCharacter;\n  char setuidBitCharacter;\n  \n  timeData = archivePaths[0x1e];\n  tempFileNameIndexes[0] = -1;\n  tempFileName = (void *)xstrdup(*archivePaths);\n  tempFile = (FILE *)make_tempname(tempFileName,tempFileNameIndexes);\n  tempFd = tempFileNameIndexes[0];\n  if (tempFile != (FILE *)0x0) {\n    output_filename = tempFile;\n    outputBfd = (char **)bfd_fdopenw(tempFile,*(undefined8 *)archivePaths[1],tempFileNameIndexes[0]);\n    if (outputBfd != (char **)0x0) {\n      output_bfd = outputBfd;\n      bfd_set_format(outputBfd,2);\n      flags = (~write_armap >> 0x1f) << 3 | *(byte *)((long)outputBfd + 0x49) & 0xfffffff7;\n      *(char *)((long)outputBfd + 0x49) = (char)flags;\n      if (ar_truncate != '\\0') {\n        *(uint *)((long)outputBfd + 0x44) = *(uint *)((long)outputBfd + 0x44) | 0x400;\n      }\n      if (deterministic != 0) {\n        *(uint *)((long)outputBfd + 0x44) = *(uint *)((long)outputBfd + 0x44) | 0x2000;\n      }\n      if (full_pathname != '\\0') goto LAB_00102d37;\n      while( true ) {\n        if ((make_thin_archive != '\\0') || ((*(byte *)((long)archivePaths + 0x49) & 0x10) != 0)) {\n          *(byte *)((long)outputBfd + 0x49) = (byte)flags | 0x10;\n        }\n        returnValue = bfd_set_archive_head(outputBfd,timeData);\n        if (returnValue != '\\0') break;\n        flags = bfd_fatal(tempFileName);\nLAB_00102d37:\n        *(uint *)((long)outputBfd + 0x44) = *(uint *)((long)outputBfd + 0x44) | 0x100000;\n      }\n      tempFd = dup(tempFd);\n      returnValue = bfd_close(outputBfd);\n      if (returnValue == '\\0') {\n        bfd_fatal(tempFileName);\n        errorMessage = (char *)dcgettext(0,\"<time data corrupt>\",5);\n        sprintf(&stack0xffffffffffffffd8,errorMessage);\n        flags = filePermission & 0xf000;\n        if (flags == 0x4000) {\n          fileTypeCharacter = 100;\n        }\n        else if (flags == 0xa000) {\n          fileTypeCharacter = 0x6c;\n        }\n        else if (flags == 0x6000) {\n          fileTypeCharacter = 0x62;\n        }\n        else if (flags == 0x2000) {\n          fileTypeCharacter = 99;\n        }\n        else if (flags == 0xc000) {\n          fileTypeCharacter = 0x73;\n        }\n        else {\n          fileTypeCharacter = 0x70;\n          if (flags != 0x1000) {\n            fileTypeCharacter = 0x2d;\n          }\n        }\n        setgidBitCharacter = (-((_filePermission & 0x100) == 0) & 0xbbU) + 0x72;\n        setuidBitCharacter = (-((_filePermission & 0x80) == 0) & 0xb6U) + 0x77;\n        fprintf(tempFile,\"%s %ld/%ld %6lu %s \",&setgidBitCharacter,_filePermission >> 0x20,\n                (ulong)fileOwner,fileGroup,&stack0xffffffffffffffd8,\n                _filePermission & 0xffffffff);\n        fputs(*outputBfd,tempFile);\n        if ((char)archivePaths != '\\0') {\n          if ((*(byte *)((long)outputBfd + 0x49) & 0x10) == 0) {\n            if (outputBfd[0xb] != (char *)0x0) {\n              fprintf(tempFile,\" 0x%lx\");\n            }\n          }\n          else if (outputBfd[0xc] != (char *)0x0) {\n            fprintf(tempFile,\" 0x%lx\");\n          }\n        }\n        fputc(10,tempFile);\n        return;\n      }\n      output_bfd = (char **)0x0;\n      output_filename = (FILE *)0x0;\n      bfd_close(archivePaths);\n      tempFd = smart_rename_constprop_0(tempFile,tempFileName,tempFd);\n      if (tempFd == 0) {\n        free(tempFileName);\n        free(tempFile);\n        return;\n      }\n      goto LAB_00102d7a;\n    }\n    close(tempFd);\n    bfd_fatal(tempFileName);\n  }\n  timeData = dcgettext(0,\"could not create temporary file whilst writing archive\",5);\n  bfd_fatal(timeData);\nLAB_00102d7a:\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "make_tempname",
                "close",
                "bfd_fatal",
                "bfd_fdopenw",
                "dcgettext",
                "bfd_set_format",
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001058b0",
            "calling": [
                "ranlib_only",
                "replace_members.cold",
                "main"
            ],
            "imported": false,
            "current_name": "write_archive_to_temp_file_001058b0"
        },
        "FUN_00102420": {
            "renaming": {},
            "code": "\nvoid bfd_openw(void)\n\n{\n  bfd_openw();\n  return;\n}\n\n",
            "called": [
                "bfd_openw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102420",
            "calling": [
                "open_inarch",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102420"
        },
        "FUN_0010e260": {
            "renaming": {},
            "code": "\n\n\n\nint open(char *__file,int __oflag,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* open@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e260",
            "calling": [
                "open"
            ],
            "imported": false,
            "current_name": "FUN_0010e260"
        },
        "FUN_00102540": {
            "renaming": {},
            "code": "\nvoid bfd_bread(void)\n\n{\n  bfd_bread();\n  return;\n}\n\n",
            "called": [
                "bfd_bread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102540",
            "calling": [
                "print_contents",
                "extract_file.cold"
            ],
            "imported": false,
            "current_name": "FUN_00102540"
        },
        "FUN_00102300": {
            "renaming": {},
            "code": "\nvoid bfd_fdopenr(void)\n\n{\n  bfd_fdopenr();\n  return;\n}\n\n",
            "called": [
                "bfd_fdopenr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102300",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102300"
        },
        "FUN_001024d0": {
            "renaming": {},
            "code": "\nvoid bfd_errmsg(void)\n\n{\n  bfd_errmsg();\n  return;\n}\n\n",
            "called": [
                "bfd_errmsg"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024d0",
            "calling": [
                "bfd_nonfatal",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001024d0"
        },
        "FUN_0010e0e0": {
            "renaming": {},
            "code": "\n\n\n\nint printf(char *__format,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* printf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0e0",
            "calling": [
                "printf"
            ],
            "imported": false,
            "current_name": "FUN_0010e0e0"
        },
        "FUN_001023b0": {
            "renaming": {},
            "code": "\n\n\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "malloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023b0",
            "calling": [
                "yy_create_buffer.constprop.0",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_001023b0"
        },
        "FUN_00105a20": {
            "renaming": {
                "FUN_00105a20": "extract_archive_member_00105a20",
                "param_1": "archiveMemberPath",
                "pcVar1": "outputDirectory",
                "pcVar2": "currentChar",
                "uVar3": "basenameResult",
                "uVar4": "errorString",
                "pFVar5": "fileStream",
                "sVar6": "outputDirectoryLength"
            },
            "code": "\nvoid extractArchiveMember_00105a20(char *archiveMemberPath)\n\n{\n  char *outputDirectory;\n  char *currentChar;\n  undefined8 basenameResult;\n  undefined8 errorString;\n  FILE *fileStream;\n  size_t outputDirectoryLength;\n  \n  outputDirectory = output_dir;\n  output_filename = archiveMemberPath;\n  if (*archiveMemberPath == '/') {\nLAB_00102e9a:\n    basenameResult = lbasename();\n    outputDirectory = output_filename;\n    errorString = dcgettext(0,\"illegal output pathname for archive member: %s, using \\'%s\\' instead\",5);\n    non_fatal(errorString,outputDirectory,basenameResult);\n    output_filename = (char *)basenameResult;\n    FUN_00105a68();\n    return;\n  }\n  do {\n    if (*archiveMemberPath == '\\0') {\n      if ((output_dir != (char *)0x0) && (outputDirectoryLength = strlen(output_dir), outputDirectoryLength != 0)) {\n        if (outputDirectory[outputDirectoryLength - 1] == '/') {\n          output_filename = (char *)concat(outputDirectory,output_filename,0);\n        }\n        else {\n          output_filename = (char *)concat(outputDirectory,&DAT_00108260,output_filename,0);\n        }\n      }\n      if (verbose != 0) {\n        printf(\"x - %s\\n\",output_filename);\n      }\n      fileStream = fopen(output_filename,\"w\");\n      if (fileStream == (FILE *)0x0) {\n        perror(output_filename);\n                    \n        xexit(1);\n      }\n      return;\n    }\n    currentChar = archiveMemberPath;\n    if ((*archiveMemberPath == '.') && (currentChar = archiveMemberPath + 1, archiveMemberPath[1] == '.')) {\n      currentChar = archiveMemberPath + 2;\n      if ((archiveMemberPath[2] == '/') || (archiveMemberPath[2] == '\\0')) goto LAB_00102e9a;\n    }\n    for (; (*currentChar != '\\0' && (*currentChar != '/')); currentChar = currentChar + 1) {\n    }\n    for (; archiveMemberPath = currentChar, *currentChar == '/'; currentChar = currentChar + 1) {\n    }\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105a20",
            "calling": [
                "extract_file.cold"
            ],
            "imported": false,
            "current_name": "extract_archive_member_00105a20"
        },
        "FUN_0010e158": {
            "renaming": {},
            "code": "\n\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fputc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e158",
            "calling": [
                "fputc"
            ],
            "imported": false,
            "current_name": "FUN_0010e158"
        },
        "FUN_00102f55": {
            "renaming": {
                "FUN_00102f55": "close_file_00102f55",
                "unaff_R12D": "fileDescriptor",
                "piVar2": "errnoPointer",
                "iVar1": "errnoValue"
            },
            "code": "\nundefined8 closeFile_00102f55(void)\n\n{\n  int errnoValue;\n  int *errnoPointer;\n  int fileDescriptor;\n  \n  errnoPointer = __errno_location();\n  errnoValue = *errnoPointer;\n  close(fileDescriptor);\n  *errnoPointer = errnoValue;\n  return 0xffffffff;\n}\n\n",
            "called": [
                "close",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f55",
            "calling": [
                "simple_copy.constprop.0"
            ],
            "imported": false,
            "current_name": "close_file_00102f55"
        },
        "FUN_001057a0": {
            "renaming": {
                "FUN_001057a0": "decompose_path_001057a0",
                "param_1": "path",
                "param_2": "return_fd",
                "param_4": "flags",
                "iVar1": "result_fd",
                "pcVar2": "last_slash",
                "lVar3": "path_length",
                "lVar4": "loop_counter",
                "lVar5": "last_slash_index",
                "pcVar6": "new_path",
                "bVar7": "null_byte",
                "auVar8": "result",
                "auVar8._0_8_": "result_path",
                "auVar8._8_8_": "result_flags"
            },
            "code": "\nundefined  [16] decomposePath_001057a0(char *path,int *return_fd,undefined8 param_3,undefined8 flags)\n\n{\n  int result_fd;\n  char *last_slash;\n  long path_length;\n  long loop_counter;\n  long last_slash_index;\n  char *new_path;\n  byte null_byte;\n  undefined result [16];\n  \n  null_byte = 0;\n  last_slash = strrchr(path,0x2f);\n  if (last_slash == (char *)0x0) {\n    last_slash = (char *)xmalloc(9);\n    path_length = 0;\n  }\n  else {\n    last_slash_index = (long)last_slash - (long)path;\n    last_slash = (char *)xmalloc(last_slash_index + 0xb);\n    path_length = last_slash_index + 1;\n    new_path = last_slash;\n    for (loop_counter = last_slash_index; loop_counter != 0; loop_counter = loop_counter + -1) {\n      *new_path = *path;\n      path = path + (ulong)null_byte * -2 + 1;\n      new_path = new_path + (ulong)null_byte * -2 + 1;\n    }\n    last_slash[last_slash_index] = '/';\n  }\n  *(undefined8 *)(last_slash + path_length) = 0x5858585858587473;\n  *(undefined *)((long)(last_slash + path_length) + 8) = 0;\n  result_fd = mkstemp(last_slash);\n  if (result_fd == -1) {\n    new_path = (char *)0x0;\n    free(last_slash);\n  }\n  else {\n    *return_fd = result_fd;\n    new_path = last_slash;\n  }\n  result_flags = flags;\n  result_path = new_path;\n  return result;\n}\n\n",
            "called": [
                "xmalloc",
                "strrchr",
                "mkstemp",
                "make_tempname.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001057a0",
            "calling": [
                "ar_open",
                "write_archive"
            ],
            "imported": false,
            "current_name": "decompose_path_001057a0"
        },
        "FUN_00102550": {
            "renaming": {},
            "code": "\n\n\nchar * strerror(int __errnum)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strerror(__errnum);\n  return pcVar1;\n}\n\n",
            "called": [
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102550",
            "calling": [
                "ar_open",
                "print_contents",
                "set_times.cold",
                "get_file_size.cold",
                "smart_rename.constprop.0.cold",
                "extract_file.cold"
            ],
            "imported": false,
            "current_name": "FUN_00102550"
        },
        "FUN_00102310": {
            "renaming": {},
            "code": "\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = fprintf(__stream,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102310",
            "calling": [
                "report",
                "open_inarch",
                "bfd_nonfatal.cold",
                "list_supported_targets",
                "ar_emul_default_usage",
                "main",
                "yyparse.isra.0",
                "map_over_list",
                "ar_open",
                "list_matching_formats",
                "map_over_members.cold",
                "print_arelt_descr.cold",
                "yy_fatal_error",
                "ranlib_usage",
                "usage"
            ],
            "imported": false,
            "current_name": "FUN_00102310"
        },
        "FUN_00102430": {
            "renaming": {},
            "code": "\n\n\nint chmod(char *__file,__mode_t __mode)\n\n{\n  int iVar1;\n  \n  iVar1 = chmod(__file,__mode);\n  return iVar1;\n}\n\n",
            "called": [
                "chmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102430",
            "calling": [
                "extract_file.cold"
            ],
            "imported": false,
            "current_name": "FUN_00102430"
        },
        "FUN_0010e0f8": {
            "renaming": {},
            "code": "\n\n\n\nint dup(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* dup@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0f8",
            "calling": [
                "dup"
            ],
            "imported": false,
            "current_name": "FUN_0010e0f8"
        },
        "FUN_00107c10": {
            "renaming": {
                "FUN_00107c10": "exit_with_error_00107c10",
                "bfd_nonfatal": "handleNonfatalError",
                "xexit": "performExit"
            },
            "code": "\nvoid exitWithError_00107c10(void)\n\n{\n  handleNonfatalError();\n                    \n  performExit(1);\n}\n\n",
            "called": [
                "xexit",
                "bfd_nonfatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c10",
            "calling": [
                "open_inarch",
                "write_archive",
                "replace_members.cold",
                "write_archive.cold",
                "main"
            ],
            "imported": false,
            "current_name": "exit_with_error_00107c10"
        },
        "FUN_001023c0": {
            "renaming": {},
            "code": "\n\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fflush(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023c0",
            "calling": [
                "report",
                "list_matching_formats",
                "prompt",
                "bfd_nonfatal.cold"
            ],
            "imported": false,
            "current_name": "FUN_001023c0"
        },
        "FUN_0010e0f0": {
            "renaming": {},
            "code": "\n\n\n\nchar * strrchr(char *__s,int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strrchr@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0f0",
            "calling": [
                "strrchr"
            ],
            "imported": false,
            "current_name": "FUN_0010e0f0"
        },
        "FUN_001024e0": {
            "renaming": {},
            "code": "\nvoid bfd_find_target(void)\n\n{\n  bfd_find_target();\n  return;\n}\n\n",
            "called": [
                "bfd_find_target"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024e0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001024e0"
        },
        "FUN_001022a0": {
            "renaming": {},
            "code": "\nvoid bfd_create(void)\n\n{\n  bfd_create();\n  return;\n}\n\n",
            "called": [
                "bfd_create"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022a0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001022a0"
        },
        "FUN_00107cc0": {
            "renaming": {
                "FUN_00107cc0": "execute_atexit_functions_00107cc0",
                "plVar4": "atexit_function_ptr",
                "uVar5": "index",
                "lVar1": "count",
                "lVar2": "i",
                "lVar3": "j"
            },
            "code": "\nvoid execute_atexit_functions_00107cc0(void)\n\n{\n  long count;\n  long i;\n  long j;\n  long *atexit_function_ptr;\n  uint index;\n  \n  atexit_function_ptr = (long *)xatexit_head;\n  if (xatexit_head != (undefined *)0x0) {\n    do {\n      index = *(int *)(atexit_function_ptr + 1) - 1;\n      if (-1 < (int)index) {\n        count = (long)(int)index;\n        index = index & 7;\n        (*(code *)atexit_function_ptr[count + 2])();\n        i = count + -1;\n        if (-1 < (int)i) {\n          j = i;\n          if (index != 0) {\n            if (index != 1) {\n              if (index != 2) {\n                if (index != 3) {\n                  if (index != 4) {\n                    if (index != 5) {\n                      if (index != 6) {\n                        (*(code *)atexit_function_ptr[count + 1])();\n                        i = count + -2;\n                      }\n                      (*(code *)atexit_function_ptr[i + 2])();\n                      i = i + -1;\n                    }\n                    (*(code *)atexit_function_ptr[i + 2])();\n                    i = i + -1;\n                  }\n                  (*(code *)atexit_function_ptr[i + 2])();\n                  i = i + -1;\n                }\n                (*(code *)atexit_function_ptr[i + 2])();\n                i = i + -1;\n              }\n              (*(code *)atexit_function_ptr[i + 2])();\n              i = i + -1;\n            }\n            (*(code *)atexit_function_ptr[i + 2])();\n            j = i + -1;\n            if ((int)(i + -1) < 0) goto LAB_00107d96;\n          }\n          do {\n            (*(code *)atexit_function_ptr[j + 2])();\n            count = j + -1;\n            (*(code *)atexit_function_ptr[j + 1])();\n            (*(code *)atexit_function_ptr[j])();\n            (*(code *)atexit_function_ptr[count])();\n            (*(code *)atexit_function_ptr[j + -2])();\n            (*(code *)atexit_function_ptr[j + -3])();\n            (*(code *)atexit_function_ptr[j + -4])();\n            (*(code *)atexit_function_ptr[j + -5])();\n            j = j + -8;\n          } while (-1 < (int)count + -7);\n        }\n      }\nLAB_00107d96:\n      atexit_function_ptr = (long *)*atexit_function_ptr;\n    } while (atexit_function_ptr != (long *)0x0);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107cc0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "execute_atexit_functions_00107cc0"
        },
        "FUN_0010e288": {
            "renaming": {},
            "code": "\n\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* vfprintf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e288",
            "calling": [
                "vfprintf"
            ],
            "imported": false,
            "current_name": "FUN_0010e288"
        },
        "FUN_00105ae0": {
            "renaming": {
                "FUN_00105ae0": "append_constant_propagation_00105ae0",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "param3",
                "param_4": "param4"
            },
            "code": "\nvoid appendConstantPropagation_00105ae0(undefined8 input1,undefined8 input2,undefined param3,undefined param4)\n\n{\n  do_ar_emul_append_constprop_0(input1,input2,param3,param4);\n  return;\n}\n\n",
            "called": [
                "do_ar_emul_append.constprop.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105ae0",
            "calling": [
                "replace_members.cold"
            ],
            "imported": false,
            "current_name": "append_constant_propagation_00105ae0"
        },
        "FUN_00107690": {
            "renaming": {
                "FUN_00107690": "report_and_exit_00107690",
                "param_1": "firstParam",
                "param_2": "secondParam",
                "param_3": "thirdParam",
                "param_4": "fourthParam",
                "param_5": "fifthParam",
                "param_6": "sixthParam",
                "param_7": "seventhParam",
                "param_8": "eighthParam",
                "param_9": "reportPointer",
                "param_10": "tenthParam",
                "param_11": "eleventhParam",
                "param_12": "twelfthParam",
                "param_13": "thirteenthParam",
                "param_14": "fourteenthParam",
                "in_AL": "flag",
                "local_d8": "stackSize",
                "local_d4": "maxLength",
                "local_d0": "stackPointer",
                "local_c8": "localBuffer",
                "local_b8": "tempBuffer",
                "local_b0": "tenthLocal",
                "local_a8": "eleventhLocal",
                "local_a0": "twelfthLocal",
                "local_98": "thirteenthLocal",
                "local_90": "fourteenthLocal",
                "local_88": "firstLocal",
                "local_78": "secondLocal",
                "local_68": "thirdLocal",
                "local_58": "fourthLocal",
                "local_48": "fifthLocal",
                "local_38": "sixthLocal",
                "local_28": "seventhLocal",
                "local_18": "eighthLocal"
            },
            "code": "\nvoid reportAndExit_00107690(undefined4 firstParam,undefined4 secondParam,undefined4 thirdParam,undefined4 fourthParam,\n                 undefined4 fifthParam,undefined4 sixthParam,undefined4 seventhParam,undefined4 eighthParam,\n                 undefined8 reportPointer,undefined8 tenthParam,undefined8 eleventhParam,undefined8 twelfthParam,\n                 undefined8 thirteenthParam,undefined8 fourteenthParam)\n\n{\n  char flag;\n  undefined4 stackSize;\n  undefined4 maxLength;\n  undefined *stackPointer;\n  undefined *localBuffer;\n  undefined tempBuffer [8];\n  undefined8 tenthLocal;\n  undefined8 eleventhLocal;\n  undefined8 twelfthLocal;\n  undefined8 thirteenthLocal;\n  undefined8 fourteenthLocal;\n  undefined4 firstLocal;\n  undefined4 secondLocal;\n  undefined4 thirdLocal;\n  undefined4 fourthLocal;\n  undefined4 fifthLocal;\n  undefined4 sixthLocal;\n  undefined4 seventhLocal;\n  undefined4 eighthLocal;\n  \n  if (flag != '\\0') {\n    firstLocal = firstParam;\n    secondLocal = secondParam;\n    thirdLocal = thirdParam;\n    fourthLocal = fourthParam;\n    fifthLocal = fifthParam;\n    sixthLocal = sixthParam;\n    seventhLocal = seventhParam;\n    eighthLocal = eighthParam;\n  }\n  stackPointer = &stack0x00000008;\n  stackSize = 8;\n  localBuffer = tempBuffer;\n  maxLength = 0x30;\n  tenthLocal = tenthParam;\n  eleventhLocal = eleventhParam;\n  twelfthLocal = twelfthParam;\n  thirteenthLocal = thirteenthParam;\n  fourteenthLocal = fourteenthParam;\n  report(reportPointer,&stackSize);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "xexit",
                "report"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107690",
            "calling": [
                "open_inarch",
                "print_contents",
                "replace_members.cold",
                "extract_file.cold",
                "main"
            ],
            "imported": false,
            "current_name": "report_and_exit_00107690"
        },
        "FUN_0010266f": {
            "renaming": {
                "FUN_0010266f": "print_supported_targets_0010266f",
                "param_1": "target",
                "param_2": "output",
                "lVar1": "targetAddr",
                "pcVar2": "targetLabel",
                "__ptr": "targetList",
                "plVar3": "currentTarget"
            },
            "code": "\nvoid printSupportedTargets_0010266f(long target,FILE *output)\n\n{\n  long targetAddr;\n  char *targetLabel;\n  long *targetList;\n  long *currentTarget;\n  \n  if (target == 0) {\n    targetLabel = (char *)dcgettext(0,\"Supported targets:\",5);\n    fprintf(output,targetLabel);\n  }\n  else {\n    targetLabel = (char *)dcgettext(0,\"%s: supported targets:\",5);\n    fprintf(output,targetLabel,target);\n  }\n  targetList = (long *)bfd_target_list();\n  currentTarget = targetList;\n  while( true ) {\n    targetAddr = *currentTarget;\n    currentTarget = currentTarget + 1;\n    if (targetAddr == 0) break;\n    fprintf(output,\" %s\");\n  }\n  fputc(10,output);\n  free(targetList);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fputc",
                "free",
                "dcgettext",
                "bfd_target_list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010266f",
            "calling": [
                "ranlib_usage",
                "usage"
            ],
            "imported": false,
            "current_name": "print_supported_targets_0010266f"
        },
        "FUN_00102440": {
            "renaming": {},
            "code": "\nvoid bfd_set_error_program_name(void)\n\n{\n  bfd_set_error_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102440",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102440"
        },
        "FUN_0010e280": {
            "renaming": {},
            "code": "\n\n\n\nvoid perror(char *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* perror@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e280",
            "calling": [
                "perror"
            ],
            "imported": false,
            "current_name": "FUN_0010e280"
        },
        "FUN_00102560": {
            "renaming": {},
            "code": "\n\n\nint getc(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = getc(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102560",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102560"
        },
        "FUN_00105830": {
            "renaming": {
                "FUN_00105830": "get_truncated_path_00105830",
                "param_1": "originalPath",
                "param_2": "fileInfo",
                "param_3": "param3",
                "param_4": "param4",
                "lVar1": "fileAddress",
                "sVar2": "originalPathLength",
                "__s": "fileName",
                "uVar3": "maxPathLength",
                "pcVar4": "currentChar",
                "bVar5": "isBackward",
                "auVar6": "result"
            },
            "code": "\nundefined  [16] getTruncatedPath_00105830(char *originalPath,long fileInfo,undefined8 param3,undefined8 param4)\n\n{\n  long fileAddress;\n  size_t originalPathLength;\n  char *fileName;\n  ulong maxPathLength;\n  char *currentChar;\n  byte isBackward;\n  undefined result [16];\n  \n  isBackward = 0;\n  if (full_pathname == '\\0') {\n    fileName = (char *)lbasename();\n    originalPath = fileName;\n    if ((ar_truncate != '\\0') && (fileInfo != 0)) {\n      originalPathLength = strlen(fileName);\n      maxPathLength = (ulong)*(byte *)(*(long *)(fileInfo + 8) + 0x1e);\n      if (maxPathLength < originalPathLength) {\n        originalPath = (char *)xmalloc(maxPathLength + 1);\n        fileAddress = *(long *)(fileInfo + 8);\n        currentChar = originalPath;\n        for (maxPathLength = (ulong)*(byte *)(fileAddress + 0x1e); maxPathLength != 0; maxPathLength = maxPathLength - 1) {\n          *currentChar = *fileName;\n          fileName = fileName + (ulong)isBackward * -2 + 1;\n          currentChar = currentChar + (ulong)isBackward * -2 + 1;\n        }\n        originalPath[*(byte *)(fileAddress + 0x1e)] = '\\0';\n      }\n    }\n  }\n  result._8_8_ = param4;\n  result._0_8_ = originalPath;\n  return result;\n}\n\n",
            "called": [
                "normalize.cold",
                "lbasename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105830",
            "calling": [
                "replace_members.cold",
                "map_over_members",
                "main"
            ],
            "imported": false,
            "current_name": "get_truncated_path_00105830"
        },
        "FUN_0010e160": {
            "renaming": {},
            "code": "\n\n\n\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* read@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e160",
            "calling": [
                "read"
            ],
            "imported": false,
            "current_name": "FUN_0010e160"
        },
        "FUN_00102200": {
            "renaming": {},
            "code": "\nvoid concat(void)\n\n{\n  concat();\n  return;\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102200",
            "calling": [
                "FUN_00105a68",
                "open_output_file.isra.0.cold"
            ],
            "imported": false,
            "current_name": "FUN_00102200"
        },
        "FUN_00102320": {
            "renaming": {},
            "code": "\n\n\nlong ftell(FILE *__stream)\n\n{\n  long lVar1;\n  \n  lVar1 = ftell(__stream);\n  return lVar1;\n}\n\n",
            "called": [
                "ftell"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102320",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102320"
        },
        "FUN_00107c20": {
            "renaming": {
                "FUN_00107c20": "print_error_message_00107c20",
                "param_1": "errorMessage",
                "iVar1": "error",
                "uVar2": "errorString",
                "in_R10": "additionalInfo"
            },
            "code": "\n\n\nvoid printErrorMessage_00107c20(long errorMessage)\n\n{\n  int error;\n  undefined8 errorString;\n  undefined8 additionalInfo;\n  \n  error = bfd_get_error();\n  if (error == 0) {\n    errorString = dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    errorString = bfd_errmsg(error);\n  }\n  fflush(_stdout);\n  if (errorMessage != 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",program_name,errorMessage,errorString,additionalInfo);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",program_name,errorString,additionalInfo);\n  return;\n}\n\n",
            "called": [
                "bfd_nonfatal.cold",
                "bfd_get_error",
                "bfd_errmsg"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c20",
            "calling": [
                "open_inarch",
                "bfd_fatal",
                "main"
            ],
            "imported": false,
            "current_name": "print_error_message_00107c20"
        },
        "FUN_001022b0": {
            "renaming": {},
            "code": "\nvoid bfd_init(void)\n\n{\n  bfd_init();\n  return;\n}\n\n",
            "called": [
                "bfd_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022b0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001022b0"
        },
        "FUN_001023d0": {
            "renaming": {},
            "code": "\nvoid unlink_if_ordinary(void)\n\n{\n  unlink_if_ordinary();\n  return;\n}\n\n",
            "called": [
                "unlink_if_ordinary"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023d0",
            "calling": [
                "remove_output.cold"
            ],
            "imported": false,
            "current_name": "FUN_001023d0"
        },
        "FUN_001024f0": {
            "renaming": {},
            "code": "\n\n\nint sprintf(char *__s,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = sprintf(__s,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024f0",
            "calling": [
                "print_arelt_descr.cold",
                "print_arelt_descr"
            ],
            "imported": false,
            "current_name": "FUN_001024f0"
        },
        "FUN_00102e57": {
            "renaming": {
                "FUN_00102e57": "create_output_file_00102e57",
                "pFVar1": "filePointer",
                "output_filename": "outputFilename"
            },
            "code": "\nvoid createOutputFile_00102e57(void)\n\n{\n  FILE *filePointer;\n  \n  outputFilename = (char *)concat();\n  if (verbose != 0) {\n    printf(\"x - %s\\n\",outputFilename);\n  }\n  filePointer = fopen(outputFilename,\"w\");\n  if (filePointer != (FILE *)0x0) {\n    return;\n  }\n  perror(outputFilename);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102e57",
            "calling": [
                "FUN_00105a68"
            ],
            "imported": false,
            "current_name": "create_output_file_00102e57"
        },
        "FUN_0010e058": {
            "renaming": {},
            "code": "\n\n\n\nint ferror(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ferror@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e058",
            "calling": [
                "ferror"
            ],
            "imported": false,
            "current_name": "FUN_0010e058"
        },
        "FUN_00105af0": {
            "renaming": {
                "FUN_00105af0": "process_files_00105af0",
                "param_1": "file_list",
                "param_2": "archive",
                "param_3": "condition_1",
                "param_4": "condition_2",
                "cVar1": "is_bfd_format",
                "uVar2": "result",
                "lVar3": "archived_file",
                "uVar4": "total_count"
            },
            "code": "\nulong process_files_00105af0(long *file_list,long archive,char condition_1,char condition_2)\n\n{\n  char is_bfd_format;\n  uint result;\n  long archived_file;\n  ulong total_count;\n  \n  if (condition_2 == '\\0') {\n    if (condition_1 != '\\0') {\n      total_count = do_ar_emul_append_constprop_0_cold();\n      return total_count;\n    }\n  }\n  else {\n    is_bfd_format = bfd_check_format(archive,2);\n    if (is_bfd_format != '\\0') {\n      total_count = 0;\n      for (archived_file = bfd_openr_next_archived_file(archive,0); archived_file != 0;\n          archived_file = bfd_openr_next_archived_file(archive,archived_file)) {\n        result = process_files_00105af0(file_list,archived_file,condition_1,1);\n        if ((char)result != '\\0') {\n          total_count = (ulong)result;\n          file_list = (long *)(*file_list + 0xf0);\n        }\n      }\n      return total_count;\n    }\n    if (condition_1 != '\\0') {\n      total_count = do_ar_emul_append_constprop_0_cold();\n      return total_count;\n    }\n  }\n  *(long *)(archive + 0xf0) = *file_list;\n  *file_list = archive;\n  return 1;\n}\n\n",
            "called": [
                "do_ar_emul_append.constprop.0.cold",
                "bfd_openr_next_archived_file",
                "do_ar_emul_append.constprop.0",
                "bfd_check_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105af0",
            "calling": [
                "ar_emul_default_append",
                "do_ar_emul_append.constprop.0",
                "replace_members.cold"
            ],
            "imported": false,
            "current_name": "process_files_00105af0"
        },
        "FUN_00102330": {
            "renaming": {},
            "code": "\n\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = stat(__file,__buf);\n  return iVar1;\n}\n\n",
            "called": [
                "stat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102330",
            "calling": [
                "open_inarch",
                "replace_members.cold",
                "get_file_size",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102330"
        },
        "FUN_00102450": {
            "renaming": {},
            "code": "\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memmove(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102450",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102450"
        },
        "FUN_00102ba1": {
            "renaming": {
                "FUN_00102ba1": "deallocate_memory_00102ba1",
                "unaff_RBP": "memory_address",
                "unaff_retaddr": "return_address",
                "auVar1": "temp_variable"
            },
            "code": "\nundefined  [16] deallocate_memory_00102ba1(void)\n\n{\n  undefined temp_variable [16];\n  void *memory_address;\n  ulong return_address;\n  \n  free(memory_address);\n  temp_variable._8_8_ = 0;\n  temp_variable._0_8_ = return_address;\n  return temp_variable << 0x40;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102ba1",
            "calling": [
                "make_tempname"
            ],
            "imported": false,
            "current_name": "deallocate_memory_00102ba1"
        },
        "FUN_00102210": {
            "renaming": {},
            "code": "\nvoid bfd_target_list(void)\n\n{\n  bfd_target_list();\n  return;\n}\n\n",
            "called": [
                "bfd_target_list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102210",
            "calling": [
                "list_supported_targets"
            ],
            "imported": false,
            "current_name": "FUN_00102210"
        },
        "FUN_00102570": {
            "renaming": {},
            "code": "\nvoid bfd_fdopenw(void)\n\n{\n  bfd_fdopenw();\n  return;\n}\n\n",
            "called": [
                "bfd_fdopenw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102570",
            "calling": [
                "ar_open",
                "write_archive"
            ],
            "imported": false,
            "current_name": "FUN_00102570"
        },
        "FUN_00102d2f": {
            "renaming": {
                "FUN_00102d2f": "print_file_info_00102d2f",
                "bVar1": "fatalError",
                "cVar2": "result",
                "iVar3": "renameResult",
                "__format": "corruptTimeFormat",
                "uVar4": "fileType",
                "uStack0000000000000068": "filePermissions",
                "uStack000000000000006c": "fileSize",
                "in_stack_00000070": "userId",
                "in_stack_00000080": "modificationTime",
                "uStack0000000000000015": "firstCharacter",
                "cStack0000000000000016": "permissionOwnerRead",
                "cStack0000000000000017": "permissionOwnerWrite",
                "in_stack_00000018": "permissionOwnerExecute",
                "cStack0000000000000019": "permissionGroupRead",
                "cStack000000000000001a": "permissionGroupWrite",
                "cStack000000000000001b": "permissionGroupExecute",
                "cStack000000000000001c": "permissionOtherRead",
                "cStack000000000000001d": "permissionOtherWrite",
                "cStack000000000000001e": "permissionOtherExecute"
            },
            "code": "\nvoid printFileInfo_00102d2f(void)\n\n{\n  byte fatalError;\n  char result;\n  int renameResult;\n  char *corruptTimeFormat;\n  uint fileType;\n  char **unaff_RBX;\n  FILE *unaff_RBP;\n  long unaff_R12;\n  void *unaff_R13;\n  int unaff_R14D;\n  undefined firstCharacter;\n  char permissionOwnerRead;\n  char permissionOwnerWrite;\n  char permissionOwnerExecute;\n  char permissionGroupRead;\n  char permissionGroupWrite;\n  char permissionGroupExecute;\n  char permissionOtherRead;\n  char permissionOtherWrite;\n  char permissionOtherExecute;\n  undefined uStack000000000000001f;\n  uint filePermissions;\n  uint fileSize;\n  uint userId;\n  undefined8 modificationTime;\n  \n  do {\n    fatalError = bfd_fatal();\n    *(uint *)((long)unaff_RBX + 0x44) = *(uint *)((long)unaff_RBX + 0x44) | 0x100000;\n    if ((make_thin_archive != '\\0') || ((*(byte *)(unaff_R12 + 0x49) & 0x10) != 0)) {\n      *(byte *)((long)unaff_RBX + 0x49) = fatalError | 0x10;\n    }\n    result = bfd_set_archive_head();\n  } while (result == '\\0');\n  dup(unaff_R14D);\n  result = bfd_close();\n  if (result != '\\0') {\n    output_bfd = 0;\n    output_filename = 0;\n    bfd_close();\n    renameResult = smart_rename_constprop_0();\n    if (renameResult == 0) {\n      free(unaff_R13);\n      free(unaff_RBP);\n      return;\n    }\n                    \n    xexit(1);\n  }\n  bfd_fatal();\n  corruptTimeFormat = (char *)dcgettext(0,\"<time data corrupt>\",5);\n  sprintf(&stack0x00000020,corruptTimeFormat);\n  fileType = filePermissions & 0xf000;\n  if (fileType == 0x4000) {\n    firstCharacter = 100;\n  }\n  else if (fileType == 0xa000) {\n    firstCharacter = 0x6c;\n  }\n  else if (fileType == 0x6000) {\n    firstCharacter = 0x62;\n  }\n  else if (fileType == 0x2000) {\n    firstCharacter = 99;\n  }\n  else if (fileType == 0xc000) {\n    firstCharacter = 0x73;\n  }\n  else {\n    firstCharacter = 0x70;\n    if (fileType != 0x1000) {\n      firstCharacter = 0x2d;\n    }\n  }\n  permissionOwnerRead = (-((filePermissions & 0x100) == 0) & 0xbbU) + 0x72;\n  permissionOwnerWrite = (-((filePermissions & 0x80) == 0) & 0xb6U) + 0x77;\n  permissionOwnerExecute = (-((filePermissions & 0x40) == 0) & 0xb5U) + 0x78;\n  permissionGroupRead = (-((filePermissions & 0x20) == 0) & 0xbbU) + 0x72;\n  permissionGroupWrite = (-((filePermissions & 0x10) == 0) & 0xb6U) + 0x77;\n  permissionGroupExecute = (-((filePermissions & 8) == 0) & 0xb5U) + 0x78;\n  permissionOtherRead = (-((filePermissions & 4) == 0) & 0xbbU) + 0x72;\n  permissionOtherWrite = (-((filePermissions & 2) == 0) & 0xb6U) + 0x77;\n  permissionOtherExecute = (-((filePermissions & 1) == 0) & 0xb5U) + 0x78;\n  if ((filePermissions & 0x800) != 0) {\n    if (permissionOwnerExecute == 'x') {\n      permissionOwnerExecute = 's';\n    }\n    else {\n      permissionOwnerExecute = 'S';\n    }\n  }\n  if ((filePermissions & 0x400) != 0) {\n    if (permissionGroupExecute == 'x') {\n      permissionGroupExecute = 's';\n    }\n    else {\n      permissionGroupExecute = 'S';\n    }\n  }\n  if ((filePermissions & 0x200) != 0) {\n    if (permissionOtherExecute == 'x') {\n      permissionOtherExecute = 't';\n    }\n    else {\n      permissionOtherExecute = 'T';\n    }\n  }\n  uStack000000000000001f = 0;\n  fprintf(unaff_RBP,\"%s %ld/%ld %6lu %s \",&stack0x00000016,(ulong)fileSize,\n          (ulong)userId,modificationTime,&stack0x00000020,(ulong)filePermissions)\n  ;\n  fputs(*unaff_RBX,unaff_RBP);\n  if ((char)unaff_R12 != '\\0') {\n    if ((*(byte *)((long)unaff_RBX + 0x49) & 0x10) == 0) {\n      if (unaff_RBX[0xb] != (char *)0x0) {\n        fprintf(unaff_RBP,\" 0x%lx\");\n      }\n    }\n    else if (unaff_RBX[0xc] != (char *)0x0) {\n      fprintf(unaff_RBP,\" 0x%lx\");\n    }\n  }\n  fputc(10,unaff_RBP);\n  return;\n}\n\n",
            "called": [
                "xexit",
                "bfd_fatal",
                "dup",
                "smart_rename.constprop.0",
                "bfd_close",
                "bfd_set_archive_head",
                "free",
                "write_archive.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102d2f",
            "calling": [
                "write_archive.cold"
            ],
            "imported": false,
            "current_name": "print_file_info_00102d2f"
        },
        "FUN_001021a0": {
            "renaming": {},
            "code": "\n\n\nint printf(char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = printf(__format);\n  return iVar1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021a0",
            "calling": [
                "do_ar_emul_append.constprop.0.cold",
                "ar_emul_default_replace",
                "print_contents",
                "prompt",
                "FUN_00105a68",
                "yyerror.constprop.0",
                "print_version",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_001021a0"
        },
        "FUN_001033b0": {
            "renaming": {
                "FUN_001033b0": "print_and_exit_001033b0",
                "param_1": "message",
                "_stderr": "errorFile"
            },
            "code": "\n\n\nvoid printAndExit_001033b0(undefined8 message)\n\n{\n  fprintf(errorFile,\"%s\\n\",message);\n                    \n  exit(2);\n}\n\n",
            "called": [
                "exit",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001033b0",
            "calling": [
                "yy_create_buffer.constprop.0",
                "yyensure_buffer_stack",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "print_and_exit_001033b0"
        },
        "FUN_001022c0": {
            "renaming": {},
            "code": "\nvoid lbasename(void)\n\n{\n  lbasename();\n  return;\n}\n\n",
            "called": [
                "lbasename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022c0",
            "calling": [
                "replace_members.cold",
                "normalize",
                "main",
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "FUN_001022c0"
        },
        "FUN_001023e0": {
            "renaming": {},
            "code": "\n\n\nint mkstemp(char *__template)\n\n{\n  int iVar1;\n  \n  iVar1 = mkstemp(__template);\n  return iVar1;\n}\n\n",
            "called": [
                "mkstemp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023e0",
            "calling": [
                "make_tempname"
            ],
            "imported": false,
            "current_name": "FUN_001023e0"
        },
        "FUN_00102c25": {
            "renaming": {
                "FUN_00102c25": "extract_archive_files_00102c25",
                "param_7": "error_flags",
                "param_11": "file_permissions",
                "param_12": "file_size",
                "iVar1": "comparison_result",
                "iVar2": "function_result",
                "pcVar4": "error_message",
                "piVar3": "errno_location",
                "plVar8": "file_ptr",
                "__ptr": "buffer_ptr",
                "__n": "bytes_read",
                "lVar7": "loop_counter",
                "puVar9": "param_ptr",
                "pplVar6": "pointer_ptr",
                "unaff_RBX": "register_RBX",
                "uVar5": "result",
                "uVar10": "bytes_written",
                "sVar11": "bytes_to_read"
            },
            "code": "\nlong * extract_archive_files_00102c25(void)\n\n{\n  int comparison_result;\n  int function_result;\n  int *errno_location;\n  char *error_message;\n  undefined8 result;\n  long **pointer_ptr;\n  void *buffer_ptr;\n  size_t bytes_read;\n  long loop_counter;\n  long **register_RBX;\n  long *file_ptr;\n  undefined4 *param_ptr;\n  ulong bytes_written;\n  size_t bytes_to_read;\n  undefined4 *error_flags;\n  __mode_t file_permissions;\n  ulong file_size;\n  \n  param_ptr = error_flags;\n  for (loop_counter = 0x24; loop_counter != 0; loop_counter = loop_counter + -1) {\n    *param_ptr = 0;\n    param_ptr = param_ptr + 1;\n  }\n  pointer_ptr = (long **)register_RBX[0x1d];\n  if ((long **)register_RBX[0x1d] == (long **)0x0) {\n    pointer_ptr = register_RBX;\n  }\n  function_result = (*(code *)pointer_ptr[1][0x3d])();\n  if (function_result != 0) {\n    file_ptr = *register_RBX;\n    result = dcgettext(0,\"internal stat error on %s\",5);\n    function_result = fatal(result,file_ptr);\n    result = posname;\n    if (function_result == 3) {\n      for (; *file_ptr != 0; file_ptr = (long *)(*file_ptr + 0xf0)) {\n      }\n    }\n    else {\n      for (; (undefined8 *)*file_ptr != (undefined8 *)0x0; file_ptr = (long *)(*file_ptr + 0xf0)) {\n        comparison_result = filename_cmp(*(undefined8 *)*file_ptr,result);\n        if (comparison_result == 0) {\n          if (function_result != 2) {\n            return file_ptr;\n          }\n          return (long *)(*file_ptr + 0xf0);\n        }\n      }\n    }\n    return file_ptr;\n  }\n  bfd_seek();\n  output_file = (FILE *)0x0;\n  if (file_size == 0) {\nLAB_00102ca2:\n    output_file = (FILE *)open_output_file_isra_0(*register_RBX);\n  }\n  else {\n    bytes_written = 0;\n    buffer_ptr = (void *)xmalloc(0x2000);\n    do {\n      bytes_to_read = file_size - bytes_written;\n      if (0x2000 < bytes_to_read) {\n        bytes_to_read = 0x2000;\n      }\n      bytes_read = bfd_bread(buffer_ptr,bytes_to_read);\n      if (bytes_to_read != bytes_read) {\nLAB_00102c78:\n        register_RBX = (long **)*register_RBX[0x1d];\n        result = dcgettext(0,\"%s is not a valid archive\",5);\n        fatal(result,register_RBX);\n        goto LAB_00102ca2;\n      }\n      if (output_file == (FILE *)0x0) {\n        output_file = (FILE *)open_output_file_isra_0(*register_RBX);\n      }\n      bytes_to_read = fwrite(buffer_ptr,1,bytes_read,output_file);\n      if (bytes_to_read != bytes_read) {\n        errno_location = __errno_location();\n        error_message = strerror(*errno_location);\n        fatal(\"%s: %s\",output_filename,error_message);\n        goto LAB_00102c78;\n      }\n      bytes_written = bytes_written + bytes_read;\n    } while (bytes_written < file_size);\n    free(buffer_ptr);\n  }\n  fclose(output_file);\n  error_message = output_filename;\n  output_file = (FILE *)0x0;\n  chmod(output_filename,file_permissions);\n  if (preserve_dates != 0) {\n    set_times(error_message,error_flags);\n  }\n  output_filename = (char *)0x0;\n  return (long *)0x0;\n}\n\n",
            "called": [
                "open_output_file.isra.0",
                "strerror",
                "fclose",
                "set_times",
                "dcgettext",
                "bfd_bread",
                "chmod",
                "fwrite",
                "fatal",
                "xmalloc",
                "bfd_seek",
                "__errno_location",
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102c25",
            "calling": [
                "extract_file"
            ],
            "imported": false,
            "current_name": "extract_archive_files_00102c25"
        },
        "FUN_0010e188": {
            "renaming": {},
            "code": "\n\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcmp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e188",
            "calling": [
                "strcmp"
            ],
            "imported": false,
            "current_name": "FUN_0010e188"
        },
        "FUN_00102220": {
            "renaming": {},
            "code": "\nvoid bfd_get_error(void)\n\n{\n  bfd_get_error();\n  return;\n}\n\n",
            "called": [
                "bfd_get_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102220",
            "calling": [
                "open_inarch",
                "bfd_nonfatal",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102220"
        },
        "FUN_00102bb0": {
            "renaming": {
                "FUN_00102bb0": "reverse_string_00102bb0",
                "in_RAX": "inputString",
                "sVar2": "inputLength",
                "puVar3": "reversedString",
                "uVar4": "maxLength",
                "unaff_RBX": "originalString",
                "unaff_RBP": "framePointer",
                "puVar5": "currentCharPtr",
                "bVar6": "byteCounter",
                "auVar7": "returnValue",
                "unaff_retaddr": "returnAddress",
                "xmalloc": "allocateMemory"
            },
            "code": "\nundefined  [16] reverseString_00102bb0(void)\n\n{\n  long lVar1;\n  char *inputString;\n  size_t inputLength;\n  undefined *reversedString;\n  ulong maxLength;\n  undefined *originalString;\n  long framePointer;\n  undefined *currentCharPtr;\n  byte byteCounter;\n  undefined returnValue [16];\n  undefined8 returnAddress;\n  \n  byteCounter = 0;\n  inputLength = strlen(inputString);\n  maxLength = (ulong)*(byte *)(*(long *)(framePointer + 8) + 0x1e);\n  reversedString = originalString;\n  if (maxLength < inputLength) {\n    reversedString = (undefined *)allocateMemory(maxLength + 1);\n    lVar1 = *(long *)(framePointer + 8);\n    currentCharPtr = reversedString;\n    for (maxLength = (ulong)*(byte *)(lVar1 + 0x1e); maxLength != 0; maxLength = maxLength - 1) {\n      *currentCharPtr = *originalString;\n      originalString = originalString + (ulong)byteCounter * -2 + 1;\n      currentCharPtr = currentCharPtr + (ulong)byteCounter * -2 + 1;\n    }\n    reversedString[*(byte *)(lVar1 + 0x1e)] = 0;\n  }\n  returnValue._8_8_ = returnAddress;\n  returnValue._0_8_ = reversedString;\n  return returnValue;\n}\n\n",
            "called": [
                "xmalloc",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102bb0",
            "calling": [
                "normalize"
            ],
            "imported": false,
            "current_name": "reverse_string_00102bb0"
        },
        "FUN_0010e060": {
            "renaming": {},
            "code": "\n\n\n\nint isatty(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* isatty@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e060",
            "calling": [
                "isatty"
            ],
            "imported": false,
            "current_name": "FUN_0010e060"
        },
        "FUN_00102340": {
            "renaming": {},
            "code": "\nvoid bfd_set_format(void)\n\n{\n  bfd_set_format();\n  return;\n}\n\n",
            "called": [
                "bfd_set_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102340",
            "calling": [
                "open_inarch",
                "ar_open",
                "write_archive",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102340"
        },
        "FUN_00102100": {
            "renaming": {},
            "code": "\nvoid filename_cmp(void)\n\n{\n  filename_cmp();\n  return;\n}\n\n",
            "called": [
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102100",
            "calling": [
                "map_over_list",
                "replace_members.cold",
                "map_over_members",
                "get_pos_bfd.cold",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102100"
        },
        "FUN_00102460": {
            "renaming": {},
            "code": "\n\n\nint open(char *__file,int __oflag,...)\n\n{\n  int iVar1;\n  \n  iVar1 = open(__file,__oflag);\n  return iVar1;\n}\n\n",
            "called": [
                "open"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102460",
            "calling": [
                "simple_copy.constprop.0",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102460"
        },
        "FUN_00102580": {
            "renaming": {},
            "code": "\nvoid bfd_seek(void)\n\n{\n  bfd_seek();\n  return;\n}\n\n",
            "called": [
                "bfd_seek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102580",
            "calling": [
                "print_contents",
                "extract_file.cold"
            ],
            "imported": false,
            "current_name": "FUN_00102580"
        },
        "FUN_0010e180": {
            "renaming": {},
            "code": "\n\n\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* calloc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e180",
            "calling": [
                "calloc"
            ],
            "imported": false,
            "current_name": "FUN_0010e180"
        }
    },
    "used_tokens": 98867,
    "layers": [
        [
            "FUN_00102cd9",
            "FUN_001079c0",
            "FUN_00105a68",
            "FUN_001032a8",
            "FUN_00102f96",
            "FUN_0010342d",
            "FUN_00107920",
            "FUN_001033d6",
            "FUN_00102000",
            "FUN_00105870",
            "FUN_00103ba8",
            "FUN_00103ddc",
            "FUN_001078c0",
            "FUN_001031a5",
            "FUN_00103df9",
            "FUN_00102bf5",
            "FUN_00102020",
            "FUN_00102943",
            "FUN_00107c80",
            "FUN_00102d8c",
            "FUN_00105300",
            "FUN_00105db0",
            "FUN_00103bd1",
            "FUN_00102710",
            "FUN_00103e95",
            "FUN_00107730",
            "FUN_001031cf",
            "FUN_0010312d",
            "FUN_00105c00",
            "FUN_001052a0",
            "FUN_0010336b",
            "FUN_00103c60",
            "FUN_0010300e",
            "FUN_00107740",
            "FUN_001028ed",
            "FUN_001025a0",
            "FUN_0010284b",
            "FUN_00105cc0",
            "FUN_00102f08",
            "FUN_0010285f",
            "FUN_0010394a",
            "FUN_00105bb0",
            "FUN_00107640",
            "FUN_0010315d",
            "FUN_00107890",
            "FUN_00103172",
            "FUN_001030ed",
            "FUN_00105bc0",
            "FUN_00107650",
            "FUN_00102f1e",
            "FUN_00102fd7",
            "FUN_00105d60",
            "FUN_001075e0",
            "FUN_00105480",
            "FUN_00103a78",
            "FUN_001058b0",
            "FUN_00105a20",
            "FUN_00102f55",
            "FUN_001057a0",
            "FUN_00107c10",
            "FUN_00107cc0",
            "FUN_00105ae0",
            "FUN_00107690",
            "FUN_0010266f",
            "FUN_00105830",
            "FUN_00107c20",
            "FUN_00102e57",
            "FUN_00102ba1",
            "FUN_00102d2f",
            "FUN_001033b0",
            "FUN_00102c25",
            "FUN_00102bb0"
        ],
        [
            "FUN_00102e6f",
            "FUN_00105570"
        ],
        [
            "FUN_00105af0"
        ]
    ],
    "locked_functions": []
}