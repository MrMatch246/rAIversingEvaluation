{
    "functions": {
        "FUN_00113dfe": {
            "renaming": {
                "FUN_00113dfe": "update_type_with_const_prop_00113dfe",
                "param_1": "type",
                "param_2": "value",
                "lVar1": "typeAddress"
            },
            "code": "\nvoid updateTypeWithConstProp_00113dfe(undefined4 type,undefined value)\n\n{\n  long typeAddress;\n  \n  typeAddress = debug_make_type_constprop_0(3,type);\n  if (typeAddress != 0) {\n    *(undefined *)(typeAddress + 0x10) = value;\n  }\n  return;\n}\n\n",
            "called": [
                "debug_make_type.constprop.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113dfe",
            "calling": [
                "stab_demangle_v3_arg",
                "parse_coff_type.lto_priv.0",
                "parse_stab_type",
                "stab_find_type",
                "stab_demangle_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "update_type_with_const_prop_00113dfe"
        },
        "FUN_001045d0": {
            "renaming": {},
            "code": "\n\n\nint strncasecmp(char *__s1,char *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = strncasecmp(__s1,__s2,__n);\n  return iVar1;\n}\n\n",
            "called": [
                "strncasecmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001045d0",
            "calling": [
                "main",
                "parse_flags.cold"
            ],
            "imported": false,
            "current_name": "FUN_001045d0"
        },
        "FUN_001044b0": {
            "renaming": {},
            "code": "\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = fprintf(__stream,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001044b0",
            "calling": [
                "stab_demangle_v3_arg",
                "bfd_nonfatal.cold",
                "debug_record_line",
                "list_matching_formats",
                "list_supported_targets",
                "FUN_0010554f",
                "debug_record_variable",
                "finish_stab",
                "strip_usage",
                "debug_add_to_current_namespace.constprop.0",
                "bad_stab",
                "copy_usage",
                "stab_demangle_v3_arglist",
                "main",
                "stab_bad_demangle",
                "debug_name_type",
                "debug_write_type.constprop.0",
                "bfd_nonfatal_message",
                "display_info.isra.0",
                "debug_end_block",
                "stab_find_slot",
                "debug_get_real_type.isra.0",
                "debug_record_function",
                "stab_find_type",
                "report",
                "debug_end_function",
                "debug_start_block",
                "parse_stab",
                "stab_context",
                "parse_stab_type",
                "debug_tag_type",
                "debug_start_source",
                "debug_find_named_type",
                "warn_stab",
                "debug_record_parameter"
            ],
            "imported": false,
            "current_name": "FUN_001044b0"
        },
        "FUN_0010ab4d": {
            "renaming": {
                "FUN_0010ab4d": "update_string_with_prefix_0010ab4d",
                "param_1": "dataStruct",
                "param_2": "prefix",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "ptr1",
                "lVar2": "ptr2",
                "auVar3": "result",
                "sVar4": "prefixLength",
                "pcVar5": "existingString",
                "sVar6": "existingStringLength",
                "auVar7": "updatedResult"
            },
            "code": "\nundefined  [16] updateStringWithPrefix_0010ab4d(long dataStruct,char *prefix,undefined8 param3,undefined8 param4)\n\n{\n  ulong ptr1;\n  long ptr2;\n  undefined result [16];\n  size_t prefixLength;\n  char *existingString;\n  size_t existingStringLength;\n  undefined updatedResult [16];\n  \n  ptr1 = *(ulong *)(dataStruct + 0x60);\n  if ((ptr1 != 0) && (*(long *)(ptr1 + 0x20) != 0)) {\n    existingString = *(char **)(ptr1 + 0x30);\n    prefixLength = strlen(prefix);\n    if (existingString == (char *)0x0) {\n      existingString = (char *)xmalloc(prefixLength + 3);\n      *existingString = '\\0';\n    }\n    else {\n      existingStringLength = strlen(existingString);\n      existingString = (char *)xrealloc(existingString,prefixLength + 4 + existingStringLength);\n    }\n    prefixLength = strlen(existingString);\n    sprintf(existingString + prefixLength,\"%s::\",prefix);\n    ptr2 = *(long *)(dataStruct + 0x60);\n    *(char **)(ptr2 + 0x30) = existingString;\n    updatedResult._1_7_ = (undefined7)((ulong)ptr2 >> 8);\n    updatedResult[0] = 1;\n    updatedResult._8_8_ = param4;\n    return updatedResult;\n  }\n  result._8_8_ = 0;\n  result._0_8_ = ptr1;\n  return result << 0x40;\n}\n\n",
            "called": [
                "strlen",
                "sprintf",
                "xrealloc",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010ab4d",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "update_string_with_prefix_0010ab4d"
        },
        "FUN_001046f0": {
            "renaming": {},
            "code": "\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memmove(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001046f0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001046f0"
        },
        "FUN_0010c218": {
            "renaming": {
                "FUN_0010c218": "add_type_to_namespace_0010c218",
                "param_1": "file",
                "param_2": "typeIndex",
                "param_3": "value",
                "uVar1": "errorMessage",
                "lVar2": "type",
                "pauVar3": "pointerArray",
                "lVar4": "namespaceEntry"
            },
            "code": "\n\n\nlong addTypeToNamespace_0010c218(long file,long typeIndex,long value)\n\n{\n  undefined8 errorMessage;\n  long type;\n  undefined (*pointerArray) [16];\n  long namespaceEntry;\n  \n  if ((typeIndex != 0) && (value != 0)) {\n    if ((*(long *)(file + 8) == 0) || (*(long *)(file + 0x10) == 0)) {\n      errorMessage = dcgettext(0,\"debug_name_type: no current file\",5);\n      fprintf(_stderr,\"%s\\n\",errorMessage);\n    }\n    else {\n      type = debug_make_type_constprop_0(0x16,0);\n      if (type != 0) {\n        pointerArray = (undefined (*) [16])xmalloc(0x10);\n        namespaceEntry = *(long *)(file + 0x10);\n        *pointerArray = ZEXT816(0);\n        *(long *)(*pointerArray + 8) = value;\n        *(undefined (**) [16])(type + 0x10) = pointerArray;\n        namespaceEntry = debug_add_to_namespace_constprop_0(namespaceEntry + 0x10,typeIndex,0,3);\n        if (namespaceEntry != 0) {\n          *(long *)(namespaceEntry + 0x20) = type;\n          *(long *)*pointerArray = namespaceEntry;\n          return type;\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext",
                "debug_add_to_namespace.constprop.0",
                "debug_make_type.constprop.0",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c218",
            "calling": [
                "parse_coff_type.lto_priv.0",
                "parse_stab",
                "stab_find_type",
                "parse_coff_symbol.constprop.0.isra.0"
            ],
            "imported": false,
            "current_name": "add_type_to_namespace_0010c218"
        },
        "FUN_00128060": {
            "renaming": {},
            "code": "\n\n\n\nchar * strncpy(char *__dest,char *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strncpy@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128060",
            "calling": [
                "strncpy"
            ],
            "imported": false,
            "current_name": "FUN_00128060"
        },
        "FUN_00116b90": {
            "renaming": {
                "FUN_00116b90": "FUNC_00116b90"
            },
            "code": "\n\n\nuint FUNC_00116b90(uint param_1,char **param_2)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  bool bVar4;\n  bool bVar5;\n  undefined *puVar6;\n  byte bVar7;\n  char cVar8;\n  int iVar9;\n  uint uVar10;\n  int iVar11;\n  undefined4 uVar12;\n  int iVar13;\n  FILE *pFVar14;\n  size_t sVar15;\n  byte *__s;\n  size_t sVar16;\n  byte *__ptr;\n  long lVar17;\n  char **ppcVar18;\n  long *__src;\n  char **ppcVar19;\n  undefined8 *puVar20;\n  char *__template;\n  FILE *pFVar21;\n  undefined8 uVar22;\n  FILE **ppFVar23;\n  undefined8 uVar24;\n  int *piVar25;\n  char *pcVar26;\n  ulong uVar27;\n  byte *pbVar28;\n  undefined **ppuVar29;\n  long lVar30;\n  byte *pbVar31;\n  char *pcVar32;\n  FILE *pFVar33;\n  char *pcVar34;\n  FILE *unaff_R12;\n  int iVar35;\n  uint uVar36;\n  char *unaff_R13;\n  byte bVar37;\n  FILE *pFVar38;\n  bool bVar39;\n  FILE *local_130;\n  FILE *local_120;\n  size_t local_118;\n  ulong local_110;\n  long *local_108;\n  FILE *local_d8;\n  FILE *local_d0;\n  undefined local_c8 [152];\n  \n  setlocale(5,\"\");\n  setlocale(0,\"\");\n  bindtextdomain(\"binutils\",\"/usr/share/locale\");\n  textdomain(\"binutils\");\n  program_name = *param_2;\n  xmalloc_set_program_name();\n  ppcVar18 = param_2;\n  if (1 < (int)param_1) {\n    local_120 = (FILE *)0x7d0;\n    unaff_R13 = (char *)(ulong)param_1;\n    unaff_R12 = (FILE *)0x1;\n    iVar11 = 0;\n    do {\n      iVar13 = (int)unaff_R12;\n      lVar30 = (long)iVar13;\n      iVar35 = (int)unaff_R13;\n      if (*ppcVar18[lVar30] == '@') {\n        uVar10 = (int)local_120 - 1;\n        local_120 = (FILE *)(ulong)uVar10;\n        if (uVar10 == 0) {\n          pcVar32 = *ppcVar18;\n          pcVar26 = \"%s: error: too many @-files encountered\\n\";\nLAB_00118365:\n          fprintf(_stderr,pcVar26,pcVar32);\n                    \n          xexit(1);\n        }\n        pcVar32 = ppcVar18[lVar30] + 1;\n        iVar9 = stat(pcVar32,(stat *)local_c8);\n        if (iVar9 < 0) goto LAB_00116fd0;\n        if ((local_c8._24_4_ & 0xf000) == 0x4000) {\n          pcVar32 = *ppcVar18;\n          pcVar26 = \"%s: error: @-file refers to a directory\\n\";\n          goto LAB_00118365;\n        }\n        pFVar14 = fopen(pcVar32,\"r\");\n        if (pFVar14 == (FILE *)0x0) goto LAB_00116fd0;\n        iVar9 = fseek(pFVar14,0,2);\n        if (((iVar9 == -1) || (sVar15 = ftell(pFVar14), sVar15 == 0xffffffffffffffff)) ||\n           (iVar9 = fseek(pFVar14,0,0), iVar9 == -1)) {\nLAB_00117070:\n          fclose(pFVar14);\n          if (iVar13 + 1 < iVar35) goto LAB_00116fde;\n          goto LAB_00117086;\n        }\n        __s = (byte *)xmalloc(sVar15 + 1);\n        sVar16 = fread(__s,1,sVar15,pFVar14);\n        if ((sVar15 != sVar16) && (iVar9 = ferror(pFVar14), iVar9 != 0)) {\n          free(__s);\n          goto LAB_00117070;\n        }\n        __s[sVar16] = 0;\n        bVar7 = *__s;\n        pbVar28 = __s;\n        if (bVar7 != 0) {\nLAB_00116d58:\n          if (((&_sch_istable)[(ulong)bVar7 * 2] & 0x40) != 0) goto LAB_00116d48;\n          sVar15 = strlen((char *)__s);\n          __ptr = (byte *)xmalloc(sVar15 + 1);\n          __src = (long *)0x0;\n          iVar9 = 0;\n          bVar39 = false;\n          bVar5 = false;\n          bVar4 = false;\n          local_110 = 0;\n          pbVar28 = __s;\n          do {\n            while (((&_sch_istable)[(ulong)*pbVar28 * 2] & 0x40) != 0) {\n              pbVar28 = pbVar28 + 1;\n            }\n            if ((iVar9 == 0) || (iVar9 + -1 <= (int)local_110)) {\n              if (__src == (long *)0x0) {\n                iVar9 = 8;\n                __src = (long *)xmalloc(0x40);\n                local_108 = __src + local_110;\n                *local_108 = 0;\n              }\n              else {\n                iVar9 = iVar9 * 2;\n                __src = (long *)xrealloc(__src,(long)iVar9 << 3);\n                local_108 = __src + local_110;\n                *local_108 = 0;\n              }\n            }\n            else {\n              local_108 = __src + local_110;\n            }\n            bVar7 = *pbVar28;\n            pbVar31 = __ptr;\n            while (bVar7 != 0) {\n              while( true ) {\n                if ((((&_sch_istable)[(ulong)bVar7 * 2] & 0x40) != 0) &&\n                   (!(bool)(bVar5 | bVar4 | bVar39))) {\n                  bVar4 = false;\n                  bVar39 = false;\n                  bVar5 = false;\n                  goto LAB_00116e3f;\n                }\n                if (!bVar4) break;\n                pbVar28 = pbVar28 + 1;\n                *pbVar31 = bVar7;\n                pbVar31 = pbVar31 + 1;\n                bVar4 = false;\n                bVar7 = *pbVar28;\n                if (bVar7 == 0) goto LAB_00116e3f;\n              }\n              if (bVar7 == 0x5c) {\n                bVar4 = true;\n              }\n              else if (bVar5) {\n                if (bVar7 == 0x27) {\n                  bVar5 = false;\n                }\n                else {\nLAB_00116fb1:\n                  *pbVar31 = bVar7;\n                  pbVar31 = pbVar31 + 1;\n                }\n              }\n              else if (bVar39) {\n                if (bVar7 != 0x22) goto LAB_00116fb1;\n                bVar39 = false;\n              }\n              else if (bVar7 == 0x27) {\n                bVar5 = true;\n              }\n              else {\n                if (bVar7 != 0x22) goto LAB_00116fb1;\n                bVar39 = true;\n              }\n              pbVar1 = pbVar28 + 1;\n              pbVar28 = pbVar28 + 1;\n              bVar7 = *pbVar1;\n            }\nLAB_00116e3f:\n            *pbVar31 = 0;\n            lVar17 = xstrdup(__ptr);\n            *local_108 = lVar17;\n            __src[local_110 + 1] = 0;\n            bVar7 = *pbVar28;\n            bVar2 = (&_sch_istable)[(ulong)bVar7 * 2];\n            while ((bVar2 & 0x40) != 0) {\n              bVar7 = pbVar28[1];\n              pbVar28 = pbVar28 + 1;\n              bVar2 = (&_sch_istable)[(ulong)bVar7 * 2];\n            }\n            local_110 = local_110 + 1;\n          } while (bVar7 != 0);\n          free(__ptr);\n          ppcVar19 = ppcVar18;\n          if (param_2 == ppcVar18) goto LAB_001172ad;\n          goto LAB_00116ed7;\n        }\nLAB_0011728f:\n        __src = (long *)xmalloc(8);\n        *__src = 0;\n        if (param_2 == ppcVar18) {\nLAB_001172ad:\n          if (*ppcVar18 == (char *)0x0) {\n            iVar9 = 0;\n          }\n          else {\n            lVar17 = 1;\n            do {\n              iVar9 = (int)lVar17;\n              ppcVar19 = ppcVar18 + lVar17;\n              lVar17 = lVar17 + 1;\n            } while (*ppcVar19 != (char *)0x0);\n          }\n          lVar17 = 0;\n          ppcVar19 = (char **)xmalloc((long)(iVar9 + 1) << 3);\n          pcVar32 = *ppcVar18;\n          while (pcVar32 != (char *)0x0) {\n            uVar24 = xstrdup();\n            *(undefined8 *)((long)ppcVar19 + lVar17) = uVar24;\n            lVar17 = lVar17 + 8;\n            pcVar32 = *(char **)((long)ppcVar18 + lVar17);\n          }\n          *(undefined8 *)((long)ppcVar19 + lVar17) = 0;\nLAB_00116ed7:\n          ppcVar18 = ppcVar19;\n          if (*__src == 0) goto LAB_00117768;\n          lVar17 = 0;\n          do {\n            lVar17 = lVar17 + 1;\n          } while (__src[lVar17] != 0);\n          local_118 = lVar17 * 8;\n        }\n        else {\nLAB_00117768:\n          lVar17 = 0;\n          local_118 = 0;\n        }\n        free(ppcVar18[lVar30]);\n        ppcVar18 = (char **)xrealloc(ppcVar18,(lVar17 + 1 + (long)iVar35) * 8);\n        uVar36 = iVar35 + -1 + (int)lVar17;\n        unaff_R13 = (char *)(ulong)uVar36;\n        memmove(ppcVar18 + lVar30 + lVar17,ppcVar18 + 1 + lVar30,(long)(iVar35 - iVar13) << 3);\n        memcpy(ppcVar18 + lVar30,__src,local_118);\n        free(__src);\n        free(__s);\n        fclose(pFVar14);\n        uVar10 = iVar11 + 1;\n        unaff_R12 = (FILE *)(lVar30 * 8);\n        if ((int)uVar36 <= (int)uVar10) goto LAB_00117086;\n      }\n      else {\nLAB_00116fd0:\n        if (iVar35 <= iVar13 + 1) goto LAB_00117086;\nLAB_00116fde:\n        uVar10 = iVar13 + 1;\n        iVar11 = iVar13;\n      }\n      unaff_R12 = (FILE *)(ulong)uVar10;\n    } while( true );\n  }\nLAB_0011708b:\n  strip_symbols = 0;\n  discard_locals = 0;\n  iVar11 = bfd_init();\n  pcVar32 = \"fatal error: libbfd ABI mismatch\";\n  if (iVar11 != 0x118) {\nLAB_00117aed:\n    uVar24 = dcgettext(0,pcVar32,5);\n                    \n    fatal(uVar24);\n  }\n  pcVar32 = \"x86_64-pc-linux-gnu\";\n  bVar7 = bfd_set_default_target(\"x86_64-pc-linux-gnu\",\"fatal error: libbfd ABI mismatch\",5);\n  pcVar26 = program_name;\n  if (bVar7 == 0) {\n    uVar12 = bfd_get_error();\n    pcVar26 = (char *)bfd_errmsg(uVar12);\n    pcVar34 = \"can\\'t set BFD default target to `%s\\': %s\";\nLAB_00118de6:\n    uVar24 = dcgettext(0,pcVar34,5);\n                    \n    fatal(uVar24,pcVar32,pcVar26);\n  }\n  uVar10 = is_strip;\n  if ((int)is_strip < 0) {\n    sVar15 = strlen(program_name);\n    uVar10 = 0;\n    if (4 < (int)sVar15) {\n      iVar11 = filename_cmp(pcVar26 + (long)(int)sVar15 + -5,\"strip\");\n      uVar10 = (uint)(iVar11 == 0);\n    }\n  }\n  is_strip = uVar10;\n  strip_specific_htab = create_symbol_htab();\n  strip_unneeded_htab = create_symbol_htab();\n  keep_specific_htab = create_symbol_htab();\n  localize_specific_htab = create_symbol_htab();\n  globalize_specific_htab = create_symbol_htab();\n  keepglobal_specific_htab = create_symbol_htab();\n  weaken_specific_htab = create_symbol_htab();\n  redefine_specific_htab = htab_create_alloc(0x10,htab_hash_redefnode,eq_string_redefnode);\n  redefine_specific_reverse_htab = create_symbol_htab();\n  puVar6 = xatexit_head_lto_priv_0;\n  if (__xexit_cleanup == (code *)0x0) {\n    __xexit_cleanup = xatexit_cleanup_lto_priv_0;\n  }\n  if (0x1f < *(int *)(xatexit_head_lto_priv_0 + 8)) {\n    puVar20 = (undefined8 *)malloc(0x110);\n    if (puVar20 == (undefined8 *)0x0) goto LAB_001171a7;\n    *puVar20 = puVar6;\n    *(undefined4 *)(puVar20 + 1) = 0;\n    xatexit_head_lto_priv_0 = (undefined *)puVar20;\n  }\n  puVar6 = xatexit_head_lto_priv_0;\n  iVar11 = *(int *)(xatexit_head_lto_priv_0 + 8);\n  *(int *)(xatexit_head_lto_priv_0 + 8) = iVar11 + 1;\n  *(code **)(puVar6 + (long)iVar11 * 8 + 0x10) = delete_symbol_htabs;\nLAB_001171a7:\n  bfd_set_error_program_name(*ppcVar18);\n  if (is_strip != 0) {\n    local_130 = (FILE *)0x0;\n    unaff_R12 = (FILE *)0x0;\n    ppuVar29 = (undefined **)(FILE *)0x0;\n    pFVar14 = (FILE *)0x0;\n    bVar37 = 0;\n    bVar2 = 0;\nswitchD_001177df_caseD_0:\n    do {\n      uVar12 = getopt_long(param_1,ppcVar18,\"I:O:F:K:MN:R:o:sSpdgxXHhVvwDU\",strip_options);\n      pFVar21 = _optarg;\n      switch(uVar12) {\n      case 0x44:\n        deterministic = 1;\n        break;\n      case 0x48:\n      case 0x68:\n        strip_usage(_stdout,0);\n      case 0x46:\n        local_130 = _optarg;\n        pFVar14 = _optarg;\n        break;\n      case 0x49:\n        local_130 = _optarg;\n        break;\n      case 0x4b:\n        local_120 = _optarg;\n        ppFVar23 = (FILE **)htab_find_slot(keep_specific_htab,_optarg,1);\n        *ppFVar23 = pFVar21;\n        break;\n      case 0x4d:\n        merge_notes = bVar7;\n        bVar2 = bVar7;\n        break;\n      case 0x4e:\n        local_120 = _optarg;\n        ppFVar23 = (FILE **)htab_find_slot(strip_specific_htab,_optarg,1);\n        *ppFVar23 = pFVar21;\n        break;\n      case 0x4f:\n        pFVar14 = _optarg;\n        break;\n      case 0x52:\n        handle_remove_section_option(_optarg);\n        break;\n      case 0x53:\n      case 100:\n      case 0x67:\n        strip_symbols = 2;\n        break;\n      case 0x55:\n        deterministic = 0;\n        break;\n      case 0x56:\n        unaff_R12 = (FILE *)(ulong)bVar7;\n        break;\n      case 0x58:\n        discard_locals = 1;\n        break;\n      case 0x6f:\n        ppuVar29 = (undefined **)_optarg;\n        break;\n      case 0x70:\n        preserve_dates = 1;\n        break;\n      case 0x73:\n        strip_symbols = 7;\n        break;\n      case 0x76:\n        verbose = 1;\n        break;\n      case 0x77:\n        wildcard = 1;\n        break;\n      case 0x78:\n        discard_locals = 2;\n        break;\n      case 0xa9:\n        bVar37 = bVar7;\n        break;\n      case 0xb2:\n        keep_file_symbols = 1;\n        break;\n      case 0xb3:\n        find_section_list(_optarg,1,4);\n        break;\n      case 0xb5:\n        keep_section_symbols = 1;\n        break;\n      case 0xba:\n        merge_notes = 0;\n        bVar2 = bVar7;\n        break;\n      case 0xbc:\n        strip_symbols = 4;\n        break;\n      case 0xc6:\n        find_section_list(_optarg,1,0x100);\n        break;\n      case 0xd0:\n        strip_symbols = 5;\n        break;\n      case 0xd2:\n        goto switchD_001177df_caseD_d2;\n      default:\n        if (((bVar2 == 0) && (strip_symbols < 8)) &&\n           ((-0xdaL >> ((byte)strip_symbols & 0x3f) & 1U) == 0)) {\n          merge_notes = 1;\n        }\n        if (bVar37 != 0) goto LAB_00118a4c;\n        if ((char)unaff_R12 != '\\0') {\n          print_version(\"strip\");\n          goto LAB_001189a2;\n        }\n        if (deterministic < 0) {\n          deterministic = 1;\n        }\n        if (((strip_symbols | discard_locals) == 0) &&\n           (lVar30 = htab_elements(strip_specific_htab), lVar30 == 0)) {\n          strip_symbols = 7;\n        }\n        if (pFVar14 == (FILE *)0x0) {\n          pFVar14 = local_130;\n        }\n        unaff_R12 = (FILE *)(long)(int)_optind;\n        if ((_optind != param_1) &&\n           (((FILE *)ppuVar29 == (FILE *)0x0 || ((int)param_1 <= (int)(_optind + 1)))))\n        goto LAB_00117888;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n      case 0x21:\n      case 0x22:\n      case 0x23:\n      case 0x24:\n      case 0x25:\n      case 0x26:\n      case 0x27:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n      case 0x3f:\n      case 0x40:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x45:\n      case 0x47:\n      case 0x4a:\n      case 0x4c:\n      case 0x50:\n      case 0x51:\n      case 0x54:\n      case 0x57:\n      case 0x59:\n      case 0x5a:\n      case 0x5b:\n      case 0x5c:\n      case 0x5d:\n      case 0x5e:\n      case 0x5f:\n      case 0x60:\n      case 0x61:\n      case 0x62:\n      case 99:\n      case 0x65:\n      case 0x66:\n      case 0x69:\n      case 0x6a:\n      case 0x6b:\n      case 0x6c:\n      case 0x6d:\n      case 0x6e:\n      case 0x71:\n      case 0x72:\n      case 0x74:\n      case 0x75:\n      case 0x79:\n      case 0x7a:\n      case 0x7b:\n      case 0x7c:\n      case 0x7d:\n      case 0x7e:\n      case 0x7f:\n      case 0x80:\n      case 0x81:\n      case 0x82:\n      case 0x83:\n      case 0x84:\n      case 0x85:\n      case 0x86:\n      case 0x87:\n      case 0x88:\n      case 0x89:\n      case 0x8a:\n      case 0x8b:\n      case 0x8c:\n      case 0x8d:\n      case 0x8e:\n      case 0x8f:\n      case 0x90:\n      case 0x91:\n      case 0x92:\n      case 0x93:\n      case 0x94:\n      case 0x95:\n      case 0x96:\n      case 0x97:\n      case 0x98:\n      case 0x99:\n      case 0x9a:\n      case 0x9b:\n      case 0x9c:\n      case 0x9d:\n      case 0x9e:\n      case 0x9f:\n      case 0xa0:\n      case 0xa1:\n      case 0xa2:\n      case 0xa3:\n      case 0xa4:\n      case 0xa5:\n      case 0xa6:\n      case 0xa7:\n      case 0xa8:\n      case 0xaa:\n      case 0xab:\n      case 0xac:\n      case 0xad:\n      case 0xae:\n      case 0xaf:\n      case 0xb0:\n      case 0xb1:\n      case 0xb4:\n      case 0xb6:\n      case 0xb7:\n      case 0xb8:\n      case 0xb9:\n      case 0xbb:\n      case 0xbd:\n      case 0xbe:\n      case 0xbf:\n      case 0xc0:\n      case 0xc1:\n      case 0xc2:\n      case 0xc3:\n      case 0xc4:\n      case 0xc5:\n      case 199:\n      case 200:\n      case 0xc9:\n      case 0xca:\n      case 0xcb:\n      case 0xcc:\n      case 0xcd:\n      case 0xce:\n      case 0xcf:\n      case 0xd1:\n        strip_usage(_stderr,1);\n        unaff_R13 = strip_options;\n        goto switchD_00117234_caseD_c1;\n      }\n    } while( true );\n  }\n  local_108 = (long *)0x0;\n  local_d8 = (FILE *)0x0;\n  local_d0 = (FILE *)0x0;\n  local_130 = (FILE *)(ulong)bVar7;\n  local_120 = (FILE *)0x0;\n  local_118 = 0;\n  local_110 = 0;\n  ppuVar29 = (undefined **)(FILE *)0x0;\n  bVar2 = 0;\nswitchD_00117234_caseD_0:\n  uVar36 = getopt_long(param_1,ppcVar18,\"b:B:i:I:j:K:MN:s:O:d:F:L:G:R:SpgxXHhVvW:wDU\",copy_options);\n  pFVar14 = _optarg;\n  uVar10 = reverse_bytes;\n  pcVar26 = (char *)(ulong)uVar36;\n  if (uVar36 != 0xffffffff) goto code_r0x00117223;\n  if (bVar2 != 0) {\n    pcVar32 = \"--globalize-symbol(s) is incompatible with -G/--keep-global-symbol(s)\";\n    if ((char)local_108 != '\\0') goto LAB_00117aed;\n  }\n  if ((char)local_118 != '\\0') {\nLAB_00118a4c:\n    display_info_isra_0();\n    return status;\n  }\n  if ((char)local_110 != '\\0') {\n    print_version(\"objcopy\");\n    goto LAB_00118398;\n  }\n  if ((interleave != 0) && (copy_byte == -1)) {\n    pcVar32 = \"interleave start byte must be set with --byte\";\n    goto LAB_00117aed;\n  }\n  if (interleave <= copy_byte) {\n    pcVar32 = \"byte number must be less than interleave\";\n    goto LAB_00117aed;\n  }\n  pcVar32 = \"interleave width must be less than or equal to interleave - byte`\";\n  if (interleave - copy_byte < copy_width) goto LAB_00117aed;\n  if ((_optind == param_1) || ((int)(_optind + 2) < (int)param_1)) goto switchD_00117234_caseD_1;\n  pcVar32 = ppcVar18[(int)_optind];\n  if ((int)(_optind + 1) < (int)param_1) {\n    pcVar34 = ppcVar18[(long)(int)_optind + 1];\n  }\n  else {\n    pcVar34 = (char *)0x0;\n  }\n  if (deterministic < 0) {\n    deterministic = 1;\n  }\n  if ((strip_symbols | discard_locals) == 0) {\n    strip_symbols = 1;\n  }\n  if (local_d0 == (FILE *)0x0) {\n    local_d0 = local_d8;\n    if (local_d8 != (FILE *)0x0) {\nLAB_00117661:\n      cVar8 = startswith_lto_priv_0_lto_priv_0(local_d8,&DAT_0011b300);\n      if (cVar8 != '\\0') {\n        iVar11 = convert_efi_target(&local_d8);\n        if (iVar11 < 0) {\n          pcVar32 = \"unknown input EFI target: %s\";\n          pFVar14 = local_d8;\n          goto LAB_001176c2;\n        }\n        if (local_d0 == (FILE *)0x0) goto LAB_0011743e;\n      }\n      goto LAB_001175b1;\n    }\n  }\n  else {\n    if (local_d8 != (FILE *)0x0) goto LAB_00117661;\nLAB_001175b1:\n    cVar8 = startswith_lto_priv_0_lto_priv_0(local_d0,&DAT_0011b300);\n    if (cVar8 != '\\0') {\n      iVar11 = convert_efi_target(&local_d0);\n      if (iVar11 < 0) {\n        pcVar32 = \"unknown output EFI target: %s\";\n        pFVar14 = local_d0;\n        goto LAB_001176c2;\n      }\n      if (pe_subsystem == -1) {\n        pe_subsystem = (short)iVar11;\n      }\n      if (pe_file_alignment == -1) {\n        pe_file_alignment = 0x200;\n      }\n      if (pe_section_alignment == -1) {\n        pe_section_alignment = 0x1000;\n      }\n    }\n  }\nLAB_0011743e:\n  if ((pcVar34 == (char *)0x0) || (uVar10 = filename_cmp(pcVar32,pcVar34), uVar10 == 0)) {\n    __template = (char *)template_in_dir(pcVar32);\n    uVar36 = mkstemp(__template);\n    if (uVar36 == 0xffffffff) {\n      free(__template);\n      piVar25 = __errno_location();\n      pcVar26 = strerror(*piVar25);\n      pcVar34 = \"warning: could not create temporary file whilst copying \\'%s\\', (error: %s)\";\n      goto LAB_00118de6;\n    }\n    uVar10 = uVar36;\n    if (-1 < (int)uVar36) {\n      uVar10 = dup(uVar36);\n      pcVar26 = (char *)(ulong)uVar10;\n    }\n  }\n  else {\n    uVar36 = 0xffffffff;\n    __template = pcVar34;\n  }\n  copy_file(pcVar32,__template,uVar36,local_c8,local_d8,local_d0,local_120,uVar10);\n  if (status == 0) {\n    if (pcVar34 != (char *)0x0) {\n      pcVar32 = pcVar34;\n    }\n    iVar11 = smart_rename(__template,pcVar32,pcVar26,local_c8,preserve_dates);\n    status = (uint)(iVar11 != 0);\n  }\n  else {\n    if (-1 < (int)pcVar26) {\n      close((int)pcVar26);\n    }\n    unlink_if_ordinary(__template);\n  }\n  if (pcVar34 != __template) {\n    free(__template);\n  }\n  puVar20 = change_sections;\n  if ((char)local_130 != '\\0') {\n    for (; puVar20 != (undefined8 *)0x0; puVar20 = (undefined8 *)*puVar20) {\n      if (*(char *)(puVar20 + 2) == '\\0') {\n        uVar10 = *(uint *)((long)puVar20 + 0x14);\n        if ((uVar10 & 0x18) != 0) {\n          uVar24 = puVar20[3];\n          uVar3 = puVar20[1];\n          uVar22 = dcgettext(0,\"%s %s%c0x%lx never used\",5);\n          non_fatal(uVar22,\"--change-section-vma\",uVar3,\n                    (-(uint)((uVar10 & 8) == 0) & 0xffffffee) + 0x3d,uVar24);\n          uVar10 = *(uint *)((long)puVar20 + 0x14);\n        }\n        if ((uVar10 & 0x60) != 0) {\n          uVar24 = puVar20[4];\n          uVar3 = puVar20[1];\n          uVar22 = dcgettext(0,\"%s %s%c0x%lx never used\",5);\n          non_fatal(uVar22,\"--change-section-lma\",uVar3,\n                    (-(uint)((uVar10 & 0x20) == 0) & 0xffffffee) + 0x3d,uVar24);\n        }\n      }\n    }\n  }\n  free(strip_specific_buffer);\n  free(strip_unneeded_buffer);\n  free(keep_specific_buffer);\n  free(localize_specific_buffer);\n  free(globalize_specific_buffer);\n  free(keepglobal_specific_buffer);\n  free(weaken_specific_buffer);\n  return status;\nLAB_00116d48:\n  bVar7 = pbVar28[1];\n  pbVar28 = pbVar28 + 1;\n  if (bVar7 == 0) goto LAB_0011728f;\n  goto LAB_00116d58;\nLAB_00117086:\n  param_1 = (uint)unaff_R13;\n  goto LAB_0011708b;\nLAB_00117888:\n  uVar10 = status;\n  if ((int)param_1 <= (int)unaff_R12) {\n    return status;\n  }\n  lVar30 = get_file_size(ppcVar18[(long)unaff_R12]);\n  if (lVar30 < 1) {\nLAB_00118edb:\n    status = 1;\n  }\n  else {\n    pcVar32 = ppcVar18[(long)unaff_R12];\n    if ((FILE *)ppuVar29 == (FILE *)0x0) {\nLAB_001178b9:\n      pFVar21 = (FILE *)template_in_dir(pcVar32);\n      iVar11 = mkstemp((char *)pFVar21);\n      if (iVar11 == -1) {\n        free(pFVar21);\n        uVar24 = dcgettext(0,\"could not create temporary file to hold stripped copy\",5);\n        bfd_nonfatal_message(ppcVar18[(long)unaff_R12],0,0,uVar24);\n        goto LAB_00118edb;\n      }\n      iVar13 = -1;\n      if (-1 < iVar11) {\n        iVar13 = dup(iVar11);\n      }\n    }\n    else {\n      iVar11 = filename_cmp(pcVar32,ppuVar29);\n      if (iVar11 == 0) {\n        pcVar32 = ppcVar18[(long)unaff_R12];\n        goto LAB_001178b9;\n      }\n      iVar11 = -1;\n      iVar13 = -1;\n      pFVar21 = (FILE *)ppuVar29;\n    }\n    status = 0;\n    copy_file(ppcVar18[(long)unaff_R12],pFVar21,iVar11,local_c8,local_130,pFVar14,0);\n    if (status == 0) {\n      pFVar33 = (FILE *)ppuVar29;\n      if ((FILE *)ppuVar29 == (FILE *)0x0) {\n        pFVar33 = (FILE *)ppcVar18[(long)unaff_R12];\n      }\n      iVar11 = smart_rename(pFVar21,pFVar33,iVar13,local_c8,preserve_dates);\n      status = uVar10;\n      if (iVar11 != 0) {\n        status = 1;\n      }\n    }\n    else {\n      if (-1 < iVar13) {\n        close(iVar13);\n      }\n      unlink_if_ordinary(pFVar21);\n    }\n    if ((FILE *)ppuVar29 != pFVar21) {\n      free(pFVar21);\n    }\n  }\n  unaff_R12 = (FILE *)((long)&unaff_R12->_flags + 1);\n  goto LAB_00117888;\nswitchD_001177df_caseD_d2:\n  strip_symbols = 3;\n  goto switchD_001177df_caseD_0;\nLAB_001189a2:\n  pcVar32 = \"bad format for --set-section-alignment: numeric argument needed\";\n  goto LAB_00117aed;\nLAB_00119858:\n  if (iVar13 == 10) goto LAB_0011902d;\n  if (iVar13 == 0xd) goto LAB_00119866;\n  if (iVar13 + 1U < 2) goto LAB_001198cd;\n  if ((iVar13 != 0x20) && (iVar13 != 9)) {\n    if (iVar13 != 0x23) goto LAB_001198d6;\n    goto LAB_001198ec;\n  }\n  iVar13 = getc((FILE *)ppuVar29);\n  goto LAB_00119858;\nLAB_0011902d:\n  if (iVar13 == 0xd) {\nLAB_00119866:\n    iVar13 = getc((FILE *)ppuVar29);\n    if (iVar13 == 10) {\n      if (*(char *)(int *)unaff_R13 != '\\0') {\n        add_redefine_and_check\n                  (pFVar14,unaff_R13,\n                   (undefined *)((long)&unaff_R12->_flags + (long)(int *)unaff_R13));\n      }\n      goto LAB_0011988e;\n    }\nLAB_001198cd:\n    if (iVar13 != -1) {\nLAB_001198d6:\n      pcVar32 = \"%s:%d: garbage found at end of line\";\nLAB_00119756:\n      uVar24 = dcgettext(0,pcVar32,5);\n                    \n      fatal(uVar24,pFVar14,iVar11 + -1);\n    }\n  }\n  else {\n    iVar13 = 10;\n  }\nLAB_0011903b:\n  if (*(char *)(int *)unaff_R13 != '\\0') {\n    add_redefine_and_check\n              (pFVar14,unaff_R13,(undefined *)((long)&unaff_R12->_flags + (long)(int *)unaff_R13));\n  }\n  unaff_R12 = (FILE *)ppuVar29;\n  if (iVar13 == -1) goto LAB_00119065;\nLAB_0011988e:\n  iVar13 = getc((FILE *)ppuVar29);\n  iVar11 = iVar11 + 1;\n  goto LAB_00118ace;\nswitchD_00117234_caseD_c7:\n  pcVar32 = strchr((char *)_optarg,0x3d);\n  if ((pcVar32 != (char *)0x0) && ((int)pcVar32 != iVar11)) {\n    uVar27 = (long)pcVar32 - (long)pFVar14 & 0xffffffff;\n    pcVar34 = pcVar32 + 1;\n    pcVar26 = (char *)xmalloc((int)((long)pcVar32 - (long)pFVar14) + 1);\n    strncpy(pcVar26,(char *)_optarg,uVar27);\n    pcVar26[uVar27] = '\\0';\n    pcVar32 = strchr(pcVar34,0x2c);\n    if (pcVar32 == (char *)0x0) {\n      unaff_R12 = (FILE *)0xffffffff;\n      sVar15 = strlen(pcVar34);\n      sVar15 = sVar15 & 0xffffffff;\n    }\n    else {\n      sVar15 = (size_t)(uint)((int)pcVar32 - (int)pcVar34);\n      uVar10 = parse_flags(pcVar32 + 1);\n      unaff_R12 = (FILE *)(ulong)uVar10;\n    }\n    if ((int)sVar15 != 0) {\n      unaff_R13 = (char *)xmalloc((int)sVar15 + 1);\n      strncpy(unaff_R13,pcVar34,sVar15);\n      *(undefined *)((long)(int *)unaff_R13 + sVar15) = 0;\n      ppuVar29 = (undefined **)section_rename_list;\n      goto LAB_00117f6f;\n    }\n  }\n  uVar24 = dcgettext(0,\"bad format for %s\",5);\n                    \n  fatal(uVar24,\"--rename-section\");\ncode_r0x00117223:\n  iVar11 = (int)_optarg;\n  switch(pcVar26) {\n  case (char *)0x0:\n    goto switchD_00117234_caseD_0;\n  default:\nswitchD_00117234_caseD_1:\n    copy_usage(_stderr,1);\n    do {\n      iVar11 = strcmp(*ppuVar29,pcVar26);\n      if (iVar11 == 0) {\n        iVar11 = strcmp(*(char **)((long)ppuVar29 + 8),unaff_R13);\n        if ((iVar11 != 0) || ((int)unaff_R12 != *(int *)((long)ppuVar29 + 0x10))) {\n          uVar24 = dcgettext(0,\"Multiple renames of section %s\",5);\n                    \n          fatal(uVar24,pcVar26);\n        }\n        goto switchD_00117234_caseD_0;\n      }\n      ppuVar29 = (undefined **)*(FILE **)((long)ppuVar29 + 0x18);\nLAB_00117f6f:\n    } while ((FILE *)ppuVar29 != (FILE *)0x0);\n    pFVar14 = (FILE *)xmalloc(0x20);\n    *(char **)pFVar14 = pcVar26;\n    pFVar14->_IO_read_ptr = unaff_R13;\n    *(int *)&pFVar14->_IO_read_end = (int)unaff_R12;\n    pFVar14->_IO_read_base = (char *)section_rename_list;\n    section_rename_list = pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x42:\n    ppuVar29 = (undefined **)&optarg;\n    local_120 = (FILE *)bfd_scan_arch(_optarg);\n    if (local_120 != (FILE *)0x0) goto switchD_00117234_caseD_0;\n    pcVar32 = \"architecture %s unknown\";\n    pFVar14 = _optarg;\n    break;\n  case (char *)0x44:\n    deterministic = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x46:\n    local_d0 = _optarg;\n    local_d8 = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x47:\n    ppFVar23 = (FILE **)htab_find_slot(keepglobal_specific_htab,_optarg,1);\n    *ppFVar23 = pFVar14;\n    local_108 = (long *)(ulong)bVar7;\n    ppuVar29 = (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x48:\n  case (char *)0x68:\n    copy_usage(_stdout,0);\n  case (char *)0xcd:\n    _bfd_srec_forceS3 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x49:\n  case (char *)0x73:\n    local_d8 = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4b:\n    ppFVar23 = (FILE **)htab_find_slot(keep_specific_htab,_optarg,1);\n    *ppFVar23 = pFVar14;\n    ppuVar29 = (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4c:\n    ppFVar23 = (FILE **)htab_find_slot(localize_specific_htab,_optarg,1);\n    *ppFVar23 = pFVar14;\n    ppuVar29 = (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4d:\n    merge_notes = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4e:\n    ppFVar23 = (FILE **)htab_find_slot(strip_specific_htab,_optarg,1);\n    *ppFVar23 = pFVar14;\n    ppuVar29 = (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4f:\n  case (char *)0x64:\n    local_d0 = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x52:\n    handle_remove_section_option(_optarg);\n    goto switchD_00117234_caseD_0;\n  case (char *)0x53:\n    strip_symbols = 7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x55:\n    deterministic = 0;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x56:\n    local_110 = (ulong)bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x57:\n    ppFVar23 = (FILE **)htab_find_slot(weaken_specific_htab,_optarg,1);\n    *ppFVar23 = pFVar14;\n    ppuVar29 = (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x58:\n    discard_locals = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x62:\n    lVar30 = strtol((char *)_optarg,(char **)0x0,10);\n    copy_byte = (int)lVar30;\n    if (copy_byte < 0) {\n      pcVar32 = \"byte number must be non-negative\";\n      goto LAB_00117aed;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0x67:\n    strip_symbols = 2;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x69:\n    if (_optarg == (FILE *)0x0) {\n      interleave = 4;\n    }\n    else {\n      lVar30 = strtol((char *)_optarg,(char **)0x0,10);\n      interleave = (int)lVar30;\n      if (interleave < 1) {\n        pcVar32 = \"interleave must be positive\";\n        goto LAB_00117aed;\n      }\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0x6a:\n    find_section_list(_optarg,1,2);\n    sections_copied = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x70:\n    preserve_dates = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x76:\n    verbose = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x77:\n    wildcard = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x78:\n    discard_locals = 2;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x96:\n    add_sections = init_section_add(_optarg,add_sections,\"--add-section\");\n    section_add_load_file(add_sections);\n    goto switchD_00117234_caseD_0;\n  case (char *)0x97:\n    long_section_names = 1;\n    gnu_debuglink_filename = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x98:\n    puVar20 = (undefined8 *)xmalloc(0x30);\n    *puVar20 = 0;\n    unaff_R13 = (char *)_optarg;\n    pcVar32 = strchr((char *)_optarg,0x3d);\n    if (pcVar32 == (char *)0x0) {\n      uVar24 = dcgettext(0,\"bad format for %s\",5);\n                    \n      fatal(uVar24,\"--add-symbol\");\n    }\n    ppuVar29 = (undefined **)(pcVar32 + 1);\n    pcVar32 = strchr((char *)ppuVar29,0x3a);\n    uVar24 = xstrndup(unaff_R13);\n    puVar20[1] = uVar24;\n    if (pcVar32 == (char *)0x0) {\n      puVar20[4] = 0;\n      lVar30 = strtol((char *)ppuVar29,(char **)0x0,0);\n    }\n    else {\n      uVar24 = xstrndup(ppuVar29);\n      puVar20[4] = uVar24;\n      lVar30 = strtol((char *)(FILE *)(pcVar32 + 1),(char **)0x0,0);\n      ppuVar29 = (undefined **)(FILE *)(pcVar32 + 1);\n    }\n    puVar20[2] = lVar30;\n    pcVar32 = strchr((char *)ppuVar29,0x2c);\n    puVar20[5] = 0;\n    if (pcVar32 == (char *)0x0) {\n      *(undefined4 *)(puVar20 + 3) = 2;\n      unaff_R12 = (FILE *)0x0;\n    }\n    else {\n      ppuVar29 = (undefined **)0x0;\n      pFVar14 = (FILE *)(pcVar32 + 1);\n      do {\n        unaff_R12 = pFVar14;\n        pcVar32 = strchr((char *)unaff_R12,0x2c);\n        if (pcVar32 == (char *)0x0) {\n          sVar15 = strlen((char *)unaff_R12);\n          pFVar14 = (FILE *)0x0;\n        }\n        else {\n          pFVar14 = (FILE *)(pcVar32 + 1);\n          sVar15 = (long)pcVar32 - (long)unaff_R12;\n        }\n        uVar10 = (uint)ppuVar29;\n        if (sVar15 == 5) {\n          iVar11 = strncasecmp(\"local\",(char *)unaff_R12,5);\n          if (iVar11 == 0) {\n            ppuVar29 = (undefined **)(ulong)(uVar10 | 1);\n          }\n          else {\n            iVar11 = strncasecmp(\"debug\",(char *)unaff_R12,5);\n            if (iVar11 != 0) goto LAB_001186b2;\n            ppuVar29 = (undefined **)(ulong)(uVar10 | 4);\n          }\n        }\n        else if (sVar15 == 6) {\n          iVar11 = strncasecmp(\"global\",(char *)unaff_R12,6);\n          if ((iVar11 == 0) || (iVar11 = strncasecmp(\"export\",(char *)unaff_R12,6), iVar11 == 0)) {\n            ppuVar29 = (undefined **)(ulong)(uVar10 | 2);\n          }\n          else {\n            iVar11 = strncasecmp(\"object\",(char *)unaff_R12,6);\n            if (iVar11 != 0) goto LAB_001186b2;\n            ppuVar29 = (undefined **)(ulong)(uVar10 | 0x10000);\n          }\n        }\n        else if (sVar15 == 8) {\n          iVar11 = strncasecmp(\"function\",(char *)unaff_R12,8);\n          if (iVar11 == 0) {\n            ppuVar29 = (undefined **)(ulong)(uVar10 | 8);\n          }\n          else {\n            iVar11 = strncasecmp(\"indirect\",(char *)unaff_R12,8);\n            if (iVar11 != 0) goto LAB_0011862f;\n            ppuVar29 = (undefined **)((ulong)ppuVar29 | 0x2000);\n          }\n        }\n        else if (sVar15 == 4) {\n          iVar11 = strncasecmp(\"weak\",(char *)unaff_R12,4);\n          if (iVar11 == 0) {\n            ppuVar29 = (undefined **)((ulong)ppuVar29 | 0x80);\n          }\n          else {\n            iVar11 = strncasecmp(\"file\",(char *)unaff_R12,4);\n            if (iVar11 != 0) goto LAB_001186b2;\n            ppuVar29 = (undefined **)((ulong)ppuVar29 | 0x4000);\n          }\n        }\n        else if (sVar15 == 7) {\n          iVar11 = strncasecmp(\"section\",(char *)unaff_R12,7);\n          if (iVar11 == 0) {\n            ppuVar29 = (undefined **)((ulong)ppuVar29 | 0x100);\n          }\n          else {\n            iVar11 = strncasecmp(\"warning\",(char *)unaff_R12,7);\n            if (iVar11 != 0) goto LAB_001186b2;\n            ppuVar29 = (undefined **)((ulong)ppuVar29 | 0x1000);\n          }\n        }\n        else {\n          if (sVar15 == 0xb) {\n            iVar11 = strncasecmp(\"constructor\",(char *)unaff_R12,0xb);\n            if (iVar11 == 0) {\n              ppuVar29 = (undefined **)((ulong)ppuVar29 | 0x800);\n              goto LAB_00117e3d;\n            }\n          }\n          else if (sVar15 == 9) {\n            iVar11 = strncasecmp(\"synthetic\",(char *)unaff_R12,9);\n            if (iVar11 == 0) {\n              ppuVar29 = (undefined **)(ulong)(uVar10 | 0x200000);\n              goto LAB_00117e3d;\n            }\n          }\n          else if (sVar15 == 0x11) {\n            iVar11 = strncasecmp(\"indirect-function\",(char *)unaff_R12,0x11);\n            if (iVar11 == 0) {\n              ppuVar29 = (undefined **)(ulong)(uVar10 | 0x400008);\n              goto LAB_00117e3d;\n            }\n          }\n          else if (sVar15 == 0xd) {\n            iVar11 = strncasecmp(\"unique-object\",(char *)unaff_R12,0xd);\n            if (iVar11 == 0) {\n              ppuVar29 = (undefined **)(ulong)(uVar10 | 0x810000);\n              goto LAB_00117e3d;\n            }\n          }\n          else if (sVar15 < 8) goto LAB_001186b2;\nLAB_0011862f:\n          iVar11 = strncasecmp(\"before=\",(char *)unaff_R12,7);\n          if (iVar11 != 0) {\nLAB_001186b2:\n            pcVar32 = (char *)xmalloc(sVar15 + 1);\n            strncpy(pcVar32,(char *)unaff_R12,sVar15);\n            pcVar32[sVar15] = '\\0';\n            uVar24 = dcgettext(0,\"unrecognized symbol flag `%s\\'\",5);\n            non_fatal(uVar24,pcVar32);\n            uVar24 = dcgettext(0,\"supported flags: %s\",5);\n                    \n            fatal(uVar24,\n                  \"local, global, export, debug, function, weak, section, constructor, warning, indirect, file, object, synthetic, indirect-function, unique-object, before=<othersym>\"\n                 );\n          }\n          uVar24 = xstrndup(&unaff_R12->field_0x7,sVar15 - 7);\n          puVar20[5] = uVar24;\n        }\nLAB_00117e3d:\n      } while (pFVar14 != (FILE *)0x0);\n      *(int *)(puVar20 + 3) = (int)ppuVar29;\n      unaff_R13 = (char *)0x0;\n      if (puVar20[5] != 0) {\n        *puVar20 = add_sym_list;\n        bVar39 = add_sym_list == (undefined8 *)0x0;\n        add_sym_list = puVar20;\n        if (bVar39) {\n          add_sym_tail = (undefined *)puVar20;\n        }\n        goto LAB_00117e65;\n      }\n    }\n    *(undefined8 **)add_sym_tail = puVar20;\n    add_sym_tail = (undefined *)puVar20;\nLAB_00117e65:\n    add_symbols = add_symbols + 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x99:\n    use_alt_mach_code = strtoul((char *)_optarg,(char **)0x0,0);\n    if (use_alt_mach_code == 0) {\n      pcVar32 = \"unable to parse alternative machine code\";\n      goto LAB_00117aed;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0x9a:\n    change_section_address = parse_vma(_optarg,\"--change-addresses\");\n    change_start = change_section_address;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x9b:\n    change_leading_char = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x9c:\n  case (char *)0x9d:\n  case (char *)0x9e:\n    ppuVar29 = (undefined **)strchr((char *)_optarg,0x3d);\n    if (uVar36 == 0x9d) {\n      uVar12 = 0x40;\n      unaff_R13 = \"--change-section-lma\";\n      if ((FILE *)ppuVar29 != (FILE *)0x0) {\n        uVar12 = 0x20;\n        goto LAB_00117a19;\n      }\n    }\n    else if (uVar36 == 0x9e) {\n      if ((FILE *)ppuVar29 != (FILE *)0x0) {\n        unaff_R13 = \"--change-section-vma\";\n        uVar12 = 8;\n        goto LAB_00117a19;\n      }\n      uVar12 = 0x10;\n      unaff_R13 = \"--change-section-vma\";\n    }\n    else {\n      unaff_R13 = \"--change-section-address\";\n      uVar12 = 0x28;\n      if ((FILE *)ppuVar29 != (FILE *)0x0) goto LAB_00117a19;\n      uVar12 = 0x50;\n    }\n    ppuVar29 = (undefined **)strchr((char *)pFVar14,0x2b);\n    if (((FILE *)ppuVar29 == (FILE *)0x0) &&\n       (ppuVar29 = (undefined **)strchr((char *)pFVar14,0x2d), (FILE *)ppuVar29 == (FILE *)0x0)) {\n      uVar24 = dcgettext(0,\"bad format for %s\",5);\n                    \n      fatal(uVar24,unaff_R13);\n    }\nLAB_00117a19:\n    iVar11 = (int)ppuVar29 - iVar11;\n    pcVar32 = (char *)xmalloc((long)(iVar11 + 1));\n    unaff_R12 = (FILE *)(long)iVar11;\n    pcVar32 = strncpy(pcVar32,(char *)_optarg,(size_t)unaff_R12);\n    pcVar32[(long)unaff_R12] = '\\0';\n    lVar30 = find_section_list(pcVar32,1,uVar12);\n    lVar17 = parse_vma((undefined *)((long)(int *)ppuVar29 + 1),unaff_R13);\n    if (*(char *)(int *)ppuVar29 == '-') {\n      lVar17 = -lVar17;\n    }\n    if ((uVar36 == 0x9d) || (*(long *)(lVar30 + 0x18) = lVar17, uVar36 != 0x9e)) {\n      *(long *)(lVar30 + 0x20) = lVar17;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0x9f:\n    change_start = parse_vma(_optarg,\"--change-start\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa0:\n    local_130 = (FILE *)(ulong)bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa1:\n    ppuVar29 = (undefined **)_optarg;\n    if (_optarg == (FILE *)0x0) {\nLAB_00118398:\n      do_debug_sections = 1;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcasecmp((char *)_optarg,\"none\");\n    if (iVar11 == 0) {\n      do_debug_sections = 0x20;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcasecmp((char *)pFVar14,\"zlib\");\n    if (iVar11 == 0) {\n      do_debug_sections = 3;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcasecmp((char *)pFVar14,\"zlib-gnu\");\n    if (iVar11 == 0) {\n      do_debug_sections = 5;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcasecmp((char *)pFVar14,\"zlib-gabi\");\n    if (iVar11 == 0) {\n      do_debug_sections = 9;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcasecmp((char *)pFVar14,\"zstd\");\n    if (iVar11 == 0) {\n      do_debug_sections = 0x11;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    pcVar32 = \"unrecognized --compress-debug-sections type `%s\\'\";\n    break;\n  case (char *)0xa2:\n    convert_debugging = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa3:\n    do_debug_sections = 0x20;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa4:\n    dump_sections = init_section_add(_optarg,dump_sections,\"--dump-section\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa5:\n    iVar11 = strcasecmp((char *)_optarg,\"yes\");\n    if (iVar11 == 0) {\n      do_elf_stt_common = 1;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcasecmp((char *)pFVar14,\"no\");\n    if (iVar11 == 0) {\n      do_elf_stt_common = 2;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    pcVar32 = \"unrecognized --elf-stt-common= option `%s\\'\";\n    break;\n  case (char *)0xa6:\n    strip_symbols = 6;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa7:\n    extract_symbol = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa8:\n    pe_file_alignment = parse_vma(_optarg,\"--file-alignment\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa9:\n    local_118 = (size_t)bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xaa:\n    ppuVar29 = (undefined **)parse_vma(_optarg,\"--gap-fill\");\n    gap_fill = SUB81(ppuVar29,0);\n    if ((FILE *)0xff < ppuVar29) {\n      uVar24 = dcgettext(0,\"Warning: truncating gap-fill from 0x%lx to 0x%x\",5);\n      non_fatal(uVar24,ppuVar29,(ulong)ppuVar29 & 0xff);\n    }\n    gap_fill_set = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xab:\n    ppFVar23 = (FILE **)htab_find_slot(globalize_specific_htab,_optarg,1);\n    *ppFVar23 = pFVar14;\n    ppuVar29 = (undefined **)pFVar14;\n    bVar2 = bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xac:\n    add_specific_symbols(_optarg,globalize_specific_htab,&globalize_specific_buffer);\n    bVar2 = bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xad:\n    pe_heap_reserve = strtoul((char *)_optarg,(char **)(FILE *)local_c8,0);\n    unaff_R12 = _optarg;\n    ppuVar29 = (undefined **)(FILE *)local_c8;\n    if ((FILE *)local_c8._0_8_ != _optarg) {\n      if (*(char *)(int *)local_c8._0_8_ == '.') {\n        pe_heap_commit =\n             strtoul((char *)((long)(int *)local_c8._0_8_ + 1),(char **)(FILE *)local_c8,0);\n        pFVar14 = _optarg;\n        if (*(char *)(int *)local_c8._0_8_ != '\\0') {\n          uVar24 = dcgettext(0,\"%s: invalid commit value for --heap\",5);\n          non_fatal(uVar24,pFVar14);\n          ppuVar29 = (undefined **)pFVar14;\n        }\n        goto switchD_00117234_caseD_0;\n      }\n      if (*(char *)(int *)local_c8._0_8_ == '\\0') goto switchD_00117234_caseD_0;\n    }\n    uVar24 = dcgettext(0,\"%s: invalid reserve value for --heap\",5);\n    non_fatal(uVar24,unaff_R12);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xae:\n    pe_image_base = parse_vma(_optarg,\"--image-base\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xaf:\n    bfd_flags_to_clear = bfd_flags_to_clear | 0x100;\n    bfd_flags_to_set = bfd_flags_to_set & 0xfffffeff;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb0:\n    lVar30 = strtol((char *)_optarg,(char **)0x0,10);\n    copy_width = (int)lVar30;\n    if (copy_width < 1) {\n      pcVar32 = \"interleave width must be positive\";\n      goto LAB_00117aed;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb1:\n    add_specific_symbols(_optarg,keepglobal_specific_htab,&keepglobal_specific_buffer);\n    local_108 = (long *)(ulong)bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb2:\n    keep_file_symbols = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb3:\n    find_section_list(_optarg,1,4);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb4:\n    add_specific_symbols(_optarg,keep_specific_htab,&keep_specific_buffer);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb5:\n    keep_section_symbols = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb6:\n    localize_hidden = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb7:\n    add_specific_symbols(_optarg,localize_specific_htab,&localize_specific_buffer);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb8:\n    iVar11 = strcmp(\"enable\",(char *)_optarg);\n    if (iVar11 == 0) {\n      long_section_names = 1;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcmp(\"disable\",(char *)pFVar14);\n    if (iVar11 == 0) {\n      long_section_names = 0;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcmp(\"keep\",(char *)pFVar14);\n    if (iVar11 == 0) {\n      long_section_names = 2;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    pcVar32 = \"unknown long section names option \\'%s\\'\";\n    break;\n  case (char *)0xba:\n    merge_notes = 0;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbb:\n    local_130 = (FILE *)0x0;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbc:\n    strip_symbols = 4;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbd:\n    pad_to = parse_vma(_optarg,\"--pad-to\");\n    pad_to_set = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbe:\n    prefix_alloc_sections_string = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbf:\n    prefix_sections_string = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc0:\n    prefix_symbols_string = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc1:\nswitchD_00117234_caseD_c1:\n    bfd_flags_to_set = bfd_flags_to_set | 0x100;\n    bfd_flags_to_clear = bfd_flags_to_clear & 0xfffffeff;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc2:\n    bfd_flags_to_set = bfd_flags_to_set | 0x80;\n    bfd_flags_to_clear = bfd_flags_to_clear & 0xffffff7f;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc3:\n    unaff_R13 = &optarg;\n    pcVar32 = strchr((char *)_optarg,0x3d);\n    if (pcVar32 == (char *)0x0) {\n      uVar24 = dcgettext(0,\"bad format for %s\",5);\n                    \n      fatal(uVar24,\"--redefine-sym\");\n    }\n    ppuVar29 = (undefined **)(pcVar32 + 1);\n    iVar11 = (int)pcVar32 - iVar11;\n    pcVar32 = (char *)xmalloc((long)(iVar11 + 1));\n    strncpy(pcVar32,(char *)_optarg,(long)iVar11);\n    pcVar32[iVar11] = '\\0';\n    sVar15 = strlen((char *)ppuVar29);\n    unaff_R12 = (FILE *)xmalloc((long)((int)sVar15 + 1));\n    strcpy((char *)unaff_R12,(char *)ppuVar29);\n    add_redefine_and_check(\"--redefine-sym\",pcVar32,unaff_R12);\n    free(pcVar32);\n    free(unaff_R12);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc4:\n    ppuVar29 = (undefined **)fopen((char *)_optarg,\"r\");\n    if ((FILE *)ppuVar29 == (FILE *)0x0) {\n      piVar25 = __errno_location();\n      pcVar32 = strerror(*piVar25);\n      uVar24 = dcgettext(0,\"couldn\\'t open symbol redefinition file %s (error: %s)\",5);\n                    \n      fatal(uVar24,pFVar14,pcVar32);\n    }\n    pFVar21 = (FILE *)0x64;\n    unaff_R13 = (char *)xmalloc(0x65);\n    iVar13 = getc((FILE *)ppuVar29);\n    iVar11 = 2;\nLAB_00118ace:\n    unaff_R12 = (FILE *)ppuVar29;\n    if (iVar13 != -1) {\n      pFVar33 = (FILE *)0x0;\n      while ((iVar13 != 0x20 && (iVar13 != 9))) {\n        if ((iVar13 == 10) || (iVar13 == 0xd)) {\n          *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n          goto LAB_00118faa;\n        }\n        if (iVar13 == 0) break;\n        if (iVar13 == -1) {\n          *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n          unaff_R12 = (FILE *)((long)&pFVar33->_flags + 1);\n          goto LAB_00119803;\n        }\n        unaff_R12 = pFVar33;\n        if (iVar13 == 0x23) goto LAB_00119745;\n        pFVar38 = (FILE *)((long)&pFVar33->_flags + 1);\n        *(char *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = (char)iVar13;\n        if (pFVar21 <= pFVar38) {\n          pFVar21 = (FILE *)((long)pFVar21 * 2);\n          unaff_R13 = (char *)xrealloc(unaff_R13,(undefined *)((long)&pFVar21->_flags + 1));\n        }\n        iVar13 = getc((FILE *)ppuVar29);\n        pFVar33 = pFVar38;\n      }\n      unaff_R12 = (FILE *)((long)&pFVar33->_flags + 1);\n      *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n      while ((iVar13 == 0x20 || (iVar13 == 9))) {\n        iVar13 = getc((FILE *)ppuVar29);\n      }\n      if (iVar13 == 0x23) {\nLAB_00119745:\n        if (unaff_R12 != (FILE *)0x0) goto LAB_0011974a;\n        pFVar33 = (FILE *)0x0;\n        unaff_R12 = (FILE *)0x0;\nLAB_001197ca:\n        *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n        while ((iVar13 != 10 && (iVar13 != -1))) {\n          iVar13 = getc((FILE *)ppuVar29);\n        }\n        goto LAB_0011903b;\n      }\nLAB_00118faa:\n      unaff_R12 = (FILE *)((long)&pFVar33->_flags + 1);\n      if (((iVar13 == 10) || (iVar13 == 0xd)) || (iVar13 == 0)) goto LAB_00119745;\n      pFVar38 = unaff_R12;\n      if (iVar13 != -1) {\n        do {\n          pFVar33 = (FILE *)((long)&pFVar38->_flags + 1);\n          *(char *)((long)&pFVar38->_flags + (long)(int *)unaff_R13) = (char)iVar13;\n          if (pFVar21 <= pFVar33) {\n            pFVar21 = (FILE *)((long)pFVar21 * 2);\n            unaff_R13 = (char *)xrealloc(unaff_R13,(undefined *)((long)&pFVar21->_flags + 1));\n          }\n          iVar13 = getc((FILE *)ppuVar29);\n          if ((iVar13 == 0x20) || (iVar13 == 9)) {\nLAB_001198b6:\n            *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n            pFVar33 = (FILE *)((long)&pFVar38->_flags + 2);\n            goto LAB_00119858;\n          }\n          if ((iVar13 == 10) || (iVar13 == 0xd)) {\n            *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n            goto LAB_0011902d;\n          }\n          if (iVar13 == 0) goto LAB_001198b6;\n          if (iVar13 == -1) {\n            *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n            unaff_R12 = (FILE *)((long)&pFVar38->_flags + 2);\n            goto LAB_00119803;\n          }\n          pFVar38 = pFVar33;\n        } while (iVar13 != 0x23);\nLAB_001198ec:\n        if ((pFVar33 == (FILE *)0x0) || ((unaff_R12 != (FILE *)0x0 && (unaff_R12 != pFVar33)))) {\n          iVar13 = 0x23;\n          goto LAB_001197ca;\n        }\nLAB_0011974a:\n        pcVar32 = \"%s:%d: missing new symbol name\";\n        goto LAB_00119756;\n      }\nLAB_00119803:\n      if (unaff_R12 != (FILE *)0x0) {\n        pcVar32 = \"%s:%d: premature end of file\";\n        goto LAB_00119756;\n      }\n    }\nLAB_00119065:\n    free(unaff_R13);\n    fclose((FILE *)ppuVar29);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc5:\n    remove_leading_char = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc6:\n    find_section_list(_optarg,1,0x100);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc7:\n    goto switchD_00117234_caseD_c7;\n  case (char *)0xc8:\n    ppuVar29 = (undefined **)(ulong)reverse_bytes;\n    uVar27 = strtol((char *)_optarg,(char **)0x0,10);\n    reverse_bytes = (uint)uVar27;\n    if (((int)reverse_bytes < 1) || ((uVar27 & 1) != 0)) {\n      pcVar32 = \"number of bytes to reverse must be positive and even\";\n      goto LAB_00117aed;\n    }\n    if ((uVar10 != reverse_bytes) && (uVar10 != 0)) {\n      uVar24 = dcgettext(0,\"Warning: ignoring previous --reverse-bytes value of %d\",5);\n      non_fatal(uVar24,uVar10);\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc9:\n    pe_section_alignment = parse_vma(_optarg,\"--section-alignment\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xca:\n    unaff_R12 = (FILE *)strchr((char *)_optarg,0x3d);\n    if (unaff_R12 == (FILE *)0x0) {\n      uVar24 = dcgettext(0,\"bad format for %s\",5);\n                    \n      fatal(uVar24,\"--set-section-flags\");\n    }\n    iVar11 = (int)unaff_R12 - iVar11;\n    pcVar32 = (char *)xmalloc((long)(iVar11 + 1));\n    pcVar32 = strncpy(pcVar32,(char *)_optarg,(long)iVar11);\n    pcVar32[iVar11] = '\\0';\n    ppuVar29 = (undefined **)find_section_list(pcVar32,1,0x80);\n    uVar12 = parse_flags((undefined *)((long)&unaff_R12->_flags + 1));\n    *(undefined4 *)((long)ppuVar29 + 0x28) = uVar12;\n    unaff_R13 = (char *)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xcb:\n    pcVar32 = strchr((char *)_optarg,0x3d);\n    if (pcVar32 == (char *)0x0) {\n      pcVar32 = \"bad format for --set-section-alignment: argument needed\";\n      goto LAB_00117aed;\n    }\n    uVar27 = strtol(pcVar32 + 1,(char **)0x0,10);\n    if ((int)uVar27 < 1) goto LAB_001189a2;\n    unaff_R12 = (FILE *)0x0;\n    while( true ) {\n      if ((uVar27 & 1) != 0) break;\n      uVar27 = (ulong)(uint)((int)uVar27 >> 1);\n      unaff_R12 = (FILE *)(ulong)((int)unaff_R12 + 1);\n    }\n    if ((int)uVar27 != 1) {\n      pcVar32 = \"bad format for --set-section-alignment: alignment is not a power of two\";\n      goto LAB_00117aed;\n    }\n    iVar11 = (int)pcVar32 - (int)_optarg;\n    ppuVar29 = (undefined **)(long)iVar11;\n    pcVar32 = (char *)xmalloc((long)(iVar11 + 1));\n    pcVar32 = strncpy(pcVar32,(char *)_optarg,(size_t)ppuVar29);\n    pcVar32[(long)ppuVar29] = '\\0';\n    lVar30 = find_section_list(pcVar32,1,0x200);\n    if (lVar30 != 0) {\n      *(int *)(lVar30 + 0x2c) = (int)unaff_R12;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xcc:\n    set_start = parse_vma(_optarg,\"--set-start\");\n    set_start_set = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xce:\n    __bfd_srec_len = parse_vma(_optarg,\"--srec-len\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xcf:\n    pe_stack_reserve = strtoul((char *)_optarg,(char **)(FILE *)local_c8,0);\n    unaff_R12 = _optarg;\n    ppuVar29 = (undefined **)(FILE *)local_c8;\n    if ((FILE *)local_c8._0_8_ != _optarg) {\n      if (*(char *)(int *)local_c8._0_8_ == '.') {\n        pe_stack_commit =\n             strtoul((char *)((long)(int *)local_c8._0_8_ + 1),(char **)(FILE *)local_c8,0);\n        pFVar14 = _optarg;\n        if (*(char *)(int *)local_c8._0_8_ != '\\0') {\n          uVar24 = dcgettext(0,\"%s: invalid commit value for --stack\",5);\n          non_fatal(uVar24,pFVar14);\n          ppuVar29 = (undefined **)pFVar14;\n        }\n        goto switchD_00117234_caseD_0;\n      }\n      if (*(char *)(int *)local_c8._0_8_ == '\\0') goto switchD_00117234_caseD_0;\n    }\n    uVar24 = dcgettext(0,\"%s: invalid reserve value for --stack\",5);\n    non_fatal(uVar24,unaff_R12);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd0:\n    strip_symbols = 5;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd1:\n    add_specific_symbols(_optarg,strip_specific_htab,&strip_specific_buffer);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd2:\n    strip_symbols = 3;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd3:\n    ppFVar23 = (FILE **)htab_find_slot(strip_unneeded_htab,_optarg,1);\n    *ppFVar23 = pFVar14;\n    ppuVar29 = (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd4:\n    add_specific_symbols(_optarg,strip_unneeded_htab,&strip_unneeded_buffer);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd5:\n    pcVar32 = strchr((char *)_optarg,0x3a);\n    pFVar21 = pFVar14;\n    if (pcVar32 != (char *)0x0) {\n      pFVar21 = (FILE *)xstrdup(pFVar14);\n      lVar30 = (long)((int)pcVar32 - iVar11);\n      *(undefined *)((long)&pFVar21->_flags + lVar30) = 0;\n      local_c8._0_8_ = pFVar21;\n      uVar27 = strtoul((char *)((long)&pFVar21->_flags + lVar30 + 1),(char **)local_c8,0);\n      pe_major_subsystem_version = (undefined2)uVar27;\n      if (*(char *)(int *)local_c8._0_8_ == '.') {\n        uVar27 = strtoul((char *)((long)(int *)local_c8._0_8_ + 1),(char **)local_c8,0);\n        pe_minor_subsystem_version = (undefined2)uVar27;\n      }\n      if (*(char *)(int *)local_c8._0_8_ != '\\0') {\n        uVar24 = dcgettext(0,\"%s: bad version in PE subsystem\",5);\n        non_fatal(uVar24,pFVar14);\n      }\n    }\n    lVar30 = strtol((char *)pFVar21,(char **)local_c8,0);\n    if (*(char *)(int *)local_c8._0_8_ == '\\0') {\n      lVar17 = 0;\n      while ((short)lVar30 != (&DAT_00125caa)[lVar17 * 8]) {\n        lVar17 = lVar17 + 1;\n        if (lVar17 == 10) goto LAB_00119248;\n      }\n      ppuVar29 = &v_0;\n      cVar8 = (&DAT_00125ca8)[lVar17 * 0x10];\n      pe_subsystem = (short)lVar30;\n    }\n    else {\n      unaff_R13 = (char *)0x0;\n      while( true ) {\n        iVar11 = strcmp((char *)pFVar21,(&v_0)[(long)unaff_R13 * 2]);\n        if (iVar11 == 0) break;\n        unaff_R13 = (char *)((long)(int *)unaff_R13 + 1);\n        if ((FILE *)unaff_R13 == (FILE *)0xa) goto LAB_00119248;\n      }\n      ppuVar29 = &v_0 + (long)unaff_R13 * 2;\n      pe_subsystem = (&DAT_00125caa)[(long)unaff_R13 * 8];\n      cVar8 = (&DAT_00125ca8)[(long)unaff_R13 * 0x10];\n    }\n    if (cVar8 == -1) {\nLAB_00119248:\n      uVar24 = dcgettext(0,\"unknown PE subsystem: %s\",5);\n                    \n      fatal(uVar24,pFVar14);\n    }\n    if (cVar8 != '\\0') {\n      if (pe_file_alignment == -1) {\n        pe_file_alignment = 0x200;\n      }\n      if (pe_section_alignment == -1) {\n        pe_section_alignment = 0x1000;\n      }\n    }\n    unaff_R12 = pFVar14;\n    if (pFVar14 != pFVar21) {\n      free(pFVar21);\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd6:\n    update_sections = init_section_add(_optarg,update_sections,\"--update-section\");\n    section_add_load_file(update_sections);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd7:\n    _VerilogDataWidth = parse_vma(_optarg,\"--verilog-data-width\");\n    if ((0x10 < _VerilogDataWidth) || ((0x10116UL >> ((byte)_VerilogDataWidth & 0x3f) & 1) == 0)) {\n      pcVar32 = \"error: verilog data width must be 1, 2, 4, 8 or 16\";\n      goto LAB_00117aed;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd8:\n    weaken = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd9:\n    add_specific_symbols(_optarg,weaken_specific_htab,&weaken_specific_buffer);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xda:\n    bfd_flags_to_clear = bfd_flags_to_clear | 0x80;\n    bfd_flags_to_set = bfd_flags_to_set & 0xffffff7f;\n    goto switchD_00117234_caseD_0;\n  }\nLAB_001176c2:\n  uVar24 = dcgettext(0,pcVar32,5);\n                    \n  fatal(uVar24,pFVar14);\n}\n\n",
            "called": [
                "add_redefine_and_check",
                "strchr",
                "bfd_set_error_program_name",
                "memmove",
                "find_section_list",
                "filename_cmp",
                "xstrndup",
                "strtoul",
                "fatal",
                "copy_usage",
                "dup",
                "strlen",
                "strncpy",
                "bfd_init",
                "dcgettext",
                "htab_create_alloc",
                "xrealloc",
                "ftell",
                "bfd_nonfatal_message",
                "convert_efi_target",
                "display_info.isra.0",
                "strtol",
                "add_specific_symbols",
                "strcmp",
                "mkstemp",
                "non_fatal",
                "template_in_dir",
                "free",
                "getc",
                "bindtextdomain",
                "bfd_set_default_target",
                "eq_string_redefnode",
                "fprintf",
                "strcpy",
                "handle_remove_section_option",
                "delete_symbol_htabs",
                "print_version",
                "fseek",
                "getopt_long",
                "copy_file",
                "setlocale",
                "fopen",
                "__errno_location",
                "htab_hash_redefnode",
                "stat",
                "free",
                "strerror",
                "section_add_load_file",
                "bfd_errmsg",
                "xmalloc_set_program_name",
                "parse_flags",
                "close",
                "startswith.lto_priv.0.lto_priv.0",
                "strip_usage",
                "init_section_add",
                "xcalloc",
                "htab_elements",
                "strncasecmp",
                "malloc",
                "get_file_size",
                "bfd_scan_arch",
                "unlink_if_ordinary",
                "memcpy",
                "strcasecmp",
                "xexit",
                "htab_find_slot",
                "ferror",
                "fread",
                "create_symbol_htab",
                "xatexit_cleanup.lto_priv.0",
                "bfd_get_error",
                "xstrdup",
                "fclose",
                "parse_vma",
                "smart_rename",
                "xmalloc",
                "textdomain"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00116b90",
            "calling": [
                "_start"
            ],
            "imported": false,
            "current_name": "FUNC_00116b90"
        },
        "FUN_00128180": {
            "renaming": {},
            "code": "\n\n\n\nint dup(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* dup@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128180",
            "calling": [
                "dup"
            ],
            "imported": false,
            "current_name": "FUN_00128180"
        },
        "FUN_00104090": {
            "renaming": {},
            "code": "\nvoid htab_delete(void)\n\n{\n  htab_delete();\n  return;\n}\n\n",
            "called": [
                "htab_delete"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104090",
            "calling": [
                "delete_symbol_htabs"
            ],
            "imported": false,
            "current_name": "FUN_00104090"
        },
        "FUN_00128068": {
            "renaming": {},
            "code": "\n\n\n\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strncmp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128068",
            "calling": [
                "strncmp"
            ],
            "imported": false,
            "current_name": "FUN_00128068"
        },
        "FUN_0010be88": {
            "renaming": {
                "FUN_0010be88": "start_debug_block_0010be88",
                "param_1": "blockPtr",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "puVar1": "nextPtr",
                "uVar2": "result",
                "puVar3": "newBlock",
                "puVar4": "currentPtr",
                "puVar6": "lastPtr",
                "puVar7": "tempPtr",
                "bVar8": "flag",
                "auVar9": "returnValue",
                "lVar5": "blockValue"
            },
            "code": "\n\n\nundefined  [16] startDebugBlock_0010be88(long blockPtr,undefined8 param2,undefined8 param3,undefined8 param4)\n\n{\n  undefined8 *nextPtr;\n  undefined8 result;\n  undefined4 *newBlock;\n  undefined8 *currentPtr;\n  long blockValue;\n  undefined8 *lastPtr;\n  undefined4 *tempPtr;\n  byte flag;\n  undefined returnValue [16];\n  \n  flag = 0;\n  if ((*(long *)(blockPtr + 8) == 0) || (*(long *)(blockPtr + 0x20) == 0)) {\n    result = dcgettext(0,\"debug_start_block: no current block\",5);\n    fprintf(_stderr,\"%s\\n\",result);\n    result = 0;\n  }\n  else {\n    newBlock = (undefined4 *)xmalloc(0x30);\n    tempPtr = newBlock;\n    for (blockValue = 0xc; blockValue != 0; blockValue = blockValue + -1) {\n      *tempPtr = 0;\n      tempPtr = tempPtr + (ulong)flag * -2 + 1;\n    }\n    blockValue = *(long *)(blockPtr + 0x20);\n    *(undefined8 *)(newBlock + 6) = param2;\n    *(undefined8 *)(newBlock + 8) = 0xffffffffffffffff;\n    *(long *)(newBlock + 2) = blockValue;\n    nextPtr = *(undefined8 **)(blockValue + 0x10);\n    lastPtr = (undefined8 *)(blockValue + 0x10);\n    while (currentPtr = nextPtr, currentPtr != (undefined8 *)0x0) {\n      lastPtr = currentPtr;\n      nextPtr = (undefined8 *)*currentPtr;\n    }\n    *lastPtr = newBlock;\n    result = 1;\n    *(undefined4 **)(blockPtr + 0x20) = newBlock;\n  }\n  returnValue._8_8_ = param4;\n  returnValue._0_8_ = result;\n  return returnValue;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010be88",
            "calling": [
                "parse_stab",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "start_debug_block_0010be88"
        },
        "FUN_0010ba08": {
            "renaming": {
                "FUN_0010ba08": "generate_warning_message_0010ba08",
                "param_1": "functionParams",
                "param_2": "fieldName",
                "param_3": "param3Value",
                "param_4": "structSize",
                "param_5": "param5Value",
                "cVar1": "charValue",
                "iVar2": "intValue",
                "lVar3": "longValue",
                "__s": "stringValue1",
                "sVar4": "string1Size",
                "sVar5": "fieldNameSize",
                "sVar6": "stringValue2Size",
                "__s_00": "newString1",
                "uVar7": "errorMessage",
                "uVar8": "returnValue",
                "pcVar9": "string2",
                "stab_pop_type": "popType",
                "xmalloc": "allocateMemory",
                "strlen": "getStringLength",
                "sprintf": "formatStringWithValues",
                "free": "freeMemory",
                "dcgettext": "getTranslatedString",
                "non_fatal": "handleNonFatalError",
                "abort": "terminateProgram"
            },
            "code": "\nundefined8\ngenerateWarningMessage_0010ba08(undefined8 *functionParams,char *fieldName,undefined8 param3Value,ulong structSize,int param5Value)\n\n{\n  char charValue;\n  int intValue;\n  long longValue;\n  char *stringValue1;\n  size_t string1Size;\n  size_t fieldNameSize;\n  size_t stringValue2Size;\n  char *newString1;\n  undefined8 errorMessage;\n  undefined8 returnValue;\n  char *string2;\n  \n  charValue = *(char *)(functionParams[0xc] + 0x1c);\n  intValue = *(int *)(functionParams[0xc] + 0x18);\n  stringValue1 = (char *)popType();\n  if (*(char **)(functionParams[0xc] + 0x20) == (char *)0x0) {\n    returnValue = 0;\n  }\n  else {\n    string1Size = getStringLength(*(char **)(functionParams[0xc] + 0x20));\n    fieldNameSize = getStringLength(fieldName);\n    stringValue2Size = getStringLength(stringValue1);\n    newString1 = (char *)allocateMemory(string1Size + 0x32 + fieldNameSize + stringValue2Size);\n    if (param5Value == 1) {\n      string2 = \"/1\";\n    }\n    else {\n      string2 = \"/0\";\n      if ((param5Value != 2) && (string2 = \"\", param5Value != 0)) {\n                    \n        terminateProgram();\n      }\n    }\n    if ((structSize == 0) && (structSize = (ulong)(uint)(intValue * 8), structSize == 0)) {\n      returnValue = *(undefined8 *)*functionParams;\n      errorMessage = getTranslatedString(0,\"%s: warning: unknown size for field `%s\\' in struct\",5);\n      handleNonFatalError(errorMessage,returnValue,fieldName);\n    }\n    formatStringWithValues(newString1,\"%s%s:%s%s,%ld,%ld;\",*(undefined8 *)(functionParams[0xc] + 0x20),fieldName,string2,stringValue1,\n            param3Value,structSize);\n    freeMemory(*(void **)(functionParams[0xc] + 0x20));\n    longValue = functionParams[0xc];\n    *(char **)(longValue + 0x20) = newString1;\n    if (charValue != '\\0') {\n      *(undefined *)(longValue + 0x1c) = 1;\n    }\n    returnValue = CONCAT71((int7)((ulong)longValue >> 8),1);\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "strlen",
                "dcgettext",
                "non_fatal",
                "sprintf",
                "abort",
                "free",
                "xmalloc",
                "stab_pop_type"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010ba08",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "generate_warning_message_0010ba08"
        },
        "FUN_00128188": {
            "renaming": {},
            "code": "\n\n\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* lseek@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128188",
            "calling": [
                "lseek"
            ],
            "imported": false,
            "current_name": "FUN_00128188"
        },
        "FUN_0010aa53": {
            "renaming": {
                "FUN_0010aa53": "update_data_0010aa53",
                "param_1": "dataPtr",
                "param_2": "newValue",
                "param_3": "flag",
                "param_4": "action",
                "cVar1": "counter",
                "__s": "string",
                "sVar5": "strLen",
                "pcVar6": "newData",
                "lVar2": "basePtr",
                "cVar3": "actionFlag",
                "uVar4": "index",
                "lVar7": "reallocPtr",
                "uVar8": "success",
                "uVar9": "indexTemp",
                "uVar10": "indexMax"
            },
            "code": "\nundefined8 updateData_0010aa53(long dataPtr,undefined8 newValue,char flag,int action)\n\n{\n  char counter;\n  long basePtr;\n  char actionFlag;\n  uint index;\n  char *string;\n  size_t strLen;\n  char *newData;\n  long reallocPtr;\n  undefined8 success;\n  ulong indexTemp;\n  ulong indexMax;\n  \n  counter = *(char *)(*(long *)(dataPtr + 0x60) + 0x1c);\n  string = (char *)stab_pop_type();\n  strLen = strlen(string);\n  newData = (char *)xmalloc(strLen + 0x19);\n  *newData = flag + '0';\n  if (action == 1) {\n    actionFlag = '1';\n  }\n  else {\n    actionFlag = '0';\n    if ((action != 2) && (actionFlag = '2', action != 0)) {\n                    \n      abort();\n    }\n  }\n  newData[1] = actionFlag;\n  sprintf(newData + 2,\"%ld,%s;\",newValue);\n  free(string);\n  basePtr = *(long *)(dataPtr + 0x60);\n  success = 0;\n  if ((basePtr != 0) && (*(long *)(basePtr + 0x20) != 0)) {\n    basePtr = *(long *)(basePtr + 0x28);\n    indexMax = 0;\n    if (basePtr != 0) {\n      index = 0;\n      do {\n        indexTemp = (ulong)index;\n        indexMax = (ulong)index;\n        index = index + 1;\n      } while (*(long *)(basePtr + indexTemp * 8) != 0);\n    }\n    reallocPtr = xrealloc(basePtr,(ulong)((int)indexMax + 2) << 3);\n    *(char **)(reallocPtr + indexMax * 8) = newData;\n    *(undefined8 *)(reallocPtr + (ulong)((int)indexMax + 1) * 8) = 0;\n    basePtr = *(long *)(dataPtr + 0x60);\n    *(long *)(basePtr + 0x28) = reallocPtr;\n    if (counter != '\\0') {\n      *(undefined *)(basePtr + 0x1c) = 1;\n    }\n    success = 1;\n  }\n  return success;\n}\n\n",
            "called": [
                "strlen",
                "sprintf",
                "abort",
                "xrealloc",
                "free",
                "xmalloc",
                "stab_pop_type"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010aa53",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "update_data_0010aa53"
        },
        "FUN_0011173a": {
            "renaming": {
                "FUN_0011173a": "parse_stab_function_0011173a",
                "param_2": "stab_data",
                "param_3": "opcode",
                "param_4": "line_number",
                "param_5": "address",
                "param_6": "name",
                "cVar1": "char1",
                "__ptr": "ptr",
                "cVar3": "char2",
                "uVar4": "result",
                "iVar5": "index",
                "puVar6": "ptr2",
                "plVar7": "ptr3",
                "pcVar8": "ptr4",
                "uVar9": "value",
                "lVar10": "length",
                "lVar11": "value2",
                "lVar12": "value3",
                "lVar13": "ptr5",
                "uVar14": "value4",
                "uVar15": "value5",
                "pcVar16": "ptr6",
                "uVar17": "value6",
                "pplVar18": "dptr",
                "dVar19": "value7",
                "local_48": "ptr7",
                "local_40": "array[2]"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0011244f) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nundefined parse_stab_function_0011173a(undefined8 param_1,long *stab_data,int opcode,int line_number,ulong address,\n                      char *name)\n\n{\n  char char1;\n  byte bVar2;\n  void *ptr;\n  char char2;\n  undefined result;\n  int index;\n  undefined8 *ptr2;\n  long *ptr3;\n  char *ptr4;\n  undefined8 value;\n  long length;\n  long value2;\n  long value3;\n  long **ppptr5;\n  ulong value4;\n  ulong value5;\n  char *ptr6;\n  uint value6;\n  long **dptr;\n  double value7;\n  char *ptr7;\n  long **array[2] [2];\n  \n  if (stab_data[4] != 0) {\n    if (((opcode == 100) && (*name != '\\0')) && (stab_data[5] == address)) goto LAB_00111a06;\n    char2 = debug_set_filename(param_1);\n    if (char2 == '\\0') {\n      return 0;\n    }\n    *(undefined *)((long)stab_data + 0x44) = 0;\n    *(undefined4 *)(stab_data + 8) = 0;\n    stab_data[9] = stab_data[4];\n    if (*(char *)(stab_data + 1) == '\\0') {\n      stab_data[6] = stab_data[5];\n    }\n    *(undefined4 *)(stab_data + 0x10) = 1;\n    ptr2 = (undefined8 *)xmalloc(8);\n    stab_data[0x11] = (long)ptr2;\n    *ptr2 = 0;\n    stab_data[4] = 0;\n  }\n  strlen(name);\n  if (opcode == 0x84) {\nLAB_00111ab7:\n    result = debug_start_source(param_1,name);\n    return result;\n  }\n  if (opcode < 0x85) {\n    if (opcode == 0x3c) {\n      index = strcmp(name,\"gcc2_compiled.\");\n      if (index == 0) {\n        *(undefined4 *)(stab_data + 8) = 2;\n        return 1;\n      }\n      index = strcmp(name,\"gcc_compiled.\");\n      if (index == 0) {\n        *(undefined4 *)(stab_data + 8) = 1;\n        return 1;\n      }\n      *(undefined *)((long)stab_data + 0x44) = 1;\n      return 1;\n    }\n    if (opcode < 0x3d) {\n      if (opcode == 0x24) {\n        if (*name == '\\0') {\n          if (*(char *)(stab_data + 0xc) == '\\0') {\n            return 1;\n          }\n          if (*(char *)(stab_data + 1) != '\\0') {\n            address = address + stab_data[7];\n          }\n          char2 = stab_emit_pending_vars(param_1,stab_data);\n          if (char2 != '\\0') {\n            char2 = debug_end_function(param_1,address);\n            if (char2 != '\\0') {\n              *(undefined *)(stab_data + 0xc) = 0;\n              stab_data[0xd] = -1;\n              return 1;\n            }\n            return 0;\n          }\n          return 0;\n        }\n        if ((*(char *)(stab_data + 0xc) != '\\0') &&\n           ((address < (ulong)stab_data[0xd] || (stab_data[0xd] == 0xffffffffffffffff)))) {\n          stab_data[0xd] = address;\n        }\n      }\n      else if (opcode < 0x25) {\n        if (opcode == 0xc) {\n          return 1;\n        }\n        if (opcode - 0x1eU < 2) {\n          return 1;\n        }\n      }\n      else {\n        if (opcode == 0x2a) {\n          return 1;\n        }\n        if (opcode == 0x38) {\n          return 1;\n        }\n      }\n    }\n    else {\n      if (opcode == 100) {\nLAB_00111a06:\n        if (*(char *)(stab_data + 0xc) != '\\0') {\n          value4 = address;\n          if (((*name != '\\0') && (value5 = stab_data[0xd], value5 != 0xffffffffffffffff)) &&\n             (value4 = value5, address < value5)) {\n            value4 = address;\n          }\n          char2 = stab_emit_pending_vars(param_1,stab_data);\n          if (char2 == '\\0') {\n            return 0;\n          }\n          char2 = debug_end_function(param_1,value4);\n          if (char2 == '\\0') {\n            return 0;\n          }\n          *(undefined *)(stab_data + 0xc) = 0;\n          stab_data[0xd] = -1;\n        }\n        if (*name == '\\0') {\n          return 1;\n        }\n        ptr = (void *)stab_data[4];\n        if (ptr == (void *)0x0) {\n          value3 = xstrdup(name);\n          stab_data[4] = value3;\n        }\n        else {\n          if (*name == '/') {\n            value3 = xstrdup(name);\n          }\n          else {\n            value3 = concat(ptr,name,0);\n          }\n          stab_data[4] = value3;\n          free(ptr);\n        }\n        stab_data[5] = address;\n        return 1;\n      }\n      if (opcode < 0x65) {\n        if (opcode == 0x44) {\n          value3 = 0;\n          if (*(char *)(stab_data + 0xc) != '\\0') {\n            value3 = stab_data[7];\n          }\n          result = debug_record_line(param_1,(long)line_number,value3 + address);\n          return result;\n        }\n        if (opcode == 0x62) {\n          return 1;\n        }\n      }\n      else if (opcode == 0x82) {\n        ptr3 = (long *)xmalloc();\n        index = *(int *)(stab_data + 0x10);\n        length = stab_data[10];\n        value2 = stab_data[0xb];\n        ptr3[5] = 0;\n        value3 = stab_data[0x11];\n        *(int *)(ptr3 + 4) = index;\n        value6 = index + 1;\n        *(uint *)(stab_data + 0x10) = value6;\n        *ptr3 = value2;\n        ptr3[1] = length;\n        ptr3[2] = (long)name;\n        ptr3[3] = address;\n        stab_data[10] = (long)ptr3;\n        stab_data[0xb] = (long)ptr3;\n        value3 = xrealloc(value3,(ulong)value6 << 3);\n        value6 = *(uint *)(ptr3 + 4);\n        stab_data[0x11] = value3;\n        *(undefined8 *)(value3 + (ulong)value6 * 8) = 0;\n        goto LAB_00111ab7;\n      }\n    }\nLAB_00111c29:\n    ptr4 = strchr(name,0x3a);\n    if ((ptr4 != (char *)0x0) && ((ptr4[1] & 0xdfU) == 0x46)) {\n      if (*(char *)(stab_data + 0xc) != '\\0') {\n        value4 = stab_data[0xd];\n        value5 = address;\n        if ((value4 != 0xffffffffffffffff) && (value5 = value4, address < value4)) {\n          value5 = address;\n        }\n        char2 = stab_emit_pending_vars(param_1,stab_data);\n        if (char2 == '\\0') {\n          return 0;\n        }\n        char2 = debug_end_function(param_1,value5);\n        if (char2 == '\\0') {\n          return 0;\n        }\n        stab_data[0xd] = -1;\n      }\n      if (*(char *)(stab_data + 1) != '\\0') {\n        stab_data[7] = address;\n      }\n      *(undefined *)(stab_data + 0xc) = 1;\n    }\n    ptr7 = strchr(name,0x3a);\n    if (ptr7 == (char *)0x0) {\n      return 1;\n    }\nLAB_00111cbc:\n    if (ptr7[1] == ':') goto code_r0x00111cc7;\n    if (*name == '$') {\n      char2 = name[1];\n      ptr6 = \"eh_throw\";\n      if (char2 != 'e') {\n        if (char2 < 'f') {\n          if ((char2 != 'X') && (char2 != '_')) {\nLAB_00111d1a:\n            value = dcgettext(0,\"unknown C++ encoded name\",5);\n            warn_stab(name,value);\n          }\n        }\n        else {\n          ptr6 = \"this\";\n          if (char2 == 't') goto LAB_00111d62;\n          if (char2 != 'v') goto LAB_00111d1a;\n        }\n        goto LAB_00111d38;\n      }\n    }\n    else {\nLAB_00111d38:\n      ptr6 = (char *)0x0;\n      if ((name != ptr7) && ((*name != ' ' || (ptr7 != name + 1)))) {\n        ptr6 = (char *)savestring(name,(int)ptr7 - (int)name);\n      }\n    }\nLAB_00111d62:\n    bVar2 = ptr7[1];\n    ptr4 = ptr7 + 1;\n    if (((byte)(*(ushort *)(&_sch_istable + (ulong)bVar2 * 2) >> 2) & 1 |\n        (bVar2 == 0x2d || bVar2 == 0x28)) != 0) {\nswitchD_00111de5_caseD_58:\n      ptr7 = ptr4;\n      value3 = parse_stab_type(param_1,stab_data,0,&ptr7,0);\n      if (value3 == 0) {\n        return 0;\n      }\n      value = 4;\n      goto LAB_001123e8;\n    }\n    if (bVar2 == 0) goto switchD_00111de5_caseD_44;\n    ptr4 = ptr7 + 2;\n    char2 = ptr7[1];\n    switch(char2) {\n    case 'C':\n      ptr7 = ptr4;\n      value3 = parse_stab_type(param_1,stab_data,0,&ptr7,0);\n      ptr4 = \"debug_record_label: not implemented\";\n      if (value3 == 0) {\n        return 0;\n      }\n      goto LAB_00111b96;\n    default:\n      goto switchD_00111de5_caseD_44;\n    case 'F':\n    case 'f':\n      ptr7 = ptr4;\n      value3 = parse_stab_type(param_1,stab_data,0,&ptr7,0);\n      if (value3 == 0) {\n        return 0;\n      }\n      char2 = debug_record_function(param_1,ptr6,value3,char2 == 'F',address);\n      if (char2 != '\\0') {\n        do {\n          if (*ptr7 != ';') {\n            return 1;\n          }\n          ptr7 = ptr7 + 1;\n          value3 = parse_stab_type(param_1,stab_data,0,&ptr7,0);\n        } while (value3 != 0);\n        return 0;\n      }\n      return 0;\n    case 'G':\n      ptr7 = ptr4;\n      value3 = parse_stab_type(param_1,stab_data,0,&ptr7,0);\n      if (value3 == 0) {\n        return 0;\n      }\n      if (ptr6 == (char *)0x0) goto LAB_0011208f;\n      length = stab_data[3];\n      ptr3 = (long *)stab_data[2];\n      char2 = *(char *)(*(long *)(*stab_data + 8) + 0x1c);\n      goto LAB_00112045;\n    case 'P':\n      if (opcode == 0x24) {\n        ptr7 = ptr4;\n        do {\n          if (*ptr7 != ';') {\n            return 1;\n          }\n          ptr7 = ptr7 + 1;\n          value3 = parse_stab_type(param_1,stab_data,0,&ptr7,0);\n        } while (value3 != 0);\n        return 0;\n      }\n    case 'R':\n      ptr7 = ptr4;\n      value3 = parse_stab_type(param_1,stab_data,0,&ptr7,0);\n      if (value3 == 0) {\n        return 0;\n      }\n      value = 2;\n      break;\n    case 'S':\n      ptr7 = ptr4;\n      value3 = parse_stab_type(param_1,stab_data,0,&ptr7,0);\n      if (value3 == 0) {\n        return 0;\n      }\n      value = 2;\n      goto LAB_001121c4;\n    case 'T':\n      char2 = ptr7[2];\n      if (char2 == 't') {\n        ptr4 = ptr7 + 3;\n      }\n      ptr7 = ptr4;\n      value3 = parse_stab_type(param_1,stab_data,ptr6,&ptr7,array[2]);\n      if (value3 == 0) {\n        return 0;\n      }\n      if (ptr6 == (char *)0x0) {\n        return 1;\n      }\n      char1 = *(char *)(stab_data + 0x35);\n      ptr3 = (long *)debug_tag_type(param_1,ptr6,value3);\n      if (ptr3 == (long *)0x0) {\n        return 0;\n      }\n      if (array[2][0] != (long **)0x0) {\n        *array[2][0] = ptr3;\n      }\n      if (char1 != '\\0') goto LAB_001122f0;\n      ppptr5 = (long **)(stab_data + 0x34);\n      dptr = (long **)stab_data[0x34];\n      goto LAB_001122b2;\n    case 'V':\n      ptr7 = ptr4;\n      value3 = parse_stab_type(param_1,stab_data,0,&ptr7,0);\n      if (value3 == 0) {\n        return 0;\n      }\n      value = 3;\n      goto LAB_001123e8;\n    case 'X':\n    case 'l':\n    case 's':\n      goto switchD_00111de5_caseD_58;\n    case 'Y':\n      ptr4 = ptr7 + 3;\n      if (((ptr7[2] != '\\0') && (ptr4 = ptr7 + 4, ptr7[3] == 'n')) &&\n         (ptr4 = ptr7 + 5, ptr6 = ptr7 + 4, ptr7 = ptr4, *ptr6 == '0')) {\n        for (; ptr4 = ptr7, *ptr7 != '\\0'; ptr7 = ptr7 + 1) {\n          if (*ptr7 == ';') {\n            return 1;\n          }\n        }\n      }\n      goto switchD_00111de5_caseD_44;\n    case 'a':\n      ptr7 = ptr4;\n      value3 = parse_stab_type(param_1,stab_data,0,&ptr7,0);\n      if (value3 == 0) {\n        return 0;\n      }\n      value = 4;\n      break;\n    case 'c':\n      if (ptr7[2] == '=') {\n        ptr4 = ptr7 + 4;\n        char2 = ptr7[3];\n        ptr7 = ptr4;\n        if (char2 == 'i') {\n          value3 = strtol(ptr4,(char **)0x0,10);\n          if (ptr6 == (char *)0x0) {\n            return 0;\n          }\n          length = debug_add_to_current_namespace_constprop_0(param_1,ptr6,4);\n          if (length != 0) {\n            *(long *)(length + 0x20) = (long)(int)value3;\n            return 1;\n          }\n          return 0;\n        }\n        if (char2 == 'r') {\n          value7 = strtod(ptr4,(char **)0x0);\n          if (ptr6 == (char *)0x0) {\n            return 0;\n          }\n          value3 = debug_add_to_current_namespace_constprop_0(param_1,ptr6,5);\n          if (value3 != 0) {\n            *(double *)(value3 + 0x20) = value7;\n            return 1;\n          }\n          return 0;\n        }\n        if (char2 == 'e') {\n          value3 = parse_stab_type(param_1,stab_data,0,&ptr7,0);\n          if (value3 == 0) {\n            return 0;\n          }\n          ptr4 = ptr7;\n          if (*ptr7 == ',') {\n            length = strtol(ptr7,(char **)0x0,10);\n            if (ptr6 == (char *)0x0) {\n              return 0;\n            }\n            value2 = debug_add_to_current_namespace_constprop_0(param_1,ptr6,6);\n            if (value2 != 0) {\n              ptr3 = (long *)xmalloc(0x10);\n              *ptr3 = value3;\n              ptr3[1] = (long)(int)length;\n              *(long **)(value2 + 0x20) = ptr3;\n              return 1;\n            }\n            return 0;\n          }\n        }\n      }\n      goto switchD_00111de5_caseD_44;\n    case 'p':\n      if (ptr7[2] == 'F') {\n        ptr7 = ptr7 + 3;\n        value3 = parse_stab_type(param_1,stab_data,0,&ptr7,0);\n        if (value3 == 0) {\n          return 0;\n        }\n        value = debug_make_function_type_isra_0(value3,0,0);\n        value3 = debug_make_pointer_type_isra_0(value);\n      }\n      else {\n        ptr7 = ptr4;\n        value3 = parse_stab_type(param_1,stab_data,0,&ptr7,0);\n      }\n      if (value3 == 0) {\n        return 0;\n      }\n      value = 1;\n      break;\n    case 'r':\n      ptr7 = ptr4;\n      value3 = parse_stab_type(param_1,stab_data,0,&ptr7,0);\n      if (value3 == 0) {\n        return 0;\n      }\n      value = 5;\nLAB_001123e8:\n      char2 = stab_record_variable(param_1,stab_data,ptr6,value3,value,address);\n      goto joined_r0x001123f8;\n    case 't':\n      ptr7 = ptr4;\n      value3 = parse_stab_type(param_1,stab_data,ptr6,&ptr7,array[2]);\n      if (value3 == 0) {\n        return 0;\n      }\n      if (ptr6 == (char *)0x0) {\n        return 1;\n      }\n      ptr3 = (long *)debug_name_type(param_1,ptr6,value3);\n      if (ptr3 == (long *)0x0) {\n        return 0;\n      }\n      if (array[2][0] == (long **)0x0) {\n        return 1;\n      }\n      *array[2][0] = ptr3;\n      return 1;\n    case 'v':\n      ptr7 = ptr4;\n      value3 = parse_stab_type(param_1,stab_data,0,&ptr7,0);\n      if (value3 == 0) {\n        return 0;\n      }\n      value = 3;\n    }\n    char2 = debug_record_parameter(param_1,ptr6,value3,value,address);\n    goto joined_r0x001123f8;\n  }\n  if (opcode == 0xe0) {\n    if ((*(char *)((long)stab_data + 0x44) != '\\0') && (line_number == 1)) {\n      return 1;\n    }\n    char2 = stab_emit_pending_vars(param_1,stab_data);\n    if (char2 == '\\0') {\n      return 0;\n    }\n    char2 = debug_end_block(param_1,stab_data[7] + stab_data[6] + address);\n    if (char2 == '\\0') {\n      return 0;\n    }\n    stab_data = stab_data + 0xe;\n    *(int *)stab_data = *(int *)stab_data + -1;\n    ptr4 = \"Too many N_RBRACs\\n\";\n    if (-1 < *(int *)stab_data) {\n      return 1;\n    }\n  }\n  else {\n    if (0xe0 < opcode) {\n      if (opcode == 0xe2) {\n        ptr4 = \"debug_start_common_block: not implemented\";\n      }\n      else {\n        ptr4 = \"debug_end_common_block: not implemented\";\n        if (opcode != 0xe4) goto LAB_00111c29;\n      }\nLAB_00111b96:\n      value = dcgettext(0,ptr4,5);\n      fprintf(_stderr,\"%s\\n\",value);\n      return 0;\n    }\n    if (opcode != 0xc0) {\n      if (opcode == 0xc2) {\n        index = *(int *)(stab_data + 0x10);\n        *(uint *)(stab_data + 0x10) = index + 1U;\n        value3 = xrealloc(stab_data[0x11],(ulong)(index + 1U) << 3);\n        ptr2 = (undefined8 *)stab_data[0xb];\n        stab_data[0x11] = value3;\n        while( true ) {\n          if (ptr2 == (undefined8 *)0x0) {\n            value = dcgettext(0,\"Undefined N_EXCL\",5);\n            warn_stab(name,value);\n            *(undefined8 *)(stab_data[0x11] + (ulong)(*(int *)(stab_data + 0x10) - 1) * 8) = 0;\n            return 1;\n          }\n          if ((address == ptr2[3]) && (index = strcmp((char *)ptr2[2],name), index == 0))\n          break;\n          ptr2 = (undefined8 *)*ptr2;\n        }\n        *(undefined8 *)(value3 + (ulong)(*(int *)(stab_data + 0x10) - 1) * 8) = ptr2[5];\n        return 1;\n      }\n      if (opcode == 0xa2) {\n        value3 = stab_data[10];\n        if (value3 != 0) {\n          length = *(long *)(value3 + 8);\n          value6 = *(uint *)(value3 + 0x20);\n          stab_data[10] = length;\n          if ((value6 < *(uint *)(stab_data + 0x10)) &&\n             (*(undefined8 *)(value3 + 0x28) = *(undefined8 *)(stab_data[0x11] + (ulong)value6 * 8),\n             length != 0)) {\n            name = *(char **)(length + 0x10);\n            goto LAB_00111ab7;\n          }\n        }\n        name = (char *)stab_data[9];\n        goto LAB_00111ab7;\n      }\n      goto LAB_00111c29;\n    }\n    if ((*(char *)((long)stab_data + 0x44) != '\\0') && (line_number == 1)) {\n      return 1;\n    }\n    if (*(char *)(stab_data + 0xc) != '\\0') {\n      char2 = debug_start_block(param_1,stab_data[7] + stab_data[6] + address);\n      if (char2 == '\\0') {\n        return 0;\n      }\n      char2 = stab_emit_pending_vars(param_1,stab_data);\n      if (char2 != '\\0') {\n        *(int *)(stab_data + 0xe) = *(int *)(stab_data + 0xe) + 1;\n        return 1;\n      }\n      return 0;\n    }\n    ptr4 = \"N_LBRAC not within function\\n\";\n  }\n  ptr4 = (char *)dcgettext(0,ptr4,5);\n  fprintf(_stderr,ptr4);\n  return 0;\ncode_r0x00111cc7:\n  ptr7 = ptr7 + 2;\n  ptr7 = strchr(ptr7,0x3a);\n  if (ptr7 == (char *)0x0) {\n    ptr4 = (char *)0x0;\nswitchD_00111de5_caseD_44:\n    ptr7 = ptr4;\n    bad_stab(name);\n    return 0;\n  }\n  goto LAB_00111cbc;\nLAB_001122b2:\n  if (dptr == (long **)0x0) {\nLAB_001122f0:\n    if (char2 != 't') {\n      return 1;\n    }\n    ptr3 = (long *)debug_name_type(param_1,ptr6,ptr3);\n    if (ptr3 != (long *)0x0) {\n      if (array[2][0] == (long **)0x0) {\n        return 1;\n      }\n      *array[2][0] = ptr3;\n      return 1;\n    }\n    return 0;\n  }\n  if ((*(char *)dptr[1] == *ptr6) &&\n     (index = strcmp((char *)dptr[1],ptr6), index == 0)) {\n    dptr[3] = ptr3;\n    *ppptr5 = *dptr;\n    goto LAB_001122f0;\n  }\n  ppptr5 = dptr;\n  dptr = (long **)*dptr;\n  goto LAB_001122b2;\nLAB_00112045:\n  if (length < 1) {\nLAB_0011208f:\n    value = 1;\nLAB_001121c4:\n    char2 = debug_record_variable(param_1,ptr6,value3,value,address);\njoined_r0x001123f8:\n    if (char2 != '\\0') {\n      return 1;\n    }\n    return 0;\n  }\n  ptr4 = *(char **)(*ptr3 + 8);\n  if ((char2 != '\\0') && (char2 == *ptr4)) {\n    ptr4 = ptr4 + 1;\n  }\n  if ((*ptr4 == *ptr6) && (index = strcmp(ptr4,ptr6), index == 0)) {\n    address = *(long *)(*ptr3 + 0x10) + *(long *)(*(long *)(*ptr3 + 0x20) + 0x30);\n    goto LAB_0011208f;\n  }\n  length = length + -1;\n  ptr3 = ptr3 + 1;\n  goto LAB_00112045;\n}\n\n",
            "called": [
                "strchr",
                "debug_record_line",
                "debug_record_variable",
                "debug_add_to_current_namespace.constprop.0",
                "bad_stab",
                "savestring",
                "debug_name_type",
                "concat",
                "strlen",
                "dcgettext",
                "debug_make_pointer_type.isra.0",
                "xrealloc",
                "stab_emit_pending_vars",
                "debug_end_block",
                "strtol",
                "strcmp",
                "debug_record_function",
                "free",
                "debug_end_function",
                "fprintf",
                "debug_start_block",
                "xstrdup",
                "stab_record_variable",
                "debug_make_function_type.isra.0",
                "parse_stab_type",
                "debug_set_filename",
                "debug_tag_type",
                "debug_start_source",
                "xmalloc",
                "warn_stab",
                "strtod",
                "debug_record_parameter"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011173a",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "parse_stab_function_0011173a"
        },
        "FUN_00115dc0": {
            "renaming": {
                "FUN_00115dc0": "handle_binary_00115dc0",
                "param_1": "binary_file",
                "param_2": "section_list",
                "param_3": "bfd_handler",
                "cVar1": "skip_result",
                "iVar2": "error_code",
                "uVar3": "reloc_result",
                "lVar4": "section_length",
                "puVar5": "reloc_list",
                "uVar6": "reloc_count",
                "UNRECOVERED_JUMPTABLE": "jump_table",
                "puVar7": "filtered_reloc_list",
                "puVar8": "next_reloc",
                "uVar9": "loop_index",
                "uStack_38": "error_message"
            },
            "code": "\nvoid handle_binary_00115dc0(undefined8 binary_file,undefined8 *section_list,long bfd_handler)\n\n{\n  char skip_result;\n  int error_code;\n  undefined8 reloc_result;\n  long section_length;\n  undefined8 *reloc_list;\n  ulong reloc_count;\n  code *jump_table;\n  undefined8 *filtered_reloc_list;\n  undefined8 *next_reloc;\n  ulong loop_index;\n  undefined8 error_message;\n  \n  skip_result = skip_section(binary_file,section_list,0);\n  if (skip_result != '\\0') {\n    return;\n  }\n  reloc_result = section_list[0xc];\n  if ((((*(byte *)(bfd_handler + 0x48) & 7) != 3) && (strip_symbols != 6)) &&\n     (section_length = find_section_list(*section_list,0,0x100), section_length == 0)) {\n    section_length = bfd_get_reloc_upper_bound(binary_file,section_list);\n    if (section_length < 0) {\n      if ((section_length != -1) || (error_code = bfd_get_error(), error_code != 5)) {\n        status = 1;\n        reloc_result = 0;\nLAB_00108315:\n        bfd_nonfatal_message(0,binary_file,section_list,reloc_result,error_message);\n        return;\n      }\n    }\n    else if (section_length != 0) {\n      reloc_list = (undefined8 *)section_list[0xe];\n      if (reloc_list == (undefined8 *)0x0) {\n        reloc_list = (undefined8 *)bfd_alloc(bfd_handler);\n        if (reloc_list == (undefined8 *)0x0) {\n          bfd_nonfatal(0);\n                    \n          xexit(1);\n        }\n        reloc_count = bfd_canonicalize_reloc(binary_file,section_list,reloc_list,isympp);\n        if ((long)reloc_count < 0) {\n          status = 1;\n          reloc_result = dcgettext(0,\"relocation count is negative\",5);\n          goto LAB_00108315;\n        }\n      }\n      else {\n        reloc_count = (ulong)*(uint *)(section_list + 0xf);\n      }\n      if (strip_symbols == 7) {\n        filtered_reloc_list = reloc_list;\n        for (loop_index = 0; loop_index != reloc_count; loop_index = loop_index + 1) {\n          next_reloc = filtered_reloc_list;\n          if (((*(long **)reloc_list[loop_index] != (long *)0x0) &&\n              (section_length = **(long **)reloc_list[loop_index], section_length != 0)) &&\n             (skip_result = is_specified_symbol(*(undefined8 *)(section_length + 8),keep_specific_htab),\n             skip_result != '\\0')) {\n            next_reloc = filtered_reloc_list + 1;\n            *filtered_reloc_list = reloc_list[loop_index];\n          }\n          filtered_reloc_list = next_reloc;\n        }\n        *filtered_reloc_list = 0;\n        reloc_count = (long)filtered_reloc_list - (long)reloc_list >> 3;\n      }\n      jump_table = *(code **)(*(long *)(bfd_handler + 8) + 0x288);\n      if (reloc_count == 0) {\n        reloc_count = 0;\n        reloc_list = (undefined8 *)0x0;\n      }\n      else {\n        reloc_count = reloc_count & 0xffffffff;\n      }\n      goto LAB_00115e9a;\n    }\n  }\n  reloc_count = 0;\n  reloc_list = (undefined8 *)0x0;\n  jump_table = *(code **)(*(long *)(bfd_handler + 8) + 0x288);\nLAB_00115e9a:\n                    /* WARNING: Could not recover jumptable at 0x00115eae. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jump_table)(bfd_handler,reloc_result,reloc_list,reloc_count);\n  return;\n}\n\n",
            "called": [
                "bfd_get_error",
                "dcgettext",
                "bfd_canonicalize_reloc",
                "xexit",
                "find_section_list",
                "bfd_nonfatal_message",
                "bfd_get_reloc_upper_bound",
                "copy_relocations_in_section.cold",
                "skip_section",
                "bfd_nonfatal",
                "bfd_alloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115dc0",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "handle_binary_00115dc0"
        },
        "FUN_001044c0": {
            "renaming": {},
            "code": "\n\n\nlong ftell(FILE *__stream)\n\n{\n  long lVar1;\n  \n  lVar1 = ftell(__stream);\n  return lVar1;\n}\n\n",
            "called": [
                "ftell"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001044c0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001044c0"
        },
        "FUN_001043a0": {
            "renaming": {},
            "code": "\nvoid bfd_set_error(void)\n\n{\n  bfd_set_error();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043a0",
            "calling": [
                "FUN_001086af",
                "FUN_0010554f",
                "copy_file"
            ],
            "imported": false,
            "current_name": "FUN_001043a0"
        },
        "FUN_001045e0": {
            "renaming": {},
            "code": "\n\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fflush(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001045e0",
            "calling": [
                "bfd_nonfatal.cold",
                "list_matching_formats",
                "report",
                "bfd_nonfatal_message"
            ],
            "imported": false,
            "current_name": "FUN_001045e0"
        },
        "FUN_0010d559": {
            "renaming": {
                "FUN_0010d559": "reverse_and_improve_code_0010d559",
                "param_1": "paramArray",
                "param_2": "byteArrayPtr",
                "param_3": "longArrayPtr",
                "bVar1": "byteVar",
                "pbVar2": "bytePtr",
                "cVar3": "charVar",
                "uVar4": "uintVar",
                "iVar5": "intVar",
                "ppcVar6": "charPtrPtr",
                "sVar7": "sizeVar",
                "lVar8": "longVar",
                "plVar9": "longArrayPtr",
                "pcVar10": "charVarPtr",
                "__s1": "charVarPtr2",
                "__ptr": "voidPtr",
                "pbVar11": "bytePtr2",
                "uVar12": "undefined8Var",
                "__nptr": "bytePtr3",
                "local_64": "localVar",
                "local_40": "charArray"
            },
            "code": "\nundefined8 reverseAndImproveCode_0010d559(undefined8 *paramArray,byte **byteArrayPtr,long *longArrayPtr)\n\n{\n  byte byteVar;\n  byte *bytePtr;\n  char charVar;\n  uint uintVar;\n  int intVar;\n  char **charPtrPtr;\n  size_t sizeVar;\n  long longVar;\n  long *longArrayPtr;\n  char *charVarPtr;\n  char *charVarPtr2;\n  void *voidPtr;\n  byte *bytePtr2;\n  undefined8 undefined8Var;\n  byte *bytePtr3;\n  int localVar;\n  char *charArray [2];\n  \n  bytePtr = *byteArrayPtr;\n  byteVar = bytePtr[1];\n  if ((char)byteVar < ':') {\n    if ((char)byteVar < '1') goto LAB_0010d5d8;\n    localVar = (char)byteVar + -0x30;\n    if (bytePtr[2] == 0x5f) {\n      *byteArrayPtr = bytePtr + 1;\n    }\n    bytePtr2 = *byteArrayPtr + 2;\n  }\n  else {\n    if (((byteVar != 0x5f) || (((&_sch_istable)[(ulong)bytePtr[2] * 2] & 4) == 0)) ||\n       (bytePtr[2] == 0x30)) goto LAB_0010d5d8;\n    bytePtr3 = bytePtr + 2;\n    longVar = strtol((char *)bytePtr3,(char **)0x0,10);\n    localVar = (int)longVar;\n    while (((&_sch_istable)[(ulong)*bytePtr3 * 2] & 4) != 0) {\n      bytePtr3 = bytePtr3 + 1;\n    }\n    bytePtr2 = bytePtr3 + 1;\n    if (*bytePtr3 != 0x5f) goto LAB_0010d5d8;\n  }\n  *byteArrayPtr = bytePtr2;\n  charPtrPtr = (char **)0x0;\n  if (longArrayPtr != (long *)0x0) {\n    charPtrPtr = charArray;\n  }\n  longVar = 0;\n  while( true ) {\n    while( true ) {\n      localVar = localVar + -1;\n      if (localVar == -1) {\n        if (longArrayPtr != (long *)0x0) {\n          *longArrayPtr = longVar;\n        }\n        return 1;\n      }\n      if (**byteArrayPtr == 0x5f) {\n        *byteArrayPtr = *byteArrayPtr + 1;\n      }\n      if (**byteArrayPtr != 0x74) break;\n      charVar = stab_demangle_template(paramArray,byteArrayPtr,charPtrPtr);\n      charVarPtr = charArray[0];\n      if (charVar == '\\0') {\n        return 0;\n      }\n      if (longArrayPtr != (long *)0x0) {\n        sizeVar = strlen(charArray[0]);\n        longVar = stab_find_tagged_type(*paramArray,paramArray[1],charVarPtr,sizeVar & 0xffffffff,9);\n        free(charVarPtr);\n        if (longVar == 0) {\n          return 0;\n        }\n      }\n    }\n    uintVar = stab_demangle_count(byteArrayPtr);\n    sizeVar = strlen((char *)*byteArrayPtr);\n    if (sizeVar < uintVar) break;\n    if (longArrayPtr != (long *)0x0) {\n      if ((longVar != 0) && (longArrayPtr = (long *)debug_get_fields_isra_0(longVar), longArrayPtr != (long *)0x0))\n      {\n        charVarPtr = (char *)savestring(*byteArrayPtr,uintVar);\n        for (; longVar = *longArrayPtr, longVar != 0; longArrayPtr = longArrayPtr + 1) {\n          longVar = *(long *)(longVar + 8);\n          if (longVar == 0) {\n            free(charVarPtr);\n            return 0;\n          }\n          charVarPtr2 = (char *)debug_get_type_name_constprop_0(longVar);\n          if ((charVarPtr2 != (char *)0x0) && (intVar = strcmp(charVarPtr2,charVarPtr), intVar == 0)) break;\n        }\n        free(charVarPtr);\n        if (longVar != 0) goto LAB_0010d7ad;\n      }\n      undefined8Var = 9;\n      if (localVar == 0) {\n        voidPtr = (void *)savestring(*byteArrayPtr,uintVar);\n        longVar = debug_find_named_type(*paramArray,voidPtr);\n        free(voidPtr);\n        if (longVar != 0) goto LAB_0010d7ad;\n        undefined8Var = 0;\n      }\n      longVar = stab_find_tagged_type(*paramArray,paramArray[1],*byteArrayPtr,uintVar,undefined8Var);\n      if (longVar == 0) {\n        return 0;\n      }\n    }\nLAB_0010d7ad:\n    *byteArrayPtr = *byteArrayPtr + uintVar;\n  }\nLAB_0010d5d8:\n  stab_bad_demangle(bytePtr);\n  return 0;\n}\n\n",
            "called": [
                "stab_bad_demangle",
                "strlen",
                "stab_demangle_count",
                "stab_find_tagged_type",
                "debug_get_fields.isra.0",
                "debug_find_named_type",
                "free",
                "stab_demangle_template",
                "savestring",
                "debug_get_type_name.constprop.0",
                "strtol",
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010d559",
            "calling": [
                "parse_stab_type",
                "stab_demangle_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "reverse_and_improve_code_0010d559"
        },
        "FUN_00119e70": {
            "renaming": {
                "FUN_00119e70": "print_formatted_message_00119e70",
                "param_1": "formatString",
                "param_2": "arguments",
                "_stdout": "stdoutStream",
                "_stderr": "stderrStream",
                "program_name": "programName"
            },
            "code": "\n\n\nvoid printFormattedMessage_00119e70(char *formatString,__gnuc_va_list arguments)\n\n{\n  fflush(stdoutStream);\n  fprintf(stderrStream,\"%s: \",programName);\n  vfprintf(stderrStream,formatString,arguments);\n  putc(10,stderrStream);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "vfprintf",
                "putc",
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00119e70",
            "calling": [
                "non_fatal",
                "fatal"
            ],
            "imported": false,
            "current_name": "print_formatted_message_00119e70"
        },
        "FUN_00128290": {
            "renaming": {},
            "code": "\n\n\n\nlong ftell(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ftell@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128290",
            "calling": [
                "ftell"
            ],
            "imported": false,
            "current_name": "FUN_00128290"
        },
        "FUN_00128050": {
            "renaming": {},
            "code": "\n\n\n\nint * __errno_location(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __errno_location@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128050",
            "calling": [
                "__errno_location"
            ],
            "imported": false,
            "current_name": "FUN_00128050"
        },
        "FUN_00108466": {
            "renaming": {
                "FUN_00108466": "free_memory_and_set_status_00108466",
                "param_7": "memoryBlock",
                "status": "programStatus"
            },
            "code": "\nvoid freeMemoryAndSetStatus_00108466(void)\n\n{\n  void *memoryBlock;\n  \n  programStatus = 1;\n  bfd_nonfatal_message(0);\n  free(memoryBlock);\n  return;\n}\n\n",
            "called": [
                "bfd_nonfatal_message",
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108466",
            "calling": [
                "copy_section"
            ],
            "imported": false,
            "current_name": "free_memory_and_set_status_00108466"
        },
        "FUN_00128298": {
            "renaming": {},
            "code": "\n\n\n\nint feof(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* feof@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128298",
            "calling": [
                "feof"
            ],
            "imported": false,
            "current_name": "FUN_00128298"
        },
        "FUN_00128058": {
            "renaming": {},
            "code": "\n\n\n\nint unlink(char *__name)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* unlink@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128058",
            "calling": [
                "unlink"
            ],
            "imported": false,
            "current_name": "FUN_00128058"
        },
        "FUN_00128178": {
            "renaming": {},
            "code": "\n\n\n\nchar * strrchr(char *__s,int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strrchr@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128178",
            "calling": [
                "strrchr"
            ],
            "imported": false,
            "current_name": "FUN_00128178"
        },
        "FUN_00108e76": {
            "renaming": {
                "FUN_00108e76": "parse_and_convert_to_decimal_00108e76",
                "param_1": "byteArray",
                "bVar1": "currentByte",
                "iVar2": "parsedNumber"
            },
            "code": "\nint parseAndConvertToDecimal_00108e76(byte **byteArray)\n\n{\n  byte currentByte;\n  int parsedNumber;\n  \n  parsedNumber = 0;\n  while( true ) {\n    currentByte = **byteArray;\n    if (((&_sch_istable)[(ulong)currentByte * 2] & 4) == 0) break;\n    *byteArray = *byteArray + 1;\n    parsedNumber = parsedNumber * 10 + -0x30 + (int)(char)currentByte;\n  }\n  return parsedNumber;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108e76",
            "calling": [
                "parse_stab_type",
                "stab_demangle_qualified",
                "stab_demangle_type.lto_priv.0",
                "stab_demangle_template"
            ],
            "imported": false,
            "current_name": "parse_and_convert_to_decimal_00108e76"
        },
        "FUN_0010bb52": {
            "renaming": {
                "FUN_0010bb52": "create_hash_function_0010bb52",
                "param_1": "inputValue",
                "param_2": "param2",
                "param_3": "param3",
                "lVar1": "hashPtr"
            },
            "code": "\nlong createHashFunction_0010bb52(long inputValue,undefined8 param2,undefined8 param3)\n\n{\n  long hashPtr;\n  \n  if (((inputValue != 0) || (inputValue = bfd_hash_allocate(param2,0x30), inputValue != 0)) &&\n     (hashPtr = bfd_hash_newfunc(inputValue,param2,param3), hashPtr != 0)) {\n    *(undefined8 *)(hashPtr + 0x20) = 0xffffffffffffffff;\n    *(undefined8 *)(hashPtr + 0x18) = 0;\n    *(undefined4 *)(hashPtr + 0x28) = 0;\n    return hashPtr;\n  }\n  return 0;\n}\n\n",
            "called": [
                "bfd_hash_allocate",
                "bfd_hash_newfunc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bb52",
            "calling": [
                "write_stabs_in_sections_debugging_info.constprop.0"
            ],
            "imported": false,
            "current_name": "create_hash_function_0010bb52"
        },
        "FUN_001043b0": {
            "renaming": {},
            "code": "\nvoid xmalloc_set_program_name(void)\n\n{\n  xmalloc_set_program_name();\n  return;\n}\n\n",
            "called": [
                "xmalloc_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043b0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001043b0"
        },
        "FUN_0011283f": {
            "renaming": {
                "FUN_0011283f": "check_and_get_directory_path_0011283f",
                "param_1": "path_to_check",
                "param_2": "directory_path",
                "sStack_a8": "file_info"
            },
            "code": "\nchar * check_and_get_directory_path_0011283f(char *path_to_check,char *directory_path)\n\n{\n  int iVar1;\n  stat file_info;\n  \n  if ((directory_path == (char *)0x0) && (path_to_check != (char *)0x0)) {\n    iVar1 = access(path_to_check,7);\n    if (iVar1 == 0) {\n      iVar1 = stat(path_to_check,&file_info);\n      if ((iVar1 == 0) && ((file_info.st_mode & 0xf000) == 0x4000)) {\n        directory_path = path_to_check;\n      }\n    }\n  }\n  return directory_path;\n}\n\n",
            "called": [
                "stat",
                "access"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011283f",
            "calling": [
                "display_info.isra.0"
            ],
            "imported": false,
            "current_name": "check_and_get_directory_path_0011283f"
        },
        "FUN_001045f0": {
            "renaming": {},
            "code": "\nvoid bfd_set_section_size(void)\n\n{\n  bfd_set_section_size();\n  return;\n}\n\n",
            "called": [
                "bfd_set_section_size"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001045f0",
            "calling": [
                "setup_section",
                "FUN_0010554f",
                "FUN_00107880",
                "copy_section"
            ],
            "imported": false,
            "current_name": "FUN_001045f0"
        },
        "FUN_001044d0": {
            "renaming": {},
            "code": "\n\n\nint feof(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = feof(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "feof"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001044d0",
            "calling": [
                "FUN_00114dc7"
            ],
            "imported": false,
            "current_name": "FUN_001044d0"
        },
        "FUN_001284a8": {
            "renaming": {},
            "code": "\n\n\n\nchar * strerror(int __errnum)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strerror@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001284a8",
            "calling": [
                "strerror"
            ],
            "imported": false,
            "current_name": "FUN_001284a8"
        },
        "FUN_00108237": {
            "renaming": {
                "FUN_00108237": "close_and_reset_error_00108237",
                "unaff_R12D": "fileDescriptor",
                "piVar2": "errorPointer",
                "iVar1": "originalErrorValue"
            },
            "code": "\nundefined8 closeAndResetError_00108237(void)\n\n{\n  int originalErrorValue;\n  int *errorPointer;\n  int fileDescriptor;\n  \n  errorPointer = __errno_location();\n  originalErrorValue = *errorPointer;\n  close(fileDescriptor);\n  *errorPointer = originalErrorValue;\n  return 0xffffffff;\n}\n\n",
            "called": [
                "close",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108237",
            "calling": [
                "simple_copy"
            ],
            "imported": false,
            "current_name": "close_and_reset_error_00108237"
        },
        "FUN_00128088": {
            "renaming": {},
            "code": "\n\n\n\nchar * strcpy(char *__dest,char *__src)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcpy@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128088",
            "calling": [
                "strcpy"
            ],
            "imported": false,
            "current_name": "FUN_00128088"
        },
        "FUN_0010bc80": {
            "renaming": {
                "FUN_0010bc80": "debug_record_function_0010bc80",
                "param_1": "file_info_ptr",
                "param_2": "filename",
                "param_3": "record_size",
                "param_4": "flags",
                "param_5": "unknown_param_1",
                "param_6": "unknown_param_2",
                "uVar1": "error_message",
                "plVar2": "record_ptr",
                "puVar3": "ptr",
                "lVar4": "loop_counter",
                "puVar5": "ptr2",
                "pcVar6": "empty_string",
                "bVar7": "byte_value",
                "auVar8": "return_value"
            },
            "code": "\n\n\nundefined  [16]\ndebug_record_function_0010bc80(long file_info_ptr,char *filename,long record_size,uint flags,undefined8 unknown_param_1,\n            undefined8 unknown_param_2)\n\n{\n  undefined8 error_message;\n  long *record_ptr;\n  undefined4 *ptr;\n  long loop_counter;\n  undefined4 *ptr2;\n  char *empty_string;\n  byte byte_value;\n  undefined return_value [16];\n  \n  byte_value = 0;\n  empty_string = \"\";\n  if (filename != (char *)0x0) {\n    empty_string = filename;\n  }\n  if (record_size != 0) {\n    if (*(long *)(file_info_ptr + 8) == 0) {\n      error_message = dcgettext(0,\"debug_record_function_0010bc80: no debug_set_filename call\",5);\n      fprintf(_stderr,\"%s\\n\",error_message);\n    }\n    else {\n      record_ptr = (long *)xmalloc(0x18);\n      *record_ptr = record_size;\n      *(undefined (*) [16])(record_ptr + 1) = ZEXT816(0);\n      ptr = (undefined4 *)xmalloc(0x30);\n      *(long **)(file_info_ptr + 0x18) = record_ptr;\n      record_ptr[2] = (long)ptr;\n      ptr2 = ptr;\n      for (loop_counter = 0xc; loop_counter != 0; loop_counter = loop_counter + -1) {\n        *ptr2 = 0;\n        ptr2 = ptr2 + (ulong)byte_value * -2 + 1;\n      }\n      *(undefined4 **)(file_info_ptr + 0x20) = ptr;\n      loop_counter = *(long *)(file_info_ptr + 0x10);\n      *(undefined8 *)(ptr + 6) = unknown_param_1;\n      *(undefined8 *)(ptr + 8) = 0xffffffffffffffff;\n      loop_counter = debug_add_to_namespace_constprop_0(loop_counter + 0x10,empty_string,3,(flags & 0xff) + 1);\n      if (loop_counter != 0) {\n        *(long **)(loop_counter + 0x20) = record_ptr;\n        error_message = CONCAT71((int7)((ulong)loop_counter >> 8),1);\n        goto LAB_0010bd56;\n      }\n    }\n  }\n  error_message = 0;\nLAB_0010bd56:\n  return_value._8_8_ = unknown_param_2;\n  return_value._0_8_ = error_message;\n  return return_value;\n}\n\n",
            "called": [
                "fprintf",
                "debug_add_to_namespace.constprop.0",
                "dcgettext",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bc80",
            "calling": [
                "parse_stab",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "debug_record_function_0010bc80"
        },
        "FUN_001152b6": {
            "renaming": {
                "FUN_001152b6": "FUNC_001152b6"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong FUNC_001152b6(void)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  undefined *puVar3;\n  long *plVar4;\n  code *pcVar5;\n  long *plVar6;\n  ulong uVar7;\n  ulong uVar8;\n  char *__s;\n  char cVar9;\n  char cVar10;\n  uint uVar11;\n  int iVar12;\n  uint uVar13;\n  undefined4 uVar14;\n  int iVar15;\n  long *plVar16;\n  long lVar17;\n  undefined8 uVar18;\n  undefined8 uVar19;\n  size_t sVar20;\n  size_t sVar21;\n  char *pcVar22;\n  void *__ptr;\n  void *__ptr_00;\n  ulong uVar23;\n  long lVar24;\n  ulong uVar25;\n  int *piVar26;\n  long lVar27;\n  ulong uVar28;\n  FILE *__s_00;\n  long **pplVar29;\n  undefined4 unaff_EBX;\n  long **__ptr_01;\n  char *pcVar30;\n  undefined8 *puVar31;\n  ulong uVar32;\n  int iVar33;\n  long **pplVar34;\n  long unaff_RBP;\n  char *pcVar35;\n  undefined4 *puVar36;\n  undefined8 *puVar37;\n  int unaff_R12D;\n  char **ppcVar38;\n  void *pvVar39;\n  undefined8 *unaff_R14;\n  undefined **ppuVar40;\n  bool bVar41;\n  byte bVar42;\n  long param_7;\n  ulong uStack0000000000000010;\n  char in_stack_00000018;\n  undefined4 *puStack0000000000000020;\n  char *pcStack0000000000000038;\n  uint uStack0000000000000048;\n  int iStack000000000000006c;\n  long lStack0000000000000078;\n  long lStack0000000000000088;\n  char *pcStack0000000000000090;\n  long lStack00000000000000a0;\n  long *in_stack_000000c0;\n  ulong in_stack_000000c8;\n  long in_stack_000000d0;\n  long in_stack_000000d8;\n  void *in_stack_000000e0;\n  long in_stack_000000f0;\n  undefined8 in_stack_000000f8;\n  byte bStack0000000000000100;\n  byte bStack0000000000000101;\n  undefined8 in_stack_00000110;\n  ushort in_stack_00000118;\n  char *in_stack_00000140;\n  char cStack0000000000000148;\n  char *in_stack_00000150;\n  undefined uStack0000000000000158;\n  short sStack000000000000015a;\n  \n  bVar42 = 0;\n  if (unaff_R12D == 0) {\n    unaff_R12D = *(int *)(unaff_RBP + 0xc);\n    unaff_EBX = *(undefined4 *)(unaff_RBP + 0x10);\n    if (((unaff_R12D == 0) && (*(int *)(unaff_R14[1] + 8) != 5)) &&\n       (*(int *)(*(long *)(param_7 + 8) + 8) == 5)) {\n      uVar28 = FUNC_00107880();\n      return uVar28;\n    }\n  }\n  else {\n    uVar19 = bfd_get_archive_filename();\n    uVar18 = dcgettext(0,\"Input file `%s\\' ignores binary architecture parameter.\",5);\n    non_fatal(uVar18,uVar19);\n  }\n  cVar10 = (**(code **)(*(long *)(param_7 + 8) + 0x2a0))(param_7,unaff_R12D,unaff_EBX);\n  if (cVar10 == '\\0') {\n    if ((*(byte *)(unaff_R14 + 9) & 0x40) != 0) {\n      iVar12 = bfd_get_arch();\n      if (iVar12 == 0) {\n        uVar19 = bfd_get_archive_filename();\n        uVar18 = dcgettext(0,\"Unable to recognise the format of the input file `%s\\'\",5);\n        non_fatal(uVar18,uVar19);\n        return 0;\n      }\n      uVar19 = bfd_get_mach();\n      uVar14 = bfd_get_arch();\n      uVar19 = bfd_printable_arch_mach(uVar14,uVar19);\n      uVar18 = dcgettext(0,\"Output file cannot represent architecture `%s\\'\",5);\n      non_fatal(uVar18,uVar19);\n      return 0;\n    }\n    iVar12 = bfd_get_arch();\n    iVar33 = bfd_get_arch(param_7);\n    if (iVar12 != iVar33) {\n      uVar28 = check_file_format_00105828();\n      return uVar28;\n    }\n  }\n  cVar10 = bfd_set_format(param_7,*(byte *)(unaff_R14 + 9) & 7);\n  if (cVar10 == '\\0') {\nLAB_00107a82:\n    bfd_nonfatal_message(0);\n    return 0;\n  }\n  if ((*(int *)(*(undefined8 **)(param_7 + 8) + 1) == 2) &&\n     (cVar10 = startswith_lto_priv_0_lto_priv_0(**(undefined8 **)(param_7 + 8),&DAT_0011b503),\n     cVar10 != '\\0')) {\n    lVar27 = *(long *)(param_7 + 0x110);\n    if ((*(int *)((undefined8 *)unaff_R14[1] + 1) == 2) &&\n       (cVar10 = startswith_lto_priv_0_lto_priv_0(*(undefined8 *)unaff_R14[1],&DAT_0011b503),\n       cVar10 != '\\0')) {\n      lVar17 = unaff_R14[0x22];\n      bVar41 = preserve_dates == '\\0';\n      puVar31 = (undefined8 *)(lVar17 + 200);\n      puVar37 = (undefined8 *)(lVar27 + 200);\n      for (lVar24 = 0x32; lVar24 != 0; lVar24 = lVar24 + -1) {\n        *puVar37 = *puVar31;\n        puVar31 = puVar31 + (ulong)bVar42 * -2 + 1;\n        puVar37 = puVar37 + (ulong)bVar42 * -2 + 1;\n      }\n      if (bVar41) {\n        *(undefined4 *)(lVar27 + 0x2a4) = 0xffffffff;\n      }\n      else {\n        *(int *)(lVar27 + 0x2a4) = (int)*(undefined8 *)(lVar17 + 0xa8);\n      }\n    }\n    uVar28 = pe_file_alignment;\n    if (pe_file_alignment == 0xffffffffffffffff) {\n      pe_file_alignment = 0x200;\n      uVar28 = 0x200;\n    }\n    else {\n      *(int *)(lVar27 + 0x10c) = (int)pe_file_alignment;\n    }\n    if (pe_heap_commit != -1) {\n      *(long *)(lVar27 + 0x148) = pe_heap_commit;\n    }\n    if (pe_heap_reserve != -1) {\n      *(long *)(lVar27 + 0x148) = pe_heap_reserve;\n    }\n    if (pe_image_base != -1) {\n      *(long *)(lVar27 + 0x100) = pe_image_base;\n    }\n    uVar23 = pe_section_alignment;\n    if (pe_section_alignment == 0xffffffffffffffff) {\n      pe_section_alignment = 0x1000;\n      uVar23 = 0x1000;\n    }\n    else {\n      *(int *)(lVar27 + 0x108) = (int)pe_section_alignment;\n    }\n    if (pe_stack_commit != -1) {\n      *(long *)(lVar27 + 0x138) = pe_stack_commit;\n    }\n    if (pe_stack_reserve != -1) {\n      *(long *)(lVar27 + 0x138) = pe_stack_reserve;\n    }\n    if (pe_subsystem != -1) {\n      *(short *)(lVar27 + 300) = pe_subsystem;\n    }\n    if (pe_major_subsystem_version != -1) {\n      *(short *)(lVar27 + 0x118) = pe_major_subsystem_version;\n    }\n    if (pe_minor_subsystem_version != -1) {\n      *(short *)(lVar27 + 0x11a) = pe_minor_subsystem_version;\n    }\n    if (uVar23 < uVar28) {\n      uVar19 = dcgettext(0,\"warning: file alignment (0x%lx) > section alignment (0x%lx)\",5);\n      non_fatal(uVar19,uVar28,uVar23);\n    }\n  }\n  plVar6 = isympp;\n  free(isympp);\n  if (plVar6 == osympp) {\n    isympp = (long *)0x0;\n    osympp = (long *)0x0;\n    lVar27 = (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  else {\n    free(osympp);\n    isympp = (long *)0x0;\n    osympp = (long *)0x0;\n    lVar27 = (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  if (lVar27 < 0) goto LAB_00107a82;\n  osympp = (long *)xmalloc();\n  isympp = osympp;\n  uStack0000000000000010 = (**(code **)(unaff_R14[1] + 0x200))();\n  if ((long)uStack0000000000000010 < 0) goto LAB_00107a82;\n  if (uStack0000000000000010 == 0) {\n    free(isympp);\n    isympp = (long *)0x0;\n    osympp = (long *)0x0;\n  }\n  bfd_map_over_sections();\n  puVar31 = add_sections;\n  if ((extract_symbol == '\\0') &&\n     (cVar10 = (**(code **)(*(long *)(param_7 + 8) + 0x168))(), puVar31 = add_sections,\n     cVar10 == '\\0')) {\n    status = 1;\n    dcgettext(0,\"error in private header data\",5);\n    bfd_nonfatal_message(0);\n    puVar31 = add_sections;\n  }\n  for (; puVar37 = update_sections, puVar31 != (undefined8 *)0x0; puVar31 = (undefined8 *)*puVar31)\n  {\n    uVar11 = 0x128;\n    lVar27 = find_section_list(puVar31[1],0,0x80);\n    if (lVar27 != 0) {\n      uVar11 = check_new_section_flags(*(uint *)(lVar27 + 0x28) | 0x100,param_7,puVar31[1]);\n    }\n    lVar27 = bfd_get_section_by_name(param_7,puVar31[1]);\n    if (lVar27 != 0) {\n      uVar19 = puVar31[1];\n      uVar18 = dcgettext(0,\"can\\'t add section \\'%s\\'\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar18,uVar19);\n      return 0;\n    }\n    lVar27 = bfd_make_section_with_flags(param_7,puVar31[1],uVar11 | 0x100000);\n    puVar31[5] = lVar27;\n    if (lVar27 == 0) {\n      uVar19 = puVar31[1];\n      uVar18 = dcgettext(0,\"can\\'t create section `%s\\'\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar18,uVar19);\n      return 0;\n    }\n    cVar10 = bfd_set_section_size();\n    if (cVar10 == '\\0') {\n      bfd_nonfatal_message(0,param_7,puVar31[5],0);\n      return 0;\n    }\n    lVar27 = find_section_list(puVar31[1],0,0x18);\n    if (lVar27 != 0) {\n      uVar19 = *(undefined8 *)(lVar27 + 0x18);\n      lVar27 = puVar31[5];\n      *(byte *)(lVar27 + 0x28) = *(byte *)(lVar27 + 0x28) | 1;\n      *(undefined8 *)(lVar27 + 0x30) = uVar19;\n      *(undefined8 *)(lVar27 + 0x38) = uVar19;\n    }\n    lVar27 = find_section_list(puVar31[1],0,0x60);\n    if (lVar27 != 0) {\n      lVar17 = puVar31[5];\n      *(undefined8 *)(lVar17 + 0x38) = *(undefined8 *)(lVar27 + 0x20);\n      if (0x3e < *(uint *)(lVar17 + 0x7c)) {\n        bfd_nonfatal_message(0,param_7,lVar17,0);\n        return 0;\n      }\n    }\n  }\n  for (; puVar37 != (undefined8 *)0x0; puVar37 = (undefined8 *)*puVar37) {\n    lVar27 = bfd_get_section_by_name();\n    puVar37[5] = lVar27;\n    if (lVar27 == 0) {\n      uVar19 = puVar37[1];\n      uVar18 = dcgettext(0,\"error: %s not found, can\\'t be updated\",5);\n      non_fatal(uVar18,uVar19);\n      return 0;\n    }\n    uVar19 = *(undefined8 *)(lVar27 + 0x60);\n    cVar10 = bfd_set_section_size(uVar19);\n    if (cVar10 == '\\0') {\n      bfd_nonfatal_message(0,param_7,uVar19,0);\n      return 0;\n    }\n  }\n  puVar31 = dump_sections;\n  if (merge_notes == '\\0') {\n    __ptr_01 = (long **)0x0;\n  }\n  else {\n    pplVar34 = (long **)unaff_R14[0x12];\n    __ptr_01 = pplVar34;\n    if (pplVar34 != (long **)0x0) {\n      __ptr_01 = (long **)0x0;\nLAB_001151ab:\n      if (merge_notes != '\\0') goto LAB_00115187;\n      for (plVar6 = pplVar34[1]; puVar31 = dump_sections, plVar6 != (long *)0x0;\n          plVar6 = (long *)plVar6[1]) {\n      }\n    }\n  }\njoined_r0x001151c7:\n  for (; puVar31 != (undefined8 *)0x0; puVar31 = (undefined8 *)*puVar31) {\n    lVar27 = bfd_get_section_by_name();\n    if (lVar27 == 0) {\n      dcgettext(0,\"can\\'t dump section \\'%s\\' - it does not exist\",5);\n      bfd_nonfatal_message(0);\n    }\n    else if ((*(byte *)(lVar27 + 0x25) & 1) == 0) {\n      dcgettext(0,\"can\\'t dump section - it has no contents\",5);\n      bfd_nonfatal_message(0);\n    }\n    else {\n      sVar20 = *(size_t *)(lVar27 + 0x40);\n      __s_00 = fopen((char *)puVar31[2],\"w\");\n      if (__s_00 == (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        bfd_nonfatal_message(puVar31[2],0,0);\n      }\n      else {\n        cVar10 = bfd_malloc_and_get_section();\n        if (cVar10 == '\\0') {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          bfd_nonfatal_message(0);\n        }\n        else if ((sVar20 != 0) &&\n                (sVar21 = fwrite(in_stack_00000140,1,sVar20,__s_00), sVar21 != sVar20)) {\n          piVar26 = __errno_location();\n          pcVar35 = strerror(*piVar26);\n          uVar19 = puVar31[2];\n          uVar18 = dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          non_fatal(uVar18,uVar19,pcVar35);\n          free(in_stack_00000140);\n          fclose(__s_00);\n          return 0;\n        }\n        fclose(__s_00);\n        free(in_stack_00000140);\n      }\n    }\n  }\n  if (gnu_debuglink_filename == 0) {\nLAB_0010790a:\n    lStack0000000000000078 = 0;\n  }\n  else {\n    lVar27 = bfd_get_section_by_name(param_7,\".gnu_debuglink\");\n    if (lVar27 != 0) {\n      uVar19 = dcgettext(0,\"%s: debuglink section already exists\",5);\n      non_fatal(uVar19);\n      gnu_debuglink_filename = 0;\n      goto LAB_0010790a;\n    }\n    lStack0000000000000078 = bfd_create_gnu_debuglink_section(param_7);\n    lVar27 = gnu_debuglink_filename;\n    if (lStack0000000000000078 == 0) {\n      uVar19 = dcgettext(0,\"cannot create debug link section `%s\\'\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar19,lVar27);\n      return 0;\n    }\n    if (*(int *)(*(long *)(param_7 + 8) + 8) == 2) {\n      uVar23 = 0;\n      for (uVar28 = *(ulong *)(param_7 + 0x90); uVar28 != 0; uVar28 = *(ulong *)(uVar28 + 8)) {\n        uVar25 = *(ulong *)(uVar28 + 0x30);\n        uVar32 = uVar23;\n        uVar7 = uVar28;\n        uVar8 = uVar23;\n        if (uVar25 != 0) {\n          while ((uVar32 = uVar7, uVar8 != 0 &&\n                 (uVar32 = uVar28, uVar25 <= *(ulong *)(uVar23 + 0x30)))) {\n            uVar28 = *(ulong *)(uVar28 + 8);\n            if (uVar28 == 0) goto LAB_00107db8;\n            uVar25 = *(ulong *)(uVar28 + 0x30);\n            uVar7 = uVar23;\n            uVar8 = uVar25;\n          }\n        }\n        uVar23 = uVar32;\n      }\nLAB_00107db8:\n      if (uVar23 == 0) {\n        uVar28 = 0x1000;\n      }\n      else {\n        uVar23 = *(long *)(uVar23 + 0x40) + *(long *)(uVar23 + 0x30);\n        uVar28 = 0xffffffffffffffff;\n        if (uVar23 < 0xfffffffffffff001) {\n          uVar28 = uVar23 + 0xfff & 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(lStack0000000000000078 + 0x28) = *(byte *)(lStack0000000000000078 + 0x28) | 1;\n      *(ulong *)(lStack0000000000000078 + 0x30) = uVar28;\n      *(ulong *)(lStack0000000000000078 + 0x38) = uVar28;\n    }\n  }\n  plVar6 = isympp;\n  iStack000000000000006c = *(int *)(param_7 + 0xa0);\n  if (iStack000000000000006c != 0) {\n    uVar28 = improve_and_reverse_0010554f();\n    return uVar28;\n  }\n  if (convert_debugging == '\\0') {\nLAB_00105588:\n    puStack0000000000000020 = (undefined4 *)0x0;\n  }\n  else {\n    ppuVar40 = &names_0;\n    puStack0000000000000020 = (undefined4 *)xmalloc(0x60);\n    puVar36 = puStack0000000000000020;\n    for (lVar27 = 0x18; lVar27 != 0; lVar27 = lVar27 + -1) {\n      *puVar36 = 0;\n      puVar36 = puVar36 + (ulong)bVar42 * -2 + 1;\n    }\n    pcStack0000000000000038 = (char *)0x0;\n    do {\n      puVar3 = *ppuVar40;\n      lVar27 = bfd_get_section_by_name();\n      lVar17 = bfd_get_section_by_name();\n      if ((lVar27 != 0) && (lVar17 != 0)) {\n        lVar27 = *(long *)(lVar27 + 0x40);\n        __ptr = (void *)xmalloc(lVar27);\n        cVar10 = bfd_get_section_contents();\n        if (cVar10 == '\\0') {\n          uVar14 = bfd_get_error();\n          bfd_errmsg(uVar14);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n          free(pcStack0000000000000038);\n          free(__ptr);\n        }\n        else {\n          uVar28 = *(ulong *)(lVar17 + 0x40);\n          __ptr_00 = (void *)xmalloc(uVar28 + 1);\n          in_stack_00000018 = bfd_get_section_contents();\n          if (in_stack_00000018 == '\\0') {\n            uVar14 = bfd_get_error();\n            bfd_errmsg(uVar14);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n            free(pcStack0000000000000038);\n          }\n          else {\n            *(undefined *)((long)__ptr_00 + uVar28) = 0;\n            if ((pcStack0000000000000038 != (char *)0x0) ||\n               (pcStack0000000000000038 = (char *)start_stab_constprop_0(),\n               pcStack0000000000000038 != (char *)0x0)) {\n              lStack00000000000000a0 = 0;\n              lStack0000000000000088 = 0;\n              for (pvVar39 = __ptr; pvVar39 <= (void *)((long)__ptr + lVar27 + -0xc);\n                  pvVar39 = (void *)((long)pvVar39 + 0xc)) {\n                uVar23 = (**(code **)(unaff_R14[1] + 0x40))(pvVar39);\n                bVar2 = *(byte *)((long)pvVar39 + 4);\n                uVar14 = (**(code **)(unaff_R14[1] + 0x58))((long)pvVar39 + 6);\n                lVar17 = (**(code **)(unaff_R14[1] + 0x40))((long)pvVar39 + 8);\n                if (bVar2 == 0) {\n                  lStack0000000000000088 = lStack00000000000000a0;\n                  lStack00000000000000a0 = lStack00000000000000a0 + lVar17;\n                }\n                else {\n                  uVar25 = (uVar23 & 0xffffffff) + lStack0000000000000088;\n                  if (uVar25 < uVar28) {\n                    pcVar35 = (char *)((long)__ptr_00 + uVar25);\n                    pcStack0000000000000090 = (char *)0x0;\n                    while( true ) {\n                      sVar20 = strlen(pcVar35);\n                      if (((sVar20 == 0) || (pcVar30 = pcVar35 + (sVar20 - 1), *pcVar30 != '\\\\')) ||\n                         ((ulong)((long)__ptr + lVar27) < (long)pvVar39 + 0x10U)) goto LAB_001077fb;\n                      *pcVar30 = '\\0';\n                      pvVar39 = (void *)((long)pvVar39 + 0xc);\n                      iVar12 = (**(code **)(unaff_R14[1] + 0x40))(pvVar39);\n                      uVar23 = (ulong)(uint)(iVar12 + (int)lStack0000000000000088);\n                      if (uVar28 <= uVar23) break;\n                      pcVar35 = (char *)concat(pcVar35,(long)__ptr_00 + uVar23,0);\n                      *pcVar30 = '\\\\';\n                      free(pcStack0000000000000090);\n                      pcStack0000000000000090 = pcVar35;\n                    }\n                    uVar19 = *unaff_R14;\n                    pcVar30 = (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar30,uVar19,puVar3,((long)pvVar39 - (long)__ptr) / 0xc);\nLAB_001077fb:\n                    save_stab((ulong)bVar2,uVar14,lVar17,pcVar35);\n                    cVar10 = parse_stab(puStack0000000000000020,pcStack0000000000000038,bVar2);\n                    if (cVar10 == '\\0') {\n                      stab_context();\n                      free_saved_stabs();\n                      free(pcStack0000000000000090);\n                      free(pcStack0000000000000038);\n                      free(__ptr);\n                      free(__ptr_00);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar19 = *unaff_R14;\n                    pcVar35 = (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar35,uVar19,puVar3,((long)pvVar39 - (long)__ptr) / 0xc,\n                            uVar23 & 0xffffffff,(ulong)bVar2,((long)pvVar39 - (long)__ptr) % 0xc);\n                  }\n                }\n              }\n              free_saved_stabs();\n              free(__ptr);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_00);\n          free(__ptr);\n        }\n        goto LAB_00105981;\n      }\nLAB_001058eb:\n      ppuVar40 = ppuVar40 + 2;\n    } while (ppuVar40 != (undefined **)&DAT_00125c90);\n    if ((pcStack0000000000000038 != (char *)0x0) && (cVar10 = finish_stab(), cVar10 == '\\0')) {\nLAB_00105981:\n      free(puStack0000000000000020);\n      goto LAB_00105588;\n    }\n    if (*(int *)(unaff_R14[1] + 8) == 1) {\n      lVar27 = 0;\n      for (plVar16 = plVar6; plVar16 < plVar6 + uStack0000000000000010; plVar16 = plVar16 + 1) {\n        (**(code **)(unaff_R14[1] + 0x218))();\n        if (cStack0000000000000148 == '-') {\n          if (((lVar27 == 0) && (lVar27 = start_stab_constprop_0(), lVar27 == 0)) ||\n             ((in_stack_00000150 == (char *)0x0 || (*in_stack_00000150 == '\\0'))))\n          goto LAB_00105981;\n          pcVar35 = (char *)0x0;\n          pcVar30 = in_stack_00000150;\n          while (((*pcVar30 != '\\0' && (sVar20 = strlen(pcVar30), pcVar30[sVar20 - 1] == '\\\\')) &&\n                 (plVar16 + 1 < plVar6 + uStack0000000000000010))) {\n            pcVar22 = (char *)xstrdup(pcVar30);\n            sVar20 = strlen(pcVar22);\n            pcVar22[sVar20 - 1] = '\\0';\n            pcVar30 = (char *)concat(pcVar22,*(undefined8 *)(plVar16[1] + 8),0);\n            free(pcVar22);\n            free(pcVar35);\n            plVar16 = plVar16 + 1;\n            pcVar35 = pcVar30;\n          }\n          save_stab(uStack0000000000000158,(int)sStack000000000000015a,in_stack_00000140,pcVar30);\n          in_stack_00000018 = parse_stab(puStack0000000000000020,lVar27,uStack0000000000000158);\n          if (in_stack_00000018 == '\\0') {\n            stab_context();\n            free_saved_stabs();\n            goto LAB_00105981;\n          }\n        }\n      }\n      free_saved_stabs();\n      if ((lVar27 != 0) && (cVar10 = finish_stab(), cVar10 == '\\0')) goto LAB_00105981;\n    }\n    if (in_stack_00000018 == '\\0') {\n      if ((*(int *)(unaff_R14[1] + 8) == 2) && (uStack0000000000000010 != 0)) {\n        in_stack_00000140 = (char *)0x0;\n        in_stack_000000c0 = plVar6;\n        in_stack_000000d0 = 0;\n        in_stack_000000d8 = 0;\n        puVar31 = (undefined8 *)&stack0x00000148;\n        for (lVar27 = 0x22; lVar27 != 0; lVar27 = lVar27 + -1) {\n          *(undefined4 *)puVar31 = 0;\n          puVar31 = (undefined8 *)((long)puVar31 + (ulong)bVar42 * -8 + 4);\n        }\n        cVar10 = '\\0';\n        _uStack0000000000000048 = (int *)0x0;\n        pcStack0000000000000038 = (char *)0x0;\n        pcStack0000000000000090 = (char *)0xffffffffffffffff;\n        in_stack_000000c8 = uStack0000000000000010;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((long)uStack0000000000000010 <= in_stack_000000d0) goto LAB_00105590;\n            lVar27 = plVar6[in_stack_000000d0];\n            cVar9 = bfd_coff_get_syment();\n            lVar17 = in_stack_000000d8;\n            if (cVar9 == '\\0') {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar35 = \"bfd_coff_get_syment failed: %s\";\n              goto LAB_00105968;\n            }\n            pcVar35 = *(char **)(lVar27 + 8);\n            in_stack_000000d0 = in_stack_000000d0 + 1;\n            in_stack_000000d8 = (ulong)bStack0000000000000101 + 1 + in_stack_000000d8;\n            if ((bStack0000000000000101 != 0) && (cVar9 = bfd_coff_get_auxent(), cVar9 == '\\0')) {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar35 = \"bfd_coff_get_auxent failed: %s\";\n              goto LAB_00105968;\n            }\n            if (pcStack0000000000000090 != (char *)lVar17) break;\n            if (bStack0000000000000100 != 0x67) {\n              cVar9 = debug_set_filename(puStack0000000000000020);\n              if (cVar9 != '\\0') break;\n              goto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            pcStack0000000000000090 = (char *)in_stack_000000f0;\n            cVar9 = debug_set_filename(puStack0000000000000020);\n            if (cVar9 == '\\0') goto LAB_00105981;\n          }\n          if ((char)bStack0000000000000100 < '\\0') {\n            if (bStack0000000000000100 == 0xff) goto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            lVar24 = parse_coff_type_lto_priv_0();\n            if (lVar24 == 0) break;\n            cVar9 = parse_coff_symbol_constprop_0_isra_0(&stack0x00000140,lVar27,lVar17);\n          }\n          else {\n            if (bStack0000000000000100 < 100) {\n              switch(bStack0000000000000100) {\n              case 3:\n                if (in_stack_000000f8._6_2_ == 0) goto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulong)((uint)in_stack_000000f8._6_2_ & *(uint *)(unaff_R14[0x22] + 0x40)) !=\n                    2L << ((byte)*(undefined4 *)(unaff_R14[0x22] + 0x3c) & 0x3f)) goto LAB_0010700a;\n                _uStack0000000000000048 = (int *)(**(code **)(unaff_R14[1] + 0x238))();\n                pcStack0000000000000038 = pcVar35;\n                goto switchD_00106e1a_caseD_68;\n              default:\n                goto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                goto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(bStack0000000000000100) {\n            case 100:\n              iVar12 = strcmp(pcVar35,\".bb\");\n              if (iVar12 == 0) {\n                cVar9 = debug_start_block(puStack0000000000000020);\n              }\n              else {\n                iVar12 = strcmp(pcVar35,\".eb\");\n                if (iVar12 != 0) goto switchD_00106e1a_caseD_68;\n                cVar9 = debug_end_block(puStack0000000000000020);\n              }\n              break;\n            case 0x65:\n              iVar12 = strcmp(pcVar35,\".bf\");\n              if (iVar12 == 0) {\n                if (pcStack0000000000000038 != (char *)0x0) {\n                  lVar17 = parse_coff_type_lto_priv_0();\n                  if ((lVar17 == 0) ||\n                     (cVar10 = debug_record_function(puStack0000000000000020), cVar10 == '\\0'))\n                  goto LAB_00105981;\n                  if (_uStack0000000000000048 != (int *)0x0) {\n                    iVar12 = 0;\n                    if (bStack0000000000000101 != 0) {\n                      iVar12 = in_stack_00000118 - 1;\n                    }\n                    lVar27 = *(long *)(*(long *)(lVar27 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar33 = _uStack0000000000000048[4];\n                      if (iVar33 == 0) break;\n                      cVar9 = debug_record_line(puStack0000000000000020,iVar12 + iVar33,\n                                                *(long *)(_uStack0000000000000048 + 6) + lVar27);\n                      _uStack0000000000000048 = _uStack0000000000000048 + 4;\n                      if (cVar9 == '\\0') goto LAB_00105981;\n                    }\n                  }\n                  _uStack0000000000000048 = (int *)0x0;\n                  pcStack0000000000000038 = (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar35 = \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar12 = strcmp(pcVar35,\".ef\");\n                if (iVar12 != 0) goto switchD_00106e1a_caseD_68;\n                if (cVar10 != '\\0') {\n                  cVar10 = debug_end_function(puStack0000000000000020);\n                  if (cVar10 == '\\0') goto LAB_00105981;\n                  cVar10 = '\\0';\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar35 = \"%ld: unexpected .ef\\n\";\n              }\n              uVar19 = dcgettext(0,pcVar35,5);\n              non_fatal(uVar19);\n              goto LAB_00105981;\n            default:\n              goto LAB_0010700a;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (cVar9 != '\\0');\n      }\n      else {\n        pcVar35 = \"%s: no recognized debugging information\";\nLAB_00105968:\n        uVar19 = dcgettext(0,pcVar35,5);\n        non_fatal(uVar19);\n      }\n      goto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)(param_7 + 0x44) & 0x42) != 0) && ((*(uint *)(param_7 + 0x44) & 1) == 0)) {\n    if ((*(char *)(*(long *)(param_7 + 8) + 0x20) == '\\0') && (keep_section_symbols == '\\0')) {\n      if (uStack0000000000000010 != 0) {\n        plVar6 = isympp + uStack0000000000000010;\n        plVar16 = isympp;\n        do {\n          uVar11 = *(uint *)(*plVar16 + 0x18);\n          if ((uVar11 & 0x1000000) != 0) {\n            *(uint *)(*plVar16 + 0x18) = uVar11 & 0xfeffffff;\n          }\n          plVar16 = plVar16 + 1;\n        } while (plVar6 != plVar16);\n      }\n    }\n    else {\n      for (lVar27 = *(long *)(param_7 + 0x90); lVar27 != 0; lVar27 = *(long *)(lVar27 + 8)) {\n        if (*(long *)(lVar27 + 0xe8) != 0) {\n          puVar1 = (uint *)(*(long *)(lVar27 + 0xe8) + 0x18);\n          *puVar1 = *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((strip_symbols == 2) || (strip_symbols == 7)) {\nLAB_001059fe:\n    if (strip_symbols == 7) {\nLAB_00105a3b:\n      plVar16 = (long *)xmalloc();\n      plVar6 = isympp;\n      uStack0000000000000048 = *(uint *)((long)unaff_R14 + 0x44) & 0x42;\n      osympp = plVar16;\n      if (uStack0000000000000010 == 0) {\n        uVar28 = 0;\n      }\n      else {\n        uVar28 = 0;\n        _in_stack_00000018 = 0;\n        do {\n          iVar12 = add_symbols;\n          plVar4 = (long *)plVar6[_in_stack_00000018];\n          pcVar5 = (code *)plVar4[4];\n          uVar11 = *(uint *)(plVar4 + 3);\n          pcVar35 = (char *)plVar4[1];\n          pcVar30 = pcVar35;\n          if (add_sym_list != (undefined8 *)0x0) {\n            iVar33 = 0;\n            puVar31 = add_sym_list;\n            while ((iVar33 < iVar12 && (pcVar22 = (char *)puVar31[5], pcVar22 != (char *)0x0))) {\n              if (pcVar22 != \"\") {\n                iVar15 = strcmp(pcVar22,pcVar35);\n                if (iVar15 == 0) {\n                  free(pcVar22);\n                  uVar23 = uVar28 + 1;\n                  puVar31[5] = \"\";\n                  lVar27 = create_new_symbol(puVar31);\n                  uVar19 = redefine_specific_htab;\n                  plVar16[uVar28] = lVar27;\n                  lVar27 = htab_elements(uVar19);\n                  if ((lVar27 != 0) || (section_rename_list != (char **)0x0)) goto LAB_001064eb;\n                  goto LAB_00105af8;\n                }\n                puVar31 = (undefined8 *)*puVar31;\n              }\n              iVar33 = iVar33 + 1;\n            }\n          }\n          lVar27 = htab_elements(redefine_specific_htab);\n          uVar23 = uVar28;\n          if ((lVar27 != 0) || (section_rename_list != (char **)0x0)) {\n            if (pcVar35 != (char *)0x0) {\nLAB_001064eb:\n              if (((*pcVar35 == '_') && (pcVar35[1] == '_')) &&\n                 (iVar12 = strcmp(pcVar35 + (pcVar35[2] == '_'),\"__gnu_lto_slim\"), iVar12 == 0)) {\n                uVar19 = dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\"\n                                   ,5);\n                    \n                fatal(uVar19);\n              }\n            }\n            _cStack0000000000000148 = 0;\n            in_stack_00000140 = pcVar35;\n            lVar27 = htab_find(redefine_specific_htab);\n            if (((lVar27 == 0) || (pcVar30 = *(char **)(lVar27 + 8), pcVar35 == pcVar30)) &&\n               (pcVar30 = pcVar35, ppcVar38 = section_rename_list, (uVar11 & 0x100) != 0)) {\n              for (; ppcVar38 != (char **)0x0; ppcVar38 = (char **)ppcVar38[3]) {\n                iVar12 = strcmp(*ppcVar38,pcVar35);\n                if (iVar12 == 0) {\n                  pcVar30 = ppcVar38[1];\n                  break;\n                }\n              }\n            }\n            plVar4[1] = (long)pcVar30;\n            cVar10 = *pcVar30;\n            if (cVar10 != '\\0') goto LAB_00105b11;\nLAB_00106557:\n            pcVar35 = prefix_symbols_string;\n            if ((change_leading_char != '\\0') && (*(char *)(*(long *)(param_7 + 8) + 0x1c) != '\\0'))\n            {\n              lVar27 = unaff_R14[1];\n              cVar10 = '\\0';\n              goto LAB_0010668d;\n            }\n            goto joined_r0x00106565;\n          }\nLAB_00105af8:\n          cVar10 = *pcVar35;\n          if (cVar10 == '\\0') goto LAB_00106557;\nLAB_00105b11:\n          pcVar35 = prefix_symbols_string;\n          lVar27 = unaff_R14[1];\n          if (*(char *)(lVar27 + 0x1c) == cVar10) {\n            if (change_leading_char == '\\0') {\n              if ((remove_leading_char == '\\0') ||\n                 ((((uVar11 & 0x82) == 0 && (pcVar5 != bfd_map_over_sections)) &&\n                  ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n              pcVar30 = pcVar30 + 1;\n              plVar4[1] = (long)pcVar30;\n              goto joined_r0x00106565;\n            }\n            cVar10 = *(char *)(*(long *)(param_7 + 8) + 0x1c);\n            if (cVar10 == '\\0') goto LAB_0010677d;\n            if (prefix_symbols_string != (char *)0x0) {\n              pcVar30 = pcVar30 + 1;\n              plVar4[1] = (long)pcVar30;\n              sVar20 = strlen(pcVar30);\n              lVar27 = sVar20 + 2;\nLAB_001066bc:\n              sVar20 = strlen(pcVar35);\n              pcVar35 = (char *)xmalloc(sVar20 + lVar27);\n              goto LAB_001066d0;\n            }\n            *pcVar30 = cVar10;\n            plVar4[1] = (long)pcVar30;\n            uVar28 = uVar23;\n          }\n          else {\n            if ((change_leading_char == '\\0') || (*(char *)(*(long *)(param_7 + 8) + 0x1c) == '\\0'))\n            {\njoined_r0x00106565:\n              uVar28 = uVar23;\n              if (pcVar35 == (char *)0x0) goto LAB_00105b32;\n              sVar20 = strlen(pcVar30);\n              sVar21 = strlen(pcVar35);\n              pcVar22 = (char *)xmalloc(sVar21 + sVar20 + 1);\n              pcVar35 = pcVar22;\n            }\n            else {\nLAB_0010668d:\n              pcVar35 = prefix_symbols_string;\n              if ((*(char *)(lVar27 + 0x1c) != '\\0') && (cVar10 != *(char *)(lVar27 + 0x1c)))\n              goto joined_r0x00106565;\n              sVar20 = strlen(pcVar30);\n              lVar27 = sVar20 + 2;\n              if (pcVar35 != (char *)0x0) goto LAB_001066bc;\n              pcVar35 = (char *)xmalloc(lVar27);\nLAB_001066d0:\n              pcVar22 = pcVar35 + 1;\n              *pcVar35 = *(char *)(*(long *)(param_7 + 8) + 0x1c);\n            }\n            __s = prefix_symbols_string;\n            if (prefix_symbols_string != (char *)0x0) {\n              strcpy(pcVar22,prefix_symbols_string);\n              sVar20 = strlen(__s);\n              pcVar22 = pcVar22 + sVar20;\n            }\n            strcpy(pcVar22,pcVar30);\n            plVar4[1] = (long)pcVar35;\n            pcVar30 = pcVar35;\n            uVar28 = uVar23;\n          }\nLAB_00105b32:\n          if (strip_symbols == 7) goto LAB_001067a8;\n          if (((uVar11 & 0x20) == 0) &&\n             (((uVar11 & 0x100) == 0 ||\n              ((*(byte *)(**(long **)(plVar4[4] + 0xf0) + 0x18) & 0x20) == 0)))) {\n            if (((uStack0000000000000048 == 0) &&\n                (((uVar11 & 0x82) != 0 || ((*(byte *)(plVar4[4] + 0x25) & 0x10) != 0)))) ||\n               (iVar12 = bfd_decode_symclass(plVar4), iVar12 == 0x49)) {\nLAB_00105be2:\n              if (wildcard == '\\0') {\n                lVar27 = htab_find();\n                if (lVar27 == 0) goto LAB_00105c07;\n              }\n              else {\n                _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n                in_stack_00000140 = pcVar30;\n                htab_traverse(strip_specific_htab,is_specified_symbol_predicate,&stack0x00000140);\n                if (cStack0000000000000148 == '\\0') goto LAB_00105c07;\n              }\n            }\n            else if ((((uVar11 & 0x82) == 0) && (pcVar5 != bfd_map_over_sections)) &&\n                    ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)) {\n              if ((uVar11 & 4) == 0) {\n                if (((*(int *)(unaff_R14[1] + 8) != 2) ||\n                    (lVar27 = *(long *)(plVar4[4] + 0xd0), lVar27 == 0)) ||\n                   (*(long *)(lVar27 + 0x40) == 0)) {\n                  if ((strip_symbols == 3) || (discard_locals == 2)) goto LAB_001067a8;\n                  if (discard_locals == 1) {\n                    cVar10 = bfd_is_local_label(unaff_R14);\n                    goto joined_r0x00106a11;\n                  }\n                }\n                goto LAB_00105be2;\n              }\n              cVar10 = convert_debugging;\n              if (1 < strip_symbols - 2U) {\njoined_r0x00106a11:\n                if (cVar10 == '\\0') goto LAB_00105be2;\n              }\n            }\n            else if (strip_symbols != 3) goto LAB_00105be2;\n            goto LAB_001067a8;\n          }\n          if (wildcard == '\\0') {\n            lVar27 = htab_find();\n            if (lVar27 != 0) {\nLAB_0010687f:\n              uVar19 = dcgettext(0,\"not stripping symbol `%s\\' because it is named in a relocation\",\n                                 5);\n              non_fatal(uVar19);\n              status = 1;\n            }\n          }\n          else {\n            _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n            in_stack_00000140 = pcVar30;\n            htab_traverse(strip_specific_htab,is_specified_symbol_predicate,&stack0x00000140);\n            if (cStack0000000000000148 != '\\0') goto LAB_0010687f;\n          }\n          if ((uVar11 & 0x20) == 0) {\nLAB_00105c07:\n            if (wildcard != '\\0') {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              in_stack_00000140 = pcVar30;\n              htab_traverse(strip_unneeded_htab,is_specified_symbol_predicate,&stack0x00000140);\n              if (cStack0000000000000148 != '\\0') goto LAB_001067a8;\n              goto LAB_00105c2c;\n            }\n            lVar27 = htab_find();\n            if (lVar27 == 0) goto LAB_00105c2c;\nLAB_001067a8:\n            if ((keep_file_symbols != '\\0') && ((uVar11 & 0x4000) != 0)) goto LAB_00105c2c;\n            if (wildcard == '\\0') {\n              lVar27 = htab_find();\n              if (lVar27 != 0) goto LAB_00105c2c;\n            }\n            else {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              in_stack_00000140 = pcVar30;\n              htab_traverse(keep_specific_htab,is_specified_symbol_predicate,&stack0x00000140);\n              if (cStack0000000000000148 != '\\0') goto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            cVar10 = is_strip_section_isra_0(plVar4[4]);\n            if (cVar10 == '\\0') {\n              if (((uVar11 & 0x800002) == 0) && (pcVar5 != bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uVar11 & 0x82) != 0) {\n                  cVar10 = is_specified_symbol(pcVar30);\n                  if ((cVar10 == '\\0') &&\n                     ((lVar27 = htab_elements(keepglobal_specific_htab), lVar27 == 0 ||\n                      (cVar10 = is_specified_symbol(pcVar30), cVar10 != '\\0')))) {\n                    if (((((localize_hidden == '\\0') ||\n                          (uVar13 = *(uint *)(plVar4 + 3), (uVar13 & 0x200000) != 0)) ||\n                         (lVar27 = *plVar4, lVar27 == 0)) ||\n                        ((*(int *)(*(long *)(lVar27 + 8) + 8) != 5 ||\n                         (*(long *)(lVar27 + 0x110) == 0)))) ||\n                       (1 < (*(byte *)((long)plVar4 + 0x49) & 3) - 1)) goto joined_r0x00105ca2;\n                  }\n                  else {\n                    uVar13 = *(uint *)(plVar4 + 3);\n                  }\n                  *(uint *)(plVar4 + 3) = uVar13 & 0xffffff7d | 1;\n                }\njoined_r0x00105ca2:\n                if (((uVar11 & 1) != 0) && (cVar10 = is_specified_symbol(pcVar30), cVar10 != '\\0'))\n                {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((weaken != '\\0') || (cVar10 = is_specified_symbol(pcVar30), cVar10 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xff7ffffd | 0x80;\n                }\n                if (pcVar5 != bfd_map_over_sections) goto LAB_00105c5f;\n              }\n              plVar16[uVar28] = (long)plVar4;\n              uVar28 = uVar28 + 1;\n            }\n          }\n          _in_stack_00000018 = _in_stack_00000018 + 1;\n        } while (uStack0000000000000010 != _in_stack_00000018);\n      }\n      if (add_sym_list != (undefined8 *)0x0) {\n        puVar31 = add_sym_list;\n        iVar12 = add_symbols;\n        for (lVar27 = 0; lVar27 < iVar12; lVar27 = lVar27 + 1) {\n          pcVar35 = (char *)puVar31[5];\n          if (pcVar35 == (char *)0x0) {\n            plVar6 = plVar16 + uVar28;\n            uVar28 = uVar28 + 1;\n            lVar17 = create_new_symbol(puVar31,param_7);\n            *plVar6 = lVar17;\n            iVar12 = add_symbols;\n          }\n          else if (pcVar35 != \"\") {\n            uVar19 = dcgettext(0,\"\\'before=%s\\' not found\",5);\n                    \n            fatal(uVar19,pcVar35);\n          }\n          puVar31 = (undefined8 *)*puVar31;\n        }\n      }\n      bVar41 = convert_debugging == '\\0';\n      plVar16[uVar28] = 0;\n      if ((bVar41) || (puStack0000000000000020 == (undefined4 *)0x0)) {\nLAB_00105cfa:\n        uStack0000000000000010 = uVar28 & 0xffffffff;\n        goto LAB_00105710;\n      }\n      iVar12 = *(int *)(*(undefined8 **)(param_7 + 8) + 1);\n      if ((iVar12 == 5) || (iVar12 == 2)) {\n        in_stack_000000e0 = (void *)0x0;\n        cVar10 = write_stabs_in_sections_debugging_info_constprop_0\n                           (param_7,puStack0000000000000020,&stack0x000000c0,&stack0x00000110,\n                            &stack0x000000e0,&stack0x00000140);\n        if (cVar10 != '\\0') {\n          lVar27 = bfd_make_section_with_flags(param_7,\".stab\",0x2108);\n          lVar17 = bfd_make_section_with_flags(param_7,\".stabstr\",0x2108);\n          if ((((lVar27 == 0) || (lVar17 == 0)) ||\n              (cVar10 = bfd_set_section_size(lVar27,in_stack_00000110), cVar10 == '\\0')) ||\n             (cVar10 = bfd_set_section_size(lVar17,in_stack_00000140), cVar10 == '\\0')) {\n            pcVar35 = \"can\\'t create debugging section\";\n          }\n          else {\n            *(undefined4 *)(lVar27 + 0x7c) = 2;\n            *(undefined4 *)(lVar17 + 0x7c) = 0;\n            cVar10 = bfd_set_section_contents(param_7,lVar27,in_stack_000000c0,0,in_stack_00000110);\n            if ((cVar10 != '\\0') &&\n               (cVar10 = bfd_set_section_contents\n                                   (param_7,lVar17,in_stack_000000e0,0,in_stack_00000140),\n               cVar10 != '\\0')) {\n              free(puStack0000000000000020);\n              goto LAB_00105cfa;\n            }\n            pcVar35 = \"can\\'t set debugging section contents\";\n          }\n          uVar19 = dcgettext(0,pcVar35,5);\n          bfd_nonfatal_message(0,param_7,0,uVar19);\n          free(in_stack_000000e0);\n          free(puStack0000000000000020);\n          goto LAB_00105d96;\n        }\n      }\n      else {\n        uVar19 = **(undefined8 **)(param_7 + 8);\n        uVar18 = dcgettext(0,\"don\\'t know how to write debugging information for %s\",5);\n        bfd_nonfatal_message(0,param_7,0,uVar18,uVar19);\n      }\n      free(puStack0000000000000020);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections();\n      iVar12 = bfd_get_error();\n      if (iVar12 == 0) goto LAB_00105a3b;\n    }\nLAB_00105d96:\n    status = 1;\n  }\n  else {\n    if ((strip_symbols - 3U < 4) || ((discard_locals != 0 || (localize_hidden != '\\0'))))\n    goto LAB_00105a07;\n    lVar27 = htab_elements(strip_specific_htab);\n    if (((lVar27 != 0) ||\n        (((((((lVar27 = htab_elements(keep_specific_htab), lVar27 != 0 ||\n              (lVar27 = htab_elements(localize_specific_htab), lVar27 != 0)) ||\n             (lVar27 = htab_elements(globalize_specific_htab), lVar27 != 0)) ||\n            ((lVar27 = htab_elements(keepglobal_specific_htab), lVar27 != 0 ||\n             (lVar27 = htab_elements(weaken_specific_htab), lVar27 != 0)))) ||\n           (lVar27 = htab_elements(redefine_specific_htab), lVar27 != 0)) ||\n          (((prefix_symbols_string != (char *)0x0 || (sections_removed != '\\0')) ||\n           ((sections_copied != '\\0' ||\n            (((convert_debugging != '\\0' || (change_leading_char != '\\0')) ||\n             (remove_leading_char != '\\0')))))))) ||\n         ((section_rename_list != (char **)0x0 || (weaken != '\\0')))))) || (add_symbols != 0))\n    goto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(param_7,osympp,uStack0000000000000010 & 0xffffffff);\n    bfd_map_over_sections(unaff_R14,copy_relocations_in_section,param_7);\n    bfd_map_over_sections(unaff_R14,copy_section,param_7);\n    for (puVar31 = add_sections; puVar37 = update_sections, puVar31 != (undefined8 *)0x0;\n        puVar31 = (undefined8 *)*puVar31) {\n      cVar10 = bfd_set_section_contents(param_7,puVar31[5],puVar31[4],0,puVar31[3]);\n      if (cVar10 == '\\0') {\n        bfd_nonfatal_message(0,param_7,puVar31[5],0);\n        return 0;\n      }\n    }\n    for (; puVar37 != (undefined8 *)0x0; puVar37 = (undefined8 *)*puVar37) {\n      uVar19 = *(undefined8 *)(puVar37[5] + 0x60);\n      cVar10 = bfd_set_section_contents(param_7,uVar19,puVar37[4],0,puVar37[3]);\n      if (cVar10 == '\\0') {\n        bfd_nonfatal_message(0,param_7,uVar19,0);\n        return 0;\n      }\n    }\n    if (__ptr_01 == (long **)0x0) {\n      if ((merge_notes != '\\0') && (is_strip == 0)) {\n        uVar19 = *unaff_R14;\n        uVar18 = dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n        non_fatal(uVar18,uVar19);\n      }\n    }\n    else {\n      pplVar34 = (long **)0x0;\n      for (puVar31 = *(undefined8 **)(param_7 + 0x90); puVar31 != (undefined8 *)0x0;\n          puVar31 = (undefined8 *)puVar31[1]) {\n        if (((merge_notes != '\\0') && (*(int *)(*(long *)(param_7 + 8) + 8) == 5)) &&\n           ((*(int *)(puVar31[0x1a] + 4) == 7 &&\n            (cVar10 = startswith_lto_priv_0_lto_priv_0(*puVar31,\".gnu.build.attributes\"),\n            cVar10 != '\\0')))) {\n          if (pplVar34 == (long **)0x0) {\n            pplVar34 = __ptr_01;\n          }\n          pplVar29 = __ptr_01;\n          if ((undefined8 *)(*pplVar34)[0xc] == puVar31) {\nLAB_0010625f:\n            pcVar35 = \"error: failed to merge notes\";\n            if (pplVar34[1] != (long *)0x0) {\n              cVar10 = bfd_set_section_contents(param_7,puVar31,pplVar34[1],0,pplVar34[2]);\n              if (cVar10 == '\\0') {\n                uVar19 = dcgettext(0,\"error: failed to copy merged notes into output\",5);\n                bfd_nonfatal_message(0,param_7,puVar31,uVar19);\n                return 0;\n              }\n              pplVar34 = (long **)pplVar34[3];\n              goto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              pplVar34 = pplVar29;\n              if ((undefined8 *)(*pplVar29)[0xc] == puVar31) goto LAB_0010625f;\n              pplVar34 = (long **)pplVar29[3];\n              pplVar29 = pplVar34;\n            } while (pplVar34 != (long **)0x0);\n            pcVar35 = \"error: failed to locate merged notes\";\n          }\n          uVar19 = dcgettext(0,pcVar35,5);\n          bfd_nonfatal_message(0,param_7,puVar31,uVar19);\n        }\nLAB_001061be:\n      }\n      do {\n        pplVar34 = (long **)__ptr_01[3];\n        free(__ptr_01[1]);\n        free(__ptr_01);\n        __ptr_01 = pplVar34;\n      } while (pplVar34 != (long **)0x0);\n    }\n    if ((gnu_debuglink_filename == 0) ||\n       (cVar10 = bfd_fill_in_gnu_debuglink_section(param_7,lStack0000000000000078),\n       lVar27 = gnu_debuglink_filename, cVar10 != '\\0')) {\n      uVar11 = (**(code **)(*(long *)(param_7 + 8) + 0x140))(unaff_R14);\n      uVar28 = (ulong)uVar11;\n      if ((char)uVar11 != '\\0') {\n        if (use_alt_mach_code == 0) {\n          return uVar28;\n        }\n        cVar10 = bfd_alt_mach_code(param_7,use_alt_mach_code & 0xffffffff);\n        uVar23 = use_alt_mach_code;\n        if (cVar10 == '\\0') {\n          uVar19 = dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n          non_fatal(uVar19,uVar23);\n          if (*(int *)(*(long *)(param_7 + 8) + 8) == 5) {\n            uVar19 = dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n            non_fatal(uVar19);\n            *(short *)(*(long *)(param_7 + 0x110) + 0x3a) = (short)use_alt_mach_code;\n            return uVar28;\n          }\n          uVar19 = dcgettext(0,\"ignoring the alternative value\",5);\n          non_fatal(uVar19);\n          return uVar28;\n        }\n        return uVar28;\n      }\n      uVar19 = dcgettext(0,\"error copying private BFD data\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar19);\n    }\n    else {\n      uVar19 = dcgettext(0,\"cannot fill debug link section `%s\\'\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar19,lVar27);\n    }\n  }\n  return 0;\nLAB_00115187:\n  if ((((*(int *)(unaff_R14[1] + 8) == 5) && (*(int *)((long)pplVar34[0x1a] + 4) == 7)) &&\n      (cVar10 = startswith_lto_priv_0_lto_priv_0(*pplVar34), cVar10 != '\\0')) &&\n     ((pplVar34[0xc] != (long *)0x0 && (plVar6 = pplVar34[8], plVar6 != (long *)0x0)))) {\n    pplVar29 = (long **)xmalloc(0x20);\n    pplVar29[1] = (long *)0x0;\n    cVar10 = bfd_get_full_section_contents();\n    if (cVar10 == '\\0') {\n      dcgettext(0,\"warning: could not load note section\",5);\n      bfd_nonfatal_message(0);\n      free(pplVar29);\n    }\n    else {\n      plVar16 = (long *)merge_gnu_build_notes();\n      pplVar29[2] = plVar16;\n      if ((plVar16 == plVar6) || (cVar10 = bfd_set_section_size(pplVar34[0xc]), cVar10 != '\\0')) {\n        pplVar29[3] = (long *)__ptr_01;\n        *pplVar29 = (long *)pplVar34;\n        __ptr_01 = pplVar29;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        bfd_nonfatal_message(0,param_7,pplVar34);\n        free(pplVar29[1]);\n        free(pplVar29);\n      }\n    }\n  }\n  pplVar34 = (long **)pplVar34[1];\n  puVar31 = dump_sections;\n  if (pplVar34 == (long **)0x0) goto joined_r0x001151c7;\n  goto LAB_001151ab;\n}\n\n",
            "called": [
                "dcgettext",
                "non_fatal",
                "FUN_00107880",
                "bfd_get_archive_filename"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x001152b6",
            "calling": [
                "FUN_00107976"
            ],
            "imported": false,
            "current_name": "FUNC_001152b6"
        },
        "FUN_001042a0": {
            "renaming": {},
            "code": "\n\n\nint printf(char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = printf(__format);\n  return iVar1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001042a0",
            "calling": [
                "display_info.isra.0.cold",
                "FUN_00107976",
                "print_version",
                "FUN_00104ea2",
                "display_info.isra.0",
                "do_display_target"
            ],
            "imported": false,
            "current_name": "FUN_001042a0"
        },
        "FUN_001044e0": {
            "renaming": {},
            "code": "\nvoid htab_elements(void)\n\n{\n  htab_elements();\n  return;\n}\n\n",
            "called": [
                "htab_elements"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001044e0",
            "calling": [
                "main",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "FUN_001044e0"
        },
        "FUN_001043c0": {
            "renaming": {},
            "code": "\n\n\nint close(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = close(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043c0",
            "calling": [
                "main",
                "simple_copy.cold",
                "copy_file",
                "display_info.isra.0",
                "simple_copy"
            ],
            "imported": false,
            "current_name": "FUN_001043c0"
        },
        "FUN_00114cf0": {
            "renaming": {
                "FUN_00114cf0": "create_file_path_and_set_null_00114cf0",
                "param_1": "inputPath",
                "pcVar1": "lastSlash",
                "lVar2": "loopCounter",
                "lVar3": "index",
                "lVar4": "lastSlashIndex",
                "pcVar5": "newPath",
                "bVar6": "isSlashPresent"
            },
            "code": "\nvoid createFilePathAndSetNull_00114cf0(char *inputPath)\n\n{\n  char *lastSlash;\n  long loopCounter;\n  long index;\n  long lastSlashIndex;\n  char *newPath;\n  byte isSlashPresent;\n  \n  isSlashPresent = 0;\n  lastSlash = strrchr(inputPath,0x2f);\n  if (lastSlash == (char *)0x0) {\n    lastSlash = (char *)xmalloc(9);\n    index = 0;\n  }\n  else {\n    lastSlashIndex = (long)lastSlash - (long)inputPath;\n    lastSlash = (char *)xmalloc(lastSlashIndex + 0xb);\n    index = lastSlashIndex + 1;\n    newPath = lastSlash;\n    for (loopCounter = lastSlashIndex; loopCounter != 0; loopCounter = loopCounter + -1) {\n      *newPath = *inputPath;\n      inputPath = inputPath + (ulong)isSlashPresent * -2 + 1;\n      newPath = newPath + (ulong)isSlashPresent * -2 + 1;\n    }\n    lastSlash[lastSlashIndex] = '/';\n  }\n  *(undefined8 *)(lastSlash + index) = 0x5858585858587473;\n  *(undefined *)((long)(lastSlash + index) + 8) = 0;\n  return;\n}\n\n",
            "called": [
                "strrchr",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114cf0",
            "calling": [
                "main",
                "make_tempdir"
            ],
            "imported": false,
            "current_name": "create_file_path_and_set_null_00114cf0"
        },
        "FUN_0011a4b4": {
            "renaming": {
                "FUN_0011a4b4": "FUNC_0011a4b4"
            },
            "code": "\nvoid FUNC_0011a4b4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0011a4b4",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_0011a4b4"
        },
        "FUN_0010a181": {
            "renaming": {
                "FUN_0010a181": "generate_formatted_string_0010a181",
                "param_1": "data",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "flag",
                "cVar1": "tempChar",
                "__s": "str1",
                "__s_00": "str2",
                "sVar5": "len1",
                "sVar6": "len2",
                "__s_01": "formattedStr",
                "lVar7": "counter",
                "local_41": "localFlag",
                "iVar2": "dataValue",
                "iVar3": "result",
                "uVar4": "returnValue"
            },
            "code": "\nundefined4 generateFormattedString_0010a181(long data,long value1,long value2,byte flag)\n\n{\n  char tempChar;\n  int dataValue;\n  int result;\n  undefined4 returnValue;\n  char *str1;\n  char *str2;\n  size_t len1;\n  size_t len2;\n  char *formattedStr;\n  long counter;\n  byte localFlag;\n  \n  tempChar = *(char *)(*(long *)(data + 0x60) + 0x1c);\n  str1 = (char *)stab_pop_type();\n  localFlag = 1;\n  if (tempChar == '\\0') {\n    localFlag = *(byte *)(*(long *)(data + 0x60) + 0x1c);\n  }\n  dataValue = *(int *)(*(long *)(data + 0x60) + 0x18);\n  str2 = (char *)stab_pop_type(data);\n  len1 = strlen(str1);\n  len2 = strlen(str2);\n  formattedStr = (char *)xmalloc(len1 + 100 + len2);\n  if (flag == 0) {\n    *formattedStr = '\\0';\n    counter = 0;\n    localFlag = localFlag & 1;\n  }\n  else {\n    counter = *(long *)(data + 0x68);\n    *(long *)(data + 0x68) = counter + 1;\n    sprintf(formattedStr,\"%ld=@S;\",counter);\n    localFlag = flag;\n  }\n  len1 = strlen(formattedStr);\n  sprintf(formattedStr + len1,\"ar%s;%ld;%ld;%s\",str1,value1,value2,str2);\n  free(str1);\n  free(str2);\n  result = 0;\n  if (value1 <= value2) {\n    result = dataValue * (((int)value2 - (int)value1) + 1);\n  }\n  returnValue = stab_push_string(data,formattedStr,counter,localFlag,result);\n  if ((char)returnValue != '\\0') {\n    free(formattedStr);\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "strlen",
                "stab_push_string",
                "sprintf",
                "free",
                "stab_pop_type",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a181",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "generate_formatted_string_0010a181"
        },
        "FUN_001199d0": {
            "renaming": {
                "FUN_001199d0": "display_binary_targets_001199d0",
                "iVar1": "columnWidth",
                "iVar2": "targetIndex",
                "iVar3": "archMachIndex",
                "pcVar4": "formatString",
                "sVar5": "stringLength",
                "pcVar6": "temporaryFilePath",
                "uVar7": "result",
                "piVar8": "errorNumber",
                "iVar9": "loopIndex",
                "lVar10": "loopVariable1",
                "lVar11": "loopVariable2",
                "ppcVar12": "targetInfo"
            },
            "code": "\n\n\nvoid displayBinaryTargets_001199d0(void)\n\n{\n  int columnWidth;\n  int targetIndex;\n  int archMachIndex;\n  char *formatString;\n  size_t stringLength;\n  char *temporaryFilePath;\n  undefined8 result;\n  int *errorNumber;\n  int loopIndex;\n  long loopVariable1;\n  long loopVariable2;\n  char **targetInfo;\n  uint uVar13;\n  ulong uVar14;\n  int local_70;\n  \n  formatString = (char *)dcgettext(0,\"BFD header file version %s\\n\",5);\n  printf(formatString,\"(GNU Binutils for Debian) 2.40\");\n  if (memoized_tmpdir == (char *)0x0) {\n    formatString = getenv(\"TMPDIR\");\n    result = try_dir_lto_priv_0(formatString,0);\n    formatString = getenv(\"TMP\");\n    result = try_dir_lto_priv_0(formatString,result);\n    formatString = getenv(\"TEMP\");\n    result = try_dir_lto_priv_0(formatString,result);\n    result = try_dir_lto_priv_0(&DAT_0011b39a,result);\n    result = try_dir_lto_priv_0(vartmp,result);\n    formatString = (char *)try_dir_lto_priv_0(&tmp,result);\n    if (formatString == (char *)0x0) {\n      formatString = \".\";\n    }\n    stringLength = strlen(formatString);\n    temporaryFilePath = (char *)xmalloc((int)stringLength + 2);\n    memoized_tmpdir = strcpy(temporaryFilePath,formatString);\n    memoized_tmpdir[stringLength & 0xffffffff] = '/';\n    memoized_tmpdir[(int)stringLength + 1] = '\\0';\n  }\n  formatString = memoized_tmpdir;\n  stringLength = strlen(memoized_tmpdir);\n  loopVariable1 = (long)(int)stringLength;\n  temporaryFilePath = (char *)xmalloc(loopVariable1 + 9);\n  strcpy(temporaryFilePath,formatString);\n  *(undefined2 *)(temporaryFilePath + loopVariable1) = 0x6363;\n  *(undefined4 *)(temporaryFilePath + loopVariable1 + 2) = 0x58585858;\n  *(undefined4 *)((long)(temporaryFilePath + loopVariable1 + 2) + 3) = 0x585858;\n  temporaryFilePath[loopVariable1 + 8] = '\\0';\n  targetIndex = mkstemps(temporaryFilePath,0);\n  if (targetIndex == -1) {\n    errorNumber = __errno_location();\n    temporaryFilePath = strerror(*errorNumber);\n    fprintf(_stderr,\"Cannot create temporary file in %s: %s\\n\",formatString,temporaryFilePath);\n                    \n    abort();\n  }\n  targetIndex = close(targetIndex);\n  if (targetIndex != 0) {\n                    \n    abort();\n  }\n  uVar13 = 0;\n  targetIndex = 2;\n  bfd_iterate_over_targets(do_display_target);\n  unlink(temporaryFilePath);\n  free(temporaryFilePath);\n  local_70 = 0;\n  do {\n    formatString = (char *)bfd_printable_arch_mach(targetIndex);\n    stringLength = strlen(formatString);\n    if ((int)uVar13 < (int)(uint)stringLength) {\n      uVar13 = (uint)stringLength;\n    }\n    targetIndex = targetIndex + 1;\n  } while (targetIndex != 0x57);\n  formatString = getenv(\"COLUMNS\");\n  targetIndex = local_70;\n  if (formatString != (char *)0x0) {\n    loopVariable1 = strtol(formatString,(char **)0x0,10);\n    columnWidth = (int)loopVariable1;\n    if (columnWidth != 0) goto LAB_00119b11;\n  }\n  columnWidth = 0x50;\nLAB_00119b11:\n  do {\n    local_70 = targetIndex;\n    if (-1 < local_70) {\n      return;\n    }\n    loopVariable2 = (long)local_70;\n    loopIndex = (columnWidth - uVar13) + -1;\n    loopVariable1 = loopVariable2;\n    do {\n      targetIndex = (int)loopVariable1;\n      if (-1 < targetIndex) break;\n      stringLength = strlen(*(char **)(loopVariable1 * 0x60));\n      loopVariable1 = loopVariable1 + 1;\n      loopIndex = (loopIndex - (int)stringLength) + -1;\n    } while (-1 < loopIndex);\n    printf(\"\\n%*s\",(ulong)(uVar13 + 1),&DAT_0011b4a1);\n    for (targetInfo = (char **)(loopVariable2 * 0x60);\n        ((ulong)(uint)(targetIndex - local_70) + loopVariable2) * 0x60 - (long)targetInfo != 0;\n        targetInfo = targetInfo + 0xc) {\n      printf(\"%s \",*targetInfo);\n    }\n    loopIndex = 2;\n    putc(10,_stdout);\n    do {\n      formatString = (char *)bfd_printable_arch_mach(loopIndex,0);\n      archMachIndex = strcmp(formatString,\"UNKNOWN!\");\n      if (archMachIndex != 0) {\n        result = bfd_printable_arch_mach(loopIndex,0);\n        printf(\"%*s \",(ulong)uVar13,result);\n        targetInfo = (char **)(loopVariable2 * 0x60);\n        archMachIndex = local_70;\n        while (targetIndex != archMachIndex) {\n          if (*(char *)((long)targetInfo + (ulong)(loopIndex - 2) + 8) == '\\0') {\n            stringLength = strlen(*targetInfo);\n            for (uVar14 = stringLength & 0xffffffff; (int)uVar14 != 0; uVar14 = (ulong)((int)uVar14 - 1)) {\n              putc(0x2d,_stdout);\n            }\n          }\n          else {\n            fputs(*targetInfo,_stdout);\n          }\n          archMachIndex = archMachIndex + 1;\n          if (targetIndex != archMachIndex) {\n            putc(0x20,_stdout);\n          }\n          targetInfo = targetInfo + 0xc;\n        }\n        putc(10,_stdout);\n      }\n      loopIndex = loopIndex + 1;\n    } while (loopIndex != 0x57);\n  } while( true );\n}\n\n",
            "called": [
                "display_info.isra.0.cold",
                "strerror",
                "bfd_printable_arch_mach",
                "close",
                "abort",
                "mkstemps",
                "free",
                "bfd_iterate_over_targets",
                "getenv",
                "fprintf",
                "strcpy",
                "strlen",
                "dcgettext",
                "printf",
                "try_dir.lto_priv.0",
                "xmalloc",
                "do_display_target",
                "__errno_location",
                "unlink"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001199d0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "display_binary_targets_001199d0"
        },
        "FUN_00128198": {
            "renaming": {},
            "code": "\n\n\n\nvoid __assert_fail(char *__assertion,char *__file,uint __line,char *__function)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __assert_fail@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128198",
            "calling": [
                "__assert_fail"
            ],
            "imported": false,
            "current_name": "FUN_00128198"
        },
        "FUN_0010847a": {
            "renaming": {
                "FUN_0010847a": "extract_build_attribute_notes_0010847a",
                "extract_build_attribute_notes_00116490": "extract_notes"
            },
            "code": "\nvoid extract_build_attribute_notes_0010847a(void)\n\n{\n  extract_notes();\n  return;\n}\n\n",
            "called": [
                "FUN_00116490"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010847a",
            "calling": [
                "FUN_001086af"
            ],
            "imported": false,
            "current_name": "extract_build_attribute_notes_0010847a"
        },
        "FUN_0010d21c": {
            "renaming": {
                "FUN_0010d21c": "reverse_and_improve_0010d21c",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "output",
                "bVar1": "byte1",
                "pbVar2": "bytePtr1",
                "bVar3": "byte2",
                "cVar4": "char1",
                "bVar5": "byte3",
                "uVar6": "result",
                "iVar7": "intVar1",
                "uVar8": "uintVar1",
                "sVar9": "size",
                "pbVar10": "bytePtr2",
                "__ptr": "ptr1",
                "__ptr_00": "ptr2",
                "__haystack": "haystack",
                "pcVar11": "pcVar1",
                "uVar12": "outputStr",
                "pcVar13": "pcVar2",
                "bVar14": "byte4",
                "pcVar15": "pcVar3",
                "bVar16": "byte5",
                "bVar17": "byte6",
                "bVar18": "byte7",
                "bVar19": "byte8",
                "uVar20": "count",
                "uVar21": "ulongVar",
                "local_3c": "uintArray"
            },
            "code": "\nundefined4 reverseAndImprove_0010d21c(undefined8 input1,byte **input2,undefined8 *output)\n\n{\n  byte byte1;\n  byte *bytePtr1;\n  byte byte2;\n  char char1;\n  byte byte3;\n  undefined4 result;\n  int intVar1;\n  uint uintVar1;\n  size_t size;\n  byte *bytePtr2;\n  void *ptr1;\n  void *ptr2;\n  char *haystack;\n  char *pcVar1;\n  undefined8 outputStr;\n  char *pcVar2;\n  byte byte4;\n  char *pcVar3;\n  byte byte5;\n  byte byte6;\n  byte byte7;\n  byte byte8;\n  uint count;\n  ulong ulongVar;\n  uint uintArray [3];\n  \n  bytePtr1 = *input2;\n  *input2 = bytePtr1 + 1;\n  uintArray[0] = stab_demangle_count(input2);\n  ulongVar = (ulong)uintArray[0];\n  if (uintArray[0] != 0) {\n    bytePtr2 = *input2;\n    size = strlen((char *)bytePtr2);\n    if (ulongVar <= size) {\n      *input2 = bytePtr2 + ulongVar;\n      count = 0;\n      result = stab_demangle_get_count(input2,uintArray);\n      if ((char)result != '\\0') {\nLAB_0010d2b4:\n        if (uintArray[0] <= count) {\n          if (output == (undefined8 *)0x0) {\n            return result;\n          }\n          ptr1 = (void *)savestring(bytePtr1,(int)*input2 - (int)bytePtr1);\n          ptr2 = (void *)concat(\"NoSuchStrinG__\",ptr1,0);\n          free(ptr1);\n          haystack = (char *)cplus_demangle(ptr2,2);\n          free(ptr2);\n          if ((haystack != (char *)0x0) &&\n             (pcVar1 = strstr(haystack,\"::NoSuchStrinG\"), pcVar2 = haystack,\n             pcVar3 = haystack, pcVar1 != (char *)0x0)) {\n            for (; pcVar2 != pcVar1; pcVar2 = pcVar2 + 1) {\n              if ((*pcVar2 != ' ') ||\n                 (((pcVar2[1] == '>' && (haystack < pcVar2)) && (pcVar2[-1] == '>')))) {\n                *pcVar3 = *pcVar2;\n                pcVar3 = pcVar3 + 1;\n              }\n            }\n            outputStr = savestring(haystack,(int)pcVar3 - (int)haystack);\n            *output = outputStr;\n            free(haystack);\n            return result;\n          }\n          stab_bad_demangle(bytePtr1);\n          free(haystack);\n          return 0;\n        }\n        bytePtr2 = *input2;\n        if (*bytePtr2 != 0x5a) {\n          byte3 = stab_demangle_type_lto_priv_0(input1,input2,0);\n          if (byte3 == 0) {\n            return 0;\n          }\n          byte2 = 0;\n          byte4 = 0;\n          byte7 = 0;\n          byte6 = 0;\n          byte8 = 0;\nLAB_0010d2e9:\n          do {\n            do {\n              byte5 = byte2;\n              byte1 = *bytePtr2;\n              if ((byte4 | byte1 == 0) != 0) {\n                byte3 = 0;\n                goto switchD_0010d329_caseD_70;\n              }\n              byte2 = byte3;\n              byte4 = byte3;\n            } while ('v' < (char)byte1);\n            if ((char)byte1 < 'b') {\n              if ((char)byte1 < 'U') {\n                if ((char)byte1 < 'C') goto LAB_0010d2e9;\n                ulongVar = 1L << (byte1 + 0xbd & 0x3f);\n                if ((ulongVar & 0x11409) == 0) {\n                  if ((ulongVar & 0xa000) != 0) goto switchD_0010d329_caseD_70;\n                  if (byte1 == 0x54) goto switchD_0010d329_caseD_76;\n                  goto LAB_0010d2e9;\n                }\n              }\n              else if (1 < (byte)(byte1 + 0xab)) goto LAB_0010d2e9;\n              bytePtr2 = bytePtr2 + 1;\n              byte2 = byte5;\n              byte4 = 0;\n              goto LAB_0010d2e9;\n            }\n            switch(byte1) {\n            case 0x62:\n              byte2 = byte5;\n              byte7 = byte3;\n              break;\n            case 99:\n              byte2 = byte5;\n              byte8 = byte3;\n              break;\n            case 100:\n            case 0x66:\n            case 0x72:\n              byte2 = byte5;\n              byte6 = byte3;\n              break;\n            case 0x70:\n              goto switchD_0010d329_caseD_70;\n            case 0x76:\nswitchD_0010d329_caseD_76:\n                    \n              abort();\n            }\n          } while( true );\n        }\n        *input2 = bytePtr2 + 1;\n        char1 = stab_demangle_type_lto_priv_0(input1,input2,0);\n        if (char1 == '\\0') {\n          return 0;\n        }\n        goto LAB_0010d2b1;\n      }\n    }\n  }\nLAB_0010d280:\n  stab_bad_demangle(bytePtr1);\n  return 0;\nswitchD_0010d329_caseD_70:\n  if (byte5 == 0) {\n    if (byte8 == 0) {\n      if (byte7 == 0) {\n        if (byte6 == 0) {\n          if (byte3 != 0) {\n            uintVar1 = stab_demangle_count(input2);\n            if (uintVar1 == 0) goto LAB_0010d280;\n            *input2 = *input2 + uintVar1;\n          }\n        }\n        else {\n          if (**input2 == 0x6d) {\n            *input2 = *input2 + 1;\n          }\n          while( true ) {\n            bytePtr2 = *input2;\n            if (((&_sch_istable)[(ulong)*bytePtr2 * 2] & 4) == 0) break;\n            *input2 = bytePtr2 + 1;\n          }\n          if (*bytePtr2 == 0x2e) {\n            do {\n              bytePtr2 = bytePtr2 + 1;\n              *input2 = bytePtr2;\n            } while (((&_sch_istable)[(ulong)*bytePtr2 * 2] & 4) != 0);\n          }\n          bytePtr2 = *input2;\n          if (*bytePtr2 == 0x65) {\n            do {\n              bytePtr2 = bytePtr2 + 1;\n              *input2 = bytePtr2;\n            } while (((&_sch_istable)[(ulong)*bytePtr2 * 2] & 4) != 0);\n          }\n        }\n      }\n      else {\n        uintVar1 = stab_demangle_count(input2);\n        if (1 < uintVar1) goto LAB_0010d280;\n      }\n    }\n    else {\n      if (**input2 == 0x6d) {\n        *input2 = *input2 + 1;\n      }\n      intVar1 = stab_demangle_count(input2);\n      if (intVar1 == 0) goto LAB_0010d280;\n    }\n  }\n  else {\n    if (**input2 == 0x6d) {\n      *input2 = *input2 + 1;\n    }\n    while (((&_sch_istable)[(ulong)**input2 * 2] & 4) != 0) {\n      *input2 = *input2 + 1;\n    }\n  }\nLAB_0010d2b1:\n  count = count + 1;\n  goto LAB_0010d2b4;\n}\n\n",
            "called": [
                "cplus_demangle",
                "stab_bad_demangle",
                "strlen",
                "stab_demangle_get_count",
                "concat",
                "stab_demangle_count",
                "abort",
                "strstr",
                "stab_demangle_type.lto_priv.0",
                "free",
                "savestring"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010d21c",
            "calling": [
                "parse_stab_type",
                "stab_demangle_qualified",
                "stab_demangle_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "reverse_and_improve_0010d21c"
        },
        "FUN_001054af": {
            "renaming": {
                "FUN_001054af": "cleanup_hash_tables_001054af",
                "param_1": "unusedParam1",
                "param_2": "unusedParam2",
                "in_RAX": "returnValue"
            },
            "code": "\nvoid cleanupHashTables_001054af(undefined8 unusedParam1,undefined8 unusedParam2)\n\n{\n  undefined8 returnValue;\n  \n  htab_delete(strip_specific_htab);\n  htab_delete(strip_unneeded_htab);\n  htab_delete(keep_specific_htab);\n  htab_delete(localize_specific_htab);\n  htab_delete(globalize_specific_htab);\n  htab_delete(keepglobal_specific_htab);\n  htab_delete(weaken_specific_htab);\n  htab_delete(redefine_specific_htab);\n  htab_delete(redefine_specific_reverse_htab,unusedParam2,returnValue);\n  return;\n}\n\n",
            "called": [
                "htab_delete"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001054af",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "cleanup_hash_tables_001054af"
        },
        "FUN_0010c139": {
            "renaming": {
                "FUN_0010c139": "allocate_or_update_data_0010c139",
                "param_1": "record",
                "param_2": "data",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6",
                "uVar1": "oldPointer",
                "cVar2": "charValue",
                "uVar3": "result",
                "puVar4": "newPointer",
                "in_R10": "register10",
                "unaff_R15": "register15"
            },
            "code": "\nulong allocateOrUpdateData_0010c139(undefined8 record,long data,undefined8 param3,undefined8 param4,\n                  undefined4 param5,undefined8 param6)\n\n{\n  undefined8 oldPointer;\n  char charValue;\n  ulong result;\n  undefined8 *newPointer;\n  undefined8 register10;\n  undefined8 register15;\n  \n  charValue = *(char *)(data + 0x60);\n  if ((charValue != '\\0') && ((*(int *)(data + 0x40) != 0 || (*(char *)(data + 0x44) == '\\0')))) {\n    newPointer = (undefined8 *)xmalloc(0x28);\n    oldPointer = *(undefined8 *)(data + 0x78);\n    *(undefined8 *)((long)newPointer + 0x1c) = 0;\n    newPointer[2] = param4;\n    *(undefined4 *)(newPointer + 3) = param5;\n    newPointer[4] = param6;\n    *(undefined8 **)(data + 0x78) = newPointer;\n    *newPointer = oldPointer;\n    newPointer[1] = param3;\n    return CONCAT71((int7)((ulong)register15 >> 8),charValue) & 0xffffffff;\n  }\n  result = debug_record_variable(record,param3,param4,param5,param6,register10);\n  return result;\n}\n\n",
            "called": [
                "debug_record_variable",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c139",
            "calling": [
                "parse_stab"
            ],
            "imported": false,
            "current_name": "allocate_or_update_data_0010c139"
        },
        "FUN_0010e439": {
            "renaming": {
                "FUN_0010e439": "update_symbol_in_memory_0010e439",
                "param_1": "memoryAddress",
                "param_2": "newValue",
                "stab_write_symbol_lto_priv_0": "writeSymbolToStabTable"
            },
            "code": "\nvoid updateSymbolInMemory_0010e439(long memoryAddress,undefined8 newValue)\n\n{\n  *(undefined8 *)(memoryAddress + 0x210) = newValue;\n  writeSymbolToStabTable(memoryAddress,0x84,0,0,newValue);\n  return;\n}\n\n",
            "called": [
                "stab_write_symbol.lto_priv.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e439",
            "calling": [
                "stab_start_compilation_unit.lto_priv.0",
                "write_stabs_in_sections_debugging_info.constprop.0"
            ],
            "imported": false,
            "current_name": "update_symbol_in_memory_0010e439"
        },
        "FUN_001043d0": {
            "renaming": {},
            "code": "\nvoid xstrdup(void)\n\n{\n  xstrdup();\n  return;\n}\n\n",
            "called": [
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043d0",
            "calling": [
                "main",
                "parse_stab",
                "stab_push_string",
                "save_stab",
                "FUN_0010554f",
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "FUN_001043d0"
        },
        "FUN_001042b0": {
            "renaming": {},
            "code": "\nvoid xrealloc(void)\n\n{\n  xrealloc();\n  return;\n}\n\n",
            "called": [
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001042b0",
            "calling": [
                "parse_coff_struct_type",
                "stab_demangle_v3_arglist",
                "stab_demangle_arg",
                "stab_class_method_var",
                "main",
                "parse_stab",
                "parse_coff_type.lto_priv.0",
                "stab_write_symbol.lto_priv.0",
                "stab_class_baseclass.lto_priv.0",
                "parse_stab_type",
                "stab_demangle_remember_type",
                "stab_modify_type",
                "stab_class_start_method.lto_priv.0",
                "FUN_00114dc7",
                "stab_get_struct_index",
                "do_display_target"
            ],
            "imported": false,
            "current_name": "FUN_001042b0"
        },
        "FUN_001284c0": {
            "renaming": {},
            "code": "\n\n\n\nchar * strstr(char *__haystack,char *__needle)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strstr@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001284c0",
            "calling": [
                "strstr"
            ],
            "imported": false,
            "current_name": "FUN_001284c0"
        },
        "FUN_001044f0": {
            "renaming": {},
            "code": "\n\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = stat(__file,__buf);\n  return iVar1;\n}\n\n",
            "called": [
                "stat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001044f0",
            "calling": [
                "main",
                "get_file_size",
                "try_dir.lto_priv.0",
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "FUN_001044f0"
        },
        "FUN_00109d3e": {
            "renaming": {
                "FUN_00109d3e": "push_defined_type_with_switch_00109d3e",
                "param_1": "param1",
                "param_2": "param2",
                "uVar1": "defaultValue"
            },
            "code": "\nvoid pushDefinedTypeWithSwitch_00109d3e(undefined8 param1,int param2)\n\n{\n  undefined8 defaultValue;\n  \n  defaultValue = 0xfffffffffffffff0;\n  if (param2 - 1U < 8) {\n    defaultValue = *(undefined8 *)(CSWTCH_58 + (ulong)(param2 - 1U) * 8);\n  }\n  stab_push_defined_type(param1,defaultValue,param2);\n  return;\n}\n\n",
            "called": [
                "stab_push_defined_type"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109d3e",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "push_defined_type_with_switch_00109d3e"
        },
        "FUN_00112502": {
            "renaming": {
                "FUN_00112502": "check_line_number_validity_00112502",
                "param_1": "funcParam_1",
                "param_2": "funcParam_2",
                "param_3": "funcParam_3",
                "uVar1": "loopCounter",
                "puVar2": "funcPointer",
                "uVar3": "tempValue",
                "cVar4": "lineValidity"
            },
            "code": "\nundefined checkLineNumberValidity_00112502(long funcParam_1,undefined8 funcParam_2,ulong funcParam_3)\n\n{\n  uint loopCounter;\n  undefined8 *funcPointer;\n  undefined8 tempValue;\n  char lineValidity;\n  \n  do {\n    funcPointer = *(undefined8 **)(funcParam_1 + 0x40);\n    if (funcPointer == (undefined8 *)0x0) {\n      return 1;\n    }\n    while ((loopCounter = *(uint *)(funcParam_1 + 0x48), loopCounter < 10 && (funcPointer[(ulong)loopCounter + 2] != -1))) {\n      if (funcParam_3 <= (ulong)funcPointer[(ulong)loopCounter + 0xc]) {\n        return 1;\n      }\n      lineValidity = stab_lineno_lto_priv_0(funcParam_2,*(undefined8 *)(funcPointer[1] + 8));\n      if (lineValidity == '\\0') {\n        return 0;\n      }\n      *(int *)(funcParam_1 + 0x48) = *(int *)(funcParam_1 + 0x48) + 1;\n    }\n    tempValue = *funcPointer;\n    *(undefined4 *)(funcParam_1 + 0x48) = 0;\n    *(undefined8 *)(funcParam_1 + 0x40) = tempValue;\n  } while( true );\n}\n\n",
            "called": [
                "stab_lineno.lto_priv.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112502",
            "calling": [
                "debug_write_name.constprop.0",
                "write_stabs_in_sections_debugging_info.constprop.0",
                "debug_write_block.constprop.0"
            ],
            "imported": false,
            "current_name": "check_line_number_validity_00112502"
        },
        "FUN_00104cc1": {
            "renaming": {
                "FUN_00104cc1": "process_input_lines_00104cc1",
                "unaff_RBX": "currentLine",
                "pbVar5": "linePointer",
                "unaff_EBP": "lineIndex",
                "in_R10": "inputBuffer",
                "unaff_R13": "returnAddress",
                "unaff_R14": "startOfLine",
                "unaff_R15": "endOfLine",
                "param_7": "formatString",
                "param_8": "errorPtr",
                "param_9": "currentChar",
                "uVar1": "errorString",
                "ppbVar2": "slotPtr",
                "pbVar3": "currentCharPtr",
                "bVar4": "currentCharByte"
            },
            "code": "\nvoid processInputLines_00104cc1(void)\n\n{\n  undefined8 errorString;\n  byte **slotPtr;\n  byte *currentCharPtr;\n  byte currentCharByte;\n  byte *currentLine;\n  byte *linePointer;\n  int lineIndex;\n  byte *inputBuffer;\n  undefined8 returnAddress;\n  byte *startOfLine;\n  byte *endOfLine;\n  undefined8 formatString;\n  undefined8 *errorPtr;\n  byte *currentChar;\n  \ncode_r0x00104cc1:\n  currentChar = inputBuffer;\n  errorString = dcgettext(0,\"%s:%d: Ignoring rubbish found on this line\",5);\n  non_fatal(errorString,formatString,lineIndex);\n  linePointer = currentLine;\n  inputBuffer = currentChar;\nLAB_00114599:\n  do {\n    *inputBuffer = 0;\n    if (endOfLine < inputBuffer) {\n      slotPtr = (byte **)htab_find_slot();\n      *slotPtr = endOfLine;\n    }\n    lineIndex = lineIndex + 1;\n    currentCharPtr = linePointer;\n    if (startOfLine[1] == 0) {\n      *errorPtr = returnAddress;\n      return;\n    }\n    for (; currentCharByte = *currentCharPtr, startOfLine = currentCharPtr, currentCharByte != 10; currentCharPtr = currentCharPtr + 1) {\n      if ((char)currentCharByte < '\\v') {\n        if (currentCharByte == 0) {\n          currentLine = currentCharPtr + 1;\n          goto LAB_00114553;\n        }\n      }\n      else {\n        if (currentCharByte == 0xd) {\n          *currentCharPtr = 0;\n          currentLine = currentCharPtr + 1;\n          if (currentCharPtr[1] == 10) {\n            currentLine = currentCharPtr + 2;\n            startOfLine = currentCharPtr + 1;\n          }\n          goto LAB_00114553;\n        }\n        if (currentCharByte == 0x23) {\n          parse_input_lines_00104d1c();\n          return;\n        }\n      }\n    }\n    *currentCharPtr = 0;\n    if (currentCharPtr[1] == 0xd) {\n      startOfLine = currentCharPtr + 1;\n      currentLine = currentCharPtr + 2;\n    }\n    else {\n      currentLine = currentCharPtr + 1;\n    }\nLAB_00114553:\n    currentCharByte = *linePointer;\n    endOfLine = linePointer;\n    while ((currentCharByte == 0x20 || (inputBuffer = endOfLine, currentCharByte == 9))) {\n      linePointer = endOfLine + 1;\n      endOfLine = endOfLine + 1;\n      currentCharByte = *linePointer;\n    }\n    do {\n      linePointer = currentLine;\n      if ((currentCharByte == 10) || (currentCharByte == 0xd)) goto LAB_00114676;\n      if (currentCharByte == 0) goto LAB_00114599;\n      currentCharByte = inputBuffer[1];\n      inputBuffer = inputBuffer + 1;\n    } while ((currentCharByte != 0x20) && (currentCharByte != 9));\n    if ((char)currentCharByte < '\\x0e') {\nLAB_00114676:\n      if ((-0x2402L >> (currentCharByte & 0x3f) & 1U) == 0) goto LAB_00114599;\n    }\n    currentCharByte = inputBuffer[1];\n    if ((((((currentCharByte == 9) || (currentCharByte == 0x20)) && ((currentCharByte = inputBuffer[2], currentCharByte == 9 || (currentCharByte == 0x20)))\n          ) && ((currentCharByte = inputBuffer[3], currentCharByte == 9 || (currentCharByte == 0x20)))) &&\n        ((currentCharByte = inputBuffer[4], currentCharByte == 9 || (currentCharByte == 0x20)))) &&\n       ((currentCharByte = inputBuffer[5], currentCharByte == 9 || (currentCharByte == 0x20)))) {\n      currentCharByte = inputBuffer[6];\n      currentCharPtr = inputBuffer + 6;\n      if ((currentCharByte == 9) || (currentCharByte == 0x20)) {\n        do {\n          do {\n            currentCharByte = currentCharPtr[1];\n            currentCharPtr = currentCharPtr + 1;\n          } while (currentCharByte == 0x20);\n        } while (currentCharByte == 9);\n      }\n    }\n    if ((0xd < currentCharByte) || ((-0x2402L >> (currentCharByte & 0x3f) & 1U) != 0)) goto code_r0x00104cc1;\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00104cc1",
                "FUN_00104d1c",
                "dcgettext",
                "non_fatal",
                "htab_find_slot",
                "add_specific_symbols.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104cc1",
            "calling": [
                "FUN_00104cc1"
            ],
            "imported": false,
            "current_name": "process_input_lines_00104cc1"
        },
        "FUN_00113bfa": {
            "renaming": {
                "FUN_00113bfa": "allocate_and_store_data_00113bfa",
                "param_1": "input_value_1",
                "param_2": "input_value_2",
                "lVar1": "type_constant",
                "plVar2": "allocated_memory",
                "debug_make_type_constprop_0": "get_type_constant",
                "xmalloc": "allocate_memory"
            },
            "code": "\nlong allocate_and_store_data_00113bfa(long input_value_1,long input_value_2)\n\n{\n  long type_constant;\n  long *allocated_memory;\n  \n  if (((input_value_1 != 0) && (input_value_2 != 0)) &&\n     (type_constant = get_type_constant(0x12,0), type_constant != 0)) {\n    allocated_memory = (long *)allocate_memory(0x10);\n    *allocated_memory = input_value_1;\n    allocated_memory[1] = input_value_2;\n    *(long **)(type_constant + 0x10) = allocated_memory;\n    return type_constant;\n  }\n  return 0;\n}\n\n",
            "called": [
                "debug_make_type.constprop.0",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113bfa",
            "calling": [
                "parse_stab_type",
                "stab_demangle_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "allocate_and_store_data_00113bfa"
        },
        "FUN_00108375": {
            "renaming": {
                "FUN_00108375": "check_and_drop_share_flag_00108375",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "uVar1": "value1",
                "uVar2": "message",
                "unaff_EBX": "ebx"
            },
            "code": "\nuint checkAndDropShareFlag_00108375(undefined8 param1,undefined8 *param2,undefined8 param3)\n\n{\n  undefined8 value1;\n  undefined8 message;\n  uint ebx;\n  \n  if (*(int *)(param2[1] + 8) != 2) {\n    value1 = *param2;\n    ebx = ebx & 0xf7ffffff;\n    message = dcgettext(0,\"%s[%s]: Note - dropping \\'share\\' flag as output format is not COFF\",5);\n    non_fatal(message,value1,param3);\n  }\n  return ebx;\n}\n\n",
            "called": [
                "dcgettext",
                "non_fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108375",
            "calling": [
                "check_new_section_flags"
            ],
            "imported": false,
            "current_name": "check_and_drop_share_flag_00108375"
        },
        "FUN_00109e76": {
            "renaming": {
                "FUN_00109e76": "generate_stab_string_00109e76",
                "param_1": "binaryAddress",
                "param_2": "accessMode",
                "lVar1": "previousValue",
                "local_5a": "stringBuffer"
            },
            "code": "\nvoid generateStabString_00109e76(long binaryAddress,uint accessMode)\n\n{\n  long previousValue;\n  char stringBuffer [58];\n  \n  previousValue = *(long *)(binaryAddress + 0x68);\n  *(long *)(binaryAddress + 0x68) = previousValue + 1;\n  sprintf(stringBuffer,\"%ld=r%ld;%u;0;\",previousValue,previousValue,(ulong)accessMode);\n  stab_push_string(binaryAddress,stringBuffer,previousValue,1,accessMode * 2);\n  return;\n}\n\n",
            "called": [
                "stab_push_string",
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109e76",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "generate_stab_string_00109e76"
        },
        "FUN_001088ae": {
            "renaming": {
                "FUN_001088ae": "update_saved_stabs_001088ae",
                "param_1": "newValue1",
                "param_2": "newValue2",
                "param_3": "newValue3",
                "param_4": "newValue4",
                "iVar1": "updatedIndex",
                "lVar2": "stabsIndexOffset",
                "uVar3": "duplicatedString",
                "saved_stabs_index": "currentIndex",
                "saved_stabs": "stabsArray"
            },
            "code": "\nulong updateSavedStabs_001088ae(undefined4 newValue1,undefined4 newValue2,undefined8 newValue3,undefined8 newValue4)\n\n{\n  int updatedIndex;\n  long stabsIndexOffset;\n  undefined8 duplicatedString;\n  \n  stabsIndexOffset = (long)currentIndex * 0x18;\n  free(*(void **)(stabsArray + stabsIndexOffset + 0x10));\n  *(undefined4 *)(stabsArray + stabsIndexOffset) = newValue1;\n  *(undefined4 *)(stabsArray + stabsIndexOffset + 4) = newValue2;\n  *(undefined8 *)(stabsArray + stabsIndexOffset + 8) = newValue3;\n  duplicatedString = xstrdup(newValue4);\n  *(undefined8 *)(stabsArray + stabsIndexOffset + 0x10) = duplicatedString;\n  updatedIndex = currentIndex + 1;\n  currentIndex = updatedIndex % 0x10;\n  return (long)updatedIndex / 0x10 & 0xffffffff;\n}\n\n",
            "called": [
                "xstrdup",
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001088ae",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "update_saved_stabs_001088ae"
        },
        "FUN_001042c0": {
            "renaming": {},
            "code": "\n\n\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strrchr(__s,__c);\n  return pcVar1;\n}\n\n",
            "called": [
                "strrchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001042c0",
            "calling": [
                "template_in_dir"
            ],
            "imported": false,
            "current_name": "FUN_001042c0"
        },
        "FUN_001041a0": {
            "renaming": {},
            "code": "\nvoid filename_cmp(void)\n\n{\n  filename_cmp();\n  return;\n}\n\n",
            "called": [
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001041a0",
            "calling": [
                "main",
                "debug_start_source",
                "stab_lineno.lto_priv.0"
            ],
            "imported": false,
            "current_name": "FUN_001041a0"
        },
        "FUN_0010afd5": {
            "renaming": {
                "FUN_0010afd5": "find_string_in_data_structure_0010afd5",
                "param_1": "ptrToDataStructure",
                "param_2": "dataStructureSize",
                "param_3": "stringToFind",
                "param_4": "stringLength",
                "param_5": "dataType",
                "param_6": "result",
                "iVar1": "comparisonResult",
                "__s2": "stringCopy",
                "puVar2": "ptrToNode",
                "uVar3": "indirectType",
                "lVar4": "nodeValue",
                "puVar5": "ptrToNextNode",
                "puVar6": "ptrToDataField",
                "bVar7": "counter",
                "auVar8": "returnValue"
            },
            "code": "\nundefined  [16]\nfindStringInDataStructure_0010afd5(undefined8 *ptrToDataStructure,long dataStructureSize,undefined8 stringToFind,undefined4 stringLength,\n            undefined4 dataType,undefined8 result)\n\n{\n  int comparisonResult;\n  char *stringCopy;\n  undefined8 *ptrToNode;\n  undefined8 indirectType;\n  long nodeValue;\n  undefined8 *ptrToNextNode;\n  undefined4 *ptrToDataField;\n  byte counter;\n  undefined returnValue [16];\n  \n  counter = 0;\n  stringCopy = (char *)savestring(stringToFind,stringLength);\n  for (ptrToDataStructure = (undefined8 *)*ptrToDataStructure; ptrToDataStructure != (undefined8 *)0x0;\n      ptrToDataStructure = (undefined8 *)*ptrToDataStructure) {\n    for (ptrToNode = (undefined8 *)ptrToDataStructure[1]; ptrToNode != (undefined8 *)0x0;\n        ptrToNode = (undefined8 *)*ptrToNode) {\n      if ((undefined8 *)ptrToNode[2] != (undefined8 *)0x0) {\n        for (ptrToNextNode = *(undefined8 **)(undefined8 *)ptrToNode[2]; ptrToNextNode != (undefined8 *)0x0;\n            ptrToNextNode = (undefined8 *)*ptrToNextNode) {\n          if ((*(int *)((long)ptrToNextNode + 0x14) == 1) && (*(char *)ptrToNextNode[1] == *stringCopy)) {\n            comparisonResult = strcmp((char *)ptrToNextNode[1],stringCopy);\n            if (comparisonResult == 0) {\n              nodeValue = ptrToNextNode[4];\n              if (nodeValue == 0) goto LAB_0010b05b;\n              free(stringCopy);\n              goto LAB_0010b0eb;\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010b05b:\n  ptrToNode = *(undefined8 **)(dataStructureSize + 0x1a0);\n  do {\n    if (ptrToNode == (undefined8 *)0x0) {\n      ptrToNode = (undefined8 *)xmalloc(0x28);\n      indirectType = *(undefined8 *)(dataStructureSize + 0x1a0);\n      ptrToDataField = (undefined4 *)((long)ptrToNode + 0x14);\n      for (nodeValue = 5; nodeValue != 0; nodeValue = nodeValue + -1) {\n        *ptrToDataField = 0;\n        ptrToDataField = ptrToDataField + (ulong)counter * -2 + 1;\n      }\n      *(undefined4 *)(ptrToNode + 2) = dataType;\n      *ptrToNode = indirectType;\n      ptrToNode[1] = stringCopy;\n      indirectType = debug_make_indirect_type_isra_0(ptrToNode + 3,stringCopy);\n      *(undefined8 **)(dataStructureSize + 0x1a0) = ptrToNode;\n      ptrToNode[4] = indirectType;\nLAB_0010b0e7:\n      nodeValue = ptrToNode[4];\nLAB_0010b0eb:\n      returnValue._8_8_ = result;\n      returnValue._0_8_ = nodeValue;\n      return returnValue;\n    }\n    if (*(char *)ptrToNode[1] == *stringCopy) {\n      comparisonResult = strcmp((char *)ptrToNode[1],stringCopy);\n      if (comparisonResult == 0) {\n        if (*(int *)(ptrToNode + 2) == 0) {\n          *(undefined4 *)(ptrToNode + 2) = dataType;\n        }\n        free(stringCopy);\n        goto LAB_0010b0e7;\n      }\n    }\n    ptrToNode = (undefined8 *)*ptrToNode;\n  } while( true );\n}\n\n",
            "called": [
                "free",
                "debug_make_indirect_type.isra.0",
                "savestring",
                "xmalloc",
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010afd5",
            "calling": [
                "stab_demangle_v3_arg",
                "parse_stab_type",
                "stab_demangle_qualified",
                "stab_demangle_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "find_string_in_data_structure_0010afd5"
        },
        "FUN_001043e0": {
            "renaming": {},
            "code": "\n\n\nsize_t strspn(char *__s,char *__accept)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strspn(__s,__accept);\n  return sVar1;\n}\n\n",
            "called": [
                "strspn"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043e0",
            "calling": [
                "parse_stab_type"
            ],
            "imported": false,
            "current_name": "FUN_001043e0"
        },
        "FUN_0010ee3f": {
            "renaming": {
                "FUN_0010ee3f": "FUNC_0010ee3f"
            },
            "code": "\n\n\nvoid * FUNC_0010ee3f(undefined8 param_1,long param_2,char *param_3,byte **param_4,undefined8 *param_5\n                   ,byte *param_6)\n\n{\n  byte bVar1;\n  byte bVar2;\n  byte *pbVar3;\n  long lVar4;\n  byte *pbVar5;\n  char cVar6;\n  byte bVar7;\n  char cVar8;\n  byte bVar9;\n  int iVar10;\n  undefined4 uVar11;\n  uint uVar12;\n  undefined4 uVar13;\n  int iVar14;\n  undefined8 uVar15;\n  char *pcVar16;\n  void *pvVar17;\n  void **ppvVar18;\n  long lVar19;\n  long lVar20;\n  int *piVar21;\n  undefined *puVar22;\n  char **ppcVar23;\n  void *pvVar24;\n  void *pvVar25;\n  ulong uVar26;\n  byte *pbVar27;\n  byte *pbVar28;\n  char *pcVar29;\n  size_t sVar30;\n  byte *pbVar31;\n  undefined8 *puVar32;\n  size_t sVar33;\n  byte **ppbVar34;\n  void **ppvVar35;\n  undefined8 uVar36;\n  undefined8 uVar37;\n  long lVar38;\n  long *plVar39;\n  char *pcVar40;\n  bool bVar41;\n  byte *pbVar42;\n  char cVar43;\n  undefined uVar44;\n  ulong uVar45;\n  char *pcVar46;\n  byte bVar47;\n  byte bVar48;\n  ulong uVar49;\n  byte *pbVar50;\n  bool bVar51;\n  bool bVar52;\n  undefined auVar53 [16];\n  undefined auVar54 [16];\n  void *local_158;\n  char *local_150;\n  byte *local_140;\n  char local_138;\n  char local_130;\n  uint local_12c;\n  char *local_128;\n  byte *local_120;\n  void *local_118;\n  byte *local_110;\n  undefined4 local_100;\n  uint local_fc;\n  uint local_f0;\n  uint local_ec;\n  uint local_e0;\n  int local_d0;\n  char local_a9;\n  undefined8 local_a8;\n  byte *local_a0;\n  undefined8 local_98;\n  long local_90;\n  long local_88;\n  char local_80;\n  undefined7 uStack_7f;\n  void *local_78;\n  undefined4 local_70;\n  int local_6c;\n  void *local_68;\n  int local_5c;\n  \n  bVar48 = 0;\n  if (param_5 != (undefined8 *)0x0) {\n    *param_5 = 0;\n  }\n  pbVar3 = *param_4;\n  if (param_6 <= pbVar3) {\n    return (void *)0x0;\n  }\n  *(undefined *)(param_2 + 0x1a8) = 0;\n  bVar9 = *pbVar3;\n  if (((bVar9 != 0x28 && bVar9 != 0x2d) &\n      ((byte)(*(ushort *)(&_sch_istable + (ulong)bVar9 * 2) >> 2) ^ 1)) == 0) {\n    cVar6 = parse_stab_type_number(param_4,&local_a8,param_6);\n    if (cVar6 == '\\0') {\n      return (void *)0x0;\n    }\n    if (**param_4 != 0x3d) {\n      pvVar17 = (void *)stab_find_type(param_1,param_2,&local_a8);\n      return pvVar17;\n    }\n    if (param_5 != (undefined8 *)0x0) {\n      if (-1 < (int)((uint)local_a8 | local_a8._4_4_)) {\n        uVar15 = stab_find_slot(param_2);\n        *param_5 = uVar15;\n      }\n    }\n    *param_4 = *param_4 + 1;\n    local_12c = 0xffffffff;\n    cVar8 = '\\0';\n    do {\n      while( true ) {\n        do {\n          cVar43 = cVar8;\n          pbVar27 = *param_4;\n          if (((*pbVar27 != 0x40) ||\n              (bVar9 = pbVar27[1], ((&_sch_istable)[(ulong)bVar9 * 2] & 4) != 0)) ||\n             (pbVar50 = pbVar27, bVar9 == 0x28 || bVar9 == 0x2d)) goto LAB_0010efe0;\n          while( true ) {\n            bVar9 = pbVar50[1];\n            if (bVar9 == 0x3b) break;\n            pbVar50 = pbVar50 + 1;\n            if (bVar9 == 0) goto switchD_0010f055_caseD_24;\n          }\n          *param_4 = pbVar50 + 2;\n          bVar9 = pbVar27[1];\n          cVar8 = cVar6;\n        } while (bVar9 == 0x53);\n        cVar8 = cVar43;\n        if (bVar9 != 0x73) break;\n        lVar38 = strtol((char *)(pbVar27 + 2),(char **)0x0,10);\n        local_12c = 0xffffffff;\n        if (7 < (int)lVar38) {\n          local_12c = (int)lVar38 >> 3;\n        }\n      }\n    } while (bVar9 != 0);\n    goto switchD_0010f055_caseD_24;\n  }\n  local_12c = 0xffffffff;\n  cVar43 = '\\0';\n  local_a8 = 0xffffffffffffffff;\nLAB_0010efe0:\n  pbVar50 = *param_4;\n  bVar9 = *pbVar50;\n  pbVar27 = pbVar50 + 1;\n  *param_4 = pbVar27;\n  if ('x' < (char)bVar9) goto switchD_0010f055_caseD_24;\n  if ((char)bVar9 < 'a') {\n    if (bVar9 == 0x40) {\n      lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      if (lVar38 == 0) {\n        return (void *)0x0;\n      }\n      if (**param_4 != 0x2c) goto switchD_0010f055_caseD_24;\n      *param_4 = *param_4 + 1;\n      lVar19 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      if (lVar19 == 0) {\n        return (void *)0x0;\n      }\n      pvVar17 = (void *)debug_make_offset_type_isra_0(lVar38,lVar19);\n    }\n    else if ((char)bVar9 < 'A') {\n      if ('-' < (char)bVar9) {\n        if (9 < (byte)(bVar9 - 0x30)) goto switchD_0010f055_caseD_24;\nswitchD_0010f055_caseD_28:\n        *param_4 = pbVar50;\n        cVar6 = parse_stab_type_number(param_4,&local_98,param_6);\n        if (cVar6 == '\\0') {\n          return (void *)0x0;\n        }\n        iVar10 = (uint)local_a8;\n        if ((uint)local_a8 == (uint)local_98) {\n          if (local_a8._4_4_ == local_98._4_4_) {\n            pvVar17 = (void *)debug_make_void_type_isra_0();\n            if (iVar10 != -1) {\n              ppvVar18 = (void **)stab_find_slot(param_2,&local_a8);\n              if (ppvVar18 == (void **)0x0) {\n                return (void *)0x0;\n              }\n              *ppvVar18 = pvVar17;\n            }\n            goto LAB_001115e2;\n          }\n        }\n        *param_4 = pbVar50;\n        pvVar17 = (void *)FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n        if (pvVar17 == (void *)0x0) {\n          return (void *)0x0;\n        }\n        if (iVar10 != -1) {\n          ppvVar18 = (void **)stab_find_slot(param_2,&local_a8);\n          if (ppvVar18 == (void **)0x0) {\n            return (void *)0x0;\n          }\n          *ppvVar18 = pvVar17;\n        }\n        goto LAB_001115eb;\n      }\n      if ((char)bVar9 < '#') goto switchD_0010f055_caseD_24;\n      switch(bVar9) {\n      case 0x23:\n        if (pbVar50[1] == 0x23) {\n          *param_4 = pbVar50 + 2;\n          lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n          if (lVar38 == 0) {\n            return (void *)0x0;\n          }\n          if (**param_4 != 0x3b) goto switchD_0010f055_caseD_24;\n          *param_4 = *param_4 + 1;\n          pvVar17 = (void *)debug_make_method_type_isra_0(lVar38,0,0,0);\n        }\n        else {\n          lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n          if (lVar38 == 0) {\n            return (void *)0x0;\n          }\n          if (**param_4 != 0x2c) goto switchD_0010f055_caseD_24;\n          *param_4 = *param_4 + 1;\n          lVar19 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n          if (lVar19 == 0) {\n            return (void *)0x0;\n          }\n          uVar45 = 10;\n          uVar49 = 0;\n          auVar53 = xmalloc(0x50);\n          while( true ) {\n            lVar20 = auVar53._0_8_;\n            pbVar27 = *param_4;\n            iVar10 = (int)uVar49;\n            if (*pbVar27 == 0x3b) break;\n            if (*pbVar27 != 0x2c) {\n              bad_stab(pbVar3);\n              return (void *)0x0;\n            }\n            *param_4 = pbVar27 + 1;\n            if ((uint)uVar45 <= iVar10 + 1U) {\n              uVar45 = (ulong)((uint)uVar45 + 10);\n              lVar20 = xrealloc(lVar20,uVar45 << 3);\n            }\n            auVar54 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n            auVar53._8_8_ = auVar54._8_8_;\n            auVar53._0_8_ = lVar20;\n            *(long *)(lVar20 + uVar49 * 8) = auVar54._0_8_;\n            if (auVar54._0_8_ == 0) {\n              return (void *)0x0;\n            }\n            uVar49 = (ulong)(iVar10 + 1U);\n          }\n          uVar15 = 1;\n          *param_4 = pbVar27 + 1;\n          uVar45 = uVar49;\n          if (iVar10 != 0) {\n            uVar45 = (ulong)(iVar10 - 1);\n            lVar4 = *(long *)(lVar20 + uVar45 * 8);\n            if (((lVar4 == 0) ||\n                (piVar21 = (int *)debug_get_real_type_isra_0(lVar4,0,0x3b,1), piVar21 == (int *)0x0)\n                ) || (*piVar21 != 2)) {\n              uVar15 = 1;\n              uVar45 = uVar49;\n            }\n            else {\n              uVar15 = 0;\n            }\n          }\n          *(undefined8 *)(lVar20 + uVar45 * 8) = 0;\n          pvVar17 = (void *)debug_make_method_type_isra_0(lVar19,lVar38,lVar20,uVar15);\n        }\n        break;\n      default:\n        goto switchD_0010f055_caseD_24;\n      case 0x26:\n        uVar15 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n        pvVar17 = (void *)debug_make_reference_type_isra_0(uVar15);\n        break;\n      case 0x28:\n      case 0x2d:\n        goto switchD_0010f055_caseD_28;\n      case 0x2a:\n        uVar15 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n        pvVar17 = (void *)debug_make_pointer_type_isra_0(uVar15);\n      }\n    }\n    else if (bVar9 == 0x52) {\n      if (param_6 <= pbVar27) {\n        return (void *)0x0;\n      }\n      lVar38 = parse_number(param_4,0,param_6);\n      if ((**param_4 != 0x3b) || (uVar11 = parse_number(param_4,0,param_6), **param_4 != 0x3b))\n      goto LAB_0010fb4c;\n      if (lVar38 - 3U < 3) {\n        pvVar17 = (void *)debug_make_type_constprop_0(5);\n      }\n      else {\n        pvVar17 = (void *)debug_make_float_type_isra_0(uVar11);\n      }\n    }\n    else {\n      if (bVar9 == 0x53) {\n        lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n        if (lVar38 == 0) {\n          return (void *)0x0;\n        }\n        pvVar17 = (void *)debug_make_type_constprop_0(0x11,0);\n        if (pvVar17 == (void *)0x0) {\n          return (void *)0x0;\n        }\n        plVar39 = (long *)xmalloc(0x10);\n        *(undefined4 *)((long)plVar39 + 9) = 0;\n        *plVar39 = lVar38;\n        *(undefined4 *)((long)plVar39 + 0xc) = 0;\n        *(char *)(plVar39 + 1) = cVar43;\n        *(long **)((long)pvVar17 + 0x10) = plVar39;\n        goto LAB_001115eb;\n      }\n      if (bVar9 != 0x42) goto switchD_0010f055_caseD_24;\n      uVar15 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      pvVar17 = (void *)debug_make_volatile_type_isra_0(uVar15);\n    }\n  }\n  else {\n    switch(bVar9) {\n    case 0x61:\n      if (pbVar50[1] != 0x72) goto switchD_0010f055_caseD_24;\n      pbVar50 = pbVar50 + 2;\n      *param_4 = pbVar50;\n      if (param_6 <= pbVar50) {\n        return (void *)0x0;\n      }\n      local_a0 = pbVar50;\n      cVar6 = parse_stab_type_number(&local_a0,&local_98,param_6);\n      if (cVar6 == '\\0') {\n        return (void *)0x0;\n      }\n      if ((((uint)local_98 | local_98._4_4_) == 0) && (**param_4 != 0x3d)) {\n        lVar38 = debug_find_named_type(param_1,\"int\");\n        if ((lVar38 == 0) && (lVar38 = debug_make_int_type_isra_0(4,0), lVar38 == 0)) {\n          return (void *)0x0;\n        }\n        *param_4 = local_a0;\n      }\n      else {\n        lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      }\n      pbVar3 = *param_4;\n      if (*pbVar3 != 0x3b) {\nLAB_0011151b:\n        bad_stab(pbVar50);\n        return (void *)0x0;\n      }\n      *param_4 = pbVar3 + 1;\n      bVar48 = pbVar3[1];\n      bVar48 = (bVar48 != 0x2d && bVar48 != 0) &\n               ((byte)(*(ushort *)(&_sch_istable + (ulong)bVar48 * 2) >> 2) ^ 1);\n      if (bVar48 != 0) {\n        *param_4 = pbVar3 + 2;\n      }\n      uVar15 = parse_number(param_4,0,param_6);\n      pbVar3 = *param_4;\n      if (*pbVar3 != 0x3b) goto LAB_0011151b;\n      *param_4 = pbVar3 + 1;\n      bVar9 = pbVar3[1];\n      bVar9 = (bVar9 != 0x2d && bVar9 != 0) &\n              ((byte)(*(ushort *)(&_sch_istable + (ulong)bVar9 * 2) >> 2) ^ 1);\n      if (bVar9 != 0) {\n        *param_4 = pbVar3 + 2;\n        bVar48 = bVar9;\n      }\n      uVar36 = parse_number(param_4,0,param_6);\n      if (**param_4 != 0x3b) goto LAB_0011151b;\n      *param_4 = *param_4 + 1;\n      lVar19 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      if (lVar19 == 0) {\n        return (void *)0x0;\n      }\n      if (bVar48 != 0) {\n        uVar15 = 0;\n      }\n      uVar37 = 0xffffffffffffffff;\n      if (bVar48 == 0) {\n        uVar37 = uVar36;\n      }\n      pvVar17 = (void *)debug_make_array_type_isra_0(lVar19,lVar38,uVar15,uVar37,cVar43);\n      break;\n    case 0x62:\n      if (param_6 <= pbVar27) {\n        return (void *)0x0;\n      }\n      if (pbVar50[1] == 0x73) {\n        uVar44 = 0;\n      }\n      else {\n        if (pbVar50[1] != 0x75) goto LAB_0010fb4c;\n        uVar44 = 1;\n      }\n      *param_4 = pbVar50 + 2;\n      if (((byte)(pbVar50[2] + 0x9e) < 2) || (pbVar50[2] == 0x76)) {\n        *param_4 = pbVar50 + 3;\n      }\n      parse_number(param_4,0,param_6);\n      if (**param_4 != 0x3b) goto LAB_0010fb4c;\n      *param_4 = *param_4 + 1;\n      parse_number(param_4,0,param_6);\n      if (**param_4 != 0x3b) goto LAB_0010fb4c;\n      *param_4 = *param_4 + 1;\n      uVar49 = parse_number(param_4,0,param_6);\n      if (**param_4 == 0x3b) {\n        *param_4 = *param_4 + 1;\n      }\n      if (uVar49 != 0) {\n        pvVar17 = (void *)debug_make_int_type_isra_0(uVar49 >> 3 & 0xffffffff,uVar44);\n        break;\n      }\nLAB_0010fa8f:\n      pvVar17 = (void *)debug_make_void_type_isra_0();\n      break;\n    default:\n      goto switchD_0010f055_caseD_24;\n    case 0x65:\n      if (param_6 <= pbVar27) {\n        return (void *)0x0;\n      }\n      if (pbVar50[1] == 0x2d) {\n        while( true ) {\n          pbVar3 = *param_4;\n          if (*pbVar3 == 0x3a) break;\n          if (*pbVar3 == 0) goto LAB_0010fb4c;\n          *param_4 = pbVar3 + 1;\n        }\n        *param_4 = pbVar3 + 1;\n      }\n      uVar45 = 10;\n      pvVar17 = (void *)xmalloc(0x50);\n      pvVar24 = (void *)xmalloc(0x50);\n      uVar49 = 0;\n      while( true ) {\n        pbVar3 = *param_4;\n        pbVar50 = pbVar3;\n        if ((*pbVar3 < 0x3c) && ((-0x800100000000002 >> (*pbVar3 & 0x3f) & 1U) == 0)) break;\n        for (; *pbVar50 != 0x3a; pbVar50 = pbVar50 + 1) {\n          if (*pbVar50 == 0) {\n            bad_stab(pbVar27);\n            free(pvVar17);\n            free(pvVar24);\n            return (void *)0x0;\n          }\n        }\n        pvVar25 = (void *)savestring(pbVar3,(int)pbVar50 - (int)pbVar3);\n        *param_4 = pbVar50 + 1;\n        uVar15 = parse_number(param_4,0,param_6);\n        if (**param_4 != 0x2c) {\n          bad_stab(pbVar27);\n          free(pvVar25);\n          free(pvVar17);\n          free(pvVar24);\n          return (void *)0x0;\n        }\n        uVar12 = (int)uVar49 + 1;\n        *param_4 = *param_4 + 1;\n        if ((uint)uVar45 <= uVar12) {\n          uVar45 = (ulong)((uint)uVar45 + 10);\n          pvVar17 = (void *)xrealloc(pvVar17,uVar45 << 3);\n          pvVar24 = (void *)xrealloc(pvVar24,uVar45 << 3);\n        }\n        *(void **)((long)pvVar17 + uVar49 * 8) = pvVar25;\n        *(undefined8 *)((long)pvVar24 + uVar49 * 8) = uVar15;\n        uVar49 = (ulong)uVar12;\n      }\n      *(undefined8 *)((long)pvVar17 + uVar49 * 8) = 0;\n      *(undefined8 *)((long)pvVar24 + uVar49 * 8) = 0;\n      if (**param_4 == 0x3b) {\n        *param_4 = *param_4 + 1;\n      }\n      pvVar17 = (void *)debug_make_enum_type_isra_0(pvVar17,pvVar24);\n      break;\n    case 0x66:\n      uVar15 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      pvVar17 = (void *)debug_make_function_type_isra_0(uVar15,0,0);\n      break;\n    case 0x6b:\n      uVar15 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      pvVar17 = (void *)debug_make_const_type_isra_0(uVar15);\n      break;\n    case 0x72:\n      if (param_6 <= pbVar27) {\n        return (void *)0x0;\n      }\n      cVar6 = parse_stab_type_number(param_4,&local_98,param_6);\n      if (cVar6 == '\\0') {\n        return (void *)0x0;\n      }\n      bVar51 = false;\n      if ((uint)local_98 == (uint)local_a8) {\n        bVar51 = local_98._4_4_ == local_a8._4_4_;\n      }\n      lVar38 = 0;\n      if (**param_4 == 0x3d) {\n        *param_4 = pbVar27;\n        lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n        if (lVar38 == 0) {\n          return (void *)0x0;\n        }\n      }\n      if (**param_4 == 0x3b) {\n        *param_4 = *param_4 + 1;\n      }\n      pbVar3 = *param_4;\n      uVar49 = parse_number(param_4,&local_a9,param_6);\n      if (**param_4 != 0x3b) goto LAB_0010fb4c;\n      pbVar50 = *param_4 + 1;\n      *param_4 = pbVar50;\n      uVar45 = parse_number(param_4,&local_a0,param_6);\n      cVar6 = local_a9;\n      if (**param_4 != 0x3b) goto LAB_0010fb4c;\n      *param_4 = *param_4 + 1;\n      if ((local_a9 == '\\0') && ((char)local_a0 == '\\0')) {\nLAB_0010f700:\n        if (lVar38 != 0) goto LAB_0010f956;\n        if ((!bVar51) || (uVar49 != 0)) {\n          bVar52 = uVar45 != 0;\n          if ((!bVar51) || (bVar52)) {\n            if (((long)uVar49 < 1) || (bVar52)) {\n              if ((uVar45 == 0xffffffffffffffff) && (uVar49 == 0)) goto LAB_0010f788;\n              if (uVar49 == 0) goto LAB_0010f829;\n              if ((-1 < (long)uVar49) || (bVar52)) goto LAB_0010f8cd;\n              if ((uVar49 == 0xfffffffffffffff8) || (bVar51)) goto LAB_0010f89d;\n              if (uVar49 != 0xffffffffffffffff) {\n                if (uVar49 != 1) goto LAB_0010f956;\n                goto LAB_0010f8eb;\n              }\nLAB_0010f8ff:\n              if (uVar45 == 0x7f) goto LAB_0010f810;\n              if (uVar45 == 0x7fff) {\nLAB_0010f912:\n                pvVar17 = (void *)debug_make_int_type_isra_0(2,0);\n              }\n              else {\n                if (uVar45 != 0x7fffffff) {\n                  if (uVar45 == 0x7fffffffffffffff) goto LAB_0010f7a5;\n                  goto LAB_0010f956;\n                }\nLAB_0010f92f:\n                pvVar17 = (void *)debug_make_int_type_isra_0(4,0);\n              }\n            }\n            else {\n              pvVar17 = (void *)debug_make_float_type_isra_0(uVar49 & 0xffffffff);\n            }\n          }\n          else if ((long)uVar49 < 1) {\n            if (-1 < (long)uVar49) {\nLAB_0010f8cd:\n              if (uVar49 == ~uVar45) goto LAB_0010f8ff;\n              if (uVar49 == uVar45 + 1) {\n                if (uVar45 == 0x7f) goto LAB_0010f810;\nLAB_0010f8eb:\n                if (uVar45 == 0x7fff) goto LAB_0010f912;\n                if (uVar45 == 0x7fffffff) goto LAB_0010f92f;\n              }\nLAB_0010f956:\n              if (bVar51) {\nLAB_0010fb4c:\n                bad_stab(pbVar27);\n                return (void *)0x0;\n              }\n              lVar38 = stab_find_type(param_1,param_2,&local_98);\n              if (lVar38 == 0) {\n                uVar15 = dcgettext(0,\"missing index type\",5);\n                warn_stab(pbVar27,uVar15);\n                lVar38 = debug_make_int_type_isra_0(4,0);\n                if (lVar38 == 0) {\n                  return (void *)0x0;\n                }\n              }\n              pvVar17 = (void *)debug_make_type_constprop_0(0xf,0);\n              if (pvVar17 == (void *)0x0) {\n                return (void *)0x0;\n              }\n              plVar39 = (long *)xmalloc(0x18);\n              *plVar39 = lVar38;\n              plVar39[1] = uVar49;\n              plVar39[2] = uVar45;\n              *(long **)((long)pvVar17 + 0x10) = plVar39;\n              goto LAB_001115eb;\n            }\nLAB_0010f89d:\n            pvVar17 = (void *)debug_make_int_type_isra_0(-(int)uVar49,1);\n          }\n          else {\n            pvVar17 = (void *)debug_make_type_constprop_0(5,uVar49 & 0xffffffff);\n          }\n        }\n        else {\n          if (uVar45 == 0) goto LAB_0010fa8f;\n          if (uVar45 == 0xffffffffffffffff) {\nLAB_0010f788:\n            if (param_3 != (char *)0x0) {\n              iVar10 = strcmp(param_3,\"long long int\");\n              if (iVar10 == 0) goto LAB_0010f7a5;\n              iVar10 = strcmp(param_3,\"long long unsigned int\");\n              if (iVar10 == 0) goto LAB_0010f7ce;\n            }\nLAB_0010f7f3:\n            pvVar17 = (void *)debug_make_int_type_isra_0(4,1);\n          }\n          else if (uVar45 == 0x7f) {\nLAB_0010f810:\n            pvVar17 = (void *)debug_make_int_type_isra_0(1,0);\n          }\n          else {\nLAB_0010f829:\n            if ((long)uVar45 < 0) {\n              pvVar17 = (void *)debug_make_int_type_isra_0(-(int)uVar45,1);\n            }\n            else if (uVar45 == 0xff) {\n              pvVar17 = (void *)debug_make_int_type_isra_0(1,1);\n            }\n            else {\n              if (uVar45 != 0xffff) {\n                if (uVar45 != 0xffffffff) goto LAB_0010f956;\n                goto LAB_0010f7f3;\n              }\n              pvVar17 = (void *)debug_make_int_type_isra_0(2,1);\n            }\n          }\n        }\n      }\n      else {\n        if (lVar38 != 0) {\nLAB_0010f6e2:\n          uVar15 = dcgettext(0,\"numeric overflow\",5);\n          warn_stab(pbVar27,uVar15);\n          goto LAB_0010f700;\n        }\n        cVar8 = startswith_lto_priv_0_lto_priv_0(pbVar3,\"01000000000000000000000;\");\n        if ((cVar8 == '\\0') ||\n           (cVar8 = startswith_lto_priv_0_lto_priv_0(pbVar50,\"0777777777777777777777;\"),\n           cVar8 == '\\0')) {\n          if ((cVar6 == '\\x01') ||\n             ((uVar49 != 0 ||\n              (cVar6 = startswith_lto_priv_0_lto_priv_0(pbVar50,\"01777777777777777777777;\"),\n              cVar6 == '\\0')))) goto LAB_0010f6e2;\nLAB_0010f7ce:\n          pvVar17 = (void *)debug_make_int_type_isra_0(8,1);\n        }\n        else {\nLAB_0010f7a5:\n          pvVar17 = (void *)debug_make_int_type_isra_0(8,0);\n        }\n      }\n      break;\n    case 0x73:\n    case 0x75:\n      uVar49 = parse_number(param_4,0,param_6);\n      pbVar3 = *param_4;\n      if (pbVar3 < param_6) {\n        local_118 = (void *)0x0;\n        if (*pbVar3 == 0x21) {\n          *param_4 = pbVar3 + 1;\n          uVar12 = parse_number(param_4,0,param_6);\n          if (**param_4 != 0x2c) {\nLAB_0010fe26:\n            bad_stab(pbVar3);\n            goto LAB_0010fe2e;\n          }\n          *param_4 = *param_4 + 1;\n          lVar38 = 0;\n          local_118 = (void *)xmalloc();\n          while ((uint)lVar38 < uVar12) {\n            bVar1 = **param_4;\n            if (bVar1 == 0x30) {\nLAB_0010fe06:\n              uVar44 = 0;\n            }\n            else {\n              if (bVar1 != 0x31) {\n                if (bVar1 != 0) {\n                  uVar15 = dcgettext(0,\"unknown virtual character for baseclass\",5);\n                  warn_stab(pbVar3,uVar15);\n                  goto LAB_0010fe06;\n                }\n                goto LAB_0010fe26;\n              }\n              uVar44 = 1;\n            }\n            pbVar27 = *param_4;\n            *param_4 = pbVar27 + 1;\n            bVar1 = pbVar27[1];\n            if (bVar1 == 0x31) {\n              uVar11 = 1;\n            }\n            else {\n              if ((char)bVar1 < '2') {\n                if (bVar1 == 0) goto LAB_0010fe26;\n                uVar11 = 2;\n                if (bVar1 == 0x30) goto LAB_0010fd53;\nLAB_0010fe6c:\n                uVar15 = dcgettext(0,\"unknown visibility character for baseclass\",5);\n                warn_stab(pbVar3,uVar15);\n              }\n              else if (bVar1 != 0x32) goto LAB_0010fe6c;\n              uVar11 = 0;\n            }\nLAB_0010fd53:\n            *param_4 = *param_4 + 1;\n            uVar13 = parse_number(param_4,0,param_6);\n            if (**param_4 != 0x2c) goto LAB_0010fe26;\n            *param_4 = *param_4 + 1;\n            lVar19 = FUNC_0010ee3f(param_1,param_2,0,param_4);\n            if (lVar19 == 0) goto LAB_0010fe2e;\n            plVar39 = (long *)xmalloc();\n            *(undefined8 *)((long)plVar39 + 0xd) = 0;\n            *(undefined4 *)(plVar39 + 1) = uVar13;\n            *(undefined4 *)((long)plVar39 + 0x14) = 0;\n            *plVar39 = lVar19;\n            *(long **)((long)local_118 + lVar38 * 8) = plVar39;\n            lVar38 = lVar38 + 1;\n            *(undefined *)((long)plVar39 + 0xc) = uVar44;\n            *(undefined4 *)(plVar39 + 2) = uVar11;\n            if (**param_4 != 0x3b) goto LAB_0010fe2e;\n            *param_4 = *param_4 + 1;\n          }\n          *(undefined8 *)((long)local_118 + lVar38 * 8) = 0;\n        }\n        pbVar3 = *param_4;\n        if (pbVar3 < param_6) {\n          uVar45 = 0;\n          local_158 = (void *)xmalloc(0x50);\n          bVar51 = false;\n          local_150._0_4_ = 10;\n          while (pbVar27 = *param_4, *pbVar27 != 0x3b) {\n            uVar12 = (int)uVar45 + 1;\n            if ((uint)local_150 <= uVar12) {\n              local_150._0_4_ = (uint)local_150 + 10;\n              local_158 = (void *)xrealloc(local_158);\n            }\n            if (((*pbVar27 == 0x24) || (*pbVar27 == 0x2e)) && (pbVar27[1] != 0x5f)) {\n              *param_4 = *param_4 + 1;\n              plVar39 = (long *)((long)local_158 + uVar45 * 8);\n              *plVar39 = 0;\n              pbVar27 = *param_4;\n              if (pbVar27 < param_6) {\n                if (*pbVar27 == 0x76) {\n                  *param_4 = pbVar27 + 1;\n                  bVar1 = pbVar27[1];\n                  if (bVar1 != 0) {\n                    *param_4 = pbVar27 + 2;\n                    lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n                    if (lVar38 == 0) goto LAB_001102dc;\n                    if (bVar1 == 0x62) {\n                      puVar22 = (undefined *)debug_get_type_name_constprop_0();\n                      if (puVar22 == (undefined *)0x0) {\n                        uVar15 = dcgettext(0,\"unnamed $vb type\",5);\n                        warn_stab(pbVar27,uVar15);\n                        puVar22 = &DAT_001206ea;\n                      }\n                      pcVar40 = (char *)concat(&DAT_0012077e,puVar22,0);\n                    }\n                    else {\n                      pcVar40 = \"_vptr$\";\n                      if (bVar1 != 0x66) {\n                        uVar15 = dcgettext(0,\"unrecognized C++ abbreviation\",5);\n                        pcVar40 = \"INVALID_CPLUSPLUS_ABBREV\";\n                        warn_stab(pbVar27,uVar15);\n                      }\n                    }\n                    if (**param_4 == 0x3a) {\n                      *param_4 = *param_4 + 1;\n                      pcVar16 = (char *)FUNC_0010ee3f(param_1,param_2,0);\n                      if (**param_4 == 0x2c) {\n                        *param_4 = *param_4 + 1;\n                        uVar11 = parse_number(param_4,0,param_6);\n                        if (**param_4 == 0x3b) {\n                          *param_4 = *param_4 + 1;\n                          ppcVar23 = (char **)xmalloc(0x20);\n                          *(undefined8 *)((long)ppcVar23 + 0x14) = 0;\n                          *(undefined4 *)((long)ppcVar23 + 0x1c) = 0;\n                          *ppcVar23 = pcVar40;\n                          ppcVar23[1] = pcVar16;\n                          *(undefined4 *)(ppcVar23 + 3) = uVar11;\n                          *(undefined4 *)(ppcVar23 + 2) = 2;\n                          *plVar39 = (long)ppcVar23;\n                          goto LAB_001102eb;\n                        }\n                      }\n                    }\n                  }\n                }\n                bad_stab(pbVar27);\n              }\nLAB_001102dc:\n              free(local_158);\n              goto LAB_0010fe2e;\n            }\n            pcVar40 = strchr((char *)pbVar27,0x3a);\n            if (pcVar40 == (char *)0x0) {\n              bad_stab(pbVar3);\n              free(local_158);\n              goto LAB_0010fe2e;\n            }\n            if (pcVar40[1] == ':') break;\n            pbVar27 = *param_4;\n            if (param_6 <= pbVar27) goto LAB_001102dc;\n            pvVar17 = (void *)savestring(pbVar27,(int)pcVar40 - (int)pbVar27);\n            *param_4 = (byte *)(pcVar40 + 1);\n            if (pcVar40[1] == '/') {\n              *param_4 = (byte *)(pcVar40 + 2);\n              cVar6 = pcVar40[2];\n              if (cVar6 == '1') {\n                uVar11 = 1;\n              }\n              else if (cVar6 < '2') {\n                if (cVar6 == '\\0') {\n                  bad_stab(pbVar27);\n                  goto LAB_001102dc;\n                }\n                uVar11 = 2;\n                if (cVar6 != '0') goto LAB_00110152;\n              }\n              else {\n                if (cVar6 != '2') {\nLAB_00110152:\n                  uVar15 = dcgettext(0,\"unknown visibility character for field\",5);\n                  warn_stab(pbVar27,uVar15);\n                }\n                uVar11 = 0;\n              }\n              *param_4 = *param_4 + 1;\n            }\n            else {\n              uVar11 = 0;\n            }\n            pvVar24 = (void *)FUNC_0010ee3f(param_1,param_2,0,param_4);\n            if (pvVar24 == (void *)0x0) {\nLAB_001101e1:\n              free(pvVar17);\n              goto LAB_001102dc;\n            }\n            puVar32 = (undefined8 *)((long)local_158 + uVar45 * 8);\n            pbVar50 = *param_4;\n            if (*pbVar50 != 0x3a) {\n              if (*pbVar50 == 0x2c) {\n                *param_4 = pbVar50 + 1;\n                uVar45 = parse_number(param_4,0,param_6);\n                if (**param_4 == 0x2c) {\n                  *param_4 = *param_4 + 1;\n                  uVar26 = parse_number(param_4,0,param_6);\n                  if (**param_4 == 0x3b) {\n                    *param_4 = *param_4 + 1;\n                    if ((uVar45 | uVar26) == 0) {\n                      uVar11 = 3;\n                    }\n                    ppvVar18 = (void **)xmalloc(0x20);\n                    *(undefined8 *)((long)ppvVar18 + 0x14) = 0;\n                    *ppvVar18 = pvVar17;\n                    ppvVar18[1] = pvVar24;\n                    *(int *)(ppvVar18 + 3) = (int)uVar45;\n                    *(int *)((long)ppvVar18 + 0x1c) = (int)uVar26;\n                    *(undefined4 *)(ppvVar18 + 2) = uVar11;\n                    *puVar32 = ppvVar18;\n                    goto LAB_001102eb;\n                  }\n                }\n              }\nLAB_001101d9:\n              bad_stab(pbVar27);\n              goto LAB_001101e1;\n            }\n            pbVar50 = pbVar50 + 1;\n            *param_4 = pbVar50;\n            pcVar40 = strchr((char *)pbVar50,0x3b);\n            if (pcVar40 == (char *)0x0) goto LAB_001101d9;\n            pvVar25 = (void *)savestring(pbVar50);\n            *param_4 = (byte *)(pcVar40 + 1);\n            ppvVar18 = (void **)xmalloc(0x20);\n            bVar51 = true;\n            *(undefined8 *)((long)ppvVar18 + 0x15) = 0;\n            *ppvVar18 = pvVar17;\n            ppvVar18[1] = pvVar24;\n            *(undefined *)((long)ppvVar18 + 0x14) = 1;\n            ppvVar18[3] = pvVar25;\n            *(undefined4 *)(ppvVar18 + 2) = uVar11;\n            *puVar32 = ppvVar18;\nLAB_001102eb:\n            uVar45 = (ulong)uVar12;\n          }\n          *(undefined8 *)((long)local_158 + uVar45 * 8) = 0;\n          pbVar3 = *param_4;\n          if (param_6 <= pbVar3) goto LAB_001112f3;\n          local_128 = (char *)0x0;\n          pbVar27 = (byte *)0x0;\n          pvVar24 = (void *)0x0;\n          local_150 = (char *)0x0;\n          local_e0 = 0;\n          local_fc = 0;\nLAB_00110345:\n          pbVar50 = *param_4;\n          bVar1 = *pbVar50;\n          if (((bVar1 != 0x3b) && (pcVar40 = strchr((char *)pbVar50,0x3a), pcVar40 != (char *)0x0))\n             && (pcVar40[1] == ':')) {\n            pbVar28 = (byte *)(pcVar40 + 2);\n            if (((bVar1 == 0x6f) && (pbVar50[1] == 0x70)) && (pbVar50[2] == 0x24)) {\n              *param_4 = pbVar28;\n              for (pbVar50 = pbVar28; *pbVar50 != 0x2e; pbVar50 = pbVar50 + 1) {\n                if (*pbVar50 == 0) goto LAB_00110788;\n              }\n              pbVar50 = pbVar50 + 1;\n              local_150 = (char *)savestring(pbVar28);\n            }\n            else {\n              local_150 = (char *)savestring(pbVar50);\n              pbVar50 = pbVar28;\n            }\n            *param_4 = pbVar50;\n            local_128 = (char *)xmalloc();\n            local_ec = 10;\n            local_140 = (byte *)0x0;\n            local_f0 = 0;\nLAB_00110406:\n            pbVar50 = local_140;\n            if (local_140 == (byte *)0x0) {\n              pbVar50 = (byte *)FUNC_0010ee3f(param_1,param_2,0);\n              if (pbVar50 == (byte *)0x0) goto LAB_001111e9;\n              if (**param_4 != 0x3a) goto LAB_00110788;\n            }\n            pbVar28 = *param_4;\n            *param_4 = pbVar28 + 1;\n            pcVar40 = strchr((char *)(pbVar28 + 1),0x3b);\n            if (pcVar40 == (char *)0x0) goto LAB_00110788;\n            piVar21 = (int *)debug_get_real_type_isra_0(pbVar50,0);\n            bVar52 = false;\n            if ((piVar21 != (int *)0x0) && (bVar52 = false, *piVar21 == 0x13)) {\n              bVar52 = true;\n              piVar21 = (int *)debug_get_real_type_isra_0(pbVar50,0);\n              if (piVar21 != (int *)0x0) {\n                if (*piVar21 == 0xd) {\n                  lVar38 = *(long *)(*(long *)(piVar21 + 4) + 8);\n                }\n                else {\n                  if (*piVar21 != 0x13) goto LAB_001104b1;\n                  lVar38 = *(long *)(*(long *)(piVar21 + 4) + 0x10);\n                }\n                bVar52 = lVar38 == 0;\n              }\n            }\nLAB_001104b1:\n            pbVar27 = (byte *)savestring(*param_4,(int)pcVar40 - (int)*param_4);\n            *param_4 = (byte *)(pcVar40 + 1);\n            cVar6 = pcVar40[1];\n            if (cVar6 == '0') {\n              local_100 = 2;\n            }\n            else if (cVar6 == '1') {\n              local_100 = 1;\n            }\n            else {\n              if (cVar6 == '\\0') goto LAB_00110788;\n              local_100 = 0;\n            }\n            *param_4 = (byte *)(pcVar40 + 2);\n            bVar1 = pcVar40[2];\n            if ('D' < (char)bVar1) {\nswitchD_00110537_caseD_40:\n              uVar15 = dcgettext(0,\"const/volatile indicator missing\",5);\n              warn_stab(pbVar3,uVar15);\n              goto switchD_00110537_caseD_3f;\n            }\n            if ((char)bVar1 < '?') {\n              if ((bVar1 & 0xfb) != 0x2a) goto switchD_00110537_caseD_40;\n              goto switchD_00110537_caseD_3f;\n            }\n            switch(bVar1) {\n            default:\n              goto switchD_00110537_caseD_40;\n            case 0x41:\n              *param_4 = (byte *)(pcVar40 + 3);\n            case 0x3f:\nswitchD_00110537_caseD_3f:\n              local_130 = '\\0';\n              local_138 = '\\0';\n              break;\n            case 0x42:\n              local_130 = '\\0';\n              *param_4 = (byte *)(pcVar40 + 3);\n              local_138 = '\\x01';\n              break;\n            case 0x43:\n              local_130 = '\\x01';\n              *param_4 = (byte *)(pcVar40 + 3);\n              local_138 = '\\0';\n              break;\n            case 0x44:\n              local_130 = '\\x01';\n              *param_4 = (byte *)(pcVar40 + 3);\n              local_138 = '\\x01';\n            }\n            pbVar28 = *param_4;\n            bVar1 = *pbVar28;\n            pbVar31 = pbVar27;\n            if (bVar1 == 0x2e) {\n              *param_4 = pbVar28 + 1;\nLAB_001106bd:\n              bVar41 = false;\n              local_120 = (byte *)0x0;\n              local_110 = (byte *)0x0;\n              local_140 = (byte *)0x0;\n            }\n            else {\n              if (bVar1 == 0x3f) {\n                *param_4 = pbVar28 + 1;\n                sVar33 = strlen(local_150);\n                iVar10 = strncmp((char *)pbVar27,local_150,sVar33);\n                if (iVar10 == 0) {\n                  bVar41 = true;\n                  local_120 = (byte *)0x0;\n                  local_110 = (byte *)0x0;\n                  local_140 = (byte *)0x0;\n                  goto LAB_00110703;\n                }\n                bVar41 = true;\n                local_140 = (byte *)0x0;\n                local_120 = (byte *)0x0;\n                local_110 = (byte *)0x0;\nLAB_0011072b:\n                lVar38 = stab_find_type(param_1,param_2,&local_a8);\n                if (lVar38 == 0) goto LAB_001111e9;\n                piVar21 = (int *)debug_get_real_type_isra_0(pbVar50,0);\n                if ((piVar21 == (int *)0x0) ||\n                   (((*piVar21 != 0xd && (*piVar21 != 0x13)) ||\n                    (lVar19 = **(long **)(piVar21 + 4), lVar19 == 0)))) goto LAB_00110788;\n                bVar1 = *pbVar27;\n                if (((bVar1 == 0x5f) && (pbVar27[1] == 0x5f)) &&\n                   ((bVar47 = pbVar27[2], ((&_sch_istable)[(ulong)bVar47 * 2] & 4) != 0 ||\n                    (bVar47 == 0x51 || bVar47 == 0x74)))) {\n                  bVar52 = true;\n                  bVar47 = 1;\nLAB_00110827:\n                  bVar2 = pbVar27[1];\n                  if ((bVar2 == 0x24) || (bVar2 == 0x2e)) {\n                    if (pbVar27[2] != 0x5f) goto LAB_0011085d;\n                    goto LAB_00110a69;\n                  }\n                  bVar7 = startswith_lto_priv_0_lto_priv_0(pbVar27,&DAT_001207c3);\n                  if (bVar2 != 0x5a) goto LAB_0011086f;\n                  if ((bVar47 | bVar7) != 0) goto LAB_00110a58;\n                  uVar45 = 0;\nLAB_00110a9d:\n                  local_a0 = pbVar31;\n                  if ((*pbVar31 == 0x5f) && (pbVar31[1] == 0x5a)) {\n                    sVar33 = strlen((char *)pbVar31);\n                    cplus_demangle_init_info(pbVar31,3,sVar33,&local_98);\n                    pvVar17 = malloc((long)local_6c << 5);\n                    local_78 = pvVar17;\n                    pvVar25 = malloc((long)local_5c << 3);\n                    local_68 = pvVar25;\n                    if ((pvVar17 == (void *)0x0) || (pvVar25 == (void *)0x0)) {\n                      free(pvVar17);\n                      free(pvVar25);\n                    }\n                    else {\n                      piVar21 = (int *)cplus_demangle_mangled_name(&local_98,1);\n                      if (*(char *)CONCAT71(uStack_7f,local_80) == '\\0') {\n                        free(local_68);\n                        pvVar17 = local_78;\n                        if (piVar21 != (int *)0x0) {\n                          if ((*piVar21 == 3) && (**(int **)(piVar21 + 6) == 0x29)) {\n                            lVar20 = stab_demangle_v3_arglist\n                                               (param_1,param_2,\n                                                *(undefined8 *)(*(int **)(piVar21 + 6) + 6),\n                                                &local_a9);\n                            free(pvVar17);\n                            goto LAB_001110a9;\n                          }\n                          pcVar40 = (char *)dcgettext(0,\"Demangled name is not a function\\n\",5);\n                          fprintf(_stderr,pcVar40);\n                          free(pvVar17);\n                          goto LAB_001111e9;\n                        }\n                      }\n                      else {\n                        free(local_68);\n                      }\n                      free(local_78);\n                    }\n                    stab_bad_demangle(pbVar31);\n                  }\n                  else {\n                    local_80 = '\\0';\n                    local_88 = 0;\n                    local_6c = 10;\n                    local_98 = param_1;\n                    local_90 = param_2;\n                    local_78 = (void *)xmalloc(0xa0);\n                    pbVar50 = local_a0;\n                    local_70 = 0;\n                    pbVar28 = local_a0;\n                    if ((int)uVar45 == 0) {\n                      do {\n                        pbVar42 = (byte *)strchr((char *)pbVar28,0x5f);\n                        if (pbVar42 == (byte *)0x0) {\n                          stab_bad_demangle(pbVar50);\n                          goto LAB_00111097;\n                        }\n                        pbVar28 = pbVar42 + 1;\n                      } while (pbVar42[1] != 0x5f);\n                      sVar33 = strspn((char *)pbVar42,\"_\");\n                      if (2 < (uint)sVar33) {\n                        pbVar42 = pbVar42 + ((uint)sVar33 - 2);\n                      }\n                    }\n                    else {\n                      pbVar42 = local_a0 + uVar45;\n                    }\n                    bVar1 = pbVar42[2];\n                    if (local_a0 == pbVar42) {\n                      if ((((&_sch_istable)[(ulong)bVar1 * 2] & 4) != 0) ||\n                         (pbVar50 = pbVar42, bVar1 == 0x51 || bVar1 == 0x74)) {\n                        local_a0 = pbVar42 + 2;\nLAB_00110d86:\n                        pbVar50 = local_a0;\n                        if (*local_a0 != 0) {\n                          pbVar28 = (byte *)0x0;\n                          cVar8 = '\\0';\n                          cVar6 = '\\0';\n                          while (pbVar42 = local_a0, bVar1 = *local_a0, bVar1 != 0) {\n                            if (bVar1 == 0x51) {\n                              cVar6 = stab_demangle_qualified(&local_98,&local_a0,0);\n                              if (cVar6 != '\\0') {\n                                cVar6 = stab_demangle_remember_type\n                                                  (&local_98,pbVar42,(int)local_a0 - (int)pbVar42);\njoined_r0x00110fbc:\n                                if (cVar6 != '\\0') {\n                                  pbVar28 = (byte *)0x0;\n                                  goto LAB_0011100c;\n                                }\n                              }\n                              goto LAB_00111097;\n                            }\n                            if ('Q' < (char)bVar1) {\n                              if (bVar1 == 0x5f) {\n                                stab_bad_demangle(pbVar50);\n                              }\n                              else {\n                                if (bVar1 != 0x74) {\n                                  if (bVar1 != 0x53) goto LAB_00110fd7;\n                                  goto LAB_00110ead;\n                                }\n                                if (pbVar28 == (byte *)0x0) {\n                                  pbVar28 = local_a0;\n                                }\n                                cVar6 = stab_demangle_template(&local_98,&local_a0,0);\n                                if (cVar6 != '\\0') {\n                                  cVar6 = stab_demangle_remember_type\n                                                    (&local_98,pbVar28,(int)local_a0 - (int)pbVar28)\n                                  ;\n                                  goto joined_r0x00110fbc;\n                                }\n                              }\n                              goto LAB_00111097;\n                            }\n                            if (bVar1 != 0x43) {\n                              if ((char)bVar1 < 'D') {\n                                if ((byte)(bVar1 - 0x30) < 10) {\n                                  if (pbVar28 == (byte *)0x0) {\n                                    pbVar28 = local_a0;\n                                  }\n                                  uVar12 = stab_demangle_count(&local_a0);\n                                  pbVar5 = local_a0;\n                                  sVar33 = strlen((char *)local_a0);\n                                  if (uVar12 <= sVar33) {\n                                    local_a0 = pbVar5 + uVar12;\n                                    cVar6 = stab_demangle_remember_type\n                                                      (&local_98,pbVar28,\n                                                       (int)local_a0 - (int)pbVar28);\n                                    goto joined_r0x00110fbc;\n                                  }\n                                  stab_bad_demangle(pbVar42);\n                                  goto LAB_00111097;\n                                }\n                              }\n                              else if (bVar1 == 0x46) {\n                                local_a0 = local_a0 + 1;\n                                cVar8 = stab_demangle_args(&local_98,&local_a0,&local_88,&local_80);\n                                if (cVar8 != '\\0') {\n                                  pbVar28 = (byte *)0x0;\n                                  pbVar42 = local_a0;\n                                  goto LAB_00111004;\n                                }\n                                goto LAB_00111097;\n                              }\nLAB_00110fd7:\n                              cVar8 = stab_demangle_args(&local_98,&local_a0,&local_88,&local_80);\n                              pbVar42 = local_a0;\n                              if (cVar8 != '\\0') goto LAB_00111004;\n                              goto LAB_00111097;\n                            }\nLAB_00110ead:\n                            pbVar42 = local_a0 + 1;\n                            if (pbVar28 == (byte *)0x0) {\n                              pbVar28 = local_a0;\n                            }\nLAB_00111004:\n                            local_a0 = pbVar42;\n                            if (cVar6 != '\\0') {\nLAB_0011100c:\n                              cVar8 = stab_demangle_args(&local_98,&local_a0,&local_88,&local_80);\n                              cVar6 = cVar8;\n                              if (cVar8 == '\\0') goto LAB_00111097;\n                            }\n                          }\n                          if ((cVar8 == '\\0') &&\n                             (cVar6 = stab_demangle_args(&local_98,&local_a0,&local_88,&local_80),\n                             cVar6 == '\\0')) goto LAB_00111097;\n                        }\n                        free(local_78);\n                        local_78 = (void *)0x0;\n                        if (local_88 == 0) {\n                          pcVar40 = (char *)dcgettext(0,\"no argument types in mangled string\\n\",5);\n                          fprintf(_stderr,pcVar40);\n                        }\n                        local_a9 = local_80;\n                        lVar20 = local_88;\nLAB_001110a9:\n                        if (lVar20 != 0) {\n                          pbVar50 = (byte *)debug_make_method_type_isra_0\n                                                      (lVar19,lVar38,lVar20,local_a9);\n                          goto LAB_001110d5;\n                        }\n                        goto LAB_001111e9;\n                      }\n                      for (; *pbVar50 == 0x5f; pbVar50 = pbVar50 + 1) {\n                      }\n                      pcVar40 = strstr((char *)pbVar50,\"__\");\n                      if ((pcVar40 != (char *)0x0) && (pcVar40[2] != '\\0')) {\n                        cVar6 = stab_demangle_function_name_constprop_0(&local_98,&local_a0,pcVar40)\n                        ;\n                        goto LAB_00110d7e;\n                      }\n                      stab_bad_demangle(pbVar42);\n                    }\n                    else if (bVar1 == 0) {\n                      stab_bad_demangle(local_a0);\n                    }\n                    else {\n                      cVar6 = stab_demangle_function_name_constprop_0(&local_98,&local_a0,pbVar42);\nLAB_00110d7e:\n                      if (cVar6 != '\\0') goto LAB_00110d86;\n                    }\nLAB_00111097:\n                    free(local_78);\n                  }\n                  goto LAB_001111e9;\n                }\n                cVar6 = startswith_lto_priv_0_lto_priv_0(pbVar27,&DAT_001207be);\n                if (cVar6 == '\\0') {\n                  if (param_3 == (char *)0x0) {\n                    bVar47 = 0;\n                    bVar52 = false;\n                  }\n                  else {\n                    iVar10 = strcmp(local_150,param_3);\n                    bVar52 = iVar10 == 0;\n                    bVar47 = 0;\n                  }\n                }\n                else {\n                  bVar47 = 1;\n                  bVar52 = true;\n                }\n                if (bVar1 == 0x5f) goto LAB_00110827;\nLAB_0011085d:\n                bVar7 = startswith_lto_priv_0_lto_priv_0(pbVar27,&DAT_001207c3);\nLAB_0011086f:\n                if ((bVar47 | bVar7) == 0) {\n                  pcVar40 = param_3;\n                  if (param_3 == (char *)0x0) {\n                    if (local_138 == '\\0') {\n                      pcVar16 = \"\";\n                      if (local_130 != '\\0') {\n                        pcVar16 = \"V\";\n                      }\n                      pcVar46 = \"\";\n                    }\n                    else {\n                      pcVar16 = \"\";\n                      if (local_130 != '\\0') {\n                        pcVar16 = \"V\";\n                      }\n                      pcVar46 = \"C\";\n                    }\nLAB_00110917:\n                    iVar10 = 0;\n                    sprintf((char *)&local_98,\"__%s%s\",pcVar46,pcVar16);\n                  }\n                  else {\n                    pcVar46 = \"C\";\n                    pcVar16 = \"V\";\n                    sVar33 = strlen(param_3);\n                    iVar10 = (int)sVar33;\n                    if (local_138 == '\\0') {\n                      pcVar46 = \"\";\n                    }\n                    if (local_130 == '\\0') {\n                      pcVar16 = \"\";\n                    }\n                    if (iVar10 == 0) goto LAB_00110917;\n                    pcVar29 = strchr(param_3,0x3c);\n                    if (pcVar29 == (char *)0x0) {\n                      sprintf((char *)&local_98,\"__%s%s%d\",pcVar46,pcVar16);\n                    }\n                    else {\n                      iVar10 = 0;\n                      sprintf((char *)&local_98,\"__%s%s\",pcVar46,pcVar16);\n                      pcVar40 = (char *)0x0;\n                    }\n                  }\n                  iVar14 = 0;\n                  if (!bVar52) {\n                    sVar33 = strlen(local_150);\n                    iVar14 = (int)sVar33;\n                  }\n                  sVar33 = strlen((char *)&local_98);\n                  sVar30 = strlen((char *)pbVar27);\n                  local_d0 = (int)sVar33;\n                  if (((*local_150 == 'o') && (local_150[1] == 'p')) &&\n                     ((local_150[2] == '$' || (local_150[2] == '.')))) goto LAB_001111e9;\n                  pbVar31 = (byte *)xmalloc(iVar10 + 1 + iVar14 + local_d0 + (int)sVar30);\n                  if (bVar52) {\n                    *pbVar31 = 0;\n                  }\n                  else {\n                    strcpy((char *)pbVar31,local_150);\n                  }\n                  sVar33 = strlen((char *)pbVar31);\n                  uVar45 = sVar33 & 0xffffffff;\n                  strcpy((char *)(pbVar31 + sVar33),(char *)&local_98);\n                  if (pcVar40 != (char *)0x0) {\n                    strcat((char *)pbVar31,pcVar40);\n                  }\n                  strcat((char *)pbVar31,(char *)pbVar27);\n                  if (*pbVar27 != 0) goto LAB_00110a9d;\n                }\n                else {\nLAB_00110a58:\n                  if ((bVar1 != 0) && ((bVar7 & 1) == 0)) {\n                    uVar45 = 0;\n                    goto LAB_00110a9d;\n                  }\n                }\nLAB_00110a69:\n                puVar32 = (undefined8 *)xmalloc(8);\n                *puVar32 = 0;\n                pbVar50 = (byte *)debug_make_method_type_isra_0(lVar19,lVar38,puVar32,0);\nLAB_001110d5:\n                if (pbVar50 == (byte *)0x0) goto LAB_001111e9;\n                goto LAB_001110de;\n              }\n              if (bVar1 != 0x2a) {\n                warn_stab(pbVar3,\"member function type missing\");\n                goto LAB_001106bd;\n              }\n              *param_4 = pbVar28 + 1;\n              uVar12 = parse_number(param_4,0,param_6);\n              pbVar28 = *param_4;\n              if (*pbVar28 != 0x3b) goto LAB_00110788;\n              local_110 = (byte *)(ulong)(uVar12 & 0x7fffffff);\n              *param_4 = pbVar28 + 1;\n              bVar41 = pbVar28[1] == 0x3b || pbVar28[1] == 0;\n              if (bVar41) {\n                bVar41 = false;\n                local_120 = (byte *)0x0;\n                local_140 = (byte *)0x0;\n              }\n              else {\n                pbVar28 = (byte *)FUNC_0010ee3f(param_1,param_2,0,param_4);\n                bVar1 = **param_4;\n                if (bVar1 != 0x3a) {\n                  if (bVar1 == 0x3b) {\n                    *param_4 = *param_4 + 1;\n                    local_140 = (byte *)0x0;\n                    local_120 = pbVar28;\n                    goto LAB_00110703;\n                  }\n                  goto LAB_00110788;\n                }\n                local_120 = (byte *)0x0;\n                local_140 = pbVar28;\n              }\n            }\nLAB_00110703:\n            if (bVar52) goto LAB_0011072b;\nLAB_001110de:\n            uVar12 = local_f0 + 1;\n            if (local_ec <= uVar12) {\n              local_ec = local_ec + 10;\n              local_128 = (char *)xrealloc(local_128,(ulong)local_ec << 3);\n            }\n            if (bVar41) {\n              ppbVar34 = (byte **)xmalloc(0x28);\n              puVar22 = (undefined *)((long)ppbVar34 + 0x16);\n              for (lVar38 = 0x12; lVar38 != 0; lVar38 = lVar38 + -1) {\n                *puVar22 = 0;\n                puVar22 = puVar22 + (ulong)bVar48 * -2 + 1;\n              }\n              *ppbVar34 = pbVar31;\n              ppbVar34[1] = pbVar50;\n              *(undefined4 *)(ppbVar34 + 2) = local_100;\n              ppbVar34[3] = (byte *)0xffffffffffffffff;\n              *(char *)((long)ppbVar34 + 0x14) = local_138;\n              *(char *)((long)ppbVar34 + 0x15) = local_130;\n            }\n            else {\n              ppbVar34 = (byte **)xmalloc(0x28);\n              puVar22 = (undefined *)((long)ppbVar34 + 0x16);\n              for (lVar38 = 0x12; lVar38 != 0; lVar38 = lVar38 + -1) {\n                *puVar22 = 0;\n                puVar22 = puVar22 + (ulong)bVar48 * -2 + 1;\n              }\n              *ppbVar34 = pbVar31;\n              ppbVar34[1] = pbVar50;\n              *(undefined4 *)(ppbVar34 + 2) = local_100;\n              *(char *)((long)ppbVar34 + 0x14) = local_138;\n              *(char *)((long)ppbVar34 + 0x15) = local_130;\n              ppbVar34[3] = local_110;\n              ppbVar34[4] = local_120;\n            }\n            *(byte ***)(local_128 + (ulong)local_f0 * 8) = ppbVar34;\n            pbVar50 = *param_4;\n            if ((*pbVar50 == 0x3b) || (local_f0 = uVar12, *pbVar50 == 0)) goto LAB_00111678;\n            goto LAB_00110406;\n          }\n          if (pvVar24 != (void *)0x0) {\n            *(undefined8 *)((long)pvVar24 + (ulong)local_fc * 8) = 0;\n          }\n          pbVar3 = *param_4;\n          if (param_6 <= pbVar3) goto LAB_001112f3;\n          if (*pbVar3 == 0x3b) {\n            *param_4 = pbVar3 + 1;\n          }\n          pbVar27 = *param_4;\n          if (*pbVar27 == 0x7e) {\n            *param_4 = pbVar27 + 1;\n            if (((pbVar27[1] & 0xef) == 0x2d) || (pbVar27[1] == 0x2b)) {\n              *param_4 = pbVar27 + 2;\n            }\n            if (**param_4 != 0x25) goto LAB_001112ee;\n            pbVar27 = *param_4 + 1;\n            *param_4 = pbVar27;\n            cVar6 = parse_stab_type_number(param_4,&local_98,param_6);\n            if (cVar6 == '\\0') goto LAB_001112f3;\n            if ((uint)local_98 != (uint)local_a8) {\nLAB_001112a2:\n              *param_4 = pbVar27;\n              pvVar25 = (void *)FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n              for (pbVar27 = *param_4; *pbVar27 != 0x3b; pbVar27 = pbVar27 + 1) {\n                if (*pbVar27 == 0) {\n                  bad_stab(pbVar3);\n                  goto LAB_001112f3;\n                }\n              }\n              *param_4 = pbVar27 + 1;\n              goto LAB_00111307;\n            }\n            if (local_98._4_4_ != local_a8._4_4_) goto LAB_001112a2;\n            pvVar25 = (void *)0x0;\n          }\n          else {\nLAB_001112ee:\n            pvVar25 = (void *)0x0;\nLAB_00111307:\n            if ((((ulong)local_118 | (ulong)pvVar24 | (ulong)pvVar25) == 0) && (!bVar51)) {\n              pvVar17 = (void *)debug_make_struct_type_isra_0(bVar9 == 0x73,uVar49,local_158);\n              break;\n            }\n            cVar6 = '\\0';\n          }\n          pvVar17 = (void *)debug_make_type_constprop_0((bVar9 != 0x73) + '\\t',uVar49 & 0xffffffff);\n          if (pvVar17 == (void *)0x0) {\n            return (void *)0x0;\n          }\n          ppvVar35 = (void **)xmalloc(0x28);\n          lVar38 = 8;\n          ppvVar18 = ppvVar35 + 1;\n          if (cVar6 != '\\0') {\n            pvVar25 = pvVar17;\n          }\n          for (; lVar38 != 0; lVar38 = lVar38 + -1) {\n            *(undefined4 *)ppvVar18 = 0;\n            ppvVar18 = (void **)((long)ppvVar18 + (ulong)bVar48 * -8 + 4);\n          }\n          ppvVar35[3] = pvVar24;\n          ppvVar35[4] = pvVar25;\n          *ppvVar35 = local_158;\n          ppvVar35[2] = local_118;\n          *(void ***)((long)pvVar17 + 0x10) = ppvVar35;\n          goto LAB_001115eb;\n        }\n      }\nLAB_0010fe2e:\n      local_158 = (void *)0x0;\nLAB_001112f3:\n      free(local_158);\n      return (void *)0x0;\n    case 0x78:\n      bVar48 = pbVar50[1];\n      if (bVar48 == 0x73) {\nLAB_0010f0fd:\n        uVar15 = 7;\n      }\n      else if ((char)bVar48 < 't') {\n        if (bVar48 == 0) goto switchD_0010f055_caseD_24;\n        uVar15 = 0xb;\n        if (bVar48 != 0x65) goto LAB_0010f0df;\n      }\n      else {\n        uVar15 = 8;\n        if (bVar48 != 0x75) {\nLAB_0010f0df:\n          uVar15 = dcgettext(0,\"unrecognized cross reference type\",5);\n          warn_stab(pbVar3,uVar15);\n          goto LAB_0010f0fd;\n        }\n      }\n      pbVar27 = *param_4 + 1;\n      *param_4 = pbVar27;\n      pcVar16 = strchr((char *)pbVar27,0x3c);\n      pcVar40 = strchr((char *)pbVar27,0x3a);\n      if (pcVar40 == (char *)0x0) {\nswitchD_0010f055_caseD_24:\n        bad_stab(pbVar3);\n        return (void *)0x0;\n      }\n      if (((pcVar16 != (char *)0x0) && (pcVar16 < pcVar40)) && (pcVar40[1] == ':')) {\n        iVar10 = 0;\n        for (; cVar6 = *pcVar16, cVar6 != '\\0'; pcVar16 = pcVar16 + 1) {\n          if (cVar6 == '<') {\n            iVar10 = iVar10 + 1;\n          }\n          else if (cVar6 == '>') {\n            iVar10 = iVar10 + -1;\n          }\n          else if ((iVar10 == 0) && (pcVar40 = pcVar16, cVar6 == ':')) goto LAB_0010f176;\n        }\n        goto switchD_0010f055_caseD_24;\n      }\nLAB_0010f176:\n      uVar49 = (long)pcVar40 - (long)pbVar27;\n      if ((param_3 != (char *)0x0) &&\n         ((iVar10 = strncmp(param_3,(char *)pbVar27,uVar49), iVar10 == 0 &&\n          (param_3[uVar49] == '\\0')))) {\n        *(undefined *)(param_2 + 0x1a8) = 1;\n      }\n      pvVar17 = (void *)stab_find_tagged_type(param_1,param_2,pbVar27,uVar49 & 0xffffffff,uVar15);\n      *param_4 = (byte *)(pcVar40 + 1);\n    }\n  }\nLAB_001115e2:\n  if (pvVar17 == (void *)0x0) {\n    return (void *)0x0;\n  }\nLAB_001115eb:\n  if ((uint)local_a8 != -1) {\n    ppvVar18 = (void **)stab_find_slot(param_2,&local_a8);\n    if (ppvVar18 == (void **)0x0) {\n      return (void *)0x0;\n    }\n    *ppvVar18 = pvVar17;\n  }\n  if (local_12c != 0xffffffff) {\n    uVar12 = *(uint *)((long)pvVar17 + 4);\n    if ((uVar12 != 0) && (local_12c != uVar12)) {\n      pcVar40 = (char *)dcgettext(0,\"Warning: changing type size from %d to %d\\n\",5);\n      fprintf(_stderr,pcVar40,(ulong)uVar12,(ulong)local_12c);\n    }\n    *(uint *)((long)pvVar17 + 4) = local_12c;\n    return pvVar17;\n  }\n  return pvVar17;\nLAB_00110788:\n  bad_stab(pbVar3);\nLAB_001111e9:\n  free(local_150);\n  free(local_128);\n  free(pbVar27);\n  goto LAB_001112f3;\nLAB_00111678:\n  *(undefined8 *)(local_128 + (ulong)uVar12 * 8) = 0;\n  if (*pbVar50 != 0) {\n    *param_4 = pbVar50 + 1;\n  }\n  if (local_e0 <= local_fc + 1) {\n    local_e0 = local_e0 + 10;\n    pvVar24 = (void *)xrealloc(pvVar24,(ulong)local_e0 << 3);\n  }\n  ppcVar23 = (char **)xmalloc(0x10);\n  *ppcVar23 = local_150;\n  ppcVar23[1] = local_128;\n  *(char ***)((long)pvVar24 + (ulong)local_fc * 8) = ppcVar23;\n  local_fc = local_fc + 1;\n  goto LAB_00110345;\n}\n\n",
            "called": [
                "strchr",
                "bad_stab",
                "savestring",
                "concat",
                "strlen",
                "dcgettext",
                "debug_make_array_type.isra.0",
                "debug_make_pointer_type.isra.0",
                "xrealloc",
                "stab_demangle_args",
                "strtol",
                "debug_make_enum_type.isra.0",
                "strcmp",
                "debug_get_real_type.isra.0",
                "stab_demangle_count",
                "free",
                "fprintf",
                "strcpy",
                "debug_make_function_type.isra.0",
                "parse_stab_type",
                "parse_number",
                "strstr",
                "cplus_demangle_init_info",
                "debug_make_float_type.isra.0",
                "debug_make_reference_type.isra.0",
                "cplus_demangle_mangled_name",
                "sprintf",
                "startswith.lto_priv.0.lto_priv.0",
                "strncmp",
                "debug_get_type_name.constprop.0",
                "stab_demangle_v3_arglist",
                "debug_make_void_type.isra.0",
                "strcat",
                "stab_bad_demangle",
                "debug_make_volatile_type.isra.0",
                "stab_demangle_qualified",
                "debug_make_method_type.isra.0",
                "malloc",
                "stab_demangle_remember_type",
                "debug_make_struct_type.isra.0",
                "debug_make_offset_type.isra.0",
                "stab_demangle_template",
                "parse_stab_type_number",
                "stab_find_slot",
                "debug_make_const_type.isra.0",
                "stab_demangle_function_name.constprop.0",
                "stab_find_type",
                "stab_find_tagged_type",
                "strspn",
                "debug_make_type.constprop.0",
                "debug_make_int_type.isra.0",
                "debug_find_named_type",
                "warn_stab",
                "xmalloc"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0010ee3f",
            "calling": [
                "parse_stab",
                "parse_stab_type"
            ],
            "imported": false,
            "current_name": "FUNC_0010ee3f"
        },
        "FUN_00108b3e": {
            "renaming": {
                "FUN_00108b3e": "print_last_stab_entries_00108b3e",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "__format": "formatMessage",
                "lVar1": "stabName",
                "lVar2": "stabIndex",
                "piVar3": "currentStab",
                "iVar4": "index",
                "saved_stabs_index": "stabIndexTotal",
                "saved_stabs": "stabEntries"
            },
            "code": "\n\n\nundefined8 printLastStabEntries_00108b3e(undefined8 param1,undefined8 param2,undefined8 param3)\n\n{\n  char *formatMessage;\n  long stabName;\n  long stabIndex;\n  int *currentStab;\n  int index;\n  \n  formatMessage = (char *)dcgettext(0,\"Last stabs entries before error:\\n\",5);\n  fprintf(_stderr,formatMessage);\n  fwrite(\"n_type n_desc n_value  string\\n\",1,0x1e,_stderr);\n  index = stabIndexTotal;\n  do {\n    stabIndex = (long)index * 0x18;\n    currentStab = (int *)(stabEntries + stabIndex);\n    if (*(long *)(stabEntries + stabIndex + 0x10) != 0) {\n      stabName = bfd_get_stab_name(*currentStab);\n      if (stabName == 0) {\n        if (*currentStab == 0) {\n          fwrite(\"HdrSym\",1,6,_stderr);\n        }\n        else {\n          fprintf(_stderr,\"%-6d\");\n        }\n      }\n      else {\n        fprintf(_stderr,\"%-6s\",stabName);\n      }\n      fprintf(_stderr,\" %-6d \",(ulong)*(uint *)(stabEntries + stabIndex + 4));\n      fprintf(_stderr,\"%08lx\",*(undefined8 *)(stabEntries + stabIndex + 8));\n      if (*currentStab != 0) {\n        fprintf(_stderr,\" %s\",*(undefined8 *)(stabEntries + stabIndex + 0x10));\n      }\n      fputc(10,_stderr);\n    }\n    index = (index + 1) % 0x10;\n  } while (stabIndexTotal != index);\n  return param3;\n}\n\n",
            "called": [
                "fprintf",
                "fputc",
                "dcgettext",
                "bfd_get_stab_name",
                "fwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108b3e",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "print_last_stab_entries_00108b3e"
        },
        "FUN_0010a083": {
            "renaming": {
                "FUN_0010a083": "modify_stab_type_0010a083",
                "param_1": "input_param",
                "stab_modify_type": "update_stab_type"
            },
            "code": "\nvoid modify_stab_type_0010a083(long input_param)\n\n{\n  update_stab_type(input_param,0x2a,4,input_param + 0x178,input_param + 0x180);\n  return;\n}\n\n",
            "called": [
                "stab_modify_type"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a083",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "modify_stab_type_0010a083"
        },
        "FUN_00109c2e": {
            "renaming": {
                "FUN_00109c2e": "expand_and_copy_array_00109c2e",
                "param_1": "arrayPointer",
                "param_2": "newValue",
                "param_3": "arraySize",
                "param_4": "flag",
                "param_5": "output",
                "param_6": "returnVal",
                "lVar1": "newArrayPointer",
                "plVar2": "currentElement",
                "lVar3": "remainingElements",
                "puVar4": "currentPosition",
                "uVar5": "currentSize",
                "bVar6": "isZero",
                "auVar7": "returnArray"
            },
            "code": "\nundefined  [16]\nexpandAndCopyArray_00109c2e(long arrayPointer,long newValue,ulong arraySize,int flag,undefined4 *output,\n            undefined8 returnVal)\n\n{\n  long newArrayPointer;\n  long *currentElement;\n  long remainingElements;\n  undefined *currentPosition;\n  ulong currentSize;\n  byte isZero;\n  undefined returnArray [16];\n  \n  isZero = 0;\n  arraySize = arraySize & 0xffffffff;\n  currentSize = *(ulong *)(arrayPointer + 0x1b0);\n  if (currentSize <= arraySize) {\n    if (currentSize == 0) {\n      currentSize = 10;\n    }\n    for (; currentSize <= arraySize; currentSize = currentSize * 2) {\n    }\n    newArrayPointer = xrealloc(*(undefined8 *)(arrayPointer + 0x1a8),currentSize * 0x18);\n    *(long *)(arrayPointer + 0x1a8) = newArrayPointer;\n    currentPosition = (undefined *)(*(long *)(arrayPointer + 0x1b0) * 0x18 + newArrayPointer);\n    for (remainingElements = (currentSize - *(long *)(arrayPointer + 0x1b0)) * 0x18; remainingElements != 0; remainingElements = remainingElements + -1) {\n      *currentPosition = 0;\n      currentPosition = currentPosition + (ulong)isZero * -2 + 1;\n    }\n    *(ulong *)(arrayPointer + 0x1b0) = currentSize;\n  }\n  currentElement = (long *)(arraySize * 0x18 + *(long *)(arrayPointer + 0x1a8));\n  if (*currentElement == 0) {\n    newArrayPointer = *(long *)(arrayPointer + 0x68);\n    *currentElement = newArrayPointer;\n    *(long *)(arrayPointer + 0x68) = newArrayPointer + 1;\n    currentElement[1] = newValue;\n    *(int *)(currentElement + 2) = flag;\n  }\n  if (flag == 0) {\n    *(undefined4 *)(currentElement + 2) = 0;\n    *(undefined4 *)((long)currentElement + 0x14) = *output;\n  }\n  else {\n    *output = *(undefined4 *)((long)currentElement + 0x14);\n  }\n  returnArray._8_8_ = returnVal;\n  returnArray._0_8_ = *currentElement;\n  return returnArray;\n}\n\n",
            "called": [
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109c2e",
            "calling": [
                "stab_tag_type.lto_priv.0",
                "stab_start_struct_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "expand_and_copy_array_00109c2e"
        },
        "FUN_001053b5": {
            "renaming": {
                "FUN_001053b5": "format_error_001053b5",
                "uVar1": "errorMsg",
                "dcgettext": "getTranslatedMessage",
                "fatal": "handleFatalError"
            },
            "code": "\nvoid formatError_001053b5(void)\n\n{\n  undefined8 errorMsg;\n  \n  errorMsg = getTranslatedMessage(0,\"bad format for %s\",5);\n                    \n  handleFatalError(errorMsg);\n}\n\n",
            "called": [
                "dcgettext",
                "fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001053b5",
            "calling": [
                "init_section_add"
            ],
            "imported": false,
            "current_name": "format_error_001053b5"
        },
        "FUN_00112996": {
            "renaming": {
                "FUN_00112996": "add_to_current_namespace_00112996",
                "param_1": "input_ptr",
                "param_2": "arg1",
                "param_3": "arg2",
                "uVar1": "result",
                "lVar2": "temp_var"
            },
            "code": "\n\n\nundefined8 add_to_current_namespace_00112996(long input_ptr,undefined8 arg1,undefined8 arg2)\n\n{\n  undefined8 result;\n  long temp_var;\n  \n  if ((*(long *)(input_ptr + 8) != 0) && (*(long *)(input_ptr + 0x10) != 0)) {\n    temp_var = *(long *)(input_ptr + 0x10) + 0x10;\n    if (*(long *)(input_ptr + 0x20) != 0) {\n      temp_var = *(long *)(input_ptr + 0x20) + 0x28;\n    }\n    result = debug_add_to_namespace_constprop_0(temp_var,arg1,arg2,3);\n    return result;\n  }\n  result = dcgettext(0,\"debug_add_to_current_namespace_00112996: no current file\",5);\n  fprintf(_stderr,\"%s\\n\",result);\n  return 0;\n}\n\n",
            "called": [
                "fprintf",
                "debug_add_to_namespace.constprop.0",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112996",
            "calling": [
                "parse_stab"
            ],
            "imported": false,
            "current_name": "add_to_current_namespace_00112996"
        },
        "FUN_001284b8": {
            "renaming": {},
            "code": "\n\n\n\nint getc(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001284b8",
            "calling": [
                "getc"
            ],
            "imported": false,
            "current_name": "FUN_001284b8"
        },
        "FUN_0010c7a0": {
            "renaming": {
                "FUN_0010c7a0": "set_debug_class_id_0010c7a0",
                "param_1": "classTypeID",
                "param_2": "className",
                "param_3": "debugTypeKind",
                "param_4": "debugInfo",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "lVar3": "tempVar3",
                "piVar4": "debugTypeKindPtr",
                "__s1": "debugClassName",
                "cVar5": "isSameType",
                "iVar6": "counter",
                "puVar7": "tempPtrVar",
                "auVar8": "returnVal"
            },
            "code": "\nundefined  [16] setDebugClassID_0010c7a0(long classTypeID,char *className,int *debugTypeKind,undefined8 debugInfo)\n\n{\n  undefined8 tempVar1;\n  uint tempVar2;\n  long tempVar3;\n  int *debugTypeKindPtr;\n  char *debugClassName;\n  char isSameType;\n  int counter;\n  undefined8 *tempPtrVar;\n  undefined returnVal [16];\n  \n  if (3 < *debugTypeKind - 7U) {\n                    \n    __assert_fail(\"type->kind == DEBUG_KIND_STRUCT || type->kind == DEBUG_KIND_UNION || type->kind == DEBUG_KIND_CLASS || type->kind == DEBUG_KIND_UNION_CLASS\"\n                  ,\"../../binutils/debug.c\",0xb87,\"debug_set_class_id\");\n  }\n  tempVar3 = *(long *)(debugTypeKind + 4);\n  tempPtrVar = (undefined8 *)(ulong)*(uint *)(tempVar3 + 0xc);\n  if (*(uint *)(tempVar3 + 0xc) <= *(uint *)(classTypeID + 0x38)) {\n    for (tempPtrVar = *(undefined8 **)(classTypeID + 0x50); tempPtrVar != (undefined8 *)0x0;\n        tempPtrVar = (undefined8 *)*tempPtrVar) {\n      debugTypeKindPtr = (int *)tempPtrVar[1];\n      if (*debugTypeKindPtr == *debugTypeKind) {\n        debugClassName = (char *)tempPtrVar[2];\n        if (className == (char *)0x0) {\n          if (debugClassName == (char *)0x0) {\nLAB_0010c82c:\n            isSameType = debug_type_samep(classTypeID,debugTypeKindPtr,debugTypeKind);\n            if (isSameType != '\\0') {\n              tempVar2 = *(uint *)(*(long *)(tempPtrVar[1] + 0x10) + 0xc);\n              tempPtrVar = (undefined8 *)(ulong)tempVar2;\n              *(uint *)(tempVar3 + 0xc) = tempVar2;\n              goto LAB_0010c884;\n            }\n          }\n        }\n        else if (((debugClassName != (char *)0x0) && (*debugClassName == *className)) &&\n                (counter = strcmp(debugClassName,className), counter == 0)) goto LAB_0010c82c;\n      }\n    }\n    counter = *(int *)(classTypeID + 0x34) + 1;\n    *(int *)(classTypeID + 0x34) = counter;\n    *(int *)(tempVar3 + 0xc) = counter;\n    tempPtrVar = (undefined8 *)xmalloc(0x18);\n    tempVar1 = *(undefined8 *)(classTypeID + 0x50);\n    tempPtrVar[2] = className;\n    *(undefined8 **)(classTypeID + 0x50) = tempPtrVar;\n    *tempPtrVar = tempVar1;\n    tempPtrVar[1] = debugTypeKind;\n  }\nLAB_0010c884:\n  returnVal._1_7_ = (undefined7)((ulong)tempPtrVar >> 8);\n  returnVal[0] = 1;\n  returnVal._8_8_ = debugInfo;\n  return returnVal;\n}\n\n",
            "called": [
                "debug_type_samep",
                "__assert_fail",
                "xmalloc",
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c7a0",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "set_debug_class_id_0010c7a0"
        },
        "FUN_0010922b": {
            "renaming": {
                "FUN_0010922b": "compare_values_0010922b",
                "param_1": "param1",
                "param_2": "values1",
                "param_3": "values2",
                "uVar1": "val1_type",
                "uVar2": "val2_type",
                "pplVar3": "val2_refs",
                "ppcVar4": "str1_refs",
                "ppcVar5": "str2_refs",
                "lVar6": "val1",
                "lVar7": "val1_type2",
                "lVar8": "val2_type2",
                "pcVar9": "str1",
                "pcVar10": "str2",
                "cVar11": "result",
                "bVar12": "returnValue",
                "iVar13": "cmpResult",
                "uVar14": "debug_type1",
                "uVar15": "debug_type2",
                "puVar16": "debug_type1_ptr",
                "puVar17": "debug_type2_ptr",
                "plVar18": "ptr1",
                "lVar19": "offset",
                "plVar20": "debug_refs1",
                "plVar21": "debug_refs2",
                "lVar22": "ptr1_deref",
                "local_70": "ptr2_deref",
                "local_58": "debug_refs_list",
                "plStack_50": "ptr1_stack",
                "local_48": "ptr2_stack"
            },
            "code": "\nbyte compareValues_0010922b(long param1,long *values1,long *values2)\n\n{\n  uint val1_type;\n  uint val2_type;\n  long **val2_refs;\n  char **str1_refs;\n  char **str2_refs;\n  long val1;\n  long val1_type2;\n  long val2_type2;\n  char *str1;\n  char *str2;\n  char result;\n  byte returnValue;\n  int cmpResult;\n  undefined8 debug_type1;\n  undefined8 debug_type2;\n  undefined8 *debug_type1_ptr;\n  undefined8 *debug_type2_ptr;\n  long *ptr1;\n  long offset;\n  long *debug_refs1;\n  long *debug_refs2;\n  long ptr1_deref;\n  long *ptr2_deref;\n  undefined8 *debug_refs_list;\n  long *ptr1_stack;\n  long *ptr2_stack;\n  \n  ptr1 = values2;\n  if (values1 == (long *)0x0) {\nLAB_00109241:\n    return values2 == (long *)0x0;\n  }\njoined_r0x00109255:\n  if (ptr1 == (long *)0x0) {\n    return false;\n  }\n  while( true ) {\n    val1_type = *(uint *)values1;\n    if (val1_type == 1) goto code_r0x00109263;\n    while (val2_type = *(uint *)values2, val2_type == 1) {\n      values2 = **(long ***)values2[2];\n      if (values2 == (long *)0x0) {\n        return false;\n      }\n    }\n    if (values1 == values2) {\n      return true;\n    }\n    if (val1_type != 0x16) break;\n    if (val2_type != 0x17) goto LAB_001092cb;\n    values1 = *(long **)(values1[2] + 8);\n    if (values1 == (long *)0x0) goto LAB_00109241;\n  }\n  if ((val1_type == 0x17) && (val2_type == 0x16)) {\n    values2 = *(long **)(values2[2] + 8);\n    ptr1 = values2;\n    goto joined_r0x00109255;\n  }\nLAB_001092cb:\n  if (*values1 != *values2) {\n    return false;\n  }\n  if (val1_type == 3) {\n    return *(char *)(values1 + 2) == *(char *)(values2 + 2);\n  }\n  if (val1_type < 4) {\n    if (val1_type == 2) {\n      return true;\n    }\n  }\n  else if (val1_type - 4 < 3) {\n    return true;\n  }\n  debug_refs_list = *(undefined8 **)(param1 + 0x58);\n  for (debug_type2_ptr = debug_refs_list; debug_type2_ptr != (undefined8 *)0x0; debug_type2_ptr = (undefined8 *)*debug_type2_ptr) {\n    if (((long *)debug_type2_ptr[1] == values1) && ((long *)debug_type2_ptr[2] == values2)) {\n      return true;\n    }\n  }\n  *(undefined8 ***)(param1 + 0x58) = &debug_refs_list;\n  ptr1_stack = values1;\n  ptr2_stack = values2;\n  switch(val1_type) {\n  case 7:\n  case 8:\n  case 9:\n  case 10:\n    ptr1 = (long *)values1[2];\n    val2_refs = (long **)values2[2];\n    if (ptr1 == (long *)0x0) {\n      returnValue = val2_refs == (long **)0x0;\n      goto LAB_001099c4;\n    }\n    if (val2_refs == (long **)0x0) goto LAB_00109382;\n    if ((*(uint *)(param1 + 0x38) < *(uint *)((long)ptr1 + 0xc)) &&\n       (*(uint *)((long)ptr1 + 0xc) == *(uint *)((long)val2_refs + 0xc))) goto LAB_001097af;\n    debug_type2_ptr = (undefined8 *)*ptr1;\n    ptr2_deref = *val2_refs;\n    if (((debug_type2_ptr == (undefined8 *)0x0) == (ptr2_deref == (long *)0x0)) &&\n       ((((ptr1[2] == 0) == (val2_refs[2] == (long *)0x0) &&\n         ((ptr1[3] == 0) == (val2_refs[3] == (long *)0x0))) &&\n        ((ptr1[4] == 0) == (val2_refs[4] == (long *)0x0))))) {\n      if (debug_type2_ptr == (undefined8 *)0x0) {\nLAB_001093fd:\n        if ((ptr1[4] != 0) &&\n           (result = compareValues_0010922b(param1,ptr1[4],val2_refs[4]), result == '\\0'))\n        goto LAB_00109382;\n        debug_refs2 = (long *)ptr1[2];\n        if (debug_refs2 == (long *)0x0) {\nLAB_00109540:\n          debug_type2_ptr = (undefined8 *)ptr1[3];\n          if (debug_type2_ptr == (undefined8 *)0x0) goto LAB_001097af;\n          ptr1 = val2_refs[3];\n          while( true ) {\n            str2_refs = (char **)*debug_type2_ptr;\n            if (str2_refs == (char **)0x0) {\n              returnValue = *ptr1 == 0;\n              goto LAB_001099c4;\n            }\n            str1_refs = (char **)*ptr1;\n            if (str1_refs == (char **)0x0) break;\n            if ((**str2_refs != **str1_refs) || (cmpResult = strcmp(*str2_refs,*str1_refs), cmpResult != 0))\n            break;\n            str1 = str2_refs[1];\n            str2 = str1_refs[1];\n            if ((str1 == (char *)0x0) != (str2 == (char *)0x0)) break;\n            if (str1 != (char *)0x0) {\n              ptr1_deref = 0;\n              while( true ) {\n                str2_refs = *(char ***)(str1 + ptr1_deref);\n                str1_refs = *(char ***)(str2 + ptr1_deref);\n                if (str2_refs == (char **)0x0) break;\n                if (str1_refs == (char **)0x0) goto LAB_00109382;\n                if ((((**str2_refs != **str1_refs) ||\n                     ((((ulong)str2_refs[2] ^ (ulong)str1_refs[2]) & 0xffffffffffff) != 0)) ||\n                    ((str2_refs[3] != str1_refs[3] ||\n                     ((((str2_refs[4] == (char *)0x0) != (str1_refs[4] == (char *)0x0) ||\n                       (cmpResult = strcmp(*str2_refs,*str1_refs), cmpResult != 0)) ||\n                      (result = compareValues_0010922b(param1,str2_refs[1],str1_refs[1]), result == '\\0')))))) ||\n                   ((str2_refs[4] != (char *)0x0 &&\n                    (result = compareValues_0010922b(param1,str2_refs[4],str1_refs[4]), result == '\\0'))))\n                goto LAB_00109382;\n                ptr1_deref = ptr1_deref + 8;\n              }\n              if (str1_refs == (char **)0x0) goto LAB_001095f1;\n              break;\n            }\nLAB_001095f1:\n            debug_type2_ptr = debug_type2_ptr + 1;\n            ptr1 = ptr1 + 1;\n          }\n        }\n        else {\n          debug_refs1 = val2_refs[2];\n          for (; debug_type2_ptr = (undefined8 *)*debug_refs2, debug_type2_ptr != (undefined8 *)0x0;\n              debug_refs2 = debug_refs2 + 1) {\n            debug_type1_ptr = (undefined8 *)*debug_refs1;\n            if ((((debug_type1_ptr == (undefined8 *)0x0) ||\n                 (((debug_type2_ptr[1] ^ debug_type1_ptr[1]) & 0xffffffffff) != 0)) ||\n                (*(int *)(debug_type2_ptr + 2) != *(int *)(debug_type1_ptr + 2))) ||\n               (result = compareValues_0010922b(param1,*debug_type2_ptr,*debug_type1_ptr), result == '\\0'))\n            goto LAB_00109382;\n            debug_refs1 = debug_refs1 + 1;\n          }\n          if (*debug_refs1 == 0) goto LAB_00109540;\n        }\n      }\n      else {\n        for (; str2_refs = (char **)*debug_type2_ptr, str2_refs != (char **)0x0; debug_type2_ptr = debug_type2_ptr + 1) {\n          str1_refs = (char **)*ptr2_deref;\n          if (str1_refs == (char **)0x0) goto LAB_00109382;\n          str1 = *str1_refs;\n          str2 = *str2_refs;\n          if ((*str2 != *str1) ||\n             ((((ulong)str2_refs[2] ^ (ulong)str1_refs[2]) & 0xffffffffff) != 0)) goto LAB_00109382;\n          if (*(char *)((long)str2_refs + 0x14) == '\\0') {\n            if (str2_refs[3] == str1_refs[3]) goto LAB_00109480;\n            goto LAB_00109382;\n          }\n          cmpResult = strcmp(str2_refs[3],str1_refs[3]);\n          if (cmpResult != 0) goto LAB_00109382;\nLAB_00109480:\n          cmpResult = strcmp(str2,str1);\n          if (((cmpResult != 0) || (str2_refs[1] == (char *)0x0)) || (str1_refs[1] == (char *)0x0))\n          goto LAB_00109382;\n          debug_type1 = debug_get_real_type_isra_0(str1_refs[1],0);\n          debug_type2 = debug_get_real_type_isra_0(str2_refs[1],0);\n          result = compareValues_0010922b(param1,debug_type2,debug_type1);\n          if (result == '\\0') goto LAB_00109382;\n          ptr2_deref = ptr2_deref + 1;\n        }\n        if (*ptr2_deref == 0) goto LAB_001093fd;\n      }\n    }\n    goto LAB_00109382;\n  case 0xb:\n    ptr1 = (long *)values1[2];\n    debug_refs2 = (long *)values2[2];\n    if (ptr1 == (long *)0x0) {\n      returnValue = debug_refs2 == (long *)0x0;\n      goto LAB_001099c4;\n    }\n    if (debug_refs2 == (long *)0x0) goto LAB_00109382;\n    ptr1_deref = *ptr1;\n    val1 = *debug_refs2;\n    offset = 0;\n    val1_type2 = ptr1[1];\n    val2_type2 = debug_refs2[1];\n    do {\n      str1 = *(char **)(ptr1_deref + offset);\n      if (str1 == (char *)0x0) {\n        returnValue = *(long *)(val1 + offset) == 0;\n        goto LAB_001099c1;\n      }\n      str2 = *(char **)(val1 + offset);\n      if (((str2 == (char *)0x0) || (*str1 != *str2)) ||\n         (*(long *)(val1_type2 + offset) != *(long *)(val2_type2 + offset))) break;\n      cmpResult = strcmp(str1,str2);\n      offset = offset + 8;\n    } while (cmpResult == 0);\nLAB_00109964:\n    returnValue = 0;\n    break;\n  case 0xc:\n  case 0xe:\n  case 0x14:\n  case 0x15:\n    returnValue = compareValues_0010922b(param1,values1[2],values2[2]);\n    goto LAB_001099c4;\n  case 0xd:\n    if ((*(char *)((undefined8 *)values1[2] + 2) == *(char *)((undefined8 *)values2[2] + 2)) &&\n       (result = compareValues_0010922b(param1,*(undefined8 *)values1[2],*(undefined8 *)values2[2]),\n       result != '\\0')) {\n      ptr1 = *(long **)(values1[2] + 8);\n      debug_refs2 = *(long **)(values2[2] + 8);\n      if ((ptr1 == (long *)0x0) == (debug_refs2 == (long *)0x0)) {\n        if (ptr1 == (long *)0x0) goto LAB_001097af;\n        while (((*ptr1 != 0 && (*debug_refs2 != 0)) &&\n               (result = compareValues_0010922b(param1), result != '\\0'))) {\n          ptr1 = ptr1 + 1;\n          debug_refs2 = debug_refs2 + 1;\n        }\nLAB_0010995d:\n        if (*ptr1 != 0) goto LAB_00109964;\n        returnValue = *debug_refs2 == 0;\n        break;\n      }\n    }\n    goto LAB_00109382;\n  case 0xf:\n    debug_type2_ptr = (undefined8 *)values2[2];\n    debug_type1_ptr = (undefined8 *)values1[2];\n    returnValue = 0;\n    if ((debug_type1_ptr[1] == debug_type2_ptr[1]) && (debug_type1_ptr[2] == debug_type2_ptr[2])) {\nLAB_00109862:\n      returnValue = compareValues_0010922b(param1,*debug_type1_ptr,*debug_type2_ptr);\n    }\n    break;\n  case 0x10:\n    debug_type2_ptr = (undefined8 *)values2[2];\n    debug_type1_ptr = (undefined8 *)values1[2];\n    returnValue = 0;\n    if (((debug_type1_ptr[2] == debug_type2_ptr[2]) && (debug_type1_ptr[3] == debug_type2_ptr[3])) &&\n       (*(char *)(debug_type1_ptr + 4) == *(char *)(debug_type2_ptr + 4))) goto LAB_00109862;\n    break;\n  case 0x11:\n    debug_type2_ptr = (undefined8 *)values2[2];\n    debug_type1_ptr = (undefined8 *)values1[2];\n    returnValue = 0;\n    if (*(char *)(debug_type1_ptr + 1) == *(char *)(debug_type2_ptr + 1)) goto LAB_00109862;\n    break;\n  case 0x12:\n    result = compareValues_0010922b(param1,*(undefined8 *)values1[2],*(undefined8 *)values2[2]);\n    returnValue = 0;\n    if (result != '\\0') {\n      returnValue = compareValues_0010922b(param1,*(undefined8 *)(values1[2] + 8),*(undefined8 *)(values2[2] + 8))\n      ;\n    }\n    break;\n  case 0x13:\n    if (((*(char *)((undefined8 *)values1[2] + 3) == *(char *)((undefined8 *)values2[2] + 3)) &&\n        (result = compareValues_0010922b(param1,*(undefined8 *)values1[2],*(undefined8 *)values2[2]),\n        result != '\\0')) &&\n       (result = compareValues_0010922b(param1,*(undefined8 *)(values1[2] + 8),\n                              *(undefined8 *)(values2[2] + 8)), result != '\\0')) {\n      ptr1 = *(long **)(values1[2] + 0x10);\n      debug_refs2 = *(long **)(values2[2] + 0x10);\n      if ((ptr1 == (long *)0x0) == (debug_refs2 == (long *)0x0)) {\n        if (ptr1 != (long *)0x0) {\n          while (((*ptr1 != 0 && (*debug_refs2 != 0)) &&\n                 (result = compareValues_0010922b(param1), result != '\\0'))) {\n            ptr1 = ptr1 + 1;\n            debug_refs2 = debug_refs2 + 1;\n          }\n          goto LAB_0010995d;\n        }\nLAB_001097af:\n        returnValue = 1;\n        goto LAB_001099c4;\n      }\n    }\nLAB_00109382:\n    returnValue = 0;\n    goto LAB_001099c4;\n  case 0x16:\n  case 0x17:\n    ptr1 = (long *)values2[2];\n    debug_refs2 = (long *)values1[2];\n    cmpResult = strcmp(*(char **)(*debug_refs2 + 8),*(char **)(*ptr1 + 8));\n    returnValue = 0;\n    if (cmpResult == 0) {\n      returnValue = compareValues_0010922b(param1,debug_refs2[1],ptr1[1]);\n    }\n    break;\n  default:\n                    \n    abort();\n  }\nLAB_001099c1:\n  returnValue = returnValue & 1;\nLAB_001099c4:\n  *(undefined8 **)(param1 + 0x58) = debug_refs_list;\n  return returnValue;\ncode_r0x00109263:\n  values1 = **(long ***)values1[2];\n  ptr1 = values1;\n  goto joined_r0x00109255;\n}\n\n",
            "called": [
                "debug_type_samep",
                "debug_get_real_type.isra.0",
                "abort",
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010922b",
            "calling": [
                "debug_type_samep",
                "debug_set_class_id.lto_priv.0"
            ],
            "imported": false,
            "current_name": "compare_values_0010922b"
        },
        "FUN_00104900": {
            "renaming": {},
            "code": "\nvoid bfd_close_all_done(void)\n\n{\n  bfd_close_all_done();\n  return;\n}\n\n",
            "called": [
                "bfd_close_all_done"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104900",
            "calling": [
                "FUN_00104ea2",
                "copy_file",
                "do_display_target"
            ],
            "imported": false,
            "current_name": "FUN_00104900"
        },
        "FUN_00104908": {
            "renaming": {},
            "code": "\nvoid bfd_close(void)\n\n{\n  bfd_close();\n  return;\n}\n\n",
            "called": [
                "bfd_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104908",
            "calling": [
                "copy_file",
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "FUN_00104908"
        },
        "FUN_001052a2": {
            "renaming": {
                "FUN_001052a2": "extract_and_copy_archived_files_001052a2",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "path",
                "cVar1": "result",
                "iVar2": "archType",
                "iVar3": "statResult",
                "ppcVar4": "entryPoint",
                "lVar5": "totalSize",
                "uVar6": "formatString",
                "puVar7": "tempDir",
                "piVar8": "errorNum",
                "uVar9": "errorMessage",
                "in_RAX": "fileOffset",
                "pcVar10": "currentChar",
                "ppcVar11": "archiveFile",
                "lVar12": "fileSize",
                "pvVar13": "buffer",
                "pcVar14": "closeFunc",
                "lVar15": "copySize",
                "pcVar16": "nextChar",
                "psVar17": "statStruct",
                "unaff_R14": "fileItems",
                "unaff_R15": "archiveHandle",
                "bVar18": "stackVar",
                "unaff_retaddr": "returnAddress",
                "in_stack_00000008": "sourceFilePath",
                "in_stack_00000010": "fileSizeAddr",
                "in_stack_00000018": "tempDirPath",
                "in_stack_00000020": "destFilePath",
                "in_stack_00000028": "fileMode",
                "in_stack_00000030": "fileOpenedWithTemp",
                "in_stack_000000f8": "modeMask",
                "in_stack_00000110": "fileSizeLimit"
            },
            "code": "\nvoid extractAndCopyArchivedFiles_001052a2(undefined8 param1,undefined8 param2,char *path)\n\n{\n  char result;\n  int archType;\n  int statResult;\n  char **entryPoint;\n  long totalSize;\n  undefined8 formatString;\n  char *__format;\n  undefined8 *tempDir;\n  int *errorNum;\n  undefined8 errorMessage;\n  long fileOffset;\n  char *currentChar;\n  char **archiveFile;\n  long fileSize;\n  void *buffer;\n  code *closeFunc;\n  long copySize;\n  char *nextChar;\n  stat *statStruct;\n  undefined8 *fileItems;\n  char **archiveHandle;\n  byte stackVar;\n  undefined8 returnAddress;\n  undefined8 *sourceFilePath;\n  long *fileSizeAddr;\n  char *tempDirPath;\n  undefined8 *destFilePath;\n  undefined8 fileMode;\n  undefined8 fileOpenedWithTemp;\n  uint modeMask;\n  long fileSizeLimit;\n  \n  stackVar = 0;\n  currentChar = (char *)(fileOffset + 1);\n  do {\n    if (*currentChar == '/') {\n      extractAndCopyArchivedFiles_001052a2();\n      return;\n    }\n    while (*currentChar == '\\0') {\n      currentChar = (char *)concat(tempDirPath,&DAT_0011b47d);\n      statResult = stat(currentChar,(stat *)&stack0x00000050);\n      tempDir = fileItems;\n      if (-1 < statResult) {\n        fileSize = make_tempdir(currentChar);\n        free(currentChar);\n        if (fileSize == 0) {\n          errorNum = __errno_location();\n          currentChar = strerror(*errorNum);\n          errorMessage = dcgettext(0,\"cannot create tempdir for archive copying (error: %s)\",5);\n          non_fatal(errorMessage,currentChar);\n          goto LAB_00104e93;\n        }\n        tempDir = (undefined8 *)xmalloc(0x18);\n        currentChar = *archiveHandle;\n        *tempDir = fileItems;\n        tempDir[2] = 0;\n        tempDir[1] = fileSize;\n        currentChar = (char *)concat(fileSize,&DAT_0011b47d,currentChar);\n      }\n      statResult = 0;\n      if (preserve_dates != '\\0') {\n        statStruct = (stat *)&stack0x00000050;\n        for (fileSize = 0x24; fileSize != 0; fileSize = fileSize + -1) {\n          *(undefined4 *)&statStruct->st_dev = 0;\n          statStruct = (stat *)((long)statStruct + (ulong)stackVar * -8 + 4);\n        }\n        archiveFile = (char **)archiveHandle[0x1d];\n        if ((char **)archiveHandle[0x1d] == (char **)0x0) {\n          archiveFile = archiveHandle;\n        }\n        statResult = (**(code **)(archiveFile[1] + 0x1e8))(archiveHandle,(stat *)&stack0x00000050);\n        if (statResult != 0) {\n          nextChar = *archiveHandle;\n          errorMessage = dcgettext(0,\"internal stat error on %s\",5);\n          non_fatal(errorMessage,nextChar);\n        }\n      }\n      fileItems = (undefined8 *)xmalloc(0x18);\n      fileItems[1] = currentChar;\n      *fileItems = tempDir;\n      fileItems[2] = 0;\n      result = bfd_check_format(archiveHandle,1);\n      if (result == '\\0') {\n        errorMessage = dcgettext(0,\"Unable to recognise the format of file\",5);\n        bfd_nonfatal_message(0,archiveHandle,0,errorMessage);\n        archiveFile = (char **)bfd_openw(currentChar,fileMode);\n        if (archiveFile == (char **)0x0) goto LAB_00104e80;\nLAB_00104d75:\n        entryPoint = (char **)archiveHandle[0x1d];\n        if ((char **)archiveHandle[0x1d] == (char **)0x0) {\n          entryPoint = archiveHandle;\n        }\n        archType = (**(code **)(entryPoint[1] + 0x1e8))(archiveHandle,&stack0x000000e0);\n        fileSize = fileSizeLimit;\n        if (archType == 0) {\n          if (fileSizeLimit < 0) {\n            errorMessage = bfd_get_archive_filename(archiveHandle);\n            formatString = dcgettext(0,\"stat returns negative size for `%s\\'\",5);\n            non_fatal(formatString,errorMessage);\n          }\n          else {\n            archType = bfd_seek(archiveHandle,0,0);\n            if (archType == 0) {\n              if (verbose != '\\0') {\n                nextChar = *archiveFile;\n                errorMessage = bfd_get_archive_filename(archiveHandle);\n                __format = (char *)dcgettext(0,\"copy from `%s\\' [unknown] to `%s\\' [unknown]\\n\",5);\n                printf(__format,errorMessage,nextChar);\n              }\n              buffer = (void *)xmalloc(0x2000);\n              for (; fileSize != 0; fileSize = fileSize - copySize) {\n                copySize = 0x2000;\n                if (fileSize < 0x2001) {\n                  copySize = fileSize;\n                }\n                totalSize = bfd_bread(buffer,copySize,archiveHandle);\n                entryPoint = archiveHandle;\n                if ((copySize != totalSize) ||\n                   (totalSize = bfd_bwrite(buffer,copySize,archiveFile), entryPoint = archiveFile, copySize != totalSize\n                   )) {\n                  bfd_nonfatal_message(0,entryPoint,0,0);\n                  free(buffer);\n                  goto LAB_00104f00;\n                }\n              }\n              chmod(*archiveFile,modeMask | 0x100);\n              free(buffer);\n              result = bfd_close_all_done(archiveFile);\n              if (result == '\\0') {\n                bfd_nonfatal_message(currentChar,0,0,0);\n                status = 1;\n              }\n              goto LAB_00114a86;\n            }\n            errorMessage = bfd_get_archive_filename(archiveHandle);\n            bfd_nonfatal(errorMessage);\n          }\n        }\n        else {\n          bfd_nonfatal_message(0,archiveHandle,0,0);\n        }\nLAB_00104f00:\n        result = bfd_close_all_done(archiveFile);\n        if (result == '\\0') {\n          bfd_nonfatal_message(currentChar,0,0,0);\n        }\nLAB_00104ec9:\n        unlink(currentChar);\n        status = 1;\n      }\n      else {\n        if (fileOpenedWithTemp._7_1_ == '\\0') {\n          archiveFile = (char **)bfd_openw(currentChar,*(undefined8 *)archiveHandle[1]);\n        }\n        else {\n          archiveFile = (char **)bfd_openw(currentChar,fileMode);\n        }\n        if (archiveFile == (char **)0x0) {\nLAB_00104e80:\n          bfd_nonfatal_message(currentChar,0,0,0);\n          goto LAB_00104e93;\n        }\n        result = copy_object(archiveHandle,archiveFile,returnAddress);\n        if (result == '\\0') {\n          archType = bfd_get_arch(archiveHandle);\n          if (archType == 0) goto LAB_00104d75;\n          result = bfd_close_all_done(archiveFile);\n          if (result == '\\0') {\n            bfd_nonfatal_message(currentChar,0,0,0);\n          }\n          goto LAB_00104ec9;\n        }\n        result = bfd_close(archiveFile);\n        if (result == '\\0') {\n          bfd_nonfatal_message(currentChar,0,0,0);\n          status = 1;\n        }\nLAB_00114a86:\n        if ((preserve_dates != '\\0') && (statResult == 0)) {\n          set_times(currentChar,(stat *)&stack0x00000050);\n        }\n        fileSize = bfd_openr(currentChar,fileMode);\n        fileItems[2] = fileSize;\n        *fileSizeAddr = fileSize;\n        fileSizeAddr = (long *)(fileSize + 0xf0);\n        archiveFile = (char **)bfd_openr_next_archived_file(destFilePath,archiveHandle);\n        bfd_close(archiveHandle);\n        archiveHandle = archiveFile;\n      }\n      if ((status != 0) || (archiveHandle == (char **)0x0)) {\n        *fileSizeAddr = 0;\n        buffer = (void *)xstrdup(*sourceFilePath);\n        if (status == 0) {\n          closeFunc = bfd_close;\n        }\n        else {\n          closeFunc = bfd_close_all_done;\n        }\n        result = (*closeFunc)(sourceFilePath);\n        if (result == '\\0') {\n          status = 1;\n          bfd_nonfatal_message(buffer,0,0,0);\n        }\n        free(buffer);\n        buffer = (void *)xstrdup(*destFilePath);\n        result = bfd_close(destFilePath);\n        if (result == '\\0') {\n          status = 1;\n          bfd_nonfatal_message(buffer,0,0,0);\n        }\n        free(buffer);\n        goto LAB_00114b4b;\n      }\n      currentChar = *archiveHandle;\n      path = currentChar;\n      if (*currentChar == '/') goto LAB_0010527d;\n    }\n    nextChar = currentChar;\n    if ((*currentChar == '.') && (nextChar = currentChar + 1, currentChar[1] == '.')) {\n      nextChar = currentChar + 2;\n      if ((currentChar[2] == '\\0') || (currentChar[2] == '/')) {\nLAB_0010527d:\n        errorMessage = dcgettext(0,\"illegal pathname found in archive member: %s\",5);\n        non_fatal(errorMessage,path);\nLAB_00104e93:\n        status = 1;\nLAB_00114b4b:\n        while (fileItems != (undefined8 *)0x0) {\n          if (fileItems[2] == 0) {\n            rmdir((char *)fileItems[1]);\n          }\n          else {\n            bfd_close();\n            unlink((char *)fileItems[1]);\n          }\n          free((void *)fileItems[1]);\n          tempDir = (undefined8 *)*fileItems;\n          free(fileItems);\n          fileItems = tempDir;\n        }\n        rmdir(tempDirPath);\n        free(tempDirPath);\n        return;\n      }\n    }\n    for (; (currentChar = nextChar, *nextChar != '\\0' && (*nextChar != '/')); nextChar = nextChar + 1) {\n    }\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001052a2",
            "calling": [
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "extract_and_copy_archived_files_001052a2"
        },
        "FUN_001041b0": {
            "renaming": {},
            "code": "\nvoid bfd_stat(void)\n\n{\n  bfd_stat();\n  return;\n}\n\n",
            "called": [
                "bfd_stat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001041b0",
            "calling": [
                "copy_file"
            ],
            "imported": false,
            "current_name": "FUN_001041b0"
        },
        "FUN_001043f0": {
            "renaming": {},
            "code": "\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043f0",
            "calling": [
                "stab_context",
                "list_matching_formats",
                "list_supported_targets"
            ],
            "imported": false,
            "current_name": "FUN_001043f0"
        },
        "FUN_001042d0": {
            "renaming": {},
            "code": "\n\n\nint dup(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = dup(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "dup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001042d0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001042d0"
        },
        "FUN_0010e453": {
            "renaming": {
                "FUN_0010e453": "extract_and_push_symbol_0010e453",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "lVar1": "loopVar1",
                "cVar2": "charVar",
                "sVar3": "strLen",
                "__s": "newString",
                "uVar4": "returnValue",
                "lVar5": "loopVar2",
                "ppcVar6": "ptrArrayVar",
                "lVar7": "loopVar3"
            },
            "code": "\nundefined8 extractAndPushSymbol_0010e453(long arg1,char *arg2,char **arg3)\n\n{\n  long loopVar1;\n  char charVar;\n  size_t strLen;\n  undefined2 *newString;\n  undefined8 returnValue;\n  long loopVar2;\n  char **ptrArrayVar;\n  long loopVar3;\n  \n  if (arg3 == (char **)0x0) {\n    if (arg2 != (char *)0x0) {\n      strLen = strlen(arg2);\n      newString = (undefined2 *)xmalloc(strLen + 10);\n      sprintf((char *)newString,\"xe%s:\",arg2);\nLAB_0010e578:\n      charVar = stab_push_string(arg1,newString,0,0,4);\n      if (charVar != '\\0') goto LAB_0010e58b;\n    }\nLAB_0010e475:\n    returnValue = 0;\n  }\n  else {\n    loopVar2 = 10;\n    ptrArrayVar = arg3;\n    if (arg2 != (char *)0x0) {\n      strLen = strlen(arg2);\n      loopVar2 = strLen + 10;\n    }\n    for (; *ptrArrayVar != (char *)0x0; ptrArrayVar = ptrArrayVar + 1) {\n      strLen = strlen(*ptrArrayVar);\n      loopVar2 = loopVar2 + 0x14 + strLen;\n    }\n    newString = (undefined2 *)xmalloc(loopVar2);\n    if (arg2 == (char *)0x0) {\n      *newString = 0x65;\n      loopVar2 = 0;\n    }\n    else {\n      loopVar2 = *(long *)(arg1 + 0x68);\n      *(long *)(arg1 + 0x68) = loopVar2 + 1;\n      sprintf((char *)newString,\"%s:T%ld=e\",arg2,loopVar2);\n    }\n    loopVar3 = 0;\n    while( true ) {\n      loopVar1 = *(long *)((long)arg3 + loopVar3);\n      strLen = strlen((char *)newString);\n      if (loopVar1 == 0) break;\n      loopVar3 = loopVar3 + 8;\n      sprintf((char *)(undefined2 *)((long)newString + strLen),\"%s:%ld,\");\n    }\n    *(undefined2 *)((long)newString + strLen) = 0x3b;\n    if (arg2 == (char *)0x0) goto LAB_0010e578;\n    charVar = stab_write_symbol_lto_priv_0(arg1,0x80,0,0,newString);\n    if ((charVar == '\\0') || (charVar = stab_push_defined_type(arg1,loopVar2,4), charVar == '\\0'))\n    goto LAB_0010e475;\nLAB_0010e58b:\n    free(newString);\n    returnValue = 1;\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "strlen",
                "stab_push_string",
                "stab_write_symbol.lto_priv.0",
                "sprintf",
                "stab_push_defined_type",
                "free",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e453",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "extract_and_push_symbol_0010e453"
        },
        "FUN_00109d5c": {
            "renaming": {
                "FUN_00109d5c": "push_defined_struct_00109d5c",
                "param_1": "inputParam",
                "lVar1": "structIndex",
                "uVar2": "result"
            },
            "code": "\nundefined8 pushDefinedStruct_00109d5c(undefined8 inputParam)\n\n{\n  long structIndex;\n  undefined8 result;\n  \n  structIndex = stab_get_struct_index();\n  if (-1 < structIndex) {\n    result = stab_push_defined_type(inputParam,structIndex,0);\n    return result;\n  }\n  return 0;\n}\n\n",
            "called": [
                "stab_push_defined_type",
                "stab_get_struct_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109d5c",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "push_defined_struct_00109d5c"
        },
        "FUN_0010ed2c": {
            "renaming": {
                "FUN_0010ed2c": "update_symbol_0010ed2c",
                "param_1": "symbolTable",
                "param_2": "newValue",
                "param_3": "additionalValue",
                "cVar1": "successFlag",
                "iVar2": "counter",
                "extraout_RDX": "outputValue",
                "uVar3": "result",
                "in_R10": "inputValue",
                "auVar4": "returnValue"
            },
            "code": "\nundefined  [16] updateSymbol_0010ed2c(long symbolTable,ulong newValue,undefined8 additionalValue)\n\n{\n  char successFlag;\n  int counter;\n  undefined8 outputValue;\n  ulong result;\n  undefined8 inputValue;\n  undefined returnValue [16];\n  \n  if (*(ulong *)(symbolTable + 0x1f0) < newValue) {\n    *(ulong *)(symbolTable + 0x1f0) = newValue;\n  }\n  if (*(long *)(symbolTable + 0x208) == -1) {\nLAB_0010ed78:\n    if (*(int *)(symbolTable + 0x1f8) != 0) {\n      counter = *(int *)(symbolTable + 0x1f8) + -1;\n      result = CONCAT71((int7)((ulong)additionalValue >> 8),1);\n      *(int *)(symbolTable + 0x1f8) = counter;\n      if (counter != 0) {\n        returnValue = stab_write_symbol_lto_priv_0\n                           (symbolTable,0xe0,0,newValue - *(long *)(symbolTable + 0x200),0,inputValue);\n        return returnValue;\n      }\n      goto LAB_0010edae;\n    }\n  }\n  else {\n    successFlag = stab_write_symbol_lto_priv_0(symbolTable,0xc0,0,*(long *)(symbolTable + 0x208),0);\n    if (successFlag != '\\0') {\n      *(undefined8 *)(symbolTable + 0x208) = 0xffffffffffffffff;\n      additionalValue = outputValue;\n      goto LAB_0010ed78;\n    }\n  }\n  result = 0;\nLAB_0010edae:\n  returnValue._0_8_ = result & 0xffffffff;\n  returnValue._8_8_ = inputValue;\n  return returnValue;\n}\n\n",
            "called": [
                "stab_write_symbol.lto_priv.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010ed2c",
            "calling": [
                "debug_write_block.constprop.0"
            ],
            "imported": false,
            "current_name": "update_symbol_0010ed2c"
        },
        "FUN_001284e8": {
            "renaming": {},
            "code": "\n\n\nvoid __cxa_finalize(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __cxa_finalize@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001284e8",
            "calling": [
                "__cxa_finalize"
            ],
            "imported": false,
            "current_name": "FUN_001284e8"
        },
        "FUN_001283c8": {
            "renaming": {},
            "code": "\n\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memmove@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001283c8",
            "calling": [
                "memmove"
            ],
            "imported": false,
            "current_name": "FUN_001283c8"
        },
        "FUN_0010e451": {
            "renaming": {},
            "code": "\nvoid stab_start_source_lto_priv_0(long param_1,undefined8 param_2)\n\n{\n  *(undefined8 *)(param_1 + 0x210) = param_2;\n  stab_write_symbol_lto_priv_0(param_1,0x84,0,0,param_2);\n  return;\n}\n\n",
            "called": [
                "stab_start_source.lto_priv.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e451",
            "calling": [
                "write_stabs_in_sections_debugging_info.constprop.0"
            ],
            "imported": false,
            "current_name": "FUN_0010e451"
        },
        "FUN_0011a1b0": {
            "renaming": {
                "FUN_0011a1b0": "compare_memory_blocks_0011a1b0",
                "param_1": "block1",
                "param_2": "block2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "block1Size",
                "uVar2": "block2Size",
                "iVar3": "comparisonResult",
                "extraout_var": "extraOutput",
                "uVar4": "finalResult",
                "auVar5": "returnVal"
            },
            "code": "\nundefined  [16] compareMemoryBlocks_0011a1b0(ulong *block1,ulong *block2,undefined8 param3,undefined8 param4)\n\n{\n  ulong block1Size;\n  ulong block2Size;\n  int comparisonResult;\n  undefined4 extraOutput;\n  ulong finalResult;\n  undefined returnVal [16];\n  \n  finalResult = *block1;\n  if (*block2 <= *block1) {\n    finalResult = *block2;\n  }\n  comparisonResult = memcmp((void *)(block1[3] + 3),(void *)(block2[3] + 3),finalResult - 3);\n  finalResult = CONCAT44(extraOutput,comparisonResult);\n  if (comparisonResult == 0) {\n    block1Size = block1[8];\n    if (block1Size < block2[7]) {\n      finalResult = 0xffffffff;\n    }\n    else {\n      block2Size = block2[8];\n      if (block2Size < block1[7]) {\n        finalResult = 1;\n      }\n      else {\n        finalResult = 0xffffffff;\n        if (block2[7] <= block1[7]) {\n          if (block2Size < block1Size) {\n            finalResult = 1;\n          }\n          else {\n            finalResult = 0xffffffff;\n            if (block2Size <= block1Size) {\n              if (block1[2] == 0x100) {\n                finalResult = (ulong)-(uint)(block2[2] != 0x100);\n              }\n              else {\n                finalResult = (ulong)(block2[2] == 0x100);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  returnVal._8_8_ = param4;\n  returnVal._0_8_ = finalResult;\n  return returnVal;\n}\n\n",
            "called": [
                "memcmp",
                "compare_gnu_build_notes.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a1b0",
            "calling": [
                "FUN_001086af"
            ],
            "imported": false,
            "current_name": "compare_memory_blocks_0011a1b0"
        },
        "FUN_001163d0": {
            "renaming": {
                "FUN_001163d0": "extract_and_sort_build_attributes_001163d0",
                "param_1": "param_elf_file",
                "param_2": "param_section",
                "param_3": "param_section_size",
                "param_4": "param_output_buffer",
                "uVar1": "result",
                "uVar2": "elf_file",
                "uVar3": "section",
                "bVar4": "is_valid",
                "puVar5": "temp_ptr",
                "iVar6": "comparison_result",
                "uVar7": "error_message",
                "lVar8": "error_string_length",
                "__ptr": "error_string_buffer",
                "uVar9": "temp_value_1",
                "uVar10": "temp_value_2",
                "uVar11": "temp_value_3",
                "uVar12": "temp_value_4",
                "uVar13": "temp_value_5",
                "uVar14": "temp_value_6",
                "uVar15": "temp_value_7",
                "uVar16": "temp_value_8",
                "puVar17": "build_attribute",
                "puVar18": "output_buffer_ptr",
                "cVar19": "note_type",
                "puVar20": "temp_ptr_2",
                "iVar21": "loop_counter",
                "puVar22": "temp_ptr_3",
                "puVar23": "build_attribute_ptr",
                "uVar24": "temp_value_9",
                "__nmemb": "build_attribute_count",
                "puVar25": "temp_ptr_4",
                "bVar26": "is_strip",
                "local_88": "note_type_1",
                "uStack_80": "note_type_2",
                "local_70": "note_type_3",
                "local_68": "output_buffer_size",
                "local_60": "build_attribute_array"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x001166ef) */\n/* WARNING: Removing unreachable block (ram,0x001166df) */\n/* WARNING: Removing unreachable block (ram,0x001166d7) */\n/* WARNING: Removing unreachable block (ram,0x001166ea) */\n/* WARNING: Removing unreachable block (ram,0x00116716) */\n/* WARNING: Removing unreachable block (ram,0x0010858b) */\n\nulong extract_and_sort_build_attributes_001163d0(undefined8 *param_elf_file,undefined8 *param_section,ulong param_section_size,undefined *param_output_buffer)\n\n{\n  ulong result;\n  undefined8 elf_file;\n  undefined8 section;\n  bool is_valid;\n  ulong *temp_ptr;\n  int comparison_result;\n  undefined8 error_message;\n  long error_string_length;\n  void *error_string_buffer;\n  ulong temp_value_1;\n  ulong temp_value_2;\n  ulong temp_value_3;\n  ulong temp_value_4;\n  undefined *error_string_buffer_00;\n  ulong temp_value_5;\n  ulong temp_value_6;\n  ulong temp_value_7;\n  ulong temp_value_8;\n  ulong *build_attribute;\n  undefined *output_buffer_ptr;\n  char note_type;\n  undefined *temp_ptr_2;\n  int loop_counter;\n  undefined *temp_ptr_3;\n  ulong *build_attribute_ptr;\n  ulong temp_value_9;\n  size_t build_attribute_count;\n  ulong *temp_ptr_4;\n  byte is_strip;\n  ulong note_type_1;\n  ulong note_type_2;\n  ulong note_type_3;\n  ulong output_buffer_size;\n  ulong *build_attribute_array;\n  \n  is_strip = 0;\n  error_string_length = bfd_get_reloc_upper_bound();\n  output_buffer_size = param_section_size;\n  if (0 < error_string_length) {\n    error_string_buffer = (void *)xmalloc(error_string_length);\n    error_string_length = bfd_canonicalize_reloc(param_elf_file,param_section,error_string_buffer,isympp);\n    free(error_string_buffer);\n    if (error_string_length != 0) {\n      if (is_strip == 0) {\n        elf_file = *param_elf_file;\n        section = *param_section;\n        error_message = dcgettext(0,\"%s[%s]: Cannot merge - there are relocations against this section\",5);\n        non_fatal(error_message,elf_file,section);\n      }\n      build_attribute_array = (ulong *)0x0;\n      goto LAB_001166f8;\n    }\n  }\n  build_attribute_array = (ulong *)xcalloc(param_section_size / 0xc,0x48,param_section_size % 0xc);\n  note_type_1 = 0;\n  note_type_3 = 0;\n  temp_value_8 = param_section_size;\n  temp_value_7 = 0;\n  build_attribute_ptr = build_attribute_array;\n  temp_value_6 = 0;\n  temp_ptr_3 = param_output_buffer;\n  while (0xb < temp_value_8) {\n    temp_value_2 = (**(code **)(param_elf_file[1] + 0x40))(temp_ptr_3);\n    *build_attribute_ptr = temp_value_2;\n    temp_value_2 = (**(code **)(param_elf_file[1] + 0x40))(temp_ptr_3 + 4);\n    build_attribute_ptr[1] = temp_value_2;\n    temp_value_3 = (**(code **)(param_elf_file[1] + 0x40))(temp_ptr_3 + 8);\n    temp_value_2 = *build_attribute_ptr;\n    build_attribute_ptr[2] = temp_value_3;\n    temp_value_4 = build_attribute_ptr[1];\n    temp_value_5 = temp_value_2 + 3 & 0xfffffffffffffffc;\n    build_attribute_ptr[6] = temp_value_5;\n    if (temp_value_4 != (temp_value_4 + 3 & 0xfffffffffffffffc)) {\n      error_string_length = dcgettext(0,\"corrupt GNU build attribute note: description size not a factor of 4\",5);\n      goto LAB_0010849a;\n    }\n    if (1 < temp_value_3 - 0x100) {\n      error_string_length = dcgettext(0,\"corrupt GNU build attribute note: wrong note type\",5);\n      goto LAB_0010849a;\n    }\n    result = temp_value_5 + temp_value_4 + 0xc;\n    if (temp_value_8 < result) {\n      error_string_length = dcgettext(0,\"corrupt GNU build attribute note: note too big\",5);\n      goto LAB_0010849a;\n    }\n    if (temp_value_2 < 2) {\n      error_string_length = dcgettext(0,\"corrupt GNU build attribute note: name too small\",5);\n      goto LAB_0010849a;\n    }\n    build_attribute_ptr[3] = (ulong)(temp_ptr_3 + 0xc);\n    build_attribute_ptr[4] = (ulong)(temp_ptr_3 + temp_value_5 + 0xc);\n    temp_value_8 = temp_value_8 + (-0xc - (temp_value_5 + temp_value_4));\n    if (temp_value_2 != 2) {\n      if (temp_ptr_3[0xc] == '$') {\n        if ((temp_ptr_3[0xd] == '\\x01') && (temp_ptr_3[0xe] == '1')) {\n          temp_value_8 = extract_build_attribute_notes_00116490();\n          return temp_value_8;\n        }\n      }\n      else if ((((4 < temp_value_2) && (temp_ptr_3[0xc] == 'G')) && (temp_ptr_3[0xd] == 'A')) &&\n              ((temp_ptr_3[0xe] == '$' && (temp_ptr_3[0xf] == '\\x01')))) {\n        if (temp_ptr_3[0x10] == '2') {\n          temp_value_8 = extract_build_attribute_notes_00116490();\n          return temp_value_8;\n        }\n        if (temp_ptr_3[0x10] == '3') {\n          temp_value_8 = extract_build_attribute_notes_00116490();\n          return temp_value_8;\n        }\n        error_string_length = dcgettext(0,\"corrupt GNU build attribute note: unsupported version\",5);\n        goto LAB_0010849a;\n      }\n    }\n    temp_value_1 = temp_value_7;\n    temp_value_9 = temp_value_6;\n    if (temp_value_4 == 0) {\n      if (temp_value_3 == 0x100) {\n        build_attribute_ptr[7] = note_type_1;\nLAB_001164af:\n        temp_value_4 = temp_value_6;\n        temp_value_9 = temp_value_6;\n      }\n      else {\n        build_attribute_ptr[7] = note_type_3;\nLAB_0011669e:\n        temp_value_1 = temp_value_7;\n        temp_value_4 = temp_value_7;\n      }\n    }\n    else {\n      if (temp_value_4 != 0x10) {\n        if (temp_value_4 < 0x11) {\n          if (temp_value_4 == 4) {\n            temp_value_3 = (**(code **)(param_elf_file[1] + 0x40))();\n            temp_value_4 = 0xffffffffffffffff;\n            goto LAB_00116631;\n          }\n          if (temp_value_4 == 8) {\n            temp_value_8 = FUNC_001086af();\n            return temp_value_8;\n          }\n        }\n        error_string_length = dcgettext(0,\"corrupt GNU build attribute note: bad description size\",5);\n        goto LAB_0010849a;\n      }\n      temp_value_3 = (**(code **)(param_elf_file[1] + 0x28))(temp_ptr_3 + temp_value_5 + 0xc);\n      temp_value_4 = (**(code **)(param_elf_file[1] + 0x28))();\n      if (temp_value_4 < temp_value_3) {\n        temp_value_3 = temp_value_4;\n      }\nLAB_00116631:\n      if (build_attribute_ptr[2] == 0x100) {\n        if (temp_value_3 == 0) {\n          temp_value_3 = note_type_1;\n        }\n        temp_value_2 = *build_attribute_ptr;\n        build_attribute_ptr[7] = temp_value_3;\n        temp_value_9 = temp_value_4;\n        note_type_1 = temp_value_3;\n        if (temp_value_4 == 0) goto LAB_001164af;\n      }\n      else {\n        if (temp_value_3 == 0) {\n          temp_value_3 = note_type_3;\n        }\n        temp_value_2 = *build_attribute_ptr;\n        build_attribute_ptr[7] = temp_value_3;\n        temp_value_1 = temp_value_4;\n        note_type_3 = temp_value_3;\n        if (temp_value_4 == 0) goto LAB_0011669e;\n      }\n    }\n    build_attribute_ptr[8] = temp_value_4;\n    if (*(char *)((build_attribute_ptr[3] - 1) + temp_value_2) != '\\0') {\n      error_string_length = dcgettext(0,\"corrupt GNU build attribute note: name not NUL terminated\",5);\n      goto LAB_0010849a;\n    }\n    build_attribute_ptr = build_attribute_ptr + 9;\n    temp_value_7 = temp_value_1;\n    temp_value_6 = temp_value_9;\n    temp_ptr_3 = temp_ptr_3 + result;\n  }\n  if (temp_value_8 == 0) {\n    elf_file = *param_elf_file;\n    section = *param_section;\n    error_message = dcgettext(0,\"%s[%s]: Warning: version note missing - assuming version 3\",5);\n    non_fatal(error_message,elf_file,section);\n    build_attribute_count = ((long)build_attribute_ptr - (long)build_attribute_array >> 3) * -0x71c71c71c71c71c7;\n    qsort(build_attribute_array,build_attribute_count,0x48,compare_gnu_build_notes);\n    for (build_attribute = build_attribute_array; build_attribute < build_attribute_ptr; build_attribute = build_attribute + 9) {\n      temp_value_8 = build_attribute[2];\n      if (temp_value_8 != 0) {\n        temp_value_7 = build_attribute[7];\n        temp_value_6 = build_attribute[8];\n        temp_ptr_4 = build_attribute;\n        loop_counter = 0;\n        if (temp_value_7 == temp_value_6) {\n          build_attribute[2] = 0;\n        }\n        else {\n          do {\n            do {\n              temp_ptr = temp_ptr_4;\n              temp_ptr_4 = temp_ptr + -9;\n              if (temp_ptr_4 < build_attribute_array) goto LAB_001167f5;\n              temp_value_2 = temp_ptr[-7];\n            } while (temp_value_2 == 0);\n            if ((*temp_ptr_4 != *build_attribute) ||\n               (comparison_result = memcmp((void *)temp_ptr[-6],(void *)build_attribute[3],*build_attribute), comparison_result != 0)) break;\n            temp_value_4 = temp_ptr[-2];\n            temp_value_3 = temp_ptr[-1];\n            if (temp_value_7 == temp_value_4) {\n              if (temp_value_6 == temp_value_3) {\n                build_attribute[2] = 0;\n                break;\n              }\nLAB_001167a6:\n              if (temp_value_6 <= temp_value_3) {\n                build_attribute[2] = 0;\n                break;\n              }\n              if (temp_value_3 < temp_value_7) {\nLAB_0010852c:\n                if ((0xfffffffffffffff0 < temp_value_3) || (temp_value_7 <= (temp_value_3 + 0xf & 0xfffffffffffffff0))\n                   ) goto process_build_notes_00116852;\n              }\nLAB_001167b8:\n              if ((temp_value_8 == 0x101) == (temp_value_2 == 0x101)) {\n                if (temp_value_3 <= temp_value_6) {\n                  temp_value_3 = temp_value_6;\n                }\n                if (temp_value_4 < temp_value_7) {\n                  temp_value_7 = temp_value_4;\n                }\n                temp_ptr[-1] = temp_value_3;\n                temp_ptr[-2] = temp_value_7;\n                build_attribute[2] = 0;\n                break;\n              }\n            }\n            else {\n              if (temp_value_4 <= temp_value_7) goto LAB_001167a6;\n              if (temp_value_3 < temp_value_7) goto LAB_0010852c;\n              if (temp_value_6 < temp_value_7) {\n                if ((0xfffffffffffffff0 < temp_value_6) || (temp_value_4 <= (temp_value_6 + 0xf & 0xfffffffffffffff0))\n                   ) goto process_build_notes_00116852;\n                goto LAB_001167b8;\n              }\n              if (temp_value_6 != temp_value_3) goto LAB_001167b8;\n            }\nprocess_build_notes_00116852:\n            is_valid = loop_counter < 0x11;\n            loop_counter = loop_counter + 1;\n          } while (is_valid);\n        }\n      }\nLAB_001167f5:\n    }\n    qsort(build_attribute_array,build_attribute_count,0x48,sort_gnu_build_notes);\n    error_string_buffer_00 = (undefined *)xmalloc(param_section_size * 2);\n    note_type_2 = 0;\n    note_type_3 = 0;\n    temp_ptr_3 = error_string_buffer_00;\n    for (build_attribute = build_attribute_array; build_attribute < build_attribute_ptr; build_attribute = build_attribute + 9) {\n      if (build_attribute[2] != 0) {\n        output_buffer_ptr = temp_ptr_3 + 0xc;\n        if ((build_attribute[7] == note_type_3) && (build_attribute[8] == note_type_2)) {\n          (**(code **)(param_elf_file[1] + 0x50))(*build_attribute,temp_ptr_3);\n          (**(code **)(param_elf_file[1] + 0x50))(0,temp_ptr_3 + 4);\n          (**(code **)(param_elf_file[1] + 0x50))(build_attribute[2],temp_ptr_3 + 8);\n          temp_value_7 = build_attribute[6];\n          temp_value_8 = *build_attribute;\n          temp_ptr_3 = (undefined *)build_attribute[3];\n          temp_ptr_2 = output_buffer_ptr;\n          for (temp_value_6 = temp_value_8; temp_value_6 != 0; temp_value_6 = temp_value_6 - 1) {\n            *temp_ptr_2 = *temp_ptr_3;\n            temp_ptr_3 = temp_ptr_3 + (ulong)is_strip * -2 + 1;\n            temp_ptr_2 = temp_ptr_2 + (ulong)is_strip * -2 + 1;\n          }\n          if (temp_value_8 < temp_value_7) {\n            for (error_string_length = temp_value_7 - temp_value_8; error_string_length != 0; error_string_length = error_string_length + -1) {\n              *temp_ptr_2 = 0;\n              temp_ptr_2 = temp_ptr_2 + (ulong)is_strip * -2 + 1;\n            }\n          }\n          temp_ptr_3 = output_buffer_ptr + temp_value_7;\n        }\n        else {\n          (**(code **)(param_elf_file[1] + 0x50))();\n          if (*(int *)(param_elf_file[1] + 8) == 5) {\n            note_type = (*(char *)(param_elf_file[0x22] + 4) == '\\x02') * '\\b' + '\\b';\n          }\n          else {\n            note_type = '\\b';\n          }\n          (**(code **)(param_elf_file[1] + 0x50))(note_type,temp_ptr_3 + 4);\n          (**(code **)(param_elf_file[1] + 0x50))(build_attribute[2],temp_ptr_3 + 8);\n          temp_value_8 = *build_attribute;\n          temp_ptr_3 = (undefined *)build_attribute[3];\n          temp_ptr_2 = output_buffer_ptr;\n          for (temp_value_7 = temp_value_8; temp_value_7 != 0; temp_value_7 = temp_value_7 - 1) {\n            *temp_ptr_2 = *temp_ptr_3;\n            temp_ptr_3 = temp_ptr_3 + (ulong)is_strip * -2 + 1;\n            temp_ptr_2 = temp_ptr_2 + (ulong)is_strip * -2 + 1;\n          }\n          temp_value_7 = build_attribute[6];\n          if (temp_value_8 < temp_value_7) {\n            for (error_string_length = temp_value_7 - temp_value_8; error_string_length != 0; error_string_length = error_string_length + -1) {\n              *temp_ptr_2 = 0;\n              temp_ptr_2 = temp_ptr_2 + (ulong)is_strip * -2 + 1;\n            }\n          }\n          error_string_length = param_elf_file[1];\n          output_buffer_ptr = output_buffer_ptr + temp_value_7;\n          temp_ptr_3 = output_buffer_ptr + 8;\n          if ((*(int *)(error_string_length + 8) == 5) && (*(char *)(param_elf_file[0x22] + 4) == '\\x02')) {\n            (**(code **)(error_string_length + 0x38))(build_attribute[7],output_buffer_ptr);\n            (**(code **)(param_elf_file[1] + 0x38))(build_attribute[8],temp_ptr_3);\n            temp_ptr_3 = output_buffer_ptr + 0x10;\n          }\n          else {\n            (**(code **)(error_string_length + 0x50))(build_attribute[7],output_buffer_ptr);\n            (**(code **)(param_elf_file[1] + 0x50))(build_attribute[8],output_buffer_ptr + 4);\n          }\n          note_type_3 = build_attribute[7];\n          note_type_2 = build_attribute[8];\n        }\n      }\n    }\n    temp_value_7 = (long)temp_ptr_3 - (long)error_string_buffer_00;\n    temp_value_8 = temp_value_7;\n    temp_ptr_3 = error_string_buffer_00;\n    output_buffer_size = param_section_size;\n    if (temp_value_7 < param_section_size) {\n      for (; output_buffer_size = temp_value_7, temp_value_8 != 0; temp_value_8 = temp_value_8 - 1) {\n        *param_output_buffer = *temp_ptr_3;\n        temp_ptr_3 = temp_ptr_3 + (ulong)is_strip * -2 + 1;\n        param_output_buffer = param_output_buffer + (ulong)is_strip * -2 + 1;\n      }\n    }\n    free(error_string_buffer_00);\n  }\n  else {\n    error_string_length = dcgettext(0,\"corrupt GNU build attribute notes: excess data at end\",5);\nLAB_0010849a:\n    if (error_string_length != 0) {\n      bfd_set_error(0x11);\n      bfd_nonfatal_message(0,param_elf_file,param_section,error_string_length);\n      status = 1;\n    }\n  }\nLAB_001166f8:\n  free(build_attribute_array);\n  return output_buffer_size;\n}\n\n",
            "called": [
                "non_fatal",
                "bfd_canonicalize_reloc",
                "dcgettext",
                "xcalloc",
                "bfd_get_reloc_upper_bound",
                "free",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001163d0",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "extract_and_sort_build_attributes_001163d0"
        },
        "FUN_00108a2a": {
            "renaming": {
                "FUN_00108a2a": "print_usage_00108a2a",
                "param_1": "filePtr",
                "param_2": "errorCode",
                "uVar1": "programName",
                "pcVar2": "message"
            },
            "code": "\nvoid printUsage_00108a2a(FILE *filePtr,int errorCode)\n\n{\n  undefined8 programName;\n  char *message;\n  \n  programName = program_name;\n  message = (char *)dcgettext(0,\"Usage: %s <option(s)> in-file(s)\\n\",5);\n  fprintf(filePtr,message,programName);\n  message = (char *)dcgettext(0,\" Removes symbols and sections from files\\n\",5);\n  fprintf(filePtr,message);\n  message = (char *)dcgettext(0,\" The options are:\\n\",5);\n  fprintf(filePtr,message);\n  message = (char *)dcgettext(0,\n                             \"  -I --input-target=<bfdname>      Assume input file is in format <bfdname>\\n  -O --output-target=<bfdname>     Create an output file in format <bfdname>\\n  -F --target=<bfdname>            Set both input and output format to <bfdname>\\n  -p --preserve-dates              Copy modified/access timestamps to the output\\n\"\n                             ,5);\n  fprintf(filePtr,message);\n  message = (char *)dcgettext(0,\n                             \"  -D --enable-deterministic-archives\\n                                   Produce deterministic output when stripping archives (default)\\n  -U --disable-deterministic-archives\\n                                   Disable -D behavior\\n\"\n                             ,5);\n  fprintf(filePtr,message);\n  message = (char *)dcgettext(0,\n                             \"  -R --remove-section=<name>       Also remove section <name> from the output\\n     --remove-relocations <name>   Remove relocations from section <name>\\n  -s --strip-all                   Remove all symbol and relocation information\\n  -g -S -d --strip-debug           Remove all debugging symbols & sections\\n     --strip-dwo                   Remove all DWO sections\\n     --strip-unneeded              Remove all symbols not needed by relocations\\n     --only-keep-debug             Strip everything but the debug information\\n  -M  --merge-notes                Remove redundant entries in note sections (default)\\n      --no-merge-notes             Do not attempt to remove redundant notes\\n  -N --strip-symbol=<name>         Do not copy symbol <name>\\n     --keep-section=<name>         Do not strip section <name>\\n  -K --keep-symbol=<name>          Do not strip symbol <name>\\n     --keep-section-symbols        Do not strip section symbols\\n     --keep-file-symbols           Do not strip file symbol(s)\\n  -w --wildcard                    Permit wildcard in symbol comparison\\n  -x --discard-all                 Remove all non-global symbols\\n  -X --discard-locals              Remove any compiler-generated symbols\\n  -v --verbose                     List all object files modified\\n  -V --version                     Display this program\\'s version number\\n  -h --help                        Display this output\\n     --info                        List object formats & architectures supported\\n  -o <file>                        Place stripped output into <file>\\n\"\n                             ,5);\n  fprintf(filePtr,message);\n  list_supported_targets(program_name,filePtr);\n  if (errorCode == 0) {\n    message = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(filePtr,message,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  exit(errorCode);\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext",
                "list_supported_targets",
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108a2a",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "print_usage_00108a2a"
        },
        "FUN_00108c86": {
            "renaming": {
                "FUN_00108c86": "extract_prefix_info_00108c86",
                "param_1": "prefix_ptr",
                "cVar1": "startsWithLTO",
                "iVar2": "comparison_result",
                "sVar3": "string_length",
                "puVar4": "new_string_ptr",
                "lVar5": "offset",
                "__s": "input_string",
                "__s1": "architecture",
                "puVar6": "new_string_ptr_iterator",
                "uVar7": "result",
                "bVar8": "is_negative"
            },
            "code": "\nundefined8 extract_prefix_info_00108c86(long *prefix_ptr)\n\n{\n  char startsWithLTO;\n  int comparison_result;\n  size_t string_length;\n  undefined2 *new_string_ptr;\n  long offset;\n  char *input_string;\n  char *architecture;\n  undefined2 *new_string_ptr_iterator;\n  undefined8 result;\n  byte is_negative;\n  \n  is_negative = 0;\n  offset = *prefix_ptr;\n  input_string = (char *)(offset + 4);\n  startsWithLTO = startswith_lto_priv_0_lto_priv_0(input_string,&DAT_0011b73b);\n  if (startsWithLTO == '\\0') {\n    startsWithLTO = startswith_lto_priv_0_lto_priv_0(input_string,\"bsdrv-\");\n    if (startsWithLTO == '\\0') {\n      startsWithLTO = startswith_lto_priv_0_lto_priv_0(input_string,\"rtdrv-\");\n      if (startsWithLTO == '\\0') {\n        return 0xffffffff;\n      }\n      input_string = (char *)(offset + 6);\n      result = 0xc;\n    }\n    else {\n      input_string = (char *)(offset + 6);\n      result = 0xb;\n    }\n  }\n  else {\n    result = 10;\n  }\n  string_length = strlen(input_string);\n  new_string_ptr = (undefined2 *)xmalloc(string_length + 8);\n  architecture = input_string + 4;\n  new_string_ptr_iterator = new_string_ptr;\n  for (offset = string_length + 1; offset != 0; offset = offset + -1) {\n    *(char *)new_string_ptr_iterator = *input_string;\n    input_string = input_string + (ulong)is_negative * -2 + 1;\n    new_string_ptr_iterator = (undefined2 *)((long)new_string_ptr_iterator + (ulong)is_negative * -2 + 1);\n  }\n  *(undefined *)(new_string_ptr + 1) = 0x69;\n  *new_string_ptr = 0x6570;\n  comparison_result = strcmp(architecture,\"ia32\");\n  if (comparison_result == 0) {\n    *(undefined *)((long)new_string_ptr + 7) = 0x36;\n    *(undefined2 *)((long)new_string_ptr + 5) = 0x3833;\n  }\n  else {\n    comparison_result = strcmp(architecture,\"x86_64\");\n    if (comparison_result == 0) {\n      *(undefined *)((long)new_string_ptr + 7) = 0x2d;\n    }\n    else {\n      comparison_result = strcmp(architecture,\"aarch64\");\n      if (comparison_result == 0) {\n        *(undefined8 *)((long)new_string_ptr + 0xb) = 0x656c7474696c2d;\n      }\n    }\n  }\n  *prefix_ptr = (long)new_string_ptr;\n  return result;\n}\n\n",
            "called": [
                "strlen",
                "startswith.lto_priv.0.lto_priv.0",
                "xmalloc",
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108c86",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "extract_prefix_info_00108c86"
        },
        "FUN_0010911f": {
            "renaming": {
                "FUN_0010911f": "print_error_message_0010911f",
                "param_1": "message",
                "__format": "errorFormat"
            },
            "code": "\n\n\nvoid printErrorMessage_0010911f(undefined8 message)\n\n{\n  char *errorFormat;\n  \n  errorFormat = (char *)dcgettext(0,\"bad mangled name `%s\\'\\n\",5);\n  fprintf(_stderr,errorFormat,message);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010911f",
            "calling": [
                "parse_stab_type",
                "stab_demangle_qualified",
                "stab_demangle_type.lto_priv.0",
                "stab_demangle_args",
                "stab_demangle_template"
            ],
            "imported": false,
            "current_name": "print_error_message_0010911f"
        },
        "FUN_00104910": {
            "renaming": {},
            "code": "\nvoid __cxa_finalize(void)\n\n{\n  __cxa_finalize();\n  return;\n}\n\n",
            "called": [
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104910",
            "calling": [
                "__do_global_dtors_aux"
            ],
            "imported": false,
            "current_name": "FUN_00104910"
        },
        "FUN_001053d5": {
            "renaming": {
                "FUN_001053d5": "close_bfd_and_return_status_001053d5",
                "unaff_R12": "pointerToStatus",
                "unaff_R14": "pointerToBFD",
                "bfd_nonfatal": "nonfatalBFD",
                "bfd_close_all_done": "closeAllBFD"
            },
            "code": "\nundefined4 closeBFDAndReturnStatus_001053d5(void)\n\n{\n  long pointerToStatus;\n  undefined8 *pointerToBFD;\n  \n  nonfatalBFD(*pointerToBFD);\n  *(undefined4 *)(pointerToStatus + 8) = 1;\n  closeAllBFD();\n  return *(undefined4 *)(pointerToStatus + 8);\n}\n\n",
            "called": [
                "bfd_nonfatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001053d5",
            "calling": [
                "do_display_target"
            ],
            "imported": false,
            "current_name": "close_bfd_and_return_status_001053d5"
        },
        "FUN_00104bba": {
            "renaming": {
                "FUN_00104bba": "check_and_set_bit_flags_00104bba",
                "in_EAX": "eaxValue",
                "uVar1": "errorMessage",
                "unaff_EBP": "ebpValue",
                "unaff_R14": "r14Value"
            },
            "code": "\nvoid checkAndSetBitFlags_00104bba(void)\n\n{\n  uint eaxValue;\n  undefined8 errorMessage;\n  uint ebpValue;\n  long r14Value;\n  \n  if ((eaxValue & 2) != 0) {\n    errorMessage = dcgettext(0,\"error: %s both copied and removed\",5);\n                    \n    fatal(errorMessage);\n  }\n  if ((((eaxValue & 8) == 0) || ((ebpValue & 0x10) == 0)) && ((ebpValue & 0x18) != 0x18)) {\n    if ((((eaxValue & 0x20) == 0) || ((ebpValue & 0x40) == 0)) && ((ebpValue & 0x60) != 0x60)) {\n      *(uint *)(r14Value + 0x14) = eaxValue | ebpValue;\n      return;\n    }\n    errorMessage = dcgettext(0,\"error: %s both sets and alters LMA\",5);\n                    \n    fatal(errorMessage);\n  }\n  errorMessage = dcgettext(0,\"error: %s both sets and alters VMA\",5);\n                    \n  fatal(errorMessage);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104bba",
            "calling": [
                "find_section_list"
            ],
            "imported": false,
            "current_name": "check_and_set_bit_flags_00104bba"
        },
        "FUN_001040a0": {
            "renaming": {},
            "code": "\n\n\nvoid abort(void)\n\n{\n                    \n  abort();\n}\n\n",
            "called": [
                "abort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001040a0",
            "calling": [
                "debug_type_samep",
                "stab_demangle_v3_arg",
                "stab_class_method_var",
                "stab_variable.lto_priv.0",
                "stab_class_baseclass.lto_priv.0",
                "debug_write_type.constprop.0",
                "debug_write_name.constprop.0",
                "stab_struct_field.lto_priv.0",
                "stab_class_static_member.lto_priv.0",
                "stab_demangle_template",
                "display_info.isra.0",
                "stab_function_parameter.lto_priv.0"
            ],
            "imported": false,
            "current_name": "FUN_001040a0"
        },
        "FUN_00104918": {
            "renaming": {},
            "code": "\nvoid xcalloc(void)\n\n{\n  xcalloc();\n  return;\n}\n\n",
            "called": [
                "xcalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104918",
            "calling": [
                "merge_gnu_build_notes"
            ],
            "imported": false,
            "current_name": "FUN_00104918"
        },
        "FUN_001042e0": {
            "renaming": {},
            "code": "\n\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  __off_t _Var1;\n  \n  _Var1 = lseek(__fd,__offset,__whence);\n  return _Var1;\n}\n\n",
            "called": [
                "lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001042e0",
            "calling": [
                "simple_copy"
            ],
            "imported": false,
            "current_name": "FUN_001042e0"
        },
        "FUN_001283b0": {
            "renaming": {},
            "code": "\n\n\n\nint fchmod(int __fd,__mode_t __mode)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fchmod@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001283b0",
            "calling": [
                "fchmod"
            ],
            "imported": false,
            "current_name": "FUN_001283b0"
        },
        "FUN_001041c0": {
            "renaming": {},
            "code": "\n\n\nssize_t write(int __fd,void *__buf,size_t __n)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = write(__fd,__buf,__n);\n  return sVar1;\n}\n\n",
            "called": [
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001041c0",
            "calling": [
                "simple_copy"
            ],
            "imported": false,
            "current_name": "FUN_001041c0"
        },
        "FUN_00109a0b": {
            "renaming": {
                "FUN_00109a0b": "copy_string_00109a0b",
                "param_1": "sourceString",
                "param_2": "length",
                "puVar1": "newString",
                "lVar2": "index",
                "puVar3": "destinationString",
                "bVar4": "increment"
            },
            "code": "\nvoid copyString_00109a0b(undefined *sourceString,int length)\n\n{\n  undefined *newString;\n  long index;\n  undefined *destinationString;\n  byte increment;\n  \n  increment = 0;\n  newString = (undefined *)xmalloc((long)(length + 1));\n  destinationString = newString;\n  for (index = (long)length; index != 0; index = index + -1) {\n    *destinationString = *sourceString;\n    sourceString = sourceString + (ulong)increment * -2 + 1;\n    destinationString = destinationString + (ulong)increment * -2 + 1;\n  }\n  newString[length] = 0;\n  return;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109a0b",
            "calling": [
                "parse_stab",
                "parse_stab_type",
                "stab_demangle_qualified",
                "stab_find_tagged_type",
                "stab_demangle_type.lto_priv.0",
                "stab_demangle_template"
            ],
            "imported": false,
            "current_name": "copy_string_00109a0b"
        },
        "FUN_0010da0b": {
            "renaming": {
                "FUN_0010da0b": "allocate_and_initialize_slot_0010da0b",
                "param_1": "slot",
                "param_2": "index",
                "uVar1": "message",
                "plVar2": "allocated_slot",
                "lVar3": "slot_offset",
                "lVar4": "init_loop",
                "uVar5": "remaining_index",
                "bVar6": "is_zero",
                "auVar7": "result"
            },
            "code": "\nundefined  [16] allocate_and_initialize_slot_0010da0b(long **slot,ulong index,undefined8 param_3,undefined8 param_4)\n\n{\n  undefined8 message;\n  long *allocated_slot;\n  long slot_offset;\n  long init_loop;\n  ulong remaining_index;\n  byte is_zero;\n  undefined result [16];\n  \n  is_zero = 0;\n  remaining_index = index;\n  if ((long)index < 0x3e90) {\n    for (; 0xf < (long)remaining_index; remaining_index = remaining_index - 0x10) {\n      if (*slot == (long *)0x0) {\n        allocated_slot = (long *)xmalloc(0x88);\n        *slot = allocated_slot;\n        for (slot_offset = 0x22; slot_offset != 0; slot_offset = slot_offset + -1) {\n          *(undefined4 *)allocated_slot = 0;\n          allocated_slot = (long *)((long)allocated_slot + (ulong)is_zero * -8 + 4);\n        }\n      }\n      slot = (long **)*slot;\n    }\n    slot_offset = (index >> 4) * -0x10;\n    if ((long)index < 0) {\n      slot_offset = 0;\n    }\n    if (*slot == (long *)0x0) {\n      allocated_slot = (long *)xmalloc(0x88);\n      *slot = allocated_slot;\n      for (init_loop = 0x22; init_loop != 0; init_loop = init_loop + -1) {\n        *(undefined4 *)allocated_slot = 0;\n        allocated_slot = (long *)((long)allocated_slot + (ulong)is_zero * -8 + 4);\n      }\n    }\n    result._8_8_ = param_4;\n    result._0_8_ = *slot + index + slot_offset + 1;\n    return result;\n  }\n  message = dcgettext(0,\"Excessively large slot index: %lx\",5);\n                    \n  fatal(message,index);\n}\n\n",
            "called": [
                "dcgettext",
                "xmalloc",
                "fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010da0b",
            "calling": [
                "parse_coff_type.lto_priv.0",
                "parse_coff_symbol.constprop.0.isra.0"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_slot_0010da0b"
        },
        "FUN_00112894": {
            "renaming": {
                "FUN_00112894": "initialize_data_structure_00112894",
                "param_1": "dataPointer",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "puVar1": "dataStructure",
                "puVar2": "dynamicMemory",
                "lVar3": "loopCounter",
                "bVar4": "byteValue"
            },
            "code": "\nundefined8 *\ninitializeDataStructure_00112894(undefined8 dataPointer,undefined param2,undefined8 param3,undefined8 param4)\n\n{\n  undefined8 *dataStructure;\n  undefined8 *dynamicMemory;\n  long loopCounter;\n  byte byteValue;\n  \n  byteValue = 0;\n  dataStructure = (undefined8 *)xmalloc(0x1b0);\n  dynamicMemory = dataStructure;\n  for (loopCounter = 0x6c; loopCounter != 0; loopCounter = loopCounter + -1) {\n    *(undefined4 *)dynamicMemory = 0;\n    dynamicMemory = (undefined8 *)((long)dynamicMemory + (ulong)byteValue * -8 + 4);\n  }\n  *dataStructure = dataPointer;\n  *(undefined *)(dataStructure + 1) = param2;\n  dataStructure[2] = param3;\n  dataStructure[3] = param4;\n  *(undefined4 *)(dataStructure + 0x10) = 1;\n  dynamicMemory = (undefined8 *)xmalloc(8);\n  dataStructure[0xd] = 0xffffffffffffffff;\n  dataStructure[0x11] = dynamicMemory;\n  *dynamicMemory = 0;\n  return dataStructure;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112894",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "initialize_data_structure_00112894"
        },
        "FUN_00109b2f": {
            "renaming": {
                "FUN_00109b2f": "extract_and_free_pointer_00109b2f",
                "param_1": "ptrAddress",
                "__ptr": "ptrValue",
                "puVar1": "returnValue"
            },
            "code": "\nundefined8 * extractAndFreePointer_00109b2f(long ptrAddress)\n\n{\n  undefined8 *ptrValue;\n  undefined8 *returnValue;\n  \n  ptrValue = *(undefined8 **)(ptrAddress + 0x60);\n  if (ptrValue != (undefined8 *)0x0) {\n    returnValue = (undefined8 *)ptrValue[1];\n    *(undefined8 *)(ptrAddress + 0x60) = *ptrValue;\n    free(ptrValue);\n    return returnValue;\n  }\n  return ptrValue;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109b2f",
            "calling": [
                "stab_function_type.lto_priv.0",
                "stab_variable.lto_priv.0",
                "stab_start_class_type.lto_priv.0",
                "stab_end_struct_type.lto_priv.0",
                "stab_range_type.lto_priv.0",
                "stab_tag.lto_priv.0",
                "stab_typed_constant.lto_priv.0",
                "stab_float_type.lto_priv.0",
                "stab_struct_field.lto_priv.0",
                "stab_set_type.lto_priv.0",
                "stab_array_type.lto_priv.0",
                "stab_offset_type.lto_priv.0",
                "stab_typdef.lto_priv.0",
                "stab_start_function.lto_priv.0",
                "stab_class_method_var",
                "stab_class_baseclass.lto_priv.0",
                "stab_modify_type",
                "stab_method_type.lto_priv.0",
                "stab_class_static_member.lto_priv.0",
                "stab_function_parameter.lto_priv.0"
            ],
            "imported": false,
            "current_name": "extract_and_free_pointer_00109b2f"
        },
        "FUN_001283b8": {
            "renaming": {},
            "code": "\n\n\n\nint chmod(char *__file,__mode_t __mode)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* chmod@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001283b8",
            "calling": [
                "chmod"
            ],
            "imported": false,
            "current_name": "FUN_001283b8"
        },
        "FUN_00108d9a": {
            "renaming": {
                "FUN_00108d9a": "process_redefinition_00108d9a",
                "param_1": "output_stream",
                "param_2": "symbol_name",
                "param_3": "target_symbol",
                "param_4": "result",
                "ppcVar1": "symbol_entry",
                "pcVar2": "symbol_name_copy",
                "lVar3": "symbol_entry_index",
                "uVar4": "htab",
                "plVar5": "slot_entry"
            },
            "code": "\nundefined8 process_redefinition_00108d9a(undefined8 output_stream,char *symbol_name,char *target_symbol,undefined8 result)\n\n{\n  char **symbol_entry;\n  char *symbol_name_copy;\n  long symbol_entry_index;\n  undefined8 htab;\n  long *slot_entry;\n  \n  symbol_entry = (char **)xmalloc(0x10);\n  symbol_name_copy = strdup(symbol_name);\n  *symbol_entry = symbol_name_copy;\n  symbol_name_copy = strdup(target_symbol);\n  htab = redefine_specific_htab;\n  symbol_entry[1] = symbol_name_copy;\n  symbol_entry_index = htab_find(htab,symbol_entry);\n  if (symbol_entry_index != 0) {\n    htab = dcgettext(0,\"%s: Multiple redefinition of symbol \\\"%s\\\"\",5);\n                    \n    fatal(htab,output_stream,symbol_name);\n  }\n  symbol_entry_index = htab_find(redefine_specific_reverse_htab,target_symbol);\n  if (symbol_entry_index != 0) {\n    htab = dcgettext(0,\"%s: Symbol \\\"%s\\\" is target of more than one redefinition\",5);\n                    \n    fatal(htab,output_stream,target_symbol);\n  }\n  slot_entry = (long *)htab_find_slot(redefine_specific_htab,symbol_entry,1);\n  htab = redefine_specific_reverse_htab;\n  *slot_entry = (long)symbol_entry;\n  symbol_name_copy = symbol_entry[1];\n  symbol_entry = (char **)htab_find_slot(htab,symbol_name_copy,1);\n  *symbol_entry = symbol_name_copy;\n  return result;\n}\n\n",
            "called": [
                "dcgettext",
                "strdup",
                "htab_find_slot",
                "htab_find",
                "xmalloc",
                "fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108d9a",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "process_redefinition_00108d9a"
        },
        "FUN_0010e9a0": {
            "renaming": {
                "FUN_0010e9a0": "write_symbol_0010e9a0",
                "param_1": "arg1",
                "param_2": "symbolName",
                "param_3": "symbolType",
                "param_4": "arg4",
                "__s": "type",
                "__s_00": "modifiedType",
                "__s_01": "modifiedSymbol",
                "pcVar5": "symbolPrefix",
                "uVar6": "symbolCode",
                "lVar1": "counter",
                "sVar3": "symbolNameLength",
                "sVar4": "modifiedSymbolLength",
                "_sch_istable": "characterTable"
            },
            "code": "\nundefined4 writeSymbol_0010e9a0(long arg1,char *symbolName,undefined4 symbolType,undefined8 arg4)\n\n{\n  long counter;\n  undefined4 uVar2;\n  byte *type;\n  byte *modifiedType;\n  size_t symbolNameLength;\n  size_t modifiedSymbolLength;\n  char *modifiedSymbol;\n  char *symbolPrefix;\n  undefined8 symbolCode;\n  \n  type = (byte *)stab_pop_type();\n  switch(symbolType) {\n  case 1:\n    symbolPrefix = \"G\";\n    symbolCode = 0x20;\n    break;\n  case 2:\n    symbolPrefix = \"S\";\n    symbolCode = 0x26;\n    break;\n  case 3:\n    symbolPrefix = \"V\";\n    symbolCode = 0x26;\n    break;\n  case 4:\n    symbolPrefix = \"\";\n    symbolCode = 0x80;\n    if (((&characterTable)[(ulong)*type * 2] & 4) == 0) {\n      counter = *(long *)(arg1 + 0x68);\n      *(long *)(arg1 + 0x68) = counter + 1;\n      symbolNameLength = strlen((char *)type);\n      modifiedType = (byte *)xmalloc(symbolNameLength + 0x14);\n      sprintf((char *)modifiedType,\"%ld=%s\",counter,type);\n      free(type);\n      type = modifiedType;\n    }\n    break;\n  case 5:\n    symbolPrefix = \"r\";\n    symbolCode = 0x40;\n    break;\n  default:\n                    \n    abort();\n  }\n  symbolNameLength = strlen(symbolName);\n  modifiedSymbolLength = strlen((char *)type);\n  modifiedSymbol = (char *)xmalloc(symbolNameLength + 3 + modifiedSymbolLength);\n  sprintf(modifiedSymbol,\"%s:%s%s\",symbolName,symbolPrefix,type);\n  free(type);\n  uVar2 = stab_write_symbol_lto_priv_0(arg1,symbolCode,0,arg4,modifiedSymbol);\n  if ((char)uVar2 != '\\0') {\n    free(modifiedSymbol);\n  }\n  return uVar2;\n}\n\n",
            "called": [
                "strlen",
                "stab_write_symbol.lto_priv.0",
                "sprintf",
                "abort",
                "free",
                "xmalloc",
                "stab_pop_type"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e9a0",
            "calling": [
                "debug_write_name.constprop.0"
            ],
            "imported": false,
            "current_name": "write_symbol_0010e9a0"
        },
        "FUN_001042f0": {
            "renaming": {},
            "code": "\nvoid bfd_convert_section_contents(void)\n\n{\n  bfd_convert_section_contents();\n  return;\n}\n\n",
            "called": [
                "bfd_convert_section_contents"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001042f0",
            "calling": [
                "copy_section"
            ],
            "imported": false,
            "current_name": "FUN_001042f0"
        },
        "FUN_0010827b": {
            "renaming": {
                "FUN_0010827b": "report_error_section_match_0010827b",
                "unaff_RBX": "sectionPtr",
                "uVar1": "sectionValue",
                "uVar2": "errorMessage",
                "fatal": "terminateProgram"
            },
            "code": "\nvoid reportErrorSectionMatch_0010827b(void)\n\n{\n  undefined8 sectionValue;\n  undefined8 errorMessage;\n  undefined8 *sectionPtr;\n  \n  sectionValue = *sectionPtr;\n  errorMessage = dcgettext(0,\"error: section %s matches both remove and copy options\",5);\n                    \n  terminateProgram(errorMessage,sectionValue);\n}\n\n",
            "called": [
                "dcgettext",
                "fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010827b",
            "calling": [
                "is_strip_section_1.isra.0"
            ],
            "imported": false,
            "current_name": "report_error_section_match_0010827b"
        },
        "FUN_00104920": {
            "renaming": {
                "FUN_00104920": "handle_bad_number_00104920",
                "uVar1": "errorString"
            },
            "code": "\nvoid handleBadNumber_00104920(void)\n\n{\n  undefined8 errorString;\n  \n  errorString = dcgettext(0,\"%s: bad number: %s\",5);\n                    \n  fatal(errorString);\n}\n\n",
            "called": [
                "dcgettext",
                "fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104920",
            "calling": [
                "parse_vma"
            ],
            "imported": false,
            "current_name": "handle_bad_number_00104920"
        },
        "FUN_00104800": {
            "renaming": {},
            "code": "\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fwrite(__ptr,__size,__n,__s);\n  return sVar1;\n}\n\n",
            "called": [
                "fwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104800",
            "calling": [
                "stab_context",
                "bfd_nonfatal_message",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "FUN_00104800"
        },
        "FUN_00113f20": {
            "renaming": {
                "FUN_00113f20": "initialize_hash_table_00113f20",
                "htab_create_alloc": "createHashTable",
                "htab_hash_string": "hashString",
                "htab_eq_string": "compareStrings",
                "xcalloc": "allocateMemory",
                "free": "releaseMemory"
            },
            "code": "\nvoid initializeHashTable_00113f20(void)\n\n{\n  createHashTable(0x10,hashString,compareStrings,0,allocateMemory,releaseMemory);\n  return;\n}\n\n",
            "called": [
                "free",
                "htab_eq_string",
                "htab_create_alloc",
                "htab_hash_string",
                "xcalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113f20",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_hash_table_00113f20"
        },
        "FUN_001283e8": {
            "renaming": {},
            "code": "\n\n\n\nint open(char *__file,int __oflag,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* open@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001283e8",
            "calling": [
                "open"
            ],
            "imported": false,
            "current_name": "FUN_001283e8"
        },
        "FUN_001282c0": {
            "renaming": {},
            "code": "\n\n\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strtol@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001282c0",
            "calling": [
                "strtol"
            ],
            "imported": false,
            "current_name": "FUN_001282c0"
        },
        "FUN_001281a0": {
            "renaming": {},
            "code": "\n\n\n\nint fputs(char *__s,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fputs@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001281a0",
            "calling": [
                "fputs"
            ],
            "imported": false,
            "current_name": "FUN_001281a0"
        },
        "FUN_001041d0": {
            "renaming": {},
            "code": "\nvoid textdomain(void)\n\n{\n  textdomain();\n  return;\n}\n\n",
            "called": [
                "textdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001041d0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001041d0"
        },
        "FUN_001040b0": {
            "renaming": {},
            "code": "\n\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = __errno_location();\n  return piVar1;\n}\n\n",
            "called": [
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001040b0",
            "calling": [
                "set_times.cold",
                "simple_copy.cold",
                "smart_rename.cold",
                "main",
                "parse_number",
                "get_file_size.cold",
                "FUN_00107880",
                "copy_file",
                "FUN_00104ea2",
                "display_info.isra.0",
                "simple_copy",
                "section_add_load_file.cold",
                "add_specific_symbols"
            ],
            "imported": false,
            "current_name": "FUN_001040b0"
        },
        "FUN_00116aa0": {
            "renaming": {
                "FUN_00116aa0": "start_main_loop_00116aa0",
                "param_1": "param1",
                "param_2": "param2",
                "auStack_8": "stack",
                "__libc_start_main": "initializeLibcStartMain"
            },
            "code": "\nvoid processEntry startMainLoop_00116aa0(undefined8 param1,undefined8 param2)\n\n{\n  undefined stack [8];\n  \n  initializeLibcStartMain(main,param2,&stack0x00000008,0,0,param1,stack);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "main",
                "__libc_start_main"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116aa0",
            "calling": [],
            "imported": false,
            "current_name": "start_main_loop_00116aa0"
        },
        "FUN_00108179": {
            "renaming": {
                "FUN_00108179": "set_alignment_00108179",
                "lVar1": "alignmentError",
                "lVar2": "groupSignature",
                "cVar3": "successIndicator",
                "lVar4": "errorMsg",
                "lVar5": "signatureResult",
                "unaff_RBX": "memoryAddress1",
                "unaff_RBP": "memoryAddress2",
                "unaff_R12": "memoryAddress3",
                "unaff_R14B": "flag",
                "unaff_R15": "memoryAddress4"
            },
            "code": "\nvoid setAlignment_00108179(void)\n\n{\n  long alignmentError;\n  long groupSignature;\n  char successIndicator;\n  long errorMsg;\n  long signatureResult;\n  long memoryAddress1;\n  long memoryAddress2;\n  long memoryAddress3;\n  char flag;\n  long memoryAddress4;\n  \n  errorMsg = dcgettext(0,\"failed to set alignment\",5);\n  *(undefined4 *)(memoryAddress4 + 0xb4) = *(undefined4 *)(memoryAddress1 + 0xb4);\n  *(byte *)(memoryAddress4 + 0x28) =\n       *(byte *)(memoryAddress4 + 0x28) & 0xcf | *(byte *)(memoryAddress1 + 0x28) & 0x30;\n  *(long *)(memoryAddress1 + 0x60) = memoryAddress4;\n  *(undefined8 *)(memoryAddress1 + 0x58) = 0;\n  if ((*(byte *)(memoryAddress1 + 0x27) & 2) != 0) {\n    alignmentError = *(long *)(memoryAddress1 + 0xd0);\n    signatureResult = group_signature_isra_0(alignmentError,*(undefined8 *)(memoryAddress1 + 0xe0));\n    if ((signatureResult != 0) &&\n       (groupSignature = *(long *)(memoryAddress3 + 8), *(uint *)(signatureResult + 0x18) = *(uint *)(signatureResult + 0x18) | 0x20,\n       *(int *)(groupSignature + 8) == 5)) {\n      *(long *)(alignmentError + 0xb0) = signatureResult;\n      successIndicator = (**(code **)(*(long *)(memoryAddress2 + 8) + 0x158))();\n      if (successIndicator == '\\0') {\n        copy_private_data_0010808f();\n        return;\n      }\n      goto LAB_0011571e;\n    }\n  }\n  successIndicator = (**(code **)(*(long *)(memoryAddress2 + 8) + 0x158))();\n  if (successIndicator == '\\0') {\n    copy_private_data_0010808f();\n    return;\n  }\nLAB_0011571e:\n  if (flag != '\\0') {\n    *(undefined4 *)(*(long *)(memoryAddress4 + 0xd0) + 4) = 8;\n  }\n  if (errorMsg != 0) {\n    status = 1;\n    bfd_nonfatal_message(0);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_0010808f",
                "dcgettext",
                "group_signature.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108179",
            "calling": [
                "setup_section.cold"
            ],
            "imported": false,
            "current_name": "set_alignment_00108179"
        },
        "FUN_00109022": {
            "renaming": {
                "FUN_00109022": "validate_and_retrieve_data_00109022",
                "param_1": "fileNumber",
                "param_2": "typeIndices",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "typeIndex",
                "pcVar2": "errorMsg",
                "plVar3": "dataPointer",
                "lVar4": "counter",
                "uVar5": "numIndices",
                "pplVar6": "dataPtrPtr",
                "bVar7": "byteVar",
                "auVar8": "returnVar"
            },
            "code": "\n\n\nundefined  [16] validateAndRetrieveData_00109022(long fileNumber,uint *typeIndices,undefined8 param3,undefined8 param4)\n\n{\n  uint typeIndex;\n  char *errorMsg;\n  long *dataPointer;\n  long counter;\n  uint numIndices;\n  long **dataPtrPtr;\n  byte byteVar;\n  undefined returnVar [16];\n  \n  byteVar = 0;\n  numIndices = *typeIndices;\n  typeIndex = typeIndices[1];\n  if (((int)numIndices < 0) || (*(uint *)(fileNumber + 0x80) <= numIndices)) {\n    errorMsg = (char *)dcgettext(0,\"Type file number %d out of range\\n\",5);\n    fprintf(_stderr,errorMsg,(ulong)numIndices);\n  }\n  else {\n    if (-1 < (int)typeIndex) {\n      dataPtrPtr = (long **)(*(long *)(fileNumber + 0x88) + (long)(int)numIndices * 8);\n      for (numIndices = typeIndex; 0xf < (int)numIndices; numIndices = numIndices - 0x10) {\n        if (*dataPtrPtr == (long *)0x0) {\n          dataPointer = (long *)xmalloc(0x88);\n          *dataPtrPtr = dataPointer;\n          for (counter = 0x22; counter != 0; counter = counter + -1) {\n            *(undefined4 *)dataPointer = 0;\n            dataPointer = (long *)((long)dataPointer + (ulong)byteVar * -8 + 4);\n          }\n        }\n        dataPtrPtr = (long **)*dataPtrPtr;\n      }\n      if (*dataPtrPtr == (long *)0x0) {\n        dataPointer = (long *)xmalloc(0x88);\n        *dataPtrPtr = dataPointer;\n        for (counter = 0x22; counter != 0; counter = counter + -1) {\n          *(undefined4 *)dataPointer = 0;\n          dataPointer = (long *)((long)dataPointer + (ulong)byteVar * -8 + 4);\n        }\n      }\n      dataPointer = *dataPtrPtr + (long)(int)((typeIndex >> 4) * -0x10 + typeIndex) + 1;\n      goto LAB_00109117;\n    }\n    errorMsg = (char *)dcgettext(0,\"Type index number %d out of range\\n\",5);\n    fprintf(_stderr,errorMsg,(ulong)typeIndex);\n  }\n  dataPointer = (long *)0x0;\nLAB_00109117:\n  returnVar._8_8_ = param4;\n  returnVar._0_8_ = dataPointer;\n  return returnVar;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109022",
            "calling": [
                "parse_stab_type",
                "stab_find_type"
            ],
            "imported": false,
            "current_name": "validate_and_retrieve_data_00109022"
        },
        "FUN_0010c05d": {
            "renaming": {
                "FUN_0010c05d": "process_debug_variable_0010c05d",
                "param_1": "sourceFile",
                "param_2": "variable",
                "param_3": "namespace",
                "param_4": "recordCount",
                "param_5": "param5",
                "param_6": "param6",
                "auVar1": "result",
                "uVar2": "returnValue",
                "piVar3": "ptrRecord",
                "cVar4": "flag",
                "lVar5": "loopCounter",
                "lVar6": "currentFile",
                "piVar7": "ptrRecordData"
            },
            "code": "\n\n\nundefined  [16]\nprocessDebugVariable_0010c05d(long sourceFile,long variable,ulong namespace,int recordCount,undefined8 param5,\n            undefined8 param6)\n\n{\n  undefined result [16];\n  undefined8 returnValue;\n  int *ptrRecord;\n  char flag;\n  long loopCounter;\n  long currentFile;\n  int *ptrRecordData;\n  byte bVar8;\n  undefined auVar9 [16];\n  \n  bVar8 = 0;\n  if (variable == 0) {\n    result._8_8_ = 0;\n    result._0_8_ = namespace;\n    return result << 0x40;\n  }\n  if (namespace != 0) {\n    if ((*(long *)(sourceFile + 8) == 0) || (currentFile = *(long *)(sourceFile + 0x10), currentFile == 0)) {\n      returnValue = dcgettext(0,\"debug_record_variable: no current file\",5);\n      fprintf(_stderr,\"%s\\n\",returnValue);\n    }\n    else {\n      if (recordCount - 1U < 2) {\n        currentFile = currentFile + 0x10;\n        flag = (recordCount == 1) + '\\x01';\n      }\n      else if (*(long *)(sourceFile + 0x20) == 0) {\n        currentFile = currentFile + 0x10;\n        flag = '\\0';\n      }\n      else {\n        currentFile = *(long *)(sourceFile + 0x20) + 0x28;\n        flag = '\\0';\n      }\n      currentFile = debug_add_to_namespace_constprop_0(currentFile,variable,2,flag);\n      if (currentFile != 0) {\n        ptrRecord = (int *)xmalloc(0x18);\n        ptrRecordData = ptrRecord + 1;\n        for (loopCounter = 5; loopCounter != 0; loopCounter = loopCounter + -1) {\n          *ptrRecordData = 0;\n          ptrRecordData = ptrRecordData + (ulong)bVar8 * -2 + 1;\n        }\n        *ptrRecord = recordCount;\n        returnValue = 1;\n        *(ulong *)(ptrRecord + 2) = namespace;\n        *(undefined8 *)(ptrRecord + 4) = param5;\n        *(int **)(currentFile + 0x20) = ptrRecord;\n        goto LAB_0010c12e;\n      }\n    }\n  }\n  returnValue = 0;\nLAB_0010c12e:\n  auVar9._8_8_ = param6;\n  auVar9._0_8_ = returnValue;\n  return auVar9;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext",
                "debug_add_to_namespace.constprop.0",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c05d",
            "calling": [
                "stab_record_variable",
                "parse_stab",
                "parse_coff_symbol.constprop.0.isra.0",
                "stab_emit_pending_vars"
            ],
            "imported": false,
            "current_name": "process_debug_variable_0010c05d"
        },
        "FUN_001041e0": {
            "renaming": {},
            "code": "\nvoid bfd_malloc_and_get_section(void)\n\n{\n  bfd_malloc_and_get_section();\n  return;\n}\n\n",
            "called": [
                "bfd_malloc_and_get_section"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001041e0",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "FUN_001041e0"
        },
        "FUN_00109d97": {
            "renaming": {
                "FUN_00109d97": "process_parameter_00109d97",
                "param_1": "parameter",
                "lVar1": "counter",
                "local_40": "outputString"
            },
            "code": "\nvoid processParameter_00109d97(long parameter)\n\n{\n  long counter;\n  char outputString [40];\n  \n  if (*(long *)(parameter + 0x70) != 0) {\n    stab_push_defined_type(parameter,*(long *)(parameter + 0x70),0);\n    return;\n  }\n  counter = *(long *)(parameter + 0x68);\n  *(long *)(parameter + 0x68) = counter + 1;\n  sprintf(outputString,\"%ld=%ld\",counter,counter);\n  stab_push_string(parameter,outputString,counter,0,0);\n  return;\n}\n\n",
            "called": [
                "stab_push_string",
                "sprintf",
                "stab_push_defined_type"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109d97",
            "calling": [
                "debug_write_type.constprop.0",
                "stab_method_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "process_parameter_00109d97"
        },
        "FUN_001284f0": {
            "renaming": {},
            "code": "\n\n\n\nvoid free(void *__ptr)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* free@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001284f0",
            "calling": [
                "main",
                "create_symbol_htab",
                "free"
            ],
            "imported": false,
            "current_name": "FUN_001284f0"
        },
        "FUN_00104810": {
            "renaming": {},
            "code": "\nvoid bfd_check_format(void)\n\n{\n  bfd_check_format();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104810",
            "calling": [
                "copy_file",
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "FUN_00104810"
        },
        "FUN_001086af": {
            "renaming": {
                "FUN_001086af": "FUNC_001086af"
            },
            "code": "\nulong FUNC_001086af(void)\n\n{\n  ulong uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  bool bVar4;\n  ulong *puVar5;\n  int iVar6;\n  long lVar7;\n  undefined8 uVar8;\n  ulong uVar9;\n  ulong uVar10;\n  ulong uVar11;\n  undefined *__ptr;\n  ulong in_RCX;\n  ulong uVar12;\n  ulong uVar13;\n  ulong uVar14;\n  ulong unaff_RBX;\n  ulong unaff_RBP;\n  ulong *puVar15;\n  undefined *puVar16;\n  char cVar17;\n  undefined *puVar18;\n  undefined *puVar19;\n  ulong *unaff_R12;\n  ulong unaff_R13;\n  ulong uVar20;\n  size_t __nmemb;\n  undefined8 *unaff_R14;\n  ulong *puVar21;\n  byte bVar22;\n  int iVar23;\n  ulong unaff_retaddr;\n  ulong param_7;\n  uint param_8;\n  ulong param_9;\n  ulong param_10;\n  ulong *param_11;\n  undefined *in_stack_00000030;\n  uint in_stack_00000038;\n  uint param_13;\n  undefined8 *param_14;\n  \n  bVar22 = 0;\n  param_7 = in_RCX;\n  uVar9 = (**(code **)(unaff_R14[1] + 0x40))();\n  uVar10 = (**(code **)(unaff_R14[1] + 0x40))(unaff_R12[4] + 4);\nLAB_0011662a:\n  uVar13 = unaff_RBP;\n  uVar20 = unaff_R13;\n  if (uVar10 < uVar9) {\n    uVar9 = uVar10;\n  }\n  do {\n    uVar11 = param_7;\n    uVar12 = param_7;\n    puVar15 = unaff_R12;\n    if (unaff_R12[2] == 0x100) {\n      if (uVar9 == 0) {\n        uVar9 = unaff_retaddr;\n      }\n      uVar14 = *unaff_R12;\n      unaff_R12[7] = uVar9;\n      unaff_RBP = uVar13;\n      unaff_R13 = uVar10;\n      unaff_retaddr = uVar9;\n      if (uVar10 == 0) goto LAB_001164af;\n    }\n    else {\n      if (uVar9 == 0) {\n        uVar9 = param_9;\n      }\n      uVar14 = *unaff_R12;\n      unaff_R12[7] = uVar9;\n      unaff_RBP = uVar10;\n      unaff_R13 = uVar20;\n      param_9 = uVar9;\n      if (uVar10 == 0) goto LAB_0011669e;\n    }\nLAB_001164bb:\n    puVar15[8] = uVar10;\n    if (*(char *)((puVar15[3] - 1) + uVar14) != '\\0') {\n      lVar7 = dcgettext(0,\"corrupt GNU build attribute note: name not NUL terminated\",5);\n      goto LAB_0010849a;\n    }\n    unaff_R12 = puVar15 + 9;\n    if (unaff_RBX < 0xc) {\n      if (unaff_RBX != 0) {\n        lVar7 = dcgettext(0,\"corrupt GNU build attribute notes: excess data at end\",5);\n        goto LAB_0010849a;\n      }\n      if ((in_stack_00000038 | param_13 | param_8) != 0) {\n        if (((param_13 | param_8) == 0) || (in_stack_00000038 == 0)) {\n          if (param_13 == 0) {\n            if (param_8 != 0) goto LAB_0011671b;\n            goto LAB_001166f8;\n          }\n          if (param_8 == 0) goto LAB_001166f8;\n        }\n        lVar7 = dcgettext(0,\"bad GNU build attribute notes: multiple different versions\",5);\n        goto LAB_0010849a;\n      }\n      uVar2 = *unaff_R14;\n      uVar3 = *param_14;\n      uVar8 = dcgettext(0,\"%s[%s]: Warning: version note missing - assuming version 3\",5);\n      non_fatal(uVar8,uVar2,uVar3);\nLAB_0011671b:\n      __nmemb = ((long)unaff_R12 - (long)param_11 >> 3) * -0x71c71c71c71c71c7;\n      qsort(param_11,__nmemb,0x48,compare_gnu_build_notes);\n      puVar15 = param_11;\n      goto LAB_001167f9;\n    }\n    uVar10 = (**(code **)(unaff_R14[1] + 0x40))(uVar12);\n    *unaff_R12 = uVar10;\n    uVar10 = (**(code **)(unaff_R14[1] + 0x40))(uVar12 + 4);\n    puVar15[10] = uVar10;\n    uVar9 = (**(code **)(unaff_R14[1] + 0x40))(uVar12 + 8);\n    uVar14 = *unaff_R12;\n    puVar15[0xb] = uVar9;\n    uVar10 = puVar15[10];\n    uVar13 = uVar14 + 3 & 0xfffffffffffffffc;\n    puVar15[0xf] = uVar13;\n    if (uVar10 != (uVar10 + 3 & 0xfffffffffffffffc)) {\n      lVar7 = dcgettext(0,\"corrupt GNU build attribute note: description size not a factor of 4\",5);\n      goto LAB_0010849a;\n    }\n    if (1 < uVar9 - 0x100) {\n      lVar7 = dcgettext(0,\"corrupt GNU build attribute note: wrong note type\",5);\n      goto LAB_0010849a;\n    }\n    uVar11 = uVar13 + uVar10 + 0xc;\n    if (unaff_RBX < uVar11) {\n      lVar7 = dcgettext(0,\"corrupt GNU build attribute note: note too big\",5);\n      goto LAB_0010849a;\n    }\n    if (uVar14 < 2) {\n      lVar7 = dcgettext(0,\"corrupt GNU build attribute note: name too small\",5);\n      goto LAB_0010849a;\n    }\n    puVar15[0xc] = uVar12 + 0xc;\n    uVar1 = uVar12 + 0xc + uVar13;\n    puVar15[0xd] = uVar1;\n    unaff_RBX = unaff_RBX + (-0xc - (uVar13 + uVar10));\n    uVar11 = uVar12 + uVar11;\n    if (uVar14 != 2) {\n      if (*(char *)(uVar12 + 0xc) == '$') {\n        if ((*(char *)(uVar12 + 0xd) == '\\x01') && (*(char *)(uVar12 + 0xe) == '1')) {\n          uVar10 = extract_build_attribute_notes_00116490();\n          return uVar10;\n        }\n      }\n      else if ((((4 < uVar14) && (*(char *)(uVar12 + 0xc) == 'G')) &&\n               (*(char *)(uVar12 + 0xd) == 'A')) &&\n              ((*(char *)(uVar12 + 0xe) == '$' && (*(char *)(uVar12 + 0xf) == '\\x01')))) {\n        if (*(char *)(uVar12 + 0x10) == '2') {\n          uVar10 = extract_build_attribute_notes_00116490();\n          return uVar10;\n        }\n        if (*(char *)(uVar12 + 0x10) == '3') {\n          uVar10 = extract_build_attribute_notes_00116490();\n          return uVar10;\n        }\n        lVar7 = dcgettext(0,\"corrupt GNU build attribute note: unsupported version\",5);\n        goto LAB_0010849a;\n      }\n    }\n    uVar13 = unaff_RBP;\n    uVar20 = unaff_R13;\n    if (uVar10 == 0) {\n      if (uVar9 == 0x100) {\n        puVar15[0x10] = unaff_retaddr;\nLAB_001164af:\n        uVar12 = uVar11;\n        uVar10 = uVar20;\n        puVar15 = unaff_R12;\n        unaff_R13 = uVar20;\n      }\n      else {\n        puVar15[0x10] = param_9;\nLAB_0011669e:\n        unaff_RBP = uVar13;\n        uVar12 = uVar11;\n        uVar10 = uVar13;\n        puVar15 = unaff_R12;\n        unaff_R13 = uVar20;\n      }\n      goto LAB_001164bb;\n    }\n    if (uVar10 == 0x10) break;\n    if (0x10 < uVar10) {\nLAB_00116679:\n      lVar7 = dcgettext(0,\"corrupt GNU build attribute note: bad description size\",5);\nLAB_0010849a:\n      if (lVar7 != 0) {\n        bfd_set_error(0x11);\n        bfd_nonfatal_message(0,unaff_R14,param_14,lVar7);\n        status = 1;\n      }\n      goto LAB_001166f8;\n    }\n    if (uVar10 != 4) {\n      if (uVar10 == 8) {\n        uVar10 = FUNC_001086af();\n        return uVar10;\n      }\n      goto LAB_00116679;\n    }\n    param_7 = uVar11;\n    uVar9 = (**(code **)(unaff_R14[1] + 0x40))();\n    uVar10 = 0xffffffffffffffff;\n  } while( true );\n  param_7 = uVar11;\n  uVar9 = (**(code **)(unaff_R14[1] + 0x28))(uVar1);\n  uVar10 = (**(code **)(unaff_R14[1] + 0x28))();\n  goto LAB_0011662a;\nLAB_001167f9:\n  if (unaff_R12 <= puVar15) {\n    qsort(param_11,__nmemb,0x48,sort_gnu_build_notes);\n    __ptr = (undefined *)xmalloc(param_10 * 2);\n    param_7 = 0;\n    param_9 = 0;\n    puVar19 = __ptr;\n    for (puVar15 = param_11; puVar15 < unaff_R12; puVar15 = puVar15 + 9) {\n      if (puVar15[2] != 0) {\n        puVar18 = puVar19 + 4;\n        puVar16 = puVar19 + 0xc;\n        if ((puVar15[7] == param_9) && (puVar15[8] == param_7)) {\n          (**(code **)(unaff_R14[1] + 0x50))(*puVar15,puVar19);\n          (**(code **)(unaff_R14[1] + 0x50))(0,puVar18);\n          (**(code **)(unaff_R14[1] + 0x50))(puVar15[2],puVar19 + 8);\n          uVar9 = puVar15[6];\n          uVar10 = *puVar15;\n          puVar19 = (undefined *)puVar15[3];\n          puVar18 = puVar16;\n          for (uVar13 = uVar10; uVar13 != 0; uVar13 = uVar13 - 1) {\n            *puVar18 = *puVar19;\n            puVar19 = puVar19 + (ulong)bVar22 * -2 + 1;\n            puVar18 = puVar18 + (ulong)bVar22 * -2 + 1;\n          }\n          if (uVar10 < uVar9) {\n            for (lVar7 = uVar9 - uVar10; lVar7 != 0; lVar7 = lVar7 + -1) {\n              *puVar18 = 0;\n              puVar18 = puVar18 + (ulong)bVar22 * -2 + 1;\n            }\n          }\n          puVar19 = puVar16 + uVar9;\n        }\n        else {\n          (**(code **)(unaff_R14[1] + 0x50))();\n          if (*(int *)(unaff_R14[1] + 8) == 5) {\n            cVar17 = (*(char *)(unaff_R14[0x22] + 4) == '\\x02') * '\\b' + '\\b';\n          }\n          else {\n            cVar17 = '\\b';\n          }\n          (**(code **)(unaff_R14[1] + 0x50))(cVar17,puVar18);\n          (**(code **)(unaff_R14[1] + 0x50))(puVar15[2],puVar19 + 8);\n          uVar10 = *puVar15;\n          puVar19 = (undefined *)puVar15[3];\n          puVar18 = puVar16;\n          for (uVar9 = uVar10; uVar9 != 0; uVar9 = uVar9 - 1) {\n            *puVar18 = *puVar19;\n            puVar19 = puVar19 + (ulong)bVar22 * -2 + 1;\n            puVar18 = puVar18 + (ulong)bVar22 * -2 + 1;\n          }\n          uVar9 = puVar15[6];\n          if (uVar10 < uVar9) {\n            for (lVar7 = uVar9 - uVar10; lVar7 != 0; lVar7 = lVar7 + -1) {\n              *puVar18 = 0;\n              puVar18 = puVar18 + (ulong)bVar22 * -2 + 1;\n            }\n          }\n          lVar7 = unaff_R14[1];\n          puVar16 = puVar16 + uVar9;\n          puVar19 = puVar16 + 8;\n          if ((*(int *)(lVar7 + 8) == 5) && (*(char *)(unaff_R14[0x22] + 4) == '\\x02')) {\n            (**(code **)(lVar7 + 0x38))(puVar15[7],puVar16);\n            (**(code **)(unaff_R14[1] + 0x38))(puVar15[8],puVar19);\n            puVar19 = puVar16 + 0x10;\n          }\n          else {\n            (**(code **)(lVar7 + 0x50))(puVar15[7],puVar16);\n            (**(code **)(unaff_R14[1] + 0x50))(puVar15[8],puVar16 + 4);\n          }\n          param_9 = puVar15[7];\n          param_7 = puVar15[8];\n        }\n      }\n    }\n    uVar9 = (long)puVar19 - (long)__ptr;\n    uVar10 = uVar9;\n    puVar19 = __ptr;\n    if (uVar9 < param_10) {\n      for (; param_10 = uVar9, uVar10 != 0; uVar10 = uVar10 - 1) {\n        *in_stack_00000030 = *puVar19;\n        puVar19 = puVar19 + (ulong)bVar22 * -2 + 1;\n        in_stack_00000030 = in_stack_00000030 + (ulong)bVar22 * -2 + 1;\n      }\n    }\n    free(__ptr);\nLAB_001166f8:\n    free(param_11);\n    return param_10;\n  }\n  if (puVar15[2] != 0) {\n    uVar10 = puVar15[7];\n    uVar9 = puVar15[8];\n    uVar13 = puVar15[2];\n    puVar21 = puVar15;\n    iVar23 = 0;\n    if (uVar10 == uVar9) {\n      puVar15[2] = 0;\n    }\n    else {\n      do {\n        do {\n          puVar5 = puVar21;\n          puVar21 = puVar5 + -9;\n          if (puVar21 < param_11) goto LAB_001167f5;\n          uVar20 = puVar5[-7];\n        } while (uVar20 == 0);\n        param_7 = uVar13;\n        if ((*puVar21 != *puVar15) ||\n           (iVar6 = memcmp((void *)puVar5[-6],(void *)puVar15[3],*puVar15), iVar6 != 0)) break;\n        uVar13 = puVar5[-2];\n        uVar11 = puVar5[-1];\n        if (uVar10 == uVar13) {\n          if (uVar9 == uVar11) {\n            puVar15[2] = 0;\n            break;\n          }\nLAB_001167a6:\n          if (uVar9 <= uVar11) {\n            puVar15[2] = 0;\n            break;\n          }\n          if (uVar11 < uVar10) {\nLAB_0010852c:\n            if ((0xfffffffffffffff0 < uVar11) || (uVar10 <= (uVar11 + 0xf & 0xfffffffffffffff0)))\n            goto process_build_notes_00116852;\n          }\nLAB_001167b8:\n          if ((param_7 == 0x101) == (uVar20 == 0x101)) {\n            if (uVar11 <= uVar9) {\n              uVar11 = uVar9;\n            }\n            if (uVar13 < uVar10) {\n              uVar10 = uVar13;\n            }\n            puVar5[-1] = uVar11;\n            puVar5[-2] = uVar10;\n            puVar15[2] = 0;\n            break;\n          }\n        }\n        else {\n          if (uVar13 <= uVar10) goto LAB_001167a6;\n          if (uVar11 < uVar10) goto LAB_0010852c;\n          if (uVar9 < uVar10) {\n            if ((0xfffffffffffffff0 < uVar9) || (uVar13 <= (uVar9 + 0xf & 0xfffffffffffffff0)))\n            goto process_build_notes_00116852;\n            goto LAB_001167b8;\n          }\n          if (uVar9 != uVar11) goto LAB_001167b8;\n        }\nprocess_build_notes_00116852:\n        bVar4 = iVar23 < 0x11;\n        uVar13 = param_7;\n        iVar23 = iVar23 + 1;\n      } while (bVar4);\n    }\n  }\nLAB_001167f5:\n  puVar15 = puVar15 + 9;\n  goto LAB_001167f9;\n}\n\n",
            "called": [
                "bfd_set_error",
                "dcgettext",
                "non_fatal",
                "qsort",
                "compare_gnu_build_notes",
                "bfd_nonfatal_message",
                "merge_gnu_build_notes.cold",
                "FUN_00116490"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x001086af",
            "calling": [
                "FUN_00116490"
            ],
            "imported": false,
            "current_name": "FUNC_001086af"
        },
        "FUN_0010add5": {
            "renaming": {
                "FUN_0010add5": "initialize_function_0010add5",
                "stab_class_method_var": "setupClassMethodVariable"
            },
            "code": "\nvoid initializeFunction_0010add5(void)\n\n{\n  setupClassMethodVariable();\n  return;\n}\n\n",
            "called": [
                "stab_class_method_var"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010add5",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "initialize_function_0010add5"
        },
        "FUN_00113e17": {
            "renaming": {
                "FUN_00113e17": "set_constant_property_00113e17",
                "debug_make_type_constprop_0": "makeTypeConstpropZero"
            },
            "code": "\nvoid setConstantProperty_00113e17(void)\n\n{\n  makeTypeConstpropZero(2,0);\n  return;\n}\n\n",
            "called": [
                "debug_make_type.constprop.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113e17",
            "calling": [
                "stab_demangle_v3_arg",
                "parse_coff_type.lto_priv.0",
                "parse_stab_type",
                "stab_find_type",
                "stab_demangle_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "set_constant_property_00113e17"
        },
        "FUN_00109b52": {
            "renaming": {
                "FUN_00109b52": "initialize_data_00109b52",
                "param_1": "dataStructPtr",
                "param_2": "sourceString",
                "param_3": "param3Value",
                "param_4": "param4Value",
                "param_5": "param5Value",
                "uVar1": "tempVar1",
                "puVar2": "allocatedMemory",
                "uVar3": "duplicatedString"
            },
            "code": "\nundefined initializeData_00109b52(long dataStructPtr,undefined8 sourceString,undefined8 param3Value,undefined param4Value,\n                      undefined4 param5Value)\n\n{\n  undefined8 tempVar1;\n  undefined8 *allocatedMemory;\n  undefined8 duplicatedString;\n  \n  allocatedMemory = (undefined8 *)xmalloc(0x40);\n  duplicatedString = xstrdup(sourceString);\n  allocatedMemory[2] = param3Value;\n  *(undefined (*) [16])(allocatedMemory + 4) = ZEXT816(0);\n  *(undefined (*) [16])(allocatedMemory + 6) = ZEXT816(0);\n  tempVar1 = *(undefined8 *)(dataStructPtr + 0x60);\n  *(undefined *)((long)allocatedMemory + 0x1c) = param4Value;\n  *(undefined4 *)(allocatedMemory + 3) = param5Value;\n  *(undefined8 **)(dataStructPtr + 0x60) = allocatedMemory;\n  *allocatedMemory = tempVar1;\n  allocatedMemory[1] = duplicatedString;\n  return 1;\n}\n\n",
            "called": [
                "xstrdup",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109b52",
            "calling": [
                "stab_void_type.lto_priv.0",
                "stab_complex_type.lto_priv.0",
                "stab_end_struct_type.lto_priv.0",
                "stab_range_type.lto_priv.0",
                "stab_push_defined_type",
                "stab_float_type.lto_priv.0",
                "stab_int_type.lto_priv.0",
                "stab_set_type.lto_priv.0",
                "stab_start_struct_type.lto_priv.0",
                "stab_array_type.lto_priv.0",
                "stab_offset_type.lto_priv.0",
                "stab_enum_type.lto_priv.0",
                "stab_modify_type",
                "stab_empty_type.lto_priv.0",
                "stab_method_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "initialize_data_00109b52"
        },
        "FUN_001282b0": {
            "renaming": {},
            "code": "\n\n\n\nint stat(char *__file,stat *__buf)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* stat@GLIBC_2.33 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001282b0",
            "calling": [
                "stat"
            ],
            "imported": false,
            "current_name": "FUN_001282b0"
        },
        "FUN_001040c0": {
            "renaming": {},
            "code": "\n\n\nint unlink(char *__name)\n\n{\n  int iVar1;\n  \n  iVar1 = unlink(__name);\n  return iVar1;\n}\n\n",
            "called": [
                "unlink"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001040c0",
            "calling": [
                "FUN_00104ea2",
                "display_info.isra.0",
                "smart_rename.cold"
            ],
            "imported": false,
            "current_name": "FUN_001040c0"
        },
        "FUN_00109a32": {
            "renaming": {
                "FUN_00109a32": "parse_and_convert_input_00109a32",
                "param_1": "input_string",
                "param_2": "overflow_flag",
                "param_3": "end_of_string",
                "param_4": "unused_param",
                "param_5": "output_size",
                "__nptr": "current_position",
                "piVar1": "error_code",
                "uVar2": "converted_value",
                "uVar3": "error_message",
                "auVar4": "result"
            },
            "code": "\nundefined  [16]\nparse_and_convert_input_00109a32(char **input_string,undefined *overflow_flag,char *end_of_string,undefined8 unused_param,undefined8 output_size)\n\n{\n  char *current_position;\n  int *error_code;\n  ulong converted_value;\n  undefined8 error_message;\n  undefined result [16];\n  \n  if (overflow_flag != (undefined *)0x0) {\n    *overflow_flag = 0;\n  }\n  current_position = *input_string;\n  if ((current_position < end_of_string) && (*current_position != '\\0')) {\n    error_code = __errno_location();\n    *error_code = 0;\n    converted_value = strtoul(current_position,input_string,0);\n    if ((converted_value != 0xffffffffffffffff) || (*error_code == 0)) goto LAB_00109aa9;\n    if (overflow_flag == (undefined *)0x0) {\n      error_message = dcgettext(0,\"numeric overflow\",5);\n      warn_stab(current_position,error_message);\n    }\n    else {\n      *overflow_flag = 1;\n    }\n  }\n  converted_value = 0;\nLAB_00109aa9:\n  result._8_8_ = output_size;\n  result._0_8_ = converted_value;\n  return result;\n}\n\n",
            "called": [
                "dcgettext",
                "strtoul",
                "warn_stab",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109a32",
            "calling": [
                "parse_stab_type",
                "parse_stab_type_number"
            ],
            "imported": false,
            "current_name": "parse_and_convert_input_00109a32"
        },
        "FUN_0010c6be": {
            "renaming": {
                "FUN_0010c6be": "debug_tag_type_0010c6be",
                "param_1": "file_ptr",
                "param_2": "tag_name",
                "param_3": "tag_ptr",
                "iVar1": "str_cmp_res",
                "pauVar4": "type_ptr",
                "lVar5": "namespace_ptr",
                "pcVar6": "error_msg",
                "uVar2": "translated_msg"
            },
            "code": "\n\n\nint * debug_tag_type_0010c6be(long file_ptr,char *tag_name,int *tag_ptr)\n\n{\n  int str_cmp_res;\n  undefined8 translated_msg;\n  int *piVar3;\n  undefined (*type_ptr) [16];\n  long namespace_ptr;\n  char *error_msg;\n  \n  if ((tag_name != (char *)0x0) && (tag_ptr != (int *)0x0)) {\n    if (*(long *)(file_ptr + 0x10) == 0) {\n      error_msg = \"debug_tag_type_0010c6be: no current file\";\n    }\n    else {\n      if (*tag_ptr != 0x17) {\n        piVar3 = (int *)debug_make_type_constprop_0(0x17,0);\n        if (piVar3 == (int *)0x0) {\n          return (int *)0x0;\n        }\n        type_ptr = (undefined (*) [16])xmalloc(0x10);\n        namespace_ptr = *(long *)(file_ptr + 0x10);\n        *type_ptr = ZEXT816(0);\n        *(int **)(*type_ptr + 8) = tag_ptr;\n        *(undefined (**) [16])(piVar3 + 4) = type_ptr;\n        namespace_ptr = debug_add_to_namespace_constprop_0(namespace_ptr + 0x10,tag_name,1,3);\n        if (namespace_ptr == 0) {\n          return (int *)0x0;\n        }\n        *(int **)(namespace_ptr + 0x20) = piVar3;\n        *(long *)*type_ptr = namespace_ptr;\n        return piVar3;\n      }\n      str_cmp_res = strcmp(*(char **)(**(long **)(tag_ptr + 4) + 8),tag_name);\n      error_msg = \"debug_tag_type_0010c6be: extra tag attempted\";\n      if (str_cmp_res == 0) {\n        return tag_ptr;\n      }\n    }\n    translated_msg = dcgettext(0,error_msg,5);\n    fprintf(_stderr,\"%s\\n\",translated_msg);\n  }\n  return (int *)0x0;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext",
                "debug_add_to_namespace.constprop.0",
                "debug_make_type.constprop.0",
                "xmalloc",
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c6be",
            "calling": [
                "parse_stab",
                "parse_coff_symbol.constprop.0.isra.0",
                "finish_stab"
            ],
            "imported": false,
            "current_name": "debug_tag_type_0010c6be"
        },
        "FUN_0010b6ea": {
            "renaming": {
                "FUN_0010b6ea": "demangle_arglist_v3_0010b6ea",
                "param_1": "arglistPtr",
                "param_2": "arglistSize",
                "param_3": "argNodePtr",
                "param_4": "isErrorPtr",
                "__ptr": "resultPtr",
                "__format": "errorMsg",
                "lVar1": "demangleResult",
                "uVar2": "numArgs",
                "uVar3": "maxArgs",
                "uVar4": "newNumArgs",
                "local_39": "demangledArg"
            },
            "code": "\n\n\nvoid * demangleArglistV3_0010b6ea(undefined8 arglistPtr,undefined8 arglistSize,int *argNodePtr,undefined *isErrorPtr)\n\n{\n  void *resultPtr;\n  char *errorMsg;\n  long demangleResult;\n  ulong numArgs;\n  ulong maxArgs;\n  uint newNumArgs;\n  char demangledArg [9];\n  \n  maxArgs = 10;\n  numArgs = 0;\n  resultPtr = (void *)xmalloc(0x50);\n  *isErrorPtr = 0;\n  for (; argNodePtr != (int *)0x0; argNodePtr = *(int **)(argNodePtr + 6)) {\n    if (*argNodePtr != 0x2e) {\n      errorMsg = (char *)dcgettext(0,\"Unexpected type in v3 arglist demangling\\n\",5);\n      fprintf(_stderr,errorMsg);\n      free(resultPtr);\n      return (void *)0x0;\n    }\n    if (*(long *)(argNodePtr + 4) == 0) break;\n    demangleResult = stab_demangle_v3_arg(arglistPtr,arglistSize,*(long *)(argNodePtr + 4),0,demangledArg);\n    if (demangleResult == 0) {\n      if (demangledArg[0] == '\\0') {\n        free(resultPtr);\n        return (void *)0x0;\n      }\n      *isErrorPtr = 1;\n    }\n    else {\n      newNumArgs = (int)numArgs + 1;\n      if ((uint)maxArgs <= newNumArgs) {\n        maxArgs = (ulong)((uint)maxArgs + 10);\n        resultPtr = (void *)xrealloc(resultPtr,maxArgs << 3);\n      }\n      *(long *)((long)resultPtr + numArgs * 8) = demangleResult;\n      numArgs = (ulong)newNumArgs;\n    }\n  }\n  *(undefined8 *)((long)resultPtr + numArgs * 8) = 0;\n  return resultPtr;\n}\n\n",
            "called": [
                "stab_demangle_v3_arg",
                "fprintf",
                "dcgettext",
                "xrealloc",
                "free",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010b6ea",
            "calling": [
                "stab_demangle_v3_arg",
                "parse_stab_type"
            ],
            "imported": false,
            "current_name": "demangle_arglist_v3_0010b6ea"
        },
        "FUN_0011a2e0": {
            "renaming": {
                "FUN_0011a2e0": "extract_section_from_binary_0011a2e0",
                "param_1": "binary_header",
                "param_2": "binary_file",
                "uVar1": "section_name",
                "uVar2": "error_message",
                "lVar3": "section_header",
                "lVar4": "section_address"
            },
            "code": "\nlong extract_section_from_binary_0011a2e0(long binary_header,long binary_file)\n\n{\n  undefined8 section_name;\n  undefined8 error_message;\n  long section_header;\n  long section_address;\n  \n  section_header = (**(code **)(*(long *)(binary_file + 8) + 0x208))(binary_file);\n  section_address = *(long *)(binary_header + 0x20);\n  *(undefined8 *)(section_header + 8) = *(undefined8 *)(binary_header + 8);\n  *(undefined8 *)(section_header + 0x10) = *(undefined8 *)(binary_header + 0x10);\n  *(undefined4 *)(section_header + 0x18) = *(undefined4 *)(binary_header + 0x18);\n  if (section_address == 0) {\n    section_address = 0x128598;\n  }\n  else {\n    section_address = bfd_get_section_by_name(binary_file);\n    if (section_address == 0) {\n      section_name = *(undefined8 *)(binary_header + 0x20);\n      error_message = dcgettext(0,\"Section %s not found\",5);\n                    \n      fatal(error_message,section_name);\n    }\n  }\n  *(long *)(section_header + 0x20) = section_address;\n  return section_header;\n}\n\n",
            "called": [
                "bfd_get_section_by_name",
                "create_new_symbol.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a2e0",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "extract_section_from_binary_0011a2e0"
        },
        "FUN_0010e8a9": {
            "renaming": {
                "FUN_0010e8a9": "write_symbol_with_param_0010e8a9",
                "param_1": "filename",
                "param_2": "symbol",
                "param_3": "value",
                "uVar1": "result",
                "sVar2": "value_length",
                "__s": "buffer"
            },
            "code": "\nundefined4 write_symbol_with_param_0010e8a9(undefined8 filename,undefined8 symbol,char *value)\n\n{\n  undefined4 result;\n  size_t value_length;\n  char *buffer;\n  \n  value_length = strlen(value);\n  buffer = (char *)xmalloc(value_length + 0x14);\n  sprintf(buffer,\"%s:c=f%g\",filename,value);\n  result = stab_write_symbol_lto_priv_0(symbol,0x80,0,0,buffer);\n  if ((char)result != '\\0') {\n    free(buffer);\n  }\n  return result;\n}\n\n",
            "called": [
                "strlen",
                "stab_write_symbol.lto_priv.0",
                "sprintf",
                "free",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e8a9",
            "calling": [
                "debug_write_name.constprop.0"
            ],
            "imported": false,
            "current_name": "write_symbol_with_param_0010e8a9"
        },
        "FUN_00104ad6": {
            "renaming": {
                "FUN_00104ad6": "parse_section_flags_00104ad6",
                "unaff_RBP": "currentString",
                "__s": "sectionFlag",
                "unaff_R14D": "flags",
                "unaff_R15": "currentFlag",
                "unaff_retaddr": "returnAddress",
                "iVar1": "comparisonResult",
                "uVar2": "errorString",
                "pcVar3": "commaPosition",
                "sVar4": "sectionFlagLength",
                "iVar5": "stringLength",
                "auVar6": "returnValue"
            },
            "code": "\nundefined  [16] parseSectionFlags_00104ad6(void)\n\n{\n  int comparisonResult;\n  undefined8 errorString;\n  char *commaPosition;\n  char *currentString;\n  char *sectionFlag;\n  size_t sectionFlagLength;\n  int stringLength;\n  uint flags;\n  char *currentFlag;\n  undefined returnValue [16];\n  undefined8 returnAddress;\n  \n  do {\n    flags = flags | 0x2000;\n    sectionFlag = currentString;\n    while( true ) {\n      while( true ) {\n        while( true ) {\n          while( true ) {\n            while( true ) {\n              if (sectionFlag == (char *)0x0) {\n                returnValue._4_4_ = 0;\n                returnValue._0_4_ = flags;\n                returnValue._8_8_ = returnAddress;\n                return returnValue;\n              }\n              commaPosition = strchr(sectionFlag,0x2c);\n              if (commaPosition == (char *)0x0) {\n                sectionFlagLength = strlen(sectionFlag);\n                stringLength = (int)sectionFlagLength;\n                currentString = (char *)0x0;\n              }\n              else {\n                currentString = commaPosition + 1;\n                stringLength = (int)commaPosition - (int)sectionFlag;\n              }\n              sectionFlagLength = (size_t)stringLength;\n              comparisonResult = strncasecmp(currentFlag,sectionFlag,sectionFlagLength);\n              if (comparisonResult != 0) break;\n              flags = flags | 1;\n              sectionFlag = currentString;\n            }\n            comparisonResult = strncasecmp(\"load\",sectionFlag,sectionFlagLength);\n            if (comparisonResult != 0) break;\n            flags = flags | 2;\n            sectionFlag = currentString;\n          }\n          comparisonResult = strncasecmp(\"noload\",sectionFlag,sectionFlagLength);\n          if (comparisonResult != 0) break;\n          flags = flags | 0x200;\n          sectionFlag = currentString;\n        }\n        comparisonResult = strncasecmp(\"readonly\",sectionFlag,sectionFlagLength);\n        if (comparisonResult != 0) break;\n        flags = flags | 8;\n        sectionFlag = currentString;\n      }\n      comparisonResult = strncasecmp(\"debug\",sectionFlag,sectionFlagLength);\n      if (comparisonResult == 0) break;\n      comparisonResult = strncasecmp(\"code\",sectionFlag,sectionFlagLength);\n      if (comparisonResult == 0) {\n        flags = flags | 0x10;\n        sectionFlag = currentString;\n      }\n      else {\n        comparisonResult = strncasecmp(\"data\",sectionFlag,sectionFlagLength);\n        if (comparisonResult == 0) {\n          flags = flags | 0x20;\n          sectionFlag = currentString;\n        }\n        else {\n          comparisonResult = strncasecmp(\"rom\",sectionFlag,sectionFlagLength);\n          if (comparisonResult == 0) {\n            flags = flags | 0x40;\n            sectionFlag = currentString;\n          }\n          else {\n            comparisonResult = strncasecmp(\"exclude\",sectionFlag,sectionFlagLength);\n            if (comparisonResult == 0) {\n              flags = flags | 0x8000;\n              sectionFlag = currentString;\n            }\n            else {\n              comparisonResult = strncasecmp(\"share\",sectionFlag,sectionFlagLength);\n              if (comparisonResult == 0) {\n                flags = flags | 0x8000000;\n                sectionFlag = currentString;\n              }\n              else {\n                comparisonResult = strncasecmp(\"contents\",sectionFlag,sectionFlagLength);\n                if (comparisonResult == 0) {\n                  flags = flags | 0x100;\n                  sectionFlag = currentString;\n                }\n                else {\n                  comparisonResult = strncasecmp(\"merge\",sectionFlag,sectionFlagLength);\n                  if (comparisonResult == 0) {\n                    flags = flags | 0x800000;\n                    sectionFlag = currentString;\n                  }\n                  else {\n                    comparisonResult = strncasecmp(\"strings\",sectionFlag,sectionFlagLength);\n                    if (comparisonResult != 0) {\n                      commaPosition = (char *)xmalloc((long)(stringLength + 1));\n                      strncpy(commaPosition,sectionFlag,sectionFlagLength);\n                      commaPosition[sectionFlagLength] = '\\0';\n                      errorString = dcgettext(0,\"unrecognized section flag `%s\\'\",5);\n                      non_fatal(errorString,commaPosition);\n                      errorString = dcgettext(0,\"supported flags: %s\",5);\n                    \n                      fatal(errorString,\n                            \"alloc, load, noload, readonly, debug, code, data, rom, exclude, share, contents, merge, strings\"\n                           );\n                    }\n                    flags = flags | 0x1000000;\n                    sectionFlag = currentString;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } while( true );\n}\n\n",
            "called": [
                "parse_flags.cold",
                "strlen",
                "strchr",
                "strncpy",
                "dcgettext",
                "non_fatal",
                "strncasecmp",
                "xmalloc",
                "fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104ad6",
            "calling": [
                "parse_flags.cold"
            ],
            "imported": false,
            "current_name": "parse_section_flags_00104ad6"
        },
        "FUN_001087da": {
            "renaming": {
                "FUN_001087da": "check_is_rax_equal_to0x100_001087da",
                "in_RAX": "inputValue",
                "auVar1": "returnValue",
                "unaff_retaddr": "returnAddress"
            },
            "code": "\nundefined  [16] checkIsRAXEqualTo0x100_001087da(void)\n\n{\n  long inputValue;\n  undefined returnValue [16];\n  undefined8 returnAddress;\n  \n  returnValue._1_7_ = 0;\n  returnValue[0] = inputValue == 0x100;\n  returnValue._8_8_ = returnAddress;\n  return returnValue;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001087da",
            "calling": [
                "compare_gnu_build_notes"
            ],
            "imported": false,
            "current_name": "check_is_rax_equal_to0x100_001087da"
        },
        "FUN_0010914e": {
            "renaming": {
                "FUN_0010914e": "find_named_type_0010914e",
                "param_1": "compilation_unit",
                "param_2": "type_name",
                "param_3": "arg3",
                "param_4": "arg4",
                "lVar1": "current_unit_ptr",
                "iVar2": "comparison_result",
                "uVar3": "error_message",
                "puVar4": "current",
                "lVar5": "current_ptr",
                "puVar6": "current_unit",
                "auVar7": "result"
            },
            "code": "\n\n\nundefined  [16] find_named_type_0010914e(long compilation_unit,char *type_name,undefined8 arg3,undefined8 arg4)\n\n{\n  long current_unit_ptr;\n  int comparison_result;\n  undefined8 error_message;\n  undefined8 *current;\n  long current_ptr;\n  undefined8 *current_unit;\n  undefined result [16];\n  \n  current_unit_ptr = *(long *)(compilation_unit + 8);\n  if (current_unit_ptr == 0) {\n    error_message = dcgettext(0,\"debug_find_named_type_0010914e: no current compilation unit\",5);\n    fprintf(_stderr,\"%s\\n\",error_message);\n  }\n  else {\n    for (current_ptr = *(long *)(compilation_unit + 0x20); current_ptr != 0; current_ptr = *(long *)(current_ptr + 8)) {\n      if (*(undefined8 **)(current_ptr + 0x28) != (undefined8 *)0x0) {\n        for (current = (undefined8 *)**(undefined8 **)(current_ptr + 0x28); current != (undefined8 *)0x0;\n            current = (undefined8 *)*current) {\n          if (*(int *)((long)current + 0x14) == 0) {\n            if (*(char *)current[1] == *type_name) {\n              comparison_result = strcmp((char *)current[1],type_name);\n              if (comparison_result == 0) goto LAB_00109216;\n            }\n          }\n        }\n      }\n    }\n    for (current_unit = *(undefined8 **)(current_unit_ptr + 8); current_unit != (undefined8 *)0x0;\n        current_unit = (undefined8 *)*current_unit) {\n      if ((undefined8 *)current_unit[2] != (undefined8 *)0x0) {\n        for (current = *(undefined8 **)(undefined8 *)current_unit[2]; current != (undefined8 *)0x0;\n            current = (undefined8 *)*current) {\n          if (*(int *)((long)current + 0x14) == 0) {\n            if (*(char *)current[1] == *type_name) {\n              comparison_result = strcmp((char *)current[1],type_name);\n              if (comparison_result == 0) goto LAB_00109216;\n            }\n          }\n        }\n      }\n    }\n  }\n  error_message = 0;\nLAB_00109223:\n  result._8_8_ = arg4;\n  result._0_8_ = error_message;\n  return result;\nLAB_00109216:\n  error_message = current[4];\n  goto LAB_00109223;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext",
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010914e",
            "calling": [
                "parse_stab_type",
                "stab_demangle_qualified",
                "stab_demangle_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "find_named_type_0010914e"
        },
        "FUN_001041f0": {
            "renaming": {},
            "code": "\nvoid bfd_openr(void)\n\n{\n  bfd_openr();\n  return;\n}\n\n",
            "called": [
                "bfd_openr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001041f0",
            "calling": [
                "copy_file",
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "FUN_001041f0"
        },
        "FUN_001040d0": {
            "renaming": {},
            "code": "\n\n\nchar * strncpy(char *__dest,char *__src,size_t __n)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strncpy(__dest,__src,__n);\n  return pcVar1;\n}\n\n",
            "called": [
                "strncpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001040d0",
            "calling": [
                "main",
                "parse_flags.cold"
            ],
            "imported": false,
            "current_name": "FUN_001040d0"
        },
        "FUN_0010829e": {
            "renaming": {
                "FUN_0010829e": "process_ebp_value_0010829e",
                "unaff_EBP": "ebp_value",
                "uVar1": "result"
            },
            "code": "\nundefined8 process_EBP_value_0010829e(void)\n\n{\n  undefined8 result;\n  int ebp_value;\n  \n  if (ebp_value == 5) {\n    result = is_dwo_section_constprop_0();\n    return result;\n  }\n  if ((ebp_value != 4) && (ebp_value == 6)) {\n    result = invert_and_get_dwo_section_constprop_001082b3();\n    return result;\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_001082b3",
                "is_dwo_section.constprop.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010829e",
            "calling": [
                "is_strip_section_1.isra.0"
            ],
            "imported": false,
            "current_name": "process_ebp_value_0010829e"
        },
        "FUN_001281c0": {
            "renaming": {},
            "code": "\n\n\n\nint fnmatch(char *__pattern,char *__name,int __flags)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fnmatch@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001281c0",
            "calling": [
                "fnmatch"
            ],
            "imported": false,
            "current_name": "FUN_001281c0"
        },
        "FUN_00104700": {
            "renaming": {},
            "code": "\nvoid cplus_demangle_mangled_name(void)\n\n{\n  cplus_demangle_mangled_name();\n  return;\n}\n\n",
            "called": [
                "cplus_demangle_mangled_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104700",
            "calling": [
                "parse_stab_type"
            ],
            "imported": false,
            "current_name": "FUN_00104700"
        },
        "FUN_00104943": {
            "renaming": {
                "FUN_00104943": "print_arch_mach_info_00104943",
                "in_RAX": "inputString",
                "iVar1": "parsedInt",
                "iVar2": "comparisonResult",
                "lVar3": "lengthVar",
                "sVar4": "strLen",
                "pcVar5": "printableString",
                "uVar6": "archMachStr",
                "iVar7": "archMachIndex",
                "lVar8": "loopVar",
                "iVar9": "innerLoopVar",
                "unaff_R15D": "param7",
                "uVar10": "loopCounter",
                "uVar11": "archMachOffset",
                "param_7": "param7",
                "uStack000000000000000c": "padding",
                "param_11": "param11",
                "param_13": "param13"
            },
            "code": "\n\n\nvoid printArchMachInfo_00104943(void)\n\n{\n  int parsedInt;\n  int comparisonResult;\n  char *inputString;\n  long lengthVar;\n  size_t strLen;\n  char *printableString;\n  undefined8 archMachStr;\n  int archMachIndex;\n  long loopVar;\n  int innerLoopVar;\n  uint param7;\n  ulong loopCounter;\n  uint archMachOffset;\n  int param7;\n  uint padding;\n  undefined8 param11;\n  long param13;\n  \n  lengthVar = strtol(inputString,(char **)0x0,10);\n  parsedInt = (int)lengthVar;\n  innerLoopVar = param7;\n  padding = param7;\n  if (parsedInt == 0) {\n    parsedInt = 0x50;\n  }\n  do {\n    param7 = innerLoopVar;\n    if (param11._4_4_ <= param7) {\n      return;\n    }\n    loopVar = (long)param7;\n    archMachIndex = (parsedInt - padding) + -1;\n    lengthVar = loopVar;\n    do {\n      innerLoopVar = (int)lengthVar;\n      if (param11._4_4_ <= innerLoopVar) break;\n      strLen = strlen(*(char **)(param13 + lengthVar * 0x60));\n      lengthVar = lengthVar + 1;\n      archMachIndex = (archMachIndex - (int)strLen) + -1;\n    } while (-1 < archMachIndex);\n    printf(\"\\n%*s\",(ulong)(padding + 1),&DAT_0011b4a1);\n    for (lengthVar = loopVar * 0x60; ((ulong)(uint)(innerLoopVar - param7) + loopVar) * 0x60 - lengthVar != 0;\n        lengthVar = lengthVar + 0x60) {\n      printf(\"%s \",*(undefined8 *)(param13 + lengthVar));\n    }\n    archMachIndex = 2;\n    putc(10,_stdout);\n    do {\n      printableString = (char *)bfd_printable_arch_mach(archMachIndex,0);\n      comparisonResult = strcmp(printableString,\"UNKNOWN!\");\n      if (comparisonResult != 0) {\n        archMachStr = bfd_printable_arch_mach(archMachIndex,0);\n        printf(\"%*s \",(ulong)padding,archMachStr);\n        archMachOffset = archMachIndex - 2;\n        lengthVar = loopVar * 0x60;\n        comparisonResult = param7;\n        while (innerLoopVar != comparisonResult) {\n          printableString = *(char **)(param13 + lengthVar);\n          if (*(char *)((long)(char **)(param13 + lengthVar) + (ulong)archMachOffset + 8) == '\\0') {\n            strLen = strlen(printableString);\n            for (loopCounter = strLen & 0xffffffff; (int)loopCounter != 0; loopCounter = (ulong)((int)loopCounter - 1)) {\n              putc(0x2d,_stdout);\n            }\n          }\n          else {\n            fputs(printableString,_stdout);\n          }\n          comparisonResult = comparisonResult + 1;\n          if (innerLoopVar != comparisonResult) {\n            putc(0x20,_stdout);\n          }\n          lengthVar = lengthVar + 0x60;\n        }\n        putc(10,_stdout);\n      }\n      archMachIndex = archMachIndex + 1;\n    } while (archMachIndex != 0x57);\n  } while( true );\n}\n\n",
            "called": [
                "strlen",
                "fputs",
                "printf",
                "putc",
                "bfd_printable_arch_mach",
                "strtol",
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104943",
            "calling": [
                "display_info.isra.0"
            ],
            "imported": false,
            "current_name": "print_arch_mach_info_00104943"
        },
        "FUN_00104820": {
            "renaming": {},
            "code": "\nvoid bfd_openr_next_archived_file(void)\n\n{\n  bfd_openr_next_archived_file();\n  return;\n}\n\n",
            "called": [
                "bfd_openr_next_archived_file"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104820",
            "calling": [
                "copy_file",
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "FUN_00104820"
        },
        "FUN_00113e23": {
            "renaming": {
                "FUN_00113e23": "create_debug_type_00113e23",
                "param_1": "input1",
                "param_2": "input2",
                "lVar1": "debug_type",
                "puVar2": "allocated_memory"
            },
            "code": "\nlong create_debug_type_00113e23(undefined8 input1,undefined8 input2)\n\n{\n  long debug_type;\n  undefined8 *allocated_memory;\n  \n  debug_type = debug_make_type_constprop_0(1,0);\n  if (debug_type != 0) {\n    allocated_memory = (undefined8 *)xmalloc(0x10);\n    *allocated_memory = input1;\n    allocated_memory[1] = input2;\n    *(undefined8 **)(debug_type + 0x10) = allocated_memory;\n  }\n  return debug_type;\n}\n\n",
            "called": [
                "debug_make_type.constprop.0",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113e23",
            "calling": [
                "parse_coff_type.lto_priv.0",
                "stab_find_type",
                "stab_find_tagged_type"
            ],
            "imported": false,
            "current_name": "create_debug_type_00113e23"
        },
        "FUN_00108fb9": {
            "renaming": {
                "FUN_00108fb9": "print_bad_stab_00108fb9",
                "param_1": "stabValue",
                "__format": "errorMessage"
            },
            "code": "\n\n\nvoid printBadStab_00108fb9(undefined8 stabValue)\n\n{\n  char *errorMessage;\n  \n  errorMessage = (char *)dcgettext(0,\"Bad stab: %s\\n\",5);\n  fprintf(_stderr,errorMessage,stabValue);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108fb9",
            "calling": [
                "parse_stab",
                "parse_stab_type",
                "parse_stab_type_number"
            ],
            "imported": false,
            "current_name": "print_bad_stab_00108fb9"
        },
        "FUN_001280a0": {
            "renaming": {},
            "code": "\n\n\n\nint ferror(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ferror@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001280a0",
            "calling": [
                "ferror"
            ],
            "imported": false,
            "current_name": "FUN_001280a0"
        },
        "FUN_00108ea1": {
            "renaming": {
                "FUN_00108ea1": "parse_numeric_value_00108ea1",
                "param_1": "input_ptr",
                "param_2": "output_value",
                "iVar1": "accumulator",
                "pbVar2": "input_byte",
                "pbVar3": "next_byte",
                "uVar4": "result"
            },
            "code": "\nulong parse_numeric_value_00108ea1(byte **input_ptr,int *output_value)\n\n{\n  int accumulator;\n  byte *input_byte;\n  byte *next_byte;\n  ulong result;\n  \n  input_byte = *input_ptr;\n  result = 0;\n  if (((&_sch_istable)[(ulong)*input_byte * 2] & 4) != 0) {\n    next_byte = input_byte + 1;\n    accumulator = (char)*input_byte + -0x30;\n    *output_value = accumulator;\n    *input_ptr = next_byte;\n    if (((&_sch_istable)[(ulong)input_byte[1] * 2] & 4) != 0) {\n      do {\n        input_byte = next_byte;\n        accumulator = accumulator * 10 + -0x30 + (int)(char)*input_byte;\n        next_byte = input_byte + 1;\n      } while (((&_sch_istable)[(ulong)input_byte[1] * 2] & 4) != 0);\n      if (input_byte[1] == 0x5f) {\n        next_byte = input_byte + 2;\n        *input_ptr = next_byte;\n        *output_value = accumulator;\n      }\n    }\n    result = CONCAT71((int7)((ulong)next_byte >> 8),1);\n  }\n  return result & 0xffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108ea1",
            "calling": [
                "stab_demangle_args",
                "stab_demangle_type.lto_priv.0",
                "stab_demangle_template"
            ],
            "imported": false,
            "current_name": "parse_numeric_value_00108ea1"
        },
        "FUN_001280a8": {
            "renaming": {},
            "code": "\n\n\n\nvoid qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* qsort@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001280a8",
            "calling": [
                "qsort"
            ],
            "imported": false,
            "current_name": "FUN_001280a8"
        },
        "FUN_00108072": {
            "renaming": {
                "FUN_00108072": "set_section_addresses_00108072",
                "unaff_RBX": "sectionPointers",
                "unaff_RBP": "changeSectionAddress",
                "unaff_R12": "signatureData",
                "unaff_R14B": "hasPrivateData",
                "unaff_R15": "outputSection",
                "bVar1": "flag1",
                "uVar2": "currentSection",
                "cVar3": "result",
                "uVar4": "alignment",
                "lVar5": "errorMessage",
                "lVar6": "sectionA",
                "lVar7": "sectionB",
                "lVar8": "sectionC"
            },
            "code": "\nvoid setSectionAddresses_00108072(void)\n\n{\n  byte flag1;\n  undefined8 currentSection;\n  char result;\n  uint alignment;\n  long errorMessage;\n  long sectionA;\n  long sectionB;\n  undefined8 *sectionPointers;\n  long changeSectionAddress;\n  long signatureData;\n  long sectionC;\n  char hasPrivateData;\n  long outputSection;\n  \n  errorMessage = dcgettext(0,\"failed to set size\",5);\n  sectionC = sectionPointers[6];\n  sectionA = find_section_list(*sectionPointers,0,0x18);\n  if (sectionA == 0) {\n    *(byte *)(outputSection + 0x28) = *(byte *)(outputSection + 0x28) | 1;\n    currentSection = *sectionPointers;\n    sectionC = sectionC + change_section_address;\n    *(long *)(outputSection + 0x30) = sectionC;\n    *(long *)(outputSection + 0x38) = sectionC;\n    sectionC = sectionPointers[7];\n    sectionA = find_section_list(currentSection,0,0x60);\n    if (sectionA == 0) goto LAB_00115695;\nLAB_00115860:\n    sectionB = *(long *)(sectionA + 0x20);\n    if ((*(byte *)(sectionA + 0x14) & 0x40) != 0) {\n      sectionB = sectionB + sectionC;\n    }\n    *(long *)(outputSection + 0x38) = sectionB;\n    sectionC = find_section_list(*sectionPointers,0,0x200);\n    if (sectionC != 0) goto LAB_00115889;\nLAB_001156b8:\n    alignment = *(uint *)((long)sectionPointers + 0x7c);\n    if (alignment < 0x3f) goto LAB_001156c4;\n    errorMessage = dcgettext(0,\"failed to set alignment\",5);\n    *(undefined4 *)(outputSection + 0xb4) = *(undefined4 *)((long)sectionPointers + 0xb4);\n    *(byte *)(outputSection + 0x28) =\n         *(byte *)(outputSection + 0x28) & 0xcf | *(byte *)(sectionPointers + 5) & 0x30;\n    sectionPointers[0xc] = outputSection;\n    sectionPointers[0xb] = 0;\n    flag1 = *(byte *)((long)sectionPointers + 0x27);\n  }\n  else {\n    sectionB = *(long *)(sectionA + 0x18);\n    if ((*(byte *)(sectionA + 0x14) & 8) == 0) {\n      sectionB = sectionB + sectionC;\n    }\n    *(byte *)(outputSection + 0x28) = *(byte *)(outputSection + 0x28) | 1;\n    currentSection = *sectionPointers;\n    *(long *)(outputSection + 0x30) = sectionB;\n    *(long *)(outputSection + 0x38) = sectionB;\n    sectionC = sectionPointers[7];\n    sectionA = find_section_list(currentSection,0,0x60);\n    if (sectionA != 0) goto LAB_00115860;\nLAB_00115695:\n    currentSection = *sectionPointers;\n    *(long *)(outputSection + 0x38) = sectionC + change_section_address;\n    sectionC = find_section_list(currentSection,0,0x200);\n    if (sectionC == 0) goto LAB_001156b8;\nLAB_00115889:\n    alignment = *(uint *)(sectionC + 0x2c);\n    if (0x3e < alignment) {\n      set_alignment_00108179();\n      return;\n    }\nLAB_001156c4:\n    *(uint *)(outputSection + 0x7c) = alignment;\n    *(undefined4 *)(outputSection + 0xb4) = *(undefined4 *)((long)sectionPointers + 0xb4);\n    *(byte *)(outputSection + 0x28) =\n         *(byte *)(outputSection + 0x28) & 0xcf | *(byte *)(sectionPointers + 5) & 0x30;\n    sectionPointers[0xc] = outputSection;\n    sectionPointers[0xb] = 0;\n    flag1 = *(byte *)((long)sectionPointers + 0x27);\n  }\n  if ((flag1 & 2) != 0) {\n    sectionC = sectionPointers[0x1a];\n    sectionA = group_signature_isra_0(sectionC,sectionPointers[0x1c]);\n    if ((sectionA != 0) &&\n       (sectionB = *(long *)(signatureData + 8), *(uint *)(sectionA + 0x18) = *(uint *)(sectionA + 0x18) | 0x20,\n       *(int *)(sectionB + 8) == 5)) {\n      *(long *)(sectionC + 0xb0) = sectionA;\n      result = (**(code **)(*(long *)(changeSectionAddress + 8) + 0x158))();\n      if (result == '\\0') {\n        copy_private_data_0010808f();\n        return;\n      }\n      goto LAB_0011571e;\n    }\n  }\n  result = (**(code **)(*(long *)(changeSectionAddress + 8) + 0x158))();\n  if (result == '\\0') {\n    copy_private_data_0010808f();\n    return;\n  }\nLAB_0011571e:\n  if (hasPrivateData != '\\0') {\n    *(undefined4 *)(*(long *)(outputSection + 0xd0) + 4) = 8;\n  }\n  if (errorMessage != 0) {\n    status = 1;\n    bfd_nonfatal_message(0);\n  }\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "find_section_list",
                "FUN_00108179"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108072",
            "calling": [
                "setup_section"
            ],
            "imported": false,
            "current_name": "set_section_addresses_00108072"
        },
        "FUN_0010a2b9": {
            "renaming": {
                "FUN_0010a2b9": "process_stab_entry_0010a2b9",
                "param_1": "binary_address",
                "param_2": "flag",
                "param_3": "param_ptr1",
                "param_4": "param_ptr2",
                "cVar1": "char_value",
                "__s": "string_ptr",
                "sVar2": "string_length",
                "__s_00": "new_string_ptr",
                "lVar3": "counter",
                "auVar4": "result"
            },
            "code": "\nundefined  [16] process_stab_entry_0010a2b9(long binary_address,char flag,undefined8 param_ptr1,undefined8 param_ptr2)\n\n{\n  char char_value;\n  char *string_ptr;\n  size_t string_length;\n  char *new_string_ptr;\n  long counter;\n  undefined result [16];\n  \n  char_value = *(char *)(*(long *)(binary_address + 0x60) + 0x1c);\n  string_ptr = (char *)stab_pop_type();\n  string_length = strlen(string_ptr);\n  new_string_ptr = (char *)xmalloc(string_length + 0x1e);\n  if (flag == '\\0') {\n    *new_string_ptr = '\\0';\n    counter = 0;\n    flag = char_value;\n  }\n  else {\n    counter = *(long *)(binary_address + 0x68);\n    *(long *)(binary_address + 0x68) = counter + 1;\n    sprintf(new_string_ptr,\"%ld=@S;\",counter);\n  }\n  string_length = strlen(new_string_ptr);\n  sprintf(new_string_ptr + string_length,\"S%s\",string_ptr);\n  free(string_ptr);\n  result._0_4_ = stab_push_string(binary_address,new_string_ptr,counter,flag,0);\n  result._4_4_ = 0;\n  if ((char)result._0_4_ != '\\0') {\n    free(new_string_ptr);\n  }\n  result._8_8_ = param_ptr2;\n  return result;\n}\n\n",
            "called": [
                "strlen",
                "stab_push_string",
                "sprintf",
                "free",
                "xmalloc",
                "stab_pop_type"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a2b9",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "process_stab_entry_0010a2b9"
        },
        "FUN_001040e0": {
            "renaming": {},
            "code": "\n\n\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = strncmp(__s1,__s2,__n);\n  return iVar1;\n}\n\n",
            "called": [
                "strncmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001040e0",
            "calling": [
                "stab_demangle_v3_arg",
                "parse_stab_type",
                "startswith.lto_priv.0.lto_priv.0"
            ],
            "imported": false,
            "current_name": "FUN_001040e0"
        },
        "FUN_00116ad0": {
            "renaming": {
                "FUN_00116ad0": "FUNC_00116ad0"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00116ae3) */\n/* WARNING: Removing unreachable block (ram,0x00116aef) */\n\nvoid FUNC_00116ad0(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_deregisterTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00116ad0",
            "calling": [
                "__do_global_dtors_aux"
            ],
            "imported": false,
            "current_name": "FUNC_00116ad0"
        },
        "FUN_001283f0": {
            "renaming": {},
            "code": "\n\n\n\nint access(char *__name,int __type)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* access@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001283f0",
            "calling": [
                "access"
            ],
            "imported": false,
            "current_name": "FUN_001283f0"
        },
        "FUN_0010ec73": {
            "renaming": {
                "FUN_0010ec73": "update_param_values_0010ec73",
                "param_1": "paramArray",
                "param_2": "newValue",
                "param_3": "unusedParam1",
                "param_4": "unusedParam2",
                "param_5": "unusedParam3",
                "param_6": "unusedParam4",
                "iVar1": "counter",
                "cVar2": "error"
            },
            "code": "\nundefined updateParamValues_0010ec73(long *paramArray,long newValue,undefined8 unusedParam1,undefined8 unusedParam2,\n                      undefined8 unusedParam3,undefined8 unusedParam4)\n\n{\n  int counter;\n  char error;\n  \n  if (paramArray[0x3c] != -1) {\n    (**(code **)(*(long *)(*paramArray + 8) + 0x50))(newValue,paramArray[1] + 8 + paramArray[0x3c]);\n    paramArray[0x3c] = -1;\n  }\n  if (paramArray[0x3d] != -1) {\n    (**(code **)(*(long *)(*paramArray + 8) + 0x50))(newValue,paramArray[1] + 8 + paramArray[0x3d]);\n    paramArray[0x3d] = -1;\n  }\n  counter = *(int *)(paramArray + 0x3f);\n  *(int *)(paramArray + 0x3f) = counter + 1;\n  if (counter == 0) {\n    paramArray[0x40] = newValue;\n  }\n  else {\n    if ((paramArray[0x41] != -1) &&\n       (error = stab_write_symbol_lto_priv_0(paramArray,0xc0,0,paramArray[0x41],0,unusedParam4,unusedParam2),\n       error == '\\0')) {\n      return 0;\n    }\n    paramArray[0x41] = newValue - paramArray[0x40];\n  }\n  return 1;\n}\n\n",
            "called": [
                "stab_write_symbol.lto_priv.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010ec73",
            "calling": [
                "debug_write_block.constprop.0"
            ],
            "imported": false,
            "current_name": "update_param_values_0010ec73"
        },
        "FUN_00114e00": {
            "renaming": {
                "FUN_00114e00": "determine_endianness_00114e00",
                "param_1": "endianness"
            },
            "code": "\nvoid determineEndianness_00114e00(int endianness)\n\n{\n  if (endianness == 0) {\n    dcgettext(0,\"big endian\",5);\n    return;\n  }\n  if (endianness == 1) {\n    dcgettext(0,\"little endian\",5);\n    return;\n  }\n  dcgettext(0,\"endianness unknown\",5);\n  return;\n}\n\n",
            "called": [
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114e00",
            "calling": [
                "do_display_target"
            ],
            "imported": false,
            "current_name": "determine_endianness_00114e00"
        },
        "FUN_00104830": {
            "renaming": {},
            "code": "\nvoid bfd_hash_table_init(void)\n\n{\n  bfd_hash_table_init();\n  return;\n}\n\n",
            "called": [
                "bfd_hash_table_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104830",
            "calling": [
                "write_stabs_in_sections_debugging_info.constprop.0"
            ],
            "imported": false,
            "current_name": "FUN_00104830"
        },
        "FUN_00104710": {
            "renaming": {},
            "code": "\nvoid bfd_scan_arch(void)\n\n{\n  bfd_scan_arch();\n  return;\n}\n\n",
            "called": [
                "bfd_scan_arch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104710",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00104710"
        },
        "FUN_00115970": {
            "renaming": {
                "FUN_00115970": "copy_and_unlink_file_00115970",
                "param_1": "sourceFilePath",
                "param_2": "destinationFilePath",
                "param_3": "bufferSize",
                "param_4": "fileSize",
                "param_5": "setTimes",
                "param_6": "errorCode",
                "uVar1": "copyResult",
                "piVar2": "errnoLocation",
                "pcVar3": "errorMessage",
                "uVar4": "errorString",
                "uVar5": "copySize",
                "auVar6": "returnValue"
            },
            "code": "\nundefined  [16]\ncopyAndUnlinkFile_00115970(char *sourceFilePath,char *destinationFilePath,undefined4 bufferSize,undefined8 fileSize,char setTimes,\n            undefined8 errorCode)\n\n{\n  uint copyResult;\n  int *errnoLocation;\n  char *errorMessage;\n  undefined8 errorString;\n  ulong copySize;\n  undefined returnValue [16];\n  \n  if (destinationFilePath == sourceFilePath) {\n    copySize = 0;\n  }\n  else {\n    copyResult = simple_copy(bufferSize,destinationFilePath,fileSize);\n    copySize = (ulong)copyResult;\n    if (copyResult != 0) {\n      errnoLocation = __errno_location();\n      errorMessage = strerror(*errnoLocation);\n      errorString = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n      non_fatal(errorString,destinationFilePath,errorMessage);\n    }\n    unlink(sourceFilePath);\n  }\n  if (setTimes != '\\0') {\n    set_times(destinationFilePath,fileSize);\n  }\n  returnValue._8_8_ = errorCode;\n  returnValue._0_8_ = copySize;\n  return returnValue;\n}\n\n",
            "called": [
                "simple_copy",
                "smart_rename.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115970",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "copy_and_unlink_file_00115970"
        },
        "FUN_001283f8": {
            "renaming": {},
            "code": "\n\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fopen@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001283f8",
            "calling": [
                "fopen"
            ],
            "imported": false,
            "current_name": "FUN_001283f8"
        },
        "FUN_001282d8": {
            "renaming": {},
            "code": "\n\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memcpy@GLIBC_2.14 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001282d8",
            "calling": [
                "memcpy"
            ],
            "imported": false,
            "current_name": "FUN_001282d8"
        },
        "FUN_0010adf2": {
            "renaming": {
                "FUN_0010adf2": "initialize_class_method_variables_0010adf2",
                "stab_class_method_var": "stab_class_method_variables"
            },
            "code": "\nvoid initialize_class_method_variables_0010adf2(void)\n\n{\n  stab_class_method_variables();\n  return;\n}\n\n",
            "called": [
                "stab_class_method_var"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010adf2",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "initialize_class_method_variables_0010adf2"
        },
        "FUN_00104840": {
            "renaming": {},
            "code": "\nvoid bfd_get_reloc_upper_bound(void)\n\n{\n  bfd_get_reloc_upper_bound();\n  return;\n}\n\n",
            "called": [
                "bfd_get_reloc_upper_bound"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104840",
            "calling": [
                "merge_gnu_build_notes",
                "copy_relocations_in_section",
                "mark_symbols_used_in_relocations"
            ],
            "imported": false,
            "current_name": "FUN_00104840"
        },
        "FUN_0010d7d4": {
            "renaming": {
                "FUN_0010d7d4": "demangle_and_remember_type_0010d7d4",
                "param_1": "input_format",
                "param_2": "type_string",
                "param_3": "type_array",
                "param_4": "type_count",
                "param_5": "type_capacity",
                "uVar1": "format_copy",
                "cVar2": "is_demangled",
                "uVar3": "result",
                "lVar4": "array_ptr",
                "plVar5": "array_buffer",
                "uVar6": "new_type_count",
                "local_40": "local_array"
            },
            "code": "\nundefined4\ndemangle_and_remember_type_0010d7d4(undefined8 input_format,undefined8 *type_string,long *type_array,uint *type_count,uint *type_capacity)\n\n{\n  undefined8 format_copy;\n  char is_demangled;\n  undefined4 result;\n  long array_ptr;\n  long *array_buffer;\n  uint new_type_count;\n  long local_array [2];\n  \n  format_copy = *type_string;\n  array_buffer = local_array;\n  if (type_array == (long *)0x0) {\n    array_buffer = (long *)0x0;\n  }\n  is_demangled = stab_demangle_type_lto_priv_0(input_format,type_string,array_buffer);\n  if ((is_demangled != '\\0') &&\n     (result = stab_demangle_remember_type(input_format,format_copy,(int)*type_string - (int)format_copy),\n     (char)result != '\\0')) {\n    if (type_array == (long *)0x0) {\n      return result;\n    }\n    if (local_array[0] != 0) {\n      if (*type_capacity <= *type_count + 1) {\n        new_type_count = *type_capacity + 10;\n        array_ptr = *type_array;\n        *type_capacity = new_type_count;\n        array_ptr = xrealloc(array_ptr,(ulong)new_type_count << 3);\n        *type_array = array_ptr;\n      }\n      new_type_count = *type_count;\n      *(long *)(*type_array + (ulong)new_type_count * 8) = local_array[0];\n      *type_count = new_type_count + 1;\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "stab_demangle_remember_type",
                "xrealloc",
                "stab_demangle_type.lto_priv.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010d7d4",
            "calling": [
                "stab_demangle_args"
            ],
            "imported": false,
            "current_name": "demangle_and_remember_type_0010d7d4"
        },
        "FUN_00113f50": {
            "renaming": {
                "FUN_00113f50": "validate_file_00113f50",
                "param_1": "file_path",
                "iVar1": "status",
                "piVar2": "errno_ptr",
                "uVar3": "error_msg",
                "pcVar4": "str_error",
                "sStack_a8": "file_stats"
            },
            "code": "\nlong validate_file_00113f50(char *file_path)\n\n{\n  int status;\n  int *errno_ptr;\n  undefined8 error_msg;\n  char *str_error;\n  stat file_stats;\n  \n  if (file_path != (char *)0x0) {\n    status = stat(file_path,&file_stats);\n    if (status < 0) {\n      errno_ptr = __errno_location();\n      if (*errno_ptr == 2) {\n        error_msg = dcgettext(0,\"\\'%s\\': No such file\",5);\n        non_fatal(error_msg,file_path);\n      }\n      else {\n        str_error = strerror(*errno_ptr);\n        error_msg = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n        non_fatal(error_msg,file_path,str_error);\n      }\n    }\n    else if ((file_stats.st_mode & 0xf000) == 0x4000) {\n      error_msg = dcgettext(0,\"Warning: \\'%s\\' is a directory\",5);\n      non_fatal(error_msg,file_path);\n    }\n    else if ((file_stats.st_mode & 0xf000) == 0x8000) {\n      if (-1 < file_stats.st_size) {\n        return file_stats.st_size;\n      }\n      error_msg = dcgettext(0,\"Warning: \\'%s\\' has negative size, probably it is too large\",5);\n      non_fatal(error_msg,file_path);\n    }\n    else {\n      error_msg = dcgettext(0,\"Warning: \\'%s\\' is not an ordinary file\",5);\n      non_fatal(error_msg,file_path);\n    }\n  }\n  return -1;\n}\n\n",
            "called": [
                "stat",
                "dcgettext",
                "non_fatal",
                "get_file_size.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113f50",
            "calling": [
                "main",
                "copy_file",
                "add_specific_symbols"
            ],
            "imported": false,
            "current_name": "validate_file_00113f50"
        },
        "FUN_001087fd": {
            "renaming": {
                "FUN_001087fd": "initialize_application_001087fd"
            },
            "code": "\nundefined8 initializeApplication_001087fd(void)\n\n{\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001087fd",
            "calling": [
                "sort_gnu_build_notes"
            ],
            "imported": false,
            "current_name": "initialize_application_001087fd"
        },
        "FUN_0011256b": {
            "renaming": {
                "FUN_0011256b": "print_matching_formats_0011256b",
                "param_1": "formatList",
                "uVar1": "programName",
                "__format": "formatString",
                "plVar2": "currentFormat"
            },
            "code": "\n\n\nvoid printMatchingFormats_0011256b(long *formatList)\n\n{\n  undefined8 programName;\n  char *formatString;\n  long *currentFormat;\n  \n  fflush(_stdout);\n  programName = program_name;\n  formatString = (char *)dcgettext(0,\"%s: Matching formats:\",5);\n  fprintf(_stderr,formatString,programName);\n  for (currentFormat = formatList; *currentFormat != 0; currentFormat = currentFormat + 1) {\n    fprintf(_stderr,\" %s\");\n  }\n  free(formatList);\n  fputc(10,_stderr);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fputc",
                "dcgettext",
                "free",
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011256b",
            "calling": [
                "copy_file"
            ],
            "imported": false,
            "current_name": "print_matching_formats_0011256b"
        },
        "FUN_0011378f": {
            "renaming": {
                "FUN_0011378f": "decompiled_function_0011378f",
                "param_1": "input_ptr_1",
                "param_2": "input_ptr_2",
                "param_3": "output_ptr_1",
                "param_4": "output_ptr_2",
                "param_5": "output_ptr_3",
                "param_6": "output_ptr_4",
                "auVar1": "temp_array",
                "cVar2": "status",
                "uVar3": "return_value",
                "uVar4": "error_message",
                "puVar5": "temp_ptr",
                "sVar6": "string_length",
                "lVar7": "loop_counter",
                "puVar8": "inner_ptr",
                "puVar9": "array_ptr",
                "__dest": "destination_ptr",
                "puVar10": "function_ptr",
                "plVar11": "source_ptr",
                "bVar12": "flag",
                "local_258": "local_ptr_1",
                "local_250": "local_var_1",
                "local_248": "local_var_2",
                "uStack_244": "local_var_3",
                "uStack_240": "local_var_4",
                "uStack_23c": "local_var_5",
                "local_238": "local_array_1",
                "local_228": "local_var_6",
                "local_220": "local_array_2",
                "local_1f8": "local_var_7",
                "local_1f0": "local_var_8",
                "local_1e8": "local_array_3",
                "local_a0": "local_array_4",
                "local_78": "local_array_5",
                "uStack_70": "local_var_9",
                "local_68": "local_var_10",
                "local_60": "local_var_11",
                "local_58": "local_var_12",
                "uStack_54": "local_var_13",
                "uStack_50": "local_var_14",
                "uStack_4c": "local_var_15"
            },
            "code": "\nundefined4\ndecompiled_function_0011378f(undefined8 *input_ptr_1,undefined8 *input_ptr_2,long *output_ptr_1,undefined8 *output_ptr_2,\n            undefined8 *output_ptr_3,undefined8 *output_ptr_4)\n\n{\n  undefined temp_array [16];\n  char status;\n  undefined4 return_value;\n  undefined8 error_message;\n  undefined *temp_ptr;\n  size_t string_length;\n  long loop_counter;\n  undefined8 *inner_ptr;\n  undefined4 *array_ptr;\n  char *destination_ptr;\n  undefined8 *function_ptr;\n  long *source_ptr;\n  byte flag;\n  undefined8 *local_ptr_1;\n  long local_var_1;\n  undefined4 local_var_2;\n  undefined4 local_var_3;\n  undefined4 local_var_4;\n  undefined4 local_var_5;\n  undefined local_array_1 [16];\n  undefined8 local_var_6;\n  undefined local_array_2 [40];\n  undefined8 local_var_7;\n  undefined8 local_var_8;\n  undefined4 local_array_3 [82];\n  undefined local_array_4 [40];\n  undefined local_array_5 [8];\n  undefined8 local_var_9;\n  undefined8 local_var_10;\n  undefined4 local_var_11;\n  undefined4 local_var_12;\n  undefined4 local_var_13;\n  undefined4 local_var_14;\n  undefined4 local_var_15;\n  \n  flag = 0;\n  local_var_2 = 0;\n  local_var_3 = 0;\n  local_var_4 = 500;\n  local_var_5 = 0;\n  local_ptr_1 = input_ptr_1;\n  local_var_1 = xmalloc(500);\n  local_var_6 = 1;\n  local_array_1 = ZEXT816(0);\n  status = bfd_hash_table_init(local_array_2,string_hash_newfunc_lto_priv_0,0x30);\n  if ((status == '\\0') ||\n     (status = bfd_hash_table_init(local_array_4,string_hash_newfunc_lto_priv_0,0x30), status == '\\0')) {\n    return_value = bfd_get_error();\n    error_message = bfd_errmsg(return_value);\n    non_fatal(\"bfd_hash_table_init_failed: %s\",error_message);\n  }\n  else {\n    local_var_7 = 0;\n    unique0x100000e9 = 0xffffffff;\n    local_array_5 = (undefined  [8])0xffffffffffffffff;\n    unique0x100000ed = 0xffffffff;\n    array_ptr = local_array_3;\n    for (loop_counter = 0x52; loop_counter != 0; loop_counter = loop_counter + -1) {\n      *array_ptr = 0;\n      array_ptr = array_ptr + (ulong)flag * -2 + 1;\n    }\n    local_var_10 = 0;\n    local_var_11 = 0;\n    local_var_8 = 1;\n    local_var_12 = 0;\n    local_var_13 = 0;\n    local_var_14 = 0xffffffff;\n    local_var_15 = 0xffffffff;\n    status = stab_write_symbol_lto_priv_0(&local_ptr_1,0,0,0,0);\n    temp_array = _local_array_5;\n    if (status != '\\0') {\n      local_array_5._4_4_ = local_var_3;\n      local_array_5._0_4_ = local_var_2;\n      local_var_9 = temp_array._8_8_;\n      status = stab_write_symbol_lto_priv_0(&local_ptr_1,100,0,0,*input_ptr_1);\n      if (status != '\\0') {\n        *(int *)(input_ptr_2 + 6) = *(int *)(input_ptr_2 + 6) + 1;\n        input_ptr_2[10] = 0;\n        function_ptr = (undefined8 *)*input_ptr_2;\n        *(undefined4 *)(input_ptr_2 + 7) = *(undefined4 *)((long)input_ptr_2 + 0x34);\n        for (; function_ptr != (undefined8 *)0x0; function_ptr = (undefined8 *)*function_ptr) {\n          input_ptr_2[8] = function_ptr[2];\n          *(undefined4 *)(input_ptr_2 + 9) = 0;\n          status = stab_start_compilation_unit_lto_priv_0(&local_ptr_1,*(undefined8 *)(function_ptr[1] + 8))\n          ;\n          if (status == '\\0') {\n            return 0;\n          }\n          source_ptr = (long *)function_ptr[1];\n          if (source_ptr != (long *)0x0) {\n            while( true ) {\n              if ((undefined8 *)source_ptr[2] != (undefined8 *)0x0) {\n                for (inner_ptr = *(undefined8 **)(undefined8 *)source_ptr[2]; inner_ptr != (undefined8 *)0x0;\n                    inner_ptr = (undefined8 *)*inner_ptr) {\n                  status = debug_write_name_constprop_0(input_ptr_2,&local_ptr_1);\n                  if (status == '\\0') {\n                    return 0;\n                  }\n                }\n              }\n              source_ptr = (long *)*source_ptr;\n              if (source_ptr == (long *)0x0) break;\n              status = stab_start_source_lto_priv_0(&local_ptr_1,source_ptr[1]);\n              if (status == '\\0') {\n                return 0;\n              }\n            }\n          }\n          status = debug_write_linenos_constprop_0(input_ptr_2,&local_ptr_1,0xffffffffffffffff);\n          if (status == '\\0') {\n            return 0;\n          }\n        }\n        if ((CONCAT44(local_var_15,local_var_14) == -1) &&\n           (return_value = stab_write_symbol_lto_priv_0(&local_ptr_1,100,0,local_var_10,0), (char)return_value != '\\0'))\n        {\n          (**(code **)(input_ptr_1[1] + 0x50))(local_var_6,local_var_1 + 8);\n          *output_ptr_1 = local_var_1;\n          *output_ptr_2 = CONCAT44(local_var_3,local_var_2);\n          *output_ptr_4 = local_var_6;\n          temp_ptr = (undefined *)xmalloc();\n          *temp_ptr = 0;\n          destination_ptr = temp_ptr + 1;\n          *output_ptr_3 = temp_ptr;\n          for (loop_counter = local_array_1._0_8_; loop_counter != 0; loop_counter = *(long *)(loop_counter + 0x18)) {\n            strcpy(destination_ptr,*(char **)(loop_counter + 8));\n            string_length = strlen(destination_ptr);\n            destination_ptr = destination_ptr + string_length + 1;\n          }\n          return return_value;\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "debug_write_linenos.constprop.0",
                "bfd_errmsg",
                "non_fatal",
                "stab_start_compilation_unit.lto_priv.0",
                "debug_write_name.constprop.0",
                "bfd_get_error",
                "strcpy",
                "strlen",
                "stab_write_symbol.lto_priv.0",
                "string_hash_newfunc.lto_priv.0",
                "bfd_hash_table_init",
                "stab_start_source.lto_priv.0",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011378f",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "decompiled_function_0011378f"
        },
        "FUN_001281e0": {
            "renaming": {},
            "code": "\n\n\n\nsize_t strnlen(char *__string,size_t __maxlen)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strnlen@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001281e0",
            "calling": [
                "strnlen"
            ],
            "imported": false,
            "current_name": "FUN_001281e0"
        },
        "FUN_00104966": {
            "renaming": {
                "FUN_00104966": "handle_file_error_00104966",
                "piVar1": "errnoValue",
                "uVar2": "errorString"
            },
            "code": "\nundefined8 handleFileError_00104966(void)\n\n{\n  int *errnoValue;\n  undefined8 errorString;\n  \n  errnoValue = __errno_location();\n  if (*errnoValue == 2) {\n    errorString = dcgettext(0,\"\\'%s\\': No such file\",5);\n    non_fatal(errorString);\n  }\n  else {\n    strerror(*errnoValue);\n    errorString = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n    non_fatal(errorString);\n  }\n  return 0xffffffffffffffff;\n}\n\n",
            "called": [
                "strerror",
                "dcgettext",
                "non_fatal",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104966",
            "calling": [
                "get_file_size"
            ],
            "imported": false,
            "current_name": "handle_file_error_00104966"
        },
        "FUN_001280c0": {
            "renaming": {},
            "code": "\n\n\n\ndouble strtod(char *__nptr,char **__endptr)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strtod@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001280c0",
            "calling": [
                "strtod"
            ],
            "imported": false,
            "current_name": "FUN_001280c0"
        },
        "FUN_001040f0": {
            "renaming": {},
            "code": "\nvoid bfd_convert_section_setup(void)\n\n{\n  bfd_convert_section_setup();\n  return;\n}\n\n",
            "called": [
                "bfd_convert_section_setup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001040f0",
            "calling": [
                "setup_section"
            ],
            "imported": false,
            "current_name": "FUN_001040f0"
        },
        "FUN_00104720": {
            "renaming": {},
            "code": "\nvoid htab_create_alloc(void)\n\n{\n  htab_create_alloc();\n  return;\n}\n\n",
            "called": [
                "htab_create_alloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104720",
            "calling": [
                "main",
                "create_symbol_htab"
            ],
            "imported": false,
            "current_name": "FUN_00104720"
        },
        "FUN_0010a0a0": {
            "renaming": {
                "FUN_0010a0a0": "modify_stab_entries_0010a0a0",
                "param_1": "baseAddress",
                "stab_modify_type": "modifyStabType"
            },
            "code": "\nvoid modifyStabEntries_0010a0a0(long baseAddress)\n\n{\n  modifyStabType(baseAddress,0x26,4,baseAddress + 0x198,baseAddress + 0x1a0);\n  return;\n}\n\n",
            "called": [
                "stab_modify_type"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a0a0",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "modify_stab_entries_0010a0a0"
        },
        "FUN_00104600": {
            "renaming": {},
            "code": "\nvoid bfd_fill_in_gnu_debuglink_section(void)\n\n{\n  bfd_fill_in_gnu_debuglink_section();\n  return;\n}\n\n",
            "called": [
                "bfd_fill_in_gnu_debuglink_section"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104600",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "FUN_00104600"
        },
        "FUN_00119ed0": {
            "renaming": {
                "FUN_00119ed0": "report_data_00119ed0",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "param_5": "input_5",
                "param_6": "input_6",
                "param_7": "input_7",
                "param_8": "input_8",
                "param_9": "address",
                "param_10": "data_1",
                "param_11": "data_2",
                "param_12": "data_3",
                "param_13": "data_4",
                "param_14": "data_5",
                "in_AL": "condition",
                "local_d8": "size",
                "local_d4": "length",
                "local_d0": "buffer",
                "local_c8": "localBuffer",
                "local_b8": "localArray",
                "local_b0": "data_6",
                "local_a8": "data_7",
                "local_a0": "data_8",
                "local_98": "data_9",
                "local_90": "data_10",
                "local_88": "copy_1",
                "local_78": "copy_2",
                "local_68": "copy_3",
                "local_58": "copy_4",
                "local_48": "copy_5",
                "local_38": "copy_6",
                "local_28": "copy_7",
                "local_18": "copy_8"
            },
            "code": "\nvoid reportData_00119ed0(undefined4 input_1,undefined4 input_2,undefined4 input_3,undefined4 input_4,\n                 undefined4 input_5,undefined4 input_6,undefined4 input_7,undefined4 input_8,\n                 undefined8 address,undefined8 data_1,undefined8 data_2,undefined8 data_3,\n                 undefined8 data_4,undefined8 data_5)\n\n{\n  char condition;\n  undefined4 size;\n  undefined4 length;\n  undefined *buffer;\n  undefined *localBuffer;\n  undefined localArray [8];\n  undefined8 data_6;\n  undefined8 data_7;\n  undefined8 data_8;\n  undefined8 data_9;\n  undefined8 data_10;\n  undefined4 copy_1;\n  undefined4 copy_2;\n  undefined4 copy_3;\n  undefined4 copy_4;\n  undefined4 copy_5;\n  undefined4 copy_6;\n  undefined4 copy_7;\n  undefined4 copy_8;\n  \n  if (condition != '\\0') {\n    copy_1 = input_1;\n    copy_2 = input_2;\n    copy_3 = input_3;\n    copy_4 = input_4;\n    copy_5 = input_5;\n    copy_6 = input_6;\n    copy_7 = input_7;\n    copy_8 = input_8;\n  }\n  buffer = &stack0x00000008;\n  size = 8;\n  localBuffer = localArray;\n  length = 0x30;\n  data_6 = data_1;\n  data_7 = data_2;\n  data_8 = data_3;\n  data_9 = data_4;\n  data_10 = data_5;\n  report(address,&size);\n  return;\n}\n\n",
            "called": [
                "report"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00119ed0",
            "calling": [
                "FUN_00105828",
                "merge_gnu_build_notes",
                "set_times.cold",
                "FUN_0010554f",
                "parse_coff_struct_type",
                "FUN_001152b6",
                "stab_struct_field.lto_priv.0",
                "stab_int_type.lto_priv.0",
                "smart_rename.cold",
                "stab_typdef.lto_priv.0",
                "FUN_00104cc1",
                "copy_object",
                "main",
                "parse_flags.cold",
                "parse_coff_type.lto_priv.0",
                "stab_write_symbol.lto_priv.0",
                "FUN_001086af",
                "check_new_section_flags.cold",
                "get_file_size.cold",
                "get_file_size",
                "FUN_00107880",
                "copy_file",
                "FUN_00104ea2",
                "write_stabs_in_sections_debugging_info.constprop.0"
            ],
            "imported": false,
            "current_name": "report_data_00119ed0"
        },
        "FUN_00112c1f": {
            "renaming": {
                "FUN_00112c1f": "FUNC_00112c1f"
            },
            "code": "\n\n\nundefined8 FUNC_00112c1f(ulong param_1,undefined8 param_2,int *param_3,long param_4)\n\n{\n  long *plVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  undefined8 *puVar4;\n  char cVar5;\n  int *piVar6;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  int iVar9;\n  undefined4 uVar10;\n  undefined8 uVar11;\n  ulong uVar12;\n  uint uVar13;\n  bool bVar14;\n  uint local_3c;\n  \n  uVar12 = param_1;\nLAB_00112c39:\n  if (param_3 != (int *)0x0) {\n    iVar9 = *param_3;\n    if (iVar9 - 0x16U < 2) {\n      do {\n        plVar1 = *(long **)(param_3 + 4);\n        uVar13 = *(uint *)(param_1 + 0x30);\n        uVar12 = (ulong)uVar13;\n        lVar2 = *plVar1;\n        if (*(uint *)(lVar2 + 0x10) == uVar13) {\n          if (iVar9 == 0x16) {\n            uVar7 = stab_typedef_type_lto_priv_0(param_2,*(undefined8 *)(lVar2 + 8));\n            return uVar7;\n          }\nLAB_00112c94:\n          piVar6 = (int *)debug_get_real_type_isra_0(param_3,0);\n          if (piVar6 == (int *)0x0) goto LAB_00112dd6;\n          if ((*piVar6 - 7U < 4) && (*(long *)(piVar6 + 4) != 0)) {\n            if ((*(uint *)(*(long *)(piVar6 + 4) + 0xc) <= *(uint *)(param_1 + 0x38)) &&\n               (cVar5 = debug_set_class_id_lto_priv_0\n                                  (param_1,*(undefined8 *)(**(long **)(param_3 + 4) + 8),piVar6),\n               cVar5 == '\\0')) {\n              return 0;\n            }\n            uVar13 = *(uint *)(*(long *)(piVar6 + 4) + 0xc);\n          }\n          else {\n            uVar13 = 0;\n          }\n          iVar9 = *piVar6;\n          uVar7 = *(undefined8 *)(**(long **)(param_3 + 4) + 8);\n          goto LAB_00112ed2;\n        }\n        if (iVar9 == 0x17) {\n          if (lVar2 != param_4) goto LAB_00112c94;\n          *(uint *)(param_4 + 0x10) = uVar13;\n          param_4 = *plVar1;\n          param_3 = (int *)plVar1[1];\n          goto LAB_00112c39;\n        }\n        if (param_4 != 0) {\n          *(uint *)(param_4 + 0x10) = uVar13;\n        }\n        param_3 = (int *)plVar1[1];\n        if (param_3 == (int *)0x0) goto LAB_00112dd6;\n        iVar9 = *param_3;\n        param_4 = 0;\n      } while (iVar9 - 0x16U < 2);\nLAB_00112d74:\n      uVar7 = 0;\n    }\n    else {\n      if (param_4 == 0) goto LAB_00112d74;\n      *(undefined4 *)(param_4 + 0x10) = *(undefined4 *)(param_1 + 0x30);\n      if (*(int *)(param_4 + 0x14) != 1) {\n                    \n        __assert_fail(\"name->kind == DEBUG_OBJECT_TAG\",\"../../binutils/debug.c\",0x9b3,\n                      \"debug_write_type\");\n      }\n      uVar7 = *(undefined8 *)(param_4 + 8);\n    }\n    switch(iVar9) {\n    case 0:\n      uVar7 = dcgettext(0,\"debug_write_type: illegal type encountered\",5);\n      fprintf(_stderr,\"%s\\n\",uVar7);\n      return 0;\n    case 1:\n      goto switchD_00112d8e_caseD_1;\n    case 2:\n      uVar7 = stab_void_type_lto_priv_0(param_2);\n      return uVar7;\n    case 3:\n      uVar7 = stab_int_type_lto_priv_0(param_2,param_3[1],*(undefined *)(param_3 + 4));\n      return uVar7;\n    case 4:\n      uVar7 = stab_float_type_lto_priv_0(param_2,param_3[1]);\n      return uVar7;\n    case 5:\n      uVar7 = stab_complex_type_lto_priv_0(param_2,param_3[1]);\n      return uVar7;\n    case 6:\n      uVar7 = stab_bool_type_lto_priv_0(param_2,param_3[1]);\n      return uVar7;\n    case 7:\n    case 8:\n      if (*(long *)(param_3 + 4) != 0) {\n        if ((*(uint *)(*(long *)(param_3 + 4) + 0xc) <= *(uint *)(param_1 + 0x38)) &&\n           (cVar5 = debug_set_class_id_lto_priv_0(param_1,uVar7,param_3), cVar5 == '\\0')) {\n          return 0;\n        }\n        lVar2 = *(long *)(param_3 + 4);\n        if (*(int *)(param_1 + 0x30) == *(int *)(lVar2 + 8)) {\n          uVar13 = *(uint *)(lVar2 + 0xc);\n          if (uVar13 <= *(uint *)(param_1 + 0x38)) {\n                    \n            __assert_fail(\"type->u.kclass->id > info->base_id\",\"../../binutils/debug.c\",0x9db,\n                          \"debug_write_type\");\n          }\n          iVar9 = *param_3;\nLAB_00112ed2:\n          uVar7 = stab_tag_type_lto_priv_0(param_2,uVar7,uVar13,iVar9);\n          return uVar7;\n        }\n        *(int *)(lVar2 + 8) = *(int *)(param_1 + 0x30);\n      }\n      uVar10 = 0;\n      if (*(long *)(param_3 + 4) != 0) {\n        uVar10 = *(undefined4 *)(*(long *)(param_3 + 4) + 0xc);\n      }\n      cVar5 = stab_start_struct_type_lto_priv_0(param_2,uVar7,uVar10,*param_3 == 7,param_3[1]);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      if ((*(long **)(param_3 + 4) != (long *)0x0) && (uVar12 = 0, **(long **)(param_3 + 4) != 0)) {\n        while( true ) {\n          puVar4 = *(undefined8 **)(**(long **)(param_3 + 4) + uVar12 * 8);\n          if (puVar4 == (undefined8 *)0x0) break;\n          cVar5 = FUNC_00112c1f(param_1,param_2,puVar4[1],0);\n          if (cVar5 == '\\0') {\n            return 0;\n          }\n          cVar5 = stab_struct_field_lto_priv_0\n                            (param_2,*puVar4,*(undefined4 *)(puVar4 + 3),\n                             *(undefined4 *)((long)puVar4 + 0x1c),*(undefined4 *)(puVar4 + 2));\n          if (cVar5 == '\\0') {\n            return 0;\n          }\n          uVar12 = (ulong)((int)uVar12 + 1);\n        }\n      }\n      uVar7 = stab_end_struct_type_lto_priv_0(param_2);\n      return uVar7;\n    case 9:\n    case 10:\n      if (*(long *)(param_3 + 4) == 0) {\n        uVar13 = 0;\n        piVar6 = (int *)0x0;\n      }\n      else {\n        if ((*(uint *)(*(long *)(param_3 + 4) + 0xc) <= *(uint *)(param_1 + 0x38)) &&\n           (uVar12 = param_1, cVar5 = debug_set_class_id_lto_priv_0(param_1,uVar7,param_3),\n           cVar5 == '\\0')) {\n          return 0;\n        }\n        lVar2 = *(long *)(param_3 + 4);\n        uVar13 = *(uint *)(lVar2 + 0xc);\n        if (*(int *)(param_1 + 0x30) == *(int *)(lVar2 + 8)) {\n          if (uVar13 <= *(uint *)(param_1 + 0x38)) {\n                    \n            __assert_fail(\"type->u.kclass->id > info->base_id\",\"../../binutils/debug.c\",0xa87,\n                          \"debug_write_class_type\");\n          }\n          iVar9 = *param_3;\n          goto LAB_00112ed2;\n        }\n        piVar6 = *(int **)(lVar2 + 0x20);\n        *(int *)(lVar2 + 8) = *(int *)(param_1 + 0x30);\n        if (((piVar6 != (int *)0x0) && (param_3 != piVar6)) &&\n           (uVar12 = param_1, cVar5 = FUNC_00112c1f(param_1,param_2,piVar6,0), cVar5 == '\\0')) {\n          return 0;\n        }\n      }\n      cVar5 = stab_start_class_type_lto_priv_0\n                        (param_2,uVar7,uVar13,*param_3 == 9,param_3[1],piVar6 != (int *)0x0,\n                         param_3 == piVar6,uVar12);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      if (*(long **)(param_3 + 4) != (long *)0x0) {\n        uVar13 = 0;\n        if (**(long **)(param_3 + 4) != 0) {\n          while (puVar4 = *(undefined8 **)(**(long **)(param_3 + 4) + (ulong)uVar13 * 8),\n                puVar4 != (undefined8 *)0x0) {\n            cVar5 = FUNC_00112c1f(param_1,param_2,puVar4[1],0);\n            if (cVar5 == '\\0') {\n              return 0;\n            }\n            if (*(char *)((long)puVar4 + 0x14) == '\\0') {\n              cVar5 = stab_struct_field_lto_priv_0(param_2,*puVar4,*(undefined4 *)(puVar4 + 3));\n            }\n            else {\n              cVar5 = stab_class_static_member_lto_priv_0(param_2,*puVar4,puVar4[3]);\n            }\n            if (cVar5 == '\\0') {\n              return 0;\n            }\n            uVar13 = uVar13 + 1;\n          }\n        }\n        uVar13 = 0;\n        if (*(long *)(*(long *)(param_3 + 4) + 0x10) != 0) {\n          while (puVar4 = *(undefined8 **)\n                           (*(long *)(*(long *)(param_3 + 4) + 0x10) + (ulong)uVar13 * 8),\n                puVar4 != (undefined8 *)0x0) {\n            cVar5 = FUNC_00112c1f(param_1,param_2,*puVar4,0);\n            if (cVar5 == '\\0') {\n              return 0;\n            }\n            cVar5 = stab_class_baseclass_lto_priv_0\n                              (param_2,*(undefined4 *)(puVar4 + 1),\n                               *(undefined *)((long)puVar4 + 0xc));\n            if (cVar5 == '\\0') {\n              return 0;\n            }\n            uVar13 = uVar13 + 1;\n          }\n        }\n        local_3c = 0;\n        if (*(long *)(*(long *)(param_3 + 4) + 0x18) != 0) {\n          while (puVar4 = *(undefined8 **)\n                           (*(long *)(*(long *)(param_3 + 4) + 0x18) + (ulong)local_3c * 8),\n                puVar4 != (undefined8 *)0x0) {\n            cVar5 = stab_class_start_method_lto_priv_0(param_2,*puVar4);\n            if (cVar5 == '\\0') {\n              return 0;\n            }\n            uVar13 = 0;\n            while (puVar3 = *(undefined8 **)(puVar4[1] + (ulong)uVar13 * 8),\n                  puVar3 != (undefined8 *)0x0) {\n              if ((puVar3[4] != 0) &&\n                 (cVar5 = FUNC_00112c1f(param_1,param_2,puVar3[4],0), cVar5 == '\\0')) {\n                return 0;\n              }\n              cVar5 = FUNC_00112c1f(param_1,param_2,puVar3[1],0);\n              if (cVar5 == '\\0') {\n                return 0;\n              }\n              if (puVar3[3] == -1) {\n                cVar5 = stab_class_static_method_variant_lto_priv_0\n                                  (param_2,*puVar3,*(undefined4 *)(puVar3 + 2),\n                                   *(undefined *)((long)puVar3 + 0x14),\n                                   *(undefined *)((long)puVar3 + 0x15));\n              }\n              else {\n                cVar5 = stab_class_method_variant_lto_priv_0(param_2);\n              }\n              if (cVar5 == '\\0') {\n                return 0;\n              }\n              uVar13 = uVar13 + 1;\n            }\n            cVar5 = stab_class_end_method_lto_priv_0(param_2);\n            if (cVar5 == '\\0') {\n              return 0;\n            }\n            local_3c = local_3c + 1;\n          }\n        }\n      }\n      uVar7 = stab_end_class_type_lto_priv_0(param_2);\n      return uVar7;\n    case 0xb:\n      puVar4 = *(undefined8 **)(param_3 + 4);\n      if (puVar4 == (undefined8 *)0x0) {\n        uVar8 = 0;\n        uVar11 = 0;\n      }\n      else {\n        uVar8 = puVar4[1];\n        uVar11 = *puVar4;\n      }\n      uVar7 = stab_enum_type_lto_priv_0(param_2,uVar7,uVar11,uVar8);\n      return uVar7;\n    case 0xc:\n      cVar5 = FUNC_00112c1f(param_1,param_2,*(undefined8 *)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      uVar7 = stab_pointer_type_lto_priv_0(param_2);\n      return uVar7;\n    case 0xd:\n      cVar5 = FUNC_00112c1f(param_1,param_2,**(undefined8 **)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      uVar12 = 0;\n      if (*(long *)(*(long *)(param_3 + 4) + 8) == 0) {\n        uVar12 = 0xffffffff;\n      }\n      else {\n        while (lVar2 = *(long *)(*(long *)(*(long *)(param_3 + 4) + 8) + uVar12 * 8), lVar2 != 0) {\n          uVar12 = uVar12 + 1;\n          cVar5 = FUNC_00112c1f(param_1,param_2,lVar2,0);\n          if (cVar5 == '\\0') {\n            return 0;\n          }\n        }\n        uVar12 = uVar12 & 0xffffffff;\n      }\n      uVar7 = stab_function_type_lto_priv_0\n                        (param_2,uVar12,*(undefined *)(*(long *)(param_3 + 4) + 0x10));\n      return uVar7;\n    case 0xe:\n      cVar5 = FUNC_00112c1f(param_1,param_2,*(undefined8 *)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      uVar7 = stab_reference_type_lto_priv_0(param_2);\n      return uVar7;\n    case 0xf:\n      cVar5 = FUNC_00112c1f(param_1,param_2,**(undefined8 **)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      uVar7 = stab_range_type_lto_priv_0\n                        (param_2,*(undefined8 *)(*(long *)(param_3 + 4) + 8),\n                         *(undefined8 *)(*(long *)(param_3 + 4) + 0x10));\n      return uVar7;\n    case 0x10:\n      cVar5 = FUNC_00112c1f(param_1,param_2,**(undefined8 **)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      cVar5 = FUNC_00112c1f(param_1,param_2,*(undefined8 *)(*(long *)(param_3 + 4) + 8),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      lVar2 = *(long *)(param_3 + 4);\n      uVar7 = stab_array_type_lto_priv_0\n                        (param_2,*(undefined8 *)(lVar2 + 0x10),*(undefined8 *)(lVar2 + 0x18),\n                         *(undefined *)(lVar2 + 0x20));\n      return uVar7;\n    case 0x11:\n      cVar5 = FUNC_00112c1f(param_1,param_2,**(undefined8 **)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      uVar7 = stab_set_type_lto_priv_0(param_2,*(undefined *)(*(long *)(param_3 + 4) + 8));\n      return uVar7;\n    case 0x12:\n      cVar5 = FUNC_00112c1f(param_1,param_2,**(undefined8 **)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      cVar5 = FUNC_00112c1f(param_1,param_2,*(undefined8 *)(*(long *)(param_3 + 4) + 8),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      uVar7 = stab_offset_type_lto_priv_0(param_2);\n      return uVar7;\n    case 0x13:\n      cVar5 = FUNC_00112c1f(param_1,param_2,**(undefined8 **)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      uVar12 = 0;\n      if (*(long *)(*(long *)(param_3 + 4) + 0x10) == 0) {\n        uVar12 = 0xffffffff;\n      }\n      else {\n        while (lVar2 = *(long *)(*(long *)(*(long *)(param_3 + 4) + 0x10) + uVar12 * 8), lVar2 != 0)\n        {\n          uVar12 = uVar12 + 1;\n          cVar5 = FUNC_00112c1f(param_1,param_2,lVar2,0);\n          if (cVar5 == '\\0') {\n            return 0;\n          }\n        }\n      }\n      if ((*(long *)(*(long *)(param_3 + 4) + 8) != 0) &&\n         (cVar5 = FUNC_00112c1f(param_1,param_2,*(long *)(*(long *)(param_3 + 4) + 8),0),\n         cVar5 == '\\0')) {\n        return 0;\n      }\n      uVar7 = stab_method_type_lto_priv_0\n                        (param_2,*(long *)(*(long *)(param_3 + 4) + 8) != 0,uVar12 & 0xffffffff,\n                         *(undefined *)(*(long *)(param_3 + 4) + 0x18));\n      return uVar7;\n    case 0x14:\n      cVar5 = FUNC_00112c1f(param_1,param_2,*(undefined8 *)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      uVar7 = stab_const_type_lto_priv_0(param_2);\n      return uVar7;\n    case 0x15:\n      cVar5 = FUNC_00112c1f(param_1,param_2,*(undefined8 *)(param_3 + 4),0);\n      if (cVar5 == '\\0') {\n        return 0;\n      }\n      uVar7 = stab_volatile_type_lto_priv_0(param_2);\n      return uVar7;\n    default:\n                    \n      abort();\n    }\n  }\n  goto LAB_00112dd6;\nswitchD_00112d8e_caseD_1:\n  bVar14 = *(int **)**(undefined8 **)(param_3 + 4) == param_3;\n  param_3 = *(int **)**(undefined8 **)(param_3 + 4);\n  if (bVar14) {\nLAB_00112dd6:\n    uVar7 = stab_empty_type_lto_priv_0(param_2);\n    return uVar7;\n  }\n  goto LAB_00112c39;\n}\n\n",
            "called": [
                "stab_typedef_type.lto_priv.0",
                "stab_end_struct_type.lto_priv.0",
                "stab_tag_type.lto_priv.0",
                "stab_float_type.lto_priv.0",
                "stab_struct_field.lto_priv.0",
                "debug_set_class_id.lto_priv.0",
                "stab_set_type.lto_priv.0",
                "stab_start_struct_type.lto_priv.0",
                "stab_enum_type.lto_priv.0",
                "debug_write_type.constprop.0",
                "stab_class_baseclass.lto_priv.0",
                "dcgettext",
                "stab_bool_type.lto_priv.0",
                "stab_class_start_method.lto_priv.0",
                "stab_pointer_type.lto_priv.0",
                "stab_class_static_member.lto_priv.0",
                "stab_method_type.lto_priv.0",
                "__assert_fail",
                "stab_class_method_variant.lto_priv.0",
                "debug_get_real_type.isra.0",
                "stab_function_type.lto_priv.0",
                "stab_volatile_type.lto_priv.0",
                "stab_void_type.lto_priv.0",
                "stab_complex_type.lto_priv.0",
                "stab_start_class_type.lto_priv.0",
                "stab_const_type.lto_priv.0",
                "stab_range_type.lto_priv.0",
                "abort",
                "stab_class_end_method.lto_priv.0",
                "stab_int_type.lto_priv.0",
                "stab_reference_type.lto_priv.0",
                "stab_array_type.lto_priv.0",
                "stab_offset_type.lto_priv.0",
                "fprintf",
                "stab_class_static_method_variant.lto_priv.0",
                "stab_empty_type.lto_priv.0",
                "stab_end_class_type.lto_priv.0"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00112c1f",
            "calling": [
                "debug_write_type.constprop.0",
                "debug_write_name.constprop.0"
            ],
            "imported": false,
            "current_name": "FUNC_00112c1f"
        },
        "FUN_00104850": {
            "renaming": {},
            "code": "\nvoid bfd_map_over_sections(void)\n\n{\n  bfd_map_over_sections();\n  return;\n}\n\n",
            "called": [
                "bfd_map_over_sections"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104850",
            "calling": [
                "FUN_0010554f",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "FUN_00104850"
        },
        "FUN_00104730": {
            "renaming": {},
            "code": "\n\n\nint open(char *__file,int __oflag,...)\n\n{\n  int iVar1;\n  \n  iVar1 = open(__file,__oflag);\n  return iVar1;\n}\n\n",
            "called": [
                "open"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104730",
            "calling": [
                "simple_copy"
            ],
            "imported": false,
            "current_name": "FUN_00104730"
        },
        "FUN_0010808f": {
            "renaming": {
                "FUN_0010808f": "copy_private_data_0010808f",
                "unaff_R14B": "isPrivateCopy",
                "unaff_R15": "privateDataAddress",
                "lVar1": "errorMsg",
                "status": "errorCode"
            },
            "code": "\nvoid copyPrivateData_0010808f(void)\n\n{\n  long errorMsg;\n  char isPrivateCopy;\n  long privateDataAddress;\n  \n  errorMsg = dcgettext(0,\"failed to copy private data\",5);\n  if (isPrivateCopy != '\\0') {\n    *(undefined4 *)(*(long *)(privateDataAddress + 0xd0) + 4) = 8;\n  }\n  if (errorMsg != 0) {\n    errorCode = 1;\n    bfd_nonfatal_message(0);\n  }\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "bfd_nonfatal_message"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010808f",
            "calling": [
                "FUN_00108179"
            ],
            "imported": false,
            "current_name": "copy_private_data_0010808f"
        },
        "FUN_001281d0": {
            "renaming": {},
            "code": "\n\n\n\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memset@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001281d0",
            "calling": [
                "memset"
            ],
            "imported": false,
            "current_name": "FUN_001281d0"
        },
        "FUN_00104610": {
            "renaming": {},
            "code": "\nvoid unlink_if_ordinary(void)\n\n{\n  unlink_if_ordinary();\n  return;\n}\n\n",
            "called": [
                "unlink_if_ordinary"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104610",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00104610"
        },
        "FUN_00108fe8": {
            "renaming": {
                "FUN_00108fe8": "print_warning_00108fe8",
                "param_1": "errorMessage",
                "param_2": "warningMessage",
                "in_RAX": "formatSpecifier",
                "__format": "warningString"
            },
            "code": "\n\n\nvoid printWarning_00108fe8(undefined8 errorMessage,undefined8 warningMessage)\n\n{\n  undefined8 formatSpecifier;\n  char *warningString;\n  \n  warningString = (char *)dcgettext(0,\"Warning: %s: %s\\n\",5);\n  fprintf(_stderr,warningString,warningMessage,errorMessage,formatSpecifier);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108fe8",
            "calling": [
                "parse_stab",
                "parse_stab_type",
                "parse_number"
            ],
            "imported": false,
            "current_name": "print_warning_00108fe8"
        },
        "FUN_001280b8": {
            "renaming": {},
            "code": "\n\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fread@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001280b8",
            "calling": [
                "fread"
            ],
            "imported": false,
            "current_name": "FUN_001280b8"
        },
        "FUN_00105828": {
            "renaming": {
                "FUN_00105828": "check_file_format_00105828",
                "iVar1": "arch",
                "uVar2": "fileFormat",
                "uVar3": "filename",
                "uVar4": "errorMessage"
            },
            "code": "\nundefined8 checkFileFormat_00105828(void)\n\n{\n  int arch;\n  undefined4 fileFormat;\n  undefined8 filename;\n  undefined8 errorMessage;\n  \n  arch = bfd_get_arch();\n  if (arch == 0) {\n    filename = bfd_get_archive_filename();\n    errorMessage = dcgettext(0,\"Unable to recognise the format of the input file `%s\\'\",5);\n    non_fatal(errorMessage,filename);\n  }\n  else {\n    filename = bfd_get_mach();\n    fileFormat = bfd_get_arch();\n    filename = bfd_printable_arch_mach(fileFormat,filename);\n    errorMessage = dcgettext(0,\"Output file cannot represent architecture `%s\\'\",5);\n    non_fatal(errorMessage,filename);\n  }\n  return 0;\n}\n\n",
            "called": [
                "non_fatal",
                "dcgettext",
                "bfd_printable_arch_mach",
                "bfd_get_mach",
                "bfd_get_arch",
                "bfd_get_archive_filename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105828",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "check_file_format_00105828"
        },
        "FUN_0011a0e0": {
            "renaming": {
                "FUN_0011a0e0": "create_temp_directory_0011a0e0",
                "__template": "template_path",
                "pcVar1": "temp_directory_path"
            },
            "code": "\nchar * create_temp_directory_0011a0e0(void)\n\n{\n  char *template_path;\n  char *temp_directory_path;\n  \n  template_path = (char *)template_in_dir();\n  temp_directory_path = mkdtemp(template_path);\n  if (temp_directory_path == (char *)0x0) {\n    free(template_path);\n  }\n  return temp_directory_path;\n}\n\n",
            "called": [
                "template_in_dir",
                "mkdtemp",
                "make_tempdir.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a0e0",
            "calling": [
                "copy_file",
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "create_temp_directory_0011a0e0"
        },
        "FUN_0010bba1": {
            "renaming": {
                "FUN_0010bba1": "lookup_and_push_0010bba1",
                "param_1": "hash_table",
                "param_2": "key",
                "lVar1": "hash_result",
                "uVar2": "return_value"
            },
            "code": "\nundefined8 lookup_and_push_0010bba1(long hash_table,undefined8 key)\n\n{\n  long hash_result;\n  undefined8 return_value;\n  \n  hash_result = bfd_hash_lookup(hash_table + 0x1b8,key,0,0);\n  if ((hash_result != 0) && (0 < *(long *)(hash_result + 0x20))) {\n    return_value = stab_push_defined_type(hash_table,*(long *)(hash_result + 0x20),*(undefined4 *)(hash_result + 0x28));\n    return return_value;\n  }\n  return 0;\n}\n\n",
            "called": [
                "bfd_hash_lookup",
                "stab_push_defined_type"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bba1",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "lookup_and_push_0010bba1"
        },
        "FUN_00104740": {
            "renaming": {},
            "code": "\n\n\nint access(char *__name,int __type)\n\n{\n  int iVar1;\n  \n  iVar1 = access(__name,__type);\n  return iVar1;\n}\n\n",
            "called": [
                "access"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104740",
            "calling": [
                "try_dir.lto_priv.0"
            ],
            "imported": false,
            "current_name": "FUN_00104740"
        },
        "FUN_00104620": {
            "renaming": {},
            "code": "\nvoid bfd_iterate_over_targets(void)\n\n{\n  bfd_iterate_over_targets();\n  return;\n}\n\n",
            "called": [
                "bfd_iterate_over_targets"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104620",
            "calling": [
                "display_info.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00104620"
        },
        "FUN_00104860": {
            "renaming": {},
            "code": "\nvoid bfd_set_start_address(void)\n\n{\n  bfd_set_start_address();\n  return;\n}\n\n",
            "called": [
                "bfd_set_start_address"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104860",
            "calling": [
                "FUN_00107976"
            ],
            "imported": false,
            "current_name": "FUN_00104860"
        },
        "FUN_0010e6a8": {
            "renaming": {
                "FUN_0010e6a8": "write_symbol_to_debug_info_0010e6a8",
                "param_1": "debug_info_ptr",
                "param_2": "symbol_name",
                "__s": "type_name",
                "sVar3": "symbol_name_len",
                "sVar4": "type_name_len",
                "__s_00": "formatted_str",
                "lVar8": "symbol_id",
                "lVar5": "hash_lookup_result",
                "uVar1": "write_result",
                "uVar2": "symbol_attr",
                "uVar6": "error_msg",
                "uVar7": "failure_msg",
                "uVar9": "result_code",
                "auVar10": "result"
            },
            "code": "\nundefined  [16] write_symbol_to_debug_info_0010e6a8(long debug_info_ptr,char *symbol_name,undefined8 param_3,undefined8 param_4)\n\n{\n  uint write_result;\n  undefined4 symbol_attr;\n  char *type_name;\n  size_t symbol_name_len;\n  size_t type_name_len;\n  char *formatted_str;\n  long hash_lookup_result;\n  undefined8 error_msg;\n  undefined8 failure_msg;\n  long symbol_id;\n  ulong result_code;\n  undefined result [16];\n  \n  symbol_id = *(long *)(*(long *)(debug_info_ptr + 0x60) + 0x10);\n  symbol_attr = *(undefined4 *)(*(long *)(debug_info_ptr + 0x60) + 0x18);\n  type_name = (char *)stab_pop_type();\n  symbol_name_len = strlen(symbol_name);\n  type_name_len = strlen(type_name);\n  formatted_str = (char *)xmalloc(symbol_name_len + 0x14 + type_name_len);\n  if (symbol_id < 1) {\n    symbol_id = *(long *)(debug_info_ptr + 0x68);\n    *(long *)(debug_info_ptr + 0x68) = symbol_id + 1;\n    sprintf(formatted_str,\"%s:t%ld=%s\",symbol_name,symbol_id,type_name);\n  }\n  else {\n    sprintf(formatted_str,\"%s:t%s\",symbol_name,type_name);\n  }\n  free(type_name);\n  write_result = stab_write_symbol_lto_priv_0(debug_info_ptr,0x80,0,0,formatted_str);\n  result_code = (ulong)write_result;\n  if ((char)write_result != '\\0') {\n    free(formatted_str);\n    hash_lookup_result = bfd_hash_lookup(debug_info_ptr + 0x1b8,symbol_name,1,0);\n    if (hash_lookup_result != 0) {\n      *(long *)(hash_lookup_result + 0x20) = symbol_id;\n      *(undefined4 *)(hash_lookup_result + 0x28) = symbol_attr;\n      goto LAB_0010e7b3;\n    }\n    symbol_attr = bfd_get_error();\n    error_msg = bfd_errmsg(symbol_attr);\n    failure_msg = dcgettext(0,\"string_hash_lookup failed: %s\",5);\n    non_fatal(failure_msg,error_msg);\n  }\n  result_code = 0;\nLAB_0010e7b3:\n  result._8_8_ = param_4;\n  result._0_8_ = result_code;\n  return result;\n}\n\n",
            "called": [
                "bfd_hash_lookup",
                "bfd_get_error",
                "strlen",
                "bfd_errmsg",
                "stab_write_symbol.lto_priv.0",
                "non_fatal",
                "dcgettext",
                "sprintf",
                "free",
                "stab_pop_type",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e6a8",
            "calling": [
                "debug_write_name.constprop.0"
            ],
            "imported": false,
            "current_name": "write_symbol_to_debug_info_0010e6a8"
        },
        "FUN_0010e7c2": {
            "renaming": {
                "FUN_0010e7c2": "add_symbol_and_write_0010e7c2",
                "param_1": "symbol",
                "param_2": "prefix",
                "param_3": "param3",
                "param_4": "param4",
                "__s": "type",
                "sVar1": "prefixLength",
                "sVar2": "typeLength",
                "__s_00": "combinedString",
                "auVar3": "result"
            },
            "code": "\nundefined  [16] addSymbolAndWrite_0010e7c2(undefined8 symbol,char *prefix,undefined8 param3,undefined8 param4)\n\n{\n  char *type;\n  size_t prefixLength;\n  size_t typeLength;\n  char *combinedString;\n  undefined result [16];\n  \n  type = (char *)stab_pop_type();\n  prefixLength = strlen(prefix);\n  typeLength = strlen(type);\n  combinedString = (char *)xmalloc(prefixLength + 3 + typeLength);\n  sprintf(combinedString,\"%s:T%s\",prefix,type);\n  free(type);\n  result._0_4_ = stab_write_symbol_lto_priv_0(symbol,0x80,0,0,combinedString);\n  result._4_4_ = 0;\n  if ((char)result._0_4_ != '\\0') {\n    free(combinedString);\n  }\n  result._8_8_ = param4;\n  return result;\n}\n\n",
            "called": [
                "strlen",
                "stab_write_symbol.lto_priv.0",
                "sprintf",
                "free",
                "stab_pop_type",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e7c2",
            "calling": [
                "debug_write_name.constprop.0"
            ],
            "imported": false,
            "current_name": "add_symbol_and_write_0010e7c2"
        },
        "FUN_00119dd0": {
            "renaming": {
                "FUN_00119dd0": "report_and_exit_00119dd0",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "param_5": "input5",
                "param_6": "input6",
                "param_7": "input7",
                "param_8": "input8",
                "param_9": "param1",
                "param_10": "param2",
                "param_11": "param3",
                "param_12": "param4",
                "param_13": "param5",
                "param_14": "param6",
                "in_AL": "flag",
                "local_d8": "size",
                "local_d4": "constant",
                "local_d0": "buffer",
                "local_c8": "localBuffer",
                "local_b8": "tempBuffer",
                "local_b0": "param2_copy",
                "local_a8": "param3_copy",
                "local_a0": "param4_copy",
                "local_98": "param5_copy",
                "local_90": "param6_copy",
                "local_88": "input1_copy",
                "local_78": "input2_copy",
                "local_68": "input3_copy",
                "local_58": "input4_copy",
                "local_48": "input5_copy",
                "local_38": "input6_copy",
                "local_28": "input7_copy",
                "local_18": "input8_copy"
            },
            "code": "\nvoid reportAndExit_00119dd0(undefined4 input1,undefined4 input2,undefined4 input3,undefined4 input4,\n                 undefined4 input5,undefined4 input6,undefined4 input7,undefined4 input8,\n                 undefined8 param1,undefined8 param2,undefined8 param3,undefined8 param4,\n                 undefined8 param5,undefined8 param6)\n\n{\n  char flag;\n  undefined4 size;\n  undefined4 constant;\n  undefined *buffer;\n  undefined *localBuffer;\n  undefined tempBuffer [8];\n  undefined8 param2_copy;\n  undefined8 param3_copy;\n  undefined8 param4_copy;\n  undefined8 param5_copy;\n  undefined8 param6_copy;\n  undefined4 input1_copy;\n  undefined4 input2_copy;\n  undefined4 input3_copy;\n  undefined4 input4_copy;\n  undefined4 input5_copy;\n  undefined4 input6_copy;\n  undefined4 input7_copy;\n  undefined4 input8_copy;\n  \n  if (flag != '\\0') {\n    input1_copy = input1;\n    input2_copy = input2;\n    input3_copy = input3;\n    input4_copy = input4;\n    input5_copy = input5;\n    input6_copy = input6;\n    input7_copy = input7;\n    input8_copy = input8;\n  }\n  buffer = &stack0x00000008;\n  size = 8;\n  localBuffer = tempBuffer;\n  constant = 0x30;\n  param2_copy = param2;\n  param3_copy = param3;\n  param4_copy = param4;\n  param5_copy = param5;\n  param6_copy = param6;\n  report(param1,&size);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "xexit",
                "report"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00119dd0",
            "calling": [
                "add_redefine_and_check",
                "FUN_0010554f",
                "init_section_add.cold",
                "coff_get_slot.lto_priv.0",
                "find_section_list",
                "copy_section.cold",
                "main",
                "parse_vma.cold",
                "parse_flags.cold",
                "is_strip_section_1.isra.0.cold",
                "is_strip_section_1.isra.0",
                "create_new_symbol.cold",
                "copy_file",
                "FUN_00114dc7",
                "section_add_load_file.cold",
                "add_specific_symbols"
            ],
            "imported": false,
            "current_name": "report_and_exit_00119dd0"
        },
        "FUN_00104500": {
            "renaming": {},
            "code": "\nvoid bfd_set_format(void)\n\n{\n  bfd_set_format();\n  return;\n}\n\n",
            "called": [
                "bfd_set_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104500",
            "calling": [
                "copy_object",
                "copy_file",
                "FUN_00107880",
                "do_display_target"
            ],
            "imported": false,
            "current_name": "FUN_00104500"
        },
        "FUN_001083b7": {
            "renaming": {
                "FUN_001083b7": "handle_bfd_error_001083b7",
                "param_1": "error_code",
                "iVar1": "bfd_error",
                "unaff_RBP": "pointer_to_error",
                "unaff_retaddr": "return_address"
            },
            "code": "\nundefined8 handle_bfd_error_001083b7(long error_code)\n\n{\n  int bfd_error;\n  undefined8 *pointer_to_error;\n  undefined8 return_address;\n  \n  if (error_code == -1) {\n    bfd_error = bfd_get_error();\n    if (bfd_error == 5) {\n      return return_address;\n    }\n  }\n  bfd_nonfatal(*pointer_to_error);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "bfd_get_error",
                "xexit",
                "bfd_nonfatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001083b7",
            "calling": [
                "mark_symbols_used_in_relocations"
            ],
            "imported": false,
            "current_name": "handle_bfd_error_001083b7"
        },
        "FUN_001280e8": {
            "renaming": {},
            "code": "\n\n\n\nssize_t write(int __fd,void *__buf,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* write@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001280e8",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "FUN_001280e8"
        },
        "FUN_00116852": {
            "renaming": {
                "FUN_00116852": "process_build_notes_00116852",
                "in_RCX": "note_entries",
                "in_R10": "index",
                "unaff_RBX": "max_size",
                "unaff_RBP": "prev_note",
                "unaff_R13": "start",
                "unaff_R14": "current",
                "unaff_R15": "start_size",
                "param_7": "param_1",
                "param_9": "param_2",
                "param_10": "param_3",
                "param_11": "param_4",
                "param_12": "param_5",
                "param_13": "param_6",
                "param_14": "param_7",
                "bVar14": "bVar",
                "iVar3": "result",
                "uVar4": "count",
                "uVar5": "size_a",
                "uVar6": "size_b",
                "uVar8": "index_a",
                "lVar7": "length",
                "__ptr": "buffer",
                "puVar9": "dest",
                "cVar10": "flag",
                "puVar11": "dest_a",
                "puVar12": "dest_b",
                "psVar13": "note_ptr",
                "sVar1": "note_size"
            },
            "code": "\nulong processBuildNotes_00116852(void)\n\n{\n  size_t note_size;\n  code *pcVar2;\n  int result;\n  uint count;\n  undefined *buffer;\n  size_t *note_entries;\n  ulong size_a;\n  ulong size_b;\n  long length;\n  ulong index_a;\n  size_t max_size;\n  size_t *prev_note;\n  undefined *dest;\n  char flag;\n  undefined *dest_a;\n  ulong index;\n  undefined *dest_b;\n  size_t in_R11;\n  size_t *start;\n  size_t *current;\n  size_t start_size;\n  size_t *note_ptr;\n  byte bVar;\n  size_t param_1;\n  size_t param_2;\n  ulong param_3;\n  size_t *param_4;\n  undefined *param_5;\n  long param_6;\n  size_t param_7;\n  \n  bVar = 0;\ncode_r0x00116852:\n  count = (int)index + 1;\n  if (0x10 < (int)index) goto LAB_001167f5;\nLAB_00116863:\n  current = current + -9;\n  do {\n    if (start <= current) {\n      note_size = current[2];\n      if (note_size == 0) goto LAB_00116863;\n      index_a = (ulong)count;\n      if ((*current == *prev_note) &&\n         (result = memcmp((void *)current[3],(void *)prev_note[3],*prev_note), result == 0)) {\n        size_b = current[7];\n        size_a = current[8];\n        index = index_a & 0xffffffff;\n        if (start_size == size_b) {\n          if (max_size != size_a) goto LAB_001167a6;\n          prev_note[2] = 0;\n        }\n        else {\n          if (start_size < size_b) {\n            if (size_a < start_size) {\nLAB_0010852c:\n              if ((0xfffffffffffffff0 < size_a) || (start_size <= (size_a + 0xf & 0xfffffffffffffff0)))\n              goto code_r0x00116852;\n            }\n            else if (max_size < start_size) {\n              if ((0xfffffffffffffff0 < max_size) ||\n                 (size_b <= (max_size + 0xf & 0xfffffffffffffff0))) goto code_r0x00116852;\n            }\n            else if (max_size == size_a) goto code_r0x00116852;\n          }\n          else {\nLAB_001167a6:\n            if (max_size <= size_a) {\n              prev_note[2] = 0;\n              goto LAB_001167f5;\n            }\n            if (size_a < start_size) goto LAB_0010852c;\n          }\n          if ((in_R11 == 0x101) != (note_size == 0x101)) goto code_r0x00116852;\n          if (size_a <= max_size) {\n            size_a = max_size;\n          }\n          if (size_b < start_size) {\n            start_size = size_b;\n          }\n          current[8] = size_a;\n          current[7] = start_size;\n          prev_note[2] = 0;\n        }\n      }\n    }\nLAB_001167f5:\n    while( true ) {\n      do {\n        current = prev_note;\n        prev_note = current + 9;\n        if (note_entries <= prev_note) {\n          qsort(param_4,param_7,0x48,sort_gnu_build_notes);\n          buffer = (undefined *)xmalloc(param_3 * 2);\n          param_1 = 0;\n          dest_b = buffer;\n          for (note_ptr = param_4; note_ptr < note_entries; note_ptr = note_ptr + 9) {\n            if (note_ptr[2] != 0) {\n              dest_a = dest_b + 4;\n              dest = dest_b + 0xc;\n              pcVar2 = *(code **)(*(long *)(param_6 + 8) + 0x50);\n              if ((note_ptr[7] == param_2) && (note_ptr[8] == param_1)) {\n                (*pcVar2)(*note_ptr,dest_b);\n                (**(code **)(*(long *)(param_6 + 8) + 0x50))(0,dest_a);\n                (**(code **)(*(long *)(param_6 + 8) + 0x50))(note_ptr[2],dest_b + 8);\n                size_b = note_ptr[6];\n                index_a = *note_ptr;\n                dest_b = (undefined *)note_ptr[3];\n                dest_a = dest;\n                for (size_a = index_a; size_a != 0; size_a = size_a - 1) {\n                  *dest_a = *dest_b;\n                  dest_b = dest_b + (ulong)bVar * -2 + 1;\n                  dest_a = dest_a + (ulong)bVar * -2 + 1;\n                }\n                if (index_a < size_b) {\n                  for (length = size_b - index_a; length != 0; length = length + -1) {\n                    *dest_a = 0;\n                    dest_a = dest_a + (ulong)bVar * -2 + 1;\n                  }\n                }\n                dest_b = dest + size_b;\n              }\n              else {\n                (*pcVar2)();\n                if (*(int *)(*(long *)(param_6 + 8) + 8) == 5) {\n                  flag = (*(char *)(*(long *)(param_6 + 0x110) + 4) == '\\x02') * '\\b' + '\\b';\n                }\n                else {\n                  flag = '\\b';\n                }\n                (**(code **)(*(long *)(param_6 + 8) + 0x50))(flag,dest_a);\n                (**(code **)(*(long *)(param_6 + 8) + 0x50))(note_ptr[2],dest_b + 8);\n                index_a = *note_ptr;\n                dest_b = (undefined *)note_ptr[3];\n                dest_a = dest;\n                for (size_b = index_a; size_b != 0; size_b = size_b - 1) {\n                  *dest_a = *dest_b;\n                  dest_b = dest_b + (ulong)bVar * -2 + 1;\n                  dest_a = dest_a + (ulong)bVar * -2 + 1;\n                }\n                size_b = note_ptr[6];\n                if (index_a < size_b) {\n                  for (length = size_b - index_a; length != 0; length = length + -1) {\n                    *dest_a = 0;\n                    dest_a = dest_a + (ulong)bVar * -2 + 1;\n                  }\n                }\n                length = *(long *)(param_6 + 8);\n                dest = dest + size_b;\n                dest_b = dest + 8;\n                if ((*(int *)(length + 8) == 5) &&\n                   (*(char *)(*(long *)(param_6 + 0x110) + 4) == '\\x02')) {\n                  (**(code **)(length + 0x38))(note_ptr[7],dest);\n                  (**(code **)(*(long *)(param_6 + 8) + 0x38))(note_ptr[8],dest_b);\n                  dest_b = dest + 0x10;\n                }\n                else {\n                  (**(code **)(length + 0x50))(note_ptr[7],dest);\n                  (**(code **)(*(long *)(param_6 + 8) + 0x50))(note_ptr[8],dest + 4);\n                }\n                param_2 = note_ptr[7];\n                param_1 = note_ptr[8];\n              }\n            }\n          }\n          size_b = (long)dest_b - (long)buffer;\n          index_a = size_b;\n          dest_b = buffer;\n          if (size_b < param_3) {\n            for (; param_3 = size_b, index_a != 0; index_a = index_a - 1) {\n              *param_5 = *dest_b;\n              dest_b = dest_b + (ulong)bVar * -2 + 1;\n              param_5 = param_5 + (ulong)bVar * -2 + 1;\n            }\n          }\n          free(buffer);\n          free(param_4);\n          return param_3;\n        }\n        in_R11 = current[0xb];\n      } while (in_R11 == 0);\n      start_size = current[0x10];\n      max_size = current[0x11];\n      count = 0;\n      if (start_size != max_size) break;\n      current[0xb] = 0;\n    }\n  } while( true );\n}\n\n",
            "called": [
                "memcmp",
                "FUN_00116852",
                "qsort",
                "free",
                "sort_gnu_build_notes",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116852",
            "calling": [
                "FUN_00116852"
            ],
            "imported": false,
            "current_name": "process_build_notes_00116852"
        },
        "FUN_00113d3a": {
            "renaming": {
                "FUN_00113d3a": "initialize_type_00113d3a",
                "param_1": "input",
                "lVar1": "typePointer"
            },
            "code": "\nlong initializeType_00113d3a(long input)\n\n{\n  long typePointer;\n  \n  if (input != 0) {\n    typePointer = *(long *)(input + 8);\n    if (typePointer == 0) {\n      typePointer = debug_make_type_constprop_0(0xc,0);\n      if (typePointer == 0) {\n        typePointer = 0;\n      }\n      else {\n        *(long *)(typePointer + 0x10) = input;\n        *(long *)(input + 8) = typePointer;\n      }\n    }\n    return typePointer;\n  }\n  return 0;\n}\n\n",
            "called": [
                "debug_make_type.constprop.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113d3a",
            "calling": [
                "stab_demangle_v3_arg",
                "parse_coff_type.lto_priv.0",
                "parse_stab",
                "parse_stab_type",
                "stab_demangle_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "initialize_type_00113d3a"
        },
        "FUN_00104630": {
            "renaming": {},
            "code": "\nvoid bfd_set_file_flags(void)\n\n{\n  bfd_set_file_flags();\n  return;\n}\n\n",
            "called": [
                "bfd_set_file_flags"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104630",
            "calling": [
                "FUN_00107976"
            ],
            "imported": false,
            "current_name": "FUN_00104630"
        },
        "FUN_00104510": {
            "renaming": {},
            "code": "\n\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n  long lVar1;\n  \n  lVar1 = strtol(__nptr,__endptr,__base);\n  return lVar1;\n}\n\n",
            "called": [
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104510",
            "calling": [
                "display_info.isra.0.cold",
                "main",
                "parse_stab",
                "parse_stab_type",
                "stab_demangle_qualified"
            ],
            "imported": false,
            "current_name": "FUN_00104510"
        },
        "FUN_00104870": {
            "renaming": {},
            "code": "\nvoid bfd_bread(void)\n\n{\n  bfd_bread();\n  return;\n}\n\n",
            "called": [
                "bfd_bread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104870",
            "calling": [
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "FUN_00104870"
        },
        "FUN_00104750": {
            "renaming": {},
            "code": "\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 = fopen(__filename,__modes);\n  return pFVar1;\n}\n\n",
            "called": [
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104750",
            "calling": [
                "main",
                "section_add_load_file",
                "FUN_00107880",
                "add_specific_symbols"
            ],
            "imported": false,
            "current_name": "FUN_00104750"
        },
        "FUN_0010a0d3": {
            "renaming": {
                "FUN_0010a0d3": "FUNC_0010a0d3"
            },
            "code": "\nvoid FUNC_0010a0d3(long param_1)\n\n{\n  stab_modify_type(param_1,0x42,*(undefined4 *)(*(long *)(param_1 + 0x60) + 0x18),0,0);\n  return;\n}\n\n",
            "called": [
                "stab_modify_type"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0010a0d3",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "FUNC_0010a0d3"
        },
        "FUN_00115530": {
            "renaming": {
                "FUN_00115530": "create_output_section_00115530",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "lVar1": "tempVar1",
                "pcVar2": "tempVar2",
                "ppcVar3": "tempVar3",
                "cVar4": "tempVar4",
                "iVar5": "tempVar5",
                "uVar6": "tempVar6",
                "sVar7": "tempVar7",
                "sVar8": "tempVar8",
                "lVar9": "tempVar9",
                "pcVar10": "tempVar10",
                "pcVar11": "tempVar11",
                "pcVar12": "tempVar12",
                "uVar13": "tempVar13",
                "bVar14": "tempVar14",
                "local_50": "localErrorMsg",
                "local_48": "localSectionName",
                "local_40": "localTempArray"
            },
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nvoid createOutputSection_00115530(long param1,char **param2,long param3)\n\n{\n  long tempVar1;\n  char *tempVar2;\n  char **tempVar3;\n  char tempVar4;\n  int tempVar5;\n  uint tempVar6;\n  size_t tempVar7;\n  size_t tempVar8;\n  long tempVar9;\n  char *tempVar10;\n  char *tempVar11;\n  char *tempVar12;\n  uint tempVar13;\n  bool tempVar14;\n  long localErrorMsg;\n  char *localSectionName;\n  long localTempArray [2];\n  \n  tempVar4 = is_strip_section_isra_0(param2);\n  if (tempVar4 != '\\0') {\n    return;\n  }\n  tempVar10 = *param2;\n  tempVar13 = *(uint *)((long)param2 + 0x24);\n  localSectionName = tempVar10;\n  tempVar3 = section_rename_list;\n  if (*(int *)(*(long *)(param1 + 8) + 8) != *(int *)(*(long *)(param3 + 8) + 8)) {\n    tempVar13 = tempVar13 & *(uint *)(*(long *)(param1 + 8) + 0x18) &\n             *(uint *)(*(long *)(param3 + 8) + 0x18);\n  }\n  for (; tempVar3 != (char **)0x0; tempVar3 = (char **)tempVar3[3]) {\n    tempVar5 = strcmp(*tempVar3,tempVar10);\n    if (tempVar5 == 0) {\n      if (*(uint *)(tempVar3 + 2) != 0xffffffff) {\n        tempVar13 = *(uint *)(tempVar3 + 2);\n      }\n      if (tempVar10 != tempVar3[1]) {\n        localSectionName = tempVar3[1];\n        tempVar13 = check_new_section_flags(tempVar13,param3);\n      }\n      break;\n    }\n  }\n  if (((prefix_alloc_sections_string != (char *)0x0) &&\n      (tempVar10 = prefix_alloc_sections_string, (*(byte *)((long)param2 + 0x24) & 1) != 0)) ||\n     (tempVar10 = prefix_sections_string, prefix_sections_string != (char *)0x0)) {\n    tempVar7 = strlen(tempVar10);\n    tempVar8 = strlen(localSectionName);\n    tempVar12 = (char *)xmalloc(tempVar7 + 1 + tempVar8);\n    tempVar10 = strcpy(tempVar12,tempVar10);\n    localSectionName = strcat(tempVar10,localSectionName);\n  }\n  tempVar9 = find_section_list(*param2,0,0x80);\n  tempVar14 = false;\n  if (tempVar9 == 0) {\n    if ((strip_symbols == 4) && ((tempVar13 & 0x2000001) != 0)) {\n      tempVar5 = *(int *)(*(long *)(param1 + 8) + 8);\n      if (tempVar5 == 5) {\n        if (*(int *)(param2[0x1a] + 4) != 7) {\nLAB_00115771:\n          if (*(int *)(*(long *)(param3 + 8) + 8) == 5) {\n            tempVar14 = (tempVar13 & 0x2000000) == 0;\n            tempVar6 = ~((-(uint)((tempVar13 & 0x2000000) == 0) & 0x2000100) + 2);\n            *(uint *)((long)param2 + 0x24) = *(uint *)((long)param2 + 0x24) & tempVar6;\n          }\n          else {\n            tempVar6 = 0xfdfffefd;\n          }\n          tempVar13 = tempVar13 & tempVar6;\n        }\n      }\n      else if ((tempVar5 != 2) || (tempVar5 = strcmp(*param2,\".buildid\"), tempVar5 != 0)) goto LAB_00115771;\n    }\n  }\n  else {\n    tempVar13 = check_new_section_flags(tempVar13 & 0x104 | *(uint *)(tempVar9 + 0x28),param3,*param2);\n  }\n  tempVar4 = bfd_convert_section_setup(param1,param2,param3,&localSectionName,localTempArray);\n  if (tempVar4 == '\\0') {\n    tempVar10 = (char *)0x0;\n    localErrorMsg = dcgettext(0,\"failed to create output section\",5);\n    goto LAB_001080d1;\n  }\n  tempVar10 = (char *)bfd_make_section_anyway_with_flags(param3,localSectionName,tempVar13);\n  if (tempVar10 == (char *)0x0) {\n    localErrorMsg = dcgettext(0,\"failed to create output section\",5);\n    goto LAB_001080d1;\n  }\n  if (copy_byte < 0) {\n    if (extract_symbol != '\\0') {\n      localTempArray[0] = 0;\n      goto LAB_001158e7;\n    }\n    tempVar4 = bfd_set_section_size(tempVar10,localTempArray[0]);\n    if (tempVar4 == '\\0') {\n      setup_section_cold();\n      return;\n    }\n  }\n  else {\n    localTempArray[0] = ((((long)interleave - 1U) + localTempArray[0]) / (ulong)(long)interleave) *\n                  (long)copy_width;\nLAB_001158e7:\n    tempVar4 = bfd_set_section_size(tempVar10);\n    if (tempVar4 == '\\0') {\n      setup_section_cold();\n      return;\n    }\n  }\n  localErrorMsg = 0;\n  tempVar12 = param2[6];\n  tempVar9 = find_section_list(*param2,0,0x18);\n  if (tempVar9 == 0) {\n    tempVar10[0x28] = tempVar10[0x28] | 1;\n    tempVar11 = *param2;\n    tempVar12 = tempVar12 + change_section_address;\n    *(char **)(tempVar10 + 0x30) = tempVar12;\n    *(char **)(tempVar10 + 0x38) = tempVar12;\n    tempVar12 = param2[7];\n    tempVar9 = find_section_list(tempVar11,0,0x60);\n    if (tempVar9 == 0) goto LAB_00115695;\nLAB_00115860:\n    tempVar11 = *(char **)(tempVar9 + 0x20);\n    if ((*(byte *)(tempVar9 + 0x14) & 0x40) != 0) {\n      tempVar11 = tempVar11 + (long)tempVar12;\n    }\n    *(char **)(tempVar10 + 0x38) = tempVar11;\n    tempVar9 = find_section_list(*param2,0,0x200);\n    if (tempVar9 != 0) goto LAB_00115889;\nLAB_001156b8:\n    tempVar13 = *(uint *)((long)param2 + 0x7c);\n    if (tempVar13 < 0x3f) goto LAB_001156c4;\n    localErrorMsg = dcgettext(0,\"failed to set alignment\",5);\n    *(undefined4 *)(tempVar10 + 0xb4) = *(undefined4 *)((long)param2 + 0xb4);\n    tempVar10[0x28] = tempVar10[0x28] & 0xcfU | *(byte *)(param2 + 5) & 0x30;\n    param2[0xc] = tempVar10;\n    param2[0xb] = (char *)0x0;\n    if ((*(byte *)((long)param2 + 0x27) & 2) != 0) goto LAB_001157c8;\nLAB_00115700:\n    tempVar4 = (**(code **)(*(long *)(param3 + 8) + 0x158))(param1,param2,param3,tempVar10);\n    if (tempVar4 == '\\0') {\n      copy_private_data_0010808f();\n      return;\n    }\n  }\n  else {\n    tempVar11 = *(char **)(tempVar9 + 0x18);\n    if ((*(byte *)(tempVar9 + 0x14) & 8) == 0) {\n      tempVar11 = tempVar11 + (long)tempVar12;\n    }\n    tempVar10[0x28] = tempVar10[0x28] | 1;\n    tempVar2 = *param2;\n    *(char **)(tempVar10 + 0x30) = tempVar11;\n    *(char **)(tempVar10 + 0x38) = tempVar11;\n    tempVar12 = param2[7];\n    tempVar9 = find_section_list(tempVar2,0,0x60);\n    if (tempVar9 != 0) goto LAB_00115860;\nLAB_00115695:\n    tempVar11 = *param2;\n    *(char **)(tempVar10 + 0x38) = tempVar12 + change_section_address;\n    tempVar9 = find_section_list(tempVar11,0,0x200);\n    if (tempVar9 == 0) goto LAB_001156b8;\nLAB_00115889:\n    tempVar13 = *(uint *)(tempVar9 + 0x2c);\n    if (0x3e < tempVar13) {\n      set_alignment_00108179();\n      return;\n    }\nLAB_001156c4:\n    *(uint *)(tempVar10 + 0x7c) = tempVar13;\n    *(undefined4 *)(tempVar10 + 0xb4) = *(undefined4 *)((long)param2 + 0xb4);\n    tempVar10[0x28] = tempVar10[0x28] & 0xcfU | *(byte *)(param2 + 5) & 0x30;\n    param2[0xc] = tempVar10;\n    param2[0xb] = (char *)0x0;\n    if ((*(byte *)((long)param2 + 0x27) & 2) == 0) goto LAB_00115700;\nLAB_001157c8:\n    tempVar12 = param2[0x1a];\n    tempVar9 = group_signature_isra_0(tempVar12,param2[0x1c]);\n    if ((tempVar9 == 0) ||\n       (tempVar1 = *(long *)(param1 + 8), *(uint *)(tempVar9 + 0x18) = *(uint *)(tempVar9 + 0x18) | 0x20,\n       *(int *)(tempVar1 + 8) != 5)) goto LAB_00115700;\n    *(long *)(tempVar12 + 0xb0) = tempVar9;\n    tempVar4 = (**(code **)(*(long *)(param3 + 8) + 0x158))(param1,param2,param3,tempVar10);\n    if (tempVar4 == '\\0') {\n      copy_private_data_0010808f();\n      return;\n    }\n  }\n  if (tempVar14) {\n    *(undefined4 *)(*(long *)(tempVar10 + 0xd0) + 4) = 8;\n  }\n  if (localErrorMsg == 0) {\n    return;\n  }\nLAB_001080d1:\n  status = 1;\n  bfd_nonfatal_message(0,param3,tempVar10,localErrorMsg);\n  return;\n}\n\n",
            "called": [
                "check_new_section_flags",
                "is_strip_section.isra.0",
                "find_section_list",
                "setup_section.cold",
                "strcpy",
                "strcat",
                "strlen",
                "dcgettext",
                "bfd_set_section_size",
                "bfd_convert_section_setup",
                "bfd_make_section_anyway_with_flags",
                "xmalloc",
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115530",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "create_output_section_00115530"
        },
        "FUN_0010a0bd": {
            "renaming": {
                "FUN_0010a0bd": "update_stab_type_0010a0bd",
                "param_1": "inputAddress",
                "stab_modify_type": "modifyType"
            },
            "code": "\nvoid updateStabType_0010a0bd(long inputAddress)\n\n{\n  modifyType(inputAddress,0x6b,*(undefined4 *)(*(long *)(inputAddress + 0x60) + 0x18),0,0);\n  return;\n}\n\n",
            "called": [
                "stab_modify_type"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a0bd",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "update_stab_type_0010a0bd"
        },
        "FUN_00113e5e": {
            "renaming": {
                "FUN_00113e5e": "validate_and_demangle_type_00113e5e",
                "param_1": "param",
                "param_2": "arg_array",
                "param_3": "length",
                "cVar1": "is_valid",
                "local_20[0]": "str_ptr"
            },
            "code": "\nundefined8 validate_and_demangle_type_00113e5e(undefined8 param,char **arg_array,long length)\n\n{\n  char is_valid;\n  char *local_20 [2];\n  \n  str_ptr = *arg_array;\n  *arg_array = (char *)(length + 2);\n  if ((((long)(char *)(length + 2) - (long)str_ptr < 5) ||\n      (is_valid = startswith_lto_priv_0_lto_priv_0(str_ptr,\"type\"), is_valid == '\\0')) ||\n     ((str_ptr[4] != '$' && (str_ptr[4] != '.')))) {\n    if (*str_ptr != '_') {\n      return 1;\n    }\n    if (str_ptr[1] != '_') {\n      return 1;\n    }\n    if (str_ptr[2] != 'o') {\n      return 1;\n    }\n    if (str_ptr[3] != 'p') {\n      return 1;\n    }\n    str_ptr = str_ptr + 4;\n  }\n  else {\n    str_ptr = str_ptr + 5;\n  }\n  is_valid = stab_demangle_type_lto_priv_0(param,local_20,0);\n  if (is_valid != '\\0') {\n    return 1;\n  }\n  return 0;\n}\n\n",
            "called": [
                "startswith.lto_priv.0.lto_priv.0",
                "stab_demangle_type.lto_priv.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113e5e",
            "calling": [
                "parse_stab_type"
            ],
            "imported": false,
            "current_name": "validate_and_demangle_type_00113e5e"
        },
        "FUN_00104520": {
            "renaming": {},
            "code": "\nvoid bfd_octets_per_byte(void)\n\n{\n  bfd_octets_per_byte();\n  return;\n}\n\n",
            "called": [
                "bfd_octets_per_byte"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104520",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "FUN_00104520"
        },
        "FUN_00104400": {
            "renaming": {},
            "code": "\nvoid bfd_get_section_by_name(void)\n\n{\n  bfd_get_section_by_name();\n  return;\n}\n\n",
            "called": [
                "bfd_get_section_by_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104400",
            "calling": [
                "FUN_0010554f",
                "create_new_symbol",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "FUN_00104400"
        },
        "FUN_00104760": {
            "renaming": {},
            "code": "\nvoid xexit(void)\n\n{\n                    \n  xexit();\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104760",
            "calling": [
                "main",
                "mark_symbols_used_in_relocations.cold",
                "copy_relocations_in_section",
                "mark_symbols_used_in_relocations",
                "fatal"
            ],
            "imported": false,
            "current_name": "FUN_00104760"
        },
        "FUN_00104640": {
            "renaming": {},
            "code": "\n\n\nint mkstemp(char *__template)\n\n{\n  int iVar1;\n  \n  iVar1 = mkstemp(__template);\n  return iVar1;\n}\n\n",
            "called": [
                "mkstemp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104640",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00104640"
        },
        "FUN_0010abdd": {
            "renaming": {
                "FUN_0010abdd": "update_data_0010abdd",
                "param_1": "data_ptr",
                "param_2": "string1",
                "param_3": "length",
                "param_4": "flag1",
                "param_5": "flag2",
                "param_6": "flag3",
                "param_7": "value",
                "param_8": "flag4",
                "lVar1": "data_ptr",
                "pcVar2": "string2",
                "bVar3": "byteVal",
                "pcVar4": "string3",
                "__s": "string4",
                "sVar5": "length1",
                "sVar6": "length2",
                "sVar7": "length3",
                "sVar8": "length4",
                "uVar9": "result",
                "cVar10": "charVal1",
                "cVar11": "charVal2",
                "local_52": "localByte"
            },
            "code": "\nundefined8\nupdateData_0010abdd(long data_ptr,char *string1,uint length,char flag1,char flag2,char flag3,\n            undefined8 value,char flag4)\n\n{\n  long data_ptr;\n  char *string2;\n  byte byteVal;\n  char *string3;\n  char *string4;\n  size_t length1;\n  size_t length2;\n  size_t length3;\n  size_t length4;\n  undefined8 result;\n  char charVal1;\n  char charVal2;\n  byte localByte;\n  \n  string4 = (char *)0x0;\n  localByte = *(byte *)(*(long *)(data_ptr + 0x60) + 0x1c);\n  string3 = (char *)stab_pop_type();\n  if (flag4 != '\\0') {\n    byteVal = 1;\n    if (localByte == 0) {\n      byteVal = *(byte *)(*(long *)(data_ptr + 0x60) + 0x1c);\n    }\n    localByte = byteVal & 1;\n    string4 = (char *)stab_pop_type(data_ptr);\n  }\n  data_ptr = *(long *)(data_ptr + 0x60);\n  if ((data_ptr == 0) || (string2 = *(char **)(data_ptr + 0x30), string2 == (char *)0x0)) {\n    result = 0;\n  }\n  else {\n    if (2 < length) {\n                    \n      abort();\n    }\n    if (flag2 == '\\0') {\n      charVal2 = (-(flag3 == '\\0') & 0xfeU) + 0x43;\n    }\n    else {\n      charVal2 = (-(flag3 == '\\0') & 0xfeU) + 0x44;\n    }\n    charVal1 = '?';\n    if (flag1 == '\\0') {\n      charVal1 = (-(flag4 == '\\0') & 4U) + 0x2a;\n    }\n    length1 = strlen(string2);\n    length2 = strlen(string3);\n    length3 = strlen(string1);\n    length4 = 0;\n    if (flag4 != '\\0') {\n      length4 = strlen(string4);\n    }\n    result = xrealloc(string2,length3 + length1 + 0x28 + length2 + length4);\n    *(undefined8 *)(data_ptr + 0x30) = result;\n    string2 = *(char **)(*(long *)(data_ptr + 0x60) + 0x30);\n    length1 = strlen(string2);\n    sprintf(string2 + length1,\"%s:%s;%c%c%c\",string3,string1,(ulong)(byte)(0x32 - (char)length),\n            (ulong)(uint)(int)charVal2,(ulong)(uint)(int)charVal1,length1);\n    free(string3);\n    if (flag4 != '\\0') {\n      string3 = *(char **)(*(long *)(data_ptr + 0x60) + 0x30);\n      length1 = strlen(string3);\n      sprintf(string3 + length1,\"%ld;%s;\",value,string4);\n      free(string4);\n    }\n    if (localByte != 0) {\n      *(undefined *)(*(long *)(data_ptr + 0x60) + 0x1c) = 1;\n    }\n    result = 1;\n  }\n  return result;\n}\n\n",
            "called": [
                "strlen",
                "sprintf",
                "abort",
                "xrealloc",
                "free",
                "stab_pop_type"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010abdd",
            "calling": [
                "stab_class_static_method_variant.lto_priv.0",
                "stab_class_method_variant.lto_priv.0"
            ],
            "imported": false,
            "current_name": "update_data_0010abdd"
        },
        "FUN_00115f30": {
            "renaming": {
                "FUN_00115f30": "remove_share_flag_if_not_coff_00115f30",
                "param_1": "flag",
                "param_2": "params",
                "param_3": "outputFormat",
                "uVar1": "value1",
                "uVar2": "errorMessage"
            },
            "code": "\nuint removeShareFlagIfNotCOFF_00115f30(uint flag,undefined8 *params,undefined8 outputFormat)\n\n{\n  undefined8 value1;\n  undefined8 errorMessage;\n  \n  if (((flag & 0x8000000) != 0) && (*(int *)(params[1] + 8) != 2)) {\n    value1 = *params;\n    flag = flag & 0xf7ffffff;\n    errorMessage = dcgettext(0,\"%s[%s]: Note - dropping \\'share\\' flag as output format is not COFF\",5);\n    non_fatal(errorMessage,value1,outputFormat);\n  }\n  return flag;\n}\n\n",
            "called": [
                "check_new_section_flags.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115f30",
            "calling": [
                "setup_section",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "remove_share_flag_if_not_coff_00115f30"
        },
        "FUN_00104880": {
            "renaming": {},
            "code": "\n\n\nchar * strdup(char *__s)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strdup(__s);\n  return pcVar1;\n}\n\n",
            "called": [
                "strdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104880",
            "calling": [
                "add_redefine_and_check"
            ],
            "imported": false,
            "current_name": "FUN_00104880"
        },
        "FUN_001129f4": {
            "renaming": {
                "FUN_001129f4": "get_result_001129f4",
                "param_1": "input",
                "puVar1": "ptr_to_array",
                "piVar2": "current_element"
            },
            "code": "\nundefined8 get_result_001129f4(int *input)\n\n{\n  undefined8 *ptr_to_array;\n  int *current_element;\n  \n  do {\n    if (*input != 1) {\n      if (1 < *input - 0x16U) {\n        return 0;\n      }\n      return *(undefined8 *)(**(long **)(input + 4) + 8);\n    }\n    ptr_to_array = (undefined8 *)(input + 4);\n    current_element = **(int ***)(undefined8 *)*ptr_to_array;\n  } while ((input != current_element) && (input = current_element, current_element != (int *)0x0));\n  return ((undefined8 *)*ptr_to_array)[1];\n}\n\n",
            "called": [
                "debug_get_type_name.constprop.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001129f4",
            "calling": [
                "debug_get_real_type.isra.0",
                "stab_demangle_v3_arg",
                "parse_stab_type",
                "stab_demangle_qualified",
                "debug_get_type_name.constprop.0"
            ],
            "imported": false,
            "current_name": "get_result_001129f4"
        },
        "FUN_001082b3": {
            "renaming": {
                "FUN_001082b3": "invert_and_get_dwo_section_constprop_001082b3",
                "uVar1": "result",
                "is_dwo_section_constprop_0": "get_dwo_section_constprop"
            },
            "code": "\nuint invert_and_get_dwo_section_constprop_001082b3(void)\n\n{\n  uint result;\n  \n  result = get_dwo_section_constprop();\n  return result ^ 1;\n}\n\n",
            "called": [
                "is_dwo_section.constprop.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001082b3",
            "calling": [
                "FUN_0010829e"
            ],
            "imported": false,
            "current_name": "invert_and_get_dwo_section_constprop_001082b3"
        },
        "FUN_00114690": {
            "renaming": {
                "FUN_00114690": "process_binary_file_00114690",
                "param_1": "inputFilePath",
                "param_2": "outputFilePath",
                "param_3": "fileDescriptor",
                "param_4": "statBuf",
                "param_5": "bfdVec",
                "param_6": "fileSize",
                "param_7": "additionalParam",
                "bVar1": "byteVar1",
                "cVar2": "charVar1",
                "cVar3": "charVar2",
                "iVar4": "intVar1",
                "iVar5": "intVar2",
                "ppcVar6": "charPtrPtr1",
                "pvVar7": "voidPtr1",
                "lVar8": "longVar1",
                "puVar9": "undefined8Ptr1",
                "piVar10": "intPtr1",
                "uVar11": "undefined8Var1",
                "uVar12": "undefined8Var2",
                "lVar13": "fileSizeVar",
                "puVar14": "bfdFilePtr",
                "ppcVar16": "charPtrPtr3",
                "pcVar15": "tempDirPath",
                "pcVar17": "tempStr",
                "pcVar18": "concatenatedStr",
                "__ptr": "chunkPtr",
                "ppcVar19": "charPtrPtr4",
                "pcVar20": "functionPtr1",
                "lVar21": "chunkSize",
                "uVar22": "uintVar1",
                "pcVar23": "tempStr2",
                "psVar24": "statPtr",
                "bVar25": "boolVar1",
                "bVar26": "boolVar2",
                "local_1a0": "undefined8Ptr2",
                "local_198": "longPtr1",
                "local_158": "statStruct",
                "local_c8": "voidPtrPtr1",
                "uStack_b0": "uintVar2",
                "lStack_98": "longVar2"
            },
            "code": "\nvoid processBinaryFile_00114690(undefined8 inputFilePath,undefined8 outputFilePath,int fileDescriptor,undefined8 statBuf,\n                 undefined8 bfdVec,long fileSize,undefined8 additionalParam)\n\n{\n  byte byteVar1;\n  char charVar1;\n  char charVar2;\n  int intVar1;\n  int intVar2;\n  char **charPtrPtr1;\n  void *voidPtr1;\n  long longVar1;\n  undefined8 *undefined8Ptr1;\n  int *intPtr1;\n  undefined8 undefined8Var1;\n  undefined8 undefined8Var2;\n  long fileSizeVar;\n  undefined8 *bfdFilePtr;\n  char *tempDirPath;\n  char **charPtrPtr3;\n  char *tempStr;\n  char *concatenatedStr;\n  undefined8 *chunkPtr;\n  char **charPtrPtr4;\n  code *functionPtr1;\n  long chunkSize;\n  uint uintVar1;\n  char *tempStr2;\n  stat *statPtr;\n  bool boolVar1;\n  byte boolVar2;\n  undefined8 *undefined8Ptr2;\n  long *longPtr1;\n  stat statStruct;\n  void *voidPtrPtr1 [3];\n  uint uintVar2;\n  long longVar2;\n  \n  boolVar2 = 0;\n  fileSizeVar = get_file_size();\n  if (fileSizeVar < 1) {\n    if (fileSizeVar == 0) {\n      undefined8Var2 = dcgettext(0,\"error: the input file \\'%s\\' is empty\",5);\n      non_fatal(undefined8Var2,inputFilePath);\n    }\n    status = 1;\n    return;\n  }\n  bfdFilePtr = (undefined8 *)bfd_openr(inputFilePath,bfdVec);\n  if ((bfdFilePtr == (undefined8 *)0x0) || (intVar2 = bfd_stat(bfdFilePtr,statBuf), intVar2 != 0)) {\n    bfd_nonfatal_message(inputFilePath,0,0,0);\n    status = 1;\n    return;\n  }\n  switch(do_debug_sections) {\n  case 1:\n  case 3:\n  case 9:\n    *(uint *)((long)bfdFilePtr + 0x44) = *(uint *)((long)bfdFilePtr + 0x44) | 0x24000;\n    break;\n  case 5:\n    *(uint *)((long)bfdFilePtr + 0x44) = *(uint *)((long)bfdFilePtr + 0x44) | 0x4000;\n    break;\n  case 0x11:\n    *(uint *)((long)bfdFilePtr + 0x44) = *(uint *)((long)bfdFilePtr + 0x44) | 0x424000;\n    break;\n  case 0x20:\n    *(uint *)((long)bfdFilePtr + 0x44) = *(uint *)((long)bfdFilePtr + 0x44) | 0x8000;\n  }\n  if (do_elf_stt_common == 1) {\n    *(uint *)((long)bfdFilePtr + 0x44) = *(uint *)((long)bfdFilePtr + 0x44) | 0xc0000;\n  }\n  else if (do_elf_stt_common == 2) {\n    *(uint *)((long)bfdFilePtr + 0x44) = *(uint *)((long)bfdFilePtr + 0x44) | 0x40000;\n  }\n  charVar1 = bfd_check_format(bfdFilePtr,2);\n  if (charVar1 != '\\0') {\n    if (fileSize == 0) {\n      charVar1 = '\\0';\n      fileSize = *(long *)bfdFilePtr[1];\n    }\n    if (fileDescriptor < 0) {\n      undefined8Ptr2 = (undefined8 *)bfd_openw(outputFilePath,fileSize);\n    }\n    else {\n      undefined8Ptr2 = (undefined8 *)bfd_fdopenw(outputFilePath,fileSize,fileDescriptor);\n    }\n    if (undefined8Ptr2 != (undefined8 *)0x0) {\n      if (gnu_debuglink_filename != 0) {\n        undefined8Var2 = *bfdFilePtr;\n        undefined8Var1 = dcgettext(0,\"--add-gnu-debuglink ignored for archive %s\",5);\n        non_fatal(undefined8Var1,undefined8Var2);\n        gnu_debuglink_filename = 0;\n      }\n      set_long_section_mode(undefined8Ptr2,bfdFilePtr,long_section_names);\n      longPtr1 = undefined8Ptr2 + 0x1f;\n      if ((*(byte *)((long)bfdFilePtr + 0x49) & 0x10) != 0) {\n        status = 1;\n        bfd_set_error(5);\n        undefined8Var2 = dcgettext(0,\"sorry: copying thin archives is not currently supported\",5);\n        bfd_nonfatal_message(0,bfdFilePtr,0,undefined8Var2);\n        return;\n      }\n      tempDirPath = (char *)make_tempdir(*undefined8Ptr2);\n      if (tempDirPath == (char *)0x0) {\n        intPtr1 = __errno_location();\n        tempDirPath = strerror(*intPtr1);\n        undefined8Var2 = dcgettext(0,\"cannot create tempdir for archive copying (error: %s)\",5);\n                    \n        fatal(undefined8Var2,tempDirPath);\n      }\n      if (strip_symbols == 7) {\n        byteVar1 = *(byte *)((long)bfdFilePtr + 0x49);\n        uintVar1 = 0;\n      }\n      else {\n        byteVar1 = *(byte *)((long)bfdFilePtr + 0x49);\n        uintVar1 = byteVar1 >> 3 & 1;\n      }\n      boolVar1 = deterministic != 0;\n      *(byte *)((long)undefined8Ptr2 + 0x49) =\n           byteVar1 & 0x10 | (byte)(uintVar1 << 3) | *(byte *)((long)undefined8Ptr2 + 0x49) & 0xe7;\n      if (boolVar1) {\n        *(uint *)((long)undefined8Ptr2 + 0x44) = *(uint *)((long)undefined8Ptr2 + 0x44) | 0x2000;\n      }\n      chunkPtr = (undefined8 *)0x0;\n      charPtrPtr3 = (char **)bfd_openr_next_archived_file(bfdFilePtr,0);\n      charVar2 = bfd_set_format(undefined8Ptr2,*(byte *)(bfdFilePtr + 9) & 7);\n      if (charVar2 == '\\0') {\n        status = 1;\n        bfd_nonfatal_message(0,undefined8Ptr2,0,0);\n        remove_directory_00114b84();\n        return;\n      }\n      while ((status == 0 && (charPtrPtr3 != (char **)0x0))) {\n        concatenatedStr = *charPtrPtr3;\n        tempStr = concatenatedStr;\n        if (*concatenatedStr == '/') {\nLAB_0010527d:\n          undefined8Var2 = dcgettext(0,\"illegal pathname found in archive member: %s\",5);\n          non_fatal(undefined8Var2,concatenatedStr);\nLAB_00104e93:\n          status = 1;\n          goto LAB_00114b4b;\n        }\n        while (*tempStr != '\\0') {\n          tempStr2 = tempStr;\n          if ((*tempStr == '.') && (tempStr2 = tempStr + 1, tempStr[1] == '.')) {\n            tempStr2 = tempStr + 2;\n            if ((tempStr[2] == '\\0') || (tempStr[2] == '/')) goto LAB_0010527d;\n          }\n          for (; (*tempStr2 != '\\0' && (*tempStr2 != '/')); tempStr2 = tempStr2 + 1) {\n          }\n          tempStr = tempStr2;\n          if (*tempStr2 == '/') {\n            extract_and_copy_archived_files_001052a2();\n            return;\n          }\n        }\n        concatenatedStr = (char *)concat(tempDirPath,&DAT_0011b47d);\n        intVar2 = stat(concatenatedStr,&statStruct);\n        undefined8Ptr1 = chunkPtr;\n        if (-1 < intVar2) {\n          fileSizeVar = make_tempdir(concatenatedStr);\n          free(concatenatedStr);\n          if (fileSizeVar == 0) {\n            intPtr1 = __errno_location();\n            concatenatedStr = strerror(*intPtr1);\n            undefined8Var2 = dcgettext(0,\"cannot create tempdir for archive copying (error: %s)\",5);\n            non_fatal(undefined8Var2,concatenatedStr);\n            goto LAB_00104e93;\n          }\n          undefined8Ptr1 = (undefined8 *)xmalloc(0x18);\n          concatenatedStr = *charPtrPtr3;\n          *undefined8Ptr1 = chunkPtr;\n          undefined8Ptr1[2] = 0;\n          undefined8Ptr1[1] = fileSizeVar;\n          concatenatedStr = (char *)concat(fileSizeVar,&DAT_0011b47d,concatenatedStr);\n        }\n        intVar2 = 0;\n        if (preserve_dates != '\\0') {\n          statPtr = &statStruct;\n          for (fileSizeVar = 0x24; fileSizeVar != 0; fileSizeVar = fileSizeVar + -1) {\n            *(undefined4 *)&statPtr->st_dev = 0;\n            statPtr = (stat *)((long)statPtr + (ulong)boolVar2 * -8 + 4);\n          }\n          charPtrPtr4 = (char **)charPtrPtr3[0x1d];\n          if ((char **)charPtrPtr3[0x1d] == (char **)0x0) {\n            charPtrPtr4 = charPtrPtr3;\n          }\n          intVar2 = (**(code **)(charPtrPtr4[1] + 0x1e8))(charPtrPtr3,&statStruct);\n          if (intVar2 != 0) {\n            tempStr = *charPtrPtr3;\n            undefined8Var2 = dcgettext(0,\"internal stat error on %s\",5);\n            non_fatal(undefined8Var2,tempStr);\n          }\n        }\n        chunkPtr = (undefined8 *)xmalloc(0x18);\n        chunkPtr[1] = concatenatedStr;\n        *chunkPtr = undefined8Ptr1;\n        chunkPtr[2] = 0;\n        charVar2 = bfd_check_format(charPtrPtr3,1);\n        if (charVar2 == '\\0') {\n          undefined8Var2 = dcgettext(0,\"Unable to recognise the format of file\",5);\n          bfd_nonfatal_message(0,charPtrPtr3,0,undefined8Var2);\n          charPtrPtr4 = (char **)bfd_openw(concatenatedStr,fileSize);\n          if (charPtrPtr4 == (char **)0x0) {\nLAB_00104e80:\n            bfd_nonfatal_message(concatenatedStr,0,0,0);\n            goto LAB_00104e93;\n          }\nLAB_00104d75:\n          charPtrPtr1 = (char **)charPtrPtr3[0x1d];\n          if ((char **)charPtrPtr3[0x1d] == (char **)0x0) {\n            charPtrPtr1 = charPtrPtr3;\n          }\n          intVar1 = (**(code **)(charPtrPtr1[1] + 0x1e8))(charPtrPtr3);\n          fileSizeVar = longVar2;\n          if (intVar1 == 0) {\n            if (longVar2 < 0) {\n              bfd_get_archive_filename(charPtrPtr3);\n              undefined8Var2 = dcgettext(0,\"stat returns negative size for `%s\\'\",5);\n              non_fatal(undefined8Var2);\n            }\n            else {\n              intVar1 = bfd_seek(charPtrPtr3,0,0);\n              if (intVar1 == 0) {\n                if (verbose != '\\0') {\n                  tempStr = *charPtrPtr4;\n                  undefined8Var2 = bfd_get_archive_filename(charPtrPtr3);\n                  tempStr2 = (char *)dcgettext(0,\"copy from `%s\\' [unknown] to `%s\\' [unknown]\\n\",5);\n                  printf(tempStr2,undefined8Var2,tempStr);\n                }\n                voidPtr1 = (void *)xmalloc(0x2000);\n                for (; fileSizeVar != 0; fileSizeVar = fileSizeVar - chunkSize) {\n                  chunkSize = 0x2000;\n                  if (fileSizeVar < 0x2001) {\n                    chunkSize = fileSizeVar;\n                  }\n                  longVar1 = bfd_bread(voidPtr1,chunkSize,charPtrPtr3);\n                  charPtrPtr1 = charPtrPtr3;\n                  if ((chunkSize != longVar1) ||\n                     (longVar1 = bfd_bwrite(voidPtr1,chunkSize,charPtrPtr4), charPtrPtr1 = charPtrPtr4,\n                     chunkSize != longVar1)) {\n                    bfd_nonfatal_message(0,charPtrPtr1,0,0);\n                    free(voidPtr1);\n                    goto LAB_00104f00;\n                  }\n                }\n                chmod(*charPtrPtr4,uintVar2 | 0x100);\n                free(voidPtr1);\n                charVar2 = bfd_close_all_done(charPtrPtr4);\n                if (charVar2 == '\\0') {\n                  bfd_nonfatal_message(concatenatedStr,0,0,0);\n                  status = 1;\n                }\n                goto LAB_00114a86;\n              }\n              undefined8Var2 = bfd_get_archive_filename(charPtrPtr3);\n              bfd_nonfatal(undefined8Var2);\n            }\n          }\n          else {\n            bfd_nonfatal_message(0,charPtrPtr3,0,0);\n          }\nLAB_00104f00:\n          charVar2 = bfd_close_all_done(charPtrPtr4);\n          if (charVar2 == '\\0') {\n            bfd_nonfatal_message(concatenatedStr,0,0,0);\n          }\nLAB_00104ec9:\n          unlink(concatenatedStr);\n          status = 1;\n        }\n        else {\n          if (charVar1 == '\\0') {\n            charPtrPtr4 = (char **)bfd_openw(concatenatedStr,*(undefined8 *)charPtrPtr3[1]);\n          }\n          else {\n            charPtrPtr4 = (char **)bfd_openw(concatenatedStr,fileSize);\n          }\n          if (charPtrPtr4 == (char **)0x0) goto LAB_00104e80;\n          charVar2 = copy_object(charPtrPtr3,charPtrPtr4,additionalParam);\n          if (charVar2 == '\\0') {\n            intVar1 = bfd_get_arch(charPtrPtr3);\n            if (intVar1 == 0) goto LAB_00104d75;\n            charVar2 = bfd_close_all_done(charPtrPtr4);\n            if (charVar2 == '\\0') {\n              bfd_nonfatal_message(concatenatedStr,0,0,0);\n            }\n            goto LAB_00104ec9;\n          }\n          charVar2 = bfd_close(charPtrPtr4);\n          if (charVar2 == '\\0') {\n            bfd_nonfatal_message(concatenatedStr,0,0,0);\n            status = 1;\n          }\nLAB_00114a86:\n          if ((preserve_dates != '\\0') && (intVar2 == 0)) {\n            set_times(concatenatedStr,&statStruct);\n          }\n          fileSizeVar = bfd_openr(concatenatedStr,fileSize);\n          chunkPtr[2] = fileSizeVar;\n          *longPtr1 = fileSizeVar;\n          longPtr1 = (long *)(fileSizeVar + 0xf0);\n          charPtrPtr4 = (char **)bfd_openr_next_archived_file(bfdFilePtr);\n          bfd_close(charPtrPtr3);\n          charPtrPtr3 = charPtrPtr4;\n        }\n      }\n      *longPtr1 = 0;\n      voidPtr1 = (void *)xstrdup(*undefined8Ptr2);\n      if (status == 0) {\n        functionPtr1 = bfd_close;\n      }\n      else {\n        functionPtr1 = bfd_close_all_done;\n      }\n      charVar1 = (*functionPtr1)(undefined8Ptr2);\n      if (charVar1 == '\\0') {\n        status = 1;\n        bfd_nonfatal_message(voidPtr1,0,0,0);\n      }\n      free(voidPtr1);\n      voidPtr1 = (void *)xstrdup(*bfdFilePtr);\n      charVar1 = bfd_close(bfdFilePtr);\n      if (charVar1 == '\\0') {\n        status = 1;\n        bfd_nonfatal_message(voidPtr1,0,0,0);\n      }\n      free(voidPtr1);\nLAB_00114b4b:\n      while (chunkPtr != (undefined8 *)0x0) {\n        if (chunkPtr[2] == 0) {\n          rmdir((char *)chunkPtr[1]);\n        }\n        else {\n          bfd_close();\n          unlink((char *)chunkPtr[1]);\n        }\n        free((void *)chunkPtr[1]);\n        bfdFilePtr = (undefined8 *)*chunkPtr;\n        free(chunkPtr);\n        chunkPtr = bfdFilePtr;\n      }\n      rmdir(tempDirPath);\n      free(tempDirPath);\n      return;\n    }\nLAB_00105231:\n    close(fileDescriptor);\n    bfd_nonfatal_message(outputFilePath,0,0,0);\n    status = 1;\n    return;\n  }\n  charVar1 = bfd_check_format_matches(bfdFilePtr,1,voidPtrPtr1);\n  if (charVar1 == '\\0') {\n    intVar2 = bfd_get_error();\n    charVar1 = bfd_check_format_matches(bfdFilePtr,3,&statStruct);\n    if (charVar1 == '\\0') {\n      intVar1 = bfd_get_error();\n      if (intVar2 != intVar1) {\n        bfd_set_error(intVar2);\n      }\n      bfd_nonfatal_message(inputFilePath,0,0,0);\n      if (intVar2 == 0xd) {\n        list_matching_formats(voidPtrPtr1[0]);\n      }\n      if (intVar1 != 0xd) {\n        status = 1;\n        return;\n      }\n      list_matching_formats(statStruct.st_dev);\n      status = 1;\n      return;\n    }\n    if (intVar2 == 0xd) {\n      free(voidPtrPtr1[0]);\n    }\n  }\n  if (fileSize == 0) {\n    fileSize = *(long *)bfdFilePtr[1];\n  }\n  if (fileDescriptor < 0) {\n    fileSizeVar = bfd_openw(outputFilePath,fileSize);\n  }\n  else {\n    fileSizeVar = bfd_fdopenw(outputFilePath,fileSize,fileDescriptor);\n  }\n  if (fileSizeVar == 0) goto LAB_00105231;\n  set_long_section_mode(fileSizeVar,bfdFilePtr,long_section_names);\n  charVar1 = copy_object(bfdFilePtr,fileSizeVar,additionalParam);\n  if (charVar1 == '\\0') {\n    status = 1;\n  }\n  else if (status == 0) {\n    charVar1 = bfd_close(fileSizeVar);\n    goto LAB_001147d5;\n  }\n  charVar1 = bfd_close_all_done(fileSizeVar);\nLAB_001147d5:\n  if (charVar1 != '\\x01') {\n    status = 1;\n    bfd_nonfatal_message(outputFilePath,0,0,0);\n    return;\n  }\n  charVar1 = bfd_close(bfdFilePtr);\n  if (charVar1 == '\\0') {\n    status = 1;\n    bfd_nonfatal_message(inputFilePath,0,0,0);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "bfd_set_error",
                "bfd_check_format_matches",
                "strerror",
                "list_matching_formats",
                "bfd_openr",
                "close",
                "bfd_stat",
                "fatal",
                "dcgettext",
                "get_file_size",
                "bfd_nonfatal_message",
                "bfd_close_all_done",
                "copy_file.cold",
                "non_fatal",
                "bfd_set_format",
                "free",
                "bfd_get_error",
                "copy_object",
                "bfd_fdopenw",
                "bfd_check_format",
                "bfd_openw",
                "bfd_openr_next_archived_file",
                "bfd_close",
                "make_tempdir",
                "__errno_location",
                "set_long_section_mode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114690",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "process_binary_file_00114690"
        },
        "FUN_0010b800": {
            "renaming": {
                "FUN_0010b800": "parse_stab_entry_0010b800",
                "param_1": "base_address",
                "param_2": "size",
                "param_3": "flag",
                "plVar1": "ptr_to_value",
                "uVar2": "result",
                "sVar3": "string_length",
                "lVar4": "temp_value_1",
                "lVar5": "temp_value_2",
                "local_8c": "string_buffer",
                "auStack_8a": "auxiliary_stack"
            },
            "code": "\nundefined8 parse_stab_entry_0010b800(long base_address,int size,char flag)\n\n{\n  long *ptr_to_value;\n  undefined8 result;\n  size_t string_length;\n  long temp_value_1;\n  long temp_value_2;\n  undefined2 string_buffer;\n  undefined4 auxiliary_stack [24];\n  \n  if (size - 1U < 8) {\n    temp_value_1 = base_address + 0xb8;\n    if (flag != '\\0') {\n      temp_value_1 = base_address + 0x78;\n    }\n    ptr_to_value = (long *)(temp_value_1 + (ulong)(size - 1U) * 8);\n    temp_value_1 = *ptr_to_value;\n    if (temp_value_1 != 0) {\n      result = stab_push_defined_type(base_address,temp_value_1,size);\n      return result;\n    }\n    temp_value_1 = *(long *)(base_address + 0x68);\n    *(long *)(base_address + 0x68) = temp_value_1 + 1;\n    *ptr_to_value = temp_value_1;\n    sprintf((char *)&string_buffer,\"%ld=r%ld;\",temp_value_1,temp_value_1);\n    if (flag == '\\0') {\n      temp_value_2 = 1L << ((char)size * '\\b' - 1U & 0x3f);\n      string_length = strlen((char *)&string_buffer);\n      sprintf((char *)((long)&string_buffer + string_length),\"%ld;%ld;\",-temp_value_2,temp_value_2 + -1);\n    }\n    else {\n      string_length = strlen((char *)&string_buffer);\n      *(undefined2 *)((long)&string_buffer + string_length) = 0x3b30;\n      *(undefined *)((long)&string_buffer + string_length + 2) = 0;\n      if (size == 8) {\n        *(undefined4 *)((long)&string_buffer + string_length + 2) = 0x3b312d;\n      }\n      else {\n        sprintf((char *)((long)&string_buffer + string_length + 2),\"%ld;\",\n                (1L << ((char)size * '\\b' & 0x3fU)) + -1);\n      }\n    }\n    result = stab_push_string(base_address,&string_buffer,temp_value_1,1,size);\n  }\n  else {\n    result = dcgettext(0,\"stab_int_type: bad size %u\",5);\n    non_fatal(result,size);\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [
                "strlen",
                "stab_push_string",
                "dcgettext",
                "non_fatal",
                "sprintf",
                "stab_push_defined_type"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010b800",
            "calling": [
                "debug_write_type.constprop.0",
                "stab_float_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "parse_stab_entry_0010b800"
        },
        "FUN_00109ed3": {
            "renaming": {
                "FUN_00109ed3": "parse_and_push_string_00109ed3",
                "param_1": "binaryOffset",
                "param_2": "character",
                "param_3": "formatSpecifier",
                "param_4": "longArray",
                "param_5": "ulongArray",
                "uVar1": "arrayLength",
                "uVar2": "temp",
                "cVar3": "result",
                "pcVar4": "poppedString",
                "sVar5": "stringLength",
                "__s": "formattedString",
                "lVar6": "temp1",
                "__ptr": "allocatedMemory",
                "uVar7": "returnValue",
                "uVar8": "flag",
                "lVar9": "loopCounter",
                "uVar10": "newArrayLength",
                "puVar11": "ptr",
                "bVar12": "booleanValue"
            },
            "code": "\nundefined8 parseAndPushString_00109ed3(long binaryOffset,uint character,undefined4 formatSpecifier,long *longArray,ulong *ulongArray)\n\n{\n  ulong arrayLength;\n  ulong temp;\n  char result;\n  char *poppedString;\n  size_t stringLength;\n  char *formattedString;\n  long temp1;\n  void *allocatedMemory;\n  undefined8 returnValue;\n  undefined flag;\n  long loopCounter;\n  ulong newArrayLength;\n  undefined *ptr;\n  byte booleanValue;\n  \n  booleanValue = 0;\n  temp1 = *(long *)(binaryOffset + 0x60);\n  if (temp1 != 0) {\n    arrayLength = *(ulong *)(temp1 + 0x10);\n    if (((long)arrayLength < 1) || (longArray == (long *)0x0)) {\n      flag = *(undefined *)(temp1 + 0x1c);\n      poppedString = (char *)stab_pop_type(binaryOffset);\n      stringLength = strlen(poppedString);\n      formattedString = (char *)xmalloc(stringLength + 2);\n      sprintf(formattedString,\"%c%s\",(ulong)character,poppedString);\n      free(poppedString);\n      temp1 = 0;\n    }\n    else {\n      newArrayLength = *ulongArray;\n      if (newArrayLength <= arrayLength) {\n        if (newArrayLength == 0) {\n          newArrayLength = 10;\n        }\n        for (; newArrayLength <= arrayLength; newArrayLength = newArrayLength * 2) {\n        }\n        temp1 = xrealloc(*longArray,newArrayLength * 8);\n        temp = *ulongArray;\n        *longArray = temp1;\n        ptr = (undefined *)(temp1 + temp * 8);\n        for (loopCounter = (newArrayLength - temp) * 8; loopCounter != 0; loopCounter = loopCounter + -1) {\n          *ptr = 0;\n          ptr = ptr + (ulong)booleanValue * -2 + 1;\n        }\n        *ulongArray = newArrayLength;\n      }\n      temp1 = *(long *)(*longArray + arrayLength * 8);\n      if ((temp1 != 0) && (*(char *)(*(long *)(binaryOffset + 0x60) + 0x1c) == '\\0')) {\n        allocatedMemory = (void *)stab_pop_type(binaryOffset);\n        free(allocatedMemory);\n        returnValue = stab_push_defined_type(binaryOffset,temp1,formatSpecifier);\n        return returnValue;\n      }\n      temp1 = *(long *)(binaryOffset + 0x68);\n      *(long *)(binaryOffset + 0x68) = temp1 + 1;\n      poppedString = (char *)stab_pop_type(binaryOffset);\n      stringLength = strlen(poppedString);\n      formattedString = (char *)xmalloc(stringLength + 0x14);\n      sprintf(formattedString,\"%ld=%c%s\",temp1,(ulong)character,poppedString);\n      free(poppedString);\n      flag = 1;\n      *(long *)(*longArray + arrayLength * 8) = temp1;\n    }\n    result = stab_push_string(binaryOffset,formattedString,temp1,flag,formatSpecifier);\n    if (result != '\\0') {\n      free(formattedString);\n      return 1;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "strlen",
                "stab_push_string",
                "sprintf",
                "stab_push_defined_type",
                "xrealloc",
                "free",
                "stab_pop_type",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109ed3",
            "calling": [
                "stab_function_type.lto_priv.0",
                "stab_volatile_type.lto_priv.0",
                "stab_const_type.lto_priv.0",
                "stab_pointer_type.lto_priv.0",
                "stab_reference_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "parse_and_push_string_00109ed3"
        },
        "FUN_0010bbd3": {
            "renaming": {
                "FUN_0010bbd3": "initialize_debug_info_0010bbd3",
                "param_1": "debugInfo",
                "param_2": "filename",
                "param_3": "param3",
                "param_4": "param4",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "puVar3": "ptr3",
                "lVar4": "loopCounter",
                "puVar5": "ptr4",
                "pcVar6": "emptyString",
                "bVar7": "flag",
                "auVar8": "result"
            },
            "code": "\nundefined  [16] initializeDebugInfo_0010bbd3(long *debugInfo,char *filename,undefined8 param3,undefined8 param4)\n\n{\n  undefined8 *ptr1;\n  undefined4 *ptr2;\n  undefined4 *ptr3;\n  long loopCounter;\n  undefined4 *ptr4;\n  char *emptyString;\n  byte flag;\n  undefined result [16];\n  \n  flag = 0;\n  emptyString = \"\";\n  if (filename != (char *)0x0) {\n    emptyString = filename;\n  }\n  ptr2 = (undefined4 *)xmalloc(0x18);\n  ptr4 = ptr2;\n  for (loopCounter = 6; loopCounter != 0; loopCounter = loopCounter + -1) {\n    *ptr4 = 0;\n    ptr4 = ptr4 + (ulong)flag * -2 + 1;\n  }\n  *(char **)(ptr2 + 2) = emptyString;\n  ptr3 = (undefined4 *)xmalloc(0x18);\n  debugInfo[2] = (long)ptr2;\n  ptr4 = ptr3;\n  for (loopCounter = 6; loopCounter != 0; loopCounter = loopCounter + -1) {\n    *ptr4 = 0;\n    ptr4 = ptr4 + (ulong)flag * -2 + 1;\n  }\n  ptr1 = (undefined8 *)debugInfo[1];\n  *(undefined4 **)(ptr3 + 2) = ptr2;\n  if (ptr1 == (undefined8 *)0x0) {\n    if (*debugInfo != 0) {\n                    \n      __assert_fail(\"info->units == NULL\",\"../../binutils/debug.c\",699,\"debug_set_filename\");\n    }\n    *debugInfo = (long)ptr3;\n  }\n  else {\n    *ptr1 = ptr3;\n  }\n  debugInfo[1] = (long)ptr3;\n  debugInfo[5] = 0;\n  *(undefined (*) [16])(debugInfo + 3) = ZEXT816(0);\n  result._8_8_ = param4;\n  result._0_8_ = 1;\n  return result;\n}\n\n",
            "called": [
                "__assert_fail",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bbd3",
            "calling": [
                "parse_stab",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "initialize_debug_info_0010bbd3"
        },
        "FUN_00104410": {
            "renaming": {},
            "code": "\n\n\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = read(__fd,__buf,__nbytes);\n  return sVar1;\n}\n\n",
            "called": [
                "read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104410",
            "calling": [
                "simple_copy"
            ],
            "imported": false,
            "current_name": "FUN_00104410"
        },
        "FUN_00114e50": {
            "renaming": {
                "FUN_00114e50": "FUNC_00114e50"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong FUNC_00114e50(undefined8 *param_1,long param_2,long param_3)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  undefined *puVar3;\n  long *plVar4;\n  code *pcVar5;\n  long *plVar6;\n  ulong uVar7;\n  ulong uVar8;\n  char *__s;\n  ushort uVar9;\n  char cVar10;\n  char cVar11;\n  int iVar12;\n  int iVar13;\n  undefined4 uVar14;\n  long *plVar15;\n  long lVar16;\n  undefined8 uVar17;\n  undefined8 uVar18;\n  size_t sVar19;\n  size_t sVar20;\n  char *pcVar21;\n  void *__ptr;\n  void *__ptr_00;\n  ulong uVar22;\n  long lVar23;\n  ulong uVar24;\n  int *piVar25;\n  ulong uVar26;\n  FILE *__s_00;\n  long **pplVar27;\n  uint uVar28;\n  long **__ptr_01;\n  char *pcVar29;\n  undefined8 *puVar30;\n  ulong uVar31;\n  int iVar32;\n  long **pplVar33;\n  char *pcVar34;\n  long lVar35;\n  undefined4 *puVar36;\n  ulong *puVar37;\n  undefined8 *puVar38;\n  uint uVar39;\n  char **ppcVar40;\n  void *pvVar41;\n  undefined **ppuVar42;\n  bool bVar43;\n  byte bVar44;\n  ulong uStack_1f8;\n  ulong local_1f0;\n  undefined4 *puStack_1e8;\n  char *pcStack_1d0;\n  int *piStack_1c0;\n  long lStack_190;\n  long lStack_180;\n  char *pcStack_178;\n  long lStack_168;\n  long *plStack_148;\n  ulong uStack_140;\n  long lStack_138;\n  long lStack_130;\n  void *apvStack_128 [2];\n  long lStack_118;\n  ushort uStack_10a;\n  byte bStack_108;\n  byte bStack_107;\n  undefined8 uStack_f8;\n  ushort uStack_f0;\n  char *pcStack_c8;\n  ulong uStack_c0;\n  char *pcStack_b8;\n  undefined uStack_b0;\n  short sStack_ae;\n  \n  bVar44 = 0;\n  iVar13 = *(int *)(*(long *)(param_2 + 8) + 0xc);\n  local_1f0._0_1_ =\n       (*(int *)(param_1[1] + 0xc) != iVar13 && *(int *)(param_1[1] + 0xc) != 2) && iVar13 != 2;\n  if ((bool)(char)local_1f0) {\n    uVar18 = bfd_get_archive_filename();\n    uVar17 = dcgettext(0,\"unable to change endianness of \\'%s\\'\",5);\n    non_fatal(uVar17,uVar18);\n    return 0;\n  }\n  if ((*(byte *)((long)param_1 + 0x4a) & 0x20) != 0) {\n    uVar18 = bfd_get_archive_filename();\n    uVar17 = dcgettext(0,\"unable to modify \\'%s\\' due to errors\",5);\n    non_fatal(uVar17,uVar18);\n    return 0;\n  }\n  cVar11 = bfd_set_format(param_2,*(byte *)(param_1 + 9) & 7);\n  if (cVar11 == '\\0') {\n    bfd_nonfatal_message(0,param_2,0,0);\n    return 0;\n  }\n  if (param_1[0x12] == 0) {\n    uVar18 = bfd_get_archive_filename(param_1);\n    uVar17 = dcgettext(0,\"error: the input file \\'%s\\' has no sections\",5);\n    non_fatal(uVar17,uVar18);\n    return 0;\n  }\n  _VerilogDataEndianness = *(undefined4 *)(param_1[1] + 0xc);\n  if (*(int *)(param_1[1] + 8) == 5) {\n    if (verbose != '\\0') {\n      uVar26 = FUNC_00107976();\n      return uVar26;\n    }\n  }\n  else {\n    if ((do_debug_sections != 1) && ((do_debug_sections & 1) != 0)) {\n      uVar18 = bfd_get_archive_filename(param_1);\n      uVar17 = dcgettext(0,\n                         \"--compress-debug-sections=[zlib|zlib-gnu|zlib-gabi|zstd] is unsupported on `%s\\'\"\n                         ,5);\n      non_fatal(uVar17,uVar18);\n      return 0;\n    }\n    if (do_elf_stt_common != 0) {\n      uVar18 = bfd_get_archive_filename(param_1);\n      uVar17 = dcgettext(0,\"--elf-stt-common=[yes|no] is unsupported on `%s\\'\",5);\n      non_fatal(uVar17,uVar18);\n      return 0;\n    }\n    if (verbose != '\\0') {\n      uVar26 = FUNC_00107976();\n      return uVar26;\n    }\n  }\n  if (extract_symbol == '\\0') {\n    if (set_start_set == '\\0') {\n      lVar35 = change_start + param_1[0x17];\n    }\n    else {\n      lVar35 = change_start + set_start;\n    }\n  }\n  else {\n    lVar35 = 0;\n  }\n  if ((*(byte *)(param_2 + 0x48) & 7) == 3) {\n    iVar13 = bfd_get_arch(param_1,lVar35);\n    uVar14 = bfd_get_mach(param_1);\n    if (param_3 != 0) {\n      uVar26 = FUNC_001152b6();\n      return uVar26;\n    }\n    goto LAB_00114f9a;\n  }\n  uVar28 = ~bfd_flags_to_clear & *(uint *)(*(long *)(param_2 + 8) + 0x14) &\n           (bfd_flags_to_set | *(uint *)((long)param_1 + 0x44));\n  if (strip_symbols == 7) {\n    uVar28 = uVar28 & 0xfffffffe;\n    cVar11 = bfd_set_start_address(param_2);\n  }\n  else {\n    cVar11 = bfd_set_start_address(param_2);\n  }\n  if ((cVar11 == '\\0') || (cVar11 = bfd_set_file_flags(param_2,uVar28), cVar11 == '\\0'))\n  goto LAB_00107a82;\n  iVar13 = bfd_get_arch(param_1);\n  uVar14 = bfd_get_mach(param_1);\n  if (param_3 == 0) {\nLAB_00114f9a:\n    if (((iVar13 == 0) && (*(int *)(param_1[1] + 8) != 5)) &&\n       (*(int *)(*(long *)(param_2 + 8) + 8) == 5)) {\n      uVar26 = FUNC_00107880();\n      return uVar26;\n    }\n  }\n  else {\n    if (iVar13 == 0) {\n      iVar13 = *(int *)(param_3 + 0xc);\n      uVar14 = *(undefined4 *)(param_3 + 0x10);\n      goto LAB_00114f9a;\n    }\n    uVar18 = bfd_get_archive_filename(param_1);\n    uVar17 = dcgettext(0,\"Input file `%s\\' ignores binary architecture parameter.\",5);\n    non_fatal(uVar17,uVar18);\n  }\n  cVar11 = (**(code **)(*(long *)(param_2 + 8) + 0x2a0))(param_2,iVar13,uVar14);\n  if (cVar11 == '\\0') {\n    if ((*(byte *)(param_1 + 9) & 0x40) != 0) {\n      iVar13 = bfd_get_arch(param_1);\n      if (iVar13 == 0) {\n        uVar18 = bfd_get_archive_filename(param_1);\n        uVar17 = dcgettext(0,\"Unable to recognise the format of the input file `%s\\'\",5);\n        non_fatal(uVar17,uVar18);\n        return 0;\n      }\n      uVar18 = bfd_get_mach(param_1);\n      uVar14 = bfd_get_arch(param_1);\n      uVar18 = bfd_printable_arch_mach(uVar14,uVar18);\n      uVar17 = dcgettext(0,\"Output file cannot represent architecture `%s\\'\",5);\n      non_fatal(uVar17,uVar18);\n      return 0;\n    }\n    iVar13 = bfd_get_arch(param_1);\n    iVar32 = bfd_get_arch(param_2);\n    if (iVar13 != iVar32) {\n      uVar26 = check_file_format_00105828();\n      return uVar26;\n    }\n  }\n  cVar11 = bfd_set_format(param_2,*(byte *)(param_1 + 9) & 7);\n  if (cVar11 == '\\0') {\nLAB_00107a82:\n    bfd_nonfatal_message(0,param_1,0,0);\n    return 0;\n  }\n  if ((*(int *)(*(undefined8 **)(param_2 + 8) + 1) == 2) &&\n     (cVar11 = startswith_lto_priv_0_lto_priv_0(**(undefined8 **)(param_2 + 8),&DAT_0011b503),\n     cVar11 != '\\0')) {\n    lVar35 = *(long *)(param_2 + 0x110);\n    if ((*(int *)((undefined8 *)param_1[1] + 1) == 2) &&\n       (cVar11 = startswith_lto_priv_0_lto_priv_0(*(undefined8 *)param_1[1],&DAT_0011b503),\n       cVar11 != '\\0')) {\n      lVar16 = param_1[0x22];\n      bVar43 = preserve_dates == '\\0';\n      puVar30 = (undefined8 *)(lVar16 + 200);\n      puVar38 = (undefined8 *)(lVar35 + 200);\n      for (lVar23 = 0x32; lVar23 != 0; lVar23 = lVar23 + -1) {\n        *puVar38 = *puVar30;\n        puVar30 = puVar30 + (ulong)bVar44 * -2 + 1;\n        puVar38 = puVar38 + (ulong)bVar44 * -2 + 1;\n      }\n      if (bVar43) {\n        *(undefined4 *)(lVar35 + 0x2a4) = 0xffffffff;\n      }\n      else {\n        *(int *)(lVar35 + 0x2a4) = (int)*(undefined8 *)(lVar16 + 0xa8);\n      }\n    }\n    uVar26 = pe_file_alignment;\n    if (pe_file_alignment == 0xffffffffffffffff) {\n      pe_file_alignment = 0x200;\n      uVar26 = 0x200;\n    }\n    else {\n      *(int *)(lVar35 + 0x10c) = (int)pe_file_alignment;\n    }\n    if (pe_heap_commit != -1) {\n      *(long *)(lVar35 + 0x148) = pe_heap_commit;\n    }\n    if (pe_heap_reserve != -1) {\n      *(long *)(lVar35 + 0x148) = pe_heap_reserve;\n    }\n    if (pe_image_base != -1) {\n      *(long *)(lVar35 + 0x100) = pe_image_base;\n    }\n    uVar22 = pe_section_alignment;\n    if (pe_section_alignment == 0xffffffffffffffff) {\n      pe_section_alignment = 0x1000;\n      uVar22 = 0x1000;\n    }\n    else {\n      *(int *)(lVar35 + 0x108) = (int)pe_section_alignment;\n    }\n    if (pe_stack_commit != -1) {\n      *(long *)(lVar35 + 0x138) = pe_stack_commit;\n    }\n    if (pe_stack_reserve != -1) {\n      *(long *)(lVar35 + 0x138) = pe_stack_reserve;\n    }\n    if (pe_subsystem != -1) {\n      *(short *)(lVar35 + 300) = pe_subsystem;\n    }\n    if (pe_major_subsystem_version != -1) {\n      *(short *)(lVar35 + 0x118) = pe_major_subsystem_version;\n    }\n    if (pe_minor_subsystem_version != -1) {\n      *(short *)(lVar35 + 0x11a) = pe_minor_subsystem_version;\n    }\n    if (uVar22 < uVar26) {\n      uVar18 = dcgettext(0,\"warning: file alignment (0x%lx) > section alignment (0x%lx)\",5);\n      non_fatal(uVar18,uVar26,uVar22);\n    }\n  }\n  plVar6 = isympp;\n  free(isympp);\n  if (plVar6 == osympp) {\n    isympp = (long *)0x0;\n    osympp = (long *)0x0;\n    lVar35 = (**(code **)(param_1[1] + 0x1f8))(param_1);\n  }\n  else {\n    free(osympp);\n    isympp = (long *)0x0;\n    osympp = (long *)0x0;\n    lVar35 = (**(code **)(param_1[1] + 0x1f8))(param_1);\n  }\n  if (lVar35 < 0) goto LAB_00107a82;\n  osympp = (long *)xmalloc();\n  isympp = osympp;\n  uStack_1f8 = (**(code **)(param_1[1] + 0x200))(param_1,osympp);\n  if ((long)uStack_1f8 < 0) goto LAB_00107a82;\n  if (uStack_1f8 == 0) {\n    free(isympp);\n    isympp = (long *)0x0;\n    osympp = (long *)0x0;\n  }\n  bfd_map_over_sections(param_1,setup_section,param_2);\n  puVar30 = add_sections;\n  if ((extract_symbol == '\\0') &&\n     (cVar11 = (**(code **)(*(long *)(param_2 + 8) + 0x168))(param_1), puVar30 = add_sections,\n     cVar11 == '\\0')) {\n    status = 1;\n    dcgettext(0,\"error in private header data\",5);\n    bfd_nonfatal_message(0,param_1,0);\n    puVar30 = add_sections;\n  }\n  for (; puVar38 = update_sections, puVar30 != (undefined8 *)0x0; puVar30 = (undefined8 *)*puVar30)\n  {\n    uVar28 = 0x128;\n    lVar35 = find_section_list(puVar30[1],0,0x80);\n    if (lVar35 != 0) {\n      uVar28 = check_new_section_flags(*(uint *)(lVar35 + 0x28) | 0x100,param_2,puVar30[1]);\n    }\n    lVar35 = bfd_get_section_by_name(param_2,puVar30[1]);\n    if (lVar35 != 0) {\n      uVar18 = puVar30[1];\n      uVar17 = dcgettext(0,\"can\\'t add section \\'%s\\'\",5);\n      bfd_nonfatal_message(0,param_2,0,uVar17,uVar18);\n      return 0;\n    }\n    lVar35 = bfd_make_section_with_flags(param_2,puVar30[1],uVar28 | 0x100000);\n    puVar30[5] = lVar35;\n    if (lVar35 == 0) {\n      uVar18 = puVar30[1];\n      uVar17 = dcgettext(0,\"can\\'t create section `%s\\'\",5);\n      bfd_nonfatal_message(0,param_2,0,uVar17,uVar18);\n      return 0;\n    }\n    cVar11 = bfd_set_section_size();\n    if (cVar11 == '\\0') {\n      bfd_nonfatal_message(0,param_2,puVar30[5],0);\n      return 0;\n    }\n    lVar35 = find_section_list(puVar30[1],0,0x18);\n    if (lVar35 != 0) {\n      uVar18 = *(undefined8 *)(lVar35 + 0x18);\n      lVar35 = puVar30[5];\n      *(byte *)(lVar35 + 0x28) = *(byte *)(lVar35 + 0x28) | 1;\n      *(undefined8 *)(lVar35 + 0x30) = uVar18;\n      *(undefined8 *)(lVar35 + 0x38) = uVar18;\n    }\n    lVar35 = find_section_list(puVar30[1],0,0x60);\n    if (lVar35 != 0) {\n      lVar16 = puVar30[5];\n      *(undefined8 *)(lVar16 + 0x38) = *(undefined8 *)(lVar35 + 0x20);\n      if (0x3e < *(uint *)(lVar16 + 0x7c)) {\n        bfd_nonfatal_message(0,param_2,lVar16,0);\n        return 0;\n      }\n    }\n  }\n  for (; puVar38 != (undefined8 *)0x0; puVar38 = (undefined8 *)*puVar38) {\n    lVar35 = bfd_get_section_by_name(param_1,puVar38[1]);\n    puVar38[5] = lVar35;\n    if (lVar35 == 0) {\n      uVar18 = puVar38[1];\n      uVar17 = dcgettext(0,\"error: %s not found, can\\'t be updated\",5);\n      non_fatal(uVar17,uVar18);\n      return 0;\n    }\n    uVar18 = *(undefined8 *)(lVar35 + 0x60);\n    cVar11 = bfd_set_section_size(uVar18);\n    if (cVar11 == '\\0') {\n      bfd_nonfatal_message(0,param_2,uVar18,0);\n      return 0;\n    }\n  }\n  puVar30 = dump_sections;\n  if (merge_notes == '\\0') {\n    __ptr_01 = (long **)0x0;\n  }\n  else {\n    pplVar33 = (long **)param_1[0x12];\n    __ptr_01 = pplVar33;\n    if (pplVar33 != (long **)0x0) {\n      __ptr_01 = (long **)0x0;\nLAB_001151ab:\n      if (merge_notes != '\\0') goto LAB_00115187;\n      for (plVar6 = pplVar33[1]; puVar30 = dump_sections, plVar6 != (long *)0x0;\n          plVar6 = (long *)plVar6[1]) {\n      }\n    }\n  }\njoined_r0x001151c7:\n  for (; puVar30 != (undefined8 *)0x0; puVar30 = (undefined8 *)*puVar30) {\n    lVar35 = bfd_get_section_by_name(param_1,puVar30[1]);\n    if (lVar35 == 0) {\n      dcgettext(0,\"can\\'t dump section \\'%s\\' - it does not exist\",5);\n      bfd_nonfatal_message(0,param_1,0);\n    }\n    else if ((*(byte *)(lVar35 + 0x25) & 1) == 0) {\n      dcgettext(0,\"can\\'t dump section - it has no contents\",5);\n      bfd_nonfatal_message(0,param_1,lVar35);\n    }\n    else {\n      sVar19 = *(size_t *)(lVar35 + 0x40);\n      __s_00 = fopen((char *)puVar30[2],\"w\");\n      if (__s_00 == (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        bfd_nonfatal_message(puVar30[2],0,0);\n      }\n      else {\n        cVar11 = bfd_malloc_and_get_section(param_1,lVar35,&pcStack_c8);\n        if (cVar11 == '\\0') {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          bfd_nonfatal_message(0,param_1,lVar35);\n        }\n        else if ((sVar19 != 0) && (sVar20 = fwrite(pcStack_c8,1,sVar19,__s_00), sVar20 != sVar19)) {\n          piVar25 = __errno_location();\n          pcVar34 = strerror(*piVar25);\n          uVar18 = puVar30[2];\n          uVar17 = dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          non_fatal(uVar17,uVar18,pcVar34);\n          free(pcStack_c8);\n          fclose(__s_00);\n          return 0;\n        }\n        fclose(__s_00);\n        free(pcStack_c8);\n      }\n    }\n  }\n  if (gnu_debuglink_filename == 0) {\nLAB_0010790a:\n    lStack_190 = 0;\n  }\n  else {\n    lVar35 = bfd_get_section_by_name(param_2,\".gnu_debuglink\");\n    if (lVar35 != 0) {\n      uVar18 = dcgettext(0,\"%s: debuglink section already exists\",5);\n      non_fatal(uVar18);\n      gnu_debuglink_filename = 0;\n      goto LAB_0010790a;\n    }\n    lStack_190 = bfd_create_gnu_debuglink_section(param_2);\n    lVar35 = gnu_debuglink_filename;\n    if (lStack_190 == 0) {\n      uVar18 = dcgettext(0,\"cannot create debug link section `%s\\'\",5);\n      bfd_nonfatal_message(0,param_2,0,uVar18,lVar35);\n      return 0;\n    }\n    if (*(int *)(*(long *)(param_2 + 8) + 8) == 2) {\n      uVar22 = 0;\n      for (uVar26 = *(ulong *)(param_2 + 0x90); uVar26 != 0; uVar26 = *(ulong *)(uVar26 + 8)) {\n        uVar24 = *(ulong *)(uVar26 + 0x30);\n        uVar31 = uVar22;\n        uVar7 = uVar26;\n        uVar8 = uVar22;\n        if (uVar24 != 0) {\n          while ((uVar31 = uVar7, uVar8 != 0 &&\n                 (uVar31 = uVar26, uVar24 <= *(ulong *)(uVar22 + 0x30)))) {\n            uVar26 = *(ulong *)(uVar26 + 8);\n            if (uVar26 == 0) goto LAB_00107db8;\n            uVar24 = *(ulong *)(uVar26 + 0x30);\n            uVar7 = uVar22;\n            uVar8 = uVar24;\n          }\n        }\n        uVar22 = uVar31;\n      }\nLAB_00107db8:\n      if (uVar22 == 0) {\n        uVar26 = 0x1000;\n      }\n      else {\n        uVar22 = *(long *)(uVar22 + 0x40) + *(long *)(uVar22 + 0x30);\n        uVar26 = 0xffffffffffffffff;\n        if (uVar22 < 0xfffffffffffff001) {\n          uVar26 = uVar22 + 0xfff & 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(lStack_190 + 0x28) = *(byte *)(lStack_190 + 0x28) | 1;\n      *(ulong *)(lStack_190 + 0x30) = uVar26;\n      *(ulong *)(lStack_190 + 0x38) = uVar26;\n    }\n  }\n  plVar6 = isympp;\n  if (*(int *)(param_2 + 0xa0) != 0) {\n    uVar26 = improve_and_reverse_0010554f();\n    return uVar26;\n  }\n  if (convert_debugging == '\\0') {\nLAB_00105588:\n    puStack_1e8 = (undefined4 *)0x0;\n  }\n  else {\n    ppuVar42 = &names_0;\n    puStack_1e8 = (undefined4 *)xmalloc(0x60);\n    puVar36 = puStack_1e8;\n    for (lVar35 = 0x18; lVar35 != 0; lVar35 = lVar35 + -1) {\n      *puVar36 = 0;\n      puVar36 = puVar36 + (ulong)bVar44 * -2 + 1;\n    }\n    pcStack_1d0 = (char *)0x0;\n    do {\n      puVar3 = *ppuVar42;\n      lVar35 = bfd_get_section_by_name(param_1,puVar3);\n      lVar16 = bfd_get_section_by_name();\n      if ((lVar35 != 0) && (lVar16 != 0)) {\n        lVar23 = *(long *)(lVar35 + 0x40);\n        __ptr = (void *)xmalloc(lVar23);\n        cVar11 = bfd_get_section_contents(param_1,lVar35,__ptr,0,lVar23);\n        if (cVar11 == '\\0') {\n          uVar14 = bfd_get_error();\n          bfd_errmsg(uVar14);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*param_1);\n          free(pcStack_1d0);\n          free(__ptr);\n        }\n        else {\n          uVar26 = *(ulong *)(lVar16 + 0x40);\n          __ptr_00 = (void *)xmalloc(uVar26 + 1);\n          local_1f0._0_1_ = bfd_get_section_contents(param_1,lVar16,__ptr_00,0);\n          if ((char)local_1f0 == '\\0') {\n            uVar14 = bfd_get_error();\n            bfd_errmsg(uVar14);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*param_1);\n            free(pcStack_1d0);\n          }\n          else {\n            *(undefined *)((long)__ptr_00 + uVar26) = 0;\n            if ((pcStack_1d0 != (char *)0x0) ||\n               (pcStack_1d0 = (char *)start_stab_constprop_0(param_1,1,plVar6),\n               pcStack_1d0 != (char *)0x0)) {\n              lStack_168 = 0;\n              lStack_180 = 0;\n              for (pvVar41 = __ptr; pvVar41 <= (void *)((long)__ptr + lVar23 + -0xc);\n                  pvVar41 = (void *)((long)pvVar41 + 0xc)) {\n                uVar22 = (**(code **)(param_1[1] + 0x40))(pvVar41);\n                bVar2 = *(byte *)((long)pvVar41 + 4);\n                uVar14 = (**(code **)(param_1[1] + 0x58))((long)pvVar41 + 6);\n                lVar35 = (**(code **)(param_1[1] + 0x40))((long)pvVar41 + 8);\n                if (bVar2 == 0) {\n                  lStack_180 = lStack_168;\n                  lStack_168 = lStack_168 + lVar35;\n                }\n                else {\n                  uVar24 = (uVar22 & 0xffffffff) + lStack_180;\n                  if (uVar24 < uVar26) {\n                    pcVar34 = (char *)((long)__ptr_00 + uVar24);\n                    pcStack_178 = (char *)0x0;\n                    while( true ) {\n                      sVar19 = strlen(pcVar34);\n                      if (((sVar19 == 0) || (pcVar29 = pcVar34 + (sVar19 - 1), *pcVar29 != '\\\\')) ||\n                         ((ulong)((long)__ptr + lVar23) < (long)pvVar41 + 0x10U)) goto LAB_001077fb;\n                      *pcVar29 = '\\0';\n                      pvVar41 = (void *)((long)pvVar41 + 0xc);\n                      iVar13 = (**(code **)(param_1[1] + 0x40))(pvVar41);\n                      uVar22 = (ulong)(uint)(iVar13 + (int)lStack_180);\n                      if (uVar26 <= uVar22) break;\n                      pcVar34 = (char *)concat(pcVar34,(long)__ptr_00 + uVar22,0);\n                      *pcVar29 = '\\\\';\n                      free(pcStack_178);\n                      pcStack_178 = pcVar34;\n                    }\n                    uVar18 = *param_1;\n                    pcVar29 = (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar29,uVar18,puVar3,((long)pvVar41 - (long)__ptr) / 0xc);\nLAB_001077fb:\n                    save_stab((ulong)bVar2,uVar14,lVar35,pcVar34);\n                    cVar11 = parse_stab(puStack_1e8,pcStack_1d0,bVar2);\n                    if (cVar11 == '\\0') {\n                      stab_context();\n                      free_saved_stabs();\n                      free(pcStack_178);\n                      free(pcStack_1d0);\n                      free(__ptr);\n                      free(__ptr_00);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar18 = *param_1;\n                    pcVar34 = (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar34,uVar18,puVar3,((long)pvVar41 - (long)__ptr) / 0xc,\n                            uVar22 & 0xffffffff,(ulong)bVar2,((long)pvVar41 - (long)__ptr) % 0xc);\n                  }\n                }\n              }\n              free_saved_stabs();\n              free(__ptr);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_00);\n          free(__ptr);\n        }\n        goto LAB_00105981;\n      }\nLAB_001058eb:\n      ppuVar42 = ppuVar42 + 2;\n    } while (ppuVar42 != (undefined **)&DAT_00125c90);\n    if ((pcStack_1d0 != (char *)0x0) && (cVar11 = finish_stab(), cVar11 == '\\0')) {\nLAB_00105981:\n      free(puStack_1e8);\n      goto LAB_00105588;\n    }\n    if (*(int *)(param_1[1] + 8) == 1) {\n      lVar35 = 0;\n      for (plVar15 = plVar6; plVar15 < plVar6 + uStack_1f8; plVar15 = plVar15 + 1) {\n        (**(code **)(param_1[1] + 0x218))(param_1,*plVar15,&pcStack_c8);\n        if ((char)uStack_c0 == '-') {\n          if (((lVar35 == 0) && (lVar35 = start_stab_constprop_0(param_1,0,plVar6), lVar35 == 0)) ||\n             ((pcStack_b8 == (char *)0x0 || (*pcStack_b8 == '\\0')))) goto LAB_00105981;\n          pcVar34 = (char *)0x0;\n          pcVar29 = pcStack_b8;\n          while (((*pcVar29 != '\\0' && (sVar19 = strlen(pcVar29), pcVar29[sVar19 - 1] == '\\\\')) &&\n                 (plVar15 + 1 < plVar6 + uStack_1f8))) {\n            pcVar21 = (char *)xstrdup(pcVar29);\n            sVar19 = strlen(pcVar21);\n            pcVar21[sVar19 - 1] = '\\0';\n            pcVar29 = (char *)concat(pcVar21,*(undefined8 *)(plVar15[1] + 8),0);\n            free(pcVar21);\n            free(pcVar34);\n            plVar15 = plVar15 + 1;\n            pcVar34 = pcVar29;\n          }\n          save_stab(uStack_b0,(int)sStack_ae,pcStack_c8,pcVar29);\n          local_1f0._0_1_ = parse_stab(puStack_1e8,lVar35,uStack_b0);\n          if ((char)local_1f0 == '\\0') {\n            stab_context();\n            free_saved_stabs();\n            goto LAB_00105981;\n          }\n        }\n      }\n      free_saved_stabs();\n      if ((lVar35 != 0) && (cVar11 = finish_stab(), cVar11 == '\\0')) goto LAB_00105981;\n    }\n    if ((char)local_1f0 == '\\0') {\n      if ((*(int *)(param_1[1] + 8) == 2) && (uStack_1f8 != 0)) {\n        pcStack_c8 = (char *)0x0;\n        plStack_148 = plVar6;\n        lStack_138 = 0;\n        lStack_130 = 0;\n        puVar37 = &uStack_c0;\n        for (lVar35 = 0x22; lVar35 != 0; lVar35 = lVar35 + -1) {\n          *(undefined4 *)puVar37 = 0;\n          puVar37 = (ulong *)((long)puVar37 + (ulong)bVar44 * -8 + 4);\n        }\n        cVar11 = '\\0';\n        piStack_1c0 = (int *)0x0;\n        uVar28 = 0;\n        pcStack_1d0 = (char *)0x0;\n        pcStack_178 = (char *)0xffffffffffffffff;\n        uStack_140 = uStack_1f8;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((long)uStack_1f8 <= lStack_138) goto LAB_00105590;\n            lVar35 = plVar6[lStack_138];\n            cVar10 = bfd_coff_get_syment(param_1,lVar35,apvStack_128);\n            lVar16 = lStack_130;\n            if (cVar10 == '\\0') {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar34 = \"bfd_coff_get_syment failed: %s\";\n              goto LAB_00105968;\n            }\n            pcVar34 = *(char **)(lVar35 + 8);\n            puVar30 = (undefined8 *)0x0;\n            lStack_138 = lStack_138 + 1;\n            lStack_130 = (ulong)bStack_107 + 1 + lStack_130;\n            if (bStack_107 != 0) {\n              puVar30 = &uStack_f8;\n              cVar10 = bfd_coff_get_auxent(param_1,lVar35,0);\n              if (cVar10 == '\\0') {\n                uVar14 = bfd_get_error();\n                bfd_errmsg(uVar14);\n                pcVar34 = \"bfd_coff_get_auxent failed: %s\";\n                goto LAB_00105968;\n              }\n            }\n            if (pcStack_178 != (char *)lVar16) break;\n            if (bStack_108 != 0x67) {\n              cVar10 = debug_set_filename(puStack_1e8);\n              if (cVar10 != '\\0') break;\n              goto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            pcStack_178 = (char *)lStack_118;\n            cVar10 = debug_set_filename(puStack_1e8);\n            if (cVar10 == '\\0') goto LAB_00105981;\n          }\n          uVar9 = uStack_10a;\n          if ((char)bStack_108 < '\\0') {\n            if (bStack_108 == 0xff) goto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            lVar23 = parse_coff_type_lto_priv_0(param_1,&plStack_148,&pcStack_c8);\n            if (lVar23 == 0) break;\n            cVar10 = parse_coff_symbol_constprop_0_isra_0(&pcStack_c8,lVar35,lVar16);\n          }\n          else {\n            if (bStack_108 < 100) {\n              switch(bStack_108) {\n              case 3:\n                if (uStack_10a == 0) goto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulong)((uint)uStack_10a & *(uint *)(param_1[0x22] + 0x40)) !=\n                    2L << ((byte)*(undefined4 *)(param_1[0x22] + 0x3c) & 0x3f)) goto LAB_0010700a;\n                piStack_1c0 = (int *)(**(code **)(param_1[1] + 0x238))(param_1);\n                uVar28 = (uint)uVar9;\n                pcStack_1d0 = pcVar34;\n                goto switchD_00106e1a_caseD_68;\n              default:\n                goto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                goto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(bStack_108) {\n            case 100:\n              iVar13 = strcmp(pcVar34,\".bb\");\n              if (iVar13 == 0) {\n                cVar10 = debug_start_block(puStack_1e8);\n              }\n              else {\n                iVar13 = strcmp(pcVar34,\".eb\");\n                if (iVar13 != 0) goto switchD_00106e1a_caseD_68;\n                cVar10 = debug_end_block(puStack_1e8);\n              }\n              break;\n            case 0x65:\n              iVar13 = strcmp(pcVar34,\".bf\");\n              if (iVar13 == 0) {\n                if (pcStack_1d0 != (char *)0x0) {\n                  uVar39 = (int)uVar28 >> ((byte)*(undefined4 *)(param_1[0x22] + 0x44) & 0x1f);\n                  lVar16 = parse_coff_type_lto_priv_0\n                                     (param_1,&plStack_148,&pcStack_c8,lVar16,\n                                      uVar39 ^ (uVar28 ^ uVar39) & *(uint *)(param_1[0x22] + 0x38),\n                                      puVar30,0,puStack_1e8);\n                  if ((lVar16 == 0) || (cVar11 = debug_record_function(puStack_1e8), cVar11 == '\\0')\n                     ) goto LAB_00105981;\n                  if (piStack_1c0 != (int *)0x0) {\n                    iVar13 = 0;\n                    if (bStack_107 != 0) {\n                      iVar13 = uStack_f0 - 1;\n                    }\n                    lVar35 = *(long *)(*(long *)(lVar35 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar32 = piStack_1c0[4];\n                      if (iVar32 == 0) break;\n                      cVar10 = debug_record_line(puStack_1e8,iVar13 + iVar32,\n                                                 *(long *)(piStack_1c0 + 6) + lVar35);\n                      piStack_1c0 = piStack_1c0 + 4;\n                      if (cVar10 == '\\0') goto LAB_00105981;\n                    }\n                  }\n                  uVar28 = 0;\n                  piStack_1c0 = (int *)0x0;\n                  pcStack_1d0 = (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar34 = \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar13 = strcmp(pcVar34,\".ef\");\n                if (iVar13 != 0) goto switchD_00106e1a_caseD_68;\n                if (cVar11 != '\\0') {\n                  cVar11 = debug_end_function(puStack_1e8);\n                  if (cVar11 == '\\0') goto LAB_00105981;\n                  cVar11 = '\\0';\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar34 = \"%ld: unexpected .ef\\n\";\n              }\n              uVar18 = dcgettext(0,pcVar34,5);\n              non_fatal(uVar18);\n              goto LAB_00105981;\n            default:\n              goto LAB_0010700a;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (cVar10 != '\\0');\n      }\n      else {\n        pcVar34 = \"%s: no recognized debugging information\";\nLAB_00105968:\n        uVar18 = dcgettext(0,pcVar34,5);\n        non_fatal(uVar18);\n      }\n      goto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)(param_2 + 0x44) & 0x42) != 0) && ((*(uint *)(param_2 + 0x44) & 1) == 0)) {\n    if ((*(char *)(*(long *)(param_2 + 8) + 0x20) == '\\0') && (keep_section_symbols == '\\0')) {\n      if (uStack_1f8 != 0) {\n        plVar6 = isympp + uStack_1f8;\n        plVar15 = isympp;\n        do {\n          uVar28 = *(uint *)(*plVar15 + 0x18);\n          if ((uVar28 & 0x1000000) != 0) {\n            *(uint *)(*plVar15 + 0x18) = uVar28 & 0xfeffffff;\n          }\n          plVar15 = plVar15 + 1;\n        } while (plVar6 != plVar15);\n      }\n    }\n    else {\n      for (lVar35 = *(long *)(param_2 + 0x90); lVar35 != 0; lVar35 = *(long *)(lVar35 + 8)) {\n        if (*(long *)(lVar35 + 0xe8) != 0) {\n          puVar1 = (uint *)(*(long *)(lVar35 + 0xe8) + 0x18);\n          *puVar1 = *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((strip_symbols == 2) || (strip_symbols == 7)) {\nLAB_001059fe:\n    if (strip_symbols == 7) {\nLAB_00105a3b:\n      plVar15 = (long *)xmalloc();\n      plVar6 = isympp;\n      piStack_1c0._0_4_ = *(uint *)((long)param_1 + 0x44) & 0x42;\n      osympp = plVar15;\n      if (uStack_1f8 == 0) {\n        uVar26 = 0;\n      }\n      else {\n        uVar26 = 0;\n        local_1f0 = 0;\n        do {\n          iVar13 = add_symbols;\n          plVar4 = (long *)plVar6[local_1f0];\n          pcVar5 = (code *)plVar4[4];\n          uVar28 = *(uint *)(plVar4 + 3);\n          pcVar34 = (char *)plVar4[1];\n          pcVar29 = pcVar34;\n          if (add_sym_list != (undefined8 *)0x0) {\n            iVar32 = 0;\n            puVar30 = add_sym_list;\n            while ((iVar32 < iVar13 && (pcVar21 = (char *)puVar30[5], pcVar21 != (char *)0x0))) {\n              if (pcVar21 != \"\") {\n                iVar12 = strcmp(pcVar21,pcVar34);\n                if (iVar12 == 0) {\n                  free(pcVar21);\n                  uVar22 = uVar26 + 1;\n                  puVar30[5] = \"\";\n                  lVar35 = create_new_symbol(puVar30);\n                  uVar18 = redefine_specific_htab;\n                  plVar15[uVar26] = lVar35;\n                  lVar35 = htab_elements(uVar18);\n                  if ((lVar35 != 0) || (section_rename_list != (char **)0x0)) goto LAB_001064eb;\n                  goto LAB_00105af8;\n                }\n                puVar30 = (undefined8 *)*puVar30;\n              }\n              iVar32 = iVar32 + 1;\n            }\n          }\n          lVar35 = htab_elements(redefine_specific_htab);\n          uVar22 = uVar26;\n          if ((lVar35 != 0) || (section_rename_list != (char **)0x0)) {\n            if (pcVar34 != (char *)0x0) {\nLAB_001064eb:\n              if (((*pcVar34 == '_') && (pcVar34[1] == '_')) &&\n                 (iVar13 = strcmp(pcVar34 + (pcVar34[2] == '_'),\"__gnu_lto_slim\"), iVar13 == 0)) {\n                uVar18 = dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\"\n                                   ,5);\n                    \n                fatal(uVar18);\n              }\n            }\n            uStack_c0 = 0;\n            pcStack_c8 = pcVar34;\n            lVar35 = htab_find(redefine_specific_htab);\n            if (((lVar35 == 0) || (pcVar29 = *(char **)(lVar35 + 8), pcVar34 == pcVar29)) &&\n               (pcVar29 = pcVar34, ppcVar40 = section_rename_list, (uVar28 & 0x100) != 0)) {\n              for (; ppcVar40 != (char **)0x0; ppcVar40 = (char **)ppcVar40[3]) {\n                iVar13 = strcmp(*ppcVar40,pcVar34);\n                if (iVar13 == 0) {\n                  pcVar29 = ppcVar40[1];\n                  break;\n                }\n              }\n            }\n            plVar4[1] = (long)pcVar29;\n            cVar11 = *pcVar29;\n            if (cVar11 != '\\0') goto LAB_00105b11;\nLAB_00106557:\n            pcVar34 = prefix_symbols_string;\n            if ((change_leading_char != '\\0') && (*(char *)(*(long *)(param_2 + 8) + 0x1c) != '\\0'))\n            {\n              lVar35 = param_1[1];\n              cVar11 = '\\0';\n              goto LAB_0010668d;\n            }\n            goto joined_r0x00106565;\n          }\nLAB_00105af8:\n          cVar11 = *pcVar34;\n          if (cVar11 == '\\0') goto LAB_00106557;\nLAB_00105b11:\n          pcVar34 = prefix_symbols_string;\n          lVar35 = param_1[1];\n          if (*(char *)(lVar35 + 0x1c) == cVar11) {\n            if (change_leading_char == '\\0') {\n              if ((remove_leading_char == '\\0') ||\n                 ((((uVar28 & 0x82) == 0 && (pcVar5 != bfd_map_over_sections)) &&\n                  ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n              pcVar29 = pcVar29 + 1;\n              plVar4[1] = (long)pcVar29;\n              goto joined_r0x00106565;\n            }\n            cVar11 = *(char *)(*(long *)(param_2 + 8) + 0x1c);\n            if (cVar11 == '\\0') goto LAB_0010677d;\n            if (prefix_symbols_string != (char *)0x0) {\n              pcVar29 = pcVar29 + 1;\n              plVar4[1] = (long)pcVar29;\n              sVar19 = strlen(pcVar29);\n              lVar35 = sVar19 + 2;\nLAB_001066bc:\n              sVar19 = strlen(pcVar34);\n              pcVar34 = (char *)xmalloc(sVar19 + lVar35);\n              goto LAB_001066d0;\n            }\n            *pcVar29 = cVar11;\n            plVar4[1] = (long)pcVar29;\n            uVar26 = uVar22;\n          }\n          else {\n            if ((change_leading_char == '\\0') || (*(char *)(*(long *)(param_2 + 8) + 0x1c) == '\\0'))\n            {\njoined_r0x00106565:\n              uVar26 = uVar22;\n              if (pcVar34 == (char *)0x0) goto LAB_00105b32;\n              sVar19 = strlen(pcVar29);\n              sVar20 = strlen(pcVar34);\n              pcVar21 = (char *)xmalloc(sVar20 + sVar19 + 1);\n              pcVar34 = pcVar21;\n            }\n            else {\nLAB_0010668d:\n              pcVar34 = prefix_symbols_string;\n              if ((*(char *)(lVar35 + 0x1c) != '\\0') && (cVar11 != *(char *)(lVar35 + 0x1c)))\n              goto joined_r0x00106565;\n              sVar19 = strlen(pcVar29);\n              lVar35 = sVar19 + 2;\n              if (pcVar34 != (char *)0x0) goto LAB_001066bc;\n              pcVar34 = (char *)xmalloc(lVar35);\nLAB_001066d0:\n              pcVar21 = pcVar34 + 1;\n              *pcVar34 = *(char *)(*(long *)(param_2 + 8) + 0x1c);\n            }\n            __s = prefix_symbols_string;\n            if (prefix_symbols_string != (char *)0x0) {\n              strcpy(pcVar21,prefix_symbols_string);\n              sVar19 = strlen(__s);\n              pcVar21 = pcVar21 + sVar19;\n            }\n            strcpy(pcVar21,pcVar29);\n            plVar4[1] = (long)pcVar34;\n            pcVar29 = pcVar34;\n            uVar26 = uVar22;\n          }\nLAB_00105b32:\n          if (strip_symbols == 7) goto LAB_001067a8;\n          if (((uVar28 & 0x20) == 0) &&\n             (((uVar28 & 0x100) == 0 ||\n              ((*(byte *)(**(long **)(plVar4[4] + 0xf0) + 0x18) & 0x20) == 0)))) {\n            if ((((uint)piStack_1c0 == 0) &&\n                (((uVar28 & 0x82) != 0 || ((*(byte *)(plVar4[4] + 0x25) & 0x10) != 0)))) ||\n               (iVar13 = bfd_decode_symclass(plVar4), iVar13 == 0x49)) {\nLAB_00105be2:\n              if (wildcard == '\\0') {\n                lVar35 = htab_find();\n                if (lVar35 == 0) goto LAB_00105c07;\n              }\n              else {\n                uStack_c0 = uStack_c0 & 0xffffffffffffff00;\n                pcStack_c8 = pcVar29;\n                htab_traverse(strip_specific_htab,is_specified_symbol_predicate,&pcStack_c8);\n                if ((char)uStack_c0 == '\\0') goto LAB_00105c07;\n              }\n            }\n            else if ((((uVar28 & 0x82) == 0) && (pcVar5 != bfd_map_over_sections)) &&\n                    ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)) {\n              if ((uVar28 & 4) == 0) {\n                if (((*(int *)(param_1[1] + 8) != 2) ||\n                    (lVar35 = *(long *)(plVar4[4] + 0xd0), lVar35 == 0)) ||\n                   (*(long *)(lVar35 + 0x40) == 0)) {\n                  if ((strip_symbols == 3) || (discard_locals == 2)) goto LAB_001067a8;\n                  if (discard_locals == 1) {\n                    cVar11 = bfd_is_local_label(param_1);\n                    goto joined_r0x00106a11;\n                  }\n                }\n                goto LAB_00105be2;\n              }\n              cVar11 = convert_debugging;\n              if (1 < strip_symbols - 2U) {\njoined_r0x00106a11:\n                if (cVar11 == '\\0') goto LAB_00105be2;\n              }\n            }\n            else if (strip_symbols != 3) goto LAB_00105be2;\n            goto LAB_001067a8;\n          }\n          if (wildcard == '\\0') {\n            lVar35 = htab_find();\n            if (lVar35 != 0) {\nLAB_0010687f:\n              uVar18 = dcgettext(0,\"not stripping symbol `%s\\' because it is named in a relocation\",\n                                 5);\n              non_fatal(uVar18);\n              status = 1;\n            }\n          }\n          else {\n            uStack_c0 = uStack_c0 & 0xffffffffffffff00;\n            pcStack_c8 = pcVar29;\n            htab_traverse(strip_specific_htab,is_specified_symbol_predicate,&pcStack_c8);\n            if ((char)uStack_c0 != '\\0') goto LAB_0010687f;\n          }\n          if ((uVar28 & 0x20) == 0) {\nLAB_00105c07:\n            if (wildcard != '\\0') {\n              uStack_c0 = uStack_c0 & 0xffffffffffffff00;\n              pcStack_c8 = pcVar29;\n              htab_traverse(strip_unneeded_htab,is_specified_symbol_predicate,&pcStack_c8);\n              if ((char)uStack_c0 != '\\0') goto LAB_001067a8;\n              goto LAB_00105c2c;\n            }\n            lVar35 = htab_find();\n            if (lVar35 == 0) goto LAB_00105c2c;\nLAB_001067a8:\n            if ((keep_file_symbols != '\\0') && ((uVar28 & 0x4000) != 0)) goto LAB_00105c2c;\n            if (wildcard == '\\0') {\n              lVar35 = htab_find();\n              if (lVar35 != 0) goto LAB_00105c2c;\n            }\n            else {\n              uStack_c0 = uStack_c0 & 0xffffffffffffff00;\n              pcStack_c8 = pcVar29;\n              htab_traverse(keep_specific_htab,is_specified_symbol_predicate,&pcStack_c8);\n              if ((char)uStack_c0 != '\\0') goto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            cVar11 = is_strip_section_isra_0(plVar4[4]);\n            if (cVar11 == '\\0') {\n              if (((uVar28 & 0x800002) == 0) && (pcVar5 != bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uVar28 & 0x82) != 0) {\n                  cVar11 = is_specified_symbol(pcVar29);\n                  if ((cVar11 == '\\0') &&\n                     ((lVar35 = htab_elements(keepglobal_specific_htab), lVar35 == 0 ||\n                      (cVar11 = is_specified_symbol(pcVar29), cVar11 != '\\0')))) {\n                    if (((((localize_hidden == '\\0') ||\n                          (uVar39 = *(uint *)(plVar4 + 3), (uVar39 & 0x200000) != 0)) ||\n                         (lVar35 = *plVar4, lVar35 == 0)) ||\n                        ((*(int *)(*(long *)(lVar35 + 8) + 8) != 5 ||\n                         (*(long *)(lVar35 + 0x110) == 0)))) ||\n                       (1 < (*(byte *)((long)plVar4 + 0x49) & 3) - 1)) goto joined_r0x00105ca2;\n                  }\n                  else {\n                    uVar39 = *(uint *)(plVar4 + 3);\n                  }\n                  *(uint *)(plVar4 + 3) = uVar39 & 0xffffff7d | 1;\n                }\njoined_r0x00105ca2:\n                if (((uVar28 & 1) != 0) && (cVar11 = is_specified_symbol(pcVar29), cVar11 != '\\0'))\n                {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((weaken != '\\0') || (cVar11 = is_specified_symbol(pcVar29), cVar11 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xff7ffffd | 0x80;\n                }\n                if (pcVar5 != bfd_map_over_sections) goto LAB_00105c5f;\n              }\n              plVar15[uVar26] = (long)plVar4;\n              uVar26 = uVar26 + 1;\n            }\n          }\n          local_1f0 = local_1f0 + 1;\n        } while (uStack_1f8 != local_1f0);\n      }\n      if (add_sym_list != (undefined8 *)0x0) {\n        puVar30 = add_sym_list;\n        iVar13 = add_symbols;\n        for (lVar35 = 0; lVar35 < iVar13; lVar35 = lVar35 + 1) {\n          pcVar34 = (char *)puVar30[5];\n          if (pcVar34 == (char *)0x0) {\n            plVar6 = plVar15 + uVar26;\n            uVar26 = uVar26 + 1;\n            lVar16 = create_new_symbol(puVar30,param_2);\n            *plVar6 = lVar16;\n            iVar13 = add_symbols;\n          }\n          else if (pcVar34 != \"\") {\n            uVar18 = dcgettext(0,\"\\'before=%s\\' not found\",5);\n                    \n            fatal(uVar18,pcVar34);\n          }\n          puVar30 = (undefined8 *)*puVar30;\n        }\n      }\n      bVar43 = convert_debugging == '\\0';\n      plVar15[uVar26] = 0;\n      if ((bVar43) || (puStack_1e8 == (undefined4 *)0x0)) {\nLAB_00105cfa:\n        uStack_1f8 = uVar26 & 0xffffffff;\n        goto LAB_00105710;\n      }\n      iVar13 = *(int *)(*(undefined8 **)(param_2 + 8) + 1);\n      if ((iVar13 == 5) || (iVar13 == 2)) {\n        apvStack_128[0] = (void *)0x0;\n        cVar11 = write_stabs_in_sections_debugging_info_constprop_0\n                           (param_2,puStack_1e8,&plStack_148,&uStack_f8,apvStack_128,&pcStack_c8);\n        if (cVar11 != '\\0') {\n          lVar35 = bfd_make_section_with_flags(param_2,\".stab\",0x2108);\n          lVar16 = bfd_make_section_with_flags(param_2,\".stabstr\",0x2108);\n          if ((((lVar35 == 0) || (lVar16 == 0)) ||\n              (cVar11 = bfd_set_section_size(lVar35,uStack_f8), cVar11 == '\\0')) ||\n             (cVar11 = bfd_set_section_size(lVar16,pcStack_c8), cVar11 == '\\0')) {\n            pcVar34 = \"can\\'t create debugging section\";\n          }\n          else {\n            *(undefined4 *)(lVar35 + 0x7c) = 2;\n            *(undefined4 *)(lVar16 + 0x7c) = 0;\n            cVar11 = bfd_set_section_contents(param_2,lVar35,plStack_148,0,uStack_f8);\n            if ((cVar11 != '\\0') &&\n               (cVar11 = bfd_set_section_contents(param_2,lVar16,apvStack_128[0],0,pcStack_c8),\n               cVar11 != '\\0')) {\n              free(puStack_1e8);\n              goto LAB_00105cfa;\n            }\n            pcVar34 = \"can\\'t set debugging section contents\";\n          }\n          uVar18 = dcgettext(0,pcVar34,5);\n          bfd_nonfatal_message(0,param_2,0,uVar18);\n          free(apvStack_128[0]);\n          free(puStack_1e8);\n          goto LAB_00105d96;\n        }\n      }\n      else {\n        uVar18 = **(undefined8 **)(param_2 + 8);\n        uVar17 = dcgettext(0,\"don\\'t know how to write debugging information for %s\",5);\n        bfd_nonfatal_message(0,param_2,0,uVar17,uVar18);\n      }\n      free(puStack_1e8);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections(param_1,mark_symbols_used_in_relocations,isympp);\n      iVar13 = bfd_get_error();\n      if (iVar13 == 0) goto LAB_00105a3b;\n    }\nLAB_00105d96:\n    status = 1;\n  }\n  else {\n    if ((strip_symbols - 3U < 4) || ((discard_locals != 0 || (localize_hidden != '\\0'))))\n    goto LAB_00105a07;\n    lVar35 = htab_elements(strip_specific_htab);\n    if (((lVar35 != 0) ||\n        (((((((lVar35 = htab_elements(keep_specific_htab), lVar35 != 0 ||\n              (lVar35 = htab_elements(localize_specific_htab), lVar35 != 0)) ||\n             (lVar35 = htab_elements(globalize_specific_htab), lVar35 != 0)) ||\n            ((lVar35 = htab_elements(keepglobal_specific_htab), lVar35 != 0 ||\n             (lVar35 = htab_elements(weaken_specific_htab), lVar35 != 0)))) ||\n           (lVar35 = htab_elements(redefine_specific_htab), lVar35 != 0)) ||\n          (((prefix_symbols_string != (char *)0x0 || (sections_removed != '\\0')) ||\n           ((sections_copied != '\\0' ||\n            (((convert_debugging != '\\0' || (change_leading_char != '\\0')) ||\n             (remove_leading_char != '\\0')))))))) ||\n         ((section_rename_list != (char **)0x0 || (weaken != '\\0')))))) || (add_symbols != 0))\n    goto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(param_2,osympp,uStack_1f8 & 0xffffffff);\n    bfd_map_over_sections(param_1,copy_relocations_in_section,param_2);\n    bfd_map_over_sections(param_1,copy_section,param_2);\n    for (puVar30 = add_sections; puVar38 = update_sections, puVar30 != (undefined8 *)0x0;\n        puVar30 = (undefined8 *)*puVar30) {\n      cVar11 = bfd_set_section_contents(param_2,puVar30[5],puVar30[4],0,puVar30[3]);\n      if (cVar11 == '\\0') {\n        bfd_nonfatal_message(0,param_2,puVar30[5],0);\n        return 0;\n      }\n    }\n    for (; puVar38 != (undefined8 *)0x0; puVar38 = (undefined8 *)*puVar38) {\n      uVar18 = *(undefined8 *)(puVar38[5] + 0x60);\n      cVar11 = bfd_set_section_contents(param_2,uVar18,puVar38[4],0,puVar38[3]);\n      if (cVar11 == '\\0') {\n        bfd_nonfatal_message(0,param_2,uVar18,0);\n        return 0;\n      }\n    }\n    if (__ptr_01 == (long **)0x0) {\n      if ((merge_notes != '\\0') && (is_strip == 0)) {\n        uVar18 = *param_1;\n        uVar17 = dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n        non_fatal(uVar17,uVar18);\n      }\n    }\n    else {\n      pplVar33 = (long **)0x0;\n      for (puVar30 = *(undefined8 **)(param_2 + 0x90); puVar30 != (undefined8 *)0x0;\n          puVar30 = (undefined8 *)puVar30[1]) {\n        if (((merge_notes != '\\0') && (*(int *)(*(long *)(param_2 + 8) + 8) == 5)) &&\n           ((*(int *)(puVar30[0x1a] + 4) == 7 &&\n            (cVar11 = startswith_lto_priv_0_lto_priv_0(*puVar30,\".gnu.build.attributes\"),\n            cVar11 != '\\0')))) {\n          if (pplVar33 == (long **)0x0) {\n            pplVar33 = __ptr_01;\n          }\n          pplVar27 = __ptr_01;\n          if ((undefined8 *)(*pplVar33)[0xc] == puVar30) {\nLAB_0010625f:\n            pcVar34 = \"error: failed to merge notes\";\n            if (pplVar33[1] != (long *)0x0) {\n              cVar11 = bfd_set_section_contents(param_2,puVar30,pplVar33[1],0,pplVar33[2]);\n              if (cVar11 == '\\0') {\n                uVar18 = dcgettext(0,\"error: failed to copy merged notes into output\",5);\n                bfd_nonfatal_message(0,param_2,puVar30,uVar18);\n                return 0;\n              }\n              pplVar33 = (long **)pplVar33[3];\n              goto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              pplVar33 = pplVar27;\n              if ((undefined8 *)(*pplVar27)[0xc] == puVar30) goto LAB_0010625f;\n              pplVar33 = (long **)pplVar27[3];\n              pplVar27 = pplVar33;\n            } while (pplVar33 != (long **)0x0);\n            pcVar34 = \"error: failed to locate merged notes\";\n          }\n          uVar18 = dcgettext(0,pcVar34,5);\n          bfd_nonfatal_message(0,param_2,puVar30,uVar18);\n        }\nLAB_001061be:\n      }\n      do {\n        pplVar33 = (long **)__ptr_01[3];\n        free(__ptr_01[1]);\n        free(__ptr_01);\n        __ptr_01 = pplVar33;\n      } while (pplVar33 != (long **)0x0);\n    }\n    if ((gnu_debuglink_filename == 0) ||\n       (cVar11 = bfd_fill_in_gnu_debuglink_section(param_2,lStack_190),\n       lVar35 = gnu_debuglink_filename, cVar11 != '\\0')) {\n      uVar28 = (**(code **)(*(long *)(param_2 + 8) + 0x140))(param_1);\n      uVar26 = (ulong)uVar28;\n      if ((char)uVar28 != '\\0') {\n        if (use_alt_mach_code == 0) {\n          return uVar26;\n        }\n        cVar11 = bfd_alt_mach_code(param_2,use_alt_mach_code & 0xffffffff);\n        uVar22 = use_alt_mach_code;\n        if (cVar11 == '\\0') {\n          uVar18 = dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n          non_fatal(uVar18,uVar22);\n          if (*(int *)(*(long *)(param_2 + 8) + 8) == 5) {\n            uVar18 = dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n            non_fatal(uVar18);\n            *(short *)(*(long *)(param_2 + 0x110) + 0x3a) = (short)use_alt_mach_code;\n            return uVar26;\n          }\n          uVar18 = dcgettext(0,\"ignoring the alternative value\",5);\n          non_fatal(uVar18);\n          return uVar26;\n        }\n        return uVar26;\n      }\n      uVar18 = dcgettext(0,\"error copying private BFD data\",5);\n      bfd_nonfatal_message(0,param_2,0,uVar18);\n    }\n    else {\n      uVar18 = dcgettext(0,\"cannot fill debug link section `%s\\'\",5);\n      bfd_nonfatal_message(0,param_2,0,uVar18,lVar35);\n    }\n  }\n  return 0;\nLAB_00115187:\n  if ((((*(int *)(param_1[1] + 8) == 5) && (*(int *)((long)pplVar33[0x1a] + 4) == 7)) &&\n      (cVar11 = startswith_lto_priv_0_lto_priv_0(*pplVar33), cVar11 != '\\0')) &&\n     ((pplVar33[0xc] != (long *)0x0 && (plVar6 = pplVar33[8], plVar6 != (long *)0x0)))) {\n    pplVar27 = (long **)xmalloc(0x20);\n    pplVar27[1] = (long *)0x0;\n    cVar11 = bfd_get_full_section_contents(param_1,pplVar33,pplVar27 + 1);\n    if (cVar11 == '\\0') {\n      dcgettext(0,\"warning: could not load note section\",5);\n      bfd_nonfatal_message(0,param_1,pplVar33);\n      free(pplVar27);\n    }\n    else {\n      plVar15 = (long *)merge_gnu_build_notes(param_1,pplVar33,plVar6);\n      pplVar27[2] = plVar15;\n      if ((plVar15 == plVar6) || (cVar11 = bfd_set_section_size(pplVar33[0xc]), cVar11 != '\\0')) {\n        pplVar27[3] = (long *)__ptr_01;\n        *pplVar27 = (long *)pplVar33;\n        __ptr_01 = pplVar27;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        bfd_nonfatal_message(0,param_2,pplVar33);\n        free(pplVar27[1]);\n        free(pplVar27);\n      }\n    }\n  }\n  pplVar33 = (long **)pplVar33[1];\n  puVar30 = dump_sections;\n  if (pplVar33 == (long **)0x0) goto joined_r0x001151c7;\n  goto LAB_001151ab;\n}\n\n",
            "called": [
                "non_fatal",
                "dcgettext",
                "FUN_00107976",
                "bfd_set_format",
                "bfd_nonfatal_message",
                "bfd_get_archive_filename"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00114e50",
            "calling": [
                "copy_file",
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "FUNC_00114e50"
        },
        "FUN_00104650": {
            "renaming": {},
            "code": "\nvoid bfd_get_mach(void)\n\n{\n  bfd_get_mach();\n  return;\n}\n\n",
            "called": [
                "bfd_get_mach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104650",
            "calling": [
                "FUN_00105828",
                "FUN_00107976"
            ],
            "imported": false,
            "current_name": "FUN_00104650"
        },
        "FUN_00115d00": {
            "renaming": {
                "FUN_00115d00": "find_symbol_00115d00",
                "param_1": "symbolTable",
                "param_2": "moduleInfo",
                "uVar1": "moduleSize",
                "lVar2": "symbolAddress"
            },
            "code": "\nlong findSymbol_00115d00(long symbolTable,long moduleInfo)\n\n{\n  uint moduleSize;\n  long symbolAddress;\n  \n  symbolAddress = isympp;\n  if (isympp != 0) {\n    if (*(int *)(*(long *)(moduleInfo + 8) + 8) == 5) {\n      if (*(int *)(symbolTable + 0x28) == *(int *)(*(long *)(moduleInfo + 0x110) + 0xd40)) {\n        moduleSize = *(uint *)(symbolTable + 0x2c);\n        if (moduleSize == 0) {\n          symbolAddress = 0;\n        }\n        else if ((ulong)moduleSize <\n                 *(ulong *)(*(long *)(moduleInfo + 0x110) + 0x88) /\n                 (ulong)*(byte *)(*(long *)(*(long *)(*(long *)(moduleInfo + 8) + 0x380) + 0x340) + 5))\n        {\n          symbolAddress = *(long *)(isympp + (ulong)(moduleSize - 1) * 8);\n        }\n        else {\n          symbolAddress = 0;\n        }\n      }\n      else {\n        symbolAddress = 0;\n      }\n    }\n    else {\n      symbolAddress = 0;\n    }\n  }\n  return symbolAddress;\n}\n\n",
            "called": [
                "group_signature.isra.0.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115d00",
            "calling": [
                "is_strip_section.isra.0",
                "FUN_00108179"
            ],
            "imported": false,
            "current_name": "find_symbol_00115d00"
        },
        "FUN_00104530": {
            "renaming": {},
            "code": "\nvoid bfd_bwrite(void)\n\n{\n  bfd_bwrite();\n  return;\n}\n\n",
            "called": [
                "bfd_bwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104530",
            "calling": [
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "FUN_00104530"
        },
        "FUN_00113c43": {
            "renaming": {
                "FUN_00113c43": "initialize_debug_type_00113c43",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "param_5": "input5",
                "param_6": "input6",
                "lVar1": "debugType",
                "plVar2": "debugTypePointer",
                "auVar3": "returnValue"
            },
            "code": "\nundefined  [16]\ninitializeDebugType_00113c43(long input1,long input2,long input3,long input4,undefined input5,\n            undefined8 input6)\n\n{\n  long debugType;\n  long *debugTypePointer;\n  undefined returnValue [16];\n  \n  if ((input1 != 0) && (input2 != 0)) {\n    debugType = debug_make_type_constprop_0(0x10,0);\n    if (debugType != 0) {\n      debugTypePointer = (long *)xmalloc(0x28);\n      *(undefined4 *)((long)debugTypePointer + 0x21) = 0;\n      *debugTypePointer = input1;\n      *(undefined4 *)((long)debugTypePointer + 0x24) = 0;\n      debugTypePointer[1] = input2;\n      debugTypePointer[2] = input3;\n      debugTypePointer[3] = input4;\n      *(undefined *)(debugTypePointer + 4) = input5;\n      *(long **)(debugType + 0x10) = debugTypePointer;\n      goto LAB_00113caa;\n    }\n  }\n  debugType = 0;\nLAB_00113caa:\n  returnValue._8_8_ = input6;\n  returnValue._0_8_ = debugType;\n  return returnValue;\n}\n\n",
            "called": [
                "debug_make_type.constprop.0",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113c43",
            "calling": [
                "parse_coff_type.lto_priv.0",
                "parse_stab_type",
                "stab_demangle_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "initialize_debug_type_00113c43"
        },
        "FUN_00104890": {
            "renaming": {},
            "code": "\n\n\nchar * strerror(int __errnum)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strerror(__errnum);\n  return pcVar1;\n}\n\n",
            "called": [
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104890",
            "calling": [
                "main",
                "set_times.cold",
                "get_file_size.cold",
                "FUN_00107880",
                "copy_file",
                "FUN_00104ea2",
                "display_info.isra.0",
                "section_add_load_file.cold",
                "smart_rename.cold",
                "add_specific_symbols"
            ],
            "imported": false,
            "current_name": "FUN_00104890"
        },
        "FUN_00112a33": {
            "renaming": {
                "FUN_00112a33": "record_debug_info_00112a33",
                "param_1": "context",
                "param_2": "address",
                "param_3": "slot",
                "param_4": "tag",
                "param_5": "debug_info",
                "param_6": "value",
                "param_7": "parameter_type",
                "uVar1": "result",
                "lVar2": "type",
                "plVar3": "slot_ptr"
            },
            "code": "\nbool recordDebugInfo_00112a33(undefined8 context,long address,undefined8 slot,byte tag,undefined8 debug_info\n                 ,undefined8 value,uint parameter_type)\n\n{\n  undefined result;\n  long type;\n  long *slot_ptr;\n  \n  if (tag < 0x12) {\n    if (tag != 0) {\n      switch(tag) {\n      case 1:\n        result = debug_record_variable\n                          (debug_info,*(undefined8 *)(address + 8),value,4,\n                           *(long *)(address + 0x10) + *(long *)(*(long *)(address + 0x20) + 0x30));\n        return (bool)result;\n      case 2:\n        goto switchD_00112a73_caseD_2;\n      case 3:\n        result = debug_record_variable\n                          (debug_info,*(undefined8 *)(address + 8),value,(parameter_type & 0xff) + 2,\n                           *(long *)(address + 0x10) + *(long *)(*(long *)(address + 0x20) + 0x30));\n        return (bool)result;\n      case 4:\n        result = debug_record_variable\n                          (debug_info,*(undefined8 *)(address + 8),value,5,\n                           *(long *)(address + 0x10) + *(long *)(*(long *)(address + 0x20) + 0x30));\n        return (bool)result;\n      case 9:\n        result = debug_record_parameter\n                          (debug_info,*(undefined8 *)(address + 8),value,1,\n                           *(long *)(address + 0x10) + *(long *)(*(long *)(address + 0x20) + 0x30));\n        return (bool)result;\n      case 10:\n      case 0xc:\n      case 0xf:\n        type = debug_tag_type(debug_info,*(undefined8 *)(address + 8));\n        if (type == 0) {\n          return false;\n        }\n        slot_ptr = (long *)coff_get_slot_lto_priv_0(context,slot);\n        *slot_ptr = type;\n        break;\n      case 0xd:\n        type = debug_name_type(debug_info,*(undefined8 *)(address + 8));\n        return type != 0;\n      case 0x11:\n        result = debug_record_parameter\n                          (debug_info,*(undefined8 *)(address + 8),value,2,\n                           *(long *)(address + 0x10) + *(long *)(*(long *)(address + 0x20) + 0x30));\n        return (bool)result;\n      }\n    }\n  }\n  else if (tag == 0x7f) {\nswitchD_00112a73_caseD_2:\n    result = debug_record_variable\n                      (debug_info,*(undefined8 *)(address + 8),value,1,\n                       *(long *)(address + 0x10) + *(long *)(*(long *)(address + 0x20) + 0x30));\n    return (bool)result;\n  }\n  return true;\n}\n\n",
            "called": [
                "debug_name_type",
                "debug_tag_type",
                "coff_get_slot.lto_priv.0",
                "debug_record_variable",
                "debug_record_parameter"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112a33",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "record_debug_info_00112a33"
        },
        "FUN_00104770": {
            "renaming": {},
            "code": "\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n  int iVar1;\n  \n  iVar1 = vfprintf(__s,__format,__arg);\n  return iVar1;\n}\n\n",
            "called": [
                "vfprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104770",
            "calling": [
                "report",
                "bfd_nonfatal_message"
            ],
            "imported": false,
            "current_name": "FUN_00104770"
        },
        "FUN_0010c2d2": {
            "renaming": {
                "FUN_0010c2d2": "determine_data_type_0010c2d2",
                "param_1": "typeTable",
                "param_2": "baseAddress",
                "param_3": "typeSpecifier",
                "uVar1": "specifierValue",
                "pcVar2": "dataTypeName",
                "uVar3": "dataType",
                "lVar4": "dataTypeAddress",
                "plVar5": "symbolTableEntry",
                "uVar6": "absSpecifierValue"
            },
            "code": "\n\n\nlong determineDataType_0010c2d2(undefined8 typeTable,long baseAddress,int *typeSpecifier)\n\n{\n  uint specifierValue;\n  char *dataTypeName;\n  undefined8 dataType;\n  long dataTypeAddress;\n  long *symbolTableEntry;\n  uint absSpecifierValue;\n  \n  if ((*typeSpecifier == 0) && (specifierValue = typeSpecifier[1], (int)specifierValue < 0)) {\n    absSpecifierValue = ~specifierValue;\n    if (absSpecifierValue < 0x22) {\n      dataTypeAddress = *(long *)(baseAddress + 0x90 + (ulong)absSpecifierValue * 8);\n      if (dataTypeAddress == 0) {\n        switch(absSpecifierValue) {\n        case 1:\n          dataType = debug_make_int_type_isra_0(1,0);\n          dataTypeName = \"char\";\n          break;\n        case 2:\n          dataType = debug_make_int_type_isra_0(2,0);\n          dataTypeName = \"short\";\n          break;\n        case 3:\n          dataType = debug_make_int_type_isra_0(4,0);\n          dataTypeName = \"long\";\n          break;\n        case 4:\n          dataType = debug_make_int_type_isra_0(1,1);\n          dataTypeName = \"unsigned char\";\n          break;\n        case 5:\n          dataType = debug_make_int_type_isra_0(1,0);\n          dataTypeName = \"signed char\";\n          break;\n        case 6:\n          dataType = debug_make_int_type_isra_0(2,1);\n          dataTypeName = \"unsigned short\";\n          break;\n        case 7:\n          dataType = debug_make_int_type_isra_0(4,1);\n          dataTypeName = \"unsigned int\";\n          break;\n        case 8:\n          dataType = debug_make_int_type_isra_0(4,1);\n          dataTypeName = \"unsigned\";\n          break;\n        case 9:\n          dataType = debug_make_int_type_isra_0(4,1);\n          dataTypeName = \"unsigned long\";\n          break;\n        case 10:\n          dataType = debug_make_void_type_isra_0();\n          dataTypeName = \"void\";\n          break;\n        case 0xb:\n          dataType = debug_make_float_type_isra_0(4);\n          dataTypeName = \"float\";\n          break;\n        case 0xc:\n          dataType = debug_make_float_type_isra_0(8);\n          dataTypeName = \"double\";\n          break;\n        case 0xd:\n          dataType = debug_make_float_type_isra_0(8);\n          dataTypeName = \"long double\";\n          break;\n        case 0xe:\n          dataType = debug_make_int_type_isra_0(4,0);\n          dataTypeName = \"integer\";\n          break;\n        case 0xf:\n          dataType = debug_make_type_constprop_0(6,4);\n          dataTypeName = \"boolean\";\n          break;\n        case 0x10:\n          dataType = debug_make_float_type_isra_0(4);\n          dataTypeName = \"short real\";\n          break;\n        case 0x11:\n          dataType = debug_make_float_type_isra_0(8);\n          dataTypeName = \"real\";\n          break;\n        case 0x12:\n          dataTypeName = \"stringptr\";\n          dataType = 0;\n          break;\n        case 0x13:\n          dataType = debug_make_int_type_isra_0(1,1);\n          dataTypeName = \"character\";\n          break;\n        case 0x14:\n          dataType = debug_make_type_constprop_0(6,1);\n          dataTypeName = \"logical*1\";\n          break;\n        case 0x15:\n          dataType = debug_make_type_constprop_0(6,2);\n          dataTypeName = \"logical*2\";\n          break;\n        case 0x16:\n          dataType = debug_make_type_constprop_0(6,4);\n          dataTypeName = \"logical*4\";\n          break;\n        case 0x17:\n          dataType = debug_make_type_constprop_0(6,4);\n          dataTypeName = \"logical\";\n          break;\n        case 0x18:\n          dataType = debug_make_type_constprop_0(5,8);\n          dataTypeName = \"complex\";\n          break;\n        case 0x19:\n          dataType = debug_make_type_constprop_0(5,0x10);\n          dataTypeName = \"double complex\";\n          break;\n        case 0x1a:\n          dataType = debug_make_int_type_isra_0(1,0);\n          dataTypeName = \"integer*1\";\n          break;\n        case 0x1b:\n          dataType = debug_make_int_type_isra_0(2,0);\n          dataTypeName = \"integer*2\";\n          break;\n        case 0x1c:\n          dataType = debug_make_int_type_isra_0(4,0);\n          dataTypeName = \"integer*4\";\n          break;\n        case 0x1d:\n          dataType = debug_make_int_type_isra_0(2,0);\n          dataTypeName = \"wchar\";\n          break;\n        case 0x1e:\n          dataType = debug_make_int_type_isra_0(8,0);\n          dataTypeName = \"long long\";\n          break;\n        case 0x1f:\n          dataType = debug_make_int_type_isra_0(8,1);\n          dataTypeName = \"unsigned long long\";\n          break;\n        case 0x20:\n          dataType = debug_make_type_constprop_0(6,8);\n          dataTypeName = \"logical*8\";\n          break;\n        case 0x21:\n          dataType = debug_make_int_type_isra_0(8,0);\n          dataTypeName = \"integer*8\";\n          break;\n        default:\n          dataType = debug_make_int_type_isra_0(4,0);\n          dataTypeName = \"int\";\n        }\n        dataTypeAddress = debug_name_type(typeTable,dataTypeName,dataType);\n        *(long *)(baseAddress + 0x90 + (ulong)absSpecifierValue * 8) = dataTypeAddress;\n        return dataTypeAddress;\n      }\n      return dataTypeAddress;\n    }\n    dataTypeName = (char *)dcgettext(0,\"Unrecognized XCOFF type %d\\n\",5);\n    fprintf(_stderr,dataTypeName,(ulong)specifierValue);\n  }\n  else {\n    symbolTableEntry = (long *)stab_find_slot(baseAddress);\n    if (symbolTableEntry != (long *)0x0) {\n      if (*symbolTableEntry == 0) {\n        dataTypeAddress = debug_make_indirect_type_isra_0(symbolTableEntry,0);\n        return dataTypeAddress;\n      }\n      return *symbolTableEntry;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "fprintf",
                "debug_make_int_type.isra.0",
                "debug_make_void_type.isra.0",
                "debug_name_type",
                "dcgettext",
                "debug_make_indirect_type.isra.0",
                "debug_make_float_type.isra.0",
                "debug_make_type.constprop.0",
                "stab_find_slot"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c2d2",
            "calling": [
                "parse_stab_type"
            ],
            "imported": false,
            "current_name": "determine_data_type_0010c2d2"
        },
        "FUN_0010e07c": {
            "renaming": {
                "FUN_0010e07c": "parse_coff_types_0010e07c",
                "param_2": "coff_symbols",
                "param_5": "coff_headers",
                "lVar1": "symbol_table_offset",
                "lVar2": "symbol",
                "lVar3": "symbol_count",
                "cVar4": "result",
                "uVar5": "error_code",
                "__ptr": "symbol_types",
                "uVar6": "type1",
                "uVar7": "type2",
                "puVar8": "new_symbol",
                "pcVar9": "error_message",
                "puVar10": "aux_data",
                "uVar11": "some_value",
                "lVar12": "symbol_index",
                "iVar13": "aux_data_offset",
                "iVar14": "symbol_capacity",
                "local_a8": "var1",
                "uStack_a4": "var2",
                "uStack_a0": "var3",
                "uStack_9c": "var4",
                "local_88": "symbol_name",
                "local_6a": "symbol_type",
                "local_68": "aux_tag",
                "local_67": "aux_tag2",
                "local_60": "aux_data_buffer",
                "local_56": "section_flags"
            },
            "code": "\nundefined8\nparse_coff_types_0010e07c(undefined8 param_1,long *coff_symbols,undefined8 param_3,int param_4,long coff_headers,\n            undefined8 param_6)\n\n{\n  long symbol_table_offset;\n  long symbol;\n  long symbol_count;\n  char result;\n  undefined4 error_code;\n  void *symbol_types;\n  undefined8 type1;\n  undefined8 type2;\n  undefined4 *new_symbol;\n  char *error_message;\n  undefined *aux_data;\n  uint some_value;\n  long symbol_index;\n  int aux_data_offset;\n  int symbol_capacity;\n  undefined4 var1;\n  undefined4 var2;\n  undefined4 var3;\n  undefined4 var4;\n  undefined symbol_name [30];\n  undefined2 symbol_type;\n  byte aux_tag;\n  byte aux_tag2;\n  undefined aux_data_buffer [10];\n  ushort section_flags;\n  \n  symbol_capacity = 10;\n  symbol_index = 0;\n  symbol_table_offset = *(long *)(coff_headers + 0x18);\n  symbol_types = (void *)xmalloc(0x50);\n  while ((coff_symbols[3] < symbol_table_offset && (coff_symbols[2] < coff_symbols[1]))) {\n    symbol = *(long *)(*coff_symbols + coff_symbols[2] * 8);\n    result = bfd_coff_get_syment(param_1,symbol,symbol_name);\n    if (result == '\\0') {\n      error_code = bfd_get_error();\n      type1 = bfd_errmsg(error_code);\n      error_message = \"bfd_coff_get_syment failed: %s\";\nLAB_0010e18d:\n      type2 = dcgettext(0,error_message,5);\n      non_fatal(type2,type1);\n      free(symbol_types);\n      return 0;\n    }\n    symbol_count = coff_symbols[3];\n    aux_data = (undefined *)0x0;\n    coff_symbols[2] = coff_symbols[2] + 1;\n    coff_symbols[3] = symbol_count + 1 + (ulong)aux_tag2;\n    if (aux_tag2 != 0) {\n      aux_data = aux_data_buffer;\n      result = bfd_coff_get_auxent(param_1,symbol,0,aux_data);\n      if (result == '\\0') {\n        error_code = bfd_get_error();\n        type1 = bfd_errmsg(error_code);\n        error_message = \"bfd_coff_get_auxent failed: %s\";\n        goto LAB_0010e18d;\n      }\n    }\n    if (aux_tag == 0x12) {\n      some_value = (uint)section_flags;\n      aux_data_offset = (int)*(undefined8 *)(symbol + 0x10) +\n               (int)*(undefined8 *)(*(long *)(symbol + 0x20) + 0x30);\n    }\n    else {\n      if (aux_tag < 0x13) {\n        if ((aux_tag == 8) || (aux_tag == 0xb)) {\n          some_value = 0;\n          aux_data_offset = ((int)*(undefined8 *)(symbol + 0x10) +\n                   (int)*(undefined8 *)(*(long *)(symbol + 0x20) + 0x30)) * 8;\n          goto LAB_0010e214;\n        }\n      }\n      else if (aux_tag == 0x66) break;\n      some_value = 0;\n      aux_data_offset = 0;\n    }\nLAB_0010e214:\n    type2 = parse_coff_type_lto_priv_0(param_1,coff_symbols,param_3,symbol_count,symbol_type,aux_data,1);\n    type1 = *(undefined8 *)(symbol + 8);\n    new_symbol = (undefined4 *)xmalloc(0x20);\n    var1 = (undefined4)type1;\n    var2 = (undefined4)((ulong)type1 >> 0x20);\n    var3 = (undefined4)type2;\n    var4 = (undefined4)((ulong)type2 >> 0x20);\n    *(undefined8 *)(new_symbol + 5) = 0;\n    new_symbol[6] = aux_data_offset;\n    new_symbol[7] = some_value;\n    new_symbol[4] = 0;\n    *new_symbol = var1;\n    new_symbol[1] = var2;\n    new_symbol[2] = var3;\n    new_symbol[3] = var4;\n    if (symbol_capacity <= (int)symbol_index + 1) {\n      symbol_capacity = symbol_capacity + 10;\n      symbol_types = (void *)xrealloc(symbol_types,(long)symbol_capacity << 3,new_symbol,0,param_6);\n    }\n    *(undefined4 **)((long)symbol_types + symbol_index * 8) = new_symbol;\n    symbol_index = symbol_index + 1;\n  }\n  *(undefined8 *)((long)symbol_types + (long)(int)symbol_index * 8) = 0;\n  type1 = debug_make_struct_type_isra_0(param_4 == 8,*(undefined2 *)(coff_headers + 10),symbol_types);\n  return type1;\n}\n\n",
            "called": [
                "bfd_get_error",
                "bfd_coff_get_auxent",
                "parse_coff_type.lto_priv.0",
                "bfd_errmsg",
                "dcgettext",
                "non_fatal",
                "xrealloc",
                "free",
                "debug_make_struct_type.isra.0",
                "xmalloc",
                "bfd_coff_get_syment"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e07c",
            "calling": [
                "parse_coff_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "parse_coff_types_0010e07c"
        },
        "FUN_001082c3": {
            "renaming": {
                "FUN_001082c3": "initialize_001082c3",
                "undefined8": "void"
            },
            "code": "\nvoid initialize_001082c3(void)\n\n{\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001082c3",
            "calling": [
                "group_signature.isra.0"
            ],
            "imported": false,
            "current_name": "initialize_001082c3"
        },
        "FUN_00114460": {
            "renaming": {
                "FUN_00114460": "read_and_process_file_00114460",
                "param_1": "filename",
                "param_2": "hashTable",
                "param_3": "fileContent",
                "iVar1": "lineNumber",
                "piVar2": "errnoLocation",
                "pcVar3": "errorString",
                "uVar4": "translatedString",
                "__n": "fileSize",
                "__ptr": "fileBuffer",
                "__stream": "fileStream",
                "sVar5": "bytesRead",
                "ppbVar6": "hashTableEntry",
                "pbVar7": "linePointer",
                "bVar8": "currentByte",
                "pbVar9": "nextLinePointer",
                "pbVar10": "currentLinePointer",
                "pbVar11": "nextLinePointer2",
                "pbVar12": "currentLineStart"
            },
            "code": "\nvoid readAndProcessFile_00114460(char *filename,undefined8 hashTable,byte **fileContent)\n\n{\n  int lineNumber;\n  int *errnoLocation;\n  char *errorString;\n  undefined8 translatedString;\n  size_t fileSize;\n  byte *fileBuffer;\n  FILE *fileStream;\n  size_t bytesRead;\n  byte **hashTableEntry;\n  byte *linePointer;\n  byte currentByte;\n  byte *nextLinePointer;\n  byte *currentLinePointer;\n  byte *nextLinePointer2;\n  byte *currentLineStart;\n  \n  fileSize = get_file_size();\n  if (fileSize == 0) {\n    status = 1;\n  }\n  else {\n    fileBuffer = (byte *)xmalloc(fileSize + 2);\n    fileStream = fopen(filename,\"r\");\n    if (fileStream == (FILE *)0x0) {\n      errnoLocation = __errno_location();\n      errorString = strerror(*errnoLocation);\n      translatedString = dcgettext(0,\"cannot open \\'%s\\': %s\",5);\n                    \n      fatal(translatedString,filename,errorString);\n    }\n    bytesRead = fread(fileBuffer,1,fileSize,fileStream);\n    if ((bytesRead == 0) || (lineNumber = ferror(fileStream), lineNumber != 0)) {\n      translatedString = dcgettext(0,\"%s: fread failed\",5);\n                    \n      fatal(translatedString,filename);\n    }\n    lineNumber = 1;\n    fclose(fileStream);\n    *(undefined2 *)(fileBuffer + fileSize) = 10;\n    currentByte = *fileBuffer;\n    currentLineStart = fileBuffer;\n    while (currentLinePointer = currentLineStart, currentByte != 0) {\n      for (; currentByte = *currentLinePointer, nextLinePointer2 = currentLinePointer, currentByte != 10; currentLinePointer = currentLinePointer + 1) {\n        if ((char)currentByte < '\\v') {\n          if (currentByte == 0) {\n            nextLinePointer = currentLinePointer + 1;\n            goto LAB_00114553;\n          }\n        }\n        else {\n          if (currentByte == 0xd) {\n            *currentLinePointer = 0;\n            nextLinePointer = currentLinePointer + 1;\n            if (currentLinePointer[1] == 10) {\n              nextLinePointer = currentLinePointer + 2;\n              nextLinePointer2 = currentLinePointer + 1;\n            }\n            goto LAB_00114553;\n          }\n          if (currentByte == 0x23) {\n            parse_input_lines_00104d1c();\n            return;\n          }\n        }\n      }\n      *currentLinePointer = 0;\n      if (currentLinePointer[1] == 0xd) {\n        nextLinePointer2 = currentLinePointer + 1;\n        nextLinePointer = currentLinePointer + 2;\n      }\n      else {\n        nextLinePointer = currentLinePointer + 1;\n      }\nLAB_00114553:\n      currentByte = *currentLineStart;\n      while ((currentByte == 0x20 || (currentLinePointer = currentLineStart, currentByte == 9))) {\n        currentLinePointer = currentLineStart + 1;\n        currentLineStart = currentLineStart + 1;\n        currentByte = *currentLinePointer;\n      }\n      do {\n        if ((currentByte == 10) || (currentByte == 0xd)) goto LAB_00114676;\n        if (currentByte == 0) goto LAB_00114599;\n        currentByte = currentLinePointer[1];\n        currentLinePointer = currentLinePointer + 1;\n      } while ((currentByte != 0x20) && (currentByte != 9));\n      if ((char)currentByte < '\\x0e') {\nLAB_00114676:\n        if ((-0x2402L >> (currentByte & 0x3f) & 1U) != 0) goto LAB_001145e6;\n      }\n      else {\nLAB_001145e6:\n        currentByte = currentLinePointer[1];\n        if ((((((currentByte == 9) || (currentByte == 0x20)) &&\n              ((currentByte = currentLinePointer[2], currentByte == 9 || (currentByte == 0x20)))) &&\n             ((currentByte = currentLinePointer[3], currentByte == 9 || (currentByte == 0x20)))) &&\n            ((currentByte = currentLinePointer[4], currentByte == 9 || (currentByte == 0x20)))) &&\n           ((currentByte = currentLinePointer[5], currentByte == 9 || (currentByte == 0x20)))) {\n          currentByte = currentLinePointer[6];\n          linePointer = currentLinePointer + 6;\n          if ((currentByte == 9) || (currentByte == 0x20)) {\n            do {\n              do {\n                currentByte = linePointer[1];\n                linePointer = linePointer + 1;\n              } while (currentByte == 0x20);\n            } while (currentByte == 9);\n          }\n        }\n        if ((0xd < currentByte) || ((-0x2402L >> (currentByte & 0x3f) & 1U) != 0)) {\n          translatedString = dcgettext(0,\"%s:%d: Ignoring rubbish found on this line\",5);\n          non_fatal(translatedString,filename,lineNumber);\n        }\n      }\nLAB_00114599:\n      *currentLinePointer = 0;\n      if (currentLineStart < currentLinePointer) {\n        hashTableEntry = (byte **)htab_find_slot(hashTable,currentLineStart,1);\n        *hashTableEntry = currentLineStart;\n      }\n      lineNumber = lineNumber + 1;\n      currentLineStart = nextLinePointer;\n      currentByte = nextLinePointer2[1];\n    }\n    *fileContent = fileBuffer;\n  }\n  return;\n}\n\n",
            "called": [
                "strerror",
                "fclose",
                "dcgettext",
                "ferror",
                "get_file_size",
                "fread",
                "xmalloc",
                "fopen",
                "__errno_location",
                "fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114460",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "read_and_process_file_00114460"
        },
        "FUN_001280f8": {
            "renaming": {},
            "code": "\n\n\nvoid textdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* textdomain@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001280f8",
            "calling": [
                "textdomain"
            ],
            "imported": false,
            "current_name": "FUN_001280f8"
        },
        "FUN_0010a94e": {
            "renaming": {
                "FUN_0010a94e": "construct_message_0010a94e",
                "param_1": "context",
                "param_2": "param1",
                "param_3": "param2",
                "param_4": "flag",
                "__s": "type",
                "pcVar7": "message",
                "uVar8": "result",
                "pcVar9": "flagSuffix",
                "cVar1": "typeFlag",
                "lVar2": "ptr"
            },
            "code": "\nundefined8 constructMessage_0010a94e(long context,char *param1,char *param2,int flag)\n\n{\n  char typeFlag;\n  long ptr;\n  char *type;\n  size_t sVar3;\n  size_t sVar4;\n  size_t sVar5;\n  size_t sVar6;\n  char *message;\n  undefined8 result;\n  char *flagSuffix;\n  \n  typeFlag = *(char *)(*(long *)(context + 0x60) + 0x1c);\n  type = (char *)stab_pop_type();\n  message = *(char **)(*(long *)(context + 0x60) + 0x20);\n  if (message == (char *)0x0) {\n    result = 0;\n  }\n  else {\n    sVar3 = strlen(message);\n    sVar4 = strlen(param1);\n    sVar5 = strlen(type);\n    sVar6 = strlen(param2);\n    message = (char *)xmalloc(sVar3 + 10 + sVar4 + sVar5 + sVar6);\n    if (flag == 1) {\n      flagSuffix = \"/1\";\n    }\n    else {\n      flagSuffix = \"/0\";\n      if ((flag != 2) && (flagSuffix = \"\", flag != 0)) {\n                    \n        abort();\n      }\n    }\n    sprintf(message,\"%s%s:%s%s:%s;\",*(undefined8 *)(*(long *)(context + 0x60) + 0x20),param1,flagSuffix,\n            type,param2,*(long *)(context + 0x60));\n    free(*(void **)(*(long *)(context + 0x60) + 0x20));\n    ptr = *(long *)(context + 0x60);\n    *(char **)(ptr + 0x20) = message;\n    if (typeFlag != '\\0') {\n      *(undefined *)(ptr + 0x1c) = 1;\n    }\n    result = CONCAT71((int7)((ulong)ptr >> 8),1);\n  }\n  return result;\n}\n\n",
            "called": [
                "strlen",
                "sprintf",
                "abort",
                "free",
                "xmalloc",
                "stab_pop_type"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a94e",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "construct_message_0010a94e"
        },
        "FUN_00113b1e": {
            "renaming": {
                "FUN_00113b1e": "extract_real_type_00113b1e",
                "param_1": "input_ptr",
                "param_2": "unused_param",
                "param_3": "param_value",
                "param_4": "output_ptr",
                "auVar1": "result",
                "piVar2": "type_ptr",
                "uVar3": "real_type",
                "auVar4": "output"
            },
            "code": "\nundefined  [16] extract_real_type_00113b1e(long input_ptr,undefined8 unused_param,ulong param_value,undefined8 output_ptr)\n\n{\n  undefined result [16];\n  int *type_ptr;\n  undefined8 real_type;\n  undefined output [16];\n  \n  if (input_ptr != 0) {\n    type_ptr = (int *)debug_get_real_type_isra_0(input_ptr,0);\n    if ((type_ptr == (int *)0x0) || (3 < *type_ptr - 7U)) {\n      real_type = 0;\n    }\n    else {\n      real_type = **(undefined8 **)(type_ptr + 4);\n    }\n    output._8_8_ = output_ptr;\n    output._0_8_ = real_type;\n    return output;\n  }\n  result._8_8_ = 0;\n  result._0_8_ = param_value;\n  return result << 0x40;\n}\n\n",
            "called": [
                "debug_get_real_type.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113b1e",
            "calling": [
                "stab_demangle_v3_arg",
                "stab_demangle_qualified"
            ],
            "imported": false,
            "current_name": "extract_real_type_00113b1e"
        },
        "FUN_00104300": {
            "renaming": {},
            "code": "\n\n\nvoid __assert_fail(char *__assertion,char *__file,uint __line,char *__function)\n\n{\n                    \n  __assert_fail(__assertion,__file,__line,__function);\n}\n\n",
            "called": [
                "__assert_fail"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104300",
            "calling": [
                "debug_write_type.constprop.0",
                "debug_set_filename",
                "debug_set_class_id.lto_priv.0",
                "bfd_get_archive_filename"
            ],
            "imported": false,
            "current_name": "FUN_00104300"
        },
        "FUN_0010a0e9": {
            "renaming": {
                "FUN_0010a0e9": "process_data_0010a0e9",
                "param_1": "dataStruct",
                "param_2": "value1",
                "param_3": "value2",
                "__s": "string",
                "sVar3": "stringLength",
                "__s_00": "newString",
                "uVar1": "charValue",
                "uVar2": "returnValue"
            },
            "code": "\nundefined4 processData_0010a0e9(long dataStruct,undefined8 value1,undefined8 value2)\n\n{\n  undefined charValue;\n  undefined4 returnValue;\n  char *string;\n  size_t stringLength;\n  char *newString;\n  \n  charValue = *(undefined *)(*(long *)(dataStruct + 0x60) + 0x1c);\n  returnValue = *(undefined4 *)(*(long *)(dataStruct + 0x60) + 0x18);\n  string = (char *)stab_pop_type();\n  stringLength = strlen(string);\n  newString = (char *)xmalloc(stringLength + 100);\n  sprintf(newString,\"r%s;%ld;%ld;\",string,value1,value2);\n  free(string);\n  returnValue = stab_push_string(dataStruct,newString,0,charValue,returnValue);\n  if ((char)returnValue != '\\0') {\n    free(newString);\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "strlen",
                "stab_push_string",
                "sprintf",
                "free",
                "stab_pop_type",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a0e9",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "process_data_0010a0e9"
        },
        "FUN_00114c20": {
            "renaming": {
                "FUN_00114c20": "remove_unused_sections_00114c20",
                "param_1": "sectionAddress",
                "cVar1": "startsWithPrefix",
                "pcVar2": "nextSectionAddress"
            },
            "code": "\nvoid removeUnusedSections_00114c20(long sectionAddress)\n\n{\n  char startsWithPrefix;\n  char *nextSectionAddress;\n  \n  find_section_list(sectionAddress,1,1);\n  startsWithPrefix = startswith_lto_priv_0_lto_priv_0(sectionAddress,&DAT_0011b499);\n  if (startsWithPrefix != '\\0') {\n    nextSectionAddress = (char *)(sectionAddress + 5);\n    if (*(char *)(sectionAddress + 4) != 'a') {\n      nextSectionAddress = (char *)(sectionAddress + 4);\n    }\n    if (*nextSectionAddress != '\\0') {\n      find_section_list(nextSectionAddress,1,0x100);\n    }\n  }\n  sections_removed = 1;\n  return;\n}\n\n",
            "called": [
                "startswith.lto_priv.0.lto_priv.0",
                "find_section_list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114c20",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "remove_unused_sections_00114c20"
        },
        "FUN_00115f50": {
            "renaming": {
                "FUN_00115f50": "check_and_update_sections_00115f50",
                "param_1": "status",
                "param_2": "argv",
                "param_3": "flag",
                "__s1": "currentSection",
                "uVar1": "comparisonResult",
                "uVar2": "result",
                "extraout_EDX": "additionalResult",
                "plVar3": "sectionsIterator",
                "auVar4": "sectionCheckResult"
            },
            "code": "\nuint checkAndUpdateSections_00115f50(long status,char **argv,char flag)\n\n{\n  char *currentSection;\n  uint comparisonResult;\n  undefined4 result;\n  undefined4 additionalResult;\n  long *sectionsIterator;\n  undefined sectionCheckResult [12];\n  \n  if ((status != 0) || (extract_symbol != '\\0')) {\n    return 1;\n  }\n  sectionCheckResult = is_strip_section_isra_0(argv);\n  if (sectionCheckResult[0] == '\\0') {\n    if (update_sections != (long *)0x0) {\n      currentSection = *argv;\n      sectionsIterator = update_sections;\n      do {\n        comparisonResult = strcmp(currentSection,(char *)sectionsIterator[1]);\n        sectionCheckResult._4_4_ = 0;\n        sectionCheckResult._0_4_ = comparisonResult;\n        sectionCheckResult._8_4_ = additionalResult;\n        if (comparisonResult == 0) {\n          return 1;\n        }\n        sectionsIterator = (long *)*sectionsIterator;\n      } while (sectionsIterator != (long *)0x0);\n    }\n    result = sectionCheckResult._8_4_;\n    if (((((flag == '\\0') || (merge_notes == '\\0')) ||\n         (sectionCheckResult._8_4_ = result, sectionCheckResult._0_8_ = *(long *)(status + 8),\n         *(int *)(*(long *)(status + 8) + 8) != 5)) ||\n        ((sectionCheckResult._0_8_ = (ulong)argv[0x1a], *(int *)(argv[0x1a] + 4) != 7 ||\n         (sectionCheckResult = startswith_lto_priv_0_lto_priv_0(*argv,\".gnu.build.attributes\"),\n         sectionCheckResult[0] == '\\0')))) && ((*(byte *)((long)argv + 0x27) & 2) == 0)) {\n      return (uint)CONCAT71(sectionCheckResult._1_7_,argv[8] == (char *)0x0) |\n             CONCAT31(sectionCheckResult._9_3_,argv[0xc] == (char *)0x0);\n    }\n  }\n  return 1;\n}\n\n",
            "called": [
                "is_strip_section.isra.0",
                "startswith.lto_priv.0.lto_priv.0",
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115f50",
            "calling": [
                "copy_relocations_in_section",
                "copy_section"
            ],
            "imported": false,
            "current_name": "check_and_update_sections_00115f50"
        },
        "FUN_00104540": {
            "renaming": {},
            "code": "\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memcpy(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104540",
            "calling": [
                "main",
                "xstrndup"
            ],
            "imported": false,
            "current_name": "FUN_00104540"
        },
        "FUN_00104420": {
            "renaming": {},
            "code": "\n\n\nint memcmp(void *__s1,void *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = memcmp(__s1,__s2,__n);\n  return iVar1;\n}\n\n",
            "called": [
                "memcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104420",
            "calling": [
                "FUN_00116852",
                "compare_gnu_build_notes"
            ],
            "imported": false,
            "current_name": "FUN_00104420"
        },
        "FUN_001083de": {
            "renaming": {
                "FUN_001083de": "handle_section_length_error_001083de",
                "unaff_RBX": "sectionPointer",
                "unaff_EBP": "errorCode",
                "uVar1": "sectionLength",
                "uVar2": "errorMessage"
            },
            "code": "\nvoid handleSectionLengthError_001083de(void)\n\n{\n  undefined8 sectionLength;\n  undefined8 errorMessage;\n  undefined8 *sectionPointer;\n  undefined4 errorCode;\n  \n  sectionLength = *sectionPointer;\n  errorMessage = dcgettext(0,\"cannot reverse bytes: length of section %s must be evenly divisible by %d\",5)\n  ;\n                    \n  fatal(errorMessage,sectionLength,errorCode);\n}\n\n",
            "called": [
                "dcgettext",
                "fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001083de",
            "calling": [
                "copy_section"
            ],
            "imported": false,
            "current_name": "handle_section_length_error_001083de"
        },
        "FUN_00104780": {
            "renaming": {},
            "code": "\nvoid bfd_check_format_matches(void)\n\n{\n  bfd_check_format_matches();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format_matches"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104780",
            "calling": [
                "copy_file"
            ],
            "imported": false,
            "current_name": "FUN_00104780"
        },
        "FUN_00104660": {
            "renaming": {},
            "code": "\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 = fseek(__stream,__off,__whence);\n  return iVar1;\n}\n\n",
            "called": [
                "fseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104660",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00104660"
        },
        "FUN_0010b948": {
            "renaming": {
                "FUN_0010b948": "process_parameter_0010b948",
                "param_1": "inputParam",
                "param_2": "count",
                "lVar1": "typeAddress",
                "cVar2": "isIntType",
                "__ptr": "pointer",
                "uVar3": "val",
                "uVar4": "updatedCount",
                "local_5a": "outputString"
            },
            "code": "\nvoid processParameter_0010b948(long inputParam,uint count)\n\n{\n  long typeAddress;\n  char isIntType;\n  void *pointer;\n  ulong val;\n  uint updatedCount;\n  char outputString [50];\n  \n  updatedCount = count - 1;\n  val = (ulong)count;\n  if ((updatedCount < 0x10) && (typeAddress = *(long *)(inputParam + 0xf8 + (ulong)updatedCount * 8), typeAddress != 0)) {\n    stab_push_defined_type(inputParam,typeAddress,val);\n    return;\n  }\n  isIntType = stab_int_type_lto_priv_0(inputParam,4,0);\n  if (isIntType != '\\0') {\n    pointer = (void *)stab_pop_type(inputParam);\n    typeAddress = *(long *)(inputParam + 0x68);\n    *(long *)(inputParam + 0x68) = typeAddress + 1;\n    if (updatedCount < 0x10) {\n      *(long *)(inputParam + 0xf8 + (ulong)updatedCount * 8) = typeAddress;\n    }\n    sprintf(outputString,\"%ld=r%s;%u;0;\",typeAddress,pointer,val);\n    free(pointer);\n    stab_push_string(inputParam,outputString,typeAddress,1,val);\n  }\n  return;\n}\n\n",
            "called": [
                "stab_push_string",
                "sprintf",
                "stab_push_defined_type",
                "stab_int_type.lto_priv.0",
                "free",
                "stab_pop_type"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010b948",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "process_parameter_0010b948"
        },
        "FUN_00112b6e": {
            "renaming": {
                "FUN_00112b6e": "reverse_circular_debug_info_00112b6e",
                "param_1": "input_array",
                "param_2": "debug_info",
                "iVar1": "array_length",
                "__format": "format_string",
                "piVar3": "result_array",
                "plVar4": "debug_pointer",
                "bVar5": "is_circular",
                "local_18": "debug_info_copy",
                "local_10": "input_array_copy",
                "uVar2": "type_name"
            },
            "code": "\n\n\nint * reverse_circular_debug_info_00112b6e(int *input_array,long *debug_info)\n\n{\n  int array_length;\n  undefined8 type_name;\n  char *format_string;\n  int *result_array;\n  long *debug_pointer;\n  bool is_circular;\n  long *debug_info_copy;\n  int *input_array_copy;\n  \n  array_length = *input_array;\n  if ((array_length != 1) && (1 < array_length - 0x16U)) {\n    return input_array;\n  }\n  debug_pointer = debug_info;\n  while (debug_pointer != (long *)0x0) {\n    if ((input_array == (int *)debug_pointer[1]) ||\n       (is_circular = debug_pointer == (long *)*debug_pointer, debug_pointer = (long *)*debug_pointer, is_circular)) {\n      type_name = debug_get_type_name_constprop_0\n                        (input_array,\"debug_get_real_type: circular debug information for %s\\n\");\n      format_string = (char *)dcgettext(0);\n      fprintf(_stderr,format_string,type_name);\n      return (int *)0x0;\n    }\n  }\n  debug_info_copy = debug_info;\n  input_array_copy = input_array;\n  if (array_length - 0x16U < 2) {\n    result_array = (int *)reverse_circular_debug_info_00112b6e((*(undefined8 **)(input_array + 4))[1],&debug_info_copy);\n    return result_array;\n  }\n  result_array = *(int **)**(undefined8 **)(input_array + 4);\n  if (input_array == result_array) {\n    return input_array;\n  }\n  if (result_array == (int *)0x0) {\n    return input_array;\n  }\n  result_array = (int *)reverse_circular_debug_info_00112b6e(result_array,&debug_info_copy);\n  return result_array;\n}\n\n",
            "called": [
                "fprintf",
                "debug_get_real_type.isra.0",
                "dcgettext",
                "debug_get_type_name.constprop.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112b6e",
            "calling": [
                "debug_get_real_type.isra.0",
                "debug_type_samep",
                "debug_write_type.constprop.0",
                "parse_stab_type",
                "debug_get_fields.isra.0"
            ],
            "imported": false,
            "current_name": "reverse_circular_debug_info_00112b6e"
        },
        "FUN_0010a83e": {
            "renaming": {
                "FUN_0010a83e": "process_struct_type_0010a83e",
                "param_1": "base_address",
                "param_2": "data_ptr",
                "param_3": "size",
                "param_4": "undefined_param",
                "param_5": "mask",
                "param_6": "condition_1",
                "param_7": "condition_2",
                "uVar1": "result",
                "__s": "string_1",
                "__s_00": "string_2",
                "sVar2": "string_length",
                "cVar3": "flag",
                "stab_start_struct_type_lto_priv_0": "initialize_struct_type",
                "stab_pop_type": "pop_type",
                "xmalloc": "allocate_memory",
                "strlen": "get_string_length",
                "free": "deallocate_memory",
                "sprintf": "format_string"
            },
            "code": "\nundefined4\nprocess_struct_type_0010a83e(long base_address,undefined8 data_ptr,ulong size,undefined undefined_param,ulong mask,\n            byte condition_1,byte condition_2)\n\n{\n  undefined4 result;\n  char *string_1;\n  char *string_2;\n  size_t string_length;\n  char flag;\n  \n  if (((condition_2 ^ 1) & condition_1) == 0) {\n    string_1 = (char *)0x0;\n    flag = '\\0';\n  }\n  else {\n    flag = *(char *)(*(long *)(base_address + 0x60) + 0x1c);\n    string_1 = (char *)pop_type();\n    mask = mask & 0xffffffff;\n    size = size & 0xffffffff;\n  }\n  result = initialize_struct_type(base_address,data_ptr,size,undefined_param,mask);\n  if ((char)result != '\\0') {\n    if (condition_1 == 0) {\n      return result;\n    }\n    if (condition_2 == 0) {\n      if (string_1 == (char *)0x0) {\n        return 0;\n      }\n      string_length = get_string_length(string_1);\n      string_2 = (char *)allocate_memory(string_length + 3);\n      format_string(string_2,\"~%%%s\",string_1);\n      deallocate_memory(string_1);\n      if (flag != '\\0') {\n        *(undefined *)(*(long *)(base_address + 0x60) + 0x1c) = 1;\n      }\n    }\n    else {\n      if (*(long *)(*(long *)(base_address + 0x60) + 0x10) < 1) {\n        return 0;\n      }\n      string_2 = (char *)allocate_memory(0x14);\n      format_string(string_2,\"~%%%ld\",*(undefined8 *)(*(long *)(base_address + 0x60) + 0x10));\n    }\n    *(char **)(*(long *)(base_address + 0x60) + 0x38) = string_2;\n    return result;\n  }\n  return result;\n}\n\n",
            "called": [
                "strlen",
                "sprintf",
                "free",
                "xmalloc",
                "stab_start_struct_type.lto_priv.0",
                "stab_pop_type"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a83e",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "process_struct_type_0010a83e"
        },
        "FUN_00113d6e": {
            "renaming": {
                "FUN_00113d6e": "create_debug_type_00113d6e",
                "param_1": "input1",
                "param_2": "input2",
                "lVar1": "debugTypePointer",
                "puVar2": "allocatedMemory"
            },
            "code": "\nlong createDebugType_00113d6e(undefined8 input1,undefined8 input2)\n\n{\n  long debugTypePointer;\n  undefined8 *allocatedMemory;\n  \n  debugTypePointer = debug_make_type_constprop_0(0xb,0);\n  if (debugTypePointer != 0) {\n    allocatedMemory = (undefined8 *)xmalloc(0x10);\n    *allocatedMemory = input1;\n    allocatedMemory[1] = input2;\n    *(undefined8 **)(debugTypePointer + 0x10) = allocatedMemory;\n  }\n  return debugTypePointer;\n}\n\n",
            "called": [
                "debug_make_type.constprop.0",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113d6e",
            "calling": [
                "parse_coff_type.lto_priv.0",
                "parse_stab_type"
            ],
            "imported": false,
            "current_name": "create_debug_type_00113d6e"
        },
        "FUN_00104430": {
            "renaming": {},
            "code": "\nvoid bfd_init(void)\n\n{\n  bfd_init();\n  return;\n}\n\n",
            "called": [
                "bfd_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104430",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00104430"
        },
        "FUN_00104310": {
            "renaming": {},
            "code": "\n\n\nint fputs(char *__s,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputs(__s,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputs"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104310",
            "calling": [
                "display_info.isra.0.cold",
                "bfd_nonfatal_message"
            ],
            "imported": false,
            "current_name": "FUN_00104310"
        },
        "FUN_00104670": {
            "renaming": {},
            "code": "\n\n\nchar * mkdtemp(char *__template)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = mkdtemp(__template);\n  return pcVar1;\n}\n\n",
            "called": [
                "mkdtemp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104670",
            "calling": [
                "make_tempdir"
            ],
            "imported": false,
            "current_name": "FUN_00104670"
        },
        "FUN_00104550": {
            "renaming": {},
            "code": "\nvoid cplus_demangle_init_info(void)\n\n{\n  cplus_demangle_init_info();\n  return;\n}\n\n",
            "called": [
                "cplus_demangle_init_info"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104550",
            "calling": [
                "parse_stab_type"
            ],
            "imported": false,
            "current_name": "FUN_00104550"
        },
        "FUN_00104790": {
            "renaming": {},
            "code": "\n\n\nulong strtoul(char *__nptr,char **__endptr,int __base)\n\n{\n  ulong uVar1;\n  \n  uVar1 = strtoul(__nptr,__endptr,__base);\n  return uVar1;\n}\n\n",
            "called": [
                "strtoul"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104790",
            "calling": [
                "main",
                "parse_number"
            ],
            "imported": false,
            "current_name": "FUN_00104790"
        },
        "FUN_00114d50": {
            "renaming": {
                "FUN_00114d50": "execute_operation_00114d50",
                "param_1": "sourcePointer",
                "param_2": "targetPointer",
                "param_3": "operationType"
            },
            "code": "\nvoid executeOperation_00114d50(long sourcePointer,long targetPointer,uint operationType)\n\n{\n  if (*(int *)(*(long *)(sourcePointer + 8) + 8) != 2) {\n    return;\n  }\n  if ((operationType == 2) && (*(int *)(*(long *)(targetPointer + 8) + 8) == 2)) {\n    operationType = (uint)*(byte *)(*(long *)(*(long *)(targetPointer + 8) + 0x380) + 0x71);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00105422. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (**(code **)(*(long *)(*(long *)(sourcePointer + 8) + 0x380) + 0x78))(sourcePointer,operationType != 0);\n  return;\n}\n\n",
            "called": [
                "set_long_section_mode.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114d50",
            "calling": [
                "copy_file"
            ],
            "imported": false,
            "current_name": "execute_operation_00114d50"
        },
        "FUN_00108916": {
            "renaming": {
                "FUN_00108916": "print_usage_00108916",
                "param_1": "outputFile",
                "param_2": "exitCode",
                "uVar1": "programName",
                "pcVar2": "message"
            },
            "code": "\nvoid printUsage_00108916(FILE *outputFile,int exitCode)\n\n{\n  undefined8 programName;\n  char *message;\n  \n  programName = program_name;\n  message = (char *)dcgettext(0,\"Usage: %s [option(s)] in-file [out-file]\\n\",5);\n  fprintf(outputFile,message,programName);\n  message = (char *)dcgettext(0,\" Copies a binary file, possibly transforming it in the process\\n\",5)\n  ;\n  fprintf(outputFile,message);\n  message = (char *)dcgettext(0,\" The options are:\\n\",5);\n  fprintf(outputFile,message);\n  message = (char *)dcgettext(0,\n                             \"  -I --input-target <bfdname>      Assume input file is in format <bfdname>\\n  -O --output-target <bfdname>     Create an output file in format <bfdname>\\n  -B --binary-architecture <arch>  Set output arch, when input is arch-less\\n  -F --target <bfdname>            Set both input and output format to <bfdname>\\n     --debugging                   Convert debugging information, if possible\\n  -p --preserve-dates              Copy modified/access timestamps to the output\\n\"\n                             ,5);\n  fprintf(outputFile,message);\n  message = (char *)dcgettext(0,\n                             \"  -D --enable-deterministic-archives\\n                                   Produce deterministic output when stripping archives (default)\\n  -U --disable-deterministic-archives\\n                                   Disable -D behavior\\n\"\n                             ,5);\n  fprintf(outputFile,message);\n  message = (char *)dcgettext(0,\n                             \"  -j --only-section <name>         Only copy section <name> into the output\\n     --add-gnu-debuglink=<file>    Add section .gnu_debuglink linking to <file>\\n  -R --remove-section <name>       Remove section <name> from the output\\n     --remove-relocations <name>   Remove relocations from section <name>\\n  -S --strip-all                   Remove all symbol and relocation information\\n  -g --strip-debug                 Remove all debugging symbols & sections\\n     --strip-dwo                   Remove all DWO sections\\n     --strip-unneeded              Remove all symbols not needed by relocations\\n  -N --strip-symbol <name>         Do not copy symbol <name>\\n     --strip-unneeded-symbol <name>\\n                                   Do not copy symbol <name> unless needed by\\n                                     relocations\\n     --only-keep-debug             Strip everything but the debug information\\n     --extract-dwo                 Copy only DWO sections\\n     --extract-symbol              Remove section contents but keep symbols\\n     --keep-section <name>         Do not strip section <name>\\n  -K --keep-symbol <name>          Do not strip symbol <name>\\n     --keep-section-symbols        Do not strip section symbols\\n     --keep-file-symbols           Do not strip file symbol(s)\\n     --localize-hidden             Turn all ELF hidden symbols into locals\\n  -L --localize-symbol <name>      Force symbol <name> to be marked as a local\\n     --globalize-symbol <name>     Force symbol <name> to be marked as a global\\n  -G --keep-global-symbol <name>   Localize all symbols except <name>\\n  -W --weaken-symbol <name>        Force symbol <name> to be marked as a weak\\n     --weaken                      Force all global symbols to be marked as weak\\n  -w --wildcard                    Permit wildcard in symbol comparison\\n  -x --discard-all                 Remove all non-global symbols\\n  -X --discard-locals              Remove any compiler-generated symbols\\n  -i --interleave[=<number>]       Only copy N out of every <number> bytes\\n     --interlea...\" /* TRUNCATED STRING LITERAL */\n                             ,5);\n  fprintf(outputFile,message);\n  list_supported_targets(program_name,outputFile);\n  if (exitCode == 0) {\n    message = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(outputFile,message,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  exit(exitCode);\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext",
                "list_supported_targets",
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108916",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "print_usage_00108916"
        },
        "FUN_001126c0": {
            "renaming": {
                "FUN_001126c0": "print_error_message_001126c0",
                "param_1": "error1",
                "param_2": "error2",
                "param_3": "error3",
                "param_4": "error4",
                "param_5": "error5",
                "param_6": "error6",
                "param_7": "error7",
                "param_8": "error8",
                "param_9": "fileLength",
                "param_10": "filePointer",
                "param_11": "errorCode",
                "param_12": "errorMessage",
                "param_13": "paramVar1",
                "param_14": "paramVar2",
                "in_AL": "inputFlag",
                "iVar1": "bfdError",
                "uVar2": "errorMsg",
                "local_100": "localVar1",
                "local_fc": "localVar2",
                "local_f8": "localVar3",
                "local_f0": "localVar4",
                "local_e8": "localArray",
                "local_c8": "localVar5",
                "local_c0": "localVar6",
                "local_b8": "localVar7",
                "local_a8": "localVar8",
                "local_98": "localVar9",
                "local_88": "localVar10",
                "local_78": "localVar11",
                "local_68": "localVar12",
                "local_58": "localVar13",
                "local_48": "localVar14",
                "_stdout": "standardOutput",
                "_stderr": "standardError",
                "program_name": "programName",
                "stack0x00000008": "stackVariable"
            },
            "code": "\n\n\nvoid printErrorMessage_001126c0(undefined4 error1,undefined4 error2,undefined4 error3,undefined4 error4,\n                 undefined4 error5,undefined4 error6,undefined4 error7,undefined4 error8,\n                 long fileLength,long filePointer,long *errorCode,char *errorMessage,undefined8 paramVar1,\n                 undefined8 paramVar2)\n\n{\n  char inputFlag;\n  int bfdError;\n  undefined8 errorMsg;\n  undefined4 localVar1;\n  undefined4 localVar2;\n  undefined *localVar3;\n  undefined *localVar4;\n  undefined localArray [32];\n  undefined8 localVar5;\n  undefined8 localVar6;\n  undefined4 localVar7;\n  undefined4 localVar8;\n  undefined4 localVar9;\n  undefined4 localVar10;\n  undefined4 localVar11;\n  undefined4 localVar12;\n  undefined4 localVar13;\n  undefined4 localVar14;\n  \n  if (inputFlag != '\\0') {\n    localVar7 = error1;\n    localVar8 = error2;\n    localVar9 = error3;\n    localVar10 = error4;\n    localVar11 = error5;\n    localVar12 = error6;\n    localVar13 = error7;\n    localVar14 = error8;\n  }\n  localVar5 = paramVar1;\n  localVar6 = paramVar2;\n  bfdError = bfd_get_error();\n  if (bfdError == 0) {\n    errorMsg = dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    errorMsg = bfd_errmsg();\n  }\n  fflush(standardOutput);\n  fputs(programName,standardError);\n  if (filePointer != 0) {\n    if (fileLength == 0) {\n      fileLength = bfd_get_archive_filename(filePointer);\n    }\n    if ((errorCode != (long *)0x0) && (*errorCode != 0)) {\n      fprintf(standardError,\": %s[%s]\",fileLength);\n      goto LAB_001127c1;\n    }\n  }\n  fprintf(standardError,\": %s\",fileLength);\nLAB_001127c1:\n  if (errorMessage != (char *)0x0) {\n    localVar3 = &stackVariable;\n    localVar4 = localArray;\n    localVar1 = 0x20;\n    localVar2 = 0x30;\n    fwrite(&DAT_0011b4a0,1,2,standardError);\n    vfprintf(standardError,errorMessage,&localVar1);\n  }\n  fprintf(standardError,\": %s\\n\",errorMsg);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "bfd_get_error",
                "vfprintf",
                "bfd_errmsg",
                "fputs",
                "dcgettext",
                "fwrite",
                "fflush",
                "bfd_get_archive_filename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001126c0",
            "calling": [
                "copy_object.cold",
                "FUN_0010808f",
                "copy_file.cold",
                "FUN_0010554f",
                "copy_object",
                "main",
                "FUN_001086af",
                "FUN_00108466",
                "copy_relocations_in_section",
                "FUN_00107880",
                "copy_file",
                "FUN_00104ea2",
                "copy_section"
            ],
            "imported": false,
            "current_name": "print_error_message_001126c0"
        },
        "FUN_00113b4a": {
            "renaming": {
                "FUN_00113b4a": "create_constprop_type_00113b4a",
                "param_1": "input_value",
                "lVar1": "result",
                "debug_make_type_constprop_0": "create_constprop"
            },
            "code": "\nlong create_constprop_type_00113b4a(long input_value)\n\n{\n  long result;\n  \n  if (input_value != 0) {\n    result = create_constprop(0x15,0);\n    if (result == 0) {\n      result = 0;\n    }\n    else {\n      *(long *)(result + 0x10) = input_value;\n    }\n    return result;\n  }\n  return 0;\n}\n\n",
            "called": [
                "debug_make_type.constprop.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113b4a",
            "calling": [
                "stab_demangle_v3_arg",
                "parse_stab_type",
                "stab_demangle_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "create_constprop_type_00113b4a"
        },
        "FUN_0010edb4": {
            "renaming": {
                "FUN_0010edb4": "write_symbol_lto_0010edb4",
                "param_1": "file_handle",
                "param_2": "symbol_name",
                "param_3": "symbol_type",
                "param_4": "symbol_value",
                "cVar1": "write_result",
                "iVar2": "filename_comparison",
                "uVar3": "write_result_extended",
                "in_R10": "additional_param"
            },
            "code": "\nundefined8 write_symbol_lto_0010edb4(long file_handle,undefined8 symbol_name,undefined4 symbol_type,ulong symbol_value)\n\n{\n  char write_result;\n  int filename_comparison;\n  undefined8 write_result_extended;\n  undefined8 additional_param;\n  \n  if (*(long *)(file_handle + 0x210) == 0) {\n    return 0;\n  }\n  if (*(ulong *)(file_handle + 0x1f0) < symbol_value) {\n    *(ulong *)(file_handle + 0x1f0) = symbol_value;\n  }\n  filename_comparison = filename_cmp(symbol_name);\n  if (filename_comparison != 0) {\n    write_result = stab_write_symbol_lto_0010edb4_priv_0(file_handle,0x84,0,symbol_value,symbol_name);\n    if (write_result == '\\0') {\n      return 0;\n    }\n    *(undefined8 *)(file_handle + 0x210) = symbol_name;\n  }\n  write_result_extended = stab_write_symbol_lto_0010edb4_priv_0\n                    (file_handle,0x44,symbol_type,symbol_value - *(long *)(file_handle + 0x200),0,additional_param);\n  return write_result_extended;\n}\n\n",
            "called": [
                "stab_write_symbol.lto_priv.0",
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010edb4",
            "calling": [
                "debug_write_linenos.constprop.0"
            ],
            "imported": false,
            "current_name": "write_symbol_lto_0010edb4"
        },
        "FUN_0010e5db": {
            "renaming": {
                "FUN_0010e5db": "process_data_0010e5db",
                "param_1": "dataPtr",
                "param_2": "dataLength",
                "cVar1": "charVar",
                "__ptr": "ptr",
                "__s": "str",
                "sVar2": "strLength",
                "__s_00": "newStr",
                "in_R10": "unknownValue",
                "iVar3": "count",
                "auVar4": "returnValue"
            },
            "code": "\nundefined  [16] processData_0010e5db(long dataPtr,int dataLength)\n\n{\n  char charVar;\n  void *ptr;\n  char *str;\n  size_t strLength;\n  char *newStr;\n  ulong unknownValue;\n  int count;\n  undefined returnValue [16];\n  \n  count = 0;\n  do {\n    if (dataLength <= count) {\n      returnValue = stab_modify_type(dataPtr,0x66,0,dataPtr + 0x188,dataPtr + 400,unknownValue);\n      return returnValue;\n    }\n    if (*(char *)(*(long *)(dataPtr + 0x60) + 0x1c) == '\\0') {\n      ptr = (void *)stab_pop_type(dataPtr);\n      free(ptr);\n    }\n    else {\n      str = (char *)stab_pop_type(dataPtr);\n      strLength = strlen(str);\n      newStr = (char *)xmalloc(strLength + 3);\n      sprintf(newStr,\":t%s\",str);\n      free(str);\n      charVar = stab_write_symbol_lto_priv_0(dataPtr,0x80,0,0,newStr);\n      if (charVar == '\\0') {\n        returnValue._8_8_ = 0;\n        returnValue._0_8_ = unknownValue;\n        return returnValue << 0x40;\n      }\n      free(newStr);\n    }\n    count = count + 1;\n  } while( true );\n}\n\n",
            "called": [
                "strlen",
                "stab_write_symbol.lto_priv.0",
                "sprintf",
                "stab_modify_type",
                "free",
                "xmalloc",
                "stab_pop_type"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e5db",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "process_data_0010e5db"
        },
        "FUN_00104d25": {
            "renaming": {
                "FUN_00104d25": "cleanup_and_remove_directory_00104d25",
                "param_7": "status",
                "status": "statusCode"
            },
            "code": "\nvoid cleanupAndRemoveDirectory_00104d25(void)\n\n{\n  undefined8 status;\n  \n  statusCode = 1;\n  bfd_nonfatal_message(0,status,0,0);\n  remove_directory_00114b84();\n  return;\n}\n\n",
            "called": [
                "FUN_00114b84",
                "bfd_nonfatal_message"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104d25",
            "calling": [
                "copy_file"
            ],
            "imported": false,
            "current_name": "cleanup_and_remove_directory_00104d25"
        },
        "FUN_0010551d": {
            "renaming": {
                "FUN_0010551d": "FUNC_0010551d"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong FUNC_0010551d(void)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  undefined *puVar3;\n  code *pcVar4;\n  undefined8 *puVar5;\n  ulong uVar6;\n  ulong uVar7;\n  char *__s;\n  char cVar8;\n  char cVar9;\n  uint uVar10;\n  int iVar11;\n  uint uVar12;\n  undefined4 uVar13;\n  int iVar14;\n  long *plVar15;\n  undefined8 uVar16;\n  undefined8 uVar17;\n  size_t sVar18;\n  char *pcVar19;\n  void *__ptr;\n  void *__ptr_00;\n  ulong uVar20;\n  long lVar21;\n  ulong uVar22;\n  int *piVar23;\n  ulong uVar24;\n  long lVar25;\n  FILE *__s_00;\n  size_t sVar26;\n  long lVar27;\n  long *unaff_RBX;\n  char *pcVar28;\n  undefined8 *puVar29;\n  ulong uVar30;\n  int iVar31;\n  long unaff_RBP;\n  long *plVar32;\n  char *pcVar33;\n  undefined4 *puVar34;\n  char **ppcVar35;\n  long *unaff_R13;\n  void *pvVar36;\n  undefined8 *unaff_R14;\n  undefined **ppuVar37;\n  bool bVar38;\n  byte bVar39;\n  long in_stack_00000008;\n  ulong in_stack_00000010;\n  char in_stack_00000018;\n  undefined4 *puStack0000000000000020;\n  char *pcStack0000000000000038;\n  uint uStack0000000000000048;\n  int iStack000000000000006c;\n  long lStack0000000000000078;\n  long lStack0000000000000088;\n  char *pcStack0000000000000090;\n  long lStack00000000000000a0;\n  long *in_stack_000000c0;\n  ulong in_stack_000000c8;\n  long in_stack_000000d0;\n  long in_stack_000000d8;\n  void *in_stack_000000e0;\n  long in_stack_000000f0;\n  undefined8 in_stack_000000f8;\n  byte bStack0000000000000100;\n  byte bStack0000000000000101;\n  undefined8 in_stack_00000110;\n  ushort in_stack_00000118;\n  char *in_stack_00000140;\n  char cStack0000000000000148;\n  char *in_stack_00000150;\n  undefined uStack0000000000000158;\n  short sStack000000000000015a;\n  \n  bVar39 = 0;\ncode_r0x0010551d:\n  dcgettext(0,\"warning: could not load note section\",5);\n  bfd_nonfatal_message(0);\n  free(unaff_RBX);\nLAB_001151a2:\n  unaff_RBP = *(long *)(unaff_RBP + 8);\n  puVar29 = dump_sections;\n  if (unaff_RBP == 0) goto joined_r0x001151c7;\n  if (merge_notes != '\\0') {\n    if ((((*(int *)(unaff_R14[1] + 8) != 5) || (*(int *)(*(long *)(unaff_RBP + 0xd0) + 4) != 7)) ||\n        (cVar9 = startswith_lto_priv_0_lto_priv_0(), cVar9 == '\\0')) ||\n       ((*(long *)(unaff_RBP + 0x60) == 0 || (lVar25 = *(long *)(unaff_RBP + 0x40), lVar25 == 0))))\n    goto LAB_001151a2;\n    unaff_RBX = (long *)xmalloc(0x20);\n    unaff_RBX[1] = 0;\n    cVar9 = bfd_get_full_section_contents();\n    if (cVar9 != '\\0') {\n      lVar27 = merge_gnu_build_notes();\n      unaff_RBX[2] = lVar27;\n      if ((lVar27 == lVar25) || (cVar9 = bfd_set_section_size(), cVar9 != '\\0')) {\n        unaff_RBX[3] = (long)unaff_R13;\n        *unaff_RBX = unaff_RBP;\n        unaff_R13 = unaff_RBX;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        bfd_nonfatal_message(0,in_stack_00000008,unaff_RBP);\n        free((void *)unaff_RBX[1]);\n        free(unaff_RBX);\n      }\n      goto LAB_001151a2;\n    }\n    goto code_r0x0010551d;\n  }\n  for (lVar25 = *(long *)(unaff_RBP + 8); lVar25 != 0; lVar25 = *(long *)(lVar25 + 8)) {\n  }\njoined_r0x001151c7:\n  for (; puVar29 != (undefined8 *)0x0; puVar29 = (undefined8 *)*puVar29) {\n    lVar25 = bfd_get_section_by_name();\n    if (lVar25 == 0) {\n      dcgettext(0,\"can\\'t dump section \\'%s\\' - it does not exist\",5);\n      bfd_nonfatal_message(0);\n    }\n    else if ((*(byte *)(lVar25 + 0x25) & 1) == 0) {\n      dcgettext(0,\"can\\'t dump section - it has no contents\",5);\n      bfd_nonfatal_message(0);\n    }\n    else {\n      sVar18 = *(size_t *)(lVar25 + 0x40);\n      __s_00 = fopen((char *)puVar29[2],\"w\");\n      if (__s_00 == (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        bfd_nonfatal_message(puVar29[2],0,0);\n      }\n      else {\n        cVar9 = bfd_malloc_and_get_section();\n        if (cVar9 == '\\0') {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          bfd_nonfatal_message(0);\n        }\n        else if ((sVar18 != 0) &&\n                (sVar26 = fwrite(in_stack_00000140,1,sVar18,__s_00), sVar26 != sVar18)) {\n          piVar23 = __errno_location();\n          pcVar33 = strerror(*piVar23);\n          uVar17 = puVar29[2];\n          uVar16 = dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          non_fatal(uVar16,uVar17,pcVar33);\n          free(in_stack_00000140);\n          fclose(__s_00);\n          return 0;\n        }\n        fclose(__s_00);\n        free(in_stack_00000140);\n      }\n    }\n  }\n  if (gnu_debuglink_filename == 0) {\nLAB_0010790a:\n    lStack0000000000000078 = 0;\n  }\n  else {\n    lVar25 = bfd_get_section_by_name(in_stack_00000008,\".gnu_debuglink\");\n    if (lVar25 != 0) {\n      uVar17 = dcgettext(0,\"%s: debuglink section already exists\",5);\n      non_fatal(uVar17);\n      gnu_debuglink_filename = 0;\n      goto LAB_0010790a;\n    }\n    lStack0000000000000078 = bfd_create_gnu_debuglink_section(in_stack_00000008);\n    lVar25 = gnu_debuglink_filename;\n    if (lStack0000000000000078 == 0) {\n      uVar17 = dcgettext(0,\"cannot create debug link section `%s\\'\",5);\n      bfd_nonfatal_message(0,in_stack_00000008,0,uVar17,lVar25);\n      return 0;\n    }\n    if (*(int *)(*(long *)(in_stack_00000008 + 8) + 8) == 2) {\n      uVar20 = 0;\n      for (uVar24 = *(ulong *)(in_stack_00000008 + 0x90); uVar24 != 0;\n          uVar24 = *(ulong *)(uVar24 + 8)) {\n        uVar22 = *(ulong *)(uVar24 + 0x30);\n        uVar30 = uVar20;\n        uVar6 = uVar24;\n        uVar7 = uVar20;\n        if (uVar22 != 0) {\n          while ((uVar30 = uVar6, uVar7 != 0 &&\n                 (uVar30 = uVar24, uVar22 <= *(ulong *)(uVar20 + 0x30)))) {\n            uVar24 = *(ulong *)(uVar24 + 8);\n            if (uVar24 == 0) goto LAB_00107db8;\n            uVar22 = *(ulong *)(uVar24 + 0x30);\n            uVar6 = uVar20;\n            uVar7 = uVar22;\n          }\n        }\n        uVar20 = uVar30;\n      }\nLAB_00107db8:\n      if (uVar20 == 0) {\n        uVar24 = 0x1000;\n      }\n      else {\n        uVar20 = *(long *)(uVar20 + 0x40) + *(long *)(uVar20 + 0x30);\n        uVar24 = 0xffffffffffffffff;\n        if (uVar20 < 0xfffffffffffff001) {\n          uVar24 = uVar20 + 0xfff & 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(lStack0000000000000078 + 0x28) = *(byte *)(lStack0000000000000078 + 0x28) | 1;\n      *(ulong *)(lStack0000000000000078 + 0x30) = uVar24;\n      *(ulong *)(lStack0000000000000078 + 0x38) = uVar24;\n    }\n  }\n  plVar32 = isympp;\n  iStack000000000000006c = *(int *)(in_stack_00000008 + 0xa0);\n  if (iStack000000000000006c != 0) {\n    uVar24 = improve_and_reverse_0010554f();\n    return uVar24;\n  }\n  if (convert_debugging == '\\0') {\nLAB_00105588:\n    puStack0000000000000020 = (undefined4 *)0x0;\n  }\n  else {\n    ppuVar37 = &names_0;\n    puStack0000000000000020 = (undefined4 *)xmalloc(0x60);\n    puVar34 = puStack0000000000000020;\n    for (lVar25 = 0x18; lVar25 != 0; lVar25 = lVar25 + -1) {\n      *puVar34 = 0;\n      puVar34 = puVar34 + (ulong)bVar39 * -2 + 1;\n    }\n    pcStack0000000000000038 = (char *)0x0;\n    do {\n      puVar3 = *ppuVar37;\n      lVar25 = bfd_get_section_by_name();\n      lVar27 = bfd_get_section_by_name();\n      if ((lVar25 != 0) && (lVar27 != 0)) {\n        lVar25 = *(long *)(lVar25 + 0x40);\n        __ptr = (void *)xmalloc(lVar25);\n        cVar9 = bfd_get_section_contents();\n        if (cVar9 == '\\0') {\n          uVar13 = bfd_get_error();\n          bfd_errmsg(uVar13);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n          free(pcStack0000000000000038);\n          free(__ptr);\n        }\n        else {\n          uVar24 = *(ulong *)(lVar27 + 0x40);\n          __ptr_00 = (void *)xmalloc(uVar24 + 1);\n          in_stack_00000018 = bfd_get_section_contents();\n          if (in_stack_00000018 == '\\0') {\n            uVar13 = bfd_get_error();\n            bfd_errmsg(uVar13);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n            free(pcStack0000000000000038);\n          }\n          else {\n            *(undefined *)((long)__ptr_00 + uVar24) = 0;\n            if ((pcStack0000000000000038 != (char *)0x0) ||\n               (pcStack0000000000000038 = (char *)start_stab_constprop_0(),\n               pcStack0000000000000038 != (char *)0x0)) {\n              lStack00000000000000a0 = 0;\n              lStack0000000000000088 = 0;\n              for (pvVar36 = __ptr; pvVar36 <= (void *)((long)__ptr + lVar25 + -0xc);\n                  pvVar36 = (void *)((long)pvVar36 + 0xc)) {\n                uVar20 = (**(code **)(unaff_R14[1] + 0x40))(pvVar36);\n                bVar2 = *(byte *)((long)pvVar36 + 4);\n                uVar13 = (**(code **)(unaff_R14[1] + 0x58))((long)pvVar36 + 6);\n                lVar27 = (**(code **)(unaff_R14[1] + 0x40))((long)pvVar36 + 8);\n                if (bVar2 == 0) {\n                  lStack0000000000000088 = lStack00000000000000a0;\n                  lStack00000000000000a0 = lStack00000000000000a0 + lVar27;\n                }\n                else {\n                  uVar22 = (uVar20 & 0xffffffff) + lStack0000000000000088;\n                  if (uVar22 < uVar24) {\n                    pcVar33 = (char *)((long)__ptr_00 + uVar22);\n                    pcStack0000000000000090 = (char *)0x0;\n                    while( true ) {\n                      sVar18 = strlen(pcVar33);\n                      if (((sVar18 == 0) || (pcVar28 = pcVar33 + (sVar18 - 1), *pcVar28 != '\\\\')) ||\n                         ((ulong)((long)__ptr + lVar25) < (long)pvVar36 + 0x10U)) goto LAB_001077fb;\n                      *pcVar28 = '\\0';\n                      pvVar36 = (void *)((long)pvVar36 + 0xc);\n                      iVar11 = (**(code **)(unaff_R14[1] + 0x40))(pvVar36);\n                      uVar20 = (ulong)(uint)(iVar11 + (int)lStack0000000000000088);\n                      if (uVar24 <= uVar20) break;\n                      pcVar33 = (char *)concat(pcVar33,(long)__ptr_00 + uVar20,0);\n                      *pcVar28 = '\\\\';\n                      free(pcStack0000000000000090);\n                      pcStack0000000000000090 = pcVar33;\n                    }\n                    uVar17 = *unaff_R14;\n                    pcVar28 = (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar28,uVar17,puVar3,((long)pvVar36 - (long)__ptr) / 0xc);\nLAB_001077fb:\n                    save_stab((ulong)bVar2,uVar13,lVar27,pcVar33);\n                    cVar9 = parse_stab(puStack0000000000000020,pcStack0000000000000038,bVar2);\n                    if (cVar9 == '\\0') {\n                      stab_context();\n                      free_saved_stabs();\n                      free(pcStack0000000000000090);\n                      free(pcStack0000000000000038);\n                      free(__ptr);\n                      free(__ptr_00);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar17 = *unaff_R14;\n                    pcVar33 = (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar33,uVar17,puVar3,((long)pvVar36 - (long)__ptr) / 0xc,\n                            uVar20 & 0xffffffff,(ulong)bVar2,((long)pvVar36 - (long)__ptr) % 0xc);\n                  }\n                }\n              }\n              free_saved_stabs();\n              free(__ptr);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_00);\n          free(__ptr);\n        }\nLAB_00105981:\n        free(puStack0000000000000020);\n        goto LAB_00105588;\n      }\nLAB_001058eb:\n      ppuVar37 = ppuVar37 + 2;\n    } while (ppuVar37 != (undefined **)&DAT_00125c90);\n    if ((pcStack0000000000000038 != (char *)0x0) && (cVar9 = finish_stab(), cVar9 == '\\0'))\n    goto LAB_00105981;\n    if (*(int *)(unaff_R14[1] + 8) == 1) {\n      lVar25 = 0;\n      for (plVar15 = plVar32; plVar15 < plVar32 + in_stack_00000010; plVar15 = plVar15 + 1) {\n        (**(code **)(unaff_R14[1] + 0x218))();\n        if (cStack0000000000000148 == '-') {\n          if (((lVar25 != 0) || (lVar25 = start_stab_constprop_0(), lVar25 != 0)) &&\n             ((in_stack_00000150 != (char *)0x0 && (*in_stack_00000150 != '\\0')))) {\n            pcVar33 = (char *)0x0;\n            pcVar28 = in_stack_00000150;\n            while (((*pcVar28 != '\\0' && (sVar18 = strlen(pcVar28), pcVar28[sVar18 - 1] == '\\\\')) &&\n                   (plVar15 + 1 < plVar32 + in_stack_00000010))) {\n              pcVar19 = (char *)xstrdup(pcVar28);\n              sVar18 = strlen(pcVar19);\n              pcVar19[sVar18 - 1] = '\\0';\n              pcVar28 = (char *)concat(pcVar19,*(undefined8 *)(plVar15[1] + 8),0);\n              free(pcVar19);\n              free(pcVar33);\n              plVar15 = plVar15 + 1;\n              pcVar33 = pcVar28;\n            }\n            save_stab(uStack0000000000000158,(int)sStack000000000000015a,in_stack_00000140,pcVar28);\n            in_stack_00000018 = parse_stab(puStack0000000000000020,lVar25,uStack0000000000000158);\n            if (in_stack_00000018 != '\\0') goto LAB_00106cac;\n            stab_context();\n            free_saved_stabs();\n          }\n          goto LAB_00105981;\n        }\nLAB_00106cac:\n      }\n      free_saved_stabs();\n      if ((lVar25 != 0) && (cVar9 = finish_stab(), cVar9 == '\\0')) goto LAB_00105981;\n    }\n    if (in_stack_00000018 == '\\0') {\n      if ((*(int *)(unaff_R14[1] + 8) != 2) || (in_stack_00000010 == 0)) {\n        pcVar33 = \"%s: no recognized debugging information\";\n        goto LAB_00105968;\n      }\n      in_stack_00000140 = (char *)0x0;\n      in_stack_000000c0 = plVar32;\n      in_stack_000000d0 = 0;\n      in_stack_000000c8 = in_stack_00000010;\n      in_stack_000000d8 = 0;\n      puVar29 = (undefined8 *)&stack0x00000148;\n      for (lVar25 = 0x22; lVar25 != 0; lVar25 = lVar25 + -1) {\n        *(undefined4 *)puVar29 = 0;\n        puVar29 = (undefined8 *)((long)puVar29 + (ulong)bVar39 * -8 + 4);\n      }\n      cVar9 = '\\0';\n      _uStack0000000000000048 = (int *)0x0;\n      pcStack0000000000000038 = (char *)0x0;\n      pcStack0000000000000090 = (char *)0xffffffffffffffff;\nswitchD_00106e1a_caseD_68:\n      do {\n        if ((long)in_stack_00000010 <= in_stack_000000d0) break;\n        lVar25 = plVar32[in_stack_000000d0];\n        cVar8 = bfd_coff_get_syment();\n        lVar27 = in_stack_000000d8;\n        if (cVar8 == '\\0') {\n          uVar13 = bfd_get_error();\n          bfd_errmsg(uVar13);\n          pcVar33 = \"bfd_coff_get_syment failed: %s\";\nLAB_00105968:\n          uVar17 = dcgettext(0,pcVar33,5);\n          non_fatal(uVar17);\n          goto LAB_00105981;\n        }\n        pcVar33 = *(char **)(lVar25 + 8);\n        in_stack_000000d0 = in_stack_000000d0 + 1;\n        in_stack_000000d8 = (ulong)bStack0000000000000101 + 1 + in_stack_000000d8;\n        if ((bStack0000000000000101 != 0) && (cVar8 = bfd_coff_get_auxent(), cVar8 == '\\0')) {\n          uVar13 = bfd_get_error();\n          bfd_errmsg(uVar13);\n          pcVar33 = \"bfd_coff_get_auxent failed: %s\";\n          goto LAB_00105968;\n        }\n        if (pcStack0000000000000090 == (char *)lVar27) {\n          if (bStack0000000000000100 != 0x67) {\n            cVar8 = debug_set_filename(puStack0000000000000020);\n            if (cVar8 == '\\0') goto LAB_00105981;\n            goto LAB_00106de4;\n          }\nswitchD_00106e1a_caseD_67:\n          pcStack0000000000000090 = (char *)in_stack_000000f0;\n          cVar8 = debug_set_filename(puStack0000000000000020);\n        }\n        else {\nLAB_00106de4:\n          if ((char)bStack0000000000000100 < '\\0') {\n            if (bStack0000000000000100 == 0xff) goto switchD_00106e1a_caseD_68;\n          }\n          else if (bStack0000000000000100 < 100) {\n            switch(bStack0000000000000100) {\n            case 3:\n              if (in_stack_000000f8._6_2_ == 0) goto switchD_00106e1a_caseD_68;\n            case 2:\nswitchD_00106e1a_caseD_7f:\n              if ((ulong)((uint)in_stack_000000f8._6_2_ & *(uint *)(unaff_R14[0x22] + 0x40)) ==\n                  2L << ((byte)*(undefined4 *)(unaff_R14[0x22] + 0x3c) & 0x3f)) {\n                _uStack0000000000000048 = (int *)(**(code **)(unaff_R14[1] + 0x238))();\n                pcStack0000000000000038 = pcVar33;\n                goto switchD_00106e1a_caseD_68;\n              }\n              break;\n            default:\n              break;\n            case 5:\n            case 7:\n            case 0xe:\n              goto switchD_00106e1a_caseD_68;\n            }\n          }\n          else {\n            switch(bStack0000000000000100) {\n            case 100:\n              iVar11 = strcmp(pcVar33,\".bb\");\n              if (iVar11 == 0) {\n                cVar8 = debug_start_block(puStack0000000000000020);\n                goto joined_r0x00107247;\n              }\n              iVar11 = strcmp(pcVar33,\".eb\");\n              if (iVar11 == 0) {\n                cVar8 = debug_end_block(puStack0000000000000020);\n                goto joined_r0x00107247;\n              }\n              goto switchD_00106e1a_caseD_68;\n            case 0x65:\n              iVar11 = strcmp(pcVar33,\".bf\");\n              if (iVar11 == 0) {\n                if (pcStack0000000000000038 != (char *)0x0) {\n                  lVar27 = parse_coff_type_lto_priv_0();\n                  if ((lVar27 == 0) ||\n                     (cVar9 = debug_record_function(puStack0000000000000020), cVar9 == '\\0'))\n                  goto LAB_00105981;\n                  if (_uStack0000000000000048 != (int *)0x0) {\n                    iVar11 = 0;\n                    if (bStack0000000000000101 != 0) {\n                      iVar11 = in_stack_00000118 - 1;\n                    }\n                    lVar25 = *(long *)(*(long *)(lVar25 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar31 = _uStack0000000000000048[4];\n                      if (iVar31 == 0) break;\n                      cVar8 = debug_record_line(puStack0000000000000020,iVar11 + iVar31,\n                                                *(long *)(_uStack0000000000000048 + 6) + lVar25);\n                      _uStack0000000000000048 = _uStack0000000000000048 + 4;\n                      if (cVar8 == '\\0') goto LAB_00105981;\n                    }\n                  }\n                  _uStack0000000000000048 = (int *)0x0;\n                  pcStack0000000000000038 = (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar33 = \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar11 = strcmp(pcVar33,\".ef\");\n                if (iVar11 != 0) goto switchD_00106e1a_caseD_68;\n                if (cVar9 != '\\0') {\n                  cVar9 = debug_end_function(puStack0000000000000020);\n                  if (cVar9 == '\\0') goto LAB_00105981;\n                  cVar9 = '\\0';\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar33 = \"%ld: unexpected .ef\\n\";\n              }\n              uVar17 = dcgettext(0,pcVar33,5);\n              non_fatal(uVar17);\n              goto LAB_00105981;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n          lVar21 = parse_coff_type_lto_priv_0();\n          if (lVar21 == 0) goto LAB_00105981;\n          cVar8 = parse_coff_symbol_constprop_0_isra_0(&stack0x00000140,lVar25,lVar27);\n        }\njoined_r0x00107247:\n        if (cVar8 == '\\0') goto LAB_00105981;\n      } while( true );\n    }\n  }\n  if (((*(uint *)(in_stack_00000008 + 0x44) & 0x42) != 0) &&\n     ((*(uint *)(in_stack_00000008 + 0x44) & 1) == 0)) {\n    if ((*(char *)(*(long *)(in_stack_00000008 + 8) + 0x20) == '\\0') &&\n       (keep_section_symbols == '\\0')) {\n      if (in_stack_00000010 != 0) {\n        plVar32 = isympp + in_stack_00000010;\n        plVar15 = isympp;\n        do {\n          uVar10 = *(uint *)(*plVar15 + 0x18);\n          if ((uVar10 & 0x1000000) != 0) {\n            *(uint *)(*plVar15 + 0x18) = uVar10 & 0xfeffffff;\n          }\n          plVar15 = plVar15 + 1;\n        } while (plVar32 != plVar15);\n      }\n    }\n    else {\n      for (lVar25 = *(long *)(in_stack_00000008 + 0x90); lVar25 != 0; lVar25 = *(long *)(lVar25 + 8)\n          ) {\n        if (*(long *)(lVar25 + 0xe8) != 0) {\n          puVar1 = (uint *)(*(long *)(lVar25 + 0xe8) + 0x18);\n          *puVar1 = *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((strip_symbols == 2) || (strip_symbols == 7)) {\nLAB_001059fe:\n    if (strip_symbols != 7) {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections();\n      iVar11 = bfd_get_error();\n      if (iVar11 != 0) {\n        status = 1;\n        return 0;\n      }\n    }\n    lVar25 = xmalloc();\n    plVar32 = isympp;\n    uStack0000000000000048 = *(uint *)((long)unaff_R14 + 0x44) & 0x42;\n    osympp = lVar25;\n    if (in_stack_00000010 == 0) {\n      uVar24 = 0;\n    }\n    else {\n      uVar24 = 0;\n      _in_stack_00000018 = 0;\n      do {\n        iVar11 = add_symbols;\n        plVar15 = (long *)plVar32[_in_stack_00000018];\n        pcVar4 = (code *)plVar15[4];\n        uVar10 = *(uint *)(plVar15 + 3);\n        pcVar33 = (char *)plVar15[1];\n        pcVar28 = pcVar33;\n        if (add_sym_list != (undefined8 *)0x0) {\n          iVar31 = 0;\n          puVar29 = add_sym_list;\n          while( true ) {\n            if ((iVar11 <= iVar31) || (pcVar19 = (char *)puVar29[5], pcVar19 == (char *)0x0))\n            goto LAB_00105ad5;\n            if (pcVar19 != \"\") break;\nLAB_0010750b:\n            iVar31 = iVar31 + 1;\n          }\n          iVar14 = strcmp(pcVar19,pcVar33);\n          if (iVar14 != 0) {\n            puVar29 = (undefined8 *)*puVar29;\n            goto LAB_0010750b;\n          }\n          free(pcVar19);\n          uVar20 = uVar24 + 1;\n          puVar29[5] = \"\";\n          uVar16 = create_new_symbol(puVar29);\n          uVar17 = redefine_specific_htab;\n          *(undefined8 *)(lVar25 + uVar24 * 8) = uVar16;\n          lVar27 = htab_elements(uVar17);\n          if ((lVar27 != 0) || (section_rename_list != (char **)0x0)) goto LAB_001064eb;\nLAB_00105af8:\n          cVar9 = *pcVar33;\n          if (cVar9 != '\\0') goto LAB_00105b11;\nLAB_00106557:\n          pcVar33 = prefix_symbols_string;\n          if ((change_leading_char != '\\0') &&\n             (*(char *)(*(long *)(in_stack_00000008 + 8) + 0x1c) != '\\0')) {\n            lVar27 = unaff_R14[1];\n            cVar9 = '\\0';\n            goto LAB_0010668d;\n          }\n          goto joined_r0x00106565;\n        }\nLAB_00105ad5:\n        lVar27 = htab_elements(redefine_specific_htab);\n        uVar20 = uVar24;\n        if ((lVar27 == 0) && (section_rename_list == (char **)0x0)) goto LAB_00105af8;\n        if (pcVar33 != (char *)0x0) {\nLAB_001064eb:\n          if (((*pcVar33 == '_') && (pcVar33[1] == '_')) &&\n             (iVar11 = strcmp(pcVar33 + (pcVar33[2] == '_'),\"__gnu_lto_slim\"), iVar11 == 0)) {\n            uVar17 = dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\",5);\n                    \n            fatal(uVar17);\n          }\n        }\n        _cStack0000000000000148 = 0;\n        in_stack_00000140 = pcVar33;\n        lVar27 = htab_find(redefine_specific_htab);\n        if (((lVar27 == 0) || (pcVar28 = *(char **)(lVar27 + 8), pcVar33 == pcVar28)) &&\n           (pcVar28 = pcVar33, ppcVar35 = section_rename_list, (uVar10 & 0x100) != 0)) {\n          for (; ppcVar35 != (char **)0x0; ppcVar35 = (char **)ppcVar35[3]) {\n            iVar11 = strcmp(*ppcVar35,pcVar33);\n            if (iVar11 == 0) {\n              pcVar28 = ppcVar35[1];\n              break;\n            }\n          }\n        }\n        plVar15[1] = (long)pcVar28;\n        cVar9 = *pcVar28;\n        if (cVar9 == '\\0') goto LAB_00106557;\nLAB_00105b11:\n        pcVar33 = prefix_symbols_string;\n        lVar27 = unaff_R14[1];\n        if (*(char *)(lVar27 + 0x1c) == cVar9) {\n          if (change_leading_char == '\\0') {\n            if ((remove_leading_char == '\\0') ||\n               ((((uVar10 & 0x82) == 0 && (pcVar4 != bfd_map_over_sections)) &&\n                ((*(byte *)(plVar15[4] + 0x25) & 0x10) == 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n            pcVar28 = pcVar28 + 1;\n            plVar15[1] = (long)pcVar28;\n            goto joined_r0x00106565;\n          }\n          cVar9 = *(char *)(*(long *)(in_stack_00000008 + 8) + 0x1c);\n          if (cVar9 == '\\0') goto LAB_0010677d;\n          if (prefix_symbols_string != (char *)0x0) {\n            pcVar28 = pcVar28 + 1;\n            plVar15[1] = (long)pcVar28;\n            sVar18 = strlen(pcVar28);\n            lVar27 = sVar18 + 2;\n            goto LAB_001066bc;\n          }\n          *pcVar28 = cVar9;\n          plVar15[1] = (long)pcVar28;\n          uVar24 = uVar20;\n        }\n        else {\n          if ((change_leading_char == '\\0') ||\n             (*(char *)(*(long *)(in_stack_00000008 + 8) + 0x1c) == '\\0')) {\njoined_r0x00106565:\n            uVar24 = uVar20;\n            if (pcVar33 == (char *)0x0) goto LAB_00105b32;\n            sVar18 = strlen(pcVar28);\n            sVar26 = strlen(pcVar33);\n            pcVar33 = (char *)xmalloc(sVar26 + sVar18 + 1);\n            pcVar19 = pcVar33;\n          }\n          else {\nLAB_0010668d:\n            pcVar33 = prefix_symbols_string;\n            if ((*(char *)(lVar27 + 0x1c) != '\\0') && (cVar9 != *(char *)(lVar27 + 0x1c)))\n            goto joined_r0x00106565;\n            sVar18 = strlen(pcVar28);\n            lVar27 = sVar18 + 2;\n            if (pcVar33 == (char *)0x0) {\n              pcVar19 = (char *)xmalloc(lVar27);\n            }\n            else {\nLAB_001066bc:\n              sVar18 = strlen(pcVar33);\n              pcVar19 = (char *)xmalloc(sVar18 + lVar27);\n            }\n            pcVar33 = pcVar19 + 1;\n            *pcVar19 = *(char *)(*(long *)(in_stack_00000008 + 8) + 0x1c);\n          }\n          __s = prefix_symbols_string;\n          if (prefix_symbols_string != (char *)0x0) {\n            strcpy(pcVar33,prefix_symbols_string);\n            sVar18 = strlen(__s);\n            pcVar33 = pcVar33 + sVar18;\n          }\n          strcpy(pcVar33,pcVar28);\n          plVar15[1] = (long)pcVar19;\n          pcVar28 = pcVar19;\n          uVar24 = uVar20;\n        }\nLAB_00105b32:\n        if (strip_symbols == 7) goto LAB_001067a8;\n        if (((uVar10 & 0x20) == 0) &&\n           (((uVar10 & 0x100) == 0 ||\n            ((*(byte *)(**(long **)(plVar15[4] + 0xf0) + 0x18) & 0x20) == 0)))) {\n          if (((uStack0000000000000048 == 0) &&\n              (((uVar10 & 0x82) != 0 || ((*(byte *)(plVar15[4] + 0x25) & 0x10) != 0)))) ||\n             (iVar11 = bfd_decode_symclass(plVar15), iVar11 == 0x49)) {\nLAB_00105be2:\n            if (wildcard == '\\0') {\n              lVar27 = htab_find();\n              if (lVar27 == 0) goto LAB_00105c07;\n            }\n            else {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              in_stack_00000140 = pcVar28;\n              htab_traverse(strip_specific_htab,is_specified_symbol_predicate,&stack0x00000140);\n              if (cStack0000000000000148 == '\\0') goto LAB_00105c07;\n            }\n          }\n          else if ((((uVar10 & 0x82) == 0) && (pcVar4 != bfd_map_over_sections)) &&\n                  ((*(byte *)(plVar15[4] + 0x25) & 0x10) == 0)) {\n            if ((uVar10 & 4) == 0) {\n              if (((*(int *)(unaff_R14[1] + 8) != 2) ||\n                  (lVar27 = *(long *)(plVar15[4] + 0xd0), lVar27 == 0)) ||\n                 (*(long *)(lVar27 + 0x40) == 0)) {\n                if ((strip_symbols == 3) || (discard_locals == 2)) goto LAB_001067a8;\n                if (discard_locals == 1) {\n                  cVar9 = bfd_is_local_label(unaff_R14);\n                  goto joined_r0x00106a11;\n                }\n              }\n              goto LAB_00105be2;\n            }\n            cVar9 = convert_debugging;\n            if (1 < strip_symbols - 2U) {\njoined_r0x00106a11:\n              if (cVar9 == '\\0') goto LAB_00105be2;\n            }\n          }\n          else if (strip_symbols != 3) goto LAB_00105be2;\n          goto LAB_001067a8;\n        }\n        if (wildcard == '\\0') {\n          lVar27 = htab_find();\n          if (lVar27 != 0) {\nLAB_0010687f:\n            uVar17 = dcgettext(0,\"not stripping symbol `%s\\' because it is named in a relocation\",5)\n            ;\n            non_fatal(uVar17);\n            status = 1;\n          }\n        }\n        else {\n          _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n          in_stack_00000140 = pcVar28;\n          htab_traverse(strip_specific_htab,is_specified_symbol_predicate,&stack0x00000140);\n          if (cStack0000000000000148 != '\\0') goto LAB_0010687f;\n        }\n        if ((uVar10 & 0x20) == 0) {\nLAB_00105c07:\n          if (wildcard != '\\0') {\n            _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n            in_stack_00000140 = pcVar28;\n            htab_traverse(strip_unneeded_htab,is_specified_symbol_predicate,&stack0x00000140);\n            if (cStack0000000000000148 != '\\0') goto LAB_001067a8;\n            goto LAB_00105c2c;\n          }\n          lVar27 = htab_find();\n          if (lVar27 == 0) goto LAB_00105c2c;\nLAB_001067a8:\n          if ((keep_file_symbols != '\\0') && ((uVar10 & 0x4000) != 0)) goto LAB_00105c2c;\n          if (wildcard == '\\0') {\n            lVar27 = htab_find();\n            if (lVar27 != 0) goto LAB_00105c2c;\n          }\n          else {\n            _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n            in_stack_00000140 = pcVar28;\n            htab_traverse(keep_specific_htab,is_specified_symbol_predicate,&stack0x00000140);\n            if (cStack0000000000000148 != '\\0') goto LAB_00105c2c;\n          }\n        }\n        else {\nLAB_00105c2c:\n          cVar9 = is_strip_section_isra_0(plVar15[4]);\n          if (cVar9 == '\\0') {\n            if (((uVar10 & 0x800002) == 0) && (pcVar4 != bfd_map_over_sections)) {\nLAB_00105c5f:\n              if ((uVar10 & 0x82) != 0) {\n                cVar9 = is_specified_symbol(pcVar28);\n                if ((cVar9 == '\\0') &&\n                   ((lVar27 = htab_elements(keepglobal_specific_htab), lVar27 == 0 ||\n                    (cVar9 = is_specified_symbol(pcVar28), cVar9 != '\\0')))) {\n                  if (((((localize_hidden == '\\0') ||\n                        (uVar12 = *(uint *)(plVar15 + 3), (uVar12 & 0x200000) != 0)) ||\n                       (lVar27 = *plVar15, lVar27 == 0)) ||\n                      ((*(int *)(*(long *)(lVar27 + 8) + 8) != 5 || (*(long *)(lVar27 + 0x110) == 0)\n                       ))) || (1 < (*(byte *)((long)plVar15 + 0x49) & 3) - 1))\n                  goto joined_r0x00105ca2;\n                }\n                else {\n                  uVar12 = *(uint *)(plVar15 + 3);\n                }\n                *(uint *)(plVar15 + 3) = uVar12 & 0xffffff7d | 1;\n              }\njoined_r0x00105ca2:\n              if (((uVar10 & 1) != 0) && (cVar9 = is_specified_symbol(pcVar28), cVar9 != '\\0')) {\n                *(uint *)(plVar15 + 3) = *(uint *)(plVar15 + 3) & 0xfffffffe | 2;\n              }\n            }\n            else {\n              if ((weaken != '\\0') || (cVar9 = is_specified_symbol(pcVar28), cVar9 != '\\0')) {\n                *(uint *)(plVar15 + 3) = *(uint *)(plVar15 + 3) & 0xff7ffffd | 0x80;\n              }\n              if (pcVar4 != bfd_map_over_sections) goto LAB_00105c5f;\n            }\n            *(long **)(lVar25 + uVar24 * 8) = plVar15;\n            uVar24 = uVar24 + 1;\n          }\n        }\n        _in_stack_00000018 = _in_stack_00000018 + 1;\n      } while (in_stack_00000010 != _in_stack_00000018);\n    }\n    if (add_sym_list != (undefined8 *)0x0) {\n      puVar29 = add_sym_list;\n      iVar11 = add_symbols;\n      for (lVar27 = 0; lVar27 < iVar11; lVar27 = lVar27 + 1) {\n        pcVar33 = (char *)puVar29[5];\n        if (pcVar33 == (char *)0x0) {\n          lVar21 = uVar24 * 8;\n          uVar24 = uVar24 + 1;\n          uVar17 = create_new_symbol(puVar29,in_stack_00000008);\n          *(undefined8 *)(lVar25 + lVar21) = uVar17;\n          iVar11 = add_symbols;\n        }\n        else if (pcVar33 != \"\") {\n          uVar17 = dcgettext(0,\"\\'before=%s\\' not found\",5);\n                    \n          fatal(uVar17,pcVar33);\n        }\n        puVar29 = (undefined8 *)*puVar29;\n      }\n    }\n    bVar38 = convert_debugging != '\\0';\n    *(undefined8 *)(lVar25 + uVar24 * 8) = 0;\n    if ((bVar38) && (puStack0000000000000020 != (undefined4 *)0x0)) {\n      iVar11 = *(int *)(*(undefined8 **)(in_stack_00000008 + 8) + 1);\n      if ((iVar11 != 5) && (iVar11 != 2)) {\n        uVar17 = **(undefined8 **)(in_stack_00000008 + 8);\n        uVar16 = dcgettext(0,\"don\\'t know how to write debugging information for %s\",5);\n        bfd_nonfatal_message(0,in_stack_00000008,0,uVar16,uVar17);\nLAB_00105d8c:\n        free(puStack0000000000000020);\n        status = 1;\n        return 0;\n      }\n      in_stack_000000e0 = (void *)0x0;\n      cVar9 = write_stabs_in_sections_debugging_info_constprop_0\n                        (in_stack_00000008,puStack0000000000000020,&stack0x000000c0,&stack0x00000110\n                         ,&stack0x000000e0,&stack0x00000140);\n      if (cVar9 == '\\0') goto LAB_00105d8c;\n      lVar25 = bfd_make_section_with_flags(in_stack_00000008,\".stab\",0x2108);\n      lVar27 = bfd_make_section_with_flags(in_stack_00000008,\".stabstr\",0x2108);\n      if ((((lVar25 == 0) || (lVar27 == 0)) ||\n          (cVar9 = bfd_set_section_size(lVar25,in_stack_00000110), cVar9 == '\\0')) ||\n         (cVar9 = bfd_set_section_size(lVar27,in_stack_00000140), cVar9 == '\\0')) {\n        pcVar33 = \"can\\'t create debugging section\";\nLAB_00105eb4:\n        uVar17 = dcgettext(0,pcVar33,5);\n        bfd_nonfatal_message(0,in_stack_00000008,0,uVar17);\n        free(in_stack_000000e0);\n        free(puStack0000000000000020);\n        status = 1;\n        return 0;\n      }\n      *(undefined4 *)(lVar25 + 0x7c) = 2;\n      *(undefined4 *)(lVar27 + 0x7c) = 0;\n      cVar9 = bfd_set_section_contents\n                        (in_stack_00000008,lVar25,in_stack_000000c0,0,in_stack_00000110);\n      if ((cVar9 == '\\0') ||\n         (cVar9 = bfd_set_section_contents\n                            (in_stack_00000008,lVar27,in_stack_000000e0,0,in_stack_00000140),\n         cVar9 == '\\0')) {\n        pcVar33 = \"can\\'t set debugging section contents\";\n        goto LAB_00105eb4;\n      }\n      free(puStack0000000000000020);\n    }\n    in_stack_00000010 = uVar24 & 0xffffffff;\n  }\n  else {\n    if ((strip_symbols - 3U < 4) || ((discard_locals != 0 || (localize_hidden != '\\0'))))\n    goto LAB_00105a07;\n    lVar25 = htab_elements(strip_specific_htab);\n    if (((lVar25 != 0) ||\n        (((((((lVar25 = htab_elements(keep_specific_htab), lVar25 != 0 ||\n              (lVar25 = htab_elements(localize_specific_htab), lVar25 != 0)) ||\n             (lVar25 = htab_elements(globalize_specific_htab), lVar25 != 0)) ||\n            ((lVar25 = htab_elements(keepglobal_specific_htab), lVar25 != 0 ||\n             (lVar25 = htab_elements(weaken_specific_htab), lVar25 != 0)))) ||\n           (lVar25 = htab_elements(redefine_specific_htab), lVar25 != 0)) ||\n          (((prefix_symbols_string != (char *)0x0 || (sections_removed != '\\0')) ||\n           ((sections_copied != '\\0' ||\n            (((convert_debugging != '\\0' || (change_leading_char != '\\0')) ||\n             (remove_leading_char != '\\0')))))))) ||\n         ((section_rename_list != (char **)0x0 || (weaken != '\\0')))))) || (add_symbols != 0))\n    goto LAB_001059fe;\n  }\n  bfd_set_symtab(in_stack_00000008,osympp,in_stack_00000010 & 0xffffffff);\n  bfd_map_over_sections(unaff_R14,copy_relocations_in_section,in_stack_00000008);\n  bfd_map_over_sections(unaff_R14,copy_section,in_stack_00000008);\n  for (puVar29 = add_sections; puVar5 = update_sections, puVar29 != (undefined8 *)0x0;\n      puVar29 = (undefined8 *)*puVar29) {\n    cVar9 = bfd_set_section_contents(in_stack_00000008,puVar29[5],puVar29[4],0,puVar29[3]);\n    if (cVar9 == '\\0') {\n      bfd_nonfatal_message(0,in_stack_00000008,puVar29[5],0);\n      return 0;\n    }\n  }\n  for (; puVar5 != (undefined8 *)0x0; puVar5 = (undefined8 *)*puVar5) {\n    uVar17 = *(undefined8 *)(puVar5[5] + 0x60);\n    cVar9 = bfd_set_section_contents(in_stack_00000008,uVar17,puVar5[4],0,puVar5[3]);\n    if (cVar9 == '\\0') {\n      bfd_nonfatal_message(0,in_stack_00000008,uVar17,0);\n      return 0;\n    }\n  }\n  if (unaff_R13 == (long *)0x0) {\n    if ((merge_notes != '\\0') && (is_strip == 0)) {\n      uVar17 = *unaff_R14;\n      uVar16 = dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n      non_fatal(uVar16,uVar17);\n    }\nLAB_0010578f:\n    if ((gnu_debuglink_filename == 0) ||\n       (cVar9 = bfd_fill_in_gnu_debuglink_section(in_stack_00000008,lStack0000000000000078),\n       lVar25 = gnu_debuglink_filename, cVar9 != '\\0')) {\n      uVar10 = (**(code **)(*(long *)(in_stack_00000008 + 8) + 0x140))(unaff_R14);\n      uVar24 = (ulong)uVar10;\n      if ((char)uVar10 != '\\0') {\n        if (use_alt_mach_code == 0) {\n          return uVar24;\n        }\n        cVar9 = bfd_alt_mach_code(in_stack_00000008,use_alt_mach_code & 0xffffffff);\n        uVar20 = use_alt_mach_code;\n        if (cVar9 != '\\0') {\n          return uVar24;\n        }\n        uVar17 = dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n        non_fatal(uVar17,uVar20);\n        if (*(int *)(*(long *)(in_stack_00000008 + 8) + 8) != 5) {\n          uVar17 = dcgettext(0,\"ignoring the alternative value\",5);\n          non_fatal(uVar17);\n          return uVar24;\n        }\n        uVar17 = dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n        non_fatal(uVar17);\n        *(short *)(*(long *)(in_stack_00000008 + 0x110) + 0x3a) = (short)use_alt_mach_code;\n        return uVar24;\n      }\n      uVar17 = dcgettext(0,\"error copying private BFD data\",5);\n      bfd_nonfatal_message(0,in_stack_00000008,0,uVar17);\n    }\n    else {\n      uVar17 = dcgettext(0,\"cannot fill debug link section `%s\\'\",5);\n      bfd_nonfatal_message(0,in_stack_00000008,0,uVar17,lVar25);\n    }\n    return 0;\n  }\n  plVar32 = (long *)0x0;\n  puVar29 = *(undefined8 **)(in_stack_00000008 + 0x90);\n  do {\n    if (puVar29 == (undefined8 *)0x0) {\n      do {\n        plVar32 = (long *)unaff_R13[3];\n        free((void *)unaff_R13[1]);\n        free(unaff_R13);\n        unaff_R13 = plVar32;\n      } while (plVar32 != (long *)0x0);\n      goto LAB_0010578f;\n    }\n    if ((((merge_notes != '\\0') && (*(int *)(*(long *)(in_stack_00000008 + 8) + 8) == 5)) &&\n        (*(int *)(puVar29[0x1a] + 4) == 7)) &&\n       (cVar9 = startswith_lto_priv_0_lto_priv_0(*puVar29,\".gnu.build.attributes\"), cVar9 != '\\0'))\n    {\n      if (plVar32 == (long *)0x0) {\n        plVar32 = unaff_R13;\n      }\n      plVar15 = unaff_R13;\n      if (*(undefined8 **)(*plVar32 + 0x60) == puVar29) {\nLAB_0010625f:\n        pcVar33 = \"error: failed to merge notes\";\n        if (plVar32[1] != 0) {\n          cVar9 = bfd_set_section_contents(in_stack_00000008,puVar29,plVar32[1],0,plVar32[2]);\n          if (cVar9 == '\\0') {\n            uVar17 = dcgettext(0,\"error: failed to copy merged notes into output\",5);\n            bfd_nonfatal_message(0,in_stack_00000008,puVar29,uVar17);\n            return 0;\n          }\n          plVar32 = (long *)plVar32[3];\n          goto LAB_001061be;\n        }\n      }\n      else {\n        do {\n          plVar32 = plVar15;\n          if (*(undefined8 **)(*plVar15 + 0x60) == puVar29) goto LAB_0010625f;\n          plVar32 = (long *)plVar15[3];\n          plVar15 = plVar32;\n        } while (plVar32 != (long *)0x0);\n        pcVar33 = \"error: failed to locate merged notes\";\n      }\n      uVar17 = dcgettext(0,pcVar33,5);\n      bfd_nonfatal_message(0,in_stack_00000008,puVar29,uVar17);\n    }\nLAB_001061be:\n    puVar29 = (undefined8 *)puVar29[1];\n  } while( true );\n}\n\n",
            "called": [
                "dcgettext",
                "bfd_nonfatal_message",
                "free"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0010551d",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "FUNC_0010551d"
        },
        "FUN_00108800": {
            "renaming": {
                "FUN_00108800": "calculate_hash_00108800",
                "param_1": "inputString",
                "htab_hash_string": "hashString"
            },
            "code": "\nvoid calculateHash_00108800(undefined8 *inputString)\n\n{\n  hashString(*inputString);\n  return;\n}\n\n",
            "called": [
                "htab_hash_string"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108800",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "calculate_hash_00108800"
        },
        "FUN_00104320": {
            "renaming": {},
            "code": "\nvoid concat(void)\n\n{\n  concat();\n  return;\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104320",
            "calling": [
                "parse_stab",
                "parse_stab_type",
                "FUN_0010554f",
                "stab_demangle_template",
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "FUN_00104320"
        },
        "FUN_00104200": {
            "renaming": {},
            "code": "\nvoid bfd_hash_newfunc(void)\n\n{\n  bfd_hash_newfunc();\n  return;\n}\n\n",
            "called": [
                "bfd_hash_newfunc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104200",
            "calling": [
                "string_hash_newfunc.lto_priv.0"
            ],
            "imported": false,
            "current_name": "FUN_00104200"
        },
        "FUN_0010c1c6": {
            "renaming": {
                "FUN_0010c1c6": "process_debug_records_0010c1c6",
                "param_1": "record",
                "param_2": "data",
                "param_3": "arg1",
                "param_4": "arg2",
                "param_5": "arg3",
                "param_6": "arg4",
                "puVar1": "nextPtr",
                "cVar2": "success",
                "__ptr": "currentPtr"
            },
            "code": "\nundefined processDebugRecords_0010c1c6(undefined8 record,long data,undefined8 arg1,undefined8 arg2,\n                      undefined8 arg3,undefined8 arg4)\n\n{\n  undefined8 *nextPtr;\n  char success;\n  undefined8 *currentPtr;\n  \n  currentPtr = *(undefined8 **)(data + 0x78);\n  while( true ) {\n    if (currentPtr == (undefined8 *)0x0) {\n      *(undefined8 *)(data + 0x78) = 0;\n      return 1;\n    }\n    success = debug_record_variable\n                      (record,currentPtr[1],currentPtr[2],*(undefined4 *)(currentPtr + 3),currentPtr[4],arg4,arg3\n                      );\n    if (success == '\\0') break;\n    nextPtr = (undefined8 *)*currentPtr;\n    free(currentPtr);\n    currentPtr = nextPtr;\n  }\n  return 0;\n}\n\n",
            "called": [
                "debug_record_variable",
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c1c6",
            "calling": [
                "parse_stab",
                "finish_stab"
            ],
            "imported": false,
            "current_name": "process_debug_records_0010c1c6"
        },
        "FUN_00104560": {
            "renaming": {},
            "code": "\nvoid bfd_hash_lookup(void)\n\n{\n  bfd_hash_lookup();\n  return;\n}\n\n",
            "called": [
                "bfd_hash_lookup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104560",
            "calling": [
                "stab_typedef_type.lto_priv.0",
                "stab_write_symbol.lto_priv.0",
                "stab_typdef.lto_priv.0"
            ],
            "imported": false,
            "current_name": "FUN_00104560"
        },
        "FUN_001082df": {
            "renaming": {
                "FUN_001082df": "process_symbol_table_001082df",
                "unaff_RBX": "symbol_table",
                "unaff_RBP": "function_pointer",
                "unaff_R13": "symbol_array",
                "uVar1": "symbol_count",
                "lVar2": "symbol_address",
                "cVar3": "is_symbol_keepable",
                "puVar4": "filtered_symbols",
                "puVar5": "updated_filtered_symbols",
                "uVar6": "symbol_index"
            },
            "code": "\nvoid process_symbol_table_001082df(void)\n\n{\n  uint symbol_count;\n  long symbol_address;\n  char is_symbol_keepable;\n  long symbol_table;\n  undefined8 *filtered_symbols;\n  undefined8 *updated_filtered_symbols;\n  long function_pointer;\n  ulong symbol_index;\n  undefined8 *symbol_array;\n  \n  symbol_count = *(uint *)(symbol_table + 0x78);\n  if (strip_symbols == 7) {\n    filtered_symbols = symbol_array;\n    for (symbol_index = 0; symbol_index != symbol_count; symbol_index = symbol_index + 1) {\n      updated_filtered_symbols = filtered_symbols;\n      if (((*(long **)symbol_array[symbol_index] != (long *)0x0) &&\n          (symbol_address = **(long **)symbol_array[symbol_index], symbol_address != 0)) &&\n         (is_symbol_keepable = is_specified_symbol(*(undefined8 *)(symbol_address + 8),keep_specific_htab), is_symbol_keepable != '\\0')\n         ) {\n        updated_filtered_symbols = filtered_symbols + 1;\n        *filtered_symbols = symbol_array[symbol_index];\n      }\n      filtered_symbols = updated_filtered_symbols;\n    }\n    *filtered_symbols = 0;\n  }\n                    /* WARNING: Could not recover jumptable at 0x00115eae. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (**(code **)(*(long *)(function_pointer + 8) + 0x288))();\n  return;\n}\n\n",
            "called": [
                "is_specified_symbol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001082df",
            "calling": [
                "copy_relocations_in_section"
            ],
            "imported": false,
            "current_name": "process_symbol_table_001082df"
        },
        "FUN_00104440": {
            "renaming": {},
            "code": "\nvoid bfd_get_full_section_contents(void)\n\n{\n  bfd_get_full_section_contents();\n  return;\n}\n\n",
            "called": [
                "bfd_get_full_section_contents"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104440",
            "calling": [
                "FUN_00107880",
                "copy_section"
            ],
            "imported": false,
            "current_name": "FUN_00104440"
        },
        "FUN_00114d60": {
            "renaming": {
                "FUN_00114d60": "read_file_and_store_content_00114d60",
                "param_1": "filePath",
                "iVar1": "eofCheck",
                "piVar2": "errnoLocation",
                "pcVar3": "errorString",
                "__stream": "filePointer",
                "uVar4": "errorFormat",
                "uVar5": "allocatedBuffer",
                "__errno_location": "getErrnoLocation",
                "strerror": "getErrorMessage",
                "dcgettext": "getLocalizedErrorMessage",
                "fatal": "printErrorAndExit",
                "sVar6": "bytesRead",
                "lVar7": "currentSize",
                "lVar8": "allocatedSize"
            },
            "code": "\nvoid readFileAndStoreContent_00114d60(long filePath)\n\n{\n  int eofCheck;\n  int *errnoLocation;\n  char *errorString;\n  undefined8 errorFormat;\n  FILE *filePointer;\n  undefined8 allocatedBuffer;\n  size_t bytesRead;\n  long currentSize;\n  long allocatedSize;\n  \n  filePointer = fopen(*(char **)(filePath + 0x10),\"r\");\n  if (filePointer == (FILE *)0x0) {\n    errnoLocation = getErrnoLocation();\n    errorString = getErrorMessage(*errnoLocation);\n    allocatedBuffer = *(undefined8 *)(filePath + 0x10);\n    errorFormat = getLocalizedErrorMessage(0,\"cannot open: %s: %s\",5);\n                    \n    printErrorAndExit(errorFormat,allocatedBuffer,errorString);\n  }\n  allocatedSize = 0x1000;\n  currentSize = 0;\n  allocatedBuffer = xmalloc(0x1000);\n  *(undefined8 *)(filePath + 0x20) = allocatedBuffer;\n  while( true ) {\n    eofCheck = feof(filePointer);\n    if (eofCheck != 0) {\n      *(long *)(filePath + 0x18) = currentSize;\n      fclose(filePointer);\n      return;\n    }\n    if (currentSize == allocatedSize) {\n      allocatedSize = currentSize * 2;\n      allocatedBuffer = xrealloc(*(undefined8 *)(filePath + 0x20),allocatedSize);\n      *(undefined8 *)(filePath + 0x20) = allocatedBuffer;\n    }\n    bytesRead = fread((void *)(*(long *)(filePath + 0x20) + currentSize),1,allocatedSize - currentSize,filePointer);\n    eofCheck = ferror(filePointer);\n    if (eofCheck != 0) break;\n    currentSize = currentSize + bytesRead;\n  }\n  allocatedBuffer = *(undefined8 *)(filePath + 0x10);\n  errorFormat = getLocalizedErrorMessage(0,\"%s: fread failed\",5);\n                    \n  printErrorAndExit(errorFormat,allocatedBuffer);\n}\n\n",
            "called": [
                "section_add_load_file.cold",
                "xmalloc",
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114d60",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "read_file_and_store_content_00114d60"
        },
        "FUN_00104680": {
            "renaming": {},
            "code": "\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = setlocale(__category,__locale);\n  return pcVar1;\n}\n\n",
            "called": [
                "setlocale"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104680",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00104680"
        },
        "FUN_00108808": {
            "renaming": {
                "FUN_00108808": "find_and_print_missing_section_00108808",
                "unaff_RBP": "basePointer",
                "uVar1": "sectionAddress",
                "uVar2": "errorMessage"
            },
            "code": "\nvoid findAndPrintMissingSection_00108808(void)\n\n{\n  undefined8 sectionAddress;\n  undefined8 errorMessage;\n  long basePointer;\n  \n  sectionAddress = *(undefined8 *)(basePointer + 0x20);\n  errorMessage = dcgettext(0,\"Section %s not found\",5);\n                    \n  fatal(errorMessage,sectionAddress);\n}\n\n",
            "called": [
                "dcgettext",
                "fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108808",
            "calling": [
                "create_new_symbol"
            ],
            "imported": false,
            "current_name": "find_and_print_missing_section_00108808"
        },
        "FUN_00128418": {
            "renaming": {},
            "code": "\n\n\n\nulong strtoul(char *__nptr,char **__endptr,int __base)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strtoul@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128418",
            "calling": [
                "strtoul"
            ],
            "imported": false,
            "current_name": "FUN_00128418"
        },
        "FUN_00104d1c": {
            "renaming": {
                "FUN_00104d1c": "parse_input_lines_00104d1c",
                "uVar1": "translation",
                "ppbVar2": "slot",
                "pbVar3": "currentChar",
                "bVar4": "currentByte",
                "pbVar5": "nextLine",
                "unaff_EBP": "lineCount",
                "pbVar6": "currentLine",
                "unaff_R13": "translationTable",
                "pbVar7": "nextChar",
                "unaff_R14": "currentLineStart",
                "unaff_R15": "currentLinePtr",
                "in_stack_00000008": "fileDescriptor",
                "in_stack_00000010": "translationPtr"
            },
            "code": "\nvoid parseInputLines_00104d1c(void)\n\n{\n  undefined8 translation;\n  byte **slot;\n  byte *currentChar;\n  byte currentByte;\n  byte *nextLine;\n  int lineCount;\n  byte *currentLine;\n  undefined8 translationTable;\n  byte *nextChar;\n  byte *currentLineStart;\n  byte *currentLinePtr;\n  undefined8 fileDescriptor;\n  undefined8 *translationPtr;\n  \n  *currentLineStart = 0;\nLAB_00114520:\n  currentLineStart = currentLineStart + 1;\n  do {\n    currentByte = *currentLineStart;\n    nextChar = currentLineStart;\n    if (currentByte == 10) {\n      *currentLineStart = 0;\n      if (currentLineStart[1] == 0xd) {\n        nextChar = currentLineStart + 1;\n        nextLine = currentLineStart + 2;\n      }\n      else {\n        nextLine = currentLineStart + 1;\n      }\n    }\n    else if ((char)currentByte < '\\v') {\n      if (currentByte != 0) goto LAB_00114520;\n      nextLine = currentLineStart + 1;\n    }\n    else {\n      if (currentByte != 0xd) break;\n      *currentLineStart = 0;\n      nextLine = currentLineStart + 1;\n      if (currentLineStart[1] == 10) {\n        nextLine = currentLineStart + 2;\n        nextChar = currentLineStart + 1;\n      }\n    }\n    currentByte = *currentLinePtr;\n    while ((currentByte == 0x20 || (currentLine = currentLinePtr, currentByte == 9))) {\n      currentLine = currentLinePtr + 1;\n      currentLinePtr = currentLinePtr + 1;\n      currentByte = *currentLine;\n    }\n    do {\n      if ((currentByte == 10) || (currentByte == 0xd)) goto LAB_00114676;\n      if (currentByte == 0) goto LAB_00114599;\n      currentByte = currentLine[1];\n      currentLine = currentLine + 1;\n    } while ((currentByte != 0x20) && (currentByte != 9));\n    if ((char)currentByte < '\\x0e') {\nLAB_00114676:\n      if ((-0x2402L >> (currentByte & 0x3f) & 1U) != 0) goto LAB_001145e6;\n    }\n    else {\nLAB_001145e6:\n      currentByte = currentLine[1];\n      if ((((((currentByte == 9) || (currentByte == 0x20)) &&\n            ((currentByte = currentLine[2], currentByte == 9 || (currentByte == 0x20)))) &&\n           ((currentByte = currentLine[3], currentByte == 9 || (currentByte == 0x20)))) &&\n          ((currentByte = currentLine[4], currentByte == 9 || (currentByte == 0x20)))) &&\n         ((currentByte = currentLine[5], currentByte == 9 || (currentByte == 0x20)))) {\n        currentByte = currentLine[6];\n        currentChar = currentLine + 6;\n        if ((currentByte == 9) || (currentByte == 0x20)) {\n          do {\n            do {\n              currentByte = currentChar[1];\n              currentChar = currentChar + 1;\n            } while (currentByte == 0x20);\n          } while (currentByte == 9);\n        }\n      }\n      if ((0xd < currentByte) || ((-0x2402L >> (currentByte & 0x3f) & 1U) != 0)) {\n        translation = dcgettext(0,\"%s:%d: Ignoring rubbish found on this line\",5);\n        non_fatal(translation,fileDescriptor,lineCount);\n      }\n    }\nLAB_00114599:\n    *currentLine = 0;\n    if (currentLinePtr < currentLine) {\n      slot = (byte **)htab_find_slot();\n      *slot = currentLinePtr;\n    }\n    lineCount = lineCount + 1;\n    currentLineStart = nextLine;\n    currentLinePtr = nextLine;\n    if (nextChar[1] == 0) {\n      *translationPtr = translationTable;\n      return;\n    }\n  } while( true );\n  if (currentByte == 0x23) {\n    parseInputLines_00104d1c();\n    return;\n  }\n  goto LAB_00114520;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104d1c",
            "calling": [
                "FUN_00104cc1"
            ],
            "imported": false,
            "current_name": "parse_input_lines_00104d1c"
        },
        "FUN_00119940": {
            "renaming": {
                "FUN_00119940": "check_and_handle_bad_number_00119940",
                "param_1": "vma",
                "param_2": "message",
                "uVar1": "translatedMessage",
                "local_20": "vmaString"
            },
            "code": "\nvoid checkAndHandleBadNumber_00119940(undefined8 vma,undefined8 message)\n\n{\n  undefined8 translatedMessage;\n  char *vmaString [2];\n  \n  bfd_scan_vma(vma,vmaString,0);\n  if (*vmaString[0] == '\\0') {\n    return;\n  }\n  translatedMessage = dcgettext(0,\"%s: bad number: %s\",5);\n                    \n  fatal(translatedMessage,message,vma);\n}\n\n",
            "called": [
                "parse_vma.cold",
                "bfd_scan_vma"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00119940",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "check_and_handle_bad_number_00119940"
        },
        "FUN_0010540e": {
            "renaming": {
                "FUN_0010540e": "execute_operation_0010540e",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "in_RAX": "tempVar"
            },
            "code": "\nvoid executeOperation_0010540e(undefined8 param1,long param2,uint param3)\n\n{\n  long tempVar;\n  \n  if ((param3 == 2) && (*(int *)(*(long *)(param2 + 8) + 8) == 2)) {\n    param3 = (uint)*(byte *)(*(long *)(*(long *)(param2 + 8) + 0x380) + 0x71);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00105422. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (**(code **)(*(long *)(tempVar + 0x380) + 0x78))(param1,param3 != 0);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010540e",
            "calling": [
                "set_long_section_mode"
            ],
            "imported": false,
            "current_name": "execute_operation_0010540e"
        },
        "FUN_00104210": {
            "renaming": {},
            "code": "\n\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fclose(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fclose"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104210",
            "calling": [
                "main",
                "FUN_00107880",
                "FUN_00114dc7",
                "add_specific_symbols"
            ],
            "imported": false,
            "current_name": "FUN_00104210"
        },
        "FUN_00104450": {
            "renaming": {},
            "code": "\nvoid bfd_hash_allocate(void)\n\n{\n  bfd_hash_allocate();\n  return;\n}\n\n",
            "called": [
                "bfd_hash_allocate"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104450",
            "calling": [
                "string_hash_newfunc.lto_priv.0"
            ],
            "imported": false,
            "current_name": "FUN_00104450"
        },
        "FUN_00104330": {
            "renaming": {},
            "code": "\nvoid bfd_set_section_contents(void)\n\n{\n  bfd_set_section_contents();\n  return;\n}\n\n",
            "called": [
                "bfd_set_section_contents"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104330",
            "calling": [
                "FUN_0010554f",
                "copy_section"
            ],
            "imported": false,
            "current_name": "FUN_00104330"
        },
        "FUN_00104690": {
            "renaming": {},
            "code": "\nvoid bfd_openw(void)\n\n{\n  bfd_openw();\n  return;\n}\n\n",
            "called": [
                "bfd_openw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104690",
            "calling": [
                "copy_file",
                "FUN_00104ea2",
                "do_display_target"
            ],
            "imported": false,
            "current_name": "FUN_00104690"
        },
        "FUN_00104570": {
            "renaming": {},
            "code": "\nvoid bfd_get_arch(void)\n\n{\n  bfd_get_arch();\n  return;\n}\n\n",
            "called": [
                "bfd_get_arch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104570",
            "calling": [
                "FUN_00105828",
                "FUN_00107976",
                "FUN_00104ea2",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "FUN_00104570"
        },
        "FUN_00128408": {
            "renaming": {},
            "code": "\n\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* vfprintf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128408",
            "calling": [
                "vfprintf"
            ],
            "imported": false,
            "current_name": "FUN_00128408"
        },
        "FUN_00113a4d": {
            "renaming": {
                "FUN_00113a4d": "process_function_00113a4d",
                "param_1": "output_file",
                "param_2": "debugger",
                "param_3": "function_info",
                "param_4": "temp_param",
                "param_5": "temp_param2",
                "cVar1": "result",
                "uVar2": "temp_result",
                "puVar3": "current_name",
                "auVar4": "write_result"
            },
            "code": "\nundefined8\nprocess_function_00113a4d(undefined8 output_file,undefined8 debugger,long function_info,undefined8 temp_param,\n            undefined8 temp_param2)\n\n{\n  char result;\n  undefined8 temp_result;\n  undefined8 *current_name;\n  undefined write_result [16];\n  \n  result = debug_write_linenos_constprop_0(output_file,debugger,*(undefined8 *)(function_info + 0x18));\n  if ((result != '\\0') &&\n     (((*(long *)(function_info + 0x28) == 0 && (*(long *)(function_info + 8) != 0)) ||\n      (result = stab_start_block_lto_priv_0(debugger,*(undefined8 *)(function_info + 0x18)), result != '\\0'))\n     )) {\n    if (*(undefined8 **)(function_info + 0x28) != (undefined8 *)0x0) {\n      for (current_name = (undefined8 *)**(undefined8 **)(function_info + 0x28); current_name != (undefined8 *)0x0;\n          current_name = (undefined8 *)*current_name) {\n        result = debug_write_name_constprop_0(output_file,debugger,current_name);\n        if (result == '\\0') {\n          return 0;\n        }\n      }\n    }\n    for (current_name = *(undefined8 **)(function_info + 0x10); current_name != (undefined8 *)0x0;\n        current_name = (undefined8 *)*current_name) {\n      result = process_function_00113a4d(output_file,debugger,current_name);\n      if (result == '\\0') {\n        return 0;\n      }\n    }\n    write_result = debug_write_linenos_constprop_0(output_file,debugger,*(undefined8 *)(function_info + 0x20));\n    if (write_result[0] != '\\0') {\n      if ((*(long *)(function_info + 0x28) == 0) && (*(long *)(function_info + 8) != 0)) {\n        return write_result._0_8_;\n      }\n      temp_result = stab_end_block_lto_priv_0\n                        (debugger,*(undefined8 *)(function_info + 0x20),write_result._8_8_,temp_param2);\n      return temp_result;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "stab_start_block.lto_priv.0",
                "debug_write_linenos.constprop.0",
                "debug_write_name.constprop.0",
                "stab_end_block.lto_priv.0",
                "debug_write_block.constprop.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113a4d",
            "calling": [
                "debug_write_name.constprop.0",
                "debug_write_block.constprop.0"
            ],
            "imported": false,
            "current_name": "process_function_00113a4d"
        },
        "FUN_001081e9": {
            "renaming": {
                "FUN_001081e9": "release_memory_001081e9",
                "in_RAX": "return_value",
                "unaff_RBX": "memory_to_release",
                "param_7": "return_value"
            },
            "code": "\nundefined8 release_memory_001081e9(void)\n\n{\n  undefined8 return_value;\n  void *memory_to_release;\n  undefined8 return_value;\n  \n  return_value = return_value;\n  free(memory_to_release);\n  return return_value;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001081e9",
            "calling": [
                "make_tempdir"
            ],
            "imported": false,
            "current_name": "release_memory_001081e9"
        },
        "FUN_00104100": {
            "renaming": {},
            "code": "\n\n\nchar * strcpy(char *__dest,char *__src)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strcpy(__dest,__src);\n  return pcVar1;\n}\n\n",
            "called": [
                "strcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104100",
            "calling": [
                "main",
                "setup_section",
                "parse_stab_type",
                "FUN_0010554f",
                "stab_method_type.lto_priv.0",
                "display_info.isra.0",
                "stab_end_class_type.lto_priv.0",
                "write_stabs_in_sections_debugging_info.constprop.0"
            ],
            "imported": false,
            "current_name": "FUN_00104100"
        },
        "FUN_00104340": {
            "renaming": {},
            "code": "\n\n\nint fnmatch(char *__pattern,char *__name,int __flags)\n\n{\n  int iVar1;\n  \n  iVar1 = fnmatch(__pattern,__name,__flags);\n  return iVar1;\n}\n\n",
            "called": [
                "fnmatch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104340",
            "calling": [
                "find_section_list",
                "is_specified_symbol_predicate"
            ],
            "imported": false,
            "current_name": "FUN_00104340"
        },
        "FUN_00104220": {
            "renaming": {},
            "code": "\nvoid bindtextdomain(void)\n\n{\n  bindtextdomain();\n  return;\n}\n\n",
            "called": [
                "bindtextdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104220",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00104220"
        },
        "FUN_00113b71": {
            "renaming": {
                "FUN_00113b71": "create_type_constprop_00113b71",
                "param_1": "inputValue",
                "lVar1": "result",
                "debug_make_type_constprop_0": "allocate_memory"
            },
            "code": "\nlong create_type_constprop_00113b71(long inputValue)\n\n{\n  long result;\n  \n  if (inputValue != 0) {\n    result = allocate_memory(0x14,0);\n    if (result == 0) {\n      result = 0;\n    }\n    else {\n      *(long *)(result + 0x10) = inputValue;\n    }\n    return result;\n  }\n  return 0;\n}\n\n",
            "called": [
                "debug_make_type.constprop.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113b71",
            "calling": [
                "stab_demangle_v3_arg",
                "parse_stab_type",
                "stab_demangle_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "create_type_constprop_00113b71"
        },
        "FUN_00104580": {
            "renaming": {},
            "code": "\nvoid htab_traverse(void)\n\n{\n  htab_traverse();\n  return;\n}\n\n",
            "called": [
                "htab_traverse"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104580",
            "calling": [
                "FUN_0010554f",
                "is_specified_symbol"
            ],
            "imported": false,
            "current_name": "FUN_00104580"
        },
        "FUN_00104460": {
            "renaming": {},
            "code": "\nvoid bfd_set_symtab(void)\n\n{\n  bfd_set_symtab();\n  return;\n}\n\n",
            "called": [
                "bfd_set_symtab"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104460",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "FUN_00104460"
        },
        "FUN_00109dfe": {
            "renaming": {
                "FUN_00109dfe": "push_defined_type_or_string_value_00109dfe",
                "param_1": "functionContext",
                "local_40": "resultString",
                "lVar1": "currentValue"
            },
            "code": "\nvoid pushDefinedTypeOrStringValue_00109dfe(long functionContext)\n\n{\n  long currentValue;\n  char resultString [40];\n  \n  if (*(long *)(functionContext + 0x70) != 0) {\n    stab_push_defined_type(functionContext,*(long *)(functionContext + 0x70),0);\n    return;\n  }\n  currentValue = *(long *)(functionContext + 0x68);\n  *(long *)(functionContext + 0x68) = currentValue + 1;\n  *(long *)(functionContext + 0x70) = currentValue;\n  sprintf(resultString,\"%ld=%ld\",currentValue,currentValue);\n  stab_push_string(functionContext,resultString,currentValue,1,0);\n  return;\n}\n\n",
            "called": [
                "stab_push_string",
                "sprintf",
                "stab_push_defined_type"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109dfe",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "push_defined_type_or_string_value_00109dfe"
        },
        "FUN_00109bbb": {
            "renaming": {
                "FUN_00109bbb": "append_to_end_with_semicolon_00109bbb",
                "param_1": "inputValue",
                "__s": "stringPointer",
                "sVar1": "stringLength"
            },
            "code": "\nbool appendToEndWithSemicolon_00109bbb(long inputValue)\n\n{\n  char *stringPointer;\n  size_t stringLength;\n  \n  if (*(long *)(inputValue + 0x60) != 0) {\n    stringPointer = *(char **)(*(long *)(inputValue + 0x60) + 0x30);\n    if (stringPointer != (char *)0x0) {\n      stringLength = strlen(stringPointer);\n      *(undefined2 *)(stringPointer + stringLength) = 0x3b;\n    }\n    return stringPointer != (char *)0x0;\n  }\n  return false;\n}\n\n",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109bbb",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "append_to_end_with_semicolon_00109bbb"
        },
        "FUN_0010ae0e": {
            "renaming": {
                "FUN_0010ae0e": "extracted_function_0010ae0e",
                "param_1": "input",
                "lVar1": "ptr1",
                "lVar2": "ptr2",
                "__ptr": "ptr3",
                "pcVar3": "str1",
                "sVar4": "len1",
                "sVar5": "len2",
                "pcVar6": "str2",
                "uVar7": "result",
                "lVar8": "totalLen",
                "uVar9": "counter",
                "uVar10": "count"
            },
            "code": "\nundefined8 extractedFunction_0010ae0e(long input)\n\n{\n  long ptr1;\n  long ptr2;\n  void *ptr3;\n  char *str1;\n  size_t len1;\n  size_t len2;\n  char *str2;\n  undefined8 result;\n  long totalLen;\n  uint counter;\n  ulong count;\n  \n  result = 0;\n  ptr1 = *(long *)(input + 0x60);\n  if (((ptr1 != 0) && (*(char **)(ptr1 + 8) != (char *)0x0)) &&\n     (str2 = *(char **)(ptr1 + 0x20), str2 != (char *)0x0)) {\n    len1 = strlen(*(char **)(ptr1 + 8));\n    len2 = strlen(str2);\n    ptr2 = *(long *)(ptr1 + 0x28);\n    if (ptr2 == 0) {\n      totalLen = len1 + len2 + 10;\n      count = 0;\n    }\n    else {\n      totalLen = len1 + len2 + 0x1e;\n      count = 0;\n      while( true ) {\n        str2 = *(char **)(ptr2 + count * 8);\n        if (str2 == (char *)0x0) break;\n        len1 = strlen(str2);\n        count = (ulong)((int)count + 1);\n        totalLen = totalLen + len1;\n      }\n    }\n    if (*(char **)(ptr1 + 0x30) != (char *)0x0) {\n      len1 = strlen(*(char **)(ptr1 + 0x30));\n      totalLen = totalLen + len1;\n    }\n    if (*(char **)(ptr1 + 0x38) != (char *)0x0) {\n      len1 = strlen(*(char **)(ptr1 + 0x38));\n      totalLen = totalLen + len1;\n    }\n    str2 = (char *)xmalloc(totalLen);\n    ptr1 = *(long *)(input + 0x60);\n    strcpy(str2,*(char **)(ptr1 + 8));\n    if (*(long *)(ptr1 + 0x28) != 0) {\n      counter = 0;\n      len1 = strlen(str2);\n      sprintf(str2 + len1,\"!%u,\",count);\n      while( true ) {\n        ptr1 = *(long *)(input + 0x60);\n        count = (ulong)counter;\n        ptr3 = *(void **)(ptr1 + 0x28);\n        str1 = *(char **)((long)ptr3 + count * 8);\n        if (str1 == (char *)0x0) break;\n        counter = counter + 1;\n        strcat(str2,str1);\n        free(*(void **)(*(long *)(ptr1 + 0x28) + count * 8));\n      }\n      free(ptr3);\n      *(undefined8 *)(*(long *)(input + 0x60) + 0x28) = 0;\n    }\n    ptr1 = *(long *)(input + 0x60);\n    strcat(str2,*(char **)(ptr1 + 0x20));\n    free(*(void **)(ptr1 + 0x20));\n    ptr1 = *(long *)(input + 0x60);\n    *(undefined8 *)(ptr1 + 0x20) = 0;\n    if (*(char **)(ptr1 + 0x30) != (char *)0x0) {\n      strcat(str2,*(char **)(ptr1 + 0x30));\n      free(*(void **)(ptr1 + 0x30));\n      *(undefined8 *)(*(long *)(input + 0x60) + 0x30) = 0;\n    }\n    len1 = strlen(str2);\n    ptr1 = *(long *)(input + 0x60);\n    *(undefined2 *)(str2 + len1) = 0x3b;\n    str1 = *(char **)(ptr1 + 0x38);\n    if (str1 != (char *)0x0) {\n      strcpy(str2 + len1 + 1,str1);\n      free(*(void **)(ptr1 + 0x38));\n      *(undefined8 *)(*(long *)(input + 0x60) + 0x38) = 0;\n    }\n    free(*(void **)(*(long *)(input + 0x60) + 8));\n    ptr1 = *(long *)(input + 0x60);\n    *(char **)(ptr1 + 8) = str2;\n    result = CONCAT71((int7)((ulong)ptr1 >> 8),1);\n  }\n  return result;\n}\n\n",
            "called": [
                "strcat",
                "strcpy",
                "strlen",
                "sprintf",
                "free",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010ae0e",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "extracted_function_0010ae0e"
        },
        "FUN_001135a5": {
            "renaming": {
                "FUN_001135a5": "write_and_transform_001135a5",
                "param_1": "outputStream",
                "param_2": "inputStream",
                "param_3": "functionInfo",
                "iVar1": "numParams",
                "cVar2": "success",
                "uVar3": "result",
                "puVar4": "currParam",
                "puVar5": "currBlock"
            },
            "code": "\nundefined8 writeAndTransform_001135a5(undefined8 outputStream,undefined8 inputStream,long functionInfo)\n\n{\n  int numParams;\n  char success;\n  undefined8 result;\n  undefined8 *currParam;\n  undefined8 *currBlock;\n  \n  if (6 < *(uint *)(functionInfo + 0x14)) {\n                    \n    abort();\n  }\n  switch(*(undefined4 *)(functionInfo + 0x14)) {\n  case 0:\n    success = debug_write_type_constprop_0(outputStream,inputStream,*(undefined8 *)(functionInfo + 0x20),functionInfo);\n    if (success != '\\0') {\n      result = stab_typdef_lto_priv_0(inputStream,*(undefined8 *)(functionInfo + 8));\n      return result;\n    }\n    break;\n  case 1:\n    success = debug_write_type_constprop_0(outputStream,inputStream,*(undefined8 *)(functionInfo + 0x20),functionInfo);\n    if (success != '\\0') {\n      result = stab_tag_lto_priv_0(inputStream,*(undefined8 *)(functionInfo + 8));\n      return result;\n    }\n    break;\n  case 2:\n    success = debug_write_type_constprop_0\n                      (outputStream,inputStream,*(undefined8 *)(*(long *)(functionInfo + 0x20) + 8),0);\n    if (success != '\\0') {\n      result = stab_variable_lto_priv_0\n                        (inputStream,*(undefined8 *)(functionInfo + 8),**(undefined4 **)(functionInfo + 0x20),\n                         *(undefined8 *)(*(undefined4 **)(functionInfo + 0x20) + 4));\n      return result;\n    }\n    break;\n  case 3:\n    currBlock = *(undefined8 **)(functionInfo + 0x20);\n    numParams = *(int *)(functionInfo + 0x18);\n    result = *(undefined8 *)(functionInfo + 8);\n    success = debug_write_linenos_constprop_0(outputStream,inputStream,*(undefined8 *)(currBlock[2] + 0x18));\n    if (((success != '\\0') &&\n        (success = debug_write_type_constprop_0(outputStream,inputStream,*currBlock,0), success != '\\0')) &&\n       (success = stab_start_function_lto_priv_0(inputStream,result,numParams == 2), success != '\\0')) {\n      for (currParam = (undefined8 *)currBlock[1]; currParam != (undefined8 *)0x0;\n          currParam = (undefined8 *)*currParam) {\n        success = debug_write_type_constprop_0(outputStream,inputStream,currParam[2],0);\n        if (success == '\\0') {\n          return 0;\n        }\n        success = stab_function_parameter_lto_priv_0(inputStream,currParam[1],*(undefined4 *)(currParam + 3));\n        if (success == '\\0') {\n          return 0;\n        }\n      }\n      currBlock = (undefined8 *)currBlock[2];\n      while( true ) {\n        if (currBlock == (undefined8 *)0x0) {\n          result = stab_end_function_lto_priv_0(inputStream);\n          return result;\n        }\n        success = debug_write_block_constprop_0(outputStream,inputStream,currBlock);\n        if (success == '\\0') break;\n        currBlock = (undefined8 *)*currBlock;\n      }\n    }\n    break;\n  case 4:\n    result = stab_int_constant_lto_priv_0\n                      (inputStream,*(undefined8 *)(functionInfo + 8),*(undefined8 *)(functionInfo + 0x20));\n    return result;\n  case 5:\n    result = stab_float_constant_lto_priv_0\n                      (*(undefined8 *)(functionInfo + 0x20),inputStream,*(undefined8 *)(functionInfo + 8));\n    return result;\n  case 6:\n    success = debug_write_type_constprop_0(outputStream,inputStream,**(undefined8 **)(functionInfo + 0x20),0);\n    if (success != '\\0') {\n      result = stab_typed_constant_lto_priv_0\n                        (inputStream,*(undefined8 *)(functionInfo + 8),\n                         *(undefined8 *)(*(long *)(functionInfo + 0x20) + 8));\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "stab_end_function.lto_priv.0",
                "stab_variable.lto_priv.0",
                "debug_write_linenos.constprop.0",
                "abort",
                "stab_tag.lto_priv.0",
                "stab_typed_constant.lto_priv.0",
                "stab_start_function.lto_priv.0",
                "stab_typdef.lto_priv.0",
                "debug_write_block.constprop.0",
                "stab_int_constant.lto_priv.0",
                "debug_write_type.constprop.0",
                "stab_float_constant.lto_priv.0",
                "stab_function_parameter.lto_priv.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001135a5",
            "calling": [
                "write_stabs_in_sections_debugging_info.constprop.0",
                "debug_write_block.constprop.0"
            ],
            "imported": false,
            "current_name": "write_and_transform_001135a5"
        },
        "FUN_00107976": {
            "renaming": {
                "FUN_00107976": "FUNC_00107976"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong FUNC_00107976(void)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  undefined *puVar3;\n  long *plVar4;\n  code *pcVar5;\n  long *plVar6;\n  ulong uVar7;\n  ulong uVar8;\n  char *__s;\n  char cVar9;\n  char cVar10;\n  uint uVar11;\n  int iVar12;\n  int iVar13;\n  undefined4 uVar14;\n  long *plVar15;\n  long lVar16;\n  undefined8 uVar17;\n  undefined8 uVar18;\n  size_t sVar19;\n  size_t sVar20;\n  char *pcVar21;\n  void *__ptr;\n  void *__ptr_00;\n  ulong uVar22;\n  long lVar23;\n  ulong uVar24;\n  undefined8 *in_RAX;\n  undefined8 uVar25;\n  char *pcVar26;\n  int *piVar27;\n  long lVar28;\n  ulong uVar29;\n  FILE *__s_00;\n  long **pplVar30;\n  uint uVar31;\n  long **__ptr_01;\n  char *pcVar32;\n  undefined8 *puVar33;\n  ulong uVar34;\n  int iVar35;\n  long **pplVar36;\n  long unaff_RBP;\n  undefined4 *puVar37;\n  undefined8 *puVar38;\n  char **ppcVar39;\n  void *pvVar40;\n  undefined8 *unaff_R14;\n  undefined **ppuVar41;\n  bool bVar42;\n  byte bVar43;\n  undefined8 *param_7;\n  ulong param_8;\n  char in_stack_00000018;\n  undefined4 *puStack0000000000000020;\n  char *pcStack0000000000000038;\n  uint uStack0000000000000048;\n  int iStack000000000000006c;\n  long lStack0000000000000078;\n  long lStack0000000000000088;\n  char *pcStack0000000000000090;\n  long lStack00000000000000a0;\n  long *in_stack_000000c0;\n  ulong in_stack_000000c8;\n  long in_stack_000000d0;\n  long in_stack_000000d8;\n  void *in_stack_000000e0;\n  long in_stack_000000f0;\n  undefined8 in_stack_000000f8;\n  byte bStack0000000000000100;\n  byte bStack0000000000000101;\n  undefined8 in_stack_00000110;\n  ushort in_stack_00000118;\n  char *in_stack_00000140;\n  char cStack0000000000000148;\n  char *in_stack_00000150;\n  undefined uStack0000000000000158;\n  short sStack000000000000015a;\n  \n  bVar43 = 0;\n  uVar18 = *in_RAX;\n  uVar17 = *param_7;\n  uVar25 = bfd_get_archive_filename();\n  pcVar26 = (char *)dcgettext(0,\"copy from `%s\\' [%s] to `%s\\' [%s]\\n\",5);\n  printf(pcVar26,uVar25,uVar18,uVar17);\n  if ((*(byte *)(param_7 + 9) & 7) == 3) {\n    iVar13 = bfd_get_arch();\n    uVar14 = bfd_get_mach();\n    if (unaff_RBP != 0) {\n      uVar29 = FUNC_001152b6();\n      return uVar29;\n    }\n    goto LAB_00114f9a;\n  }\n  uVar31 = ~bfd_flags_to_clear & *(uint *)(param_7[1] + 0x14) &\n           (bfd_flags_to_set | *(uint *)((long)unaff_R14 + 0x44));\n  if (strip_symbols == 7) {\n    uVar31 = uVar31 & 0xfffffffe;\n    cVar10 = bfd_set_start_address(param_7);\n  }\n  else {\n    cVar10 = bfd_set_start_address(param_7);\n  }\n  if ((cVar10 == '\\0') || (cVar10 = bfd_set_file_flags(param_7,uVar31), cVar10 == '\\0'))\n  goto LAB_00107a82;\n  iVar13 = bfd_get_arch();\n  uVar14 = bfd_get_mach();\n  if (unaff_RBP == 0) {\nLAB_00114f9a:\n    if (((iVar13 == 0) && (*(int *)(unaff_R14[1] + 8) != 5)) && (*(int *)(param_7[1] + 8) == 5)) {\n      uVar29 = FUNC_00107880();\n      return uVar29;\n    }\n  }\n  else {\n    if (iVar13 == 0) {\n      iVar13 = *(int *)(unaff_RBP + 0xc);\n      uVar14 = *(undefined4 *)(unaff_RBP + 0x10);\n      goto LAB_00114f9a;\n    }\n    uVar18 = bfd_get_archive_filename();\n    uVar17 = dcgettext(0,\"Input file `%s\\' ignores binary architecture parameter.\",5);\n    non_fatal(uVar17,uVar18);\n  }\n  cVar10 = (**(code **)(param_7[1] + 0x2a0))(param_7,iVar13,uVar14);\n  if (cVar10 == '\\0') {\n    if ((*(byte *)(unaff_R14 + 9) & 0x40) != 0) {\n      iVar13 = bfd_get_arch();\n      if (iVar13 == 0) {\n        uVar18 = bfd_get_archive_filename();\n        uVar17 = dcgettext(0,\"Unable to recognise the format of the input file `%s\\'\",5);\n        non_fatal(uVar17,uVar18);\n        return 0;\n      }\n      uVar18 = bfd_get_mach();\n      uVar14 = bfd_get_arch();\n      uVar18 = bfd_printable_arch_mach(uVar14,uVar18);\n      uVar17 = dcgettext(0,\"Output file cannot represent architecture `%s\\'\",5);\n      non_fatal(uVar17,uVar18);\n      return 0;\n    }\n    iVar13 = bfd_get_arch();\n    iVar35 = bfd_get_arch(param_7);\n    if (iVar13 != iVar35) {\n      uVar29 = check_file_format_00105828();\n      return uVar29;\n    }\n  }\n  cVar10 = bfd_set_format(param_7,*(byte *)(unaff_R14 + 9) & 7);\n  if (cVar10 == '\\0') {\nLAB_00107a82:\n    bfd_nonfatal_message(0);\n    return 0;\n  }\n  if ((*(int *)((undefined8 *)param_7[1] + 1) == 2) &&\n     (cVar10 = startswith_lto_priv_0_lto_priv_0(*(undefined8 *)param_7[1],&DAT_0011b503),\n     cVar10 != '\\0')) {\n    lVar28 = param_7[0x22];\n    if ((*(int *)((undefined8 *)unaff_R14[1] + 1) == 2) &&\n       (cVar10 = startswith_lto_priv_0_lto_priv_0(*(undefined8 *)unaff_R14[1],&DAT_0011b503),\n       cVar10 != '\\0')) {\n      lVar16 = unaff_R14[0x22];\n      bVar42 = preserve_dates == '\\0';\n      puVar33 = (undefined8 *)(lVar16 + 200);\n      puVar38 = (undefined8 *)(lVar28 + 200);\n      for (lVar23 = 0x32; lVar23 != 0; lVar23 = lVar23 + -1) {\n        *puVar38 = *puVar33;\n        puVar33 = puVar33 + (ulong)bVar43 * -2 + 1;\n        puVar38 = puVar38 + (ulong)bVar43 * -2 + 1;\n      }\n      if (bVar42) {\n        *(undefined4 *)(lVar28 + 0x2a4) = 0xffffffff;\n      }\n      else {\n        *(int *)(lVar28 + 0x2a4) = (int)*(undefined8 *)(lVar16 + 0xa8);\n      }\n    }\n    uVar29 = pe_file_alignment;\n    if (pe_file_alignment == 0xffffffffffffffff) {\n      pe_file_alignment = 0x200;\n      uVar29 = 0x200;\n    }\n    else {\n      *(int *)(lVar28 + 0x10c) = (int)pe_file_alignment;\n    }\n    if (pe_heap_commit != -1) {\n      *(long *)(lVar28 + 0x148) = pe_heap_commit;\n    }\n    if (pe_heap_reserve != -1) {\n      *(long *)(lVar28 + 0x148) = pe_heap_reserve;\n    }\n    if (pe_image_base != -1) {\n      *(long *)(lVar28 + 0x100) = pe_image_base;\n    }\n    uVar22 = pe_section_alignment;\n    if (pe_section_alignment == 0xffffffffffffffff) {\n      pe_section_alignment = 0x1000;\n      uVar22 = 0x1000;\n    }\n    else {\n      *(int *)(lVar28 + 0x108) = (int)pe_section_alignment;\n    }\n    if (pe_stack_commit != -1) {\n      *(long *)(lVar28 + 0x138) = pe_stack_commit;\n    }\n    if (pe_stack_reserve != -1) {\n      *(long *)(lVar28 + 0x138) = pe_stack_reserve;\n    }\n    if (pe_subsystem != -1) {\n      *(short *)(lVar28 + 300) = pe_subsystem;\n    }\n    if (pe_major_subsystem_version != -1) {\n      *(short *)(lVar28 + 0x118) = pe_major_subsystem_version;\n    }\n    if (pe_minor_subsystem_version != -1) {\n      *(short *)(lVar28 + 0x11a) = pe_minor_subsystem_version;\n    }\n    if (uVar22 < uVar29) {\n      uVar18 = dcgettext(0,\"warning: file alignment (0x%lx) > section alignment (0x%lx)\",5);\n      non_fatal(uVar18,uVar29,uVar22);\n    }\n  }\n  plVar6 = isympp;\n  free(isympp);\n  if (plVar6 == osympp) {\n    isympp = (long *)0x0;\n    osympp = (long *)0x0;\n    lVar28 = (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  else {\n    free(osympp);\n    isympp = (long *)0x0;\n    osympp = (long *)0x0;\n    lVar28 = (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  if (lVar28 < 0) goto LAB_00107a82;\n  osympp = (long *)xmalloc();\n  isympp = osympp;\n  param_8 = (**(code **)(unaff_R14[1] + 0x200))();\n  if ((long)param_8 < 0) goto LAB_00107a82;\n  if (param_8 == 0) {\n    free(isympp);\n    isympp = (long *)0x0;\n    osympp = (long *)0x0;\n  }\n  bfd_map_over_sections();\n  puVar33 = add_sections;\n  if ((extract_symbol == '\\0') &&\n     (cVar10 = (**(code **)(param_7[1] + 0x168))(), puVar33 = add_sections, cVar10 == '\\0')) {\n    status = 1;\n    dcgettext(0,\"error in private header data\",5);\n    bfd_nonfatal_message(0);\n    puVar33 = add_sections;\n  }\n  for (; puVar38 = update_sections, puVar33 != (undefined8 *)0x0; puVar33 = (undefined8 *)*puVar33)\n  {\n    uVar31 = 0x128;\n    lVar28 = find_section_list(puVar33[1],0,0x80);\n    if (lVar28 != 0) {\n      uVar31 = check_new_section_flags(*(uint *)(lVar28 + 0x28) | 0x100,param_7,puVar33[1]);\n    }\n    lVar28 = bfd_get_section_by_name(param_7,puVar33[1]);\n    if (lVar28 != 0) {\n      uVar18 = puVar33[1];\n      uVar17 = dcgettext(0,\"can\\'t add section \\'%s\\'\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar17,uVar18);\n      return 0;\n    }\n    lVar28 = bfd_make_section_with_flags(param_7,puVar33[1],uVar31 | 0x100000);\n    puVar33[5] = lVar28;\n    if (lVar28 == 0) {\n      uVar18 = puVar33[1];\n      uVar17 = dcgettext(0,\"can\\'t create section `%s\\'\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar17,uVar18);\n      return 0;\n    }\n    cVar10 = bfd_set_section_size();\n    if (cVar10 == '\\0') {\n      bfd_nonfatal_message(0,param_7,puVar33[5],0);\n      return 0;\n    }\n    lVar28 = find_section_list(puVar33[1],0,0x18);\n    if (lVar28 != 0) {\n      uVar18 = *(undefined8 *)(lVar28 + 0x18);\n      lVar28 = puVar33[5];\n      *(byte *)(lVar28 + 0x28) = *(byte *)(lVar28 + 0x28) | 1;\n      *(undefined8 *)(lVar28 + 0x30) = uVar18;\n      *(undefined8 *)(lVar28 + 0x38) = uVar18;\n    }\n    lVar28 = find_section_list(puVar33[1],0,0x60);\n    if (lVar28 != 0) {\n      lVar16 = puVar33[5];\n      *(undefined8 *)(lVar16 + 0x38) = *(undefined8 *)(lVar28 + 0x20);\n      if (0x3e < *(uint *)(lVar16 + 0x7c)) {\n        bfd_nonfatal_message(0,param_7,lVar16,0);\n        return 0;\n      }\n    }\n  }\n  for (; puVar38 != (undefined8 *)0x0; puVar38 = (undefined8 *)*puVar38) {\n    lVar28 = bfd_get_section_by_name();\n    puVar38[5] = lVar28;\n    if (lVar28 == 0) {\n      uVar18 = puVar38[1];\n      uVar17 = dcgettext(0,\"error: %s not found, can\\'t be updated\",5);\n      non_fatal(uVar17,uVar18);\n      return 0;\n    }\n    uVar18 = *(undefined8 *)(lVar28 + 0x60);\n    cVar10 = bfd_set_section_size(uVar18);\n    if (cVar10 == '\\0') {\n      bfd_nonfatal_message(0,param_7,uVar18,0);\n      return 0;\n    }\n  }\n  puVar33 = dump_sections;\n  if (merge_notes == '\\0') {\n    __ptr_01 = (long **)0x0;\n  }\n  else {\n    pplVar36 = (long **)unaff_R14[0x12];\n    __ptr_01 = pplVar36;\n    if (pplVar36 != (long **)0x0) {\n      __ptr_01 = (long **)0x0;\nLAB_001151ab:\n      if (merge_notes != '\\0') goto LAB_00115187;\n      for (plVar6 = pplVar36[1]; puVar33 = dump_sections, plVar6 != (long *)0x0;\n          plVar6 = (long *)plVar6[1]) {\n      }\n    }\n  }\njoined_r0x001151c7:\n  for (; puVar33 != (undefined8 *)0x0; puVar33 = (undefined8 *)*puVar33) {\n    lVar28 = bfd_get_section_by_name();\n    if (lVar28 == 0) {\n      dcgettext(0,\"can\\'t dump section \\'%s\\' - it does not exist\",5);\n      bfd_nonfatal_message(0);\n    }\n    else if ((*(byte *)(lVar28 + 0x25) & 1) == 0) {\n      dcgettext(0,\"can\\'t dump section - it has no contents\",5);\n      bfd_nonfatal_message(0);\n    }\n    else {\n      sVar19 = *(size_t *)(lVar28 + 0x40);\n      __s_00 = fopen((char *)puVar33[2],\"w\");\n      if (__s_00 == (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        bfd_nonfatal_message(puVar33[2],0,0);\n      }\n      else {\n        cVar10 = bfd_malloc_and_get_section();\n        if (cVar10 == '\\0') {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          bfd_nonfatal_message(0);\n        }\n        else if ((sVar19 != 0) &&\n                (sVar20 = fwrite(in_stack_00000140,1,sVar19,__s_00), sVar20 != sVar19)) {\n          piVar27 = __errno_location();\n          pcVar26 = strerror(*piVar27);\n          uVar18 = puVar33[2];\n          uVar17 = dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          non_fatal(uVar17,uVar18,pcVar26);\n          free(in_stack_00000140);\n          fclose(__s_00);\n          return 0;\n        }\n        fclose(__s_00);\n        free(in_stack_00000140);\n      }\n    }\n  }\n  if (gnu_debuglink_filename == 0) {\nLAB_0010790a:\n    lStack0000000000000078 = 0;\n  }\n  else {\n    lVar28 = bfd_get_section_by_name(param_7,\".gnu_debuglink\");\n    if (lVar28 != 0) {\n      uVar18 = dcgettext(0,\"%s: debuglink section already exists\",5);\n      non_fatal(uVar18);\n      gnu_debuglink_filename = 0;\n      goto LAB_0010790a;\n    }\n    lStack0000000000000078 = bfd_create_gnu_debuglink_section(param_7);\n    lVar28 = gnu_debuglink_filename;\n    if (lStack0000000000000078 == 0) {\n      uVar18 = dcgettext(0,\"cannot create debug link section `%s\\'\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar18,lVar28);\n      return 0;\n    }\n    if (*(int *)(param_7[1] + 8) == 2) {\n      uVar22 = 0;\n      for (uVar29 = param_7[0x12]; uVar29 != 0; uVar29 = *(ulong *)(uVar29 + 8)) {\n        uVar24 = *(ulong *)(uVar29 + 0x30);\n        uVar34 = uVar22;\n        uVar7 = uVar29;\n        uVar8 = uVar22;\n        if (uVar24 != 0) {\n          while ((uVar34 = uVar7, uVar8 != 0 &&\n                 (uVar34 = uVar29, uVar24 <= *(ulong *)(uVar22 + 0x30)))) {\n            uVar29 = *(ulong *)(uVar29 + 8);\n            if (uVar29 == 0) goto LAB_00107db8;\n            uVar24 = *(ulong *)(uVar29 + 0x30);\n            uVar7 = uVar22;\n            uVar8 = uVar24;\n          }\n        }\n        uVar22 = uVar34;\n      }\nLAB_00107db8:\n      if (uVar22 == 0) {\n        uVar29 = 0x1000;\n      }\n      else {\n        uVar22 = *(long *)(uVar22 + 0x40) + *(long *)(uVar22 + 0x30);\n        uVar29 = 0xffffffffffffffff;\n        if (uVar22 < 0xfffffffffffff001) {\n          uVar29 = uVar22 + 0xfff & 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(lStack0000000000000078 + 0x28) = *(byte *)(lStack0000000000000078 + 0x28) | 1;\n      *(ulong *)(lStack0000000000000078 + 0x30) = uVar29;\n      *(ulong *)(lStack0000000000000078 + 0x38) = uVar29;\n    }\n  }\n  plVar6 = isympp;\n  iStack000000000000006c = *(int *)(param_7 + 0x14);\n  if (iStack000000000000006c != 0) {\n    uVar29 = improve_and_reverse_0010554f();\n    return uVar29;\n  }\n  if (convert_debugging == '\\0') {\nLAB_00105588:\n    puStack0000000000000020 = (undefined4 *)0x0;\n  }\n  else {\n    ppuVar41 = &names_0;\n    puStack0000000000000020 = (undefined4 *)xmalloc(0x60);\n    puVar37 = puStack0000000000000020;\n    for (lVar28 = 0x18; lVar28 != 0; lVar28 = lVar28 + -1) {\n      *puVar37 = 0;\n      puVar37 = puVar37 + (ulong)bVar43 * -2 + 1;\n    }\n    pcStack0000000000000038 = (char *)0x0;\n    do {\n      puVar3 = *ppuVar41;\n      lVar28 = bfd_get_section_by_name();\n      lVar16 = bfd_get_section_by_name();\n      if ((lVar28 != 0) && (lVar16 != 0)) {\n        lVar28 = *(long *)(lVar28 + 0x40);\n        __ptr = (void *)xmalloc(lVar28);\n        cVar10 = bfd_get_section_contents();\n        if (cVar10 == '\\0') {\n          uVar14 = bfd_get_error();\n          bfd_errmsg(uVar14);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n          free(pcStack0000000000000038);\n          free(__ptr);\n        }\n        else {\n          uVar29 = *(ulong *)(lVar16 + 0x40);\n          __ptr_00 = (void *)xmalloc(uVar29 + 1);\n          in_stack_00000018 = bfd_get_section_contents();\n          if (in_stack_00000018 == '\\0') {\n            uVar14 = bfd_get_error();\n            bfd_errmsg(uVar14);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n            free(pcStack0000000000000038);\n          }\n          else {\n            *(undefined *)((long)__ptr_00 + uVar29) = 0;\n            if ((pcStack0000000000000038 != (char *)0x0) ||\n               (pcStack0000000000000038 = (char *)start_stab_constprop_0(),\n               pcStack0000000000000038 != (char *)0x0)) {\n              lStack00000000000000a0 = 0;\n              lStack0000000000000088 = 0;\n              for (pvVar40 = __ptr; pvVar40 <= (void *)((long)__ptr + lVar28 + -0xc);\n                  pvVar40 = (void *)((long)pvVar40 + 0xc)) {\n                uVar22 = (**(code **)(unaff_R14[1] + 0x40))(pvVar40);\n                bVar2 = *(byte *)((long)pvVar40 + 4);\n                uVar14 = (**(code **)(unaff_R14[1] + 0x58))((long)pvVar40 + 6);\n                lVar16 = (**(code **)(unaff_R14[1] + 0x40))((long)pvVar40 + 8);\n                if (bVar2 == 0) {\n                  lStack0000000000000088 = lStack00000000000000a0;\n                  lStack00000000000000a0 = lStack00000000000000a0 + lVar16;\n                }\n                else {\n                  uVar24 = (uVar22 & 0xffffffff) + lStack0000000000000088;\n                  if (uVar24 < uVar29) {\n                    pcVar26 = (char *)((long)__ptr_00 + uVar24);\n                    pcStack0000000000000090 = (char *)0x0;\n                    while( true ) {\n                      sVar19 = strlen(pcVar26);\n                      if (((sVar19 == 0) || (pcVar32 = pcVar26 + (sVar19 - 1), *pcVar32 != '\\\\')) ||\n                         ((ulong)((long)__ptr + lVar28) < (long)pvVar40 + 0x10U)) goto LAB_001077fb;\n                      *pcVar32 = '\\0';\n                      pvVar40 = (void *)((long)pvVar40 + 0xc);\n                      iVar13 = (**(code **)(unaff_R14[1] + 0x40))(pvVar40);\n                      uVar22 = (ulong)(uint)(iVar13 + (int)lStack0000000000000088);\n                      if (uVar29 <= uVar22) break;\n                      pcVar26 = (char *)concat(pcVar26,(long)__ptr_00 + uVar22,0);\n                      *pcVar32 = '\\\\';\n                      free(pcStack0000000000000090);\n                      pcStack0000000000000090 = pcVar26;\n                    }\n                    uVar18 = *unaff_R14;\n                    pcVar32 = (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar32,uVar18,puVar3,((long)pvVar40 - (long)__ptr) / 0xc);\nLAB_001077fb:\n                    save_stab((ulong)bVar2,uVar14,lVar16,pcVar26);\n                    cVar10 = parse_stab(puStack0000000000000020,pcStack0000000000000038,bVar2);\n                    if (cVar10 == '\\0') {\n                      stab_context();\n                      free_saved_stabs();\n                      free(pcStack0000000000000090);\n                      free(pcStack0000000000000038);\n                      free(__ptr);\n                      free(__ptr_00);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar18 = *unaff_R14;\n                    pcVar26 = (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar26,uVar18,puVar3,((long)pvVar40 - (long)__ptr) / 0xc,\n                            uVar22 & 0xffffffff,(ulong)bVar2,((long)pvVar40 - (long)__ptr) % 0xc);\n                  }\n                }\n              }\n              free_saved_stabs();\n              free(__ptr);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_00);\n          free(__ptr);\n        }\n        goto LAB_00105981;\n      }\nLAB_001058eb:\n      ppuVar41 = ppuVar41 + 2;\n    } while (ppuVar41 != (undefined **)&DAT_00125c90);\n    if ((pcStack0000000000000038 != (char *)0x0) && (cVar10 = finish_stab(), cVar10 == '\\0')) {\nLAB_00105981:\n      free(puStack0000000000000020);\n      goto LAB_00105588;\n    }\n    if (*(int *)(unaff_R14[1] + 8) == 1) {\n      lVar28 = 0;\n      for (plVar15 = plVar6; plVar15 < plVar6 + param_8; plVar15 = plVar15 + 1) {\n        (**(code **)(unaff_R14[1] + 0x218))();\n        if (cStack0000000000000148 == '-') {\n          if (((lVar28 == 0) && (lVar28 = start_stab_constprop_0(), lVar28 == 0)) ||\n             ((in_stack_00000150 == (char *)0x0 || (*in_stack_00000150 == '\\0'))))\n          goto LAB_00105981;\n          pcVar26 = (char *)0x0;\n          pcVar32 = in_stack_00000150;\n          while (((*pcVar32 != '\\0' && (sVar19 = strlen(pcVar32), pcVar32[sVar19 - 1] == '\\\\')) &&\n                 (plVar15 + 1 < plVar6 + param_8))) {\n            pcVar21 = (char *)xstrdup(pcVar32);\n            sVar19 = strlen(pcVar21);\n            pcVar21[sVar19 - 1] = '\\0';\n            pcVar32 = (char *)concat(pcVar21,*(undefined8 *)(plVar15[1] + 8),0);\n            free(pcVar21);\n            free(pcVar26);\n            plVar15 = plVar15 + 1;\n            pcVar26 = pcVar32;\n          }\n          save_stab(uStack0000000000000158,(int)sStack000000000000015a,in_stack_00000140,pcVar32);\n          in_stack_00000018 = parse_stab(puStack0000000000000020,lVar28,uStack0000000000000158);\n          if (in_stack_00000018 == '\\0') {\n            stab_context();\n            free_saved_stabs();\n            goto LAB_00105981;\n          }\n        }\n      }\n      free_saved_stabs();\n      if ((lVar28 != 0) && (cVar10 = finish_stab(), cVar10 == '\\0')) goto LAB_00105981;\n    }\n    if (in_stack_00000018 == '\\0') {\n      if ((*(int *)(unaff_R14[1] + 8) == 2) && (param_8 != 0)) {\n        in_stack_00000140 = (char *)0x0;\n        in_stack_000000c0 = plVar6;\n        in_stack_000000d0 = 0;\n        in_stack_000000d8 = 0;\n        puVar33 = (undefined8 *)&stack0x00000148;\n        for (lVar28 = 0x22; lVar28 != 0; lVar28 = lVar28 + -1) {\n          *(undefined4 *)puVar33 = 0;\n          puVar33 = (undefined8 *)((long)puVar33 + (ulong)bVar43 * -8 + 4);\n        }\n        cVar10 = '\\0';\n        _uStack0000000000000048 = (int *)0x0;\n        pcStack0000000000000038 = (char *)0x0;\n        pcStack0000000000000090 = (char *)0xffffffffffffffff;\n        in_stack_000000c8 = param_8;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((long)param_8 <= in_stack_000000d0) goto LAB_00105590;\n            lVar28 = plVar6[in_stack_000000d0];\n            cVar9 = bfd_coff_get_syment();\n            lVar16 = in_stack_000000d8;\n            if (cVar9 == '\\0') {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar26 = \"bfd_coff_get_syment failed: %s\";\n              goto LAB_00105968;\n            }\n            pcVar26 = *(char **)(lVar28 + 8);\n            in_stack_000000d0 = in_stack_000000d0 + 1;\n            in_stack_000000d8 = (ulong)bStack0000000000000101 + 1 + in_stack_000000d8;\n            if ((bStack0000000000000101 != 0) && (cVar9 = bfd_coff_get_auxent(), cVar9 == '\\0')) {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar26 = \"bfd_coff_get_auxent failed: %s\";\n              goto LAB_00105968;\n            }\n            if (pcStack0000000000000090 != (char *)lVar16) break;\n            if (bStack0000000000000100 != 0x67) {\n              cVar9 = debug_set_filename(puStack0000000000000020);\n              if (cVar9 != '\\0') break;\n              goto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            pcStack0000000000000090 = (char *)in_stack_000000f0;\n            cVar9 = debug_set_filename(puStack0000000000000020);\n            if (cVar9 == '\\0') goto LAB_00105981;\n          }\n          if ((char)bStack0000000000000100 < '\\0') {\n            if (bStack0000000000000100 == 0xff) goto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            lVar23 = parse_coff_type_lto_priv_0();\n            if (lVar23 == 0) break;\n            cVar9 = parse_coff_symbol_constprop_0_isra_0(&stack0x00000140,lVar28,lVar16);\n          }\n          else {\n            if (bStack0000000000000100 < 100) {\n              switch(bStack0000000000000100) {\n              case 3:\n                if (in_stack_000000f8._6_2_ == 0) goto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulong)((uint)in_stack_000000f8._6_2_ & *(uint *)(unaff_R14[0x22] + 0x40)) !=\n                    2L << ((byte)*(undefined4 *)(unaff_R14[0x22] + 0x3c) & 0x3f)) goto LAB_0010700a;\n                _uStack0000000000000048 = (int *)(**(code **)(unaff_R14[1] + 0x238))();\n                pcStack0000000000000038 = pcVar26;\n                goto switchD_00106e1a_caseD_68;\n              default:\n                goto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                goto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(bStack0000000000000100) {\n            case 100:\n              iVar13 = strcmp(pcVar26,\".bb\");\n              if (iVar13 == 0) {\n                cVar9 = debug_start_block(puStack0000000000000020);\n              }\n              else {\n                iVar13 = strcmp(pcVar26,\".eb\");\n                if (iVar13 != 0) goto switchD_00106e1a_caseD_68;\n                cVar9 = debug_end_block(puStack0000000000000020);\n              }\n              break;\n            case 0x65:\n              iVar13 = strcmp(pcVar26,\".bf\");\n              if (iVar13 == 0) {\n                if (pcStack0000000000000038 != (char *)0x0) {\n                  lVar16 = parse_coff_type_lto_priv_0();\n                  if ((lVar16 == 0) ||\n                     (cVar10 = debug_record_function(puStack0000000000000020), cVar10 == '\\0'))\n                  goto LAB_00105981;\n                  if (_uStack0000000000000048 != (int *)0x0) {\n                    iVar13 = 0;\n                    if (bStack0000000000000101 != 0) {\n                      iVar13 = in_stack_00000118 - 1;\n                    }\n                    lVar28 = *(long *)(*(long *)(lVar28 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar35 = _uStack0000000000000048[4];\n                      if (iVar35 == 0) break;\n                      cVar9 = debug_record_line(puStack0000000000000020,iVar13 + iVar35,\n                                                *(long *)(_uStack0000000000000048 + 6) + lVar28);\n                      _uStack0000000000000048 = _uStack0000000000000048 + 4;\n                      if (cVar9 == '\\0') goto LAB_00105981;\n                    }\n                  }\n                  _uStack0000000000000048 = (int *)0x0;\n                  pcStack0000000000000038 = (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar26 = \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar13 = strcmp(pcVar26,\".ef\");\n                if (iVar13 != 0) goto switchD_00106e1a_caseD_68;\n                if (cVar10 != '\\0') {\n                  cVar10 = debug_end_function(puStack0000000000000020);\n                  if (cVar10 == '\\0') goto LAB_00105981;\n                  cVar10 = '\\0';\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar26 = \"%ld: unexpected .ef\\n\";\n              }\n              uVar18 = dcgettext(0,pcVar26,5);\n              non_fatal(uVar18);\n              goto LAB_00105981;\n            default:\n              goto LAB_0010700a;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (cVar9 != '\\0');\n      }\n      else {\n        pcVar26 = \"%s: no recognized debugging information\";\nLAB_00105968:\n        uVar18 = dcgettext(0,pcVar26,5);\n        non_fatal(uVar18);\n      }\n      goto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)((long)param_7 + 0x44) & 0x42) != 0) &&\n     ((*(uint *)((long)param_7 + 0x44) & 1) == 0)) {\n    if ((*(char *)(param_7[1] + 0x20) == '\\0') && (keep_section_symbols == '\\0')) {\n      if (param_8 != 0) {\n        plVar6 = isympp + param_8;\n        plVar15 = isympp;\n        do {\n          uVar31 = *(uint *)(*plVar15 + 0x18);\n          if ((uVar31 & 0x1000000) != 0) {\n            *(uint *)(*plVar15 + 0x18) = uVar31 & 0xfeffffff;\n          }\n          plVar15 = plVar15 + 1;\n        } while (plVar6 != plVar15);\n      }\n    }\n    else {\n      for (lVar28 = param_7[0x12]; lVar28 != 0; lVar28 = *(long *)(lVar28 + 8)) {\n        if (*(long *)(lVar28 + 0xe8) != 0) {\n          puVar1 = (uint *)(*(long *)(lVar28 + 0xe8) + 0x18);\n          *puVar1 = *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((strip_symbols == 2) || (strip_symbols == 7)) {\nLAB_001059fe:\n    if (strip_symbols == 7) {\nLAB_00105a3b:\n      plVar15 = (long *)xmalloc();\n      plVar6 = isympp;\n      uStack0000000000000048 = *(uint *)((long)unaff_R14 + 0x44) & 0x42;\n      osympp = plVar15;\n      if (param_8 == 0) {\n        uVar29 = 0;\n      }\n      else {\n        uVar29 = 0;\n        _in_stack_00000018 = 0;\n        do {\n          iVar13 = add_symbols;\n          plVar4 = (long *)plVar6[_in_stack_00000018];\n          pcVar5 = (code *)plVar4[4];\n          uVar31 = *(uint *)(plVar4 + 3);\n          pcVar26 = (char *)plVar4[1];\n          pcVar32 = pcVar26;\n          if (add_sym_list != (undefined8 *)0x0) {\n            iVar35 = 0;\n            puVar33 = add_sym_list;\n            while ((iVar35 < iVar13 && (pcVar21 = (char *)puVar33[5], pcVar21 != (char *)0x0))) {\n              if (pcVar21 != \"\") {\n                iVar12 = strcmp(pcVar21,pcVar26);\n                if (iVar12 == 0) {\n                  free(pcVar21);\n                  uVar22 = uVar29 + 1;\n                  puVar33[5] = \"\";\n                  lVar28 = create_new_symbol(puVar33);\n                  uVar18 = redefine_specific_htab;\n                  plVar15[uVar29] = lVar28;\n                  lVar28 = htab_elements(uVar18);\n                  if ((lVar28 != 0) || (section_rename_list != (char **)0x0)) goto LAB_001064eb;\n                  goto LAB_00105af8;\n                }\n                puVar33 = (undefined8 *)*puVar33;\n              }\n              iVar35 = iVar35 + 1;\n            }\n          }\n          lVar28 = htab_elements(redefine_specific_htab);\n          uVar22 = uVar29;\n          if ((lVar28 == 0) && (section_rename_list == (char **)0x0)) {\nLAB_00105af8:\n            cVar10 = *pcVar26;\n            if (cVar10 != '\\0') goto LAB_00105b11;\nLAB_00106557:\n            pcVar26 = prefix_symbols_string;\n            if ((change_leading_char != '\\0') && (*(char *)(param_7[1] + 0x1c) != '\\0')) {\n              lVar28 = unaff_R14[1];\n              cVar10 = '\\0';\n              goto LAB_0010668d;\n            }\n            goto joined_r0x00106565;\n          }\n          if (pcVar26 != (char *)0x0) {\nLAB_001064eb:\n            if (((*pcVar26 == '_') && (pcVar26[1] == '_')) &&\n               (iVar13 = strcmp(pcVar26 + (pcVar26[2] == '_'),\"__gnu_lto_slim\"), iVar13 == 0)) {\n              uVar18 = dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\",5\n                                );\n                    \n              fatal(uVar18);\n            }\n          }\n          _cStack0000000000000148 = 0;\n          in_stack_00000140 = pcVar26;\n          lVar28 = htab_find(redefine_specific_htab);\n          if (((lVar28 == 0) || (pcVar32 = *(char **)(lVar28 + 8), pcVar26 == pcVar32)) &&\n             (pcVar32 = pcVar26, ppcVar39 = section_rename_list, (uVar31 & 0x100) != 0)) {\n            for (; ppcVar39 != (char **)0x0; ppcVar39 = (char **)ppcVar39[3]) {\n              iVar13 = strcmp(*ppcVar39,pcVar26);\n              if (iVar13 == 0) {\n                pcVar32 = ppcVar39[1];\n                break;\n              }\n            }\n          }\n          plVar4[1] = (long)pcVar32;\n          cVar10 = *pcVar32;\n          if (cVar10 == '\\0') goto LAB_00106557;\nLAB_00105b11:\n          pcVar26 = prefix_symbols_string;\n          lVar28 = unaff_R14[1];\n          if (*(char *)(lVar28 + 0x1c) == cVar10) {\n            if (change_leading_char == '\\0') {\n              if ((remove_leading_char == '\\0') ||\n                 ((((uVar31 & 0x82) == 0 && (pcVar5 != bfd_map_over_sections)) &&\n                  ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n              pcVar32 = pcVar32 + 1;\n              plVar4[1] = (long)pcVar32;\n              goto joined_r0x00106565;\n            }\n            if (*(char *)(param_7[1] + 0x1c) == '\\0') goto LAB_0010677d;\n            if (prefix_symbols_string != (char *)0x0) {\n              pcVar32 = pcVar32 + 1;\n              plVar4[1] = (long)pcVar32;\n              sVar19 = strlen(pcVar32);\n              lVar28 = sVar19 + 2;\nLAB_001066bc:\n              sVar19 = strlen(pcVar26);\n              pcVar26 = (char *)xmalloc(sVar19 + lVar28);\n              goto LAB_001066d0;\n            }\n            *pcVar32 = *(char *)(param_7[1] + 0x1c);\n            plVar4[1] = (long)pcVar32;\n            uVar29 = uVar22;\n          }\n          else {\n            if ((change_leading_char == '\\0') || (*(char *)(param_7[1] + 0x1c) == '\\0')) {\njoined_r0x00106565:\n              uVar29 = uVar22;\n              if (pcVar26 == (char *)0x0) goto LAB_00105b32;\n              sVar19 = strlen(pcVar32);\n              sVar20 = strlen(pcVar26);\n              pcVar21 = (char *)xmalloc(sVar20 + sVar19 + 1);\n              pcVar26 = pcVar21;\n            }\n            else {\nLAB_0010668d:\n              pcVar26 = prefix_symbols_string;\n              if ((*(char *)(lVar28 + 0x1c) != '\\0') && (cVar10 != *(char *)(lVar28 + 0x1c)))\n              goto joined_r0x00106565;\n              sVar19 = strlen(pcVar32);\n              lVar28 = sVar19 + 2;\n              if (pcVar26 != (char *)0x0) goto LAB_001066bc;\n              pcVar26 = (char *)xmalloc(lVar28);\nLAB_001066d0:\n              pcVar21 = pcVar26 + 1;\n              *pcVar26 = *(char *)(param_7[1] + 0x1c);\n            }\n            __s = prefix_symbols_string;\n            if (prefix_symbols_string != (char *)0x0) {\n              strcpy(pcVar21,prefix_symbols_string);\n              sVar19 = strlen(__s);\n              pcVar21 = pcVar21 + sVar19;\n            }\n            strcpy(pcVar21,pcVar32);\n            plVar4[1] = (long)pcVar26;\n            pcVar32 = pcVar26;\n            uVar29 = uVar22;\n          }\nLAB_00105b32:\n          if (strip_symbols == 7) goto LAB_001067a8;\n          if (((uVar31 & 0x20) == 0) &&\n             (((uVar31 & 0x100) == 0 ||\n              ((*(byte *)(**(long **)(plVar4[4] + 0xf0) + 0x18) & 0x20) == 0)))) {\n            if (((uStack0000000000000048 == 0) &&\n                (((uVar31 & 0x82) != 0 || ((*(byte *)(plVar4[4] + 0x25) & 0x10) != 0)))) ||\n               (iVar13 = bfd_decode_symclass(plVar4), iVar13 == 0x49)) {\nLAB_00105be2:\n              if (wildcard == '\\0') {\n                lVar28 = htab_find();\n                if (lVar28 == 0) goto LAB_00105c07;\n              }\n              else {\n                _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n                in_stack_00000140 = pcVar32;\n                htab_traverse(strip_specific_htab,is_specified_symbol_predicate,&stack0x00000140);\n                if (cStack0000000000000148 == '\\0') goto LAB_00105c07;\n              }\n            }\n            else if ((((uVar31 & 0x82) == 0) && (pcVar5 != bfd_map_over_sections)) &&\n                    ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)) {\n              if ((uVar31 & 4) == 0) {\n                if (((*(int *)(unaff_R14[1] + 8) != 2) ||\n                    (lVar28 = *(long *)(plVar4[4] + 0xd0), lVar28 == 0)) ||\n                   (*(long *)(lVar28 + 0x40) == 0)) {\n                  if ((strip_symbols == 3) || (discard_locals == 2)) goto LAB_001067a8;\n                  if (discard_locals == 1) {\n                    cVar10 = bfd_is_local_label(unaff_R14);\n                    goto joined_r0x00106a11;\n                  }\n                }\n                goto LAB_00105be2;\n              }\n              cVar10 = convert_debugging;\n              if (1 < strip_symbols - 2U) {\njoined_r0x00106a11:\n                if (cVar10 == '\\0') goto LAB_00105be2;\n              }\n            }\n            else if (strip_symbols != 3) goto LAB_00105be2;\n            goto LAB_001067a8;\n          }\n          if (wildcard == '\\0') {\n            lVar28 = htab_find();\n            if (lVar28 != 0) {\nLAB_0010687f:\n              uVar18 = dcgettext(0,\"not stripping symbol `%s\\' because it is named in a relocation\",\n                                 5);\n              non_fatal(uVar18);\n              status = 1;\n            }\n          }\n          else {\n            _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n            in_stack_00000140 = pcVar32;\n            htab_traverse(strip_specific_htab,is_specified_symbol_predicate,&stack0x00000140);\n            if (cStack0000000000000148 != '\\0') goto LAB_0010687f;\n          }\n          if ((uVar31 & 0x20) == 0) {\nLAB_00105c07:\n            if (wildcard != '\\0') {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              in_stack_00000140 = pcVar32;\n              htab_traverse(strip_unneeded_htab,is_specified_symbol_predicate,&stack0x00000140);\n              if (cStack0000000000000148 != '\\0') goto LAB_001067a8;\n              goto LAB_00105c2c;\n            }\n            lVar28 = htab_find();\n            if (lVar28 == 0) goto LAB_00105c2c;\nLAB_001067a8:\n            if ((keep_file_symbols != '\\0') && ((uVar31 & 0x4000) != 0)) goto LAB_00105c2c;\n            if (wildcard == '\\0') {\n              lVar28 = htab_find();\n              if (lVar28 != 0) goto LAB_00105c2c;\n            }\n            else {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              in_stack_00000140 = pcVar32;\n              htab_traverse(keep_specific_htab,is_specified_symbol_predicate,&stack0x00000140);\n              if (cStack0000000000000148 != '\\0') goto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            cVar10 = is_strip_section_isra_0(plVar4[4]);\n            if (cVar10 == '\\0') {\n              if (((uVar31 & 0x800002) == 0) && (pcVar5 != bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uVar31 & 0x82) != 0) {\n                  cVar10 = is_specified_symbol(pcVar32);\n                  if ((cVar10 == '\\0') &&\n                     ((lVar28 = htab_elements(keepglobal_specific_htab), lVar28 == 0 ||\n                      (cVar10 = is_specified_symbol(pcVar32), cVar10 != '\\0')))) {\n                    if (((((localize_hidden == '\\0') ||\n                          (uVar11 = *(uint *)(plVar4 + 3), (uVar11 & 0x200000) != 0)) ||\n                         (lVar28 = *plVar4, lVar28 == 0)) ||\n                        ((*(int *)(*(long *)(lVar28 + 8) + 8) != 5 ||\n                         (*(long *)(lVar28 + 0x110) == 0)))) ||\n                       (1 < (*(byte *)((long)plVar4 + 0x49) & 3) - 1)) goto joined_r0x00105ca2;\n                  }\n                  else {\n                    uVar11 = *(uint *)(plVar4 + 3);\n                  }\n                  *(uint *)(plVar4 + 3) = uVar11 & 0xffffff7d | 1;\n                }\njoined_r0x00105ca2:\n                if (((uVar31 & 1) != 0) && (cVar10 = is_specified_symbol(pcVar32), cVar10 != '\\0'))\n                {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((weaken != '\\0') || (cVar10 = is_specified_symbol(pcVar32), cVar10 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xff7ffffd | 0x80;\n                }\n                if (pcVar5 != bfd_map_over_sections) goto LAB_00105c5f;\n              }\n              plVar15[uVar29] = (long)plVar4;\n              uVar29 = uVar29 + 1;\n            }\n          }\n          _in_stack_00000018 = _in_stack_00000018 + 1;\n        } while (param_8 != _in_stack_00000018);\n      }\n      if (add_sym_list != (undefined8 *)0x0) {\n        puVar33 = add_sym_list;\n        iVar13 = add_symbols;\n        for (lVar28 = 0; lVar28 < iVar13; lVar28 = lVar28 + 1) {\n          pcVar26 = (char *)puVar33[5];\n          if (pcVar26 == (char *)0x0) {\n            plVar6 = plVar15 + uVar29;\n            uVar29 = uVar29 + 1;\n            lVar16 = create_new_symbol(puVar33,param_7);\n            *plVar6 = lVar16;\n            iVar13 = add_symbols;\n          }\n          else if (pcVar26 != \"\") {\n            uVar18 = dcgettext(0,\"\\'before=%s\\' not found\",5);\n                    \n            fatal(uVar18,pcVar26);\n          }\n          puVar33 = (undefined8 *)*puVar33;\n        }\n      }\n      bVar42 = convert_debugging == '\\0';\n      plVar15[uVar29] = 0;\n      if ((bVar42) || (puStack0000000000000020 == (undefined4 *)0x0)) {\nLAB_00105cfa:\n        param_8 = uVar29 & 0xffffffff;\n        goto LAB_00105710;\n      }\n      iVar13 = *(int *)((undefined8 *)param_7[1] + 1);\n      if ((iVar13 == 5) || (iVar13 == 2)) {\n        in_stack_000000e0 = (void *)0x0;\n        cVar10 = write_stabs_in_sections_debugging_info_constprop_0\n                           (param_7,puStack0000000000000020,&stack0x000000c0,&stack0x00000110,\n                            &stack0x000000e0,&stack0x00000140);\n        if (cVar10 != '\\0') {\n          lVar28 = bfd_make_section_with_flags(param_7,\".stab\",0x2108);\n          lVar16 = bfd_make_section_with_flags(param_7,\".stabstr\",0x2108);\n          if ((((lVar28 == 0) || (lVar16 == 0)) ||\n              (cVar10 = bfd_set_section_size(lVar28,in_stack_00000110), cVar10 == '\\0')) ||\n             (cVar10 = bfd_set_section_size(lVar16,in_stack_00000140), cVar10 == '\\0')) {\n            pcVar26 = \"can\\'t create debugging section\";\n          }\n          else {\n            *(undefined4 *)(lVar28 + 0x7c) = 2;\n            *(undefined4 *)(lVar16 + 0x7c) = 0;\n            cVar10 = bfd_set_section_contents(param_7,lVar28,in_stack_000000c0,0,in_stack_00000110);\n            if ((cVar10 != '\\0') &&\n               (cVar10 = bfd_set_section_contents\n                                   (param_7,lVar16,in_stack_000000e0,0,in_stack_00000140),\n               cVar10 != '\\0')) {\n              free(puStack0000000000000020);\n              goto LAB_00105cfa;\n            }\n            pcVar26 = \"can\\'t set debugging section contents\";\n          }\n          uVar18 = dcgettext(0,pcVar26,5);\n          bfd_nonfatal_message(0,param_7,0,uVar18);\n          free(in_stack_000000e0);\n          free(puStack0000000000000020);\n          goto LAB_00105d96;\n        }\n      }\n      else {\n        uVar18 = *(undefined8 *)param_7[1];\n        uVar17 = dcgettext(0,\"don\\'t know how to write debugging information for %s\",5);\n        bfd_nonfatal_message(0,param_7,0,uVar17,uVar18);\n      }\n      free(puStack0000000000000020);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections();\n      iVar13 = bfd_get_error();\n      if (iVar13 == 0) goto LAB_00105a3b;\n    }\nLAB_00105d96:\n    status = 1;\n  }\n  else {\n    if ((strip_symbols - 3U < 4) || ((discard_locals != 0 || (localize_hidden != '\\0'))))\n    goto LAB_00105a07;\n    lVar28 = htab_elements(strip_specific_htab);\n    if (((lVar28 != 0) ||\n        (((((((lVar28 = htab_elements(keep_specific_htab), lVar28 != 0 ||\n              (lVar28 = htab_elements(localize_specific_htab), lVar28 != 0)) ||\n             (lVar28 = htab_elements(globalize_specific_htab), lVar28 != 0)) ||\n            ((lVar28 = htab_elements(keepglobal_specific_htab), lVar28 != 0 ||\n             (lVar28 = htab_elements(weaken_specific_htab), lVar28 != 0)))) ||\n           (lVar28 = htab_elements(redefine_specific_htab), lVar28 != 0)) ||\n          (((prefix_symbols_string != (char *)0x0 || (sections_removed != '\\0')) ||\n           ((sections_copied != '\\0' ||\n            (((convert_debugging != '\\0' || (change_leading_char != '\\0')) ||\n             (remove_leading_char != '\\0')))))))) ||\n         ((section_rename_list != (char **)0x0 || (weaken != '\\0')))))) || (add_symbols != 0))\n    goto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(param_7,osympp,param_8 & 0xffffffff);\n    bfd_map_over_sections(unaff_R14,copy_relocations_in_section,param_7);\n    bfd_map_over_sections(unaff_R14,copy_section,param_7);\n    for (puVar33 = add_sections; puVar38 = update_sections, puVar33 != (undefined8 *)0x0;\n        puVar33 = (undefined8 *)*puVar33) {\n      cVar10 = bfd_set_section_contents(param_7,puVar33[5],puVar33[4],0,puVar33[3]);\n      if (cVar10 == '\\0') {\n        bfd_nonfatal_message(0,param_7,puVar33[5],0);\n        return 0;\n      }\n    }\n    for (; puVar38 != (undefined8 *)0x0; puVar38 = (undefined8 *)*puVar38) {\n      uVar18 = *(undefined8 *)(puVar38[5] + 0x60);\n      cVar10 = bfd_set_section_contents(param_7,uVar18,puVar38[4],0,puVar38[3]);\n      if (cVar10 == '\\0') {\n        bfd_nonfatal_message(0,param_7,uVar18,0);\n        return 0;\n      }\n    }\n    if (__ptr_01 == (long **)0x0) {\n      if ((merge_notes != '\\0') && (is_strip == 0)) {\n        uVar18 = *unaff_R14;\n        uVar17 = dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n        non_fatal(uVar17,uVar18);\n      }\n    }\n    else {\n      pplVar36 = (long **)0x0;\n      for (puVar33 = (undefined8 *)param_7[0x12]; puVar33 != (undefined8 *)0x0;\n          puVar33 = (undefined8 *)puVar33[1]) {\n        if (((merge_notes != '\\0') && (*(int *)(param_7[1] + 8) == 5)) &&\n           ((*(int *)(puVar33[0x1a] + 4) == 7 &&\n            (cVar10 = startswith_lto_priv_0_lto_priv_0(*puVar33,\".gnu.build.attributes\"),\n            cVar10 != '\\0')))) {\n          if (pplVar36 == (long **)0x0) {\n            pplVar36 = __ptr_01;\n          }\n          pplVar30 = __ptr_01;\n          if ((undefined8 *)(*pplVar36)[0xc] == puVar33) {\nLAB_0010625f:\n            pcVar26 = \"error: failed to merge notes\";\n            if (pplVar36[1] != (long *)0x0) {\n              cVar10 = bfd_set_section_contents(param_7,puVar33,pplVar36[1],0,pplVar36[2]);\n              if (cVar10 == '\\0') {\n                uVar18 = dcgettext(0,\"error: failed to copy merged notes into output\",5);\n                bfd_nonfatal_message(0,param_7,puVar33,uVar18);\n                return 0;\n              }\n              pplVar36 = (long **)pplVar36[3];\n              goto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              pplVar36 = pplVar30;\n              if ((undefined8 *)(*pplVar30)[0xc] == puVar33) goto LAB_0010625f;\n              pplVar36 = (long **)pplVar30[3];\n              pplVar30 = pplVar36;\n            } while (pplVar36 != (long **)0x0);\n            pcVar26 = \"error: failed to locate merged notes\";\n          }\n          uVar18 = dcgettext(0,pcVar26,5);\n          bfd_nonfatal_message(0,param_7,puVar33,uVar18);\n        }\nLAB_001061be:\n      }\n      do {\n        pplVar36 = (long **)__ptr_01[3];\n        free(__ptr_01[1]);\n        free(__ptr_01);\n        __ptr_01 = pplVar36;\n      } while (pplVar36 != (long **)0x0);\n    }\n    if ((gnu_debuglink_filename == 0) ||\n       (cVar10 = bfd_fill_in_gnu_debuglink_section(param_7,lStack0000000000000078),\n       lVar28 = gnu_debuglink_filename, cVar10 != '\\0')) {\n      uVar31 = (**(code **)(param_7[1] + 0x140))(unaff_R14);\n      uVar29 = (ulong)uVar31;\n      if ((char)uVar31 != '\\0') {\n        if (use_alt_mach_code == 0) {\n          return uVar29;\n        }\n        cVar10 = bfd_alt_mach_code(param_7,use_alt_mach_code & 0xffffffff);\n        uVar22 = use_alt_mach_code;\n        if (cVar10 == '\\0') {\n          uVar18 = dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n          non_fatal(uVar18,uVar22);\n          if (*(int *)(param_7[1] + 8) == 5) {\n            uVar18 = dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n            non_fatal(uVar18);\n            *(short *)(param_7[0x22] + 0x3a) = (short)use_alt_mach_code;\n            return uVar29;\n          }\n          uVar18 = dcgettext(0,\"ignoring the alternative value\",5);\n          non_fatal(uVar18);\n          return uVar29;\n        }\n        return uVar29;\n      }\n      uVar18 = dcgettext(0,\"error copying private BFD data\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar18);\n    }\n    else {\n      uVar18 = dcgettext(0,\"cannot fill debug link section `%s\\'\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar18,lVar28);\n    }\n  }\n  return 0;\nLAB_00115187:\n  if ((((*(int *)(unaff_R14[1] + 8) == 5) && (*(int *)((long)pplVar36[0x1a] + 4) == 7)) &&\n      (cVar10 = startswith_lto_priv_0_lto_priv_0(*pplVar36), cVar10 != '\\0')) &&\n     ((pplVar36[0xc] != (long *)0x0 && (plVar6 = pplVar36[8], plVar6 != (long *)0x0)))) {\n    pplVar30 = (long **)xmalloc(0x20);\n    pplVar30[1] = (long *)0x0;\n    cVar10 = bfd_get_full_section_contents();\n    if (cVar10 == '\\0') {\n      dcgettext(0,\"warning: could not load note section\",5);\n      bfd_nonfatal_message(0);\n      free(pplVar30);\n    }\n    else {\n      plVar15 = (long *)merge_gnu_build_notes();\n      pplVar30[2] = plVar15;\n      if ((plVar15 == plVar6) || (cVar10 = bfd_set_section_size(pplVar36[0xc]), cVar10 != '\\0')) {\n        pplVar30[3] = (long *)__ptr_01;\n        *pplVar30 = (long *)pplVar36;\n        __ptr_01 = pplVar30;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        bfd_nonfatal_message(0,param_7,pplVar36);\n        free(pplVar30[1]);\n        free(pplVar30);\n      }\n    }\n  }\n  pplVar36 = (long **)pplVar36[1];\n  puVar33 = dump_sections;\n  if (pplVar36 == (long **)0x0) goto joined_r0x001151c7;\n  goto LAB_001151ab;\n}\n\n",
            "called": [
                "bfd_set_file_flags",
                "dcgettext",
                "printf",
                "FUN_001152b6",
                "bfd_set_start_address",
                "bfd_get_mach",
                "bfd_get_arch",
                "bfd_get_archive_filename"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00107976",
            "calling": [
                "copy_object"
            ],
            "imported": false,
            "current_name": "FUNC_00107976"
        },
        "FUN_00128318": {
            "renaming": {},
            "code": "\n\n\n\nvoid * malloc(size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* malloc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128318",
            "calling": [
                "malloc"
            ],
            "imported": false,
            "current_name": "FUN_00128318"
        },
        "FUN_00104590": {
            "renaming": {},
            "code": "\nvoid bfd_alt_mach_code(void)\n\n{\n  bfd_alt_mach_code();\n  return;\n}\n\n",
            "called": [
                "bfd_alt_mach_code"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104590",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "FUN_00104590"
        },
        "FUN_0010b0fa": {
            "renaming": {
                "FUN_0010b0fa": "decompile_and_improve_0010b0fa",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arr",
                "param_4": "param",
                "param_5": "result_arr",
                "uVar1": "value",
                "iVar2": "index",
                "pcVar3": "ptr",
                "plVar4": "ptr_arr",
                "pcVar5": "str",
                "sVar6": "length",
                "__ptr": "ptr_var",
                "lVar7": "result",
                "local_40": "local_array"
            },
            "code": "\n\n\nchar * decompile_and_improve_0010b0fa(undefined8 arg1,undefined8 arg2,uint *arr,long param,\n                   undefined *result_arr)\n\n{\n  uint value;\n  int index;\n  char *ptr;\n  long *ptr_arr;\n  char *str;\n  size_t length;\n  void *ptr_var;\n  long result;\n  undefined local_array [16];\n  \n  if (result_arr != (undefined *)0x0) {\n    *result_arr = 0;\n  }\n  while( true ) {\n    value = *arr;\n    if (0x29 < value) break;\n    if (0x17 < value) {\n      switch(value) {\n      case 0x18:\n        goto switchD_0010b158_caseD_18;\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x22:\n      case 0x23:\n        ptr = (char *)decompile_and_improve_0010b0fa(arg1,arg2,*(undefined8 *)(arr + 4),0,0);\n        if (ptr != (char *)0x0) {\n          switch(*arr) {\n          case 0x19:\n            goto switchD_0010b2de_caseD_19;\n          case 0x1a:\n            ptr = (char *)debug_make_volatile_type_isra_0(ptr);\n            return ptr;\n          case 0x1b:\n            ptr = (char *)debug_make_const_type_isra_0(ptr);\n            return ptr;\n          default:\n                    \n            abort();\n          case 0x22:\n            ptr = (char *)debug_make_pointer_type_isra_0(ptr);\n            return ptr;\n          case 0x23:\n            ptr = (char *)debug_make_reference_type_isra_0(ptr);\n            return ptr;\n          }\n        }\n        goto LAB_0010b38c;\n      case 0x27:\n        ptr = (char *)cplus_demangle_print(3,arr,0x14,local_array);\n        if (ptr == (char *)0x0) {\n          str = \"Couldn\\'t get demangled builtin type\\n\";\n          ptr = (char *)0x0;\n          goto LAB_0010b3d3;\n        }\n        index = strcmp(ptr,\"signed char\");\n        if (index == 0) {\nLAB_0010b406:\n          str = (char *)debug_make_int_type_isra_0(1,0);\n          goto LAB_0010b6c6;\n        }\n        index = strcmp(ptr,\"bool\");\n        if (index == 0) {\n          str = (char *)debug_make_type_constprop_0(6,1);\n          goto LAB_0010b6c6;\n        }\n        index = strcmp(ptr,\"char\");\n        if (index == 0) goto LAB_0010b406;\n        index = strcmp(ptr,\"double\");\n        if ((index == 0) || (index = strcmp(ptr,\"long double\"), index == 0)) {\n          str = (char *)debug_make_float_type_isra_0(8);\n          goto LAB_0010b6c6;\n        }\n        index = strcmp(ptr,\"float\");\n        if (index == 0) {\n          str = (char *)debug_make_float_type_isra_0(4);\n          goto LAB_0010b6c6;\n        }\n        index = strcmp(ptr,\"__float128\");\n        if (index == 0) {\n          str = (char *)debug_make_float_type_isra_0(0x10);\n          goto LAB_0010b6c6;\n        }\n        index = strcmp(ptr,\"unsigned char\");\n        if (index == 0) {\n          str = (char *)debug_make_int_type_isra_0(1,1);\n          goto LAB_0010b6c6;\n        }\n        index = strcmp(ptr,\"int\");\n        if (index == 0) {\nLAB_0010b504:\n          str = (char *)debug_make_int_type_isra_0(4,0);\n          goto LAB_0010b6c6;\n        }\n        index = strcmp(ptr,\"unsigned int\");\n        if (index == 0) {\nLAB_0010b528:\n          str = (char *)debug_make_int_type_isra_0(4,1);\n          goto LAB_0010b6c6;\n        }\n        index = strcmp(ptr,\"long\");\n        if (index == 0) goto LAB_0010b504;\n        index = strcmp(ptr,\"unsigned long\");\n        if (index == 0) goto LAB_0010b528;\n        index = strcmp(ptr,\"__int128\");\n        if (index == 0) {\n          str = (char *)debug_make_int_type_isra_0(0x10,0);\n          goto LAB_0010b6c6;\n        }\n        index = strcmp(ptr,\"unsigned __int128\");\n        if (index == 0) {\n          str = (char *)debug_make_int_type_isra_0(0x10,1);\n          goto LAB_0010b6c6;\n        }\n        index = strcmp(ptr,\"short\");\n        if (index == 0) {\n          str = (char *)debug_make_int_type_isra_0(2,0);\n          goto LAB_0010b6c6;\n        }\n        index = strcmp(ptr,\"unsigned short\");\n        if (index == 0) {\n          str = (char *)debug_make_int_type_isra_0(2,1);\n          goto LAB_0010b6c6;\n        }\n        index = strcmp(ptr,\"void\");\n        if (index == 0) {\n          str = (char *)debug_make_void_type_isra_0();\n          goto LAB_0010b6c6;\n        }\n        index = strcmp(ptr,\"wchar_t\");\n        if (index == 0) goto LAB_0010b528;\n        index = strcmp(ptr,\"long long\");\n        if (index == 0) {\n          str = (char *)debug_make_int_type_isra_0(8,0);\n          goto LAB_0010b6c6;\n        }\n        index = strcmp(ptr,\"unsigned long long\");\n        if (index == 0) {\n          str = (char *)debug_make_int_type_isra_0(8,1);\n          goto LAB_0010b6c6;\n        }\n        index = strcmp(ptr,\"...\");\n        if (index == 0) {\n          str = \"Unexpected demangled varargs\\n\";\n          if (result_arr == (undefined *)0x0) goto LAB_0010b6a9;\n          *result_arr = 1;\n        }\n        else {\n          str = \"Unrecognized demangled builtin type\\n\";\nLAB_0010b6a9:\n          str = (char *)dcgettext(0,str,5);\n          fprintf(_stderr,str);\n        }\n        str = (char *)0x0;\nLAB_0010b6c6:\n        free(ptr);\n        return str;\n      case 0x29:\n        if (*(long *)(arr + 4) == 0) {\n          ptr_var = (void *)debug_make_void_type_isra_0();\n        }\n        else {\n          ptr_var = (void *)decompile_and_improve_0010b0fa(arg1,arg2,*(long *)(arr + 4),0,0);\n        }\n        if (ptr_var != (void *)0x0) {\n          result = stab_demangle_v3_arglist(arg1,arg2,*(undefined8 *)(arr + 6),local_array);\n          if (result != 0) {\n            ptr = (char *)debug_make_function_type_isra_0(ptr_var,result,local_array[0]);\n            return ptr;\n          }\n          free(ptr_var);\n        }\n        goto LAB_0010b38c;\n      }\n      break;\n    }\n    if (value != 1) {\n      if (value == 4) {\n        ptr = (char *)cplus_demangle_print(3,arr,0x14,local_array);\n        str = \"Failed to print demangled template\\n\";\n        if (ptr != (char *)0x0) {\n          length = strlen(ptr);\n          str = (char *)stab_find_tagged_type(arg1,arg2,ptr,length & 0xffffffff,9);\n          free(ptr);\n          return str;\n        }\nLAB_0010b3d3:\n        str = (char *)dcgettext(0,str,5);\n        fprintf(_stderr,str);\n        return ptr;\n      }\n      if (value == 0) {\n        if ((param == 0) ||\n           (ptr_arr = (long *)debug_get_fields_isra_0(param), ptr_arr == (long *)0x0))\n        goto switchD_0010b158_caseD_18;\n        goto LAB_0010b1a5;\n      }\n      break;\n    }\n    param = decompile_and_improve_0010b0fa(arg1,arg2,*(undefined8 *)(arr + 4),param,0);\n    if (param == 0) goto LAB_0010b38c;\n    arr = *(uint **)(arr + 6);\n    result_arr = (undefined *)0x0;\n  }\n  ptr = (char *)dcgettext(0,\"Unrecognized demangle component %d\\n\",5);\n  fprintf(_stderr,ptr,(ulong)value);\nLAB_0010b38c:\n  ptr = (char *)0x0;\nswitchD_0010b2de_caseD_19:\n  return ptr;\nLAB_0010b1a5:\n  if (*ptr_arr == 0) {\nswitchD_0010b158_caseD_18:\n    ptr = (char *)stab_find_tagged_type\n                               (arg1,arg2,*(undefined8 *)(arr + 4),arr[6],0);\n    return ptr;\n  }\n  ptr = *(char **)(*ptr_arr + 8);\n  if (ptr == (char *)0x0) goto LAB_0010b38c;\n  str = (char *)debug_get_type_name_constprop_0(ptr);\n  if (str != (char *)0x0) {\n    length = strlen(str);\n    if ((arr[6] == (uint)length) &&\n       (index = strncmp(str,*(char **)(arr + 4),(long)(int)arr[6]), index == 0)) {\n      return ptr;\n    }\n  }\n  ptr_arr = ptr_arr + 1;\n  goto LAB_0010b1a5;\n}\n\n",
            "called": [
                "stab_demangle_v3_arg",
                "stab_find_tagged_type",
                "strncmp",
                "abort",
                "free",
                "debug_get_type_name.constprop.0",
                "debug_make_type.constprop.0",
                "stab_demangle_v3_arglist",
                "fprintf",
                "debug_make_int_type.isra.0",
                "debug_make_void_type.isra.0",
                "strlen",
                "debug_make_function_type.isra.0",
                "debug_make_volatile_type.isra.0",
                "dcgettext",
                "debug_make_pointer_type.isra.0",
                "cplus_demangle_print",
                "debug_get_fields.isra.0",
                "debug_make_float_type.isra.0",
                "debug_make_const_type.isra.0",
                "strcmp",
                "debug_make_reference_type.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010b0fa",
            "calling": [
                "stab_demangle_v3_arg",
                "stab_demangle_v3_arglist"
            ],
            "imported": false,
            "current_name": "decompile_and_improve_0010b0fa"
        },
        "FUN_00104c36": {
            "renaming": {
                "FUN_00104c36": "parse_and_process_lines_00104c36",
                "in_CL": "currentChar",
                "ppbVar2": "slotPointer",
                "pbVar3": "nextChar",
                "bVar4": "nextByte",
                "unaff_RBX": "lineStart",
                "unaff_EBP": "lineCount",
                "pbVar5": "linePtr",
                "unaff_R13": "callbackFunction",
                "unaff_R14": "lineEnd",
                "unaff_R15": "lineStartPtr",
                "in_stack_00000008": "lineErrorFormat",
                "in_stack_00000010": "callbackReturn"
            },
            "code": "\nvoid parseAndProcessLines_00104c36(void)\n\n{\n  undefined8 uVar1;\n  byte **slotPointer;\n  byte *nextChar;\n  byte currentChar;\n  byte nextByte;\n  byte *lineStart;\n  int lineCount;\n  byte *linePtr;\n  undefined8 callbackFunction;\n  byte *lineEnd;\n  byte *lineStartPtr;\n  undefined8 lineErrorFormat;\n  undefined8 *callbackReturn;\n  \n  do {\n    linePtr = lineStartPtr;\n    if (currentChar == 9) goto LAB_00104c3f;\n    do {\n      if ((currentChar == 10) || (currentChar == 0xd)) goto LAB_00114676;\n      if (currentChar == 0) goto LAB_00114599;\n      currentChar = linePtr[1];\n      linePtr = linePtr + 1;\n    } while ((currentChar != 0x20) && (currentChar != 9));\n    if ((char)currentChar < '\\x0e') {\nLAB_00114676:\n      if ((-0x2402L >> (currentChar & 0x3f) & 1U) != 0) goto LAB_001145e6;\n    }\n    else {\nLAB_001145e6:\n      nextByte = linePtr[1];\n      if ((((((nextByte == 9) || (nextByte == 0x20)) &&\n            ((nextByte = linePtr[2], nextByte == 9 || (nextByte == 0x20)))) &&\n           ((nextByte = linePtr[3], nextByte == 9 || (nextByte == 0x20)))) &&\n          ((nextByte = linePtr[4], nextByte == 9 || (nextByte == 0x20)))) &&\n         ((nextByte = linePtr[5], nextByte == 9 || (nextByte == 0x20)))) {\n        nextByte = linePtr[6];\n        nextChar = linePtr + 6;\n        if ((nextByte == 9) || (nextByte == 0x20)) {\n          do {\n            do {\n              nextByte = nextChar[1];\n              nextChar = nextChar + 1;\n            } while (nextByte == 0x20);\n          } while (nextByte == 9);\n        }\n      }\n      if ((0xd < nextByte) || ((-0x2402L >> (nextByte & 0x3f) & 1U) != 0)) {\n        uVar1 = dcgettext(0,\"%s:%d: Ignoring rubbish found on this line\",5);\n        non_fatal(uVar1,lineErrorFormat,lineCount);\n      }\n    }\nLAB_00114599:\n    *linePtr = 0;\n    if (lineStartPtr < linePtr) {\n      slotPointer = (byte **)htab_find_slot();\n      *slotPointer = lineStartPtr;\n    }\n    lineCount = lineCount + 1;\n    linePtr = lineStart;\n    if (lineEnd[1] == 0) {\n      *callbackReturn = callbackFunction;\n      return;\n    }\n    for (; nextByte = *linePtr, lineEnd = linePtr, nextByte != 10; linePtr = linePtr + 1) {\n      if ((char)nextByte < '\\v') {\n        if (nextByte == 0) {\n          nextChar = linePtr + 1;\n          goto LAB_00114553;\n        }\n      }\n      else {\n        if (nextByte == 0xd) {\n          *linePtr = 0;\n          nextChar = linePtr + 1;\n          if (linePtr[1] == 10) {\n            nextChar = linePtr + 2;\n            lineEnd = linePtr + 1;\n          }\n          goto LAB_00114553;\n        }\n        if (nextByte == 0x23) {\n          FUN_00104d1c();\n          return;\n        }\n      }\n    }\n    *linePtr = 0;\n    if (linePtr[1] == 0xd) {\n      lineEnd = linePtr + 1;\n      nextChar = linePtr + 2;\n    }\n    else {\n      nextChar = linePtr + 1;\n    }\nLAB_00114553:\n    currentChar = *lineStart;\n    lineStartPtr = lineStart;\n    while (lineStart = nextChar, currentChar == 0x20) {\nLAB_00104c3f:\n      linePtr = lineStartPtr + 1;\n      lineStartPtr = lineStartPtr + 1;\n      nextChar = lineStart;\n      currentChar = *linePtr;\n    }\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104c36",
            "calling": [
                "FUN_00104cc1"
            ],
            "imported": false,
            "current_name": "parse_and_process_lines_00104c36"
        },
        "FUN_0010554f": {
            "renaming": {
                "FUN_0010554f": "improve_and_reverse_0010554f",
                "param_7": "binary",
                "param_8": "section_count",
                "param_9": "debugging_info_flag",
                "in_R10": "symbol_list",
                "g": "strip_symbols",
                "bVar39": "temp_flag",
                "lVar14": "temp_value",
                "puVar33": "ptr_1",
                "plVar20": "ptr_2",
                "plVar28": "ptr_3",
                "param_12": "gap_fill_size",
                "param_14": "gap_fill_buffer",
                "param_15": "gap_fill_set",
                "uVar29": "updated_value",
                "sVar18": "str_length",
                "__ptr": "string_buffer",
                "__s": "temp_string",
                "uVar16": "result_1",
                "uVar17": "result_2",
                "pcVar31": "temp_string_2",
                "uVar21": "temp_value_2",
                "iVar27": "loop_counter",
                "_param_15": "loop_variable_1",
                "_param_41": "loop_variable_2",
                "unaff_R14": "bfd_data"
            },
            "code": "\n/* WARNING: Type propastrip_symbolsation alstrip_symbolsorithm not settlinstrip_symbols */\n\n\nundefined4 improve_and_reverse_0010554f(void)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  code *pcVar3;\n  undefined8 *puVar4;\n  undefined uVar5;\n  ushort uVar6;\n  char cVar7;\n  char cVar8;\n  undefined4 uVar9;\n  int iVar10;\n  int iVar11;\n  uint uVar12;\n  uint uVar13;\n  lonstrip_symbols temp_value;\n  lonstrip_symbols *plVar15;\n  undefined8 result_1;\n  undefined *string_buffer;\n  undefined8 result_2;\n  size_t str_length;\n  size_t sVar19;\n  lonstrip_symbols *__dest;\n  lonstrip_symbols *ptr_2;\n  void *string_buffer_00;\n  void *string_buffer_01;\n  ulonstrip_symbols temp_value_2;\n  char *temp_string;\n  char *pcVar22;\n  lonstrip_symbols lVar23;\n  ulonstrip_symbols uVar24;\n  lonstrip_symbols *plVar25;\n  undefined8 *puVar26;\n  int loop_counter;\n  lonstrip_symbols *ptr_3;\n  ulonstrip_symbols updated_value;\n  ulonstrip_symbols *puVar30;\n  char *temp_string_2;\n  undefined4 *puVar32;\n  undefined *ptr_1;\n  lonstrip_symbols *symbol_list;\n  char **ppcVar34;\n  void *pvVar35;\n  undefined8 *bfd_data;\n  undefined **ppuVar36;\n  lonstrip_symbols lVar37;\n  bool bVar38;\n  byte temp_flag;\n  lonstrip_symbols binary;\n  ulonstrip_symbols section_count;\n  char debugging_info_flag;\n  undefined4 *string_buffer_02;\n  ulonstrip_symbols gap_fill_size;\n  char *param_13;\n  undefined *gap_fill_buffer;\n  uint gap_fill_set;\n  lonstrip_symbols *param_17;\n  undefined8 in_stack_00000068;\n  undefined8 param_21;\n  lonstrip_symbols param_23;\n  char *param_24;\n  lonstrip_symbols param_26;\n  lonstrip_symbols *param_30;\n  ulonstrip_symbols param_31;\n  lonstrip_symbols param_32;\n  lonstrip_symbols in_stack_000000d8;\n  void *param_33;\n  lonstrip_symbols param_34;\n  undefined8 in_stack_000000f8;\n  byte param_36;\n  byte param_37;\n  undefined8 param_38;\n  ushort param_39;\n  lonstrip_symbols *param_40;\n  char param_41;\n  char *param_42;\n  undefined param_43;\n  short param_44;\n  \n  temp_flag = 0;\n  if ((strip_symbolsap_fill_set == '\\0') && (pad_to_set == '\\0')) {\n    gap_fill_size = 0;\n    gap_fill_buffer = (undefined *)0x0;\n    param_17 = (lonstrip_symbols *)0x0;\n    updated_value = gap_fill_size;\n  }\n  else {\n    temp_value = (ulonstrip_symbols)in_stack_00000068._4_4_ * 8;\n    param_17 = (lonstrip_symbols *)xmalloc(temp_value);\n    param_40 = param_17;\n    bfd_map_over_sections(binary,strip_symbolset_sections,&stack0x00000140);\n    qsort(param_17,(ulonstrip_symbols)in_stack_00000068._4_4_,8,compare_section_lma);\n    gap_fill_buffer = (undefined *)xmalloc(temp_value);\n    bVar38 = strip_symbolsap_fill_set != '\\0';\n    ptr_1 = gap_fill_buffer;\n    for (; temp_value != 0; temp_value = temp_value + -1) {\n      *ptr_1 = 0;\n      ptr_1 = ptr_1 + (ulonstrip_symbols)temp_flag * -2 + 1;\n    }\n    if (bVar38) {\n      updated_value = 0;\n      gap_fill_size = 0;\n      do {\n        puVar30 = (ulonstrip_symbols *)(gap_fill_buffer + updated_value * 8);\n        ptr_3 = param_17 + updated_value;\n        temp_value_2 = gap_fill_size;\n        do {\n          gap_fill_size = temp_value_2;\n          if (in_stack_00000068._4_4_ - 1 <= (uint)updated_value) strip_symbolsoto LAB_00107cd1;\n          updated_value = (ulonstrip_symbols)((uint)updated_value + 1);\n          uVar12 = bfd_octets_per_byte(binary,*ptr_3);\n          uVar13 = bfd_octets_per_byte(binary);\n          temp_value = *ptr_3;\n          if ((*(uint *)(temp_value + 0x24) & 0x102) != 0x102) break;\n          temp_value_2 = (ulonstrip_symbols)uVar13 * *(lonstrip_symbols *)(ptr_3[1] + 0x38);\n          uVar24 = (ulonstrip_symbols)uVar12 * *(lonstrip_symbols *)(temp_value + 0x38) + *(lonstrip_symbols *)(temp_value + 0x40);\n          if (temp_value_2 <= uVar24) break;\n          temp_value_2 = temp_value_2 - uVar24;\n          cVar7 = bfd_set_section_size();\n          if (cVar7 == '\\0') {\n            dcstrip_symbolsettext(0,\"Can\\'t fill strip_symbolsap after section\",5);\n            bfd_nonfatal_messastrip_symbolse(0,binary,*ptr_3);\n            status = 1;\n            strip_symbolsoto LAB_00107cd1;\n          }\n          *puVar30 = temp_value_2;\n          ptr_3 = ptr_3 + 1;\n          puVar30 = puVar30 + 1;\n        } while (gap_fill_size < temp_value_2);\n      } while( true );\n    }\n    gap_fill_size = 0;\nLAB_00107cd1:\n    updated_value = gap_fill_size;\n    if (pad_to_set != '\\0') {\n      uVar12 = bfd_octets_per_byte(binary);\n      temp_value = param_17[in_stack_00000068._4_4_ - 1];\n      temp_value_2 = pad_to * (ulonstrip_symbols)uVar12;\n      uVar24 = *(lonstrip_symbols *)(temp_value + 0x40) + (ulonstrip_symbols)uVar12 * *(lonstrip_symbols *)(temp_value + 0x38);\n      if (uVar24 < temp_value_2) {\n        cVar7 = bfd_set_section_size();\n        if (cVar7 == '\\0') {\n          dcstrip_symbolsettext(0,\"can\\'t add paddinstrip_symbols\",5);\n          bfd_nonfatal_messastrip_symbolse(0,binary,param_17[in_stack_00000068._4_4_ - 1]);\n          status = 1;\n        }\n        else {\n          updated_value = temp_value_2 - uVar24;\n          *(ulonstrip_symbols *)(gap_fill_buffer + (ulonstrip_symbols)(in_stack_00000068._4_4_ - 1) * 8) = updated_value;\n          if (updated_value <= gap_fill_size) {\n            updated_value = gap_fill_size;\n          }\n        }\n      }\n    }\n  }\n  gap_fill_size = updated_value;\n  ptr_3 = isympp;\n  if (convert_debustrip_symbolsstrip_symbolsinstrip_symbols == '\\0') {\nLAB_00105588:\n    string_buffer_02 = (undefined4 *)0x0;\n  }\n  else {\n    ppuVar36 = &names_0;\n    string_buffer_02 = (undefined4 *)xmalloc(0x60);\n    puVar32 = string_buffer_02;\n    for (temp_value = 0x18; temp_value != 0; temp_value = temp_value + -1) {\n      *puVar32 = 0;\n      puVar32 = puVar32 + (ulonstrip_symbols)temp_flag * -2 + 1;\n    }\n    param_13 = (char *)0x0;\n    do {\n      ptr_1 = *ppuVar36;\n      temp_value = bfd_strip_symbolset_section_by_name(bfd_data,ptr_1);\n      lVar37 = bfd_strip_symbolset_section_by_name();\n      if ((temp_value != 0) && (lVar37 != 0)) {\n        lVar23 = *(lonstrip_symbols *)(temp_value + 0x40);\n        string_buffer_00 = (void *)xmalloc(lVar23);\n        cVar7 = bfd_strip_symbolset_section_contents(bfd_data,temp_value,string_buffer_00,0,lVar23);\n        if (cVar7 == '\\0') {\n          uVar9 = bfd_strip_symbolset_error();\n          bfd_errmsstrip_symbols(uVar9);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*bfd_data);\n          free(param_13);\n          free(string_buffer_00);\n        }\n        else {\n          updated_value = *(ulonstrip_symbols *)(lVar37 + 0x40);\n          string_buffer_01 = (void *)xmalloc(updated_value + 1);\n          debugging_info_flag = bfd_strip_symbolset_section_contents(bfd_data,lVar37,string_buffer_01,0);\n          if (debugging_info_flag == '\\0') {\n            uVar9 = bfd_strip_symbolset_error();\n            bfd_errmsstrip_symbols(uVar9);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*bfd_data);\n            free(param_13);\n          }\n          else {\n            *(undefined *)((lonstrip_symbols)string_buffer_01 + updated_value) = 0;\n            if ((param_13 != (char *)0x0) ||\n               (param_13 = (char *)start_stab_constprop_0(bfd_data,1,ptr_3),\n               param_13 != (char *)0x0)) {\n              param_26 = 0;\n              param_23 = 0;\n              for (pvVar35 = string_buffer_00; pvVar35 <= (void *)((lonstrip_symbols)string_buffer_00 + lVar23 + -0xc);\n                  pvVar35 = (void *)((lonstrip_symbols)pvVar35 + 0xc)) {\n                temp_value_2 = (**(code **)(bfd_data[1] + 0x40))(pvVar35);\n                bVar2 = *(byte *)((lonstrip_symbols)pvVar35 + 4);\n                uVar9 = (**(code **)(bfd_data[1] + 0x58))((lonstrip_symbols)pvVar35 + 6);\n                temp_value = (**(code **)(bfd_data[1] + 0x40))((lonstrip_symbols)pvVar35 + 8);\n                if (bVar2 == 0) {\n                  param_23 = param_26;\n                  param_26 = param_26 + temp_value;\n                }\n                else {\n                  uVar24 = (temp_value_2 & 0xffffffff) + param_23;\n                  if (uVar24 < updated_value) {\n                    temp_string_2 = (char *)((lonstrip_symbols)string_buffer_01 + uVar24);\n                    param_24 = (char *)0x0;\n                    while( true ) {\n                      str_length = strlen(temp_string_2);\n                      if (((str_length == 0) || (pcVar22 = temp_string_2 + (str_length - 1), *pcVar22 != '\\')) ||\n                         ((ulonstrip_symbols)((lonstrip_symbols)string_buffer_00 + lVar23) < (lonstrip_symbols)pvVar35 + 0x10U))\n                      strip_symbolsoto LAB_001077fb;\n                      *pcVar22 = '\\0';\n                      pvVar35 = (void *)((lonstrip_symbols)pvVar35 + 0xc);\n                      iVar10 = (**(code **)(bfd_data[1] + 0x40))(pvVar35);\n                      temp_value_2 = (ulonstrip_symbols)(uint)(iVar10 + (int)param_23);\n                      if (updated_value <= temp_value_2) break;\n                      temp_string_2 = (char *)concat(temp_string_2,(lonstrip_symbols)string_buffer_01 + temp_value_2,0);\n                      *pcVar22 = '\\';\n                      free(param_24);\n                      param_24 = temp_string_2;\n                    }\n                    result_2 = *bfd_data;\n                    pcVar22 = (char *)dcstrip_symbolsettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar22,result_2,ptr_1,((lonstrip_symbols)pvVar35 - (lonstrip_symbols)string_buffer_00) / 0xc);\nLAB_001077fb:\n                    save_stab((ulonstrip_symbols)bVar2,uVar9,temp_value,temp_string_2);\n                    cVar7 = parse_stab(string_buffer_02,param_13,bVar2);\n                    if (cVar7 == '\\0') {\n                      stab_context();\n                      free_saved_stabs();\n                      free(param_24);\n                      free(param_13);\n                      free(string_buffer_00);\n                      free(string_buffer_01);\n                      strip_symbolsoto LAB_00105981;\n                    }\n                  }\n                  else {\n                    result_2 = *bfd_data;\n                    temp_string_2 = (char *)dcstrip_symbolsettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,temp_string_2,result_2,ptr_1,((lonstrip_symbols)pvVar35 - (lonstrip_symbols)string_buffer_00) / 0xc,\n                            temp_value_2 & 0xffffffff,(ulonstrip_symbols)bVar2,((lonstrip_symbols)pvVar35 - (lonstrip_symbols)string_buffer_00) % 0xc)\n                    ;\n                  }\n                }\n              }\n              free_saved_stabs();\n              free(string_buffer_00);\n              strip_symbolsoto LAB_001058eb;\n            }\n          }\n          free(string_buffer_01);\n          free(string_buffer_00);\n        }\n        strip_symbolsoto LAB_00105981;\n      }\nLAB_001058eb:\n      ppuVar36 = ppuVar36 + 2;\n    } while (ppuVar36 != (undefined **)&DAT_00125c90);\n    if ((param_13 != (char *)0x0) && (cVar7 = finish_stab(), cVar7 == '\\0')) {\nLAB_00105981:\n      free(string_buffer_02);\n      strip_symbolsoto LAB_00105588;\n    }\n    if (*(int *)(bfd_data[1] + 8) == 1) {\n      temp_value = 0;\n      for (plVar15 = ptr_3; plVar15 < ptr_3 + section_count; plVar15 = plVar15 + 1) {\n        (**(code **)(bfd_data[1] + 0x218))(bfd_data,*plVar15,&stack0x00000140);\n        if (param_41 == '-') {\n          if (((temp_value == 0) && (temp_value = start_stab_constprop_0(bfd_data,0,ptr_3), temp_value == 0))\n             || ((param_42 == (char *)0x0 || (*param_42 == '\\0')))) strip_symbolsoto LAB_00105981;\n          temp_string_2 = (char *)0x0;\n          pcVar22 = param_42;\n          while (((*pcVar22 != '\\0' && (str_length = strlen(pcVar22), pcVar22[str_length - 1] == '\\')) &&\n                 (plVar15 + 1 < ptr_3 + section_count))) {\n            temp_string = (char *)xstrdup(pcVar22);\n            str_length = strlen(temp_string);\n            temp_string[str_length - 1] = '\\0';\n            pcVar22 = (char *)concat(temp_string,*(undefined8 *)(plVar15[1] + 8),0);\n            free(temp_string);\n            free(temp_string_2);\n            plVar15 = plVar15 + 1;\n            temp_string_2 = pcVar22;\n          }\n          save_stab(param_43,(int)param_44,param_40,pcVar22);\n          debugging_info_flag = parse_stab(string_buffer_02,temp_value,param_43);\n          if (debugging_info_flag == '\\0') {\n            stab_context();\n            free_saved_stabs();\n            strip_symbolsoto LAB_00105981;\n          }\n        }\n      }\n      free_saved_stabs();\n      if ((temp_value != 0) && (cVar7 = finish_stab(), cVar7 == '\\0')) strip_symbolsoto LAB_00105981;\n    }\n    if (debugging_info_flag == '\\0') {\n      if ((*(int *)(bfd_data[1] + 8) == 2) && (section_count != 0)) {\n        param_40 = (lonstrip_symbols *)0x0;\n        param_30 = ptr_3;\n        param_32 = 0;\n        param_31 = section_count;\n        in_stack_000000d8 = 0;\n        puVar26 = (undefined8 *)&stack0x00000148;\n        for (temp_value = 0x22; temp_value != 0; temp_value = temp_value + -1) {\n          *(undefined4 *)puVar26 = 0;\n          puVar26 = (undefined8 *)((lonstrip_symbols)puVar26 + (ulonstrip_symbols)temp_flag * -8 + 4);\n        }\n        cVar7 = '\\0';\n        loop_variable_1 = (int *)0x0;\n        uVar12 = 0;\n        param_13 = (char *)0x0;\n        param_24 = (char *)0xffffffffffffffff;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((lonstrip_symbols)section_count <= param_32) strip_symbolsoto LAB_00105590;\n            temp_value = ptr_3[param_32];\n            cVar8 = bfd_coff_strip_symbolset_syment(bfd_data,temp_value,&stack0x000000e0);\n            lVar37 = in_stack_000000d8;\n            if (cVar8 == '\\0') {\n              uVar9 = bfd_strip_symbolset_error();\n              bfd_errmsstrip_symbols(uVar9);\n              temp_string_2 = \"bfd_coff_strip_symbolset_syment failed: %s\";\n              strip_symbolsoto LAB_00105968;\n            }\n            temp_string_2 = *(char **)(temp_value + 8);\n            puVar26 = (undefined8 *)0x0;\n            param_32 = param_32 + 1;\n            in_stack_000000d8 = (ulonstrip_symbols)param_37 + 1 + in_stack_000000d8;\n            if (param_37 != 0) {\n              puVar26 = &stack0x00000110;\n              cVar8 = bfd_coff_strip_symbolset_auxent(bfd_data,temp_value,0);\n              if (cVar8 == '\\0') {\n                uVar9 = bfd_strip_symbolset_error();\n                bfd_errmsstrip_symbols(uVar9);\n                temp_string_2 = \"bfd_coff_strip_symbolset_auxent failed: %s\";\n                strip_symbolsoto LAB_00105968;\n              }\n            }\n            if (param_24 != (char *)lVar37) break;\n            if (param_36 != 0x67) {\n              cVar8 = debustrip_symbols_set_filename(string_buffer_02);\n              if (cVar8 != '\\0') break;\n              strip_symbolsoto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            param_24 = (char *)param_34;\n            cVar8 = debustrip_symbols_set_filename(string_buffer_02);\n            if (cVar8 == '\\0') strip_symbolsoto LAB_00105981;\n          }\n          uVar6 = in_stack_000000f8._6_2_;\n          if ((char)param_36 < '\\0') {\n            if (param_36 == 0xff) strip_symbolsoto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            lVar23 = parse_coff_type_lto_priv_0(bfd_data,&stack0x000000c0,&stack0x00000140);\n            if (lVar23 == 0) break;\n            cVar8 = parse_coff_symbol_constprop_0_isra_0(&stack0x00000140,temp_value,lVar37);\n          }\n          else {\n            if (param_36 < 100) {\n              switch(param_36) {\n              case 3:\n                if (in_stack_000000f8._6_2_ == 0) strip_symbolsoto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulonstrip_symbols)((uint)in_stack_000000f8._6_2_ & *(uint *)(bfd_data[0x22] + 0x40)) !=\n                    2L << ((byte)*(undefined4 *)(bfd_data[0x22] + 0x3c) & 0x3f)) strip_symbolsoto LAB_0010700a;\n                loop_variable_1 = (int *)(**(code **)(bfd_data[1] + 0x238))(bfd_data);\n                uVar12 = (uint)uVar6;\n                param_13 = temp_string_2;\n                strip_symbolsoto switchD_00106e1a_caseD_68;\n              default:\n                strip_symbolsoto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                strip_symbolsoto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(param_36) {\n            case 100:\n              iVar10 = strcmp(temp_string_2,\".bb\");\n              if (iVar10 == 0) {\n                cVar8 = debustrip_symbols_start_block(string_buffer_02);\n              }\n              else {\n                iVar10 = strcmp(temp_string_2,\".eb\");\n                if (iVar10 != 0) strip_symbolsoto switchD_00106e1a_caseD_68;\n                cVar8 = debustrip_symbols_end_block(string_buffer_02);\n              }\n              break;\n            case 0x65:\n              iVar10 = strcmp(temp_string_2,\".bf\");\n              if (iVar10 == 0) {\n                if (param_13 != (char *)0x0) {\n                  uVar13 = (int)uVar12 >> ((byte)*(undefined4 *)(bfd_data[0x22] + 0x44) & 0x1f);\n                  lVar37 = parse_coff_type_lto_priv_0\n                                     (bfd_data,&stack0x000000c0,&stack0x00000140,lVar37,\n                                      uVar13 ^ (uVar12 ^ uVar13) & *(uint *)(bfd_data[0x22] + 0x38)\n                                      ,puVar26,0,string_buffer_02);\n                  if ((lVar37 == 0) || (cVar7 = debustrip_symbols_record_function(string_buffer_02), cVar7 == '\\0'))\n                  strip_symbolsoto LAB_00105981;\n                  if (loop_variable_1 != (int *)0x0) {\n                    iVar10 = 0;\n                    if (param_37 != 0) {\n                      iVar10 = param_39 - 1;\n                    }\n                    temp_value = *(lonstrip_symbols *)(*(lonstrip_symbols *)(temp_value + 0x20) + 0x30);\n                    while( true ) {\n                      loop_counter = loop_variable_1[4];\n                      if (loop_counter == 0) break;\n                      cVar8 = debustrip_symbols_record_line(string_buffer_02,iVar10 + loop_counter,\n                                                *(lonstrip_symbols *)(loop_variable_1 + 6) + temp_value);\n                      loop_variable_1 = loop_variable_1 + 4;\n                      if (cVar8 == '\\0') strip_symbolsoto LAB_00105981;\n                    }\n                  }\n                  uVar12 = 0;\n                  loop_variable_1 = (int *)0x0;\n                  param_13 = (char *)0x0;\n                  strip_symbolsoto switchD_00106e1a_caseD_68;\n                }\n                temp_string_2 = \"%ld: .bf without precedinstrip_symbols function\";\n              }\n              else {\n                iVar10 = strcmp(temp_string_2,\".ef\");\n                if (iVar10 != 0) strip_symbolsoto switchD_00106e1a_caseD_68;\n                if (cVar7 != '\\0') {\n                  cVar7 = debustrip_symbols_end_function(string_buffer_02);\n                  if (cVar7 == '\\0') strip_symbolsoto LAB_00105981;\n                  cVar7 = '\\0';\n                  strip_symbolsoto switchD_00106e1a_caseD_68;\n                }\n                temp_string_2 = \"%ld: unexpected .ef\\n\";\n              }\n              result_2 = dcstrip_symbolsettext(0,temp_string_2,5);\n              non_fatal(result_2);\n              strip_symbolsoto LAB_00105981;\n            default:\n              strip_symbolsoto LAB_0010700a;\n            case 0x67:\n              strip_symbolsoto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              strip_symbolsoto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              strip_symbolsoto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (cVar8 != '\\0');\n      }\n      else {\n        temp_string_2 = \"%s: no recostrip_symbolsnized debustrip_symbolsstrip_symbolsinstrip_symbols information\";\nLAB_00105968:\n        result_2 = dcstrip_symbolsettext(0,temp_string_2,5);\n        non_fatal(result_2);\n      }\n      strip_symbolsoto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)(binary + 0x44) & 0x42) != 0) && ((*(uint *)(binary + 0x44) & 1) == 0)) {\n    if ((*(char *)(*(lonstrip_symbols *)(binary + 8) + 0x20) == '\\0') && (keep_section_symbols == '\\0')) {\n      if (section_count != 0) {\n        ptr_3 = isympp + section_count;\n        plVar15 = isympp;\n        do {\n          uVar12 = *(uint *)(*plVar15 + 0x18);\n          if ((uVar12 & 0x1000000) != 0) {\n            *(uint *)(*plVar15 + 0x18) = uVar12 & 0xfeffffff;\n          }\n          plVar15 = plVar15 + 1;\n        } while (ptr_3 != plVar15);\n      }\n    }\n    else {\n      for (temp_value = *(lonstrip_symbols *)(binary + 0x90); temp_value != 0; temp_value = *(lonstrip_symbols *)(temp_value + 8)) {\n        if (*(lonstrip_symbols *)(temp_value + 0xe8) != 0) {\n          puVar1 = (uint *)(*(lonstrip_symbols *)(temp_value + 0xe8) + 0x18);\n          *puVar1 = *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((strip_symbols == 2) || (strip_symbols == 7)) {\nLAB_001059fe:\n    if (strip_symbols == 7) {\nLAB_00105a3b:\n      temp_value = xmalloc();\n      ptr_3 = isympp;\n      gap_fill_set = *(uint *)((lonstrip_symbols)bfd_data + 0x44) & 0x42;\n      osympp = temp_value;\n      if (section_count == 0) {\n        updated_value = 0;\n      }\n      else {\n        updated_value = 0;\n        _debugging_info_flag = 0;\n        do {\n          iVar10 = add_symbols;\n          plVar15 = (lonstrip_symbols *)ptr_3[_debugging_info_flag];\n          pcVar3 = (code *)plVar15[4];\n          uVar12 = *(uint *)(plVar15 + 3);\n          ptr_2 = (lonstrip_symbols *)plVar15[1];\n          plVar25 = ptr_2;\n          if (add_sym_list != (undefined8 *)0x0) {\n            loop_counter = 0;\n            puVar26 = add_sym_list;\n            while ((loop_counter < iVar10 && (temp_string_2 = (char *)puVar26[5], temp_string_2 != (char *)0x0))) {\n              if (temp_string_2 != \"\") {\n                iVar11 = strcmp(temp_string_2,(char *)ptr_2);\n                if (iVar11 == 0) {\n                  free(temp_string_2);\n                  temp_value_2 = updated_value + 1;\n                  puVar26[5] = \"\";\n                  result_1 = create_new_symbol(puVar26);\n                  result_2 = redefine_specific_htab;\n                  *(undefined8 *)(temp_value + updated_value * 8) = result_1;\n                  lVar37 = htab_elements(result_2);\n                  if ((lVar37 != 0) || (section_rename_list != (char **)0x0)) strip_symbolsoto LAB_001064eb;\n                  strip_symbolsoto LAB_00105af8;\n                }\n                puVar26 = (undefined8 *)*puVar26;\n              }\n              loop_counter = loop_counter + 1;\n            }\n          }\n          lVar37 = htab_elements(redefine_specific_htab);\n          temp_value_2 = updated_value;\n          if ((lVar37 != 0) || (section_rename_list != (char **)0x0)) {\n            if (ptr_2 != (lonstrip_symbols *)0x0) {\nLAB_001064eb:\n              if (((*(char *)ptr_2 == '_') && (*(char *)((lonstrip_symbols)ptr_2 + 1) == '_')) &&\n                 (iVar10 = strcmp((char *)((ulonstrip_symbols)(*(char *)((lonstrip_symbols)ptr_2 + 2) == '_') +\n                                          (lonstrip_symbols)ptr_2),\"__strip_symbolsnu_lto_slim\"), iVar10 == 0)) {\n                result_2 = dcstrip_symbolsettext(0,\"redefininstrip_symbols symbols does not work on LTO-compiled object files\"\n                                   ,5);\n                    \n                fatal(result_2);\n              }\n            }\n            loop_variable_2 = 0;\n            param_40 = ptr_2;\n            lVar37 = htab_find(redefine_specific_htab);\n            if (((lVar37 == 0) || (plVar25 = *(lonstrip_symbols **)(lVar37 + 8), ptr_2 == plVar25)) &&\n               (plVar25 = ptr_2, ppcVar34 = section_rename_list, (uVar12 & 0x100) != 0)) {\n              for (; ppcVar34 != (char **)0x0; ppcVar34 = (char **)ppcVar34[3]) {\n                iVar10 = strcmp(*ppcVar34,(char *)ptr_2);\n                if (iVar10 == 0) {\n                  plVar25 = (lonstrip_symbols *)ppcVar34[1];\n                  break;\n                }\n              }\n            }\n            plVar15[1] = (lonstrip_symbols)plVar25;\n            cVar7 = *(char *)plVar25;\n            if (cVar7 != '\\0') strip_symbolsoto LAB_00105b11;\nLAB_00106557:\n            temp_string_2 = prefix_symbols_strinstrip_symbols;\n            if ((chanstrip_symbolse_leadinstrip_symbols_char != '\\0') && (*(char *)(*(lonstrip_symbols *)(binary + 8) + 0x1c) != '\\0'))\n            {\n              lVar37 = bfd_data[1];\n              cVar7 = '\\0';\n              strip_symbolsoto LAB_0010668d;\n            }\n            strip_symbolsoto joined_r0x00106565;\n          }\nLAB_00105af8:\n          cVar7 = *(char *)ptr_2;\n          if (cVar7 == '\\0') strip_symbolsoto LAB_00106557;\nLAB_00105b11:\n          temp_string_2 = prefix_symbols_strinstrip_symbols;\n          lVar37 = bfd_data[1];\n          if (*(char *)(lVar37 + 0x1c) == cVar7) {\n            if (chanstrip_symbolse_leadinstrip_symbols_char == '\\0') {\n              if ((remove_leadinstrip_symbols_char == '\\0') ||\n                 ((((uVar12 & 0x82) == 0 && (pcVar3 != bfd_map_over_sections)) &&\n                  ((*(byte *)(plVar15[4] + 0x25) & 0x10) == 0)))) strip_symbolsoto joined_r0x00106565;\nLAB_0010677d:\n              plVar25 = (lonstrip_symbols *)((lonstrip_symbols)plVar25 + 1);\n              plVar15[1] = (lonstrip_symbols)plVar25;\n              strip_symbolsoto joined_r0x00106565;\n            }\n            cVar7 = *(char *)(*(lonstrip_symbols *)(binary + 8) + 0x1c);\n            if (cVar7 == '\\0') strip_symbolsoto LAB_0010677d;\n            if (prefix_symbols_strinstrip_symbols != (char *)0x0) {\n              plVar25 = (lonstrip_symbols *)((lonstrip_symbols)plVar25 + 1);\n              plVar15[1] = (lonstrip_symbols)plVar25;\n              str_length = strlen((char *)plVar25);\n              lVar37 = str_length + 2;\nLAB_001066bc:\n              str_length = strlen(temp_string_2);\n              ptr_2 = (lonstrip_symbols *)xmalloc(str_length + lVar37);\n              strip_symbolsoto LAB_001066d0;\n            }\n            *(char *)plVar25 = cVar7;\n            plVar15[1] = (lonstrip_symbols)plVar25;\n            updated_value = temp_value_2;\n          }\n          else {\n            if ((chanstrip_symbolse_leadinstrip_symbols_char == '\\0') || (*(char *)(*(lonstrip_symbols *)(binary + 8) + 0x1c) == '\\0'))\n            {\njoined_r0x00106565:\n              updated_value = temp_value_2;\n              if (temp_string_2 == (char *)0x0) strip_symbolsoto LAB_00105b32;\n              str_length = strlen((char *)plVar25);\n              sVar19 = strlen(temp_string_2);\n              __dest = (lonstrip_symbols *)xmalloc(sVar19 + str_length + 1);\n              ptr_2 = __dest;\n            }\n            else {\nLAB_0010668d:\n              temp_string_2 = prefix_symbols_strinstrip_symbols;\n              if ((*(char *)(lVar37 + 0x1c) != '\\0') && (cVar7 != *(char *)(lVar37 + 0x1c)))\n              strip_symbolsoto joined_r0x00106565;\n              str_length = strlen((char *)plVar25);\n              lVar37 = str_length + 2;\n              if (temp_string_2 != (char *)0x0) strip_symbolsoto LAB_001066bc;\n              ptr_2 = (lonstrip_symbols *)xmalloc(lVar37);\nLAB_001066d0:\n              __dest = (lonstrip_symbols *)((lonstrip_symbols)ptr_2 + 1);\n              *(char *)ptr_2 = *(char *)(*(lonstrip_symbols *)(binary + 8) + 0x1c);\n            }\n            temp_string_2 = prefix_symbols_strinstrip_symbols;\n            if (prefix_symbols_strinstrip_symbols != (char *)0x0) {\n              strcpy((char *)__dest,prefix_symbols_strinstrip_symbols);\n              str_length = strlen(temp_string_2);\n              __dest = (lonstrip_symbols *)((lonstrip_symbols)__dest + str_length);\n            }\n            strcpy((char *)__dest,(char *)plVar25);\n            plVar15[1] = (lonstrip_symbols)ptr_2;\n            plVar25 = ptr_2;\n            updated_value = temp_value_2;\n          }\nLAB_00105b32:\n          if (strip_symbols == 7) strip_symbolsoto LAB_001067a8;\n          if (((uVar12 & 0x20) == 0) &&\n             (((uVar12 & 0x100) == 0 ||\n              ((*(byte *)(**(lonstrip_symbols **)(plVar15[4] + 0xf0) + 0x18) & 0x20) == 0)))) {\n            if (((gap_fill_set == 0) &&\n                (((uVar12 & 0x82) != 0 || ((*(byte *)(plVar15[4] + 0x25) & 0x10) != 0)))) ||\n               (iVar10 = bfd_decode_symclass(plVar15), iVar10 == 0x49)) {\nLAB_00105be2:\n              if (wildcard == '\\0') {\n                lVar37 = htab_find();\n                if (lVar37 == 0) strip_symbolsoto LAB_00105c07;\n              }\n              else {\n                loop_variable_2 = loop_variable_2 & 0xffffffffffffff00;\n                param_40 = plVar25;\n                htab_traverse(strip_specific_htab,is_specified_symbol_predicate,&stack0x00000140);\n                if (param_41 == '\\0') strip_symbolsoto LAB_00105c07;\n              }\n            }\n            else if ((((uVar12 & 0x82) == 0) && (pcVar3 != bfd_map_over_sections)) &&\n                    ((*(byte *)(plVar15[4] + 0x25) & 0x10) == 0)) {\n              if ((uVar12 & 4) == 0) {\n                if (((*(int *)(bfd_data[1] + 8) != 2) ||\n                    (lVar37 = *(lonstrip_symbols *)(plVar15[4] + 0xd0), lVar37 == 0)) ||\n                   (*(lonstrip_symbols *)(lVar37 + 0x40) == 0)) {\n                  if ((strip_symbols == 3) || (discard_locals == 2)) strip_symbolsoto LAB_001067a8;\n                  if (discard_locals == 1) {\n                    cVar7 = bfd_is_local_label(bfd_data);\n                    strip_symbolsoto joined_r0x00106a11;\n                  }\n                }\n                strip_symbolsoto LAB_00105be2;\n              }\n              cVar7 = convert_debustrip_symbolsstrip_symbolsinstrip_symbols;\n              if (1 < strip_symbols - 2U) {\njoined_r0x00106a11:\n                if (cVar7 == '\\0') strip_symbolsoto LAB_00105be2;\n              }\n            }\n            else if (strip_symbols != 3) strip_symbolsoto LAB_00105be2;\n            strip_symbolsoto LAB_001067a8;\n          }\n          if (wildcard == '\\0') {\n            lVar37 = htab_find();\n            if (lVar37 != 0) {\nLAB_0010687f:\n              result_2 = dcstrip_symbolsettext(0,\"not strippinstrip_symbols symbol `%s\\' because it is named in a relocation\",\n                                 5);\n              non_fatal(result_2);\n              status = 1;\n            }\n          }\n          else {\n            loop_variable_2 = loop_variable_2 & 0xffffffffffffff00;\n            param_40 = plVar25;\n            htab_traverse(strip_specific_htab,is_specified_symbol_predicate,&stack0x00000140);\n            if (param_41 != '\\0') strip_symbolsoto LAB_0010687f;\n          }\n          if ((uVar12 & 0x20) == 0) {\nLAB_00105c07:\n            if (wildcard != '\\0') {\n              loop_variable_2 = loop_variable_2 & 0xffffffffffffff00;\n              param_40 = plVar25;\n              htab_traverse(strip_unneeded_htab,is_specified_symbol_predicate,&stack0x00000140);\n              if (param_41 != '\\0') strip_symbolsoto LAB_001067a8;\n              strip_symbolsoto LAB_00105c2c;\n            }\n            lVar37 = htab_find();\n            if (lVar37 == 0) strip_symbolsoto LAB_00105c2c;\nLAB_001067a8:\n            if ((keep_file_symbols != '\\0') && ((uVar12 & 0x4000) != 0)) strip_symbolsoto LAB_00105c2c;\n            if (wildcard == '\\0') {\n              lVar37 = htab_find();\n              if (lVar37 != 0) strip_symbolsoto LAB_00105c2c;\n            }\n            else {\n              loop_variable_2 = loop_variable_2 & 0xffffffffffffff00;\n              param_40 = plVar25;\n              htab_traverse(keep_specific_htab,is_specified_symbol_predicate,&stack0x00000140);\n              if (param_41 != '\\0') strip_symbolsoto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            cVar7 = is_strip_section_isra_0(plVar15[4]);\n            if (cVar7 == '\\0') {\n              if (((uVar12 & 0x800002) == 0) && (pcVar3 != bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uVar12 & 0x82) != 0) {\n                  cVar7 = is_specified_symbol(plVar25);\n                  if ((cVar7 == '\\0') &&\n                     ((lVar37 = htab_elements(keepstrip_symbolslobal_specific_htab), lVar37 == 0 ||\n                      (cVar7 = is_specified_symbol(plVar25), cVar7 != '\\0')))) {\n                    if (((((localize_hidden == '\\0') ||\n                          (uVar13 = *(uint *)(plVar15 + 3), (uVar13 & 0x200000) != 0)) ||\n                         (lVar37 = *plVar15, lVar37 == 0)) ||\n                        ((*(int *)(*(lonstrip_symbols *)(lVar37 + 8) + 8) != 5 ||\n                         (*(lonstrip_symbols *)(lVar37 + 0x110) == 0)))) ||\n                       (1 < (*(byte *)((lonstrip_symbols)plVar15 + 0x49) & 3) - 1)) strip_symbolsoto joined_r0x00106920;\n                  }\n                  else {\n                    uVar13 = *(uint *)(plVar15 + 3);\n                  }\n                  *(uint *)(plVar15 + 3) = uVar13 & 0xffffff7d | 1;\n                }\njoined_r0x00106920:\n                if (((uVar12 & 1) != 0) && (cVar7 = is_specified_symbol(plVar25), cVar7 != '\\0')) {\n                  *(uint *)(plVar15 + 3) = *(uint *)(plVar15 + 3) & 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((weaken != '\\0') || (cVar7 = is_specified_symbol(plVar25), cVar7 != '\\0')) {\n                  *(uint *)(plVar15 + 3) = *(uint *)(plVar15 + 3) & 0xff7ffffd | 0x80;\n                }\n                if (pcVar3 != bfd_map_over_sections) strip_symbolsoto LAB_00105c5f;\n              }\n              *(lonstrip_symbols **)(temp_value + updated_value * 8) = plVar15;\n              updated_value = updated_value + 1;\n            }\n          }\n          _debugging_info_flag = _debugging_info_flag + 1;\n        } while (section_count != _debugging_info_flag);\n      }\n      if (add_sym_list != (undefined8 *)0x0) {\n        puVar26 = add_sym_list;\n        iVar10 = add_symbols;\n        for (lVar37 = 0; lVar37 < iVar10; lVar37 = lVar37 + 1) {\n          temp_string_2 = (char *)puVar26[5];\n          if (temp_string_2 == (char *)0x0) {\n            lVar23 = updated_value * 8;\n            updated_value = updated_value + 1;\n            result_2 = create_new_symbol(puVar26,binary);\n            *(undefined8 *)(temp_value + lVar23) = result_2;\n            iVar10 = add_symbols;\n          }\n          else if (temp_string_2 != \"\") {\n            result_2 = dcstrip_symbolsettext(0,\"\\'before=%s\\' not found\",5);\n                    \n            fatal(result_2,temp_string_2);\n          }\n          puVar26 = (undefined8 *)*puVar26;\n        }\n      }\n      bVar38 = convert_debustrip_symbolsstrip_symbolsinstrip_symbols == '\\0';\n      *(undefined8 *)(temp_value + updated_value * 8) = 0;\n      if ((bVar38) || (string_buffer_02 == (undefined4 *)0x0)) {\nLAB_00105cfa:\n        section_count = updated_value & 0xffffffff;\n        strip_symbolsoto LAB_00105710;\n      }\n      iVar10 = *(int *)(*(undefined8 **)(binary + 8) + 1);\n      if ((iVar10 == 5) || (iVar10 == 2)) {\n        param_33 = (void *)0x0;\n        cVar7 = write_stabs_in_sections_debustrip_symbolsstrip_symbolsinstrip_symbols_info_constprop_0\n                          (binary,string_buffer_02,&stack0x000000c0,&stack0x00000110,&stack0x000000e0,\n                           &stack0x00000140);\n        if (cVar7 != '\\0') {\n          temp_value = bfd_make_section_with_flastrip_symbolss(binary,\".stab\",0x2108);\n          lVar37 = bfd_make_section_with_flastrip_symbolss(binary,\".stabstr\",0x2108);\n          if ((((temp_value == 0) || (lVar37 == 0)) ||\n              (cVar7 = bfd_set_section_size(temp_value,param_38), cVar7 == '\\0')) ||\n             (cVar7 = bfd_set_section_size(lVar37,param_40), cVar7 == '\\0')) {\n            temp_string_2 = \"can\\'t create debustrip_symbolsstrip_symbolsinstrip_symbols section\";\n          }\n          else {\n            *(undefined4 *)(temp_value + 0x7c) = 2;\n            *(undefined4 *)(lVar37 + 0x7c) = 0;\n            cVar7 = bfd_set_section_contents(binary,temp_value,param_30,0,param_38);\n            if ((cVar7 != '\\0') &&\n               (cVar7 = bfd_set_section_contents(binary,lVar37,param_33,0,param_40), cVar7 != '\\0')\n               ) {\n              free(string_buffer_02);\n              strip_symbolsoto LAB_00105cfa;\n            }\n            temp_string_2 = \"can\\'t set debustrip_symbolsstrip_symbolsinstrip_symbols section contents\";\n          }\n          result_2 = dcstrip_symbolsettext(0,temp_string_2,5);\n          bfd_nonfatal_messastrip_symbolse(0,binary,0,result_2);\n          free(param_33);\n          free(string_buffer_02);\n          strip_symbolsoto LAB_00105d96;\n        }\n      }\n      else {\n        result_2 = **(undefined8 **)(binary + 8);\n        result_1 = dcstrip_symbolsettext(0,\"don\\'t know how to write debustrip_symbolsstrip_symbolsinstrip_symbols information for %s\",5);\n        bfd_nonfatal_messastrip_symbolse(0,binary,0,result_1,result_2);\n      }\n      free(string_buffer_02);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections(bfd_data,mark_symbols_used_in_relocations,isympp);\n      iVar10 = bfd_strip_symbolset_error();\n      if (iVar10 == 0) strip_symbolsoto LAB_00105a3b;\n    }\nLAB_00105d96:\n    status = 1;\n  }\n  else {\n    if ((strip_symbols - 3U < 4) || ((discard_locals != 0 || (localize_hidden != '\\0'))))\n    strip_symbolsoto LAB_00105a07;\n    temp_value = htab_elements(strip_specific_htab);\n    if (((temp_value != 0) ||\n        ((((temp_value = htab_elements(keep_specific_htab), temp_value != 0 ||\n           (temp_value = htab_elements(localize_specific_htab), temp_value != 0)) ||\n          (temp_value = htab_elements(strip_symbolslobalize_specific_htab), temp_value != 0)) ||\n         ((temp_value = htab_elements(keepstrip_symbolslobal_specific_htab), temp_value != 0 ||\n          (temp_value = htab_elements(weaken_specific_htab), temp_value != 0)))))) ||\n       ((((temp_value = htab_elements(redefine_specific_htab), temp_value != 0 ||\n          ((prefix_symbols_strinstrip_symbols != (char *)0x0 || (sections_removed != '\\0')))) ||\n         (sections_copied != '\\0')) ||\n        ((((convert_debustrip_symbolsstrip_symbolsinstrip_symbols != '\\0' || (chanstrip_symbolse_leadinstrip_symbols_char != '\\0')) ||\n          (remove_leadinstrip_symbols_char != '\\0')) ||\n         (((section_rename_list != (char **)0x0 || (weaken != '\\0')) || (add_symbols != 0))))))))\n    strip_symbolsoto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(binary,osympp,section_count & 0xffffffff);\n    bfd_map_over_sections(bfd_data,copy_relocations_in_section,binary);\n    bfd_map_over_sections(bfd_data,copy_section,binary);\n    for (puVar26 = add_sections; puVar4 = update_sections, puVar26 != (undefined8 *)0x0;\n        puVar26 = (undefined8 *)*puVar26) {\n      cVar7 = bfd_set_section_contents(binary,puVar26[5],puVar26[4],0,puVar26[3]);\n      if (cVar7 == '\\0') {\n        bfd_nonfatal_messastrip_symbolse(0,binary,puVar26[5],0);\n        return 0;\n      }\n    }\n    for (; puVar4 != (undefined8 *)0x0; puVar4 = (undefined8 *)*puVar4) {\n      result_2 = *(undefined8 *)(puVar4[5] + 0x60);\n      cVar7 = bfd_set_section_contents(binary,result_2,puVar4[4],0,puVar4[3]);\n      if (cVar7 == '\\0') {\n        bfd_nonfatal_messastrip_symbolse(0,binary,result_2,0);\n        return 0;\n      }\n    }\n    if (symbol_list == (lonstrip_symbols *)0x0) {\n      if ((merstrip_symbolse_notes != '\\0') && (is_strip == 0)) {\n        result_2 = *bfd_data;\n        result_1 = dcstrip_symbolsettext(0,\"%s: Could not find any merstrip_symbolseable note sections\",5);\n        non_fatal(result_1,result_2);\n      }\n    }\n    else {\n      ptr_3 = (lonstrip_symbols *)0x0;\n      for (puVar26 = *(undefined8 **)(binary + 0x90); puVar26 != (undefined8 *)0x0;\n          puVar26 = (undefined8 *)puVar26[1]) {\n        if (((merstrip_symbolse_notes != '\\0') && (*(int *)(*(lonstrip_symbols *)(binary + 8) + 8) == 5)) &&\n           ((*(int *)(puVar26[0x1a] + 4) == 7 &&\n            (cVar7 = startswith_lto_priv_0_lto_priv_0(*puVar26,\".strip_symbolsnu.build.attributes\"),\n            cVar7 != '\\0')))) {\n          if (ptr_3 == (lonstrip_symbols *)0x0) {\n            ptr_3 = symbol_list;\n          }\n          plVar15 = symbol_list;\n          if (*(undefined8 **)(*ptr_3 + 0x60) == puVar26) {\nLAB_0010625f:\n            temp_string_2 = \"error: failed to merstrip_symbolse notes\";\n            if (ptr_3[1] != 0) {\n              cVar7 = bfd_set_section_contents(binary,puVar26,ptr_3[1],0,ptr_3[2]);\n              if (cVar7 == '\\0') {\n                result_2 = dcstrip_symbolsettext(0,\"error: failed to copy merstrip_symbolsed notes into output\",5);\n                bfd_nonfatal_messastrip_symbolse(0,binary,puVar26,result_2);\n                return 0;\n              }\n              ptr_3 = (lonstrip_symbols *)ptr_3[3];\n              strip_symbolsoto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              ptr_3 = plVar15;\n              if (*(undefined8 **)(*plVar15 + 0x60) == puVar26) strip_symbolsoto LAB_0010625f;\n              ptr_3 = (lonstrip_symbols *)plVar15[3];\n              plVar15 = ptr_3;\n            } while (ptr_3 != (lonstrip_symbols *)0x0);\n            temp_string_2 = \"error: failed to locate merstrip_symbolsed notes\";\n          }\n          result_2 = dcstrip_symbolsettext(0,temp_string_2,5);\n          bfd_nonfatal_messastrip_symbolse(0,binary,puVar26,result_2);\n        }\nLAB_001061be:\n      }\n      do {\n        ptr_3 = (lonstrip_symbols *)symbol_list[3];\n        free((void *)symbol_list[1]);\n        free(symbol_list);\n        symbol_list = ptr_3;\n      } while (ptr_3 != (lonstrip_symbols *)0x0);\n    }\n    if ((strip_symbolsnu_debustrip_symbolslink_filename == 0) ||\n       (cVar7 = bfd_fill_in_strip_symbolsnu_debustrip_symbolslink_section(binary,param_21), temp_value = strip_symbolsnu_debustrip_symbolslink_filename\n       , cVar7 != '\\0')) {\n      if (gap_fill_buffer != (undefined *)0x0) {\n        if (0x2000 < gap_fill_size) {\n          gap_fill_size = 0x2000;\n        }\n        temp_value = 0;\n        string_buffer = (undefined *)xmalloc(gap_fill_size);\n        uVar5 = strip_symbolsap_fill;\n        ptr_1 = string_buffer;\n        for (gap_fill_size = gap_fill_size & 0xffffffff; gap_fill_size != 0; gap_fill_size = gap_fill_size - 1) {\n          *ptr_1 = uVar5;\n          ptr_1 = ptr_1 + (ulonstrip_symbols)temp_flag * -2 + 1;\n        }\n        for (; (uint)temp_value < in_stack_00000068._4_4_; temp_value = temp_value + 1) {\n          updated_value = *(ulonstrip_symbols *)(gap_fill_buffer + temp_value * 8);\n          if (updated_value != 0) {\n            lVar37 = *(lonstrip_symbols *)(*param_17 + 0x40) - updated_value;\n            do {\n              temp_value_2 = 0x2000;\n              if (updated_value < 0x2001) {\n                temp_value_2 = updated_value;\n              }\n              cVar7 = bfd_set_section_contents(binary,*param_17,string_buffer,lVar37,temp_value_2);\n              if (cVar7 == '\\0') {\n                bfd_nonfatal_messastrip_symbolse(0,binary,*param_17,0);\n                free(string_buffer);\n                return 0;\n              }\n              lVar37 = lVar37 + temp_value_2;\n              updated_value = updated_value - temp_value_2;\n            } while (updated_value != 0);\n          }\n          param_17 = param_17 + 1;\n        }\n        free(string_buffer);\n        free(gap_fill_buffer);\n      }\n      uVar9 = (**(code **)(*(lonstrip_symbols *)(binary + 8) + 0x140))(bfd_data);\n      if ((char)uVar9 != '\\0') {\n        if (use_alt_mach_code == 0) {\n          return uVar9;\n        }\n        cVar7 = bfd_alt_mach_code(binary,use_alt_mach_code & 0xffffffff);\n        updated_value = use_alt_mach_code;\n        if (cVar7 == '\\0') {\n          result_2 = dcstrip_symbolsettext(0,\"this tarstrip_symbolset does not support %lu alternative machine codes\",5);\n          non_fatal(result_2,updated_value);\n          if (*(int *)(*(lonstrip_symbols *)(binary + 8) + 8) == 5) {\n            result_2 = dcstrip_symbolsettext(0,\"treatinstrip_symbols that number as an absolute e_machine value instead\",5);\n            non_fatal(result_2);\n            *(short *)(*(lonstrip_symbols *)(binary + 0x110) + 0x3a) = (short)use_alt_mach_code;\n            return uVar9;\n          }\n          result_2 = dcstrip_symbolsettext(0,\"istrip_symbolsnorinstrip_symbols the alternative value\",5);\n          non_fatal(result_2);\n          return uVar9;\n        }\n        return uVar9;\n      }\n      result_2 = dcstrip_symbolsettext(0,\"error copyinstrip_symbols private BFD data\",5);\n      bfd_nonfatal_messastrip_symbolse(0,binary,0,result_2);\n    }\n    else {\n      result_2 = dcstrip_symbolsettext(0,\"cannot fill debustrip_symbols link section `%s\\'\",5);\n      bfd_nonfatal_messastrip_symbolse(0,binary,0,result_2,temp_value);\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "bfd_get_section_by_name",
                "is_strip_section.isra.0",
                "is_specified_symbol",
                "finish_stab",
                "bfd_is_local_label",
                "fatal",
                "bfd_map_over_sections",
                "strlen",
                "concat",
                "dcgettext",
                "bfd_set_section_size",
                "create_new_symbol",
                "copy_relocations_in_section",
                "bfd_nonfatal_message",
                "bfd_set_symtab",
                "htab_find",
                "debug_end_block",
                "copy_section",
                "bfd_coff_get_syment",
                "strcmp",
                "debug_record_function",
                "non_fatal",
                "htab_traverse",
                "free",
                "bfd_map_over_sections",
                "debug_end_function",
                "fprintf",
                "debug_start_block",
                "free_saved_stabs",
                "strcpy",
                "parse_stab",
                "bfd_alt_mach_code",
                "bfd_decode_symclass",
                "debug_set_filename",
                "bfd_make_section_with_flags",
                "bfd_set_error",
                "bfd_errmsg",
                "debug_record_line",
                "save_stab",
                "startswith.lto_priv.0.lto_priv.0",
                "htab_elements",
                "bfd_fill_in_gnu_debuglink_section",
                "qsort",
                "mark_symbols_used_in_relocations",
                "write_stabs_in_sections_debugging_info.constprop.0",
                "bfd_coff_get_auxent",
                "start_stab.constprop.0",
                "bfd_octets_per_byte",
                "get_sections",
                "bfd_set_section_contents",
                "bfd_get_error",
                "xstrdup",
                "parse_coff_type.lto_priv.0",
                "stab_context",
                "compare_section_lma",
                "bfd_get_section_contents",
                "parse_coff_symbol.constprop.0.isra.0",
                "is_specified_symbol_predicate",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010554f",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "improve_and_reverse_0010554f"
        },
        "FUN_00104230": {
            "renaming": {},
            "code": "\n\n\nint rmdir(char *__path)\n\n{\n  int iVar1;\n  \n  iVar1 = rmdir(__path);\n  return iVar1;\n}\n\n",
            "called": [
                "rmdir"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104230",
            "calling": [
                "FUN_00114b84",
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "FUN_00104230"
        },
        "FUN_00104110": {
            "renaming": {},
            "code": "\nvoid bfd_get_stab_name(void)\n\n{\n  bfd_get_stab_name();\n  return;\n}\n\n",
            "called": [
                "bfd_get_stab_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104110",
            "calling": [
                "stab_context"
            ],
            "imported": false,
            "current_name": "FUN_00104110"
        },
        "FUN_00128440": {
            "renaming": {},
            "code": "\n\n\n\nint sprintf(char *__s,char *__format,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* sprintf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128440",
            "calling": [
                "sprintf"
            ],
            "imported": false,
            "current_name": "FUN_00128440"
        },
        "FUN_00104470": {
            "renaming": {},
            "code": "\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = strcmp(__s1,__s2);\n  return iVar1;\n}\n\n",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104470",
            "calling": [
                "debug_type_samep",
                "stab_demangle_v3_arg",
                "display_info.isra.0.cold",
                "FUN_0010554f",
                "stab_find_tagged_type",
                "find_section_list",
                "debug_set_class_id.lto_priv.0",
                "eq_string_redefnode",
                "main",
                "parse_stab",
                "setup_section",
                "is_strip_section_1.isra.0",
                "parse_stab_type",
                "stab_demangle_qualified",
                "debug_tag_type",
                "convert_efi_target",
                "debug_find_named_type",
                "skip_section"
            ],
            "imported": false,
            "current_name": "FUN_00104470"
        },
        "FUN_00109cf4": {
            "renaming": {
                "FUN_00109cf4": "convert_and_push_to_string_00109cf4",
                "param_1": "outputBuffer",
                "param_2": "inputValue",
                "param_3": "formatSpecifier",
                "local_3c": "buffer"
            },
            "code": "\nvoid convertAndPushToString_00109cf4(undefined8 outputBuffer,undefined8 inputValue,undefined4 formatSpecifier)\n\n{\n  char buffer [28];\n  \n  sprintf(buffer,\"%ld\",inputValue);\n  stab_push_string(outputBuffer,buffer,inputValue,0,formatSpecifier);\n  return;\n}\n\n",
            "called": [
                "stab_push_string",
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109cf4",
            "calling": [
                "stab_void_type.lto_priv.0",
                "stab_typedef_type.lto_priv.0",
                "stab_enum_type.lto_priv.0",
                "stab_tag_type.lto_priv.0",
                "stab_bool_type.lto_priv.0",
                "stab_modify_type",
                "stab_empty_type.lto_priv.0",
                "stab_float_type.lto_priv.0",
                "stab_int_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "convert_and_push_to_string_00109cf4"
        },
        "FUN_00128320": {
            "renaming": {},
            "code": "\n\n\n\nint strncasecmp(char *__s1,char *__s2,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strncasecmp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128320",
            "calling": [
                "strncasecmp"
            ],
            "imported": false,
            "current_name": "FUN_00128320"
        },
        "FUN_00104350": {
            "renaming": {},
            "code": "\nvoid bfd_target_list(void)\n\n{\n  bfd_target_list();\n  return;\n}\n\n",
            "called": [
                "bfd_target_list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104350",
            "calling": [
                "list_supported_targets"
            ],
            "imported": false,
            "current_name": "FUN_00104350"
        },
        "FUN_00109ab1": {
            "renaming": {
                "FUN_00109ab1": "parse_and_extract_numbers_00109ab1",
                "param_1": "data_pointer",
                "param_2": "output_values",
                "param_3": "param3_value",
                "param_4": "param4_value",
                "param_5": "param5_value",
                "uVar1": "parsed_number",
                "pcVar2": "current_char",
                "uVar3": "result",
                "auVar4": "return_value"
            },
            "code": "\nundefined  [16]\nparse_and_extract_numbers_00109ab1(char **data_pointer,undefined4 *output_values,undefined8 param3_value,undefined8 param4_value,\n            undefined8 param5_value)\n\n{\n  undefined4 parsed_number;\n  char *current_char;\n  undefined8 result;\n  undefined return_value [16];\n  \n  current_char = *data_pointer;\n  if (*current_char == '(') {\n    *data_pointer = current_char + 1;\n    parsed_number = parse_number(data_pointer,0);\n    *output_values = parsed_number;\n    if (**data_pointer == ',') {\n      *data_pointer = *data_pointer + 1;\n      parsed_number = parse_number(data_pointer,0,param3_value);\n      output_values[1] = parsed_number;\n      if (**data_pointer == ')') {\n        current_char = *data_pointer + 1;\n        *data_pointer = current_char;\n        goto LAB_00109b25;\n      }\n    }\n    bad_stab(current_char);\n    result = 0;\n  }\n  else {\n    *output_values = 0;\n    current_char = (char *)parse_number(data_pointer,0);\n    output_values[1] = (int)current_char;\nLAB_00109b25:\n    result = CONCAT71((int7)((ulong)current_char >> 8),1);\n  }\n  return_value._8_8_ = param5_value;\n  return_value._0_8_ = result;\n  return return_value;\n}\n\n",
            "called": [
                "parse_number",
                "bad_stab"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109ab1",
            "calling": [
                "parse_stab_type"
            ],
            "imported": false,
            "current_name": "parse_and_extract_numbers_00109ab1"
        },
        "FUN_00128200": {
            "renaming": {},
            "code": "\n\n\n\nint close(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* close@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128200",
            "calling": [
                "close"
            ],
            "imported": false,
            "current_name": "FUN_00128200"
        },
        "FUN_001159d0": {
            "renaming": {
                "FUN_001159d0": "check_strip_section_001159d0",
                "param_1": "input_address",
                "uVar1": "result",
                "cVar2": "is_symbol_specified",
                "uVar3": "section_strip_result",
                "lVar4": "group_signature",
                "lVar5": "current_address"
            },
            "code": "\nundefined4 check_strip_section_001159d0(long input_address)\n\n{\n  undefined8 result;\n  char is_symbol_specified;\n  undefined4 section_strip_result;\n  long group_signature;\n  long current_address;\n  \n  section_strip_result = is_strip_section_1_isra_0();\n  if ((char)section_strip_result == '\\0') {\n    if ((*(byte *)(input_address + 0x27) & 2) == 0) {\n      return section_strip_result;\n    }\n    group_signature = group_signature_isra_0(*(undefined8 *)(input_address + 0xd0),*(undefined8 *)(input_address + 0xe0));\n    if ((group_signature != 0) &&\n       (((result = *(undefined8 *)(group_signature + 8), strip_symbols != 7 ||\n         (is_symbol_specified = is_specified_symbol(result,keep_specific_htab), is_symbol_specified != '\\0')) &&\n        (is_symbol_specified = is_specified_symbol(result,strip_specific_htab), is_symbol_specified == '\\0')))) {\n      group_signature = *(long *)(*(long *)(input_address + 0xd0) + 0xc0);\n      current_address = group_signature;\n      do {\n        if (current_address == 0) {\n          return 1;\n        }\n        is_symbol_specified = is_strip_section_1_isra_0(current_address);\n        if (is_symbol_specified == '\\0') {\n          return section_strip_result;\n        }\n        current_address = *(long *)(*(long *)(current_address + 0xd0) + 0xc0);\n      } while (group_signature != current_address);\n    }\n  }\n  return 1;\n}\n\n",
            "called": [
                "is_strip_section_1.isra.0",
                "is_specified_symbol",
                "group_signature.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001159d0",
            "calling": [
                "setup_section",
                "FUN_0010554f",
                "skip_section"
            ],
            "imported": false,
            "current_name": "check_strip_section_001159d0"
        },
        "FUN_0010a77a": {
            "renaming": {
                "FUN_0010a77a": "merge_strings_0010a77a",
                "param_1": "source",
                "uVar1": "symbol",
                "lVar2": "data",
                "__s": "dest",
                "uVar3": "address",
                "uVar4": "result",
                "__s_00": "source_str",
                "sVar5": "source_len",
                "sVar6": "dest_len",
                "__s_01": "merged_str"
            },
            "code": "\nundefined4 mergeStrings_0010a77a(long source)\n\n{\n  undefined symbol;\n  long data;\n  char *dest;\n  undefined8 address;\n  undefined4 result;\n  char *source_str;\n  size_t source_len;\n  size_t dest_len;\n  char *merged_str;\n  \n  data = *(long *)(source + 0x60);\n  if ((data != 0) && (dest = *(char **)(data + 0x20), dest != (char *)0x0)) {\n    result = *(undefined4 *)(data + 0x18);\n    symbol = *(undefined *)(data + 0x1c);\n    address = *(undefined8 *)(data + 0x10);\n    source_str = (char *)stab_pop_type();\n    source_len = strlen(source_str);\n    dest_len = strlen(dest);\n    merged_str = (char *)xmalloc(source_len + 2 + dest_len);\n    sprintf(merged_str,\"%s%s;\",source_str,dest);\n    free(source_str);\n    free(dest);\n    result = stab_push_string(source,merged_str,address,symbol,result);\n    if ((char)result != '\\0') {\n      free(merged_str);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "strlen",
                "stab_push_string",
                "sprintf",
                "free",
                "stab_pop_type",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a77a",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "merge_strings_0010a77a"
        },
        "FUN_0010543c": {
            "renaming": {
                "FUN_0010543c": "open_file_with_error_handling_0010543c",
                "uVar1": "fileHandle",
                "piVar2": "errnoLocation",
                "pcVar3": "errorMsg",
                "uVar4": "errorText",
                "unaff_RBP": "stackPointer"
            },
            "code": "\nvoid openFileWithErrorHandling_0010543c(void)\n\n{\n  undefined8 fileHandle;\n  int *errnoLocation;\n  char *errorMsg;\n  undefined8 errorText;\n  long stackPointer;\n  \n  errnoLocation = __errno_location();\n  errorMsg = strerror(*errnoLocation);\n  fileHandle = *(undefined8 *)(stackPointer + 0x10);\n  errorText = dcgettext(0,\"cannot open: %s: %s\",5);\n                    \n  fatal(errorText,fileHandle,errorMsg);\n}\n\n",
            "called": [
                "strerror",
                "dcgettext",
                "__errno_location",
                "fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010543c",
            "calling": [
                "section_add_load_file"
            ],
            "imported": false,
            "current_name": "open_file_with_error_handling_0010543c"
        },
        "FUN_0010a424": {
            "renaming": {
                "FUN_0010a424": "decompiled_function_0010a424",
                "param_1": "param_1_value",
                "param_2": "param_2_char",
                "param_3": "param_3_int",
                "param_4": "param_4_char",
                "cVar1": "empty_type_flag",
                "bVar2": "byte_flag",
                "iVar3": "temp_int",
                "uVar4": "return_value",
                "pcVar5": "temp_char_ptr",
                "__ptr": "dynamic_array",
                "uVar6": "temp_value",
                "__s": "temp_string",
                "sVar7": "size_var1",
                "sVar8": "size_var2",
                "__s_00": "final_string",
                "lVar9": "temp_long1",
                "bVar10": "temp_byte",
                "lVar11": "temp_long2",
                "uVar12": "temp_unknown"
            },
            "code": "\nundefined4 decompiled_function_0010a424(long param_1_value,char param_2_char,int param_3_int,char param_4_char)\n\n{\n  char empty_type_flag;\n  byte byte_flag;\n  int temp_int;\n  undefined4 return_value;\n  char *temp_char_ptr;\n  undefined8 *dynamic_array;\n  undefined8 temp_value;\n  char *temp_string;\n  size_t size_var1;\n  size_t size_var2;\n  char *final_string;\n  long temp_long1;\n  byte temp_byte;\n  long temp_long2;\n  undefined temp_unknown;\n  \n  if ((param_2_char == '\\0') && (empty_type_flag = stab_empty_type_lto_priv_0(), empty_type_flag == '\\0')) {\n    return 0;\n  }\n  temp_byte = *(byte *)(*(long *)(param_1_value + 0x60) + 0x1c);\n  temp_char_ptr = (char *)stab_pop_type(param_1_value);\n  if (param_3_int < 0) {\n    dynamic_array = (undefined8 *)0x0;\n    param_3_int = 0;\nLAB_0010a582:\n    temp_unknown = 1;\n    if (temp_byte != 0) goto LAB_0010a596;\n  }\n  else {\n    if (param_3_int != 0) {\n      temp_int = param_3_int + 1;\n      dynamic_array = (undefined8 *)xmalloc((long)temp_int * 8);\n      temp_long1 = (long)(param_3_int + -1);\n      do {\n        byte_flag = 1;\n        if (temp_byte == 0) {\n          byte_flag = *(byte *)(*(long *)(param_1_value + 0x60) + 0x1c);\n        }\n        temp_value = stab_pop_type(param_1_value);\n        temp_byte = byte_flag & 1;\n        dynamic_array[temp_long1] = temp_value;\n        temp_long1 = temp_long1 + -1;\n      } while ((int)temp_long1 != -1);\n      if (param_4_char == '\\0') {\n        empty_type_flag = stab_empty_type_lto_priv_0(param_1_value);\n        if (empty_type_flag == '\\0') {\n          return 0;\n        }\n        byte_flag = 1;\n        if (temp_byte == 0) {\n          byte_flag = *(byte *)(*(long *)(param_1_value + 0x60) + 0x1c);\n        }\n        temp_byte = byte_flag & 1;\n        temp_value = stab_pop_type(param_1_value);\n        dynamic_array[(long)temp_int + -1] = temp_value;\n        param_3_int = temp_int;\n      }\n      goto LAB_0010a582;\n    }\n    dynamic_array = (undefined8 *)0x0;\n    if (param_4_char != '\\0') goto LAB_0010a582;\n    dynamic_array = (undefined8 *)xmalloc(8);\n    empty_type_flag = stab_empty_type_lto_priv_0(param_1_value);\n    if (empty_type_flag == '\\0') {\n      return 0;\n    }\n    if ((temp_byte != 0) || (*(char *)(*(long *)(param_1_value + 0x60) + 0x1c) != '\\0')) {\n      temp_value = stab_pop_type(param_1_value);\n      param_3_int = 1;\n      temp_unknown = 1;\n      *dynamic_array = temp_value;\n      goto LAB_0010a596;\n    }\n    temp_value = stab_pop_type(param_1_value);\n    param_3_int = 1;\n    *dynamic_array = temp_value;\n  }\n  temp_unknown = *(undefined *)(*(long *)(param_1_value + 0x60) + 0x1c);\nLAB_0010a596:\n  temp_string = (char *)stab_pop_type(param_1_value);\n  size_var1 = strlen(temp_char_ptr);\n  size_var2 = strlen(temp_string);\n  temp_long1 = size_var1 + 10 + size_var2;\n  for (temp_long2 = 0; (int)temp_long2 < param_3_int; temp_long2 = temp_long2 + 1) {\n    size_var1 = strlen((char *)dynamic_array[temp_long2]);\n    temp_long1 = temp_long1 + size_var1;\n  }\n  final_string = (char *)xmalloc(temp_long1);\n  sprintf(final_string,\"#%s,%s\",temp_char_ptr,temp_string);\n  temp_long1 = 0;\n  free(temp_char_ptr);\n  free(temp_string);\n  while( true ) {\n    size_var1 = strlen(final_string);\n    if (param_3_int <= (int)temp_long1) break;\n    *(undefined2 *)(final_string + size_var1) = 0x2c;\n    temp_char_ptr = (char *)dynamic_array[temp_long1];\n    temp_long1 = temp_long1 + 1;\n    strcpy(final_string + size_var1 + 1,temp_char_ptr);\n    free(temp_char_ptr);\n  }\n  *(undefined2 *)(final_string + size_var1) = 0x3b;\n  free(dynamic_array);\n  return_value = stab_push_string(param_1_value,final_string,0,temp_unknown,0);\n  if ((char)return_value == '\\0') {\n    return 0;\n  }\n  free(final_string);\n  return return_value;\n}\n\n",
            "called": [
                "strcpy",
                "strlen",
                "stab_push_string",
                "sprintf",
                "stab_empty_type.lto_priv.0",
                "free",
                "stab_pop_type",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a424",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "decompiled_function_0010a424"
        },
        "FUN_00119970": {
            "renaming": {
                "FUN_00119970": "print_welcome_message_00119970",
                "param_1": "version",
                "pcVar1": "message"
            },
            "code": "\nvoid printWelcomeMessage_00119970(undefined8 version)\n\n{\n  char *message;\n  \n  printf(\"GNU %s %s\\n\",version,\"(GNU Binutils for Debian) 2.40\");\n  message = (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n  printf(message);\n  message = (char *)dcgettext(0,\n                             \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                             ,5);\n  printf(message);\n                    \n  exit(0);\n}\n\n",
            "called": [
                "printf",
                "dcgettext",
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00119970",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "print_welcome_message_00119970"
        },
        "FUN_00104480": {
            "renaming": {},
            "code": "\n\n\nint putc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = putc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104480",
            "calling": [
                "display_info.isra.0.cold",
                "report"
            ],
            "imported": false,
            "current_name": "FUN_00104480"
        },
        "FUN_00114c80": {
            "renaming": {
                "FUN_00114c80": "parse_param_string_00114c80",
                "param_1": "param_string",
                "param_2": "data_ptr",
                "param_3": "error_message",
                "param_4": "additional_data",
                "pcVar1": "equal_sign_pos",
                "uVar2": "substring",
                "auVar3": "result"
            },
            "code": "\nundefined  [16] parse_param_string_00114c80(char *param_string,undefined8 data_ptr,undefined8 error_message,undefined8 additional_data)\n\n{\n  char *equal_sign_pos;\n  undefined8 substring;\n  undefined result [16];\n  \n  equal_sign_pos = strchr(param_string,0x3d);\n  if (equal_sign_pos != (char *)0x0) {\n    result._0_8_ = (undefined8 *)xmalloc(0x30);\n    substring = xstrndup(param_string,(long)equal_sign_pos - (long)param_string);\n    result._0_8_[2] = equal_sign_pos + 1;\n    result._0_8_[1] = substring;\n    result._0_8_[4] = 0;\n    result._0_8_[3] = 0;\n    *result._0_8_ = data_ptr;\n    result._8_8_ = additional_data;\n    return result;\n  }\n  substring = dcgettext(0,\"bad format for %s\",5);\n                    \n  fatal(substring,error_message);\n}\n\n",
            "called": [
                "strchr",
                "init_section_add.cold",
                "xstrndup",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114c80",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "parse_param_string_00114c80"
        },
        "FUN_0010870e": {
            "renaming": {
                "FUN_0010870e": "update_pointer_0010870e",
                "param_1": "ptr",
                "param_2": "newValue",
                "param_3": "ptrList",
                "puVar1": "ptrValue"
            },
            "code": "\nvoid updatePointer_0010870e(undefined8 ptr,undefined8 newValue,long *ptrList)\n\n{\n  undefined8 *ptrValue;\n  \n  ptrValue = (undefined8 *)*ptrList;\n  *ptrValue = newValue;\n  *ptrList = (long)(ptrValue + 1);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010870e",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "update_pointer_0010870e"
        },
        "FUN_001048a0": {
            "renaming": {},
            "code": "\nvoid bfd_is_local_label(void)\n\n{\n  bfd_is_local_label();\n  return;\n}\n\n",
            "called": [
                "bfd_is_local_label"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048a0",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "FUN_001048a0"
        },
        "FUN_0010dac0": {
            "renaming": {
                "FUN_0010dac0": "parse_coff_type_0010dac0",
                "param_1": "input_param1",
                "param_2": "input_param2",
                "param_3": "input_param3",
                "param_4": "input_param4",
                "param_5": "input_param5",
                "param_6": "input_param6",
                "param_7": "input_param7",
                "param_8": "input_param8",
                "lVar1": "result1",
                "cVar2": "tempVar1",
                "uVar3": "result2",
                "uVar4": "result3",
                "lVar5": "result4",
                "uVar6": "result5",
                "plVar7": "tempVar2",
                "__ptr": "pointer1",
                "__ptr_00": "pointer2",
                "bVar8": "tempVar3",
                "iVar9": "tempVar4",
                "pcVar10": "tempVar5",
                "uVar11": "result6",
                "lVar12": "result7",
                "uVar13": "result8",
                "uVar14": "result9",
                "uVar15": "result10",
                "local_68": "localArray1",
                "local_48": "localVar1",
                "local_47": "localVar2"
            },
            "code": "\nlong parse_coff_type_0010dac0(long input_param1,long *input_param2,long input_param3,undefined8 input_param4,uint input_param5,\n                 long *input_param6,char input_param7,undefined8 input_param8)\n\n{\n  long result1;\n  char tempVar1;\n  undefined4 result2;\n  undefined8 result3;\n  long result4;\n  undefined8 result5;\n  long *tempVar2;\n  void *pointer1;\n  void *pointer2;\n  byte tempVar3;\n  int tempVar4;\n  char *tempVar5;\n  ulong result6;\n  long result7;\n  uint result8;\n  uint result9;\n  undefined8 result10;\n  undefined localArray1 [32];\n  char localVar1;\n  byte localVar2;\n  \n  result4 = *(long *)(input_param1 + 0x110);\n  if ((~*(uint *)(result4 + 0x38) & input_param5) != 0) {\n    result8 = (int)input_param5 >> ((byte)*(undefined4 *)(result4 + 0x44) & 0x1f);\n    result6 = (ulong)(input_param5 & *(uint *)(result4 + 0x40));\n    tempVar3 = (byte)*(undefined4 *)(result4 + 0x3c);\n    result8 = (result8 ^ input_param5) & *(uint *)(result4 + 0x38) ^ result8;\n    if (result6 == 1L << (tempVar3 & 0x3f)) {\n      result3 = parse_coff_type_0010dac0(input_param1,input_param2,input_param3,input_param4,result8,input_param6,input_param7,input_param8);\n      result4 = debug_make_pointer_type_isra_0(result3);\n      return result4;\n    }\n    if (result6 != 2L << (tempVar3 & 0x3f)) {\n      if (result6 != 3L << (tempVar3 & 0x3f)) {\n        result3 = dcgettext(0,\"parse_coff_type_0010dac0: Bad type code 0x%x\",5,*(undefined4 *)(result4 + 0x3c),\n                          result8);\n        non_fatal(result3,input_param5);\n        return 0;\n      }\n      result9 = 0;\n      if (input_param6 != (long *)0x0) {\n        result9 = (uint)*(ushort *)(input_param6 + 2);\n        tempVar2 = input_param6 + 2;\n        for (tempVar4 = 0; (*(short *)tempVar2 != 0 && (tempVar4 != 3)); tempVar4 = tempVar4 + 1) {\n          *(short *)tempVar2 = *(short *)((long)tempVar2 + 2);\n          tempVar2 = (long *)((long)tempVar2 + 2);\n        }\n        *(short *)tempVar2 = 0;\n      }\n      result10 = 0;\n      result3 = input_param8;\n      result5 = parse_coff_type_0010dac0(input_param1,input_param2,input_param3,input_param4,result8,input_param6,0);\n      result4 = *(long *)(input_param3 + 0x28);\n      if (result4 == 0) {\n        result3 = debug_make_int_type_isra_0(4,0,result10,result3);\n        result4 = debug_name_type(input_param8,\"int\",result3);\n        *(long *)(input_param3 + 0x28) = result4;\n      }\n      result4 = debug_make_array_type_isra_0(result5,result4,0,(long)(int)(result9 - 1),0);\n      return result4;\n    }\n    result3 = parse_coff_type_0010dac0(input_param1,input_param2,input_param3,input_param4,result8,input_param6,input_param7,input_param8);\n    result4 = debug_make_function_type_isra_0(result3,0,0);\n    return result4;\n  }\n  if ((input_param6 != (long *)0x0) && (0 < *input_param6)) {\n    tempVar2 = (long *)coff_get_slot_lto_priv_0(input_param3);\n    if (*tempVar2 != 0) {\n      return *tempVar2;\n    }\n    result4 = debug_make_indirect_type_isra_0(tempVar2,0);\n    return result4;\n  }\n  if (input_param7 == '\\0') {\n    input_param6 = (long *)0x0;\n  }\n  if (0x10 < input_param5) {\n    result4 = debug_make_void_type_isra_0();\n    return result4;\n  }\n  result4 = *(long *)(input_param3 + 8 + (long)(int)input_param5 * 8);\n  if (result4 != 0) {\n    return result4;\n  }\n  switch(input_param5) {\n  default:\n    result3 = debug_make_void_type_isra_0();\n    tempVar5 = \"void\";\n    break;\n  case 2:\n    result3 = debug_make_int_type_isra_0(1,0);\n    tempVar5 = \"char\";\n    break;\n  case 3:\n    result3 = debug_make_int_type_isra_0(2,0);\n    tempVar5 = \"short\";\n    break;\n  case 4:\n    result3 = debug_make_int_type_isra_0(4,0);\n    tempVar5 = \"int\";\n    break;\n  case 5:\n    result3 = debug_make_int_type_isra_0(4,0);\n    tempVar5 = \"long\";\n    break;\n  case 6:\n    result3 = debug_make_float_type_isra_0(4);\n    tempVar5 = \"float\";\n    break;\n  case 7:\n    result3 = debug_make_float_type_isra_0(8);\n    tempVar5 = \"double\";\n    break;\n  case 8:\n    if (input_param6 == (long *)0x0) {\n      result4 = debug_make_struct_type_isra_0(1,0,0);\n      goto LAB_0010e046;\n    }\n    result3 = 8;\n    goto LAB_0010de7a;\n  case 9:\n    if (input_param6 == (long *)0x0) {\n      result4 = debug_make_struct_type_isra_0(0,0,0);\n      goto LAB_0010e046;\n    }\n    result3 = 9;\nLAB_0010de7a:\n    result4 = parse_coff_struct_type(input_param1,input_param2,input_param3,result3,input_param6,input_param8);\nLAB_0010e046:\n    tempVar2 = (long *)coff_get_slot_lto_priv_0(input_param3,input_param4);\n    *tempVar2 = result4;\n    return result4;\n  case 10:\n    if (input_param6 == (long *)0x0) {\n      result4 = debug_make_enum_type_isra_0(0,0);\n    }\n    else {\n      result4 = input_param6[3];\n      pointer1 = (void *)xmalloc(0x50);\n      pointer2 = (void *)xmalloc(0x50);\n      result7 = 0;\n      do {\n        while( true ) {\n          if ((result4 <= input_param2[3]) || (input_param2[1] <= input_param2[2])) goto LAB_0010e032;\n          tempVar4 = (int)result7;\n          result1 = *(long *)(*input_param2 + input_param2[2] * 8);\n          tempVar1 = bfd_coff_get_syment(input_param1,result1,localArray1);\n          result7 = (long)tempVar4;\n          if (tempVar1 == '\\0') {\n            result2 = bfd_get_error();\n            result3 = bfd_errmsg(result2);\n            result5 = dcgettext(0,\"bfd_coff_get_syment failed: %s\",5);\n            non_fatal(result5,result3);\n            free(pointer1);\n            free(pointer2);\n            result4 = 0;\n            goto LAB_0010e046;\n          }\n          input_param2[2] = input_param2[2] + 1;\n          input_param2[3] = (ulong)localVar2 + 1 + input_param2[3];\n          if (localVar1 != '\\x10') break;\n          if ((int)input_param5 <= tempVar4 + 1) {\n            input_param5 = input_param5 + 10;\n            pointer1 = (void *)xrealloc(pointer1);\n            pointer2 = (void *)xrealloc(pointer2,(long)(int)input_param5 << 3);\n          }\n          result7 = *(long *)(result1 + 0x20);\n          *(undefined8 *)((long)pointer1 + (long)tempVar4 * 8) = *(undefined8 *)(result1 + 8);\n          *(long *)((long)pointer2 + (long)tempVar4 * 8) =\n               *(long *)(result1 + 0x10) + *(long *)(result7 + 0x30);\n          result7 = (long)(tempVar4 + 1);\n        }\n      } while (localVar1 != 'f');\nLAB_0010e032:\n      *(undefined8 *)((long)pointer1 + result7 * 8) = 0;\n      result4 = debug_make_enum_type_isra_0(pointer1,pointer2);\n    }\n    goto LAB_0010e046;\n  case 0xb:\n    result4 = debug_make_void_type_isra_0();\n    goto LAB_0010e065;\n  case 0xc:\n    result3 = debug_make_int_type_isra_0(1,1);\n    tempVar5 = \"unsigned char\";\n    break;\n  case 0xd:\n    result3 = debug_make_int_type_isra_0(2,1);\n    tempVar5 = \"unsigned short\";\n    break;\n  case 0xe:\n    result3 = debug_make_int_type_isra_0(4,1);\n    tempVar5 = \"unsigned int\";\n    break;\n  case 0xf:\n    result3 = debug_make_int_type_isra_0(4,1);\n    tempVar5 = \"unsigned long\";\n    break;\n  case 0x10:\n    result3 = debug_make_float_type_isra_0(0xc);\n    tempVar5 = \"long double\";\n  }\n  result4 = debug_name_type(input_param8,tempVar5,result3);\nLAB_0010e065:\n  *(long *)(input_param3 + 8 + (long)(int)input_param5 * 8) = result4;\n  return result4;\n}\n\n",
            "called": [
                "bfd_errmsg",
                "non_fatal",
                "parse_coff_struct_type",
                "coff_get_slot.lto_priv.0",
                "free",
                "debug_make_indirect_type.isra.0",
                "bfd_get_error",
                "debug_make_void_type.isra.0",
                "debug_make_int_type.isra.0",
                "parse_coff_type.lto_priv.0",
                "debug_name_type",
                "debug_make_function_type.isra.0",
                "debug_make_array_type.isra.0",
                "dcgettext",
                "debug_make_pointer_type.isra.0",
                "xrealloc",
                "debug_make_struct_type.isra.0",
                "debug_make_float_type.isra.0",
                "xmalloc",
                "bfd_coff_get_syment",
                "debug_make_enum_type.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010dac0",
            "calling": [
                "parse_coff_type.lto_priv.0",
                "FUN_0010554f",
                "parse_coff_struct_type"
            ],
            "imported": false,
            "current_name": "parse_coff_type_0010dac0"
        },
        "FUN_00113fb0": {
            "renaming": {
                "FUN_00113fb0": "string_comparison_00113fb0",
                "param_1": "inputString",
                "param_2": "comparisonString",
                "__n": "comparisonStringLength",
                "iVar1": "comparisonResult",
                "extraout_var": "additionalVar",
                "auVar2": "resultArray"
            },
            "code": "\nundefined  [16] stringComparison_00113fb0(char *inputString,char *comparisonString)\n\n{\n  int comparisonResult;\n  undefined8 in_RAX;\n  size_t comparisonStringLength;\n  undefined4 additionalVar;\n  undefined resultArray [16];\n  \n  comparisonStringLength = strlen(comparisonString);\n  comparisonResult = strncmp(inputString,comparisonString,comparisonStringLength);\n  resultArray._1_7_ = (undefined7)(CONCAT44(additionalVar,comparisonResult) >> 8);\n  resultArray[0] = comparisonResult == 0;\n  resultArray._8_8_ = in_RAX;\n  return resultArray;\n}\n\n",
            "called": [
                "strlen",
                "strncmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113fb0",
            "calling": [
                "main",
                "stab_demangle_function_name.constprop.0",
                "handle_remove_section_option",
                "parse_stab_type",
                "FUN_0010554f",
                "convert_efi_target",
                "FUN_00107880",
                "skip_section",
                "is_dwo_section.constprop.0"
            ],
            "imported": false,
            "current_name": "string_comparison_00113fb0"
        },
        "FUN_0010882c": {
            "renaming": {
                "FUN_0010882c": "display_time_setting_error_0010882c",
                "piVar1": "errorPointer",
                "uVar2": "errorMessage",
                "__errno_location": "getErrorPointer",
                "strerror": "getErrorString",
                "dcgettext": "getLocalizedMessage",
                "non_fatal": "handleNonFatalError"
            },
            "code": "\nvoid displayTimeSettingError_0010882c(void)\n\n{\n  int *errorPointer;\n  undefined8 errorMessage;\n  \n  errorPointer = getErrorPointer();\n  getErrorString(*errorPointer);\n  errorMessage = getLocalizedMessage(0,\"%s: cannot set time: %s\",5);\n  handleNonFatalError(errorMessage);\n  return;\n}\n\n",
            "called": [
                "strerror",
                "dcgettext",
                "non_fatal",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010882c",
            "calling": [
                "set_times"
            ],
            "imported": false,
            "current_name": "display_time_setting_error_0010882c"
        },
        "FUN_0010ebb0": {
            "renaming": {
                "FUN_0010ebb0": "write_symbol_0010ebb0",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "cVar1": "selectedChar",
                "__s": "poppedString",
                "sVar4": "param2Length",
                "sVar5": "poppedStringLength",
                "__s_00": "newString",
                "uVar2": "index",
                "uVar3": "result"
            },
            "code": "\nundefined4 writeSymbol_0010ebb0(undefined8 param1,char *param2,int param3,undefined8 param4)\n\n{\n  char selectedChar;\n  uint index;\n  undefined4 result;\n  char *poppedString;\n  size_t param2Length;\n  size_t poppedStringLength;\n  char *newString;\n  \n  poppedString = (char *)stab_pop_type();\n  index = param3 - 1;\n  if (index < 4) {\n    result = *(undefined4 *)(CSWTCH_42 + (ulong)index * 4);\n    selectedChar = *(char *)((long)&CSWTCH_43 + (ulong)index);\n    param2Length = strlen(param2);\n    poppedStringLength = strlen(poppedString);\n    newString = (char *)xmalloc(param2Length + 3 + poppedStringLength);\n    sprintf(newString,\"%s:%c%s\",param2,(ulong)(uint)(int)selectedChar,poppedString);\n    free(poppedString);\n    result = stab_write_symbol_lto_priv_0(param1,result,0,param4,newString);\n    if ((char)result != '\\0') {\n      free(newString);\n    }\n    return result;\n  }\n                    \n  abort();\n}\n\n",
            "called": [
                "strlen",
                "stab_write_symbol.lto_priv.0",
                "sprintf",
                "abort",
                "free",
                "xmalloc",
                "stab_pop_type"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010ebb0",
            "calling": [
                "debug_write_name.constprop.0"
            ],
            "imported": false,
            "current_name": "write_symbol_0010ebb0"
        },
        "FUN_00116b00": {
            "renaming": {
                "FUN_00116b00": "FUNC_00116b00"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00116b24) */\n/* WARNING: Removing unreachable block (ram,0x00116b30) */\n\nvoid FUNC_00116b00(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_registerTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00116b00",
            "calling": [
                "frame_dummy"
            ],
            "imported": false,
            "current_name": "FUNC_00116b00"
        },
        "FUN_00113b98": {
            "renaming": {
                "FUN_00113b98": "initialize_debug_struct_00113b98",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "lVar1": "debugStruct",
                "plVar2": "debugPointer"
            },
            "code": "\nlong initializeDebugStruct_00113b98(long input1,long input2,long input3,undefined input4)\n\n{\n  long debugStruct;\n  long *debugPointer;\n  \n  if ((input1 != 0) && (debugStruct = debug_make_type_constprop_0(0x13,0), debugStruct != 0)) {\n    debugPointer = (long *)xmalloc(0x20);\n    *(undefined4 *)((long)debugPointer + 0x19) = 0;\n    *debugPointer = input1;\n    *(undefined4 *)((long)debugPointer + 0x1c) = 0;\n    debugPointer[1] = input2;\n    debugPointer[2] = input3;\n    *(undefined *)(debugPointer + 3) = input4;\n    *(long **)(debugStruct + 0x10) = debugPointer;\n    return debugStruct;\n  }\n  return 0;\n}\n\n",
            "called": [
                "debug_make_type.constprop.0",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113b98",
            "calling": [
                "parse_stab_type",
                "stab_demangle_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "initialize_debug_struct_00113b98"
        },
        "FUN_00104120": {
            "renaming": {},
            "code": "\nvoid bfd_make_section_with_flags(void)\n\n{\n  bfd_make_section_with_flags();\n  return;\n}\n\n",
            "called": [
                "bfd_make_section_with_flags"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104120",
            "calling": [
                "FUN_0010554f",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "FUN_00104120"
        },
        "FUN_00115d70": {
            "renaming": {
                "FUN_00115d70": "check_symbol_existence_00115d70",
                "param_1": "symbol",
                "param_2": "symbol_table",
                "lVar1": "symbol_status",
                "local_18": "symbol_to_check",
                "local_10": "symbol_exists"
            },
            "code": "\nundefined check_symbol_existence_00115d70(undefined8 symbol,undefined8 symbol_table)\n\n{\n  long symbol_status;\n  undefined8 symbol_to_check;\n  undefined symbol_exists;\n  \n  if (wildcard == '\\0') {\n    symbol_status = htab_find(symbol_table,symbol);\n    symbol_exists = symbol_status != 0;\n  }\n  else {\n    symbol_exists = 0;\n    symbol_to_check = symbol;\n    htab_traverse(symbol_table,is_specified_symbol_predicate,&symbol_to_check);\n  }\n  return symbol_exists;\n}\n\n",
            "called": [
                "is_specified_symbol_predicate",
                "htab_traverse",
                "htab_find"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115d70",
            "calling": [
                "is_strip_section.isra.0",
                "FUN_0010554f",
                "copy_relocations_in_section.cold"
            ],
            "imported": false,
            "current_name": "check_symbol_existence_00115d70"
        },
        "FUN_00104000": {
            "renaming": {
                "FUN_00104000": "initialize_profiler_00104000",
                "ctx": "context",
                "iVar1": "gmonStartResult"
            },
            "code": "\nint initializeProfiler_00104000(EVP_PKEY_CTX *context)\n\n{\n  int gmonStartResult;\n  \n  gmonStartResult = __gmon_start__();\n  return gmonStartResult;\n}\n\n",
            "called": [
                "__gmon_start__"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104000",
            "calling": [],
            "imported": false,
            "current_name": "initialize_profiler_00104000"
        },
        "FUN_00104360": {
            "renaming": {},
            "code": "\n\n\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memset(__s,__c,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104360",
            "calling": [
                "do_display_target"
            ],
            "imported": false,
            "current_name": "FUN_00104360"
        },
        "FUN_00128430": {
            "renaming": {},
            "code": "\n\n\n\nchar * strcat(char *__dest,char *__src)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcat@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128430",
            "calling": [
                "strcat"
            ],
            "imported": false,
            "current_name": "FUN_00128430"
        },
        "FUN_00104240": {
            "renaming": {},
            "code": "\nvoid dcgettext(void)\n\n{\n  dcgettext();\n  return;\n}\n\n",
            "called": [
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104240",
            "calling": [
                "bfd_nonfatal.cold",
                "merge_gnu_build_notes",
                "add_redefine_and_check",
                "list_matching_formats",
                "coff_get_slot.lto_priv.0",
                "find_section_list",
                "finish_stab",
                "stab_struct_field.lto_priv.0",
                "bad_stab",
                "copy_usage",
                "main",
                "debug_name_type",
                "is_strip_section_1.isra.0.cold",
                "is_strip_section_1.isra.0",
                "stab_write_symbol.lto_priv.0",
                "debug_write_type.constprop.0",
                "get_file_size.cold",
                "copy_relocations_in_section",
                "bfd_nonfatal_message",
                "FUN_00104ea2",
                "display_info.isra.0",
                "debug_end_block",
                "add_specific_symbols",
                "debug_get_real_type.isra.0",
                "debug_record_function",
                "parse_coff_struct_type",
                "endian_string",
                "debug_end_function",
                "copy_section.cold",
                "debug_start_block",
                "copy_object",
                "parse_vma.cold",
                "parse_flags.cold",
                "parse_stab",
                "parse_stab_type",
                "parse_number",
                "print_version",
                "create_new_symbol.cold",
                "FUN_00107880",
                "copy_file",
                "do_display_target",
                "stab_demangle_v3_arg",
                "debug_record_line",
                "list_supported_targets",
                "FUN_0010554f",
                "init_section_add.cold",
                "debug_record_variable",
                "strip_usage",
                "debug_add_to_current_namespace.constprop.0",
                "FUN_00116490",
                "setup_section.cold",
                "smart_rename.cold",
                "stab_typdef.lto_priv.0",
                "FUN_00108179",
                "stab_demangle_v3_arglist",
                "FUN_00104cc1",
                "stab_bad_demangle",
                "setup_section",
                "get_file_size",
                "section_add_load_file.cold",
                "stab_find_slot",
                "FUN_00105828",
                "copy_object.cold",
                "set_times.cold",
                "FUN_0010808f",
                "stab_find_type",
                "FUN_001152b6",
                "stab_int_type.lto_priv.0",
                "parse_coff_type.lto_priv.0",
                "stab_context",
                "FUN_001086af",
                "FUN_00107976",
                "check_new_section_flags.cold",
                "debug_tag_type",
                "debug_start_source",
                "debug_find_named_type",
                "FUN_00114dc7",
                "warn_stab",
                "debug_record_parameter"
            ],
            "imported": false,
            "current_name": "FUN_00104240"
        },
        "FUN_00109be3": {
            "renaming": {
                "FUN_00109be3": "expand_and_store_data_00109be3",
                "param_1": "dataStructure",
                "param_2": "value",
                "param_3": "status",
                "uVar1": "reallocResult",
                "puVar2": "currentElementPtr",
                "uVar3": "currentSize"
            },
            "code": "\nundefined8 expandAndStoreData_00109be3(long dataStructure,undefined8 value,undefined4 status)\n\n{\n  undefined8 reallocResult;\n  undefined8 *currentElementPtr;\n  uint currentSize;\n  \n  if (*(uint *)(dataStructure + 0x2c) <= *(uint *)(dataStructure + 0x28)) {\n    currentSize = *(uint *)(dataStructure + 0x2c) + 10;\n    *(uint *)(dataStructure + 0x2c) = currentSize;\n    reallocResult = xrealloc(*(undefined8 *)(dataStructure + 0x20),(ulong)currentSize << 4);\n    *(undefined8 *)(dataStructure + 0x20) = reallocResult;\n  }\n  currentSize = *(uint *)(dataStructure + 0x28);\n  currentElementPtr = (undefined8 *)((ulong)currentSize * 0x10 + *(long *)(dataStructure + 0x20));\n  *currentElementPtr = value;\n  *(undefined4 *)(currentElementPtr + 1) = status;\n  *(uint *)(dataStructure + 0x28) = currentSize + 1;\n  return CONCAT71((int7)((ulong)currentElementPtr >> 8),1);\n}\n\n",
            "called": [
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109be3",
            "calling": [
                "stab_demangle_arg",
                "parse_stab_type"
            ],
            "imported": false,
            "current_name": "expand_and_store_data_00109be3"
        },
        "FUN_0011a480": {
            "renaming": {
                "FUN_0011a480": "copy_string_0011a480",
                "param_1": "inputString",
                "param_2": "maxLength",
                "__n": "stringLength",
                "__dest": "copiedString"
            },
            "code": "\nvoid copyString_0011a480(char *inputString,size_t maxLength)\n\n{\n  size_t stringLength;\n  void *copiedString;\n  \n  stringLength = strnlen(inputString,maxLength);\n  copiedString = (void *)xmalloc(stringLength + 1);\n  *(undefined *)((long)copiedString + stringLength) = 0;\n  memcpy(copiedString,inputString,stringLength);\n  return;\n}\n\n",
            "called": [
                "memcpy",
                "xmalloc",
                "strnlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a480",
            "calling": [
                "main",
                "init_section_add"
            ],
            "imported": false,
            "current_name": "copy_string_0011a480"
        },
        "FUN_0010e918": {
            "renaming": {
                "FUN_0010e918": "write_symbol_with_params_0010e918",
                "param_1": "input",
                "param_2": "message",
                "param_3": "count",
                "__s": "symbol",
                "sVar2": "messageLength",
                "sVar3": "symbolLength",
                "__s_00": "combinedString",
                "uVar1": "result"
            },
            "code": "\nundefined4 writeSymbolWithParams_0010e918(undefined8 input,char *message,undefined8 count)\n\n{\n  undefined4 result;\n  char *symbol;\n  size_t messageLength;\n  size_t symbolLength;\n  char *combinedString;\n  \n  symbol = (char *)stab_pop_type();\n  messageLength = strlen(message);\n  symbolLength = strlen(symbol);\n  combinedString = (char *)xmalloc(messageLength + 0x14 + symbolLength);\n  sprintf(combinedString,\"%s:c=e%s,%ld\",message,symbol,count);\n  free(symbol);\n  result = stab_write_symbol_lto_priv_0(input,0x80,0,0,combinedString);\n  if ((char)result != '\\0') {\n    free(combinedString);\n  }\n  return result;\n}\n\n",
            "called": [
                "strlen",
                "stab_write_symbol.lto_priv.0",
                "sprintf",
                "free",
                "stab_pop_type",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e918",
            "calling": [
                "debug_write_name.constprop.0"
            ],
            "imported": false,
            "current_name": "write_symbol_with_params_0010e918"
        },
        "FUN_00128218": {
            "renaming": {},
            "code": "\n\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fputc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128218",
            "calling": [
                "fputc"
            ],
            "imported": false,
            "current_name": "FUN_00128218"
        },
        "FUN_00116110": {
            "renaming": {
                "FUN_00116110": "copy_section_content_00116110",
                "param_1": "inputBFD",
                "param_2": "sectionHeader",
                "param_3": "outputBFD",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "lVar3": "tempVar3",
                "iVar4": "tempVar4",
                "iVar5": "tempVar5",
                "cVar6": "tempVar6",
                "uVar7": "tempVar7",
                "__ptr": "bufferPtr",
                "lVar8": "tempVar8",
                "uVar9": "tempVar9",
                "iVar10": "tempVar10",
                "uVar11": "tempVar11",
                "puVar12": "tempVar12",
                "lVar13": "tempVar13",
                "puVar14": "tempVar14",
                "puVar15": "tempVar15",
                "pvVar16": "tempVar16",
                "uVar17": "tempVar17",
                "uVar18": "tempVar18",
                "uVar19": "tempVar19",
                "bVar20": "tempVar20",
                "local_38": "sectionSize",
                "local_30": "sectionContent",
                "fatal": "reportError",
                "status": "processingStatus",
                "skip_section": "isSectionSkipped",
                "find_section_list": "searchSectionList",
                "xmalloc": "allocateMemory",
                "bfd_set_section_contents": "setSectionContents",
                "bfd_get_full_section_contents": "getFullSectionContents",
                "bfd_convert_section_contents": "convertSectionContents",
                "bfd_set_section_size": "setSectionSize",
                "bfd_nonfatal_message": "reportNonFatalError",
                "reverse_bytes": "reverseByteOrder",
                "copy_width": "copyWidth",
                "copy_byte": "copyByte",
                "interleave": "interleaveFactor",
                "free": "freeMemory",
                "free_memory_and_set_status_00108466": "cleanupAndSetStatus"
            },
            "code": "\nvoid copySectionContent_00116110(undefined8 inputBFD,undefined8 *sectionHeader,undefined8 outputBFD)\n\n{\n  undefined tempVar1;\n  undefined8 tempVar2;\n  long tempVar3;\n  int tempVar4;\n  int tempVar5;\n  char tempVar6;\n  undefined8 tempVar7;\n  undefined8 *bufferPtr;\n  long tempVar8;\n  ulong tempVar9;\n  int tempVar10;\n  ulong tempVar11;\n  undefined *tempVar12;\n  long tempVar13;\n  undefined8 *tempVar14;\n  undefined8 *tempVar15;\n  void *tempVar16;\n  ulong tempVar17;\n  ulong tempVar18;\n  ulong tempVar19;\n  byte tempVar20;\n  ulong sectionSize;\n  void *sectionContent;\n  \n  tempVar20 = 0;\n  tempVar6 = isSectionSkipped(inputBFD,sectionHeader,1);\n  if (tempVar6 != '\\0') {\n    return;\n  }\n  sectionSize = sectionHeader[8];\n  tempVar3 = sectionHeader[0xc];\n  if (((*(byte *)((long)sectionHeader + 0x25) & 1) == 0) || ((*(byte *)(tempVar3 + 0x25) & 1) == 0)) {\n    tempVar13 = searchSectionList(*sectionHeader,0,0x80);\n    if (tempVar13 == 0) {\n      return;\n    }\n    if ((*(byte *)(tempVar13 + 0x29) & 1) == 0) {\n      return;\n    }\n    bufferPtr = (undefined8 *)allocateMemory(sectionSize);\n    tempVar15 = bufferPtr;\n    if (7 < sectionSize) {\n      for (tempVar18 = sectionSize >> 3; tempVar18 != 0; tempVar18 = tempVar18 - 1) {\n        *tempVar15 = 0;\n        tempVar15 = tempVar15 + (ulong)tempVar20 * -2 + 1;\n      }\n    }\n    tempVar14 = tempVar15;\n    if ((sectionSize & 4) != 0) {\n      tempVar14 = (undefined8 *)((long)tempVar15 + (ulong)tempVar20 * -8 + 4);\n      *(undefined4 *)tempVar15 = 0;\n    }\n    tempVar15 = tempVar14;\n    if ((sectionSize & 2) != 0) {\n      tempVar15 = (undefined8 *)((long)tempVar14 + (ulong)tempVar20 * -4 + 2);\n      *(undefined2 *)tempVar14 = 0;\n    }\n    if ((sectionSize & 1) != 0) {\n      *(undefined *)tempVar15 = 0;\n    }\n    tempVar6 = setSectionContents(outputBFD,tempVar3,bufferPtr,0);\n    if (tempVar6 != '\\0') {\n      freeMemory(bufferPtr);\n      return;\n    }\n    processingStatus = 1;\n    reportNonFatalError(0,outputBFD,tempVar3,0);\n    freeMemory(bufferPtr);\n    return;\n  }\n  sectionContent = (void *)0x0;\n  tempVar6 = getFullSectionContents(inputBFD,sectionHeader,&sectionContent);\n  if ((tempVar6 == '\\0') ||\n     (tempVar6 = convertSectionContents(inputBFD,sectionHeader,outputBFD,&sectionContent,&sectionSize),\n     tempVar10 = reverseByteOrder, tempVar6 == '\\0')) {\n    setSectionSize(tempVar3,0);\n    processingStatus = 1;\n    reportNonFatalError(0,inputBFD,sectionHeader,0);\n    freeMemory(sectionContent);\n    return;\n  }\n  tempVar4 = copyWidth;\n  tempVar5 = copyByte;\n  if (reverseByteOrder != 0) {\n    tempVar18 = (ulong)reverseByteOrder;\n    if (sectionSize % tempVar18 != 0) {\n      tempVar2 = *sectionHeader;\n      tempVar7 = dcgettext(0,\n                        \"cannot reverse bytes: length of section %s must be evenly divisible by %d\",\n                        5);\n                    \n      reportError(tempVar7,tempVar2,tempVar10);\n    }\n    tempVar10 = reverseByteOrder / 2;\n    tempVar11 = 0;\n    while (tempVar19 = tempVar11, tempVar4 = copyWidth, tempVar5 = copyByte, tempVar19 < sectionSize) {\n      tempVar11 = tempVar18 + tempVar19;\n      tempVar17 = tempVar11;\n      for (tempVar9 = 0; tempVar9 < (ulong)(long)tempVar10; tempVar9 = tempVar9 + 1) {\n        tempVar17 = tempVar17 - 1;\n        tempVar12 = (undefined *)(tempVar19 + tempVar9 + (long)sectionContent);\n        tempVar1 = *tempVar12;\n        *tempVar12 = *(undefined *)((long)sectionContent + tempVar17);\n        *(undefined *)((long)sectionContent + tempVar17) = tempVar1;\n      }\n    }\n  }\n  copyWidth = tempVar4;\n  copyByte = tempVar5;\n  if (-1 < tempVar5) {\n    tempVar18 = (ulong)interleaveFactor;\n    tempVar10 = (int)((ulong)sectionHeader[7] % tempVar18);\n    tempVar11 = ((long)tempVar5 - (long)tempVar10) + (long)sectionContent;\n    if (tempVar5 < tempVar10) {\n      tempVar11 = tempVar11 + tempVar18;\n    }\n    tempVar13 = (sectionSize + (long)sectionContent) - tempVar11;\n    tempVar16 = sectionContent;\n    for (; tempVar11 < sectionSize + (long)sectionContent; tempVar11 = tempVar11 + tempVar18) {\n      for (tempVar8 = 0; ((int)tempVar8 < tempVar4 && (tempVar8 != tempVar13)); tempVar8 = tempVar8 + 1) {\n        *(undefined *)((long)tempVar16 + tempVar8) = *(undefined *)(tempVar11 + tempVar8);\n      }\n      tempVar16 = (void *)((long)tempVar16 + tempVar8);\n      tempVar13 = tempVar13 - tempVar18;\n    }\n    sectionSize = ((((tempVar18 - 1) + sectionSize) - (long)tempVar5) / tempVar18) * (long)tempVar4;\n    tempVar18 = *(ulong *)(tempVar3 + 0x38) / tempVar18;\n    *(ulong *)(tempVar3 + 0x38) = tempVar18;\n    if (tempVar5 < tempVar10) {\n      *(ulong *)(tempVar3 + 0x38) = tempVar18 + 1;\n      tempVar6 = setSectionContents(outputBFD,tempVar3,sectionContent,0,sectionSize);\n      if (tempVar6 == '\\0') {\n        cleanupAndSetStatus();\n        return;\n      }\n      goto LAB_001161d8;\n    }\n  }\n  tempVar6 = setSectionContents(outputBFD,tempVar3,sectionContent,0,sectionSize);\n  if (tempVar6 == '\\0') {\n    cleanupAndSetStatus();\n    return;\n  }\nLAB_001161d8:\n  freeMemory(sectionContent);\n  return;\n}\n\n",
            "called": [
                "FUN_00108466",
                "bfd_set_section_size",
                "bfd_convert_section_contents",
                "bfd_nonfatal_message",
                "find_section_list",
                "free",
                "bfd_get_full_section_contents",
                "skip_section",
                "xmalloc",
                "bfd_set_section_contents",
                "copy_section.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116110",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "copy_section_content_00116110"
        },
        "FUN_00104490": {
            "renaming": {},
            "code": "\nvoid bfd_decode_symclass(void)\n\n{\n  bfd_decode_symclass();\n  return;\n}\n\n",
            "called": [
                "bfd_decode_symclass"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104490",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "FUN_00104490"
        },
        "FUN_00104370": {
            "renaming": {},
            "code": "\nvoid bfd_get_error(void)\n\n{\n  bfd_get_error();\n  return;\n}\n\n",
            "called": [
                "bfd_get_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104370",
            "calling": [
                "FUN_0010554f",
                "parse_coff_struct_type",
                "mark_symbols_used_in_relocations.cold",
                "stab_typdef.lto_priv.0",
                "main",
                "parse_coff_type.lto_priv.0",
                "stab_write_symbol.lto_priv.0",
                "copy_relocations_in_section",
                "bfd_nonfatal_message",
                "copy_file",
                "bfd_nonfatal",
                "write_stabs_in_sections_debugging_info.constprop.0",
                "do_display_target"
            ],
            "imported": false,
            "current_name": "FUN_00104370"
        },
        "FUN_001048b0": {
            "renaming": {},
            "code": "\n\n\nint getc(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = getc(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048b0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001048b0"
        },
        "FUN_0010871c": {
            "renaming": {
                "FUN_0010871c": "print_error_message_0010871c",
                "uVar1": "errorString",
                "unaff_RBX": "errorCode",
                "unaff_retaddr": "returnAddress",
                "_stdout": "standardOutput",
                "_stderr": "standardError",
                "program_name": "executableName"
            },
            "code": "\n\n\nvoid printErrorMessage_0010871c(void)\n\n{\n  undefined8 errorString;\n  long errorCode;\n  undefined8 returnAddress;\n  \n  errorString = dcgettext(0,\"cause of error unknown\",5);\n  fflush(standardOutput);\n  if (errorCode != 0) {\n    fprintf(standardError,\"%s: %s: %s\\n\",executableName);\n    return;\n  }\n  fprintf(standardError,\"%s: %s\\n\",executableName,errorString,returnAddress);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext",
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010871c",
            "calling": [
                "bfd_nonfatal"
            ],
            "imported": false,
            "current_name": "print_error_message_0010871c"
        },
        "FUN_0010bf20": {
            "renaming": {
                "FUN_0010bf20": "debug_end_block_0010bf20",
                "param_1": "ptr_param_1",
                "param_2": "ptr_param_2",
                "param_3": "ptr_param_3",
                "param_4": "ptr_param_4",
                "lVar1": "local_var_1",
                "uVar2": "result",
                "pcVar3": "error_message",
                "auVar4": "output_variable"
            },
            "code": "\n\n\nundefined  [16] debug_end_block_0010bf20(long ptr_param_1,undefined8 ptr_param_2,undefined8 ptr_param_3,undefined8 ptr_param_4)\n\n{\n  long local_var_1;\n  undefined8 result;\n  char *error_message;\n  undefined output_variable [16];\n  \n  if ((*(long *)(ptr_param_1 + 8) == 0) || (local_var_1 = *(long *)(ptr_param_1 + 0x20), local_var_1 == 0)) {\n    error_message = \"debug_end_block_0010bf20: no current block\";\n  }\n  else {\n    if (*(long *)(local_var_1 + 8) != 0) {\n      *(undefined8 *)(local_var_1 + 0x20) = ptr_param_2;\n      result = CONCAT71((int7)((ulong)local_var_1 >> 8),1);\n      *(long *)(ptr_param_1 + 0x20) = *(long *)(local_var_1 + 8);\n      goto LAB_0010bf84;\n    }\n    error_message = \"debug_end_block_0010bf20: attempt to close top level block\";\n  }\n  result = dcgettext(0,error_message,5);\n  fprintf(_stderr,\"%s\\n\",result);\n  result = 0;\nLAB_0010bf84:\n  output_variable._8_8_ = ptr_param_4;\n  output_variable._0_8_ = result;\n  return output_variable;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bf20",
            "calling": [
                "parse_stab",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "debug_end_block_0010bf20"
        },
        "FUN_00104250": {
            "renaming": {},
            "code": "\nvoid bfd_alloc(void)\n\n{\n  bfd_alloc();\n  return;\n}\n\n",
            "called": [
                "bfd_alloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104250",
            "calling": [
                "copy_relocations_in_section"
            ],
            "imported": false,
            "current_name": "FUN_00104250"
        },
        "FUN_0010c95e": {
            "renaming": {
                "FUN_0010c95e": "decode_mangled_name_0010c95e",
                "param_1": "param_pointer",
                "param_2": "buffer_pointer",
                "param_3": "type_pointer",
                "bVar1": "current_byte",
                "bVar2": "next_byte",
                "pbVar3": "byte_pointer",
                "bVar4": "has_signed_char",
                "bVar5": "has_const",
                "bVar6": "has_volatile",
                "cVar7": "result",
                "uVar8": "count",
                "pbVar9": "next_byte_pointer",
                "lVar10": "type",
                "uVar11": "returnValue",
                "pcVar12": "type_name_1",
                "sVar13": "type_name_length",
                "uVar14": "count_as_ulong",
                "__ptr": "allocated_string",
                "lVar15": "type_result",
                "pcVar19": "type_name_3",
                "local_49": "has_const_local",
                "local_48": "count_as_ulong_local",
                "local_40": "template_arguments"
            },
            "code": "\nundefined8 decodeMangledName_0010c95e(undefined8 *param_pointer,byte **buffer_pointer,long *type_pointer)\n\n{\n  byte current_byte;\n  byte next_byte;\n  byte *byte_pointer;\n  bool has_signed_char;\n  bool has_const;\n  bool has_volatile;\n  char result;\n  uint count;\n  byte *next_byte_pointer;\n  long type;\n  undefined8 returnValue;\n  char *type_name_1;\n  size_t type_name_length;\n  ulong count_as_ulong;\n  void *allocated_string;\n  long type_result;\n  ulong *puVar16;\n  undefined *puVar17;\n  char **ppcVar18;\n  char *type_name_3;\n  byte *pnext_byte0;\n  undefined has_const_local;\n  ulong count_as_ulong_local;\n  char *template_arguments [2];\n  \n  while( true ) {\n    pnext_byte0 = *buffer_pointer;\n    current_byte = *pnext_byte0;\n    if ('T' < (char)current_byte) break;\n    if ((char)current_byte < 'A') goto switchD_0010c9b2_caseD_42;\n    switch(current_byte) {\n    case 0x41:\n      type_result = 0;\n      byte_pointer = pnext_byte0;\n      goto LAB_0010ca26;\n    default:\n      goto switchD_0010c9b2_caseD_42;\n    case 0x43:\n      *buffer_pointer = pnext_byte0 + 1;\n      result = decodeMangledName_0010c95e(param_pointer,buffer_pointer,type_pointer);\n      if (result == '\\0') {\n        return 0;\n      }\n      if (type_pointer == (long *)0x0) {\n        return 1;\n      }\n      type_result = debug_make_const_type_isra_0(*type_pointer);\n      *type_pointer = type_result;\n      return 1;\n    case 0x46:\n      *buffer_pointer = pnext_byte0 + 1;\n      if (type_pointer == (long *)0x0) {\n        puVar16 = (ulong *)0x0;\n        ppcVar18 = (char **)0x0;\n      }\n      else {\n        puVar16 = &count_as_ulong_local;\n        ppcVar18 = template_arguments;\n      }\n      result = stab_demangle_args(param_pointer,buffer_pointer,ppcVar18,puVar16);\n      if (result == '\\0') {\n        return 0;\n      }\n      if (**buffer_pointer == 0x5f) {\n        *buffer_pointer = *buffer_pointer + 1;\n        result = decodeMangledName_0010c95e(param_pointer,buffer_pointer,type_pointer);\n        if (result == '\\0') {\n          return 0;\n        }\n        if (type_pointer == (long *)0x0) {\n          return 1;\n        }\n        type_result = debug_make_function_type_isra_0(*type_pointer,template_arguments[0],count_as_ulong_local & 0xff);\n        *type_pointer = type_result;\n        return 1;\n      }\n      goto switchD_0010cdf9_caseD_60;\n    case 0x47:\n      *buffer_pointer = pnext_byte0 + 1;\n      break;\n    case 0x4d:\n    case 0x4f:\n      has_const_local = 0;\n      template_arguments[0] = (char *)0x0;\n      count_as_ulong_local = 0;\n      *buffer_pointer = pnext_byte0 + 1;\n      if (((&_sch_istable)[(ulong)pnext_byte0[1] * 2] & 4) == 0) {\n        if (pnext_byte0[1] != 0x51) goto switchD_0010cdf9_caseD_60;\n        ppcVar18 = template_arguments;\n        if (type_pointer == (long *)0x0) {\n          ppcVar18 = (char **)0x0;\n        }\n        result = stab_demangle_qualified(param_pointer,buffer_pointer,ppcVar18);\n        if (result == '\\0') {\n          return 0;\n        }\n      }\n      else {\n        count = stab_demangle_count(buffer_pointer);\n        byte_pointer = *buffer_pointer;\n        type_name_length = strlen((char *)byte_pointer);\n        if (type_name_length < count) goto switchD_0010cdf9_caseD_60;\n        *buffer_pointer = byte_pointer + count;\n        if ((type_pointer != (long *)0x0) &&\n           (template_arguments[0] = (char *)stab_find_tagged_type(*param_pointer,param_pointer[1],byte_pointer,count,9),\n           template_arguments[0] == (char *)0x0)) {\n          return 0;\n        }\n      }\n      next_byte = **buffer_pointer;\n      if (current_byte == 0x4d) {\n        if ((next_byte == 0x43) || (next_byte == 0x56)) {\n          *buffer_pointer = *buffer_pointer + 1;\n        }\n        if (**buffer_pointer != 0x46) goto switchD_0010cdf9_caseD_60;\n        *buffer_pointer = *buffer_pointer + 1;\n        if (type_pointer == (long *)0x0) {\n          puVar17 = (undefined *)0x0;\n          puVar16 = (ulong *)0x0;\n        }\n        else {\n          puVar17 = &has_const_local;\n          puVar16 = &count_as_ulong_local;\n        }\n        result = stab_demangle_args(param_pointer,buffer_pointer,puVar16,puVar17);\n        if (result == '\\0') {\n          return 0;\n        }\n      }\n      if (**buffer_pointer == 0x5f) {\n        *buffer_pointer = *buffer_pointer + 1;\n        result = decodeMangledName_0010c95e(param_pointer,buffer_pointer,type_pointer);\n        if (result == '\\0') {\n          return 0;\n        }\n        if (type_pointer == (long *)0x0) {\n          return 1;\n        }\n        if (current_byte != 0x4d) {\n          type_result = debug_make_offset_type_isra_0(template_arguments[0],*type_pointer);\n          *type_pointer = type_result;\n          return 1;\n        }\n        type_result = debug_make_method_type_isra_0(*type_pointer,template_arguments[0],count_as_ulong_local,has_const_local);\n        *type_pointer = type_result;\n        return 1;\n      }\n      goto switchD_0010cdf9_caseD_60;\n    case 0x50:\n      goto switchD_0010c9b2_caseD_50;\n    case 0x51:\n      returnValue = stab_demangle_qualified(param_pointer,buffer_pointer,type_pointer);\n      return returnValue;\n    case 0x52:\n      *buffer_pointer = pnext_byte0 + 1;\n      result = decodeMangledName_0010c95e(param_pointer,buffer_pointer,type_pointer);\n      if (result == '\\0') {\n        return 0;\n      }\n      if (type_pointer == (long *)0x0) {\n        return 1;\n      }\n      type_result = debug_make_reference_type_isra_0(*type_pointer);\n      *type_pointer = type_result;\n      return 1;\n    case 0x54:\n      *buffer_pointer = pnext_byte0 + 1;\n      result = stab_demangle_get_count(buffer_pointer,&count_as_ulong_local);\n      if (result != '\\0') {\n        if ((uint)count_as_ulong_local < *(uint *)(param_pointer + 5)) {\n          template_arguments[0] = *(char **)((count_as_ulong_local & 0xffffffff) * 0x10 + param_pointer[4]);\n          result = decodeMangledName_0010c95e(param_pointer,template_arguments,type_pointer);\n          if (result == '\\0') {\n            return 0;\n          }\n          return 1;\n        }\n      }\n      goto switchD_0010cdf9_caseD_60;\n    }\n  }\n  if (current_byte == 0x70) {\nswitchD_0010c9b2_caseD_50:\n    *buffer_pointer = pnext_byte0 + 1;\n    result = decodeMangledName_0010c95e(param_pointer,buffer_pointer,type_pointer);\n    if (result == '\\0') {\n      return 0;\n    }\n    if (type_pointer == (long *)0x0) {\n      return 1;\n    }\n    type_result = debug_make_pointer_type_isra_0(*type_pointer);\n    *type_pointer = type_result;\n    return 1;\n  }\nswitchD_0010c9b2_caseD_42:\n  has_volatile = false;\n  has_signed_char = false;\n  result = '\\0';\n  has_const = false;\n  do {\n    byte_pointer = *buffer_pointer;\n    current_byte = *byte_pointer;\n    if (current_byte == 0x55) {\n      result = '\\x01';\n      goto LAB_0010cd84;\n    }\n    if ('U' < (char)current_byte) {\n      if (current_byte == 0x56) {\n        has_volatile = true;\n        goto LAB_0010cd84;\n      }\n      if ('x' < (char)current_byte) goto switchD_0010cdf9_caseD_60;\n      if ((char)current_byte < '_') goto LAB_0010cdfb;\n      switch(current_byte) {\n      case 0x5f:\n        goto switchD_0010cdf9_caseD_5f;\n      default:\n        goto switchD_0010cdf9_caseD_60;\n      case 0x62:\n        if (type_pointer == (long *)0x0) {\nLAB_0010d0aa:\n          *buffer_pointer = byte_pointer + 1;\n          return 1;\n        }\n        type_result = debug_find_named_type(*param_pointer,&DAT_00120436);\n        *type_pointer = type_result;\n        if (type_result == 0) {\n          type_result = debug_make_type_constprop_0(6,4);\n          *type_pointer = type_result;\n          *buffer_pointer = *buffer_pointer + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 99:\n        if (type_pointer == (long *)0x0) goto LAB_0010d0aa;\n        type_name_3 = \"unsigned char\";\n        if ((result == '\\0') && (type_name_3 = \"char\", has_signed_char)) {\n          type_name_3 = \"signed char\";\n        }\n        type_result = debug_find_named_type(*param_pointer,type_name_3);\n        *type_pointer = type_result;\n        if (type_result == 0) {\n          type_result = debug_make_int_type_isra_0(1,result);\n          *type_pointer = type_result;\n          *buffer_pointer = *buffer_pointer + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 100:\n        if (type_pointer == (long *)0x0) goto LAB_0010d0aa;\n        type_name_3 = \"double\";\n        goto LAB_0010d046;\n      case 0x66:\n        if (type_pointer == (long *)0x0) goto LAB_0010d0aa;\n        type_result = debug_find_named_type(*param_pointer,\"float\");\n        *type_pointer = type_result;\n        if (type_result == 0) {\n          type_result = debug_make_float_type_isra_0(4);\n          *type_pointer = type_result;\n          *buffer_pointer = *buffer_pointer + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x69:\n        if (type_pointer == (long *)0x0) goto LAB_0010d0aa;\n        type_name_3 = \"unsigned int\";\n        type_name_1 = \"int\";\n        goto LAB_0010ced2;\n      case 0x6c:\n        if (type_pointer == (long *)0x0) goto LAB_0010d0aa;\n        type_name_3 = \"long unsigned int\";\n        type_name_1 = \"long int\";\nLAB_0010ced2:\n        if (result == '\\0') {\n          type_name_3 = type_name_1;\n        }\n        type_result = debug_find_named_type(*param_pointer,type_name_3);\n        *type_pointer = type_result;\n        if (type_result == 0) {\n          type_result = debug_make_int_type_isra_0(4,result);\n          *type_pointer = type_result;\n          *buffer_pointer = *buffer_pointer + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x72:\n        type_name_3 = \"long double\";\n        if (type_pointer == (long *)0x0) goto LAB_0010d0aa;\nLAB_0010d046:\n        type_result = debug_find_named_type(*param_pointer,type_name_3);\n        *type_pointer = type_result;\n        if (type_result == 0) {\n          type_result = debug_make_float_type_isra_0(8);\n          *type_pointer = type_result;\n          *buffer_pointer = *buffer_pointer + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x73:\n        if (type_pointer == (long *)0x0) goto LAB_0010d0aa;\n        type_name_3 = \"short unsigned int\";\n        if (result == '\\0') {\n          type_name_3 = \"short int\";\n        }\n        type_result = debug_find_named_type(*param_pointer,type_name_3);\n        *type_pointer = type_result;\n        if (type_result == 0) {\n          type_result = debug_make_int_type_isra_0(2,result);\n          *type_pointer = type_result;\n          *buffer_pointer = *buffer_pointer + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x74:\n        ppcVar18 = template_arguments;\n        if (type_pointer == (long *)0x0) {\n          ppcVar18 = (char **)0x0;\n        }\n        result = stab_demangle_template(param_pointer,buffer_pointer,ppcVar18);\n        if (result == '\\0') {\n          return 0;\n        }\n        if (type_pointer == (long *)0x0) {\n          return 1;\n        }\n        type_name_length = strlen(template_arguments[0]);\n        type_result = stab_find_tagged_type(*param_pointer,param_pointer[1],template_arguments[0],type_name_length & 0xffffffff,9);\n        *type_pointer = type_result;\n        free(template_arguments[0]);\n        type_result = *type_pointer;\n        goto joined_r0x0010d1d8;\n      case 0x76:\n        if (type_pointer == (long *)0x0) goto LAB_0010d0aa;\n        type_result = debug_find_named_type(*param_pointer,&DAT_00120495);\n        *type_pointer = type_result;\n        if (type_result == 0) {\n          type_result = debug_make_void_type_isra_0();\n          *type_pointer = type_result;\n          *buffer_pointer = *buffer_pointer + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x77:\n        if (type_pointer == (long *)0x0) goto LAB_0010d0aa;\n        type_result = debug_find_named_type(*param_pointer,\"__wchar_t\");\n        *type_pointer = type_result;\n        if (type_result == 0) {\n          type_result = debug_make_int_type_isra_0(2,1);\n          *type_pointer = type_result;\n          *buffer_pointer = *buffer_pointer + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x78:\n        if (type_pointer == (long *)0x0) goto LAB_0010d0aa;\n        type_name_3 = \"long long unsigned int\";\n        if (result == '\\0') {\n          type_name_3 = \"long long int\";\n        }\n        type_result = debug_find_named_type(*param_pointer,type_name_3);\n        *type_pointer = type_result;\n        if (type_result == 0) {\n          type_result = debug_make_int_type_isra_0(8,result);\n          *type_pointer = type_result;\n        }\n      }\n      *buffer_pointer = *buffer_pointer + 1;\n      goto LAB_0010d1de;\n    }\n    if (current_byte == 0x43) {\n      has_const = true;\n      goto LAB_0010cd84;\n    }\n    if (current_byte != 0x53) goto LAB_0010cdc5;\n    has_signed_char = true;\nLAB_0010cd84:\n    *buffer_pointer = byte_pointer + 1;\n  } while( true );\nLAB_0010ca26:\n  next_byte_pointer = byte_pointer + 1;\n  *buffer_pointer = next_byte_pointer;\n  current_byte = *next_byte_pointer;\n  if (current_byte == 0) goto switchD_0010cdf9_caseD_60;\n  if (current_byte == 0x5f) {\n    *buffer_pointer = byte_pointer + 2;\n    result = decodeMangledName_0010c95e(param_pointer,buffer_pointer,type_pointer);\n    if (result == '\\0') {\n      return 0;\n    }\n    if (type_pointer == (long *)0x0) {\n      return 1;\n    }\n    type = debug_find_named_type(*param_pointer,\"int\");\n    if (type == 0) {\n      type = debug_make_int_type_isra_0(4,0);\n    }\n    type_result = debug_make_array_type_isra_0(*type_pointer,type,0,type_result,0);\n    *type_pointer = type_result;\n    return 1;\n  }\n  if (((&_sch_istable)[(ulong)current_byte * 2] & 4) == 0) goto switchD_0010cdf9_caseD_60;\n  type_result = type_result * 10 + (long)((char)current_byte + -0x30);\n  byte_pointer = next_byte_pointer;\n  goto LAB_0010ca26;\nLAB_0010cdc5:\n  if ((char)current_byte < ':') {\n    if ((char)current_byte < '0') {\n      if (current_byte != 0) goto switchD_0010cdf9_caseD_60;\nswitchD_0010cdf9_caseD_5f:\n      stab_bad_demangle(pnext_byte0);\n      if (type_pointer == (long *)0x0) {\n        return 1;\n      }\n      goto LAB_0010d1de;\n    }\n  }\n  else {\nLAB_0010cdfb:\n    if ((current_byte != 0x47) || (*buffer_pointer = byte_pointer + 1, ((&_sch_istable)[(ulong)byte_pointer[1] * 2] & 4) == 0)\n       ) goto switchD_0010cdf9_caseD_60;\n  }\n  pnext_byte0 = *buffer_pointer;\n  count = stab_demangle_count(buffer_pointer);\n  byte_pointer = *buffer_pointer;\n  type_name_length = strlen((char *)byte_pointer);\n  count_as_ulong = (ulong)count;\n  if (count_as_ulong <= type_name_length) {\n    *buffer_pointer = byte_pointer + count_as_ulong;\n    if (type_pointer == (long *)0x0) {\n      return 1;\n    }\n    allocated_string = (void *)savestring(byte_pointer,count_as_ulong);\n    type_result = debug_find_named_type(*param_pointer,allocated_string);\n    *type_pointer = type_result;\n    free(allocated_string);\n    if (*type_pointer == 0) {\n      type_result = stab_find_tagged_type(*param_pointer,param_pointer[1],byte_pointer,(int)*buffer_pointer - (int)byte_pointer,0);\n      *type_pointer = type_result;\njoined_r0x0010d1d8:\n      if (type_result == 0) {\n        return 0;\n      }\n    }\nLAB_0010d1de:\n    if (has_const) {\n      type_result = debug_make_const_type_isra_0(*type_pointer);\n      *type_pointer = type_result;\n    }\n    if (has_volatile) {\n      type_result = debug_make_volatile_type_isra_0(*type_pointer);\n      *type_pointer = type_result;\n    }\n    return 1;\n  }\nswitchD_0010cdf9_caseD_60:\n  stab_bad_demangle(pnext_byte0);\n  return 0;\n}\n\n",
            "called": [
                "stab_demangle_get_count",
                "stab_demangle_count",
                "stab_find_tagged_type",
                "stab_demangle_type.lto_priv.0",
                "free",
                "savestring",
                "debug_make_type.constprop.0",
                "stab_bad_demangle",
                "debug_make_int_type.isra.0",
                "debug_make_void_type.isra.0",
                "strlen",
                "debug_make_function_type.isra.0",
                "debug_make_volatile_type.isra.0",
                "debug_make_array_type.isra.0",
                "stab_demangle_qualified",
                "debug_make_pointer_type.isra.0",
                "debug_make_method_type.isra.0",
                "debug_find_named_type",
                "stab_demangle_args",
                "debug_make_offset_type.isra.0",
                "stab_demangle_template",
                "debug_make_float_type.isra.0",
                "debug_make_reference_type.isra.0",
                "debug_make_const_type.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c95e",
            "calling": [
                "stab_demangle_arg",
                "stab_demangle_function_name.constprop.0",
                "stab_demangle_type.lto_priv.0",
                "stab_demangle_template"
            ],
            "imported": false,
            "current_name": "decode_mangled_name_0010c95e"
        },
        "FUN_00104130": {
            "renaming": {},
            "code": "\n\n\nint ferror(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = ferror(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "ferror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104130",
            "calling": [
                "main",
                "FUN_00114dc7",
                "add_specific_symbols"
            ],
            "imported": false,
            "current_name": "FUN_00104130"
        },
        "FUN_00107880": {
            "renaming": {
                "FUN_00107880": "FUNC_00107880"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong FUNC_00107880(void)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  undefined *puVar3;\n  long *plVar4;\n  code *pcVar5;\n  long *plVar6;\n  ulong uVar7;\n  ulong uVar8;\n  char *__s;\n  char cVar9;\n  char cVar10;\n  uint uVar11;\n  int iVar12;\n  uint uVar13;\n  undefined4 uVar14;\n  int iVar15;\n  long *plVar16;\n  long lVar17;\n  undefined8 uVar18;\n  undefined8 uVar19;\n  size_t sVar20;\n  size_t sVar21;\n  char *pcVar22;\n  void *__ptr;\n  void *__ptr_00;\n  ulong uVar23;\n  long lVar24;\n  ulong uVar25;\n  long in_RAX;\n  int *piVar26;\n  long lVar27;\n  ulong uVar28;\n  FILE *__s_00;\n  long **pplVar29;\n  long **__ptr_01;\n  char *pcVar30;\n  undefined8 *puVar31;\n  ulong uVar32;\n  int iVar33;\n  long **pplVar34;\n  char *pcVar35;\n  undefined4 *puVar36;\n  undefined8 *puVar37;\n  char **ppcVar38;\n  void *pvVar39;\n  undefined8 *unaff_R14;\n  undefined **ppuVar40;\n  bool bVar41;\n  byte bVar42;\n  long param_7;\n  ulong param_8;\n  char param_9;\n  undefined4 *param_10;\n  char *pcStack0000000000000038;\n  uint uStack0000000000000048;\n  int param_11;\n  long param_12;\n  long lStack0000000000000088;\n  char *pcStack0000000000000090;\n  long lStack00000000000000a0;\n  long *in_stack_000000c0;\n  ulong in_stack_000000c8;\n  long in_stack_000000d0;\n  long in_stack_000000d8;\n  void *in_stack_000000e0;\n  long in_stack_000000f0;\n  undefined8 in_stack_000000f8;\n  byte bStack0000000000000100;\n  byte bStack0000000000000101;\n  undefined8 in_stack_00000110;\n  ushort in_stack_00000118;\n  char *param_13;\n  char cStack0000000000000148;\n  char *in_stack_00000150;\n  undefined uStack0000000000000158;\n  short sStack000000000000015a;\n  \n  bVar42 = 0;\n  cVar10 = (**(code **)(*(long *)(param_7 + 8) + 0x2a0))\n                     (param_7,**(undefined4 **)(in_RAX + 0x380),0);\n  if (cVar10 == '\\0') {\n    if ((*(byte *)(unaff_R14 + 9) & 0x40) != 0) {\n      iVar12 = bfd_get_arch();\n      if (iVar12 == 0) {\n        uVar19 = bfd_get_archive_filename();\n        uVar18 = dcgettext(0,\"Unable to recognise the format of the input file `%s\\'\",5);\n        non_fatal(uVar18,uVar19);\n        return 0;\n      }\n      uVar19 = bfd_get_mach();\n      uVar14 = bfd_get_arch();\n      uVar19 = bfd_printable_arch_mach(uVar14,uVar19);\n      uVar18 = dcgettext(0,\"Output file cannot represent architecture `%s\\'\",5);\n      non_fatal(uVar18,uVar19);\n      return 0;\n    }\n    iVar12 = bfd_get_arch();\n    iVar33 = bfd_get_arch(param_7);\n    if (iVar12 != iVar33) {\n      uVar28 = check_file_format_00105828();\n      return uVar28;\n    }\n  }\n  cVar10 = bfd_set_format(param_7,*(byte *)(unaff_R14 + 9) & 7);\n  if (cVar10 == '\\0') {\nLAB_00107a82:\n    bfd_nonfatal_message(0);\n    return 0;\n  }\n  if ((*(int *)(*(undefined8 **)(param_7 + 8) + 1) == 2) &&\n     (cVar10 = startswith_lto_priv_0_lto_priv_0(**(undefined8 **)(param_7 + 8),&DAT_0011b503),\n     cVar10 != '\\0')) {\n    lVar27 = *(long *)(param_7 + 0x110);\n    if ((*(int *)((undefined8 *)unaff_R14[1] + 1) == 2) &&\n       (cVar10 = startswith_lto_priv_0_lto_priv_0(*(undefined8 *)unaff_R14[1],&DAT_0011b503),\n       cVar10 != '\\0')) {\n      lVar17 = unaff_R14[0x22];\n      bVar41 = preserve_dates == '\\0';\n      puVar31 = (undefined8 *)(lVar17 + 200);\n      puVar37 = (undefined8 *)(lVar27 + 200);\n      for (lVar24 = 0x32; lVar24 != 0; lVar24 = lVar24 + -1) {\n        *puVar37 = *puVar31;\n        puVar31 = puVar31 + (ulong)bVar42 * -2 + 1;\n        puVar37 = puVar37 + (ulong)bVar42 * -2 + 1;\n      }\n      if (bVar41) {\n        *(undefined4 *)(lVar27 + 0x2a4) = 0xffffffff;\n      }\n      else {\n        *(int *)(lVar27 + 0x2a4) = (int)*(undefined8 *)(lVar17 + 0xa8);\n      }\n    }\n    uVar28 = pe_file_alignment;\n    if (pe_file_alignment == 0xffffffffffffffff) {\n      pe_file_alignment = 0x200;\n      uVar28 = 0x200;\n    }\n    else {\n      *(int *)(lVar27 + 0x10c) = (int)pe_file_alignment;\n    }\n    if (pe_heap_commit != -1) {\n      *(long *)(lVar27 + 0x148) = pe_heap_commit;\n    }\n    if (pe_heap_reserve != -1) {\n      *(long *)(lVar27 + 0x148) = pe_heap_reserve;\n    }\n    if (pe_image_base != -1) {\n      *(long *)(lVar27 + 0x100) = pe_image_base;\n    }\n    uVar23 = pe_section_alignment;\n    if (pe_section_alignment == 0xffffffffffffffff) {\n      pe_section_alignment = 0x1000;\n      uVar23 = 0x1000;\n    }\n    else {\n      *(int *)(lVar27 + 0x108) = (int)pe_section_alignment;\n    }\n    if (pe_stack_commit != -1) {\n      *(long *)(lVar27 + 0x138) = pe_stack_commit;\n    }\n    if (pe_stack_reserve != -1) {\n      *(long *)(lVar27 + 0x138) = pe_stack_reserve;\n    }\n    if (pe_subsystem != -1) {\n      *(short *)(lVar27 + 300) = pe_subsystem;\n    }\n    if (pe_major_subsystem_version != -1) {\n      *(short *)(lVar27 + 0x118) = pe_major_subsystem_version;\n    }\n    if (pe_minor_subsystem_version != -1) {\n      *(short *)(lVar27 + 0x11a) = pe_minor_subsystem_version;\n    }\n    if (uVar23 < uVar28) {\n      uVar19 = dcgettext(0,\"warning: file alignment (0x%lx) > section alignment (0x%lx)\",5);\n      non_fatal(uVar19,uVar28,uVar23);\n    }\n  }\n  plVar6 = isympp;\n  free(isympp);\n  if (plVar6 == osympp) {\n    isympp = (long *)0x0;\n    osympp = (long *)0x0;\n    lVar27 = (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  else {\n    free(osympp);\n    isympp = (long *)0x0;\n    osympp = (long *)0x0;\n    lVar27 = (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  if (lVar27 < 0) goto LAB_00107a82;\n  osympp = (long *)xmalloc();\n  isympp = osympp;\n  param_8 = (**(code **)(unaff_R14[1] + 0x200))();\n  if ((long)param_8 < 0) goto LAB_00107a82;\n  if (param_8 == 0) {\n    free(isympp);\n    isympp = (long *)0x0;\n    osympp = (long *)0x0;\n  }\n  bfd_map_over_sections();\n  puVar31 = add_sections;\n  if ((extract_symbol == '\\0') &&\n     (cVar10 = (**(code **)(*(long *)(param_7 + 8) + 0x168))(), puVar31 = add_sections,\n     cVar10 == '\\0')) {\n    status = 1;\n    dcgettext(0,\"error in private header data\",5);\n    bfd_nonfatal_message(0);\n    puVar31 = add_sections;\n  }\n  for (; puVar37 = update_sections, puVar31 != (undefined8 *)0x0; puVar31 = (undefined8 *)*puVar31)\n  {\n    uVar11 = 0x128;\n    lVar27 = find_section_list(puVar31[1],0,0x80);\n    if (lVar27 != 0) {\n      uVar11 = check_new_section_flags(*(uint *)(lVar27 + 0x28) | 0x100,param_7,puVar31[1]);\n    }\n    lVar27 = bfd_get_section_by_name(param_7,puVar31[1]);\n    if (lVar27 != 0) {\n      uVar19 = puVar31[1];\n      uVar18 = dcgettext(0,\"can\\'t add section \\'%s\\'\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar18,uVar19);\n      return 0;\n    }\n    lVar27 = bfd_make_section_with_flags(param_7,puVar31[1],uVar11 | 0x100000);\n    puVar31[5] = lVar27;\n    if (lVar27 == 0) {\n      uVar19 = puVar31[1];\n      uVar18 = dcgettext(0,\"can\\'t create section `%s\\'\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar18,uVar19);\n      return 0;\n    }\n    cVar10 = bfd_set_section_size();\n    if (cVar10 == '\\0') {\n      bfd_nonfatal_message(0,param_7,puVar31[5],0);\n      return 0;\n    }\n    lVar27 = find_section_list(puVar31[1],0,0x18);\n    if (lVar27 != 0) {\n      uVar19 = *(undefined8 *)(lVar27 + 0x18);\n      lVar27 = puVar31[5];\n      *(byte *)(lVar27 + 0x28) = *(byte *)(lVar27 + 0x28) | 1;\n      *(undefined8 *)(lVar27 + 0x30) = uVar19;\n      *(undefined8 *)(lVar27 + 0x38) = uVar19;\n    }\n    lVar27 = find_section_list(puVar31[1],0,0x60);\n    if (lVar27 != 0) {\n      lVar17 = puVar31[5];\n      *(undefined8 *)(lVar17 + 0x38) = *(undefined8 *)(lVar27 + 0x20);\n      if (0x3e < *(uint *)(lVar17 + 0x7c)) {\n        bfd_nonfatal_message(0,param_7,lVar17,0);\n        return 0;\n      }\n    }\n  }\n  for (; puVar37 != (undefined8 *)0x0; puVar37 = (undefined8 *)*puVar37) {\n    lVar27 = bfd_get_section_by_name();\n    puVar37[5] = lVar27;\n    if (lVar27 == 0) {\n      uVar19 = puVar37[1];\n      uVar18 = dcgettext(0,\"error: %s not found, can\\'t be updated\",5);\n      non_fatal(uVar18,uVar19);\n      return 0;\n    }\n    uVar19 = *(undefined8 *)(lVar27 + 0x60);\n    cVar10 = bfd_set_section_size(uVar19);\n    if (cVar10 == '\\0') {\n      bfd_nonfatal_message(0,param_7,uVar19,0);\n      return 0;\n    }\n  }\n  puVar31 = dump_sections;\n  if (merge_notes == '\\0') {\n    __ptr_01 = (long **)0x0;\n  }\n  else {\n    pplVar34 = (long **)unaff_R14[0x12];\n    __ptr_01 = pplVar34;\n    if (pplVar34 != (long **)0x0) {\n      __ptr_01 = (long **)0x0;\nLAB_001151ab:\n      if (merge_notes != '\\0') goto LAB_00115187;\n      for (plVar6 = pplVar34[1]; puVar31 = dump_sections, plVar6 != (long *)0x0;\n          plVar6 = (long *)plVar6[1]) {\n      }\n    }\n  }\njoined_r0x001151c7:\n  for (; puVar31 != (undefined8 *)0x0; puVar31 = (undefined8 *)*puVar31) {\n    lVar27 = bfd_get_section_by_name();\n    if (lVar27 == 0) {\n      dcgettext(0,\"can\\'t dump section \\'%s\\' - it does not exist\",5);\n      bfd_nonfatal_message(0);\n    }\n    else if ((*(byte *)(lVar27 + 0x25) & 1) == 0) {\n      dcgettext(0,\"can\\'t dump section - it has no contents\",5);\n      bfd_nonfatal_message(0);\n    }\n    else {\n      sVar20 = *(size_t *)(lVar27 + 0x40);\n      __s_00 = fopen((char *)puVar31[2],\"w\");\n      if (__s_00 == (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        bfd_nonfatal_message(puVar31[2],0,0);\n      }\n      else {\n        cVar10 = bfd_malloc_and_get_section();\n        if (cVar10 == '\\0') {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          bfd_nonfatal_message(0);\n        }\n        else if ((sVar20 != 0) && (sVar21 = fwrite(param_13,1,sVar20,__s_00), sVar21 != sVar20)) {\n          piVar26 = __errno_location();\n          pcVar35 = strerror(*piVar26);\n          uVar19 = puVar31[2];\n          uVar18 = dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          non_fatal(uVar18,uVar19,pcVar35);\n          free(param_13);\n          fclose(__s_00);\n          return 0;\n        }\n        fclose(__s_00);\n        free(param_13);\n      }\n    }\n  }\n  if (gnu_debuglink_filename == 0) {\nLAB_0010790a:\n    param_12 = 0;\n  }\n  else {\n    lVar27 = bfd_get_section_by_name(param_7,\".gnu_debuglink\");\n    if (lVar27 != 0) {\n      uVar19 = dcgettext(0,\"%s: debuglink section already exists\",5);\n      non_fatal(uVar19);\n      gnu_debuglink_filename = 0;\n      goto LAB_0010790a;\n    }\n    param_12 = bfd_create_gnu_debuglink_section(param_7);\n    lVar27 = gnu_debuglink_filename;\n    if (param_12 == 0) {\n      uVar19 = dcgettext(0,\"cannot create debug link section `%s\\'\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar19,lVar27);\n      return 0;\n    }\n    if (*(int *)(*(long *)(param_7 + 8) + 8) == 2) {\n      uVar23 = 0;\n      for (uVar28 = *(ulong *)(param_7 + 0x90); uVar28 != 0; uVar28 = *(ulong *)(uVar28 + 8)) {\n        uVar25 = *(ulong *)(uVar28 + 0x30);\n        uVar32 = uVar23;\n        uVar7 = uVar28;\n        uVar8 = uVar23;\n        if (uVar25 != 0) {\n          while ((uVar32 = uVar7, uVar8 != 0 &&\n                 (uVar32 = uVar28, uVar25 <= *(ulong *)(uVar23 + 0x30)))) {\n            uVar28 = *(ulong *)(uVar28 + 8);\n            if (uVar28 == 0) goto LAB_00107db8;\n            uVar25 = *(ulong *)(uVar28 + 0x30);\n            uVar7 = uVar23;\n            uVar8 = uVar25;\n          }\n        }\n        uVar23 = uVar32;\n      }\nLAB_00107db8:\n      if (uVar23 == 0) {\n        uVar28 = 0x1000;\n      }\n      else {\n        uVar23 = *(long *)(uVar23 + 0x40) + *(long *)(uVar23 + 0x30);\n        uVar28 = 0xffffffffffffffff;\n        if (uVar23 < 0xfffffffffffff001) {\n          uVar28 = uVar23 + 0xfff & 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(param_12 + 0x28) = *(byte *)(param_12 + 0x28) | 1;\n      *(ulong *)(param_12 + 0x30) = uVar28;\n      *(ulong *)(param_12 + 0x38) = uVar28;\n    }\n  }\n  plVar6 = isympp;\n  param_11 = *(int *)(param_7 + 0xa0);\n  if (param_11 != 0) {\n    uVar28 = improve_and_reverse_0010554f();\n    return uVar28;\n  }\n  if (convert_debugging == '\\0') {\nLAB_00105588:\n    param_10 = (undefined4 *)0x0;\n  }\n  else {\n    ppuVar40 = &names_0;\n    param_10 = (undefined4 *)xmalloc(0x60);\n    puVar36 = param_10;\n    for (lVar27 = 0x18; lVar27 != 0; lVar27 = lVar27 + -1) {\n      *puVar36 = 0;\n      puVar36 = puVar36 + (ulong)bVar42 * -2 + 1;\n    }\n    pcStack0000000000000038 = (char *)0x0;\n    do {\n      puVar3 = *ppuVar40;\n      lVar27 = bfd_get_section_by_name();\n      lVar17 = bfd_get_section_by_name();\n      if ((lVar27 != 0) && (lVar17 != 0)) {\n        lVar27 = *(long *)(lVar27 + 0x40);\n        __ptr = (void *)xmalloc(lVar27);\n        cVar10 = bfd_get_section_contents();\n        if (cVar10 == '\\0') {\n          uVar14 = bfd_get_error();\n          bfd_errmsg(uVar14);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n          free(pcStack0000000000000038);\n          free(__ptr);\n        }\n        else {\n          uVar28 = *(ulong *)(lVar17 + 0x40);\n          __ptr_00 = (void *)xmalloc(uVar28 + 1);\n          param_9 = bfd_get_section_contents();\n          if (param_9 == '\\0') {\n            uVar14 = bfd_get_error();\n            bfd_errmsg(uVar14);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n            free(pcStack0000000000000038);\n          }\n          else {\n            *(undefined *)((long)__ptr_00 + uVar28) = 0;\n            if ((pcStack0000000000000038 != (char *)0x0) ||\n               (pcStack0000000000000038 = (char *)start_stab_constprop_0(),\n               pcStack0000000000000038 != (char *)0x0)) {\n              lStack00000000000000a0 = 0;\n              lStack0000000000000088 = 0;\n              for (pvVar39 = __ptr; pvVar39 <= (void *)((long)__ptr + lVar27 + -0xc);\n                  pvVar39 = (void *)((long)pvVar39 + 0xc)) {\n                uVar23 = (**(code **)(unaff_R14[1] + 0x40))(pvVar39);\n                bVar2 = *(byte *)((long)pvVar39 + 4);\n                uVar14 = (**(code **)(unaff_R14[1] + 0x58))((long)pvVar39 + 6);\n                lVar17 = (**(code **)(unaff_R14[1] + 0x40))((long)pvVar39 + 8);\n                if (bVar2 == 0) {\n                  lStack0000000000000088 = lStack00000000000000a0;\n                  lStack00000000000000a0 = lStack00000000000000a0 + lVar17;\n                }\n                else {\n                  uVar25 = (uVar23 & 0xffffffff) + lStack0000000000000088;\n                  if (uVar25 < uVar28) {\n                    pcVar35 = (char *)((long)__ptr_00 + uVar25);\n                    pcStack0000000000000090 = (char *)0x0;\n                    while( true ) {\n                      sVar20 = strlen(pcVar35);\n                      if (((sVar20 == 0) || (pcVar30 = pcVar35 + (sVar20 - 1), *pcVar30 != '\\\\')) ||\n                         ((ulong)((long)__ptr + lVar27) < (long)pvVar39 + 0x10U)) goto LAB_001077fb;\n                      *pcVar30 = '\\0';\n                      pvVar39 = (void *)((long)pvVar39 + 0xc);\n                      iVar12 = (**(code **)(unaff_R14[1] + 0x40))(pvVar39);\n                      uVar23 = (ulong)(uint)(iVar12 + (int)lStack0000000000000088);\n                      if (uVar28 <= uVar23) break;\n                      pcVar35 = (char *)concat(pcVar35,(long)__ptr_00 + uVar23,0);\n                      *pcVar30 = '\\\\';\n                      free(pcStack0000000000000090);\n                      pcStack0000000000000090 = pcVar35;\n                    }\n                    uVar19 = *unaff_R14;\n                    pcVar30 = (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar30,uVar19,puVar3,((long)pvVar39 - (long)__ptr) / 0xc);\nLAB_001077fb:\n                    save_stab((ulong)bVar2,uVar14,lVar17,pcVar35);\n                    cVar10 = parse_stab(param_10,pcStack0000000000000038,bVar2);\n                    if (cVar10 == '\\0') {\n                      stab_context();\n                      free_saved_stabs();\n                      free(pcStack0000000000000090);\n                      free(pcStack0000000000000038);\n                      free(__ptr);\n                      free(__ptr_00);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar19 = *unaff_R14;\n                    pcVar35 = (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar35,uVar19,puVar3,((long)pvVar39 - (long)__ptr) / 0xc,\n                            uVar23 & 0xffffffff,(ulong)bVar2,((long)pvVar39 - (long)__ptr) % 0xc);\n                  }\n                }\n              }\n              free_saved_stabs();\n              free(__ptr);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_00);\n          free(__ptr);\n        }\n        goto LAB_00105981;\n      }\nLAB_001058eb:\n      ppuVar40 = ppuVar40 + 2;\n    } while (ppuVar40 != (undefined **)&DAT_00125c90);\n    if ((pcStack0000000000000038 != (char *)0x0) && (cVar10 = finish_stab(), cVar10 == '\\0')) {\nLAB_00105981:\n      free(param_10);\n      goto LAB_00105588;\n    }\n    if (*(int *)(unaff_R14[1] + 8) == 1) {\n      lVar27 = 0;\n      for (plVar16 = plVar6; plVar16 < plVar6 + param_8; plVar16 = plVar16 + 1) {\n        (**(code **)(unaff_R14[1] + 0x218))();\n        if (cStack0000000000000148 == '-') {\n          if (((lVar27 == 0) && (lVar27 = start_stab_constprop_0(), lVar27 == 0)) ||\n             ((in_stack_00000150 == (char *)0x0 || (*in_stack_00000150 == '\\0'))))\n          goto LAB_00105981;\n          pcVar35 = (char *)0x0;\n          pcVar30 = in_stack_00000150;\n          while (((*pcVar30 != '\\0' && (sVar20 = strlen(pcVar30), pcVar30[sVar20 - 1] == '\\\\')) &&\n                 (plVar16 + 1 < plVar6 + param_8))) {\n            pcVar22 = (char *)xstrdup(pcVar30);\n            sVar20 = strlen(pcVar22);\n            pcVar22[sVar20 - 1] = '\\0';\n            pcVar30 = (char *)concat(pcVar22,*(undefined8 *)(plVar16[1] + 8),0);\n            free(pcVar22);\n            free(pcVar35);\n            plVar16 = plVar16 + 1;\n            pcVar35 = pcVar30;\n          }\n          save_stab(uStack0000000000000158,(int)sStack000000000000015a,param_13,pcVar30);\n          param_9 = parse_stab(param_10,lVar27,uStack0000000000000158);\n          if (param_9 == '\\0') {\n            stab_context();\n            free_saved_stabs();\n            goto LAB_00105981;\n          }\n        }\n      }\n      free_saved_stabs();\n      if ((lVar27 != 0) && (cVar10 = finish_stab(), cVar10 == '\\0')) goto LAB_00105981;\n    }\n    if (param_9 == '\\0') {\n      if ((*(int *)(unaff_R14[1] + 8) == 2) && (param_8 != 0)) {\n        param_13 = (char *)0x0;\n        in_stack_000000c0 = plVar6;\n        in_stack_000000d0 = 0;\n        in_stack_000000d8 = 0;\n        puVar31 = (undefined8 *)&stack0x00000148;\n        for (lVar27 = 0x22; lVar27 != 0; lVar27 = lVar27 + -1) {\n          *(undefined4 *)puVar31 = 0;\n          puVar31 = (undefined8 *)((long)puVar31 + (ulong)bVar42 * -8 + 4);\n        }\n        cVar10 = '\\0';\n        _uStack0000000000000048 = (int *)0x0;\n        pcStack0000000000000038 = (char *)0x0;\n        pcStack0000000000000090 = (char *)0xffffffffffffffff;\n        in_stack_000000c8 = param_8;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((long)param_8 <= in_stack_000000d0) goto LAB_00105590;\n            lVar27 = plVar6[in_stack_000000d0];\n            cVar9 = bfd_coff_get_syment();\n            lVar17 = in_stack_000000d8;\n            if (cVar9 == '\\0') {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar35 = \"bfd_coff_get_syment failed: %s\";\n              goto LAB_00105968;\n            }\n            pcVar35 = *(char **)(lVar27 + 8);\n            in_stack_000000d0 = in_stack_000000d0 + 1;\n            in_stack_000000d8 = (ulong)bStack0000000000000101 + 1 + in_stack_000000d8;\n            if ((bStack0000000000000101 != 0) && (cVar9 = bfd_coff_get_auxent(), cVar9 == '\\0')) {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar35 = \"bfd_coff_get_auxent failed: %s\";\n              goto LAB_00105968;\n            }\n            if (pcStack0000000000000090 != (char *)lVar17) break;\n            if (bStack0000000000000100 != 0x67) {\n              cVar9 = debug_set_filename(param_10);\n              if (cVar9 != '\\0') break;\n              goto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            pcStack0000000000000090 = (char *)in_stack_000000f0;\n            cVar9 = debug_set_filename(param_10);\n            if (cVar9 == '\\0') goto LAB_00105981;\n          }\n          if ((char)bStack0000000000000100 < '\\0') {\n            if (bStack0000000000000100 == 0xff) goto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            lVar24 = parse_coff_type_lto_priv_0();\n            if (lVar24 == 0) break;\n            cVar9 = parse_coff_symbol_constprop_0_isra_0(&stack0x00000140,lVar27,lVar17);\n          }\n          else {\n            if (bStack0000000000000100 < 100) {\n              switch(bStack0000000000000100) {\n              case 3:\n                if (in_stack_000000f8._6_2_ == 0) goto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulong)((uint)in_stack_000000f8._6_2_ & *(uint *)(unaff_R14[0x22] + 0x40)) !=\n                    2L << ((byte)*(undefined4 *)(unaff_R14[0x22] + 0x3c) & 0x3f)) goto LAB_0010700a;\n                _uStack0000000000000048 = (int *)(**(code **)(unaff_R14[1] + 0x238))();\n                pcStack0000000000000038 = pcVar35;\n                goto switchD_00106e1a_caseD_68;\n              default:\n                goto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                goto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(bStack0000000000000100) {\n            case 100:\n              iVar12 = strcmp(pcVar35,\".bb\");\n              if (iVar12 == 0) {\n                cVar9 = debug_start_block(param_10);\n              }\n              else {\n                iVar12 = strcmp(pcVar35,\".eb\");\n                if (iVar12 != 0) goto switchD_00106e1a_caseD_68;\n                cVar9 = debug_end_block(param_10);\n              }\n              break;\n            case 0x65:\n              iVar12 = strcmp(pcVar35,\".bf\");\n              if (iVar12 == 0) {\n                if (pcStack0000000000000038 != (char *)0x0) {\n                  lVar17 = parse_coff_type_lto_priv_0();\n                  if ((lVar17 == 0) || (cVar10 = debug_record_function(param_10), cVar10 == '\\0'))\n                  goto LAB_00105981;\n                  if (_uStack0000000000000048 != (int *)0x0) {\n                    iVar12 = 0;\n                    if (bStack0000000000000101 != 0) {\n                      iVar12 = in_stack_00000118 - 1;\n                    }\n                    lVar27 = *(long *)(*(long *)(lVar27 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar33 = _uStack0000000000000048[4];\n                      if (iVar33 == 0) break;\n                      cVar9 = debug_record_line(param_10,iVar12 + iVar33,\n                                                *(long *)(_uStack0000000000000048 + 6) + lVar27);\n                      _uStack0000000000000048 = _uStack0000000000000048 + 4;\n                      if (cVar9 == '\\0') goto LAB_00105981;\n                    }\n                  }\n                  _uStack0000000000000048 = (int *)0x0;\n                  pcStack0000000000000038 = (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar35 = \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar12 = strcmp(pcVar35,\".ef\");\n                if (iVar12 != 0) goto switchD_00106e1a_caseD_68;\n                if (cVar10 != '\\0') {\n                  cVar10 = debug_end_function(param_10);\n                  if (cVar10 == '\\0') goto LAB_00105981;\n                  cVar10 = '\\0';\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar35 = \"%ld: unexpected .ef\\n\";\n              }\n              uVar19 = dcgettext(0,pcVar35,5);\n              non_fatal(uVar19);\n              goto LAB_00105981;\n            default:\n              goto LAB_0010700a;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (cVar9 != '\\0');\n      }\n      else {\n        pcVar35 = \"%s: no recognized debugging information\";\nLAB_00105968:\n        uVar19 = dcgettext(0,pcVar35,5);\n        non_fatal(uVar19);\n      }\n      goto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)(param_7 + 0x44) & 0x42) != 0) && ((*(uint *)(param_7 + 0x44) & 1) == 0)) {\n    if ((*(char *)(*(long *)(param_7 + 8) + 0x20) == '\\0') && (keep_section_symbols == '\\0')) {\n      if (param_8 != 0) {\n        plVar6 = isympp + param_8;\n        plVar16 = isympp;\n        do {\n          uVar11 = *(uint *)(*plVar16 + 0x18);\n          if ((uVar11 & 0x1000000) != 0) {\n            *(uint *)(*plVar16 + 0x18) = uVar11 & 0xfeffffff;\n          }\n          plVar16 = plVar16 + 1;\n        } while (plVar6 != plVar16);\n      }\n    }\n    else {\n      for (lVar27 = *(long *)(param_7 + 0x90); lVar27 != 0; lVar27 = *(long *)(lVar27 + 8)) {\n        if (*(long *)(lVar27 + 0xe8) != 0) {\n          puVar1 = (uint *)(*(long *)(lVar27 + 0xe8) + 0x18);\n          *puVar1 = *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((strip_symbols == 2) || (strip_symbols == 7)) {\nLAB_001059fe:\n    if (strip_symbols == 7) {\nLAB_00105a3b:\n      plVar16 = (long *)xmalloc();\n      plVar6 = isympp;\n      uStack0000000000000048 = *(uint *)((long)unaff_R14 + 0x44) & 0x42;\n      osympp = plVar16;\n      if (param_8 == 0) {\n        uVar28 = 0;\n      }\n      else {\n        uVar28 = 0;\n        _param_9 = 0;\n        do {\n          iVar12 = add_symbols;\n          plVar4 = (long *)plVar6[_param_9];\n          pcVar5 = (code *)plVar4[4];\n          uVar11 = *(uint *)(plVar4 + 3);\n          pcVar35 = (char *)plVar4[1];\n          pcVar30 = pcVar35;\n          if (add_sym_list != (undefined8 *)0x0) {\n            iVar33 = 0;\n            puVar31 = add_sym_list;\n            while ((iVar33 < iVar12 && (pcVar22 = (char *)puVar31[5], pcVar22 != (char *)0x0))) {\n              if (pcVar22 != \"\") {\n                iVar15 = strcmp(pcVar22,pcVar35);\n                if (iVar15 == 0) {\n                  free(pcVar22);\n                  uVar23 = uVar28 + 1;\n                  puVar31[5] = \"\";\n                  lVar27 = create_new_symbol(puVar31);\n                  uVar19 = redefine_specific_htab;\n                  plVar16[uVar28] = lVar27;\n                  lVar27 = htab_elements(uVar19);\n                  if ((lVar27 != 0) || (section_rename_list != (char **)0x0)) goto LAB_001064eb;\n                  goto LAB_00105af8;\n                }\n                puVar31 = (undefined8 *)*puVar31;\n              }\n              iVar33 = iVar33 + 1;\n            }\n          }\n          lVar27 = htab_elements(redefine_specific_htab);\n          uVar23 = uVar28;\n          if ((lVar27 != 0) || (section_rename_list != (char **)0x0)) {\n            if (pcVar35 != (char *)0x0) {\nLAB_001064eb:\n              if (((*pcVar35 == '_') && (pcVar35[1] == '_')) &&\n                 (iVar12 = strcmp(pcVar35 + (pcVar35[2] == '_'),\"__gnu_lto_slim\"), iVar12 == 0)) {\n                uVar19 = dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\"\n                                   ,5);\n                    \n                fatal(uVar19);\n              }\n            }\n            _cStack0000000000000148 = 0;\n            param_13 = pcVar35;\n            lVar27 = htab_find(redefine_specific_htab);\n            if (((lVar27 == 0) || (pcVar30 = *(char **)(lVar27 + 8), pcVar35 == pcVar30)) &&\n               (pcVar30 = pcVar35, ppcVar38 = section_rename_list, (uVar11 & 0x100) != 0)) {\n              for (; ppcVar38 != (char **)0x0; ppcVar38 = (char **)ppcVar38[3]) {\n                iVar12 = strcmp(*ppcVar38,pcVar35);\n                if (iVar12 == 0) {\n                  pcVar30 = ppcVar38[1];\n                  break;\n                }\n              }\n            }\n            plVar4[1] = (long)pcVar30;\n            cVar10 = *pcVar30;\n            if (cVar10 != '\\0') goto LAB_00105b11;\nLAB_00106557:\n            pcVar35 = prefix_symbols_string;\n            if ((change_leading_char != '\\0') && (*(char *)(*(long *)(param_7 + 8) + 0x1c) != '\\0'))\n            {\n              lVar27 = unaff_R14[1];\n              cVar10 = '\\0';\n              goto LAB_0010668d;\n            }\n            goto joined_r0x00106565;\n          }\nLAB_00105af8:\n          cVar10 = *pcVar35;\n          if (cVar10 == '\\0') goto LAB_00106557;\nLAB_00105b11:\n          pcVar35 = prefix_symbols_string;\n          lVar27 = unaff_R14[1];\n          if (*(char *)(lVar27 + 0x1c) == cVar10) {\n            if (change_leading_char == '\\0') {\n              if ((remove_leading_char == '\\0') ||\n                 ((((uVar11 & 0x82) == 0 && (pcVar5 != bfd_map_over_sections)) &&\n                  ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n              pcVar30 = pcVar30 + 1;\n              plVar4[1] = (long)pcVar30;\n              goto joined_r0x00106565;\n            }\n            cVar10 = *(char *)(*(long *)(param_7 + 8) + 0x1c);\n            if (cVar10 == '\\0') goto LAB_0010677d;\n            if (prefix_symbols_string != (char *)0x0) {\n              pcVar30 = pcVar30 + 1;\n              plVar4[1] = (long)pcVar30;\n              sVar20 = strlen(pcVar30);\n              lVar27 = sVar20 + 2;\nLAB_001066bc:\n              sVar20 = strlen(pcVar35);\n              pcVar35 = (char *)xmalloc(sVar20 + lVar27);\n              goto LAB_001066d0;\n            }\n            *pcVar30 = cVar10;\n            plVar4[1] = (long)pcVar30;\n            uVar28 = uVar23;\n          }\n          else {\n            if ((change_leading_char == '\\0') || (*(char *)(*(long *)(param_7 + 8) + 0x1c) == '\\0'))\n            {\njoined_r0x00106565:\n              uVar28 = uVar23;\n              if (pcVar35 == (char *)0x0) goto LAB_00105b32;\n              sVar20 = strlen(pcVar30);\n              sVar21 = strlen(pcVar35);\n              pcVar22 = (char *)xmalloc(sVar21 + sVar20 + 1);\n              pcVar35 = pcVar22;\n            }\n            else {\nLAB_0010668d:\n              pcVar35 = prefix_symbols_string;\n              if ((*(char *)(lVar27 + 0x1c) != '\\0') && (cVar10 != *(char *)(lVar27 + 0x1c)))\n              goto joined_r0x00106565;\n              sVar20 = strlen(pcVar30);\n              lVar27 = sVar20 + 2;\n              if (pcVar35 != (char *)0x0) goto LAB_001066bc;\n              pcVar35 = (char *)xmalloc(lVar27);\nLAB_001066d0:\n              pcVar22 = pcVar35 + 1;\n              *pcVar35 = *(char *)(*(long *)(param_7 + 8) + 0x1c);\n            }\n            __s = prefix_symbols_string;\n            if (prefix_symbols_string != (char *)0x0) {\n              strcpy(pcVar22,prefix_symbols_string);\n              sVar20 = strlen(__s);\n              pcVar22 = pcVar22 + sVar20;\n            }\n            strcpy(pcVar22,pcVar30);\n            plVar4[1] = (long)pcVar35;\n            pcVar30 = pcVar35;\n            uVar28 = uVar23;\n          }\nLAB_00105b32:\n          if (strip_symbols == 7) goto LAB_001067a8;\n          if (((uVar11 & 0x20) == 0) &&\n             (((uVar11 & 0x100) == 0 ||\n              ((*(byte *)(**(long **)(plVar4[4] + 0xf0) + 0x18) & 0x20) == 0)))) {\n            if (((uStack0000000000000048 == 0) &&\n                (((uVar11 & 0x82) != 0 || ((*(byte *)(plVar4[4] + 0x25) & 0x10) != 0)))) ||\n               (iVar12 = bfd_decode_symclass(plVar4), iVar12 == 0x49)) {\nLAB_00105be2:\n              if (wildcard == '\\0') {\n                lVar27 = htab_find();\n                if (lVar27 == 0) goto LAB_00105c07;\n              }\n              else {\n                _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n                param_13 = pcVar30;\n                htab_traverse(strip_specific_htab,is_specified_symbol_predicate,&stack0x00000140);\n                if (cStack0000000000000148 == '\\0') goto LAB_00105c07;\n              }\n            }\n            else if ((((uVar11 & 0x82) == 0) && (pcVar5 != bfd_map_over_sections)) &&\n                    ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)) {\n              if ((uVar11 & 4) == 0) {\n                if (((*(int *)(unaff_R14[1] + 8) != 2) ||\n                    (lVar27 = *(long *)(plVar4[4] + 0xd0), lVar27 == 0)) ||\n                   (*(long *)(lVar27 + 0x40) == 0)) {\n                  if ((strip_symbols == 3) || (discard_locals == 2)) goto LAB_001067a8;\n                  if (discard_locals == 1) {\n                    cVar10 = bfd_is_local_label(unaff_R14);\n                    goto joined_r0x00106a11;\n                  }\n                }\n                goto LAB_00105be2;\n              }\n              cVar10 = convert_debugging;\n              if (1 < strip_symbols - 2U) {\njoined_r0x00106a11:\n                if (cVar10 == '\\0') goto LAB_00105be2;\n              }\n            }\n            else if (strip_symbols != 3) goto LAB_00105be2;\n            goto LAB_001067a8;\n          }\n          if (wildcard == '\\0') {\n            lVar27 = htab_find();\n            if (lVar27 != 0) {\nLAB_0010687f:\n              uVar19 = dcgettext(0,\"not stripping symbol `%s\\' because it is named in a relocation\",\n                                 5);\n              non_fatal(uVar19);\n              status = 1;\n            }\n          }\n          else {\n            _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n            param_13 = pcVar30;\n            htab_traverse(strip_specific_htab,is_specified_symbol_predicate,&stack0x00000140);\n            if (cStack0000000000000148 != '\\0') goto LAB_0010687f;\n          }\n          if ((uVar11 & 0x20) == 0) {\nLAB_00105c07:\n            if (wildcard != '\\0') {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              param_13 = pcVar30;\n              htab_traverse(strip_unneeded_htab,is_specified_symbol_predicate,&stack0x00000140);\n              if (cStack0000000000000148 != '\\0') goto LAB_001067a8;\n              goto LAB_00105c2c;\n            }\n            lVar27 = htab_find();\n            if (lVar27 == 0) goto LAB_00105c2c;\nLAB_001067a8:\n            if ((keep_file_symbols != '\\0') && ((uVar11 & 0x4000) != 0)) goto LAB_00105c2c;\n            if (wildcard == '\\0') {\n              lVar27 = htab_find();\n              if (lVar27 != 0) goto LAB_00105c2c;\n            }\n            else {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              param_13 = pcVar30;\n              htab_traverse(keep_specific_htab,is_specified_symbol_predicate,&stack0x00000140);\n              if (cStack0000000000000148 != '\\0') goto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            cVar10 = is_strip_section_isra_0(plVar4[4]);\n            if (cVar10 == '\\0') {\n              if (((uVar11 & 0x800002) == 0) && (pcVar5 != bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uVar11 & 0x82) != 0) {\n                  cVar10 = is_specified_symbol(pcVar30);\n                  if ((cVar10 == '\\0') &&\n                     ((lVar27 = htab_elements(keepglobal_specific_htab), lVar27 == 0 ||\n                      (cVar10 = is_specified_symbol(pcVar30), cVar10 != '\\0')))) {\n                    if (((((localize_hidden == '\\0') ||\n                          (uVar13 = *(uint *)(plVar4 + 3), (uVar13 & 0x200000) != 0)) ||\n                         (lVar27 = *plVar4, lVar27 == 0)) ||\n                        ((*(int *)(*(long *)(lVar27 + 8) + 8) != 5 ||\n                         (*(long *)(lVar27 + 0x110) == 0)))) ||\n                       (1 < (*(byte *)((long)plVar4 + 0x49) & 3) - 1)) goto joined_r0x00105ca2;\n                  }\n                  else {\n                    uVar13 = *(uint *)(plVar4 + 3);\n                  }\n                  *(uint *)(plVar4 + 3) = uVar13 & 0xffffff7d | 1;\n                }\njoined_r0x00105ca2:\n                if (((uVar11 & 1) != 0) && (cVar10 = is_specified_symbol(pcVar30), cVar10 != '\\0'))\n                {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((weaken != '\\0') || (cVar10 = is_specified_symbol(pcVar30), cVar10 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xff7ffffd | 0x80;\n                }\n                if (pcVar5 != bfd_map_over_sections) goto LAB_00105c5f;\n              }\n              plVar16[uVar28] = (long)plVar4;\n              uVar28 = uVar28 + 1;\n            }\n          }\n          _param_9 = _param_9 + 1;\n        } while (param_8 != _param_9);\n      }\n      if (add_sym_list != (undefined8 *)0x0) {\n        puVar31 = add_sym_list;\n        iVar12 = add_symbols;\n        for (lVar27 = 0; lVar27 < iVar12; lVar27 = lVar27 + 1) {\n          pcVar35 = (char *)puVar31[5];\n          if (pcVar35 == (char *)0x0) {\n            plVar6 = plVar16 + uVar28;\n            uVar28 = uVar28 + 1;\n            lVar17 = create_new_symbol(puVar31,param_7);\n            *plVar6 = lVar17;\n            iVar12 = add_symbols;\n          }\n          else if (pcVar35 != \"\") {\n            uVar19 = dcgettext(0,\"\\'before=%s\\' not found\",5);\n                    \n            fatal(uVar19,pcVar35);\n          }\n          puVar31 = (undefined8 *)*puVar31;\n        }\n      }\n      bVar41 = convert_debugging == '\\0';\n      plVar16[uVar28] = 0;\n      if ((bVar41) || (param_10 == (undefined4 *)0x0)) {\nLAB_00105cfa:\n        param_8 = uVar28 & 0xffffffff;\n        goto LAB_00105710;\n      }\n      iVar12 = *(int *)(*(undefined8 **)(param_7 + 8) + 1);\n      if ((iVar12 == 5) || (iVar12 == 2)) {\n        in_stack_000000e0 = (void *)0x0;\n        cVar10 = write_stabs_in_sections_debugging_info_constprop_0\n                           (param_7,param_10,&stack0x000000c0,&stack0x00000110,&stack0x000000e0,\n                            &stack0x00000140);\n        if (cVar10 != '\\0') {\n          lVar27 = bfd_make_section_with_flags(param_7,\".stab\",0x2108);\n          lVar17 = bfd_make_section_with_flags(param_7,\".stabstr\",0x2108);\n          if ((((lVar27 == 0) || (lVar17 == 0)) ||\n              (cVar10 = bfd_set_section_size(lVar27,in_stack_00000110), cVar10 == '\\0')) ||\n             (cVar10 = bfd_set_section_size(lVar17,param_13), cVar10 == '\\0')) {\n            pcVar35 = \"can\\'t create debugging section\";\n          }\n          else {\n            *(undefined4 *)(lVar27 + 0x7c) = 2;\n            *(undefined4 *)(lVar17 + 0x7c) = 0;\n            cVar10 = bfd_set_section_contents(param_7,lVar27,in_stack_000000c0,0,in_stack_00000110);\n            if ((cVar10 != '\\0') &&\n               (cVar10 = bfd_set_section_contents(param_7,lVar17,in_stack_000000e0,0,param_13),\n               cVar10 != '\\0')) {\n              free(param_10);\n              goto LAB_00105cfa;\n            }\n            pcVar35 = \"can\\'t set debugging section contents\";\n          }\n          uVar19 = dcgettext(0,pcVar35,5);\n          bfd_nonfatal_message(0,param_7,0,uVar19);\n          free(in_stack_000000e0);\n          free(param_10);\n          goto LAB_00105d96;\n        }\n      }\n      else {\n        uVar19 = **(undefined8 **)(param_7 + 8);\n        uVar18 = dcgettext(0,\"don\\'t know how to write debugging information for %s\",5);\n        bfd_nonfatal_message(0,param_7,0,uVar18,uVar19);\n      }\n      free(param_10);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections();\n      iVar12 = bfd_get_error();\n      if (iVar12 == 0) goto LAB_00105a3b;\n    }\nLAB_00105d96:\n    status = 1;\n  }\n  else {\n    if ((strip_symbols - 3U < 4) || ((discard_locals != 0 || (localize_hidden != '\\0'))))\n    goto LAB_00105a07;\n    lVar27 = htab_elements(strip_specific_htab);\n    if (((lVar27 != 0) ||\n        (((((((lVar27 = htab_elements(keep_specific_htab), lVar27 != 0 ||\n              (lVar27 = htab_elements(localize_specific_htab), lVar27 != 0)) ||\n             (lVar27 = htab_elements(globalize_specific_htab), lVar27 != 0)) ||\n            ((lVar27 = htab_elements(keepglobal_specific_htab), lVar27 != 0 ||\n             (lVar27 = htab_elements(weaken_specific_htab), lVar27 != 0)))) ||\n           (lVar27 = htab_elements(redefine_specific_htab), lVar27 != 0)) ||\n          (((prefix_symbols_string != (char *)0x0 || (sections_removed != '\\0')) ||\n           ((sections_copied != '\\0' ||\n            (((convert_debugging != '\\0' || (change_leading_char != '\\0')) ||\n             (remove_leading_char != '\\0')))))))) ||\n         ((section_rename_list != (char **)0x0 || (weaken != '\\0')))))) || (add_symbols != 0))\n    goto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(param_7,osympp,param_8 & 0xffffffff);\n    bfd_map_over_sections(unaff_R14,copy_relocations_in_section,param_7);\n    bfd_map_over_sections(unaff_R14,copy_section,param_7);\n    for (puVar31 = add_sections; puVar37 = update_sections, puVar31 != (undefined8 *)0x0;\n        puVar31 = (undefined8 *)*puVar31) {\n      cVar10 = bfd_set_section_contents(param_7,puVar31[5],puVar31[4],0,puVar31[3]);\n      if (cVar10 == '\\0') {\n        bfd_nonfatal_message(0,param_7,puVar31[5],0);\n        return 0;\n      }\n    }\n    for (; puVar37 != (undefined8 *)0x0; puVar37 = (undefined8 *)*puVar37) {\n      uVar19 = *(undefined8 *)(puVar37[5] + 0x60);\n      cVar10 = bfd_set_section_contents(param_7,uVar19,puVar37[4],0,puVar37[3]);\n      if (cVar10 == '\\0') {\n        bfd_nonfatal_message(0,param_7,uVar19,0);\n        return 0;\n      }\n    }\n    if (__ptr_01 == (long **)0x0) {\n      if ((merge_notes != '\\0') && (is_strip == 0)) {\n        uVar19 = *unaff_R14;\n        uVar18 = dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n        non_fatal(uVar18,uVar19);\n      }\n    }\n    else {\n      pplVar34 = (long **)0x0;\n      for (puVar31 = *(undefined8 **)(param_7 + 0x90); puVar31 != (undefined8 *)0x0;\n          puVar31 = (undefined8 *)puVar31[1]) {\n        if (((merge_notes != '\\0') && (*(int *)(*(long *)(param_7 + 8) + 8) == 5)) &&\n           ((*(int *)(puVar31[0x1a] + 4) == 7 &&\n            (cVar10 = startswith_lto_priv_0_lto_priv_0(*puVar31,\".gnu.build.attributes\"),\n            cVar10 != '\\0')))) {\n          if (pplVar34 == (long **)0x0) {\n            pplVar34 = __ptr_01;\n          }\n          pplVar29 = __ptr_01;\n          if ((undefined8 *)(*pplVar34)[0xc] == puVar31) {\nLAB_0010625f:\n            pcVar35 = \"error: failed to merge notes\";\n            if (pplVar34[1] != (long *)0x0) {\n              cVar10 = bfd_set_section_contents(param_7,puVar31,pplVar34[1],0,pplVar34[2]);\n              if (cVar10 == '\\0') {\n                uVar19 = dcgettext(0,\"error: failed to copy merged notes into output\",5);\n                bfd_nonfatal_message(0,param_7,puVar31,uVar19);\n                return 0;\n              }\n              pplVar34 = (long **)pplVar34[3];\n              goto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              pplVar34 = pplVar29;\n              if ((undefined8 *)(*pplVar29)[0xc] == puVar31) goto LAB_0010625f;\n              pplVar34 = (long **)pplVar29[3];\n              pplVar29 = pplVar34;\n            } while (pplVar34 != (long **)0x0);\n            pcVar35 = \"error: failed to locate merged notes\";\n          }\n          uVar19 = dcgettext(0,pcVar35,5);\n          bfd_nonfatal_message(0,param_7,puVar31,uVar19);\n        }\nLAB_001061be:\n      }\n      do {\n        pplVar34 = (long **)__ptr_01[3];\n        free(__ptr_01[1]);\n        free(__ptr_01);\n        __ptr_01 = pplVar34;\n      } while (pplVar34 != (long **)0x0);\n    }\n    if ((gnu_debuglink_filename == 0) ||\n       (cVar10 = bfd_fill_in_gnu_debuglink_section(param_7,param_12),\n       lVar27 = gnu_debuglink_filename, cVar10 != '\\0')) {\n      uVar11 = (**(code **)(*(long *)(param_7 + 8) + 0x140))(unaff_R14);\n      uVar28 = (ulong)uVar11;\n      if ((char)uVar11 != '\\0') {\n        if (use_alt_mach_code == 0) {\n          return uVar28;\n        }\n        cVar10 = bfd_alt_mach_code(param_7,use_alt_mach_code & 0xffffffff);\n        uVar23 = use_alt_mach_code;\n        if (cVar10 == '\\0') {\n          uVar19 = dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n          non_fatal(uVar19,uVar23);\n          if (*(int *)(*(long *)(param_7 + 8) + 8) == 5) {\n            uVar19 = dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n            non_fatal(uVar19);\n            *(short *)(*(long *)(param_7 + 0x110) + 0x3a) = (short)use_alt_mach_code;\n            return uVar28;\n          }\n          uVar19 = dcgettext(0,\"ignoring the alternative value\",5);\n          non_fatal(uVar19);\n          return uVar28;\n        }\n        return uVar28;\n      }\n      uVar19 = dcgettext(0,\"error copying private BFD data\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar19);\n    }\n    else {\n      uVar19 = dcgettext(0,\"cannot fill debug link section `%s\\'\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar19,lVar27);\n    }\n  }\n  return 0;\nLAB_00115187:\n  if ((((*(int *)(unaff_R14[1] + 8) == 5) && (*(int *)((long)pplVar34[0x1a] + 4) == 7)) &&\n      (cVar10 = startswith_lto_priv_0_lto_priv_0(*pplVar34), cVar10 != '\\0')) &&\n     ((pplVar34[0xc] != (long *)0x0 && (plVar6 = pplVar34[8], plVar6 != (long *)0x0)))) {\n    pplVar29 = (long **)xmalloc(0x20);\n    pplVar29[1] = (long *)0x0;\n    cVar10 = bfd_get_full_section_contents();\n    if (cVar10 == '\\0') {\n      dcgettext(0,\"warning: could not load note section\",5);\n      bfd_nonfatal_message(0);\n      free(pplVar29);\n    }\n    else {\n      plVar16 = (long *)merge_gnu_build_notes();\n      pplVar29[2] = plVar16;\n      if ((plVar16 == plVar6) || (cVar10 = bfd_set_section_size(pplVar34[0xc]), cVar10 != '\\0')) {\n        pplVar29[3] = (long *)__ptr_01;\n        *pplVar29 = (long *)pplVar34;\n        __ptr_01 = pplVar29;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        bfd_nonfatal_message(0,param_7,pplVar34);\n        free(pplVar29[1]);\n        free(pplVar29);\n      }\n    }\n  }\n  pplVar34 = (long **)pplVar34[1];\n  puVar31 = dump_sections;\n  if (pplVar34 == (long **)0x0) goto joined_r0x001151c7;\n  goto LAB_001151ab;\n}\n\n",
            "called": [
                "bfd_get_section_by_name",
                "strerror",
                "merge_gnu_build_notes",
                "check_new_section_flags",
                "startswith.lto_priv.0.lto_priv.0",
                "FUN_0010554f",
                "find_section_list",
                "bfd_get_arch",
                "setup_section",
                "bfd_create_gnu_debuglink_section",
                "dcgettext",
                "bfd_set_section_size",
                "bfd_nonfatal_message",
                "bfd_get_full_section_contents",
                "FUN_00105828",
                "copy_object.cold",
                "bfd_malloc_and_get_section",
                "non_fatal",
                "fwrite",
                "bfd_set_format",
                "free",
                "bfd_map_over_sections",
                "fclose",
                "bfd_make_section_with_flags",
                "xmalloc",
                "fopen",
                "__errno_location"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00107880",
            "calling": [
                "FUN_001152b6"
            ],
            "imported": false,
            "current_name": "FUNC_00107880"
        },
        "FUN_0011a350": {
            "renaming": {
                "FUN_0011a350": "set_file_time_0011a350",
                "param_1": "filePath",
                "param_2": "fileInfo",
                "iVar1": "result",
                "piVar2": "errno",
                "pcVar3": "errorMessage",
                "uVar4": "localizedErrorMessage",
                "local_38": "modificationTime",
                "uStack_34": "unusedVar1",
                "uStack_30": "unusedVar2",
                "uStack_2c": "unusedVar3",
                "local_28": "accessTime",
                "uStack_24": "changeTime",
                "uStack_20": "birthTime",
                "uStack_1c": "unusedVar4"
            },
            "code": "\nvoid setFileTime_0011a350(char *filePath,long fileInfo)\n\n{\n  int result;\n  int *errno;\n  char *errorMessage;\n  undefined8 localizedErrorMessage;\n  undefined4 modificationTime;\n  undefined4 unusedVar1;\n  undefined4 unusedVar2;\n  undefined4 unusedVar3;\n  undefined4 accessTime;\n  undefined4 changeTime;\n  undefined4 birthTime;\n  undefined4 unusedVar4;\n  \n  accessTime = *(undefined4 *)(fileInfo + 0x58);\n  changeTime = *(undefined4 *)(fileInfo + 0x5c);\n  birthTime = *(undefined4 *)(fileInfo + 0x60);\n  unusedVar4 = *(undefined4 *)(fileInfo + 100);\n  modificationTime = *(undefined4 *)(fileInfo + 0x48);\n  unusedVar1 = *(undefined4 *)(fileInfo + 0x4c);\n  unusedVar2 = *(undefined4 *)(fileInfo + 0x50);\n  unusedVar3 = *(undefined4 *)(fileInfo + 0x54);\n  result = utimensat(-100,filePath,(timespec *)&modificationTime,0);\n  if (result != 0) {\n    errno = __errno_location();\n    errorMessage = strerror(*errno);\n    localizedErrorMessage = dcgettext(0,\"%s: cannot set time: %s\",5);\n    non_fatal(localizedErrorMessage,filePath,errorMessage);\n  }\n  return;\n}\n\n",
            "called": [
                "set_times.cold",
                "utimensat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a350",
            "calling": [
                "FUN_00104ea2",
                "smart_rename.cold"
            ],
            "imported": false,
            "current_name": "set_file_time_0011a350"
        },
        "FUN_00128448": {
            "renaming": {},
            "code": "\n\n\n\nvoid exit(int __status)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* exit@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128448",
            "calling": [
                "exit"
            ],
            "imported": false,
            "current_name": "FUN_00128448"
        },
        "FUN_00128328": {
            "renaming": {},
            "code": "\n\n\n\nint fflush(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fflush@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128328",
            "calling": [
                "fflush"
            ],
            "imported": false,
            "current_name": "FUN_00128328"
        },
        "FUN_0011a110": {
            "renaming": {
                "FUN_0011a110": "print_error_message_0011a110",
                "param_1": "errorMessage",
                "iVar1": "error",
                "uVar2": "errorMsg",
                "in_R10": "additionalInfo",
                "_stdout": "stdout",
                "_stderr": "stderr",
                "program_name": "appName"
            },
            "code": "\n\n\nvoid printErrorMessage_0011a110(long errorMessage)\n\n{\n  int error;\n  undefined8 errorMsg;\n  undefined8 additionalInfo;\n  \n  error = bfd_get_error();\n  if (error == 0) {\n    errorMsg = dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    errorMsg = bfd_errmsg(error);\n  }\n  fflush(stdout);\n  if (errorMessage != 0) {\n    fprintf(stderr,\"%s: %s: %s\\n\",appName,errorMessage,errorMsg,additionalInfo);\n    return;\n  }\n  fprintf(stderr,\"%s: %s\\n\",appName,errorMsg,additionalInfo);\n  return;\n}\n\n",
            "called": [
                "bfd_get_error",
                "bfd_nonfatal.cold",
                "bfd_errmsg"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a110",
            "calling": [
                "do_display_target.cold",
                "mark_symbols_used_in_relocations.cold",
                "copy_relocations_in_section",
                "mark_symbols_used_in_relocations",
                "FUN_00104ea2",
                "do_display_target"
            ],
            "imported": false,
            "current_name": "print_error_message_0011a110"
        },
        "FUN_0010e2f0": {
            "renaming": {
                "FUN_0010e2f0": "add_string_to_table_0010e2f0",
                "param_1": "table",
                "param_2": "option",
                "param_3": "value",
                "param_4": "data",
                "param_5": "string",
                "lVar1": "length",
                "lVar3": "hashEntry",
                "lVar7": "stringOffset",
                "uVar2": "error",
                "uVar4": "errorMsg",
                "uVar5": "errorMessage",
                "sVar6": "stringLength",
                "local_44": "result",
                "uStack_40": "var1",
                "uStack_3f": "var2",
                "uStack_3e": "var3",
                "local_3c": "array",
                "bfd_hash_lookup": "lookupHash",
                "bfd_get_error": "getError",
                "bfd_errmsg": "errorMessage",
                "dcgettext": "getTranslatedString",
                "non_fatal": "handleNonFatal",
                "strlen": "getStringLength",
                "xrealloc": "reallocateMemory"
            },
            "code": "\nundefined8\naddStringToTable_0010e2f0(long *table,undefined option,int value,undefined8 data,char *string)\n\n{\n  long length;\n  undefined4 error;\n  long hashEntry;\n  undefined8 errorMsg;\n  undefined8 errorMessage;\n  size_t stringLength;\n  long stringOffset;\n  undefined4 result;\n  undefined var1;\n  undefined var2;\n  undefined2 var3;\n  undefined4 array [3];\n  \n  if (string == (char *)0x0) {\n    stringOffset = 0;\n  }\n  else {\n    hashEntry = lookupHash(table + 7,string,1,1);\n    if (hashEntry == 0) {\n      error = getError();\n      errorMsg = errorMessage(error);\n      errorMessage = getTranslatedString(0,\"string_hash_lookup failed: %s\",5);\n      handleNonFatal(errorMessage,errorMsg);\n      return 0;\n    }\n    stringOffset = *(long *)(hashEntry + 0x20);\n    if (stringOffset == -1) {\n      stringOffset = table[6];\n      length = table[5];\n      *(long *)(hashEntry + 0x20) = stringOffset;\n      if (length == 0) {\n        table[4] = hashEntry;\n      }\n      else {\n        *(long *)(length + 0x18) = hashEntry;\n      }\n      table[5] = hashEntry;\n      stringLength = getStringLength(string);\n      table[6] = stringOffset + 1 + stringLength;\n    }\n  }\n  (**(code **)(*(long *)(*table + 8) + 0x50))(stringOffset,&result);\n  var2 = 0;\n  var1 = option;\n  (**(code **)(*(long *)(*table + 8) + 0x68))((long)value,&var3);\n  (**(code **)(*(long *)(*table + 8) + 0x50))(data,array);\n  if ((ulong)table[3] < table[2] + 0xcU) {\n    table[3] = table[3] * 2;\n    stringOffset = reallocateMemory(table[1]);\n    table[1] = stringOffset;\n  }\n  stringOffset = table[2];\n  hashEntry = table[1];\n  *(ulong *)(hashEntry + stringOffset) = CONCAT26(var3,CONCAT15(var2,CONCAT14(var1,result)));\n  *(undefined4 *)(hashEntry + 8 + stringOffset) = array[0];\n  table[2] = table[2] + 0xc;\n  return CONCAT71((int7)((ulong)stringOffset >> 8),1);\n}\n\n",
            "called": [
                "bfd_hash_lookup",
                "bfd_get_error",
                "strlen",
                "bfd_errmsg",
                "dcgettext",
                "non_fatal",
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e2f0",
            "calling": [
                "stab_function_type.lto_priv.0",
                "stab_variable.lto_priv.0",
                "stab_tag.lto_priv.0",
                "stab_typed_constant.lto_priv.0",
                "stab_lineno.lto_priv.0",
                "stab_typdef.lto_priv.0",
                "stab_start_function.lto_priv.0",
                "stab_int_constant.lto_priv.0",
                "stab_start_block.lto_priv.0",
                "stab_enum_type.lto_priv.0",
                "stab_start_source.lto_priv.0",
                "stab_float_constant.lto_priv.0",
                "write_stabs_in_sections_debugging_info.constprop.0",
                "stab_end_block.lto_priv.0",
                "stab_function_parameter.lto_priv.0"
            ],
            "imported": false,
            "current_name": "add_string_to_table_0010e2f0"
        },
        "FUN_00113fe0": {
            "renaming": {
                "FUN_00113fe0": "parse_section_flags_00113fe0",
                "param_1": "flagsString",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "iVar1": "result",
                "uVar2": "errorMsg",
                "pcVar3": "commaPos",
                "pcVar4": "nextFlag",
                "sVar5": "flagLength",
                "iVar6": "flagIndex",
                "uVar7": "sectionFlags",
                "auVar8": "output"
            },
            "code": "\nundefined  [16] parseSectionFlags_00113fe0(char *flagsString,undefined8 param2,undefined8 param3,undefined8 param4)\n\n{\n  int result;\n  undefined8 errorMsg;\n  char *commaPos;\n  char *nextFlag;\n  size_t flagLength;\n  int flagIndex;\n  uint sectionFlags;\n  undefined output [16];\n  \n  sectionFlags = 0;\n  do {\n    commaPos = strchr(flagsString,0x2c);\n    if (commaPos == (char *)0x0) {\n      flagLength = strlen(flagsString);\n      flagIndex = (int)flagLength;\n      nextFlag = (char *)0x0;\n    }\n    else {\n      nextFlag = commaPos + 1;\n      flagIndex = (int)commaPos - (int)flagsString;\n    }\n    flagLength = (size_t)flagIndex;\n    result = strncasecmp(\"alloc\",flagsString,flagLength);\n    if (result == 0) {\n      sectionFlags = sectionFlags | 1;\n    }\n    else {\n      result = strncasecmp(\"load\",flagsString,flagLength);\n      if (result == 0) {\n        sectionFlags = sectionFlags | 2;\n      }\n      else {\n        result = strncasecmp(\"noload\",flagsString,flagLength);\n        if (result == 0) {\n          sectionFlags = sectionFlags | 0x200;\n        }\n        else {\n          result = strncasecmp(\"readonly\",flagsString,flagLength);\n          if (result == 0) {\n            sectionFlags = sectionFlags | 8;\n          }\n          else {\n            result = strncasecmp(\"debug\",flagsString,flagLength);\n            if (result == 0) {\n              sectionFlags = sectionFlags | 0x2000;\n            }\n            else {\n              result = strncasecmp(\"code\",flagsString,flagLength);\n              if (result == 0) {\n                sectionFlags = sectionFlags | 0x10;\n              }\n              else {\n                result = strncasecmp(\"data\",flagsString,flagLength);\n                if (result == 0) {\n                  sectionFlags = sectionFlags | 0x20;\n                }\n                else {\n                  result = strncasecmp(\"rom\",flagsString,flagLength);\n                  if (result == 0) {\n                    sectionFlags = sectionFlags | 0x40;\n                  }\n                  else {\n                    result = strncasecmp(\"exclude\",flagsString,flagLength);\n                    if (result == 0) {\n                      sectionFlags = sectionFlags | 0x8000;\n                    }\n                    else {\n                      result = strncasecmp(\"share\",flagsString,flagLength);\n                      if (result == 0) {\n                        sectionFlags = sectionFlags | 0x8000000;\n                      }\n                      else {\n                        result = strncasecmp(\"contents\",flagsString,flagLength);\n                        if (result == 0) {\n                          sectionFlags = sectionFlags | 0x100;\n                        }\n                        else {\n                          result = strncasecmp(\"merge\",flagsString,flagLength);\n                          if (result == 0) {\n                            sectionFlags = sectionFlags | 0x800000;\n                          }\n                          else {\n                            result = strncasecmp(\"strings\",flagsString,flagLength);\n                            if (result != 0) {\n                              commaPos = (char *)xmalloc((long)(flagIndex + 1));\n                              strncpy(commaPos,flagsString,flagLength);\n                              commaPos[flagLength] = '\\0';\n                              errorMsg = dcgettext(0,\"unrecognized section flag `%s\\'\",5);\n                              non_fatal(errorMsg,commaPos);\n                              errorMsg = dcgettext(0,\"supported flags: %s\",5);\n                    \n                              fatal(errorMsg,\n                                    \"alloc, load, noload, readonly, debug, code, data, rom, exclude, share, contents, merge, strings\"\n                                   );\n                            }\n                            sectionFlags = sectionFlags | 0x1000000;\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    flagsString = nextFlag;\n  } while (nextFlag != (char *)0x0);\n  output._4_4_ = 0;\n  output._0_4_ = sectionFlags;\n  output._8_8_ = param4;\n  return output;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113fe0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "parse_section_flags_00113fe0"
        },
        "FUN_001125fa": {
            "renaming": {
                "FUN_001125fa": "get_archive_filename_001125fa",
                "param_1": "arguments",
                "ppcVar2": "archiveFileName",
                "sVar3": "archiveLen",
                "sVar4": "inputLen",
                "__s": "output",
                "uVar1": "outputLen",
                "curr_1": "currentLen",
                "buf_0": "buffer"
            },
            "code": "\nchar * getArchiveFilename_001125fa(char **arguments)\n\n{\n  ulong outputLen;\n  char **archiveFileName;\n  size_t archiveLen;\n  size_t inputLen;\n  char *output;\n  \n  if (arguments == (char **)0x0) {\n                    \n    __assert_fail(\"abfd != NULL\",\"../../binutils/bucomm.c\",0x298,\"bfd_get_archive_filename\");\n  }\n  archiveFileName = (char **)arguments[0x1d];\n  output = *arguments;\n  if ((archiveFileName != (char **)0x0) && ((*(byte *)((long)archiveFileName + 0x49) & 0x10) == 0)) {\n    archiveLen = strlen(*archiveFileName);\n    inputLen = strlen(output);\n    outputLen = archiveLen + 3 + inputLen;\n    if (currentLen < outputLen) {\n      if (currentLen != 0) {\n        free(buffer);\n      }\n      currentLen = (outputLen >> 1) + outputLen;\n      buffer = (char *)xmalloc();\n    }\n    sprintf(buffer,\"%s(%s)\",*(undefined8 *)arguments[0x1d],*arguments);\n    output = buffer;\n  }\n  return output;\n}\n\n",
            "called": [
                "strlen",
                "sprintf",
                "free",
                "__assert_fail",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001125fa",
            "calling": [
                "copy_object",
                "FUN_00105828",
                "FUN_00107976",
                "FUN_001152b6",
                "bfd_nonfatal_message",
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "get_archive_filename_001125fa"
        },
        "FUN_00104380": {
            "renaming": {},
            "code": "\n\n\nsize_t strnlen(char *__string,size_t __maxlen)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strnlen(__string,__maxlen);\n  return sVar1;\n}\n\n",
            "called": [
                "strnlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104380",
            "calling": [
                "xstrndup"
            ],
            "imported": false,
            "current_name": "FUN_00104380"
        },
        "FUN_00104260": {
            "renaming": {},
            "code": "\nvoid bfd_get_section_contents(void)\n\n{\n  bfd_get_section_contents();\n  return;\n}\n\n",
            "called": [
                "bfd_get_section_contents"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104260",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "FUN_00104260"
        },
        "FUN_001048c0": {
            "renaming": {},
            "code": "\n\n\nchar * strstr(char *__haystack,char *__needle)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strstr(__haystack,__needle);\n  return pcVar1;\n}\n\n",
            "called": [
                "strstr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048c0",
            "calling": [
                "parse_stab_type",
                "stab_demangle_template"
            ],
            "imported": false,
            "current_name": "FUN_001048c0"
        },
        "FUN_001047a0": {
            "renaming": {},
            "code": "\nvoid bfd_errmsg(void)\n\n{\n  bfd_errmsg();\n  return;\n}\n\n",
            "called": [
                "bfd_errmsg"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047a0",
            "calling": [
                "main",
                "parse_coff_type.lto_priv.0",
                "stab_write_symbol.lto_priv.0",
                "FUN_0010554f",
                "parse_coff_struct_type",
                "bfd_nonfatal_message",
                "bfd_nonfatal",
                "write_stabs_in_sections_debugging_info.constprop.0",
                "stab_typdef.lto_priv.0"
            ],
            "imported": false,
            "current_name": "FUN_001047a0"
        },
        "FUN_00108f05": {
            "renaming": {
                "FUN_00108f05": "get_one_00108f05"
            },
            "code": "\nundefined getOne_00108f05(void)\n\n{\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108f05",
            "calling": [
                "debug_write_name.constprop.0"
            ],
            "imported": false,
            "current_name": "get_one_00108f05"
        },
        "FUN_00108863": {
            "renaming": {
                "FUN_00108863": "cleanup_and_reset_00108863",
                "puVar1": "currentEntry",
                "puVar2": "nextEntry",
                "saved_stabs": "entryList",
                "saved_stabs_index": "entryListSize"
            },
            "code": "\nvoid cleanupAndReset_00108863(void)\n\n{\n  undefined4 *currentEntry;\n  undefined4 *nextEntry;\n  \n  currentEntry = (undefined4 *)entryList;\n  do {\n    nextEntry = currentEntry + 6;\n    free(*(void **)(currentEntry + 4));\n    *(undefined8 *)(currentEntry + 4) = 0;\n    currentEntry = nextEntry;\n  } while (nextEntry != &entryListSize);\n  entryListSize = 0;\n  return;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108863",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "cleanup_and_reset_00108863"
        },
        "FUN_00104020": {
            "renaming": {
                "FUN_00104020": "execute_indirect_jump_00104020"
            },
            "code": "\nvoid executeIndirectJump_00104020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(undefined *)0x0)();\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104020",
            "calling": [],
            "imported": false,
            "current_name": "execute_indirect_jump_00104020"
        },
        "FUN_00128450": {
            "renaming": {},
            "code": "\n\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fwrite@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128450",
            "calling": [
                "fwrite",
                "mark_symbols_used_in_relocations"
            ],
            "imported": false,
            "current_name": "FUN_00128450"
        },
        "FUN_00108f08": {
            "renaming": {
                "FUN_00108f08": "update_debug_info_00108f08",
                "param_1": "param1",
                "param_2": "param2",
                "iVar1": "comparisonResult",
                "uVar2": "returnValue",
                "puVar3": "currentFilename",
                "puVar4": "tempPtr",
                "lVar5": "loopCounter",
                "puVar6": "filenameList",
                "pcVar7": "defaultFilename",
                "puVar8": "lastPtr",
                "bVar9": "byteFlag"
            },
            "code": "\n\n\nundefined8 updateDebugInfo_00108f08(long param1,char *param2)\n\n{\n  int comparisonResult;\n  undefined8 returnValue;\n  undefined8 *currentFilename;\n  undefined8 *tempPtr;\n  long loopCounter;\n  undefined8 *filenameList;\n  char *defaultFilename;\n  undefined8 *lastPtr;\n  byte byteFlag;\n  \n  byteFlag = 0;\n  defaultFilename = \"\";\n  if (param2 != (char *)0x0) {\n    defaultFilename = param2;\n  }\n  if (*(long *)(param1 + 8) == 0) {\n    returnValue = dcgettext(0,\"debug_start_source: no debug_set_filename call\",5);\n    fprintf(_stderr,\"%s\\n\",returnValue);\n    returnValue = 0;\n  }\n  else {\n    for (currentFilename = *(undefined8 **)(*(long *)(param1 + 8) + 8); currentFilename != (undefined8 *)0x0;\n        currentFilename = (undefined8 *)*currentFilename) {\n      comparisonResult = filename_cmp(currentFilename[1],defaultFilename);\n      if (comparisonResult == 0) goto LAB_00108fad;\n    }\n    currentFilename = (undefined8 *)xmalloc(0x18);\n    filenameList = *(undefined8 **)(param1 + 0x10);\n    lastPtr = currentFilename;\n    for (loopCounter = 6; loopCounter != 0; loopCounter = loopCounter + -1) {\n      *(undefined4 *)lastPtr = 0;\n      lastPtr = (undefined8 *)((long)lastPtr + (ulong)byteFlag * -8 + 4);\n    }\n    currentFilename[1] = defaultFilename;\n    lastPtr = (undefined8 *)*filenameList;\n    while (tempPtr = lastPtr, tempPtr != (undefined8 *)0x0) {\n      filenameList = tempPtr;\n      lastPtr = (undefined8 *)*tempPtr;\n    }\n    *filenameList = currentFilename;\nLAB_00108fad:\n    *(undefined8 **)(param1 + 0x10) = currentFilename;\n    returnValue = 1;\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext",
                "filename_cmp",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108f08",
            "calling": [
                "parse_stab"
            ],
            "imported": false,
            "current_name": "update_debug_info_00108f08"
        },
        "FUN_00104140": {
            "renaming": {},
            "code": "\n\n\nvoid qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)\n\n{\n  qsort(__base,__nmemb,__size,__compar);\n  return;\n}\n\n",
            "called": [
                "qsort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104140",
            "calling": [
                "FUN_001086af",
                "FUN_00116852",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "FUN_00104140"
        },
        "FUN_00114b84": {
            "renaming": {
                "FUN_00114b84": "remove_directory_00114b84",
                "param_9": "directoryPath"
            },
            "code": "\nvoid removeDirectory_00114b84(void)\n\n{\n  char *directoryPath;\n  \n  rmdir(directoryPath);\n  free(directoryPath);\n  return;\n}\n\n",
            "called": [
                "rmdir",
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114b84",
            "calling": [
                "copy_file.cold",
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "remove_directory_00114b84"
        },
        "FUN_00128210": {
            "renaming": {},
            "code": "\n\n\n\nsize_t strspn(char *__s,char *__accept)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strspn@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128210",
            "calling": [
                "strspn"
            ],
            "imported": false,
            "current_name": "FUN_00128210"
        },
        "FUN_00114190": {
            "renaming": {
                "FUN_00114190": "find_matching_section_00114190",
                "param_1": "section_name",
                "param_2": "exact_match",
                "param_3": "flags",
                "uVar1": "section_flags",
                "plVar2": "current_pattern",
                "pplVar3": "last_section",
                "iVar4": "result",
                "uVar5": "error_message",
                "pplVar6": "current_section",
                "pplVar7": "previous_section",
                "pplVar8": "next_section"
            },
            "code": "\nlong ** find_matching_section_00114190(long *section_name,char exact_match,uint flags)\n\n{\n  uint section_flags;\n  long *current_pattern;\n  long **last_section;\n  int result;\n  undefined8 error_message;\n  long **current_section;\n  long **previous_section;\n  long **next_section;\n  \n  previous_section = change_sections;\n  if (change_sections == (long **)0x0) {\n    if (exact_match == '\\0') {\n      return (long **)0x0;\n    }\n    goto LAB_001142a9;\n  }\n  if (exact_match == '\\0') {\n    if ((flags & *(uint *)((long)change_sections + 0x14)) == 0) {\nLAB_001141e5:\n      current_section = (long **)*previous_section;\n      if (current_section == (long **)0x0) {\n        return (long **)0x0;\n      }\n      previous_section = (long **)0x0;\n    }\n    else {\n      current_pattern = change_sections[1];\n      if (*(char *)current_pattern == '!') {\n        result = fnmatch((char *)((long)current_pattern + 1),(char *)section_name,0);\n        current_section = previous_section;\n        if (result == 0) goto LAB_0011438e;\n        goto LAB_001141e5;\n      }\n      result = fnmatch((char *)current_pattern,(char *)section_name,0);\n      if (result != 0) goto LAB_001141e5;\n      current_section = (long **)*previous_section;\n      if (current_section == (long **)0x0) goto LAB_00114245;\n    }\n    if ((flags & *(uint *)((long)current_section + 0x14)) != 0) {\n      current_pattern = current_section[1];\n      if (*(char *)current_pattern == '!') {\n        result = fnmatch((char *)((long)current_pattern + 1),(char *)section_name,0);\n        if (result == 0) {\nLAB_0011438e:\n          *(undefined *)(current_section + 2) = 1;\n          return (long **)0x0;\n        }\n      }\n      else {\n        result = fnmatch((char *)current_pattern,(char *)section_name,0);\n        if ((previous_section == (long **)0x0) && (result == 0)) {\n          next_section = (long **)*current_section;\n          previous_section = current_section;\n          if (next_section == (long **)0x0) goto LAB_00114245;\n          goto LAB_00114288;\n        }\n      }\n    }\n    next_section = (long **)*current_section;\n    current_section = previous_section;\n    if (next_section != (long **)0x0) goto LAB_00114288;\n  }\n  else {\n    result = strcmp((char *)change_sections[1],(char *)section_name);\n    if (result == 0) {\nLAB_001143cd:\n      section_flags = *(uint *)((long)previous_section + 0x14);\n      if ((((section_flags & 1) != 0) && ((flags & 2) != 0)) ||\n         (((flags & 1) != 0 && ((section_flags & 2) != 0)))) {\n        error_message = dcgettext(0,\"error: %s both copied and removed\",5);\n                    \n        fatal(error_message,section_name);\n      }\n      if ((((section_flags & 8) != 0) && ((flags & 0x10) != 0)) || ((flags & 0x18) == 0x18)) {\n        error_message = dcgettext(0,\"error: %s both sets and alters VMA\",5);\n                    \n        fatal(error_message,section_name);\n      }\n      if ((((section_flags & 0x20) == 0) || ((flags & 0x40) == 0)) && ((flags & 0x60) != 0x60)) {\n        *(uint *)((long)previous_section + 0x14) = section_flags | flags;\n        return previous_section;\n      }\n      error_message = dcgettext(0,\"error: %s both sets and alters LMA\",5);\n                    \n      fatal(error_message,section_name);\n    }\n    previous_section = (long **)*previous_section;\n    if (previous_section == (long **)0x0) goto LAB_001142a9;\n    result = strcmp((char *)previous_section[1],(char *)section_name);\n    if (result == 0) goto LAB_001143cd;\n    next_section = (long **)*previous_section;\n    current_section = (long **)0x0;\n    if (next_section == (long **)0x0) goto LAB_001142a9;\nLAB_00114288:\n    do {\n      previous_section = current_section;\n      if (exact_match == '\\0') {\n        while (current_section = next_section, last_section = previous_section, next_section = current_section,\n              (flags & *(uint *)((long)current_section + 0x14)) != 0) {\n          current_pattern = current_section[1];\n          if (*(char *)current_pattern == '!') {\n            result = fnmatch((char *)((long)current_pattern + 1),(char *)section_name,0);\n            if (result == 0) goto LAB_0011438e;\n            next_section = (long **)*current_section;\n            if ((long **)*current_section == (long **)0x0) goto LAB_001142a1;\n          }\n          else {\n            result = fnmatch((char *)current_pattern,(char *)section_name,0);\n            if ((previous_section == (long **)0x0) && (result == 0)) {\n              previous_section = current_section;\n              next_section = (long **)*current_section;\n              if ((long **)*current_section == (long **)0x0) goto LAB_00114245;\n            }\n            else {\n              next_section = (long **)*current_section;\n              if ((long **)*current_section == (long **)0x0) goto LAB_00114212;\n            }\n          }\n        }\n      }\n      else {\n        result = strcmp((char *)next_section[1],(char *)section_name);\n        last_section = current_section;\n        previous_section = next_section;\n        if (result == 0) goto LAB_001143cd;\n      }\n      current_section = last_section;\n      next_section = (long **)*next_section;\n      previous_section = current_section;\n    } while (next_section != (long **)0x0);\nLAB_001142a1:\n    if (exact_match != '\\0') {\nLAB_001142a9:\n      current_section = (long **)xmalloc(0x30);\n      *(undefined (*) [16])(current_section + 3) = (undefined  [16])0x0;\n      *(undefined *)(current_section + 2) = 0;\n      *(uint *)((long)current_section + 0x14) = flags;\n      current_section[5] = (long *)0x0;\n      previous_section = current_section;\n      *current_section = (long *)change_sections;\n      change_sections = previous_section;\n      current_section[1] = section_name;\n      return current_section;\n    }\n  }\nLAB_00114212:\n  if (previous_section == (long **)0x0) {\n    return (long **)0x0;\n  }\nLAB_00114245:\n  *(undefined *)(previous_section + 2) = 1;\n  return previous_section;\n}\n\n",
            "called": [
                "dcgettext",
                "fnmatch",
                "find_section_list.cold",
                "xmalloc",
                "fatal",
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114190",
            "calling": [
                "main",
                "setup_section",
                "is_strip_section_1.isra.0",
                "handle_remove_section_option",
                "copy_relocations_in_section",
                "FUN_00107880",
                "setup_section.cold",
                "copy_section"
            ],
            "imported": false,
            "current_name": "find_matching_section_00114190"
        },
        "FUN_00116490": {
            "renaming": {
                "FUN_00116490": "extract_build_attribute_notes_00116490",
                "param_1": "param_compression_type",
                "param_2": "param_notes_size",
                "param_3": "param_notes_name",
                "param_4": "param_notes_offset",
                "uVar1": "var1",
                "uVar2": "var2",
                "uVar3": "var3",
                "bVar4": "var4",
                "puVar5": "var5",
                "iVar6": "var6",
                "lVar7": "var7",
                "uVar8": "var8",
                "in_RAX": "var_in_RAX",
                "uVar9": "var9",
                "uVar10": "var10",
                "uVar11": "var11",
                "uVar12": "var12",
                "__ptr": "ptr",
                "uVar13": "var13",
                "unaff_RBX": "var_unaff_RBX",
                "unaff_RBP": "var_unaff_RBP",
                "puVar14": "var14",
                "puVar15": "var15",
                "cVar16": "var16",
                "puVar17": "var17",
                "puVar18": "var18",
                "in_R11": "var_in_R11",
                "unaff_R12": "var_unaff_R12",
                "puVar19": "var19",
                "unaff_R13": "var_unaff_R13",
                "__nmemb": "nmemb",
                "unaff_R14": "var_unaff_R14",
                "puVar20": "var20",
                "bVar21": "var21",
                "iVar22": "var22",
                "unaff_retaddr": "var_unaff_retaddr",
                "param_7": "param_compression_level",
                "param_8": "param_flag1",
                "param_9": "param_flag2",
                "in_stack_00000020": "var_in_stack_20",
                "in_stack_00000028": "var_in_stack_28",
                "in_stack_00000030": "var_in_stack_30",
                "in_stack_00000038": "var_in_stack_38",
                "in_stack_00000040": "var_in_stack_40",
                "in_stack_00000048": "var_in_stack_48"
            },
            "code": "\nulong extractBuildAttributeNotes_00116490(undefined8 param_compression_type,ulong param_notes_size,ulong param_notes_name,long param_notes_offset)\n\n{\n  undefined8 var1;\n  undefined8 var2;\n  ulong var3;\n  bool var4;\n  ulong *var5;\n  int var6;\n  long var7;\n  undefined8 var8;\n  ulong var_in_RAX;\n  ulong var9;\n  ulong var10;\n  ulong var11;\n  ulong var12;\n  undefined *ptr;\n  ulong var13;\n  ulong var_unaff_RBX;\n  ulong var_unaff_RBP;\n  ulong *var14;\n  undefined *var15;\n  char var16;\n  undefined *var17;\n  undefined *var18;\n  ulong var_in_R11;\n  ulong *var_unaff_R12;\n  ulong *var19;\n  ulong var_unaff_R13;\n  size_t nmemb;\n  undefined8 *var_unaff_R14;\n  ulong *var20;\n  byte var21;\n  int var22;\n  ulong var_unaff_retaddr;\n  ulong param_compression_level;\n  uint param_flag1;\n  ulong param_flag2;\n  ulong var_in_stack_20;\n  ulong *var_in_stack_28;\n  undefined *var_in_stack_30;\n  uint var_in_stack_38;\n  uint var_in_stack_40;\n  undefined8 *var_in_stack_48;\n  \n  var21 = 0;\ncode_r0x00116490:\n  var7 = param_notes_offset;\n  var10 = var_unaff_RBP;\n  var13 = var_unaff_R13;\n  if (var_in_RAX == 0) {\n    if (param_notes_size == 0x100) {\n      var_unaff_R12[7] = var_unaff_retaddr;\n      var11 = var_unaff_retaddr;\nLAB_001164af:\n      var9 = var_unaff_R13;\n      var13 = var_unaff_R13;\n      var_unaff_retaddr = var11;\n    }\n    else {\n      var_unaff_R12[7] = param_flag2;\nLAB_0011669e:\n      var10 = var_unaff_RBP;\n      var9 = var_unaff_RBP;\n    }\nLAB_001164bb:\n    var_unaff_R12[8] = var9;\n    if (*(char *)((var_unaff_R12[3] - 1) + param_notes_name) != '\\0') {\n      var7 = dcgettext(0,\"corrupt GNU build attribute note: name not NUL terminated\",5);\n      goto LAB_0010849a;\n    }\n    var19 = var_unaff_R12 + 9;\n    if (0xb < var_unaff_RBX) {\n      var9 = (**(code **)(var_unaff_R14[1] + 0x40))(var7);\n      *var19 = var9;\n      var9 = (**(code **)(var_unaff_R14[1] + 0x40))(var7 + 4);\n      var_unaff_R12[10] = var9;\n      param_notes_size = (**(code **)(var_unaff_R14[1] + 0x40))(var7 + 8);\n      param_notes_name = *var19;\n      var_unaff_R12[0xb] = param_notes_size;\n      var_in_RAX = var_unaff_R12[10];\n      var9 = param_notes_name + 3 & 0xfffffffffffffffc;\n      var_unaff_R12[0xf] = var9;\n      if (var_in_RAX != (var_in_RAX + 3 & 0xfffffffffffffffc)) {\n        var7 = dcgettext(0,\"corrupt GNU build attribute note: description size not a factor of 4\",5\n                         );\n        goto LAB_0010849a;\n      }\n      if (1 < param_notes_size - 0x100) {\n        var7 = dcgettext(0,\"corrupt GNU build attribute note: wrong note type\",5);\n        goto LAB_0010849a;\n      }\n      var11 = var9 + var_in_RAX + 0xc;\n      if (var_unaff_RBX < var11) {\n        var7 = dcgettext(0,\"corrupt GNU build attribute note: note too big\",5);\n        goto LAB_0010849a;\n      }\n      if (param_notes_name < 2) {\n        var7 = dcgettext(0,\"corrupt GNU build attribute note: name too small\",5);\n        goto LAB_0010849a;\n      }\n      var_unaff_R12[0xc] = var7 + 0xc;\n      var_in_R11 = var7 + 0xc + var9;\n      var_unaff_R12[0xd] = var_in_R11;\n      var_unaff_RBX = var_unaff_RBX + (-0xc - (var9 + var_in_RAX));\n      param_notes_offset = var7 + var11;\n      var_unaff_RBP = var10;\n      var_unaff_R12 = var19;\n      var_unaff_R13 = var13;\n      if (param_notes_name != 2) {\n        if (*(char *)(var7 + 0xc) == '$') {\n          if ((*(char *)(var7 + 0xd) == '\\x01') && (*(char *)(var7 + 0xe) == '1')) {\n            var10 = extractBuildAttributeNotes_00116490();\n            return var10;\n          }\n        }\n        else if ((((4 < param_notes_name) && (*(char *)(var7 + 0xc) == 'G')) &&\n                 (*(char *)(var7 + 0xd) == 'A')) &&\n                ((*(char *)(var7 + 0xe) == '$' && (*(char *)(var7 + 0xf) == '\\x01')))) {\n          if (*(char *)(var7 + 0x10) == '2') {\n            var10 = extractBuildAttributeNotes_00116490();\n            return var10;\n          }\n          if (*(char *)(var7 + 0x10) == '3') {\n            var10 = extractBuildAttributeNotes_00116490();\n            return var10;\n          }\n          var7 = dcgettext(0,\"corrupt GNU build attribute note: unsupported version\",5);\n          goto LAB_0010849a;\n        }\n      }\n      goto code_r0x00116490;\n    }\n    if (var_unaff_RBX != 0) {\n      var7 = dcgettext(0,\"corrupt GNU build attribute notes: excess data at end\",5);\n      goto LAB_0010849a;\n    }\n    if ((var_in_stack_38 | var_in_stack_40 | param_flag1) == 0) {\n      var1 = *var_unaff_R14;\n      var2 = *var_in_stack_48;\n      var8 = dcgettext(0,\"%s[%s]: Warning: version note missing - assuming version 3\",5);\n      non_fatal(var8,var1,var2);\nLAB_0011671b:\n      nmemb = ((long)var19 - (long)var_in_stack_28 >> 3) * -0x71c71c71c71c71c7;\n      qsort(var_in_stack_28,nmemb,0x48,compare_gnu_build_notes);\n      for (var14 = var_in_stack_28; var14 < var19; var14 = var14 + 9) {\n        var10 = var14[2];\n        if (var10 != 0) {\n          var13 = var14[7];\n          var9 = var14[8];\n          var20 = var14;\n          var22 = 0;\n          if (var13 == var9) {\n            var14[2] = 0;\n          }\n          else {\n            do {\n              do {\n                var5 = var20;\n                var20 = var5 + -9;\n                if (var20 < var_in_stack_28) goto LAB_001167f5;\n                var11 = var5[-7];\n              } while (var11 == 0);\n              if ((*var20 != *var14) ||\n                 (var6 = memcmp((void *)var5[-6],(void *)var14[3],*var14), var6 != 0))\n              break;\n              var3 = var5[-2];\n              var12 = var5[-1];\n              if (var13 == var3) {\n                if (var9 == var12) {\n                  var14[2] = 0;\n                  break;\n                }\nLAB_001167a6:\n                if (var9 <= var12) {\n                  var14[2] = 0;\n                  break;\n                }\n                if (var12 < var13) {\nLAB_0010852c:\n                  if ((0xfffffffffffffff0 < var12) ||\n                     (var13 <= (var12 + 0xf & 0xfffffffffffffff0))) goto process_build_notes_00116852;\n                }\nLAB_001167b8:\n                if ((var10 == 0x101) == (var11 == 0x101)) {\n                  if (var12 <= var9) {\n                    var12 = var9;\n                  }\n                  if (var3 < var13) {\n                    var13 = var3;\n                  }\n                  var5[-1] = var12;\n                  var5[-2] = var13;\n                  var14[2] = 0;\n                  break;\n                }\n              }\n              else {\n                if (var3 <= var13) goto LAB_001167a6;\n                if (var12 < var13) goto LAB_0010852c;\n                if (var9 < var13) {\n                  if ((0xfffffffffffffff0 < var9) || (var3 <= (var9 + 0xf & 0xfffffffffffffff0)))\n                  goto process_build_notes_00116852;\n                  goto LAB_001167b8;\n                }\n                if (var9 != var12) goto LAB_001167b8;\n              }\nprocess_build_notes_00116852:\n              var4 = var22 < 0x11;\n              var22 = var22 + 1;\n            } while (var4);\n          }\n        }\nLAB_001167f5:\n      }\n      qsort(var_in_stack_28,nmemb,0x48,sort_gnu_build_notes);\n      ptr = (undefined *)xmalloc(var_in_stack_20 * 2);\n      param_compression_level = 0;\n      param_flag2 = 0;\n      var18 = ptr;\n      for (var14 = var_in_stack_28; var14 < var19; var14 = var14 + 9) {\n        if (var14[2] != 0) {\n          var17 = var18 + 4;\n          var15 = var18 + 0xc;\n          if ((var14[7] == param_flag2) && (var14[8] == param_compression_level)) {\n            (**(code **)(var_unaff_R14[1] + 0x50))(*var14,var18);\n            (**(code **)(var_unaff_R14[1] + 0x50))(0,var17);\n            (**(code **)(var_unaff_R14[1] + 0x50))(var14[2],var18 + 8);\n            var13 = var14[6];\n            var10 = *var14;\n            var18 = (undefined *)var14[3];\n            var17 = var15;\n            for (var9 = var10; var9 != 0; var9 = var9 - 1) {\n              *var17 = *var18;\n              var18 = var18 + (ulong)var21 * -2 + 1;\n              var17 = var17 + (ulong)var21 * -2 + 1;\n            }\n            if (var10 < var13) {\n              for (var7 = var13 - var10; var7 != 0; var7 = var7 + -1) {\n                *var17 = 0;\n                var17 = var17 + (ulong)var21 * -2 + 1;\n              }\n            }\n            var18 = var15 + var13;\n          }\n          else {\n            (**(code **)(var_unaff_R14[1] + 0x50))();\n            if (*(int *)(var_unaff_R14[1] + 8) == 5) {\n              var16 = (*(char *)(var_unaff_R14[0x22] + 4) == '\\x02') * '\\b' + '\\b';\n            }\n            else {\n              var16 = '\\b';\n            }\n            (**(code **)(var_unaff_R14[1] + 0x50))(var16,var17);\n            (**(code **)(var_unaff_R14[1] + 0x50))(var14[2],var18 + 8);\n            var10 = *var14;\n            var18 = (undefined *)var14[3];\n            var17 = var15;\n            for (var13 = var10; var13 != 0; var13 = var13 - 1) {\n              *var17 = *var18;\n              var18 = var18 + (ulong)var21 * -2 + 1;\n              var17 = var17 + (ulong)var21 * -2 + 1;\n            }\n            var13 = var14[6];\n            if (var10 < var13) {\n              for (var7 = var13 - var10; var7 != 0; var7 = var7 + -1) {\n                *var17 = 0;\n                var17 = var17 + (ulong)var21 * -2 + 1;\n              }\n            }\n            var7 = var_unaff_R14[1];\n            var15 = var15 + var13;\n            var18 = var15 + 8;\n            if ((*(int *)(var7 + 8) == 5) && (*(char *)(var_unaff_R14[0x22] + 4) == '\\x02')) {\n              (**(code **)(var7 + 0x38))(var14[7],var15);\n              (**(code **)(var_unaff_R14[1] + 0x38))(var14[8],var18);\n              var18 = var15 + 0x10;\n            }\n            else {\n              (**(code **)(var7 + 0x50))(var14[7],var15);\n              (**(code **)(var_unaff_R14[1] + 0x50))(var14[8],var15 + 4);\n            }\n            param_flag2 = var14[7];\n            param_compression_level = var14[8];\n          }\n        }\n      }\n      var13 = (long)var18 - (long)ptr;\n      var10 = var13;\n      var18 = ptr;\n      if (var13 < var_in_stack_20) {\n        for (; var_in_stack_20 = var13, var10 != 0; var10 = var10 - 1) {\n          *var_in_stack_30 = *var18;\n          var18 = var18 + (ulong)var21 * -2 + 1;\n          var_in_stack_30 = var_in_stack_30 + (ulong)var21 * -2 + 1;\n        }\n      }\n      free(ptr);\nLAB_001166f8:\n      free(var_in_stack_28);\n      return var_in_stack_20;\n    }\n    if (((var_in_stack_40 | param_flag1) == 0) || (var_in_stack_38 == 0)) {\n      if (var_in_stack_40 == 0) {\n        if (param_flag1 != 0) goto LAB_0011671b;\n        goto LAB_001166f8;\n      }\n      if (param_flag1 == 0) goto LAB_001166f8;\n    }\n    var7 = dcgettext(0,\"bad GNU build attribute notes: multiple different versions\",5);\n  }\n  else {\n    if (var_in_RAX == 0x10) {\n      var11 = (**(code **)(var_unaff_R14[1] + 0x28))(var_in_R11);\n      var9 = (**(code **)(var_unaff_R14[1] + 0x28))(var_unaff_R12[4] + 8);\n      if (var9 < var11) {\n        var11 = var9;\n      }\nLAB_00116631:\n      if (var_unaff_R12[2] == 0x100) {\n        if (var11 == 0) {\n          var11 = var_unaff_retaddr;\n        }\n        param_notes_name = *var_unaff_R12;\n        var_unaff_R12[7] = var11;\n        var13 = var9;\n        var_unaff_retaddr = var11;\n        if (var9 == 0) goto LAB_001164af;\n      }\n      else {\n        if (var11 == 0) {\n          var11 = param_flag2;\n        }\n        param_notes_name = *var_unaff_R12;\n        var_unaff_R12[7] = var11;\n        var10 = var9;\n        param_flag2 = var11;\n        if (var9 == 0) goto LAB_0011669e;\n      }\n      goto LAB_001164bb;\n    }\n    if (var_in_RAX < 0x11) {\n      if (var_in_RAX == 4) {\n        var11 = (**(code **)(var_unaff_R14[1] + 0x40))(var_in_R11);\n        var9 = 0xffffffffffffffff;\n        goto LAB_00116631;\n      }\n      if (var_in_RAX == 8) {\n        var10 = FUNC_001086af();\n        return var10;\n      }\n    }\n    var7 = dcgettext(0,\"corrupt GNU build attribute note: bad description size\",5);\n  }\nLAB_0010849a:\n  if (var7 != 0) {\n    bfd_set_error(0x11);\n    bfd_nonfatal_message(0,var_unaff_R14,var_in_stack_48,var7);\n    status = 1;\n  }\n  goto LAB_001166f8;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_001086af"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116490",
            "calling": [
                "FUN_001086af",
                "merge_gnu_build_notes.cold"
            ],
            "imported": false,
            "current_name": "extract_build_attribute_notes_00116490",
            "code_backup": "\nulong FUN_00116490(undefined8 param_1,ulong param_2,ulong param_3,long param_4)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  ulong uVar3;\n  bool bVar4;\n  ulong *puVar5;\n  int iVar6;\n  long lVar7;\n  undefined8 uVar8;\n  ulong in_RAX;\n  ulong uVar9;\n  ulong uVar10;\n  ulong uVar11;\n  ulong uVar12;\n  undefined *__ptr;\n  ulong uVar13;\n  ulong unaff_RBX;\n  ulong unaff_RBP;\n  ulong *puVar14;\n  undefined *puVar15;\n  char cVar16;\n  undefined *puVar17;\n  undefined *puVar18;\n  ulong in_R11;\n  ulong *unaff_R12;\n  ulong *puVar19;\n  ulong unaff_R13;\n  size_t __nmemb;\n  undefined8 *unaff_R14;\n  ulong *puVar20;\n  byte bVar21;\n  int iVar22;\n  ulong unaff_retaddr;\n  ulong param_7;\n  uint param_8;\n  ulong param_9;\n  ulong in_stack_00000020;\n  ulong *in_stack_00000028;\n  undefined *in_stack_00000030;\n  uint in_stack_00000038;\n  uint in_stack_00000040;\n  undefined8 *in_stack_00000048;\n  \n  bVar21 = 0;\ncode_r0x00116490:\n  lVar7 = param_4;\n  uVar10 = unaff_RBP;\n  uVar13 = unaff_R13;\n  if (in_RAX == 0) {\n    if (param_2 == 0x100) {\n      unaff_R12[7] = unaff_retaddr;\n      uVar11 = unaff_retaddr;\nLAB_001164af:\n      uVar9 = unaff_R13;\n      uVar13 = unaff_R13;\n      unaff_retaddr = uVar11;\n    }\n    else {\n      unaff_R12[7] = param_9;\nLAB_0011669e:\n      uVar10 = unaff_RBP;\n      uVar9 = unaff_RBP;\n    }\nLAB_001164bb:\n    unaff_R12[8] = uVar9;\n    if (*(char *)((unaff_R12[3] - 1) + param_3) != '\\0') {\n      lVar7 = dcgettext(0,\"corrupt GNU build attribute note: name not NUL terminated\",5);\n      goto LAB_0010849a;\n    }\n    puVar19 = unaff_R12 + 9;\n    if (0xb < unaff_RBX) {\n      uVar9 = (**(code **)(unaff_R14[1] + 0x40))(lVar7);\n      *puVar19 = uVar9;\n      uVar9 = (**(code **)(unaff_R14[1] + 0x40))(lVar7 + 4);\n      unaff_R12[10] = uVar9;\n      param_2 = (**(code **)(unaff_R14[1] + 0x40))(lVar7 + 8);\n      param_3 = *puVar19;\n      unaff_R12[0xb] = param_2;\n      in_RAX = unaff_R12[10];\n      uVar9 = param_3 + 3 & 0xfffffffffffffffc;\n      unaff_R12[0xf] = uVar9;\n      if (in_RAX != (in_RAX + 3 & 0xfffffffffffffffc)) {\n        lVar7 = dcgettext(0,\"corrupt GNU build attribute note: description size not a factor of 4\",5\n                         );\n        goto LAB_0010849a;\n      }\n      if (1 < param_2 - 0x100) {\n        lVar7 = dcgettext(0,\"corrupt GNU build attribute note: wrong note type\",5);\n        goto LAB_0010849a;\n      }\n      uVar11 = uVar9 + in_RAX + 0xc;\n      if (unaff_RBX < uVar11) {\n        lVar7 = dcgettext(0,\"corrupt GNU build attribute note: note too big\",5);\n        goto LAB_0010849a;\n      }\n      if (param_3 < 2) {\n        lVar7 = dcgettext(0,\"corrupt GNU build attribute note: name too small\",5);\n        goto LAB_0010849a;\n      }\n      unaff_R12[0xc] = lVar7 + 0xc;\n      in_R11 = lVar7 + 0xc + uVar9;\n      unaff_R12[0xd] = in_R11;\n      unaff_RBX = unaff_RBX + (-0xc - (uVar9 + in_RAX));\n      param_4 = lVar7 + uVar11;\n      unaff_RBP = uVar10;\n      unaff_R12 = puVar19;\n      unaff_R13 = uVar13;\n      if (param_3 != 2) {\n        if (*(char *)(lVar7 + 0xc) == '$') {\n          if ((*(char *)(lVar7 + 0xd) == '\\x01') && (*(char *)(lVar7 + 0xe) == '1')) {\n            uVar10 = FUN_00116490();\n            return uVar10;\n          }\n        }\n        else if ((((4 < param_3) && (*(char *)(lVar7 + 0xc) == 'G')) &&\n                 (*(char *)(lVar7 + 0xd) == 'A')) &&\n                ((*(char *)(lVar7 + 0xe) == '$' && (*(char *)(lVar7 + 0xf) == '\\x01')))) {\n          if (*(char *)(lVar7 + 0x10) == '2') {\n            uVar10 = FUN_00116490();\n            return uVar10;\n          }\n          if (*(char *)(lVar7 + 0x10) == '3') {\n            uVar10 = FUN_00116490();\n            return uVar10;\n          }\n          lVar7 = dcgettext(0,\"corrupt GNU build attribute note: unsupported version\",5);\n          goto LAB_0010849a;\n        }\n      }\n      goto code_r0x00116490;\n    }\n    if (unaff_RBX != 0) {\n      lVar7 = dcgettext(0,\"corrupt GNU build attribute notes: excess data at end\",5);\n      goto LAB_0010849a;\n    }\n    if ((in_stack_00000038 | in_stack_00000040 | param_8) == 0) {\n      uVar1 = *unaff_R14;\n      uVar2 = *in_stack_00000048;\n      uVar8 = dcgettext(0,\"%s[%s]: Warning: version note missing - assuming version 3\",5);\n      non_fatal(uVar8,uVar1,uVar2);\nLAB_0011671b:\n      __nmemb = ((long)puVar19 - (long)in_stack_00000028 >> 3) * -0x71c71c71c71c71c7;\n      qsort(in_stack_00000028,__nmemb,0x48,compare_gnu_build_notes);\n      for (puVar14 = in_stack_00000028; puVar14 < puVar19; puVar14 = puVar14 + 9) {\n        uVar10 = puVar14[2];\n        if (uVar10 != 0) {\n          uVar13 = puVar14[7];\n          uVar9 = puVar14[8];\n          puVar20 = puVar14;\n          iVar22 = 0;\n          if (uVar13 == uVar9) {\n            puVar14[2] = 0;\n          }\n          else {\n            do {\n              do {\n                puVar5 = puVar20;\n                puVar20 = puVar5 + -9;\n                if (puVar20 < in_stack_00000028) goto LAB_001167f5;\n                uVar11 = puVar5[-7];\n              } while (uVar11 == 0);\n              if ((*puVar20 != *puVar14) ||\n                 (iVar6 = memcmp((void *)puVar5[-6],(void *)puVar14[3],*puVar14), iVar6 != 0))\n              break;\n              uVar3 = puVar5[-2];\n              uVar12 = puVar5[-1];\n              if (uVar13 == uVar3) {\n                if (uVar9 == uVar12) {\n                  puVar14[2] = 0;\n                  break;\n                }\nLAB_001167a6:\n                if (uVar9 <= uVar12) {\n                  puVar14[2] = 0;\n                  break;\n                }\n                if (uVar12 < uVar13) {\nLAB_0010852c:\n                  if ((0xfffffffffffffff0 < uVar12) ||\n                     (uVar13 <= (uVar12 + 0xf & 0xfffffffffffffff0))) goto process_build_notes_00116852;\n                }\nLAB_001167b8:\n                if ((uVar10 == 0x101) == (uVar11 == 0x101)) {\n                  if (uVar12 <= uVar9) {\n                    uVar12 = uVar9;\n                  }\n                  if (uVar3 < uVar13) {\n                    uVar13 = uVar3;\n                  }\n                  puVar5[-1] = uVar12;\n                  puVar5[-2] = uVar13;\n                  puVar14[2] = 0;\n                  break;\n                }\n              }\n              else {\n                if (uVar3 <= uVar13) goto LAB_001167a6;\n                if (uVar12 < uVar13) goto LAB_0010852c;\n                if (uVar9 < uVar13) {\n                  if ((0xfffffffffffffff0 < uVar9) || (uVar3 <= (uVar9 + 0xf & 0xfffffffffffffff0)))\n                  goto process_build_notes_00116852;\n                  goto LAB_001167b8;\n                }\n                if (uVar9 != uVar12) goto LAB_001167b8;\n              }\nprocess_build_notes_00116852:\n              bVar4 = iVar22 < 0x11;\n              iVar22 = iVar22 + 1;\n            } while (bVar4);\n          }\n        }\nLAB_001167f5:\n      }\n      qsort(in_stack_00000028,__nmemb,0x48,sort_gnu_build_notes);\n      __ptr = (undefined *)xmalloc(in_stack_00000020 * 2);\n      param_7 = 0;\n      param_9 = 0;\n      puVar18 = __ptr;\n      for (puVar14 = in_stack_00000028; puVar14 < puVar19; puVar14 = puVar14 + 9) {\n        if (puVar14[2] != 0) {\n          puVar17 = puVar18 + 4;\n          puVar15 = puVar18 + 0xc;\n          if ((puVar14[7] == param_9) && (puVar14[8] == param_7)) {\n            (**(code **)(unaff_R14[1] + 0x50))(*puVar14,puVar18);\n            (**(code **)(unaff_R14[1] + 0x50))(0,puVar17);\n            (**(code **)(unaff_R14[1] + 0x50))(puVar14[2],puVar18 + 8);\n            uVar13 = puVar14[6];\n            uVar10 = *puVar14;\n            puVar18 = (undefined *)puVar14[3];\n            puVar17 = puVar15;\n            for (uVar9 = uVar10; uVar9 != 0; uVar9 = uVar9 - 1) {\n              *puVar17 = *puVar18;\n              puVar18 = puVar18 + (ulong)bVar21 * -2 + 1;\n              puVar17 = puVar17 + (ulong)bVar21 * -2 + 1;\n            }\n            if (uVar10 < uVar13) {\n              for (lVar7 = uVar13 - uVar10; lVar7 != 0; lVar7 = lVar7 + -1) {\n                *puVar17 = 0;\n                puVar17 = puVar17 + (ulong)bVar21 * -2 + 1;\n              }\n            }\n            puVar18 = puVar15 + uVar13;\n          }\n          else {\n            (**(code **)(unaff_R14[1] + 0x50))();\n            if (*(int *)(unaff_R14[1] + 8) == 5) {\n              cVar16 = (*(char *)(unaff_R14[0x22] + 4) == '\\x02') * '\\b' + '\\b';\n            }\n            else {\n              cVar16 = '\\b';\n            }\n            (**(code **)(unaff_R14[1] + 0x50))(cVar16,puVar17);\n            (**(code **)(unaff_R14[1] + 0x50))(puVar14[2],puVar18 + 8);\n            uVar10 = *puVar14;\n            puVar18 = (undefined *)puVar14[3];\n            puVar17 = puVar15;\n            for (uVar13 = uVar10; uVar13 != 0; uVar13 = uVar13 - 1) {\n              *puVar17 = *puVar18;\n              puVar18 = puVar18 + (ulong)bVar21 * -2 + 1;\n              puVar17 = puVar17 + (ulong)bVar21 * -2 + 1;\n            }\n            uVar13 = puVar14[6];\n            if (uVar10 < uVar13) {\n              for (lVar7 = uVar13 - uVar10; lVar7 != 0; lVar7 = lVar7 + -1) {\n                *puVar17 = 0;\n                puVar17 = puVar17 + (ulong)bVar21 * -2 + 1;\n              }\n            }\n            lVar7 = unaff_R14[1];\n            puVar15 = puVar15 + uVar13;\n            puVar18 = puVar15 + 8;\n            if ((*(int *)(lVar7 + 8) == 5) && (*(char *)(unaff_R14[0x22] + 4) == '\\x02')) {\n              (**(code **)(lVar7 + 0x38))(puVar14[7],puVar15);\n              (**(code **)(unaff_R14[1] + 0x38))(puVar14[8],puVar18);\n              puVar18 = puVar15 + 0x10;\n            }\n            else {\n              (**(code **)(lVar7 + 0x50))(puVar14[7],puVar15);\n              (**(code **)(unaff_R14[1] + 0x50))(puVar14[8],puVar15 + 4);\n            }\n            param_9 = puVar14[7];\n            param_7 = puVar14[8];\n          }\n        }\n      }\n      uVar13 = (long)puVar18 - (long)__ptr;\n      uVar10 = uVar13;\n      puVar18 = __ptr;\n      if (uVar13 < in_stack_00000020) {\n        for (; in_stack_00000020 = uVar13, uVar10 != 0; uVar10 = uVar10 - 1) {\n          *in_stack_00000030 = *puVar18;\n          puVar18 = puVar18 + (ulong)bVar21 * -2 + 1;\n          in_stack_00000030 = in_stack_00000030 + (ulong)bVar21 * -2 + 1;\n        }\n      }\n      free(__ptr);\nLAB_001166f8:\n      free(in_stack_00000028);\n      return in_stack_00000020;\n    }\n    if (((in_stack_00000040 | param_8) == 0) || (in_stack_00000038 == 0)) {\n      if (in_stack_00000040 == 0) {\n        if (param_8 != 0) goto LAB_0011671b;\n        goto LAB_001166f8;\n      }\n      if (param_8 == 0) goto LAB_001166f8;\n    }\n    lVar7 = dcgettext(0,\"bad GNU build attribute notes: multiple different versions\",5);\n  }\n  else {\n    if (in_RAX == 0x10) {\n      uVar11 = (**(code **)(unaff_R14[1] + 0x28))(in_R11);\n      uVar9 = (**(code **)(unaff_R14[1] + 0x28))(unaff_R12[4] + 8);\n      if (uVar9 < uVar11) {\n        uVar11 = uVar9;\n      }\nLAB_00116631:\n      if (unaff_R12[2] == 0x100) {\n        if (uVar11 == 0) {\n          uVar11 = unaff_retaddr;\n        }\n        param_3 = *unaff_R12;\n        unaff_R12[7] = uVar11;\n        uVar13 = uVar9;\n        unaff_retaddr = uVar11;\n        if (uVar9 == 0) goto LAB_001164af;\n      }\n      else {\n        if (uVar11 == 0) {\n          uVar11 = param_9;\n        }\n        param_3 = *unaff_R12;\n        unaff_R12[7] = uVar11;\n        uVar10 = uVar9;\n        param_9 = uVar11;\n        if (uVar9 == 0) goto LAB_0011669e;\n      }\n      goto LAB_001164bb;\n    }\n    if (in_RAX < 0x11) {\n      if (in_RAX == 4) {\n        uVar11 = (**(code **)(unaff_R14[1] + 0x40))(in_R11);\n        uVar9 = 0xffffffffffffffff;\n        goto LAB_00116631;\n      }\n      if (in_RAX == 8) {\n        uVar10 = FUNC_001086af();\n        return uVar10;\n      }\n    }\n    lVar7 = dcgettext(0,\"corrupt GNU build attribute note: bad description size\",5);\n  }\nLAB_0010849a:\n  if (lVar7 != 0) {\n    bfd_set_error(0x11);\n    bfd_nonfatal_message(0,unaff_R14,in_stack_00000048,lVar7);\n    status = 1;\n  }\n  goto LAB_001166f8;\n}\n\n"
        },
        "FUN_00128118": {
            "renaming": {},
            "code": "\n\n\n\nint fclose(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fclose@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128118",
            "calling": [
                "fclose"
            ],
            "imported": false,
            "current_name": "FUN_00128118"
        },
        "FUN_00104a35": {
            "renaming": {
                "FUN_00104a35": "print_supported_targets_00104a35",
                "param_1": "target",
                "param_2": "outputFile",
                "lVar1": "targetPtr",
                "pcVar2": "message",
                "__ptr": "targetList",
                "plVar3": "currentTarget"
            },
            "code": "\nvoid printSupportedTargets_00104a35(long target,FILE *outputFile)\n\n{\n  long targetPtr;\n  char *message;\n  long *targetList;\n  long *currentTarget;\n  \n  if (target == 0) {\n    message = (char *)dcgettext(0,\"Supported targets:\",5);\n    fprintf(outputFile,message);\n  }\n  else {\n    message = (char *)dcgettext(0,\"%s: supported targets:\",5);\n    fprintf(outputFile,message,target);\n  }\n  targetList = (long *)bfd_target_list();\n  currentTarget = targetList;\n  while( true ) {\n    targetPtr = *currentTarget;\n    currentTarget = currentTarget + 1;\n    if (targetPtr == 0) break;\n    fprintf(outputFile,\" %s\");\n  }\n  fputc(10,outputFile);\n  free(targetList);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fputc",
                "dcgettext",
                "bfd_target_list",
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104a35",
            "calling": [
                "strip_usage",
                "copy_usage"
            ],
            "imported": false,
            "current_name": "print_supported_targets_00104a35"
        },
        "FUN_001048d0": {
            "renaming": {},
            "code": "\nvoid bfd_fdopenw(void)\n\n{\n  bfd_fdopenw();\n  return;\n}\n\n",
            "called": [
                "bfd_fdopenw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048d0",
            "calling": [
                "copy_file"
            ],
            "imported": false,
            "current_name": "FUN_001048d0"
        },
        "FUN_0010be1a": {
            "renaming": {
                "FUN_0010be1a": "debug_end_function_0010be1a",
                "param_1": "function_info",
                "param_2": "new_function_addr",
                "param_3": "unused",
                "param_4": "return_value",
                "lVar1": "block_info",
                "uVar2": "error_message",
                "pcVar3": "error_string",
                "auVar4": "result"
            },
            "code": "\n\n\nundefined  [16] debug_end_function_0010be1a(long function_info,undefined8 new_function_addr,undefined8 unused,undefined8 return_value)\n\n{\n  long block_info;\n  undefined8 error_message;\n  char *error_string;\n  undefined result [16];\n  \n  if (((*(long *)(function_info + 8) == 0) || (block_info = *(long *)(function_info + 0x20), block_info == 0)) ||\n     (*(long *)(function_info + 0x18) == 0)) {\n    error_string = \"debug_end_function_0010be1a: no current function\";\n  }\n  else {\n    if (*(long *)(block_info + 8) == 0) {\n      *(undefined8 *)(block_info + 0x20) = new_function_addr;\n      error_message = CONCAT71((int7)((ulong)block_info >> 8),1);\n      *(undefined (*) [16])(function_info + 0x18) = ZEXT816(0);\n      goto LAB_0010be86;\n    }\n    error_string = \"debug_end_function_0010be1a: some blocks were not closed\";\n  }\n  error_message = dcgettext(0,error_string,5);\n  fprintf(_stderr,\"%s\\n\",error_message);\n  error_message = 0;\nLAB_0010be86:\n  result._8_8_ = return_value;\n  result._0_8_ = error_message;\n  return result;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010be1a",
            "calling": [
                "parse_stab",
                "FUN_0010554f",
                "finish_stab"
            ],
            "imported": false,
            "current_name": "debug_end_function_0010be1a"
        },
        "FUN_00104270": {
            "renaming": {},
            "code": "\n\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(__s);\n  return sVar1;\n}\n\n",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104270",
            "calling": [
                "stab_demangle_v3_arg",
                "display_info.isra.0.cold",
                "stab_variable.lto_priv.0",
                "stab_end_struct_type.lto_priv.0",
                "FUN_0010554f",
                "startswith.lto_priv.0.lto_priv.0",
                "stab_tag.lto_priv.0",
                "stab_typed_constant.lto_priv.0",
                "stab_struct_field.lto_priv.0",
                "stab_demangle_type.lto_priv.0",
                "stab_set_type.lto_priv.0",
                "stab_start_struct_type.lto_priv.0",
                "stab_typdef.lto_priv.0",
                "stab_int_constant.lto_priv.0",
                "main",
                "setup_section",
                "stab_enum_type.lto_priv.0",
                "stab_write_symbol.lto_priv.0",
                "stab_class_baseclass.lto_priv.0",
                "stab_demangle_qualified",
                "stab_class_start_method.lto_priv.0",
                "convert_efi_target",
                "stab_method_type.lto_priv.0",
                "stab_class_static_member.lto_priv.0",
                "stab_demangle_template",
                "display_info.isra.0",
                "write_stabs_in_sections_debugging_info.constprop.0",
                "bfd_get_archive_filename",
                "stab_function_parameter.lto_priv.0",
                "stab_function_type.lto_priv.0",
                "stab_start_class_type.lto_priv.0",
                "stab_range_type.lto_priv.0",
                "stab_class_end_method.lto_priv.0",
                "stab_int_type.lto_priv.0",
                "stab_array_type.lto_priv.0",
                "stab_offset_type.lto_priv.0",
                "stab_start_function.lto_priv.0",
                "stab_class_method_var",
                "parse_flags.cold",
                "parse_stab",
                "parse_stab_type",
                "stab_modify_type",
                "stab_float_constant.lto_priv.0",
                "stab_end_class_type.lto_priv.0",
                "is_dwo_section.constprop.0"
            ],
            "imported": false,
            "current_name": "FUN_00104270"
        },
        "FUN_00104150": {
            "renaming": {},
            "code": "\nvoid bfd_set_default_target(void)\n\n{\n  bfd_set_default_target();\n  return;\n}\n\n",
            "called": [
                "bfd_set_default_target"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104150",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00104150"
        },
        "FUN_00104390": {
            "renaming": {},
            "code": "\nvoid xmalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104390",
            "calling": [
                "merge_gnu_build_notes",
                "stab_variable.lto_priv.0",
                "add_redefine_and_check",
                "coff_get_slot.lto_priv.0",
                "find_section_list",
                "stab_struct_field.lto_priv.0",
                "savestring",
                "debug_set_class_id.lto_priv.0",
                "xstrndup",
                "stab_start_struct_type.lto_priv.0",
                "stab_int_constant.lto_priv.0",
                "main",
                "debug_name_type",
                "debug_make_array_type.isra.0",
                "convert_efi_target",
                "stab_demangle_args",
                "stab_method_type.lto_priv.0",
                "FUN_00104ea2",
                "display_info.isra.0",
                "copy_section",
                "add_specific_symbols",
                "bfd_get_archive_filename",
                "debug_make_enum_type.isra.0",
                "stab_function_type.lto_priv.0",
                "debug_record_function",
                "debug_add_to_namespace.constprop.0",
                "stab_range_type.lto_priv.0",
                "template_in_dir",
                "parse_coff_struct_type",
                "stab_start_function.lto_priv.0",
                "debug_start_block",
                "parse_flags.cold",
                "parse_stab",
                "debug_make_function_type.isra.0",
                "parse_stab_type",
                "debug_set_filename",
                "stab_modify_type",
                "FUN_00107880",
                "section_add_load_file",
                "debug_record_line",
                "stab_end_struct_type.lto_priv.0",
                "FUN_0010554f",
                "debug_record_variable",
                "stab_tag.lto_priv.0",
                "stab_typed_constant.lto_priv.0",
                "debug_make_indirect_type.isra.0",
                "stab_set_type.lto_priv.0",
                "init_section_add",
                "stab_typdef.lto_priv.0",
                "stab_demangle_v3_arglist",
                "setup_section",
                "stab_enum_type.lto_priv.0",
                "stab_class_baseclass.lto_priv.0",
                "debug_make_method_type.isra.0",
                "stab_class_start_method.lto_priv.0",
                "mark_symbols_used_in_relocations",
                "debug_make_offset_type.isra.0",
                "stab_class_static_member.lto_priv.0",
                "debug_make_struct_type.isra.0",
                "write_stabs_in_sections_debugging_info.constprop.0",
                "stab_find_slot",
                "stab_function_parameter.lto_priv.0",
                "stab_push_string",
                "stab_start_class_type.lto_priv.0",
                "FUN_00116852",
                "start_stab.constprop.0",
                "stab_find_tagged_type",
                "debug_make_type.constprop.0",
                "stab_array_type.lto_priv.0",
                "stab_offset_type.lto_priv.0",
                "stab_record_variable",
                "parse_coff_type.lto_priv.0",
                "debug_tag_type",
                "debug_start_source",
                "stab_float_constant.lto_priv.0",
                "stab_end_class_type.lto_priv.0",
                "debug_record_parameter"
            ],
            "imported": false,
            "current_name": "FUN_00104390"
        },
        "FUN_001047b0": {
            "renaming": {},
            "code": "\nvoid bfd_canonicalize_reloc(void)\n\n{\n  bfd_canonicalize_reloc();\n  return;\n}\n\n",
            "called": [
                "bfd_canonicalize_reloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047b0",
            "calling": [
                "merge_gnu_build_notes",
                "copy_relocations_in_section",
                "mark_symbols_used_in_relocations"
            ],
            "imported": false,
            "current_name": "FUN_001047b0"
        },
        "FUN_00128000": {
            "renaming": {},
            "code": "\n\n\n\nint mkstemps(char *__template,int __suffixlen)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mkstemps@GLIBC_2.11 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128000",
            "calling": [
                "mkstemps"
            ],
            "imported": false,
            "current_name": "FUN_00128000"
        },
        "FUN_00104030": {
            "renaming": {},
            "code": "\n\n\nint mkstemps(char *__template,int __suffixlen)\n\n{\n  int iVar1;\n  \n  iVar1 = mkstemps(__template,__suffixlen);\n  return iVar1;\n}\n\n",
            "called": [
                "mkstemps"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104030",
            "calling": [
                "display_info.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00104030"
        },
        "FUN_00113da9": {
            "renaming": {
                "FUN_00113da9": "initialize_debug_type_00113da9",
                "param_1": "byteCount",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "puVar1": "debugType",
                "lVar2": "loopCount",
                "puVar3": "ptr",
                "bVar4": "counter",
                "auVar5": "result"
            },
            "code": "\nundefined  [16] initializeDebugType_00113da9(byte byteCount,undefined8 param2,undefined8 param3,undefined8 param4)\n\n{\n  undefined8 *debugType;\n  long loopCount;\n  undefined8 *ptr;\n  byte counter;\n  undefined result [16];\n  \n  counter = 0;\n  result._0_8_ = debug_make_type_constprop_0(8 - (uint)byteCount);\n  if (result._0_8_ != 0) {\n    debugType = (undefined8 *)xmalloc(0x28);\n    ptr = debugType + 1;\n    for (loopCount = 8; loopCount != 0; loopCount = loopCount + -1) {\n      *(undefined4 *)ptr = 0;\n      ptr = (undefined8 *)((long)ptr + (ulong)counter * -8 + 4);\n    }\n    *debugType = param3;\n    *(undefined8 **)(result._0_8_ + 0x10) = debugType;\n  }\n  result._8_8_ = param4;\n  return result;\n}\n\n",
            "called": [
                "debug_make_type.constprop.0",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113da9",
            "calling": [
                "parse_coff_type.lto_priv.0",
                "parse_stab_type",
                "parse_coff_struct_type"
            ],
            "imported": false,
            "current_name": "initialize_debug_type_00113da9"
        },
        "FUN_0011a250": {
            "renaming": {
                "FUN_0011a250": "compare_records_0011a250",
                "param_1": "record1",
                "param_2": "record2",
                "uVar1": "record1_value",
                "param_1[2]": "record1_field2_value",
                "param_2[2]": "record2_field2_value",
                "param_2[7]": "record2_field7_value",
                "param_1[7]": "record1_field7_value",
                "param_2[8]": "record2_field8_value",
                "param_1[8]": "record1_field8_value",
                "param_1[3]": "record1_field3_address",
                "param_2[3]": "record2_field3_address"
            },
            "code": "\nint compare_records_0011a250(ulong *record1,ulong *record2)\n\n{\n  ulong record1_value;\n  \n  record1_value = record1_field2_value;\n  if (record1_value == record2_field2_value) {\n    if (record2_field7_value <= record1_field7_value) {\n      if (record1_field7_value <= record2_field7_value) {\n        if (record2_field8_value < record1_field8_value) {\n          return -1;\n        }\n        if (record2_field8_value <= record1_field8_value) {\n          if ((4 < *record1) && (4 < *record2)) {\n            if (*(char *)(record1_field3_address + 3) != *(char *)(record2_field3_address + 3)) {\n              return (int)*(char *)(record1_field3_address + 3) - (int)*(char *)(record2_field3_address + 3);\n            }\n          }\n          return 0;\n        }\n      }\n      return 1;\n    }\n  }\n  else if ((record1_value == 0) || ((record1_value != 0x100 && (record2_field2_value != 0)))) {\n    return 1;\n  }\n  return -1;\n}\n\n",
            "called": [
                "sort_gnu_build_notes.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a250",
            "calling": [
                "FUN_00116852"
            ],
            "imported": false,
            "current_name": "compare_records_0011a250"
        },
        "FUN_00128228": {
            "renaming": {},
            "code": "\n\n\n\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* read@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128228",
            "calling": [
                "read"
            ],
            "imported": false,
            "current_name": "FUN_00128228"
        },
        "FUN_0010a69a": {
            "renaming": {
                "FUN_0010a69a": "reverse_and_push_struct_0010a69a",
                "param_1": "data_ptr",
                "param_2": "struct_ptr",
                "param_3": "flag",
                "param_4": "char_input",
                "param_5": "uint_input",
                "uVar1": "result",
                "lVar2": "struct_index",
                "sVar3": "str_length",
                "uVar4": "allocated_ptr",
                "uVar5": "is_struct_index_valid",
                "local_60": "output_buffer"
            },
            "code": "\nundefined4 reverse_and_push_struct_0010a69a(long data_ptr,undefined8 struct_ptr,int flag,char char_input,uint uint_input)\n\n{\n  undefined4 result;\n  long struct_index;\n  size_t str_length;\n  undefined8 allocated_ptr;\n  undefined is_struct_index_valid;\n  char output_buffer [48];\n  \n  if (flag == 0) {\n    output_buffer[0] = '\\0';\n    is_struct_index_valid = 0;\n    struct_index = 0;\n  }\n  else {\n    struct_index = stab_get_struct_index();\n    if (struct_index < 0) {\n      return 0;\n    }\n    is_struct_index_valid = 1;\n    sprintf(output_buffer,\"%ld=\",struct_index);\n  }\n  str_length = strlen(output_buffer);\n  sprintf(output_buffer + str_length,\"%c%u\",(ulong)((-(uint)(char_input == '\\0') & 2) + 0x73),(ulong)uint_input);\n  result = stab_push_string(data_ptr,output_buffer,struct_index,is_struct_index_valid,uint_input);\n  if ((char)result == '\\0') {\n    return 0;\n  }\n  struct_index = *(long *)(data_ptr + 0x60);\n  allocated_ptr = xmalloc(1);\n  *(undefined8 *)(struct_index + 0x20) = allocated_ptr;\n  **(undefined **)(*(long *)(data_ptr + 0x60) + 0x20) = 0;\n  return result;\n}\n\n",
            "called": [
                "strlen",
                "stab_push_string",
                "sprintf",
                "stab_get_struct_index",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a69a",
            "calling": [
                "stab_start_class_type.lto_priv.0",
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "reverse_and_push_struct_0010a69a"
        },
        "FUN_001048e0": {
            "renaming": {},
            "code": "\nvoid bfd_seek(void)\n\n{\n  bfd_seek();\n  return;\n}\n\n",
            "called": [
                "bfd_seek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048e0",
            "calling": [
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "FUN_001048e0"
        },
        "FUN_001047c0": {
            "renaming": {},
            "code": "\n\n\nchar * strcat(char *__dest,char *__src)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strcat(__dest,__src);\n  return pcVar1;\n}\n\n",
            "called": [
                "strcat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047c0",
            "calling": [
                "setup_section",
                "parse_stab_type",
                "stab_end_class_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "FUN_001047c0"
        },
        "FUN_00104160": {
            "renaming": {},
            "code": "\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fread(__ptr,__size,__n,__stream);\n  return sVar1;\n}\n\n",
            "called": [
                "fread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104160",
            "calling": [
                "main",
                "FUN_00114dc7",
                "add_specific_symbols"
            ],
            "imported": false,
            "current_name": "FUN_00104160"
        },
        "FUN_00104040": {
            "renaming": {},
            "code": "\n\n\nchar * getenv(char *__name)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = getenv(__name);\n  return pcVar1;\n}\n\n",
            "called": [
                "getenv"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104040",
            "calling": [
                "display_info.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00104040"
        },
        "FUN_00104280": {
            "renaming": {},
            "code": "\nvoid getopt_long(void)\n\n{\n  getopt_long();\n  return;\n}\n\n",
            "called": [
                "getopt_long"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104280",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00104280"
        },
        "FUN_00115b70": {
            "renaming": {
                "FUN_00115b70": "check_and_process_sections_00115b70",
                "param_1": "section_names",
                "pcVar1": "current_section",
                "iVar2": "comparison_result",
                "iVar3": "strip_option",
                "lVar4": "section_1",
                "lVar5": "section_2",
                "uVar6": "result",
                "plVar7": "updated_sections"
            },
            "code": "\nundefined8 check_and_process_sections_00115b70(char **section_names)\n\n{\n  char *current_section;\n  int comparison_result;\n  int strip_option;\n  long section_1;\n  long section_2;\n  undefined8 result;\n  long *updated_sections;\n  \n  section_1 = find_section_list(*section_names,0,4);\n  if (section_1 == 0) {\n    if ((sections_removed != '\\0') || (sections_copied != '\\0')) {\n      section_1 = find_section_list(*section_names,0,1);\n      section_2 = find_section_list(*section_names,0,2);\n      if (section_1 != 0) {\n        if (section_2 != 0) {\n          current_section = *section_names;\n          result = dcgettext(0,\"error: section %s matches both remove and copy options\",5);\n                    \n          fatal(result,current_section);\n        }\n        if (section_1 != 0) {\n          if (update_sections == (long *)0x0) {\n            return 1;\n          }\n          current_section = *section_names;\n          updated_sections = update_sections;\n          do {\n            strip_option = strcmp(current_section,(char *)updated_sections[1]);\n            if (strip_option == 0) {\n              result = dcgettext(0,\"error: section %s matches both update and remove options\",5);\n                    \n              fatal(result,current_section);\n            }\n            updated_sections = (long *)*updated_sections;\n          } while (updated_sections != (long *)0x0);\n          return 1;\n        }\n      }\n      if ((sections_copied != '\\0') && (section_2 == 0)) {\n        return 1;\n      }\n    }\n    strip_option = strip_symbols;\n    if ((*(byte *)((long)section_names + 0x25) & 0x20) != 0) {\n      if ((((strip_symbols - 2U < 2) || (strip_symbols == 7)) || (discard_locals == 2)) ||\n         (convert_debugging != '\\0')) {\n        current_section = *section_names;\n        comparison_result = strcmp(current_section,\".gnu_debugaltlink\");\n        if ((comparison_result != 0) && (comparison_result = strcmp(current_section,\".gnu_debuglink\"), comparison_result != 0)) {\n          strip_option = strcmp(current_section,\".reloc\");\n          if (strip_option != 0) {\n            return 1;\n          }\n          result = process_ebp_value_0010829e();\n          return result;\n        }\n      }\n      if (strip_option == 5) {\n        result = is_dwo_section_constprop_0(section_names);\n        return result;\n      }\n      if (strip_option == 4) {\n        return 0;\n      }\n    }\n    if (strip_option == 6) {\n      result = invert_and_get_dwo_section_constprop_001082b3();\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "is_strip_section_1.isra.0.cold",
                "dcgettext",
                "find_section_list",
                "FUN_0010829e",
                "strcmp",
                "fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115b70",
            "calling": [
                "is_strip_section.isra.0"
            ],
            "imported": false,
            "current_name": "check_and_process_sections_00115b70"
        },
        "FUN_001046a0": {
            "renaming": {},
            "code": "\nvoid bfd_coff_get_syment(void)\n\n{\n  bfd_coff_get_syment();\n  return;\n}\n\n",
            "called": [
                "bfd_coff_get_syment"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001046a0",
            "calling": [
                "parse_coff_type.lto_priv.0",
                "FUN_0010554f",
                "parse_coff_struct_type"
            ],
            "imported": false,
            "current_name": "FUN_001046a0"
        },
        "FUN_00128358": {
            "renaming": {},
            "code": "\n\n\n\nint mkstemp(char *__template)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mkstemp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128358",
            "calling": [
                "mkstemp"
            ],
            "imported": false,
            "current_name": "FUN_00128358"
        },
        "FUN_00128230": {
            "renaming": {},
            "code": "\n\n\n\nint memcmp(void *__s1,void *__s2,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memcmp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128230",
            "calling": [
                "memcmp"
            ],
            "imported": false,
            "current_name": "FUN_00128230"
        },
        "FUN_00116b40": {
            "renaming": {
                "FUN_00116b40": "initialize_application_00116b40",
                "completed_0": "isInitialized",
                "__cxa_finalize": "finalizeConstruction",
                "__dso_handle": "constructionHandle",
                "deregister_tm_clones": "deregisterClones"
            },
            "code": "\nvoid initializeApplication_00116b40(void)\n\n{\n  if (isInitialized != '\\0') {\n    return;\n  }\n  finalizeConstruction(constructionHandle);\n  deregisterClones();\n  isInitialized = 1;\n  return;\n}\n\n",
            "called": [
                "deregister_tm_clones",
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116b40",
            "calling": [],
            "imported": false,
            "current_name": "initialize_application_00116b40"
        },
        "FUN_00116030": {
            "renaming": {
                "FUN_00116030": "process_relocation_00116030",
                "param_1": "param_array",
                "param_2": "param_length",
                "plVar1": "pointer_var",
                "lVar2": "long_var_2",
                "lVar3": "long_var_3",
                "lVar4": "long_var_4",
                "iVar5": "int_var",
                "in_RAX": "return_val",
                "lVar6": "upper_bound",
                "__ptr": "reloc_ptr",
                "lVar7": "result",
                "extraout_RAX": "return_val_extra",
                "lVar8": "loop_counter",
                "uStack_28": "stack_var"
            },
            "code": "\n\n\nundefined8 process_relocation_00116030(undefined8 *param_array,long param_length)\n\n{\n  long *pointer_var;\n  long long_var_2;\n  long long_var_3;\n  long long_var_4;\n  int int_var;\n  undefined8 return_val;\n  long upper_bound;\n  void *reloc_ptr;\n  long result;\n  undefined8 return_val_extra;\n  long loop_counter;\n  undefined8 stack_var;\n  \n  if (*(long *)(param_length + 0x60) == 0) {\n    return return_val;\n  }\n  upper_bound = bfd_get_reloc_upper_bound();\n  if (upper_bound < 0) {\n    if ((upper_bound != -1) || (int_var = bfd_get_error(), int_var != 5)) {\n      bfd_nonfatal(*param_array);\n                    \n      xexit(1);\n    }\n  }\n  else if (upper_bound != 0) {\n    reloc_ptr = (void *)xmalloc();\n    result = bfd_canonicalize_reloc(param_array,param_length,reloc_ptr);\n    long_var_4 = _DAT_00128680;\n    long_var_3 = _DAT_00128568;\n    upper_bound = _fwrite;\n    if (result < 0) {\n      bfd_nonfatal(*param_array);\n                    \n      xexit(1);\n    }\n    if (result != 0) {\n      loop_counter = 0;\n      do {\n        pointer_var = **(long ***)((long)reloc_ptr + loop_counter * 8);\n        if ((((pointer_var != (long *)0x0) && (long_var_2 = *pointer_var, long_var_2 != 0)) && (long_var_2 != upper_bound)) &&\n           ((long_var_2 != long_var_4 && (long_var_2 != long_var_3)))) {\n          *(uint *)(long_var_2 + 0x18) = *(uint *)(long_var_2 + 0x18) | 0x20;\n        }\n        loop_counter = loop_counter + 1;\n      } while (result != loop_counter);\n    }\n    free(reloc_ptr);\n    return return_val_extra;\n  }\n  return stack_var;\n}\n\n",
            "called": [
                "bfd_canonicalize_reloc",
                "xexit",
                "mark_symbols_used_in_relocations.cold",
                "fwrite",
                "bfd_get_reloc_upper_bound",
                "free",
                "xmalloc",
                "bfd_nonfatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116030",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "process_relocation_00116030"
        },
        "FUN_00128018": {
            "renaming": {},
            "code": "\n\n\n\nint utimensat(int __fd,char *__path,timespec *__times,int __flags)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* utimensat@GLIBC_2.6 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128018",
            "calling": [
                "utimensat"
            ],
            "imported": false,
            "current_name": "FUN_00128018"
        },
        "FUN_00113ede": {
            "renaming": {
                "FUN_00113ede": "check_prefix_string_00113ede",
                "param_1": "strings",
                "__s": "input_string",
                "sVar1": "string_length",
                "uVar2": "startswith_result"
            },
            "code": "\nundefined8 check_prefix_string_00113ede(char **strings)\n\n{\n  char *input_string;\n  size_t string_length;\n  undefined8 startswith_result;\n  \n  if (strings == (char **)0x0) {\n    return 0;\n  }\n  input_string = *strings;\n  if (input_string != (char *)0x0) {\n    string_length = strlen(input_string);\n    if (4 < (int)string_length) {\n      startswith_result = startswith_lto_priv_0_lto_priv_0(input_string + (long)(int)string_length + -4,&DAT_0012142b);\n      return startswith_result;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "strlen",
                "startswith.lto_priv.0.lto_priv.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113ede",
            "calling": [
                "FUN_001082b3",
                "FUN_0010829e"
            ],
            "imported": false,
            "current_name": "check_prefix_string_00113ede"
        },
        "FUN_001047d0": {
            "renaming": {},
            "code": "\nvoid htab_find(void)\n\n{\n  htab_find();\n  return;\n}\n\n",
            "called": [
                "htab_find"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047d0",
            "calling": [
                "add_redefine_and_check",
                "FUN_0010554f",
                "is_specified_symbol"
            ],
            "imported": false,
            "current_name": "FUN_001047d0"
        },
        "FUN_001046b0": {
            "renaming": {},
            "code": "\nvoid cplus_demangle(void)\n\n{\n  cplus_demangle();\n  return;\n}\n\n",
            "called": [
                "cplus_demangle"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001046b0",
            "calling": [
                "stab_demangle_template"
            ],
            "imported": false,
            "current_name": "FUN_001046b0"
        },
        "FUN_0010875d": {
            "renaming": {
                "FUN_0010875d": "compare_records_0010875d",
                "param_1": "record1",
                "param_2": "record2",
                "lVar1": "record1Address",
                "lVar2": "record2Address",
                "iVar3": "comparisonResult",
                "uVar4": "flag"
            },
            "code": "\nint compareRecords_0010875d(long *record1,long *record2)\n\n{\n  long record1Address;\n  long record2Address;\n  int comparisonResult;\n  uint flag;\n  \n  record1Address = *record1;\n  record2Address = *record2;\n  flag = *(uint *)(record2Address + 0x24) & 0x102;\n  if ((*(uint *)(record1Address + 0x24) & 0x102) == 0x102) {\n    if (flag != 0x102) {\n      return 1;\n    }\n  }\n  else if (flag == 0x102) {\n    return -1;\n  }\n  comparisonResult = 1;\n  if (*(ulong *)(record1Address + 0x38) <= *(ulong *)(record2Address + 0x38)) {\n    comparisonResult = -1;\n    if (*(ulong *)(record2Address + 0x38) <= *(ulong *)(record1Address + 0x38)) {\n      if (*(ulong *)(record2Address + 0x40) < *(ulong *)(record1Address + 0x40)) {\n        comparisonResult = 1;\n      }\n      else {\n        comparisonResult = -1;\n        if (*(ulong *)(record2Address + 0x40) <= *(ulong *)(record1Address + 0x40)) {\n          comparisonResult = 1;\n          if (*(uint *)(record1Address + 0x18) <= *(uint *)(record2Address + 0x18)) {\n            return -(uint)(*(uint *)(record1Address + 0x18) < *(uint *)(record2Address + 0x18));\n          }\n        }\n      }\n    }\n  }\n  return comparisonResult;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010875d",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "compare_records_0010875d"
        },
        "FUN_001048f0": {
            "renaming": {},
            "code": "\n\n\nvoid free(void *__ptr)\n\n{\n  free(__ptr);\n  return;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048f0",
            "calling": [
                "merge_gnu_build_notes",
                "stab_variable.lto_priv.0",
                "list_matching_formats",
                "stab_float_type.lto_priv.0",
                "stab_struct_field.lto_priv.0",
                "stab_demangle_type.lto_priv.0",
                "stab_pop_type",
                "stab_int_constant.lto_priv.0",
                "main",
                "stab_method_type.lto_priv.0",
                "FUN_00104ea2",
                "display_info.isra.0",
                "stab_emit_pending_vars",
                "copy_section",
                "bfd_get_archive_filename",
                "stab_function_type.lto_priv.0",
                "stab_range_type.lto_priv.0",
                "parse_coff_struct_type",
                "stab_start_function.lto_priv.0",
                "free_saved_stabs",
                "parse_stab",
                "parse_stab_type",
                "stab_modify_type",
                "FUN_00107880",
                "copy_file",
                "stab_demangle_v3_arg",
                "stab_end_struct_type.lto_priv.0",
                "save_stab",
                "FUN_0010554f",
                "list_supported_targets",
                "stab_tag.lto_priv.0",
                "stab_typed_constant.lto_priv.0",
                "stab_set_type.lto_priv.0",
                "stab_typdef.lto_priv.0",
                "stab_demangle_v3_arglist",
                "stab_enum_type.lto_priv.0",
                "stab_class_baseclass.lto_priv.0",
                "stab_demangle_qualified",
                "FUN_00114b84",
                "make_tempdir.cold",
                "mark_symbols_used_in_relocations",
                "stab_class_static_member.lto_priv.0",
                "stab_demangle_template",
                "stab_function_parameter.lto_priv.0",
                "copy_object.cold",
                "stab_start_class_type.lto_priv.0",
                "FUN_00116852",
                "stab_find_tagged_type",
                "stab_array_type.lto_priv.0",
                "stab_offset_type.lto_priv.0",
                "stab_class_method_var",
                "parse_coff_type.lto_priv.0",
                "FUN_00108466",
                "stab_float_constant.lto_priv.0",
                "stab_end_class_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "FUN_001048f0"
        },
        "FUN_00128260": {
            "renaming": {},
            "code": "\n\n\n\nint putc(int __c,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* putc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128260",
            "calling": [
                "putc"
            ],
            "imported": false,
            "current_name": "FUN_00128260"
        },
        "FUN_00104290": {
            "renaming": {},
            "code": "\n\n\nchar * strchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strchr(__s,__c);\n  return pcVar1;\n}\n\n",
            "called": [
                "strchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104290",
            "calling": [
                "main",
                "parse_flags.cold",
                "parse_stab",
                "parse_stab_type",
                "init_section_add"
            ],
            "imported": false,
            "current_name": "FUN_00104290"
        },
        "FUN_00104050": {
            "renaming": {},
            "code": "\nvoid cplus_demangle_print(void)\n\n{\n  cplus_demangle_print();\n  return;\n}\n\n",
            "called": [
                "cplus_demangle_print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104050",
            "calling": [
                "stab_demangle_v3_arg"
            ],
            "imported": false,
            "current_name": "FUN_00104050"
        },
        "FUN_00104170": {
            "renaming": {},
            "code": "\n\n\ndouble strtod(char *__nptr,char **__endptr)\n\n{\n  double dVar1;\n  \n  dVar1 = strtod(__nptr,__endptr);\n  return dVar1;\n}\n\n",
            "called": [
                "strtod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104170",
            "calling": [
                "parse_stab"
            ],
            "imported": false,
            "current_name": "FUN_00104170"
        },
        "FUN_001048f8": {
            "renaming": {},
            "code": "\nvoid htab_hash_string(void)\n\n{\n  htab_hash_string();\n  return;\n}\n\n",
            "called": [
                "htab_hash_string"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048f8",
            "calling": [
                "htab_hash_redefnode"
            ],
            "imported": false,
            "current_name": "FUN_001048f8"
        },
        "FUN_0010c892": {
            "renaming": {
                "FUN_0010c892": "process_debug_types_0010c892",
                "cVar1": "shouldEmitPendingVars",
                "lVar2": "typeResult",
                "lVar3": "taggedType",
                "uVar4": "result",
                "puVar5": "typeList",
                "iVar6": "typeKind"
            },
            "code": "\n\n\nundefined8 processDebugTypes_0010c892(undefined8 param_1,long param_2)\n\n{\n  char shouldEmitPendingVars;\n  long typeResult;\n  long taggedType;\n  undefined8 result;\n  undefined8 *typeList;\n  int typeKind;\n  \n  if (*(char *)(param_2 + 0x60) == '\\0') {\nLAB_0010c8c7:\n    for (typeList = *(undefined8 **)(param_2 + 0x1a0); typeList != (undefined8 *)0x0;\n        typeList = (undefined8 *)*typeList) {\n      typeKind = *(int *)(typeList + 2);\n      taggedType = typeList[1];\n      if (typeKind != 0) {\n        if (taggedType != 0) {\n          if (typeKind - 7U < 5) goto LAB_0010c8d5;\n          result = dcgettext(0,\"debug_make_undefined_type: unsupported kind\",5);\n          fprintf(_stderr,\"%s\\n\",result);\n        }\nLAB_0010c910:\n        typeList[3] = 0;\n        goto LAB_0010c916;\n      }\n      if (taggedType == 0) goto LAB_0010c910;\n      typeKind = 7;\nLAB_0010c8d5:\n      typeResult = debug_make_type_constprop_0(typeKind,0);\n      if (typeResult == 0) goto LAB_0010c910;\n      taggedType = debug_tag_type(param_1,taggedType,typeResult);\n      typeList[3] = taggedType;\n      if (taggedType == 0) goto LAB_0010c916;\n    }\n    result = 1;\n  }\n  else {\n    shouldEmitPendingVars = stab_emit_pending_vars();\n    if (shouldEmitPendingVars != '\\0') {\n      shouldEmitPendingVars = debug_end_function(param_1,*(undefined8 *)(param_2 + 0x68));\n      if (shouldEmitPendingVars != '\\0') {\n        *(undefined *)(param_2 + 0x60) = 0;\n        *(undefined8 *)(param_2 + 0x68) = 0xffffffffffffffff;\n        goto LAB_0010c8c7;\n      }\n    }\nLAB_0010c916:\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext",
                "debug_tag_type",
                "stab_emit_pending_vars",
                "debug_make_type.constprop.0",
                "debug_end_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c892",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "process_debug_types_0010c892"
        },
        "FUN_00112904": {
            "renaming": {
                "FUN_00112904": "initialize_memory_block_00112904",
                "param_1": "value1",
                "param_2": "value2",
                "puVar1": "memoryBlock",
                "xmalloc": "allocateMemory"
            },
            "code": "\nvoid initializeMemoryBlock_00112904(undefined4 value1,undefined4 value2)\n\n{\n  undefined4 *memoryBlock;\n  \n  memoryBlock = (undefined4 *)allocateMemory(0x18);\n  *memoryBlock = value1;\n  memoryBlock[1] = value2;\n  *(undefined (*) [16])(memoryBlock + 2) = ZEXT816(0);\n  return;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112904",
            "calling": [
                "stab_demangle_v3_arg",
                "stab_find_type",
                "finish_stab",
                "stab_demangle_type.lto_priv.0",
                "debug_make_indirect_type.isra.0",
                "debug_make_int_type.isra.0",
                "debug_make_void_type.isra.0",
                "debug_name_type",
                "debug_make_function_type.isra.0",
                "debug_make_volatile_type.isra.0",
                "debug_make_array_type.isra.0",
                "parse_stab_type",
                "debug_make_pointer_type.isra.0",
                "debug_tag_type",
                "debug_make_method_type.isra.0",
                "debug_make_offset_type.isra.0",
                "debug_make_struct_type.isra.0",
                "debug_make_float_type.isra.0",
                "debug_make_const_type.isra.0",
                "debug_make_reference_type.isra.0",
                "debug_make_enum_type.isra.0"
            ],
            "imported": false,
            "current_name": "initialize_memory_block_00112904"
        },
        "FUN_00128388": {
            "renaming": {},
            "code": "\n\n\n\nchar * mkdtemp(char *__template)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mkdtemp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128388",
            "calling": [
                "mkdtemp"
            ],
            "imported": false,
            "current_name": "FUN_00128388"
        },
        "FUN_00108898": {
            "renaming": {
                "FUN_00108898": "compare_strings_00108898",
                "param_1": "string1",
                "param_2": "string2",
                "iVar1": "stringComparisonResult",
                "in_RAX": "returnValue",
                "auVar2": "result"
            },
            "code": "\nundefined  [16] compareStrings_00108898(char **string1,char **string2)\n\n{\n  int stringComparisonResult;\n  undefined8 returnValue;\n  undefined result [16];\n  \n  stringComparisonResult = strcmp(*string1,*string2);\n  result._1_7_ = 0;\n  result[0] = stringComparisonResult == 0;\n  result._8_8_ = returnValue;\n  return result;\n}\n\n",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108898",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "compare_strings_00108898"
        },
        "FUN_0011a390": {
            "renaming": {
                "FUN_0011a390": "execute_atexit_functions_0011a390",
                "lVar1": "index",
                "lVar2": "reverse_index",
                "lVar3": "inner_index",
                "plVar4": "atexit_list",
                "uVar5": "num_functions"
            },
            "code": "\nvoid execute_atexit_functions_0011a390(void)\n\n{\n  long index;\n  long reverse_index;\n  long inner_index;\n  long *atexit_list;\n  uint num_functions;\n  \n  atexit_list = (long *)xatexit_head_lto_priv_0;\n  if (xatexit_head_lto_priv_0 != (undefined *)0x0) {\n    do {\n      num_functions = *(int *)(atexit_list + 1) - 1;\n      if (-1 < (int)num_functions) {\n        index = (long)(int)num_functions;\n        num_functions = num_functions & 7;\n        (*(code *)atexit_list[index + 2])();\n        reverse_index = index + -1;\n        if (-1 < (int)reverse_index) {\n          inner_index = reverse_index;\n          if (num_functions != 0) {\n            if (num_functions != 1) {\n              if (num_functions != 2) {\n                if (num_functions != 3) {\n                  if (num_functions != 4) {\n                    if (num_functions != 5) {\n                      if (num_functions != 6) {\n                        (*(code *)atexit_list[index + 1])();\n                        reverse_index = index + -2;\n                      }\n                      (*(code *)atexit_list[reverse_index + 2])();\n                      reverse_index = reverse_index + -1;\n                    }\n                    (*(code *)atexit_list[reverse_index + 2])();\n                    reverse_index = reverse_index + -1;\n                  }\n                  (*(code *)atexit_list[reverse_index + 2])();\n                  reverse_index = reverse_index + -1;\n                }\n                (*(code *)atexit_list[reverse_index + 2])();\n                reverse_index = reverse_index + -1;\n              }\n              (*(code *)atexit_list[reverse_index + 2])();\n              reverse_index = reverse_index + -1;\n            }\n            (*(code *)atexit_list[reverse_index + 2])();\n            inner_index = reverse_index + -1;\n            if ((int)(reverse_index + -1) < 0) goto LAB_0011a466;\n          }\n          do {\n            (*(code *)atexit_list[inner_index + 2])();\n            index = inner_index + -1;\n            (*(code *)atexit_list[inner_index + 1])();\n            (*(code *)atexit_list[inner_index])();\n            (*(code *)atexit_list[index])();\n            (*(code *)atexit_list[inner_index + -2])();\n            (*(code *)atexit_list[inner_index + -3])();\n            (*(code *)atexit_list[inner_index + -4])();\n            (*(code *)atexit_list[inner_index + -5])();\n            inner_index = inner_index + -8;\n          } while (-1 < (int)index + -7);\n        }\n      }\nLAB_0011a466:\n      atexit_list = (long *)*atexit_list;\n    } while (atexit_list != (long *)0x0);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a390",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "execute_atexit_functions_0011a390"
        },
        "FUN_00128008": {
            "renaming": {},
            "code": "\n\n\n\nchar * getenv(char *__name)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getenv@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128008",
            "calling": [
                "getenv"
            ],
            "imported": false,
            "current_name": "FUN_00128008"
        },
        "FUN_00128128": {
            "renaming": {},
            "code": "\n\n\nvoid bindtextdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* bindtextdomain@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128128",
            "calling": [
                "bindtextdomain"
            ],
            "imported": false,
            "current_name": "FUN_00128128"
        },
        "FUN_001046c0": {
            "renaming": {},
            "code": "\n\n\nint fchmod(int __fd,__mode_t __mode)\n\n{\n  int iVar1;\n  \n  iVar1 = fchmod(__fd,__mode);\n  return iVar1;\n}\n\n",
            "called": [
                "fchmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001046c0",
            "calling": [
                "simple_copy"
            ],
            "imported": false,
            "current_name": "FUN_001046c0"
        },
        "FUN_001045a0": {
            "renaming": {},
            "code": "\nvoid bfd_printable_arch_mach(void)\n\n{\n  bfd_printable_arch_mach();\n  return;\n}\n\n",
            "called": [
                "bfd_printable_arch_mach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001045a0",
            "calling": [
                "FUN_00105828",
                "display_info.isra.0.cold",
                "display_info.isra.0",
                "do_display_target"
            ],
            "imported": false,
            "current_name": "FUN_001045a0"
        },
        "FUN_001047e0": {
            "renaming": {},
            "code": "\n\n\nint sprintf(char *__s,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = sprintf(__s,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047e0",
            "calling": [
                "stab_variable.lto_priv.0",
                "stab_end_struct_type.lto_priv.0",
                "stab_push_defined_type",
                "stab_tag.lto_priv.0",
                "stab_typed_constant.lto_priv.0",
                "stab_float_type.lto_priv.0",
                "stab_struct_field.lto_priv.0",
                "stab_set_type.lto_priv.0",
                "stab_start_struct_type.lto_priv.0",
                "stab_typdef.lto_priv.0",
                "stab_int_constant.lto_priv.0",
                "stab_enum_type.lto_priv.0",
                "stab_class_baseclass.lto_priv.0",
                "stab_class_start_method.lto_priv.0",
                "stab_method_type.lto_priv.0",
                "stab_class_static_member.lto_priv.0",
                "bfd_get_archive_filename",
                "stab_function_parameter.lto_priv.0",
                "stab_function_type.lto_priv.0",
                "stab_void_type.lto_priv.0",
                "stab_complex_type.lto_priv.0",
                "stab_start_class_type.lto_priv.0",
                "stab_range_type.lto_priv.0",
                "stab_int_type.lto_priv.0",
                "stab_array_type.lto_priv.0",
                "stab_offset_type.lto_priv.0",
                "stab_start_function.lto_priv.0",
                "stab_class_method_var",
                "parse_stab_type",
                "stab_modify_type",
                "stab_empty_type.lto_priv.0",
                "stab_float_constant.lto_priv.0",
                "stab_end_class_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "FUN_001047e0"
        },
        "FUN_0010e842": {
            "renaming": {
                "FUN_0010e842": "write_symbol_to_private_symbol_table_0010e842",
                "param_1": "symbolTable",
                "param_2": "symbolName",
                "param_3": "symbolValue",
                "param_4": "additionalParameter",
                "__s": "formattedSymbol",
                "sVar1": "symbolNameLength",
                "auVar2": "result"
            },
            "code": "\nundefined  [16] writeSymbolToPrivateSymbolTable_0010e842(undefined8 symbolTable,char *symbolName,undefined8 symbolValue,undefined8 additionalParameter)\n\n{\n  size_t symbolNameLength;\n  char *formattedSymbol;\n  undefined result [16];\n  \n  symbolNameLength = strlen(symbolName);\n  formattedSymbol = (char *)xmalloc(symbolNameLength + 0x14);\n  sprintf(formattedSymbol,\"%s:c=i%ld\",symbolName,symbolValue);\n  result._0_4_ = stab_write_symbol_lto_priv_0(symbolTable,0x80,0,0,formattedSymbol);\n  result._4_4_ = 0;\n  if ((char)result._0_4_ != '\\0') {\n    free(formattedSymbol);\n  }\n  result._8_8_ = additionalParameter;\n  return result;\n}\n\n",
            "called": [
                "strlen",
                "stab_write_symbol.lto_priv.0",
                "sprintf",
                "free",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e842",
            "calling": [
                "debug_write_name.constprop.0"
            ],
            "imported": false,
            "current_name": "write_symbol_to_private_symbol_table_0010e842"
        },
        "FUN_00104060": {
            "renaming": {},
            "code": "\n\n\nint utimensat(int __fd,char *__path,timespec *__times,int __flags)\n\n{\n  int iVar1;\n  \n  iVar1 = utimensat(__fd,__path,__times,__flags);\n  return iVar1;\n}\n\n",
            "called": [
                "utimensat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104060",
            "calling": [
                "set_times"
            ],
            "imported": false,
            "current_name": "FUN_00104060"
        },
        "FUN_00128370": {
            "renaming": {},
            "code": "\n\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fseek@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128370",
            "calling": [
                "fseek"
            ],
            "imported": false,
            "current_name": "FUN_00128370"
        },
        "FUN_00104180": {
            "renaming": {},
            "code": "\nvoid bfd_create_gnu_debuglink_section(void)\n\n{\n  bfd_create_gnu_debuglink_section();\n  return;\n}\n\n",
            "called": [
                "bfd_create_gnu_debuglink_section"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104180",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "FUN_00104180"
        },
        "FUN_00113cb9": {
            "renaming": {
                "FUN_00113cb9": "create_constprop_type_00113cb9",
                "param_1": "value",
                "lVar1": "type_ptr"
            },
            "code": "\nlong create_constprop_type_00113cb9(long value)\n\n{\n  long type_ptr;\n  \n  if (value != 0) {\n    type_ptr = debug_make_type_constprop_0(0xe,0);\n    if (type_ptr == 0) {\n      type_ptr = 0;\n    }\n    else {\n      *(long *)(type_ptr + 0x10) = value;\n    }\n    return type_ptr;\n  }\n  return 0;\n}\n\n",
            "called": [
                "debug_make_type.constprop.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113cb9",
            "calling": [
                "stab_demangle_v3_arg",
                "parse_stab_type",
                "stab_demangle_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "create_constprop_type_00113cb9"
        },
        "FUN_00128130": {
            "renaming": {},
            "code": "\n\n\n\nint rmdir(char *__path)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* rmdir@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128130",
            "calling": [
                "rmdir"
            ],
            "imported": false,
            "current_name": "FUN_00128130"
        },
        "FUN_00128498": {
            "renaming": {},
            "code": "\n\n\n\nchar * strdup(char *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strdup@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128498",
            "calling": [
                "strdup"
            ],
            "imported": false,
            "current_name": "FUN_00128498"
        },
        "FUN_00128258": {
            "renaming": {},
            "code": "\n\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcmp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128258",
            "calling": [
                "strcmp"
            ],
            "imported": false,
            "current_name": "FUN_00128258"
        },
        "FUN_00128138": {
            "renaming": {},
            "code": "\n\n\nvoid dcgettext(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* dcgettext@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128138",
            "calling": [
                "dcgettext"
            ],
            "imported": false,
            "current_name": "FUN_00128138"
        },
        "FUN_0010eafe": {
            "renaming": {
                "FUN_0010eafe": "write_symbol_and_free_0010eafe",
                "param_1": "symbolTable",
                "param_2": "fileName",
                "param_3": "flag",
                "__s": "type",
                "sVar2": "fileNameLength",
                "sVar3": "typeLength",
                "__s_00": "formattedSymbol"
            },
            "code": "\nundefined4 writeSymbolAndFree_0010eafe(long symbolTable,char *fileName,char flag)\n\n{\n  undefined4 uVar1;\n  char *type;\n  size_t fileNameLength;\n  size_t typeLength;\n  char *formattedSymbol;\n  \n  if ((*(int *)(symbolTable + 0x1f8) == 0) && (*(long *)(symbolTable + 0x1e8) == -1)) {\n    type = (char *)stab_pop_type();\n    fileNameLength = strlen(fileName);\n    typeLength = strlen(type);\n    formattedSymbol = (char *)xmalloc(fileNameLength + 3 + typeLength);\n    sprintf(formattedSymbol,\"%s:%c%s\",fileName,(ulong)((-(uint)(flag == '\\0') & 0x20) + 0x46),type);\n    *(undefined8 *)(symbolTable + 0x1e8) = *(undefined8 *)(symbolTable + 0x10);\n    uVar1 = stab_write_symbol_lto_priv_0(symbolTable,0x24,0,0,formattedSymbol);\n    if ((char)uVar1 != '\\0') {\n      free(formattedSymbol);\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "strlen",
                "stab_write_symbol.lto_priv.0",
                "sprintf",
                "free",
                "stab_pop_type",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010eafe",
            "calling": [
                "debug_write_name.constprop.0"
            ],
            "imported": false,
            "current_name": "write_symbol_and_free_0010eafe"
        },
        "FUN_001045b0": {
            "renaming": {},
            "code": "\nvoid bfd_coff_get_auxent(void)\n\n{\n  bfd_coff_get_auxent();\n  return;\n}\n\n",
            "called": [
                "bfd_coff_get_auxent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001045b0",
            "calling": [
                "FUN_0010554f",
                "parse_coff_struct_type"
            ],
            "imported": false,
            "current_name": "FUN_001045b0"
        },
        "FUN_00113df2": {
            "renaming": {
                "FUN_00113df2": "set_constant_type_00113df2",
                "param_1": "inputParam",
                "debug_make_type_constprop_0": "makeTypeConstant"
            },
            "code": "\nvoid setConstantType_00113df2(undefined4 inputParam)\n\n{\n  makeTypeConstant(4,inputParam);\n  return;\n}\n\n",
            "called": [
                "debug_make_type.constprop.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113df2",
            "calling": [
                "stab_demangle_v3_arg",
                "parse_coff_type.lto_priv.0",
                "parse_stab_type",
                "stab_find_type",
                "stab_demangle_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "set_constant_type_00113df2"
        },
        "FUN_001047f0": {
            "renaming": {},
            "code": "\n\n\nvoid exit(int __status)\n\n{\n                    \n  exit(__status);\n}\n\n",
            "called": [
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047f0",
            "calling": [
                "print_version",
                "strip_usage",
                "copy_usage"
            ],
            "imported": false,
            "current_name": "FUN_001047f0"
        },
        "FUN_0010a377": {
            "renaming": {
                "FUN_0010a377": "concatenate_strings_0010a377",
                "param_1": "input",
                "cVar1": "flag",
                "__s": "string1",
                "__s_00": "string2",
                "sVar3": "length1",
                "sVar4": "length2",
                "__s_01": "concatenatedString",
                "uVar2": "output",
                "uVar5": "useFlag"
            },
            "code": "\nundefined4 concatenateStrings_0010a377(long input)\n\n{\n  char flag;\n  undefined4 output;\n  char *string1;\n  char *string2;\n  size_t length1;\n  size_t length2;\n  char *concatenatedString;\n  undefined useFlag;\n  \n  useFlag = 1;\n  flag = *(char *)(*(long *)(input + 0x60) + 0x1c);\n  string1 = (char *)stab_pop_type();\n  if (flag == '\\0') {\n    useFlag = *(undefined *)(*(long *)(input + 0x60) + 0x1c);\n  }\n  string2 = (char *)stab_pop_type(input);\n  length1 = strlen(string1);\n  length2 = strlen(string2);\n  concatenatedString = (char *)xmalloc(length1 + 3 + length2);\n  sprintf(concatenatedString,\"@%s,%s\",string2,string1);\n  free(string2);\n  free(string1);\n  output = stab_push_string(input,concatenatedString,0,useFlag,0);\n  if ((char)output != '\\0') {\n    free(concatenatedString);\n  }\n  return output;\n}\n\n",
            "called": [
                "strlen",
                "stab_push_string",
                "sprintf",
                "free",
                "stab_pop_type",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a377",
            "calling": [
                "debug_write_type.constprop.0"
            ],
            "imported": false,
            "current_name": "concatenate_strings_0010a377"
        },
        "FUN_001046d0": {
            "renaming": {},
            "code": "\n\n\nint chmod(char *__file,__mode_t __mode)\n\n{\n  int iVar1;\n  \n  iVar1 = chmod(__file,__mode);\n  return iVar1;\n}\n\n",
            "called": [
                "chmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001046d0",
            "calling": [
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "FUN_001046d0"
        },
        "FUN_00128160": {
            "renaming": {},
            "code": "\n\n\n\nchar * strchr(char *__s,int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strchr@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128160",
            "calling": [
                "strchr"
            ],
            "imported": false,
            "current_name": "FUN_00128160"
        },
        "FUN_00104070": {
            "renaming": {},
            "code": "\nvoid bfd_scan_vma(void)\n\n{\n  bfd_scan_vma();\n  return;\n}\n\n",
            "called": [
                "bfd_scan_vma"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104070",
            "calling": [
                "parse_vma"
            ],
            "imported": false,
            "current_name": "FUN_00104070"
        },
        "FUN_00104190": {
            "renaming": {},
            "code": "\nvoid bfd_make_section_anyway_with_flags(void)\n\n{\n  bfd_make_section_anyway_with_flags();\n  return;\n}\n\n",
            "called": [
                "bfd_make_section_anyway_with_flags"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104190",
            "calling": [
                "setup_section"
            ],
            "imported": false,
            "current_name": "FUN_00104190"
        },
        "FUN_0010d882": {
            "renaming": {
                "FUN_0010d882": "process_demangled_names_0010d882",
                "param_1": "ptr1",
                "param_2": "param_list",
                "param_3": "ptr2",
                "param_4": "ptr3",
                "iVar1": "count",
                "pcVar2": "current_char",
                "cVar3": "current_value",
                "lVar4": "allocated_memory",
                "pcVar5": "current_position",
                "uVar6": "index",
                "bVar7": "condition",
                "local_50": "total_args",
                "local_4c": "default_value",
                "local_48": "max_arg_count",
                "local_44": "remaining_count",
                "local_40": "tmp_memory"
            },
            "code": "\nundefined8 process_demangled_names_0010d882(long ptr1,char **param_list,long *ptr2,undefined *ptr3)\n\n{\n  int count;\n  char *current_char;\n  char current_value;\n  long allocated_memory;\n  char *current_position;\n  ulong index;\n  bool condition;\n  uint total_args;\n  undefined4 default_value;\n  uint max_arg_count;\n  int remaining_count;\n  undefined8 tmp_memory [2];\n  \n  current_char = *param_list;\n  default_value = 10;\n  if (ptr2 != (long *)0x0) {\n    allocated_memory = xmalloc();\n    *ptr2 = allocated_memory;\n    *ptr3 = 0;\n  }\n  total_args = 0;\n  while( true ) {\n    current_position = *param_list;\n    current_value = *current_position;\n    if ((current_value == '_' || current_value == '\\0') || (current_value == 'e')) break;\n    if ((current_value == 'N') || (current_value == 'T')) {\n      *param_list = current_position + 1;\n      if (current_value == 'T') {\n        remaining_count = 1;\n      }\n      else {\n        current_value = stab_demangle_get_count(param_list,&remaining_count);\n        if (current_value == '\\0') goto LAB_0010d958;\n      }\n      current_value = stab_demangle_get_count(param_list,&max_arg_count);\n      if ((current_value == '\\0') || (*(uint *)(ptr1 + 0x28) <= max_arg_count)) {\nLAB_0010d958:\n        stab_bad_demangle(current_char);\n        return 0;\n      }\n      index = (ulong)max_arg_count;\n      while (count = remaining_count + -1, condition = remaining_count != 0, remaining_count = count, condition) {\n        tmp_memory[0] = *(undefined8 *)(*(long *)(ptr1 + 0x20) + index * 0x10);\n        current_value = stab_demangle_arg(ptr1,tmp_memory,ptr2,&total_args,&default_value);\n        if (current_value == '\\0') {\n          return 0;\n        }\n      }\n    }\n    else {\n      current_value = stab_demangle_arg(ptr1,param_list,ptr2,&total_args,&default_value);\n      if (current_value == '\\0') {\n        return 0;\n      }\n    }\n  }\n  if (ptr2 == (long *)0x0) {\n    if (current_value != 'e') goto LAB_0010d9fa;\n  }\n  else {\n    *(undefined8 *)(*ptr2 + (ulong)total_args * 8) = 0;\n    if (*current_position != 'e') goto LAB_0010d9fa;\n    *ptr3 = 1;\n  }\n  current_position = current_position + 1;\n  *param_list = current_position;\nLAB_0010d9fa:\n  return CONCAT71((int7)((ulong)current_position >> 8),1);\n}\n\n",
            "called": [
                "stab_demangle_arg",
                "stab_bad_demangle",
                "stab_demangle_get_count",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010d882",
            "calling": [
                "parse_stab_type",
                "stab_demangle_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "process_demangled_names_0010d882"
        },
        "FUN_00128040": {
            "renaming": {},
            "code": "\n\n\nvoid __libc_start_main(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __libc_start_main@GLIBC_2.34 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128040",
            "calling": [
                "_start"
            ],
            "imported": false,
            "current_name": "FUN_00128040"
        },
        "FUN_00128168": {
            "renaming": {},
            "code": "\n\n\n\nint printf(char *__format,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* printf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128168",
            "calling": [
                "printf"
            ],
            "imported": false,
            "current_name": "FUN_00128168"
        },
        "FUN_00112925": {
            "renaming": {
                "FUN_00112925": "initialize_buffer_00112925",
                "param_1": "buffer",
                "param_2": "value",
                "param_3": "param3",
                "param_4": "param4",
                "puVar1": "bufferPointer",
                "pauVar2": "bufferAddress",
                "lVar3": "loopCounter",
                "puVar4": "currentPointer",
                "bVar5": "byteValue"
            },
            "code": "\nundefined4 *\ninitializeBuffer_00112925(undefined (**buffer) [16],undefined8 value,undefined4 param3,undefined4 param4)\n\n{\n  undefined4 *bufferPointer;\n  undefined (*bufferAddress) [16];\n  long loopCounter;\n  undefined4 *currentPointer;\n  byte byteValue;\n  \n  byteValue = 0;\n  bufferPointer = (undefined4 *)xmalloc(0x28);\n  currentPointer = bufferPointer;\n  for (loopCounter = 10; loopCounter != 0; loopCounter = loopCounter + -1) {\n    *currentPointer = 0;\n    currentPointer = currentPointer + (ulong)byteValue * -2 + 1;\n  }\n  bufferAddress = *buffer;\n  *(undefined8 *)(bufferPointer + 2) = value;\n  bufferPointer[5] = param3;\n  bufferPointer[6] = param4;\n  if (bufferAddress == (undefined (*) [16])0x0) {\n    bufferAddress = (undefined (*) [16])xmalloc(0x10);\n    *bufferAddress = ZEXT816(0);\n    *buffer = bufferAddress;\n    *(undefined (**) [16])(*bufferAddress + 8) = bufferAddress;\n  }\n  **(undefined8 **)(*bufferAddress + 8) = bufferPointer;\n  *(undefined4 **)(*bufferAddress + 8) = bufferPointer;\n  return bufferPointer;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112925",
            "calling": [
                "debug_name_type",
                "debug_record_function",
                "debug_tag_type",
                "debug_record_variable",
                "debug_add_to_current_namespace.constprop.0"
            ],
            "imported": false,
            "current_name": "initialize_buffer_00112925"
        },
        "FUN_0010bf86": {
            "renaming": {
                "FUN_0010bf86": "record_line_0010bf86",
                "param_1": "context",
                "param_2": "line_number",
                "param_3": "unit",
                "uVar1": "errorMessage",
                "puVar2": "currentUnit",
                "uVar3": "index",
                "puVar4": "newRecord",
                "lVar5": "loopCounter",
                "puVar6": "record",
                "bVar7": "flag"
            },
            "code": "\n\n\nundefined8 record_line_0010bf86(long context,undefined8 line_number,undefined8 unit)\n\n{\n  undefined8 errorMessage;\n  undefined8 *currentUnit;\n  ulong index;\n  undefined4 *newRecord;\n  long loopCounter;\n  undefined4 *record;\n  byte flag;\n  \n  flag = 0;\n  if (*(long *)(context + 8) == 0) {\n    errorMessage = dcgettext(0,\"debug_record_line_0010bf86: no current unit\",5);\n    fprintf(_stderr,\"%s\\n\",errorMessage);\n    errorMessage = 0;\n  }\n  else {\n    loopCounter = *(long *)(context + 0x28);\n    if ((loopCounter != 0) && (*(long *)(loopCounter + 8) == *(long *)(context + 0x10))) {\n      index = 0;\n      do {\n        if (*(long *)(loopCounter + 0x10 + index * 8) == -1) {\n          currentUnit = (undefined8 *)(index & 0xffffffff);\n          *(undefined8 *)(loopCounter + 0x10 + (long)currentUnit * 8) = line_number;\n          *(undefined8 *)(loopCounter + 0x60 + (long)currentUnit * 8) = unit;\n          goto LAB_0010c056;\n        }\n        index = index + 1;\n      } while (index != 10);\n    }\n    newRecord = (undefined4 *)xmalloc(0xb0);\n    record = newRecord;\n    for (loopCounter = 0x2c; loopCounter != 0; loopCounter = loopCounter + -1) {\n      *record = 0;\n      record = record + (ulong)flag * -2 + 1;\n    }\n    errorMessage = *(undefined8 *)(context + 0x10);\n    *(undefined8 *)(newRecord + 4) = line_number;\n    *(undefined8 *)(newRecord + 2) = errorMessage;\n    *(undefined8 *)(newRecord + 0x18) = unit;\n    record = newRecord + 6;\n    for (loopCounter = 0x48; loopCounter != 0; loopCounter = loopCounter + -1) {\n      *(undefined *)record = 0xff;\n      record = (undefined4 *)((long)record + (ulong)flag * -2 + 1);\n    }\n    currentUnit = *(undefined8 **)(context + 0x28);\n    if (currentUnit == (undefined8 *)0x0) {\n      currentUnit = *(undefined8 **)(context + 8);\n      currentUnit[2] = newRecord;\n    }\n    else {\n      *currentUnit = newRecord;\n    }\n    *(undefined4 **)(context + 0x28) = newRecord;\nLAB_0010c056:\n    errorMessage = CONCAT71((int7)((ulong)currentUnit >> 8),1);\n  }\n  return errorMessage;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bf86",
            "calling": [
                "parse_stab",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "record_line_0010bf86"
        },
        "FUN_00128048": {
            "renaming": {},
            "code": "\n\n\n\nvoid abort(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* abort@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128048",
            "calling": [
                "abort"
            ],
            "imported": false,
            "current_name": "FUN_00128048"
        },
        "FUN_00128288": {
            "renaming": {},
            "code": "\n\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fprintf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128288",
            "calling": [
                "fprintf"
            ],
            "imported": false,
            "current_name": "FUN_00128288"
        },
        "FUN_0011a170": {
            "renaming": {
                "FUN_0011a170": "pattern_match_0011a170",
                "param_1": "pattern",
                "param_2": "string",
                "__pattern": "currentPattern",
                "iVar1": "matchResult"
            },
            "code": "\nint patternMatch_0011a170(char **pattern,char **string)\n\n{\n  char *currentPattern;\n  int matchResult;\n  \n  currentPattern = *pattern;\n  if (*currentPattern == '!') {\n    matchResult = fnmatch(currentPattern + 1,*string,0);\n    if (matchResult == 0) {\n      *(undefined *)(string + 1) = 0;\n      return matchResult;\n    }\n  }\n  else {\n    matchResult = fnmatch(currentPattern,*string,0);\n    if (matchResult == 0) {\n      *(undefined *)(string + 1) = 1;\n    }\n  }\n  return 1;\n}\n\n",
            "called": [
                "fnmatch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a170",
            "calling": [
                "FUN_0010554f",
                "is_specified_symbol"
            ],
            "imported": false,
            "current_name": "pattern_match_0011a170"
        },
        "FUN_0010bd62": {
            "renaming": {
                "FUN_0010bd62": "record_parameter_0010bd62",
                "param_1": "functionInfo",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "puVar1": "currentNode",
                "uVar2": "errorMessage",
                "puVar3": "newRecord",
                "puVar4": "nextNode",
                "puVar6": "prevNode",
                "puVar7": "pointer",
                "bVar8": "flag",
                "lVar5": "index"
            },
            "code": "\n\n\nundefined8\nrecordParameter_0010bd62(long functionInfo,long param2,long param3,undefined4 param4,undefined8 param5)\n\n{\n  undefined8 *currentNode;\n  undefined8 errorMessage;\n  undefined4 *newRecord;\n  undefined8 *nextNode;\n  long index;\n  undefined8 *prevNode;\n  undefined4 *pointer;\n  byte flag;\n  \n  flag = 0;\n  if (param2 == 0) {\n    return 0;\n  }\n  if (param3 != 0) {\n    if ((*(long *)(functionInfo + 8) != 0) && (*(long *)(functionInfo + 0x18) != 0)) {\n      newRecord = (undefined4 *)xmalloc(0x28);\n      pointer = newRecord;\n      for (index = 10; index != 0; index = index + -1) {\n        *pointer = 0;\n        pointer = pointer + (ulong)flag * -2 + 1;\n      }\n      index = *(long *)(functionInfo + 0x18);\n      *(long *)(newRecord + 2) = param2;\n      *(long *)(newRecord + 4) = param3;\n      newRecord[6] = param4;\n      currentNode = *(undefined8 **)(index + 8);\n      *(undefined8 *)(newRecord + 8) = param5;\n      prevNode = (undefined8 *)(index + 8);\n      while (nextNode = currentNode, nextNode != (undefined8 *)0x0) {\n        prevNode = nextNode;\n        currentNode = (undefined8 *)*nextNode;\n      }\n      *prevNode = newRecord;\n      return 1;\n    }\n    errorMessage = dcgettext(0,\"debug_record_parameter: no current function\",5);\n    fprintf(_stderr,\"%s\\n\",errorMessage);\n  }\n  return 0;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bd62",
            "calling": [
                "parse_stab",
                "parse_coff_symbol.constprop.0.isra.0"
            ],
            "imported": false,
            "current_name": "record_parameter_0010bd62"
        },
        "FUN_00104ea2": {
            "renaming": {
                "FUN_00104ea2": "extract_and_copy_archived_files_00104ea2",
                "cVar1": "result",
                "iVar2": "archType",
                "ppcVar3": "archPtr",
                "pvVar4": "buffer",
                "lVar5": "bytesRead",
                "ppcVar6": "outputFile",
                "pcVar7": "currentChar",
                "puVar8": "tempDirData",
                "piVar9": "errorNum",
                "pcVar10": "filePath",
                "uVar11": "errorMessage",
                "lVar12": "fileSize",
                "pcVar13": "closeFunction",
                "lVar14": "bytesWritten",
                "unaff_EBX": "preserveDates",
                "unaff_RBP": "fileStats",
                "pcVar15": "tempPtr",
                "psVar16": "tempStats",
                "unaff_R12": "inputFile",
                "unaff_R13": "tempData",
                "unaff_R15": "archiveFile",
                "bVar17": "stackByte",
                "unaff_retaddr": "returnAddress",
                "param_7": "inputFilePtr",
                "param_8": "fileSizePtr",
                "param_9": "tempDir",
                "param_10": "archiveFilePtr",
                "param_11": "openFlags",
                "in_stack_00000030": "additionalFlag",
                "param_18": "timeStamp",
                "param_19": "archiveSize"
            },
            "code": "\nvoid extractAndCopyArchivedFiles_00104ea2(void)\n\n{\n  char result;\n  int archType;\n  char **archPtr;\n  void *buffer;\n  long bytesRead;\n  char **outputFile;\n  char *currentChar;\n  undefined8 *tempDirData;\n  int *errorNum;\n  char *filePath;\n  undefined8 errorMessage;\n  long fileSize;\n  code *closeFunction;\n  long bytesWritten;\n  int preserveDates;\n  stat *fileStats;\n  char *tempPtr;\n  stat *tempStats;\n  char *inputFile;\n  undefined8 *tempData;\n  char **archiveFile;\n  byte stackByte;\n  undefined8 returnAddress;\n  undefined8 *inputFilePtr;\n  long *fileSizePtr;\n  char *tempDir;\n  undefined8 *archiveFilePtr;\n  undefined8 openFlags;\n  undefined8 additionalFlag;\n  uint timeStamp;\n  long archiveSize;\n  \n  stackByte = 0;\ncode_r0x00104ea2:\n  outputFile = (char **)bfd_openw(inputFile,openFlags);\n  if (outputFile == (char **)0x0) {\nLAB_00104e80:\n    bfd_nonfatal_message(inputFile,0,0,0);\nLAB_00104e93:\n    status = 1;\n  }\n  else {\nLAB_00114a5f:\n    result = copy_object(archiveFile,outputFile,returnAddress);\n    if (result == '\\0') {\n      archType = bfd_get_arch(archiveFile);\n      if (archType == 0) goto LAB_00104d75;\n      result = bfd_close_all_done(outputFile);\n      if (result != '\\0') goto LAB_00104ec9;\n      bfd_nonfatal_message(inputFile,0,0,0);\n      goto LAB_00104ec9;\n    }\n    result = bfd_close(outputFile);\n    outputFile = archiveFile;\n    if (result == '\\0') {\n      bfd_nonfatal_message(inputFile,0,0,0);\n      status = 1;\n    }\nLAB_00114a86:\n    if ((preserve_dates != '\\0') && (preserveDates == 0)) {\n      set_times(inputFile,fileStats);\n    }\n    fileSize = bfd_openr(inputFile,openFlags);\n    tempData[2] = fileSize;\n    *fileSizePtr = fileSize;\n    fileSizePtr = (long *)(fileSize + 0xf0);\n    archiveFile = (char **)bfd_openr_next_archived_file(archiveFilePtr,outputFile);\n    bfd_close(outputFile);\n    while ((status == 0 && (archiveFile != (char **)0x0))) {\n      filePath = *archiveFile;\n      currentChar = filePath;\n      if (*filePath == '/') {\nLAB_0010527d:\n        errorMessage = dcgettext(0,\"illegal pathname found in archive member: %s\",5);\n        non_fatal(errorMessage,filePath);\n        goto LAB_00104e93;\n      }\n      while (*currentChar != '\\0') {\n        tempPtr = currentChar;\n        if ((*currentChar == '.') && (tempPtr = currentChar + 1, currentChar[1] == '.')) {\n          tempPtr = currentChar + 2;\n          if ((currentChar[2] == '\\0') || (currentChar[2] == '/')) goto LAB_0010527d;\n        }\n        for (; (*tempPtr != '\\0' && (*tempPtr != '/')); tempPtr = tempPtr + 1) {\n        }\n        currentChar = tempPtr;\n        if (*tempPtr == '/') {\n          extract_and_copy_archived_files_001052a2();\n          return;\n        }\n      }\n      fileStats = (stat *)&stack0x00000050;\n      inputFile = (char *)concat(tempDir,&DAT_0011b47d);\n      archType = stat(inputFile,fileStats);\n      tempDirData = tempData;\n      if (-1 < archType) {\n        fileSize = make_tempdir(inputFile);\n        free(inputFile);\n        if (fileSize == 0) {\n          errorNum = __errno_location();\n          filePath = strerror(*errorNum);\n          errorMessage = dcgettext(0,\"cannot create tempdir for archive copying (error: %s)\",5);\n          non_fatal(errorMessage,filePath);\n          goto LAB_00104e93;\n        }\n        tempDirData = (undefined8 *)xmalloc(0x18);\n        filePath = *archiveFile;\n        *tempDirData = tempData;\n        tempDirData[2] = 0;\n        tempDirData[1] = fileSize;\n        inputFile = (char *)concat(fileSize,&DAT_0011b47d,filePath);\n      }\n      preserveDates = 0;\n      if (preserve_dates != '\\0') {\n        tempStats = fileStats;\n        for (fileSize = 0x24; fileSize != 0; fileSize = fileSize + -1) {\n          *(undefined4 *)&tempStats->st_dev = 0;\n          tempStats = (stat *)((long)tempStats + (ulong)stackByte * -8 + 4);\n        }\n        outputFile = (char **)archiveFile[0x1d];\n        if ((char **)archiveFile[0x1d] == (char **)0x0) {\n          outputFile = archiveFile;\n        }\n        preserveDates = (**(code **)(outputFile[1] + 0x1e8))(archiveFile,fileStats);\n        if (preserveDates != 0) {\n          filePath = *archiveFile;\n          errorMessage = dcgettext(0,\"internal stat error on %s\",5);\n          non_fatal(errorMessage,filePath);\n        }\n      }\n      tempData = (undefined8 *)xmalloc(0x18);\n      tempData[1] = inputFile;\n      *tempData = tempDirData;\n      tempData[2] = 0;\n      result = bfd_check_format(archiveFile,1);\n      if (result != '\\0') {\n        if (additionalFlag._7_1_ != '\\0') goto code_r0x00104ea2;\n        outputFile = (char **)bfd_openw(inputFile,*(undefined8 *)archiveFile[1]);\n        if (outputFile == (char **)0x0) goto LAB_00104e80;\n        goto LAB_00114a5f;\n      }\n      errorMessage = dcgettext(0,\"Unable to recognise the format of file\",5);\n      bfd_nonfatal_message(0,archiveFile,0,errorMessage);\n      outputFile = (char **)bfd_openw(inputFile,openFlags);\n      if (outputFile == (char **)0x0) goto LAB_00104e80;\nLAB_00104d75:\n      archPtr = (char **)archiveFile[0x1d];\n      if ((char **)archiveFile[0x1d] == (char **)0x0) {\n        archPtr = archiveFile;\n      }\n      archType = (**(code **)(archPtr[1] + 0x1e8))(archiveFile);\n      fileSize = archiveSize;\n      if (archType == 0) {\n        if (archiveSize < 0) {\n          bfd_get_archive_filename(archiveFile);\n          errorMessage = dcgettext(0,\"stat returns negative size for `%s\\'\",5);\n          non_fatal(errorMessage);\n        }\n        else {\n          archType = bfd_seek(archiveFile,0,0);\n          if (archType == 0) {\n            if (verbose != '\\0') {\n              filePath = *outputFile;\n              errorMessage = bfd_get_archive_filename(archiveFile);\n              currentChar = (char *)dcgettext(0,\"copy from `%s\\' [unknown] to `%s\\' [unknown]\\n\",5);\n              printf(currentChar,errorMessage,filePath);\n            }\n            buffer = (void *)xmalloc(0x2000);\n            while( true ) {\n              if (fileSize == 0) {\n                chmod(*outputFile,timeStamp | 0x100);\n                free(buffer);\n                result = bfd_close_all_done(outputFile);\n                outputFile = archiveFile;\n                if (result == '\\0') {\n                  bfd_nonfatal_message(inputFile,0,0,0);\n                  status = 1;\n                }\n                goto LAB_00114a86;\n              }\n              bytesWritten = 0x2000;\n              if (fileSize < 0x2001) {\n                bytesWritten = fileSize;\n              }\n              bytesRead = bfd_bread(buffer,bytesWritten,archiveFile);\n              archPtr = archiveFile;\n              if ((bytesWritten != bytesRead) ||\n                 (bytesRead = bfd_bwrite(buffer,bytesWritten,outputFile), archPtr = outputFile, bytesWritten != bytesRead))\n              break;\n              fileSize = fileSize - bytesWritten;\n            }\n            bfd_nonfatal_message(0,archPtr,0,0);\n            free(buffer);\n          }\n          else {\n            errorMessage = bfd_get_archive_filename(archiveFile);\n            bfd_nonfatal(errorMessage);\n          }\n        }\n      }\n      else {\n        bfd_nonfatal_message(0,archiveFile,0,0);\n      }\n      result = bfd_close_all_done(outputFile);\n      if (result == '\\0') {\n        bfd_nonfatal_message(inputFile,0,0,0);\n      }\nLAB_00104ec9:\n      unlink(inputFile);\n      status = 1;\n    }\n    *fileSizePtr = 0;\n    buffer = (void *)xstrdup(*inputFilePtr);\n    if (status == 0) {\n      closeFunction = bfd_close;\n    }\n    else {\n      closeFunction = bfd_close_all_done;\n    }\n    result = (*closeFunction)(inputFilePtr);\n    if (result == '\\0') {\n      status = 1;\n      bfd_nonfatal_message(buffer,0,0,0);\n    }\n    free(buffer);\n    buffer = (void *)xstrdup(*archiveFilePtr);\n    result = bfd_close(archiveFilePtr);\n    if (result == '\\0') {\n      status = 1;\n      bfd_nonfatal_message(buffer,0,0,0);\n    }\n    free(buffer);\n  }\n  while (tempData != (undefined8 *)0x0) {\n    if (tempData[2] == 0) {\n      rmdir((char *)tempData[1]);\n    }\n    else {\n      bfd_close();\n      unlink((char *)tempData[1]);\n    }\n    free((void *)tempData[1]);\n    tempDirData = (undefined8 *)*tempData;\n    free(tempData);\n    tempData = tempDirData;\n  }\n  rmdir(tempDir);\n  free(tempDir);\n  return;\n}\n\n",
            "called": [
                "rmdir",
                "stat",
                "strerror",
                "bfd_openr",
                "FUN_001052a2",
                "bfd_get_arch",
                "bfd_close_all_done",
                "concat",
                "dcgettext",
                "printf",
                "bfd_bread",
                "FUN_00114b84",
                "bfd_nonfatal_message",
                "FUN_00104ea2",
                "bfd_close_all_done",
                "bfd_get_archive_filename",
                "non_fatal",
                "chmod",
                "free",
                "bfd_seek",
                "copy_object",
                "xstrdup",
                "bfd_bwrite",
                "bfd_check_format",
                "bfd_openw",
                "bfd_openr_next_archived_file",
                "bfd_close",
                "make_tempdir",
                "xmalloc",
                "bfd_nonfatal",
                "set_times",
                "bfd_close",
                "__errno_location",
                "unlink"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104ea2",
            "calling": [
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "extract_and_copy_archived_files_00104ea2"
        },
        "FUN_001044a0": {
            "renaming": {},
            "code": "\nvoid htab_find_slot(void)\n\n{\n  htab_find_slot();\n  return;\n}\n\n",
            "called": [
                "htab_find_slot"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001044a0",
            "calling": [
                "FUN_00104cc1",
                "main",
                "add_redefine_and_check"
            ],
            "imported": false,
            "current_name": "FUN_001044a0"
        },
        "FUN_001046e0": {
            "renaming": {},
            "code": "\nvoid bfd_set_error_program_name(void)\n\n{\n  bfd_set_error_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001046e0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001046e0"
        },
        "FUN_001045c0": {
            "renaming": {},
            "code": "\n\n\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "malloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001045c0",
            "calling": [
                "main",
                "parse_stab_type"
            ],
            "imported": false,
            "current_name": "FUN_001045c0"
        },
        "FUN_00113ce0": {
            "renaming": {
                "FUN_00113ce0": "create_debug_struct_00113ce0",
                "param_1": "input_value_1",
                "param_2": "input_value_2",
                "param_3": "input_value_3",
                "param_4": "input_value_4",
                "param_5": "input_value_5",
                "lVar1": "debug_struct_ptr",
                "plVar2": "allocated_memory_ptr",
                "auVar3": "result",
                "xmalloc": "allocate_memory",
                "debug_make_type_constprop_0": "create_debug_type"
            },
            "code": "\nundefined  [16]\ncreate_debug_struct_00113ce0(long input_value_1,long input_value_2,undefined input_value_3,undefined8 input_value_4,undefined8 input_value_5)\n\n{\n  long debug_struct_ptr;\n  long *allocated_memory_ptr;\n  undefined result [16];\n  \n  if (input_value_1 != 0) {\n    debug_struct_ptr = create_debug_type(0xd,0);\n    if (debug_struct_ptr != 0) {\n      allocated_memory_ptr = (long *)allocate_memory(0x18);\n      *(undefined4 *)((long)allocated_memory_ptr + 0x11) = 0;\n      *allocated_memory_ptr = input_value_1;\n      *(undefined4 *)((long)allocated_memory_ptr + 0x14) = 0;\n      allocated_memory_ptr[1] = input_value_2;\n      *(undefined *)(allocated_memory_ptr + 2) = input_value_3;\n      *(long **)(debug_struct_ptr + 0x10) = allocated_memory_ptr;\n      goto LAB_00113d2f;\n    }\n  }\n  debug_struct_ptr = 0;\nLAB_00113d2f:\n  result._8_8_ = input_value_5;\n  result._0_8_ = debug_struct_ptr;\n  return result;\n}\n\n",
            "called": [
                "debug_make_type.constprop.0",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113ce0",
            "calling": [
                "stab_demangle_v3_arg",
                "parse_coff_type.lto_priv.0",
                "parse_stab",
                "parse_stab_type",
                "stab_demangle_type.lto_priv.0"
            ],
            "imported": false,
            "current_name": "create_debug_struct_00113ce0"
        },
        "FUN_00114dc7": {
            "renaming": {
                "FUN_00114dc7": "read_and_resize_buffer_00114dc7",
                "unaff_RBX": "file",
                "unaff_RBP": "bufferAddress",
                "unaff_R12": "readOffset",
                "unaff_R14": "bufferSize",
                "iVar1": "errorStatus",
                "sVar4": "bytesRead",
                "uVar2": "errorMessage",
                "uVar3": "translatedErrorMessage"
            },
            "code": "\nvoid readAndResizeBuffer_00114dc7(void)\n\n{\n  int errorStatus;\n  undefined8 errorMessage;\n  undefined8 translatedErrorMessage;\n  size_t bytesRead;\n  FILE *file;\n  long bufferAddress;\n  long readOffset;\n  long bufferSize;\n  \n  while( true ) {\n    bytesRead = fread((void *)(*(long *)(bufferAddress + 0x20) + readOffset),1,bufferSize - readOffset,\n                  file);\n    errorStatus = ferror(file);\n    if (errorStatus != 0) {\n      translatedErrorMessage = *(undefined8 *)(bufferAddress + 0x10);\n      errorMessage = dcgettext(0,\"%s: fread failed\",5);\n                    \n      fatal(errorMessage,translatedErrorMessage);\n    }\n    readOffset = readOffset + bytesRead;\n    errorStatus = feof(file);\n    if (errorStatus != 0) break;\n    if (readOffset == bufferSize) {\n      bufferSize = readOffset * 2;\n      translatedErrorMessage = xrealloc(*(undefined8 *)(bufferAddress + 0x20),bufferSize);\n      *(undefined8 *)(bufferAddress + 0x20) = translatedErrorMessage;\n    }\n  }\n  *(long *)(bufferAddress + 0x18) = readOffset;\n  fclose(file);\n  return;\n}\n\n",
            "called": [
                "fclose",
                "dcgettext",
                "ferror",
                "xrealloc",
                "feof",
                "fread",
                "FUN_00114dc7",
                "fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114dc7",
            "calling": [
                "FUN_00114dc7"
            ],
            "imported": false,
            "current_name": "read_and_resize_buffer_00114dc7"
        },
        "FUN_00116b80": {
            "renaming": {},
            "code": "\nvoid register_tm_clones(void)\n\n{\n  register_tm_clones();\n  return;\n}\n\n",
            "called": [
                "register_tm_clones"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116b80",
            "calling": [],
            "imported": false,
            "current_name": "FUN_00116b80"
        },
        "FUN_00119f70": {
            "renaming": {
                "FUN_00119f70": "header_processing_00119f70",
                "param_1": "header_data",
                "param_2": "metadata",
                "uVar1": "format_version",
                "cVar2": "success_flag",
                "iVar3": "architecture_counter",
                "uVar4": "formatted_endian1",
                "uVar5": "formatted_endian2",
                "__format": "info_format",
                "lVar6": "buffer_size",
                "uVar7": "header_value",
                "lVar8": "reallocated_buffer"
            },
            "code": "\nundefined4 header_processing_00119f70(undefined8 *header_data,undefined8 *metadata)\n\n{\n  undefined4 format_version;\n  char success_flag;\n  int architecture_counter;\n  undefined8 formatted_endian1;\n  undefined8 formatted_endian2;\n  char *info_format;\n  long buffer_size;\n  undefined8 header_value;\n  long reallocated_buffer;\n  \n  architecture_counter = *(int *)((long)metadata + 0xc) + 1;\n  *(int *)((long)metadata + 0xc) = architecture_counter;\n  if ((ulong)metadata[2] < (ulong)((long)architecture_counter * 0x60)) {\n    buffer_size = 0x3000;\n    if (0x3f < architecture_counter) {\n      buffer_size = (long)architecture_counter * 0xc0;\n    }\n    reallocated_buffer = xrealloc(metadata[3]);\n    metadata[3] = reallocated_buffer;\n    memset((void *)(reallocated_buffer + metadata[2]),0,buffer_size - metadata[2]);\n    metadata[2] = buffer_size;\n  }\n  format_version = *(undefined4 *)((long)header_data + 0xc);\n  *(undefined8 *)((long)*(int *)((long)metadata + 0xc) * 0x60 + metadata[3] + -0x60) = *header_data;\n  formatted_endian1 = endian_string(format_version);\n  formatted_endian2 = endian_string(*(undefined4 *)(header_data + 2));\n  header_value = *header_data;\n  info_format = (char *)dcgettext(0,\"%s\\n (header %s, data %s)\\n\",5);\n  printf(info_format,header_value,formatted_endian2,formatted_endian1);\n  buffer_size = bfd_openw(*metadata,*header_data);\n  if (buffer_size == 0) {\n    bfd_nonfatal(*metadata);\n    *(undefined4 *)(metadata + 1) = 1;\n  }\n  else {\n    architecture_counter = 2;\n    success_flag = bfd_set_format(buffer_size,1);\n    if (success_flag == '\\0') {\n      architecture_counter = bfd_get_error();\n      if (architecture_counter != 5) {\n        bfd_nonfatal(*header_data);\n        *(undefined4 *)(metadata + 1) = 1;\n      }\n    }\n    else {\n      do {\n        success_flag = (**(code **)(*(long *)(buffer_size + 8) + 0x2a0))(buffer_size,architecture_counter,0);\n        if (success_flag != '\\0') {\n          header_value = bfd_printable_arch_mach(architecture_counter,0);\n          printf(\"  %s\\n\",header_value);\n          *(undefined *)\n           ((long)*(int *)((long)metadata + 0xc) * 0x60 + metadata[3] + -0x58 + (ulong)(architecture_counter - 2)) =\n               1;\n        }\n        architecture_counter = architecture_counter + 1;\n      } while (architecture_counter != 0x57);\n    }\n    bfd_close_all_done(buffer_size);\n  }\n  return *(undefined4 *)(metadata + 1);\n}\n\n",
            "called": [
                "bfd_get_error",
                "dcgettext",
                "printf",
                "bfd_openw",
                "bfd_printable_arch_mach",
                "endian_string",
                "do_display_target.cold",
                "bfd_set_format",
                "xrealloc",
                "memset",
                "bfd_close_all_done",
                "bfd_nonfatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00119f70",
            "calling": [
                "display_info.isra.0"
            ],
            "imported": false,
            "current_name": "header_processing_00119f70"
        },
        "FUN_00128150": {
            "renaming": {},
            "code": "\n\n\n\nsize_t strlen(char *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strlen@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128150",
            "calling": [
                "strlen"
            ],
            "imported": false,
            "current_name": "FUN_00128150"
        },
        "FUN_00128030": {
            "renaming": {},
            "code": "\n\n\n\nint strcasecmp(char *__s1,char *__s2)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcasecmp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128030",
            "calling": [
                "strcasecmp"
            ],
            "imported": false,
            "current_name": "FUN_00128030"
        },
        "FUN_00104080": {
            "renaming": {},
            "code": "\n\n\nint strcasecmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = strcasecmp(__s1,__s2);\n  return iVar1;\n}\n\n",
            "called": [
                "strcasecmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104080",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00104080"
        },
        "FUN_00115a90": {
            "renaming": {
                "FUN_00115a90": "copy_file_contents_00115a90",
                "param_1": "file_descriptor",
                "param_2": "source_file",
                "param_3": "copy_params",
                "iVar1": "original_errno",
                "__fd": "destination_file_descriptor",
                "iVar2": "bytes_read",
                "_Var3": "file_position",
                "uVar4": "total_bytes_copied",
                "sVar5": "bytes_written",
                "piVar6": "errno_pointer",
                "local_2038": "buffer"
            },
            "code": "\nulong copy_file_contents_00115a90(int file_descriptor,char *source_file,long copy_params)\n\n{\n  int original_errno;\n  int destination_file_descriptor;\n  int bytes_read;\n  __off_t file_position;\n  ulong total_bytes_copied;\n  size_t bytes_written;\n  int *errno_pointer;\n  undefined buffer [8200];\n  \n  if ((-1 < file_descriptor) && (file_position = lseek(file_descriptor,0,0), file_position == 0)) {\n    destination_file_descriptor = open(source_file,0x201);\n    if (destination_file_descriptor < 0) {\n      total_bytes_copied = simple_copy_cold();\n      return total_bytes_copied;\n    }\n    do {\n      total_bytes_copied = read(file_descriptor,buffer,0x2000);\n      bytes_read = (int)total_bytes_copied;\n      if (bytes_read < 1) {\n        errno_pointer = __errno_location();\n        original_errno = *errno_pointer;\n        fchmod(destination_file_descriptor,*(__mode_t *)(copy_params + 0x18));\n        close(file_descriptor);\n        close(destination_file_descriptor);\n        if (bytes_read != 0) {\n          *errno_pointer = original_errno;\n          return 0xffffffff;\n        }\n        return total_bytes_copied & 0xffffffff;\n      }\n      bytes_written = write(destination_file_descriptor,buffer,(long)bytes_read);\n    } while (bytes_written == (long)bytes_read);\n    errno_pointer = __errno_location();\n    bytes_read = *errno_pointer;\n    close(file_descriptor);\n    close(destination_file_descriptor);\n    *errno_pointer = bytes_read;\n  }\n  return 0xffffffff;\n}\n\n",
            "called": [
                "close",
                "lseek",
                "fchmod",
                "write",
                "simple_copy.cold",
                "open",
                "read",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115a90",
            "calling": [
                "smart_rename"
            ],
            "imported": false,
            "current_name": "copy_file_contents_00115a90"
        },
        "FUN_00128390": {
            "renaming": {},
            "code": "\n\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* setlocale@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128390",
            "calling": [
                "setlocale"
            ],
            "imported": false,
            "current_name": "FUN_00128390"
        },
        "FUN_00128158": {
            "renaming": {},
            "code": "\n\n\nvoid getopt_long(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getopt_long@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00128158",
            "calling": [
                "getopt_long"
            ],
            "imported": false,
            "current_name": "FUN_00128158"
        },
        "FUN_00108200": {
            "renaming": {
                "FUN_00108200": "copy_file_and_set_times_00108200",
                "piVar1": "error_location_ptr",
                "uVar2": "error_message",
                "unaff_RBP": "file_path",
                "unaff_R12B": "should_set_times",
                "unaff_R13": "timestamp",
                "auVar3": "result"
            },
            "code": "\nundefined  [16] copy_file_and_set_times_00108200(void)\n\n{\n  int *error_location_ptr;\n  undefined8 error_message;\n  char *file_path;\n  char should_set_times;\n  ulong timestamp;\n  undefined result [16];\n  undefined8 unaff_retaddr;\n  \n  error_location_ptr = __errno_location();\n  strerror(*error_location_ptr);\n  error_message = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n  non_fatal(error_message);\n  unlink(file_path);\n  if (should_set_times != '\\0') {\n    set_times();\n  }\n  result._0_8_ = timestamp & 0xffffffff;\n  result._8_8_ = unaff_retaddr;\n  return result;\n}\n\n",
            "called": [
                "strerror",
                "dcgettext",
                "non_fatal",
                "set_times",
                "__errno_location",
                "unlink"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108200",
            "calling": [
                "smart_rename"
            ],
            "imported": false,
            "current_name": "copy_file_and_set_times_00108200"
        }
    },
    "used_tokens": 267592,
    "layers": [
        [
            "FUN_00113dfe",
            "FUN_0010ab4d",
            "FUN_0010c218",
            "FUN_0010be88",
            "FUN_0010ba08",
            "FUN_0010aa53",
            "FUN_0011173a",
            "FUN_00115dc0",
            "FUN_0010d559",
            "FUN_00119e70",
            "FUN_00108466",
            "FUN_00108e76",
            "FUN_0010bb52",
            "FUN_0011283f",
            "FUN_00108237",
            "FUN_0010bc80",
            "FUN_00114cf0",
            "FUN_0010a181",
            "FUN_001199d0",
            "FUN_0010d21c",
            "FUN_001054af",
            "FUN_0010c139",
            "FUN_0010e439",
            "FUN_00109d3e",
            "FUN_00112502",
            "FUN_00113bfa",
            "FUN_00108375",
            "FUN_00109e76",
            "FUN_001088ae",
            "FUN_0010afd5",
            "FUN_00108b3e",
            "FUN_0010a083",
            "FUN_00109c2e",
            "FUN_001053b5",
            "FUN_00112996",
            "FUN_0010c7a0",
            "FUN_001052a2",
            "FUN_0010e453",
            "FUN_00109d5c",
            "FUN_0010ed2c",
            "FUN_0011a1b0",
            "FUN_00108a2a",
            "FUN_00108c86",
            "FUN_0010911f",
            "FUN_001053d5",
            "FUN_00104bba",
            "FUN_00109a0b",
            "FUN_0010da0b",
            "FUN_00112894",
            "FUN_00109b2f",
            "FUN_00108d9a",
            "FUN_0010e9a0",
            "FUN_0010827b",
            "FUN_00104920",
            "FUN_00113f20",
            "FUN_00116aa0",
            "FUN_00109022",
            "FUN_0010c05d",
            "FUN_00109d97",
            "FUN_0010add5",
            "FUN_00113e17",
            "FUN_00109b52",
            "FUN_00109a32",
            "FUN_0010c6be",
            "FUN_0010b6ea",
            "FUN_0011a2e0",
            "FUN_0010e8a9",
            "FUN_00104ad6",
            "FUN_001087da",
            "FUN_0010914e",
            "FUN_00104943",
            "FUN_00113e23",
            "FUN_00108fb9",
            "FUN_00108ea1",
            "FUN_0010a2b9",
            "FUN_0010ec73",
            "FUN_00114e00",
            "FUN_00115970",
            "FUN_0010adf2",
            "FUN_0010d7d4",
            "FUN_00113f50",
            "FUN_001087fd",
            "FUN_0011256b",
            "FUN_0011378f",
            "FUN_00104966",
            "FUN_0010a0a0",
            "FUN_00119ed0",
            "FUN_0010808f",
            "FUN_00108fe8",
            "FUN_00105828",
            "FUN_0011a0e0",
            "FUN_0010bba1",
            "FUN_0010e6a8",
            "FUN_0010e7c2",
            "FUN_00119dd0",
            "FUN_001083b7",
            "FUN_00116852",
            "FUN_00113d3a",
            "FUN_0010a0d3",
            "FUN_0010a0bd",
            "FUN_00113e5e",
            "FUN_0010abdd",
            "FUN_00115f30",
            "FUN_001129f4",
            "FUN_001082b3",
            "FUN_0010b800",
            "FUN_00109ed3",
            "FUN_0010bbd3",
            "FUN_00115d00",
            "FUN_00113c43",
            "FUN_00112a33",
            "FUN_0010c2d2",
            "FUN_0010e07c",
            "FUN_001082c3",
            "FUN_0010a94e",
            "FUN_00113b1e",
            "FUN_0010a0e9",
            "FUN_00114c20",
            "FUN_00115f50",
            "FUN_001083de",
            "FUN_0010b948",
            "FUN_0010a83e",
            "FUN_00113d6e",
            "FUN_00114d50",
            "FUN_00108916",
            "FUN_001126c0",
            "FUN_00113b4a",
            "FUN_0010edb4",
            "FUN_0010e5db",
            "FUN_00108800",
            "FUN_0010c1c6",
            "FUN_001082df",
            "FUN_00114d60",
            "FUN_00108808",
            "FUN_00104d1c",
            "FUN_00119940",
            "FUN_0010540e",
            "FUN_001081e9",
            "FUN_00113b71",
            "FUN_00109dfe",
            "FUN_00109bbb",
            "FUN_0010ae0e",
            "FUN_001135a5",
            "FUN_00104c36",
            "FUN_0010554f",
            "FUN_00109cf4",
            "FUN_00109ab1",
            "FUN_001159d0",
            "FUN_0010a77a",
            "FUN_0010543c",
            "FUN_0010a424",
            "FUN_00119970",
            "FUN_00114c80",
            "FUN_0010870e",
            "FUN_00113fb0",
            "FUN_0010882c",
            "FUN_0010ebb0",
            "FUN_00113b98",
            "FUN_00115d70",
            "FUN_00104000",
            "FUN_00109be3",
            "FUN_0011a480",
            "FUN_0010e918",
            "FUN_0010871c",
            "FUN_0010bf20",
            "FUN_0011a350",
            "FUN_0011a110",
            "FUN_0010e2f0",
            "FUN_00113fe0",
            "FUN_001125fa",
            "FUN_00108f05",
            "FUN_00108863",
            "FUN_00104020",
            "FUN_00108f08",
            "FUN_00114b84",
            "FUN_00114190",
            "FUN_00104a35",
            "FUN_0010be1a",
            "FUN_00113da9",
            "FUN_0011a250",
            "FUN_0010a69a",
            "FUN_00116b40",
            "FUN_00116030",
            "FUN_00113ede",
            "FUN_0010875d",
            "FUN_0010c892",
            "FUN_00112904",
            "FUN_00108898",
            "FUN_0011a390",
            "FUN_0010e842",
            "FUN_00113cb9",
            "FUN_0010eafe",
            "FUN_00113df2",
            "FUN_0010a377",
            "FUN_0010d882",
            "FUN_00112925",
            "FUN_0010bf86",
            "FUN_0011a170",
            "FUN_0010bd62",
            "FUN_00113ce0",
            "FUN_00114dc7",
            "FUN_00119f70",
            "FUN_00115a90",
            "FUN_00108200"
        ],
        [
            "FUN_00104cc1",
            "FUN_00108179",
            "FUN_0010829e",
            "FUN_00114690",
            "FUN_00114460",
            "FUN_00104d25",
            "FUN_0010551d",
            "FUN_00116110",
            "FUN_00104ea2"
        ],
        [
            "FUN_00108072",
            "FUN_00115530",
            "FUN_00115b70"
        ],
        [
            "FUN_0010922b",
            "FUN_00112c1f",
            "FUN_00112b6e",
            "FUN_00113a4d",
            "FUN_0010b0fa",
            "FUN_0010dac0",
            "FUN_0010c95e"
        ],
        [
            "FUN_00116490"
        ],
        [
            "FUN_0010847a",
            "FUN_001163d0"
        ]
    ],
    "locked_functions": []
}