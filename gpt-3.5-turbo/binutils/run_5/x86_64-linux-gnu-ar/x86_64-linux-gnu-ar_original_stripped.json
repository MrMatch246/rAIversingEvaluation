{
    "functions": {
        "FUN_00102cd9": {
            "renaming": {
                "FUN_00102cd9": "find_matching_entry_00102cd9",
                "in_EAX": "inputValue",
                "iVar1": "comparisonResult",
                "unaff_RBX": "entryPointer",
                "param_7": "searchString"
            },
            "code": "\nlong * findMatchingEntry_00102cd9(void)\n\n{\n  int inputValue;\n  int comparisonResult;\n  long *entryPointer;\n  undefined8 searchString;\n  \n  searchString = posname;\n  if (inputValue == 3) {\n    for (; *entryPointer != 0; entryPointer = (long *)(*entryPointer + 0xf0)) {\n    }\n  }\n  else {\n    for (; (undefined8 *)*entryPointer != (undefined8 *)0x0; entryPointer = (long *)(*entryPointer + 0xf0)) {\n      comparisonResult = filename_cmp(*(undefined8 *)*entryPointer,searchString);\n      if (comparisonResult == 0) {\n        if (inputValue != 2) {\n          return entryPointer;\n        }\n        return (long *)(*entryPointer + 0xf0);\n      }\n    }\n  }\n  return entryPointer;\n}\n\n",
            "called": [
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102cd9",
            "calling": [
                "get_pos_bfd"
            ],
            "imported": false,
            "current_name": "find_matching_entry_00102cd9"
        },
        "FUN_001021b0": {
            "renaming": {},
            "code": "\nvoid xrealloc(void)\n\n{\n  xrealloc();\n  return;\n}\n\n",
            "called": [
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021b0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001021b0"
        },
        "FUN_001079c0": {
            "renaming": {
                "FUN_001079c0": "print_file_info_001079c0",
                "param_1": "filePtr",
                "param_2": "fileInfoPtr",
                "param_3": "includeHeader",
                "param_4": "includeAddress",
                "iVar1": "status",
                "ppcVar2": "fileInfoPtr2",
                "pcVar3": "timeString",
                "uVar4": "fileType",
                "local_100": "currentTimestamp",
                "uStack_f3": "filePermissionSymbol",
                "cStack_f2": "isOwnerReadable",
                "cStack_f1": "isOwnerWritable",
                "cStack_f0": "isOwnerExecutable",
                "cStack_ef": "isGroupReadable",
                "cStack_ee": "isGroupWritable",
                "cStack_ed": "isGroupExecutable",
                "cStack_ec": "isOtherReadable",
                "cStack_eb": "isOtherWritable",
                "cStack_ea": "isOtherExecutable",
                "local_e8": "timeFormatted",
                "local_b8": "otherData",
                "uStack_a0": "fileMode",
                "uStack_9c": "userID",
                "uStack_98": "groupID",
                "uStack_88": "fileSize",
                "local_60": "createTime"
            },
            "code": "\nvoid printFileInfo_001079c0(FILE *filePtr,char **fileInfoPtr,char includeHeader,char includeAddress)\n\n{\n  int status;\n  char **fileInfoPtr2;\n  char *timeString;\n  uint fileType;\n  time_t currentTimestamp;\n  undefined filePermissionSymbol;\n  char isOwnerReadable;\n  char isOwnerWritable;\n  char isOwnerExecutable;\n  char isGroupReadable;\n  char isGroupWritable;\n  char isGroupExecutable;\n  char isOtherReadable;\n  char isOtherWritable;\n  char isOtherExecutable;\n  undefined uStack_e9;\n  char timeFormatted [48];\n  undefined otherData [24];\n  uint fileMode;\n  uint userID;\n  uint groupID;\n  undefined8 fileSize;\n  time_t createTime;\n  \n  if (includeHeader != '\\0') {\n    fileInfoPtr2 = (char **)fileInfoPtr[0x1d];\n    if ((char **)fileInfoPtr[0x1d] == (char **)0x0) {\n      fileInfoPtr2 = fileInfoPtr;\n    }\n    status = (**(code **)(fileInfoPtr2[1] + 0x1e8))(fileInfoPtr,otherData);\n    if (status == 0) {\n      currentTimestamp = createTime;\n      timeString = ctime(&currentTimestamp);\n      if (timeString == (char *)0x0) {\n        timeString = (char *)dcgettext(0,\"<time data corrupt>\",5);\n        sprintf(timeFormatted,timeString);\n      }\n      else {\n        sprintf(timeFormatted,\"%.12s %.4s\",timeString + 4);\n      }\n      fileType = fileMode & 0xf000;\n      if (fileType == 0x4000) {\n        filePermissionSymbol = 100;\n      }\n      else if (fileType == 0xa000) {\n        filePermissionSymbol = 0x6c;\n      }\n      else if (fileType == 0x6000) {\n        filePermissionSymbol = 0x62;\n      }\n      else if (fileType == 0x2000) {\n        filePermissionSymbol = 99;\n      }\n      else if (fileType == 0xc000) {\n        filePermissionSymbol = 0x73;\n      }\n      else {\n        filePermissionSymbol = 0x70;\n        if (fileType != 0x1000) {\n          filePermissionSymbol = 0x2d;\n        }\n      }\n      isOwnerReadable = (-((fileMode & 0x100) == 0) & 0xbbU) + 0x72;\n      isOwnerWritable = (-((fileMode & 0x80) == 0) & 0xb6U) + 0x77;\n      isOwnerExecutable = (-((fileMode & 0x40) == 0) & 0xb5U) + 0x78;\n      isGroupReadable = (-((fileMode & 0x20) == 0) & 0xbbU) + 0x72;\n      isGroupWritable = (-((fileMode & 0x10) == 0) & 0xb6U) + 0x77;\n      isGroupExecutable = (-((fileMode & 8) == 0) & 0xb5U) + 0x78;\n      isOtherReadable = (-((fileMode & 4) == 0) & 0xbbU) + 0x72;\n      isOtherWritable = (-((fileMode & 2) == 0) & 0xb6U) + 0x77;\n      isOtherExecutable = (-((fileMode & 1) == 0) & 0xb5U) + 0x78;\n      if ((fileMode & 0x800) != 0) {\n        if (isOwnerExecutable == 'x') {\n          isOwnerExecutable = 's';\n        }\n        else {\n          isOwnerExecutable = 'S';\n        }\n      }\n      if ((fileMode & 0x400) != 0) {\n        if (isGroupExecutable == 'x') {\n          isGroupExecutable = 's';\n        }\n        else {\n          isGroupExecutable = 'S';\n        }\n      }\n      if ((fileMode & 0x200) != 0) {\n        if (isOtherExecutable == 'x') {\n          isOtherExecutable = 't';\n        }\n        else {\n          isOtherExecutable = 'T';\n        }\n      }\n      uStack_e9 = 0;\n      fprintf(filePtr,\"%s %ld/%ld %6lu %s \",&isOwnerReadable,(ulong)userID,(ulong)groupID,fileSize,\n              timeFormatted,(ulong)fileMode);\n    }\n  }\n  fputs(*fileInfoPtr,filePtr);\n  if (includeAddress != '\\0') {\n    if ((*(byte *)((long)fileInfoPtr + 0x49) & 0x10) == 0) {\n      if (fileInfoPtr[0xb] != (char *)0x0) {\n        fprintf(filePtr,\" 0x%lx\");\n      }\n    }\n    else if (fileInfoPtr[0xc] != (char *)0x0) {\n      fprintf(filePtr,\" 0x%lx\");\n    }\n  }\n  fputc(10,filePtr);\n  return;\n}\n\n",
            "called": [
                "print_arelt_descr.cold",
                "ctime",
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001079c0",
            "calling": [
                "ar_directory_doer",
                "print_descr"
            ],
            "imported": false,
            "current_name": "print_file_info_001079c0"
        },
        "FUN_00105a68": {
            "renaming": {
                "FUN_00105a68": "initialize_output_file_00105a68",
                "pcVar1": "outputDirectory",
                "pFVar2": "outputFile",
                "sVar3": "outputDirLength"
            },
            "code": "\nvoid initializeOutputFile_00105a68(void)\n\n{\n  char *outputDirectory;\n  FILE *outputFile;\n  size_t outputDirLength;\n  \n  outputDirectory = output_dir;\n  if (output_dir != (char *)0x0) {\n    outputDirLength = strlen(output_dir);\n    if (outputDirLength != 0) {\n      if (outputDirectory[outputDirLength - 1] == '/') {\n        output_filename = (char *)concat(outputDirectory,output_filename,0);\n      }\n      else {\n        output_filename = (char *)concat(outputDirectory,&DAT_00108260,output_filename,0);\n      }\n    }\n  }\n  if (verbose != 0) {\n    printf(\"x - %s\\n\",output_filename);\n  }\n  outputFile = fopen(output_filename,\"w\");\n  if (outputFile != (FILE *)0x0) {\n    return;\n  }\n  perror(output_filename);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "xexit",
                "strlen",
                "open_output_file.isra.0.cold",
                "perror",
                "printf",
                "fopen",
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105a68",
            "calling": [
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "initialize_output_file_00105a68"
        },
        "FUN_001022d0": {
            "renaming": {},
            "code": "\n\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = calloc(__nmemb,__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "calloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022d0",
            "calling": [
                "yyensure_buffer_stack"
            ],
            "imported": false,
            "current_name": "FUN_001022d0"
        },
        "FUN_001023f0": {
            "renaming": {},
            "code": "\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 = fseek(__stream,__off,__whence);\n  return iVar1;\n}\n\n",
            "called": [
                "fseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023f0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001023f0"
        },
        "FUN_001032a8": {
            "renaming": {
                "FUN_001032a8": "process_archived_files_001032a8",
                "param_1": "fileInfoArray",
                "param_2": "fileCallback",
                "param_3": "entryArray",
                "param_4": "returnValue",
                "lVar1": "nextFileInfo",
                "uVar2": "entry",
                "bVar3": "entryFound",
                "plVar4": "currentFileInfo",
                "iVar5": "comparisonResult",
                "__format": "errorMessage",
                "plVar6": "tempFileInfo",
                "lVar7": "initialFileInfo",
                "plVar8": "previousFileInfo"
            },
            "code": "\n\n\nundefined8 processArchivedFiles_001032a8(long *fileInfoArray,code *fileCallback,undefined8 *entryArray,undefined8 returnValue)\n\n{\n  long nextFileInfo;\n  undefined8 entry;\n  bool entryFound;\n  long *currentFileInfo;\n  int comparisonResult;\n  char *errorMessage;\n  long *tempFileInfo;\n  long initialFileInfo;\n  long *previousFileInfo;\n  \n  initialFileInfo = fileInfoArray[0x1e];\n  if (entryArray == (undefined8 *)0x0) {\n    while (initialFileInfo != 0) {\n      nextFileInfo = *(long *)(initialFileInfo + 0xf0);\n      (*fileCallback)(initialFileInfo,0);\n      initialFileInfo = nextFileInfo;\n    }\n  }\n  else {\n    do {\n      entryFound = false;\n      currentFileInfo = (long *)fileInfoArray[0x1e];\n      previousFileInfo = fileInfoArray;\n      while (tempFileInfo = currentFileInfo, tempFileInfo != (long *)0x0) {\n        if (*tempFileInfo != 0) {\n          comparisonResult = filename_cmp(*entryArray);\n          if (comparisonResult == 0) {\n            entryFound = true;\n            (*fileCallback)(tempFileInfo,previousFileInfo);\n          }\n        }\n        previousFileInfo = tempFileInfo;\n        currentFileInfo = (long *)tempFileInfo[0x1e];\n      }\n      if (!entryFound) {\n        entry = *entryArray;\n        errorMessage = (char *)dcgettext(0,\"No entry %s in archive.\\n\",5);\n        fprintf(_stderr,errorMessage,entry);\n      }\n      entryArray = (undefined8 *)entryArray[1];\n    } while (entryArray != (undefined8 *)0x0);\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "filename_cmp",
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001032a8",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "process_archived_files_001032a8"
        },
        "FUN_00102f96": {
            "renaming": {
                "FUN_00102f96": "print_error_message_00102f96",
                "unaff_RBX": "errorCode",
                "unaff_retaddr": "returnAddress",
                "uVar1": "errorMessage"
            },
            "code": "\n\n\nvoid printErrorMessage_00102f96(void)\n\n{\n  undefined8 errorMessage;\n  long errorCode;\n  undefined8 returnAddress;\n  \n  errorMessage = dcgettext(0,\"cause of error unknown\",5);\n  fflush(_stdout);\n  if (errorCode != 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",program_name);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",program_name,errorMessage,returnAddress);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fflush",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f96",
            "calling": [
                "bfd_nonfatal"
            ],
            "imported": false,
            "current_name": "print_error_message_00102f96"
        },
        "FUN_0010342d": {
            "renaming": {
                "FUN_0010342d": "print_usage_0010342d",
                "param_1": "outputToFile",
                "uVar1": "programName",
                "pcVar2": "message",
                "__stream": "outputStream"
            },
            "code": "\n\n\nvoid printUsage_0010342d(uint outputToFile)\n\n{\n  undefined8 programName;\n  char *message;\n  FILE *outputStream;\n  \n  message = (char *)dcgettext(0,\n                             \"Usage: %s [emulation options] [-]{dmpqrstx}[abcDfilMNoOPsSTuvV] [--plugin <name>] [member-name] [count] archive-file file...\\n\"\n                             ,5);\n  outputStream = _stderr;\n  if (outputToFile != 0) {\n    outputStream = _stdout;\n  }\n  fprintf(outputStream,message,program_name);\n  programName = program_name;\n  message = (char *)dcgettext(0,\"       %s -M [<mri-script]\\n\",5);\n  fprintf(outputStream,message,programName);\n  message = (char *)dcgettext(0,\" commands:\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  d            - delete file(s) from the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  m[ab]        - move file(s) in the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  p            - print file(s) found in the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  q[f]         - quick append file(s) to the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\n                             \"  r[ab][f][u]  - replace existing or insert new file(s) into the archive\\n\"\n                             ,5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  s            - act as ranlib\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  t[O][v]      - display contents of the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  x[o]         - extract file(s) from the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\" command specific modifiers:\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [a]          - put file(s) after [member-name]\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [b]          - put file(s) before [member-name] (same as [i])\\n\",5\n                            );\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [D]          - use zero for timestamps and uids/gids (default)\\n\",\n                             5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [U]          - use actual timestamps and uids/gids\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [N]          - use instance [count] of name\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [f]          - truncate inserted file names\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [P]          - use full path names when matching\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [o]          - preserve original dates\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [O]          - display offsets of files in the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\n                             \"  [u]          - only replace files that are newer than current archive contents\\n\"\n                             ,5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\" generic modifiers:\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [c]          - do not warn if the library had to be created\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [s]          - create an archive index (cf. ranlib)\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [l <text> ]  - specify the dependencies of this library\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [S]          - do not build a symbol table\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [T]          - deprecated, use --thin instead\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [v]          - be verbose\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [V]          - display the version number\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  @<file>      - read options from <file>\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  --target=BFDNAME - specify the target object format as BFDNAME\\n\",\n                             5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\n                             \"  --output=DIRNAME - specify the output directory for extraction operations\\n\"\n                             ,5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\n                             \"  --record-libdeps=<text> - specify the dependencies of this library\\n\"\n                             ,5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  --thin       - make a thin archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\" optional:\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  --plugin <p> - load the specified plugin\\n\",5);\n  fprintf(outputStream,message);\n  ar_emul_default_usage(outputStream);\n  list_supported_targets(program_name,outputStream);\n  if (outputToFile != 0) {\n    message = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(outputStream,message,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  xexit(outputToFile ^ 1);\n}\n\n",
            "called": [
                "xexit",
                "fprintf",
                "list_supported_targets",
                "ar_emul_default_usage",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010342d",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "print_usage_0010342d"
        },
        "FUN_00102110": {
            "renaming": {},
            "code": "\n\n\nssize_t write(int __fd,void *__buf,size_t __n)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = write(__fd,__buf,__n);\n  return sVar1;\n}\n\n",
            "called": [
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102110",
            "calling": [
                "simple_copy.constprop.0"
            ],
            "imported": false,
            "current_name": "FUN_00102110"
        },
        "FUN_00107920": {
            "renaming": {
                "FUN_00107920": "report_data_00107920",
                "param_1": "source1",
                "param_2": "source2",
                "param_3": "source3",
                "param_4": "source4",
                "param_5": "source5",
                "param_6": "source6",
                "param_7": "source7",
                "param_8": "source8",
                "param_9": "reportTarget",
                "param_10": "data1",
                "param_11": "data2",
                "param_12": "data3",
                "param_13": "data4",
                "param_14": "data5",
                "in_AL": "condition",
                "local_d8": "length",
                "local_d4": "size",
                "local_d0": "buffer",
                "local_c8": "localBuffer",
                "local_b8": "tempBuffer",
                "local_b0": "param10",
                "local_a8": "param11",
                "local_a0": "param12",
                "local_98": "param13",
                "local_90": "param14",
                "local_88": "source1Copy",
                "local_78": "source2Copy",
                "local_68": "source3Copy",
                "local_58": "source4Copy",
                "local_48": "source5Copy",
                "local_38": "source6Copy",
                "local_28": "source7Copy",
                "local_18": "source8Copy"
            },
            "code": "\nvoid reportData_00107920(undefined4 source1,undefined4 source2,undefined4 source3,undefined4 source4,\n                 undefined4 source5,undefined4 source6,undefined4 source7,undefined4 source8,\n                 undefined8 reportTarget,undefined8 data1,undefined8 data2,undefined8 data3,\n                 undefined8 data4,undefined8 data5)\n\n{\n  char condition;\n  undefined4 length;\n  undefined4 size;\n  undefined *buffer;\n  undefined *localBuffer;\n  undefined tempBuffer [8];\n  undefined8 param10;\n  undefined8 param11;\n  undefined8 param12;\n  undefined8 param13;\n  undefined8 param14;\n  undefined4 source1Copy;\n  undefined4 source2Copy;\n  undefined4 source3Copy;\n  undefined4 source4Copy;\n  undefined4 source5Copy;\n  undefined4 source6Copy;\n  undefined4 source7Copy;\n  undefined4 source8Copy;\n  \n  if (condition != '\\0') {\n    source1Copy = source1;\n    source2Copy = source2;\n    source3Copy = source3;\n    source4Copy = source4;\n    source5Copy = source5;\n    source6Copy = source6;\n    source7Copy = source7;\n    source8Copy = source8;\n  }\n  buffer = &stack0x00000008;\n  length = 8;\n  localBuffer = tempBuffer;\n  size = 0x30;\n  param10 = data1;\n  param11 = data2;\n  param12 = data3;\n  param13 = data4;\n  param14 = data5;\n  report(reportTarget,&length);\n  return;\n}\n\n",
            "called": [
                "report"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107920",
            "calling": [
                "open_inarch",
                "set_times.cold",
                "get_file_size.cold",
                "smart_rename.constprop.0.cold",
                "get_file_size",
                "main",
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "report_data_00107920"
        },
        "FUN_00102230": {
            "renaming": {},
            "code": "\nvoid xmalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102230",
            "calling": [
                "normalize.cold",
                "make_tempname",
                "print_contents",
                "replace_members.cold",
                "extract_file.cold",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102230"
        },
        "FUN_00102590": {
            "renaming": {},
            "code": "\nvoid __cxa_finalize(void)\n\n{\n  __cxa_finalize();\n  return;\n}\n\n",
            "called": [
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102590",
            "calling": [
                "__do_global_dtors_aux"
            ],
            "imported": false,
            "current_name": "FUN_00102590"
        },
        "FUN_00102350": {
            "renaming": {},
            "code": "\n\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n  long lVar1;\n  \n  lVar1 = strtol(__nptr,__endptr,__base);\n  return lVar1;\n}\n\n",
            "called": [
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102350",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102350"
        },
        "FUN_0010e190": {
            "renaming": {},
            "code": "\n\n\n\nint putc(int __c,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* putc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e190",
            "calling": [
                "putc"
            ],
            "imported": false,
            "current_name": "FUN_0010e190"
        },
        "FUN_00102470": {
            "renaming": {},
            "code": "\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 = fopen(__filename,__modes);\n  return pFVar1;\n}\n\n",
            "called": [
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102470",
            "calling": [
                "FUN_00105a68",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102470"
        },
        "FUN_0010e070": {
            "renaming": {},
            "code": "\n\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fread@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e070",
            "calling": [
                "fread"
            ],
            "imported": false,
            "current_name": "FUN_0010e070"
        },
        "FUN_00102e6f": {
            "renaming": {
                "FUN_00102e6f": "initialize_output_file_00102e6f",
                "in_RAX": "input_path",
                "pcVar1": "output_directory",
                "uVar2": "base_name",
                "uVar3": "error_message",
                "pFVar4": "file_pointer",
                "sVar5": "output_directory_length",
                "pcVar6": "current_char"
            },
            "code": "\nvoid initialize_output_file_00102e6f(void)\n\n{\n  char *output_directory;\n  char *input_path;\n  undefined8 base_name;\n  undefined8 error_message;\n  FILE *file_pointer;\n  size_t output_directory_length;\n  char *current_char;\n  \n  output_directory = output_dir;\n  do {\n    input_path = input_path + 1;\n    while (*input_path != '/') {\n      if (*input_path == '\\0') {\n        if ((output_dir != (char *)0x0) && (output_directory_length = strlen(output_dir), output_directory_length != 0)) {\n          if (output_directory[output_directory_length - 1] == '/') {\n            output_filename = (char *)concat(output_directory,output_filename,0);\n          }\n          else {\n            output_filename = (char *)concat(output_directory,&DAT_00108260,output_filename,0);\n          }\n        }\n        if (verbose != 0) {\n          printf(\"x - %s\\n\",output_filename);\n        }\n        file_pointer = fopen(output_filename,\"w\");\n        if (file_pointer == (FILE *)0x0) {\n          perror(output_filename);\n                    \n          xexit(1);\n        }\n        return;\n      }\n      current_char = input_path;\n      if ((*input_path == '.') && (current_char = input_path + 1, input_path[1] == '.')) {\n        current_char = input_path + 2;\n        if ((input_path[2] == '/') || (input_path[2] == '\\0')) {\n          base_name = lbasename();\n          output_directory = output_filename;\n          error_message = dcgettext(0,\"illegal output pathname for archive member: %s, using \\'%s\\' instead\"\n                            ,5);\n          non_fatal(error_message,output_directory,base_name);\n          output_filename = (char *)base_name;\n          initialize_output_file_00102e6f_00105a68();\n          return;\n        }\n      }\n      for (; (input_path = current_char, *current_char != '\\0' && (*current_char != '/')); current_char = current_char + 1) {\n      }\n    }\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00105a68",
                "dcgettext",
                "non_fatal",
                "FUN_00102e6f",
                "lbasename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102e6f",
            "calling": [
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "initialize_output_file_00102e6f"
        },
        "FUN_001020a0": {
            "renaming": {},
            "code": "\nvoid bfd_make_readable(void)\n\n{\n  bfd_make_readable();\n  return;\n}\n\n",
            "called": [
                "bfd_make_readable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020a0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001020a0"
        },
        "FUN_001021c0": {
            "renaming": {},
            "code": "\n\n\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strrchr(__s,__c);\n  return pcVar1;\n}\n\n",
            "called": [
                "strrchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021c0",
            "calling": [
                "make_tempname"
            ],
            "imported": false,
            "current_name": "FUN_001021c0"
        },
        "FUN_001022e0": {
            "renaming": {},
            "code": "\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = strcmp(__s1,__s2);\n  return iVar1;\n}\n\n",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022e0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001022e0"
        },
        "FUN_001033d6": {
            "renaming": {
                "FUN_001033d6": "create_buffer_001033d6",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "pvVar1": "buffer",
                "pvVar2": "data",
                "auVar3": "result"
            },
            "code": "\nundefined  [16]\ncreate_buffer_001033d6(undefined8 param1,undefined8 param2,undefined8 param3,undefined8 param4)\n\n{\n  void *buffer;\n  void *data;\n  undefined result [16];\n  \n  buffer = malloc(0x40);\n  if (buffer != (void *)0x0) goto LAB_001033f7;\n  do {\n    buffer = (void *)yy_fatal_error(\"out of dynamic memory in yy_create_buffer_001033d6()\");\nLAB_001033f7:\n    *(undefined4 *)((long)buffer + 0x18) = 0x4000;\n    data = malloc(0x4002);\n    *(void **)((long)buffer + 8) = data;\n  } while (data == (void *)0x0);\n  *(undefined4 *)((long)buffer + 0x20) = 1;\n  yy_init_buffer(buffer,param1);\n  result._8_8_ = param4;\n  result._0_8_ = buffer;\n  return result;\n}\n\n",
            "called": [
                "yy_init_buffer",
                "yy_fatal_error",
                "malloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001033d6",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "create_buffer_001033d6"
        },
        "FUN_00102000": {
            "renaming": {
                "FUN_00102000": "initialize_evp_context_00102000",
                "ctx": "context",
                "iVar1": "startValue"
            },
            "code": "\nint initializeEVPContext_00102000(EVP_PKEY_CTX *context)\n\n{\n  int startValue;\n  \n  startValue = __gmon_start__();\n  return startValue;\n}\n\n",
            "called": [
                "__gmon_start__"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102000",
            "calling": [],
            "imported": false,
            "current_name": "initialize_evp_context_00102000"
        },
        "FUN_00102120": {
            "renaming": {},
            "code": "\nvoid textdomain(void)\n\n{\n  textdomain();\n  return;\n}\n\n",
            "called": [
                "textdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102120",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102120"
        },
        "FUN_00102480": {
            "renaming": {},
            "code": "\nvoid xexit(void)\n\n{\n                    \n  xexit();\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102480",
            "calling": [
                "open_inarch",
                "fatal",
                "bfd_fatal",
                "ranlib_only",
                "FUN_00105a68",
                "maybequit",
                "ranlib_usage",
                "write_archive.cold",
                "usage",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102480"
        },
        "FUN_00105870": {
            "renaming": {
                "FUN_00105870": "find_matching_param_00105870",
                "param_1": "inputArray",
                "param_2": "numElements",
                "param_3": "searchValue",
                "uVar2": "posName",
                "iVar3": "posType",
                "iVar1": "filenameComparison"
            },
            "code": "\nlong * findMatchingParam_00105870(long *inputArray,int numElements,undefined8 searchValue)\n\n{\n  int filenameComparison;\n  undefined8 posName;\n  int posType;\n  \n  posName = posname;\n  posType = postype;\n  if (postype == 0) {\n    posName = searchValue;\n    posType = numElements;\n  }\n  if (posType == 3) {\n    for (; *inputArray != 0; inputArray = (long *)(*inputArray + 0xf0)) {\n    }\n  }\n  else {\n    for (; (undefined8 *)*inputArray != (undefined8 *)0x0; inputArray = (long *)(*inputArray + 0xf0)) {\n      filenameComparison = filename_cmp(*(undefined8 *)*inputArray,posName);\n      if (filenameComparison == 0) {\n        if (posType != 2) {\n          return inputArray;\n        }\n        return (long *)(*inputArray + 0xf0);\n      }\n    }\n  }\n  return inputArray;\n}\n\n",
            "called": [
                "get_pos_bfd.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105870",
            "calling": [
                "replace_members.cold",
                "main"
            ],
            "imported": false,
            "current_name": "find_matching_param_00105870"
        },
        "FUN_00102240": {
            "renaming": {},
            "code": "\nvoid bfd_set_error(void)\n\n{\n  bfd_set_error();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102240",
            "calling": [
                "open_inarch",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102240"
        },
        "FUN_00102360": {
            "renaming": {},
            "code": "\n\n\nvoid clearerr(FILE *__stream)\n\n{\n  clearerr(__stream);\n  return;\n}\n\n",
            "called": [
                "clearerr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102360",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102360"
        },
        "FUN_00103ba8": {
            "renaming": {
                "FUN_00103ba8": "prompt_user_for_input_00103ba8",
                "interactive": "isInteractiveMode",
                "printf": "printMessage",
                "fflush": "flushStandardOutput"
            },
            "code": "\n\n\nvoid promptUserForInput_00103ba8(void)\n\n{\n  if (isInteractiveMode != 0) {\n    printMessage(\"AR >\");\n    flushStandardOutput(_stdout);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "fflush",
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103ba8",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "prompt_user_for_input_00103ba8"
        },
        "FUN_00103ddc": {
            "renaming": {
                "FUN_00103ddc": "print_arelt_descr_verbose_00103ddc",
                "param_1": "output_param",
                "outfile": "output_file",
                "verbose": "is_verbose"
            },
            "code": "\nvoid print_arelt_descr_verbose_00103ddc(undefined8 output_param)\n\n{\n  print_arelt_descr(output_file,output_param,is_verbose != 0,0);\n  return;\n}\n\n",
            "called": [
                "print_arelt_descr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103ddc",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "print_arelt_descr_verbose_00103ddc"
        },
        "FUN_001078c0": {
            "renaming": {
                "FUN_001078c0": "print_error_message_001078c0",
                "param_1": "errorMessage",
                "param_2": "argList",
                "_stdout": "standardOutput",
                "_stderr": "standardError",
                "program_name": "programName"
            },
            "code": "\n\n\nvoid printErrorMessage_001078c0(char *errorMessage,__gnuc_va_list argList)\n\n{\n  fflush(standardOutput);\n  fprintf(standardError,\"%s: \",programName);\n  vfprintf(standardError,errorMessage,argList);\n  putc(10,standardError);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fflush",
                "putc",
                "vfprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001078c0",
            "calling": [
                "fatal",
                "non_fatal"
            ],
            "imported": false,
            "current_name": "print_error_message_001078c0"
        },
        "FUN_001022f0": {
            "renaming": {},
            "code": "\n\n\nint putc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = putc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022f0",
            "calling": [
                "report"
            ],
            "imported": false,
            "current_name": "FUN_001022f0"
        },
        "FUN_001020b0": {
            "renaming": {},
            "code": "\n\n\nint ferror(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = ferror(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "ferror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020b0",
            "calling": [
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_001020b0"
        },
        "FUN_001021d0": {
            "renaming": {},
            "code": "\n\n\nint dup(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = dup(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "dup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021d0",
            "calling": [
                "write_archive.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_001021d0"
        },
        "FUN_001031a5": {
            "renaming": {
                "FUN_001031a5": "print_syntax_error_001031a5",
                "linenumber": "currentLine",
                "__format": "errorMessageFormat",
                "uVar1": "nextLine"
            },
            "code": "\nvoid printSyntaxError_001031a5(void)\n\n{\n  uint nextLine;\n  char *errorMessageFormat;\n  \n  nextLine = currentLine + 1;\n  errorMessageFormat = (char *)dcgettext(0,\"Syntax error in archive script, line %d\\n\",5);\n  printf(errorMessageFormat,(ulong)nextLine);\n  return;\n}\n\n",
            "called": [
                "printf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001031a5",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "print_syntax_error_001031a5"
        },
        "FUN_0010e098": {
            "renaming": {},
            "code": "\n\n\nvoid textdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* textdomain@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e098",
            "calling": [
                "textdomain"
            ],
            "imported": false,
            "current_name": "FUN_0010e098"
        },
        "FUN_00102370": {
            "renaming": {},
            "code": "\nvoid bfd_bwrite(void)\n\n{\n  bfd_bwrite();\n  return;\n}\n\n",
            "called": [
                "bfd_bwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102370",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102370"
        },
        "FUN_00102490": {
            "renaming": {},
            "code": "\nvoid bfd_close(void)\n\n{\n  bfd_close();\n  return;\n}\n\n",
            "called": [
                "bfd_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102490",
            "calling": [
                "open_inarch",
                "open_inarch.cold",
                "write_archive.cold",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102490"
        },
        "FUN_0010e090": {
            "renaming": {},
            "code": "\n\n\n\nssize_t write(int __fd,void *__buf,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* write@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e090",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "FUN_0010e090"
        },
        "FUN_00102130": {
            "renaming": {},
            "code": "\nvoid bfd_openr(void)\n\n{\n  bfd_openr();\n  return;\n}\n\n",
            "called": [
                "bfd_openr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102130",
            "calling": [
                "open_inarch",
                "open_inarch.cold",
                "ar_open",
                "replace_members.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102130"
        },
        "FUN_00102250": {
            "renaming": {},
            "code": "\nvoid xmalloc_set_program_name(void)\n\n{\n  xmalloc_set_program_name();\n  return;\n}\n\n",
            "called": [
                "xmalloc_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102250",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102250"
        },
        "FUN_00103df9": {
            "renaming": {
                "FUN_00103df9": "allocate_and_initialize_buffer_00103df9",
                "in_RCX": "return_value",
                "yy_buffer_stack": "buffer_stack",
                "yy_buffer_stack_max": "buffer_stack_max",
                "yy_buffer_stack_top": "buffer_stack_top",
                "puVar3": "pointer",
                "bVar4": "flag",
                "__size": "total_size",
                "lVar1": "counter",
                "lVar2": "new_buffer_size"
            },
            "code": "\nundefined8 allocate_and_initialize_buffer_00103df9(void)\n\n{\n  size_t total_size;\n  undefined8 return_value;\n  long counter;\n  long new_buffer_size;\n  undefined4 *pointer;\n  byte flag;\n  \n  flag = 0;\n  if (buffer_stack == (void *)0x0) {\n    buffer_stack = calloc(8,1);\n    if (buffer_stack != (void *)0x0) {\n      buffer_stack_max = 1;\n      buffer_stack_top = 0;\n      return return_value;\n    }\n  }\n  else {\n    if (buffer_stack_top < buffer_stack_max - 1U) {\n      return return_value;\n    }\n    new_buffer_size = buffer_stack_max + 8;\n    total_size = new_buffer_size * 8;\n    buffer_stack = realloc(buffer_stack,total_size);\n    if (buffer_stack != (void *)0x0) {\n      pointer = (undefined4 *)((long)buffer_stack + (total_size - 0x40));\n      buffer_stack_max = new_buffer_size;\n      for (counter = 0x10; counter != 0; counter = counter + -1) {\n        *pointer = 0;\n        pointer = pointer + (ulong)flag * -2 + 1;\n      }\n      return return_value;\n    }\n  }\n  yy_fatal_error(\"out of dynamic memory in yyensure_buffer_stack()\");\n  buffer_stack_top = 0;\n  buffer_stack_max = 1;\n  return return_value;\n}\n\n",
            "called": [
                "calloc",
                "yy_fatal_error",
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103df9",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_buffer_00103df9"
        },
        "FUN_0010e308": {
            "renaming": {},
            "code": "\n\n\nvoid __cxa_finalize(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __cxa_finalize@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e308",
            "calling": [
                "__cxa_finalize"
            ],
            "imported": false,
            "current_name": "FUN_0010e308"
        },
        "FUN_001021e0": {
            "renaming": {},
            "code": "\n\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  __off_t _Var1;\n  \n  _Var1 = lseek(__fd,__offset,__whence);\n  return _Var1;\n}\n\n",
            "called": [
                "lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021e0",
            "calling": [
                "simple_copy.constprop.0"
            ],
            "imported": false,
            "current_name": "FUN_001021e0"
        },
        "FUN_001020c0": {
            "renaming": {},
            "code": "\n\n\nint isatty(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = isatty(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "isatty"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020c0",
            "calling": [
                "yy_init_buffer",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001020c0"
        },
        "FUN_00105da0": {
            "renaming": {},
            "code": "\nvoid register_tm_clones(void)\n\n{\n  register_tm_clones();\n  return;\n}\n\n",
            "called": [
                "register_tm_clones"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105da0",
            "calling": [],
            "imported": false,
            "current_name": "FUN_00105da0"
        },
        "FUN_00102bf5": {
            "renaming": {
                "FUN_00102bf5": "cleanup_output_00102bf5",
                "output_bfd": "outputBfd",
                "bfd_cache_close": "closeBfdCache",
                "output_file": "outputFile",
                "output_filename": "outputFilename"
            },
            "code": "\nvoid cleanupOutput_00102bf5(void)\n\n{\n  if (outputBfd != 0) {\n    closeBfdCache();\n  }\n  if (outputFile != (FILE *)0x0) {\n    fclose(outputFile);\n  }\n  unlink_if_ordinary(outputFilename);\n  return;\n}\n\n",
            "called": [
                "unlink_if_ordinary",
                "fclose",
                "bfd_cache_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102bf5",
            "calling": [
                "remove_output"
            ],
            "imported": false,
            "current_name": "cleanup_output_00102bf5"
        },
        "FUN_00102260": {
            "renaming": {},
            "code": "\n\n\nint close(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = close(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102260",
            "calling": [
                "simple_copy.constprop.0.cold",
                "write_archive",
                "simple_copy.constprop.0"
            ],
            "imported": false,
            "current_name": "FUN_00102260"
        },
        "FUN_00102380": {
            "renaming": {},
            "code": "\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memcpy(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102380",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102380"
        },
        "FUN_00102020": {
            "renaming": {
                "FUN_00102020": "execute_indirect_jump_00102020"
            },
            "code": "\nvoid executeIndirectJump_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(undefined *)0x0)();\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102020",
            "calling": [],
            "imported": false,
            "current_name": "execute_indirect_jump_00102020"
        },
        "FUN_00102140": {
            "renaming": {},
            "code": "\n\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fclose(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fclose"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102140",
            "calling": [
                "extract_file.cold",
                "remove_output.cold",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102140"
        },
        "FUN_00102943": {
            "renaming": {
                "FUN_00102943": "initialize_output_filename_00102943",
                "output_filename": "outputFilename"
            },
            "code": "\nvoid initializeOutputFilename_00102943(void)\n\n{\n  outputFilename = 0;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102943",
            "calling": [
                "replace_members.cold",
                "replace_members"
            ],
            "imported": false,
            "current_name": "initialize_output_filename_00102943"
        },
        "FUN_00107c80": {
            "renaming": {
                "FUN_00107c80": "set_file_modification_time_00107c80",
                "param_1": "filePath",
                "param_2": "fileMetadata",
                "iVar1": "result",
                "piVar2": "errnoPointer",
                "pcVar3": "errorMessage",
                "uVar4": "translatedErrorMessage",
                "local_38": "accessTime",
                "uStack_34": "modifiedTime",
                "uStack_30": "changeTime",
                "uStack_2c": "backupChangeTime",
                "local_28": "creationTime"
            },
            "code": "\nvoid setFileModificationTime_00107c80(char *filePath,long fileMetadata)\n\n{\n  int result;\n  int *errnoPointer;\n  char *errorMessage;\n  undefined8 translatedErrorMessage;\n  undefined4 accessTime;\n  undefined4 modifiedTime;\n  undefined4 changeTime;\n  undefined4 backupChangeTime;\n  undefined4 creationTime;\n  undefined4 uStack_24;\n  undefined4 uStack_20;\n  undefined4 uStack_1c;\n  \n  creationTime = *(undefined4 *)(fileMetadata + 0x58);\n  uStack_24 = *(undefined4 *)(fileMetadata + 0x5c);\n  uStack_20 = *(undefined4 *)(fileMetadata + 0x60);\n  uStack_1c = *(undefined4 *)(fileMetadata + 100);\n  accessTime = *(undefined4 *)(fileMetadata + 0x48);\n  modifiedTime = *(undefined4 *)(fileMetadata + 0x4c);\n  changeTime = *(undefined4 *)(fileMetadata + 0x50);\n  backupChangeTime = *(undefined4 *)(fileMetadata + 0x54);\n  result = utimensat(-100,filePath,(timespec *)&accessTime,0);\n  if (result != 0) {\n    errnoPointer = __errno_location();\n    errorMessage = strerror(*errnoPointer);\n    translatedErrorMessage = dcgettext(0,\"%s: cannot set time: %s\",5);\n    non_fatal(translatedErrorMessage,filePath,errorMessage);\n  }\n  return;\n}\n\n",
            "called": [
                "utimensat",
                "set_times.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c80",
            "calling": [
                "extract_file.cold"
            ],
            "imported": false,
            "current_name": "set_file_modification_time_00107c80"
        },
        "FUN_001020d0": {
            "renaming": {},
            "code": "\nvoid bfd_set_default_target(void)\n\n{\n  bfd_set_default_target();\n  return;\n}\n\n",
            "called": [
                "bfd_set_default_target"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020d0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001020d0"
        },
        "FUN_001021f0": {
            "renaming": {},
            "code": "\n\n\nint fputs(char *__s,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputs(__s,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputs"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021f0",
            "calling": [
                "print_arelt_descr.cold"
            ],
            "imported": false,
            "current_name": "FUN_001021f0"
        },
        "FUN_00102390": {
            "renaming": {},
            "code": "\n\n\nint fileno(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fileno(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fileno"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102390",
            "calling": [
                "yy_init_buffer",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102390"
        },
        "FUN_00102d8c": {
            "renaming": {
                "FUN_00102d8c": "print_file_metadata_00102d8c",
                "unaff_RBX": "fileLines",
                "unaff_RBP": "outputFile",
                "unaff_R12B": "isHexDump",
                "__format": "corruptedDataFormat",
                "uVar1": "fileMode",
                "uStack0000000000000015": "filePermission",
                "cStack0000000000000016": "isSetuid",
                "cStack0000000000000017": "isSetgid",
                "param_9": "isStickyBit",
                "cStack0000000000000019": "isExecutable",
                "cStack000000000000001a": "isWritable",
                "cStack000000000000001b": "isReadable",
                "cStack000000000000001c": "isDirectory",
                "cStack000000000000001d": "isSymbolicLink",
                "cStack000000000000001e": "isRegularFile",
                "uStack000000000000001f": "formatSpecifier",
                "param_19": "filePermissionBits",
                "uStack000000000000006c": "fileLinkCount",
                "param_20": "fileSize",
                "param_22": "fileInode"
            },
            "code": "\nvoid printFileMetadata_00102d8c(void)\n\n{\n  char *corruptedDataFormat;\n  uint fileMode;\n  char **fileLines;\n  FILE *outputFile;\n  char isHexDump;\n  undefined filePermission;\n  char isSetuid;\n  char isSetgid;\n  char isStickyBit;\n  char isExecutable;\n  char isWritable;\n  char isReadable;\n  char isDirectory;\n  char isSymbolicLink;\n  char isRegularFile;\n  undefined formatSpecifier;\n  uint filePermissionBits;\n  uint fileLinkCount;\n  uint fileSize;\n  undefined8 fileInode;\n  \n  corruptedDataFormat = (char *)dcgettext(0,\"<time data corrupt>\",5);\n  sprintf(&stack0x00000020,corruptedDataFormat);\n  fileMode = filePermissionBits & 0xf000;\n  if (fileMode == 0x4000) {\n    filePermission = 100;\n  }\n  else if (fileMode == 0xa000) {\n    filePermission = 0x6c;\n  }\n  else if (fileMode == 0x6000) {\n    filePermission = 0x62;\n  }\n  else if (fileMode == 0x2000) {\n    filePermission = 99;\n  }\n  else if (fileMode == 0xc000) {\n    filePermission = 0x73;\n  }\n  else {\n    filePermission = 0x70;\n    if (fileMode != 0x1000) {\n      filePermission = 0x2d;\n    }\n  }\n  isSetuid = (-((filePermissionBits & 0x100) == 0) & 0xbbU) + 0x72;\n  isSetgid = (-((filePermissionBits & 0x80) == 0) & 0xb6U) + 0x77;\n  isStickyBit = (-((filePermissionBits & 0x40) == 0) & 0xb5U) + 0x78;\n  isExecutable = (-((filePermissionBits & 0x20) == 0) & 0xbbU) + 0x72;\n  isWritable = (-((filePermissionBits & 0x10) == 0) & 0xb6U) + 0x77;\n  isReadable = (-((filePermissionBits & 8) == 0) & 0xb5U) + 0x78;\n  isDirectory = (-((filePermissionBits & 4) == 0) & 0xbbU) + 0x72;\n  isSymbolicLink = (-((filePermissionBits & 2) == 0) & 0xb6U) + 0x77;\n  isRegularFile = (-((filePermissionBits & 1) == 0) & 0xb5U) + 0x78;\n  if ((filePermissionBits & 0x800) != 0) {\n    if (isStickyBit == 'x') {\n      isStickyBit = 's';\n    }\n    else {\n      isStickyBit = 'S';\n    }\n  }\n  if ((filePermissionBits & 0x400) != 0) {\n    if (isReadable == 'x') {\n      isReadable = 's';\n    }\n    else {\n      isReadable = 'S';\n    }\n  }\n  if ((filePermissionBits & 0x200) != 0) {\n    if (isRegularFile == 'x') {\n      isRegularFile = 't';\n    }\n    else {\n      isRegularFile = 'T';\n    }\n  }\n  formatSpecifier = 0;\n  fprintf(outputFile,\"%s %ld/%ld %6lu %s \",&stack0x00000016,(ulong)fileLinkCount,\n          (ulong)fileSize,fileInode,&stack0x00000020,(ulong)filePermissionBits);\n  fputs(*fileLines,outputFile);\n  if (isHexDump != '\\0') {\n    if ((*(byte *)((long)fileLines + 0x49) & 0x10) == 0) {\n      if (fileLines[0xb] != (char *)0x0) {\n        fprintf(outputFile,\" 0x%lx\");\n      }\n    }\n    else if (fileLines[0xc] != (char *)0x0) {\n      fprintf(outputFile,\" 0x%lx\");\n    }\n  }\n  fputc(10,outputFile);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fputs",
                "fputc",
                "dcgettext",
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102d8c",
            "calling": [
                "print_arelt_descr"
            ],
            "imported": false,
            "current_name": "print_file_metadata_00102d8c"
        },
        "FUN_00105300": {
            "renaming": {
                "FUN_00105300": "extract_archived_files_00105300",
                "param_1": "filename",
                "param_2": "archived_files",
                "plVar1": "file_ptr",
                "pcVar2": "output_filename",
                "bVar3": "format_check",
                "cVar4": "check_result",
                "iVar5": "stat_result",
                "uVar6": "msg",
                "uVar7": "error_msg",
                "piVar8": "errno_ptr",
                "lVar9": "file_offset",
                "puVar10": "arch_file",
                "local_b0": "matching_formats",
                "local_a8": "file_stat",
                "target": "target_name",
                "operation_alters_arch": "alter_arch_operation",
                "operation": "operation_type"
            },
            "code": "\n\n\nundefined8 * extractArchivedFiles_00105300(char *filename,undefined8 *archived_files)\n\n{\n  long *file_ptr;\n  char *output_filename;\n  byte format_check;\n  char check_result;\n  int stat_result;\n  undefined8 msg;\n  undefined8 error_msg;\n  int *errno_ptr;\n  long file_offset;\n  undefined8 *arch_file;\n  undefined8 matching_formats;\n  stat file_stat;\n  \n  bfd_set_error(0);\n  if (target_name == (char *)0x0) {\n    target_name = \"plugin\";\n  }\n  stat_result = stat(filename,&file_stat);\n  output_filename = output_filename;\n  if (stat_result == 0) goto LAB_001053be;\n  errno_ptr = __errno_location();\n  if (*errno_ptr == 2) {\n    if (alter_arch_operation == '\\0') {\n      fprintf(_stderr,\"%s: \",program_name);\n      perror(filename);\n      maybequit();\n      return (undefined8 *)0x0;\n    }\n    if ((target_name == (char *)0x0) && (archived_files != (undefined8 *)0x0)) {\n      arch_file = (undefined8 *)open_inarch_cold();\n      return arch_file;\n    }\n    archived_files = (undefined8 *)bfd_openw(filename,target_name);\n    if (((archived_files != (undefined8 *)0x0) && (check_result = bfd_set_format(archived_files,2), check_result != '\\0')) &&\n       (check_result = bfd_close(archived_files), check_result != '\\0')) {\n      output_filename = filename;\n      if (silent_create == 0) goto LAB_00102826;\n      goto LAB_001053be;\n    }\n  }\n  bfd_fatal(filename);\n  do {\n    format_check = *(byte *)((long)archived_files + 0x49) >> 4 & 1;\n    if (make_thin_archive == '\\0') {\n      if (format_check != 0) {\n        error_msg = *archived_files;\n        msg = dcgettext(0,\"Cannot convert existing thin library %s to normal format\",5);\n        fatal(msg,error_msg);\n        goto LAB_00102812;\n      }\n    }\n    else if (format_check == 0) {\n      error_msg = *archived_files;\n      msg = dcgettext(0,\"Cannot convert existing library %s to thin format\",5);\n      fatal(msg,error_msg);\nLAB_001027cb:\n      bfd_nonfatal(filename);\n      stat_result = bfd_get_error();\n      if (stat_result == 0xd) {\nLAB_00102812:\n        list_matching_formats(matching_formats);\n      }\n                    \n      xexit(1);\n    }\n    do {\n      file_ptr = archived_files + 0x1e;\n      for (file_offset = bfd_openr_next_archived_file(archived_files,0); file_offset != 0;\n          file_offset = bfd_openr_next_archived_file(archived_files,file_offset)) {\n        *file_ptr = file_offset;\n        file_ptr = (long *)(file_offset + 0xf0);\n      }\n      *file_ptr = 0;\n      stat_result = bfd_get_error();\n      if (stat_result == 9) {\n        return archived_files;\n      }\n      do {\n        bfd_fatal(filename);\nLAB_00102826:\n        error_msg = dcgettext(0,\"creating %s\",5);\n        non_fatal(error_msg,filename);\n        output_filename = filename;\nLAB_001053be:\n        output_filename = output_filename;\n        archived_files = (undefined8 *)bfd_openr(filename,target_name);\n      } while (archived_files == (undefined8 *)0x0);\n      check_result = bfd_check_format_matches(archived_files,2,&matching_formats);\n      if (check_result == '\\0') goto LAB_001027cb;\n    } while (((operation_type != 2) && (operation_type != 7)) ||\n            (file_offset = bfd_openr_next_archived_file(archived_files,0), file_offset == 0));\n  } while( true );\n}\n\n",
            "called": [
                "xexit",
                "bfd_openr_next_archived_file",
                "bfd_fatal",
                "fprintf",
                "maybequit",
                "bfd_check_format_matches",
                "bfd_nonfatal",
                "bfd_openr",
                "dcgettext",
                "non_fatal",
                "fatal",
                "stat",
                "open_inarch.cold",
                "list_matching_formats",
                "__errno_location",
                "bfd_openw",
                "bfd_get_error",
                "perror",
                "bfd_close",
                "bfd_set_error",
                "bfd_set_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105300",
            "calling": [
                "ranlib_only",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "extract_archived_files_00105300"
        },
        "FUN_00105db0": {
            "renaming": {
                "FUN_00105db0": "extract_files_00105db0",
                "param_1": "argc",
                "param_2": "argv",
                "pbVar1": "byteArray",
                "puVar2": "uintPtr",
                "bVar3": "byteVar",
                "plVar4": "longPtr",
                "puVar5": "undefined8Ptr",
                "uVar6": "uintVar",
                "uVar7": "uintVar",
                "bVar8": "boolVar1",
                "bVar9": "boolVar2",
                "ppcVar10": "charPtrPtr",
                "piVar11": "intPtr",
                "puVar12": "undefinedPtr",
                "bVar13": "byteVar",
                "cVar14": "charVar",
                "iVar15": "intVar",
                "uVar16": "uintVar",
                "uVar17": "uintVar",
                "pFVar18": "filePtr",
                "sVar19": "sizeVar",
                "sVar20": "sizeVar",
                "__ptr": "bytePtr",
                "plVar21": "longPtr",
                "pFVar22": "filePtr",
                "pcVar23": "charPtr",
                "lVar24": "longVar",
                "uVar25": "ulongVar",
                "puVar26": "undefined8Ptr",
                "uVar27": "undefined8Var",
                "pFVar28": "filePtr",
                "plVar29": "longPtrPtr",
                "uVar30": "undefined8Var",
                "ppcVar31": "charPtrPtr",
                "extraout_EDX": "uintVar",
                "ppcVar32": "charPtrPtr",
                "pbVar33": "byteArray",
                "lVar34": "longVar",
                "lVar35": "longVar",
                "unaff_RBP": "charPtr",
                "pbVar38": "bytePtr",
                "pcVar39": "charPtr",
                "uVar40": "ulongVar",
                "uVar41": "ulongVar",
                "uVar42": "ulongVar",
                "uVar44": "uintVar",
                "iVar45": "intVar",
                "pcVar46": "charPtr",
                "bVar47": "boolVar",
                "bVar48": "byteVar",
                "local_130": "undefined8Var",
                "local_128": "filePtr",
                "local_118": "byteArray",
                "local_110": "charPtrPtr",
                "local_108": "sizeVar",
                "local_100": "longVar",
                "local_c8": "undefinedArray",
                "uStack_c6": "undefinedVar",
                "uStack_c5": "undefined5Var",
                "local_b0": "uintVar"
            },
            "code": "\n\n\nvoid extractFiles_00105db0(uint argc,FILE *argv)\n\n{\n  byte *byteArray;\n  uint *uintPtr;\n  byte byteVar;\n  long *longPtr;\n  undefined8 *undefined8Ptr;\n  undefined4 uintVar;\n  undefined4 uintVar;\n  bool boolVar1;\n  bool boolVar2;\n  char **charPtrPtr;\n  int *intPtr;\n  undefined *undefinedPtr;\n  byte byteVar;\n  char charVar;\n  int intVar;\n  uint uintVar;\n  undefined4 uintVar;\n  FILE *filePtr;\n  size_t sizeVar;\n  size_t sizeVar;\n  byte *bytePtr;\n  long *longPtr;\n  FILE *filePtr;\n  char *charPtr;\n  long longVar;\n  ulong ulongVar;\n  undefined8 *undefined8Ptr;\n  undefined8 undefined8Var;\n  FILE *filePtr;\n  long **plongPtrPtr;\n  undefined8 undefined8Var;\n  char **charPtrPtr;\n  uint uintVar;\n  char **charPtrPtr;\n  byte *byteArray;\n  long longVar;\n  long longVar;\n  undefined1 *puVar36;\n  uint uVar37;\n  char *charPtr;\n  byte *bytePtr;\n  char *charPtr;\n  ulong ulongVar;\n  ulong ulongVar;\n  ulong ulongVar;\n  FILE *unaff_R12;\n  char *pcVar43;\n  uint uintVar;\n  int intVar;\n  char *charPtr;\n  bool boolVar;\n  byte byteVar;\n  undefined8 undefined8Var;\n  FILE *filePtr;\n  byte *byteArray;\n  char **charPtrPtr;\n  size_t sizeVar;\n  long longVar;\n  undefined undefinedArray [2];\n  undefined undefinedVar;\n  undefined5 undefined5Var;\n  uint uintVar;\n  \n  byteVar = 0;\n  charPtr = (char *)(ulong)argc;\n  setlocale(5,\"\");\n  setlocale(0,\"\");\n  bindtextdomain(\"binutils\",\"/usr/share/locale\");\n  textdomain(\"binutils\");\n  program_name = *(long **)argv;\n  xmalloc_set_program_name();\n  bfd_set_error_program_name(program_name);\n  bfd_plugin_set_program_name(program_name);\n  pcVar43 = (char *)argv;\n  filePtr = argv;\n  if ((int)argc < 2) goto LAB_001062c6;\n  charPtrPtr = (char **)0x7d0;\n  unaff_R12 = (FILE *)0x1;\n  filePtr = (FILE *)0x0;\n  filePtr = argv;\n  do {\n    uintVar = (uint)unaff_R12;\n    charPtr = (char *)(long)(int)uintVar;\n    undefined8Var = (FILE *)((long)charPtr * 8);\n    pcVar43 = (char *)filePtr;\n    if (**(char **)(&filePtr->_flags + (long)charPtr * 2) == '@') {\n      uintVar = (int)charPtrPtr - 1;\n      charPtrPtr = (char **)(ulong)uintVar;\n      if (uintVar == 0) {\n        longPtr = *(long **)filePtr;\n        charPtr = \"%s: error: too many @-files encountered\\n\";\nLAB_00106ffe:\n        fprintf(_stderr,charPtr,longPtr);\nLAB_0010700f:\n                    \n        xexit(1);\n      }\n      charPtr = *(char **)(&filePtr->_flags + (long)charPtr * 2) + 1;\n      intVar = stat(charPtr,(stat *)undefinedArray);\n      if (-1 < intVar) {\n        if ((uintVar & 0xf000) == 0x4000) {\n          longPtr = *(long **)filePtr;\n          charPtr = \"%s: error: @-file refers to a directory\\n\";\n          goto LAB_00106ffe;\n        }\n        filePtr = fopen(charPtr,\"r\");\n        if (filePtr != (FILE *)0x0) {\n          intVar = fseek(filePtr,0,2);\n          if (((intVar != -1) && (sizeVar = ftell(filePtr), sizeVar != 0xffffffffffffffff)) &&\n             (intVar = fseek(filePtr,0,0), intVar != -1)) {\n            byteArray = (byte *)xmalloc(sizeVar + 1);\n            sizeVar = fread(byteArray,1,sizeVar,filePtr);\n            if ((sizeVar == sizeVar) || (intVar = ferror(filePtr), intVar == 0)) {\n              byteArray[sizeVar] = 0;\n              byteVar = *byteArray;\n              byteArray = byteArray;\n              while( true ) {\n                if (byteVar == 0) goto LAB_00106814;\n                if (((&_sch_istable)[(ulong)byteVar * 2] & 0x40) == 0) break;\n                byteVar = byteArray[1];\n                byteArray = byteArray + 1;\n              }\n              sizeVar = strlen((char *)byteArray);\n              bytePtr = (byte *)xmalloc(sizeVar + 1);\n              filePtr = (FILE *)0x0;\n              intVar = 0;\n              boolVar2 = false;\n              boolVar = false;\n              boolVar1 = false;\n              longVar = 0;\n              byteArray = byteArray;\n              do {\n                while (((&_sch_istable)[(ulong)*byteArray * 2] & 0x40) != 0) {\n                  byteArray = byteArray + 1;\n                }\n                if ((intVar == 0) || (intVar + -1 <= (int)longVar)) {\n                  if (filePtr == (FILE *)0x0) {\n                    intVar = 8;\n                    filePtr = (FILE *)xmalloc(0x40);\n                    charPtrPtr = (char **)((long)&filePtr->_flags + longVar * 8);\n                    *charPtrPtr = (char *)0x0;\n                  }\n                  else {\n                    intVar = intVar * 2;\n                    filePtr = (FILE *)xrealloc(filePtr,(long)intVar << 3);\n                    charPtrPtr = (char **)((long)&filePtr->_flags + longVar * 8);\n                    *charPtrPtr = (char *)0x0;\n                  }\n                }\n                else {\n                  charPtrPtr = (char **)((long)&filePtr->_flags + longVar * 8);\n                }\n                byteVar = *byteArray;\n                bytePtr = bytePtr;\n                while (byteVar != 0) {\n                  while( true ) {\n                    if ((((&_sch_istable)[(ulong)byteVar * 2] & 0x40) != 0) &&\n                       (!(bool)(boolVar2 | boolVar1 | boolVar))) {\n                      boolVar1 = false;\n                      boolVar2 = false;\n                      boolVar = false;\n                      goto LAB_0010606f;\n                    }\n                    if (!boolVar1) break;\n                    byteArray = byteArray + 1;\n                    *bytePtr = byteVar;\n                    bytePtr = bytePtr + 1;\n                    boolVar1 = false;\n                    byteVar = *byteArray;\n                    if (byteVar == 0) goto LAB_0010606f;\n                  }\n                  if (byteVar == 0x5c) {\n                    boolVar1 = true;\n                  }\n                  else if (boolVar) {\n                    if (byteVar == 0x27) {\n                      boolVar = false;\n                    }\n                    else {\nLAB_001061f1:\n                      *bytePtr = byteVar;\n                      bytePtr = bytePtr + 1;\n                    }\n                  }\n                  else if (boolVar2) {\n                    if (byteVar != 0x22) goto LAB_001061f1;\n                    boolVar2 = false;\n                  }\n                  else if (byteVar == 0x27) {\n                    boolVar = true;\n                  }\n                  else {\n                    if (byteVar != 0x22) goto LAB_001061f1;\n                    boolVar2 = true;\n                  }\n                  byteArray = byteArray + 1;\n                  byteArray = byteArray + 1;\n                  byteVar = *byteArray;\n                }\nLAB_0010606f:\n                *bytePtr = 0;\n                longPtr = (long *)xstrdup(bytePtr);\n                *charPtrPtr = (char *)longPtr;\n                *(undefined8 *)(filePtr->_shortbuf + longVar * 8 + -0x7b) = 0;\n                byteVar = *byteArray;\n                byteVar = (&_sch_istable)[(ulong)byteVar * 2];\n                while ((byteVar & 0x40) != 0) {\n                  byteVar = byteArray[1];\n                  byteArray = byteArray + 1;\n                  byteVar = (&_sch_istable)[(ulong)byteVar * 2];\n                }\n                longVar = longVar + 1;\n                if (byteVar == 0) {\n                  free(bytePtr);\n                  if (filePtr == argv) goto LAB_00106834;\n                  goto LAB_0010610a;\n                }\n              } while( true );\n            }\n            free(byteArray);\n          }\n          fclose(filePtr);\n        }\n      }\n    }\n    if ((int)charPtr <= (int)(uintVar + 1)) {\nLAB_001062c6:\n      do {\n        if (is_ranlib < 0) goto LAB_001073cc;\nLAB_001062d3:\n        uintVar = (uint)unaff_R12;\n        intVar = bfd_init();\n        charPtr = \"fatal error: libbfd ABI mismatch\";\n        if (intVar != 0x118) goto LAB_00106803;\n        charPtr = \"x86_64-pc-linux-gnu\";\n        uintVar = bfd_set_default_target(\"x86_64-pc-linux-gnu\",\"fatal error: libbfd ABI mismatch\",5);\n        undefinedPtr = xatexit_head;\n        unaff_R12 = (FILE *)(ulong)uintVar;\n        if ((char)uintVar != '\\0') {\n          if (__xexit_cleanup == (code *)0x0) {\n            __xexit_cleanup = xatexit_cleanup;\n          }\n          if (*(int *)(xatexit_head + 8) < 0x20) {\nLAB_0010632b:\n            undefinedPtr = xatexit_head;\n            intVar = *(int *)(xatexit_head + 8);\n            *(int *)(xatexit_head + 8) = intVar + 1;\n            *(code **)(undefinedPtr + (long)intVar * 8 + 0x10) = remove_output;\n          }\n          else {\n            undefined8Ptr = (undefined8 *)malloc(0x110);\n            if (undefined8Ptr != (undefined8 *)0x0) {\n              *undefined8Ptr = undefinedPtr;\n              *(undefined4 *)(undefined8Ptr + 1) = 0;\n              xatexit_head = (undefined *)undefined8Ptr;\n              goto LAB_0010632b;\n            }\n          }\n          longVar = 1;\n          do {\n            longVar = longVar;\n            intVar = (int)charPtr;\n            if (intVar <= (int)longVar) break;\n            charVar = ar_emul_default_parse_arg(*(undefined8 *)((int *)pcVar43 + longVar * 2));\n            longVar = longVar + 1;\n          } while (charVar != '\\0');\n          charPtr = (char *)((long)pcVar43 + longVar * 8 + -8);\n          uintVar = intVar - ((int)longVar + -1);\n          filePtr = (FILE *)(ulong)uintVar;\n          if (is_ranlib != 0) {\n            pcVar43 = \"DhHUvVt\";\n            uVar37 = 0;\n            while (intVar = getopt_long(filePtr,charPtr,\"DhHUvVt\",long_options), intVar != -1) {\n              if (intVar < 0x77) {\n                if (0x43 < intVar) {\n                  switch(intVar) {\n                  case 0x44:\n                    deterministic = 1;\n                    break;\n                  case 0x48:\n                  case 0x68:\n                    show_help = 1;\n                    break;\n                  case 0x55:\n                    deterministic = 0;\n                    break;\n                  case 0x56:\n                  case 0x76:\n                    show_version = 1;\n                    break;\n                  case 0x74:\n                    uVar37 = uintVar;\n                  }\n                }\n              }\n              else if (intVar == 0xc9) {\n                bfd_plugin_set_plugin(_optarg);\n              }\n            }\n            if ((int)uintVar < 2) {\nLAB_00107125:\n              charPtr = (char *)0x0;\n              ranlib_usage();\n            }\n            else {\n              if (show_help != 0) {\nLAB_0010711b:\n                ranlib_usage();\n                goto LAB_00107125;\n              }\n              if (show_version != 0) {\n                print_version(\"ranlib\");\n                goto LAB_0010711b;\n              }\n              if (deterministic < 0) {\n                deterministic = 1;\n              }\n              unaff_R12 = (FILE *)0x0;\n              pcVar43 = (char *)(long)_optind;\n              while( true ) {\n                if ((int)uintVar <= (int)pcVar43) goto LAB_00106f8b;\n                charPtr = *(char **)((int *)charPtr + (long)pcVar43 * 2);\n                if ((char)uVar37 != '\\0') break;\n                uintVar = ranlib_only();\n                pcVar43 = (char *)((long)(int *)pcVar43 + 1);\n                unaff_R12 = (FILE *)(ulong)((uint)unaff_R12 | uintVar);\n              }\n            }\n            while (longVar = get_file_size(charPtr), longVar < 1) {\n              uintVar = 1;\nLAB_001071c4:\n              intPtr = (int *)pcVar43;\n              pcVar43 = (char *)((long)intPtr + 1);\n              unaff_R12 = (FILE *)(ulong)((uint)unaff_R12 | uintVar);\n              if ((int)uintVar <= (int)pcVar43) {\nLAB_00106f8b:\n                    \n                xexit(unaff_R12);\n              }\n              charPtr = *(char **)((char *)((long)charPtr + 0x83) + (long)intPtr * 8 + -0x7b);\n            }\n            intVar = open(charPtr,2,0);\n            if (intVar < 0) {\n              bfd_set_error(1);\n              bfd_fatal(charPtr);\nLAB_0010737f:\n              bfd_fatal(charPtr);\nLAB_00107387:\n              bfd_nonfatal(charPtr);\n              intVar = bfd_get_error();\n              if (intVar == 0xd) {\n                list_matching_formats\n                          (CONCAT53(undefined5Var,CONCAT12(undefinedVar,CONCAT11(undefinedArray[1],undefinedArray[0])))\n                          );\n              }\n              goto LAB_0010700f;\n            }\n            charPtr = (char *)bfd_fdopenr(charPtr,0);\n            if ((FILE *)charPtr == (FILE *)0x0) goto LAB_0010737f;\n            charVar = bfd_check_format_matches(charPtr,2,undefinedArray);\n            if (charVar == '\\0') goto LAB_00107387;\n            if ((*(byte *)((long)((long)charPtr + 0x48) + 1) & 8) != 0) {\n              if (deterministic != 0) {\n                uintPtr = (uint *)((long)((long)charPtr + 0x40) + 4);\n                *uintPtr = *uintPtr | 0x2000;\n              }\n              (**(code **)(*(char **)((long)charPtr + 8) + 0x1f0))(charPtr);\n              charVar = bfd_close(charPtr);\n              if (charVar != '\\0') {\n                uintVar = 0;\n                goto LAB_001071c4;\n              }\n              goto LAB_0010737f;\n            }\n            undefined8Var = dcgettext(0,\"%s: no archive map to update\",5);\n            fatal(undefined8Var,charPtr);\nLAB_001073cc:\n            charPtr = (char *)lbasename(program_name);\n            sizeVar = strlen(charPtr);\n            if ((sizeVar < 6) ||\n               (intVar = filename_cmp(charPtr + (sizeVar - 6),\"ranlib\"), intVar != 0)) {\n              is_ranlib = 0;\n            }\n            else {\n              is_ranlib = 1;\n            }\n            goto LAB_001062d3;\n          }\n          puVar36 = long_options;\n          charPtr = \"hdmpqrtxl:coOVsSuvabiMNfPTDU\";\n          pcVar43 = (char *)&DAT_001096a0;\n          filePtr = (FILE *)charPtr;\n          filePtr = filePtr;\n          if ((int)uintVar < 2) goto switchD_00107462_caseD_1;\n          undefined8Var = (FILE *)CONCAT71(undefined8Var._1_7_,(char)uintVar);\nLAB_001063a3:\n          filePtr = (FILE *)charPtr;\n          if (**(char **)((long)charPtr + 8) != '-') {\n            undefinedArray[0] = 0x2d;\n            undefinedVar = 0;\n            sizeVar = strlen(*(char **)((long)charPtr + 8));\n            intVar = (int)sizeVar + (int)filePtr;\n            unaff_R12 = (FILE *)xmalloc((long)intVar * 8);\n            uintVar = *(undefined4 *)((long)charPtr + 4);\n            unaff_R12->_flags = *(int *)charPtr;\n            *(undefined4 *)&unaff_R12->field_0x4 = uintVar;\n            charPtrPtr = *(char ***)((long)charPtr + 8);\n            filePtr = (FILE *)((long)charPtr + 0x10);\n            charPtrPtr = charPtrPtr;\n            if (*(char *)charPtrPtr == '\\0') {\n              charPtrPtr = &unaff_R12->_IO_read_ptr;\n            }\n            else {\n              byteArray = undefinedArray;\n              undefinedArray[1] = *(char *)charPtrPtr;\n              charPtr = (char *)xstrdup();\n              charPtrPtr = &unaff_R12->_IO_read_end;\n              unaff_R12->_IO_read_ptr = charPtr;\n              if (*(char *)((long)charPtrPtr + 1) != '\\0') {\n                undefinedArray[1] = *(char *)((long)charPtrPtr + 1);\n                charPtr = (char *)xstrdup(byteArray);\n                charPtrPtr = &unaff_R12->_IO_read_base;\n                unaff_R12->_IO_read_end = charPtr;\n                if (*(char *)((long)charPtrPtr + 2) != '\\0') {\n                  undefinedArray[1] = *(char *)((long)charPtrPtr + 2);\n                  charPtr = (char *)xstrdup(byteArray);\n                  charPtrPtr = &unaff_R12->_IO_write_base;\n                  unaff_R12->_IO_read_base = charPtr;\n                  if (*(char *)((long)charPtrPtr + 3) != '\\0') {\n                    charPtrPtr = &unaff_R12->_IO_write_ptr;\n                    undefinedArray[1] = *(char *)((long)charPtrPtr + 3);\n                    charPtr = (char *)xstrdup(byteArray);\n                    unaff_R12->_IO_write_base = charPtr;\n                    charVar = *(char *)((long)charPtrPtr + 4);\n                    charPtrPtr = charPtrPtr;\n                    if (charVar != '\\0') {\n                      charPtr = (char *)((long)charPtrPtr + 4);\n                      charPtrPtr = charPtrPtr;\n                      do {\n                        charPtrPtr = charPtrPtr + 1;\n                        undefinedArray[1] = charVar;\n                        charPtr = (char *)xstrdup(byteArray);\n                        charPtr = charPtr + 1;\n                        *charPtrPtr = charPtr;\n                        charVar = *charPtr;\n                        charPtrPtr = charPtrPtr;\n                        charPtrPtr = charPtrPtr;\n                      } while (charVar != '\\0');\n                    }\n                  }\n                }\n              }\n            }\n            longVar = (long)(int)filePtr;\n            intPtr = (int *)charPtr + longVar * 2;\n            if (filePtr < intPtr) {\n              ulongVar = longVar * 8 - 0x11;\n              if ((ulongVar < 0x18) || (charPtrPtr == (char **)((long)charPtr + 0x18))) {\n                *charPtrPtr = *(char **)((long)charPtr + 0x10);\n                if (((char **)((long)charPtr + 0x18) < intPtr) &&\n                   ((((charPtrPtr[1] = *(char **)((long)charPtr + 0x18),\n                      (char **)((long)charPtr + 0x20) < intPtr &&\n                      (charPtrPtr[2] = *(char **)((long)charPtr + 0x20),\n                      (char **)((long)charPtr + 0x28) < intPtr)) &&\n                     (charPtrPtr[3] = *(char **)((long)charPtr + 0x28),\n                     (char **)((long)charPtr + 0x30) < intPtr)) &&\n                    (charPtrPtr[4] = *(char **)((long)charPtr + 0x30),\n                    (char **)((long)charPtr + 0x38) < intPtr)))) {\n                  charPtrPtr[5] = *(char **)((long)charPtr + 0x38);\n                  charPtrPtr = charPtrPtr + 6;\n                  for (charPtrPtr = (char **)((long)charPtr + 0x40); charPtrPtr < intPtr;\n                      charPtrPtr = charPtrPtr + (ulong)byteVar * -2 + 1) {\n                    *charPtrPtr = *charPtrPtr;\n                    charPtrPtr = charPtrPtr + (ulong)byteVar * -2 + 1;\n                  }\n                }\n              }\n              else {\n                uintVar = *(undefined4 *)((long)((long)charPtr + 0x10) + 4);\n                uintVar = *(undefined4 *)((long)charPtr + 0x18);\n                uintVar = *(undefined4 *)((long)((long)charPtr + 0x18) + 4);\n                ulongVar = (ulongVar >> 3) + 1;\n                *(undefined4 *)charPtrPtr = *(undefined4 *)((long)charPtr + 0x10);\n                *(undefined4 *)((long)charPtrPtr + 4) = uintVar;\n                *(undefined4 *)(charPtrPtr + 1) = uintVar;\n                *(undefined4 *)((long)charPtrPtr + 0xc) = uintVar;\n                uintVar = *(undefined4 *)((long)((long)charPtr + 0x20) + 4);\n                uintVar = *(undefined4 *)((long)charPtr + 0x28);\n                uintVar = *(undefined4 *)((long)((long)charPtr + 0x28) + 4);\n                ulongVar = ulongVar >> 1;\n                *(undefined4 *)(charPtrPtr + 2) = *(undefined4 *)((long)charPtr + 0x20);\n                *(undefined4 *)((long)charPtrPtr + 0x14) = uintVar;\n                *(undefined4 *)(charPtrPtr + 3) = uintVar;\n                *(undefined4 *)((long)charPtrPtr + 0x1c) = uintVar;\n                if (ulongVar != 2) {\n                  uintVar = *(undefined4 *)((long)((long)charPtr + 0x30) + 4);\n                  uintVar = *(undefined4 *)((long)charPtr + 0x38);\n                  uintVar = *(undefined4 *)((long)((long)charPtr + 0x38) + 4);\n                  *(undefined4 *)(charPtrPtr + 4) = *(undefined4 *)((long)charPtr + 0x30);\n                  *(undefined4 *)((long)charPtrPtr + 0x24) = uintVar;\n                  *(undefined4 *)(charPtrPtr + 5) = uintVar;\n                  *(undefined4 *)((long)charPtrPtr + 0x2c) = uintVar;\n                  if (ulongVar != 3) {\n                    ulongVar = 3;\n                    do {\n                      ulongVar = ulongVar + 1;\n                      charPtr = (char *)((long)charPtr + 0x83) + ulongVar * 0x10 + -0x73;\n                      uintVar = *(undefined4 *)(charPtr + 4);\n                      uintVar = *(undefined4 *)(charPtr + 8);\n                      uintVar = *(undefined4 *)(charPtr + 0xc);\n                      charPtrPtr = charPtrPtr + ulongVar * 2;\n                      *(undefined4 *)charPtrPtr = *(undefined4 *)charPtr;\n                      *(undefined4 *)((long)charPtrPtr + 4) = uintVar;\n                      *(undefined4 *)(charPtrPtr + 1) = uintVar;\n                      *(undefined4 *)((long)charPtrPtr + 0xc) = uintVar;\n                      ulongVar = ulongVar;\n                    } while (ulongVar != ulongVar);\n                  }\n                }\n                if ((ulongVar & 1) != 0) {\n                  charPtrPtr[ulongVar & 0xfffffffffffffffe] =\n                       *(char **)((long)filePtr + (ulongVar & 0xfffffffffffffffe) * 8);\n                }\n              }\n              charPtrPtr = charPtrPtr + longVar + -2;\n            }\n            filePtr = (FILE *)(ulong)(intVar - 1);\n            *charPtrPtr = (char *)0x0;\n            charPtr = (char *)unaff_R12;\n          }\nLAB_001065a2:\n          while( true ) {\n            uintVar = (uint)unaff_R12;\n            uintVar = getopt_long((ulong)filePtr & 0xffffffff,charPtr,filePtr,puVar36,0);\n            charPtr = (char *)filePtr;\n            if (uintVar == 0xffffffff) break;\n            if (((uintVar - 100 < 0x15) && ((0x117201UL >> ((ulong)(uintVar - 100) & 0x3f) & 1) != 0))\n               && (operation != 0)) goto LAB_001067f7;\n            filePtr = (FILE *)charPtr;\n            if (uintVar < 0xcc) {\n                    /* WARNING: Could not recover jumptable at 0x001065eb. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n              (*(code *)((long)(int *)pcVar43 + (long)((int *)pcVar43)[uintVar]))();\n              return;\n            }\nswitchD_00107462_caseD_1:\n            usage(0);\n            charPtr = (char *)filePtr;\nswitchD_00107462_caseD_68:\n            show_help = 1;\n          }\nLAB_00106680:\n          uintVar = operation;\n          filePtr = (FILE *)charPtr;\n          if (operation == 0) {\n            if (((write_armap == 1) || (mri_mode != 0)) ||\n               (((int)filePtr <= _optind || (_optind < 1)))) {\n              uintVar = 0;\n              goto LAB_001066aa;\n            }\n            charPtr = (char *)((long)charPtr + (long)_optind * 8 + -8);\n            uintVar = (int)filePtr - (_optind + -1);\n            filePtr = (FILE *)(ulong)uintVar;\n            _optind = 0;\n            if (1 < (int)uintVar) goto LAB_001063a3;\n            goto LAB_001065a2;\n          }\nLAB_001066aa:\n          unaff_R12 = (FILE *)((ulong)undefined8Var & 0xff);\n          uintVar = (uint)unaff_R12;\n          puVar36 = (undefined1 *)((int *)charPtr + (long)_optind * 2);\n          if (show_help == 0) {\n            if (show_version != 0) {\n              print_version(&DAT_0010807c);\n              goto LAB_00107591;\n            }\n            if (mri_mode == 0) {\n              filePtr = (FILE *)charPtr;\n              if (*(long *)puVar36 == 0) goto switchD_00107462_caseD_1;\n              if (operation == 7) {\n                if (write_armap == 0) {\n                  if (uintVar == 3) goto LAB_00106abc;\n                  if (uintVar != 0) goto LAB_00106700;\nLAB_00106eff:\n                  charPtr = \"no operation specified\";\n                  goto LAB_00106803;\n                }\n                operation = 2;\n                if (newer_only != 0) goto LAB_0010704f;\n              }\n              else if ((uintVar == 3) || (uintVar == 0)) {\n                if (write_armap == 1) {\n                  uintVar = ranlib_only();\n                    \n                  xexit(uintVar);\n                }\nLAB_00106abc:\n                if (uintVar == 0) goto LAB_00106eff;\n                if (newer_only != 0) {\nLAB_00106ad1:\n                  charPtr = \"`u\\' is only meaningful with the `r\\' option.\";\n                  goto LAB_00106803;\n                }\n              }\n              else {\nLAB_00106700:\n                if (newer_only != 0) goto LAB_00107548;\n              }\nLAB_0010670d:\n              if (deterministic < 0) {\n                deterministic = 1;\n              }\nLAB_00106720:\n              charPtr = (char *)0x0;\n              if (postype != 0) {\n                posname = *(long *)puVar36;\n                charPtr = (char *)0x1;\n                charPtr = \"missing position arg.\";\n                if (posname == 0) goto LAB_00106803;\n              }\n              if (counted_name_mode != '\\0') {\n                charPtr = \"`N\\' is only meaningful with the `x\\' and `d\\' options.\";\n                if ((operation & 0xfffffffb) == 1) {\n                  intVar = (int)charPtr;\n                  if (*(char **)((long)puVar36 + (long)intVar * 2 * 4) == (char *)0x0) {\n                    undefined8Var = dcgettext(0,\"`N\\' missing value.\",5);\n                    fatal(undefined8Var);\n                    uintVar = uintVar;\nLAB_00107548:\n                    if (uintVar == 2) {\nLAB_0010704f:\n                      charPtr = \"`u\\' is not meaningful with the `D\\' option.\";\n                      if (deterministic < 1) goto code_r0x00107068;\n                      goto LAB_00106803;\n                    }\n                    goto LAB_00106ad1;\n                  }\n                  charPtr = (char *)(ulong)(intVar + 1);\n                  longVar = strtol(*(char **)((long)puVar36 + (long)intVar * 2 * 4),(char **)0x0,10);\n                  charPtr = \"Value for `N\\' must be positive.\";\n                  counted_name_counter = (int)longVar;\n                  if (0 < counted_name_counter) goto LAB_0010673c;\n                }\n                goto LAB_00106803;\n              }\nLAB_0010673c:\n              longVar = (long)(int)charPtr;\n              filePtr = (FILE *)charPtr;\n              if (*(long *)(int *)((long)puVar36 + longVar * 2 * 4) == 0)\n              goto switchD_00107462_caseD_1;\n              filePtr = (FILE *)((long)puVar36 + (longVar + 1) * 2 * 4);\n              if (*(FILE **)filePtr == (FILE *)0x0) {\n                pcVar43 = (char *)0x0;\n                filePtr = (FILE *)0x0;\n              }\n              else if (*(long *)((long)puVar36 + (longVar + 2) * 2 * 4) == 0) {\n                pcVar43 = (char *)0x1;\n              }\n              else if (*(long *)((long)puVar36 + (longVar + 3) * 2 * 4) == 0) {\n                pcVar43 = (char *)0x2;\n              }\n              else if (*(long *)((long)puVar36 + (longVar + 4) * 2 * 4) == 0) {\n                pcVar43 = (char *)0x3;\n              }\n              else if (*(long *)((long)puVar36 + (longVar + 5) * 2 * 4) == 0) {\n                pcVar43 = (char *)0x4;\n              }\n              else {\n                filePtr = (FILE *)0x5;\n                do {\n                  pcVar43 = (char *)filePtr;\n                  filePtr = (FILE *)((long)(int *)pcVar43 + 1);\n                } while (*(long *)((int *)((long)puVar36 + longVar * 2 * 4) + (long)filePtr * 2) != 0\n                        );\n              }\n              undefined8Ptr = (undefined8 *)open_inarch();\n              filePtr = filePtr;\n              if (operation == 5) {\n                charPtr = \"`x\\' cannot be used on thin archives.\";\n                if ((*(byte *)((long)undefined8Ptr + 0x49) & 0x10) == 0) {\n                  charPtr = (char *)filePtr;\n                  if (libdeps != (char *)0x0) goto LAB_00106d5c;\nswitchD_00106ed8_caseD_5:\n                  map_over_members(undefined8Ptr,extract_file,charPtr,(ulong)pcVar43 & 0xffffffff);\n                  goto LAB_0010696c;\n                }\n                goto LAB_00106803;\n              }\n              if (libdeps != (char *)0x0) {\nLAB_00106d5c:\n                sizeVar = strlen(libdeps);\n                charPtr = \"__.LIBDEP\";\n                charPtr = (char *)(sizeVar + 1);\n                libdeps_bfd = bfd_create(\"__.LIBDEP\",undefined8Ptr);\n                if (libdeps_bfd == 0) {\n                  charPtr = \"Cannot create libdeps record.\";\n                }\n                else {\n                  longVar = bfd_find_target(\"binary\",libdeps_bfd);\n                  charPtr = \"Cannot set libdeps record type to binary.\";\n                  if (longVar != 0) {\n                    charVar = bfd_set_format(libdeps_bfd,1,5);\n                    charPtr = \"Cannot set libdeps object format.\";\n                    if (charVar == '\\0') goto LAB_00106803;\n                    charVar = bfd_make_writable(libdeps_bfd,\"Cannot set libdeps object format.\",5);\n                    charPtr = \"Cannot make libdeps object writable.\";\n                    if (charVar == '\\0') goto LAB_00106803;\n                    filePtr = (FILE *)bfd_bwrite(libdeps,charPtr,libdeps_bfd);\n                    charPtr = \"Cannot write libdeps record.\";\n                    if (filePtr != (FILE *)charPtr) goto LAB_00106803;\n                    charVar = bfd_make_readable(libdeps_bfd,\"Cannot write libdeps record.\",5);\n                    charPtr = \"Cannot make libdeps object readable.\";\n                    if (charVar == '\\0') goto LAB_00106803;\n                    longVar = bfd_find_target(\"plugin\",libdeps_bfd,5);\n                    charPtr = \"Cannot reset libdeps record type.\";\n                    if (longVar == 0) goto LAB_00106803;\n                    intVar = (int)pcVar43;\n                    undefined8Var = (FILE *)((long)(intVar + 2) * 8);\n                    charPtr = (char *)xmalloc(undefined8Var,\"Cannot reset libdeps record type.\");\n                    if (intVar == 0) {\n                      longVar = 0;\n                    }\n                    else {\n                      uintVar = *(undefined4 *)&filePtr->field_0x4;\n                      *(int *)charPtr = filePtr->_flags;\n                      *(undefined4 *)((long)charPtr + 4) = uintVar;\n                      longVar = 8;\n                      charPtrPtr = (char **)((long)charPtr + 8);\n                      for (pcVar43 = undefined8Var[-1]._unused2 + 4; pcVar43 != (char *)0x0;\n                          pcVar43 = pcVar43 + -1) {\n                        *(undefined *)charPtrPtr = *(undefined *)&filePtr->_flags;\n                        filePtr = (FILE *)((long)filePtr + (ulong)byteVar * -2 + 1);\n                        charPtrPtr = (char **)((long)charPtrPtr + (ulong)byteVar * -2 + 1);\n                      }\n                    }\n                    *(char **)((long)(char **)charPtr + longVar) = \"__.LIBDEP\";\n                    pcVar43 = (char *)(ulong)(intVar + 1);\n                    *(undefined8 *)\n                     (((FILE *)((long)charPtr + -0xd8))->_unused2 + 0xc + (long)undefined8Var) = 0;\n                    switch(operation) {\n                    case 1:\n                      goto switchD_00106ed8_caseD_1;\n                    case 2:\n                    case 7:\n                      break;\n                    case 3:\n                      goto switchD_00106ed8_caseD_3;\n                    case 4:\n                      goto switchD_00106ed8_caseD_4;\n                    case 5:\n                      goto switchD_00106ed8_caseD_5;\n                    case 6:\n                      filePtr = (FILE *)charPtr;\n                      if (silent_create == 0) goto LAB_00106afb;\n                      break;\n                    default:\n                      goto switchD_001067e8_caseD_5;\n                    }\n                    goto switchD_00106ed8_caseD_2;\n                  }\n                }\n                goto LAB_00106803;\n              }\n              switch(operation) {\n              case 1:\n                charPtr = (char *)filePtr;\n                if (filePtr == (FILE *)0x0) break;\nswitchD_00106ed8_caseD_1:\n                filePtr = (FILE *)0x0;\n                goto LAB_00106b89;\n              case 2:\n              case 7:\nswitchD_001067e8_caseD_2:\n                charPtr = (char *)filePtr;\n                if ((filePtr != (FILE *)0x0) || (0 < write_armap)) {\nswitchD_00106ed8_caseD_2:\n                  replace_members(undefined8Ptr,charPtr,operation == 7);\n                  goto LAB_0010696c;\n                }\n                break;\n              case 3:\n                charPtr = (char *)filePtr;\nswitchD_00106ed8_caseD_3:\n                map_over_members(undefined8Ptr,print_descr,charPtr,(ulong)pcVar43 & 0xffffffff);\n                goto LAB_0010696c;\n              case 4:\n                charPtr = (char *)filePtr;\nswitchD_00106ed8_caseD_4:\n                map_over_members(undefined8Ptr,print_contents,charPtr,(ulong)pcVar43 & 0xffffffff);\n                goto LAB_0010696c;\n              default:\nswitchD_001067e8_caseD_5:\n                charPtr = \"internal error -- this option not implemented\";\n                goto LAB_00106803;\n              case 6:\n                if (silent_create != 0) goto switchD_001067e8_caseD_2;\n                if (filePtr == (FILE *)0x0) break;\nLAB_00106afb:\n                filePtr = (FILE *)(undefined8Ptr + 0x1e);\n                do {\n                  unaff_R12 = filePtr;\n                  if (*(FILE **)filePtr == (FILE *)0x0) {\nLAB_00106b9f:\n                    write_archive(undefined8Ptr);\n                    goto LAB_0010696c;\n                  }\n                  while( true ) {\n                    longPtr = *(long **)unaff_R12;\n                    charPtr = *(char **)filePtr;\n                    if (longPtr == (long *)0x0) {\n                      undefined8Var = *undefined8Ptr;\n                      undefined8Var = dcgettext(0,\"no entry %s in archive %s!\",5);\n                      fatal(undefined8Var,charPtr,undefined8Var);\n                      pcVar43 = (char *)0x0;\n                      goto LAB_00107293;\n                    }\n                    longVar = *longPtr;\n                    undefined8Var = normalize(charPtr,undefined8Ptr);\n                    intVar = filename_cmp(undefined8Var,longVar);\n                    if (intVar == 0) break;\n                    unaff_R12 = (FILE *)(*(long **)unaff_R12 + 0x1e);\n                  }\n                  *(long **)unaff_R12 = (long *)longPtr[0x1e];\n                  plongPtrPtr = (long **)get_pos_bfd(filePtr,3,0);\n                  boolVar = verbose != 0;\n                  longPtr = *plongPtrPtr;\n                  *plongPtrPtr = longPtr;\n                  longPtr[0x1e] = (long)longPtr;\n                  if (boolVar) {\n                    printf(\"m - %s\\n\",*(FILE **)filePtr);\n                  }\n                  filePtr = (FILE *)&filePtr->_IO_read_ptr;\n                } while( true );\n              }\n              goto LAB_00106d4e;\n            }\n            if (-1 < deterministic) goto LAB_0010755f;\n          }\n          else {\nLAB_00107591:\n            usage(1);\n          }\n          deterministic = 1;\nLAB_0010755f:\n          intVar = fileno(_stdin);\n          interactive = isatty(intVar);\n          yyparse_isra_0();\nLAB_0010696c:\n                    \n          xexit(0);\n        }\n        uintVar = bfd_get_error();\n        filePtr = (FILE *)bfd_errmsg(uintVar);\n        undefined8Var = dcgettext(0,\"can\\'t set BFD default target to `%s\\': %s\",5);\n        intVar = fatal(undefined8Var,\"x86_64-pc-linux-gnu\",filePtr);\nLAB_0010751b:\n        if (operation == 0) {\nLAB_00107447:\n          puVar36 = charPtr;\n          filePtr = (FILE *)charPtr;\n          switch(intVar) {\n          case 0:\n            goto switchD_00107462_caseD_0;\n          default:\n            goto switchD_00107462_caseD_1;\n          case 0x44:\n            deterministic = 1;\n            goto LAB_001065a2;\n          case 0x4d:\n            mri_mode = 1;\n            goto LAB_001065a2;\n          case 0x4e:\n            counted_name_mode = '\\x01';\n            goto LAB_001065a2;\n          case 0x4f:\n            display_offsets = 1;\n            goto LAB_001065a2;\n          case 0x50:\n            full_pathname = 1;\n            goto LAB_001065a2;\n          case 0x53:\n            write_armap = -1;\n            goto LAB_001065a2;\n          case 0x54:\n            make_thin_archive = 1;\n            goto LAB_001065a2;\n          case 0x55:\n            deterministic = 0;\n            goto LAB_001065a2;\n          case 0x56:\n            show_version = 1;\n            goto LAB_001065a2;\n          case 0x61:\n            postype = 2;\n            goto LAB_001065a2;\n          case 0x62:\n          case 0x69:\n            postype = 1;\n            goto LAB_001065a2;\n          case 99:\n            silent_create = 1;\n            goto LAB_001065a2;\n          case 100:\n            operation = 1;\n            operation_alters_arch = 1;\n            goto LAB_001065a2;\n          case 0x66:\n            ar_truncate = 1;\n            goto LAB_001065a2;\n          case 0x68:\n            goto switchD_00107462_caseD_68;\n          case 0x6c:\n            if (libdeps == (char *)0x0) {\n              libdeps = _optarg;\n              goto LAB_001065a2;\n            }\nLAB_00107293:\n            uintVar = (uint)unaff_R12;\n            charPtr = \"libdeps specified more than once\";\n            charPtr = (char *)filePtr;\n            break;\n          case 0x6d:\n            operation = 6;\n            operation_alters_arch = 1;\n            goto LAB_001065a2;\n          case 0x6f:\n            preserve_dates = 1;\n            goto LAB_001065a2;\n          case 0x70:\n            operation = 4;\n            goto LAB_001065a2;\n          case 0x71:\n            operation = 7;\n            operation_alters_arch = 1;\n            goto LAB_001065a2;\n          case 0x72:\n            operation = 2;\n            operation_alters_arch = 1;\n            goto LAB_001065a2;\n          case 0x73:\n            write_armap = 1;\n            goto LAB_001065a2;\n          case 0x74:\n            operation = 3;\n            goto LAB_001065a2;\n          case 0x75:\n            newer_only = 1;\n            goto LAB_001065a2;\n          case 0x76:\n            verbose = 1;\n            goto LAB_001065a2;\n          case 0x78:\n            operation = 5;\n            goto LAB_001065a2;\n          case 0xc9:\n            bfd_plugin_set_plugin(_optarg);\n            goto LAB_001065a2;\n          case 0xca:\n            target = _optarg;\n            goto LAB_001065a2;\n          case 0xcb:\n            output_dir = _optarg;\n            goto LAB_001065a2;\n          }\n          goto LAB_00106803;\n        }\nLAB_001067f7:\n        charPtr = \"two different operation options specified\";\n        charPtr = (char *)filePtr;\nLAB_00106803:\n        undefined8Var = dcgettext(0,charPtr,5);\n        fatal(undefined8Var);\nLAB_00106814:\n        intVar = (int)charPtr;\n        filePtr = (FILE *)xmalloc(8);\n        *(long **)filePtr = (long *)0x0;\n        if ((FILE *)pcVar43 == argv) {\nLAB_00106834:\n          if (*(long **)pcVar43 == (long *)0x0) {\n            intVar = 0;\n          }\n          else {\n            longVar = 1;\n            do {\n              intVar = (int)longVar;\n              longVar = longVar * 2;\n              longVar = longVar + 1;\n            } while (*(long *)((int *)pcVar43 + longVar) != 0);\n          }\n          filePtr = (FILE *)xmalloc((long)(intVar + 1) << 3);\n          longPtr = *(long **)pcVar43;\n          longVar = 0;\n          while (longPtr != (long *)0x0) {\n            undefined8Var = xstrdup();\n            *(undefined8 *)((long)&filePtr->_flags + longVar) = undefined8Var;\n            longPtr = *(long **)((char *)((long)pcVar43 + 0x83) + longVar + -0x7b);\n            longVar = longVar + 8;\n          }\n          *(undefined8 *)((long)&filePtr->_flags + longVar) = 0;\nLAB_0010610a:\n          intVar = (int)charPtr;\n          pcVar43 = (char *)filePtr;\n          if (*(long **)filePtr == (long *)0x0) goto LAB_00106a80;\n          longVar = 0;\n          do {\n            longVar = longVar + 1;\n            longVar = longVar * 8;\n            longVar = longVar;\n          } while (*(long *)(filePtr->_shortbuf + longVar + -0x7b) != 0);\n          sizeVar = longVar * 8;\n        }\n        else {\nLAB_00106a80:\n          longVar = 0;\n          sizeVar = 0;\n        }\n        longVar = (long)charPtr * 2;\n        charPtr = (char *)((long)(char **)charPtr + longVar);\n        free(*(void **)((int *)pcVar43 + longVar));\n        filePtr = (FILE *)xrealloc(pcVar43,(longVar + 1 + (long)intVar) * 8);\n        uintVar = intVar + -1 + (int)longVar;\n        charPtr = (char *)(ulong)uintVar;\n        memmove(&filePtr->_flags + (long)charPtr * 2,\n                (void *)((long)&filePtr->_IO_read_ptr + (long)undefined8Var),\n                (long)(int)(intVar - uintVar) << 3);\n        memcpy((void *)((long)&undefined8Var->_flags + (long)&filePtr->_flags),filePtr,sizeVar);\n        free(filePtr);\n        free(byteArray);\n        fclose(filePtr);\n        uintVar = (int)filePtr + 1;\n        unaff_R12 = undefined8Var;\n        pcVar43 = (char *)filePtr;\n        undefined8Var = filePtr;\n        if ((int)uintVar < (int)uintVar) goto LAB_001061ce;\n      } while( true );\n    }\n    uintVar = uintVar + 1;\n    filePtr = unaff_R12;\nLAB_001061ce:\n    unaff_R12 = (FILE *)(ulong)uintVar;\n  } while( true );\nswitchD_00107462_caseD_0:\n  intVar = getopt_long((ulong)filePtr & 0xffffffff,charPtr,filePtr,\"x86_64-pc-linux-gnu\");\n  charPtr = (char *)filePtr;\n  if (intVar == -1) goto LAB_00106680;\n  if ((0x14 < intVar - 100U) || ((0x117201UL >> ((byte)(intVar - 100U) & 0x3f) & 1) == 0))\n  goto LAB_00107447;\n  goto LAB_0010751b;\ncode_r0x00107068:\n  if (deterministic != 0) goto code_r0x0010706e;\n  goto LAB_00106720;\ncode_r0x0010706e:\n  undefined8Var = dcgettext(0,\"`u\\' modifier ignored since `D\\' is the default (see `U\\')\",5);\n  non_fatal(undefined8Var);\n  goto LAB_0010670d;\nLAB_00106b89:\n  if (*(FILE **)charPtr == (FILE *)0x0) {\n    if ((char)filePtr != '\\0') goto LAB_00106b9f;\nLAB_00106d4e:\n    output_filename = 0;\n    goto LAB_0010696c;\n  }\n  intVar = 0;\n  intVar = strcmp((char *)*(FILE **)charPtr,\"__.SYMDEF\");\n  undefined8Ptr = undefined8Ptr;\n  if (intVar == 0) {\n    *(byte *)((long)undefined8Ptr + 0x49) = *(byte *)((long)undefined8Ptr + 0x49) & 0xf7;\n    write_armap = -1;\n  }\n  else {\n    while( true ) {\n      longPtr = undefined8Ptr + 0x1e;\n      if ((undefined8 *)*longPtr == (undefined8 *)0x0) break;\n      undefined8Var = *(undefined8 *)*longPtr;\n      undefined8Var = normalize(*(FILE **)charPtr,undefined8Ptr);\n      intVar = filename_cmp(undefined8Var,undefined8Var);\n      if ((intVar == 0) &&\n         ((counted_name_mode == '\\0' || (intVar = intVar + 1, intVar == counted_name_counter)))) {\n        if (verbose != 0) {\n          printf(\"d - %s\\n\",*(FILE **)charPtr);\n        }\n        *longPtr = *(long *)(*longPtr + 0xf0);\n        filePtr = unaff_R12;\n        goto LAB_00106d38;\n      }\n      undefined8Ptr = (undefined8 *)*longPtr;\n    }\n    if (verbose != 0) {\n      filePtr = *(FILE **)charPtr;\n      charPtr = (char *)dcgettext(0,\"No member named `%s\\'\\n\",5);\n      printf(charPtr,filePtr);\n    }\n  }\nLAB_00106d38:\n  charPtr = (char *)((long)charPtr + 8);\n  goto LAB_00106b89;\n}\n\n",
            "called": [
                "open_inarch",
                "bfd_fatal",
                "fprintf",
                "strtol",
                "fread",
                "fclose",
                "bfd_plugin_set_program_name",
                "bfd_errmsg",
                "bfd_plugin_set_plugin",
                "bfd_nonfatal",
                "dcgettext",
                "non_fatal",
                "strcmp",
                "fatal",
                "xmalloc",
                "memmove",
                "write_archive",
                "bindtextdomain",
                "normalize",
                "setlocale",
                "replace_members",
                "printf",
                "ranlib_usage",
                "bfd_close",
                "fopen",
                "bfd_set_format",
                "print_contents",
                "bfd_make_writable",
                "ar_emul_default_parse_arg",
                "bfd_check_format_matches",
                "memcpy",
                "bfd_find_target",
                "bfd_set_error_program_name",
                "bfd_get_error",
                "print_version",
                "open",
                "bfd_set_error",
                "free",
                "bfd_init",
                "xstrdup",
                "ranlib_only",
                "getopt_long",
                "ferror",
                "map_over_members",
                "get_file_size",
                "fileno",
                "bfd_create",
                "stat",
                "strlen",
                "filename_cmp",
                "bfd_set_default_target",
                "bfd_bwrite",
                "bfd_make_readable",
                "usage",
                "xexit",
                "bfd_fdopenr",
                "ftell",
                "textdomain",
                "fseek",
                "remove_output",
                "yyparse.isra.0",
                "xmalloc_set_program_name",
                "print_descr",
                "get_pos_bfd",
                "list_matching_formats",
                "extract_file",
                "xrealloc",
                "xatexit_cleanup",
                "isatty",
                "malloc",
                "lbasename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105db0",
            "calling": [
                "_start"
            ],
            "imported": false,
            "current_name": "extract_files_00105db0"
        },
        "FUN_00102150": {
            "renaming": {},
            "code": "\n\n\nchar * ctime(time_t *__timer)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = ctime(__timer);\n  return pcVar1;\n}\n\n",
            "called": [
                "ctime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102150",
            "calling": [
                "print_arelt_descr"
            ],
            "imported": false,
            "current_name": "FUN_00102150"
        },
        "FUN_00102270": {
            "renaming": {},
            "code": "\nvoid xstrdup(void)\n\n{\n  xstrdup();\n  return;\n}\n\n",
            "called": [
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102270",
            "calling": [
                "ar_open",
                "write_archive",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102270"
        },
        "FUN_00103bd1": {
            "renaming": {
                "FUN_00103bd1": "print_matching_formats_00103bd1",
                "param_1": "formatStrings",
                "uVar1": "programName",
                "__format": "formatString",
                "plVar2": "currentFormat"
            },
            "code": "\n\n\nvoid printMatchingFormats_00103bd1(long *formatStrings)\n\n{\n  undefined8 programName;\n  char *formatString;\n  long *currentFormat;\n  \n  fflush(_stdout);\n  programName = program_name;\n  formatString = (char *)dcgettext(0,\"%s: Matching formats:\",5);\n  fprintf(_stderr,formatString,programName);\n  for (currentFormat = formatStrings; *currentFormat != 0; currentFormat = currentFormat + 1) {\n    fprintf(_stderr,\" %s\");\n  }\n  free(formatStrings);\n  fputc(10,_stderr);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fflush",
                "fputc",
                "free",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103bd1",
            "calling": [
                "open_inarch",
                "main"
            ],
            "imported": false,
            "current_name": "print_matching_formats_00103bd1"
        },
        "FUN_00102030": {
            "renaming": {},
            "code": "\n\n\nvoid free(void *__ptr)\n\n{\n  free(__ptr);\n  return;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102030",
            "calling": [
                "list_matching_formats",
                "print_contents",
                "list_supported_targets",
                "extract_file.cold",
                "write_archive.cold",
                "main",
                "make_tempname.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102030"
        },
        "FUN_00102710": {
            "renaming": {
                "FUN_00102710": "extract_archived_files_00102710",
                "plVar1": "currentFilePointer",
                "cVar2": "formatCorrect",
                "bVar3": "isThinArchive",
                "iVar4": "error",
                "lVar5": "filePointer",
                "uVar6": "errorMessage",
                "uVar7": "formatMessage",
                "puVar8": "outputFilePointer",
                "unaff_RBP": "outputFilename",
                "in_stack_00000008": "matchingFormat",
                "silent_create": "isSilentCreate",
                "make_thin_archive": "isThinArchiveConversion",
                "xexit": "exitProgram",
                "target": "targetFormat",
                "fatal": "errorMessageAndExit",
                "dcgettext": "getMessage",
                "bfd_openr": "openInputFile",
                "bfd_check_format": "checkFormat",
                "bfd_close": "closeFile",
                "bfd_set_format": "setFormat",
                "bfd_fatal": "fatalError",
                "bfd_nonfatal": "nonFatalError",
                "bfd_get_error": "getError",
                "list_matching_formats": "listMatchingFormats",
                "output_filename": "outputFilename",
                "bfd_openr_next_archived_file": "openNextArchivedFile",
                "operation": "currentOperation",
                "stack0x00000008": "stackArgument"
            },
            "code": "\nundefined8 * extractArchivedFiles_00102710(void)\n\n{\n  long *currentFilePointer;\n  char formatCorrect;\n  byte isThinArchive;\n  int error;\n  long filePointer;\n  undefined8 errorMessage;\n  undefined8 formatMessage;\n  undefined8 *outputFilePointer;\n  undefined8 outputFilename;\n  undefined8 matchingFormat;\n  \n  filePointer = openInputFile();\n  if (filePointer != 0) {\n    formatCorrect = checkFormat(filePointer,1);\n    if (formatCorrect != '\\0') {\n      targetFormat = **(undefined8 **)(filePointer + 8);\n    }\n    closeFile(filePointer);\n  }\n  outputFilePointer = (undefined8 *)bfd_openw();\n  if (((outputFilePointer != (undefined8 *)0x0) && (formatCorrect = setFormat(outputFilePointer,2), formatCorrect != '\\0')) &&\n     (formatCorrect = closeFile(outputFilePointer), formatCorrect != '\\0')) {\n    if (isSilentCreate == 0) goto LAB_00102826;\n    goto LAB_001053b7;\n  }\n  fatalError();\n  do {\n    isThinArchive = *(byte *)((long)outputFilePointer + 0x49) >> 4 & 1;\n    if (isThinArchiveConversion == '\\0') {\n      if (isThinArchive != 0) {\n        formatMessage = *outputFilePointer;\n        errorMessage = getMessage(0,\"Cannot convert existing thin library %s to normal format\",5);\n        errorMessageAndExit(errorMessage,formatMessage);\n        goto LAB_00102812;\n      }\n    }\n    else if (isThinArchive == 0) {\n      formatMessage = *outputFilePointer;\n      errorMessage = getMessage(0,\"Cannot convert existing library %s to thin format\",5);\n      errorMessageAndExit(errorMessage,formatMessage);\nLAB_001027cb:\n      nonFatalError();\n      error = getError();\n      if (error == 0xd) {\nLAB_00102812:\n        listMatchingFormats(matchingFormat);\n      }\n                    \n      exitProgram(1);\n    }\n    do {\n      currentFilePointer = outputFilePointer + 0x1e;\n      for (filePointer = openNextArchivedFile(outputFilePointer,0); filePointer != 0;\n          filePointer = openNextArchivedFile(outputFilePointer,filePointer)) {\n        *currentFilePointer = filePointer;\n        currentFilePointer = (long *)(filePointer + 0xf0);\n      }\n      *currentFilePointer = 0;\n      error = getError();\n      if (error == 9) {\n        return outputFilePointer;\n      }\n      do {\n        fatalError();\nLAB_00102826:\n        formatMessage = getMessage(0,\"creating %s\",5);\n        non_errorMessageAndExit(formatMessage);\nLAB_001053b7:\n        outputFilename = outputFilename;\n        outputFilePointer = (undefined8 *)openInputFile();\n      } while (outputFilePointer == (undefined8 *)0x0);\n      formatCorrect = checkFormat_matches(outputFilePointer,2,&stackArgument);\n      if (formatCorrect == '\\0') goto LAB_001027cb;\n    } while (((currentOperation != 2) && (currentOperation != 7)) ||\n            (filePointer = openNextArchivedFile(outputFilePointer,0), filePointer == 0));\n  } while( true );\n}\n\n",
            "called": [
                "bfd_check_format",
                "bfd_close",
                "bfd_openr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102710",
            "calling": [
                "open_inarch"
            ],
            "imported": false,
            "current_name": "extract_archived_files_00102710"
        },
        "FUN_0010e2b0": {
            "renaming": {},
            "code": "\n\n\n\nvoid exit(int __status)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* exit@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e2b0",
            "calling": [
                "exit"
            ],
            "imported": false,
            "current_name": "FUN_0010e2b0"
        },
        "FUN_0010e208": {
            "renaming": {},
            "code": "\n\n\n\nint fflush(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fflush@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e208",
            "calling": [
                "fflush"
            ],
            "imported": false,
            "current_name": "FUN_0010e208"
        },
        "FUN_00103e95": {
            "renaming": {
                "FUN_00103e95": "convert_to_binary_00103e95",
                "pplVar1": "doublePointerData",
                "cVar2": "character",
                "ppFVar3": "doubleFilePointer",
                "pFVar4": "filePointer",
                "plVar5": "longDataPointer",
                "uVar6": "unsignedLongData",
                "pbVar7": "bytePointer",
                "iVar8": "integerData",
                "pcVar10": "characterData",
                "uVar11": "unsignedLongData",
                "iVar9": "integerData",
                "plVar12": "longDataPointer",
                "sVar13": "sizeData",
                "pvVar14": "voidPointer",
                "pcVar15": "characterData",
                "pcVar16": "characterData",
                "lVar17": "longData",
                "lVar18": "longData",
                "uVar19": "unsignedLongData",
                "uVar20": "unsignedIntegerData",
                "lVar21": "longData",
                "puVar22": "unsignedLongDataPointer",
                "puVar23": "unsignedLongDataPointer",
                "uVar24": "unsignedIntegerData",
                "iVar25": "integerData",
                "uVar26": "unsignedLongData",
                "ppcVar27": "doubleCharacterPointer",
                "bVar28": "booleanData",
                "bVar30": "byteData",
                "lVar31": "longData",
                "pbVar32": "bytePointer",
                "pbVar33": "bytePointer",
                "piVar34": "integerPointer",
                "pbVar35": "bytePointer",
                "uVar36": "unsignedIntegerData",
                "iVar37": "integerData",
                "ppcVar29": "doubleCharacterPointer",
                "local_828": "localCharacterPointer",
                "local_820": "localCharacterPointer",
                "local_818": "localLongData",
                "local_810": "localDoubleCharacterPointer",
                "local_800": "localIntegerData",
                "local_7fc": "localUnsignedIntegerData",
                "local_7f8": "localBytePointer",
                "local_7d0": "localStatData",
                "local_740": "localCharacterArray",
                "local_678": "localCharacterDoublePointer"
            },
            "code": "\n\n\nvoid convertToBinary_00103e95(void)\n\n{\n  long **doublePointerData;\n  char character;\n  FILE **doubleFilePointer;\n  FILE *filePointer;\n  long *longDataPointer;\n  undefined8 unsignedLongData;\n  byte *bytePointer;\n  int integerData;\n  char *characterData;\n  undefined8 unsignedLongData;\n  int integerData;\n  long *longDataPointer;\n  size_t sizeData;\n  void *voidPointer;\n  char *characterData;\n  char *characterData;\n  long longData;\n  long longData;\n  ulong unsignedLongData;\n  uint unsignedIntegerData;\n  long longData;\n  undefined8 *unsignedLongDataPointer;\n  undefined8 *unsignedLongDataPointer;\n  uint unsignedIntegerData;\n  int integerData;\n  ulong unsignedLongData;\n  char **doubleCharacterPointer;\n  bool booleanData;\n  char **doubleCharacterPointer;\n  byte byteData;\n  long longData;\n  byte *bytePointer;\n  byte *bytePointer;\n  int *integerPointer;\n  byte *bytePointer;\n  uint unsignedIntegerData;\n  int integerData;\n  char **ppcVar38;\n  byte bVar39;\n  undefined auVar40 [16];\n  undefined auVar41 [16];\n  char *localCharacterPointer;\n  char *localCharacterPointer;\n  long localLongData;\n  char **localDoubleCharacterPointer;\n  int localIntegerData;\n  uint localUnsignedIntegerData;\n  byte *localBytePointer;\n  stat localStatData;\n  char localCharacterArray [200];\n  char *localCharacterDoublePointer [201];\n  \n  bVar39 = 0;\n  longData = 0;\n  yychar = -2;\n  doubleCharacterPointer = localCharacterDoublePointer;\n  localIntegerData = 0;\n  localCharacterPointer = localCharacterArray;\n  localLongData = 200;\n  localCharacterPointer = localCharacterPointer;\n  localDoubleCharacterPointer = doubleCharacterPointer;\nLAB_00103ee9:\n  *localCharacterPointer = (char)longData;\n  if (localCharacterPointer + localLongData + -1 <= localCharacterPointer) {\n    longData = (long)localCharacterPointer - (long)localCharacterPointer;\n    longData = longData + 1;\n    if (localLongData < 10000) {\n      longData = localLongData * 2;\n      localLongData = 10000;\n      if (longData < 0x2711) {\n        localLongData = longData;\n      }\n      characterData = (char *)malloc(localLongData * 9 + 7);\n      if (characterData != (char *)0x0) {\n        longData = longData * 8;\n        characterData = localCharacterPointer;\n        characterData = characterData;\n        for (; longData != 0; longData = longData + -1) {\n          *characterData = *characterData;\n          characterData = characterData + (ulong)bVar39 * -2 + 1;\n          characterData = characterData + (ulong)bVar39 * -2 + 1;\n        }\n        ppcVar38 = (char **)(characterData + localLongData);\n        doubleCharacterPointer = ppcVar38;\n        for (; longData != 0; longData = longData + -1) {\n          *(undefined *)doubleCharacterPointer = *(undefined *)localDoubleCharacterPointer;\n          localDoubleCharacterPointer = (char **)((long)localDoubleCharacterPointer + (ulong)bVar39 * -2 + 1);\n          doubleCharacterPointer = (char **)((long)doubleCharacterPointer + (ulong)bVar39 * -2 + 1);\n        }\n        if (localCharacterPointer != localCharacterArray) {\n          free(localCharacterPointer);\n        }\n        localCharacterPointer = characterData + longData;\n        doubleCharacterPointer = ppcVar38 + longData;\n        localCharacterPointer = characterData;\n        localDoubleCharacterPointer = ppcVar38;\n        if (characterData + localLongData + -1 <= localCharacterPointer) goto LAB_00105265;\n        goto LAB_00103fd8;\n      }\n    }\n    yyerror_constprop_0();\nLAB_0010524c:\n    characterData = localCharacterPointer;\n    if (localCharacterPointer == localCharacterArray) {\n      return;\n    }\nLAB_00105265:\n    free(characterData);\n    return;\n  }\nLAB_00103fd8:\n  integerData = (int)longData;\n  if (integerData == 3) goto LAB_0010524c;\n  character = (&yypact)[integerData];\n  if (character != -0xe) {\n    if (yychar == -2) {\n      if (yy_init == 0) {\n        yy_init = 1;\n        if (yy_start == 0) {\n          yy_start = 1;\n        }\n        if (yyin == (FILE *)0x0) {\n          yyin = _stdin;\n        }\n        if (yyout == (FILE *)0x0) {\n          yyout = _stdout;\n        }\n        if ((yy_buffer_stack == 0) || (*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) == 0)) {\n          yyensure_buffer_stack();\n          unsignedLongDataPointer = (undefined8 *)(yy_buffer_stack + yy_buffer_stack_top * 8);\n          unsignedLongData = yy_create_buffer_constprop_0(yyin);\n          *unsignedLongDataPointer = unsignedLongData;\n        }\n        yy_load_buffer_state();\n      }\nLAB_001040b1:\n      *yy_c_buf_p = yy_hold_char;\n      bytePointer = yy_c_buf_p;\n      bytePointer = yy_c_buf_p;\n      unsignedIntegerData = yy_start;\nLAB_001040d4:\n      unsignedLongData = (ulong)unsignedIntegerData;\n      unsignedLongData = (ulong)localUnsignedIntegerData;\n      booleanData = false;\n      do {\n        byteData = yy_ec[*bytePointer];\n        if (*(short *)(yy_accept + (long)(int)unsignedLongData * 2) != 0) {\n          booleanData = true;\n          unsignedLongData = unsignedLongData & 0xffffffff;\n          localBytePointer = bytePointer;\n        }\n        while( true ) {\n          integerData = (int)unsignedLongData;\n          longData = (long)(int)((int)*(short *)(yy_base + (long)integerData * 2) + (uint)byteData);\n          if (integerData == *(short *)(yy_chk + longData * 2)) break;\n          unsignedLongData = (ulong)(uint)(int)*(short *)(yy_def + (long)integerData * 2);\n          if (0xb0 < *(short *)(yy_def + (long)integerData * 2)) {\n            byteData = yy_meta[(int)(uint)byteData];\n          }\n        }\n        bytePointer = bytePointer + 1;\n        unsignedLongData = (ulong)*(short *)(yy_nxt + longData * 2);\n      } while (*(short *)(yy_base + unsignedLongData * 2) != 0xc2);\n      localUnsignedIntegerData = (uint)unsignedLongData;\n      bytePointer = bytePointer;\n      if (booleanData) {\n        yy_last_accepting_cpos = localBytePointer;\n        yy_last_accepting_state = localUnsignedIntegerData;\n      }\nLAB_0010419f:\n      integerData = (int)*(short *)(yy_accept + (long)(int)unsignedLongData * 2);\n      if (integerData == 0) {\n        integerData = (int)*(short *)(yy_accept + (long)(int)yy_last_accepting_state * 2);\n        bytePointer = yy_last_accepting_cpos;\n      }\n      yyleng = (int)bytePointer - (int)bytePointer;\n      yy_hold_char = *bytePointer;\n      yy_c_buf_p = bytePointer;\n      yytext = bytePointer;\n      *bytePointer = 0;\nLAB_001041f0:\n      bytePointer = yytext;\n      longData = yy_buffer_stack_top;\n      switch(integerData) {\n      case 0:\n        goto switchD_00104200_caseD_0;\n      case 1:\n      case 0x10:\n        yychar = 0x105;\n        break;\n      case 2:\n      case 0x11:\n        yychar = 0x107;\n        break;\n      case 3:\n      case 0x12:\n        yychar = 0x108;\n        break;\n      case 4:\n      case 0x13:\n        yychar = 0x109;\n        break;\n      case 5:\n      case 0x14:\n        yychar = 0x10a;\n        break;\n      case 6:\n      case 0x15:\n        yychar = 0x10b;\n        break;\n      case 7:\n      case 0x16:\n        yychar = 0x10c;\n        break;\n      case 8:\n      case 0x17:\n        yychar = 0x10d;\n        break;\n      case 9:\n      case 0x18:\n        yychar = 0x10e;\n        break;\n      case 10:\n      case 0x19:\n        yychar = 0x10f;\n        break;\n      case 0xb:\n      case 0x1a:\n        yychar = 0x106;\n        break;\n      case 0xc:\n      case 0x1b:\n        yychar = 0x113;\n        break;\n      case 0xd:\n      case 0x1c:\n        yychar = 0x111;\n        break;\n      case 0xe:\n      case 0x1d:\n        yychar = 0x103;\n        break;\n      case 0x1f:\n        linenumber = linenumber + 1;\n        goto LAB_001040b1;\n      case 0x20:\n        yychar = 0x28;\n        break;\n      case 0x21:\n        yychar = 0x29;\n        break;\n      case 0x22:\n        yychar = 0x2c;\n        break;\n      case 0x23:\n        yylval = (char *)xstrdup(yytext);\n        yychar = 0x104;\n        break;\n      case 0x24:\n      case 0x25:\n      case 0x26:\n        goto LAB_001040b1;\n      case 0x27:\n        linenumber = linenumber + 1;\n        yychar = 0x102;\n        break;\n      case 0x28:\n        fwrite(yytext,(long)yyleng,1,yyout);\n        goto LAB_001040b1;\n      case 0x29:\n        goto switchD_00104200_caseD_29;\n      case 0x2a:\n        yychar = 0;\n        break;\n      default:\n        yy_fatal_error(\"fatal flex scanner internal error--no action found\");\n      case 0xf:\n      case 0x1e:\n        yychar = 0x112;\n      }\n      longData = (long)integerData;\n    }\n    if (0 < yychar) {\n      if (yychar != 0x100) {\n        integerData = 2;\n        if (yychar < 0x114) {\n          integerData = (int)(char)yytranslate[yychar];\n        }\n        goto LAB_0010497d;\n      }\n      yychar = 0x101;\n      goto LAB_001051f0;\n    }\n    integerData = 0;\n    yychar = 0;\nLAB_0010497d:\n    unsignedIntegerData = character + integerData;\n    if ((0x22 < unsignedIntegerData) || (integerData != (char)yycheck[(int)unsignedIntegerData])) goto LAB_001049db;\n    character = yytable[(int)unsignedIntegerData];\n    longData = (long)character;\n    if (character < '\\x01') {\n      integerData = -(int)character;\n      goto LAB_00104a0a;\n    }\n    yychar = -2;\n    localIntegerData = localIntegerData + -1 + (uint)(localIntegerData == 0);\n    doubleCharacterPointer = doubleCharacterPointer + 1;\n    *doubleCharacterPointer = yylval;\n    goto LAB_001049d1;\n  }\nLAB_001049db:\n  integerData = (int)(char)(&yydefact)[(int)longData];\n  if ((&yydefact)[(int)longData] == '\\0') {\n    if (localIntegerData == 0) {\n      yynerrs = yynerrs + 1;\n      yyerror_constprop_0();\nLAB_001051f0:\n      do {\n        if (((((char)(&yypact)[longData] != -0xe) &&\n             (unsignedIntegerData = (int)(char)(&yypact)[longData] + 1, unsignedIntegerData < 0x23)) &&\n            (yycheck[(int)unsignedIntegerData] == '\\x01')) &&\n           (longData = (long)(char)yytable[(int)unsignedIntegerData], '\\0' < (char)yytable[(int)unsignedIntegerData]))\n        goto LAB_00105227;\n        if (localCharacterPointer == localCharacterPointer) goto LAB_0010524c;\n        localCharacterPointer = localCharacterPointer + -1;\n        doubleCharacterPointer = doubleCharacterPointer + -1;\n        longData = (long)*localCharacterPointer;\n      } while( true );\n    }\n    if (localIntegerData != 3) goto LAB_001051f0;\n    if (0 < yychar) {\n      yychar = -2;\n      goto LAB_001051f0;\n    }\n    if (yychar != 0) goto LAB_001051f0;\n    goto LAB_0010524c;\n  }\nLAB_00104a0a:\n  unsignedLongData = program_name;\n  doubleCharacterPointer = obfd;\n  character = yyr2[integerData];\n  ppcVar38 = (char **)doubleCharacterPointer[1 - character];\n  switch(integerData) {\n  case 2:\n  case 6:\n    prompt();\n    break;\n  case 0x13:\n    if (obfd == (char **)0x0) {\n      return;\n    }\n    bfd_cache_close();\n    unlink(*obfd);\n    return;\n  case 0x15:\n    yyerror_constprop_0();\n    break;\n  case 0x17:\n    unsignedLongDataPointer = (undefined8 *)*doubleCharacterPointer;\n    if (obfd == (char **)0x0) {\n      characterData = \"%s: no open archive\\n\";\nLAB_00104b62:\n      characterData = (char *)dcgettext(0,characterData,5);\n      fprintf(_stderr,characterData,unsignedLongData);\n      maybequit();\n    }\n    else {\n      for (; unsignedLongDataPointer != (undefined8 *)0x0; unsignedLongDataPointer = (undefined8 *)unsignedLongDataPointer[1]) {\n        for (unsignedLongDataPointer = (undefined8 *)obfd[0x1f]; unsignedLongDataPointer != (undefined8 *)0x0;\n            unsignedLongDataPointer = (undefined8 *)unsignedLongDataPointer[0x1e]) {\n          integerData = filename_cmp(*unsignedLongDataPointer);\n          if (integerData == 0) {\n            extract_file();\n            goto LAB_00104adf;\n          }\n        }\n        bfd_openr(*unsignedLongDataPointer,0);\n        unsignedLongData = program_name;\n        unsignedLongData = *unsignedLongDataPointer;\n        characterData = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,characterData,unsignedLongData,unsignedLongData);\nLAB_00104adf:\n      }\n    }\n    break;\n  case 0x18:\n    unsignedLongDataPointer = (undefined8 *)*doubleCharacterPointer;\n    if (obfd == (char **)0x0) {\nLAB_00104b4f:\n      characterData = \"%s: no open output archive\\n\";\n      goto LAB_00104b62;\n    }\n    for (; unsignedLongDataPointer != (undefined8 *)0x0; unsignedLongDataPointer = (undefined8 *)unsignedLongDataPointer[1]) {\n      booleanData = false;\n      doubleCharacterPointer = obfd + 0x1f;\n      for (characterData = obfd[0x1f]; characterData != (char *)0x0; characterData = *(char **)(characterData + 0xf0)) {\n        integerData = filename_cmp();\n        if (integerData == 0) {\n          characterData = (char *)bfd_openr(*unsignedLongDataPointer,0);\n          unsignedLongData = program_name;\n          if (characterData == (char *)0x0) {\n            unsignedLongData = *unsignedLongDataPointer;\n            characterData = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n            fprintf(_stderr,characterData,unsignedLongData,unsignedLongData);\n            maybequit();\n          }\n          else {\n            *doubleCharacterPointer = characterData;\n            booleanData = true;\n            *(undefined8 *)(characterData + 0xf0) = *(undefined8 *)(characterData + 0xf0);\n          }\n        }\n        else {\n          doubleCharacterPointer = (char **)(characterData + 0xf0);\n        }\n      }\n      if (!booleanData) {\n        characterData = (char *)bfd_openr(*unsignedLongDataPointer,0);\n        unsignedLongData = program_name;\n        unsignedLongData = *unsignedLongDataPointer;\n        characterData = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,characterData,unsignedLongData,unsignedLongData);\n        unsignedLongData = program_name;\n        if (characterData == (char *)0x0) {\n          unsignedLongData = *unsignedLongDataPointer;\n          characterData = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n          fprintf(_stderr,characterData,unsignedLongData,unsignedLongData);\n          maybequit();\n        }\n        else {\n          *doubleCharacterPointer = characterData;\n        }\n      }\n    }\n    break;\n  case 0x19:\n    if (obfd != (char **)0x0) {\n      obfd[0x1f] = (char *)0x0;\n    }\n    break;\n  case 0x1a:\n    unsignedLongDataPointer = (undefined8 *)*doubleCharacterPointer;\n    if (obfd == (char **)0x0) goto LAB_00104b4f;\n    for (; unsignedLongDataPointer != (undefined8 *)0x0; unsignedLongDataPointer = (undefined8 *)unsignedLongDataPointer[1]) {\n      booleanData = false;\n      doubleCharacterPointer = obfd + 0x1f;\n      for (unsignedLongDataPointer = (undefined8 *)obfd[0x1f]; unsignedLongData = program_name, unsignedLongDataPointer != (undefined8 *)0x0;\n          unsignedLongDataPointer = (undefined8 *)unsignedLongDataPointer[0x1e]) {\n        integerData = filename_cmp(*unsignedLongDataPointer,*unsignedLongDataPointer);\n        if (integerData == 0) {\n          booleanData = true;\n          *doubleCharacterPointer = (char *)unsignedLongDataPointer[0x1e];\n        }\n        else {\n          doubleCharacterPointer = (char **)(unsignedLongDataPointer + 0x1e);\n        }\n      }\n      if (!booleanData) {\n        unsignedLongData = *unsignedLongDataPointer;\n        characterData = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,characterData,unsignedLongData,unsignedLongData);\n        maybequit();\n      }\n    }\n    break;\n  case 0x1b:\n    unsignedLongDataPointer = (undefined8 *)*doubleCharacterPointer;\n    if (obfd == (char **)0x0) goto LAB_00104b4f;\n    for (; unsignedLongDataPointer != (undefined8 *)0x0; unsignedLongDataPointer = (undefined8 *)unsignedLongDataPointer[1]) {\n      characterData = (char *)bfd_openr(*unsignedLongDataPointer,\"plugin\");\n      unsignedLongData = program_name;\n      doubleCharacterPointer = obfd;\n      if (characterData == (char *)0x0) {\n        unsignedLongData = *unsignedLongDataPointer;\n        characterData = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n        fprintf(_stderr,characterData,unsignedLongData,unsignedLongData);\n        maybequit();\n      }\n      else {\n        *(char **)(characterData + 0xf0) = obfd[0x1f];\n        doubleCharacterPointer[0x1f] = characterData;\n      }\n    }\n    break;\n  case 0x1c:\n    if (obfd == (char **)0x0) goto LAB_00104b4f;\n    characterData = *obfd;\n    verbose = 1;\n    outfile = _stdout;\n    characterData = (char *)dcgettext(0,\"Current open archive is %s\\n\",5);\n    printf(characterData,characterData);\n    for (characterData = obfd[0x1f]; characterData != (char *)0x0; characterData = *(char **)(characterData + 0xf0)) {\n      ar_directory_doer(characterData,0);\n    }\n    break;\n  case 0x1d:\n    if (obfd == (char **)0x0) goto LAB_00104b4f;\n    if (0 < deterministic) {\n      *(uint *)((long)obfd + 0x44) = *(uint *)((long)obfd + 0x44) | 0x2000;\n    }\n    temp_fd = dup(temp_fd);\n    bfd_close(doubleCharacterPointer);\n    characterData = real_name;\n    integerData = stat(real_name,&localStatData);\n    if ((integerData != 0) && (obfd = (char **)bfd_openw(characterData,0), obfd != (char **)0x0)) {\n      bfd_set_format(obfd,2);\n      bfd_close(obfd);\n    }\n    smart_rename_constprop_0(temp_name,real_name,temp_fd);\n    obfd = (char **)0x0;\n    free(temp_name);\n    free(real_name);\n    break;\n  case 0x1e:\n    ar_open(*doubleCharacterPointer,0);\n    break;\n  case 0x1f:\n    ar_open(*doubleCharacterPointer,1);\n    break;\n  case 0x20:\n    characterData = *doubleCharacterPointer;\n    if (obfd == (char **)0x0) {\n      characterData = \"%s: no output archive specified yet\\n\";\n      goto LAB_00104b62;\n    }\n    longData = open_inarch(doubleCharacterPointer[-1],0);\n    if (longData != 0) {\n      map_over_list(longData,ar_addlib_doer,characterData);\n    }\n    break;\n  case 0x21:\n    characterData = *doubleCharacterPointer;\n    characterData = doubleCharacterPointer[-1];\n    unsignedLongData = open_inarch(doubleCharacterPointer[-2],0);\n    if (characterData == (char *)0x0) {\n      outfile = _stdout;\n    }\n    else {\n      outfile = fopen(characterData,\"w\");\n      if (outfile != (FILE *)0x0) {\n        map_over_list(unsignedLongData,ar_directory_doer,characterData);\n        bfd_close(unsignedLongData);\n        fclose(outfile);\n        break;\n      }\n      outfile = _stdout;\n      characterData = (char *)dcgettext(0,\"Can\\'t open file %s\\n\",5);\n      fprintf(_stderr,characterData,characterData);\n    }\n    map_over_list(unsignedLongData,ar_directory_doer,characterData);\n    bfd_close(unsignedLongData);\n    break;\n  case 0x22:\n    ppcVar38 = (char **)*doubleCharacterPointer;\n    break;\n  case 0x23:\n  case 0x25:\n  case 0x27:\n    ppcVar38 = (char **)0x0;\n    break;\n  case 0x24:\n    ppcVar38 = (char **)doubleCharacterPointer[-1];\n    break;\n  case 0x26:\n    ppcVar38 = (char **)malloc(0x10);\n    characterData = doubleCharacterPointer[-2];\n    *ppcVar38 = *doubleCharacterPointer;\n    ppcVar38[1] = characterData;\n    break;\n  case 0x2a:\n    verbose = (uint)(verbose == 0);\n  }\n  longData = (long)character;\n  localCharacterPointer = localCharacterPointer + -longData;\n  doubleCharacterPointer[1 - longData] = (char *)ppcVar38;\n  doubleCharacterPointer = doubleCharacterPointer + (1 - longData);\n  unsignedIntegerData = (int)(char)yypgoto[(char)yyr1[integerData] + -0x18] + (int)*localCharacterPointer;\n  if ((unsignedIntegerData < 0x23) && (*localCharacterPointer == yycheck[(int)unsignedIntegerData])) {\n    longData = (long)(char)yytable[(int)unsignedIntegerData];\n  }\n  else {\n    longData = (long)(char)yydefgoto[(char)yyr1[integerData] + -0x18];\n  }\n  goto LAB_001049d1;\nswitchD_00104200_caseD_29:\n  integerData = ((int)bytePointer - (int)yytext) + -1;\n  *bytePointer = yy_hold_char;\n  doublePointerData = (long **)(yy_buffer_stack + longData * 8);\n  doubleFilePointer = (FILE **)*doublePointerData;\n  if (*(int *)(doubleFilePointer + 7) == 0) {\n    yy_n_chars = *(uint *)((long)doubleFilePointer + 0x1c);\n    *(undefined4 *)(doubleFilePointer + 7) = 1;\n    *doubleFilePointer = yyin;\n  }\n  bytePointer = yy_c_buf_p;\n  filePointer = doubleFilePointer[1];\n  auVar40._8_8_ = filePointer;\n  auVar40._0_8_ = doubleFilePointer;\n  if ((byte *)((long)&filePointer->_flags + (long)(int)yy_n_chars) < yy_c_buf_p) {\n    if ((byte *)((long)&filePointer->_flags + (long)(int)yy_n_chars + 1) < yy_c_buf_p) {\n      auVar40 = yy_fatal_error();\n    }\n    if (*(int *)(auVar40._0_8_ + 0x34) != 0) {\n      unsignedIntegerData = (int)((long)bytePointer - (long)bytePointer) - 1;\n      for (longData = 0; (int)longData < (int)unsignedIntegerData; longData = longData + 1) {\n        *(byte *)(auVar40._8_8_ + longData) = bytePointer[longData];\n      }\n      longDataPointer = *doublePointerData;\n      if (*(int *)(longDataPointer + 7) == 2) {\n        yy_n_chars = 0;\n        *(undefined4 *)((long)longDataPointer + 0x1c) = 0;\nLAB_0010475e:\n        filePointer = yyin;\n        if (unsignedIntegerData == 0) {\n          if ((yy_buffer_stack == 0) || (*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) == 0))\n          {\n            yyensure_buffer_stack();\n            unsignedLongDataPointer = (undefined8 *)(yy_buffer_stack + yy_buffer_stack_top * 8);\n            unsignedLongData = yy_create_buffer_constprop_0(filePointer);\n            *unsignedLongDataPointer = unsignedLongData;\n          }\n          longData = yy_buffer_stack;\n          if (yy_buffer_stack != 0) {\n            longData = *(long *)(yy_buffer_stack + yy_buffer_stack_top * 8);\n          }\n          integerData = 1;\n          yy_init_buffer(longData);\n          yy_load_buffer_state();\n        }\n        else {\n          integerData = 2;\n          *(undefined4 *)(*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) + 0x38) = 2;\n        }\n      }\n      else {\n        while( true ) {\n          longDataPointer = *doublePointerData;\n          unsignedIntegerData = ~unsignedIntegerData + *(int *)(longDataPointer + 3);\n          if (0 < (int)unsignedIntegerData) break;\n          unsignedIntegerData = (int)yy_c_buf_p - (int)(void *)longDataPointer[1];\n          if (*(int *)(longDataPointer + 4) == 0) {\n            longDataPointer[1] = 0;\nLAB_00104626:\n            yy_fatal_error();\n            break;\n          }\n          integerData = *(int *)(longDataPointer + 3);\n          integerData = integerData;\n          if (integerData < 1) {\n            integerData = integerData / 8;\n          }\n          *(int *)(longDataPointer + 3) = integerData + integerData;\n          voidPointer = realloc((void *)longDataPointer[1],(long)(integerData + integerData + 2));\n          longDataPointer[1] = (long)voidPointer;\n          if (voidPointer == (void *)0x0) goto LAB_00104626;\n          yy_c_buf_p = (byte *)((long)voidPointer + (long)(int)unsignedIntegerData);\n          longDataPointer = *doublePointerData;\n        }\n        if (0x2000 < (int)unsignedIntegerData) {\n          unsignedIntegerData = 0x2000;\n        }\n        unsignedLongData = (ulong)unsignedIntegerData;\n        if (*(int *)((long)longDataPointer + 0x24) == 0) {\n          integerPointer = __errno_location();\n          unsignedLongData = (ulong)(int)unsignedIntegerData;\n          unsignedLongData = (ulong)(int)unsignedIntegerData;\n          *integerPointer = 0;\n          goto LAB_001046c7;\n        }\n        unsignedLongData = 0;\n        integerPointer = (int *)(long)(int)unsignedIntegerData;\n        do {\n          integerData = getc(yyin);\n          unsignedIntegerData = (uint)unsignedLongData;\n          if (integerData == -1) {\n            integerData = ferror(yyin);\n            unsignedIntegerData = unsignedIntegerData;\n            if (integerData != 0) {\n              do {\n                characterData = \"input in flex scanner failed\";\n                yy_fatal_error();\n                do {\n                  *integerPointer = 0;\n                  clearerr((FILE *)characterData);\nLAB_001046c7:\n                  sizeData = fread((void *)(*(long *)(*(long *)(yy_buffer_stack +\n                                                             yy_buffer_stack_top * 8) + 8) + unsignedLongData)\n                                 ,1,unsignedLongData,yyin);\n                  characterData = (char *)yyin;\n                  yy_n_chars = (uint)sizeData;\n                  unsignedIntegerData = yy_n_chars;\n                  if ((yy_n_chars != 0) || (integerData = ferror(yyin), unsignedIntegerData = yy_n_chars, integerData == 0))\n                  goto LAB_00104738;\n                } while (*integerPointer == 4);\n              } while( true );\n            }\n            break;\n          }\n          if (integerData == 10) {\n            *(undefined *)\n             ((long)(int *)(long)(int)unsignedIntegerData +\n             (long)(int)unsignedIntegerData + *(long *)(*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) + 8)\n             ) = 10;\n            unsignedIntegerData = unsignedIntegerData + 1;\n            break;\n          }\n          unsignedLongData = (ulong)(unsignedIntegerData + 1);\n          *(char *)(*(long *)(*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) + 8) +\n                   (long)integerPointer) = (char)integerData;\n          integerPointer = (int *)((long)integerPointer + 1);\n        } while (unsignedIntegerData != unsignedIntegerData + 1);\nLAB_00104738:\n        yy_n_chars = unsignedIntegerData;\n        unsignedIntegerData = yy_n_chars;\n        integerData = 0;\n        *(uint *)(*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) + 0x1c) = yy_n_chars;\n        if (unsignedIntegerData == 0) goto LAB_0010475e;\n      }\n      longDataPointer = (long *)(yy_buffer_stack + yy_buffer_stack_top * 8);\n      longData = *longDataPointer;\n      unsignedIntegerData = unsignedIntegerData + yy_n_chars;\n      if (*(int *)(longData + 0x18) < (int)unsignedIntegerData) {\n        integerData = ((int)yy_n_chars >> 1) + unsignedIntegerData;\n        voidPointer = realloc(*(void **)(longData + 8),(long)integerData);\n        *(void **)(longData + 8) = voidPointer;\n        auVar41._8_8_ = longDataPointer;\n        auVar41._0_8_ = *longDataPointer;\n        if (*(long *)(*longDataPointer + 8) == 0) {\n          auVar41 = yy_fatal_error();\n        }\n        longDataPointer = auVar41._8_8_;\n        *(int *)(auVar41._0_8_ + 0x18) = integerData + -2;\n      }\n      yy_n_chars = unsignedIntegerData;\n      *(undefined *)(*(long *)(*longDataPointer + 8) + (long)(int)unsignedIntegerData) = 0;\n      *(undefined *)(*(long *)(*longDataPointer + 8) + 1 + (long)(int)unsignedIntegerData) = 0;\n      bytePointer = *(byte **)(*longDataPointer + 8);\n      yytext = bytePointer;\n      if (integerData == 1) goto LAB_001048a4;\n      if (integerData == 2) goto LAB_001048ca;\n      bytePointer = bytePointer + integerData;\n      yy_c_buf_p = bytePointer;\n      unsignedIntegerData = yy_get_previous_state();\n      goto LAB_001040d4;\n    }\n    if ((long)bytePointer - (long)bytePointer == 1) goto LAB_001048a4;\nLAB_001048ca:\n    bytePointer = (byte *)((long)(int)yy_n_chars +\n                      *(long *)(*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) + 8));\n    yy_c_buf_p = bytePointer;\n    unsignedLongData = yy_get_previous_state();\n    bytePointer = yytext;\n    goto LAB_0010419f;\n  }\n  bytePointer = bytePointer + integerData;\n  yy_c_buf_p = bytePointer;\n  unsignedLongData = yy_get_previous_state();\n  if (*(short *)(yy_accept + (long)(int)(uint)unsignedLongData * 2) != 0) {\n    yy_last_accepting_cpos = bytePointer;\n    yy_last_accepting_state = (uint)unsignedLongData;\n  }\n  unsignedLongData = unsignedLongData & 0xffffffff;\n  while( true ) {\n    integerData = (int)unsignedLongData;\n    if (integerData == *(short *)(yy_chk + (long)(*(short *)(yy_base + (long)integerData * 2) + 1) * 2)) break;\n    unsignedLongData = (ulong)(uint)(int)*(short *)(yy_def + (long)integerData * 2);\n  }\n  unsignedIntegerData = (uint)*(short *)(yy_nxt + (long)(*(short *)(yy_base + (long)integerData * 2) + 1) * 2);\n  bytePointer = bytePointer;\n  if ((*(short *)(yy_nxt + (long)(*(short *)(yy_base + (long)integerData * 2) + 1) * 2) == 0) ||\n     (unsignedIntegerData == 0xb0)) goto LAB_0010419f;\n  bytePointer = bytePointer + 1;\n  goto LAB_001040d4;\nLAB_001048a4:\n  yy_c_buf_p = yytext;\n  integerData = (int)(yy_start - 1) / 2 + 0x2a;\n  goto LAB_001041f0;\nswitchD_00104200_caseD_0:\n  *bytePointer = yy_hold_char;\n  unsignedLongData = (ulong)yy_last_accepting_state;\n  bytePointer = yy_last_accepting_cpos;\n  goto LAB_0010419f;\nLAB_00105227:\n  doubleCharacterPointer = doubleCharacterPointer + 1;\n  localIntegerData = 3;\n  *doubleCharacterPointer = yylval;\nLAB_001049d1:\n  localCharacterPointer = localCharacterPointer + 1;\n  goto LAB_00103ee9;\n}\n\n",
            "called": [
                "open_inarch",
                "prompt",
                "smart_rename.constprop.0",
                "fprintf",
                "ferror",
                "fread",
                "fclose",
                "clearerr",
                "maybequit",
                "dcgettext",
                "map_over_list",
                "yy_load_buffer_state",
                "ar_directory_doer",
                "fwrite",
                "stat",
                "ar_open",
                "filename_cmp",
                "__errno_location",
                "yyerror.constprop.0",
                "bfd_openw",
                "dup",
                "ar_addlib_doer",
                "yy_fatal_error",
                "printf",
                "fopen",
                "bfd_close",
                "unlink",
                "bfd_set_format",
                "yy_init_buffer",
                "bfd_cache_close",
                "yy_get_previous_state",
                "bfd_openr",
                "realloc",
                "yyensure_buffer_stack",
                "yy_create_buffer.constprop.0",
                "getc",
                "extract_file",
                "free",
                "malloc",
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103e95",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "convert_to_binary_00103e95"
        },
        "FUN_001020e0": {
            "renaming": {},
            "code": "\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fread(__ptr,__size,__n,__stream);\n  return sVar1;\n}\n\n",
            "called": [
                "fread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020e0",
            "calling": [
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_001020e0"
        },
        "FUN_0010e200": {
            "renaming": {},
            "code": "\n\n\n\nvoid * malloc(size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* malloc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e200",
            "calling": [
                "malloc"
            ],
            "imported": false,
            "current_name": "FUN_0010e200"
        },
        "FUN_00102280": {
            "renaming": {},
            "code": "\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102280",
            "calling": [
                "list_matching_formats",
                "list_supported_targets",
                "print_arelt_descr.cold"
            ],
            "imported": false,
            "current_name": "FUN_00102280"
        },
        "FUN_00107730": {
            "renaming": {
                "FUN_00107730": "cleanup_output_file_00107730",
                "output_filename": "filename",
                "output_file": "file",
                "unlink_if_ordinary": "deleteIfOrdinary"
            },
            "code": "\nvoid cleanupOutputFile_00107730(void)\n\n{\n  if (filename == 0) {\n    return;\n  }\n  if (output_bfd != 0) {\n    bfd_cache_close();\n  }\n  if (file != (FILE *)0x0) {\n    fclose(file);\n  }\n  deleteIfOrdinary(filename);\n  return;\n}\n\n",
            "called": [
                "remove_output.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107730",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "cleanup_output_file_00107730"
        },
        "FUN_00102040": {
            "renaming": {},
            "code": "\n\n\nint utimensat(int __fd,char *__path,timespec *__times,int __flags)\n\n{\n  int iVar1;\n  \n  iVar1 = utimensat(__fd,__path,__times,__flags);\n  return iVar1;\n}\n\n",
            "called": [
                "utimensat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102040",
            "calling": [
                "set_times"
            ],
            "imported": false,
            "current_name": "FUN_00102040"
        },
        "FUN_00102160": {
            "renaming": {},
            "code": "\nvoid bindtextdomain(void)\n\n{\n  bindtextdomain();\n  return;\n}\n\n",
            "called": [
                "bindtextdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102160",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102160"
        },
        "FUN_0010e2a8": {
            "renaming": {},
            "code": "\n\n\n\nint sprintf(char *__s,char *__format,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* sprintf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e2a8",
            "calling": [
                "sprintf"
            ],
            "imported": false,
            "current_name": "FUN_0010e2a8"
        },
        "FUN_001020f0": {
            "renaming": {},
            "code": "\nvoid bfd_set_archive_head(void)\n\n{\n  bfd_set_archive_head();\n  return;\n}\n\n",
            "called": [
                "bfd_set_archive_head"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020f0",
            "calling": [
                "write_archive.cold"
            ],
            "imported": false,
            "current_name": "FUN_001020f0"
        },
        "FUN_001031cf": {
            "renaming": {
                "FUN_001031cf": "initialize_file_001031cf",
                "param_1": "filePtr",
                "param_2": "inputFile",
                "param_3": "param1",
                "param_4": "param2",
                "param_5": "param3",
                "iVar1": "errorCode",
                "uVar2": "isTerminal",
                "iVar3": "fileDescriptor",
                "piVar4": "errnoPtr",
                "lVar5": "bufferStack"
            },
            "code": "\n\n\nundefined8\ninitializeFile_001031cf(FILE **filePtr,FILE *inputFile,undefined8 param1,undefined8 param2,undefined8 param3)\n\n{\n  int errorCode;\n  uint isTerminal;\n  int fileDescriptor;\n  int *errnoPtr;\n  long bufferStack;\n  \n  errnoPtr = __errno_location();\n  bufferStack = yy_buffer_stack;\n  errorCode = *errnoPtr;\n  if (filePtr == (FILE **)0x0) {\n    _DAT_00000034 = 1;\n    _DAT_00000000 = inputFile;\n    if (yy_buffer_stack != 0) {\nLAB_00103263:\n      if (filePtr == *(FILE ***)(bufferStack + yy_buffer_stack_top * 8)) goto LAB_0010327b;\n    }\n  }\n  else {\n    *(undefined4 *)((long)filePtr + 0x1c) = 0;\n    *(undefined *)&filePtr[1]->_flags = 0;\n    *(undefined *)((long)&filePtr[1]->_flags + 1) = 0;\n    *(undefined4 *)(filePtr + 5) = 1;\n    filePtr[2] = filePtr[1];\n    *(undefined4 *)(filePtr + 7) = 0;\n    if (bufferStack != 0) {\n      if (filePtr == *(FILE ***)(bufferStack + yy_buffer_stack_top * 8)) {\n        yy_load_buffer_state();\n      }\n      *filePtr = inputFile;\n      *(undefined4 *)((long)filePtr + 0x34) = 1;\n      goto LAB_00103263;\n    }\n    *filePtr = inputFile;\n    *(undefined4 *)((long)filePtr + 0x34) = 1;\n  }\n  *(undefined8 *)((long)filePtr + 0x2c) = 1;\nLAB_0010327b:\n  isTerminal = 0;\n  if (inputFile != (FILE *)0x0) {\n    fileDescriptor = fileno(inputFile);\n    fileDescriptor = isatty(fileDescriptor);\n    isTerminal = (uint)(0 < fileDescriptor);\n  }\n  *(uint *)((long)filePtr + 0x24) = isTerminal;\n  *errnoPtr = errorCode;\n  return param3;\n}\n\n",
            "called": [
                "yy_load_buffer_state",
                "__errno_location",
                "isatty",
                "fileno"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001031cf",
            "calling": [
                "yy_create_buffer.constprop.0",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "initialize_file_001031cf"
        },
        "FUN_0010312d": {
            "renaming": {
                "FUN_0010312d": "copy_memory_0010312d",
                "param_1": "destination",
                "param_2": "source",
                "lVar1": "tempVar"
            },
            "code": "\nvoid copyMemory_0010312d(long destination,long source)\n\n{\n  long tempVar;\n  \n  if (source != 0) {\n    *(undefined8 *)(source + 0xf0) = *(undefined8 *)(destination + 0xf0);\n  }\n  tempVar = obfd;\n  *(undefined8 *)(destination + 0xf0) = *(undefined8 *)(obfd + 0xf8);\n  *(long *)(tempVar + 0xf8) = destination;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010312d",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "copy_memory_0010312d"
        },
        "FUN_00105c00": {
            "renaming": {
                "FUN_00105c00": "copy_file_00105c00",
                "param_1": "source_file_descriptor",
                "param_2": "destination_file_path",
                "iVar1": "error_value",
                "__fd": "destination_file_descriptor",
                "iVar2": "read_result",
                "_Var3": "position",
                "uVar4": "write_result",
                "sVar5": "write_result_check",
                "piVar6": "error_ptr",
                "auStack_2038": "buffer"
            },
            "code": "\nulong copy_file_00105c00(int source_file_descriptor,char *destination_file_path)\n\n{\n  int error_value;\n  int destination_file_descriptor;\n  int read_result;\n  __off_t position;\n  ulong write_result;\n  size_t write_result_check;\n  int *error_ptr;\n  undefined buffer [8200];\n  \n  if ((-1 < source_file_descriptor) && (position = lseek(source_file_descriptor,0,0), position == 0)) {\n    destination_file_descriptor = open(destination_file_path,0x201);\n    if (destination_file_descriptor < 0) {\n      write_result = simple_copy_constprop_0_cold();\n      return write_result;\n    }\n    do {\n      write_result = read(source_file_descriptor,buffer,0x2000);\n      read_result = (int)write_result;\n      if (read_result < 1) {\n        error_ptr = __errno_location();\n        error_value = *error_ptr;\n        close(source_file_descriptor);\n        close(destination_file_descriptor);\n        if (read_result != 0) {\n          *error_ptr = error_value;\n          return 0xffffffff;\n        }\n        return write_result & 0xffffffff;\n      }\n      write_result_check = write(destination_file_descriptor,buffer,(long)read_result);\n    } while (write_result_check == (long)read_result);\n    error_ptr = __errno_location();\n    read_result = *error_ptr;\n    close(source_file_descriptor);\n    close(destination_file_descriptor);\n    *error_ptr = read_result;\n  }\n  return 0xffffffff;\n}\n\n",
            "called": [
                "close",
                "simple_copy.constprop.0.cold",
                "__errno_location",
                "write",
                "open",
                "read",
                "lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105c00",
            "calling": [
                "smart_rename.constprop.0"
            ],
            "imported": false,
            "current_name": "copy_file_00105c00"
        },
        "FUN_00105d20": {
            "renaming": {
                "FUN_00105d20": "FUNC_00105d20"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00105d44) */\n/* WARNING: Removing unreachable block (ram,0x00105d50) */\n\nvoid FUNC_00105d20(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_registerTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00105d20",
            "calling": [
                "frame_dummy"
            ],
            "imported": false,
            "current_name": "FUNC_00105d20"
        },
        "FUN_001052a0": {
            "renaming": {
                "FUN_001052a0": "check_file_001052a0",
                "param_1": "file_path",
                "iVar1": "status",
                "piVar2": "errno_ptr",
                "uVar3": "error_msg",
                "pcVar4": "error_reason",
                "sStack_a8": "file_info"
            },
            "code": "\nlong check_file_001052a0(char *file_path)\n\n{\n  int status;\n  int *errno_ptr;\n  undefined8 error_msg;\n  char *error_reason;\n  stat file_info;\n  \n  if (file_path != (char *)0x0) {\n    status = stat(file_path,&file_info);\n    if (status < 0) {\n      errno_ptr = __errno_location();\n      if (*errno_ptr == 2) {\n        error_msg = dcgettext(0,\"\\'%s\\': No such file\",5);\n        non_fatal(error_msg,file_path);\n      }\n      else {\n        error_reason = strerror(*errno_ptr);\n        error_msg = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n        non_fatal(error_msg,file_path,error_reason);\n      }\n    }\n    else if ((file_info.st_mode & 0xf000) == 0x4000) {\n      error_msg = dcgettext(0,\"Warning: \\'%s\\' is a directory\",5);\n      non_fatal(error_msg,file_path);\n    }\n    else if ((file_info.st_mode & 0xf000) == 0x8000) {\n      if (-1 < file_info.st_size) {\n        return file_info.st_size;\n      }\n      error_msg = dcgettext(0,\"Warning: \\'%s\\' has negative size, probably it is too large\",5);\n      non_fatal(error_msg,file_path);\n    }\n    else {\n      error_msg = dcgettext(0,\"Warning: \\'%s\\' is not an ordinary file\",5);\n      non_fatal(error_msg,file_path);\n    }\n  }\n  return -1;\n}\n\n",
            "called": [
                "stat",
                "get_file_size.cold",
                "dcgettext",
                "non_fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001052a0",
            "calling": [
                "ranlib_only",
                "main"
            ],
            "imported": false,
            "current_name": "check_file_001052a0"
        },
        "FUN_0010336b": {
            "renaming": {
                "FUN_0010336b": "print_emulation_options_0010336b",
                "param_1": "file",
                "pcVar1": "emulationText"
            },
            "code": "\nvoid printEmulationOptions_0010336b(FILE *file)\n\n{\n  char *emulationText;\n  \n  emulationText = (char *)dcgettext(0,\" emulation options: \\n\",5);\n  fprintf(file,emulationText);\n  emulationText = (char *)dcgettext(0,\"  No emulation specific options\\n\",5);\n  fprintf(file,emulationText);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010336b",
            "calling": [
                "usage"
            ],
            "imported": false,
            "current_name": "print_emulation_options_0010336b"
        },
        "FUN_00103c60": {
            "renaming": {
                "FUN_00103c60": "process_archive_file_00103c60",
                "param_1": "archiveFileName",
                "param_2": "isPlugin",
                "cVar1": "checkFormatResult",
                "piVar2": "errorNumberPtr",
                "pcVar3": "errorMessage",
                "lVar4": "inputArchive",
                "lVar5": "archivedFile",
                "uVar6": "programName",
                "plVar7": "currentFilePtr",
                "real_name": "duplicatedArchiveName",
                "temp_name": "temporaryArchiveName",
                "temp_fd": "temporaryFileDescriptor",
                "obfd": "outputBFD"
            },
            "code": "\n\n\nvoid processArchiveFile_00103c60(char *archiveFileName,int isPlugin)\n\n{\n  char checkFormatResult;\n  int *errorNumberPtr;\n  char *errorMessage;\n  long inputArchive;\n  long archivedFile;\n  undefined8 programName;\n  long *currentFilePtr;\n  \n  duplicatedArchiveName = xstrdup();\n  temporaryArchiveName = (char *)make_tempname(duplicatedArchiveName,&temporaryFileDescriptor);\n  if (temporaryArchiveName == (char *)0x0) {\n    errorNumberPtr = __errno_location();\n    archiveFileName = strerror(*errorNumberPtr);\n    programName = program_name;\n    errorMessage = (char *)dcgettext(0,\"%s: Can\\'t open temporary file (%s)\\n\",5);\n  }\n  else {\n    outputBFD = bfd_fdopenw(temporaryArchiveName,0,temporaryFileDescriptor);\n    if (outputBFD == 0) {\n      errorMessage = \"%s: Can\\'t open output archive %s\\n\";\n      archiveFileName = temporaryArchiveName;\n    }\n    else {\n      if (isPlugin != 0) {\nLAB_00103d02:\n        bfd_set_format(outputBFD,2);\n        *(byte *)(outputBFD + 0x49) = *(byte *)(outputBFD + 0x49) & 0xe7 | 8;\n        return;\n      }\n      inputArchive = bfd_openr(archiveFileName,\"plugin\");\n      if (inputArchive == 0) {\n        errorMessage = \"%s: Can\\'t open input archive %s\\n\";\n      }\n      else {\n        checkFormatResult = bfd_check_format(inputArchive,2);\n        if (checkFormatResult != '\\0') {\n          currentFilePtr = (long *)(outputBFD + 0xf8);\n          for (archivedFile = bfd_openr_next_archived_file(inputArchive,0); archivedFile != 0;\n              archivedFile = bfd_openr_next_archived_file(inputArchive,archivedFile)) {\n            *currentFilePtr = archivedFile;\n            currentFilePtr = (long *)(archivedFile + 0xf0);\n          }\n          goto LAB_00103d02;\n        }\n        errorMessage = \"%s: file %s is not an archive\\n\";\n      }\n    }\n    programName = program_name;\n    errorMessage = (char *)dcgettext(0,errorMessage,5);\n  }\n  fprintf(_stderr,errorMessage,programName,archiveFileName);\n  maybequit();\n  return;\n}\n\n",
            "called": [
                "make_tempname",
                "bfd_openr_next_archived_file",
                "__errno_location",
                "strerror",
                "fprintf",
                "bfd_check_format",
                "maybequit",
                "bfd_fdopenw",
                "bfd_openr",
                "dcgettext",
                "bfd_set_format",
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103c60",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "process_archive_file_00103c60"
        },
        "FUN_0010e218": {
            "renaming": {},
            "code": "\n\n\n\nint mkstemp(char *__template)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mkstemp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e218",
            "calling": [
                "mkstemp"
            ],
            "imported": false,
            "current_name": "FUN_0010e218"
        },
        "FUN_00102170": {
            "renaming": {},
            "code": "\nvoid dcgettext(void)\n\n{\n  dcgettext();\n  return;\n}\n\n",
            "called": [
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102170",
            "calling": [
                "open_inarch",
                "print_contents",
                "bfd_nonfatal.cold",
                "replace_members.cold",
                "list_supported_targets",
                "extract_file.cold",
                "ar_emul_default_usage",
                "get_file_size",
                "main",
                "FUN_00102e6f",
                "yyparse.isra.0",
                "map_over_list",
                "ar_open",
                "list_matching_formats",
                "write_archive",
                "set_times.cold",
                "yyerror.constprop.0",
                "get_file_size.cold",
                "map_over_members.cold",
                "print_arelt_descr.cold",
                "smart_rename.constprop.0.cold",
                "print_version",
                "ranlib_usage",
                "usage"
            ],
            "imported": false,
            "current_name": "FUN_00102170"
        },
        "FUN_00102290": {
            "renaming": {},
            "code": "\n\n\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = read(__fd,__buf,__nbytes);\n  return sVar1;\n}\n\n",
            "called": [
                "read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102290",
            "calling": [
                "simple_copy.constprop.0"
            ],
            "imported": false,
            "current_name": "FUN_00102290"
        },
        "FUN_0010300e": {
            "renaming": {
                "FUN_0010300e": "find_matching_pattern_0010300e",
                "bVar1": "pattern_found",
                "iVar2": "current_state",
                "lVar3": "pattern_location",
                "bVar4": "character_match",
                "pbVar5": "current_character",
                "in_R9": "last_accepting_character",
                "in_R10D": "last_accepting_state"
            },
            "code": "\nvoid find_matching_pattern_0010300e(void)\n\n{\n  bool pattern_found;\n  int current_state;\n  long pattern_location;\n  byte character_match;\n  byte *current_character;\n  byte *last_accepting_character;\n  int last_accepting_state;\n  \n  pattern_found = false;\n  current_state = yy_start;\n  for (current_character = yytext; current_character < yy_c_buf_p; current_character = current_character + 1) {\n    character_match = 1;\n    if (*current_character != 0) {\n      character_match = yy_ec[*current_character];\n    }\n    if (*(short *)(yy_accept + (long)current_state * 2) != 0) {\n      pattern_found = true;\n      last_accepting_character = current_character;\n      last_accepting_state = current_state;\n    }\n    while( true ) {\n      pattern_location = (long)(int)((int)*(short *)(yy_base + (long)current_state * 2) + (uint)character_match);\n      if (*(short *)(yy_chk + pattern_location * 2) == current_state) break;\n      current_state = (int)*(short *)(yy_def + (long)current_state * 2);\n      if (0xb0 < current_state) {\n        character_match = yy_meta[(int)(uint)character_match];\n      }\n    }\n    current_state = (int)*(short *)(yy_nxt + pattern_location * 2);\n  }\n  if (pattern_found) {\n    yy_last_accepting_cpos = last_accepting_character;\n    yy_last_accepting_state = last_accepting_state;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010300e",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "find_matching_pattern_0010300e"
        },
        "FUN_00107740": {
            "renaming": {
                "FUN_00107740": "extract_and_write_archive_00107740",
                "param_1": "archive",
                "iVar1": "comparisonResult",
                "iVar2": "internalStatError",
                "piVar3": "errnoPointer",
                "pcVar4": "errorMessage",
                "uVar5": "translationString",
                "pplVar6": "ptrToPtrByPtr",
                "__ptr": "buffer",
                "__n": "readSize",
                "lVar7": "loopCounter",
                "plVar8": "pointer",
                "puVar9": "preserveDatesArray",
                "uVar10": "bytesRead",
                "sVar11": "chunkSize",
                "local_c8": "preserveDatesLocal",
                "_Stack_b0": "filePermission",
                "uStack_98": "archiveSize",
                "uStack_80": "timestamp1",
                "uStack_70": "timestamp2",
                "output_file": "fileStream",
                "output_filename": "fileName"
            },
            "code": "\nlong * extractAndWriteArchive_00107740(long **archive)\n\n{\n  int comparisonResult;\n  int internalStatError;\n  int *errnoPointer;\n  char *errorMessage;\n  undefined8 translationString;\n  long **ptrToPtrByPtr;\n  void *buffer;\n  size_t readSize;\n  long loopCounter;\n  long *pointer;\n  undefined4 *preserveDatesArray;\n  ulong bytesRead;\n  size_t chunkSize;\n  undefined4 preserveDatesLocal [6];\n  __mode_t filePermission;\n  ulong archiveSize;\n  undefined8 timestamp1;\n  undefined8 timestamp2;\n  \n  if (preserve_dates != 0) {\n    preserveDatesArray = preserveDatesLocal;\n    for (loopCounter = 0x24; loopCounter != 0; loopCounter = loopCounter + -1) {\n      *preserveDatesArray = 0;\n      preserveDatesArray = preserveDatesArray + 1;\n    }\n  }\n  ptrToPtrByPtr = (long **)archive[0x1d];\n  if ((long **)archive[0x1d] == (long **)0x0) {\n    ptrToPtrByPtr = archive;\n  }\n  internalStatError = (*(code *)ptrToPtrByPtr[1][0x3d])(archive,preserveDatesLocal);\n  if (internalStatError != 0) {\n    pointer = *archive;\n    translationString = dcgettext(0,\"internal stat error on %s\",5);\n    internalStatError = fatal(translationString,pointer);\n    translationString = posname;\n    if (internalStatError == 3) {\n      for (; *pointer != 0; pointer = (long *)(*pointer + 0xf0)) {\n      }\n    }\n    else {\n      for (; (undefined8 *)*pointer != (undefined8 *)0x0; pointer = (long *)(*pointer + 0xf0)) {\n        comparisonResult = filename_cmp(*(undefined8 *)*pointer,translationString);\n        if (comparisonResult == 0) {\n          if (internalStatError != 2) {\n            return pointer;\n          }\n          return (long *)(*pointer + 0xf0);\n        }\n      }\n    }\n    return pointer;\n  }\n  bfd_seek(archive,0,0);\n  fileStream = (FILE *)0x0;\n  if (archiveSize == 0) {\nLAB_00102ca2:\n    fileStream = (FILE *)open_fileStream_isra_0(*archive);\n  }\n  else {\n    bytesRead = 0;\n    buffer = (void *)xmalloc(0x2000);\n    do {\n      chunkSize = archiveSize - bytesRead;\n      if (0x2000 < chunkSize) {\n        chunkSize = 0x2000;\n      }\n      readSize = bfd_bread(buffer,chunkSize,archive);\n      if (chunkSize != readSize) {\nLAB_00102c78:\n        archive = (long **)*archive[0x1d];\n        translationString = dcgettext(0,\"%s is not a valid archive\",5);\n        fatal(translationString,archive);\n        goto LAB_00102ca2;\n      }\n      if (fileStream == (FILE *)0x0) {\n        fileStream = (FILE *)open_fileStream_isra_0(*archive);\n      }\n      chunkSize = fwrite(buffer,1,readSize,fileStream);\n      if (chunkSize != readSize) {\n        errnoPointer = __errno_location();\n        errorMessage = strerror(*errnoPointer);\n        fatal(\"%s: %s\",fileName,errorMessage);\n        goto LAB_00102c78;\n      }\n      bytesRead = bytesRead + readSize;\n    } while (bytesRead < archiveSize);\n    free(buffer);\n  }\n  fclose(fileStream);\n  errorMessage = fileName;\n  fileStream = (FILE *)0x0;\n  chmod(fileName,filePermission);\n  if (preserve_dates != 0) {\n    timestamp1 = timestamp2;\n    set_times(errorMessage,preserveDatesLocal);\n  }\n  fileName = (char *)0x0;\n  return (long *)0x0;\n}\n\n",
            "called": [
                "extract_file.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107740",
            "calling": [
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "extract_and_write_archive_00107740"
        },
        "FUN_00102050": {
            "renaming": {},
            "code": "\nvoid bfd_cache_close(void)\n\n{\n  bfd_cache_close();\n  return;\n}\n\n",
            "called": [
                "bfd_cache_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102050",
            "calling": [
                "remove_output.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102050"
        },
        "FUN_0010e2b8": {
            "renaming": {},
            "code": "\n\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fwrite@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e2b8",
            "calling": [
                "fwrite"
            ],
            "imported": false,
            "current_name": "FUN_0010e2b8"
        },
        "FUN_001028ed": {
            "renaming": {
                "FUN_001028ed": "process_archive_001028ed",
                "param_1": "param1",
                "param_2": "param2",
                "uVar1": "result",
                "bVar2": "flag",
                "iVar3": "cmpResult",
                "sVar4": "length",
                "piVar5": "errnoPtr",
                "pcVar6": "currentPath",
                "pcVar7": "basename1",
                "ppcVar8": "pointerToPointer",
                "uVar9": "normalizedPath",
                "lVar10": "tempPointer",
                "__s": "tempString1",
                "__s_00": "tempString2",
                "lVar11": "currentParentPointer",
                "uVar12": "posname",
                "uVar13": "tempLength",
                "unaff_RBX": "basePointer",
                "ppcVar14": "currentEntry",
                "unaff_RBP": "parameterPointer",
                "unaff_R12": "tempPointer",
                "unaff_R13D": "comparisonFlag",
                "ppcVar15": "tempEntry",
                "unaff_R14": "parentPointer",
                "bVar16": "verboseFlag",
                "bVar17": "tempByte",
                "param_7": "param7",
                "param_9": "resultFlag",
                "in_stack_00000078": "localVar1",
                "in_stack_00000108": "localVar2"
            },
            "code": "\nundefined8 processArchive_001028ed(undefined8 param1,long param2)\n\n{\n  undefined result;\n  byte flag;\n  int cmpResult;\n  size_t length;\n  int *errnoPtr;\n  char *currentPath;\n  char *basename1;\n  char **pointerToPointer;\n  undefined8 normalizedPath;\n  long tempPointer;\n  char *tempString1;\n  char *tempString2;\n  long currentParentPointer;\n  undefined8 posname;\n  ulong tempLength;\n  char *basePointer;\n  char **currentEntry;\n  char **parameterPointer;\n  char **tempPointer;\n  uint comparisonFlag;\n  char **tempEntry;\n  long parentPointer;\n  bool verboseFlag;\n  byte tempByte;\n  char **param7;\n  undefined8 resultFlag;\n  long localVar1;\n  long localVar2;\n  \n  tempByte = 0;\ncode_r0x001028ed:\n  bfd_fatal(basePointer,param2);\nLAB_001028f5:\n  posname = posname;\n  if (comparisonFlag != 3) {\n    while( true ) {\n      if ((undefined8 *)*tempPointer == (undefined8 *)0x0) goto LAB_0010571f;\n      cmpResult = filename_cmp(*(undefined8 *)*tempPointer,posname);\n      if (cmpResult == 0) break;\n      tempPointer = (char **)(*tempPointer + 0xf0);\n    }\n    if (comparisonFlag != 2) goto LAB_0010571f;\n    tempPointer = (char **)(*tempPointer + 0xf0);\n    goto LAB_0010571f;\n  }\n  tempPointer = *(long *)(parentPointer + 0xf0);\n  if (*(long *)(parentPointer + 0xf0) == 0) goto LAB_0010571f;\nLAB_00105670:\n  do {\n    currentParentPointer = tempPointer;\n    tempPointer = *(long *)(currentParentPointer + 0xf0);\n  } while (tempPointer != 0);\n  tempPointer = (char **)(currentParentPointer + 0xf0);\n  basePointer = *parameterPointer;\n  if (libdeps_bfd != 0) goto LAB_00105731;\nLAB_00105698:\n  result = make_thin_archive;\n  comparisonFlag = (uint)(verbose != 0);\n  param2 = bfd_openr(basePointer,target);\n  if (param2 != 0) {\n    parameterPointer = parameterPointer + 1;\n    flag = do_ar_emul_append_constprop_0(tempPointer,param2,comparisonFlag,result);\n    resultFlag._6_1_ = resultFlag._6_1_ | flag;\n    currentPath = *parameterPointer;\n    do {\n      if (currentPath == (char *)0x0) {\n        if (resultFlag._6_1_ == 0) {\n          output_filename = 0;\n          return 0;\n        }\n        posname = write_archive();\n        return posname;\n      }\n      currentEntry = *(char ***)(parentPointer + 0xf0);\n      tempPointer = param7;\n      if (resultFlag._7_1_ == '\\0') {\n        tempEntry = param7;\n        if (currentEntry != (char **)0x0) {\n          do {\n            if (full_pathname == '\\0') {\n              tempString1 = (char *)lbasename(*currentEntry);\n              basename1 = tempString1;\n              if (ar_truncate != '\\0') {\n                length = strlen(tempString1);\n                tempLength = (ulong)*(byte *)(*(long *)(parentPointer + 8) + 0x1e);\n                if (tempLength < length) {\n                  basename1 = (char *)xmalloc(tempLength + 1);\n                  tempPointer = *(long *)(parentPointer + 8);\n                  currentPath = basename1;\n                  for (tempLength = (ulong)*(byte *)(tempPointer + 0x1e); tempLength != 0; tempLength = tempLength - 1) {\n                    *currentPath = *tempString1;\n                    tempString1 = tempString1 + (ulong)tempByte * -2 + 1;\n                    currentPath = currentPath + (ulong)tempByte * -2 + 1;\n                  }\n                  basename1[*(byte *)(tempPointer + 0x1e)] = '\\0';\n                }\n                currentPath = *parameterPointer;\n                tempString1 = basename1;\n                if (full_pathname == '\\0') goto LAB_00105611;\n                goto LAB_00102980;\n              }\n              currentPath = *parameterPointer;\n              if (full_pathname != '\\0') goto LAB_00102980;\nLAB_00105611:\n              tempString2 = (char *)lbasename(currentPath);\n              if (ar_truncate != '\\0') {\n                length = strlen(tempString2);\n                tempLength = (ulong)*(byte *)(*(long *)(parentPointer + 8) + 0x1e);\n                currentPath = tempString2;\n                tempString1 = basename1;\n                if (tempLength < length) {\n                  currentPath = (char *)xmalloc(tempLength + 1);\n                  tempPointer = *(long *)(parentPointer + 8);\n                  basename1 = currentPath;\n                  for (tempLength = (ulong)*(byte *)(tempPointer + 0x1e); tempLength != 0; tempLength = tempLength - 1) {\n                    *basename1 = *tempString2;\n                    tempString2 = tempString2 + (ulong)tempByte * -2 + 1;\n                    basename1 = basename1 + (ulong)tempByte * -2 + 1;\n                  }\n                  currentPath[*(byte *)(tempPointer + 0x1e)] = '\\0';\n                }\n                goto LAB_00102980;\n              }\n              cmpResult = filename_cmp(tempString2,basename1);\n            }\n            else {\n              currentPath = *parameterPointer;\n              tempString1 = *currentEntry;\nLAB_00102980:\n              cmpResult = filename_cmp(currentPath,tempString1);\n            }\n            if ((cmpResult == 0) && (currentEntry[0x1c] != (char *)0x0)) {\n              if (newer_only != 0) {\n                cmpResult = stat(*parameterPointer,(stat *)&stack0x000000b0);\n                if (cmpResult != 0) {\n                  errnoPtr = __errno_location();\n                  if (*errnoPtr != 2) {\n                    bfd_fatal(*parameterPointer);\nLAB_00102b7e:\n                    currentPath = *currentEntry;\n                    posname = dcgettext(0,\"internal stat error on %s\",5);\n                    fatal(posname,currentPath);\n                    free(parameterPointer);\n                    return 0;\n                  }\n                  goto LAB_0010577e;\n                }\n                pointerToPointer = (char **)currentEntry[0x1d];\n                if ((char **)currentEntry[0x1d] == (char **)0x0) {\n                  pointerToPointer = currentEntry;\n                }\n                cmpResult = (**(code **)(pointerToPointer[1] + 0x1e8))(currentEntry,&stack0x00000020);\n                if (cmpResult != 0) goto LAB_00102b7e;\n                if (localVar2 <= localVar1) goto LAB_0010577e;\n              }\n              posname = get_pos_bfd(param7,2,*currentEntry);\n              if (libdeps_bfd == 0) {\nLAB_00102ae2:\n                currentPath = *parameterPointer;\n                verboseFlag = verbose != 0;\n                tempPointer = bfd_openr(currentPath,target);\n                if (tempPointer == 0) {\n                  bfd_fatal(currentPath,0);\n                  goto LAB_00102b3e;\n                }\n                flag = ar_emul_default_replace(posname,tempPointer,verboseFlag);\n              }\n              else {\n                normalizedPath = normalize(*parameterPointer);\n                cmpResult = filename_cmp(normalizedPath,\"__.LIBDEP\");\n                if (cmpResult != 0) goto LAB_00102ae2;\nLAB_00102b3e:\n                flag = ar_emul_default_replace(posname,libdeps_bfd,verbose != 0);\n              }\n              if (flag != 0) {\n                *tempEntry = *(char **)(*tempEntry + 0xf0);\n                resultFlag._6_1_ = flag;\n              }\n              goto LAB_0010577e;\n            }\n            tempEntry = currentEntry + 0x1e;\n            currentEntry = (char **)currentEntry[0x1e];\n          } while (currentEntry != (char **)0x0);\n          goto LAB_0010564c;\n        }\n        comparisonFlag = postype;\n        if (postype != 0) goto LAB_001028f5;\n      }\n      else {\nLAB_0010564c:\n        comparisonFlag = postype;\n        if (postype != 0) goto LAB_001028f5;\n        tempPointer = *(long *)(parentPointer + 0xf0);\n        if (*(long *)(parentPointer + 0xf0) != 0) goto LAB_00105670;\n      }\nLAB_0010571f:\n      basePointer = *parameterPointer;\n      if (libdeps_bfd == 0) goto LAB_00105698;\nLAB_00105731:\n      posname = normalize(basePointer);\n      cmpResult = filename_cmp(posname,\"__.LIBDEP\");\n      if (cmpResult != 0) goto code_r0x0010574f;\n      flag = ar_emul_default_append(tempPointer,libdeps_bfd,verbose != 0,make_thin_archive);\n      resultFlag._6_1_ = flag | resultFlag._6_1_;\nLAB_0010577e:\n      parameterPointer = parameterPointer + 1;\n      currentPath = *parameterPointer;\n    } while( true );\n  }\n  goto code_r0x001028ed;\ncode_r0x0010574f:\n  basePointer = *parameterPointer;\n  goto LAB_00105698;\n}\n\n",
            "called": [
                "do_ar_emul_append.constprop.0",
                "bfd_fatal",
                "replace_members.cold",
                "bfd_openr",
                "dcgettext",
                "ar_emul_default_replace",
                "ar_emul_default_append",
                "xmalloc",
                "fatal",
                "stat",
                "strlen",
                "filename_cmp",
                "get_pos_bfd",
                "__errno_location",
                "write_archive",
                "normalize",
                "FUN_00102943",
                "lbasename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001028ed",
            "calling": [
                "replace_members.cold"
            ],
            "imported": false,
            "current_name": "process_archive_001028ed"
        },
        "FUN_0010e1b0": {
            "renaming": {},
            "code": "\n\n\n\nlong ftell(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ftell@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1b0",
            "calling": [
                "ftell"
            ],
            "imported": false,
            "current_name": "FUN_0010e1b0"
        },
        "FUN_0010e228": {
            "renaming": {},
            "code": "\n\n\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* realloc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e228",
            "calling": [
                "realloc"
            ],
            "imported": false,
            "current_name": "FUN_0010e228"
        },
        "FUN_0010e108": {
            "renaming": {},
            "code": "\n\n\n\nint fputs(char *__s,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fputs@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e108",
            "calling": [
                "fputs"
            ],
            "imported": false,
            "current_name": "FUN_0010e108"
        },
        "FUN_00102060": {
            "renaming": {},
            "code": "\n\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = __errno_location();\n  return piVar1;\n}\n\n",
            "called": [
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102060",
            "calling": [
                "yy_init_buffer",
                "open_inarch",
                "simple_copy.constprop.0.cold",
                "ar_open",
                "print_contents",
                "set_times.cold",
                "get_file_size.cold",
                "replace_members.cold",
                "simple_copy.constprop.0",
                "smart_rename.constprop.0.cold",
                "extract_file.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102060"
        },
        "FUN_00102180": {
            "renaming": {},
            "code": "\n\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(__s);\n  return sVar1;\n}\n\n",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102180",
            "calling": [
                "normalize.cold",
                "FUN_00105a68",
                "replace_members.cold",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102180"
        },
        "FUN_001025a0": {
            "renaming": {
                "FUN_001025a0": "handle_file_error_001025a0",
                "piVar1": "errnoPtr",
                "uVar2": "errorMessage"
            },
            "code": "\nundefined8 handleFileError_001025a0(void)\n\n{\n  int *errnoPtr;\n  undefined8 errorMessage;\n  \n  errnoPtr = __errno_location();\n  if (*errnoPtr == 2) {\n    errorMessage = dcgettext(0,\"\\'%s\\': No such file\",5);\n    non_fatal(errorMessage);\n  }\n  else {\n    strerror(*errnoPtr);\n    errorMessage = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n    non_fatal(errorMessage);\n  }\n  return 0xffffffffffffffff;\n}\n\n",
            "called": [
                "__errno_location",
                "strerror",
                "dcgettext",
                "non_fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001025a0",
            "calling": [
                "get_file_size"
            ],
            "imported": false,
            "current_name": "handle_file_error_001025a0"
        },
        "FUN_0010284b": {
            "renaming": {
                "FUN_0010284b": "get_one_0010284b",
                "undefined8": "uint64_t"
            },
            "code": "\nuint64_t getOne_0010284b(void)\n\n{\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010284b",
            "calling": [
                "ranlib_only"
            ],
            "imported": false,
            "current_name": "get_one_0010284b"
        },
        "FUN_0010e220": {
            "renaming": {},
            "code": "\n\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fseek@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e220",
            "calling": [
                "fseek"
            ],
            "imported": false,
            "current_name": "FUN_0010e220"
        },
        "FUN_0010e100": {
            "renaming": {},
            "code": "\n\n\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* lseek@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e100",
            "calling": [
                "lseek"
            ],
            "imported": false,
            "current_name": "FUN_0010e100"
        },
        "FUN_00105cc0": {
            "renaming": {
                "FUN_00105cc0": "start_main_process_00105cc0",
                "param_1": "entryPoint",
                "param_2": "paramPointer",
                "auStack_8": "stackArray"
            },
            "code": "\nvoid processEntry startMainProcess_00105cc0(undefined8 entryPoint,undefined8 paramPointer)\n\n{\n  undefined stackArray [8];\n  \n  __libc_start_main(main,paramPointer,&stack0x00000008,0,0,entryPoint,stackArray);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "__libc_start_main",
                "main"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105cc0",
            "calling": [],
            "imported": false,
            "current_name": "start_main_process_00105cc0"
        },
        "FUN_00102f08": {
            "renaming": {
                "FUN_00102f08": "print_and_swap_00102f08",
                "unaff_RBX": "printString",
                "unaff_R12": "targetString"
            },
            "code": "\nundefined8 printAndSwap_00102f08(void)\n\n{\n  undefined8 *printString;\n  undefined8 *targetString;\n  \n  printf(\"a - %s\\n\",*printString);\n  printString[0x1e] = *targetString;\n  *targetString = printString;\n  return 1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f08",
            "calling": [
                "do_ar_emul_append.constprop.0"
            ],
            "imported": false,
            "current_name": "print_and_swap_00102f08"
        },
        "FUN_00105570": {
            "renaming": {
                "FUN_00105570": "process_files_00105570",
                "param_1": "arg1",
                "param_2": "filenames",
                "param_3": "flag",
                "ppcVar1": "currentFile",
                "uVar2": "undefinedVar",
                "bVar3": "byteVar",
                "iVar4": "intVar",
                "sVar5": "sizeVar",
                "piVar6": "errorVar",
                "pcVar7": "fileVar1",
                "pcVar8": "fileVar2",
                "uVar9": "undefinedVar2",
                "pcVar10": "currentFilename",
                "__s": "basenameVar",
                "lVar11": "loopVar1",
                "lVar12": "loopVar2",
                "uVar13": "result",
                "uVar14": "ulongVar",
                "ppcVar15": "fileList",
                "ppcVar16": "currentFileList",
                "uVar17": "uintVar",
                "ppcVar18": "previousFileList",
                "bVar19": "boolVar",
                "bVar20": "byteVar2",
                "local_15a": "localVar",
                "auStack_158": "stackVar",
                "lStack_100": "lStackVar",
                "sStack_c8": "sStackVar",
                "output_filename": "outputFilename",
                "initialize_output_filename_00102943": "initializeOutputFilename",
                "write_archive": "writeArchive",
                "ar_emul_default_append": "append",
                "libdeps_bfd": "libdepsBfd",
                "filename_cmp": "compareFilenames",
                "make_thin_archive": "makeThinArchive",
                "bfd_openr": "openBfd",
                "do_ar_emul_append_constprop_0": "appendConstprop",
                "bfd_fatal": "fatal",
                "posname": "positionName",
                "postype": "positionType",
                "get_pos_bfd": "getPositionBfd",
                "ar_emul_default_replace": "replace",
                "dcgettext": "getLocaleString",
                "fatal": "fatalError",
                "free": "freeMemory"
            },
            "code": "\nundefined8 processFiles_00105570(long arg1,char **filenames,char flag)\n\n{\n  char **currentFile;\n  undefined undefinedVar;\n  byte byteVar;\n  int intVar;\n  size_t sizeVar;\n  int *errorVar;\n  char *fileVar1;\n  char *fileVar2;\n  undefined8 undefinedVar2;\n  char *currentFilename;\n  char *basenameVar;\n  long loopVar1;\n  long loopVar2;\n  undefined8 result;\n  ulong ulongVar;\n  char **fileList;\n  char **currentFileList;\n  uint uintVar;\n  char **previousFileList;\n  bool boolVar;\n  byte byteVar2;\n  byte localVar;\n  undefined stackVar [88];\n  long lStackVar;\n  stat sStackVar;\n  \n  byteVar2 = 0;\n  currentFile = (char **)(arg1 + 0xf0);\n  localVar = 0;\n  if (filenames == (char **)0x0) {\n    result = initializeOutputFilename();\n    return result;\n  }\n  do {\n    currentFilename = *filenames;\njoined_r0x001055aa:\n    if (currentFilename == (char *)0x0) {\n      if (localVar != 0) {\n        result = writeArchive(arg1);\n        return result;\n      }\n      outputFilename = 0;\n      return 0;\n    }\n    fileList = *(char ***)(arg1 + 0xf0);\n    currentFileList = currentFile;\n    if (flag != '\\0') {\nLAB_0010564c:\n      uintVar = positionType;\n      if (positionType != 0) goto LAB_001028f5;\n      loopVar2 = *(long *)(arg1 + 0xf0);\n      if (*(long *)(arg1 + 0xf0) == 0) goto LAB_0010571f;\nLAB_00105670:\n      do {\n        loopVar1 = loopVar2;\n        loopVar2 = *(long *)(loopVar1 + 0xf0);\n      } while (loopVar2 != 0);\n      currentFileList = (char **)(loopVar1 + 0xf0);\n      currentFilename = *filenames;\n      do {\n        if (libdepsBfd != 0) {\n          result = normalize(currentFilename,arg1);\n          intVar = compareFilenames(result,\"__.LIBDEP\");\n          if (intVar == 0) {\n            byteVar = append(currentFileList,libdepsBfd,verbose != 0,makeThinArchive);\n            localVar = byteVar | localVar;\n            goto LAB_0010577e;\n          }\n          currentFilename = *filenames;\n        }\n        undefinedVar = makeThinArchive;\n        boolVar = verbose != 0;\n        loopVar2 = openBfd(currentFilename,target);\n        if (loopVar2 != 0) {\n          filenames = filenames + 1;\n          byteVar = appendConstprop(currentFileList,loopVar2,(uint)boolVar,undefinedVar);\n          localVar = localVar | byteVar;\n          currentFilename = *filenames;\n          goto joined_r0x001055aa;\n        }\n        fatal(currentFilename,0);\n        uintVar = (uint)boolVar;\nLAB_001028f5:\n        result = positionName;\n        if (uintVar == 3) {\n          loopVar2 = *(long *)(arg1 + 0xf0);\n          if (*(long *)(arg1 + 0xf0) != 0) goto LAB_00105670;\n        }\n        else {\n          for (; (undefined8 *)*currentFileList != (undefined8 *)0x0;\n              currentFileList = (char **)(*currentFileList + 0xf0)) {\n            intVar = compareFilenames(*(undefined8 *)*currentFileList,result);\n            if (intVar == 0) {\n              if (uintVar == 2) {\n                currentFileList = (char **)(*currentFileList + 0xf0);\n              }\n              break;\n            }\n          }\n        }\nLAB_0010571f:\n        currentFilename = *filenames;\n      } while( true );\n    }\n    previousFileList = currentFile;\n    if (fileList == (char **)0x0) {\n      uintVar = positionType;\n      if (positionType == 0) goto LAB_0010571f;\n      goto LAB_001028f5;\n    }\nLAB_001055d8:\n    if (full_pathname == '\\0') {\n      currentFilename = (char *)lbasename(*fileList);\n      fileVar2 = currentFilename;\n      if (ar_truncate != '\\0') {\n        sizeVar = strlen(currentFilename);\n        ulongVar = (ulong)*(byte *)(*(long *)(arg1 + 8) + 0x1e);\n        if (ulongVar < sizeVar) {\n          fileVar2 = (char *)xmalloc(ulongVar + 1);\n          loopVar2 = *(long *)(arg1 + 8);\n          fileVar1 = fileVar2;\n          for (ulongVar = (ulong)*(byte *)(loopVar2 + 0x1e); ulongVar != 0; ulongVar = ulongVar - 1) {\n            *fileVar1 = *currentFilename;\n            currentFilename = currentFilename + (ulong)byteVar2 * -2 + 1;\n            fileVar1 = fileVar1 + (ulong)byteVar2 * -2 + 1;\n          }\n          fileVar2[*(byte *)(loopVar2 + 0x1e)] = '\\0';\n        }\n        fileVar1 = *filenames;\n        currentFilename = fileVar2;\n        if (full_pathname == '\\0') goto LAB_00105611;\n        goto LAB_00102980;\n      }\n      fileVar1 = *filenames;\n      if (full_pathname != '\\0') goto LAB_00102980;\nLAB_00105611:\n      basenameVar = (char *)lbasename(fileVar1);\n      if (ar_truncate != '\\0') {\n        sizeVar = strlen(basenameVar);\n        ulongVar = (ulong)*(byte *)(*(long *)(arg1 + 8) + 0x1e);\n        fileVar1 = basenameVar;\n        currentFilename = fileVar2;\n        if (ulongVar < sizeVar) {\n          fileVar1 = (char *)xmalloc(ulongVar + 1);\n          loopVar2 = *(long *)(arg1 + 8);\n          fileVar2 = fileVar1;\n          for (ulongVar = (ulong)*(byte *)(loopVar2 + 0x1e); ulongVar != 0; ulongVar = ulongVar - 1) {\n            *fileVar2 = *basenameVar;\n            basenameVar = basenameVar + (ulong)byteVar2 * -2 + 1;\n            fileVar2 = fileVar2 + (ulong)byteVar2 * -2 + 1;\n          }\n          fileVar1[*(byte *)(loopVar2 + 0x1e)] = '\\0';\n        }\n        goto LAB_00102980;\n      }\n      intVar = compareFilenames(basenameVar,fileVar2);\n      if (intVar == 0) goto LAB_00102993;\nLAB_00105639:\n      previousFileList = fileList + 0x1e;\n      fileList = (char **)fileList[0x1e];\n      if (fileList == (char **)0x0) goto LAB_0010564c;\n      goto LAB_001055d8;\n    }\n    fileVar1 = *filenames;\n    currentFilename = *fileList;\nLAB_00102980:\n    intVar = compareFilenames(fileVar1,currentFilename);\n    if (intVar != 0) goto LAB_00105639;\nLAB_00102993:\n    if (fileList[0x1c] == (char *)0x0) goto LAB_00105639;\n    if (newer_only != 0) {\n      intVar = stat(*filenames,&sStackVar);\n      if (intVar != 0) {\n        errorVar = __errno_location();\n        if (*errorVar != 2) {\n          fatal(*filenames);\nLAB_00102b7e:\n          currentFilename = *fileList;\n          result = getLocaleString(0,\"internal stat error on %s\",5);\n          fatalError(result,currentFilename);\n          freeMemory(filenames);\n          return 0;\n        }\n        goto LAB_0010577e;\n      }\n      currentFileList = (char **)fileList[0x1d];\n      if ((char **)fileList[0x1d] == (char **)0x0) {\n        currentFileList = fileList;\n      }\n      intVar = (**(code **)(currentFileList[1] + 0x1e8))(fileList,stackVar);\n      if (intVar != 0) goto LAB_00102b7e;\n      if (sStackVar.st_mtim.tv_sec <= lStackVar) goto LAB_0010577e;\n    }\n    result = getPositionBfd(currentFile,2,*fileList);\n    if (libdepsBfd == 0) {\nLAB_00102ae2:\n      currentFilename = *filenames;\n      boolVar = verbose != 0;\n      loopVar2 = openBfd(currentFilename,target);\n      if (loopVar2 == 0) {\n        fatal(currentFilename,0);\n        goto LAB_00102b3e;\n      }\n      byteVar = replace(result,loopVar2,boolVar);\n    }\n    else {\n      undefinedVar2 = normalize(*filenames,arg1);\n      intVar = compareFilenames(undefinedVar2,\"__.LIBDEP\");\n      if (intVar != 0) goto LAB_00102ae2;\nLAB_00102b3e:\n      byteVar = replace(result,libdepsBfd,verbose != 0);\n    }\n    if (byteVar != 0) {\n      *previousFileList = *(char **)(*previousFileList + 0xf0);\n      localVar = byteVar;\n    }\nLAB_0010577e:\n    filenames = filenames + 1;\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00102943"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105570",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "process_files_00105570"
        },
        "FUN_0010e1a8": {
            "renaming": {},
            "code": "\n\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fprintf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1a8",
            "calling": [
                "fprintf"
            ],
            "imported": false,
            "current_name": "FUN_0010e1a8"
        },
        "FUN_0010e2e8": {
            "renaming": {},
            "code": "\n\n\n\nint getc(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e2e8",
            "calling": [
                "getc"
            ],
            "imported": false,
            "current_name": "FUN_0010e2e8"
        },
        "FUN_0010e1c0": {
            "renaming": {},
            "code": "\n\n\n\nint stat(char *__file,stat *__buf)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* stat@GLIBC_2.33 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1c0",
            "calling": [
                "stat"
            ],
            "imported": false,
            "current_name": "FUN_0010e1c0"
        },
        "FUN_00102500": {
            "renaming": {},
            "code": "\n\n\nvoid exit(int __status)\n\n{\n                    \n  exit(__status);\n}\n\n",
            "called": [
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102500",
            "calling": [
                "print_version",
                "yy_fatal_error"
            ],
            "imported": false,
            "current_name": "FUN_00102500"
        },
        "FUN_0010e2e0": {
            "renaming": {},
            "code": "\n\n\n\nchar * strerror(int __errnum)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strerror@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e2e0",
            "calling": [
                "strerror"
            ],
            "imported": false,
            "current_name": "FUN_0010e2e0"
        },
        "FUN_0010e238": {
            "renaming": {},
            "code": "\n\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* setlocale@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e238",
            "calling": [
                "setlocale"
            ],
            "imported": false,
            "current_name": "FUN_0010e238"
        },
        "FUN_00102190": {
            "renaming": {},
            "code": "\nvoid getopt_long(void)\n\n{\n  getopt_long();\n  return;\n}\n\n",
            "called": [
                "getopt_long"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102190",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102190"
        },
        "FUN_00102070": {
            "renaming": {},
            "code": "\n\n\nint unlink(char *__name)\n\n{\n  int iVar1;\n  \n  iVar1 = unlink(__name);\n  return iVar1;\n}\n\n",
            "called": [
                "unlink"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102070",
            "calling": [
                "smart_rename.constprop.0.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102070"
        },
        "FUN_0010285f": {
            "renaming": {
                "FUN_0010285f": "print_archive_entry_not_found_0010285f",
                "__format": "errorMessage",
                "lVar2": "archiveEntry",
                "plVar3": "tempPointer",
                "uVar4": "entryName",
                "plVar5": "currentEntry",
                "unaff_RBP": "callbackFunction",
                "unaff_R12": "archivePointer",
                "unaff_R13D": "entryCount",
                "unaff_R14": "entryNamesArray",
                "iStack000000000000000c": "counter"
            },
            "code": "\n\n\nvoid printArchiveEntryNotFound_0010285f(void)\n\n{\n  int iVar1;\n  char *errorMessage;\n  long archiveEntry;\n  long *tempPointer;\n  undefined8 entryName;\n  long *currentEntry;\n  code *callbackFunction;\n  long archivePointer;\n  int entryCount;\n  undefined8 *entryNamesArray;\n  int counter;\n  \ncode_r0x0010285f:\n  entryName = *entryNamesArray;\n  errorMessage = (char *)dcgettext(0,\"no entry %s in archive\\n\",5);\n  fprintf(_stderr,errorMessage,entryName);\nLAB_0010553e:\n  entryNamesArray = entryNamesArray + 1;\n  entryCount = entryCount + -1;\n  if (entryCount == 0) {\n    return;\n  }\n  currentEntry = *(long **)(archivePointer + 0xf0);\n  counter = 0;\n  do {\n    if (currentEntry == (long *)0x0) goto code_r0x0010285f;\n    if (*(int *)((long)currentEntry + 0xac) == 0) {\n      archiveEntry = *currentEntry;\n      if (archiveEntry == 0) {\n        tempPointer = (long *)currentEntry[0x1d];\n        if ((long *)currentEntry[0x1d] == (long *)0x0) {\n          tempPointer = currentEntry;\n        }\n        (**(code **)(tempPointer[1] + 0x1e8))(currentEntry,&stack0x00000010);\n      }\n      else if (((*(byte *)(archivePointer + 0x49) & 0x10) == 0) || (archiveEntry = normalize(), archiveEntry != 0)) {\n        entryName = normalize(*entryNamesArray);\n        iVar1 = filename_cmp(entryName,archiveEntry);\n        if ((iVar1 == 0) &&\n           ((counted_name_mode == '\\0' ||\n            (counter = counter + 1,\n            counter == counted_name_counter)))) break;\n      }\n    }\n    currentEntry = (long *)currentEntry[0x1e];\n  } while( true );\n  (*callbackFunction)();\n  *(undefined4 *)((long)currentEntry + 0xac) = 1;\n  goto LAB_0010553e;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010285f",
            "calling": [
                "map_over_members"
            ],
            "imported": false,
            "current_name": "print_archive_entry_not_found_0010285f"
        },
        "FUN_0010394a": {
            "renaming": {
                "FUN_0010394a": "print_usage_and_exit_0010394a",
                "param_1": "isOutputToFile",
                "uVar1": "programName",
                "pcVar2": "message",
                "__stream": "outputStream"
            },
            "code": "\n\n\nvoid printUsageAndExit_0010394a(uint isOutputToFile)\n\n{\n  undefined8 programName;\n  char *message;\n  FILE *outputStream;\n  \n  programName = program_name;\n  outputStream = _stderr;\n  if (isOutputToFile != 0) {\n    outputStream = _stdout;\n  }\n  message = (char *)dcgettext(0,\"Usage: %s [options] archive\\n\",5);\n  fprintf(outputStream,message,programName);\n  message = (char *)dcgettext(0,\" Generate an index to speed access to archives\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\n                             \" The options are:\\n  @<file>                      Read options from <file>\\n\"\n                             ,5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  --plugin <name>              Load the specified plugin\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\n                             \"  -D                           Use zero for symbol map timestamp (default)\\n  -U                           Use an actual symbol map timestamp\\n\"\n                             ,5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\n                             \"  -t                           Update the archive\\'s symbol map timestamp\\n  -h --help                    Print this help message\\n  -v --version                 Print version information\\n\"\n                             ,5);\n  fprintf(outputStream,message);\n  list_supported_targets(program_name,outputStream);\n  if (isOutputToFile != 0) {\n    message = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(outputStream,message,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  xexit(isOutputToFile ^ 1);\n}\n\n",
            "called": [
                "xexit",
                "fprintf",
                "list_supported_targets",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010394a",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "print_usage_and_exit_0010394a"
        },
        "FUN_00105bb0": {
            "renaming": {
                "FUN_00105bb0": "get_one_00105bb0",
                "undefined8": "uint64_t"
            },
            "code": "\nuint64_t getOne_00105bb0(void)\n\n{\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105bb0",
            "calling": [],
            "imported": false,
            "current_name": "get_one_00105bb0"
        },
        "FUN_00107640": {
            "renaming": {
                "FUN_00107640": "initialize_program_00107640"
            },
            "code": "\nundefined8 initializeProgram_00107640(void)\n\n{\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107640",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_program_00107640"
        },
        "FUN_0010e1d8": {
            "renaming": {},
            "code": "\n\n\n\nvoid clearerr(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* clearerr@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1d8",
            "calling": [
                "clearerr"
            ],
            "imported": false,
            "current_name": "FUN_0010e1d8"
        },
        "FUN_00102510": {
            "renaming": {},
            "code": "\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fwrite(__ptr,__size,__n,__s);\n  return sVar1;\n}\n\n",
            "called": [
                "fwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102510",
            "calling": [
                "print_contents",
                "extract_file.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102510"
        },
        "FUN_0010315d": {
            "renaming": {
                "FUN_0010315d": "handle_non_interactive_mode_0010315d",
                "interactive": "isInteractive",
                "xexit": "exitProgram"
            },
            "code": "\nvoid handleNonInteractiveMode_0010315d(void)\n\n{\n  if (isInteractive == 0) {\n                    \n    exitProgram(9);\n  }\n  return;\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010315d",
            "calling": [
                "open_inarch",
                "ar_open",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "handle_non_interactive_mode_0010315d"
        },
        "FUN_0010e1d0": {
            "renaming": {},
            "code": "\n\n\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strtol@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1d0",
            "calling": [
                "strtol"
            ],
            "imported": false,
            "current_name": "FUN_0010e1d0"
        },
        "FUN_0010e248": {
            "renaming": {},
            "code": "\n\n\n\nint chmod(char *__file,__mode_t __mode)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* chmod@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e248",
            "calling": [
                "chmod"
            ],
            "imported": false,
            "current_name": "FUN_0010e248"
        },
        "FUN_0010e008": {
            "renaming": {},
            "code": "\n\n\n\nint utimensat(int __fd,char *__path,timespec *__times,int __flags)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* utimensat@GLIBC_2.6 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e008",
            "calling": [
                "utimensat"
            ],
            "imported": false,
            "current_name": "FUN_0010e008"
        },
        "FUN_00102080": {
            "renaming": {},
            "code": "\nvoid bfd_make_writable(void)\n\n{\n  bfd_make_writable();\n  return;\n}\n\n",
            "called": [
                "bfd_make_writable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102080",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102080"
        },
        "FUN_00107890": {
            "renaming": {
                "FUN_00107890": "print_arelt_descr_00107890",
                "param_1": "output_file",
                "_stdout": "standard_output",
                "verbose": "print_verbose",
                "display_offsets": "show_offsets"
            },
            "code": "\n\n\nvoid print_arelt_descr_00107890(undefined8 output_file)\n\n{\n  print_arelt_descr_00107890(standard_output,output_file,print_verbose != 0,show_offsets != 0);\n  return;\n}\n\n",
            "called": [
                "print_arelt_descr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107890",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "print_arelt_descr_00107890"
        },
        "FUN_001024a0": {
            "renaming": {},
            "code": "\n\n\nvoid perror(char *__s)\n\n{\n  perror(__s);\n  return;\n}\n\n",
            "called": [
                "perror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024a0",
            "calling": [
                "open_inarch",
                "FUN_00105a68"
            ],
            "imported": false,
            "current_name": "FUN_001024a0"
        },
        "FUN_0010e000": {
            "renaming": {},
            "code": "\n\n\n\nvoid free(void *__ptr)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* free@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e000",
            "calling": [
                "free"
            ],
            "imported": false,
            "current_name": "FUN_0010e000"
        },
        "FUN_00103172": {
            "renaming": {
                "FUN_00103172": "copy_data_00103172",
                "param_1": "source",
                "param_2": "destination",
                "param_3": "flag",
                "param_4": "value",
                "uVar1": "old_value",
                "auVar2": "new_data"
            },
            "code": "\nundefined  [16]\ncopy_data_00103172(undefined8 *source,undefined8 *destination,char flag,undefined8 value)\n\n{\n  undefined8 old_value;\n  undefined new_data [16];\n  \n  if (flag != '\\0') {\n    printf(\"r - %s\\n\",*destination);\n  }\n  old_value = *source;\n  destination[0x1e] = old_value;\n  new_data._1_7_ = (undefined7)((ulong)old_value >> 8);\n  new_data[0] = 1;\n  *source = destination;\n  new_data._8_8_ = value;\n  return new_data;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103172",
            "calling": [
                "replace_members.cold"
            ],
            "imported": false,
            "current_name": "copy_data_00103172"
        },
        "FUN_0010e0a8": {
            "renaming": {},
            "code": "\n\n\n\nint fclose(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fclose@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0a8",
            "calling": [
                "fclose"
            ],
            "imported": false,
            "current_name": "FUN_0010e0a8"
        },
        "FUN_001030ed": {
            "renaming": {
                "FUN_001030ed": "initialize_buffer_001030ed",
                "puVar1": "bufferPointer",
                "yy_buffer_stack": "bufferStack",
                "yy_buffer_stack_top": "bufferStackTop",
                "yy_n_chars": "numberOfChars",
                "yy_c_buf_p": "currentBufferPointer",
                "yytext": "textBuffer",
                "yyin": "inputBuffer",
                "yy_hold_char": "holdCharacter"
            },
            "code": "\nvoid initializeBuffer_001030ed(void)\n\n{\n  undefined8 *bufferPointer;\n  \n  bufferPointer = *(undefined8 **)(bufferStack + bufferStackTop * 8);\n  numberOfChars = *(undefined4 *)((long)bufferPointer + 0x1c);\n  currentBufferPointer = (undefined *)bufferPointer[2];\n  textBuffer = currentBufferPointer;\n  inputBuffer = *bufferPointer;\n  holdCharacter = *currentBufferPointer;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001030ed",
            "calling": [
                "yy_init_buffer",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "initialize_buffer_001030ed"
        },
        "FUN_00105bc0": {
            "renaming": {
                "FUN_00105bc0": "copy_and_delete_file_00105bc0",
                "param_1": "sourceFilePath",
                "param_2": "destinationFilePath",
                "param_3": "filePermission",
                "param_4": "errorCode",
                "uVar1": "copyResult",
                "piVar2": "errnoLocation",
                "pcVar3": "errorString",
                "uVar4": "errorDescription",
                "uVar5": "unlinkResult",
                "auVar6": "resultContainer"
            },
            "code": "\nundefined  [16] copyAndDeleteFile_00105bc0(char *sourceFilePath,char *destinationFilePath,undefined4 filePermission,undefined8 errorCode)\n\n{\n  uint copyResult;\n  int *errnoLocation;\n  char *errorString;\n  undefined8 errorDescription;\n  ulong unlinkResult;\n  undefined resultContainer [16];\n  \n  if (destinationFilePath == sourceFilePath) {\n    unlinkResult = 0;\n  }\n  else {\n    copyResult = simple_copy_constprop_0(filePermission);\n    unlinkResult = (ulong)copyResult;\n    if (copyResult != 0) {\n      errnoLocation = __errno_location();\n      errorString = strerror(*errnoLocation);\n      errorDescription = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n      non_fatal(errorDescription,destinationFilePath,errorString);\n    }\n    unlink(sourceFilePath);\n  }\n  resultContainer._8_8_ = errorCode;\n  resultContainer._0_8_ = unlinkResult;\n  return resultContainer;\n}\n\n",
            "called": [
                "simple_copy.constprop.0",
                "smart_rename.constprop.0.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105bc0",
            "calling": [
                "write_archive.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "copy_and_delete_file_00105bc0"
        },
        "FUN_00107650": {
            "renaming": {
                "FUN_00107650": "handle_file_00107650",
                "param_1": "file",
                "uVar1": "status",
                "lVar2": "fileSize",
                "write_armap": "writeArchiveFlag"
            },
            "code": "\nundefined8 handleFile_00107650(undefined8 file)\n\n{\n  undefined8 status;\n  long fileSize;\n  \n  fileSize = get_file_size();\n  if (fileSize < 1) {\n    status = 1;\n  }\n  else {\n    writeArchiveFlag = 1;\n    fileSize = open_inarch(file,0);\n    if (fileSize == 0) {\n                    \n      xexit(1);\n    }\n    write_archive(fileSize);\n    status = 0;\n  }\n  return status;\n}\n\n",
            "called": [
                "xexit",
                "open_inarch",
                "write_archive",
                "ranlib_only.cold",
                "get_file_size"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107650",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "handle_file_00107650"
        },
        "FUN_00102f1e": {
            "renaming": {
                "FUN_00102f1e": "copy_and_unlink_file_00102f1e",
                "piVar1": "errorLocationPointer",
                "uVar2": "errorMessage",
                "unaff_RBP": "fileSize",
                "unaff_R12": "filePath",
                "auVar3": "returnValue",
                "unaff_retaddr": "returnAddress"
            },
            "code": "\nundefined  [16] copyAndUnlinkFile_00102f1e(void)\n\n{\n  int *errorLocationPointer;\n  undefined8 errorMessage;\n  ulong fileSize;\n  char *filePath;\n  undefined returnValue [16];\n  undefined8 returnAddress;\n  \n  errorLocationPointer = __errno_location();\n  strerror(*errorLocationPointer);\n  errorMessage = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n  non_fatal(errorMessage);\n  unlink(filePath);\n  returnValue._0_8_ = fileSize & 0xffffffff;\n  returnValue._8_8_ = returnAddress;\n  return returnValue;\n}\n\n",
            "called": [
                "__errno_location",
                "strerror",
                "unlink",
                "dcgettext",
                "non_fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f1e",
            "calling": [
                "smart_rename.constprop.0"
            ],
            "imported": false,
            "current_name": "copy_and_unlink_file_00102f1e"
        },
        "FUN_0010e1e8": {
            "renaming": {},
            "code": "\n\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memcpy@GLIBC_2.14 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1e8",
            "calling": [
                "memcpy"
            ],
            "imported": false,
            "current_name": "FUN_0010e1e8"
        },
        "FUN_00102fd7": {
            "renaming": {
                "FUN_00102fd7": "print_time_set_error_message_00102fd7",
                "piVar1": "errorCodePtr",
                "uVar2": "errorMessage",
                "__errno_location": "getErrorCodePointer",
                "strerror": "getErrorString",
                "dcgettext": "getLocalizedMessage",
                "non_fatal": "reportError"
            },
            "code": "\nvoid printTimeSetErrorMessage_00102fd7(void)\n\n{\n  int *errorCodePtr;\n  undefined8 errorMessage;\n  \n  errorCodePtr = getErrorCodePointer();\n  getErrorString(*errorCodePtr);\n  errorMessage = getLocalizedMessage(0,\"%s: cannot set time: %s\",5);\n  reportError(errorMessage);\n  return;\n}\n\n",
            "called": [
                "__errno_location",
                "strerror",
                "dcgettext",
                "non_fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102fd7",
            "calling": [
                "set_times"
            ],
            "imported": false,
            "current_name": "print_time_set_error_message_00102fd7"
        },
        "FUN_0010e0c8": {
            "renaming": {},
            "code": "\n\n\nvoid dcgettext(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* dcgettext@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0c8",
            "calling": [
                "dcgettext"
            ],
            "imported": false,
            "current_name": "FUN_0010e0c8"
        },
        "FUN_00102400": {
            "renaming": {},
            "code": "\n\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = realloc(__ptr,__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102400",
            "calling": [
                "yyensure_buffer_stack",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102400"
        },
        "FUN_00102520": {
            "renaming": {},
            "code": "\nvoid bfd_check_format(void)\n\n{\n  bfd_check_format();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102520",
            "calling": [
                "open_inarch.cold",
                "do_ar_emul_append.constprop.0",
                "ar_open"
            ],
            "imported": false,
            "current_name": "FUN_00102520"
        },
        "FUN_001024b0": {
            "renaming": {},
            "code": "\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n  int iVar1;\n  \n  iVar1 = vfprintf(__s,__format,__arg);\n  return iVar1;\n}\n\n",
            "called": [
                "vfprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024b0",
            "calling": [
                "report"
            ],
            "imported": false,
            "current_name": "FUN_001024b0"
        },
        "FUN_00107da8": {
            "renaming": {
                "FUN_00107da8": "FUNC_00107da8"
            },
            "code": "\nvoid FUNC_00107da8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00107da8",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_00107da8"
        },
        "FUN_0010e0c0": {
            "renaming": {},
            "code": "\n\n\nvoid bindtextdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* bindtextdomain@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0c0",
            "calling": [
                "bindtextdomain"
            ],
            "imported": false,
            "current_name": "FUN_0010e0c0"
        },
        "FUN_0010e018": {
            "renaming": {},
            "code": "\n\n\nvoid __libc_start_main(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __libc_start_main@GLIBC_2.34 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e018",
            "calling": [
                "_start"
            ],
            "imported": false,
            "current_name": "FUN_0010e018"
        },
        "FUN_00105d60": {
            "renaming": {
                "FUN_00105d60": "initialize_program_00105d60",
                "completed_0": "isInitialized",
                "__cxa_finalize": "finalizeConstructorDestructors",
                "__dso_handle": "dynamicSharedObjectHandle",
                "deregister_tm_clones": "deregisterClonedConstructors"
            },
            "code": "\nvoid initializeProgram_00105d60(void)\n\n{\n  if (isInitialized != '\\0') {\n    return;\n  }\n  finalizeConstructorDestructors(dynamicSharedObjectHandle);\n  deregisterClonedConstructors();\n  isInitialized = 1;\n  return;\n}\n\n",
            "called": [
                "deregister_tm_clones",
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105d60",
            "calling": [],
            "imported": false,
            "current_name": "initialize_program_00105d60"
        },
        "FUN_001075e0": {
            "renaming": {
                "FUN_001075e0": "print_welcome_message_001075e0",
                "param_1": "version",
                "pcVar1": "copyRightMsg"
            },
            "code": "\nvoid printWelcomeMessage_001075e0(undefined8 version)\n\n{\n  char *copyRightMsg;\n  \n  printf(\"GNU %s %s\\n\",version,\"(GNU Binutils for Debian) 2.40\");\n  copyRightMsg = (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n  printf(copyRightMsg);\n  copyRightMsg = (char *)dcgettext(0,\n                             \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                             ,5);\n  printf(copyRightMsg);\n                    \n  exit(0);\n}\n\n",
            "called": [
                "exit",
                "printf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001075e0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "print_welcome_message_001075e0"
        },
        "FUN_00105480": {
            "renaming": {
                "FUN_00105480": "process_archive_entries_00105480",
                "param_1": "archive",
                "param_2": "entryProcessor",
                "param_3": "filenames",
                "param_4": "numFilenames",
                "iVar1": "filenameComparisonResult",
                "__format": "errorMessageFormat",
                "lVar2": "currEntry",
                "plVar3": "fallbackEntry",
                "uVar4": "normalizedEntry",
                "plVar5": "currArchiveEntry",
                "local_cc": "countedNameCounter",
                "local_c8": "localBuffer"
            },
            "code": "\n\n\nvoid processArchiveEntries_00105480(long archive,code *entryProcessor,undefined8 *filenames,int numFilenames)\n\n{\n  int filenameComparisonResult;\n  char *errorMessageFormat;\n  long currEntry;\n  long *fallbackEntry;\n  undefined8 normalizedEntry;\n  long *currArchiveEntry;\n  int countedNameCounter;\n  undefined localBuffer [152];\n  \n  currEntry = *(long *)(archive + 0xf0);\n  if (numFilenames == 0) {\n    for (; currEntry != 0; currEntry = *(long *)(currEntry + 0xf0)) {\n      (*entryProcessor)(currEntry);\n    }\n  }\n  else {\n    for (; currEntry != 0; currEntry = *(long *)(currEntry + 0xf0)) {\n      *(undefined4 *)(currEntry + 0xac) = 0;\n    }\n    do {\n      currArchiveEntry = *(long **)(archive + 0xf0);\n      countedNameCounter = 0;\n      for (; currArchiveEntry != (long *)0x0; currArchiveEntry = (long *)currArchiveEntry[0x1e]) {\n        if (*(int *)((long)currArchiveEntry + 0xac) == 0) {\n          currEntry = *currArchiveEntry;\n          if (currEntry == 0) {\n            fallbackEntry = (long *)currArchiveEntry[0x1d];\n            if ((long *)currArchiveEntry[0x1d] == (long *)0x0) {\n              fallbackEntry = currArchiveEntry;\n            }\n            (**(code **)(fallbackEntry[1] + 0x1e8))(currArchiveEntry,localBuffer);\n          }\n          else if (((*(byte *)(archive + 0x49) & 0x10) == 0) ||\n                  (currEntry = normalize(currEntry,archive), currEntry != 0)) {\n            normalizedEntry = normalize(*filenames,archive);\n            filenameComparisonResult = filename_cmp(normalizedEntry,currEntry);\n            if ((filenameComparisonResult == 0) &&\n               ((counted_name_mode == '\\0' ||\n                (countedNameCounter = countedNameCounter + 1, countedNameCounter == counted_name_counter)))) {\n              (*entryProcessor)();\n              *(undefined4 *)((long)currArchiveEntry + 0xac) = 1;\n              goto LAB_0010553e;\n            }\n          }\n        }\n      }\n      normalizedEntry = *filenames;\n      errorMessageFormat = (char *)dcgettext(0,\"no entry %s in archive\\n\",5);\n      fprintf(_stderr,errorMessageFormat,normalizedEntry);\nLAB_0010553e:\n      filenames = filenames + 1;\n      numFilenames = numFilenames + -1;\n    } while (numFilenames != 0);\n  }\n  return;\n}\n\n",
            "called": [
                "filename_cmp",
                "normalize",
                "map_over_members.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105480",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "process_archive_entries_00105480"
        },
        "FUN_00105cf0": {
            "renaming": {
                "FUN_00105cf0": "FUNC_00105cf0"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00105d03) */\n/* WARNING: Removing unreachable block (ram,0x00105d0f) */\n\nvoid FUNC_00105cf0(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_deregisterTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00105cf0",
            "calling": [
                "__do_global_dtors_aux"
            ],
            "imported": false,
            "current_name": "FUNC_00105cf0"
        },
        "FUN_00102090": {
            "renaming": {},
            "code": "\nvoid bfd_plugin_set_plugin(void)\n\n{\n  bfd_plugin_set_plugin();\n  return;\n}\n\n",
            "called": [
                "bfd_plugin_set_plugin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102090",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102090"
        },
        "FUN_0010e258": {
            "renaming": {},
            "code": "\n\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memmove@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e258",
            "calling": [
                "memmove"
            ],
            "imported": false,
            "current_name": "FUN_0010e258"
        },
        "FUN_00102530": {
            "renaming": {},
            "code": "\nvoid bfd_openr_next_archived_file(void)\n\n{\n  bfd_openr_next_archived_file();\n  return;\n}\n\n",
            "called": [
                "bfd_openr_next_archived_file"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102530",
            "calling": [
                "open_inarch",
                "do_ar_emul_append.constprop.0",
                "ar_open"
            ],
            "imported": false,
            "current_name": "FUN_00102530"
        },
        "FUN_0010e0b8": {
            "renaming": {},
            "code": "\n\n\n\nchar * ctime(time_t *__timer)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ctime@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0b8",
            "calling": [
                "ctime"
            ],
            "imported": false,
            "current_name": "FUN_0010e0b8"
        },
        "FUN_0010e0d8": {
            "renaming": {},
            "code": "\n\n\nvoid getopt_long(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getopt_long@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0d8",
            "calling": [
                "getopt_long"
            ],
            "imported": false,
            "current_name": "FUN_0010e0d8"
        },
        "FUN_00102410": {
            "renaming": {},
            "code": "\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = setlocale(__category,__locale);\n  return pcVar1;\n}\n\n",
            "called": [
                "setlocale"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102410",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102410"
        },
        "FUN_00103a78": {
            "renaming": {
                "FUN_00103a78": "decompile_and_improve_00103a78",
                "param_1": "input",
                "iVar1": "result",
                "__ptr": "buffer",
                "puVar2": "ptr",
                "uVar3": "bytes_read",
                "uVar4": "error_message",
                "sVar5": "bytes_written",
                "piVar6": "error_number_location",
                "unaff_RBP": "bytes_remaining",
                "pcVar7": "error_string",
                "unaff_R13": "total_bytes_read",
                "unaff_R14": "file_size",
                "auStack_b8": "temporary_stack",
                "local_88": "remaining_bytes"
            },
            "code": "\n\n\nvoid decompile_and_improve_00103a78(undefined8 *input)\n\n{\n  int result;\n  void *buffer;\n  undefined8 *ptr;\n  ulong bytes_read;\n  undefined8 error_message;\n  size_t bytes_written;\n  int *error_number_location;\n  size_t bytes_remaining;\n  char *error_string;\n  ulong total_bytes_read;\n  ulong file_size;\n  undefined temporary_stack [48];\n  ulong remaining_bytes;\n  \n  buffer = (void *)xmalloc(0x2000);\n  ptr = (undefined8 *)input[0x1d];\n  if ((undefined8 *)input[0x1d] == (undefined8 *)0x0) {\n    ptr = input;\n  }\n  result = (**(code **)(ptr[1] + 0x1e8))(input,temporary_stack);\n  if (result == 0) {\n    if (verbose != 0) {\n      printf(\"\\n<%s>\\n\\n\",*input);\n    }\n    total_bytes_read = 0;\n    bfd_seek(input,0,0);\n    goto LAB_00103afd;\n  }\n  input = (undefined8 *)*input;\n  error_string = \"internal stat error on %s\";\n  do {\n    error_message = dcgettext(0,error_string,5);\n    fatal(error_message,input);\n    remaining_bytes = file_size;\n    do {\n      bytes_written = fwrite(buffer,1,bytes_remaining,_stdout);\n      if (bytes_written != bytes_remaining) {\n        error_number_location = __errno_location();\n        error_string = strerror(*error_number_location);\n        fatal(\"stdout: %s\",error_string);\nLAB_00103b91:\n        free(buffer);\n        return;\n      }\n      total_bytes_read = total_bytes_read + bytes_written;\nLAB_00103afd:\n      if (remaining_bytes <= total_bytes_read) goto LAB_00103b91;\n      bytes_remaining = remaining_bytes - total_bytes_read;\n      if (0x2000 < bytes_remaining) {\n        bytes_remaining = 0x2000;\n      }\n      bytes_read = bfd_bread(buffer,bytes_remaining,input);\n    } while (bytes_remaining == bytes_read);\n    error_string = \"%s is not a valid archive\";\n    input = *(undefined8 **)input[0x1d];\n    file_size = remaining_bytes;\n  } while( true );\n}\n\n",
            "called": [
                "fwrite",
                "xmalloc",
                "fatal",
                "bfd_seek",
                "__errno_location",
                "strerror",
                "printf",
                "free",
                "dcgettext",
                "bfd_bread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103a78",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "decompile_and_improve_00103a78"
        },
        "FUN_0010e1f0": {
            "renaming": {},
            "code": "\n\n\n\nint fileno(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fileno@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1f0",
            "calling": [
                "fileno"
            ],
            "imported": false,
            "current_name": "FUN_0010e1f0"
        },
        "FUN_001023a0": {
            "renaming": {},
            "code": "\nvoid bfd_plugin_set_program_name(void)\n\n{\n  bfd_plugin_set_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_plugin_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023a0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001023a0"
        },
        "FUN_0010e0d0": {
            "renaming": {},
            "code": "\n\n\n\nsize_t strlen(char *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strlen@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0d0",
            "calling": [
                "strlen"
            ],
            "imported": false,
            "current_name": "FUN_0010e0d0"
        },
        "FUN_001024c0": {
            "renaming": {},
            "code": "\nvoid bfd_check_format_matches(void)\n\n{\n  bfd_check_format_matches();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format_matches"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024c0",
            "calling": [
                "open_inarch",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001024c0"
        },
        "FUN_0010e028": {
            "renaming": {},
            "code": "\n\n\n\nint unlink(char *__name)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* unlink@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e028",
            "calling": [
                "unlink"
            ],
            "imported": false,
            "current_name": "FUN_0010e028"
        },
        "FUN_0010e268": {
            "renaming": {},
            "code": "\n\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fopen@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e268",
            "calling": [
                "fopen"
            ],
            "imported": false,
            "current_name": "FUN_0010e268"
        },
        "FUN_0010e148": {
            "renaming": {},
            "code": "\n\n\n\nint close(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* close@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e148",
            "calling": [
                "close"
            ],
            "imported": false,
            "current_name": "FUN_0010e148"
        },
        "FUN_0010e020": {
            "renaming": {},
            "code": "\n\n\n\nint * __errno_location(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __errno_location@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e020",
            "calling": [
                "__errno_location"
            ],
            "imported": false,
            "current_name": "FUN_0010e020"
        },
        "FUN_001058b0": {
            "renaming": {
                "FUN_001058b0": "generate_archive_001058b0",
                "param_1": "input_files",
                "cVar1": "result",
                "uVar2": "flags",
                "iVar3": "temp_file_descriptor",
                "uVar4": "time_data",
                "__format": "format_string",
                "__ptr": "temp_filename",
                "__stream": "output_file",
                "ppcVar5": "output_bfd",
                "uStack0000000000000020": "file_permissions",
                "in_stack_00000028": "inode",
                "in_stack_00000038": "file_size",
                "local_3c": "error_code",
                "uStack_33": "file_type",
                "cStack_32": "is_setuid",
                "cStack_31": "is_setgid"
            },
            "code": "\nvoid generate_archive_001058b0(undefined8 *input_files)\n\n{\n  char result;\n  uint flags;\n  int temp_file_descriptor;\n  undefined8 time_data;\n  char *format_string;\n  void *temp_filename;\n  FILE *output_file;\n  char **output_bfd;\n  uint file_permissions;\n  uint inode;\n  undefined8 file_size;\n  int error_code [2];\n  undefined file_type;\n  char is_setuid;\n  char is_setgid;\n  \n  time_data = input_files[0x1e];\n  error_code[0] = -1;\n  temp_filename = (void *)xstrdup(*input_files);\n  output_file = (FILE *)make_tempname(temp_filename,error_code);\n  temp_file_descriptor = error_code[0];\n  if (output_file != (FILE *)0x0) {\n    output_filename = output_file;\n    output_bfd = (char **)bfd_fdopenw(output_file,*(undefined8 *)input_files[1],error_code[0]);\n    if (output_bfd != (char **)0x0) {\n      output_bfd = output_bfd;\n      bfd_set_format(output_bfd,2);\n      flags = (~write_armap >> 0x1f) << 3 | *(byte *)((long)output_bfd + 0x49) & 0xfffffff7;\n      *(char *)((long)output_bfd + 0x49) = (char)flags;\n      if (ar_truncate != '\\0') {\n        *(uint *)((long)output_bfd + 0x44) = *(uint *)((long)output_bfd + 0x44) | 0x400;\n      }\n      if (deterministic != 0) {\n        *(uint *)((long)output_bfd + 0x44) = *(uint *)((long)output_bfd + 0x44) | 0x2000;\n      }\n      if (full_pathname != '\\0') goto LAB_00102d37;\n      while( true ) {\n        if ((make_thin_archive != '\\0') || ((*(byte *)((long)input_files + 0x49) & 0x10) != 0)) {\n          *(byte *)((long)output_bfd + 0x49) = (byte)flags | 0x10;\n        }\n        result = bfd_set_archive_head(output_bfd,time_data);\n        if (result != '\\0') break;\n        flags = bfd_fatal(temp_filename);\nLAB_00102d37:\n        *(uint *)((long)output_bfd + 0x44) = *(uint *)((long)output_bfd + 0x44) | 0x100000;\n      }\n      temp_file_descriptor = dup(temp_file_descriptor);\n      result = bfd_close(output_bfd);\n      if (result == '\\0') {\n        bfd_fatal(temp_filename);\n        format_string = (char *)dcgettext(0,\"<time data corrupt>\",5);\n        sprintf(&stack0xffffffffffffffd8,format_string);\n        flags = file_permissions & 0xf000;\n        if (flags == 0x4000) {\n          file_type = 100;\n        }\n        else if (flags == 0xa000) {\n          file_type = 0x6c;\n        }\n        else if (flags == 0x6000) {\n          file_type = 0x62;\n        }\n        else if (flags == 0x2000) {\n          file_type = 99;\n        }\n        else if (flags == 0xc000) {\n          file_type = 0x73;\n        }\n        else {\n          file_type = 0x70;\n          if (flags != 0x1000) {\n            file_type = 0x2d;\n          }\n        }\n        is_setuid = (-((_file_permissions & 0x100) == 0) & 0xbbU) + 0x72;\n        is_setgid = (-((_file_permissions & 0x80) == 0) & 0xb6U) + 0x77;\n        fprintf(output_file,\"%s %ld/%ld %6lu %s \",&is_setuid,_file_permissions >> 0x20,\n                (ulong)inode,file_size,&stack0xffffffffffffffd8,\n                _file_permissions & 0xffffffff);\n        fputs(*output_bfd,output_file);\n        if ((char)input_files != '\\0') {\n          if ((*(byte *)((long)output_bfd + 0x49) & 0x10) == 0) {\n            if (output_bfd[0xb] != (char *)0x0) {\n              fprintf(output_file,\" 0x%lx\");\n            }\n          }\n          else if (output_bfd[0xc] != (char *)0x0) {\n            fprintf(output_file,\" 0x%lx\");\n          }\n        }\n        fputc(10,output_file);\n        return;\n      }\n      output_bfd = (char **)0x0;\n      output_filename = (FILE *)0x0;\n      bfd_close(input_files);\n      temp_file_descriptor = smart_rename_constprop_0(output_file,temp_filename,temp_file_descriptor);\n      if (temp_file_descriptor == 0) {\n        free(temp_filename);\n        free(output_file);\n        return;\n      }\n      goto LAB_00102d7a;\n    }\n    close(temp_file_descriptor);\n    bfd_fatal(temp_filename);\n  }\n  time_data = dcgettext(0,\"could not create temporary file whilst writing archive\",5);\n  bfd_fatal(time_data);\nLAB_00102d7a:\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "make_tempname",
                "close",
                "bfd_fatal",
                "bfd_fdopenw",
                "dcgettext",
                "bfd_set_format",
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001058b0",
            "calling": [
                "ranlib_only",
                "replace_members.cold",
                "main"
            ],
            "imported": false,
            "current_name": "generate_archive_001058b0"
        },
        "FUN_00102420": {
            "renaming": {},
            "code": "\nvoid bfd_openw(void)\n\n{\n  bfd_openw();\n  return;\n}\n\n",
            "called": [
                "bfd_openw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102420",
            "calling": [
                "open_inarch",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102420"
        },
        "FUN_0010e260": {
            "renaming": {},
            "code": "\n\n\n\nint open(char *__file,int __oflag,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* open@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e260",
            "calling": [
                "open"
            ],
            "imported": false,
            "current_name": "FUN_0010e260"
        },
        "FUN_00102540": {
            "renaming": {},
            "code": "\nvoid bfd_bread(void)\n\n{\n  bfd_bread();\n  return;\n}\n\n",
            "called": [
                "bfd_bread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102540",
            "calling": [
                "print_contents",
                "extract_file.cold"
            ],
            "imported": false,
            "current_name": "FUN_00102540"
        },
        "FUN_00102300": {
            "renaming": {},
            "code": "\nvoid bfd_fdopenr(void)\n\n{\n  bfd_fdopenr();\n  return;\n}\n\n",
            "called": [
                "bfd_fdopenr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102300",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102300"
        },
        "FUN_001024d0": {
            "renaming": {},
            "code": "\nvoid bfd_errmsg(void)\n\n{\n  bfd_errmsg();\n  return;\n}\n\n",
            "called": [
                "bfd_errmsg"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024d0",
            "calling": [
                "bfd_nonfatal",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001024d0"
        },
        "FUN_0010e0e0": {
            "renaming": {},
            "code": "\n\n\n\nint printf(char *__format,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* printf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0e0",
            "calling": [
                "printf"
            ],
            "imported": false,
            "current_name": "FUN_0010e0e0"
        },
        "FUN_001023b0": {
            "renaming": {},
            "code": "\n\n\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "malloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023b0",
            "calling": [
                "yy_create_buffer.constprop.0",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_001023b0"
        },
        "FUN_00105a20": {
            "renaming": {
                "FUN_00105a20": "extract_archive_member_00105a20",
                "param_1": "inputPath",
                "pcVar1": "outputPath",
                "pcVar2": "currentPath",
                "uVar3": "baseName",
                "uVar4": "errorMessage",
                "pFVar5": "outputFile",
                "sVar6": "outputDirLength"
            },
            "code": "\nvoid extractArchiveMember_00105a20(char *inputPath)\n\n{\n  char *outputPath;\n  char *currentPath;\n  undefined8 baseName;\n  undefined8 errorMessage;\n  FILE *outputFile;\n  size_t outputDirLength;\n  \n  outputPath = output_dir;\n  output_filename = inputPath;\n  if (*inputPath == '/') {\nLAB_00102e9a:\n    baseName = lbasename();\n    outputPath = output_filename;\n    errorMessage = dcgettext(0,\"illegal output pathname for archive member: %s, using \\'%s\\' instead\",5);\n    non_fatal(errorMessage,outputPath,baseName);\n    output_filename = (char *)baseName;\n    FUN_00105a68();\n    return;\n  }\n  do {\n    if (*inputPath == '\\0') {\n      if ((output_dir != (char *)0x0) && (outputDirLength = strlen(output_dir), outputDirLength != 0)) {\n        if (outputPath[outputDirLength - 1] == '/') {\n          output_filename = (char *)concat(outputPath,output_filename,0);\n        }\n        else {\n          output_filename = (char *)concat(outputPath,&DAT_00108260,output_filename,0);\n        }\n      }\n      if (verbose != 0) {\n        printf(\"x - %s\\n\",output_filename);\n      }\n      outputFile = fopen(output_filename,\"w\");\n      if (outputFile == (FILE *)0x0) {\n        perror(output_filename);\n                    \n        xexit(1);\n      }\n      return;\n    }\n    currentPath = inputPath;\n    if ((*inputPath == '.') && (currentPath = inputPath + 1, inputPath[1] == '.')) {\n      currentPath = inputPath + 2;\n      if ((inputPath[2] == '/') || (inputPath[2] == '\\0')) goto LAB_00102e9a;\n    }\n    for (; (*currentPath != '\\0' && (*currentPath != '/')); currentPath = currentPath + 1) {\n    }\n    for (; inputPath = currentPath, *currentPath == '/'; currentPath = currentPath + 1) {\n    }\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105a20",
            "calling": [
                "extract_file.cold"
            ],
            "imported": false,
            "current_name": "extract_archive_member_00105a20"
        },
        "FUN_0010e158": {
            "renaming": {},
            "code": "\n\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fputc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e158",
            "calling": [
                "fputc"
            ],
            "imported": false,
            "current_name": "FUN_0010e158"
        },
        "FUN_00102f55": {
            "renaming": {
                "FUN_00102f55": "close_file_and_set_error_00102f55",
                "unaff_R12D": "fileDescriptor",
                "piVar2": "errorPointer",
                "iVar1": "originalError"
            },
            "code": "\nundefined8 closeFileAndSetError_00102f55(void)\n\n{\n  int originalError;\n  int *errorPointer;\n  int fileDescriptor;\n  \n  errorPointer = __errno_location();\n  originalError = *errorPointer;\n  close(fileDescriptor);\n  *errorPointer = originalError;\n  return 0xffffffff;\n}\n\n",
            "called": [
                "close",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f55",
            "calling": [
                "simple_copy.constprop.0"
            ],
            "imported": false,
            "current_name": "close_file_and_set_error_00102f55"
        },
        "FUN_001057a0": {
            "renaming": {
                "FUN_001057a0": "allocate_and_initialize_file_001057a0",
                "param_1": "path",
                "param_2": "fileDescriptor",
                "param_3": "unknown1",
                "param_4": "unknown2",
                "iVar1": "result",
                "pcVar2": "lastSlash",
                "lVar3": "pathLength",
                "lVar4": "i",
                "lVar5": "lastSlashIndex",
                "pcVar6": "allocatedPath",
                "bVar7": "count",
                "auVar8": "returnValue"
            },
            "code": "\nundefined  [16] allocateAndInitializeFile_001057a0(char *path,int *fileDescriptor,undefined8 unknown1,undefined8 unknown2)\n\n{\n  int result;\n  char *lastSlash;\n  long pathLength;\n  long i;\n  long lastSlashIndex;\n  char *allocatedPath;\n  byte count;\n  undefined returnValue [16];\n  \n  count = 0;\n  lastSlash = strrchr(path,0x2f);\n  if (lastSlash == (char *)0x0) {\n    lastSlash = (char *)xmalloc(9);\n    pathLength = 0;\n  }\n  else {\n    lastSlashIndex = (long)lastSlash - (long)path;\n    lastSlash = (char *)xmalloc(lastSlashIndex + 0xb);\n    pathLength = lastSlashIndex + 1;\n    allocatedPath = lastSlash;\n    for (i = lastSlashIndex; i != 0; i = i + -1) {\n      *allocatedPath = *path;\n      path = path + (ulong)count * -2 + 1;\n      allocatedPath = allocatedPath + (ulong)count * -2 + 1;\n    }\n    lastSlash[lastSlashIndex] = '/';\n  }\n  *(undefined8 *)(lastSlash + pathLength) = 0x5858585858587473;\n  *(undefined *)((long)(lastSlash + pathLength) + 8) = 0;\n  result = mkstemp(lastSlash);\n  if (result == -1) {\n    allocatedPath = (char *)0x0;\n    free(lastSlash);\n  }\n  else {\n    *fileDescriptor = result;\n    allocatedPath = lastSlash;\n  }\n  returnValue._8_8_ = unknown2;\n  returnValue._0_8_ = allocatedPath;\n  return returnValue;\n}\n\n",
            "called": [
                "xmalloc",
                "strrchr",
                "mkstemp",
                "make_tempname.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001057a0",
            "calling": [
                "ar_open",
                "write_archive"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_file_001057a0"
        },
        "FUN_00102550": {
            "renaming": {},
            "code": "\n\n\nchar * strerror(int __errnum)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strerror(__errnum);\n  return pcVar1;\n}\n\n",
            "called": [
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102550",
            "calling": [
                "ar_open",
                "print_contents",
                "set_times.cold",
                "get_file_size.cold",
                "smart_rename.constprop.0.cold",
                "extract_file.cold"
            ],
            "imported": false,
            "current_name": "FUN_00102550"
        },
        "FUN_00102310": {
            "renaming": {},
            "code": "\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = fprintf(__stream,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102310",
            "calling": [
                "report",
                "open_inarch",
                "bfd_nonfatal.cold",
                "list_supported_targets",
                "ar_emul_default_usage",
                "main",
                "yyparse.isra.0",
                "map_over_list",
                "ar_open",
                "list_matching_formats",
                "map_over_members.cold",
                "print_arelt_descr.cold",
                "yy_fatal_error",
                "ranlib_usage",
                "usage"
            ],
            "imported": false,
            "current_name": "FUN_00102310"
        },
        "FUN_00102430": {
            "renaming": {},
            "code": "\n\n\nint chmod(char *__file,__mode_t __mode)\n\n{\n  int iVar1;\n  \n  iVar1 = chmod(__file,__mode);\n  return iVar1;\n}\n\n",
            "called": [
                "chmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102430",
            "calling": [
                "extract_file.cold"
            ],
            "imported": false,
            "current_name": "FUN_00102430"
        },
        "FUN_0010e0f8": {
            "renaming": {},
            "code": "\n\n\n\nint dup(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* dup@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0f8",
            "calling": [
                "dup"
            ],
            "imported": false,
            "current_name": "FUN_0010e0f8"
        },
        "FUN_00107c10": {
            "renaming": {
                "FUN_00107c10": "terminate_program_00107c10",
                "bfd_nonfatal": "handleNonFatalErrors",
                "xexit": "exitCode"
            },
            "code": "\nvoid terminateProgram_00107c10(void)\n\n{\n  handleNonFatalErrors();\n                    \n  exitCode(1);\n}\n\n",
            "called": [
                "xexit",
                "bfd_nonfatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c10",
            "calling": [
                "open_inarch",
                "write_archive",
                "replace_members.cold",
                "write_archive.cold",
                "main"
            ],
            "imported": false,
            "current_name": "terminate_program_00107c10"
        },
        "FUN_001023c0": {
            "renaming": {},
            "code": "\n\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fflush(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023c0",
            "calling": [
                "report",
                "list_matching_formats",
                "prompt",
                "bfd_nonfatal.cold"
            ],
            "imported": false,
            "current_name": "FUN_001023c0"
        },
        "FUN_0010e0f0": {
            "renaming": {},
            "code": "\n\n\n\nchar * strrchr(char *__s,int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strrchr@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0f0",
            "calling": [
                "strrchr"
            ],
            "imported": false,
            "current_name": "FUN_0010e0f0"
        },
        "FUN_001024e0": {
            "renaming": {},
            "code": "\nvoid bfd_find_target(void)\n\n{\n  bfd_find_target();\n  return;\n}\n\n",
            "called": [
                "bfd_find_target"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024e0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001024e0"
        },
        "FUN_001022a0": {
            "renaming": {},
            "code": "\nvoid bfd_create(void)\n\n{\n  bfd_create();\n  return;\n}\n\n",
            "called": [
                "bfd_create"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022a0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001022a0"
        },
        "FUN_00107cc0": {
            "renaming": {
                "FUN_00107cc0": "execute_exit_handlers_00107cc0",
                "plVar4": "exitHandler",
                "uVar5": "index",
                "lVar1": "currentIndex",
                "lVar2": "previousIndex",
                "lVar3": "tempIndex"
            },
            "code": "\nvoid executeExitHandlers_00107cc0(void)\n\n{\n  long currentIndex;\n  long previousIndex;\n  long tempIndex;\n  long *exitHandler;\n  uint index;\n  \n  exitHandler = (long *)xatexit_head;\n  if (xatexit_head != (undefined *)0x0) {\n    do {\n      index = *(int *)(exitHandler + 1) - 1;\n      if (-1 < (int)index) {\n        currentIndex = (long)(int)index;\n        index = index & 7;\n        (*(code *)exitHandler[currentIndex + 2])();\n        previousIndex = currentIndex + -1;\n        if (-1 < (int)previousIndex) {\n          tempIndex = previousIndex;\n          if (index != 0) {\n            if (index != 1) {\n              if (index != 2) {\n                if (index != 3) {\n                  if (index != 4) {\n                    if (index != 5) {\n                      if (index != 6) {\n                        (*(code *)exitHandler[currentIndex + 1])();\n                        previousIndex = currentIndex + -2;\n                      }\n                      (*(code *)exitHandler[previousIndex + 2])();\n                      previousIndex = previousIndex + -1;\n                    }\n                    (*(code *)exitHandler[previousIndex + 2])();\n                    previousIndex = previousIndex + -1;\n                  }\n                  (*(code *)exitHandler[previousIndex + 2])();\n                  previousIndex = previousIndex + -1;\n                }\n                (*(code *)exitHandler[previousIndex + 2])();\n                previousIndex = previousIndex + -1;\n              }\n              (*(code *)exitHandler[previousIndex + 2])();\n              previousIndex = previousIndex + -1;\n            }\n            (*(code *)exitHandler[previousIndex + 2])();\n            tempIndex = previousIndex + -1;\n            if ((int)(previousIndex + -1) < 0) goto LAB_00107d96;\n          }\n          do {\n            (*(code *)exitHandler[tempIndex + 2])();\n            currentIndex = tempIndex + -1;\n            (*(code *)exitHandler[tempIndex + 1])();\n            (*(code *)exitHandler[tempIndex])();\n            (*(code *)exitHandler[currentIndex])();\n            (*(code *)exitHandler[tempIndex + -2])();\n            (*(code *)exitHandler[tempIndex + -3])();\n            (*(code *)exitHandler[tempIndex + -4])();\n            (*(code *)exitHandler[tempIndex + -5])();\n            tempIndex = tempIndex + -8;\n          } while (-1 < (int)currentIndex + -7);\n        }\n      }\nLAB_00107d96:\n      exitHandler = (long *)*exitHandler;\n    } while (exitHandler != (long *)0x0);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107cc0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "execute_exit_handlers_00107cc0"
        },
        "FUN_0010e288": {
            "renaming": {},
            "code": "\n\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* vfprintf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e288",
            "calling": [
                "vfprintf"
            ],
            "imported": false,
            "current_name": "FUN_0010e288"
        },
        "FUN_00105ae0": {
            "renaming": {
                "FUN_00105ae0": "append_const_property_00105ae0",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4"
            },
            "code": "\nvoid appendConstProperty_00105ae0(undefined8 param1,undefined8 param2,undefined param3,undefined param4)\n\n{\n  do_ar_emul_append_constprop_0(param1,param2,param3,param4);\n  return;\n}\n\n",
            "called": [
                "do_ar_emul_append.constprop.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105ae0",
            "calling": [
                "replace_members.cold"
            ],
            "imported": false,
            "current_name": "append_const_property_00105ae0"
        },
        "FUN_00107690": {
            "renaming": {
                "FUN_00107690": "report_and_exit_00107690",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4",
                "param_5": "arg5",
                "param_6": "arg6",
                "param_7": "arg7",
                "param_8": "arg8",
                "param_9": "param1",
                "param_10": "param2",
                "param_11": "param3",
                "param_12": "param4",
                "param_13": "param5",
                "param_14": "param6",
                "in_AL": "flag",
                "local_d8": "size",
                "local_d4": "length",
                "local_d0": "buffer",
                "local_c8": "destination",
                "local_b8": "localArray",
                "local_b0": "param2_copy",
                "local_a8": "param3_copy",
                "local_a0": "param4_copy",
                "local_98": "param5_copy",
                "local_90": "param6_copy",
                "local_88": "arg1_copy",
                "local_78": "arg2_copy",
                "local_68": "arg3_copy",
                "local_58": "arg4_copy",
                "local_48": "arg5_copy",
                "local_38": "arg6_copy",
                "local_28": "arg7_copy",
                "local_18": "arg8_copy"
            },
            "code": "\nvoid reportAndExit_00107690(undefined4 arg1,undefined4 arg2,undefined4 arg3,undefined4 arg4,\n                 undefined4 arg5,undefined4 arg6,undefined4 arg7,undefined4 arg8,\n                 undefined8 param1,undefined8 param2,undefined8 param3,undefined8 param4,\n                 undefined8 param5,undefined8 param6)\n\n{\n  char flag;\n  undefined4 size;\n  undefined4 length;\n  undefined *buffer;\n  undefined *destination;\n  undefined localArray [8];\n  undefined8 param2_copy;\n  undefined8 param3_copy;\n  undefined8 param4_copy;\n  undefined8 param5_copy;\n  undefined8 param6_copy;\n  undefined4 arg1_copy;\n  undefined4 arg2_copy;\n  undefined4 arg3_copy;\n  undefined4 arg4_copy;\n  undefined4 arg5_copy;\n  undefined4 arg6_copy;\n  undefined4 arg7_copy;\n  undefined4 arg8_copy;\n  \n  if (flag != '\\0') {\n    arg1_copy = arg1;\n    arg2_copy = arg2;\n    arg3_copy = arg3;\n    arg4_copy = arg4;\n    arg5_copy = arg5;\n    arg6_copy = arg6;\n    arg7_copy = arg7;\n    arg8_copy = arg8;\n  }\n  buffer = &stack0x00000008;\n  size = 8;\n  destination = localArray;\n  length = 0x30;\n  param2_copy = param2;\n  param3_copy = param3;\n  param4_copy = param4;\n  param5_copy = param5;\n  param6_copy = param6;\n  report(param1,&size);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "xexit",
                "report"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107690",
            "calling": [
                "open_inarch",
                "print_contents",
                "replace_members.cold",
                "extract_file.cold",
                "main"
            ],
            "imported": false,
            "current_name": "report_and_exit_00107690"
        },
        "FUN_0010266f": {
            "renaming": {
                "FUN_0010266f": "print_supported_targets_0010266f",
                "param_1": "target",
                "param_2": "outputFile",
                "lVar1": "currentTarget",
                "pcVar2": "formatString",
                "__ptr": "targetList",
                "plVar3": "ptr"
            },
            "code": "\nvoid printSupportedTargets_0010266f(long target,FILE *outputFile)\n\n{\n  long currentTarget;\n  char *formatString;\n  long *targetList;\n  long *ptr;\n  \n  if (target == 0) {\n    formatString = (char *)dcgettext(0,\"Supported targets:\",5);\n    fprintf(outputFile,formatString);\n  }\n  else {\n    formatString = (char *)dcgettext(0,\"%s: supported targets:\",5);\n    fprintf(outputFile,formatString,target);\n  }\n  targetList = (long *)bfd_target_list();\n  ptr = targetList;\n  while( true ) {\n    currentTarget = *ptr;\n    ptr = ptr + 1;\n    if (currentTarget == 0) break;\n    fprintf(outputFile,\" %s\");\n  }\n  fputc(10,outputFile);\n  free(targetList);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fputc",
                "free",
                "dcgettext",
                "bfd_target_list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010266f",
            "calling": [
                "ranlib_usage",
                "usage"
            ],
            "imported": false,
            "current_name": "print_supported_targets_0010266f"
        },
        "FUN_00102440": {
            "renaming": {},
            "code": "\nvoid bfd_set_error_program_name(void)\n\n{\n  bfd_set_error_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102440",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102440"
        },
        "FUN_0010e280": {
            "renaming": {},
            "code": "\n\n\n\nvoid perror(char *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* perror@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e280",
            "calling": [
                "perror"
            ],
            "imported": false,
            "current_name": "FUN_0010e280"
        },
        "FUN_00102560": {
            "renaming": {},
            "code": "\n\n\nint getc(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = getc(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102560",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102560"
        },
        "FUN_00105830": {
            "renaming": {
                "FUN_00105830": "extract_basename_00105830",
                "param_1": "input_path",
                "param_2": "info_ptr",
                "param_3": "unused_ptr1",
                "param_4": "unused_ptr2",
                "__s": "basename",
                "uVar3": "basename_length",
                "pcVar4": "output_path",
                "bVar5": "is_negative",
                "auVar6": "result"
            },
            "code": "\nundefined  [16] extract_basename_00105830(char *input_path,long info_ptr,undefined8 unused_ptr1,undefined8 unused_ptr2)\n\n{\n  long lVar1;\n  size_t sVar2;\n  char *basename;\n  ulong basename_length;\n  char *output_path;\n  byte is_negative;\n  undefined result [16];\n  \n  is_negative = 0;\n  if (full_pathname == '\\0') {\n    basename = (char *)lbasename();\n    input_path = basename;\n    if ((ar_truncate != '\\0') && (info_ptr != 0)) {\n      sVar2 = strlen(basename);\n      basename_length = (ulong)*(byte *)(*(long *)(info_ptr + 8) + 0x1e);\n      if (basename_length < sVar2) {\n        input_path = (char *)xmalloc(basename_length + 1);\n        lVar1 = *(long *)(info_ptr + 8);\n        output_path = input_path;\n        for (basename_length = (ulong)*(byte *)(lVar1 + 0x1e); basename_length != 0; basename_length = basename_length - 1) {\n          *output_path = *basename;\n          basename = basename + (ulong)is_negative * -2 + 1;\n          output_path = output_path + (ulong)is_negative * -2 + 1;\n        }\n        input_path[*(byte *)(lVar1 + 0x1e)] = '\\0';\n      }\n    }\n  }\n  result._8_8_ = unused_ptr2;\n  result._0_8_ = input_path;\n  return result;\n}\n\n",
            "called": [
                "normalize.cold",
                "lbasename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105830",
            "calling": [
                "replace_members.cold",
                "map_over_members",
                "main"
            ],
            "imported": false,
            "current_name": "extract_basename_00105830"
        },
        "FUN_0010e160": {
            "renaming": {},
            "code": "\n\n\n\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* read@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e160",
            "calling": [
                "read"
            ],
            "imported": false,
            "current_name": "FUN_0010e160"
        },
        "FUN_00102200": {
            "renaming": {},
            "code": "\nvoid concat(void)\n\n{\n  concat();\n  return;\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102200",
            "calling": [
                "FUN_00105a68",
                "open_output_file.isra.0.cold"
            ],
            "imported": false,
            "current_name": "FUN_00102200"
        },
        "FUN_00102320": {
            "renaming": {},
            "code": "\n\n\nlong ftell(FILE *__stream)\n\n{\n  long lVar1;\n  \n  lVar1 = ftell(__stream);\n  return lVar1;\n}\n\n",
            "called": [
                "ftell"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102320",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102320"
        },
        "FUN_00107c20": {
            "renaming": {
                "FUN_00107c20": "print_error_message_00107c20",
                "param_1": "errorDescription",
                "iVar1": "error",
                "uVar2": "errorMessage",
                "in_R10": "undefinedArg",
                "_stdout": "stdout",
                "_stderr": "stderr",
                "program_name": "applicationName"
            },
            "code": "\n\n\nvoid printErrorMessage_00107c20(long errorDescription)\n\n{\n  int error;\n  undefined8 errorMessage;\n  undefined8 undefinedArg;\n  \n  error = bfd_get_error();\n  if (error == 0) {\n    errorMessage = dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    errorMessage = bfd_errmsg(error);\n  }\n  fflush(stdout);\n  if (errorDescription != 0) {\n    fprintf(stderr,\"%s: %s: %s\\n\",applicationName,errorDescription,errorMessage,undefinedArg);\n    return;\n  }\n  fprintf(stderr,\"%s: %s\\n\",applicationName,errorMessage,undefinedArg);\n  return;\n}\n\n",
            "called": [
                "bfd_nonfatal.cold",
                "bfd_get_error",
                "bfd_errmsg"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c20",
            "calling": [
                "open_inarch",
                "bfd_fatal",
                "main"
            ],
            "imported": false,
            "current_name": "print_error_message_00107c20"
        },
        "FUN_001022b0": {
            "renaming": {},
            "code": "\nvoid bfd_init(void)\n\n{\n  bfd_init();\n  return;\n}\n\n",
            "called": [
                "bfd_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022b0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001022b0"
        },
        "FUN_001023d0": {
            "renaming": {},
            "code": "\nvoid unlink_if_ordinary(void)\n\n{\n  unlink_if_ordinary();\n  return;\n}\n\n",
            "called": [
                "unlink_if_ordinary"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023d0",
            "calling": [
                "remove_output.cold"
            ],
            "imported": false,
            "current_name": "FUN_001023d0"
        },
        "FUN_001024f0": {
            "renaming": {},
            "code": "\n\n\nint sprintf(char *__s,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = sprintf(__s,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024f0",
            "calling": [
                "print_arelt_descr.cold",
                "print_arelt_descr"
            ],
            "imported": false,
            "current_name": "FUN_001024f0"
        },
        "FUN_00102e57": {
            "renaming": {
                "FUN_00102e57": "initialize_output_file_00102e57",
                "pFVar1": "outputFilePointer",
                "output_filename": "outputFilename"
            },
            "code": "\nvoid initializeOutputFile_00102e57(void)\n\n{\n  FILE *outputFilePointer;\n  \n  outputFilename = (char *)concat();\n  if (verbose != 0) {\n    printf(\"x - %s\\n\",outputFilename);\n  }\n  outputFilePointer = fopen(outputFilename,\"w\");\n  if (outputFilePointer != (FILE *)0x0) {\n    return;\n  }\n  perror(outputFilename);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102e57",
            "calling": [
                "FUN_00105a68"
            ],
            "imported": false,
            "current_name": "initialize_output_file_00102e57"
        },
        "FUN_0010e058": {
            "renaming": {},
            "code": "\n\n\n\nint ferror(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ferror@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e058",
            "calling": [
                "ferror"
            ],
            "imported": false,
            "current_name": "FUN_0010e058"
        },
        "FUN_00105af0": {
            "renaming": {
                "FUN_00105af0": "process_files_00105af0",
                "param_1": "file_list",
                "param_2": "current_file",
                "param_3": "flag1",
                "param_4": "flag2",
                "cVar1": "is_bfd_valid",
                "uVar2": "result",
                "lVar3": "archived_file",
                "uVar4": "return_value"
            },
            "code": "\nulong process_files_00105af0(long *file_list,long current_file,char flag1,char flag2)\n\n{\n  char is_bfd_valid;\n  uint result;\n  long archived_file;\n  ulong return_value;\n  \n  if (flag2 == '\\0') {\n    if (flag1 != '\\0') {\n      return_value = do_ar_emul_append_constprop_0_cold();\n      return return_value;\n    }\n  }\n  else {\n    is_bfd_valid = bfd_check_format(current_file,2);\n    if (is_bfd_valid != '\\0') {\n      return_value = 0;\n      for (archived_file = bfd_openr_next_archived_file(current_file,0); archived_file != 0;\n          archived_file = bfd_openr_next_archived_file(current_file,archived_file)) {\n        result = process_files_00105af0(file_list,archived_file,flag1,1);\n        if ((char)result != '\\0') {\n          return_value = (ulong)result;\n          file_list = (long *)(*file_list + 0xf0);\n        }\n      }\n      return return_value;\n    }\n    if (flag1 != '\\0') {\n      return_value = do_ar_emul_append_constprop_0_cold();\n      return return_value;\n    }\n  }\n  *(long *)(current_file + 0xf0) = *file_list;\n  *file_list = current_file;\n  return 1;\n}\n\n",
            "called": [
                "do_ar_emul_append.constprop.0.cold",
                "bfd_openr_next_archived_file",
                "do_ar_emul_append.constprop.0",
                "bfd_check_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105af0",
            "calling": [
                "ar_emul_default_append",
                "do_ar_emul_append.constprop.0",
                "replace_members.cold"
            ],
            "imported": false,
            "current_name": "process_files_00105af0"
        },
        "FUN_00102330": {
            "renaming": {},
            "code": "\n\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = stat(__file,__buf);\n  return iVar1;\n}\n\n",
            "called": [
                "stat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102330",
            "calling": [
                "open_inarch",
                "replace_members.cold",
                "get_file_size",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102330"
        },
        "FUN_00102450": {
            "renaming": {},
            "code": "\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memmove(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102450",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102450"
        },
        "FUN_00102ba1": {
            "renaming": {
                "FUN_00102ba1": "deallocate_memory_00102ba1",
                "unaff_RBP": "memory_address",
                "unaff_retaddr": "return_address",
                "auVar1": "result"
            },
            "code": "\nundefined  [16] deallocate_memory_00102ba1(void)\n\n{\n  undefined result [16];\n  void *memory_address;\n  ulong return_address;\n  \n  free(memory_address);\n  result._8_8_ = 0;\n  result._0_8_ = return_address;\n  return result << 0x40;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102ba1",
            "calling": [
                "make_tempname"
            ],
            "imported": false,
            "current_name": "deallocate_memory_00102ba1"
        },
        "FUN_00102210": {
            "renaming": {},
            "code": "\nvoid bfd_target_list(void)\n\n{\n  bfd_target_list();\n  return;\n}\n\n",
            "called": [
                "bfd_target_list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102210",
            "calling": [
                "list_supported_targets"
            ],
            "imported": false,
            "current_name": "FUN_00102210"
        },
        "FUN_00102570": {
            "renaming": {},
            "code": "\nvoid bfd_fdopenw(void)\n\n{\n  bfd_fdopenw();\n  return;\n}\n\n",
            "called": [
                "bfd_fdopenw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102570",
            "calling": [
                "ar_open",
                "write_archive"
            ],
            "imported": false,
            "current_name": "FUN_00102570"
        },
        "FUN_00102d2f": {
            "renaming": {
                "FUN_00102d2f": "print_file_attributes_00102d2f",
                "unaff_RBX": "fileMetadata",
                "unaff_RBP": "outputFile",
                "unaff_R12": "fileMode",
                "unaff_R13": "allocatedMemory",
                "unaff_R14D": "fileDescriptor",
                "uStack0000000000000015": "fileType",
                "cStack0000000000000016": "isReadable",
                "cStack0000000000000017": "isWritable",
                "in_stack_00000018": "isExecutable",
                "cStack0000000000000019": "isArchived",
                "cStack000000000000001a": "isPubliclyReadable",
                "cStack000000000000001b": "isSharedLibrary",
                "cStack000000000000001c": "isSUID",
                "cStack000000000000001d": "isSGID",
                "cStack000000000000001e": "isSticky",
                "uStack0000000000000068": "filePermissions",
                "uStack000000000000006c": "numHardLinks",
                "in_stack_00000070": "fileSize",
                "in_stack_00000080": "timestamp",
                "stack0x00000020": "fileName",
                "__format": "formatString",
                "uVar4": "fileTypeMask",
                "unaff_RBX[0xb]": "arIndex",
                "unaff_RBX[0xc]": "thinArIndex"
            },
            "code": "\nvoid printFileAttributes_00102d2f(void)\n\n{\n  byte bVar1;\n  char cVar2;\n  int iVar3;\n  char *formatString;\n  uint fileTypeMask;\n  char **fileMetadata;\n  FILE *outputFile;\n  long fileMode;\n  void *allocatedMemory;\n  int fileDescriptor;\n  undefined fileType;\n  char isReadable;\n  char isWritable;\n  char isExecutable;\n  char isArchived;\n  char isPubliclyReadable;\n  char isSharedLibrary;\n  char isSUID;\n  char isSGID;\n  char isSticky;\n  undefined uStack000000000000001f;\n  uint filePermissions;\n  uint numHardLinks;\n  uint fileSize;\n  undefined8 timestamp;\n  \n  do {\n    bVar1 = bfd_fatal();\n    *(uint *)((long)fileMetadata + 0x44) = *(uint *)((long)fileMetadata + 0x44) | 0x100000;\n    if ((make_thin_archive != '\\0') || ((*(byte *)(fileMode + 0x49) & 0x10) != 0)) {\n      *(byte *)((long)fileMetadata + 0x49) = bVar1 | 0x10;\n    }\n    cVar2 = bfd_set_archive_head();\n  } while (cVar2 == '\\0');\n  dup(fileDescriptor);\n  cVar2 = bfd_close();\n  if (cVar2 != '\\0') {\n    output_bfd = 0;\n    output_filename = 0;\n    bfd_close();\n    iVar3 = smart_rename_constprop_0();\n    if (iVar3 == 0) {\n      free(allocatedMemory);\n      free(outputFile);\n      return;\n    }\n                    \n    xexit(1);\n  }\n  bfd_fatal();\n  formatString = (char *)dcgettext(0,\"<time data corrupt>\",5);\n  sprintf(&fileName,formatString);\n  fileTypeMask = filePermissions & 0xf000;\n  if (fileTypeMask == 0x4000) {\n    fileType = 100;\n  }\n  else if (fileTypeMask == 0xa000) {\n    fileType = 0x6c;\n  }\n  else if (fileTypeMask == 0x6000) {\n    fileType = 0x62;\n  }\n  else if (fileTypeMask == 0x2000) {\n    fileType = 99;\n  }\n  else if (fileTypeMask == 0xc000) {\n    fileType = 0x73;\n  }\n  else {\n    fileType = 0x70;\n    if (fileTypeMask != 0x1000) {\n      fileType = 0x2d;\n    }\n  }\n  isReadable = (-((filePermissions & 0x100) == 0) & 0xbbU) + 0x72;\n  isWritable = (-((filePermissions & 0x80) == 0) & 0xb6U) + 0x77;\n  isExecutable = (-((filePermissions & 0x40) == 0) & 0xb5U) + 0x78;\n  isArchived = (-((filePermissions & 0x20) == 0) & 0xbbU) + 0x72;\n  isPubliclyReadable = (-((filePermissions & 0x10) == 0) & 0xb6U) + 0x77;\n  isSharedLibrary = (-((filePermissions & 8) == 0) & 0xb5U) + 0x78;\n  isSUID = (-((filePermissions & 4) == 0) & 0xbbU) + 0x72;\n  isSGID = (-((filePermissions & 2) == 0) & 0xb6U) + 0x77;\n  isSticky = (-((filePermissions & 1) == 0) & 0xb5U) + 0x78;\n  if ((filePermissions & 0x800) != 0) {\n    if (isExecutable == 'x') {\n      isExecutable = 's';\n    }\n    else {\n      isExecutable = 'S';\n    }\n  }\n  if ((filePermissions & 0x400) != 0) {\n    if (isSharedLibrary == 'x') {\n      isSharedLibrary = 's';\n    }\n    else {\n      isSharedLibrary = 'S';\n    }\n  }\n  if ((filePermissions & 0x200) != 0) {\n    if (isSticky == 'x') {\n      isSticky = 't';\n    }\n    else {\n      isSticky = 'T';\n    }\n  }\n  uStack000000000000001f = 0;\n  fprintf(outputFile,\"%s %ld/%ld %6lu %s \",&stack0x00000016,(ulong)numHardLinks,\n          (ulong)fileSize,timestamp,&fileName,(ulong)filePermissions)\n  ;\n  fputs(*fileMetadata,outputFile);\n  if ((char)fileMode != '\\0') {\n    if ((*(byte *)((long)fileMetadata + 0x49) & 0x10) == 0) {\n      if (arIndex != (char *)0x0) {\n        fprintf(outputFile,\" 0x%lx\");\n      }\n    }\n    else if (thinArIndex != (char *)0x0) {\n      fprintf(outputFile,\" 0x%lx\");\n    }\n  }\n  fputc(10,outputFile);\n  return;\n}\n\n",
            "called": [
                "xexit",
                "bfd_fatal",
                "dup",
                "smart_rename.constprop.0",
                "bfd_close",
                "bfd_set_archive_head",
                "free",
                "write_archive.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102d2f",
            "calling": [
                "write_archive.cold"
            ],
            "imported": false,
            "current_name": "print_file_attributes_00102d2f"
        },
        "FUN_001021a0": {
            "renaming": {},
            "code": "\n\n\nint printf(char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = printf(__format);\n  return iVar1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021a0",
            "calling": [
                "do_ar_emul_append.constprop.0.cold",
                "ar_emul_default_replace",
                "print_contents",
                "prompt",
                "FUN_00105a68",
                "yyerror.constprop.0",
                "print_version",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_001021a0"
        },
        "FUN_001033b0": {
            "renaming": {
                "FUN_001033b0": "print_and_exit_001033b0",
                "param_1": "errorMessage"
            },
            "code": "\n\n\nvoid printAndExit_001033b0(undefined8 errorMessage)\n\n{\n  fprintf(_stderr,\"%s\\n\",errorMessage);\n                    \n  exit(2);\n}\n\n",
            "called": [
                "exit",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001033b0",
            "calling": [
                "yy_create_buffer.constprop.0",
                "yyensure_buffer_stack",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "print_and_exit_001033b0"
        },
        "FUN_001022c0": {
            "renaming": {},
            "code": "\nvoid lbasename(void)\n\n{\n  lbasename();\n  return;\n}\n\n",
            "called": [
                "lbasename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022c0",
            "calling": [
                "replace_members.cold",
                "normalize",
                "main",
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "FUN_001022c0"
        },
        "FUN_001023e0": {
            "renaming": {},
            "code": "\n\n\nint mkstemp(char *__template)\n\n{\n  int iVar1;\n  \n  iVar1 = mkstemp(__template);\n  return iVar1;\n}\n\n",
            "called": [
                "mkstemp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023e0",
            "calling": [
                "make_tempname"
            ],
            "imported": false,
            "current_name": "FUN_001023e0"
        },
        "FUN_00102c25": {
            "renaming": {
                "FUN_00102c25": "extract_and_write_archive_contents_00102c25",
                "param_7": "error_codes",
                "param_11": "file_permissions",
                "param_12": "archive_size",
                "iVar1": "comparison_result",
                "iVar2": "status_code",
                "piVar3": "errno_location_ptr",
                "pcVar4": "error_message",
                "uVar5": "translated_string",
                "pplVar6": "archive_ptr",
                "__ptr": "buffer_ptr",
                "__n": "bytes_read",
                "lVar7": "loop_counter",
                "unaff_RBX": "input_arguments",
                "plVar8": "current_position",
                "puVar9": "pointer",
                "uVar10": "bytes_processed",
                "sVar11": "bytes_to_process",
                "output_file": "output_file_ptr",
                "output_filename": "output_filename_ptr",
                "preserve_dates": "preserve_dates_flag"
            },
            "code": "\nlong * extract_and_write_archive_contents_00102c25(void)\n\n{\n  int comparison_result;\n  int status_code;\n  int *errno_location_ptr;\n  char *error_message;\n  undefined8 translated_string;\n  long **archive_ptr;\n  void *buffer_ptr;\n  size_t bytes_read;\n  long loop_counter;\n  long **input_arguments;\n  long *current_position;\n  undefined4 *pointer;\n  ulong bytes_processed;\n  size_t bytes_to_process;\n  undefined4 *error_codes;\n  __mode_t file_permissions;\n  ulong archive_size;\n  \n  pointer = error_codes;\n  for (loop_counter = 0x24; loop_counter != 0; loop_counter = loop_counter + -1) {\n    *pointer = 0;\n    pointer = pointer + 1;\n  }\n  archive_ptr = (long **)input_arguments[0x1d];\n  if ((long **)input_arguments[0x1d] == (long **)0x0) {\n    archive_ptr = input_arguments;\n  }\n  status_code = (*(code *)archive_ptr[1][0x3d])();\n  if (status_code != 0) {\n    current_position = *input_arguments;\n    translated_string = dcgettext(0,\"internal stat error on %s\",5);\n    status_code = fatal(translated_string,current_position);\n    translated_string = posname;\n    if (status_code == 3) {\n      for (; *current_position != 0; current_position = (long *)(*current_position + 0xf0)) {\n      }\n    }\n    else {\n      for (; (undefined8 *)*current_position != (undefined8 *)0x0; current_position = (long *)(*current_position + 0xf0)) {\n        comparison_result = filename_cmp(*(undefined8 *)*current_position,translated_string);\n        if (comparison_result == 0) {\n          if (status_code != 2) {\n            return current_position;\n          }\n          return (long *)(*current_position + 0xf0);\n        }\n      }\n    }\n    return current_position;\n  }\n  bfd_seek();\n  output_file_ptr = (FILE *)0x0;\n  if (archive_size == 0) {\nLAB_00102ca2:\n    output_file_ptr = (FILE *)open_output_file_ptr_isra_0(*input_arguments);\n  }\n  else {\n    bytes_processed = 0;\n    buffer_ptr = (void *)xmalloc(0x2000);\n    do {\n      bytes_to_process = archive_size - bytes_processed;\n      if (0x2000 < bytes_to_process) {\n        bytes_to_process = 0x2000;\n      }\n      bytes_read = bfd_bread(buffer_ptr,bytes_to_process);\n      if (bytes_to_process != bytes_read) {\nLAB_00102c78:\n        input_arguments = (long **)*input_arguments[0x1d];\n        translated_string = dcgettext(0,\"%s is not a valid archive\",5);\n        fatal(translated_string,input_arguments);\n        goto LAB_00102ca2;\n      }\n      if (output_file_ptr == (FILE *)0x0) {\n        output_file_ptr = (FILE *)open_output_file_ptr_isra_0(*input_arguments);\n      }\n      bytes_to_process = fwrite(buffer_ptr,1,bytes_read,output_file_ptr);\n      if (bytes_to_process != bytes_read) {\n        errno_location_ptr = __errno_location();\n        error_message = strerror(*errno_location_ptr);\n        fatal(\"%s: %s\",output_filename_ptr,error_message);\n        goto LAB_00102c78;\n      }\n      bytes_processed = bytes_processed + bytes_read;\n    } while (bytes_processed < archive_size);\n    free(buffer_ptr);\n  }\n  fclose(output_file_ptr);\n  error_message = output_filename_ptr;\n  output_file_ptr = (FILE *)0x0;\n  chmod(output_filename_ptr,file_permissions);\n  if (preserve_dates_flag != 0) {\n    set_times(error_message,error_codes);\n  }\n  output_filename_ptr = (char *)0x0;\n  return (long *)0x0;\n}\n\n",
            "called": [
                "open_output_file.isra.0",
                "strerror",
                "fclose",
                "set_times",
                "dcgettext",
                "bfd_bread",
                "chmod",
                "fwrite",
                "fatal",
                "xmalloc",
                "bfd_seek",
                "__errno_location",
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102c25",
            "calling": [
                "extract_file"
            ],
            "imported": false,
            "current_name": "extract_and_write_archive_contents_00102c25"
        },
        "FUN_0010e188": {
            "renaming": {},
            "code": "\n\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcmp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e188",
            "calling": [
                "strcmp"
            ],
            "imported": false,
            "current_name": "FUN_0010e188"
        },
        "FUN_00102220": {
            "renaming": {},
            "code": "\nvoid bfd_get_error(void)\n\n{\n  bfd_get_error();\n  return;\n}\n\n",
            "called": [
                "bfd_get_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102220",
            "calling": [
                "open_inarch",
                "bfd_nonfatal",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102220"
        },
        "FUN_00102bb0": {
            "renaming": {
                "FUN_00102bb0": "reverse_string_00102bb0",
                "in_RAX": "inputString",
                "sVar2": "stringLength",
                "puVar3": "reversedString",
                "uVar4": "maxIndex",
                "unaff_RBX": "sourceString",
                "unaff_RBP": "framePointer",
                "puVar5": "reversedStringPointer",
                "bVar6": "reverseDirection",
                "auVar7": "returnValue",
                "unaff_retaddr": "returnAddress"
            },
            "code": "\nundefined  [16] reverseString_00102bb0(void)\n\n{\n  long lVar1;\n  char *inputString;\n  size_t stringLength;\n  undefined *reversedString;\n  ulong maxIndex;\n  undefined *sourceString;\n  long framePointer;\n  undefined *reversedStringPointer;\n  byte reverseDirection;\n  undefined returnValue [16];\n  undefined8 returnAddress;\n  \n  reverseDirection = 0;\n  stringLength = strlen(inputString);\n  maxIndex = (ulong)*(byte *)(*(long *)(framePointer + 8) + 0x1e);\n  reversedString = sourceString;\n  if (maxIndex < stringLength) {\n    reversedString = (undefined *)xmalloc(maxIndex + 1);\n    lVar1 = *(long *)(framePointer + 8);\n    reversedStringPointer = reversedString;\n    for (maxIndex = (ulong)*(byte *)(lVar1 + 0x1e); maxIndex != 0; maxIndex = maxIndex - 1) {\n      *reversedStringPointer = *sourceString;\n      sourceString = sourceString + (ulong)reverseDirection * -2 + 1;\n      reversedStringPointer = reversedStringPointer + (ulong)reverseDirection * -2 + 1;\n    }\n    reversedString[*(byte *)(lVar1 + 0x1e)] = 0;\n  }\n  returnValue._8_8_ = returnAddress;\n  returnValue._0_8_ = reversedString;\n  return returnValue;\n}\n\n",
            "called": [
                "xmalloc",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102bb0",
            "calling": [
                "normalize"
            ],
            "imported": false,
            "current_name": "reverse_string_00102bb0"
        },
        "FUN_0010e060": {
            "renaming": {},
            "code": "\n\n\n\nint isatty(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* isatty@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e060",
            "calling": [
                "isatty"
            ],
            "imported": false,
            "current_name": "FUN_0010e060"
        },
        "FUN_00102340": {
            "renaming": {},
            "code": "\nvoid bfd_set_format(void)\n\n{\n  bfd_set_format();\n  return;\n}\n\n",
            "called": [
                "bfd_set_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102340",
            "calling": [
                "open_inarch",
                "ar_open",
                "write_archive",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102340"
        },
        "FUN_00102100": {
            "renaming": {},
            "code": "\nvoid filename_cmp(void)\n\n{\n  filename_cmp();\n  return;\n}\n\n",
            "called": [
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102100",
            "calling": [
                "map_over_list",
                "replace_members.cold",
                "map_over_members",
                "get_pos_bfd.cold",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102100"
        },
        "FUN_00102460": {
            "renaming": {},
            "code": "\n\n\nint open(char *__file,int __oflag,...)\n\n{\n  int iVar1;\n  \n  iVar1 = open(__file,__oflag);\n  return iVar1;\n}\n\n",
            "called": [
                "open"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102460",
            "calling": [
                "simple_copy.constprop.0",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102460"
        },
        "FUN_00102580": {
            "renaming": {},
            "code": "\nvoid bfd_seek(void)\n\n{\n  bfd_seek();\n  return;\n}\n\n",
            "called": [
                "bfd_seek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102580",
            "calling": [
                "print_contents",
                "extract_file.cold"
            ],
            "imported": false,
            "current_name": "FUN_00102580"
        },
        "FUN_0010e180": {
            "renaming": {},
            "code": "\n\n\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* calloc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e180",
            "calling": [
                "calloc"
            ],
            "imported": false,
            "current_name": "FUN_0010e180"
        }
    },
    "used_tokens": 74872,
    "layers": [
        [
            "FUN_00102cd9",
            "FUN_001079c0",
            "FUN_00105a68",
            "FUN_001032a8",
            "FUN_00102f96",
            "FUN_0010342d",
            "FUN_00107920",
            "FUN_001033d6",
            "FUN_00102000",
            "FUN_00105870",
            "FUN_00103ba8",
            "FUN_00103ddc",
            "FUN_001078c0",
            "FUN_001031a5",
            "FUN_00103df9",
            "FUN_00102bf5",
            "FUN_00102020",
            "FUN_00102943",
            "FUN_00107c80",
            "FUN_00102d8c",
            "FUN_00105300",
            "FUN_00105db0",
            "FUN_00103bd1",
            "FUN_00102710",
            "FUN_00103e95",
            "FUN_00107730",
            "FUN_001031cf",
            "FUN_0010312d",
            "FUN_00105c00",
            "FUN_001052a0",
            "FUN_0010336b",
            "FUN_00103c60",
            "FUN_0010300e",
            "FUN_00107740",
            "FUN_001028ed",
            "FUN_001025a0",
            "FUN_0010284b",
            "FUN_00105cc0",
            "FUN_00102f08",
            "FUN_0010285f",
            "FUN_0010394a",
            "FUN_00105bb0",
            "FUN_00107640",
            "FUN_0010315d",
            "FUN_00107890",
            "FUN_00103172",
            "FUN_001030ed",
            "FUN_00105bc0",
            "FUN_00107650",
            "FUN_00102f1e",
            "FUN_00102fd7",
            "FUN_00105d60",
            "FUN_001075e0",
            "FUN_00105480",
            "FUN_00103a78",
            "FUN_001058b0",
            "FUN_00105a20",
            "FUN_00102f55",
            "FUN_001057a0",
            "FUN_00107c10",
            "FUN_00107cc0",
            "FUN_00105ae0",
            "FUN_00107690",
            "FUN_0010266f",
            "FUN_00105830",
            "FUN_00107c20",
            "FUN_00102e57",
            "FUN_00102ba1",
            "FUN_00102d2f",
            "FUN_001033b0",
            "FUN_00102c25",
            "FUN_00102bb0"
        ],
        [
            "FUN_00102e6f",
            "FUN_00105570"
        ],
        [
            "FUN_00105af0"
        ]
    ],
    "locked_functions": []
}