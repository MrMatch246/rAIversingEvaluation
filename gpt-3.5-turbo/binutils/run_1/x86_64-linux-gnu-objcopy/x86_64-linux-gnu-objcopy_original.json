{
  "functions": {
    "_init": {
      "entrypoint": "0x00104000",
      "current_name": "_init",
      "code": "\nint _init(EVP_PKEY_CTX *ctx)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d __gmon_start__();\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__gmon_start__"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00104020": {
      "entrypoint": "0x00104020",
      "current_name": "FUN_00104020",
      "code": "\nvoid FUN_00104020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(undefined *)0x0)();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "mkstemps": {
      "entrypoint": "0x00128000",
      "current_name": "mkstemps",
      "code": "\n\n\n\nint mkstemps(char *__template,int __suffixlen)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mkstemps@GLIBC_2.11 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "mkstemps"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getenv": {
      "entrypoint": "0x00128008",
      "current_name": "getenv",
      "code": "\n\n\n\nchar * getenv(char *__name)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getenv@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "getenv"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "cplus_demangle_print": {
      "entrypoint": "0x00104050",
      "current_name": "cplus_demangle_print",
      "code": "\nvoid cplus_demangle_print(void)\n\n{\n  cplus_demangle_print();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_v3_arg"
      ],
      "called": [
        "cplus_demangle_print"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "utimensat": {
      "entrypoint": "0x00128018",
      "current_name": "utimensat",
      "code": "\n\n\n\nint utimensat(int __fd,char *__path,timespec *__times,int __flags)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* utimensat@GLIBC_2.6 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "utimensat"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_scan_vma": {
      "entrypoint": "0x00104070",
      "current_name": "bfd_scan_vma",
      "code": "\nvoid bfd_scan_vma(void)\n\n{\n  bfd_scan_vma();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_vma"
      ],
      "called": [
        "bfd_scan_vma"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strcasecmp": {
      "entrypoint": "0x00128030",
      "current_name": "strcasecmp",
      "code": "\n\n\n\nint strcasecmp(char *__s1,char *__s2)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcasecmp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strcasecmp"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "htab_delete": {
      "entrypoint": "0x00104090",
      "current_name": "htab_delete",
      "code": "\nvoid htab_delete(void)\n\n{\n  htab_delete();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "delete_symbol_htabs"
      ],
      "called": [
        "htab_delete"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "abort": {
      "entrypoint": "0x00128048",
      "current_name": "abort",
      "code": "\n\n\n\nvoid abort(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* abort@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "abort"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__errno_location": {
      "entrypoint": "0x00128050",
      "current_name": "__errno_location",
      "code": "\n\n\n\nint * __errno_location(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __errno_location@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "__errno_location"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "unlink": {
      "entrypoint": "0x00128058",
      "current_name": "unlink",
      "code": "\n\n\n\nint unlink(char *__name)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* unlink@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "unlink"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strncpy": {
      "entrypoint": "0x00128060",
      "current_name": "strncpy",
      "code": "\n\n\n\nchar * strncpy(char *__dest,char *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strncpy@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strncpy"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strncmp": {
      "entrypoint": "0x00128068",
      "current_name": "strncmp",
      "code": "\n\n\n\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strncmp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strncmp"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_convert_section_setup": {
      "entrypoint": "0x001040f0",
      "current_name": "bfd_convert_section_setup",
      "code": "\nvoid bfd_convert_section_setup(void)\n\n{\n  bfd_convert_section_setup();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup_section"
      ],
      "called": [
        "bfd_convert_section_setup"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strcpy": {
      "entrypoint": "0x00128088",
      "current_name": "strcpy",
      "code": "\n\n\n\nchar * strcpy(char *__dest,char *__src)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcpy@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strcpy"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_get_stab_name": {
      "entrypoint": "0x00104110",
      "current_name": "bfd_get_stab_name",
      "code": "\nvoid bfd_get_stab_name(void)\n\n{\n  bfd_get_stab_name();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_context"
      ],
      "called": [
        "bfd_get_stab_name"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_make_section_with_flags": {
      "entrypoint": "0x00104120",
      "current_name": "bfd_make_section_with_flags",
      "code": "\nvoid bfd_make_section_with_flags(void)\n\n{\n  bfd_make_section_with_flags();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107880",
        "FUN_0010554f"
      ],
      "called": [
        "bfd_make_section_with_flags"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ferror": {
      "entrypoint": "0x001280a0",
      "current_name": "ferror",
      "code": "\n\n\n\nint ferror(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ferror@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "ferror"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "qsort": {
      "entrypoint": "0x001280a8",
      "current_name": "qsort",
      "code": "\n\n\n\nvoid qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* qsort@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "qsort"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_default_target": {
      "entrypoint": "0x00104150",
      "current_name": "bfd_set_default_target",
      "code": "\nvoid bfd_set_default_target(void)\n\n{\n  bfd_set_default_target();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "bfd_set_default_target"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fread": {
      "entrypoint": "0x001280b8",
      "current_name": "fread",
      "code": "\n\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fread@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fread"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strtod": {
      "entrypoint": "0x001280c0",
      "current_name": "strtod",
      "code": "\n\n\n\ndouble strtod(char *__nptr,char **__endptr)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strtod@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strtod"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_create_gnu_debuglink_section": {
      "entrypoint": "0x00104180",
      "current_name": "bfd_create_gnu_debuglink_section",
      "code": "\nvoid bfd_create_gnu_debuglink_section(void)\n\n{\n  bfd_create_gnu_debuglink_section();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107880"
      ],
      "called": [
        "bfd_create_gnu_debuglink_section"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_make_section_anyway_with_flags": {
      "entrypoint": "0x00104190",
      "current_name": "bfd_make_section_anyway_with_flags",
      "code": "\nvoid bfd_make_section_anyway_with_flags(void)\n\n{\n  bfd_make_section_anyway_with_flags();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup_section"
      ],
      "called": [
        "bfd_make_section_anyway_with_flags"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "filename_cmp": {
      "entrypoint": "0x001041a0",
      "current_name": "filename_cmp",
      "code": "\nvoid filename_cmp(void)\n\n{\n  filename_cmp();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_start_source",
        "main",
        "stab_lineno.lto_priv.0"
      ],
      "called": [
        "filename_cmp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_stat": {
      "entrypoint": "0x001041b0",
      "current_name": "bfd_stat",
      "code": "\nvoid bfd_stat(void)\n\n{\n  bfd_stat();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_file"
      ],
      "called": [
        "bfd_stat"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "write": {
      "entrypoint": "0x001280e8",
      "current_name": "write",
      "code": "\n\n\n\nssize_t write(int __fd,void *__buf,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* write@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "write"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "textdomain": {
      "entrypoint": "0x001280f8",
      "current_name": "textdomain",
      "code": "\n\n\nvoid textdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* textdomain@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "textdomain"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_malloc_and_get_section": {
      "entrypoint": "0x001041e0",
      "current_name": "bfd_malloc_and_get_section",
      "code": "\nvoid bfd_malloc_and_get_section(void)\n\n{\n  bfd_malloc_and_get_section();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107880"
      ],
      "called": [
        "bfd_malloc_and_get_section"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_openr": {
      "entrypoint": "0x001041f0",
      "current_name": "bfd_openr",
      "code": "\nvoid bfd_openr(void)\n\n{\n  bfd_openr();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_file",
        "FUN_00104ea2"
      ],
      "called": [
        "bfd_openr"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_hash_newfunc": {
      "entrypoint": "0x00104200",
      "current_name": "bfd_hash_newfunc",
      "code": "\nvoid bfd_hash_newfunc(void)\n\n{\n  bfd_hash_newfunc();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "string_hash_newfunc.lto_priv.0"
      ],
      "called": [
        "bfd_hash_newfunc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fclose": {
      "entrypoint": "0x00128118",
      "current_name": "fclose",
      "code": "\n\n\n\nint fclose(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fclose@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fclose"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bindtextdomain": {
      "entrypoint": "0x00128128",
      "current_name": "bindtextdomain",
      "code": "\n\n\nvoid bindtextdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* bindtextdomain@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "bindtextdomain"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rmdir": {
      "entrypoint": "0x00128130",
      "current_name": "rmdir",
      "code": "\n\n\n\nint rmdir(char *__path)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* rmdir@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "rmdir"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "dcgettext": {
      "entrypoint": "0x00128138",
      "current_name": "dcgettext",
      "code": "\n\n\nvoid dcgettext(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* dcgettext@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "dcgettext"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_alloc": {
      "entrypoint": "0x00104250",
      "current_name": "bfd_alloc",
      "code": "\nvoid bfd_alloc(void)\n\n{\n  bfd_alloc();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_relocations_in_section"
      ],
      "called": [
        "bfd_alloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_get_section_contents": {
      "entrypoint": "0x00104260",
      "current_name": "bfd_get_section_contents",
      "code": "\nvoid bfd_get_section_contents(void)\n\n{\n  bfd_get_section_contents();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [
        "bfd_get_section_contents"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strlen": {
      "entrypoint": "0x00128150",
      "current_name": "strlen",
      "code": "\n\n\n\nsize_t strlen(char *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strlen@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strlen"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getopt_long": {
      "entrypoint": "0x00128158",
      "current_name": "getopt_long",
      "code": "\n\n\nvoid getopt_long(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getopt_long@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "getopt_long"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strchr": {
      "entrypoint": "0x00128160",
      "current_name": "strchr",
      "code": "\n\n\n\nchar * strchr(char *__s,int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strchr@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strchr"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "printf": {
      "entrypoint": "0x00128168",
      "current_name": "printf",
      "code": "\n\n\n\nint printf(char *__format,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* printf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "printf"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xrealloc": {
      "entrypoint": "0x001042b0",
      "current_name": "xrealloc",
      "code": "\nvoid xrealloc(void)\n\n{\n  xrealloc();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "do_display_target",
        "stab_modify_type",
        "stab_demangle_v3_arglist",
        "stab_get_struct_index",
        "stab_write_symbol.lto_priv.0",
        "main",
        "parse_stab_type",
        "parse_coff_type.lto_priv.0",
        "stab_demangle_remember_type",
        "stab_class_baseclass.lto_priv.0",
        "parse_stab",
        "FUN_00114dc7",
        "stab_demangle_arg",
        "parse_coff_struct_type",
        "stab_class_method_var",
        "stab_class_start_method.lto_priv.0"
      ],
      "called": [
        "xrealloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strrchr": {
      "entrypoint": "0x00128178",
      "current_name": "strrchr",
      "code": "\n\n\n\nchar * strrchr(char *__s,int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strrchr@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strrchr"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "dup": {
      "entrypoint": "0x00128180",
      "current_name": "dup",
      "code": "\n\n\n\nint dup(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* dup@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "dup"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "lseek": {
      "entrypoint": "0x00128188",
      "current_name": "lseek",
      "code": "\n\n\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* lseek@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "lseek"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_convert_section_contents": {
      "entrypoint": "0x001042f0",
      "current_name": "bfd_convert_section_contents",
      "code": "\nvoid bfd_convert_section_contents(void)\n\n{\n  bfd_convert_section_contents();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_section"
      ],
      "called": [
        "bfd_convert_section_contents"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__assert_fail": {
      "entrypoint": "0x00128198",
      "current_name": "__assert_fail",
      "code": "\n\n\n\nvoid __assert_fail(char *__assertion,char *__file,uint __line,char *__function)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __assert_fail@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "__assert_fail"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fputs": {
      "entrypoint": "0x001281a0",
      "current_name": "fputs",
      "code": "\n\n\n\nint fputs(char *__s,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fputs@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fputs"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "concat": {
      "entrypoint": "0x00104320",
      "current_name": "concat",
      "code": "\nvoid concat(void)\n\n{\n  concat();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_stab",
        "stab_demangle_template",
        "FUN_0010554f",
        "parse_stab_type",
        "FUN_00104ea2"
      ],
      "called": [
        "concat"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_section_contents": {
      "entrypoint": "0x00104330",
      "current_name": "bfd_set_section_contents",
      "code": "\nvoid bfd_set_section_contents(void)\n\n{\n  bfd_set_section_contents();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f",
        "copy_section"
      ],
      "called": [
        "bfd_set_section_contents"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fnmatch": {
      "entrypoint": "0x001281c0",
      "current_name": "fnmatch",
      "code": "\n\n\n\nint fnmatch(char *__pattern,char *__name,int __flags)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fnmatch@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fnmatch"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_target_list": {
      "entrypoint": "0x00104350",
      "current_name": "bfd_target_list",
      "code": "\nvoid bfd_target_list(void)\n\n{\n  bfd_target_list();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "list_supported_targets"
      ],
      "called": [
        "bfd_target_list"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memset": {
      "entrypoint": "0x001281d0",
      "current_name": "memset",
      "code": "\n\n\n\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memset@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "memset"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_get_error": {
      "entrypoint": "0x00104370",
      "current_name": "bfd_get_error",
      "code": "\nvoid bfd_get_error(void)\n\n{\n  bfd_get_error();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_typdef.lto_priv.0",
        "copy_relocations_in_section",
        "bfd_nonfatal",
        "do_display_target",
        "stab_write_symbol.lto_priv.0",
        "main",
        "parse_coff_type.lto_priv.0",
        "write_stabs_in_sections_debugging_info.constprop.0",
        "parse_coff_struct_type",
        "FUN_0010554f",
        "mark_symbols_used_in_relocations.cold",
        "copy_file",
        "bfd_nonfatal_message"
      ],
      "called": [
        "bfd_get_error"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strnlen": {
      "entrypoint": "0x001281e0",
      "current_name": "strnlen",
      "code": "\n\n\n\nsize_t strnlen(char *__string,size_t __maxlen)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strnlen@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strnlen"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xmalloc": {
      "entrypoint": "0x00104390",
      "current_name": "xmalloc",
      "code": "\nvoid xmalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_enum_type.lto_priv.0",
        "FUN_00107880",
        "stab_method_type.lto_priv.0",
        "init_section_add",
        "xstrndup",
        "bfd_get_archive_filename",
        "debug_make_function_type.isra.0",
        "debug_record_parameter",
        "debug_set_class_id.lto_priv.0",
        "parse_stab",
        "debug_record_function",
        "stab_variable.lto_priv.0",
        "parse_coff_struct_type",
        "FUN_0010554f",
        "debug_name_type",
        "mark_symbols_used_in_relocations",
        "stab_class_start_method.lto_priv.0",
        "stab_end_class_type.lto_priv.0",
        "debug_set_filename",
        "debug_make_type.constprop.0",
        "stab_typdef.lto_priv.0",
        "stab_function_type.lto_priv.0",
        "debug_make_enum_type.isra.0",
        "savestring",
        "debug_make_array_type.isra.0",
        "FUN_00116852",
        "main",
        "parse_stab_type",
        "parse_coff_type.lto_priv.0",
        "FUN_00104ea2",
        "coff_get_slot.lto_priv.0",
        "stab_class_static_member.lto_priv.0",
        "stab_record_variable",
        "debug_make_offset_type.isra.0",
        "section_add_load_file",
        "debug_start_source",
        "debug_add_to_namespace.constprop.0",
        "stab_range_type.lto_priv.0",
        "parse_flags.cold",
        "stab_typed_constant.lto_priv.0",
        "debug_make_method_type.isra.0",
        "debug_record_variable",
        "display_info.isra.0",
        "setup_section",
        "find_section_list",
        "stab_start_struct_type.lto_priv.0",
        "stab_find_slot",
        "stab_class_baseclass.lto_priv.0",
        "debug_make_indirect_type.isra.0",
        "debug_tag_type",
        "stab_array_type.lto_priv.0",
        "add_redefine_and_check",
        "stab_find_tagged_type",
        "template_in_dir",
        "stab_push_string",
        "stab_demangle_args",
        "debug_make_struct_type.isra.0",
        "merge_gnu_build_notes",
        "copy_section",
        "start_stab.constprop.0",
        "stab_float_constant.lto_priv.0",
        "stab_end_struct_type.lto_priv.0",
        "stab_struct_field.lto_priv.0",
        "stab_start_function.lto_priv.0",
        "convert_efi_target",
        "stab_set_type.lto_priv.0",
        "stab_int_constant.lto_priv.0",
        "stab_modify_type",
        "stab_demangle_v3_arglist",
        "write_stabs_in_sections_debugging_info.constprop.0",
        "stab_function_parameter.lto_priv.0",
        "debug_start_block",
        "stab_offset_type.lto_priv.0",
        "debug_record_line",
        "stab_start_class_type.lto_priv.0",
        "stab_tag.lto_priv.0",
        "add_specific_symbols"
      ],
      "called": [
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_error": {
      "entrypoint": "0x001043a0",
      "current_name": "bfd_set_error",
      "code": "\nvoid bfd_set_error(void)\n\n{\n  bfd_set_error();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001086af",
        "FUN_0010554f",
        "copy_file"
      ],
      "called": [
        "bfd_set_error"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xmalloc_set_program_name": {
      "entrypoint": "0x001043b0",
      "current_name": "xmalloc_set_program_name",
      "code": "\nvoid xmalloc_set_program_name(void)\n\n{\n  xmalloc_set_program_name();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "xmalloc_set_program_name"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "close": {
      "entrypoint": "0x00128200",
      "current_name": "close",
      "code": "\n\n\n\nint close(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* close@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "close"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xstrdup": {
      "entrypoint": "0x001043d0",
      "current_name": "xstrdup",
      "code": "\nvoid xstrdup(void)\n\n{\n  xstrdup();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "save_stab",
        "parse_stab",
        "stab_push_string",
        "FUN_0010554f",
        "main",
        "FUN_00104ea2"
      ],
      "called": [
        "xstrdup"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strspn": {
      "entrypoint": "0x00128210",
      "current_name": "strspn",
      "code": "\n\n\n\nsize_t strspn(char *__s,char *__accept)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strspn@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strspn"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fputc": {
      "entrypoint": "0x00128218",
      "current_name": "fputc",
      "code": "\n\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fputc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fputc"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_get_section_by_name": {
      "entrypoint": "0x00104400",
      "current_name": "bfd_get_section_by_name",
      "code": "\nvoid bfd_get_section_by_name(void)\n\n{\n  bfd_get_section_by_name();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107880",
        "create_new_symbol",
        "FUN_0010554f"
      ],
      "called": [
        "bfd_get_section_by_name"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "read": {
      "entrypoint": "0x00128228",
      "current_name": "read",
      "code": "\n\n\n\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* read@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "read"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memcmp": {
      "entrypoint": "0x00128230",
      "current_name": "memcmp",
      "code": "\n\n\n\nint memcmp(void *__s1,void *__s2,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memcmp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "memcmp"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_init": {
      "entrypoint": "0x00104430",
      "current_name": "bfd_init",
      "code": "\nvoid bfd_init(void)\n\n{\n  bfd_init();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "bfd_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_get_full_section_contents": {
      "entrypoint": "0x00104440",
      "current_name": "bfd_get_full_section_contents",
      "code": "\nvoid bfd_get_full_section_contents(void)\n\n{\n  bfd_get_full_section_contents();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107880",
        "copy_section"
      ],
      "called": [
        "bfd_get_full_section_contents"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_hash_allocate": {
      "entrypoint": "0x00104450",
      "current_name": "bfd_hash_allocate",
      "code": "\nvoid bfd_hash_allocate(void)\n\n{\n  bfd_hash_allocate();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "string_hash_newfunc.lto_priv.0"
      ],
      "called": [
        "bfd_hash_allocate"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_symtab": {
      "entrypoint": "0x00104460",
      "current_name": "bfd_set_symtab",
      "code": "\nvoid bfd_set_symtab(void)\n\n{\n  bfd_set_symtab();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [
        "bfd_set_symtab"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strcmp": {
      "entrypoint": "0x00128258",
      "current_name": "strcmp",
      "code": "\n\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcmp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strcmp"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "putc": {
      "entrypoint": "0x00128260",
      "current_name": "putc",
      "code": "\n\n\n\nint putc(int __c,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* putc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "putc"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_decode_symclass": {
      "entrypoint": "0x00104490",
      "current_name": "bfd_decode_symclass",
      "code": "\nvoid bfd_decode_symclass(void)\n\n{\n  bfd_decode_symclass();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [
        "bfd_decode_symclass"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "htab_find_slot": {
      "entrypoint": "0x001044a0",
      "current_name": "htab_find_slot",
      "code": "\nvoid htab_find_slot(void)\n\n{\n  htab_find_slot();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "add_redefine_and_check",
        "FUN_00104cc1",
        "main"
      ],
      "called": [
        "htab_find_slot"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fprintf": {
      "entrypoint": "0x00128288",
      "current_name": "fprintf",
      "code": "\n\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fprintf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fprintf"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ftell": {
      "entrypoint": "0x00128290",
      "current_name": "ftell",
      "code": "\n\n\n\nlong ftell(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ftell@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "ftell"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "feof": {
      "entrypoint": "0x00128298",
      "current_name": "feof",
      "code": "\n\n\n\nint feof(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* feof@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "feof"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "htab_elements": {
      "entrypoint": "0x001044e0",
      "current_name": "htab_elements",
      "code": "\nvoid htab_elements(void)\n\n{\n  htab_elements();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f",
        "main"
      ],
      "called": [
        "htab_elements"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stat": {
      "entrypoint": "0x001282b0",
      "current_name": "stat",
      "code": "\n\n\n\nint stat(char *__file,stat *__buf)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* stat@GLIBC_2.33 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "stat"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_format": {
      "entrypoint": "0x00104500",
      "current_name": "bfd_set_format",
      "code": "\nvoid bfd_set_format(void)\n\n{\n  bfd_set_format();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107880",
        "do_display_target",
        "copy_file",
        "copy_object"
      ],
      "called": [
        "bfd_set_format"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strtol": {
      "entrypoint": "0x001282c0",
      "current_name": "strtol",
      "code": "\n\n\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strtol@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strtol"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_octets_per_byte": {
      "entrypoint": "0x00104520",
      "current_name": "bfd_octets_per_byte",
      "code": "\nvoid bfd_octets_per_byte(void)\n\n{\n  bfd_octets_per_byte();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [
        "bfd_octets_per_byte"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_bwrite": {
      "entrypoint": "0x00104530",
      "current_name": "bfd_bwrite",
      "code": "\nvoid bfd_bwrite(void)\n\n{\n  bfd_bwrite();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104ea2"
      ],
      "called": [
        "bfd_bwrite"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memcpy": {
      "entrypoint": "0x001282d8",
      "current_name": "memcpy",
      "code": "\n\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memcpy@GLIBC_2.14 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "memcpy"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "cplus_demangle_init_info": {
      "entrypoint": "0x00104550",
      "current_name": "cplus_demangle_init_info",
      "code": "\nvoid cplus_demangle_init_info(void)\n\n{\n  cplus_demangle_init_info();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_stab_type"
      ],
      "called": [
        "cplus_demangle_init_info"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_hash_lookup": {
      "entrypoint": "0x00104560",
      "current_name": "bfd_hash_lookup",
      "code": "\nvoid bfd_hash_lookup(void)\n\n{\n  bfd_hash_lookup();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_typdef.lto_priv.0",
        "stab_write_symbol.lto_priv.0",
        "stab_typedef_type.lto_priv.0"
      ],
      "called": [
        "bfd_hash_lookup"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_get_arch": {
      "entrypoint": "0x00104570",
      "current_name": "bfd_get_arch",
      "code": "\nvoid bfd_get_arch(void)\n\n{\n  bfd_get_arch();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107880",
        "FUN_00107976",
        "FUN_00104ea2",
        "FUN_00105828"
      ],
      "called": [
        "bfd_get_arch"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "htab_traverse": {
      "entrypoint": "0x00104580",
      "current_name": "htab_traverse",
      "code": "\nvoid htab_traverse(void)\n\n{\n  htab_traverse();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "is_specified_symbol",
        "FUN_0010554f"
      ],
      "called": [
        "htab_traverse"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_alt_mach_code": {
      "entrypoint": "0x00104590",
      "current_name": "bfd_alt_mach_code",
      "code": "\nvoid bfd_alt_mach_code(void)\n\n{\n  bfd_alt_mach_code();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [
        "bfd_alt_mach_code"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_printable_arch_mach": {
      "entrypoint": "0x001045a0",
      "current_name": "bfd_printable_arch_mach",
      "code": "\nvoid bfd_printable_arch_mach(void)\n\n{\n  bfd_printable_arch_mach();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "display_info.isra.0.cold",
        "do_display_target",
        "display_info.isra.0",
        "FUN_00105828"
      ],
      "called": [
        "bfd_printable_arch_mach"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_coff_get_auxent": {
      "entrypoint": "0x001045b0",
      "current_name": "bfd_coff_get_auxent",
      "code": "\nvoid bfd_coff_get_auxent(void)\n\n{\n  bfd_coff_get_auxent();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_coff_struct_type",
        "FUN_0010554f"
      ],
      "called": [
        "bfd_coff_get_auxent"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "malloc": {
      "entrypoint": "0x00128318",
      "current_name": "malloc",
      "code": "\n\n\n\nvoid * malloc(size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* malloc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "malloc"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strncasecmp": {
      "entrypoint": "0x00128320",
      "current_name": "strncasecmp",
      "code": "\n\n\n\nint strncasecmp(char *__s1,char *__s2,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strncasecmp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strncasecmp"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fflush": {
      "entrypoint": "0x00128328",
      "current_name": "fflush",
      "code": "\n\n\n\nint fflush(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fflush@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fflush"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_section_size": {
      "entrypoint": "0x001045f0",
      "current_name": "bfd_set_section_size",
      "code": "\nvoid bfd_set_section_size(void)\n\n{\n  bfd_set_section_size();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107880",
        "FUN_0010554f",
        "copy_section",
        "setup_section"
      ],
      "called": [
        "bfd_set_section_size"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_fill_in_gnu_debuglink_section": {
      "entrypoint": "0x00104600",
      "current_name": "bfd_fill_in_gnu_debuglink_section",
      "code": "\nvoid bfd_fill_in_gnu_debuglink_section(void)\n\n{\n  bfd_fill_in_gnu_debuglink_section();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [
        "bfd_fill_in_gnu_debuglink_section"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "unlink_if_ordinary": {
      "entrypoint": "0x00104610",
      "current_name": "unlink_if_ordinary",
      "code": "\nvoid unlink_if_ordinary(void)\n\n{\n  unlink_if_ordinary();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "unlink_if_ordinary"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_iterate_over_targets": {
      "entrypoint": "0x00104620",
      "current_name": "bfd_iterate_over_targets",
      "code": "\nvoid bfd_iterate_over_targets(void)\n\n{\n  bfd_iterate_over_targets();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "display_info.isra.0"
      ],
      "called": [
        "bfd_iterate_over_targets"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_file_flags": {
      "entrypoint": "0x00104630",
      "current_name": "bfd_set_file_flags",
      "code": "\nvoid bfd_set_file_flags(void)\n\n{\n  bfd_set_file_flags();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107976"
      ],
      "called": [
        "bfd_set_file_flags"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "mkstemp": {
      "entrypoint": "0x00128358",
      "current_name": "mkstemp",
      "code": "\n\n\n\nint mkstemp(char *__template)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mkstemp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "mkstemp"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_get_mach": {
      "entrypoint": "0x00104650",
      "current_name": "bfd_get_mach",
      "code": "\nvoid bfd_get_mach(void)\n\n{\n  bfd_get_mach();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107976",
        "FUN_00105828"
      ],
      "called": [
        "bfd_get_mach"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fseek": {
      "entrypoint": "0x00128370",
      "current_name": "fseek",
      "code": "\n\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fseek@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fseek"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "mkdtemp": {
      "entrypoint": "0x00128388",
      "current_name": "mkdtemp",
      "code": "\n\n\n\nchar * mkdtemp(char *__template)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mkdtemp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "mkdtemp"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setlocale": {
      "entrypoint": "0x00128390",
      "current_name": "setlocale",
      "code": "\n\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* setlocale@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "setlocale"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_openw": {
      "entrypoint": "0x00104690",
      "current_name": "bfd_openw",
      "code": "\nvoid bfd_openw(void)\n\n{\n  bfd_openw();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "do_display_target",
        "copy_file",
        "FUN_00104ea2"
      ],
      "called": [
        "bfd_openw"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_coff_get_syment": {
      "entrypoint": "0x001046a0",
      "current_name": "bfd_coff_get_syment",
      "code": "\nvoid bfd_coff_get_syment(void)\n\n{\n  bfd_coff_get_syment();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_coff_struct_type",
        "FUN_0010554f",
        "parse_coff_type.lto_priv.0"
      ],
      "called": [
        "bfd_coff_get_syment"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "cplus_demangle": {
      "entrypoint": "0x001046b0",
      "current_name": "cplus_demangle",
      "code": "\nvoid cplus_demangle(void)\n\n{\n  cplus_demangle();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_template"
      ],
      "called": [
        "cplus_demangle"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fchmod": {
      "entrypoint": "0x001283b0",
      "current_name": "fchmod",
      "code": "\n\n\n\nint fchmod(int __fd,__mode_t __mode)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fchmod@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fchmod"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "chmod": {
      "entrypoint": "0x001283b8",
      "current_name": "chmod",
      "code": "\n\n\n\nint chmod(char *__file,__mode_t __mode)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* chmod@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "chmod"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_error_program_name": {
      "entrypoint": "0x001046e0",
      "current_name": "bfd_set_error_program_name",
      "code": "\nvoid bfd_set_error_program_name(void)\n\n{\n  bfd_set_error_program_name();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "bfd_set_error_program_name"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memmove": {
      "entrypoint": "0x001283c8",
      "current_name": "memmove",
      "code": "\n\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memmove@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "memmove"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "cplus_demangle_mangled_name": {
      "entrypoint": "0x00104700",
      "current_name": "cplus_demangle_mangled_name",
      "code": "\nvoid cplus_demangle_mangled_name(void)\n\n{\n  cplus_demangle_mangled_name();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_stab_type"
      ],
      "called": [
        "cplus_demangle_mangled_name"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_scan_arch": {
      "entrypoint": "0x00104710",
      "current_name": "bfd_scan_arch",
      "code": "\nvoid bfd_scan_arch(void)\n\n{\n  bfd_scan_arch();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "bfd_scan_arch"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "htab_create_alloc": {
      "entrypoint": "0x00104720",
      "current_name": "htab_create_alloc",
      "code": "\nvoid htab_create_alloc(void)\n\n{\n  htab_create_alloc();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "create_symbol_htab",
        "main"
      ],
      "called": [
        "htab_create_alloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "open": {
      "entrypoint": "0x001283e8",
      "current_name": "open",
      "code": "\n\n\n\nint open(char *__file,int __oflag,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* open@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "open"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "access": {
      "entrypoint": "0x001283f0",
      "current_name": "access",
      "code": "\n\n\n\nint access(char *__name,int __type)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* access@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "access"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fopen": {
      "entrypoint": "0x001283f8",
      "current_name": "fopen",
      "code": "\n\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fopen@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fopen"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xexit": {
      "entrypoint": "0x00104760",
      "current_name": "xexit",
      "code": "\nvoid xexit(void)\n\n{\n                    \n  xexit();\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_relocations_in_section",
        "fatal",
        "mark_symbols_used_in_relocations",
        "main",
        "mark_symbols_used_in_relocations.cold"
      ],
      "called": [
        "xexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "vfprintf": {
      "entrypoint": "0x00128408",
      "current_name": "vfprintf",
      "code": "\n\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* vfprintf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "vfprintf"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_check_format_matches": {
      "entrypoint": "0x00104780",
      "current_name": "bfd_check_format_matches",
      "code": "\nvoid bfd_check_format_matches(void)\n\n{\n  bfd_check_format_matches();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_file"
      ],
      "called": [
        "bfd_check_format_matches"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strtoul": {
      "entrypoint": "0x00128418",
      "current_name": "strtoul",
      "code": "\n\n\n\nulong strtoul(char *__nptr,char **__endptr,int __base)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strtoul@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strtoul"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_errmsg": {
      "entrypoint": "0x001047a0",
      "current_name": "bfd_errmsg",
      "code": "\nvoid bfd_errmsg(void)\n\n{\n  bfd_errmsg();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_typdef.lto_priv.0",
        "bfd_nonfatal",
        "parse_coff_struct_type",
        "FUN_0010554f",
        "stab_write_symbol.lto_priv.0",
        "main",
        "parse_coff_type.lto_priv.0",
        "write_stabs_in_sections_debugging_info.constprop.0",
        "bfd_nonfatal_message"
      ],
      "called": [
        "bfd_errmsg"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_canonicalize_reloc": {
      "entrypoint": "0x001047b0",
      "current_name": "bfd_canonicalize_reloc",
      "code": "\nvoid bfd_canonicalize_reloc(void)\n\n{\n  bfd_canonicalize_reloc();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_relocations_in_section",
        "merge_gnu_build_notes",
        "mark_symbols_used_in_relocations"
      ],
      "called": [
        "bfd_canonicalize_reloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strcat": {
      "entrypoint": "0x00128430",
      "current_name": "strcat",
      "code": "\n\n\n\nchar * strcat(char *__dest,char *__src)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcat@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strcat"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "htab_find": {
      "entrypoint": "0x001047d0",
      "current_name": "htab_find",
      "code": "\nvoid htab_find(void)\n\n{\n  htab_find();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "is_specified_symbol",
        "add_redefine_and_check",
        "FUN_0010554f"
      ],
      "called": [
        "htab_find"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sprintf": {
      "entrypoint": "0x00128440",
      "current_name": "sprintf",
      "code": "\n\n\n\nint sprintf(char *__s,char *__format,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* sprintf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "sprintf"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "exit": {
      "entrypoint": "0x00128448",
      "current_name": "exit",
      "code": "\n\n\n\nvoid exit(int __status)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* exit@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "exit"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fwrite": {
      "entrypoint": "0x00128450",
      "current_name": "fwrite",
      "code": "\n\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fwrite@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fwrite",
        "mark_symbols_used_in_relocations"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_check_format": {
      "entrypoint": "0x00104810",
      "current_name": "bfd_check_format",
      "code": "\nvoid bfd_check_format(void)\n\n{\n  bfd_check_format();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_file",
        "FUN_00104ea2"
      ],
      "called": [
        "bfd_check_format"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_openr_next_archived_file": {
      "entrypoint": "0x00104820",
      "current_name": "bfd_openr_next_archived_file",
      "code": "\nvoid bfd_openr_next_archived_file(void)\n\n{\n  bfd_openr_next_archived_file();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_file",
        "FUN_00104ea2"
      ],
      "called": [
        "bfd_openr_next_archived_file"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_hash_table_init": {
      "entrypoint": "0x00104830",
      "current_name": "bfd_hash_table_init",
      "code": "\nvoid bfd_hash_table_init(void)\n\n{\n  bfd_hash_table_init();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "write_stabs_in_sections_debugging_info.constprop.0"
      ],
      "called": [
        "bfd_hash_table_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_get_reloc_upper_bound": {
      "entrypoint": "0x00104840",
      "current_name": "bfd_get_reloc_upper_bound",
      "code": "\nvoid bfd_get_reloc_upper_bound(void)\n\n{\n  bfd_get_reloc_upper_bound();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_relocations_in_section",
        "merge_gnu_build_notes",
        "mark_symbols_used_in_relocations"
      ],
      "called": [
        "bfd_get_reloc_upper_bound"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_map_over_sections": {
      "entrypoint": "0x00104850",
      "current_name": "bfd_map_over_sections",
      "code": "\nvoid bfd_map_over_sections(void)\n\n{\n  bfd_map_over_sections();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107880",
        "FUN_0010554f"
      ],
      "called": [
        "bfd_map_over_sections"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_start_address": {
      "entrypoint": "0x00104860",
      "current_name": "bfd_set_start_address",
      "code": "\nvoid bfd_set_start_address(void)\n\n{\n  bfd_set_start_address();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107976"
      ],
      "called": [
        "bfd_set_start_address"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_bread": {
      "entrypoint": "0x00104870",
      "current_name": "bfd_bread",
      "code": "\nvoid bfd_bread(void)\n\n{\n  bfd_bread();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104ea2"
      ],
      "called": [
        "bfd_bread"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strdup": {
      "entrypoint": "0x00128498",
      "current_name": "strdup",
      "code": "\n\n\n\nchar * strdup(char *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strdup@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strdup"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strerror": {
      "entrypoint": "0x001284a8",
      "current_name": "strerror",
      "code": "\n\n\n\nchar * strerror(int __errnum)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strerror@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strerror"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_is_local_label": {
      "entrypoint": "0x001048a0",
      "current_name": "bfd_is_local_label",
      "code": "\nvoid bfd_is_local_label(void)\n\n{\n  bfd_is_local_label();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [
        "bfd_is_local_label"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getc": {
      "entrypoint": "0x001284b8",
      "current_name": "getc",
      "code": "\n\n\n\nint getc(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "getc"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strstr": {
      "entrypoint": "0x001284c0",
      "current_name": "strstr",
      "code": "\n\n\n\nchar * strstr(char *__haystack,char *__needle)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strstr@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strstr"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_fdopenw": {
      "entrypoint": "0x001048d0",
      "current_name": "bfd_fdopenw",
      "code": "\nvoid bfd_fdopenw(void)\n\n{\n  bfd_fdopenw();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_file"
      ],
      "called": [
        "bfd_fdopenw"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_seek": {
      "entrypoint": "0x001048e0",
      "current_name": "bfd_seek",
      "code": "\nvoid bfd_seek(void)\n\n{\n  bfd_seek();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104ea2"
      ],
      "called": [
        "bfd_seek"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "free": {
      "entrypoint": "0x001284f0",
      "current_name": "free",
      "code": "\n\n\n\nvoid free(void *__ptr)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* free@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "free",
        "create_symbol_htab",
        "main"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "htab_hash_string": {
      "entrypoint": "0x001048f8",
      "current_name": "htab_hash_string",
      "code": "\nvoid htab_hash_string(void)\n\n{\n  htab_hash_string();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "htab_hash_redefnode"
      ],
      "called": [
        "htab_hash_string"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_close_all_done": {
      "entrypoint": "0x00104900",
      "current_name": "bfd_close_all_done",
      "code": "\nvoid bfd_close_all_done(void)\n\n{\n  bfd_close_all_done();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "do_display_target",
        "copy_file",
        "FUN_00104ea2"
      ],
      "called": [
        "bfd_close_all_done"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_close": {
      "entrypoint": "0x00104908",
      "current_name": "bfd_close",
      "code": "\nvoid bfd_close(void)\n\n{\n  bfd_close();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_file",
        "FUN_00104ea2"
      ],
      "called": [
        "bfd_close"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__cxa_finalize": {
      "entrypoint": "0x001284e8",
      "current_name": "__cxa_finalize",
      "code": "\n\n\nvoid __cxa_finalize(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __cxa_finalize@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "__cxa_finalize"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xcalloc": {
      "entrypoint": "0x00104918",
      "current_name": "xcalloc",
      "code": "\nvoid xcalloc(void)\n\n{\n  xcalloc();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "merge_gnu_build_notes"
      ],
      "called": [
        "xcalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "parse_vma.cold": {
      "entrypoint": "0x00104920",
      "current_name": "parse_vma.cold",
      "code": "\nvoid parse_vma_cold(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 \u003d dcgettext(0,\"%s: bad number: %s\",5);\n                    \n  fatal(uVar1);\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_vma"
      ],
      "called": [
        "dcgettext",
        "fatal"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "display_info.isra.0.cold": {
      "entrypoint": "0x00104943",
      "current_name": "display_info.isra.0.cold",
      "code": "\n\n\nvoid display_info_isra_0_cold(void)\n\n{\n  int iVar1;\n  int iVar2;\n  char *in_RAX;\n  long lVar3;\n  size_t sVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  int iVar7;\n  long lVar8;\n  int iVar9;\n  uint unaff_R15D;\n  ulong uVar10;\n  uint uVar11;\n  int param_7;\n  uint uStack000000000000000c;\n  undefined8 param_11;\n  long param_13;\n  \n  lVar3 \u003d strtol(in_RAX,(char **)0x0,10);\n  iVar1 \u003d (int)lVar3;\n  iVar9 \u003d param_7;\n  uStack000000000000000c \u003d unaff_R15D;\n  if (iVar1 \u003d\u003d 0) {\n    iVar1 \u003d 0x50;\n  }\n  do {\n    param_7 \u003d iVar9;\n    if (param_11._4_4_ \u003c\u003d param_7) {\n      return;\n    }\n    lVar8 \u003d (long)param_7;\n    iVar7 \u003d (iVar1 - uStack000000000000000c) + -1;\n    lVar3 \u003d lVar8;\n    do {\n      iVar9 \u003d (int)lVar3;\n      if (param_11._4_4_ \u003c\u003d iVar9) break;\n      sVar4 \u003d strlen(*(char **)(param_13 + lVar3 * 0x60));\n      lVar3 \u003d lVar3 + 1;\n      iVar7 \u003d (iVar7 - (int)sVar4) + -1;\n    } while (-1 \u003c iVar7);\n    printf(\"\\n%*s\",(ulong)(uStack000000000000000c + 1),\u0026DAT_0011b4a1);\n    for (lVar3 \u003d lVar8 * 0x60; ((ulong)(uint)(iVar9 - param_7) + lVar8) * 0x60 - lVar3 !\u003d 0;\n        lVar3 \u003d lVar3 + 0x60) {\n      printf(\"%s \",*(undefined8 *)(param_13 + lVar3));\n    }\n    iVar7 \u003d 2;\n    putc(10,_stdout);\n    do {\n      pcVar5 \u003d (char *)bfd_printable_arch_mach(iVar7,0);\n      iVar2 \u003d strcmp(pcVar5,\"UNKNOWN!\");\n      if (iVar2 !\u003d 0) {\n        uVar6 \u003d bfd_printable_arch_mach(iVar7,0);\n        printf(\"%*s \",(ulong)uStack000000000000000c,uVar6);\n        uVar11 \u003d iVar7 - 2;\n        lVar3 \u003d lVar8 * 0x60;\n        iVar2 \u003d param_7;\n        while (iVar9 !\u003d iVar2) {\n          pcVar5 \u003d *(char **)(param_13 + lVar3);\n          if (*(char *)((long)(char **)(param_13 + lVar3) + (ulong)uVar11 + 8) \u003d\u003d \u0027\\0\u0027) {\n            sVar4 \u003d strlen(pcVar5);\n            for (uVar10 \u003d sVar4 \u0026 0xffffffff; (int)uVar10 !\u003d 0; uVar10 \u003d (ulong)((int)uVar10 - 1)) {\n              putc(0x2d,_stdout);\n            }\n          }\n          else {\n            fputs(pcVar5,_stdout);\n          }\n          iVar2 \u003d iVar2 + 1;\n          if (iVar9 !\u003d iVar2) {\n            putc(0x20,_stdout);\n          }\n          lVar3 \u003d lVar3 + 0x60;\n        }\n        putc(10,_stdout);\n      }\n      iVar7 \u003d iVar7 + 1;\n    } while (iVar7 !\u003d 0x57);\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "display_info.isra.0"
      ],
      "called": [
        "printf",
        "strlen",
        "fputs",
        "strcmp",
        "bfd_printable_arch_mach",
        "strtol",
        "putc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "get_file_size.cold": {
      "entrypoint": "0x00104966",
      "current_name": "get_file_size.cold",
      "code": "\nundefined8 get_file_size_cold(void)\n\n{\n  int *piVar1;\n  undefined8 uVar2;\n  \n  piVar1 \u003d __errno_location();\n  if (*piVar1 \u003d\u003d 2) {\n    uVar2 \u003d dcgettext(0,\"\\\u0027%s\\\u0027: No such file\",5);\n    non_fatal(uVar2);\n  }\n  else {\n    strerror(*piVar1);\n    uVar2 \u003d dcgettext(0,\"Warning: could not locate \\\u0027%s\\\u0027.  reason: %s\",5);\n    non_fatal(uVar2);\n  }\n  return 0xffffffffffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "get_file_size"
      ],
      "called": [
        "non_fatal",
        "dcgettext",
        "strerror",
        "__errno_location"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "list_supported_targets": {
      "entrypoint": "0x00104a35",
      "current_name": "list_supported_targets",
      "code": "\nvoid list_supported_targets(long param_1,FILE *param_2)\n\n{\n  long lVar1;\n  char *pcVar2;\n  long *__ptr;\n  long *plVar3;\n  \n  if (param_1 \u003d\u003d 0) {\n    pcVar2 \u003d (char *)dcgettext(0,\"Supported targets:\",5);\n    fprintf(param_2,pcVar2);\n  }\n  else {\n    pcVar2 \u003d (char *)dcgettext(0,\"%s: supported targets:\",5);\n    fprintf(param_2,pcVar2,param_1);\n  }\n  __ptr \u003d (long *)bfd_target_list();\n  plVar3 \u003d __ptr;\n  while( true ) {\n    lVar1 \u003d *plVar3;\n    plVar3 \u003d plVar3 + 1;\n    if (lVar1 \u003d\u003d 0) break;\n    fprintf(param_2,\" %s\");\n  }\n  fputc(10,param_2);\n  free(__ptr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_usage",
        "strip_usage"
      ],
      "called": [
        "fprintf",
        "free",
        "fputc",
        "dcgettext",
        "bfd_target_list"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "parse_flags.cold": {
      "entrypoint": "0x00104ad6",
      "current_name": "parse_flags.cold",
      "code": "\nundefined  [16] parse_flags_cold(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  char *unaff_RBP;\n  char *__s;\n  size_t sVar4;\n  int iVar5;\n  uint unaff_R14D;\n  char *unaff_R15;\n  undefined auVar6 [16];\n  undefined8 unaff_retaddr;\n  \n  do {\n    unaff_R14D \u003d unaff_R14D | 0x2000;\n    __s \u003d unaff_RBP;\n    while( true ) {\n      while( true ) {\n        while( true ) {\n          while( true ) {\n            while( true ) {\n              if (__s \u003d\u003d (char *)0x0) {\n                auVar6._4_4_ \u003d 0;\n                auVar6._0_4_ \u003d unaff_R14D;\n                auVar6._8_8_ \u003d unaff_retaddr;\n                return auVar6;\n              }\n              pcVar3 \u003d strchr(__s,0x2c);\n              if (pcVar3 \u003d\u003d (char *)0x0) {\n                sVar4 \u003d strlen(__s);\n                iVar5 \u003d (int)sVar4;\n                unaff_RBP \u003d (char *)0x0;\n              }\n              else {\n                unaff_RBP \u003d pcVar3 + 1;\n                iVar5 \u003d (int)pcVar3 - (int)__s;\n              }\n              sVar4 \u003d (size_t)iVar5;\n              iVar1 \u003d strncasecmp(unaff_R15,__s,sVar4);\n              if (iVar1 !\u003d 0) break;\n              unaff_R14D \u003d unaff_R14D | 1;\n              __s \u003d unaff_RBP;\n            }\n            iVar1 \u003d strncasecmp(\"load\",__s,sVar4);\n            if (iVar1 !\u003d 0) break;\n            unaff_R14D \u003d unaff_R14D | 2;\n            __s \u003d unaff_RBP;\n          }\n          iVar1 \u003d strncasecmp(\"noload\",__s,sVar4);\n          if (iVar1 !\u003d 0) break;\n          unaff_R14D \u003d unaff_R14D | 0x200;\n          __s \u003d unaff_RBP;\n        }\n        iVar1 \u003d strncasecmp(\"readonly\",__s,sVar4);\n        if (iVar1 !\u003d 0) break;\n        unaff_R14D \u003d unaff_R14D | 8;\n        __s \u003d unaff_RBP;\n      }\n      iVar1 \u003d strncasecmp(\"debug\",__s,sVar4);\n      if (iVar1 \u003d\u003d 0) break;\n      iVar1 \u003d strncasecmp(\"code\",__s,sVar4);\n      if (iVar1 \u003d\u003d 0) {\n        unaff_R14D \u003d unaff_R14D | 0x10;\n        __s \u003d unaff_RBP;\n      }\n      else {\n        iVar1 \u003d strncasecmp(\"data\",__s,sVar4);\n        if (iVar1 \u003d\u003d 0) {\n          unaff_R14D \u003d unaff_R14D | 0x20;\n          __s \u003d unaff_RBP;\n        }\n        else {\n          iVar1 \u003d strncasecmp(\"rom\",__s,sVar4);\n          if (iVar1 \u003d\u003d 0) {\n            unaff_R14D \u003d unaff_R14D | 0x40;\n            __s \u003d unaff_RBP;\n          }\n          else {\n            iVar1 \u003d strncasecmp(\"exclude\",__s,sVar4);\n            if (iVar1 \u003d\u003d 0) {\n              unaff_R14D \u003d unaff_R14D | 0x8000;\n              __s \u003d unaff_RBP;\n            }\n            else {\n              iVar1 \u003d strncasecmp(\"share\",__s,sVar4);\n              if (iVar1 \u003d\u003d 0) {\n                unaff_R14D \u003d unaff_R14D | 0x8000000;\n                __s \u003d unaff_RBP;\n              }\n              else {\n                iVar1 \u003d strncasecmp(\"contents\",__s,sVar4);\n                if (iVar1 \u003d\u003d 0) {\n                  unaff_R14D \u003d unaff_R14D | 0x100;\n                  __s \u003d unaff_RBP;\n                }\n                else {\n                  iVar1 \u003d strncasecmp(\"merge\",__s,sVar4);\n                  if (iVar1 \u003d\u003d 0) {\n                    unaff_R14D \u003d unaff_R14D | 0x800000;\n                    __s \u003d unaff_RBP;\n                  }\n                  else {\n                    iVar1 \u003d strncasecmp(\"strings\",__s,sVar4);\n                    if (iVar1 !\u003d 0) {\n                      pcVar3 \u003d (char *)xmalloc((long)(iVar5 + 1));\n                      strncpy(pcVar3,__s,sVar4);\n                      pcVar3[sVar4] \u003d \u0027\\0\u0027;\n                      uVar2 \u003d dcgettext(0,\"unrecognized section flag `%s\\\u0027\",5);\n                      non_fatal(uVar2,pcVar3);\n                      uVar2 \u003d dcgettext(0,\"supported flags: %s\",5);\n                    \n                      fatal(uVar2,\n                            \"alloc, load, noload, readonly, debug, code, data, rom, exclude, share, contents, merge, strings\"\n                           );\n                    }\n                    unaff_R14D \u003d unaff_R14D | 0x1000000;\n                    __s \u003d unaff_RBP;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_flags.cold"
      ],
      "called": [
        "non_fatal",
        "strchr",
        "parse_flags.cold",
        "dcgettext",
        "fatal",
        "strlen",
        "strncasecmp",
        "xmalloc",
        "strncpy"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "find_section_list.cold": {
      "entrypoint": "0x00104bba",
      "current_name": "find_section_list.cold",
      "code": "\nvoid find_section_list_cold(void)\n\n{\n  uint in_EAX;\n  undefined8 uVar1;\n  uint unaff_EBP;\n  long unaff_R14;\n  \n  if ((in_EAX \u0026 2) !\u003d 0) {\n    uVar1 \u003d dcgettext(0,\"error: %s both copied and removed\",5);\n                    \n    fatal(uVar1);\n  }\n  if ((((in_EAX \u0026 8) \u003d\u003d 0) || ((unaff_EBP \u0026 0x10) \u003d\u003d 0)) \u0026\u0026 ((unaff_EBP \u0026 0x18) !\u003d 0x18)) {\n    if ((((in_EAX \u0026 0x20) \u003d\u003d 0) || ((unaff_EBP \u0026 0x40) \u003d\u003d 0)) \u0026\u0026 ((unaff_EBP \u0026 0x60) !\u003d 0x60)) {\n      *(uint *)(unaff_R14 + 0x14) \u003d in_EAX | unaff_EBP;\n      return;\n    }\n    uVar1 \u003d dcgettext(0,\"error: %s both sets and alters LMA\",5);\n                    \n    fatal(uVar1);\n  }\n  uVar1 \u003d dcgettext(0,\"error: %s both sets and alters VMA\",5);\n                    \n  fatal(uVar1);\n}\n\n",
      "renaming": {},
      "calling": [
        "find_section_list"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "add_specific_symbols.cold": {
      "entrypoint": "0x00104c36",
      "current_name": "add_specific_symbols.cold",
      "code": "\nvoid add_specific_symbols_cold(void)\n\n{\n  undefined8 uVar1;\n  byte **ppbVar2;\n  byte *pbVar3;\n  byte in_CL;\n  byte bVar4;\n  byte *unaff_RBX;\n  int unaff_EBP;\n  byte *pbVar5;\n  undefined8 unaff_R13;\n  byte *unaff_R14;\n  byte *unaff_R15;\n  undefined8 in_stack_00000008;\n  undefined8 *in_stack_00000010;\n  \n  do {\n    pbVar5 \u003d unaff_R15;\n    if (in_CL \u003d\u003d 9) goto LAB_00104c3f;\n    do {\n      if ((in_CL \u003d\u003d 10) || (in_CL \u003d\u003d 0xd)) goto LAB_00114676;\n      if (in_CL \u003d\u003d 0) goto LAB_00114599;\n      in_CL \u003d pbVar5[1];\n      pbVar5 \u003d pbVar5 + 1;\n    } while ((in_CL !\u003d 0x20) \u0026\u0026 (in_CL !\u003d 9));\n    if ((char)in_CL \u003c \u0027\\x0e\u0027) {\nLAB_00114676:\n      if ((-0x2402L \u003e\u003e (in_CL \u0026 0x3f) \u0026 1U) !\u003d 0) goto LAB_001145e6;\n    }\n    else {\nLAB_001145e6:\n      bVar4 \u003d pbVar5[1];\n      if ((((((bVar4 \u003d\u003d 9) || (bVar4 \u003d\u003d 0x20)) \u0026\u0026\n            ((bVar4 \u003d pbVar5[2], bVar4 \u003d\u003d 9 || (bVar4 \u003d\u003d 0x20)))) \u0026\u0026\n           ((bVar4 \u003d pbVar5[3], bVar4 \u003d\u003d 9 || (bVar4 \u003d\u003d 0x20)))) \u0026\u0026\n          ((bVar4 \u003d pbVar5[4], bVar4 \u003d\u003d 9 || (bVar4 \u003d\u003d 0x20)))) \u0026\u0026\n         ((bVar4 \u003d pbVar5[5], bVar4 \u003d\u003d 9 || (bVar4 \u003d\u003d 0x20)))) {\n        bVar4 \u003d pbVar5[6];\n        pbVar3 \u003d pbVar5 + 6;\n        if ((bVar4 \u003d\u003d 9) || (bVar4 \u003d\u003d 0x20)) {\n          do {\n            do {\n              bVar4 \u003d pbVar3[1];\n              pbVar3 \u003d pbVar3 + 1;\n            } while (bVar4 \u003d\u003d 0x20);\n          } while (bVar4 \u003d\u003d 9);\n        }\n      }\n      if ((0xd \u003c bVar4) || ((-0x2402L \u003e\u003e (bVar4 \u0026 0x3f) \u0026 1U) !\u003d 0)) {\n        uVar1 \u003d dcgettext(0,\"%s:%d: Ignoring rubbish found on this line\",5);\n        non_fatal(uVar1,in_stack_00000008,unaff_EBP);\n      }\n    }\nLAB_00114599:\n    *pbVar5 \u003d 0;\n    if (unaff_R15 \u003c pbVar5) {\n      ppbVar2 \u003d (byte **)htab_find_slot();\n      *ppbVar2 \u003d unaff_R15;\n    }\n    unaff_EBP \u003d unaff_EBP + 1;\n    pbVar5 \u003d unaff_RBX;\n    if (unaff_R14[1] \u003d\u003d 0) {\n      *in_stack_00000010 \u003d unaff_R13;\n      return;\n    }\n    for (; bVar4 \u003d *pbVar5, unaff_R14 \u003d pbVar5, bVar4 !\u003d 10; pbVar5 \u003d pbVar5 + 1) {\n      if ((char)bVar4 \u003c \u0027\\v\u0027) {\n        if (bVar4 \u003d\u003d 0) {\n          pbVar3 \u003d pbVar5 + 1;\n          goto LAB_00114553;\n        }\n      }\n      else {\n        if (bVar4 \u003d\u003d 0xd) {\n          *pbVar5 \u003d 0;\n          pbVar3 \u003d pbVar5 + 1;\n          if (pbVar5[1] \u003d\u003d 10) {\n            pbVar3 \u003d pbVar5 + 2;\n            unaff_R14 \u003d pbVar5 + 1;\n          }\n          goto LAB_00114553;\n        }\n        if (bVar4 \u003d\u003d 0x23) {\n          FUN_00104d1c();\n          return;\n        }\n      }\n    }\n    *pbVar5 \u003d 0;\n    if (pbVar5[1] \u003d\u003d 0xd) {\n      unaff_R14 \u003d pbVar5 + 1;\n      pbVar3 \u003d pbVar5 + 2;\n    }\n    else {\n      pbVar3 \u003d pbVar5 + 1;\n    }\nLAB_00114553:\n    in_CL \u003d *unaff_RBX;\n    unaff_R15 \u003d unaff_RBX;\n    while (unaff_RBX \u003d pbVar3, in_CL \u003d\u003d 0x20) {\nLAB_00104c3f:\n      pbVar5 \u003d unaff_R15 + 1;\n      unaff_R15 \u003d unaff_R15 + 1;\n      pbVar3 \u003d unaff_RBX;\n      in_CL \u003d *pbVar5;\n    }\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104cc1"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00104cc1": {
      "entrypoint": "0x00104cc1",
      "current_name": "FUN_00104cc1",
      "code": "\nvoid FUN_00104cc1(void)\n\n{\n  undefined8 uVar1;\n  byte **ppbVar2;\n  byte *pbVar3;\n  byte bVar4;\n  byte *unaff_RBX;\n  byte *pbVar5;\n  int unaff_EBP;\n  byte *in_R10;\n  undefined8 unaff_R13;\n  byte *unaff_R14;\n  byte *unaff_R15;\n  undefined8 param_7;\n  undefined8 *param_8;\n  byte *param_9;\n  \ncode_r0x00104cc1:\n  param_9 \u003d in_R10;\n  uVar1 \u003d dcgettext(0,\"%s:%d: Ignoring rubbish found on this line\",5);\n  non_fatal(uVar1,param_7,unaff_EBP);\n  pbVar5 \u003d unaff_RBX;\n  in_R10 \u003d param_9;\nLAB_00114599:\n  do {\n    *in_R10 \u003d 0;\n    if (unaff_R15 \u003c in_R10) {\n      ppbVar2 \u003d (byte **)htab_find_slot();\n      *ppbVar2 \u003d unaff_R15;\n    }\n    unaff_EBP \u003d unaff_EBP + 1;\n    pbVar3 \u003d pbVar5;\n    if (unaff_R14[1] \u003d\u003d 0) {\n      *param_8 \u003d unaff_R13;\n      return;\n    }\n    for (; bVar4 \u003d *pbVar3, unaff_R14 \u003d pbVar3, bVar4 !\u003d 10; pbVar3 \u003d pbVar3 + 1) {\n      if ((char)bVar4 \u003c \u0027\\v\u0027) {\n        if (bVar4 \u003d\u003d 0) {\n          unaff_RBX \u003d pbVar3 + 1;\n          goto LAB_00114553;\n        }\n      }\n      else {\n        if (bVar4 \u003d\u003d 0xd) {\n          *pbVar3 \u003d 0;\n          unaff_RBX \u003d pbVar3 + 1;\n          if (pbVar3[1] \u003d\u003d 10) {\n            unaff_RBX \u003d pbVar3 + 2;\n            unaff_R14 \u003d pbVar3 + 1;\n          }\n          goto LAB_00114553;\n        }\n        if (bVar4 \u003d\u003d 0x23) {\n          FUN_00104d1c();\n          return;\n        }\n      }\n    }\n    *pbVar3 \u003d 0;\n    if (pbVar3[1] \u003d\u003d 0xd) {\n      unaff_R14 \u003d pbVar3 + 1;\n      unaff_RBX \u003d pbVar3 + 2;\n    }\n    else {\n      unaff_RBX \u003d pbVar3 + 1;\n    }\nLAB_00114553:\n    bVar4 \u003d *pbVar5;\n    unaff_R15 \u003d pbVar5;\n    while ((bVar4 \u003d\u003d 0x20 || (in_R10 \u003d unaff_R15, bVar4 \u003d\u003d 9))) {\n      pbVar5 \u003d unaff_R15 + 1;\n      unaff_R15 \u003d unaff_R15 + 1;\n      bVar4 \u003d *pbVar5;\n    }\n    do {\n      pbVar5 \u003d unaff_RBX;\n      if ((bVar4 \u003d\u003d 10) || (bVar4 \u003d\u003d 0xd)) goto LAB_00114676;\n      if (bVar4 \u003d\u003d 0) goto LAB_00114599;\n      bVar4 \u003d in_R10[1];\n      in_R10 \u003d in_R10 + 1;\n    } while ((bVar4 !\u003d 0x20) \u0026\u0026 (bVar4 !\u003d 9));\n    if ((char)bVar4 \u003c \u0027\\x0e\u0027) {\nLAB_00114676:\n      if ((-0x2402L \u003e\u003e (bVar4 \u0026 0x3f) \u0026 1U) \u003d\u003d 0) goto LAB_00114599;\n    }\n    bVar4 \u003d in_R10[1];\n    if ((((((bVar4 \u003d\u003d 9) || (bVar4 \u003d\u003d 0x20)) \u0026\u0026 ((bVar4 \u003d in_R10[2], bVar4 \u003d\u003d 9 || (bVar4 \u003d\u003d 0x20)))\n          ) \u0026\u0026 ((bVar4 \u003d in_R10[3], bVar4 \u003d\u003d 9 || (bVar4 \u003d\u003d 0x20)))) \u0026\u0026\n        ((bVar4 \u003d in_R10[4], bVar4 \u003d\u003d 9 || (bVar4 \u003d\u003d 0x20)))) \u0026\u0026\n       ((bVar4 \u003d in_R10[5], bVar4 \u003d\u003d 9 || (bVar4 \u003d\u003d 0x20)))) {\n      bVar4 \u003d in_R10[6];\n      pbVar3 \u003d in_R10 + 6;\n      if ((bVar4 \u003d\u003d 9) || (bVar4 \u003d\u003d 0x20)) {\n        do {\n          do {\n            bVar4 \u003d pbVar3[1];\n            pbVar3 \u003d pbVar3 + 1;\n          } while (bVar4 \u003d\u003d 0x20);\n        } while (bVar4 \u003d\u003d 9);\n      }\n    }\n    if ((0xd \u003c bVar4) || ((-0x2402L \u003e\u003e (bVar4 \u0026 0x3f) \u0026 1U) !\u003d 0)) goto code_r0x00104cc1;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104cc1"
      ],
      "called": [
        "non_fatal",
        "dcgettext",
        "htab_find_slot",
        "FUN_00104cc1",
        "FUN_00104d1c",
        "add_specific_symbols.cold"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00104d1c": {
      "entrypoint": "0x00104d1c",
      "current_name": "FUN_00104d1c",
      "code": "\nvoid FUN_00104d1c(void)\n\n{\n  undefined8 uVar1;\n  byte **ppbVar2;\n  byte *pbVar3;\n  byte bVar4;\n  byte *pbVar5;\n  int unaff_EBP;\n  byte *pbVar6;\n  undefined8 unaff_R13;\n  byte *pbVar7;\n  byte *unaff_R14;\n  byte *unaff_R15;\n  undefined8 in_stack_00000008;\n  undefined8 *in_stack_00000010;\n  \n  *unaff_R14 \u003d 0;\nLAB_00114520:\n  unaff_R14 \u003d unaff_R14 + 1;\n  do {\n    bVar4 \u003d *unaff_R14;\n    pbVar7 \u003d unaff_R14;\n    if (bVar4 \u003d\u003d 10) {\n      *unaff_R14 \u003d 0;\n      if (unaff_R14[1] \u003d\u003d 0xd) {\n        pbVar7 \u003d unaff_R14 + 1;\n        pbVar5 \u003d unaff_R14 + 2;\n      }\n      else {\n        pbVar5 \u003d unaff_R14 + 1;\n      }\n    }\n    else if ((char)bVar4 \u003c \u0027\\v\u0027) {\n      if (bVar4 !\u003d 0) goto LAB_00114520;\n      pbVar5 \u003d unaff_R14 + 1;\n    }\n    else {\n      if (bVar4 !\u003d 0xd) break;\n      *unaff_R14 \u003d 0;\n      pbVar5 \u003d unaff_R14 + 1;\n      if (unaff_R14[1] \u003d\u003d 10) {\n        pbVar5 \u003d unaff_R14 + 2;\n        pbVar7 \u003d unaff_R14 + 1;\n      }\n    }\n    bVar4 \u003d *unaff_R15;\n    while ((bVar4 \u003d\u003d 0x20 || (pbVar6 \u003d unaff_R15, bVar4 \u003d\u003d 9))) {\n      pbVar6 \u003d unaff_R15 + 1;\n      unaff_R15 \u003d unaff_R15 + 1;\n      bVar4 \u003d *pbVar6;\n    }\n    do {\n      if ((bVar4 \u003d\u003d 10) || (bVar4 \u003d\u003d 0xd)) goto LAB_00114676;\n      if (bVar4 \u003d\u003d 0) goto LAB_00114599;\n      bVar4 \u003d pbVar6[1];\n      pbVar6 \u003d pbVar6 + 1;\n    } while ((bVar4 !\u003d 0x20) \u0026\u0026 (bVar4 !\u003d 9));\n    if ((char)bVar4 \u003c \u0027\\x0e\u0027) {\nLAB_00114676:\n      if ((-0x2402L \u003e\u003e (bVar4 \u0026 0x3f) \u0026 1U) !\u003d 0) goto LAB_001145e6;\n    }\n    else {\nLAB_001145e6:\n      bVar4 \u003d pbVar6[1];\n      if ((((((bVar4 \u003d\u003d 9) || (bVar4 \u003d\u003d 0x20)) \u0026\u0026\n            ((bVar4 \u003d pbVar6[2], bVar4 \u003d\u003d 9 || (bVar4 \u003d\u003d 0x20)))) \u0026\u0026\n           ((bVar4 \u003d pbVar6[3], bVar4 \u003d\u003d 9 || (bVar4 \u003d\u003d 0x20)))) \u0026\u0026\n          ((bVar4 \u003d pbVar6[4], bVar4 \u003d\u003d 9 || (bVar4 \u003d\u003d 0x20)))) \u0026\u0026\n         ((bVar4 \u003d pbVar6[5], bVar4 \u003d\u003d 9 || (bVar4 \u003d\u003d 0x20)))) {\n        bVar4 \u003d pbVar6[6];\n        pbVar3 \u003d pbVar6 + 6;\n        if ((bVar4 \u003d\u003d 9) || (bVar4 \u003d\u003d 0x20)) {\n          do {\n            do {\n              bVar4 \u003d pbVar3[1];\n              pbVar3 \u003d pbVar3 + 1;\n            } while (bVar4 \u003d\u003d 0x20);\n          } while (bVar4 \u003d\u003d 9);\n        }\n      }\n      if ((0xd \u003c bVar4) || ((-0x2402L \u003e\u003e (bVar4 \u0026 0x3f) \u0026 1U) !\u003d 0)) {\n        uVar1 \u003d dcgettext(0,\"%s:%d: Ignoring rubbish found on this line\",5);\n        non_fatal(uVar1,in_stack_00000008,unaff_EBP);\n      }\n    }\nLAB_00114599:\n    *pbVar6 \u003d 0;\n    if (unaff_R15 \u003c pbVar6) {\n      ppbVar2 \u003d (byte **)htab_find_slot();\n      *ppbVar2 \u003d unaff_R15;\n    }\n    unaff_EBP \u003d unaff_EBP + 1;\n    unaff_R14 \u003d pbVar5;\n    unaff_R15 \u003d pbVar5;\n    if (pbVar7[1] \u003d\u003d 0) {\n      *in_stack_00000010 \u003d unaff_R13;\n      return;\n    }\n  } while( true );\n  if (bVar4 \u003d\u003d 0x23) {\n    FUN_00104d1c();\n    return;\n  }\n  goto LAB_00114520;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104cc1"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "copy_file.cold": {
      "entrypoint": "0x00104d25",
      "current_name": "copy_file.cold",
      "code": "\nvoid copy_file_cold(void)\n\n{\n  undefined8 param_7;\n  \n  status \u003d 1;\n  bfd_nonfatal_message(0,param_7,0,0);\n  FUN_00114b84();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_file"
      ],
      "called": [
        "FUN_00114b84",
        "bfd_nonfatal_message"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00104ea2": {
      "entrypoint": "0x00104ea2",
      "current_name": "FUN_00104ea2",
      "code": "\nvoid FUN_00104ea2(void)\n\n{\n  char cVar1;\n  int iVar2;\n  char **ppcVar3;\n  void *pvVar4;\n  long lVar5;\n  char **ppcVar6;\n  char *pcVar7;\n  undefined8 *puVar8;\n  int *piVar9;\n  char *pcVar10;\n  undefined8 uVar11;\n  long lVar12;\n  code *pcVar13;\n  long lVar14;\n  int unaff_EBX;\n  stat *unaff_RBP;\n  char *pcVar15;\n  stat *psVar16;\n  char *unaff_R12;\n  undefined8 *unaff_R13;\n  char **unaff_R15;\n  byte bVar17;\n  undefined8 unaff_retaddr;\n  undefined8 *param_7;\n  long *param_8;\n  char *param_9;\n  undefined8 *param_10;\n  undefined8 param_11;\n  undefined8 in_stack_00000030;\n  uint param_18;\n  long param_19;\n  \n  bVar17 \u003d 0;\ncode_r0x00104ea2:\n  ppcVar6 \u003d (char **)bfd_openw(unaff_R12,param_11);\n  if (ppcVar6 \u003d\u003d (char **)0x0) {\nLAB_00104e80:\n    bfd_nonfatal_message(unaff_R12,0,0,0);\nLAB_00104e93:\n    status \u003d 1;\n  }\n  else {\nLAB_00114a5f:\n    cVar1 \u003d copy_object(unaff_R15,ppcVar6,unaff_retaddr);\n    if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n      iVar2 \u003d bfd_get_arch(unaff_R15);\n      if (iVar2 \u003d\u003d 0) goto LAB_00104d75;\n      cVar1 \u003d bfd_close_all_done(ppcVar6);\n      if (cVar1 !\u003d \u0027\\0\u0027) goto LAB_00104ec9;\n      bfd_nonfatal_message(unaff_R12,0,0,0);\n      goto LAB_00104ec9;\n    }\n    cVar1 \u003d bfd_close(ppcVar6);\n    ppcVar6 \u003d unaff_R15;\n    if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n      bfd_nonfatal_message(unaff_R12,0,0,0);\n      status \u003d 1;\n    }\nLAB_00114a86:\n    if ((preserve_dates !\u003d \u0027\\0\u0027) \u0026\u0026 (unaff_EBX \u003d\u003d 0)) {\n      set_times(unaff_R12,unaff_RBP);\n    }\n    lVar12 \u003d bfd_openr(unaff_R12,param_11);\n    unaff_R13[2] \u003d lVar12;\n    *param_8 \u003d lVar12;\n    param_8 \u003d (long *)(lVar12 + 0xf0);\n    unaff_R15 \u003d (char **)bfd_openr_next_archived_file(param_10,ppcVar6);\n    bfd_close(ppcVar6);\n    while ((status \u003d\u003d 0 \u0026\u0026 (unaff_R15 !\u003d (char **)0x0))) {\n      pcVar10 \u003d *unaff_R15;\n      pcVar7 \u003d pcVar10;\n      if (*pcVar10 \u003d\u003d \u0027/\u0027) {\nLAB_0010527d:\n        uVar11 \u003d dcgettext(0,\"illegal pathname found in archive member: %s\",5);\n        non_fatal(uVar11,pcVar10);\n        goto LAB_00104e93;\n      }\n      while (*pcVar7 !\u003d \u0027\\0\u0027) {\n        pcVar15 \u003d pcVar7;\n        if ((*pcVar7 \u003d\u003d \u0027.\u0027) \u0026\u0026 (pcVar15 \u003d pcVar7 + 1, pcVar7[1] \u003d\u003d \u0027.\u0027)) {\n          pcVar15 \u003d pcVar7 + 2;\n          if ((pcVar7[2] \u003d\u003d \u0027\\0\u0027) || (pcVar7[2] \u003d\u003d \u0027/\u0027)) goto LAB_0010527d;\n        }\n        for (; (*pcVar15 !\u003d \u0027\\0\u0027 \u0026\u0026 (*pcVar15 !\u003d \u0027/\u0027)); pcVar15 \u003d pcVar15 + 1) {\n        }\n        pcVar7 \u003d pcVar15;\n        if (*pcVar15 \u003d\u003d \u0027/\u0027) {\n          FUN_001052a2();\n          return;\n        }\n      }\n      unaff_RBP \u003d (stat *)\u0026stack0x00000050;\n      unaff_R12 \u003d (char *)concat(param_9,\u0026DAT_0011b47d);\n      iVar2 \u003d stat(unaff_R12,unaff_RBP);\n      puVar8 \u003d unaff_R13;\n      if (-1 \u003c iVar2) {\n        lVar12 \u003d make_tempdir(unaff_R12);\n        free(unaff_R12);\n        if (lVar12 \u003d\u003d 0) {\n          piVar9 \u003d __errno_location();\n          pcVar10 \u003d strerror(*piVar9);\n          uVar11 \u003d dcgettext(0,\"cannot create tempdir for archive copying (error: %s)\",5);\n          non_fatal(uVar11,pcVar10);\n          goto LAB_00104e93;\n        }\n        puVar8 \u003d (undefined8 *)xmalloc(0x18);\n        pcVar10 \u003d *unaff_R15;\n        *puVar8 \u003d unaff_R13;\n        puVar8[2] \u003d 0;\n        puVar8[1] \u003d lVar12;\n        unaff_R12 \u003d (char *)concat(lVar12,\u0026DAT_0011b47d,pcVar10);\n      }\n      unaff_EBX \u003d 0;\n      if (preserve_dates !\u003d \u0027\\0\u0027) {\n        psVar16 \u003d unaff_RBP;\n        for (lVar12 \u003d 0x24; lVar12 !\u003d 0; lVar12 \u003d lVar12 + -1) {\n          *(undefined4 *)\u0026psVar16-\u003est_dev \u003d 0;\n          psVar16 \u003d (stat *)((long)psVar16 + (ulong)bVar17 * -8 + 4);\n        }\n        ppcVar6 \u003d (char **)unaff_R15[0x1d];\n        if ((char **)unaff_R15[0x1d] \u003d\u003d (char **)0x0) {\n          ppcVar6 \u003d unaff_R15;\n        }\n        unaff_EBX \u003d (**(code **)(ppcVar6[1] + 0x1e8))(unaff_R15,unaff_RBP);\n        if (unaff_EBX !\u003d 0) {\n          pcVar10 \u003d *unaff_R15;\n          uVar11 \u003d dcgettext(0,\"internal stat error on %s\",5);\n          non_fatal(uVar11,pcVar10);\n        }\n      }\n      unaff_R13 \u003d (undefined8 *)xmalloc(0x18);\n      unaff_R13[1] \u003d unaff_R12;\n      *unaff_R13 \u003d puVar8;\n      unaff_R13[2] \u003d 0;\n      cVar1 \u003d bfd_check_format(unaff_R15,1);\n      if (cVar1 !\u003d \u0027\\0\u0027) {\n        if (in_stack_00000030._7_1_ !\u003d \u0027\\0\u0027) goto code_r0x00104ea2;\n        ppcVar6 \u003d (char **)bfd_openw(unaff_R12,*(undefined8 *)unaff_R15[1]);\n        if (ppcVar6 \u003d\u003d (char **)0x0) goto LAB_00104e80;\n        goto LAB_00114a5f;\n      }\n      uVar11 \u003d dcgettext(0,\"Unable to recognise the format of file\",5);\n      bfd_nonfatal_message(0,unaff_R15,0,uVar11);\n      ppcVar6 \u003d (char **)bfd_openw(unaff_R12,param_11);\n      if (ppcVar6 \u003d\u003d (char **)0x0) goto LAB_00104e80;\nLAB_00104d75:\n      ppcVar3 \u003d (char **)unaff_R15[0x1d];\n      if ((char **)unaff_R15[0x1d] \u003d\u003d (char **)0x0) {\n        ppcVar3 \u003d unaff_R15;\n      }\n      iVar2 \u003d (**(code **)(ppcVar3[1] + 0x1e8))(unaff_R15);\n      lVar12 \u003d param_19;\n      if (iVar2 \u003d\u003d 0) {\n        if (param_19 \u003c 0) {\n          bfd_get_archive_filename(unaff_R15);\n          uVar11 \u003d dcgettext(0,\"stat returns negative size for `%s\\\u0027\",5);\n          non_fatal(uVar11);\n        }\n        else {\n          iVar2 \u003d bfd_seek(unaff_R15,0,0);\n          if (iVar2 \u003d\u003d 0) {\n            if (verbose !\u003d \u0027\\0\u0027) {\n              pcVar10 \u003d *ppcVar6;\n              uVar11 \u003d bfd_get_archive_filename(unaff_R15);\n              pcVar7 \u003d (char *)dcgettext(0,\"copy from `%s\\\u0027 [unknown] to `%s\\\u0027 [unknown]\\n\",5);\n              printf(pcVar7,uVar11,pcVar10);\n            }\n            pvVar4 \u003d (void *)xmalloc(0x2000);\n            while( true ) {\n              if (lVar12 \u003d\u003d 0) {\n                chmod(*ppcVar6,param_18 | 0x100);\n                free(pvVar4);\n                cVar1 \u003d bfd_close_all_done(ppcVar6);\n                ppcVar6 \u003d unaff_R15;\n                if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n                  bfd_nonfatal_message(unaff_R12,0,0,0);\n                  status \u003d 1;\n                }\n                goto LAB_00114a86;\n              }\n              lVar14 \u003d 0x2000;\n              if (lVar12 \u003c 0x2001) {\n                lVar14 \u003d lVar12;\n              }\n              lVar5 \u003d bfd_bread(pvVar4,lVar14,unaff_R15);\n              ppcVar3 \u003d unaff_R15;\n              if ((lVar14 !\u003d lVar5) ||\n                 (lVar5 \u003d bfd_bwrite(pvVar4,lVar14,ppcVar6), ppcVar3 \u003d ppcVar6, lVar14 !\u003d lVar5))\n              break;\n              lVar12 \u003d lVar12 - lVar14;\n            }\n            bfd_nonfatal_message(0,ppcVar3,0,0);\n            free(pvVar4);\n          }\n          else {\n            uVar11 \u003d bfd_get_archive_filename(unaff_R15);\n            bfd_nonfatal(uVar11);\n          }\n        }\n      }\n      else {\n        bfd_nonfatal_message(0,unaff_R15,0,0);\n      }\n      cVar1 \u003d bfd_close_all_done(ppcVar6);\n      if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n        bfd_nonfatal_message(unaff_R12,0,0,0);\n      }\nLAB_00104ec9:\n      unlink(unaff_R12);\n      status \u003d 1;\n    }\n    *param_8 \u003d 0;\n    pvVar4 \u003d (void *)xstrdup(*param_7);\n    if (status \u003d\u003d 0) {\n      pcVar13 \u003d bfd_close;\n    }\n    else {\n      pcVar13 \u003d bfd_close_all_done;\n    }\n    cVar1 \u003d (*pcVar13)(param_7);\n    if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n      status \u003d 1;\n      bfd_nonfatal_message(pvVar4,0,0,0);\n    }\n    free(pvVar4);\n    pvVar4 \u003d (void *)xstrdup(*param_10);\n    cVar1 \u003d bfd_close(param_10);\n    if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n      status \u003d 1;\n      bfd_nonfatal_message(pvVar4,0,0,0);\n    }\n    free(pvVar4);\n  }\n  while (unaff_R13 !\u003d (undefined8 *)0x0) {\n    if (unaff_R13[2] \u003d\u003d 0) {\n      rmdir((char *)unaff_R13[1]);\n    }\n    else {\n      bfd_close();\n      unlink((char *)unaff_R13[1]);\n    }\n    free((void *)unaff_R13[1]);\n    puVar8 \u003d (undefined8 *)*unaff_R13;\n    free(unaff_R13);\n    unaff_R13 \u003d puVar8;\n  }\n  rmdir(param_9);\n  free(param_9);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104ea2"
      ],
      "called": [
        "bfd_seek",
        "free",
        "bfd_bread",
        "unlink",
        "bfd_openr",
        "set_times",
        "printf",
        "strerror",
        "bfd_check_format",
        "__errno_location",
        "bfd_get_archive_filename",
        "concat",
        "bfd_close",
        "dcgettext",
        "stat",
        "xmalloc",
        "rmdir",
        "non_fatal",
        "bfd_close",
        "bfd_nonfatal",
        "make_tempdir",
        "FUN_00104ea2",
        "FUN_00114b84",
        "bfd_openw",
        "bfd_openr_next_archived_file",
        "chmod",
        "bfd_close_all_done",
        "bfd_bwrite",
        "bfd_close_all_done",
        "FUN_001052a2",
        "xstrdup",
        "copy_object",
        "bfd_nonfatal_message",
        "bfd_get_arch"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001052a2": {
      "entrypoint": "0x001052a2",
      "current_name": "FUN_001052a2",
      "code": "\nvoid FUN_001052a2(undefined8 param_1,undefined8 param_2,char *param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  int iVar3;\n  char **ppcVar4;\n  long lVar5;\n  undefined8 uVar6;\n  char *__format;\n  undefined8 *puVar7;\n  int *piVar8;\n  undefined8 uVar9;\n  long in_RAX;\n  char *pcVar10;\n  char **ppcVar11;\n  long lVar12;\n  void *pvVar13;\n  code *pcVar14;\n  long lVar15;\n  char *pcVar16;\n  stat *psVar17;\n  undefined8 *unaff_R14;\n  char **unaff_R15;\n  byte bVar18;\n  undefined8 unaff_retaddr;\n  undefined8 *in_stack_00000008;\n  long *in_stack_00000010;\n  char *in_stack_00000018;\n  undefined8 *in_stack_00000020;\n  undefined8 in_stack_00000028;\n  undefined8 in_stack_00000030;\n  uint in_stack_000000f8;\n  long in_stack_00000110;\n  \n  bVar18 \u003d 0;\n  pcVar10 \u003d (char *)(in_RAX + 1);\n  do {\n    if (*pcVar10 \u003d\u003d \u0027/\u0027) {\n      FUN_001052a2();\n      return;\n    }\n    while (*pcVar10 \u003d\u003d \u0027\\0\u0027) {\n      pcVar10 \u003d (char *)concat(in_stack_00000018,\u0026DAT_0011b47d);\n      iVar3 \u003d stat(pcVar10,(stat *)\u0026stack0x00000050);\n      puVar7 \u003d unaff_R14;\n      if (-1 \u003c iVar3) {\n        lVar12 \u003d make_tempdir(pcVar10);\n        free(pcVar10);\n        if (lVar12 \u003d\u003d 0) {\n          piVar8 \u003d __errno_location();\n          pcVar10 \u003d strerror(*piVar8);\n          uVar9 \u003d dcgettext(0,\"cannot create tempdir for archive copying (error: %s)\",5);\n          non_fatal(uVar9,pcVar10);\n          goto LAB_00104e93;\n        }\n        puVar7 \u003d (undefined8 *)xmalloc(0x18);\n        pcVar10 \u003d *unaff_R15;\n        *puVar7 \u003d unaff_R14;\n        puVar7[2] \u003d 0;\n        puVar7[1] \u003d lVar12;\n        pcVar10 \u003d (char *)concat(lVar12,\u0026DAT_0011b47d,pcVar10);\n      }\n      iVar3 \u003d 0;\n      if (preserve_dates !\u003d \u0027\\0\u0027) {\n        psVar17 \u003d (stat *)\u0026stack0x00000050;\n        for (lVar12 \u003d 0x24; lVar12 !\u003d 0; lVar12 \u003d lVar12 + -1) {\n          *(undefined4 *)\u0026psVar17-\u003est_dev \u003d 0;\n          psVar17 \u003d (stat *)((long)psVar17 + (ulong)bVar18 * -8 + 4);\n        }\n        ppcVar11 \u003d (char **)unaff_R15[0x1d];\n        if ((char **)unaff_R15[0x1d] \u003d\u003d (char **)0x0) {\n          ppcVar11 \u003d unaff_R15;\n        }\n        iVar3 \u003d (**(code **)(ppcVar11[1] + 0x1e8))(unaff_R15,(stat *)\u0026stack0x00000050);\n        if (iVar3 !\u003d 0) {\n          pcVar16 \u003d *unaff_R15;\n          uVar9 \u003d dcgettext(0,\"internal stat error on %s\",5);\n          non_fatal(uVar9,pcVar16);\n        }\n      }\n      unaff_R14 \u003d (undefined8 *)xmalloc(0x18);\n      unaff_R14[1] \u003d pcVar10;\n      *unaff_R14 \u003d puVar7;\n      unaff_R14[2] \u003d 0;\n      cVar1 \u003d bfd_check_format(unaff_R15,1);\n      if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n        uVar9 \u003d dcgettext(0,\"Unable to recognise the format of file\",5);\n        bfd_nonfatal_message(0,unaff_R15,0,uVar9);\n        ppcVar11 \u003d (char **)bfd_openw(pcVar10,in_stack_00000028);\n        if (ppcVar11 \u003d\u003d (char **)0x0) goto LAB_00104e80;\nLAB_00104d75:\n        ppcVar4 \u003d (char **)unaff_R15[0x1d];\n        if ((char **)unaff_R15[0x1d] \u003d\u003d (char **)0x0) {\n          ppcVar4 \u003d unaff_R15;\n        }\n        iVar2 \u003d (**(code **)(ppcVar4[1] + 0x1e8))(unaff_R15,\u0026stack0x000000e0);\n        lVar12 \u003d in_stack_00000110;\n        if (iVar2 \u003d\u003d 0) {\n          if (in_stack_00000110 \u003c 0) {\n            uVar9 \u003d bfd_get_archive_filename(unaff_R15);\n            uVar6 \u003d dcgettext(0,\"stat returns negative size for `%s\\\u0027\",5);\n            non_fatal(uVar6,uVar9);\n          }\n          else {\n            iVar2 \u003d bfd_seek(unaff_R15,0,0);\n            if (iVar2 \u003d\u003d 0) {\n              if (verbose !\u003d \u0027\\0\u0027) {\n                pcVar16 \u003d *ppcVar11;\n                uVar9 \u003d bfd_get_archive_filename(unaff_R15);\n                __format \u003d (char *)dcgettext(0,\"copy from `%s\\\u0027 [unknown] to `%s\\\u0027 [unknown]\\n\",5);\n                printf(__format,uVar9,pcVar16);\n              }\n              pvVar13 \u003d (void *)xmalloc(0x2000);\n              for (; lVar12 !\u003d 0; lVar12 \u003d lVar12 - lVar15) {\n                lVar15 \u003d 0x2000;\n                if (lVar12 \u003c 0x2001) {\n                  lVar15 \u003d lVar12;\n                }\n                lVar5 \u003d bfd_bread(pvVar13,lVar15,unaff_R15);\n                ppcVar4 \u003d unaff_R15;\n                if ((lVar15 !\u003d lVar5) ||\n                   (lVar5 \u003d bfd_bwrite(pvVar13,lVar15,ppcVar11), ppcVar4 \u003d ppcVar11, lVar15 !\u003d lVar5\n                   )) {\n                  bfd_nonfatal_message(0,ppcVar4,0,0);\n                  free(pvVar13);\n                  goto LAB_00104f00;\n                }\n              }\n              chmod(*ppcVar11,in_stack_000000f8 | 0x100);\n              free(pvVar13);\n              cVar1 \u003d bfd_close_all_done(ppcVar11);\n              if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n                bfd_nonfatal_message(pcVar10,0,0,0);\n                status \u003d 1;\n              }\n              goto LAB_00114a86;\n            }\n            uVar9 \u003d bfd_get_archive_filename(unaff_R15);\n            bfd_nonfatal(uVar9);\n          }\n        }\n        else {\n          bfd_nonfatal_message(0,unaff_R15,0,0);\n        }\nLAB_00104f00:\n        cVar1 \u003d bfd_close_all_done(ppcVar11);\n        if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n          bfd_nonfatal_message(pcVar10,0,0,0);\n        }\nLAB_00104ec9:\n        unlink(pcVar10);\n        status \u003d 1;\n      }\n      else {\n        if (in_stack_00000030._7_1_ \u003d\u003d \u0027\\0\u0027) {\n          ppcVar11 \u003d (char **)bfd_openw(pcVar10,*(undefined8 *)unaff_R15[1]);\n        }\n        else {\n          ppcVar11 \u003d (char **)bfd_openw(pcVar10,in_stack_00000028);\n        }\n        if (ppcVar11 \u003d\u003d (char **)0x0) {\nLAB_00104e80:\n          bfd_nonfatal_message(pcVar10,0,0,0);\n          goto LAB_00104e93;\n        }\n        cVar1 \u003d copy_object(unaff_R15,ppcVar11,unaff_retaddr);\n        if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n          iVar2 \u003d bfd_get_arch(unaff_R15);\n          if (iVar2 \u003d\u003d 0) goto LAB_00104d75;\n          cVar1 \u003d bfd_close_all_done(ppcVar11);\n          if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n            bfd_nonfatal_message(pcVar10,0,0,0);\n          }\n          goto LAB_00104ec9;\n        }\n        cVar1 \u003d bfd_close(ppcVar11);\n        if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n          bfd_nonfatal_message(pcVar10,0,0,0);\n          status \u003d 1;\n        }\nLAB_00114a86:\n        if ((preserve_dates !\u003d \u0027\\0\u0027) \u0026\u0026 (iVar3 \u003d\u003d 0)) {\n          set_times(pcVar10,(stat *)\u0026stack0x00000050);\n        }\n        lVar12 \u003d bfd_openr(pcVar10,in_stack_00000028);\n        unaff_R14[2] \u003d lVar12;\n        *in_stack_00000010 \u003d lVar12;\n        in_stack_00000010 \u003d (long *)(lVar12 + 0xf0);\n        ppcVar11 \u003d (char **)bfd_openr_next_archived_file(in_stack_00000020,unaff_R15);\n        bfd_close(unaff_R15);\n        unaff_R15 \u003d ppcVar11;\n      }\n      if ((status !\u003d 0) || (unaff_R15 \u003d\u003d (char **)0x0)) {\n        *in_stack_00000010 \u003d 0;\n        pvVar13 \u003d (void *)xstrdup(*in_stack_00000008);\n        if (status \u003d\u003d 0) {\n          pcVar14 \u003d bfd_close;\n        }\n        else {\n          pcVar14 \u003d bfd_close_all_done;\n        }\n        cVar1 \u003d (*pcVar14)(in_stack_00000008);\n        if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n          status \u003d 1;\n          bfd_nonfatal_message(pvVar13,0,0,0);\n        }\n        free(pvVar13);\n        pvVar13 \u003d (void *)xstrdup(*in_stack_00000020);\n        cVar1 \u003d bfd_close(in_stack_00000020);\n        if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n          status \u003d 1;\n          bfd_nonfatal_message(pvVar13,0,0,0);\n        }\n        free(pvVar13);\n        goto LAB_00114b4b;\n      }\n      pcVar10 \u003d *unaff_R15;\n      param_3 \u003d pcVar10;\n      if (*pcVar10 \u003d\u003d \u0027/\u0027) goto LAB_0010527d;\n    }\n    pcVar16 \u003d pcVar10;\n    if ((*pcVar10 \u003d\u003d \u0027.\u0027) \u0026\u0026 (pcVar16 \u003d pcVar10 + 1, pcVar10[1] \u003d\u003d \u0027.\u0027)) {\n      pcVar16 \u003d pcVar10 + 2;\n      if ((pcVar10[2] \u003d\u003d \u0027\\0\u0027) || (pcVar10[2] \u003d\u003d \u0027/\u0027)) {\nLAB_0010527d:\n        uVar9 \u003d dcgettext(0,\"illegal pathname found in archive member: %s\",5);\n        non_fatal(uVar9,param_3);\nLAB_00104e93:\n        status \u003d 1;\nLAB_00114b4b:\n        while (unaff_R14 !\u003d (undefined8 *)0x0) {\n          if (unaff_R14[2] \u003d\u003d 0) {\n            rmdir((char *)unaff_R14[1]);\n          }\n          else {\n            bfd_close();\n            unlink((char *)unaff_R14[1]);\n          }\n          free((void *)unaff_R14[1]);\n          puVar7 \u003d (undefined8 *)*unaff_R14;\n          free(unaff_R14);\n          unaff_R14 \u003d puVar7;\n        }\n        rmdir(in_stack_00000018);\n        free(in_stack_00000018);\n        return;\n      }\n    }\n    for (; (pcVar10 \u003d pcVar16, *pcVar16 !\u003d \u0027\\0\u0027 \u0026\u0026 (*pcVar16 !\u003d \u0027/\u0027)); pcVar16 \u003d pcVar16 + 1) {\n    }\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104ea2"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "init_section_add.cold": {
      "entrypoint": "0x001053b5",
      "current_name": "init_section_add.cold",
      "code": "\nvoid init_section_add_cold(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 \u003d dcgettext(0,\"bad format for %s\",5);\n                    \n  fatal(uVar1);\n}\n\n",
      "renaming": {},
      "calling": [
        "init_section_add"
      ],
      "called": [
        "dcgettext",
        "fatal"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "do_display_target.cold": {
      "entrypoint": "0x001053d5",
      "current_name": "do_display_target.cold",
      "code": "\nundefined4 do_display_target_cold(void)\n\n{\n  long unaff_R12;\n  undefined8 *unaff_R14;\n  \n  bfd_nonfatal(*unaff_R14);\n  *(undefined4 *)(unaff_R12 + 8) \u003d 1;\n  bfd_close_all_done();\n  return *(undefined4 *)(unaff_R12 + 8);\n}\n\n",
      "renaming": {},
      "calling": [
        "do_display_target"
      ],
      "called": [
        "bfd_nonfatal"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "set_long_section_mode.cold": {
      "entrypoint": "0x0010540e",
      "current_name": "set_long_section_mode.cold",
      "code": "\nvoid set_long_section_mode_cold(undefined8 param_1,long param_2,uint param_3)\n\n{\n  long in_RAX;\n  \n  if ((param_3 \u003d\u003d 2) \u0026\u0026 (*(int *)(*(long *)(param_2 + 8) + 8) \u003d\u003d 2)) {\n    param_3 \u003d (uint)*(byte *)(*(long *)(*(long *)(param_2 + 8) + 0x380) + 0x71);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00105422. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (**(code **)(*(long *)(in_RAX + 0x380) + 0x78))(param_1,param_3 !\u003d 0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "set_long_section_mode"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "section_add_load_file.cold": {
      "entrypoint": "0x0010543c",
      "current_name": "section_add_load_file.cold",
      "code": "\nvoid section_add_load_file_cold(void)\n\n{\n  undefined8 uVar1;\n  int *piVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  long unaff_RBP;\n  \n  piVar2 \u003d __errno_location();\n  pcVar3 \u003d strerror(*piVar2);\n  uVar1 \u003d *(undefined8 *)(unaff_RBP + 0x10);\n  uVar4 \u003d dcgettext(0,\"cannot open: %s: %s\",5);\n                    \n  fatal(uVar4,uVar1,pcVar3);\n}\n\n",
      "renaming": {},
      "calling": [
        "section_add_load_file"
      ],
      "called": [
        "dcgettext",
        "fatal",
        "strerror",
        "__errno_location"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "delete_symbol_htabs": {
      "entrypoint": "0x001054af",
      "current_name": "delete_symbol_htabs",
      "code": "\nvoid delete_symbol_htabs(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 in_RAX;\n  \n  htab_delete(strip_specific_htab);\n  htab_delete(strip_unneeded_htab);\n  htab_delete(keep_specific_htab);\n  htab_delete(localize_specific_htab);\n  htab_delete(globalize_specific_htab);\n  htab_delete(keepglobal_specific_htab);\n  htab_delete(weaken_specific_htab);\n  htab_delete(redefine_specific_htab);\n  htab_delete(redefine_specific_reverse_htab,param_2,in_RAX);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "htab_delete"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "copy_object.cold": {
      "entrypoint": "0x0010551d",
      "current_name": "copy_object.cold",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong copy_object_cold(void)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  undefined *puVar3;\n  code *pcVar4;\n  undefined8 *puVar5;\n  ulong uVar6;\n  ulong uVar7;\n  char *__s;\n  char cVar8;\n  char cVar9;\n  uint uVar10;\n  int iVar11;\n  uint uVar12;\n  undefined4 uVar13;\n  int iVar14;\n  long *plVar15;\n  undefined8 uVar16;\n  undefined8 uVar17;\n  size_t sVar18;\n  char *pcVar19;\n  void *__ptr;\n  void *__ptr_00;\n  ulong uVar20;\n  long lVar21;\n  ulong uVar22;\n  int *piVar23;\n  ulong uVar24;\n  long lVar25;\n  FILE *__s_00;\n  size_t sVar26;\n  long lVar27;\n  long *unaff_RBX;\n  char *pcVar28;\n  undefined8 *puVar29;\n  ulong uVar30;\n  int iVar31;\n  long unaff_RBP;\n  long *plVar32;\n  char *pcVar33;\n  undefined4 *puVar34;\n  char **ppcVar35;\n  long *unaff_R13;\n  void *pvVar36;\n  undefined8 *unaff_R14;\n  undefined **ppuVar37;\n  bool bVar38;\n  byte bVar39;\n  long in_stack_00000008;\n  ulong in_stack_00000010;\n  char in_stack_00000018;\n  undefined4 *puStack0000000000000020;\n  char *pcStack0000000000000038;\n  uint uStack0000000000000048;\n  int iStack000000000000006c;\n  long lStack0000000000000078;\n  long lStack0000000000000088;\n  char *pcStack0000000000000090;\n  long lStack00000000000000a0;\n  long *in_stack_000000c0;\n  ulong in_stack_000000c8;\n  long in_stack_000000d0;\n  long in_stack_000000d8;\n  void *in_stack_000000e0;\n  long in_stack_000000f0;\n  undefined8 in_stack_000000f8;\n  byte bStack0000000000000100;\n  byte bStack0000000000000101;\n  undefined8 in_stack_00000110;\n  ushort in_stack_00000118;\n  char *in_stack_00000140;\n  char cStack0000000000000148;\n  char *in_stack_00000150;\n  undefined uStack0000000000000158;\n  short sStack000000000000015a;\n  \n  bVar39 \u003d 0;\ncode_r0x0010551d:\n  dcgettext(0,\"warning: could not load note section\",5);\n  bfd_nonfatal_message(0);\n  free(unaff_RBX);\nLAB_001151a2:\n  unaff_RBP \u003d *(long *)(unaff_RBP + 8);\n  puVar29 \u003d dump_sections;\n  if (unaff_RBP \u003d\u003d 0) goto joined_r0x001151c7;\n  if (merge_notes !\u003d \u0027\\0\u0027) {\n    if ((((*(int *)(unaff_R14[1] + 8) !\u003d 5) || (*(int *)(*(long *)(unaff_RBP + 0xd0) + 4) !\u003d 7)) ||\n        (cVar9 \u003d startswith_lto_priv_0_lto_priv_0(), cVar9 \u003d\u003d \u0027\\0\u0027)) ||\n       ((*(long *)(unaff_RBP + 0x60) \u003d\u003d 0 || (lVar25 \u003d *(long *)(unaff_RBP + 0x40), lVar25 \u003d\u003d 0))))\n    goto LAB_001151a2;\n    unaff_RBX \u003d (long *)xmalloc(0x20);\n    unaff_RBX[1] \u003d 0;\n    cVar9 \u003d bfd_get_full_section_contents();\n    if (cVar9 !\u003d \u0027\\0\u0027) {\n      lVar27 \u003d merge_gnu_build_notes();\n      unaff_RBX[2] \u003d lVar27;\n      if ((lVar27 \u003d\u003d lVar25) || (cVar9 \u003d bfd_set_section_size(), cVar9 !\u003d \u0027\\0\u0027)) {\n        unaff_RBX[3] \u003d (long)unaff_R13;\n        *unaff_RBX \u003d unaff_RBP;\n        unaff_R13 \u003d unaff_RBX;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        bfd_nonfatal_message(0,in_stack_00000008,unaff_RBP);\n        free((void *)unaff_RBX[1]);\n        free(unaff_RBX);\n      }\n      goto LAB_001151a2;\n    }\n    goto code_r0x0010551d;\n  }\n  for (lVar25 \u003d *(long *)(unaff_RBP + 8); lVar25 !\u003d 0; lVar25 \u003d *(long *)(lVar25 + 8)) {\n  }\njoined_r0x001151c7:\n  for (; puVar29 !\u003d (undefined8 *)0x0; puVar29 \u003d (undefined8 *)*puVar29) {\n    lVar25 \u003d bfd_get_section_by_name();\n    if (lVar25 \u003d\u003d 0) {\n      dcgettext(0,\"can\\\u0027t dump section \\\u0027%s\\\u0027 - it does not exist\",5);\n      bfd_nonfatal_message(0);\n    }\n    else if ((*(byte *)(lVar25 + 0x25) \u0026 1) \u003d\u003d 0) {\n      dcgettext(0,\"can\\\u0027t dump section - it has no contents\",5);\n      bfd_nonfatal_message(0);\n    }\n    else {\n      sVar18 \u003d *(size_t *)(lVar25 + 0x40);\n      __s_00 \u003d fopen((char *)puVar29[2],\"w\");\n      if (__s_00 \u003d\u003d (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        bfd_nonfatal_message(puVar29[2],0,0);\n      }\n      else {\n        cVar9 \u003d bfd_malloc_and_get_section();\n        if (cVar9 \u003d\u003d \u0027\\0\u0027) {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          bfd_nonfatal_message(0);\n        }\n        else if ((sVar18 !\u003d 0) \u0026\u0026\n                (sVar26 \u003d fwrite(in_stack_00000140,1,sVar18,__s_00), sVar26 !\u003d sVar18)) {\n          piVar23 \u003d __errno_location();\n          pcVar33 \u003d strerror(*piVar23);\n          uVar17 \u003d puVar29[2];\n          uVar16 \u003d dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          non_fatal(uVar16,uVar17,pcVar33);\n          free(in_stack_00000140);\n          fclose(__s_00);\n          return 0;\n        }\n        fclose(__s_00);\n        free(in_stack_00000140);\n      }\n    }\n  }\n  if (gnu_debuglink_filename \u003d\u003d 0) {\nLAB_0010790a:\n    lStack0000000000000078 \u003d 0;\n  }\n  else {\n    lVar25 \u003d bfd_get_section_by_name(in_stack_00000008,\".gnu_debuglink\");\n    if (lVar25 !\u003d 0) {\n      uVar17 \u003d dcgettext(0,\"%s: debuglink section already exists\",5);\n      non_fatal(uVar17);\n      gnu_debuglink_filename \u003d 0;\n      goto LAB_0010790a;\n    }\n    lStack0000000000000078 \u003d bfd_create_gnu_debuglink_section(in_stack_00000008);\n    lVar25 \u003d gnu_debuglink_filename;\n    if (lStack0000000000000078 \u003d\u003d 0) {\n      uVar17 \u003d dcgettext(0,\"cannot create debug link section `%s\\\u0027\",5);\n      bfd_nonfatal_message(0,in_stack_00000008,0,uVar17,lVar25);\n      return 0;\n    }\n    if (*(int *)(*(long *)(in_stack_00000008 + 8) + 8) \u003d\u003d 2) {\n      uVar20 \u003d 0;\n      for (uVar24 \u003d *(ulong *)(in_stack_00000008 + 0x90); uVar24 !\u003d 0;\n          uVar24 \u003d *(ulong *)(uVar24 + 8)) {\n        uVar22 \u003d *(ulong *)(uVar24 + 0x30);\n        uVar30 \u003d uVar20;\n        uVar6 \u003d uVar24;\n        uVar7 \u003d uVar20;\n        if (uVar22 !\u003d 0) {\n          while ((uVar30 \u003d uVar6, uVar7 !\u003d 0 \u0026\u0026\n                 (uVar30 \u003d uVar24, uVar22 \u003c\u003d *(ulong *)(uVar20 + 0x30)))) {\n            uVar24 \u003d *(ulong *)(uVar24 + 8);\n            if (uVar24 \u003d\u003d 0) goto LAB_00107db8;\n            uVar22 \u003d *(ulong *)(uVar24 + 0x30);\n            uVar6 \u003d uVar20;\n            uVar7 \u003d uVar22;\n          }\n        }\n        uVar20 \u003d uVar30;\n      }\nLAB_00107db8:\n      if (uVar20 \u003d\u003d 0) {\n        uVar24 \u003d 0x1000;\n      }\n      else {\n        uVar20 \u003d *(long *)(uVar20 + 0x40) + *(long *)(uVar20 + 0x30);\n        uVar24 \u003d 0xffffffffffffffff;\n        if (uVar20 \u003c 0xfffffffffffff001) {\n          uVar24 \u003d uVar20 + 0xfff \u0026 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(lStack0000000000000078 + 0x28) \u003d *(byte *)(lStack0000000000000078 + 0x28) | 1;\n      *(ulong *)(lStack0000000000000078 + 0x30) \u003d uVar24;\n      *(ulong *)(lStack0000000000000078 + 0x38) \u003d uVar24;\n    }\n  }\n  plVar32 \u003d isympp;\n  iStack000000000000006c \u003d *(int *)(in_stack_00000008 + 0xa0);\n  if (iStack000000000000006c !\u003d 0) {\n    uVar24 \u003d FUN_0010554f();\n    return uVar24;\n  }\n  if (convert_debugging \u003d\u003d \u0027\\0\u0027) {\nLAB_00105588:\n    puStack0000000000000020 \u003d (undefined4 *)0x0;\n  }\n  else {\n    ppuVar37 \u003d \u0026names_0;\n    puStack0000000000000020 \u003d (undefined4 *)xmalloc(0x60);\n    puVar34 \u003d puStack0000000000000020;\n    for (lVar25 \u003d 0x18; lVar25 !\u003d 0; lVar25 \u003d lVar25 + -1) {\n      *puVar34 \u003d 0;\n      puVar34 \u003d puVar34 + (ulong)bVar39 * -2 + 1;\n    }\n    pcStack0000000000000038 \u003d (char *)0x0;\n    do {\n      puVar3 \u003d *ppuVar37;\n      lVar25 \u003d bfd_get_section_by_name();\n      lVar27 \u003d bfd_get_section_by_name();\n      if ((lVar25 !\u003d 0) \u0026\u0026 (lVar27 !\u003d 0)) {\n        lVar25 \u003d *(long *)(lVar25 + 0x40);\n        __ptr \u003d (void *)xmalloc(lVar25);\n        cVar9 \u003d bfd_get_section_contents();\n        if (cVar9 \u003d\u003d \u0027\\0\u0027) {\n          uVar13 \u003d bfd_get_error();\n          bfd_errmsg(uVar13);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n          free(pcStack0000000000000038);\n          free(__ptr);\n        }\n        else {\n          uVar24 \u003d *(ulong *)(lVar27 + 0x40);\n          __ptr_00 \u003d (void *)xmalloc(uVar24 + 1);\n          in_stack_00000018 \u003d bfd_get_section_contents();\n          if (in_stack_00000018 \u003d\u003d \u0027\\0\u0027) {\n            uVar13 \u003d bfd_get_error();\n            bfd_errmsg(uVar13);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n            free(pcStack0000000000000038);\n          }\n          else {\n            *(undefined *)((long)__ptr_00 + uVar24) \u003d 0;\n            if ((pcStack0000000000000038 !\u003d (char *)0x0) ||\n               (pcStack0000000000000038 \u003d (char *)start_stab_constprop_0(),\n               pcStack0000000000000038 !\u003d (char *)0x0)) {\n              lStack00000000000000a0 \u003d 0;\n              lStack0000000000000088 \u003d 0;\n              for (pvVar36 \u003d __ptr; pvVar36 \u003c\u003d (void *)((long)__ptr + lVar25 + -0xc);\n                  pvVar36 \u003d (void *)((long)pvVar36 + 0xc)) {\n                uVar20 \u003d (**(code **)(unaff_R14[1] + 0x40))(pvVar36);\n                bVar2 \u003d *(byte *)((long)pvVar36 + 4);\n                uVar13 \u003d (**(code **)(unaff_R14[1] + 0x58))((long)pvVar36 + 6);\n                lVar27 \u003d (**(code **)(unaff_R14[1] + 0x40))((long)pvVar36 + 8);\n                if (bVar2 \u003d\u003d 0) {\n                  lStack0000000000000088 \u003d lStack00000000000000a0;\n                  lStack00000000000000a0 \u003d lStack00000000000000a0 + lVar27;\n                }\n                else {\n                  uVar22 \u003d (uVar20 \u0026 0xffffffff) + lStack0000000000000088;\n                  if (uVar22 \u003c uVar24) {\n                    pcVar33 \u003d (char *)((long)__ptr_00 + uVar22);\n                    pcStack0000000000000090 \u003d (char *)0x0;\n                    while( true ) {\n                      sVar18 \u003d strlen(pcVar33);\n                      if (((sVar18 \u003d\u003d 0) || (pcVar28 \u003d pcVar33 + (sVar18 - 1), *pcVar28 !\u003d \u0027\\\\\u0027)) ||\n                         ((ulong)((long)__ptr + lVar25) \u003c (long)pvVar36 + 0x10U)) goto LAB_001077fb;\n                      *pcVar28 \u003d \u0027\\0\u0027;\n                      pvVar36 \u003d (void *)((long)pvVar36 + 0xc);\n                      iVar11 \u003d (**(code **)(unaff_R14[1] + 0x40))(pvVar36);\n                      uVar20 \u003d (ulong)(uint)(iVar11 + (int)lStack0000000000000088);\n                      if (uVar24 \u003c\u003d uVar20) break;\n                      pcVar33 \u003d (char *)concat(pcVar33,(long)__ptr_00 + uVar20,0);\n                      *pcVar28 \u003d \u0027\\\\\u0027;\n                      free(pcStack0000000000000090);\n                      pcStack0000000000000090 \u003d pcVar33;\n                    }\n                    uVar17 \u003d *unaff_R14;\n                    pcVar28 \u003d (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar28,uVar17,puVar3,((long)pvVar36 - (long)__ptr) / 0xc);\nLAB_001077fb:\n                    save_stab((ulong)bVar2,uVar13,lVar27,pcVar33);\n                    cVar9 \u003d parse_stab(puStack0000000000000020,pcStack0000000000000038,bVar2);\n                    if (cVar9 \u003d\u003d \u0027\\0\u0027) {\n                      stab_context();\n                      free_saved_stabs();\n                      free(pcStack0000000000000090);\n                      free(pcStack0000000000000038);\n                      free(__ptr);\n                      free(__ptr_00);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar17 \u003d *unaff_R14;\n                    pcVar33 \u003d (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx \u003d 0x%x, type \u003d %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar33,uVar17,puVar3,((long)pvVar36 - (long)__ptr) / 0xc,\n                            uVar20 \u0026 0xffffffff,(ulong)bVar2,((long)pvVar36 - (long)__ptr) % 0xc);\n                  }\n                }\n              }\n              free_saved_stabs();\n              free(__ptr);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_00);\n          free(__ptr);\n        }\nLAB_00105981:\n        free(puStack0000000000000020);\n        goto LAB_00105588;\n      }\nLAB_001058eb:\n      ppuVar37 \u003d ppuVar37 + 2;\n    } while (ppuVar37 !\u003d (undefined **)\u0026DAT_00125c90);\n    if ((pcStack0000000000000038 !\u003d (char *)0x0) \u0026\u0026 (cVar9 \u003d finish_stab(), cVar9 \u003d\u003d \u0027\\0\u0027))\n    goto LAB_00105981;\n    if (*(int *)(unaff_R14[1] + 8) \u003d\u003d 1) {\n      lVar25 \u003d 0;\n      for (plVar15 \u003d plVar32; plVar15 \u003c plVar32 + in_stack_00000010; plVar15 \u003d plVar15 + 1) {\n        (**(code **)(unaff_R14[1] + 0x218))();\n        if (cStack0000000000000148 \u003d\u003d \u0027-\u0027) {\n          if (((lVar25 !\u003d 0) || (lVar25 \u003d start_stab_constprop_0(), lVar25 !\u003d 0)) \u0026\u0026\n             ((in_stack_00000150 !\u003d (char *)0x0 \u0026\u0026 (*in_stack_00000150 !\u003d \u0027\\0\u0027)))) {\n            pcVar33 \u003d (char *)0x0;\n            pcVar28 \u003d in_stack_00000150;\n            while (((*pcVar28 !\u003d \u0027\\0\u0027 \u0026\u0026 (sVar18 \u003d strlen(pcVar28), pcVar28[sVar18 - 1] \u003d\u003d \u0027\\\\\u0027)) \u0026\u0026\n                   (plVar15 + 1 \u003c plVar32 + in_stack_00000010))) {\n              pcVar19 \u003d (char *)xstrdup(pcVar28);\n              sVar18 \u003d strlen(pcVar19);\n              pcVar19[sVar18 - 1] \u003d \u0027\\0\u0027;\n              pcVar28 \u003d (char *)concat(pcVar19,*(undefined8 *)(plVar15[1] + 8),0);\n              free(pcVar19);\n              free(pcVar33);\n              plVar15 \u003d plVar15 + 1;\n              pcVar33 \u003d pcVar28;\n            }\n            save_stab(uStack0000000000000158,(int)sStack000000000000015a,in_stack_00000140,pcVar28);\n            in_stack_00000018 \u003d parse_stab(puStack0000000000000020,lVar25,uStack0000000000000158);\n            if (in_stack_00000018 !\u003d \u0027\\0\u0027) goto LAB_00106cac;\n            stab_context();\n            free_saved_stabs();\n          }\n          goto LAB_00105981;\n        }\nLAB_00106cac:\n      }\n      free_saved_stabs();\n      if ((lVar25 !\u003d 0) \u0026\u0026 (cVar9 \u003d finish_stab(), cVar9 \u003d\u003d \u0027\\0\u0027)) goto LAB_00105981;\n    }\n    if (in_stack_00000018 \u003d\u003d \u0027\\0\u0027) {\n      if ((*(int *)(unaff_R14[1] + 8) !\u003d 2) || (in_stack_00000010 \u003d\u003d 0)) {\n        pcVar33 \u003d \"%s: no recognized debugging information\";\n        goto LAB_00105968;\n      }\n      in_stack_00000140 \u003d (char *)0x0;\n      in_stack_000000c0 \u003d plVar32;\n      in_stack_000000d0 \u003d 0;\n      in_stack_000000c8 \u003d in_stack_00000010;\n      in_stack_000000d8 \u003d 0;\n      puVar29 \u003d (undefined8 *)\u0026stack0x00000148;\n      for (lVar25 \u003d 0x22; lVar25 !\u003d 0; lVar25 \u003d lVar25 + -1) {\n        *(undefined4 *)puVar29 \u003d 0;\n        puVar29 \u003d (undefined8 *)((long)puVar29 + (ulong)bVar39 * -8 + 4);\n      }\n      cVar9 \u003d \u0027\\0\u0027;\n      _uStack0000000000000048 \u003d (int *)0x0;\n      pcStack0000000000000038 \u003d (char *)0x0;\n      pcStack0000000000000090 \u003d (char *)0xffffffffffffffff;\nswitchD_00106e1a_caseD_68:\n      do {\n        if ((long)in_stack_00000010 \u003c\u003d in_stack_000000d0) break;\n        lVar25 \u003d plVar32[in_stack_000000d0];\n        cVar8 \u003d bfd_coff_get_syment();\n        lVar27 \u003d in_stack_000000d8;\n        if (cVar8 \u003d\u003d \u0027\\0\u0027) {\n          uVar13 \u003d bfd_get_error();\n          bfd_errmsg(uVar13);\n          pcVar33 \u003d \"bfd_coff_get_syment failed: %s\";\nLAB_00105968:\n          uVar17 \u003d dcgettext(0,pcVar33,5);\n          non_fatal(uVar17);\n          goto LAB_00105981;\n        }\n        pcVar33 \u003d *(char **)(lVar25 + 8);\n        in_stack_000000d0 \u003d in_stack_000000d0 + 1;\n        in_stack_000000d8 \u003d (ulong)bStack0000000000000101 + 1 + in_stack_000000d8;\n        if ((bStack0000000000000101 !\u003d 0) \u0026\u0026 (cVar8 \u003d bfd_coff_get_auxent(), cVar8 \u003d\u003d \u0027\\0\u0027)) {\n          uVar13 \u003d bfd_get_error();\n          bfd_errmsg(uVar13);\n          pcVar33 \u003d \"bfd_coff_get_auxent failed: %s\";\n          goto LAB_00105968;\n        }\n        if (pcStack0000000000000090 \u003d\u003d (char *)lVar27) {\n          if (bStack0000000000000100 !\u003d 0x67) {\n            cVar8 \u003d debug_set_filename(puStack0000000000000020);\n            if (cVar8 \u003d\u003d \u0027\\0\u0027) goto LAB_00105981;\n            goto LAB_00106de4;\n          }\nswitchD_00106e1a_caseD_67:\n          pcStack0000000000000090 \u003d (char *)in_stack_000000f0;\n          cVar8 \u003d debug_set_filename(puStack0000000000000020);\n        }\n        else {\nLAB_00106de4:\n          if ((char)bStack0000000000000100 \u003c \u0027\\0\u0027) {\n            if (bStack0000000000000100 \u003d\u003d 0xff) goto switchD_00106e1a_caseD_68;\n          }\n          else if (bStack0000000000000100 \u003c 100) {\n            switch(bStack0000000000000100) {\n            case 3:\n              if (in_stack_000000f8._6_2_ \u003d\u003d 0) goto switchD_00106e1a_caseD_68;\n            case 2:\nswitchD_00106e1a_caseD_7f:\n              if ((ulong)((uint)in_stack_000000f8._6_2_ \u0026 *(uint *)(unaff_R14[0x22] + 0x40)) \u003d\u003d\n                  2L \u003c\u003c ((byte)*(undefined4 *)(unaff_R14[0x22] + 0x3c) \u0026 0x3f)) {\n                _uStack0000000000000048 \u003d (int *)(**(code **)(unaff_R14[1] + 0x238))();\n                pcStack0000000000000038 \u003d pcVar33;\n                goto switchD_00106e1a_caseD_68;\n              }\n              break;\n            default:\n              break;\n            case 5:\n            case 7:\n            case 0xe:\n              goto switchD_00106e1a_caseD_68;\n            }\n          }\n          else {\n            switch(bStack0000000000000100) {\n            case 100:\n              iVar11 \u003d strcmp(pcVar33,\".bb\");\n              if (iVar11 \u003d\u003d 0) {\n                cVar8 \u003d debug_start_block(puStack0000000000000020);\n                goto joined_r0x00107247;\n              }\n              iVar11 \u003d strcmp(pcVar33,\".eb\");\n              if (iVar11 \u003d\u003d 0) {\n                cVar8 \u003d debug_end_block(puStack0000000000000020);\n                goto joined_r0x00107247;\n              }\n              goto switchD_00106e1a_caseD_68;\n            case 0x65:\n              iVar11 \u003d strcmp(pcVar33,\".bf\");\n              if (iVar11 \u003d\u003d 0) {\n                if (pcStack0000000000000038 !\u003d (char *)0x0) {\n                  lVar27 \u003d parse_coff_type_lto_priv_0();\n                  if ((lVar27 \u003d\u003d 0) ||\n                     (cVar9 \u003d debug_record_function(puStack0000000000000020), cVar9 \u003d\u003d \u0027\\0\u0027))\n                  goto LAB_00105981;\n                  if (_uStack0000000000000048 !\u003d (int *)0x0) {\n                    iVar11 \u003d 0;\n                    if (bStack0000000000000101 !\u003d 0) {\n                      iVar11 \u003d in_stack_00000118 - 1;\n                    }\n                    lVar25 \u003d *(long *)(*(long *)(lVar25 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar31 \u003d _uStack0000000000000048[4];\n                      if (iVar31 \u003d\u003d 0) break;\n                      cVar8 \u003d debug_record_line(puStack0000000000000020,iVar11 + iVar31,\n                                                *(long *)(_uStack0000000000000048 + 6) + lVar25);\n                      _uStack0000000000000048 \u003d _uStack0000000000000048 + 4;\n                      if (cVar8 \u003d\u003d \u0027\\0\u0027) goto LAB_00105981;\n                    }\n                  }\n                  _uStack0000000000000048 \u003d (int *)0x0;\n                  pcStack0000000000000038 \u003d (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar33 \u003d \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar11 \u003d strcmp(pcVar33,\".ef\");\n                if (iVar11 !\u003d 0) goto switchD_00106e1a_caseD_68;\n                if (cVar9 !\u003d \u0027\\0\u0027) {\n                  cVar9 \u003d debug_end_function(puStack0000000000000020);\n                  if (cVar9 \u003d\u003d \u0027\\0\u0027) goto LAB_00105981;\n                  cVar9 \u003d \u0027\\0\u0027;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar33 \u003d \"%ld: unexpected .ef\\n\";\n              }\n              uVar17 \u003d dcgettext(0,pcVar33,5);\n              non_fatal(uVar17);\n              goto LAB_00105981;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n          lVar21 \u003d parse_coff_type_lto_priv_0();\n          if (lVar21 \u003d\u003d 0) goto LAB_00105981;\n          cVar8 \u003d parse_coff_symbol_constprop_0_isra_0(\u0026stack0x00000140,lVar25,lVar27);\n        }\njoined_r0x00107247:\n        if (cVar8 \u003d\u003d \u0027\\0\u0027) goto LAB_00105981;\n      } while( true );\n    }\n  }\n  if (((*(uint *)(in_stack_00000008 + 0x44) \u0026 0x42) !\u003d 0) \u0026\u0026\n     ((*(uint *)(in_stack_00000008 + 0x44) \u0026 1) \u003d\u003d 0)) {\n    if ((*(char *)(*(long *)(in_stack_00000008 + 8) + 0x20) \u003d\u003d \u0027\\0\u0027) \u0026\u0026\n       (keep_section_symbols \u003d\u003d \u0027\\0\u0027)) {\n      if (in_stack_00000010 !\u003d 0) {\n        plVar32 \u003d isympp + in_stack_00000010;\n        plVar15 \u003d isympp;\n        do {\n          uVar10 \u003d *(uint *)(*plVar15 + 0x18);\n          if ((uVar10 \u0026 0x1000000) !\u003d 0) {\n            *(uint *)(*plVar15 + 0x18) \u003d uVar10 \u0026 0xfeffffff;\n          }\n          plVar15 \u003d plVar15 + 1;\n        } while (plVar32 !\u003d plVar15);\n      }\n    }\n    else {\n      for (lVar25 \u003d *(long *)(in_stack_00000008 + 0x90); lVar25 !\u003d 0; lVar25 \u003d *(long *)(lVar25 + 8)\n          ) {\n        if (*(long *)(lVar25 + 0xe8) !\u003d 0) {\n          puVar1 \u003d (uint *)(*(long *)(lVar25 + 0xe8) + 0x18);\n          *puVar1 \u003d *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((strip_symbols \u003d\u003d 2) || (strip_symbols \u003d\u003d 7)) {\nLAB_001059fe:\n    if (strip_symbols !\u003d 7) {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections();\n      iVar11 \u003d bfd_get_error();\n      if (iVar11 !\u003d 0) {\n        status \u003d 1;\n        return 0;\n      }\n    }\n    lVar25 \u003d xmalloc();\n    plVar32 \u003d isympp;\n    uStack0000000000000048 \u003d *(uint *)((long)unaff_R14 + 0x44) \u0026 0x42;\n    osympp \u003d lVar25;\n    if (in_stack_00000010 \u003d\u003d 0) {\n      uVar24 \u003d 0;\n    }\n    else {\n      uVar24 \u003d 0;\n      _in_stack_00000018 \u003d 0;\n      do {\n        iVar11 \u003d add_symbols;\n        plVar15 \u003d (long *)plVar32[_in_stack_00000018];\n        pcVar4 \u003d (code *)plVar15[4];\n        uVar10 \u003d *(uint *)(plVar15 + 3);\n        pcVar33 \u003d (char *)plVar15[1];\n        pcVar28 \u003d pcVar33;\n        if (add_sym_list !\u003d (undefined8 *)0x0) {\n          iVar31 \u003d 0;\n          puVar29 \u003d add_sym_list;\n          while( true ) {\n            if ((iVar11 \u003c\u003d iVar31) || (pcVar19 \u003d (char *)puVar29[5], pcVar19 \u003d\u003d (char *)0x0))\n            goto LAB_00105ad5;\n            if (pcVar19 !\u003d \"\") break;\nLAB_0010750b:\n            iVar31 \u003d iVar31 + 1;\n          }\n          iVar14 \u003d strcmp(pcVar19,pcVar33);\n          if (iVar14 !\u003d 0) {\n            puVar29 \u003d (undefined8 *)*puVar29;\n            goto LAB_0010750b;\n          }\n          free(pcVar19);\n          uVar20 \u003d uVar24 + 1;\n          puVar29[5] \u003d \"\";\n          uVar16 \u003d create_new_symbol(puVar29);\n          uVar17 \u003d redefine_specific_htab;\n          *(undefined8 *)(lVar25 + uVar24 * 8) \u003d uVar16;\n          lVar27 \u003d htab_elements(uVar17);\n          if ((lVar27 !\u003d 0) || (section_rename_list !\u003d (char **)0x0)) goto LAB_001064eb;\nLAB_00105af8:\n          cVar9 \u003d *pcVar33;\n          if (cVar9 !\u003d \u0027\\0\u0027) goto LAB_00105b11;\nLAB_00106557:\n          pcVar33 \u003d prefix_symbols_string;\n          if ((change_leading_char !\u003d \u0027\\0\u0027) \u0026\u0026\n             (*(char *)(*(long *)(in_stack_00000008 + 8) + 0x1c) !\u003d \u0027\\0\u0027)) {\n            lVar27 \u003d unaff_R14[1];\n            cVar9 \u003d \u0027\\0\u0027;\n            goto LAB_0010668d;\n          }\n          goto joined_r0x00106565;\n        }\nLAB_00105ad5:\n        lVar27 \u003d htab_elements(redefine_specific_htab);\n        uVar20 \u003d uVar24;\n        if ((lVar27 \u003d\u003d 0) \u0026\u0026 (section_rename_list \u003d\u003d (char **)0x0)) goto LAB_00105af8;\n        if (pcVar33 !\u003d (char *)0x0) {\nLAB_001064eb:\n          if (((*pcVar33 \u003d\u003d \u0027_\u0027) \u0026\u0026 (pcVar33[1] \u003d\u003d \u0027_\u0027)) \u0026\u0026\n             (iVar11 \u003d strcmp(pcVar33 + (pcVar33[2] \u003d\u003d \u0027_\u0027),\"__gnu_lto_slim\"), iVar11 \u003d\u003d 0)) {\n            uVar17 \u003d dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\",5);\n                    \n            fatal(uVar17);\n          }\n        }\n        _cStack0000000000000148 \u003d 0;\n        in_stack_00000140 \u003d pcVar33;\n        lVar27 \u003d htab_find(redefine_specific_htab);\n        if (((lVar27 \u003d\u003d 0) || (pcVar28 \u003d *(char **)(lVar27 + 8), pcVar33 \u003d\u003d pcVar28)) \u0026\u0026\n           (pcVar28 \u003d pcVar33, ppcVar35 \u003d section_rename_list, (uVar10 \u0026 0x100) !\u003d 0)) {\n          for (; ppcVar35 !\u003d (char **)0x0; ppcVar35 \u003d (char **)ppcVar35[3]) {\n            iVar11 \u003d strcmp(*ppcVar35,pcVar33);\n            if (iVar11 \u003d\u003d 0) {\n              pcVar28 \u003d ppcVar35[1];\n              break;\n            }\n          }\n        }\n        plVar15[1] \u003d (long)pcVar28;\n        cVar9 \u003d *pcVar28;\n        if (cVar9 \u003d\u003d \u0027\\0\u0027) goto LAB_00106557;\nLAB_00105b11:\n        pcVar33 \u003d prefix_symbols_string;\n        lVar27 \u003d unaff_R14[1];\n        if (*(char *)(lVar27 + 0x1c) \u003d\u003d cVar9) {\n          if (change_leading_char \u003d\u003d \u0027\\0\u0027) {\n            if ((remove_leading_char \u003d\u003d \u0027\\0\u0027) ||\n               ((((uVar10 \u0026 0x82) \u003d\u003d 0 \u0026\u0026 (pcVar4 !\u003d bfd_map_over_sections)) \u0026\u0026\n                ((*(byte *)(plVar15[4] + 0x25) \u0026 0x10) \u003d\u003d 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n            pcVar28 \u003d pcVar28 + 1;\n            plVar15[1] \u003d (long)pcVar28;\n            goto joined_r0x00106565;\n          }\n          cVar9 \u003d *(char *)(*(long *)(in_stack_00000008 + 8) + 0x1c);\n          if (cVar9 \u003d\u003d \u0027\\0\u0027) goto LAB_0010677d;\n          if (prefix_symbols_string !\u003d (char *)0x0) {\n            pcVar28 \u003d pcVar28 + 1;\n            plVar15[1] \u003d (long)pcVar28;\n            sVar18 \u003d strlen(pcVar28);\n            lVar27 \u003d sVar18 + 2;\n            goto LAB_001066bc;\n          }\n          *pcVar28 \u003d cVar9;\n          plVar15[1] \u003d (long)pcVar28;\n          uVar24 \u003d uVar20;\n        }\n        else {\n          if ((change_leading_char \u003d\u003d \u0027\\0\u0027) ||\n             (*(char *)(*(long *)(in_stack_00000008 + 8) + 0x1c) \u003d\u003d \u0027\\0\u0027)) {\njoined_r0x00106565:\n            uVar24 \u003d uVar20;\n            if (pcVar33 \u003d\u003d (char *)0x0) goto LAB_00105b32;\n            sVar18 \u003d strlen(pcVar28);\n            sVar26 \u003d strlen(pcVar33);\n            pcVar33 \u003d (char *)xmalloc(sVar26 + sVar18 + 1);\n            pcVar19 \u003d pcVar33;\n          }\n          else {\nLAB_0010668d:\n            pcVar33 \u003d prefix_symbols_string;\n            if ((*(char *)(lVar27 + 0x1c) !\u003d \u0027\\0\u0027) \u0026\u0026 (cVar9 !\u003d *(char *)(lVar27 + 0x1c)))\n            goto joined_r0x00106565;\n            sVar18 \u003d strlen(pcVar28);\n            lVar27 \u003d sVar18 + 2;\n            if (pcVar33 \u003d\u003d (char *)0x0) {\n              pcVar19 \u003d (char *)xmalloc(lVar27);\n            }\n            else {\nLAB_001066bc:\n              sVar18 \u003d strlen(pcVar33);\n              pcVar19 \u003d (char *)xmalloc(sVar18 + lVar27);\n            }\n            pcVar33 \u003d pcVar19 + 1;\n            *pcVar19 \u003d *(char *)(*(long *)(in_stack_00000008 + 8) + 0x1c);\n          }\n          __s \u003d prefix_symbols_string;\n          if (prefix_symbols_string !\u003d (char *)0x0) {\n            strcpy(pcVar33,prefix_symbols_string);\n            sVar18 \u003d strlen(__s);\n            pcVar33 \u003d pcVar33 + sVar18;\n          }\n          strcpy(pcVar33,pcVar28);\n          plVar15[1] \u003d (long)pcVar19;\n          pcVar28 \u003d pcVar19;\n          uVar24 \u003d uVar20;\n        }\nLAB_00105b32:\n        if (strip_symbols \u003d\u003d 7) goto LAB_001067a8;\n        if (((uVar10 \u0026 0x20) \u003d\u003d 0) \u0026\u0026\n           (((uVar10 \u0026 0x100) \u003d\u003d 0 ||\n            ((*(byte *)(**(long **)(plVar15[4] + 0xf0) + 0x18) \u0026 0x20) \u003d\u003d 0)))) {\n          if (((uStack0000000000000048 \u003d\u003d 0) \u0026\u0026\n              (((uVar10 \u0026 0x82) !\u003d 0 || ((*(byte *)(plVar15[4] + 0x25) \u0026 0x10) !\u003d 0)))) ||\n             (iVar11 \u003d bfd_decode_symclass(plVar15), iVar11 \u003d\u003d 0x49)) {\nLAB_00105be2:\n            if (wildcard \u003d\u003d \u0027\\0\u0027) {\n              lVar27 \u003d htab_find();\n              if (lVar27 \u003d\u003d 0) goto LAB_00105c07;\n            }\n            else {\n              _cStack0000000000000148 \u003d _cStack0000000000000148 \u0026 0xffffffffffffff00;\n              in_stack_00000140 \u003d pcVar28;\n              htab_traverse(strip_specific_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n              if (cStack0000000000000148 \u003d\u003d \u0027\\0\u0027) goto LAB_00105c07;\n            }\n          }\n          else if ((((uVar10 \u0026 0x82) \u003d\u003d 0) \u0026\u0026 (pcVar4 !\u003d bfd_map_over_sections)) \u0026\u0026\n                  ((*(byte *)(plVar15[4] + 0x25) \u0026 0x10) \u003d\u003d 0)) {\n            if ((uVar10 \u0026 4) \u003d\u003d 0) {\n              if (((*(int *)(unaff_R14[1] + 8) !\u003d 2) ||\n                  (lVar27 \u003d *(long *)(plVar15[4] + 0xd0), lVar27 \u003d\u003d 0)) ||\n                 (*(long *)(lVar27 + 0x40) \u003d\u003d 0)) {\n                if ((strip_symbols \u003d\u003d 3) || (discard_locals \u003d\u003d 2)) goto LAB_001067a8;\n                if (discard_locals \u003d\u003d 1) {\n                  cVar9 \u003d bfd_is_local_label(unaff_R14);\n                  goto joined_r0x00106a11;\n                }\n              }\n              goto LAB_00105be2;\n            }\n            cVar9 \u003d convert_debugging;\n            if (1 \u003c strip_symbols - 2U) {\njoined_r0x00106a11:\n              if (cVar9 \u003d\u003d \u0027\\0\u0027) goto LAB_00105be2;\n            }\n          }\n          else if (strip_symbols !\u003d 3) goto LAB_00105be2;\n          goto LAB_001067a8;\n        }\n        if (wildcard \u003d\u003d \u0027\\0\u0027) {\n          lVar27 \u003d htab_find();\n          if (lVar27 !\u003d 0) {\nLAB_0010687f:\n            uVar17 \u003d dcgettext(0,\"not stripping symbol `%s\\\u0027 because it is named in a relocation\",5)\n            ;\n            non_fatal(uVar17);\n            status \u003d 1;\n          }\n        }\n        else {\n          _cStack0000000000000148 \u003d _cStack0000000000000148 \u0026 0xffffffffffffff00;\n          in_stack_00000140 \u003d pcVar28;\n          htab_traverse(strip_specific_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n          if (cStack0000000000000148 !\u003d \u0027\\0\u0027) goto LAB_0010687f;\n        }\n        if ((uVar10 \u0026 0x20) \u003d\u003d 0) {\nLAB_00105c07:\n          if (wildcard !\u003d \u0027\\0\u0027) {\n            _cStack0000000000000148 \u003d _cStack0000000000000148 \u0026 0xffffffffffffff00;\n            in_stack_00000140 \u003d pcVar28;\n            htab_traverse(strip_unneeded_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n            if (cStack0000000000000148 !\u003d \u0027\\0\u0027) goto LAB_001067a8;\n            goto LAB_00105c2c;\n          }\n          lVar27 \u003d htab_find();\n          if (lVar27 \u003d\u003d 0) goto LAB_00105c2c;\nLAB_001067a8:\n          if ((keep_file_symbols !\u003d \u0027\\0\u0027) \u0026\u0026 ((uVar10 \u0026 0x4000) !\u003d 0)) goto LAB_00105c2c;\n          if (wildcard \u003d\u003d \u0027\\0\u0027) {\n            lVar27 \u003d htab_find();\n            if (lVar27 !\u003d 0) goto LAB_00105c2c;\n          }\n          else {\n            _cStack0000000000000148 \u003d _cStack0000000000000148 \u0026 0xffffffffffffff00;\n            in_stack_00000140 \u003d pcVar28;\n            htab_traverse(keep_specific_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n            if (cStack0000000000000148 !\u003d \u0027\\0\u0027) goto LAB_00105c2c;\n          }\n        }\n        else {\nLAB_00105c2c:\n          cVar9 \u003d is_strip_section_isra_0(plVar15[4]);\n          if (cVar9 \u003d\u003d \u0027\\0\u0027) {\n            if (((uVar10 \u0026 0x800002) \u003d\u003d 0) \u0026\u0026 (pcVar4 !\u003d bfd_map_over_sections)) {\nLAB_00105c5f:\n              if ((uVar10 \u0026 0x82) !\u003d 0) {\n                cVar9 \u003d is_specified_symbol(pcVar28);\n                if ((cVar9 \u003d\u003d \u0027\\0\u0027) \u0026\u0026\n                   ((lVar27 \u003d htab_elements(keepglobal_specific_htab), lVar27 \u003d\u003d 0 ||\n                    (cVar9 \u003d is_specified_symbol(pcVar28), cVar9 !\u003d \u0027\\0\u0027)))) {\n                  if (((((localize_hidden \u003d\u003d \u0027\\0\u0027) ||\n                        (uVar12 \u003d *(uint *)(plVar15 + 3), (uVar12 \u0026 0x200000) !\u003d 0)) ||\n                       (lVar27 \u003d *plVar15, lVar27 \u003d\u003d 0)) ||\n                      ((*(int *)(*(long *)(lVar27 + 8) + 8) !\u003d 5 || (*(long *)(lVar27 + 0x110) \u003d\u003d 0)\n                       ))) || (1 \u003c (*(byte *)((long)plVar15 + 0x49) \u0026 3) - 1))\n                  goto joined_r0x00105ca2;\n                }\n                else {\n                  uVar12 \u003d *(uint *)(plVar15 + 3);\n                }\n                *(uint *)(plVar15 + 3) \u003d uVar12 \u0026 0xffffff7d | 1;\n              }\njoined_r0x00105ca2:\n              if (((uVar10 \u0026 1) !\u003d 0) \u0026\u0026 (cVar9 \u003d is_specified_symbol(pcVar28), cVar9 !\u003d \u0027\\0\u0027)) {\n                *(uint *)(plVar15 + 3) \u003d *(uint *)(plVar15 + 3) \u0026 0xfffffffe | 2;\n              }\n            }\n            else {\n              if ((weaken !\u003d \u0027\\0\u0027) || (cVar9 \u003d is_specified_symbol(pcVar28), cVar9 !\u003d \u0027\\0\u0027)) {\n                *(uint *)(plVar15 + 3) \u003d *(uint *)(plVar15 + 3) \u0026 0xff7ffffd | 0x80;\n              }\n              if (pcVar4 !\u003d bfd_map_over_sections) goto LAB_00105c5f;\n            }\n            *(long **)(lVar25 + uVar24 * 8) \u003d plVar15;\n            uVar24 \u003d uVar24 + 1;\n          }\n        }\n        _in_stack_00000018 \u003d _in_stack_00000018 + 1;\n      } while (in_stack_00000010 !\u003d _in_stack_00000018);\n    }\n    if (add_sym_list !\u003d (undefined8 *)0x0) {\n      puVar29 \u003d add_sym_list;\n      iVar11 \u003d add_symbols;\n      for (lVar27 \u003d 0; lVar27 \u003c iVar11; lVar27 \u003d lVar27 + 1) {\n        pcVar33 \u003d (char *)puVar29[5];\n        if (pcVar33 \u003d\u003d (char *)0x0) {\n          lVar21 \u003d uVar24 * 8;\n          uVar24 \u003d uVar24 + 1;\n          uVar17 \u003d create_new_symbol(puVar29,in_stack_00000008);\n          *(undefined8 *)(lVar25 + lVar21) \u003d uVar17;\n          iVar11 \u003d add_symbols;\n        }\n        else if (pcVar33 !\u003d \"\") {\n          uVar17 \u003d dcgettext(0,\"\\\u0027before\u003d%s\\\u0027 not found\",5);\n                    \n          fatal(uVar17,pcVar33);\n        }\n        puVar29 \u003d (undefined8 *)*puVar29;\n      }\n    }\n    bVar38 \u003d convert_debugging !\u003d \u0027\\0\u0027;\n    *(undefined8 *)(lVar25 + uVar24 * 8) \u003d 0;\n    if ((bVar38) \u0026\u0026 (puStack0000000000000020 !\u003d (undefined4 *)0x0)) {\n      iVar11 \u003d *(int *)(*(undefined8 **)(in_stack_00000008 + 8) + 1);\n      if ((iVar11 !\u003d 5) \u0026\u0026 (iVar11 !\u003d 2)) {\n        uVar17 \u003d **(undefined8 **)(in_stack_00000008 + 8);\n        uVar16 \u003d dcgettext(0,\"don\\\u0027t know how to write debugging information for %s\",5);\n        bfd_nonfatal_message(0,in_stack_00000008,0,uVar16,uVar17);\nLAB_00105d8c:\n        free(puStack0000000000000020);\n        status \u003d 1;\n        return 0;\n      }\n      in_stack_000000e0 \u003d (void *)0x0;\n      cVar9 \u003d write_stabs_in_sections_debugging_info_constprop_0\n                        (in_stack_00000008,puStack0000000000000020,\u0026stack0x000000c0,\u0026stack0x00000110\n                         ,\u0026stack0x000000e0,\u0026stack0x00000140);\n      if (cVar9 \u003d\u003d \u0027\\0\u0027) goto LAB_00105d8c;\n      lVar25 \u003d bfd_make_section_with_flags(in_stack_00000008,\".stab\",0x2108);\n      lVar27 \u003d bfd_make_section_with_flags(in_stack_00000008,\".stabstr\",0x2108);\n      if ((((lVar25 \u003d\u003d 0) || (lVar27 \u003d\u003d 0)) ||\n          (cVar9 \u003d bfd_set_section_size(lVar25,in_stack_00000110), cVar9 \u003d\u003d \u0027\\0\u0027)) ||\n         (cVar9 \u003d bfd_set_section_size(lVar27,in_stack_00000140), cVar9 \u003d\u003d \u0027\\0\u0027)) {\n        pcVar33 \u003d \"can\\\u0027t create debugging section\";\nLAB_00105eb4:\n        uVar17 \u003d dcgettext(0,pcVar33,5);\n        bfd_nonfatal_message(0,in_stack_00000008,0,uVar17);\n        free(in_stack_000000e0);\n        free(puStack0000000000000020);\n        status \u003d 1;\n        return 0;\n      }\n      *(undefined4 *)(lVar25 + 0x7c) \u003d 2;\n      *(undefined4 *)(lVar27 + 0x7c) \u003d 0;\n      cVar9 \u003d bfd_set_section_contents\n                        (in_stack_00000008,lVar25,in_stack_000000c0,0,in_stack_00000110);\n      if ((cVar9 \u003d\u003d \u0027\\0\u0027) ||\n         (cVar9 \u003d bfd_set_section_contents\n                            (in_stack_00000008,lVar27,in_stack_000000e0,0,in_stack_00000140),\n         cVar9 \u003d\u003d \u0027\\0\u0027)) {\n        pcVar33 \u003d \"can\\\u0027t set debugging section contents\";\n        goto LAB_00105eb4;\n      }\n      free(puStack0000000000000020);\n    }\n    in_stack_00000010 \u003d uVar24 \u0026 0xffffffff;\n  }\n  else {\n    if ((strip_symbols - 3U \u003c 4) || ((discard_locals !\u003d 0 || (localize_hidden !\u003d \u0027\\0\u0027))))\n    goto LAB_00105a07;\n    lVar25 \u003d htab_elements(strip_specific_htab);\n    if (((lVar25 !\u003d 0) ||\n        (((((((lVar25 \u003d htab_elements(keep_specific_htab), lVar25 !\u003d 0 ||\n              (lVar25 \u003d htab_elements(localize_specific_htab), lVar25 !\u003d 0)) ||\n             (lVar25 \u003d htab_elements(globalize_specific_htab), lVar25 !\u003d 0)) ||\n            ((lVar25 \u003d htab_elements(keepglobal_specific_htab), lVar25 !\u003d 0 ||\n             (lVar25 \u003d htab_elements(weaken_specific_htab), lVar25 !\u003d 0)))) ||\n           (lVar25 \u003d htab_elements(redefine_specific_htab), lVar25 !\u003d 0)) ||\n          (((prefix_symbols_string !\u003d (char *)0x0 || (sections_removed !\u003d \u0027\\0\u0027)) ||\n           ((sections_copied !\u003d \u0027\\0\u0027 ||\n            (((convert_debugging !\u003d \u0027\\0\u0027 || (change_leading_char !\u003d \u0027\\0\u0027)) ||\n             (remove_leading_char !\u003d \u0027\\0\u0027)))))))) ||\n         ((section_rename_list !\u003d (char **)0x0 || (weaken !\u003d \u0027\\0\u0027)))))) || (add_symbols !\u003d 0))\n    goto LAB_001059fe;\n  }\n  bfd_set_symtab(in_stack_00000008,osympp,in_stack_00000010 \u0026 0xffffffff);\n  bfd_map_over_sections(unaff_R14,copy_relocations_in_section,in_stack_00000008);\n  bfd_map_over_sections(unaff_R14,copy_section,in_stack_00000008);\n  for (puVar29 \u003d add_sections; puVar5 \u003d update_sections, puVar29 !\u003d (undefined8 *)0x0;\n      puVar29 \u003d (undefined8 *)*puVar29) {\n    cVar9 \u003d bfd_set_section_contents(in_stack_00000008,puVar29[5],puVar29[4],0,puVar29[3]);\n    if (cVar9 \u003d\u003d \u0027\\0\u0027) {\n      bfd_nonfatal_message(0,in_stack_00000008,puVar29[5],0);\n      return 0;\n    }\n  }\n  for (; puVar5 !\u003d (undefined8 *)0x0; puVar5 \u003d (undefined8 *)*puVar5) {\n    uVar17 \u003d *(undefined8 *)(puVar5[5] + 0x60);\n    cVar9 \u003d bfd_set_section_contents(in_stack_00000008,uVar17,puVar5[4],0,puVar5[3]);\n    if (cVar9 \u003d\u003d \u0027\\0\u0027) {\n      bfd_nonfatal_message(0,in_stack_00000008,uVar17,0);\n      return 0;\n    }\n  }\n  if (unaff_R13 \u003d\u003d (long *)0x0) {\n    if ((merge_notes !\u003d \u0027\\0\u0027) \u0026\u0026 (is_strip \u003d\u003d 0)) {\n      uVar17 \u003d *unaff_R14;\n      uVar16 \u003d dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n      non_fatal(uVar16,uVar17);\n    }\nLAB_0010578f:\n    if ((gnu_debuglink_filename \u003d\u003d 0) ||\n       (cVar9 \u003d bfd_fill_in_gnu_debuglink_section(in_stack_00000008,lStack0000000000000078),\n       lVar25 \u003d gnu_debuglink_filename, cVar9 !\u003d \u0027\\0\u0027)) {\n      uVar10 \u003d (**(code **)(*(long *)(in_stack_00000008 + 8) + 0x140))(unaff_R14);\n      uVar24 \u003d (ulong)uVar10;\n      if ((char)uVar10 !\u003d \u0027\\0\u0027) {\n        if (use_alt_mach_code \u003d\u003d 0) {\n          return uVar24;\n        }\n        cVar9 \u003d bfd_alt_mach_code(in_stack_00000008,use_alt_mach_code \u0026 0xffffffff);\n        uVar20 \u003d use_alt_mach_code;\n        if (cVar9 !\u003d \u0027\\0\u0027) {\n          return uVar24;\n        }\n        uVar17 \u003d dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n        non_fatal(uVar17,uVar20);\n        if (*(int *)(*(long *)(in_stack_00000008 + 8) + 8) !\u003d 5) {\n          uVar17 \u003d dcgettext(0,\"ignoring the alternative value\",5);\n          non_fatal(uVar17);\n          return uVar24;\n        }\n        uVar17 \u003d dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n        non_fatal(uVar17);\n        *(short *)(*(long *)(in_stack_00000008 + 0x110) + 0x3a) \u003d (short)use_alt_mach_code;\n        return uVar24;\n      }\n      uVar17 \u003d dcgettext(0,\"error copying private BFD data\",5);\n      bfd_nonfatal_message(0,in_stack_00000008,0,uVar17);\n    }\n    else {\n      uVar17 \u003d dcgettext(0,\"cannot fill debug link section `%s\\\u0027\",5);\n      bfd_nonfatal_message(0,in_stack_00000008,0,uVar17,lVar25);\n    }\n    return 0;\n  }\n  plVar32 \u003d (long *)0x0;\n  puVar29 \u003d *(undefined8 **)(in_stack_00000008 + 0x90);\n  do {\n    if (puVar29 \u003d\u003d (undefined8 *)0x0) {\n      do {\n        plVar32 \u003d (long *)unaff_R13[3];\n        free((void *)unaff_R13[1]);\n        free(unaff_R13);\n        unaff_R13 \u003d plVar32;\n      } while (plVar32 !\u003d (long *)0x0);\n      goto LAB_0010578f;\n    }\n    if ((((merge_notes !\u003d \u0027\\0\u0027) \u0026\u0026 (*(int *)(*(long *)(in_stack_00000008 + 8) + 8) \u003d\u003d 5)) \u0026\u0026\n        (*(int *)(puVar29[0x1a] + 4) \u003d\u003d 7)) \u0026\u0026\n       (cVar9 \u003d startswith_lto_priv_0_lto_priv_0(*puVar29,\".gnu.build.attributes\"), cVar9 !\u003d \u0027\\0\u0027))\n    {\n      if (plVar32 \u003d\u003d (long *)0x0) {\n        plVar32 \u003d unaff_R13;\n      }\n      plVar15 \u003d unaff_R13;\n      if (*(undefined8 **)(*plVar32 + 0x60) \u003d\u003d puVar29) {\nLAB_0010625f:\n        pcVar33 \u003d \"error: failed to merge notes\";\n        if (plVar32[1] !\u003d 0) {\n          cVar9 \u003d bfd_set_section_contents(in_stack_00000008,puVar29,plVar32[1],0,plVar32[2]);\n          if (cVar9 \u003d\u003d \u0027\\0\u0027) {\n            uVar17 \u003d dcgettext(0,\"error: failed to copy merged notes into output\",5);\n            bfd_nonfatal_message(0,in_stack_00000008,puVar29,uVar17);\n            return 0;\n          }\n          plVar32 \u003d (long *)plVar32[3];\n          goto LAB_001061be;\n        }\n      }\n      else {\n        do {\n          plVar32 \u003d plVar15;\n          if (*(undefined8 **)(*plVar15 + 0x60) \u003d\u003d puVar29) goto LAB_0010625f;\n          plVar32 \u003d (long *)plVar15[3];\n          plVar15 \u003d plVar32;\n        } while (plVar32 !\u003d (long *)0x0);\n        pcVar33 \u003d \"error: failed to locate merged notes\";\n      }\n      uVar17 \u003d dcgettext(0,pcVar33,5);\n      bfd_nonfatal_message(0,in_stack_00000008,puVar29,uVar17);\n    }\nLAB_001061be:\n    puVar29 \u003d (undefined8 *)puVar29[1];\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107880"
      ],
      "called": [
        "free",
        "dcgettext",
        "bfd_nonfatal_message"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010554f": {
      "entrypoint": "0x0010554f",
      "current_name": "FUN_0010554f",
      "code": "\n/* WARNING: Type propagation algorithm not settling */\n\n\nundefined4 FUN_0010554f(void)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  code *pcVar3;\n  undefined8 *puVar4;\n  undefined uVar5;\n  ushort uVar6;\n  char cVar7;\n  char cVar8;\n  undefined4 uVar9;\n  int iVar10;\n  int iVar11;\n  uint uVar12;\n  uint uVar13;\n  long lVar14;\n  long *plVar15;\n  undefined8 uVar16;\n  undefined *__ptr;\n  undefined8 uVar17;\n  size_t sVar18;\n  size_t sVar19;\n  long *__dest;\n  long *plVar20;\n  void *__ptr_00;\n  void *__ptr_01;\n  ulong uVar21;\n  char *__s;\n  char *pcVar22;\n  long lVar23;\n  ulong uVar24;\n  long *plVar25;\n  undefined8 *puVar26;\n  int iVar27;\n  long *plVar28;\n  ulong uVar29;\n  ulong *puVar30;\n  char *pcVar31;\n  undefined4 *puVar32;\n  undefined *puVar33;\n  long *in_R10;\n  char **ppcVar34;\n  void *pvVar35;\n  undefined8 *unaff_R14;\n  undefined **ppuVar36;\n  long lVar37;\n  bool bVar38;\n  byte bVar39;\n  long param_7;\n  ulong param_8;\n  char param_9;\n  undefined4 *__ptr_02;\n  ulong param_12;\n  char *param_13;\n  undefined *param_14;\n  uint param_15;\n  long *param_17;\n  undefined8 in_stack_00000068;\n  undefined8 param_21;\n  long param_23;\n  char *param_24;\n  long param_26;\n  long *param_30;\n  ulong param_31;\n  long param_32;\n  long in_stack_000000d8;\n  void *param_33;\n  long param_34;\n  undefined8 in_stack_000000f8;\n  byte param_36;\n  byte param_37;\n  undefined8 param_38;\n  ushort param_39;\n  long *param_40;\n  char param_41;\n  char *param_42;\n  undefined param_43;\n  short param_44;\n  \n  bVar39 \u003d 0;\n  if ((gap_fill_set \u003d\u003d \u0027\\0\u0027) \u0026\u0026 (pad_to_set \u003d\u003d \u0027\\0\u0027)) {\n    param_12 \u003d 0;\n    param_14 \u003d (undefined *)0x0;\n    param_17 \u003d (long *)0x0;\n    uVar29 \u003d param_12;\n  }\n  else {\n    lVar14 \u003d (ulong)in_stack_00000068._4_4_ * 8;\n    param_17 \u003d (long *)xmalloc(lVar14);\n    param_40 \u003d param_17;\n    bfd_map_over_sections(param_7,get_sections,\u0026stack0x00000140);\n    qsort(param_17,(ulong)in_stack_00000068._4_4_,8,compare_section_lma);\n    param_14 \u003d (undefined *)xmalloc(lVar14);\n    bVar38 \u003d gap_fill_set !\u003d \u0027\\0\u0027;\n    puVar33 \u003d param_14;\n    for (; lVar14 !\u003d 0; lVar14 \u003d lVar14 + -1) {\n      *puVar33 \u003d 0;\n      puVar33 \u003d puVar33 + (ulong)bVar39 * -2 + 1;\n    }\n    if (bVar38) {\n      uVar29 \u003d 0;\n      param_12 \u003d 0;\n      do {\n        puVar30 \u003d (ulong *)(param_14 + uVar29 * 8);\n        plVar28 \u003d param_17 + uVar29;\n        uVar21 \u003d param_12;\n        do {\n          param_12 \u003d uVar21;\n          if (in_stack_00000068._4_4_ - 1 \u003c\u003d (uint)uVar29) goto LAB_00107cd1;\n          uVar29 \u003d (ulong)((uint)uVar29 + 1);\n          uVar12 \u003d bfd_octets_per_byte(param_7,*plVar28);\n          uVar13 \u003d bfd_octets_per_byte(param_7);\n          lVar14 \u003d *plVar28;\n          if ((*(uint *)(lVar14 + 0x24) \u0026 0x102) !\u003d 0x102) break;\n          uVar21 \u003d (ulong)uVar13 * *(long *)(plVar28[1] + 0x38);\n          uVar24 \u003d (ulong)uVar12 * *(long *)(lVar14 + 0x38) + *(long *)(lVar14 + 0x40);\n          if (uVar21 \u003c\u003d uVar24) break;\n          uVar21 \u003d uVar21 - uVar24;\n          cVar7 \u003d bfd_set_section_size();\n          if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n            dcgettext(0,\"Can\\\u0027t fill gap after section\",5);\n            bfd_nonfatal_message(0,param_7,*plVar28);\n            status \u003d 1;\n            goto LAB_00107cd1;\n          }\n          *puVar30 \u003d uVar21;\n          plVar28 \u003d plVar28 + 1;\n          puVar30 \u003d puVar30 + 1;\n        } while (param_12 \u003c uVar21);\n      } while( true );\n    }\n    param_12 \u003d 0;\nLAB_00107cd1:\n    uVar29 \u003d param_12;\n    if (pad_to_set !\u003d \u0027\\0\u0027) {\n      uVar12 \u003d bfd_octets_per_byte(param_7);\n      lVar14 \u003d param_17[in_stack_00000068._4_4_ - 1];\n      uVar21 \u003d pad_to * (ulong)uVar12;\n      uVar24 \u003d *(long *)(lVar14 + 0x40) + (ulong)uVar12 * *(long *)(lVar14 + 0x38);\n      if (uVar24 \u003c uVar21) {\n        cVar7 \u003d bfd_set_section_size();\n        if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n          dcgettext(0,\"can\\\u0027t add padding\",5);\n          bfd_nonfatal_message(0,param_7,param_17[in_stack_00000068._4_4_ - 1]);\n          status \u003d 1;\n        }\n        else {\n          uVar29 \u003d uVar21 - uVar24;\n          *(ulong *)(param_14 + (ulong)(in_stack_00000068._4_4_ - 1) * 8) \u003d uVar29;\n          if (uVar29 \u003c\u003d param_12) {\n            uVar29 \u003d param_12;\n          }\n        }\n      }\n    }\n  }\n  param_12 \u003d uVar29;\n  plVar28 \u003d isympp;\n  if (convert_debugging \u003d\u003d \u0027\\0\u0027) {\nLAB_00105588:\n    __ptr_02 \u003d (undefined4 *)0x0;\n  }\n  else {\n    ppuVar36 \u003d \u0026names_0;\n    __ptr_02 \u003d (undefined4 *)xmalloc(0x60);\n    puVar32 \u003d __ptr_02;\n    for (lVar14 \u003d 0x18; lVar14 !\u003d 0; lVar14 \u003d lVar14 + -1) {\n      *puVar32 \u003d 0;\n      puVar32 \u003d puVar32 + (ulong)bVar39 * -2 + 1;\n    }\n    param_13 \u003d (char *)0x0;\n    do {\n      puVar33 \u003d *ppuVar36;\n      lVar14 \u003d bfd_get_section_by_name(unaff_R14,puVar33);\n      lVar37 \u003d bfd_get_section_by_name();\n      if ((lVar14 !\u003d 0) \u0026\u0026 (lVar37 !\u003d 0)) {\n        lVar23 \u003d *(long *)(lVar14 + 0x40);\n        __ptr_00 \u003d (void *)xmalloc(lVar23);\n        cVar7 \u003d bfd_get_section_contents(unaff_R14,lVar14,__ptr_00,0,lVar23);\n        if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n          uVar9 \u003d bfd_get_error();\n          bfd_errmsg(uVar9);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n          free(param_13);\n          free(__ptr_00);\n        }\n        else {\n          uVar29 \u003d *(ulong *)(lVar37 + 0x40);\n          __ptr_01 \u003d (void *)xmalloc(uVar29 + 1);\n          param_9 \u003d bfd_get_section_contents(unaff_R14,lVar37,__ptr_01,0);\n          if (param_9 \u003d\u003d \u0027\\0\u0027) {\n            uVar9 \u003d bfd_get_error();\n            bfd_errmsg(uVar9);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n            free(param_13);\n          }\n          else {\n            *(undefined *)((long)__ptr_01 + uVar29) \u003d 0;\n            if ((param_13 !\u003d (char *)0x0) ||\n               (param_13 \u003d (char *)start_stab_constprop_0(unaff_R14,1,plVar28),\n               param_13 !\u003d (char *)0x0)) {\n              param_26 \u003d 0;\n              param_23 \u003d 0;\n              for (pvVar35 \u003d __ptr_00; pvVar35 \u003c\u003d (void *)((long)__ptr_00 + lVar23 + -0xc);\n                  pvVar35 \u003d (void *)((long)pvVar35 + 0xc)) {\n                uVar21 \u003d (**(code **)(unaff_R14[1] + 0x40))(pvVar35);\n                bVar2 \u003d *(byte *)((long)pvVar35 + 4);\n                uVar9 \u003d (**(code **)(unaff_R14[1] + 0x58))((long)pvVar35 + 6);\n                lVar14 \u003d (**(code **)(unaff_R14[1] + 0x40))((long)pvVar35 + 8);\n                if (bVar2 \u003d\u003d 0) {\n                  param_23 \u003d param_26;\n                  param_26 \u003d param_26 + lVar14;\n                }\n                else {\n                  uVar24 \u003d (uVar21 \u0026 0xffffffff) + param_23;\n                  if (uVar24 \u003c uVar29) {\n                    pcVar31 \u003d (char *)((long)__ptr_01 + uVar24);\n                    param_24 \u003d (char *)0x0;\n                    while( true ) {\n                      sVar18 \u003d strlen(pcVar31);\n                      if (((sVar18 \u003d\u003d 0) || (pcVar22 \u003d pcVar31 + (sVar18 - 1), *pcVar22 !\u003d \u0027\\\\\u0027)) ||\n                         ((ulong)((long)__ptr_00 + lVar23) \u003c (long)pvVar35 + 0x10U))\n                      goto LAB_001077fb;\n                      *pcVar22 \u003d \u0027\\0\u0027;\n                      pvVar35 \u003d (void *)((long)pvVar35 + 0xc);\n                      iVar10 \u003d (**(code **)(unaff_R14[1] + 0x40))(pvVar35);\n                      uVar21 \u003d (ulong)(uint)(iVar10 + (int)param_23);\n                      if (uVar29 \u003c\u003d uVar21) break;\n                      pcVar31 \u003d (char *)concat(pcVar31,(long)__ptr_01 + uVar21,0);\n                      *pcVar22 \u003d \u0027\\\\\u0027;\n                      free(param_24);\n                      param_24 \u003d pcVar31;\n                    }\n                    uVar17 \u003d *unaff_R14;\n                    pcVar22 \u003d (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar22,uVar17,puVar33,((long)pvVar35 - (long)__ptr_00) / 0xc);\nLAB_001077fb:\n                    save_stab((ulong)bVar2,uVar9,lVar14,pcVar31);\n                    cVar7 \u003d parse_stab(__ptr_02,param_13,bVar2);\n                    if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n                      stab_context();\n                      free_saved_stabs();\n                      free(param_24);\n                      free(param_13);\n                      free(__ptr_00);\n                      free(__ptr_01);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar17 \u003d *unaff_R14;\n                    pcVar31 \u003d (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx \u003d 0x%x, type \u003d %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar31,uVar17,puVar33,((long)pvVar35 - (long)__ptr_00) / 0xc,\n                            uVar21 \u0026 0xffffffff,(ulong)bVar2,((long)pvVar35 - (long)__ptr_00) % 0xc)\n                    ;\n                  }\n                }\n              }\n              free_saved_stabs();\n              free(__ptr_00);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_01);\n          free(__ptr_00);\n        }\n        goto LAB_00105981;\n      }\nLAB_001058eb:\n      ppuVar36 \u003d ppuVar36 + 2;\n    } while (ppuVar36 !\u003d (undefined **)\u0026DAT_00125c90);\n    if ((param_13 !\u003d (char *)0x0) \u0026\u0026 (cVar7 \u003d finish_stab(), cVar7 \u003d\u003d \u0027\\0\u0027)) {\nLAB_00105981:\n      free(__ptr_02);\n      goto LAB_00105588;\n    }\n    if (*(int *)(unaff_R14[1] + 8) \u003d\u003d 1) {\n      lVar14 \u003d 0;\n      for (plVar15 \u003d plVar28; plVar15 \u003c plVar28 + param_8; plVar15 \u003d plVar15 + 1) {\n        (**(code **)(unaff_R14[1] + 0x218))(unaff_R14,*plVar15,\u0026stack0x00000140);\n        if (param_41 \u003d\u003d \u0027-\u0027) {\n          if (((lVar14 \u003d\u003d 0) \u0026\u0026 (lVar14 \u003d start_stab_constprop_0(unaff_R14,0,plVar28), lVar14 \u003d\u003d 0))\n             || ((param_42 \u003d\u003d (char *)0x0 || (*param_42 \u003d\u003d \u0027\\0\u0027)))) goto LAB_00105981;\n          pcVar31 \u003d (char *)0x0;\n          pcVar22 \u003d param_42;\n          while (((*pcVar22 !\u003d \u0027\\0\u0027 \u0026\u0026 (sVar18 \u003d strlen(pcVar22), pcVar22[sVar18 - 1] \u003d\u003d \u0027\\\\\u0027)) \u0026\u0026\n                 (plVar15 + 1 \u003c plVar28 + param_8))) {\n            __s \u003d (char *)xstrdup(pcVar22);\n            sVar18 \u003d strlen(__s);\n            __s[sVar18 - 1] \u003d \u0027\\0\u0027;\n            pcVar22 \u003d (char *)concat(__s,*(undefined8 *)(plVar15[1] + 8),0);\n            free(__s);\n            free(pcVar31);\n            plVar15 \u003d plVar15 + 1;\n            pcVar31 \u003d pcVar22;\n          }\n          save_stab(param_43,(int)param_44,param_40,pcVar22);\n          param_9 \u003d parse_stab(__ptr_02,lVar14,param_43);\n          if (param_9 \u003d\u003d \u0027\\0\u0027) {\n            stab_context();\n            free_saved_stabs();\n            goto LAB_00105981;\n          }\n        }\n      }\n      free_saved_stabs();\n      if ((lVar14 !\u003d 0) \u0026\u0026 (cVar7 \u003d finish_stab(), cVar7 \u003d\u003d \u0027\\0\u0027)) goto LAB_00105981;\n    }\n    if (param_9 \u003d\u003d \u0027\\0\u0027) {\n      if ((*(int *)(unaff_R14[1] + 8) \u003d\u003d 2) \u0026\u0026 (param_8 !\u003d 0)) {\n        param_40 \u003d (long *)0x0;\n        param_30 \u003d plVar28;\n        param_32 \u003d 0;\n        param_31 \u003d param_8;\n        in_stack_000000d8 \u003d 0;\n        puVar26 \u003d (undefined8 *)\u0026stack0x00000148;\n        for (lVar14 \u003d 0x22; lVar14 !\u003d 0; lVar14 \u003d lVar14 + -1) {\n          *(undefined4 *)puVar26 \u003d 0;\n          puVar26 \u003d (undefined8 *)((long)puVar26 + (ulong)bVar39 * -8 + 4);\n        }\n        cVar7 \u003d \u0027\\0\u0027;\n        _param_15 \u003d (int *)0x0;\n        uVar12 \u003d 0;\n        param_13 \u003d (char *)0x0;\n        param_24 \u003d (char *)0xffffffffffffffff;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((long)param_8 \u003c\u003d param_32) goto LAB_00105590;\n            lVar14 \u003d plVar28[param_32];\n            cVar8 \u003d bfd_coff_get_syment(unaff_R14,lVar14,\u0026stack0x000000e0);\n            lVar37 \u003d in_stack_000000d8;\n            if (cVar8 \u003d\u003d \u0027\\0\u0027) {\n              uVar9 \u003d bfd_get_error();\n              bfd_errmsg(uVar9);\n              pcVar31 \u003d \"bfd_coff_get_syment failed: %s\";\n              goto LAB_00105968;\n            }\n            pcVar31 \u003d *(char **)(lVar14 + 8);\n            puVar26 \u003d (undefined8 *)0x0;\n            param_32 \u003d param_32 + 1;\n            in_stack_000000d8 \u003d (ulong)param_37 + 1 + in_stack_000000d8;\n            if (param_37 !\u003d 0) {\n              puVar26 \u003d \u0026stack0x00000110;\n              cVar8 \u003d bfd_coff_get_auxent(unaff_R14,lVar14,0);\n              if (cVar8 \u003d\u003d \u0027\\0\u0027) {\n                uVar9 \u003d bfd_get_error();\n                bfd_errmsg(uVar9);\n                pcVar31 \u003d \"bfd_coff_get_auxent failed: %s\";\n                goto LAB_00105968;\n              }\n            }\n            if (param_24 !\u003d (char *)lVar37) break;\n            if (param_36 !\u003d 0x67) {\n              cVar8 \u003d debug_set_filename(__ptr_02);\n              if (cVar8 !\u003d \u0027\\0\u0027) break;\n              goto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            param_24 \u003d (char *)param_34;\n            cVar8 \u003d debug_set_filename(__ptr_02);\n            if (cVar8 \u003d\u003d \u0027\\0\u0027) goto LAB_00105981;\n          }\n          uVar6 \u003d in_stack_000000f8._6_2_;\n          if ((char)param_36 \u003c \u0027\\0\u0027) {\n            if (param_36 \u003d\u003d 0xff) goto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            lVar23 \u003d parse_coff_type_lto_priv_0(unaff_R14,\u0026stack0x000000c0,\u0026stack0x00000140);\n            if (lVar23 \u003d\u003d 0) break;\n            cVar8 \u003d parse_coff_symbol_constprop_0_isra_0(\u0026stack0x00000140,lVar14,lVar37);\n          }\n          else {\n            if (param_36 \u003c 100) {\n              switch(param_36) {\n              case 3:\n                if (in_stack_000000f8._6_2_ \u003d\u003d 0) goto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulong)((uint)in_stack_000000f8._6_2_ \u0026 *(uint *)(unaff_R14[0x22] + 0x40)) !\u003d\n                    2L \u003c\u003c ((byte)*(undefined4 *)(unaff_R14[0x22] + 0x3c) \u0026 0x3f)) goto LAB_0010700a;\n                _param_15 \u003d (int *)(**(code **)(unaff_R14[1] + 0x238))(unaff_R14);\n                uVar12 \u003d (uint)uVar6;\n                param_13 \u003d pcVar31;\n                goto switchD_00106e1a_caseD_68;\n              default:\n                goto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                goto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(param_36) {\n            case 100:\n              iVar10 \u003d strcmp(pcVar31,\".bb\");\n              if (iVar10 \u003d\u003d 0) {\n                cVar8 \u003d debug_start_block(__ptr_02);\n              }\n              else {\n                iVar10 \u003d strcmp(pcVar31,\".eb\");\n                if (iVar10 !\u003d 0) goto switchD_00106e1a_caseD_68;\n                cVar8 \u003d debug_end_block(__ptr_02);\n              }\n              break;\n            case 0x65:\n              iVar10 \u003d strcmp(pcVar31,\".bf\");\n              if (iVar10 \u003d\u003d 0) {\n                if (param_13 !\u003d (char *)0x0) {\n                  uVar13 \u003d (int)uVar12 \u003e\u003e ((byte)*(undefined4 *)(unaff_R14[0x22] + 0x44) \u0026 0x1f);\n                  lVar37 \u003d parse_coff_type_lto_priv_0\n                                     (unaff_R14,\u0026stack0x000000c0,\u0026stack0x00000140,lVar37,\n                                      uVar13 ^ (uVar12 ^ uVar13) \u0026 *(uint *)(unaff_R14[0x22] + 0x38)\n                                      ,puVar26,0,__ptr_02);\n                  if ((lVar37 \u003d\u003d 0) || (cVar7 \u003d debug_record_function(__ptr_02), cVar7 \u003d\u003d \u0027\\0\u0027))\n                  goto LAB_00105981;\n                  if (_param_15 !\u003d (int *)0x0) {\n                    iVar10 \u003d 0;\n                    if (param_37 !\u003d 0) {\n                      iVar10 \u003d param_39 - 1;\n                    }\n                    lVar14 \u003d *(long *)(*(long *)(lVar14 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar27 \u003d _param_15[4];\n                      if (iVar27 \u003d\u003d 0) break;\n                      cVar8 \u003d debug_record_line(__ptr_02,iVar10 + iVar27,\n                                                *(long *)(_param_15 + 6) + lVar14);\n                      _param_15 \u003d _param_15 + 4;\n                      if (cVar8 \u003d\u003d \u0027\\0\u0027) goto LAB_00105981;\n                    }\n                  }\n                  uVar12 \u003d 0;\n                  _param_15 \u003d (int *)0x0;\n                  param_13 \u003d (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar31 \u003d \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar10 \u003d strcmp(pcVar31,\".ef\");\n                if (iVar10 !\u003d 0) goto switchD_00106e1a_caseD_68;\n                if (cVar7 !\u003d \u0027\\0\u0027) {\n                  cVar7 \u003d debug_end_function(__ptr_02);\n                  if (cVar7 \u003d\u003d \u0027\\0\u0027) goto LAB_00105981;\n                  cVar7 \u003d \u0027\\0\u0027;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar31 \u003d \"%ld: unexpected .ef\\n\";\n              }\n              uVar17 \u003d dcgettext(0,pcVar31,5);\n              non_fatal(uVar17);\n              goto LAB_00105981;\n            default:\n              goto LAB_0010700a;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (cVar8 !\u003d \u0027\\0\u0027);\n      }\n      else {\n        pcVar31 \u003d \"%s: no recognized debugging information\";\nLAB_00105968:\n        uVar17 \u003d dcgettext(0,pcVar31,5);\n        non_fatal(uVar17);\n      }\n      goto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)(param_7 + 0x44) \u0026 0x42) !\u003d 0) \u0026\u0026 ((*(uint *)(param_7 + 0x44) \u0026 1) \u003d\u003d 0)) {\n    if ((*(char *)(*(long *)(param_7 + 8) + 0x20) \u003d\u003d \u0027\\0\u0027) \u0026\u0026 (keep_section_symbols \u003d\u003d \u0027\\0\u0027)) {\n      if (param_8 !\u003d 0) {\n        plVar28 \u003d isympp + param_8;\n        plVar15 \u003d isympp;\n        do {\n          uVar12 \u003d *(uint *)(*plVar15 + 0x18);\n          if ((uVar12 \u0026 0x1000000) !\u003d 0) {\n            *(uint *)(*plVar15 + 0x18) \u003d uVar12 \u0026 0xfeffffff;\n          }\n          plVar15 \u003d plVar15 + 1;\n        } while (plVar28 !\u003d plVar15);\n      }\n    }\n    else {\n      for (lVar14 \u003d *(long *)(param_7 + 0x90); lVar14 !\u003d 0; lVar14 \u003d *(long *)(lVar14 + 8)) {\n        if (*(long *)(lVar14 + 0xe8) !\u003d 0) {\n          puVar1 \u003d (uint *)(*(long *)(lVar14 + 0xe8) + 0x18);\n          *puVar1 \u003d *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((strip_symbols \u003d\u003d 2) || (strip_symbols \u003d\u003d 7)) {\nLAB_001059fe:\n    if (strip_symbols \u003d\u003d 7) {\nLAB_00105a3b:\n      lVar14 \u003d xmalloc();\n      plVar28 \u003d isympp;\n      param_15 \u003d *(uint *)((long)unaff_R14 + 0x44) \u0026 0x42;\n      osympp \u003d lVar14;\n      if (param_8 \u003d\u003d 0) {\n        uVar29 \u003d 0;\n      }\n      else {\n        uVar29 \u003d 0;\n        _param_9 \u003d 0;\n        do {\n          iVar10 \u003d add_symbols;\n          plVar15 \u003d (long *)plVar28[_param_9];\n          pcVar3 \u003d (code *)plVar15[4];\n          uVar12 \u003d *(uint *)(plVar15 + 3);\n          plVar20 \u003d (long *)plVar15[1];\n          plVar25 \u003d plVar20;\n          if (add_sym_list !\u003d (undefined8 *)0x0) {\n            iVar27 \u003d 0;\n            puVar26 \u003d add_sym_list;\n            while ((iVar27 \u003c iVar10 \u0026\u0026 (pcVar31 \u003d (char *)puVar26[5], pcVar31 !\u003d (char *)0x0))) {\n              if (pcVar31 !\u003d \"\") {\n                iVar11 \u003d strcmp(pcVar31,(char *)plVar20);\n                if (iVar11 \u003d\u003d 0) {\n                  free(pcVar31);\n                  uVar21 \u003d uVar29 + 1;\n                  puVar26[5] \u003d \"\";\n                  uVar16 \u003d create_new_symbol(puVar26);\n                  uVar17 \u003d redefine_specific_htab;\n                  *(undefined8 *)(lVar14 + uVar29 * 8) \u003d uVar16;\n                  lVar37 \u003d htab_elements(uVar17);\n                  if ((lVar37 !\u003d 0) || (section_rename_list !\u003d (char **)0x0)) goto LAB_001064eb;\n                  goto LAB_00105af8;\n                }\n                puVar26 \u003d (undefined8 *)*puVar26;\n              }\n              iVar27 \u003d iVar27 + 1;\n            }\n          }\n          lVar37 \u003d htab_elements(redefine_specific_htab);\n          uVar21 \u003d uVar29;\n          if ((lVar37 !\u003d 0) || (section_rename_list !\u003d (char **)0x0)) {\n            if (plVar20 !\u003d (long *)0x0) {\nLAB_001064eb:\n              if (((*(char *)plVar20 \u003d\u003d \u0027_\u0027) \u0026\u0026 (*(char *)((long)plVar20 + 1) \u003d\u003d \u0027_\u0027)) \u0026\u0026\n                 (iVar10 \u003d strcmp((char *)((ulong)(*(char *)((long)plVar20 + 2) \u003d\u003d \u0027_\u0027) +\n                                          (long)plVar20),\"__gnu_lto_slim\"), iVar10 \u003d\u003d 0)) {\n                uVar17 \u003d dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\"\n                                   ,5);\n                    \n                fatal(uVar17);\n              }\n            }\n            _param_41 \u003d 0;\n            param_40 \u003d plVar20;\n            lVar37 \u003d htab_find(redefine_specific_htab);\n            if (((lVar37 \u003d\u003d 0) || (plVar25 \u003d *(long **)(lVar37 + 8), plVar20 \u003d\u003d plVar25)) \u0026\u0026\n               (plVar25 \u003d plVar20, ppcVar34 \u003d section_rename_list, (uVar12 \u0026 0x100) !\u003d 0)) {\n              for (; ppcVar34 !\u003d (char **)0x0; ppcVar34 \u003d (char **)ppcVar34[3]) {\n                iVar10 \u003d strcmp(*ppcVar34,(char *)plVar20);\n                if (iVar10 \u003d\u003d 0) {\n                  plVar25 \u003d (long *)ppcVar34[1];\n                  break;\n                }\n              }\n            }\n            plVar15[1] \u003d (long)plVar25;\n            cVar7 \u003d *(char *)plVar25;\n            if (cVar7 !\u003d \u0027\\0\u0027) goto LAB_00105b11;\nLAB_00106557:\n            pcVar31 \u003d prefix_symbols_string;\n            if ((change_leading_char !\u003d \u0027\\0\u0027) \u0026\u0026 (*(char *)(*(long *)(param_7 + 8) + 0x1c) !\u003d \u0027\\0\u0027))\n            {\n              lVar37 \u003d unaff_R14[1];\n              cVar7 \u003d \u0027\\0\u0027;\n              goto LAB_0010668d;\n            }\n            goto joined_r0x00106565;\n          }\nLAB_00105af8:\n          cVar7 \u003d *(char *)plVar20;\n          if (cVar7 \u003d\u003d \u0027\\0\u0027) goto LAB_00106557;\nLAB_00105b11:\n          pcVar31 \u003d prefix_symbols_string;\n          lVar37 \u003d unaff_R14[1];\n          if (*(char *)(lVar37 + 0x1c) \u003d\u003d cVar7) {\n            if (change_leading_char \u003d\u003d \u0027\\0\u0027) {\n              if ((remove_leading_char \u003d\u003d \u0027\\0\u0027) ||\n                 ((((uVar12 \u0026 0x82) \u003d\u003d 0 \u0026\u0026 (pcVar3 !\u003d bfd_map_over_sections)) \u0026\u0026\n                  ((*(byte *)(plVar15[4] + 0x25) \u0026 0x10) \u003d\u003d 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n              plVar25 \u003d (long *)((long)plVar25 + 1);\n              plVar15[1] \u003d (long)plVar25;\n              goto joined_r0x00106565;\n            }\n            cVar7 \u003d *(char *)(*(long *)(param_7 + 8) + 0x1c);\n            if (cVar7 \u003d\u003d \u0027\\0\u0027) goto LAB_0010677d;\n            if (prefix_symbols_string !\u003d (char *)0x0) {\n              plVar25 \u003d (long *)((long)plVar25 + 1);\n              plVar15[1] \u003d (long)plVar25;\n              sVar18 \u003d strlen((char *)plVar25);\n              lVar37 \u003d sVar18 + 2;\nLAB_001066bc:\n              sVar18 \u003d strlen(pcVar31);\n              plVar20 \u003d (long *)xmalloc(sVar18 + lVar37);\n              goto LAB_001066d0;\n            }\n            *(char *)plVar25 \u003d cVar7;\n            plVar15[1] \u003d (long)plVar25;\n            uVar29 \u003d uVar21;\n          }\n          else {\n            if ((change_leading_char \u003d\u003d \u0027\\0\u0027) || (*(char *)(*(long *)(param_7 + 8) + 0x1c) \u003d\u003d \u0027\\0\u0027))\n            {\njoined_r0x00106565:\n              uVar29 \u003d uVar21;\n              if (pcVar31 \u003d\u003d (char *)0x0) goto LAB_00105b32;\n              sVar18 \u003d strlen((char *)plVar25);\n              sVar19 \u003d strlen(pcVar31);\n              __dest \u003d (long *)xmalloc(sVar19 + sVar18 + 1);\n              plVar20 \u003d __dest;\n            }\n            else {\nLAB_0010668d:\n              pcVar31 \u003d prefix_symbols_string;\n              if ((*(char *)(lVar37 + 0x1c) !\u003d \u0027\\0\u0027) \u0026\u0026 (cVar7 !\u003d *(char *)(lVar37 + 0x1c)))\n              goto joined_r0x00106565;\n              sVar18 \u003d strlen((char *)plVar25);\n              lVar37 \u003d sVar18 + 2;\n              if (pcVar31 !\u003d (char *)0x0) goto LAB_001066bc;\n              plVar20 \u003d (long *)xmalloc(lVar37);\nLAB_001066d0:\n              __dest \u003d (long *)((long)plVar20 + 1);\n              *(char *)plVar20 \u003d *(char *)(*(long *)(param_7 + 8) + 0x1c);\n            }\n            pcVar31 \u003d prefix_symbols_string;\n            if (prefix_symbols_string !\u003d (char *)0x0) {\n              strcpy((char *)__dest,prefix_symbols_string);\n              sVar18 \u003d strlen(pcVar31);\n              __dest \u003d (long *)((long)__dest + sVar18);\n            }\n            strcpy((char *)__dest,(char *)plVar25);\n            plVar15[1] \u003d (long)plVar20;\n            plVar25 \u003d plVar20;\n            uVar29 \u003d uVar21;\n          }\nLAB_00105b32:\n          if (strip_symbols \u003d\u003d 7) goto LAB_001067a8;\n          if (((uVar12 \u0026 0x20) \u003d\u003d 0) \u0026\u0026\n             (((uVar12 \u0026 0x100) \u003d\u003d 0 ||\n              ((*(byte *)(**(long **)(plVar15[4] + 0xf0) + 0x18) \u0026 0x20) \u003d\u003d 0)))) {\n            if (((param_15 \u003d\u003d 0) \u0026\u0026\n                (((uVar12 \u0026 0x82) !\u003d 0 || ((*(byte *)(plVar15[4] + 0x25) \u0026 0x10) !\u003d 0)))) ||\n               (iVar10 \u003d bfd_decode_symclass(plVar15), iVar10 \u003d\u003d 0x49)) {\nLAB_00105be2:\n              if (wildcard \u003d\u003d \u0027\\0\u0027) {\n                lVar37 \u003d htab_find();\n                if (lVar37 \u003d\u003d 0) goto LAB_00105c07;\n              }\n              else {\n                _param_41 \u003d _param_41 \u0026 0xffffffffffffff00;\n                param_40 \u003d plVar25;\n                htab_traverse(strip_specific_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n                if (param_41 \u003d\u003d \u0027\\0\u0027) goto LAB_00105c07;\n              }\n            }\n            else if ((((uVar12 \u0026 0x82) \u003d\u003d 0) \u0026\u0026 (pcVar3 !\u003d bfd_map_over_sections)) \u0026\u0026\n                    ((*(byte *)(plVar15[4] + 0x25) \u0026 0x10) \u003d\u003d 0)) {\n              if ((uVar12 \u0026 4) \u003d\u003d 0) {\n                if (((*(int *)(unaff_R14[1] + 8) !\u003d 2) ||\n                    (lVar37 \u003d *(long *)(plVar15[4] + 0xd0), lVar37 \u003d\u003d 0)) ||\n                   (*(long *)(lVar37 + 0x40) \u003d\u003d 0)) {\n                  if ((strip_symbols \u003d\u003d 3) || (discard_locals \u003d\u003d 2)) goto LAB_001067a8;\n                  if (discard_locals \u003d\u003d 1) {\n                    cVar7 \u003d bfd_is_local_label(unaff_R14);\n                    goto joined_r0x00106a11;\n                  }\n                }\n                goto LAB_00105be2;\n              }\n              cVar7 \u003d convert_debugging;\n              if (1 \u003c strip_symbols - 2U) {\njoined_r0x00106a11:\n                if (cVar7 \u003d\u003d \u0027\\0\u0027) goto LAB_00105be2;\n              }\n            }\n            else if (strip_symbols !\u003d 3) goto LAB_00105be2;\n            goto LAB_001067a8;\n          }\n          if (wildcard \u003d\u003d \u0027\\0\u0027) {\n            lVar37 \u003d htab_find();\n            if (lVar37 !\u003d 0) {\nLAB_0010687f:\n              uVar17 \u003d dcgettext(0,\"not stripping symbol `%s\\\u0027 because it is named in a relocation\",\n                                 5);\n              non_fatal(uVar17);\n              status \u003d 1;\n            }\n          }\n          else {\n            _param_41 \u003d _param_41 \u0026 0xffffffffffffff00;\n            param_40 \u003d plVar25;\n            htab_traverse(strip_specific_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n            if (param_41 !\u003d \u0027\\0\u0027) goto LAB_0010687f;\n          }\n          if ((uVar12 \u0026 0x20) \u003d\u003d 0) {\nLAB_00105c07:\n            if (wildcard !\u003d \u0027\\0\u0027) {\n              _param_41 \u003d _param_41 \u0026 0xffffffffffffff00;\n              param_40 \u003d plVar25;\n              htab_traverse(strip_unneeded_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n              if (param_41 !\u003d \u0027\\0\u0027) goto LAB_001067a8;\n              goto LAB_00105c2c;\n            }\n            lVar37 \u003d htab_find();\n            if (lVar37 \u003d\u003d 0) goto LAB_00105c2c;\nLAB_001067a8:\n            if ((keep_file_symbols !\u003d \u0027\\0\u0027) \u0026\u0026 ((uVar12 \u0026 0x4000) !\u003d 0)) goto LAB_00105c2c;\n            if (wildcard \u003d\u003d \u0027\\0\u0027) {\n              lVar37 \u003d htab_find();\n              if (lVar37 !\u003d 0) goto LAB_00105c2c;\n            }\n            else {\n              _param_41 \u003d _param_41 \u0026 0xffffffffffffff00;\n              param_40 \u003d plVar25;\n              htab_traverse(keep_specific_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n              if (param_41 !\u003d \u0027\\0\u0027) goto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            cVar7 \u003d is_strip_section_isra_0(plVar15[4]);\n            if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n              if (((uVar12 \u0026 0x800002) \u003d\u003d 0) \u0026\u0026 (pcVar3 !\u003d bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uVar12 \u0026 0x82) !\u003d 0) {\n                  cVar7 \u003d is_specified_symbol(plVar25);\n                  if ((cVar7 \u003d\u003d \u0027\\0\u0027) \u0026\u0026\n                     ((lVar37 \u003d htab_elements(keepglobal_specific_htab), lVar37 \u003d\u003d 0 ||\n                      (cVar7 \u003d is_specified_symbol(plVar25), cVar7 !\u003d \u0027\\0\u0027)))) {\n                    if (((((localize_hidden \u003d\u003d \u0027\\0\u0027) ||\n                          (uVar13 \u003d *(uint *)(plVar15 + 3), (uVar13 \u0026 0x200000) !\u003d 0)) ||\n                         (lVar37 \u003d *plVar15, lVar37 \u003d\u003d 0)) ||\n                        ((*(int *)(*(long *)(lVar37 + 8) + 8) !\u003d 5 ||\n                         (*(long *)(lVar37 + 0x110) \u003d\u003d 0)))) ||\n                       (1 \u003c (*(byte *)((long)plVar15 + 0x49) \u0026 3) - 1)) goto joined_r0x00106920;\n                  }\n                  else {\n                    uVar13 \u003d *(uint *)(plVar15 + 3);\n                  }\n                  *(uint *)(plVar15 + 3) \u003d uVar13 \u0026 0xffffff7d | 1;\n                }\njoined_r0x00106920:\n                if (((uVar12 \u0026 1) !\u003d 0) \u0026\u0026 (cVar7 \u003d is_specified_symbol(plVar25), cVar7 !\u003d \u0027\\0\u0027)) {\n                  *(uint *)(plVar15 + 3) \u003d *(uint *)(plVar15 + 3) \u0026 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((weaken !\u003d \u0027\\0\u0027) || (cVar7 \u003d is_specified_symbol(plVar25), cVar7 !\u003d \u0027\\0\u0027)) {\n                  *(uint *)(plVar15 + 3) \u003d *(uint *)(plVar15 + 3) \u0026 0xff7ffffd | 0x80;\n                }\n                if (pcVar3 !\u003d bfd_map_over_sections) goto LAB_00105c5f;\n              }\n              *(long **)(lVar14 + uVar29 * 8) \u003d plVar15;\n              uVar29 \u003d uVar29 + 1;\n            }\n          }\n          _param_9 \u003d _param_9 + 1;\n        } while (param_8 !\u003d _param_9);\n      }\n      if (add_sym_list !\u003d (undefined8 *)0x0) {\n        puVar26 \u003d add_sym_list;\n        iVar10 \u003d add_symbols;\n        for (lVar37 \u003d 0; lVar37 \u003c iVar10; lVar37 \u003d lVar37 + 1) {\n          pcVar31 \u003d (char *)puVar26[5];\n          if (pcVar31 \u003d\u003d (char *)0x0) {\n            lVar23 \u003d uVar29 * 8;\n            uVar29 \u003d uVar29 + 1;\n            uVar17 \u003d create_new_symbol(puVar26,param_7);\n            *(undefined8 *)(lVar14 + lVar23) \u003d uVar17;\n            iVar10 \u003d add_symbols;\n          }\n          else if (pcVar31 !\u003d \"\") {\n            uVar17 \u003d dcgettext(0,\"\\\u0027before\u003d%s\\\u0027 not found\",5);\n                    \n            fatal(uVar17,pcVar31);\n          }\n          puVar26 \u003d (undefined8 *)*puVar26;\n        }\n      }\n      bVar38 \u003d convert_debugging \u003d\u003d \u0027\\0\u0027;\n      *(undefined8 *)(lVar14 + uVar29 * 8) \u003d 0;\n      if ((bVar38) || (__ptr_02 \u003d\u003d (undefined4 *)0x0)) {\nLAB_00105cfa:\n        param_8 \u003d uVar29 \u0026 0xffffffff;\n        goto LAB_00105710;\n      }\n      iVar10 \u003d *(int *)(*(undefined8 **)(param_7 + 8) + 1);\n      if ((iVar10 \u003d\u003d 5) || (iVar10 \u003d\u003d 2)) {\n        param_33 \u003d (void *)0x0;\n        cVar7 \u003d write_stabs_in_sections_debugging_info_constprop_0\n                          (param_7,__ptr_02,\u0026stack0x000000c0,\u0026stack0x00000110,\u0026stack0x000000e0,\n                           \u0026stack0x00000140);\n        if (cVar7 !\u003d \u0027\\0\u0027) {\n          lVar14 \u003d bfd_make_section_with_flags(param_7,\".stab\",0x2108);\n          lVar37 \u003d bfd_make_section_with_flags(param_7,\".stabstr\",0x2108);\n          if ((((lVar14 \u003d\u003d 0) || (lVar37 \u003d\u003d 0)) ||\n              (cVar7 \u003d bfd_set_section_size(lVar14,param_38), cVar7 \u003d\u003d \u0027\\0\u0027)) ||\n             (cVar7 \u003d bfd_set_section_size(lVar37,param_40), cVar7 \u003d\u003d \u0027\\0\u0027)) {\n            pcVar31 \u003d \"can\\\u0027t create debugging section\";\n          }\n          else {\n            *(undefined4 *)(lVar14 + 0x7c) \u003d 2;\n            *(undefined4 *)(lVar37 + 0x7c) \u003d 0;\n            cVar7 \u003d bfd_set_section_contents(param_7,lVar14,param_30,0,param_38);\n            if ((cVar7 !\u003d \u0027\\0\u0027) \u0026\u0026\n               (cVar7 \u003d bfd_set_section_contents(param_7,lVar37,param_33,0,param_40), cVar7 !\u003d \u0027\\0\u0027)\n               ) {\n              free(__ptr_02);\n              goto LAB_00105cfa;\n            }\n            pcVar31 \u003d \"can\\\u0027t set debugging section contents\";\n          }\n          uVar17 \u003d dcgettext(0,pcVar31,5);\n          bfd_nonfatal_message(0,param_7,0,uVar17);\n          free(param_33);\n          free(__ptr_02);\n          goto LAB_00105d96;\n        }\n      }\n      else {\n        uVar17 \u003d **(undefined8 **)(param_7 + 8);\n        uVar16 \u003d dcgettext(0,\"don\\\u0027t know how to write debugging information for %s\",5);\n        bfd_nonfatal_message(0,param_7,0,uVar16,uVar17);\n      }\n      free(__ptr_02);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections(unaff_R14,mark_symbols_used_in_relocations,isympp);\n      iVar10 \u003d bfd_get_error();\n      if (iVar10 \u003d\u003d 0) goto LAB_00105a3b;\n    }\nLAB_00105d96:\n    status \u003d 1;\n  }\n  else {\n    if ((strip_symbols - 3U \u003c 4) || ((discard_locals !\u003d 0 || (localize_hidden !\u003d \u0027\\0\u0027))))\n    goto LAB_00105a07;\n    lVar14 \u003d htab_elements(strip_specific_htab);\n    if (((lVar14 !\u003d 0) ||\n        ((((lVar14 \u003d htab_elements(keep_specific_htab), lVar14 !\u003d 0 ||\n           (lVar14 \u003d htab_elements(localize_specific_htab), lVar14 !\u003d 0)) ||\n          (lVar14 \u003d htab_elements(globalize_specific_htab), lVar14 !\u003d 0)) ||\n         ((lVar14 \u003d htab_elements(keepglobal_specific_htab), lVar14 !\u003d 0 ||\n          (lVar14 \u003d htab_elements(weaken_specific_htab), lVar14 !\u003d 0)))))) ||\n       ((((lVar14 \u003d htab_elements(redefine_specific_htab), lVar14 !\u003d 0 ||\n          ((prefix_symbols_string !\u003d (char *)0x0 || (sections_removed !\u003d \u0027\\0\u0027)))) ||\n         (sections_copied !\u003d \u0027\\0\u0027)) ||\n        ((((convert_debugging !\u003d \u0027\\0\u0027 || (change_leading_char !\u003d \u0027\\0\u0027)) ||\n          (remove_leading_char !\u003d \u0027\\0\u0027)) ||\n         (((section_rename_list !\u003d (char **)0x0 || (weaken !\u003d \u0027\\0\u0027)) || (add_symbols !\u003d 0))))))))\n    goto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(param_7,osympp,param_8 \u0026 0xffffffff);\n    bfd_map_over_sections(unaff_R14,copy_relocations_in_section,param_7);\n    bfd_map_over_sections(unaff_R14,copy_section,param_7);\n    for (puVar26 \u003d add_sections; puVar4 \u003d update_sections, puVar26 !\u003d (undefined8 *)0x0;\n        puVar26 \u003d (undefined8 *)*puVar26) {\n      cVar7 \u003d bfd_set_section_contents(param_7,puVar26[5],puVar26[4],0,puVar26[3]);\n      if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n        bfd_nonfatal_message(0,param_7,puVar26[5],0);\n        return 0;\n      }\n    }\n    for (; puVar4 !\u003d (undefined8 *)0x0; puVar4 \u003d (undefined8 *)*puVar4) {\n      uVar17 \u003d *(undefined8 *)(puVar4[5] + 0x60);\n      cVar7 \u003d bfd_set_section_contents(param_7,uVar17,puVar4[4],0,puVar4[3]);\n      if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n        bfd_nonfatal_message(0,param_7,uVar17,0);\n        return 0;\n      }\n    }\n    if (in_R10 \u003d\u003d (long *)0x0) {\n      if ((merge_notes !\u003d \u0027\\0\u0027) \u0026\u0026 (is_strip \u003d\u003d 0)) {\n        uVar17 \u003d *unaff_R14;\n        uVar16 \u003d dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n        non_fatal(uVar16,uVar17);\n      }\n    }\n    else {\n      plVar28 \u003d (long *)0x0;\n      for (puVar26 \u003d *(undefined8 **)(param_7 + 0x90); puVar26 !\u003d (undefined8 *)0x0;\n          puVar26 \u003d (undefined8 *)puVar26[1]) {\n        if (((merge_notes !\u003d \u0027\\0\u0027) \u0026\u0026 (*(int *)(*(long *)(param_7 + 8) + 8) \u003d\u003d 5)) \u0026\u0026\n           ((*(int *)(puVar26[0x1a] + 4) \u003d\u003d 7 \u0026\u0026\n            (cVar7 \u003d startswith_lto_priv_0_lto_priv_0(*puVar26,\".gnu.build.attributes\"),\n            cVar7 !\u003d \u0027\\0\u0027)))) {\n          if (plVar28 \u003d\u003d (long *)0x0) {\n            plVar28 \u003d in_R10;\n          }\n          plVar15 \u003d in_R10;\n          if (*(undefined8 **)(*plVar28 + 0x60) \u003d\u003d puVar26) {\nLAB_0010625f:\n            pcVar31 \u003d \"error: failed to merge notes\";\n            if (plVar28[1] !\u003d 0) {\n              cVar7 \u003d bfd_set_section_contents(param_7,puVar26,plVar28[1],0,plVar28[2]);\n              if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n                uVar17 \u003d dcgettext(0,\"error: failed to copy merged notes into output\",5);\n                bfd_nonfatal_message(0,param_7,puVar26,uVar17);\n                return 0;\n              }\n              plVar28 \u003d (long *)plVar28[3];\n              goto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              plVar28 \u003d plVar15;\n              if (*(undefined8 **)(*plVar15 + 0x60) \u003d\u003d puVar26) goto LAB_0010625f;\n              plVar28 \u003d (long *)plVar15[3];\n              plVar15 \u003d plVar28;\n            } while (plVar28 !\u003d (long *)0x0);\n            pcVar31 \u003d \"error: failed to locate merged notes\";\n          }\n          uVar17 \u003d dcgettext(0,pcVar31,5);\n          bfd_nonfatal_message(0,param_7,puVar26,uVar17);\n        }\nLAB_001061be:\n      }\n      do {\n        plVar28 \u003d (long *)in_R10[3];\n        free((void *)in_R10[1]);\n        free(in_R10);\n        in_R10 \u003d plVar28;\n      } while (plVar28 !\u003d (long *)0x0);\n    }\n    if ((gnu_debuglink_filename \u003d\u003d 0) ||\n       (cVar7 \u003d bfd_fill_in_gnu_debuglink_section(param_7,param_21), lVar14 \u003d gnu_debuglink_filename\n       , cVar7 !\u003d \u0027\\0\u0027)) {\n      if (param_14 !\u003d (undefined *)0x0) {\n        if (0x2000 \u003c param_12) {\n          param_12 \u003d 0x2000;\n        }\n        lVar14 \u003d 0;\n        __ptr \u003d (undefined *)xmalloc(param_12);\n        uVar5 \u003d gap_fill;\n        puVar33 \u003d __ptr;\n        for (param_12 \u003d param_12 \u0026 0xffffffff; param_12 !\u003d 0; param_12 \u003d param_12 - 1) {\n          *puVar33 \u003d uVar5;\n          puVar33 \u003d puVar33 + (ulong)bVar39 * -2 + 1;\n        }\n        for (; (uint)lVar14 \u003c in_stack_00000068._4_4_; lVar14 \u003d lVar14 + 1) {\n          uVar29 \u003d *(ulong *)(param_14 + lVar14 * 8);\n          if (uVar29 !\u003d 0) {\n            lVar37 \u003d *(long *)(*param_17 + 0x40) - uVar29;\n            do {\n              uVar21 \u003d 0x2000;\n              if (uVar29 \u003c 0x2001) {\n                uVar21 \u003d uVar29;\n              }\n              cVar7 \u003d bfd_set_section_contents(param_7,*param_17,__ptr,lVar37,uVar21);\n              if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n                bfd_nonfatal_message(0,param_7,*param_17,0);\n                free(__ptr);\n                return 0;\n              }\n              lVar37 \u003d lVar37 + uVar21;\n              uVar29 \u003d uVar29 - uVar21;\n            } while (uVar29 !\u003d 0);\n          }\n          param_17 \u003d param_17 + 1;\n        }\n        free(__ptr);\n        free(param_14);\n      }\n      uVar9 \u003d (**(code **)(*(long *)(param_7 + 8) + 0x140))(unaff_R14);\n      if ((char)uVar9 !\u003d \u0027\\0\u0027) {\n        if (use_alt_mach_code \u003d\u003d 0) {\n          return uVar9;\n        }\n        cVar7 \u003d bfd_alt_mach_code(param_7,use_alt_mach_code \u0026 0xffffffff);\n        uVar29 \u003d use_alt_mach_code;\n        if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n          uVar17 \u003d dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n          non_fatal(uVar17,uVar29);\n          if (*(int *)(*(long *)(param_7 + 8) + 8) \u003d\u003d 5) {\n            uVar17 \u003d dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n            non_fatal(uVar17);\n            *(short *)(*(long *)(param_7 + 0x110) + 0x3a) \u003d (short)use_alt_mach_code;\n            return uVar9;\n          }\n          uVar17 \u003d dcgettext(0,\"ignoring the alternative value\",5);\n          non_fatal(uVar17);\n          return uVar9;\n        }\n        return uVar9;\n      }\n      uVar17 \u003d dcgettext(0,\"error copying private BFD data\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar17);\n    }\n    else {\n      uVar17 \u003d dcgettext(0,\"cannot fill debug link section `%s\\\u0027\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar17,lVar14);\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107880"
      ],
      "called": [
        "htab_elements",
        "strlen",
        "bfd_set_section_size",
        "concat",
        "bfd_set_error",
        "parse_coff_symbol.constprop.0.isra.0",
        "bfd_make_section_with_flags",
        "parse_stab",
        "debug_record_function",
        "strcmp",
        "bfd_is_local_label",
        "bfd_map_over_sections",
        "mark_symbols_used_in_relocations",
        "is_specified_symbol_predicate",
        "xmalloc",
        "non_fatal",
        "debug_end_function",
        "debug_set_filename",
        "bfd_octets_per_byte",
        "parse_coff_type.lto_priv.0",
        "htab_find",
        "is_specified_symbol",
        "debug_end_block",
        "bfd_coff_get_auxent",
        "fatal",
        "get_sections",
        "stab_context",
        "bfd_get_section_contents",
        "bfd_map_over_sections",
        "bfd_decode_symclass",
        "htab_traverse",
        "xstrdup",
        "is_strip_section.isra.0",
        "bfd_coff_get_syment",
        "free",
        "finish_stab",
        "bfd_get_section_by_name",
        "compare_section_lma",
        "dcgettext",
        "bfd_set_section_contents",
        "bfd_fill_in_gnu_debuglink_section",
        "copy_section",
        "start_stab.constprop.0",
        "bfd_alt_mach_code",
        "copy_relocations_in_section",
        "startswith.lto_priv.0.lto_priv.0",
        "strcpy",
        "write_stabs_in_sections_debugging_info.constprop.0",
        "bfd_set_symtab",
        "fprintf",
        "save_stab",
        "debug_start_block",
        "create_new_symbol",
        "qsort",
        "bfd_get_error",
        "bfd_errmsg",
        "debug_record_line",
        "free_saved_stabs",
        "bfd_nonfatal_message"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00105828": {
      "entrypoint": "0x00105828",
      "current_name": "FUN_00105828",
      "code": "\nundefined8 FUN_00105828(void)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  \n  iVar1 \u003d bfd_get_arch();\n  if (iVar1 \u003d\u003d 0) {\n    uVar3 \u003d bfd_get_archive_filename();\n    uVar4 \u003d dcgettext(0,\"Unable to recognise the format of the input file `%s\\\u0027\",5);\n    non_fatal(uVar4,uVar3);\n  }\n  else {\n    uVar3 \u003d bfd_get_mach();\n    uVar2 \u003d bfd_get_arch();\n    uVar3 \u003d bfd_printable_arch_mach(uVar2,uVar3);\n    uVar4 \u003d dcgettext(0,\"Output file cannot represent architecture `%s\\\u0027\",5);\n    non_fatal(uVar4,uVar3);\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107880"
      ],
      "called": [
        "bfd_get_mach",
        "non_fatal",
        "dcgettext",
        "bfd_printable_arch_mach",
        "bfd_get_archive_filename",
        "bfd_get_arch"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00107880": {
      "entrypoint": "0x00107880",
      "current_name": "FUN_00107880",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong FUN_00107880(void)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  undefined *puVar3;\n  long *plVar4;\n  code *pcVar5;\n  long *plVar6;\n  ulong uVar7;\n  ulong uVar8;\n  char *__s;\n  char cVar9;\n  char cVar10;\n  uint uVar11;\n  int iVar12;\n  uint uVar13;\n  undefined4 uVar14;\n  int iVar15;\n  long *plVar16;\n  long lVar17;\n  undefined8 uVar18;\n  undefined8 uVar19;\n  size_t sVar20;\n  size_t sVar21;\n  char *pcVar22;\n  void *__ptr;\n  void *__ptr_00;\n  ulong uVar23;\n  long lVar24;\n  ulong uVar25;\n  long in_RAX;\n  int *piVar26;\n  long lVar27;\n  ulong uVar28;\n  FILE *__s_00;\n  long **pplVar29;\n  long **__ptr_01;\n  char *pcVar30;\n  undefined8 *puVar31;\n  ulong uVar32;\n  int iVar33;\n  long **pplVar34;\n  char *pcVar35;\n  undefined4 *puVar36;\n  undefined8 *puVar37;\n  char **ppcVar38;\n  void *pvVar39;\n  undefined8 *unaff_R14;\n  undefined **ppuVar40;\n  bool bVar41;\n  byte bVar42;\n  long param_7;\n  ulong param_8;\n  char param_9;\n  undefined4 *param_10;\n  char *pcStack0000000000000038;\n  uint uStack0000000000000048;\n  int param_11;\n  long param_12;\n  long lStack0000000000000088;\n  char *pcStack0000000000000090;\n  long lStack00000000000000a0;\n  long *in_stack_000000c0;\n  ulong in_stack_000000c8;\n  long in_stack_000000d0;\n  long in_stack_000000d8;\n  void *in_stack_000000e0;\n  long in_stack_000000f0;\n  undefined8 in_stack_000000f8;\n  byte bStack0000000000000100;\n  byte bStack0000000000000101;\n  undefined8 in_stack_00000110;\n  ushort in_stack_00000118;\n  char *param_13;\n  char cStack0000000000000148;\n  char *in_stack_00000150;\n  undefined uStack0000000000000158;\n  short sStack000000000000015a;\n  \n  bVar42 \u003d 0;\n  cVar10 \u003d (**(code **)(*(long *)(param_7 + 8) + 0x2a0))\n                     (param_7,**(undefined4 **)(in_RAX + 0x380),0);\n  if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n    if ((*(byte *)(unaff_R14 + 9) \u0026 0x40) !\u003d 0) {\n      iVar12 \u003d bfd_get_arch();\n      if (iVar12 \u003d\u003d 0) {\n        uVar19 \u003d bfd_get_archive_filename();\n        uVar18 \u003d dcgettext(0,\"Unable to recognise the format of the input file `%s\\\u0027\",5);\n        non_fatal(uVar18,uVar19);\n        return 0;\n      }\n      uVar19 \u003d bfd_get_mach();\n      uVar14 \u003d bfd_get_arch();\n      uVar19 \u003d bfd_printable_arch_mach(uVar14,uVar19);\n      uVar18 \u003d dcgettext(0,\"Output file cannot represent architecture `%s\\\u0027\",5);\n      non_fatal(uVar18,uVar19);\n      return 0;\n    }\n    iVar12 \u003d bfd_get_arch();\n    iVar33 \u003d bfd_get_arch(param_7);\n    if (iVar12 !\u003d iVar33) {\n      uVar28 \u003d FUN_00105828();\n      return uVar28;\n    }\n  }\n  cVar10 \u003d bfd_set_format(param_7,*(byte *)(unaff_R14 + 9) \u0026 7);\n  if (cVar10 \u003d\u003d \u0027\\0\u0027) {\nLAB_00107a82:\n    bfd_nonfatal_message(0);\n    return 0;\n  }\n  if ((*(int *)(*(undefined8 **)(param_7 + 8) + 1) \u003d\u003d 2) \u0026\u0026\n     (cVar10 \u003d startswith_lto_priv_0_lto_priv_0(**(undefined8 **)(param_7 + 8),\u0026DAT_0011b503),\n     cVar10 !\u003d \u0027\\0\u0027)) {\n    lVar27 \u003d *(long *)(param_7 + 0x110);\n    if ((*(int *)((undefined8 *)unaff_R14[1] + 1) \u003d\u003d 2) \u0026\u0026\n       (cVar10 \u003d startswith_lto_priv_0_lto_priv_0(*(undefined8 *)unaff_R14[1],\u0026DAT_0011b503),\n       cVar10 !\u003d \u0027\\0\u0027)) {\n      lVar17 \u003d unaff_R14[0x22];\n      bVar41 \u003d preserve_dates \u003d\u003d \u0027\\0\u0027;\n      puVar31 \u003d (undefined8 *)(lVar17 + 200);\n      puVar37 \u003d (undefined8 *)(lVar27 + 200);\n      for (lVar24 \u003d 0x32; lVar24 !\u003d 0; lVar24 \u003d lVar24 + -1) {\n        *puVar37 \u003d *puVar31;\n        puVar31 \u003d puVar31 + (ulong)bVar42 * -2 + 1;\n        puVar37 \u003d puVar37 + (ulong)bVar42 * -2 + 1;\n      }\n      if (bVar41) {\n        *(undefined4 *)(lVar27 + 0x2a4) \u003d 0xffffffff;\n      }\n      else {\n        *(int *)(lVar27 + 0x2a4) \u003d (int)*(undefined8 *)(lVar17 + 0xa8);\n      }\n    }\n    uVar28 \u003d pe_file_alignment;\n    if (pe_file_alignment \u003d\u003d 0xffffffffffffffff) {\n      pe_file_alignment \u003d 0x200;\n      uVar28 \u003d 0x200;\n    }\n    else {\n      *(int *)(lVar27 + 0x10c) \u003d (int)pe_file_alignment;\n    }\n    if (pe_heap_commit !\u003d -1) {\n      *(long *)(lVar27 + 0x148) \u003d pe_heap_commit;\n    }\n    if (pe_heap_reserve !\u003d -1) {\n      *(long *)(lVar27 + 0x148) \u003d pe_heap_reserve;\n    }\n    if (pe_image_base !\u003d -1) {\n      *(long *)(lVar27 + 0x100) \u003d pe_image_base;\n    }\n    uVar23 \u003d pe_section_alignment;\n    if (pe_section_alignment \u003d\u003d 0xffffffffffffffff) {\n      pe_section_alignment \u003d 0x1000;\n      uVar23 \u003d 0x1000;\n    }\n    else {\n      *(int *)(lVar27 + 0x108) \u003d (int)pe_section_alignment;\n    }\n    if (pe_stack_commit !\u003d -1) {\n      *(long *)(lVar27 + 0x138) \u003d pe_stack_commit;\n    }\n    if (pe_stack_reserve !\u003d -1) {\n      *(long *)(lVar27 + 0x138) \u003d pe_stack_reserve;\n    }\n    if (pe_subsystem !\u003d -1) {\n      *(short *)(lVar27 + 300) \u003d pe_subsystem;\n    }\n    if (pe_major_subsystem_version !\u003d -1) {\n      *(short *)(lVar27 + 0x118) \u003d pe_major_subsystem_version;\n    }\n    if (pe_minor_subsystem_version !\u003d -1) {\n      *(short *)(lVar27 + 0x11a) \u003d pe_minor_subsystem_version;\n    }\n    if (uVar23 \u003c uVar28) {\n      uVar19 \u003d dcgettext(0,\"warning: file alignment (0x%lx) \u003e section alignment (0x%lx)\",5);\n      non_fatal(uVar19,uVar28,uVar23);\n    }\n  }\n  plVar6 \u003d isympp;\n  free(isympp);\n  if (plVar6 \u003d\u003d osympp) {\n    isympp \u003d (long *)0x0;\n    osympp \u003d (long *)0x0;\n    lVar27 \u003d (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  else {\n    free(osympp);\n    isympp \u003d (long *)0x0;\n    osympp \u003d (long *)0x0;\n    lVar27 \u003d (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  if (lVar27 \u003c 0) goto LAB_00107a82;\n  osympp \u003d (long *)xmalloc();\n  isympp \u003d osympp;\n  param_8 \u003d (**(code **)(unaff_R14[1] + 0x200))();\n  if ((long)param_8 \u003c 0) goto LAB_00107a82;\n  if (param_8 \u003d\u003d 0) {\n    free(isympp);\n    isympp \u003d (long *)0x0;\n    osympp \u003d (long *)0x0;\n  }\n  bfd_map_over_sections();\n  puVar31 \u003d add_sections;\n  if ((extract_symbol \u003d\u003d \u0027\\0\u0027) \u0026\u0026\n     (cVar10 \u003d (**(code **)(*(long *)(param_7 + 8) + 0x168))(), puVar31 \u003d add_sections,\n     cVar10 \u003d\u003d \u0027\\0\u0027)) {\n    status \u003d 1;\n    dcgettext(0,\"error in private header data\",5);\n    bfd_nonfatal_message(0);\n    puVar31 \u003d add_sections;\n  }\n  for (; puVar37 \u003d update_sections, puVar31 !\u003d (undefined8 *)0x0; puVar31 \u003d (undefined8 *)*puVar31)\n  {\n    uVar11 \u003d 0x128;\n    lVar27 \u003d find_section_list(puVar31[1],0,0x80);\n    if (lVar27 !\u003d 0) {\n      uVar11 \u003d check_new_section_flags(*(uint *)(lVar27 + 0x28) | 0x100,param_7,puVar31[1]);\n    }\n    lVar27 \u003d bfd_get_section_by_name(param_7,puVar31[1]);\n    if (lVar27 !\u003d 0) {\n      uVar19 \u003d puVar31[1];\n      uVar18 \u003d dcgettext(0,\"can\\\u0027t add section \\\u0027%s\\\u0027\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar18,uVar19);\n      return 0;\n    }\n    lVar27 \u003d bfd_make_section_with_flags(param_7,puVar31[1],uVar11 | 0x100000);\n    puVar31[5] \u003d lVar27;\n    if (lVar27 \u003d\u003d 0) {\n      uVar19 \u003d puVar31[1];\n      uVar18 \u003d dcgettext(0,\"can\\\u0027t create section `%s\\\u0027\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar18,uVar19);\n      return 0;\n    }\n    cVar10 \u003d bfd_set_section_size();\n    if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n      bfd_nonfatal_message(0,param_7,puVar31[5],0);\n      return 0;\n    }\n    lVar27 \u003d find_section_list(puVar31[1],0,0x18);\n    if (lVar27 !\u003d 0) {\n      uVar19 \u003d *(undefined8 *)(lVar27 + 0x18);\n      lVar27 \u003d puVar31[5];\n      *(byte *)(lVar27 + 0x28) \u003d *(byte *)(lVar27 + 0x28) | 1;\n      *(undefined8 *)(lVar27 + 0x30) \u003d uVar19;\n      *(undefined8 *)(lVar27 + 0x38) \u003d uVar19;\n    }\n    lVar27 \u003d find_section_list(puVar31[1],0,0x60);\n    if (lVar27 !\u003d 0) {\n      lVar17 \u003d puVar31[5];\n      *(undefined8 *)(lVar17 + 0x38) \u003d *(undefined8 *)(lVar27 + 0x20);\n      if (0x3e \u003c *(uint *)(lVar17 + 0x7c)) {\n        bfd_nonfatal_message(0,param_7,lVar17,0);\n        return 0;\n      }\n    }\n  }\n  for (; puVar37 !\u003d (undefined8 *)0x0; puVar37 \u003d (undefined8 *)*puVar37) {\n    lVar27 \u003d bfd_get_section_by_name();\n    puVar37[5] \u003d lVar27;\n    if (lVar27 \u003d\u003d 0) {\n      uVar19 \u003d puVar37[1];\n      uVar18 \u003d dcgettext(0,\"error: %s not found, can\\\u0027t be updated\",5);\n      non_fatal(uVar18,uVar19);\n      return 0;\n    }\n    uVar19 \u003d *(undefined8 *)(lVar27 + 0x60);\n    cVar10 \u003d bfd_set_section_size(uVar19);\n    if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n      bfd_nonfatal_message(0,param_7,uVar19,0);\n      return 0;\n    }\n  }\n  puVar31 \u003d dump_sections;\n  if (merge_notes \u003d\u003d \u0027\\0\u0027) {\n    __ptr_01 \u003d (long **)0x0;\n  }\n  else {\n    pplVar34 \u003d (long **)unaff_R14[0x12];\n    __ptr_01 \u003d pplVar34;\n    if (pplVar34 !\u003d (long **)0x0) {\n      __ptr_01 \u003d (long **)0x0;\nLAB_001151ab:\n      if (merge_notes !\u003d \u0027\\0\u0027) goto LAB_00115187;\n      for (plVar6 \u003d pplVar34[1]; puVar31 \u003d dump_sections, plVar6 !\u003d (long *)0x0;\n          plVar6 \u003d (long *)plVar6[1]) {\n      }\n    }\n  }\njoined_r0x001151c7:\n  for (; puVar31 !\u003d (undefined8 *)0x0; puVar31 \u003d (undefined8 *)*puVar31) {\n    lVar27 \u003d bfd_get_section_by_name();\n    if (lVar27 \u003d\u003d 0) {\n      dcgettext(0,\"can\\\u0027t dump section \\\u0027%s\\\u0027 - it does not exist\",5);\n      bfd_nonfatal_message(0);\n    }\n    else if ((*(byte *)(lVar27 + 0x25) \u0026 1) \u003d\u003d 0) {\n      dcgettext(0,\"can\\\u0027t dump section - it has no contents\",5);\n      bfd_nonfatal_message(0);\n    }\n    else {\n      sVar20 \u003d *(size_t *)(lVar27 + 0x40);\n      __s_00 \u003d fopen((char *)puVar31[2],\"w\");\n      if (__s_00 \u003d\u003d (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        bfd_nonfatal_message(puVar31[2],0,0);\n      }\n      else {\n        cVar10 \u003d bfd_malloc_and_get_section();\n        if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          bfd_nonfatal_message(0);\n        }\n        else if ((sVar20 !\u003d 0) \u0026\u0026 (sVar21 \u003d fwrite(param_13,1,sVar20,__s_00), sVar21 !\u003d sVar20)) {\n          piVar26 \u003d __errno_location();\n          pcVar35 \u003d strerror(*piVar26);\n          uVar19 \u003d puVar31[2];\n          uVar18 \u003d dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          non_fatal(uVar18,uVar19,pcVar35);\n          free(param_13);\n          fclose(__s_00);\n          return 0;\n        }\n        fclose(__s_00);\n        free(param_13);\n      }\n    }\n  }\n  if (gnu_debuglink_filename \u003d\u003d 0) {\nLAB_0010790a:\n    param_12 \u003d 0;\n  }\n  else {\n    lVar27 \u003d bfd_get_section_by_name(param_7,\".gnu_debuglink\");\n    if (lVar27 !\u003d 0) {\n      uVar19 \u003d dcgettext(0,\"%s: debuglink section already exists\",5);\n      non_fatal(uVar19);\n      gnu_debuglink_filename \u003d 0;\n      goto LAB_0010790a;\n    }\n    param_12 \u003d bfd_create_gnu_debuglink_section(param_7);\n    lVar27 \u003d gnu_debuglink_filename;\n    if (param_12 \u003d\u003d 0) {\n      uVar19 \u003d dcgettext(0,\"cannot create debug link section `%s\\\u0027\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar19,lVar27);\n      return 0;\n    }\n    if (*(int *)(*(long *)(param_7 + 8) + 8) \u003d\u003d 2) {\n      uVar23 \u003d 0;\n      for (uVar28 \u003d *(ulong *)(param_7 + 0x90); uVar28 !\u003d 0; uVar28 \u003d *(ulong *)(uVar28 + 8)) {\n        uVar25 \u003d *(ulong *)(uVar28 + 0x30);\n        uVar32 \u003d uVar23;\n        uVar7 \u003d uVar28;\n        uVar8 \u003d uVar23;\n        if (uVar25 !\u003d 0) {\n          while ((uVar32 \u003d uVar7, uVar8 !\u003d 0 \u0026\u0026\n                 (uVar32 \u003d uVar28, uVar25 \u003c\u003d *(ulong *)(uVar23 + 0x30)))) {\n            uVar28 \u003d *(ulong *)(uVar28 + 8);\n            if (uVar28 \u003d\u003d 0) goto LAB_00107db8;\n            uVar25 \u003d *(ulong *)(uVar28 + 0x30);\n            uVar7 \u003d uVar23;\n            uVar8 \u003d uVar25;\n          }\n        }\n        uVar23 \u003d uVar32;\n      }\nLAB_00107db8:\n      if (uVar23 \u003d\u003d 0) {\n        uVar28 \u003d 0x1000;\n      }\n      else {\n        uVar23 \u003d *(long *)(uVar23 + 0x40) + *(long *)(uVar23 + 0x30);\n        uVar28 \u003d 0xffffffffffffffff;\n        if (uVar23 \u003c 0xfffffffffffff001) {\n          uVar28 \u003d uVar23 + 0xfff \u0026 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(param_12 + 0x28) \u003d *(byte *)(param_12 + 0x28) | 1;\n      *(ulong *)(param_12 + 0x30) \u003d uVar28;\n      *(ulong *)(param_12 + 0x38) \u003d uVar28;\n    }\n  }\n  plVar6 \u003d isympp;\n  param_11 \u003d *(int *)(param_7 + 0xa0);\n  if (param_11 !\u003d 0) {\n    uVar28 \u003d FUN_0010554f();\n    return uVar28;\n  }\n  if (convert_debugging \u003d\u003d \u0027\\0\u0027) {\nLAB_00105588:\n    param_10 \u003d (undefined4 *)0x0;\n  }\n  else {\n    ppuVar40 \u003d \u0026names_0;\n    param_10 \u003d (undefined4 *)xmalloc(0x60);\n    puVar36 \u003d param_10;\n    for (lVar27 \u003d 0x18; lVar27 !\u003d 0; lVar27 \u003d lVar27 + -1) {\n      *puVar36 \u003d 0;\n      puVar36 \u003d puVar36 + (ulong)bVar42 * -2 + 1;\n    }\n    pcStack0000000000000038 \u003d (char *)0x0;\n    do {\n      puVar3 \u003d *ppuVar40;\n      lVar27 \u003d bfd_get_section_by_name();\n      lVar17 \u003d bfd_get_section_by_name();\n      if ((lVar27 !\u003d 0) \u0026\u0026 (lVar17 !\u003d 0)) {\n        lVar27 \u003d *(long *)(lVar27 + 0x40);\n        __ptr \u003d (void *)xmalloc(lVar27);\n        cVar10 \u003d bfd_get_section_contents();\n        if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n          uVar14 \u003d bfd_get_error();\n          bfd_errmsg(uVar14);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n          free(pcStack0000000000000038);\n          free(__ptr);\n        }\n        else {\n          uVar28 \u003d *(ulong *)(lVar17 + 0x40);\n          __ptr_00 \u003d (void *)xmalloc(uVar28 + 1);\n          param_9 \u003d bfd_get_section_contents();\n          if (param_9 \u003d\u003d \u0027\\0\u0027) {\n            uVar14 \u003d bfd_get_error();\n            bfd_errmsg(uVar14);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n            free(pcStack0000000000000038);\n          }\n          else {\n            *(undefined *)((long)__ptr_00 + uVar28) \u003d 0;\n            if ((pcStack0000000000000038 !\u003d (char *)0x0) ||\n               (pcStack0000000000000038 \u003d (char *)start_stab_constprop_0(),\n               pcStack0000000000000038 !\u003d (char *)0x0)) {\n              lStack00000000000000a0 \u003d 0;\n              lStack0000000000000088 \u003d 0;\n              for (pvVar39 \u003d __ptr; pvVar39 \u003c\u003d (void *)((long)__ptr + lVar27 + -0xc);\n                  pvVar39 \u003d (void *)((long)pvVar39 + 0xc)) {\n                uVar23 \u003d (**(code **)(unaff_R14[1] + 0x40))(pvVar39);\n                bVar2 \u003d *(byte *)((long)pvVar39 + 4);\n                uVar14 \u003d (**(code **)(unaff_R14[1] + 0x58))((long)pvVar39 + 6);\n                lVar17 \u003d (**(code **)(unaff_R14[1] + 0x40))((long)pvVar39 + 8);\n                if (bVar2 \u003d\u003d 0) {\n                  lStack0000000000000088 \u003d lStack00000000000000a0;\n                  lStack00000000000000a0 \u003d lStack00000000000000a0 + lVar17;\n                }\n                else {\n                  uVar25 \u003d (uVar23 \u0026 0xffffffff) + lStack0000000000000088;\n                  if (uVar25 \u003c uVar28) {\n                    pcVar35 \u003d (char *)((long)__ptr_00 + uVar25);\n                    pcStack0000000000000090 \u003d (char *)0x0;\n                    while( true ) {\n                      sVar20 \u003d strlen(pcVar35);\n                      if (((sVar20 \u003d\u003d 0) || (pcVar30 \u003d pcVar35 + (sVar20 - 1), *pcVar30 !\u003d \u0027\\\\\u0027)) ||\n                         ((ulong)((long)__ptr + lVar27) \u003c (long)pvVar39 + 0x10U)) goto LAB_001077fb;\n                      *pcVar30 \u003d \u0027\\0\u0027;\n                      pvVar39 \u003d (void *)((long)pvVar39 + 0xc);\n                      iVar12 \u003d (**(code **)(unaff_R14[1] + 0x40))(pvVar39);\n                      uVar23 \u003d (ulong)(uint)(iVar12 + (int)lStack0000000000000088);\n                      if (uVar28 \u003c\u003d uVar23) break;\n                      pcVar35 \u003d (char *)concat(pcVar35,(long)__ptr_00 + uVar23,0);\n                      *pcVar30 \u003d \u0027\\\\\u0027;\n                      free(pcStack0000000000000090);\n                      pcStack0000000000000090 \u003d pcVar35;\n                    }\n                    uVar19 \u003d *unaff_R14;\n                    pcVar30 \u003d (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar30,uVar19,puVar3,((long)pvVar39 - (long)__ptr) / 0xc);\nLAB_001077fb:\n                    save_stab((ulong)bVar2,uVar14,lVar17,pcVar35);\n                    cVar10 \u003d parse_stab(param_10,pcStack0000000000000038,bVar2);\n                    if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n                      stab_context();\n                      free_saved_stabs();\n                      free(pcStack0000000000000090);\n                      free(pcStack0000000000000038);\n                      free(__ptr);\n                      free(__ptr_00);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar19 \u003d *unaff_R14;\n                    pcVar35 \u003d (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx \u003d 0x%x, type \u003d %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar35,uVar19,puVar3,((long)pvVar39 - (long)__ptr) / 0xc,\n                            uVar23 \u0026 0xffffffff,(ulong)bVar2,((long)pvVar39 - (long)__ptr) % 0xc);\n                  }\n                }\n              }\n              free_saved_stabs();\n              free(__ptr);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_00);\n          free(__ptr);\n        }\n        goto LAB_00105981;\n      }\nLAB_001058eb:\n      ppuVar40 \u003d ppuVar40 + 2;\n    } while (ppuVar40 !\u003d (undefined **)\u0026DAT_00125c90);\n    if ((pcStack0000000000000038 !\u003d (char *)0x0) \u0026\u0026 (cVar10 \u003d finish_stab(), cVar10 \u003d\u003d \u0027\\0\u0027)) {\nLAB_00105981:\n      free(param_10);\n      goto LAB_00105588;\n    }\n    if (*(int *)(unaff_R14[1] + 8) \u003d\u003d 1) {\n      lVar27 \u003d 0;\n      for (plVar16 \u003d plVar6; plVar16 \u003c plVar6 + param_8; plVar16 \u003d plVar16 + 1) {\n        (**(code **)(unaff_R14[1] + 0x218))();\n        if (cStack0000000000000148 \u003d\u003d \u0027-\u0027) {\n          if (((lVar27 \u003d\u003d 0) \u0026\u0026 (lVar27 \u003d start_stab_constprop_0(), lVar27 \u003d\u003d 0)) ||\n             ((in_stack_00000150 \u003d\u003d (char *)0x0 || (*in_stack_00000150 \u003d\u003d \u0027\\0\u0027))))\n          goto LAB_00105981;\n          pcVar35 \u003d (char *)0x0;\n          pcVar30 \u003d in_stack_00000150;\n          while (((*pcVar30 !\u003d \u0027\\0\u0027 \u0026\u0026 (sVar20 \u003d strlen(pcVar30), pcVar30[sVar20 - 1] \u003d\u003d \u0027\\\\\u0027)) \u0026\u0026\n                 (plVar16 + 1 \u003c plVar6 + param_8))) {\n            pcVar22 \u003d (char *)xstrdup(pcVar30);\n            sVar20 \u003d strlen(pcVar22);\n            pcVar22[sVar20 - 1] \u003d \u0027\\0\u0027;\n            pcVar30 \u003d (char *)concat(pcVar22,*(undefined8 *)(plVar16[1] + 8),0);\n            free(pcVar22);\n            free(pcVar35);\n            plVar16 \u003d plVar16 + 1;\n            pcVar35 \u003d pcVar30;\n          }\n          save_stab(uStack0000000000000158,(int)sStack000000000000015a,param_13,pcVar30);\n          param_9 \u003d parse_stab(param_10,lVar27,uStack0000000000000158);\n          if (param_9 \u003d\u003d \u0027\\0\u0027) {\n            stab_context();\n            free_saved_stabs();\n            goto LAB_00105981;\n          }\n        }\n      }\n      free_saved_stabs();\n      if ((lVar27 !\u003d 0) \u0026\u0026 (cVar10 \u003d finish_stab(), cVar10 \u003d\u003d \u0027\\0\u0027)) goto LAB_00105981;\n    }\n    if (param_9 \u003d\u003d \u0027\\0\u0027) {\n      if ((*(int *)(unaff_R14[1] + 8) \u003d\u003d 2) \u0026\u0026 (param_8 !\u003d 0)) {\n        param_13 \u003d (char *)0x0;\n        in_stack_000000c0 \u003d plVar6;\n        in_stack_000000d0 \u003d 0;\n        in_stack_000000d8 \u003d 0;\n        puVar31 \u003d (undefined8 *)\u0026stack0x00000148;\n        for (lVar27 \u003d 0x22; lVar27 !\u003d 0; lVar27 \u003d lVar27 + -1) {\n          *(undefined4 *)puVar31 \u003d 0;\n          puVar31 \u003d (undefined8 *)((long)puVar31 + (ulong)bVar42 * -8 + 4);\n        }\n        cVar10 \u003d \u0027\\0\u0027;\n        _uStack0000000000000048 \u003d (int *)0x0;\n        pcStack0000000000000038 \u003d (char *)0x0;\n        pcStack0000000000000090 \u003d (char *)0xffffffffffffffff;\n        in_stack_000000c8 \u003d param_8;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((long)param_8 \u003c\u003d in_stack_000000d0) goto LAB_00105590;\n            lVar27 \u003d plVar6[in_stack_000000d0];\n            cVar9 \u003d bfd_coff_get_syment();\n            lVar17 \u003d in_stack_000000d8;\n            if (cVar9 \u003d\u003d \u0027\\0\u0027) {\n              uVar14 \u003d bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar35 \u003d \"bfd_coff_get_syment failed: %s\";\n              goto LAB_00105968;\n            }\n            pcVar35 \u003d *(char **)(lVar27 + 8);\n            in_stack_000000d0 \u003d in_stack_000000d0 + 1;\n            in_stack_000000d8 \u003d (ulong)bStack0000000000000101 + 1 + in_stack_000000d8;\n            if ((bStack0000000000000101 !\u003d 0) \u0026\u0026 (cVar9 \u003d bfd_coff_get_auxent(), cVar9 \u003d\u003d \u0027\\0\u0027)) {\n              uVar14 \u003d bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar35 \u003d \"bfd_coff_get_auxent failed: %s\";\n              goto LAB_00105968;\n            }\n            if (pcStack0000000000000090 !\u003d (char *)lVar17) break;\n            if (bStack0000000000000100 !\u003d 0x67) {\n              cVar9 \u003d debug_set_filename(param_10);\n              if (cVar9 !\u003d \u0027\\0\u0027) break;\n              goto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            pcStack0000000000000090 \u003d (char *)in_stack_000000f0;\n            cVar9 \u003d debug_set_filename(param_10);\n            if (cVar9 \u003d\u003d \u0027\\0\u0027) goto LAB_00105981;\n          }\n          if ((char)bStack0000000000000100 \u003c \u0027\\0\u0027) {\n            if (bStack0000000000000100 \u003d\u003d 0xff) goto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            lVar24 \u003d parse_coff_type_lto_priv_0();\n            if (lVar24 \u003d\u003d 0) break;\n            cVar9 \u003d parse_coff_symbol_constprop_0_isra_0(\u0026stack0x00000140,lVar27,lVar17);\n          }\n          else {\n            if (bStack0000000000000100 \u003c 100) {\n              switch(bStack0000000000000100) {\n              case 3:\n                if (in_stack_000000f8._6_2_ \u003d\u003d 0) goto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulong)((uint)in_stack_000000f8._6_2_ \u0026 *(uint *)(unaff_R14[0x22] + 0x40)) !\u003d\n                    2L \u003c\u003c ((byte)*(undefined4 *)(unaff_R14[0x22] + 0x3c) \u0026 0x3f)) goto LAB_0010700a;\n                _uStack0000000000000048 \u003d (int *)(**(code **)(unaff_R14[1] + 0x238))();\n                pcStack0000000000000038 \u003d pcVar35;\n                goto switchD_00106e1a_caseD_68;\n              default:\n                goto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                goto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(bStack0000000000000100) {\n            case 100:\n              iVar12 \u003d strcmp(pcVar35,\".bb\");\n              if (iVar12 \u003d\u003d 0) {\n                cVar9 \u003d debug_start_block(param_10);\n              }\n              else {\n                iVar12 \u003d strcmp(pcVar35,\".eb\");\n                if (iVar12 !\u003d 0) goto switchD_00106e1a_caseD_68;\n                cVar9 \u003d debug_end_block(param_10);\n              }\n              break;\n            case 0x65:\n              iVar12 \u003d strcmp(pcVar35,\".bf\");\n              if (iVar12 \u003d\u003d 0) {\n                if (pcStack0000000000000038 !\u003d (char *)0x0) {\n                  lVar17 \u003d parse_coff_type_lto_priv_0();\n                  if ((lVar17 \u003d\u003d 0) || (cVar10 \u003d debug_record_function(param_10), cVar10 \u003d\u003d \u0027\\0\u0027))\n                  goto LAB_00105981;\n                  if (_uStack0000000000000048 !\u003d (int *)0x0) {\n                    iVar12 \u003d 0;\n                    if (bStack0000000000000101 !\u003d 0) {\n                      iVar12 \u003d in_stack_00000118 - 1;\n                    }\n                    lVar27 \u003d *(long *)(*(long *)(lVar27 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar33 \u003d _uStack0000000000000048[4];\n                      if (iVar33 \u003d\u003d 0) break;\n                      cVar9 \u003d debug_record_line(param_10,iVar12 + iVar33,\n                                                *(long *)(_uStack0000000000000048 + 6) + lVar27);\n                      _uStack0000000000000048 \u003d _uStack0000000000000048 + 4;\n                      if (cVar9 \u003d\u003d \u0027\\0\u0027) goto LAB_00105981;\n                    }\n                  }\n                  _uStack0000000000000048 \u003d (int *)0x0;\n                  pcStack0000000000000038 \u003d (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar35 \u003d \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar12 \u003d strcmp(pcVar35,\".ef\");\n                if (iVar12 !\u003d 0) goto switchD_00106e1a_caseD_68;\n                if (cVar10 !\u003d \u0027\\0\u0027) {\n                  cVar10 \u003d debug_end_function(param_10);\n                  if (cVar10 \u003d\u003d \u0027\\0\u0027) goto LAB_00105981;\n                  cVar10 \u003d \u0027\\0\u0027;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar35 \u003d \"%ld: unexpected .ef\\n\";\n              }\n              uVar19 \u003d dcgettext(0,pcVar35,5);\n              non_fatal(uVar19);\n              goto LAB_00105981;\n            default:\n              goto LAB_0010700a;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (cVar9 !\u003d \u0027\\0\u0027);\n      }\n      else {\n        pcVar35 \u003d \"%s: no recognized debugging information\";\nLAB_00105968:\n        uVar19 \u003d dcgettext(0,pcVar35,5);\n        non_fatal(uVar19);\n      }\n      goto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)(param_7 + 0x44) \u0026 0x42) !\u003d 0) \u0026\u0026 ((*(uint *)(param_7 + 0x44) \u0026 1) \u003d\u003d 0)) {\n    if ((*(char *)(*(long *)(param_7 + 8) + 0x20) \u003d\u003d \u0027\\0\u0027) \u0026\u0026 (keep_section_symbols \u003d\u003d \u0027\\0\u0027)) {\n      if (param_8 !\u003d 0) {\n        plVar6 \u003d isympp + param_8;\n        plVar16 \u003d isympp;\n        do {\n          uVar11 \u003d *(uint *)(*plVar16 + 0x18);\n          if ((uVar11 \u0026 0x1000000) !\u003d 0) {\n            *(uint *)(*plVar16 + 0x18) \u003d uVar11 \u0026 0xfeffffff;\n          }\n          plVar16 \u003d plVar16 + 1;\n        } while (plVar6 !\u003d plVar16);\n      }\n    }\n    else {\n      for (lVar27 \u003d *(long *)(param_7 + 0x90); lVar27 !\u003d 0; lVar27 \u003d *(long *)(lVar27 + 8)) {\n        if (*(long *)(lVar27 + 0xe8) !\u003d 0) {\n          puVar1 \u003d (uint *)(*(long *)(lVar27 + 0xe8) + 0x18);\n          *puVar1 \u003d *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((strip_symbols \u003d\u003d 2) || (strip_symbols \u003d\u003d 7)) {\nLAB_001059fe:\n    if (strip_symbols \u003d\u003d 7) {\nLAB_00105a3b:\n      plVar16 \u003d (long *)xmalloc();\n      plVar6 \u003d isympp;\n      uStack0000000000000048 \u003d *(uint *)((long)unaff_R14 + 0x44) \u0026 0x42;\n      osympp \u003d plVar16;\n      if (param_8 \u003d\u003d 0) {\n        uVar28 \u003d 0;\n      }\n      else {\n        uVar28 \u003d 0;\n        _param_9 \u003d 0;\n        do {\n          iVar12 \u003d add_symbols;\n          plVar4 \u003d (long *)plVar6[_param_9];\n          pcVar5 \u003d (code *)plVar4[4];\n          uVar11 \u003d *(uint *)(plVar4 + 3);\n          pcVar35 \u003d (char *)plVar4[1];\n          pcVar30 \u003d pcVar35;\n          if (add_sym_list !\u003d (undefined8 *)0x0) {\n            iVar33 \u003d 0;\n            puVar31 \u003d add_sym_list;\n            while ((iVar33 \u003c iVar12 \u0026\u0026 (pcVar22 \u003d (char *)puVar31[5], pcVar22 !\u003d (char *)0x0))) {\n              if (pcVar22 !\u003d \"\") {\n                iVar15 \u003d strcmp(pcVar22,pcVar35);\n                if (iVar15 \u003d\u003d 0) {\n                  free(pcVar22);\n                  uVar23 \u003d uVar28 + 1;\n                  puVar31[5] \u003d \"\";\n                  lVar27 \u003d create_new_symbol(puVar31);\n                  uVar19 \u003d redefine_specific_htab;\n                  plVar16[uVar28] \u003d lVar27;\n                  lVar27 \u003d htab_elements(uVar19);\n                  if ((lVar27 !\u003d 0) || (section_rename_list !\u003d (char **)0x0)) goto LAB_001064eb;\n                  goto LAB_00105af8;\n                }\n                puVar31 \u003d (undefined8 *)*puVar31;\n              }\n              iVar33 \u003d iVar33 + 1;\n            }\n          }\n          lVar27 \u003d htab_elements(redefine_specific_htab);\n          uVar23 \u003d uVar28;\n          if ((lVar27 !\u003d 0) || (section_rename_list !\u003d (char **)0x0)) {\n            if (pcVar35 !\u003d (char *)0x0) {\nLAB_001064eb:\n              if (((*pcVar35 \u003d\u003d \u0027_\u0027) \u0026\u0026 (pcVar35[1] \u003d\u003d \u0027_\u0027)) \u0026\u0026\n                 (iVar12 \u003d strcmp(pcVar35 + (pcVar35[2] \u003d\u003d \u0027_\u0027),\"__gnu_lto_slim\"), iVar12 \u003d\u003d 0)) {\n                uVar19 \u003d dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\"\n                                   ,5);\n                    \n                fatal(uVar19);\n              }\n            }\n            _cStack0000000000000148 \u003d 0;\n            param_13 \u003d pcVar35;\n            lVar27 \u003d htab_find(redefine_specific_htab);\n            if (((lVar27 \u003d\u003d 0) || (pcVar30 \u003d *(char **)(lVar27 + 8), pcVar35 \u003d\u003d pcVar30)) \u0026\u0026\n               (pcVar30 \u003d pcVar35, ppcVar38 \u003d section_rename_list, (uVar11 \u0026 0x100) !\u003d 0)) {\n              for (; ppcVar38 !\u003d (char **)0x0; ppcVar38 \u003d (char **)ppcVar38[3]) {\n                iVar12 \u003d strcmp(*ppcVar38,pcVar35);\n                if (iVar12 \u003d\u003d 0) {\n                  pcVar30 \u003d ppcVar38[1];\n                  break;\n                }\n              }\n            }\n            plVar4[1] \u003d (long)pcVar30;\n            cVar10 \u003d *pcVar30;\n            if (cVar10 !\u003d \u0027\\0\u0027) goto LAB_00105b11;\nLAB_00106557:\n            pcVar35 \u003d prefix_symbols_string;\n            if ((change_leading_char !\u003d \u0027\\0\u0027) \u0026\u0026 (*(char *)(*(long *)(param_7 + 8) + 0x1c) !\u003d \u0027\\0\u0027))\n            {\n              lVar27 \u003d unaff_R14[1];\n              cVar10 \u003d \u0027\\0\u0027;\n              goto LAB_0010668d;\n            }\n            goto joined_r0x00106565;\n          }\nLAB_00105af8:\n          cVar10 \u003d *pcVar35;\n          if (cVar10 \u003d\u003d \u0027\\0\u0027) goto LAB_00106557;\nLAB_00105b11:\n          pcVar35 \u003d prefix_symbols_string;\n          lVar27 \u003d unaff_R14[1];\n          if (*(char *)(lVar27 + 0x1c) \u003d\u003d cVar10) {\n            if (change_leading_char \u003d\u003d \u0027\\0\u0027) {\n              if ((remove_leading_char \u003d\u003d \u0027\\0\u0027) ||\n                 ((((uVar11 \u0026 0x82) \u003d\u003d 0 \u0026\u0026 (pcVar5 !\u003d bfd_map_over_sections)) \u0026\u0026\n                  ((*(byte *)(plVar4[4] + 0x25) \u0026 0x10) \u003d\u003d 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n              pcVar30 \u003d pcVar30 + 1;\n              plVar4[1] \u003d (long)pcVar30;\n              goto joined_r0x00106565;\n            }\n            cVar10 \u003d *(char *)(*(long *)(param_7 + 8) + 0x1c);\n            if (cVar10 \u003d\u003d \u0027\\0\u0027) goto LAB_0010677d;\n            if (prefix_symbols_string !\u003d (char *)0x0) {\n              pcVar30 \u003d pcVar30 + 1;\n              plVar4[1] \u003d (long)pcVar30;\n              sVar20 \u003d strlen(pcVar30);\n              lVar27 \u003d sVar20 + 2;\nLAB_001066bc:\n              sVar20 \u003d strlen(pcVar35);\n              pcVar35 \u003d (char *)xmalloc(sVar20 + lVar27);\n              goto LAB_001066d0;\n            }\n            *pcVar30 \u003d cVar10;\n            plVar4[1] \u003d (long)pcVar30;\n            uVar28 \u003d uVar23;\n          }\n          else {\n            if ((change_leading_char \u003d\u003d \u0027\\0\u0027) || (*(char *)(*(long *)(param_7 + 8) + 0x1c) \u003d\u003d \u0027\\0\u0027))\n            {\njoined_r0x00106565:\n              uVar28 \u003d uVar23;\n              if (pcVar35 \u003d\u003d (char *)0x0) goto LAB_00105b32;\n              sVar20 \u003d strlen(pcVar30);\n              sVar21 \u003d strlen(pcVar35);\n              pcVar22 \u003d (char *)xmalloc(sVar21 + sVar20 + 1);\n              pcVar35 \u003d pcVar22;\n            }\n            else {\nLAB_0010668d:\n              pcVar35 \u003d prefix_symbols_string;\n              if ((*(char *)(lVar27 + 0x1c) !\u003d \u0027\\0\u0027) \u0026\u0026 (cVar10 !\u003d *(char *)(lVar27 + 0x1c)))\n              goto joined_r0x00106565;\n              sVar20 \u003d strlen(pcVar30);\n              lVar27 \u003d sVar20 + 2;\n              if (pcVar35 !\u003d (char *)0x0) goto LAB_001066bc;\n              pcVar35 \u003d (char *)xmalloc(lVar27);\nLAB_001066d0:\n              pcVar22 \u003d pcVar35 + 1;\n              *pcVar35 \u003d *(char *)(*(long *)(param_7 + 8) + 0x1c);\n            }\n            __s \u003d prefix_symbols_string;\n            if (prefix_symbols_string !\u003d (char *)0x0) {\n              strcpy(pcVar22,prefix_symbols_string);\n              sVar20 \u003d strlen(__s);\n              pcVar22 \u003d pcVar22 + sVar20;\n            }\n            strcpy(pcVar22,pcVar30);\n            plVar4[1] \u003d (long)pcVar35;\n            pcVar30 \u003d pcVar35;\n            uVar28 \u003d uVar23;\n          }\nLAB_00105b32:\n          if (strip_symbols \u003d\u003d 7) goto LAB_001067a8;\n          if (((uVar11 \u0026 0x20) \u003d\u003d 0) \u0026\u0026\n             (((uVar11 \u0026 0x100) \u003d\u003d 0 ||\n              ((*(byte *)(**(long **)(plVar4[4] + 0xf0) + 0x18) \u0026 0x20) \u003d\u003d 0)))) {\n            if (((uStack0000000000000048 \u003d\u003d 0) \u0026\u0026\n                (((uVar11 \u0026 0x82) !\u003d 0 || ((*(byte *)(plVar4[4] + 0x25) \u0026 0x10) !\u003d 0)))) ||\n               (iVar12 \u003d bfd_decode_symclass(plVar4), iVar12 \u003d\u003d 0x49)) {\nLAB_00105be2:\n              if (wildcard \u003d\u003d \u0027\\0\u0027) {\n                lVar27 \u003d htab_find();\n                if (lVar27 \u003d\u003d 0) goto LAB_00105c07;\n              }\n              else {\n                _cStack0000000000000148 \u003d _cStack0000000000000148 \u0026 0xffffffffffffff00;\n                param_13 \u003d pcVar30;\n                htab_traverse(strip_specific_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n                if (cStack0000000000000148 \u003d\u003d \u0027\\0\u0027) goto LAB_00105c07;\n              }\n            }\n            else if ((((uVar11 \u0026 0x82) \u003d\u003d 0) \u0026\u0026 (pcVar5 !\u003d bfd_map_over_sections)) \u0026\u0026\n                    ((*(byte *)(plVar4[4] + 0x25) \u0026 0x10) \u003d\u003d 0)) {\n              if ((uVar11 \u0026 4) \u003d\u003d 0) {\n                if (((*(int *)(unaff_R14[1] + 8) !\u003d 2) ||\n                    (lVar27 \u003d *(long *)(plVar4[4] + 0xd0), lVar27 \u003d\u003d 0)) ||\n                   (*(long *)(lVar27 + 0x40) \u003d\u003d 0)) {\n                  if ((strip_symbols \u003d\u003d 3) || (discard_locals \u003d\u003d 2)) goto LAB_001067a8;\n                  if (discard_locals \u003d\u003d 1) {\n                    cVar10 \u003d bfd_is_local_label(unaff_R14);\n                    goto joined_r0x00106a11;\n                  }\n                }\n                goto LAB_00105be2;\n              }\n              cVar10 \u003d convert_debugging;\n              if (1 \u003c strip_symbols - 2U) {\njoined_r0x00106a11:\n                if (cVar10 \u003d\u003d \u0027\\0\u0027) goto LAB_00105be2;\n              }\n            }\n            else if (strip_symbols !\u003d 3) goto LAB_00105be2;\n            goto LAB_001067a8;\n          }\n          if (wildcard \u003d\u003d \u0027\\0\u0027) {\n            lVar27 \u003d htab_find();\n            if (lVar27 !\u003d 0) {\nLAB_0010687f:\n              uVar19 \u003d dcgettext(0,\"not stripping symbol `%s\\\u0027 because it is named in a relocation\",\n                                 5);\n              non_fatal(uVar19);\n              status \u003d 1;\n            }\n          }\n          else {\n            _cStack0000000000000148 \u003d _cStack0000000000000148 \u0026 0xffffffffffffff00;\n            param_13 \u003d pcVar30;\n            htab_traverse(strip_specific_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n            if (cStack0000000000000148 !\u003d \u0027\\0\u0027) goto LAB_0010687f;\n          }\n          if ((uVar11 \u0026 0x20) \u003d\u003d 0) {\nLAB_00105c07:\n            if (wildcard !\u003d \u0027\\0\u0027) {\n              _cStack0000000000000148 \u003d _cStack0000000000000148 \u0026 0xffffffffffffff00;\n              param_13 \u003d pcVar30;\n              htab_traverse(strip_unneeded_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n              if (cStack0000000000000148 !\u003d \u0027\\0\u0027) goto LAB_001067a8;\n              goto LAB_00105c2c;\n            }\n            lVar27 \u003d htab_find();\n            if (lVar27 \u003d\u003d 0) goto LAB_00105c2c;\nLAB_001067a8:\n            if ((keep_file_symbols !\u003d \u0027\\0\u0027) \u0026\u0026 ((uVar11 \u0026 0x4000) !\u003d 0)) goto LAB_00105c2c;\n            if (wildcard \u003d\u003d \u0027\\0\u0027) {\n              lVar27 \u003d htab_find();\n              if (lVar27 !\u003d 0) goto LAB_00105c2c;\n            }\n            else {\n              _cStack0000000000000148 \u003d _cStack0000000000000148 \u0026 0xffffffffffffff00;\n              param_13 \u003d pcVar30;\n              htab_traverse(keep_specific_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n              if (cStack0000000000000148 !\u003d \u0027\\0\u0027) goto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            cVar10 \u003d is_strip_section_isra_0(plVar4[4]);\n            if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n              if (((uVar11 \u0026 0x800002) \u003d\u003d 0) \u0026\u0026 (pcVar5 !\u003d bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uVar11 \u0026 0x82) !\u003d 0) {\n                  cVar10 \u003d is_specified_symbol(pcVar30);\n                  if ((cVar10 \u003d\u003d \u0027\\0\u0027) \u0026\u0026\n                     ((lVar27 \u003d htab_elements(keepglobal_specific_htab), lVar27 \u003d\u003d 0 ||\n                      (cVar10 \u003d is_specified_symbol(pcVar30), cVar10 !\u003d \u0027\\0\u0027)))) {\n                    if (((((localize_hidden \u003d\u003d \u0027\\0\u0027) ||\n                          (uVar13 \u003d *(uint *)(plVar4 + 3), (uVar13 \u0026 0x200000) !\u003d 0)) ||\n                         (lVar27 \u003d *plVar4, lVar27 \u003d\u003d 0)) ||\n                        ((*(int *)(*(long *)(lVar27 + 8) + 8) !\u003d 5 ||\n                         (*(long *)(lVar27 + 0x110) \u003d\u003d 0)))) ||\n                       (1 \u003c (*(byte *)((long)plVar4 + 0x49) \u0026 3) - 1)) goto joined_r0x00105ca2;\n                  }\n                  else {\n                    uVar13 \u003d *(uint *)(plVar4 + 3);\n                  }\n                  *(uint *)(plVar4 + 3) \u003d uVar13 \u0026 0xffffff7d | 1;\n                }\njoined_r0x00105ca2:\n                if (((uVar11 \u0026 1) !\u003d 0) \u0026\u0026 (cVar10 \u003d is_specified_symbol(pcVar30), cVar10 !\u003d \u0027\\0\u0027))\n                {\n                  *(uint *)(plVar4 + 3) \u003d *(uint *)(plVar4 + 3) \u0026 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((weaken !\u003d \u0027\\0\u0027) || (cVar10 \u003d is_specified_symbol(pcVar30), cVar10 !\u003d \u0027\\0\u0027)) {\n                  *(uint *)(plVar4 + 3) \u003d *(uint *)(plVar4 + 3) \u0026 0xff7ffffd | 0x80;\n                }\n                if (pcVar5 !\u003d bfd_map_over_sections) goto LAB_00105c5f;\n              }\n              plVar16[uVar28] \u003d (long)plVar4;\n              uVar28 \u003d uVar28 + 1;\n            }\n          }\n          _param_9 \u003d _param_9 + 1;\n        } while (param_8 !\u003d _param_9);\n      }\n      if (add_sym_list !\u003d (undefined8 *)0x0) {\n        puVar31 \u003d add_sym_list;\n        iVar12 \u003d add_symbols;\n        for (lVar27 \u003d 0; lVar27 \u003c iVar12; lVar27 \u003d lVar27 + 1) {\n          pcVar35 \u003d (char *)puVar31[5];\n          if (pcVar35 \u003d\u003d (char *)0x0) {\n            plVar6 \u003d plVar16 + uVar28;\n            uVar28 \u003d uVar28 + 1;\n            lVar17 \u003d create_new_symbol(puVar31,param_7);\n            *plVar6 \u003d lVar17;\n            iVar12 \u003d add_symbols;\n          }\n          else if (pcVar35 !\u003d \"\") {\n            uVar19 \u003d dcgettext(0,\"\\\u0027before\u003d%s\\\u0027 not found\",5);\n                    \n            fatal(uVar19,pcVar35);\n          }\n          puVar31 \u003d (undefined8 *)*puVar31;\n        }\n      }\n      bVar41 \u003d convert_debugging \u003d\u003d \u0027\\0\u0027;\n      plVar16[uVar28] \u003d 0;\n      if ((bVar41) || (param_10 \u003d\u003d (undefined4 *)0x0)) {\nLAB_00105cfa:\n        param_8 \u003d uVar28 \u0026 0xffffffff;\n        goto LAB_00105710;\n      }\n      iVar12 \u003d *(int *)(*(undefined8 **)(param_7 + 8) + 1);\n      if ((iVar12 \u003d\u003d 5) || (iVar12 \u003d\u003d 2)) {\n        in_stack_000000e0 \u003d (void *)0x0;\n        cVar10 \u003d write_stabs_in_sections_debugging_info_constprop_0\n                           (param_7,param_10,\u0026stack0x000000c0,\u0026stack0x00000110,\u0026stack0x000000e0,\n                            \u0026stack0x00000140);\n        if (cVar10 !\u003d \u0027\\0\u0027) {\n          lVar27 \u003d bfd_make_section_with_flags(param_7,\".stab\",0x2108);\n          lVar17 \u003d bfd_make_section_with_flags(param_7,\".stabstr\",0x2108);\n          if ((((lVar27 \u003d\u003d 0) || (lVar17 \u003d\u003d 0)) ||\n              (cVar10 \u003d bfd_set_section_size(lVar27,in_stack_00000110), cVar10 \u003d\u003d \u0027\\0\u0027)) ||\n             (cVar10 \u003d bfd_set_section_size(lVar17,param_13), cVar10 \u003d\u003d \u0027\\0\u0027)) {\n            pcVar35 \u003d \"can\\\u0027t create debugging section\";\n          }\n          else {\n            *(undefined4 *)(lVar27 + 0x7c) \u003d 2;\n            *(undefined4 *)(lVar17 + 0x7c) \u003d 0;\n            cVar10 \u003d bfd_set_section_contents(param_7,lVar27,in_stack_000000c0,0,in_stack_00000110);\n            if ((cVar10 !\u003d \u0027\\0\u0027) \u0026\u0026\n               (cVar10 \u003d bfd_set_section_contents(param_7,lVar17,in_stack_000000e0,0,param_13),\n               cVar10 !\u003d \u0027\\0\u0027)) {\n              free(param_10);\n              goto LAB_00105cfa;\n            }\n            pcVar35 \u003d \"can\\\u0027t set debugging section contents\";\n          }\n          uVar19 \u003d dcgettext(0,pcVar35,5);\n          bfd_nonfatal_message(0,param_7,0,uVar19);\n          free(in_stack_000000e0);\n          free(param_10);\n          goto LAB_00105d96;\n        }\n      }\n      else {\n        uVar19 \u003d **(undefined8 **)(param_7 + 8);\n        uVar18 \u003d dcgettext(0,\"don\\\u0027t know how to write debugging information for %s\",5);\n        bfd_nonfatal_message(0,param_7,0,uVar18,uVar19);\n      }\n      free(param_10);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections();\n      iVar12 \u003d bfd_get_error();\n      if (iVar12 \u003d\u003d 0) goto LAB_00105a3b;\n    }\nLAB_00105d96:\n    status \u003d 1;\n  }\n  else {\n    if ((strip_symbols - 3U \u003c 4) || ((discard_locals !\u003d 0 || (localize_hidden !\u003d \u0027\\0\u0027))))\n    goto LAB_00105a07;\n    lVar27 \u003d htab_elements(strip_specific_htab);\n    if (((lVar27 !\u003d 0) ||\n        (((((((lVar27 \u003d htab_elements(keep_specific_htab), lVar27 !\u003d 0 ||\n              (lVar27 \u003d htab_elements(localize_specific_htab), lVar27 !\u003d 0)) ||\n             (lVar27 \u003d htab_elements(globalize_specific_htab), lVar27 !\u003d 0)) ||\n            ((lVar27 \u003d htab_elements(keepglobal_specific_htab), lVar27 !\u003d 0 ||\n             (lVar27 \u003d htab_elements(weaken_specific_htab), lVar27 !\u003d 0)))) ||\n           (lVar27 \u003d htab_elements(redefine_specific_htab), lVar27 !\u003d 0)) ||\n          (((prefix_symbols_string !\u003d (char *)0x0 || (sections_removed !\u003d \u0027\\0\u0027)) ||\n           ((sections_copied !\u003d \u0027\\0\u0027 ||\n            (((convert_debugging !\u003d \u0027\\0\u0027 || (change_leading_char !\u003d \u0027\\0\u0027)) ||\n             (remove_leading_char !\u003d \u0027\\0\u0027)))))))) ||\n         ((section_rename_list !\u003d (char **)0x0 || (weaken !\u003d \u0027\\0\u0027)))))) || (add_symbols !\u003d 0))\n    goto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(param_7,osympp,param_8 \u0026 0xffffffff);\n    bfd_map_over_sections(unaff_R14,copy_relocations_in_section,param_7);\n    bfd_map_over_sections(unaff_R14,copy_section,param_7);\n    for (puVar31 \u003d add_sections; puVar37 \u003d update_sections, puVar31 !\u003d (undefined8 *)0x0;\n        puVar31 \u003d (undefined8 *)*puVar31) {\n      cVar10 \u003d bfd_set_section_contents(param_7,puVar31[5],puVar31[4],0,puVar31[3]);\n      if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n        bfd_nonfatal_message(0,param_7,puVar31[5],0);\n        return 0;\n      }\n    }\n    for (; puVar37 !\u003d (undefined8 *)0x0; puVar37 \u003d (undefined8 *)*puVar37) {\n      uVar19 \u003d *(undefined8 *)(puVar37[5] + 0x60);\n      cVar10 \u003d bfd_set_section_contents(param_7,uVar19,puVar37[4],0,puVar37[3]);\n      if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n        bfd_nonfatal_message(0,param_7,uVar19,0);\n        return 0;\n      }\n    }\n    if (__ptr_01 \u003d\u003d (long **)0x0) {\n      if ((merge_notes !\u003d \u0027\\0\u0027) \u0026\u0026 (is_strip \u003d\u003d 0)) {\n        uVar19 \u003d *unaff_R14;\n        uVar18 \u003d dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n        non_fatal(uVar18,uVar19);\n      }\n    }\n    else {\n      pplVar34 \u003d (long **)0x0;\n      for (puVar31 \u003d *(undefined8 **)(param_7 + 0x90); puVar31 !\u003d (undefined8 *)0x0;\n          puVar31 \u003d (undefined8 *)puVar31[1]) {\n        if (((merge_notes !\u003d \u0027\\0\u0027) \u0026\u0026 (*(int *)(*(long *)(param_7 + 8) + 8) \u003d\u003d 5)) \u0026\u0026\n           ((*(int *)(puVar31[0x1a] + 4) \u003d\u003d 7 \u0026\u0026\n            (cVar10 \u003d startswith_lto_priv_0_lto_priv_0(*puVar31,\".gnu.build.attributes\"),\n            cVar10 !\u003d \u0027\\0\u0027)))) {\n          if (pplVar34 \u003d\u003d (long **)0x0) {\n            pplVar34 \u003d __ptr_01;\n          }\n          pplVar29 \u003d __ptr_01;\n          if ((undefined8 *)(*pplVar34)[0xc] \u003d\u003d puVar31) {\nLAB_0010625f:\n            pcVar35 \u003d \"error: failed to merge notes\";\n            if (pplVar34[1] !\u003d (long *)0x0) {\n              cVar10 \u003d bfd_set_section_contents(param_7,puVar31,pplVar34[1],0,pplVar34[2]);\n              if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n                uVar19 \u003d dcgettext(0,\"error: failed to copy merged notes into output\",5);\n                bfd_nonfatal_message(0,param_7,puVar31,uVar19);\n                return 0;\n              }\n              pplVar34 \u003d (long **)pplVar34[3];\n              goto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              pplVar34 \u003d pplVar29;\n              if ((undefined8 *)(*pplVar29)[0xc] \u003d\u003d puVar31) goto LAB_0010625f;\n              pplVar34 \u003d (long **)pplVar29[3];\n              pplVar29 \u003d pplVar34;\n            } while (pplVar34 !\u003d (long **)0x0);\n            pcVar35 \u003d \"error: failed to locate merged notes\";\n          }\n          uVar19 \u003d dcgettext(0,pcVar35,5);\n          bfd_nonfatal_message(0,param_7,puVar31,uVar19);\n        }\nLAB_001061be:\n      }\n      do {\n        pplVar34 \u003d (long **)__ptr_01[3];\n        free(__ptr_01[1]);\n        free(__ptr_01);\n        __ptr_01 \u003d pplVar34;\n      } while (pplVar34 !\u003d (long **)0x0);\n    }\n    if ((gnu_debuglink_filename \u003d\u003d 0) ||\n       (cVar10 \u003d bfd_fill_in_gnu_debuglink_section(param_7,param_12),\n       lVar27 \u003d gnu_debuglink_filename, cVar10 !\u003d \u0027\\0\u0027)) {\n      uVar11 \u003d (**(code **)(*(long *)(param_7 + 8) + 0x140))(unaff_R14);\n      uVar28 \u003d (ulong)uVar11;\n      if ((char)uVar11 !\u003d \u0027\\0\u0027) {\n        if (use_alt_mach_code \u003d\u003d 0) {\n          return uVar28;\n        }\n        cVar10 \u003d bfd_alt_mach_code(param_7,use_alt_mach_code \u0026 0xffffffff);\n        uVar23 \u003d use_alt_mach_code;\n        if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n          uVar19 \u003d dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n          non_fatal(uVar19,uVar23);\n          if (*(int *)(*(long *)(param_7 + 8) + 8) \u003d\u003d 5) {\n            uVar19 \u003d dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n            non_fatal(uVar19);\n            *(short *)(*(long *)(param_7 + 0x110) + 0x3a) \u003d (short)use_alt_mach_code;\n            return uVar28;\n          }\n          uVar19 \u003d dcgettext(0,\"ignoring the alternative value\",5);\n          non_fatal(uVar19);\n          return uVar28;\n        }\n        return uVar28;\n      }\n      uVar19 \u003d dcgettext(0,\"error copying private BFD data\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar19);\n    }\n    else {\n      uVar19 \u003d dcgettext(0,\"cannot fill debug link section `%s\\\u0027\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar19,lVar27);\n    }\n  }\n  return 0;\nLAB_00115187:\n  if ((((*(int *)(unaff_R14[1] + 8) \u003d\u003d 5) \u0026\u0026 (*(int *)((long)pplVar34[0x1a] + 4) \u003d\u003d 7)) \u0026\u0026\n      (cVar10 \u003d startswith_lto_priv_0_lto_priv_0(*pplVar34), cVar10 !\u003d \u0027\\0\u0027)) \u0026\u0026\n     ((pplVar34[0xc] !\u003d (long *)0x0 \u0026\u0026 (plVar6 \u003d pplVar34[8], plVar6 !\u003d (long *)0x0)))) {\n    pplVar29 \u003d (long **)xmalloc(0x20);\n    pplVar29[1] \u003d (long *)0x0;\n    cVar10 \u003d bfd_get_full_section_contents();\n    if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n      dcgettext(0,\"warning: could not load note section\",5);\n      bfd_nonfatal_message(0);\n      free(pplVar29);\n    }\n    else {\n      plVar16 \u003d (long *)merge_gnu_build_notes();\n      pplVar29[2] \u003d plVar16;\n      if ((plVar16 \u003d\u003d plVar6) || (cVar10 \u003d bfd_set_section_size(pplVar34[0xc]), cVar10 !\u003d \u0027\\0\u0027)) {\n        pplVar29[3] \u003d (long *)__ptr_01;\n        *pplVar29 \u003d (long *)pplVar34;\n        __ptr_01 \u003d pplVar29;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        bfd_nonfatal_message(0,param_7,pplVar34);\n        free(pplVar29[1]);\n        free(pplVar29);\n      }\n    }\n  }\n  pplVar34 \u003d (long **)pplVar34[1];\n  puVar31 \u003d dump_sections;\n  if (pplVar34 \u003d\u003d (long **)0x0) goto joined_r0x001151c7;\n  goto LAB_001151ab;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001152b6"
      ],
      "called": [
        "free",
        "fclose",
        "strerror",
        "bfd_set_section_size",
        "__errno_location",
        "bfd_get_section_by_name",
        "fopen",
        "setup_section",
        "check_new_section_flags",
        "find_section_list",
        "fwrite",
        "bfd_make_section_with_flags",
        "dcgettext",
        "FUN_0010554f",
        "bfd_map_over_sections",
        "merge_gnu_build_notes",
        "xmalloc",
        "non_fatal",
        "bfd_create_gnu_debuglink_section",
        "startswith.lto_priv.0.lto_priv.0",
        "bfd_malloc_and_get_section",
        "FUN_00105828",
        "bfd_set_format",
        "bfd_get_full_section_contents",
        "copy_object.cold",
        "bfd_nonfatal_message",
        "bfd_get_arch"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00107976": {
      "entrypoint": "0x00107976",
      "current_name": "FUN_00107976",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong FUN_00107976(void)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  undefined *puVar3;\n  long *plVar4;\n  code *pcVar5;\n  long *plVar6;\n  ulong uVar7;\n  ulong uVar8;\n  char *__s;\n  char cVar9;\n  char cVar10;\n  uint uVar11;\n  int iVar12;\n  int iVar13;\n  undefined4 uVar14;\n  long *plVar15;\n  long lVar16;\n  undefined8 uVar17;\n  undefined8 uVar18;\n  size_t sVar19;\n  size_t sVar20;\n  char *pcVar21;\n  void *__ptr;\n  void *__ptr_00;\n  ulong uVar22;\n  long lVar23;\n  ulong uVar24;\n  undefined8 *in_RAX;\n  undefined8 uVar25;\n  char *pcVar26;\n  int *piVar27;\n  long lVar28;\n  ulong uVar29;\n  FILE *__s_00;\n  long **pplVar30;\n  uint uVar31;\n  long **__ptr_01;\n  char *pcVar32;\n  undefined8 *puVar33;\n  ulong uVar34;\n  int iVar35;\n  long **pplVar36;\n  long unaff_RBP;\n  undefined4 *puVar37;\n  undefined8 *puVar38;\n  char **ppcVar39;\n  void *pvVar40;\n  undefined8 *unaff_R14;\n  undefined **ppuVar41;\n  bool bVar42;\n  byte bVar43;\n  undefined8 *param_7;\n  ulong param_8;\n  char in_stack_00000018;\n  undefined4 *puStack0000000000000020;\n  char *pcStack0000000000000038;\n  uint uStack0000000000000048;\n  int iStack000000000000006c;\n  long lStack0000000000000078;\n  long lStack0000000000000088;\n  char *pcStack0000000000000090;\n  long lStack00000000000000a0;\n  long *in_stack_000000c0;\n  ulong in_stack_000000c8;\n  long in_stack_000000d0;\n  long in_stack_000000d8;\n  void *in_stack_000000e0;\n  long in_stack_000000f0;\n  undefined8 in_stack_000000f8;\n  byte bStack0000000000000100;\n  byte bStack0000000000000101;\n  undefined8 in_stack_00000110;\n  ushort in_stack_00000118;\n  char *in_stack_00000140;\n  char cStack0000000000000148;\n  char *in_stack_00000150;\n  undefined uStack0000000000000158;\n  short sStack000000000000015a;\n  \n  bVar43 \u003d 0;\n  uVar18 \u003d *in_RAX;\n  uVar17 \u003d *param_7;\n  uVar25 \u003d bfd_get_archive_filename();\n  pcVar26 \u003d (char *)dcgettext(0,\"copy from `%s\\\u0027 [%s] to `%s\\\u0027 [%s]\\n\",5);\n  printf(pcVar26,uVar25,uVar18,uVar17);\n  if ((*(byte *)(param_7 + 9) \u0026 7) \u003d\u003d 3) {\n    iVar13 \u003d bfd_get_arch();\n    uVar14 \u003d bfd_get_mach();\n    if (unaff_RBP !\u003d 0) {\n      uVar29 \u003d FUN_001152b6();\n      return uVar29;\n    }\n    goto LAB_00114f9a;\n  }\n  uVar31 \u003d ~bfd_flags_to_clear \u0026 *(uint *)(param_7[1] + 0x14) \u0026\n           (bfd_flags_to_set | *(uint *)((long)unaff_R14 + 0x44));\n  if (strip_symbols \u003d\u003d 7) {\n    uVar31 \u003d uVar31 \u0026 0xfffffffe;\n    cVar10 \u003d bfd_set_start_address(param_7);\n  }\n  else {\n    cVar10 \u003d bfd_set_start_address(param_7);\n  }\n  if ((cVar10 \u003d\u003d \u0027\\0\u0027) || (cVar10 \u003d bfd_set_file_flags(param_7,uVar31), cVar10 \u003d\u003d \u0027\\0\u0027))\n  goto LAB_00107a82;\n  iVar13 \u003d bfd_get_arch();\n  uVar14 \u003d bfd_get_mach();\n  if (unaff_RBP \u003d\u003d 0) {\nLAB_00114f9a:\n    if (((iVar13 \u003d\u003d 0) \u0026\u0026 (*(int *)(unaff_R14[1] + 8) !\u003d 5)) \u0026\u0026 (*(int *)(param_7[1] + 8) \u003d\u003d 5)) {\n      uVar29 \u003d FUN_00107880();\n      return uVar29;\n    }\n  }\n  else {\n    if (iVar13 \u003d\u003d 0) {\n      iVar13 \u003d *(int *)(unaff_RBP + 0xc);\n      uVar14 \u003d *(undefined4 *)(unaff_RBP + 0x10);\n      goto LAB_00114f9a;\n    }\n    uVar18 \u003d bfd_get_archive_filename();\n    uVar17 \u003d dcgettext(0,\"Input file `%s\\\u0027 ignores binary architecture parameter.\",5);\n    non_fatal(uVar17,uVar18);\n  }\n  cVar10 \u003d (**(code **)(param_7[1] + 0x2a0))(param_7,iVar13,uVar14);\n  if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n    if ((*(byte *)(unaff_R14 + 9) \u0026 0x40) !\u003d 0) {\n      iVar13 \u003d bfd_get_arch();\n      if (iVar13 \u003d\u003d 0) {\n        uVar18 \u003d bfd_get_archive_filename();\n        uVar17 \u003d dcgettext(0,\"Unable to recognise the format of the input file `%s\\\u0027\",5);\n        non_fatal(uVar17,uVar18);\n        return 0;\n      }\n      uVar18 \u003d bfd_get_mach();\n      uVar14 \u003d bfd_get_arch();\n      uVar18 \u003d bfd_printable_arch_mach(uVar14,uVar18);\n      uVar17 \u003d dcgettext(0,\"Output file cannot represent architecture `%s\\\u0027\",5);\n      non_fatal(uVar17,uVar18);\n      return 0;\n    }\n    iVar13 \u003d bfd_get_arch();\n    iVar35 \u003d bfd_get_arch(param_7);\n    if (iVar13 !\u003d iVar35) {\n      uVar29 \u003d FUN_00105828();\n      return uVar29;\n    }\n  }\n  cVar10 \u003d bfd_set_format(param_7,*(byte *)(unaff_R14 + 9) \u0026 7);\n  if (cVar10 \u003d\u003d \u0027\\0\u0027) {\nLAB_00107a82:\n    bfd_nonfatal_message(0);\n    return 0;\n  }\n  if ((*(int *)((undefined8 *)param_7[1] + 1) \u003d\u003d 2) \u0026\u0026\n     (cVar10 \u003d startswith_lto_priv_0_lto_priv_0(*(undefined8 *)param_7[1],\u0026DAT_0011b503),\n     cVar10 !\u003d \u0027\\0\u0027)) {\n    lVar28 \u003d param_7[0x22];\n    if ((*(int *)((undefined8 *)unaff_R14[1] + 1) \u003d\u003d 2) \u0026\u0026\n       (cVar10 \u003d startswith_lto_priv_0_lto_priv_0(*(undefined8 *)unaff_R14[1],\u0026DAT_0011b503),\n       cVar10 !\u003d \u0027\\0\u0027)) {\n      lVar16 \u003d unaff_R14[0x22];\n      bVar42 \u003d preserve_dates \u003d\u003d \u0027\\0\u0027;\n      puVar33 \u003d (undefined8 *)(lVar16 + 200);\n      puVar38 \u003d (undefined8 *)(lVar28 + 200);\n      for (lVar23 \u003d 0x32; lVar23 !\u003d 0; lVar23 \u003d lVar23 + -1) {\n        *puVar38 \u003d *puVar33;\n        puVar33 \u003d puVar33 + (ulong)bVar43 * -2 + 1;\n        puVar38 \u003d puVar38 + (ulong)bVar43 * -2 + 1;\n      }\n      if (bVar42) {\n        *(undefined4 *)(lVar28 + 0x2a4) \u003d 0xffffffff;\n      }\n      else {\n        *(int *)(lVar28 + 0x2a4) \u003d (int)*(undefined8 *)(lVar16 + 0xa8);\n      }\n    }\n    uVar29 \u003d pe_file_alignment;\n    if (pe_file_alignment \u003d\u003d 0xffffffffffffffff) {\n      pe_file_alignment \u003d 0x200;\n      uVar29 \u003d 0x200;\n    }\n    else {\n      *(int *)(lVar28 + 0x10c) \u003d (int)pe_file_alignment;\n    }\n    if (pe_heap_commit !\u003d -1) {\n      *(long *)(lVar28 + 0x148) \u003d pe_heap_commit;\n    }\n    if (pe_heap_reserve !\u003d -1) {\n      *(long *)(lVar28 + 0x148) \u003d pe_heap_reserve;\n    }\n    if (pe_image_base !\u003d -1) {\n      *(long *)(lVar28 + 0x100) \u003d pe_image_base;\n    }\n    uVar22 \u003d pe_section_alignment;\n    if (pe_section_alignment \u003d\u003d 0xffffffffffffffff) {\n      pe_section_alignment \u003d 0x1000;\n      uVar22 \u003d 0x1000;\n    }\n    else {\n      *(int *)(lVar28 + 0x108) \u003d (int)pe_section_alignment;\n    }\n    if (pe_stack_commit !\u003d -1) {\n      *(long *)(lVar28 + 0x138) \u003d pe_stack_commit;\n    }\n    if (pe_stack_reserve !\u003d -1) {\n      *(long *)(lVar28 + 0x138) \u003d pe_stack_reserve;\n    }\n    if (pe_subsystem !\u003d -1) {\n      *(short *)(lVar28 + 300) \u003d pe_subsystem;\n    }\n    if (pe_major_subsystem_version !\u003d -1) {\n      *(short *)(lVar28 + 0x118) \u003d pe_major_subsystem_version;\n    }\n    if (pe_minor_subsystem_version !\u003d -1) {\n      *(short *)(lVar28 + 0x11a) \u003d pe_minor_subsystem_version;\n    }\n    if (uVar22 \u003c uVar29) {\n      uVar18 \u003d dcgettext(0,\"warning: file alignment (0x%lx) \u003e section alignment (0x%lx)\",5);\n      non_fatal(uVar18,uVar29,uVar22);\n    }\n  }\n  plVar6 \u003d isympp;\n  free(isympp);\n  if (plVar6 \u003d\u003d osympp) {\n    isympp \u003d (long *)0x0;\n    osympp \u003d (long *)0x0;\n    lVar28 \u003d (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  else {\n    free(osympp);\n    isympp \u003d (long *)0x0;\n    osympp \u003d (long *)0x0;\n    lVar28 \u003d (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  if (lVar28 \u003c 0) goto LAB_00107a82;\n  osympp \u003d (long *)xmalloc();\n  isympp \u003d osympp;\n  param_8 \u003d (**(code **)(unaff_R14[1] + 0x200))();\n  if ((long)param_8 \u003c 0) goto LAB_00107a82;\n  if (param_8 \u003d\u003d 0) {\n    free(isympp);\n    isympp \u003d (long *)0x0;\n    osympp \u003d (long *)0x0;\n  }\n  bfd_map_over_sections();\n  puVar33 \u003d add_sections;\n  if ((extract_symbol \u003d\u003d \u0027\\0\u0027) \u0026\u0026\n     (cVar10 \u003d (**(code **)(param_7[1] + 0x168))(), puVar33 \u003d add_sections, cVar10 \u003d\u003d \u0027\\0\u0027)) {\n    status \u003d 1;\n    dcgettext(0,\"error in private header data\",5);\n    bfd_nonfatal_message(0);\n    puVar33 \u003d add_sections;\n  }\n  for (; puVar38 \u003d update_sections, puVar33 !\u003d (undefined8 *)0x0; puVar33 \u003d (undefined8 *)*puVar33)\n  {\n    uVar31 \u003d 0x128;\n    lVar28 \u003d find_section_list(puVar33[1],0,0x80);\n    if (lVar28 !\u003d 0) {\n      uVar31 \u003d check_new_section_flags(*(uint *)(lVar28 + 0x28) | 0x100,param_7,puVar33[1]);\n    }\n    lVar28 \u003d bfd_get_section_by_name(param_7,puVar33[1]);\n    if (lVar28 !\u003d 0) {\n      uVar18 \u003d puVar33[1];\n      uVar17 \u003d dcgettext(0,\"can\\\u0027t add section \\\u0027%s\\\u0027\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar17,uVar18);\n      return 0;\n    }\n    lVar28 \u003d bfd_make_section_with_flags(param_7,puVar33[1],uVar31 | 0x100000);\n    puVar33[5] \u003d lVar28;\n    if (lVar28 \u003d\u003d 0) {\n      uVar18 \u003d puVar33[1];\n      uVar17 \u003d dcgettext(0,\"can\\\u0027t create section `%s\\\u0027\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar17,uVar18);\n      return 0;\n    }\n    cVar10 \u003d bfd_set_section_size();\n    if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n      bfd_nonfatal_message(0,param_7,puVar33[5],0);\n      return 0;\n    }\n    lVar28 \u003d find_section_list(puVar33[1],0,0x18);\n    if (lVar28 !\u003d 0) {\n      uVar18 \u003d *(undefined8 *)(lVar28 + 0x18);\n      lVar28 \u003d puVar33[5];\n      *(byte *)(lVar28 + 0x28) \u003d *(byte *)(lVar28 + 0x28) | 1;\n      *(undefined8 *)(lVar28 + 0x30) \u003d uVar18;\n      *(undefined8 *)(lVar28 + 0x38) \u003d uVar18;\n    }\n    lVar28 \u003d find_section_list(puVar33[1],0,0x60);\n    if (lVar28 !\u003d 0) {\n      lVar16 \u003d puVar33[5];\n      *(undefined8 *)(lVar16 + 0x38) \u003d *(undefined8 *)(lVar28 + 0x20);\n      if (0x3e \u003c *(uint *)(lVar16 + 0x7c)) {\n        bfd_nonfatal_message(0,param_7,lVar16,0);\n        return 0;\n      }\n    }\n  }\n  for (; puVar38 !\u003d (undefined8 *)0x0; puVar38 \u003d (undefined8 *)*puVar38) {\n    lVar28 \u003d bfd_get_section_by_name();\n    puVar38[5] \u003d lVar28;\n    if (lVar28 \u003d\u003d 0) {\n      uVar18 \u003d puVar38[1];\n      uVar17 \u003d dcgettext(0,\"error: %s not found, can\\\u0027t be updated\",5);\n      non_fatal(uVar17,uVar18);\n      return 0;\n    }\n    uVar18 \u003d *(undefined8 *)(lVar28 + 0x60);\n    cVar10 \u003d bfd_set_section_size(uVar18);\n    if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n      bfd_nonfatal_message(0,param_7,uVar18,0);\n      return 0;\n    }\n  }\n  puVar33 \u003d dump_sections;\n  if (merge_notes \u003d\u003d \u0027\\0\u0027) {\n    __ptr_01 \u003d (long **)0x0;\n  }\n  else {\n    pplVar36 \u003d (long **)unaff_R14[0x12];\n    __ptr_01 \u003d pplVar36;\n    if (pplVar36 !\u003d (long **)0x0) {\n      __ptr_01 \u003d (long **)0x0;\nLAB_001151ab:\n      if (merge_notes !\u003d \u0027\\0\u0027) goto LAB_00115187;\n      for (plVar6 \u003d pplVar36[1]; puVar33 \u003d dump_sections, plVar6 !\u003d (long *)0x0;\n          plVar6 \u003d (long *)plVar6[1]) {\n      }\n    }\n  }\njoined_r0x001151c7:\n  for (; puVar33 !\u003d (undefined8 *)0x0; puVar33 \u003d (undefined8 *)*puVar33) {\n    lVar28 \u003d bfd_get_section_by_name();\n    if (lVar28 \u003d\u003d 0) {\n      dcgettext(0,\"can\\\u0027t dump section \\\u0027%s\\\u0027 - it does not exist\",5);\n      bfd_nonfatal_message(0);\n    }\n    else if ((*(byte *)(lVar28 + 0x25) \u0026 1) \u003d\u003d 0) {\n      dcgettext(0,\"can\\\u0027t dump section - it has no contents\",5);\n      bfd_nonfatal_message(0);\n    }\n    else {\n      sVar19 \u003d *(size_t *)(lVar28 + 0x40);\n      __s_00 \u003d fopen((char *)puVar33[2],\"w\");\n      if (__s_00 \u003d\u003d (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        bfd_nonfatal_message(puVar33[2],0,0);\n      }\n      else {\n        cVar10 \u003d bfd_malloc_and_get_section();\n        if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          bfd_nonfatal_message(0);\n        }\n        else if ((sVar19 !\u003d 0) \u0026\u0026\n                (sVar20 \u003d fwrite(in_stack_00000140,1,sVar19,__s_00), sVar20 !\u003d sVar19)) {\n          piVar27 \u003d __errno_location();\n          pcVar26 \u003d strerror(*piVar27);\n          uVar18 \u003d puVar33[2];\n          uVar17 \u003d dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          non_fatal(uVar17,uVar18,pcVar26);\n          free(in_stack_00000140);\n          fclose(__s_00);\n          return 0;\n        }\n        fclose(__s_00);\n        free(in_stack_00000140);\n      }\n    }\n  }\n  if (gnu_debuglink_filename \u003d\u003d 0) {\nLAB_0010790a:\n    lStack0000000000000078 \u003d 0;\n  }\n  else {\n    lVar28 \u003d bfd_get_section_by_name(param_7,\".gnu_debuglink\");\n    if (lVar28 !\u003d 0) {\n      uVar18 \u003d dcgettext(0,\"%s: debuglink section already exists\",5);\n      non_fatal(uVar18);\n      gnu_debuglink_filename \u003d 0;\n      goto LAB_0010790a;\n    }\n    lStack0000000000000078 \u003d bfd_create_gnu_debuglink_section(param_7);\n    lVar28 \u003d gnu_debuglink_filename;\n    if (lStack0000000000000078 \u003d\u003d 0) {\n      uVar18 \u003d dcgettext(0,\"cannot create debug link section `%s\\\u0027\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar18,lVar28);\n      return 0;\n    }\n    if (*(int *)(param_7[1] + 8) \u003d\u003d 2) {\n      uVar22 \u003d 0;\n      for (uVar29 \u003d param_7[0x12]; uVar29 !\u003d 0; uVar29 \u003d *(ulong *)(uVar29 + 8)) {\n        uVar24 \u003d *(ulong *)(uVar29 + 0x30);\n        uVar34 \u003d uVar22;\n        uVar7 \u003d uVar29;\n        uVar8 \u003d uVar22;\n        if (uVar24 !\u003d 0) {\n          while ((uVar34 \u003d uVar7, uVar8 !\u003d 0 \u0026\u0026\n                 (uVar34 \u003d uVar29, uVar24 \u003c\u003d *(ulong *)(uVar22 + 0x30)))) {\n            uVar29 \u003d *(ulong *)(uVar29 + 8);\n            if (uVar29 \u003d\u003d 0) goto LAB_00107db8;\n            uVar24 \u003d *(ulong *)(uVar29 + 0x30);\n            uVar7 \u003d uVar22;\n            uVar8 \u003d uVar24;\n          }\n        }\n        uVar22 \u003d uVar34;\n      }\nLAB_00107db8:\n      if (uVar22 \u003d\u003d 0) {\n        uVar29 \u003d 0x1000;\n      }\n      else {\n        uVar22 \u003d *(long *)(uVar22 + 0x40) + *(long *)(uVar22 + 0x30);\n        uVar29 \u003d 0xffffffffffffffff;\n        if (uVar22 \u003c 0xfffffffffffff001) {\n          uVar29 \u003d uVar22 + 0xfff \u0026 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(lStack0000000000000078 + 0x28) \u003d *(byte *)(lStack0000000000000078 + 0x28) | 1;\n      *(ulong *)(lStack0000000000000078 + 0x30) \u003d uVar29;\n      *(ulong *)(lStack0000000000000078 + 0x38) \u003d uVar29;\n    }\n  }\n  plVar6 \u003d isympp;\n  iStack000000000000006c \u003d *(int *)(param_7 + 0x14);\n  if (iStack000000000000006c !\u003d 0) {\n    uVar29 \u003d FUN_0010554f();\n    return uVar29;\n  }\n  if (convert_debugging \u003d\u003d \u0027\\0\u0027) {\nLAB_00105588:\n    puStack0000000000000020 \u003d (undefined4 *)0x0;\n  }\n  else {\n    ppuVar41 \u003d \u0026names_0;\n    puStack0000000000000020 \u003d (undefined4 *)xmalloc(0x60);\n    puVar37 \u003d puStack0000000000000020;\n    for (lVar28 \u003d 0x18; lVar28 !\u003d 0; lVar28 \u003d lVar28 + -1) {\n      *puVar37 \u003d 0;\n      puVar37 \u003d puVar37 + (ulong)bVar43 * -2 + 1;\n    }\n    pcStack0000000000000038 \u003d (char *)0x0;\n    do {\n      puVar3 \u003d *ppuVar41;\n      lVar28 \u003d bfd_get_section_by_name();\n      lVar16 \u003d bfd_get_section_by_name();\n      if ((lVar28 !\u003d 0) \u0026\u0026 (lVar16 !\u003d 0)) {\n        lVar28 \u003d *(long *)(lVar28 + 0x40);\n        __ptr \u003d (void *)xmalloc(lVar28);\n        cVar10 \u003d bfd_get_section_contents();\n        if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n          uVar14 \u003d bfd_get_error();\n          bfd_errmsg(uVar14);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n          free(pcStack0000000000000038);\n          free(__ptr);\n        }\n        else {\n          uVar29 \u003d *(ulong *)(lVar16 + 0x40);\n          __ptr_00 \u003d (void *)xmalloc(uVar29 + 1);\n          in_stack_00000018 \u003d bfd_get_section_contents();\n          if (in_stack_00000018 \u003d\u003d \u0027\\0\u0027) {\n            uVar14 \u003d bfd_get_error();\n            bfd_errmsg(uVar14);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n            free(pcStack0000000000000038);\n          }\n          else {\n            *(undefined *)((long)__ptr_00 + uVar29) \u003d 0;\n            if ((pcStack0000000000000038 !\u003d (char *)0x0) ||\n               (pcStack0000000000000038 \u003d (char *)start_stab_constprop_0(),\n               pcStack0000000000000038 !\u003d (char *)0x0)) {\n              lStack00000000000000a0 \u003d 0;\n              lStack0000000000000088 \u003d 0;\n              for (pvVar40 \u003d __ptr; pvVar40 \u003c\u003d (void *)((long)__ptr + lVar28 + -0xc);\n                  pvVar40 \u003d (void *)((long)pvVar40 + 0xc)) {\n                uVar22 \u003d (**(code **)(unaff_R14[1] + 0x40))(pvVar40);\n                bVar2 \u003d *(byte *)((long)pvVar40 + 4);\n                uVar14 \u003d (**(code **)(unaff_R14[1] + 0x58))((long)pvVar40 + 6);\n                lVar16 \u003d (**(code **)(unaff_R14[1] + 0x40))((long)pvVar40 + 8);\n                if (bVar2 \u003d\u003d 0) {\n                  lStack0000000000000088 \u003d lStack00000000000000a0;\n                  lStack00000000000000a0 \u003d lStack00000000000000a0 + lVar16;\n                }\n                else {\n                  uVar24 \u003d (uVar22 \u0026 0xffffffff) + lStack0000000000000088;\n                  if (uVar24 \u003c uVar29) {\n                    pcVar26 \u003d (char *)((long)__ptr_00 + uVar24);\n                    pcStack0000000000000090 \u003d (char *)0x0;\n                    while( true ) {\n                      sVar19 \u003d strlen(pcVar26);\n                      if (((sVar19 \u003d\u003d 0) || (pcVar32 \u003d pcVar26 + (sVar19 - 1), *pcVar32 !\u003d \u0027\\\\\u0027)) ||\n                         ((ulong)((long)__ptr + lVar28) \u003c (long)pvVar40 + 0x10U)) goto LAB_001077fb;\n                      *pcVar32 \u003d \u0027\\0\u0027;\n                      pvVar40 \u003d (void *)((long)pvVar40 + 0xc);\n                      iVar13 \u003d (**(code **)(unaff_R14[1] + 0x40))(pvVar40);\n                      uVar22 \u003d (ulong)(uint)(iVar13 + (int)lStack0000000000000088);\n                      if (uVar29 \u003c\u003d uVar22) break;\n                      pcVar26 \u003d (char *)concat(pcVar26,(long)__ptr_00 + uVar22,0);\n                      *pcVar32 \u003d \u0027\\\\\u0027;\n                      free(pcStack0000000000000090);\n                      pcStack0000000000000090 \u003d pcVar26;\n                    }\n                    uVar18 \u003d *unaff_R14;\n                    pcVar32 \u003d (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar32,uVar18,puVar3,((long)pvVar40 - (long)__ptr) / 0xc);\nLAB_001077fb:\n                    save_stab((ulong)bVar2,uVar14,lVar16,pcVar26);\n                    cVar10 \u003d parse_stab(puStack0000000000000020,pcStack0000000000000038,bVar2);\n                    if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n                      stab_context();\n                      free_saved_stabs();\n                      free(pcStack0000000000000090);\n                      free(pcStack0000000000000038);\n                      free(__ptr);\n                      free(__ptr_00);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar18 \u003d *unaff_R14;\n                    pcVar26 \u003d (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx \u003d 0x%x, type \u003d %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar26,uVar18,puVar3,((long)pvVar40 - (long)__ptr) / 0xc,\n                            uVar22 \u0026 0xffffffff,(ulong)bVar2,((long)pvVar40 - (long)__ptr) % 0xc);\n                  }\n                }\n              }\n              free_saved_stabs();\n              free(__ptr);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_00);\n          free(__ptr);\n        }\n        goto LAB_00105981;\n      }\nLAB_001058eb:\n      ppuVar41 \u003d ppuVar41 + 2;\n    } while (ppuVar41 !\u003d (undefined **)\u0026DAT_00125c90);\n    if ((pcStack0000000000000038 !\u003d (char *)0x0) \u0026\u0026 (cVar10 \u003d finish_stab(), cVar10 \u003d\u003d \u0027\\0\u0027)) {\nLAB_00105981:\n      free(puStack0000000000000020);\n      goto LAB_00105588;\n    }\n    if (*(int *)(unaff_R14[1] + 8) \u003d\u003d 1) {\n      lVar28 \u003d 0;\n      for (plVar15 \u003d plVar6; plVar15 \u003c plVar6 + param_8; plVar15 \u003d plVar15 + 1) {\n        (**(code **)(unaff_R14[1] + 0x218))();\n        if (cStack0000000000000148 \u003d\u003d \u0027-\u0027) {\n          if (((lVar28 \u003d\u003d 0) \u0026\u0026 (lVar28 \u003d start_stab_constprop_0(), lVar28 \u003d\u003d 0)) ||\n             ((in_stack_00000150 \u003d\u003d (char *)0x0 || (*in_stack_00000150 \u003d\u003d \u0027\\0\u0027))))\n          goto LAB_00105981;\n          pcVar26 \u003d (char *)0x0;\n          pcVar32 \u003d in_stack_00000150;\n          while (((*pcVar32 !\u003d \u0027\\0\u0027 \u0026\u0026 (sVar19 \u003d strlen(pcVar32), pcVar32[sVar19 - 1] \u003d\u003d \u0027\\\\\u0027)) \u0026\u0026\n                 (plVar15 + 1 \u003c plVar6 + param_8))) {\n            pcVar21 \u003d (char *)xstrdup(pcVar32);\n            sVar19 \u003d strlen(pcVar21);\n            pcVar21[sVar19 - 1] \u003d \u0027\\0\u0027;\n            pcVar32 \u003d (char *)concat(pcVar21,*(undefined8 *)(plVar15[1] + 8),0);\n            free(pcVar21);\n            free(pcVar26);\n            plVar15 \u003d plVar15 + 1;\n            pcVar26 \u003d pcVar32;\n          }\n          save_stab(uStack0000000000000158,(int)sStack000000000000015a,in_stack_00000140,pcVar32);\n          in_stack_00000018 \u003d parse_stab(puStack0000000000000020,lVar28,uStack0000000000000158);\n          if (in_stack_00000018 \u003d\u003d \u0027\\0\u0027) {\n            stab_context();\n            free_saved_stabs();\n            goto LAB_00105981;\n          }\n        }\n      }\n      free_saved_stabs();\n      if ((lVar28 !\u003d 0) \u0026\u0026 (cVar10 \u003d finish_stab(), cVar10 \u003d\u003d \u0027\\0\u0027)) goto LAB_00105981;\n    }\n    if (in_stack_00000018 \u003d\u003d \u0027\\0\u0027) {\n      if ((*(int *)(unaff_R14[1] + 8) \u003d\u003d 2) \u0026\u0026 (param_8 !\u003d 0)) {\n        in_stack_00000140 \u003d (char *)0x0;\n        in_stack_000000c0 \u003d plVar6;\n        in_stack_000000d0 \u003d 0;\n        in_stack_000000d8 \u003d 0;\n        puVar33 \u003d (undefined8 *)\u0026stack0x00000148;\n        for (lVar28 \u003d 0x22; lVar28 !\u003d 0; lVar28 \u003d lVar28 + -1) {\n          *(undefined4 *)puVar33 \u003d 0;\n          puVar33 \u003d (undefined8 *)((long)puVar33 + (ulong)bVar43 * -8 + 4);\n        }\n        cVar10 \u003d \u0027\\0\u0027;\n        _uStack0000000000000048 \u003d (int *)0x0;\n        pcStack0000000000000038 \u003d (char *)0x0;\n        pcStack0000000000000090 \u003d (char *)0xffffffffffffffff;\n        in_stack_000000c8 \u003d param_8;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((long)param_8 \u003c\u003d in_stack_000000d0) goto LAB_00105590;\n            lVar28 \u003d plVar6[in_stack_000000d0];\n            cVar9 \u003d bfd_coff_get_syment();\n            lVar16 \u003d in_stack_000000d8;\n            if (cVar9 \u003d\u003d \u0027\\0\u0027) {\n              uVar14 \u003d bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar26 \u003d \"bfd_coff_get_syment failed: %s\";\n              goto LAB_00105968;\n            }\n            pcVar26 \u003d *(char **)(lVar28 + 8);\n            in_stack_000000d0 \u003d in_stack_000000d0 + 1;\n            in_stack_000000d8 \u003d (ulong)bStack0000000000000101 + 1 + in_stack_000000d8;\n            if ((bStack0000000000000101 !\u003d 0) \u0026\u0026 (cVar9 \u003d bfd_coff_get_auxent(), cVar9 \u003d\u003d \u0027\\0\u0027)) {\n              uVar14 \u003d bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar26 \u003d \"bfd_coff_get_auxent failed: %s\";\n              goto LAB_00105968;\n            }\n            if (pcStack0000000000000090 !\u003d (char *)lVar16) break;\n            if (bStack0000000000000100 !\u003d 0x67) {\n              cVar9 \u003d debug_set_filename(puStack0000000000000020);\n              if (cVar9 !\u003d \u0027\\0\u0027) break;\n              goto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            pcStack0000000000000090 \u003d (char *)in_stack_000000f0;\n            cVar9 \u003d debug_set_filename(puStack0000000000000020);\n            if (cVar9 \u003d\u003d \u0027\\0\u0027) goto LAB_00105981;\n          }\n          if ((char)bStack0000000000000100 \u003c \u0027\\0\u0027) {\n            if (bStack0000000000000100 \u003d\u003d 0xff) goto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            lVar23 \u003d parse_coff_type_lto_priv_0();\n            if (lVar23 \u003d\u003d 0) break;\n            cVar9 \u003d parse_coff_symbol_constprop_0_isra_0(\u0026stack0x00000140,lVar28,lVar16);\n          }\n          else {\n            if (bStack0000000000000100 \u003c 100) {\n              switch(bStack0000000000000100) {\n              case 3:\n                if (in_stack_000000f8._6_2_ \u003d\u003d 0) goto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulong)((uint)in_stack_000000f8._6_2_ \u0026 *(uint *)(unaff_R14[0x22] + 0x40)) !\u003d\n                    2L \u003c\u003c ((byte)*(undefined4 *)(unaff_R14[0x22] + 0x3c) \u0026 0x3f)) goto LAB_0010700a;\n                _uStack0000000000000048 \u003d (int *)(**(code **)(unaff_R14[1] + 0x238))();\n                pcStack0000000000000038 \u003d pcVar26;\n                goto switchD_00106e1a_caseD_68;\n              default:\n                goto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                goto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(bStack0000000000000100) {\n            case 100:\n              iVar13 \u003d strcmp(pcVar26,\".bb\");\n              if (iVar13 \u003d\u003d 0) {\n                cVar9 \u003d debug_start_block(puStack0000000000000020);\n              }\n              else {\n                iVar13 \u003d strcmp(pcVar26,\".eb\");\n                if (iVar13 !\u003d 0) goto switchD_00106e1a_caseD_68;\n                cVar9 \u003d debug_end_block(puStack0000000000000020);\n              }\n              break;\n            case 0x65:\n              iVar13 \u003d strcmp(pcVar26,\".bf\");\n              if (iVar13 \u003d\u003d 0) {\n                if (pcStack0000000000000038 !\u003d (char *)0x0) {\n                  lVar16 \u003d parse_coff_type_lto_priv_0();\n                  if ((lVar16 \u003d\u003d 0) ||\n                     (cVar10 \u003d debug_record_function(puStack0000000000000020), cVar10 \u003d\u003d \u0027\\0\u0027))\n                  goto LAB_00105981;\n                  if (_uStack0000000000000048 !\u003d (int *)0x0) {\n                    iVar13 \u003d 0;\n                    if (bStack0000000000000101 !\u003d 0) {\n                      iVar13 \u003d in_stack_00000118 - 1;\n                    }\n                    lVar28 \u003d *(long *)(*(long *)(lVar28 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar35 \u003d _uStack0000000000000048[4];\n                      if (iVar35 \u003d\u003d 0) break;\n                      cVar9 \u003d debug_record_line(puStack0000000000000020,iVar13 + iVar35,\n                                                *(long *)(_uStack0000000000000048 + 6) + lVar28);\n                      _uStack0000000000000048 \u003d _uStack0000000000000048 + 4;\n                      if (cVar9 \u003d\u003d \u0027\\0\u0027) goto LAB_00105981;\n                    }\n                  }\n                  _uStack0000000000000048 \u003d (int *)0x0;\n                  pcStack0000000000000038 \u003d (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar26 \u003d \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar13 \u003d strcmp(pcVar26,\".ef\");\n                if (iVar13 !\u003d 0) goto switchD_00106e1a_caseD_68;\n                if (cVar10 !\u003d \u0027\\0\u0027) {\n                  cVar10 \u003d debug_end_function(puStack0000000000000020);\n                  if (cVar10 \u003d\u003d \u0027\\0\u0027) goto LAB_00105981;\n                  cVar10 \u003d \u0027\\0\u0027;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar26 \u003d \"%ld: unexpected .ef\\n\";\n              }\n              uVar18 \u003d dcgettext(0,pcVar26,5);\n              non_fatal(uVar18);\n              goto LAB_00105981;\n            default:\n              goto LAB_0010700a;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (cVar9 !\u003d \u0027\\0\u0027);\n      }\n      else {\n        pcVar26 \u003d \"%s: no recognized debugging information\";\nLAB_00105968:\n        uVar18 \u003d dcgettext(0,pcVar26,5);\n        non_fatal(uVar18);\n      }\n      goto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)((long)param_7 + 0x44) \u0026 0x42) !\u003d 0) \u0026\u0026\n     ((*(uint *)((long)param_7 + 0x44) \u0026 1) \u003d\u003d 0)) {\n    if ((*(char *)(param_7[1] + 0x20) \u003d\u003d \u0027\\0\u0027) \u0026\u0026 (keep_section_symbols \u003d\u003d \u0027\\0\u0027)) {\n      if (param_8 !\u003d 0) {\n        plVar6 \u003d isympp + param_8;\n        plVar15 \u003d isympp;\n        do {\n          uVar31 \u003d *(uint *)(*plVar15 + 0x18);\n          if ((uVar31 \u0026 0x1000000) !\u003d 0) {\n            *(uint *)(*plVar15 + 0x18) \u003d uVar31 \u0026 0xfeffffff;\n          }\n          plVar15 \u003d plVar15 + 1;\n        } while (plVar6 !\u003d plVar15);\n      }\n    }\n    else {\n      for (lVar28 \u003d param_7[0x12]; lVar28 !\u003d 0; lVar28 \u003d *(long *)(lVar28 + 8)) {\n        if (*(long *)(lVar28 + 0xe8) !\u003d 0) {\n          puVar1 \u003d (uint *)(*(long *)(lVar28 + 0xe8) + 0x18);\n          *puVar1 \u003d *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((strip_symbols \u003d\u003d 2) || (strip_symbols \u003d\u003d 7)) {\nLAB_001059fe:\n    if (strip_symbols \u003d\u003d 7) {\nLAB_00105a3b:\n      plVar15 \u003d (long *)xmalloc();\n      plVar6 \u003d isympp;\n      uStack0000000000000048 \u003d *(uint *)((long)unaff_R14 + 0x44) \u0026 0x42;\n      osympp \u003d plVar15;\n      if (param_8 \u003d\u003d 0) {\n        uVar29 \u003d 0;\n      }\n      else {\n        uVar29 \u003d 0;\n        _in_stack_00000018 \u003d 0;\n        do {\n          iVar13 \u003d add_symbols;\n          plVar4 \u003d (long *)plVar6[_in_stack_00000018];\n          pcVar5 \u003d (code *)plVar4[4];\n          uVar31 \u003d *(uint *)(plVar4 + 3);\n          pcVar26 \u003d (char *)plVar4[1];\n          pcVar32 \u003d pcVar26;\n          if (add_sym_list !\u003d (undefined8 *)0x0) {\n            iVar35 \u003d 0;\n            puVar33 \u003d add_sym_list;\n            while ((iVar35 \u003c iVar13 \u0026\u0026 (pcVar21 \u003d (char *)puVar33[5], pcVar21 !\u003d (char *)0x0))) {\n              if (pcVar21 !\u003d \"\") {\n                iVar12 \u003d strcmp(pcVar21,pcVar26);\n                if (iVar12 \u003d\u003d 0) {\n                  free(pcVar21);\n                  uVar22 \u003d uVar29 + 1;\n                  puVar33[5] \u003d \"\";\n                  lVar28 \u003d create_new_symbol(puVar33);\n                  uVar18 \u003d redefine_specific_htab;\n                  plVar15[uVar29] \u003d lVar28;\n                  lVar28 \u003d htab_elements(uVar18);\n                  if ((lVar28 !\u003d 0) || (section_rename_list !\u003d (char **)0x0)) goto LAB_001064eb;\n                  goto LAB_00105af8;\n                }\n                puVar33 \u003d (undefined8 *)*puVar33;\n              }\n              iVar35 \u003d iVar35 + 1;\n            }\n          }\n          lVar28 \u003d htab_elements(redefine_specific_htab);\n          uVar22 \u003d uVar29;\n          if ((lVar28 \u003d\u003d 0) \u0026\u0026 (section_rename_list \u003d\u003d (char **)0x0)) {\nLAB_00105af8:\n            cVar10 \u003d *pcVar26;\n            if (cVar10 !\u003d \u0027\\0\u0027) goto LAB_00105b11;\nLAB_00106557:\n            pcVar26 \u003d prefix_symbols_string;\n            if ((change_leading_char !\u003d \u0027\\0\u0027) \u0026\u0026 (*(char *)(param_7[1] + 0x1c) !\u003d \u0027\\0\u0027)) {\n              lVar28 \u003d unaff_R14[1];\n              cVar10 \u003d \u0027\\0\u0027;\n              goto LAB_0010668d;\n            }\n            goto joined_r0x00106565;\n          }\n          if (pcVar26 !\u003d (char *)0x0) {\nLAB_001064eb:\n            if (((*pcVar26 \u003d\u003d \u0027_\u0027) \u0026\u0026 (pcVar26[1] \u003d\u003d \u0027_\u0027)) \u0026\u0026\n               (iVar13 \u003d strcmp(pcVar26 + (pcVar26[2] \u003d\u003d \u0027_\u0027),\"__gnu_lto_slim\"), iVar13 \u003d\u003d 0)) {\n              uVar18 \u003d dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\",5\n                                );\n                    \n              fatal(uVar18);\n            }\n          }\n          _cStack0000000000000148 \u003d 0;\n          in_stack_00000140 \u003d pcVar26;\n          lVar28 \u003d htab_find(redefine_specific_htab);\n          if (((lVar28 \u003d\u003d 0) || (pcVar32 \u003d *(char **)(lVar28 + 8), pcVar26 \u003d\u003d pcVar32)) \u0026\u0026\n             (pcVar32 \u003d pcVar26, ppcVar39 \u003d section_rename_list, (uVar31 \u0026 0x100) !\u003d 0)) {\n            for (; ppcVar39 !\u003d (char **)0x0; ppcVar39 \u003d (char **)ppcVar39[3]) {\n              iVar13 \u003d strcmp(*ppcVar39,pcVar26);\n              if (iVar13 \u003d\u003d 0) {\n                pcVar32 \u003d ppcVar39[1];\n                break;\n              }\n            }\n          }\n          plVar4[1] \u003d (long)pcVar32;\n          cVar10 \u003d *pcVar32;\n          if (cVar10 \u003d\u003d \u0027\\0\u0027) goto LAB_00106557;\nLAB_00105b11:\n          pcVar26 \u003d prefix_symbols_string;\n          lVar28 \u003d unaff_R14[1];\n          if (*(char *)(lVar28 + 0x1c) \u003d\u003d cVar10) {\n            if (change_leading_char \u003d\u003d \u0027\\0\u0027) {\n              if ((remove_leading_char \u003d\u003d \u0027\\0\u0027) ||\n                 ((((uVar31 \u0026 0x82) \u003d\u003d 0 \u0026\u0026 (pcVar5 !\u003d bfd_map_over_sections)) \u0026\u0026\n                  ((*(byte *)(plVar4[4] + 0x25) \u0026 0x10) \u003d\u003d 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n              pcVar32 \u003d pcVar32 + 1;\n              plVar4[1] \u003d (long)pcVar32;\n              goto joined_r0x00106565;\n            }\n            if (*(char *)(param_7[1] + 0x1c) \u003d\u003d \u0027\\0\u0027) goto LAB_0010677d;\n            if (prefix_symbols_string !\u003d (char *)0x0) {\n              pcVar32 \u003d pcVar32 + 1;\n              plVar4[1] \u003d (long)pcVar32;\n              sVar19 \u003d strlen(pcVar32);\n              lVar28 \u003d sVar19 + 2;\nLAB_001066bc:\n              sVar19 \u003d strlen(pcVar26);\n              pcVar26 \u003d (char *)xmalloc(sVar19 + lVar28);\n              goto LAB_001066d0;\n            }\n            *pcVar32 \u003d *(char *)(param_7[1] + 0x1c);\n            plVar4[1] \u003d (long)pcVar32;\n            uVar29 \u003d uVar22;\n          }\n          else {\n            if ((change_leading_char \u003d\u003d \u0027\\0\u0027) || (*(char *)(param_7[1] + 0x1c) \u003d\u003d \u0027\\0\u0027)) {\njoined_r0x00106565:\n              uVar29 \u003d uVar22;\n              if (pcVar26 \u003d\u003d (char *)0x0) goto LAB_00105b32;\n              sVar19 \u003d strlen(pcVar32);\n              sVar20 \u003d strlen(pcVar26);\n              pcVar21 \u003d (char *)xmalloc(sVar20 + sVar19 + 1);\n              pcVar26 \u003d pcVar21;\n            }\n            else {\nLAB_0010668d:\n              pcVar26 \u003d prefix_symbols_string;\n              if ((*(char *)(lVar28 + 0x1c) !\u003d \u0027\\0\u0027) \u0026\u0026 (cVar10 !\u003d *(char *)(lVar28 + 0x1c)))\n              goto joined_r0x00106565;\n              sVar19 \u003d strlen(pcVar32);\n              lVar28 \u003d sVar19 + 2;\n              if (pcVar26 !\u003d (char *)0x0) goto LAB_001066bc;\n              pcVar26 \u003d (char *)xmalloc(lVar28);\nLAB_001066d0:\n              pcVar21 \u003d pcVar26 + 1;\n              *pcVar26 \u003d *(char *)(param_7[1] + 0x1c);\n            }\n            __s \u003d prefix_symbols_string;\n            if (prefix_symbols_string !\u003d (char *)0x0) {\n              strcpy(pcVar21,prefix_symbols_string);\n              sVar19 \u003d strlen(__s);\n              pcVar21 \u003d pcVar21 + sVar19;\n            }\n            strcpy(pcVar21,pcVar32);\n            plVar4[1] \u003d (long)pcVar26;\n            pcVar32 \u003d pcVar26;\n            uVar29 \u003d uVar22;\n          }\nLAB_00105b32:\n          if (strip_symbols \u003d\u003d 7) goto LAB_001067a8;\n          if (((uVar31 \u0026 0x20) \u003d\u003d 0) \u0026\u0026\n             (((uVar31 \u0026 0x100) \u003d\u003d 0 ||\n              ((*(byte *)(**(long **)(plVar4[4] + 0xf0) + 0x18) \u0026 0x20) \u003d\u003d 0)))) {\n            if (((uStack0000000000000048 \u003d\u003d 0) \u0026\u0026\n                (((uVar31 \u0026 0x82) !\u003d 0 || ((*(byte *)(plVar4[4] + 0x25) \u0026 0x10) !\u003d 0)))) ||\n               (iVar13 \u003d bfd_decode_symclass(plVar4), iVar13 \u003d\u003d 0x49)) {\nLAB_00105be2:\n              if (wildcard \u003d\u003d \u0027\\0\u0027) {\n                lVar28 \u003d htab_find();\n                if (lVar28 \u003d\u003d 0) goto LAB_00105c07;\n              }\n              else {\n                _cStack0000000000000148 \u003d _cStack0000000000000148 \u0026 0xffffffffffffff00;\n                in_stack_00000140 \u003d pcVar32;\n                htab_traverse(strip_specific_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n                if (cStack0000000000000148 \u003d\u003d \u0027\\0\u0027) goto LAB_00105c07;\n              }\n            }\n            else if ((((uVar31 \u0026 0x82) \u003d\u003d 0) \u0026\u0026 (pcVar5 !\u003d bfd_map_over_sections)) \u0026\u0026\n                    ((*(byte *)(plVar4[4] + 0x25) \u0026 0x10) \u003d\u003d 0)) {\n              if ((uVar31 \u0026 4) \u003d\u003d 0) {\n                if (((*(int *)(unaff_R14[1] + 8) !\u003d 2) ||\n                    (lVar28 \u003d *(long *)(plVar4[4] + 0xd0), lVar28 \u003d\u003d 0)) ||\n                   (*(long *)(lVar28 + 0x40) \u003d\u003d 0)) {\n                  if ((strip_symbols \u003d\u003d 3) || (discard_locals \u003d\u003d 2)) goto LAB_001067a8;\n                  if (discard_locals \u003d\u003d 1) {\n                    cVar10 \u003d bfd_is_local_label(unaff_R14);\n                    goto joined_r0x00106a11;\n                  }\n                }\n                goto LAB_00105be2;\n              }\n              cVar10 \u003d convert_debugging;\n              if (1 \u003c strip_symbols - 2U) {\njoined_r0x00106a11:\n                if (cVar10 \u003d\u003d \u0027\\0\u0027) goto LAB_00105be2;\n              }\n            }\n            else if (strip_symbols !\u003d 3) goto LAB_00105be2;\n            goto LAB_001067a8;\n          }\n          if (wildcard \u003d\u003d \u0027\\0\u0027) {\n            lVar28 \u003d htab_find();\n            if (lVar28 !\u003d 0) {\nLAB_0010687f:\n              uVar18 \u003d dcgettext(0,\"not stripping symbol `%s\\\u0027 because it is named in a relocation\",\n                                 5);\n              non_fatal(uVar18);\n              status \u003d 1;\n            }\n          }\n          else {\n            _cStack0000000000000148 \u003d _cStack0000000000000148 \u0026 0xffffffffffffff00;\n            in_stack_00000140 \u003d pcVar32;\n            htab_traverse(strip_specific_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n            if (cStack0000000000000148 !\u003d \u0027\\0\u0027) goto LAB_0010687f;\n          }\n          if ((uVar31 \u0026 0x20) \u003d\u003d 0) {\nLAB_00105c07:\n            if (wildcard !\u003d \u0027\\0\u0027) {\n              _cStack0000000000000148 \u003d _cStack0000000000000148 \u0026 0xffffffffffffff00;\n              in_stack_00000140 \u003d pcVar32;\n              htab_traverse(strip_unneeded_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n              if (cStack0000000000000148 !\u003d \u0027\\0\u0027) goto LAB_001067a8;\n              goto LAB_00105c2c;\n            }\n            lVar28 \u003d htab_find();\n            if (lVar28 \u003d\u003d 0) goto LAB_00105c2c;\nLAB_001067a8:\n            if ((keep_file_symbols !\u003d \u0027\\0\u0027) \u0026\u0026 ((uVar31 \u0026 0x4000) !\u003d 0)) goto LAB_00105c2c;\n            if (wildcard \u003d\u003d \u0027\\0\u0027) {\n              lVar28 \u003d htab_find();\n              if (lVar28 !\u003d 0) goto LAB_00105c2c;\n            }\n            else {\n              _cStack0000000000000148 \u003d _cStack0000000000000148 \u0026 0xffffffffffffff00;\n              in_stack_00000140 \u003d pcVar32;\n              htab_traverse(keep_specific_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n              if (cStack0000000000000148 !\u003d \u0027\\0\u0027) goto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            cVar10 \u003d is_strip_section_isra_0(plVar4[4]);\n            if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n              if (((uVar31 \u0026 0x800002) \u003d\u003d 0) \u0026\u0026 (pcVar5 !\u003d bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uVar31 \u0026 0x82) !\u003d 0) {\n                  cVar10 \u003d is_specified_symbol(pcVar32);\n                  if ((cVar10 \u003d\u003d \u0027\\0\u0027) \u0026\u0026\n                     ((lVar28 \u003d htab_elements(keepglobal_specific_htab), lVar28 \u003d\u003d 0 ||\n                      (cVar10 \u003d is_specified_symbol(pcVar32), cVar10 !\u003d \u0027\\0\u0027)))) {\n                    if (((((localize_hidden \u003d\u003d \u0027\\0\u0027) ||\n                          (uVar11 \u003d *(uint *)(plVar4 + 3), (uVar11 \u0026 0x200000) !\u003d 0)) ||\n                         (lVar28 \u003d *plVar4, lVar28 \u003d\u003d 0)) ||\n                        ((*(int *)(*(long *)(lVar28 + 8) + 8) !\u003d 5 ||\n                         (*(long *)(lVar28 + 0x110) \u003d\u003d 0)))) ||\n                       (1 \u003c (*(byte *)((long)plVar4 + 0x49) \u0026 3) - 1)) goto joined_r0x00105ca2;\n                  }\n                  else {\n                    uVar11 \u003d *(uint *)(plVar4 + 3);\n                  }\n                  *(uint *)(plVar4 + 3) \u003d uVar11 \u0026 0xffffff7d | 1;\n                }\njoined_r0x00105ca2:\n                if (((uVar31 \u0026 1) !\u003d 0) \u0026\u0026 (cVar10 \u003d is_specified_symbol(pcVar32), cVar10 !\u003d \u0027\\0\u0027))\n                {\n                  *(uint *)(plVar4 + 3) \u003d *(uint *)(plVar4 + 3) \u0026 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((weaken !\u003d \u0027\\0\u0027) || (cVar10 \u003d is_specified_symbol(pcVar32), cVar10 !\u003d \u0027\\0\u0027)) {\n                  *(uint *)(plVar4 + 3) \u003d *(uint *)(plVar4 + 3) \u0026 0xff7ffffd | 0x80;\n                }\n                if (pcVar5 !\u003d bfd_map_over_sections) goto LAB_00105c5f;\n              }\n              plVar15[uVar29] \u003d (long)plVar4;\n              uVar29 \u003d uVar29 + 1;\n            }\n          }\n          _in_stack_00000018 \u003d _in_stack_00000018 + 1;\n        } while (param_8 !\u003d _in_stack_00000018);\n      }\n      if (add_sym_list !\u003d (undefined8 *)0x0) {\n        puVar33 \u003d add_sym_list;\n        iVar13 \u003d add_symbols;\n        for (lVar28 \u003d 0; lVar28 \u003c iVar13; lVar28 \u003d lVar28 + 1) {\n          pcVar26 \u003d (char *)puVar33[5];\n          if (pcVar26 \u003d\u003d (char *)0x0) {\n            plVar6 \u003d plVar15 + uVar29;\n            uVar29 \u003d uVar29 + 1;\n            lVar16 \u003d create_new_symbol(puVar33,param_7);\n            *plVar6 \u003d lVar16;\n            iVar13 \u003d add_symbols;\n          }\n          else if (pcVar26 !\u003d \"\") {\n            uVar18 \u003d dcgettext(0,\"\\\u0027before\u003d%s\\\u0027 not found\",5);\n                    \n            fatal(uVar18,pcVar26);\n          }\n          puVar33 \u003d (undefined8 *)*puVar33;\n        }\n      }\n      bVar42 \u003d convert_debugging \u003d\u003d \u0027\\0\u0027;\n      plVar15[uVar29] \u003d 0;\n      if ((bVar42) || (puStack0000000000000020 \u003d\u003d (undefined4 *)0x0)) {\nLAB_00105cfa:\n        param_8 \u003d uVar29 \u0026 0xffffffff;\n        goto LAB_00105710;\n      }\n      iVar13 \u003d *(int *)((undefined8 *)param_7[1] + 1);\n      if ((iVar13 \u003d\u003d 5) || (iVar13 \u003d\u003d 2)) {\n        in_stack_000000e0 \u003d (void *)0x0;\n        cVar10 \u003d write_stabs_in_sections_debugging_info_constprop_0\n                           (param_7,puStack0000000000000020,\u0026stack0x000000c0,\u0026stack0x00000110,\n                            \u0026stack0x000000e0,\u0026stack0x00000140);\n        if (cVar10 !\u003d \u0027\\0\u0027) {\n          lVar28 \u003d bfd_make_section_with_flags(param_7,\".stab\",0x2108);\n          lVar16 \u003d bfd_make_section_with_flags(param_7,\".stabstr\",0x2108);\n          if ((((lVar28 \u003d\u003d 0) || (lVar16 \u003d\u003d 0)) ||\n              (cVar10 \u003d bfd_set_section_size(lVar28,in_stack_00000110), cVar10 \u003d\u003d \u0027\\0\u0027)) ||\n             (cVar10 \u003d bfd_set_section_size(lVar16,in_stack_00000140), cVar10 \u003d\u003d \u0027\\0\u0027)) {\n            pcVar26 \u003d \"can\\\u0027t create debugging section\";\n          }\n          else {\n            *(undefined4 *)(lVar28 + 0x7c) \u003d 2;\n            *(undefined4 *)(lVar16 + 0x7c) \u003d 0;\n            cVar10 \u003d bfd_set_section_contents(param_7,lVar28,in_stack_000000c0,0,in_stack_00000110);\n            if ((cVar10 !\u003d \u0027\\0\u0027) \u0026\u0026\n               (cVar10 \u003d bfd_set_section_contents\n                                   (param_7,lVar16,in_stack_000000e0,0,in_stack_00000140),\n               cVar10 !\u003d \u0027\\0\u0027)) {\n              free(puStack0000000000000020);\n              goto LAB_00105cfa;\n            }\n            pcVar26 \u003d \"can\\\u0027t set debugging section contents\";\n          }\n          uVar18 \u003d dcgettext(0,pcVar26,5);\n          bfd_nonfatal_message(0,param_7,0,uVar18);\n          free(in_stack_000000e0);\n          free(puStack0000000000000020);\n          goto LAB_00105d96;\n        }\n      }\n      else {\n        uVar18 \u003d *(undefined8 *)param_7[1];\n        uVar17 \u003d dcgettext(0,\"don\\\u0027t know how to write debugging information for %s\",5);\n        bfd_nonfatal_message(0,param_7,0,uVar17,uVar18);\n      }\n      free(puStack0000000000000020);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections();\n      iVar13 \u003d bfd_get_error();\n      if (iVar13 \u003d\u003d 0) goto LAB_00105a3b;\n    }\nLAB_00105d96:\n    status \u003d 1;\n  }\n  else {\n    if ((strip_symbols - 3U \u003c 4) || ((discard_locals !\u003d 0 || (localize_hidden !\u003d \u0027\\0\u0027))))\n    goto LAB_00105a07;\n    lVar28 \u003d htab_elements(strip_specific_htab);\n    if (((lVar28 !\u003d 0) ||\n        (((((((lVar28 \u003d htab_elements(keep_specific_htab), lVar28 !\u003d 0 ||\n              (lVar28 \u003d htab_elements(localize_specific_htab), lVar28 !\u003d 0)) ||\n             (lVar28 \u003d htab_elements(globalize_specific_htab), lVar28 !\u003d 0)) ||\n            ((lVar28 \u003d htab_elements(keepglobal_specific_htab), lVar28 !\u003d 0 ||\n             (lVar28 \u003d htab_elements(weaken_specific_htab), lVar28 !\u003d 0)))) ||\n           (lVar28 \u003d htab_elements(redefine_specific_htab), lVar28 !\u003d 0)) ||\n          (((prefix_symbols_string !\u003d (char *)0x0 || (sections_removed !\u003d \u0027\\0\u0027)) ||\n           ((sections_copied !\u003d \u0027\\0\u0027 ||\n            (((convert_debugging !\u003d \u0027\\0\u0027 || (change_leading_char !\u003d \u0027\\0\u0027)) ||\n             (remove_leading_char !\u003d \u0027\\0\u0027)))))))) ||\n         ((section_rename_list !\u003d (char **)0x0 || (weaken !\u003d \u0027\\0\u0027)))))) || (add_symbols !\u003d 0))\n    goto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(param_7,osympp,param_8 \u0026 0xffffffff);\n    bfd_map_over_sections(unaff_R14,copy_relocations_in_section,param_7);\n    bfd_map_over_sections(unaff_R14,copy_section,param_7);\n    for (puVar33 \u003d add_sections; puVar38 \u003d update_sections, puVar33 !\u003d (undefined8 *)0x0;\n        puVar33 \u003d (undefined8 *)*puVar33) {\n      cVar10 \u003d bfd_set_section_contents(param_7,puVar33[5],puVar33[4],0,puVar33[3]);\n      if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n        bfd_nonfatal_message(0,param_7,puVar33[5],0);\n        return 0;\n      }\n    }\n    for (; puVar38 !\u003d (undefined8 *)0x0; puVar38 \u003d (undefined8 *)*puVar38) {\n      uVar18 \u003d *(undefined8 *)(puVar38[5] + 0x60);\n      cVar10 \u003d bfd_set_section_contents(param_7,uVar18,puVar38[4],0,puVar38[3]);\n      if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n        bfd_nonfatal_message(0,param_7,uVar18,0);\n        return 0;\n      }\n    }\n    if (__ptr_01 \u003d\u003d (long **)0x0) {\n      if ((merge_notes !\u003d \u0027\\0\u0027) \u0026\u0026 (is_strip \u003d\u003d 0)) {\n        uVar18 \u003d *unaff_R14;\n        uVar17 \u003d dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n        non_fatal(uVar17,uVar18);\n      }\n    }\n    else {\n      pplVar36 \u003d (long **)0x0;\n      for (puVar33 \u003d (undefined8 *)param_7[0x12]; puVar33 !\u003d (undefined8 *)0x0;\n          puVar33 \u003d (undefined8 *)puVar33[1]) {\n        if (((merge_notes !\u003d \u0027\\0\u0027) \u0026\u0026 (*(int *)(param_7[1] + 8) \u003d\u003d 5)) \u0026\u0026\n           ((*(int *)(puVar33[0x1a] + 4) \u003d\u003d 7 \u0026\u0026\n            (cVar10 \u003d startswith_lto_priv_0_lto_priv_0(*puVar33,\".gnu.build.attributes\"),\n            cVar10 !\u003d \u0027\\0\u0027)))) {\n          if (pplVar36 \u003d\u003d (long **)0x0) {\n            pplVar36 \u003d __ptr_01;\n          }\n          pplVar30 \u003d __ptr_01;\n          if ((undefined8 *)(*pplVar36)[0xc] \u003d\u003d puVar33) {\nLAB_0010625f:\n            pcVar26 \u003d \"error: failed to merge notes\";\n            if (pplVar36[1] !\u003d (long *)0x0) {\n              cVar10 \u003d bfd_set_section_contents(param_7,puVar33,pplVar36[1],0,pplVar36[2]);\n              if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n                uVar18 \u003d dcgettext(0,\"error: failed to copy merged notes into output\",5);\n                bfd_nonfatal_message(0,param_7,puVar33,uVar18);\n                return 0;\n              }\n              pplVar36 \u003d (long **)pplVar36[3];\n              goto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              pplVar36 \u003d pplVar30;\n              if ((undefined8 *)(*pplVar30)[0xc] \u003d\u003d puVar33) goto LAB_0010625f;\n              pplVar36 \u003d (long **)pplVar30[3];\n              pplVar30 \u003d pplVar36;\n            } while (pplVar36 !\u003d (long **)0x0);\n            pcVar26 \u003d \"error: failed to locate merged notes\";\n          }\n          uVar18 \u003d dcgettext(0,pcVar26,5);\n          bfd_nonfatal_message(0,param_7,puVar33,uVar18);\n        }\nLAB_001061be:\n      }\n      do {\n        pplVar36 \u003d (long **)__ptr_01[3];\n        free(__ptr_01[1]);\n        free(__ptr_01);\n        __ptr_01 \u003d pplVar36;\n      } while (pplVar36 !\u003d (long **)0x0);\n    }\n    if ((gnu_debuglink_filename \u003d\u003d 0) ||\n       (cVar10 \u003d bfd_fill_in_gnu_debuglink_section(param_7,lStack0000000000000078),\n       lVar28 \u003d gnu_debuglink_filename, cVar10 !\u003d \u0027\\0\u0027)) {\n      uVar31 \u003d (**(code **)(param_7[1] + 0x140))(unaff_R14);\n      uVar29 \u003d (ulong)uVar31;\n      if ((char)uVar31 !\u003d \u0027\\0\u0027) {\n        if (use_alt_mach_code \u003d\u003d 0) {\n          return uVar29;\n        }\n        cVar10 \u003d bfd_alt_mach_code(param_7,use_alt_mach_code \u0026 0xffffffff);\n        uVar22 \u003d use_alt_mach_code;\n        if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n          uVar18 \u003d dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n          non_fatal(uVar18,uVar22);\n          if (*(int *)(param_7[1] + 8) \u003d\u003d 5) {\n            uVar18 \u003d dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n            non_fatal(uVar18);\n            *(short *)(param_7[0x22] + 0x3a) \u003d (short)use_alt_mach_code;\n            return uVar29;\n          }\n          uVar18 \u003d dcgettext(0,\"ignoring the alternative value\",5);\n          non_fatal(uVar18);\n          return uVar29;\n        }\n        return uVar29;\n      }\n      uVar18 \u003d dcgettext(0,\"error copying private BFD data\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar18);\n    }\n    else {\n      uVar18 \u003d dcgettext(0,\"cannot fill debug link section `%s\\\u0027\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar18,lVar28);\n    }\n  }\n  return 0;\nLAB_00115187:\n  if ((((*(int *)(unaff_R14[1] + 8) \u003d\u003d 5) \u0026\u0026 (*(int *)((long)pplVar36[0x1a] + 4) \u003d\u003d 7)) \u0026\u0026\n      (cVar10 \u003d startswith_lto_priv_0_lto_priv_0(*pplVar36), cVar10 !\u003d \u0027\\0\u0027)) \u0026\u0026\n     ((pplVar36[0xc] !\u003d (long *)0x0 \u0026\u0026 (plVar6 \u003d pplVar36[8], plVar6 !\u003d (long *)0x0)))) {\n    pplVar30 \u003d (long **)xmalloc(0x20);\n    pplVar30[1] \u003d (long *)0x0;\n    cVar10 \u003d bfd_get_full_section_contents();\n    if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n      dcgettext(0,\"warning: could not load note section\",5);\n      bfd_nonfatal_message(0);\n      free(pplVar30);\n    }\n    else {\n      plVar15 \u003d (long *)merge_gnu_build_notes();\n      pplVar30[2] \u003d plVar15;\n      if ((plVar15 \u003d\u003d plVar6) || (cVar10 \u003d bfd_set_section_size(pplVar36[0xc]), cVar10 !\u003d \u0027\\0\u0027)) {\n        pplVar30[3] \u003d (long *)__ptr_01;\n        *pplVar30 \u003d (long *)pplVar36;\n        __ptr_01 \u003d pplVar30;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        bfd_nonfatal_message(0,param_7,pplVar36);\n        free(pplVar30[1]);\n        free(pplVar30);\n      }\n    }\n  }\n  pplVar36 \u003d (long **)pplVar36[1];\n  puVar33 \u003d dump_sections;\n  if (pplVar36 \u003d\u003d (long **)0x0) goto joined_r0x001151c7;\n  goto LAB_001151ab;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_object"
      ],
      "called": [
        "bfd_get_mach",
        "bfd_set_file_flags",
        "printf",
        "dcgettext",
        "bfd_set_start_address",
        "bfd_get_archive_filename",
        "bfd_get_arch",
        "FUN_001152b6"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setup_section.cold": {
      "entrypoint": "0x00108072",
      "current_name": "setup_section.cold",
      "code": "\nvoid setup_section_cold(void)\n\n{\n  byte bVar1;\n  undefined8 uVar2;\n  char cVar3;\n  uint uVar4;\n  long lVar5;\n  long lVar6;\n  long lVar7;\n  undefined8 *unaff_RBX;\n  long unaff_RBP;\n  long unaff_R12;\n  long lVar8;\n  char unaff_R14B;\n  long unaff_R15;\n  \n  lVar5 \u003d dcgettext(0,\"failed to set size\",5);\n  lVar8 \u003d unaff_RBX[6];\n  lVar6 \u003d find_section_list(*unaff_RBX,0,0x18);\n  if (lVar6 \u003d\u003d 0) {\n    *(byte *)(unaff_R15 + 0x28) \u003d *(byte *)(unaff_R15 + 0x28) | 1;\n    uVar2 \u003d *unaff_RBX;\n    lVar8 \u003d lVar8 + change_section_address;\n    *(long *)(unaff_R15 + 0x30) \u003d lVar8;\n    *(long *)(unaff_R15 + 0x38) \u003d lVar8;\n    lVar8 \u003d unaff_RBX[7];\n    lVar6 \u003d find_section_list(uVar2,0,0x60);\n    if (lVar6 \u003d\u003d 0) goto LAB_00115695;\nLAB_00115860:\n    lVar7 \u003d *(long *)(lVar6 + 0x20);\n    if ((*(byte *)(lVar6 + 0x14) \u0026 0x40) !\u003d 0) {\n      lVar7 \u003d lVar7 + lVar8;\n    }\n    *(long *)(unaff_R15 + 0x38) \u003d lVar7;\n    lVar8 \u003d find_section_list(*unaff_RBX,0,0x200);\n    if (lVar8 !\u003d 0) goto LAB_00115889;\nLAB_001156b8:\n    uVar4 \u003d *(uint *)((long)unaff_RBX + 0x7c);\n    if (uVar4 \u003c 0x3f) goto LAB_001156c4;\n    lVar5 \u003d dcgettext(0,\"failed to set alignment\",5);\n    *(undefined4 *)(unaff_R15 + 0xb4) \u003d *(undefined4 *)((long)unaff_RBX + 0xb4);\n    *(byte *)(unaff_R15 + 0x28) \u003d\n         *(byte *)(unaff_R15 + 0x28) \u0026 0xcf | *(byte *)(unaff_RBX + 5) \u0026 0x30;\n    unaff_RBX[0xc] \u003d unaff_R15;\n    unaff_RBX[0xb] \u003d 0;\n    bVar1 \u003d *(byte *)((long)unaff_RBX + 0x27);\n  }\n  else {\n    lVar7 \u003d *(long *)(lVar6 + 0x18);\n    if ((*(byte *)(lVar6 + 0x14) \u0026 8) \u003d\u003d 0) {\n      lVar7 \u003d lVar7 + lVar8;\n    }\n    *(byte *)(unaff_R15 + 0x28) \u003d *(byte *)(unaff_R15 + 0x28) | 1;\n    uVar2 \u003d *unaff_RBX;\n    *(long *)(unaff_R15 + 0x30) \u003d lVar7;\n    *(long *)(unaff_R15 + 0x38) \u003d lVar7;\n    lVar8 \u003d unaff_RBX[7];\n    lVar6 \u003d find_section_list(uVar2,0,0x60);\n    if (lVar6 !\u003d 0) goto LAB_00115860;\nLAB_00115695:\n    uVar2 \u003d *unaff_RBX;\n    *(long *)(unaff_R15 + 0x38) \u003d lVar8 + change_section_address;\n    lVar8 \u003d find_section_list(uVar2,0,0x200);\n    if (lVar8 \u003d\u003d 0) goto LAB_001156b8;\nLAB_00115889:\n    uVar4 \u003d *(uint *)(lVar8 + 0x2c);\n    if (0x3e \u003c uVar4) {\n      FUN_00108179();\n      return;\n    }\nLAB_001156c4:\n    *(uint *)(unaff_R15 + 0x7c) \u003d uVar4;\n    *(undefined4 *)(unaff_R15 + 0xb4) \u003d *(undefined4 *)((long)unaff_RBX + 0xb4);\n    *(byte *)(unaff_R15 + 0x28) \u003d\n         *(byte *)(unaff_R15 + 0x28) \u0026 0xcf | *(byte *)(unaff_RBX + 5) \u0026 0x30;\n    unaff_RBX[0xc] \u003d unaff_R15;\n    unaff_RBX[0xb] \u003d 0;\n    bVar1 \u003d *(byte *)((long)unaff_RBX + 0x27);\n  }\n  if ((bVar1 \u0026 2) !\u003d 0) {\n    lVar8 \u003d unaff_RBX[0x1a];\n    lVar6 \u003d group_signature_isra_0(lVar8,unaff_RBX[0x1c]);\n    if ((lVar6 !\u003d 0) \u0026\u0026\n       (lVar7 \u003d *(long *)(unaff_R12 + 8), *(uint *)(lVar6 + 0x18) \u003d *(uint *)(lVar6 + 0x18) | 0x20,\n       *(int *)(lVar7 + 8) \u003d\u003d 5)) {\n      *(long *)(lVar8 + 0xb0) \u003d lVar6;\n      cVar3 \u003d (**(code **)(*(long *)(unaff_RBP + 8) + 0x158))();\n      if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n        FUN_0010808f();\n        return;\n      }\n      goto LAB_0011571e;\n    }\n  }\n  cVar3 \u003d (**(code **)(*(long *)(unaff_RBP + 8) + 0x158))();\n  if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n    FUN_0010808f();\n    return;\n  }\nLAB_0011571e:\n  if (unaff_R14B !\u003d \u0027\\0\u0027) {\n    *(undefined4 *)(*(long *)(unaff_R15 + 0xd0) + 4) \u003d 8;\n  }\n  if (lVar5 !\u003d 0) {\n    status \u003d 1;\n    bfd_nonfatal_message(0);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup_section"
      ],
      "called": [
        "dcgettext",
        "FUN_00108179",
        "find_section_list"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010808f": {
      "entrypoint": "0x0010808f",
      "current_name": "FUN_0010808f",
      "code": "\nvoid FUN_0010808f(void)\n\n{\n  long lVar1;\n  char unaff_R14B;\n  long unaff_R15;\n  \n  lVar1 \u003d dcgettext(0,\"failed to copy private data\",5);\n  if (unaff_R14B !\u003d \u0027\\0\u0027) {\n    *(undefined4 *)(*(long *)(unaff_R15 + 0xd0) + 4) \u003d 8;\n  }\n  if (lVar1 !\u003d 0) {\n    status \u003d 1;\n    bfd_nonfatal_message(0);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00108179"
      ],
      "called": [
        "dcgettext",
        "bfd_nonfatal_message"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00108179": {
      "entrypoint": "0x00108179",
      "current_name": "FUN_00108179",
      "code": "\nvoid FUN_00108179(void)\n\n{\n  long lVar1;\n  long lVar2;\n  char cVar3;\n  long lVar4;\n  long lVar5;\n  long unaff_RBX;\n  long unaff_RBP;\n  long unaff_R12;\n  char unaff_R14B;\n  long unaff_R15;\n  \n  lVar4 \u003d dcgettext(0,\"failed to set alignment\",5);\n  *(undefined4 *)(unaff_R15 + 0xb4) \u003d *(undefined4 *)(unaff_RBX + 0xb4);\n  *(byte *)(unaff_R15 + 0x28) \u003d\n       *(byte *)(unaff_R15 + 0x28) \u0026 0xcf | *(byte *)(unaff_RBX + 0x28) \u0026 0x30;\n  *(long *)(unaff_RBX + 0x60) \u003d unaff_R15;\n  *(undefined8 *)(unaff_RBX + 0x58) \u003d 0;\n  if ((*(byte *)(unaff_RBX + 0x27) \u0026 2) !\u003d 0) {\n    lVar1 \u003d *(long *)(unaff_RBX + 0xd0);\n    lVar5 \u003d group_signature_isra_0(lVar1,*(undefined8 *)(unaff_RBX + 0xe0));\n    if ((lVar5 !\u003d 0) \u0026\u0026\n       (lVar2 \u003d *(long *)(unaff_R12 + 8), *(uint *)(lVar5 + 0x18) \u003d *(uint *)(lVar5 + 0x18) | 0x20,\n       *(int *)(lVar2 + 8) \u003d\u003d 5)) {\n      *(long *)(lVar1 + 0xb0) \u003d lVar5;\n      cVar3 \u003d (**(code **)(*(long *)(unaff_RBP + 8) + 0x158))();\n      if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n        FUN_0010808f();\n        return;\n      }\n      goto LAB_0011571e;\n    }\n  }\n  cVar3 \u003d (**(code **)(*(long *)(unaff_RBP + 8) + 0x158))();\n  if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n    FUN_0010808f();\n    return;\n  }\nLAB_0011571e:\n  if (unaff_R14B !\u003d \u0027\\0\u0027) {\n    *(undefined4 *)(*(long *)(unaff_R15 + 0xd0) + 4) \u003d 8;\n  }\n  if (lVar4 !\u003d 0) {\n    status \u003d 1;\n    bfd_nonfatal_message(0);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup_section.cold"
      ],
      "called": [
        "dcgettext",
        "group_signature.isra.0",
        "FUN_0010808f"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "make_tempdir.cold": {
      "entrypoint": "0x001081e9",
      "current_name": "make_tempdir.cold",
      "code": "\nundefined8 make_tempdir_cold(void)\n\n{\n  undefined8 in_RAX;\n  void *unaff_RBX;\n  undefined8 param_7;\n  \n  param_7 \u003d in_RAX;\n  free(unaff_RBX);\n  return param_7;\n}\n\n",
      "renaming": {},
      "calling": [
        "make_tempdir"
      ],
      "called": [
        "free"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "smart_rename.cold": {
      "entrypoint": "0x00108200",
      "current_name": "smart_rename.cold",
      "code": "\nundefined  [16] smart_rename_cold(void)\n\n{\n  int *piVar1;\n  undefined8 uVar2;\n  char *unaff_RBP;\n  char unaff_R12B;\n  ulong unaff_R13;\n  undefined auVar3 [16];\n  undefined8 unaff_retaddr;\n  \n  piVar1 \u003d __errno_location();\n  strerror(*piVar1);\n  uVar2 \u003d dcgettext(0,\"unable to copy file \\\u0027%s\\\u0027; reason: %s\",5);\n  non_fatal(uVar2);\n  unlink(unaff_RBP);\n  if (unaff_R12B !\u003d \u0027\\0\u0027) {\n    set_times();\n  }\n  auVar3._0_8_ \u003d unaff_R13 \u0026 0xffffffff;\n  auVar3._8_8_ \u003d unaff_retaddr;\n  return auVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "smart_rename"
      ],
      "called": [
        "non_fatal",
        "unlink",
        "set_times",
        "dcgettext",
        "strerror",
        "__errno_location"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "simple_copy.cold": {
      "entrypoint": "0x00108237",
      "current_name": "simple_copy.cold",
      "code": "\nundefined8 simple_copy_cold(void)\n\n{\n  int iVar1;\n  int *piVar2;\n  int unaff_R12D;\n  \n  piVar2 \u003d __errno_location();\n  iVar1 \u003d *piVar2;\n  close(unaff_R12D);\n  *piVar2 \u003d iVar1;\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "simple_copy"
      ],
      "called": [
        "__errno_location",
        "close"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "is_strip_section_1.isra.0.cold": {
      "entrypoint": "0x0010827b",
      "current_name": "is_strip_section_1.isra.0.cold",
      "code": "\nvoid is_strip_section_1_isra_0_cold(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 *unaff_RBX;\n  \n  uVar1 \u003d *unaff_RBX;\n  uVar2 \u003d dcgettext(0,\"error: section %s matches both remove and copy options\",5);\n                    \n  fatal(uVar2,uVar1);\n}\n\n",
      "renaming": {},
      "calling": [
        "is_strip_section_1.isra.0"
      ],
      "called": [
        "dcgettext",
        "fatal"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010829e": {
      "entrypoint": "0x0010829e",
      "current_name": "FUN_0010829e",
      "code": "\nundefined8 FUN_0010829e(void)\n\n{\n  undefined8 uVar1;\n  int unaff_EBP;\n  \n  if (unaff_EBP \u003d\u003d 5) {\n    uVar1 \u003d is_dwo_section_constprop_0();\n    return uVar1;\n  }\n  if ((unaff_EBP !\u003d 4) \u0026\u0026 (unaff_EBP \u003d\u003d 6)) {\n    uVar1 \u003d FUN_001082b3();\n    return uVar1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "is_strip_section_1.isra.0"
      ],
      "called": [
        "FUN_001082b3",
        "is_dwo_section.constprop.0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001082b3": {
      "entrypoint": "0x001082b3",
      "current_name": "FUN_001082b3",
      "code": "\nuint FUN_001082b3(void)\n\n{\n  uint uVar1;\n  \n  uVar1 \u003d is_dwo_section_constprop_0();\n  return uVar1 ^ 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010829e"
      ],
      "called": [
        "is_dwo_section.constprop.0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "group_signature.isra.0.cold": {
      "entrypoint": "0x001082c3",
      "current_name": "group_signature.isra.0.cold",
      "code": "\nundefined8 group_signature_isra_0_cold(void)\n\n{\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "group_signature.isra.0"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "copy_relocations_in_section.cold": {
      "entrypoint": "0x001082df",
      "current_name": "copy_relocations_in_section.cold",
      "code": "\nvoid copy_relocations_in_section_cold(void)\n\n{\n  uint uVar1;\n  long lVar2;\n  char cVar3;\n  long unaff_RBX;\n  undefined8 *puVar4;\n  undefined8 *puVar5;\n  long unaff_RBP;\n  ulong uVar6;\n  undefined8 *unaff_R13;\n  \n  uVar1 \u003d *(uint *)(unaff_RBX + 0x78);\n  if (strip_symbols \u003d\u003d 7) {\n    puVar4 \u003d unaff_R13;\n    for (uVar6 \u003d 0; uVar6 !\u003d uVar1; uVar6 \u003d uVar6 + 1) {\n      puVar5 \u003d puVar4;\n      if (((*(long **)unaff_R13[uVar6] !\u003d (long *)0x0) \u0026\u0026\n          (lVar2 \u003d **(long **)unaff_R13[uVar6], lVar2 !\u003d 0)) \u0026\u0026\n         (cVar3 \u003d is_specified_symbol(*(undefined8 *)(lVar2 + 8),keep_specific_htab), cVar3 !\u003d \u0027\\0\u0027)\n         ) {\n        puVar5 \u003d puVar4 + 1;\n        *puVar4 \u003d unaff_R13[uVar6];\n      }\n      puVar4 \u003d puVar5;\n    }\n    *puVar4 \u003d 0;\n  }\n                    /* WARNING: Could not recover jumptable at 0x00115eae. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (**(code **)(*(long *)(unaff_RBP + 8) + 0x288))();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_relocations_in_section"
      ],
      "called": [
        "is_specified_symbol"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "check_new_section_flags.cold": {
      "entrypoint": "0x00108375",
      "current_name": "check_new_section_flags.cold",
      "code": "\nuint check_new_section_flags_cold(undefined8 param_1,undefined8 *param_2,undefined8 param_3)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  uint unaff_EBX;\n  \n  if (*(int *)(param_2[1] + 8) !\u003d 2) {\n    uVar1 \u003d *param_2;\n    unaff_EBX \u003d unaff_EBX \u0026 0xf7ffffff;\n    uVar2 \u003d dcgettext(0,\"%s[%s]: Note - dropping \\\u0027share\\\u0027 flag as output format is not COFF\",5);\n    non_fatal(uVar2,uVar1,param_3);\n  }\n  return unaff_EBX;\n}\n\n",
      "renaming": {},
      "calling": [
        "check_new_section_flags"
      ],
      "called": [
        "non_fatal",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "mark_symbols_used_in_relocations.cold": {
      "entrypoint": "0x001083b7",
      "current_name": "mark_symbols_used_in_relocations.cold",
      "code": "\nundefined8 mark_symbols_used_in_relocations_cold(long param_1)\n\n{\n  int iVar1;\n  undefined8 *unaff_RBP;\n  undefined8 unaff_retaddr;\n  \n  if (param_1 \u003d\u003d -1) {\n    iVar1 \u003d bfd_get_error();\n    if (iVar1 \u003d\u003d 5) {\n      return unaff_retaddr;\n    }\n  }\n  bfd_nonfatal(*unaff_RBP);\n                    \n  xexit(1);\n}\n\n",
      "renaming": {},
      "calling": [
        "mark_symbols_used_in_relocations"
      ],
      "called": [
        "bfd_nonfatal",
        "bfd_get_error",
        "xexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "copy_section.cold": {
      "entrypoint": "0x001083de",
      "current_name": "copy_section.cold",
      "code": "\nvoid copy_section_cold(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 *unaff_RBX;\n  undefined4 unaff_EBP;\n  \n  uVar1 \u003d *unaff_RBX;\n  uVar2 \u003d dcgettext(0,\"cannot reverse bytes: length of section %s must be evenly divisible by %d\",5)\n  ;\n                    \n  fatal(uVar2,uVar1,unaff_EBP);\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_section"
      ],
      "called": [
        "dcgettext",
        "fatal"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00108466": {
      "entrypoint": "0x00108466",
      "current_name": "FUN_00108466",
      "code": "\nvoid FUN_00108466(void)\n\n{\n  void *param_7;\n  \n  status \u003d 1;\n  bfd_nonfatal_message(0);\n  free(param_7);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_section"
      ],
      "called": [
        "free",
        "bfd_nonfatal_message"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "merge_gnu_build_notes.cold": {
      "entrypoint": "0x0010847a",
      "current_name": "merge_gnu_build_notes.cold",
      "code": "\nvoid merge_gnu_build_notes_cold(void)\n\n{\n  FUN_00116490();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001086af"
      ],
      "called": [
        "FUN_00116490"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001086af": {
      "entrypoint": "0x001086af",
      "current_name": "FUN_001086af",
      "code": "\nulong FUN_001086af(void)\n\n{\n  ulong uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  bool bVar4;\n  ulong *puVar5;\n  int iVar6;\n  long lVar7;\n  undefined8 uVar8;\n  ulong uVar9;\n  ulong uVar10;\n  ulong uVar11;\n  undefined *__ptr;\n  ulong in_RCX;\n  ulong uVar12;\n  ulong uVar13;\n  ulong uVar14;\n  ulong unaff_RBX;\n  ulong unaff_RBP;\n  ulong *puVar15;\n  undefined *puVar16;\n  char cVar17;\n  undefined *puVar18;\n  undefined *puVar19;\n  ulong *unaff_R12;\n  ulong unaff_R13;\n  ulong uVar20;\n  size_t __nmemb;\n  undefined8 *unaff_R14;\n  ulong *puVar21;\n  byte bVar22;\n  int iVar23;\n  ulong unaff_retaddr;\n  ulong param_7;\n  uint param_8;\n  ulong param_9;\n  ulong param_10;\n  ulong *param_11;\n  undefined *in_stack_00000030;\n  uint in_stack_00000038;\n  uint param_13;\n  undefined8 *param_14;\n  \n  bVar22 \u003d 0;\n  param_7 \u003d in_RCX;\n  uVar9 \u003d (**(code **)(unaff_R14[1] + 0x40))();\n  uVar10 \u003d (**(code **)(unaff_R14[1] + 0x40))(unaff_R12[4] + 4);\nLAB_0011662a:\n  uVar13 \u003d unaff_RBP;\n  uVar20 \u003d unaff_R13;\n  if (uVar10 \u003c uVar9) {\n    uVar9 \u003d uVar10;\n  }\n  do {\n    uVar11 \u003d param_7;\n    uVar12 \u003d param_7;\n    puVar15 \u003d unaff_R12;\n    if (unaff_R12[2] \u003d\u003d 0x100) {\n      if (uVar9 \u003d\u003d 0) {\n        uVar9 \u003d unaff_retaddr;\n      }\n      uVar14 \u003d *unaff_R12;\n      unaff_R12[7] \u003d uVar9;\n      unaff_RBP \u003d uVar13;\n      unaff_R13 \u003d uVar10;\n      unaff_retaddr \u003d uVar9;\n      if (uVar10 \u003d\u003d 0) goto LAB_001164af;\n    }\n    else {\n      if (uVar9 \u003d\u003d 0) {\n        uVar9 \u003d param_9;\n      }\n      uVar14 \u003d *unaff_R12;\n      unaff_R12[7] \u003d uVar9;\n      unaff_RBP \u003d uVar10;\n      unaff_R13 \u003d uVar20;\n      param_9 \u003d uVar9;\n      if (uVar10 \u003d\u003d 0) goto LAB_0011669e;\n    }\nLAB_001164bb:\n    puVar15[8] \u003d uVar10;\n    if (*(char *)((puVar15[3] - 1) + uVar14) !\u003d \u0027\\0\u0027) {\n      lVar7 \u003d dcgettext(0,\"corrupt GNU build attribute note: name not NUL terminated\",5);\n      goto LAB_0010849a;\n    }\n    unaff_R12 \u003d puVar15 + 9;\n    if (unaff_RBX \u003c 0xc) {\n      if (unaff_RBX !\u003d 0) {\n        lVar7 \u003d dcgettext(0,\"corrupt GNU build attribute notes: excess data at end\",5);\n        goto LAB_0010849a;\n      }\n      if ((in_stack_00000038 | param_13 | param_8) !\u003d 0) {\n        if (((param_13 | param_8) \u003d\u003d 0) || (in_stack_00000038 \u003d\u003d 0)) {\n          if (param_13 \u003d\u003d 0) {\n            if (param_8 !\u003d 0) goto LAB_0011671b;\n            goto LAB_001166f8;\n          }\n          if (param_8 \u003d\u003d 0) goto LAB_001166f8;\n        }\n        lVar7 \u003d dcgettext(0,\"bad GNU build attribute notes: multiple different versions\",5);\n        goto LAB_0010849a;\n      }\n      uVar2 \u003d *unaff_R14;\n      uVar3 \u003d *param_14;\n      uVar8 \u003d dcgettext(0,\"%s[%s]: Warning: version note missing - assuming version 3\",5);\n      non_fatal(uVar8,uVar2,uVar3);\nLAB_0011671b:\n      __nmemb \u003d ((long)unaff_R12 - (long)param_11 \u003e\u003e 3) * -0x71c71c71c71c71c7;\n      qsort(param_11,__nmemb,0x48,compare_gnu_build_notes);\n      puVar15 \u003d param_11;\n      goto LAB_001167f9;\n    }\n    uVar10 \u003d (**(code **)(unaff_R14[1] + 0x40))(uVar12);\n    *unaff_R12 \u003d uVar10;\n    uVar10 \u003d (**(code **)(unaff_R14[1] + 0x40))(uVar12 + 4);\n    puVar15[10] \u003d uVar10;\n    uVar9 \u003d (**(code **)(unaff_R14[1] + 0x40))(uVar12 + 8);\n    uVar14 \u003d *unaff_R12;\n    puVar15[0xb] \u003d uVar9;\n    uVar10 \u003d puVar15[10];\n    uVar13 \u003d uVar14 + 3 \u0026 0xfffffffffffffffc;\n    puVar15[0xf] \u003d uVar13;\n    if (uVar10 !\u003d (uVar10 + 3 \u0026 0xfffffffffffffffc)) {\n      lVar7 \u003d dcgettext(0,\"corrupt GNU build attribute note: description size not a factor of 4\",5);\n      goto LAB_0010849a;\n    }\n    if (1 \u003c uVar9 - 0x100) {\n      lVar7 \u003d dcgettext(0,\"corrupt GNU build attribute note: wrong note type\",5);\n      goto LAB_0010849a;\n    }\n    uVar11 \u003d uVar13 + uVar10 + 0xc;\n    if (unaff_RBX \u003c uVar11) {\n      lVar7 \u003d dcgettext(0,\"corrupt GNU build attribute note: note too big\",5);\n      goto LAB_0010849a;\n    }\n    if (uVar14 \u003c 2) {\n      lVar7 \u003d dcgettext(0,\"corrupt GNU build attribute note: name too small\",5);\n      goto LAB_0010849a;\n    }\n    puVar15[0xc] \u003d uVar12 + 0xc;\n    uVar1 \u003d uVar12 + 0xc + uVar13;\n    puVar15[0xd] \u003d uVar1;\n    unaff_RBX \u003d unaff_RBX + (-0xc - (uVar13 + uVar10));\n    uVar11 \u003d uVar12 + uVar11;\n    if (uVar14 !\u003d 2) {\n      if (*(char *)(uVar12 + 0xc) \u003d\u003d \u0027$\u0027) {\n        if ((*(char *)(uVar12 + 0xd) \u003d\u003d \u0027\\x01\u0027) \u0026\u0026 (*(char *)(uVar12 + 0xe) \u003d\u003d \u00271\u0027)) {\n          uVar10 \u003d FUN_00116490();\n          return uVar10;\n        }\n      }\n      else if ((((4 \u003c uVar14) \u0026\u0026 (*(char *)(uVar12 + 0xc) \u003d\u003d \u0027G\u0027)) \u0026\u0026\n               (*(char *)(uVar12 + 0xd) \u003d\u003d \u0027A\u0027)) \u0026\u0026\n              ((*(char *)(uVar12 + 0xe) \u003d\u003d \u0027$\u0027 \u0026\u0026 (*(char *)(uVar12 + 0xf) \u003d\u003d \u0027\\x01\u0027)))) {\n        if (*(char *)(uVar12 + 0x10) \u003d\u003d \u00272\u0027) {\n          uVar10 \u003d FUN_00116490();\n          return uVar10;\n        }\n        if (*(char *)(uVar12 + 0x10) \u003d\u003d \u00273\u0027) {\n          uVar10 \u003d FUN_00116490();\n          return uVar10;\n        }\n        lVar7 \u003d dcgettext(0,\"corrupt GNU build attribute note: unsupported version\",5);\n        goto LAB_0010849a;\n      }\n    }\n    uVar13 \u003d unaff_RBP;\n    uVar20 \u003d unaff_R13;\n    if (uVar10 \u003d\u003d 0) {\n      if (uVar9 \u003d\u003d 0x100) {\n        puVar15[0x10] \u003d unaff_retaddr;\nLAB_001164af:\n        uVar12 \u003d uVar11;\n        uVar10 \u003d uVar20;\n        puVar15 \u003d unaff_R12;\n        unaff_R13 \u003d uVar20;\n      }\n      else {\n        puVar15[0x10] \u003d param_9;\nLAB_0011669e:\n        unaff_RBP \u003d uVar13;\n        uVar12 \u003d uVar11;\n        uVar10 \u003d uVar13;\n        puVar15 \u003d unaff_R12;\n        unaff_R13 \u003d uVar20;\n      }\n      goto LAB_001164bb;\n    }\n    if (uVar10 \u003d\u003d 0x10) break;\n    if (0x10 \u003c uVar10) {\nLAB_00116679:\n      lVar7 \u003d dcgettext(0,\"corrupt GNU build attribute note: bad description size\",5);\nLAB_0010849a:\n      if (lVar7 !\u003d 0) {\n        bfd_set_error(0x11);\n        bfd_nonfatal_message(0,unaff_R14,param_14,lVar7);\n        status \u003d 1;\n      }\n      goto LAB_001166f8;\n    }\n    if (uVar10 !\u003d 4) {\n      if (uVar10 \u003d\u003d 8) {\n        uVar10 \u003d FUN_001086af();\n        return uVar10;\n      }\n      goto LAB_00116679;\n    }\n    param_7 \u003d uVar11;\n    uVar9 \u003d (**(code **)(unaff_R14[1] + 0x40))();\n    uVar10 \u003d 0xffffffffffffffff;\n  } while( true );\n  param_7 \u003d uVar11;\n  uVar9 \u003d (**(code **)(unaff_R14[1] + 0x28))(uVar1);\n  uVar10 \u003d (**(code **)(unaff_R14[1] + 0x28))();\n  goto LAB_0011662a;\nLAB_001167f9:\n  if (unaff_R12 \u003c\u003d puVar15) {\n    qsort(param_11,__nmemb,0x48,sort_gnu_build_notes);\n    __ptr \u003d (undefined *)xmalloc(param_10 * 2);\n    param_7 \u003d 0;\n    param_9 \u003d 0;\n    puVar19 \u003d __ptr;\n    for (puVar15 \u003d param_11; puVar15 \u003c unaff_R12; puVar15 \u003d puVar15 + 9) {\n      if (puVar15[2] !\u003d 0) {\n        puVar18 \u003d puVar19 + 4;\n        puVar16 \u003d puVar19 + 0xc;\n        if ((puVar15[7] \u003d\u003d param_9) \u0026\u0026 (puVar15[8] \u003d\u003d param_7)) {\n          (**(code **)(unaff_R14[1] + 0x50))(*puVar15,puVar19);\n          (**(code **)(unaff_R14[1] + 0x50))(0,puVar18);\n          (**(code **)(unaff_R14[1] + 0x50))(puVar15[2],puVar19 + 8);\n          uVar9 \u003d puVar15[6];\n          uVar10 \u003d *puVar15;\n          puVar19 \u003d (undefined *)puVar15[3];\n          puVar18 \u003d puVar16;\n          for (uVar13 \u003d uVar10; uVar13 !\u003d 0; uVar13 \u003d uVar13 - 1) {\n            *puVar18 \u003d *puVar19;\n            puVar19 \u003d puVar19 + (ulong)bVar22 * -2 + 1;\n            puVar18 \u003d puVar18 + (ulong)bVar22 * -2 + 1;\n          }\n          if (uVar10 \u003c uVar9) {\n            for (lVar7 \u003d uVar9 - uVar10; lVar7 !\u003d 0; lVar7 \u003d lVar7 + -1) {\n              *puVar18 \u003d 0;\n              puVar18 \u003d puVar18 + (ulong)bVar22 * -2 + 1;\n            }\n          }\n          puVar19 \u003d puVar16 + uVar9;\n        }\n        else {\n          (**(code **)(unaff_R14[1] + 0x50))();\n          if (*(int *)(unaff_R14[1] + 8) \u003d\u003d 5) {\n            cVar17 \u003d (*(char *)(unaff_R14[0x22] + 4) \u003d\u003d \u0027\\x02\u0027) * \u0027\\b\u0027 + \u0027\\b\u0027;\n          }\n          else {\n            cVar17 \u003d \u0027\\b\u0027;\n          }\n          (**(code **)(unaff_R14[1] + 0x50))(cVar17,puVar18);\n          (**(code **)(unaff_R14[1] + 0x50))(puVar15[2],puVar19 + 8);\n          uVar10 \u003d *puVar15;\n          puVar19 \u003d (undefined *)puVar15[3];\n          puVar18 \u003d puVar16;\n          for (uVar9 \u003d uVar10; uVar9 !\u003d 0; uVar9 \u003d uVar9 - 1) {\n            *puVar18 \u003d *puVar19;\n            puVar19 \u003d puVar19 + (ulong)bVar22 * -2 + 1;\n            puVar18 \u003d puVar18 + (ulong)bVar22 * -2 + 1;\n          }\n          uVar9 \u003d puVar15[6];\n          if (uVar10 \u003c uVar9) {\n            for (lVar7 \u003d uVar9 - uVar10; lVar7 !\u003d 0; lVar7 \u003d lVar7 + -1) {\n              *puVar18 \u003d 0;\n              puVar18 \u003d puVar18 + (ulong)bVar22 * -2 + 1;\n            }\n          }\n          lVar7 \u003d unaff_R14[1];\n          puVar16 \u003d puVar16 + uVar9;\n          puVar19 \u003d puVar16 + 8;\n          if ((*(int *)(lVar7 + 8) \u003d\u003d 5) \u0026\u0026 (*(char *)(unaff_R14[0x22] + 4) \u003d\u003d \u0027\\x02\u0027)) {\n            (**(code **)(lVar7 + 0x38))(puVar15[7],puVar16);\n            (**(code **)(unaff_R14[1] + 0x38))(puVar15[8],puVar19);\n            puVar19 \u003d puVar16 + 0x10;\n          }\n          else {\n            (**(code **)(lVar7 + 0x50))(puVar15[7],puVar16);\n            (**(code **)(unaff_R14[1] + 0x50))(puVar15[8],puVar16 + 4);\n          }\n          param_9 \u003d puVar15[7];\n          param_7 \u003d puVar15[8];\n        }\n      }\n    }\n    uVar9 \u003d (long)puVar19 - (long)__ptr;\n    uVar10 \u003d uVar9;\n    puVar19 \u003d __ptr;\n    if (uVar9 \u003c param_10) {\n      for (; param_10 \u003d uVar9, uVar10 !\u003d 0; uVar10 \u003d uVar10 - 1) {\n        *in_stack_00000030 \u003d *puVar19;\n        puVar19 \u003d puVar19 + (ulong)bVar22 * -2 + 1;\n        in_stack_00000030 \u003d in_stack_00000030 + (ulong)bVar22 * -2 + 1;\n      }\n    }\n    free(__ptr);\nLAB_001166f8:\n    free(param_11);\n    return param_10;\n  }\n  if (puVar15[2] !\u003d 0) {\n    uVar10 \u003d puVar15[7];\n    uVar9 \u003d puVar15[8];\n    uVar13 \u003d puVar15[2];\n    puVar21 \u003d puVar15;\n    iVar23 \u003d 0;\n    if (uVar10 \u003d\u003d uVar9) {\n      puVar15[2] \u003d 0;\n    }\n    else {\n      do {\n        do {\n          puVar5 \u003d puVar21;\n          puVar21 \u003d puVar5 + -9;\n          if (puVar21 \u003c param_11) goto LAB_001167f5;\n          uVar20 \u003d puVar5[-7];\n        } while (uVar20 \u003d\u003d 0);\n        param_7 \u003d uVar13;\n        if ((*puVar21 !\u003d *puVar15) ||\n           (iVar6 \u003d memcmp((void *)puVar5[-6],(void *)puVar15[3],*puVar15), iVar6 !\u003d 0)) break;\n        uVar13 \u003d puVar5[-2];\n        uVar11 \u003d puVar5[-1];\n        if (uVar10 \u003d\u003d uVar13) {\n          if (uVar9 \u003d\u003d uVar11) {\n            puVar15[2] \u003d 0;\n            break;\n          }\nLAB_001167a6:\n          if (uVar9 \u003c\u003d uVar11) {\n            puVar15[2] \u003d 0;\n            break;\n          }\n          if (uVar11 \u003c uVar10) {\nLAB_0010852c:\n            if ((0xfffffffffffffff0 \u003c uVar11) || (uVar10 \u003c\u003d (uVar11 + 0xf \u0026 0xfffffffffffffff0)))\n            goto FUN_00116852;\n          }\nLAB_001167b8:\n          if ((param_7 \u003d\u003d 0x101) \u003d\u003d (uVar20 \u003d\u003d 0x101)) {\n            if (uVar11 \u003c\u003d uVar9) {\n              uVar11 \u003d uVar9;\n            }\n            if (uVar13 \u003c uVar10) {\n              uVar10 \u003d uVar13;\n            }\n            puVar5[-1] \u003d uVar11;\n            puVar5[-2] \u003d uVar10;\n            puVar15[2] \u003d 0;\n            break;\n          }\n        }\n        else {\n          if (uVar13 \u003c\u003d uVar10) goto LAB_001167a6;\n          if (uVar11 \u003c uVar10) goto LAB_0010852c;\n          if (uVar9 \u003c uVar10) {\n            if ((0xfffffffffffffff0 \u003c uVar9) || (uVar13 \u003c\u003d (uVar9 + 0xf \u0026 0xfffffffffffffff0)))\n            goto FUN_00116852;\n            goto LAB_001167b8;\n          }\n          if (uVar9 !\u003d uVar11) goto LAB_001167b8;\n        }\nFUN_00116852:\n        bVar4 \u003d iVar23 \u003c 0x11;\n        uVar13 \u003d param_7;\n        iVar23 \u003d iVar23 + 1;\n      } while (bVar4);\n    }\n  }\nLAB_001167f5:\n  puVar15 \u003d puVar15 + 9;\n  goto LAB_001167f9;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00116490"
      ],
      "called": [
        "non_fatal",
        "bfd_set_error",
        "dcgettext",
        "FUN_00116490",
        "qsort",
        "compare_gnu_build_notes",
        "merge_gnu_build_notes.cold",
        "bfd_nonfatal_message"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "get_sections": {
      "entrypoint": "0x0010870e",
      "current_name": "get_sections",
      "code": "\nvoid get_sections(undefined8 param_1,undefined8 param_2,long *param_3)\n\n{\n  undefined8 *puVar1;\n  \n  puVar1 \u003d (undefined8 *)*param_3;\n  *puVar1 \u003d param_2;\n  *param_3 \u003d (long)(puVar1 + 1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_nonfatal.cold": {
      "entrypoint": "0x0010871c",
      "current_name": "bfd_nonfatal.cold",
      "code": "\n\n\nvoid bfd_nonfatal_cold(void)\n\n{\n  undefined8 uVar1;\n  long unaff_RBX;\n  undefined8 unaff_retaddr;\n  \n  uVar1 \u003d dcgettext(0,\"cause of error unknown\",5);\n  fflush(_stdout);\n  if (unaff_RBX !\u003d 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",program_name);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",program_name,uVar1,unaff_retaddr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "bfd_nonfatal"
      ],
      "called": [
        "fprintf",
        "fflush",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "compare_section_lma": {
      "entrypoint": "0x0010875d",
      "current_name": "compare_section_lma",
      "code": "\nint compare_section_lma(long *param_1,long *param_2)\n\n{\n  long lVar1;\n  long lVar2;\n  int iVar3;\n  uint uVar4;\n  \n  lVar1 \u003d *param_1;\n  lVar2 \u003d *param_2;\n  uVar4 \u003d *(uint *)(lVar2 + 0x24) \u0026 0x102;\n  if ((*(uint *)(lVar1 + 0x24) \u0026 0x102) \u003d\u003d 0x102) {\n    if (uVar4 !\u003d 0x102) {\n      return 1;\n    }\n  }\n  else if (uVar4 \u003d\u003d 0x102) {\n    return -1;\n  }\n  iVar3 \u003d 1;\n  if (*(ulong *)(lVar1 + 0x38) \u003c\u003d *(ulong *)(lVar2 + 0x38)) {\n    iVar3 \u003d -1;\n    if (*(ulong *)(lVar2 + 0x38) \u003c\u003d *(ulong *)(lVar1 + 0x38)) {\n      if (*(ulong *)(lVar2 + 0x40) \u003c *(ulong *)(lVar1 + 0x40)) {\n        iVar3 \u003d 1;\n      }\n      else {\n        iVar3 \u003d -1;\n        if (*(ulong *)(lVar2 + 0x40) \u003c\u003d *(ulong *)(lVar1 + 0x40)) {\n          iVar3 \u003d 1;\n          if (*(uint *)(lVar1 + 0x18) \u003c\u003d *(uint *)(lVar2 + 0x18)) {\n            return -(uint)(*(uint *)(lVar1 + 0x18) \u003c *(uint *)(lVar2 + 0x18));\n          }\n        }\n      }\n    }\n  }\n  return iVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "compare_gnu_build_notes.cold": {
      "entrypoint": "0x001087da",
      "current_name": "compare_gnu_build_notes.cold",
      "code": "\nundefined  [16] compare_gnu_build_notes_cold(void)\n\n{\n  long in_RAX;\n  undefined auVar1 [16];\n  undefined8 unaff_retaddr;\n  \n  auVar1._1_7_ \u003d 0;\n  auVar1[0] \u003d in_RAX \u003d\u003d 0x100;\n  auVar1._8_8_ \u003d unaff_retaddr;\n  return auVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "compare_gnu_build_notes"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sort_gnu_build_notes.cold": {
      "entrypoint": "0x001087fd",
      "current_name": "sort_gnu_build_notes.cold",
      "code": "\nundefined8 sort_gnu_build_notes_cold(void)\n\n{\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "sort_gnu_build_notes"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "htab_hash_redefnode": {
      "entrypoint": "0x00108800",
      "current_name": "htab_hash_redefnode",
      "code": "\nvoid htab_hash_redefnode(undefined8 *param_1)\n\n{\n  htab_hash_string(*param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "htab_hash_string"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "create_new_symbol.cold": {
      "entrypoint": "0x00108808",
      "current_name": "create_new_symbol.cold",
      "code": "\nvoid create_new_symbol_cold(void)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  long unaff_RBP;\n  \n  uVar1 \u003d *(undefined8 *)(unaff_RBP + 0x20);\n  uVar2 \u003d dcgettext(0,\"Section %s not found\",5);\n                    \n  fatal(uVar2,uVar1);\n}\n\n",
      "renaming": {},
      "calling": [
        "create_new_symbol"
      ],
      "called": [
        "dcgettext",
        "fatal"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "set_times.cold": {
      "entrypoint": "0x0010882c",
      "current_name": "set_times.cold",
      "code": "\nvoid set_times_cold(void)\n\n{\n  int *piVar1;\n  undefined8 uVar2;\n  \n  piVar1 \u003d __errno_location();\n  strerror(*piVar1);\n  uVar2 \u003d dcgettext(0,\"%s: cannot set time: %s\",5);\n  non_fatal(uVar2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "set_times"
      ],
      "called": [
        "non_fatal",
        "dcgettext",
        "strerror",
        "__errno_location"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "free_saved_stabs": {
      "entrypoint": "0x00108863",
      "current_name": "free_saved_stabs",
      "code": "\nvoid free_saved_stabs(void)\n\n{\n  undefined4 *puVar1;\n  undefined4 *puVar2;\n  \n  puVar1 \u003d (undefined4 *)saved_stabs;\n  do {\n    puVar2 \u003d puVar1 + 6;\n    free(*(void **)(puVar1 + 4));\n    *(undefined8 *)(puVar1 + 4) \u003d 0;\n    puVar1 \u003d puVar2;\n  } while (puVar2 !\u003d \u0026saved_stabs_index);\n  saved_stabs_index \u003d 0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [
        "free"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "eq_string_redefnode": {
      "entrypoint": "0x00108898",
      "current_name": "eq_string_redefnode",
      "code": "\nundefined  [16] eq_string_redefnode(char **param_1,char **param_2)\n\n{\n  int iVar1;\n  undefined8 in_RAX;\n  undefined auVar2 [16];\n  \n  iVar1 \u003d strcmp(*param_1,*param_2);\n  auVar2._1_7_ \u003d 0;\n  auVar2[0] \u003d iVar1 \u003d\u003d 0;\n  auVar2._8_8_ \u003d in_RAX;\n  return auVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "strcmp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "save_stab": {
      "entrypoint": "0x001088ae",
      "current_name": "save_stab",
      "code": "\nulong save_stab(undefined4 param_1,undefined4 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  int iVar1;\n  long lVar2;\n  undefined8 uVar3;\n  \n  lVar2 \u003d (long)saved_stabs_index * 0x18;\n  free(*(void **)(saved_stabs + lVar2 + 0x10));\n  *(undefined4 *)(saved_stabs + lVar2) \u003d param_1;\n  *(undefined4 *)(saved_stabs + lVar2 + 4) \u003d param_2;\n  *(undefined8 *)(saved_stabs + lVar2 + 8) \u003d param_3;\n  uVar3 \u003d xstrdup(param_4);\n  *(undefined8 *)(saved_stabs + lVar2 + 0x10) \u003d uVar3;\n  iVar1 \u003d saved_stabs_index + 1;\n  saved_stabs_index \u003d iVar1 % 0x10;\n  return (long)iVar1 / 0x10 \u0026 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [
        "free",
        "xstrdup"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "copy_usage": {
      "entrypoint": "0x00108916",
      "current_name": "copy_usage",
      "code": "\nvoid copy_usage(FILE *param_1,int param_2)\n\n{\n  undefined8 uVar1;\n  char *pcVar2;\n  \n  uVar1 \u003d program_name;\n  pcVar2 \u003d (char *)dcgettext(0,\"Usage: %s [option(s)] in-file [out-file]\\n\",5);\n  fprintf(param_1,pcVar2,uVar1);\n  pcVar2 \u003d (char *)dcgettext(0,\" Copies a binary file, possibly transforming it in the process\\n\",5)\n  ;\n  fprintf(param_1,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\" The options are:\\n\",5);\n  fprintf(param_1,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \"  -I --input-target \u003cbfdname\u003e      Assume input file is in format \u003cbfdname\u003e\\n  -O --output-target \u003cbfdname\u003e     Create an output file in format \u003cbfdname\u003e\\n  -B --binary-architecture \u003carch\u003e  Set output arch, when input is arch-less\\n  -F --target \u003cbfdname\u003e            Set both input and output format to \u003cbfdname\u003e\\n     --debugging                   Convert debugging information, if possible\\n  -p --preserve-dates              Copy modified/access timestamps to the output\\n\"\n                             ,5);\n  fprintf(param_1,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \"  -D --enable-deterministic-archives\\n                                   Produce deterministic output when stripping archives (default)\\n  -U --disable-deterministic-archives\\n                                   Disable -D behavior\\n\"\n                             ,5);\n  fprintf(param_1,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \"  -j --only-section \u003cname\u003e         Only copy section \u003cname\u003e into the output\\n     --add-gnu-debuglink\u003d\u003cfile\u003e    Add section .gnu_debuglink linking to \u003cfile\u003e\\n  -R --remove-section \u003cname\u003e       Remove section \u003cname\u003e from the output\\n     --remove-relocations \u003cname\u003e   Remove relocations from section \u003cname\u003e\\n  -S --strip-all                   Remove all symbol and relocation information\\n  -g --strip-debug                 Remove all debugging symbols \u0026 sections\\n     --strip-dwo                   Remove all DWO sections\\n     --strip-unneeded              Remove all symbols not needed by relocations\\n  -N --strip-symbol \u003cname\u003e         Do not copy symbol \u003cname\u003e\\n     --strip-unneeded-symbol \u003cname\u003e\\n                                   Do not copy symbol \u003cname\u003e unless needed by\\n                                     relocations\\n     --only-keep-debug             Strip everything but the debug information\\n     --extract-dwo                 Copy only DWO sections\\n     --extract-symbol              Remove section contents but keep symbols\\n     --keep-section \u003cname\u003e         Do not strip section \u003cname\u003e\\n  -K --keep-symbol \u003cname\u003e          Do not strip symbol \u003cname\u003e\\n     --keep-section-symbols        Do not strip section symbols\\n     --keep-file-symbols           Do not strip file symbol(s)\\n     --localize-hidden             Turn all ELF hidden symbols into locals\\n  -L --localize-symbol \u003cname\u003e      Force symbol \u003cname\u003e to be marked as a local\\n     --globalize-symbol \u003cname\u003e     Force symbol \u003cname\u003e to be marked as a global\\n  -G --keep-global-symbol \u003cname\u003e   Localize all symbols except \u003cname\u003e\\n  -W --weaken-symbol \u003cname\u003e        Force symbol \u003cname\u003e to be marked as a weak\\n     --weaken                      Force all global symbols to be marked as weak\\n  -w --wildcard                    Permit wildcard in symbol comparison\\n  -x --discard-all                 Remove all non-global symbols\\n  -X --discard-locals              Remove any compiler-generated symbols\\n  -i --interleave[\u003d\u003cnumber\u003e]       Only copy N out of every \u003cnumber\u003e bytes\\n     --interlea...\" /* TRUNCATED STRING LITERAL */\n                             ,5);\n  fprintf(param_1,pcVar2);\n  list_supported_targets(program_name,param_1);\n  if (param_2 \u003d\u003d 0) {\n    pcVar2 \u003d (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(param_1,pcVar2,\"\u003chttps://sourceware.org/bugzilla/\u003e\");\n  }\n                    \n  exit(param_2);\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "fprintf",
        "dcgettext",
        "exit",
        "list_supported_targets"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strip_usage": {
      "entrypoint": "0x00108a2a",
      "current_name": "strip_usage",
      "code": "\nvoid strip_usage(FILE *param_1,int param_2)\n\n{\n  undefined8 uVar1;\n  char *pcVar2;\n  \n  uVar1 \u003d program_name;\n  pcVar2 \u003d (char *)dcgettext(0,\"Usage: %s \u003coption(s)\u003e in-file(s)\\n\",5);\n  fprintf(param_1,pcVar2,uVar1);\n  pcVar2 \u003d (char *)dcgettext(0,\" Removes symbols and sections from files\\n\",5);\n  fprintf(param_1,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\" The options are:\\n\",5);\n  fprintf(param_1,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \"  -I --input-target\u003d\u003cbfdname\u003e      Assume input file is in format \u003cbfdname\u003e\\n  -O --output-target\u003d\u003cbfdname\u003e     Create an output file in format \u003cbfdname\u003e\\n  -F --target\u003d\u003cbfdname\u003e            Set both input and output format to \u003cbfdname\u003e\\n  -p --preserve-dates              Copy modified/access timestamps to the output\\n\"\n                             ,5);\n  fprintf(param_1,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \"  -D --enable-deterministic-archives\\n                                   Produce deterministic output when stripping archives (default)\\n  -U --disable-deterministic-archives\\n                                   Disable -D behavior\\n\"\n                             ,5);\n  fprintf(param_1,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \"  -R --remove-section\u003d\u003cname\u003e       Also remove section \u003cname\u003e from the output\\n     --remove-relocations \u003cname\u003e   Remove relocations from section \u003cname\u003e\\n  -s --strip-all                   Remove all symbol and relocation information\\n  -g -S -d --strip-debug           Remove all debugging symbols \u0026 sections\\n     --strip-dwo                   Remove all DWO sections\\n     --strip-unneeded              Remove all symbols not needed by relocations\\n     --only-keep-debug             Strip everything but the debug information\\n  -M  --merge-notes                Remove redundant entries in note sections (default)\\n      --no-merge-notes             Do not attempt to remove redundant notes\\n  -N --strip-symbol\u003d\u003cname\u003e         Do not copy symbol \u003cname\u003e\\n     --keep-section\u003d\u003cname\u003e         Do not strip section \u003cname\u003e\\n  -K --keep-symbol\u003d\u003cname\u003e          Do not strip symbol \u003cname\u003e\\n     --keep-section-symbols        Do not strip section symbols\\n     --keep-file-symbols           Do not strip file symbol(s)\\n  -w --wildcard                    Permit wildcard in symbol comparison\\n  -x --discard-all                 Remove all non-global symbols\\n  -X --discard-locals              Remove any compiler-generated symbols\\n  -v --verbose                     List all object files modified\\n  -V --version                     Display this program\\\u0027s version number\\n  -h --help                        Display this output\\n     --info                        List object formats \u0026 architectures supported\\n  -o \u003cfile\u003e                        Place stripped output into \u003cfile\u003e\\n\"\n                             ,5);\n  fprintf(param_1,pcVar2);\n  list_supported_targets(program_name,param_1);\n  if (param_2 \u003d\u003d 0) {\n    pcVar2 \u003d (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(param_1,pcVar2,\"\u003chttps://sourceware.org/bugzilla/\u003e\");\n  }\n                    \n  exit(param_2);\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "fprintf",
        "dcgettext",
        "exit",
        "list_supported_targets"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_context": {
      "entrypoint": "0x00108b3e",
      "current_name": "stab_context",
      "code": "\n\n\nundefined8 stab_context(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  char *__format;\n  long lVar1;\n  long lVar2;\n  int *piVar3;\n  int iVar4;\n  \n  __format \u003d (char *)dcgettext(0,\"Last stabs entries before error:\\n\",5);\n  fprintf(_stderr,__format);\n  fwrite(\"n_type n_desc n_value  string\\n\",1,0x1e,_stderr);\n  iVar4 \u003d saved_stabs_index;\n  do {\n    lVar2 \u003d (long)iVar4 * 0x18;\n    piVar3 \u003d (int *)(saved_stabs + lVar2);\n    if (*(long *)(saved_stabs + lVar2 + 0x10) !\u003d 0) {\n      lVar1 \u003d bfd_get_stab_name(*piVar3);\n      if (lVar1 \u003d\u003d 0) {\n        if (*piVar3 \u003d\u003d 0) {\n          fwrite(\"HdrSym\",1,6,_stderr);\n        }\n        else {\n          fprintf(_stderr,\"%-6d\");\n        }\n      }\n      else {\n        fprintf(_stderr,\"%-6s\",lVar1);\n      }\n      fprintf(_stderr,\" %-6d \",(ulong)*(uint *)(saved_stabs + lVar2 + 4));\n      fprintf(_stderr,\"%08lx\",*(undefined8 *)(saved_stabs + lVar2 + 8));\n      if (*piVar3 !\u003d 0) {\n        fprintf(_stderr,\" %s\",*(undefined8 *)(saved_stabs + lVar2 + 0x10));\n      }\n      fputc(10,_stderr);\n    }\n    iVar4 \u003d (iVar4 + 1) % 0x10;\n  } while (saved_stabs_index !\u003d iVar4);\n  return param_3;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [
        "fprintf",
        "fwrite",
        "fputc",
        "dcgettext",
        "bfd_get_stab_name"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "convert_efi_target": {
      "entrypoint": "0x00108c86",
      "current_name": "convert_efi_target",
      "code": "\nundefined8 convert_efi_target(long *param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  size_t sVar3;\n  undefined2 *puVar4;\n  long lVar5;\n  char *__s;\n  char *__s1;\n  undefined2 *puVar6;\n  undefined8 uVar7;\n  byte bVar8;\n  \n  bVar8 \u003d 0;\n  lVar5 \u003d *param_1;\n  __s \u003d (char *)(lVar5 + 4);\n  cVar1 \u003d startswith_lto_priv_0_lto_priv_0(__s,\u0026DAT_0011b73b);\n  if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n    cVar1 \u003d startswith_lto_priv_0_lto_priv_0(__s,\"bsdrv-\");\n    if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n      cVar1 \u003d startswith_lto_priv_0_lto_priv_0(__s,\"rtdrv-\");\n      if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n        return 0xffffffff;\n      }\n      __s \u003d (char *)(lVar5 + 6);\n      uVar7 \u003d 0xc;\n    }\n    else {\n      __s \u003d (char *)(lVar5 + 6);\n      uVar7 \u003d 0xb;\n    }\n  }\n  else {\n    uVar7 \u003d 10;\n  }\n  sVar3 \u003d strlen(__s);\n  puVar4 \u003d (undefined2 *)xmalloc(sVar3 + 8);\n  __s1 \u003d __s + 4;\n  puVar6 \u003d puVar4;\n  for (lVar5 \u003d sVar3 + 1; lVar5 !\u003d 0; lVar5 \u003d lVar5 + -1) {\n    *(char *)puVar6 \u003d *__s;\n    __s \u003d __s + (ulong)bVar8 * -2 + 1;\n    puVar6 \u003d (undefined2 *)((long)puVar6 + (ulong)bVar8 * -2 + 1);\n  }\n  *(undefined *)(puVar4 + 1) \u003d 0x69;\n  *puVar4 \u003d 0x6570;\n  iVar2 \u003d strcmp(__s1,\"ia32\");\n  if (iVar2 \u003d\u003d 0) {\n    *(undefined *)((long)puVar4 + 7) \u003d 0x36;\n    *(undefined2 *)((long)puVar4 + 5) \u003d 0x3833;\n  }\n  else {\n    iVar2 \u003d strcmp(__s1,\"x86_64\");\n    if (iVar2 \u003d\u003d 0) {\n      *(undefined *)((long)puVar4 + 7) \u003d 0x2d;\n    }\n    else {\n      iVar2 \u003d strcmp(__s1,\"aarch64\");\n      if (iVar2 \u003d\u003d 0) {\n        *(undefined8 *)((long)puVar4 + 0xb) \u003d 0x656c7474696c2d;\n      }\n    }\n  }\n  *param_1 \u003d (long)puVar4;\n  return uVar7;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "strlen",
        "startswith.lto_priv.0.lto_priv.0",
        "strcmp",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "add_redefine_and_check": {
      "entrypoint": "0x00108d9a",
      "current_name": "add_redefine_and_check",
      "code": "\nundefined8 add_redefine_and_check(undefined8 param_1,char *param_2,char *param_3,undefined8 param_4)\n\n{\n  char **ppcVar1;\n  char *pcVar2;\n  long lVar3;\n  undefined8 uVar4;\n  long *plVar5;\n  \n  ppcVar1 \u003d (char **)xmalloc(0x10);\n  pcVar2 \u003d strdup(param_2);\n  *ppcVar1 \u003d pcVar2;\n  pcVar2 \u003d strdup(param_3);\n  uVar4 \u003d redefine_specific_htab;\n  ppcVar1[1] \u003d pcVar2;\n  lVar3 \u003d htab_find(uVar4,ppcVar1);\n  if (lVar3 !\u003d 0) {\n    uVar4 \u003d dcgettext(0,\"%s: Multiple redefinition of symbol \\\"%s\\\"\",5);\n                    \n    fatal(uVar4,param_1,param_2);\n  }\n  lVar3 \u003d htab_find(redefine_specific_reverse_htab,param_3);\n  if (lVar3 !\u003d 0) {\n    uVar4 \u003d dcgettext(0,\"%s: Symbol \\\"%s\\\" is target of more than one redefinition\",5);\n                    \n    fatal(uVar4,param_1,param_3);\n  }\n  plVar5 \u003d (long *)htab_find_slot(redefine_specific_htab,ppcVar1,1);\n  uVar4 \u003d redefine_specific_reverse_htab;\n  *plVar5 \u003d (long)ppcVar1;\n  pcVar2 \u003d ppcVar1[1];\n  ppcVar1 \u003d (char **)htab_find_slot(uVar4,pcVar2,1);\n  *ppcVar1 \u003d pcVar2;\n  return param_4;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "htab_find",
        "dcgettext",
        "fatal",
        "htab_find_slot",
        "xmalloc",
        "strdup"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_demangle_count": {
      "entrypoint": "0x00108e76",
      "current_name": "stab_demangle_count",
      "code": "\nint stab_demangle_count(byte **param_1)\n\n{\n  byte bVar1;\n  int iVar2;\n  \n  iVar2 \u003d 0;\n  while( true ) {\n    bVar1 \u003d **param_1;\n    if (((\u0026_sch_istable)[(ulong)bVar1 * 2] \u0026 4) \u003d\u003d 0) break;\n    *param_1 \u003d *param_1 + 1;\n    iVar2 \u003d iVar2 * 10 + -0x30 + (int)(char)bVar1;\n  }\n  return iVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "stab_demangle_template",
        "stab_demangle_qualified",
        "parse_stab_type"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_demangle_get_count": {
      "entrypoint": "0x00108ea1",
      "current_name": "stab_demangle_get_count",
      "code": "\nulong stab_demangle_get_count(byte **param_1,int *param_2)\n\n{\n  int iVar1;\n  byte *pbVar2;\n  byte *pbVar3;\n  ulong uVar4;\n  \n  pbVar2 \u003d *param_1;\n  uVar4 \u003d 0;\n  if (((\u0026_sch_istable)[(ulong)*pbVar2 * 2] \u0026 4) !\u003d 0) {\n    pbVar3 \u003d pbVar2 + 1;\n    iVar1 \u003d (char)*pbVar2 + -0x30;\n    *param_2 \u003d iVar1;\n    *param_1 \u003d pbVar3;\n    if (((\u0026_sch_istable)[(ulong)pbVar2[1] * 2] \u0026 4) !\u003d 0) {\n      do {\n        pbVar2 \u003d pbVar3;\n        iVar1 \u003d iVar1 * 10 + -0x30 + (int)(char)*pbVar2;\n        pbVar3 \u003d pbVar2 + 1;\n      } while (((\u0026_sch_istable)[(ulong)pbVar2[1] * 2] \u0026 4) !\u003d 0);\n      if (pbVar2[1] \u003d\u003d 0x5f) {\n        pbVar3 \u003d pbVar2 + 2;\n        *param_1 \u003d pbVar3;\n        *param_2 \u003d iVar1;\n      }\n    }\n    uVar4 \u003d CONCAT71((int7)((ulong)pbVar3 \u003e\u003e 8),1);\n  }\n  return uVar4 \u0026 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "stab_demangle_template",
        "stab_demangle_args"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_end_function.lto_priv.0": {
      "entrypoint": "0x00108f05",
      "current_name": "stab_end_function.lto_priv.0",
      "code": "\nundefined stab_end_function_lto_priv_0(void)\n\n{\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_name.constprop.0"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_start_source": {
      "entrypoint": "0x00108f08",
      "current_name": "debug_start_source",
      "code": "\n\n\nundefined8 debug_start_source(long param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 *puVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  undefined8 *puVar6;\n  char *pcVar7;\n  undefined8 *puVar8;\n  byte bVar9;\n  \n  bVar9 \u003d 0;\n  pcVar7 \u003d \"\";\n  if (param_2 !\u003d (char *)0x0) {\n    pcVar7 \u003d param_2;\n  }\n  if (*(long *)(param_1 + 8) \u003d\u003d 0) {\n    uVar2 \u003d dcgettext(0,\"debug_start_source: no debug_set_filename call\",5);\n    fprintf(_stderr,\"%s\\n\",uVar2);\n    uVar2 \u003d 0;\n  }\n  else {\n    for (puVar3 \u003d *(undefined8 **)(*(long *)(param_1 + 8) + 8); puVar3 !\u003d (undefined8 *)0x0;\n        puVar3 \u003d (undefined8 *)*puVar3) {\n      iVar1 \u003d filename_cmp(puVar3[1],pcVar7);\n      if (iVar1 \u003d\u003d 0) goto LAB_00108fad;\n    }\n    puVar3 \u003d (undefined8 *)xmalloc(0x18);\n    puVar6 \u003d *(undefined8 **)(param_1 + 0x10);\n    puVar8 \u003d puVar3;\n    for (lVar5 \u003d 6; lVar5 !\u003d 0; lVar5 \u003d lVar5 + -1) {\n      *(undefined4 *)puVar8 \u003d 0;\n      puVar8 \u003d (undefined8 *)((long)puVar8 + (ulong)bVar9 * -8 + 4);\n    }\n    puVar3[1] \u003d pcVar7;\n    puVar8 \u003d (undefined8 *)*puVar6;\n    while (puVar4 \u003d puVar8, puVar4 !\u003d (undefined8 *)0x0) {\n      puVar6 \u003d puVar4;\n      puVar8 \u003d (undefined8 *)*puVar4;\n    }\n    *puVar6 \u003d puVar3;\nLAB_00108fad:\n    *(undefined8 **)(param_1 + 0x10) \u003d puVar3;\n    uVar2 \u003d 1;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_stab"
      ],
      "called": [
        "fprintf",
        "dcgettext",
        "filename_cmp",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bad_stab": {
      "entrypoint": "0x00108fb9",
      "current_name": "bad_stab",
      "code": "\n\n\nvoid bad_stab(undefined8 param_1)\n\n{\n  char *__format;\n  \n  __format \u003d (char *)dcgettext(0,\"Bad stab: %s\\n\",5);\n  fprintf(_stderr,__format,param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_stab_type_number",
        "parse_stab",
        "parse_stab_type"
      ],
      "called": [
        "fprintf",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "warn_stab": {
      "entrypoint": "0x00108fe8",
      "current_name": "warn_stab",
      "code": "\n\n\nvoid warn_stab(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 in_RAX;\n  char *__format;\n  \n  __format \u003d (char *)dcgettext(0,\"Warning: %s: %s\\n\",5);\n  fprintf(_stderr,__format,param_2,param_1,in_RAX);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_number",
        "parse_stab",
        "parse_stab_type"
      ],
      "called": [
        "fprintf",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_find_slot": {
      "entrypoint": "0x00109022",
      "current_name": "stab_find_slot",
      "code": "\n\n\nundefined  [16] stab_find_slot(long param_1,uint *param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  uint uVar1;\n  char *pcVar2;\n  long *plVar3;\n  long lVar4;\n  uint uVar5;\n  long **pplVar6;\n  byte bVar7;\n  undefined auVar8 [16];\n  \n  bVar7 \u003d 0;\n  uVar5 \u003d *param_2;\n  uVar1 \u003d param_2[1];\n  if (((int)uVar5 \u003c 0) || (*(uint *)(param_1 + 0x80) \u003c\u003d uVar5)) {\n    pcVar2 \u003d (char *)dcgettext(0,\"Type file number %d out of range\\n\",5);\n    fprintf(_stderr,pcVar2,(ulong)uVar5);\n  }\n  else {\n    if (-1 \u003c (int)uVar1) {\n      pplVar6 \u003d (long **)(*(long *)(param_1 + 0x88) + (long)(int)uVar5 * 8);\n      for (uVar5 \u003d uVar1; 0xf \u003c (int)uVar5; uVar5 \u003d uVar5 - 0x10) {\n        if (*pplVar6 \u003d\u003d (long *)0x0) {\n          plVar3 \u003d (long *)xmalloc(0x88);\n          *pplVar6 \u003d plVar3;\n          for (lVar4 \u003d 0x22; lVar4 !\u003d 0; lVar4 \u003d lVar4 + -1) {\n            *(undefined4 *)plVar3 \u003d 0;\n            plVar3 \u003d (long *)((long)plVar3 + (ulong)bVar7 * -8 + 4);\n          }\n        }\n        pplVar6 \u003d (long **)*pplVar6;\n      }\n      if (*pplVar6 \u003d\u003d (long *)0x0) {\n        plVar3 \u003d (long *)xmalloc(0x88);\n        *pplVar6 \u003d plVar3;\n        for (lVar4 \u003d 0x22; lVar4 !\u003d 0; lVar4 \u003d lVar4 + -1) {\n          *(undefined4 *)plVar3 \u003d 0;\n          plVar3 \u003d (long *)((long)plVar3 + (ulong)bVar7 * -8 + 4);\n        }\n      }\n      plVar3 \u003d *pplVar6 + (long)(int)((uVar1 \u003e\u003e 4) * -0x10 + uVar1) + 1;\n      goto LAB_00109117;\n    }\n    pcVar2 \u003d (char *)dcgettext(0,\"Type index number %d out of range\\n\",5);\n    fprintf(_stderr,pcVar2,(ulong)uVar1);\n  }\n  plVar3 \u003d (long *)0x0;\nLAB_00109117:\n  auVar8._8_8_ \u003d param_4;\n  auVar8._0_8_ \u003d plVar3;\n  return auVar8;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_find_type",
        "parse_stab_type"
      ],
      "called": [
        "fprintf",
        "dcgettext",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_bad_demangle": {
      "entrypoint": "0x0010911f",
      "current_name": "stab_bad_demangle",
      "code": "\n\n\nvoid stab_bad_demangle(undefined8 param_1)\n\n{\n  char *__format;\n  \n  __format \u003d (char *)dcgettext(0,\"bad mangled name `%s\\\u0027\\n\",5);\n  fprintf(_stderr,__format,param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "stab_demangle_template",
        "stab_demangle_args",
        "stab_demangle_qualified",
        "parse_stab_type"
      ],
      "called": [
        "fprintf",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_find_named_type": {
      "entrypoint": "0x0010914e",
      "current_name": "debug_find_named_type",
      "code": "\n\n\nundefined  [16]\ndebug_find_named_type(long param_1,char *param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  long lVar1;\n  int iVar2;\n  undefined8 uVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  undefined8 *puVar6;\n  undefined auVar7 [16];\n  \n  lVar1 \u003d *(long *)(param_1 + 8);\n  if (lVar1 \u003d\u003d 0) {\n    uVar3 \u003d dcgettext(0,\"debug_find_named_type: no current compilation unit\",5);\n    fprintf(_stderr,\"%s\\n\",uVar3);\n  }\n  else {\n    for (lVar5 \u003d *(long *)(param_1 + 0x20); lVar5 !\u003d 0; lVar5 \u003d *(long *)(lVar5 + 8)) {\n      if (*(undefined8 **)(lVar5 + 0x28) !\u003d (undefined8 *)0x0) {\n        for (puVar4 \u003d (undefined8 *)**(undefined8 **)(lVar5 + 0x28); puVar4 !\u003d (undefined8 *)0x0;\n            puVar4 \u003d (undefined8 *)*puVar4) {\n          if (*(int *)((long)puVar4 + 0x14) \u003d\u003d 0) {\n            if (*(char *)puVar4[1] \u003d\u003d *param_2) {\n              iVar2 \u003d strcmp((char *)puVar4[1],param_2);\n              if (iVar2 \u003d\u003d 0) goto LAB_00109216;\n            }\n          }\n        }\n      }\n    }\n    for (puVar6 \u003d *(undefined8 **)(lVar1 + 8); puVar6 !\u003d (undefined8 *)0x0;\n        puVar6 \u003d (undefined8 *)*puVar6) {\n      if ((undefined8 *)puVar6[2] !\u003d (undefined8 *)0x0) {\n        for (puVar4 \u003d *(undefined8 **)(undefined8 *)puVar6[2]; puVar4 !\u003d (undefined8 *)0x0;\n            puVar4 \u003d (undefined8 *)*puVar4) {\n          if (*(int *)((long)puVar4 + 0x14) \u003d\u003d 0) {\n            if (*(char *)puVar4[1] \u003d\u003d *param_2) {\n              iVar2 \u003d strcmp((char *)puVar4[1],param_2);\n              if (iVar2 \u003d\u003d 0) goto LAB_00109216;\n            }\n          }\n        }\n      }\n    }\n  }\n  uVar3 \u003d 0;\nLAB_00109223:\n  auVar7._8_8_ \u003d param_4;\n  auVar7._0_8_ \u003d uVar3;\n  return auVar7;\nLAB_00109216:\n  uVar3 \u003d puVar4[4];\n  goto LAB_00109223;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "stab_demangle_qualified",
        "parse_stab_type"
      ],
      "called": [
        "fprintf",
        "dcgettext",
        "strcmp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_type_samep": {
      "entrypoint": "0x0010922b",
      "current_name": "debug_type_samep",
      "code": "\nbyte debug_type_samep(long param_1,long *param_2,long *param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  long **pplVar3;\n  char **ppcVar4;\n  char **ppcVar5;\n  long lVar6;\n  long lVar7;\n  long lVar8;\n  char *pcVar9;\n  char *pcVar10;\n  char cVar11;\n  byte bVar12;\n  int iVar13;\n  undefined8 uVar14;\n  undefined8 uVar15;\n  undefined8 *puVar16;\n  undefined8 *puVar17;\n  long *plVar18;\n  long lVar19;\n  long *plVar20;\n  long *plVar21;\n  long lVar22;\n  long *local_70;\n  undefined8 *local_58;\n  long *plStack_50;\n  long *local_48;\n  \n  plVar18 \u003d param_3;\n  if (param_2 \u003d\u003d (long *)0x0) {\nLAB_00109241:\n    return param_3 \u003d\u003d (long *)0x0;\n  }\njoined_r0x00109255:\n  if (plVar18 \u003d\u003d (long *)0x0) {\n    return false;\n  }\n  while( true ) {\n    uVar1 \u003d *(uint *)param_2;\n    if (uVar1 \u003d\u003d 1) goto code_r0x00109263;\n    while (uVar2 \u003d *(uint *)param_3, uVar2 \u003d\u003d 1) {\n      param_3 \u003d **(long ***)param_3[2];\n      if (param_3 \u003d\u003d (long *)0x0) {\n        return false;\n      }\n    }\n    if (param_2 \u003d\u003d param_3) {\n      return true;\n    }\n    if (uVar1 !\u003d 0x16) break;\n    if (uVar2 !\u003d 0x17) goto LAB_001092cb;\n    param_2 \u003d *(long **)(param_2[2] + 8);\n    if (param_2 \u003d\u003d (long *)0x0) goto LAB_00109241;\n  }\n  if ((uVar1 \u003d\u003d 0x17) \u0026\u0026 (uVar2 \u003d\u003d 0x16)) {\n    param_3 \u003d *(long **)(param_3[2] + 8);\n    plVar18 \u003d param_3;\n    goto joined_r0x00109255;\n  }\nLAB_001092cb:\n  if (*param_2 !\u003d *param_3) {\n    return false;\n  }\n  if (uVar1 \u003d\u003d 3) {\n    return *(char *)(param_2 + 2) \u003d\u003d *(char *)(param_3 + 2);\n  }\n  if (uVar1 \u003c 4) {\n    if (uVar1 \u003d\u003d 2) {\n      return true;\n    }\n  }\n  else if (uVar1 - 4 \u003c 3) {\n    return true;\n  }\n  local_58 \u003d *(undefined8 **)(param_1 + 0x58);\n  for (puVar17 \u003d local_58; puVar17 !\u003d (undefined8 *)0x0; puVar17 \u003d (undefined8 *)*puVar17) {\n    if (((long *)puVar17[1] \u003d\u003d param_2) \u0026\u0026 ((long *)puVar17[2] \u003d\u003d param_3)) {\n      return true;\n    }\n  }\n  *(undefined8 ***)(param_1 + 0x58) \u003d \u0026local_58;\n  plStack_50 \u003d param_2;\n  local_48 \u003d param_3;\n  switch(uVar1) {\n  case 7:\n  case 8:\n  case 9:\n  case 10:\n    plVar18 \u003d (long *)param_2[2];\n    pplVar3 \u003d (long **)param_3[2];\n    if (plVar18 \u003d\u003d (long *)0x0) {\n      bVar12 \u003d pplVar3 \u003d\u003d (long **)0x0;\n      goto LAB_001099c4;\n    }\n    if (pplVar3 \u003d\u003d (long **)0x0) goto LAB_00109382;\n    if ((*(uint *)(param_1 + 0x38) \u003c *(uint *)((long)plVar18 + 0xc)) \u0026\u0026\n       (*(uint *)((long)plVar18 + 0xc) \u003d\u003d *(uint *)((long)pplVar3 + 0xc))) goto LAB_001097af;\n    puVar17 \u003d (undefined8 *)*plVar18;\n    local_70 \u003d *pplVar3;\n    if (((puVar17 \u003d\u003d (undefined8 *)0x0) \u003d\u003d (local_70 \u003d\u003d (long *)0x0)) \u0026\u0026\n       ((((plVar18[2] \u003d\u003d 0) \u003d\u003d (pplVar3[2] \u003d\u003d (long *)0x0) \u0026\u0026\n         ((plVar18[3] \u003d\u003d 0) \u003d\u003d (pplVar3[3] \u003d\u003d (long *)0x0))) \u0026\u0026\n        ((plVar18[4] \u003d\u003d 0) \u003d\u003d (pplVar3[4] \u003d\u003d (long *)0x0))))) {\n      if (puVar17 \u003d\u003d (undefined8 *)0x0) {\nLAB_001093fd:\n        if ((plVar18[4] !\u003d 0) \u0026\u0026\n           (cVar11 \u003d debug_type_samep(param_1,plVar18[4],pplVar3[4]), cVar11 \u003d\u003d \u0027\\0\u0027))\n        goto LAB_00109382;\n        plVar21 \u003d (long *)plVar18[2];\n        if (plVar21 \u003d\u003d (long *)0x0) {\nLAB_00109540:\n          puVar17 \u003d (undefined8 *)plVar18[3];\n          if (puVar17 \u003d\u003d (undefined8 *)0x0) goto LAB_001097af;\n          plVar18 \u003d pplVar3[3];\n          while( true ) {\n            ppcVar5 \u003d (char **)*puVar17;\n            if (ppcVar5 \u003d\u003d (char **)0x0) {\n              bVar12 \u003d *plVar18 \u003d\u003d 0;\n              goto LAB_001099c4;\n            }\n            ppcVar4 \u003d (char **)*plVar18;\n            if (ppcVar4 \u003d\u003d (char **)0x0) break;\n            if ((**ppcVar5 !\u003d **ppcVar4) || (iVar13 \u003d strcmp(*ppcVar5,*ppcVar4), iVar13 !\u003d 0))\n            break;\n            pcVar9 \u003d ppcVar5[1];\n            pcVar10 \u003d ppcVar4[1];\n            if ((pcVar9 \u003d\u003d (char *)0x0) !\u003d (pcVar10 \u003d\u003d (char *)0x0)) break;\n            if (pcVar9 !\u003d (char *)0x0) {\n              lVar22 \u003d 0;\n              while( true ) {\n                ppcVar5 \u003d *(char ***)(pcVar9 + lVar22);\n                ppcVar4 \u003d *(char ***)(pcVar10 + lVar22);\n                if (ppcVar5 \u003d\u003d (char **)0x0) break;\n                if (ppcVar4 \u003d\u003d (char **)0x0) goto LAB_00109382;\n                if ((((**ppcVar5 !\u003d **ppcVar4) ||\n                     ((((ulong)ppcVar5[2] ^ (ulong)ppcVar4[2]) \u0026 0xffffffffffff) !\u003d 0)) ||\n                    ((ppcVar5[3] !\u003d ppcVar4[3] ||\n                     ((((ppcVar5[4] \u003d\u003d (char *)0x0) !\u003d (ppcVar4[4] \u003d\u003d (char *)0x0) ||\n                       (iVar13 \u003d strcmp(*ppcVar5,*ppcVar4), iVar13 !\u003d 0)) ||\n                      (cVar11 \u003d debug_type_samep(param_1,ppcVar5[1],ppcVar4[1]), cVar11 \u003d\u003d \u0027\\0\u0027)))))\n                    ) || ((ppcVar5[4] !\u003d (char *)0x0 \u0026\u0026\n                          (cVar11 \u003d debug_type_samep(param_1,ppcVar5[4],ppcVar4[4]), cVar11 \u003d\u003d \u0027\\0\u0027)\n                          ))) goto LAB_00109382;\n                lVar22 \u003d lVar22 + 8;\n              }\n              if (ppcVar4 \u003d\u003d (char **)0x0) goto LAB_001095f1;\n              break;\n            }\nLAB_001095f1:\n            puVar17 \u003d puVar17 + 1;\n            plVar18 \u003d plVar18 + 1;\n          }\n        }\n        else {\n          plVar20 \u003d pplVar3[2];\n          for (; puVar17 \u003d (undefined8 *)*plVar21, puVar17 !\u003d (undefined8 *)0x0;\n              plVar21 \u003d plVar21 + 1) {\n            puVar16 \u003d (undefined8 *)*plVar20;\n            if ((((puVar16 \u003d\u003d (undefined8 *)0x0) ||\n                 (((puVar17[1] ^ puVar16[1]) \u0026 0xffffffffff) !\u003d 0)) ||\n                (*(int *)(puVar17 + 2) !\u003d *(int *)(puVar16 + 2))) ||\n               (cVar11 \u003d debug_type_samep(param_1,*puVar17,*puVar16), cVar11 \u003d\u003d \u0027\\0\u0027))\n            goto LAB_00109382;\n            plVar20 \u003d plVar20 + 1;\n          }\n          if (*plVar20 \u003d\u003d 0) goto LAB_00109540;\n        }\n      }\n      else {\n        for (; ppcVar5 \u003d (char **)*puVar17, ppcVar5 !\u003d (char **)0x0; puVar17 \u003d puVar17 + 1) {\n          ppcVar4 \u003d (char **)*local_70;\n          if (ppcVar4 \u003d\u003d (char **)0x0) goto LAB_00109382;\n          pcVar9 \u003d *ppcVar4;\n          pcVar10 \u003d *ppcVar5;\n          if ((*pcVar10 !\u003d *pcVar9) ||\n             ((((ulong)ppcVar5[2] ^ (ulong)ppcVar4[2]) \u0026 0xffffffffff) !\u003d 0)) goto LAB_00109382;\n          if (*(char *)((long)ppcVar5 + 0x14) \u003d\u003d \u0027\\0\u0027) {\n            if (ppcVar5[3] \u003d\u003d ppcVar4[3]) goto LAB_00109480;\n            goto LAB_00109382;\n          }\n          iVar13 \u003d strcmp(ppcVar5[3],ppcVar4[3]);\n          if (iVar13 !\u003d 0) goto LAB_00109382;\nLAB_00109480:\n          iVar13 \u003d strcmp(pcVar10,pcVar9);\n          if (((iVar13 !\u003d 0) || (ppcVar5[1] \u003d\u003d (char *)0x0)) || (ppcVar4[1] \u003d\u003d (char *)0x0))\n          goto LAB_00109382;\n          uVar14 \u003d debug_get_real_type_isra_0(ppcVar4[1],0);\n          uVar15 \u003d debug_get_real_type_isra_0(ppcVar5[1],0);\n          cVar11 \u003d debug_type_samep(param_1,uVar15,uVar14);\n          if (cVar11 \u003d\u003d \u0027\\0\u0027) goto LAB_00109382;\n          local_70 \u003d local_70 + 1;\n        }\n        if (*local_70 \u003d\u003d 0) goto LAB_001093fd;\n      }\n    }\n    goto LAB_00109382;\n  case 0xb:\n    plVar18 \u003d (long *)param_2[2];\n    plVar21 \u003d (long *)param_3[2];\n    if (plVar18 \u003d\u003d (long *)0x0) {\n      bVar12 \u003d plVar21 \u003d\u003d (long *)0x0;\n      goto LAB_001099c4;\n    }\n    if (plVar21 \u003d\u003d (long *)0x0) goto LAB_00109382;\n    lVar22 \u003d *plVar18;\n    lVar6 \u003d *plVar21;\n    lVar19 \u003d 0;\n    lVar7 \u003d plVar18[1];\n    lVar8 \u003d plVar21[1];\n    do {\n      pcVar9 \u003d *(char **)(lVar22 + lVar19);\n      if (pcVar9 \u003d\u003d (char *)0x0) {\n        bVar12 \u003d *(long *)(lVar6 + lVar19) \u003d\u003d 0;\n        goto LAB_001099c1;\n      }\n      pcVar10 \u003d *(char **)(lVar6 + lVar19);\n      if (((pcVar10 \u003d\u003d (char *)0x0) || (*pcVar9 !\u003d *pcVar10)) ||\n         (*(long *)(lVar7 + lVar19) !\u003d *(long *)(lVar8 + lVar19))) break;\n      iVar13 \u003d strcmp(pcVar9,pcVar10);\n      lVar19 \u003d lVar19 + 8;\n    } while (iVar13 \u003d\u003d 0);\nLAB_00109964:\n    bVar12 \u003d 0;\n    break;\n  case 0xc:\n  case 0xe:\n  case 0x14:\n  case 0x15:\n    bVar12 \u003d debug_type_samep(param_1,param_2[2],param_3[2]);\n    goto LAB_001099c4;\n  case 0xd:\n    if ((*(char *)((undefined8 *)param_2[2] + 2) \u003d\u003d *(char *)((undefined8 *)param_3[2] + 2)) \u0026\u0026\n       (cVar11 \u003d debug_type_samep(param_1,*(undefined8 *)param_2[2],*(undefined8 *)param_3[2]),\n       cVar11 !\u003d \u0027\\0\u0027)) {\n      plVar18 \u003d *(long **)(param_2[2] + 8);\n      plVar21 \u003d *(long **)(param_3[2] + 8);\n      if ((plVar18 \u003d\u003d (long *)0x0) \u003d\u003d (plVar21 \u003d\u003d (long *)0x0)) {\n        if (plVar18 \u003d\u003d (long *)0x0) goto LAB_001097af;\n        while (((*plVar18 !\u003d 0 \u0026\u0026 (*plVar21 !\u003d 0)) \u0026\u0026\n               (cVar11 \u003d debug_type_samep(param_1), cVar11 !\u003d \u0027\\0\u0027))) {\n          plVar18 \u003d plVar18 + 1;\n          plVar21 \u003d plVar21 + 1;\n        }\nLAB_0010995d:\n        if (*plVar18 !\u003d 0) goto LAB_00109964;\n        bVar12 \u003d *plVar21 \u003d\u003d 0;\n        break;\n      }\n    }\n    goto LAB_00109382;\n  case 0xf:\n    puVar17 \u003d (undefined8 *)param_3[2];\n    puVar16 \u003d (undefined8 *)param_2[2];\n    bVar12 \u003d 0;\n    if ((puVar16[1] \u003d\u003d puVar17[1]) \u0026\u0026 (puVar16[2] \u003d\u003d puVar17[2])) {\nLAB_00109862:\n      bVar12 \u003d debug_type_samep(param_1,*puVar16,*puVar17);\n    }\n    break;\n  case 0x10:\n    puVar17 \u003d (undefined8 *)param_3[2];\n    puVar16 \u003d (undefined8 *)param_2[2];\n    bVar12 \u003d 0;\n    if (((puVar16[2] \u003d\u003d puVar17[2]) \u0026\u0026 (puVar16[3] \u003d\u003d puVar17[3])) \u0026\u0026\n       (*(char *)(puVar16 + 4) \u003d\u003d *(char *)(puVar17 + 4))) goto LAB_00109862;\n    break;\n  case 0x11:\n    puVar17 \u003d (undefined8 *)param_3[2];\n    puVar16 \u003d (undefined8 *)param_2[2];\n    bVar12 \u003d 0;\n    if (*(char *)(puVar16 + 1) \u003d\u003d *(char *)(puVar17 + 1)) goto LAB_00109862;\n    break;\n  case 0x12:\n    cVar11 \u003d debug_type_samep(param_1,*(undefined8 *)param_2[2],*(undefined8 *)param_3[2]);\n    bVar12 \u003d 0;\n    if (cVar11 !\u003d \u0027\\0\u0027) {\n      bVar12 \u003d debug_type_samep(param_1,*(undefined8 *)(param_2[2] + 8),\n                                *(undefined8 *)(param_3[2] + 8));\n    }\n    break;\n  case 0x13:\n    if (((*(char *)((undefined8 *)param_2[2] + 3) \u003d\u003d *(char *)((undefined8 *)param_3[2] + 3)) \u0026\u0026\n        (cVar11 \u003d debug_type_samep(param_1,*(undefined8 *)param_2[2],*(undefined8 *)param_3[2]),\n        cVar11 !\u003d \u0027\\0\u0027)) \u0026\u0026\n       (cVar11 \u003d debug_type_samep(param_1,*(undefined8 *)(param_2[2] + 8),\n                                  *(undefined8 *)(param_3[2] + 8)), cVar11 !\u003d \u0027\\0\u0027)) {\n      plVar18 \u003d *(long **)(param_2[2] + 0x10);\n      plVar21 \u003d *(long **)(param_3[2] + 0x10);\n      if ((plVar18 \u003d\u003d (long *)0x0) \u003d\u003d (plVar21 \u003d\u003d (long *)0x0)) {\n        if (plVar18 !\u003d (long *)0x0) {\n          while (((*plVar18 !\u003d 0 \u0026\u0026 (*plVar21 !\u003d 0)) \u0026\u0026\n                 (cVar11 \u003d debug_type_samep(param_1), cVar11 !\u003d \u0027\\0\u0027))) {\n            plVar18 \u003d plVar18 + 1;\n            plVar21 \u003d plVar21 + 1;\n          }\n          goto LAB_0010995d;\n        }\nLAB_001097af:\n        bVar12 \u003d 1;\n        goto LAB_001099c4;\n      }\n    }\nLAB_00109382:\n    bVar12 \u003d 0;\n    goto LAB_001099c4;\n  case 0x16:\n  case 0x17:\n    plVar18 \u003d (long *)param_3[2];\n    plVar21 \u003d (long *)param_2[2];\n    iVar13 \u003d strcmp(*(char **)(*plVar21 + 8),*(char **)(*plVar18 + 8));\n    bVar12 \u003d 0;\n    if (iVar13 \u003d\u003d 0) {\n      bVar12 \u003d debug_type_samep(param_1,plVar21[1],plVar18[1]);\n    }\n    break;\n  default:\n                    \n    abort();\n  }\nLAB_001099c1:\n  bVar12 \u003d bVar12 \u0026 1;\nLAB_001099c4:\n  *(undefined8 **)(param_1 + 0x58) \u003d local_58;\n  return bVar12;\ncode_r0x00109263:\n  param_2 \u003d **(long ***)param_2[2];\n  plVar18 \u003d param_2;\n  goto joined_r0x00109255;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_type_samep",
        "debug_set_class_id.lto_priv.0"
      ],
      "called": [
        "debug_type_samep",
        "debug_get_real_type.isra.0",
        "strcmp",
        "abort"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "savestring": {
      "entrypoint": "0x00109a0b",
      "current_name": "savestring",
      "code": "\nvoid savestring(undefined *param_1,int param_2)\n\n{\n  undefined *puVar1;\n  long lVar2;\n  undefined *puVar3;\n  byte bVar4;\n  \n  bVar4 \u003d 0;\n  puVar1 \u003d (undefined *)xmalloc((long)(param_2 + 1));\n  puVar3 \u003d puVar1;\n  for (lVar2 \u003d (long)param_2; lVar2 !\u003d 0; lVar2 \u003d lVar2 + -1) {\n    *puVar3 \u003d *param_1;\n    param_1 \u003d param_1 + (ulong)bVar4 * -2 + 1;\n    puVar3 \u003d puVar3 + (ulong)bVar4 * -2 + 1;\n  }\n  puVar1[param_2] \u003d 0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "parse_stab",
        "stab_find_tagged_type",
        "stab_demangle_template",
        "stab_demangle_qualified",
        "parse_stab_type"
      ],
      "called": [
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "parse_number": {
      "entrypoint": "0x00109a32",
      "current_name": "parse_number",
      "code": "\nundefined  [16]\nparse_number(char **param_1,undefined *param_2,char *param_3,undefined8 param_4,undefined8 param_5)\n\n{\n  char *__nptr;\n  int *piVar1;\n  ulong uVar2;\n  undefined8 uVar3;\n  undefined auVar4 [16];\n  \n  if (param_2 !\u003d (undefined *)0x0) {\n    *param_2 \u003d 0;\n  }\n  __nptr \u003d *param_1;\n  if ((__nptr \u003c param_3) \u0026\u0026 (*__nptr !\u003d \u0027\\0\u0027)) {\n    piVar1 \u003d __errno_location();\n    *piVar1 \u003d 0;\n    uVar2 \u003d strtoul(__nptr,param_1,0);\n    if ((uVar2 !\u003d 0xffffffffffffffff) || (*piVar1 \u003d\u003d 0)) goto LAB_00109aa9;\n    if (param_2 \u003d\u003d (undefined *)0x0) {\n      uVar3 \u003d dcgettext(0,\"numeric overflow\",5);\n      warn_stab(__nptr,uVar3);\n    }\n    else {\n      *param_2 \u003d 1;\n    }\n  }\n  uVar2 \u003d 0;\nLAB_00109aa9:\n  auVar4._8_8_ \u003d param_5;\n  auVar4._0_8_ \u003d uVar2;\n  return auVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_stab_type_number",
        "parse_stab_type"
      ],
      "called": [
        "strtoul",
        "dcgettext",
        "warn_stab",
        "__errno_location"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "parse_stab_type_number": {
      "entrypoint": "0x00109ab1",
      "current_name": "parse_stab_type_number",
      "code": "\nundefined  [16]\nparse_stab_type_number\n          (char **param_1,undefined4 *param_2,undefined8 param_3,undefined8 param_4,\n          undefined8 param_5)\n\n{\n  undefined4 uVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  undefined auVar4 [16];\n  \n  pcVar2 \u003d *param_1;\n  if (*pcVar2 \u003d\u003d \u0027(\u0027) {\n    *param_1 \u003d pcVar2 + 1;\n    uVar1 \u003d parse_number(param_1,0);\n    *param_2 \u003d uVar1;\n    if (**param_1 \u003d\u003d \u0027,\u0027) {\n      *param_1 \u003d *param_1 + 1;\n      uVar1 \u003d parse_number(param_1,0,param_3);\n      param_2[1] \u003d uVar1;\n      if (**param_1 \u003d\u003d \u0027)\u0027) {\n        pcVar2 \u003d *param_1 + 1;\n        *param_1 \u003d pcVar2;\n        goto LAB_00109b25;\n      }\n    }\n    bad_stab(pcVar2);\n    uVar3 \u003d 0;\n  }\n  else {\n    *param_2 \u003d 0;\n    pcVar2 \u003d (char *)parse_number(param_1,0);\n    param_2[1] \u003d (int)pcVar2;\nLAB_00109b25:\n    uVar3 \u003d CONCAT71((int7)((ulong)pcVar2 \u003e\u003e 8),1);\n  }\n  auVar4._8_8_ \u003d param_5;\n  auVar4._0_8_ \u003d uVar3;\n  return auVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_stab_type"
      ],
      "called": [
        "parse_number",
        "bad_stab"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_pop_type": {
      "entrypoint": "0x00109b2f",
      "current_name": "stab_pop_type",
      "code": "\nundefined8 * stab_pop_type(long param_1)\n\n{\n  undefined8 *__ptr;\n  undefined8 *puVar1;\n  \n  __ptr \u003d *(undefined8 **)(param_1 + 0x60);\n  if (__ptr !\u003d (undefined8 *)0x0) {\n    puVar1 \u003d (undefined8 *)__ptr[1];\n    *(undefined8 *)(param_1 + 0x60) \u003d *__ptr;\n    free(__ptr);\n    return puVar1;\n  }\n  return __ptr;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_end_struct_type.lto_priv.0",
        "stab_struct_field.lto_priv.0",
        "stab_typdef.lto_priv.0",
        "stab_range_type.lto_priv.0",
        "stab_function_type.lto_priv.0",
        "stab_start_function.lto_priv.0",
        "stab_set_type.lto_priv.0",
        "stab_method_type.lto_priv.0",
        "stab_typed_constant.lto_priv.0",
        "stab_modify_type",
        "stab_function_parameter.lto_priv.0",
        "stab_class_static_member.lto_priv.0",
        "stab_class_baseclass.lto_priv.0",
        "stab_float_type.lto_priv.0",
        "stab_array_type.lto_priv.0",
        "stab_variable.lto_priv.0",
        "stab_offset_type.lto_priv.0",
        "stab_start_class_type.lto_priv.0",
        "stab_class_method_var",
        "stab_tag.lto_priv.0"
      ],
      "called": [
        "free"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_push_string": {
      "entrypoint": "0x00109b52",
      "current_name": "stab_push_string",
      "code": "\nundefined stab_push_string(long param_1,undefined8 param_2,undefined8 param_3,undefined param_4,\n                          undefined4 param_5)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  undefined8 uVar3;\n  \n  puVar2 \u003d (undefined8 *)xmalloc(0x40);\n  uVar3 \u003d xstrdup(param_2);\n  puVar2[2] \u003d param_3;\n  *(undefined (*) [16])(puVar2 + 4) \u003d ZEXT816(0);\n  *(undefined (*) [16])(puVar2 + 6) \u003d ZEXT816(0);\n  uVar1 \u003d *(undefined8 *)(param_1 + 0x60);\n  *(undefined *)((long)puVar2 + 0x1c) \u003d param_4;\n  *(undefined4 *)(puVar2 + 3) \u003d param_5;\n  *(undefined8 **)(param_1 + 0x60) \u003d puVar2;\n  *puVar2 \u003d uVar1;\n  puVar2[1] \u003d uVar3;\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_end_struct_type.lto_priv.0",
        "stab_int_type.lto_priv.0",
        "stab_enum_type.lto_priv.0",
        "stab_range_type.lto_priv.0",
        "stab_set_type.lto_priv.0",
        "stab_method_type.lto_priv.0",
        "stab_push_defined_type",
        "stab_modify_type",
        "stab_void_type.lto_priv.0",
        "stab_start_struct_type.lto_priv.0",
        "stab_float_type.lto_priv.0",
        "stab_complex_type.lto_priv.0",
        "stab_array_type.lto_priv.0",
        "stab_empty_type.lto_priv.0",
        "stab_offset_type.lto_priv.0"
      ],
      "called": [
        "xstrdup",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_class_end_method.lto_priv.0": {
      "entrypoint": "0x00109bbb",
      "current_name": "stab_class_end_method.lto_priv.0",
      "code": "\nbool stab_class_end_method_lto_priv_0(long param_1)\n\n{\n  char *__s;\n  size_t sVar1;\n  \n  if (*(long *)(param_1 + 0x60) !\u003d 0) {\n    __s \u003d *(char **)(*(long *)(param_1 + 0x60) + 0x30);\n    if (__s !\u003d (char *)0x0) {\n      sVar1 \u003d strlen(__s);\n      *(undefined2 *)(__s + sVar1) \u003d 0x3b;\n    }\n    return __s !\u003d (char *)0x0;\n  }\n  return false;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "strlen"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_demangle_remember_type": {
      "entrypoint": "0x00109be3",
      "current_name": "stab_demangle_remember_type",
      "code": "\nundefined8 stab_demangle_remember_type(long param_1,undefined8 param_2,undefined4 param_3)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  uint uVar3;\n  \n  if (*(uint *)(param_1 + 0x2c) \u003c\u003d *(uint *)(param_1 + 0x28)) {\n    uVar3 \u003d *(uint *)(param_1 + 0x2c) + 10;\n    *(uint *)(param_1 + 0x2c) \u003d uVar3;\n    uVar1 \u003d xrealloc(*(undefined8 *)(param_1 + 0x20),(ulong)uVar3 \u003c\u003c 4);\n    *(undefined8 *)(param_1 + 0x20) \u003d uVar1;\n  }\n  uVar3 \u003d *(uint *)(param_1 + 0x28);\n  puVar2 \u003d (undefined8 *)((ulong)uVar3 * 0x10 + *(long *)(param_1 + 0x20));\n  *puVar2 \u003d param_2;\n  *(undefined4 *)(puVar2 + 1) \u003d param_3;\n  *(uint *)(param_1 + 0x28) \u003d uVar3 + 1;\n  return CONCAT71((int7)((ulong)puVar2 \u003e\u003e 8),1);\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_arg",
        "parse_stab_type"
      ],
      "called": [
        "xrealloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_get_struct_index": {
      "entrypoint": "0x00109c2e",
      "current_name": "stab_get_struct_index",
      "code": "\nundefined  [16]\nstab_get_struct_index\n          (long param_1,long param_2,ulong param_3,int param_4,undefined4 *param_5,\n          undefined8 param_6)\n\n{\n  long lVar1;\n  long *plVar2;\n  long lVar3;\n  undefined *puVar4;\n  ulong uVar5;\n  byte bVar6;\n  undefined auVar7 [16];\n  \n  bVar6 \u003d 0;\n  param_3 \u003d param_3 \u0026 0xffffffff;\n  uVar5 \u003d *(ulong *)(param_1 + 0x1b0);\n  if (uVar5 \u003c\u003d param_3) {\n    if (uVar5 \u003d\u003d 0) {\n      uVar5 \u003d 10;\n    }\n    for (; uVar5 \u003c\u003d param_3; uVar5 \u003d uVar5 * 2) {\n    }\n    lVar1 \u003d xrealloc(*(undefined8 *)(param_1 + 0x1a8),uVar5 * 0x18);\n    *(long *)(param_1 + 0x1a8) \u003d lVar1;\n    puVar4 \u003d (undefined *)(*(long *)(param_1 + 0x1b0) * 0x18 + lVar1);\n    for (lVar3 \u003d (uVar5 - *(long *)(param_1 + 0x1b0)) * 0x18; lVar3 !\u003d 0; lVar3 \u003d lVar3 + -1) {\n      *puVar4 \u003d 0;\n      puVar4 \u003d puVar4 + (ulong)bVar6 * -2 + 1;\n    }\n    *(ulong *)(param_1 + 0x1b0) \u003d uVar5;\n  }\n  plVar2 \u003d (long *)(param_3 * 0x18 + *(long *)(param_1 + 0x1a8));\n  if (*plVar2 \u003d\u003d 0) {\n    lVar1 \u003d *(long *)(param_1 + 0x68);\n    *plVar2 \u003d lVar1;\n    *(long *)(param_1 + 0x68) \u003d lVar1 + 1;\n    plVar2[1] \u003d param_2;\n    *(int *)(plVar2 + 2) \u003d param_4;\n  }\n  if (param_4 \u003d\u003d 0) {\n    *(undefined4 *)(plVar2 + 2) \u003d 0;\n    *(undefined4 *)((long)plVar2 + 0x14) \u003d *param_5;\n  }\n  else {\n    *param_5 \u003d *(undefined4 *)((long)plVar2 + 0x14);\n  }\n  auVar7._8_8_ \u003d param_6;\n  auVar7._0_8_ \u003d *plVar2;\n  return auVar7;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_start_struct_type.lto_priv.0",
        "stab_tag_type.lto_priv.0"
      ],
      "called": [
        "xrealloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_push_defined_type": {
      "entrypoint": "0x00109cf4",
      "current_name": "stab_push_defined_type",
      "code": "\nvoid stab_push_defined_type(undefined8 param_1,undefined8 param_2,undefined4 param_3)\n\n{\n  char local_3c [28];\n  \n  sprintf(local_3c,\"%ld\",param_2);\n  stab_push_string(param_1,local_3c,param_2,0,param_3);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_enum_type.lto_priv.0",
        "stab_tag_type.lto_priv.0",
        "stab_int_type.lto_priv.0",
        "stab_float_type.lto_priv.0",
        "stab_empty_type.lto_priv.0",
        "stab_bool_type.lto_priv.0",
        "stab_modify_type",
        "stab_void_type.lto_priv.0",
        "stab_typedef_type.lto_priv.0"
      ],
      "called": [
        "stab_push_string",
        "sprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_bool_type.lto_priv.0": {
      "entrypoint": "0x00109d3e",
      "current_name": "stab_bool_type.lto_priv.0",
      "code": "\nvoid stab_bool_type_lto_priv_0(undefined8 param_1,int param_2)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 \u003d 0xfffffffffffffff0;\n  if (param_2 - 1U \u003c 8) {\n    uVar1 \u003d *(undefined8 *)(CSWTCH_58 + (ulong)(param_2 - 1U) * 8);\n  }\n  stab_push_defined_type(param_1,uVar1,param_2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "stab_push_defined_type"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_tag_type.lto_priv.0": {
      "entrypoint": "0x00109d5c",
      "current_name": "stab_tag_type.lto_priv.0",
      "code": "\nundefined8 stab_tag_type_lto_priv_0(undefined8 param_1)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 \u003d stab_get_struct_index();\n  if (-1 \u003c lVar1) {\n    uVar2 \u003d stab_push_defined_type(param_1,lVar1,0);\n    return uVar2;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "stab_push_defined_type",
        "stab_get_struct_index"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_empty_type.lto_priv.0": {
      "entrypoint": "0x00109d97",
      "current_name": "stab_empty_type.lto_priv.0",
      "code": "\nvoid stab_empty_type_lto_priv_0(long param_1)\n\n{\n  long lVar1;\n  char local_40 [40];\n  \n  if (*(long *)(param_1 + 0x70) !\u003d 0) {\n    stab_push_defined_type(param_1,*(long *)(param_1 + 0x70),0);\n    return;\n  }\n  lVar1 \u003d *(long *)(param_1 + 0x68);\n  *(long *)(param_1 + 0x68) \u003d lVar1 + 1;\n  sprintf(local_40,\"%ld\u003d%ld\",lVar1,lVar1);\n  stab_push_string(param_1,local_40,lVar1,0,0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_method_type.lto_priv.0",
        "debug_write_type.constprop.0"
      ],
      "called": [
        "stab_push_defined_type",
        "stab_push_string",
        "sprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_void_type.lto_priv.0": {
      "entrypoint": "0x00109dfe",
      "current_name": "stab_void_type.lto_priv.0",
      "code": "\nvoid stab_void_type_lto_priv_0(long param_1)\n\n{\n  long lVar1;\n  char local_40 [40];\n  \n  if (*(long *)(param_1 + 0x70) !\u003d 0) {\n    stab_push_defined_type(param_1,*(long *)(param_1 + 0x70),0);\n    return;\n  }\n  lVar1 \u003d *(long *)(param_1 + 0x68);\n  *(long *)(param_1 + 0x68) \u003d lVar1 + 1;\n  *(long *)(param_1 + 0x70) \u003d lVar1;\n  sprintf(local_40,\"%ld\u003d%ld\",lVar1,lVar1);\n  stab_push_string(param_1,local_40,lVar1,1,0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "stab_push_defined_type",
        "stab_push_string",
        "sprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_complex_type.lto_priv.0": {
      "entrypoint": "0x00109e76",
      "current_name": "stab_complex_type.lto_priv.0",
      "code": "\nvoid stab_complex_type_lto_priv_0(long param_1,uint param_2)\n\n{\n  long lVar1;\n  char local_5a [58];\n  \n  lVar1 \u003d *(long *)(param_1 + 0x68);\n  *(long *)(param_1 + 0x68) \u003d lVar1 + 1;\n  sprintf(local_5a,\"%ld\u003dr%ld;%u;0;\",lVar1,lVar1,(ulong)param_2);\n  stab_push_string(param_1,local_5a,lVar1,1,param_2 * 2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "stab_push_string",
        "sprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_modify_type": {
      "entrypoint": "0x00109ed3",
      "current_name": "stab_modify_type",
      "code": "\nundefined8\nstab_modify_type(long param_1,uint param_2,undefined4 param_3,long *param_4,ulong *param_5)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  char cVar3;\n  char *pcVar4;\n  size_t sVar5;\n  char *__s;\n  long lVar6;\n  void *__ptr;\n  undefined8 uVar7;\n  undefined uVar8;\n  long lVar9;\n  ulong uVar10;\n  undefined *puVar11;\n  byte bVar12;\n  \n  bVar12 \u003d 0;\n  lVar6 \u003d *(long *)(param_1 + 0x60);\n  if (lVar6 !\u003d 0) {\n    uVar1 \u003d *(ulong *)(lVar6 + 0x10);\n    if (((long)uVar1 \u003c 1) || (param_4 \u003d\u003d (long *)0x0)) {\n      uVar8 \u003d *(undefined *)(lVar6 + 0x1c);\n      pcVar4 \u003d (char *)stab_pop_type(param_1);\n      sVar5 \u003d strlen(pcVar4);\n      __s \u003d (char *)xmalloc(sVar5 + 2);\n      sprintf(__s,\"%c%s\",(ulong)param_2,pcVar4);\n      free(pcVar4);\n      lVar6 \u003d 0;\n    }\n    else {\n      uVar10 \u003d *param_5;\n      if (uVar10 \u003c\u003d uVar1) {\n        if (uVar10 \u003d\u003d 0) {\n          uVar10 \u003d 10;\n        }\n        for (; uVar10 \u003c\u003d uVar1; uVar10 \u003d uVar10 * 2) {\n        }\n        lVar6 \u003d xrealloc(*param_4,uVar10 * 8);\n        uVar2 \u003d *param_5;\n        *param_4 \u003d lVar6;\n        puVar11 \u003d (undefined *)(lVar6 + uVar2 * 8);\n        for (lVar9 \u003d (uVar10 - uVar2) * 8; lVar9 !\u003d 0; lVar9 \u003d lVar9 + -1) {\n          *puVar11 \u003d 0;\n          puVar11 \u003d puVar11 + (ulong)bVar12 * -2 + 1;\n        }\n        *param_5 \u003d uVar10;\n      }\n      lVar6 \u003d *(long *)(*param_4 + uVar1 * 8);\n      if ((lVar6 !\u003d 0) \u0026\u0026 (*(char *)(*(long *)(param_1 + 0x60) + 0x1c) \u003d\u003d \u0027\\0\u0027)) {\n        __ptr \u003d (void *)stab_pop_type(param_1);\n        free(__ptr);\n        uVar7 \u003d stab_push_defined_type(param_1,lVar6,param_3);\n        return uVar7;\n      }\n      lVar6 \u003d *(long *)(param_1 + 0x68);\n      *(long *)(param_1 + 0x68) \u003d lVar6 + 1;\n      pcVar4 \u003d (char *)stab_pop_type(param_1);\n      sVar5 \u003d strlen(pcVar4);\n      __s \u003d (char *)xmalloc(sVar5 + 0x14);\n      sprintf(__s,\"%ld\u003d%c%s\",lVar6,(ulong)param_2,pcVar4);\n      free(pcVar4);\n      uVar8 \u003d 1;\n      *(long *)(*param_4 + uVar1 * 8) \u003d lVar6;\n    }\n    cVar3 \u003d stab_push_string(param_1,__s,lVar6,uVar8,param_3);\n    if (cVar3 !\u003d \u0027\\0\u0027) {\n      free(__s);\n      return 1;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_function_type.lto_priv.0",
        "stab_pointer_type.lto_priv.0",
        "stab_volatile_type.lto_priv.0",
        "stab_reference_type.lto_priv.0",
        "stab_const_type.lto_priv.0"
      ],
      "called": [
        "free",
        "strlen",
        "xrealloc",
        "stab_push_defined_type",
        "stab_push_string",
        "sprintf",
        "stab_pop_type",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_pointer_type.lto_priv.0": {
      "entrypoint": "0x0010a083",
      "current_name": "stab_pointer_type.lto_priv.0",
      "code": "\nvoid stab_pointer_type_lto_priv_0(long param_1)\n\n{\n  stab_modify_type(param_1,0x2a,4,param_1 + 0x178,param_1 + 0x180);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "stab_modify_type"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_reference_type.lto_priv.0": {
      "entrypoint": "0x0010a0a0",
      "current_name": "stab_reference_type.lto_priv.0",
      "code": "\nvoid stab_reference_type_lto_priv_0(long param_1)\n\n{\n  stab_modify_type(param_1,0x26,4,param_1 + 0x198,param_1 + 0x1a0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "stab_modify_type"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_const_type.lto_priv.0": {
      "entrypoint": "0x0010a0bd",
      "current_name": "stab_const_type.lto_priv.0",
      "code": "\nvoid stab_const_type_lto_priv_0(long param_1)\n\n{\n  stab_modify_type(param_1,0x6b,*(undefined4 *)(*(long *)(param_1 + 0x60) + 0x18),0,0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "stab_modify_type"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_volatile_type.lto_priv.0": {
      "entrypoint": "0x0010a0d3",
      "current_name": "stab_volatile_type.lto_priv.0",
      "code": "\nvoid stab_volatile_type_lto_priv_0(long param_1)\n\n{\n  stab_modify_type(param_1,0x42,*(undefined4 *)(*(long *)(param_1 + 0x60) + 0x18),0,0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "stab_modify_type"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_range_type.lto_priv.0": {
      "entrypoint": "0x0010a0e9",
      "current_name": "stab_range_type.lto_priv.0",
      "code": "\nundefined4 stab_range_type_lto_priv_0(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined uVar1;\n  undefined4 uVar2;\n  char *__s;\n  size_t sVar3;\n  char *__s_00;\n  \n  uVar1 \u003d *(undefined *)(*(long *)(param_1 + 0x60) + 0x1c);\n  uVar2 \u003d *(undefined4 *)(*(long *)(param_1 + 0x60) + 0x18);\n  __s \u003d (char *)stab_pop_type();\n  sVar3 \u003d strlen(__s);\n  __s_00 \u003d (char *)xmalloc(sVar3 + 100);\n  sprintf(__s_00,\"r%s;%ld;%ld;\",__s,param_2,param_3);\n  free(__s);\n  uVar2 \u003d stab_push_string(param_1,__s_00,0,uVar1,uVar2);\n  if ((char)uVar2 !\u003d \u0027\\0\u0027) {\n    free(__s_00);\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "free",
        "strlen",
        "stab_push_string",
        "sprintf",
        "stab_pop_type",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_array_type.lto_priv.0": {
      "entrypoint": "0x0010a181",
      "current_name": "stab_array_type.lto_priv.0",
      "code": "\nundefined4 stab_array_type_lto_priv_0(long param_1,long param_2,long param_3,byte param_4)\n\n{\n  char cVar1;\n  int iVar2;\n  int iVar3;\n  undefined4 uVar4;\n  char *__s;\n  char *__s_00;\n  size_t sVar5;\n  size_t sVar6;\n  char *__s_01;\n  long lVar7;\n  byte local_41;\n  \n  cVar1 \u003d *(char *)(*(long *)(param_1 + 0x60) + 0x1c);\n  __s \u003d (char *)stab_pop_type();\n  local_41 \u003d 1;\n  if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n    local_41 \u003d *(byte *)(*(long *)(param_1 + 0x60) + 0x1c);\n  }\n  iVar2 \u003d *(int *)(*(long *)(param_1 + 0x60) + 0x18);\n  __s_00 \u003d (char *)stab_pop_type(param_1);\n  sVar5 \u003d strlen(__s);\n  sVar6 \u003d strlen(__s_00);\n  __s_01 \u003d (char *)xmalloc(sVar5 + 100 + sVar6);\n  if (param_4 \u003d\u003d 0) {\n    *__s_01 \u003d \u0027\\0\u0027;\n    lVar7 \u003d 0;\n    local_41 \u003d local_41 \u0026 1;\n  }\n  else {\n    lVar7 \u003d *(long *)(param_1 + 0x68);\n    *(long *)(param_1 + 0x68) \u003d lVar7 + 1;\n    sprintf(__s_01,\"%ld\u003d@S;\",lVar7);\n    local_41 \u003d param_4;\n  }\n  sVar5 \u003d strlen(__s_01);\n  sprintf(__s_01 + sVar5,\"ar%s;%ld;%ld;%s\",__s,param_2,param_3,__s_00);\n  free(__s);\n  free(__s_00);\n  iVar3 \u003d 0;\n  if (param_2 \u003c\u003d param_3) {\n    iVar3 \u003d iVar2 * (((int)param_3 - (int)param_2) + 1);\n  }\n  uVar4 \u003d stab_push_string(param_1,__s_01,lVar7,local_41,iVar3);\n  if ((char)uVar4 !\u003d \u0027\\0\u0027) {\n    free(__s_01);\n  }\n  return uVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "free",
        "strlen",
        "stab_push_string",
        "sprintf",
        "stab_pop_type",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_set_type.lto_priv.0": {
      "entrypoint": "0x0010a2b9",
      "current_name": "stab_set_type.lto_priv.0",
      "code": "\nundefined  [16]\nstab_set_type_lto_priv_0(long param_1,char param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  char cVar1;\n  char *__s;\n  size_t sVar2;\n  char *__s_00;\n  long lVar3;\n  undefined auVar4 [16];\n  \n  cVar1 \u003d *(char *)(*(long *)(param_1 + 0x60) + 0x1c);\n  __s \u003d (char *)stab_pop_type();\n  sVar2 \u003d strlen(__s);\n  __s_00 \u003d (char *)xmalloc(sVar2 + 0x1e);\n  if (param_2 \u003d\u003d \u0027\\0\u0027) {\n    *__s_00 \u003d \u0027\\0\u0027;\n    lVar3 \u003d 0;\n    param_2 \u003d cVar1;\n  }\n  else {\n    lVar3 \u003d *(long *)(param_1 + 0x68);\n    *(long *)(param_1 + 0x68) \u003d lVar3 + 1;\n    sprintf(__s_00,\"%ld\u003d@S;\",lVar3);\n  }\n  sVar2 \u003d strlen(__s_00);\n  sprintf(__s_00 + sVar2,\"S%s\",__s);\n  free(__s);\n  auVar4._0_4_ \u003d stab_push_string(param_1,__s_00,lVar3,param_2,0);\n  auVar4._4_4_ \u003d 0;\n  if ((char)auVar4._0_4_ !\u003d \u0027\\0\u0027) {\n    free(__s_00);\n  }\n  auVar4._8_8_ \u003d param_4;\n  return auVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "free",
        "strlen",
        "stab_push_string",
        "sprintf",
        "stab_pop_type",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_offset_type.lto_priv.0": {
      "entrypoint": "0x0010a377",
      "current_name": "stab_offset_type.lto_priv.0",
      "code": "\nundefined4 stab_offset_type_lto_priv_0(long param_1)\n\n{\n  char cVar1;\n  undefined4 uVar2;\n  char *__s;\n  char *__s_00;\n  size_t sVar3;\n  size_t sVar4;\n  char *__s_01;\n  undefined uVar5;\n  \n  uVar5 \u003d 1;\n  cVar1 \u003d *(char *)(*(long *)(param_1 + 0x60) + 0x1c);\n  __s \u003d (char *)stab_pop_type();\n  if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n    uVar5 \u003d *(undefined *)(*(long *)(param_1 + 0x60) + 0x1c);\n  }\n  __s_00 \u003d (char *)stab_pop_type(param_1);\n  sVar3 \u003d strlen(__s);\n  sVar4 \u003d strlen(__s_00);\n  __s_01 \u003d (char *)xmalloc(sVar3 + 3 + sVar4);\n  sprintf(__s_01,\"@%s,%s\",__s_00,__s);\n  free(__s_00);\n  free(__s);\n  uVar2 \u003d stab_push_string(param_1,__s_01,0,uVar5,0);\n  if ((char)uVar2 !\u003d \u0027\\0\u0027) {\n    free(__s_01);\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "free",
        "strlen",
        "stab_push_string",
        "sprintf",
        "stab_pop_type",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_method_type.lto_priv.0": {
      "entrypoint": "0x0010a424",
      "current_name": "stab_method_type.lto_priv.0",
      "code": "\nundefined4 stab_method_type_lto_priv_0(long param_1,char param_2,int param_3,char param_4)\n\n{\n  char cVar1;\n  byte bVar2;\n  int iVar3;\n  undefined4 uVar4;\n  char *pcVar5;\n  undefined8 *__ptr;\n  undefined8 uVar6;\n  char *__s;\n  size_t sVar7;\n  size_t sVar8;\n  char *__s_00;\n  long lVar9;\n  byte bVar10;\n  long lVar11;\n  undefined uVar12;\n  \n  if ((param_2 \u003d\u003d \u0027\\0\u0027) \u0026\u0026 (cVar1 \u003d stab_empty_type_lto_priv_0(), cVar1 \u003d\u003d \u0027\\0\u0027)) {\n    return 0;\n  }\n  bVar10 \u003d *(byte *)(*(long *)(param_1 + 0x60) + 0x1c);\n  pcVar5 \u003d (char *)stab_pop_type(param_1);\n  if (param_3 \u003c 0) {\n    __ptr \u003d (undefined8 *)0x0;\n    param_3 \u003d 0;\nLAB_0010a582:\n    uVar12 \u003d 1;\n    if (bVar10 !\u003d 0) goto LAB_0010a596;\n  }\n  else {\n    if (param_3 !\u003d 0) {\n      iVar3 \u003d param_3 + 1;\n      __ptr \u003d (undefined8 *)xmalloc((long)iVar3 * 8);\n      lVar9 \u003d (long)(param_3 + -1);\n      do {\n        bVar2 \u003d 1;\n        if (bVar10 \u003d\u003d 0) {\n          bVar2 \u003d *(byte *)(*(long *)(param_1 + 0x60) + 0x1c);\n        }\n        uVar6 \u003d stab_pop_type(param_1);\n        bVar10 \u003d bVar2 \u0026 1;\n        __ptr[lVar9] \u003d uVar6;\n        lVar9 \u003d lVar9 + -1;\n      } while ((int)lVar9 !\u003d -1);\n      if (param_4 \u003d\u003d \u0027\\0\u0027) {\n        cVar1 \u003d stab_empty_type_lto_priv_0(param_1);\n        if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n          return 0;\n        }\n        bVar2 \u003d 1;\n        if (bVar10 \u003d\u003d 0) {\n          bVar2 \u003d *(byte *)(*(long *)(param_1 + 0x60) + 0x1c);\n        }\n        bVar10 \u003d bVar2 \u0026 1;\n        uVar6 \u003d stab_pop_type(param_1);\n        __ptr[(long)iVar3 + -1] \u003d uVar6;\n        param_3 \u003d iVar3;\n      }\n      goto LAB_0010a582;\n    }\n    __ptr \u003d (undefined8 *)0x0;\n    if (param_4 !\u003d \u0027\\0\u0027) goto LAB_0010a582;\n    __ptr \u003d (undefined8 *)xmalloc(8);\n    cVar1 \u003d stab_empty_type_lto_priv_0(param_1);\n    if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n      return 0;\n    }\n    if ((bVar10 !\u003d 0) || (*(char *)(*(long *)(param_1 + 0x60) + 0x1c) !\u003d \u0027\\0\u0027)) {\n      uVar6 \u003d stab_pop_type(param_1);\n      param_3 \u003d 1;\n      uVar12 \u003d 1;\n      *__ptr \u003d uVar6;\n      goto LAB_0010a596;\n    }\n    uVar6 \u003d stab_pop_type(param_1);\n    param_3 \u003d 1;\n    *__ptr \u003d uVar6;\n  }\n  uVar12 \u003d *(undefined *)(*(long *)(param_1 + 0x60) + 0x1c);\nLAB_0010a596:\n  __s \u003d (char *)stab_pop_type(param_1);\n  sVar7 \u003d strlen(pcVar5);\n  sVar8 \u003d strlen(__s);\n  lVar9 \u003d sVar7 + 10 + sVar8;\n  for (lVar11 \u003d 0; (int)lVar11 \u003c param_3; lVar11 \u003d lVar11 + 1) {\n    sVar7 \u003d strlen((char *)__ptr[lVar11]);\n    lVar9 \u003d lVar9 + sVar7;\n  }\n  __s_00 \u003d (char *)xmalloc(lVar9);\n  sprintf(__s_00,\"#%s,%s\",pcVar5,__s);\n  lVar9 \u003d 0;\n  free(pcVar5);\n  free(__s);\n  while( true ) {\n    sVar7 \u003d strlen(__s_00);\n    if (param_3 \u003c\u003d (int)lVar9) break;\n    *(undefined2 *)(__s_00 + sVar7) \u003d 0x2c;\n    pcVar5 \u003d (char *)__ptr[lVar9];\n    lVar9 \u003d lVar9 + 1;\n    strcpy(__s_00 + sVar7 + 1,pcVar5);\n    free(pcVar5);\n  }\n  *(undefined2 *)(__s_00 + sVar7) \u003d 0x3b;\n  free(__ptr);\n  uVar4 \u003d stab_push_string(param_1,__s_00,0,uVar12,0);\n  if ((char)uVar4 \u003d\u003d \u0027\\0\u0027) {\n    return 0;\n  }\n  free(__s_00);\n  return uVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "free",
        "strlen",
        "stab_empty_type.lto_priv.0",
        "stab_push_string",
        "strcpy",
        "sprintf",
        "stab_pop_type",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_start_struct_type.lto_priv.0": {
      "entrypoint": "0x0010a69a",
      "current_name": "stab_start_struct_type.lto_priv.0",
      "code": "\nundefined4\nstab_start_struct_type_lto_priv_0\n          (long param_1,undefined8 param_2,int param_3,char param_4,uint param_5)\n\n{\n  undefined4 uVar1;\n  long lVar2;\n  size_t sVar3;\n  undefined8 uVar4;\n  undefined uVar5;\n  char local_60 [48];\n  \n  if (param_3 \u003d\u003d 0) {\n    local_60[0] \u003d \u0027\\0\u0027;\n    uVar5 \u003d 0;\n    lVar2 \u003d 0;\n  }\n  else {\n    lVar2 \u003d stab_get_struct_index();\n    if (lVar2 \u003c 0) {\n      return 0;\n    }\n    uVar5 \u003d 1;\n    sprintf(local_60,\"%ld\u003d\",lVar2);\n  }\n  sVar3 \u003d strlen(local_60);\n  sprintf(local_60 + sVar3,\"%c%u\",(ulong)((-(uint)(param_4 \u003d\u003d \u0027\\0\u0027) \u0026 2) + 0x73),(ulong)param_5);\n  uVar1 \u003d stab_push_string(param_1,local_60,lVar2,uVar5,param_5);\n  if ((char)uVar1 \u003d\u003d \u0027\\0\u0027) {\n    return 0;\n  }\n  lVar2 \u003d *(long *)(param_1 + 0x60);\n  uVar4 \u003d xmalloc(1);\n  *(undefined8 *)(lVar2 + 0x20) \u003d uVar4;\n  **(undefined **)(*(long *)(param_1 + 0x60) + 0x20) \u003d 0;\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0",
        "stab_start_class_type.lto_priv.0"
      ],
      "called": [
        "strlen",
        "stab_push_string",
        "stab_get_struct_index",
        "sprintf",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_end_struct_type.lto_priv.0": {
      "entrypoint": "0x0010a77a",
      "current_name": "stab_end_struct_type.lto_priv.0",
      "code": "\nundefined4 stab_end_struct_type_lto_priv_0(long param_1)\n\n{\n  undefined uVar1;\n  long lVar2;\n  char *__s;\n  undefined8 uVar3;\n  undefined4 uVar4;\n  char *__s_00;\n  size_t sVar5;\n  size_t sVar6;\n  char *__s_01;\n  \n  lVar2 \u003d *(long *)(param_1 + 0x60);\n  if ((lVar2 !\u003d 0) \u0026\u0026 (__s \u003d *(char **)(lVar2 + 0x20), __s !\u003d (char *)0x0)) {\n    uVar4 \u003d *(undefined4 *)(lVar2 + 0x18);\n    uVar1 \u003d *(undefined *)(lVar2 + 0x1c);\n    uVar3 \u003d *(undefined8 *)(lVar2 + 0x10);\n    __s_00 \u003d (char *)stab_pop_type();\n    sVar5 \u003d strlen(__s_00);\n    sVar6 \u003d strlen(__s);\n    __s_01 \u003d (char *)xmalloc(sVar5 + 2 + sVar6);\n    sprintf(__s_01,\"%s%s;\",__s_00,__s);\n    free(__s_00);\n    free(__s);\n    uVar4 \u003d stab_push_string(param_1,__s_01,uVar3,uVar1,uVar4);\n    if ((char)uVar4 !\u003d \u0027\\0\u0027) {\n      free(__s_01);\n      return uVar4;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "free",
        "strlen",
        "stab_push_string",
        "sprintf",
        "stab_pop_type",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_start_class_type.lto_priv.0": {
      "entrypoint": "0x0010a83e",
      "current_name": "stab_start_class_type.lto_priv.0",
      "code": "\nundefined4\nstab_start_class_type_lto_priv_0\n          (long param_1,undefined8 param_2,ulong param_3,undefined param_4,ulong param_5,\n          byte param_6,byte param_7)\n\n{\n  undefined4 uVar1;\n  char *__s;\n  char *__s_00;\n  size_t sVar2;\n  char cVar3;\n  \n  if (((param_7 ^ 1) \u0026 param_6) \u003d\u003d 0) {\n    __s \u003d (char *)0x0;\n    cVar3 \u003d \u0027\\0\u0027;\n  }\n  else {\n    cVar3 \u003d *(char *)(*(long *)(param_1 + 0x60) + 0x1c);\n    __s \u003d (char *)stab_pop_type();\n    param_5 \u003d param_5 \u0026 0xffffffff;\n    param_3 \u003d param_3 \u0026 0xffffffff;\n  }\n  uVar1 \u003d stab_start_struct_type_lto_priv_0(param_1,param_2,param_3,param_4,param_5);\n  if ((char)uVar1 !\u003d \u0027\\0\u0027) {\n    if (param_6 \u003d\u003d 0) {\n      return uVar1;\n    }\n    if (param_7 \u003d\u003d 0) {\n      if (__s \u003d\u003d (char *)0x0) {\n        return 0;\n      }\n      sVar2 \u003d strlen(__s);\n      __s_00 \u003d (char *)xmalloc(sVar2 + 3);\n      sprintf(__s_00,\"~%%%s\",__s);\n      free(__s);\n      if (cVar3 !\u003d \u0027\\0\u0027) {\n        *(undefined *)(*(long *)(param_1 + 0x60) + 0x1c) \u003d 1;\n      }\n    }\n    else {\n      if (*(long *)(*(long *)(param_1 + 0x60) + 0x10) \u003c 1) {\n        return 0;\n      }\n      __s_00 \u003d (char *)xmalloc(0x14);\n      sprintf(__s_00,\"~%%%ld\",*(undefined8 *)(*(long *)(param_1 + 0x60) + 0x10));\n    }\n    *(char **)(*(long *)(param_1 + 0x60) + 0x38) \u003d __s_00;\n    return uVar1;\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "stab_start_struct_type.lto_priv.0",
        "free",
        "strlen",
        "sprintf",
        "stab_pop_type",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_class_static_member.lto_priv.0": {
      "entrypoint": "0x0010a94e",
      "current_name": "stab_class_static_member.lto_priv.0",
      "code": "\nundefined8 stab_class_static_member_lto_priv_0(long param_1,char *param_2,char *param_3,int param_4)\n\n{\n  char cVar1;\n  long lVar2;\n  char *__s;\n  size_t sVar3;\n  size_t sVar4;\n  size_t sVar5;\n  size_t sVar6;\n  char *pcVar7;\n  undefined8 uVar8;\n  char *pcVar9;\n  \n  cVar1 \u003d *(char *)(*(long *)(param_1 + 0x60) + 0x1c);\n  __s \u003d (char *)stab_pop_type();\n  pcVar7 \u003d *(char **)(*(long *)(param_1 + 0x60) + 0x20);\n  if (pcVar7 \u003d\u003d (char *)0x0) {\n    uVar8 \u003d 0;\n  }\n  else {\n    sVar3 \u003d strlen(pcVar7);\n    sVar4 \u003d strlen(param_2);\n    sVar5 \u003d strlen(__s);\n    sVar6 \u003d strlen(param_3);\n    pcVar7 \u003d (char *)xmalloc(sVar3 + 10 + sVar4 + sVar5 + sVar6);\n    if (param_4 \u003d\u003d 1) {\n      pcVar9 \u003d \"/1\";\n    }\n    else {\n      pcVar9 \u003d \"/0\";\n      if ((param_4 !\u003d 2) \u0026\u0026 (pcVar9 \u003d \"\", param_4 !\u003d 0)) {\n                    \n        abort();\n      }\n    }\n    sprintf(pcVar7,\"%s%s:%s%s:%s;\",*(undefined8 *)(*(long *)(param_1 + 0x60) + 0x20),param_2,pcVar9,\n            __s,param_3,*(long *)(param_1 + 0x60));\n    free(*(void **)(*(long *)(param_1 + 0x60) + 0x20));\n    lVar2 \u003d *(long *)(param_1 + 0x60);\n    *(char **)(lVar2 + 0x20) \u003d pcVar7;\n    if (cVar1 !\u003d \u0027\\0\u0027) {\n      *(undefined *)(lVar2 + 0x1c) \u003d 1;\n    }\n    uVar8 \u003d CONCAT71((int7)((ulong)lVar2 \u003e\u003e 8),1);\n  }\n  return uVar8;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "free",
        "strlen",
        "abort",
        "sprintf",
        "stab_pop_type",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_class_baseclass.lto_priv.0": {
      "entrypoint": "0x0010aa53",
      "current_name": "stab_class_baseclass.lto_priv.0",
      "code": "\nundefined8 stab_class_baseclass_lto_priv_0(long param_1,undefined8 param_2,char param_3,int param_4)\n\n{\n  char cVar1;\n  long lVar2;\n  char cVar3;\n  uint uVar4;\n  char *__s;\n  size_t sVar5;\n  char *pcVar6;\n  long lVar7;\n  undefined8 uVar8;\n  ulong uVar9;\n  ulong uVar10;\n  \n  cVar1 \u003d *(char *)(*(long *)(param_1 + 0x60) + 0x1c);\n  __s \u003d (char *)stab_pop_type();\n  sVar5 \u003d strlen(__s);\n  pcVar6 \u003d (char *)xmalloc(sVar5 + 0x19);\n  *pcVar6 \u003d param_3 + \u00270\u0027;\n  if (param_4 \u003d\u003d 1) {\n    cVar3 \u003d \u00271\u0027;\n  }\n  else {\n    cVar3 \u003d \u00270\u0027;\n    if ((param_4 !\u003d 2) \u0026\u0026 (cVar3 \u003d \u00272\u0027, param_4 !\u003d 0)) {\n                    \n      abort();\n    }\n  }\n  pcVar6[1] \u003d cVar3;\n  sprintf(pcVar6 + 2,\"%ld,%s;\",param_2);\n  free(__s);\n  lVar2 \u003d *(long *)(param_1 + 0x60);\n  uVar8 \u003d 0;\n  if ((lVar2 !\u003d 0) \u0026\u0026 (*(long *)(lVar2 + 0x20) !\u003d 0)) {\n    lVar2 \u003d *(long *)(lVar2 + 0x28);\n    uVar10 \u003d 0;\n    if (lVar2 !\u003d 0) {\n      uVar4 \u003d 0;\n      do {\n        uVar9 \u003d (ulong)uVar4;\n        uVar10 \u003d (ulong)uVar4;\n        uVar4 \u003d uVar4 + 1;\n      } while (*(long *)(lVar2 + uVar9 * 8) !\u003d 0);\n    }\n    lVar7 \u003d xrealloc(lVar2,(ulong)((int)uVar10 + 2) \u003c\u003c 3);\n    *(char **)(lVar7 + uVar10 * 8) \u003d pcVar6;\n    *(undefined8 *)(lVar7 + (ulong)((int)uVar10 + 1) * 8) \u003d 0;\n    lVar2 \u003d *(long *)(param_1 + 0x60);\n    *(long *)(lVar2 + 0x28) \u003d lVar7;\n    if (cVar1 !\u003d \u0027\\0\u0027) {\n      *(undefined *)(lVar2 + 0x1c) \u003d 1;\n    }\n    uVar8 \u003d 1;\n  }\n  return uVar8;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "free",
        "strlen",
        "xrealloc",
        "abort",
        "sprintf",
        "stab_pop_type",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_class_start_method.lto_priv.0": {
      "entrypoint": "0x0010ab4d",
      "current_name": "stab_class_start_method.lto_priv.0",
      "code": "\nundefined  [16]\nstab_class_start_method_lto_priv_0(long param_1,char *param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  ulong uVar1;\n  long lVar2;\n  undefined auVar3 [16];\n  size_t sVar4;\n  char *pcVar5;\n  size_t sVar6;\n  undefined auVar7 [16];\n  \n  uVar1 \u003d *(ulong *)(param_1 + 0x60);\n  if ((uVar1 !\u003d 0) \u0026\u0026 (*(long *)(uVar1 + 0x20) !\u003d 0)) {\n    pcVar5 \u003d *(char **)(uVar1 + 0x30);\n    sVar4 \u003d strlen(param_2);\n    if (pcVar5 \u003d\u003d (char *)0x0) {\n      pcVar5 \u003d (char *)xmalloc(sVar4 + 3);\n      *pcVar5 \u003d \u0027\\0\u0027;\n    }\n    else {\n      sVar6 \u003d strlen(pcVar5);\n      pcVar5 \u003d (char *)xrealloc(pcVar5,sVar4 + 4 + sVar6);\n    }\n    sVar4 \u003d strlen(pcVar5);\n    sprintf(pcVar5 + sVar4,\"%s::\",param_2);\n    lVar2 \u003d *(long *)(param_1 + 0x60);\n    *(char **)(lVar2 + 0x30) \u003d pcVar5;\n    auVar7._1_7_ \u003d (undefined7)((ulong)lVar2 \u003e\u003e 8);\n    auVar7[0] \u003d 1;\n    auVar7._8_8_ \u003d param_4;\n    return auVar7;\n  }\n  auVar3._8_8_ \u003d 0;\n  auVar3._0_8_ \u003d uVar1;\n  return auVar3 \u003c\u003c 0x40;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "strlen",
        "xrealloc",
        "sprintf",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_class_method_var": {
      "entrypoint": "0x0010abdd",
      "current_name": "stab_class_method_var",
      "code": "\nundefined8\nstab_class_method_var\n          (long param_1,char *param_2,uint param_3,char param_4,char param_5,char param_6,\n          undefined8 param_7,char param_8)\n\n{\n  long lVar1;\n  char *pcVar2;\n  byte bVar3;\n  char *pcVar4;\n  char *__s;\n  size_t sVar5;\n  size_t sVar6;\n  size_t sVar7;\n  size_t sVar8;\n  undefined8 uVar9;\n  char cVar10;\n  char cVar11;\n  byte local_52;\n  \n  __s \u003d (char *)0x0;\n  local_52 \u003d *(byte *)(*(long *)(param_1 + 0x60) + 0x1c);\n  pcVar4 \u003d (char *)stab_pop_type();\n  if (param_8 !\u003d \u0027\\0\u0027) {\n    bVar3 \u003d 1;\n    if (local_52 \u003d\u003d 0) {\n      bVar3 \u003d *(byte *)(*(long *)(param_1 + 0x60) + 0x1c);\n    }\n    local_52 \u003d bVar3 \u0026 1;\n    __s \u003d (char *)stab_pop_type(param_1);\n  }\n  lVar1 \u003d *(long *)(param_1 + 0x60);\n  if ((lVar1 \u003d\u003d 0) || (pcVar2 \u003d *(char **)(lVar1 + 0x30), pcVar2 \u003d\u003d (char *)0x0)) {\n    uVar9 \u003d 0;\n  }\n  else {\n    if (2 \u003c param_3) {\n                    \n      abort();\n    }\n    if (param_5 \u003d\u003d \u0027\\0\u0027) {\n      cVar11 \u003d (-(param_6 \u003d\u003d \u0027\\0\u0027) \u0026 0xfeU) + 0x43;\n    }\n    else {\n      cVar11 \u003d (-(param_6 \u003d\u003d \u0027\\0\u0027) \u0026 0xfeU) + 0x44;\n    }\n    cVar10 \u003d \u0027?\u0027;\n    if (param_4 \u003d\u003d \u0027\\0\u0027) {\n      cVar10 \u003d (-(param_8 \u003d\u003d \u0027\\0\u0027) \u0026 4U) + 0x2a;\n    }\n    sVar5 \u003d strlen(pcVar2);\n    sVar6 \u003d strlen(pcVar4);\n    sVar7 \u003d strlen(param_2);\n    sVar8 \u003d 0;\n    if (param_8 !\u003d \u0027\\0\u0027) {\n      sVar8 \u003d strlen(__s);\n    }\n    uVar9 \u003d xrealloc(pcVar2,sVar7 + sVar5 + 0x28 + sVar6 + sVar8);\n    *(undefined8 *)(lVar1 + 0x30) \u003d uVar9;\n    pcVar2 \u003d *(char **)(*(long *)(param_1 + 0x60) + 0x30);\n    sVar5 \u003d strlen(pcVar2);\n    sprintf(pcVar2 + sVar5,\"%s:%s;%c%c%c\",pcVar4,param_2,(ulong)(byte)(0x32 - (char)param_3),\n            (ulong)(uint)(int)cVar11,(ulong)(uint)(int)cVar10,sVar5);\n    free(pcVar4);\n    if (param_8 !\u003d \u0027\\0\u0027) {\n      pcVar4 \u003d *(char **)(*(long *)(param_1 + 0x60) + 0x30);\n      sVar5 \u003d strlen(pcVar4);\n      sprintf(pcVar4 + sVar5,\"%ld;%s;\",param_7,__s);\n      free(__s);\n    }\n    if (local_52 !\u003d 0) {\n      *(undefined *)(*(long *)(param_1 + 0x60) + 0x1c) \u003d 1;\n    }\n    uVar9 \u003d 1;\n  }\n  return uVar9;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_class_method_variant.lto_priv.0",
        "stab_class_static_method_variant.lto_priv.0"
      ],
      "called": [
        "free",
        "strlen",
        "xrealloc",
        "abort",
        "sprintf",
        "stab_pop_type"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_class_method_variant.lto_priv.0": {
      "entrypoint": "0x0010add5",
      "current_name": "stab_class_method_variant.lto_priv.0",
      "code": "\nvoid stab_class_method_variant_lto_priv_0(void)\n\n{\n  stab_class_method_var();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "stab_class_method_var"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_class_static_method_variant.lto_priv.0": {
      "entrypoint": "0x0010adf2",
      "current_name": "stab_class_static_method_variant.lto_priv.0",
      "code": "\nvoid stab_class_static_method_variant_lto_priv_0(void)\n\n{\n  stab_class_method_var();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "stab_class_method_var"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_end_class_type.lto_priv.0": {
      "entrypoint": "0x0010ae0e",
      "current_name": "stab_end_class_type.lto_priv.0",
      "code": "\nundefined8 stab_end_class_type_lto_priv_0(long param_1)\n\n{\n  long lVar1;\n  long lVar2;\n  void *__ptr;\n  char *pcVar3;\n  size_t sVar4;\n  size_t sVar5;\n  char *pcVar6;\n  undefined8 uVar7;\n  long lVar8;\n  uint uVar9;\n  ulong uVar10;\n  \n  uVar7 \u003d 0;\n  lVar1 \u003d *(long *)(param_1 + 0x60);\n  if (((lVar1 !\u003d 0) \u0026\u0026 (*(char **)(lVar1 + 8) !\u003d (char *)0x0)) \u0026\u0026\n     (pcVar6 \u003d *(char **)(lVar1 + 0x20), pcVar6 !\u003d (char *)0x0)) {\n    sVar4 \u003d strlen(*(char **)(lVar1 + 8));\n    sVar5 \u003d strlen(pcVar6);\n    lVar2 \u003d *(long *)(lVar1 + 0x28);\n    if (lVar2 \u003d\u003d 0) {\n      lVar8 \u003d sVar4 + sVar5 + 10;\n      uVar10 \u003d 0;\n    }\n    else {\n      lVar8 \u003d sVar4 + sVar5 + 0x1e;\n      uVar10 \u003d 0;\n      while( true ) {\n        pcVar6 \u003d *(char **)(lVar2 + uVar10 * 8);\n        if (pcVar6 \u003d\u003d (char *)0x0) break;\n        sVar4 \u003d strlen(pcVar6);\n        uVar10 \u003d (ulong)((int)uVar10 + 1);\n        lVar8 \u003d lVar8 + sVar4;\n      }\n    }\n    if (*(char **)(lVar1 + 0x30) !\u003d (char *)0x0) {\n      sVar4 \u003d strlen(*(char **)(lVar1 + 0x30));\n      lVar8 \u003d lVar8 + sVar4;\n    }\n    if (*(char **)(lVar1 + 0x38) !\u003d (char *)0x0) {\n      sVar4 \u003d strlen(*(char **)(lVar1 + 0x38));\n      lVar8 \u003d lVar8 + sVar4;\n    }\n    pcVar6 \u003d (char *)xmalloc(lVar8);\n    lVar1 \u003d *(long *)(param_1 + 0x60);\n    strcpy(pcVar6,*(char **)(lVar1 + 8));\n    if (*(long *)(lVar1 + 0x28) !\u003d 0) {\n      uVar9 \u003d 0;\n      sVar4 \u003d strlen(pcVar6);\n      sprintf(pcVar6 + sVar4,\"!%u,\",uVar10);\n      while( true ) {\n        lVar1 \u003d *(long *)(param_1 + 0x60);\n        uVar10 \u003d (ulong)uVar9;\n        __ptr \u003d *(void **)(lVar1 + 0x28);\n        pcVar3 \u003d *(char **)((long)__ptr + uVar10 * 8);\n        if (pcVar3 \u003d\u003d (char *)0x0) break;\n        uVar9 \u003d uVar9 + 1;\n        strcat(pcVar6,pcVar3);\n        free(*(void **)(*(long *)(lVar1 + 0x28) + uVar10 * 8));\n      }\n      free(__ptr);\n      *(undefined8 *)(*(long *)(param_1 + 0x60) + 0x28) \u003d 0;\n    }\n    lVar1 \u003d *(long *)(param_1 + 0x60);\n    strcat(pcVar6,*(char **)(lVar1 + 0x20));\n    free(*(void **)(lVar1 + 0x20));\n    lVar1 \u003d *(long *)(param_1 + 0x60);\n    *(undefined8 *)(lVar1 + 0x20) \u003d 0;\n    if (*(char **)(lVar1 + 0x30) !\u003d (char *)0x0) {\n      strcat(pcVar6,*(char **)(lVar1 + 0x30));\n      free(*(void **)(lVar1 + 0x30));\n      *(undefined8 *)(*(long *)(param_1 + 0x60) + 0x30) \u003d 0;\n    }\n    sVar4 \u003d strlen(pcVar6);\n    lVar1 \u003d *(long *)(param_1 + 0x60);\n    *(undefined2 *)(pcVar6 + sVar4) \u003d 0x3b;\n    pcVar3 \u003d *(char **)(lVar1 + 0x38);\n    if (pcVar3 !\u003d (char *)0x0) {\n      strcpy(pcVar6 + sVar4 + 1,pcVar3);\n      free(*(void **)(lVar1 + 0x38));\n      *(undefined8 *)(*(long *)(param_1 + 0x60) + 0x38) \u003d 0;\n    }\n    free(*(void **)(*(long *)(param_1 + 0x60) + 8));\n    lVar1 \u003d *(long *)(param_1 + 0x60);\n    *(char **)(lVar1 + 8) \u003d pcVar6;\n    uVar7 \u003d CONCAT71((int7)((ulong)lVar1 \u003e\u003e 8),1);\n  }\n  return uVar7;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "free",
        "strcat",
        "strlen",
        "strcpy",
        "sprintf",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_find_tagged_type": {
      "entrypoint": "0x0010afd5",
      "current_name": "stab_find_tagged_type",
      "code": "\nundefined  [16]\nstab_find_tagged_type\n          (undefined8 *param_1,long param_2,undefined8 param_3,undefined4 param_4,undefined4 param_5\n          ,undefined8 param_6)\n\n{\n  int iVar1;\n  char *__s2;\n  undefined8 *puVar2;\n  undefined8 uVar3;\n  long lVar4;\n  undefined8 *puVar5;\n  undefined4 *puVar6;\n  byte bVar7;\n  undefined auVar8 [16];\n  \n  bVar7 \u003d 0;\n  __s2 \u003d (char *)savestring(param_3,param_4);\n  for (param_1 \u003d (undefined8 *)*param_1; param_1 !\u003d (undefined8 *)0x0;\n      param_1 \u003d (undefined8 *)*param_1) {\n    for (puVar2 \u003d (undefined8 *)param_1[1]; puVar2 !\u003d (undefined8 *)0x0;\n        puVar2 \u003d (undefined8 *)*puVar2) {\n      if ((undefined8 *)puVar2[2] !\u003d (undefined8 *)0x0) {\n        for (puVar5 \u003d *(undefined8 **)(undefined8 *)puVar2[2]; puVar5 !\u003d (undefined8 *)0x0;\n            puVar5 \u003d (undefined8 *)*puVar5) {\n          if ((*(int *)((long)puVar5 + 0x14) \u003d\u003d 1) \u0026\u0026 (*(char *)puVar5[1] \u003d\u003d *__s2)) {\n            iVar1 \u003d strcmp((char *)puVar5[1],__s2);\n            if (iVar1 \u003d\u003d 0) {\n              lVar4 \u003d puVar5[4];\n              if (lVar4 \u003d\u003d 0) goto LAB_0010b05b;\n              free(__s2);\n              goto LAB_0010b0eb;\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010b05b:\n  puVar2 \u003d *(undefined8 **)(param_2 + 0x1a0);\n  do {\n    if (puVar2 \u003d\u003d (undefined8 *)0x0) {\n      puVar2 \u003d (undefined8 *)xmalloc(0x28);\n      uVar3 \u003d *(undefined8 *)(param_2 + 0x1a0);\n      puVar6 \u003d (undefined4 *)((long)puVar2 + 0x14);\n      for (lVar4 \u003d 5; lVar4 !\u003d 0; lVar4 \u003d lVar4 + -1) {\n        *puVar6 \u003d 0;\n        puVar6 \u003d puVar6 + (ulong)bVar7 * -2 + 1;\n      }\n      *(undefined4 *)(puVar2 + 2) \u003d param_5;\n      *puVar2 \u003d uVar3;\n      puVar2[1] \u003d __s2;\n      uVar3 \u003d debug_make_indirect_type_isra_0(puVar2 + 3,__s2);\n      *(undefined8 **)(param_2 + 0x1a0) \u003d puVar2;\n      puVar2[4] \u003d uVar3;\nLAB_0010b0e7:\n      lVar4 \u003d puVar2[4];\nLAB_0010b0eb:\n      auVar8._8_8_ \u003d param_6;\n      auVar8._0_8_ \u003d lVar4;\n      return auVar8;\n    }\n    if (*(char *)puVar2[1] \u003d\u003d *__s2) {\n      iVar1 \u003d strcmp((char *)puVar2[1],__s2);\n      if (iVar1 \u003d\u003d 0) {\n        if (*(int *)(puVar2 + 2) \u003d\u003d 0) {\n          *(undefined4 *)(puVar2 + 2) \u003d param_5;\n        }\n        free(__s2);\n        goto LAB_0010b0e7;\n      }\n    }\n    puVar2 \u003d (undefined8 *)*puVar2;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "stab_demangle_v3_arg",
        "stab_demangle_qualified",
        "parse_stab_type"
      ],
      "called": [
        "free",
        "debug_make_indirect_type.isra.0",
        "savestring",
        "strcmp",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_demangle_v3_arg": {
      "entrypoint": "0x0010b0fa",
      "current_name": "stab_demangle_v3_arg",
      "code": "\n\n\nchar * stab_demangle_v3_arg\n                 (undefined8 param_1,undefined8 param_2,uint *param_3,long param_4,\n                 undefined *param_5)\n\n{\n  uint uVar1;\n  int iVar2;\n  char *pcVar3;\n  long *plVar4;\n  char *pcVar5;\n  size_t sVar6;\n  void *__ptr;\n  long lVar7;\n  undefined local_40 [16];\n  \n  if (param_5 !\u003d (undefined *)0x0) {\n    *param_5 \u003d 0;\n  }\n  while( true ) {\n    uVar1 \u003d *param_3;\n    if (0x29 \u003c uVar1) break;\n    if (0x17 \u003c uVar1) {\n      switch(uVar1) {\n      case 0x18:\n        goto switchD_0010b158_caseD_18;\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x22:\n      case 0x23:\n        pcVar3 \u003d (char *)stab_demangle_v3_arg(param_1,param_2,*(undefined8 *)(param_3 + 4),0,0);\n        if (pcVar3 !\u003d (char *)0x0) {\n          switch(*param_3) {\n          case 0x19:\n            goto switchD_0010b2de_caseD_19;\n          case 0x1a:\n            pcVar3 \u003d (char *)debug_make_volatile_type_isra_0(pcVar3);\n            return pcVar3;\n          case 0x1b:\n            pcVar3 \u003d (char *)debug_make_const_type_isra_0(pcVar3);\n            return pcVar3;\n          default:\n                    \n            abort();\n          case 0x22:\n            pcVar3 \u003d (char *)debug_make_pointer_type_isra_0(pcVar3);\n            return pcVar3;\n          case 0x23:\n            pcVar3 \u003d (char *)debug_make_reference_type_isra_0(pcVar3);\n            return pcVar3;\n          }\n        }\n        goto LAB_0010b38c;\n      case 0x27:\n        pcVar3 \u003d (char *)cplus_demangle_print(3,param_3,0x14,local_40);\n        if (pcVar3 \u003d\u003d (char *)0x0) {\n          pcVar5 \u003d \"Couldn\\\u0027t get demangled builtin type\\n\";\n          pcVar3 \u003d (char *)0x0;\n          goto LAB_0010b3d3;\n        }\n        iVar2 \u003d strcmp(pcVar3,\"signed char\");\n        if (iVar2 \u003d\u003d 0) {\nLAB_0010b406:\n          pcVar5 \u003d (char *)debug_make_int_type_isra_0(1,0);\n          goto LAB_0010b6c6;\n        }\n        iVar2 \u003d strcmp(pcVar3,\"bool\");\n        if (iVar2 \u003d\u003d 0) {\n          pcVar5 \u003d (char *)debug_make_type_constprop_0(6,1);\n          goto LAB_0010b6c6;\n        }\n        iVar2 \u003d strcmp(pcVar3,\"char\");\n        if (iVar2 \u003d\u003d 0) goto LAB_0010b406;\n        iVar2 \u003d strcmp(pcVar3,\"double\");\n        if ((iVar2 \u003d\u003d 0) || (iVar2 \u003d strcmp(pcVar3,\"long double\"), iVar2 \u003d\u003d 0)) {\n          pcVar5 \u003d (char *)debug_make_float_type_isra_0(8);\n          goto LAB_0010b6c6;\n        }\n        iVar2 \u003d strcmp(pcVar3,\"float\");\n        if (iVar2 \u003d\u003d 0) {\n          pcVar5 \u003d (char *)debug_make_float_type_isra_0(4);\n          goto LAB_0010b6c6;\n        }\n        iVar2 \u003d strcmp(pcVar3,\"__float128\");\n        if (iVar2 \u003d\u003d 0) {\n          pcVar5 \u003d (char *)debug_make_float_type_isra_0(0x10);\n          goto LAB_0010b6c6;\n        }\n        iVar2 \u003d strcmp(pcVar3,\"unsigned char\");\n        if (iVar2 \u003d\u003d 0) {\n          pcVar5 \u003d (char *)debug_make_int_type_isra_0(1,1);\n          goto LAB_0010b6c6;\n        }\n        iVar2 \u003d strcmp(pcVar3,\"int\");\n        if (iVar2 \u003d\u003d 0) {\nLAB_0010b504:\n          pcVar5 \u003d (char *)debug_make_int_type_isra_0(4,0);\n          goto LAB_0010b6c6;\n        }\n        iVar2 \u003d strcmp(pcVar3,\"unsigned int\");\n        if (iVar2 \u003d\u003d 0) {\nLAB_0010b528:\n          pcVar5 \u003d (char *)debug_make_int_type_isra_0(4,1);\n          goto LAB_0010b6c6;\n        }\n        iVar2 \u003d strcmp(pcVar3,\"long\");\n        if (iVar2 \u003d\u003d 0) goto LAB_0010b504;\n        iVar2 \u003d strcmp(pcVar3,\"unsigned long\");\n        if (iVar2 \u003d\u003d 0) goto LAB_0010b528;\n        iVar2 \u003d strcmp(pcVar3,\"__int128\");\n        if (iVar2 \u003d\u003d 0) {\n          pcVar5 \u003d (char *)debug_make_int_type_isra_0(0x10,0);\n          goto LAB_0010b6c6;\n        }\n        iVar2 \u003d strcmp(pcVar3,\"unsigned __int128\");\n        if (iVar2 \u003d\u003d 0) {\n          pcVar5 \u003d (char *)debug_make_int_type_isra_0(0x10,1);\n          goto LAB_0010b6c6;\n        }\n        iVar2 \u003d strcmp(pcVar3,\"short\");\n        if (iVar2 \u003d\u003d 0) {\n          pcVar5 \u003d (char *)debug_make_int_type_isra_0(2,0);\n          goto LAB_0010b6c6;\n        }\n        iVar2 \u003d strcmp(pcVar3,\"unsigned short\");\n        if (iVar2 \u003d\u003d 0) {\n          pcVar5 \u003d (char *)debug_make_int_type_isra_0(2,1);\n          goto LAB_0010b6c6;\n        }\n        iVar2 \u003d strcmp(pcVar3,\"void\");\n        if (iVar2 \u003d\u003d 0) {\n          pcVar5 \u003d (char *)debug_make_void_type_isra_0();\n          goto LAB_0010b6c6;\n        }\n        iVar2 \u003d strcmp(pcVar3,\"wchar_t\");\n        if (iVar2 \u003d\u003d 0) goto LAB_0010b528;\n        iVar2 \u003d strcmp(pcVar3,\"long long\");\n        if (iVar2 \u003d\u003d 0) {\n          pcVar5 \u003d (char *)debug_make_int_type_isra_0(8,0);\n          goto LAB_0010b6c6;\n        }\n        iVar2 \u003d strcmp(pcVar3,\"unsigned long long\");\n        if (iVar2 \u003d\u003d 0) {\n          pcVar5 \u003d (char *)debug_make_int_type_isra_0(8,1);\n          goto LAB_0010b6c6;\n        }\n        iVar2 \u003d strcmp(pcVar3,\"...\");\n        if (iVar2 \u003d\u003d 0) {\n          pcVar5 \u003d \"Unexpected demangled varargs\\n\";\n          if (param_5 \u003d\u003d (undefined *)0x0) goto LAB_0010b6a9;\n          *param_5 \u003d 1;\n        }\n        else {\n          pcVar5 \u003d \"Unrecognized demangled builtin type\\n\";\nLAB_0010b6a9:\n          pcVar5 \u003d (char *)dcgettext(0,pcVar5,5);\n          fprintf(_stderr,pcVar5);\n        }\n        pcVar5 \u003d (char *)0x0;\nLAB_0010b6c6:\n        free(pcVar3);\n        return pcVar5;\n      case 0x29:\n        if (*(long *)(param_3 + 4) \u003d\u003d 0) {\n          __ptr \u003d (void *)debug_make_void_type_isra_0();\n        }\n        else {\n          __ptr \u003d (void *)stab_demangle_v3_arg(param_1,param_2,*(long *)(param_3 + 4),0,0);\n        }\n        if (__ptr !\u003d (void *)0x0) {\n          lVar7 \u003d stab_demangle_v3_arglist(param_1,param_2,*(undefined8 *)(param_3 + 6),local_40);\n          if (lVar7 !\u003d 0) {\n            pcVar3 \u003d (char *)debug_make_function_type_isra_0(__ptr,lVar7,local_40[0]);\n            return pcVar3;\n          }\n          free(__ptr);\n        }\n        goto LAB_0010b38c;\n      }\n      break;\n    }\n    if (uVar1 !\u003d 1) {\n      if (uVar1 \u003d\u003d 4) {\n        pcVar3 \u003d (char *)cplus_demangle_print(3,param_3,0x14,local_40);\n        pcVar5 \u003d \"Failed to print demangled template\\n\";\n        if (pcVar3 !\u003d (char *)0x0) {\n          sVar6 \u003d strlen(pcVar3);\n          pcVar5 \u003d (char *)stab_find_tagged_type(param_1,param_2,pcVar3,sVar6 \u0026 0xffffffff,9);\n          free(pcVar3);\n          return pcVar5;\n        }\nLAB_0010b3d3:\n        pcVar5 \u003d (char *)dcgettext(0,pcVar5,5);\n        fprintf(_stderr,pcVar5);\n        return pcVar3;\n      }\n      if (uVar1 \u003d\u003d 0) {\n        if ((param_4 \u003d\u003d 0) ||\n           (plVar4 \u003d (long *)debug_get_fields_isra_0(param_4), plVar4 \u003d\u003d (long *)0x0))\n        goto switchD_0010b158_caseD_18;\n        goto LAB_0010b1a5;\n      }\n      break;\n    }\n    param_4 \u003d stab_demangle_v3_arg(param_1,param_2,*(undefined8 *)(param_3 + 4),param_4,0);\n    if (param_4 \u003d\u003d 0) goto LAB_0010b38c;\n    param_3 \u003d *(uint **)(param_3 + 6);\n    param_5 \u003d (undefined *)0x0;\n  }\n  pcVar3 \u003d (char *)dcgettext(0,\"Unrecognized demangle component %d\\n\",5);\n  fprintf(_stderr,pcVar3,(ulong)uVar1);\nLAB_0010b38c:\n  pcVar3 \u003d (char *)0x0;\nswitchD_0010b2de_caseD_19:\n  return pcVar3;\nLAB_0010b1a5:\n  if (*plVar4 \u003d\u003d 0) {\nswitchD_0010b158_caseD_18:\n    pcVar3 \u003d (char *)stab_find_tagged_type\n                               (param_1,param_2,*(undefined8 *)(param_3 + 4),param_3[6],0);\n    return pcVar3;\n  }\n  pcVar3 \u003d *(char **)(*plVar4 + 8);\n  if (pcVar3 \u003d\u003d (char *)0x0) goto LAB_0010b38c;\n  pcVar5 \u003d (char *)debug_get_type_name_constprop_0(pcVar3);\n  if (pcVar5 !\u003d (char *)0x0) {\n    sVar6 \u003d strlen(pcVar5);\n    if ((param_3[6] \u003d\u003d (uint)sVar6) \u0026\u0026\n       (iVar2 \u003d strncmp(pcVar5,*(char **)(param_3 + 4),(long)(int)param_3[6]), iVar2 \u003d\u003d 0)) {\n      return pcVar3;\n    }\n  }\n  plVar4 \u003d plVar4 + 1;\n  goto LAB_0010b1a5;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_v3_arg",
        "stab_demangle_v3_arglist"
      ],
      "called": [
        "debug_make_type.constprop.0",
        "free",
        "debug_make_float_type.isra.0",
        "strlen",
        "stab_demangle_v3_arglist",
        "abort",
        "debug_get_type_name.constprop.0",
        "fprintf",
        "debug_get_fields.isra.0",
        "debug_make_function_type.isra.0",
        "cplus_demangle_print",
        "debug_make_void_type.isra.0",
        "dcgettext",
        "strncmp",
        "stab_find_tagged_type",
        "stab_demangle_v3_arg",
        "strcmp",
        "debug_make_int_type.isra.0",
        "debug_make_reference_type.isra.0",
        "debug_make_volatile_type.isra.0",
        "debug_make_const_type.isra.0",
        "debug_make_pointer_type.isra.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_demangle_v3_arglist": {
      "entrypoint": "0x0010b6ea",
      "current_name": "stab_demangle_v3_arglist",
      "code": "\n\n\nvoid * stab_demangle_v3_arglist\n                 (undefined8 param_1,undefined8 param_2,int *param_3,undefined *param_4)\n\n{\n  void *__ptr;\n  char *__format;\n  long lVar1;\n  ulong uVar2;\n  ulong uVar3;\n  uint uVar4;\n  char local_39 [9];\n  \n  uVar3 \u003d 10;\n  uVar2 \u003d 0;\n  __ptr \u003d (void *)xmalloc(0x50);\n  *param_4 \u003d 0;\n  for (; param_3 !\u003d (int *)0x0; param_3 \u003d *(int **)(param_3 + 6)) {\n    if (*param_3 !\u003d 0x2e) {\n      __format \u003d (char *)dcgettext(0,\"Unexpected type in v3 arglist demangling\\n\",5);\n      fprintf(_stderr,__format);\n      free(__ptr);\n      return (void *)0x0;\n    }\n    if (*(long *)(param_3 + 4) \u003d\u003d 0) break;\n    lVar1 \u003d stab_demangle_v3_arg(param_1,param_2,*(long *)(param_3 + 4),0,local_39);\n    if (lVar1 \u003d\u003d 0) {\n      if (local_39[0] \u003d\u003d \u0027\\0\u0027) {\n        free(__ptr);\n        return (void *)0x0;\n      }\n      *param_4 \u003d 1;\n    }\n    else {\n      uVar4 \u003d (int)uVar2 + 1;\n      if ((uint)uVar3 \u003c\u003d uVar4) {\n        uVar3 \u003d (ulong)((uint)uVar3 + 10);\n        __ptr \u003d (void *)xrealloc(__ptr,uVar3 \u003c\u003c 3);\n      }\n      *(long *)((long)__ptr + uVar2 * 8) \u003d lVar1;\n      uVar2 \u003d (ulong)uVar4;\n    }\n  }\n  *(undefined8 *)((long)__ptr + uVar2 * 8) \u003d 0;\n  return __ptr;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_v3_arg",
        "parse_stab_type"
      ],
      "called": [
        "fprintf",
        "free",
        "dcgettext",
        "xrealloc",
        "stab_demangle_v3_arg",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_int_type.lto_priv.0": {
      "entrypoint": "0x0010b800",
      "current_name": "stab_int_type.lto_priv.0",
      "code": "\nundefined8 stab_int_type_lto_priv_0(long param_1,int param_2,char param_3)\n\n{\n  long *plVar1;\n  undefined8 uVar2;\n  size_t sVar3;\n  long lVar4;\n  long lVar5;\n  undefined2 local_8c;\n  undefined4 auStack_8a [24];\n  \n  if (param_2 - 1U \u003c 8) {\n    lVar4 \u003d param_1 + 0xb8;\n    if (param_3 !\u003d \u0027\\0\u0027) {\n      lVar4 \u003d param_1 + 0x78;\n    }\n    plVar1 \u003d (long *)(lVar4 + (ulong)(param_2 - 1U) * 8);\n    lVar4 \u003d *plVar1;\n    if (lVar4 !\u003d 0) {\n      uVar2 \u003d stab_push_defined_type(param_1,lVar4,param_2);\n      return uVar2;\n    }\n    lVar4 \u003d *(long *)(param_1 + 0x68);\n    *(long *)(param_1 + 0x68) \u003d lVar4 + 1;\n    *plVar1 \u003d lVar4;\n    sprintf((char *)\u0026local_8c,\"%ld\u003dr%ld;\",lVar4,lVar4);\n    if (param_3 \u003d\u003d \u0027\\0\u0027) {\n      lVar5 \u003d 1L \u003c\u003c ((char)param_2 * \u0027\\b\u0027 - 1U \u0026 0x3f);\n      sVar3 \u003d strlen((char *)\u0026local_8c);\n      sprintf((char *)((long)\u0026local_8c + sVar3),\"%ld;%ld;\",-lVar5,lVar5 + -1);\n    }\n    else {\n      sVar3 \u003d strlen((char *)\u0026local_8c);\n      *(undefined2 *)((long)\u0026local_8c + sVar3) \u003d 0x3b30;\n      *(undefined *)((long)\u0026local_8c + sVar3 + 2) \u003d 0;\n      if (param_2 \u003d\u003d 8) {\n        *(undefined4 *)((long)\u0026local_8c + sVar3 + 2) \u003d 0x3b312d;\n      }\n      else {\n        sprintf((char *)((long)\u0026local_8c + sVar3 + 2),\"%ld;\",\n                (1L \u003c\u003c ((char)param_2 * \u0027\\b\u0027 \u0026 0x3fU)) + -1);\n      }\n    }\n    uVar2 \u003d stab_push_string(param_1,\u0026local_8c,lVar4,1,param_2);\n  }\n  else {\n    uVar2 \u003d dcgettext(0,\"stab_int_type: bad size %u\",5);\n    non_fatal(uVar2,param_2);\n    uVar2 \u003d 0;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_float_type.lto_priv.0",
        "debug_write_type.constprop.0"
      ],
      "called": [
        "non_fatal",
        "strlen",
        "dcgettext",
        "stab_push_defined_type",
        "stab_push_string",
        "sprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_float_type.lto_priv.0": {
      "entrypoint": "0x0010b948",
      "current_name": "stab_float_type.lto_priv.0",
      "code": "\nvoid stab_float_type_lto_priv_0(long param_1,uint param_2)\n\n{\n  long lVar1;\n  char cVar2;\n  void *__ptr;\n  ulong uVar3;\n  uint uVar4;\n  char local_5a [50];\n  \n  uVar4 \u003d param_2 - 1;\n  uVar3 \u003d (ulong)param_2;\n  if ((uVar4 \u003c 0x10) \u0026\u0026 (lVar1 \u003d *(long *)(param_1 + 0xf8 + (ulong)uVar4 * 8), lVar1 !\u003d 0)) {\n    stab_push_defined_type(param_1,lVar1,uVar3);\n    return;\n  }\n  cVar2 \u003d stab_int_type_lto_priv_0(param_1,4,0);\n  if (cVar2 !\u003d \u0027\\0\u0027) {\n    __ptr \u003d (void *)stab_pop_type(param_1);\n    lVar1 \u003d *(long *)(param_1 + 0x68);\n    *(long *)(param_1 + 0x68) \u003d lVar1 + 1;\n    if (uVar4 \u003c 0x10) {\n      *(long *)(param_1 + 0xf8 + (ulong)uVar4 * 8) \u003d lVar1;\n    }\n    sprintf(local_5a,\"%ld\u003dr%s;%u;0;\",lVar1,__ptr,uVar3);\n    free(__ptr);\n    stab_push_string(param_1,local_5a,lVar1,1,uVar3);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "stab_int_type.lto_priv.0",
        "free",
        "stab_push_defined_type",
        "stab_push_string",
        "sprintf",
        "stab_pop_type"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_struct_field.lto_priv.0": {
      "entrypoint": "0x0010ba08",
      "current_name": "stab_struct_field.lto_priv.0",
      "code": "\nundefined8\nstab_struct_field_lto_priv_0\n          (undefined8 *param_1,char *param_2,undefined8 param_3,ulong param_4,int param_5)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  char *__s;\n  size_t sVar4;\n  size_t sVar5;\n  size_t sVar6;\n  char *__s_00;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  char *pcVar9;\n  \n  cVar1 \u003d *(char *)(param_1[0xc] + 0x1c);\n  iVar2 \u003d *(int *)(param_1[0xc] + 0x18);\n  __s \u003d (char *)stab_pop_type();\n  if (*(char **)(param_1[0xc] + 0x20) \u003d\u003d (char *)0x0) {\n    uVar8 \u003d 0;\n  }\n  else {\n    sVar4 \u003d strlen(*(char **)(param_1[0xc] + 0x20));\n    sVar5 \u003d strlen(param_2);\n    sVar6 \u003d strlen(__s);\n    __s_00 \u003d (char *)xmalloc(sVar4 + 0x32 + sVar5 + sVar6);\n    if (param_5 \u003d\u003d 1) {\n      pcVar9 \u003d \"/1\";\n    }\n    else {\n      pcVar9 \u003d \"/0\";\n      if ((param_5 !\u003d 2) \u0026\u0026 (pcVar9 \u003d \"\", param_5 !\u003d 0)) {\n                    \n        abort();\n      }\n    }\n    if ((param_4 \u003d\u003d 0) \u0026\u0026 (param_4 \u003d (ulong)(uint)(iVar2 * 8), param_4 \u003d\u003d 0)) {\n      uVar8 \u003d *(undefined8 *)*param_1;\n      uVar7 \u003d dcgettext(0,\"%s: warning: unknown size for field `%s\\\u0027 in struct\",5);\n      non_fatal(uVar7,uVar8,param_2);\n    }\n    sprintf(__s_00,\"%s%s:%s%s,%ld,%ld;\",*(undefined8 *)(param_1[0xc] + 0x20),param_2,pcVar9,__s,\n            param_3,param_4);\n    free(*(void **)(param_1[0xc] + 0x20));\n    lVar3 \u003d param_1[0xc];\n    *(char **)(lVar3 + 0x20) \u003d __s_00;\n    if (cVar1 !\u003d \u0027\\0\u0027) {\n      *(undefined *)(lVar3 + 0x1c) \u003d 1;\n    }\n    uVar8 \u003d CONCAT71((int7)((ulong)lVar3 \u003e\u003e 8),1);\n  }\n  return uVar8;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "non_fatal",
        "free",
        "strlen",
        "dcgettext",
        "abort",
        "sprintf",
        "stab_pop_type",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "string_hash_newfunc.lto_priv.0": {
      "entrypoint": "0x0010bb52",
      "current_name": "string_hash_newfunc.lto_priv.0",
      "code": "\nlong string_hash_newfunc_lto_priv_0(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  long lVar1;\n  \n  if (((param_1 !\u003d 0) || (param_1 \u003d bfd_hash_allocate(param_2,0x30), param_1 !\u003d 0)) \u0026\u0026\n     (lVar1 \u003d bfd_hash_newfunc(param_1,param_2,param_3), lVar1 !\u003d 0)) {\n    *(undefined8 *)(lVar1 + 0x20) \u003d 0xffffffffffffffff;\n    *(undefined8 *)(lVar1 + 0x18) \u003d 0;\n    *(undefined4 *)(lVar1 + 0x28) \u003d 0;\n    return lVar1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "write_stabs_in_sections_debugging_info.constprop.0"
      ],
      "called": [
        "bfd_hash_newfunc",
        "bfd_hash_allocate"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_typedef_type.lto_priv.0": {
      "entrypoint": "0x0010bba1",
      "current_name": "stab_typedef_type.lto_priv.0",
      "code": "\nundefined8 stab_typedef_type_lto_priv_0(long param_1,undefined8 param_2)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  \n  lVar1 \u003d bfd_hash_lookup(param_1 + 0x1b8,param_2,0,0);\n  if ((lVar1 !\u003d 0) \u0026\u0026 (0 \u003c *(long *)(lVar1 + 0x20))) {\n    uVar2 \u003d stab_push_defined_type(param_1,*(long *)(lVar1 + 0x20),*(undefined4 *)(lVar1 + 0x28));\n    return uVar2;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "stab_push_defined_type",
        "bfd_hash_lookup"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_set_filename": {
      "entrypoint": "0x0010bbd3",
      "current_name": "debug_set_filename",
      "code": "\nundefined  [16]\ndebug_set_filename(long *param_1,char *param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  undefined8 *puVar1;\n  undefined4 *puVar2;\n  undefined4 *puVar3;\n  long lVar4;\n  undefined4 *puVar5;\n  char *pcVar6;\n  byte bVar7;\n  undefined auVar8 [16];\n  \n  bVar7 \u003d 0;\n  pcVar6 \u003d \"\";\n  if (param_2 !\u003d (char *)0x0) {\n    pcVar6 \u003d param_2;\n  }\n  puVar2 \u003d (undefined4 *)xmalloc(0x18);\n  puVar5 \u003d puVar2;\n  for (lVar4 \u003d 6; lVar4 !\u003d 0; lVar4 \u003d lVar4 + -1) {\n    *puVar5 \u003d 0;\n    puVar5 \u003d puVar5 + (ulong)bVar7 * -2 + 1;\n  }\n  *(char **)(puVar2 + 2) \u003d pcVar6;\n  puVar3 \u003d (undefined4 *)xmalloc(0x18);\n  param_1[2] \u003d (long)puVar2;\n  puVar5 \u003d puVar3;\n  for (lVar4 \u003d 6; lVar4 !\u003d 0; lVar4 \u003d lVar4 + -1) {\n    *puVar5 \u003d 0;\n    puVar5 \u003d puVar5 + (ulong)bVar7 * -2 + 1;\n  }\n  puVar1 \u003d (undefined8 *)param_1[1];\n  *(undefined4 **)(puVar3 + 2) \u003d puVar2;\n  if (puVar1 \u003d\u003d (undefined8 *)0x0) {\n    if (*param_1 !\u003d 0) {\n                    \n      __assert_fail(\"info-\u003eunits \u003d\u003d NULL\",\"../../binutils/debug.c\",699,\"debug_set_filename\");\n    }\n    *param_1 \u003d (long)puVar3;\n  }\n  else {\n    *puVar1 \u003d puVar3;\n  }\n  param_1[1] \u003d (long)puVar3;\n  param_1[5] \u003d 0;\n  *(undefined (*) [16])(param_1 + 3) \u003d ZEXT816(0);\n  auVar8._8_8_ \u003d param_4;\n  auVar8._0_8_ \u003d 1;\n  return auVar8;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_stab",
        "FUN_0010554f"
      ],
      "called": [
        "__assert_fail",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_record_function": {
      "entrypoint": "0x0010bc80",
      "current_name": "debug_record_function",
      "code": "\n\n\nundefined  [16]\ndebug_record_function\n          (long param_1,char *param_2,long param_3,uint param_4,undefined8 param_5,\n          undefined8 param_6)\n\n{\n  undefined8 uVar1;\n  long *plVar2;\n  undefined4 *puVar3;\n  long lVar4;\n  undefined4 *puVar5;\n  char *pcVar6;\n  byte bVar7;\n  undefined auVar8 [16];\n  \n  bVar7 \u003d 0;\n  pcVar6 \u003d \"\";\n  if (param_2 !\u003d (char *)0x0) {\n    pcVar6 \u003d param_2;\n  }\n  if (param_3 !\u003d 0) {\n    if (*(long *)(param_1 + 8) \u003d\u003d 0) {\n      uVar1 \u003d dcgettext(0,\"debug_record_function: no debug_set_filename call\",5);\n      fprintf(_stderr,\"%s\\n\",uVar1);\n    }\n    else {\n      plVar2 \u003d (long *)xmalloc(0x18);\n      *plVar2 \u003d param_3;\n      *(undefined (*) [16])(plVar2 + 1) \u003d ZEXT816(0);\n      puVar3 \u003d (undefined4 *)xmalloc(0x30);\n      *(long **)(param_1 + 0x18) \u003d plVar2;\n      plVar2[2] \u003d (long)puVar3;\n      puVar5 \u003d puVar3;\n      for (lVar4 \u003d 0xc; lVar4 !\u003d 0; lVar4 \u003d lVar4 + -1) {\n        *puVar5 \u003d 0;\n        puVar5 \u003d puVar5 + (ulong)bVar7 * -2 + 1;\n      }\n      *(undefined4 **)(param_1 + 0x20) \u003d puVar3;\n      lVar4 \u003d *(long *)(param_1 + 0x10);\n      *(undefined8 *)(puVar3 + 6) \u003d param_5;\n      *(undefined8 *)(puVar3 + 8) \u003d 0xffffffffffffffff;\n      lVar4 \u003d debug_add_to_namespace_constprop_0(lVar4 + 0x10,pcVar6,3,(param_4 \u0026 0xff) + 1);\n      if (lVar4 !\u003d 0) {\n        *(long **)(lVar4 + 0x20) \u003d plVar2;\n        uVar1 \u003d CONCAT71((int7)((ulong)lVar4 \u003e\u003e 8),1);\n        goto LAB_0010bd56;\n      }\n    }\n  }\n  uVar1 \u003d 0;\nLAB_0010bd56:\n  auVar8._8_8_ \u003d param_6;\n  auVar8._0_8_ \u003d uVar1;\n  return auVar8;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_stab",
        "FUN_0010554f"
      ],
      "called": [
        "fprintf",
        "debug_add_to_namespace.constprop.0",
        "dcgettext",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_record_parameter": {
      "entrypoint": "0x0010bd62",
      "current_name": "debug_record_parameter",
      "code": "\n\n\nundefined8\ndebug_record_parameter(long param_1,long param_2,long param_3,undefined4 param_4,undefined8 param_5)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  undefined4 *puVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  undefined8 *puVar6;\n  undefined4 *puVar7;\n  byte bVar8;\n  \n  bVar8 \u003d 0;\n  if (param_2 \u003d\u003d 0) {\n    return 0;\n  }\n  if (param_3 !\u003d 0) {\n    if ((*(long *)(param_1 + 8) !\u003d 0) \u0026\u0026 (*(long *)(param_1 + 0x18) !\u003d 0)) {\n      puVar3 \u003d (undefined4 *)xmalloc(0x28);\n      puVar7 \u003d puVar3;\n      for (lVar5 \u003d 10; lVar5 !\u003d 0; lVar5 \u003d lVar5 + -1) {\n        *puVar7 \u003d 0;\n        puVar7 \u003d puVar7 + (ulong)bVar8 * -2 + 1;\n      }\n      lVar5 \u003d *(long *)(param_1 + 0x18);\n      *(long *)(puVar3 + 2) \u003d param_2;\n      *(long *)(puVar3 + 4) \u003d param_3;\n      puVar3[6] \u003d param_4;\n      puVar1 \u003d *(undefined8 **)(lVar5 + 8);\n      *(undefined8 *)(puVar3 + 8) \u003d param_5;\n      puVar6 \u003d (undefined8 *)(lVar5 + 8);\n      while (puVar4 \u003d puVar1, puVar4 !\u003d (undefined8 *)0x0) {\n        puVar6 \u003d puVar4;\n        puVar1 \u003d (undefined8 *)*puVar4;\n      }\n      *puVar6 \u003d puVar3;\n      return 1;\n    }\n    uVar2 \u003d dcgettext(0,\"debug_record_parameter: no current function\",5);\n    fprintf(_stderr,\"%s\\n\",uVar2);\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_coff_symbol.constprop.0.isra.0",
        "parse_stab"
      ],
      "called": [
        "fprintf",
        "dcgettext",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_end_function": {
      "entrypoint": "0x0010be1a",
      "current_name": "debug_end_function",
      "code": "\n\n\nundefined  [16]\ndebug_end_function(long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  undefined auVar4 [16];\n  \n  if (((*(long *)(param_1 + 8) \u003d\u003d 0) || (lVar1 \u003d *(long *)(param_1 + 0x20), lVar1 \u003d\u003d 0)) ||\n     (*(long *)(param_1 + 0x18) \u003d\u003d 0)) {\n    pcVar3 \u003d \"debug_end_function: no current function\";\n  }\n  else {\n    if (*(long *)(lVar1 + 8) \u003d\u003d 0) {\n      *(undefined8 *)(lVar1 + 0x20) \u003d param_2;\n      uVar2 \u003d CONCAT71((int7)((ulong)lVar1 \u003e\u003e 8),1);\n      *(undefined (*) [16])(param_1 + 0x18) \u003d ZEXT816(0);\n      goto LAB_0010be86;\n    }\n    pcVar3 \u003d \"debug_end_function: some blocks were not closed\";\n  }\n  uVar2 \u003d dcgettext(0,pcVar3,5);\n  fprintf(_stderr,\"%s\\n\",uVar2);\n  uVar2 \u003d 0;\nLAB_0010be86:\n  auVar4._8_8_ \u003d param_4;\n  auVar4._0_8_ \u003d uVar2;\n  return auVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "finish_stab",
        "parse_stab",
        "FUN_0010554f"
      ],
      "called": [
        "fprintf",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_start_block": {
      "entrypoint": "0x0010be88",
      "current_name": "debug_start_block",
      "code": "\n\n\nundefined  [16]\ndebug_start_block(long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  undefined8 *puVar1;\n  undefined8 uVar2;\n  undefined4 *puVar3;\n  undefined8 *puVar4;\n  long lVar5;\n  undefined8 *puVar6;\n  undefined4 *puVar7;\n  byte bVar8;\n  undefined auVar9 [16];\n  \n  bVar8 \u003d 0;\n  if ((*(long *)(param_1 + 8) \u003d\u003d 0) || (*(long *)(param_1 + 0x20) \u003d\u003d 0)) {\n    uVar2 \u003d dcgettext(0,\"debug_start_block: no current block\",5);\n    fprintf(_stderr,\"%s\\n\",uVar2);\n    uVar2 \u003d 0;\n  }\n  else {\n    puVar3 \u003d (undefined4 *)xmalloc(0x30);\n    puVar7 \u003d puVar3;\n    for (lVar5 \u003d 0xc; lVar5 !\u003d 0; lVar5 \u003d lVar5 + -1) {\n      *puVar7 \u003d 0;\n      puVar7 \u003d puVar7 + (ulong)bVar8 * -2 + 1;\n    }\n    lVar5 \u003d *(long *)(param_1 + 0x20);\n    *(undefined8 *)(puVar3 + 6) \u003d param_2;\n    *(undefined8 *)(puVar3 + 8) \u003d 0xffffffffffffffff;\n    *(long *)(puVar3 + 2) \u003d lVar5;\n    puVar1 \u003d *(undefined8 **)(lVar5 + 0x10);\n    puVar6 \u003d (undefined8 *)(lVar5 + 0x10);\n    while (puVar4 \u003d puVar1, puVar4 !\u003d (undefined8 *)0x0) {\n      puVar6 \u003d puVar4;\n      puVar1 \u003d (undefined8 *)*puVar4;\n    }\n    *puVar6 \u003d puVar3;\n    uVar2 \u003d 1;\n    *(undefined4 **)(param_1 + 0x20) \u003d puVar3;\n  }\n  auVar9._8_8_ \u003d param_4;\n  auVar9._0_8_ \u003d uVar2;\n  return auVar9;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_stab",
        "FUN_0010554f"
      ],
      "called": [
        "fprintf",
        "dcgettext",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_end_block": {
      "entrypoint": "0x0010bf20",
      "current_name": "debug_end_block",
      "code": "\n\n\nundefined  [16]\ndebug_end_block(long param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  undefined auVar4 [16];\n  \n  if ((*(long *)(param_1 + 8) \u003d\u003d 0) || (lVar1 \u003d *(long *)(param_1 + 0x20), lVar1 \u003d\u003d 0)) {\n    pcVar3 \u003d \"debug_end_block: no current block\";\n  }\n  else {\n    if (*(long *)(lVar1 + 8) !\u003d 0) {\n      *(undefined8 *)(lVar1 + 0x20) \u003d param_2;\n      uVar2 \u003d CONCAT71((int7)((ulong)lVar1 \u003e\u003e 8),1);\n      *(long *)(param_1 + 0x20) \u003d *(long *)(lVar1 + 8);\n      goto LAB_0010bf84;\n    }\n    pcVar3 \u003d \"debug_end_block: attempt to close top level block\";\n  }\n  uVar2 \u003d dcgettext(0,pcVar3,5);\n  fprintf(_stderr,\"%s\\n\",uVar2);\n  uVar2 \u003d 0;\nLAB_0010bf84:\n  auVar4._8_8_ \u003d param_4;\n  auVar4._0_8_ \u003d uVar2;\n  return auVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_stab",
        "FUN_0010554f"
      ],
      "called": [
        "fprintf",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_record_line": {
      "entrypoint": "0x0010bf86",
      "current_name": "debug_record_line",
      "code": "\n\n\nundefined8 debug_record_line(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 uVar1;\n  undefined8 *puVar2;\n  ulong uVar3;\n  undefined4 *puVar4;\n  long lVar5;\n  undefined4 *puVar6;\n  byte bVar7;\n  \n  bVar7 \u003d 0;\n  if (*(long *)(param_1 + 8) \u003d\u003d 0) {\n    uVar1 \u003d dcgettext(0,\"debug_record_line: no current unit\",5);\n    fprintf(_stderr,\"%s\\n\",uVar1);\n    uVar1 \u003d 0;\n  }\n  else {\n    lVar5 \u003d *(long *)(param_1 + 0x28);\n    if ((lVar5 !\u003d 0) \u0026\u0026 (*(long *)(lVar5 + 8) \u003d\u003d *(long *)(param_1 + 0x10))) {\n      uVar3 \u003d 0;\n      do {\n        if (*(long *)(lVar5 + 0x10 + uVar3 * 8) \u003d\u003d -1) {\n          puVar2 \u003d (undefined8 *)(uVar3 \u0026 0xffffffff);\n          *(undefined8 *)(lVar5 + 0x10 + (long)puVar2 * 8) \u003d param_2;\n          *(undefined8 *)(lVar5 + 0x60 + (long)puVar2 * 8) \u003d param_3;\n          goto LAB_0010c056;\n        }\n        uVar3 \u003d uVar3 + 1;\n      } while (uVar3 !\u003d 10);\n    }\n    puVar4 \u003d (undefined4 *)xmalloc(0xb0);\n    puVar6 \u003d puVar4;\n    for (lVar5 \u003d 0x2c; lVar5 !\u003d 0; lVar5 \u003d lVar5 + -1) {\n      *puVar6 \u003d 0;\n      puVar6 \u003d puVar6 + (ulong)bVar7 * -2 + 1;\n    }\n    uVar1 \u003d *(undefined8 *)(param_1 + 0x10);\n    *(undefined8 *)(puVar4 + 4) \u003d param_2;\n    *(undefined8 *)(puVar4 + 2) \u003d uVar1;\n    *(undefined8 *)(puVar4 + 0x18) \u003d param_3;\n    puVar6 \u003d puVar4 + 6;\n    for (lVar5 \u003d 0x48; lVar5 !\u003d 0; lVar5 \u003d lVar5 + -1) {\n      *(undefined *)puVar6 \u003d 0xff;\n      puVar6 \u003d (undefined4 *)((long)puVar6 + (ulong)bVar7 * -2 + 1);\n    }\n    puVar2 \u003d *(undefined8 **)(param_1 + 0x28);\n    if (puVar2 \u003d\u003d (undefined8 *)0x0) {\n      puVar2 \u003d *(undefined8 **)(param_1 + 8);\n      puVar2[2] \u003d puVar4;\n    }\n    else {\n      *puVar2 \u003d puVar4;\n    }\n    *(undefined4 **)(param_1 + 0x28) \u003d puVar4;\nLAB_0010c056:\n    uVar1 \u003d CONCAT71((int7)((ulong)puVar2 \u003e\u003e 8),1);\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_stab",
        "FUN_0010554f"
      ],
      "called": [
        "fprintf",
        "dcgettext",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_record_variable": {
      "entrypoint": "0x0010c05d",
      "current_name": "debug_record_variable",
      "code": "\n\n\nundefined  [16]\ndebug_record_variable\n          (long param_1,long param_2,ulong param_3,int param_4,undefined8 param_5,undefined8 param_6\n          )\n\n{\n  undefined auVar1 [16];\n  undefined8 uVar2;\n  int *piVar3;\n  char cVar4;\n  long lVar5;\n  long lVar6;\n  int *piVar7;\n  byte bVar8;\n  undefined auVar9 [16];\n  \n  bVar8 \u003d 0;\n  if (param_2 \u003d\u003d 0) {\n    auVar1._8_8_ \u003d 0;\n    auVar1._0_8_ \u003d param_3;\n    return auVar1 \u003c\u003c 0x40;\n  }\n  if (param_3 !\u003d 0) {\n    if ((*(long *)(param_1 + 8) \u003d\u003d 0) || (lVar6 \u003d *(long *)(param_1 + 0x10), lVar6 \u003d\u003d 0)) {\n      uVar2 \u003d dcgettext(0,\"debug_record_variable: no current file\",5);\n      fprintf(_stderr,\"%s\\n\",uVar2);\n    }\n    else {\n      if (param_4 - 1U \u003c 2) {\n        lVar6 \u003d lVar6 + 0x10;\n        cVar4 \u003d (param_4 \u003d\u003d 1) + \u0027\\x01\u0027;\n      }\n      else if (*(long *)(param_1 + 0x20) \u003d\u003d 0) {\n        lVar6 \u003d lVar6 + 0x10;\n        cVar4 \u003d \u0027\\0\u0027;\n      }\n      else {\n        lVar6 \u003d *(long *)(param_1 + 0x20) + 0x28;\n        cVar4 \u003d \u0027\\0\u0027;\n      }\n      lVar6 \u003d debug_add_to_namespace_constprop_0(lVar6,param_2,2,cVar4);\n      if (lVar6 !\u003d 0) {\n        piVar3 \u003d (int *)xmalloc(0x18);\n        piVar7 \u003d piVar3 + 1;\n        for (lVar5 \u003d 5; lVar5 !\u003d 0; lVar5 \u003d lVar5 + -1) {\n          *piVar7 \u003d 0;\n          piVar7 \u003d piVar7 + (ulong)bVar8 * -2 + 1;\n        }\n        *piVar3 \u003d param_4;\n        uVar2 \u003d 1;\n        *(ulong *)(piVar3 + 2) \u003d param_3;\n        *(undefined8 *)(piVar3 + 4) \u003d param_5;\n        *(int **)(lVar6 + 0x20) \u003d piVar3;\n        goto LAB_0010c12e;\n      }\n    }\n  }\n  uVar2 \u003d 0;\nLAB_0010c12e:\n  auVar9._8_8_ \u003d param_6;\n  auVar9._0_8_ \u003d uVar2;\n  return auVar9;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_coff_symbol.constprop.0.isra.0",
        "stab_record_variable",
        "parse_stab",
        "stab_emit_pending_vars"
      ],
      "called": [
        "fprintf",
        "debug_add_to_namespace.constprop.0",
        "dcgettext",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_record_variable": {
      "entrypoint": "0x0010c139",
      "current_name": "stab_record_variable",
      "code": "\nulong stab_record_variable\n                (undefined8 param_1,long param_2,undefined8 param_3,undefined8 param_4,\n                undefined4 param_5,undefined8 param_6)\n\n{\n  undefined8 uVar1;\n  char cVar2;\n  ulong uVar3;\n  undefined8 *puVar4;\n  undefined8 in_R10;\n  undefined8 unaff_R15;\n  \n  cVar2 \u003d *(char *)(param_2 + 0x60);\n  if ((cVar2 !\u003d \u0027\\0\u0027) \u0026\u0026 ((*(int *)(param_2 + 0x40) !\u003d 0 || (*(char *)(param_2 + 0x44) \u003d\u003d \u0027\\0\u0027)))) {\n    puVar4 \u003d (undefined8 *)xmalloc(0x28);\n    uVar1 \u003d *(undefined8 *)(param_2 + 0x78);\n    *(undefined8 *)((long)puVar4 + 0x1c) \u003d 0;\n    puVar4[2] \u003d param_4;\n    *(undefined4 *)(puVar4 + 3) \u003d param_5;\n    puVar4[4] \u003d param_6;\n    *(undefined8 **)(param_2 + 0x78) \u003d puVar4;\n    *puVar4 \u003d uVar1;\n    puVar4[1] \u003d param_3;\n    return CONCAT71((int7)((ulong)unaff_R15 \u003e\u003e 8),cVar2) \u0026 0xffffffff;\n  }\n  uVar3 \u003d debug_record_variable(param_1,param_3,param_4,param_5,param_6,in_R10);\n  return uVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_stab"
      ],
      "called": [
        "debug_record_variable",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_emit_pending_vars": {
      "entrypoint": "0x0010c1c6",
      "current_name": "stab_emit_pending_vars",
      "code": "\nundefined stab_emit_pending_vars\n                    (undefined8 param_1,long param_2,undefined8 param_3,undefined8 param_4,\n                    undefined8 param_5,undefined8 param_6)\n\n{\n  undefined8 *puVar1;\n  char cVar2;\n  undefined8 *__ptr;\n  \n  __ptr \u003d *(undefined8 **)(param_2 + 0x78);\n  while( true ) {\n    if (__ptr \u003d\u003d (undefined8 *)0x0) {\n      *(undefined8 *)(param_2 + 0x78) \u003d 0;\n      return 1;\n    }\n    cVar2 \u003d debug_record_variable\n                      (param_1,__ptr[1],__ptr[2],*(undefined4 *)(__ptr + 3),__ptr[4],param_6,param_5\n                      );\n    if (cVar2 \u003d\u003d \u0027\\0\u0027) break;\n    puVar1 \u003d (undefined8 *)*__ptr;\n    free(__ptr);\n    __ptr \u003d puVar1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "finish_stab",
        "parse_stab"
      ],
      "called": [
        "free",
        "debug_record_variable"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_name_type": {
      "entrypoint": "0x0010c218",
      "current_name": "debug_name_type",
      "code": "\n\n\nlong debug_name_type(long param_1,long param_2,long param_3)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  undefined (*pauVar3) [16];\n  long lVar4;\n  \n  if ((param_2 !\u003d 0) \u0026\u0026 (param_3 !\u003d 0)) {\n    if ((*(long *)(param_1 + 8) \u003d\u003d 0) || (*(long *)(param_1 + 0x10) \u003d\u003d 0)) {\n      uVar1 \u003d dcgettext(0,\"debug_name_type: no current file\",5);\n      fprintf(_stderr,\"%s\\n\",uVar1);\n    }\n    else {\n      lVar2 \u003d debug_make_type_constprop_0(0x16,0);\n      if (lVar2 !\u003d 0) {\n        pauVar3 \u003d (undefined (*) [16])xmalloc(0x10);\n        lVar4 \u003d *(long *)(param_1 + 0x10);\n        *pauVar3 \u003d ZEXT816(0);\n        *(long *)(*pauVar3 + 8) \u003d param_3;\n        *(undefined (**) [16])(lVar2 + 0x10) \u003d pauVar3;\n        lVar4 \u003d debug_add_to_namespace_constprop_0(lVar4 + 0x10,param_2,0,3);\n        if (lVar4 !\u003d 0) {\n          *(long *)(lVar4 + 0x20) \u003d lVar2;\n          *(long *)*pauVar3 \u003d lVar4;\n          return lVar2;\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_coff_symbol.constprop.0.isra.0",
        "parse_stab",
        "stab_find_type",
        "parse_coff_type.lto_priv.0"
      ],
      "called": [
        "fprintf",
        "debug_make_type.constprop.0",
        "debug_add_to_namespace.constprop.0",
        "dcgettext",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_find_type": {
      "entrypoint": "0x0010c2d2",
      "current_name": "stab_find_type",
      "code": "\n\n\nlong stab_find_type(undefined8 param_1,long param_2,int *param_3)\n\n{\n  uint uVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  long lVar4;\n  long *plVar5;\n  uint uVar6;\n  \n  if ((*param_3 \u003d\u003d 0) \u0026\u0026 (uVar1 \u003d param_3[1], (int)uVar1 \u003c 0)) {\n    uVar6 \u003d ~uVar1;\n    if (uVar6 \u003c 0x22) {\n      lVar4 \u003d *(long *)(param_2 + 0x90 + (ulong)uVar6 * 8);\n      if (lVar4 \u003d\u003d 0) {\n        switch(uVar6) {\n        case 1:\n          uVar3 \u003d debug_make_int_type_isra_0(1,0);\n          pcVar2 \u003d \"char\";\n          break;\n        case 2:\n          uVar3 \u003d debug_make_int_type_isra_0(2,0);\n          pcVar2 \u003d \"short\";\n          break;\n        case 3:\n          uVar3 \u003d debug_make_int_type_isra_0(4,0);\n          pcVar2 \u003d \"long\";\n          break;\n        case 4:\n          uVar3 \u003d debug_make_int_type_isra_0(1,1);\n          pcVar2 \u003d \"unsigned char\";\n          break;\n        case 5:\n          uVar3 \u003d debug_make_int_type_isra_0(1,0);\n          pcVar2 \u003d \"signed char\";\n          break;\n        case 6:\n          uVar3 \u003d debug_make_int_type_isra_0(2,1);\n          pcVar2 \u003d \"unsigned short\";\n          break;\n        case 7:\n          uVar3 \u003d debug_make_int_type_isra_0(4,1);\n          pcVar2 \u003d \"unsigned int\";\n          break;\n        case 8:\n          uVar3 \u003d debug_make_int_type_isra_0(4,1);\n          pcVar2 \u003d \"unsigned\";\n          break;\n        case 9:\n          uVar3 \u003d debug_make_int_type_isra_0(4,1);\n          pcVar2 \u003d \"unsigned long\";\n          break;\n        case 10:\n          uVar3 \u003d debug_make_void_type_isra_0();\n          pcVar2 \u003d \"void\";\n          break;\n        case 0xb:\n          uVar3 \u003d debug_make_float_type_isra_0(4);\n          pcVar2 \u003d \"float\";\n          break;\n        case 0xc:\n          uVar3 \u003d debug_make_float_type_isra_0(8);\n          pcVar2 \u003d \"double\";\n          break;\n        case 0xd:\n          uVar3 \u003d debug_make_float_type_isra_0(8);\n          pcVar2 \u003d \"long double\";\n          break;\n        case 0xe:\n          uVar3 \u003d debug_make_int_type_isra_0(4,0);\n          pcVar2 \u003d \"integer\";\n          break;\n        case 0xf:\n          uVar3 \u003d debug_make_type_constprop_0(6,4);\n          pcVar2 \u003d \"boolean\";\n          break;\n        case 0x10:\n          uVar3 \u003d debug_make_float_type_isra_0(4);\n          pcVar2 \u003d \"short real\";\n          break;\n        case 0x11:\n          uVar3 \u003d debug_make_float_type_isra_0(8);\n          pcVar2 \u003d \"real\";\n          break;\n        case 0x12:\n          pcVar2 \u003d \"stringptr\";\n          uVar3 \u003d 0;\n          break;\n        case 0x13:\n          uVar3 \u003d debug_make_int_type_isra_0(1,1);\n          pcVar2 \u003d \"character\";\n          break;\n        case 0x14:\n          uVar3 \u003d debug_make_type_constprop_0(6,1);\n          pcVar2 \u003d \"logical*1\";\n          break;\n        case 0x15:\n          uVar3 \u003d debug_make_type_constprop_0(6,2);\n          pcVar2 \u003d \"logical*2\";\n          break;\n        case 0x16:\n          uVar3 \u003d debug_make_type_constprop_0(6,4);\n          pcVar2 \u003d \"logical*4\";\n          break;\n        case 0x17:\n          uVar3 \u003d debug_make_type_constprop_0(6,4);\n          pcVar2 \u003d \"logical\";\n          break;\n        case 0x18:\n          uVar3 \u003d debug_make_type_constprop_0(5,8);\n          pcVar2 \u003d \"complex\";\n          break;\n        case 0x19:\n          uVar3 \u003d debug_make_type_constprop_0(5,0x10);\n          pcVar2 \u003d \"double complex\";\n          break;\n        case 0x1a:\n          uVar3 \u003d debug_make_int_type_isra_0(1,0);\n          pcVar2 \u003d \"integer*1\";\n          break;\n        case 0x1b:\n          uVar3 \u003d debug_make_int_type_isra_0(2,0);\n          pcVar2 \u003d \"integer*2\";\n          break;\n        case 0x1c:\n          uVar3 \u003d debug_make_int_type_isra_0(4,0);\n          pcVar2 \u003d \"integer*4\";\n          break;\n        case 0x1d:\n          uVar3 \u003d debug_make_int_type_isra_0(2,0);\n          pcVar2 \u003d \"wchar\";\n          break;\n        case 0x1e:\n          uVar3 \u003d debug_make_int_type_isra_0(8,0);\n          pcVar2 \u003d \"long long\";\n          break;\n        case 0x1f:\n          uVar3 \u003d debug_make_int_type_isra_0(8,1);\n          pcVar2 \u003d \"unsigned long long\";\n          break;\n        case 0x20:\n          uVar3 \u003d debug_make_type_constprop_0(6,8);\n          pcVar2 \u003d \"logical*8\";\n          break;\n        case 0x21:\n          uVar3 \u003d debug_make_int_type_isra_0(8,0);\n          pcVar2 \u003d \"integer*8\";\n          break;\n        default:\n          uVar3 \u003d debug_make_int_type_isra_0(4,0);\n          pcVar2 \u003d \"int\";\n        }\n        lVar4 \u003d debug_name_type(param_1,pcVar2,uVar3);\n        *(long *)(param_2 + 0x90 + (ulong)uVar6 * 8) \u003d lVar4;\n        return lVar4;\n      }\n      return lVar4;\n    }\n    pcVar2 \u003d (char *)dcgettext(0,\"Unrecognized XCOFF type %d\\n\",5);\n    fprintf(_stderr,pcVar2,(ulong)uVar1);\n  }\n  else {\n    plVar5 \u003d (long *)stab_find_slot(param_2);\n    if (plVar5 !\u003d (long *)0x0) {\n      if (*plVar5 \u003d\u003d 0) {\n        lVar4 \u003d debug_make_indirect_type_isra_0(plVar5,0);\n        return lVar4;\n      }\n      return *plVar5;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_stab_type"
      ],
      "called": [
        "fprintf",
        "debug_make_type.constprop.0",
        "stab_find_slot",
        "debug_make_float_type.isra.0",
        "dcgettext",
        "debug_make_void_type.isra.0",
        "debug_make_indirect_type.isra.0",
        "debug_make_int_type.isra.0",
        "debug_name_type"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_tag_type": {
      "entrypoint": "0x0010c6be",
      "current_name": "debug_tag_type",
      "code": "\n\n\nint * debug_tag_type(long param_1,char *param_2,int *param_3)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  undefined (*pauVar4) [16];\n  long lVar5;\n  char *pcVar6;\n  \n  if ((param_2 !\u003d (char *)0x0) \u0026\u0026 (param_3 !\u003d (int *)0x0)) {\n    if (*(long *)(param_1 + 0x10) \u003d\u003d 0) {\n      pcVar6 \u003d \"debug_tag_type: no current file\";\n    }\n    else {\n      if (*param_3 !\u003d 0x17) {\n        piVar3 \u003d (int *)debug_make_type_constprop_0(0x17,0);\n        if (piVar3 \u003d\u003d (int *)0x0) {\n          return (int *)0x0;\n        }\n        pauVar4 \u003d (undefined (*) [16])xmalloc(0x10);\n        lVar5 \u003d *(long *)(param_1 + 0x10);\n        *pauVar4 \u003d ZEXT816(0);\n        *(int **)(*pauVar4 + 8) \u003d param_3;\n        *(undefined (**) [16])(piVar3 + 4) \u003d pauVar4;\n        lVar5 \u003d debug_add_to_namespace_constprop_0(lVar5 + 0x10,param_2,1,3);\n        if (lVar5 \u003d\u003d 0) {\n          return (int *)0x0;\n        }\n        *(int **)(lVar5 + 0x20) \u003d piVar3;\n        *(long *)*pauVar4 \u003d lVar5;\n        return piVar3;\n      }\n      iVar1 \u003d strcmp(*(char **)(**(long **)(param_3 + 4) + 8),param_2);\n      pcVar6 \u003d \"debug_tag_type: extra tag attempted\";\n      if (iVar1 \u003d\u003d 0) {\n        return param_3;\n      }\n    }\n    uVar2 \u003d dcgettext(0,pcVar6,5);\n    fprintf(_stderr,\"%s\\n\",uVar2);\n  }\n  return (int *)0x0;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_coff_symbol.constprop.0.isra.0",
        "finish_stab",
        "parse_stab"
      ],
      "called": [
        "fprintf",
        "debug_make_type.constprop.0",
        "debug_add_to_namespace.constprop.0",
        "dcgettext",
        "strcmp",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_set_class_id.lto_priv.0": {
      "entrypoint": "0x0010c7a0",
      "current_name": "debug_set_class_id.lto_priv.0",
      "code": "\nundefined  [16]\ndebug_set_class_id_lto_priv_0(long param_1,char *param_2,int *param_3,undefined8 param_4)\n\n{\n  undefined8 uVar1;\n  uint uVar2;\n  long lVar3;\n  int *piVar4;\n  char *__s1;\n  char cVar5;\n  int iVar6;\n  undefined8 *puVar7;\n  undefined auVar8 [16];\n  \n  if (3 \u003c *param_3 - 7U) {\n                    \n    __assert_fail(\"type-\u003ekind \u003d\u003d DEBUG_KIND_STRUCT || type-\u003ekind \u003d\u003d DEBUG_KIND_UNION || type-\u003ekind \u003d\u003d DEBUG_KIND_CLASS || type-\u003ekind \u003d\u003d DEBUG_KIND_UNION_CLASS\"\n                  ,\"../../binutils/debug.c\",0xb87,\"debug_set_class_id\");\n  }\n  lVar3 \u003d *(long *)(param_3 + 4);\n  puVar7 \u003d (undefined8 *)(ulong)*(uint *)(lVar3 + 0xc);\n  if (*(uint *)(lVar3 + 0xc) \u003c\u003d *(uint *)(param_1 + 0x38)) {\n    for (puVar7 \u003d *(undefined8 **)(param_1 + 0x50); puVar7 !\u003d (undefined8 *)0x0;\n        puVar7 \u003d (undefined8 *)*puVar7) {\n      piVar4 \u003d (int *)puVar7[1];\n      if (*piVar4 \u003d\u003d *param_3) {\n        __s1 \u003d (char *)puVar7[2];\n        if (param_2 \u003d\u003d (char *)0x0) {\n          if (__s1 \u003d\u003d (char *)0x0) {\nLAB_0010c82c:\n            cVar5 \u003d debug_type_samep(param_1,piVar4,param_3);\n            if (cVar5 !\u003d \u0027\\0\u0027) {\n              uVar2 \u003d *(uint *)(*(long *)(puVar7[1] + 0x10) + 0xc);\n              puVar7 \u003d (undefined8 *)(ulong)uVar2;\n              *(uint *)(lVar3 + 0xc) \u003d uVar2;\n              goto LAB_0010c884;\n            }\n          }\n        }\n        else if (((__s1 !\u003d (char *)0x0) \u0026\u0026 (*__s1 \u003d\u003d *param_2)) \u0026\u0026\n                (iVar6 \u003d strcmp(__s1,param_2), iVar6 \u003d\u003d 0)) goto LAB_0010c82c;\n      }\n    }\n    iVar6 \u003d *(int *)(param_1 + 0x34) + 1;\n    *(int *)(param_1 + 0x34) \u003d iVar6;\n    *(int *)(lVar3 + 0xc) \u003d iVar6;\n    puVar7 \u003d (undefined8 *)xmalloc(0x18);\n    uVar1 \u003d *(undefined8 *)(param_1 + 0x50);\n    puVar7[2] \u003d param_2;\n    *(undefined8 **)(param_1 + 0x50) \u003d puVar7;\n    *puVar7 \u003d uVar1;\n    puVar7[1] \u003d param_3;\n  }\nLAB_0010c884:\n  auVar8._1_7_ \u003d (undefined7)((ulong)puVar7 \u003e\u003e 8);\n  auVar8[0] \u003d 1;\n  auVar8._8_8_ \u003d param_4;\n  return auVar8;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "debug_type_samep",
        "__assert_fail",
        "strcmp",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "finish_stab": {
      "entrypoint": "0x0010c892",
      "current_name": "finish_stab",
      "code": "\n\n\nundefined8 finish_stab(undefined8 param_1,long param_2)\n\n{\n  char cVar1;\n  long lVar2;\n  long lVar3;\n  undefined8 uVar4;\n  undefined8 *puVar5;\n  int iVar6;\n  \n  if (*(char *)(param_2 + 0x60) \u003d\u003d \u0027\\0\u0027) {\nLAB_0010c8c7:\n    for (puVar5 \u003d *(undefined8 **)(param_2 + 0x1a0); puVar5 !\u003d (undefined8 *)0x0;\n        puVar5 \u003d (undefined8 *)*puVar5) {\n      iVar6 \u003d *(int *)(puVar5 + 2);\n      lVar3 \u003d puVar5[1];\n      if (iVar6 !\u003d 0) {\n        if (lVar3 !\u003d 0) {\n          if (iVar6 - 7U \u003c 5) goto LAB_0010c8d5;\n          uVar4 \u003d dcgettext(0,\"debug_make_undefined_type: unsupported kind\",5);\n          fprintf(_stderr,\"%s\\n\",uVar4);\n        }\nLAB_0010c910:\n        puVar5[3] \u003d 0;\n        goto LAB_0010c916;\n      }\n      if (lVar3 \u003d\u003d 0) goto LAB_0010c910;\n      iVar6 \u003d 7;\nLAB_0010c8d5:\n      lVar2 \u003d debug_make_type_constprop_0(iVar6,0);\n      if (lVar2 \u003d\u003d 0) goto LAB_0010c910;\n      lVar3 \u003d debug_tag_type(param_1,lVar3,lVar2);\n      puVar5[3] \u003d lVar3;\n      if (lVar3 \u003d\u003d 0) goto LAB_0010c916;\n    }\n    uVar4 \u003d 1;\n  }\n  else {\n    cVar1 \u003d stab_emit_pending_vars();\n    if (cVar1 !\u003d \u0027\\0\u0027) {\n      cVar1 \u003d debug_end_function(param_1,*(undefined8 *)(param_2 + 0x68));\n      if (cVar1 !\u003d \u0027\\0\u0027) {\n        *(undefined *)(param_2 + 0x60) \u003d 0;\n        *(undefined8 *)(param_2 + 0x68) \u003d 0xffffffffffffffff;\n        goto LAB_0010c8c7;\n      }\n    }\nLAB_0010c916:\n    uVar4 \u003d 0;\n  }\n  return uVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [
        "debug_end_function",
        "fprintf",
        "debug_make_type.constprop.0",
        "dcgettext",
        "debug_tag_type",
        "stab_emit_pending_vars"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_demangle_type.lto_priv.0": {
      "entrypoint": "0x0010c95e",
      "current_name": "stab_demangle_type.lto_priv.0",
      "code": "\nundefined8 stab_demangle_type_lto_priv_0(undefined8 *param_1,byte **param_2,long *param_3)\n\n{\n  byte bVar1;\n  byte bVar2;\n  byte *pbVar3;\n  bool bVar4;\n  bool bVar5;\n  bool bVar6;\n  char cVar7;\n  uint uVar8;\n  byte *pbVar9;\n  long lVar10;\n  undefined8 uVar11;\n  char *pcVar12;\n  size_t sVar13;\n  ulong uVar14;\n  void *__ptr;\n  long lVar15;\n  ulong *puVar16;\n  undefined *puVar17;\n  char **ppcVar18;\n  char *pcVar19;\n  byte *pbVar20;\n  undefined local_49;\n  ulong local_48;\n  char *local_40 [2];\n  \n  while( true ) {\n    pbVar20 \u003d *param_2;\n    bVar1 \u003d *pbVar20;\n    if (\u0027T\u0027 \u003c (char)bVar1) break;\n    if ((char)bVar1 \u003c \u0027A\u0027) goto switchD_0010c9b2_caseD_42;\n    switch(bVar1) {\n    case 0x41:\n      lVar15 \u003d 0;\n      pbVar3 \u003d pbVar20;\n      goto LAB_0010ca26;\n    default:\n      goto switchD_0010c9b2_caseD_42;\n    case 0x43:\n      *param_2 \u003d pbVar20 + 1;\n      cVar7 \u003d stab_demangle_type_lto_priv_0(param_1,param_2,param_3);\n      if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      if (param_3 \u003d\u003d (long *)0x0) {\n        return 1;\n      }\n      lVar15 \u003d debug_make_const_type_isra_0(*param_3);\n      *param_3 \u003d lVar15;\n      return 1;\n    case 0x46:\n      *param_2 \u003d pbVar20 + 1;\n      if (param_3 \u003d\u003d (long *)0x0) {\n        puVar16 \u003d (ulong *)0x0;\n        ppcVar18 \u003d (char **)0x0;\n      }\n      else {\n        puVar16 \u003d \u0026local_48;\n        ppcVar18 \u003d local_40;\n      }\n      cVar7 \u003d stab_demangle_args(param_1,param_2,ppcVar18,puVar16);\n      if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      if (**param_2 \u003d\u003d 0x5f) {\n        *param_2 \u003d *param_2 + 1;\n        cVar7 \u003d stab_demangle_type_lto_priv_0(param_1,param_2,param_3);\n        if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n          return 0;\n        }\n        if (param_3 \u003d\u003d (long *)0x0) {\n          return 1;\n        }\n        lVar15 \u003d debug_make_function_type_isra_0(*param_3,local_40[0],local_48 \u0026 0xff);\n        *param_3 \u003d lVar15;\n        return 1;\n      }\n      goto switchD_0010cdf9_caseD_60;\n    case 0x47:\n      *param_2 \u003d pbVar20 + 1;\n      break;\n    case 0x4d:\n    case 0x4f:\n      local_49 \u003d 0;\n      local_40[0] \u003d (char *)0x0;\n      local_48 \u003d 0;\n      *param_2 \u003d pbVar20 + 1;\n      if (((\u0026_sch_istable)[(ulong)pbVar20[1] * 2] \u0026 4) \u003d\u003d 0) {\n        if (pbVar20[1] !\u003d 0x51) goto switchD_0010cdf9_caseD_60;\n        ppcVar18 \u003d local_40;\n        if (param_3 \u003d\u003d (long *)0x0) {\n          ppcVar18 \u003d (char **)0x0;\n        }\n        cVar7 \u003d stab_demangle_qualified(param_1,param_2,ppcVar18);\n        if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n          return 0;\n        }\n      }\n      else {\n        uVar8 \u003d stab_demangle_count(param_2);\n        pbVar3 \u003d *param_2;\n        sVar13 \u003d strlen((char *)pbVar3);\n        if (sVar13 \u003c uVar8) goto switchD_0010cdf9_caseD_60;\n        *param_2 \u003d pbVar3 + uVar8;\n        if ((param_3 !\u003d (long *)0x0) \u0026\u0026\n           (local_40[0] \u003d (char *)stab_find_tagged_type(*param_1,param_1[1],pbVar3,uVar8,9),\n           local_40[0] \u003d\u003d (char *)0x0)) {\n          return 0;\n        }\n      }\n      bVar2 \u003d **param_2;\n      if (bVar1 \u003d\u003d 0x4d) {\n        if ((bVar2 \u003d\u003d 0x43) || (bVar2 \u003d\u003d 0x56)) {\n          *param_2 \u003d *param_2 + 1;\n        }\n        if (**param_2 !\u003d 0x46) goto switchD_0010cdf9_caseD_60;\n        *param_2 \u003d *param_2 + 1;\n        if (param_3 \u003d\u003d (long *)0x0) {\n          puVar17 \u003d (undefined *)0x0;\n          puVar16 \u003d (ulong *)0x0;\n        }\n        else {\n          puVar17 \u003d \u0026local_49;\n          puVar16 \u003d \u0026local_48;\n        }\n        cVar7 \u003d stab_demangle_args(param_1,param_2,puVar16,puVar17);\n        if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n          return 0;\n        }\n      }\n      if (**param_2 \u003d\u003d 0x5f) {\n        *param_2 \u003d *param_2 + 1;\n        cVar7 \u003d stab_demangle_type_lto_priv_0(param_1,param_2,param_3);\n        if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n          return 0;\n        }\n        if (param_3 \u003d\u003d (long *)0x0) {\n          return 1;\n        }\n        if (bVar1 !\u003d 0x4d) {\n          lVar15 \u003d debug_make_offset_type_isra_0(local_40[0],*param_3);\n          *param_3 \u003d lVar15;\n          return 1;\n        }\n        lVar15 \u003d debug_make_method_type_isra_0(*param_3,local_40[0],local_48,local_49);\n        *param_3 \u003d lVar15;\n        return 1;\n      }\n      goto switchD_0010cdf9_caseD_60;\n    case 0x50:\n      goto switchD_0010c9b2_caseD_50;\n    case 0x51:\n      uVar11 \u003d stab_demangle_qualified(param_1,param_2,param_3);\n      return uVar11;\n    case 0x52:\n      *param_2 \u003d pbVar20 + 1;\n      cVar7 \u003d stab_demangle_type_lto_priv_0(param_1,param_2,param_3);\n      if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      if (param_3 \u003d\u003d (long *)0x0) {\n        return 1;\n      }\n      lVar15 \u003d debug_make_reference_type_isra_0(*param_3);\n      *param_3 \u003d lVar15;\n      return 1;\n    case 0x54:\n      *param_2 \u003d pbVar20 + 1;\n      cVar7 \u003d stab_demangle_get_count(param_2,\u0026local_48);\n      if (cVar7 !\u003d \u0027\\0\u0027) {\n        if ((uint)local_48 \u003c *(uint *)(param_1 + 5)) {\n          local_40[0] \u003d *(char **)((local_48 \u0026 0xffffffff) * 0x10 + param_1[4]);\n          cVar7 \u003d stab_demangle_type_lto_priv_0(param_1,local_40,param_3);\n          if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n            return 0;\n          }\n          return 1;\n        }\n      }\n      goto switchD_0010cdf9_caseD_60;\n    }\n  }\n  if (bVar1 \u003d\u003d 0x70) {\nswitchD_0010c9b2_caseD_50:\n    *param_2 \u003d pbVar20 + 1;\n    cVar7 \u003d stab_demangle_type_lto_priv_0(param_1,param_2,param_3);\n    if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n      return 0;\n    }\n    if (param_3 \u003d\u003d (long *)0x0) {\n      return 1;\n    }\n    lVar15 \u003d debug_make_pointer_type_isra_0(*param_3);\n    *param_3 \u003d lVar15;\n    return 1;\n  }\nswitchD_0010c9b2_caseD_42:\n  bVar6 \u003d false;\n  bVar4 \u003d false;\n  cVar7 \u003d \u0027\\0\u0027;\n  bVar5 \u003d false;\n  do {\n    pbVar3 \u003d *param_2;\n    bVar1 \u003d *pbVar3;\n    if (bVar1 \u003d\u003d 0x55) {\n      cVar7 \u003d \u0027\\x01\u0027;\n      goto LAB_0010cd84;\n    }\n    if (\u0027U\u0027 \u003c (char)bVar1) {\n      if (bVar1 \u003d\u003d 0x56) {\n        bVar6 \u003d true;\n        goto LAB_0010cd84;\n      }\n      if (\u0027x\u0027 \u003c (char)bVar1) goto switchD_0010cdf9_caseD_60;\n      if ((char)bVar1 \u003c \u0027_\u0027) goto LAB_0010cdfb;\n      switch(bVar1) {\n      case 0x5f:\n        goto switchD_0010cdf9_caseD_5f;\n      default:\n        goto switchD_0010cdf9_caseD_60;\n      case 0x62:\n        if (param_3 \u003d\u003d (long *)0x0) {\nLAB_0010d0aa:\n          *param_2 \u003d pbVar3 + 1;\n          return 1;\n        }\n        lVar15 \u003d debug_find_named_type(*param_1,\u0026DAT_00120436);\n        *param_3 \u003d lVar15;\n        if (lVar15 \u003d\u003d 0) {\n          lVar15 \u003d debug_make_type_constprop_0(6,4);\n          *param_3 \u003d lVar15;\n          *param_2 \u003d *param_2 + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 99:\n        if (param_3 \u003d\u003d (long *)0x0) goto LAB_0010d0aa;\n        pcVar19 \u003d \"unsigned char\";\n        if ((cVar7 \u003d\u003d \u0027\\0\u0027) \u0026\u0026 (pcVar19 \u003d \"char\", bVar4)) {\n          pcVar19 \u003d \"signed char\";\n        }\n        lVar15 \u003d debug_find_named_type(*param_1,pcVar19);\n        *param_3 \u003d lVar15;\n        if (lVar15 \u003d\u003d 0) {\n          lVar15 \u003d debug_make_int_type_isra_0(1,cVar7);\n          *param_3 \u003d lVar15;\n          *param_2 \u003d *param_2 + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 100:\n        if (param_3 \u003d\u003d (long *)0x0) goto LAB_0010d0aa;\n        pcVar19 \u003d \"double\";\n        goto LAB_0010d046;\n      case 0x66:\n        if (param_3 \u003d\u003d (long *)0x0) goto LAB_0010d0aa;\n        lVar15 \u003d debug_find_named_type(*param_1,\"float\");\n        *param_3 \u003d lVar15;\n        if (lVar15 \u003d\u003d 0) {\n          lVar15 \u003d debug_make_float_type_isra_0(4);\n          *param_3 \u003d lVar15;\n          *param_2 \u003d *param_2 + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x69:\n        if (param_3 \u003d\u003d (long *)0x0) goto LAB_0010d0aa;\n        pcVar19 \u003d \"unsigned int\";\n        pcVar12 \u003d \"int\";\n        goto LAB_0010ced2;\n      case 0x6c:\n        if (param_3 \u003d\u003d (long *)0x0) goto LAB_0010d0aa;\n        pcVar19 \u003d \"long unsigned int\";\n        pcVar12 \u003d \"long int\";\nLAB_0010ced2:\n        if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n          pcVar19 \u003d pcVar12;\n        }\n        lVar15 \u003d debug_find_named_type(*param_1,pcVar19);\n        *param_3 \u003d lVar15;\n        if (lVar15 \u003d\u003d 0) {\n          lVar15 \u003d debug_make_int_type_isra_0(4,cVar7);\n          *param_3 \u003d lVar15;\n          *param_2 \u003d *param_2 + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x72:\n        pcVar19 \u003d \"long double\";\n        if (param_3 \u003d\u003d (long *)0x0) goto LAB_0010d0aa;\nLAB_0010d046:\n        lVar15 \u003d debug_find_named_type(*param_1,pcVar19);\n        *param_3 \u003d lVar15;\n        if (lVar15 \u003d\u003d 0) {\n          lVar15 \u003d debug_make_float_type_isra_0(8);\n          *param_3 \u003d lVar15;\n          *param_2 \u003d *param_2 + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x73:\n        if (param_3 \u003d\u003d (long *)0x0) goto LAB_0010d0aa;\n        pcVar19 \u003d \"short unsigned int\";\n        if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n          pcVar19 \u003d \"short int\";\n        }\n        lVar15 \u003d debug_find_named_type(*param_1,pcVar19);\n        *param_3 \u003d lVar15;\n        if (lVar15 \u003d\u003d 0) {\n          lVar15 \u003d debug_make_int_type_isra_0(2,cVar7);\n          *param_3 \u003d lVar15;\n          *param_2 \u003d *param_2 + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x74:\n        ppcVar18 \u003d local_40;\n        if (param_3 \u003d\u003d (long *)0x0) {\n          ppcVar18 \u003d (char **)0x0;\n        }\n        cVar7 \u003d stab_demangle_template(param_1,param_2,ppcVar18);\n        if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n          return 0;\n        }\n        if (param_3 \u003d\u003d (long *)0x0) {\n          return 1;\n        }\n        sVar13 \u003d strlen(local_40[0]);\n        lVar15 \u003d stab_find_tagged_type(*param_1,param_1[1],local_40[0],sVar13 \u0026 0xffffffff,9);\n        *param_3 \u003d lVar15;\n        free(local_40[0]);\n        lVar15 \u003d *param_3;\n        goto joined_r0x0010d1d8;\n      case 0x76:\n        if (param_3 \u003d\u003d (long *)0x0) goto LAB_0010d0aa;\n        lVar15 \u003d debug_find_named_type(*param_1,\u0026DAT_00120495);\n        *param_3 \u003d lVar15;\n        if (lVar15 \u003d\u003d 0) {\n          lVar15 \u003d debug_make_void_type_isra_0();\n          *param_3 \u003d lVar15;\n          *param_2 \u003d *param_2 + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x77:\n        if (param_3 \u003d\u003d (long *)0x0) goto LAB_0010d0aa;\n        lVar15 \u003d debug_find_named_type(*param_1,\"__wchar_t\");\n        *param_3 \u003d lVar15;\n        if (lVar15 \u003d\u003d 0) {\n          lVar15 \u003d debug_make_int_type_isra_0(2,1);\n          *param_3 \u003d lVar15;\n          *param_2 \u003d *param_2 + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x78:\n        if (param_3 \u003d\u003d (long *)0x0) goto LAB_0010d0aa;\n        pcVar19 \u003d \"long long unsigned int\";\n        if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n          pcVar19 \u003d \"long long int\";\n        }\n        lVar15 \u003d debug_find_named_type(*param_1,pcVar19);\n        *param_3 \u003d lVar15;\n        if (lVar15 \u003d\u003d 0) {\n          lVar15 \u003d debug_make_int_type_isra_0(8,cVar7);\n          *param_3 \u003d lVar15;\n        }\n      }\n      *param_2 \u003d *param_2 + 1;\n      goto LAB_0010d1de;\n    }\n    if (bVar1 \u003d\u003d 0x43) {\n      bVar5 \u003d true;\n      goto LAB_0010cd84;\n    }\n    if (bVar1 !\u003d 0x53) goto LAB_0010cdc5;\n    bVar4 \u003d true;\nLAB_0010cd84:\n    *param_2 \u003d pbVar3 + 1;\n  } while( true );\nLAB_0010ca26:\n  pbVar9 \u003d pbVar3 + 1;\n  *param_2 \u003d pbVar9;\n  bVar1 \u003d *pbVar9;\n  if (bVar1 \u003d\u003d 0) goto switchD_0010cdf9_caseD_60;\n  if (bVar1 \u003d\u003d 0x5f) {\n    *param_2 \u003d pbVar3 + 2;\n    cVar7 \u003d stab_demangle_type_lto_priv_0(param_1,param_2,param_3);\n    if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n      return 0;\n    }\n    if (param_3 \u003d\u003d (long *)0x0) {\n      return 1;\n    }\n    lVar10 \u003d debug_find_named_type(*param_1,\"int\");\n    if (lVar10 \u003d\u003d 0) {\n      lVar10 \u003d debug_make_int_type_isra_0(4,0);\n    }\n    lVar15 \u003d debug_make_array_type_isra_0(*param_3,lVar10,0,lVar15,0);\n    *param_3 \u003d lVar15;\n    return 1;\n  }\n  if (((\u0026_sch_istable)[(ulong)bVar1 * 2] \u0026 4) \u003d\u003d 0) goto switchD_0010cdf9_caseD_60;\n  lVar15 \u003d lVar15 * 10 + (long)((char)bVar1 + -0x30);\n  pbVar3 \u003d pbVar9;\n  goto LAB_0010ca26;\nLAB_0010cdc5:\n  if ((char)bVar1 \u003c \u0027:\u0027) {\n    if ((char)bVar1 \u003c \u00270\u0027) {\n      if (bVar1 !\u003d 0) goto switchD_0010cdf9_caseD_60;\nswitchD_0010cdf9_caseD_5f:\n      stab_bad_demangle(pbVar20);\n      if (param_3 \u003d\u003d (long *)0x0) {\n        return 1;\n      }\n      goto LAB_0010d1de;\n    }\n  }\n  else {\nLAB_0010cdfb:\n    if ((bVar1 !\u003d 0x47) || (*param_2 \u003d pbVar3 + 1, ((\u0026_sch_istable)[(ulong)pbVar3[1] * 2] \u0026 4) \u003d\u003d 0)\n       ) goto switchD_0010cdf9_caseD_60;\n  }\n  pbVar20 \u003d *param_2;\n  uVar8 \u003d stab_demangle_count(param_2);\n  pbVar3 \u003d *param_2;\n  sVar13 \u003d strlen((char *)pbVar3);\n  uVar14 \u003d (ulong)uVar8;\n  if (uVar14 \u003c\u003d sVar13) {\n    *param_2 \u003d pbVar3 + uVar14;\n    if (param_3 \u003d\u003d (long *)0x0) {\n      return 1;\n    }\n    __ptr \u003d (void *)savestring(pbVar3,uVar14);\n    lVar15 \u003d debug_find_named_type(*param_1,__ptr);\n    *param_3 \u003d lVar15;\n    free(__ptr);\n    if (*param_3 \u003d\u003d 0) {\n      lVar15 \u003d stab_find_tagged_type(*param_1,param_1[1],pbVar3,(int)*param_2 - (int)pbVar3,0);\n      *param_3 \u003d lVar15;\njoined_r0x0010d1d8:\n      if (lVar15 \u003d\u003d 0) {\n        return 0;\n      }\n    }\nLAB_0010d1de:\n    if (bVar5) {\n      lVar15 \u003d debug_make_const_type_isra_0(*param_3);\n      *param_3 \u003d lVar15;\n    }\n    if (bVar6) {\n      lVar15 \u003d debug_make_volatile_type_isra_0(*param_3);\n      *param_3 \u003d lVar15;\n    }\n    return 1;\n  }\nswitchD_0010cdf9_caseD_60:\n  stab_bad_demangle(pbVar20);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "stab_demangle_template",
        "stab_demangle_arg",
        "stab_demangle_function_name.constprop.0"
      ],
      "called": [
        "free",
        "debug_make_type.constprop.0",
        "debug_make_float_type.isra.0",
        "strlen",
        "savestring",
        "debug_make_method_type.isra.0",
        "debug_make_array_type.isra.0",
        "stab_bad_demangle",
        "debug_find_named_type",
        "stab_demangle_type.lto_priv.0",
        "debug_make_function_type.isra.0",
        "debug_make_void_type.isra.0",
        "stab_find_tagged_type",
        "stab_demangle_template",
        "stab_demangle_args",
        "debug_make_offset_type.isra.0",
        "stab_demangle_qualified",
        "stab_demangle_get_count",
        "debug_make_int_type.isra.0",
        "debug_make_reference_type.isra.0",
        "stab_demangle_count",
        "debug_make_volatile_type.isra.0",
        "debug_make_const_type.isra.0",
        "debug_make_pointer_type.isra.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_demangle_template": {
      "entrypoint": "0x0010d21c",
      "current_name": "stab_demangle_template",
      "code": "\nundefined4 stab_demangle_template(undefined8 param_1,byte **param_2,undefined8 *param_3)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  byte bVar3;\n  char cVar4;\n  byte bVar5;\n  undefined4 uVar6;\n  int iVar7;\n  uint uVar8;\n  size_t sVar9;\n  byte *pbVar10;\n  void *__ptr;\n  void *__ptr_00;\n  char *__haystack;\n  char *pcVar11;\n  undefined8 uVar12;\n  char *pcVar13;\n  byte bVar14;\n  char *pcVar15;\n  byte bVar16;\n  byte bVar17;\n  byte bVar18;\n  byte bVar19;\n  uint uVar20;\n  ulong uVar21;\n  uint local_3c [3];\n  \n  pbVar2 \u003d *param_2;\n  *param_2 \u003d pbVar2 + 1;\n  local_3c[0] \u003d stab_demangle_count(param_2);\n  uVar21 \u003d (ulong)local_3c[0];\n  if (local_3c[0] !\u003d 0) {\n    pbVar10 \u003d *param_2;\n    sVar9 \u003d strlen((char *)pbVar10);\n    if (uVar21 \u003c\u003d sVar9) {\n      *param_2 \u003d pbVar10 + uVar21;\n      uVar20 \u003d 0;\n      uVar6 \u003d stab_demangle_get_count(param_2,local_3c);\n      if ((char)uVar6 !\u003d \u0027\\0\u0027) {\nLAB_0010d2b4:\n        if (local_3c[0] \u003c\u003d uVar20) {\n          if (param_3 \u003d\u003d (undefined8 *)0x0) {\n            return uVar6;\n          }\n          __ptr \u003d (void *)savestring(pbVar2,(int)*param_2 - (int)pbVar2);\n          __ptr_00 \u003d (void *)concat(\"NoSuchStrinG__\",__ptr,0);\n          free(__ptr);\n          __haystack \u003d (char *)cplus_demangle(__ptr_00,2);\n          free(__ptr_00);\n          if ((__haystack !\u003d (char *)0x0) \u0026\u0026\n             (pcVar11 \u003d strstr(__haystack,\"::NoSuchStrinG\"), pcVar13 \u003d __haystack,\n             pcVar15 \u003d __haystack, pcVar11 !\u003d (char *)0x0)) {\n            for (; pcVar13 !\u003d pcVar11; pcVar13 \u003d pcVar13 + 1) {\n              if ((*pcVar13 !\u003d \u0027 \u0027) ||\n                 (((pcVar13[1] \u003d\u003d \u0027\u003e\u0027 \u0026\u0026 (__haystack \u003c pcVar13)) \u0026\u0026 (pcVar13[-1] \u003d\u003d \u0027\u003e\u0027)))) {\n                *pcVar15 \u003d *pcVar13;\n                pcVar15 \u003d pcVar15 + 1;\n              }\n            }\n            uVar12 \u003d savestring(__haystack,(int)pcVar15 - (int)__haystack);\n            *param_3 \u003d uVar12;\n            free(__haystack);\n            return uVar6;\n          }\n          stab_bad_demangle(pbVar2);\n          free(__haystack);\n          return 0;\n        }\n        pbVar10 \u003d *param_2;\n        if (*pbVar10 !\u003d 0x5a) {\n          bVar5 \u003d stab_demangle_type_lto_priv_0(param_1,param_2,0);\n          if (bVar5 \u003d\u003d 0) {\n            return 0;\n          }\n          bVar3 \u003d 0;\n          bVar14 \u003d 0;\n          bVar18 \u003d 0;\n          bVar17 \u003d 0;\n          bVar19 \u003d 0;\nLAB_0010d2e9:\n          do {\n            do {\n              bVar16 \u003d bVar3;\n              bVar1 \u003d *pbVar10;\n              if ((bVar14 | bVar1 \u003d\u003d 0) !\u003d 0) {\n                bVar5 \u003d 0;\n                goto switchD_0010d329_caseD_70;\n              }\n              bVar3 \u003d bVar5;\n              bVar14 \u003d bVar5;\n            } while (\u0027v\u0027 \u003c (char)bVar1);\n            if ((char)bVar1 \u003c \u0027b\u0027) {\n              if ((char)bVar1 \u003c \u0027U\u0027) {\n                if ((char)bVar1 \u003c \u0027C\u0027) goto LAB_0010d2e9;\n                uVar21 \u003d 1L \u003c\u003c (bVar1 + 0xbd \u0026 0x3f);\n                if ((uVar21 \u0026 0x11409) \u003d\u003d 0) {\n                  if ((uVar21 \u0026 0xa000) !\u003d 0) goto switchD_0010d329_caseD_70;\n                  if (bVar1 \u003d\u003d 0x54) goto switchD_0010d329_caseD_76;\n                  goto LAB_0010d2e9;\n                }\n              }\n              else if (1 \u003c (byte)(bVar1 + 0xab)) goto LAB_0010d2e9;\n              pbVar10 \u003d pbVar10 + 1;\n              bVar3 \u003d bVar16;\n              bVar14 \u003d 0;\n              goto LAB_0010d2e9;\n            }\n            switch(bVar1) {\n            case 0x62:\n              bVar3 \u003d bVar16;\n              bVar18 \u003d bVar5;\n              break;\n            case 99:\n              bVar3 \u003d bVar16;\n              bVar19 \u003d bVar5;\n              break;\n            case 100:\n            case 0x66:\n            case 0x72:\n              bVar3 \u003d bVar16;\n              bVar17 \u003d bVar5;\n              break;\n            case 0x70:\n              goto switchD_0010d329_caseD_70;\n            case 0x76:\nswitchD_0010d329_caseD_76:\n                    \n              abort();\n            }\n          } while( true );\n        }\n        *param_2 \u003d pbVar10 + 1;\n        cVar4 \u003d stab_demangle_type_lto_priv_0(param_1,param_2,0);\n        if (cVar4 \u003d\u003d \u0027\\0\u0027) {\n          return 0;\n        }\n        goto LAB_0010d2b1;\n      }\n    }\n  }\nLAB_0010d280:\n  stab_bad_demangle(pbVar2);\n  return 0;\nswitchD_0010d329_caseD_70:\n  if (bVar16 \u003d\u003d 0) {\n    if (bVar19 \u003d\u003d 0) {\n      if (bVar18 \u003d\u003d 0) {\n        if (bVar17 \u003d\u003d 0) {\n          if (bVar5 !\u003d 0) {\n            uVar8 \u003d stab_demangle_count(param_2);\n            if (uVar8 \u003d\u003d 0) goto LAB_0010d280;\n            *param_2 \u003d *param_2 + uVar8;\n          }\n        }\n        else {\n          if (**param_2 \u003d\u003d 0x6d) {\n            *param_2 \u003d *param_2 + 1;\n          }\n          while( true ) {\n            pbVar10 \u003d *param_2;\n            if (((\u0026_sch_istable)[(ulong)*pbVar10 * 2] \u0026 4) \u003d\u003d 0) break;\n            *param_2 \u003d pbVar10 + 1;\n          }\n          if (*pbVar10 \u003d\u003d 0x2e) {\n            do {\n              pbVar10 \u003d pbVar10 + 1;\n              *param_2 \u003d pbVar10;\n            } while (((\u0026_sch_istable)[(ulong)*pbVar10 * 2] \u0026 4) !\u003d 0);\n          }\n          pbVar10 \u003d *param_2;\n          if (*pbVar10 \u003d\u003d 0x65) {\n            do {\n              pbVar10 \u003d pbVar10 + 1;\n              *param_2 \u003d pbVar10;\n            } while (((\u0026_sch_istable)[(ulong)*pbVar10 * 2] \u0026 4) !\u003d 0);\n          }\n        }\n      }\n      else {\n        uVar8 \u003d stab_demangle_count(param_2);\n        if (1 \u003c uVar8) goto LAB_0010d280;\n      }\n    }\n    else {\n      if (**param_2 \u003d\u003d 0x6d) {\n        *param_2 \u003d *param_2 + 1;\n      }\n      iVar7 \u003d stab_demangle_count(param_2);\n      if (iVar7 \u003d\u003d 0) goto LAB_0010d280;\n    }\n  }\n  else {\n    if (**param_2 \u003d\u003d 0x6d) {\n      *param_2 \u003d *param_2 + 1;\n    }\n    while (((\u0026_sch_istable)[(ulong)**param_2 * 2] \u0026 4) !\u003d 0) {\n      *param_2 \u003d *param_2 + 1;\n    }\n  }\nLAB_0010d2b1:\n  uVar20 \u003d uVar20 + 1;\n  goto LAB_0010d2b4;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "stab_demangle_qualified",
        "parse_stab_type"
      ],
      "called": [
        "concat",
        "free",
        "stab_demangle_type.lto_priv.0",
        "strlen",
        "savestring",
        "abort",
        "strstr",
        "stab_demangle_get_count",
        "cplus_demangle",
        "stab_demangle_count",
        "stab_bad_demangle"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_demangle_qualified": {
      "entrypoint": "0x0010d559",
      "current_name": "stab_demangle_qualified",
      "code": "\nundefined8 stab_demangle_qualified(undefined8 *param_1,byte **param_2,long *param_3)\n\n{\n  byte bVar1;\n  byte *pbVar2;\n  char cVar3;\n  uint uVar4;\n  int iVar5;\n  char **ppcVar6;\n  size_t sVar7;\n  long lVar8;\n  long *plVar9;\n  char *pcVar10;\n  char *__s1;\n  void *__ptr;\n  byte *pbVar11;\n  undefined8 uVar12;\n  byte *__nptr;\n  int local_64;\n  char *local_40 [2];\n  \n  pbVar2 \u003d *param_2;\n  bVar1 \u003d pbVar2[1];\n  if ((char)bVar1 \u003c \u0027:\u0027) {\n    if ((char)bVar1 \u003c \u00271\u0027) goto LAB_0010d5d8;\n    local_64 \u003d (char)bVar1 + -0x30;\n    if (pbVar2[2] \u003d\u003d 0x5f) {\n      *param_2 \u003d pbVar2 + 1;\n    }\n    pbVar11 \u003d *param_2 + 2;\n  }\n  else {\n    if (((bVar1 !\u003d 0x5f) || (((\u0026_sch_istable)[(ulong)pbVar2[2] * 2] \u0026 4) \u003d\u003d 0)) ||\n       (pbVar2[2] \u003d\u003d 0x30)) goto LAB_0010d5d8;\n    __nptr \u003d pbVar2 + 2;\n    lVar8 \u003d strtol((char *)__nptr,(char **)0x0,10);\n    local_64 \u003d (int)lVar8;\n    while (((\u0026_sch_istable)[(ulong)*__nptr * 2] \u0026 4) !\u003d 0) {\n      __nptr \u003d __nptr + 1;\n    }\n    pbVar11 \u003d __nptr + 1;\n    if (*__nptr !\u003d 0x5f) goto LAB_0010d5d8;\n  }\n  *param_2 \u003d pbVar11;\n  ppcVar6 \u003d (char **)0x0;\n  if (param_3 !\u003d (long *)0x0) {\n    ppcVar6 \u003d local_40;\n  }\n  lVar8 \u003d 0;\n  while( true ) {\n    while( true ) {\n      local_64 \u003d local_64 + -1;\n      if (local_64 \u003d\u003d -1) {\n        if (param_3 !\u003d (long *)0x0) {\n          *param_3 \u003d lVar8;\n        }\n        return 1;\n      }\n      if (**param_2 \u003d\u003d 0x5f) {\n        *param_2 \u003d *param_2 + 1;\n      }\n      if (**param_2 !\u003d 0x74) break;\n      cVar3 \u003d stab_demangle_template(param_1,param_2,ppcVar6);\n      pcVar10 \u003d local_40[0];\n      if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      if (param_3 !\u003d (long *)0x0) {\n        sVar7 \u003d strlen(local_40[0]);\n        lVar8 \u003d stab_find_tagged_type(*param_1,param_1[1],pcVar10,sVar7 \u0026 0xffffffff,9);\n        free(pcVar10);\n        if (lVar8 \u003d\u003d 0) {\n          return 0;\n        }\n      }\n    }\n    uVar4 \u003d stab_demangle_count(param_2);\n    sVar7 \u003d strlen((char *)*param_2);\n    if (sVar7 \u003c uVar4) break;\n    if (param_3 !\u003d (long *)0x0) {\n      if ((lVar8 !\u003d 0) \u0026\u0026 (plVar9 \u003d (long *)debug_get_fields_isra_0(lVar8), plVar9 !\u003d (long *)0x0))\n      {\n        pcVar10 \u003d (char *)savestring(*param_2,uVar4);\n        for (; lVar8 \u003d *plVar9, lVar8 !\u003d 0; plVar9 \u003d plVar9 + 1) {\n          lVar8 \u003d *(long *)(lVar8 + 8);\n          if (lVar8 \u003d\u003d 0) {\n            free(pcVar10);\n            return 0;\n          }\n          __s1 \u003d (char *)debug_get_type_name_constprop_0(lVar8);\n          if ((__s1 !\u003d (char *)0x0) \u0026\u0026 (iVar5 \u003d strcmp(__s1,pcVar10), iVar5 \u003d\u003d 0)) break;\n        }\n        free(pcVar10);\n        if (lVar8 !\u003d 0) goto LAB_0010d7ad;\n      }\n      uVar12 \u003d 9;\n      if (local_64 \u003d\u003d 0) {\n        __ptr \u003d (void *)savestring(*param_2,uVar4);\n        lVar8 \u003d debug_find_named_type(*param_1,__ptr);\n        free(__ptr);\n        if (lVar8 !\u003d 0) goto LAB_0010d7ad;\n        uVar12 \u003d 0;\n      }\n      lVar8 \u003d stab_find_tagged_type(*param_1,param_1[1],*param_2,uVar4,uVar12);\n      if (lVar8 \u003d\u003d 0) {\n        return 0;\n      }\n    }\nLAB_0010d7ad:\n    *param_2 \u003d *param_2 + uVar4;\n  }\nLAB_0010d5d8:\n  stab_bad_demangle(pbVar2);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "parse_stab_type"
      ],
      "called": [
        "debug_get_fields.isra.0",
        "free",
        "strlen",
        "savestring",
        "stab_find_tagged_type",
        "stab_demangle_template",
        "strcmp",
        "strtol",
        "debug_get_type_name.constprop.0",
        "stab_demangle_count",
        "stab_bad_demangle",
        "debug_find_named_type"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_demangle_arg": {
      "entrypoint": "0x0010d7d4",
      "current_name": "stab_demangle_arg",
      "code": "\nundefined4\nstab_demangle_arg(undefined8 param_1,undefined8 *param_2,long *param_3,uint *param_4,uint *param_5)\n\n{\n  undefined8 uVar1;\n  char cVar2;\n  undefined4 uVar3;\n  long lVar4;\n  long *plVar5;\n  uint uVar6;\n  long local_40 [2];\n  \n  uVar1 \u003d *param_2;\n  plVar5 \u003d local_40;\n  if (param_3 \u003d\u003d (long *)0x0) {\n    plVar5 \u003d (long *)0x0;\n  }\n  cVar2 \u003d stab_demangle_type_lto_priv_0(param_1,param_2,plVar5);\n  if ((cVar2 !\u003d \u0027\\0\u0027) \u0026\u0026\n     (uVar3 \u003d stab_demangle_remember_type(param_1,uVar1,(int)*param_2 - (int)uVar1),\n     (char)uVar3 !\u003d \u0027\\0\u0027)) {\n    if (param_3 \u003d\u003d (long *)0x0) {\n      return uVar3;\n    }\n    if (local_40[0] !\u003d 0) {\n      if (*param_5 \u003c\u003d *param_4 + 1) {\n        uVar6 \u003d *param_5 + 10;\n        lVar4 \u003d *param_3;\n        *param_5 \u003d uVar6;\n        lVar4 \u003d xrealloc(lVar4,(ulong)uVar6 \u003c\u003c 3);\n        *param_3 \u003d lVar4;\n      }\n      uVar6 \u003d *param_4;\n      *(long *)(*param_3 + (ulong)uVar6 * 8) \u003d local_40[0];\n      *param_4 \u003d uVar6 + 1;\n      return uVar3;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_args"
      ],
      "called": [
        "stab_demangle_type.lto_priv.0",
        "xrealloc",
        "stab_demangle_remember_type"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_demangle_args": {
      "entrypoint": "0x0010d882",
      "current_name": "stab_demangle_args",
      "code": "\nundefined8 stab_demangle_args(long param_1,char **param_2,long *param_3,undefined *param_4)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char cVar3;\n  long lVar4;\n  char *pcVar5;\n  ulong uVar6;\n  bool bVar7;\n  uint local_50;\n  undefined4 local_4c;\n  uint local_48;\n  int local_44;\n  undefined8 local_40 [2];\n  \n  pcVar2 \u003d *param_2;\n  local_4c \u003d 10;\n  if (param_3 !\u003d (long *)0x0) {\n    lVar4 \u003d xmalloc();\n    *param_3 \u003d lVar4;\n    *param_4 \u003d 0;\n  }\n  local_50 \u003d 0;\n  while( true ) {\n    pcVar5 \u003d *param_2;\n    cVar3 \u003d *pcVar5;\n    if ((cVar3 \u003d\u003d \u0027_\u0027 || cVar3 \u003d\u003d \u0027\\0\u0027) || (cVar3 \u003d\u003d \u0027e\u0027)) break;\n    if ((cVar3 \u003d\u003d \u0027N\u0027) || (cVar3 \u003d\u003d \u0027T\u0027)) {\n      *param_2 \u003d pcVar5 + 1;\n      if (cVar3 \u003d\u003d \u0027T\u0027) {\n        local_44 \u003d 1;\n      }\n      else {\n        cVar3 \u003d stab_demangle_get_count(param_2,\u0026local_44);\n        if (cVar3 \u003d\u003d \u0027\\0\u0027) goto LAB_0010d958;\n      }\n      cVar3 \u003d stab_demangle_get_count(param_2,\u0026local_48);\n      if ((cVar3 \u003d\u003d \u0027\\0\u0027) || (*(uint *)(param_1 + 0x28) \u003c\u003d local_48)) {\nLAB_0010d958:\n        stab_bad_demangle(pcVar2);\n        return 0;\n      }\n      uVar6 \u003d (ulong)local_48;\n      while (iVar1 \u003d local_44 + -1, bVar7 \u003d local_44 !\u003d 0, local_44 \u003d iVar1, bVar7) {\n        local_40[0] \u003d *(undefined8 *)(*(long *)(param_1 + 0x20) + uVar6 * 0x10);\n        cVar3 \u003d stab_demangle_arg(param_1,local_40,param_3,\u0026local_50,\u0026local_4c);\n        if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n          return 0;\n        }\n      }\n    }\n    else {\n      cVar3 \u003d stab_demangle_arg(param_1,param_2,param_3,\u0026local_50,\u0026local_4c);\n      if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n    }\n  }\n  if (param_3 \u003d\u003d (long *)0x0) {\n    if (cVar3 !\u003d \u0027e\u0027) goto LAB_0010d9fa;\n  }\n  else {\n    *(undefined8 *)(*param_3 + (ulong)local_50 * 8) \u003d 0;\n    if (*pcVar5 !\u003d \u0027e\u0027) goto LAB_0010d9fa;\n    *param_4 \u003d 1;\n  }\n  pcVar5 \u003d pcVar5 + 1;\n  *param_2 \u003d pcVar5;\nLAB_0010d9fa:\n  return CONCAT71((int7)((ulong)pcVar5 \u003e\u003e 8),1);\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "parse_stab_type"
      ],
      "called": [
        "stab_demangle_arg",
        "stab_demangle_get_count",
        "stab_bad_demangle",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "coff_get_slot.lto_priv.0": {
      "entrypoint": "0x0010da0b",
      "current_name": "coff_get_slot.lto_priv.0",
      "code": "\nundefined  [16]\ncoff_get_slot_lto_priv_0(long **param_1,ulong param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  undefined8 uVar1;\n  long *plVar2;\n  long lVar3;\n  long lVar4;\n  ulong uVar5;\n  byte bVar6;\n  undefined auVar7 [16];\n  \n  bVar6 \u003d 0;\n  uVar5 \u003d param_2;\n  if ((long)param_2 \u003c 0x3e90) {\n    for (; 0xf \u003c (long)uVar5; uVar5 \u003d uVar5 - 0x10) {\n      if (*param_1 \u003d\u003d (long *)0x0) {\n        plVar2 \u003d (long *)xmalloc(0x88);\n        *param_1 \u003d plVar2;\n        for (lVar3 \u003d 0x22; lVar3 !\u003d 0; lVar3 \u003d lVar3 + -1) {\n          *(undefined4 *)plVar2 \u003d 0;\n          plVar2 \u003d (long *)((long)plVar2 + (ulong)bVar6 * -8 + 4);\n        }\n      }\n      param_1 \u003d (long **)*param_1;\n    }\n    lVar3 \u003d (param_2 \u003e\u003e 4) * -0x10;\n    if ((long)param_2 \u003c 0) {\n      lVar3 \u003d 0;\n    }\n    if (*param_1 \u003d\u003d (long *)0x0) {\n      plVar2 \u003d (long *)xmalloc(0x88);\n      *param_1 \u003d plVar2;\n      for (lVar4 \u003d 0x22; lVar4 !\u003d 0; lVar4 \u003d lVar4 + -1) {\n        *(undefined4 *)plVar2 \u003d 0;\n        plVar2 \u003d (long *)((long)plVar2 + (ulong)bVar6 * -8 + 4);\n      }\n    }\n    auVar7._8_8_ \u003d param_4;\n    auVar7._0_8_ \u003d *param_1 + param_2 + lVar3 + 1;\n    return auVar7;\n  }\n  uVar1 \u003d dcgettext(0,\"Excessively large slot index: %lx\",5);\n                    \n  fatal(uVar1,param_2);\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_coff_symbol.constprop.0.isra.0",
        "parse_coff_type.lto_priv.0"
      ],
      "called": [
        "dcgettext",
        "fatal",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "parse_coff_type.lto_priv.0": {
      "entrypoint": "0x0010dac0",
      "current_name": "parse_coff_type.lto_priv.0",
      "code": "\nlong parse_coff_type_lto_priv_0\n               (long param_1,long *param_2,long param_3,undefined8 param_4,uint param_5,\n               long *param_6,char param_7,undefined8 param_8)\n\n{\n  long lVar1;\n  char cVar2;\n  undefined4 uVar3;\n  undefined8 uVar4;\n  long lVar5;\n  undefined8 uVar6;\n  long *plVar7;\n  void *__ptr;\n  void *__ptr_00;\n  byte bVar8;\n  int iVar9;\n  char *pcVar10;\n  ulong uVar11;\n  long lVar12;\n  uint uVar13;\n  uint uVar14;\n  undefined8 uVar15;\n  undefined local_68 [32];\n  char local_48;\n  byte local_47;\n  \n  lVar5 \u003d *(long *)(param_1 + 0x110);\n  if ((~*(uint *)(lVar5 + 0x38) \u0026 param_5) !\u003d 0) {\n    uVar13 \u003d (int)param_5 \u003e\u003e ((byte)*(undefined4 *)(lVar5 + 0x44) \u0026 0x1f);\n    uVar11 \u003d (ulong)(param_5 \u0026 *(uint *)(lVar5 + 0x40));\n    bVar8 \u003d (byte)*(undefined4 *)(lVar5 + 0x3c);\n    uVar13 \u003d (uVar13 ^ param_5) \u0026 *(uint *)(lVar5 + 0x38) ^ uVar13;\n    if (uVar11 \u003d\u003d 1L \u003c\u003c (bVar8 \u0026 0x3f)) {\n      uVar4 \u003d parse_coff_type_lto_priv_0\n                        (param_1,param_2,param_3,param_4,uVar13,param_6,param_7,param_8);\n      lVar5 \u003d debug_make_pointer_type_isra_0(uVar4);\n      return lVar5;\n    }\n    if (uVar11 !\u003d 2L \u003c\u003c (bVar8 \u0026 0x3f)) {\n      if (uVar11 !\u003d 3L \u003c\u003c (bVar8 \u0026 0x3f)) {\n        uVar4 \u003d dcgettext(0,\"parse_coff_type: Bad type code 0x%x\",5,*(undefined4 *)(lVar5 + 0x3c),\n                          uVar13);\n        non_fatal(uVar4,param_5);\n        return 0;\n      }\n      uVar14 \u003d 0;\n      if (param_6 !\u003d (long *)0x0) {\n        uVar14 \u003d (uint)*(ushort *)(param_6 + 2);\n        plVar7 \u003d param_6 + 2;\n        for (iVar9 \u003d 0; (*(short *)plVar7 !\u003d 0 \u0026\u0026 (iVar9 !\u003d 3)); iVar9 \u003d iVar9 + 1) {\n          *(short *)plVar7 \u003d *(short *)((long)plVar7 + 2);\n          plVar7 \u003d (long *)((long)plVar7 + 2);\n        }\n        *(short *)plVar7 \u003d 0;\n      }\n      uVar15 \u003d 0;\n      uVar4 \u003d param_8;\n      uVar6 \u003d parse_coff_type_lto_priv_0(param_1,param_2,param_3,param_4,uVar13,param_6,0);\n      lVar5 \u003d *(long *)(param_3 + 0x28);\n      if (lVar5 \u003d\u003d 0) {\n        uVar4 \u003d debug_make_int_type_isra_0(4,0,uVar15,uVar4);\n        lVar5 \u003d debug_name_type(param_8,\"int\",uVar4);\n        *(long *)(param_3 + 0x28) \u003d lVar5;\n      }\n      lVar5 \u003d debug_make_array_type_isra_0(uVar6,lVar5,0,(long)(int)(uVar14 - 1),0);\n      return lVar5;\n    }\n    uVar4 \u003d parse_coff_type_lto_priv_0\n                      (param_1,param_2,param_3,param_4,uVar13,param_6,param_7,param_8);\n    lVar5 \u003d debug_make_function_type_isra_0(uVar4,0,0);\n    return lVar5;\n  }\n  if ((param_6 !\u003d (long *)0x0) \u0026\u0026 (0 \u003c *param_6)) {\n    plVar7 \u003d (long *)coff_get_slot_lto_priv_0(param_3);\n    if (*plVar7 !\u003d 0) {\n      return *plVar7;\n    }\n    lVar5 \u003d debug_make_indirect_type_isra_0(plVar7,0);\n    return lVar5;\n  }\n  if (param_7 \u003d\u003d \u0027\\0\u0027) {\n    param_6 \u003d (long *)0x0;\n  }\n  if (0x10 \u003c param_5) {\n    lVar5 \u003d debug_make_void_type_isra_0();\n    return lVar5;\n  }\n  lVar5 \u003d *(long *)(param_3 + 8 + (long)(int)param_5 * 8);\n  if (lVar5 !\u003d 0) {\n    return lVar5;\n  }\n  switch(param_5) {\n  default:\n    uVar4 \u003d debug_make_void_type_isra_0();\n    pcVar10 \u003d \"void\";\n    break;\n  case 2:\n    uVar4 \u003d debug_make_int_type_isra_0(1,0);\n    pcVar10 \u003d \"char\";\n    break;\n  case 3:\n    uVar4 \u003d debug_make_int_type_isra_0(2,0);\n    pcVar10 \u003d \"short\";\n    break;\n  case 4:\n    uVar4 \u003d debug_make_int_type_isra_0(4,0);\n    pcVar10 \u003d \"int\";\n    break;\n  case 5:\n    uVar4 \u003d debug_make_int_type_isra_0(4,0);\n    pcVar10 \u003d \"long\";\n    break;\n  case 6:\n    uVar4 \u003d debug_make_float_type_isra_0(4);\n    pcVar10 \u003d \"float\";\n    break;\n  case 7:\n    uVar4 \u003d debug_make_float_type_isra_0(8);\n    pcVar10 \u003d \"double\";\n    break;\n  case 8:\n    if (param_6 \u003d\u003d (long *)0x0) {\n      lVar5 \u003d debug_make_struct_type_isra_0(1,0,0);\n      goto LAB_0010e046;\n    }\n    uVar4 \u003d 8;\n    goto LAB_0010de7a;\n  case 9:\n    if (param_6 \u003d\u003d (long *)0x0) {\n      lVar5 \u003d debug_make_struct_type_isra_0(0,0,0);\n      goto LAB_0010e046;\n    }\n    uVar4 \u003d 9;\nLAB_0010de7a:\n    lVar5 \u003d parse_coff_struct_type(param_1,param_2,param_3,uVar4,param_6,param_8);\nLAB_0010e046:\n    plVar7 \u003d (long *)coff_get_slot_lto_priv_0(param_3,param_4);\n    *plVar7 \u003d lVar5;\n    return lVar5;\n  case 10:\n    if (param_6 \u003d\u003d (long *)0x0) {\n      lVar5 \u003d debug_make_enum_type_isra_0(0,0);\n    }\n    else {\n      lVar5 \u003d param_6[3];\n      __ptr \u003d (void *)xmalloc(0x50);\n      __ptr_00 \u003d (void *)xmalloc(0x50);\n      lVar12 \u003d 0;\n      do {\n        while( true ) {\n          if ((lVar5 \u003c\u003d param_2[3]) || (param_2[1] \u003c\u003d param_2[2])) goto LAB_0010e032;\n          iVar9 \u003d (int)lVar12;\n          lVar1 \u003d *(long *)(*param_2 + param_2[2] * 8);\n          cVar2 \u003d bfd_coff_get_syment(param_1,lVar1,local_68);\n          lVar12 \u003d (long)iVar9;\n          if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n            uVar3 \u003d bfd_get_error();\n            uVar4 \u003d bfd_errmsg(uVar3);\n            uVar6 \u003d dcgettext(0,\"bfd_coff_get_syment failed: %s\",5);\n            non_fatal(uVar6,uVar4);\n            free(__ptr);\n            free(__ptr_00);\n            lVar5 \u003d 0;\n            goto LAB_0010e046;\n          }\n          param_2[2] \u003d param_2[2] + 1;\n          param_2[3] \u003d (ulong)local_47 + 1 + param_2[3];\n          if (local_48 !\u003d \u0027\\x10\u0027) break;\n          if ((int)param_5 \u003c\u003d iVar9 + 1) {\n            param_5 \u003d param_5 + 10;\n            __ptr \u003d (void *)xrealloc(__ptr);\n            __ptr_00 \u003d (void *)xrealloc(__ptr_00,(long)(int)param_5 \u003c\u003c 3);\n          }\n          lVar12 \u003d *(long *)(lVar1 + 0x20);\n          *(undefined8 *)((long)__ptr + (long)iVar9 * 8) \u003d *(undefined8 *)(lVar1 + 8);\n          *(long *)((long)__ptr_00 + (long)iVar9 * 8) \u003d\n               *(long *)(lVar1 + 0x10) + *(long *)(lVar12 + 0x30);\n          lVar12 \u003d (long)(iVar9 + 1);\n        }\n      } while (local_48 !\u003d \u0027f\u0027);\nLAB_0010e032:\n      *(undefined8 *)((long)__ptr + lVar12 * 8) \u003d 0;\n      lVar5 \u003d debug_make_enum_type_isra_0(__ptr,__ptr_00);\n    }\n    goto LAB_0010e046;\n  case 0xb:\n    lVar5 \u003d debug_make_void_type_isra_0();\n    goto LAB_0010e065;\n  case 0xc:\n    uVar4 \u003d debug_make_int_type_isra_0(1,1);\n    pcVar10 \u003d \"unsigned char\";\n    break;\n  case 0xd:\n    uVar4 \u003d debug_make_int_type_isra_0(2,1);\n    pcVar10 \u003d \"unsigned short\";\n    break;\n  case 0xe:\n    uVar4 \u003d debug_make_int_type_isra_0(4,1);\n    pcVar10 \u003d \"unsigned int\";\n    break;\n  case 0xf:\n    uVar4 \u003d debug_make_int_type_isra_0(4,1);\n    pcVar10 \u003d \"unsigned long\";\n    break;\n  case 0x10:\n    uVar4 \u003d debug_make_float_type_isra_0(0xc);\n    pcVar10 \u003d \"long double\";\n  }\n  lVar5 \u003d debug_name_type(param_8,pcVar10,uVar4);\nLAB_0010e065:\n  *(long *)(param_3 + 8 + (long)(int)param_5 * 8) \u003d lVar5;\n  return lVar5;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_coff_struct_type",
        "FUN_0010554f",
        "parse_coff_type.lto_priv.0"
      ],
      "called": [
        "bfd_coff_get_syment",
        "non_fatal",
        "free",
        "debug_make_float_type.isra.0",
        "debug_make_enum_type.isra.0",
        "debug_make_array_type.isra.0",
        "parse_coff_type.lto_priv.0",
        "coff_get_slot.lto_priv.0",
        "debug_make_function_type.isra.0",
        "debug_make_void_type.isra.0",
        "dcgettext",
        "debug_make_indirect_type.isra.0",
        "xrealloc",
        "bfd_errmsg",
        "bfd_get_error",
        "parse_coff_struct_type",
        "debug_make_struct_type.isra.0",
        "debug_make_int_type.isra.0",
        "debug_name_type",
        "debug_make_pointer_type.isra.0",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "parse_coff_struct_type": {
      "entrypoint": "0x0010e07c",
      "current_name": "parse_coff_struct_type",
      "code": "\nundefined8\nparse_coff_struct_type\n          (undefined8 param_1,long *param_2,undefined8 param_3,int param_4,long param_5,\n          undefined8 param_6)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  char cVar4;\n  undefined4 uVar5;\n  void *__ptr;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  undefined4 *puVar8;\n  char *pcVar9;\n  undefined *puVar10;\n  uint uVar11;\n  long lVar12;\n  int iVar13;\n  int iVar14;\n  undefined4 local_a8;\n  undefined4 uStack_a4;\n  undefined4 uStack_a0;\n  undefined4 uStack_9c;\n  undefined local_88 [30];\n  undefined2 local_6a;\n  byte local_68;\n  byte local_67;\n  undefined local_60 [10];\n  ushort local_56;\n  \n  iVar14 \u003d 10;\n  lVar12 \u003d 0;\n  lVar1 \u003d *(long *)(param_5 + 0x18);\n  __ptr \u003d (void *)xmalloc(0x50);\n  while ((param_2[3] \u003c lVar1 \u0026\u0026 (param_2[2] \u003c param_2[1]))) {\n    lVar2 \u003d *(long *)(*param_2 + param_2[2] * 8);\n    cVar4 \u003d bfd_coff_get_syment(param_1,lVar2,local_88);\n    if (cVar4 \u003d\u003d \u0027\\0\u0027) {\n      uVar5 \u003d bfd_get_error();\n      uVar6 \u003d bfd_errmsg(uVar5);\n      pcVar9 \u003d \"bfd_coff_get_syment failed: %s\";\nLAB_0010e18d:\n      uVar7 \u003d dcgettext(0,pcVar9,5);\n      non_fatal(uVar7,uVar6);\n      free(__ptr);\n      return 0;\n    }\n    lVar3 \u003d param_2[3];\n    puVar10 \u003d (undefined *)0x0;\n    param_2[2] \u003d param_2[2] + 1;\n    param_2[3] \u003d lVar3 + 1 + (ulong)local_67;\n    if (local_67 !\u003d 0) {\n      puVar10 \u003d local_60;\n      cVar4 \u003d bfd_coff_get_auxent(param_1,lVar2,0,puVar10);\n      if (cVar4 \u003d\u003d \u0027\\0\u0027) {\n        uVar5 \u003d bfd_get_error();\n        uVar6 \u003d bfd_errmsg(uVar5);\n        pcVar9 \u003d \"bfd_coff_get_auxent failed: %s\";\n        goto LAB_0010e18d;\n      }\n    }\n    if (local_68 \u003d\u003d 0x12) {\n      uVar11 \u003d (uint)local_56;\n      iVar13 \u003d (int)*(undefined8 *)(lVar2 + 0x10) +\n               (int)*(undefined8 *)(*(long *)(lVar2 + 0x20) + 0x30);\n    }\n    else {\n      if (local_68 \u003c 0x13) {\n        if ((local_68 \u003d\u003d 8) || (local_68 \u003d\u003d 0xb)) {\n          uVar11 \u003d 0;\n          iVar13 \u003d ((int)*(undefined8 *)(lVar2 + 0x10) +\n                   (int)*(undefined8 *)(*(long *)(lVar2 + 0x20) + 0x30)) * 8;\n          goto LAB_0010e214;\n        }\n      }\n      else if (local_68 \u003d\u003d 0x66) break;\n      uVar11 \u003d 0;\n      iVar13 \u003d 0;\n    }\nLAB_0010e214:\n    uVar7 \u003d parse_coff_type_lto_priv_0(param_1,param_2,param_3,lVar3,local_6a,puVar10,1);\n    uVar6 \u003d *(undefined8 *)(lVar2 + 8);\n    puVar8 \u003d (undefined4 *)xmalloc(0x20);\n    local_a8 \u003d (undefined4)uVar6;\n    uStack_a4 \u003d (undefined4)((ulong)uVar6 \u003e\u003e 0x20);\n    uStack_a0 \u003d (undefined4)uVar7;\n    uStack_9c \u003d (undefined4)((ulong)uVar7 \u003e\u003e 0x20);\n    *(undefined8 *)(puVar8 + 5) \u003d 0;\n    puVar8[6] \u003d iVar13;\n    puVar8[7] \u003d uVar11;\n    puVar8[4] \u003d 0;\n    *puVar8 \u003d local_a8;\n    puVar8[1] \u003d uStack_a4;\n    puVar8[2] \u003d uStack_a0;\n    puVar8[3] \u003d uStack_9c;\n    if (iVar14 \u003c\u003d (int)lVar12 + 1) {\n      iVar14 \u003d iVar14 + 10;\n      __ptr \u003d (void *)xrealloc(__ptr,(long)iVar14 \u003c\u003c 3,puVar8,0,param_6);\n    }\n    *(undefined4 **)((long)__ptr + lVar12 * 8) \u003d puVar8;\n    lVar12 \u003d lVar12 + 1;\n  }\n  *(undefined8 *)((long)__ptr + (long)(int)lVar12 * 8) \u003d 0;\n  uVar6 \u003d debug_make_struct_type_isra_0(param_4 \u003d\u003d 8,*(undefined2 *)(param_5 + 10),__ptr);\n  return uVar6;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_coff_type.lto_priv.0"
      ],
      "called": [
        "bfd_coff_get_syment",
        "non_fatal",
        "free",
        "bfd_coff_get_auxent",
        "dcgettext",
        "xrealloc",
        "bfd_errmsg",
        "bfd_get_error",
        "debug_make_struct_type.isra.0",
        "parse_coff_type.lto_priv.0",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_write_symbol.lto_priv.0": {
      "entrypoint": "0x0010e2f0",
      "current_name": "stab_write_symbol.lto_priv.0",
      "code": "\nundefined8\nstab_write_symbol_lto_priv_0\n          (long *param_1,undefined param_2,int param_3,undefined8 param_4,char *param_5)\n\n{\n  long lVar1;\n  undefined4 uVar2;\n  long lVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  size_t sVar6;\n  long lVar7;\n  undefined4 local_44;\n  undefined uStack_40;\n  undefined uStack_3f;\n  undefined2 uStack_3e;\n  undefined4 local_3c [3];\n  \n  if (param_5 \u003d\u003d (char *)0x0) {\n    lVar7 \u003d 0;\n  }\n  else {\n    lVar3 \u003d bfd_hash_lookup(param_1 + 7,param_5,1,1);\n    if (lVar3 \u003d\u003d 0) {\n      uVar2 \u003d bfd_get_error();\n      uVar4 \u003d bfd_errmsg(uVar2);\n      uVar5 \u003d dcgettext(0,\"string_hash_lookup failed: %s\",5);\n      non_fatal(uVar5,uVar4);\n      return 0;\n    }\n    lVar7 \u003d *(long *)(lVar3 + 0x20);\n    if (lVar7 \u003d\u003d -1) {\n      lVar7 \u003d param_1[6];\n      lVar1 \u003d param_1[5];\n      *(long *)(lVar3 + 0x20) \u003d lVar7;\n      if (lVar1 \u003d\u003d 0) {\n        param_1[4] \u003d lVar3;\n      }\n      else {\n        *(long *)(lVar1 + 0x18) \u003d lVar3;\n      }\n      param_1[5] \u003d lVar3;\n      sVar6 \u003d strlen(param_5);\n      param_1[6] \u003d lVar7 + 1 + sVar6;\n    }\n  }\n  (**(code **)(*(long *)(*param_1 + 8) + 0x50))(lVar7,\u0026local_44);\n  uStack_3f \u003d 0;\n  uStack_40 \u003d param_2;\n  (**(code **)(*(long *)(*param_1 + 8) + 0x68))((long)param_3,\u0026uStack_3e);\n  (**(code **)(*(long *)(*param_1 + 8) + 0x50))(param_4,local_3c);\n  if ((ulong)param_1[3] \u003c param_1[2] + 0xcU) {\n    param_1[3] \u003d param_1[3] * 2;\n    lVar7 \u003d xrealloc(param_1[1]);\n    param_1[1] \u003d lVar7;\n  }\n  lVar7 \u003d param_1[2];\n  lVar3 \u003d param_1[1];\n  *(ulong *)(lVar3 + lVar7) \u003d CONCAT26(uStack_3e,CONCAT15(uStack_3f,CONCAT14(uStack_40,local_44)));\n  *(undefined4 *)(lVar3 + 8 + lVar7) \u003d local_3c[0];\n  param_1[2] \u003d param_1[2] + 0xc;\n  return CONCAT71((int7)((ulong)lVar7 \u003e\u003e 8),1);\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_float_constant.lto_priv.0",
        "stab_enum_type.lto_priv.0",
        "stab_typdef.lto_priv.0",
        "stab_function_type.lto_priv.0",
        "stab_start_function.lto_priv.0",
        "stab_start_block.lto_priv.0",
        "stab_int_constant.lto_priv.0",
        "stab_typed_constant.lto_priv.0",
        "write_stabs_in_sections_debugging_info.constprop.0",
        "stab_lineno.lto_priv.0",
        "stab_function_parameter.lto_priv.0",
        "stab_end_block.lto_priv.0",
        "stab_variable.lto_priv.0",
        "stab_start_source.lto_priv.0",
        "stab_tag.lto_priv.0"
      ],
      "called": [
        "non_fatal",
        "dcgettext",
        "strlen",
        "xrealloc",
        "bfd_errmsg",
        "bfd_get_error",
        "bfd_hash_lookup"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_start_source.lto_priv.0": {
      "entrypoint": "0x0010e439",
      "current_name": "stab_start_source.lto_priv.0",
      "code": "\nvoid stab_start_source_lto_priv_0(long param_1,undefined8 param_2)\n\n{\n  *(undefined8 *)(param_1 + 0x210) \u003d param_2;\n  stab_write_symbol_lto_priv_0(param_1,0x84,0,0,param_2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_start_compilation_unit.lto_priv.0",
        "write_stabs_in_sections_debugging_info.constprop.0"
      ],
      "called": [
        "stab_write_symbol.lto_priv.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_start_compilation_unit.lto_priv.0": {
      "entrypoint": "0x0010e451",
      "current_name": "stab_start_compilation_unit.lto_priv.0",
      "code": "\nvoid stab_start_compilation_unit_lto_priv_0(long param_1,undefined8 param_2)\n\n{\n  *(undefined8 *)(param_1 + 0x210) \u003d param_2;\n  stab_write_symbol_lto_priv_0(param_1,0x84,0,0,param_2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "write_stabs_in_sections_debugging_info.constprop.0"
      ],
      "called": [
        "stab_start_source.lto_priv.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_enum_type.lto_priv.0": {
      "entrypoint": "0x0010e453",
      "current_name": "stab_enum_type.lto_priv.0",
      "code": "\nundefined8 stab_enum_type_lto_priv_0(long param_1,char *param_2,char **param_3)\n\n{\n  long lVar1;\n  char cVar2;\n  size_t sVar3;\n  undefined2 *__s;\n  undefined8 uVar4;\n  long lVar5;\n  char **ppcVar6;\n  long lVar7;\n  \n  if (param_3 \u003d\u003d (char **)0x0) {\n    if (param_2 !\u003d (char *)0x0) {\n      sVar3 \u003d strlen(param_2);\n      __s \u003d (undefined2 *)xmalloc(sVar3 + 10);\n      sprintf((char *)__s,\"xe%s:\",param_2);\nLAB_0010e578:\n      cVar2 \u003d stab_push_string(param_1,__s,0,0,4);\n      if (cVar2 !\u003d \u0027\\0\u0027) goto LAB_0010e58b;\n    }\nLAB_0010e475:\n    uVar4 \u003d 0;\n  }\n  else {\n    lVar5 \u003d 10;\n    ppcVar6 \u003d param_3;\n    if (param_2 !\u003d (char *)0x0) {\n      sVar3 \u003d strlen(param_2);\n      lVar5 \u003d sVar3 + 10;\n    }\n    for (; *ppcVar6 !\u003d (char *)0x0; ppcVar6 \u003d ppcVar6 + 1) {\n      sVar3 \u003d strlen(*ppcVar6);\n      lVar5 \u003d lVar5 + 0x14 + sVar3;\n    }\n    __s \u003d (undefined2 *)xmalloc(lVar5);\n    if (param_2 \u003d\u003d (char *)0x0) {\n      *__s \u003d 0x65;\n      lVar5 \u003d 0;\n    }\n    else {\n      lVar5 \u003d *(long *)(param_1 + 0x68);\n      *(long *)(param_1 + 0x68) \u003d lVar5 + 1;\n      sprintf((char *)__s,\"%s:T%ld\u003de\",param_2,lVar5);\n    }\n    lVar7 \u003d 0;\n    while( true ) {\n      lVar1 \u003d *(long *)((long)param_3 + lVar7);\n      sVar3 \u003d strlen((char *)__s);\n      if (lVar1 \u003d\u003d 0) break;\n      lVar7 \u003d lVar7 + 8;\n      sprintf((char *)(undefined2 *)((long)__s + sVar3),\"%s:%ld,\");\n    }\n    *(undefined2 *)((long)__s + sVar3) \u003d 0x3b;\n    if (param_2 \u003d\u003d (char *)0x0) goto LAB_0010e578;\n    cVar2 \u003d stab_write_symbol_lto_priv_0(param_1,0x80,0,0,__s);\n    if ((cVar2 \u003d\u003d \u0027\\0\u0027) || (cVar2 \u003d stab_push_defined_type(param_1,lVar5,4), cVar2 \u003d\u003d \u0027\\0\u0027))\n    goto LAB_0010e475;\nLAB_0010e58b:\n    free(__s);\n    uVar4 \u003d 1;\n  }\n  return uVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "free",
        "strlen",
        "stab_push_defined_type",
        "stab_push_string",
        "sprintf",
        "stab_write_symbol.lto_priv.0",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_function_type.lto_priv.0": {
      "entrypoint": "0x0010e5db",
      "current_name": "stab_function_type.lto_priv.0",
      "code": "\nundefined  [16] stab_function_type_lto_priv_0(long param_1,int param_2)\n\n{\n  char cVar1;\n  void *__ptr;\n  char *__s;\n  size_t sVar2;\n  char *__s_00;\n  ulong in_R10;\n  int iVar3;\n  undefined auVar4 [16];\n  \n  iVar3 \u003d 0;\n  do {\n    if (param_2 \u003c\u003d iVar3) {\n      auVar4 \u003d stab_modify_type(param_1,0x66,0,param_1 + 0x188,param_1 + 400,in_R10);\n      return auVar4;\n    }\n    if (*(char *)(*(long *)(param_1 + 0x60) + 0x1c) \u003d\u003d \u0027\\0\u0027) {\n      __ptr \u003d (void *)stab_pop_type(param_1);\n      free(__ptr);\n    }\n    else {\n      __s \u003d (char *)stab_pop_type(param_1);\n      sVar2 \u003d strlen(__s);\n      __s_00 \u003d (char *)xmalloc(sVar2 + 3);\n      sprintf(__s_00,\":t%s\",__s);\n      free(__s);\n      cVar1 \u003d stab_write_symbol_lto_priv_0(param_1,0x80,0,0,__s_00);\n      if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n        auVar4._8_8_ \u003d 0;\n        auVar4._0_8_ \u003d in_R10;\n        return auVar4 \u003c\u003c 0x40;\n      }\n      free(__s_00);\n    }\n    iVar3 \u003d iVar3 + 1;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_type.constprop.0"
      ],
      "called": [
        "free",
        "strlen",
        "stab_modify_type",
        "sprintf",
        "stab_write_symbol.lto_priv.0",
        "stab_pop_type",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_typdef.lto_priv.0": {
      "entrypoint": "0x0010e6a8",
      "current_name": "stab_typdef.lto_priv.0",
      "code": "\nundefined  [16]\nstab_typdef_lto_priv_0(long param_1,char *param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  uint uVar1;\n  undefined4 uVar2;\n  char *__s;\n  size_t sVar3;\n  size_t sVar4;\n  char *__s_00;\n  long lVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  long lVar8;\n  ulong uVar9;\n  undefined auVar10 [16];\n  \n  lVar8 \u003d *(long *)(*(long *)(param_1 + 0x60) + 0x10);\n  uVar2 \u003d *(undefined4 *)(*(long *)(param_1 + 0x60) + 0x18);\n  __s \u003d (char *)stab_pop_type();\n  sVar3 \u003d strlen(param_2);\n  sVar4 \u003d strlen(__s);\n  __s_00 \u003d (char *)xmalloc(sVar3 + 0x14 + sVar4);\n  if (lVar8 \u003c 1) {\n    lVar8 \u003d *(long *)(param_1 + 0x68);\n    *(long *)(param_1 + 0x68) \u003d lVar8 + 1;\n    sprintf(__s_00,\"%s:t%ld\u003d%s\",param_2,lVar8,__s);\n  }\n  else {\n    sprintf(__s_00,\"%s:t%s\",param_2,__s);\n  }\n  free(__s);\n  uVar1 \u003d stab_write_symbol_lto_priv_0(param_1,0x80,0,0,__s_00);\n  uVar9 \u003d (ulong)uVar1;\n  if ((char)uVar1 !\u003d \u0027\\0\u0027) {\n    free(__s_00);\n    lVar5 \u003d bfd_hash_lookup(param_1 + 0x1b8,param_2,1,0);\n    if (lVar5 !\u003d 0) {\n      *(long *)(lVar5 + 0x20) \u003d lVar8;\n      *(undefined4 *)(lVar5 + 0x28) \u003d uVar2;\n      goto LAB_0010e7b3;\n    }\n    uVar2 \u003d bfd_get_error();\n    uVar6 \u003d bfd_errmsg(uVar2);\n    uVar7 \u003d dcgettext(0,\"string_hash_lookup failed: %s\",5);\n    non_fatal(uVar7,uVar6);\n  }\n  uVar9 \u003d 0;\nLAB_0010e7b3:\n  auVar10._8_8_ \u003d param_4;\n  auVar10._0_8_ \u003d uVar9;\n  return auVar10;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_name.constprop.0"
      ],
      "called": [
        "non_fatal",
        "free",
        "strlen",
        "dcgettext",
        "bfd_errmsg",
        "bfd_get_error",
        "bfd_hash_lookup",
        "sprintf",
        "stab_write_symbol.lto_priv.0",
        "stab_pop_type",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_tag.lto_priv.0": {
      "entrypoint": "0x0010e7c2",
      "current_name": "stab_tag.lto_priv.0",
      "code": "\nundefined  [16]\nstab_tag_lto_priv_0(undefined8 param_1,char *param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  char *__s;\n  size_t sVar1;\n  size_t sVar2;\n  char *__s_00;\n  undefined auVar3 [16];\n  \n  __s \u003d (char *)stab_pop_type();\n  sVar1 \u003d strlen(param_2);\n  sVar2 \u003d strlen(__s);\n  __s_00 \u003d (char *)xmalloc(sVar1 + 3 + sVar2);\n  sprintf(__s_00,\"%s:T%s\",param_2,__s);\n  free(__s);\n  auVar3._0_4_ \u003d stab_write_symbol_lto_priv_0(param_1,0x80,0,0,__s_00);\n  auVar3._4_4_ \u003d 0;\n  if ((char)auVar3._0_4_ !\u003d \u0027\\0\u0027) {\n    free(__s_00);\n  }\n  auVar3._8_8_ \u003d param_4;\n  return auVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_name.constprop.0"
      ],
      "called": [
        "free",
        "strlen",
        "sprintf",
        "stab_write_symbol.lto_priv.0",
        "stab_pop_type",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_int_constant.lto_priv.0": {
      "entrypoint": "0x0010e842",
      "current_name": "stab_int_constant.lto_priv.0",
      "code": "\nundefined  [16]\nstab_int_constant_lto_priv_0(undefined8 param_1,char *param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  size_t sVar1;\n  char *__s;\n  undefined auVar2 [16];\n  \n  sVar1 \u003d strlen(param_2);\n  __s \u003d (char *)xmalloc(sVar1 + 0x14);\n  sprintf(__s,\"%s:c\u003di%ld\",param_2,param_3);\n  auVar2._0_4_ \u003d stab_write_symbol_lto_priv_0(param_1,0x80,0,0,__s);\n  auVar2._4_4_ \u003d 0;\n  if ((char)auVar2._0_4_ !\u003d \u0027\\0\u0027) {\n    free(__s);\n  }\n  auVar2._8_8_ \u003d param_4;\n  return auVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_name.constprop.0"
      ],
      "called": [
        "free",
        "strlen",
        "stab_write_symbol.lto_priv.0",
        "sprintf",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_float_constant.lto_priv.0": {
      "entrypoint": "0x0010e8a9",
      "current_name": "stab_float_constant.lto_priv.0",
      "code": "\nundefined4 stab_float_constant_lto_priv_0(undefined8 param_1,undefined8 param_2,char *param_3)\n\n{\n  undefined4 uVar1;\n  size_t sVar2;\n  char *__s;\n  \n  sVar2 \u003d strlen(param_3);\n  __s \u003d (char *)xmalloc(sVar2 + 0x14);\n  sprintf(__s,\"%s:c\u003df%g\",param_1,param_3);\n  uVar1 \u003d stab_write_symbol_lto_priv_0(param_2,0x80,0,0,__s);\n  if ((char)uVar1 !\u003d \u0027\\0\u0027) {\n    free(__s);\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_name.constprop.0"
      ],
      "called": [
        "free",
        "strlen",
        "stab_write_symbol.lto_priv.0",
        "sprintf",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_typed_constant.lto_priv.0": {
      "entrypoint": "0x0010e918",
      "current_name": "stab_typed_constant.lto_priv.0",
      "code": "\nundefined4 stab_typed_constant_lto_priv_0(undefined8 param_1,char *param_2,undefined8 param_3)\n\n{\n  undefined4 uVar1;\n  char *__s;\n  size_t sVar2;\n  size_t sVar3;\n  char *__s_00;\n  \n  __s \u003d (char *)stab_pop_type();\n  sVar2 \u003d strlen(param_2);\n  sVar3 \u003d strlen(__s);\n  __s_00 \u003d (char *)xmalloc(sVar2 + 0x14 + sVar3);\n  sprintf(__s_00,\"%s:c\u003de%s,%ld\",param_2,__s,param_3);\n  free(__s);\n  uVar1 \u003d stab_write_symbol_lto_priv_0(param_1,0x80,0,0,__s_00);\n  if ((char)uVar1 !\u003d \u0027\\0\u0027) {\n    free(__s_00);\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_name.constprop.0"
      ],
      "called": [
        "free",
        "strlen",
        "sprintf",
        "stab_write_symbol.lto_priv.0",
        "stab_pop_type",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_variable.lto_priv.0": {
      "entrypoint": "0x0010e9a0",
      "current_name": "stab_variable.lto_priv.0",
      "code": "\nundefined4\nstab_variable_lto_priv_0(long param_1,char *param_2,undefined4 param_3,undefined8 param_4)\n\n{\n  long lVar1;\n  undefined4 uVar2;\n  byte *__s;\n  byte *__s_00;\n  size_t sVar3;\n  size_t sVar4;\n  char *__s_01;\n  char *pcVar5;\n  undefined8 uVar6;\n  \n  __s \u003d (byte *)stab_pop_type();\n  switch(param_3) {\n  case 1:\n    pcVar5 \u003d \"G\";\n    uVar6 \u003d 0x20;\n    break;\n  case 2:\n    pcVar5 \u003d \"S\";\n    uVar6 \u003d 0x26;\n    break;\n  case 3:\n    pcVar5 \u003d \"V\";\n    uVar6 \u003d 0x26;\n    break;\n  case 4:\n    pcVar5 \u003d \"\";\n    uVar6 \u003d 0x80;\n    if (((\u0026_sch_istable)[(ulong)*__s * 2] \u0026 4) \u003d\u003d 0) {\n      lVar1 \u003d *(long *)(param_1 + 0x68);\n      *(long *)(param_1 + 0x68) \u003d lVar1 + 1;\n      sVar3 \u003d strlen((char *)__s);\n      __s_00 \u003d (byte *)xmalloc(sVar3 + 0x14);\n      sprintf((char *)__s_00,\"%ld\u003d%s\",lVar1,__s);\n      free(__s);\n      __s \u003d __s_00;\n    }\n    break;\n  case 5:\n    pcVar5 \u003d \"r\";\n    uVar6 \u003d 0x40;\n    break;\n  default:\n                    \n    abort();\n  }\n  sVar3 \u003d strlen(param_2);\n  sVar4 \u003d strlen((char *)__s);\n  __s_01 \u003d (char *)xmalloc(sVar3 + 3 + sVar4);\n  sprintf(__s_01,\"%s:%s%s\",param_2,pcVar5,__s);\n  free(__s);\n  uVar2 \u003d stab_write_symbol_lto_priv_0(param_1,uVar6,0,param_4,__s_01);\n  if ((char)uVar2 !\u003d \u0027\\0\u0027) {\n    free(__s_01);\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_name.constprop.0"
      ],
      "called": [
        "free",
        "strlen",
        "abort",
        "sprintf",
        "stab_write_symbol.lto_priv.0",
        "stab_pop_type",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_start_function.lto_priv.0": {
      "entrypoint": "0x0010eafe",
      "current_name": "stab_start_function.lto_priv.0",
      "code": "\nundefined4 stab_start_function_lto_priv_0(long param_1,char *param_2,char param_3)\n\n{\n  undefined4 uVar1;\n  char *__s;\n  size_t sVar2;\n  size_t sVar3;\n  char *__s_00;\n  \n  if ((*(int *)(param_1 + 0x1f8) \u003d\u003d 0) \u0026\u0026 (*(long *)(param_1 + 0x1e8) \u003d\u003d -1)) {\n    __s \u003d (char *)stab_pop_type();\n    sVar2 \u003d strlen(param_2);\n    sVar3 \u003d strlen(__s);\n    __s_00 \u003d (char *)xmalloc(sVar2 + 3 + sVar3);\n    sprintf(__s_00,\"%s:%c%s\",param_2,(ulong)((-(uint)(param_3 \u003d\u003d \u0027\\0\u0027) \u0026 0x20) + 0x46),__s);\n    *(undefined8 *)(param_1 + 0x1e8) \u003d *(undefined8 *)(param_1 + 0x10);\n    uVar1 \u003d stab_write_symbol_lto_priv_0(param_1,0x24,0,0,__s_00);\n    if ((char)uVar1 !\u003d \u0027\\0\u0027) {\n      free(__s_00);\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_name.constprop.0"
      ],
      "called": [
        "free",
        "strlen",
        "sprintf",
        "stab_write_symbol.lto_priv.0",
        "stab_pop_type",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_function_parameter.lto_priv.0": {
      "entrypoint": "0x0010ebb0",
      "current_name": "stab_function_parameter.lto_priv.0",
      "code": "\nundefined4\nstab_function_parameter_lto_priv_0(undefined8 param_1,char *param_2,int param_3,undefined8 param_4)\n\n{\n  char cVar1;\n  uint uVar2;\n  undefined4 uVar3;\n  char *__s;\n  size_t sVar4;\n  size_t sVar5;\n  char *__s_00;\n  \n  __s \u003d (char *)stab_pop_type();\n  uVar2 \u003d param_3 - 1;\n  if (uVar2 \u003c 4) {\n    uVar3 \u003d *(undefined4 *)(CSWTCH_42 + (ulong)uVar2 * 4);\n    cVar1 \u003d *(char *)((long)\u0026CSWTCH_43 + (ulong)uVar2);\n    sVar4 \u003d strlen(param_2);\n    sVar5 \u003d strlen(__s);\n    __s_00 \u003d (char *)xmalloc(sVar4 + 3 + sVar5);\n    sprintf(__s_00,\"%s:%c%s\",param_2,(ulong)(uint)(int)cVar1,__s);\n    free(__s);\n    uVar3 \u003d stab_write_symbol_lto_priv_0(param_1,uVar3,0,param_4,__s_00);\n    if ((char)uVar3 !\u003d \u0027\\0\u0027) {\n      free(__s_00);\n    }\n    return uVar3;\n  }\n                    \n  abort();\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_name.constprop.0"
      ],
      "called": [
        "free",
        "strlen",
        "abort",
        "sprintf",
        "stab_write_symbol.lto_priv.0",
        "stab_pop_type",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_start_block.lto_priv.0": {
      "entrypoint": "0x0010ec73",
      "current_name": "stab_start_block.lto_priv.0",
      "code": "\nundefined stab_start_block_lto_priv_0\n                    (long *param_1,long param_2,undefined8 param_3,undefined8 param_4,\n                    undefined8 param_5,undefined8 param_6)\n\n{\n  int iVar1;\n  char cVar2;\n  \n  if (param_1[0x3c] !\u003d -1) {\n    (**(code **)(*(long *)(*param_1 + 8) + 0x50))(param_2,param_1[1] + 8 + param_1[0x3c]);\n    param_1[0x3c] \u003d -1;\n  }\n  if (param_1[0x3d] !\u003d -1) {\n    (**(code **)(*(long *)(*param_1 + 8) + 0x50))(param_2,param_1[1] + 8 + param_1[0x3d]);\n    param_1[0x3d] \u003d -1;\n  }\n  iVar1 \u003d *(int *)(param_1 + 0x3f);\n  *(int *)(param_1 + 0x3f) \u003d iVar1 + 1;\n  if (iVar1 \u003d\u003d 0) {\n    param_1[0x40] \u003d param_2;\n  }\n  else {\n    if ((param_1[0x41] !\u003d -1) \u0026\u0026\n       (cVar2 \u003d stab_write_symbol_lto_priv_0(param_1,0xc0,0,param_1[0x41],0,param_6,param_4),\n       cVar2 \u003d\u003d \u0027\\0\u0027)) {\n      return 0;\n    }\n    param_1[0x41] \u003d param_2 - param_1[0x40];\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_block.constprop.0"
      ],
      "called": [
        "stab_write_symbol.lto_priv.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_end_block.lto_priv.0": {
      "entrypoint": "0x0010ed2c",
      "current_name": "stab_end_block.lto_priv.0",
      "code": "\nundefined  [16] stab_end_block_lto_priv_0(long param_1,ulong param_2,undefined8 param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined8 extraout_RDX;\n  ulong uVar3;\n  undefined8 in_R10;\n  undefined auVar4 [16];\n  \n  if (*(ulong *)(param_1 + 0x1f0) \u003c param_2) {\n    *(ulong *)(param_1 + 0x1f0) \u003d param_2;\n  }\n  if (*(long *)(param_1 + 0x208) \u003d\u003d -1) {\nLAB_0010ed78:\n    if (*(int *)(param_1 + 0x1f8) !\u003d 0) {\n      iVar2 \u003d *(int *)(param_1 + 0x1f8) + -1;\n      uVar3 \u003d CONCAT71((int7)((ulong)param_3 \u003e\u003e 8),1);\n      *(int *)(param_1 + 0x1f8) \u003d iVar2;\n      if (iVar2 !\u003d 0) {\n        auVar4 \u003d stab_write_symbol_lto_priv_0\n                           (param_1,0xe0,0,param_2 - *(long *)(param_1 + 0x200),0,in_R10);\n        return auVar4;\n      }\n      goto LAB_0010edae;\n    }\n  }\n  else {\n    cVar1 \u003d stab_write_symbol_lto_priv_0(param_1,0xc0,0,*(long *)(param_1 + 0x208),0);\n    if (cVar1 !\u003d \u0027\\0\u0027) {\n      *(undefined8 *)(param_1 + 0x208) \u003d 0xffffffffffffffff;\n      param_3 \u003d extraout_RDX;\n      goto LAB_0010ed78;\n    }\n  }\n  uVar3 \u003d 0;\nLAB_0010edae:\n  auVar4._0_8_ \u003d uVar3 \u0026 0xffffffff;\n  auVar4._8_8_ \u003d in_R10;\n  return auVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_block.constprop.0"
      ],
      "called": [
        "stab_write_symbol.lto_priv.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_lineno.lto_priv.0": {
      "entrypoint": "0x0010edb4",
      "current_name": "stab_lineno.lto_priv.0",
      "code": "\nundefined8 stab_lineno_lto_priv_0(long param_1,undefined8 param_2,undefined4 param_3,ulong param_4)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  undefined8 in_R10;\n  \n  if (*(long *)(param_1 + 0x210) \u003d\u003d 0) {\n    return 0;\n  }\n  if (*(ulong *)(param_1 + 0x1f0) \u003c param_4) {\n    *(ulong *)(param_1 + 0x1f0) \u003d param_4;\n  }\n  iVar2 \u003d filename_cmp(param_2);\n  if (iVar2 !\u003d 0) {\n    cVar1 \u003d stab_write_symbol_lto_priv_0(param_1,0x84,0,param_4,param_2);\n    if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n      return 0;\n    }\n    *(undefined8 *)(param_1 + 0x210) \u003d param_2;\n  }\n  uVar3 \u003d stab_write_symbol_lto_priv_0\n                    (param_1,0x44,param_3,param_4 - *(long *)(param_1 + 0x200),0,in_R10);\n  return uVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_linenos.constprop.0"
      ],
      "called": [
        "filename_cmp",
        "stab_write_symbol.lto_priv.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "parse_stab_type": {
      "entrypoint": "0x0010ee3f",
      "current_name": "parse_stab_type",
      "code": "\n\n\nvoid * parse_stab_type(undefined8 param_1,long param_2,char *param_3,byte **param_4,\n                      undefined8 *param_5,byte *param_6)\n\n{\n  byte bVar1;\n  byte bVar2;\n  byte *pbVar3;\n  long lVar4;\n  byte *pbVar5;\n  char cVar6;\n  byte bVar7;\n  char cVar8;\n  byte bVar9;\n  int iVar10;\n  undefined4 uVar11;\n  uint uVar12;\n  undefined4 uVar13;\n  int iVar14;\n  undefined8 uVar15;\n  char *pcVar16;\n  void *pvVar17;\n  void **ppvVar18;\n  long lVar19;\n  long lVar20;\n  int *piVar21;\n  undefined *puVar22;\n  char **ppcVar23;\n  void *pvVar24;\n  void *pvVar25;\n  ulong uVar26;\n  byte *pbVar27;\n  byte *pbVar28;\n  char *pcVar29;\n  size_t sVar30;\n  byte *pbVar31;\n  undefined8 *puVar32;\n  size_t sVar33;\n  byte **ppbVar34;\n  void **ppvVar35;\n  undefined8 uVar36;\n  undefined8 uVar37;\n  long lVar38;\n  long *plVar39;\n  char *pcVar40;\n  bool bVar41;\n  byte *pbVar42;\n  char cVar43;\n  undefined uVar44;\n  ulong uVar45;\n  char *pcVar46;\n  byte bVar47;\n  byte bVar48;\n  ulong uVar49;\n  byte *pbVar50;\n  bool bVar51;\n  bool bVar52;\n  undefined auVar53 [16];\n  undefined auVar54 [16];\n  void *local_158;\n  char *local_150;\n  byte *local_140;\n  char local_138;\n  char local_130;\n  uint local_12c;\n  char *local_128;\n  byte *local_120;\n  void *local_118;\n  byte *local_110;\n  undefined4 local_100;\n  uint local_fc;\n  uint local_f0;\n  uint local_ec;\n  uint local_e0;\n  int local_d0;\n  char local_a9;\n  undefined8 local_a8;\n  byte *local_a0;\n  undefined8 local_98;\n  long local_90;\n  long local_88;\n  char local_80;\n  undefined7 uStack_7f;\n  void *local_78;\n  undefined4 local_70;\n  int local_6c;\n  void *local_68;\n  int local_5c;\n  \n  bVar48 \u003d 0;\n  if (param_5 !\u003d (undefined8 *)0x0) {\n    *param_5 \u003d 0;\n  }\n  pbVar3 \u003d *param_4;\n  if (param_6 \u003c\u003d pbVar3) {\n    return (void *)0x0;\n  }\n  *(undefined *)(param_2 + 0x1a8) \u003d 0;\n  bVar9 \u003d *pbVar3;\n  if (((bVar9 !\u003d 0x28 \u0026\u0026 bVar9 !\u003d 0x2d) \u0026\n      ((byte)(*(ushort *)(\u0026_sch_istable + (ulong)bVar9 * 2) \u003e\u003e 2) ^ 1)) \u003d\u003d 0) {\n    cVar6 \u003d parse_stab_type_number(param_4,\u0026local_a8,param_6);\n    if (cVar6 \u003d\u003d \u0027\\0\u0027) {\n      return (void *)0x0;\n    }\n    if (**param_4 !\u003d 0x3d) {\n      pvVar17 \u003d (void *)stab_find_type(param_1,param_2,\u0026local_a8);\n      return pvVar17;\n    }\n    if (param_5 !\u003d (undefined8 *)0x0) {\n      if (-1 \u003c (int)((uint)local_a8 | local_a8._4_4_)) {\n        uVar15 \u003d stab_find_slot(param_2);\n        *param_5 \u003d uVar15;\n      }\n    }\n    *param_4 \u003d *param_4 + 1;\n    local_12c \u003d 0xffffffff;\n    cVar8 \u003d \u0027\\0\u0027;\n    do {\n      while( true ) {\n        do {\n          cVar43 \u003d cVar8;\n          pbVar27 \u003d *param_4;\n          if (((*pbVar27 !\u003d 0x40) ||\n              (bVar9 \u003d pbVar27[1], ((\u0026_sch_istable)[(ulong)bVar9 * 2] \u0026 4) !\u003d 0)) ||\n             (pbVar50 \u003d pbVar27, bVar9 \u003d\u003d 0x28 || bVar9 \u003d\u003d 0x2d)) goto LAB_0010efe0;\n          while( true ) {\n            bVar9 \u003d pbVar50[1];\n            if (bVar9 \u003d\u003d 0x3b) break;\n            pbVar50 \u003d pbVar50 + 1;\n            if (bVar9 \u003d\u003d 0) goto switchD_0010f055_caseD_24;\n          }\n          *param_4 \u003d pbVar50 + 2;\n          bVar9 \u003d pbVar27[1];\n          cVar8 \u003d cVar6;\n        } while (bVar9 \u003d\u003d 0x53);\n        cVar8 \u003d cVar43;\n        if (bVar9 !\u003d 0x73) break;\n        lVar38 \u003d strtol((char *)(pbVar27 + 2),(char **)0x0,10);\n        local_12c \u003d 0xffffffff;\n        if (7 \u003c (int)lVar38) {\n          local_12c \u003d (int)lVar38 \u003e\u003e 3;\n        }\n      }\n    } while (bVar9 !\u003d 0);\n    goto switchD_0010f055_caseD_24;\n  }\n  local_12c \u003d 0xffffffff;\n  cVar43 \u003d \u0027\\0\u0027;\n  local_a8 \u003d 0xffffffffffffffff;\nLAB_0010efe0:\n  pbVar50 \u003d *param_4;\n  bVar9 \u003d *pbVar50;\n  pbVar27 \u003d pbVar50 + 1;\n  *param_4 \u003d pbVar27;\n  if (\u0027x\u0027 \u003c (char)bVar9) goto switchD_0010f055_caseD_24;\n  if ((char)bVar9 \u003c \u0027a\u0027) {\n    if (bVar9 \u003d\u003d 0x40) {\n      lVar38 \u003d parse_stab_type(param_1,param_2,0,param_4,0,param_6);\n      if (lVar38 \u003d\u003d 0) {\n        return (void *)0x0;\n      }\n      if (**param_4 !\u003d 0x2c) goto switchD_0010f055_caseD_24;\n      *param_4 \u003d *param_4 + 1;\n      lVar19 \u003d parse_stab_type(param_1,param_2,0,param_4,0,param_6);\n      if (lVar19 \u003d\u003d 0) {\n        return (void *)0x0;\n      }\n      pvVar17 \u003d (void *)debug_make_offset_type_isra_0(lVar38,lVar19);\n    }\n    else if ((char)bVar9 \u003c \u0027A\u0027) {\n      if (\u0027-\u0027 \u003c (char)bVar9) {\n        if (9 \u003c (byte)(bVar9 - 0x30)) goto switchD_0010f055_caseD_24;\nswitchD_0010f055_caseD_28:\n        *param_4 \u003d pbVar50;\n        cVar6 \u003d parse_stab_type_number(param_4,\u0026local_98,param_6);\n        if (cVar6 \u003d\u003d \u0027\\0\u0027) {\n          return (void *)0x0;\n        }\n        iVar10 \u003d (uint)local_a8;\n        if ((uint)local_a8 \u003d\u003d (uint)local_98) {\n          if (local_a8._4_4_ \u003d\u003d local_98._4_4_) {\n            pvVar17 \u003d (void *)debug_make_void_type_isra_0();\n            if (iVar10 !\u003d -1) {\n              ppvVar18 \u003d (void **)stab_find_slot(param_2,\u0026local_a8);\n              if (ppvVar18 \u003d\u003d (void **)0x0) {\n                return (void *)0x0;\n              }\n              *ppvVar18 \u003d pvVar17;\n            }\n            goto LAB_001115e2;\n          }\n        }\n        *param_4 \u003d pbVar50;\n        pvVar17 \u003d (void *)parse_stab_type(param_1,param_2,0,param_4,0,param_6);\n        if (pvVar17 \u003d\u003d (void *)0x0) {\n          return (void *)0x0;\n        }\n        if (iVar10 !\u003d -1) {\n          ppvVar18 \u003d (void **)stab_find_slot(param_2,\u0026local_a8);\n          if (ppvVar18 \u003d\u003d (void **)0x0) {\n            return (void *)0x0;\n          }\n          *ppvVar18 \u003d pvVar17;\n        }\n        goto LAB_001115eb;\n      }\n      if ((char)bVar9 \u003c \u0027#\u0027) goto switchD_0010f055_caseD_24;\n      switch(bVar9) {\n      case 0x23:\n        if (pbVar50[1] \u003d\u003d 0x23) {\n          *param_4 \u003d pbVar50 + 2;\n          lVar38 \u003d parse_stab_type(param_1,param_2,0,param_4,0,param_6);\n          if (lVar38 \u003d\u003d 0) {\n            return (void *)0x0;\n          }\n          if (**param_4 !\u003d 0x3b) goto switchD_0010f055_caseD_24;\n          *param_4 \u003d *param_4 + 1;\n          pvVar17 \u003d (void *)debug_make_method_type_isra_0(lVar38,0,0,0);\n        }\n        else {\n          lVar38 \u003d parse_stab_type(param_1,param_2,0,param_4,0,param_6);\n          if (lVar38 \u003d\u003d 0) {\n            return (void *)0x0;\n          }\n          if (**param_4 !\u003d 0x2c) goto switchD_0010f055_caseD_24;\n          *param_4 \u003d *param_4 + 1;\n          lVar19 \u003d parse_stab_type(param_1,param_2,0,param_4,0,param_6);\n          if (lVar19 \u003d\u003d 0) {\n            return (void *)0x0;\n          }\n          uVar45 \u003d 10;\n          uVar49 \u003d 0;\n          auVar53 \u003d xmalloc(0x50);\n          while( true ) {\n            lVar20 \u003d auVar53._0_8_;\n            pbVar27 \u003d *param_4;\n            iVar10 \u003d (int)uVar49;\n            if (*pbVar27 \u003d\u003d 0x3b) break;\n            if (*pbVar27 !\u003d 0x2c) {\n              bad_stab(pbVar3);\n              return (void *)0x0;\n            }\n            *param_4 \u003d pbVar27 + 1;\n            if ((uint)uVar45 \u003c\u003d iVar10 + 1U) {\n              uVar45 \u003d (ulong)((uint)uVar45 + 10);\n              lVar20 \u003d xrealloc(lVar20,uVar45 \u003c\u003c 3);\n            }\n            auVar54 \u003d parse_stab_type(param_1,param_2,0,param_4,0,param_6);\n            auVar53._8_8_ \u003d auVar54._8_8_;\n            auVar53._0_8_ \u003d lVar20;\n            *(long *)(lVar20 + uVar49 * 8) \u003d auVar54._0_8_;\n            if (auVar54._0_8_ \u003d\u003d 0) {\n              return (void *)0x0;\n            }\n            uVar49 \u003d (ulong)(iVar10 + 1U);\n          }\n          uVar15 \u003d 1;\n          *param_4 \u003d pbVar27 + 1;\n          uVar45 \u003d uVar49;\n          if (iVar10 !\u003d 0) {\n            uVar45 \u003d (ulong)(iVar10 - 1);\n            lVar4 \u003d *(long *)(lVar20 + uVar45 * 8);\n            if (((lVar4 \u003d\u003d 0) ||\n                (piVar21 \u003d (int *)debug_get_real_type_isra_0(lVar4,0,0x3b,1), piVar21 \u003d\u003d (int *)0x0)\n                ) || (*piVar21 !\u003d 2)) {\n              uVar15 \u003d 1;\n              uVar45 \u003d uVar49;\n            }\n            else {\n              uVar15 \u003d 0;\n            }\n          }\n          *(undefined8 *)(lVar20 + uVar45 * 8) \u003d 0;\n          pvVar17 \u003d (void *)debug_make_method_type_isra_0(lVar19,lVar38,lVar20,uVar15);\n        }\n        break;\n      default:\n        goto switchD_0010f055_caseD_24;\n      case 0x26:\n        uVar15 \u003d parse_stab_type(param_1,param_2,0,param_4,0,param_6);\n        pvVar17 \u003d (void *)debug_make_reference_type_isra_0(uVar15);\n        break;\n      case 0x28:\n      case 0x2d:\n        goto switchD_0010f055_caseD_28;\n      case 0x2a:\n        uVar15 \u003d parse_stab_type(param_1,param_2,0,param_4,0,param_6);\n        pvVar17 \u003d (void *)debug_make_pointer_type_isra_0(uVar15);\n      }\n    }\n    else if (bVar9 \u003d\u003d 0x52) {\n      if (param_6 \u003c\u003d pbVar27) {\n        return (void *)0x0;\n      }\n      lVar38 \u003d parse_number(param_4,0,param_6);\n      if ((**param_4 !\u003d 0x3b) || (uVar11 \u003d parse_number(param_4,0,param_6), **param_4 !\u003d 0x3b))\n      goto LAB_0010fb4c;\n      if (lVar38 - 3U \u003c 3) {\n        pvVar17 \u003d (void *)debug_make_type_constprop_0(5);\n      }\n      else {\n        pvVar17 \u003d (void *)debug_make_float_type_isra_0(uVar11);\n      }\n    }\n    else {\n      if (bVar9 \u003d\u003d 0x53) {\n        lVar38 \u003d parse_stab_type(param_1,param_2,0,param_4,0,param_6);\n        if (lVar38 \u003d\u003d 0) {\n          return (void *)0x0;\n        }\n        pvVar17 \u003d (void *)debug_make_type_constprop_0(0x11,0);\n        if (pvVar17 \u003d\u003d (void *)0x0) {\n          return (void *)0x0;\n        }\n        plVar39 \u003d (long *)xmalloc(0x10);\n        *(undefined4 *)((long)plVar39 + 9) \u003d 0;\n        *plVar39 \u003d lVar38;\n        *(undefined4 *)((long)plVar39 + 0xc) \u003d 0;\n        *(char *)(plVar39 + 1) \u003d cVar43;\n        *(long **)((long)pvVar17 + 0x10) \u003d plVar39;\n        goto LAB_001115eb;\n      }\n      if (bVar9 !\u003d 0x42) goto switchD_0010f055_caseD_24;\n      uVar15 \u003d parse_stab_type(param_1,param_2,0,param_4,0,param_6);\n      pvVar17 \u003d (void *)debug_make_volatile_type_isra_0(uVar15);\n    }\n  }\n  else {\n    switch(bVar9) {\n    case 0x61:\n      if (pbVar50[1] !\u003d 0x72) goto switchD_0010f055_caseD_24;\n      pbVar50 \u003d pbVar50 + 2;\n      *param_4 \u003d pbVar50;\n      if (param_6 \u003c\u003d pbVar50) {\n        return (void *)0x0;\n      }\n      local_a0 \u003d pbVar50;\n      cVar6 \u003d parse_stab_type_number(\u0026local_a0,\u0026local_98,param_6);\n      if (cVar6 \u003d\u003d \u0027\\0\u0027) {\n        return (void *)0x0;\n      }\n      if ((((uint)local_98 | local_98._4_4_) \u003d\u003d 0) \u0026\u0026 (**param_4 !\u003d 0x3d)) {\n        lVar38 \u003d debug_find_named_type(param_1,\"int\");\n        if ((lVar38 \u003d\u003d 0) \u0026\u0026 (lVar38 \u003d debug_make_int_type_isra_0(4,0), lVar38 \u003d\u003d 0)) {\n          return (void *)0x0;\n        }\n        *param_4 \u003d local_a0;\n      }\n      else {\n        lVar38 \u003d parse_stab_type(param_1,param_2,0,param_4,0,param_6);\n      }\n      pbVar3 \u003d *param_4;\n      if (*pbVar3 !\u003d 0x3b) {\nLAB_0011151b:\n        bad_stab(pbVar50);\n        return (void *)0x0;\n      }\n      *param_4 \u003d pbVar3 + 1;\n      bVar48 \u003d pbVar3[1];\n      bVar48 \u003d (bVar48 !\u003d 0x2d \u0026\u0026 bVar48 !\u003d 0) \u0026\n               ((byte)(*(ushort *)(\u0026_sch_istable + (ulong)bVar48 * 2) \u003e\u003e 2) ^ 1);\n      if (bVar48 !\u003d 0) {\n        *param_4 \u003d pbVar3 + 2;\n      }\n      uVar15 \u003d parse_number(param_4,0,param_6);\n      pbVar3 \u003d *param_4;\n      if (*pbVar3 !\u003d 0x3b) goto LAB_0011151b;\n      *param_4 \u003d pbVar3 + 1;\n      bVar9 \u003d pbVar3[1];\n      bVar9 \u003d (bVar9 !\u003d 0x2d \u0026\u0026 bVar9 !\u003d 0) \u0026\n              ((byte)(*(ushort *)(\u0026_sch_istable + (ulong)bVar9 * 2) \u003e\u003e 2) ^ 1);\n      if (bVar9 !\u003d 0) {\n        *param_4 \u003d pbVar3 + 2;\n        bVar48 \u003d bVar9;\n      }\n      uVar36 \u003d parse_number(param_4,0,param_6);\n      if (**param_4 !\u003d 0x3b) goto LAB_0011151b;\n      *param_4 \u003d *param_4 + 1;\n      lVar19 \u003d parse_stab_type(param_1,param_2,0,param_4,0,param_6);\n      if (lVar19 \u003d\u003d 0) {\n        return (void *)0x0;\n      }\n      if (bVar48 !\u003d 0) {\n        uVar15 \u003d 0;\n      }\n      uVar37 \u003d 0xffffffffffffffff;\n      if (bVar48 \u003d\u003d 0) {\n        uVar37 \u003d uVar36;\n      }\n      pvVar17 \u003d (void *)debug_make_array_type_isra_0(lVar19,lVar38,uVar15,uVar37,cVar43);\n      break;\n    case 0x62:\n      if (param_6 \u003c\u003d pbVar27) {\n        return (void *)0x0;\n      }\n      if (pbVar50[1] \u003d\u003d 0x73) {\n        uVar44 \u003d 0;\n      }\n      else {\n        if (pbVar50[1] !\u003d 0x75) goto LAB_0010fb4c;\n        uVar44 \u003d 1;\n      }\n      *param_4 \u003d pbVar50 + 2;\n      if (((byte)(pbVar50[2] + 0x9e) \u003c 2) || (pbVar50[2] \u003d\u003d 0x76)) {\n        *param_4 \u003d pbVar50 + 3;\n      }\n      parse_number(param_4,0,param_6);\n      if (**param_4 !\u003d 0x3b) goto LAB_0010fb4c;\n      *param_4 \u003d *param_4 + 1;\n      parse_number(param_4,0,param_6);\n      if (**param_4 !\u003d 0x3b) goto LAB_0010fb4c;\n      *param_4 \u003d *param_4 + 1;\n      uVar49 \u003d parse_number(param_4,0,param_6);\n      if (**param_4 \u003d\u003d 0x3b) {\n        *param_4 \u003d *param_4 + 1;\n      }\n      if (uVar49 !\u003d 0) {\n        pvVar17 \u003d (void *)debug_make_int_type_isra_0(uVar49 \u003e\u003e 3 \u0026 0xffffffff,uVar44);\n        break;\n      }\nLAB_0010fa8f:\n      pvVar17 \u003d (void *)debug_make_void_type_isra_0();\n      break;\n    default:\n      goto switchD_0010f055_caseD_24;\n    case 0x65:\n      if (param_6 \u003c\u003d pbVar27) {\n        return (void *)0x0;\n      }\n      if (pbVar50[1] \u003d\u003d 0x2d) {\n        while( true ) {\n          pbVar3 \u003d *param_4;\n          if (*pbVar3 \u003d\u003d 0x3a) break;\n          if (*pbVar3 \u003d\u003d 0) goto LAB_0010fb4c;\n          *param_4 \u003d pbVar3 + 1;\n        }\n        *param_4 \u003d pbVar3 + 1;\n      }\n      uVar45 \u003d 10;\n      pvVar17 \u003d (void *)xmalloc(0x50);\n      pvVar24 \u003d (void *)xmalloc(0x50);\n      uVar49 \u003d 0;\n      while( true ) {\n        pbVar3 \u003d *param_4;\n        pbVar50 \u003d pbVar3;\n        if ((*pbVar3 \u003c 0x3c) \u0026\u0026 ((-0x800100000000002 \u003e\u003e (*pbVar3 \u0026 0x3f) \u0026 1U) \u003d\u003d 0)) break;\n        for (; *pbVar50 !\u003d 0x3a; pbVar50 \u003d pbVar50 + 1) {\n          if (*pbVar50 \u003d\u003d 0) {\n            bad_stab(pbVar27);\n            free(pvVar17);\n            free(pvVar24);\n            return (void *)0x0;\n          }\n        }\n        pvVar25 \u003d (void *)savestring(pbVar3,(int)pbVar50 - (int)pbVar3);\n        *param_4 \u003d pbVar50 + 1;\n        uVar15 \u003d parse_number(param_4,0,param_6);\n        if (**param_4 !\u003d 0x2c) {\n          bad_stab(pbVar27);\n          free(pvVar25);\n          free(pvVar17);\n          free(pvVar24);\n          return (void *)0x0;\n        }\n        uVar12 \u003d (int)uVar49 + 1;\n        *param_4 \u003d *param_4 + 1;\n        if ((uint)uVar45 \u003c\u003d uVar12) {\n          uVar45 \u003d (ulong)((uint)uVar45 + 10);\n          pvVar17 \u003d (void *)xrealloc(pvVar17,uVar45 \u003c\u003c 3);\n          pvVar24 \u003d (void *)xrealloc(pvVar24,uVar45 \u003c\u003c 3);\n        }\n        *(void **)((long)pvVar17 + uVar49 * 8) \u003d pvVar25;\n        *(undefined8 *)((long)pvVar24 + uVar49 * 8) \u003d uVar15;\n        uVar49 \u003d (ulong)uVar12;\n      }\n      *(undefined8 *)((long)pvVar17 + uVar49 * 8) \u003d 0;\n      *(undefined8 *)((long)pvVar24 + uVar49 * 8) \u003d 0;\n      if (**param_4 \u003d\u003d 0x3b) {\n        *param_4 \u003d *param_4 + 1;\n      }\n      pvVar17 \u003d (void *)debug_make_enum_type_isra_0(pvVar17,pvVar24);\n      break;\n    case 0x66:\n      uVar15 \u003d parse_stab_type(param_1,param_2,0,param_4,0,param_6);\n      pvVar17 \u003d (void *)debug_make_function_type_isra_0(uVar15,0,0);\n      break;\n    case 0x6b:\n      uVar15 \u003d parse_stab_type(param_1,param_2,0,param_4,0,param_6);\n      pvVar17 \u003d (void *)debug_make_const_type_isra_0(uVar15);\n      break;\n    case 0x72:\n      if (param_6 \u003c\u003d pbVar27) {\n        return (void *)0x0;\n      }\n      cVar6 \u003d parse_stab_type_number(param_4,\u0026local_98,param_6);\n      if (cVar6 \u003d\u003d \u0027\\0\u0027) {\n        return (void *)0x0;\n      }\n      bVar51 \u003d false;\n      if ((uint)local_98 \u003d\u003d (uint)local_a8) {\n        bVar51 \u003d local_98._4_4_ \u003d\u003d local_a8._4_4_;\n      }\n      lVar38 \u003d 0;\n      if (**param_4 \u003d\u003d 0x3d) {\n        *param_4 \u003d pbVar27;\n        lVar38 \u003d parse_stab_type(param_1,param_2,0,param_4,0,param_6);\n        if (lVar38 \u003d\u003d 0) {\n          return (void *)0x0;\n        }\n      }\n      if (**param_4 \u003d\u003d 0x3b) {\n        *param_4 \u003d *param_4 + 1;\n      }\n      pbVar3 \u003d *param_4;\n      uVar49 \u003d parse_number(param_4,\u0026local_a9,param_6);\n      if (**param_4 !\u003d 0x3b) goto LAB_0010fb4c;\n      pbVar50 \u003d *param_4 + 1;\n      *param_4 \u003d pbVar50;\n      uVar45 \u003d parse_number(param_4,\u0026local_a0,param_6);\n      cVar6 \u003d local_a9;\n      if (**param_4 !\u003d 0x3b) goto LAB_0010fb4c;\n      *param_4 \u003d *param_4 + 1;\n      if ((local_a9 \u003d\u003d \u0027\\0\u0027) \u0026\u0026 ((char)local_a0 \u003d\u003d \u0027\\0\u0027)) {\nLAB_0010f700:\n        if (lVar38 !\u003d 0) goto LAB_0010f956;\n        if ((!bVar51) || (uVar49 !\u003d 0)) {\n          bVar52 \u003d uVar45 !\u003d 0;\n          if ((!bVar51) || (bVar52)) {\n            if (((long)uVar49 \u003c 1) || (bVar52)) {\n              if ((uVar45 \u003d\u003d 0xffffffffffffffff) \u0026\u0026 (uVar49 \u003d\u003d 0)) goto LAB_0010f788;\n              if (uVar49 \u003d\u003d 0) goto LAB_0010f829;\n              if ((-1 \u003c (long)uVar49) || (bVar52)) goto LAB_0010f8cd;\n              if ((uVar49 \u003d\u003d 0xfffffffffffffff8) || (bVar51)) goto LAB_0010f89d;\n              if (uVar49 !\u003d 0xffffffffffffffff) {\n                if (uVar49 !\u003d 1) goto LAB_0010f956;\n                goto LAB_0010f8eb;\n              }\nLAB_0010f8ff:\n              if (uVar45 \u003d\u003d 0x7f) goto LAB_0010f810;\n              if (uVar45 \u003d\u003d 0x7fff) {\nLAB_0010f912:\n                pvVar17 \u003d (void *)debug_make_int_type_isra_0(2,0);\n              }\n              else {\n                if (uVar45 !\u003d 0x7fffffff) {\n                  if (uVar45 \u003d\u003d 0x7fffffffffffffff) goto LAB_0010f7a5;\n                  goto LAB_0010f956;\n                }\nLAB_0010f92f:\n                pvVar17 \u003d (void *)debug_make_int_type_isra_0(4,0);\n              }\n            }\n            else {\n              pvVar17 \u003d (void *)debug_make_float_type_isra_0(uVar49 \u0026 0xffffffff);\n            }\n          }\n          else if ((long)uVar49 \u003c 1) {\n            if (-1 \u003c (long)uVar49) {\nLAB_0010f8cd:\n              if (uVar49 \u003d\u003d ~uVar45) goto LAB_0010f8ff;\n              if (uVar49 \u003d\u003d uVar45 + 1) {\n                if (uVar45 \u003d\u003d 0x7f) goto LAB_0010f810;\nLAB_0010f8eb:\n                if (uVar45 \u003d\u003d 0x7fff) goto LAB_0010f912;\n                if (uVar45 \u003d\u003d 0x7fffffff) goto LAB_0010f92f;\n              }\nLAB_0010f956:\n              if (bVar51) {\nLAB_0010fb4c:\n                bad_stab(pbVar27);\n                return (void *)0x0;\n              }\n              lVar38 \u003d stab_find_type(param_1,param_2,\u0026local_98);\n              if (lVar38 \u003d\u003d 0) {\n                uVar15 \u003d dcgettext(0,\"missing index type\",5);\n                warn_stab(pbVar27,uVar15);\n                lVar38 \u003d debug_make_int_type_isra_0(4,0);\n                if (lVar38 \u003d\u003d 0) {\n                  return (void *)0x0;\n                }\n              }\n              pvVar17 \u003d (void *)debug_make_type_constprop_0(0xf,0);\n              if (pvVar17 \u003d\u003d (void *)0x0) {\n                return (void *)0x0;\n              }\n              plVar39 \u003d (long *)xmalloc(0x18);\n              *plVar39 \u003d lVar38;\n              plVar39[1] \u003d uVar49;\n              plVar39[2] \u003d uVar45;\n              *(long **)((long)pvVar17 + 0x10) \u003d plVar39;\n              goto LAB_001115eb;\n            }\nLAB_0010f89d:\n            pvVar17 \u003d (void *)debug_make_int_type_isra_0(-(int)uVar49,1);\n          }\n          else {\n            pvVar17 \u003d (void *)debug_make_type_constprop_0(5,uVar49 \u0026 0xffffffff);\n          }\n        }\n        else {\n          if (uVar45 \u003d\u003d 0) goto LAB_0010fa8f;\n          if (uVar45 \u003d\u003d 0xffffffffffffffff) {\nLAB_0010f788:\n            if (param_3 !\u003d (char *)0x0) {\n              iVar10 \u003d strcmp(param_3,\"long long int\");\n              if (iVar10 \u003d\u003d 0) goto LAB_0010f7a5;\n              iVar10 \u003d strcmp(param_3,\"long long unsigned int\");\n              if (iVar10 \u003d\u003d 0) goto LAB_0010f7ce;\n            }\nLAB_0010f7f3:\n            pvVar17 \u003d (void *)debug_make_int_type_isra_0(4,1);\n          }\n          else if (uVar45 \u003d\u003d 0x7f) {\nLAB_0010f810:\n            pvVar17 \u003d (void *)debug_make_int_type_isra_0(1,0);\n          }\n          else {\nLAB_0010f829:\n            if ((long)uVar45 \u003c 0) {\n              pvVar17 \u003d (void *)debug_make_int_type_isra_0(-(int)uVar45,1);\n            }\n            else if (uVar45 \u003d\u003d 0xff) {\n              pvVar17 \u003d (void *)debug_make_int_type_isra_0(1,1);\n            }\n            else {\n              if (uVar45 !\u003d 0xffff) {\n                if (uVar45 !\u003d 0xffffffff) goto LAB_0010f956;\n                goto LAB_0010f7f3;\n              }\n              pvVar17 \u003d (void *)debug_make_int_type_isra_0(2,1);\n            }\n          }\n        }\n      }\n      else {\n        if (lVar38 !\u003d 0) {\nLAB_0010f6e2:\n          uVar15 \u003d dcgettext(0,\"numeric overflow\",5);\n          warn_stab(pbVar27,uVar15);\n          goto LAB_0010f700;\n        }\n        cVar8 \u003d startswith_lto_priv_0_lto_priv_0(pbVar3,\"01000000000000000000000;\");\n        if ((cVar8 \u003d\u003d \u0027\\0\u0027) ||\n           (cVar8 \u003d startswith_lto_priv_0_lto_priv_0(pbVar50,\"0777777777777777777777;\"),\n           cVar8 \u003d\u003d \u0027\\0\u0027)) {\n          if ((cVar6 \u003d\u003d \u0027\\x01\u0027) ||\n             ((uVar49 !\u003d 0 ||\n              (cVar6 \u003d startswith_lto_priv_0_lto_priv_0(pbVar50,\"01777777777777777777777;\"),\n              cVar6 \u003d\u003d \u0027\\0\u0027)))) goto LAB_0010f6e2;\nLAB_0010f7ce:\n          pvVar17 \u003d (void *)debug_make_int_type_isra_0(8,1);\n        }\n        else {\nLAB_0010f7a5:\n          pvVar17 \u003d (void *)debug_make_int_type_isra_0(8,0);\n        }\n      }\n      break;\n    case 0x73:\n    case 0x75:\n      uVar49 \u003d parse_number(param_4,0,param_6);\n      pbVar3 \u003d *param_4;\n      if (pbVar3 \u003c param_6) {\n        local_118 \u003d (void *)0x0;\n        if (*pbVar3 \u003d\u003d 0x21) {\n          *param_4 \u003d pbVar3 + 1;\n          uVar12 \u003d parse_number(param_4,0,param_6);\n          if (**param_4 !\u003d 0x2c) {\nLAB_0010fe26:\n            bad_stab(pbVar3);\n            goto LAB_0010fe2e;\n          }\n          *param_4 \u003d *param_4 + 1;\n          lVar38 \u003d 0;\n          local_118 \u003d (void *)xmalloc();\n          while ((uint)lVar38 \u003c uVar12) {\n            bVar1 \u003d **param_4;\n            if (bVar1 \u003d\u003d 0x30) {\nLAB_0010fe06:\n              uVar44 \u003d 0;\n            }\n            else {\n              if (bVar1 !\u003d 0x31) {\n                if (bVar1 !\u003d 0) {\n                  uVar15 \u003d dcgettext(0,\"unknown virtual character for baseclass\",5);\n                  warn_stab(pbVar3,uVar15);\n                  goto LAB_0010fe06;\n                }\n                goto LAB_0010fe26;\n              }\n              uVar44 \u003d 1;\n            }\n            pbVar27 \u003d *param_4;\n            *param_4 \u003d pbVar27 + 1;\n            bVar1 \u003d pbVar27[1];\n            if (bVar1 \u003d\u003d 0x31) {\n              uVar11 \u003d 1;\n            }\n            else {\n              if ((char)bVar1 \u003c \u00272\u0027) {\n                if (bVar1 \u003d\u003d 0) goto LAB_0010fe26;\n                uVar11 \u003d 2;\n                if (bVar1 \u003d\u003d 0x30) goto LAB_0010fd53;\nLAB_0010fe6c:\n                uVar15 \u003d dcgettext(0,\"unknown visibility character for baseclass\",5);\n                warn_stab(pbVar3,uVar15);\n              }\n              else if (bVar1 !\u003d 0x32) goto LAB_0010fe6c;\n              uVar11 \u003d 0;\n            }\nLAB_0010fd53:\n            *param_4 \u003d *param_4 + 1;\n            uVar13 \u003d parse_number(param_4,0,param_6);\n            if (**param_4 !\u003d 0x2c) goto LAB_0010fe26;\n            *param_4 \u003d *param_4 + 1;\n            lVar19 \u003d parse_stab_type(param_1,param_2,0,param_4);\n            if (lVar19 \u003d\u003d 0) goto LAB_0010fe2e;\n            plVar39 \u003d (long *)xmalloc();\n            *(undefined8 *)((long)plVar39 + 0xd) \u003d 0;\n            *(undefined4 *)(plVar39 + 1) \u003d uVar13;\n            *(undefined4 *)((long)plVar39 + 0x14) \u003d 0;\n            *plVar39 \u003d lVar19;\n            *(long **)((long)local_118 + lVar38 * 8) \u003d plVar39;\n            lVar38 \u003d lVar38 + 1;\n            *(undefined *)((long)plVar39 + 0xc) \u003d uVar44;\n            *(undefined4 *)(plVar39 + 2) \u003d uVar11;\n            if (**param_4 !\u003d 0x3b) goto LAB_0010fe2e;\n            *param_4 \u003d *param_4 + 1;\n          }\n          *(undefined8 *)((long)local_118 + lVar38 * 8) \u003d 0;\n        }\n        pbVar3 \u003d *param_4;\n        if (pbVar3 \u003c param_6) {\n          uVar45 \u003d 0;\n          local_158 \u003d (void *)xmalloc(0x50);\n          bVar51 \u003d false;\n          local_150._0_4_ \u003d 10;\n          while (pbVar27 \u003d *param_4, *pbVar27 !\u003d 0x3b) {\n            uVar12 \u003d (int)uVar45 + 1;\n            if ((uint)local_150 \u003c\u003d uVar12) {\n              local_150._0_4_ \u003d (uint)local_150 + 10;\n              local_158 \u003d (void *)xrealloc(local_158);\n            }\n            if (((*pbVar27 \u003d\u003d 0x24) || (*pbVar27 \u003d\u003d 0x2e)) \u0026\u0026 (pbVar27[1] !\u003d 0x5f)) {\n              *param_4 \u003d *param_4 + 1;\n              plVar39 \u003d (long *)((long)local_158 + uVar45 * 8);\n              *plVar39 \u003d 0;\n              pbVar27 \u003d *param_4;\n              if (pbVar27 \u003c param_6) {\n                if (*pbVar27 \u003d\u003d 0x76) {\n                  *param_4 \u003d pbVar27 + 1;\n                  bVar1 \u003d pbVar27[1];\n                  if (bVar1 !\u003d 0) {\n                    *param_4 \u003d pbVar27 + 2;\n                    lVar38 \u003d parse_stab_type(param_1,param_2,0,param_4,0,param_6);\n                    if (lVar38 \u003d\u003d 0) goto LAB_001102dc;\n                    if (bVar1 \u003d\u003d 0x62) {\n                      puVar22 \u003d (undefined *)debug_get_type_name_constprop_0();\n                      if (puVar22 \u003d\u003d (undefined *)0x0) {\n                        uVar15 \u003d dcgettext(0,\"unnamed $vb type\",5);\n                        warn_stab(pbVar27,uVar15);\n                        puVar22 \u003d \u0026DAT_001206ea;\n                      }\n                      pcVar40 \u003d (char *)concat(\u0026DAT_0012077e,puVar22,0);\n                    }\n                    else {\n                      pcVar40 \u003d \"_vptr$\";\n                      if (bVar1 !\u003d 0x66) {\n                        uVar15 \u003d dcgettext(0,\"unrecognized C++ abbreviation\",5);\n                        pcVar40 \u003d \"INVALID_CPLUSPLUS_ABBREV\";\n                        warn_stab(pbVar27,uVar15);\n                      }\n                    }\n                    if (**param_4 \u003d\u003d 0x3a) {\n                      *param_4 \u003d *param_4 + 1;\n                      pcVar16 \u003d (char *)parse_stab_type(param_1,param_2,0);\n                      if (**param_4 \u003d\u003d 0x2c) {\n                        *param_4 \u003d *param_4 + 1;\n                        uVar11 \u003d parse_number(param_4,0,param_6);\n                        if (**param_4 \u003d\u003d 0x3b) {\n                          *param_4 \u003d *param_4 + 1;\n                          ppcVar23 \u003d (char **)xmalloc(0x20);\n                          *(undefined8 *)((long)ppcVar23 + 0x14) \u003d 0;\n                          *(undefined4 *)((long)ppcVar23 + 0x1c) \u003d 0;\n                          *ppcVar23 \u003d pcVar40;\n                          ppcVar23[1] \u003d pcVar16;\n                          *(undefined4 *)(ppcVar23 + 3) \u003d uVar11;\n                          *(undefined4 *)(ppcVar23 + 2) \u003d 2;\n                          *plVar39 \u003d (long)ppcVar23;\n                          goto LAB_001102eb;\n                        }\n                      }\n                    }\n                  }\n                }\n                bad_stab(pbVar27);\n              }\nLAB_001102dc:\n              free(local_158);\n              goto LAB_0010fe2e;\n            }\n            pcVar40 \u003d strchr((char *)pbVar27,0x3a);\n            if (pcVar40 \u003d\u003d (char *)0x0) {\n              bad_stab(pbVar3);\n              free(local_158);\n              goto LAB_0010fe2e;\n            }\n            if (pcVar40[1] \u003d\u003d \u0027:\u0027) break;\n            pbVar27 \u003d *param_4;\n            if (param_6 \u003c\u003d pbVar27) goto LAB_001102dc;\n            pvVar17 \u003d (void *)savestring(pbVar27,(int)pcVar40 - (int)pbVar27);\n            *param_4 \u003d (byte *)(pcVar40 + 1);\n            if (pcVar40[1] \u003d\u003d \u0027/\u0027) {\n              *param_4 \u003d (byte *)(pcVar40 + 2);\n              cVar6 \u003d pcVar40[2];\n              if (cVar6 \u003d\u003d \u00271\u0027) {\n                uVar11 \u003d 1;\n              }\n              else if (cVar6 \u003c \u00272\u0027) {\n                if (cVar6 \u003d\u003d \u0027\\0\u0027) {\n                  bad_stab(pbVar27);\n                  goto LAB_001102dc;\n                }\n                uVar11 \u003d 2;\n                if (cVar6 !\u003d \u00270\u0027) goto LAB_00110152;\n              }\n              else {\n                if (cVar6 !\u003d \u00272\u0027) {\nLAB_00110152:\n                  uVar15 \u003d dcgettext(0,\"unknown visibility character for field\",5);\n                  warn_stab(pbVar27,uVar15);\n                }\n                uVar11 \u003d 0;\n              }\n              *param_4 \u003d *param_4 + 1;\n            }\n            else {\n              uVar11 \u003d 0;\n            }\n            pvVar24 \u003d (void *)parse_stab_type(param_1,param_2,0,param_4);\n            if (pvVar24 \u003d\u003d (void *)0x0) {\nLAB_001101e1:\n              free(pvVar17);\n              goto LAB_001102dc;\n            }\n            puVar32 \u003d (undefined8 *)((long)local_158 + uVar45 * 8);\n            pbVar50 \u003d *param_4;\n            if (*pbVar50 !\u003d 0x3a) {\n              if (*pbVar50 \u003d\u003d 0x2c) {\n                *param_4 \u003d pbVar50 + 1;\n                uVar45 \u003d parse_number(param_4,0,param_6);\n                if (**param_4 \u003d\u003d 0x2c) {\n                  *param_4 \u003d *param_4 + 1;\n                  uVar26 \u003d parse_number(param_4,0,param_6);\n                  if (**param_4 \u003d\u003d 0x3b) {\n                    *param_4 \u003d *param_4 + 1;\n                    if ((uVar45 | uVar26) \u003d\u003d 0) {\n                      uVar11 \u003d 3;\n                    }\n                    ppvVar18 \u003d (void **)xmalloc(0x20);\n                    *(undefined8 *)((long)ppvVar18 + 0x14) \u003d 0;\n                    *ppvVar18 \u003d pvVar17;\n                    ppvVar18[1] \u003d pvVar24;\n                    *(int *)(ppvVar18 + 3) \u003d (int)uVar45;\n                    *(int *)((long)ppvVar18 + 0x1c) \u003d (int)uVar26;\n                    *(undefined4 *)(ppvVar18 + 2) \u003d uVar11;\n                    *puVar32 \u003d ppvVar18;\n                    goto LAB_001102eb;\n                  }\n                }\n              }\nLAB_001101d9:\n              bad_stab(pbVar27);\n              goto LAB_001101e1;\n            }\n            pbVar50 \u003d pbVar50 + 1;\n            *param_4 \u003d pbVar50;\n            pcVar40 \u003d strchr((char *)pbVar50,0x3b);\n            if (pcVar40 \u003d\u003d (char *)0x0) goto LAB_001101d9;\n            pvVar25 \u003d (void *)savestring(pbVar50);\n            *param_4 \u003d (byte *)(pcVar40 + 1);\n            ppvVar18 \u003d (void **)xmalloc(0x20);\n            bVar51 \u003d true;\n            *(undefined8 *)((long)ppvVar18 + 0x15) \u003d 0;\n            *ppvVar18 \u003d pvVar17;\n            ppvVar18[1] \u003d pvVar24;\n            *(undefined *)((long)ppvVar18 + 0x14) \u003d 1;\n            ppvVar18[3] \u003d pvVar25;\n            *(undefined4 *)(ppvVar18 + 2) \u003d uVar11;\n            *puVar32 \u003d ppvVar18;\nLAB_001102eb:\n            uVar45 \u003d (ulong)uVar12;\n          }\n          *(undefined8 *)((long)local_158 + uVar45 * 8) \u003d 0;\n          pbVar3 \u003d *param_4;\n          if (param_6 \u003c\u003d pbVar3) goto LAB_001112f3;\n          local_128 \u003d (char *)0x0;\n          pbVar27 \u003d (byte *)0x0;\n          pvVar24 \u003d (void *)0x0;\n          local_150 \u003d (char *)0x0;\n          local_e0 \u003d 0;\n          local_fc \u003d 0;\nLAB_00110345:\n          pbVar50 \u003d *param_4;\n          bVar1 \u003d *pbVar50;\n          if (((bVar1 !\u003d 0x3b) \u0026\u0026 (pcVar40 \u003d strchr((char *)pbVar50,0x3a), pcVar40 !\u003d (char *)0x0))\n             \u0026\u0026 (pcVar40[1] \u003d\u003d \u0027:\u0027)) {\n            pbVar28 \u003d (byte *)(pcVar40 + 2);\n            if (((bVar1 \u003d\u003d 0x6f) \u0026\u0026 (pbVar50[1] \u003d\u003d 0x70)) \u0026\u0026 (pbVar50[2] \u003d\u003d 0x24)) {\n              *param_4 \u003d pbVar28;\n              for (pbVar50 \u003d pbVar28; *pbVar50 !\u003d 0x2e; pbVar50 \u003d pbVar50 + 1) {\n                if (*pbVar50 \u003d\u003d 0) goto LAB_00110788;\n              }\n              pbVar50 \u003d pbVar50 + 1;\n              local_150 \u003d (char *)savestring(pbVar28);\n            }\n            else {\n              local_150 \u003d (char *)savestring(pbVar50);\n              pbVar50 \u003d pbVar28;\n            }\n            *param_4 \u003d pbVar50;\n            local_128 \u003d (char *)xmalloc();\n            local_ec \u003d 10;\n            local_140 \u003d (byte *)0x0;\n            local_f0 \u003d 0;\nLAB_00110406:\n            pbVar50 \u003d local_140;\n            if (local_140 \u003d\u003d (byte *)0x0) {\n              pbVar50 \u003d (byte *)parse_stab_type(param_1,param_2,0);\n              if (pbVar50 \u003d\u003d (byte *)0x0) goto LAB_001111e9;\n              if (**param_4 !\u003d 0x3a) goto LAB_00110788;\n            }\n            pbVar28 \u003d *param_4;\n            *param_4 \u003d pbVar28 + 1;\n            pcVar40 \u003d strchr((char *)(pbVar28 + 1),0x3b);\n            if (pcVar40 \u003d\u003d (char *)0x0) goto LAB_00110788;\n            piVar21 \u003d (int *)debug_get_real_type_isra_0(pbVar50,0);\n            bVar52 \u003d false;\n            if ((piVar21 !\u003d (int *)0x0) \u0026\u0026 (bVar52 \u003d false, *piVar21 \u003d\u003d 0x13)) {\n              bVar52 \u003d true;\n              piVar21 \u003d (int *)debug_get_real_type_isra_0(pbVar50,0);\n              if (piVar21 !\u003d (int *)0x0) {\n                if (*piVar21 \u003d\u003d 0xd) {\n                  lVar38 \u003d *(long *)(*(long *)(piVar21 + 4) + 8);\n                }\n                else {\n                  if (*piVar21 !\u003d 0x13) goto LAB_001104b1;\n                  lVar38 \u003d *(long *)(*(long *)(piVar21 + 4) + 0x10);\n                }\n                bVar52 \u003d lVar38 \u003d\u003d 0;\n              }\n            }\nLAB_001104b1:\n            pbVar27 \u003d (byte *)savestring(*param_4,(int)pcVar40 - (int)*param_4);\n            *param_4 \u003d (byte *)(pcVar40 + 1);\n            cVar6 \u003d pcVar40[1];\n            if (cVar6 \u003d\u003d \u00270\u0027) {\n              local_100 \u003d 2;\n            }\n            else if (cVar6 \u003d\u003d \u00271\u0027) {\n              local_100 \u003d 1;\n            }\n            else {\n              if (cVar6 \u003d\u003d \u0027\\0\u0027) goto LAB_00110788;\n              local_100 \u003d 0;\n            }\n            *param_4 \u003d (byte *)(pcVar40 + 2);\n            bVar1 \u003d pcVar40[2];\n            if (\u0027D\u0027 \u003c (char)bVar1) {\nswitchD_00110537_caseD_40:\n              uVar15 \u003d dcgettext(0,\"const/volatile indicator missing\",5);\n              warn_stab(pbVar3,uVar15);\n              goto switchD_00110537_caseD_3f;\n            }\n            if ((char)bVar1 \u003c \u0027?\u0027) {\n              if ((bVar1 \u0026 0xfb) !\u003d 0x2a) goto switchD_00110537_caseD_40;\n              goto switchD_00110537_caseD_3f;\n            }\n            switch(bVar1) {\n            default:\n              goto switchD_00110537_caseD_40;\n            case 0x41:\n              *param_4 \u003d (byte *)(pcVar40 + 3);\n            case 0x3f:\nswitchD_00110537_caseD_3f:\n              local_130 \u003d \u0027\\0\u0027;\n              local_138 \u003d \u0027\\0\u0027;\n              break;\n            case 0x42:\n              local_130 \u003d \u0027\\0\u0027;\n              *param_4 \u003d (byte *)(pcVar40 + 3);\n              local_138 \u003d \u0027\\x01\u0027;\n              break;\n            case 0x43:\n              local_130 \u003d \u0027\\x01\u0027;\n              *param_4 \u003d (byte *)(pcVar40 + 3);\n              local_138 \u003d \u0027\\0\u0027;\n              break;\n            case 0x44:\n              local_130 \u003d \u0027\\x01\u0027;\n              *param_4 \u003d (byte *)(pcVar40 + 3);\n              local_138 \u003d \u0027\\x01\u0027;\n            }\n            pbVar28 \u003d *param_4;\n            bVar1 \u003d *pbVar28;\n            pbVar31 \u003d pbVar27;\n            if (bVar1 \u003d\u003d 0x2e) {\n              *param_4 \u003d pbVar28 + 1;\nLAB_001106bd:\n              bVar41 \u003d false;\n              local_120 \u003d (byte *)0x0;\n              local_110 \u003d (byte *)0x0;\n              local_140 \u003d (byte *)0x0;\n            }\n            else {\n              if (bVar1 \u003d\u003d 0x3f) {\n                *param_4 \u003d pbVar28 + 1;\n                sVar33 \u003d strlen(local_150);\n                iVar10 \u003d strncmp((char *)pbVar27,local_150,sVar33);\n                if (iVar10 \u003d\u003d 0) {\n                  bVar41 \u003d true;\n                  local_120 \u003d (byte *)0x0;\n                  local_110 \u003d (byte *)0x0;\n                  local_140 \u003d (byte *)0x0;\n                  goto LAB_00110703;\n                }\n                bVar41 \u003d true;\n                local_140 \u003d (byte *)0x0;\n                local_120 \u003d (byte *)0x0;\n                local_110 \u003d (byte *)0x0;\nLAB_0011072b:\n                lVar38 \u003d stab_find_type(param_1,param_2,\u0026local_a8);\n                if (lVar38 \u003d\u003d 0) goto LAB_001111e9;\n                piVar21 \u003d (int *)debug_get_real_type_isra_0(pbVar50,0);\n                if ((piVar21 \u003d\u003d (int *)0x0) ||\n                   (((*piVar21 !\u003d 0xd \u0026\u0026 (*piVar21 !\u003d 0x13)) ||\n                    (lVar19 \u003d **(long **)(piVar21 + 4), lVar19 \u003d\u003d 0)))) goto LAB_00110788;\n                bVar1 \u003d *pbVar27;\n                if (((bVar1 \u003d\u003d 0x5f) \u0026\u0026 (pbVar27[1] \u003d\u003d 0x5f)) \u0026\u0026\n                   ((bVar47 \u003d pbVar27[2], ((\u0026_sch_istable)[(ulong)bVar47 * 2] \u0026 4) !\u003d 0 ||\n                    (bVar47 \u003d\u003d 0x51 || bVar47 \u003d\u003d 0x74)))) {\n                  bVar52 \u003d true;\n                  bVar47 \u003d 1;\nLAB_00110827:\n                  bVar2 \u003d pbVar27[1];\n                  if ((bVar2 \u003d\u003d 0x24) || (bVar2 \u003d\u003d 0x2e)) {\n                    if (pbVar27[2] !\u003d 0x5f) goto LAB_0011085d;\n                    goto LAB_00110a69;\n                  }\n                  bVar7 \u003d startswith_lto_priv_0_lto_priv_0(pbVar27,\u0026DAT_001207c3);\n                  if (bVar2 !\u003d 0x5a) goto LAB_0011086f;\n                  if ((bVar47 | bVar7) !\u003d 0) goto LAB_00110a58;\n                  uVar45 \u003d 0;\nLAB_00110a9d:\n                  local_a0 \u003d pbVar31;\n                  if ((*pbVar31 \u003d\u003d 0x5f) \u0026\u0026 (pbVar31[1] \u003d\u003d 0x5a)) {\n                    sVar33 \u003d strlen((char *)pbVar31);\n                    cplus_demangle_init_info(pbVar31,3,sVar33,\u0026local_98);\n                    pvVar17 \u003d malloc((long)local_6c \u003c\u003c 5);\n                    local_78 \u003d pvVar17;\n                    pvVar25 \u003d malloc((long)local_5c \u003c\u003c 3);\n                    local_68 \u003d pvVar25;\n                    if ((pvVar17 \u003d\u003d (void *)0x0) || (pvVar25 \u003d\u003d (void *)0x0)) {\n                      free(pvVar17);\n                      free(pvVar25);\n                    }\n                    else {\n                      piVar21 \u003d (int *)cplus_demangle_mangled_name(\u0026local_98,1);\n                      if (*(char *)CONCAT71(uStack_7f,local_80) \u003d\u003d \u0027\\0\u0027) {\n                        free(local_68);\n                        pvVar17 \u003d local_78;\n                        if (piVar21 !\u003d (int *)0x0) {\n                          if ((*piVar21 \u003d\u003d 3) \u0026\u0026 (**(int **)(piVar21 + 6) \u003d\u003d 0x29)) {\n                            lVar20 \u003d stab_demangle_v3_arglist\n                                               (param_1,param_2,\n                                                *(undefined8 *)(*(int **)(piVar21 + 6) + 6),\n                                                \u0026local_a9);\n                            free(pvVar17);\n                            goto LAB_001110a9;\n                          }\n                          pcVar40 \u003d (char *)dcgettext(0,\"Demangled name is not a function\\n\",5);\n                          fprintf(_stderr,pcVar40);\n                          free(pvVar17);\n                          goto LAB_001111e9;\n                        }\n                      }\n                      else {\n                        free(local_68);\n                      }\n                      free(local_78);\n                    }\n                    stab_bad_demangle(pbVar31);\n                  }\n                  else {\n                    local_80 \u003d \u0027\\0\u0027;\n                    local_88 \u003d 0;\n                    local_6c \u003d 10;\n                    local_98 \u003d param_1;\n                    local_90 \u003d param_2;\n                    local_78 \u003d (void *)xmalloc(0xa0);\n                    pbVar50 \u003d local_a0;\n                    local_70 \u003d 0;\n                    pbVar28 \u003d local_a0;\n                    if ((int)uVar45 \u003d\u003d 0) {\n                      do {\n                        pbVar42 \u003d (byte *)strchr((char *)pbVar28,0x5f);\n                        if (pbVar42 \u003d\u003d (byte *)0x0) {\n                          stab_bad_demangle(pbVar50);\n                          goto LAB_00111097;\n                        }\n                        pbVar28 \u003d pbVar42 + 1;\n                      } while (pbVar42[1] !\u003d 0x5f);\n                      sVar33 \u003d strspn((char *)pbVar42,\"_\");\n                      if (2 \u003c (uint)sVar33) {\n                        pbVar42 \u003d pbVar42 + ((uint)sVar33 - 2);\n                      }\n                    }\n                    else {\n                      pbVar42 \u003d local_a0 + uVar45;\n                    }\n                    bVar1 \u003d pbVar42[2];\n                    if (local_a0 \u003d\u003d pbVar42) {\n                      if ((((\u0026_sch_istable)[(ulong)bVar1 * 2] \u0026 4) !\u003d 0) ||\n                         (pbVar50 \u003d pbVar42, bVar1 \u003d\u003d 0x51 || bVar1 \u003d\u003d 0x74)) {\n                        local_a0 \u003d pbVar42 + 2;\nLAB_00110d86:\n                        pbVar50 \u003d local_a0;\n                        if (*local_a0 !\u003d 0) {\n                          pbVar28 \u003d (byte *)0x0;\n                          cVar8 \u003d \u0027\\0\u0027;\n                          cVar6 \u003d \u0027\\0\u0027;\n                          while (pbVar42 \u003d local_a0, bVar1 \u003d *local_a0, bVar1 !\u003d 0) {\n                            if (bVar1 \u003d\u003d 0x51) {\n                              cVar6 \u003d stab_demangle_qualified(\u0026local_98,\u0026local_a0,0);\n                              if (cVar6 !\u003d \u0027\\0\u0027) {\n                                cVar6 \u003d stab_demangle_remember_type\n                                                  (\u0026local_98,pbVar42,(int)local_a0 - (int)pbVar42);\njoined_r0x00110fbc:\n                                if (cVar6 !\u003d \u0027\\0\u0027) {\n                                  pbVar28 \u003d (byte *)0x0;\n                                  goto LAB_0011100c;\n                                }\n                              }\n                              goto LAB_00111097;\n                            }\n                            if (\u0027Q\u0027 \u003c (char)bVar1) {\n                              if (bVar1 \u003d\u003d 0x5f) {\n                                stab_bad_demangle(pbVar50);\n                              }\n                              else {\n                                if (bVar1 !\u003d 0x74) {\n                                  if (bVar1 !\u003d 0x53) goto LAB_00110fd7;\n                                  goto LAB_00110ead;\n                                }\n                                if (pbVar28 \u003d\u003d (byte *)0x0) {\n                                  pbVar28 \u003d local_a0;\n                                }\n                                cVar6 \u003d stab_demangle_template(\u0026local_98,\u0026local_a0,0);\n                                if (cVar6 !\u003d \u0027\\0\u0027) {\n                                  cVar6 \u003d stab_demangle_remember_type\n                                                    (\u0026local_98,pbVar28,(int)local_a0 - (int)pbVar28)\n                                  ;\n                                  goto joined_r0x00110fbc;\n                                }\n                              }\n                              goto LAB_00111097;\n                            }\n                            if (bVar1 !\u003d 0x43) {\n                              if ((char)bVar1 \u003c \u0027D\u0027) {\n                                if ((byte)(bVar1 - 0x30) \u003c 10) {\n                                  if (pbVar28 \u003d\u003d (byte *)0x0) {\n                                    pbVar28 \u003d local_a0;\n                                  }\n                                  uVar12 \u003d stab_demangle_count(\u0026local_a0);\n                                  pbVar5 \u003d local_a0;\n                                  sVar33 \u003d strlen((char *)local_a0);\n                                  if (uVar12 \u003c\u003d sVar33) {\n                                    local_a0 \u003d pbVar5 + uVar12;\n                                    cVar6 \u003d stab_demangle_remember_type\n                                                      (\u0026local_98,pbVar28,\n                                                       (int)local_a0 - (int)pbVar28);\n                                    goto joined_r0x00110fbc;\n                                  }\n                                  stab_bad_demangle(pbVar42);\n                                  goto LAB_00111097;\n                                }\n                              }\n                              else if (bVar1 \u003d\u003d 0x46) {\n                                local_a0 \u003d local_a0 + 1;\n                                cVar8 \u003d stab_demangle_args(\u0026local_98,\u0026local_a0,\u0026local_88,\u0026local_80);\n                                if (cVar8 !\u003d \u0027\\0\u0027) {\n                                  pbVar28 \u003d (byte *)0x0;\n                                  pbVar42 \u003d local_a0;\n                                  goto LAB_00111004;\n                                }\n                                goto LAB_00111097;\n                              }\nLAB_00110fd7:\n                              cVar8 \u003d stab_demangle_args(\u0026local_98,\u0026local_a0,\u0026local_88,\u0026local_80);\n                              pbVar42 \u003d local_a0;\n                              if (cVar8 !\u003d \u0027\\0\u0027) goto LAB_00111004;\n                              goto LAB_00111097;\n                            }\nLAB_00110ead:\n                            pbVar42 \u003d local_a0 + 1;\n                            if (pbVar28 \u003d\u003d (byte *)0x0) {\n                              pbVar28 \u003d local_a0;\n                            }\nLAB_00111004:\n                            local_a0 \u003d pbVar42;\n                            if (cVar6 !\u003d \u0027\\0\u0027) {\nLAB_0011100c:\n                              cVar8 \u003d stab_demangle_args(\u0026local_98,\u0026local_a0,\u0026local_88,\u0026local_80);\n                              cVar6 \u003d cVar8;\n                              if (cVar8 \u003d\u003d \u0027\\0\u0027) goto LAB_00111097;\n                            }\n                          }\n                          if ((cVar8 \u003d\u003d \u0027\\0\u0027) \u0026\u0026\n                             (cVar6 \u003d stab_demangle_args(\u0026local_98,\u0026local_a0,\u0026local_88,\u0026local_80),\n                             cVar6 \u003d\u003d \u0027\\0\u0027)) goto LAB_00111097;\n                        }\n                        free(local_78);\n                        local_78 \u003d (void *)0x0;\n                        if (local_88 \u003d\u003d 0) {\n                          pcVar40 \u003d (char *)dcgettext(0,\"no argument types in mangled string\\n\",5);\n                          fprintf(_stderr,pcVar40);\n                        }\n                        local_a9 \u003d local_80;\n                        lVar20 \u003d local_88;\nLAB_001110a9:\n                        if (lVar20 !\u003d 0) {\n                          pbVar50 \u003d (byte *)debug_make_method_type_isra_0\n                                                      (lVar19,lVar38,lVar20,local_a9);\n                          goto LAB_001110d5;\n                        }\n                        goto LAB_001111e9;\n                      }\n                      for (; *pbVar50 \u003d\u003d 0x5f; pbVar50 \u003d pbVar50 + 1) {\n                      }\n                      pcVar40 \u003d strstr((char *)pbVar50,\"__\");\n                      if ((pcVar40 !\u003d (char *)0x0) \u0026\u0026 (pcVar40[2] !\u003d \u0027\\0\u0027)) {\n                        cVar6 \u003d stab_demangle_function_name_constprop_0(\u0026local_98,\u0026local_a0,pcVar40)\n                        ;\n                        goto LAB_00110d7e;\n                      }\n                      stab_bad_demangle(pbVar42);\n                    }\n                    else if (bVar1 \u003d\u003d 0) {\n                      stab_bad_demangle(local_a0);\n                    }\n                    else {\n                      cVar6 \u003d stab_demangle_function_name_constprop_0(\u0026local_98,\u0026local_a0,pbVar42);\nLAB_00110d7e:\n                      if (cVar6 !\u003d \u0027\\0\u0027) goto LAB_00110d86;\n                    }\nLAB_00111097:\n                    free(local_78);\n                  }\n                  goto LAB_001111e9;\n                }\n                cVar6 \u003d startswith_lto_priv_0_lto_priv_0(pbVar27,\u0026DAT_001207be);\n                if (cVar6 \u003d\u003d \u0027\\0\u0027) {\n                  if (param_3 \u003d\u003d (char *)0x0) {\n                    bVar47 \u003d 0;\n                    bVar52 \u003d false;\n                  }\n                  else {\n                    iVar10 \u003d strcmp(local_150,param_3);\n                    bVar52 \u003d iVar10 \u003d\u003d 0;\n                    bVar47 \u003d 0;\n                  }\n                }\n                else {\n                  bVar47 \u003d 1;\n                  bVar52 \u003d true;\n                }\n                if (bVar1 \u003d\u003d 0x5f) goto LAB_00110827;\nLAB_0011085d:\n                bVar7 \u003d startswith_lto_priv_0_lto_priv_0(pbVar27,\u0026DAT_001207c3);\nLAB_0011086f:\n                if ((bVar47 | bVar7) \u003d\u003d 0) {\n                  pcVar40 \u003d param_3;\n                  if (param_3 \u003d\u003d (char *)0x0) {\n                    if (local_138 \u003d\u003d \u0027\\0\u0027) {\n                      pcVar16 \u003d \"\";\n                      if (local_130 !\u003d \u0027\\0\u0027) {\n                        pcVar16 \u003d \"V\";\n                      }\n                      pcVar46 \u003d \"\";\n                    }\n                    else {\n                      pcVar16 \u003d \"\";\n                      if (local_130 !\u003d \u0027\\0\u0027) {\n                        pcVar16 \u003d \"V\";\n                      }\n                      pcVar46 \u003d \"C\";\n                    }\nLAB_00110917:\n                    iVar10 \u003d 0;\n                    sprintf((char *)\u0026local_98,\"__%s%s\",pcVar46,pcVar16);\n                  }\n                  else {\n                    pcVar46 \u003d \"C\";\n                    pcVar16 \u003d \"V\";\n                    sVar33 \u003d strlen(param_3);\n                    iVar10 \u003d (int)sVar33;\n                    if (local_138 \u003d\u003d \u0027\\0\u0027) {\n                      pcVar46 \u003d \"\";\n                    }\n                    if (local_130 \u003d\u003d \u0027\\0\u0027) {\n                      pcVar16 \u003d \"\";\n                    }\n                    if (iVar10 \u003d\u003d 0) goto LAB_00110917;\n                    pcVar29 \u003d strchr(param_3,0x3c);\n                    if (pcVar29 \u003d\u003d (char *)0x0) {\n                      sprintf((char *)\u0026local_98,\"__%s%s%d\",pcVar46,pcVar16);\n                    }\n                    else {\n                      iVar10 \u003d 0;\n                      sprintf((char *)\u0026local_98,\"__%s%s\",pcVar46,pcVar16);\n                      pcVar40 \u003d (char *)0x0;\n                    }\n                  }\n                  iVar14 \u003d 0;\n                  if (!bVar52) {\n                    sVar33 \u003d strlen(local_150);\n                    iVar14 \u003d (int)sVar33;\n                  }\n                  sVar33 \u003d strlen((char *)\u0026local_98);\n                  sVar30 \u003d strlen((char *)pbVar27);\n                  local_d0 \u003d (int)sVar33;\n                  if (((*local_150 \u003d\u003d \u0027o\u0027) \u0026\u0026 (local_150[1] \u003d\u003d \u0027p\u0027)) \u0026\u0026\n                     ((local_150[2] \u003d\u003d \u0027$\u0027 || (local_150[2] \u003d\u003d \u0027.\u0027)))) goto LAB_001111e9;\n                  pbVar31 \u003d (byte *)xmalloc(iVar10 + 1 + iVar14 + local_d0 + (int)sVar30);\n                  if (bVar52) {\n                    *pbVar31 \u003d 0;\n                  }\n                  else {\n                    strcpy((char *)pbVar31,local_150);\n                  }\n                  sVar33 \u003d strlen((char *)pbVar31);\n                  uVar45 \u003d sVar33 \u0026 0xffffffff;\n                  strcpy((char *)(pbVar31 + sVar33),(char *)\u0026local_98);\n                  if (pcVar40 !\u003d (char *)0x0) {\n                    strcat((char *)pbVar31,pcVar40);\n                  }\n                  strcat((char *)pbVar31,(char *)pbVar27);\n                  if (*pbVar27 !\u003d 0) goto LAB_00110a9d;\n                }\n                else {\nLAB_00110a58:\n                  if ((bVar1 !\u003d 0) \u0026\u0026 ((bVar7 \u0026 1) \u003d\u003d 0)) {\n                    uVar45 \u003d 0;\n                    goto LAB_00110a9d;\n                  }\n                }\nLAB_00110a69:\n                puVar32 \u003d (undefined8 *)xmalloc(8);\n                *puVar32 \u003d 0;\n                pbVar50 \u003d (byte *)debug_make_method_type_isra_0(lVar19,lVar38,puVar32,0);\nLAB_001110d5:\n                if (pbVar50 \u003d\u003d (byte *)0x0) goto LAB_001111e9;\n                goto LAB_001110de;\n              }\n              if (bVar1 !\u003d 0x2a) {\n                warn_stab(pbVar3,\"member function type missing\");\n                goto LAB_001106bd;\n              }\n              *param_4 \u003d pbVar28 + 1;\n              uVar12 \u003d parse_number(param_4,0,param_6);\n              pbVar28 \u003d *param_4;\n              if (*pbVar28 !\u003d 0x3b) goto LAB_00110788;\n              local_110 \u003d (byte *)(ulong)(uVar12 \u0026 0x7fffffff);\n              *param_4 \u003d pbVar28 + 1;\n              bVar41 \u003d pbVar28[1] \u003d\u003d 0x3b || pbVar28[1] \u003d\u003d 0;\n              if (bVar41) {\n                bVar41 \u003d false;\n                local_120 \u003d (byte *)0x0;\n                local_140 \u003d (byte *)0x0;\n              }\n              else {\n                pbVar28 \u003d (byte *)parse_stab_type(param_1,param_2,0,param_4);\n                bVar1 \u003d **param_4;\n                if (bVar1 !\u003d 0x3a) {\n                  if (bVar1 \u003d\u003d 0x3b) {\n                    *param_4 \u003d *param_4 + 1;\n                    local_140 \u003d (byte *)0x0;\n                    local_120 \u003d pbVar28;\n                    goto LAB_00110703;\n                  }\n                  goto LAB_00110788;\n                }\n                local_120 \u003d (byte *)0x0;\n                local_140 \u003d pbVar28;\n              }\n            }\nLAB_00110703:\n            if (bVar52) goto LAB_0011072b;\nLAB_001110de:\n            uVar12 \u003d local_f0 + 1;\n            if (local_ec \u003c\u003d uVar12) {\n              local_ec \u003d local_ec + 10;\n              local_128 \u003d (char *)xrealloc(local_128,(ulong)local_ec \u003c\u003c 3);\n            }\n            if (bVar41) {\n              ppbVar34 \u003d (byte **)xmalloc(0x28);\n              puVar22 \u003d (undefined *)((long)ppbVar34 + 0x16);\n              for (lVar38 \u003d 0x12; lVar38 !\u003d 0; lVar38 \u003d lVar38 + -1) {\n                *puVar22 \u003d 0;\n                puVar22 \u003d puVar22 + (ulong)bVar48 * -2 + 1;\n              }\n              *ppbVar34 \u003d pbVar31;\n              ppbVar34[1] \u003d pbVar50;\n              *(undefined4 *)(ppbVar34 + 2) \u003d local_100;\n              ppbVar34[3] \u003d (byte *)0xffffffffffffffff;\n              *(char *)((long)ppbVar34 + 0x14) \u003d local_138;\n              *(char *)((long)ppbVar34 + 0x15) \u003d local_130;\n            }\n            else {\n              ppbVar34 \u003d (byte **)xmalloc(0x28);\n              puVar22 \u003d (undefined *)((long)ppbVar34 + 0x16);\n              for (lVar38 \u003d 0x12; lVar38 !\u003d 0; lVar38 \u003d lVar38 + -1) {\n                *puVar22 \u003d 0;\n                puVar22 \u003d puVar22 + (ulong)bVar48 * -2 + 1;\n              }\n              *ppbVar34 \u003d pbVar31;\n              ppbVar34[1] \u003d pbVar50;\n              *(undefined4 *)(ppbVar34 + 2) \u003d local_100;\n              *(char *)((long)ppbVar34 + 0x14) \u003d local_138;\n              *(char *)((long)ppbVar34 + 0x15) \u003d local_130;\n              ppbVar34[3] \u003d local_110;\n              ppbVar34[4] \u003d local_120;\n            }\n            *(byte ***)(local_128 + (ulong)local_f0 * 8) \u003d ppbVar34;\n            pbVar50 \u003d *param_4;\n            if ((*pbVar50 \u003d\u003d 0x3b) || (local_f0 \u003d uVar12, *pbVar50 \u003d\u003d 0)) goto LAB_00111678;\n            goto LAB_00110406;\n          }\n          if (pvVar24 !\u003d (void *)0x0) {\n            *(undefined8 *)((long)pvVar24 + (ulong)local_fc * 8) \u003d 0;\n          }\n          pbVar3 \u003d *param_4;\n          if (param_6 \u003c\u003d pbVar3) goto LAB_001112f3;\n          if (*pbVar3 \u003d\u003d 0x3b) {\n            *param_4 \u003d pbVar3 + 1;\n          }\n          pbVar27 \u003d *param_4;\n          if (*pbVar27 \u003d\u003d 0x7e) {\n            *param_4 \u003d pbVar27 + 1;\n            if (((pbVar27[1] \u0026 0xef) \u003d\u003d 0x2d) || (pbVar27[1] \u003d\u003d 0x2b)) {\n              *param_4 \u003d pbVar27 + 2;\n            }\n            if (**param_4 !\u003d 0x25) goto LAB_001112ee;\n            pbVar27 \u003d *param_4 + 1;\n            *param_4 \u003d pbVar27;\n            cVar6 \u003d parse_stab_type_number(param_4,\u0026local_98,param_6);\n            if (cVar6 \u003d\u003d \u0027\\0\u0027) goto LAB_001112f3;\n            if ((uint)local_98 !\u003d (uint)local_a8) {\nLAB_001112a2:\n              *param_4 \u003d pbVar27;\n              pvVar25 \u003d (void *)parse_stab_type(param_1,param_2,0,param_4,0,param_6);\n              for (pbVar27 \u003d *param_4; *pbVar27 !\u003d 0x3b; pbVar27 \u003d pbVar27 + 1) {\n                if (*pbVar27 \u003d\u003d 0) {\n                  bad_stab(pbVar3);\n                  goto LAB_001112f3;\n                }\n              }\n              *param_4 \u003d pbVar27 + 1;\n              goto LAB_00111307;\n            }\n            if (local_98._4_4_ !\u003d local_a8._4_4_) goto LAB_001112a2;\n            pvVar25 \u003d (void *)0x0;\n          }\n          else {\nLAB_001112ee:\n            pvVar25 \u003d (void *)0x0;\nLAB_00111307:\n            if ((((ulong)local_118 | (ulong)pvVar24 | (ulong)pvVar25) \u003d\u003d 0) \u0026\u0026 (!bVar51)) {\n              pvVar17 \u003d (void *)debug_make_struct_type_isra_0(bVar9 \u003d\u003d 0x73,uVar49,local_158);\n              break;\n            }\n            cVar6 \u003d \u0027\\0\u0027;\n          }\n          pvVar17 \u003d (void *)debug_make_type_constprop_0((bVar9 !\u003d 0x73) + \u0027\\t\u0027,uVar49 \u0026 0xffffffff);\n          if (pvVar17 \u003d\u003d (void *)0x0) {\n            return (void *)0x0;\n          }\n          ppvVar35 \u003d (void **)xmalloc(0x28);\n          lVar38 \u003d 8;\n          ppvVar18 \u003d ppvVar35 + 1;\n          if (cVar6 !\u003d \u0027\\0\u0027) {\n            pvVar25 \u003d pvVar17;\n          }\n          for (; lVar38 !\u003d 0; lVar38 \u003d lVar38 + -1) {\n            *(undefined4 *)ppvVar18 \u003d 0;\n            ppvVar18 \u003d (void **)((long)ppvVar18 + (ulong)bVar48 * -8 + 4);\n          }\n          ppvVar35[3] \u003d pvVar24;\n          ppvVar35[4] \u003d pvVar25;\n          *ppvVar35 \u003d local_158;\n          ppvVar35[2] \u003d local_118;\n          *(void ***)((long)pvVar17 + 0x10) \u003d ppvVar35;\n          goto LAB_001115eb;\n        }\n      }\nLAB_0010fe2e:\n      local_158 \u003d (void *)0x0;\nLAB_001112f3:\n      free(local_158);\n      return (void *)0x0;\n    case 0x78:\n      bVar48 \u003d pbVar50[1];\n      if (bVar48 \u003d\u003d 0x73) {\nLAB_0010f0fd:\n        uVar15 \u003d 7;\n      }\n      else if ((char)bVar48 \u003c \u0027t\u0027) {\n        if (bVar48 \u003d\u003d 0) goto switchD_0010f055_caseD_24;\n        uVar15 \u003d 0xb;\n        if (bVar48 !\u003d 0x65) goto LAB_0010f0df;\n      }\n      else {\n        uVar15 \u003d 8;\n        if (bVar48 !\u003d 0x75) {\nLAB_0010f0df:\n          uVar15 \u003d dcgettext(0,\"unrecognized cross reference type\",5);\n          warn_stab(pbVar3,uVar15);\n          goto LAB_0010f0fd;\n        }\n      }\n      pbVar27 \u003d *param_4 + 1;\n      *param_4 \u003d pbVar27;\n      pcVar16 \u003d strchr((char *)pbVar27,0x3c);\n      pcVar40 \u003d strchr((char *)pbVar27,0x3a);\n      if (pcVar40 \u003d\u003d (char *)0x0) {\nswitchD_0010f055_caseD_24:\n        bad_stab(pbVar3);\n        return (void *)0x0;\n      }\n      if (((pcVar16 !\u003d (char *)0x0) \u0026\u0026 (pcVar16 \u003c pcVar40)) \u0026\u0026 (pcVar40[1] \u003d\u003d \u0027:\u0027)) {\n        iVar10 \u003d 0;\n        for (; cVar6 \u003d *pcVar16, cVar6 !\u003d \u0027\\0\u0027; pcVar16 \u003d pcVar16 + 1) {\n          if (cVar6 \u003d\u003d \u0027\u003c\u0027) {\n            iVar10 \u003d iVar10 + 1;\n          }\n          else if (cVar6 \u003d\u003d \u0027\u003e\u0027) {\n            iVar10 \u003d iVar10 + -1;\n          }\n          else if ((iVar10 \u003d\u003d 0) \u0026\u0026 (pcVar40 \u003d pcVar16, cVar6 \u003d\u003d \u0027:\u0027)) goto LAB_0010f176;\n        }\n        goto switchD_0010f055_caseD_24;\n      }\nLAB_0010f176:\n      uVar49 \u003d (long)pcVar40 - (long)pbVar27;\n      if ((param_3 !\u003d (char *)0x0) \u0026\u0026\n         ((iVar10 \u003d strncmp(param_3,(char *)pbVar27,uVar49), iVar10 \u003d\u003d 0 \u0026\u0026\n          (param_3[uVar49] \u003d\u003d \u0027\\0\u0027)))) {\n        *(undefined *)(param_2 + 0x1a8) \u003d 1;\n      }\n      pvVar17 \u003d (void *)stab_find_tagged_type(param_1,param_2,pbVar27,uVar49 \u0026 0xffffffff,uVar15);\n      *param_4 \u003d (byte *)(pcVar40 + 1);\n    }\n  }\nLAB_001115e2:\n  if (pvVar17 \u003d\u003d (void *)0x0) {\n    return (void *)0x0;\n  }\nLAB_001115eb:\n  if ((uint)local_a8 !\u003d -1) {\n    ppvVar18 \u003d (void **)stab_find_slot(param_2,\u0026local_a8);\n    if (ppvVar18 \u003d\u003d (void **)0x0) {\n      return (void *)0x0;\n    }\n    *ppvVar18 \u003d pvVar17;\n  }\n  if (local_12c !\u003d 0xffffffff) {\n    uVar12 \u003d *(uint *)((long)pvVar17 + 4);\n    if ((uVar12 !\u003d 0) \u0026\u0026 (local_12c !\u003d uVar12)) {\n      pcVar40 \u003d (char *)dcgettext(0,\"Warning: changing type size from %d to %d\\n\",5);\n      fprintf(_stderr,pcVar40,(ulong)uVar12,(ulong)local_12c);\n    }\n    *(uint *)((long)pvVar17 + 4) \u003d local_12c;\n    return pvVar17;\n  }\n  return pvVar17;\nLAB_00110788:\n  bad_stab(pbVar3);\nLAB_001111e9:\n  free(local_150);\n  free(local_128);\n  free(pbVar27);\n  goto LAB_001112f3;\nLAB_00111678:\n  *(undefined8 *)(local_128 + (ulong)uVar12 * 8) \u003d 0;\n  if (*pbVar50 !\u003d 0) {\n    *param_4 \u003d pbVar50 + 1;\n  }\n  if (local_e0 \u003c\u003d local_fc + 1) {\n    local_e0 \u003d local_e0 + 10;\n    pvVar24 \u003d (void *)xrealloc(pvVar24,(ulong)local_e0 \u003c\u003c 3);\n  }\n  ppcVar23 \u003d (char **)xmalloc(0x10);\n  *ppcVar23 \u003d local_150;\n  ppcVar23[1] \u003d local_128;\n  *(char ***)((long)pvVar24 + (ulong)local_fc * 8) \u003d ppcVar23;\n  local_fc \u003d local_fc + 1;\n  goto LAB_00110345;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_stab",
        "parse_stab_type"
      ],
      "called": [
        "parse_stab_type_number",
        "strchr",
        "strlen",
        "debug_get_type_name.constprop.0",
        "debug_find_named_type",
        "concat",
        "debug_make_function_type.isra.0",
        "debug_make_void_type.isra.0",
        "strncmp",
        "strcmp",
        "stab_find_type",
        "stab_demangle_qualified",
        "debug_make_int_type.isra.0",
        "stab_demangle_function_name.constprop.0",
        "xmalloc",
        "debug_make_type.constprop.0",
        "debug_make_float_type.isra.0",
        "debug_make_enum_type.isra.0",
        "savestring",
        "debug_make_array_type.isra.0",
        "strspn",
        "cplus_demangle_mangled_name",
        "parse_stab_type",
        "malloc",
        "debug_make_offset_type.isra.0",
        "strstr",
        "bad_stab",
        "debug_make_const_type.isra.0",
        "free",
        "parse_number",
        "debug_get_real_type.isra.0",
        "debug_make_method_type.isra.0",
        "cplus_demangle_init_info",
        "stab_bad_demangle",
        "stab_demangle_remember_type",
        "stab_find_slot",
        "dcgettext",
        "xrealloc",
        "stab_find_tagged_type",
        "stab_demangle_args",
        "debug_make_struct_type.isra.0",
        "strtol",
        "sprintf",
        "debug_make_volatile_type.isra.0",
        "debug_make_reference_type.isra.0",
        "debug_make_pointer_type.isra.0",
        "startswith.lto_priv.0.lto_priv.0",
        "stab_demangle_v3_arglist",
        "strcpy",
        "fprintf",
        "strcat",
        "stab_demangle_template",
        "warn_stab",
        "stab_demangle_count"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "parse_stab": {
      "entrypoint": "0x0011173a",
      "current_name": "parse_stab",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x0011244f) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nundefined parse_stab(undefined8 param_1,long *param_2,int param_3,int param_4,ulong param_5,\n                    char *param_6)\n\n{\n  char cVar1;\n  byte bVar2;\n  void *__ptr;\n  char cVar3;\n  undefined uVar4;\n  int iVar5;\n  undefined8 *puVar6;\n  long *plVar7;\n  char *pcVar8;\n  undefined8 uVar9;\n  long lVar10;\n  long lVar11;\n  long lVar12;\n  long **pplVar13;\n  ulong uVar14;\n  ulong uVar15;\n  char *pcVar16;\n  uint uVar17;\n  long **pplVar18;\n  double dVar19;\n  char *local_48;\n  long **local_40 [2];\n  \n  if (param_2[4] !\u003d 0) {\n    if (((param_3 \u003d\u003d 100) \u0026\u0026 (*param_6 !\u003d \u0027\\0\u0027)) \u0026\u0026 (param_2[5] \u003d\u003d param_5)) goto LAB_00111a06;\n    cVar3 \u003d debug_set_filename(param_1);\n    if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n      return 0;\n    }\n    *(undefined *)((long)param_2 + 0x44) \u003d 0;\n    *(undefined4 *)(param_2 + 8) \u003d 0;\n    param_2[9] \u003d param_2[4];\n    if (*(char *)(param_2 + 1) \u003d\u003d \u0027\\0\u0027) {\n      param_2[6] \u003d param_2[5];\n    }\n    *(undefined4 *)(param_2 + 0x10) \u003d 1;\n    puVar6 \u003d (undefined8 *)xmalloc(8);\n    param_2[0x11] \u003d (long)puVar6;\n    *puVar6 \u003d 0;\n    param_2[4] \u003d 0;\n  }\n  strlen(param_6);\n  if (param_3 \u003d\u003d 0x84) {\nLAB_00111ab7:\n    uVar4 \u003d debug_start_source(param_1,param_6);\n    return uVar4;\n  }\n  if (param_3 \u003c 0x85) {\n    if (param_3 \u003d\u003d 0x3c) {\n      iVar5 \u003d strcmp(param_6,\"gcc2_compiled.\");\n      if (iVar5 \u003d\u003d 0) {\n        *(undefined4 *)(param_2 + 8) \u003d 2;\n        return 1;\n      }\n      iVar5 \u003d strcmp(param_6,\"gcc_compiled.\");\n      if (iVar5 \u003d\u003d 0) {\n        *(undefined4 *)(param_2 + 8) \u003d 1;\n        return 1;\n      }\n      *(undefined *)((long)param_2 + 0x44) \u003d 1;\n      return 1;\n    }\n    if (param_3 \u003c 0x3d) {\n      if (param_3 \u003d\u003d 0x24) {\n        if (*param_6 \u003d\u003d \u0027\\0\u0027) {\n          if (*(char *)(param_2 + 0xc) \u003d\u003d \u0027\\0\u0027) {\n            return 1;\n          }\n          if (*(char *)(param_2 + 1) !\u003d \u0027\\0\u0027) {\n            param_5 \u003d param_5 + param_2[7];\n          }\n          cVar3 \u003d stab_emit_pending_vars(param_1,param_2);\n          if (cVar3 !\u003d \u0027\\0\u0027) {\n            cVar3 \u003d debug_end_function(param_1,param_5);\n            if (cVar3 !\u003d \u0027\\0\u0027) {\n              *(undefined *)(param_2 + 0xc) \u003d 0;\n              param_2[0xd] \u003d -1;\n              return 1;\n            }\n            return 0;\n          }\n          return 0;\n        }\n        if ((*(char *)(param_2 + 0xc) !\u003d \u0027\\0\u0027) \u0026\u0026\n           ((param_5 \u003c (ulong)param_2[0xd] || (param_2[0xd] \u003d\u003d 0xffffffffffffffff)))) {\n          param_2[0xd] \u003d param_5;\n        }\n      }\n      else if (param_3 \u003c 0x25) {\n        if (param_3 \u003d\u003d 0xc) {\n          return 1;\n        }\n        if (param_3 - 0x1eU \u003c 2) {\n          return 1;\n        }\n      }\n      else {\n        if (param_3 \u003d\u003d 0x2a) {\n          return 1;\n        }\n        if (param_3 \u003d\u003d 0x38) {\n          return 1;\n        }\n      }\n    }\n    else {\n      if (param_3 \u003d\u003d 100) {\nLAB_00111a06:\n        if (*(char *)(param_2 + 0xc) !\u003d \u0027\\0\u0027) {\n          uVar14 \u003d param_5;\n          if (((*param_6 !\u003d \u0027\\0\u0027) \u0026\u0026 (uVar15 \u003d param_2[0xd], uVar15 !\u003d 0xffffffffffffffff)) \u0026\u0026\n             (uVar14 \u003d uVar15, param_5 \u003c uVar15)) {\n            uVar14 \u003d param_5;\n          }\n          cVar3 \u003d stab_emit_pending_vars(param_1,param_2);\n          if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n            return 0;\n          }\n          cVar3 \u003d debug_end_function(param_1,uVar14);\n          if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n            return 0;\n          }\n          *(undefined *)(param_2 + 0xc) \u003d 0;\n          param_2[0xd] \u003d -1;\n        }\n        if (*param_6 \u003d\u003d \u0027\\0\u0027) {\n          return 1;\n        }\n        __ptr \u003d (void *)param_2[4];\n        if (__ptr \u003d\u003d (void *)0x0) {\n          lVar12 \u003d xstrdup(param_6);\n          param_2[4] \u003d lVar12;\n        }\n        else {\n          if (*param_6 \u003d\u003d \u0027/\u0027) {\n            lVar12 \u003d xstrdup(param_6);\n          }\n          else {\n            lVar12 \u003d concat(__ptr,param_6,0);\n          }\n          param_2[4] \u003d lVar12;\n          free(__ptr);\n        }\n        param_2[5] \u003d param_5;\n        return 1;\n      }\n      if (param_3 \u003c 0x65) {\n        if (param_3 \u003d\u003d 0x44) {\n          lVar12 \u003d 0;\n          if (*(char *)(param_2 + 0xc) !\u003d \u0027\\0\u0027) {\n            lVar12 \u003d param_2[7];\n          }\n          uVar4 \u003d debug_record_line(param_1,(long)param_4,lVar12 + param_5);\n          return uVar4;\n        }\n        if (param_3 \u003d\u003d 0x62) {\n          return 1;\n        }\n      }\n      else if (param_3 \u003d\u003d 0x82) {\n        plVar7 \u003d (long *)xmalloc();\n        iVar5 \u003d *(int *)(param_2 + 0x10);\n        lVar10 \u003d param_2[10];\n        lVar11 \u003d param_2[0xb];\n        plVar7[5] \u003d 0;\n        lVar12 \u003d param_2[0x11];\n        *(int *)(plVar7 + 4) \u003d iVar5;\n        uVar17 \u003d iVar5 + 1;\n        *(uint *)(param_2 + 0x10) \u003d uVar17;\n        *plVar7 \u003d lVar11;\n        plVar7[1] \u003d lVar10;\n        plVar7[2] \u003d (long)param_6;\n        plVar7[3] \u003d param_5;\n        param_2[10] \u003d (long)plVar7;\n        param_2[0xb] \u003d (long)plVar7;\n        lVar12 \u003d xrealloc(lVar12,(ulong)uVar17 \u003c\u003c 3);\n        uVar17 \u003d *(uint *)(plVar7 + 4);\n        param_2[0x11] \u003d lVar12;\n        *(undefined8 *)(lVar12 + (ulong)uVar17 * 8) \u003d 0;\n        goto LAB_00111ab7;\n      }\n    }\nLAB_00111c29:\n    pcVar8 \u003d strchr(param_6,0x3a);\n    if ((pcVar8 !\u003d (char *)0x0) \u0026\u0026 ((pcVar8[1] \u0026 0xdfU) \u003d\u003d 0x46)) {\n      if (*(char *)(param_2 + 0xc) !\u003d \u0027\\0\u0027) {\n        uVar14 \u003d param_2[0xd];\n        uVar15 \u003d param_5;\n        if ((uVar14 !\u003d 0xffffffffffffffff) \u0026\u0026 (uVar15 \u003d uVar14, param_5 \u003c uVar14)) {\n          uVar15 \u003d param_5;\n        }\n        cVar3 \u003d stab_emit_pending_vars(param_1,param_2);\n        if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n          return 0;\n        }\n        cVar3 \u003d debug_end_function(param_1,uVar15);\n        if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n          return 0;\n        }\n        param_2[0xd] \u003d -1;\n      }\n      if (*(char *)(param_2 + 1) !\u003d \u0027\\0\u0027) {\n        param_2[7] \u003d param_5;\n      }\n      *(undefined *)(param_2 + 0xc) \u003d 1;\n    }\n    local_48 \u003d strchr(param_6,0x3a);\n    if (local_48 \u003d\u003d (char *)0x0) {\n      return 1;\n    }\nLAB_00111cbc:\n    if (local_48[1] \u003d\u003d \u0027:\u0027) goto code_r0x00111cc7;\n    if (*param_6 \u003d\u003d \u0027$\u0027) {\n      cVar3 \u003d param_6[1];\n      pcVar16 \u003d \"eh_throw\";\n      if (cVar3 !\u003d \u0027e\u0027) {\n        if (cVar3 \u003c \u0027f\u0027) {\n          if ((cVar3 !\u003d \u0027X\u0027) \u0026\u0026 (cVar3 !\u003d \u0027_\u0027)) {\nLAB_00111d1a:\n            uVar9 \u003d dcgettext(0,\"unknown C++ encoded name\",5);\n            warn_stab(param_6,uVar9);\n          }\n        }\n        else {\n          pcVar16 \u003d \"this\";\n          if (cVar3 \u003d\u003d \u0027t\u0027) goto LAB_00111d62;\n          if (cVar3 !\u003d \u0027v\u0027) goto LAB_00111d1a;\n        }\n        goto LAB_00111d38;\n      }\n    }\n    else {\nLAB_00111d38:\n      pcVar16 \u003d (char *)0x0;\n      if ((param_6 !\u003d local_48) \u0026\u0026 ((*param_6 !\u003d \u0027 \u0027 || (local_48 !\u003d param_6 + 1)))) {\n        pcVar16 \u003d (char *)savestring(param_6,(int)local_48 - (int)param_6);\n      }\n    }\nLAB_00111d62:\n    bVar2 \u003d local_48[1];\n    pcVar8 \u003d local_48 + 1;\n    if (((byte)(*(ushort *)(\u0026_sch_istable + (ulong)bVar2 * 2) \u003e\u003e 2) \u0026 1 |\n        (bVar2 \u003d\u003d 0x2d || bVar2 \u003d\u003d 0x28)) !\u003d 0) {\nswitchD_00111de5_caseD_58:\n      local_48 \u003d pcVar8;\n      lVar12 \u003d parse_stab_type(param_1,param_2,0,\u0026local_48,0);\n      if (lVar12 \u003d\u003d 0) {\n        return 0;\n      }\n      uVar9 \u003d 4;\n      goto LAB_001123e8;\n    }\n    if (bVar2 \u003d\u003d 0) goto switchD_00111de5_caseD_44;\n    pcVar8 \u003d local_48 + 2;\n    cVar3 \u003d local_48[1];\n    switch(cVar3) {\n    case \u0027C\u0027:\n      local_48 \u003d pcVar8;\n      lVar12 \u003d parse_stab_type(param_1,param_2,0,\u0026local_48,0);\n      pcVar8 \u003d \"debug_record_label: not implemented\";\n      if (lVar12 \u003d\u003d 0) {\n        return 0;\n      }\n      goto LAB_00111b96;\n    default:\n      goto switchD_00111de5_caseD_44;\n    case \u0027F\u0027:\n    case \u0027f\u0027:\n      local_48 \u003d pcVar8;\n      lVar12 \u003d parse_stab_type(param_1,param_2,0,\u0026local_48,0);\n      if (lVar12 \u003d\u003d 0) {\n        return 0;\n      }\n      cVar3 \u003d debug_record_function(param_1,pcVar16,lVar12,cVar3 \u003d\u003d \u0027F\u0027,param_5);\n      if (cVar3 !\u003d \u0027\\0\u0027) {\n        do {\n          if (*local_48 !\u003d \u0027;\u0027) {\n            return 1;\n          }\n          local_48 \u003d local_48 + 1;\n          lVar12 \u003d parse_stab_type(param_1,param_2,0,\u0026local_48,0);\n        } while (lVar12 !\u003d 0);\n        return 0;\n      }\n      return 0;\n    case \u0027G\u0027:\n      local_48 \u003d pcVar8;\n      lVar12 \u003d parse_stab_type(param_1,param_2,0,\u0026local_48,0);\n      if (lVar12 \u003d\u003d 0) {\n        return 0;\n      }\n      if (pcVar16 \u003d\u003d (char *)0x0) goto LAB_0011208f;\n      lVar10 \u003d param_2[3];\n      plVar7 \u003d (long *)param_2[2];\n      cVar3 \u003d *(char *)(*(long *)(*param_2 + 8) + 0x1c);\n      goto LAB_00112045;\n    case \u0027P\u0027:\n      if (param_3 \u003d\u003d 0x24) {\n        local_48 \u003d pcVar8;\n        do {\n          if (*local_48 !\u003d \u0027;\u0027) {\n            return 1;\n          }\n          local_48 \u003d local_48 + 1;\n          lVar12 \u003d parse_stab_type(param_1,param_2,0,\u0026local_48,0);\n        } while (lVar12 !\u003d 0);\n        return 0;\n      }\n    case \u0027R\u0027:\n      local_48 \u003d pcVar8;\n      lVar12 \u003d parse_stab_type(param_1,param_2,0,\u0026local_48,0);\n      if (lVar12 \u003d\u003d 0) {\n        return 0;\n      }\n      uVar9 \u003d 2;\n      break;\n    case \u0027S\u0027:\n      local_48 \u003d pcVar8;\n      lVar12 \u003d parse_stab_type(param_1,param_2,0,\u0026local_48,0);\n      if (lVar12 \u003d\u003d 0) {\n        return 0;\n      }\n      uVar9 \u003d 2;\n      goto LAB_001121c4;\n    case \u0027T\u0027:\n      cVar3 \u003d local_48[2];\n      if (cVar3 \u003d\u003d \u0027t\u0027) {\n        pcVar8 \u003d local_48 + 3;\n      }\n      local_48 \u003d pcVar8;\n      lVar12 \u003d parse_stab_type(param_1,param_2,pcVar16,\u0026local_48,local_40);\n      if (lVar12 \u003d\u003d 0) {\n        return 0;\n      }\n      if (pcVar16 \u003d\u003d (char *)0x0) {\n        return 1;\n      }\n      cVar1 \u003d *(char *)(param_2 + 0x35);\n      plVar7 \u003d (long *)debug_tag_type(param_1,pcVar16,lVar12);\n      if (plVar7 \u003d\u003d (long *)0x0) {\n        return 0;\n      }\n      if (local_40[0] !\u003d (long **)0x0) {\n        *local_40[0] \u003d plVar7;\n      }\n      if (cVar1 !\u003d \u0027\\0\u0027) goto LAB_001122f0;\n      pplVar13 \u003d (long **)(param_2 + 0x34);\n      pplVar18 \u003d (long **)param_2[0x34];\n      goto LAB_001122b2;\n    case \u0027V\u0027:\n      local_48 \u003d pcVar8;\n      lVar12 \u003d parse_stab_type(param_1,param_2,0,\u0026local_48,0);\n      if (lVar12 \u003d\u003d 0) {\n        return 0;\n      }\n      uVar9 \u003d 3;\n      goto LAB_001123e8;\n    case \u0027X\u0027:\n    case \u0027l\u0027:\n    case \u0027s\u0027:\n      goto switchD_00111de5_caseD_58;\n    case \u0027Y\u0027:\n      pcVar8 \u003d local_48 + 3;\n      if (((local_48[2] !\u003d \u0027\\0\u0027) \u0026\u0026 (pcVar8 \u003d local_48 + 4, local_48[3] \u003d\u003d \u0027n\u0027)) \u0026\u0026\n         (pcVar8 \u003d local_48 + 5, pcVar16 \u003d local_48 + 4, local_48 \u003d pcVar8, *pcVar16 \u003d\u003d \u00270\u0027)) {\n        for (; pcVar8 \u003d local_48, *local_48 !\u003d \u0027\\0\u0027; local_48 \u003d local_48 + 1) {\n          if (*local_48 \u003d\u003d \u0027;\u0027) {\n            return 1;\n          }\n        }\n      }\n      goto switchD_00111de5_caseD_44;\n    case \u0027a\u0027:\n      local_48 \u003d pcVar8;\n      lVar12 \u003d parse_stab_type(param_1,param_2,0,\u0026local_48,0);\n      if (lVar12 \u003d\u003d 0) {\n        return 0;\n      }\n      uVar9 \u003d 4;\n      break;\n    case \u0027c\u0027:\n      if (local_48[2] \u003d\u003d \u0027\u003d\u0027) {\n        pcVar8 \u003d local_48 + 4;\n        cVar3 \u003d local_48[3];\n        local_48 \u003d pcVar8;\n        if (cVar3 \u003d\u003d \u0027i\u0027) {\n          lVar12 \u003d strtol(pcVar8,(char **)0x0,10);\n          if (pcVar16 \u003d\u003d (char *)0x0) {\n            return 0;\n          }\n          lVar10 \u003d debug_add_to_current_namespace_constprop_0(param_1,pcVar16,4);\n          if (lVar10 !\u003d 0) {\n            *(long *)(lVar10 + 0x20) \u003d (long)(int)lVar12;\n            return 1;\n          }\n          return 0;\n        }\n        if (cVar3 \u003d\u003d \u0027r\u0027) {\n          dVar19 \u003d strtod(pcVar8,(char **)0x0);\n          if (pcVar16 \u003d\u003d (char *)0x0) {\n            return 0;\n          }\n          lVar12 \u003d debug_add_to_current_namespace_constprop_0(param_1,pcVar16,5);\n          if (lVar12 !\u003d 0) {\n            *(double *)(lVar12 + 0x20) \u003d dVar19;\n            return 1;\n          }\n          return 0;\n        }\n        if (cVar3 \u003d\u003d \u0027e\u0027) {\n          lVar12 \u003d parse_stab_type(param_1,param_2,0,\u0026local_48,0);\n          if (lVar12 \u003d\u003d 0) {\n            return 0;\n          }\n          pcVar8 \u003d local_48;\n          if (*local_48 \u003d\u003d \u0027,\u0027) {\n            lVar10 \u003d strtol(local_48,(char **)0x0,10);\n            if (pcVar16 \u003d\u003d (char *)0x0) {\n              return 0;\n            }\n            lVar11 \u003d debug_add_to_current_namespace_constprop_0(param_1,pcVar16,6);\n            if (lVar11 !\u003d 0) {\n              plVar7 \u003d (long *)xmalloc(0x10);\n              *plVar7 \u003d lVar12;\n              plVar7[1] \u003d (long)(int)lVar10;\n              *(long **)(lVar11 + 0x20) \u003d plVar7;\n              return 1;\n            }\n            return 0;\n          }\n        }\n      }\n      goto switchD_00111de5_caseD_44;\n    case \u0027p\u0027:\n      if (local_48[2] \u003d\u003d \u0027F\u0027) {\n        local_48 \u003d local_48 + 3;\n        lVar12 \u003d parse_stab_type(param_1,param_2,0,\u0026local_48,0);\n        if (lVar12 \u003d\u003d 0) {\n          return 0;\n        }\n        uVar9 \u003d debug_make_function_type_isra_0(lVar12,0,0);\n        lVar12 \u003d debug_make_pointer_type_isra_0(uVar9);\n      }\n      else {\n        local_48 \u003d pcVar8;\n        lVar12 \u003d parse_stab_type(param_1,param_2,0,\u0026local_48,0);\n      }\n      if (lVar12 \u003d\u003d 0) {\n        return 0;\n      }\n      uVar9 \u003d 1;\n      break;\n    case \u0027r\u0027:\n      local_48 \u003d pcVar8;\n      lVar12 \u003d parse_stab_type(param_1,param_2,0,\u0026local_48,0);\n      if (lVar12 \u003d\u003d 0) {\n        return 0;\n      }\n      uVar9 \u003d 5;\nLAB_001123e8:\n      cVar3 \u003d stab_record_variable(param_1,param_2,pcVar16,lVar12,uVar9,param_5);\n      goto joined_r0x001123f8;\n    case \u0027t\u0027:\n      local_48 \u003d pcVar8;\n      lVar12 \u003d parse_stab_type(param_1,param_2,pcVar16,\u0026local_48,local_40);\n      if (lVar12 \u003d\u003d 0) {\n        return 0;\n      }\n      if (pcVar16 \u003d\u003d (char *)0x0) {\n        return 1;\n      }\n      plVar7 \u003d (long *)debug_name_type(param_1,pcVar16,lVar12);\n      if (plVar7 \u003d\u003d (long *)0x0) {\n        return 0;\n      }\n      if (local_40[0] \u003d\u003d (long **)0x0) {\n        return 1;\n      }\n      *local_40[0] \u003d plVar7;\n      return 1;\n    case \u0027v\u0027:\n      local_48 \u003d pcVar8;\n      lVar12 \u003d parse_stab_type(param_1,param_2,0,\u0026local_48,0);\n      if (lVar12 \u003d\u003d 0) {\n        return 0;\n      }\n      uVar9 \u003d 3;\n    }\n    cVar3 \u003d debug_record_parameter(param_1,pcVar16,lVar12,uVar9,param_5);\n    goto joined_r0x001123f8;\n  }\n  if (param_3 \u003d\u003d 0xe0) {\n    if ((*(char *)((long)param_2 + 0x44) !\u003d \u0027\\0\u0027) \u0026\u0026 (param_4 \u003d\u003d 1)) {\n      return 1;\n    }\n    cVar3 \u003d stab_emit_pending_vars(param_1,param_2);\n    if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n      return 0;\n    }\n    cVar3 \u003d debug_end_block(param_1,param_2[7] + param_2[6] + param_5);\n    if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n      return 0;\n    }\n    param_2 \u003d param_2 + 0xe;\n    *(int *)param_2 \u003d *(int *)param_2 + -1;\n    pcVar8 \u003d \"Too many N_RBRACs\\n\";\n    if (-1 \u003c *(int *)param_2) {\n      return 1;\n    }\n  }\n  else {\n    if (0xe0 \u003c param_3) {\n      if (param_3 \u003d\u003d 0xe2) {\n        pcVar8 \u003d \"debug_start_common_block: not implemented\";\n      }\n      else {\n        pcVar8 \u003d \"debug_end_common_block: not implemented\";\n        if (param_3 !\u003d 0xe4) goto LAB_00111c29;\n      }\nLAB_00111b96:\n      uVar9 \u003d dcgettext(0,pcVar8,5);\n      fprintf(_stderr,\"%s\\n\",uVar9);\n      return 0;\n    }\n    if (param_3 !\u003d 0xc0) {\n      if (param_3 \u003d\u003d 0xc2) {\n        iVar5 \u003d *(int *)(param_2 + 0x10);\n        *(uint *)(param_2 + 0x10) \u003d iVar5 + 1U;\n        lVar12 \u003d xrealloc(param_2[0x11],(ulong)(iVar5 + 1U) \u003c\u003c 3);\n        puVar6 \u003d (undefined8 *)param_2[0xb];\n        param_2[0x11] \u003d lVar12;\n        while( true ) {\n          if (puVar6 \u003d\u003d (undefined8 *)0x0) {\n            uVar9 \u003d dcgettext(0,\"Undefined N_EXCL\",5);\n            warn_stab(param_6,uVar9);\n            *(undefined8 *)(param_2[0x11] + (ulong)(*(int *)(param_2 + 0x10) - 1) * 8) \u003d 0;\n            return 1;\n          }\n          if ((param_5 \u003d\u003d puVar6[3]) \u0026\u0026 (iVar5 \u003d strcmp((char *)puVar6[2],param_6), iVar5 \u003d\u003d 0))\n          break;\n          puVar6 \u003d (undefined8 *)*puVar6;\n        }\n        *(undefined8 *)(lVar12 + (ulong)(*(int *)(param_2 + 0x10) - 1) * 8) \u003d puVar6[5];\n        return 1;\n      }\n      if (param_3 \u003d\u003d 0xa2) {\n        lVar12 \u003d param_2[10];\n        if (lVar12 !\u003d 0) {\n          lVar10 \u003d *(long *)(lVar12 + 8);\n          uVar17 \u003d *(uint *)(lVar12 + 0x20);\n          param_2[10] \u003d lVar10;\n          if ((uVar17 \u003c *(uint *)(param_2 + 0x10)) \u0026\u0026\n             (*(undefined8 *)(lVar12 + 0x28) \u003d *(undefined8 *)(param_2[0x11] + (ulong)uVar17 * 8),\n             lVar10 !\u003d 0)) {\n            param_6 \u003d *(char **)(lVar10 + 0x10);\n            goto LAB_00111ab7;\n          }\n        }\n        param_6 \u003d (char *)param_2[9];\n        goto LAB_00111ab7;\n      }\n      goto LAB_00111c29;\n    }\n    if ((*(char *)((long)param_2 + 0x44) !\u003d \u0027\\0\u0027) \u0026\u0026 (param_4 \u003d\u003d 1)) {\n      return 1;\n    }\n    if (*(char *)(param_2 + 0xc) !\u003d \u0027\\0\u0027) {\n      cVar3 \u003d debug_start_block(param_1,param_2[7] + param_2[6] + param_5);\n      if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      cVar3 \u003d stab_emit_pending_vars(param_1,param_2);\n      if (cVar3 !\u003d \u0027\\0\u0027) {\n        *(int *)(param_2 + 0xe) \u003d *(int *)(param_2 + 0xe) + 1;\n        return 1;\n      }\n      return 0;\n    }\n    pcVar8 \u003d \"N_LBRAC not within function\\n\";\n  }\n  pcVar8 \u003d (char *)dcgettext(0,pcVar8,5);\n  fprintf(_stderr,pcVar8);\n  return 0;\ncode_r0x00111cc7:\n  local_48 \u003d local_48 + 2;\n  local_48 \u003d strchr(local_48,0x3a);\n  if (local_48 \u003d\u003d (char *)0x0) {\n    pcVar8 \u003d (char *)0x0;\nswitchD_00111de5_caseD_44:\n    local_48 \u003d pcVar8;\n    bad_stab(param_6);\n    return 0;\n  }\n  goto LAB_00111cbc;\nLAB_001122b2:\n  if (pplVar18 \u003d\u003d (long **)0x0) {\nLAB_001122f0:\n    if (cVar3 !\u003d \u0027t\u0027) {\n      return 1;\n    }\n    plVar7 \u003d (long *)debug_name_type(param_1,pcVar16,plVar7);\n    if (plVar7 !\u003d (long *)0x0) {\n      if (local_40[0] \u003d\u003d (long **)0x0) {\n        return 1;\n      }\n      *local_40[0] \u003d plVar7;\n      return 1;\n    }\n    return 0;\n  }\n  if ((*(char *)pplVar18[1] \u003d\u003d *pcVar16) \u0026\u0026\n     (iVar5 \u003d strcmp((char *)pplVar18[1],pcVar16), iVar5 \u003d\u003d 0)) {\n    pplVar18[3] \u003d plVar7;\n    *pplVar13 \u003d *pplVar18;\n    goto LAB_001122f0;\n  }\n  pplVar13 \u003d pplVar18;\n  pplVar18 \u003d (long **)*pplVar18;\n  goto LAB_001122b2;\nLAB_00112045:\n  if (lVar10 \u003c 1) {\nLAB_0011208f:\n    uVar9 \u003d 1;\nLAB_001121c4:\n    cVar3 \u003d debug_record_variable(param_1,pcVar16,lVar12,uVar9,param_5);\njoined_r0x001123f8:\n    if (cVar3 !\u003d \u0027\\0\u0027) {\n      return 1;\n    }\n    return 0;\n  }\n  pcVar8 \u003d *(char **)(*plVar7 + 8);\n  if ((cVar3 !\u003d \u0027\\0\u0027) \u0026\u0026 (cVar3 \u003d\u003d *pcVar8)) {\n    pcVar8 \u003d pcVar8 + 1;\n  }\n  if ((*pcVar8 \u003d\u003d *pcVar16) \u0026\u0026 (iVar5 \u003d strcmp(pcVar8,pcVar16), iVar5 \u003d\u003d 0)) {\n    param_5 \u003d *(long *)(*plVar7 + 0x10) + *(long *)(*(long *)(*plVar7 + 0x20) + 0x30);\n    goto LAB_0011208f;\n  }\n  lVar10 \u003d lVar10 + -1;\n  plVar7 \u003d plVar7 + 1;\n  goto LAB_00112045;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [
        "debug_start_source",
        "free",
        "strchr",
        "strlen",
        "debug_record_variable",
        "concat",
        "debug_make_function_type.isra.0",
        "debug_record_parameter",
        "dcgettext",
        "debug_tag_type",
        "xrealloc",
        "debug_record_function",
        "strcmp",
        "strtol",
        "debug_name_type",
        "xmalloc",
        "debug_make_pointer_type.isra.0",
        "debug_end_function",
        "debug_set_filename",
        "savestring",
        "parse_stab_type",
        "strtod",
        "fprintf",
        "debug_end_block",
        "debug_add_to_current_namespace.constprop.0",
        "debug_start_block",
        "stab_record_variable",
        "warn_stab",
        "stab_emit_pending_vars",
        "debug_record_line",
        "bad_stab",
        "xstrdup"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_write_linenos.constprop.0": {
      "entrypoint": "0x00112502",
      "current_name": "debug_write_linenos.constprop.0",
      "code": "\nundefined debug_write_linenos_constprop_0(long param_1,undefined8 param_2,ulong param_3)\n\n{\n  uint uVar1;\n  undefined8 *puVar2;\n  undefined8 uVar3;\n  char cVar4;\n  \n  do {\n    puVar2 \u003d *(undefined8 **)(param_1 + 0x40);\n    if (puVar2 \u003d\u003d (undefined8 *)0x0) {\n      return 1;\n    }\n    while ((uVar1 \u003d *(uint *)(param_1 + 0x48), uVar1 \u003c 10 \u0026\u0026 (puVar2[(ulong)uVar1 + 2] !\u003d -1))) {\n      if (param_3 \u003c\u003d (ulong)puVar2[(ulong)uVar1 + 0xc]) {\n        return 1;\n      }\n      cVar4 \u003d stab_lineno_lto_priv_0(param_2,*(undefined8 *)(puVar2[1] + 8));\n      if (cVar4 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      *(int *)(param_1 + 0x48) \u003d *(int *)(param_1 + 0x48) + 1;\n    }\n    uVar3 \u003d *puVar2;\n    *(undefined4 *)(param_1 + 0x48) \u003d 0;\n    *(undefined8 *)(param_1 + 0x40) \u003d uVar3;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_block.constprop.0",
        "debug_write_name.constprop.0",
        "write_stabs_in_sections_debugging_info.constprop.0"
      ],
      "called": [
        "stab_lineno.lto_priv.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "list_matching_formats": {
      "entrypoint": "0x0011256b",
      "current_name": "list_matching_formats",
      "code": "\n\n\nvoid list_matching_formats(long *param_1)\n\n{\n  undefined8 uVar1;\n  char *__format;\n  long *plVar2;\n  \n  fflush(_stdout);\n  uVar1 \u003d program_name;\n  __format \u003d (char *)dcgettext(0,\"%s: Matching formats:\",5);\n  fprintf(_stderr,__format,uVar1);\n  for (plVar2 \u003d param_1; *plVar2 !\u003d 0; plVar2 \u003d plVar2 + 1) {\n    fprintf(_stderr,\" %s\");\n  }\n  free(param_1);\n  fputc(10,_stderr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_file"
      ],
      "called": [
        "fprintf",
        "fflush",
        "free",
        "fputc",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_get_archive_filename": {
      "entrypoint": "0x001125fa",
      "current_name": "bfd_get_archive_filename",
      "code": "\nchar * bfd_get_archive_filename(char **param_1)\n\n{\n  ulong uVar1;\n  char **ppcVar2;\n  size_t sVar3;\n  size_t sVar4;\n  char *__s;\n  \n  if (param_1 \u003d\u003d (char **)0x0) {\n                    \n    __assert_fail(\"abfd !\u003d NULL\",\"../../binutils/bucomm.c\",0x298,\"bfd_get_archive_filename\");\n  }\n  ppcVar2 \u003d (char **)param_1[0x1d];\n  __s \u003d *param_1;\n  if ((ppcVar2 !\u003d (char **)0x0) \u0026\u0026 ((*(byte *)((long)ppcVar2 + 0x49) \u0026 0x10) \u003d\u003d 0)) {\n    sVar3 \u003d strlen(*ppcVar2);\n    sVar4 \u003d strlen(__s);\n    uVar1 \u003d sVar3 + 3 + sVar4;\n    if (curr_1 \u003c uVar1) {\n      if (curr_1 !\u003d 0) {\n        free(buf_0);\n      }\n      curr_1 \u003d (uVar1 \u003e\u003e 1) + uVar1;\n      buf_0 \u003d (char *)xmalloc();\n    }\n    sprintf(buf_0,\"%s(%s)\",*(undefined8 *)param_1[0x1d],*param_1);\n    __s \u003d buf_0;\n  }\n  return __s;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107976",
        "copy_object",
        "bfd_nonfatal_message",
        "FUN_00104ea2",
        "FUN_001152b6",
        "FUN_00105828"
      ],
      "called": [
        "free",
        "strlen",
        "__assert_fail",
        "sprintf",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_nonfatal_message": {
      "entrypoint": "0x001126c0",
      "current_name": "bfd_nonfatal_message",
      "code": "\n\n\nvoid bfd_nonfatal_message\n               (undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n               undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n               long param_9,long param_10,long *param_11,char *param_12,undefined8 param_13,\n               undefined8 param_14)\n\n{\n  char in_AL;\n  int iVar1;\n  undefined8 uVar2;\n  undefined4 local_100;\n  undefined4 local_fc;\n  undefined *local_f8;\n  undefined *local_f0;\n  undefined local_e8 [32];\n  undefined8 local_c8;\n  undefined8 local_c0;\n  undefined4 local_b8;\n  undefined4 local_a8;\n  undefined4 local_98;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  \n  if (in_AL !\u003d \u0027\\0\u0027) {\n    local_b8 \u003d param_1;\n    local_a8 \u003d param_2;\n    local_98 \u003d param_3;\n    local_88 \u003d param_4;\n    local_78 \u003d param_5;\n    local_68 \u003d param_6;\n    local_58 \u003d param_7;\n    local_48 \u003d param_8;\n  }\n  local_c8 \u003d param_13;\n  local_c0 \u003d param_14;\n  iVar1 \u003d bfd_get_error();\n  if (iVar1 \u003d\u003d 0) {\n    uVar2 \u003d dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    uVar2 \u003d bfd_errmsg();\n  }\n  fflush(_stdout);\n  fputs(program_name,_stderr);\n  if (param_10 !\u003d 0) {\n    if (param_9 \u003d\u003d 0) {\n      param_9 \u003d bfd_get_archive_filename(param_10);\n    }\n    if ((param_11 !\u003d (long *)0x0) \u0026\u0026 (*param_11 !\u003d 0)) {\n      fprintf(_stderr,\": %s[%s]\",param_9);\n      goto LAB_001127c1;\n    }\n  }\n  fprintf(_stderr,\": %s\",param_9);\nLAB_001127c1:\n  if (param_12 !\u003d (char *)0x0) {\n    local_f8 \u003d \u0026stack0x00000008;\n    local_f0 \u003d local_e8;\n    local_100 \u003d 0x20;\n    local_fc \u003d 0x30;\n    fwrite(\u0026DAT_0011b4a0,1,2,_stderr);\n    vfprintf(_stderr,param_12,\u0026local_100);\n  }\n  fprintf(_stderr,\": %s\\n\",uVar2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_relocations_in_section",
        "FUN_00107880",
        "FUN_001086af",
        "copy_file.cold",
        "FUN_00108466",
        "main",
        "FUN_0010808f",
        "FUN_00104ea2",
        "FUN_0010554f",
        "copy_section",
        "copy_object.cold",
        "copy_file",
        "copy_object"
      ],
      "called": [
        "fwrite",
        "fprintf",
        "fflush",
        "dcgettext",
        "vfprintf",
        "fputs",
        "bfd_get_error",
        "bfd_errmsg",
        "bfd_get_archive_filename"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "try_dir.lto_priv.0": {
      "entrypoint": "0x0011283f",
      "current_name": "try_dir.lto_priv.0",
      "code": "\nchar * try_dir_lto_priv_0(char *param_1,char *param_2)\n\n{\n  int iVar1;\n  stat sStack_a8;\n  \n  if ((param_2 \u003d\u003d (char *)0x0) \u0026\u0026 (param_1 !\u003d (char *)0x0)) {\n    iVar1 \u003d access(param_1,7);\n    if (iVar1 \u003d\u003d 0) {\n      iVar1 \u003d stat(param_1,\u0026sStack_a8);\n      if ((iVar1 \u003d\u003d 0) \u0026\u0026 ((sStack_a8.st_mode \u0026 0xf000) \u003d\u003d 0x4000)) {\n        param_2 \u003d param_1;\n      }\n    }\n  }\n  return param_2;\n}\n\n",
      "renaming": {},
      "calling": [
        "display_info.isra.0"
      ],
      "called": [
        "access",
        "stat"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "start_stab.constprop.0": {
      "entrypoint": "0x00112894",
      "current_name": "start_stab.constprop.0",
      "code": "\nundefined8 *\nstart_stab_constprop_0(undefined8 param_1,undefined param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  undefined8 *puVar1;\n  undefined8 *puVar2;\n  long lVar3;\n  byte bVar4;\n  \n  bVar4 \u003d 0;\n  puVar1 \u003d (undefined8 *)xmalloc(0x1b0);\n  puVar2 \u003d puVar1;\n  for (lVar3 \u003d 0x6c; lVar3 !\u003d 0; lVar3 \u003d lVar3 + -1) {\n    *(undefined4 *)puVar2 \u003d 0;\n    puVar2 \u003d (undefined8 *)((long)puVar2 + (ulong)bVar4 * -8 + 4);\n  }\n  *puVar1 \u003d param_1;\n  *(undefined *)(puVar1 + 1) \u003d param_2;\n  puVar1[2] \u003d param_3;\n  puVar1[3] \u003d param_4;\n  *(undefined4 *)(puVar1 + 0x10) \u003d 1;\n  puVar2 \u003d (undefined8 *)xmalloc(8);\n  puVar1[0xd] \u003d 0xffffffffffffffff;\n  puVar1[0x11] \u003d puVar2;\n  *puVar2 \u003d 0;\n  return puVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_make_type.constprop.0": {
      "entrypoint": "0x00112904",
      "current_name": "debug_make_type.constprop.0",
      "code": "\nvoid debug_make_type_constprop_0(undefined4 param_1,undefined4 param_2)\n\n{\n  undefined4 *puVar1;\n  \n  puVar1 \u003d (undefined4 *)xmalloc(0x18);\n  *puVar1 \u003d param_1;\n  puVar1[1] \u003d param_2;\n  *(undefined (*) [16])(puVar1 + 2) \u003d ZEXT816(0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_make_float_type.isra.0",
        "debug_make_enum_type.isra.0",
        "finish_stab",
        "debug_make_method_type.isra.0",
        "debug_make_array_type.isra.0",
        "parse_stab_type",
        "debug_make_function_type.isra.0",
        "stab_demangle_type.lto_priv.0",
        "debug_make_indirect_type.isra.0",
        "debug_make_void_type.isra.0",
        "debug_tag_type",
        "stab_demangle_v3_arg",
        "stab_find_type",
        "debug_make_offset_type.isra.0",
        "debug_make_struct_type.isra.0",
        "debug_name_type",
        "debug_make_int_type.isra.0",
        "debug_make_volatile_type.isra.0",
        "debug_make_reference_type.isra.0",
        "debug_make_pointer_type.isra.0",
        "debug_make_const_type.isra.0"
      ],
      "called": [
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_add_to_namespace.constprop.0": {
      "entrypoint": "0x00112925",
      "current_name": "debug_add_to_namespace.constprop.0",
      "code": "\nundefined4 *\ndebug_add_to_namespace_constprop_0\n          (undefined (**param_1) [16],undefined8 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 *puVar1;\n  undefined (*pauVar2) [16];\n  long lVar3;\n  undefined4 *puVar4;\n  byte bVar5;\n  \n  bVar5 \u003d 0;\n  puVar1 \u003d (undefined4 *)xmalloc(0x28);\n  puVar4 \u003d puVar1;\n  for (lVar3 \u003d 10; lVar3 !\u003d 0; lVar3 \u003d lVar3 + -1) {\n    *puVar4 \u003d 0;\n    puVar4 \u003d puVar4 + (ulong)bVar5 * -2 + 1;\n  }\n  pauVar2 \u003d *param_1;\n  *(undefined8 *)(puVar1 + 2) \u003d param_2;\n  puVar1[5] \u003d param_3;\n  puVar1[6] \u003d param_4;\n  if (pauVar2 \u003d\u003d (undefined (*) [16])0x0) {\n    pauVar2 \u003d (undefined (*) [16])xmalloc(0x10);\n    *pauVar2 \u003d ZEXT816(0);\n    *param_1 \u003d pauVar2;\n    *(undefined (**) [16])(*pauVar2 + 8) \u003d pauVar2;\n  }\n  **(undefined8 **)(*pauVar2 + 8) \u003d puVar1;\n  *(undefined4 **)(*pauVar2 + 8) \u003d puVar1;\n  return puVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_tag_type",
        "debug_record_function",
        "debug_add_to_current_namespace.constprop.0",
        "debug_record_variable",
        "debug_name_type"
      ],
      "called": [
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_add_to_current_namespace.constprop.0": {
      "entrypoint": "0x00112996",
      "current_name": "debug_add_to_current_namespace.constprop.0",
      "code": "\n\n\nundefined8\ndebug_add_to_current_namespace_constprop_0(long param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  \n  if ((*(long *)(param_1 + 8) !\u003d 0) \u0026\u0026 (*(long *)(param_1 + 0x10) !\u003d 0)) {\n    lVar2 \u003d *(long *)(param_1 + 0x10) + 0x10;\n    if (*(long *)(param_1 + 0x20) !\u003d 0) {\n      lVar2 \u003d *(long *)(param_1 + 0x20) + 0x28;\n    }\n    uVar1 \u003d debug_add_to_namespace_constprop_0(lVar2,param_2,param_3,3);\n    return uVar1;\n  }\n  uVar1 \u003d dcgettext(0,\"debug_add_to_current_namespace: no current file\",5);\n  fprintf(_stderr,\"%s\\n\",uVar1);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_stab"
      ],
      "called": [
        "fprintf",
        "debug_add_to_namespace.constprop.0",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_get_type_name.constprop.0": {
      "entrypoint": "0x001129f4",
      "current_name": "debug_get_type_name.constprop.0",
      "code": "\nundefined8 debug_get_type_name_constprop_0(int *param_1)\n\n{\n  undefined8 *puVar1;\n  int *piVar2;\n  \n  do {\n    if (*param_1 !\u003d 1) {\n      if (1 \u003c *param_1 - 0x16U) {\n        return 0;\n      }\n      return *(undefined8 *)(**(long **)(param_1 + 4) + 8);\n    }\n    puVar1 \u003d (undefined8 *)(param_1 + 4);\n    piVar2 \u003d **(int ***)(undefined8 *)*puVar1;\n  } while ((param_1 !\u003d piVar2) \u0026\u0026 (param_1 \u003d piVar2, piVar2 !\u003d (int *)0x0));\n  return ((undefined8 *)*puVar1)[1];\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_get_real_type.isra.0",
        "stab_demangle_v3_arg",
        "debug_get_type_name.constprop.0",
        "stab_demangle_qualified",
        "parse_stab_type"
      ],
      "called": [
        "debug_get_type_name.constprop.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "parse_coff_symbol.constprop.0.isra.0": {
      "entrypoint": "0x00112a33",
      "current_name": "parse_coff_symbol.constprop.0.isra.0",
      "code": "\nbool parse_coff_symbol_constprop_0_isra_0\n               (undefined8 param_1,long param_2,undefined8 param_3,byte param_4,undefined8 param_5,\n               undefined8 param_6,uint param_7)\n\n{\n  undefined uVar1;\n  long lVar2;\n  long *plVar3;\n  \n  if (param_4 \u003c 0x12) {\n    if (param_4 !\u003d 0) {\n      switch(param_4) {\n      case 1:\n        uVar1 \u003d debug_record_variable\n                          (param_5,*(undefined8 *)(param_2 + 8),param_6,4,\n                           *(long *)(param_2 + 0x10) + *(long *)(*(long *)(param_2 + 0x20) + 0x30));\n        return (bool)uVar1;\n      case 2:\n        goto switchD_00112a73_caseD_2;\n      case 3:\n        uVar1 \u003d debug_record_variable\n                          (param_5,*(undefined8 *)(param_2 + 8),param_6,(param_7 \u0026 0xff) + 2,\n                           *(long *)(param_2 + 0x10) + *(long *)(*(long *)(param_2 + 0x20) + 0x30));\n        return (bool)uVar1;\n      case 4:\n        uVar1 \u003d debug_record_variable\n                          (param_5,*(undefined8 *)(param_2 + 8),param_6,5,\n                           *(long *)(param_2 + 0x10) + *(long *)(*(long *)(param_2 + 0x20) + 0x30));\n        return (bool)uVar1;\n      case 9:\n        uVar1 \u003d debug_record_parameter\n                          (param_5,*(undefined8 *)(param_2 + 8),param_6,1,\n                           *(long *)(param_2 + 0x10) + *(long *)(*(long *)(param_2 + 0x20) + 0x30));\n        return (bool)uVar1;\n      case 10:\n      case 0xc:\n      case 0xf:\n        lVar2 \u003d debug_tag_type(param_5,*(undefined8 *)(param_2 + 8));\n        if (lVar2 \u003d\u003d 0) {\n          return false;\n        }\n        plVar3 \u003d (long *)coff_get_slot_lto_priv_0(param_1,param_3);\n        *plVar3 \u003d lVar2;\n        break;\n      case 0xd:\n        lVar2 \u003d debug_name_type(param_5,*(undefined8 *)(param_2 + 8));\n        return lVar2 !\u003d 0;\n      case 0x11:\n        uVar1 \u003d debug_record_parameter\n                          (param_5,*(undefined8 *)(param_2 + 8),param_6,2,\n                           *(long *)(param_2 + 0x10) + *(long *)(*(long *)(param_2 + 0x20) + 0x30));\n        return (bool)uVar1;\n      }\n    }\n  }\n  else if (param_4 \u003d\u003d 0x7f) {\nswitchD_00112a73_caseD_2:\n    uVar1 \u003d debug_record_variable\n                      (param_5,*(undefined8 *)(param_2 + 8),param_6,1,\n                       *(long *)(param_2 + 0x10) + *(long *)(*(long *)(param_2 + 0x20) + 0x30));\n    return (bool)uVar1;\n  }\n  return true;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [
        "coff_get_slot.lto_priv.0",
        "debug_record_parameter",
        "debug_tag_type",
        "debug_record_variable",
        "debug_name_type"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_get_real_type.isra.0": {
      "entrypoint": "0x00112b6e",
      "current_name": "debug_get_real_type.isra.0",
      "code": "\n\n\nint * debug_get_real_type_isra_0(int *param_1,long *param_2)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *__format;\n  int *piVar3;\n  long *plVar4;\n  bool bVar5;\n  long *local_18;\n  int *local_10;\n  \n  iVar1 \u003d *param_1;\n  if ((iVar1 !\u003d 1) \u0026\u0026 (1 \u003c iVar1 - 0x16U)) {\n    return param_1;\n  }\n  plVar4 \u003d param_2;\n  while (plVar4 !\u003d (long *)0x0) {\n    if ((param_1 \u003d\u003d (int *)plVar4[1]) ||\n       (bVar5 \u003d plVar4 \u003d\u003d (long *)*plVar4, plVar4 \u003d (long *)*plVar4, bVar5)) {\n      uVar2 \u003d debug_get_type_name_constprop_0\n                        (param_1,\"debug_get_real_type: circular debug information for %s\\n\");\n      __format \u003d (char *)dcgettext(0);\n      fprintf(_stderr,__format,uVar2);\n      return (int *)0x0;\n    }\n  }\n  local_18 \u003d param_2;\n  local_10 \u003d param_1;\n  if (iVar1 - 0x16U \u003c 2) {\n    piVar3 \u003d (int *)debug_get_real_type_isra_0((*(undefined8 **)(param_1 + 4))[1],\u0026local_18);\n    return piVar3;\n  }\n  piVar3 \u003d *(int **)**(undefined8 **)(param_1 + 4);\n  if (param_1 \u003d\u003d piVar3) {\n    return param_1;\n  }\n  if (piVar3 \u003d\u003d (int *)0x0) {\n    return param_1;\n  }\n  piVar3 \u003d (int *)debug_get_real_type_isra_0(piVar3,\u0026local_18);\n  return piVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_get_fields.isra.0",
        "debug_type_samep",
        "debug_get_real_type.isra.0",
        "debug_write_type.constprop.0",
        "parse_stab_type"
      ],
      "called": [
        "fprintf",
        "debug_get_real_type.isra.0",
        "dcgettext",
        "debug_get_type_name.constprop.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_write_type.constprop.0": {
      "entrypoint": "0x00112c1f",
      "current_name": "debug_write_type.constprop.0",
      "code": "\n\n\nundefined8 debug_write_type_constprop_0(ulong param_1,undefined8 param_2,int *param_3,long param_4)\n\n{\n  long *plVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  undefined8 *puVar4;\n  char cVar5;\n  int *piVar6;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  int iVar9;\n  undefined4 uVar10;\n  undefined8 uVar11;\n  ulong uVar12;\n  uint uVar13;\n  bool bVar14;\n  uint local_3c;\n  \n  uVar12 \u003d param_1;\nLAB_00112c39:\n  if (param_3 !\u003d (int *)0x0) {\n    iVar9 \u003d *param_3;\n    if (iVar9 - 0x16U \u003c 2) {\n      do {\n        plVar1 \u003d *(long **)(param_3 + 4);\n        uVar13 \u003d *(uint *)(param_1 + 0x30);\n        uVar12 \u003d (ulong)uVar13;\n        lVar2 \u003d *plVar1;\n        if (*(uint *)(lVar2 + 0x10) \u003d\u003d uVar13) {\n          if (iVar9 \u003d\u003d 0x16) {\n            uVar7 \u003d stab_typedef_type_lto_priv_0(param_2,*(undefined8 *)(lVar2 + 8));\n            return uVar7;\n          }\nLAB_00112c94:\n          piVar6 \u003d (int *)debug_get_real_type_isra_0(param_3,0);\n          if (piVar6 \u003d\u003d (int *)0x0) goto LAB_00112dd6;\n          if ((*piVar6 - 7U \u003c 4) \u0026\u0026 (*(long *)(piVar6 + 4) !\u003d 0)) {\n            if ((*(uint *)(*(long *)(piVar6 + 4) + 0xc) \u003c\u003d *(uint *)(param_1 + 0x38)) \u0026\u0026\n               (cVar5 \u003d debug_set_class_id_lto_priv_0\n                                  (param_1,*(undefined8 *)(**(long **)(param_3 + 4) + 8),piVar6),\n               cVar5 \u003d\u003d \u0027\\0\u0027)) {\n              return 0;\n            }\n            uVar13 \u003d *(uint *)(*(long *)(piVar6 + 4) + 0xc);\n          }\n          else {\n            uVar13 \u003d 0;\n          }\n          iVar9 \u003d *piVar6;\n          uVar7 \u003d *(undefined8 *)(**(long **)(param_3 + 4) + 8);\n          goto LAB_00112ed2;\n        }\n        if (iVar9 \u003d\u003d 0x17) {\n          if (lVar2 !\u003d param_4) goto LAB_00112c94;\n          *(uint *)(param_4 + 0x10) \u003d uVar13;\n          param_4 \u003d *plVar1;\n          param_3 \u003d (int *)plVar1[1];\n          goto LAB_00112c39;\n        }\n        if (param_4 !\u003d 0) {\n          *(uint *)(param_4 + 0x10) \u003d uVar13;\n        }\n        param_3 \u003d (int *)plVar1[1];\n        if (param_3 \u003d\u003d (int *)0x0) goto LAB_00112dd6;\n        iVar9 \u003d *param_3;\n        param_4 \u003d 0;\n      } while (iVar9 - 0x16U \u003c 2);\nLAB_00112d74:\n      uVar7 \u003d 0;\n    }\n    else {\n      if (param_4 \u003d\u003d 0) goto LAB_00112d74;\n      *(undefined4 *)(param_4 + 0x10) \u003d *(undefined4 *)(param_1 + 0x30);\n      if (*(int *)(param_4 + 0x14) !\u003d 1) {\n                    \n        __assert_fail(\"name-\u003ekind \u003d\u003d DEBUG_OBJECT_TAG\",\"../../binutils/debug.c\",0x9b3,\n                      \"debug_write_type\");\n      }\n      uVar7 \u003d *(undefined8 *)(param_4 + 8);\n    }\n    switch(iVar9) {\n    case 0:\n      uVar7 \u003d dcgettext(0,\"debug_write_type: illegal type encountered\",5);\n      fprintf(_stderr,\"%s\\n\",uVar7);\n      return 0;\n    case 1:\n      goto switchD_00112d8e_caseD_1;\n    case 2:\n      uVar7 \u003d stab_void_type_lto_priv_0(param_2);\n      return uVar7;\n    case 3:\n      uVar7 \u003d stab_int_type_lto_priv_0(param_2,param_3[1],*(undefined *)(param_3 + 4));\n      return uVar7;\n    case 4:\n      uVar7 \u003d stab_float_type_lto_priv_0(param_2,param_3[1]);\n      return uVar7;\n    case 5:\n      uVar7 \u003d stab_complex_type_lto_priv_0(param_2,param_3[1]);\n      return uVar7;\n    case 6:\n      uVar7 \u003d stab_bool_type_lto_priv_0(param_2,param_3[1]);\n      return uVar7;\n    case 7:\n    case 8:\n      if (*(long *)(param_3 + 4) !\u003d 0) {\n        if ((*(uint *)(*(long *)(param_3 + 4) + 0xc) \u003c\u003d *(uint *)(param_1 + 0x38)) \u0026\u0026\n           (cVar5 \u003d debug_set_class_id_lto_priv_0(param_1,uVar7,param_3), cVar5 \u003d\u003d \u0027\\0\u0027)) {\n          return 0;\n        }\n        lVar2 \u003d *(long *)(param_3 + 4);\n        if (*(int *)(param_1 + 0x30) \u003d\u003d *(int *)(lVar2 + 8)) {\n          uVar13 \u003d *(uint *)(lVar2 + 0xc);\n          if (uVar13 \u003c\u003d *(uint *)(param_1 + 0x38)) {\n                    \n            __assert_fail(\"type-\u003eu.kclass-\u003eid \u003e info-\u003ebase_id\",\"../../binutils/debug.c\",0x9db,\n                          \"debug_write_type\");\n          }\n          iVar9 \u003d *param_3;\nLAB_00112ed2:\n          uVar7 \u003d stab_tag_type_lto_priv_0(param_2,uVar7,uVar13,iVar9);\n          return uVar7;\n        }\n        *(int *)(lVar2 + 8) \u003d *(int *)(param_1 + 0x30);\n      }\n      uVar10 \u003d 0;\n      if (*(long *)(param_3 + 4) !\u003d 0) {\n        uVar10 \u003d *(undefined4 *)(*(long *)(param_3 + 4) + 0xc);\n      }\n      cVar5 \u003d stab_start_struct_type_lto_priv_0(param_2,uVar7,uVar10,*param_3 \u003d\u003d 7,param_3[1]);\n      if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      if ((*(long **)(param_3 + 4) !\u003d (long *)0x0) \u0026\u0026 (uVar12 \u003d 0, **(long **)(param_3 + 4) !\u003d 0)) {\n        while( true ) {\n          puVar4 \u003d *(undefined8 **)(**(long **)(param_3 + 4) + uVar12 * 8);\n          if (puVar4 \u003d\u003d (undefined8 *)0x0) break;\n          cVar5 \u003d debug_write_type_constprop_0(param_1,param_2,puVar4[1],0);\n          if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n            return 0;\n          }\n          cVar5 \u003d stab_struct_field_lto_priv_0\n                            (param_2,*puVar4,*(undefined4 *)(puVar4 + 3),\n                             *(undefined4 *)((long)puVar4 + 0x1c),*(undefined4 *)(puVar4 + 2));\n          if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n            return 0;\n          }\n          uVar12 \u003d (ulong)((int)uVar12 + 1);\n        }\n      }\n      uVar7 \u003d stab_end_struct_type_lto_priv_0(param_2);\n      return uVar7;\n    case 9:\n    case 10:\n      if (*(long *)(param_3 + 4) \u003d\u003d 0) {\n        uVar13 \u003d 0;\n        piVar6 \u003d (int *)0x0;\n      }\n      else {\n        if ((*(uint *)(*(long *)(param_3 + 4) + 0xc) \u003c\u003d *(uint *)(param_1 + 0x38)) \u0026\u0026\n           (uVar12 \u003d param_1, cVar5 \u003d debug_set_class_id_lto_priv_0(param_1,uVar7,param_3),\n           cVar5 \u003d\u003d \u0027\\0\u0027)) {\n          return 0;\n        }\n        lVar2 \u003d *(long *)(param_3 + 4);\n        uVar13 \u003d *(uint *)(lVar2 + 0xc);\n        if (*(int *)(param_1 + 0x30) \u003d\u003d *(int *)(lVar2 + 8)) {\n          if (uVar13 \u003c\u003d *(uint *)(param_1 + 0x38)) {\n                    \n            __assert_fail(\"type-\u003eu.kclass-\u003eid \u003e info-\u003ebase_id\",\"../../binutils/debug.c\",0xa87,\n                          \"debug_write_class_type\");\n          }\n          iVar9 \u003d *param_3;\n          goto LAB_00112ed2;\n        }\n        piVar6 \u003d *(int **)(lVar2 + 0x20);\n        *(int *)(lVar2 + 8) \u003d *(int *)(param_1 + 0x30);\n        if (((piVar6 !\u003d (int *)0x0) \u0026\u0026 (param_3 !\u003d piVar6)) \u0026\u0026\n           (uVar12 \u003d param_1, cVar5 \u003d debug_write_type_constprop_0(param_1,param_2,piVar6,0),\n           cVar5 \u003d\u003d \u0027\\0\u0027)) {\n          return 0;\n        }\n      }\n      cVar5 \u003d stab_start_class_type_lto_priv_0\n                        (param_2,uVar7,uVar13,*param_3 \u003d\u003d 9,param_3[1],piVar6 !\u003d (int *)0x0,\n                         param_3 \u003d\u003d piVar6,uVar12);\n      if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      if (*(long **)(param_3 + 4) !\u003d (long *)0x0) {\n        uVar13 \u003d 0;\n        if (**(long **)(param_3 + 4) !\u003d 0) {\n          while (puVar4 \u003d *(undefined8 **)(**(long **)(param_3 + 4) + (ulong)uVar13 * 8),\n                puVar4 !\u003d (undefined8 *)0x0) {\n            cVar5 \u003d debug_write_type_constprop_0(param_1,param_2,puVar4[1],0);\n            if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n              return 0;\n            }\n            if (*(char *)((long)puVar4 + 0x14) \u003d\u003d \u0027\\0\u0027) {\n              cVar5 \u003d stab_struct_field_lto_priv_0(param_2,*puVar4,*(undefined4 *)(puVar4 + 3));\n            }\n            else {\n              cVar5 \u003d stab_class_static_member_lto_priv_0(param_2,*puVar4,puVar4[3]);\n            }\n            if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n              return 0;\n            }\n            uVar13 \u003d uVar13 + 1;\n          }\n        }\n        uVar13 \u003d 0;\n        if (*(long *)(*(long *)(param_3 + 4) + 0x10) !\u003d 0) {\n          while (puVar4 \u003d *(undefined8 **)\n                           (*(long *)(*(long *)(param_3 + 4) + 0x10) + (ulong)uVar13 * 8),\n                puVar4 !\u003d (undefined8 *)0x0) {\n            cVar5 \u003d debug_write_type_constprop_0(param_1,param_2,*puVar4,0);\n            if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n              return 0;\n            }\n            cVar5 \u003d stab_class_baseclass_lto_priv_0\n                              (param_2,*(undefined4 *)(puVar4 + 1),\n                               *(undefined *)((long)puVar4 + 0xc));\n            if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n              return 0;\n            }\n            uVar13 \u003d uVar13 + 1;\n          }\n        }\n        local_3c \u003d 0;\n        if (*(long *)(*(long *)(param_3 + 4) + 0x18) !\u003d 0) {\n          while (puVar4 \u003d *(undefined8 **)\n                           (*(long *)(*(long *)(param_3 + 4) + 0x18) + (ulong)local_3c * 8),\n                puVar4 !\u003d (undefined8 *)0x0) {\n            cVar5 \u003d stab_class_start_method_lto_priv_0(param_2,*puVar4);\n            if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n              return 0;\n            }\n            uVar13 \u003d 0;\n            while (puVar3 \u003d *(undefined8 **)(puVar4[1] + (ulong)uVar13 * 8),\n                  puVar3 !\u003d (undefined8 *)0x0) {\n              if ((puVar3[4] !\u003d 0) \u0026\u0026\n                 (cVar5 \u003d debug_write_type_constprop_0(param_1,param_2,puVar3[4],0), cVar5 \u003d\u003d \u0027\\0\u0027))\n              {\n                return 0;\n              }\n              cVar5 \u003d debug_write_type_constprop_0(param_1,param_2,puVar3[1],0);\n              if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n                return 0;\n              }\n              if (puVar3[3] \u003d\u003d -1) {\n                cVar5 \u003d stab_class_static_method_variant_lto_priv_0\n                                  (param_2,*puVar3,*(undefined4 *)(puVar3 + 2),\n                                   *(undefined *)((long)puVar3 + 0x14),\n                                   *(undefined *)((long)puVar3 + 0x15));\n              }\n              else {\n                cVar5 \u003d stab_class_method_variant_lto_priv_0(param_2);\n              }\n              if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n                return 0;\n              }\n              uVar13 \u003d uVar13 + 1;\n            }\n            cVar5 \u003d stab_class_end_method_lto_priv_0(param_2);\n            if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n              return 0;\n            }\n            local_3c \u003d local_3c + 1;\n          }\n        }\n      }\n      uVar7 \u003d stab_end_class_type_lto_priv_0(param_2);\n      return uVar7;\n    case 0xb:\n      puVar4 \u003d *(undefined8 **)(param_3 + 4);\n      if (puVar4 \u003d\u003d (undefined8 *)0x0) {\n        uVar8 \u003d 0;\n        uVar11 \u003d 0;\n      }\n      else {\n        uVar8 \u003d puVar4[1];\n        uVar11 \u003d *puVar4;\n      }\n      uVar7 \u003d stab_enum_type_lto_priv_0(param_2,uVar7,uVar11,uVar8);\n      return uVar7;\n    case 0xc:\n      cVar5 \u003d debug_write_type_constprop_0(param_1,param_2,*(undefined8 *)(param_3 + 4),0);\n      if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      uVar7 \u003d stab_pointer_type_lto_priv_0(param_2);\n      return uVar7;\n    case 0xd:\n      cVar5 \u003d debug_write_type_constprop_0(param_1,param_2,**(undefined8 **)(param_3 + 4),0);\n      if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      uVar12 \u003d 0;\n      if (*(long *)(*(long *)(param_3 + 4) + 8) \u003d\u003d 0) {\n        uVar12 \u003d 0xffffffff;\n      }\n      else {\n        while (lVar2 \u003d *(long *)(*(long *)(*(long *)(param_3 + 4) + 8) + uVar12 * 8), lVar2 !\u003d 0) {\n          uVar12 \u003d uVar12 + 1;\n          cVar5 \u003d debug_write_type_constprop_0(param_1,param_2,lVar2,0);\n          if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n            return 0;\n          }\n        }\n        uVar12 \u003d uVar12 \u0026 0xffffffff;\n      }\n      uVar7 \u003d stab_function_type_lto_priv_0\n                        (param_2,uVar12,*(undefined *)(*(long *)(param_3 + 4) + 0x10));\n      return uVar7;\n    case 0xe:\n      cVar5 \u003d debug_write_type_constprop_0(param_1,param_2,*(undefined8 *)(param_3 + 4),0);\n      if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      uVar7 \u003d stab_reference_type_lto_priv_0(param_2);\n      return uVar7;\n    case 0xf:\n      cVar5 \u003d debug_write_type_constprop_0(param_1,param_2,**(undefined8 **)(param_3 + 4),0);\n      if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      uVar7 \u003d stab_range_type_lto_priv_0\n                        (param_2,*(undefined8 *)(*(long *)(param_3 + 4) + 8),\n                         *(undefined8 *)(*(long *)(param_3 + 4) + 0x10));\n      return uVar7;\n    case 0x10:\n      cVar5 \u003d debug_write_type_constprop_0(param_1,param_2,**(undefined8 **)(param_3 + 4),0);\n      if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      cVar5 \u003d debug_write_type_constprop_0\n                        (param_1,param_2,*(undefined8 *)(*(long *)(param_3 + 4) + 8),0);\n      if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      lVar2 \u003d *(long *)(param_3 + 4);\n      uVar7 \u003d stab_array_type_lto_priv_0\n                        (param_2,*(undefined8 *)(lVar2 + 0x10),*(undefined8 *)(lVar2 + 0x18),\n                         *(undefined *)(lVar2 + 0x20));\n      return uVar7;\n    case 0x11:\n      cVar5 \u003d debug_write_type_constprop_0(param_1,param_2,**(undefined8 **)(param_3 + 4),0);\n      if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      uVar7 \u003d stab_set_type_lto_priv_0(param_2,*(undefined *)(*(long *)(param_3 + 4) + 8));\n      return uVar7;\n    case 0x12:\n      cVar5 \u003d debug_write_type_constprop_0(param_1,param_2,**(undefined8 **)(param_3 + 4),0);\n      if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      cVar5 \u003d debug_write_type_constprop_0\n                        (param_1,param_2,*(undefined8 *)(*(long *)(param_3 + 4) + 8),0);\n      if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      uVar7 \u003d stab_offset_type_lto_priv_0(param_2);\n      return uVar7;\n    case 0x13:\n      cVar5 \u003d debug_write_type_constprop_0(param_1,param_2,**(undefined8 **)(param_3 + 4),0);\n      if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      uVar12 \u003d 0;\n      if (*(long *)(*(long *)(param_3 + 4) + 0x10) \u003d\u003d 0) {\n        uVar12 \u003d 0xffffffff;\n      }\n      else {\n        while (lVar2 \u003d *(long *)(*(long *)(*(long *)(param_3 + 4) + 0x10) + uVar12 * 8), lVar2 !\u003d 0)\n        {\n          uVar12 \u003d uVar12 + 1;\n          cVar5 \u003d debug_write_type_constprop_0(param_1,param_2,lVar2,0);\n          if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n            return 0;\n          }\n        }\n      }\n      if ((*(long *)(*(long *)(param_3 + 4) + 8) !\u003d 0) \u0026\u0026\n         (cVar5 \u003d debug_write_type_constprop_0\n                            (param_1,param_2,*(long *)(*(long *)(param_3 + 4) + 8),0), cVar5 \u003d\u003d \u0027\\0\u0027\n         )) {\n        return 0;\n      }\n      uVar7 \u003d stab_method_type_lto_priv_0\n                        (param_2,*(long *)(*(long *)(param_3 + 4) + 8) !\u003d 0,uVar12 \u0026 0xffffffff,\n                         *(undefined *)(*(long *)(param_3 + 4) + 0x18));\n      return uVar7;\n    case 0x14:\n      cVar5 \u003d debug_write_type_constprop_0(param_1,param_2,*(undefined8 *)(param_3 + 4),0);\n      if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      uVar7 \u003d stab_const_type_lto_priv_0(param_2);\n      return uVar7;\n    case 0x15:\n      cVar5 \u003d debug_write_type_constprop_0(param_1,param_2,*(undefined8 *)(param_3 + 4),0);\n      if (cVar5 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n      uVar7 \u003d stab_volatile_type_lto_priv_0(param_2);\n      return uVar7;\n    default:\n                    \n      abort();\n    }\n  }\n  goto LAB_00112dd6;\nswitchD_00112d8e_caseD_1:\n  bVar14 \u003d *(int **)**(undefined8 **)(param_3 + 4) \u003d\u003d param_3;\n  param_3 \u003d *(int **)**(undefined8 **)(param_3 + 4);\n  if (bVar14) {\nLAB_00112dd6:\n    uVar7 \u003d stab_empty_type_lto_priv_0(param_2);\n    return uVar7;\n  }\n  goto LAB_00112c39;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_name.constprop.0",
        "debug_write_type.constprop.0"
      ],
      "called": [
        "stab_int_type.lto_priv.0",
        "stab_enum_type.lto_priv.0",
        "stab_range_type.lto_priv.0",
        "stab_class_method_variant.lto_priv.0",
        "stab_pointer_type.lto_priv.0",
        "stab_volatile_type.lto_priv.0",
        "debug_get_real_type.isra.0",
        "stab_method_type.lto_priv.0",
        "stab_bool_type.lto_priv.0",
        "abort",
        "stab_start_struct_type.lto_priv.0",
        "stab_tag_type.lto_priv.0",
        "stab_class_baseclass.lto_priv.0",
        "debug_set_class_id.lto_priv.0",
        "dcgettext",
        "stab_array_type.lto_priv.0",
        "stab_empty_type.lto_priv.0",
        "stab_class_end_method.lto_priv.0",
        "stab_const_type.lto_priv.0",
        "stab_class_static_method_variant.lto_priv.0",
        "stab_class_start_method.lto_priv.0",
        "stab_end_class_type.lto_priv.0",
        "stab_struct_field.lto_priv.0",
        "stab_end_struct_type.lto_priv.0",
        "stab_function_type.lto_priv.0",
        "stab_set_type.lto_priv.0",
        "__assert_fail",
        "stab_void_type.lto_priv.0",
        "stab_class_static_member.lto_priv.0",
        "fprintf",
        "stab_float_type.lto_priv.0",
        "stab_complex_type.lto_priv.0",
        "stab_offset_type.lto_priv.0",
        "debug_write_type.constprop.0",
        "stab_reference_type.lto_priv.0",
        "stab_start_class_type.lto_priv.0",
        "stab_typedef_type.lto_priv.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_write_name.constprop.0": {
      "entrypoint": "0x001135a5",
      "current_name": "debug_write_name.constprop.0",
      "code": "\nundefined8 debug_write_name_constprop_0(undefined8 param_1,undefined8 param_2,long param_3)\n\n{\n  int iVar1;\n  char cVar2;\n  undefined8 uVar3;\n  undefined8 *puVar4;\n  undefined8 *puVar5;\n  \n  if (6 \u003c *(uint *)(param_3 + 0x14)) {\n                    \n    abort();\n  }\n  switch(*(undefined4 *)(param_3 + 0x14)) {\n  case 0:\n    cVar2 \u003d debug_write_type_constprop_0(param_1,param_2,*(undefined8 *)(param_3 + 0x20),param_3);\n    if (cVar2 !\u003d \u0027\\0\u0027) {\n      uVar3 \u003d stab_typdef_lto_priv_0(param_2,*(undefined8 *)(param_3 + 8));\n      return uVar3;\n    }\n    break;\n  case 1:\n    cVar2 \u003d debug_write_type_constprop_0(param_1,param_2,*(undefined8 *)(param_3 + 0x20),param_3);\n    if (cVar2 !\u003d \u0027\\0\u0027) {\n      uVar3 \u003d stab_tag_lto_priv_0(param_2,*(undefined8 *)(param_3 + 8));\n      return uVar3;\n    }\n    break;\n  case 2:\n    cVar2 \u003d debug_write_type_constprop_0\n                      (param_1,param_2,*(undefined8 *)(*(long *)(param_3 + 0x20) + 8),0);\n    if (cVar2 !\u003d \u0027\\0\u0027) {\n      uVar3 \u003d stab_variable_lto_priv_0\n                        (param_2,*(undefined8 *)(param_3 + 8),**(undefined4 **)(param_3 + 0x20),\n                         *(undefined8 *)(*(undefined4 **)(param_3 + 0x20) + 4));\n      return uVar3;\n    }\n    break;\n  case 3:\n    puVar5 \u003d *(undefined8 **)(param_3 + 0x20);\n    iVar1 \u003d *(int *)(param_3 + 0x18);\n    uVar3 \u003d *(undefined8 *)(param_3 + 8);\n    cVar2 \u003d debug_write_linenos_constprop_0(param_1,param_2,*(undefined8 *)(puVar5[2] + 0x18));\n    if (((cVar2 !\u003d \u0027\\0\u0027) \u0026\u0026\n        (cVar2 \u003d debug_write_type_constprop_0(param_1,param_2,*puVar5,0), cVar2 !\u003d \u0027\\0\u0027)) \u0026\u0026\n       (cVar2 \u003d stab_start_function_lto_priv_0(param_2,uVar3,iVar1 \u003d\u003d 2), cVar2 !\u003d \u0027\\0\u0027)) {\n      for (puVar4 \u003d (undefined8 *)puVar5[1]; puVar4 !\u003d (undefined8 *)0x0;\n          puVar4 \u003d (undefined8 *)*puVar4) {\n        cVar2 \u003d debug_write_type_constprop_0(param_1,param_2,puVar4[2],0);\n        if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n          return 0;\n        }\n        cVar2 \u003d stab_function_parameter_lto_priv_0(param_2,puVar4[1],*(undefined4 *)(puVar4 + 3));\n        if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n          return 0;\n        }\n      }\n      puVar5 \u003d (undefined8 *)puVar5[2];\n      while( true ) {\n        if (puVar5 \u003d\u003d (undefined8 *)0x0) {\n          uVar3 \u003d stab_end_function_lto_priv_0(param_2);\n          return uVar3;\n        }\n        cVar2 \u003d debug_write_block_constprop_0(param_1,param_2,puVar5);\n        if (cVar2 \u003d\u003d \u0027\\0\u0027) break;\n        puVar5 \u003d (undefined8 *)*puVar5;\n      }\n    }\n    break;\n  case 4:\n    uVar3 \u003d stab_int_constant_lto_priv_0\n                      (param_2,*(undefined8 *)(param_3 + 8),*(undefined8 *)(param_3 + 0x20));\n    return uVar3;\n  case 5:\n    uVar3 \u003d stab_float_constant_lto_priv_0\n                      (*(undefined8 *)(param_3 + 0x20),param_2,*(undefined8 *)(param_3 + 8));\n    return uVar3;\n  case 6:\n    cVar2 \u003d debug_write_type_constprop_0(param_1,param_2,**(undefined8 **)(param_3 + 0x20),0);\n    if (cVar2 !\u003d \u0027\\0\u0027) {\n      uVar3 \u003d stab_typed_constant_lto_priv_0\n                        (param_2,*(undefined8 *)(param_3 + 8),\n                         *(undefined8 *)(*(long *)(param_3 + 0x20) + 8));\n      return uVar3;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_block.constprop.0",
        "write_stabs_in_sections_debugging_info.constprop.0"
      ],
      "called": [
        "stab_float_constant.lto_priv.0",
        "stab_typdef.lto_priv.0",
        "stab_start_function.lto_priv.0",
        "stab_typed_constant.lto_priv.0",
        "stab_int_constant.lto_priv.0",
        "abort",
        "stab_function_parameter.lto_priv.0",
        "debug_write_linenos.constprop.0",
        "debug_write_block.constprop.0",
        "stab_variable.lto_priv.0",
        "debug_write_type.constprop.0",
        "stab_end_function.lto_priv.0",
        "stab_tag.lto_priv.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "write_stabs_in_sections_debugging_info.constprop.0": {
      "entrypoint": "0x0011378f",
      "current_name": "write_stabs_in_sections_debugging_info.constprop.0",
      "code": "\nundefined4\nwrite_stabs_in_sections_debugging_info_constprop_0\n          (undefined8 *param_1,undefined8 *param_2,long *param_3,undefined8 *param_4,\n          undefined8 *param_5,undefined8 *param_6)\n\n{\n  undefined auVar1 [16];\n  char cVar2;\n  undefined4 uVar3;\n  undefined8 uVar4;\n  undefined *puVar5;\n  size_t sVar6;\n  long lVar7;\n  undefined8 *puVar8;\n  undefined4 *puVar9;\n  char *__dest;\n  undefined8 *puVar10;\n  long *plVar11;\n  byte bVar12;\n  undefined8 *local_258;\n  long local_250;\n  undefined4 local_248;\n  undefined4 uStack_244;\n  undefined4 uStack_240;\n  undefined4 uStack_23c;\n  undefined local_238 [16];\n  undefined8 local_228;\n  undefined local_220 [40];\n  undefined8 local_1f8;\n  undefined8 local_1f0;\n  undefined4 local_1e8 [82];\n  undefined local_a0 [40];\n  undefined local_78 [8];\n  undefined8 uStack_70;\n  undefined8 local_68;\n  undefined4 local_60;\n  undefined4 local_58;\n  undefined4 uStack_54;\n  undefined4 uStack_50;\n  undefined4 uStack_4c;\n  \n  bVar12 \u003d 0;\n  local_248 \u003d 0;\n  uStack_244 \u003d 0;\n  uStack_240 \u003d 500;\n  uStack_23c \u003d 0;\n  local_258 \u003d param_1;\n  local_250 \u003d xmalloc(500);\n  local_228 \u003d 1;\n  local_238 \u003d ZEXT816(0);\n  cVar2 \u003d bfd_hash_table_init(local_220,string_hash_newfunc_lto_priv_0,0x30);\n  if ((cVar2 \u003d\u003d \u0027\\0\u0027) ||\n     (cVar2 \u003d bfd_hash_table_init(local_a0,string_hash_newfunc_lto_priv_0,0x30), cVar2 \u003d\u003d \u0027\\0\u0027)) {\n    uVar3 \u003d bfd_get_error();\n    uVar4 \u003d bfd_errmsg(uVar3);\n    non_fatal(\"bfd_hash_table_init_failed: %s\",uVar4);\n  }\n  else {\n    local_1f8 \u003d 0;\n    unique0x100000e9 \u003d 0xffffffff;\n    local_78 \u003d (undefined  [8])0xffffffffffffffff;\n    unique0x100000ed \u003d 0xffffffff;\n    puVar9 \u003d local_1e8;\n    for (lVar7 \u003d 0x52; lVar7 !\u003d 0; lVar7 \u003d lVar7 + -1) {\n      *puVar9 \u003d 0;\n      puVar9 \u003d puVar9 + (ulong)bVar12 * -2 + 1;\n    }\n    local_68 \u003d 0;\n    local_60 \u003d 0;\n    local_1f0 \u003d 1;\n    local_58 \u003d 0;\n    uStack_54 \u003d 0;\n    uStack_50 \u003d 0xffffffff;\n    uStack_4c \u003d 0xffffffff;\n    cVar2 \u003d stab_write_symbol_lto_priv_0(\u0026local_258,0,0,0,0);\n    auVar1 \u003d _local_78;\n    if (cVar2 !\u003d \u0027\\0\u0027) {\n      local_78._4_4_ \u003d uStack_244;\n      local_78._0_4_ \u003d local_248;\n      uStack_70 \u003d auVar1._8_8_;\n      cVar2 \u003d stab_write_symbol_lto_priv_0(\u0026local_258,100,0,0,*param_1);\n      if (cVar2 !\u003d \u0027\\0\u0027) {\n        *(int *)(param_2 + 6) \u003d *(int *)(param_2 + 6) + 1;\n        param_2[10] \u003d 0;\n        puVar10 \u003d (undefined8 *)*param_2;\n        *(undefined4 *)(param_2 + 7) \u003d *(undefined4 *)((long)param_2 + 0x34);\n        for (; puVar10 !\u003d (undefined8 *)0x0; puVar10 \u003d (undefined8 *)*puVar10) {\n          param_2[8] \u003d puVar10[2];\n          *(undefined4 *)(param_2 + 9) \u003d 0;\n          cVar2 \u003d stab_start_compilation_unit_lto_priv_0(\u0026local_258,*(undefined8 *)(puVar10[1] + 8))\n          ;\n          if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n            return 0;\n          }\n          plVar11 \u003d (long *)puVar10[1];\n          if (plVar11 !\u003d (long *)0x0) {\n            while( true ) {\n              if ((undefined8 *)plVar11[2] !\u003d (undefined8 *)0x0) {\n                for (puVar8 \u003d *(undefined8 **)(undefined8 *)plVar11[2]; puVar8 !\u003d (undefined8 *)0x0;\n                    puVar8 \u003d (undefined8 *)*puVar8) {\n                  cVar2 \u003d debug_write_name_constprop_0(param_2,\u0026local_258);\n                  if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n                    return 0;\n                  }\n                }\n              }\n              plVar11 \u003d (long *)*plVar11;\n              if (plVar11 \u003d\u003d (long *)0x0) break;\n              cVar2 \u003d stab_start_source_lto_priv_0(\u0026local_258,plVar11[1]);\n              if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n                return 0;\n              }\n            }\n          }\n          cVar2 \u003d debug_write_linenos_constprop_0(param_2,\u0026local_258,0xffffffffffffffff);\n          if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n            return 0;\n          }\n        }\n        if ((CONCAT44(uStack_4c,uStack_50) \u003d\u003d -1) \u0026\u0026\n           (uVar3 \u003d stab_write_symbol_lto_priv_0(\u0026local_258,100,0,local_68,0), (char)uVar3 !\u003d \u0027\\0\u0027))\n        {\n          (**(code **)(param_1[1] + 0x50))(local_228,local_250 + 8);\n          *param_3 \u003d local_250;\n          *param_4 \u003d CONCAT44(uStack_244,local_248);\n          *param_6 \u003d local_228;\n          puVar5 \u003d (undefined *)xmalloc();\n          *puVar5 \u003d 0;\n          __dest \u003d puVar5 + 1;\n          *param_5 \u003d puVar5;\n          for (lVar7 \u003d local_238._0_8_; lVar7 !\u003d 0; lVar7 \u003d *(long *)(lVar7 + 0x18)) {\n            strcpy(__dest,*(char **)(lVar7 + 8));\n            sVar6 \u003d strlen(__dest);\n            __dest \u003d __dest + sVar6 + 1;\n          }\n          return uVar3;\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [
        "non_fatal",
        "debug_write_name.constprop.0",
        "strlen",
        "bfd_hash_table_init",
        "strcpy",
        "stab_write_symbol.lto_priv.0",
        "string_hash_newfunc.lto_priv.0",
        "debug_write_linenos.constprop.0",
        "stab_start_compilation_unit.lto_priv.0",
        "bfd_errmsg",
        "bfd_get_error",
        "stab_start_source.lto_priv.0",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_write_block.constprop.0": {
      "entrypoint": "0x00113a4d",
      "current_name": "debug_write_block.constprop.0",
      "code": "\nundefined8\ndebug_write_block_constprop_0\n          (undefined8 param_1,undefined8 param_2,long param_3,undefined8 param_4,undefined8 param_5)\n\n{\n  char cVar1;\n  undefined8 uVar2;\n  undefined8 *puVar3;\n  undefined auVar4 [16];\n  \n  cVar1 \u003d debug_write_linenos_constprop_0(param_1,param_2,*(undefined8 *)(param_3 + 0x18));\n  if ((cVar1 !\u003d \u0027\\0\u0027) \u0026\u0026\n     (((*(long *)(param_3 + 0x28) \u003d\u003d 0 \u0026\u0026 (*(long *)(param_3 + 8) !\u003d 0)) ||\n      (cVar1 \u003d stab_start_block_lto_priv_0(param_2,*(undefined8 *)(param_3 + 0x18)), cVar1 !\u003d \u0027\\0\u0027))\n     )) {\n    if (*(undefined8 **)(param_3 + 0x28) !\u003d (undefined8 *)0x0) {\n      for (puVar3 \u003d (undefined8 *)**(undefined8 **)(param_3 + 0x28); puVar3 !\u003d (undefined8 *)0x0;\n          puVar3 \u003d (undefined8 *)*puVar3) {\n        cVar1 \u003d debug_write_name_constprop_0(param_1,param_2,puVar3);\n        if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n          return 0;\n        }\n      }\n    }\n    for (puVar3 \u003d *(undefined8 **)(param_3 + 0x10); puVar3 !\u003d (undefined8 *)0x0;\n        puVar3 \u003d (undefined8 *)*puVar3) {\n      cVar1 \u003d debug_write_block_constprop_0(param_1,param_2,puVar3);\n      if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n        return 0;\n      }\n    }\n    auVar4 \u003d debug_write_linenos_constprop_0(param_1,param_2,*(undefined8 *)(param_3 + 0x20));\n    if (auVar4[0] !\u003d \u0027\\0\u0027) {\n      if ((*(long *)(param_3 + 0x28) \u003d\u003d 0) \u0026\u0026 (*(long *)(param_3 + 8) !\u003d 0)) {\n        return auVar4._0_8_;\n      }\n      uVar2 \u003d stab_end_block_lto_priv_0\n                        (param_2,*(undefined8 *)(param_3 + 0x20),auVar4._8_8_,param_5);\n      return uVar2;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "debug_write_block.constprop.0",
        "debug_write_name.constprop.0"
      ],
      "called": [
        "debug_write_linenos.constprop.0",
        "debug_write_block.constprop.0",
        "debug_write_name.constprop.0",
        "stab_start_block.lto_priv.0",
        "stab_end_block.lto_priv.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_get_fields.isra.0": {
      "entrypoint": "0x00113b1e",
      "current_name": "debug_get_fields.isra.0",
      "code": "\nundefined  [16]\ndebug_get_fields_isra_0(long param_1,undefined8 param_2,ulong param_3,undefined8 param_4)\n\n{\n  undefined auVar1 [16];\n  int *piVar2;\n  undefined8 uVar3;\n  undefined auVar4 [16];\n  \n  if (param_1 !\u003d 0) {\n    piVar2 \u003d (int *)debug_get_real_type_isra_0(param_1,0);\n    if ((piVar2 \u003d\u003d (int *)0x0) || (3 \u003c *piVar2 - 7U)) {\n      uVar3 \u003d 0;\n    }\n    else {\n      uVar3 \u003d **(undefined8 **)(piVar2 + 4);\n    }\n    auVar4._8_8_ \u003d param_4;\n    auVar4._0_8_ \u003d uVar3;\n    return auVar4;\n  }\n  auVar1._8_8_ \u003d 0;\n  auVar1._0_8_ \u003d param_3;\n  return auVar1 \u003c\u003c 0x40;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_v3_arg",
        "stab_demangle_qualified"
      ],
      "called": [
        "debug_get_real_type.isra.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_make_volatile_type.isra.0": {
      "entrypoint": "0x00113b4a",
      "current_name": "debug_make_volatile_type.isra.0",
      "code": "\nlong debug_make_volatile_type_isra_0(long param_1)\n\n{\n  long lVar1;\n  \n  if (param_1 !\u003d 0) {\n    lVar1 \u003d debug_make_type_constprop_0(0x15,0);\n    if (lVar1 \u003d\u003d 0) {\n      lVar1 \u003d 0;\n    }\n    else {\n      *(long *)(lVar1 + 0x10) \u003d param_1;\n    }\n    return lVar1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "stab_demangle_v3_arg",
        "parse_stab_type"
      ],
      "called": [
        "debug_make_type.constprop.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_make_const_type.isra.0": {
      "entrypoint": "0x00113b71",
      "current_name": "debug_make_const_type.isra.0",
      "code": "\nlong debug_make_const_type_isra_0(long param_1)\n\n{\n  long lVar1;\n  \n  if (param_1 !\u003d 0) {\n    lVar1 \u003d debug_make_type_constprop_0(0x14,0);\n    if (lVar1 \u003d\u003d 0) {\n      lVar1 \u003d 0;\n    }\n    else {\n      *(long *)(lVar1 + 0x10) \u003d param_1;\n    }\n    return lVar1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "stab_demangle_v3_arg",
        "parse_stab_type"
      ],
      "called": [
        "debug_make_type.constprop.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_make_method_type.isra.0": {
      "entrypoint": "0x00113b98",
      "current_name": "debug_make_method_type.isra.0",
      "code": "\nlong debug_make_method_type_isra_0(long param_1,long param_2,long param_3,undefined param_4)\n\n{\n  long lVar1;\n  long *plVar2;\n  \n  if ((param_1 !\u003d 0) \u0026\u0026 (lVar1 \u003d debug_make_type_constprop_0(0x13,0), lVar1 !\u003d 0)) {\n    plVar2 \u003d (long *)xmalloc(0x20);\n    *(undefined4 *)((long)plVar2 + 0x19) \u003d 0;\n    *plVar2 \u003d param_1;\n    *(undefined4 *)((long)plVar2 + 0x1c) \u003d 0;\n    plVar2[1] \u003d param_2;\n    plVar2[2] \u003d param_3;\n    *(undefined *)(plVar2 + 3) \u003d param_4;\n    *(long **)(lVar1 + 0x10) \u003d plVar2;\n    return lVar1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "parse_stab_type"
      ],
      "called": [
        "debug_make_type.constprop.0",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_make_offset_type.isra.0": {
      "entrypoint": "0x00113bfa",
      "current_name": "debug_make_offset_type.isra.0",
      "code": "\nlong debug_make_offset_type_isra_0(long param_1,long param_2)\n\n{\n  long lVar1;\n  long *plVar2;\n  \n  if (((param_1 !\u003d 0) \u0026\u0026 (param_2 !\u003d 0)) \u0026\u0026\n     (lVar1 \u003d debug_make_type_constprop_0(0x12,0), lVar1 !\u003d 0)) {\n    plVar2 \u003d (long *)xmalloc(0x10);\n    *plVar2 \u003d param_1;\n    plVar2[1] \u003d param_2;\n    *(long **)(lVar1 + 0x10) \u003d plVar2;\n    return lVar1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "parse_stab_type"
      ],
      "called": [
        "debug_make_type.constprop.0",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_make_array_type.isra.0": {
      "entrypoint": "0x00113c43",
      "current_name": "debug_make_array_type.isra.0",
      "code": "\nundefined  [16]\ndebug_make_array_type_isra_0\n          (long param_1,long param_2,long param_3,long param_4,undefined param_5,undefined8 param_6)\n\n{\n  long lVar1;\n  long *plVar2;\n  undefined auVar3 [16];\n  \n  if ((param_1 !\u003d 0) \u0026\u0026 (param_2 !\u003d 0)) {\n    lVar1 \u003d debug_make_type_constprop_0(0x10,0);\n    if (lVar1 !\u003d 0) {\n      plVar2 \u003d (long *)xmalloc(0x28);\n      *(undefined4 *)((long)plVar2 + 0x21) \u003d 0;\n      *plVar2 \u003d param_1;\n      *(undefined4 *)((long)plVar2 + 0x24) \u003d 0;\n      plVar2[1] \u003d param_2;\n      plVar2[2] \u003d param_3;\n      plVar2[3] \u003d param_4;\n      *(undefined *)(plVar2 + 4) \u003d param_5;\n      *(long **)(lVar1 + 0x10) \u003d plVar2;\n      goto LAB_00113caa;\n    }\n  }\n  lVar1 \u003d 0;\nLAB_00113caa:\n  auVar3._8_8_ \u003d param_6;\n  auVar3._0_8_ \u003d lVar1;\n  return auVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "parse_stab_type",
        "parse_coff_type.lto_priv.0"
      ],
      "called": [
        "debug_make_type.constprop.0",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_make_reference_type.isra.0": {
      "entrypoint": "0x00113cb9",
      "current_name": "debug_make_reference_type.isra.0",
      "code": "\nlong debug_make_reference_type_isra_0(long param_1)\n\n{\n  long lVar1;\n  \n  if (param_1 !\u003d 0) {\n    lVar1 \u003d debug_make_type_constprop_0(0xe,0);\n    if (lVar1 \u003d\u003d 0) {\n      lVar1 \u003d 0;\n    }\n    else {\n      *(long *)(lVar1 + 0x10) \u003d param_1;\n    }\n    return lVar1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "stab_demangle_v3_arg",
        "parse_stab_type"
      ],
      "called": [
        "debug_make_type.constprop.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_make_function_type.isra.0": {
      "entrypoint": "0x00113ce0",
      "current_name": "debug_make_function_type.isra.0",
      "code": "\nundefined  [16]\ndebug_make_function_type_isra_0\n          (long param_1,long param_2,undefined param_3,undefined8 param_4,undefined8 param_5)\n\n{\n  long lVar1;\n  long *plVar2;\n  undefined auVar3 [16];\n  \n  if (param_1 !\u003d 0) {\n    lVar1 \u003d debug_make_type_constprop_0(0xd,0);\n    if (lVar1 !\u003d 0) {\n      plVar2 \u003d (long *)xmalloc(0x18);\n      *(undefined4 *)((long)plVar2 + 0x11) \u003d 0;\n      *plVar2 \u003d param_1;\n      *(undefined4 *)((long)plVar2 + 0x14) \u003d 0;\n      plVar2[1] \u003d param_2;\n      *(undefined *)(plVar2 + 2) \u003d param_3;\n      *(long **)(lVar1 + 0x10) \u003d plVar2;\n      goto LAB_00113d2f;\n    }\n  }\n  lVar1 \u003d 0;\nLAB_00113d2f:\n  auVar3._8_8_ \u003d param_5;\n  auVar3._0_8_ \u003d lVar1;\n  return auVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "parse_stab",
        "stab_demangle_v3_arg",
        "parse_stab_type",
        "parse_coff_type.lto_priv.0"
      ],
      "called": [
        "debug_make_type.constprop.0",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_make_pointer_type.isra.0": {
      "entrypoint": "0x00113d3a",
      "current_name": "debug_make_pointer_type.isra.0",
      "code": "\nlong debug_make_pointer_type_isra_0(long param_1)\n\n{\n  long lVar1;\n  \n  if (param_1 !\u003d 0) {\n    lVar1 \u003d *(long *)(param_1 + 8);\n    if (lVar1 \u003d\u003d 0) {\n      lVar1 \u003d debug_make_type_constprop_0(0xc,0);\n      if (lVar1 \u003d\u003d 0) {\n        lVar1 \u003d 0;\n      }\n      else {\n        *(long *)(lVar1 + 0x10) \u003d param_1;\n        *(long *)(param_1 + 8) \u003d lVar1;\n      }\n    }\n    return lVar1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "parse_stab",
        "stab_demangle_v3_arg",
        "parse_stab_type",
        "parse_coff_type.lto_priv.0"
      ],
      "called": [
        "debug_make_type.constprop.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_make_enum_type.isra.0": {
      "entrypoint": "0x00113d6e",
      "current_name": "debug_make_enum_type.isra.0",
      "code": "\nlong debug_make_enum_type_isra_0(undefined8 param_1,undefined8 param_2)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  \n  lVar1 \u003d debug_make_type_constprop_0(0xb,0);\n  if (lVar1 !\u003d 0) {\n    puVar2 \u003d (undefined8 *)xmalloc(0x10);\n    *puVar2 \u003d param_1;\n    puVar2[1] \u003d param_2;\n    *(undefined8 **)(lVar1 + 0x10) \u003d puVar2;\n  }\n  return lVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_stab_type",
        "parse_coff_type.lto_priv.0"
      ],
      "called": [
        "debug_make_type.constprop.0",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_make_struct_type.isra.0": {
      "entrypoint": "0x00113da9",
      "current_name": "debug_make_struct_type.isra.0",
      "code": "\nundefined  [16]\ndebug_make_struct_type_isra_0(byte param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  undefined8 *puVar1;\n  long lVar2;\n  undefined8 *puVar3;\n  byte bVar4;\n  undefined auVar5 [16];\n  \n  bVar4 \u003d 0;\n  auVar5._0_8_ \u003d debug_make_type_constprop_0(8 - (uint)param_1);\n  if (auVar5._0_8_ !\u003d 0) {\n    puVar1 \u003d (undefined8 *)xmalloc(0x28);\n    puVar3 \u003d puVar1 + 1;\n    for (lVar2 \u003d 8; lVar2 !\u003d 0; lVar2 \u003d lVar2 + -1) {\n      *(undefined4 *)puVar3 \u003d 0;\n      puVar3 \u003d (undefined8 *)((long)puVar3 + (ulong)bVar4 * -8 + 4);\n    }\n    *puVar1 \u003d param_3;\n    *(undefined8 **)(auVar5._0_8_ + 0x10) \u003d puVar1;\n  }\n  auVar5._8_8_ \u003d param_4;\n  return auVar5;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_coff_struct_type",
        "parse_stab_type",
        "parse_coff_type.lto_priv.0"
      ],
      "called": [
        "debug_make_type.constprop.0",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_make_float_type.isra.0": {
      "entrypoint": "0x00113df2",
      "current_name": "debug_make_float_type.isra.0",
      "code": "\nvoid debug_make_float_type_isra_0(undefined4 param_1)\n\n{\n  debug_make_type_constprop_0(4,param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "stab_demangle_v3_arg",
        "stab_find_type",
        "parse_stab_type",
        "parse_coff_type.lto_priv.0"
      ],
      "called": [
        "debug_make_type.constprop.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_make_int_type.isra.0": {
      "entrypoint": "0x00113dfe",
      "current_name": "debug_make_int_type.isra.0",
      "code": "\nvoid debug_make_int_type_isra_0(undefined4 param_1,undefined param_2)\n\n{\n  long lVar1;\n  \n  lVar1 \u003d debug_make_type_constprop_0(3,param_1);\n  if (lVar1 !\u003d 0) {\n    *(undefined *)(lVar1 + 0x10) \u003d param_2;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "stab_demangle_v3_arg",
        "stab_find_type",
        "parse_stab_type",
        "parse_coff_type.lto_priv.0"
      ],
      "called": [
        "debug_make_type.constprop.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_make_void_type.isra.0": {
      "entrypoint": "0x00113e17",
      "current_name": "debug_make_void_type.isra.0",
      "code": "\nvoid debug_make_void_type_isra_0(void)\n\n{\n  debug_make_type_constprop_0(2,0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_demangle_type.lto_priv.0",
        "stab_demangle_v3_arg",
        "stab_find_type",
        "parse_stab_type",
        "parse_coff_type.lto_priv.0"
      ],
      "called": [
        "debug_make_type.constprop.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_make_indirect_type.isra.0": {
      "entrypoint": "0x00113e23",
      "current_name": "debug_make_indirect_type.isra.0",
      "code": "\nlong debug_make_indirect_type_isra_0(undefined8 param_1,undefined8 param_2)\n\n{\n  long lVar1;\n  undefined8 *puVar2;\n  \n  lVar1 \u003d debug_make_type_constprop_0(1,0);\n  if (lVar1 !\u003d 0) {\n    puVar2 \u003d (undefined8 *)xmalloc(0x10);\n    *puVar2 \u003d param_1;\n    puVar2[1] \u003d param_2;\n    *(undefined8 **)(lVar1 + 0x10) \u003d puVar2;\n  }\n  return lVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_find_tagged_type",
        "stab_find_type",
        "parse_coff_type.lto_priv.0"
      ],
      "called": [
        "debug_make_type.constprop.0",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stab_demangle_function_name.constprop.0": {
      "entrypoint": "0x00113e5e",
      "current_name": "stab_demangle_function_name.constprop.0",
      "code": "\nundefined8 stab_demangle_function_name_constprop_0(undefined8 param_1,char **param_2,long param_3)\n\n{\n  char cVar1;\n  char *local_20 [2];\n  \n  local_20[0] \u003d *param_2;\n  *param_2 \u003d (char *)(param_3 + 2);\n  if ((((long)(char *)(param_3 + 2) - (long)local_20[0] \u003c 5) ||\n      (cVar1 \u003d startswith_lto_priv_0_lto_priv_0(local_20[0],\"type\"), cVar1 \u003d\u003d \u0027\\0\u0027)) ||\n     ((local_20[0][4] !\u003d \u0027$\u0027 \u0026\u0026 (local_20[0][4] !\u003d \u0027.\u0027)))) {\n    if (*local_20[0] !\u003d \u0027_\u0027) {\n      return 1;\n    }\n    if (local_20[0][1] !\u003d \u0027_\u0027) {\n      return 1;\n    }\n    if (local_20[0][2] !\u003d \u0027o\u0027) {\n      return 1;\n    }\n    if (local_20[0][3] !\u003d \u0027p\u0027) {\n      return 1;\n    }\n    local_20[0] \u003d local_20[0] + 4;\n  }\n  else {\n    local_20[0] \u003d local_20[0] + 5;\n  }\n  cVar1 \u003d stab_demangle_type_lto_priv_0(param_1,local_20,0);\n  if (cVar1 !\u003d \u0027\\0\u0027) {\n    return 1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_stab_type"
      ],
      "called": [
        "stab_demangle_type.lto_priv.0",
        "startswith.lto_priv.0.lto_priv.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "is_dwo_section.constprop.0": {
      "entrypoint": "0x00113ede",
      "current_name": "is_dwo_section.constprop.0",
      "code": "\nundefined8 is_dwo_section_constprop_0(char **param_1)\n\n{\n  char *__s;\n  size_t sVar1;\n  undefined8 uVar2;\n  \n  if (param_1 \u003d\u003d (char **)0x0) {\n    return 0;\n  }\n  __s \u003d *param_1;\n  if (__s !\u003d (char *)0x0) {\n    sVar1 \u003d strlen(__s);\n    if (4 \u003c (int)sVar1) {\n      uVar2 \u003d startswith_lto_priv_0_lto_priv_0(__s + (long)(int)sVar1 + -4,\u0026DAT_0012142b);\n      return uVar2;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010829e",
        "FUN_001082b3"
      ],
      "called": [
        "strlen",
        "startswith.lto_priv.0.lto_priv.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "create_symbol_htab": {
      "entrypoint": "0x00113f20",
      "current_name": "create_symbol_htab",
      "code": "\nvoid create_symbol_htab(void)\n\n{\n  htab_create_alloc(0x10,htab_hash_string,htab_eq_string,0,xcalloc,free);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "htab_create_alloc",
        "xcalloc",
        "htab_eq_string",
        "htab_hash_string",
        "free"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "get_file_size": {
      "entrypoint": "0x00113f50",
      "current_name": "get_file_size",
      "code": "\nlong get_file_size(char *param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  stat sStack_a8;\n  \n  if (param_1 !\u003d (char *)0x0) {\n    iVar1 \u003d stat(param_1,\u0026sStack_a8);\n    if (iVar1 \u003c 0) {\n      piVar2 \u003d __errno_location();\n      if (*piVar2 \u003d\u003d 2) {\n        uVar3 \u003d dcgettext(0,\"\\\u0027%s\\\u0027: No such file\",5);\n        non_fatal(uVar3,param_1);\n      }\n      else {\n        pcVar4 \u003d strerror(*piVar2);\n        uVar3 \u003d dcgettext(0,\"Warning: could not locate \\\u0027%s\\\u0027.  reason: %s\",5);\n        non_fatal(uVar3,param_1,pcVar4);\n      }\n    }\n    else if ((sStack_a8.st_mode \u0026 0xf000) \u003d\u003d 0x4000) {\n      uVar3 \u003d dcgettext(0,\"Warning: \\\u0027%s\\\u0027 is a directory\",5);\n      non_fatal(uVar3,param_1);\n    }\n    else if ((sStack_a8.st_mode \u0026 0xf000) \u003d\u003d 0x8000) {\n      if (-1 \u003c sStack_a8.st_size) {\n        return sStack_a8.st_size;\n      }\n      uVar3 \u003d dcgettext(0,\"Warning: \\\u0027%s\\\u0027 has negative size, probably it is too large\",5);\n      non_fatal(uVar3,param_1);\n    }\n    else {\n      uVar3 \u003d dcgettext(0,\"Warning: \\\u0027%s\\\u0027 is not an ordinary file\",5);\n      non_fatal(uVar3,param_1);\n    }\n  }\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "main",
        "copy_file",
        "add_specific_symbols"
      ],
      "called": [
        "non_fatal",
        "dcgettext",
        "stat",
        "get_file_size.cold"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "startswith.lto_priv.0.lto_priv.0": {
      "entrypoint": "0x00113fb0",
      "current_name": "startswith.lto_priv.0.lto_priv.0",
      "code": "\nundefined  [16] startswith_lto_priv_0_lto_priv_0(char *param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 in_RAX;\n  size_t __n;\n  undefined4 extraout_var;\n  undefined auVar2 [16];\n  \n  __n \u003d strlen(param_2);\n  iVar1 \u003d strncmp(param_1,param_2,__n);\n  auVar2._1_7_ \u003d (undefined7)(CONCAT44(extraout_var,iVar1) \u003e\u003e 8);\n  auVar2[0] \u003d iVar1 \u003d\u003d 0;\n  auVar2._8_8_ \u003d in_RAX;\n  return auVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107880",
        "convert_efi_target",
        "handle_remove_section_option",
        "FUN_0010554f",
        "skip_section",
        "main",
        "parse_stab_type",
        "stab_demangle_function_name.constprop.0",
        "is_dwo_section.constprop.0"
      ],
      "called": [
        "strlen",
        "strncmp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "parse_flags": {
      "entrypoint": "0x00113fe0",
      "current_name": "parse_flags",
      "code": "\nundefined  [16] parse_flags(char *param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  char *pcVar4;\n  size_t sVar5;\n  int iVar6;\n  uint uVar7;\n  undefined auVar8 [16];\n  \n  uVar7 \u003d 0;\n  do {\n    pcVar3 \u003d strchr(param_1,0x2c);\n    if (pcVar3 \u003d\u003d (char *)0x0) {\n      sVar5 \u003d strlen(param_1);\n      iVar6 \u003d (int)sVar5;\n      pcVar4 \u003d (char *)0x0;\n    }\n    else {\n      pcVar4 \u003d pcVar3 + 1;\n      iVar6 \u003d (int)pcVar3 - (int)param_1;\n    }\n    sVar5 \u003d (size_t)iVar6;\n    iVar1 \u003d strncasecmp(\"alloc\",param_1,sVar5);\n    if (iVar1 \u003d\u003d 0) {\n      uVar7 \u003d uVar7 | 1;\n    }\n    else {\n      iVar1 \u003d strncasecmp(\"load\",param_1,sVar5);\n      if (iVar1 \u003d\u003d 0) {\n        uVar7 \u003d uVar7 | 2;\n      }\n      else {\n        iVar1 \u003d strncasecmp(\"noload\",param_1,sVar5);\n        if (iVar1 \u003d\u003d 0) {\n          uVar7 \u003d uVar7 | 0x200;\n        }\n        else {\n          iVar1 \u003d strncasecmp(\"readonly\",param_1,sVar5);\n          if (iVar1 \u003d\u003d 0) {\n            uVar7 \u003d uVar7 | 8;\n          }\n          else {\n            iVar1 \u003d strncasecmp(\"debug\",param_1,sVar5);\n            if (iVar1 \u003d\u003d 0) {\n              uVar7 \u003d uVar7 | 0x2000;\n            }\n            else {\n              iVar1 \u003d strncasecmp(\"code\",param_1,sVar5);\n              if (iVar1 \u003d\u003d 0) {\n                uVar7 \u003d uVar7 | 0x10;\n              }\n              else {\n                iVar1 \u003d strncasecmp(\"data\",param_1,sVar5);\n                if (iVar1 \u003d\u003d 0) {\n                  uVar7 \u003d uVar7 | 0x20;\n                }\n                else {\n                  iVar1 \u003d strncasecmp(\"rom\",param_1,sVar5);\n                  if (iVar1 \u003d\u003d 0) {\n                    uVar7 \u003d uVar7 | 0x40;\n                  }\n                  else {\n                    iVar1 \u003d strncasecmp(\"exclude\",param_1,sVar5);\n                    if (iVar1 \u003d\u003d 0) {\n                      uVar7 \u003d uVar7 | 0x8000;\n                    }\n                    else {\n                      iVar1 \u003d strncasecmp(\"share\",param_1,sVar5);\n                      if (iVar1 \u003d\u003d 0) {\n                        uVar7 \u003d uVar7 | 0x8000000;\n                      }\n                      else {\n                        iVar1 \u003d strncasecmp(\"contents\",param_1,sVar5);\n                        if (iVar1 \u003d\u003d 0) {\n                          uVar7 \u003d uVar7 | 0x100;\n                        }\n                        else {\n                          iVar1 \u003d strncasecmp(\"merge\",param_1,sVar5);\n                          if (iVar1 \u003d\u003d 0) {\n                            uVar7 \u003d uVar7 | 0x800000;\n                          }\n                          else {\n                            iVar1 \u003d strncasecmp(\"strings\",param_1,sVar5);\n                            if (iVar1 !\u003d 0) {\n                              pcVar3 \u003d (char *)xmalloc((long)(iVar6 + 1));\n                              strncpy(pcVar3,param_1,sVar5);\n                              pcVar3[sVar5] \u003d \u0027\\0\u0027;\n                              uVar2 \u003d dcgettext(0,\"unrecognized section flag `%s\\\u0027\",5);\n                              non_fatal(uVar2,pcVar3);\n                              uVar2 \u003d dcgettext(0,\"supported flags: %s\",5);\n                    \n                              fatal(uVar2,\n                                    \"alloc, load, noload, readonly, debug, code, data, rom, exclude, share, contents, merge, strings\"\n                                   );\n                            }\n                            uVar7 \u003d uVar7 | 0x1000000;\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    param_1 \u003d pcVar4;\n  } while (pcVar4 !\u003d (char *)0x0);\n  auVar8._4_4_ \u003d 0;\n  auVar8._0_4_ \u003d uVar7;\n  auVar8._8_8_ \u003d param_4;\n  return auVar8;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "find_section_list": {
      "entrypoint": "0x00114190",
      "current_name": "find_section_list",
      "code": "\nlong ** find_section_list(long *param_1,char param_2,uint param_3)\n\n{\n  uint uVar1;\n  long *plVar2;\n  long **pplVar3;\n  int iVar4;\n  undefined8 uVar5;\n  long **pplVar6;\n  long **pplVar7;\n  long **pplVar8;\n  \n  pplVar7 \u003d change_sections;\n  if (change_sections \u003d\u003d (long **)0x0) {\n    if (param_2 \u003d\u003d \u0027\\0\u0027) {\n      return (long **)0x0;\n    }\n    goto LAB_001142a9;\n  }\n  if (param_2 \u003d\u003d \u0027\\0\u0027) {\n    if ((param_3 \u0026 *(uint *)((long)change_sections + 0x14)) \u003d\u003d 0) {\nLAB_001141e5:\n      pplVar6 \u003d (long **)*pplVar7;\n      if (pplVar6 \u003d\u003d (long **)0x0) {\n        return (long **)0x0;\n      }\n      pplVar7 \u003d (long **)0x0;\n    }\n    else {\n      plVar2 \u003d change_sections[1];\n      if (*(char *)plVar2 \u003d\u003d \u0027!\u0027) {\n        iVar4 \u003d fnmatch((char *)((long)plVar2 + 1),(char *)param_1,0);\n        pplVar6 \u003d pplVar7;\n        if (iVar4 \u003d\u003d 0) goto LAB_0011438e;\n        goto LAB_001141e5;\n      }\n      iVar4 \u003d fnmatch((char *)plVar2,(char *)param_1,0);\n      if (iVar4 !\u003d 0) goto LAB_001141e5;\n      pplVar6 \u003d (long **)*pplVar7;\n      if (pplVar6 \u003d\u003d (long **)0x0) goto LAB_00114245;\n    }\n    if ((param_3 \u0026 *(uint *)((long)pplVar6 + 0x14)) !\u003d 0) {\n      plVar2 \u003d pplVar6[1];\n      if (*(char *)plVar2 \u003d\u003d \u0027!\u0027) {\n        iVar4 \u003d fnmatch((char *)((long)plVar2 + 1),(char *)param_1,0);\n        if (iVar4 \u003d\u003d 0) {\nLAB_0011438e:\n          *(undefined *)(pplVar6 + 2) \u003d 1;\n          return (long **)0x0;\n        }\n      }\n      else {\n        iVar4 \u003d fnmatch((char *)plVar2,(char *)param_1,0);\n        if ((pplVar7 \u003d\u003d (long **)0x0) \u0026\u0026 (iVar4 \u003d\u003d 0)) {\n          pplVar8 \u003d (long **)*pplVar6;\n          pplVar7 \u003d pplVar6;\n          if (pplVar8 \u003d\u003d (long **)0x0) goto LAB_00114245;\n          goto LAB_00114288;\n        }\n      }\n    }\n    pplVar8 \u003d (long **)*pplVar6;\n    pplVar6 \u003d pplVar7;\n    if (pplVar8 !\u003d (long **)0x0) goto LAB_00114288;\n  }\n  else {\n    iVar4 \u003d strcmp((char *)change_sections[1],(char *)param_1);\n    if (iVar4 \u003d\u003d 0) {\nLAB_001143cd:\n      uVar1 \u003d *(uint *)((long)pplVar7 + 0x14);\n      if ((((uVar1 \u0026 1) !\u003d 0) \u0026\u0026 ((param_3 \u0026 2) !\u003d 0)) ||\n         (((param_3 \u0026 1) !\u003d 0 \u0026\u0026 ((uVar1 \u0026 2) !\u003d 0)))) {\n        uVar5 \u003d dcgettext(0,\"error: %s both copied and removed\",5);\n                    \n        fatal(uVar5,param_1);\n      }\n      if ((((uVar1 \u0026 8) !\u003d 0) \u0026\u0026 ((param_3 \u0026 0x10) !\u003d 0)) || ((param_3 \u0026 0x18) \u003d\u003d 0x18)) {\n        uVar5 \u003d dcgettext(0,\"error: %s both sets and alters VMA\",5);\n                    \n        fatal(uVar5,param_1);\n      }\n      if ((((uVar1 \u0026 0x20) \u003d\u003d 0) || ((param_3 \u0026 0x40) \u003d\u003d 0)) \u0026\u0026 ((param_3 \u0026 0x60) !\u003d 0x60)) {\n        *(uint *)((long)pplVar7 + 0x14) \u003d uVar1 | param_3;\n        return pplVar7;\n      }\n      uVar5 \u003d dcgettext(0,\"error: %s both sets and alters LMA\",5);\n                    \n      fatal(uVar5,param_1);\n    }\n    pplVar7 \u003d (long **)*pplVar7;\n    if (pplVar7 \u003d\u003d (long **)0x0) goto LAB_001142a9;\n    iVar4 \u003d strcmp((char *)pplVar7[1],(char *)param_1);\n    if (iVar4 \u003d\u003d 0) goto LAB_001143cd;\n    pplVar8 \u003d (long **)*pplVar7;\n    pplVar6 \u003d (long **)0x0;\n    if (pplVar8 \u003d\u003d (long **)0x0) goto LAB_001142a9;\nLAB_00114288:\n    do {\n      pplVar7 \u003d pplVar6;\n      if (param_2 \u003d\u003d \u0027\\0\u0027) {\n        while (pplVar6 \u003d pplVar8, pplVar3 \u003d pplVar7, pplVar8 \u003d pplVar6,\n              (param_3 \u0026 *(uint *)((long)pplVar6 + 0x14)) !\u003d 0) {\n          plVar2 \u003d pplVar6[1];\n          if (*(char *)plVar2 \u003d\u003d \u0027!\u0027) {\n            iVar4 \u003d fnmatch((char *)((long)plVar2 + 1),(char *)param_1,0);\n            if (iVar4 \u003d\u003d 0) goto LAB_0011438e;\n            pplVar8 \u003d (long **)*pplVar6;\n            if ((long **)*pplVar6 \u003d\u003d (long **)0x0) goto LAB_001142a1;\n          }\n          else {\n            iVar4 \u003d fnmatch((char *)plVar2,(char *)param_1,0);\n            if ((pplVar7 \u003d\u003d (long **)0x0) \u0026\u0026 (iVar4 \u003d\u003d 0)) {\n              pplVar7 \u003d pplVar6;\n              pplVar8 \u003d (long **)*pplVar6;\n              if ((long **)*pplVar6 \u003d\u003d (long **)0x0) goto LAB_00114245;\n            }\n            else {\n              pplVar8 \u003d (long **)*pplVar6;\n              if ((long **)*pplVar6 \u003d\u003d (long **)0x0) goto LAB_00114212;\n            }\n          }\n        }\n      }\n      else {\n        iVar4 \u003d strcmp((char *)pplVar8[1],(char *)param_1);\n        pplVar3 \u003d pplVar6;\n        pplVar7 \u003d pplVar8;\n        if (iVar4 \u003d\u003d 0) goto LAB_001143cd;\n      }\n      pplVar6 \u003d pplVar3;\n      pplVar8 \u003d (long **)*pplVar8;\n      pplVar7 \u003d pplVar6;\n    } while (pplVar8 !\u003d (long **)0x0);\nLAB_001142a1:\n    if (param_2 !\u003d \u0027\\0\u0027) {\nLAB_001142a9:\n      pplVar6 \u003d (long **)xmalloc(0x30);\n      *(undefined (*) [16])(pplVar6 + 3) \u003d (undefined  [16])0x0;\n      *(undefined *)(pplVar6 + 2) \u003d 0;\n      *(uint *)((long)pplVar6 + 0x14) \u003d param_3;\n      pplVar6[5] \u003d (long *)0x0;\n      pplVar7 \u003d pplVar6;\n      *pplVar6 \u003d (long *)change_sections;\n      change_sections \u003d pplVar7;\n      pplVar6[1] \u003d param_1;\n      return pplVar6;\n    }\n  }\nLAB_00114212:\n  if (pplVar7 \u003d\u003d (long **)0x0) {\n    return (long **)0x0;\n  }\nLAB_00114245:\n  *(undefined *)(pplVar7 + 2) \u003d 1;\n  return pplVar7;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_relocations_in_section",
        "FUN_00107880",
        "handle_remove_section_option",
        "is_strip_section_1.isra.0",
        "setup_section.cold",
        "copy_section",
        "main",
        "setup_section"
      ],
      "called": [
        "fatal",
        "dcgettext",
        "fnmatch",
        "strcmp",
        "find_section_list.cold",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "add_specific_symbols": {
      "entrypoint": "0x00114460",
      "current_name": "add_specific_symbols",
      "code": "\nvoid add_specific_symbols(char *param_1,undefined8 param_2,byte **param_3)\n\n{\n  int iVar1;\n  int *piVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  size_t __n;\n  byte *__ptr;\n  FILE *__stream;\n  size_t sVar5;\n  byte **ppbVar6;\n  byte *pbVar7;\n  byte bVar8;\n  byte *pbVar9;\n  byte *pbVar10;\n  byte *pbVar11;\n  byte *pbVar12;\n  \n  __n \u003d get_file_size();\n  if (__n \u003d\u003d 0) {\n    status \u003d 1;\n  }\n  else {\n    __ptr \u003d (byte *)xmalloc(__n + 2);\n    __stream \u003d fopen(param_1,\"r\");\n    if (__stream \u003d\u003d (FILE *)0x0) {\n      piVar2 \u003d __errno_location();\n      pcVar3 \u003d strerror(*piVar2);\n      uVar4 \u003d dcgettext(0,\"cannot open \\\u0027%s\\\u0027: %s\",5);\n                    \n      fatal(uVar4,param_1,pcVar3);\n    }\n    sVar5 \u003d fread(__ptr,1,__n,__stream);\n    if ((sVar5 \u003d\u003d 0) || (iVar1 \u003d ferror(__stream), iVar1 !\u003d 0)) {\n      uVar4 \u003d dcgettext(0,\"%s: fread failed\",5);\n                    \n      fatal(uVar4,param_1);\n    }\n    iVar1 \u003d 1;\n    fclose(__stream);\n    *(undefined2 *)(__ptr + __n) \u003d 10;\n    bVar8 \u003d *__ptr;\n    pbVar12 \u003d __ptr;\n    while (pbVar10 \u003d pbVar12, bVar8 !\u003d 0) {\n      for (; bVar8 \u003d *pbVar10, pbVar11 \u003d pbVar10, bVar8 !\u003d 10; pbVar10 \u003d pbVar10 + 1) {\n        if ((char)bVar8 \u003c \u0027\\v\u0027) {\n          if (bVar8 \u003d\u003d 0) {\n            pbVar9 \u003d pbVar10 + 1;\n            goto LAB_00114553;\n          }\n        }\n        else {\n          if (bVar8 \u003d\u003d 0xd) {\n            *pbVar10 \u003d 0;\n            pbVar9 \u003d pbVar10 + 1;\n            if (pbVar10[1] \u003d\u003d 10) {\n              pbVar9 \u003d pbVar10 + 2;\n              pbVar11 \u003d pbVar10 + 1;\n            }\n            goto LAB_00114553;\n          }\n          if (bVar8 \u003d\u003d 0x23) {\n            FUN_00104d1c();\n            return;\n          }\n        }\n      }\n      *pbVar10 \u003d 0;\n      if (pbVar10[1] \u003d\u003d 0xd) {\n        pbVar11 \u003d pbVar10 + 1;\n        pbVar9 \u003d pbVar10 + 2;\n      }\n      else {\n        pbVar9 \u003d pbVar10 + 1;\n      }\nLAB_00114553:\n      bVar8 \u003d *pbVar12;\n      while ((bVar8 \u003d\u003d 0x20 || (pbVar10 \u003d pbVar12, bVar8 \u003d\u003d 9))) {\n        pbVar10 \u003d pbVar12 + 1;\n        pbVar12 \u003d pbVar12 + 1;\n        bVar8 \u003d *pbVar10;\n      }\n      do {\n        if ((bVar8 \u003d\u003d 10) || (bVar8 \u003d\u003d 0xd)) goto LAB_00114676;\n        if (bVar8 \u003d\u003d 0) goto LAB_00114599;\n        bVar8 \u003d pbVar10[1];\n        pbVar10 \u003d pbVar10 + 1;\n      } while ((bVar8 !\u003d 0x20) \u0026\u0026 (bVar8 !\u003d 9));\n      if ((char)bVar8 \u003c \u0027\\x0e\u0027) {\nLAB_00114676:\n        if ((-0x2402L \u003e\u003e (bVar8 \u0026 0x3f) \u0026 1U) !\u003d 0) goto LAB_001145e6;\n      }\n      else {\nLAB_001145e6:\n        bVar8 \u003d pbVar10[1];\n        if ((((((bVar8 \u003d\u003d 9) || (bVar8 \u003d\u003d 0x20)) \u0026\u0026\n              ((bVar8 \u003d pbVar10[2], bVar8 \u003d\u003d 9 || (bVar8 \u003d\u003d 0x20)))) \u0026\u0026\n             ((bVar8 \u003d pbVar10[3], bVar8 \u003d\u003d 9 || (bVar8 \u003d\u003d 0x20)))) \u0026\u0026\n            ((bVar8 \u003d pbVar10[4], bVar8 \u003d\u003d 9 || (bVar8 \u003d\u003d 0x20)))) \u0026\u0026\n           ((bVar8 \u003d pbVar10[5], bVar8 \u003d\u003d 9 || (bVar8 \u003d\u003d 0x20)))) {\n          bVar8 \u003d pbVar10[6];\n          pbVar7 \u003d pbVar10 + 6;\n          if ((bVar8 \u003d\u003d 9) || (bVar8 \u003d\u003d 0x20)) {\n            do {\n              do {\n                bVar8 \u003d pbVar7[1];\n                pbVar7 \u003d pbVar7 + 1;\n              } while (bVar8 \u003d\u003d 0x20);\n            } while (bVar8 \u003d\u003d 9);\n          }\n        }\n        if ((0xd \u003c bVar8) || ((-0x2402L \u003e\u003e (bVar8 \u0026 0x3f) \u0026 1U) !\u003d 0)) {\n          uVar4 \u003d dcgettext(0,\"%s:%d: Ignoring rubbish found on this line\",5);\n          non_fatal(uVar4,param_1,iVar1);\n        }\n      }\nLAB_00114599:\n      *pbVar10 \u003d 0;\n      if (pbVar12 \u003c pbVar10) {\n        ppbVar6 \u003d (byte **)htab_find_slot(param_2,pbVar12,1);\n        *ppbVar6 \u003d pbVar12;\n      }\n      iVar1 \u003d iVar1 + 1;\n      pbVar12 \u003d pbVar9;\n      bVar8 \u003d pbVar11[1];\n    }\n    *param_3 \u003d __ptr;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "fclose",
        "strerror",
        "fread",
        "dcgettext",
        "fatal",
        "get_file_size",
        "__errno_location",
        "ferror",
        "fopen",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "copy_file": {
      "entrypoint": "0x00114690",
      "current_name": "copy_file",
      "code": "\nvoid copy_file(undefined8 param_1,undefined8 param_2,int param_3,undefined8 param_4,\n              undefined8 param_5,long param_6,undefined8 param_7)\n\n{\n  byte bVar1;\n  char cVar2;\n  char cVar3;\n  int iVar4;\n  int iVar5;\n  char **ppcVar6;\n  void *pvVar7;\n  long lVar8;\n  undefined8 *puVar9;\n  int *piVar10;\n  undefined8 uVar11;\n  undefined8 uVar12;\n  long lVar13;\n  undefined8 *puVar14;\n  char *pcVar15;\n  char **ppcVar16;\n  char *pcVar17;\n  char *pcVar18;\n  undefined8 *__ptr;\n  char **ppcVar19;\n  code *pcVar20;\n  long lVar21;\n  uint uVar22;\n  char *pcVar23;\n  stat *psVar24;\n  bool bVar25;\n  byte bVar26;\n  undefined8 *local_1a0;\n  long *local_198;\n  stat local_158;\n  void *local_c8 [3];\n  uint uStack_b0;\n  long lStack_98;\n  \n  bVar26 \u003d 0;\n  lVar13 \u003d get_file_size();\n  if (lVar13 \u003c 1) {\n    if (lVar13 \u003d\u003d 0) {\n      uVar12 \u003d dcgettext(0,\"error: the input file \\\u0027%s\\\u0027 is empty\",5);\n      non_fatal(uVar12,param_1);\n    }\n    status \u003d 1;\n    return;\n  }\n  puVar14 \u003d (undefined8 *)bfd_openr(param_1,param_5);\n  if ((puVar14 \u003d\u003d (undefined8 *)0x0) || (iVar5 \u003d bfd_stat(puVar14,param_4), iVar5 !\u003d 0)) {\n    bfd_nonfatal_message(param_1,0,0,0);\n    status \u003d 1;\n    return;\n  }\n  switch(do_debug_sections) {\n  case 1:\n  case 3:\n  case 9:\n    *(uint *)((long)puVar14 + 0x44) \u003d *(uint *)((long)puVar14 + 0x44) | 0x24000;\n    break;\n  case 5:\n    *(uint *)((long)puVar14 + 0x44) \u003d *(uint *)((long)puVar14 + 0x44) | 0x4000;\n    break;\n  case 0x11:\n    *(uint *)((long)puVar14 + 0x44) \u003d *(uint *)((long)puVar14 + 0x44) | 0x424000;\n    break;\n  case 0x20:\n    *(uint *)((long)puVar14 + 0x44) \u003d *(uint *)((long)puVar14 + 0x44) | 0x8000;\n  }\n  if (do_elf_stt_common \u003d\u003d 1) {\n    *(uint *)((long)puVar14 + 0x44) \u003d *(uint *)((long)puVar14 + 0x44) | 0xc0000;\n  }\n  else if (do_elf_stt_common \u003d\u003d 2) {\n    *(uint *)((long)puVar14 + 0x44) \u003d *(uint *)((long)puVar14 + 0x44) | 0x40000;\n  }\n  cVar2 \u003d bfd_check_format(puVar14,2);\n  if (cVar2 !\u003d \u0027\\0\u0027) {\n    if (param_6 \u003d\u003d 0) {\n      cVar2 \u003d \u0027\\0\u0027;\n      param_6 \u003d *(long *)puVar14[1];\n    }\n    if (param_3 \u003c 0) {\n      local_1a0 \u003d (undefined8 *)bfd_openw(param_2,param_6);\n    }\n    else {\n      local_1a0 \u003d (undefined8 *)bfd_fdopenw(param_2,param_6,param_3);\n    }\n    if (local_1a0 !\u003d (undefined8 *)0x0) {\n      if (gnu_debuglink_filename !\u003d 0) {\n        uVar12 \u003d *puVar14;\n        uVar11 \u003d dcgettext(0,\"--add-gnu-debuglink ignored for archive %s\",5);\n        non_fatal(uVar11,uVar12);\n        gnu_debuglink_filename \u003d 0;\n      }\n      set_long_section_mode(local_1a0,puVar14,long_section_names);\n      local_198 \u003d local_1a0 + 0x1f;\n      if ((*(byte *)((long)puVar14 + 0x49) \u0026 0x10) !\u003d 0) {\n        status \u003d 1;\n        bfd_set_error(5);\n        uVar12 \u003d dcgettext(0,\"sorry: copying thin archives is not currently supported\",5);\n        bfd_nonfatal_message(0,puVar14,0,uVar12);\n        return;\n      }\n      pcVar15 \u003d (char *)make_tempdir(*local_1a0);\n      if (pcVar15 \u003d\u003d (char *)0x0) {\n        piVar10 \u003d __errno_location();\n        pcVar15 \u003d strerror(*piVar10);\n        uVar12 \u003d dcgettext(0,\"cannot create tempdir for archive copying (error: %s)\",5);\n                    \n        fatal(uVar12,pcVar15);\n      }\n      if (strip_symbols \u003d\u003d 7) {\n        bVar1 \u003d *(byte *)((long)puVar14 + 0x49);\n        uVar22 \u003d 0;\n      }\n      else {\n        bVar1 \u003d *(byte *)((long)puVar14 + 0x49);\n        uVar22 \u003d bVar1 \u003e\u003e 3 \u0026 1;\n      }\n      bVar25 \u003d deterministic !\u003d 0;\n      *(byte *)((long)local_1a0 + 0x49) \u003d\n           bVar1 \u0026 0x10 | (byte)(uVar22 \u003c\u003c 3) | *(byte *)((long)local_1a0 + 0x49) \u0026 0xe7;\n      if (bVar25) {\n        *(uint *)((long)local_1a0 + 0x44) \u003d *(uint *)((long)local_1a0 + 0x44) | 0x2000;\n      }\n      __ptr \u003d (undefined8 *)0x0;\n      ppcVar16 \u003d (char **)bfd_openr_next_archived_file(puVar14,0);\n      cVar3 \u003d bfd_set_format(local_1a0,*(byte *)(puVar14 + 9) \u0026 7);\n      if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n        status \u003d 1;\n        bfd_nonfatal_message(0,local_1a0,0,0);\n        FUN_00114b84();\n        return;\n      }\n      while ((status \u003d\u003d 0 \u0026\u0026 (ppcVar16 !\u003d (char **)0x0))) {\n        pcVar18 \u003d *ppcVar16;\n        pcVar17 \u003d pcVar18;\n        if (*pcVar18 \u003d\u003d \u0027/\u0027) {\nLAB_0010527d:\n          uVar12 \u003d dcgettext(0,\"illegal pathname found in archive member: %s\",5);\n          non_fatal(uVar12,pcVar18);\nLAB_00104e93:\n          status \u003d 1;\n          goto LAB_00114b4b;\n        }\n        while (*pcVar17 !\u003d \u0027\\0\u0027) {\n          pcVar23 \u003d pcVar17;\n          if ((*pcVar17 \u003d\u003d \u0027.\u0027) \u0026\u0026 (pcVar23 \u003d pcVar17 + 1, pcVar17[1] \u003d\u003d \u0027.\u0027)) {\n            pcVar23 \u003d pcVar17 + 2;\n            if ((pcVar17[2] \u003d\u003d \u0027\\0\u0027) || (pcVar17[2] \u003d\u003d \u0027/\u0027)) goto LAB_0010527d;\n          }\n          for (; (*pcVar23 !\u003d \u0027\\0\u0027 \u0026\u0026 (*pcVar23 !\u003d \u0027/\u0027)); pcVar23 \u003d pcVar23 + 1) {\n          }\n          pcVar17 \u003d pcVar23;\n          if (*pcVar23 \u003d\u003d \u0027/\u0027) {\n            FUN_001052a2();\n            return;\n          }\n        }\n        pcVar18 \u003d (char *)concat(pcVar15,\u0026DAT_0011b47d);\n        iVar5 \u003d stat(pcVar18,\u0026local_158);\n        puVar9 \u003d __ptr;\n        if (-1 \u003c iVar5) {\n          lVar13 \u003d make_tempdir(pcVar18);\n          free(pcVar18);\n          if (lVar13 \u003d\u003d 0) {\n            piVar10 \u003d __errno_location();\n            pcVar18 \u003d strerror(*piVar10);\n            uVar12 \u003d dcgettext(0,\"cannot create tempdir for archive copying (error: %s)\",5);\n            non_fatal(uVar12,pcVar18);\n            goto LAB_00104e93;\n          }\n          puVar9 \u003d (undefined8 *)xmalloc(0x18);\n          pcVar18 \u003d *ppcVar16;\n          *puVar9 \u003d __ptr;\n          puVar9[2] \u003d 0;\n          puVar9[1] \u003d lVar13;\n          pcVar18 \u003d (char *)concat(lVar13,\u0026DAT_0011b47d,pcVar18);\n        }\n        iVar5 \u003d 0;\n        if (preserve_dates !\u003d \u0027\\0\u0027) {\n          psVar24 \u003d \u0026local_158;\n          for (lVar13 \u003d 0x24; lVar13 !\u003d 0; lVar13 \u003d lVar13 + -1) {\n            *(undefined4 *)\u0026psVar24-\u003est_dev \u003d 0;\n            psVar24 \u003d (stat *)((long)psVar24 + (ulong)bVar26 * -8 + 4);\n          }\n          ppcVar19 \u003d (char **)ppcVar16[0x1d];\n          if ((char **)ppcVar16[0x1d] \u003d\u003d (char **)0x0) {\n            ppcVar19 \u003d ppcVar16;\n          }\n          iVar5 \u003d (**(code **)(ppcVar19[1] + 0x1e8))(ppcVar16,\u0026local_158);\n          if (iVar5 !\u003d 0) {\n            pcVar17 \u003d *ppcVar16;\n            uVar12 \u003d dcgettext(0,\"internal stat error on %s\",5);\n            non_fatal(uVar12,pcVar17);\n          }\n        }\n        __ptr \u003d (undefined8 *)xmalloc(0x18);\n        __ptr[1] \u003d pcVar18;\n        *__ptr \u003d puVar9;\n        __ptr[2] \u003d 0;\n        cVar3 \u003d bfd_check_format(ppcVar16,1);\n        if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n          uVar12 \u003d dcgettext(0,\"Unable to recognise the format of file\",5);\n          bfd_nonfatal_message(0,ppcVar16,0,uVar12);\n          ppcVar19 \u003d (char **)bfd_openw(pcVar18,param_6);\n          if (ppcVar19 \u003d\u003d (char **)0x0) {\nLAB_00104e80:\n            bfd_nonfatal_message(pcVar18,0,0,0);\n            goto LAB_00104e93;\n          }\nLAB_00104d75:\n          ppcVar6 \u003d (char **)ppcVar16[0x1d];\n          if ((char **)ppcVar16[0x1d] \u003d\u003d (char **)0x0) {\n            ppcVar6 \u003d ppcVar16;\n          }\n          iVar4 \u003d (**(code **)(ppcVar6[1] + 0x1e8))(ppcVar16);\n          lVar13 \u003d lStack_98;\n          if (iVar4 \u003d\u003d 0) {\n            if (lStack_98 \u003c 0) {\n              bfd_get_archive_filename(ppcVar16);\n              uVar12 \u003d dcgettext(0,\"stat returns negative size for `%s\\\u0027\",5);\n              non_fatal(uVar12);\n            }\n            else {\n              iVar4 \u003d bfd_seek(ppcVar16,0,0);\n              if (iVar4 \u003d\u003d 0) {\n                if (verbose !\u003d \u0027\\0\u0027) {\n                  pcVar17 \u003d *ppcVar19;\n                  uVar12 \u003d bfd_get_archive_filename(ppcVar16);\n                  pcVar23 \u003d (char *)dcgettext(0,\"copy from `%s\\\u0027 [unknown] to `%s\\\u0027 [unknown]\\n\",5);\n                  printf(pcVar23,uVar12,pcVar17);\n                }\n                pvVar7 \u003d (void *)xmalloc(0x2000);\n                for (; lVar13 !\u003d 0; lVar13 \u003d lVar13 - lVar21) {\n                  lVar21 \u003d 0x2000;\n                  if (lVar13 \u003c 0x2001) {\n                    lVar21 \u003d lVar13;\n                  }\n                  lVar8 \u003d bfd_bread(pvVar7,lVar21,ppcVar16);\n                  ppcVar6 \u003d ppcVar16;\n                  if ((lVar21 !\u003d lVar8) ||\n                     (lVar8 \u003d bfd_bwrite(pvVar7,lVar21,ppcVar19), ppcVar6 \u003d ppcVar19,\n                     lVar21 !\u003d lVar8)) {\n                    bfd_nonfatal_message(0,ppcVar6,0,0);\n                    free(pvVar7);\n                    goto LAB_00104f00;\n                  }\n                }\n                chmod(*ppcVar19,uStack_b0 | 0x100);\n                free(pvVar7);\n                cVar3 \u003d bfd_close_all_done(ppcVar19);\n                if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n                  bfd_nonfatal_message(pcVar18,0,0,0);\n                  status \u003d 1;\n                }\n                goto LAB_00114a86;\n              }\n              uVar12 \u003d bfd_get_archive_filename(ppcVar16);\n              bfd_nonfatal(uVar12);\n            }\n          }\n          else {\n            bfd_nonfatal_message(0,ppcVar16,0,0);\n          }\nLAB_00104f00:\n          cVar3 \u003d bfd_close_all_done(ppcVar19);\n          if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n            bfd_nonfatal_message(pcVar18,0,0,0);\n          }\nLAB_00104ec9:\n          unlink(pcVar18);\n          status \u003d 1;\n        }\n        else {\n          if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n            ppcVar19 \u003d (char **)bfd_openw(pcVar18,*(undefined8 *)ppcVar16[1]);\n          }\n          else {\n            ppcVar19 \u003d (char **)bfd_openw(pcVar18,param_6);\n          }\n          if (ppcVar19 \u003d\u003d (char **)0x0) goto LAB_00104e80;\n          cVar3 \u003d copy_object(ppcVar16,ppcVar19,param_7);\n          if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n            iVar4 \u003d bfd_get_arch(ppcVar16);\n            if (iVar4 \u003d\u003d 0) goto LAB_00104d75;\n            cVar3 \u003d bfd_close_all_done(ppcVar19);\n            if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n              bfd_nonfatal_message(pcVar18,0,0,0);\n            }\n            goto LAB_00104ec9;\n          }\n          cVar3 \u003d bfd_close(ppcVar19);\n          if (cVar3 \u003d\u003d \u0027\\0\u0027) {\n            bfd_nonfatal_message(pcVar18,0,0,0);\n            status \u003d 1;\n          }\nLAB_00114a86:\n          if ((preserve_dates !\u003d \u0027\\0\u0027) \u0026\u0026 (iVar5 \u003d\u003d 0)) {\n            set_times(pcVar18,\u0026local_158);\n          }\n          lVar13 \u003d bfd_openr(pcVar18,param_6);\n          __ptr[2] \u003d lVar13;\n          *local_198 \u003d lVar13;\n          local_198 \u003d (long *)(lVar13 + 0xf0);\n          ppcVar19 \u003d (char **)bfd_openr_next_archived_file(puVar14);\n          bfd_close(ppcVar16);\n          ppcVar16 \u003d ppcVar19;\n        }\n      }\n      *local_198 \u003d 0;\n      pvVar7 \u003d (void *)xstrdup(*local_1a0);\n      if (status \u003d\u003d 0) {\n        pcVar20 \u003d bfd_close;\n      }\n      else {\n        pcVar20 \u003d bfd_close_all_done;\n      }\n      cVar2 \u003d (*pcVar20)(local_1a0);\n      if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n        status \u003d 1;\n        bfd_nonfatal_message(pvVar7,0,0,0);\n      }\n      free(pvVar7);\n      pvVar7 \u003d (void *)xstrdup(*puVar14);\n      cVar2 \u003d bfd_close(puVar14);\n      if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n        status \u003d 1;\n        bfd_nonfatal_message(pvVar7,0,0,0);\n      }\n      free(pvVar7);\nLAB_00114b4b:\n      while (__ptr !\u003d (undefined8 *)0x0) {\n        if (__ptr[2] \u003d\u003d 0) {\n          rmdir((char *)__ptr[1]);\n        }\n        else {\n          bfd_close();\n          unlink((char *)__ptr[1]);\n        }\n        free((void *)__ptr[1]);\n        puVar14 \u003d (undefined8 *)*__ptr;\n        free(__ptr);\n        __ptr \u003d puVar14;\n      }\n      rmdir(pcVar15);\n      free(pcVar15);\n      return;\n    }\nLAB_00105231:\n    close(param_3);\n    bfd_nonfatal_message(param_2,0,0,0);\n    status \u003d 1;\n    return;\n  }\n  cVar2 \u003d bfd_check_format_matches(puVar14,1,local_c8);\n  if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n    iVar5 \u003d bfd_get_error();\n    cVar2 \u003d bfd_check_format_matches(puVar14,3,\u0026local_158);\n    if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n      iVar4 \u003d bfd_get_error();\n      if (iVar5 !\u003d iVar4) {\n        bfd_set_error(iVar5);\n      }\n      bfd_nonfatal_message(param_1,0,0,0);\n      if (iVar5 \u003d\u003d 0xd) {\n        list_matching_formats(local_c8[0]);\n      }\n      if (iVar4 !\u003d 0xd) {\n        status \u003d 1;\n        return;\n      }\n      list_matching_formats(local_158.st_dev);\n      status \u003d 1;\n      return;\n    }\n    if (iVar5 \u003d\u003d 0xd) {\n      free(local_c8[0]);\n    }\n  }\n  if (param_6 \u003d\u003d 0) {\n    param_6 \u003d *(long *)puVar14[1];\n  }\n  if (param_3 \u003c 0) {\n    lVar13 \u003d bfd_openw(param_2,param_6);\n  }\n  else {\n    lVar13 \u003d bfd_fdopenw(param_2,param_6,param_3);\n  }\n  if (lVar13 \u003d\u003d 0) goto LAB_00105231;\n  set_long_section_mode(lVar13,puVar14,long_section_names);\n  cVar2 \u003d copy_object(puVar14,lVar13,param_7);\n  if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n    status \u003d 1;\n  }\n  else if (status \u003d\u003d 0) {\n    cVar2 \u003d bfd_close(lVar13);\n    goto LAB_001147d5;\n  }\n  cVar2 \u003d bfd_close_all_done(lVar13);\nLAB_001147d5:\n  if (cVar2 !\u003d \u0027\\x01\u0027) {\n    status \u003d 1;\n    bfd_nonfatal_message(param_2,0,0,0);\n    return;\n  }\n  cVar2 \u003d bfd_close(puVar14);\n  if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n    status \u003d 1;\n    bfd_nonfatal_message(param_1,0,0,0);\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "bfd_openr",
        "free",
        "strerror",
        "bfd_check_format",
        "__errno_location",
        "bfd_set_error",
        "dcgettext",
        "bfd_check_format_matches",
        "non_fatal",
        "copy_file.cold",
        "get_file_size",
        "bfd_close",
        "set_long_section_mode",
        "bfd_fdopenw",
        "make_tempdir",
        "list_matching_formats",
        "bfd_openw",
        "bfd_openr_next_archived_file",
        "fatal",
        "bfd_set_format",
        "bfd_close_all_done",
        "bfd_get_error",
        "bfd_stat",
        "close",
        "copy_object",
        "bfd_nonfatal_message"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00114b84": {
      "entrypoint": "0x00114b84",
      "current_name": "FUN_00114b84",
      "code": "\nvoid FUN_00114b84(void)\n\n{\n  char *param_9;\n  \n  rmdir(param_9);\n  free(param_9);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_file.cold",
        "FUN_00104ea2"
      ],
      "called": [
        "free",
        "rmdir"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "handle_remove_section_option": {
      "entrypoint": "0x00114c20",
      "current_name": "handle_remove_section_option",
      "code": "\nvoid handle_remove_section_option(long param_1)\n\n{\n  char cVar1;\n  char *pcVar2;\n  \n  find_section_list(param_1,1,1);\n  cVar1 \u003d startswith_lto_priv_0_lto_priv_0(param_1,\u0026DAT_0011b499);\n  if (cVar1 !\u003d \u0027\\0\u0027) {\n    pcVar2 \u003d (char *)(param_1 + 5);\n    if (*(char *)(param_1 + 4) !\u003d \u0027a\u0027) {\n      pcVar2 \u003d (char *)(param_1 + 4);\n    }\n    if (*pcVar2 !\u003d \u0027\\0\u0027) {\n      find_section_list(pcVar2,1,0x100);\n    }\n  }\n  sections_removed \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "startswith.lto_priv.0.lto_priv.0",
        "find_section_list"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "init_section_add": {
      "entrypoint": "0x00114c80",
      "current_name": "init_section_add",
      "code": "\nundefined  [16]\ninit_section_add(char *param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  char *pcVar1;\n  undefined8 uVar2;\n  undefined auVar3 [16];\n  \n  pcVar1 \u003d strchr(param_1,0x3d);\n  if (pcVar1 !\u003d (char *)0x0) {\n    auVar3._0_8_ \u003d (undefined8 *)xmalloc(0x30);\n    uVar2 \u003d xstrndup(param_1,(long)pcVar1 - (long)param_1);\n    auVar3._0_8_[2] \u003d pcVar1 + 1;\n    auVar3._0_8_[1] \u003d uVar2;\n    auVar3._0_8_[4] \u003d 0;\n    auVar3._0_8_[3] \u003d 0;\n    *auVar3._0_8_ \u003d param_2;\n    auVar3._8_8_ \u003d param_4;\n    return auVar3;\n  }\n  uVar2 \u003d dcgettext(0,\"bad format for %s\",5);\n                    \n  fatal(uVar2,param_3);\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "strchr",
        "init_section_add.cold",
        "xstrndup",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "template_in_dir": {
      "entrypoint": "0x00114cf0",
      "current_name": "template_in_dir",
      "code": "\nvoid template_in_dir(char *param_1)\n\n{\n  char *pcVar1;\n  long lVar2;\n  long lVar3;\n  long lVar4;\n  char *pcVar5;\n  byte bVar6;\n  \n  bVar6 \u003d 0;\n  pcVar1 \u003d strrchr(param_1,0x2f);\n  if (pcVar1 \u003d\u003d (char *)0x0) {\n    pcVar1 \u003d (char *)xmalloc(9);\n    lVar3 \u003d 0;\n  }\n  else {\n    lVar4 \u003d (long)pcVar1 - (long)param_1;\n    pcVar1 \u003d (char *)xmalloc(lVar4 + 0xb);\n    lVar3 \u003d lVar4 + 1;\n    pcVar5 \u003d pcVar1;\n    for (lVar2 \u003d lVar4; lVar2 !\u003d 0; lVar2 \u003d lVar2 + -1) {\n      *pcVar5 \u003d *param_1;\n      param_1 \u003d param_1 + (ulong)bVar6 * -2 + 1;\n      pcVar5 \u003d pcVar5 + (ulong)bVar6 * -2 + 1;\n    }\n    pcVar1[lVar4] \u003d \u0027/\u0027;\n  }\n  *(undefined8 *)(pcVar1 + lVar3) \u003d 0x5858585858587473;\n  *(undefined *)((long)(pcVar1 + lVar3) + 8) \u003d 0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "make_tempdir",
        "main"
      ],
      "called": [
        "strrchr",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "set_long_section_mode": {
      "entrypoint": "0x00114d50",
      "current_name": "set_long_section_mode",
      "code": "\nvoid set_long_section_mode(long param_1,long param_2,uint param_3)\n\n{\n  if (*(int *)(*(long *)(param_1 + 8) + 8) !\u003d 2) {\n    return;\n  }\n  if ((param_3 \u003d\u003d 2) \u0026\u0026 (*(int *)(*(long *)(param_2 + 8) + 8) \u003d\u003d 2)) {\n    param_3 \u003d (uint)*(byte *)(*(long *)(*(long *)(param_2 + 8) + 0x380) + 0x71);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00105422. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (**(code **)(*(long *)(*(long *)(param_1 + 8) + 0x380) + 0x78))(param_1,param_3 !\u003d 0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_file"
      ],
      "called": [
        "set_long_section_mode.cold"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "section_add_load_file": {
      "entrypoint": "0x00114d60",
      "current_name": "section_add_load_file",
      "code": "\nvoid section_add_load_file(long param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  FILE *__stream;\n  undefined8 uVar5;\n  size_t sVar6;\n  long lVar7;\n  long lVar8;\n  \n  __stream \u003d fopen(*(char **)(param_1 + 0x10),\"r\");\n  if (__stream \u003d\u003d (FILE *)0x0) {\n    piVar2 \u003d __errno_location();\n    pcVar3 \u003d strerror(*piVar2);\n    uVar5 \u003d *(undefined8 *)(param_1 + 0x10);\n    uVar4 \u003d dcgettext(0,\"cannot open: %s: %s\",5);\n                    \n    fatal(uVar4,uVar5,pcVar3);\n  }\n  lVar8 \u003d 0x1000;\n  lVar7 \u003d 0;\n  uVar5 \u003d xmalloc(0x1000);\n  *(undefined8 *)(param_1 + 0x20) \u003d uVar5;\n  while( true ) {\n    iVar1 \u003d feof(__stream);\n    if (iVar1 !\u003d 0) {\n      *(long *)(param_1 + 0x18) \u003d lVar7;\n      fclose(__stream);\n      return;\n    }\n    if (lVar7 \u003d\u003d lVar8) {\n      lVar8 \u003d lVar7 * 2;\n      uVar5 \u003d xrealloc(*(undefined8 *)(param_1 + 0x20),lVar8);\n      *(undefined8 *)(param_1 + 0x20) \u003d uVar5;\n    }\n    sVar6 \u003d fread((void *)(*(long *)(param_1 + 0x20) + lVar7),1,lVar8 - lVar7,__stream);\n    iVar1 \u003d ferror(__stream);\n    if (iVar1 !\u003d 0) break;\n    lVar7 \u003d lVar7 + sVar6;\n  }\n  uVar5 \u003d *(undefined8 *)(param_1 + 0x10);\n  uVar4 \u003d dcgettext(0,\"%s: fread failed\",5);\n                    \n  fatal(uVar4,uVar5);\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "section_add_load_file.cold",
        "fopen",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00114dc7": {
      "entrypoint": "0x00114dc7",
      "current_name": "FUN_00114dc7",
      "code": "\nvoid FUN_00114dc7(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  size_t sVar4;\n  FILE *unaff_RBX;\n  long unaff_RBP;\n  long unaff_R12;\n  long unaff_R14;\n  \n  while( true ) {\n    sVar4 \u003d fread((void *)(*(long *)(unaff_RBP + 0x20) + unaff_R12),1,unaff_R14 - unaff_R12,\n                  unaff_RBX);\n    iVar1 \u003d ferror(unaff_RBX);\n    if (iVar1 !\u003d 0) {\n      uVar3 \u003d *(undefined8 *)(unaff_RBP + 0x10);\n      uVar2 \u003d dcgettext(0,\"%s: fread failed\",5);\n                    \n      fatal(uVar2,uVar3);\n    }\n    unaff_R12 \u003d unaff_R12 + sVar4;\n    iVar1 \u003d feof(unaff_RBX);\n    if (iVar1 !\u003d 0) break;\n    if (unaff_R12 \u003d\u003d unaff_R14) {\n      unaff_R14 \u003d unaff_R12 * 2;\n      uVar3 \u003d xrealloc(*(undefined8 *)(unaff_RBP + 0x20),unaff_R14);\n      *(undefined8 *)(unaff_RBP + 0x20) \u003d uVar3;\n    }\n  }\n  *(long *)(unaff_RBP + 0x18) \u003d unaff_R12;\n  fclose(unaff_RBX);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00114dc7"
      ],
      "called": [
        "fclose",
        "dcgettext",
        "fread",
        "fatal",
        "xrealloc",
        "FUN_00114dc7",
        "feof",
        "ferror"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "endian_string": {
      "entrypoint": "0x00114e00",
      "current_name": "endian_string",
      "code": "\nvoid endian_string(int param_1)\n\n{\n  if (param_1 \u003d\u003d 0) {\n    dcgettext(0,\"big endian\",5);\n    return;\n  }\n  if (param_1 \u003d\u003d 1) {\n    dcgettext(0,\"little endian\",5);\n    return;\n  }\n  dcgettext(0,\"endianness unknown\",5);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "do_display_target"
      ],
      "called": [
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "copy_object": {
      "entrypoint": "0x00114e50",
      "current_name": "copy_object",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong copy_object(undefined8 *param_1,long param_2,long param_3)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  undefined *puVar3;\n  long *plVar4;\n  code *pcVar5;\n  long *plVar6;\n  ulong uVar7;\n  ulong uVar8;\n  char *__s;\n  ushort uVar9;\n  char cVar10;\n  char cVar11;\n  int iVar12;\n  int iVar13;\n  undefined4 uVar14;\n  long *plVar15;\n  long lVar16;\n  undefined8 uVar17;\n  undefined8 uVar18;\n  size_t sVar19;\n  size_t sVar20;\n  char *pcVar21;\n  void *__ptr;\n  void *__ptr_00;\n  ulong uVar22;\n  long lVar23;\n  ulong uVar24;\n  int *piVar25;\n  ulong uVar26;\n  FILE *__s_00;\n  long **pplVar27;\n  uint uVar28;\n  long **__ptr_01;\n  char *pcVar29;\n  undefined8 *puVar30;\n  ulong uVar31;\n  int iVar32;\n  long **pplVar33;\n  char *pcVar34;\n  long lVar35;\n  undefined4 *puVar36;\n  ulong *puVar37;\n  undefined8 *puVar38;\n  uint uVar39;\n  char **ppcVar40;\n  void *pvVar41;\n  undefined **ppuVar42;\n  bool bVar43;\n  byte bVar44;\n  ulong uStack_1f8;\n  ulong local_1f0;\n  undefined4 *puStack_1e8;\n  char *pcStack_1d0;\n  int *piStack_1c0;\n  long lStack_190;\n  long lStack_180;\n  char *pcStack_178;\n  long lStack_168;\n  long *plStack_148;\n  ulong uStack_140;\n  long lStack_138;\n  long lStack_130;\n  void *apvStack_128 [2];\n  long lStack_118;\n  ushort uStack_10a;\n  byte bStack_108;\n  byte bStack_107;\n  undefined8 uStack_f8;\n  ushort uStack_f0;\n  char *pcStack_c8;\n  ulong uStack_c0;\n  char *pcStack_b8;\n  undefined uStack_b0;\n  short sStack_ae;\n  \n  bVar44 \u003d 0;\n  iVar13 \u003d *(int *)(*(long *)(param_2 + 8) + 0xc);\n  local_1f0._0_1_ \u003d\n       (*(int *)(param_1[1] + 0xc) !\u003d iVar13 \u0026\u0026 *(int *)(param_1[1] + 0xc) !\u003d 2) \u0026\u0026 iVar13 !\u003d 2;\n  if ((bool)(char)local_1f0) {\n    uVar18 \u003d bfd_get_archive_filename();\n    uVar17 \u003d dcgettext(0,\"unable to change endianness of \\\u0027%s\\\u0027\",5);\n    non_fatal(uVar17,uVar18);\n    return 0;\n  }\n  if ((*(byte *)((long)param_1 + 0x4a) \u0026 0x20) !\u003d 0) {\n    uVar18 \u003d bfd_get_archive_filename();\n    uVar17 \u003d dcgettext(0,\"unable to modify \\\u0027%s\\\u0027 due to errors\",5);\n    non_fatal(uVar17,uVar18);\n    return 0;\n  }\n  cVar11 \u003d bfd_set_format(param_2,*(byte *)(param_1 + 9) \u0026 7);\n  if (cVar11 \u003d\u003d \u0027\\0\u0027) {\n    bfd_nonfatal_message(0,param_2,0,0);\n    return 0;\n  }\n  if (param_1[0x12] \u003d\u003d 0) {\n    uVar18 \u003d bfd_get_archive_filename(param_1);\n    uVar17 \u003d dcgettext(0,\"error: the input file \\\u0027%s\\\u0027 has no sections\",5);\n    non_fatal(uVar17,uVar18);\n    return 0;\n  }\n  _VerilogDataEndianness \u003d *(undefined4 *)(param_1[1] + 0xc);\n  if (*(int *)(param_1[1] + 8) \u003d\u003d 5) {\n    if (verbose !\u003d \u0027\\0\u0027) {\n      uVar26 \u003d FUN_00107976();\n      return uVar26;\n    }\n  }\n  else {\n    if ((do_debug_sections !\u003d 1) \u0026\u0026 ((do_debug_sections \u0026 1) !\u003d 0)) {\n      uVar18 \u003d bfd_get_archive_filename(param_1);\n      uVar17 \u003d dcgettext(0,\n                         \"--compress-debug-sections\u003d[zlib|zlib-gnu|zlib-gabi|zstd] is unsupported on `%s\\\u0027\"\n                         ,5);\n      non_fatal(uVar17,uVar18);\n      return 0;\n    }\n    if (do_elf_stt_common !\u003d 0) {\n      uVar18 \u003d bfd_get_archive_filename(param_1);\n      uVar17 \u003d dcgettext(0,\"--elf-stt-common\u003d[yes|no] is unsupported on `%s\\\u0027\",5);\n      non_fatal(uVar17,uVar18);\n      return 0;\n    }\n    if (verbose !\u003d \u0027\\0\u0027) {\n      uVar26 \u003d FUN_00107976();\n      return uVar26;\n    }\n  }\n  if (extract_symbol \u003d\u003d \u0027\\0\u0027) {\n    if (set_start_set \u003d\u003d \u0027\\0\u0027) {\n      lVar35 \u003d change_start + param_1[0x17];\n    }\n    else {\n      lVar35 \u003d change_start + set_start;\n    }\n  }\n  else {\n    lVar35 \u003d 0;\n  }\n  if ((*(byte *)(param_2 + 0x48) \u0026 7) \u003d\u003d 3) {\n    iVar13 \u003d bfd_get_arch(param_1,lVar35);\n    uVar14 \u003d bfd_get_mach(param_1);\n    if (param_3 !\u003d 0) {\n      uVar26 \u003d FUN_001152b6();\n      return uVar26;\n    }\n    goto LAB_00114f9a;\n  }\n  uVar28 \u003d ~bfd_flags_to_clear \u0026 *(uint *)(*(long *)(param_2 + 8) + 0x14) \u0026\n           (bfd_flags_to_set | *(uint *)((long)param_1 + 0x44));\n  if (strip_symbols \u003d\u003d 7) {\n    uVar28 \u003d uVar28 \u0026 0xfffffffe;\n    cVar11 \u003d bfd_set_start_address(param_2);\n  }\n  else {\n    cVar11 \u003d bfd_set_start_address(param_2);\n  }\n  if ((cVar11 \u003d\u003d \u0027\\0\u0027) || (cVar11 \u003d bfd_set_file_flags(param_2,uVar28), cVar11 \u003d\u003d \u0027\\0\u0027))\n  goto LAB_00107a82;\n  iVar13 \u003d bfd_get_arch(param_1);\n  uVar14 \u003d bfd_get_mach(param_1);\n  if (param_3 \u003d\u003d 0) {\nLAB_00114f9a:\n    if (((iVar13 \u003d\u003d 0) \u0026\u0026 (*(int *)(param_1[1] + 8) !\u003d 5)) \u0026\u0026\n       (*(int *)(*(long *)(param_2 + 8) + 8) \u003d\u003d 5)) {\n      uVar26 \u003d FUN_00107880();\n      return uVar26;\n    }\n  }\n  else {\n    if (iVar13 \u003d\u003d 0) {\n      iVar13 \u003d *(int *)(param_3 + 0xc);\n      uVar14 \u003d *(undefined4 *)(param_3 + 0x10);\n      goto LAB_00114f9a;\n    }\n    uVar18 \u003d bfd_get_archive_filename(param_1);\n    uVar17 \u003d dcgettext(0,\"Input file `%s\\\u0027 ignores binary architecture parameter.\",5);\n    non_fatal(uVar17,uVar18);\n  }\n  cVar11 \u003d (**(code **)(*(long *)(param_2 + 8) + 0x2a0))(param_2,iVar13,uVar14);\n  if (cVar11 \u003d\u003d \u0027\\0\u0027) {\n    if ((*(byte *)(param_1 + 9) \u0026 0x40) !\u003d 0) {\n      iVar13 \u003d bfd_get_arch(param_1);\n      if (iVar13 \u003d\u003d 0) {\n        uVar18 \u003d bfd_get_archive_filename(param_1);\n        uVar17 \u003d dcgettext(0,\"Unable to recognise the format of the input file `%s\\\u0027\",5);\n        non_fatal(uVar17,uVar18);\n        return 0;\n      }\n      uVar18 \u003d bfd_get_mach(param_1);\n      uVar14 \u003d bfd_get_arch(param_1);\n      uVar18 \u003d bfd_printable_arch_mach(uVar14,uVar18);\n      uVar17 \u003d dcgettext(0,\"Output file cannot represent architecture `%s\\\u0027\",5);\n      non_fatal(uVar17,uVar18);\n      return 0;\n    }\n    iVar13 \u003d bfd_get_arch(param_1);\n    iVar32 \u003d bfd_get_arch(param_2);\n    if (iVar13 !\u003d iVar32) {\n      uVar26 \u003d FUN_00105828();\n      return uVar26;\n    }\n  }\n  cVar11 \u003d bfd_set_format(param_2,*(byte *)(param_1 + 9) \u0026 7);\n  if (cVar11 \u003d\u003d \u0027\\0\u0027) {\nLAB_00107a82:\n    bfd_nonfatal_message(0,param_1,0,0);\n    return 0;\n  }\n  if ((*(int *)(*(undefined8 **)(param_2 + 8) + 1) \u003d\u003d 2) \u0026\u0026\n     (cVar11 \u003d startswith_lto_priv_0_lto_priv_0(**(undefined8 **)(param_2 + 8),\u0026DAT_0011b503),\n     cVar11 !\u003d \u0027\\0\u0027)) {\n    lVar35 \u003d *(long *)(param_2 + 0x110);\n    if ((*(int *)((undefined8 *)param_1[1] + 1) \u003d\u003d 2) \u0026\u0026\n       (cVar11 \u003d startswith_lto_priv_0_lto_priv_0(*(undefined8 *)param_1[1],\u0026DAT_0011b503),\n       cVar11 !\u003d \u0027\\0\u0027)) {\n      lVar16 \u003d param_1[0x22];\n      bVar43 \u003d preserve_dates \u003d\u003d \u0027\\0\u0027;\n      puVar30 \u003d (undefined8 *)(lVar16 + 200);\n      puVar38 \u003d (undefined8 *)(lVar35 + 200);\n      for (lVar23 \u003d 0x32; lVar23 !\u003d 0; lVar23 \u003d lVar23 + -1) {\n        *puVar38 \u003d *puVar30;\n        puVar30 \u003d puVar30 + (ulong)bVar44 * -2 + 1;\n        puVar38 \u003d puVar38 + (ulong)bVar44 * -2 + 1;\n      }\n      if (bVar43) {\n        *(undefined4 *)(lVar35 + 0x2a4) \u003d 0xffffffff;\n      }\n      else {\n        *(int *)(lVar35 + 0x2a4) \u003d (int)*(undefined8 *)(lVar16 + 0xa8);\n      }\n    }\n    uVar26 \u003d pe_file_alignment;\n    if (pe_file_alignment \u003d\u003d 0xffffffffffffffff) {\n      pe_file_alignment \u003d 0x200;\n      uVar26 \u003d 0x200;\n    }\n    else {\n      *(int *)(lVar35 + 0x10c) \u003d (int)pe_file_alignment;\n    }\n    if (pe_heap_commit !\u003d -1) {\n      *(long *)(lVar35 + 0x148) \u003d pe_heap_commit;\n    }\n    if (pe_heap_reserve !\u003d -1) {\n      *(long *)(lVar35 + 0x148) \u003d pe_heap_reserve;\n    }\n    if (pe_image_base !\u003d -1) {\n      *(long *)(lVar35 + 0x100) \u003d pe_image_base;\n    }\n    uVar22 \u003d pe_section_alignment;\n    if (pe_section_alignment \u003d\u003d 0xffffffffffffffff) {\n      pe_section_alignment \u003d 0x1000;\n      uVar22 \u003d 0x1000;\n    }\n    else {\n      *(int *)(lVar35 + 0x108) \u003d (int)pe_section_alignment;\n    }\n    if (pe_stack_commit !\u003d -1) {\n      *(long *)(lVar35 + 0x138) \u003d pe_stack_commit;\n    }\n    if (pe_stack_reserve !\u003d -1) {\n      *(long *)(lVar35 + 0x138) \u003d pe_stack_reserve;\n    }\n    if (pe_subsystem !\u003d -1) {\n      *(short *)(lVar35 + 300) \u003d pe_subsystem;\n    }\n    if (pe_major_subsystem_version !\u003d -1) {\n      *(short *)(lVar35 + 0x118) \u003d pe_major_subsystem_version;\n    }\n    if (pe_minor_subsystem_version !\u003d -1) {\n      *(short *)(lVar35 + 0x11a) \u003d pe_minor_subsystem_version;\n    }\n    if (uVar22 \u003c uVar26) {\n      uVar18 \u003d dcgettext(0,\"warning: file alignment (0x%lx) \u003e section alignment (0x%lx)\",5);\n      non_fatal(uVar18,uVar26,uVar22);\n    }\n  }\n  plVar6 \u003d isympp;\n  free(isympp);\n  if (plVar6 \u003d\u003d osympp) {\n    isympp \u003d (long *)0x0;\n    osympp \u003d (long *)0x0;\n    lVar35 \u003d (**(code **)(param_1[1] + 0x1f8))(param_1);\n  }\n  else {\n    free(osympp);\n    isympp \u003d (long *)0x0;\n    osympp \u003d (long *)0x0;\n    lVar35 \u003d (**(code **)(param_1[1] + 0x1f8))(param_1);\n  }\n  if (lVar35 \u003c 0) goto LAB_00107a82;\n  osympp \u003d (long *)xmalloc();\n  isympp \u003d osympp;\n  uStack_1f8 \u003d (**(code **)(param_1[1] + 0x200))(param_1,osympp);\n  if ((long)uStack_1f8 \u003c 0) goto LAB_00107a82;\n  if (uStack_1f8 \u003d\u003d 0) {\n    free(isympp);\n    isympp \u003d (long *)0x0;\n    osympp \u003d (long *)0x0;\n  }\n  bfd_map_over_sections(param_1,setup_section,param_2);\n  puVar30 \u003d add_sections;\n  if ((extract_symbol \u003d\u003d \u0027\\0\u0027) \u0026\u0026\n     (cVar11 \u003d (**(code **)(*(long *)(param_2 + 8) + 0x168))(param_1), puVar30 \u003d add_sections,\n     cVar11 \u003d\u003d \u0027\\0\u0027)) {\n    status \u003d 1;\n    dcgettext(0,\"error in private header data\",5);\n    bfd_nonfatal_message(0,param_1,0);\n    puVar30 \u003d add_sections;\n  }\n  for (; puVar38 \u003d update_sections, puVar30 !\u003d (undefined8 *)0x0; puVar30 \u003d (undefined8 *)*puVar30)\n  {\n    uVar28 \u003d 0x128;\n    lVar35 \u003d find_section_list(puVar30[1],0,0x80);\n    if (lVar35 !\u003d 0) {\n      uVar28 \u003d check_new_section_flags(*(uint *)(lVar35 + 0x28) | 0x100,param_2,puVar30[1]);\n    }\n    lVar35 \u003d bfd_get_section_by_name(param_2,puVar30[1]);\n    if (lVar35 !\u003d 0) {\n      uVar18 \u003d puVar30[1];\n      uVar17 \u003d dcgettext(0,\"can\\\u0027t add section \\\u0027%s\\\u0027\",5);\n      bfd_nonfatal_message(0,param_2,0,uVar17,uVar18);\n      return 0;\n    }\n    lVar35 \u003d bfd_make_section_with_flags(param_2,puVar30[1],uVar28 | 0x100000);\n    puVar30[5] \u003d lVar35;\n    if (lVar35 \u003d\u003d 0) {\n      uVar18 \u003d puVar30[1];\n      uVar17 \u003d dcgettext(0,\"can\\\u0027t create section `%s\\\u0027\",5);\n      bfd_nonfatal_message(0,param_2,0,uVar17,uVar18);\n      return 0;\n    }\n    cVar11 \u003d bfd_set_section_size();\n    if (cVar11 \u003d\u003d \u0027\\0\u0027) {\n      bfd_nonfatal_message(0,param_2,puVar30[5],0);\n      return 0;\n    }\n    lVar35 \u003d find_section_list(puVar30[1],0,0x18);\n    if (lVar35 !\u003d 0) {\n      uVar18 \u003d *(undefined8 *)(lVar35 + 0x18);\n      lVar35 \u003d puVar30[5];\n      *(byte *)(lVar35 + 0x28) \u003d *(byte *)(lVar35 + 0x28) | 1;\n      *(undefined8 *)(lVar35 + 0x30) \u003d uVar18;\n      *(undefined8 *)(lVar35 + 0x38) \u003d uVar18;\n    }\n    lVar35 \u003d find_section_list(puVar30[1],0,0x60);\n    if (lVar35 !\u003d 0) {\n      lVar16 \u003d puVar30[5];\n      *(undefined8 *)(lVar16 + 0x38) \u003d *(undefined8 *)(lVar35 + 0x20);\n      if (0x3e \u003c *(uint *)(lVar16 + 0x7c)) {\n        bfd_nonfatal_message(0,param_2,lVar16,0);\n        return 0;\n      }\n    }\n  }\n  for (; puVar38 !\u003d (undefined8 *)0x0; puVar38 \u003d (undefined8 *)*puVar38) {\n    lVar35 \u003d bfd_get_section_by_name(param_1,puVar38[1]);\n    puVar38[5] \u003d lVar35;\n    if (lVar35 \u003d\u003d 0) {\n      uVar18 \u003d puVar38[1];\n      uVar17 \u003d dcgettext(0,\"error: %s not found, can\\\u0027t be updated\",5);\n      non_fatal(uVar17,uVar18);\n      return 0;\n    }\n    uVar18 \u003d *(undefined8 *)(lVar35 + 0x60);\n    cVar11 \u003d bfd_set_section_size(uVar18);\n    if (cVar11 \u003d\u003d \u0027\\0\u0027) {\n      bfd_nonfatal_message(0,param_2,uVar18,0);\n      return 0;\n    }\n  }\n  puVar30 \u003d dump_sections;\n  if (merge_notes \u003d\u003d \u0027\\0\u0027) {\n    __ptr_01 \u003d (long **)0x0;\n  }\n  else {\n    pplVar33 \u003d (long **)param_1[0x12];\n    __ptr_01 \u003d pplVar33;\n    if (pplVar33 !\u003d (long **)0x0) {\n      __ptr_01 \u003d (long **)0x0;\nLAB_001151ab:\n      if (merge_notes !\u003d \u0027\\0\u0027) goto LAB_00115187;\n      for (plVar6 \u003d pplVar33[1]; puVar30 \u003d dump_sections, plVar6 !\u003d (long *)0x0;\n          plVar6 \u003d (long *)plVar6[1]) {\n      }\n    }\n  }\njoined_r0x001151c7:\n  for (; puVar30 !\u003d (undefined8 *)0x0; puVar30 \u003d (undefined8 *)*puVar30) {\n    lVar35 \u003d bfd_get_section_by_name(param_1,puVar30[1]);\n    if (lVar35 \u003d\u003d 0) {\n      dcgettext(0,\"can\\\u0027t dump section \\\u0027%s\\\u0027 - it does not exist\",5);\n      bfd_nonfatal_message(0,param_1,0);\n    }\n    else if ((*(byte *)(lVar35 + 0x25) \u0026 1) \u003d\u003d 0) {\n      dcgettext(0,\"can\\\u0027t dump section - it has no contents\",5);\n      bfd_nonfatal_message(0,param_1,lVar35);\n    }\n    else {\n      sVar19 \u003d *(size_t *)(lVar35 + 0x40);\n      __s_00 \u003d fopen((char *)puVar30[2],\"w\");\n      if (__s_00 \u003d\u003d (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        bfd_nonfatal_message(puVar30[2],0,0);\n      }\n      else {\n        cVar11 \u003d bfd_malloc_and_get_section(param_1,lVar35,\u0026pcStack_c8);\n        if (cVar11 \u003d\u003d \u0027\\0\u0027) {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          bfd_nonfatal_message(0,param_1,lVar35);\n        }\n        else if ((sVar19 !\u003d 0) \u0026\u0026 (sVar20 \u003d fwrite(pcStack_c8,1,sVar19,__s_00), sVar20 !\u003d sVar19)) {\n          piVar25 \u003d __errno_location();\n          pcVar34 \u003d strerror(*piVar25);\n          uVar18 \u003d puVar30[2];\n          uVar17 \u003d dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          non_fatal(uVar17,uVar18,pcVar34);\n          free(pcStack_c8);\n          fclose(__s_00);\n          return 0;\n        }\n        fclose(__s_00);\n        free(pcStack_c8);\n      }\n    }\n  }\n  if (gnu_debuglink_filename \u003d\u003d 0) {\nLAB_0010790a:\n    lStack_190 \u003d 0;\n  }\n  else {\n    lVar35 \u003d bfd_get_section_by_name(param_2,\".gnu_debuglink\");\n    if (lVar35 !\u003d 0) {\n      uVar18 \u003d dcgettext(0,\"%s: debuglink section already exists\",5);\n      non_fatal(uVar18);\n      gnu_debuglink_filename \u003d 0;\n      goto LAB_0010790a;\n    }\n    lStack_190 \u003d bfd_create_gnu_debuglink_section(param_2);\n    lVar35 \u003d gnu_debuglink_filename;\n    if (lStack_190 \u003d\u003d 0) {\n      uVar18 \u003d dcgettext(0,\"cannot create debug link section `%s\\\u0027\",5);\n      bfd_nonfatal_message(0,param_2,0,uVar18,lVar35);\n      return 0;\n    }\n    if (*(int *)(*(long *)(param_2 + 8) + 8) \u003d\u003d 2) {\n      uVar22 \u003d 0;\n      for (uVar26 \u003d *(ulong *)(param_2 + 0x90); uVar26 !\u003d 0; uVar26 \u003d *(ulong *)(uVar26 + 8)) {\n        uVar24 \u003d *(ulong *)(uVar26 + 0x30);\n        uVar31 \u003d uVar22;\n        uVar7 \u003d uVar26;\n        uVar8 \u003d uVar22;\n        if (uVar24 !\u003d 0) {\n          while ((uVar31 \u003d uVar7, uVar8 !\u003d 0 \u0026\u0026\n                 (uVar31 \u003d uVar26, uVar24 \u003c\u003d *(ulong *)(uVar22 + 0x30)))) {\n            uVar26 \u003d *(ulong *)(uVar26 + 8);\n            if (uVar26 \u003d\u003d 0) goto LAB_00107db8;\n            uVar24 \u003d *(ulong *)(uVar26 + 0x30);\n            uVar7 \u003d uVar22;\n            uVar8 \u003d uVar24;\n          }\n        }\n        uVar22 \u003d uVar31;\n      }\nLAB_00107db8:\n      if (uVar22 \u003d\u003d 0) {\n        uVar26 \u003d 0x1000;\n      }\n      else {\n        uVar22 \u003d *(long *)(uVar22 + 0x40) + *(long *)(uVar22 + 0x30);\n        uVar26 \u003d 0xffffffffffffffff;\n        if (uVar22 \u003c 0xfffffffffffff001) {\n          uVar26 \u003d uVar22 + 0xfff \u0026 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(lStack_190 + 0x28) \u003d *(byte *)(lStack_190 + 0x28) | 1;\n      *(ulong *)(lStack_190 + 0x30) \u003d uVar26;\n      *(ulong *)(lStack_190 + 0x38) \u003d uVar26;\n    }\n  }\n  plVar6 \u003d isympp;\n  if (*(int *)(param_2 + 0xa0) !\u003d 0) {\n    uVar26 \u003d FUN_0010554f();\n    return uVar26;\n  }\n  if (convert_debugging \u003d\u003d \u0027\\0\u0027) {\nLAB_00105588:\n    puStack_1e8 \u003d (undefined4 *)0x0;\n  }\n  else {\n    ppuVar42 \u003d \u0026names_0;\n    puStack_1e8 \u003d (undefined4 *)xmalloc(0x60);\n    puVar36 \u003d puStack_1e8;\n    for (lVar35 \u003d 0x18; lVar35 !\u003d 0; lVar35 \u003d lVar35 + -1) {\n      *puVar36 \u003d 0;\n      puVar36 \u003d puVar36 + (ulong)bVar44 * -2 + 1;\n    }\n    pcStack_1d0 \u003d (char *)0x0;\n    do {\n      puVar3 \u003d *ppuVar42;\n      lVar35 \u003d bfd_get_section_by_name(param_1,puVar3);\n      lVar16 \u003d bfd_get_section_by_name();\n      if ((lVar35 !\u003d 0) \u0026\u0026 (lVar16 !\u003d 0)) {\n        lVar23 \u003d *(long *)(lVar35 + 0x40);\n        __ptr \u003d (void *)xmalloc(lVar23);\n        cVar11 \u003d bfd_get_section_contents(param_1,lVar35,__ptr,0,lVar23);\n        if (cVar11 \u003d\u003d \u0027\\0\u0027) {\n          uVar14 \u003d bfd_get_error();\n          bfd_errmsg(uVar14);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*param_1);\n          free(pcStack_1d0);\n          free(__ptr);\n        }\n        else {\n          uVar26 \u003d *(ulong *)(lVar16 + 0x40);\n          __ptr_00 \u003d (void *)xmalloc(uVar26 + 1);\n          local_1f0._0_1_ \u003d bfd_get_section_contents(param_1,lVar16,__ptr_00,0);\n          if ((char)local_1f0 \u003d\u003d \u0027\\0\u0027) {\n            uVar14 \u003d bfd_get_error();\n            bfd_errmsg(uVar14);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*param_1);\n            free(pcStack_1d0);\n          }\n          else {\n            *(undefined *)((long)__ptr_00 + uVar26) \u003d 0;\n            if ((pcStack_1d0 !\u003d (char *)0x0) ||\n               (pcStack_1d0 \u003d (char *)start_stab_constprop_0(param_1,1,plVar6),\n               pcStack_1d0 !\u003d (char *)0x0)) {\n              lStack_168 \u003d 0;\n              lStack_180 \u003d 0;\n              for (pvVar41 \u003d __ptr; pvVar41 \u003c\u003d (void *)((long)__ptr + lVar23 + -0xc);\n                  pvVar41 \u003d (void *)((long)pvVar41 + 0xc)) {\n                uVar22 \u003d (**(code **)(param_1[1] + 0x40))(pvVar41);\n                bVar2 \u003d *(byte *)((long)pvVar41 + 4);\n                uVar14 \u003d (**(code **)(param_1[1] + 0x58))((long)pvVar41 + 6);\n                lVar35 \u003d (**(code **)(param_1[1] + 0x40))((long)pvVar41 + 8);\n                if (bVar2 \u003d\u003d 0) {\n                  lStack_180 \u003d lStack_168;\n                  lStack_168 \u003d lStack_168 + lVar35;\n                }\n                else {\n                  uVar24 \u003d (uVar22 \u0026 0xffffffff) + lStack_180;\n                  if (uVar24 \u003c uVar26) {\n                    pcVar34 \u003d (char *)((long)__ptr_00 + uVar24);\n                    pcStack_178 \u003d (char *)0x0;\n                    while( true ) {\n                      sVar19 \u003d strlen(pcVar34);\n                      if (((sVar19 \u003d\u003d 0) || (pcVar29 \u003d pcVar34 + (sVar19 - 1), *pcVar29 !\u003d \u0027\\\\\u0027)) ||\n                         ((ulong)((long)__ptr + lVar23) \u003c (long)pvVar41 + 0x10U)) goto LAB_001077fb;\n                      *pcVar29 \u003d \u0027\\0\u0027;\n                      pvVar41 \u003d (void *)((long)pvVar41 + 0xc);\n                      iVar13 \u003d (**(code **)(param_1[1] + 0x40))(pvVar41);\n                      uVar22 \u003d (ulong)(uint)(iVar13 + (int)lStack_180);\n                      if (uVar26 \u003c\u003d uVar22) break;\n                      pcVar34 \u003d (char *)concat(pcVar34,(long)__ptr_00 + uVar22,0);\n                      *pcVar29 \u003d \u0027\\\\\u0027;\n                      free(pcStack_178);\n                      pcStack_178 \u003d pcVar34;\n                    }\n                    uVar18 \u003d *param_1;\n                    pcVar29 \u003d (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar29,uVar18,puVar3,((long)pvVar41 - (long)__ptr) / 0xc);\nLAB_001077fb:\n                    save_stab((ulong)bVar2,uVar14,lVar35,pcVar34);\n                    cVar11 \u003d parse_stab(puStack_1e8,pcStack_1d0,bVar2);\n                    if (cVar11 \u003d\u003d \u0027\\0\u0027) {\n                      stab_context();\n                      free_saved_stabs();\n                      free(pcStack_178);\n                      free(pcStack_1d0);\n                      free(__ptr);\n                      free(__ptr_00);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar18 \u003d *param_1;\n                    pcVar34 \u003d (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx \u003d 0x%x, type \u003d %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar34,uVar18,puVar3,((long)pvVar41 - (long)__ptr) / 0xc,\n                            uVar22 \u0026 0xffffffff,(ulong)bVar2,((long)pvVar41 - (long)__ptr) % 0xc);\n                  }\n                }\n              }\n              free_saved_stabs();\n              free(__ptr);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_00);\n          free(__ptr);\n        }\n        goto LAB_00105981;\n      }\nLAB_001058eb:\n      ppuVar42 \u003d ppuVar42 + 2;\n    } while (ppuVar42 !\u003d (undefined **)\u0026DAT_00125c90);\n    if ((pcStack_1d0 !\u003d (char *)0x0) \u0026\u0026 (cVar11 \u003d finish_stab(), cVar11 \u003d\u003d \u0027\\0\u0027)) {\nLAB_00105981:\n      free(puStack_1e8);\n      goto LAB_00105588;\n    }\n    if (*(int *)(param_1[1] + 8) \u003d\u003d 1) {\n      lVar35 \u003d 0;\n      for (plVar15 \u003d plVar6; plVar15 \u003c plVar6 + uStack_1f8; plVar15 \u003d plVar15 + 1) {\n        (**(code **)(param_1[1] + 0x218))(param_1,*plVar15,\u0026pcStack_c8);\n        if ((char)uStack_c0 \u003d\u003d \u0027-\u0027) {\n          if (((lVar35 \u003d\u003d 0) \u0026\u0026 (lVar35 \u003d start_stab_constprop_0(param_1,0,plVar6), lVar35 \u003d\u003d 0)) ||\n             ((pcStack_b8 \u003d\u003d (char *)0x0 || (*pcStack_b8 \u003d\u003d \u0027\\0\u0027)))) goto LAB_00105981;\n          pcVar34 \u003d (char *)0x0;\n          pcVar29 \u003d pcStack_b8;\n          while (((*pcVar29 !\u003d \u0027\\0\u0027 \u0026\u0026 (sVar19 \u003d strlen(pcVar29), pcVar29[sVar19 - 1] \u003d\u003d \u0027\\\\\u0027)) \u0026\u0026\n                 (plVar15 + 1 \u003c plVar6 + uStack_1f8))) {\n            pcVar21 \u003d (char *)xstrdup(pcVar29);\n            sVar19 \u003d strlen(pcVar21);\n            pcVar21[sVar19 - 1] \u003d \u0027\\0\u0027;\n            pcVar29 \u003d (char *)concat(pcVar21,*(undefined8 *)(plVar15[1] + 8),0);\n            free(pcVar21);\n            free(pcVar34);\n            plVar15 \u003d plVar15 + 1;\n            pcVar34 \u003d pcVar29;\n          }\n          save_stab(uStack_b0,(int)sStack_ae,pcStack_c8,pcVar29);\n          local_1f0._0_1_ \u003d parse_stab(puStack_1e8,lVar35,uStack_b0);\n          if ((char)local_1f0 \u003d\u003d \u0027\\0\u0027) {\n            stab_context();\n            free_saved_stabs();\n            goto LAB_00105981;\n          }\n        }\n      }\n      free_saved_stabs();\n      if ((lVar35 !\u003d 0) \u0026\u0026 (cVar11 \u003d finish_stab(), cVar11 \u003d\u003d \u0027\\0\u0027)) goto LAB_00105981;\n    }\n    if ((char)local_1f0 \u003d\u003d \u0027\\0\u0027) {\n      if ((*(int *)(param_1[1] + 8) \u003d\u003d 2) \u0026\u0026 (uStack_1f8 !\u003d 0)) {\n        pcStack_c8 \u003d (char *)0x0;\n        plStack_148 \u003d plVar6;\n        lStack_138 \u003d 0;\n        lStack_130 \u003d 0;\n        puVar37 \u003d \u0026uStack_c0;\n        for (lVar35 \u003d 0x22; lVar35 !\u003d 0; lVar35 \u003d lVar35 + -1) {\n          *(undefined4 *)puVar37 \u003d 0;\n          puVar37 \u003d (ulong *)((long)puVar37 + (ulong)bVar44 * -8 + 4);\n        }\n        cVar11 \u003d \u0027\\0\u0027;\n        piStack_1c0 \u003d (int *)0x0;\n        uVar28 \u003d 0;\n        pcStack_1d0 \u003d (char *)0x0;\n        pcStack_178 \u003d (char *)0xffffffffffffffff;\n        uStack_140 \u003d uStack_1f8;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((long)uStack_1f8 \u003c\u003d lStack_138) goto LAB_00105590;\n            lVar35 \u003d plVar6[lStack_138];\n            cVar10 \u003d bfd_coff_get_syment(param_1,lVar35,apvStack_128);\n            lVar16 \u003d lStack_130;\n            if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n              uVar14 \u003d bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar34 \u003d \"bfd_coff_get_syment failed: %s\";\n              goto LAB_00105968;\n            }\n            pcVar34 \u003d *(char **)(lVar35 + 8);\n            puVar30 \u003d (undefined8 *)0x0;\n            lStack_138 \u003d lStack_138 + 1;\n            lStack_130 \u003d (ulong)bStack_107 + 1 + lStack_130;\n            if (bStack_107 !\u003d 0) {\n              puVar30 \u003d \u0026uStack_f8;\n              cVar10 \u003d bfd_coff_get_auxent(param_1,lVar35,0);\n              if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n                uVar14 \u003d bfd_get_error();\n                bfd_errmsg(uVar14);\n                pcVar34 \u003d \"bfd_coff_get_auxent failed: %s\";\n                goto LAB_00105968;\n              }\n            }\n            if (pcStack_178 !\u003d (char *)lVar16) break;\n            if (bStack_108 !\u003d 0x67) {\n              cVar10 \u003d debug_set_filename(puStack_1e8);\n              if (cVar10 !\u003d \u0027\\0\u0027) break;\n              goto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            pcStack_178 \u003d (char *)lStack_118;\n            cVar10 \u003d debug_set_filename(puStack_1e8);\n            if (cVar10 \u003d\u003d \u0027\\0\u0027) goto LAB_00105981;\n          }\n          uVar9 \u003d uStack_10a;\n          if ((char)bStack_108 \u003c \u0027\\0\u0027) {\n            if (bStack_108 \u003d\u003d 0xff) goto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            lVar23 \u003d parse_coff_type_lto_priv_0(param_1,\u0026plStack_148,\u0026pcStack_c8);\n            if (lVar23 \u003d\u003d 0) break;\n            cVar10 \u003d parse_coff_symbol_constprop_0_isra_0(\u0026pcStack_c8,lVar35,lVar16);\n          }\n          else {\n            if (bStack_108 \u003c 100) {\n              switch(bStack_108) {\n              case 3:\n                if (uStack_10a \u003d\u003d 0) goto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulong)((uint)uStack_10a \u0026 *(uint *)(param_1[0x22] + 0x40)) !\u003d\n                    2L \u003c\u003c ((byte)*(undefined4 *)(param_1[0x22] + 0x3c) \u0026 0x3f)) goto LAB_0010700a;\n                piStack_1c0 \u003d (int *)(**(code **)(param_1[1] + 0x238))(param_1);\n                uVar28 \u003d (uint)uVar9;\n                pcStack_1d0 \u003d pcVar34;\n                goto switchD_00106e1a_caseD_68;\n              default:\n                goto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                goto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(bStack_108) {\n            case 100:\n              iVar13 \u003d strcmp(pcVar34,\".bb\");\n              if (iVar13 \u003d\u003d 0) {\n                cVar10 \u003d debug_start_block(puStack_1e8);\n              }\n              else {\n                iVar13 \u003d strcmp(pcVar34,\".eb\");\n                if (iVar13 !\u003d 0) goto switchD_00106e1a_caseD_68;\n                cVar10 \u003d debug_end_block(puStack_1e8);\n              }\n              break;\n            case 0x65:\n              iVar13 \u003d strcmp(pcVar34,\".bf\");\n              if (iVar13 \u003d\u003d 0) {\n                if (pcStack_1d0 !\u003d (char *)0x0) {\n                  uVar39 \u003d (int)uVar28 \u003e\u003e ((byte)*(undefined4 *)(param_1[0x22] + 0x44) \u0026 0x1f);\n                  lVar16 \u003d parse_coff_type_lto_priv_0\n                                     (param_1,\u0026plStack_148,\u0026pcStack_c8,lVar16,\n                                      uVar39 ^ (uVar28 ^ uVar39) \u0026 *(uint *)(param_1[0x22] + 0x38),\n                                      puVar30,0,puStack_1e8);\n                  if ((lVar16 \u003d\u003d 0) || (cVar11 \u003d debug_record_function(puStack_1e8), cVar11 \u003d\u003d \u0027\\0\u0027)\n                     ) goto LAB_00105981;\n                  if (piStack_1c0 !\u003d (int *)0x0) {\n                    iVar13 \u003d 0;\n                    if (bStack_107 !\u003d 0) {\n                      iVar13 \u003d uStack_f0 - 1;\n                    }\n                    lVar35 \u003d *(long *)(*(long *)(lVar35 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar32 \u003d piStack_1c0[4];\n                      if (iVar32 \u003d\u003d 0) break;\n                      cVar10 \u003d debug_record_line(puStack_1e8,iVar13 + iVar32,\n                                                 *(long *)(piStack_1c0 + 6) + lVar35);\n                      piStack_1c0 \u003d piStack_1c0 + 4;\n                      if (cVar10 \u003d\u003d \u0027\\0\u0027) goto LAB_00105981;\n                    }\n                  }\n                  uVar28 \u003d 0;\n                  piStack_1c0 \u003d (int *)0x0;\n                  pcStack_1d0 \u003d (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar34 \u003d \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar13 \u003d strcmp(pcVar34,\".ef\");\n                if (iVar13 !\u003d 0) goto switchD_00106e1a_caseD_68;\n                if (cVar11 !\u003d \u0027\\0\u0027) {\n                  cVar11 \u003d debug_end_function(puStack_1e8);\n                  if (cVar11 \u003d\u003d \u0027\\0\u0027) goto LAB_00105981;\n                  cVar11 \u003d \u0027\\0\u0027;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar34 \u003d \"%ld: unexpected .ef\\n\";\n              }\n              uVar18 \u003d dcgettext(0,pcVar34,5);\n              non_fatal(uVar18);\n              goto LAB_00105981;\n            default:\n              goto LAB_0010700a;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (cVar10 !\u003d \u0027\\0\u0027);\n      }\n      else {\n        pcVar34 \u003d \"%s: no recognized debugging information\";\nLAB_00105968:\n        uVar18 \u003d dcgettext(0,pcVar34,5);\n        non_fatal(uVar18);\n      }\n      goto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)(param_2 + 0x44) \u0026 0x42) !\u003d 0) \u0026\u0026 ((*(uint *)(param_2 + 0x44) \u0026 1) \u003d\u003d 0)) {\n    if ((*(char *)(*(long *)(param_2 + 8) + 0x20) \u003d\u003d \u0027\\0\u0027) \u0026\u0026 (keep_section_symbols \u003d\u003d \u0027\\0\u0027)) {\n      if (uStack_1f8 !\u003d 0) {\n        plVar6 \u003d isympp + uStack_1f8;\n        plVar15 \u003d isympp;\n        do {\n          uVar28 \u003d *(uint *)(*plVar15 + 0x18);\n          if ((uVar28 \u0026 0x1000000) !\u003d 0) {\n            *(uint *)(*plVar15 + 0x18) \u003d uVar28 \u0026 0xfeffffff;\n          }\n          plVar15 \u003d plVar15 + 1;\n        } while (plVar6 !\u003d plVar15);\n      }\n    }\n    else {\n      for (lVar35 \u003d *(long *)(param_2 + 0x90); lVar35 !\u003d 0; lVar35 \u003d *(long *)(lVar35 + 8)) {\n        if (*(long *)(lVar35 + 0xe8) !\u003d 0) {\n          puVar1 \u003d (uint *)(*(long *)(lVar35 + 0xe8) + 0x18);\n          *puVar1 \u003d *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((strip_symbols \u003d\u003d 2) || (strip_symbols \u003d\u003d 7)) {\nLAB_001059fe:\n    if (strip_symbols \u003d\u003d 7) {\nLAB_00105a3b:\n      plVar15 \u003d (long *)xmalloc();\n      plVar6 \u003d isympp;\n      piStack_1c0._0_4_ \u003d *(uint *)((long)param_1 + 0x44) \u0026 0x42;\n      osympp \u003d plVar15;\n      if (uStack_1f8 \u003d\u003d 0) {\n        uVar26 \u003d 0;\n      }\n      else {\n        uVar26 \u003d 0;\n        local_1f0 \u003d 0;\n        do {\n          iVar13 \u003d add_symbols;\n          plVar4 \u003d (long *)plVar6[local_1f0];\n          pcVar5 \u003d (code *)plVar4[4];\n          uVar28 \u003d *(uint *)(plVar4 + 3);\n          pcVar34 \u003d (char *)plVar4[1];\n          pcVar29 \u003d pcVar34;\n          if (add_sym_list !\u003d (undefined8 *)0x0) {\n            iVar32 \u003d 0;\n            puVar30 \u003d add_sym_list;\n            while ((iVar32 \u003c iVar13 \u0026\u0026 (pcVar21 \u003d (char *)puVar30[5], pcVar21 !\u003d (char *)0x0))) {\n              if (pcVar21 !\u003d \"\") {\n                iVar12 \u003d strcmp(pcVar21,pcVar34);\n                if (iVar12 \u003d\u003d 0) {\n                  free(pcVar21);\n                  uVar22 \u003d uVar26 + 1;\n                  puVar30[5] \u003d \"\";\n                  lVar35 \u003d create_new_symbol(puVar30);\n                  uVar18 \u003d redefine_specific_htab;\n                  plVar15[uVar26] \u003d lVar35;\n                  lVar35 \u003d htab_elements(uVar18);\n                  if ((lVar35 !\u003d 0) || (section_rename_list !\u003d (char **)0x0)) goto LAB_001064eb;\n                  goto LAB_00105af8;\n                }\n                puVar30 \u003d (undefined8 *)*puVar30;\n              }\n              iVar32 \u003d iVar32 + 1;\n            }\n          }\n          lVar35 \u003d htab_elements(redefine_specific_htab);\n          uVar22 \u003d uVar26;\n          if ((lVar35 !\u003d 0) || (section_rename_list !\u003d (char **)0x0)) {\n            if (pcVar34 !\u003d (char *)0x0) {\nLAB_001064eb:\n              if (((*pcVar34 \u003d\u003d \u0027_\u0027) \u0026\u0026 (pcVar34[1] \u003d\u003d \u0027_\u0027)) \u0026\u0026\n                 (iVar13 \u003d strcmp(pcVar34 + (pcVar34[2] \u003d\u003d \u0027_\u0027),\"__gnu_lto_slim\"), iVar13 \u003d\u003d 0)) {\n                uVar18 \u003d dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\"\n                                   ,5);\n                    \n                fatal(uVar18);\n              }\n            }\n            uStack_c0 \u003d 0;\n            pcStack_c8 \u003d pcVar34;\n            lVar35 \u003d htab_find(redefine_specific_htab);\n            if (((lVar35 \u003d\u003d 0) || (pcVar29 \u003d *(char **)(lVar35 + 8), pcVar34 \u003d\u003d pcVar29)) \u0026\u0026\n               (pcVar29 \u003d pcVar34, ppcVar40 \u003d section_rename_list, (uVar28 \u0026 0x100) !\u003d 0)) {\n              for (; ppcVar40 !\u003d (char **)0x0; ppcVar40 \u003d (char **)ppcVar40[3]) {\n                iVar13 \u003d strcmp(*ppcVar40,pcVar34);\n                if (iVar13 \u003d\u003d 0) {\n                  pcVar29 \u003d ppcVar40[1];\n                  break;\n                }\n              }\n            }\n            plVar4[1] \u003d (long)pcVar29;\n            cVar11 \u003d *pcVar29;\n            if (cVar11 !\u003d \u0027\\0\u0027) goto LAB_00105b11;\nLAB_00106557:\n            pcVar34 \u003d prefix_symbols_string;\n            if ((change_leading_char !\u003d \u0027\\0\u0027) \u0026\u0026 (*(char *)(*(long *)(param_2 + 8) + 0x1c) !\u003d \u0027\\0\u0027))\n            {\n              lVar35 \u003d param_1[1];\n              cVar11 \u003d \u0027\\0\u0027;\n              goto LAB_0010668d;\n            }\n            goto joined_r0x00106565;\n          }\nLAB_00105af8:\n          cVar11 \u003d *pcVar34;\n          if (cVar11 \u003d\u003d \u0027\\0\u0027) goto LAB_00106557;\nLAB_00105b11:\n          pcVar34 \u003d prefix_symbols_string;\n          lVar35 \u003d param_1[1];\n          if (*(char *)(lVar35 + 0x1c) \u003d\u003d cVar11) {\n            if (change_leading_char \u003d\u003d \u0027\\0\u0027) {\n              if ((remove_leading_char \u003d\u003d \u0027\\0\u0027) ||\n                 ((((uVar28 \u0026 0x82) \u003d\u003d 0 \u0026\u0026 (pcVar5 !\u003d bfd_map_over_sections)) \u0026\u0026\n                  ((*(byte *)(plVar4[4] + 0x25) \u0026 0x10) \u003d\u003d 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n              pcVar29 \u003d pcVar29 + 1;\n              plVar4[1] \u003d (long)pcVar29;\n              goto joined_r0x00106565;\n            }\n            cVar11 \u003d *(char *)(*(long *)(param_2 + 8) + 0x1c);\n            if (cVar11 \u003d\u003d \u0027\\0\u0027) goto LAB_0010677d;\n            if (prefix_symbols_string !\u003d (char *)0x0) {\n              pcVar29 \u003d pcVar29 + 1;\n              plVar4[1] \u003d (long)pcVar29;\n              sVar19 \u003d strlen(pcVar29);\n              lVar35 \u003d sVar19 + 2;\nLAB_001066bc:\n              sVar19 \u003d strlen(pcVar34);\n              pcVar34 \u003d (char *)xmalloc(sVar19 + lVar35);\n              goto LAB_001066d0;\n            }\n            *pcVar29 \u003d cVar11;\n            plVar4[1] \u003d (long)pcVar29;\n            uVar26 \u003d uVar22;\n          }\n          else {\n            if ((change_leading_char \u003d\u003d \u0027\\0\u0027) || (*(char *)(*(long *)(param_2 + 8) + 0x1c) \u003d\u003d \u0027\\0\u0027))\n            {\njoined_r0x00106565:\n              uVar26 \u003d uVar22;\n              if (pcVar34 \u003d\u003d (char *)0x0) goto LAB_00105b32;\n              sVar19 \u003d strlen(pcVar29);\n              sVar20 \u003d strlen(pcVar34);\n              pcVar21 \u003d (char *)xmalloc(sVar20 + sVar19 + 1);\n              pcVar34 \u003d pcVar21;\n            }\n            else {\nLAB_0010668d:\n              pcVar34 \u003d prefix_symbols_string;\n              if ((*(char *)(lVar35 + 0x1c) !\u003d \u0027\\0\u0027) \u0026\u0026 (cVar11 !\u003d *(char *)(lVar35 + 0x1c)))\n              goto joined_r0x00106565;\n              sVar19 \u003d strlen(pcVar29);\n              lVar35 \u003d sVar19 + 2;\n              if (pcVar34 !\u003d (char *)0x0) goto LAB_001066bc;\n              pcVar34 \u003d (char *)xmalloc(lVar35);\nLAB_001066d0:\n              pcVar21 \u003d pcVar34 + 1;\n              *pcVar34 \u003d *(char *)(*(long *)(param_2 + 8) + 0x1c);\n            }\n            __s \u003d prefix_symbols_string;\n            if (prefix_symbols_string !\u003d (char *)0x0) {\n              strcpy(pcVar21,prefix_symbols_string);\n              sVar19 \u003d strlen(__s);\n              pcVar21 \u003d pcVar21 + sVar19;\n            }\n            strcpy(pcVar21,pcVar29);\n            plVar4[1] \u003d (long)pcVar34;\n            pcVar29 \u003d pcVar34;\n            uVar26 \u003d uVar22;\n          }\nLAB_00105b32:\n          if (strip_symbols \u003d\u003d 7) goto LAB_001067a8;\n          if (((uVar28 \u0026 0x20) \u003d\u003d 0) \u0026\u0026\n             (((uVar28 \u0026 0x100) \u003d\u003d 0 ||\n              ((*(byte *)(**(long **)(plVar4[4] + 0xf0) + 0x18) \u0026 0x20) \u003d\u003d 0)))) {\n            if ((((uint)piStack_1c0 \u003d\u003d 0) \u0026\u0026\n                (((uVar28 \u0026 0x82) !\u003d 0 || ((*(byte *)(plVar4[4] + 0x25) \u0026 0x10) !\u003d 0)))) ||\n               (iVar13 \u003d bfd_decode_symclass(plVar4), iVar13 \u003d\u003d 0x49)) {\nLAB_00105be2:\n              if (wildcard \u003d\u003d \u0027\\0\u0027) {\n                lVar35 \u003d htab_find();\n                if (lVar35 \u003d\u003d 0) goto LAB_00105c07;\n              }\n              else {\n                uStack_c0 \u003d uStack_c0 \u0026 0xffffffffffffff00;\n                pcStack_c8 \u003d pcVar29;\n                htab_traverse(strip_specific_htab,is_specified_symbol_predicate,\u0026pcStack_c8);\n                if ((char)uStack_c0 \u003d\u003d \u0027\\0\u0027) goto LAB_00105c07;\n              }\n            }\n            else if ((((uVar28 \u0026 0x82) \u003d\u003d 0) \u0026\u0026 (pcVar5 !\u003d bfd_map_over_sections)) \u0026\u0026\n                    ((*(byte *)(plVar4[4] + 0x25) \u0026 0x10) \u003d\u003d 0)) {\n              if ((uVar28 \u0026 4) \u003d\u003d 0) {\n                if (((*(int *)(param_1[1] + 8) !\u003d 2) ||\n                    (lVar35 \u003d *(long *)(plVar4[4] + 0xd0), lVar35 \u003d\u003d 0)) ||\n                   (*(long *)(lVar35 + 0x40) \u003d\u003d 0)) {\n                  if ((strip_symbols \u003d\u003d 3) || (discard_locals \u003d\u003d 2)) goto LAB_001067a8;\n                  if (discard_locals \u003d\u003d 1) {\n                    cVar11 \u003d bfd_is_local_label(param_1);\n                    goto joined_r0x00106a11;\n                  }\n                }\n                goto LAB_00105be2;\n              }\n              cVar11 \u003d convert_debugging;\n              if (1 \u003c strip_symbols - 2U) {\njoined_r0x00106a11:\n                if (cVar11 \u003d\u003d \u0027\\0\u0027) goto LAB_00105be2;\n              }\n            }\n            else if (strip_symbols !\u003d 3) goto LAB_00105be2;\n            goto LAB_001067a8;\n          }\n          if (wildcard \u003d\u003d \u0027\\0\u0027) {\n            lVar35 \u003d htab_find();\n            if (lVar35 !\u003d 0) {\nLAB_0010687f:\n              uVar18 \u003d dcgettext(0,\"not stripping symbol `%s\\\u0027 because it is named in a relocation\",\n                                 5);\n              non_fatal(uVar18);\n              status \u003d 1;\n            }\n          }\n          else {\n            uStack_c0 \u003d uStack_c0 \u0026 0xffffffffffffff00;\n            pcStack_c8 \u003d pcVar29;\n            htab_traverse(strip_specific_htab,is_specified_symbol_predicate,\u0026pcStack_c8);\n            if ((char)uStack_c0 !\u003d \u0027\\0\u0027) goto LAB_0010687f;\n          }\n          if ((uVar28 \u0026 0x20) \u003d\u003d 0) {\nLAB_00105c07:\n            if (wildcard !\u003d \u0027\\0\u0027) {\n              uStack_c0 \u003d uStack_c0 \u0026 0xffffffffffffff00;\n              pcStack_c8 \u003d pcVar29;\n              htab_traverse(strip_unneeded_htab,is_specified_symbol_predicate,\u0026pcStack_c8);\n              if ((char)uStack_c0 !\u003d \u0027\\0\u0027) goto LAB_001067a8;\n              goto LAB_00105c2c;\n            }\n            lVar35 \u003d htab_find();\n            if (lVar35 \u003d\u003d 0) goto LAB_00105c2c;\nLAB_001067a8:\n            if ((keep_file_symbols !\u003d \u0027\\0\u0027) \u0026\u0026 ((uVar28 \u0026 0x4000) !\u003d 0)) goto LAB_00105c2c;\n            if (wildcard \u003d\u003d \u0027\\0\u0027) {\n              lVar35 \u003d htab_find();\n              if (lVar35 !\u003d 0) goto LAB_00105c2c;\n            }\n            else {\n              uStack_c0 \u003d uStack_c0 \u0026 0xffffffffffffff00;\n              pcStack_c8 \u003d pcVar29;\n              htab_traverse(keep_specific_htab,is_specified_symbol_predicate,\u0026pcStack_c8);\n              if ((char)uStack_c0 !\u003d \u0027\\0\u0027) goto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            cVar11 \u003d is_strip_section_isra_0(plVar4[4]);\n            if (cVar11 \u003d\u003d \u0027\\0\u0027) {\n              if (((uVar28 \u0026 0x800002) \u003d\u003d 0) \u0026\u0026 (pcVar5 !\u003d bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uVar28 \u0026 0x82) !\u003d 0) {\n                  cVar11 \u003d is_specified_symbol(pcVar29);\n                  if ((cVar11 \u003d\u003d \u0027\\0\u0027) \u0026\u0026\n                     ((lVar35 \u003d htab_elements(keepglobal_specific_htab), lVar35 \u003d\u003d 0 ||\n                      (cVar11 \u003d is_specified_symbol(pcVar29), cVar11 !\u003d \u0027\\0\u0027)))) {\n                    if (((((localize_hidden \u003d\u003d \u0027\\0\u0027) ||\n                          (uVar39 \u003d *(uint *)(plVar4 + 3), (uVar39 \u0026 0x200000) !\u003d 0)) ||\n                         (lVar35 \u003d *plVar4, lVar35 \u003d\u003d 0)) ||\n                        ((*(int *)(*(long *)(lVar35 + 8) + 8) !\u003d 5 ||\n                         (*(long *)(lVar35 + 0x110) \u003d\u003d 0)))) ||\n                       (1 \u003c (*(byte *)((long)plVar4 + 0x49) \u0026 3) - 1)) goto joined_r0x00105ca2;\n                  }\n                  else {\n                    uVar39 \u003d *(uint *)(plVar4 + 3);\n                  }\n                  *(uint *)(plVar4 + 3) \u003d uVar39 \u0026 0xffffff7d | 1;\n                }\njoined_r0x00105ca2:\n                if (((uVar28 \u0026 1) !\u003d 0) \u0026\u0026 (cVar11 \u003d is_specified_symbol(pcVar29), cVar11 !\u003d \u0027\\0\u0027))\n                {\n                  *(uint *)(plVar4 + 3) \u003d *(uint *)(plVar4 + 3) \u0026 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((weaken !\u003d \u0027\\0\u0027) || (cVar11 \u003d is_specified_symbol(pcVar29), cVar11 !\u003d \u0027\\0\u0027)) {\n                  *(uint *)(plVar4 + 3) \u003d *(uint *)(plVar4 + 3) \u0026 0xff7ffffd | 0x80;\n                }\n                if (pcVar5 !\u003d bfd_map_over_sections) goto LAB_00105c5f;\n              }\n              plVar15[uVar26] \u003d (long)plVar4;\n              uVar26 \u003d uVar26 + 1;\n            }\n          }\n          local_1f0 \u003d local_1f0 + 1;\n        } while (uStack_1f8 !\u003d local_1f0);\n      }\n      if (add_sym_list !\u003d (undefined8 *)0x0) {\n        puVar30 \u003d add_sym_list;\n        iVar13 \u003d add_symbols;\n        for (lVar35 \u003d 0; lVar35 \u003c iVar13; lVar35 \u003d lVar35 + 1) {\n          pcVar34 \u003d (char *)puVar30[5];\n          if (pcVar34 \u003d\u003d (char *)0x0) {\n            plVar6 \u003d plVar15 + uVar26;\n            uVar26 \u003d uVar26 + 1;\n            lVar16 \u003d create_new_symbol(puVar30,param_2);\n            *plVar6 \u003d lVar16;\n            iVar13 \u003d add_symbols;\n          }\n          else if (pcVar34 !\u003d \"\") {\n            uVar18 \u003d dcgettext(0,\"\\\u0027before\u003d%s\\\u0027 not found\",5);\n                    \n            fatal(uVar18,pcVar34);\n          }\n          puVar30 \u003d (undefined8 *)*puVar30;\n        }\n      }\n      bVar43 \u003d convert_debugging \u003d\u003d \u0027\\0\u0027;\n      plVar15[uVar26] \u003d 0;\n      if ((bVar43) || (puStack_1e8 \u003d\u003d (undefined4 *)0x0)) {\nLAB_00105cfa:\n        uStack_1f8 \u003d uVar26 \u0026 0xffffffff;\n        goto LAB_00105710;\n      }\n      iVar13 \u003d *(int *)(*(undefined8 **)(param_2 + 8) + 1);\n      if ((iVar13 \u003d\u003d 5) || (iVar13 \u003d\u003d 2)) {\n        apvStack_128[0] \u003d (void *)0x0;\n        cVar11 \u003d write_stabs_in_sections_debugging_info_constprop_0\n                           (param_2,puStack_1e8,\u0026plStack_148,\u0026uStack_f8,apvStack_128,\u0026pcStack_c8);\n        if (cVar11 !\u003d \u0027\\0\u0027) {\n          lVar35 \u003d bfd_make_section_with_flags(param_2,\".stab\",0x2108);\n          lVar16 \u003d bfd_make_section_with_flags(param_2,\".stabstr\",0x2108);\n          if ((((lVar35 \u003d\u003d 0) || (lVar16 \u003d\u003d 0)) ||\n              (cVar11 \u003d bfd_set_section_size(lVar35,uStack_f8), cVar11 \u003d\u003d \u0027\\0\u0027)) ||\n             (cVar11 \u003d bfd_set_section_size(lVar16,pcStack_c8), cVar11 \u003d\u003d \u0027\\0\u0027)) {\n            pcVar34 \u003d \"can\\\u0027t create debugging section\";\n          }\n          else {\n            *(undefined4 *)(lVar35 + 0x7c) \u003d 2;\n            *(undefined4 *)(lVar16 + 0x7c) \u003d 0;\n            cVar11 \u003d bfd_set_section_contents(param_2,lVar35,plStack_148,0,uStack_f8);\n            if ((cVar11 !\u003d \u0027\\0\u0027) \u0026\u0026\n               (cVar11 \u003d bfd_set_section_contents(param_2,lVar16,apvStack_128[0],0,pcStack_c8),\n               cVar11 !\u003d \u0027\\0\u0027)) {\n              free(puStack_1e8);\n              goto LAB_00105cfa;\n            }\n            pcVar34 \u003d \"can\\\u0027t set debugging section contents\";\n          }\n          uVar18 \u003d dcgettext(0,pcVar34,5);\n          bfd_nonfatal_message(0,param_2,0,uVar18);\n          free(apvStack_128[0]);\n          free(puStack_1e8);\n          goto LAB_00105d96;\n        }\n      }\n      else {\n        uVar18 \u003d **(undefined8 **)(param_2 + 8);\n        uVar17 \u003d dcgettext(0,\"don\\\u0027t know how to write debugging information for %s\",5);\n        bfd_nonfatal_message(0,param_2,0,uVar17,uVar18);\n      }\n      free(puStack_1e8);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections(param_1,mark_symbols_used_in_relocations,isympp);\n      iVar13 \u003d bfd_get_error();\n      if (iVar13 \u003d\u003d 0) goto LAB_00105a3b;\n    }\nLAB_00105d96:\n    status \u003d 1;\n  }\n  else {\n    if ((strip_symbols - 3U \u003c 4) || ((discard_locals !\u003d 0 || (localize_hidden !\u003d \u0027\\0\u0027))))\n    goto LAB_00105a07;\n    lVar35 \u003d htab_elements(strip_specific_htab);\n    if (((lVar35 !\u003d 0) ||\n        (((((((lVar35 \u003d htab_elements(keep_specific_htab), lVar35 !\u003d 0 ||\n              (lVar35 \u003d htab_elements(localize_specific_htab), lVar35 !\u003d 0)) ||\n             (lVar35 \u003d htab_elements(globalize_specific_htab), lVar35 !\u003d 0)) ||\n            ((lVar35 \u003d htab_elements(keepglobal_specific_htab), lVar35 !\u003d 0 ||\n             (lVar35 \u003d htab_elements(weaken_specific_htab), lVar35 !\u003d 0)))) ||\n           (lVar35 \u003d htab_elements(redefine_specific_htab), lVar35 !\u003d 0)) ||\n          (((prefix_symbols_string !\u003d (char *)0x0 || (sections_removed !\u003d \u0027\\0\u0027)) ||\n           ((sections_copied !\u003d \u0027\\0\u0027 ||\n            (((convert_debugging !\u003d \u0027\\0\u0027 || (change_leading_char !\u003d \u0027\\0\u0027)) ||\n             (remove_leading_char !\u003d \u0027\\0\u0027)))))))) ||\n         ((section_rename_list !\u003d (char **)0x0 || (weaken !\u003d \u0027\\0\u0027)))))) || (add_symbols !\u003d 0))\n    goto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(param_2,osympp,uStack_1f8 \u0026 0xffffffff);\n    bfd_map_over_sections(param_1,copy_relocations_in_section,param_2);\n    bfd_map_over_sections(param_1,copy_section,param_2);\n    for (puVar30 \u003d add_sections; puVar38 \u003d update_sections, puVar30 !\u003d (undefined8 *)0x0;\n        puVar30 \u003d (undefined8 *)*puVar30) {\n      cVar11 \u003d bfd_set_section_contents(param_2,puVar30[5],puVar30[4],0,puVar30[3]);\n      if (cVar11 \u003d\u003d \u0027\\0\u0027) {\n        bfd_nonfatal_message(0,param_2,puVar30[5],0);\n        return 0;\n      }\n    }\n    for (; puVar38 !\u003d (undefined8 *)0x0; puVar38 \u003d (undefined8 *)*puVar38) {\n      uVar18 \u003d *(undefined8 *)(puVar38[5] + 0x60);\n      cVar11 \u003d bfd_set_section_contents(param_2,uVar18,puVar38[4],0,puVar38[3]);\n      if (cVar11 \u003d\u003d \u0027\\0\u0027) {\n        bfd_nonfatal_message(0,param_2,uVar18,0);\n        return 0;\n      }\n    }\n    if (__ptr_01 \u003d\u003d (long **)0x0) {\n      if ((merge_notes !\u003d \u0027\\0\u0027) \u0026\u0026 (is_strip \u003d\u003d 0)) {\n        uVar18 \u003d *param_1;\n        uVar17 \u003d dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n        non_fatal(uVar17,uVar18);\n      }\n    }\n    else {\n      pplVar33 \u003d (long **)0x0;\n      for (puVar30 \u003d *(undefined8 **)(param_2 + 0x90); puVar30 !\u003d (undefined8 *)0x0;\n          puVar30 \u003d (undefined8 *)puVar30[1]) {\n        if (((merge_notes !\u003d \u0027\\0\u0027) \u0026\u0026 (*(int *)(*(long *)(param_2 + 8) + 8) \u003d\u003d 5)) \u0026\u0026\n           ((*(int *)(puVar30[0x1a] + 4) \u003d\u003d 7 \u0026\u0026\n            (cVar11 \u003d startswith_lto_priv_0_lto_priv_0(*puVar30,\".gnu.build.attributes\"),\n            cVar11 !\u003d \u0027\\0\u0027)))) {\n          if (pplVar33 \u003d\u003d (long **)0x0) {\n            pplVar33 \u003d __ptr_01;\n          }\n          pplVar27 \u003d __ptr_01;\n          if ((undefined8 *)(*pplVar33)[0xc] \u003d\u003d puVar30) {\nLAB_0010625f:\n            pcVar34 \u003d \"error: failed to merge notes\";\n            if (pplVar33[1] !\u003d (long *)0x0) {\n              cVar11 \u003d bfd_set_section_contents(param_2,puVar30,pplVar33[1],0,pplVar33[2]);\n              if (cVar11 \u003d\u003d \u0027\\0\u0027) {\n                uVar18 \u003d dcgettext(0,\"error: failed to copy merged notes into output\",5);\n                bfd_nonfatal_message(0,param_2,puVar30,uVar18);\n                return 0;\n              }\n              pplVar33 \u003d (long **)pplVar33[3];\n              goto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              pplVar33 \u003d pplVar27;\n              if ((undefined8 *)(*pplVar27)[0xc] \u003d\u003d puVar30) goto LAB_0010625f;\n              pplVar33 \u003d (long **)pplVar27[3];\n              pplVar27 \u003d pplVar33;\n            } while (pplVar33 !\u003d (long **)0x0);\n            pcVar34 \u003d \"error: failed to locate merged notes\";\n          }\n          uVar18 \u003d dcgettext(0,pcVar34,5);\n          bfd_nonfatal_message(0,param_2,puVar30,uVar18);\n        }\nLAB_001061be:\n      }\n      do {\n        pplVar33 \u003d (long **)__ptr_01[3];\n        free(__ptr_01[1]);\n        free(__ptr_01);\n        __ptr_01 \u003d pplVar33;\n      } while (pplVar33 !\u003d (long **)0x0);\n    }\n    if ((gnu_debuglink_filename \u003d\u003d 0) ||\n       (cVar11 \u003d bfd_fill_in_gnu_debuglink_section(param_2,lStack_190),\n       lVar35 \u003d gnu_debuglink_filename, cVar11 !\u003d \u0027\\0\u0027)) {\n      uVar28 \u003d (**(code **)(*(long *)(param_2 + 8) + 0x140))(param_1);\n      uVar26 \u003d (ulong)uVar28;\n      if ((char)uVar28 !\u003d \u0027\\0\u0027) {\n        if (use_alt_mach_code \u003d\u003d 0) {\n          return uVar26;\n        }\n        cVar11 \u003d bfd_alt_mach_code(param_2,use_alt_mach_code \u0026 0xffffffff);\n        uVar22 \u003d use_alt_mach_code;\n        if (cVar11 \u003d\u003d \u0027\\0\u0027) {\n          uVar18 \u003d dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n          non_fatal(uVar18,uVar22);\n          if (*(int *)(*(long *)(param_2 + 8) + 8) \u003d\u003d 5) {\n            uVar18 \u003d dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n            non_fatal(uVar18);\n            *(short *)(*(long *)(param_2 + 0x110) + 0x3a) \u003d (short)use_alt_mach_code;\n            return uVar26;\n          }\n          uVar18 \u003d dcgettext(0,\"ignoring the alternative value\",5);\n          non_fatal(uVar18);\n          return uVar26;\n        }\n        return uVar26;\n      }\n      uVar18 \u003d dcgettext(0,\"error copying private BFD data\",5);\n      bfd_nonfatal_message(0,param_2,0,uVar18);\n    }\n    else {\n      uVar18 \u003d dcgettext(0,\"cannot fill debug link section `%s\\\u0027\",5);\n      bfd_nonfatal_message(0,param_2,0,uVar18,lVar35);\n    }\n  }\n  return 0;\nLAB_00115187:\n  if ((((*(int *)(param_1[1] + 8) \u003d\u003d 5) \u0026\u0026 (*(int *)((long)pplVar33[0x1a] + 4) \u003d\u003d 7)) \u0026\u0026\n      (cVar11 \u003d startswith_lto_priv_0_lto_priv_0(*pplVar33), cVar11 !\u003d \u0027\\0\u0027)) \u0026\u0026\n     ((pplVar33[0xc] !\u003d (long *)0x0 \u0026\u0026 (plVar6 \u003d pplVar33[8], plVar6 !\u003d (long *)0x0)))) {\n    pplVar27 \u003d (long **)xmalloc(0x20);\n    pplVar27[1] \u003d (long *)0x0;\n    cVar11 \u003d bfd_get_full_section_contents(param_1,pplVar33,pplVar27 + 1);\n    if (cVar11 \u003d\u003d \u0027\\0\u0027) {\n      dcgettext(0,\"warning: could not load note section\",5);\n      bfd_nonfatal_message(0,param_1,pplVar33);\n      free(pplVar27);\n    }\n    else {\n      plVar15 \u003d (long *)merge_gnu_build_notes(param_1,pplVar33,plVar6);\n      pplVar27[2] \u003d plVar15;\n      if ((plVar15 \u003d\u003d plVar6) || (cVar11 \u003d bfd_set_section_size(pplVar33[0xc]), cVar11 !\u003d \u0027\\0\u0027)) {\n        pplVar27[3] \u003d (long *)__ptr_01;\n        *pplVar27 \u003d (long *)pplVar33;\n        __ptr_01 \u003d pplVar27;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        bfd_nonfatal_message(0,param_2,pplVar33);\n        free(pplVar27[1]);\n        free(pplVar27);\n      }\n    }\n  }\n  pplVar33 \u003d (long **)pplVar33[1];\n  puVar30 \u003d dump_sections;\n  if (pplVar33 \u003d\u003d (long **)0x0) goto joined_r0x001151c7;\n  goto LAB_001151ab;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_file",
        "FUN_00104ea2"
      ],
      "called": [
        "non_fatal",
        "dcgettext",
        "bfd_set_format",
        "FUN_00107976",
        "bfd_get_archive_filename",
        "bfd_nonfatal_message"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001152b6": {
      "entrypoint": "0x001152b6",
      "current_name": "FUN_001152b6",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong FUN_001152b6(void)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  undefined *puVar3;\n  long *plVar4;\n  code *pcVar5;\n  long *plVar6;\n  ulong uVar7;\n  ulong uVar8;\n  char *__s;\n  char cVar9;\n  char cVar10;\n  uint uVar11;\n  int iVar12;\n  uint uVar13;\n  undefined4 uVar14;\n  int iVar15;\n  long *plVar16;\n  long lVar17;\n  undefined8 uVar18;\n  undefined8 uVar19;\n  size_t sVar20;\n  size_t sVar21;\n  char *pcVar22;\n  void *__ptr;\n  void *__ptr_00;\n  ulong uVar23;\n  long lVar24;\n  ulong uVar25;\n  int *piVar26;\n  long lVar27;\n  ulong uVar28;\n  FILE *__s_00;\n  long **pplVar29;\n  undefined4 unaff_EBX;\n  long **__ptr_01;\n  char *pcVar30;\n  undefined8 *puVar31;\n  ulong uVar32;\n  int iVar33;\n  long **pplVar34;\n  long unaff_RBP;\n  char *pcVar35;\n  undefined4 *puVar36;\n  undefined8 *puVar37;\n  int unaff_R12D;\n  char **ppcVar38;\n  void *pvVar39;\n  undefined8 *unaff_R14;\n  undefined **ppuVar40;\n  bool bVar41;\n  byte bVar42;\n  long param_7;\n  ulong uStack0000000000000010;\n  char in_stack_00000018;\n  undefined4 *puStack0000000000000020;\n  char *pcStack0000000000000038;\n  uint uStack0000000000000048;\n  int iStack000000000000006c;\n  long lStack0000000000000078;\n  long lStack0000000000000088;\n  char *pcStack0000000000000090;\n  long lStack00000000000000a0;\n  long *in_stack_000000c0;\n  ulong in_stack_000000c8;\n  long in_stack_000000d0;\n  long in_stack_000000d8;\n  void *in_stack_000000e0;\n  long in_stack_000000f0;\n  undefined8 in_stack_000000f8;\n  byte bStack0000000000000100;\n  byte bStack0000000000000101;\n  undefined8 in_stack_00000110;\n  ushort in_stack_00000118;\n  char *in_stack_00000140;\n  char cStack0000000000000148;\n  char *in_stack_00000150;\n  undefined uStack0000000000000158;\n  short sStack000000000000015a;\n  \n  bVar42 \u003d 0;\n  if (unaff_R12D \u003d\u003d 0) {\n    unaff_R12D \u003d *(int *)(unaff_RBP + 0xc);\n    unaff_EBX \u003d *(undefined4 *)(unaff_RBP + 0x10);\n    if (((unaff_R12D \u003d\u003d 0) \u0026\u0026 (*(int *)(unaff_R14[1] + 8) !\u003d 5)) \u0026\u0026\n       (*(int *)(*(long *)(param_7 + 8) + 8) \u003d\u003d 5)) {\n      uVar28 \u003d FUN_00107880();\n      return uVar28;\n    }\n  }\n  else {\n    uVar19 \u003d bfd_get_archive_filename();\n    uVar18 \u003d dcgettext(0,\"Input file `%s\\\u0027 ignores binary architecture parameter.\",5);\n    non_fatal(uVar18,uVar19);\n  }\n  cVar10 \u003d (**(code **)(*(long *)(param_7 + 8) + 0x2a0))(param_7,unaff_R12D,unaff_EBX);\n  if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n    if ((*(byte *)(unaff_R14 + 9) \u0026 0x40) !\u003d 0) {\n      iVar12 \u003d bfd_get_arch();\n      if (iVar12 \u003d\u003d 0) {\n        uVar19 \u003d bfd_get_archive_filename();\n        uVar18 \u003d dcgettext(0,\"Unable to recognise the format of the input file `%s\\\u0027\",5);\n        non_fatal(uVar18,uVar19);\n        return 0;\n      }\n      uVar19 \u003d bfd_get_mach();\n      uVar14 \u003d bfd_get_arch();\n      uVar19 \u003d bfd_printable_arch_mach(uVar14,uVar19);\n      uVar18 \u003d dcgettext(0,\"Output file cannot represent architecture `%s\\\u0027\",5);\n      non_fatal(uVar18,uVar19);\n      return 0;\n    }\n    iVar12 \u003d bfd_get_arch();\n    iVar33 \u003d bfd_get_arch(param_7);\n    if (iVar12 !\u003d iVar33) {\n      uVar28 \u003d FUN_00105828();\n      return uVar28;\n    }\n  }\n  cVar10 \u003d bfd_set_format(param_7,*(byte *)(unaff_R14 + 9) \u0026 7);\n  if (cVar10 \u003d\u003d \u0027\\0\u0027) {\nLAB_00107a82:\n    bfd_nonfatal_message(0);\n    return 0;\n  }\n  if ((*(int *)(*(undefined8 **)(param_7 + 8) + 1) \u003d\u003d 2) \u0026\u0026\n     (cVar10 \u003d startswith_lto_priv_0_lto_priv_0(**(undefined8 **)(param_7 + 8),\u0026DAT_0011b503),\n     cVar10 !\u003d \u0027\\0\u0027)) {\n    lVar27 \u003d *(long *)(param_7 + 0x110);\n    if ((*(int *)((undefined8 *)unaff_R14[1] + 1) \u003d\u003d 2) \u0026\u0026\n       (cVar10 \u003d startswith_lto_priv_0_lto_priv_0(*(undefined8 *)unaff_R14[1],\u0026DAT_0011b503),\n       cVar10 !\u003d \u0027\\0\u0027)) {\n      lVar17 \u003d unaff_R14[0x22];\n      bVar41 \u003d preserve_dates \u003d\u003d \u0027\\0\u0027;\n      puVar31 \u003d (undefined8 *)(lVar17 + 200);\n      puVar37 \u003d (undefined8 *)(lVar27 + 200);\n      for (lVar24 \u003d 0x32; lVar24 !\u003d 0; lVar24 \u003d lVar24 + -1) {\n        *puVar37 \u003d *puVar31;\n        puVar31 \u003d puVar31 + (ulong)bVar42 * -2 + 1;\n        puVar37 \u003d puVar37 + (ulong)bVar42 * -2 + 1;\n      }\n      if (bVar41) {\n        *(undefined4 *)(lVar27 + 0x2a4) \u003d 0xffffffff;\n      }\n      else {\n        *(int *)(lVar27 + 0x2a4) \u003d (int)*(undefined8 *)(lVar17 + 0xa8);\n      }\n    }\n    uVar28 \u003d pe_file_alignment;\n    if (pe_file_alignment \u003d\u003d 0xffffffffffffffff) {\n      pe_file_alignment \u003d 0x200;\n      uVar28 \u003d 0x200;\n    }\n    else {\n      *(int *)(lVar27 + 0x10c) \u003d (int)pe_file_alignment;\n    }\n    if (pe_heap_commit !\u003d -1) {\n      *(long *)(lVar27 + 0x148) \u003d pe_heap_commit;\n    }\n    if (pe_heap_reserve !\u003d -1) {\n      *(long *)(lVar27 + 0x148) \u003d pe_heap_reserve;\n    }\n    if (pe_image_base !\u003d -1) {\n      *(long *)(lVar27 + 0x100) \u003d pe_image_base;\n    }\n    uVar23 \u003d pe_section_alignment;\n    if (pe_section_alignment \u003d\u003d 0xffffffffffffffff) {\n      pe_section_alignment \u003d 0x1000;\n      uVar23 \u003d 0x1000;\n    }\n    else {\n      *(int *)(lVar27 + 0x108) \u003d (int)pe_section_alignment;\n    }\n    if (pe_stack_commit !\u003d -1) {\n      *(long *)(lVar27 + 0x138) \u003d pe_stack_commit;\n    }\n    if (pe_stack_reserve !\u003d -1) {\n      *(long *)(lVar27 + 0x138) \u003d pe_stack_reserve;\n    }\n    if (pe_subsystem !\u003d -1) {\n      *(short *)(lVar27 + 300) \u003d pe_subsystem;\n    }\n    if (pe_major_subsystem_version !\u003d -1) {\n      *(short *)(lVar27 + 0x118) \u003d pe_major_subsystem_version;\n    }\n    if (pe_minor_subsystem_version !\u003d -1) {\n      *(short *)(lVar27 + 0x11a) \u003d pe_minor_subsystem_version;\n    }\n    if (uVar23 \u003c uVar28) {\n      uVar19 \u003d dcgettext(0,\"warning: file alignment (0x%lx) \u003e section alignment (0x%lx)\",5);\n      non_fatal(uVar19,uVar28,uVar23);\n    }\n  }\n  plVar6 \u003d isympp;\n  free(isympp);\n  if (plVar6 \u003d\u003d osympp) {\n    isympp \u003d (long *)0x0;\n    osympp \u003d (long *)0x0;\n    lVar27 \u003d (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  else {\n    free(osympp);\n    isympp \u003d (long *)0x0;\n    osympp \u003d (long *)0x0;\n    lVar27 \u003d (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  if (lVar27 \u003c 0) goto LAB_00107a82;\n  osympp \u003d (long *)xmalloc();\n  isympp \u003d osympp;\n  uStack0000000000000010 \u003d (**(code **)(unaff_R14[1] + 0x200))();\n  if ((long)uStack0000000000000010 \u003c 0) goto LAB_00107a82;\n  if (uStack0000000000000010 \u003d\u003d 0) {\n    free(isympp);\n    isympp \u003d (long *)0x0;\n    osympp \u003d (long *)0x0;\n  }\n  bfd_map_over_sections();\n  puVar31 \u003d add_sections;\n  if ((extract_symbol \u003d\u003d \u0027\\0\u0027) \u0026\u0026\n     (cVar10 \u003d (**(code **)(*(long *)(param_7 + 8) + 0x168))(), puVar31 \u003d add_sections,\n     cVar10 \u003d\u003d \u0027\\0\u0027)) {\n    status \u003d 1;\n    dcgettext(0,\"error in private header data\",5);\n    bfd_nonfatal_message(0);\n    puVar31 \u003d add_sections;\n  }\n  for (; puVar37 \u003d update_sections, puVar31 !\u003d (undefined8 *)0x0; puVar31 \u003d (undefined8 *)*puVar31)\n  {\n    uVar11 \u003d 0x128;\n    lVar27 \u003d find_section_list(puVar31[1],0,0x80);\n    if (lVar27 !\u003d 0) {\n      uVar11 \u003d check_new_section_flags(*(uint *)(lVar27 + 0x28) | 0x100,param_7,puVar31[1]);\n    }\n    lVar27 \u003d bfd_get_section_by_name(param_7,puVar31[1]);\n    if (lVar27 !\u003d 0) {\n      uVar19 \u003d puVar31[1];\n      uVar18 \u003d dcgettext(0,\"can\\\u0027t add section \\\u0027%s\\\u0027\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar18,uVar19);\n      return 0;\n    }\n    lVar27 \u003d bfd_make_section_with_flags(param_7,puVar31[1],uVar11 | 0x100000);\n    puVar31[5] \u003d lVar27;\n    if (lVar27 \u003d\u003d 0) {\n      uVar19 \u003d puVar31[1];\n      uVar18 \u003d dcgettext(0,\"can\\\u0027t create section `%s\\\u0027\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar18,uVar19);\n      return 0;\n    }\n    cVar10 \u003d bfd_set_section_size();\n    if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n      bfd_nonfatal_message(0,param_7,puVar31[5],0);\n      return 0;\n    }\n    lVar27 \u003d find_section_list(puVar31[1],0,0x18);\n    if (lVar27 !\u003d 0) {\n      uVar19 \u003d *(undefined8 *)(lVar27 + 0x18);\n      lVar27 \u003d puVar31[5];\n      *(byte *)(lVar27 + 0x28) \u003d *(byte *)(lVar27 + 0x28) | 1;\n      *(undefined8 *)(lVar27 + 0x30) \u003d uVar19;\n      *(undefined8 *)(lVar27 + 0x38) \u003d uVar19;\n    }\n    lVar27 \u003d find_section_list(puVar31[1],0,0x60);\n    if (lVar27 !\u003d 0) {\n      lVar17 \u003d puVar31[5];\n      *(undefined8 *)(lVar17 + 0x38) \u003d *(undefined8 *)(lVar27 + 0x20);\n      if (0x3e \u003c *(uint *)(lVar17 + 0x7c)) {\n        bfd_nonfatal_message(0,param_7,lVar17,0);\n        return 0;\n      }\n    }\n  }\n  for (; puVar37 !\u003d (undefined8 *)0x0; puVar37 \u003d (undefined8 *)*puVar37) {\n    lVar27 \u003d bfd_get_section_by_name();\n    puVar37[5] \u003d lVar27;\n    if (lVar27 \u003d\u003d 0) {\n      uVar19 \u003d puVar37[1];\n      uVar18 \u003d dcgettext(0,\"error: %s not found, can\\\u0027t be updated\",5);\n      non_fatal(uVar18,uVar19);\n      return 0;\n    }\n    uVar19 \u003d *(undefined8 *)(lVar27 + 0x60);\n    cVar10 \u003d bfd_set_section_size(uVar19);\n    if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n      bfd_nonfatal_message(0,param_7,uVar19,0);\n      return 0;\n    }\n  }\n  puVar31 \u003d dump_sections;\n  if (merge_notes \u003d\u003d \u0027\\0\u0027) {\n    __ptr_01 \u003d (long **)0x0;\n  }\n  else {\n    pplVar34 \u003d (long **)unaff_R14[0x12];\n    __ptr_01 \u003d pplVar34;\n    if (pplVar34 !\u003d (long **)0x0) {\n      __ptr_01 \u003d (long **)0x0;\nLAB_001151ab:\n      if (merge_notes !\u003d \u0027\\0\u0027) goto LAB_00115187;\n      for (plVar6 \u003d pplVar34[1]; puVar31 \u003d dump_sections, plVar6 !\u003d (long *)0x0;\n          plVar6 \u003d (long *)plVar6[1]) {\n      }\n    }\n  }\njoined_r0x001151c7:\n  for (; puVar31 !\u003d (undefined8 *)0x0; puVar31 \u003d (undefined8 *)*puVar31) {\n    lVar27 \u003d bfd_get_section_by_name();\n    if (lVar27 \u003d\u003d 0) {\n      dcgettext(0,\"can\\\u0027t dump section \\\u0027%s\\\u0027 - it does not exist\",5);\n      bfd_nonfatal_message(0);\n    }\n    else if ((*(byte *)(lVar27 + 0x25) \u0026 1) \u003d\u003d 0) {\n      dcgettext(0,\"can\\\u0027t dump section - it has no contents\",5);\n      bfd_nonfatal_message(0);\n    }\n    else {\n      sVar20 \u003d *(size_t *)(lVar27 + 0x40);\n      __s_00 \u003d fopen((char *)puVar31[2],\"w\");\n      if (__s_00 \u003d\u003d (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        bfd_nonfatal_message(puVar31[2],0,0);\n      }\n      else {\n        cVar10 \u003d bfd_malloc_and_get_section();\n        if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          bfd_nonfatal_message(0);\n        }\n        else if ((sVar20 !\u003d 0) \u0026\u0026\n                (sVar21 \u003d fwrite(in_stack_00000140,1,sVar20,__s_00), sVar21 !\u003d sVar20)) {\n          piVar26 \u003d __errno_location();\n          pcVar35 \u003d strerror(*piVar26);\n          uVar19 \u003d puVar31[2];\n          uVar18 \u003d dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          non_fatal(uVar18,uVar19,pcVar35);\n          free(in_stack_00000140);\n          fclose(__s_00);\n          return 0;\n        }\n        fclose(__s_00);\n        free(in_stack_00000140);\n      }\n    }\n  }\n  if (gnu_debuglink_filename \u003d\u003d 0) {\nLAB_0010790a:\n    lStack0000000000000078 \u003d 0;\n  }\n  else {\n    lVar27 \u003d bfd_get_section_by_name(param_7,\".gnu_debuglink\");\n    if (lVar27 !\u003d 0) {\n      uVar19 \u003d dcgettext(0,\"%s: debuglink section already exists\",5);\n      non_fatal(uVar19);\n      gnu_debuglink_filename \u003d 0;\n      goto LAB_0010790a;\n    }\n    lStack0000000000000078 \u003d bfd_create_gnu_debuglink_section(param_7);\n    lVar27 \u003d gnu_debuglink_filename;\n    if (lStack0000000000000078 \u003d\u003d 0) {\n      uVar19 \u003d dcgettext(0,\"cannot create debug link section `%s\\\u0027\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar19,lVar27);\n      return 0;\n    }\n    if (*(int *)(*(long *)(param_7 + 8) + 8) \u003d\u003d 2) {\n      uVar23 \u003d 0;\n      for (uVar28 \u003d *(ulong *)(param_7 + 0x90); uVar28 !\u003d 0; uVar28 \u003d *(ulong *)(uVar28 + 8)) {\n        uVar25 \u003d *(ulong *)(uVar28 + 0x30);\n        uVar32 \u003d uVar23;\n        uVar7 \u003d uVar28;\n        uVar8 \u003d uVar23;\n        if (uVar25 !\u003d 0) {\n          while ((uVar32 \u003d uVar7, uVar8 !\u003d 0 \u0026\u0026\n                 (uVar32 \u003d uVar28, uVar25 \u003c\u003d *(ulong *)(uVar23 + 0x30)))) {\n            uVar28 \u003d *(ulong *)(uVar28 + 8);\n            if (uVar28 \u003d\u003d 0) goto LAB_00107db8;\n            uVar25 \u003d *(ulong *)(uVar28 + 0x30);\n            uVar7 \u003d uVar23;\n            uVar8 \u003d uVar25;\n          }\n        }\n        uVar23 \u003d uVar32;\n      }\nLAB_00107db8:\n      if (uVar23 \u003d\u003d 0) {\n        uVar28 \u003d 0x1000;\n      }\n      else {\n        uVar23 \u003d *(long *)(uVar23 + 0x40) + *(long *)(uVar23 + 0x30);\n        uVar28 \u003d 0xffffffffffffffff;\n        if (uVar23 \u003c 0xfffffffffffff001) {\n          uVar28 \u003d uVar23 + 0xfff \u0026 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(lStack0000000000000078 + 0x28) \u003d *(byte *)(lStack0000000000000078 + 0x28) | 1;\n      *(ulong *)(lStack0000000000000078 + 0x30) \u003d uVar28;\n      *(ulong *)(lStack0000000000000078 + 0x38) \u003d uVar28;\n    }\n  }\n  plVar6 \u003d isympp;\n  iStack000000000000006c \u003d *(int *)(param_7 + 0xa0);\n  if (iStack000000000000006c !\u003d 0) {\n    uVar28 \u003d FUN_0010554f();\n    return uVar28;\n  }\n  if (convert_debugging \u003d\u003d \u0027\\0\u0027) {\nLAB_00105588:\n    puStack0000000000000020 \u003d (undefined4 *)0x0;\n  }\n  else {\n    ppuVar40 \u003d \u0026names_0;\n    puStack0000000000000020 \u003d (undefined4 *)xmalloc(0x60);\n    puVar36 \u003d puStack0000000000000020;\n    for (lVar27 \u003d 0x18; lVar27 !\u003d 0; lVar27 \u003d lVar27 + -1) {\n      *puVar36 \u003d 0;\n      puVar36 \u003d puVar36 + (ulong)bVar42 * -2 + 1;\n    }\n    pcStack0000000000000038 \u003d (char *)0x0;\n    do {\n      puVar3 \u003d *ppuVar40;\n      lVar27 \u003d bfd_get_section_by_name();\n      lVar17 \u003d bfd_get_section_by_name();\n      if ((lVar27 !\u003d 0) \u0026\u0026 (lVar17 !\u003d 0)) {\n        lVar27 \u003d *(long *)(lVar27 + 0x40);\n        __ptr \u003d (void *)xmalloc(lVar27);\n        cVar10 \u003d bfd_get_section_contents();\n        if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n          uVar14 \u003d bfd_get_error();\n          bfd_errmsg(uVar14);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n          free(pcStack0000000000000038);\n          free(__ptr);\n        }\n        else {\n          uVar28 \u003d *(ulong *)(lVar17 + 0x40);\n          __ptr_00 \u003d (void *)xmalloc(uVar28 + 1);\n          in_stack_00000018 \u003d bfd_get_section_contents();\n          if (in_stack_00000018 \u003d\u003d \u0027\\0\u0027) {\n            uVar14 \u003d bfd_get_error();\n            bfd_errmsg(uVar14);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n            free(pcStack0000000000000038);\n          }\n          else {\n            *(undefined *)((long)__ptr_00 + uVar28) \u003d 0;\n            if ((pcStack0000000000000038 !\u003d (char *)0x0) ||\n               (pcStack0000000000000038 \u003d (char *)start_stab_constprop_0(),\n               pcStack0000000000000038 !\u003d (char *)0x0)) {\n              lStack00000000000000a0 \u003d 0;\n              lStack0000000000000088 \u003d 0;\n              for (pvVar39 \u003d __ptr; pvVar39 \u003c\u003d (void *)((long)__ptr + lVar27 + -0xc);\n                  pvVar39 \u003d (void *)((long)pvVar39 + 0xc)) {\n                uVar23 \u003d (**(code **)(unaff_R14[1] + 0x40))(pvVar39);\n                bVar2 \u003d *(byte *)((long)pvVar39 + 4);\n                uVar14 \u003d (**(code **)(unaff_R14[1] + 0x58))((long)pvVar39 + 6);\n                lVar17 \u003d (**(code **)(unaff_R14[1] + 0x40))((long)pvVar39 + 8);\n                if (bVar2 \u003d\u003d 0) {\n                  lStack0000000000000088 \u003d lStack00000000000000a0;\n                  lStack00000000000000a0 \u003d lStack00000000000000a0 + lVar17;\n                }\n                else {\n                  uVar25 \u003d (uVar23 \u0026 0xffffffff) + lStack0000000000000088;\n                  if (uVar25 \u003c uVar28) {\n                    pcVar35 \u003d (char *)((long)__ptr_00 + uVar25);\n                    pcStack0000000000000090 \u003d (char *)0x0;\n                    while( true ) {\n                      sVar20 \u003d strlen(pcVar35);\n                      if (((sVar20 \u003d\u003d 0) || (pcVar30 \u003d pcVar35 + (sVar20 - 1), *pcVar30 !\u003d \u0027\\\\\u0027)) ||\n                         ((ulong)((long)__ptr + lVar27) \u003c (long)pvVar39 + 0x10U)) goto LAB_001077fb;\n                      *pcVar30 \u003d \u0027\\0\u0027;\n                      pvVar39 \u003d (void *)((long)pvVar39 + 0xc);\n                      iVar12 \u003d (**(code **)(unaff_R14[1] + 0x40))(pvVar39);\n                      uVar23 \u003d (ulong)(uint)(iVar12 + (int)lStack0000000000000088);\n                      if (uVar28 \u003c\u003d uVar23) break;\n                      pcVar35 \u003d (char *)concat(pcVar35,(long)__ptr_00 + uVar23,0);\n                      *pcVar30 \u003d \u0027\\\\\u0027;\n                      free(pcStack0000000000000090);\n                      pcStack0000000000000090 \u003d pcVar35;\n                    }\n                    uVar19 \u003d *unaff_R14;\n                    pcVar30 \u003d (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar30,uVar19,puVar3,((long)pvVar39 - (long)__ptr) / 0xc);\nLAB_001077fb:\n                    save_stab((ulong)bVar2,uVar14,lVar17,pcVar35);\n                    cVar10 \u003d parse_stab(puStack0000000000000020,pcStack0000000000000038,bVar2);\n                    if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n                      stab_context();\n                      free_saved_stabs();\n                      free(pcStack0000000000000090);\n                      free(pcStack0000000000000038);\n                      free(__ptr);\n                      free(__ptr_00);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar19 \u003d *unaff_R14;\n                    pcVar35 \u003d (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx \u003d 0x%x, type \u003d %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar35,uVar19,puVar3,((long)pvVar39 - (long)__ptr) / 0xc,\n                            uVar23 \u0026 0xffffffff,(ulong)bVar2,((long)pvVar39 - (long)__ptr) % 0xc);\n                  }\n                }\n              }\n              free_saved_stabs();\n              free(__ptr);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_00);\n          free(__ptr);\n        }\n        goto LAB_00105981;\n      }\nLAB_001058eb:\n      ppuVar40 \u003d ppuVar40 + 2;\n    } while (ppuVar40 !\u003d (undefined **)\u0026DAT_00125c90);\n    if ((pcStack0000000000000038 !\u003d (char *)0x0) \u0026\u0026 (cVar10 \u003d finish_stab(), cVar10 \u003d\u003d \u0027\\0\u0027)) {\nLAB_00105981:\n      free(puStack0000000000000020);\n      goto LAB_00105588;\n    }\n    if (*(int *)(unaff_R14[1] + 8) \u003d\u003d 1) {\n      lVar27 \u003d 0;\n      for (plVar16 \u003d plVar6; plVar16 \u003c plVar6 + uStack0000000000000010; plVar16 \u003d plVar16 + 1) {\n        (**(code **)(unaff_R14[1] + 0x218))();\n        if (cStack0000000000000148 \u003d\u003d \u0027-\u0027) {\n          if (((lVar27 \u003d\u003d 0) \u0026\u0026 (lVar27 \u003d start_stab_constprop_0(), lVar27 \u003d\u003d 0)) ||\n             ((in_stack_00000150 \u003d\u003d (char *)0x0 || (*in_stack_00000150 \u003d\u003d \u0027\\0\u0027))))\n          goto LAB_00105981;\n          pcVar35 \u003d (char *)0x0;\n          pcVar30 \u003d in_stack_00000150;\n          while (((*pcVar30 !\u003d \u0027\\0\u0027 \u0026\u0026 (sVar20 \u003d strlen(pcVar30), pcVar30[sVar20 - 1] \u003d\u003d \u0027\\\\\u0027)) \u0026\u0026\n                 (plVar16 + 1 \u003c plVar6 + uStack0000000000000010))) {\n            pcVar22 \u003d (char *)xstrdup(pcVar30);\n            sVar20 \u003d strlen(pcVar22);\n            pcVar22[sVar20 - 1] \u003d \u0027\\0\u0027;\n            pcVar30 \u003d (char *)concat(pcVar22,*(undefined8 *)(plVar16[1] + 8),0);\n            free(pcVar22);\n            free(pcVar35);\n            plVar16 \u003d plVar16 + 1;\n            pcVar35 \u003d pcVar30;\n          }\n          save_stab(uStack0000000000000158,(int)sStack000000000000015a,in_stack_00000140,pcVar30);\n          in_stack_00000018 \u003d parse_stab(puStack0000000000000020,lVar27,uStack0000000000000158);\n          if (in_stack_00000018 \u003d\u003d \u0027\\0\u0027) {\n            stab_context();\n            free_saved_stabs();\n            goto LAB_00105981;\n          }\n        }\n      }\n      free_saved_stabs();\n      if ((lVar27 !\u003d 0) \u0026\u0026 (cVar10 \u003d finish_stab(), cVar10 \u003d\u003d \u0027\\0\u0027)) goto LAB_00105981;\n    }\n    if (in_stack_00000018 \u003d\u003d \u0027\\0\u0027) {\n      if ((*(int *)(unaff_R14[1] + 8) \u003d\u003d 2) \u0026\u0026 (uStack0000000000000010 !\u003d 0)) {\n        in_stack_00000140 \u003d (char *)0x0;\n        in_stack_000000c0 \u003d plVar6;\n        in_stack_000000d0 \u003d 0;\n        in_stack_000000d8 \u003d 0;\n        puVar31 \u003d (undefined8 *)\u0026stack0x00000148;\n        for (lVar27 \u003d 0x22; lVar27 !\u003d 0; lVar27 \u003d lVar27 + -1) {\n          *(undefined4 *)puVar31 \u003d 0;\n          puVar31 \u003d (undefined8 *)((long)puVar31 + (ulong)bVar42 * -8 + 4);\n        }\n        cVar10 \u003d \u0027\\0\u0027;\n        _uStack0000000000000048 \u003d (int *)0x0;\n        pcStack0000000000000038 \u003d (char *)0x0;\n        pcStack0000000000000090 \u003d (char *)0xffffffffffffffff;\n        in_stack_000000c8 \u003d uStack0000000000000010;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((long)uStack0000000000000010 \u003c\u003d in_stack_000000d0) goto LAB_00105590;\n            lVar27 \u003d plVar6[in_stack_000000d0];\n            cVar9 \u003d bfd_coff_get_syment();\n            lVar17 \u003d in_stack_000000d8;\n            if (cVar9 \u003d\u003d \u0027\\0\u0027) {\n              uVar14 \u003d bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar35 \u003d \"bfd_coff_get_syment failed: %s\";\n              goto LAB_00105968;\n            }\n            pcVar35 \u003d *(char **)(lVar27 + 8);\n            in_stack_000000d0 \u003d in_stack_000000d0 + 1;\n            in_stack_000000d8 \u003d (ulong)bStack0000000000000101 + 1 + in_stack_000000d8;\n            if ((bStack0000000000000101 !\u003d 0) \u0026\u0026 (cVar9 \u003d bfd_coff_get_auxent(), cVar9 \u003d\u003d \u0027\\0\u0027)) {\n              uVar14 \u003d bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar35 \u003d \"bfd_coff_get_auxent failed: %s\";\n              goto LAB_00105968;\n            }\n            if (pcStack0000000000000090 !\u003d (char *)lVar17) break;\n            if (bStack0000000000000100 !\u003d 0x67) {\n              cVar9 \u003d debug_set_filename(puStack0000000000000020);\n              if (cVar9 !\u003d \u0027\\0\u0027) break;\n              goto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            pcStack0000000000000090 \u003d (char *)in_stack_000000f0;\n            cVar9 \u003d debug_set_filename(puStack0000000000000020);\n            if (cVar9 \u003d\u003d \u0027\\0\u0027) goto LAB_00105981;\n          }\n          if ((char)bStack0000000000000100 \u003c \u0027\\0\u0027) {\n            if (bStack0000000000000100 \u003d\u003d 0xff) goto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            lVar24 \u003d parse_coff_type_lto_priv_0();\n            if (lVar24 \u003d\u003d 0) break;\n            cVar9 \u003d parse_coff_symbol_constprop_0_isra_0(\u0026stack0x00000140,lVar27,lVar17);\n          }\n          else {\n            if (bStack0000000000000100 \u003c 100) {\n              switch(bStack0000000000000100) {\n              case 3:\n                if (in_stack_000000f8._6_2_ \u003d\u003d 0) goto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulong)((uint)in_stack_000000f8._6_2_ \u0026 *(uint *)(unaff_R14[0x22] + 0x40)) !\u003d\n                    2L \u003c\u003c ((byte)*(undefined4 *)(unaff_R14[0x22] + 0x3c) \u0026 0x3f)) goto LAB_0010700a;\n                _uStack0000000000000048 \u003d (int *)(**(code **)(unaff_R14[1] + 0x238))();\n                pcStack0000000000000038 \u003d pcVar35;\n                goto switchD_00106e1a_caseD_68;\n              default:\n                goto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                goto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(bStack0000000000000100) {\n            case 100:\n              iVar12 \u003d strcmp(pcVar35,\".bb\");\n              if (iVar12 \u003d\u003d 0) {\n                cVar9 \u003d debug_start_block(puStack0000000000000020);\n              }\n              else {\n                iVar12 \u003d strcmp(pcVar35,\".eb\");\n                if (iVar12 !\u003d 0) goto switchD_00106e1a_caseD_68;\n                cVar9 \u003d debug_end_block(puStack0000000000000020);\n              }\n              break;\n            case 0x65:\n              iVar12 \u003d strcmp(pcVar35,\".bf\");\n              if (iVar12 \u003d\u003d 0) {\n                if (pcStack0000000000000038 !\u003d (char *)0x0) {\n                  lVar17 \u003d parse_coff_type_lto_priv_0();\n                  if ((lVar17 \u003d\u003d 0) ||\n                     (cVar10 \u003d debug_record_function(puStack0000000000000020), cVar10 \u003d\u003d \u0027\\0\u0027))\n                  goto LAB_00105981;\n                  if (_uStack0000000000000048 !\u003d (int *)0x0) {\n                    iVar12 \u003d 0;\n                    if (bStack0000000000000101 !\u003d 0) {\n                      iVar12 \u003d in_stack_00000118 - 1;\n                    }\n                    lVar27 \u003d *(long *)(*(long *)(lVar27 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar33 \u003d _uStack0000000000000048[4];\n                      if (iVar33 \u003d\u003d 0) break;\n                      cVar9 \u003d debug_record_line(puStack0000000000000020,iVar12 + iVar33,\n                                                *(long *)(_uStack0000000000000048 + 6) + lVar27);\n                      _uStack0000000000000048 \u003d _uStack0000000000000048 + 4;\n                      if (cVar9 \u003d\u003d \u0027\\0\u0027) goto LAB_00105981;\n                    }\n                  }\n                  _uStack0000000000000048 \u003d (int *)0x0;\n                  pcStack0000000000000038 \u003d (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar35 \u003d \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar12 \u003d strcmp(pcVar35,\".ef\");\n                if (iVar12 !\u003d 0) goto switchD_00106e1a_caseD_68;\n                if (cVar10 !\u003d \u0027\\0\u0027) {\n                  cVar10 \u003d debug_end_function(puStack0000000000000020);\n                  if (cVar10 \u003d\u003d \u0027\\0\u0027) goto LAB_00105981;\n                  cVar10 \u003d \u0027\\0\u0027;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar35 \u003d \"%ld: unexpected .ef\\n\";\n              }\n              uVar19 \u003d dcgettext(0,pcVar35,5);\n              non_fatal(uVar19);\n              goto LAB_00105981;\n            default:\n              goto LAB_0010700a;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (cVar9 !\u003d \u0027\\0\u0027);\n      }\n      else {\n        pcVar35 \u003d \"%s: no recognized debugging information\";\nLAB_00105968:\n        uVar19 \u003d dcgettext(0,pcVar35,5);\n        non_fatal(uVar19);\n      }\n      goto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)(param_7 + 0x44) \u0026 0x42) !\u003d 0) \u0026\u0026 ((*(uint *)(param_7 + 0x44) \u0026 1) \u003d\u003d 0)) {\n    if ((*(char *)(*(long *)(param_7 + 8) + 0x20) \u003d\u003d \u0027\\0\u0027) \u0026\u0026 (keep_section_symbols \u003d\u003d \u0027\\0\u0027)) {\n      if (uStack0000000000000010 !\u003d 0) {\n        plVar6 \u003d isympp + uStack0000000000000010;\n        plVar16 \u003d isympp;\n        do {\n          uVar11 \u003d *(uint *)(*plVar16 + 0x18);\n          if ((uVar11 \u0026 0x1000000) !\u003d 0) {\n            *(uint *)(*plVar16 + 0x18) \u003d uVar11 \u0026 0xfeffffff;\n          }\n          plVar16 \u003d plVar16 + 1;\n        } while (plVar6 !\u003d plVar16);\n      }\n    }\n    else {\n      for (lVar27 \u003d *(long *)(param_7 + 0x90); lVar27 !\u003d 0; lVar27 \u003d *(long *)(lVar27 + 8)) {\n        if (*(long *)(lVar27 + 0xe8) !\u003d 0) {\n          puVar1 \u003d (uint *)(*(long *)(lVar27 + 0xe8) + 0x18);\n          *puVar1 \u003d *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((strip_symbols \u003d\u003d 2) || (strip_symbols \u003d\u003d 7)) {\nLAB_001059fe:\n    if (strip_symbols \u003d\u003d 7) {\nLAB_00105a3b:\n      plVar16 \u003d (long *)xmalloc();\n      plVar6 \u003d isympp;\n      uStack0000000000000048 \u003d *(uint *)((long)unaff_R14 + 0x44) \u0026 0x42;\n      osympp \u003d plVar16;\n      if (uStack0000000000000010 \u003d\u003d 0) {\n        uVar28 \u003d 0;\n      }\n      else {\n        uVar28 \u003d 0;\n        _in_stack_00000018 \u003d 0;\n        do {\n          iVar12 \u003d add_symbols;\n          plVar4 \u003d (long *)plVar6[_in_stack_00000018];\n          pcVar5 \u003d (code *)plVar4[4];\n          uVar11 \u003d *(uint *)(plVar4 + 3);\n          pcVar35 \u003d (char *)plVar4[1];\n          pcVar30 \u003d pcVar35;\n          if (add_sym_list !\u003d (undefined8 *)0x0) {\n            iVar33 \u003d 0;\n            puVar31 \u003d add_sym_list;\n            while ((iVar33 \u003c iVar12 \u0026\u0026 (pcVar22 \u003d (char *)puVar31[5], pcVar22 !\u003d (char *)0x0))) {\n              if (pcVar22 !\u003d \"\") {\n                iVar15 \u003d strcmp(pcVar22,pcVar35);\n                if (iVar15 \u003d\u003d 0) {\n                  free(pcVar22);\n                  uVar23 \u003d uVar28 + 1;\n                  puVar31[5] \u003d \"\";\n                  lVar27 \u003d create_new_symbol(puVar31);\n                  uVar19 \u003d redefine_specific_htab;\n                  plVar16[uVar28] \u003d lVar27;\n                  lVar27 \u003d htab_elements(uVar19);\n                  if ((lVar27 !\u003d 0) || (section_rename_list !\u003d (char **)0x0)) goto LAB_001064eb;\n                  goto LAB_00105af8;\n                }\n                puVar31 \u003d (undefined8 *)*puVar31;\n              }\n              iVar33 \u003d iVar33 + 1;\n            }\n          }\n          lVar27 \u003d htab_elements(redefine_specific_htab);\n          uVar23 \u003d uVar28;\n          if ((lVar27 !\u003d 0) || (section_rename_list !\u003d (char **)0x0)) {\n            if (pcVar35 !\u003d (char *)0x0) {\nLAB_001064eb:\n              if (((*pcVar35 \u003d\u003d \u0027_\u0027) \u0026\u0026 (pcVar35[1] \u003d\u003d \u0027_\u0027)) \u0026\u0026\n                 (iVar12 \u003d strcmp(pcVar35 + (pcVar35[2] \u003d\u003d \u0027_\u0027),\"__gnu_lto_slim\"), iVar12 \u003d\u003d 0)) {\n                uVar19 \u003d dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\"\n                                   ,5);\n                    \n                fatal(uVar19);\n              }\n            }\n            _cStack0000000000000148 \u003d 0;\n            in_stack_00000140 \u003d pcVar35;\n            lVar27 \u003d htab_find(redefine_specific_htab);\n            if (((lVar27 \u003d\u003d 0) || (pcVar30 \u003d *(char **)(lVar27 + 8), pcVar35 \u003d\u003d pcVar30)) \u0026\u0026\n               (pcVar30 \u003d pcVar35, ppcVar38 \u003d section_rename_list, (uVar11 \u0026 0x100) !\u003d 0)) {\n              for (; ppcVar38 !\u003d (char **)0x0; ppcVar38 \u003d (char **)ppcVar38[3]) {\n                iVar12 \u003d strcmp(*ppcVar38,pcVar35);\n                if (iVar12 \u003d\u003d 0) {\n                  pcVar30 \u003d ppcVar38[1];\n                  break;\n                }\n              }\n            }\n            plVar4[1] \u003d (long)pcVar30;\n            cVar10 \u003d *pcVar30;\n            if (cVar10 !\u003d \u0027\\0\u0027) goto LAB_00105b11;\nLAB_00106557:\n            pcVar35 \u003d prefix_symbols_string;\n            if ((change_leading_char !\u003d \u0027\\0\u0027) \u0026\u0026 (*(char *)(*(long *)(param_7 + 8) + 0x1c) !\u003d \u0027\\0\u0027))\n            {\n              lVar27 \u003d unaff_R14[1];\n              cVar10 \u003d \u0027\\0\u0027;\n              goto LAB_0010668d;\n            }\n            goto joined_r0x00106565;\n          }\nLAB_00105af8:\n          cVar10 \u003d *pcVar35;\n          if (cVar10 \u003d\u003d \u0027\\0\u0027) goto LAB_00106557;\nLAB_00105b11:\n          pcVar35 \u003d prefix_symbols_string;\n          lVar27 \u003d unaff_R14[1];\n          if (*(char *)(lVar27 + 0x1c) \u003d\u003d cVar10) {\n            if (change_leading_char \u003d\u003d \u0027\\0\u0027) {\n              if ((remove_leading_char \u003d\u003d \u0027\\0\u0027) ||\n                 ((((uVar11 \u0026 0x82) \u003d\u003d 0 \u0026\u0026 (pcVar5 !\u003d bfd_map_over_sections)) \u0026\u0026\n                  ((*(byte *)(plVar4[4] + 0x25) \u0026 0x10) \u003d\u003d 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n              pcVar30 \u003d pcVar30 + 1;\n              plVar4[1] \u003d (long)pcVar30;\n              goto joined_r0x00106565;\n            }\n            cVar10 \u003d *(char *)(*(long *)(param_7 + 8) + 0x1c);\n            if (cVar10 \u003d\u003d \u0027\\0\u0027) goto LAB_0010677d;\n            if (prefix_symbols_string !\u003d (char *)0x0) {\n              pcVar30 \u003d pcVar30 + 1;\n              plVar4[1] \u003d (long)pcVar30;\n              sVar20 \u003d strlen(pcVar30);\n              lVar27 \u003d sVar20 + 2;\nLAB_001066bc:\n              sVar20 \u003d strlen(pcVar35);\n              pcVar35 \u003d (char *)xmalloc(sVar20 + lVar27);\n              goto LAB_001066d0;\n            }\n            *pcVar30 \u003d cVar10;\n            plVar4[1] \u003d (long)pcVar30;\n            uVar28 \u003d uVar23;\n          }\n          else {\n            if ((change_leading_char \u003d\u003d \u0027\\0\u0027) || (*(char *)(*(long *)(param_7 + 8) + 0x1c) \u003d\u003d \u0027\\0\u0027))\n            {\njoined_r0x00106565:\n              uVar28 \u003d uVar23;\n              if (pcVar35 \u003d\u003d (char *)0x0) goto LAB_00105b32;\n              sVar20 \u003d strlen(pcVar30);\n              sVar21 \u003d strlen(pcVar35);\n              pcVar22 \u003d (char *)xmalloc(sVar21 + sVar20 + 1);\n              pcVar35 \u003d pcVar22;\n            }\n            else {\nLAB_0010668d:\n              pcVar35 \u003d prefix_symbols_string;\n              if ((*(char *)(lVar27 + 0x1c) !\u003d \u0027\\0\u0027) \u0026\u0026 (cVar10 !\u003d *(char *)(lVar27 + 0x1c)))\n              goto joined_r0x00106565;\n              sVar20 \u003d strlen(pcVar30);\n              lVar27 \u003d sVar20 + 2;\n              if (pcVar35 !\u003d (char *)0x0) goto LAB_001066bc;\n              pcVar35 \u003d (char *)xmalloc(lVar27);\nLAB_001066d0:\n              pcVar22 \u003d pcVar35 + 1;\n              *pcVar35 \u003d *(char *)(*(long *)(param_7 + 8) + 0x1c);\n            }\n            __s \u003d prefix_symbols_string;\n            if (prefix_symbols_string !\u003d (char *)0x0) {\n              strcpy(pcVar22,prefix_symbols_string);\n              sVar20 \u003d strlen(__s);\n              pcVar22 \u003d pcVar22 + sVar20;\n            }\n            strcpy(pcVar22,pcVar30);\n            plVar4[1] \u003d (long)pcVar35;\n            pcVar30 \u003d pcVar35;\n            uVar28 \u003d uVar23;\n          }\nLAB_00105b32:\n          if (strip_symbols \u003d\u003d 7) goto LAB_001067a8;\n          if (((uVar11 \u0026 0x20) \u003d\u003d 0) \u0026\u0026\n             (((uVar11 \u0026 0x100) \u003d\u003d 0 ||\n              ((*(byte *)(**(long **)(plVar4[4] + 0xf0) + 0x18) \u0026 0x20) \u003d\u003d 0)))) {\n            if (((uStack0000000000000048 \u003d\u003d 0) \u0026\u0026\n                (((uVar11 \u0026 0x82) !\u003d 0 || ((*(byte *)(plVar4[4] + 0x25) \u0026 0x10) !\u003d 0)))) ||\n               (iVar12 \u003d bfd_decode_symclass(plVar4), iVar12 \u003d\u003d 0x49)) {\nLAB_00105be2:\n              if (wildcard \u003d\u003d \u0027\\0\u0027) {\n                lVar27 \u003d htab_find();\n                if (lVar27 \u003d\u003d 0) goto LAB_00105c07;\n              }\n              else {\n                _cStack0000000000000148 \u003d _cStack0000000000000148 \u0026 0xffffffffffffff00;\n                in_stack_00000140 \u003d pcVar30;\n                htab_traverse(strip_specific_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n                if (cStack0000000000000148 \u003d\u003d \u0027\\0\u0027) goto LAB_00105c07;\n              }\n            }\n            else if ((((uVar11 \u0026 0x82) \u003d\u003d 0) \u0026\u0026 (pcVar5 !\u003d bfd_map_over_sections)) \u0026\u0026\n                    ((*(byte *)(plVar4[4] + 0x25) \u0026 0x10) \u003d\u003d 0)) {\n              if ((uVar11 \u0026 4) \u003d\u003d 0) {\n                if (((*(int *)(unaff_R14[1] + 8) !\u003d 2) ||\n                    (lVar27 \u003d *(long *)(plVar4[4] + 0xd0), lVar27 \u003d\u003d 0)) ||\n                   (*(long *)(lVar27 + 0x40) \u003d\u003d 0)) {\n                  if ((strip_symbols \u003d\u003d 3) || (discard_locals \u003d\u003d 2)) goto LAB_001067a8;\n                  if (discard_locals \u003d\u003d 1) {\n                    cVar10 \u003d bfd_is_local_label(unaff_R14);\n                    goto joined_r0x00106a11;\n                  }\n                }\n                goto LAB_00105be2;\n              }\n              cVar10 \u003d convert_debugging;\n              if (1 \u003c strip_symbols - 2U) {\njoined_r0x00106a11:\n                if (cVar10 \u003d\u003d \u0027\\0\u0027) goto LAB_00105be2;\n              }\n            }\n            else if (strip_symbols !\u003d 3) goto LAB_00105be2;\n            goto LAB_001067a8;\n          }\n          if (wildcard \u003d\u003d \u0027\\0\u0027) {\n            lVar27 \u003d htab_find();\n            if (lVar27 !\u003d 0) {\nLAB_0010687f:\n              uVar19 \u003d dcgettext(0,\"not stripping symbol `%s\\\u0027 because it is named in a relocation\",\n                                 5);\n              non_fatal(uVar19);\n              status \u003d 1;\n            }\n          }\n          else {\n            _cStack0000000000000148 \u003d _cStack0000000000000148 \u0026 0xffffffffffffff00;\n            in_stack_00000140 \u003d pcVar30;\n            htab_traverse(strip_specific_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n            if (cStack0000000000000148 !\u003d \u0027\\0\u0027) goto LAB_0010687f;\n          }\n          if ((uVar11 \u0026 0x20) \u003d\u003d 0) {\nLAB_00105c07:\n            if (wildcard !\u003d \u0027\\0\u0027) {\n              _cStack0000000000000148 \u003d _cStack0000000000000148 \u0026 0xffffffffffffff00;\n              in_stack_00000140 \u003d pcVar30;\n              htab_traverse(strip_unneeded_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n              if (cStack0000000000000148 !\u003d \u0027\\0\u0027) goto LAB_001067a8;\n              goto LAB_00105c2c;\n            }\n            lVar27 \u003d htab_find();\n            if (lVar27 \u003d\u003d 0) goto LAB_00105c2c;\nLAB_001067a8:\n            if ((keep_file_symbols !\u003d \u0027\\0\u0027) \u0026\u0026 ((uVar11 \u0026 0x4000) !\u003d 0)) goto LAB_00105c2c;\n            if (wildcard \u003d\u003d \u0027\\0\u0027) {\n              lVar27 \u003d htab_find();\n              if (lVar27 !\u003d 0) goto LAB_00105c2c;\n            }\n            else {\n              _cStack0000000000000148 \u003d _cStack0000000000000148 \u0026 0xffffffffffffff00;\n              in_stack_00000140 \u003d pcVar30;\n              htab_traverse(keep_specific_htab,is_specified_symbol_predicate,\u0026stack0x00000140);\n              if (cStack0000000000000148 !\u003d \u0027\\0\u0027) goto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            cVar10 \u003d is_strip_section_isra_0(plVar4[4]);\n            if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n              if (((uVar11 \u0026 0x800002) \u003d\u003d 0) \u0026\u0026 (pcVar5 !\u003d bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uVar11 \u0026 0x82) !\u003d 0) {\n                  cVar10 \u003d is_specified_symbol(pcVar30);\n                  if ((cVar10 \u003d\u003d \u0027\\0\u0027) \u0026\u0026\n                     ((lVar27 \u003d htab_elements(keepglobal_specific_htab), lVar27 \u003d\u003d 0 ||\n                      (cVar10 \u003d is_specified_symbol(pcVar30), cVar10 !\u003d \u0027\\0\u0027)))) {\n                    if (((((localize_hidden \u003d\u003d \u0027\\0\u0027) ||\n                          (uVar13 \u003d *(uint *)(plVar4 + 3), (uVar13 \u0026 0x200000) !\u003d 0)) ||\n                         (lVar27 \u003d *plVar4, lVar27 \u003d\u003d 0)) ||\n                        ((*(int *)(*(long *)(lVar27 + 8) + 8) !\u003d 5 ||\n                         (*(long *)(lVar27 + 0x110) \u003d\u003d 0)))) ||\n                       (1 \u003c (*(byte *)((long)plVar4 + 0x49) \u0026 3) - 1)) goto joined_r0x00105ca2;\n                  }\n                  else {\n                    uVar13 \u003d *(uint *)(plVar4 + 3);\n                  }\n                  *(uint *)(plVar4 + 3) \u003d uVar13 \u0026 0xffffff7d | 1;\n                }\njoined_r0x00105ca2:\n                if (((uVar11 \u0026 1) !\u003d 0) \u0026\u0026 (cVar10 \u003d is_specified_symbol(pcVar30), cVar10 !\u003d \u0027\\0\u0027))\n                {\n                  *(uint *)(plVar4 + 3) \u003d *(uint *)(plVar4 + 3) \u0026 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((weaken !\u003d \u0027\\0\u0027) || (cVar10 \u003d is_specified_symbol(pcVar30), cVar10 !\u003d \u0027\\0\u0027)) {\n                  *(uint *)(plVar4 + 3) \u003d *(uint *)(plVar4 + 3) \u0026 0xff7ffffd | 0x80;\n                }\n                if (pcVar5 !\u003d bfd_map_over_sections) goto LAB_00105c5f;\n              }\n              plVar16[uVar28] \u003d (long)plVar4;\n              uVar28 \u003d uVar28 + 1;\n            }\n          }\n          _in_stack_00000018 \u003d _in_stack_00000018 + 1;\n        } while (uStack0000000000000010 !\u003d _in_stack_00000018);\n      }\n      if (add_sym_list !\u003d (undefined8 *)0x0) {\n        puVar31 \u003d add_sym_list;\n        iVar12 \u003d add_symbols;\n        for (lVar27 \u003d 0; lVar27 \u003c iVar12; lVar27 \u003d lVar27 + 1) {\n          pcVar35 \u003d (char *)puVar31[5];\n          if (pcVar35 \u003d\u003d (char *)0x0) {\n            plVar6 \u003d plVar16 + uVar28;\n            uVar28 \u003d uVar28 + 1;\n            lVar17 \u003d create_new_symbol(puVar31,param_7);\n            *plVar6 \u003d lVar17;\n            iVar12 \u003d add_symbols;\n          }\n          else if (pcVar35 !\u003d \"\") {\n            uVar19 \u003d dcgettext(0,\"\\\u0027before\u003d%s\\\u0027 not found\",5);\n                    \n            fatal(uVar19,pcVar35);\n          }\n          puVar31 \u003d (undefined8 *)*puVar31;\n        }\n      }\n      bVar41 \u003d convert_debugging \u003d\u003d \u0027\\0\u0027;\n      plVar16[uVar28] \u003d 0;\n      if ((bVar41) || (puStack0000000000000020 \u003d\u003d (undefined4 *)0x0)) {\nLAB_00105cfa:\n        uStack0000000000000010 \u003d uVar28 \u0026 0xffffffff;\n        goto LAB_00105710;\n      }\n      iVar12 \u003d *(int *)(*(undefined8 **)(param_7 + 8) + 1);\n      if ((iVar12 \u003d\u003d 5) || (iVar12 \u003d\u003d 2)) {\n        in_stack_000000e0 \u003d (void *)0x0;\n        cVar10 \u003d write_stabs_in_sections_debugging_info_constprop_0\n                           (param_7,puStack0000000000000020,\u0026stack0x000000c0,\u0026stack0x00000110,\n                            \u0026stack0x000000e0,\u0026stack0x00000140);\n        if (cVar10 !\u003d \u0027\\0\u0027) {\n          lVar27 \u003d bfd_make_section_with_flags(param_7,\".stab\",0x2108);\n          lVar17 \u003d bfd_make_section_with_flags(param_7,\".stabstr\",0x2108);\n          if ((((lVar27 \u003d\u003d 0) || (lVar17 \u003d\u003d 0)) ||\n              (cVar10 \u003d bfd_set_section_size(lVar27,in_stack_00000110), cVar10 \u003d\u003d \u0027\\0\u0027)) ||\n             (cVar10 \u003d bfd_set_section_size(lVar17,in_stack_00000140), cVar10 \u003d\u003d \u0027\\0\u0027)) {\n            pcVar35 \u003d \"can\\\u0027t create debugging section\";\n          }\n          else {\n            *(undefined4 *)(lVar27 + 0x7c) \u003d 2;\n            *(undefined4 *)(lVar17 + 0x7c) \u003d 0;\n            cVar10 \u003d bfd_set_section_contents(param_7,lVar27,in_stack_000000c0,0,in_stack_00000110);\n            if ((cVar10 !\u003d \u0027\\0\u0027) \u0026\u0026\n               (cVar10 \u003d bfd_set_section_contents\n                                   (param_7,lVar17,in_stack_000000e0,0,in_stack_00000140),\n               cVar10 !\u003d \u0027\\0\u0027)) {\n              free(puStack0000000000000020);\n              goto LAB_00105cfa;\n            }\n            pcVar35 \u003d \"can\\\u0027t set debugging section contents\";\n          }\n          uVar19 \u003d dcgettext(0,pcVar35,5);\n          bfd_nonfatal_message(0,param_7,0,uVar19);\n          free(in_stack_000000e0);\n          free(puStack0000000000000020);\n          goto LAB_00105d96;\n        }\n      }\n      else {\n        uVar19 \u003d **(undefined8 **)(param_7 + 8);\n        uVar18 \u003d dcgettext(0,\"don\\\u0027t know how to write debugging information for %s\",5);\n        bfd_nonfatal_message(0,param_7,0,uVar18,uVar19);\n      }\n      free(puStack0000000000000020);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections();\n      iVar12 \u003d bfd_get_error();\n      if (iVar12 \u003d\u003d 0) goto LAB_00105a3b;\n    }\nLAB_00105d96:\n    status \u003d 1;\n  }\n  else {\n    if ((strip_symbols - 3U \u003c 4) || ((discard_locals !\u003d 0 || (localize_hidden !\u003d \u0027\\0\u0027))))\n    goto LAB_00105a07;\n    lVar27 \u003d htab_elements(strip_specific_htab);\n    if (((lVar27 !\u003d 0) ||\n        (((((((lVar27 \u003d htab_elements(keep_specific_htab), lVar27 !\u003d 0 ||\n              (lVar27 \u003d htab_elements(localize_specific_htab), lVar27 !\u003d 0)) ||\n             (lVar27 \u003d htab_elements(globalize_specific_htab), lVar27 !\u003d 0)) ||\n            ((lVar27 \u003d htab_elements(keepglobal_specific_htab), lVar27 !\u003d 0 ||\n             (lVar27 \u003d htab_elements(weaken_specific_htab), lVar27 !\u003d 0)))) ||\n           (lVar27 \u003d htab_elements(redefine_specific_htab), lVar27 !\u003d 0)) ||\n          (((prefix_symbols_string !\u003d (char *)0x0 || (sections_removed !\u003d \u0027\\0\u0027)) ||\n           ((sections_copied !\u003d \u0027\\0\u0027 ||\n            (((convert_debugging !\u003d \u0027\\0\u0027 || (change_leading_char !\u003d \u0027\\0\u0027)) ||\n             (remove_leading_char !\u003d \u0027\\0\u0027)))))))) ||\n         ((section_rename_list !\u003d (char **)0x0 || (weaken !\u003d \u0027\\0\u0027)))))) || (add_symbols !\u003d 0))\n    goto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(param_7,osympp,uStack0000000000000010 \u0026 0xffffffff);\n    bfd_map_over_sections(unaff_R14,copy_relocations_in_section,param_7);\n    bfd_map_over_sections(unaff_R14,copy_section,param_7);\n    for (puVar31 \u003d add_sections; puVar37 \u003d update_sections, puVar31 !\u003d (undefined8 *)0x0;\n        puVar31 \u003d (undefined8 *)*puVar31) {\n      cVar10 \u003d bfd_set_section_contents(param_7,puVar31[5],puVar31[4],0,puVar31[3]);\n      if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n        bfd_nonfatal_message(0,param_7,puVar31[5],0);\n        return 0;\n      }\n    }\n    for (; puVar37 !\u003d (undefined8 *)0x0; puVar37 \u003d (undefined8 *)*puVar37) {\n      uVar19 \u003d *(undefined8 *)(puVar37[5] + 0x60);\n      cVar10 \u003d bfd_set_section_contents(param_7,uVar19,puVar37[4],0,puVar37[3]);\n      if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n        bfd_nonfatal_message(0,param_7,uVar19,0);\n        return 0;\n      }\n    }\n    if (__ptr_01 \u003d\u003d (long **)0x0) {\n      if ((merge_notes !\u003d \u0027\\0\u0027) \u0026\u0026 (is_strip \u003d\u003d 0)) {\n        uVar19 \u003d *unaff_R14;\n        uVar18 \u003d dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n        non_fatal(uVar18,uVar19);\n      }\n    }\n    else {\n      pplVar34 \u003d (long **)0x0;\n      for (puVar31 \u003d *(undefined8 **)(param_7 + 0x90); puVar31 !\u003d (undefined8 *)0x0;\n          puVar31 \u003d (undefined8 *)puVar31[1]) {\n        if (((merge_notes !\u003d \u0027\\0\u0027) \u0026\u0026 (*(int *)(*(long *)(param_7 + 8) + 8) \u003d\u003d 5)) \u0026\u0026\n           ((*(int *)(puVar31[0x1a] + 4) \u003d\u003d 7 \u0026\u0026\n            (cVar10 \u003d startswith_lto_priv_0_lto_priv_0(*puVar31,\".gnu.build.attributes\"),\n            cVar10 !\u003d \u0027\\0\u0027)))) {\n          if (pplVar34 \u003d\u003d (long **)0x0) {\n            pplVar34 \u003d __ptr_01;\n          }\n          pplVar29 \u003d __ptr_01;\n          if ((undefined8 *)(*pplVar34)[0xc] \u003d\u003d puVar31) {\nLAB_0010625f:\n            pcVar35 \u003d \"error: failed to merge notes\";\n            if (pplVar34[1] !\u003d (long *)0x0) {\n              cVar10 \u003d bfd_set_section_contents(param_7,puVar31,pplVar34[1],0,pplVar34[2]);\n              if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n                uVar19 \u003d dcgettext(0,\"error: failed to copy merged notes into output\",5);\n                bfd_nonfatal_message(0,param_7,puVar31,uVar19);\n                return 0;\n              }\n              pplVar34 \u003d (long **)pplVar34[3];\n              goto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              pplVar34 \u003d pplVar29;\n              if ((undefined8 *)(*pplVar29)[0xc] \u003d\u003d puVar31) goto LAB_0010625f;\n              pplVar34 \u003d (long **)pplVar29[3];\n              pplVar29 \u003d pplVar34;\n            } while (pplVar34 !\u003d (long **)0x0);\n            pcVar35 \u003d \"error: failed to locate merged notes\";\n          }\n          uVar19 \u003d dcgettext(0,pcVar35,5);\n          bfd_nonfatal_message(0,param_7,puVar31,uVar19);\n        }\nLAB_001061be:\n      }\n      do {\n        pplVar34 \u003d (long **)__ptr_01[3];\n        free(__ptr_01[1]);\n        free(__ptr_01);\n        __ptr_01 \u003d pplVar34;\n      } while (pplVar34 !\u003d (long **)0x0);\n    }\n    if ((gnu_debuglink_filename \u003d\u003d 0) ||\n       (cVar10 \u003d bfd_fill_in_gnu_debuglink_section(param_7,lStack0000000000000078),\n       lVar27 \u003d gnu_debuglink_filename, cVar10 !\u003d \u0027\\0\u0027)) {\n      uVar11 \u003d (**(code **)(*(long *)(param_7 + 8) + 0x140))(unaff_R14);\n      uVar28 \u003d (ulong)uVar11;\n      if ((char)uVar11 !\u003d \u0027\\0\u0027) {\n        if (use_alt_mach_code \u003d\u003d 0) {\n          return uVar28;\n        }\n        cVar10 \u003d bfd_alt_mach_code(param_7,use_alt_mach_code \u0026 0xffffffff);\n        uVar23 \u003d use_alt_mach_code;\n        if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n          uVar19 \u003d dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n          non_fatal(uVar19,uVar23);\n          if (*(int *)(*(long *)(param_7 + 8) + 8) \u003d\u003d 5) {\n            uVar19 \u003d dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n            non_fatal(uVar19);\n            *(short *)(*(long *)(param_7 + 0x110) + 0x3a) \u003d (short)use_alt_mach_code;\n            return uVar28;\n          }\n          uVar19 \u003d dcgettext(0,\"ignoring the alternative value\",5);\n          non_fatal(uVar19);\n          return uVar28;\n        }\n        return uVar28;\n      }\n      uVar19 \u003d dcgettext(0,\"error copying private BFD data\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar19);\n    }\n    else {\n      uVar19 \u003d dcgettext(0,\"cannot fill debug link section `%s\\\u0027\",5);\n      bfd_nonfatal_message(0,param_7,0,uVar19,lVar27);\n    }\n  }\n  return 0;\nLAB_00115187:\n  if ((((*(int *)(unaff_R14[1] + 8) \u003d\u003d 5) \u0026\u0026 (*(int *)((long)pplVar34[0x1a] + 4) \u003d\u003d 7)) \u0026\u0026\n      (cVar10 \u003d startswith_lto_priv_0_lto_priv_0(*pplVar34), cVar10 !\u003d \u0027\\0\u0027)) \u0026\u0026\n     ((pplVar34[0xc] !\u003d (long *)0x0 \u0026\u0026 (plVar6 \u003d pplVar34[8], plVar6 !\u003d (long *)0x0)))) {\n    pplVar29 \u003d (long **)xmalloc(0x20);\n    pplVar29[1] \u003d (long *)0x0;\n    cVar10 \u003d bfd_get_full_section_contents();\n    if (cVar10 \u003d\u003d \u0027\\0\u0027) {\n      dcgettext(0,\"warning: could not load note section\",5);\n      bfd_nonfatal_message(0);\n      free(pplVar29);\n    }\n    else {\n      plVar16 \u003d (long *)merge_gnu_build_notes();\n      pplVar29[2] \u003d plVar16;\n      if ((plVar16 \u003d\u003d plVar6) || (cVar10 \u003d bfd_set_section_size(pplVar34[0xc]), cVar10 !\u003d \u0027\\0\u0027)) {\n        pplVar29[3] \u003d (long *)__ptr_01;\n        *pplVar29 \u003d (long *)pplVar34;\n        __ptr_01 \u003d pplVar29;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        bfd_nonfatal_message(0,param_7,pplVar34);\n        free(pplVar29[1]);\n        free(pplVar29);\n      }\n    }\n  }\n  pplVar34 \u003d (long **)pplVar34[1];\n  puVar31 \u003d dump_sections;\n  if (pplVar34 \u003d\u003d (long **)0x0) goto joined_r0x001151c7;\n  goto LAB_001151ab;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107976"
      ],
      "called": [
        "non_fatal",
        "FUN_00107880",
        "dcgettext",
        "bfd_get_archive_filename"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setup_section": {
      "entrypoint": "0x00115530",
      "current_name": "setup_section",
      "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nvoid setup_section(long param_1,char **param_2,long param_3)\n\n{\n  long lVar1;\n  char *pcVar2;\n  char **ppcVar3;\n  char cVar4;\n  int iVar5;\n  uint uVar6;\n  size_t sVar7;\n  size_t sVar8;\n  long lVar9;\n  char *pcVar10;\n  char *pcVar11;\n  char *pcVar12;\n  uint uVar13;\n  bool bVar14;\n  long local_50;\n  char *local_48;\n  long local_40 [2];\n  \n  cVar4 \u003d is_strip_section_isra_0(param_2);\n  if (cVar4 !\u003d \u0027\\0\u0027) {\n    return;\n  }\n  pcVar10 \u003d *param_2;\n  uVar13 \u003d *(uint *)((long)param_2 + 0x24);\n  local_48 \u003d pcVar10;\n  ppcVar3 \u003d section_rename_list;\n  if (*(int *)(*(long *)(param_1 + 8) + 8) !\u003d *(int *)(*(long *)(param_3 + 8) + 8)) {\n    uVar13 \u003d uVar13 \u0026 *(uint *)(*(long *)(param_1 + 8) + 0x18) \u0026\n             *(uint *)(*(long *)(param_3 + 8) + 0x18);\n  }\n  for (; ppcVar3 !\u003d (char **)0x0; ppcVar3 \u003d (char **)ppcVar3[3]) {\n    iVar5 \u003d strcmp(*ppcVar3,pcVar10);\n    if (iVar5 \u003d\u003d 0) {\n      if (*(uint *)(ppcVar3 + 2) !\u003d 0xffffffff) {\n        uVar13 \u003d *(uint *)(ppcVar3 + 2);\n      }\n      if (pcVar10 !\u003d ppcVar3[1]) {\n        local_48 \u003d ppcVar3[1];\n        uVar13 \u003d check_new_section_flags(uVar13,param_3);\n      }\n      break;\n    }\n  }\n  if (((prefix_alloc_sections_string !\u003d (char *)0x0) \u0026\u0026\n      (pcVar10 \u003d prefix_alloc_sections_string, (*(byte *)((long)param_2 + 0x24) \u0026 1) !\u003d 0)) ||\n     (pcVar10 \u003d prefix_sections_string, prefix_sections_string !\u003d (char *)0x0)) {\n    sVar7 \u003d strlen(pcVar10);\n    sVar8 \u003d strlen(local_48);\n    pcVar12 \u003d (char *)xmalloc(sVar7 + 1 + sVar8);\n    pcVar10 \u003d strcpy(pcVar12,pcVar10);\n    local_48 \u003d strcat(pcVar10,local_48);\n  }\n  lVar9 \u003d find_section_list(*param_2,0,0x80);\n  bVar14 \u003d false;\n  if (lVar9 \u003d\u003d 0) {\n    if ((strip_symbols \u003d\u003d 4) \u0026\u0026 ((uVar13 \u0026 0x2000001) !\u003d 0)) {\n      iVar5 \u003d *(int *)(*(long *)(param_1 + 8) + 8);\n      if (iVar5 \u003d\u003d 5) {\n        if (*(int *)(param_2[0x1a] + 4) !\u003d 7) {\nLAB_00115771:\n          if (*(int *)(*(long *)(param_3 + 8) + 8) \u003d\u003d 5) {\n            bVar14 \u003d (uVar13 \u0026 0x2000000) \u003d\u003d 0;\n            uVar6 \u003d ~((-(uint)((uVar13 \u0026 0x2000000) \u003d\u003d 0) \u0026 0x2000100) + 2);\n            *(uint *)((long)param_2 + 0x24) \u003d *(uint *)((long)param_2 + 0x24) \u0026 uVar6;\n          }\n          else {\n            uVar6 \u003d 0xfdfffefd;\n          }\n          uVar13 \u003d uVar13 \u0026 uVar6;\n        }\n      }\n      else if ((iVar5 !\u003d 2) || (iVar5 \u003d strcmp(*param_2,\".buildid\"), iVar5 !\u003d 0)) goto LAB_00115771;\n    }\n  }\n  else {\n    uVar13 \u003d check_new_section_flags(uVar13 \u0026 0x104 | *(uint *)(lVar9 + 0x28),param_3,*param_2);\n  }\n  cVar4 \u003d bfd_convert_section_setup(param_1,param_2,param_3,\u0026local_48,local_40);\n  if (cVar4 \u003d\u003d \u0027\\0\u0027) {\n    pcVar10 \u003d (char *)0x0;\n    local_50 \u003d dcgettext(0,\"failed to create output section\",5);\n    goto LAB_001080d1;\n  }\n  pcVar10 \u003d (char *)bfd_make_section_anyway_with_flags(param_3,local_48,uVar13);\n  if (pcVar10 \u003d\u003d (char *)0x0) {\n    local_50 \u003d dcgettext(0,\"failed to create output section\",5);\n    goto LAB_001080d1;\n  }\n  if (copy_byte \u003c 0) {\n    if (extract_symbol !\u003d \u0027\\0\u0027) {\n      local_40[0] \u003d 0;\n      goto LAB_001158e7;\n    }\n    cVar4 \u003d bfd_set_section_size(pcVar10,local_40[0]);\n    if (cVar4 \u003d\u003d \u0027\\0\u0027) {\n      setup_section_cold();\n      return;\n    }\n  }\n  else {\n    local_40[0] \u003d ((((long)interleave - 1U) + local_40[0]) / (ulong)(long)interleave) *\n                  (long)copy_width;\nLAB_001158e7:\n    cVar4 \u003d bfd_set_section_size(pcVar10);\n    if (cVar4 \u003d\u003d \u0027\\0\u0027) {\n      setup_section_cold();\n      return;\n    }\n  }\n  local_50 \u003d 0;\n  pcVar12 \u003d param_2[6];\n  lVar9 \u003d find_section_list(*param_2,0,0x18);\n  if (lVar9 \u003d\u003d 0) {\n    pcVar10[0x28] \u003d pcVar10[0x28] | 1;\n    pcVar11 \u003d *param_2;\n    pcVar12 \u003d pcVar12 + change_section_address;\n    *(char **)(pcVar10 + 0x30) \u003d pcVar12;\n    *(char **)(pcVar10 + 0x38) \u003d pcVar12;\n    pcVar12 \u003d param_2[7];\n    lVar9 \u003d find_section_list(pcVar11,0,0x60);\n    if (lVar9 \u003d\u003d 0) goto LAB_00115695;\nLAB_00115860:\n    pcVar11 \u003d *(char **)(lVar9 + 0x20);\n    if ((*(byte *)(lVar9 + 0x14) \u0026 0x40) !\u003d 0) {\n      pcVar11 \u003d pcVar11 + (long)pcVar12;\n    }\n    *(char **)(pcVar10 + 0x38) \u003d pcVar11;\n    lVar9 \u003d find_section_list(*param_2,0,0x200);\n    if (lVar9 !\u003d 0) goto LAB_00115889;\nLAB_001156b8:\n    uVar13 \u003d *(uint *)((long)param_2 + 0x7c);\n    if (uVar13 \u003c 0x3f) goto LAB_001156c4;\n    local_50 \u003d dcgettext(0,\"failed to set alignment\",5);\n    *(undefined4 *)(pcVar10 + 0xb4) \u003d *(undefined4 *)((long)param_2 + 0xb4);\n    pcVar10[0x28] \u003d pcVar10[0x28] \u0026 0xcfU | *(byte *)(param_2 + 5) \u0026 0x30;\n    param_2[0xc] \u003d pcVar10;\n    param_2[0xb] \u003d (char *)0x0;\n    if ((*(byte *)((long)param_2 + 0x27) \u0026 2) !\u003d 0) goto LAB_001157c8;\nLAB_00115700:\n    cVar4 \u003d (**(code **)(*(long *)(param_3 + 8) + 0x158))(param_1,param_2,param_3,pcVar10);\n    if (cVar4 \u003d\u003d \u0027\\0\u0027) {\n      FUN_0010808f();\n      return;\n    }\n  }\n  else {\n    pcVar11 \u003d *(char **)(lVar9 + 0x18);\n    if ((*(byte *)(lVar9 + 0x14) \u0026 8) \u003d\u003d 0) {\n      pcVar11 \u003d pcVar11 + (long)pcVar12;\n    }\n    pcVar10[0x28] \u003d pcVar10[0x28] | 1;\n    pcVar2 \u003d *param_2;\n    *(char **)(pcVar10 + 0x30) \u003d pcVar11;\n    *(char **)(pcVar10 + 0x38) \u003d pcVar11;\n    pcVar12 \u003d param_2[7];\n    lVar9 \u003d find_section_list(pcVar2,0,0x60);\n    if (lVar9 !\u003d 0) goto LAB_00115860;\nLAB_00115695:\n    pcVar11 \u003d *param_2;\n    *(char **)(pcVar10 + 0x38) \u003d pcVar12 + change_section_address;\n    lVar9 \u003d find_section_list(pcVar11,0,0x200);\n    if (lVar9 \u003d\u003d 0) goto LAB_001156b8;\nLAB_00115889:\n    uVar13 \u003d *(uint *)(lVar9 + 0x2c);\n    if (0x3e \u003c uVar13) {\n      FUN_00108179();\n      return;\n    }\nLAB_001156c4:\n    *(uint *)(pcVar10 + 0x7c) \u003d uVar13;\n    *(undefined4 *)(pcVar10 + 0xb4) \u003d *(undefined4 *)((long)param_2 + 0xb4);\n    pcVar10[0x28] \u003d pcVar10[0x28] \u0026 0xcfU | *(byte *)(param_2 + 5) \u0026 0x30;\n    param_2[0xc] \u003d pcVar10;\n    param_2[0xb] \u003d (char *)0x0;\n    if ((*(byte *)((long)param_2 + 0x27) \u0026 2) \u003d\u003d 0) goto LAB_00115700;\nLAB_001157c8:\n    pcVar12 \u003d param_2[0x1a];\n    lVar9 \u003d group_signature_isra_0(pcVar12,param_2[0x1c]);\n    if ((lVar9 \u003d\u003d 0) ||\n       (lVar1 \u003d *(long *)(param_1 + 8), *(uint *)(lVar9 + 0x18) \u003d *(uint *)(lVar9 + 0x18) | 0x20,\n       *(int *)(lVar1 + 8) !\u003d 5)) goto LAB_00115700;\n    *(long *)(pcVar12 + 0xb0) \u003d lVar9;\n    cVar4 \u003d (**(code **)(*(long *)(param_3 + 8) + 0x158))(param_1,param_2,param_3,pcVar10);\n    if (cVar4 \u003d\u003d \u0027\\0\u0027) {\n      FUN_0010808f();\n      return;\n    }\n  }\n  if (bVar14) {\n    *(undefined4 *)(*(long *)(pcVar10 + 0xd0) + 4) \u003d 8;\n  }\n  if (local_50 \u003d\u003d 0) {\n    return;\n  }\nLAB_001080d1:\n  status \u003d 1;\n  bfd_nonfatal_message(0,param_3,pcVar10,local_50);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107880"
      ],
      "called": [
        "is_strip_section.isra.0",
        "strlen",
        "bfd_set_section_size",
        "bfd_convert_section_setup",
        "strcpy",
        "setup_section.cold",
        "check_new_section_flags",
        "find_section_list",
        "strcat",
        "dcgettext",
        "strcmp",
        "bfd_make_section_anyway_with_flags",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "smart_rename": {
      "entrypoint": "0x00115970",
      "current_name": "smart_rename",
      "code": "\nundefined  [16]\nsmart_rename(char *param_1,char *param_2,undefined4 param_3,undefined8 param_4,char param_5,\n            undefined8 param_6)\n\n{\n  uint uVar1;\n  int *piVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  ulong uVar5;\n  undefined auVar6 [16];\n  \n  if (param_2 \u003d\u003d param_1) {\n    uVar5 \u003d 0;\n  }\n  else {\n    uVar1 \u003d simple_copy(param_3,param_2,param_4);\n    uVar5 \u003d (ulong)uVar1;\n    if (uVar1 !\u003d 0) {\n      piVar2 \u003d __errno_location();\n      pcVar3 \u003d strerror(*piVar2);\n      uVar4 \u003d dcgettext(0,\"unable to copy file \\\u0027%s\\\u0027; reason: %s\",5);\n      non_fatal(uVar4,param_2,pcVar3);\n    }\n    unlink(param_1);\n  }\n  if (param_5 !\u003d \u0027\\0\u0027) {\n    set_times(param_2,param_4);\n  }\n  auVar6._8_8_ \u003d param_6;\n  auVar6._0_8_ \u003d uVar5;\n  return auVar6;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "smart_rename.cold",
        "simple_copy"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "is_strip_section.isra.0": {
      "entrypoint": "0x001159d0",
      "current_name": "is_strip_section.isra.0",
      "code": "\nundefined4 is_strip_section_isra_0(long param_1)\n\n{\n  undefined8 uVar1;\n  char cVar2;\n  undefined4 uVar3;\n  long lVar4;\n  long lVar5;\n  \n  uVar3 \u003d is_strip_section_1_isra_0();\n  if ((char)uVar3 \u003d\u003d \u0027\\0\u0027) {\n    if ((*(byte *)(param_1 + 0x27) \u0026 2) \u003d\u003d 0) {\n      return uVar3;\n    }\n    lVar4 \u003d group_signature_isra_0(*(undefined8 *)(param_1 + 0xd0),*(undefined8 *)(param_1 + 0xe0));\n    if ((lVar4 !\u003d 0) \u0026\u0026\n       (((uVar1 \u003d *(undefined8 *)(lVar4 + 8), strip_symbols !\u003d 7 ||\n         (cVar2 \u003d is_specified_symbol(uVar1,keep_specific_htab), cVar2 !\u003d \u0027\\0\u0027)) \u0026\u0026\n        (cVar2 \u003d is_specified_symbol(uVar1,strip_specific_htab), cVar2 \u003d\u003d \u0027\\0\u0027)))) {\n      lVar4 \u003d *(long *)(*(long *)(param_1 + 0xd0) + 0xc0);\n      lVar5 \u003d lVar4;\n      do {\n        if (lVar5 \u003d\u003d 0) {\n          return 1;\n        }\n        cVar2 \u003d is_strip_section_1_isra_0(lVar5);\n        if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n          return uVar3;\n        }\n        lVar5 \u003d *(long *)(*(long *)(lVar5 + 0xd0) + 0xc0);\n      } while (lVar4 !\u003d lVar5);\n    }\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f",
        "skip_section",
        "setup_section"
      ],
      "called": [
        "is_specified_symbol",
        "group_signature.isra.0",
        "is_strip_section_1.isra.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "simple_copy": {
      "entrypoint": "0x00115a90",
      "current_name": "simple_copy",
      "code": "\nulong simple_copy(int param_1,char *param_2,long param_3)\n\n{\n  int iVar1;\n  int __fd;\n  int iVar2;\n  __off_t _Var3;\n  ulong uVar4;\n  size_t sVar5;\n  int *piVar6;\n  undefined local_2038 [8200];\n  \n  if ((-1 \u003c param_1) \u0026\u0026 (_Var3 \u003d lseek(param_1,0,0), _Var3 \u003d\u003d 0)) {\n    __fd \u003d open(param_2,0x201);\n    if (__fd \u003c 0) {\n      uVar4 \u003d simple_copy_cold();\n      return uVar4;\n    }\n    do {\n      uVar4 \u003d read(param_1,local_2038,0x2000);\n      iVar2 \u003d (int)uVar4;\n      if (iVar2 \u003c 1) {\n        piVar6 \u003d __errno_location();\n        iVar1 \u003d *piVar6;\n        fchmod(__fd,*(__mode_t *)(param_3 + 0x18));\n        close(param_1);\n        close(__fd);\n        if (iVar2 !\u003d 0) {\n          *piVar6 \u003d iVar1;\n          return 0xffffffff;\n        }\n        return uVar4 \u0026 0xffffffff;\n      }\n      sVar5 \u003d write(__fd,local_2038,(long)iVar2);\n    } while (sVar5 \u003d\u003d (long)iVar2);\n    piVar6 \u003d __errno_location();\n    iVar2 \u003d *piVar6;\n    close(param_1);\n    close(__fd);\n    *piVar6 \u003d iVar2;\n  }\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "smart_rename"
      ],
      "called": [
        "read",
        "open",
        "write",
        "__errno_location",
        "simple_copy.cold",
        "fchmod",
        "close",
        "lseek"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "is_strip_section_1.isra.0": {
      "entrypoint": "0x00115b70",
      "current_name": "is_strip_section_1.isra.0",
      "code": "\nundefined8 is_strip_section_1_isra_0(char **param_1)\n\n{\n  char *pcVar1;\n  int iVar2;\n  int iVar3;\n  long lVar4;\n  long lVar5;\n  undefined8 uVar6;\n  long *plVar7;\n  \n  lVar4 \u003d find_section_list(*param_1,0,4);\n  if (lVar4 \u003d\u003d 0) {\n    if ((sections_removed !\u003d \u0027\\0\u0027) || (sections_copied !\u003d \u0027\\0\u0027)) {\n      lVar4 \u003d find_section_list(*param_1,0,1);\n      lVar5 \u003d find_section_list(*param_1,0,2);\n      if (lVar4 !\u003d 0) {\n        if (lVar5 !\u003d 0) {\n          pcVar1 \u003d *param_1;\n          uVar6 \u003d dcgettext(0,\"error: section %s matches both remove and copy options\",5);\n                    \n          fatal(uVar6,pcVar1);\n        }\n        if (lVar4 !\u003d 0) {\n          if (update_sections \u003d\u003d (long *)0x0) {\n            return 1;\n          }\n          pcVar1 \u003d *param_1;\n          plVar7 \u003d update_sections;\n          do {\n            iVar3 \u003d strcmp(pcVar1,(char *)plVar7[1]);\n            if (iVar3 \u003d\u003d 0) {\n              uVar6 \u003d dcgettext(0,\"error: section %s matches both update and remove options\",5);\n                    \n              fatal(uVar6,pcVar1);\n            }\n            plVar7 \u003d (long *)*plVar7;\n          } while (plVar7 !\u003d (long *)0x0);\n          return 1;\n        }\n      }\n      if ((sections_copied !\u003d \u0027\\0\u0027) \u0026\u0026 (lVar5 \u003d\u003d 0)) {\n        return 1;\n      }\n    }\n    iVar3 \u003d strip_symbols;\n    if ((*(byte *)((long)param_1 + 0x25) \u0026 0x20) !\u003d 0) {\n      if ((((strip_symbols - 2U \u003c 2) || (strip_symbols \u003d\u003d 7)) || (discard_locals \u003d\u003d 2)) ||\n         (convert_debugging !\u003d \u0027\\0\u0027)) {\n        pcVar1 \u003d *param_1;\n        iVar2 \u003d strcmp(pcVar1,\".gnu_debugaltlink\");\n        if ((iVar2 !\u003d 0) \u0026\u0026 (iVar2 \u003d strcmp(pcVar1,\".gnu_debuglink\"), iVar2 !\u003d 0)) {\n          iVar3 \u003d strcmp(pcVar1,\".reloc\");\n          if (iVar3 !\u003d 0) {\n            return 1;\n          }\n          uVar6 \u003d FUN_0010829e();\n          return uVar6;\n        }\n      }\n      if (iVar3 \u003d\u003d 5) {\n        uVar6 \u003d is_dwo_section_constprop_0(param_1);\n        return uVar6;\n      }\n      if (iVar3 \u003d\u003d 4) {\n        return 0;\n      }\n    }\n    if (iVar3 \u003d\u003d 6) {\n      uVar6 \u003d FUN_001082b3();\n      return uVar6;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "is_strip_section.isra.0"
      ],
      "called": [
        "FUN_0010829e",
        "dcgettext",
        "fatal",
        "strcmp",
        "find_section_list",
        "is_strip_section_1.isra.0.cold"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "group_signature.isra.0": {
      "entrypoint": "0x00115d00",
      "current_name": "group_signature.isra.0",
      "code": "\nlong group_signature_isra_0(long param_1,long param_2)\n\n{\n  uint uVar1;\n  long lVar2;\n  \n  lVar2 \u003d isympp;\n  if (isympp !\u003d 0) {\n    if (*(int *)(*(long *)(param_2 + 8) + 8) \u003d\u003d 5) {\n      if (*(int *)(param_1 + 0x28) \u003d\u003d *(int *)(*(long *)(param_2 + 0x110) + 0xd40)) {\n        uVar1 \u003d *(uint *)(param_1 + 0x2c);\n        if (uVar1 \u003d\u003d 0) {\n          lVar2 \u003d 0;\n        }\n        else if ((ulong)uVar1 \u003c\n                 *(ulong *)(*(long *)(param_2 + 0x110) + 0x88) /\n                 (ulong)*(byte *)(*(long *)(*(long *)(*(long *)(param_2 + 8) + 0x380) + 0x340) + 5))\n        {\n          lVar2 \u003d *(long *)(isympp + (ulong)(uVar1 - 1) * 8);\n        }\n        else {\n          lVar2 \u003d 0;\n        }\n      }\n      else {\n        lVar2 \u003d 0;\n      }\n    }\n    else {\n      lVar2 \u003d 0;\n    }\n  }\n  return lVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "is_strip_section.isra.0",
        "FUN_00108179"
      ],
      "called": [
        "group_signature.isra.0.cold"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "is_specified_symbol": {
      "entrypoint": "0x00115d70",
      "current_name": "is_specified_symbol",
      "code": "\nundefined is_specified_symbol(undefined8 param_1,undefined8 param_2)\n\n{\n  long lVar1;\n  undefined8 local_18;\n  undefined local_10;\n  \n  if (wildcard \u003d\u003d \u0027\\0\u0027) {\n    lVar1 \u003d htab_find(param_2,param_1);\n    local_10 \u003d lVar1 !\u003d 0;\n  }\n  else {\n    local_10 \u003d 0;\n    local_18 \u003d param_1;\n    htab_traverse(param_2,is_specified_symbol_predicate,\u0026local_18);\n  }\n  return local_10;\n}\n\n",
      "renaming": {},
      "calling": [
        "is_strip_section.isra.0",
        "copy_relocations_in_section.cold",
        "FUN_0010554f"
      ],
      "called": [
        "htab_find",
        "is_specified_symbol_predicate",
        "htab_traverse"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "copy_relocations_in_section": {
      "entrypoint": "0x00115dc0",
      "current_name": "copy_relocations_in_section",
      "code": "\nvoid copy_relocations_in_section(undefined8 param_1,undefined8 *param_2,long param_3)\n\n{\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  long lVar4;\n  undefined8 *puVar5;\n  ulong uVar6;\n  code *UNRECOVERED_JUMPTABLE;\n  undefined8 *puVar7;\n  undefined8 *puVar8;\n  ulong uVar9;\n  undefined8 uStack_38;\n  \n  cVar1 \u003d skip_section(param_1,param_2,0);\n  if (cVar1 !\u003d \u0027\\0\u0027) {\n    return;\n  }\n  uVar3 \u003d param_2[0xc];\n  if ((((*(byte *)(param_3 + 0x48) \u0026 7) !\u003d 3) \u0026\u0026 (strip_symbols !\u003d 6)) \u0026\u0026\n     (lVar4 \u003d find_section_list(*param_2,0,0x100), lVar4 \u003d\u003d 0)) {\n    lVar4 \u003d bfd_get_reloc_upper_bound(param_1,param_2);\n    if (lVar4 \u003c 0) {\n      if ((lVar4 !\u003d -1) || (iVar2 \u003d bfd_get_error(), iVar2 !\u003d 5)) {\n        status \u003d 1;\n        uVar3 \u003d 0;\nLAB_00108315:\n        bfd_nonfatal_message(0,param_1,param_2,uVar3,uStack_38);\n        return;\n      }\n    }\n    else if (lVar4 !\u003d 0) {\n      puVar5 \u003d (undefined8 *)param_2[0xe];\n      if (puVar5 \u003d\u003d (undefined8 *)0x0) {\n        puVar5 \u003d (undefined8 *)bfd_alloc(param_3);\n        if (puVar5 \u003d\u003d (undefined8 *)0x0) {\n          bfd_nonfatal(0);\n                    \n          xexit(1);\n        }\n        uVar6 \u003d bfd_canonicalize_reloc(param_1,param_2,puVar5,isympp);\n        if ((long)uVar6 \u003c 0) {\n          status \u003d 1;\n          uVar3 \u003d dcgettext(0,\"relocation count is negative\",5);\n          goto LAB_00108315;\n        }\n      }\n      else {\n        uVar6 \u003d (ulong)*(uint *)(param_2 + 0xf);\n      }\n      if (strip_symbols \u003d\u003d 7) {\n        puVar7 \u003d puVar5;\n        for (uVar9 \u003d 0; uVar9 !\u003d uVar6; uVar9 \u003d uVar9 + 1) {\n          puVar8 \u003d puVar7;\n          if (((*(long **)puVar5[uVar9] !\u003d (long *)0x0) \u0026\u0026\n              (lVar4 \u003d **(long **)puVar5[uVar9], lVar4 !\u003d 0)) \u0026\u0026\n             (cVar1 \u003d is_specified_symbol(*(undefined8 *)(lVar4 + 8),keep_specific_htab),\n             cVar1 !\u003d \u0027\\0\u0027)) {\n            puVar8 \u003d puVar7 + 1;\n            *puVar7 \u003d puVar5[uVar9];\n          }\n          puVar7 \u003d puVar8;\n        }\n        *puVar7 \u003d 0;\n        uVar6 \u003d (long)puVar7 - (long)puVar5 \u003e\u003e 3;\n      }\n      UNRECOVERED_JUMPTABLE \u003d *(code **)(*(long *)(param_3 + 8) + 0x288);\n      if (uVar6 \u003d\u003d 0) {\n        uVar6 \u003d 0;\n        puVar5 \u003d (undefined8 *)0x0;\n      }\n      else {\n        uVar6 \u003d uVar6 \u0026 0xffffffff;\n      }\n      goto LAB_00115e9a;\n    }\n  }\n  uVar6 \u003d 0;\n  puVar5 \u003d (undefined8 *)0x0;\n  UNRECOVERED_JUMPTABLE \u003d *(code **)(*(long *)(param_3 + 8) + 0x288);\nLAB_00115e9a:\n                    /* WARNING: Could not recover jumptable at 0x00115eae. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)(param_3,uVar3,puVar5,uVar6);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [
        "copy_relocations_in_section.cold",
        "bfd_canonicalize_reloc",
        "dcgettext",
        "bfd_get_reloc_upper_bound",
        "bfd_alloc",
        "bfd_nonfatal",
        "bfd_get_error",
        "skip_section",
        "find_section_list",
        "bfd_nonfatal_message",
        "xexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "check_new_section_flags": {
      "entrypoint": "0x00115f30",
      "current_name": "check_new_section_flags",
      "code": "\nuint check_new_section_flags(uint param_1,undefined8 *param_2,undefined8 param_3)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  \n  if (((param_1 \u0026 0x8000000) !\u003d 0) \u0026\u0026 (*(int *)(param_2[1] + 8) !\u003d 2)) {\n    uVar1 \u003d *param_2;\n    param_1 \u003d param_1 \u0026 0xf7ffffff;\n    uVar2 \u003d dcgettext(0,\"%s[%s]: Note - dropping \\\u0027share\\\u0027 flag as output format is not COFF\",5);\n    non_fatal(uVar2,uVar1,param_3);\n  }\n  return param_1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107880",
        "setup_section"
      ],
      "called": [
        "check_new_section_flags.cold"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "skip_section": {
      "entrypoint": "0x00115f50",
      "current_name": "skip_section",
      "code": "\nuint skip_section(long param_1,char **param_2,char param_3)\n\n{\n  char *__s1;\n  uint uVar1;\n  undefined4 uVar2;\n  undefined4 extraout_EDX;\n  long *plVar3;\n  undefined auVar4 [12];\n  \n  if ((status !\u003d 0) || (extract_symbol !\u003d \u0027\\0\u0027)) {\n    return 1;\n  }\n  auVar4 \u003d is_strip_section_isra_0(param_2);\n  if (auVar4[0] \u003d\u003d \u0027\\0\u0027) {\n    if (update_sections !\u003d (long *)0x0) {\n      __s1 \u003d *param_2;\n      plVar3 \u003d update_sections;\n      do {\n        uVar1 \u003d strcmp(__s1,(char *)plVar3[1]);\n        auVar4._4_4_ \u003d 0;\n        auVar4._0_4_ \u003d uVar1;\n        auVar4._8_4_ \u003d extraout_EDX;\n        if (uVar1 \u003d\u003d 0) {\n          return 1;\n        }\n        plVar3 \u003d (long *)*plVar3;\n      } while (plVar3 !\u003d (long *)0x0);\n    }\n    uVar2 \u003d auVar4._8_4_;\n    if (((((param_3 \u003d\u003d \u0027\\0\u0027) || (merge_notes \u003d\u003d \u0027\\0\u0027)) ||\n         (auVar4._8_4_ \u003d uVar2, auVar4._0_8_ \u003d *(long *)(param_1 + 8),\n         *(int *)(*(long *)(param_1 + 8) + 8) !\u003d 5)) ||\n        ((auVar4._0_8_ \u003d (ulong)param_2[0x1a], *(int *)(param_2[0x1a] + 4) !\u003d 7 ||\n         (auVar4 \u003d startswith_lto_priv_0_lto_priv_0(*param_2,\".gnu.build.attributes\"),\n         auVar4[0] \u003d\u003d \u0027\\0\u0027)))) \u0026\u0026 ((*(byte *)((long)param_2 + 0x27) \u0026 2) \u003d\u003d 0)) {\n      return (uint)CONCAT71(auVar4._1_7_,param_2[8] \u003d\u003d (char *)0x0) |\n             CONCAT31(auVar4._9_3_,param_2[0xc] \u003d\u003d (char *)0x0);\n    }\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_relocations_in_section",
        "copy_section"
      ],
      "called": [
        "is_strip_section.isra.0",
        "startswith.lto_priv.0.lto_priv.0",
        "strcmp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "mark_symbols_used_in_relocations": {
      "entrypoint": "0x00116030",
      "current_name": "mark_symbols_used_in_relocations",
      "code": "\n\n\nundefined8 mark_symbols_used_in_relocations(undefined8 *param_1,long param_2)\n\n{\n  long *plVar1;\n  long lVar2;\n  long lVar3;\n  long lVar4;\n  int iVar5;\n  undefined8 in_RAX;\n  long lVar6;\n  void *__ptr;\n  long lVar7;\n  undefined8 extraout_RAX;\n  long lVar8;\n  undefined8 uStack_28;\n  \n  if (*(long *)(param_2 + 0x60) \u003d\u003d 0) {\n    return in_RAX;\n  }\n  lVar6 \u003d bfd_get_reloc_upper_bound();\n  if (lVar6 \u003c 0) {\n    if ((lVar6 !\u003d -1) || (iVar5 \u003d bfd_get_error(), iVar5 !\u003d 5)) {\n      bfd_nonfatal(*param_1);\n                    \n      xexit(1);\n    }\n  }\n  else if (lVar6 !\u003d 0) {\n    __ptr \u003d (void *)xmalloc();\n    lVar7 \u003d bfd_canonicalize_reloc(param_1,param_2,__ptr);\n    lVar4 \u003d _DAT_00128680;\n    lVar3 \u003d _DAT_00128568;\n    lVar6 \u003d _fwrite;\n    if (lVar7 \u003c 0) {\n      bfd_nonfatal(*param_1);\n                    \n      xexit(1);\n    }\n    if (lVar7 !\u003d 0) {\n      lVar8 \u003d 0;\n      do {\n        plVar1 \u003d **(long ***)((long)__ptr + lVar8 * 8);\n        if ((((plVar1 !\u003d (long *)0x0) \u0026\u0026 (lVar2 \u003d *plVar1, lVar2 !\u003d 0)) \u0026\u0026 (lVar2 !\u003d lVar6)) \u0026\u0026\n           ((lVar2 !\u003d lVar4 \u0026\u0026 (lVar2 !\u003d lVar3)))) {\n          *(uint *)(lVar2 + 0x18) \u003d *(uint *)(lVar2 + 0x18) | 0x20;\n        }\n        lVar8 \u003d lVar8 + 1;\n      } while (lVar7 !\u003d lVar8);\n    }\n    free(__ptr);\n    return extraout_RAX;\n  }\n  return uStack_28;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [
        "bfd_canonicalize_reloc",
        "free",
        "bfd_get_reloc_upper_bound",
        "bfd_nonfatal",
        "mark_symbols_used_in_relocations.cold",
        "fwrite",
        "xmalloc",
        "xexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "copy_section": {
      "entrypoint": "0x00116110",
      "current_name": "copy_section",
      "code": "\nvoid copy_section(undefined8 param_1,undefined8 *param_2,undefined8 param_3)\n\n{\n  undefined uVar1;\n  undefined8 uVar2;\n  long lVar3;\n  int iVar4;\n  int iVar5;\n  char cVar6;\n  undefined8 uVar7;\n  undefined8 *__ptr;\n  long lVar8;\n  ulong uVar9;\n  int iVar10;\n  ulong uVar11;\n  undefined *puVar12;\n  long lVar13;\n  undefined8 *puVar14;\n  undefined8 *puVar15;\n  void *pvVar16;\n  ulong uVar17;\n  ulong uVar18;\n  ulong uVar19;\n  byte bVar20;\n  ulong local_38;\n  void *local_30;\n  \n  bVar20 \u003d 0;\n  cVar6 \u003d skip_section(param_1,param_2,1);\n  if (cVar6 !\u003d \u0027\\0\u0027) {\n    return;\n  }\n  local_38 \u003d param_2[8];\n  lVar3 \u003d param_2[0xc];\n  if (((*(byte *)((long)param_2 + 0x25) \u0026 1) \u003d\u003d 0) || ((*(byte *)(lVar3 + 0x25) \u0026 1) \u003d\u003d 0)) {\n    lVar13 \u003d find_section_list(*param_2,0,0x80);\n    if (lVar13 \u003d\u003d 0) {\n      return;\n    }\n    if ((*(byte *)(lVar13 + 0x29) \u0026 1) \u003d\u003d 0) {\n      return;\n    }\n    __ptr \u003d (undefined8 *)xmalloc(local_38);\n    puVar15 \u003d __ptr;\n    if (7 \u003c local_38) {\n      for (uVar18 \u003d local_38 \u003e\u003e 3; uVar18 !\u003d 0; uVar18 \u003d uVar18 - 1) {\n        *puVar15 \u003d 0;\n        puVar15 \u003d puVar15 + (ulong)bVar20 * -2 + 1;\n      }\n    }\n    puVar14 \u003d puVar15;\n    if ((local_38 \u0026 4) !\u003d 0) {\n      puVar14 \u003d (undefined8 *)((long)puVar15 + (ulong)bVar20 * -8 + 4);\n      *(undefined4 *)puVar15 \u003d 0;\n    }\n    puVar15 \u003d puVar14;\n    if ((local_38 \u0026 2) !\u003d 0) {\n      puVar15 \u003d (undefined8 *)((long)puVar14 + (ulong)bVar20 * -4 + 2);\n      *(undefined2 *)puVar14 \u003d 0;\n    }\n    if ((local_38 \u0026 1) !\u003d 0) {\n      *(undefined *)puVar15 \u003d 0;\n    }\n    cVar6 \u003d bfd_set_section_contents(param_3,lVar3,__ptr,0);\n    if (cVar6 !\u003d \u0027\\0\u0027) {\n      free(__ptr);\n      return;\n    }\n    status \u003d 1;\n    bfd_nonfatal_message(0,param_3,lVar3,0);\n    free(__ptr);\n    return;\n  }\n  local_30 \u003d (void *)0x0;\n  cVar6 \u003d bfd_get_full_section_contents(param_1,param_2,\u0026local_30);\n  if ((cVar6 \u003d\u003d \u0027\\0\u0027) ||\n     (cVar6 \u003d bfd_convert_section_contents(param_1,param_2,param_3,\u0026local_30,\u0026local_38),\n     iVar10 \u003d reverse_bytes, cVar6 \u003d\u003d \u0027\\0\u0027)) {\n    bfd_set_section_size(lVar3,0);\n    status \u003d 1;\n    bfd_nonfatal_message(0,param_1,param_2,0);\n    free(local_30);\n    return;\n  }\n  iVar4 \u003d copy_width;\n  iVar5 \u003d copy_byte;\n  if (reverse_bytes !\u003d 0) {\n    uVar18 \u003d (ulong)reverse_bytes;\n    if (local_38 % uVar18 !\u003d 0) {\n      uVar2 \u003d *param_2;\n      uVar7 \u003d dcgettext(0,\n                        \"cannot reverse bytes: length of section %s must be evenly divisible by %d\",\n                        5);\n                    \n      fatal(uVar7,uVar2,iVar10);\n    }\n    iVar10 \u003d reverse_bytes / 2;\n    uVar11 \u003d 0;\n    while (uVar19 \u003d uVar11, iVar4 \u003d copy_width, iVar5 \u003d copy_byte, uVar19 \u003c local_38) {\n      uVar11 \u003d uVar18 + uVar19;\n      uVar17 \u003d uVar11;\n      for (uVar9 \u003d 0; uVar9 \u003c (ulong)(long)iVar10; uVar9 \u003d uVar9 + 1) {\n        uVar17 \u003d uVar17 - 1;\n        puVar12 \u003d (undefined *)(uVar19 + uVar9 + (long)local_30);\n        uVar1 \u003d *puVar12;\n        *puVar12 \u003d *(undefined *)((long)local_30 + uVar17);\n        *(undefined *)((long)local_30 + uVar17) \u003d uVar1;\n      }\n    }\n  }\n  copy_width \u003d iVar4;\n  copy_byte \u003d iVar5;\n  if (-1 \u003c iVar5) {\n    uVar18 \u003d (ulong)interleave;\n    iVar10 \u003d (int)((ulong)param_2[7] % uVar18);\n    uVar11 \u003d ((long)iVar5 - (long)iVar10) + (long)local_30;\n    if (iVar5 \u003c iVar10) {\n      uVar11 \u003d uVar11 + uVar18;\n    }\n    lVar13 \u003d (local_38 + (long)local_30) - uVar11;\n    pvVar16 \u003d local_30;\n    for (; uVar11 \u003c local_38 + (long)local_30; uVar11 \u003d uVar11 + uVar18) {\n      for (lVar8 \u003d 0; ((int)lVar8 \u003c iVar4 \u0026\u0026 (lVar8 !\u003d lVar13)); lVar8 \u003d lVar8 + 1) {\n        *(undefined *)((long)pvVar16 + lVar8) \u003d *(undefined *)(uVar11 + lVar8);\n      }\n      pvVar16 \u003d (void *)((long)pvVar16 + lVar8);\n      lVar13 \u003d lVar13 - uVar18;\n    }\n    local_38 \u003d ((((uVar18 - 1) + local_38) - (long)iVar5) / uVar18) * (long)iVar4;\n    uVar18 \u003d *(ulong *)(lVar3 + 0x38) / uVar18;\n    *(ulong *)(lVar3 + 0x38) \u003d uVar18;\n    if (iVar5 \u003c iVar10) {\n      *(ulong *)(lVar3 + 0x38) \u003d uVar18 + 1;\n      cVar6 \u003d bfd_set_section_contents(param_3,lVar3,local_30,0,local_38);\n      if (cVar6 \u003d\u003d \u0027\\0\u0027) {\n        FUN_00108466();\n        return;\n      }\n      goto LAB_001161d8;\n    }\n  }\n  cVar6 \u003d bfd_set_section_contents(param_3,lVar3,local_30,0,local_38);\n  if (cVar6 \u003d\u003d \u0027\\0\u0027) {\n    FUN_00108466();\n    return;\n  }\nLAB_001161d8:\n  free(local_30);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [
        "free",
        "bfd_convert_section_contents",
        "FUN_00108466",
        "bfd_set_section_size",
        "bfd_set_section_contents",
        "bfd_get_full_section_contents",
        "copy_section.cold",
        "skip_section",
        "xmalloc",
        "bfd_nonfatal_message",
        "find_section_list"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "merge_gnu_build_notes": {
      "entrypoint": "0x001163d0",
      "current_name": "merge_gnu_build_notes",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x001166ef) */\n/* WARNING: Removing unreachable block (ram,0x001166df) */\n/* WARNING: Removing unreachable block (ram,0x001166d7) */\n/* WARNING: Removing unreachable block (ram,0x001166ea) */\n/* WARNING: Removing unreachable block (ram,0x00116716) */\n/* WARNING: Removing unreachable block (ram,0x0010858b) */\n\nulong merge_gnu_build_notes\n                (undefined8 *param_1,undefined8 *param_2,ulong param_3,undefined *param_4)\n\n{\n  ulong uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  bool bVar4;\n  ulong *puVar5;\n  int iVar6;\n  undefined8 uVar7;\n  long lVar8;\n  void *__ptr;\n  ulong uVar9;\n  ulong uVar10;\n  ulong uVar11;\n  ulong uVar12;\n  undefined *__ptr_00;\n  ulong uVar13;\n  ulong uVar14;\n  ulong uVar15;\n  ulong uVar16;\n  ulong *puVar17;\n  undefined *puVar18;\n  char cVar19;\n  undefined *puVar20;\n  int iVar21;\n  undefined *puVar22;\n  ulong *puVar23;\n  ulong uVar24;\n  size_t __nmemb;\n  ulong *puVar25;\n  byte bVar26;\n  ulong local_88;\n  ulong uStack_80;\n  ulong local_70;\n  ulong local_68;\n  ulong *local_60;\n  \n  bVar26 \u003d 0;\n  lVar8 \u003d bfd_get_reloc_upper_bound();\n  local_68 \u003d param_3;\n  if (0 \u003c lVar8) {\n    __ptr \u003d (void *)xmalloc(lVar8);\n    lVar8 \u003d bfd_canonicalize_reloc(param_1,param_2,__ptr,isympp);\n    free(__ptr);\n    if (lVar8 !\u003d 0) {\n      if (is_strip \u003d\u003d 0) {\n        uVar2 \u003d *param_1;\n        uVar3 \u003d *param_2;\n        uVar7 \u003d dcgettext(0,\"%s[%s]: Cannot merge - there are relocations against this section\",5);\n        non_fatal(uVar7,uVar2,uVar3);\n      }\n      local_60 \u003d (ulong *)0x0;\n      goto LAB_001166f8;\n    }\n  }\n  local_60 \u003d (ulong *)xcalloc(param_3 / 0xc,0x48,param_3 % 0xc);\n  local_88 \u003d 0;\n  local_70 \u003d 0;\n  uVar16 \u003d param_3;\n  uVar15 \u003d 0;\n  puVar23 \u003d local_60;\n  uVar14 \u003d 0;\n  puVar22 \u003d param_4;\n  while (0xb \u003c uVar16) {\n    uVar10 \u003d (**(code **)(param_1[1] + 0x40))(puVar22);\n    *puVar23 \u003d uVar10;\n    uVar10 \u003d (**(code **)(param_1[1] + 0x40))(puVar22 + 4);\n    puVar23[1] \u003d uVar10;\n    uVar11 \u003d (**(code **)(param_1[1] + 0x40))(puVar22 + 8);\n    uVar10 \u003d *puVar23;\n    puVar23[2] \u003d uVar11;\n    uVar12 \u003d puVar23[1];\n    uVar13 \u003d uVar10 + 3 \u0026 0xfffffffffffffffc;\n    puVar23[6] \u003d uVar13;\n    if (uVar12 !\u003d (uVar12 + 3 \u0026 0xfffffffffffffffc)) {\n      lVar8 \u003d dcgettext(0,\"corrupt GNU build attribute note: description size not a factor of 4\",5);\n      goto LAB_0010849a;\n    }\n    if (1 \u003c uVar11 - 0x100) {\n      lVar8 \u003d dcgettext(0,\"corrupt GNU build attribute note: wrong note type\",5);\n      goto LAB_0010849a;\n    }\n    uVar1 \u003d uVar13 + uVar12 + 0xc;\n    if (uVar16 \u003c uVar1) {\n      lVar8 \u003d dcgettext(0,\"corrupt GNU build attribute note: note too big\",5);\n      goto LAB_0010849a;\n    }\n    if (uVar10 \u003c 2) {\n      lVar8 \u003d dcgettext(0,\"corrupt GNU build attribute note: name too small\",5);\n      goto LAB_0010849a;\n    }\n    puVar23[3] \u003d (ulong)(puVar22 + 0xc);\n    puVar23[4] \u003d (ulong)(puVar22 + uVar13 + 0xc);\n    uVar16 \u003d uVar16 + (-0xc - (uVar13 + uVar12));\n    if (uVar10 !\u003d 2) {\n      if (puVar22[0xc] \u003d\u003d \u0027$\u0027) {\n        if ((puVar22[0xd] \u003d\u003d \u0027\\x01\u0027) \u0026\u0026 (puVar22[0xe] \u003d\u003d \u00271\u0027)) {\n          uVar16 \u003d FUN_00116490();\n          return uVar16;\n        }\n      }\n      else if ((((4 \u003c uVar10) \u0026\u0026 (puVar22[0xc] \u003d\u003d \u0027G\u0027)) \u0026\u0026 (puVar22[0xd] \u003d\u003d \u0027A\u0027)) \u0026\u0026\n              ((puVar22[0xe] \u003d\u003d \u0027$\u0027 \u0026\u0026 (puVar22[0xf] \u003d\u003d \u0027\\x01\u0027)))) {\n        if (puVar22[0x10] \u003d\u003d \u00272\u0027) {\n          uVar16 \u003d FUN_00116490();\n          return uVar16;\n        }\n        if (puVar22[0x10] \u003d\u003d \u00273\u0027) {\n          uVar16 \u003d FUN_00116490();\n          return uVar16;\n        }\n        lVar8 \u003d dcgettext(0,\"corrupt GNU build attribute note: unsupported version\",5);\n        goto LAB_0010849a;\n      }\n    }\n    uVar9 \u003d uVar15;\n    uVar24 \u003d uVar14;\n    if (uVar12 \u003d\u003d 0) {\n      if (uVar11 \u003d\u003d 0x100) {\n        puVar23[7] \u003d local_88;\nLAB_001164af:\n        uVar12 \u003d uVar14;\n        uVar24 \u003d uVar14;\n      }\n      else {\n        puVar23[7] \u003d local_70;\nLAB_0011669e:\n        uVar9 \u003d uVar15;\n        uVar12 \u003d uVar15;\n      }\n    }\n    else {\n      if (uVar12 !\u003d 0x10) {\n        if (uVar12 \u003c 0x11) {\n          if (uVar12 \u003d\u003d 4) {\n            uVar11 \u003d (**(code **)(param_1[1] + 0x40))();\n            uVar12 \u003d 0xffffffffffffffff;\n            goto LAB_00116631;\n          }\n          if (uVar12 \u003d\u003d 8) {\n            uVar16 \u003d FUN_001086af();\n            return uVar16;\n          }\n        }\n        lVar8 \u003d dcgettext(0,\"corrupt GNU build attribute note: bad description size\",5);\n        goto LAB_0010849a;\n      }\n      uVar11 \u003d (**(code **)(param_1[1] + 0x28))(puVar22 + uVar13 + 0xc);\n      uVar12 \u003d (**(code **)(param_1[1] + 0x28))();\n      if (uVar12 \u003c uVar11) {\n        uVar11 \u003d uVar12;\n      }\nLAB_00116631:\n      if (puVar23[2] \u003d\u003d 0x100) {\n        if (uVar11 \u003d\u003d 0) {\n          uVar11 \u003d local_88;\n        }\n        uVar10 \u003d *puVar23;\n        puVar23[7] \u003d uVar11;\n        uVar24 \u003d uVar12;\n        local_88 \u003d uVar11;\n        if (uVar12 \u003d\u003d 0) goto LAB_001164af;\n      }\n      else {\n        if (uVar11 \u003d\u003d 0) {\n          uVar11 \u003d local_70;\n        }\n        uVar10 \u003d *puVar23;\n        puVar23[7] \u003d uVar11;\n        uVar9 \u003d uVar12;\n        local_70 \u003d uVar11;\n        if (uVar12 \u003d\u003d 0) goto LAB_0011669e;\n      }\n    }\n    puVar23[8] \u003d uVar12;\n    if (*(char *)((puVar23[3] - 1) + uVar10) !\u003d \u0027\\0\u0027) {\n      lVar8 \u003d dcgettext(0,\"corrupt GNU build attribute note: name not NUL terminated\",5);\n      goto LAB_0010849a;\n    }\n    puVar23 \u003d puVar23 + 9;\n    uVar15 \u003d uVar9;\n    uVar14 \u003d uVar24;\n    puVar22 \u003d puVar22 + uVar1;\n  }\n  if (uVar16 \u003d\u003d 0) {\n    uVar2 \u003d *param_1;\n    uVar3 \u003d *param_2;\n    uVar7 \u003d dcgettext(0,\"%s[%s]: Warning: version note missing - assuming version 3\",5);\n    non_fatal(uVar7,uVar2,uVar3);\n    __nmemb \u003d ((long)puVar23 - (long)local_60 \u003e\u003e 3) * -0x71c71c71c71c71c7;\n    qsort(local_60,__nmemb,0x48,compare_gnu_build_notes);\n    for (puVar17 \u003d local_60; puVar17 \u003c puVar23; puVar17 \u003d puVar17 + 9) {\n      uVar16 \u003d puVar17[2];\n      if (uVar16 !\u003d 0) {\n        uVar15 \u003d puVar17[7];\n        uVar14 \u003d puVar17[8];\n        puVar25 \u003d puVar17;\n        iVar21 \u003d 0;\n        if (uVar15 \u003d\u003d uVar14) {\n          puVar17[2] \u003d 0;\n        }\n        else {\n          do {\n            do {\n              puVar5 \u003d puVar25;\n              puVar25 \u003d puVar5 + -9;\n              if (puVar25 \u003c local_60) goto LAB_001167f5;\n              uVar10 \u003d puVar5[-7];\n            } while (uVar10 \u003d\u003d 0);\n            if ((*puVar25 !\u003d *puVar17) ||\n               (iVar6 \u003d memcmp((void *)puVar5[-6],(void *)puVar17[3],*puVar17), iVar6 !\u003d 0)) break;\n            uVar12 \u003d puVar5[-2];\n            uVar11 \u003d puVar5[-1];\n            if (uVar15 \u003d\u003d uVar12) {\n              if (uVar14 \u003d\u003d uVar11) {\n                puVar17[2] \u003d 0;\n                break;\n              }\nLAB_001167a6:\n              if (uVar14 \u003c\u003d uVar11) {\n                puVar17[2] \u003d 0;\n                break;\n              }\n              if (uVar11 \u003c uVar15) {\nLAB_0010852c:\n                if ((0xfffffffffffffff0 \u003c uVar11) || (uVar15 \u003c\u003d (uVar11 + 0xf \u0026 0xfffffffffffffff0))\n                   ) goto FUN_00116852;\n              }\nLAB_001167b8:\n              if ((uVar16 \u003d\u003d 0x101) \u003d\u003d (uVar10 \u003d\u003d 0x101)) {\n                if (uVar11 \u003c\u003d uVar14) {\n                  uVar11 \u003d uVar14;\n                }\n                if (uVar12 \u003c uVar15) {\n                  uVar15 \u003d uVar12;\n                }\n                puVar5[-1] \u003d uVar11;\n                puVar5[-2] \u003d uVar15;\n                puVar17[2] \u003d 0;\n                break;\n              }\n            }\n            else {\n              if (uVar12 \u003c\u003d uVar15) goto LAB_001167a6;\n              if (uVar11 \u003c uVar15) goto LAB_0010852c;\n              if (uVar14 \u003c uVar15) {\n                if ((0xfffffffffffffff0 \u003c uVar14) || (uVar12 \u003c\u003d (uVar14 + 0xf \u0026 0xfffffffffffffff0))\n                   ) goto FUN_00116852;\n                goto LAB_001167b8;\n              }\n              if (uVar14 !\u003d uVar11) goto LAB_001167b8;\n            }\nFUN_00116852:\n            bVar4 \u003d iVar21 \u003c 0x11;\n            iVar21 \u003d iVar21 + 1;\n          } while (bVar4);\n        }\n      }\nLAB_001167f5:\n    }\n    qsort(local_60,__nmemb,0x48,sort_gnu_build_notes);\n    __ptr_00 \u003d (undefined *)xmalloc(param_3 * 2);\n    uStack_80 \u003d 0;\n    local_70 \u003d 0;\n    puVar22 \u003d __ptr_00;\n    for (puVar17 \u003d local_60; puVar17 \u003c puVar23; puVar17 \u003d puVar17 + 9) {\n      if (puVar17[2] !\u003d 0) {\n        puVar18 \u003d puVar22 + 0xc;\n        if ((puVar17[7] \u003d\u003d local_70) \u0026\u0026 (puVar17[8] \u003d\u003d uStack_80)) {\n          (**(code **)(param_1[1] + 0x50))(*puVar17,puVar22);\n          (**(code **)(param_1[1] + 0x50))(0,puVar22 + 4);\n          (**(code **)(param_1[1] + 0x50))(puVar17[2],puVar22 + 8);\n          uVar15 \u003d puVar17[6];\n          uVar16 \u003d *puVar17;\n          puVar22 \u003d (undefined *)puVar17[3];\n          puVar20 \u003d puVar18;\n          for (uVar14 \u003d uVar16; uVar14 !\u003d 0; uVar14 \u003d uVar14 - 1) {\n            *puVar20 \u003d *puVar22;\n            puVar22 \u003d puVar22 + (ulong)bVar26 * -2 + 1;\n            puVar20 \u003d puVar20 + (ulong)bVar26 * -2 + 1;\n          }\n          if (uVar16 \u003c uVar15) {\n            for (lVar8 \u003d uVar15 - uVar16; lVar8 !\u003d 0; lVar8 \u003d lVar8 + -1) {\n              *puVar20 \u003d 0;\n              puVar20 \u003d puVar20 + (ulong)bVar26 * -2 + 1;\n            }\n          }\n          puVar22 \u003d puVar18 + uVar15;\n        }\n        else {\n          (**(code **)(param_1[1] + 0x50))();\n          if (*(int *)(param_1[1] + 8) \u003d\u003d 5) {\n            cVar19 \u003d (*(char *)(param_1[0x22] + 4) \u003d\u003d \u0027\\x02\u0027) * \u0027\\b\u0027 + \u0027\\b\u0027;\n          }\n          else {\n            cVar19 \u003d \u0027\\b\u0027;\n          }\n          (**(code **)(param_1[1] + 0x50))(cVar19,puVar22 + 4);\n          (**(code **)(param_1[1] + 0x50))(puVar17[2],puVar22 + 8);\n          uVar16 \u003d *puVar17;\n          puVar22 \u003d (undefined *)puVar17[3];\n          puVar20 \u003d puVar18;\n          for (uVar15 \u003d uVar16; uVar15 !\u003d 0; uVar15 \u003d uVar15 - 1) {\n            *puVar20 \u003d *puVar22;\n            puVar22 \u003d puVar22 + (ulong)bVar26 * -2 + 1;\n            puVar20 \u003d puVar20 + (ulong)bVar26 * -2 + 1;\n          }\n          uVar15 \u003d puVar17[6];\n          if (uVar16 \u003c uVar15) {\n            for (lVar8 \u003d uVar15 - uVar16; lVar8 !\u003d 0; lVar8 \u003d lVar8 + -1) {\n              *puVar20 \u003d 0;\n              puVar20 \u003d puVar20 + (ulong)bVar26 * -2 + 1;\n            }\n          }\n          lVar8 \u003d param_1[1];\n          puVar18 \u003d puVar18 + uVar15;\n          puVar22 \u003d puVar18 + 8;\n          if ((*(int *)(lVar8 + 8) \u003d\u003d 5) \u0026\u0026 (*(char *)(param_1[0x22] + 4) \u003d\u003d \u0027\\x02\u0027)) {\n            (**(code **)(lVar8 + 0x38))(puVar17[7],puVar18);\n            (**(code **)(param_1[1] + 0x38))(puVar17[8],puVar22);\n            puVar22 \u003d puVar18 + 0x10;\n          }\n          else {\n            (**(code **)(lVar8 + 0x50))(puVar17[7],puVar18);\n            (**(code **)(param_1[1] + 0x50))(puVar17[8],puVar18 + 4);\n          }\n          local_70 \u003d puVar17[7];\n          uStack_80 \u003d puVar17[8];\n        }\n      }\n    }\n    uVar15 \u003d (long)puVar22 - (long)__ptr_00;\n    uVar16 \u003d uVar15;\n    puVar22 \u003d __ptr_00;\n    local_68 \u003d param_3;\n    if (uVar15 \u003c param_3) {\n      for (; local_68 \u003d uVar15, uVar16 !\u003d 0; uVar16 \u003d uVar16 - 1) {\n        *param_4 \u003d *puVar22;\n        puVar22 \u003d puVar22 + (ulong)bVar26 * -2 + 1;\n        param_4 \u003d param_4 + (ulong)bVar26 * -2 + 1;\n      }\n    }\n    free(__ptr_00);\n  }\n  else {\n    lVar8 \u003d dcgettext(0,\"corrupt GNU build attribute notes: excess data at end\",5);\nLAB_0010849a:\n    if (lVar8 !\u003d 0) {\n      bfd_set_error(0x11);\n      bfd_nonfatal_message(0,param_1,param_2,lVar8);\n      status \u003d 1;\n    }\n  }\nLAB_001166f8:\n  free(local_60);\n  return local_68;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107880"
      ],
      "called": [
        "non_fatal",
        "bfd_canonicalize_reloc",
        "free",
        "dcgettext",
        "bfd_get_reloc_upper_bound",
        "xcalloc",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00116490": {
      "entrypoint": "0x00116490",
      "current_name": "FUN_00116490",
      "code": "\nulong FUN_00116490(undefined8 param_1,ulong param_2,ulong param_3,long param_4)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  ulong uVar3;\n  bool bVar4;\n  ulong *puVar5;\n  int iVar6;\n  long lVar7;\n  undefined8 uVar8;\n  ulong in_RAX;\n  ulong uVar9;\n  ulong uVar10;\n  ulong uVar11;\n  ulong uVar12;\n  undefined *__ptr;\n  ulong uVar13;\n  ulong unaff_RBX;\n  ulong unaff_RBP;\n  ulong *puVar14;\n  undefined *puVar15;\n  char cVar16;\n  undefined *puVar17;\n  undefined *puVar18;\n  ulong in_R11;\n  ulong *unaff_R12;\n  ulong *puVar19;\n  ulong unaff_R13;\n  size_t __nmemb;\n  undefined8 *unaff_R14;\n  ulong *puVar20;\n  byte bVar21;\n  int iVar22;\n  ulong unaff_retaddr;\n  ulong param_7;\n  uint param_8;\n  ulong param_9;\n  ulong in_stack_00000020;\n  ulong *in_stack_00000028;\n  undefined *in_stack_00000030;\n  uint in_stack_00000038;\n  uint in_stack_00000040;\n  undefined8 *in_stack_00000048;\n  \n  bVar21 \u003d 0;\ncode_r0x00116490:\n  lVar7 \u003d param_4;\n  uVar10 \u003d unaff_RBP;\n  uVar13 \u003d unaff_R13;\n  if (in_RAX \u003d\u003d 0) {\n    if (param_2 \u003d\u003d 0x100) {\n      unaff_R12[7] \u003d unaff_retaddr;\n      uVar11 \u003d unaff_retaddr;\nLAB_001164af:\n      uVar9 \u003d unaff_R13;\n      uVar13 \u003d unaff_R13;\n      unaff_retaddr \u003d uVar11;\n    }\n    else {\n      unaff_R12[7] \u003d param_9;\nLAB_0011669e:\n      uVar10 \u003d unaff_RBP;\n      uVar9 \u003d unaff_RBP;\n    }\nLAB_001164bb:\n    unaff_R12[8] \u003d uVar9;\n    if (*(char *)((unaff_R12[3] - 1) + param_3) !\u003d \u0027\\0\u0027) {\n      lVar7 \u003d dcgettext(0,\"corrupt GNU build attribute note: name not NUL terminated\",5);\n      goto LAB_0010849a;\n    }\n    puVar19 \u003d unaff_R12 + 9;\n    if (0xb \u003c unaff_RBX) {\n      uVar9 \u003d (**(code **)(unaff_R14[1] + 0x40))(lVar7);\n      *puVar19 \u003d uVar9;\n      uVar9 \u003d (**(code **)(unaff_R14[1] + 0x40))(lVar7 + 4);\n      unaff_R12[10] \u003d uVar9;\n      param_2 \u003d (**(code **)(unaff_R14[1] + 0x40))(lVar7 + 8);\n      param_3 \u003d *puVar19;\n      unaff_R12[0xb] \u003d param_2;\n      in_RAX \u003d unaff_R12[10];\n      uVar9 \u003d param_3 + 3 \u0026 0xfffffffffffffffc;\n      unaff_R12[0xf] \u003d uVar9;\n      if (in_RAX !\u003d (in_RAX + 3 \u0026 0xfffffffffffffffc)) {\n        lVar7 \u003d dcgettext(0,\"corrupt GNU build attribute note: description size not a factor of 4\",5\n                         );\n        goto LAB_0010849a;\n      }\n      if (1 \u003c param_2 - 0x100) {\n        lVar7 \u003d dcgettext(0,\"corrupt GNU build attribute note: wrong note type\",5);\n        goto LAB_0010849a;\n      }\n      uVar11 \u003d uVar9 + in_RAX + 0xc;\n      if (unaff_RBX \u003c uVar11) {\n        lVar7 \u003d dcgettext(0,\"corrupt GNU build attribute note: note too big\",5);\n        goto LAB_0010849a;\n      }\n      if (param_3 \u003c 2) {\n        lVar7 \u003d dcgettext(0,\"corrupt GNU build attribute note: name too small\",5);\n        goto LAB_0010849a;\n      }\n      unaff_R12[0xc] \u003d lVar7 + 0xc;\n      in_R11 \u003d lVar7 + 0xc + uVar9;\n      unaff_R12[0xd] \u003d in_R11;\n      unaff_RBX \u003d unaff_RBX + (-0xc - (uVar9 + in_RAX));\n      param_4 \u003d lVar7 + uVar11;\n      unaff_RBP \u003d uVar10;\n      unaff_R12 \u003d puVar19;\n      unaff_R13 \u003d uVar13;\n      if (param_3 !\u003d 2) {\n        if (*(char *)(lVar7 + 0xc) \u003d\u003d \u0027$\u0027) {\n          if ((*(char *)(lVar7 + 0xd) \u003d\u003d \u0027\\x01\u0027) \u0026\u0026 (*(char *)(lVar7 + 0xe) \u003d\u003d \u00271\u0027)) {\n            uVar10 \u003d FUN_00116490();\n            return uVar10;\n          }\n        }\n        else if ((((4 \u003c param_3) \u0026\u0026 (*(char *)(lVar7 + 0xc) \u003d\u003d \u0027G\u0027)) \u0026\u0026\n                 (*(char *)(lVar7 + 0xd) \u003d\u003d \u0027A\u0027)) \u0026\u0026\n                ((*(char *)(lVar7 + 0xe) \u003d\u003d \u0027$\u0027 \u0026\u0026 (*(char *)(lVar7 + 0xf) \u003d\u003d \u0027\\x01\u0027)))) {\n          if (*(char *)(lVar7 + 0x10) \u003d\u003d \u00272\u0027) {\n            uVar10 \u003d FUN_00116490();\n            return uVar10;\n          }\n          if (*(char *)(lVar7 + 0x10) \u003d\u003d \u00273\u0027) {\n            uVar10 \u003d FUN_00116490();\n            return uVar10;\n          }\n          lVar7 \u003d dcgettext(0,\"corrupt GNU build attribute note: unsupported version\",5);\n          goto LAB_0010849a;\n        }\n      }\n      goto code_r0x00116490;\n    }\n    if (unaff_RBX !\u003d 0) {\n      lVar7 \u003d dcgettext(0,\"corrupt GNU build attribute notes: excess data at end\",5);\n      goto LAB_0010849a;\n    }\n    if ((in_stack_00000038 | in_stack_00000040 | param_8) \u003d\u003d 0) {\n      uVar1 \u003d *unaff_R14;\n      uVar2 \u003d *in_stack_00000048;\n      uVar8 \u003d dcgettext(0,\"%s[%s]: Warning: version note missing - assuming version 3\",5);\n      non_fatal(uVar8,uVar1,uVar2);\nLAB_0011671b:\n      __nmemb \u003d ((long)puVar19 - (long)in_stack_00000028 \u003e\u003e 3) * -0x71c71c71c71c71c7;\n      qsort(in_stack_00000028,__nmemb,0x48,compare_gnu_build_notes);\n      for (puVar14 \u003d in_stack_00000028; puVar14 \u003c puVar19; puVar14 \u003d puVar14 + 9) {\n        uVar10 \u003d puVar14[2];\n        if (uVar10 !\u003d 0) {\n          uVar13 \u003d puVar14[7];\n          uVar9 \u003d puVar14[8];\n          puVar20 \u003d puVar14;\n          iVar22 \u003d 0;\n          if (uVar13 \u003d\u003d uVar9) {\n            puVar14[2] \u003d 0;\n          }\n          else {\n            do {\n              do {\n                puVar5 \u003d puVar20;\n                puVar20 \u003d puVar5 + -9;\n                if (puVar20 \u003c in_stack_00000028) goto LAB_001167f5;\n                uVar11 \u003d puVar5[-7];\n              } while (uVar11 \u003d\u003d 0);\n              if ((*puVar20 !\u003d *puVar14) ||\n                 (iVar6 \u003d memcmp((void *)puVar5[-6],(void *)puVar14[3],*puVar14), iVar6 !\u003d 0))\n              break;\n              uVar3 \u003d puVar5[-2];\n              uVar12 \u003d puVar5[-1];\n              if (uVar13 \u003d\u003d uVar3) {\n                if (uVar9 \u003d\u003d uVar12) {\n                  puVar14[2] \u003d 0;\n                  break;\n                }\nLAB_001167a6:\n                if (uVar9 \u003c\u003d uVar12) {\n                  puVar14[2] \u003d 0;\n                  break;\n                }\n                if (uVar12 \u003c uVar13) {\nLAB_0010852c:\n                  if ((0xfffffffffffffff0 \u003c uVar12) ||\n                     (uVar13 \u003c\u003d (uVar12 + 0xf \u0026 0xfffffffffffffff0))) goto FUN_00116852;\n                }\nLAB_001167b8:\n                if ((uVar10 \u003d\u003d 0x101) \u003d\u003d (uVar11 \u003d\u003d 0x101)) {\n                  if (uVar12 \u003c\u003d uVar9) {\n                    uVar12 \u003d uVar9;\n                  }\n                  if (uVar3 \u003c uVar13) {\n                    uVar13 \u003d uVar3;\n                  }\n                  puVar5[-1] \u003d uVar12;\n                  puVar5[-2] \u003d uVar13;\n                  puVar14[2] \u003d 0;\n                  break;\n                }\n              }\n              else {\n                if (uVar3 \u003c\u003d uVar13) goto LAB_001167a6;\n                if (uVar12 \u003c uVar13) goto LAB_0010852c;\n                if (uVar9 \u003c uVar13) {\n                  if ((0xfffffffffffffff0 \u003c uVar9) || (uVar3 \u003c\u003d (uVar9 + 0xf \u0026 0xfffffffffffffff0)))\n                  goto FUN_00116852;\n                  goto LAB_001167b8;\n                }\n                if (uVar9 !\u003d uVar12) goto LAB_001167b8;\n              }\nFUN_00116852:\n              bVar4 \u003d iVar22 \u003c 0x11;\n              iVar22 \u003d iVar22 + 1;\n            } while (bVar4);\n          }\n        }\nLAB_001167f5:\n      }\n      qsort(in_stack_00000028,__nmemb,0x48,sort_gnu_build_notes);\n      __ptr \u003d (undefined *)xmalloc(in_stack_00000020 * 2);\n      param_7 \u003d 0;\n      param_9 \u003d 0;\n      puVar18 \u003d __ptr;\n      for (puVar14 \u003d in_stack_00000028; puVar14 \u003c puVar19; puVar14 \u003d puVar14 + 9) {\n        if (puVar14[2] !\u003d 0) {\n          puVar17 \u003d puVar18 + 4;\n          puVar15 \u003d puVar18 + 0xc;\n          if ((puVar14[7] \u003d\u003d param_9) \u0026\u0026 (puVar14[8] \u003d\u003d param_7)) {\n            (**(code **)(unaff_R14[1] + 0x50))(*puVar14,puVar18);\n            (**(code **)(unaff_R14[1] + 0x50))(0,puVar17);\n            (**(code **)(unaff_R14[1] + 0x50))(puVar14[2],puVar18 + 8);\n            uVar13 \u003d puVar14[6];\n            uVar10 \u003d *puVar14;\n            puVar18 \u003d (undefined *)puVar14[3];\n            puVar17 \u003d puVar15;\n            for (uVar9 \u003d uVar10; uVar9 !\u003d 0; uVar9 \u003d uVar9 - 1) {\n              *puVar17 \u003d *puVar18;\n              puVar18 \u003d puVar18 + (ulong)bVar21 * -2 + 1;\n              puVar17 \u003d puVar17 + (ulong)bVar21 * -2 + 1;\n            }\n            if (uVar10 \u003c uVar13) {\n              for (lVar7 \u003d uVar13 - uVar10; lVar7 !\u003d 0; lVar7 \u003d lVar7 + -1) {\n                *puVar17 \u003d 0;\n                puVar17 \u003d puVar17 + (ulong)bVar21 * -2 + 1;\n              }\n            }\n            puVar18 \u003d puVar15 + uVar13;\n          }\n          else {\n            (**(code **)(unaff_R14[1] + 0x50))();\n            if (*(int *)(unaff_R14[1] + 8) \u003d\u003d 5) {\n              cVar16 \u003d (*(char *)(unaff_R14[0x22] + 4) \u003d\u003d \u0027\\x02\u0027) * \u0027\\b\u0027 + \u0027\\b\u0027;\n            }\n            else {\n              cVar16 \u003d \u0027\\b\u0027;\n            }\n            (**(code **)(unaff_R14[1] + 0x50))(cVar16,puVar17);\n            (**(code **)(unaff_R14[1] + 0x50))(puVar14[2],puVar18 + 8);\n            uVar10 \u003d *puVar14;\n            puVar18 \u003d (undefined *)puVar14[3];\n            puVar17 \u003d puVar15;\n            for (uVar13 \u003d uVar10; uVar13 !\u003d 0; uVar13 \u003d uVar13 - 1) {\n              *puVar17 \u003d *puVar18;\n              puVar18 \u003d puVar18 + (ulong)bVar21 * -2 + 1;\n              puVar17 \u003d puVar17 + (ulong)bVar21 * -2 + 1;\n            }\n            uVar13 \u003d puVar14[6];\n            if (uVar10 \u003c uVar13) {\n              for (lVar7 \u003d uVar13 - uVar10; lVar7 !\u003d 0; lVar7 \u003d lVar7 + -1) {\n                *puVar17 \u003d 0;\n                puVar17 \u003d puVar17 + (ulong)bVar21 * -2 + 1;\n              }\n            }\n            lVar7 \u003d unaff_R14[1];\n            puVar15 \u003d puVar15 + uVar13;\n            puVar18 \u003d puVar15 + 8;\n            if ((*(int *)(lVar7 + 8) \u003d\u003d 5) \u0026\u0026 (*(char *)(unaff_R14[0x22] + 4) \u003d\u003d \u0027\\x02\u0027)) {\n              (**(code **)(lVar7 + 0x38))(puVar14[7],puVar15);\n              (**(code **)(unaff_R14[1] + 0x38))(puVar14[8],puVar18);\n              puVar18 \u003d puVar15 + 0x10;\n            }\n            else {\n              (**(code **)(lVar7 + 0x50))(puVar14[7],puVar15);\n              (**(code **)(unaff_R14[1] + 0x50))(puVar14[8],puVar15 + 4);\n            }\n            param_9 \u003d puVar14[7];\n            param_7 \u003d puVar14[8];\n          }\n        }\n      }\n      uVar13 \u003d (long)puVar18 - (long)__ptr;\n      uVar10 \u003d uVar13;\n      puVar18 \u003d __ptr;\n      if (uVar13 \u003c in_stack_00000020) {\n        for (; in_stack_00000020 \u003d uVar13, uVar10 !\u003d 0; uVar10 \u003d uVar10 - 1) {\n          *in_stack_00000030 \u003d *puVar18;\n          puVar18 \u003d puVar18 + (ulong)bVar21 * -2 + 1;\n          in_stack_00000030 \u003d in_stack_00000030 + (ulong)bVar21 * -2 + 1;\n        }\n      }\n      free(__ptr);\nLAB_001166f8:\n      free(in_stack_00000028);\n      return in_stack_00000020;\n    }\n    if (((in_stack_00000040 | param_8) \u003d\u003d 0) || (in_stack_00000038 \u003d\u003d 0)) {\n      if (in_stack_00000040 \u003d\u003d 0) {\n        if (param_8 !\u003d 0) goto LAB_0011671b;\n        goto LAB_001166f8;\n      }\n      if (param_8 \u003d\u003d 0) goto LAB_001166f8;\n    }\n    lVar7 \u003d dcgettext(0,\"bad GNU build attribute notes: multiple different versions\",5);\n  }\n  else {\n    if (in_RAX \u003d\u003d 0x10) {\n      uVar11 \u003d (**(code **)(unaff_R14[1] + 0x28))(in_R11);\n      uVar9 \u003d (**(code **)(unaff_R14[1] + 0x28))(unaff_R12[4] + 8);\n      if (uVar9 \u003c uVar11) {\n        uVar11 \u003d uVar9;\n      }\nLAB_00116631:\n      if (unaff_R12[2] \u003d\u003d 0x100) {\n        if (uVar11 \u003d\u003d 0) {\n          uVar11 \u003d unaff_retaddr;\n        }\n        param_3 \u003d *unaff_R12;\n        unaff_R12[7] \u003d uVar11;\n        uVar13 \u003d uVar9;\n        unaff_retaddr \u003d uVar11;\n        if (uVar9 \u003d\u003d 0) goto LAB_001164af;\n      }\n      else {\n        if (uVar11 \u003d\u003d 0) {\n          uVar11 \u003d param_9;\n        }\n        param_3 \u003d *unaff_R12;\n        unaff_R12[7] \u003d uVar11;\n        uVar10 \u003d uVar9;\n        param_9 \u003d uVar11;\n        if (uVar9 \u003d\u003d 0) goto LAB_0011669e;\n      }\n      goto LAB_001164bb;\n    }\n    if (in_RAX \u003c 0x11) {\n      if (in_RAX \u003d\u003d 4) {\n        uVar11 \u003d (**(code **)(unaff_R14[1] + 0x40))(in_R11);\n        uVar9 \u003d 0xffffffffffffffff;\n        goto LAB_00116631;\n      }\n      if (in_RAX \u003d\u003d 8) {\n        uVar10 \u003d FUN_001086af();\n        return uVar10;\n      }\n    }\n    lVar7 \u003d dcgettext(0,\"corrupt GNU build attribute note: bad description size\",5);\n  }\nLAB_0010849a:\n  if (lVar7 !\u003d 0) {\n    bfd_set_error(0x11);\n    bfd_nonfatal_message(0,unaff_R14,in_stack_00000048,lVar7);\n    status \u003d 1;\n  }\n  goto LAB_001166f8;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001086af",
        "merge_gnu_build_notes.cold"
      ],
      "called": [
        "FUN_001086af",
        "dcgettext"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00116852": {
      "entrypoint": "0x00116852",
      "current_name": "FUN_00116852",
      "code": "\nulong FUN_00116852(void)\n\n{\n  size_t sVar1;\n  code *pcVar2;\n  int iVar3;\n  uint uVar4;\n  undefined *__ptr;\n  size_t *in_RCX;\n  ulong uVar5;\n  ulong uVar6;\n  long lVar7;\n  ulong uVar8;\n  size_t unaff_RBX;\n  size_t *unaff_RBP;\n  undefined *puVar9;\n  char cVar10;\n  undefined *puVar11;\n  ulong in_R10;\n  undefined *puVar12;\n  size_t in_R11;\n  size_t *unaff_R13;\n  size_t *unaff_R14;\n  size_t unaff_R15;\n  size_t *psVar13;\n  byte bVar14;\n  size_t param_7;\n  size_t param_9;\n  ulong param_10;\n  size_t *param_11;\n  undefined *param_12;\n  long param_13;\n  size_t param_14;\n  \n  bVar14 \u003d 0;\ncode_r0x00116852:\n  uVar4 \u003d (int)in_R10 + 1;\n  if (0x10 \u003c (int)in_R10) goto LAB_001167f5;\nLAB_00116863:\n  unaff_R14 \u003d unaff_R14 + -9;\n  do {\n    if (unaff_R13 \u003c\u003d unaff_R14) {\n      sVar1 \u003d unaff_R14[2];\n      if (sVar1 \u003d\u003d 0) goto LAB_00116863;\n      uVar8 \u003d (ulong)uVar4;\n      if ((*unaff_R14 \u003d\u003d *unaff_RBP) \u0026\u0026\n         (iVar3 \u003d memcmp((void *)unaff_R14[3],(void *)unaff_RBP[3],*unaff_RBP), iVar3 \u003d\u003d 0)) {\n        uVar6 \u003d unaff_R14[7];\n        uVar5 \u003d unaff_R14[8];\n        in_R10 \u003d uVar8 \u0026 0xffffffff;\n        if (unaff_R15 \u003d\u003d uVar6) {\n          if (unaff_RBX !\u003d uVar5) goto LAB_001167a6;\n          unaff_RBP[2] \u003d 0;\n        }\n        else {\n          if (unaff_R15 \u003c uVar6) {\n            if (uVar5 \u003c unaff_R15) {\nLAB_0010852c:\n              if ((0xfffffffffffffff0 \u003c uVar5) || (unaff_R15 \u003c\u003d (uVar5 + 0xf \u0026 0xfffffffffffffff0)))\n              goto code_r0x00116852;\n            }\n            else if (unaff_RBX \u003c unaff_R15) {\n              if ((0xfffffffffffffff0 \u003c unaff_RBX) ||\n                 (uVar6 \u003c\u003d (unaff_RBX + 0xf \u0026 0xfffffffffffffff0))) goto code_r0x00116852;\n            }\n            else if (unaff_RBX \u003d\u003d uVar5) goto code_r0x00116852;\n          }\n          else {\nLAB_001167a6:\n            if (unaff_RBX \u003c\u003d uVar5) {\n              unaff_RBP[2] \u003d 0;\n              goto LAB_001167f5;\n            }\n            if (uVar5 \u003c unaff_R15) goto LAB_0010852c;\n          }\n          if ((in_R11 \u003d\u003d 0x101) !\u003d (sVar1 \u003d\u003d 0x101)) goto code_r0x00116852;\n          if (uVar5 \u003c\u003d unaff_RBX) {\n            uVar5 \u003d unaff_RBX;\n          }\n          if (uVar6 \u003c unaff_R15) {\n            unaff_R15 \u003d uVar6;\n          }\n          unaff_R14[8] \u003d uVar5;\n          unaff_R14[7] \u003d unaff_R15;\n          unaff_RBP[2] \u003d 0;\n        }\n      }\n    }\nLAB_001167f5:\n    while( true ) {\n      do {\n        unaff_R14 \u003d unaff_RBP;\n        unaff_RBP \u003d unaff_R14 + 9;\n        if (in_RCX \u003c\u003d unaff_RBP) {\n          qsort(param_11,param_14,0x48,sort_gnu_build_notes);\n          __ptr \u003d (undefined *)xmalloc(param_10 * 2);\n          param_7 \u003d 0;\n          puVar12 \u003d __ptr;\n          for (psVar13 \u003d param_11; psVar13 \u003c in_RCX; psVar13 \u003d psVar13 + 9) {\n            if (psVar13[2] !\u003d 0) {\n              puVar11 \u003d puVar12 + 4;\n              puVar9 \u003d puVar12 + 0xc;\n              pcVar2 \u003d *(code **)(*(long *)(param_13 + 8) + 0x50);\n              if ((psVar13[7] \u003d\u003d param_9) \u0026\u0026 (psVar13[8] \u003d\u003d param_7)) {\n                (*pcVar2)(*psVar13,puVar12);\n                (**(code **)(*(long *)(param_13 + 8) + 0x50))(0,puVar11);\n                (**(code **)(*(long *)(param_13 + 8) + 0x50))(psVar13[2],puVar12 + 8);\n                uVar6 \u003d psVar13[6];\n                uVar8 \u003d *psVar13;\n                puVar12 \u003d (undefined *)psVar13[3];\n                puVar11 \u003d puVar9;\n                for (uVar5 \u003d uVar8; uVar5 !\u003d 0; uVar5 \u003d uVar5 - 1) {\n                  *puVar11 \u003d *puVar12;\n                  puVar12 \u003d puVar12 + (ulong)bVar14 * -2 + 1;\n                  puVar11 \u003d puVar11 + (ulong)bVar14 * -2 + 1;\n                }\n                if (uVar8 \u003c uVar6) {\n                  for (lVar7 \u003d uVar6 - uVar8; lVar7 !\u003d 0; lVar7 \u003d lVar7 + -1) {\n                    *puVar11 \u003d 0;\n                    puVar11 \u003d puVar11 + (ulong)bVar14 * -2 + 1;\n                  }\n                }\n                puVar12 \u003d puVar9 + uVar6;\n              }\n              else {\n                (*pcVar2)();\n                if (*(int *)(*(long *)(param_13 + 8) + 8) \u003d\u003d 5) {\n                  cVar10 \u003d (*(char *)(*(long *)(param_13 + 0x110) + 4) \u003d\u003d \u0027\\x02\u0027) * \u0027\\b\u0027 + \u0027\\b\u0027;\n                }\n                else {\n                  cVar10 \u003d \u0027\\b\u0027;\n                }\n                (**(code **)(*(long *)(param_13 + 8) + 0x50))(cVar10,puVar11);\n                (**(code **)(*(long *)(param_13 + 8) + 0x50))(psVar13[2],puVar12 + 8);\n                uVar8 \u003d *psVar13;\n                puVar12 \u003d (undefined *)psVar13[3];\n                puVar11 \u003d puVar9;\n                for (uVar6 \u003d uVar8; uVar6 !\u003d 0; uVar6 \u003d uVar6 - 1) {\n                  *puVar11 \u003d *puVar12;\n                  puVar12 \u003d puVar12 + (ulong)bVar14 * -2 + 1;\n                  puVar11 \u003d puVar11 + (ulong)bVar14 * -2 + 1;\n                }\n                uVar6 \u003d psVar13[6];\n                if (uVar8 \u003c uVar6) {\n                  for (lVar7 \u003d uVar6 - uVar8; lVar7 !\u003d 0; lVar7 \u003d lVar7 + -1) {\n                    *puVar11 \u003d 0;\n                    puVar11 \u003d puVar11 + (ulong)bVar14 * -2 + 1;\n                  }\n                }\n                lVar7 \u003d *(long *)(param_13 + 8);\n                puVar9 \u003d puVar9 + uVar6;\n                puVar12 \u003d puVar9 + 8;\n                if ((*(int *)(lVar7 + 8) \u003d\u003d 5) \u0026\u0026\n                   (*(char *)(*(long *)(param_13 + 0x110) + 4) \u003d\u003d \u0027\\x02\u0027)) {\n                  (**(code **)(lVar7 + 0x38))(psVar13[7],puVar9);\n                  (**(code **)(*(long *)(param_13 + 8) + 0x38))(psVar13[8],puVar12);\n                  puVar12 \u003d puVar9 + 0x10;\n                }\n                else {\n                  (**(code **)(lVar7 + 0x50))(psVar13[7],puVar9);\n                  (**(code **)(*(long *)(param_13 + 8) + 0x50))(psVar13[8],puVar9 + 4);\n                }\n                param_9 \u003d psVar13[7];\n                param_7 \u003d psVar13[8];\n              }\n            }\n          }\n          uVar6 \u003d (long)puVar12 - (long)__ptr;\n          uVar8 \u003d uVar6;\n          puVar12 \u003d __ptr;\n          if (uVar6 \u003c param_10) {\n            for (; param_10 \u003d uVar6, uVar8 !\u003d 0; uVar8 \u003d uVar8 - 1) {\n              *param_12 \u003d *puVar12;\n              puVar12 \u003d puVar12 + (ulong)bVar14 * -2 + 1;\n              param_12 \u003d param_12 + (ulong)bVar14 * -2 + 1;\n            }\n          }\n          free(__ptr);\n          free(param_11);\n          return param_10;\n        }\n        in_R11 \u003d unaff_R14[0xb];\n      } while (in_R11 \u003d\u003d 0);\n      unaff_R15 \u003d unaff_R14[0x10];\n      unaff_RBX \u003d unaff_R14[0x11];\n      uVar4 \u003d 0;\n      if (unaff_R15 !\u003d unaff_RBX) break;\n      unaff_R14[0xb] \u003d 0;\n    }\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00116852"
      ],
      "called": [
        "free",
        "memcmp",
        "qsort",
        "FUN_00116852",
        "sort_gnu_build_notes",
        "xmalloc"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_start": {
      "entrypoint": "0x00116aa0",
      "current_name": "_start",
      "code": "\nvoid processEntry _start(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_8 [8];\n  \n  __libc_start_main(main,param_2,\u0026stack0x00000008,0,0,param_1,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__libc_start_main",
        "main"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "deregister_tm_clones": {
      "entrypoint": "0x00116ad0",
      "current_name": "deregister_tm_clones",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00116ae3) */\n/* WARNING: Removing unreachable block (ram,0x00116aef) */\n\nvoid deregister_tm_clones(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__do_global_dtors_aux"
      ],
      "called": [
        "_ITM_deregisterTMCloneTable"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "register_tm_clones": {
      "entrypoint": "0x00116b00",
      "current_name": "register_tm_clones",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00116b24) */\n/* WARNING: Removing unreachable block (ram,0x00116b30) */\n\nvoid register_tm_clones(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "frame_dummy"
      ],
      "called": [
        "_ITM_registerTMCloneTable"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__do_global_dtors_aux": {
      "entrypoint": "0x00116b40",
      "current_name": "__do_global_dtors_aux",
      "code": "\nvoid __do_global_dtors_aux(void)\n\n{\n  if (completed_0 !\u003d \u0027\\0\u0027) {\n    return;\n  }\n  __cxa_finalize(__dso_handle);\n  deregister_tm_clones();\n  completed_0 \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__cxa_finalize",
        "deregister_tm_clones"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "frame_dummy": {
      "entrypoint": "0x00116b80",
      "current_name": "frame_dummy",
      "code": "\nvoid frame_dummy(void)\n\n{\n  register_tm_clones();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "register_tm_clones"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "main": {
      "entrypoint": "0x00116b90",
      "current_name": "main",
      "code": "\n\n\nuint main(uint param_1,char **param_2)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  bool bVar4;\n  bool bVar5;\n  undefined *puVar6;\n  byte bVar7;\n  char cVar8;\n  int iVar9;\n  uint uVar10;\n  int iVar11;\n  undefined4 uVar12;\n  int iVar13;\n  FILE *pFVar14;\n  size_t sVar15;\n  byte *__s;\n  size_t sVar16;\n  byte *__ptr;\n  long lVar17;\n  char **ppcVar18;\n  long *__src;\n  char **ppcVar19;\n  undefined8 *puVar20;\n  char *__template;\n  FILE *pFVar21;\n  undefined8 uVar22;\n  FILE **ppFVar23;\n  undefined8 uVar24;\n  int *piVar25;\n  char *pcVar26;\n  ulong uVar27;\n  byte *pbVar28;\n  undefined **ppuVar29;\n  long lVar30;\n  byte *pbVar31;\n  char *pcVar32;\n  FILE *pFVar33;\n  char *pcVar34;\n  FILE *unaff_R12;\n  int iVar35;\n  uint uVar36;\n  char *unaff_R13;\n  byte bVar37;\n  FILE *pFVar38;\n  bool bVar39;\n  FILE *local_130;\n  FILE *local_120;\n  size_t local_118;\n  ulong local_110;\n  long *local_108;\n  FILE *local_d8;\n  FILE *local_d0;\n  undefined local_c8 [152];\n  \n  setlocale(5,\"\");\n  setlocale(0,\"\");\n  bindtextdomain(\"binutils\",\"/usr/share/locale\");\n  textdomain(\"binutils\");\n  program_name \u003d *param_2;\n  xmalloc_set_program_name();\n  ppcVar18 \u003d param_2;\n  if (1 \u003c (int)param_1) {\n    local_120 \u003d (FILE *)0x7d0;\n    unaff_R13 \u003d (char *)(ulong)param_1;\n    unaff_R12 \u003d (FILE *)0x1;\n    iVar11 \u003d 0;\n    do {\n      iVar13 \u003d (int)unaff_R12;\n      lVar30 \u003d (long)iVar13;\n      iVar35 \u003d (int)unaff_R13;\n      if (*ppcVar18[lVar30] \u003d\u003d \u0027@\u0027) {\n        uVar10 \u003d (int)local_120 - 1;\n        local_120 \u003d (FILE *)(ulong)uVar10;\n        if (uVar10 \u003d\u003d 0) {\n          pcVar32 \u003d *ppcVar18;\n          pcVar26 \u003d \"%s: error: too many @-files encountered\\n\";\nLAB_00118365:\n          fprintf(_stderr,pcVar26,pcVar32);\n                    \n          xexit(1);\n        }\n        pcVar32 \u003d ppcVar18[lVar30] + 1;\n        iVar9 \u003d stat(pcVar32,(stat *)local_c8);\n        if (iVar9 \u003c 0) goto LAB_00116fd0;\n        if ((local_c8._24_4_ \u0026 0xf000) \u003d\u003d 0x4000) {\n          pcVar32 \u003d *ppcVar18;\n          pcVar26 \u003d \"%s: error: @-file refers to a directory\\n\";\n          goto LAB_00118365;\n        }\n        pFVar14 \u003d fopen(pcVar32,\"r\");\n        if (pFVar14 \u003d\u003d (FILE *)0x0) goto LAB_00116fd0;\n        iVar9 \u003d fseek(pFVar14,0,2);\n        if (((iVar9 \u003d\u003d -1) || (sVar15 \u003d ftell(pFVar14), sVar15 \u003d\u003d 0xffffffffffffffff)) ||\n           (iVar9 \u003d fseek(pFVar14,0,0), iVar9 \u003d\u003d -1)) {\nLAB_00117070:\n          fclose(pFVar14);\n          if (iVar13 + 1 \u003c iVar35) goto LAB_00116fde;\n          goto LAB_00117086;\n        }\n        __s \u003d (byte *)xmalloc(sVar15 + 1);\n        sVar16 \u003d fread(__s,1,sVar15,pFVar14);\n        if ((sVar15 !\u003d sVar16) \u0026\u0026 (iVar9 \u003d ferror(pFVar14), iVar9 !\u003d 0)) {\n          free(__s);\n          goto LAB_00117070;\n        }\n        __s[sVar16] \u003d 0;\n        bVar7 \u003d *__s;\n        pbVar28 \u003d __s;\n        if (bVar7 !\u003d 0) {\nLAB_00116d58:\n          if (((\u0026_sch_istable)[(ulong)bVar7 * 2] \u0026 0x40) !\u003d 0) goto LAB_00116d48;\n          sVar15 \u003d strlen((char *)__s);\n          __ptr \u003d (byte *)xmalloc(sVar15 + 1);\n          __src \u003d (long *)0x0;\n          iVar9 \u003d 0;\n          bVar39 \u003d false;\n          bVar5 \u003d false;\n          bVar4 \u003d false;\n          local_110 \u003d 0;\n          pbVar28 \u003d __s;\n          do {\n            while (((\u0026_sch_istable)[(ulong)*pbVar28 * 2] \u0026 0x40) !\u003d 0) {\n              pbVar28 \u003d pbVar28 + 1;\n            }\n            if ((iVar9 \u003d\u003d 0) || (iVar9 + -1 \u003c\u003d (int)local_110)) {\n              if (__src \u003d\u003d (long *)0x0) {\n                iVar9 \u003d 8;\n                __src \u003d (long *)xmalloc(0x40);\n                local_108 \u003d __src + local_110;\n                *local_108 \u003d 0;\n              }\n              else {\n                iVar9 \u003d iVar9 * 2;\n                __src \u003d (long *)xrealloc(__src,(long)iVar9 \u003c\u003c 3);\n                local_108 \u003d __src + local_110;\n                *local_108 \u003d 0;\n              }\n            }\n            else {\n              local_108 \u003d __src + local_110;\n            }\n            bVar7 \u003d *pbVar28;\n            pbVar31 \u003d __ptr;\n            while (bVar7 !\u003d 0) {\n              while( true ) {\n                if ((((\u0026_sch_istable)[(ulong)bVar7 * 2] \u0026 0x40) !\u003d 0) \u0026\u0026\n                   (!(bool)(bVar5 | bVar4 | bVar39))) {\n                  bVar4 \u003d false;\n                  bVar39 \u003d false;\n                  bVar5 \u003d false;\n                  goto LAB_00116e3f;\n                }\n                if (!bVar4) break;\n                pbVar28 \u003d pbVar28 + 1;\n                *pbVar31 \u003d bVar7;\n                pbVar31 \u003d pbVar31 + 1;\n                bVar4 \u003d false;\n                bVar7 \u003d *pbVar28;\n                if (bVar7 \u003d\u003d 0) goto LAB_00116e3f;\n              }\n              if (bVar7 \u003d\u003d 0x5c) {\n                bVar4 \u003d true;\n              }\n              else if (bVar5) {\n                if (bVar7 \u003d\u003d 0x27) {\n                  bVar5 \u003d false;\n                }\n                else {\nLAB_00116fb1:\n                  *pbVar31 \u003d bVar7;\n                  pbVar31 \u003d pbVar31 + 1;\n                }\n              }\n              else if (bVar39) {\n                if (bVar7 !\u003d 0x22) goto LAB_00116fb1;\n                bVar39 \u003d false;\n              }\n              else if (bVar7 \u003d\u003d 0x27) {\n                bVar5 \u003d true;\n              }\n              else {\n                if (bVar7 !\u003d 0x22) goto LAB_00116fb1;\n                bVar39 \u003d true;\n              }\n              pbVar1 \u003d pbVar28 + 1;\n              pbVar28 \u003d pbVar28 + 1;\n              bVar7 \u003d *pbVar1;\n            }\nLAB_00116e3f:\n            *pbVar31 \u003d 0;\n            lVar17 \u003d xstrdup(__ptr);\n            *local_108 \u003d lVar17;\n            __src[local_110 + 1] \u003d 0;\n            bVar7 \u003d *pbVar28;\n            bVar2 \u003d (\u0026_sch_istable)[(ulong)bVar7 * 2];\n            while ((bVar2 \u0026 0x40) !\u003d 0) {\n              bVar7 \u003d pbVar28[1];\n              pbVar28 \u003d pbVar28 + 1;\n              bVar2 \u003d (\u0026_sch_istable)[(ulong)bVar7 * 2];\n            }\n            local_110 \u003d local_110 + 1;\n          } while (bVar7 !\u003d 0);\n          free(__ptr);\n          ppcVar19 \u003d ppcVar18;\n          if (param_2 \u003d\u003d ppcVar18) goto LAB_001172ad;\n          goto LAB_00116ed7;\n        }\nLAB_0011728f:\n        __src \u003d (long *)xmalloc(8);\n        *__src \u003d 0;\n        if (param_2 \u003d\u003d ppcVar18) {\nLAB_001172ad:\n          if (*ppcVar18 \u003d\u003d (char *)0x0) {\n            iVar9 \u003d 0;\n          }\n          else {\n            lVar17 \u003d 1;\n            do {\n              iVar9 \u003d (int)lVar17;\n              ppcVar19 \u003d ppcVar18 + lVar17;\n              lVar17 \u003d lVar17 + 1;\n            } while (*ppcVar19 !\u003d (char *)0x0);\n          }\n          lVar17 \u003d 0;\n          ppcVar19 \u003d (char **)xmalloc((long)(iVar9 + 1) \u003c\u003c 3);\n          pcVar32 \u003d *ppcVar18;\n          while (pcVar32 !\u003d (char *)0x0) {\n            uVar24 \u003d xstrdup();\n            *(undefined8 *)((long)ppcVar19 + lVar17) \u003d uVar24;\n            lVar17 \u003d lVar17 + 8;\n            pcVar32 \u003d *(char **)((long)ppcVar18 + lVar17);\n          }\n          *(undefined8 *)((long)ppcVar19 + lVar17) \u003d 0;\nLAB_00116ed7:\n          ppcVar18 \u003d ppcVar19;\n          if (*__src \u003d\u003d 0) goto LAB_00117768;\n          lVar17 \u003d 0;\n          do {\n            lVar17 \u003d lVar17 + 1;\n          } while (__src[lVar17] !\u003d 0);\n          local_118 \u003d lVar17 * 8;\n        }\n        else {\nLAB_00117768:\n          lVar17 \u003d 0;\n          local_118 \u003d 0;\n        }\n        free(ppcVar18[lVar30]);\n        ppcVar18 \u003d (char **)xrealloc(ppcVar18,(lVar17 + 1 + (long)iVar35) * 8);\n        uVar36 \u003d iVar35 + -1 + (int)lVar17;\n        unaff_R13 \u003d (char *)(ulong)uVar36;\n        memmove(ppcVar18 + lVar30 + lVar17,ppcVar18 + 1 + lVar30,(long)(iVar35 - iVar13) \u003c\u003c 3);\n        memcpy(ppcVar18 + lVar30,__src,local_118);\n        free(__src);\n        free(__s);\n        fclose(pFVar14);\n        uVar10 \u003d iVar11 + 1;\n        unaff_R12 \u003d (FILE *)(lVar30 * 8);\n        if ((int)uVar36 \u003c\u003d (int)uVar10) goto LAB_00117086;\n      }\n      else {\nLAB_00116fd0:\n        if (iVar35 \u003c\u003d iVar13 + 1) goto LAB_00117086;\nLAB_00116fde:\n        uVar10 \u003d iVar13 + 1;\n        iVar11 \u003d iVar13;\n      }\n      unaff_R12 \u003d (FILE *)(ulong)uVar10;\n    } while( true );\n  }\nLAB_0011708b:\n  strip_symbols \u003d 0;\n  discard_locals \u003d 0;\n  iVar11 \u003d bfd_init();\n  pcVar32 \u003d \"fatal error: libbfd ABI mismatch\";\n  if (iVar11 !\u003d 0x118) {\nLAB_00117aed:\n    uVar24 \u003d dcgettext(0,pcVar32,5);\n                    \n    fatal(uVar24);\n  }\n  pcVar32 \u003d \"x86_64-pc-linux-gnu\";\n  bVar7 \u003d bfd_set_default_target(\"x86_64-pc-linux-gnu\",\"fatal error: libbfd ABI mismatch\",5);\n  pcVar26 \u003d program_name;\n  if (bVar7 \u003d\u003d 0) {\n    uVar12 \u003d bfd_get_error();\n    pcVar26 \u003d (char *)bfd_errmsg(uVar12);\n    pcVar34 \u003d \"can\\\u0027t set BFD default target to `%s\\\u0027: %s\";\nLAB_00118de6:\n    uVar24 \u003d dcgettext(0,pcVar34,5);\n                    \n    fatal(uVar24,pcVar32,pcVar26);\n  }\n  uVar10 \u003d is_strip;\n  if ((int)is_strip \u003c 0) {\n    sVar15 \u003d strlen(program_name);\n    uVar10 \u003d 0;\n    if (4 \u003c (int)sVar15) {\n      iVar11 \u003d filename_cmp(pcVar26 + (long)(int)sVar15 + -5,\"strip\");\n      uVar10 \u003d (uint)(iVar11 \u003d\u003d 0);\n    }\n  }\n  is_strip \u003d uVar10;\n  strip_specific_htab \u003d create_symbol_htab();\n  strip_unneeded_htab \u003d create_symbol_htab();\n  keep_specific_htab \u003d create_symbol_htab();\n  localize_specific_htab \u003d create_symbol_htab();\n  globalize_specific_htab \u003d create_symbol_htab();\n  keepglobal_specific_htab \u003d create_symbol_htab();\n  weaken_specific_htab \u003d create_symbol_htab();\n  redefine_specific_htab \u003d htab_create_alloc(0x10,htab_hash_redefnode,eq_string_redefnode);\n  redefine_specific_reverse_htab \u003d create_symbol_htab();\n  puVar6 \u003d xatexit_head_lto_priv_0;\n  if (__xexit_cleanup \u003d\u003d (code *)0x0) {\n    __xexit_cleanup \u003d xatexit_cleanup_lto_priv_0;\n  }\n  if (0x1f \u003c *(int *)(xatexit_head_lto_priv_0 + 8)) {\n    puVar20 \u003d (undefined8 *)malloc(0x110);\n    if (puVar20 \u003d\u003d (undefined8 *)0x0) goto LAB_001171a7;\n    *puVar20 \u003d puVar6;\n    *(undefined4 *)(puVar20 + 1) \u003d 0;\n    xatexit_head_lto_priv_0 \u003d (undefined *)puVar20;\n  }\n  puVar6 \u003d xatexit_head_lto_priv_0;\n  iVar11 \u003d *(int *)(xatexit_head_lto_priv_0 + 8);\n  *(int *)(xatexit_head_lto_priv_0 + 8) \u003d iVar11 + 1;\n  *(code **)(puVar6 + (long)iVar11 * 8 + 0x10) \u003d delete_symbol_htabs;\nLAB_001171a7:\n  bfd_set_error_program_name(*ppcVar18);\n  if (is_strip !\u003d 0) {\n    local_130 \u003d (FILE *)0x0;\n    unaff_R12 \u003d (FILE *)0x0;\n    ppuVar29 \u003d (undefined **)(FILE *)0x0;\n    pFVar14 \u003d (FILE *)0x0;\n    bVar37 \u003d 0;\n    bVar2 \u003d 0;\nswitchD_001177df_caseD_0:\n    do {\n      uVar12 \u003d getopt_long(param_1,ppcVar18,\"I:O:F:K:MN:R:o:sSpdgxXHhVvwDU\",strip_options);\n      pFVar21 \u003d _optarg;\n      switch(uVar12) {\n      case 0x44:\n        deterministic \u003d 1;\n        break;\n      case 0x48:\n      case 0x68:\n        strip_usage(_stdout,0);\n      case 0x46:\n        local_130 \u003d _optarg;\n        pFVar14 \u003d _optarg;\n        break;\n      case 0x49:\n        local_130 \u003d _optarg;\n        break;\n      case 0x4b:\n        local_120 \u003d _optarg;\n        ppFVar23 \u003d (FILE **)htab_find_slot(keep_specific_htab,_optarg,1);\n        *ppFVar23 \u003d pFVar21;\n        break;\n      case 0x4d:\n        merge_notes \u003d bVar7;\n        bVar2 \u003d bVar7;\n        break;\n      case 0x4e:\n        local_120 \u003d _optarg;\n        ppFVar23 \u003d (FILE **)htab_find_slot(strip_specific_htab,_optarg,1);\n        *ppFVar23 \u003d pFVar21;\n        break;\n      case 0x4f:\n        pFVar14 \u003d _optarg;\n        break;\n      case 0x52:\n        handle_remove_section_option(_optarg);\n        break;\n      case 0x53:\n      case 100:\n      case 0x67:\n        strip_symbols \u003d 2;\n        break;\n      case 0x55:\n        deterministic \u003d 0;\n        break;\n      case 0x56:\n        unaff_R12 \u003d (FILE *)(ulong)bVar7;\n        break;\n      case 0x58:\n        discard_locals \u003d 1;\n        break;\n      case 0x6f:\n        ppuVar29 \u003d (undefined **)_optarg;\n        break;\n      case 0x70:\n        preserve_dates \u003d 1;\n        break;\n      case 0x73:\n        strip_symbols \u003d 7;\n        break;\n      case 0x76:\n        verbose \u003d 1;\n        break;\n      case 0x77:\n        wildcard \u003d 1;\n        break;\n      case 0x78:\n        discard_locals \u003d 2;\n        break;\n      case 0xa9:\n        bVar37 \u003d bVar7;\n        break;\n      case 0xb2:\n        keep_file_symbols \u003d 1;\n        break;\n      case 0xb3:\n        find_section_list(_optarg,1,4);\n        break;\n      case 0xb5:\n        keep_section_symbols \u003d 1;\n        break;\n      case 0xba:\n        merge_notes \u003d 0;\n        bVar2 \u003d bVar7;\n        break;\n      case 0xbc:\n        strip_symbols \u003d 4;\n        break;\n      case 0xc6:\n        find_section_list(_optarg,1,0x100);\n        break;\n      case 0xd0:\n        strip_symbols \u003d 5;\n        break;\n      case 0xd2:\n        goto switchD_001177df_caseD_d2;\n      default:\n        if (((bVar2 \u003d\u003d 0) \u0026\u0026 (strip_symbols \u003c 8)) \u0026\u0026\n           ((-0xdaL \u003e\u003e ((byte)strip_symbols \u0026 0x3f) \u0026 1U) \u003d\u003d 0)) {\n          merge_notes \u003d 1;\n        }\n        if (bVar37 !\u003d 0) goto LAB_00118a4c;\n        if ((char)unaff_R12 !\u003d \u0027\\0\u0027) {\n          print_version(\"strip\");\n          goto LAB_001189a2;\n        }\n        if (deterministic \u003c 0) {\n          deterministic \u003d 1;\n        }\n        if (((strip_symbols | discard_locals) \u003d\u003d 0) \u0026\u0026\n           (lVar30 \u003d htab_elements(strip_specific_htab), lVar30 \u003d\u003d 0)) {\n          strip_symbols \u003d 7;\n        }\n        if (pFVar14 \u003d\u003d (FILE *)0x0) {\n          pFVar14 \u003d local_130;\n        }\n        unaff_R12 \u003d (FILE *)(long)(int)_optind;\n        if ((_optind !\u003d param_1) \u0026\u0026\n           (((FILE *)ppuVar29 \u003d\u003d (FILE *)0x0 || ((int)param_1 \u003c\u003d (int)(_optind + 1)))))\n        goto LAB_00117888;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n      case 0x21:\n      case 0x22:\n      case 0x23:\n      case 0x24:\n      case 0x25:\n      case 0x26:\n      case 0x27:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n      case 0x3f:\n      case 0x40:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x45:\n      case 0x47:\n      case 0x4a:\n      case 0x4c:\n      case 0x50:\n      case 0x51:\n      case 0x54:\n      case 0x57:\n      case 0x59:\n      case 0x5a:\n      case 0x5b:\n      case 0x5c:\n      case 0x5d:\n      case 0x5e:\n      case 0x5f:\n      case 0x60:\n      case 0x61:\n      case 0x62:\n      case 99:\n      case 0x65:\n      case 0x66:\n      case 0x69:\n      case 0x6a:\n      case 0x6b:\n      case 0x6c:\n      case 0x6d:\n      case 0x6e:\n      case 0x71:\n      case 0x72:\n      case 0x74:\n      case 0x75:\n      case 0x79:\n      case 0x7a:\n      case 0x7b:\n      case 0x7c:\n      case 0x7d:\n      case 0x7e:\n      case 0x7f:\n      case 0x80:\n      case 0x81:\n      case 0x82:\n      case 0x83:\n      case 0x84:\n      case 0x85:\n      case 0x86:\n      case 0x87:\n      case 0x88:\n      case 0x89:\n      case 0x8a:\n      case 0x8b:\n      case 0x8c:\n      case 0x8d:\n      case 0x8e:\n      case 0x8f:\n      case 0x90:\n      case 0x91:\n      case 0x92:\n      case 0x93:\n      case 0x94:\n      case 0x95:\n      case 0x96:\n      case 0x97:\n      case 0x98:\n      case 0x99:\n      case 0x9a:\n      case 0x9b:\n      case 0x9c:\n      case 0x9d:\n      case 0x9e:\n      case 0x9f:\n      case 0xa0:\n      case 0xa1:\n      case 0xa2:\n      case 0xa3:\n      case 0xa4:\n      case 0xa5:\n      case 0xa6:\n      case 0xa7:\n      case 0xa8:\n      case 0xaa:\n      case 0xab:\n      case 0xac:\n      case 0xad:\n      case 0xae:\n      case 0xaf:\n      case 0xb0:\n      case 0xb1:\n      case 0xb4:\n      case 0xb6:\n      case 0xb7:\n      case 0xb8:\n      case 0xb9:\n      case 0xbb:\n      case 0xbd:\n      case 0xbe:\n      case 0xbf:\n      case 0xc0:\n      case 0xc1:\n      case 0xc2:\n      case 0xc3:\n      case 0xc4:\n      case 0xc5:\n      case 199:\n      case 200:\n      case 0xc9:\n      case 0xca:\n      case 0xcb:\n      case 0xcc:\n      case 0xcd:\n      case 0xce:\n      case 0xcf:\n      case 0xd1:\n        strip_usage(_stderr,1);\n        unaff_R13 \u003d strip_options;\n        goto switchD_00117234_caseD_c1;\n      }\n    } while( true );\n  }\n  local_108 \u003d (long *)0x0;\n  local_d8 \u003d (FILE *)0x0;\n  local_d0 \u003d (FILE *)0x0;\n  local_130 \u003d (FILE *)(ulong)bVar7;\n  local_120 \u003d (FILE *)0x0;\n  local_118 \u003d 0;\n  local_110 \u003d 0;\n  ppuVar29 \u003d (undefined **)(FILE *)0x0;\n  bVar2 \u003d 0;\nswitchD_00117234_caseD_0:\n  uVar36 \u003d getopt_long(param_1,ppcVar18,\"b:B:i:I:j:K:MN:s:O:d:F:L:G:R:SpgxXHhVvW:wDU\",copy_options);\n  pFVar14 \u003d _optarg;\n  uVar10 \u003d reverse_bytes;\n  pcVar26 \u003d (char *)(ulong)uVar36;\n  if (uVar36 !\u003d 0xffffffff) goto code_r0x00117223;\n  if (bVar2 !\u003d 0) {\n    pcVar32 \u003d \"--globalize-symbol(s) is incompatible with -G/--keep-global-symbol(s)\";\n    if ((char)local_108 !\u003d \u0027\\0\u0027) goto LAB_00117aed;\n  }\n  if ((char)local_118 !\u003d \u0027\\0\u0027) {\nLAB_00118a4c:\n    display_info_isra_0();\n    return status;\n  }\n  if ((char)local_110 !\u003d \u0027\\0\u0027) {\n    print_version(\"objcopy\");\n    goto LAB_00118398;\n  }\n  if ((interleave !\u003d 0) \u0026\u0026 (copy_byte \u003d\u003d -1)) {\n    pcVar32 \u003d \"interleave start byte must be set with --byte\";\n    goto LAB_00117aed;\n  }\n  if (interleave \u003c\u003d copy_byte) {\n    pcVar32 \u003d \"byte number must be less than interleave\";\n    goto LAB_00117aed;\n  }\n  pcVar32 \u003d \"interleave width must be less than or equal to interleave - byte`\";\n  if (interleave - copy_byte \u003c copy_width) goto LAB_00117aed;\n  if ((_optind \u003d\u003d param_1) || ((int)(_optind + 2) \u003c (int)param_1)) goto switchD_00117234_caseD_1;\n  pcVar32 \u003d ppcVar18[(int)_optind];\n  if ((int)(_optind + 1) \u003c (int)param_1) {\n    pcVar34 \u003d ppcVar18[(long)(int)_optind + 1];\n  }\n  else {\n    pcVar34 \u003d (char *)0x0;\n  }\n  if (deterministic \u003c 0) {\n    deterministic \u003d 1;\n  }\n  if ((strip_symbols | discard_locals) \u003d\u003d 0) {\n    strip_symbols \u003d 1;\n  }\n  if (local_d0 \u003d\u003d (FILE *)0x0) {\n    local_d0 \u003d local_d8;\n    if (local_d8 !\u003d (FILE *)0x0) {\nLAB_00117661:\n      cVar8 \u003d startswith_lto_priv_0_lto_priv_0(local_d8,\u0026DAT_0011b300);\n      if (cVar8 !\u003d \u0027\\0\u0027) {\n        iVar11 \u003d convert_efi_target(\u0026local_d8);\n        if (iVar11 \u003c 0) {\n          pcVar32 \u003d \"unknown input EFI target: %s\";\n          pFVar14 \u003d local_d8;\n          goto LAB_001176c2;\n        }\n        if (local_d0 \u003d\u003d (FILE *)0x0) goto LAB_0011743e;\n      }\n      goto LAB_001175b1;\n    }\n  }\n  else {\n    if (local_d8 !\u003d (FILE *)0x0) goto LAB_00117661;\nLAB_001175b1:\n    cVar8 \u003d startswith_lto_priv_0_lto_priv_0(local_d0,\u0026DAT_0011b300);\n    if (cVar8 !\u003d \u0027\\0\u0027) {\n      iVar11 \u003d convert_efi_target(\u0026local_d0);\n      if (iVar11 \u003c 0) {\n        pcVar32 \u003d \"unknown output EFI target: %s\";\n        pFVar14 \u003d local_d0;\n        goto LAB_001176c2;\n      }\n      if (pe_subsystem \u003d\u003d -1) {\n        pe_subsystem \u003d (short)iVar11;\n      }\n      if (pe_file_alignment \u003d\u003d -1) {\n        pe_file_alignment \u003d 0x200;\n      }\n      if (pe_section_alignment \u003d\u003d -1) {\n        pe_section_alignment \u003d 0x1000;\n      }\n    }\n  }\nLAB_0011743e:\n  if ((pcVar34 \u003d\u003d (char *)0x0) || (uVar10 \u003d filename_cmp(pcVar32,pcVar34), uVar10 \u003d\u003d 0)) {\n    __template \u003d (char *)template_in_dir(pcVar32);\n    uVar36 \u003d mkstemp(__template);\n    if (uVar36 \u003d\u003d 0xffffffff) {\n      free(__template);\n      piVar25 \u003d __errno_location();\n      pcVar26 \u003d strerror(*piVar25);\n      pcVar34 \u003d \"warning: could not create temporary file whilst copying \\\u0027%s\\\u0027, (error: %s)\";\n      goto LAB_00118de6;\n    }\n    uVar10 \u003d uVar36;\n    if (-1 \u003c (int)uVar36) {\n      uVar10 \u003d dup(uVar36);\n      pcVar26 \u003d (char *)(ulong)uVar10;\n    }\n  }\n  else {\n    uVar36 \u003d 0xffffffff;\n    __template \u003d pcVar34;\n  }\n  copy_file(pcVar32,__template,uVar36,local_c8,local_d8,local_d0,local_120,uVar10);\n  if (status \u003d\u003d 0) {\n    if (pcVar34 !\u003d (char *)0x0) {\n      pcVar32 \u003d pcVar34;\n    }\n    iVar11 \u003d smart_rename(__template,pcVar32,pcVar26,local_c8,preserve_dates);\n    status \u003d (uint)(iVar11 !\u003d 0);\n  }\n  else {\n    if (-1 \u003c (int)pcVar26) {\n      close((int)pcVar26);\n    }\n    unlink_if_ordinary(__template);\n  }\n  if (pcVar34 !\u003d __template) {\n    free(__template);\n  }\n  puVar20 \u003d change_sections;\n  if ((char)local_130 !\u003d \u0027\\0\u0027) {\n    for (; puVar20 !\u003d (undefined8 *)0x0; puVar20 \u003d (undefined8 *)*puVar20) {\n      if (*(char *)(puVar20 + 2) \u003d\u003d \u0027\\0\u0027) {\n        uVar10 \u003d *(uint *)((long)puVar20 + 0x14);\n        if ((uVar10 \u0026 0x18) !\u003d 0) {\n          uVar24 \u003d puVar20[3];\n          uVar3 \u003d puVar20[1];\n          uVar22 \u003d dcgettext(0,\"%s %s%c0x%lx never used\",5);\n          non_fatal(uVar22,\"--change-section-vma\",uVar3,\n                    (-(uint)((uVar10 \u0026 8) \u003d\u003d 0) \u0026 0xffffffee) + 0x3d,uVar24);\n          uVar10 \u003d *(uint *)((long)puVar20 + 0x14);\n        }\n        if ((uVar10 \u0026 0x60) !\u003d 0) {\n          uVar24 \u003d puVar20[4];\n          uVar3 \u003d puVar20[1];\n          uVar22 \u003d dcgettext(0,\"%s %s%c0x%lx never used\",5);\n          non_fatal(uVar22,\"--change-section-lma\",uVar3,\n                    (-(uint)((uVar10 \u0026 0x20) \u003d\u003d 0) \u0026 0xffffffee) + 0x3d,uVar24);\n        }\n      }\n    }\n  }\n  free(strip_specific_buffer);\n  free(strip_unneeded_buffer);\n  free(keep_specific_buffer);\n  free(localize_specific_buffer);\n  free(globalize_specific_buffer);\n  free(keepglobal_specific_buffer);\n  free(weaken_specific_buffer);\n  return status;\nLAB_00116d48:\n  bVar7 \u003d pbVar28[1];\n  pbVar28 \u003d pbVar28 + 1;\n  if (bVar7 \u003d\u003d 0) goto LAB_0011728f;\n  goto LAB_00116d58;\nLAB_00117086:\n  param_1 \u003d (uint)unaff_R13;\n  goto LAB_0011708b;\nLAB_00117888:\n  uVar10 \u003d status;\n  if ((int)param_1 \u003c\u003d (int)unaff_R12) {\n    return status;\n  }\n  lVar30 \u003d get_file_size(ppcVar18[(long)unaff_R12]);\n  if (lVar30 \u003c 1) {\nLAB_00118edb:\n    status \u003d 1;\n  }\n  else {\n    pcVar32 \u003d ppcVar18[(long)unaff_R12];\n    if ((FILE *)ppuVar29 \u003d\u003d (FILE *)0x0) {\nLAB_001178b9:\n      pFVar21 \u003d (FILE *)template_in_dir(pcVar32);\n      iVar11 \u003d mkstemp((char *)pFVar21);\n      if (iVar11 \u003d\u003d -1) {\n        free(pFVar21);\n        uVar24 \u003d dcgettext(0,\"could not create temporary file to hold stripped copy\",5);\n        bfd_nonfatal_message(ppcVar18[(long)unaff_R12],0,0,uVar24);\n        goto LAB_00118edb;\n      }\n      iVar13 \u003d -1;\n      if (-1 \u003c iVar11) {\n        iVar13 \u003d dup(iVar11);\n      }\n    }\n    else {\n      iVar11 \u003d filename_cmp(pcVar32,ppuVar29);\n      if (iVar11 \u003d\u003d 0) {\n        pcVar32 \u003d ppcVar18[(long)unaff_R12];\n        goto LAB_001178b9;\n      }\n      iVar11 \u003d -1;\n      iVar13 \u003d -1;\n      pFVar21 \u003d (FILE *)ppuVar29;\n    }\n    status \u003d 0;\n    copy_file(ppcVar18[(long)unaff_R12],pFVar21,iVar11,local_c8,local_130,pFVar14,0);\n    if (status \u003d\u003d 0) {\n      pFVar33 \u003d (FILE *)ppuVar29;\n      if ((FILE *)ppuVar29 \u003d\u003d (FILE *)0x0) {\n        pFVar33 \u003d (FILE *)ppcVar18[(long)unaff_R12];\n      }\n      iVar11 \u003d smart_rename(pFVar21,pFVar33,iVar13,local_c8,preserve_dates);\n      status \u003d uVar10;\n      if (iVar11 !\u003d 0) {\n        status \u003d 1;\n      }\n    }\n    else {\n      if (-1 \u003c iVar13) {\n        close(iVar13);\n      }\n      unlink_if_ordinary(pFVar21);\n    }\n    if ((FILE *)ppuVar29 !\u003d pFVar21) {\n      free(pFVar21);\n    }\n  }\n  unaff_R12 \u003d (FILE *)((long)\u0026unaff_R12-\u003e_flags + 1);\n  goto LAB_00117888;\nswitchD_001177df_caseD_d2:\n  strip_symbols \u003d 3;\n  goto switchD_001177df_caseD_0;\nLAB_001189a2:\n  pcVar32 \u003d \"bad format for --set-section-alignment: numeric argument needed\";\n  goto LAB_00117aed;\nLAB_00119858:\n  if (iVar13 \u003d\u003d 10) goto LAB_0011902d;\n  if (iVar13 \u003d\u003d 0xd) goto LAB_00119866;\n  if (iVar13 + 1U \u003c 2) goto LAB_001198cd;\n  if ((iVar13 !\u003d 0x20) \u0026\u0026 (iVar13 !\u003d 9)) {\n    if (iVar13 !\u003d 0x23) goto LAB_001198d6;\n    goto LAB_001198ec;\n  }\n  iVar13 \u003d getc((FILE *)ppuVar29);\n  goto LAB_00119858;\nLAB_0011902d:\n  if (iVar13 \u003d\u003d 0xd) {\nLAB_00119866:\n    iVar13 \u003d getc((FILE *)ppuVar29);\n    if (iVar13 \u003d\u003d 10) {\n      if (*(char *)(int *)unaff_R13 !\u003d \u0027\\0\u0027) {\n        add_redefine_and_check\n                  (pFVar14,unaff_R13,\n                   (undefined *)((long)\u0026unaff_R12-\u003e_flags + (long)(int *)unaff_R13));\n      }\n      goto LAB_0011988e;\n    }\nLAB_001198cd:\n    if (iVar13 !\u003d -1) {\nLAB_001198d6:\n      pcVar32 \u003d \"%s:%d: garbage found at end of line\";\nLAB_00119756:\n      uVar24 \u003d dcgettext(0,pcVar32,5);\n                    \n      fatal(uVar24,pFVar14,iVar11 + -1);\n    }\n  }\n  else {\n    iVar13 \u003d 10;\n  }\nLAB_0011903b:\n  if (*(char *)(int *)unaff_R13 !\u003d \u0027\\0\u0027) {\n    add_redefine_and_check\n              (pFVar14,unaff_R13,(undefined *)((long)\u0026unaff_R12-\u003e_flags + (long)(int *)unaff_R13));\n  }\n  unaff_R12 \u003d (FILE *)ppuVar29;\n  if (iVar13 \u003d\u003d -1) goto LAB_00119065;\nLAB_0011988e:\n  iVar13 \u003d getc((FILE *)ppuVar29);\n  iVar11 \u003d iVar11 + 1;\n  goto LAB_00118ace;\nswitchD_00117234_caseD_c7:\n  pcVar32 \u003d strchr((char *)_optarg,0x3d);\n  if ((pcVar32 !\u003d (char *)0x0) \u0026\u0026 ((int)pcVar32 !\u003d iVar11)) {\n    uVar27 \u003d (long)pcVar32 - (long)pFVar14 \u0026 0xffffffff;\n    pcVar34 \u003d pcVar32 + 1;\n    pcVar26 \u003d (char *)xmalloc((int)((long)pcVar32 - (long)pFVar14) + 1);\n    strncpy(pcVar26,(char *)_optarg,uVar27);\n    pcVar26[uVar27] \u003d \u0027\\0\u0027;\n    pcVar32 \u003d strchr(pcVar34,0x2c);\n    if (pcVar32 \u003d\u003d (char *)0x0) {\n      unaff_R12 \u003d (FILE *)0xffffffff;\n      sVar15 \u003d strlen(pcVar34);\n      sVar15 \u003d sVar15 \u0026 0xffffffff;\n    }\n    else {\n      sVar15 \u003d (size_t)(uint)((int)pcVar32 - (int)pcVar34);\n      uVar10 \u003d parse_flags(pcVar32 + 1);\n      unaff_R12 \u003d (FILE *)(ulong)uVar10;\n    }\n    if ((int)sVar15 !\u003d 0) {\n      unaff_R13 \u003d (char *)xmalloc((int)sVar15 + 1);\n      strncpy(unaff_R13,pcVar34,sVar15);\n      *(undefined *)((long)(int *)unaff_R13 + sVar15) \u003d 0;\n      ppuVar29 \u003d (undefined **)section_rename_list;\n      goto LAB_00117f6f;\n    }\n  }\n  uVar24 \u003d dcgettext(0,\"bad format for %s\",5);\n                    \n  fatal(uVar24,\"--rename-section\");\ncode_r0x00117223:\n  iVar11 \u003d (int)_optarg;\n  switch(pcVar26) {\n  case (char *)0x0:\n    goto switchD_00117234_caseD_0;\n  default:\nswitchD_00117234_caseD_1:\n    copy_usage(_stderr,1);\n    do {\n      iVar11 \u003d strcmp(*ppuVar29,pcVar26);\n      if (iVar11 \u003d\u003d 0) {\n        iVar11 \u003d strcmp(*(char **)((long)ppuVar29 + 8),unaff_R13);\n        if ((iVar11 !\u003d 0) || ((int)unaff_R12 !\u003d *(int *)((long)ppuVar29 + 0x10))) {\n          uVar24 \u003d dcgettext(0,\"Multiple renames of section %s\",5);\n                    \n          fatal(uVar24,pcVar26);\n        }\n        goto switchD_00117234_caseD_0;\n      }\n      ppuVar29 \u003d (undefined **)*(FILE **)((long)ppuVar29 + 0x18);\nLAB_00117f6f:\n    } while ((FILE *)ppuVar29 !\u003d (FILE *)0x0);\n    pFVar14 \u003d (FILE *)xmalloc(0x20);\n    *(char **)pFVar14 \u003d pcVar26;\n    pFVar14-\u003e_IO_read_ptr \u003d unaff_R13;\n    *(int *)\u0026pFVar14-\u003e_IO_read_end \u003d (int)unaff_R12;\n    pFVar14-\u003e_IO_read_base \u003d (char *)section_rename_list;\n    section_rename_list \u003d pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x42:\n    ppuVar29 \u003d (undefined **)\u0026optarg;\n    local_120 \u003d (FILE *)bfd_scan_arch(_optarg);\n    if (local_120 !\u003d (FILE *)0x0) goto switchD_00117234_caseD_0;\n    pcVar32 \u003d \"architecture %s unknown\";\n    pFVar14 \u003d _optarg;\n    break;\n  case (char *)0x44:\n    deterministic \u003d 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x46:\n    local_d0 \u003d _optarg;\n    local_d8 \u003d _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x47:\n    ppFVar23 \u003d (FILE **)htab_find_slot(keepglobal_specific_htab,_optarg,1);\n    *ppFVar23 \u003d pFVar14;\n    local_108 \u003d (long *)(ulong)bVar7;\n    ppuVar29 \u003d (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x48:\n  case (char *)0x68:\n    copy_usage(_stdout,0);\n  case (char *)0xcd:\n    _bfd_srec_forceS3 \u003d 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x49:\n  case (char *)0x73:\n    local_d8 \u003d _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4b:\n    ppFVar23 \u003d (FILE **)htab_find_slot(keep_specific_htab,_optarg,1);\n    *ppFVar23 \u003d pFVar14;\n    ppuVar29 \u003d (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4c:\n    ppFVar23 \u003d (FILE **)htab_find_slot(localize_specific_htab,_optarg,1);\n    *ppFVar23 \u003d pFVar14;\n    ppuVar29 \u003d (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4d:\n    merge_notes \u003d 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4e:\n    ppFVar23 \u003d (FILE **)htab_find_slot(strip_specific_htab,_optarg,1);\n    *ppFVar23 \u003d pFVar14;\n    ppuVar29 \u003d (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4f:\n  case (char *)0x64:\n    local_d0 \u003d _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x52:\n    handle_remove_section_option(_optarg);\n    goto switchD_00117234_caseD_0;\n  case (char *)0x53:\n    strip_symbols \u003d 7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x55:\n    deterministic \u003d 0;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x56:\n    local_110 \u003d (ulong)bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x57:\n    ppFVar23 \u003d (FILE **)htab_find_slot(weaken_specific_htab,_optarg,1);\n    *ppFVar23 \u003d pFVar14;\n    ppuVar29 \u003d (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x58:\n    discard_locals \u003d 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x62:\n    lVar30 \u003d strtol((char *)_optarg,(char **)0x0,10);\n    copy_byte \u003d (int)lVar30;\n    if (copy_byte \u003c 0) {\n      pcVar32 \u003d \"byte number must be non-negative\";\n      goto LAB_00117aed;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0x67:\n    strip_symbols \u003d 2;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x69:\n    if (_optarg \u003d\u003d (FILE *)0x0) {\n      interleave \u003d 4;\n    }\n    else {\n      lVar30 \u003d strtol((char *)_optarg,(char **)0x0,10);\n      interleave \u003d (int)lVar30;\n      if (interleave \u003c 1) {\n        pcVar32 \u003d \"interleave must be positive\";\n        goto LAB_00117aed;\n      }\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0x6a:\n    find_section_list(_optarg,1,2);\n    sections_copied \u003d 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x70:\n    preserve_dates \u003d 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x76:\n    verbose \u003d 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x77:\n    wildcard \u003d 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x78:\n    discard_locals \u003d 2;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x96:\n    add_sections \u003d init_section_add(_optarg,add_sections,\"--add-section\");\n    section_add_load_file(add_sections);\n    goto switchD_00117234_caseD_0;\n  case (char *)0x97:\n    long_section_names \u003d 1;\n    gnu_debuglink_filename \u003d _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x98:\n    puVar20 \u003d (undefined8 *)xmalloc(0x30);\n    *puVar20 \u003d 0;\n    unaff_R13 \u003d (char *)_optarg;\n    pcVar32 \u003d strchr((char *)_optarg,0x3d);\n    if (pcVar32 \u003d\u003d (char *)0x0) {\n      uVar24 \u003d dcgettext(0,\"bad format for %s\",5);\n                    \n      fatal(uVar24,\"--add-symbol\");\n    }\n    ppuVar29 \u003d (undefined **)(pcVar32 + 1);\n    pcVar32 \u003d strchr((char *)ppuVar29,0x3a);\n    uVar24 \u003d xstrndup(unaff_R13);\n    puVar20[1] \u003d uVar24;\n    if (pcVar32 \u003d\u003d (char *)0x0) {\n      puVar20[4] \u003d 0;\n      lVar30 \u003d strtol((char *)ppuVar29,(char **)0x0,0);\n    }\n    else {\n      uVar24 \u003d xstrndup(ppuVar29);\n      puVar20[4] \u003d uVar24;\n      lVar30 \u003d strtol((char *)(FILE *)(pcVar32 + 1),(char **)0x0,0);\n      ppuVar29 \u003d (undefined **)(FILE *)(pcVar32 + 1);\n    }\n    puVar20[2] \u003d lVar30;\n    pcVar32 \u003d strchr((char *)ppuVar29,0x2c);\n    puVar20[5] \u003d 0;\n    if (pcVar32 \u003d\u003d (char *)0x0) {\n      *(undefined4 *)(puVar20 + 3) \u003d 2;\n      unaff_R12 \u003d (FILE *)0x0;\n    }\n    else {\n      ppuVar29 \u003d (undefined **)0x0;\n      pFVar14 \u003d (FILE *)(pcVar32 + 1);\n      do {\n        unaff_R12 \u003d pFVar14;\n        pcVar32 \u003d strchr((char *)unaff_R12,0x2c);\n        if (pcVar32 \u003d\u003d (char *)0x0) {\n          sVar15 \u003d strlen((char *)unaff_R12);\n          pFVar14 \u003d (FILE *)0x0;\n        }\n        else {\n          pFVar14 \u003d (FILE *)(pcVar32 + 1);\n          sVar15 \u003d (long)pcVar32 - (long)unaff_R12;\n        }\n        uVar10 \u003d (uint)ppuVar29;\n        if (sVar15 \u003d\u003d 5) {\n          iVar11 \u003d strncasecmp(\"local\",(char *)unaff_R12,5);\n          if (iVar11 \u003d\u003d 0) {\n            ppuVar29 \u003d (undefined **)(ulong)(uVar10 | 1);\n          }\n          else {\n            iVar11 \u003d strncasecmp(\"debug\",(char *)unaff_R12,5);\n            if (iVar11 !\u003d 0) goto LAB_001186b2;\n            ppuVar29 \u003d (undefined **)(ulong)(uVar10 | 4);\n          }\n        }\n        else if (sVar15 \u003d\u003d 6) {\n          iVar11 \u003d strncasecmp(\"global\",(char *)unaff_R12,6);\n          if ((iVar11 \u003d\u003d 0) || (iVar11 \u003d strncasecmp(\"export\",(char *)unaff_R12,6), iVar11 \u003d\u003d 0)) {\n            ppuVar29 \u003d (undefined **)(ulong)(uVar10 | 2);\n          }\n          else {\n            iVar11 \u003d strncasecmp(\"object\",(char *)unaff_R12,6);\n            if (iVar11 !\u003d 0) goto LAB_001186b2;\n            ppuVar29 \u003d (undefined **)(ulong)(uVar10 | 0x10000);\n          }\n        }\n        else if (sVar15 \u003d\u003d 8) {\n          iVar11 \u003d strncasecmp(\"function\",(char *)unaff_R12,8);\n          if (iVar11 \u003d\u003d 0) {\n            ppuVar29 \u003d (undefined **)(ulong)(uVar10 | 8);\n          }\n          else {\n            iVar11 \u003d strncasecmp(\"indirect\",(char *)unaff_R12,8);\n            if (iVar11 !\u003d 0) goto LAB_0011862f;\n            ppuVar29 \u003d (undefined **)((ulong)ppuVar29 | 0x2000);\n          }\n        }\n        else if (sVar15 \u003d\u003d 4) {\n          iVar11 \u003d strncasecmp(\"weak\",(char *)unaff_R12,4);\n          if (iVar11 \u003d\u003d 0) {\n            ppuVar29 \u003d (undefined **)((ulong)ppuVar29 | 0x80);\n          }\n          else {\n            iVar11 \u003d strncasecmp(\"file\",(char *)unaff_R12,4);\n            if (iVar11 !\u003d 0) goto LAB_001186b2;\n            ppuVar29 \u003d (undefined **)((ulong)ppuVar29 | 0x4000);\n          }\n        }\n        else if (sVar15 \u003d\u003d 7) {\n          iVar11 \u003d strncasecmp(\"section\",(char *)unaff_R12,7);\n          if (iVar11 \u003d\u003d 0) {\n            ppuVar29 \u003d (undefined **)((ulong)ppuVar29 | 0x100);\n          }\n          else {\n            iVar11 \u003d strncasecmp(\"warning\",(char *)unaff_R12,7);\n            if (iVar11 !\u003d 0) goto LAB_001186b2;\n            ppuVar29 \u003d (undefined **)((ulong)ppuVar29 | 0x1000);\n          }\n        }\n        else {\n          if (sVar15 \u003d\u003d 0xb) {\n            iVar11 \u003d strncasecmp(\"constructor\",(char *)unaff_R12,0xb);\n            if (iVar11 \u003d\u003d 0) {\n              ppuVar29 \u003d (undefined **)((ulong)ppuVar29 | 0x800);\n              goto LAB_00117e3d;\n            }\n          }\n          else if (sVar15 \u003d\u003d 9) {\n            iVar11 \u003d strncasecmp(\"synthetic\",(char *)unaff_R12,9);\n            if (iVar11 \u003d\u003d 0) {\n              ppuVar29 \u003d (undefined **)(ulong)(uVar10 | 0x200000);\n              goto LAB_00117e3d;\n            }\n          }\n          else if (sVar15 \u003d\u003d 0x11) {\n            iVar11 \u003d strncasecmp(\"indirect-function\",(char *)unaff_R12,0x11);\n            if (iVar11 \u003d\u003d 0) {\n              ppuVar29 \u003d (undefined **)(ulong)(uVar10 | 0x400008);\n              goto LAB_00117e3d;\n            }\n          }\n          else if (sVar15 \u003d\u003d 0xd) {\n            iVar11 \u003d strncasecmp(\"unique-object\",(char *)unaff_R12,0xd);\n            if (iVar11 \u003d\u003d 0) {\n              ppuVar29 \u003d (undefined **)(ulong)(uVar10 | 0x810000);\n              goto LAB_00117e3d;\n            }\n          }\n          else if (sVar15 \u003c 8) goto LAB_001186b2;\nLAB_0011862f:\n          iVar11 \u003d strncasecmp(\"before\u003d\",(char *)unaff_R12,7);\n          if (iVar11 !\u003d 0) {\nLAB_001186b2:\n            pcVar32 \u003d (char *)xmalloc(sVar15 + 1);\n            strncpy(pcVar32,(char *)unaff_R12,sVar15);\n            pcVar32[sVar15] \u003d \u0027\\0\u0027;\n            uVar24 \u003d dcgettext(0,\"unrecognized symbol flag `%s\\\u0027\",5);\n            non_fatal(uVar24,pcVar32);\n            uVar24 \u003d dcgettext(0,\"supported flags: %s\",5);\n                    \n            fatal(uVar24,\n                  \"local, global, export, debug, function, weak, section, constructor, warning, indirect, file, object, synthetic, indirect-function, unique-object, before\u003d\u003cothersym\u003e\"\n                 );\n          }\n          uVar24 \u003d xstrndup(\u0026unaff_R12-\u003efield_0x7,sVar15 - 7);\n          puVar20[5] \u003d uVar24;\n        }\nLAB_00117e3d:\n      } while (pFVar14 !\u003d (FILE *)0x0);\n      *(int *)(puVar20 + 3) \u003d (int)ppuVar29;\n      unaff_R13 \u003d (char *)0x0;\n      if (puVar20[5] !\u003d 0) {\n        *puVar20 \u003d add_sym_list;\n        bVar39 \u003d add_sym_list \u003d\u003d (undefined8 *)0x0;\n        add_sym_list \u003d puVar20;\n        if (bVar39) {\n          add_sym_tail \u003d (undefined *)puVar20;\n        }\n        goto LAB_00117e65;\n      }\n    }\n    *(undefined8 **)add_sym_tail \u003d puVar20;\n    add_sym_tail \u003d (undefined *)puVar20;\nLAB_00117e65:\n    add_symbols \u003d add_symbols + 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x99:\n    use_alt_mach_code \u003d strtoul((char *)_optarg,(char **)0x0,0);\n    if (use_alt_mach_code \u003d\u003d 0) {\n      pcVar32 \u003d \"unable to parse alternative machine code\";\n      goto LAB_00117aed;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0x9a:\n    change_section_address \u003d parse_vma(_optarg,\"--change-addresses\");\n    change_start \u003d change_section_address;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x9b:\n    change_leading_char \u003d 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x9c:\n  case (char *)0x9d:\n  case (char *)0x9e:\n    ppuVar29 \u003d (undefined **)strchr((char *)_optarg,0x3d);\n    if (uVar36 \u003d\u003d 0x9d) {\n      uVar12 \u003d 0x40;\n      unaff_R13 \u003d \"--change-section-lma\";\n      if ((FILE *)ppuVar29 !\u003d (FILE *)0x0) {\n        uVar12 \u003d 0x20;\n        goto LAB_00117a19;\n      }\n    }\n    else if (uVar36 \u003d\u003d 0x9e) {\n      if ((FILE *)ppuVar29 !\u003d (FILE *)0x0) {\n        unaff_R13 \u003d \"--change-section-vma\";\n        uVar12 \u003d 8;\n        goto LAB_00117a19;\n      }\n      uVar12 \u003d 0x10;\n      unaff_R13 \u003d \"--change-section-vma\";\n    }\n    else {\n      unaff_R13 \u003d \"--change-section-address\";\n      uVar12 \u003d 0x28;\n      if ((FILE *)ppuVar29 !\u003d (FILE *)0x0) goto LAB_00117a19;\n      uVar12 \u003d 0x50;\n    }\n    ppuVar29 \u003d (undefined **)strchr((char *)pFVar14,0x2b);\n    if (((FILE *)ppuVar29 \u003d\u003d (FILE *)0x0) \u0026\u0026\n       (ppuVar29 \u003d (undefined **)strchr((char *)pFVar14,0x2d), (FILE *)ppuVar29 \u003d\u003d (FILE *)0x0)) {\n      uVar24 \u003d dcgettext(0,\"bad format for %s\",5);\n                    \n      fatal(uVar24,unaff_R13);\n    }\nLAB_00117a19:\n    iVar11 \u003d (int)ppuVar29 - iVar11;\n    pcVar32 \u003d (char *)xmalloc((long)(iVar11 + 1));\n    unaff_R12 \u003d (FILE *)(long)iVar11;\n    pcVar32 \u003d strncpy(pcVar32,(char *)_optarg,(size_t)unaff_R12);\n    pcVar32[(long)unaff_R12] \u003d \u0027\\0\u0027;\n    lVar30 \u003d find_section_list(pcVar32,1,uVar12);\n    lVar17 \u003d parse_vma((undefined *)((long)(int *)ppuVar29 + 1),unaff_R13);\n    if (*(char *)(int *)ppuVar29 \u003d\u003d \u0027-\u0027) {\n      lVar17 \u003d -lVar17;\n    }\n    if ((uVar36 \u003d\u003d 0x9d) || (*(long *)(lVar30 + 0x18) \u003d lVar17, uVar36 !\u003d 0x9e)) {\n      *(long *)(lVar30 + 0x20) \u003d lVar17;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0x9f:\n    change_start \u003d parse_vma(_optarg,\"--change-start\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa0:\n    local_130 \u003d (FILE *)(ulong)bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa1:\n    ppuVar29 \u003d (undefined **)_optarg;\n    if (_optarg \u003d\u003d (FILE *)0x0) {\nLAB_00118398:\n      do_debug_sections \u003d 1;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 \u003d strcasecmp((char *)_optarg,\"none\");\n    if (iVar11 \u003d\u003d 0) {\n      do_debug_sections \u003d 0x20;\n      ppuVar29 \u003d (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 \u003d strcasecmp((char *)pFVar14,\"zlib\");\n    if (iVar11 \u003d\u003d 0) {\n      do_debug_sections \u003d 3;\n      ppuVar29 \u003d (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 \u003d strcasecmp((char *)pFVar14,\"zlib-gnu\");\n    if (iVar11 \u003d\u003d 0) {\n      do_debug_sections \u003d 5;\n      ppuVar29 \u003d (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 \u003d strcasecmp((char *)pFVar14,\"zlib-gabi\");\n    if (iVar11 \u003d\u003d 0) {\n      do_debug_sections \u003d 9;\n      ppuVar29 \u003d (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 \u003d strcasecmp((char *)pFVar14,\"zstd\");\n    if (iVar11 \u003d\u003d 0) {\n      do_debug_sections \u003d 0x11;\n      ppuVar29 \u003d (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    pcVar32 \u003d \"unrecognized --compress-debug-sections type `%s\\\u0027\";\n    break;\n  case (char *)0xa2:\n    convert_debugging \u003d 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa3:\n    do_debug_sections \u003d 0x20;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa4:\n    dump_sections \u003d init_section_add(_optarg,dump_sections,\"--dump-section\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa5:\n    iVar11 \u003d strcasecmp((char *)_optarg,\"yes\");\n    if (iVar11 \u003d\u003d 0) {\n      do_elf_stt_common \u003d 1;\n      ppuVar29 \u003d (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 \u003d strcasecmp((char *)pFVar14,\"no\");\n    if (iVar11 \u003d\u003d 0) {\n      do_elf_stt_common \u003d 2;\n      ppuVar29 \u003d (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    pcVar32 \u003d \"unrecognized --elf-stt-common\u003d option `%s\\\u0027\";\n    break;\n  case (char *)0xa6:\n    strip_symbols \u003d 6;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa7:\n    extract_symbol \u003d 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa8:\n    pe_file_alignment \u003d parse_vma(_optarg,\"--file-alignment\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa9:\n    local_118 \u003d (size_t)bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xaa:\n    ppuVar29 \u003d (undefined **)parse_vma(_optarg,\"--gap-fill\");\n    gap_fill \u003d SUB81(ppuVar29,0);\n    if ((FILE *)0xff \u003c ppuVar29) {\n      uVar24 \u003d dcgettext(0,\"Warning: truncating gap-fill from 0x%lx to 0x%x\",5);\n      non_fatal(uVar24,ppuVar29,(ulong)ppuVar29 \u0026 0xff);\n    }\n    gap_fill_set \u003d 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xab:\n    ppFVar23 \u003d (FILE **)htab_find_slot(globalize_specific_htab,_optarg,1);\n    *ppFVar23 \u003d pFVar14;\n    ppuVar29 \u003d (undefined **)pFVar14;\n    bVar2 \u003d bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xac:\n    add_specific_symbols(_optarg,globalize_specific_htab,\u0026globalize_specific_buffer);\n    bVar2 \u003d bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xad:\n    pe_heap_reserve \u003d strtoul((char *)_optarg,(char **)(FILE *)local_c8,0);\n    unaff_R12 \u003d _optarg;\n    ppuVar29 \u003d (undefined **)(FILE *)local_c8;\n    if ((FILE *)local_c8._0_8_ !\u003d _optarg) {\n      if (*(char *)(int *)local_c8._0_8_ \u003d\u003d \u0027.\u0027) {\n        pe_heap_commit \u003d\n             strtoul((char *)((long)(int *)local_c8._0_8_ + 1),(char **)(FILE *)local_c8,0);\n        pFVar14 \u003d _optarg;\n        if (*(char *)(int *)local_c8._0_8_ !\u003d \u0027\\0\u0027) {\n          uVar24 \u003d dcgettext(0,\"%s: invalid commit value for --heap\",5);\n          non_fatal(uVar24,pFVar14);\n          ppuVar29 \u003d (undefined **)pFVar14;\n        }\n        goto switchD_00117234_caseD_0;\n      }\n      if (*(char *)(int *)local_c8._0_8_ \u003d\u003d \u0027\\0\u0027) goto switchD_00117234_caseD_0;\n    }\n    uVar24 \u003d dcgettext(0,\"%s: invalid reserve value for --heap\",5);\n    non_fatal(uVar24,unaff_R12);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xae:\n    pe_image_base \u003d parse_vma(_optarg,\"--image-base\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xaf:\n    bfd_flags_to_clear \u003d bfd_flags_to_clear | 0x100;\n    bfd_flags_to_set \u003d bfd_flags_to_set \u0026 0xfffffeff;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb0:\n    lVar30 \u003d strtol((char *)_optarg,(char **)0x0,10);\n    copy_width \u003d (int)lVar30;\n    if (copy_width \u003c 1) {\n      pcVar32 \u003d \"interleave width must be positive\";\n      goto LAB_00117aed;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb1:\n    add_specific_symbols(_optarg,keepglobal_specific_htab,\u0026keepglobal_specific_buffer);\n    local_108 \u003d (long *)(ulong)bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb2:\n    keep_file_symbols \u003d 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb3:\n    find_section_list(_optarg,1,4);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb4:\n    add_specific_symbols(_optarg,keep_specific_htab,\u0026keep_specific_buffer);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb5:\n    keep_section_symbols \u003d 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb6:\n    localize_hidden \u003d 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb7:\n    add_specific_symbols(_optarg,localize_specific_htab,\u0026localize_specific_buffer);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb8:\n    iVar11 \u003d strcmp(\"enable\",(char *)_optarg);\n    if (iVar11 \u003d\u003d 0) {\n      long_section_names \u003d 1;\n      ppuVar29 \u003d (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 \u003d strcmp(\"disable\",(char *)pFVar14);\n    if (iVar11 \u003d\u003d 0) {\n      long_section_names \u003d 0;\n      ppuVar29 \u003d (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 \u003d strcmp(\"keep\",(char *)pFVar14);\n    if (iVar11 \u003d\u003d 0) {\n      long_section_names \u003d 2;\n      ppuVar29 \u003d (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    pcVar32 \u003d \"unknown long section names option \\\u0027%s\\\u0027\";\n    break;\n  case (char *)0xba:\n    merge_notes \u003d 0;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbb:\n    local_130 \u003d (FILE *)0x0;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbc:\n    strip_symbols \u003d 4;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbd:\n    pad_to \u003d parse_vma(_optarg,\"--pad-to\");\n    pad_to_set \u003d 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbe:\n    prefix_alloc_sections_string \u003d _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbf:\n    prefix_sections_string \u003d _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc0:\n    prefix_symbols_string \u003d _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc1:\nswitchD_00117234_caseD_c1:\n    bfd_flags_to_set \u003d bfd_flags_to_set | 0x100;\n    bfd_flags_to_clear \u003d bfd_flags_to_clear \u0026 0xfffffeff;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc2:\n    bfd_flags_to_set \u003d bfd_flags_to_set | 0x80;\n    bfd_flags_to_clear \u003d bfd_flags_to_clear \u0026 0xffffff7f;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc3:\n    unaff_R13 \u003d \u0026optarg;\n    pcVar32 \u003d strchr((char *)_optarg,0x3d);\n    if (pcVar32 \u003d\u003d (char *)0x0) {\n      uVar24 \u003d dcgettext(0,\"bad format for %s\",5);\n                    \n      fatal(uVar24,\"--redefine-sym\");\n    }\n    ppuVar29 \u003d (undefined **)(pcVar32 + 1);\n    iVar11 \u003d (int)pcVar32 - iVar11;\n    pcVar32 \u003d (char *)xmalloc((long)(iVar11 + 1));\n    strncpy(pcVar32,(char *)_optarg,(long)iVar11);\n    pcVar32[iVar11] \u003d \u0027\\0\u0027;\n    sVar15 \u003d strlen((char *)ppuVar29);\n    unaff_R12 \u003d (FILE *)xmalloc((long)((int)sVar15 + 1));\n    strcpy((char *)unaff_R12,(char *)ppuVar29);\n    add_redefine_and_check(\"--redefine-sym\",pcVar32,unaff_R12);\n    free(pcVar32);\n    free(unaff_R12);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc4:\n    ppuVar29 \u003d (undefined **)fopen((char *)_optarg,\"r\");\n    if ((FILE *)ppuVar29 \u003d\u003d (FILE *)0x0) {\n      piVar25 \u003d __errno_location();\n      pcVar32 \u003d strerror(*piVar25);\n      uVar24 \u003d dcgettext(0,\"couldn\\\u0027t open symbol redefinition file %s (error: %s)\",5);\n                    \n      fatal(uVar24,pFVar14,pcVar32);\n    }\n    pFVar21 \u003d (FILE *)0x64;\n    unaff_R13 \u003d (char *)xmalloc(0x65);\n    iVar13 \u003d getc((FILE *)ppuVar29);\n    iVar11 \u003d 2;\nLAB_00118ace:\n    unaff_R12 \u003d (FILE *)ppuVar29;\n    if (iVar13 !\u003d -1) {\n      pFVar33 \u003d (FILE *)0x0;\n      while ((iVar13 !\u003d 0x20 \u0026\u0026 (iVar13 !\u003d 9))) {\n        if ((iVar13 \u003d\u003d 10) || (iVar13 \u003d\u003d 0xd)) {\n          *(undefined *)((long)\u0026pFVar33-\u003e_flags + (long)(int *)unaff_R13) \u003d 0;\n          goto LAB_00118faa;\n        }\n        if (iVar13 \u003d\u003d 0) break;\n        if (iVar13 \u003d\u003d -1) {\n          *(undefined *)((long)\u0026pFVar33-\u003e_flags + (long)(int *)unaff_R13) \u003d 0;\n          unaff_R12 \u003d (FILE *)((long)\u0026pFVar33-\u003e_flags + 1);\n          goto LAB_00119803;\n        }\n        unaff_R12 \u003d pFVar33;\n        if (iVar13 \u003d\u003d 0x23) goto LAB_00119745;\n        pFVar38 \u003d (FILE *)((long)\u0026pFVar33-\u003e_flags + 1);\n        *(char *)((long)\u0026pFVar33-\u003e_flags + (long)(int *)unaff_R13) \u003d (char)iVar13;\n        if (pFVar21 \u003c\u003d pFVar38) {\n          pFVar21 \u003d (FILE *)((long)pFVar21 * 2);\n          unaff_R13 \u003d (char *)xrealloc(unaff_R13,(undefined *)((long)\u0026pFVar21-\u003e_flags + 1));\n        }\n        iVar13 \u003d getc((FILE *)ppuVar29);\n        pFVar33 \u003d pFVar38;\n      }\n      unaff_R12 \u003d (FILE *)((long)\u0026pFVar33-\u003e_flags + 1);\n      *(undefined *)((long)\u0026pFVar33-\u003e_flags + (long)(int *)unaff_R13) \u003d 0;\n      while ((iVar13 \u003d\u003d 0x20 || (iVar13 \u003d\u003d 9))) {\n        iVar13 \u003d getc((FILE *)ppuVar29);\n      }\n      if (iVar13 \u003d\u003d 0x23) {\nLAB_00119745:\n        if (unaff_R12 !\u003d (FILE *)0x0) goto LAB_0011974a;\n        pFVar33 \u003d (FILE *)0x0;\n        unaff_R12 \u003d (FILE *)0x0;\nLAB_001197ca:\n        *(undefined *)((long)\u0026pFVar33-\u003e_flags + (long)(int *)unaff_R13) \u003d 0;\n        while ((iVar13 !\u003d 10 \u0026\u0026 (iVar13 !\u003d -1))) {\n          iVar13 \u003d getc((FILE *)ppuVar29);\n        }\n        goto LAB_0011903b;\n      }\nLAB_00118faa:\n      unaff_R12 \u003d (FILE *)((long)\u0026pFVar33-\u003e_flags + 1);\n      if (((iVar13 \u003d\u003d 10) || (iVar13 \u003d\u003d 0xd)) || (iVar13 \u003d\u003d 0)) goto LAB_00119745;\n      pFVar38 \u003d unaff_R12;\n      if (iVar13 !\u003d -1) {\n        do {\n          pFVar33 \u003d (FILE *)((long)\u0026pFVar38-\u003e_flags + 1);\n          *(char *)((long)\u0026pFVar38-\u003e_flags + (long)(int *)unaff_R13) \u003d (char)iVar13;\n          if (pFVar21 \u003c\u003d pFVar33) {\n            pFVar21 \u003d (FILE *)((long)pFVar21 * 2);\n            unaff_R13 \u003d (char *)xrealloc(unaff_R13,(undefined *)((long)\u0026pFVar21-\u003e_flags + 1));\n          }\n          iVar13 \u003d getc((FILE *)ppuVar29);\n          if ((iVar13 \u003d\u003d 0x20) || (iVar13 \u003d\u003d 9)) {\nLAB_001198b6:\n            *(undefined *)((long)\u0026pFVar33-\u003e_flags + (long)(int *)unaff_R13) \u003d 0;\n            pFVar33 \u003d (FILE *)((long)\u0026pFVar38-\u003e_flags + 2);\n            goto LAB_00119858;\n          }\n          if ((iVar13 \u003d\u003d 10) || (iVar13 \u003d\u003d 0xd)) {\n            *(undefined *)((long)\u0026pFVar33-\u003e_flags + (long)(int *)unaff_R13) \u003d 0;\n            goto LAB_0011902d;\n          }\n          if (iVar13 \u003d\u003d 0) goto LAB_001198b6;\n          if (iVar13 \u003d\u003d -1) {\n            *(undefined *)((long)\u0026pFVar33-\u003e_flags + (long)(int *)unaff_R13) \u003d 0;\n            unaff_R12 \u003d (FILE *)((long)\u0026pFVar38-\u003e_flags + 2);\n            goto LAB_00119803;\n          }\n          pFVar38 \u003d pFVar33;\n        } while (iVar13 !\u003d 0x23);\nLAB_001198ec:\n        if ((pFVar33 \u003d\u003d (FILE *)0x0) || ((unaff_R12 !\u003d (FILE *)0x0 \u0026\u0026 (unaff_R12 !\u003d pFVar33)))) {\n          iVar13 \u003d 0x23;\n          goto LAB_001197ca;\n        }\nLAB_0011974a:\n        pcVar32 \u003d \"%s:%d: missing new symbol name\";\n        goto LAB_00119756;\n      }\nLAB_00119803:\n      if (unaff_R12 !\u003d (FILE *)0x0) {\n        pcVar32 \u003d \"%s:%d: premature end of file\";\n        goto LAB_00119756;\n      }\n    }\nLAB_00119065:\n    free(unaff_R13);\n    fclose((FILE *)ppuVar29);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc5:\n    remove_leading_char \u003d 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc6:\n    find_section_list(_optarg,1,0x100);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc7:\n    goto switchD_00117234_caseD_c7;\n  case (char *)0xc8:\n    ppuVar29 \u003d (undefined **)(ulong)reverse_bytes;\n    uVar27 \u003d strtol((char *)_optarg,(char **)0x0,10);\n    reverse_bytes \u003d (uint)uVar27;\n    if (((int)reverse_bytes \u003c 1) || ((uVar27 \u0026 1) !\u003d 0)) {\n      pcVar32 \u003d \"number of bytes to reverse must be positive and even\";\n      goto LAB_00117aed;\n    }\n    if ((uVar10 !\u003d reverse_bytes) \u0026\u0026 (uVar10 !\u003d 0)) {\n      uVar24 \u003d dcgettext(0,\"Warning: ignoring previous --reverse-bytes value of %d\",5);\n      non_fatal(uVar24,uVar10);\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc9:\n    pe_section_alignment \u003d parse_vma(_optarg,\"--section-alignment\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xca:\n    unaff_R12 \u003d (FILE *)strchr((char *)_optarg,0x3d);\n    if (unaff_R12 \u003d\u003d (FILE *)0x0) {\n      uVar24 \u003d dcgettext(0,\"bad format for %s\",5);\n                    \n      fatal(uVar24,\"--set-section-flags\");\n    }\n    iVar11 \u003d (int)unaff_R12 - iVar11;\n    pcVar32 \u003d (char *)xmalloc((long)(iVar11 + 1));\n    pcVar32 \u003d strncpy(pcVar32,(char *)_optarg,(long)iVar11);\n    pcVar32[iVar11] \u003d \u0027\\0\u0027;\n    ppuVar29 \u003d (undefined **)find_section_list(pcVar32,1,0x80);\n    uVar12 \u003d parse_flags((undefined *)((long)\u0026unaff_R12-\u003e_flags + 1));\n    *(undefined4 *)((long)ppuVar29 + 0x28) \u003d uVar12;\n    unaff_R13 \u003d (char *)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xcb:\n    pcVar32 \u003d strchr((char *)_optarg,0x3d);\n    if (pcVar32 \u003d\u003d (char *)0x0) {\n      pcVar32 \u003d \"bad format for --set-section-alignment: argument needed\";\n      goto LAB_00117aed;\n    }\n    uVar27 \u003d strtol(pcVar32 + 1,(char **)0x0,10);\n    if ((int)uVar27 \u003c 1) goto LAB_001189a2;\n    unaff_R12 \u003d (FILE *)0x0;\n    while( true ) {\n      if ((uVar27 \u0026 1) !\u003d 0) break;\n      uVar27 \u003d (ulong)(uint)((int)uVar27 \u003e\u003e 1);\n      unaff_R12 \u003d (FILE *)(ulong)((int)unaff_R12 + 1);\n    }\n    if ((int)uVar27 !\u003d 1) {\n      pcVar32 \u003d \"bad format for --set-section-alignment: alignment is not a power of two\";\n      goto LAB_00117aed;\n    }\n    iVar11 \u003d (int)pcVar32 - (int)_optarg;\n    ppuVar29 \u003d (undefined **)(long)iVar11;\n    pcVar32 \u003d (char *)xmalloc((long)(iVar11 + 1));\n    pcVar32 \u003d strncpy(pcVar32,(char *)_optarg,(size_t)ppuVar29);\n    pcVar32[(long)ppuVar29] \u003d \u0027\\0\u0027;\n    lVar30 \u003d find_section_list(pcVar32,1,0x200);\n    if (lVar30 !\u003d 0) {\n      *(int *)(lVar30 + 0x2c) \u003d (int)unaff_R12;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xcc:\n    set_start \u003d parse_vma(_optarg,\"--set-start\");\n    set_start_set \u003d 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xce:\n    __bfd_srec_len \u003d parse_vma(_optarg,\"--srec-len\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xcf:\n    pe_stack_reserve \u003d strtoul((char *)_optarg,(char **)(FILE *)local_c8,0);\n    unaff_R12 \u003d _optarg;\n    ppuVar29 \u003d (undefined **)(FILE *)local_c8;\n    if ((FILE *)local_c8._0_8_ !\u003d _optarg) {\n      if (*(char *)(int *)local_c8._0_8_ \u003d\u003d \u0027.\u0027) {\n        pe_stack_commit \u003d\n             strtoul((char *)((long)(int *)local_c8._0_8_ + 1),(char **)(FILE *)local_c8,0);\n        pFVar14 \u003d _optarg;\n        if (*(char *)(int *)local_c8._0_8_ !\u003d \u0027\\0\u0027) {\n          uVar24 \u003d dcgettext(0,\"%s: invalid commit value for --stack\",5);\n          non_fatal(uVar24,pFVar14);\n          ppuVar29 \u003d (undefined **)pFVar14;\n        }\n        goto switchD_00117234_caseD_0;\n      }\n      if (*(char *)(int *)local_c8._0_8_ \u003d\u003d \u0027\\0\u0027) goto switchD_00117234_caseD_0;\n    }\n    uVar24 \u003d dcgettext(0,\"%s: invalid reserve value for --stack\",5);\n    non_fatal(uVar24,unaff_R12);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd0:\n    strip_symbols \u003d 5;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd1:\n    add_specific_symbols(_optarg,strip_specific_htab,\u0026strip_specific_buffer);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd2:\n    strip_symbols \u003d 3;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd3:\n    ppFVar23 \u003d (FILE **)htab_find_slot(strip_unneeded_htab,_optarg,1);\n    *ppFVar23 \u003d pFVar14;\n    ppuVar29 \u003d (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd4:\n    add_specific_symbols(_optarg,strip_unneeded_htab,\u0026strip_unneeded_buffer);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd5:\n    pcVar32 \u003d strchr((char *)_optarg,0x3a);\n    pFVar21 \u003d pFVar14;\n    if (pcVar32 !\u003d (char *)0x0) {\n      pFVar21 \u003d (FILE *)xstrdup(pFVar14);\n      lVar30 \u003d (long)((int)pcVar32 - iVar11);\n      *(undefined *)((long)\u0026pFVar21-\u003e_flags + lVar30) \u003d 0;\n      local_c8._0_8_ \u003d pFVar21;\n      uVar27 \u003d strtoul((char *)((long)\u0026pFVar21-\u003e_flags + lVar30 + 1),(char **)local_c8,0);\n      pe_major_subsystem_version \u003d (undefined2)uVar27;\n      if (*(char *)(int *)local_c8._0_8_ \u003d\u003d \u0027.\u0027) {\n        uVar27 \u003d strtoul((char *)((long)(int *)local_c8._0_8_ + 1),(char **)local_c8,0);\n        pe_minor_subsystem_version \u003d (undefined2)uVar27;\n      }\n      if (*(char *)(int *)local_c8._0_8_ !\u003d \u0027\\0\u0027) {\n        uVar24 \u003d dcgettext(0,\"%s: bad version in PE subsystem\",5);\n        non_fatal(uVar24,pFVar14);\n      }\n    }\n    lVar30 \u003d strtol((char *)pFVar21,(char **)local_c8,0);\n    if (*(char *)(int *)local_c8._0_8_ \u003d\u003d \u0027\\0\u0027) {\n      lVar17 \u003d 0;\n      while ((short)lVar30 !\u003d (\u0026DAT_00125caa)[lVar17 * 8]) {\n        lVar17 \u003d lVar17 + 1;\n        if (lVar17 \u003d\u003d 10) goto LAB_00119248;\n      }\n      ppuVar29 \u003d \u0026v_0;\n      cVar8 \u003d (\u0026DAT_00125ca8)[lVar17 * 0x10];\n      pe_subsystem \u003d (short)lVar30;\n    }\n    else {\n      unaff_R13 \u003d (char *)0x0;\n      while( true ) {\n        iVar11 \u003d strcmp((char *)pFVar21,(\u0026v_0)[(long)unaff_R13 * 2]);\n        if (iVar11 \u003d\u003d 0) break;\n        unaff_R13 \u003d (char *)((long)(int *)unaff_R13 + 1);\n        if ((FILE *)unaff_R13 \u003d\u003d (FILE *)0xa) goto LAB_00119248;\n      }\n      ppuVar29 \u003d \u0026v_0 + (long)unaff_R13 * 2;\n      pe_subsystem \u003d (\u0026DAT_00125caa)[(long)unaff_R13 * 8];\n      cVar8 \u003d (\u0026DAT_00125ca8)[(long)unaff_R13 * 0x10];\n    }\n    if (cVar8 \u003d\u003d -1) {\nLAB_00119248:\n      uVar24 \u003d dcgettext(0,\"unknown PE subsystem: %s\",5);\n                    \n      fatal(uVar24,pFVar14);\n    }\n    if (cVar8 !\u003d \u0027\\0\u0027) {\n      if (pe_file_alignment \u003d\u003d -1) {\n        pe_file_alignment \u003d 0x200;\n      }\n      if (pe_section_alignment \u003d\u003d -1) {\n        pe_section_alignment \u003d 0x1000;\n      }\n    }\n    unaff_R12 \u003d pFVar14;\n    if (pFVar14 !\u003d pFVar21) {\n      free(pFVar21);\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd6:\n    update_sections \u003d init_section_add(_optarg,update_sections,\"--update-section\");\n    section_add_load_file(update_sections);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd7:\n    _VerilogDataWidth \u003d parse_vma(_optarg,\"--verilog-data-width\");\n    if ((0x10 \u003c _VerilogDataWidth) || ((0x10116UL \u003e\u003e ((byte)_VerilogDataWidth \u0026 0x3f) \u0026 1) \u003d\u003d 0)) {\n      pcVar32 \u003d \"error: verilog data width must be 1, 2, 4, 8 or 16\";\n      goto LAB_00117aed;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd8:\n    weaken \u003d 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd9:\n    add_specific_symbols(_optarg,weaken_specific_htab,\u0026weaken_specific_buffer);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xda:\n    bfd_flags_to_clear \u003d bfd_flags_to_clear | 0x80;\n    bfd_flags_to_set \u003d bfd_flags_to_set \u0026 0xffffff7f;\n    goto switchD_00117234_caseD_0;\n  }\nLAB_001176c2:\n  uVar24 \u003d dcgettext(0,pcVar32,5);\n                    \n  fatal(uVar24,pFVar14);\n}\n\n",
      "renaming": {},
      "calling": [
        "_start"
      ],
      "called": [
        "htab_elements",
        "fclose",
        "strchr",
        "smart_rename",
        "init_section_add",
        "strerror",
        "fread",
        "strlen",
        "mkstemp",
        "__errno_location",
        "create_symbol_htab",
        "htab_find_slot",
        "delete_symbol_htabs",
        "bfd_set_default_target",
        "xstrndup",
        "bfd_set_error_program_name",
        "strcasecmp",
        "bfd_scan_arch",
        "strcmp",
        "stat",
        "getopt_long",
        "unlink_if_ordinary",
        "copy_file",
        "xmalloc",
        "bindtextdomain",
        "xexit",
        "non_fatal",
        "get_file_size",
        "parse_flags",
        "free",
        "ferror",
        "malloc",
        "htab_create_alloc",
        "fatal",
        "xcalloc",
        "section_add_load_file",
        "xstrdup",
        "copy_usage",
        "free",
        "xatexit_cleanup.lto_priv.0",
        "getc",
        "fseek",
        "display_info.isra.0",
        "fopen",
        "find_section_list",
        "strip_usage",
        "dcgettext",
        "xrealloc",
        "handle_remove_section_option",
        "add_redefine_and_check",
        "template_in_dir",
        "strtol",
        "htab_hash_redefnode",
        "memmove",
        "setlocale",
        "print_version",
        "convert_efi_target",
        "bfd_init",
        "startswith.lto_priv.0.lto_priv.0",
        "strcpy",
        "dup",
        "memcpy",
        "strtoul",
        "fprintf",
        "textdomain",
        "filename_cmp",
        "bfd_errmsg",
        "bfd_get_error",
        "eq_string_redefnode",
        "ftell",
        "close",
        "strncasecmp",
        "parse_vma",
        "xmalloc_set_program_name",
        "add_specific_symbols",
        "strncpy",
        "bfd_nonfatal_message"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "parse_vma": {
      "entrypoint": "0x00119940",
      "current_name": "parse_vma",
      "code": "\nvoid parse_vma(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined8 uVar1;\n  char *local_20 [2];\n  \n  bfd_scan_vma(param_1,local_20,0);\n  if (*local_20[0] \u003d\u003d \u0027\\0\u0027) {\n    return;\n  }\n  uVar1 \u003d dcgettext(0,\"%s: bad number: %s\",5);\n                    \n  fatal(uVar1,param_2,param_1);\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "bfd_scan_vma",
        "parse_vma.cold"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "print_version": {
      "entrypoint": "0x00119970",
      "current_name": "print_version",
      "code": "\nvoid print_version(undefined8 param_1)\n\n{\n  char *pcVar1;\n  \n  printf(\"GNU %s %s\\n\",param_1,\"(GNU Binutils for Debian) 2.40\");\n  pcVar1 \u003d (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n  printf(pcVar1);\n  pcVar1 \u003d (char *)dcgettext(0,\n                             \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                             ,5);\n  printf(pcVar1);\n                    \n  exit(0);\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "printf",
        "dcgettext",
        "exit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "display_info.isra.0": {
      "entrypoint": "0x001199d0",
      "current_name": "display_info.isra.0",
      "code": "\n\n\nvoid display_info_isra_0(void)\n\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  char *pcVar4;\n  size_t sVar5;\n  char *pcVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  int iVar9;\n  long lVar10;\n  long lVar11;\n  char **ppcVar12;\n  uint uVar13;\n  ulong uVar14;\n  int local_70;\n  \n  pcVar4 \u003d (char *)dcgettext(0,\"BFD header file version %s\\n\",5);\n  printf(pcVar4,\"(GNU Binutils for Debian) 2.40\");\n  if (memoized_tmpdir \u003d\u003d (char *)0x0) {\n    pcVar4 \u003d getenv(\"TMPDIR\");\n    uVar7 \u003d try_dir_lto_priv_0(pcVar4,0);\n    pcVar4 \u003d getenv(\"TMP\");\n    uVar7 \u003d try_dir_lto_priv_0(pcVar4,uVar7);\n    pcVar4 \u003d getenv(\"TEMP\");\n    uVar7 \u003d try_dir_lto_priv_0(pcVar4,uVar7);\n    uVar7 \u003d try_dir_lto_priv_0(\u0026DAT_0011b39a,uVar7);\n    uVar7 \u003d try_dir_lto_priv_0(vartmp,uVar7);\n    pcVar4 \u003d (char *)try_dir_lto_priv_0(\u0026tmp,uVar7);\n    if (pcVar4 \u003d\u003d (char *)0x0) {\n      pcVar4 \u003d \".\";\n    }\n    sVar5 \u003d strlen(pcVar4);\n    pcVar6 \u003d (char *)xmalloc((int)sVar5 + 2);\n    memoized_tmpdir \u003d strcpy(pcVar6,pcVar4);\n    memoized_tmpdir[sVar5 \u0026 0xffffffff] \u003d \u0027/\u0027;\n    memoized_tmpdir[(int)sVar5 + 1] \u003d \u0027\\0\u0027;\n  }\n  pcVar4 \u003d memoized_tmpdir;\n  sVar5 \u003d strlen(memoized_tmpdir);\n  lVar10 \u003d (long)(int)sVar5;\n  pcVar6 \u003d (char *)xmalloc(lVar10 + 9);\n  strcpy(pcVar6,pcVar4);\n  *(undefined2 *)(pcVar6 + lVar10) \u003d 0x6363;\n  *(undefined4 *)(pcVar6 + lVar10 + 2) \u003d 0x58585858;\n  *(undefined4 *)((long)(pcVar6 + lVar10 + 2) + 3) \u003d 0x585858;\n  pcVar6[lVar10 + 8] \u003d \u0027\\0\u0027;\n  iVar2 \u003d mkstemps(pcVar6,0);\n  if (iVar2 \u003d\u003d -1) {\n    piVar8 \u003d __errno_location();\n    pcVar6 \u003d strerror(*piVar8);\n    fprintf(_stderr,\"Cannot create temporary file in %s: %s\\n\",pcVar4,pcVar6);\n                    \n    abort();\n  }\n  iVar2 \u003d close(iVar2);\n  if (iVar2 !\u003d 0) {\n                    \n    abort();\n  }\n  uVar13 \u003d 0;\n  iVar2 \u003d 2;\n  bfd_iterate_over_targets(do_display_target);\n  unlink(pcVar6);\n  free(pcVar6);\n  local_70 \u003d 0;\n  do {\n    pcVar4 \u003d (char *)bfd_printable_arch_mach(iVar2);\n    sVar5 \u003d strlen(pcVar4);\n    if ((int)uVar13 \u003c (int)(uint)sVar5) {\n      uVar13 \u003d (uint)sVar5;\n    }\n    iVar2 \u003d iVar2 + 1;\n  } while (iVar2 !\u003d 0x57);\n  pcVar4 \u003d getenv(\"COLUMNS\");\n  iVar2 \u003d local_70;\n  if (pcVar4 !\u003d (char *)0x0) {\n    lVar10 \u003d strtol(pcVar4,(char **)0x0,10);\n    iVar1 \u003d (int)lVar10;\n    if (iVar1 !\u003d 0) goto LAB_00119b11;\n  }\n  iVar1 \u003d 0x50;\nLAB_00119b11:\n  do {\n    local_70 \u003d iVar2;\n    if (-1 \u003c local_70) {\n      return;\n    }\n    lVar11 \u003d (long)local_70;\n    iVar9 \u003d (iVar1 - uVar13) + -1;\n    lVar10 \u003d lVar11;\n    do {\n      iVar2 \u003d (int)lVar10;\n      if (-1 \u003c iVar2) break;\n      sVar5 \u003d strlen(*(char **)(lVar10 * 0x60));\n      lVar10 \u003d lVar10 + 1;\n      iVar9 \u003d (iVar9 - (int)sVar5) + -1;\n    } while (-1 \u003c iVar9);\n    printf(\"\\n%*s\",(ulong)(uVar13 + 1),\u0026DAT_0011b4a1);\n    for (ppcVar12 \u003d (char **)(lVar11 * 0x60);\n        ((ulong)(uint)(iVar2 - local_70) + lVar11) * 0x60 - (long)ppcVar12 !\u003d 0;\n        ppcVar12 \u003d ppcVar12 + 0xc) {\n      printf(\"%s \",*ppcVar12);\n    }\n    iVar9 \u003d 2;\n    putc(10,_stdout);\n    do {\n      pcVar4 \u003d (char *)bfd_printable_arch_mach(iVar9,0);\n      iVar3 \u003d strcmp(pcVar4,\"UNKNOWN!\");\n      if (iVar3 !\u003d 0) {\n        uVar7 \u003d bfd_printable_arch_mach(iVar9,0);\n        printf(\"%*s \",(ulong)uVar13,uVar7);\n        ppcVar12 \u003d (char **)(lVar11 * 0x60);\n        iVar3 \u003d local_70;\n        while (iVar2 !\u003d iVar3) {\n          if (*(char *)((long)ppcVar12 + (ulong)(iVar9 - 2) + 8) \u003d\u003d \u0027\\0\u0027) {\n            sVar5 \u003d strlen(*ppcVar12);\n            for (uVar14 \u003d sVar5 \u0026 0xffffffff; (int)uVar14 !\u003d 0; uVar14 \u003d (ulong)((int)uVar14 - 1)) {\n              putc(0x2d,_stdout);\n            }\n          }\n          else {\n            fputs(*ppcVar12,_stdout);\n          }\n          iVar3 \u003d iVar3 + 1;\n          if (iVar2 !\u003d iVar3) {\n            putc(0x20,_stdout);\n          }\n          ppcVar12 \u003d ppcVar12 + 0xc;\n        }\n        putc(10,_stdout);\n      }\n      iVar9 \u003d iVar9 + 1;\n    } while (iVar9 !\u003d 0x57);\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "free",
        "unlink",
        "printf",
        "strlen",
        "strerror",
        "do_display_target",
        "__errno_location",
        "abort",
        "bfd_printable_arch_mach",
        "strcpy",
        "getenv",
        "bfd_iterate_over_targets",
        "fprintf",
        "dcgettext",
        "display_info.isra.0.cold",
        "try_dir.lto_priv.0",
        "mkstemps",
        "close",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fatal": {
      "entrypoint": "0x00119dd0",
      "current_name": "fatal",
      "code": "\nvoid fatal(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n          undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n          undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n          undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL !\u003d \u0027\\0\u0027) {\n    local_88 \u003d param_1;\n    local_78 \u003d param_2;\n    local_68 \u003d param_3;\n    local_58 \u003d param_4;\n    local_48 \u003d param_5;\n    local_38 \u003d param_6;\n    local_28 \u003d param_7;\n    local_18 \u003d param_8;\n  }\n  local_d0 \u003d \u0026stack0x00000008;\n  local_d8 \u003d 8;\n  local_c8 \u003d local_b8;\n  local_d4 \u003d 0x30;\n  local_b0 \u003d param_10;\n  local_a8 \u003d param_11;\n  local_a0 \u003d param_12;\n  local_98 \u003d param_13;\n  local_90 \u003d param_14;\n  report(param_9,\u0026local_d8);\n                    \n  xexit(1);\n}\n\n",
      "renaming": {},
      "calling": [
        "parse_flags.cold",
        "section_add_load_file.cold",
        "create_new_symbol.cold",
        "is_strip_section_1.isra.0",
        "main",
        "find_section_list",
        "coff_get_slot.lto_priv.0",
        "FUN_00114dc7",
        "add_redefine_and_check",
        "init_section_add.cold",
        "FUN_0010554f",
        "copy_section.cold",
        "parse_vma.cold",
        "copy_file",
        "is_strip_section_1.isra.0.cold",
        "add_specific_symbols"
      ],
      "called": [
        "report",
        "xexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "report": {
      "entrypoint": "0x00119e70",
      "current_name": "report",
      "code": "\n\n\nvoid report(char *param_1,__gnuc_va_list param_2)\n\n{\n  fflush(_stdout);\n  fprintf(_stderr,\"%s: \",program_name);\n  vfprintf(_stderr,param_1,param_2);\n  putc(10,_stderr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "non_fatal",
        "fatal"
      ],
      "called": [
        "fprintf",
        "fflush",
        "vfprintf",
        "putc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "non_fatal": {
      "entrypoint": "0x00119ed0",
      "current_name": "non_fatal",
      "code": "\nvoid non_fatal(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n              undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n              undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n              undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL !\u003d \u0027\\0\u0027) {\n    local_88 \u003d param_1;\n    local_78 \u003d param_2;\n    local_68 \u003d param_3;\n    local_58 \u003d param_4;\n    local_48 \u003d param_5;\n    local_38 \u003d param_6;\n    local_28 \u003d param_7;\n    local_18 \u003d param_8;\n  }\n  local_d0 \u003d \u0026stack0x00000008;\n  local_d8 \u003d 8;\n  local_c8 \u003d local_b8;\n  local_d4 \u003d 0x30;\n  local_b0 \u003d param_10;\n  local_a8 \u003d param_11;\n  local_a0 \u003d param_12;\n  local_98 \u003d param_13;\n  local_90 \u003d param_14;\n  report(param_9,\u0026local_d8);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "stab_int_type.lto_priv.0",
        "stab_struct_field.lto_priv.0",
        "stab_typdef.lto_priv.0",
        "FUN_00107880",
        "parse_flags.cold",
        "FUN_001086af",
        "check_new_section_flags.cold",
        "get_file_size",
        "smart_rename.cold",
        "FUN_00104cc1",
        "set_times.cold",
        "stab_write_symbol.lto_priv.0",
        "main",
        "get_file_size.cold",
        "parse_coff_type.lto_priv.0",
        "write_stabs_in_sections_debugging_info.constprop.0",
        "FUN_00104ea2",
        "FUN_00105828",
        "parse_coff_struct_type",
        "FUN_0010554f",
        "merge_gnu_build_notes",
        "copy_file",
        "copy_object",
        "FUN_001152b6"
      ],
      "called": [
        "report"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "do_display_target": {
      "entrypoint": "0x00119f70",
      "current_name": "do_display_target",
      "code": "\nundefined4 do_display_target(undefined8 *param_1,undefined8 *param_2)\n\n{\n  undefined4 uVar1;\n  char cVar2;\n  int iVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  char *__format;\n  long lVar6;\n  undefined8 uVar7;\n  long lVar8;\n  \n  iVar3 \u003d *(int *)((long)param_2 + 0xc) + 1;\n  *(int *)((long)param_2 + 0xc) \u003d iVar3;\n  if ((ulong)param_2[2] \u003c (ulong)((long)iVar3 * 0x60)) {\n    lVar6 \u003d 0x3000;\n    if (0x3f \u003c iVar3) {\n      lVar6 \u003d (long)iVar3 * 0xc0;\n    }\n    lVar8 \u003d xrealloc(param_2[3]);\n    param_2[3] \u003d lVar8;\n    memset((void *)(lVar8 + param_2[2]),0,lVar6 - param_2[2]);\n    param_2[2] \u003d lVar6;\n  }\n  uVar1 \u003d *(undefined4 *)((long)param_1 + 0xc);\n  *(undefined8 *)((long)*(int *)((long)param_2 + 0xc) * 0x60 + param_2[3] + -0x60) \u003d *param_1;\n  uVar4 \u003d endian_string(uVar1);\n  uVar5 \u003d endian_string(*(undefined4 *)(param_1 + 2));\n  uVar7 \u003d *param_1;\n  __format \u003d (char *)dcgettext(0,\"%s\\n (header %s, data %s)\\n\",5);\n  printf(__format,uVar7,uVar5,uVar4);\n  lVar6 \u003d bfd_openw(*param_2,*param_1);\n  if (lVar6 \u003d\u003d 0) {\n    bfd_nonfatal(*param_2);\n    *(undefined4 *)(param_2 + 1) \u003d 1;\n  }\n  else {\n    iVar3 \u003d 2;\n    cVar2 \u003d bfd_set_format(lVar6,1);\n    if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n      iVar3 \u003d bfd_get_error();\n      if (iVar3 !\u003d 5) {\n        bfd_nonfatal(*param_1);\n        *(undefined4 *)(param_2 + 1) \u003d 1;\n      }\n    }\n    else {\n      do {\n        cVar2 \u003d (**(code **)(*(long *)(lVar6 + 8) + 0x2a0))(lVar6,iVar3,0);\n        if (cVar2 !\u003d \u0027\\0\u0027) {\n          uVar7 \u003d bfd_printable_arch_mach(iVar3,0);\n          printf(\"  %s\\n\",uVar7);\n          *(undefined *)\n           ((long)*(int *)((long)param_2 + 0xc) * 0x60 + param_2[3] + -0x58 + (ulong)(iVar3 - 2)) \u003d\n               1;\n        }\n        iVar3 \u003d iVar3 + 1;\n      } while (iVar3 !\u003d 0x57);\n    }\n    bfd_close_all_done(lVar6);\n  }\n  return *(undefined4 *)(param_2 + 1);\n}\n\n",
      "renaming": {},
      "calling": [
        "display_info.isra.0"
      ],
      "called": [
        "bfd_openw",
        "memset",
        "printf",
        "dcgettext",
        "xrealloc",
        "endian_string",
        "bfd_close_all_done",
        "bfd_set_format",
        "bfd_nonfatal",
        "bfd_get_error",
        "bfd_printable_arch_mach",
        "do_display_target.cold"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "make_tempdir": {
      "entrypoint": "0x0011a0e0",
      "current_name": "make_tempdir",
      "code": "\nchar * make_tempdir(void)\n\n{\n  char *__template;\n  char *pcVar1;\n  \n  __template \u003d (char *)template_in_dir();\n  pcVar1 \u003d mkdtemp(__template);\n  if (pcVar1 \u003d\u003d (char *)0x0) {\n    free(__template);\n  }\n  return pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_file",
        "FUN_00104ea2"
      ],
      "called": [
        "make_tempdir.cold",
        "template_in_dir",
        "mkdtemp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_nonfatal": {
      "entrypoint": "0x0011a110",
      "current_name": "bfd_nonfatal",
      "code": "\n\n\nvoid bfd_nonfatal(long param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 in_R10;\n  \n  iVar1 \u003d bfd_get_error();\n  if (iVar1 \u003d\u003d 0) {\n    uVar2 \u003d dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    uVar2 \u003d bfd_errmsg(iVar1);\n  }\n  fflush(_stdout);\n  if (param_1 !\u003d 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",program_name,param_1,uVar2,in_R10);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",program_name,uVar2,in_R10);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy_relocations_in_section",
        "do_display_target",
        "do_display_target.cold",
        "mark_symbols_used_in_relocations",
        "mark_symbols_used_in_relocations.cold",
        "FUN_00104ea2"
      ],
      "called": [
        "bfd_nonfatal.cold",
        "bfd_errmsg",
        "bfd_get_error"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "is_specified_symbol_predicate": {
      "entrypoint": "0x0011a170",
      "current_name": "is_specified_symbol_predicate",
      "code": "\nint is_specified_symbol_predicate(char **param_1,char **param_2)\n\n{\n  char *__pattern;\n  int iVar1;\n  \n  __pattern \u003d *param_1;\n  if (*__pattern \u003d\u003d \u0027!\u0027) {\n    iVar1 \u003d fnmatch(__pattern + 1,*param_2,0);\n    if (iVar1 \u003d\u003d 0) {\n      *(undefined *)(param_2 + 1) \u003d 0;\n      return iVar1;\n    }\n  }\n  else {\n    iVar1 \u003d fnmatch(__pattern,*param_2,0);\n    if (iVar1 \u003d\u003d 0) {\n      *(undefined *)(param_2 + 1) \u003d 1;\n    }\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "is_specified_symbol",
        "FUN_0010554f"
      ],
      "called": [
        "fnmatch"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "compare_gnu_build_notes": {
      "entrypoint": "0x0011a1b0",
      "current_name": "compare_gnu_build_notes",
      "code": "\nundefined  [16]\ncompare_gnu_build_notes(ulong *param_1,ulong *param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  ulong uVar1;\n  ulong uVar2;\n  int iVar3;\n  undefined4 extraout_var;\n  ulong uVar4;\n  undefined auVar5 [16];\n  \n  uVar4 \u003d *param_1;\n  if (*param_2 \u003c\u003d *param_1) {\n    uVar4 \u003d *param_2;\n  }\n  iVar3 \u003d memcmp((void *)(param_1[3] + 3),(void *)(param_2[3] + 3),uVar4 - 3);\n  uVar4 \u003d CONCAT44(extraout_var,iVar3);\n  if (iVar3 \u003d\u003d 0) {\n    uVar1 \u003d param_1[8];\n    if (uVar1 \u003c param_2[7]) {\n      uVar4 \u003d 0xffffffff;\n    }\n    else {\n      uVar2 \u003d param_2[8];\n      if (uVar2 \u003c param_1[7]) {\n        uVar4 \u003d 1;\n      }\n      else {\n        uVar4 \u003d 0xffffffff;\n        if (param_2[7] \u003c\u003d param_1[7]) {\n          if (uVar2 \u003c uVar1) {\n            uVar4 \u003d 1;\n          }\n          else {\n            uVar4 \u003d 0xffffffff;\n            if (uVar2 \u003c\u003d uVar1) {\n              if (param_1[2] \u003d\u003d 0x100) {\n                uVar4 \u003d (ulong)-(uint)(param_2[2] !\u003d 0x100);\n              }\n              else {\n                uVar4 \u003d (ulong)(param_2[2] \u003d\u003d 0x100);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  auVar5._8_8_ \u003d param_4;\n  auVar5._0_8_ \u003d uVar4;\n  return auVar5;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001086af"
      ],
      "called": [
        "memcmp",
        "compare_gnu_build_notes.cold"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sort_gnu_build_notes": {
      "entrypoint": "0x0011a250",
      "current_name": "sort_gnu_build_notes",
      "code": "\nint sort_gnu_build_notes(ulong *param_1,ulong *param_2)\n\n{\n  ulong uVar1;\n  \n  uVar1 \u003d param_1[2];\n  if (uVar1 \u003d\u003d param_2[2]) {\n    if (param_2[7] \u003c\u003d param_1[7]) {\n      if (param_1[7] \u003c\u003d param_2[7]) {\n        if (param_2[8] \u003c param_1[8]) {\n          return -1;\n        }\n        if (param_2[8] \u003c\u003d param_1[8]) {\n          if ((4 \u003c *param_1) \u0026\u0026 (4 \u003c *param_2)) {\n            if (*(char *)(param_1[3] + 3) !\u003d *(char *)(param_2[3] + 3)) {\n              return (int)*(char *)(param_1[3] + 3) - (int)*(char *)(param_2[3] + 3);\n            }\n          }\n          return 0;\n        }\n      }\n      return 1;\n    }\n  }\n  else if ((uVar1 \u003d\u003d 0) || ((uVar1 !\u003d 0x100 \u0026\u0026 (param_2[2] !\u003d 0)))) {\n    return 1;\n  }\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00116852"
      ],
      "called": [
        "sort_gnu_build_notes.cold"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "create_new_symbol": {
      "entrypoint": "0x0011a2e0",
      "current_name": "create_new_symbol",
      "code": "\nlong create_new_symbol(long param_1,long param_2)\n\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  long lVar3;\n  long lVar4;\n  \n  lVar3 \u003d (**(code **)(*(long *)(param_2 + 8) + 0x208))(param_2);\n  lVar4 \u003d *(long *)(param_1 + 0x20);\n  *(undefined8 *)(lVar3 + 8) \u003d *(undefined8 *)(param_1 + 8);\n  *(undefined8 *)(lVar3 + 0x10) \u003d *(undefined8 *)(param_1 + 0x10);\n  *(undefined4 *)(lVar3 + 0x18) \u003d *(undefined4 *)(param_1 + 0x18);\n  if (lVar4 \u003d\u003d 0) {\n    lVar4 \u003d 0x128598;\n  }\n  else {\n    lVar4 \u003d bfd_get_section_by_name(param_2);\n    if (lVar4 \u003d\u003d 0) {\n      uVar1 \u003d *(undefined8 *)(param_1 + 0x20);\n      uVar2 \u003d dcgettext(0,\"Section %s not found\",5);\n                    \n      fatal(uVar2,uVar1);\n    }\n  }\n  *(long *)(lVar3 + 0x20) \u003d lVar4;\n  return lVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010554f"
      ],
      "called": [
        "create_new_symbol.cold",
        "bfd_get_section_by_name"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "set_times": {
      "entrypoint": "0x0011a350",
      "current_name": "set_times",
      "code": "\nvoid set_times(char *param_1,long param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  undefined4 local_38;\n  undefined4 uStack_34;\n  undefined4 uStack_30;\n  undefined4 uStack_2c;\n  undefined4 local_28;\n  undefined4 uStack_24;\n  undefined4 uStack_20;\n  undefined4 uStack_1c;\n  \n  local_28 \u003d *(undefined4 *)(param_2 + 0x58);\n  uStack_24 \u003d *(undefined4 *)(param_2 + 0x5c);\n  uStack_20 \u003d *(undefined4 *)(param_2 + 0x60);\n  uStack_1c \u003d *(undefined4 *)(param_2 + 100);\n  local_38 \u003d *(undefined4 *)(param_2 + 0x48);\n  uStack_34 \u003d *(undefined4 *)(param_2 + 0x4c);\n  uStack_30 \u003d *(undefined4 *)(param_2 + 0x50);\n  uStack_2c \u003d *(undefined4 *)(param_2 + 0x54);\n  iVar1 \u003d utimensat(-100,param_1,(timespec *)\u0026local_38,0);\n  if (iVar1 !\u003d 0) {\n    piVar2 \u003d __errno_location();\n    pcVar3 \u003d strerror(*piVar2);\n    uVar4 \u003d dcgettext(0,\"%s: cannot set time: %s\",5);\n    non_fatal(uVar4,param_1,pcVar3);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "smart_rename.cold",
        "FUN_00104ea2"
      ],
      "called": [
        "set_times.cold",
        "utimensat"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xatexit_cleanup.lto_priv.0": {
      "entrypoint": "0x0011a390",
      "current_name": "xatexit_cleanup.lto_priv.0",
      "code": "\nvoid xatexit_cleanup_lto_priv_0(void)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  long *plVar4;\n  uint uVar5;\n  \n  plVar4 \u003d (long *)xatexit_head_lto_priv_0;\n  if (xatexit_head_lto_priv_0 !\u003d (undefined *)0x0) {\n    do {\n      uVar5 \u003d *(int *)(plVar4 + 1) - 1;\n      if (-1 \u003c (int)uVar5) {\n        lVar1 \u003d (long)(int)uVar5;\n        uVar5 \u003d uVar5 \u0026 7;\n        (*(code *)plVar4[lVar1 + 2])();\n        lVar2 \u003d lVar1 + -1;\n        if (-1 \u003c (int)lVar2) {\n          lVar3 \u003d lVar2;\n          if (uVar5 !\u003d 0) {\n            if (uVar5 !\u003d 1) {\n              if (uVar5 !\u003d 2) {\n                if (uVar5 !\u003d 3) {\n                  if (uVar5 !\u003d 4) {\n                    if (uVar5 !\u003d 5) {\n                      if (uVar5 !\u003d 6) {\n                        (*(code *)plVar4[lVar1 + 1])();\n                        lVar2 \u003d lVar1 + -2;\n                      }\n                      (*(code *)plVar4[lVar2 + 2])();\n                      lVar2 \u003d lVar2 + -1;\n                    }\n                    (*(code *)plVar4[lVar2 + 2])();\n                    lVar2 \u003d lVar2 + -1;\n                  }\n                  (*(code *)plVar4[lVar2 + 2])();\n                  lVar2 \u003d lVar2 + -1;\n                }\n                (*(code *)plVar4[lVar2 + 2])();\n                lVar2 \u003d lVar2 + -1;\n              }\n              (*(code *)plVar4[lVar2 + 2])();\n              lVar2 \u003d lVar2 + -1;\n            }\n            (*(code *)plVar4[lVar2 + 2])();\n            lVar3 \u003d lVar2 + -1;\n            if ((int)(lVar2 + -1) \u003c 0) goto LAB_0011a466;\n          }\n          do {\n            (*(code *)plVar4[lVar3 + 2])();\n            lVar1 \u003d lVar3 + -1;\n            (*(code *)plVar4[lVar3 + 1])();\n            (*(code *)plVar4[lVar3])();\n            (*(code *)plVar4[lVar1])();\n            (*(code *)plVar4[lVar3 + -2])();\n            (*(code *)plVar4[lVar3 + -3])();\n            (*(code *)plVar4[lVar3 + -4])();\n            (*(code *)plVar4[lVar3 + -5])();\n            lVar3 \u003d lVar3 + -8;\n          } while (-1 \u003c (int)lVar1 + -7);\n        }\n      }\nLAB_0011a466:\n      plVar4 \u003d (long *)*plVar4;\n    } while (plVar4 !\u003d (long *)0x0);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xstrndup": {
      "entrypoint": "0x0011a480",
      "current_name": "xstrndup",
      "code": "\nvoid xstrndup(char *param_1,size_t param_2)\n\n{\n  size_t __n;\n  void *__dest;\n  \n  __n \u003d strnlen(param_1,param_2);\n  __dest \u003d (void *)xmalloc(__n + 1);\n  *(undefined *)((long)__dest + __n) \u003d 0;\n  memcpy(__dest,param_1,__n);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "init_section_add",
        "main"
      ],
      "called": [
        "memcpy",
        "strnlen",
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fini": {
      "entrypoint": "0x0011a4b4",
      "current_name": "_fini",
      "code": "\nvoid _fini(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__libc_start_main": {
      "entrypoint": "0x00128040",
      "current_name": "__libc_start_main",
      "code": "\n\n\nvoid __libc_start_main(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __libc_start_main@GLIBC_2.34 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "_start"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    }
  },
  "layers": [],
  "locked_functions": [],
  "used_tokens": 0
}