{
    "functions": {
        "putc": {
            "renaming": {},
            "code": "\n\n\nint putc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = putc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102250",
            "calling": [
                "FUN_001063a0",
                "FUN_00103463"
            ],
            "imported": false,
            "current_name": "putc"
        },
        "bfd_close": {
            "renaming": {},
            "code": "\nvoid bfd_close(void)\n\n{\n  bfd_close();\n  return;\n}\n\n",
            "called": [
                "bfd_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102360",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "bfd_close"
        },
        "_FINI_0": {
            "renaming": {},
            "code": "\nvoid _FINI_0(void)\n\n{\n  if (DAT_0010b720 != '\\0') {\n    return;\n  }\n  __cxa_finalize(PTR_LOOP_0010b228);\n  FUNC_00105530();\n  DAT_0010b720 = 1;\n  return;\n}\n\n",
            "called": [
                "FUN_00105530",
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001055a0",
            "calling": [],
            "imported": false,
            "current_name": "_FINI_0"
        },
        "strchr": {
            "renaming": {},
            "code": "\n\n\nchar * strchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strchr(__s,__c);\n  return pcVar1;\n}\n\n",
            "called": [
                "strchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102180",
            "calling": [
                "FUN_00102739"
            ],
            "imported": false,
            "current_name": "strchr"
        },
        "FUN_00103c00": {
            "renaming": {
                "FUN_00103c00": "process_relocation_entries_00103c00",
                "param_1": "input_buffer",
                "param_2": "buffer_length",
                "param_3": "relocation_table",
                "puVar1": "reloc_entry_ptr",
                "auVar2": "reloc_data",
                "lVar3": "upper_bound",
                "uVar4": "malloced_buffer",
                "uVar5": "canonicalized_reloc"
            },
            "code": "\nundefined8\nprocess_relocation_entries_00103c00(undefined8 *input_buffer,long buffer_length,undefined (*relocation_table) [16],undefined8 param_4,\n            undefined8 param_5)\n\n{\n  undefined8 *reloc_entry_ptr;\n  undefined reloc_data [16];\n  long upper_bound;\n  undefined8 malloced_buffer;\n  undefined8 canonicalized_reloc;\n  \n  **(long **)*relocation_table = buffer_length;\n  if ((*(byte *)(buffer_length + 0x24) & 4) == 0) {\n    **(undefined8 **)(*relocation_table + 8) = 0;\n    **(undefined8 **)relocation_table[1] = 0;\n  }\n  else {\n    upper_bound = bfd_get_reloc_upper_bound();\n    if (-1 < upper_bound) {\n      reloc_entry_ptr = *(undefined8 **)(*relocation_table + 8);\n      malloced_buffer = xmalloc(upper_bound);\n      canonicalized_reloc = *(undefined8 *)(relocation_table[1] + 8);\n      *reloc_entry_ptr = malloced_buffer;\n      reloc_entry_ptr = *(undefined8 **)relocation_table[1];\n      canonicalized_reloc = bfd_canonicalize_reloc(input_buffer,buffer_length,**(undefined8 **)(*relocation_table + 8),canonicalized_reloc);\n      *reloc_entry_ptr = canonicalized_reloc;\n      if (-1 < **(long **)relocation_table[1]) goto LAB_00103c7c;\n    }\n    FUN_00106530(*input_buffer);\n  }\nLAB_00103c7c:\n  upper_bound = *(long *)(*relocation_table + 8) + 8;\n  *(long *)relocation_table[1] = *(long *)relocation_table[1] + 8;\n  reloc_data._8_4_ = (int)upper_bound;\n  reloc_data._0_8_ = *(long *)*relocation_table + 8;\n  reloc_data._12_4_ = (int)((ulong)upper_bound >> 0x20);\n  *relocation_table = reloc_data;\n  return param_5;\n}\n\n",
            "called": [
                "bfd_get_reloc_upper_bound",
                "xmalloc",
                "bfd_canonicalize_reloc",
                "FUN_00106530"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103c00",
            "calling": [
                "FUN_00103238"
            ],
            "imported": false,
            "current_name": "process_relocation_entries_00103c00"
        },
        "fseek": {
            "renaming": {},
            "code": "\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 = fseek(__stream,__off,__whence);\n  return iVar1;\n}\n\n",
            "called": [
                "fseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022d0",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "fseek"
        },
        "FUN_0010370a": {
            "renaming": {
                "FUN_0010370a": "print_symbol_information_0010370a",
                "cVar1": "isUndefinedSymClass",
                "uVar2": "typeCode",
                "iVar3": "asprintfRetVal",
                "plVar4": "printWidth",
                "piVar5": "errnoLocation",
                "uVar6": "errorMsg",
                "lVar7": "dataTypePtr",
                "unaff_RBX": "rbx",
                "bVar8": "dataType",
                "uVar9": "maskedRbx",
                "pcVar10": "dataTypeString"
            },
            "code": "\nvoid printSymbolInformation_0010370a(void)\n\n{\n  char isUndefinedSymClass;\n  ushort typeCode;\n  int asprintfRetVal;\n  long *printWidth;\n  int *errnoLocation;\n  undefined8 errorMsg;\n  long dataTypePtr;\n  ulong rbx;\n  byte dataType;\n  ulong maskedRbx;\n  char *dataTypeString;\n  \n  printWidth = (long *)dcgettext(0,\"Print width has not been initialized (%d)\",5);\n  maskedRbx = rbx & 0xffffffff;\n  FUN_00106300(printWidth,maskedRbx);\n  FUN_00104740(\"%-20s|\",printWidth,0,maskedRbx);\n  isUndefinedSymClass = bfd_is_undefined_symclass((int)*(char *)(*printWidth + 8));\n  if (isUndefinedSymClass == '\\0') {\n    FUN_001054d0(*(undefined8 *)*printWidth);\n  }\n  else if (DAT_0010b7a8 == 0x20) {\n    printf(\"        \");\n  }\n  else {\n    printf(\"                \");\n  }\n  printf(\"|   %c  |\",(ulong)(uint)(int)*(char *)(*printWidth + 8));\n  if (*(char *)(*printWidth + 8) == '-') {\n    printf(\"%18s|  \",*(undefined8 *)(*printWidth + 0x20));\n    printf(&DAT_0010b23d,(ulong)(uint)(int)*(short *)(*printWidth + 0x1a));\n    goto LAB_00103a54;\n  }\n  if (printWidth[2] == 0) {\n    if (printWidth[3] != 0) {\n      dataTypePtr = *(long *)(printWidth[3] + 0x30);\n      isUndefinedSymClass = *(char *)(dataTypePtr + 0x28);\n      if (isUndefinedSymClass == 'g') goto LAB_00103983;\n      if (isUndefinedSymClass == 'h') {\n        dataTypeString = \"Line\";\n      }\n      else if (isUndefinedSymClass == 'd') {\n        dataTypeString = \"Block\";\n      }\n      else if (*(ushort *)(dataTypePtr + 0x26) == 0) {\n        dataTypeString = \"None\";\n      }\n      else {\n        typeCode = *(ushort *)(dataTypePtr + 0x26) >> 4 & 3;\n        if (typeCode == 2) {\n          dataTypeString = \"Function\";\n        }\n        else if (typeCode == 3) {\n          dataTypeString = \"Array\";\n        }\n        else {\n          if (typeCode != 1) {\n            free(DAT_0010b730);\n            typeCode = *(ushort *)(dataTypePtr + 0x26);\n            dataType = *(byte *)(dataTypePtr + 0x28);\n            dataTypeString = (char *)dcgettext(0,\"<unknown>: %d/%d\",5);\n            asprintfRetVal = asprintf(&DAT_0010b730,dataTypeString,(ulong)dataType,(ulong)typeCode);\n            dataTypeString = DAT_0010b730;\n            goto joined_r0x00103964;\n          }\n          dataTypeString = \"Pointer\";\n        }\n      }\n      goto LAB_001039c0;\n    }\n    printf(\"                  |\");\n  }\n  else {\n    dataType = *(byte *)(printWidth[2] + 0x48) & 0xf;\n    switch(dataType) {\n    case 0:\n      dataTypeString = \"NOTYPE\";\n      break;\n    case 1:\n      dataTypeString = \"OBJECT\";\n      break;\n    case 2:\n      dataTypeString = \"FUNC\";\n      break;\n    case 3:\n      dataTypeString = \"SECTION\";\n      break;\n    case 4:\n      dataTypeString = \"FILE\";\n      break;\n    case 5:\n      dataTypeString = \"COMMON\";\n      break;\n    case 6:\n      dataTypeString = \"TLS\";\n      break;\n    default:\n      free(DAT_0010b728);\n      dataTypeString = \"<processor specific>: %d\";\n      if ((2 < dataType - 0xd) && (dataTypeString = \"<OS specific>: %d\", 2 < dataType - 10)) {\n        dataTypeString = \"<unknown>: %d\";\n      }\n      dataTypeString = (char *)dcgettext(0,dataTypeString,5);\n      asprintfRetVal = asprintf(&DAT_0010b728,dataTypeString,(ulong)dataType);\n      dataTypeString = DAT_0010b728;\njoined_r0x00103964:\n      if (asprintfRetVal < 0) {\n        errnoLocation = __errno_location();\n        errorMsg = xstrerror(*errnoLocation);\n        FUN_00106300(&DAT_0010712d,errorMsg);\nLAB_00103983:\n        dataTypeString = \"File\";\n      }\n    }\nLAB_001039c0:\n    printf(\"%18s|\",dataTypeString);\n  }\n  if (printWidth[2] == 0) {\n    if (printWidth[1] != 0) goto LAB_001039fb;\nLAB_00103a02:\n    if (DAT_0010b7a8 == 0x20) {\n      printf(\"        \");\n    }\n    else {\n      printf(\"                \");\n    }\n  }\n  else {\n    if (*(long *)(printWidth[2] + 0x38) == 0) goto LAB_00103a02;\nLAB_001039fb:\n    FUN_001054d0();\n  }\n  dataTypePtr = printWidth[2];\n  if ((dataTypePtr != 0) || (dataTypePtr = printWidth[3], dataTypePtr != 0)) {\n    printf(\"|     |%s\",**(undefined8 **)(dataTypePtr + 0x20));\n    return;\n  }\nLAB_00103a54:\n  printf(\"|     |\");\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00106300"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010370a",
            "calling": [
                "FUN_001054d0"
            ],
            "imported": false,
            "current_name": "print_symbol_information_0010370a"
        },
        "FUN_00104370": {
            "renaming": {
                "FUN_00104370": "determine_output_format_00104370",
                "param_1": "inputFormat",
                "uVar1": "errorMessage",
                "ppuVar2": "result"
            },
            "code": "\nundefined ** determineOutputFormat_00104370(undefined *inputFormat,undefined8 param_2)\n\n{\n  undefined8 errorMessage;\n  undefined **result;\n  \n  switch(*inputFormat) {\n  case 0x42:\n  case 0x62:\n    DAT_0010b7c0 = 0;\n    PTR_PTR_FUN_0010b260 = (undefined *)&PTR_FUN_0010ace0;\n    return &PTR_FUN_0010ace0;\n  default:\n    errorMessage = dcgettext(0,\"%s: invalid output format\",5);\n    FUN_00106300(errorMessage,inputFormat);\n    errorMessage = dcgettext(0,\"Warning: \\'%s\\' is not an ordinary file\",5);\n    FUN_00106400(errorMessage);\n    return (undefined **)0x0;\n  case 0x4a:\n  case 0x6a:\n    result = (undefined **)FUN_00104397(inputFormat,param_2,3);\n    return result;\n  case 0x50:\n  case 0x70:\n    result = (undefined **)FUN_00104397(inputFormat,param_2,2);\n    return result;\n  case 0x53:\n  case 0x73:\n    result = (undefined **)FUN_00104397(inputFormat,param_2,1);\n    return result;\n  }\n}\n\n",
            "called": [
                "FUN_00104397",
                "dcgettext",
                "caseD_4a",
                "FUN_00106300"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104370",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "determine_output_format_00104370"
        },
        "xmalloc": {
            "renaming": {},
            "code": "\nvoid xmalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021e0",
            "calling": [
                "FUN_001055f0",
                "FUN_0010268b",
                "FUN_00103c00",
                "FUN_00104d5b",
                "FUN_00103238",
                "FUN_00105110"
            ],
            "imported": false,
            "current_name": "xmalloc"
        },
        "vfprintf": {
            "renaming": {},
            "code": "\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n  int iVar1;\n  \n  iVar1 = vfprintf(__s,__format,__arg);\n  return iVar1;\n}\n\n",
            "called": [
                "vfprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102370",
            "calling": [
                "FUN_001063a0"
            ],
            "imported": false,
            "current_name": "vfprintf"
        },
        "putchar": {
            "renaming": {},
            "code": "\n\n\nint putchar(int __c)\n\n{\n  int iVar1;\n  \n  iVar1 = putchar(__c);\n  return iVar1;\n}\n\n",
            "called": [
                "putchar"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102050",
            "calling": [
                "FUN_001035a2",
                "FUN_001064b0"
            ],
            "imported": false,
            "current_name": "putchar"
        },
        "bfd_set_default_target": {
            "renaming": {},
            "code": "\nvoid bfd_set_default_target(void)\n\n{\n  bfd_set_default_target();\n  return;\n}\n\n",
            "called": [
                "bfd_set_default_target"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020d0",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "bfd_set_default_target"
        },
        "bfd_get_error": {
            "renaming": {},
            "code": "\nvoid bfd_get_error(void)\n\n{\n  bfd_get_error();\n  return;\n}\n\n",
            "called": [
                "bfd_get_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021d0",
            "calling": [
                "FUN_00106540",
                "FUN_001055f0",
                "FUN_001043d0",
                "FUN_001048e0"
            ],
            "imported": false,
            "current_name": "bfd_get_error"
        },
        "FUN_00103b5d": {
            "renaming": {
                "FUN_00103b5d": "print_matching_formats_00103b5d",
                "param_1": "formatStrings",
                "uVar1": "defaultFormat",
                "__format": "formatString",
                "plVar2": "currentFormat"
            },
            "code": "\n\n\nvoid printMatchingFormats_00103b5d(long *formatStrings)\n\n{\n  undefined8 defaultFormat;\n  char *formatString;\n  long *currentFormat;\n  \n  fflush(_stdout);\n  defaultFormat = DAT_0010b820;\n  formatString = (char *)dcgettext(0,\"%s: Matching formats:\",5);\n  fprintf(_stderr,formatString,defaultFormat);\n  for (currentFormat = formatStrings; *currentFormat != 0; currentFormat = currentFormat + 1) {\n    fprintf(_stderr,\" %s\");\n  }\n  free(formatStrings);\n  fputc(10,_stderr);\n  return;\n}\n\n",
            "called": [
                "fflush",
                "dcgettext",
                "free",
                "fputc",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103b5d",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "print_matching_formats_00103b5d"
        },
        "FUN_001036a7": {
            "renaming": {
                "FUN_001036a7": "print_parameters_001036a7",
                "param_1": "stringParam",
                "param_2": "stringParam2",
                "param_3": "unusedParam1",
                "param_4": "unusedParam2"
            },
            "code": "\nvoid printParameters_001036a7(undefined8 *stringParam,undefined8 *stringParam2,undefined8 unusedParam1,undefined8 unusedParam2)\n\n{\n  if (DAT_0010b818 != 0) {\n    if (stringParam != (undefined8 *)0x0) {\n      printf(\"%s:\",*stringParam);\n    }\n    printf(\"%s:\",*stringParam2,unusedParam2);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001036a7",
            "calling": [],
            "imported": false,
            "current_name": "print_parameters_001036a7"
        },
        "FUN_00102f19": {
            "renaming": {
                "FUN_00102f19": "print_symbols_00102f19",
                "param_1": "filename",
                "pcVar1": "message"
            },
            "code": "\nvoid printSymbols_00102f19(undefined8 filename)\n\n{\n  char *message;\n  \n  message = \"\\n\\nUndefined symbols from %s:\\n\\n\";\n  if (DAT_0010b7e8 == 0) {\n    message = \"\\n\\nSymbols from %s:\\n\\n\";\n  }\n  message = (char *)dcgettext(0,message,5);\n  printf(message,filename);\n  message = \"Name                  Value   Class        Type         Size     Line  Section\\n\\n\";\n  if (DAT_0010b7a8 != 0x20) {\n    message = \n    \"Name                  Value           Class        Type         Size             Line  Section\\n\\n\"\n    ;\n  }\n  message = (char *)dcgettext(0,message,5);\n  printf(message);\n  return;\n}\n\n",
            "called": [
                "printf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f19",
            "calling": [],
            "imported": false,
            "current_name": "print_symbols_00102f19"
        },
        "__cxa_finalize": {
            "renaming": {},
            "code": "\nvoid __cxa_finalize(void)\n\n{\n  __cxa_finalize();\n  return;\n}\n\n",
            "called": [
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102440",
            "calling": [
                "_FINI_0"
            ],
            "imported": false,
            "current_name": "__cxa_finalize"
        },
        "FUN_00102fc3": {
            "renaming": {
                "FUN_00102fc3": "check_file_compatibility_00102fc3",
                "param_1": "file1",
                "param_2": "file2",
                "cVar1": "lastChar",
                "__s": "string1",
                "__s_00": "string2",
                "uVar2": "size2",
                "uVar3": "flag",
                "lVar4": "file1Info",
                "lVar5": "file2Info",
                "sVar6": "length1",
                "sVar7": "length2",
                "pcVar8": "searchResult1",
                "pcVar9": "searchResult2",
                "uVar10": "result",
                "uVar11": "offset2",
                "uVar12": "offset1",
                "uVar13": "data",
                "unaff_R13": "file2Offset",
                "bVar14": "isMatch"
            },
            "code": "\nulong checkFileCompatibility_00102fc3(undefined8 file1,undefined8 file2)\n\n{\n  char lastChar;\n  ulong size2;\n  char *string1;\n  char *string2;\n  uint flag;\n  long file1Info;\n  long file2Info;\n  size_t length1;\n  size_t length2;\n  char *searchResult1;\n  char *searchResult2;\n  ulong result;\n  ulong offset2;\n  ulong offset1;\n  undefined8 data;\n  long file2Offset;\n  bool isMatch;\n  \n  data = *DAT_0010b780;\n  FUN_00106530();\n  file1Info = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,DAT_0010b778,data,DAT_0010b770);\n  file2Info = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,DAT_0010b778,file2,DAT_0010b768);\n  if ((file1Info == 0) || (file2Offset = file2Info, file2Info == 0)) {\n    file2Info = FUN_00106530(*DAT_0010b780);\n  }\n  if ((*(long *)(file1Info + 0x20) == 0x10c2a8) || (*(long *)(file2Info + 0x20) == 0x10c2a8)) {\n                    \n    abort();\n  }\n  result = *(ulong *)(*(long *)(file1Info + 0x20) + 0x30);\n  size2 = *(ulong *)(*(long *)(file2Info + 0x20) + 0x30);\n  offset1 = *(long *)(file1Info + 0x10) + result;\n  offset2 = *(long *)(file2Offset + 0x10) + size2;\n  isMatch = offset1 < offset2;\n  if ((offset1 != offset2) || (isMatch = result < size2, result != size2)) {\n    return (ulong)(-(uint)isMatch | 1);\n  }\n  string1 = *(char **)(file1Info + 8);\n  string2 = *(char **)(file2Offset + 8);\n  length1 = strlen(string1);\n  length2 = strlen(string2);\n  searchResult1 = strstr(string1,\"gnu_compiled\");\n  if (searchResult1 == (char *)0x0) {\n    searchResult2 = strstr(string1,\"gcc2_compiled\");\n    searchResult1 = strstr(string2,\"gnu_compiled\");\n    if ((searchResult1 == (char *)0x0) && (searchResult1 = strstr(string2,\"gcc2_compiled\"), searchResult1 == (char *)0x0))\n    goto joined_r0x00103157;\n    if (searchResult2 == (char *)0x0) {\n      return 1;\n    }\n  }\n  else {\n    searchResult1 = strstr(string2,\"gnu_compiled\");\n    if (searchResult1 == (char *)0x0) {\n      searchResult2 = strstr(string2,\"gcc2_compiled\");\njoined_r0x00103157:\n      if (searchResult2 != (char *)0x0) {\n        return 0xffffffff;\n      }\n    }\n  }\n  flag = *(uint *)(file2Offset + 0x18) & 0x4000;\n  if ((*(byte *)(file1Info + 0x19) & 0x40) == 0) {\n    if ((length1 < 3) || (string1[length1 - 2] != '.')) {\n      if (flag != 0) {\n        return 1;\n      }\n      if ((length2 < 3) || (string2[length2 - 2] != '.')) goto LAB_00103202;\n      isMatch = false;\n      goto LAB_001031e7;\n    }\n    lastChar = string1[length1 - 1];\n    isMatch = lastChar == 'o' || lastChar == 'a';\n    if (flag == 0) {\n      if ((length2 < 3) || (string2[length2 - 2] != '.')) {\n        if (lastChar == 'o' || lastChar == 'a') {\n          return 0xffffffff;\n        }\n        goto LAB_00103202;\n      }\n      goto LAB_001031e7;\n    }\n  }\n  else {\n    if (flag != 0) goto LAB_00103202;\n    if (length2 < 3) {\n      return 0xffffffff;\n    }\n    if (string2[length2 - 2] != '.') {\n      return 0xffffffff;\n    }\n    isMatch = true;\nLAB_001031e7:\n    if ((string2[length2 - 1] != 'o') && (string2[length2 - 1] != 'a')) {\n      if (isMatch) {\n        return 0xffffffff;\n      }\n      goto LAB_00103202;\n    }\n  }\n  if (!isMatch) {\n    return 1;\n  }\nLAB_00103202:\n  result = FUN_00104fa0(data,file2);\n  return result;\n}\n\n",
            "called": [
                "FUN_00106530"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102fc3",
            "calling": [
                "FUN_00105050"
            ],
            "imported": false,
            "current_name": "check_file_compatibility_00102fc3"
        },
        "textdomain": {
            "renaming": {},
            "code": "\nvoid textdomain(void)\n\n{\n  textdomain();\n  return;\n}\n\n",
            "called": [
                "textdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102110",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "textdomain"
        },
        "concat": {
            "renaming": {},
            "code": "\nvoid concat(void)\n\n{\n  concat();\n  return;\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021b0",
            "calling": [
                "FUN_001025f5",
                "FUN_00104670"
            ],
            "imported": false,
            "current_name": "concat"
        },
        "fread": {
            "renaming": {},
            "code": "\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fread(__ptr,__size,__n,__stream);\n  return sVar1;\n}\n\n",
            "called": [
                "fread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020e0",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "fread"
        },
        "FUN_00103729": {
            "renaming": {
                "FUN_00103729": "print_symbol_info_00103729",
                "param_1": "symbol",
                "param_2": "param",
                "cVar1": "isUndefined",
                "uVar2": "symClass",
                "iVar3": "asprintfResult",
                "piVar4": "errorCode",
                "uVar5": "errorMsg",
                "lVar6": "info",
                "bVar7": "type",
                "pcVar8": "typeString"
            },
            "code": "\nvoid printSymbolInfo_00103729(long *symbol,undefined8 param)\n\n{\n  char isUndefined;\n  ushort symClass;\n  int asprintfResult;\n  int *errorCode;\n  undefined8 errorMsg;\n  long info;\n  byte type;\n  char *typeString;\n  \n  FUN_00104740(\"%-20s|\",symbol,0,param);\n  isUndefined = bfd_is_undefined_symclass((int)*(char *)(*symbol + 8));\n  if (isUndefined == '\\0') {\n    FUN_001054d0(*(undefined8 *)*symbol);\n  }\n  else if (DAT_0010b7a8 == 0x20) {\n    printf(\"        \");\n  }\n  else {\n    printf(\"                \");\n  }\n  printf(\"|   %c  |\",(ulong)(uint)(int)*(char *)(*symbol + 8));\n  if (*(char *)(*symbol + 8) == '-') {\n    printf(\"%18s|  \",*(undefined8 *)(*symbol + 0x20));\n    printf(&DAT_0010b23d,(ulong)(uint)(int)*(short *)(*symbol + 0x1a));\n    goto LAB_00103a54;\n  }\n  if (symbol[2] == 0) {\n    if (symbol[3] != 0) {\n      info = *(long *)(symbol[3] + 0x30);\n      isUndefined = *(char *)(info + 0x28);\n      if (isUndefined == 'g') goto LAB_00103983;\n      if (isUndefined == 'h') {\n        typeString = \"Line\";\n      }\n      else if (isUndefined == 'd') {\n        typeString = \"Block\";\n      }\n      else if (*(ushort *)(info + 0x26) == 0) {\n        typeString = \"None\";\n      }\n      else {\n        symClass = *(ushort *)(info + 0x26) >> 4 & 3;\n        if (symClass == 2) {\n          typeString = \"Function\";\n        }\n        else if (symClass == 3) {\n          typeString = \"Array\";\n        }\n        else {\n          if (symClass != 1) {\n            free(DAT_0010b730);\n            symClass = *(ushort *)(info + 0x26);\n            type = *(byte *)(info + 0x28);\n            typeString = (char *)dcgettext(0,\"<unknown>: %d/%d\",5);\n            asprintfResult = asprintf(&DAT_0010b730,typeString,(ulong)type,(ulong)symClass);\n            typeString = DAT_0010b730;\n            goto joined_r0x00103964;\n          }\n          typeString = \"Pointer\";\n        }\n      }\n      goto LAB_001039c0;\n    }\n    printf(\"                  |\");\n  }\n  else {\n    type = *(byte *)(symbol[2] + 0x48) & 0xf;\n    switch(type) {\n    case 0:\n      typeString = \"NOTYPE\";\n      break;\n    case 1:\n      typeString = \"OBJECT\";\n      break;\n    case 2:\n      typeString = \"FUNC\";\n      break;\n    case 3:\n      typeString = \"SECTION\";\n      break;\n    case 4:\n      typeString = \"FILE\";\n      break;\n    case 5:\n      typeString = \"COMMON\";\n      break;\n    case 6:\n      typeString = \"TLS\";\n      break;\n    default:\n      free(DAT_0010b728);\n      typeString = \"<processor specific>: %d\";\n      if ((2 < type - 0xd) && (typeString = \"<OS specific>: %d\", 2 < type - 10)) {\n        typeString = \"<unknown>: %d\";\n      }\n      typeString = (char *)dcgettext(0,typeString,5);\n      asprintfResult = asprintf(&DAT_0010b728,typeString,(ulong)type);\n      typeString = DAT_0010b728;\njoined_r0x00103964:\n      if (asprintfResult < 0) {\n        errorCode = __errno_location();\n        errorMsg = xstrerror(*errorCode);\n        FUN_00106300(&DAT_0010712d,errorMsg);\nLAB_00103983:\n        typeString = \"File\";\n      }\n    }\nLAB_001039c0:\n    printf(\"%18s|\",typeString);\n  }\n  if (symbol[2] == 0) {\n    if (symbol[1] != 0) goto LAB_001039fb;\nLAB_00103a02:\n    if (DAT_0010b7a8 == 0x20) {\n      printf(\"        \");\n    }\n    else {\n      printf(\"                \");\n    }\n  }\n  else {\n    if (*(long *)(symbol[2] + 0x38) == 0) goto LAB_00103a02;\nLAB_001039fb:\n    FUN_001054d0();\n  }\n  info = symbol[2];\n  if ((info != 0) || (info = symbol[3], info != 0)) {\n    printf(\"|     |%s\",**(undefined8 **)(info + 0x20));\n    return;\n  }\nLAB_00103a54:\n  printf(\"|     |\");\n  return;\n}\n\n",
            "called": [
                "printf",
                "asprintf",
                "FUN_001054d0",
                "bfd_is_undefined_symclass",
                "dcgettext",
                "free",
                "FUN_00106300",
                "__errno_location",
                "FUN_00104740",
                "xstrerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103729",
            "calling": [],
            "imported": false,
            "current_name": "print_symbol_info_00103729"
        },
        "exit": {
            "renaming": {},
            "code": "\n\n\nvoid exit(int __status)\n\n{\n                    \n  exit(__status);\n}\n\n",
            "called": [
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023c0",
            "calling": [
                "FUN_001055f0",
                "FUN_00103ca0"
            ],
            "imported": false,
            "current_name": "exit"
        },
        "bfd_check_format": {
            "renaming": {},
            "code": "\nvoid bfd_check_format(void)\n\n{\n  bfd_check_format();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023d0",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "bfd_check_format"
        },
        "xstrerror": {
            "renaming": {},
            "code": "\nvoid xstrerror(void)\n\n{\n  xstrerror();\n  return;\n}\n\n",
            "called": [
                "xstrerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102330",
            "calling": [
                "FUN_00103729"
            ],
            "imported": false,
            "current_name": "xstrerror"
        },
        "FUN_00103573": {
            "renaming": {
                "FUN_00103573": "print_strings_and_data_00103573",
                "param_1": "string1",
                "param_2": "string2",
                "param_3": "data1",
                "param_4": "data2"
            },
            "code": "\nvoid print_strings_and_data_00103573(undefined8 *string1,undefined8 *string2,undefined8 data1,undefined8 data2)\n\n{\n  if (string1 != (undefined8 *)0x0) {\n    printf(\"%s:\",*string1);\n  }\n  printf(\"%s:\",*string2,data2);\n  return;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103573",
            "calling": [
                "FUN_001053b0"
            ],
            "imported": false,
            "current_name": "print_strings_and_data_00103573"
        },
        "FUN_00105110": {
            "renaming": {
                "FUN_00105110": "print_file_info_00105110",
                "param_1": "fileInfo",
                "param_2": "sectionHeader",
                "param_3": "offset",
                "param_4": "errorMessage",
                "__ptr": "ptr",
                "__s1": "sectionName",
                "pplVar1": "sectionPtr",
                "plVar2": "entryPtr",
                "lVar3": "entryAddress",
                "puVar4": "functionPtr",
                "cVar5": "character",
                "iVar6": "index",
                "pvVar7": "sections",
                "lVar8": "entry",
                "uVar9": "flags",
                "lVar10": "i",
                "local_b4": "lineNumber",
                "local_b0": "buffer",
                "local_a8": "sectionBuffer",
                "local_a0": "symbolName",
                "local_98": "sectionEntry",
                "local_90": "entryAddressList",
                "local_88": "offsetList",
                "pvStack_80": "symbolTableList",
                "pvStack_78": "symbolAddressList",
                "pvStack_70": "symbolNameList",
                "local_68": "sectionBuffer1",
                "local_60": "sectionType",
                "_stdout": "stdout"
            },
            "code": "\n\n\nvoid printFileInfo_00105110(undefined8 *fileInfo,long *sectionHeader,undefined8 offset,undefined8 *errorMessage)\n\n{\n  void *ptr;\n  char *sectionName;\n  long **sectionPtr;\n  long *entryPtr;\n  long entryAddress;\n  undefined8 *functionPtr;\n  char character;\n  int index;\n  void *sections;\n  long entry;\n  uint flags;\n  long i;\n  uint lineNumber;\n  undefined buffer [8];\n  undefined *sectionBuffer;\n  undefined8 symbolName;\n  long *sectionEntry;\n  long *entryAddressList;\n  void *offsetList;\n  void *symbolTableList;\n  void *symbolAddressList;\n  void *symbolNameList;\n  undefined sectionBuffer1 [8];\n  char sectionType;\n  \n  if (*(code **)(PTR_PTR_FUN_0010b260 + 0x18) == FUN_001053b0) {\n    if (DAT_0010b818 != 0) {\n      if (errorMessage != (undefined8 *)0x0) {\n        printf(\"%s:\",*errorMessage);\n      }\n      printf(\"%s:\",*fileInfo);\n    }\n  }\n  else {\n    (**(code **)(PTR_PTR_FUN_0010b260 + 0x18))(errorMessage,fileInfo);\n  }\n  sectionBuffer = sectionBuffer1;\n  (**(code **)(fileInfo[1] + 0x218))(fileInfo,sectionHeader,sectionBuffer);\n  flags = *(uint *)(sectionHeader + 3);\n  character = sectionType;\n  if (((((sectionType == 'i') && ((flags & 0x400000) != 0)) && (DAT_0010b7c8 != (char *)0x0)) &&\n      ((*DAT_0010b7c8 != '\\0' && (character = *DAT_0010b7c8, (flags & 2) == 0)))) &&\n     (character = sectionType, DAT_0010b7c8[1] != '\\0')) {\n    character = DAT_0010b7c8[1];\n  }\n  sectionType = character;\n  symbolName = offset;\n  if ((flags & 0x200100) != 0) goto LAB_00103330;\n  entry = *sectionHeader;\n  index = *(int *)(*(long *)(entry + 8) + 8);\n  if (((flags & 0x200000) == 0) && (index == 5)) {\n    sectionEntry = sectionHeader;\n    if (*(long *)(entry + 0x110) == 0) {\n      sectionEntry = (long *)0x0;\n    }\n  }\n  else {\n    sectionEntry = (long *)0x0;\n    if (((index - 2U & 0xfffffffd) == 0) && (entryAddressList = sectionHeader, *(long *)(entry + 0x110) != 0))\n    goto LAB_001051bf;\n  }\n  entryAddressList = (long *)0x0;\nLAB_001051bf:\n  (**(code **)(PTR_PTR_FUN_0010b260 + 0x20))(&sectionBuffer,fileInfo);\n  do {\n    if (DAT_0010b804 == 0) {\nLAB_001051e6:\n      putc(10,stdout);\n      return;\n    }\n    if (_DAT_0010b7b8 == fileInfo) {\n      functionPtr = _DAT_0010b7b8;\n      if (DAT_0010b758 == (void *)0x0) goto LAB_00105359;\nLAB_00105288:\n      _DAT_0010b7b8 = functionPtr;\n      sections = DAT_0010b750;\n      if (sectionHeader[4] == 0x10c2a8) {\n        if (_DAT_0010b7b0 == fileInfo) {\n          if (DAT_0010b750 == (void *)0x0) goto LAB_001033d1;\n        }\n        else {\n          flags = 0;\n          if (DAT_0010b750 != (void *)0x0) {\n            for (; flags < DAT_0010b748; flags = flags + 1) {\n              ptr = *(void **)((long)sections + (ulong)flags * 8);\n              if (ptr != (void *)0x0) {\n                free(ptr);\n              }\n            }\n            free(DAT_0010b740);\n            free(sections);\n            free(DAT_0010b738);\n            DAT_0010b740 = (void *)0x0;\n            DAT_0010b750 = (void *)0x0;\n            DAT_0010b738 = (void *)0x0;\n          }\nLAB_001033d1:\n          DAT_0010b748 = *(uint *)(fileInfo + 0x14);\n          DAT_0010b740 = (void *)xmalloc((ulong)DAT_0010b748 * 8);\n          DAT_0010b750 = (void *)xmalloc((ulong)DAT_0010b748 << 3);\n          DAT_0010b738 = (void *)xmalloc((ulong)DAT_0010b748 << 3);\n          symbolNameList = DAT_0010b758;\n          offsetList = DAT_0010b740;\n          symbolTableList = DAT_0010b750;\n          symbolAddressList = DAT_0010b738;\n          bfd_map_over_sections(fileInfo,FUN_00103c00,&offsetList);\n          _DAT_0010b7b0 = fileInfo;\n        }\n        sectionName = (char *)sectionHeader[1];\n        for (flags = 0; flags < DAT_0010b748; flags = flags + 1) {\n          entry = (ulong)flags * 8;\n          sections = DAT_0010b738;\n          for (i = 0;\n              *(long *)((long)sections + entry) != i && i <= *(long *)((long)sections + entry)\n              ; i = i + 1) {\n            sectionPtr = *(long ***)(*(long *)((long)DAT_0010b750 + entry) + i * 8);\n            entryPtr = *sectionPtr;\n            if ((((entryPtr != (long *)0x0) &&\n                 (entryAddress = *entryPtr, *(long *)(entryAddress + 0x20) == sectionHeader[4])) &&\n                (*(long *)(entryAddress + 0x10) == sectionHeader[2])) &&\n               (((index = strcmp(sectionName,*(char **)(entryAddress + 8)), index == 0 &&\n                 (character = (**(code **)(fileInfo[1] + 0x240))\n                                    (fileInfo,DAT_0010b758,\n                                     *(undefined8 *)((long)DAT_0010b740 + entry),sectionPtr[1],\n                                     &offsetList,buffer,&lineNumber,0), sections = DAT_0010b738,\n                 character != '\\0')) && (offsetList != (void *)0x0)))) {\n              printf(\"\\t%s:%u\",offsetList,(ulong)lineNumber);\n              flags = DAT_0010b748;\n              break;\n            }\n          }\n        }\n      }\n      else if (*(undefined8 **)(sectionHeader[4] + 0xe0) == fileInfo) {\n        character = (**(code **)(fileInfo[1] + 0x250))(fileInfo,DAT_0010b758,sectionHeader,&offsetList,&lineNumber);\n        if (((character != '\\0') ||\n            (character = (**(code **)(fileInfo[1] + 0x240))\n                               (fileInfo,DAT_0010b758,sectionHeader[4],sectionHeader[2],&offsetList,buffer,\n                                &lineNumber,0), character != '\\0')) &&\n           ((offsetList != (void *)0x0 && (lineNumber != 0)))) {\n          printf(\"\\t%s:%u\");\n        }\n      }\n      goto LAB_001051e6;\n    }\n    if (DAT_0010b758 != (void *)0x0) {\n      free(DAT_0010b758);\n      DAT_0010b758 = (void *)0x0;\n    }\nLAB_00105359:\n    entry = (**(code **)(fileInfo[1] + 0x1f8))(fileInfo);\n    if (entry < 0) {\n      FUN_00103463(entry);\n      return;\n    }\n    DAT_0010b758 = (void *)xmalloc();\n    entry = (**(code **)(fileInfo[1] + 0x200))(fileInfo,DAT_0010b758);\n    functionPtr = fileInfo;\n    if (-1 < entry) goto LAB_00105288;\n    FUN_00106530(*fileInfo);\nLAB_00103330:\n    sectionEntry = (long *)0x0;\n    entryAddressList = (long *)0x0;\n    (**(code **)(PTR_PTR_FUN_0010b260 + 0x20))(&sectionBuffer,fileInfo);\n  } while( true );\n}\n\n",
            "called": [
                "printf",
                "FUN_001053b0",
                "FUN_00103463",
                "FUN_001053c0",
                "xmalloc",
                "FUN_00103238",
                "free",
                "FUN_00106530"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105110",
            "calling": [
                "FUN_00104d5b"
            ],
            "imported": false,
            "current_name": "print_file_info_00105110"
        },
        "setlocale": {
            "renaming": {},
            "code": "\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = setlocale(__category,__locale);\n  return pcVar1;\n}\n\n",
            "called": [
                "setlocale"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022f0",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "setlocale"
        },
        "FUN_00102fd2": {
            "renaming": {
                "FUN_00102fd2": "check_compatibility_00102fd2",
                "param_1": "binaryPath1",
                "param_2": "binaryPath2",
                "__s": "compiler1",
                "__s_00": "compiler2",
                "uVar3": "flag",
                "lVar4": "binaryInfo1",
                "lVar5": "binaryInfo2",
                "sVar6": "compiler1Length",
                "sVar7": "compiler2Length",
                "pcVar8": "gnuCompiled",
                "pcVar9": "gcc2Compiled",
                "uVar10": "result",
                "uVar11": "compiler2End",
                "uVar12": "compiler1End",
                "unaff_R13": "binaryInfo2Backup",
                "bVar13": "isCompatible"
            },
            "code": "\nulong checkCompatibility_00102fd2(undefined8 binaryPath1,undefined8 binaryPath2)\n\n{\n  char cVar1;\n  ulong uVar2;\n  char *compiler1;\n  char *compiler2;\n  uint flag;\n  long binaryInfo1;\n  long binaryInfo2;\n  size_t compiler1Length;\n  size_t compiler2Length;\n  char *gnuCompiled;\n  char *gcc2Compiled;\n  ulong result;\n  ulong compiler2End;\n  ulong compiler1End;\n  long binaryInfo2Backup;\n  bool isCompatible;\n  \n  binaryInfo1 = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,DAT_0010b778,binaryPath1,DAT_0010b770);\n  binaryInfo2 = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,DAT_0010b778,binaryPath2,DAT_0010b768);\n  if ((binaryInfo1 == 0) || (binaryInfo2Backup = binaryInfo2, binaryInfo2 == 0)) {\n    binaryInfo2 = FUN_00106530(*DAT_0010b780);\n  }\n  if ((*(long *)(binaryInfo1 + 0x20) == 0x10c2a8) || (*(long *)(binaryInfo2 + 0x20) == 0x10c2a8)) {\n                    \n    abort();\n  }\n  result = *(ulong *)(*(long *)(binaryInfo1 + 0x20) + 0x30);\n  uVar2 = *(ulong *)(*(long *)(binaryInfo2 + 0x20) + 0x30);\n  compiler1End = *(long *)(binaryInfo1 + 0x10) + result;\n  compiler2End = *(long *)(binaryInfo2Backup + 0x10) + uVar2;\n  isCompatible = compiler1End < compiler2End;\n  if ((compiler1End != compiler2End) || (isCompatible = result < uVar2, result != uVar2)) {\n    return (ulong)(-(uint)isCompatible | 1);\n  }\n  compiler1 = *(char **)(binaryInfo1 + 8);\n  compiler2 = *(char **)(binaryInfo2Backup + 8);\n  compiler1Length = strlen(compiler1);\n  compiler2Length = strlen(compiler2);\n  gnuCompiled = strstr(compiler1,\"gnu_compiled\");\n  if (gnuCompiled == (char *)0x0) {\n    gcc2Compiled = strstr(compiler1,\"gcc2_compiled\");\n    gnuCompiled = strstr(compiler2,\"gnu_compiled\");\n    if ((gnuCompiled == (char *)0x0) && (gnuCompiled = strstr(compiler2,\"gcc2_compiled\"), gnuCompiled == (char *)0x0))\n    goto joined_r0x00103157;\n    if (gcc2Compiled == (char *)0x0) {\n      return 1;\n    }\n  }\n  else {\n    gnuCompiled = strstr(compiler2,\"gnu_compiled\");\n    if (gnuCompiled == (char *)0x0) {\n      gcc2Compiled = strstr(compiler2,\"gcc2_compiled\");\njoined_r0x00103157:\n      if (gcc2Compiled != (char *)0x0) {\n        return 0xffffffff;\n      }\n    }\n  }\n  flag = *(uint *)(binaryInfo2Backup + 0x18) & 0x4000;\n  if ((*(byte *)(binaryInfo1 + 0x19) & 0x40) == 0) {\n    if ((compiler1Length < 3) || (compiler1[compiler1Length - 2] != '.')) {\n      if (flag != 0) {\n        return 1;\n      }\n      if ((compiler2Length < 3) || (compiler2[compiler2Length - 2] != '.')) goto LAB_00103202;\n      isCompatible = false;\n      goto LAB_001031e7;\n    }\n    cVar1 = compiler1[compiler1Length - 1];\n    isCompatible = cVar1 == 'o' || cVar1 == 'a';\n    if (flag == 0) {\n      if ((compiler2Length < 3) || (compiler2[compiler2Length - 2] != '.')) {\n        if (cVar1 == 'o' || cVar1 == 'a') {\n          return 0xffffffff;\n        }\n        goto LAB_00103202;\n      }\n      goto LAB_001031e7;\n    }\n  }\n  else {\n    if (flag != 0) goto LAB_00103202;\n    if (compiler2Length < 3) {\n      return 0xffffffff;\n    }\n    if (compiler2[compiler2Length - 2] != '.') {\n      return 0xffffffff;\n    }\n    isCompatible = true;\nLAB_001031e7:\n    if ((compiler2[compiler2Length - 1] != 'o') && (compiler2[compiler2Length - 1] != 'a')) {\n      if (isCompatible) {\n        return 0xffffffff;\n      }\n      goto LAB_00103202;\n    }\n  }\n  if (!isCompatible) {\n    return 1;\n  }\nLAB_00103202:\n  result = FUN_00104fa0(binaryPath1,binaryPath2);\n  return result;\n}\n\n",
            "called": [
                "abort",
                "FUN_00104fa0",
                "strstr",
                "strlen",
                "FUN_00106530"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102fd2",
            "calling": [
                "FUN_00104d5b"
            ],
            "imported": false,
            "current_name": "check_compatibility_00102fd2"
        },
        "bindtextdomain": {
            "renaming": {},
            "code": "\nvoid bindtextdomain(void)\n\n{\n  bindtextdomain();\n  return;\n}\n\n",
            "called": [
                "bindtextdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102140",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "bindtextdomain"
        },
        "FUN_00102f9f": {
            "renaming": {
                "FUN_00102f9f": "initialize_return_address_00102f9f",
                "auVar1": "returnAddress",
                "unaff_retaddr": "originalReturnAddress"
            },
            "code": "\nundefined  [16] initializeReturnAddress_00102f9f(void)\n\n{\n  undefined returnAddress [16];\n  undefined8 originalReturnAddress;\n  \n  FUN_00106530(*DAT_0010b780);\n  returnAddress._8_8_ = originalReturnAddress;\n  returnAddress._0_8_ = 0xffffffff;\n  return returnAddress;\n}\n\n",
            "called": [
                "FUN_00106530"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f9f",
            "calling": [
                "FUN_00104fa0"
            ],
            "imported": false,
            "current_name": "initialize_return_address_00102f9f"
        },
        "dcgettext": {
            "renaming": {},
            "code": "\nvoid dcgettext(void)\n\n{\n  dcgettext();\n  return;\n}\n\n",
            "called": [
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102150",
            "calling": [
                "FUN_00103ca0",
                "FUN_00102f19",
                "FUN_00103b5d",
                "FUN_001053c0",
                "FUN_0010249f",
                "FUN_00104370",
                "FUN_0010370a",
                "FUN_00103729",
                "FUN_001055f0",
                "FUN_001043d0",
                "FUN_00103a78",
                "FUN_00103abf",
                "FUN_00104d5b",
                "FUN_001048e0",
                "FUN_00102450"
            ],
            "imported": false,
            "current_name": "dcgettext"
        },
        "bfd_set_error_program_name": {
            "renaming": {},
            "code": "\nvoid bfd_set_error_program_name(void)\n\n{\n  bfd_set_error_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102300",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "bfd_set_error_program_name"
        },
        "fputc": {
            "renaming": {},
            "code": "\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102210",
            "calling": [
                "FUN_00103ca0",
                "FUN_00103b5d"
            ],
            "imported": false,
            "current_name": "fputc"
        },
        "FUN_00103a66": {
            "renaming": {
                "FUN_00103a66": "check_if_pointer_not_null_00103a66",
                "unaff_RBX": "rbx"
            },
            "code": "\nvoid checkIfPointerNotNull_00103a66(void)\n\n{\n  long rbx;\n  \n  if (*(long *)(rbx + 8) != 0) {\n    FUN_0010651a();\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_0010651a"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103a66",
            "calling": [
                "FUN_001064b0"
            ],
            "imported": false,
            "current_name": "check_if_pointer_not_null_00103a66"
        },
        "_DT_INIT": {
            "renaming": {},
            "code": "\nvoid _DT_INIT(void)\n\n{\n  __gmon_start__();\n  return;\n}\n\n",
            "called": [
                "__gmon_start__"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102000",
            "calling": [],
            "imported": false,
            "current_name": "_DT_INIT"
        },
        "strcoll": {
            "renaming": {},
            "code": "\n\n\nint strcoll(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = strcoll(__s1,__s2);\n  return iVar1;\n}\n\n",
            "called": [
                "strcoll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022c0",
            "calling": [
                "FUN_00104fa0"
            ],
            "imported": false,
            "current_name": "strcoll"
        },
        "bfd_openr": {
            "renaming": {},
            "code": "\nvoid bfd_openr(void)\n\n{\n  bfd_openr();\n  return;\n}\n\n",
            "called": [
                "bfd_openr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102120",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "bfd_openr"
        },
        "cplus_demangle_set_style": {
            "renaming": {},
            "code": "\nvoid cplus_demangle_set_style(void)\n\n{\n  cplus_demangle_set_style();\n  return;\n}\n\n",
            "called": [
                "cplus_demangle_set_style"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102100",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "cplus_demangle_set_style"
        },
        "FUN_001035a2": {
            "renaming": {
                "FUN_001035a2": "print_formatted_data_001035a2",
                "unaff_RBX": "dataPointer",
                "lVar1": "valueToPrint"
            },
            "code": "\nvoid printFormattedData_001035a2(void)\n\n{\n  long *dataPointer;\n  long valueToPrint;\n  \n  if (dataPointer[2] == 0) {\n    valueToPrint = dataPointer[1];\n  }\n  else {\n    valueToPrint = *(long *)(dataPointer[2] + 0x38);\n  }\n  if (valueToPrint != 0) {\n    putchar(0x20);\n    if (dataPointer[2] == 0) {\n      valueToPrint = dataPointer[1];\n    }\n    else {\n      valueToPrint = *(long *)(dataPointer[2] + 0x38);\n    }\n    FUN_001054d0(valueToPrint);\n  }\n  printf(\" %c\",(ulong)(uint)(int)*(char *)(*dataPointer + 8));\n  if (*(char *)(*dataPointer + 8) != '-') {\n    FUN_00104740(&DAT_0010712c);\n    return;\n  }\n  putchar(0x20);\n  printf(&DAT_0010b238,(ulong)(uint)(int)*(char *)(*dataPointer + 0x19));\n  putchar(0x20);\n  printf(&DAT_0010b23d,(ulong)(uint)(int)*(short *)(*dataPointer + 0x1a));\n  printf(\" %5s\",*(undefined8 *)(*dataPointer + 0x20));\n  FUN_00104740(&DAT_0010712c);\n  return;\n}\n\n",
            "called": [
                "printf",
                "FUN_001054d0",
                "putchar",
                "FUN_00104740"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001035a2",
            "calling": [
                "FUN_001053c0"
            ],
            "imported": false,
            "current_name": "print_formatted_data_001035a2"
        },
        "FUN_00103463": {
            "renaming": {
                "FUN_00103463": "find_and_print_matching_records_00103463",
                "unaff_R12": "record_to_match",
                "unaff_R13": "function_ptrs",
                "unaff_R15": "record_to_compare",
                "param_8": "record_index",
                "param_10": "record_value",
                "in_stack_00000050": "record_value_2"
            },
            "code": "\n\n\nvoid find_and_print_matching_records_00103463(void)\n\n{\n  long *plVar1;\n  long lVar2;\n  char cVar3;\n  int iVar4;\n  long lVar5;\n  char *record_to_match;\n  undefined8 *function_ptrs;\n  long lVar6;\n  long record_to_compare;\n  undefined8 record_index;\n  ulong record_value;\n  long record_value_2;\n  \n  FUN_00106530(*function_ptrs);\n  do {\n    record_index._4_4_ = record_index._4_4_ + 1;\n    if (DAT_0010b748 <= record_index._4_4_) {\n      putc(10,_stdout);\n      return;\n    }\n    lVar5 = DAT_0010b738;\n    for (lVar6 = 0; plVar1 = (long *)(lVar5 + (ulong)record_index._4_4_ * 8),\n        *plVar1 != lVar6 && lVar6 <= *plVar1; lVar6 = lVar6 + 1) {\n      plVar1 = **(long ***)(*(long *)(DAT_0010b750 + (ulong)record_index._4_4_ * 8) + lVar6 * 8);\n      if ((((plVar1 != (long *)0x0) &&\n           (lVar2 = *plVar1, *(long *)(lVar2 + 0x20) == *(long *)(record_to_compare + 0x20))) &&\n          (*(long *)(lVar2 + 0x10) == *(long *)(record_to_compare + 0x10))) &&\n         (((iVar4 = strcmp(record_to_match,*(char **)(lVar2 + 8)), iVar4 == 0 &&\n           (cVar3 = (**(code **)(function_ptrs[1] + 0x240))(), lVar5 = DAT_0010b738, cVar3 != '\\0')) &&\n          (record_value_2 != 0)))) {\n        printf(\"\\t%s:%u\",record_value_2,record_value >> 0x20);\n        record_index._4_4_ = DAT_0010b748;\n        break;\n      }\n    }\n  } while( true );\n}\n\n",
            "called": [
                "printf",
                "strcmp",
                "putc",
                "FUN_00106530"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103463",
            "calling": [
                "FUN_00105110"
            ],
            "imported": false,
            "current_name": "find_and_print_matching_records_00103463"
        },
        "bfd_target_list": {
            "renaming": {},
            "code": "\nvoid bfd_target_list(void)\n\n{\n  bfd_target_list();\n  return;\n}\n\n",
            "called": [
                "bfd_target_list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021c0",
            "calling": [
                "FUN_00103ca0"
            ],
            "imported": false,
            "current_name": "bfd_target_list"
        },
        "FUN_00104397": {
            "renaming": {
                "FUN_00104397": "initialize_pointer_00104397",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "count"
            },
            "code": "\nvoid initializePointer_00104397(undefined8 input1,undefined8 input2,int count)\n\n{\n  DAT_0010b7c0 = count;\n  PTR_PTR_FUN_0010b260 = (undefined *)(&PTR_FUN_0010ace0 + (long)count * 5);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104397",
            "calling": [
                "caseD_4a",
                "FUN_00104370"
            ],
            "imported": false,
            "current_name": "initialize_pointer_00104397"
        },
        "bfd_canonicalize_reloc": {
            "renaming": {},
            "code": "\nvoid bfd_canonicalize_reloc(void)\n\n{\n  bfd_canonicalize_reloc();\n  return;\n}\n\n",
            "called": [
                "bfd_canonicalize_reloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023a0",
            "calling": [
                "FUN_00103c00"
            ],
            "imported": false,
            "current_name": "bfd_canonicalize_reloc"
        },
        "free": {
            "renaming": {},
            "code": "\n\n\nvoid free(void *__ptr)\n\n{\n  free(__ptr);\n  return;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102040",
            "calling": [
                "FUN_001047d0",
                "FUN_00103729",
                "FUN_001055f0",
                "FUN_00103ca0",
                "FUN_0010268b",
                "FUN_00103b5d",
                "FUN_00104d5b",
                "FUN_00103238",
                "FUN_00104670",
                "FUN_00105110"
            ],
            "imported": false,
            "current_name": "free"
        },
        "xexit": {
            "renaming": {},
            "code": "\nvoid xexit(void)\n\n{\n  xexit();\n  return;\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102350",
            "calling": [
                "FUN_001055f0",
                "FUN_00106300",
                "FUN_00106530"
            ],
            "imported": false,
            "current_name": "xexit"
        },
        "FUN_00104670": {
            "renaming": {
                "FUN_00104670": "resolve_architecture_size_00104670",
                "param_1": "binaryData",
                "iVar1": "architectureSize",
                "pcVar2": "architectureString",
                "puVar3": "stringResult",
                "pcVar4": "substringResult"
            },
            "code": "\nvoid resolveArchitectureSize_00104670(long binaryData)\n\n{\n  int architectureSize;\n  char *architectureString;\n  undefined *stringResult;\n  char *substringResult;\n  \n  DAT_0010b7a8 = bfd_get_arch_size();\n  if (DAT_0010b7a8 == -1) {\n    substringResult = **(char ***)(binaryData + 8);\n    architectureString = strstr(substringResult,\"64\");\n    architectureSize = 0x40;\n    if (architectureString == (char *)0x0) {\n      architectureSize = strcmp(substringResult,\"mmo\");\n      architectureSize = (-(uint)(architectureSize == 0) & 0x20) + 0x20;\n    }\n    DAT_0010b7a8 = architectureSize;\n    free(DAT_0010b7a0);\n  }\n  else {\n    free(DAT_0010b7a0);\n  }\n  if (DAT_0010b7c0 - 2U < 2) {\n    substringResult = \"\";\n  }\n  else if (DAT_0010b7a8 == 0x20) {\n    substringResult = \"08\";\n  }\n  else {\n    substringResult = \"016\";\n  }\n  stringResult = &DAT_001071d0;\n  if (DAT_0010b244 != 0x10) {\n    if (DAT_0010b244 < 0x11) {\n      if (DAT_0010b244 == 8) {\n        stringResult = &DAT_001071ca;\n      }\n      else {\n        if (DAT_0010b244 != 10) {\n          DAT_0010b7a0 = (void *)concat(&DAT_001071d7,substringResult,0,0);\n          return;\n        }\n        stringResult = &DAT_001071cd;\n      }\n    }\n    else {\n      stringResult = (undefined *)0x0;\n    }\n  }\n  DAT_0010b7a0 = (void *)concat(&DAT_001071d7,substringResult,stringResult,0);\n  return;\n}\n\n",
            "called": [
                "strcmp",
                "concat",
                "bfd_get_arch_size",
                "free",
                "FUN_001025f5",
                "strstr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104670",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "resolve_architecture_size_00104670"
        },
        "reconcat": {
            "renaming": {},
            "code": "\nvoid reconcat(void)\n\n{\n  reconcat();\n  return;\n}\n\n",
            "called": [
                "reconcat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102060",
            "calling": [
                "FUN_001047d0"
            ],
            "imported": false,
            "current_name": "reconcat"
        },
        "asprintf": {
            "renaming": {},
            "code": "\n\n\nint asprintf(char **__ptr,char *__fmt,...)\n\n{\n  int iVar1;\n  \n  iVar1 = asprintf(__ptr,__fmt);\n  return iVar1;\n}\n\n",
            "called": [
                "asprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022e0",
            "calling": [
                "FUN_00103729"
            ],
            "imported": false,
            "current_name": "asprintf"
        },
        "fopen": {
            "renaming": {},
            "code": "\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 = fopen(__filename,__modes);\n  return pFVar1;\n}\n\n",
            "called": [
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102340",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "fopen"
        },
        "stat": {
            "renaming": {},
            "code": "\n\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = stat(__file,__buf);\n  return iVar1;\n}\n\n",
            "called": [
                "stat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102280",
            "calling": [
                "FUN_001055f0",
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "stat"
        },
        "getopt_long": {
            "renaming": {},
            "code": "\nvoid getopt_long(void)\n\n{\n  getopt_long();\n  return;\n}\n\n",
            "called": [
                "getopt_long"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102170",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "getopt_long"
        },
        "xstrdup": {
            "renaming": {},
            "code": "\nvoid xstrdup(void)\n\n{\n  xstrdup();\n  return;\n}\n\n",
            "called": [
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102200",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "xstrdup"
        },
        "FUN_00103a78": {
            "renaming": {
                "FUN_00103a78": "print_error_message_00103a78",
                "unaff_RBX": "errorFlag",
                "unaff_retaddr": "returnAddress",
                "uVar1": "errorMessage",
                "_stdout": "standardOutput",
                "_stderr": "standardError",
                "dcgettext": "getLocalizedErrorMessage",
                "fflush": "flushOutput",
                "fprintf": "printFormatted"
            },
            "code": "\n\n\nvoid printErrorMessage_00103a78(void)\n\n{\n  undefined8 errorMessage;\n  long errorFlag;\n  undefined8 returnAddress;\n  \n  errorMessage = dcgettext(0,\"cause of error unknown\",5);\n  fflush(standardOutput);\n  if (errorFlag != 0) {\n    fprintf(standardError,\"%s: %s: %s\\n\",DAT_0010b820);\n    return;\n  }\n  fprintf(standardError,\"%s: %s\\n\",DAT_0010b820,errorMessage,returnAddress);\n  return;\n}\n\n",
            "called": [
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103a78",
            "calling": [
                "FUN_00106540"
            ],
            "imported": false,
            "current_name": "print_error_message_00103a78"
        },
        "FUN_001048e0": {
            "renaming": {
                "FUN_001048e0": "FUNC_001048e0"
            },
            "code": "\n\n\nvoid FUNC_001048e0(ulong **param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 ulong **param_5,ulong **param_6)\n\n{\n  byte bVar1;\n  code *pcVar2;\n  char cVar3;\n  int iVar4;\n  uint uVar5;\n  undefined8 uVar6;\n  long lVar7;\n  ulong **ppuVar8;\n  ulong **ppuVar9;\n  long lVar10;\n  ulong *puVar11;\n  ulong **unaff_RBX;\n  ulong **ppuVar12;\n  ulong **ppuVar13;\n  ulong **unaff_RBP;\n  ulong **ppuVar14;\n  ulong **ppuVar15;\n  ulong **ppuVar16;\n  ulong **ppuVar17;\n  ulong **ppuVar18;\n  ulong **unaff_R14;\n  ulong **unaff_R15;\n  bool bVar19;\n  byte bVar20;\n  ulong **ppuStack_78;\n  uint local_4c;\n  ulong *local_48;\n  ulong **local_40 [2];\n  \n  bVar20 = 0;\n  local_48 = (ulong *)0x0;\n  if ((DAT_0010b80c != 0) || ((*(byte *)((long)param_1 + 0x44) & 0x10) != 0)) {\n    ppuVar9 = (ulong **)&local_4c;\n    ppuVar8 = (ulong **)(*(code *)param_1[1][0x4d])(param_1,DAT_0010b80c != 0,local_40);\n    if ((long)ppuVar8 < 0) {\n      if ((DAT_0010b80c != 0) && (iVar4 = bfd_get_error(), iVar4 == 7)) {\n        if (_DAT_0010b810 != 0) {\n          return;\n        }\n        puVar11 = *param_1;\n        uVar6 = dcgettext(0,\"%s: no symbols\",5);\n        FUN_00106400(uVar6,puVar11);\n        return;\n      }\n      FUN_00106530(*param_1);\n      goto LAB_00102e9e;\n    }\n    if (ppuVar8 != (ulong **)0x0) {\n      if (DAT_0010b788 != 0) {\n        if (local_4c == 8) goto LAB_00102d06;\n        goto LAB_00102cc2;\n      }\n      bVar1 = *(byte *)((long)param_1 + 0x4a);\n      ppuVar13 = param_1;\n      do {\n        if ((bVar1 & 0x10) != 0) {\n          unaff_RBX = (ulong **)*ppuVar13;\n          DAT_0010b230 = '\\0';\n          uVar6 = dcgettext(0,\"%s: plugin needed to handle lto object\",5);\n          FUN_00106400(uVar6);\n        }\n        ppuVar14 = local_40[0];\n        unaff_R14 = (ulong **)(ulong)local_4c;\n        bVar19 = DAT_0010b80c != 0;\n        ppuVar9 = local_40[0];\n        unaff_R15 = (ulong **)(*(code *)ppuVar13[1][0x41])(ppuVar13);\n        ppuVar12 = unaff_RBX;\n        unaff_RBP = (ulong **)(ulong)bVar19;\n        param_1 = ppuVar13;\n        if (unaff_R15 == (ulong **)0x0) goto LAB_00102ea7;\n        ppuVar17 = (ulong **)((long)ppuVar8 * (long)unaff_R14);\n        ppuVar8 = (ulong **)((long)ppuVar14 + (long)ppuVar17);\n        param_1 = ppuVar14;\n        ppuVar12 = ppuVar14;\njoined_r0x001049a4:\n        if (param_1 < ppuVar8) {\n          do {\n            ppuVar9 = (ulong **)(*(code *)ppuVar13[1][0x4e])(ppuVar13,bVar19,param_1,unaff_R15);\n            ppuVar17 = unaff_R15;\n            if (ppuVar9 == (ulong **)0x0) goto LAB_00102eb0;\n            puVar11 = ppuVar9[1];\n            ppuVar17 = ppuVar8;\n            if (((puVar11 == (ulong *)0x0) || (*(char *)puVar11 != '_')) ||\n               (*(char *)((long)puVar11 + 1) != '_')) {\nLAB_00104a03:\n              if (DAT_0010b7e8 == 0) goto LAB_00104a11;\nLAB_00104ae2:\n              uVar5 = (uint)(ppuVar9[4] == (ulong *)0x10c2a8);\nLAB_00104af9:\n              if (uVar5 == 0) goto code_r0x00104b01;\nLAB_00104a2d:\n              if (DAT_0010b81c == 0) {\n                if ((*(byte *)(ppuVar9 + 3) & 4) == 0) {\n                  if (DAT_0010b7f8 != 0) goto FUN_00104d5b;\nLAB_00104a53:\n                  param_6 = (ulong **)(ulong)DAT_0010b7e4;\n                  if (DAT_0010b7e4 == 0) {\n                    cVar3 = (*(code *)ppuVar13[1][0x46])(ppuVar13,ppuVar9);\n                    if (cVar3 != '\\0') {\n                      FUN_00102c19();\n                      return;\n                    }\n                    goto LAB_00104a7b;\n                  }\n                  if (ppuVar9[4] != (ulong *)0x10c2a8) goto LAB_00104cba;\n                }\n              }\n              else {\n                if (DAT_0010b7f8 == 0) goto LAB_00104a53;\nFUN_00104d5b:\n                if ((ppuVar9[4] == (ulong *)0x10c2a8) || (ppuVar9[4] == (ulong *)0x10c3c0))\n                goto LAB_001049c3;\nLAB_00104cba:\n                cVar3 = (*(code *)ppuVar13[1][0x46])(ppuVar13,ppuVar9);\n                if (cVar3 != '\\0') {\n                  FUN_00102c19();\n                  return;\n                }\nLAB_00104a7b:\n                if (ppuVar12 != param_1) {\n                  if (unaff_R14 == (ulong **)0x8) {\n                    *ppuVar12 = *param_1;\n                    FUN_001049c0();\n                    return;\n                  }\n                  for (; unaff_R14 != (ulong **)0x0; unaff_R14 = (ulong **)((long)unaff_R14 + -1)) {\n                    *(undefined *)ppuVar12 = *(undefined *)param_1;\n                    param_1 = (ulong **)((long)param_1 + (ulong)bVar20 * -2 + 1);\n                    ppuVar12 = (ulong **)((long)ppuVar12 + (ulong)bVar20 * -2 + 1);\n                  }\n                  FUN_001049c0();\n                  return;\n                }\n                ppuVar12 = (ulong **)((long)ppuVar12 + (long)unaff_R14);\n              }\n            }\n            else {\n              iVar4 = strcmp((char *)((long)puVar11 + (ulong)(*(char *)((long)puVar11 + 2) == '_')),\n                             \"__gnu_lto_slim\");\n              ppuStack_78 = ppuVar9;\n              if (iVar4 == 0) {\n                if (DAT_0010b230 != '\\0') {\n                  ppuStack_78 = (ulong **)*ppuVar13;\n                  DAT_0010b230 = '\\0';\n                  uVar6 = dcgettext(0,\"%s: plugin needed to handle lto object\",5);\n                  FUN_00106400(uVar6,ppuStack_78);\n                }\n                goto LAB_00104a03;\n              }\n              if (DAT_0010b7e8 != 0) goto LAB_00104ae2;\nLAB_00104a11:\n              if (DAT_0010b808 == 0) {\n                if (DAT_0010b7d8 != 0) {\n                  uVar5 = (*(uint *)(ppuVar9 + 3) >> 7 ^ 1) & 1;\n                  goto LAB_00104af9;\n                }\n                goto LAB_00104a2d;\n              }\n              if ((((*(uint *)(ppuVar9 + 3) & 0x800082) != 0) || (ppuVar9[4] == (ulong *)0x10c2a8))\n                 || ((*(byte *)((long)ppuVar9[4] + 0x25) & 0x10) != 0)) goto LAB_00104a2d;\n            }\nLAB_001049c3:\n            param_1 = (ulong **)((long)param_1 + (long)unaff_R14);\n            if (ppuVar8 <= param_1) break;\n          } while( true );\n        }\n        ppuVar12 = (ulong **)((long)ppuVar12 - (long)ppuVar14);\n        if (unaff_R14 == (ulong **)0x8) {\n          puVar11 = ppuVar13[1];\n          ppuVar14 = (ulong **)((long)ppuVar12 + 7);\n          if (-1 < (long)ppuVar12) {\n            ppuVar14 = ppuVar12;\n          }\n          param_5 = (ulong **)(ulong)DAT_0010b800;\n          pcVar2 = (code *)puVar11[0x41];\n          ppuVar14 = (ulong **)((long)ppuVar14 >> 3);\n        }\n        else {\n          ppuVar14 = (ulong **)((long)ppuVar12 / (long)unaff_R14);\n          puVar11 = ppuVar13[1];\n          pcVar2 = (code *)puVar11[0x41];\n        }\n        if (DAT_0010b800 != 0) goto LAB_00104be2;\n        DAT_0010b778 = DAT_0010b80c != 0;\n        DAT_0010b780 = ppuVar13;\n        DAT_0010b770 = (ulong **)(*pcVar2)(ppuVar13);\n        DAT_0010b768 = (ulong **)(*(code *)ppuVar13[1][0x41])(ppuVar13);\n        ppuVar12 = local_40[0];\n        if ((DAT_0010b770 != (ulong **)0x0) && (DAT_0010b768 != (ulong **)0x0)) {\n          ppuVar8 = (ulong **)(ulong)local_4c;\n          if (DAT_0010b7f8 != 0) {\n            bVar19 = DAT_0010b80c != 0;\n            qsort(local_40[0],(size_t)ppuVar14,(size_t)ppuVar8,FUN_00102fd2);\n            ppuVar17 = (ulong **)xmalloc((long)ppuVar14 << 4);\n            ppuVar18 = DAT_0010b770;\n            param_1 = DAT_0010b768;\n            unaff_R14 = (ulong **)((long)ppuVar14 * (long)ppuVar8 + (long)ppuVar12);\n            ppuVar9 = DAT_0010b770;\n            if (unaff_R14 <= ppuVar12) goto LAB_00102ec2;\n            param_6 = DAT_0010b768;\n            ppuVar14 = (ulong **)(*(code *)ppuVar13[1][0x4e])(ppuVar13,bVar19,ppuVar12);\n            param_5 = ppuVar8;\n            ppuStack_78 = ppuVar17;\n            if (ppuVar14 == (ulong **)0x0) goto LAB_00102eb9;\n            goto LAB_00104e35;\n          }\n          qsort(local_40[0],(size_t)ppuVar14,(size_t)ppuVar8,\n                (__compar_fn_t)(&PTR_FUN_0010acc0)[(long)DAT_0010b7f4 + (long)DAT_0010b7fc * 2]);\n          puVar11 = ppuVar13[1];\nLAB_00104be2:\n          param_1 = ppuVar13;\n          ppuVar18 = (ulong **)0x0;\n          goto LAB_00104be5;\n        }\n        FUN_00106530(*ppuVar13);\n        param_1 = ppuVar13;\n        ppuVar12 = unaff_R15;\n        while( true ) {\n          unaff_RBX = (ulong **)xmalloc();\n          ppuVar8 = (ulong **)(*(code *)param_1[1][0x6b])(param_1,unaff_RBX);\n          ppuVar9 = ppuVar17;\n          if (-1 < (long)ppuVar8) break;\n          ppuVar13 = (ulong **)*param_1;\n          ppuVar14 = (ulong **)FUN_00106530(ppuVar13,ppuVar17);\nLAB_00102dbe:\n          puVar11 = ppuVar14[2];\n          ppuVar9 = (ulong **)0x0;\nLAB_00102dc4:\n          puVar11 = (ulong *)((long)ppuVar8[8] - (long)puVar11);\n          ppuVar18 = param_1;\n          ppuVar15 = ppuVar12;\nLAB_00104ea7:\n          ppuVar14 = ppuVar9;\n          ppuVar12 = unaff_RBX;\n          param_1 = param_6;\n          if (puVar11 != (ulong *)0x0) {\n            *ppuVar17 = (ulong *)ppuVar15;\n            ppuVar17[1] = puVar11;\n            ppuVar17 = ppuVar17 + 2;\n          }\nLAB_00104e35:\n          param_6 = ppuVar18;\n          if (ppuVar12 < unaff_R14) goto code_r0x00104e3e;\n          ppuVar14 = (ulong **)((long)ppuVar17 - (long)ppuStack_78 >> 4);\n          qsort(ppuStack_78,(size_t)ppuVar14,0x10,FUN_00103533);\n          puVar11 = ppuVar13[1];\n          param_1 = ppuVar13;\n          ppuVar18 = ppuStack_78;\nLAB_00104be5:\n          unaff_RBX = local_40[0];\n          ppuVar8 = (ulong **)(ulong)DAT_0010b7f8;\n          unaff_R14 = (ulong **)(ulong)(DAT_0010b80c != 0);\n          if (DAT_0010b7f8 != 0) {\n            ppuVar17 = (ulong **)(*(code *)puVar11[0x41])(param_1);\n            if (ppuVar17 == (ulong **)0x0) goto LAB_00102ed2;\n            ppuVar12 = ppuVar18 + (long)ppuVar14 * 2;\n            ppuVar14 = ppuVar18;\n            goto LAB_00104ee9;\n          }\n          ppuVar8 = (ulong **)(ulong)local_4c;\n          unaff_R15 = (ulong **)(*(code *)puVar11[0x41])(param_1);\n          if (unaff_R15 != (ulong **)0x0) {\n            unaff_RBP = (ulong **)((long)ppuVar14 * (long)ppuVar8 + (long)unaff_RBX);\n            if (unaff_RBX < unaff_RBP) goto LAB_00104c38;\n            goto LAB_00104c75;\n          }\n          FUN_00106530(*param_1);\n          unaff_R15 = ppuVar18;\nLAB_00102d06:\n          ppuVar9 = ppuVar8;\n          if (DAT_0010b80c != 0) {\n            unaff_RBX = local_40[0];\n            ppuVar14 = (ulong **)0x0;\n            ppuVar17 = (ulong **)0x0;\n            break;\n          }\n          lVar10 = (*(code *)param_1[1][0x6a])(param_1);\n          ppuVar14 = local_40[0];\n          ppuVar17 = ppuVar8;\n          ppuVar12 = unaff_R15;\n          if (lVar10 < 1) {\n            ppuVar8 = (ulong **)0x0;\n            unaff_RBX = (ulong **)0x0;\n            break;\n          }\n        }\n        param_6 = &local_48;\n        param_5 = unaff_RBX;\n        lVar10 = (*(code *)param_1[1][0x6c])(param_1,ppuVar17,ppuVar14,ppuVar8);\n        ppuVar8 = ppuVar9;\n        if (0 < lVar10) {\n          ppuVar8 = (ulong **)((long)ppuVar9 + lVar10);\n          local_40[0] = (ulong **)xrealloc(local_40[0]);\n          lVar7 = 0;\n          do {\n            local_40[0][(long)ppuVar9 + lVar7] = local_48 + lVar7 * 6;\n            lVar7 = lVar7 + 1;\n          } while (lVar10 != lVar7);\n          local_40[0][(long)ppuVar9 + lVar10] = (ulong *)0x0;\n        }\n        if ((DAT_0010b80c == 0) && (unaff_RBX != (ulong **)0x0)) {\n          free(unaff_RBX);\n        }\nLAB_00102cc2:\n        bVar1 = *(byte *)((long)param_1 + 0x4a);\n        ppuVar13 = param_1;\n      } while( true );\n    }\n  }\n  if (_DAT_0010b810 == 0) {\n    puVar11 = *param_1;\n    uVar6 = dcgettext(0,\"%s: no symbols\",5);\n    FUN_00106400(uVar6,puVar11);\n  }\n  return;\ncode_r0x00104b01:\n  param_1 = (ulong **)((long)param_1 + (long)unaff_R14);\n  goto joined_r0x001049a4;\ncode_r0x00104e3e:\n  unaff_RBX = (ulong **)((long)ppuVar12 + (long)param_5);\n  if (unaff_R14 <= unaff_RBX) {\n    ppuVar8 = (ulong **)ppuVar14[4];\n    if ((*(uint *)(ppuVar14 + 3) & 0x200100) != 0) goto LAB_00102dbe;\n    ppuVar9 = (ulong **)0x0;\nLAB_00104e95:\n    ppuVar18 = param_1;\n    ppuVar15 = ppuVar12;\n    if (*(int *)(ppuVar13[1] + 1) == 5) {\n      puVar11 = ppuVar14[7];\n      goto LAB_00104ea7;\n    }\n    puVar11 = ppuVar14[2];\n    if ((*(byte *)((long)ppuVar8 + 0x25) & 0x10) != 0) goto LAB_00104ea7;\n    if (unaff_R14 <= unaff_RBX) goto LAB_00102dc4;\n    goto LAB_00102ee7;\n  }\n  ppuVar8 = param_1;\n  ppuVar15 = param_5;\n  ppuVar16 = param_6;\n  ppuVar9 = (ulong **)(*(code *)ppuVar13[1][0x4e])();\n  ppuVar18 = ppuVar12;\n  if (ppuVar9 == (ulong **)0x0) goto LAB_00102edb;\n  ppuVar8 = (ulong **)ppuVar14[4];\n  if ((*(uint *)(ppuVar14 + 3) & 0x200100) == 0) goto LAB_00104e95;\n  goto LAB_00102ee3;\nLAB_00104ee9:\n  if (ppuVar12 <= ppuVar14) {\nLAB_00104c75:\n    if (local_48 == (ulong *)0x0) {\n      free(local_40[0]);\n      free(ppuVar18);\n      return;\n    }\n    free(local_48);\n    free(local_40[0]);\n    free(ppuVar18);\n    return;\n  }\n  ppuVar8 = ppuVar17;\n  lVar10 = (*(code *)param_1[1][0x4e])(param_1,unaff_R14,*ppuVar14);\n  if (lVar10 == 0) goto LAB_00102ec9;\n  ppuVar8 = ppuVar14 + 1;\n  ppuVar14 = ppuVar14 + 2;\n  FUN_00105110(param_1,lVar10,*ppuVar8,param_2);\n  goto LAB_00104ee9;\nLAB_00102ec9:\n  FUN_00106530(*param_1,0);\nLAB_00102ed2:\n  ppuVar13 = (ulong **)*param_1;\n  FUN_00106530();\n  unaff_RBX = ppuVar12;\n  ppuVar15 = param_5;\n  ppuVar16 = param_6;\nLAB_00102edb:\n  param_6 = ppuVar16;\n  param_5 = ppuVar15;\n  ppuVar13 = (ulong **)*ppuVar13;\n  ppuVar9 = (ulong **)FUN_00106530();\n  ppuVar12 = ppuVar18;\nLAB_00102ee3:\n  puVar11 = ppuVar14[2];\nLAB_00102ee7:\n  if (ppuVar8 != (ulong **)ppuVar9[4]) goto LAB_00102dc4;\n  puVar11 = (ulong *)((long)ppuVar9[2] - (long)puVar11);\n  ppuVar18 = param_1;\n  ppuVar15 = ppuVar12;\n  goto LAB_00104ea7;\nLAB_00104c38:\n  while (ppuVar9 = unaff_R15, lVar10 = (*(code *)param_1[1][0x4e])(param_1,unaff_R14,unaff_RBX),\n        lVar10 != 0) {\n    unaff_RBX = (ulong **)((long)unaff_RBX + (long)ppuVar8);\n    FUN_00105110(param_1,lVar10,0,param_2);\n    if (unaff_RBP <= unaff_RBX) goto LAB_00104c75;\n  }\nLAB_00102e9e:\n  FUN_00106530(*param_1);\n  ppuVar12 = unaff_RBX;\nLAB_00102ea7:\n  ppuVar13 = unaff_RBP;\n  FUN_00106530(*param_1);\n  ppuVar17 = unaff_R15;\nLAB_00102eb0:\n  FUN_00106530(*ppuVar13);\n  ppuVar13 = param_1;\nLAB_00102eb9:\n  FUN_00106530(*ppuVar13);\n  param_1 = param_6;\nLAB_00102ec2:\n  ppuVar14 = (ulong **)0x0;\n  param_5 = ppuVar8;\n  ppuVar18 = ppuVar9;\n  ppuStack_78 = ppuVar17;\n  goto LAB_00104e35;\n}\n\n",
            "called": [
                "bfd_get_error",
                "dcgettext",
                "FUN_00106400",
                "FUN_00106530"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x001048e0",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "FUNC_001048e0"
        },
        "fprintf": {
            "renaming": {},
            "code": "\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = fprintf(__stream,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102260",
            "calling": [
                "FUN_00106540",
                "FUN_001063a0",
                "FUN_001055f0",
                "FUN_00103ca0",
                "FUN_00103b5d",
                "FUN_00102450"
            ],
            "imported": false,
            "current_name": "fprintf"
        },
        "memcpy": {
            "renaming": {},
            "code": "\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memcpy(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102290",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "memcpy"
        },
        "FUN_00105530": {
            "renaming": {
                "FUN_00105530": "FUNC_00105530"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00105543) */\n/* WARNING: Removing unreachable block (ram,0x0010554f) */\n\nvoid FUNC_00105530(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_deregisterTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00105530",
            "calling": [
                "_FINI_0"
            ],
            "imported": false,
            "current_name": "FUNC_00105530"
        },
        "FUN_00102020": {
            "renaming": {
                "FUN_00102020": "execute_indirect_jump_00102020"
            },
            "code": "\nvoid executeIndirectJump_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(undefined *)0x0)();\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102020",
            "calling": [],
            "imported": false,
            "current_name": "execute_indirect_jump_00102020"
        },
        "fflush": {
            "renaming": {},
            "code": "\n\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fflush(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022b0",
            "calling": [
                "FUN_00106540",
                "FUN_001063a0",
                "FUN_00103b5d"
            ],
            "imported": false,
            "current_name": "fflush"
        },
        "bfd_get_reloc_upper_bound": {
            "renaming": {},
            "code": "\nvoid bfd_get_reloc_upper_bound(void)\n\n{\n  bfd_get_reloc_upper_bound();\n  return;\n}\n\n",
            "called": [
                "bfd_get_reloc_upper_bound"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023f0",
            "calling": [
                "FUN_00103c00"
            ],
            "imported": false,
            "current_name": "bfd_get_reloc_upper_bound"
        },
        "FUN_001062d0": {
            "renaming": {
                "FUN_001062d0": "print_if_condition_met_001062d0",
                "param_1": "message"
            },
            "code": "\n\n\nvoid printIfConditionMet_001062d0(undefined8 message)\n\n{\n  if ((_DAT_0010b7c4 != 0) && (DAT_0010b818 == 0)) {\n    printf(\"\\n%s:\\n\",message);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001062d0",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "print_if_condition_met_001062d0"
        },
        "bfd_openr_next_archived_file": {
            "renaming": {},
            "code": "\nvoid bfd_openr_next_archived_file(void)\n\n{\n  bfd_openr_next_archived_file();\n  return;\n}\n\n",
            "called": [
                "bfd_openr_next_archived_file"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023e0",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "bfd_openr_next_archived_file"
        },
        "caseD_4a": {
            "renaming": {},
            "code": "\nvoid switchD_00104393::caseD_4a(undefined8 param_1,undefined8 param_2)\n\n{\n  FUN_00104397(param_1,param_2,3);\n  return;\n}\n\n",
            "called": [
                "FUN_00104397"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102475",
            "calling": [
                "FUN_00104370"
            ],
            "imported": false,
            "current_name": "caseD_4a"
        },
        "FUN_00103238": {
            "renaming": {
                "FUN_00103238": "reverse_and_print_00103238",
                "plVar1": "pointerVar",
                "__ptr": "pointer",
                "__s1": "stringVar",
                "lVar2": "longVar",
                "cVar3": "charVar",
                "iVar4": "intVar",
                "unaff_RBX": "registerBX",
                "pvVar5": "pointerVar2",
                "uVar6": "counter",
                "unaff_R13": "registerR13",
                "lVar7": "longVar2",
                "param_10": "parameter10",
                "param_12": "parameter12"
            },
            "code": "\n\n\nvoid reverseAndPrint_00103238(void)\n\n{\n  long *pointerVar;\n  void *pointer;\n  char *stringVar;\n  long longVar;\n  char charVar;\n  int intVar;\n  long registerBX;\n  void *pointerVar2;\n  uint counter;\n  long registerR13;\n  long longVar2;\n  ulong parameter10;\n  void *parameter12;\n  \n  pointerVar2 = DAT_0010b750;\n  if (_DAT_0010b7b0 == registerR13) {\n    if (DAT_0010b750 != (void *)0x0) goto LAB_00103296;\n  }\n  else {\n    counter = 0;\n    if (DAT_0010b750 != (void *)0x0) {\n      for (; counter < DAT_0010b748; counter = counter + 1) {\n        pointer = *(void **)((long)pointerVar2 + (ulong)counter * 8);\n        if (pointer != (void *)0x0) {\n          free(pointer);\n        }\n      }\n      free(DAT_0010b740);\n      free(pointerVar2);\n      free(DAT_0010b738);\n      DAT_0010b740 = (void *)0x0;\n      DAT_0010b750 = (void *)0x0;\n      DAT_0010b738 = (void *)0x0;\n    }\n  }\n  DAT_0010b748 = *(uint *)(registerR13 + 0xa0);\n  DAT_0010b740 = (void *)xmalloc((ulong)DAT_0010b748 * 8);\n  DAT_0010b750 = (void *)xmalloc((ulong)DAT_0010b748 << 3);\n  DAT_0010b738 = (void *)xmalloc((ulong)DAT_0010b748 << 3);\n  parameter12 = DAT_0010b740;\n  bfd_map_over_sections();\n  _DAT_0010b7b0 = registerR13;\nLAB_00103296:\n  stringVar = *(char **)(registerBX + 8);\n  counter = 0;\n  do {\n    if (DAT_0010b748 <= counter) {\n      putc(10,_stdout);\n      return;\n    }\n    pointerVar2 = DAT_0010b738;\n    for (longVar2 = 0; pointerVar = (long *)((long)pointerVar2 + (ulong)counter * 8),\n        *pointerVar != longVar2 && longVar2 <= *pointerVar; longVar2 = longVar2 + 1) {\n      pointerVar = **(long ***)(*(long *)((long)DAT_0010b750 + (ulong)counter * 8) + longVar2 * 8);\n      if ((((pointerVar != (long *)0x0) &&\n           (longVar = *pointerVar, *(long *)(longVar + 0x20) == *(long *)(registerBX + 0x20))) &&\n          (*(long *)(longVar + 0x10) == *(long *)(registerBX + 0x10))) &&\n         (((intVar = strcmp(stringVar,*(char **)(longVar + 8)), intVar == 0 &&\n           (charVar = (**(code **)(*(long *)(registerR13 + 8) + 0x240))(), pointerVar2 = DAT_0010b738,\n           charVar != '\\0')) && (parameter12 != (void *)0x0)))) {\n        printf(\"\\t%s:%u\",parameter12,parameter10 >> 0x20);\n        counter = DAT_0010b748;\n        break;\n      }\n    }\n    counter = counter + 1;\n  } while( true );\n}\n\n",
            "called": [
                "bfd_map_over_sections",
                "FUN_00103c00",
                "xmalloc",
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103238",
            "calling": [
                "FUN_00105110"
            ],
            "imported": false,
            "current_name": "reverse_and_print_00103238"
        },
        "FUN_001036e0": {
            "renaming": {
                "FUN_001036e0": "print_formatted_string_001036e0",
                "param_1": "message",
                "param_2": "defaultMessage"
            },
            "code": "\nvoid printFormattedString_001036e0(undefined8 *message,undefined8 *defaultMessage)\n\n{\n  if (message != (undefined8 *)0x0) {\n    printf(\"%s[%s]: \",*message);\n    return;\n  }\n  printf(\"%s: \",*defaultMessage);\n  return;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001036e0",
            "calling": [
                "FUN_001064a0"
            ],
            "imported": false,
            "current_name": "print_formatted_string_001036e0"
        },
        "FUN_001047d0": {
            "renaming": {
                "FUN_001047d0": "print_and_free_memory_001047d0",
                "unaff_RBX": "reconcat_result",
                "unaff_R12": "output_flag",
                "unaff_R13": "concatenated_string",
                "unaff_R14": "format_string",
                "unaff_R15": "function_context",
                "pcVar1": "result_string"
            },
            "code": "\nvoid print_and_free_memory_001047d0(void)\n\n{\n  char *result_string;\n  void *reconcat_result;\n  undefined *output_flag;\n  void *concatenated_string;\n  char *format_string;\n  long function_context;\n  \n  if (((DAT_0010b234 != 0) &&\n      (result_string = (char *)(**(code **)(*(long *)(function_context + 8) + 0x220))(), result_string != (char *)0x0))\n     && (*result_string != '\\0')) {\n    reconcat_result = (void *)reconcat();\n    concatenated_string = reconcat_result;\n  }\n  printf(format_string,concatenated_string);\n  if (output_flag != (undefined *)0x0) {\n    *output_flag = 0x40;\n  }\n  free(reconcat_result);\n  return;\n}\n\n",
            "called": [
                "printf",
                "reconcat",
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047d0",
            "calling": [
                "FUN_0010268b",
                "FUN_00102739"
            ],
            "imported": false,
            "current_name": "print_and_free_memory_001047d0"
        },
        "FUN_0010249f": {
            "renaming": {
                "FUN_0010249f": "display_non_ordinary_file_warning_0010249f",
                "uVar1": "warningMessage",
                "dcgettext": "getTranslatedString"
            },
            "code": "\nundefined8 displayNonOrdinaryFileWarning_0010249f(void)\n\n{\n  undefined8 warningMessage;\n  \n  warningMessage = dcgettext(0,\"Warning: \\'%s\\' is not an ordinary file\",5);\n  FUN_00106400(warningMessage);\n  return 0;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00106400"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010249f",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "display_non_ordinary_file_warning_0010249f"
        },
        "FUN_001043d0": {
            "renaming": {
                "FUN_001043d0": "check_file_001043d0",
                "param_1": "fileName",
                "cVar1": "formatMatch",
                "iVar2": "result",
                "uVar3": "returnValue",
                "piVar4": "errnoLocation",
                "uVar5": "errorMessage",
                "puVar6": "fileDescriptor",
                "lVar7": "nextMapent",
                "pcVar8": "errorReason",
                "puVar9": "archivedFile1",
                "puVar10": "archivedFile2",
                "local_c8": "fileStat"
            },
            "code": "\n\n\nundefined4 checkFile_001043d0(char *fileName)\n\n{\n  char formatMatch;\n  int result;\n  undefined4 returnValue;\n  int *errnoLocation;\n  undefined8 errorMessage;\n  undefined8 *fileDescriptor;\n  long nextMapent;\n  char *errorReason;\n  undefined8 *archivedFile1;\n  undefined8 *archivedFile2;\n  stat fileStat;\n  \n  if (fileName != (char *)0x0) {\n    result = stat(fileName,&fileStat);\n    if (result < 0) {\nLAB_00102522:\n      errnoLocation = __errno_location();\n      if (*errnoLocation == 2) {\n        errorMessage = dcgettext(0,\"\\'%s\\': No such file\",5);\n        FUN_00106400(errorMessage,fileName);\n      }\n      else {\n        errorReason = strerror(*errnoLocation);\n        errorMessage = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n        FUN_00106400(errorMessage,fileName,errorReason);\n      }\n    }\n    else if ((fileStat.st_mode & 0xf000) == 0x4000) {\n      errorMessage = dcgettext(0,\"Warning: \\'%s\\' is a directory\",5);\n      FUN_00106400(errorMessage,fileName);\n    }\n    else if ((fileStat.st_mode & 0xf000) == 0x8000) {\n      if (fileStat.st_size < 0) {\n        errorMessage = dcgettext(0,\"Warning: \\'%s\\' has negative size, probably it is too large\",5);\n        FUN_00106400(errorMessage,fileName);\n      }\n      else if (fileStat.st_size != 0) {\n        if (DAT_0010b7d0 == 0) {\n          fileDescriptor = (undefined8 *)bfd_openr(fileName,\"plugin\");\n        }\n        else {\n          fileDescriptor = (undefined8 *)bfd_openr(fileName);\n        }\n        if (fileDescriptor != (undefined8 *)0x0) {\n          if (DAT_0010b804 != 0) {\n            *(uint *)((long)fileDescriptor + 0x44) = *(uint *)((long)fileDescriptor + 0x44) | 0x8000;\n          }\n          formatMatch = bfd_check_format(fileDescriptor,2);\n          if (formatMatch == '\\0') {\n            returnValue = bfd_check_format_matches(fileDescriptor,1,&fileStat);\n            if ((char)returnValue == '\\0') goto LAB_001025ac;\n            FUN_00104670(fileDescriptor);\n            (**(code **)PTR_PTR_FUN_0010b260)(fileName);\n            FUNC_001048e0(fileDescriptor,0);\n          }\n          else {\n            (**(code **)(PTR_PTR_FUN_0010b260 + 8))(*fileDescriptor);\n            if ((_DAT_0010b7f0 != 0) &&\n               (nextMapent = bfd_get_next_mapent(fileDescriptor,0xffffffffffffffff,&fileStat), nextMapent != -1)) {\n              errorReason = (char *)dcgettext(0,\"\\nArchive index:\\n\",5);\n              printf(errorReason);\n              do {\n                archivedFile1 = (undefined8 *)(**(code **)(fileDescriptor[1] + 0x1e0))(fileDescriptor,nextMapent);\n                if (archivedFile1 == (undefined8 *)0x0) goto LAB_00102516;\n                if (*(long *)fileStat.st_dev != 0) {\n                  FUN_00104740(&DAT_0010712d,0,*(long *)fileStat.st_dev,fileDescriptor);\n                  printf(\" in %s\\n\",*archivedFile1);\n                }\n                nextMapent = bfd_get_next_mapent(fileDescriptor,nextMapent,&fileStat);\n              } while (nextMapent != -1);\n            }\n            archivedFile1 = (undefined8 *)0x0;\n            do {\n              do {\n                archivedFile2 = archivedFile1;\n                archivedFile1 = (undefined8 *)bfd_openr_next_archived_file(fileDescriptor,archivedFile2);\n                if (archivedFile1 == (undefined8 *)0x0) {\n                  result = bfd_get_error();\n                  if (result != 9) {\n                    FUN_00106530(*fileDescriptor);\nLAB_00102516:\n                    FUN_00106530(\"bfd_get_elt_at_index\");\n                    goto LAB_00102522;\n                  }\n                  if (archivedFile2 != (undefined8 *)0x0) {\n                    bfd_close(archivedFile2);\n                    _DAT_0010b7b8 = 0;\n                    _DAT_0010b7b0 = 0;\n                  }\n                  goto LAB_001044b4;\n                }\n                formatMatch = bfd_check_format_matches(archivedFile1,1,&fileStat);\n                if (formatMatch == '\\0') {\n                  FUN_00106540(*archivedFile1);\n                  result = bfd_get_error();\n                  if (result == 0xd) {\n                    FUN_00103b5d(fileStat.st_dev);\n                  }\n                }\n                else {\n                  FUN_00104670(archivedFile1);\n                  (**(code **)(PTR_PTR_FUN_0010b260 + 0x10))(*fileDescriptor,*archivedFile1);\n                  FUNC_001048e0(archivedFile1,fileDescriptor);\n                }\n              } while (archivedFile2 == (undefined8 *)0x0);\n              bfd_close(archivedFile2);\n              _DAT_0010b7b8 = 0;\n              _DAT_0010b7b0 = 0;\n            } while (archivedFile2 != archivedFile1);\n          }\nLAB_001044b4:\n          returnValue = 1;\n          while (formatMatch = bfd_close(fileDescriptor), formatMatch == '\\0') {\n            FUN_00106530(fileName);\nLAB_001025ac:\n            FUN_00106540(fileName);\n            result = bfd_get_error();\n            if (result == 0xd) {\n              FUN_00103b5d(fileStat.st_dev);\n            }\n          }\n          _DAT_0010b7b0 = 0;\n          _DAT_0010b7b8 = 0;\n          return returnValue;\n        }\n        FUN_00106540(fileName);\n      }\n    }\n    else {\n      errorMessage = dcgettext(0,\"Warning: \\'%s\\' is not an ordinary file\",5);\n      FUN_00106400(errorMessage,fileName);\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "printf",
                "FUN_00106540",
                "FUN_0010351b",
                "bfd_get_next_mapent",
                "FUN_00103b5d",
                "bfd_openr",
                "FUN_0010249f",
                "FUN_00106400",
                "bfd_check_format",
                "bfd_openr_next_archived_file",
                "FUN_00104740",
                "bfd_check_format_matches",
                "bfd_get_error",
                "FUN_001062d0",
                "dcgettext",
                "bfd_close",
                "strerror",
                "FUN_00104670",
                "FUN_001048e0",
                "stat",
                "__errno_location",
                "FUN_00102670",
                "FUN_00106530"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043d0",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "check_file_001043d0"
        },
        "isatty": {
            "renaming": {},
            "code": "\n\n\nint isatty(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = isatty(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "isatty"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020c0",
            "calling": [
                "FUN_0010268b"
            ],
            "imported": false,
            "current_name": "isatty"
        },
        "bfd_demangle": {
            "renaming": {},
            "code": "\nvoid bfd_demangle(void)\n\n{\n  bfd_demangle();\n  return;\n}\n\n",
            "called": [
                "bfd_demangle"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102320",
            "calling": [
                "FUN_00102739"
            ],
            "imported": false,
            "current_name": "bfd_demangle"
        },
        "sprintf": {
            "renaming": {},
            "code": "\n\n\nint sprintf(char *__s,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = sprintf(__s,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023b0",
            "calling": [
                "FUN_0010268b"
            ],
            "imported": false,
            "current_name": "sprintf"
        },
        "_INIT_0": {
            "renaming": {},
            "code": "\nvoid _INIT_0(void)\n\n{\n  FUNC_00105560();\n  return;\n}\n\n",
            "called": [
                "FUN_00105560"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001055e0",
            "calling": [],
            "imported": false,
            "current_name": "_INIT_0"
        },
        "strlen": {
            "renaming": {},
            "code": "\n\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(__s);\n  return sVar1;\n}\n\n",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102160",
            "calling": [
                "FUN_001055f0",
                "FUN_00103ca0",
                "FUN_0010268b",
                "FUN_00102fd2"
            ],
            "imported": false,
            "current_name": "strlen"
        },
        "bfd_map_over_sections": {
            "renaming": {},
            "code": "\nvoid bfd_map_over_sections(void)\n\n{\n  bfd_map_over_sections();\n  return;\n}\n\n",
            "called": [
                "bfd_map_over_sections"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102400",
            "calling": [
                "FUN_00103238"
            ],
            "imported": false,
            "current_name": "bfd_map_over_sections"
        },
        "FUN_001025f5": {
            "renaming": {
                "FUN_001025f5": "concatenate_strings_001025f5",
                "param_1": "string_1",
                "param_2": "string_2"
            },
            "code": "\nvoid concatenate_strings_001025f5(undefined8 string_1,undefined8 string_2)\n\n{\n  DAT_0010b7a0 = concat(&DAT_001071d7,string_2,&DAT_001071ca,0);\n  return;\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001025f5",
            "calling": [
                "FUN_00104670"
            ],
            "imported": false,
            "current_name": "concatenate_strings_001025f5"
        },
        "FUN_00102670": {
            "renaming": {
                "FUN_00102670": "print_message_if_condition_true_00102670",
                "param_1": "message"
            },
            "code": "\n\n\nvoid printMessageIfConditionTrue_00102670(undefined8 message)\n\n{\n  if (_DAT_0010b7c4 != 0) {\n    printf(\"\\n%s:\\n\",message);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102670",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "print_message_if_condition_true_00102670"
        },
        "bfd_plugin_set_plugin": {
            "renaming": {},
            "code": "\nvoid bfd_plugin_set_plugin(void)\n\n{\n  bfd_plugin_set_plugin();\n  return;\n}\n\n",
            "called": [
                "bfd_plugin_set_plugin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102090",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "bfd_plugin_set_plugin"
        },
        "__errno_location": {
            "renaming": {},
            "code": "\n\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = __errno_location();\n  return piVar1;\n}\n\n",
            "called": [
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102080",
            "calling": [
                "FUN_00103729",
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "__errno_location"
        },
        "xrealloc": {
            "renaming": {},
            "code": "\nvoid xrealloc(void)\n\n{\n  xrealloc();\n  return;\n}\n\n",
            "called": [
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021a0",
            "calling": [
                "FUN_001055f0",
                "FUN_00104d5b"
            ],
            "imported": false,
            "current_name": "xrealloc"
        },
        "xmalloc_set_program_name": {
            "renaming": {},
            "code": "\nvoid xmalloc_set_program_name(void)\n\n{\n  xmalloc_set_program_name();\n  return;\n}\n\n",
            "called": [
                "xmalloc_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021f0",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "xmalloc_set_program_name"
        },
        "strcmp": {
            "renaming": {},
            "code": "\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = strcmp(__s1,__s2);\n  return iVar1;\n}\n\n",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102240",
            "calling": [
                "FUN_001055f0",
                "FUN_00103463",
                "FUN_00104d5b",
                "FUN_00104670"
            ],
            "imported": false,
            "current_name": "strcmp"
        },
        "FUN_00103ab9": {
            "renaming": {
                "FUN_00103ab9": "FUNC_00103ab9"
            },
            "code": "\nvoid FUNC_00103ab9(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00103ab9",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_00103ab9"
        },
        "_DT_FINI": {
            "renaming": {},
            "code": "\nvoid _DT_FINI(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001065a0",
            "calling": [],
            "imported": false,
            "current_name": "_DT_FINI"
        },
        "FUN_00104fa0": {
            "renaming": {
                "FUN_00104fa0": "compare_strings_00104fa0",
                "param_1": "string1",
                "param_2": "string2",
                "__s2": "string2_ptr",
                "__s1": "string1_ptr",
                "uVar1": "comparison_result",
                "lVar2": "string1_length",
                "lVar3": "string2_length"
            },
            "code": "\nuint compare_strings_00104fa0(undefined8 string1,undefined8 string2)\n\n{\n  char *string2_ptr;\n  char *string1_ptr;\n  uint comparison_result;\n  long string1_length;\n  long string2_length;\n  \n  string1_length = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,DAT_0010b778,string1,DAT_0010b770);\n  string2_length = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,DAT_0010b778,string2,DAT_0010b768);\n  if ((string1_length == 0) || (string2_length == 0)) {\n    FUN_00106530(*DAT_0010b780);\n  }\n  else {\n    string2_ptr = *(char **)(string2_length + 8);\n    string1_ptr = *(char **)(string1_length + 8);\n    if (string2_ptr == (char *)0x0) {\n      return (uint)(string1_ptr != (char *)0x0);\n    }\n    if (string1_ptr != (char *)0x0) {\n      if (*string2_ptr == '\\0') {\n        return (uint)(*string1_ptr != '\\0');\n      }\n      if (*string1_ptr == '\\0') {\n        return 0xffffffff;\n      }\n      comparison_result = strcoll(string1_ptr,string2_ptr);\n      return comparison_result;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "called": [
                "strcoll",
                "FUN_00102f9f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104fa0",
            "calling": [
                "FUN_00103bf6",
                "FUN_00105050",
                "FUN_00102fd2"
            ],
            "imported": false,
            "current_name": "compare_strings_00104fa0"
        },
        "bfd_is_undefined_symclass": {
            "renaming": {},
            "code": "\nvoid bfd_is_undefined_symclass(void)\n\n{\n  bfd_is_undefined_symclass();\n  return;\n}\n\n",
            "called": [
                "bfd_is_undefined_symclass"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020f0",
            "calling": [
                "FUN_00103729",
                "FUN_001053c0",
                "FUN_001064b0"
            ],
            "imported": false,
            "current_name": "bfd_is_undefined_symclass"
        },
        "FUN_001064a0": {
            "renaming": {
                "FUN_001064a0": "print_message_001064a0",
                "param_1": "header",
                "param_2": "message"
            },
            "code": "\nvoid printMessage_001064a0(undefined8 *header,undefined8 *message)\n\n{\n  if (DAT_0010b818 == 0) {\n    return;\n  }\n  if (header != (undefined8 *)0x0) {\n    printf(\"%s[%s]: \",*header);\n    return;\n  }\n  printf(\"%s: \",*message);\n  return;\n}\n\n",
            "called": [
                "FUN_001036e0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001064a0",
            "calling": [],
            "imported": false,
            "current_name": "print_message_001064a0"
        },
        "FUN_001054d0": {
            "renaming": {
                "FUN_001054d0": "print_symbol_info_001054d0",
                "param_1": "symbol",
                "cVar1": "isUndefined",
                "uVar2": "type",
                "iVar3": "asprintfResult",
                "plVar4": "symbolInfo",
                "piVar5": "errnoLocation",
                "uVar6": "errorString",
                "lVar7": "infoAddress",
                "uVar8": "printWidth",
                "bVar9": "symbolClass",
                "uVar10": "temp",
                "pcVar11": "typeName"
            },
            "code": "\nvoid printSymbolInfo_001054d0(undefined8 symbol)\n\n{\n  char isUndefined;\n  ushort type;\n  int asprintfResult;\n  long *symbolInfo;\n  int *errnoLocation;\n  undefined8 errorString;\n  long infoAddress;\n  ulong printWidth;\n  byte symbolClass;\n  ulong temp;\n  char *typeName;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  \n  printWidth = (ulong)DAT_0010b7a8;\n  if ((DAT_0010b7a8 - 0x20 & 0xffffffdf) == 0) {\n    printf(DAT_0010b7a0,symbol);\n    return;\n  }\n  symbolInfo = (long *)dcgettext(0,\"Print width has not been initialized (%d)\",5);\n  temp = printWidth;\n  FUN_00106300(symbolInfo,printWidth);\n  FUN_00104740(\"%-20s|\",symbolInfo,0,temp,in_R8,in_R9,printWidth);\n  isUndefined = bfd_is_undefined_symclass((int)*(char *)(*symbolInfo + 8));\n  if (isUndefined == '\\0') {\n    printSymbolInfo_001054d0(*(undefined8 *)*symbolInfo);\n  }\n  else if (DAT_0010b7a8 == 0x20) {\n    printf(\"        \");\n  }\n  else {\n    printf(\"                \");\n  }\n  printf(\"|   %c  |\",(ulong)(uint)(int)*(char *)(*symbolInfo + 8));\n  if (*(char *)(*symbolInfo + 8) == '-') {\n    printf(\"%18s|  \",*(undefined8 *)(*symbolInfo + 0x20));\n    printf(&DAT_0010b23d,(ulong)(uint)(int)*(short *)(*symbolInfo + 0x1a));\n    goto LAB_00103a54;\n  }\n  if (symbolInfo[2] == 0) {\n    if (symbolInfo[3] != 0) {\n      infoAddress = *(long *)(symbolInfo[3] + 0x30);\n      isUndefined = *(char *)(infoAddress + 0x28);\n      if (isUndefined == 'g') goto LAB_00103983;\n      if (isUndefined == 'h') {\n        typeName = \"Line\";\n      }\n      else if (isUndefined == 'd') {\n        typeName = \"Block\";\n      }\n      else if (*(ushort *)(infoAddress + 0x26) == 0) {\n        typeName = \"None\";\n      }\n      else {\n        type = *(ushort *)(infoAddress + 0x26) >> 4 & 3;\n        if (type == 2) {\n          typeName = \"Function\";\n        }\n        else if (type == 3) {\n          typeName = \"Array\";\n        }\n        else {\n          if (type != 1) {\n            free(DAT_0010b730);\n            type = *(ushort *)(infoAddress + 0x26);\n            symbolClass = *(byte *)(infoAddress + 0x28);\n            typeName = (char *)dcgettext(0,\"<unknown>: %d/%d\",5);\n            asprintfResult = asprintf(&DAT_0010b730,typeName,(ulong)symbolClass,(ulong)type);\n            typeName = DAT_0010b730;\n            goto joined_r0x00103964;\n          }\n          typeName = \"Pointer\";\n        }\n      }\n      goto LAB_001039c0;\n    }\n    printf(\"                  |\");\n  }\n  else {\n    symbolClass = *(byte *)(symbolInfo[2] + 0x48) & 0xf;\n    switch(symbolClass) {\n    case 0:\n      typeName = \"NOTYPE\";\n      break;\n    case 1:\n      typeName = \"OBJECT\";\n      break;\n    case 2:\n      typeName = \"FUNC\";\n      break;\n    case 3:\n      typeName = \"SECTION\";\n      break;\n    case 4:\n      typeName = \"FILE\";\n      break;\n    case 5:\n      typeName = \"COMMON\";\n      break;\n    case 6:\n      typeName = \"TLS\";\n      break;\n    default:\n      free(DAT_0010b728);\n      typeName = \"<processor specific>: %d\";\n      if ((2 < symbolClass - 0xd) && (typeName = \"<OS specific>: %d\", 2 < symbolClass - 10)) {\n        typeName = \"<unknown>: %d\";\n      }\n      typeName = (char *)dcgettext(0,typeName,5);\n      asprintfResult = asprintf(&DAT_0010b728,typeName,(ulong)symbolClass);\n      typeName = DAT_0010b728;\njoined_r0x00103964:\n      if (asprintfResult < 0) {\n        errnoLocation = __errno_location();\n        errorString = xstrerror(*errnoLocation);\n        FUN_00106300(&DAT_0010712d,errorString);\nLAB_00103983:\n        typeName = \"File\";\n      }\n    }\nLAB_001039c0:\n    printf(\"%18s|\",typeName);\n  }\n  if (symbolInfo[2] == 0) {\n    if (symbolInfo[1] != 0) goto LAB_001039fb;\nLAB_00103a02:\n    if (DAT_0010b7a8 == 0x20) {\n      printf(\"        \");\n    }\n    else {\n      printf(\"                \");\n    }\n  }\n  else {\n    if (*(long *)(symbolInfo[2] + 0x38) == 0) goto LAB_00103a02;\nLAB_001039fb:\n    printSymbolInfo_001054d0();\n  }\n  infoAddress = symbolInfo[2];\n  if ((infoAddress != 0) || (infoAddress = symbolInfo[3], infoAddress != 0)) {\n    printf(\"|     |%s\",**(undefined8 **)(infoAddress + 0x20));\n    return;\n  }\nLAB_00103a54:\n  printf(\"|     |\");\n  return;\n}\n\n",
            "called": [
                "FUN_0010370a",
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001054d0",
            "calling": [
                "FUN_00103729",
                "FUN_001035a2",
                "FUN_001053c0",
                "FUN_001064b0",
                "FUN_0010651a"
            ],
            "imported": false,
            "current_name": "print_symbol_info_001054d0"
        },
        "cplus_demangle_name_to_style": {
            "renaming": {},
            "code": "\nvoid cplus_demangle_name_to_style(void)\n\n{\n  cplus_demangle_name_to_style();\n  return;\n}\n\n",
            "called": [
                "cplus_demangle_name_to_style"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102030",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "cplus_demangle_name_to_style"
        },
        "FUN_001053b0": {
            "renaming": {
                "FUN_001053b0": "print_data_with_prefix_001053b0",
                "param_1": "prefix",
                "param_2": "data"
            },
            "code": "\nvoid printDataWithPrefix_001053b0(undefined8 *prefix,undefined8 *data,undefined8 param_3,undefined8 param_4)\n\n{\n  if (DAT_0010b818 == 0) {\n    return;\n  }\n  if (prefix != (undefined8 *)0x0) {\n    printf(\"%s:\",*prefix);\n  }\n  printf(\"%s:\",*data,param_4);\n  return;\n}\n\n",
            "called": [
                "FUN_00103573"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001053b0",
            "calling": [
                "FUN_00105110"
            ],
            "imported": false,
            "current_name": "print_data_with_prefix_001053b0"
        },
        "FUN_001055f0": {
            "renaming": {
                "FUN_001055f0": "decompile_binary_001055f0",
                "param_1": "argc",
                "param_2": "argv",
                "pbVar1": "bytePtr1",
                "bVar2": "byteVar",
                "bVar3": "boolVar1",
                "bVar4": "boolVar2",
                "bVar5": "boolVar3",
                "cVar6": "charVar1",
                "bVar7": "byteVar2",
                "cVar8": "charVar2",
                "cVar9": "charVar3",
                "iVar10": "intVar1",
                "uVar11": "uintVar",
                "iVar12": "intVar3",
                "uVar13": "uintVar1",
                "uVar14": "uintVar2",
                "__stream": "fileStream",
                "__s": "bytePtr2",
                "piVar15": "intPtr1",
                "sVar16": "size_tVar",
                "__ptr": "bytePtr3",
                "__src": "longPtr1",
                "lVar17": "longVar1",
                "plVar18": "param2Ptr",
                "plVar19": "param2Ptr2",
                "uVar20": "undefined8Var1",
                "uVar21": "undefined8Var2",
                "pcVar22": "strVar1",
                "pbVar23": "bytePtr4",
                "lVar24": "longVar2",
                "pbVar25": "bytePtr5",
                "pcVar26": "strVar2",
                "piVar27": "intPtr2",
                "local_110": "local_var1",
                "local_10c": "local_var2",
                "local_108": "local_var3",
                "local_c8": "local_stat"
            },
            "code": "\n\n\nundefined ** decompileBinary_001055f0(int argc,long *argv)\n\n{\n  byte *bytePtr1;\n  byte byteVar;\n  bool boolVar1;\n  bool boolVar2;\n  bool boolVar3;\n  char charVar1;\n  byte byteVar2;\n  char charVar2;\n  char charVar3;\n  int intVar1;\n  uint uintVar;\n  int intVar3;\n  undefined4 uintVar1;\n  undefined4 uintVar2;\n  FILE *fileStream;\n  byte *bytePtr2;\n  int *intPtr1;\n  size_t size_tVar;\n  byte *bytePtr3;\n  long *longPtr1;\n  long longVar1;\n  long *param2Ptr;\n  long *param2Ptr2;\n  undefined8 undefined8Var1;\n  undefined8 undefined8Var2;\n  char *strVar1;\n  byte *bytePtr4;\n  undefined **unaff_RBP;\n  long longVar2;\n  byte *bytePtr5;\n  char *strVar2;\n  int *unaff_R12;\n  int *intPtr2;\n  int local_var1;\n  int local_var2;\n  size_t local_var3;\n  stat local_stat;\n  \n  setlocale(5,\"\");\n  setlocale(0,\"\");\n  strVar1 = \"binutils\";\n  setlocale(3,\"\");\n  bindtextdomain(\"binutils\",\"/usr/share/locale\");\n  textdomain(\"binutils\");\n  DAT_0010b820 = *argv;\n  xmalloc_set_program_name();\n  bfd_set_error_program_name(DAT_0010b820);\n  bfd_plugin_set_program_name(DAT_0010b820);\n  param2Ptr = argv;\n  if (1 < argc) {\n    local_var2 = 2000;\n    unaff_R12 = (int *)0x1;\n    local_var1 = 0;\n    do {\n      intVar3 = (int)unaff_R12;\n      unaff_RBP = (undefined **)(long)intVar3;\n      intPtr2 = (int *)((long)unaff_RBP * 8);\n      if (*(char *)param2Ptr[(long)unaff_RBP] != '@') goto LAB_00105a70;\n      local_var2 = local_var2 + -1;\n      if (local_var2 == 0) {\n        longVar2 = *param2Ptr;\n        strVar2 = \"%s: error: too many @-files encountered\\n\";\n        goto LAB_00105f1d;\n      }\n      strVar1 = (char *)param2Ptr[(long)unaff_RBP] + 1;\n      intVar1 = stat(strVar1,&local_stat);\n      if (intVar1 < 0) {\nLAB_00105a70:\n        if (argc <= intVar3 + 1) break;\nLAB_00105a7a:\n        uintVar = intVar3 + 1;\n        local_var1 = intVar3;\n      }\n      else {\n        if ((local_stat.st_mode & 0xf000) == 0x4000) goto LAB_00105f13;\n        fileStream = fopen(strVar1,\"r\");\n        if (fileStream == (FILE *)0x0) goto LAB_00105a70;\n        intVar1 = fseek(fileStream,0,2);\n        if (((intVar1 == -1) ||\n            (strVar1 = (char *)ftell(fileStream), (int *)strVar1 == (int *)0xffffffffffffffff)) ||\n           (intVar1 = fseek(fileStream,0,0), intVar1 == -1)) {\nLAB_00105ad0:\n          fclose(fileStream);\n          if (intVar3 + 1 < argc) goto LAB_00105a7a;\n          break;\n        }\n        bytePtr2 = (byte *)xmalloc((char *)((long)strVar1 + 1));\n        intPtr1 = (int *)fread(bytePtr2,1,(size_t)strVar1,fileStream);\n        if (((int *)strVar1 != intPtr1) && (intVar1 = ferror(fileStream), intVar1 != 0)) {\n          free(bytePtr2);\n          goto LAB_00105ad0;\n        }\n        bytePtr2[(long)intPtr1] = 0;\n        byteVar2 = *bytePtr2;\n        bytePtr4 = bytePtr2;\n        if (byteVar2 != 0) {\nLAB_001057d0:\n          if (((&_sch_istable)[(ulong)byteVar2 * 2] & 0x40) != 0) goto LAB_001057c0;\n          size_tVar = strlen((char *)bytePtr2);\n          bytePtr3 = (byte *)xmalloc(size_tVar + 1);\n          intVar1 = 0;\n          boolVar3 = false;\n          boolVar1 = false;\n          longVar2 = 0;\n          longPtr1 = (long *)0x0;\n          boolVar2 = false;\n          bytePtr4 = bytePtr2;\n          do {\n            while (((&_sch_istable)[(ulong)*bytePtr4 * 2] & 0x40) != 0) {\n              bytePtr4 = bytePtr4 + 1;\n            }\n            if ((intVar1 == 0) || (param2Ptr2 = longPtr1 + longVar2, intVar1 + -1 <= (int)longVar2)) {\n              if (longPtr1 == (long *)0x0) {\n                intVar1 = 8;\n                longPtr1 = (long *)xmalloc(0x40);\n                param2Ptr2 = longPtr1 + longVar2;\n                *param2Ptr2 = 0;\n              }\n              else {\n                intVar1 = intVar1 * 2;\n                longPtr1 = (long *)xrealloc(longPtr1,(long)intVar1 << 3);\n                param2Ptr2 = longPtr1 + longVar2;\n                *param2Ptr2 = 0;\n              }\n            }\n            byteVar2 = *bytePtr4;\n            bytePtr5 = bytePtr3;\n            while (byteVar2 != 0) {\n              while( true ) {\n                if ((((&_sch_istable)[(ulong)byteVar2 * 2] & 0x40) != 0) &&\n                   (!(bool)(boolVar3 | boolVar2 | boolVar1))) {\n                  boolVar2 = false;\n                  boolVar3 = false;\n                  boolVar1 = false;\n                  goto LAB_001058e0;\n                }\n                if (!boolVar2) break;\n                bytePtr4 = bytePtr4 + 1;\n                *bytePtr5 = byteVar2;\n                bytePtr5 = bytePtr5 + 1;\n                boolVar2 = false;\n                byteVar2 = *bytePtr4;\n                if (byteVar2 == 0) goto LAB_001058e0;\n              }\n              if (byteVar2 == 0x5c) {\n                boolVar2 = true;\n              }\n              else if (boolVar1) {\n                if (byteVar2 == 0x27) {\n                  boolVar1 = false;\n                }\n                else {\nLAB_00105a55:\n                  *bytePtr5 = byteVar2;\n                  bytePtr5 = bytePtr5 + 1;\n                }\n              }\n              else if (boolVar3) {\n                if (byteVar2 != 0x22) goto LAB_00105a55;\n                boolVar3 = false;\n              }\n              else if (byteVar2 == 0x27) {\n                boolVar1 = true;\n              }\n              else {\n                if (byteVar2 != 0x22) goto LAB_00105a55;\n                boolVar3 = true;\n              }\n              bytePtr1 = bytePtr4 + 1;\n              bytePtr4 = bytePtr4 + 1;\n              byteVar2 = *bytePtr1;\n            }\nLAB_001058e0:\n            *bytePtr5 = 0;\n            longVar1 = xstrdup(bytePtr3);\n            *param2Ptr2 = longVar1;\n            longPtr1[longVar2 + 1] = 0;\n            byteVar2 = *bytePtr4;\n            byteVar = (&_sch_istable)[(ulong)byteVar2 * 2];\n            while ((byteVar & 0x40) != 0) {\n              byteVar2 = bytePtr4[1];\n              bytePtr4 = bytePtr4 + 1;\n              byteVar = (&_sch_istable)[(ulong)byteVar2 * 2];\n            }\n            longVar2 = longVar2 + 1;\n          } while (byteVar2 != 0);\n          free(bytePtr3);\n          param2Ptr2 = param2Ptr;\n          if (argv == param2Ptr) goto LAB_00105c79;\n          goto LAB_0010597d;\n        }\nLAB_00105c5c:\n        longPtr1 = (long *)xmalloc(8);\n        *longPtr1 = 0;\n        if (argv == param2Ptr) {\nLAB_00105c79:\n          if (*param2Ptr == 0) {\n            intVar1 = 0;\n          }\n          else {\n            longVar2 = 1;\n            do {\n              intVar1 = (int)longVar2;\n              param2Ptr2 = param2Ptr + longVar2;\n              longVar2 = longVar2 + 1;\n            } while (*param2Ptr2 != 0);\n          }\n          longVar1 = 0;\n          param2Ptr2 = (long *)xmalloc((long)(intVar1 + 1) << 3);\n          longVar2 = *param2Ptr;\n          while (longVar2 != 0) {\n            undefined8Var1 = xstrdup();\n            *(undefined8 *)((long)param2Ptr2 + longVar1) = undefined8Var1;\n            longVar1 = longVar1 + 8;\n            longVar2 = *(long *)((long)param2Ptr + longVar1);\n          }\n          *(undefined8 *)((long)param2Ptr2 + longVar1) = 0;\nLAB_0010597d:\n          param2Ptr = param2Ptr2;\n          if (*longPtr1 == 0) goto LAB_00105d50;\n          strVar1 = (char *)0x0;\n          do {\n            strVar1 = (char *)((long)strVar1 + 1);\n          } while (longPtr1[(long)strVar1] != 0);\n          local_var3 = (long)strVar1 * 8;\n        }\n        else {\nLAB_00105d50:\n          strVar1 = (char *)0x0;\n          local_var3 = 0;\n        }\n        free((void *)param2Ptr[(long)unaff_RBP]);\n        param2Ptr = (long *)xrealloc(param2Ptr,(long)((long)strVar1 + (long)argc + 1) * 8);\n        intVar1 = argc + -1 + (int)strVar1;\n        memmove(param2Ptr + (long)(undefined **)((long)unaff_RBP + (long)strVar1),\n                param2Ptr + 1 + (long)unaff_RBP,(long)(argc - intVar3) << 3);\n        memcpy(param2Ptr + (long)unaff_RBP,longPtr1,local_var3);\n        free(longPtr1);\n        free(bytePtr2);\n        fclose(fileStream);\n        uintVar = local_var1 + 1;\n        unaff_RBP = (undefined **)((long)unaff_RBP + (long)strVar1);\n        unaff_R12 = intPtr2;\n        argc = intVar1;\n        if (intVar1 <= (int)uintVar) break;\n      }\n      unaff_R12 = (int *)(ulong)uintVar;\n    } while( true );\n  }\n  intVar3 = bfd_init();\n  strVar2 = \"fatal error: libbfd ABI mismatch\";\n  if (intVar3 != 0x118) goto LAB_00106085;\n  unaff_RBP = &PTR_s_debug_syms_0010b280;\n  charVar2 = bfd_set_default_target(\"x86_64-pc-linux-gnu\",\"fatal error: libbfd ABI mismatch\",5);\n  strVar1 = \"aABCDef:gHhjJlnopPrSst:uU:vVvWX:\";\n  unaff_R12 = (int *)\"x86_64-pc-linux-gnu\";\n  charVar3 = DAT_0010b23b;\n  charVar1 = DAT_0010b240;\n  uintVar2 = DAT_0010b244;\n  if (charVar2 != '\\0') {\nswitchD_00105c5a_caseD_0:\n    DAT_0010b244 = uintVar2;\n    DAT_0010b240 = charVar1;\n    DAT_0010b23b = charVar3;\n    uintVar1 = getopt_long(argc,param2Ptr,strVar1);\n    intPtr2 = _optarg;\n    intPtr1 = (int *)strVar1;\n    charVar3 = DAT_0010b23b;\n    charVar1 = DAT_0010b240;\n    uintVar2 = DAT_0010b244;\n    switch(uintVar1) {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n    case 6:\n    case 7:\n    case 8:\n    case 9:\n    case 10:\n    case 0xb:\n    case 0xc:\n    case 0xd:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x27:\n    case 0x28:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3d:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x45:\n    case 0x46:\n    case 0x47:\n    case 0x49:\n    case 0x4a:\n    case 0x4b:\n    case 0x4c:\n    case 0x4d:\n    case 0x4e:\n    case 0x4f:\n    case 0x51:\n    case 0x52:\n    case 0x54:\n    case 0x59:\n    case 0x5a:\n    case 0x5b:\n    case 0x5c:\n    case 0x5d:\n    case 0x5e:\n    case 0x5f:\n    case 0x60:\n    case 0x62:\n    case 99:\n    case 100:\n    case 0x69:\n    case 0x6b:\n    case 0x6d:\n    case 0x71:\n    case 0x77:\n    case 0x78:\n    case 0x79:\n    case 0x7a:\n    case 0x7b:\n    case 0x7c:\n    case 0x7d:\n    case 0x7e:\n    case 0x7f:\n    case 0x80:\n    case 0x81:\n    case 0x82:\n    case 0x83:\n    case 0x84:\n    case 0x85:\n    case 0x86:\n    case 0x87:\n    case 0x88:\n    case 0x89:\n    case 0x8a:\n    case 0x8b:\n    case 0x8c:\n    case 0x8d:\n    case 0x8e:\n    case 0x8f:\n    case 0x90:\n    case 0x91:\n    case 0x92:\n    case 0x93:\n    case 0x94:\n    case 0x95:\n    case 0x96:\n    case 0x97:\n    case 0x98:\n    case 0x99:\n    case 0x9a:\n    case 0x9b:\n    case 0x9c:\n    case 0x9d:\n    case 0x9e:\n    case 0x9f:\n    case 0xa0:\n    case 0xa1:\n    case 0xa2:\n    case 0xa3:\n    case 0xa4:\n    case 0xa5:\n    case 0xa6:\n    case 0xa7:\n    case 0xa8:\n    case 0xa9:\n    case 0xaa:\n    case 0xab:\n    case 0xac:\n    case 0xad:\n    case 0xae:\n    case 0xaf:\n    case 0xb0:\n    case 0xb1:\n    case 0xb2:\n    case 0xb3:\n    case 0xb4:\n    case 0xb5:\n    case 0xb6:\n    case 0xb7:\n    case 0xb8:\n    case 0xb9:\n    case 0xba:\n    case 0xbb:\n    case 0xbc:\n    case 0xbd:\n    case 0xbe:\n    case 0xbf:\n    case 0xc0:\n    case 0xc1:\n    case 0xc2:\n    case 0xc3:\n    case 0xc4:\n    case 0xc5:\n    case 0xc6:\n    case 199:\n      FUN_00103ca0(_stderr,1);\n      intPtr2 = unaff_R12;\nLAB_001061d5:\n      intVar3 = strcmp((char *)intPtr2,\"l\");\n      if (intVar3 == 0) goto LAB_001061a3;\n      intVar3 = strcmp((char *)intPtr2,\"escape\");\n      unaff_R12 = intPtr2;\n      if ((intVar3 == 0) || (intVar3 = strcmp((char *)intPtr2,\"e\"), intVar3 == 0)) {\n        DAT_0010b7e0 = 2;\n        charVar3 = DAT_0010b23b;\n        charVar1 = DAT_0010b240;\n        uintVar2 = DAT_0010b244;\n        goto switchD_00105c5a_caseD_0;\n      }\n      intVar3 = strcmp((char *)intPtr2,\"invalid\");\n      if ((intVar3 == 0) || (intVar3 = strcmp((char *)intPtr2,\"i\"), intVar3 == 0)) {\n        DAT_0010b7e0 = 5;\n        charVar3 = DAT_0010b23b;\n        charVar1 = DAT_0010b240;\n        uintVar2 = DAT_0010b244;\n        goto switchD_00105c5a_caseD_0;\n      }\n      intVar3 = strcmp((char *)intPtr2,\"hex\");\n      if ((intVar3 == 0) || (intVar3 = strcmp((char *)intPtr2,\"x\"), intVar3 == 0)) {\n        DAT_0010b7e0 = 3;\n        charVar3 = DAT_0010b23b;\n        charVar1 = DAT_0010b240;\n        uintVar2 = DAT_0010b244;\n        goto switchD_00105c5a_caseD_0;\n      }\n      intVar3 = strcmp((char *)intPtr2,\"highlight\");\n      if ((intVar3 == 0) || (intVar3 = strcmp((char *)intPtr2,\"h\"), intVar3 == 0)) {\n        DAT_0010b7e0 = 4;\n        charVar3 = DAT_0010b23b;\n        charVar1 = DAT_0010b240;\n        uintVar2 = DAT_0010b244;\n        goto switchD_00105c5a_caseD_0;\n      }\n      strVar2 = \"invalid argument to -U/--unicode: %s\";\n      break;\n    case 0x41:\n    case 0x6f:\n      DAT_0010b818 = 1;\n      goto switchD_00105c5a_caseD_0;\n    case 0x42:\n      FUN_00104370(&DAT_00107033);\n      charVar3 = DAT_0010b23b;\n      charVar1 = DAT_0010b240;\n      uintVar2 = DAT_0010b244;\n      goto switchD_00105c5a_caseD_0;\n    case 0x43:\n      goto switchD_00105c5a_caseD_43;\n    case 0x44:\n      DAT_0010b80c = 1;\n      goto switchD_00105c5a_caseD_0;\n    case 0x48:\n    case 0x68:\n      FUN_00103ca0(_stdout,0);\nswitchD_00105c5a_caseD_43:\n      unaff_R12 = (int *)&optarg;\n      DAT_0010b814 = 1;\n      charVar3 = DAT_0010b23b;\n      charVar1 = DAT_0010b240;\n      uintVar2 = DAT_0010b244;\n      if (_optarg != (int *)0x0) {\n        intVar3 = cplus_demangle_name_to_style();\n        intPtr1 = _optarg;\n        if (intVar3 == 0) {\n          undefined8Var1 = dcgettext(0,\"unknown demangling style `%s\\'\",5);\n          FUN_00106300(undefined8Var1,intPtr1);\nswitchD_00105c5a_caseD_cc:\n          DAT_0010b248 = DAT_0010b248 | 0x40000;\n          strVar1 = (char *)intPtr1;\n          charVar3 = DAT_0010b23b;\n          charVar1 = DAT_0010b240;\n          uintVar2 = DAT_0010b244;\n        }\n        else {\n          cplus_demangle_set_style();\n          charVar3 = DAT_0010b23b;\n          charVar1 = DAT_0010b240;\n          uintVar2 = DAT_0010b244;\n        }\n      }\n      goto switchD_00105c5a_caseD_0;\n    case 0x50:\n      FUN_00104370(\"posix\");\n      charVar3 = DAT_0010b23b;\n      charVar1 = DAT_0010b240;\n      uintVar2 = DAT_0010b244;\n      goto switchD_00105c5a_caseD_0;\n    case 0x53:\n      DAT_0010b7ec = 1;\n      goto switchD_00105c5a_caseD_0;\n    case 0x55:\n      DAT_0010b7e4 = 1;\n      DAT_0010b7e8 = 0;\n      goto switchD_00105c5a_caseD_0;\n    case 0x56:\n      goto switchD_00105c5a_caseD_56;\n    case 0x57:\n      DAT_0010b7d8 = 1;\n      goto switchD_00105c5a_caseD_0;\n    case 0x58:\n      intVar3 = strcmp((char *)_optarg,\"32_64\");\n      charVar3 = DAT_0010b23b;\n      charVar1 = DAT_0010b240;\n      uintVar2 = DAT_0010b244;\n      if (intVar3 != 0) {\n        strVar2 = \"Only -X 32_64 is supported\";\nLAB_00106085:\n        undefined8Var1 = dcgettext(0,strVar2,5);\n        FUN_00106300(undefined8Var1);\nswitchD_00105c5a_caseD_56:\n        DAT_0010b7dc = 1;\n        charVar3 = DAT_0010b23b;\n        charVar1 = DAT_0010b240;\n        uintVar2 = DAT_0010b244;\n      }\n      goto switchD_00105c5a_caseD_0;\n    case 0x61:\n      DAT_0010b81c = 1;\n      goto switchD_00105c5a_caseD_0;\n    case 0x66:\n      FUN_00104370(_optarg);\n      charVar3 = DAT_0010b23b;\n      charVar1 = DAT_0010b240;\n      uintVar2 = DAT_0010b244;\n      goto switchD_00105c5a_caseD_0;\n    case 0x67:\n      DAT_0010b808 = 1;\n      goto switchD_00105c5a_caseD_0;\n    case 0x6a:\n      FUN_00104370(\"just-symbols\");\n      charVar3 = DAT_0010b23b;\n      charVar1 = DAT_0010b240;\n      uintVar2 = DAT_0010b244;\n      goto switchD_00105c5a_caseD_0;\n    case 0x6c:\n      DAT_0010b804 = 1;\n      goto switchD_00105c5a_caseD_0;\n    case 0x6e:\n    case 0x76:\n      DAT_0010b7fc = 1;\n      DAT_0010b800 = 0;\n      DAT_0010b7f8 = 0;\n      goto switchD_00105c5a_caseD_0;\n    case 0x70:\n      DAT_0010b800 = 1;\n      DAT_0010b7fc = 0;\n      DAT_0010b7f8 = 0;\n      goto switchD_00105c5a_caseD_0;\n    case 0x72:\n      DAT_0010b7f4 = 1;\n      goto switchD_00105c5a_caseD_0;\n    case 0x73:\n      _DAT_0010b7f0 = 1;\n      goto switchD_00105c5a_caseD_0;\n    case 0x74:\n      charVar3 = *(char *)_optarg;\n      unaff_R12 = intPtr2;\n      charVar1 = charVar3;\n      uintVar2 = 10;\n      if (charVar3 == 'd') goto switchD_00105c5a_caseD_0;\n      if ('c' < charVar3) {\n        if (charVar3 == 'o') {\n          uintVar2 = 8;\n          goto switchD_00105c5a_caseD_0;\n        }\n        if (charVar3 == 'x') {\n          uintVar2 = 0x10;\n          goto switchD_00105c5a_caseD_0;\n        }\n      }\n      strVar2 = \"%s: invalid radix\";\n      break;\n    case 0x75:\n      DAT_0010b7e8 = 1;\n      DAT_0010b7e4 = 0;\n      goto switchD_00105c5a_caseD_0;\n    case 200:\n      DAT_0010b7d0 = _optarg;\n      goto switchD_00105c5a_caseD_0;\n    case 0xc9:\n      bfd_plugin_set_plugin(_optarg);\n      charVar3 = DAT_0010b23b;\n      charVar1 = DAT_0010b240;\n      uintVar2 = DAT_0010b244;\n      goto switchD_00105c5a_caseD_0;\n    case 0xca:\n      DAT_0010b7f8 = 1;\n      DAT_0010b800 = 0;\n      DAT_0010b7fc = 0;\n      goto switchD_00105c5a_caseD_0;\n    case 0xcb:\n      DAT_0010b248 = DAT_0010b248 & 0xfffbffff;\n      goto switchD_00105c5a_caseD_0;\n    case 0xcc:\n      goto switchD_00105c5a_caseD_cc;\n    case 0xcd:\n      DAT_0010b7c8 = _optarg;\n      goto switchD_00105c5a_caseD_0;\n    case 0xce:\n      intVar3 = strcmp((char *)_optarg,\"default\");\n      if ((intVar3 == 0) || (intVar3 = strcmp((char *)intPtr2,\"d\"), intVar3 == 0)) {\n        DAT_0010b7e0 = 0;\n        unaff_R12 = intPtr2;\n        charVar3 = DAT_0010b23b;\n        charVar1 = DAT_0010b240;\n        uintVar2 = DAT_0010b244;\n      }\n      else {\n        intVar3 = strcmp((char *)intPtr2,\"locale\");\n        if (intVar3 != 0) goto LAB_001061d5;\nLAB_001061a3:\n        DAT_0010b7e0 = 1;\n        unaff_R12 = intPtr2;\n        charVar3 = DAT_0010b23b;\n        charVar1 = DAT_0010b240;\n        uintVar2 = DAT_0010b244;\n      }\n      goto switchD_00105c5a_caseD_0;\n    case 0xcf:\n      goto switchD_00105c5a_caseD_cf;\n    default:\n      goto code_r0x00105b40;\n    }\n    undefined8Var1 = dcgettext(0,strVar2,5);\n    FUN_00106300(undefined8Var1,intPtr2);\nLAB_00105f13:\n    longVar2 = *param2Ptr;\n    strVar2 = \"%s: error: @-file refers to a directory\\n\";\nLAB_00105f1d:\n    fprintf(_stderr,strVar2,longVar2);\n    xexit(1);\n    goto LAB_00105f38;\n  }\n  uintVar2 = bfd_get_error();\n  undefined8Var1 = bfd_errmsg(uintVar2);\n  undefined8Var2 = dcgettext(0,\"can\\'t set BFD default target to `%s\\': %s\",5);\n  FUN_00106300(undefined8Var2,\"x86_64-pc-linux-gnu\",undefined8Var1);\n  goto LAB_0010613c;\nLAB_001057c0:\n  byteVar2 = bytePtr4[1];\n  bytePtr4 = bytePtr4 + 1;\n  if (byteVar2 == 0) goto LAB_00105c5c;\n  goto LAB_001057d0;\nswitchD_00105c5a_caseD_cf:\n  _DAT_0010b810 = 1;\n  goto switchD_00105c5a_caseD_0;\ncode_r0x00105b40:\n  unaff_RBP = (undefined **)(ulong)DAT_0010b7dc;\n  if (DAT_0010b7dc != 0) {\n    printf(\"GNU %s %s\\n\",&DAT_001070c6,\"(GNU Binutils for Debian) 2.40\");\n    strVar1 = (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n    printf(strVar1);\n    strVar1 = (char *)dcgettext(0,\n                                \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                                ,5);\n    printf(strVar1);\n                    \n    exit(0);\n  }\n  if ((DAT_0010b7f8 != 0) && (DAT_0010b7e8 != 0)) {\n    undefined8Var1 = dcgettext(0,\"Using the --size-sort and --undefined-only options together\",5);\n    FUN_00106400(undefined8Var1);\n    undefined8Var1 = dcgettext(0,\"will produce no output, since undefined symbols have no size.\",5);\n    FUN_00106400(undefined8Var1);\n    return unaff_RBP;\n  }\n  strVar1 = &optind;\n  if (_optind != argc) {\n    if (1 < argc - _optind) {\nLAB_00105f38:\n      _DAT_0010b7c4 = 1;\n    }\n    while( true ) {\n      intVar3 = *(int *)strVar1;\n      if (argc <= intVar3) break;\n      longVar2 = param2Ptr[intVar3];\n      *(int *)strVar1 = intVar3 + 1;\n      charVar3 = FUN_001043d0(longVar2);\n      if (charVar3 != '\\0') {\n        intVar3 = *(int *)strVar1;\n        if (argc <= intVar3) break;\n        longVar2 = param2Ptr[intVar3];\n        *(int *)strVar1 = intVar3 + 1;\n        charVar3 = FUN_001043d0(longVar2);\n        if (charVar3 != '\\0') {\n          intVar3 = *(int *)strVar1;\n          while( true ) {\n            if (argc <= intVar3) goto LAB_00105bdd;\n            longVar2 = param2Ptr[intVar3];\n            *(int *)strVar1 = intVar3 + 1;\n            charVar3 = FUN_001043d0(longVar2);\n            if (charVar3 == '\\0') break;\n            intVar3 = *(int *)strVar1;\n          }\n        }\n      }\n      unaff_RBP = (undefined **)(ulong)((int)unaff_RBP + 1);\n    }\nLAB_00105bdd:\n                    \n    exit((int)unaff_RBP);\n  }\nLAB_0010613c:\n  uintVar = FUN_001043d0(\"a.out\");\n  return (undefined **)(ulong)((uintVar ^ 1) & 0xff);\n}\n\n",
            "called": [
                "memmove",
                "FUN_00103ca0",
                "memcpy",
                "ferror",
                "ftell",
                "bindtextdomain",
                "fseek",
                "textdomain",
                "xmalloc_set_program_name",
                "exit",
                "FUN_001043d0",
                "strcmp",
                "bfd_set_default_target",
                "xexit",
                "dcgettext",
                "stat",
                "strlen",
                "printf",
                "getopt_long",
                "fread",
                "cplus_demangle_set_style",
                "bfd_plugin_set_plugin",
                "xmalloc",
                "xstrdup",
                "free",
                "FUN_00104370",
                "FUN_00106300",
                "FUN_00106400",
                "xrealloc",
                "setlocale",
                "bfd_init",
                "bfd_get_error",
                "cplus_demangle_name_to_style",
                "fclose",
                "fopen",
                "bfd_plugin_set_program_name",
                "bfd_set_error_program_name",
                "bfd_errmsg",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001055f0",
            "calling": [
                "entry"
            ],
            "imported": false,
            "current_name": "decompile_binary_001055f0"
        },
        "bfd_init": {
            "renaming": {},
            "code": "\nvoid bfd_init(void)\n\n{\n  bfd_init();\n  return;\n}\n\n",
            "called": [
                "bfd_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102230",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "bfd_init"
        },
        "strerror": {
            "renaming": {},
            "code": "\n\n\nchar * strerror(int __errnum)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strerror(__errnum);\n  return pcVar1;\n}\n\n",
            "called": [
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102410",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "strerror"
        },
        "ferror": {
            "renaming": {},
            "code": "\n\n\nint ferror(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = ferror(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "ferror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020a0",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "ferror"
        },
        "entry": {
            "renaming": {},
            "code": "\nvoid processEntry entry(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_8 [8];\n  \n  __libc_start_main(FUN_001055f0,param_2,&stack0x00000008,0,0,param_1,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "__libc_start_main",
                "FUN_001055f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105500",
            "calling": [],
            "imported": false,
            "current_name": "entry"
        },
        "abort": {
            "renaming": {},
            "code": "\n\n\nvoid abort(void)\n\n{\n                    \n  abort();\n}\n\n",
            "called": [
                "abort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102070",
            "calling": [
                "FUN_00102fd2"
            ],
            "imported": false,
            "current_name": "abort"
        },
        "memmove": {
            "renaming": {},
            "code": "\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memmove(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102310",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "memmove"
        },
        "strstr": {
            "renaming": {},
            "code": "\n\n\nchar * strstr(char *__haystack,char *__needle)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strstr(__haystack,__needle);\n  return pcVar1;\n}\n\n",
            "called": [
                "strstr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102420",
            "calling": [
                "FUN_00104670",
                "FUN_00102fd2"
            ],
            "imported": false,
            "current_name": "strstr"
        },
        "FUN_0010351b": {
            "renaming": {
                "FUN_0010351b": "print_message_if_data_not_zero_0010351b"
            },
            "code": "\nvoid printMessageIfDataNotZero_0010351b(void)\n\n{\n  if (DAT_0010b818 == 0) {\n    printf(\"\\n%s:\\n\");\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010351b",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "print_message_if_data_not_zero_0010351b"
        },
        "FUN_00103b2b": {
            "renaming": {
                "FUN_00103b2b": "print_debug_message_00103b2b",
                "param_1": "module_name",
                "param_2": "message"
            },
            "code": "\nvoid print_debug_message_00103b2b(undefined8 module_name,undefined8 message)\n\n{\n  if (DAT_0010b818 == 0) {\n    printf(\"%s[%s]:\\n\",module_name,message);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103b2b",
            "calling": [],
            "imported": false,
            "current_name": "print_debug_message_00103b2b"
        },
        "FUN_00104740": {
            "renaming": {
                "FUN_00104740": "print_formatted_string_00104740",
                "param_1": "formatString",
                "param_2": "paramArray",
                "param_3": "demangledString",
                "param_4": "paramValue",
                "puVar1": "ptr1",
                "bVar2": "byte1",
                "bVar3": "byte2",
                "iVar4": "iVar",
                "sVar5": "stringLength",
                "pcVar6": "strPtr",
                "puVar7": "ptr2",
                "pcVar8": "tempStrPtr",
                "__ptr": "concatenatedString",
                "uVar9": "tempValue",
                "uVar10": "tempVar",
                "puVar11": "ptr3",
                "puVar12": "stringPtr",
                "__s": "tempCharPtr",
                "__s_00": "tempCharPtr2",
                "lVar13": "longVar",
                "uVar14": "tempUInt",
                "bVar15": "byteFlag",
                "acStack_39": "tempArray"
            },
            "code": "\n\n\nvoid printFormattedString_00104740(char *formatString,long *paramArray,undefined8 *demangledString,long paramValue)\n\n{\n  undefined8 *ptr1;\n  byte byte1;\n  byte byte2;\n  int iVar;\n  size_t stringLength;\n  char *strPtr;\n  undefined8 *ptr2;\n  char *tempStrPtr;\n  undefined8 *concatenatedString;\n  ulong tempValue;\n  undefined8 tempVar;\n  undefined *ptr3;\n  undefined8 *stringPtr;\n  char *tempCharPtr;\n  undefined8 *tempCharPtr2;\n  long longVar;\n  uint tempUInt;\n  byte byteFlag;\n  char tempArray [9];\n  \n  byteFlag = 0;\n  if (demangledString == (undefined8 *)0x0) {\n    demangledString = *(undefined8 **)(*paramArray + 0x10);\n    if (DAT_0010b234 == 0) {\n      FUN_00102739();\n      return;\n    }\nLAB_00104775:\n    stringPtr = demangledString;\n    if (DAT_0010b814 == 0) {\n      strPtr = (char *)0x0;\n      if (DAT_0010b7e0 == 0) {\nLAB_00104794:\n        stringPtr = demangledString;\n        concatenatedString = (undefined8 *)0x0;\n      }\n      else {\n        concatenatedString = (undefined8 *)0x0;\n        if (demangledString != (undefined8 *)0x0) goto LAB_0010269d;\n        stringPtr = (undefined8 *)0x1073a6;\n      }\n    }\n    else {\n      strPtr = (char *)0x0;\nLAB_0010482b:\n      if ((*(char *)stringPtr == '\\0') ||\n         (demangledString = (undefined8 *)bfd_demangle(paramValue,stringPtr,DAT_0010b248),\n         demangledString == (undefined8 *)0x0)) {\n        demangledString = stringPtr;\n        if (DAT_0010b7e0 != 0) goto LAB_00102698;\n        concatenatedString = (undefined8 *)0x0;\n      }\n      else {\n        stringPtr = demangledString;\n        concatenatedString = demangledString;\n        if (DAT_0010b7e0 != 0) goto LAB_0010269d;\n      }\n    }\n  }\n  else {\n    stringPtr = demangledString;\n    if (DAT_0010b234 == 0) {\n      if (*(int *)(*(long *)(paramValue + 8) + 8) != 5) goto LAB_00104775;\n      strPtr = strchr((char *)demangledString,0x40);\n      if (strPtr == (char *)0x0) {\n        if (DAT_0010b814 == 0) {\n          if (DAT_0010b7e0 == 0) {\n            if (paramArray == (long *)0x0) {\n              concatenatedString = (undefined8 *)0x0;\n              printf(formatString,demangledString);\n            }\n            else {\n              if (paramArray[2] != 0) {\n                FUN_001047d0();\n                return;\n              }\n              concatenatedString = (undefined8 *)0x0;\n              printf(formatString,demangledString);\n            }\n            goto LAB_001047ba;\n          }\n          goto LAB_00102698;\n        }\n      }\n      else {\n        *strPtr = '\\0';\n        if (DAT_0010b814 == 0) {\n          if (DAT_0010b7e0 == 0) goto LAB_00104794;\n          concatenatedString = (undefined8 *)0x0;\n          goto LAB_0010269d;\n        }\n      }\n      goto LAB_0010482b;\n    }\n    strPtr = (char *)0x0;\n    if (DAT_0010b814 != 0) goto LAB_0010482b;\n    if (DAT_0010b7e0 == 0) goto LAB_00104794;\nLAB_00102698:\n    stringPtr = demangledString;\n    concatenatedString = (undefined8 *)0x0;\nLAB_0010269d:\n    do {\n      byte1 = *(byte *)demangledString;\n      demangledString = (undefined8 *)((long)demangledString + 1);\n      if (byte1 == 0) goto joined_r0x00104864;\n    } while ((((&_sch_istable)[(ulong)byte1 * 2] & 2) == 0) && (byte1 < 0xc0));\n    stringLength = strlen((char *)stringPtr);\n    tempCharPtr2 = DAT_0010b790;\n    if (_DAT_0010b798 < stringLength * 9) {\n      free(DAT_0010b790);\n      stringLength = strlen((char *)stringPtr);\n      _DAT_0010b798 = stringLength * 9;\n      DAT_0010b790 = (undefined8 *)xmalloc(_DAT_0010b798 + 1);\n      tempCharPtr2 = DAT_0010b790;\n    }\n    while( true ) {\n      ptr2 = DAT_0010b790;\n      byte1 = *(byte *)stringPtr;\n      ptr1 = (undefined8 *)((long)stringPtr + 1);\n      if (byte1 == 0) break;\n      if (((&_sch_istable)[(ulong)byte1 * 2] & 2) == 0) {\n        if ((byte1 < 0xc0) || (DAT_0010b7e0 == 0)) {\n          *(byte *)tempCharPtr2 = byte1;\n          tempCharPtr2 = (undefined8 *)((long)tempCharPtr2 + 1);\n          stringPtr = ptr1;\n        }\n        else {\n          byte2 = *(byte *)((long)stringPtr + 1);\n          if ((byte2 & 0xc0) == 0x80) {\n            ptr2 = tempCharPtr2;\n            if ((byte1 & 0x20) == 0) {\n              switch(DAT_0010b7e0) {\n              case 1:\n                tempUInt = 2;\n                goto LAB_00102a62;\n              case 3:\n              case 5:\n                longVar = 2;\n                goto LAB_00102917;\n              case 4:\n                iVar = isatty(1);\n                if (iVar == 0) {\n                  byte2 = *(byte *)((long)stringPtr + 1);\n                }\n                else {\n                  *(undefined *)(tempCharPtr2 + 1) = 0;\n                  *tempCharPtr2 = 0x6d37343b31335b1b;\n                  byte2 = *(byte *)((long)stringPtr + 1);\n                  ptr2 = tempCharPtr2 + 1;\n                }\n              case 2:\n                tempUInt = 2;\n                sprintf((char *)ptr2,\"\\u%02x%02x\",(ulong)((int)(uint)*(byte *)stringPtr >> 2 & 7),\n                        (ulong)((*(byte *)stringPtr & 3) << 6 | byte2 & 0x3f));\n                ptr2 = (undefined8 *)((long)ptr2 + 6);\n                goto LAB_00102a27;\n              default:\n                tempUInt = 2;\n              }\n            }\n            else {\n              byte2 = *(byte *)((long)stringPtr + 2);\n              if ((byte2 & 0xc0) != 0x80) goto LAB_0010285d;\n              if ((byte1 & 0x10) == 0) {\n                switch(DAT_0010b7e0) {\n                case 1:\n                  tempUInt = 3;\nLAB_00102a62:\n                  for (tempValue = (ulong)tempUInt; tempValue != 0; tempValue = tempValue - 1) {\n                    *(undefined *)ptr2 = *(undefined *)stringPtr;\n                    stringPtr = (undefined8 *)((long)stringPtr + (ulong)byteFlag * -2 + 1);\n                    ptr2 = (undefined8 *)((long)ptr2 + (ulong)byteFlag * -2 + 1);\n                  }\n                  break;\n                case 3:\n                case 5:\n                  longVar = 3;\nLAB_00102917:\n                  tempVar = 0x7b;\n                  if (DAT_0010b7e0 == 3) {\n                    tempVar = 0x3c;\n                  }\n                  sprintf((char *)tempCharPtr2,\"%c\",tempVar);\n                  *(undefined *)((long)tempCharPtr2 + 3) = 0;\n                  ptr2 = (undefined8 *)(longVar + (long)stringPtr);\n                  *(undefined2 *)((long)tempCharPtr2 + 1) = 0x7830;\n                  tempStrPtr = (char *)((long)tempCharPtr2 + 3);\n                  do {\n                    tempCharPtr = tempStrPtr;\n                    byte1 = *(byte *)stringPtr;\n                    stringPtr = (undefined8 *)((long)stringPtr + 1);\n                    sprintf(tempCharPtr,\"%02x\",(ulong)byte1);\n                    tempStrPtr = tempCharPtr + 2;\n                  } while (stringPtr != ptr2);\n                  tempVar = 0x7d;\n                  if (DAT_0010b7e0 == 3) {\n                    tempVar = 0x3e;\n                  }\n                  tempUInt = (uint)longVar;\n                  sprintf(tempCharPtr + 2,\"%c\",tempVar);\n                  ptr2 = (undefined8 *)(tempCharPtr + 3);\n                  break;\n                case 4:\n                  iVar = isatty(1);\n                  if (iVar == 0) {\n                    byte2 = *(byte *)((long)stringPtr + 2);\n                  }\n                  else {\n                    *(undefined *)(tempCharPtr2 + 1) = 0;\n                    *tempCharPtr2 = 0x6d37343b31335b1b;\n                    byte2 = *(byte *)((long)stringPtr + 2);\n                    ptr2 = tempCharPtr2 + 1;\n                  }\n                case 2:\n                  tempUInt = 3;\n                  sprintf((char *)ptr2,\"\\u%02x%02x\",\n                          (ulong)((uint)(((ulong)*(byte *)stringPtr & 0xf) << 4) |\n                                 (int)(uint)*(byte *)((long)stringPtr + 1) >> 2 & 0xfU),\n                          (ulong)((*(byte *)((long)stringPtr + 1) & 3) << 6 | byte2 & 0x3f));\n                  ptr2 = (undefined8 *)((long)ptr2 + 6);\nLAB_00102a27:\n                  if ((DAT_0010b7e0 == 4) && (iVar = isatty(1), iVar != 0)) {\n                    *(undefined4 *)ptr2 = 0x6d305b1b;\n                    ptr2 = (undefined8 *)((long)ptr2 + 4);\n                    *(undefined *)ptr2 = 0;\n                  }\n                  break;\n                default:\n                  tempUInt = 3;\n                }\n              }\n              else {\n                byte2 = *(byte *)((long)stringPtr + 3);\n                if ((byte2 & 0xc0) != 0x80) goto LAB_0010285d;\n                switch(DAT_0010b7e0) {\n                case 1:\n                  tempUInt = 4;\n                  goto LAB_00102a62;\n                case 3:\n                case 5:\n                  longVar = 4;\n                  goto LAB_00102917;\n                case 4:\n                  iVar = isatty(1);\n                  if (iVar == 0) {\n                    byte2 = *(byte *)((long)stringPtr + 3);\n                  }\n                  else {\n                    *(undefined *)(tempCharPtr2 + 1) = 0;\n                    *tempCharPtr2 = 0x6d37343b31335b1b;\n                    byte2 = *(byte *)((long)stringPtr + 3);\n                    ptr2 = tempCharPtr2 + 1;\n                  }\n                case 2:\n                  tempUInt = 4;\n                  iVar = sprintf((char *)ptr2,\"\\u%02x%02x%02x\",\n                                  (ulong)((*(byte *)stringPtr & 7) << 6 |\n                                         (int)(uint)*(byte *)((long)stringPtr + 1) >> 2 & 0xfU),\n                                  (ulong)((*(byte *)((long)stringPtr + 1) & 3) << 6 |\n                                         (int)(uint)*(byte *)((long)stringPtr + 2) >> 2 & 0xfU),\n                                  (ulong)((*(byte *)((long)stringPtr + 2) & 3) << 6 | byte2 & 0x3f));\n                  ptr2 = (undefined8 *)((long)ptr2 + (long)iVar);\n                  goto LAB_00102a27;\n                default:\n                  tempUInt = 4;\n                }\n              }\n            }\n            tempValue = (ulong)(uint)((int)ptr2 - (int)tempCharPtr2);\n          }\n          else {\nLAB_0010285d:\n            *(byte *)tempCharPtr2 = byte1;\n            tempUInt = 1;\n            tempValue = 1;\n          }\n          tempCharPtr2 = (undefined8 *)((long)tempCharPtr2 + tempValue);\n          stringPtr = (undefined8 *)((long)ptr1 + (ulong)(tempUInt - 1));\n        }\n      }\n      else {\n        *(undefined *)tempCharPtr2 = 0x5e;\n        *(byte *)((long)tempCharPtr2 + 1) = byte1 + 0x40;\n        tempCharPtr2 = (undefined8 *)((long)tempCharPtr2 + 2);\n        stringPtr = ptr1;\n      }\n    }\n    *(undefined *)tempCharPtr2 = 0;\n    stringPtr = ptr2;\n  }\njoined_r0x00104864:\n  if ((((paramArray != (long *)0x0) && (paramArray[2] != 0)) && (DAT_0010b234 != 0)) &&\n     ((tempStrPtr = (char *)(**(code **)(*(long *)(paramValue + 8) + 0x220))\n                                  (paramValue,paramArray[2],0,tempArray), tempStrPtr != (char *)0x0 &&\n      (*tempStrPtr != '\\0')))) {\n    ptr3 = &DAT_001071e0;\n    if ((tempArray[0] == '\\0') && (*(long *)(paramArray[2] + 0x20) != 0x10c2a8)) {\n      ptr3 = &DAT_001071df;\n    }\n    concatenatedString = (undefined8 *)reconcat(concatenatedString,stringPtr,ptr3,tempStrPtr,0);\n    stringPtr = concatenatedString;\n  }\n  printf(formatString,stringPtr);\n  if (strPtr != (char *)0x0) {\n    *strPtr = '@';\n  }\nLAB_001047ba:\n  free(concatenatedString);\n  return;\n}\n\n",
            "called": [
                "FUN_00102739"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104740",
            "calling": [
                "FUN_00103729",
                "FUN_001035a2",
                "FUN_001043d0",
                "FUN_001064b0",
                "FUN_00103b49"
            ],
            "imported": false,
            "current_name": "print_formatted_string_00104740"
        },
        "bfd_check_format_matches": {
            "renaming": {},
            "code": "\nvoid bfd_check_format_matches(void)\n\n{\n  bfd_check_format_matches();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format_matches"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102380",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "bfd_check_format_matches"
        },
        "FUN_00106400": {
            "renaming": {
                "FUN_00106400": "initialize_data_00106400",
                "param_1": "data1",
                "param_2": "data2",
                "param_3": "data3",
                "param_4": "data4",
                "param_5": "data5",
                "param_6": "data6",
                "param_7": "data7",
                "param_8": "data8",
                "local_d8": "size",
                "local_d4": "length",
                "local_d0": "buffer",
                "local_c8": "localBuffer",
                "local_b8": "tempBuffer",
                "local_b0": "offset1",
                "local_a8": "offset2",
                "local_a0": "offset3",
                "local_98": "offset4",
                "local_90": "offset5",
                "local_88": "copy1",
                "local_78": "copy2",
                "local_68": "copy3",
                "local_58": "copy4",
                "local_48": "copy5",
                "local_38": "copy6",
                "local_28": "copy7",
                "local_18": "copy8"
            },
            "code": "\nvoid initializeData_00106400(undefined4 data1,undefined4 data2,undefined4 data3,undefined4 data4,\n                 undefined4 data5,undefined4 data6,undefined4 data7,undefined4 data8,\n                 undefined8 param_9,undefined8 data10,undefined8 data11,undefined8 data12,\n                 undefined8 data13,undefined8 data14)\n\n{\n  char in_AL;\n  undefined4 size;\n  undefined4 length;\n  undefined *buffer;\n  undefined *localBuffer;\n  undefined tempBuffer [8];\n  undefined8 offset1;\n  undefined8 offset2;\n  undefined8 offset3;\n  undefined8 offset4;\n  undefined8 offset5;\n  undefined4 copy1;\n  undefined4 copy2;\n  undefined4 copy3;\n  undefined4 copy4;\n  undefined4 copy5;\n  undefined4 copy6;\n  undefined4 copy7;\n  undefined4 copy8;\n  \n  if (in_AL != '\\0') {\n    copy1 = data1;\n    copy2 = data2;\n    copy3 = data3;\n    copy4 = data4;\n    copy5 = data5;\n    copy6 = data6;\n    copy7 = data7;\n    copy8 = data8;\n  }\n  buffer = &stack0x00000008;\n  size = 8;\n  localBuffer = tempBuffer;\n  length = 0x30;\n  offset1 = data10;\n  offset2 = data11;\n  offset3 = data12;\n  offset4 = data13;\n  offset5 = data14;\n  FUN_001063a0(param_9,&size);\n  return;\n}\n\n",
            "called": [
                "FUN_001063a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00106400",
            "calling": [
                "FUN_001055f0",
                "FUN_001043d0",
                "FUN_00104d5b",
                "FUN_0010249f",
                "FUN_001048e0"
            ],
            "imported": false,
            "current_name": "initialize_data_00106400"
        },
        "bfd_get_arch_size": {
            "renaming": {},
            "code": "\nvoid bfd_get_arch_size(void)\n\n{\n  bfd_get_arch_size();\n  return;\n}\n\n",
            "called": [
                "bfd_get_arch_size"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102220",
            "calling": [
                "FUN_00104670"
            ],
            "imported": false,
            "current_name": "bfd_get_arch_size"
        },
        "ftell": {
            "renaming": {},
            "code": "\n\n\nlong ftell(FILE *__stream)\n\n{\n  long lVar1;\n  \n  lVar1 = ftell(__stream);\n  return lVar1;\n}\n\n",
            "called": [
                "ftell"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102270",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "ftell"
        },
        "FUN_00103533": {
            "renaming": {
                "FUN_00103533": "compare_and_call_00103533",
                "param_1": "array_1",
                "param_2": "array_2",
                "uVar1": "result"
            },
            "code": "\nulong compare_and_call_00103533(undefined8 *array_1,undefined8 *array_2)\n\n{\n  ulong result;\n  \n  if ((ulong)array_1[1] < (ulong)array_2[1]) {\n    return (ulong)(-(uint)(DAT_0010b7f4 == 0) | 1);\n  }\n  if ((ulong)array_2[1] < (ulong)array_1[1]) {\n    return (ulong)((-(uint)(DAT_0010b7f4 == 0) & 2) - 1);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00103571. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  result = (*(code *)(&PTR_FUN_0010acc0)[DAT_0010b7f4])(*array_1,*array_2);\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103533",
            "calling": [
                "FUN_00104d5b"
            ],
            "imported": false,
            "current_name": "compare_and_call_00103533"
        },
        "FUN_00103abc": {
            "renaming": {
                "FUN_00103abc": "FUNC_00103abc"
            },
            "code": "\nvoid FUNC_00103abc(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00103abc",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_00103abc"
        },
        "FUN_0010651a": {
            "renaming": {
                "FUN_0010651a": "initialize_system_0010651a"
            },
            "code": "\nvoid initializeSystem_0010651a(void)\n\n{\n  FUN_001054d0();\n  return;\n}\n\n",
            "called": [
                "FUN_001054d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010651a",
            "calling": [
                "FUN_00103a66",
                "FUN_001064b0"
            ],
            "imported": false,
            "current_name": "initialize_system_0010651a"
        },
        "FUN_00103abd": {
            "renaming": {
                "FUN_00103abd": "FUNC_00103abd"
            },
            "code": "\nvoid FUNC_00103abd(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00103abd",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_00103abd"
        },
        "FUN_00103aba": {
            "renaming": {
                "FUN_00103aba": "FUNC_00103aba"
            },
            "code": "\nvoid FUNC_00103aba(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00103aba",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_00103aba"
        },
        "FUN_00103abb": {
            "renaming": {
                "FUN_00103abb": "FUNC_00103abb"
            },
            "code": "\nvoid FUNC_00103abb(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00103abb",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_00103abb"
        },
        "FUN_001053c0": {
            "renaming": {
                "FUN_001053c0": "print_symbol_info_001053c0",
                "param_1": "symbolInfo",
                "param_2": "printFlag",
                "iVar1": "printWidth",
                "cVar2": "isUndefined",
                "uVar3": "msg",
                "lVar4": "symbolAddr"
            },
            "code": "\nvoid printSymbolInfo_001053c0(long *symbolInfo,undefined8 printFlag)\n\n{\n  int printWidth;\n  char isUndefined;\n  undefined8 msg;\n  long symbolAddr;\n  \n  isUndefined = bfd_is_undefined_symclass((int)*(char *)(*symbolInfo + 8));\n  printWidth = DAT_0010b7a8;\n  if (isUndefined == '\\0') {\n    if (DAT_0010b7f8 == 0) {\n      if ((DAT_0010b7a8 - 0x20U & 0xffffffdf) != 0) {\nLAB_00103603:\n        msg = dcgettext(0,\"Print width has not been initialized (%d)\",5);\n        FUN_00106300(msg,printWidth);\n        goto LAB_00103623;\n      }\n      msg = *(undefined8 *)*symbolInfo;\n    }\n    else {\n      if (DAT_0010b7ec == 0) {\n        if (symbolInfo[2] == 0) {\n          symbolAddr = symbolInfo[1];\n        }\n        else {\n          symbolAddr = *(long *)(symbolInfo[2] + 0x38);\n        }\n        FUN_001054d0(symbolAddr);\n        if (DAT_0010b7ec != 0) {\n          FUN_001035a2();\n          return;\n        }\n        goto LAB_00105423;\n      }\n      msg = *(undefined8 *)*symbolInfo;\n      if ((DAT_0010b7a8 - 0x20U & 0xffffffdf) != 0) goto LAB_00103603;\n    }\n    printf(DAT_0010b7a0,msg);\n    if (DAT_0010b7ec != 0) {\n      FUN_001035a2();\n      return;\n    }\n  }\n  else if (DAT_0010b7a8 == 0x40) {\n    printf(\"        \");\n    printf(\"        \");\n  }\n  else {\n    printf(\"        \");\n  }\nLAB_00105423:\n  printf(\" %c\",(ulong)(uint)(int)*(char *)(*symbolInfo + 8));\n  if (*(char *)(*symbolInfo + 8) != '-') {\n    FUN_00104740(&DAT_0010712c,symbolInfo,0,printFlag);\n    return;\n  }\nLAB_00103623:\n  putchar(0x20);\n  printf(&DAT_0010b238,(ulong)(uint)(int)*(char *)(*symbolInfo + 0x19));\n  putchar(0x20);\n  printf(&DAT_0010b23d,(ulong)(uint)(int)*(short *)(*symbolInfo + 0x1a));\n  printf(\" %5s\",*(undefined8 *)(*symbolInfo + 0x20));\n  FUN_00104740(&DAT_0010712c,symbolInfo,0,printFlag);\n  return;\n}\n\n",
            "called": [
                "printf",
                "FUN_001035a2",
                "FUN_001054d0",
                "bfd_is_undefined_symclass",
                "dcgettext",
                "FUN_00106300"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001053c0",
            "calling": [
                "FUN_00105110"
            ],
            "imported": false,
            "current_name": "print_symbol_info_001053c0"
        },
        "FUN_001064b0": {
            "renaming": {
                "FUN_001064b0": "print_symbol_information_001064b0",
                "param_1": "symbolTableEntry",
                "param_2": "symbolTableSize",
                "cVar1": "isUndefinedSymbol",
                "param_1[2]": "symbolTableEntry[2]",
                "param_1[1]": "symbolTableEntry[1]"
            },
            "code": "\nvoid printSymbolInformation_001064b0(long *symbolTableEntry,undefined8 symbolTableSize)\n\n{\n  char isUndefinedSymbol;\n  \n  FUN_00104740(&DAT_00107363,symbolTableEntry,0,symbolTableSize);\n  printf(\"%c \",(ulong)(uint)(int)*(char *)(*symbolTableEntry + 8));\n  isUndefinedSymbol = bfd_is_undefined_symclass((int)*(char *)(*symbolTableEntry + 8));\n  if (isUndefinedSymbol != '\\0') {\n    printf(\"        \");\n    return;\n  }\n  FUN_001054d0(*(undefined8 *)*symbolTableEntry);\n  putchar(0x20);\n  if (symbolTableEntry[2] == 0) {\n    if (symbolTableEntry[1] != 0) {\n      FUN_0010651a();\n      return;\n    }\n  }\n  else if (*(long *)(symbolTableEntry[2] + 0x38) != 0) {\n    FUN_001054d0();\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "printf",
                "FUN_001054d0",
                "bfd_is_undefined_symclass",
                "putchar",
                "FUN_00103a66",
                "FUN_0010651a",
                "FUN_00104740"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001064b0",
            "calling": [],
            "imported": false,
            "current_name": "print_symbol_information_001064b0"
        },
        "printf": {
            "renaming": {},
            "code": "\n\n\nint printf(char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = printf(__format);\n  return iVar1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102190",
            "calling": [
                "FUN_001047d0",
                "FUN_0010351b",
                "FUN_00103463",
                "FUN_00102f19",
                "FUN_001053c0",
                "FUN_001064b0",
                "FUN_00105110",
                "FUN_00102f7b",
                "FUN_00103729",
                "FUN_001035a2",
                "FUN_001055f0",
                "FUN_001043d0",
                "FUN_001054d0",
                "FUN_00102739",
                "FUN_001036a7",
                "FUN_00103b2b",
                "FUN_001062d0",
                "FUN_00103abf",
                "FUN_00103573",
                "FUN_00102670",
                "FUN_001036e0"
            ],
            "imported": false,
            "current_name": "printf"
        },
        "FUN_00103b49": {
            "renaming": {
                "FUN_00103b49": "initialize_data_00103b49",
                "param_1": "inputData",
                "param_2": "outputData"
            },
            "code": "\nvoid initializeData_00103b49(undefined8 inputData,undefined8 outputData)\n\n{\n  FUN_00104740(&DAT_0010712d,inputData,0,outputData);\n  return;\n}\n\n",
            "called": [
                "FUN_00104740"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103b49",
            "calling": [],
            "imported": false,
            "current_name": "initialize_data_00103b49"
        },
        "FUN_00103abe": {
            "renaming": {
                "FUN_00103abe": "FUNC_00103abe"
            },
            "code": "\nvoid FUNC_00103abe(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00103abe",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_00103abe"
        },
        "FUN_00103abf": {
            "renaming": {
                "FUN_00103abf": "print_undefined_symbols_00103abf",
                "param_1": "moduleName",
                "param_2": "symbolName",
                "pcVar1": "formatString"
            },
            "code": "\nvoid printUndefinedSymbols_00103abf(undefined8 moduleName,undefined8 symbolName)\n\n{\n  char *formatString;\n  \n  formatString = \"\\n\\nUndefined symbols from %s[%s]:\\n\\n\";\n  if (DAT_0010b7e8 == 0) {\n    formatString = \"\\n\\nSymbols from %s[%s]:\\n\\n\";\n  }\n  formatString = (char *)dcgettext(0,formatString,5);\n  printf(formatString,moduleName,symbolName);\n  formatString = \"Name                  Value   Class        Type         Size     Line  Section\\n\\n\";\n  if (DAT_0010b7a8 != 0x20) {\n    formatString = \n    \"Name                  Value           Class        Type         Size             Line  Section\\n\\n\"\n    ;\n  }\n  formatString = (char *)dcgettext(0,formatString,5);\n  printf(formatString);\n  return;\n}\n\n",
            "called": [
                "printf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103abf",
            "calling": [],
            "imported": false,
            "current_name": "print_undefined_symbols_00103abf"
        },
        "FUN_00103bf6": {
            "renaming": {
                "FUN_00103bf6": "calculate_negation_and_return_value_00103bf6",
                "in_RAX": "returnValue",
                "iVar1": "result",
                "auVar2": "modifiedReturnValue"
            },
            "code": "\nundefined  [16] calculateNegationAndReturnValue_00103bf6(void)\n\n{\n  int result;\n  undefined8 returnValue;\n  undefined modifiedReturnValue [16];\n  \n  result = FUN_00104fa0();\n  modifiedReturnValue._0_4_ = -result;\n  modifiedReturnValue._4_4_ = 0;\n  modifiedReturnValue._8_8_ = returnValue;\n  return modifiedReturnValue;\n}\n\n",
            "called": [
                "FUN_00104fa0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103bf6",
            "calling": [],
            "imported": false,
            "current_name": "calculate_negation_and_return_value_00103bf6"
        },
        "FUN_00102450": {
            "renaming": {
                "FUN_00102450": "print_supported_targets_00102450",
                "pcVar2": "message",
                "__ptr": "targetList",
                "plVar3": "currentTarget",
                "lVar1": "target",
                "unaff_RBX": "outputFile",
                "in_stack_00000008": "exitCode"
            },
            "code": "\nvoid printSupportedTargets_00102450(void)\n\n{\n  long target;\n  char *message;\n  long *targetList;\n  FILE *outputFile;\n  long *currentTarget;\n  int exitCode;\n  \n  message = (char *)dcgettext(0,\"Supported targets:\",5);\n  fprintf(outputFile,message);\n  targetList = (long *)bfd_target_list();\n  currentTarget = targetList;\n  while( true ) {\n    target = *currentTarget;\n    currentTarget = currentTarget + 1;\n    if (target == 0) break;\n    fprintf(outputFile,\" %s\");\n  }\n  fputc(10,outputFile);\n  free(targetList);\n  if (exitCode == 0) {\n    message = (char *)dcgettext(0,\"Report bugs to %s.\\n\",5);\n    fprintf(outputFile,message,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  exit(exitCode);\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102450",
            "calling": [
                "FUN_00103ca0"
            ],
            "imported": false,
            "current_name": "print_supported_targets_00102450"
        },
        "FUN_00102c19": {
            "renaming": {
                "FUN_00102c19": "process_lto_object_00102c19",
                "pcVar1": "currentCharPointer",
                "pcVar2": "functionPointer",
                "cVar3": "currentChar",
                "iVar4": "intValue",
                "uVar5": "uintValue",
                "uVar6": "returnValue",
                "lVar7": "longValue",
                "puVar8": "pointer1",
                "lVar9": "longValue1",
                "puVar10": "pointer2",
                "unaff_RBX": "register1",
                "__ptr": "pointer3",
                "unaff_RBP": "register2",
                "puVar11": "pointer4",
                "puVar12": "pointer5",
                "unaff_R12": "register3",
                "puVar13": "pointer6",
                "in_R9": "register4",
                "puVar14": "pointer7",
                "unaff_R13": "register5",
                "unaff_R14": "register6",
                "unaff_R15": "register7",
                "bVar16": "booleanValue",
                "bVar17": "byteValue",
                "unaff_retaddr": "returnAddress",
                "uVar18": "uintValue1",
                "in_stack_00000008": "localVariable1",
                "in_stack_00000010": "localVariable2",
                "in_stack_00000018": "localVariable3",
                "in_stack_00000038": "localVariable4",
                "in_stack_00000040": "localVariable5",
                "in_stack_00000048": "localVariable6"
            },
            "code": "\n\n\nvoid processLTOObject_00102c19(void)\n\n{\n  char *currentCharPointer;\n  code *functionPointer;\n  char currentChar;\n  int intValue;\n  uint uintValue;\n  undefined8 returnValue;\n  long longValue;\n  undefined8 *pointer1;\n  long longValue1;\n  undefined8 *pointer2;\n  undefined8 *register1;\n  undefined8 *pointer3;\n  undefined8 *register2;\n  undefined8 *pointer4;\n  undefined8 *pointer5;\n  undefined8 *in_R8;\n  undefined8 *pointer6;\n  undefined8 *register4;\n  undefined8 *pointer7;\n  undefined8 *register3;\n  undefined8 *puVar15;\n  undefined8 *register5;\n  undefined8 *register6;\n  undefined8 *register7;\n  bool booleanValue;\n  byte byteValue;\n  ulong returnAddress;\n  ulong uintValue1;\n  undefined8 localVariable1;\n  undefined8 *localVariable2;\n  undefined8 *localVariable3;\n  undefined8 localVariable4;\n  void *localVariable5;\n  undefined8 *localVariable6;\n  \n  byteValue = 0;\n  if (_DAT_0010b760 == 0) goto LAB_001049c3;\nLAB_00104a7b:\n  do {\n    if (register1 != register5) {\n      if (register6 == (undefined8 *)0x8) {\n        *register1 = *register5;\n        FUN_001049c0();\n        return;\n      }\n      for (; register6 != (undefined8 *)0x0; register6 = (undefined8 *)((long)register6 + -1)) {\n        *(undefined *)register1 = *(undefined *)register5;\n        register5 = (undefined8 *)((long)register5 + (ulong)byteValue * -2 + 1);\n        register1 = (undefined8 *)((long)register1 + (ulong)byteValue * -2 + 1);\n      }\n      FUN_001049c0();\n      return;\n    }\n    register1 = (undefined8 *)((long)register1 + (long)register6);\nLAB_001049c3:\n    do {\n      do {\n        register5 = (undefined8 *)((long)register5 + (long)register6);\n        puVar15 = register3;\n        pointer5 = register2;\n        if (register3 <= register5) goto LAB_00104b15;\nLAB_001049cf:\n        pointer1 = (undefined8 *)\n                 (**(code **)(register2[1] + 0x270))\n                           (register2,returnAddress & 0xffffffff,register5,register7);\n        pointer4 = register2;\n        pointer5 = register5;\n        puVar15 = register7;\n        if (pointer1 == (undefined8 *)0x0) goto LAB_00102eb0;\n        currentCharPointer = (char *)pointer1[1];\n        if (((currentCharPointer == (char *)0x0) || (*currentCharPointer != '_')) || (currentCharPointer[1] != '_')) {\nLAB_00104a03:\n          if (DAT_0010b7e8 == 0) goto LAB_00104a11;\nLAB_00104ae2:\n          uintValue = (uint)(pointer1[4] == 0x10c2a8);\nLAB_00104af9:\n          if (uintValue != 0) goto LAB_00104a2d;\n          register5 = (undefined8 *)((long)register5 + (long)register6);\n          puVar15 = register3;\n          pointer5 = register2;\n          if (register3 <= register5) {\nLAB_00104b15:\n            register1 = (undefined8 *)((long)register1 - (long)localVariable3);\n            if (register6 == (undefined8 *)0x8) {\n              longValue1 = pointer5[1];\n              pointer4 = (undefined8 *)((long)register1 + 7);\n              if (-1 < (long)register1) {\n                pointer4 = register1;\n              }\n              in_R8 = (undefined8 *)(ulong)DAT_0010b800;\n              functionPointer = *(code **)(longValue1 + 0x208);\n              pointer4 = (undefined8 *)((long)pointer4 >> 3);\n            }\n            else {\n              pointer4 = (undefined8 *)((long)register1 / (long)register6);\n              longValue1 = pointer5[1];\n              functionPointer = *(code **)(longValue1 + 0x208);\n            }\n            register2 = pointer5;\n            if (DAT_0010b800 == 0) {\n              DAT_0010b778 = DAT_0010b80c != 0;\n              DAT_0010b780 = pointer5;\n              DAT_0010b770 = (undefined8 *)(*functionPointer)(pointer5);\n              DAT_0010b768 = (undefined8 *)(**(code **)(pointer5[1] + 0x208))(pointer5);\n              register1 = localVariable6;\n              if ((DAT_0010b770 == (undefined8 *)0x0) || (DAT_0010b768 == (undefined8 *)0x0)) {\n                FUN_00106530(*pointer5);\n                pointer3 = register7;\n                goto LAB_00102d8e;\n              }\n              register3 = (undefined8 *)(ulong)localVariable4._4_4_;\n              if (DAT_0010b7f8 != 0) {\n                uintValue1 = (ulong)(DAT_0010b80c != 0);\n                qsort(localVariable6,(size_t)pointer4,(size_t)register3,FUN_00102fd2);\n                puVar15 = (undefined8 *)xmalloc((long)pointer4 << 4);\n                pointer6 = DAT_0010b770;\n                register2 = DAT_0010b768;\n                register6 = (undefined8 *)((long)pointer4 * (long)register3 + (long)register1);\n                pointer1 = DAT_0010b770;\n                register4 = DAT_0010b768;\n                if (register6 <= register1) goto LAB_00102ec2;\n                pointer4 = (undefined8 *)\n                          (**(code **)(pointer5[1] + 0x270))(pointer5,uintValue1 & 0xffffffff,register1);\n                pointer3 = register1;\n                in_R8 = register3;\n                localVariable2 = puVar15;\n                if (pointer4 == (undefined8 *)0x0) goto LAB_00102eb9;\n                goto LAB_00104e35;\n              }\n              qsort(localVariable6,(size_t)pointer4,(size_t)register3,\n                    (__compar_fn_t)(&PTR_FUN_0010acc0)[(long)DAT_0010b7f4 + (long)DAT_0010b7fc * 2])\n              ;\n              longValue1 = pointer5[1];\n            }\n            pointer3 = (undefined8 *)0x0;\n            do {\n              pointer5 = localVariable6;\n              pointer1 = (undefined8 *)(ulong)DAT_0010b7f8;\n              register6 = (undefined8 *)(ulong)(DAT_0010b80c != 0);\n              if (DAT_0010b7f8 != 0) {\n                puVar15 = (undefined8 *)(**(code **)(longValue1 + 0x208))(register2);\n                if (puVar15 == (undefined8 *)0x0) goto LAB_00102ed2;\n                register1 = pointer3 + (long)pointer4 * 2;\n                pointer4 = pointer3;\n                do {\n                  if (register1 <= pointer4) {\nLAB_00104c75:\n                    if (localVariable5 == (void *)0x0) {\n                      free(localVariable6);\n                      free(pointer3);\n                      return;\n                    }\n                    free(localVariable5);\n                    free(localVariable6);\n                    free(pointer3);\n                    return;\n                  }\n                  pointer1 = puVar15;\n                  longValue1 = (**(code **)(register2[1] + 0x270))(register2,register6,*pointer4);\n                  if (longValue1 == 0) {\n                    FUN_00106530(*register2,0);\nLAB_00102ed2:\n                    pointer5 = (undefined8 *)*register2;\n                    FUN_00106530();\n                    pointer6 = in_R8;\n                    pointer7 = register4;\n                    goto LAB_00102edb;\n                  }\n                  pointer5 = pointer4 + 1;\n                  pointer4 = pointer4 + 2;\n                  FUN_00105110(register2,longValue1,*pointer5,localVariable1);\n                } while( true );\n              }\n              register3 = (undefined8 *)(ulong)localVariable4._4_4_;\n              register7 = (undefined8 *)(**(code **)(longValue1 + 0x208))(register2);\n              if (register7 == (undefined8 *)0x0) {\n                FUN_00106530(*register2);\n                pointer5 = register3;\n                if (DAT_0010b80c == 0) {\n                  longValue1 = (**(code **)(register2[1] + 0x350))(register2);\n                  pointer4 = localVariable6;\n                  puVar15 = register3;\n                  if (longValue1 < 1) {\n                    pointer1 = (undefined8 *)0x0;\n                    register1 = (undefined8 *)0x0;\n                  }\n                  else {\nLAB_00102d8e:\n                    register1 = (undefined8 *)xmalloc();\n                    pointer1 = (undefined8 *)(**(code **)(register2[1] + 0x358))(register2,register1);\n                    pointer5 = puVar15;\n                    if ((long)pointer1 < 0) {\n                      pointer5 = (undefined8 *)*register2;\n                      pointer4 = (undefined8 *)FUN_00106530(pointer5,puVar15);\n                      goto LAB_00102dbe;\n                    }\n                  }\n                }\n                else {\n                  pointer1 = register3;\n                  register1 = localVariable6;\n                  pointer4 = (undefined8 *)0x0;\n                  puVar15 = (undefined8 *)0x0;\n                }\n                register4 = &stack0x00000040;\n                in_R8 = register1;\n                longValue1 = (**(code **)(register2[1] + 0x360))(register2,puVar15,pointer4,pointer1);\n                register3 = pointer5;\n                if (0 < longValue1) {\n                  register3 = (undefined8 *)((long)pointer5 + longValue1);\n                  localVariable6 = (undefined8 *)xrealloc(localVariable6);\n                  longValue = 0;\n                  do {\n                    localVariable6[(long)((long)pointer5 + longValue)] =\n                         (void *)(longValue * 0x30 + (long)localVariable5);\n                    longValue = longValue + 1;\n                  } while (longValue1 != longValue);\n                  localVariable6[(long)((long)pointer5 + longValue1)] = 0;\n                }\n                if ((DAT_0010b80c == 0) && (register1 != (undefined8 *)0x0)) {\n                  free(register1);\n                }\n                if ((*(byte *)((long)register2 + 0x4a) & 0x10) != 0) {\n                  register1 = (undefined8 *)*register2;\n                  DAT_0010b230 = '\\0';\n                  returnValue = dcgettext(0,\"%s: plugin needed to handle lto object\",5);\n                  FUN_00106400(returnValue);\n                }\n                register6 = (undefined8 *)(ulong)localVariable4._4_4_;\n                booleanValue = DAT_0010b80c != 0;\n                pointer4 = (undefined8 *)(ulong)booleanValue;\n                pointer1 = localVariable6;\n                localVariable3 = localVariable6;\n                register7 = (undefined8 *)(**(code **)(register2[1] + 0x208))(register2);\n                if (register7 != (undefined8 *)0x0) goto code_r0x00104992;\n              }\n              else {\n                pointer4 = (undefined8 *)((long)pointer4 * (long)register3 + (long)pointer5);\n                register1 = pointer5;\n                while( true ) {\n                  if (pointer4 <= register1) goto LAB_00104c75;\n                  pointer1 = register7;\n                  longValue1 = (**(code **)(register2[1] + 0x270))(register2,register6,register1);\n                  if (longValue1 == 0) break;\n                  register1 = (undefined8 *)((long)register1 + (long)register3);\n                  FUN_00105110(register2,longValue1,0,localVariable1);\n                }\n                FUN_00106530(*register2,0);\n              }\n              FUN_00106530(*register2);\n              pointer5 = register2;\n              puVar15 = register7;\nLAB_00102eb0:\n              FUN_00106530(*pointer4);\nLAB_00102eb9:\n              FUN_00106530(*pointer5);\nLAB_00102ec2:\n              pointer4 = (undefined8 *)0x0;\n              pointer3 = register1;\n              in_R8 = register3;\n              pointer6 = pointer1;\n              register2 = register4;\n              localVariable2 = puVar15;\nLAB_00104e35:\n              while (register4 = pointer6, pointer3 < register6) {\n                register1 = (undefined8 *)((long)pointer3 + (long)in_R8);\n                if (register1 < register6) {\n                  pointer1 = register2;\n                  pointer6 = in_R8;\n                  pointer7 = register4;\n                  pointer2 = (undefined8 *)(**(code **)(pointer5[1] + 0x270))();\n                  if (pointer2 == (undefined8 *)0x0) {\nLAB_00102edb:\n                    register4 = pointer7;\n                    in_R8 = pointer6;\n                    pointer5 = (undefined8 *)*pointer5;\n                    pointer2 = (undefined8 *)FUN_00106530();\n                  }\n                  else {\n                    pointer1 = (undefined8 *)pointer4[4];\n                    if ((*(uint *)(pointer4 + 3) & 0x200100) == 0) goto LAB_00104e95;\n                  }\n                  longValue1 = pointer4[2];\nLAB_00102ee7:\n                  if (pointer1 == (undefined8 *)pointer2[4]) {\n                    longValue1 = pointer2[2] - longValue1;\n                    pointer6 = register2;\n                    pointer7 = pointer3;\n                    goto LAB_00104ea7;\n                  }\nLAB_00102dc4:\n                  longValue1 = pointer1[8] - longValue1;\n                  pointer6 = register2;\n                  pointer7 = pointer3;\n                }\n                else {\n                  pointer1 = (undefined8 *)pointer4[4];\n                  if ((*(uint *)(pointer4 + 3) & 0x200100) != 0) {\nLAB_00102dbe:\n                    longValue1 = pointer4[2];\n                    pointer2 = (undefined8 *)0x0;\n                    goto LAB_00102dc4;\n                  }\n                  pointer2 = (undefined8 *)0x0;\nLAB_00104e95:\n                  pointer6 = register2;\n                  pointer7 = pointer3;\n                  if (*(int *)(pointer5[1] + 8) == 5) {\n                    longValue1 = pointer4[7];\n                  }\n                  else {\n                    longValue1 = pointer4[2];\n                    if ((*(byte *)((long)pointer1 + 0x25) & 0x10) == 0) {\n                      if (register1 < register6) goto LAB_00102ee7;\n                      goto LAB_00102dc4;\n                    }\n                  }\n                }\nLAB_00104ea7:\n                pointer4 = pointer2;\n                pointer3 = register1;\n                register2 = register4;\n                if (longValue1 != 0) {\n                  *puVar15 = pointer7;\n                  puVar15[1] = longValue1;\n                  puVar15 = puVar15 + 2;\n                }\n              }\n              pointer4 = (undefined8 *)((long)puVar15 - (long)localVariable2 >> 4);\n              qsort(localVariable2,(size_t)pointer4,0x10,FUN_00103533);\n              longValue1 = pointer5[1];\n              register1 = pointer3;\n              register2 = pointer5;\n              pointer3 = localVariable2;\n            } while( true );\n          }\n          goto LAB_001049cf;\n        }\n        intValue = strcmp(currentCharPointer + (currentCharPointer[2] == '_'),\"__gnu_lto_slim\");\n        localVariable2 = pointer1;\n        if (intValue == 0) {\n          if (DAT_0010b230 != '\\0') {\n            localVariable2 = (undefined8 *)*register2;\n            DAT_0010b230 = '\\0';\n            returnValue = dcgettext(0,\"%s: plugin needed to handle lto object\",5);\n            FUN_00106400(returnValue,localVariable2);\n          }\n          goto LAB_00104a03;\n        }\n        if (DAT_0010b7e8 != 0) goto LAB_00104ae2;\nLAB_00104a11:\n        if (DAT_0010b808 == 0) {\n          if (DAT_0010b7d8 == 0) goto LAB_00104a2d;\n          uintValue = (*(uint *)(pointer1 + 3) >> 7 ^ 1) & 1;\n          goto LAB_00104af9;\n        }\n        if ((((*(uint *)(pointer1 + 3) & 0x800082) == 0) && (pointer1[4] != 0x10c2a8)) &&\n           ((*(byte *)(pointer1[4] + 0x25) & 0x10) == 0)) goto LAB_001049c3;\nLAB_00104a2d:\n        if (DAT_0010b81c != 0) {\n          if (DAT_0010b7f8 == 0) goto LAB_00104a53;\nFUN_00104d5b:\n          if ((pointer1[4] != 0x10c2a8) && (pointer1[4] != 0x10c3c0)) goto LAB_00104cba;\n          goto LAB_001049c3;\n        }\n      } while ((*(byte *)(pointer1 + 3) & 4) != 0);\n      if (DAT_0010b7f8 != 0) goto FUN_00104d5b;\nLAB_00104a53:\n      register4 = (undefined8 *)(ulong)DAT_0010b7e4;\n      if (DAT_0010b7e4 == 0) {\n        currentChar = (**(code **)(register2[1] + 0x230))(register2);\n        if (currentChar != '\\0') {\n          processLTOObject_00102c19();\n          return;\n        }\n        goto LAB_00104a7b;\n      }\n    } while (pointer1[4] == 0x10c2a8);\nLAB_00104cba:\n    currentChar = (**(code **)(register2[1] + 0x230))(register2);\n    if (currentChar != '\\0') {\n      processLTOObject_00102c19();\n      return;\n    }\n  } while( true );\ncode_r0x00104992:\n  puVar15 = (undefined8 *)((long)register3 * (long)register6);\n  register3 = (undefined8 *)((long)localVariable3 + (long)puVar15);\n  register1 = localVariable3;\n  pointer5 = register2;\n  if (localVariable3 < register3) goto code_r0x001049aa;\n  goto LAB_00104b15;\ncode_r0x001049aa:\n  returnAddress = (ulong)booleanValue;\n  register5 = localVariable3;\n  goto LAB_001049cf;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102c19",
            "calling": [
                "FUN_00104d5b"
            ],
            "imported": false,
            "current_name": "process_lto_object_00102c19"
        },
        "FUN_00106530": {
            "renaming": {
                "FUN_00106530": "print_bfd_error_message_00106530",
                "iVar1": "bfdError",
                "uVar2": "errorMessage",
                "lVar3": "flag",
                "in_R10": "additionalInfo"
            },
            "code": "\n\n\nvoid printBfdErrorMessage_00106530(void)\n\n{\n  int bfdError;\n  undefined8 errorMessage;\n  long flag;\n  undefined8 additionalInfo;\n  \n  FUN_00106540();\n  flag = 1;\n  xexit();\n  bfdError = bfd_get_error();\n  if (bfdError == 0) {\n    errorMessage = dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    errorMessage = bfd_errmsg(bfdError);\n  }\n  fflush(_stdout);\n  if (flag != 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",DAT_0010b820,flag,errorMessage,additionalInfo);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",DAT_0010b820,errorMessage,additionalInfo);\n  return;\n}\n\n",
            "called": [
                "FUN_00106540",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00106530",
            "calling": [
                "FUN_00103463",
                "FUN_001043d0",
                "FUN_00103c00",
                "FUN_00104d5b",
                "FUN_001048e0",
                "FUN_00105110",
                "FUN_00102fc3",
                "FUN_00102f9f",
                "FUN_00102fd2"
            ],
            "imported": false,
            "current_name": "print_bfd_error_message_00106530"
        },
        "FUN_00105560": {
            "renaming": {
                "FUN_00105560": "FUNC_00105560"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00105584) */\n/* WARNING: Removing unreachable block (ram,0x00105590) */\n\nvoid FUNC_00105560(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_registerTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00105560",
            "calling": [
                "_INIT_0"
            ],
            "imported": false,
            "current_name": "FUNC_00105560"
        },
        "qsort": {
            "renaming": {},
            "code": "\n\n\nvoid qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)\n\n{\n  qsort(__base,__nmemb,__size,__compar);\n  return;\n}\n\n",
            "called": [
                "qsort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020b0",
            "calling": [
                "FUN_00104d5b"
            ],
            "imported": false,
            "current_name": "qsort"
        },
        "fclose": {
            "renaming": {},
            "code": "\n\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fclose(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fclose"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102130",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "fclose"
        },
        "bfd_errmsg": {
            "renaming": {},
            "code": "\nvoid bfd_errmsg(void)\n\n{\n  bfd_errmsg();\n  return;\n}\n\n",
            "called": [
                "bfd_errmsg"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102390",
            "calling": [
                "FUN_00106540",
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "bfd_errmsg"
        },
        "FUN_0010268b": {
            "renaming": {
                "FUN_0010268b": "print_encoded_string_0010268b",
                "puVar1": "currentChar",
                "bVar2": "currentByte",
                "bVar3": "nextByte",
                "iVar4": "isTTY",
                "sVar5": "stringLength",
                "puVar6": "outputPointer",
                "pcVar7": "formatString",
                "uVar8": "loopCounter",
                "uVar9": "braceCharacter",
                "puVar10": "concatenationString",
                "puVar11": "inputPointer",
                "unaff_RBP": "stackBase",
                "puVar12": "resultPointer",
                "unaff_R12": "endMarker",
                "unaff_R13": "inputString",
                "lVar13": "literalLength",
                "uVar14": "byteCount",
                "unaff_R14": "formatSpecifier",
                "unaff_R15": "stackPointer",
                "bVar15": "exitFlag",
                "__s": "tempString",
                "in_stack_00000038": "hexFormat",
                "_sch_istable": "charTable",
                "stack0x00000038": "stackVariable"
            },
            "code": "\n\n\nvoid printEncodedString_0010268b(void)\n\n{\n  undefined8 *currentChar;\n  byte currentByte;\n  byte nextByte;\n  int isTTY;\n  size_t stringLength;\n  undefined8 *outputPointer;\n  char *formatString;\n  ulong loopCounter;\n  undefined8 braceCharacter;\n  undefined *concatenationString;\n  undefined8 *inputPointer;\n  long stackBase;\n  undefined8 *resultPointer;\n  undefined *endMarker;\n  undefined8 *inputString;\n  long literalLength;\n  uint byteCount;\n  char *formatSpecifier;\n  long stackPointer;\n  byte exitFlag;\n  char *tempString;\n  undefined8 hexFormat;\n  \n  exitFlag = 0;\n  resultPointer = inputString;\n  if (DAT_0010b7e0 != 0) {\n    do {\n      currentByte = *(byte *)resultPointer;\n      if (currentByte == 0) goto LAB_0010485e;\n    } while ((((&charTable)[(ulong)currentByte * 2] & 2) == 0) &&\n            (resultPointer = (undefined8 *)((long)resultPointer + 1), currentByte < 0xc0));\n    stringLength = strlen((char *)inputString);\n    resultPointer = DAT_0010b790;\n    inputPointer = inputString;\n    if (_DAT_0010b798 < stringLength * 9) {\n      free(DAT_0010b790);\n      stringLength = strlen((char *)inputString);\n      _DAT_0010b798 = stringLength * 9;\n      DAT_0010b790 = (undefined8 *)xmalloc(_DAT_0010b798 + 1);\n      resultPointer = DAT_0010b790;\n    }\n    while( true ) {\n      inputString = DAT_0010b790;\n      currentByte = *(byte *)inputPointer;\n      currentChar = (undefined8 *)((long)inputPointer + 1);\n      if (currentByte == 0) break;\n      if (((&charTable)[(ulong)currentByte * 2] & 2) == 0) {\n        if ((currentByte < 0xc0) || (DAT_0010b7e0 == 0)) {\n          *(byte *)resultPointer = currentByte;\n          resultPointer = (undefined8 *)((long)resultPointer + 1);\n          inputPointer = currentChar;\n        }\n        else {\n          nextByte = *(byte *)((long)inputPointer + 1);\n          if ((nextByte & 0xc0) == 0x80) {\n            outputPointer = resultPointer;\n            if ((currentByte & 0x20) == 0) {\n              switch(DAT_0010b7e0) {\n              case 1:\n                byteCount = 2;\n                goto LAB_00102a62;\n              case 3:\n              case 5:\n                literalLength = 2;\n                goto LAB_00102917;\n              case 4:\n                isTTY = isatty(1);\n                if (isTTY == 0) {\n                  nextByte = *(byte *)((long)inputPointer + 1);\n                }\n                else {\n                  *(undefined *)(resultPointer + 1) = 0;\n                  *resultPointer = 0x6d37343b31335b1b;\n                  nextByte = *(byte *)((long)inputPointer + 1);\n                  outputPointer = resultPointer + 1;\n                }\n              case 2:\n                byteCount = 2;\n                sprintf((char *)outputPointer,\"\\u%02x%02x\",(ulong)((int)(uint)*(byte *)inputPointer >> 2 & 7),\n                        (ulong)((*(byte *)inputPointer & 3) << 6 | nextByte & 0x3f));\n                outputPointer = (undefined8 *)((long)outputPointer + 6);\n                goto LAB_00102a27;\n              default:\n                byteCount = 2;\n              }\n            }\n            else {\n              nextByte = *(byte *)((long)inputPointer + 2);\n              if ((nextByte & 0xc0) != 0x80) goto LAB_0010285d;\n              if ((currentByte & 0x10) == 0) {\n                switch(DAT_0010b7e0) {\n                case 1:\n                  byteCount = 3;\nLAB_00102a62:\n                  for (loopCounter = (ulong)byteCount; loopCounter != 0; loopCounter = loopCounter - 1) {\n                    *(undefined *)outputPointer = *(undefined *)inputPointer;\n                    inputPointer = (undefined8 *)((long)inputPointer + (ulong)exitFlag * -2 + 1);\n                    outputPointer = (undefined8 *)((long)outputPointer + (ulong)exitFlag * -2 + 1);\n                  }\n                  break;\n                case 3:\n                case 5:\n                  literalLength = 3;\nLAB_00102917:\n                  braceCharacter = 0x7b;\n                  if (DAT_0010b7e0 == 3) {\n                    braceCharacter = 0x3c;\n                  }\n                  sprintf((char *)resultPointer,\"%c\",braceCharacter);\n                  *(undefined *)((long)resultPointer + 3) = 0;\n                  outputPointer = (undefined8 *)(literalLength + (long)inputPointer);\n                  *(undefined2 *)((long)resultPointer + 1) = 0x7830;\n                  formatString = (char *)((long)resultPointer + 3);\n                  do {\n                    tempString = formatString;\n                    currentByte = *(byte *)inputPointer;\n                    inputPointer = (undefined8 *)((long)inputPointer + 1);\n                    sprintf(tempString,\"%02x\",(ulong)currentByte);\n                    formatString = tempString + 2;\n                  } while (inputPointer != outputPointer);\n                  braceCharacter = 0x7d;\n                  if (DAT_0010b7e0 == 3) {\n                    braceCharacter = 0x3e;\n                  }\n                  byteCount = (uint)literalLength;\n                  sprintf(tempString + 2,\"%c\",braceCharacter);\n                  outputPointer = (undefined8 *)(tempString + 3);\n                  break;\n                case 4:\n                  isTTY = isatty(1);\n                  if (isTTY == 0) {\n                    nextByte = *(byte *)((long)inputPointer + 2);\n                  }\n                  else {\n                    *(undefined *)(resultPointer + 1) = 0;\n                    *resultPointer = 0x6d37343b31335b1b;\n                    nextByte = *(byte *)((long)inputPointer + 2);\n                    outputPointer = resultPointer + 1;\n                  }\n                case 2:\n                  byteCount = 3;\n                  sprintf((char *)outputPointer,\"\\u%02x%02x\",\n                          (ulong)((uint)(((ulong)*(byte *)inputPointer & 0xf) << 4) |\n                                 (int)(uint)*(byte *)((long)inputPointer + 1) >> 2 & 0xfU),\n                          (ulong)((*(byte *)((long)inputPointer + 1) & 3) << 6 | nextByte & 0x3f));\n                  outputPointer = (undefined8 *)((long)outputPointer + 6);\nLAB_00102a27:\n                  if ((DAT_0010b7e0 == 4) && (isTTY = isatty(1), isTTY != 0)) {\n                    *(undefined4 *)outputPointer = 0x6d305b1b;\n                    outputPointer = (undefined8 *)((long)outputPointer + 4);\n                    *(undefined *)outputPointer = 0;\n                  }\n                  break;\n                default:\n                  byteCount = 3;\n                }\n              }\n              else {\n                if ((*(byte *)((long)inputPointer + 3) & 0xc0) != 0x80) goto LAB_0010285d;\n                switch(DAT_0010b7e0) {\n                case 1:\n                  byteCount = 4;\n                  goto LAB_00102a62;\n                case 3:\n                case 5:\n                  literalLength = 4;\n                  goto LAB_00102917;\n                case 4:\n                  isTTY = isatty(1);\n                  if (isTTY != 0) {\n                    *(undefined *)(resultPointer + 1) = 0;\n                    *resultPointer = 0x6d37343b31335b1b;\n                    outputPointer = resultPointer + 1;\n                  }\n                case 2:\n                  byteCount = 4;\n                  isTTY = sprintf((char *)outputPointer,\"\\u%02x%02x%02x\",\n                                  (ulong)((*(byte *)inputPointer & 7) << 6 |\n                                         (int)(uint)*(byte *)((long)inputPointer + 1) >> 2 & 0xfU),\n                                  (ulong)((*(byte *)((long)inputPointer + 1) & 3) << 6 |\n                                         (int)(uint)*(byte *)((long)inputPointer + 2) >> 2 & 0xfU));\n                  outputPointer = (undefined8 *)((long)outputPointer + (long)isTTY);\n                  goto LAB_00102a27;\n                default:\n                  byteCount = 4;\n                }\n              }\n            }\n            loopCounter = (ulong)(uint)((int)outputPointer - (int)resultPointer);\n          }\n          else {\nLAB_0010285d:\n            *(byte *)resultPointer = currentByte;\n            byteCount = 1;\n            loopCounter = 1;\n          }\n          resultPointer = (undefined8 *)((long)resultPointer + loopCounter);\n          inputPointer = (undefined8 *)((long)currentChar + (ulong)(byteCount - 1));\n        }\n      }\n      else {\n        *(undefined *)resultPointer = 0x5e;\n        *(byte *)((long)resultPointer + 1) = currentByte + 0x40;\n        resultPointer = (undefined8 *)((long)resultPointer + 2);\n        inputPointer = currentChar;\n      }\n    }\n    *(undefined *)resultPointer = 0;\n  }\nLAB_0010485e:\n  resultPointer = (undefined8 *)0x0;\n  if ((((stackBase != 0) && (*(long *)(stackBase + 0x10) != 0)) && (DAT_0010b234 != 0)) &&\n     ((formatString = (char *)(**(code **)(*(long *)(stackPointer + 8) + 0x220))\n                                  (stackPointer,*(long *)(stackBase + 0x10),0,\n                                   (long)&stackVariable + 7), formatString != (char *)0x0 &&\n      (*formatString != '\\0')))) {\n    concatenationString = &DAT_001071e0;\n    if ((hexFormat._7_1_ == '\\0') &&\n       (*(long *)(*(long *)(stackBase + 0x10) + 0x20) != 0x10c2a8)) {\n      concatenationString = &DAT_001071df;\n    }\n    resultPointer = (undefined8 *)reconcat(0,inputString,concatenationString,formatString,0);\n    inputString = resultPointer;\n  }\n  printf(formatSpecifier,inputString);\n  if (endMarker != (undefined *)0x0) {\n    *endMarker = 0x40;\n  }\n  free(resultPointer);\n  return;\n}\n\n",
            "called": [
                "FUN_001047d0",
                "isatty",
                "xmalloc",
                "free",
                "sprintf",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010268b",
            "calling": [
                "FUN_00102739"
            ],
            "imported": false,
            "current_name": "print_encoded_string_0010268b"
        },
        "FUN_00103bec": {
            "renaming": {
                "FUN_00103bec": "calculate_result_00103bec",
                "in_RAX": "inputValue",
                "iVar1": "result",
                "auVar2": "outputArray"
            },
            "code": "\nundefined  [16] calculateResult_00103bec(void)\n\n{\n  int result;\n  undefined8 inputValue;\n  undefined outputArray [16];\n  \n  result = FUN_00105050();\n  outputArray._0_4_ = -result;\n  outputArray._4_4_ = 0;\n  outputArray._8_8_ = inputValue;\n  return outputArray;\n}\n\n",
            "called": [
                "FUN_00105050"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103bec",
            "calling": [],
            "imported": false,
            "current_name": "calculate_result_00103bec"
        },
        "bfd_get_next_mapent": {
            "renaming": {},
            "code": "\nvoid bfd_get_next_mapent(void)\n\n{\n  bfd_get_next_mapent();\n  return;\n}\n\n",
            "called": [
                "bfd_get_next_mapent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102430",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "bfd_get_next_mapent"
        },
        "FUN_001063a0": {
            "renaming": {
                "FUN_001063a0": "print_error_message_001063a0",
                "param_1": "message",
                "param_2": "args",
                "_stdout": "standardOutput",
                "_stderr": "standardError"
            },
            "code": "\n\n\nvoid printErrorMessage_001063a0(char *message,__gnuc_va_list args)\n\n{\n  fflush(standardOutput);\n  fprintf(standardError,\"%s: \",DAT_0010b820);\n  vfprintf(standardError,message,args);\n  putc(10,standardError);\n  return;\n}\n\n",
            "called": [
                "fflush",
                "putc",
                "fprintf",
                "vfprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001063a0",
            "calling": [
                "FUN_00106400",
                "FUN_00106300"
            ],
            "imported": false,
            "current_name": "print_error_message_001063a0"
        },
        "FUN_00102739": {
            "renaming": {
                "FUN_00102739": "print_demangled_string_00102739",
                "puVar1": "ptr1",
                "bVar2": "byte1",
                "bVar3": "byte2",
                "iVar4": "intVar",
                "sVar5": "size",
                "pcVar6": "charPtr",
                "puVar7": "ptr2",
                "pcVar8": "charPtr2",
                "__ptr": "resultPtr",
                "uVar9": "ulongVar",
                "uVar10": "ulongVar2",
                "puVar11": "ptr3",
                "unaff_RBP": "var1",
                "puVar12": "ptr4",
                "unaff_R13": "ptr5",
                "lVar13": "longVar",
                "uVar14": "uintVar",
                "unaff_R14": "charPtr3",
                "unaff_R15": "longVar2",
                "bVar15": "byte3",
                "__s": "charPtr4",
                "in_stack_00000038": "inputVar"
            },
            "code": "\n\n\nvoid printDemangledString_00102739(void)\n\n{\n  undefined8 *ptr1;\n  byte byte1;\n  byte byte2;\n  int intVar;\n  size_t size;\n  char *charPtr;\n  undefined8 *ptr2;\n  char *charPtr2;\n  undefined8 *resultPtr;\n  ulong ulongVar;\n  undefined8 ulongVar2;\n  undefined *ptr3;\n  long var1;\n  undefined8 *ptr4;\n  undefined8 *ptr5;\n  long longVar;\n  uint uintVar;\n  char *charPtr3;\n  long longVar2;\n  byte byte3;\n  char *charPtr4;\n  undefined8 inputVar;\n  \n  byte3 = 0;\n  ptr4 = ptr5;\n  if (*(int *)(*(long *)(longVar2 + 8) + 8) != 5) {\n    if (DAT_0010b814 != 0) {\n      charPtr = (char *)0x0;\n      goto LAB_0010482b;\n    }\n    charPtr = (char *)0x0;\n    if (DAT_0010b7e0 == 0) {\nLAB_00104794:\n      resultPtr = (undefined8 *)0x0;\n    }\n    else {\n      resultPtr = (undefined8 *)0x0;\n      if (ptr5 != (undefined8 *)0x0) goto LAB_0010269d;\n      resultPtr = (undefined8 *)0x0;\n      ptr5 = (undefined8 *)0x1073a6;\n    }\n    goto joined_r0x00104799;\n  }\n  charPtr = strchr((char *)ptr5,0x40);\n  if (charPtr == (char *)0x0) {\n    if (DAT_0010b814 != 0) goto LAB_0010482b;\n    if (DAT_0010b7e0 == 0) {\n      if (var1 == 0) {\n        resultPtr = (undefined8 *)0x0;\n        printf(charPtr3);\n      }\n      else {\n        if (*(long *)(var1 + 0x10) != 0) {\n          FUN_001047d0();\n          return;\n        }\n        resultPtr = (undefined8 *)0x0;\n        printf(charPtr3);\n      }\n      goto LAB_001047ba;\n    }\nLAB_00102698:\n    ptr4 = ptr5;\n    resultPtr = (undefined8 *)0x0;\nLAB_0010269d:\n    do {\n      byte1 = *(byte *)ptr4;\n      if (byte1 == 0) goto joined_r0x00104799;\n    } while ((((&_sch_istable)[(ulong)byte1 * 2] & 2) == 0) &&\n            (ptr4 = (undefined8 *)((long)ptr4 + 1), byte1 < 0xc0));\n    size = strlen((char *)ptr5);\n    ptr4 = DAT_0010b790;\n    if (_DAT_0010b798 < size * 9) {\n      free(DAT_0010b790);\n      size = strlen((char *)ptr5);\n      _DAT_0010b798 = size * 9;\n      DAT_0010b790 = (undefined8 *)xmalloc(_DAT_0010b798 + 1);\n      ptr4 = DAT_0010b790;\n    }\n    while( true ) {\n      ptr2 = DAT_0010b790;\n      byte1 = *(byte *)ptr5;\n      ptr1 = (undefined8 *)((long)ptr5 + 1);\n      if (byte1 == 0) break;\n      if (((&_sch_istable)[(ulong)byte1 * 2] & 2) == 0) {\n        if ((byte1 < 0xc0) || (DAT_0010b7e0 == 0)) {\n          *(byte *)ptr4 = byte1;\n          ptr4 = (undefined8 *)((long)ptr4 + 1);\n          ptr5 = ptr1;\n        }\n        else {\n          byte2 = *(byte *)((long)ptr5 + 1);\n          if ((byte2 & 0xc0) == 0x80) {\n            ptr2 = ptr4;\n            if ((byte1 & 0x20) == 0) {\n              switch(DAT_0010b7e0) {\n              case 1:\n                uintVar = 2;\n                goto LAB_00102a62;\n              case 3:\n              case 5:\n                longVar = 2;\n                goto LAB_00102917;\n              case 4:\n                intVar = isatty(1);\n                if (intVar == 0) {\n                  byte2 = *(byte *)((long)ptr5 + 1);\n                }\n                else {\n                  *(undefined *)(ptr4 + 1) = 0;\n                  *ptr4 = 0x6d37343b31335b1b;\n                  byte2 = *(byte *)((long)ptr5 + 1);\n                  ptr2 = ptr4 + 1;\n                }\n              case 2:\n                uintVar = 2;\n                sprintf((char *)ptr2,\"\\u%02x%02x\",(ulong)((int)(uint)*(byte *)ptr5 >> 2 & 7)\n                        ,(ulong)((*(byte *)ptr5 & 3) << 6 | byte2 & 0x3f));\n                ptr2 = (undefined8 *)((long)ptr2 + 6);\n                goto LAB_00102a27;\n              default:\n                uintVar = 2;\n              }\n            }\n            else {\n              byte2 = *(byte *)((long)ptr5 + 2);\n              if ((byte2 & 0xc0) != 0x80) goto LAB_0010285d;\n              if ((byte1 & 0x10) == 0) {\n                switch(DAT_0010b7e0) {\n                case 1:\n                  uintVar = 3;\nLAB_00102a62:\n                  for (ulongVar = (ulong)uintVar; ulongVar != 0; ulongVar = ulongVar - 1) {\n                    *(undefined *)ptr2 = *(undefined *)ptr5;\n                    ptr5 = (undefined8 *)((long)ptr5 + (ulong)byte3 * -2 + 1);\n                    ptr2 = (undefined8 *)((long)ptr2 + (ulong)byte3 * -2 + 1);\n                  }\n                  break;\n                case 3:\n                case 5:\n                  longVar = 3;\nLAB_00102917:\n                  ulongVar2 = 0x7b;\n                  if (DAT_0010b7e0 == 3) {\n                    ulongVar2 = 0x3c;\n                  }\n                  sprintf((char *)ptr4,\"%c\",ulongVar2);\n                  *(undefined *)((long)ptr4 + 3) = 0;\n                  ptr2 = (undefined8 *)(longVar + (long)ptr5);\n                  *(undefined2 *)((long)ptr4 + 1) = 0x7830;\n                  charPtr2 = (char *)((long)ptr4 + 3);\n                  do {\n                    charPtr4 = charPtr2;\n                    byte1 = *(byte *)ptr5;\n                    ptr5 = (undefined8 *)((long)ptr5 + 1);\n                    sprintf(charPtr4,\"%02x\",(ulong)byte1);\n                    charPtr2 = charPtr4 + 2;\n                  } while (ptr5 != ptr2);\n                  ulongVar2 = 0x7d;\n                  if (DAT_0010b7e0 == 3) {\n                    ulongVar2 = 0x3e;\n                  }\n                  uintVar = (uint)longVar;\n                  sprintf(charPtr4 + 2,\"%c\",ulongVar2);\n                  ptr2 = (undefined8 *)(charPtr4 + 3);\n                  break;\n                case 4:\n                  intVar = isatty(1);\n                  if (intVar == 0) {\n                    byte2 = *(byte *)((long)ptr5 + 2);\n                  }\n                  else {\n                    *(undefined *)(ptr4 + 1) = 0;\n                    *ptr4 = 0x6d37343b31335b1b;\n                    byte2 = *(byte *)((long)ptr5 + 2);\n                    ptr2 = ptr4 + 1;\n                  }\n                case 2:\n                  uintVar = 3;\n                  sprintf((char *)ptr2,\"\\u%02x%02x\",\n                          (ulong)((uint)(((ulong)*(byte *)ptr5 & 0xf) << 4) |\n                                 (int)(uint)*(byte *)((long)ptr5 + 1) >> 2 & 0xfU),\n                          (ulong)((*(byte *)((long)ptr5 + 1) & 3) << 6 | byte2 & 0x3f));\n                  ptr2 = (undefined8 *)((long)ptr2 + 6);\nLAB_00102a27:\n                  if ((DAT_0010b7e0 == 4) && (intVar = isatty(1), intVar != 0)) {\n                    *(undefined4 *)ptr2 = 0x6d305b1b;\n                    ptr2 = (undefined8 *)((long)ptr2 + 4);\n                    *(undefined *)ptr2 = 0;\n                  }\n                  break;\n                default:\n                  uintVar = 3;\n                }\n              }\n              else {\n                if ((*(byte *)((long)ptr5 + 3) & 0xc0) != 0x80) goto LAB_0010285d;\n                switch(DAT_0010b7e0) {\n                case 1:\n                  uintVar = 4;\n                  goto LAB_00102a62;\n                case 3:\n                case 5:\n                  longVar = 4;\n                  goto LAB_00102917;\n                case 4:\n                  intVar = isatty(1);\n                  if (intVar != 0) {\n                    *(undefined *)(ptr4 + 1) = 0;\n                    *ptr4 = 0x6d37343b31335b1b;\n                    ptr2 = ptr4 + 1;\n                  }\n                case 2:\n                  uintVar = 4;\n                  intVar = sprintf((char *)ptr2,\"\\u%02x%02x%02x\",\n                                  (ulong)((*(byte *)ptr5 & 7) << 6 |\n                                         (int)(uint)*(byte *)((long)ptr5 + 1) >> 2 & 0xfU),\n                                  (ulong)((*(byte *)((long)ptr5 + 1) & 3) << 6 |\n                                         (int)(uint)*(byte *)((long)ptr5 + 2) >> 2 & 0xfU));\n                  ptr2 = (undefined8 *)((long)ptr2 + (long)intVar);\n                  goto LAB_00102a27;\n                default:\n                  uintVar = 4;\n                }\n              }\n            }\n            ulongVar = (ulong)(uint)((int)ptr2 - (int)ptr4);\n          }\n          else {\nLAB_0010285d:\n            *(byte *)ptr4 = byte1;\n            uintVar = 1;\n            ulongVar = 1;\n          }\n          ptr4 = (undefined8 *)((long)ptr4 + ulongVar);\n          ptr5 = (undefined8 *)((long)ptr1 + (ulong)(uintVar - 1));\n        }\n      }\n      else {\n        *(undefined *)ptr4 = 0x5e;\n        *(byte *)((long)ptr4 + 1) = byte1 + 0x40;\n        ptr4 = (undefined8 *)((long)ptr4 + 2);\n        ptr5 = ptr1;\n      }\n    }\n    *(undefined *)ptr4 = 0;\n    ptr5 = ptr2;\n  }\n  else {\n    *charPtr = '\\0';\n    if (DAT_0010b814 == 0) {\n      if (DAT_0010b7e0 == 0) goto LAB_00104794;\n      resultPtr = (undefined8 *)0x0;\n      goto LAB_0010269d;\n    }\nLAB_0010482b:\n    if ((*(char *)ptr5 == '\\0') ||\n       (ptr4 = (undefined8 *)bfd_demangle(), ptr4 == (undefined8 *)0x0)) {\n      if (DAT_0010b7e0 != 0) goto LAB_00102698;\n      resultPtr = (undefined8 *)0x0;\n    }\n    else {\n      ptr5 = ptr4;\n      resultPtr = ptr4;\n      if (DAT_0010b7e0 != 0) goto LAB_0010269d;\n    }\n  }\njoined_r0x00104799:\n  if ((((var1 != 0) && (*(long *)(var1 + 0x10) != 0)) && (DAT_0010b234 != 0)) &&\n     ((charPtr2 = (char *)(**(code **)(*(long *)(longVar2 + 8) + 0x220))\n                                  (longVar2,*(long *)(var1 + 0x10),0,\n                                   (long)&stack0x00000038 + 7), charPtr2 != (char *)0x0 &&\n      (*charPtr2 != '\\0')))) {\n    ptr3 = &DAT_001071e0;\n    if ((inputVar._7_1_ == '\\0') &&\n       (*(long *)(*(long *)(var1 + 0x10) + 0x20) != 0x10c2a8)) {\n      ptr3 = &DAT_001071df;\n    }\n    resultPtr = (undefined8 *)reconcat(resultPtr,ptr5,ptr3,charPtr2,0);\n    ptr5 = resultPtr;\n  }\n  printf(charPtr3,ptr5);\n  if (charPtr != (char *)0x0) {\n    *charPtr = '@';\n  }\nLAB_001047ba:\n  free(resultPtr);\n  return;\n}\n\n",
            "called": [
                "printf",
                "FUN_001047d0",
                "FUN_0010268b",
                "bfd_demangle",
                "strchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102739",
            "calling": [
                "FUN_00104740"
            ],
            "imported": false,
            "current_name": "print_demangled_string_00102739"
        },
        "FUN_00105050": {
            "renaming": {
                "FUN_00105050": "compare_and_verify_00105050",
                "param_1": "input_param1",
                "param_2": "input_param2",
                "__s": "string1",
                "__s_00": "string2",
                "lVar3": "length1",
                "uVar4": "flags",
                "sVar5": "length_string1",
                "sVar6": "length_string2",
                "pcVar7": "substr1",
                "pcVar8": "substr2",
                "lVar9": "result1",
                "lVar10": "result2",
                "uVar11": "comparison_result",
                "uVar12": "temp1",
                "uVar13": "temp2",
                "uVar14": "temp3",
                "uVar15": "temp_param",
                "unaff_R13": "temp_register"
            },
            "code": "\nulong compareAndVerify_00105050(undefined8 input_param1,undefined8 input_param2)\n\n{\n  char cVar1;\n  ulong uVar2;\n  char *string1;\n  char *string2;\n  long length1;\n  uint flags;\n  size_t length_string1;\n  size_t length_string2;\n  char *substr1;\n  char *substr2;\n  long result1;\n  long result2;\n  ulong comparison_result;\n  ulong temp1;\n  ulong temp2;\n  ulong temp3;\n  undefined8 temp_param;\n  long temp_register;\n  bool bVar16;\n  \n  result1 = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,DAT_0010b778,input_param1,DAT_0010b770);\n  comparison_result = (ulong)DAT_0010b778;\n  result2 = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,comparison_result,input_param2,DAT_0010b768);\n  if ((result1 != 0) && (result2 != 0)) {\n    length1 = *(long *)(result2 + 0x20);\n    if (*(long *)(result1 + 0x20) == 0x10c2a8) {\n      comparison_result = 0xffffffff;\n      if (length1 == 0x10c2a8) {\nLAB_001050fa:\n        comparison_result = FUN_00104fa0(input_param1,input_param2);\n        return comparison_result;\n      }\n    }\n    else if (length1 == 0x10c2a8) {\n      comparison_result = 1;\n    }\n    else {\n      temp2 = *(long *)(result1 + 0x10) + *(long *)(*(long *)(result1 + 0x20) + 0x30);\n      comparison_result = *(long *)(result2 + 0x10) + *(long *)(length1 + 0x30);\n      if (temp2 == comparison_result) goto LAB_001050fa;\n      comparison_result = (ulong)(-(uint)(temp2 < comparison_result) | 1);\n    }\n    return comparison_result;\n  }\n  temp_param = *DAT_0010b780;\n  FUN_00106530();\n  result1 = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,DAT_0010b778,temp_param,DAT_0010b770);\n  result2 = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,DAT_0010b778,comparison_result,DAT_0010b768);\n  if ((result1 == 0) || (temp_register = result2, result2 == 0)) {\n    result2 = FUN_00106530(*DAT_0010b780);\n  }\n  if ((*(long *)(result1 + 0x20) == 0x10c2a8) || (*(long *)(result2 + 0x20) == 0x10c2a8)) {\n                    \n    abort();\n  }\n  temp2 = *(ulong *)(*(long *)(result1 + 0x20) + 0x30);\n  uVar2 = *(ulong *)(*(long *)(result2 + 0x20) + 0x30);\n  temp3 = *(long *)(result1 + 0x10) + temp2;\n  temp1 = *(long *)(temp_register + 0x10) + uVar2;\n  bVar16 = temp3 < temp1;\n  if ((temp3 != temp1) || (bVar16 = temp2 < uVar2, temp2 != uVar2)) {\n    return (ulong)(-(uint)bVar16 | 1);\n  }\n  string1 = *(char **)(result1 + 8);\n  string2 = *(char **)(temp_register + 8);\n  length_string1 = strlen(string1);\n  length_string2 = strlen(string2);\n  substr1 = strstr(string1,\"gnu_compiled\");\n  if (substr1 == (char *)0x0) {\n    substr2 = strstr(string1,\"gcc2_compiled\");\n    substr1 = strstr(string2,\"gnu_compiled\");\n    if ((substr1 == (char *)0x0) && (substr1 = strstr(string2,\"gcc2_compiled\"), substr1 == (char *)0x0))\n    goto joined_r0x00103157;\n    if (substr2 == (char *)0x0) {\n      return 1;\n    }\n  }\n  else {\n    substr1 = strstr(string2,\"gnu_compiled\");\n    if (substr1 == (char *)0x0) {\n      substr2 = strstr(string2,\"gcc2_compiled\");\njoined_r0x00103157:\n      if (substr2 != (char *)0x0) {\n        return 0xffffffff;\n      }\n    }\n  }\n  flags = *(uint *)(temp_register + 0x18) & 0x4000;\n  if ((*(byte *)(result1 + 0x19) & 0x40) == 0) {\n    if ((length_string1 < 3) || (string1[length_string1 - 2] != '.')) {\n      if (flags != 0) {\n        return 1;\n      }\n      if ((length_string2 < 3) || (string2[length_string2 - 2] != '.')) goto LAB_00103202;\n      bVar16 = false;\n      goto LAB_001031e7;\n    }\n    cVar1 = string1[length_string1 - 1];\n    bVar16 = cVar1 == 'o' || cVar1 == 'a';\n    if (flags == 0) {\n      if ((length_string2 < 3) || (string2[length_string2 - 2] != '.')) {\n        if (cVar1 == 'o' || cVar1 == 'a') {\n          return 0xffffffff;\n        }\n        goto LAB_00103202;\n      }\n      goto LAB_001031e7;\n    }\n  }\n  else {\n    if (flags != 0) goto LAB_00103202;\n    if (length_string2 < 3) {\n      return 0xffffffff;\n    }\n    if (string2[length_string2 - 2] != '.') {\n      return 0xffffffff;\n    }\n    bVar16 = true;\nLAB_001031e7:\n    if ((string2[length_string2 - 1] != 'o') && (string2[length_string2 - 1] != 'a')) {\n      if (bVar16) {\n        return 0xffffffff;\n      }\n      goto LAB_00103202;\n    }\n  }\n  if (!bVar16) {\n    return 1;\n  }\nLAB_00103202:\n  comparison_result = FUN_00104fa0(temp_param,comparison_result);\n  return comparison_result;\n}\n\n",
            "called": [
                "FUN_00104fa0",
                "FUN_00102fc3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105050",
            "calling": [
                "FUN_00103bec"
            ],
            "imported": false,
            "current_name": "compare_and_verify_00105050"
        },
        "bfd_plugin_set_program_name": {
            "renaming": {},
            "code": "\nvoid bfd_plugin_set_program_name(void)\n\n{\n  bfd_plugin_set_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_plugin_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022a0",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "bfd_plugin_set_program_name"
        },
        "FUN_001049c0": {
            "renaming": {
                "FUN_001049c0": "decompile_and_improve_001049c0",
                "pcVar1": "pointer_1",
                "pcVar2": "pointer_2",
                "cVar3": "char_1",
                "iVar4": "int_1",
                "uVar5": "uint_1",
                "uVar6": "undefined8_1",
                "lVar7": "long_1",
                "puVar8": "pointer_3",
                "lVar9": "long_2",
                "puVar10": "pointer_4",
                "unaff_RBX": "pointer_RBX",
                "__ptr": "pointer_ptr",
                "unaff_RBP": "pointer_RBP",
                "puVar11": "pointer_5",
                "puVar12": "pointer_6",
                "puVar13": "pointer_7",
                "in_R8": "pointer_R8",
                "puVar14": "pointer_8",
                "puVar15": "pointer_9",
                "unaff_R12": "pointer_R12",
                "unaff_R13": "pointer_R13",
                "unaff_R14": "pointer_R14",
                "unaff_R15": "pointer_R15",
                "bVar16": "bool_1",
                "bVar17": "byte_1",
                "unaff_retaddr": "ulong_retaddr",
                "uVar18": "ulong_1",
                "in_stack_00000008": "undefined8_stack_1",
                "in_stack_00000010": "undefined8_stack_2",
                "in_stack_00000018": "undefined8_stack_3",
                "in_stack_00000038": "undefined8_stack_4",
                "in_stack_00000040": "pointer_stack_1",
                "in_stack_00000048": "undefined8_stack_5"
            },
            "code": "\nvoid decompile_and_improve_001049c0(void)\n\n{\n  char *pointer_1;\n  code *pointer_2;\n  char char_1;\n  int int_1;\n  uint uint_1;\n  undefined8 undefined8_1;\n  long long_1;\n  undefined8 *pointer_3;\n  long long_2;\n  undefined8 *pointer_4;\n  undefined8 *pointer_RBX;\n  undefined8 *pointer_ptr;\n  undefined8 *pointer_RBP;\n  undefined8 *pointer_5;\n  undefined8 *pointer_6;\n  undefined8 *pointer_R8;\n  undefined8 *pointer_7;\n  undefined8 *in_R9;\n  undefined8 *pointer_8;\n  undefined8 *pointer_9;\n  undefined8 *pointer_R12;\n  undefined8 *pointer_R13;\n  undefined8 *pointer_R14;\n  undefined8 *pointer_R15;\n  bool bool_1;\n  byte byte_1;\n  ulong ulong_retaddr;\n  ulong ulong_1;\n  undefined8 undefined8_stack_1;\n  undefined8 *undefined8_stack_2;\n  undefined8 *undefined8_stack_3;\n  undefined8 undefined8_stack_4;\n  void *pointer_stack_1;\n  undefined8 *undefined8_stack_5;\n  \n  byte_1 = 0;\n  do {\n    pointer_RBX = (undefined8 *)((long)pointer_RBX + (long)pointer_R14);\nLAB_001049c3:\n    do {\n      do {\n        pointer_R13 = (undefined8 *)((long)pointer_R13 + (long)pointer_R14);\n        pointer_9 = pointer_R12;\n        pointer_6 = pointer_RBP;\n        if (pointer_R12 <= pointer_R13) goto LAB_00104b15;\nLAB_001049cf:\n        pointer_3 = (undefined8 *)\n                 (**(code **)(pointer_RBP[1] + 0x270))\n                           (pointer_RBP,ulong_retaddr & 0xffffffff,pointer_R13,pointer_R15);\n        pointer_5 = pointer_RBP;\n        pointer_6 = pointer_R13;\n        pointer_9 = pointer_R15;\n        if (pointer_3 == (undefined8 *)0x0) goto LAB_00102eb0;\n        pointer_1 = (char *)pointer_3[1];\n        if (((pointer_1 == (char *)0x0) || (*pointer_1 != '_')) || (pointer_1[1] != '_')) {\nLAB_00104a03:\n          if (DAT_0010b7e8 == 0) goto LAB_00104a11;\nLAB_00104ae2:\n          uint_1 = (uint)(pointer_3[4] == 0x10c2a8);\nLAB_00104af9:\n          if (uint_1 != 0) goto LAB_00104a2d;\n          pointer_R13 = (undefined8 *)((long)pointer_R13 + (long)pointer_R14);\n          pointer_9 = pointer_R12;\n          pointer_6 = pointer_RBP;\n          if (pointer_R12 <= pointer_R13) {\nLAB_00104b15:\n            pointer_RBX = (undefined8 *)((long)pointer_RBX - (long)undefined8_stack_3);\n            if (pointer_R14 == (undefined8 *)0x8) {\n              long_2 = pointer_6[1];\n              pointer_5 = (undefined8 *)((long)pointer_RBX + 7);\n              if (-1 < (long)pointer_RBX) {\n                pointer_5 = pointer_RBX;\n              }\n              pointer_R8 = (undefined8 *)(ulong)DAT_0010b800;\n              pointer_2 = *(code **)(long_2 + 0x208);\n              pointer_5 = (undefined8 *)((long)pointer_5 >> 3);\n            }\n            else {\n              pointer_5 = (undefined8 *)((long)pointer_RBX / (long)pointer_R14);\n              long_2 = pointer_6[1];\n              pointer_2 = *(code **)(long_2 + 0x208);\n            }\n            pointer_RBP = pointer_6;\n            if (DAT_0010b800 == 0) {\n              DAT_0010b778 = DAT_0010b80c != 0;\n              DAT_0010b780 = pointer_6;\n              DAT_0010b770 = (undefined8 *)(*pointer_2)(pointer_6);\n              DAT_0010b768 = (undefined8 *)(**(code **)(pointer_6[1] + 0x208))(pointer_6);\n              pointer_RBX = undefined8_stack_5;\n              if ((DAT_0010b770 == (undefined8 *)0x0) || (DAT_0010b768 == (undefined8 *)0x0)) {\n                FUN_00106530(*pointer_6);\n                pointer_ptr = pointer_R15;\n                goto LAB_00102d8e;\n              }\n              pointer_R12 = (undefined8 *)(ulong)undefined8_stack_4._4_4_;\n              if (DAT_0010b7f8 != 0) {\n                ulong_1 = (ulong)(DAT_0010b80c != 0);\n                qsort(undefined8_stack_5,(size_t)pointer_5,(size_t)pointer_R12,FUN_00102fd2);\n                pointer_9 = (undefined8 *)xmalloc((long)pointer_5 << 4);\n                pointer_7 = DAT_0010b770;\n                pointer_RBP = DAT_0010b768;\n                pointer_R14 = (undefined8 *)((long)pointer_5 * (long)pointer_R12 + (long)pointer_RBX);\n                pointer_3 = DAT_0010b770;\n                in_R9 = DAT_0010b768;\n                if (pointer_R14 <= pointer_RBX) goto LAB_00102ec2;\n                pointer_5 = (undefined8 *)\n                          (**(code **)(pointer_6[1] + 0x270))(pointer_6,ulong_1 & 0xffffffff,pointer_RBX);\n                pointer_ptr = pointer_RBX;\n                pointer_R8 = pointer_R12;\n                undefined8_stack_2 = pointer_9;\n                if (pointer_5 == (undefined8 *)0x0) goto LAB_00102eb9;\n                goto LAB_00104e35;\n              }\n              qsort(undefined8_stack_5,(size_t)pointer_5,(size_t)pointer_R12,\n                    (__compar_fn_t)(&PTR_FUN_0010acc0)[(long)DAT_0010b7f4 + (long)DAT_0010b7fc * 2])\n              ;\n              long_2 = pointer_6[1];\n            }\n            pointer_ptr = (undefined8 *)0x0;\n            do {\n              pointer_6 = undefined8_stack_5;\n              pointer_3 = (undefined8 *)(ulong)DAT_0010b7f8;\n              pointer_R14 = (undefined8 *)(ulong)(DAT_0010b80c != 0);\n              if (DAT_0010b7f8 != 0) {\n                pointer_9 = (undefined8 *)(**(code **)(long_2 + 0x208))(pointer_RBP);\n                if (pointer_9 == (undefined8 *)0x0) goto LAB_00102ed2;\n                pointer_RBX = pointer_ptr + (long)pointer_5 * 2;\n                pointer_5 = pointer_ptr;\n                do {\n                  if (pointer_RBX <= pointer_5) {\nLAB_00104c75:\n                    if (pointer_stack_1 == (void *)0x0) {\n                      free(undefined8_stack_5);\n                      free(pointer_ptr);\n                      return;\n                    }\n                    free(pointer_stack_1);\n                    free(undefined8_stack_5);\n                    free(pointer_ptr);\n                    return;\n                  }\n                  pointer_3 = pointer_9;\n                  long_2 = (**(code **)(pointer_RBP[1] + 0x270))(pointer_RBP,pointer_R14,*pointer_5);\n                  if (long_2 == 0) {\n                    FUN_00106530(*pointer_RBP,0);\nLAB_00102ed2:\n                    pointer_6 = (undefined8 *)*pointer_RBP;\n                    FUN_00106530();\n                    pointer_7 = pointer_R8;\n                    pointer_8 = in_R9;\n                    goto LAB_00102edb;\n                  }\n                  pointer_6 = pointer_5 + 1;\n                  pointer_5 = pointer_5 + 2;\n                  FUN_00105110(pointer_RBP,long_2,*pointer_6,undefined8_stack_1);\n                } while( true );\n              }\n              pointer_R12 = (undefined8 *)(ulong)undefined8_stack_4._4_4_;\n              pointer_R15 = (undefined8 *)(**(code **)(long_2 + 0x208))(pointer_RBP);\n              if (pointer_R15 == (undefined8 *)0x0) {\n                FUN_00106530(*pointer_RBP);\n                pointer_6 = pointer_R12;\n                if (DAT_0010b80c == 0) {\n                  long_2 = (**(code **)(pointer_RBP[1] + 0x350))(pointer_RBP);\n                  pointer_5 = undefined8_stack_5;\n                  pointer_9 = pointer_R12;\n                  if (long_2 < 1) {\n                    pointer_3 = (undefined8 *)0x0;\n                    pointer_RBX = (undefined8 *)0x0;\n                  }\n                  else {\nLAB_00102d8e:\n                    pointer_RBX = (undefined8 *)xmalloc();\n                    pointer_3 = (undefined8 *)(**(code **)(pointer_RBP[1] + 0x358))(pointer_RBP,pointer_RBX);\n                    pointer_6 = pointer_9;\n                    if ((long)pointer_3 < 0) {\n                      pointer_6 = (undefined8 *)*pointer_RBP;\n                      pointer_5 = (undefined8 *)FUN_00106530(pointer_6,pointer_9);\n                      goto LAB_00102dbe;\n                    }\n                  }\n                }\n                else {\n                  pointer_3 = pointer_R12;\n                  pointer_RBX = undefined8_stack_5;\n                  pointer_5 = (undefined8 *)0x0;\n                  pointer_9 = (undefined8 *)0x0;\n                }\n                in_R9 = &stack0x00000040;\n                pointer_R8 = pointer_RBX;\n                long_2 = (**(code **)(pointer_RBP[1] + 0x360))(pointer_RBP,pointer_9,pointer_5,pointer_3);\n                pointer_R12 = pointer_6;\n                if (0 < long_2) {\n                  pointer_R12 = (undefined8 *)((long)pointer_6 + long_2);\n                  undefined8_stack_5 = (undefined8 *)xrealloc(undefined8_stack_5);\n                  long_1 = 0;\n                  do {\n                    undefined8_stack_5[(long)((long)pointer_6 + long_1)] =\n                         (void *)(long_1 * 0x30 + (long)pointer_stack_1);\n                    long_1 = long_1 + 1;\n                  } while (long_2 != long_1);\n                  undefined8_stack_5[(long)((long)pointer_6 + long_2)] = 0;\n                }\n                if ((DAT_0010b80c == 0) && (pointer_RBX != (undefined8 *)0x0)) {\n                  free(pointer_RBX);\n                }\n                if ((*(byte *)((long)pointer_RBP + 0x4a) & 0x10) != 0) {\n                  pointer_RBX = (undefined8 *)*pointer_RBP;\n                  DAT_0010b230 = '\\0';\n                  undefined8_1 = dcgettext(0,\"%s: plugin needed to handle lto object\",5);\n                  FUN_00106400(undefined8_1);\n                }\n                pointer_R14 = (undefined8 *)(ulong)undefined8_stack_4._4_4_;\n                bool_1 = DAT_0010b80c != 0;\n                pointer_5 = (undefined8 *)(ulong)bool_1;\n                pointer_3 = undefined8_stack_5;\n                undefined8_stack_3 = undefined8_stack_5;\n                pointer_R15 = (undefined8 *)(**(code **)(pointer_RBP[1] + 0x208))(pointer_RBP);\n                if (pointer_R15 != (undefined8 *)0x0) goto code_r0x00104992;\n              }\n              else {\n                pointer_5 = (undefined8 *)((long)pointer_5 * (long)pointer_R12 + (long)pointer_6);\n                pointer_RBX = pointer_6;\n                while( true ) {\n                  if (pointer_5 <= pointer_RBX) goto LAB_00104c75;\n                  pointer_3 = pointer_R15;\n                  long_2 = (**(code **)(pointer_RBP[1] + 0x270))(pointer_RBP,pointer_R14,pointer_RBX);\n                  if (long_2 == 0) break;\n                  pointer_RBX = (undefined8 *)((long)pointer_RBX + (long)pointer_R12);\n                  FUN_00105110(pointer_RBP,long_2,0,undefined8_stack_1);\n                }\n                FUN_00106530(*pointer_RBP,0);\n              }\n              FUN_00106530(*pointer_RBP);\n              pointer_6 = pointer_RBP;\n              pointer_9 = pointer_R15;\nLAB_00102eb0:\n              FUN_00106530(*pointer_5);\nLAB_00102eb9:\n              FUN_00106530(*pointer_6);\nLAB_00102ec2:\n              pointer_5 = (undefined8 *)0x0;\n              pointer_ptr = pointer_RBX;\n              pointer_R8 = pointer_R12;\n              pointer_7 = pointer_3;\n              pointer_RBP = in_R9;\n              undefined8_stack_2 = pointer_9;\nLAB_00104e35:\n              while (in_R9 = pointer_7, pointer_ptr < pointer_R14) {\n                pointer_RBX = (undefined8 *)((long)pointer_ptr + (long)pointer_R8);\n                if (pointer_RBX < pointer_R14) {\n                  pointer_3 = pointer_RBP;\n                  pointer_7 = pointer_R8;\n                  pointer_8 = in_R9;\n                  pointer_4 = (undefined8 *)(**(code **)(pointer_6[1] + 0x270))();\n                  if (pointer_4 == (undefined8 *)0x0) {\nLAB_00102edb:\n                    in_R9 = pointer_8;\n                    pointer_R8 = pointer_7;\n                    pointer_6 = (undefined8 *)*pointer_6;\n                    pointer_4 = (undefined8 *)FUN_00106530();\n                  }\n                  else {\n                    pointer_3 = (undefined8 *)pointer_5[4];\n                    if ((*(uint *)(pointer_5 + 3) & 0x200100) == 0) goto LAB_00104e95;\n                  }\n                  long_2 = pointer_5[2];\nLAB_00102ee7:\n                  if (pointer_3 == (undefined8 *)pointer_4[4]) {\n                    long_2 = pointer_4[2] - long_2;\n                    pointer_7 = pointer_RBP;\n                    pointer_8 = pointer_ptr;\n                    goto LAB_00104ea7;\n                  }\nLAB_00102dc4:\n                  long_2 = pointer_3[8] - long_2;\n                  pointer_7 = pointer_RBP;\n                  pointer_8 = pointer_ptr;\n                }\n                else {\n                  pointer_3 = (undefined8 *)pointer_5[4];\n                  if ((*(uint *)(pointer_5 + 3) & 0x200100) != 0) {\nLAB_00102dbe:\n                    long_2 = pointer_5[2];\n                    pointer_4 = (undefined8 *)0x0;\n                    goto LAB_00102dc4;\n                  }\n                  pointer_4 = (undefined8 *)0x0;\nLAB_00104e95:\n                  pointer_7 = pointer_RBP;\n                  pointer_8 = pointer_ptr;\n                  if (*(int *)(pointer_6[1] + 8) == 5) {\n                    long_2 = pointer_5[7];\n                  }\n                  else {\n                    long_2 = pointer_5[2];\n                    if ((*(byte *)((long)pointer_3 + 0x25) & 0x10) == 0) {\n                      if (pointer_RBX < pointer_R14) goto LAB_00102ee7;\n                      goto LAB_00102dc4;\n                    }\n                  }\n                }\nLAB_00104ea7:\n                pointer_5 = pointer_4;\n                pointer_ptr = pointer_RBX;\n                pointer_RBP = in_R9;\n                if (long_2 != 0) {\n                  *pointer_9 = pointer_8;\n                  pointer_9[1] = long_2;\n                  pointer_9 = pointer_9 + 2;\n                }\n              }\n              pointer_5 = (undefined8 *)((long)pointer_9 - (long)undefined8_stack_2 >> 4);\n              qsort(undefined8_stack_2,(size_t)pointer_5,0x10,FUN_00103533);\n              long_2 = pointer_6[1];\n              pointer_RBX = pointer_ptr;\n              pointer_RBP = pointer_6;\n              pointer_ptr = undefined8_stack_2;\n            } while( true );\n          }\n          goto LAB_001049cf;\n        }\n        int_1 = strcmp(pointer_1 + (pointer_1[2] == '_'),\"__gnu_lto_slim\");\n        undefined8_stack_2 = pointer_3;\n        if (int_1 == 0) {\n          if (DAT_0010b230 != '\\0') {\n            undefined8_stack_2 = (undefined8 *)*pointer_RBP;\n            DAT_0010b230 = '\\0';\n            undefined8_1 = dcgettext(0,\"%s: plugin needed to handle lto object\",5);\n            FUN_00106400(undefined8_1,undefined8_stack_2);\n          }\n          goto LAB_00104a03;\n        }\n        if (DAT_0010b7e8 != 0) goto LAB_00104ae2;\nLAB_00104a11:\n        if (DAT_0010b808 == 0) {\n          if (DAT_0010b7d8 == 0) goto LAB_00104a2d;\n          uint_1 = (*(uint *)(pointer_3 + 3) >> 7 ^ 1) & 1;\n          goto LAB_00104af9;\n        }\n        if ((((*(uint *)(pointer_3 + 3) & 0x800082) == 0) && (pointer_3[4] != 0x10c2a8)) &&\n           ((*(byte *)(pointer_3[4] + 0x25) & 0x10) == 0)) goto LAB_001049c3;\nLAB_00104a2d:\n        if (DAT_0010b81c != 0) {\n          if (DAT_0010b7f8 == 0) goto LAB_00104a53;\nFUN_00104d5b:\n          if ((pointer_3[4] != 0x10c2a8) && (pointer_3[4] != 0x10c3c0)) goto LAB_00104cba;\n          goto LAB_001049c3;\n        }\n      } while ((*(byte *)(pointer_3 + 3) & 4) != 0);\n      if (DAT_0010b7f8 != 0) goto FUN_00104d5b;\nLAB_00104a53:\n      in_R9 = (undefined8 *)(ulong)DAT_0010b7e4;\n      if (DAT_0010b7e4 == 0) {\n        char_1 = (**(code **)(pointer_RBP[1] + 0x230))(pointer_RBP);\n        if (char_1 != '\\0') {\n          FUN_00102c19();\n          return;\n        }\n        goto LAB_00104a7b;\n      }\n    } while (pointer_3[4] == 0x10c2a8);\nLAB_00104cba:\n    char_1 = (**(code **)(pointer_RBP[1] + 0x230))(pointer_RBP);\n    if (char_1 != '\\0') {\n      FUN_00102c19();\n      return;\n    }\nLAB_00104a7b:\n    if (pointer_RBX != pointer_R13) {\n      if (pointer_R14 == (undefined8 *)0x8) {\n        *pointer_RBX = *pointer_R13;\n        decompile_and_improve_001049c0();\n        return;\n      }\n      for (; pointer_R14 != (undefined8 *)0x0; pointer_R14 = (undefined8 *)((long)pointer_R14 + -1)) {\n        *(undefined *)pointer_RBX = *(undefined *)pointer_R13;\n        pointer_R13 = (undefined8 *)((long)pointer_R13 + (ulong)byte_1 * -2 + 1);\n        pointer_RBX = (undefined8 *)((long)pointer_RBX + (ulong)byte_1 * -2 + 1);\n      }\n      decompile_and_improve_001049c0();\n      return;\n    }\n  } while( true );\ncode_r0x00104992:\n  pointer_9 = (undefined8 *)((long)pointer_R12 * (long)pointer_R14);\n  pointer_R12 = (undefined8 *)((long)undefined8_stack_3 + (long)pointer_9);\n  pointer_RBX = undefined8_stack_3;\n  pointer_6 = pointer_RBP;\n  if (undefined8_stack_3 < pointer_R12) goto code_r0x001049aa;\n  goto LAB_00104b15;\ncode_r0x001049aa:\n  ulong_retaddr = (ulong)bool_1;\n  pointer_R13 = undefined8_stack_3;\n  goto LAB_001049cf;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001049c0",
            "calling": [
                "FUN_00104d5b"
            ],
            "imported": false,
            "current_name": "decompile_and_improve_001049c0"
        },
        "FUN_00103ca0": {
            "renaming": {
                "FUN_00103ca0": "print_symbol_list_00103ca0",
                "param_1": "outputFile",
                "param_2": "exitCode",
                "lVar1": "target",
                "iVar2": "totalSymbolLength",
                "iVar3": "fprintfResult",
                "pcVar4": "translatedText",
                "lVar5": "spaceCount",
                "sVar6": "symbolLength",
                "__ptr": "targetList",
                "plVar7": "currentTarget",
                "ppcVar8": "currentDemangler",
                "pcVar9": "delimiter",
                "local_3c": "spaceLength"
            },
            "code": "\nvoid printSymbolList_00103ca0(FILE *outputFile,int exitCode)\n\n{\n  long target;\n  int totalSymbolLength;\n  int fprintfResult;\n  char *translatedText;\n  long spaceCount;\n  size_t symbolLength;\n  long *targetList;\n  long *currentTarget;\n  char **currentDemangler;\n  char *delimiter;\n  uint spaceLength;\n  \n  target = DAT_0010b820;\n  translatedText = (char *)dcgettext(0,\"Usage: %s [option(s)] [file(s)]\\n\",5);\n  fprintf(outputFile,translatedText,target);\n  translatedText = (char *)dcgettext(0,\" List symbols in [file(s)] (a.out by default).\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\" The options are:\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  -a, --debug-syms       Display debugger-only symbols\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\n                             \"  -A, --print-file-name  Print name of the input file before every symbol\\n\"\n                             ,5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  -B                     Same as --format=bsd\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  -C, --demangle[=STYLE] Decode mangled/processed symbol names\\n\",5)\n  ;\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"                           STYLE can be \",5);\n  if (*translatedText == ' ') {\n    target = 1;\n    do {\n      spaceCount = target;\n      target = spaceCount + 1;\n    } while (translatedText[spaceCount] == ' ');\n    spaceLength = (uint)spaceCount;\n  }\n  else {\n    spaceLength = 0;\n  }\n  totalSymbolLength = fprintf(outputFile,\"%s\",translatedText);\n  delimiter = \"\";\n  for (currentDemangler = (char **)&libiberty_demanglers; *currentDemangler != (char *)0x0; currentDemangler = currentDemangler + 3) {\n    symbolLength = strlen(*currentDemangler);\n    if (0x4a < (long)totalSymbolLength + symbolLength) {\n      fprintf(outputFile,\"%.1s\\n\",delimiter);\n      delimiter = \"\";\n      totalSymbolLength = fprintf(outputFile,\"%.*s\",(ulong)spaceLength,translatedText);\n    }\n    fprintfResult = fprintf(outputFile,\"%s\\\"%s\\\"\",delimiter,*currentDemangler);\n    totalSymbolLength = totalSymbolLength + fprintfResult;\n    delimiter = \", \";\n  }\n  fputc(10,outputFile);\n  translatedText = (char *)dcgettext(0,\"      --no-demangle      Do not demangle low-level symbol names\\n\",5\n                            );\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\n                             \"      --recurse-limit    Enable a demangling recursion limit.  (default)\\n\"\n                             ,5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"      --no-recurse-limit Disable a demangling recursion limit.\\n\",5)\n  ;\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\n                             \"  -D, --dynamic          Display dynamic symbols instead of normal symbols\\n\"\n                             ,5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  -e                     (ignored)\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\n                             \"  -f, --format=FORMAT    Use the output format FORMAT.  FORMAT can be `bsd\\',\\n                           `sysv\\', `posix\\' or \\'just-symbols\\'.\\n                           The default is `bsd\\'\\n\"\n                             ,5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  -g, --extern-only      Display only external symbols\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\n                             \"    --ifunc-chars=CHARS  Characters to use when displaying ifunc symbols\\n\"\n                             ,5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  -j, --just-symbols     Same as --format=just-symbols\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\n                             \"  -l, --line-numbers     Use debugging information to find a filename and\\n                           line number for each symbol\\n\"\n                             ,5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  -n, --numeric-sort     Sort symbols numerically by address\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  -o                     Same as -A\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  -p, --no-sort          Do not sort the symbols\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  -P, --portability      Same as --format=posix\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  -r, --reverse-sort     Reverse the sense of the sort\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"      --plugin NAME      Load the specified plugin\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  -S, --print-size       Print size of defined symbols\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\n                             \"  -s, --print-armap      Include index for symbols from archive members\\n\"\n                             ,5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"      --quiet            Suppress \\\"no symbols\\\" diagnostic\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"      --size-sort        Sort symbols by size\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"      --special-syms     Include special symbols in the output\\n\",5)\n  ;\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"      --synthetic        Display synthetic symbols as well\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  -t, --radix=RADIX      Use RADIX for printing symbol values\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\n                             \"      --target=BFDNAME   Specify the target object format as BFDNAME\\n\"\n                             ,5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  -u, --undefined-only   Display only undefined symbols\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  -U, --defined-only     Display only defined symbols\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\n                             \"      --unicode={default|show|invalid|hex|escape|highlight}\\n                         Specify how to treat UTF-8 encoded unicode characters\\n\"\n                             ,5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  -W, --no-weak          Ignore weak symbols\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\n                             \"      --with-symbol-versions  Display version strings after symbol names\\n\"\n                             ,5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  -X 32_64               (ignored)\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  @FILE                  Read options from FILE\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  -h, --help             Display this information\\n\",5);\n  fprintf(outputFile,translatedText);\n  translatedText = (char *)dcgettext(0,\"  -V, --version          Display this program\\'s version number\\n\",5\n                            );\n  fprintf(outputFile,translatedText);\n  target = DAT_0010b820;\n  if (DAT_0010b820 == 0) {\n    translatedText = (char *)dcgettext(0,\"Supported targets:\",5);\n    fprintf(outputFile,translatedText);\n  }\n  else {\n    translatedText = (char *)dcgettext(0,\"%s: supported targets:\",5);\n    fprintf(outputFile,translatedText,target);\n  }\n  targetList = (long *)bfd_target_list();\n  currentTarget = targetList;\n  while( true ) {\n    target = *currentTarget;\n    currentTarget = currentTarget + 1;\n    if (target == 0) break;\n    fprintf(outputFile,\" %s\");\n  }\n  fputc(10,outputFile);\n  free(targetList);\n  if (exitCode == 0) {\n    translatedText = (char *)dcgettext(0,\"Report bugs to %s.\\n\",5);\n    fprintf(outputFile,translatedText,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  exit(exitCode);\n}\n\n",
            "called": [
                "bfd_target_list",
                "exit",
                "fseek",
                "dcgettext",
                "free",
                "fputc",
                "fprintf",
                "strlen",
                "FUN_00102450"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103ca0",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "print_symbol_list_00103ca0"
        },
        "FUN_00104d5b": {
            "renaming": {
                "FUN_00104d5b": "process_lto_object_00104d5b",
                "in_RCX": "input",
                "in_RCX[4]": "inputType",
                "unaff_RBX": "accumulator",
                "unaff_R13": "accumulator2",
                "unaff_R14": "increment",
                "unaff_R12": "limit",
                "unaff_R15": "temp1",
                "unaff_RBP[1]": "callbackManager",
                "puVar12[1]": "callbackManager2",
                "param_13": "inputArray",
                "param_14": "outputArray",
                "puVar7[8]": "startAddress",
                "puVar11[4]": "startAddress2",
                "puVar11[2]": "endAddress2",
                "puVar15": "outputArray2",
                "puVar11[7]": "unknownVariable",
                "__compar_fn_t": "comparisonFunction",
                "xmalloc": "dynamicMemoryAllocation",
                "xrealloc": "reallocateMemory",
                "free": "freeMemory",
                "dcgettext": "getTranslation",
                "qsort": "sortArray",
                "strcmp": "compareStrings"
            },
            "code": "\nvoid processLTOObject_00104d5b(void)\n\n{\n  char *pcVar1;\n  code *pcVar2;\n  char cVar3;\n  int iVar4;\n  uint uVar5;\n  undefined8 uVar6;\n  undefined8 *puVar7;\n  long lVar8;\n  long lVar9;\n  undefined8 *puVar10;\n  undefined8 *input;\n  undefined8 *accumulator;\n  undefined8 *__ptr;\n  undefined8 *puVar11;\n  undefined8 *unaff_RBP;\n  undefined8 *puVar12;\n  undefined8 *in_R8;\n  undefined8 *puVar13;\n  undefined8 *in_R9;\n  undefined8 *puVar14;\n  undefined8 *outputArray2;\n  undefined8 *limit;\n  undefined8 *accumulator2;\n  undefined8 *increment;\n  undefined8 *temp1;\n  bool bVar16;\n  byte bVar17;\n  ulong unaff_retaddr;\n  ulong uVar18;\n  undefined8 param_7;\n  undefined8 *param_8;\n  undefined8 *param_9;\n  undefined8 in_stack_00000038;\n  void *inputArray;\n  undefined8 *outputArray;\n  \n  bVar17 = 0;\n  do {\n    if ((inputType != 0x10c2a8) && (inputType != 0x10c3c0)) goto LAB_00104cba;\nLAB_001049c3:\n    do {\n      accumulator2 = (undefined8 *)((long)accumulator2 + (long)increment);\n      outputArray2 = limit;\n      puVar12 = unaff_RBP;\n      if (limit <= accumulator2) goto LAB_00104b15;\nLAB_001049cf:\n      input = (undefined8 *)\n               (**(code **)(callbackManager + 0x270))\n                         (unaff_RBP,unaff_retaddr & 0xffffffff,accumulator2,temp1);\n      puVar11 = unaff_RBP;\n      puVar12 = accumulator2;\n      outputArray2 = temp1;\n      if (input == (undefined8 *)0x0) goto LAB_00102eb0;\n      pcVar1 = (char *)input[1];\n      if (((pcVar1 == (char *)0x0) || (*pcVar1 != '_')) || (pcVar1[1] != '_')) {\nLAB_00104a03:\n        if (DAT_0010b7e8 == 0) goto LAB_00104a11;\nLAB_00104ae2:\n        uVar5 = (uint)(inputType == 0x10c2a8);\nLAB_00104af9:\n        if (uVar5 != 0) goto LAB_00104a2d;\n        accumulator2 = (undefined8 *)((long)accumulator2 + (long)increment);\n        outputArray2 = limit;\n        puVar12 = unaff_RBP;\n        if (limit <= accumulator2) {\nLAB_00104b15:\n          accumulator = (undefined8 *)((long)accumulator - (long)param_9);\n          if (increment == (undefined8 *)0x8) {\n            lVar9 = callbackManager2;\n            puVar11 = (undefined8 *)((long)accumulator + 7);\n            if (-1 < (long)accumulator) {\n              puVar11 = accumulator;\n            }\n            in_R8 = (undefined8 *)(ulong)DAT_0010b800;\n            pcVar2 = *(code **)(lVar9 + 0x208);\n            puVar11 = (undefined8 *)((long)puVar11 >> 3);\n          }\n          else {\n            puVar11 = (undefined8 *)((long)accumulator / (long)increment);\n            lVar9 = callbackManager2;\n            pcVar2 = *(code **)(lVar9 + 0x208);\n          }\n          unaff_RBP = puVar12;\n          if (DAT_0010b800 == 0) {\n            DAT_0010b778 = DAT_0010b80c != 0;\n            DAT_0010b780 = puVar12;\n            DAT_0010b770 = (undefined8 *)(*pcVar2)(puVar12);\n            DAT_0010b768 = (undefined8 *)(**(code **)(callbackManager2 + 0x208))(puVar12);\n            accumulator = outputArray;\n            if ((DAT_0010b770 == (undefined8 *)0x0) || (DAT_0010b768 == (undefined8 *)0x0)) {\n              FUN_00106530(*puVar12);\n              __ptr = temp1;\n              goto LAB_00102d8e;\n            }\n            limit = (undefined8 *)(ulong)in_stack_00000038._4_4_;\n            if (DAT_0010b7f8 != 0) {\n              uVar18 = (ulong)(DAT_0010b80c != 0);\n              qsort(outputArray,(size_t)puVar11,(size_t)limit,FUN_00102fd2);\n              outputArray2 = (undefined8 *)xmalloc((long)puVar11 << 4);\n              puVar13 = DAT_0010b770;\n              unaff_RBP = DAT_0010b768;\n              increment = (undefined8 *)((long)puVar11 * (long)limit + (long)accumulator);\n              input = DAT_0010b770;\n              in_R9 = DAT_0010b768;\n              if (increment <= accumulator) goto LAB_00102ec2;\n              puVar11 = (undefined8 *)\n                        (**(code **)(callbackManager2 + 0x270))(puVar12,uVar18 & 0xffffffff,accumulator);\n              __ptr = accumulator;\n              in_R8 = limit;\n              param_8 = outputArray2;\n              if (puVar11 == (undefined8 *)0x0) goto LAB_00102eb9;\n              goto LAB_00104e35;\n            }\n            qsort(outputArray,(size_t)puVar11,(size_t)limit,\n                  (comparisonFunction)(&PTR_FUN_0010acc0)[(long)DAT_0010b7f4 + (long)DAT_0010b7fc * 2]);\n            lVar9 = callbackManager2;\n          }\n          __ptr = (undefined8 *)0x0;\n          do {\n            puVar12 = outputArray;\n            puVar7 = (undefined8 *)(ulong)DAT_0010b7f8;\n            increment = (undefined8 *)(ulong)(DAT_0010b80c != 0);\n            if (DAT_0010b7f8 != 0) {\n              outputArray2 = (undefined8 *)(**(code **)(lVar9 + 0x208))(unaff_RBP);\n              if (outputArray2 == (undefined8 *)0x0) goto LAB_00102ed2;\n              accumulator = __ptr + (long)puVar11 * 2;\n              puVar11 = __ptr;\n              do {\n                if (accumulator <= puVar11) {\nLAB_00104c75:\n                  if (inputArray != (void *)0x0) {\n                    freeMemory(inputArray);\n                    freeMemory(outputArray);\n                    freeMemory(__ptr);\n                    return;\n                  }\n                  freeMemory(outputArray);\n                  freeMemory(__ptr);\n                  return;\n                }\n                puVar7 = outputArray2;\n                lVar9 = (**(code **)(callbackManager + 0x270))(unaff_RBP,increment,*puVar11);\n                if (lVar9 == 0) {\n                  FUN_00106530(*unaff_RBP,0);\nLAB_00102ed2:\n                  puVar12 = (undefined8 *)*unaff_RBP;\n                  FUN_00106530();\n                  puVar13 = in_R8;\n                  puVar14 = in_R9;\n                  goto LAB_00102edb;\n                }\n                puVar12 = puVar11 + 1;\n                puVar11 = puVar11 + 2;\n                FUN_00105110(unaff_RBP,lVar9,*puVar12,param_7);\n              } while( true );\n            }\n            limit = (undefined8 *)(ulong)in_stack_00000038._4_4_;\n            temp1 = (undefined8 *)(**(code **)(lVar9 + 0x208))(unaff_RBP);\n            if (temp1 == (undefined8 *)0x0) {\n              FUN_00106530(*unaff_RBP);\n              puVar12 = limit;\n              if (DAT_0010b80c == 0) {\n                lVar9 = (**(code **)(callbackManager + 0x350))(unaff_RBP);\n                puVar11 = outputArray;\n                outputArray2 = limit;\n                if (lVar9 < 1) {\n                  puVar7 = (undefined8 *)0x0;\n                  accumulator = (undefined8 *)0x0;\n                }\n                else {\nLAB_00102d8e:\n                  accumulator = (undefined8 *)xmalloc();\n                  puVar7 = (undefined8 *)(**(code **)(callbackManager + 0x358))(unaff_RBP,accumulator);\n                  puVar12 = outputArray2;\n                  if ((long)puVar7 < 0) {\n                    puVar12 = (undefined8 *)*unaff_RBP;\n                    puVar11 = (undefined8 *)FUN_00106530(puVar12,outputArray2);\n                    goto LAB_00102dbe;\n                  }\n                }\n              }\n              else {\n                puVar7 = limit;\n                accumulator = outputArray;\n                puVar11 = (undefined8 *)0x0;\n                outputArray2 = (undefined8 *)0x0;\n              }\n              in_R9 = &stack0x00000040;\n              in_R8 = accumulator;\n              lVar9 = (**(code **)(callbackManager + 0x360))(unaff_RBP,outputArray2,puVar11,puVar7);\n              limit = puVar12;\n              if (0 < lVar9) {\n                limit = (undefined8 *)((long)puVar12 + lVar9);\n                outputArray = (undefined8 *)xrealloc(outputArray);\n                lVar8 = 0;\n                do {\n                  outputArray[(long)puVar12 + lVar8] = (void *)(lVar8 * 0x30 + (long)inputArray);\n                  lVar8 = lVar8 + 1;\n                } while (lVar9 != lVar8);\n                outputArray[(long)puVar12 + lVar9] = 0;\n              }\n              if ((DAT_0010b80c == 0) && (accumulator != (undefined8 *)0x0)) {\n                freeMemory(accumulator);\n              }\n              if ((*(byte *)((long)unaff_RBP + 0x4a) & 0x10) != 0) {\n                accumulator = (undefined8 *)*unaff_RBP;\n                DAT_0010b230 = '\\0';\n                uVar6 = dcgettext(0,\"%s: plugin needed to handle lto object\",5);\n                FUN_00106400(uVar6);\n              }\n              increment = (undefined8 *)(ulong)in_stack_00000038._4_4_;\n              bVar16 = DAT_0010b80c != 0;\n              puVar11 = (undefined8 *)(ulong)bVar16;\n              input = outputArray;\n              param_9 = outputArray;\n              temp1 = (undefined8 *)(**(code **)(callbackManager + 0x208))(unaff_RBP);\n              if (temp1 != (undefined8 *)0x0) goto code_r0x00104992;\n            }\n            else {\n              puVar11 = (undefined8 *)((long)puVar11 * (long)limit + (long)puVar12);\n              accumulator = puVar12;\n              while( true ) {\n                if (puVar11 <= accumulator) goto LAB_00104c75;\n                input = temp1;\n                lVar9 = (**(code **)(callbackManager + 0x270))(unaff_RBP,increment,accumulator);\n                if (lVar9 == 0) break;\n                accumulator = (undefined8 *)((long)accumulator + (long)limit);\n                FUN_00105110(unaff_RBP,lVar9,0,param_7);\n              }\n              FUN_00106530(*unaff_RBP,0);\n            }\n            FUN_00106530(*unaff_RBP);\n            puVar12 = unaff_RBP;\n            outputArray2 = temp1;\nLAB_00102eb0:\n            FUN_00106530(*puVar11);\nLAB_00102eb9:\n            FUN_00106530(*puVar12);\nLAB_00102ec2:\n            puVar11 = (undefined8 *)0x0;\n            __ptr = accumulator;\n            in_R8 = limit;\n            puVar13 = input;\n            unaff_RBP = in_R9;\n            param_8 = outputArray2;\nLAB_00104e35:\n            while (in_R9 = puVar13, __ptr < increment) {\n              accumulator = (undefined8 *)((long)__ptr + (long)in_R8);\n              if (accumulator < increment) {\n                puVar7 = unaff_RBP;\n                puVar13 = in_R8;\n                puVar14 = in_R9;\n                puVar10 = (undefined8 *)(**(code **)(callbackManager2 + 0x270))();\n                if (puVar10 == (undefined8 *)0x0) {\nLAB_00102edb:\n                  in_R9 = puVar14;\n                  in_R8 = puVar13;\n                  puVar12 = (undefined8 *)*puVar12;\n                  puVar10 = (undefined8 *)FUN_00106530();\n                }\n                else {\n                  puVar7 = (undefined8 *)startAddress2;\n                  if ((*(uint *)(puVar11 + 3) & 0x200100) == 0) goto LAB_00104e95;\n                }\n                lVar9 = endAddress2;\nLAB_00102ee7:\n                if (puVar7 == (undefined8 *)puVar10[4]) {\n                  lVar9 = puVar10[2] - lVar9;\n                  puVar13 = unaff_RBP;\n                  puVar14 = __ptr;\n                  goto LAB_00104ea7;\n                }\nLAB_00102dc4:\n                lVar9 = startAddress - lVar9;\n                puVar13 = unaff_RBP;\n                puVar14 = __ptr;\n              }\n              else {\n                puVar7 = (undefined8 *)startAddress2;\n                if ((*(uint *)(puVar11 + 3) & 0x200100) != 0) {\nLAB_00102dbe:\n                  lVar9 = endAddress2;\n                  puVar10 = (undefined8 *)0x0;\n                  goto LAB_00102dc4;\n                }\n                puVar10 = (undefined8 *)0x0;\nLAB_00104e95:\n                puVar13 = unaff_RBP;\n                puVar14 = __ptr;\n                if (*(int *)(callbackManager2 + 8) == 5) {\n                  lVar9 = unknownVariable;\n                }\n                else {\n                  lVar9 = endAddress2;\n                  if ((*(byte *)((long)puVar7 + 0x25) & 0x10) == 0) {\n                    if (accumulator < increment) goto LAB_00102ee7;\n                    goto LAB_00102dc4;\n                  }\n                }\n              }\nLAB_00104ea7:\n              puVar11 = puVar10;\n              __ptr = accumulator;\n              unaff_RBP = in_R9;\n              if (lVar9 != 0) {\n                *outputArray2 = puVar14;\n                outputArray2[1] = lVar9;\n                outputArray2 = outputArray2 + 2;\n              }\n            }\n            puVar11 = (undefined8 *)((long)outputArray2 - (long)param_8 >> 4);\n            qsort(param_8,(size_t)puVar11,0x10,FUN_00103533);\n            lVar9 = callbackManager2;\n            accumulator = __ptr;\n            unaff_RBP = puVar12;\n            __ptr = param_8;\n          } while( true );\n        }\n        goto LAB_001049cf;\n      }\n      iVar4 = strcmp(pcVar1 + (pcVar1[2] == '_'),\"__gnu_lto_slim\");\n      param_8 = input;\n      if (iVar4 == 0) {\n        if (DAT_0010b230 != '\\0') {\n          param_8 = (undefined8 *)*unaff_RBP;\n          DAT_0010b230 = '\\0';\n          uVar6 = dcgettext(0,\"%s: plugin needed to handle lto object\",5);\n          FUN_00106400(uVar6,param_8);\n        }\n        goto LAB_00104a03;\n      }\n      if (DAT_0010b7e8 != 0) goto LAB_00104ae2;\nLAB_00104a11:\n      if (DAT_0010b808 == 0) {\n        if (DAT_0010b7d8 == 0) goto LAB_00104a2d;\n        uVar5 = (*(uint *)(input + 3) >> 7 ^ 1) & 1;\n        goto LAB_00104af9;\n      }\n      if ((((*(uint *)(input + 3) & 0x800082) == 0) && (inputType != 0x10c2a8)) &&\n         ((*(byte *)(inputType + 0x25) & 0x10) == 0)) goto LAB_001049c3;\nLAB_00104a2d:\n    } while ((DAT_0010b81c == 0) && ((*(byte *)(input + 3) & 4) != 0));\n  } while (DAT_0010b7f8 != 0);\n  in_R9 = (undefined8 *)(ulong)DAT_0010b7e4;\n  if (DAT_0010b7e4 == 0) {\n    cVar3 = (**(code **)(callbackManager + 0x230))(unaff_RBP);\n    if (cVar3 != '\\0') {\n      FUN_00102c19();\n      return;\n    }\n  }\n  else {\n    if (inputType == 0x10c2a8) goto LAB_001049c3;\nLAB_00104cba:\n    cVar3 = (**(code **)(callbackManager + 0x230))(unaff_RBP);\n    if (cVar3 != '\\0') {\n      FUN_00102c19();\n      return;\n    }\n  }\n  if (accumulator != accumulator2) {\n    if (increment != (undefined8 *)0x8) {\n      for (; increment != (undefined8 *)0x0; increment = (undefined8 *)((long)increment + -1)) {\n        *(undefined *)accumulator = *(undefined *)accumulator2;\n        accumulator2 = (undefined8 *)((long)accumulator2 + (ulong)bVar17 * -2 + 1);\n        accumulator = (undefined8 *)((long)accumulator + (ulong)bVar17 * -2 + 1);\n      }\n      FUN_001049c0();\n      return;\n    }\n    *accumulator = *accumulator2;\n    FUN_001049c0();\n    return;\n  }\n  accumulator = (undefined8 *)((long)accumulator + (long)increment);\n  goto LAB_001049c3;\ncode_r0x00104992:\n  outputArray2 = (undefined8 *)((long)limit * (long)increment);\n  limit = (undefined8 *)((long)param_9 + (long)outputArray2);\n  accumulator = param_9;\n  puVar12 = unaff_RBP;\n  if (param_9 < limit) goto code_r0x001049aa;\n  goto LAB_00104b15;\ncode_r0x001049aa:\n  unaff_retaddr = (ulong)bVar16;\n  accumulator2 = param_9;\n  goto LAB_001049cf;\n}\n\n",
            "called": [
                "qsort",
                "xmalloc",
                "free",
                "FUN_00106400",
                "FUN_00105110",
                "xrealloc",
                "FUN_00102fd2",
                "FUN_00103533",
                "strcmp",
                "dcgettext",
                "FUN_00104d5b",
                "FUN_00102c19",
                "FUN_001049c0",
                "FUN_00106530"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104d5b",
            "calling": [
                "FUN_00104d5b"
            ],
            "imported": false,
            "current_name": "process_lto_object_00104d5b"
        },
        "FUN_00106300": {
            "renaming": {
                "FUN_00106300": "print_error_message_00106300",
                "param_1": "errorCode",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6",
                "param_7": "param7",
                "param_8": "param8",
                "param_9": "param9",
                "param_10": "param10",
                "param_11": "param11",
                "param_12": "param12",
                "param_13": "param13",
                "param_14": "param14",
                "in_AL": "flag",
                "__arg": "argList",
                "__format": "formatString",
                "local_d8": "localVar1",
                "local_d4": "localVar2",
                "local_d0": "localVar3",
                "local_c8": "localVar4",
                "local_b8": "localArray",
                "local_b0": "localVar5",
                "local_a8": "localVar6",
                "local_a0": "localVar7",
                "local_98": "localVar8",
                "local_90": "localVar9",
                "local_88": "localVar10",
                "local_78": "localVar11",
                "local_68": "localVar12",
                "local_58": "localVar13",
                "local_48": "localVar14",
                "local_38": "localVar15",
                "local_28": "localVar16",
                "local_18": "localVar17"
            },
            "code": "\n\n\nvoid printErrorMessage_00106300(undefined4 errorCode,undefined4 param2,undefined4 param3,undefined4 param4,\n                 undefined4 param5,undefined4 param6,undefined4 param7,undefined4 param8,\n                 undefined8 param9,undefined8 param10,undefined8 param11,undefined8 param12,\n                 undefined8 param13,undefined8 param14)\n\n{\n  char flag;\n  undefined4 *argList;\n  char *formatString;\n  undefined4 localVar1;\n  undefined4 localVar2;\n  undefined *localVar3;\n  undefined *localVar4;\n  undefined localArray [8];\n  undefined8 localVar5;\n  undefined8 localVar6;\n  undefined8 localVar7;\n  undefined8 localVar8;\n  undefined8 localVar9;\n  undefined4 localVar10;\n  undefined4 localVar11;\n  undefined4 localVar12;\n  undefined4 localVar13;\n  undefined4 localVar14;\n  undefined4 localVar15;\n  undefined4 localVar16;\n  undefined4 localVar17;\n  \n  argList = &localVar1;\n  if (flag != '\\0') {\n    localVar10 = errorCode;\n    localVar11 = param2;\n    localVar12 = param3;\n    localVar13 = param4;\n    localVar14 = param5;\n    localVar15 = param6;\n    localVar16 = param7;\n    localVar17 = param8;\n  }\n  localVar3 = &stack0x00000008;\n  localVar1 = 8;\n  localVar4 = localArray;\n  localVar2 = 0x30;\n  localVar5 = param10;\n  localVar6 = param11;\n  localVar7 = param12;\n  localVar8 = param13;\n  localVar9 = param14;\n  FUN_001063a0();\n  formatString = (char *)0x1;\n  xexit();\n  fflush(_stdout);\n  fprintf(_stderr,\"%s: \",DAT_0010b820);\n  vfprintf(_stderr,formatString,argList);\n  putc(10,_stderr);\n  return;\n}\n\n",
            "called": [
                "FUN_001063a0",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00106300",
            "calling": [
                "FUN_0010370a",
                "FUN_00103729",
                "FUN_001055f0",
                "FUN_001053c0",
                "FUN_00104370"
            ],
            "imported": false,
            "current_name": "print_error_message_00106300"
        },
        "FUN_00102f7b": {
            "renaming": {
                "FUN_00102f7b": "print_message_if_condition_met_00102f7b",
                "param_1": "message"
            },
            "code": "\n\n\nvoid print_message_if_condition_met_00102f7b(undefined8 message)\n\n{\n  if ((_DAT_0010b7c4 != 0) && (DAT_0010b818 == 0)) {\n    printf(\"%s:\\n\",message);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f7b",
            "calling": [],
            "imported": false,
            "current_name": "print_message_if_condition_met_00102f7b"
        },
        "FUN_00106540": {
            "renaming": {
                "FUN_00106540": "print_error_message_00106540",
                "param_1": "errorType",
                "iVar1": "errorCode",
                "uVar2": "errorMessage",
                "in_R10": "additionalInfo"
            },
            "code": "\n\n\nvoid printErrorMessage_00106540(long errorType)\n\n{\n  int errorCode;\n  undefined8 errorMessage;\n  undefined8 additionalInfo;\n  \n  errorCode = bfd_get_error();\n  if (errorCode == 0) {\n    errorMessage = dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    errorMessage = bfd_errmsg(errorCode);\n  }\n  fflush(_stdout);\n  if (errorType != 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",DAT_0010b820,errorType,errorMessage,additionalInfo);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",DAT_0010b820,errorMessage,additionalInfo);\n  return;\n}\n\n",
            "called": [
                "FUN_00103a78",
                "fflush",
                "bfd_get_error",
                "fprintf",
                "bfd_errmsg"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00106540",
            "calling": [
                "FUN_001043d0",
                "FUN_00106530"
            ],
            "imported": false,
            "current_name": "print_error_message_00106540"
        }
    },
    "used_tokens": 110247,
    "layers": [
        [
            "FUN_00103c00",
            "FUN_0010370a",
            "FUN_00104370",
            "FUN_00103b5d",
            "FUN_001036a7",
            "FUN_00102f19",
            "FUN_00102fc3",
            "FUN_00103729",
            "FUN_00103573",
            "FUN_00105110",
            "FUN_00102fd2",
            "FUN_00102f9f",
            "FUN_00103a66",
            "FUN_001035a2",
            "FUN_00103463",
            "FUN_00104397",
            "FUN_00104670",
            "FUN_00103a78",
            "FUN_001048e0",
            "FUN_00102020",
            "FUN_001062d0",
            "FUN_00103238",
            "FUN_001036e0",
            "FUN_001047d0",
            "FUN_0010249f",
            "FUN_001043d0",
            "FUN_001025f5",
            "FUN_00102670",
            "FUN_00104fa0",
            "FUN_001064a0",
            "FUN_001054d0",
            "FUN_001053b0",
            "FUN_001055f0",
            "FUN_0010351b",
            "FUN_00103b2b",
            "FUN_00104740",
            "FUN_00106400",
            "FUN_00103533",
            "FUN_0010651a",
            "FUN_001053c0",
            "FUN_001064b0",
            "FUN_00103b49",
            "FUN_00103abf",
            "FUN_00103bf6",
            "FUN_00102450",
            "FUN_00102c19",
            "FUN_00106530",
            "FUN_0010268b",
            "FUN_00103bec",
            "FUN_001063a0",
            "FUN_00102739",
            "FUN_00105050",
            "FUN_001049c0",
            "FUN_00103ca0",
            "FUN_00104d5b",
            "FUN_00106300",
            "FUN_00102f7b",
            "FUN_00106540"
        ]
    ],
    "locked_functions": []
}