{
    "functions": {
        "putc": {
            "renaming": {},
            "code": "\n\n\nint putc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = putc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102250",
            "calling": [
                "FUN_001063a0",
                "FUN_00103463"
            ],
            "imported": false,
            "current_name": "putc"
        },
        "bfd_close": {
            "renaming": {},
            "code": "\nvoid bfd_close(void)\n\n{\n  bfd_close();\n  return;\n}\n\n",
            "called": [
                "bfd_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102360",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "bfd_close"
        },
        "_FINI_0": {
            "renaming": {},
            "code": "\nvoid _FINI_0(void)\n\n{\n  if (DAT_0010b720 != '\\0') {\n    return;\n  }\n  __cxa_finalize(PTR_LOOP_0010b228);\n  FUNC_00105530();\n  DAT_0010b720 = 1;\n  return;\n}\n\n",
            "called": [
                "FUN_00105530",
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001055a0",
            "calling": [],
            "imported": false,
            "current_name": "_FINI_0"
        },
        "strchr": {
            "renaming": {},
            "code": "\n\n\nchar * strchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strchr(__s,__c);\n  return pcVar1;\n}\n\n",
            "called": [
                "strchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102180",
            "calling": [
                "FUN_00102739"
            ],
            "imported": false,
            "current_name": "strchr"
        },
        "FUN_00103c00": {
            "renaming": {
                "FUN_00103c00": "update_reloc_table_00103c00",
                "param_1": "ptrToParam1",
                "param_2": "param2",
                "param_3": "relocTable",
                "param_4": "param4",
                "param_5": "param5",
                "puVar1": "newPtr",
                "auVar2": "newArray",
                "lVar3": "length",
                "uVar4": "xmallocResult",
                "uVar5": "canonicalizeResult"
            },
            "code": "\nundefined8\nupdateRelocTable_00103c00(undefined8 *ptrToParam1,long param2,undefined (*relocTable) [16],undefined8 param4,\n            undefined8 param5)\n\n{\n  undefined8 *newPtr;\n  undefined newArray [16];\n  long length;\n  undefined8 xmallocResult;\n  undefined8 canonicalizeResult;\n  \n  **(long **)*relocTable = param2;\n  if ((*(byte *)(param2 + 0x24) & 4) == 0) {\n    **(undefined8 **)(*relocTable + 8) = 0;\n    **(undefined8 **)relocTable[1] = 0;\n  }\n  else {\n    length = bfd_get_reloc_upper_bound();\n    if (-1 < length) {\n      newPtr = *(undefined8 **)(*relocTable + 8);\n      xmallocResult = xmalloc(length);\n      canonicalizeResult = *(undefined8 *)(relocTable[1] + 8);\n      *newPtr = xmallocResult;\n      newPtr = *(undefined8 **)relocTable[1];\n      canonicalizeResult = bfd_canonicalize_reloc(ptrToParam1,param2,**(undefined8 **)(*relocTable + 8),canonicalizeResult);\n      *newPtr = canonicalizeResult;\n      if (-1 < **(long **)relocTable[1]) goto LAB_00103c7c;\n    }\n    handle_error_00106530(*ptrToParam1);\n  }\nLAB_00103c7c:\n  length = *(long *)(*relocTable + 8) + 8;\n  *(long *)relocTable[1] = *(long *)relocTable[1] + 8;\n  newArray._8_4_ = (int)length;\n  newArray._0_8_ = *(long *)*relocTable + 8;\n  newArray._12_4_ = (int)((ulong)length >> 0x20);\n  *relocTable = newArray;\n  return param5;\n}\n\n",
            "called": [
                "FUN_00106530",
                "bfd_canonicalize_reloc",
                "bfd_get_reloc_upper_bound",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103c00",
            "calling": [
                "FUN_00103238"
            ],
            "imported": false,
            "current_name": "update_reloc_table_00103c00"
        },
        "fseek": {
            "renaming": {},
            "code": "\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 = fseek(__stream,__off,__whence);\n  return iVar1;\n}\n\n",
            "called": [
                "fseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022d0",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "fseek"
        },
        "FUN_0010370a": {
            "renaming": {
                "FUN_0010370a": "print_symbol_information_0010370a",
                "plVar4": "widthPointer",
                "uVar9": "maskedRBX",
                "pcVar10": "symmetryType",
                "cVar1": "isUndefined",
                "uVar2": "symClass",
                "iVar3": "asprintfResult",
                "lVar7": "objectPointer",
                "unaff_RBX": "RBX",
                "bVar8": "symType",
                "piVar5": "errnoPointer"
            },
            "code": "\nvoid printSymbolInformation_0010370a(void)\n\n{\n  char isUndefined;\n  ushort symClass;\n  int asprintfResult;\n  long *widthPointer;\n  int *errnoPointer;\n  undefined8 uVar6;\n  long objectPointer;\n  ulong RBX;\n  byte symType;\n  ulong maskedRBX;\n  char *symmetryType;\n  \n  widthPointer = (long *)dcgettext(0,\"Print width has not been initialized (%d)\",5);\n  maskedRBX = RBX & 0xffffffff;\n  print_error_and_exit_00106300(widthPointer,maskedRBX);\n  print_formatted_message_00104740(\"%-20s|\",widthPointer,0,maskedRBX);\n  isUndefined = bfd_is_undefined_symclass((int)*(char *)(*widthPointer + 8));\n  if (isUndefined == '\\0') {\n    print_symmetry_001054d0(*(undefined8 *)*widthPointer);\n  }\n  else if (DAT_0010b7a8 == 0x20) {\n    printf(\"        \");\n  }\n  else {\n    printf(\"                \");\n  }\n  printf(\"|   %c  |\",(ulong)(uint)(int)*(char *)(*widthPointer + 8));\n  if (*(char *)(*widthPointer + 8) == '-') {\n    printf(\"%18s|  \",*(undefined8 *)(*widthPointer + 0x20));\n    printf(&DAT_0010b23d,(ulong)(uint)(int)*(short *)(*widthPointer + 0x1a));\n    goto LAB_00103a54;\n  }\n  if (widthPointer[2] == 0) {\n    if (widthPointer[3] != 0) {\n      objectPointer = *(long *)(widthPointer[3] + 0x30);\n      isUndefined = *(char *)(objectPointer + 0x28);\n      if (isUndefined == 'g') goto LAB_00103983;\n      if (isUndefined == 'h') {\n        symmetryType = \"Line\";\n      }\n      else if (isUndefined == 'd') {\n        symmetryType = \"Block\";\n      }\n      else if (*(ushort *)(objectPointer + 0x26) == 0) {\n        symmetryType = \"None\";\n      }\n      else {\n        symClass = *(ushort *)(objectPointer + 0x26) >> 4 & 3;\n        if (symClass == 2) {\n          symmetryType = \"Function\";\n        }\n        else if (symClass == 3) {\n          symmetryType = \"Array\";\n        }\n        else {\n          if (symClass != 1) {\n            free(DAT_0010b730);\n            symClass = *(ushort *)(objectPointer + 0x26);\n            symType = *(byte *)(objectPointer + 0x28);\n            symmetryType = (char *)dcgettext(0,\"<unknown>: %d/%d\",5);\n            asprintfResult = asprintf(&DAT_0010b730,symmetryType,(ulong)symType,(ulong)symClass);\n            symmetryType = DAT_0010b730;\n            goto joined_r0x00103964;\n          }\n          symmetryType = \"Pointer\";\n        }\n      }\n      goto LAB_001039c0;\n    }\n    printf(\"                  |\");\n  }\n  else {\n    symType = *(byte *)(widthPointer[2] + 0x48) & 0xf;\n    switch(symType) {\n    case 0:\n      symmetryType = \"NOTYPE\";\n      break;\n    case 1:\n      symmetryType = \"OBJECT\";\n      break;\n    case 2:\n      symmetryType = \"FUNC\";\n      break;\n    case 3:\n      symmetryType = \"SECTION\";\n      break;\n    case 4:\n      symmetryType = \"FILE\";\n      break;\n    case 5:\n      symmetryType = \"COMMON\";\n      break;\n    case 6:\n      symmetryType = \"TLS\";\n      break;\n    default:\n      free(DAT_0010b728);\n      symmetryType = \"<processor specific>: %d\";\n      if ((2 < symType - 0xd) && (symmetryType = \"<OS specific>: %d\", 2 < symType - 10)) {\n        symmetryType = \"<unknown>: %d\";\n      }\n      symmetryType = (char *)dcgettext(0,symmetryType,5);\n      asprintfResult = asprintf(&DAT_0010b728,symmetryType,(ulong)symType);\n      symmetryType = DAT_0010b728;\njoined_r0x00103964:\n      if (asprintfResult < 0) {\n        errnoPointer = __errno_location();\n        uVar6 = xstrerror(*errnoPointer);\n        print_error_and_exit_00106300(&DAT_0010712d,uVar6);\nLAB_00103983:\n        symmetryType = \"File\";\n      }\n    }\nLAB_001039c0:\n    printf(\"%18s|\",symmetryType);\n  }\n  if (widthPointer[2] == 0) {\n    if (widthPointer[1] != 0) goto LAB_001039fb;\nLAB_00103a02:\n    if (DAT_0010b7a8 == 0x20) {\n      printf(\"        \");\n    }\n    else {\n      printf(\"                \");\n    }\n  }\n  else {\n    if (*(long *)(widthPointer[2] + 0x38) == 0) goto LAB_00103a02;\nLAB_001039fb:\n    print_symmetry_001054d0();\n  }\n  objectPointer = widthPointer[2];\n  if ((objectPointer != 0) || (objectPointer = widthPointer[3], objectPointer != 0)) {\n    printf(\"|     |%s\",**(undefined8 **)(objectPointer + 0x20));\n    return;\n  }\nLAB_00103a54:\n  printf(\"|     |\");\n  return;\n}\n\n",
            "called": [
                "FUN_00106300",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010370a",
            "calling": [
                "FUN_001054d0"
            ],
            "imported": false,
            "current_name": "print_symbol_information_0010370a"
        },
        "FUN_00104370": {
            "renaming": {
                "FUN_00104370": "initialize_output_format_00104370",
                "param_1": "output_format",
                "uVar1": "error_msg",
                "ppuVar2": "initialized_data"
            },
            "code": "\nundefined ** initialize_output_format_00104370(undefined *output_format,undefined8 param_2)\n\n{\n  undefined8 error_msg;\n  undefined **initialized_data;\n  \n  switch(*output_format) {\n  case 0x42:\n  case 0x62:\n    DAT_0010b7c0 = 0;\n    PTR_PTR_FUN_0010b260 = (undefined *)&PTR_FUN_0010ace0;\n    return &PTR_FUN_0010ace0;\n  default:\n    error_msg = dcgettext(0,\"%s: invalid output format\",5);\n    print_error_and_exit_00106300(error_msg,output_format);\n    error_msg = dcgettext(0,\"Warning: \\'%s\\' is not an ordinary file\",5);\n    print_error_message_00106400(error_msg);\n    return (undefined **)0x0;\n  case 0x4a:\n  case 0x6a:\n    initialized_data = (undefined **)initialize_data_00104397(output_format,param_2,3);\n    return initialized_data;\n  case 0x50:\n  case 0x70:\n    initialized_data = (undefined **)initialize_data_00104397(output_format,param_2,2);\n    return initialized_data;\n  case 0x53:\n  case 0x73:\n    initialized_data = (undefined **)initialize_data_00104397(output_format,param_2,1);\n    return initialized_data;\n  }\n}\n\n",
            "called": [
                "FUN_00106300",
                "FUN_00104397",
                "caseD_4a",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104370",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "initialize_output_format_00104370"
        },
        "xmalloc": {
            "renaming": {},
            "code": "\nvoid xmalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021e0",
            "calling": [
                "FUN_00103c00",
                "FUN_00103238",
                "FUN_001055f0",
                "FUN_00104d5b",
                "FUN_00105110",
                "FUN_0010268b"
            ],
            "imported": false,
            "current_name": "xmalloc"
        },
        "vfprintf": {
            "renaming": {},
            "code": "\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n  int iVar1;\n  \n  iVar1 = vfprintf(__s,__format,__arg);\n  return iVar1;\n}\n\n",
            "called": [
                "vfprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102370",
            "calling": [
                "FUN_001063a0"
            ],
            "imported": false,
            "current_name": "vfprintf"
        },
        "putchar": {
            "renaming": {},
            "code": "\n\n\nint putchar(int __c)\n\n{\n  int iVar1;\n  \n  iVar1 = putchar(__c);\n  return iVar1;\n}\n\n",
            "called": [
                "putchar"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102050",
            "calling": [
                "FUN_001064b0",
                "FUN_001035a2"
            ],
            "imported": false,
            "current_name": "putchar"
        },
        "bfd_set_default_target": {
            "renaming": {},
            "code": "\nvoid bfd_set_default_target(void)\n\n{\n  bfd_set_default_target();\n  return;\n}\n\n",
            "called": [
                "bfd_set_default_target"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020d0",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "bfd_set_default_target"
        },
        "bfd_get_error": {
            "renaming": {},
            "code": "\nvoid bfd_get_error(void)\n\n{\n  bfd_get_error();\n  return;\n}\n\n",
            "called": [
                "bfd_get_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021d0",
            "calling": [
                "FUN_001055f0",
                "FUN_00106540",
                "FUN_001048e0",
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "bfd_get_error"
        },
        "FUN_00103b5d": {
            "renaming": {
                "FUN_00103b5d": "print_matching_formats_00103b5d",
                "param_1": "formats",
                "uVar1": "formatMessage",
                "__format": "messageTemplate",
                "plVar2": "currentFormat",
                "_stdout": "standardOutput",
                "_stderr": "standardError"
            },
            "code": "\n\n\nvoid printMatchingFormats_00103b5d(long *formats)\n\n{\n  undefined8 formatMessage;\n  char *messageTemplate;\n  long *currentFormat;\n  \n  fflush(standardOutput);\n  formatMessage = DAT_0010b820;\n  messageTemplate = (char *)dcgettext(0,\"%s: Matching formats:\",5);\n  fprintf(standardError,messageTemplate,formatMessage);\n  for (currentFormat = formats; *currentFormat != 0; currentFormat = currentFormat + 1) {\n    fprintf(standardError,\" %s\");\n  }\n  free(formats);\n  fputc(10,standardError);\n  return;\n}\n\n",
            "called": [
                "fflush",
                "fprintf",
                "fputc",
                "dcgettext",
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103b5d",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "print_matching_formats_00103b5d"
        },
        "FUN_001036a7": {
            "renaming": {
                "FUN_001036a7": "print_function_names_001036a7",
                "param_1": "functionName",
                "param_2": "parameterName",
                "param_3": "unusedParam",
                "param_4": "thirdParameter"
            },
            "code": "\nvoid printFunctionNames_001036a7(undefined8 *functionName,undefined8 *parameterName,undefined8 unusedParam,undefined8 thirdParameter)\n\n{\n  if (DAT_0010b818 != 0) {\n    if (functionName != (undefined8 *)0x0) {\n      printf(\"%s:\",*functionName);\n    }\n    printf(\"%s:\",*parameterName,thirdParameter);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001036a7",
            "calling": [],
            "imported": false,
            "current_name": "print_function_names_001036a7"
        },
        "FUN_00102f19": {
            "renaming": {
                "FUN_00102f19": "print_symbols_info_00102f19",
                "param_1": "fileName",
                "pcVar1": "formatString"
            },
            "code": "\nvoid printSymbolsInfo_00102f19(undefined8 fileName)\n\n{\n  char *formatString;\n  \n  formatString = \"\\n\\nUndefined symbols from %s:\\n\\n\";\n  if (DAT_0010b7e8 == 0) {\n    formatString = \"\\n\\nSymbols from %s:\\n\\n\";\n  }\n  formatString = (char *)dcgettext(0,formatString,5);\n  printf(formatString,fileName);\n  formatString = \"Name                  Value   Class        Type         Size     Line  Section\\n\\n\";\n  if (DAT_0010b7a8 != 0x20) {\n    formatString = \n    \"Name                  Value           Class        Type         Size             Line  Section\\n\\n\"\n    ;\n  }\n  formatString = (char *)dcgettext(0,formatString,5);\n  printf(formatString);\n  return;\n}\n\n",
            "called": [
                "printf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f19",
            "calling": [],
            "imported": false,
            "current_name": "print_symbols_info_00102f19"
        },
        "__cxa_finalize": {
            "renaming": {},
            "code": "\nvoid __cxa_finalize(void)\n\n{\n  __cxa_finalize();\n  return;\n}\n\n",
            "called": [
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102440",
            "calling": [
                "_FINI_0"
            ],
            "imported": false,
            "current_name": "__cxa_finalize"
        },
        "FUN_00102fc3": {
            "renaming": {
                "FUN_00102fc3": "check_compiled_code_00102fc3",
                "param_1": "param1",
                "param_2": "param2",
                "cVar1": "lastCharacter",
                "__s": "string1",
                "__s_00": "string2",
                "uVar2": "string1Length",
                "uVar3": "string2Length",
                "pcVar8": "compiledString1",
                "pcVar9": "compiledString2",
                "uVar10": "compareResult",
                "uVar11": "offset1",
                "uVar12": "offset2",
                "uVar13": "error",
                "unaff_R13": "errorHandle",
                "bVar14": "isCompiled"
            },
            "code": "\nulong checkCompiledCode_00102fc3(undefined8 param1,undefined8 param2)\n\n{\n  char lastCharacter;\n  ulong string1Length;\n  char *string1;\n  char *string2;\n  uint string2Length;\n  long lVar4;\n  long lVar5;\n  size_t sVar6;\n  size_t sVar7;\n  char *compiledString1;\n  char *compiledString2;\n  ulong compareResult;\n  ulong offset1;\n  ulong offset2;\n  undefined8 error;\n  long errorHandle;\n  bool isCompiled;\n  \n  error = *DAT_0010b780;\n  handle_error_00106530();\n  lVar4 = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,DAT_0010b778,error,DAT_0010b770);\n  lVar5 = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,DAT_0010b778,param2,DAT_0010b768);\n  if ((lVar4 == 0) || (errorHandle = lVar5, lVar5 == 0)) {\n    lVar5 = handle_error_00106530(*DAT_0010b780);\n  }\n  if ((*(long *)(lVar4 + 0x20) == 0x10c2a8) || (*(long *)(lVar5 + 0x20) == 0x10c2a8)) {\n                    \n    abort();\n  }\n  compareResult = *(ulong *)(*(long *)(lVar4 + 0x20) + 0x30);\n  string1Length = *(ulong *)(*(long *)(lVar5 + 0x20) + 0x30);\n  offset2 = *(long *)(lVar4 + 0x10) + compareResult;\n  offset1 = *(long *)(errorHandle + 0x10) + string1Length;\n  isCompiled = offset2 < offset1;\n  if ((offset2 != offset1) || (isCompiled = compareResult < string1Length, compareResult != string1Length)) {\n    return (ulong)(-(uint)isCompiled | 1);\n  }\n  string1 = *(char **)(lVar4 + 8);\n  string2 = *(char **)(errorHandle + 8);\n  sVar6 = strlen(string1);\n  sVar7 = strlen(string2);\n  compiledString1 = strstr(string1,\"gnu_compiled\");\n  if (compiledString1 == (char *)0x0) {\n    compiledString2 = strstr(string1,\"gcc2_compiled\");\n    compiledString1 = strstr(string2,\"gnu_compiled\");\n    if ((compiledString1 == (char *)0x0) && (compiledString1 = strstr(string2,\"gcc2_compiled\"), compiledString1 == (char *)0x0))\n    goto joined_r0x00103157;\n    if (compiledString2 == (char *)0x0) {\n      return 1;\n    }\n  }\n  else {\n    compiledString1 = strstr(string2,\"gnu_compiled\");\n    if (compiledString1 == (char *)0x0) {\n      compiledString2 = strstr(string2,\"gcc2_compiled\");\njoined_r0x00103157:\n      if (compiledString2 != (char *)0x0) {\n        return 0xffffffff;\n      }\n    }\n  }\n  string2Length = *(uint *)(errorHandle + 0x18) & 0x4000;\n  if ((*(byte *)(lVar4 + 0x19) & 0x40) == 0) {\n    if ((sVar6 < 3) || (string1[sVar6 - 2] != '.')) {\n      if (string2Length != 0) {\n        return 1;\n      }\n      if ((sVar7 < 3) || (string2[sVar7 - 2] != '.')) goto LAB_00103202;\n      isCompiled = false;\n      goto LAB_001031e7;\n    }\n    lastCharacter = string1[sVar6 - 1];\n    isCompiled = lastCharacter == 'o' || lastCharacter == 'a';\n    if (string2Length == 0) {\n      if ((sVar7 < 3) || (string2[sVar7 - 2] != '.')) {\n        if (lastCharacter == 'o' || lastCharacter == 'a') {\n          return 0xffffffff;\n        }\n        goto LAB_00103202;\n      }\n      goto LAB_001031e7;\n    }\n  }\n  else {\n    if (string2Length != 0) goto LAB_00103202;\n    if (sVar7 < 3) {\n      return 0xffffffff;\n    }\n    if (string2[sVar7 - 2] != '.') {\n      return 0xffffffff;\n    }\n    isCompiled = true;\nLAB_001031e7:\n    if ((string2[sVar7 - 1] != 'o') && (string2[sVar7 - 1] != 'a')) {\n      if (isCompiled) {\n        return 0xffffffff;\n      }\n      goto LAB_00103202;\n    }\n  }\n  if (!isCompiled) {\n    return 1;\n  }\nLAB_00103202:\n  compareResult = compare_strings_00104fa0(error,param2);\n  return compareResult;\n}\n\n",
            "called": [
                "FUN_00106530"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102fc3",
            "calling": [
                "FUN_00105050"
            ],
            "imported": false,
            "current_name": "check_compiled_code_00102fc3"
        },
        "textdomain": {
            "renaming": {},
            "code": "\nvoid textdomain(void)\n\n{\n  textdomain();\n  return;\n}\n\n",
            "called": [
                "textdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102110",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "textdomain"
        },
        "concat": {
            "renaming": {},
            "code": "\nvoid concat(void)\n\n{\n  concat();\n  return;\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021b0",
            "calling": [
                "FUN_001025f5",
                "FUN_00104670"
            ],
            "imported": false,
            "current_name": "concat"
        },
        "fread": {
            "renaming": {},
            "code": "\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fread(__ptr,__size,__n,__stream);\n  return sVar1;\n}\n\n",
            "called": [
                "fread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020e0",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "fread"
        },
        "FUN_00103729": {
            "renaming": {
                "FUN_00103729": "print_symmetric_message_00103729",
                "param_1": "symbol_address",
                "param_2": "format_argument",
                "cVar1": "is_undefined_symbol",
                "uVar2": "symmetry_class",
                "iVar3": "error_code",
                "piVar4": "error_code_ptr",
                "uVar5": "error_message",
                "lVar6": "symbol_info",
                "bVar7": "symbol_type",
                "pcVar8": "symbol_type_name"
            },
            "code": "\nvoid print_symmetric_message_00103729(long *symbol_address,undefined8 format_argument)\n\n{\n  char is_undefined_symbol;\n  ushort symmetry_class;\n  int error_code;\n  int *error_code_ptr;\n  undefined8 error_message;\n  long symbol_info;\n  byte symbol_type;\n  char *symbol_type_name;\n  \n  print_formatted_message_00104740(\"%-20s|\",symbol_address,0,format_argument);\n  is_undefined_symbol = bfd_is_undefined_symclass((int)*(char *)(*symbol_address + 8));\n  if (is_undefined_symbol == '\\0') {\n    print_symmetry_001054d0(*(undefined8 *)*symbol_address);\n  }\n  else if (DAT_0010b7a8 == 0x20) {\n    printf(\"        \");\n  }\n  else {\n    printf(\"                \");\n  }\n  printf(\"|   %c  |\",(ulong)(uint)(int)*(char *)(*symbol_address + 8));\n  if (*(char *)(*symbol_address + 8) == '-') {\n    printf(\"%18s|  \",*(undefined8 *)(*symbol_address + 0x20));\n    printf(&DAT_0010b23d,(ulong)(uint)(int)*(short *)(*symbol_address + 0x1a));\n    goto LAB_00103a54;\n  }\n  if (symbol_address[2] == 0) {\n    if (symbol_address[3] != 0) {\n      symbol_info = *(long *)(symbol_address[3] + 0x30);\n      is_undefined_symbol = *(char *)(symbol_info + 0x28);\n      if (is_undefined_symbol == 'g') goto LAB_00103983;\n      if (is_undefined_symbol == 'h') {\n        symbol_type_name = \"Line\";\n      }\n      else if (is_undefined_symbol == 'd') {\n        symbol_type_name = \"Block\";\n      }\n      else if (*(ushort *)(symbol_info + 0x26) == 0) {\n        symbol_type_name = \"None\";\n      }\n      else {\n        symmetry_class = *(ushort *)(symbol_info + 0x26) >> 4 & 3;\n        if (symmetry_class == 2) {\n          symbol_type_name = \"Function\";\n        }\n        else if (symmetry_class == 3) {\n          symbol_type_name = \"Array\";\n        }\n        else {\n          if (symmetry_class != 1) {\n            free(DAT_0010b730);\n            symmetry_class = *(ushort *)(symbol_info + 0x26);\n            symbol_type = *(byte *)(symbol_info + 0x28);\n            symbol_type_name = (char *)dcgettext(0,\"<unknown>: %d/%d\",5);\n            error_code = asprintf(&DAT_0010b730,symbol_type_name,(ulong)symbol_type,(ulong)symmetry_class);\n            symbol_type_name = DAT_0010b730;\n            goto joined_r0x00103964;\n          }\n          symbol_type_name = \"Pointer\";\n        }\n      }\n      goto LAB_001039c0;\n    }\n    printf(\"                  |\");\n  }\n  else {\n    symbol_type = *(byte *)(symbol_address[2] + 0x48) & 0xf;\n    switch(symbol_type) {\n    case 0:\n      symbol_type_name = \"NOTYPE\";\n      break;\n    case 1:\n      symbol_type_name = \"OBJECT\";\n      break;\n    case 2:\n      symbol_type_name = \"FUNC\";\n      break;\n    case 3:\n      symbol_type_name = \"SECTION\";\n      break;\n    case 4:\n      symbol_type_name = \"FILE\";\n      break;\n    case 5:\n      symbol_type_name = \"COMMON\";\n      break;\n    case 6:\n      symbol_type_name = \"TLS\";\n      break;\n    default:\n      free(DAT_0010b728);\n      symbol_type_name = \"<processor specific>: %d\";\n      if ((2 < symbol_type - 0xd) && (symbol_type_name = \"<OS specific>: %d\", 2 < symbol_type - 10)) {\n        symbol_type_name = \"<unknown>: %d\";\n      }\n      symbol_type_name = (char *)dcgettext(0,symbol_type_name,5);\n      error_code = asprintf(&DAT_0010b728,symbol_type_name,(ulong)symbol_type);\n      symbol_type_name = DAT_0010b728;\njoined_r0x00103964:\n      if (error_code < 0) {\n        error_code_ptr = __errno_location();\n        error_message = xstrerror(*error_code_ptr);\n        print_error_and_exit_00106300(&DAT_0010712d,error_message);\nLAB_00103983:\n        symbol_type_name = \"File\";\n      }\n    }\nLAB_001039c0:\n    printf(\"%18s|\",symbol_type_name);\n  }\n  if (symbol_address[2] == 0) {\n    if (symbol_address[1] != 0) goto LAB_001039fb;\nLAB_00103a02:\n    if (DAT_0010b7a8 == 0x20) {\n      printf(\"        \");\n    }\n    else {\n      printf(\"                \");\n    }\n  }\n  else {\n    if (*(long *)(symbol_address[2] + 0x38) == 0) goto LAB_00103a02;\nLAB_001039fb:\n    print_symmetry_001054d0();\n  }\n  symbol_info = symbol_address[2];\n  if ((symbol_info != 0) || (symbol_info = symbol_address[3], symbol_info != 0)) {\n    printf(\"|     |%s\",**(undefined8 **)(symbol_info + 0x20));\n    return;\n  }\nLAB_00103a54:\n  printf(\"|     |\");\n  return;\n}\n\n",
            "called": [
                "printf",
                "FUN_00106300",
                "bfd_is_undefined_symclass",
                "FUN_001054d0",
                "dcgettext",
                "free",
                "xstrerror",
                "FUN_00104740",
                "__errno_location",
                "asprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103729",
            "calling": [],
            "imported": false,
            "current_name": "print_symmetric_message_00103729"
        },
        "exit": {
            "renaming": {},
            "code": "\n\n\nvoid exit(int __status)\n\n{\n                    \n  exit(__status);\n}\n\n",
            "called": [
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023c0",
            "calling": [
                "FUN_00103ca0",
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "exit"
        },
        "bfd_check_format": {
            "renaming": {},
            "code": "\nvoid bfd_check_format(void)\n\n{\n  bfd_check_format();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023d0",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "bfd_check_format"
        },
        "xstrerror": {
            "renaming": {},
            "code": "\nvoid xstrerror(void)\n\n{\n  xstrerror();\n  return;\n}\n\n",
            "called": [
                "xstrerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102330",
            "calling": [
                "FUN_00103729"
            ],
            "imported": false,
            "current_name": "xstrerror"
        },
        "FUN_00103573": {
            "renaming": {
                "FUN_00103573": "print_strings_00103573",
                "param_1": "string_1",
                "param_2": "string_2"
            },
            "code": "\nvoid print_strings_00103573(undefined8 *string_1,undefined8 *string_2,undefined8 param_3,undefined8 param_4)\n\n{\n  if (string_1 != (undefined8 *)0x0) {\n    printf(\"%s:\",*string_1);\n  }\n  printf(\"%s:\",*string_2,param_4);\n  return;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103573",
            "calling": [
                "FUN_001053b0"
            ],
            "imported": false,
            "current_name": "print_strings_00103573"
        },
        "FUN_00105110": {
            "renaming": {
                "FUN_00105110": "print_params_and_update_table_00105110",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4",
                "__ptr": "ptr",
                "__s1": "str1",
                "pplVar1": "ptrArrVar1",
                "plVar2": "ptrVar2",
                "lVar3": "var3",
                "puVar4": "ptrVar4",
                "cVar5": "charVar",
                "iVar6": "intVar",
                "pvVar7": "ptrVar7",
                "lVar8": "var8",
                "uVar9": "uintVar",
                "lVar10": "var10",
                "local_b4": "localVarB4",
                "local_b0": "localArrayB0",
                "local_a8": "localArrayA8",
                "local_a0": "localVarA0",
                "local_98": "localVar98",
                "local_90": "localVar90",
                "local_88": "localVar88",
                "pvStack_80": "stackVar80",
                "pvStack_78": "stackVar78",
                "pvStack_70": "stackVar70",
                "local_68": "localArray68",
                "local_60": "localCharVar60"
            },
            "code": "\n\n\nvoid print_params_and_update_table_00105110(undefined8 *arg1,long *arg2,undefined8 arg3,undefined8 *arg4)\n\n{\n  void *ptr;\n  char *str1;\n  long **ptrArrVar1;\n  long *ptrVar2;\n  long var3;\n  undefined8 *ptrVar4;\n  char charVar;\n  int intVar;\n  void *ptrVar7;\n  long var8;\n  uint uintVar;\n  long var10;\n  uint localVarB4;\n  undefined localArrayB0 [8];\n  undefined *localArrayA8;\n  undefined8 localVarA0;\n  long *localVar98;\n  long *localVar90;\n  void *localVar88;\n  void *stackVar80;\n  void *stackVar78;\n  void *stackVar70;\n  undefined localArray68 [8];\n  char localCharVar60;\n  \n  if (*(code **)(PTR_PTR_FUN_0010b260 + 0x18) == print_params_001053b0) {\n    if (DAT_0010b818 != 0) {\n      if (arg4 != (undefined8 *)0x0) {\n        printf(\"%s:\",*arg4);\n      }\n      printf(\"%s:\",*arg1);\n    }\n  }\n  else {\n    (**(code **)(PTR_PTR_FUN_0010b260 + 0x18))(arg4,arg1);\n  }\n  localArrayA8 = localArray68;\n  (**(code **)(arg1[1] + 0x218))(arg1,arg2,localArrayA8);\n  uintVar = *(uint *)(arg2 + 3);\n  charVar = localCharVar60;\n  if (((((localCharVar60 == 'i') && ((uintVar & 0x400000) != 0)) && (DAT_0010b7c8 != (char *)0x0)) &&\n      ((*DAT_0010b7c8 != '\\0' && (charVar = *DAT_0010b7c8, (uintVar & 2) == 0)))) &&\n     (charVar = localCharVar60, DAT_0010b7c8[1] != '\\0')) {\n    charVar = DAT_0010b7c8[1];\n  }\n  localCharVar60 = charVar;\n  localVarA0 = arg3;\n  if ((uintVar & 0x200100) != 0) goto LAB_00103330;\n  var8 = *arg2;\n  intVar = *(int *)(*(long *)(var8 + 8) + 8);\n  if (((uintVar & 0x200000) == 0) && (intVar == 5)) {\n    localVar98 = arg2;\n    if (*(long *)(var8 + 0x110) == 0) {\n      localVar98 = (long *)0x0;\n    }\n  }\n  else {\n    localVar98 = (long *)0x0;\n    if (((intVar - 2U & 0xfffffffd) == 0) && (localVar90 = arg2, *(long *)(var8 + 0x110) != 0))\n    goto LAB_001051bf;\n  }\n  localVar90 = (long *)0x0;\nLAB_001051bf:\n  (**(code **)(PTR_PTR_FUN_0010b260 + 0x20))(&localArrayA8,arg1);\n  do {\n    if (DAT_0010b804 == 0) {\nLAB_001051e6:\n      putc(10,_stdout);\n      return;\n    }\n    if (_DAT_0010b7b8 == arg1) {\n      ptrVar4 = _DAT_0010b7b8;\n      if (DAT_0010b758 == (void *)0x0) goto LAB_00105359;\nLAB_00105288:\n      _DAT_0010b7b8 = ptrVar4;\n      ptrVar7 = DAT_0010b750;\n      if (arg2[4] == 0x10c2a8) {\n        if (_DAT_0010b7b0 == arg1) {\n          if (DAT_0010b750 == (void *)0x0) goto LAB_001033d1;\n        }\n        else {\n          uintVar = 0;\n          if (DAT_0010b750 != (void *)0x0) {\n            for (; uintVar < DAT_0010b748; uintVar = uintVar + 1) {\n              ptr = *(void **)((long)ptrVar7 + (ulong)uintVar * 8);\n              if (ptr != (void *)0x0) {\n                free(ptr);\n              }\n            }\n            free(DAT_0010b740);\n            free(ptrVar7);\n            free(DAT_0010b738);\n            DAT_0010b740 = (void *)0x0;\n            DAT_0010b750 = (void *)0x0;\n            DAT_0010b738 = (void *)0x0;\n          }\nLAB_001033d1:\n          DAT_0010b748 = *(uint *)(arg1 + 0x14);\n          DAT_0010b740 = (void *)xmalloc((ulong)DAT_0010b748 * 8);\n          DAT_0010b750 = (void *)xmalloc((ulong)DAT_0010b748 << 3);\n          DAT_0010b738 = (void *)xmalloc((ulong)DAT_0010b748 << 3);\n          stackVar70 = DAT_0010b758;\n          localVar88 = DAT_0010b740;\n          stackVar80 = DAT_0010b750;\n          stackVar78 = DAT_0010b738;\n          bfd_map_over_sections(arg1,update_reloc_table_00103c00,&localVar88);\n          _DAT_0010b7b0 = arg1;\n        }\n        str1 = (char *)arg2[1];\n        for (uintVar = 0; uintVar < DAT_0010b748; uintVar = uintVar + 1) {\n          var8 = (ulong)uintVar * 8;\n          ptrVar7 = DAT_0010b738;\n          for (var10 = 0;\n              *(long *)((long)ptrVar7 + var8) != var10 && var10 <= *(long *)((long)ptrVar7 + var8)\n              ; var10 = var10 + 1) {\n            ptrArrVar1 = *(long ***)(*(long *)((long)DAT_0010b750 + var8) + var10 * 8);\n            ptrVar2 = *ptrArrVar1;\n            if ((((ptrVar2 != (long *)0x0) &&\n                 (var3 = *ptrVar2, *(long *)(var3 + 0x20) == arg2[4])) &&\n                (*(long *)(var3 + 0x10) == arg2[2])) &&\n               (((intVar = strcmp(str1,*(char **)(var3 + 8)), intVar == 0 &&\n                 (charVar = (**(code **)(arg1[1] + 0x240))\n                                    (arg1,DAT_0010b758,\n                                     *(undefined8 *)((long)DAT_0010b740 + var8),ptrArrVar1[1],\n                                     &localVar88,localArrayB0,&localVarB4,0), ptrVar7 = DAT_0010b738,\n                 charVar != '\\0')) && (localVar88 != (void *)0x0)))) {\n              printf(\"\\t%s:%u\",localVar88,(ulong)localVarB4);\n              uintVar = DAT_0010b748;\n              break;\n            }\n          }\n        }\n      }\n      else if (*(undefined8 **)(arg2[4] + 0xe0) == arg1) {\n        charVar = (**(code **)(arg1[1] + 0x250))(arg1,DAT_0010b758,arg2,&localVar88,&localVarB4);\n        if (((charVar != '\\0') ||\n            (charVar = (**(code **)(arg1[1] + 0x240))\n                               (arg1,DAT_0010b758,arg2[4],arg2[2],&localVar88,localArrayB0,\n                                &localVarB4,0), charVar != '\\0')) &&\n           ((localVar88 != (void *)0x0 && (localVarB4 != 0)))) {\n          printf(\"\\t%s:%u\");\n        }\n      }\n      goto LAB_001051e6;\n    }\n    if (DAT_0010b758 != (void *)0x0) {\n      free(DAT_0010b758);\n      DAT_0010b758 = (void *)0x0;\n    }\nLAB_00105359:\n    var8 = (**(code **)(arg1[1] + 0x1f8))(arg1);\n    if (var8 < 0) {\n      find_and_print_matching_data_00103463(var8);\n      return;\n    }\n    DAT_0010b758 = (void *)xmalloc();\n    var8 = (**(code **)(arg1[1] + 0x200))(arg1,DAT_0010b758);\n    ptrVar4 = arg1;\n    if (-1 < var8) goto LAB_00105288;\n    handle_error_00106530(*arg1);\nLAB_00103330:\n    localVar98 = (long *)0x0;\n    localVar90 = (long *)0x0;\n    (**(code **)(PTR_PTR_FUN_0010b260 + 0x20))(&localArrayA8,arg1);\n  } while( true );\n}\n\n",
            "called": [
                "FUN_001053c0",
                "printf",
                "FUN_001053b0",
                "FUN_00103238",
                "FUN_00106530",
                "free",
                "FUN_00103463",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105110",
            "calling": [
                "FUN_00104d5b"
            ],
            "imported": false,
            "current_name": "print_params_and_update_table_00105110"
        },
        "setlocale": {
            "renaming": {},
            "code": "\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = setlocale(__category,__locale);\n  return pcVar1;\n}\n\n",
            "called": [
                "setlocale"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022f0",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "setlocale"
        },
        "FUN_00102fd2": {
            "renaming": {
                "FUN_00102fd2": "check_binary_compatibility_00102fd2",
                "param_1": "binary_1",
                "param_2": "binary_2",
                "cVar1": "last_char",
                "__s": "string_1",
                "__s_00": "string_2",
                "uVar2": "string_2_length",
                "uVar3": "is_bit_14_set",
                "lVar4": "handler_1",
                "lVar5": "handler_2",
                "sVar6": "string_1_length",
                "sVar7": "string_2_length",
                "pcVar8": "compilation_info_1",
                "pcVar9": "compilation_info_2",
                "uVar10": "comparison_result_1",
                "uVar11": "comparison_result_2",
                "uVar12": "string_1_end_address",
                "unaff_R13": "string_2_end_address",
                "bVar13": "bit_comparison_result"
            },
            "code": "\nulong check_binary_compatibility_00102fd2(undefined8 binary_1,undefined8 binary_2)\n\n{\n  char last_char;\n  ulong string_2_length;\n  char *string_1;\n  char *string_2;\n  uint is_bit_14_set;\n  long handler_1;\n  long handler_2;\n  size_t string_1_length;\n  size_t string_2_length;\n  char *compilation_info_1;\n  char *compilation_info_2;\n  ulong comparison_result_1;\n  ulong comparison_result_2;\n  ulong string_1_end_address;\n  long string_2_end_address;\n  bool bit_comparison_result;\n  \n  handler_1 = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,DAT_0010b778,binary_1,DAT_0010b770);\n  handler_2 = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,DAT_0010b778,binary_2,DAT_0010b768);\n  if ((handler_1 == 0) || (string_2_end_address = handler_2, handler_2 == 0)) {\n    handler_2 = handle_error_00106530(*DAT_0010b780);\n  }\n  if ((*(long *)(handler_1 + 0x20) == 0x10c2a8) || (*(long *)(handler_2 + 0x20) == 0x10c2a8)) {\n                    \n    abort();\n  }\n  comparison_result_1 = *(ulong *)(*(long *)(handler_1 + 0x20) + 0x30);\n  string_2_length = *(ulong *)(*(long *)(handler_2 + 0x20) + 0x30);\n  string_1_end_address = *(long *)(handler_1 + 0x10) + comparison_result_1;\n  comparison_result_2 = *(long *)(string_2_end_address + 0x10) + string_2_length;\n  bit_comparison_result = string_1_end_address < comparison_result_2;\n  if ((string_1_end_address != comparison_result_2) || (bit_comparison_result = comparison_result_1 < string_2_length, comparison_result_1 != string_2_length)) {\n    return (ulong)(-(uint)bit_comparison_result | 1);\n  }\n  string_1 = *(char **)(handler_1 + 8);\n  string_2 = *(char **)(string_2_end_address + 8);\n  string_1_length = strlen(string_1);\n  string_2_length = strlen(string_2);\n  compilation_info_1 = strstr(string_1,\"gnu_compiled\");\n  if (compilation_info_1 == (char *)0x0) {\n    compilation_info_2 = strstr(string_1,\"gcc2_compiled\");\n    compilation_info_1 = strstr(string_2,\"gnu_compiled\");\n    if ((compilation_info_1 == (char *)0x0) && (compilation_info_1 = strstr(string_2,\"gcc2_compiled\"), compilation_info_1 == (char *)0x0))\n    goto joined_r0x00103157;\n    if (compilation_info_2 == (char *)0x0) {\n      return 1;\n    }\n  }\n  else {\n    compilation_info_1 = strstr(string_2,\"gnu_compiled\");\n    if (compilation_info_1 == (char *)0x0) {\n      compilation_info_2 = strstr(string_2,\"gcc2_compiled\");\njoined_r0x00103157:\n      if (compilation_info_2 != (char *)0x0) {\n        return 0xffffffff;\n      }\n    }\n  }\n  is_bit_14_set = *(uint *)(string_2_end_address + 0x18) & 0x4000;\n  if ((*(byte *)(handler_1 + 0x19) & 0x40) == 0) {\n    if ((string_1_length < 3) || (string_1[string_1_length - 2] != '.')) {\n      if (is_bit_14_set != 0) {\n        return 1;\n      }\n      if ((string_2_length < 3) || (string_2[string_2_length - 2] != '.')) goto LAB_00103202;\n      bit_comparison_result = false;\n      goto LAB_001031e7;\n    }\n    last_char = string_1[string_1_length - 1];\n    bit_comparison_result = last_char == 'o' || last_char == 'a';\n    if (is_bit_14_set == 0) {\n      if ((string_2_length < 3) || (string_2[string_2_length - 2] != '.')) {\n        if (last_char == 'o' || last_char == 'a') {\n          return 0xffffffff;\n        }\n        goto LAB_00103202;\n      }\n      goto LAB_001031e7;\n    }\n  }\n  else {\n    if (is_bit_14_set != 0) goto LAB_00103202;\n    if (string_2_length < 3) {\n      return 0xffffffff;\n    }\n    if (string_2[string_2_length - 2] != '.') {\n      return 0xffffffff;\n    }\n    bit_comparison_result = true;\nLAB_001031e7:\n    if ((string_2[string_2_length - 1] != 'o') && (string_2[string_2_length - 1] != 'a')) {\n      if (bit_comparison_result) {\n        return 0xffffffff;\n      }\n      goto LAB_00103202;\n    }\n  }\n  if (!bit_comparison_result) {\n    return 1;\n  }\nLAB_00103202:\n  comparison_result_1 = compare_strings_00104fa0(binary_1,binary_2);\n  return comparison_result_1;\n}\n\n",
            "called": [
                "FUN_00104fa0",
                "strlen",
                "FUN_00106530",
                "strstr",
                "abort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102fd2",
            "calling": [
                "FUN_00104d5b"
            ],
            "imported": false,
            "current_name": "check_binary_compatibility_00102fd2"
        },
        "bindtextdomain": {
            "renaming": {},
            "code": "\nvoid bindtextdomain(void)\n\n{\n  bindtextdomain();\n  return;\n}\n\n",
            "called": [
                "bindtextdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102140",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "bindtextdomain"
        },
        "FUN_00102f9f": {
            "renaming": {
                "FUN_00102f9f": "handle_error_and_return_00102f9f",
                "unaff_retaddr": "return_address",
                "auVar1": "result"
            },
            "code": "\nundefined  [16] handle_error_and_return_00102f9f(void)\n\n{\n  undefined result [16];\n  undefined8 return_address;\n  \n  handle_error_00106530(*DAT_0010b780);\n  result._8_8_ = return_address;\n  result._0_8_ = 0xffffffff;\n  return result;\n}\n\n",
            "called": [
                "FUN_00106530"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f9f",
            "calling": [
                "FUN_00104fa0"
            ],
            "imported": false,
            "current_name": "handle_error_and_return_00102f9f"
        },
        "dcgettext": {
            "renaming": {},
            "code": "\nvoid dcgettext(void)\n\n{\n  dcgettext();\n  return;\n}\n\n",
            "called": [
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102150",
            "calling": [
                "FUN_00103a78",
                "FUN_00103729",
                "FUN_00103abf",
                "FUN_00103ca0",
                "FUN_00102f19",
                "FUN_00103b5d",
                "FUN_001055f0",
                "FUN_00104d5b",
                "FUN_00102450",
                "FUN_001043d0",
                "FUN_001053c0",
                "FUN_00104370",
                "FUN_0010249f",
                "FUN_001048e0",
                "FUN_0010370a"
            ],
            "imported": false,
            "current_name": "dcgettext"
        },
        "bfd_set_error_program_name": {
            "renaming": {},
            "code": "\nvoid bfd_set_error_program_name(void)\n\n{\n  bfd_set_error_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102300",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "bfd_set_error_program_name"
        },
        "fputc": {
            "renaming": {},
            "code": "\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102210",
            "calling": [
                "FUN_00103ca0",
                "FUN_00103b5d"
            ],
            "imported": false,
            "current_name": "fputc"
        },
        "FUN_00103a66": {
            "renaming": {
                "FUN_00103a66": "check_symmetry_00103a66",
                "unaff_RBX": "ptr_data",
                "print_symmetry_0010651a": "print_symmetry"
            },
            "code": "\nvoid check_symmetry_00103a66(void)\n\n{\n  long ptr_data;\n  \n  if (*(long *)(ptr_data + 8) != 0) {\n    print_symmetry();\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_0010651a"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103a66",
            "calling": [
                "FUN_001064b0"
            ],
            "imported": false,
            "current_name": "check_symmetry_00103a66"
        },
        "_DT_INIT": {
            "renaming": {},
            "code": "\nvoid _DT_INIT(void)\n\n{\n  __gmon_start__();\n  return;\n}\n\n",
            "called": [
                "__gmon_start__"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102000",
            "calling": [],
            "imported": false,
            "current_name": "_DT_INIT"
        },
        "strcoll": {
            "renaming": {},
            "code": "\n\n\nint strcoll(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = strcoll(__s1,__s2);\n  return iVar1;\n}\n\n",
            "called": [
                "strcoll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022c0",
            "calling": [
                "FUN_00104fa0"
            ],
            "imported": false,
            "current_name": "strcoll"
        },
        "bfd_openr": {
            "renaming": {},
            "code": "\nvoid bfd_openr(void)\n\n{\n  bfd_openr();\n  return;\n}\n\n",
            "called": [
                "bfd_openr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102120",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "bfd_openr"
        },
        "cplus_demangle_set_style": {
            "renaming": {},
            "code": "\nvoid cplus_demangle_set_style(void)\n\n{\n  cplus_demangle_set_style();\n  return;\n}\n\n",
            "called": [
                "cplus_demangle_set_style"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102100",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "cplus_demangle_set_style"
        },
        "FUN_001035a2": {
            "renaming": {
                "FUN_001035a2": "print_symmetry_info_001035a2",
                "unaff_RBX": "array_ptr",
                "lVar1": "symmetry_ptr"
            },
            "code": "\nvoid print_symmetry_info_001035a2(void)\n\n{\n  long *array_ptr;\n  long symmetry_ptr;\n  \n  if (array_ptr[2] == 0) {\n    symmetry_ptr = array_ptr[1];\n  }\n  else {\n    symmetry_ptr = *(long *)(array_ptr[2] + 0x38);\n  }\n  if (symmetry_ptr != 0) {\n    putchar(0x20);\n    if (array_ptr[2] == 0) {\n      symmetry_ptr = array_ptr[1];\n    }\n    else {\n      symmetry_ptr = *(long *)(array_ptr[2] + 0x38);\n    }\n    print_symmetry_001054d0(symmetry_ptr);\n  }\n  printf(\" %c\",(ulong)(uint)(int)*(char *)(*array_ptr + 8));\n  if (*(char *)(*array_ptr + 8) != '-') {\n    print_formatted_message_00104740(&DAT_0010712c);\n    return;\n  }\n  putchar(0x20);\n  printf(&DAT_0010b238,(ulong)(uint)(int)*(char *)(*array_ptr + 0x19));\n  putchar(0x20);\n  printf(&DAT_0010b23d,(ulong)(uint)(int)*(short *)(*array_ptr + 0x1a));\n  printf(\" %5s\",*(undefined8 *)(*array_ptr + 0x20));\n  print_formatted_message_00104740(&DAT_0010712c);\n  return;\n}\n\n",
            "called": [
                "putchar",
                "printf",
                "FUN_001054d0",
                "FUN_00104740"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001035a2",
            "calling": [
                "FUN_001053c0"
            ],
            "imported": false,
            "current_name": "print_symmetry_info_001035a2"
        },
        "FUN_00103463": {
            "renaming": {
                "FUN_00103463": "find_and_print_matching_data_00103463",
                "unaff_R12": "inputString",
                "unaff_R13": "functionPointer",
                "unaff_R15": "baseAddress",
                "param_8": "counter",
                "param_10": "length",
                "in_stack_00000050": "filename",
                "plVar1": "currentData",
                "lVar2": "currentValue",
                "cVar3": "comparisonResult",
                "iVar4": "stringComparisonResult",
                "lVar5": "dataPointer",
                "lVar6": "innerCounter"
            },
            "code": "\n\n\nvoid findAndPrintMatchingData_00103463(void)\n\n{\n  long *currentData;\n  long currentValue;\n  char comparisonResult;\n  int stringComparisonResult;\n  long dataPointer;\n  char *inputString;\n  undefined8 *functionPointer;\n  long innerCounter;\n  long baseAddress;\n  undefined8 counter;\n  ulong length;\n  long filename;\n  \n  handle_error_00106530(*functionPointer);\n  do {\n    counter._4_4_ = counter._4_4_ + 1;\n    if (DAT_0010b748 <= counter._4_4_) {\n      putc(10,_stdout);\n      return;\n    }\n    dataPointer = DAT_0010b738;\n    for (innerCounter = 0; currentData = (long *)(dataPointer + (ulong)counter._4_4_ * 8),\n        *currentData != innerCounter && innerCounter <= *currentData; innerCounter = innerCounter + 1) {\n      currentData = **(long ***)(*(long *)(DAT_0010b750 + (ulong)counter._4_4_ * 8) + innerCounter * 8);\n      if ((((currentData != (long *)0x0) &&\n           (currentValue = *currentData, *(long *)(currentValue + 0x20) == *(long *)(baseAddress + 0x20))) &&\n          (*(long *)(currentValue + 0x10) == *(long *)(baseAddress + 0x10))) &&\n         (((stringComparisonResult = strcmp(inputString,*(char **)(currentValue + 8)), stringComparisonResult == 0 &&\n           (comparisonResult = (**(code **)(functionPointer[1] + 0x240))(), dataPointer = DAT_0010b738, comparisonResult != '\\0')) &&\n          (filename != 0)))) {\n        printf(\"\\t%s:%u\",filename,length >> 0x20);\n        counter._4_4_ = DAT_0010b748;\n        break;\n      }\n    }\n  } while( true );\n}\n\n",
            "called": [
                "strcmp",
                "printf",
                "putc",
                "FUN_00106530"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103463",
            "calling": [
                "FUN_00105110"
            ],
            "imported": false,
            "current_name": "find_and_print_matching_data_00103463"
        },
        "bfd_target_list": {
            "renaming": {},
            "code": "\nvoid bfd_target_list(void)\n\n{\n  bfd_target_list();\n  return;\n}\n\n",
            "called": [
                "bfd_target_list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021c0",
            "calling": [
                "FUN_00103ca0"
            ],
            "imported": false,
            "current_name": "bfd_target_list"
        },
        "FUN_00104397": {
            "renaming": {
                "FUN_00104397": "initialize_data_00104397",
                "param_1": "firstParam",
                "param_2": "secondParam",
                "param_3": "count"
            },
            "code": "\nvoid initializeData_00104397(undefined8 firstParam,undefined8 secondParam,int count)\n\n{\n  DAT_0010b7c0 = count;\n  PTR_PTR_FUN_0010b260 = (undefined *)(&PTR_FUN_0010ace0 + (long)count * 5);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104397",
            "calling": [
                "FUN_00104370",
                "caseD_4a"
            ],
            "imported": false,
            "current_name": "initialize_data_00104397"
        },
        "bfd_canonicalize_reloc": {
            "renaming": {},
            "code": "\nvoid bfd_canonicalize_reloc(void)\n\n{\n  bfd_canonicalize_reloc();\n  return;\n}\n\n",
            "called": [
                "bfd_canonicalize_reloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023a0",
            "calling": [
                "FUN_00103c00"
            ],
            "imported": false,
            "current_name": "bfd_canonicalize_reloc"
        },
        "free": {
            "renaming": {},
            "code": "\n\n\nvoid free(void *__ptr)\n\n{\n  free(__ptr);\n  return;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102040",
            "calling": [
                "FUN_00103729",
                "FUN_00103ca0",
                "FUN_00103238",
                "FUN_00103b5d",
                "FUN_001055f0",
                "FUN_00104d5b",
                "FUN_00105110",
                "FUN_001047d0",
                "FUN_0010268b",
                "FUN_00104670"
            ],
            "imported": false,
            "current_name": "free"
        },
        "xexit": {
            "renaming": {},
            "code": "\nvoid xexit(void)\n\n{\n  xexit();\n  return;\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102350",
            "calling": [
                "FUN_00106300",
                "FUN_00106530",
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "xexit"
        },
        "FUN_00104670": {
            "renaming": {
                "FUN_00104670": "determine_architecture_00104670",
                "param_1": "input_param",
                "iVar1": "architecture_size",
                "pcVar2": "architecture_name_ptr",
                "puVar3": "concatenation_ptr",
                "pcVar4": "architecture_suffix_ptr"
            },
            "code": "\nvoid determineArchitecture_00104670(long input_param)\n\n{\n  int architecture_size;\n  char *architecture_name_ptr;\n  undefined *concatenation_ptr;\n  char *architecture_suffix_ptr;\n  \n  DAT_0010b7a8 = bfd_get_arch_size();\n  if (DAT_0010b7a8 == -1) {\n    architecture_suffix_ptr = **(char ***)(input_param + 8);\n    architecture_name_ptr = strstr(architecture_suffix_ptr,\"64\");\n    architecture_size = 0x40;\n    if (architecture_name_ptr == (char *)0x0) {\n      architecture_size = strcmp(architecture_suffix_ptr,\"mmo\");\n      architecture_size = (-(uint)(architecture_size == 0) & 0x20) + 0x20;\n    }\n    DAT_0010b7a8 = architecture_size;\n    free(DAT_0010b7a0);\n  }\n  else {\n    free(DAT_0010b7a0);\n  }\n  if (DAT_0010b7c0 - 2U < 2) {\n    architecture_suffix_ptr = \"\";\n  }\n  else if (DAT_0010b7a8 == 0x20) {\n    architecture_suffix_ptr = \"08\";\n  }\n  else {\n    architecture_suffix_ptr = \"016\";\n  }\n  concatenation_ptr = &DAT_001071d0;\n  if (DAT_0010b244 != 0x10) {\n    if (DAT_0010b244 < 0x11) {\n      if (DAT_0010b244 == 8) {\n        concatenation_ptr = &DAT_001071ca;\n      }\n      else {\n        if (DAT_0010b244 != 10) {\n          DAT_0010b7a0 = (void *)concat(&DAT_001071d7,architecture_suffix_ptr,0,0);\n          return;\n        }\n        concatenation_ptr = &DAT_001071cd;\n      }\n    }\n    else {\n      concatenation_ptr = (undefined *)0x0;\n    }\n  }\n  DAT_0010b7a0 = (void *)concat(&DAT_001071d7,architecture_suffix_ptr,concatenation_ptr,0);\n  return;\n}\n\n",
            "called": [
                "strcmp",
                "FUN_001025f5",
                "bfd_get_arch_size",
                "free",
                "strstr",
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104670",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "determine_architecture_00104670"
        },
        "reconcat": {
            "renaming": {},
            "code": "\nvoid reconcat(void)\n\n{\n  reconcat();\n  return;\n}\n\n",
            "called": [
                "reconcat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102060",
            "calling": [
                "FUN_001047d0"
            ],
            "imported": false,
            "current_name": "reconcat"
        },
        "asprintf": {
            "renaming": {},
            "code": "\n\n\nint asprintf(char **__ptr,char *__fmt,...)\n\n{\n  int iVar1;\n  \n  iVar1 = asprintf(__ptr,__fmt);\n  return iVar1;\n}\n\n",
            "called": [
                "asprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022e0",
            "calling": [
                "FUN_00103729"
            ],
            "imported": false,
            "current_name": "asprintf"
        },
        "fopen": {
            "renaming": {},
            "code": "\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 = fopen(__filename,__modes);\n  return pFVar1;\n}\n\n",
            "called": [
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102340",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "fopen"
        },
        "stat": {
            "renaming": {},
            "code": "\n\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = stat(__file,__buf);\n  return iVar1;\n}\n\n",
            "called": [
                "stat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102280",
            "calling": [
                "FUN_001055f0",
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "stat"
        },
        "getopt_long": {
            "renaming": {},
            "code": "\nvoid getopt_long(void)\n\n{\n  getopt_long();\n  return;\n}\n\n",
            "called": [
                "getopt_long"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102170",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "getopt_long"
        },
        "xstrdup": {
            "renaming": {},
            "code": "\nvoid xstrdup(void)\n\n{\n  xstrdup();\n  return;\n}\n\n",
            "called": [
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102200",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "xstrdup"
        },
        "FUN_00103a78": {
            "renaming": {
                "FUN_00103a78": "print_error_message_00103a78",
                "uVar1": "errorString",
                "unaff_RBX": "fileLength",
                "unaff_retaddr": "returnAddress"
            },
            "code": "\n\n\nvoid printErrorMessage_00103a78(void)\n\n{\n  undefined8 errorString;\n  long fileLength;\n  undefined8 returnAddress;\n  \n  errorString = dcgettext(0,\"cause of error unknown\",5);\n  fflush(_stdout);\n  if (fileLength != 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",DAT_0010b820);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",DAT_0010b820,errorString,returnAddress);\n  return;\n}\n\n",
            "called": [
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103a78",
            "calling": [
                "FUN_00106540"
            ],
            "imported": false,
            "current_name": "print_error_message_00103a78"
        },
        "FUN_001048e0": {
            "renaming": {
                "FUN_001048e0": "process_object_001048e0",
                "param_1": "objectParam",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6",
                "bVar1": "byteVar1",
                "pcVar2": "codePtr",
                "cVar3": "charVar3",
                "iVar4": "intVar4",
                "uVar5": "uintVar5",
                "uVar6": "uintVar6",
                "lVar7": "longVar7",
                "ppuVar8": "ptrToPtr1",
                "ppuVar9": "ptrToPtr2",
                "lVar10": "longVar10",
                "puVar11": "ptrVar11",
                "unaff_RBX": "ptrUnaffRBX",
                "ppuVar12": "ptrToPtr3",
                "ppuVar13": "ptrToPtr4",
                "ppuVar14": "ptrToPtr5",
                "ppuVar15": "ptrToPtr6",
                "ppuVar16": "ptrToPtr7",
                "ppuVar17": "ptrToPtr8",
                "ppuVar18": "ptrToPtr9",
                "unaff_RBP": "ptrUnaffRBP",
                "unaff_R14": "ptrUnaffR14",
                "unaff_R15": "ptrUnaffR15",
                "bVar19": "boolVar19",
                "bVar20": "byteVar20",
                "ppuStack_78": "stackPtr",
                "local_4c": "localVar4c",
                "local_48": "localVar48",
                "local_40": "localArray"
            },
            "code": "\n\n\nvoid processObject_001048e0(ulong **objectParam,undefined8 param2,undefined8 param3,undefined8 param4,\n                 ulong **param5,ulong **param6)\n\n{\n  byte byteVar1;\n  code *codePtr;\n  char charVar3;\n  int intVar4;\n  uint uintVar5;\n  undefined8 uintVar6;\n  long longVar7;\n  ulong **ptrToPtr1;\n  ulong **ptrToPtr2;\n  long longVar10;\n  ulong *ptrVar11;\n  ulong **ptrUnaffRBX;\n  ulong **ptrToPtr3;\n  ulong **ptrToPtr4;\n  ulong **ptrUnaffRBP;\n  ulong **ptrToPtr5;\n  ulong **ptrToPtr6;\n  ulong **ptrToPtr7;\n  ulong **ptrToPtr8;\n  ulong **ptrToPtr9;\n  ulong **ptrUnaffR14;\n  ulong **ptrUnaffR15;\n  bool boolVar19;\n  byte byteVar20;\n  ulong **stackPtr;\n  uint localVar4c;\n  ulong *localVar48;\n  ulong **localArray [2];\n  \n  byteVar20 = 0;\n  localVar48 = (ulong *)0x0;\n  if ((DAT_0010b80c != 0) || ((*(byte *)((long)objectParam + 0x44) & 0x10) != 0)) {\n    ptrToPtr2 = (ulong **)&localVar4c;\n    ptrToPtr1 = (ulong **)(*(code *)objectParam[1][0x4d])(objectParam,DAT_0010b80c != 0,localArray);\n    if ((long)ptrToPtr1 < 0) {\n      if ((DAT_0010b80c != 0) && (intVar4 = bfd_get_error(), intVar4 == 7)) {\n        if (_DAT_0010b810 != 0) {\n          return;\n        }\n        ptrVar11 = *objectParam;\n        uintVar6 = dcgettext(0,\"%s: no symbols\",5);\n        print_error_message_00106400(uintVar6,ptrVar11);\n        return;\n      }\n      handle_error_00106530(*objectParam);\n      goto LAB_00102e9e;\n    }\n    if (ptrToPtr1 != (ulong **)0x0) {\n      if (DAT_0010b788 != 0) {\n        if (localVar4c == 8) goto LAB_00102d06;\n        goto LAB_00102cc2;\n      }\n      byteVar1 = *(byte *)((long)objectParam + 0x4a);\n      ptrToPtr4 = objectParam;\n      do {\n        if ((byteVar1 & 0x10) != 0) {\n          ptrUnaffRBX = (ulong **)*ptrToPtr4;\n          DAT_0010b230 = '\\0';\n          uintVar6 = dcgettext(0,\"%s: plugin needed to handle lto object\",5);\n          print_error_message_00106400(uintVar6);\n        }\n        ptrToPtr5 = localArray[0];\n        ptrUnaffR14 = (ulong **)(ulong)localVar4c;\n        boolVar19 = DAT_0010b80c != 0;\n        ptrToPtr2 = localArray[0];\n        ptrUnaffR15 = (ulong **)(*(code *)ptrToPtr4[1][0x41])(ptrToPtr4);\n        ptrToPtr3 = ptrUnaffRBX;\n        ptrUnaffRBP = (ulong **)(ulong)boolVar19;\n        objectParam = ptrToPtr4;\n        if (ptrUnaffR15 == (ulong **)0x0) goto LAB_00102ea7;\n        ptrToPtr8 = (ulong **)((long)ptrToPtr1 * (long)ptrUnaffR14);\n        ptrToPtr1 = (ulong **)((long)ptrToPtr5 + (long)ptrToPtr8);\n        objectParam = ptrToPtr5;\n        ptrToPtr3 = ptrToPtr5;\njoined_r0x001049a4:\n        if (objectParam < ptrToPtr1) {\n          do {\n            ptrToPtr2 = (ulong **)(*(code *)ptrToPtr4[1][0x4e])(ptrToPtr4,boolVar19,objectParam,ptrUnaffR15);\n            ptrToPtr8 = ptrUnaffR15;\n            if (ptrToPtr2 == (ulong **)0x0) goto LAB_00102eb0;\n            ptrVar11 = ptrToPtr2[1];\n            ptrToPtr8 = ptrToPtr1;\n            if (((ptrVar11 == (ulong *)0x0) || (*(char *)ptrVar11 != '_')) ||\n               (*(char *)((long)ptrVar11 + 1) != '_')) {\nLAB_00104a03:\n              if (DAT_0010b7e8 == 0) goto LAB_00104a11;\nLAB_00104ae2:\n              uintVar5 = (uint)(ptrToPtr2[4] == (ulong *)0x10c2a8);\nLAB_00104af9:\n              if (uintVar5 == 0) goto code_r0x00104b01;\nLAB_00104a2d:\n              if (DAT_0010b81c == 0) {\n                if ((*(byte *)(ptrToPtr2 + 3) & 4) == 0) {\n                  if (DAT_0010b7f8 != 0) goto process_lto_object_00104d5b;\nLAB_00104a53:\n                  param6 = (ulong **)(ulong)DAT_0010b7e4;\n                  if (DAT_0010b7e4 == 0) {\n                    charVar3 = (*(code *)ptrToPtr4[1][0x46])(ptrToPtr4,ptrToPtr2);\n                    if (charVar3 != '\\0') {\n                      slim_lto_object_handler_00102c19();\n                      return;\n                    }\n                    goto LAB_00104a7b;\n                  }\n                  if (ptrToPtr2[4] != (ulong *)0x10c2a8) goto LAB_00104cba;\n                }\n              }\n              else {\n                if (DAT_0010b7f8 == 0) goto LAB_00104a53;\nprocess_lto_object_00104d5b:\n                if ((ptrToPtr2[4] == (ulong *)0x10c2a8) || (ptrToPtr2[4] == (ulong *)0x10c3c0))\n                goto LAB_001049c3;\nLAB_00104cba:\n                charVar3 = (*(code *)ptrToPtr4[1][0x46])(ptrToPtr4,ptrToPtr2);\n                if (charVar3 != '\\0') {\n                  slim_lto_object_handler_00102c19();\n                  return;\n                }\nLAB_00104a7b:\n                if (ptrToPtr3 != objectParam) {\n                  if (ptrUnaffR14 == (ulong **)0x8) {\n                    *ptrToPtr3 = *objectParam;\n                    process_lto_object_001049c0();\n                    return;\n                  }\n                  for (; ptrUnaffR14 != (ulong **)0x0; ptrUnaffR14 = (ulong **)((long)ptrUnaffR14 + -1)) {\n                    *(undefined *)ptrToPtr3 = *(undefined *)objectParam;\n                    objectParam = (ulong **)((long)objectParam + (ulong)byteVar20 * -2 + 1);\n                    ptrToPtr3 = (ulong **)((long)ptrToPtr3 + (ulong)byteVar20 * -2 + 1);\n                  }\n                  process_lto_object_001049c0();\n                  return;\n                }\n                ptrToPtr3 = (ulong **)((long)ptrToPtr3 + (long)ptrUnaffR14);\n              }\n            }\n            else {\n              intVar4 = strcmp((char *)((long)ptrVar11 + (ulong)(*(char *)((long)ptrVar11 + 2) == '_')),\n                             \"__gnu_lto_slim\");\n              stackPtr = ptrToPtr2;\n              if (intVar4 == 0) {\n                if (DAT_0010b230 != '\\0') {\n                  stackPtr = (ulong **)*ptrToPtr4;\n                  DAT_0010b230 = '\\0';\n                  uintVar6 = dcgettext(0,\"%s: plugin needed to handle lto object\",5);\n                  print_error_message_00106400(uintVar6,stackPtr);\n                }\n                goto LAB_00104a03;\n              }\n              if (DAT_0010b7e8 != 0) goto LAB_00104ae2;\nLAB_00104a11:\n              if (DAT_0010b808 == 0) {\n                if (DAT_0010b7d8 != 0) {\n                  uintVar5 = (*(uint *)(ptrToPtr2 + 3) >> 7 ^ 1) & 1;\n                  goto LAB_00104af9;\n                }\n                goto LAB_00104a2d;\n              }\n              if ((((*(uint *)(ptrToPtr2 + 3) & 0x800082) != 0) || (ptrToPtr2[4] == (ulong *)0x10c2a8))\n                 || ((*(byte *)((long)ptrToPtr2[4] + 0x25) & 0x10) != 0)) goto LAB_00104a2d;\n            }\nLAB_001049c3:\n            objectParam = (ulong **)((long)objectParam + (long)ptrUnaffR14);\n            if (ptrToPtr1 <= objectParam) break;\n          } while( true );\n        }\n        ptrToPtr3 = (ulong **)((long)ptrToPtr3 - (long)ptrToPtr5);\n        if (ptrUnaffR14 == (ulong **)0x8) {\n          ptrVar11 = ptrToPtr4[1];\n          ptrToPtr5 = (ulong **)((long)ptrToPtr3 + 7);\n          if (-1 < (long)ptrToPtr3) {\n            ptrToPtr5 = ptrToPtr3;\n          }\n          param5 = (ulong **)(ulong)DAT_0010b800;\n          codePtr = (code *)ptrVar11[0x41];\n          ptrToPtr5 = (ulong **)((long)ptrToPtr5 >> 3);\n        }\n        else {\n          ptrToPtr5 = (ulong **)((long)ptrToPtr3 / (long)ptrUnaffR14);\n          ptrVar11 = ptrToPtr4[1];\n          codePtr = (code *)ptrVar11[0x41];\n        }\n        if (DAT_0010b800 != 0) goto LAB_00104be2;\n        DAT_0010b778 = DAT_0010b80c != 0;\n        DAT_0010b780 = ptrToPtr4;\n        DAT_0010b770 = (ulong **)(*codePtr)(ptrToPtr4);\n        DAT_0010b768 = (ulong **)(*(code *)ptrToPtr4[1][0x41])(ptrToPtr4);\n        ptrToPtr3 = localArray[0];\n        if ((DAT_0010b770 != (ulong **)0x0) && (DAT_0010b768 != (ulong **)0x0)) {\n          ptrToPtr1 = (ulong **)(ulong)localVar4c;\n          if (DAT_0010b7f8 != 0) {\n            boolVar19 = DAT_0010b80c != 0;\n            qsort(localArray[0],(size_t)ptrToPtr5,(size_t)ptrToPtr1,check_binary_compatibility_00102fd2);\n            ptrToPtr8 = (ulong **)xmalloc((long)ptrToPtr5 << 4);\n            ptrToPtr9 = DAT_0010b770;\n            objectParam = DAT_0010b768;\n            ptrUnaffR14 = (ulong **)((long)ptrToPtr5 * (long)ptrToPtr1 + (long)ptrToPtr3);\n            ptrToPtr2 = DAT_0010b770;\n            if (ptrUnaffR14 <= ptrToPtr3) goto LAB_00102ec2;\n            param6 = DAT_0010b768;\n            ptrToPtr5 = (ulong **)(*(code *)ptrToPtr4[1][0x4e])(ptrToPtr4,boolVar19,ptrToPtr3);\n            param5 = ptrToPtr1;\n            stackPtr = ptrToPtr8;\n            if (ptrToPtr5 == (ulong **)0x0) goto LAB_00102eb9;\n            goto LAB_00104e35;\n          }\n          qsort(localArray[0],(size_t)ptrToPtr5,(size_t)ptrToPtr1,\n                (__compar_fn_t)(&PTR_FUN_0010acc0)[(long)DAT_0010b7f4 + (long)DAT_0010b7fc * 2]);\n          ptrVar11 = ptrToPtr4[1];\nLAB_00104be2:\n          objectParam = ptrToPtr4;\n          ptrToPtr9 = (ulong **)0x0;\n          goto LAB_00104be5;\n        }\n        handle_error_00106530(*ptrToPtr4);\n        objectParam = ptrToPtr4;\n        ptrToPtr3 = ptrUnaffR15;\n        while( true ) {\n          ptrUnaffRBX = (ulong **)xmalloc();\n          ptrToPtr1 = (ulong **)(*(code *)objectParam[1][0x6b])(objectParam,ptrUnaffRBX);\n          ptrToPtr2 = ptrToPtr8;\n          if (-1 < (long)ptrToPtr1) break;\n          ptrToPtr4 = (ulong **)*objectParam;\n          ptrToPtr5 = (ulong **)handle_error_00106530(ptrToPtr4,ptrToPtr8);\nLAB_00102dbe:\n          ptrVar11 = ptrToPtr5[2];\n          ptrToPtr2 = (ulong **)0x0;\nLAB_00102dc4:\n          ptrVar11 = (ulong *)((long)ptrToPtr1[8] - (long)ptrVar11);\n          ptrToPtr9 = objectParam;\n          ptrToPtr6 = ptrToPtr3;\nLAB_00104ea7:\n          ptrToPtr5 = ptrToPtr2;\n          ptrToPtr3 = ptrUnaffRBX;\n          objectParam = param6;\n          if (ptrVar11 != (ulong *)0x0) {\n            *ptrToPtr8 = (ulong *)ptrToPtr6;\n            ptrToPtr8[1] = ptrVar11;\n            ptrToPtr8 = ptrToPtr8 + 2;\n          }\nLAB_00104e35:\n          param6 = ptrToPtr9;\n          if (ptrToPtr3 < ptrUnaffR14) goto code_r0x00104e3e;\n          ptrToPtr5 = (ulong **)((long)ptrToPtr8 - (long)stackPtr >> 4);\n          qsort(stackPtr,(size_t)ptrToPtr5,0x10,compare_and_call_00103533);\n          ptrVar11 = ptrToPtr4[1];\n          objectParam = ptrToPtr4;\n          ptrToPtr9 = stackPtr;\nLAB_00104be5:\n          ptrUnaffRBX = localArray[0];\n          ptrToPtr1 = (ulong **)(ulong)DAT_0010b7f8;\n          ptrUnaffR14 = (ulong **)(ulong)(DAT_0010b80c != 0);\n          if (DAT_0010b7f8 != 0) {\n            ptrToPtr8 = (ulong **)(*(code *)ptrVar11[0x41])(objectParam);\n            if (ptrToPtr8 == (ulong **)0x0) goto LAB_00102ed2;\n            ptrToPtr3 = ptrToPtr9 + (long)ptrToPtr5 * 2;\n            ptrToPtr5 = ptrToPtr9;\n            goto LAB_00104ee9;\n          }\n          ptrToPtr1 = (ulong **)(ulong)localVar4c;\n          ptrUnaffR15 = (ulong **)(*(code *)ptrVar11[0x41])(objectParam);\n          if (ptrUnaffR15 != (ulong **)0x0) {\n            ptrUnaffRBP = (ulong **)((long)ptrToPtr5 * (long)ptrToPtr1 + (long)ptrUnaffRBX);\n            if (ptrUnaffRBX < ptrUnaffRBP) goto LAB_00104c38;\n            goto LAB_00104c75;\n          }\n          handle_error_00106530(*objectParam);\n          ptrUnaffR15 = ptrToPtr9;\nLAB_00102d06:\n          ptrToPtr2 = ptrToPtr1;\n          if (DAT_0010b80c != 0) {\n            ptrUnaffRBX = localArray[0];\n            ptrToPtr5 = (ulong **)0x0;\n            ptrToPtr8 = (ulong **)0x0;\n            break;\n          }\n          longVar10 = (*(code *)objectParam[1][0x6a])(objectParam);\n          ptrToPtr5 = localArray[0];\n          ptrToPtr8 = ptrToPtr1;\n          ptrToPtr3 = ptrUnaffR15;\n          if (longVar10 < 1) {\n            ptrToPtr1 = (ulong **)0x0;\n            ptrUnaffRBX = (ulong **)0x0;\n            break;\n          }\n        }\n        param6 = &localVar48;\n        param5 = ptrUnaffRBX;\n        longVar10 = (*(code *)objectParam[1][0x6c])(objectParam,ptrToPtr8,ptrToPtr5,ptrToPtr1);\n        ptrToPtr1 = ptrToPtr2;\n        if (0 < longVar10) {\n          ptrToPtr1 = (ulong **)((long)ptrToPtr2 + longVar10);\n          localArray[0] = (ulong **)xrealloc(localArray[0]);\n          longVar7 = 0;\n          do {\n            localArray[0][(long)ptrToPtr2 + longVar7] = localVar48 + longVar7 * 6;\n            longVar7 = longVar7 + 1;\n          } while (longVar10 != longVar7);\n          localArray[0][(long)ptrToPtr2 + longVar10] = (ulong *)0x0;\n        }\n        if ((DAT_0010b80c == 0) && (ptrUnaffRBX != (ulong **)0x0)) {\n          free(ptrUnaffRBX);\n        }\nLAB_00102cc2:\n        byteVar1 = *(byte *)((long)objectParam + 0x4a);\n        ptrToPtr4 = objectParam;\n      } while( true );\n    }\n  }\n  if (_DAT_0010b810 == 0) {\n    ptrVar11 = *objectParam;\n    uintVar6 = dcgettext(0,\"%s: no symbols\",5);\n    print_error_message_00106400(uintVar6,ptrVar11);\n  }\n  return;\ncode_r0x00104b01:\n  objectParam = (ulong **)((long)objectParam + (long)ptrUnaffR14);\n  goto joined_r0x001049a4;\ncode_r0x00104e3e:\n  ptrUnaffRBX = (ulong **)((long)ptrToPtr3 + (long)param5);\n  if (ptrUnaffR14 <= ptrUnaffRBX) {\n    ptrToPtr1 = (ulong **)ptrToPtr5[4];\n    if ((*(uint *)(ptrToPtr5 + 3) & 0x200100) != 0) goto LAB_00102dbe;\n    ptrToPtr2 = (ulong **)0x0;\nLAB_00104e95:\n    ptrToPtr9 = objectParam;\n    ptrToPtr6 = ptrToPtr3;\n    if (*(int *)(ptrToPtr4[1] + 1) == 5) {\n      ptrVar11 = ptrToPtr5[7];\n      goto LAB_00104ea7;\n    }\n    ptrVar11 = ptrToPtr5[2];\n    if ((*(byte *)((long)ptrToPtr1 + 0x25) & 0x10) != 0) goto LAB_00104ea7;\n    if (ptrUnaffR14 <= ptrUnaffRBX) goto LAB_00102dc4;\n    goto LAB_00102ee7;\n  }\n  ptrToPtr1 = objectParam;\n  ptrToPtr6 = param5;\n  ptrToPtr7 = param6;\n  ptrToPtr2 = (ulong **)(*(code *)ptrToPtr4[1][0x4e])();\n  ptrToPtr9 = ptrToPtr3;\n  if (ptrToPtr2 == (ulong **)0x0) goto LAB_00102edb;\n  ptrToPtr1 = (ulong **)ptrToPtr5[4];\n  if ((*(uint *)(ptrToPtr5 + 3) & 0x200100) == 0) goto LAB_00104e95;\n  goto LAB_00102ee3;\nLAB_00104ee9:\n  if (ptrToPtr3 <= ptrToPtr5) {\nLAB_00104c75:\n    if (localVar48 == (ulong *)0x0) {\n      free(localArray[0]);\n      free(ptrToPtr9);\n      return;\n    }\n    free(localVar48);\n    free(localArray[0]);\n    free(ptrToPtr9);\n    return;\n  }\n  ptrToPtr1 = ptrToPtr8;\n  longVar10 = (*(code *)objectParam[1][0x4e])(objectParam,ptrUnaffR14,*ptrToPtr5);\n  if (longVar10 == 0) goto LAB_00102ec9;\n  ptrToPtr1 = ptrToPtr5 + 1;\n  ptrToPtr5 = ptrToPtr5 + 2;\n  print_params_and_update_table_00105110(objectParam,longVar10,*ptrToPtr1,param2);\n  goto LAB_00104ee9;\nLAB_00102ec9:\n  handle_error_00106530(*objectParam,0);\nLAB_00102ed2:\n  ptrToPtr4 = (ulong **)*objectParam;\n  handle_error_00106530();\n  ptrUnaffRBX = ptrToPtr3;\n  ptrToPtr6 = param5;\n  ptrToPtr7 = param6;\nLAB_00102edb:\n  param6 = ptrToPtr7;\n  param5 = ptrToPtr6;\n  ptrToPtr4 = (ulong **)*ptrToPtr4;\n  ptrToPtr2 = (ulong **)handle_error_00106530();\n  ptrToPtr3 = ptrToPtr9;\nLAB_00102ee3:\n  ptrVar11 = ptrToPtr5[2];\nLAB_00102ee7:\n  if (ptrToPtr1 != (ulong **)ptrToPtr2[4]) goto LAB_00102dc4;\n  ptrVar11 = (ulong *)((long)ptrToPtr2[2] - (long)ptrVar11);\n  ptrToPtr9 = objectParam;\n  ptrToPtr6 = ptrToPtr3;\n  goto LAB_00104ea7;\nLAB_00104c38:\n  while (ptrToPtr2 = ptrUnaffR15, longVar10 = (*(code *)objectParam[1][0x4e])(objectParam,ptrUnaffR14,ptrUnaffRBX),\n        longVar10 != 0) {\n    ptrUnaffRBX = (ulong **)((long)ptrUnaffRBX + (long)ptrToPtr1);\n    print_params_and_update_table_00105110(objectParam,longVar10,0,param2);\n    if (ptrUnaffRBP <= ptrUnaffRBX) goto LAB_00104c75;\n  }\nLAB_00102e9e:\n  handle_error_00106530(*objectParam);\n  ptrToPtr3 = ptrUnaffRBX;\nLAB_00102ea7:\n  ptrToPtr4 = ptrUnaffRBP;\n  handle_error_00106530(*objectParam);\n  ptrToPtr8 = ptrUnaffR15;\nLAB_00102eb0:\n  handle_error_00106530(*ptrToPtr4);\n  ptrToPtr4 = objectParam;\nLAB_00102eb9:\n  handle_error_00106530(*ptrToPtr4);\n  objectParam = param6;\nLAB_00102ec2:\n  ptrToPtr5 = (ulong **)0x0;\n  param5 = ptrToPtr1;\n  ptrToPtr9 = ptrToPtr2;\n  stackPtr = ptrToPtr8;\n  goto LAB_00104e35;\n}\n\n",
            "called": [
                "bfd_get_error",
                "dcgettext",
                "FUN_00106530",
                "FUN_00106400"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048e0",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "process_object_001048e0"
        },
        "fprintf": {
            "renaming": {},
            "code": "\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = fprintf(__stream,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102260",
            "calling": [
                "FUN_001063a0",
                "FUN_00103ca0",
                "FUN_00103b5d",
                "FUN_001055f0",
                "FUN_00106540",
                "FUN_00102450"
            ],
            "imported": false,
            "current_name": "fprintf"
        },
        "memcpy": {
            "renaming": {},
            "code": "\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memcpy(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102290",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "memcpy"
        },
        "FUN_00105530": {
            "renaming": {
                "FUN_00105530": "FUNC_00105530"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00105543) */\n/* WARNING: Removing unreachable block (ram,0x0010554f) */\n\nvoid FUNC_00105530(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_deregisterTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00105530",
            "calling": [
                "_FINI_0"
            ],
            "imported": false,
            "current_name": "FUNC_00105530"
        },
        "FUN_00102020": {
            "renaming": {
                "FUN_00102020": "run_function_at_address_00102020"
            },
            "code": "\nvoid run_function_at_address_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(undefined *)0x0)();\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102020",
            "calling": [],
            "imported": false,
            "current_name": "run_function_at_address_00102020"
        },
        "fflush": {
            "renaming": {},
            "code": "\n\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fflush(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022b0",
            "calling": [
                "FUN_001063a0",
                "FUN_00103b5d",
                "FUN_00106540"
            ],
            "imported": false,
            "current_name": "fflush"
        },
        "bfd_get_reloc_upper_bound": {
            "renaming": {},
            "code": "\nvoid bfd_get_reloc_upper_bound(void)\n\n{\n  bfd_get_reloc_upper_bound();\n  return;\n}\n\n",
            "called": [
                "bfd_get_reloc_upper_bound"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023f0",
            "calling": [
                "FUN_00103c00"
            ],
            "imported": false,
            "current_name": "bfd_get_reloc_upper_bound"
        },
        "FUN_001062d0": {
            "renaming": {
                "FUN_001062d0": "print_if_flag_set_001062d0",
                "param_1": "message"
            },
            "code": "\n\n\nvoid printIfFlagSet_001062d0(undefined8 message)\n\n{\n  if ((_DAT_0010b7c4 != 0) && (DAT_0010b818 == 0)) {\n    printf(\"\\n%s:\\n\",message);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001062d0",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "print_if_flag_set_001062d0"
        },
        "bfd_openr_next_archived_file": {
            "renaming": {},
            "code": "\nvoid bfd_openr_next_archived_file(void)\n\n{\n  bfd_openr_next_archived_file();\n  return;\n}\n\n",
            "called": [
                "bfd_openr_next_archived_file"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023e0",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "bfd_openr_next_archived_file"
        },
        "caseD_4a": {
            "renaming": {},
            "code": "\nvoid switchD_00104393::caseD_4a(undefined8 param_1,undefined8 param_2)\n\n{\n  initialize_data_00104397(param_1,param_2,3);\n  return;\n}\n\n",
            "called": [
                "FUN_00104397"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102475",
            "calling": [
                "FUN_00104370"
            ],
            "imported": false,
            "current_name": "caseD_4a"
        },
        "FUN_00103238": {
            "renaming": {
                "FUN_00103238": "reverse_and_print_matches_00103238",
                "__ptr": "pointer",
                "__s1": "string1",
                "plVar1": "pointerLong1",
                "lVar2": "long2",
                "cVar3": "char3",
                "iVar4": "int4",
                "unaff_RBX": "unaffRegBX",
                "pvVar5": "pointerVoid5",
                "uVar6": "uint6",
                "unaff_R13": "unaffRegR13",
                "lVar7": "long7",
                "param_10": "param10",
                "param_12": "param12"
            },
            "code": "\n\n\nvoid reverseAndPrintMatches_00103238(void)\n\n{\n  long *pointerLong1;\n  void *pointer;\n  char *string1;\n  long long2;\n  char char3;\n  int int4;\n  long unaffRegBX;\n  void *pointerVoid5;\n  uint uint6;\n  long unaffRegR13;\n  long long7;\n  ulong param10;\n  void *param12;\n  \n  pointerVoid5 = DAT_0010b750;\n  if (_DAT_0010b7b0 == unaffRegR13) {\n    if (DAT_0010b750 != (void *)0x0) goto LAB_00103296;\n  }\n  else {\n    uint6 = 0;\n    if (DAT_0010b750 != (void *)0x0) {\n      for (; uint6 < DAT_0010b748; uint6 = uint6 + 1) {\n        pointer = *(void **)((long)pointerVoid5 + (ulong)uint6 * 8);\n        if (pointer != (void *)0x0) {\n          free(pointer);\n        }\n      }\n      free(DAT_0010b740);\n      free(pointerVoid5);\n      free(DAT_0010b738);\n      DAT_0010b740 = (void *)0x0;\n      DAT_0010b750 = (void *)0x0;\n      DAT_0010b738 = (void *)0x0;\n    }\n  }\n  DAT_0010b748 = *(uint *)(unaffRegR13 + 0xa0);\n  DAT_0010b740 = (void *)xmalloc((ulong)DAT_0010b748 * 8);\n  DAT_0010b750 = (void *)xmalloc((ulong)DAT_0010b748 << 3);\n  DAT_0010b738 = (void *)xmalloc((ulong)DAT_0010b748 << 3);\n  param12 = DAT_0010b740;\n  bfd_map_over_sections();\n  _DAT_0010b7b0 = unaffRegR13;\nLAB_00103296:\n  string1 = *(char **)(unaffRegBX + 8);\n  uint6 = 0;\n  do {\n    if (DAT_0010b748 <= uint6) {\n      putc(10,_stdout);\n      return;\n    }\n    pointerVoid5 = DAT_0010b738;\n    for (long7 = 0; pointerLong1 = (long *)((long)pointerVoid5 + (ulong)uint6 * 8),\n        *pointerLong1 != long7 && long7 <= *pointerLong1; long7 = long7 + 1) {\n      pointerLong1 = **(long ***)(*(long *)((long)DAT_0010b750 + (ulong)uint6 * 8) + long7 * 8);\n      if ((((pointerLong1 != (long *)0x0) &&\n           (long2 = *pointerLong1, *(long *)(long2 + 0x20) == *(long *)(unaffRegBX + 0x20))) &&\n          (*(long *)(long2 + 0x10) == *(long *)(unaffRegBX + 0x10))) &&\n         (((int4 = strcmp(string1,*(char **)(long2 + 8)), int4 == 0 &&\n           (char3 = (**(code **)(*(long *)(unaffRegR13 + 8) + 0x240))(), pointerVoid5 = DAT_0010b738,\n           char3 != '\\0')) && (param12 != (void *)0x0)))) {\n        printf(\"\\t%s:%u\",param12,param10 >> 0x20);\n        uint6 = DAT_0010b748;\n        break;\n      }\n    }\n    uint6 = uint6 + 1;\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00103c00",
                "bfd_map_over_sections",
                "free",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103238",
            "calling": [
                "FUN_00105110"
            ],
            "imported": false,
            "current_name": "reverse_and_print_matches_00103238"
        },
        "FUN_001036e0": {
            "renaming": {
                "FUN_001036e0": "print_message_001036e0",
                "param_1": "msg",
                "param_2": "defaultMsg"
            },
            "code": "\nvoid printMessage_001036e0(undefined8 *msg,undefined8 *defaultMsg)\n\n{\n  if (msg != (undefined8 *)0x0) {\n    printf(\"%s[%s]: \",*msg);\n    return;\n  }\n  printf(\"%s: \",*defaultMsg);\n  return;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001036e0",
            "calling": [
                "FUN_001064a0"
            ],
            "imported": false,
            "current_name": "print_message_001036e0"
        },
        "FUN_001047d0": {
            "renaming": {
                "FUN_001047d0": "print_formatted_message_001047d0",
                "unaff_RBX": "resultBuffer",
                "unaff_R12": "ptrChar",
                "unaff_R13": "ptrResult",
                "unaff_R14": "formatString",
                "unaff_R15": "ptrData",
                "pcVar1": "returnValue"
            },
            "code": "\nvoid printFormattedMessage_001047d0(void)\n\n{\n  char *returnValue;\n  void *resultBuffer;\n  undefined *ptrChar;\n  void *ptrResult;\n  char *formatString;\n  long ptrData;\n  \n  if (((DAT_0010b234 != 0) &&\n      (returnValue = (char *)(**(code **)(*(long *)(ptrData + 8) + 0x220))(), returnValue != (char *)0x0))\n     && (*returnValue != '\\0')) {\n    resultBuffer = (void *)reconcat();\n    ptrResult = resultBuffer;\n  }\n  printf(formatString,ptrResult);\n  if (ptrChar != (undefined *)0x0) {\n    *ptrChar = 0x40;\n  }\n  free(resultBuffer);\n  return;\n}\n\n",
            "called": [
                "printf",
                "reconcat",
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047d0",
            "calling": [
                "FUN_0010268b",
                "FUN_00102739"
            ],
            "imported": false,
            "current_name": "print_formatted_message_001047d0"
        },
        "FUN_0010249f": {
            "renaming": {
                "FUN_0010249f": "print_warning_for_non_ordinary_file_0010249f",
                "uVar1": "warningMessage",
                "dcgettext": "getMessage",
                "print_error_message_00106400": "printErrorMessage"
            },
            "code": "\nundefined8 printWarningForNonOrdinaryFile_0010249f(void)\n\n{\n  undefined8 warningMessage;\n  \n  warningMessage = dcgettext(0,\"Warning: \\'%s\\' is not an ordinary file\",5);\n  printErrorMessage(warningMessage);\n  return 0;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00106400"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010249f",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "print_warning_for_non_ordinary_file_0010249f"
        },
        "FUN_001043d0": {
            "renaming": {
                "FUN_001043d0": "check_file_001043d0",
                "param_1": "filename",
                "cVar1": "check_result",
                "iVar2": "status",
                "uVar3": "result",
                "piVar4": "errno_ptr",
                "uVar5": "error_message",
                "puVar6": "bfd_handle",
                "puVar9": "archived_file",
                "puVar10": "previous_file",
                "local_c8": "file_info",
                "lVar7": "map_entry_index",
                "pcVar8": "error_string"
            },
            "code": "\n\n\nundefined4 check_file_001043d0(char *filename)\n\n{\n  char check_result;\n  int status;\n  undefined4 result;\n  int *errno_ptr;\n  undefined8 error_message;\n  undefined8 *bfd_handle;\n  long map_entry_index;\n  char *error_string;\n  undefined8 *archived_file;\n  undefined8 *previous_file;\n  stat file_info;\n  \n  if (filename != (char *)0x0) {\n    status = stat(filename,&file_info);\n    if (status < 0) {\nLAB_00102522:\n      errno_ptr = __errno_location();\n      if (*errno_ptr == 2) {\n        error_message = dcgettext(0,\"\\'%s\\': No such file\",5);\n        print_error_message_00106400(error_message,filename);\n      }\n      else {\n        error_string = strerror(*errno_ptr);\n        error_message = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n        print_error_message_00106400(error_message,filename,error_string);\n      }\n    }\n    else if ((file_info.st_mode & 0xf000) == 0x4000) {\n      error_message = dcgettext(0,\"Warning: \\'%s\\' is a directory\",5);\n      print_error_message_00106400(error_message,filename);\n    }\n    else if ((file_info.st_mode & 0xf000) == 0x8000) {\n      if (file_info.st_size < 0) {\n        error_message = dcgettext(0,\"Warning: \\'%s\\' has negative size, probably it is too large\",5);\n        print_error_message_00106400(error_message,filename);\n      }\n      else if (file_info.st_size != 0) {\n        if (DAT_0010b7d0 == 0) {\n          bfd_handle = (undefined8 *)bfd_openr(filename,\"plugin\");\n        }\n        else {\n          bfd_handle = (undefined8 *)bfd_openr(filename);\n        }\n        if (bfd_handle != (undefined8 *)0x0) {\n          if (DAT_0010b804 != 0) {\n            *(uint *)((long)bfd_handle + 0x44) = *(uint *)((long)bfd_handle + 0x44) | 0x8000;\n          }\n          check_result = bfd_check_format(bfd_handle,2);\n          if (check_result == '\\0') {\n            result = bfd_check_format_matches(bfd_handle,1,&file_info);\n            if ((char)result == '\\0') goto LAB_001025ac;\n            determine_architecture_00104670(bfd_handle);\n            (**(code **)PTR_PTR_FUN_0010b260)(filename);\n            process_object_001048e0(bfd_handle,0);\n          }\n          else {\n            (**(code **)(PTR_PTR_FUN_0010b260 + 8))(*bfd_handle);\n            if ((_DAT_0010b7f0 != 0) &&\n               (map_entry_index = bfd_get_next_mapent(bfd_handle,0xffffffffffffffff,&file_info), map_entry_index != -1)) {\n              error_string = (char *)dcgettext(0,\"\\nArchive index:\\n\",5);\n              printf(error_string);\n              do {\n                archived_file = (undefined8 *)(**(code **)(bfd_handle[1] + 0x1e0))(bfd_handle,map_entry_index);\n                if (archived_file == (undefined8 *)0x0) goto LAB_00102516;\n                if (*(long *)file_info.st_dev != 0) {\n                  print_formatted_message_00104740(&DAT_0010712d,0,*(long *)file_info.st_dev,bfd_handle);\n                  printf(\" in %s\\n\",*archived_file);\n                }\n                map_entry_index = bfd_get_next_mapent(bfd_handle,map_entry_index,&file_info);\n              } while (map_entry_index != -1);\n            }\n            archived_file = (undefined8 *)0x0;\n            do {\n              do {\n                previous_file = archived_file;\n                archived_file = (undefined8 *)bfd_openr_next_archived_file(bfd_handle,previous_file);\n                if (archived_file == (undefined8 *)0x0) {\n                  status = bfd_get_error();\n                  if (status != 9) {\n                    handle_error_00106530(*bfd_handle);\nLAB_00102516:\n                    handle_error_00106530(\"bfd_get_elt_at_index\");\n                    goto LAB_00102522;\n                  }\n                  if (previous_file != (undefined8 *)0x0) {\n                    bfd_close(previous_file);\n                    _DAT_0010b7b8 = 0;\n                    _DAT_0010b7b0 = 0;\n                  }\n                  goto LAB_001044b4;\n                }\n                check_result = bfd_check_format_matches(archived_file,1,&file_info);\n                if (check_result == '\\0') {\n                  print_error_message_00106540(*archived_file);\n                  status = bfd_get_error();\n                  if (status == 0xd) {\n                    print_matching_formats_00103b5d(file_info.st_dev);\n                  }\n                }\n                else {\n                  determine_architecture_00104670(archived_file);\n                  (**(code **)(PTR_PTR_FUN_0010b260 + 0x10))(*bfd_handle,*archived_file);\n                  process_object_001048e0(archived_file,bfd_handle);\n                }\n              } while (previous_file == (undefined8 *)0x0);\n              bfd_close(previous_file);\n              _DAT_0010b7b8 = 0;\n              _DAT_0010b7b0 = 0;\n            } while (previous_file != archived_file);\n          }\nLAB_001044b4:\n          result = 1;\n          while (check_result = bfd_close(bfd_handle), check_result == '\\0') {\n            handle_error_00106530(filename);\nLAB_001025ac:\n            print_error_message_00106540(filename);\n            status = bfd_get_error();\n            if (status == 0xd) {\n              print_matching_formats_00103b5d(file_info.st_dev);\n            }\n          }\n          _DAT_0010b7b0 = 0;\n          _DAT_0010b7b8 = 0;\n          return result;\n        }\n        print_error_message_00106540(filename);\n      }\n    }\n    else {\n      error_message = dcgettext(0,\"Warning: \\'%s\\' is not an ordinary file\",5);\n      print_error_message_00106400(error_message,filename);\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "bfd_openr",
                "bfd_check_format_matches",
                "bfd_get_next_mapent",
                "printf",
                "FUN_00102670",
                "FUN_00103b5d",
                "FUN_00106530",
                "FUN_00106540",
                "bfd_openr_next_archived_file",
                "bfd_check_format",
                "stat",
                "FUN_0010351b",
                "bfd_get_error",
                "strerror",
                "FUN_0010249f",
                "dcgettext",
                "FUN_001062d0",
                "FUN_001048e0",
                "__errno_location",
                "FUN_00106400",
                "FUN_00104740",
                "FUN_00104670",
                "bfd_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043d0",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "check_file_001043d0"
        },
        "isatty": {
            "renaming": {},
            "code": "\n\n\nint isatty(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = isatty(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "isatty"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020c0",
            "calling": [
                "FUN_0010268b"
            ],
            "imported": false,
            "current_name": "isatty"
        },
        "bfd_demangle": {
            "renaming": {},
            "code": "\nvoid bfd_demangle(void)\n\n{\n  bfd_demangle();\n  return;\n}\n\n",
            "called": [
                "bfd_demangle"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102320",
            "calling": [
                "FUN_00102739"
            ],
            "imported": false,
            "current_name": "bfd_demangle"
        },
        "sprintf": {
            "renaming": {},
            "code": "\n\n\nint sprintf(char *__s,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = sprintf(__s,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023b0",
            "calling": [
                "FUN_0010268b"
            ],
            "imported": false,
            "current_name": "sprintf"
        },
        "_INIT_0": {
            "renaming": {},
            "code": "\nvoid _INIT_0(void)\n\n{\n  FUNC_00105560();\n  return;\n}\n\n",
            "called": [
                "FUN_00105560"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001055e0",
            "calling": [],
            "imported": false,
            "current_name": "_INIT_0"
        },
        "strlen": {
            "renaming": {},
            "code": "\n\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(__s);\n  return sVar1;\n}\n\n",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102160",
            "calling": [
                "FUN_00103ca0",
                "FUN_00102fd2",
                "FUN_001055f0",
                "FUN_0010268b"
            ],
            "imported": false,
            "current_name": "strlen"
        },
        "bfd_map_over_sections": {
            "renaming": {},
            "code": "\nvoid bfd_map_over_sections(void)\n\n{\n  bfd_map_over_sections();\n  return;\n}\n\n",
            "called": [
                "bfd_map_over_sections"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102400",
            "calling": [
                "FUN_00103238"
            ],
            "imported": false,
            "current_name": "bfd_map_over_sections"
        },
        "FUN_001025f5": {
            "renaming": {
                "FUN_001025f5": "concatenate_strings_001025f5",
                "param_1": "inputString1",
                "param_2": "inputString2"
            },
            "code": "\nvoid concatenateStrings_001025f5(undefined8 inputString1,undefined8 inputString2)\n\n{\n  DAT_0010b7a0 = concat(&DAT_001071d7,inputString2,&DAT_001071ca,0);\n  return;\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001025f5",
            "calling": [
                "FUN_00104670"
            ],
            "imported": false,
            "current_name": "concatenate_strings_001025f5"
        },
        "FUN_00102670": {
            "renaming": {
                "FUN_00102670": "display_message_if_data_available_00102670",
                "param_1": "message"
            },
            "code": "\n\n\nvoid displayMessageIfDataAvailable_00102670(undefined8 message)\n\n{\n  if (_DAT_0010b7c4 != 0) {\n    printf(\"\\n%s:\\n\",message);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102670",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "display_message_if_data_available_00102670"
        },
        "bfd_plugin_set_plugin": {
            "renaming": {},
            "code": "\nvoid bfd_plugin_set_plugin(void)\n\n{\n  bfd_plugin_set_plugin();\n  return;\n}\n\n",
            "called": [
                "bfd_plugin_set_plugin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102090",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "bfd_plugin_set_plugin"
        },
        "__errno_location": {
            "renaming": {},
            "code": "\n\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = __errno_location();\n  return piVar1;\n}\n\n",
            "called": [
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102080",
            "calling": [
                "FUN_00103729",
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "__errno_location"
        },
        "xrealloc": {
            "renaming": {},
            "code": "\nvoid xrealloc(void)\n\n{\n  xrealloc();\n  return;\n}\n\n",
            "called": [
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021a0",
            "calling": [
                "FUN_001055f0",
                "FUN_00104d5b"
            ],
            "imported": false,
            "current_name": "xrealloc"
        },
        "xmalloc_set_program_name": {
            "renaming": {},
            "code": "\nvoid xmalloc_set_program_name(void)\n\n{\n  xmalloc_set_program_name();\n  return;\n}\n\n",
            "called": [
                "xmalloc_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021f0",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "xmalloc_set_program_name"
        },
        "strcmp": {
            "renaming": {},
            "code": "\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = strcmp(__s1,__s2);\n  return iVar1;\n}\n\n",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102240",
            "calling": [
                "FUN_001055f0",
                "FUN_00104d5b",
                "FUN_00104670",
                "FUN_00103463"
            ],
            "imported": false,
            "current_name": "strcmp"
        },
        "FUN_00103ab9": {
            "renaming": {
                "FUN_00103ab9": "FUNC_00103ab9"
            },
            "code": "\nvoid FUNC_00103ab9(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00103ab9",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_00103ab9"
        },
        "_DT_FINI": {
            "renaming": {},
            "code": "\nvoid _DT_FINI(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001065a0",
            "calling": [],
            "imported": false,
            "current_name": "_DT_FINI"
        },
        "FUN_00104fa0": {
            "renaming": {
                "FUN_00104fa0": "compare_strings_00104fa0",
                "param_1": "string1",
                "param_2": "string2",
                "__s1": "str1",
                "__s2": "str2",
                "uVar1": "result",
                "lVar2": "length_str1",
                "lVar3": "length_str2"
            },
            "code": "\nuint compare_strings_00104fa0(undefined8 string1,undefined8 string2)\n\n{\n  char *str2;\n  char *str1;\n  uint result;\n  long length_str1;\n  long length_str2;\n  \n  length_str1 = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,DAT_0010b778,string1,DAT_0010b770);\n  length_str2 = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,DAT_0010b778,string2,DAT_0010b768);\n  if ((length_str1 == 0) || (length_str2 == 0)) {\n    handle_error_00106530(*DAT_0010b780);\n  }\n  else {\n    str2 = *(char **)(length_str2 + 8);\n    str1 = *(char **)(length_str1 + 8);\n    if (str2 == (char *)0x0) {\n      return (uint)(str1 != (char *)0x0);\n    }\n    if (str1 != (char *)0x0) {\n      if (*str2 == '\\0') {\n        return (uint)(*str1 != '\\0');\n      }\n      if (*str1 == '\\0') {\n        return 0xffffffff;\n      }\n      result = strcoll(str1,str2);\n      return result;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "called": [
                "FUN_00102f9f",
                "strcoll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104fa0",
            "calling": [
                "FUN_00103bf6",
                "FUN_00105050",
                "FUN_00102fd2"
            ],
            "imported": false,
            "current_name": "compare_strings_00104fa0"
        },
        "bfd_is_undefined_symclass": {
            "renaming": {},
            "code": "\nvoid bfd_is_undefined_symclass(void)\n\n{\n  bfd_is_undefined_symclass();\n  return;\n}\n\n",
            "called": [
                "bfd_is_undefined_symclass"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020f0",
            "calling": [
                "FUN_001053c0",
                "FUN_001064b0",
                "FUN_00103729"
            ],
            "imported": false,
            "current_name": "bfd_is_undefined_symclass"
        },
        "FUN_001064a0": {
            "renaming": {
                "FUN_001064a0": "print_log_message_001064a0",
                "param_1": "logger_name",
                "param_2": "default_logger_name"
            },
            "code": "\nvoid print_log_message_001064a0(undefined8 *logger_name,undefined8 *default_logger_name)\n\n{\n  if (DAT_0010b818 == 0) {\n    return;\n  }\n  if (logger_name != (undefined8 *)0x0) {\n    printf(\"%s[%s]: \",*logger_name);\n    return;\n  }\n  printf(\"%s: \",*default_logger_name);\n  return;\n}\n\n",
            "called": [
                "FUN_001036e0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001064a0",
            "calling": [],
            "imported": false,
            "current_name": "print_log_message_001064a0"
        },
        "FUN_001054d0": {
            "renaming": {
                "FUN_001054d0": "print_symmetry_001054d0",
                "param_1": "input",
                "cVar1": "symClass",
                "uVar2": "classBits",
                "iVar3": "formatStatus",
                "plVar4": "printWidth",
                "piVar5": "errorStatus",
                "uVar6": "errorMsg",
                "lVar7": "typeBits",
                "uVar8": "symCount",
                "bVar9": "typeCode",
                "uVar10": "symClass",
                "pcVar11": "symType",
                "in_R8": "parameter_1",
                "in_R9": "parameter_2"
            },
            "code": "\nvoid printSymmetry_001054d0(undefined8 input)\n\n{\n  char symClass;\n  ushort classBits;\n  int formatStatus;\n  long *printWidth;\n  int *errorStatus;\n  undefined8 errorMsg;\n  long typeBits;\n  ulong symCount;\n  byte typeCode;\n  ulong symClass;\n  char *symType;\n  undefined8 parameter_1;\n  undefined8 parameter_2;\n  \n  symCount = (ulong)DAT_0010b7a8;\n  if ((DAT_0010b7a8 - 0x20 & 0xffffffdf) == 0) {\n    printf(DAT_0010b7a0,input);\n    return;\n  }\n  printWidth = (long *)dcgettext(0,\"Print width has not been initialized (%d)\",5);\n  symClass = symCount;\n  print_error_and_exit_00106300(printWidth,symCount);\n  print_formatted_message_00104740(\"%-20s|\",printWidth,0,symClass,parameter_1,parameter_2,symCount);\n  symClass = bfd_is_undefined_symclass((int)*(char *)(*printWidth + 8));\n  if (symClass == '\\0') {\n    printSymmetry_001054d0(*(undefined8 *)*printWidth);\n  }\n  else if (DAT_0010b7a8 == 0x20) {\n    printf(\"        \");\n  }\n  else {\n    printf(\"                \");\n  }\n  printf(\"|   %c  |\",(ulong)(uint)(int)*(char *)(*printWidth + 8));\n  if (*(char *)(*printWidth + 8) == '-') {\n    printf(\"%18s|  \",*(undefined8 *)(*printWidth + 0x20));\n    printf(&DAT_0010b23d,(ulong)(uint)(int)*(short *)(*printWidth + 0x1a));\n    goto LAB_00103a54;\n  }\n  if (printWidth[2] == 0) {\n    if (printWidth[3] != 0) {\n      typeBits = *(long *)(printWidth[3] + 0x30);\n      symClass = *(char *)(typeBits + 0x28);\n      if (symClass == 'g') goto LAB_00103983;\n      if (symClass == 'h') {\n        symType = \"Line\";\n      }\n      else if (symClass == 'd') {\n        symType = \"Block\";\n      }\n      else if (*(ushort *)(typeBits + 0x26) == 0) {\n        symType = \"None\";\n      }\n      else {\n        classBits = *(ushort *)(typeBits + 0x26) >> 4 & 3;\n        if (classBits == 2) {\n          symType = \"Function\";\n        }\n        else if (classBits == 3) {\n          symType = \"Array\";\n        }\n        else {\n          if (classBits != 1) {\n            free(DAT_0010b730);\n            classBits = *(ushort *)(typeBits + 0x26);\n            typeCode = *(byte *)(typeBits + 0x28);\n            symType = (char *)dcgettext(0,\"<unknown>: %d/%d\",5);\n            formatStatus = asprintf(&DAT_0010b730,symType,(ulong)typeCode,(ulong)classBits);\n            symType = DAT_0010b730;\n            goto joined_r0x00103964;\n          }\n          symType = \"Pointer\";\n        }\n      }\n      goto LAB_001039c0;\n    }\n    printf(\"                  |\");\n  }\n  else {\n    typeCode = *(byte *)(printWidth[2] + 0x48) & 0xf;\n    switch(typeCode) {\n    case 0:\n      symType = \"NOTYPE\";\n      break;\n    case 1:\n      symType = \"OBJECT\";\n      break;\n    case 2:\n      symType = \"FUNC\";\n      break;\n    case 3:\n      symType = \"SECTION\";\n      break;\n    case 4:\n      symType = \"FILE\";\n      break;\n    case 5:\n      symType = \"COMMON\";\n      break;\n    case 6:\n      symType = \"TLS\";\n      break;\n    default:\n      free(DAT_0010b728);\n      symType = \"<processor specific>: %d\";\n      if ((2 < typeCode - 0xd) && (symType = \"<OS specific>: %d\", 2 < typeCode - 10)) {\n        symType = \"<unknown>: %d\";\n      }\n      symType = (char *)dcgettext(0,symType,5);\n      formatStatus = asprintf(&DAT_0010b728,symType,(ulong)typeCode);\n      symType = DAT_0010b728;\njoined_r0x00103964:\n      if (formatStatus < 0) {\n        errorStatus = __errno_location();\n        errorMsg = xstrerror(*errorStatus);\n        print_error_and_exit_00106300(&DAT_0010712d,errorMsg);\nLAB_00103983:\n        symType = \"File\";\n      }\n    }\nLAB_001039c0:\n    printf(\"%18s|\",symType);\n  }\n  if (printWidth[2] == 0) {\n    if (printWidth[1] != 0) goto LAB_001039fb;\nLAB_00103a02:\n    if (DAT_0010b7a8 == 0x20) {\n      printf(\"        \");\n    }\n    else {\n      printf(\"                \");\n    }\n  }\n  else {\n    if (*(long *)(printWidth[2] + 0x38) == 0) goto LAB_00103a02;\nLAB_001039fb:\n    printSymmetry_001054d0();\n  }\n  typeBits = printWidth[2];\n  if ((typeBits != 0) || (typeBits = printWidth[3], typeBits != 0)) {\n    printf(\"|     |%s\",**(undefined8 **)(typeBits + 0x20));\n    return;\n  }\nLAB_00103a54:\n  printf(\"|     |\");\n  return;\n}\n\n",
            "called": [
                "printf",
                "FUN_0010370a"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001054d0",
            "calling": [
                "FUN_001053c0",
                "FUN_001064b0",
                "FUN_00103729",
                "FUN_001035a2",
                "FUN_0010651a"
            ],
            "imported": false,
            "current_name": "print_symmetry_001054d0"
        },
        "cplus_demangle_name_to_style": {
            "renaming": {},
            "code": "\nvoid cplus_demangle_name_to_style(void)\n\n{\n  cplus_demangle_name_to_style();\n  return;\n}\n\n",
            "called": [
                "cplus_demangle_name_to_style"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102030",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "cplus_demangle_name_to_style"
        },
        "FUN_001053b0": {
            "renaming": {
                "FUN_001053b0": "print_params_001053b0",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4"
            },
            "code": "\nvoid printParams_001053b0(undefined8 *param1,undefined8 *param2,undefined8 param3,undefined8 param4)\n\n{\n  if (DAT_0010b818 == 0) {\n    return;\n  }\n  if (param1 != (undefined8 *)0x0) {\n    printf(\"%s:\",*param1);\n  }\n  printf(\"%s:\",*param2,param4);\n  return;\n}\n\n",
            "called": [
                "FUN_00103573"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001053b0",
            "calling": [
                "FUN_00105110"
            ],
            "imported": false,
            "current_name": "print_params_001053b0"
        },
        "FUN_001055f0": {
            "renaming": {
                "FUN_001055f0": "FUNC_001055f0"
            },
            "code": "\n\n\nundefined ** FUNC_001055f0(int param_1,long *param_2)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  bool bVar3;\n  bool bVar4;\n  bool bVar5;\n  char cVar6;\n  byte bVar7;\n  char cVar8;\n  char cVar9;\n  int iVar10;\n  uint uVar11;\n  int iVar12;\n  undefined4 uVar13;\n  undefined4 uVar14;\n  FILE *__stream;\n  byte *__s;\n  int *piVar15;\n  size_t sVar16;\n  byte *__ptr;\n  long *__src;\n  long lVar17;\n  long *plVar18;\n  long *plVar19;\n  undefined8 uVar20;\n  undefined8 uVar21;\n  char *pcVar22;\n  byte *pbVar23;\n  undefined **unaff_RBP;\n  long lVar24;\n  byte *pbVar25;\n  char *pcVar26;\n  int *unaff_R12;\n  int *piVar27;\n  int local_110;\n  int local_10c;\n  size_t local_108;\n  stat local_c8;\n  \n  setlocale(5,\"\");\n  setlocale(0,\"\");\n  pcVar22 = \"binutils\";\n  setlocale(3,\"\");\n  bindtextdomain(\"binutils\",\"/usr/share/locale\");\n  textdomain(\"binutils\");\n  DAT_0010b820 = *param_2;\n  xmalloc_set_program_name();\n  bfd_set_error_program_name(DAT_0010b820);\n  bfd_plugin_set_program_name(DAT_0010b820);\n  plVar18 = param_2;\n  if (1 < param_1) {\n    local_10c = 2000;\n    unaff_R12 = (int *)0x1;\n    local_110 = 0;\n    do {\n      iVar12 = (int)unaff_R12;\n      unaff_RBP = (undefined **)(long)iVar12;\n      piVar27 = (int *)((long)unaff_RBP * 8);\n      if (*(char *)plVar18[(long)unaff_RBP] != '@') goto LAB_00105a70;\n      local_10c = local_10c + -1;\n      if (local_10c == 0) {\n        lVar24 = *plVar18;\n        pcVar26 = \"%s: error: too many @-files encountered\\n\";\n        goto LAB_00105f1d;\n      }\n      pcVar22 = (char *)plVar18[(long)unaff_RBP] + 1;\n      iVar10 = stat(pcVar22,&local_c8);\n      if (iVar10 < 0) {\nLAB_00105a70:\n        if (param_1 <= iVar12 + 1) break;\nLAB_00105a7a:\n        uVar11 = iVar12 + 1;\n        local_110 = iVar12;\n      }\n      else {\n        if ((local_c8.st_mode & 0xf000) == 0x4000) goto LAB_00105f13;\n        __stream = fopen(pcVar22,\"r\");\n        if (__stream == (FILE *)0x0) goto LAB_00105a70;\n        iVar10 = fseek(__stream,0,2);\n        if (((iVar10 == -1) ||\n            (pcVar22 = (char *)ftell(__stream), (int *)pcVar22 == (int *)0xffffffffffffffff)) ||\n           (iVar10 = fseek(__stream,0,0), iVar10 == -1)) {\nLAB_00105ad0:\n          fclose(__stream);\n          if (iVar12 + 1 < param_1) goto LAB_00105a7a;\n          break;\n        }\n        __s = (byte *)xmalloc((char *)((long)pcVar22 + 1));\n        piVar15 = (int *)fread(__s,1,(size_t)pcVar22,__stream);\n        if (((int *)pcVar22 != piVar15) && (iVar10 = ferror(__stream), iVar10 != 0)) {\n          free(__s);\n          goto LAB_00105ad0;\n        }\n        __s[(long)piVar15] = 0;\n        bVar7 = *__s;\n        pbVar23 = __s;\n        if (bVar7 != 0) {\nLAB_001057d0:\n          if (((&_sch_istable)[(ulong)bVar7 * 2] & 0x40) != 0) goto LAB_001057c0;\n          sVar16 = strlen((char *)__s);\n          __ptr = (byte *)xmalloc(sVar16 + 1);\n          iVar10 = 0;\n          bVar5 = false;\n          bVar3 = false;\n          lVar24 = 0;\n          __src = (long *)0x0;\n          bVar4 = false;\n          pbVar23 = __s;\n          do {\n            while (((&_sch_istable)[(ulong)*pbVar23 * 2] & 0x40) != 0) {\n              pbVar23 = pbVar23 + 1;\n            }\n            if ((iVar10 == 0) || (plVar19 = __src + lVar24, iVar10 + -1 <= (int)lVar24)) {\n              if (__src == (long *)0x0) {\n                iVar10 = 8;\n                __src = (long *)xmalloc(0x40);\n                plVar19 = __src + lVar24;\n                *plVar19 = 0;\n              }\n              else {\n                iVar10 = iVar10 * 2;\n                __src = (long *)xrealloc(__src,(long)iVar10 << 3);\n                plVar19 = __src + lVar24;\n                *plVar19 = 0;\n              }\n            }\n            bVar7 = *pbVar23;\n            pbVar25 = __ptr;\n            while (bVar7 != 0) {\n              while( true ) {\n                if ((((&_sch_istable)[(ulong)bVar7 * 2] & 0x40) != 0) &&\n                   (!(bool)(bVar5 | bVar4 | bVar3))) {\n                  bVar4 = false;\n                  bVar5 = false;\n                  bVar3 = false;\n                  goto LAB_001058e0;\n                }\n                if (!bVar4) break;\n                pbVar23 = pbVar23 + 1;\n                *pbVar25 = bVar7;\n                pbVar25 = pbVar25 + 1;\n                bVar4 = false;\n                bVar7 = *pbVar23;\n                if (bVar7 == 0) goto LAB_001058e0;\n              }\n              if (bVar7 == 0x5c) {\n                bVar4 = true;\n              }\n              else if (bVar3) {\n                if (bVar7 == 0x27) {\n                  bVar3 = false;\n                }\n                else {\nLAB_00105a55:\n                  *pbVar25 = bVar7;\n                  pbVar25 = pbVar25 + 1;\n                }\n              }\n              else if (bVar5) {\n                if (bVar7 != 0x22) goto LAB_00105a55;\n                bVar5 = false;\n              }\n              else if (bVar7 == 0x27) {\n                bVar3 = true;\n              }\n              else {\n                if (bVar7 != 0x22) goto LAB_00105a55;\n                bVar5 = true;\n              }\n              pbVar1 = pbVar23 + 1;\n              pbVar23 = pbVar23 + 1;\n              bVar7 = *pbVar1;\n            }\nLAB_001058e0:\n            *pbVar25 = 0;\n            lVar17 = xstrdup(__ptr);\n            *plVar19 = lVar17;\n            __src[lVar24 + 1] = 0;\n            bVar7 = *pbVar23;\n            bVar2 = (&_sch_istable)[(ulong)bVar7 * 2];\n            while ((bVar2 & 0x40) != 0) {\n              bVar7 = pbVar23[1];\n              pbVar23 = pbVar23 + 1;\n              bVar2 = (&_sch_istable)[(ulong)bVar7 * 2];\n            }\n            lVar24 = lVar24 + 1;\n          } while (bVar7 != 0);\n          free(__ptr);\n          plVar19 = plVar18;\n          if (param_2 == plVar18) goto LAB_00105c79;\n          goto LAB_0010597d;\n        }\nLAB_00105c5c:\n        __src = (long *)xmalloc(8);\n        *__src = 0;\n        if (param_2 == plVar18) {\nLAB_00105c79:\n          if (*plVar18 == 0) {\n            iVar10 = 0;\n          }\n          else {\n            lVar24 = 1;\n            do {\n              iVar10 = (int)lVar24;\n              plVar19 = plVar18 + lVar24;\n              lVar24 = lVar24 + 1;\n            } while (*plVar19 != 0);\n          }\n          lVar17 = 0;\n          plVar19 = (long *)xmalloc((long)(iVar10 + 1) << 3);\n          lVar24 = *plVar18;\n          while (lVar24 != 0) {\n            uVar20 = xstrdup();\n            *(undefined8 *)((long)plVar19 + lVar17) = uVar20;\n            lVar17 = lVar17 + 8;\n            lVar24 = *(long *)((long)plVar18 + lVar17);\n          }\n          *(undefined8 *)((long)plVar19 + lVar17) = 0;\nLAB_0010597d:\n          plVar18 = plVar19;\n          if (*__src == 0) goto LAB_00105d50;\n          pcVar22 = (char *)0x0;\n          do {\n            pcVar22 = (char *)((long)pcVar22 + 1);\n          } while (__src[(long)pcVar22] != 0);\n          local_108 = (long)pcVar22 * 8;\n        }\n        else {\nLAB_00105d50:\n          pcVar22 = (char *)0x0;\n          local_108 = 0;\n        }\n        free((void *)plVar18[(long)unaff_RBP]);\n        plVar18 = (long *)xrealloc(plVar18,(long)((long)pcVar22 + (long)param_1 + 1) * 8);\n        iVar10 = param_1 + -1 + (int)pcVar22;\n        memmove(plVar18 + (long)(undefined **)((long)unaff_RBP + (long)pcVar22),\n                plVar18 + 1 + (long)unaff_RBP,(long)(param_1 - iVar12) << 3);\n        memcpy(plVar18 + (long)unaff_RBP,__src,local_108);\n        free(__src);\n        free(__s);\n        fclose(__stream);\n        uVar11 = local_110 + 1;\n        unaff_RBP = (undefined **)((long)unaff_RBP + (long)pcVar22);\n        unaff_R12 = piVar27;\n        param_1 = iVar10;\n        if (iVar10 <= (int)uVar11) break;\n      }\n      unaff_R12 = (int *)(ulong)uVar11;\n    } while( true );\n  }\n  iVar12 = bfd_init();\n  pcVar26 = \"fatal error: libbfd ABI mismatch\";\n  if (iVar12 != 0x118) goto LAB_00106085;\n  unaff_RBP = &PTR_s_debug_syms_0010b280;\n  cVar8 = bfd_set_default_target(\"x86_64-pc-linux-gnu\",\"fatal error: libbfd ABI mismatch\",5);\n  pcVar22 = \"aABCDef:gHhjJlnopPrSst:uU:vVvWX:\";\n  unaff_R12 = (int *)\"x86_64-pc-linux-gnu\";\n  cVar9 = DAT_0010b23b;\n  cVar6 = DAT_0010b240;\n  uVar14 = DAT_0010b244;\n  if (cVar8 != '\\0') {\nswitchD_00105c5a_caseD_0:\n    DAT_0010b244 = uVar14;\n    DAT_0010b240 = cVar6;\n    DAT_0010b23b = cVar9;\n    uVar13 = getopt_long(param_1,plVar18,pcVar22);\n    piVar27 = _optarg;\n    piVar15 = (int *)pcVar22;\n    cVar9 = DAT_0010b23b;\n    cVar6 = DAT_0010b240;\n    uVar14 = DAT_0010b244;\n    switch(uVar13) {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n    case 6:\n    case 7:\n    case 8:\n    case 9:\n    case 10:\n    case 0xb:\n    case 0xc:\n    case 0xd:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x27:\n    case 0x28:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3d:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x45:\n    case 0x46:\n    case 0x47:\n    case 0x49:\n    case 0x4a:\n    case 0x4b:\n    case 0x4c:\n    case 0x4d:\n    case 0x4e:\n    case 0x4f:\n    case 0x51:\n    case 0x52:\n    case 0x54:\n    case 0x59:\n    case 0x5a:\n    case 0x5b:\n    case 0x5c:\n    case 0x5d:\n    case 0x5e:\n    case 0x5f:\n    case 0x60:\n    case 0x62:\n    case 99:\n    case 100:\n    case 0x69:\n    case 0x6b:\n    case 0x6d:\n    case 0x71:\n    case 0x77:\n    case 0x78:\n    case 0x79:\n    case 0x7a:\n    case 0x7b:\n    case 0x7c:\n    case 0x7d:\n    case 0x7e:\n    case 0x7f:\n    case 0x80:\n    case 0x81:\n    case 0x82:\n    case 0x83:\n    case 0x84:\n    case 0x85:\n    case 0x86:\n    case 0x87:\n    case 0x88:\n    case 0x89:\n    case 0x8a:\n    case 0x8b:\n    case 0x8c:\n    case 0x8d:\n    case 0x8e:\n    case 0x8f:\n    case 0x90:\n    case 0x91:\n    case 0x92:\n    case 0x93:\n    case 0x94:\n    case 0x95:\n    case 0x96:\n    case 0x97:\n    case 0x98:\n    case 0x99:\n    case 0x9a:\n    case 0x9b:\n    case 0x9c:\n    case 0x9d:\n    case 0x9e:\n    case 0x9f:\n    case 0xa0:\n    case 0xa1:\n    case 0xa2:\n    case 0xa3:\n    case 0xa4:\n    case 0xa5:\n    case 0xa6:\n    case 0xa7:\n    case 0xa8:\n    case 0xa9:\n    case 0xaa:\n    case 0xab:\n    case 0xac:\n    case 0xad:\n    case 0xae:\n    case 0xaf:\n    case 0xb0:\n    case 0xb1:\n    case 0xb2:\n    case 0xb3:\n    case 0xb4:\n    case 0xb5:\n    case 0xb6:\n    case 0xb7:\n    case 0xb8:\n    case 0xb9:\n    case 0xba:\n    case 0xbb:\n    case 0xbc:\n    case 0xbd:\n    case 0xbe:\n    case 0xbf:\n    case 0xc0:\n    case 0xc1:\n    case 0xc2:\n    case 0xc3:\n    case 0xc4:\n    case 0xc5:\n    case 0xc6:\n    case 199:\n      print_symbol_info_00103ca0(_stderr,1);\n      piVar27 = unaff_R12;\nLAB_001061d5:\n      iVar12 = strcmp((char *)piVar27,\"l\");\n      if (iVar12 == 0) goto LAB_001061a3;\n      iVar12 = strcmp((char *)piVar27,\"escape\");\n      unaff_R12 = piVar27;\n      if ((iVar12 == 0) || (iVar12 = strcmp((char *)piVar27,\"e\"), iVar12 == 0)) {\n        DAT_0010b7e0 = 2;\n        cVar9 = DAT_0010b23b;\n        cVar6 = DAT_0010b240;\n        uVar14 = DAT_0010b244;\n        goto switchD_00105c5a_caseD_0;\n      }\n      iVar12 = strcmp((char *)piVar27,\"invalid\");\n      if ((iVar12 == 0) || (iVar12 = strcmp((char *)piVar27,\"i\"), iVar12 == 0)) {\n        DAT_0010b7e0 = 5;\n        cVar9 = DAT_0010b23b;\n        cVar6 = DAT_0010b240;\n        uVar14 = DAT_0010b244;\n        goto switchD_00105c5a_caseD_0;\n      }\n      iVar12 = strcmp((char *)piVar27,\"hex\");\n      if ((iVar12 == 0) || (iVar12 = strcmp((char *)piVar27,\"x\"), iVar12 == 0)) {\n        DAT_0010b7e0 = 3;\n        cVar9 = DAT_0010b23b;\n        cVar6 = DAT_0010b240;\n        uVar14 = DAT_0010b244;\n        goto switchD_00105c5a_caseD_0;\n      }\n      iVar12 = strcmp((char *)piVar27,\"highlight\");\n      if ((iVar12 == 0) || (iVar12 = strcmp((char *)piVar27,\"h\"), iVar12 == 0)) {\n        DAT_0010b7e0 = 4;\n        cVar9 = DAT_0010b23b;\n        cVar6 = DAT_0010b240;\n        uVar14 = DAT_0010b244;\n        goto switchD_00105c5a_caseD_0;\n      }\n      pcVar26 = \"invalid argument to -U/--unicode: %s\";\n      break;\n    case 0x41:\n    case 0x6f:\n      DAT_0010b818 = 1;\n      goto switchD_00105c5a_caseD_0;\n    case 0x42:\n      initialize_output_format_00104370(&DAT_00107033);\n      cVar9 = DAT_0010b23b;\n      cVar6 = DAT_0010b240;\n      uVar14 = DAT_0010b244;\n      goto switchD_00105c5a_caseD_0;\n    case 0x43:\n      goto switchD_00105c5a_caseD_43;\n    case 0x44:\n      DAT_0010b80c = 1;\n      goto switchD_00105c5a_caseD_0;\n    case 0x48:\n    case 0x68:\n      print_symbol_info_00103ca0(_stdout,0);\nswitchD_00105c5a_caseD_43:\n      unaff_R12 = (int *)&optarg;\n      DAT_0010b814 = 1;\n      cVar9 = DAT_0010b23b;\n      cVar6 = DAT_0010b240;\n      uVar14 = DAT_0010b244;\n      if (_optarg != (int *)0x0) {\n        iVar12 = cplus_demangle_name_to_style();\n        piVar15 = _optarg;\n        if (iVar12 == 0) {\n          uVar20 = dcgettext(0,\"unknown demangling style `%s\\'\",5);\n          print_error_and_exit_00106300(uVar20,piVar15);\nswitchD_00105c5a_caseD_cc:\n          DAT_0010b248 = DAT_0010b248 | 0x40000;\n          pcVar22 = (char *)piVar15;\n          cVar9 = DAT_0010b23b;\n          cVar6 = DAT_0010b240;\n          uVar14 = DAT_0010b244;\n        }\n        else {\n          cplus_demangle_set_style();\n          cVar9 = DAT_0010b23b;\n          cVar6 = DAT_0010b240;\n          uVar14 = DAT_0010b244;\n        }\n      }\n      goto switchD_00105c5a_caseD_0;\n    case 0x50:\n      initialize_output_format_00104370(\"posix\");\n      cVar9 = DAT_0010b23b;\n      cVar6 = DAT_0010b240;\n      uVar14 = DAT_0010b244;\n      goto switchD_00105c5a_caseD_0;\n    case 0x53:\n      DAT_0010b7ec = 1;\n      goto switchD_00105c5a_caseD_0;\n    case 0x55:\n      DAT_0010b7e4 = 1;\n      DAT_0010b7e8 = 0;\n      goto switchD_00105c5a_caseD_0;\n    case 0x56:\n      goto switchD_00105c5a_caseD_56;\n    case 0x57:\n      DAT_0010b7d8 = 1;\n      goto switchD_00105c5a_caseD_0;\n    case 0x58:\n      iVar12 = strcmp((char *)_optarg,\"32_64\");\n      cVar9 = DAT_0010b23b;\n      cVar6 = DAT_0010b240;\n      uVar14 = DAT_0010b244;\n      if (iVar12 != 0) {\n        pcVar26 = \"Only -X 32_64 is supported\";\nLAB_00106085:\n        uVar20 = dcgettext(0,pcVar26,5);\n        print_error_and_exit_00106300(uVar20);\nswitchD_00105c5a_caseD_56:\n        DAT_0010b7dc = 1;\n        cVar9 = DAT_0010b23b;\n        cVar6 = DAT_0010b240;\n        uVar14 = DAT_0010b244;\n      }\n      goto switchD_00105c5a_caseD_0;\n    case 0x61:\n      DAT_0010b81c = 1;\n      goto switchD_00105c5a_caseD_0;\n    case 0x66:\n      initialize_output_format_00104370(_optarg);\n      cVar9 = DAT_0010b23b;\n      cVar6 = DAT_0010b240;\n      uVar14 = DAT_0010b244;\n      goto switchD_00105c5a_caseD_0;\n    case 0x67:\n      DAT_0010b808 = 1;\n      goto switchD_00105c5a_caseD_0;\n    case 0x6a:\n      initialize_output_format_00104370(\"just-symbols\");\n      cVar9 = DAT_0010b23b;\n      cVar6 = DAT_0010b240;\n      uVar14 = DAT_0010b244;\n      goto switchD_00105c5a_caseD_0;\n    case 0x6c:\n      DAT_0010b804 = 1;\n      goto switchD_00105c5a_caseD_0;\n    case 0x6e:\n    case 0x76:\n      DAT_0010b7fc = 1;\n      DAT_0010b800 = 0;\n      DAT_0010b7f8 = 0;\n      goto switchD_00105c5a_caseD_0;\n    case 0x70:\n      DAT_0010b800 = 1;\n      DAT_0010b7fc = 0;\n      DAT_0010b7f8 = 0;\n      goto switchD_00105c5a_caseD_0;\n    case 0x72:\n      DAT_0010b7f4 = 1;\n      goto switchD_00105c5a_caseD_0;\n    case 0x73:\n      _DAT_0010b7f0 = 1;\n      goto switchD_00105c5a_caseD_0;\n    case 0x74:\n      cVar9 = *(char *)_optarg;\n      unaff_R12 = piVar27;\n      cVar6 = cVar9;\n      uVar14 = 10;\n      if (cVar9 == 'd') goto switchD_00105c5a_caseD_0;\n      if ('c' < cVar9) {\n        if (cVar9 == 'o') {\n          uVar14 = 8;\n          goto switchD_00105c5a_caseD_0;\n        }\n        if (cVar9 == 'x') {\n          uVar14 = 0x10;\n          goto switchD_00105c5a_caseD_0;\n        }\n      }\n      pcVar26 = \"%s: invalid radix\";\n      break;\n    case 0x75:\n      DAT_0010b7e8 = 1;\n      DAT_0010b7e4 = 0;\n      goto switchD_00105c5a_caseD_0;\n    case 200:\n      DAT_0010b7d0 = _optarg;\n      goto switchD_00105c5a_caseD_0;\n    case 0xc9:\n      bfd_plugin_set_plugin(_optarg);\n      cVar9 = DAT_0010b23b;\n      cVar6 = DAT_0010b240;\n      uVar14 = DAT_0010b244;\n      goto switchD_00105c5a_caseD_0;\n    case 0xca:\n      DAT_0010b7f8 = 1;\n      DAT_0010b800 = 0;\n      DAT_0010b7fc = 0;\n      goto switchD_00105c5a_caseD_0;\n    case 0xcb:\n      DAT_0010b248 = DAT_0010b248 & 0xfffbffff;\n      goto switchD_00105c5a_caseD_0;\n    case 0xcc:\n      goto switchD_00105c5a_caseD_cc;\n    case 0xcd:\n      DAT_0010b7c8 = _optarg;\n      goto switchD_00105c5a_caseD_0;\n    case 0xce:\n      iVar12 = strcmp((char *)_optarg,\"default\");\n      if ((iVar12 == 0) || (iVar12 = strcmp((char *)piVar27,\"d\"), iVar12 == 0)) {\n        DAT_0010b7e0 = 0;\n        unaff_R12 = piVar27;\n        cVar9 = DAT_0010b23b;\n        cVar6 = DAT_0010b240;\n        uVar14 = DAT_0010b244;\n      }\n      else {\n        iVar12 = strcmp((char *)piVar27,\"locale\");\n        if (iVar12 != 0) goto LAB_001061d5;\nLAB_001061a3:\n        DAT_0010b7e0 = 1;\n        unaff_R12 = piVar27;\n        cVar9 = DAT_0010b23b;\n        cVar6 = DAT_0010b240;\n        uVar14 = DAT_0010b244;\n      }\n      goto switchD_00105c5a_caseD_0;\n    case 0xcf:\n      goto switchD_00105c5a_caseD_cf;\n    default:\n      goto code_r0x00105b40;\n    }\n    uVar20 = dcgettext(0,pcVar26,5);\n    print_error_and_exit_00106300(uVar20,piVar27);\nLAB_00105f13:\n    lVar24 = *plVar18;\n    pcVar26 = \"%s: error: @-file refers to a directory\\n\";\nLAB_00105f1d:\n    fprintf(_stderr,pcVar26,lVar24);\n    xexit(1);\n    goto LAB_00105f38;\n  }\n  uVar14 = bfd_get_error();\n  uVar20 = bfd_errmsg(uVar14);\n  uVar21 = dcgettext(0,\"can\\'t set BFD default target to `%s\\': %s\",5);\n  print_error_and_exit_00106300(uVar21,\"x86_64-pc-linux-gnu\",uVar20);\n  goto LAB_0010613c;\nLAB_001057c0:\n  bVar7 = pbVar23[1];\n  pbVar23 = pbVar23 + 1;\n  if (bVar7 == 0) goto LAB_00105c5c;\n  goto LAB_001057d0;\nswitchD_00105c5a_caseD_cf:\n  _DAT_0010b810 = 1;\n  goto switchD_00105c5a_caseD_0;\ncode_r0x00105b40:\n  unaff_RBP = (undefined **)(ulong)DAT_0010b7dc;\n  if (DAT_0010b7dc != 0) {\n    printf(\"GNU %s %s\\n\",&DAT_001070c6,\"(GNU Binutils for Debian) 2.40\");\n    pcVar22 = (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n    printf(pcVar22);\n    pcVar22 = (char *)dcgettext(0,\n                                \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                                ,5);\n    printf(pcVar22);\n                    \n    exit(0);\n  }\n  if ((DAT_0010b7f8 != 0) && (DAT_0010b7e8 != 0)) {\n    uVar20 = dcgettext(0,\"Using the --size-sort and --undefined-only options together\",5);\n    print_error_message_00106400(uVar20);\n    uVar20 = dcgettext(0,\"will produce no output, since undefined symbols have no size.\",5);\n    print_error_message_00106400(uVar20);\n    return unaff_RBP;\n  }\n  pcVar22 = &optind;\n  if (_optind != param_1) {\n    if (1 < param_1 - _optind) {\nLAB_00105f38:\n      _DAT_0010b7c4 = 1;\n    }\n    while( true ) {\n      iVar12 = *(int *)pcVar22;\n      if (param_1 <= iVar12) break;\n      lVar24 = plVar18[iVar12];\n      *(int *)pcVar22 = iVar12 + 1;\n      cVar9 = check_file_001043d0(lVar24);\n      if (cVar9 != '\\0') {\n        iVar12 = *(int *)pcVar22;\n        if (param_1 <= iVar12) break;\n        lVar24 = plVar18[iVar12];\n        *(int *)pcVar22 = iVar12 + 1;\n        cVar9 = check_file_001043d0(lVar24);\n        if (cVar9 != '\\0') {\n          iVar12 = *(int *)pcVar22;\n          while( true ) {\n            if (param_1 <= iVar12) goto LAB_00105bdd;\n            lVar24 = plVar18[iVar12];\n            *(int *)pcVar22 = iVar12 + 1;\n            cVar9 = check_file_001043d0(lVar24);\n            if (cVar9 == '\\0') break;\n            iVar12 = *(int *)pcVar22;\n          }\n        }\n      }\n      unaff_RBP = (undefined **)(ulong)((int)unaff_RBP + 1);\n    }\nLAB_00105bdd:\n                    \n    exit((int)unaff_RBP);\n  }\nLAB_0010613c:\n  uVar11 = check_file_001043d0(\"a.out\");\n  return (undefined **)(ulong)((uVar11 ^ 1) & 0xff);\n}\n\n",
            "called": [
                "bfd_set_default_target",
                "xexit",
                "printf",
                "getopt_long",
                "exit",
                "memmove",
                "strlen",
                "cplus_demangle_set_style",
                "FUN_001043d0",
                "ferror",
                "bfd_set_error_program_name",
                "ftell",
                "FUN_00104370",
                "bfd_get_error",
                "cplus_demangle_name_to_style",
                "setlocale",
                "dcgettext",
                "bindtextdomain",
                "textdomain",
                "bfd_plugin_set_plugin",
                "xrealloc",
                "FUN_00106400",
                "strcmp",
                "xmalloc_set_program_name",
                "FUN_00106300",
                "FUN_00103ca0",
                "bfd_plugin_set_program_name",
                "fseek",
                "stat",
                "memcpy",
                "xstrdup",
                "bfd_errmsg",
                "fprintf",
                "fread",
                "fclose",
                "free",
                "bfd_init",
                "fopen",
                "xmalloc"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x001055f0",
            "calling": [
                "entry"
            ],
            "imported": false,
            "current_name": "FUNC_001055f0"
        },
        "bfd_init": {
            "renaming": {},
            "code": "\nvoid bfd_init(void)\n\n{\n  bfd_init();\n  return;\n}\n\n",
            "called": [
                "bfd_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102230",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "bfd_init"
        },
        "strerror": {
            "renaming": {},
            "code": "\n\n\nchar * strerror(int __errnum)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strerror(__errnum);\n  return pcVar1;\n}\n\n",
            "called": [
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102410",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "strerror"
        },
        "ferror": {
            "renaming": {},
            "code": "\n\n\nint ferror(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = ferror(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "ferror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020a0",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "ferror"
        },
        "entry": {
            "renaming": {},
            "code": "\nvoid processEntry entry(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_8 [8];\n  \n  __libc_start_main(FUNC_001055f0,param_2,&stack0x00000008,0,0,param_1,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "__libc_start_main",
                "FUN_001055f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105500",
            "calling": [],
            "imported": false,
            "current_name": "entry"
        },
        "abort": {
            "renaming": {},
            "code": "\n\n\nvoid abort(void)\n\n{\n                    \n  abort();\n}\n\n",
            "called": [
                "abort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102070",
            "calling": [
                "FUN_00102fd2"
            ],
            "imported": false,
            "current_name": "abort"
        },
        "memmove": {
            "renaming": {},
            "code": "\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memmove(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102310",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "memmove"
        },
        "strstr": {
            "renaming": {},
            "code": "\n\n\nchar * strstr(char *__haystack,char *__needle)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strstr(__haystack,__needle);\n  return pcVar1;\n}\n\n",
            "called": [
                "strstr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102420",
            "calling": [
                "FUN_00102fd2",
                "FUN_00104670"
            ],
            "imported": false,
            "current_name": "strstr"
        },
        "FUN_0010351b": {
            "renaming": {
                "FUN_0010351b": "check_data_validity_0010351b"
            },
            "code": "\nvoid checkDataValidity_0010351b(void)\n\n{\n  if (DAT_0010b818 == 0) {\n    printf(\"\\n%s:\\n\");\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010351b",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "check_data_validity_0010351b"
        },
        "FUN_00103b2b": {
            "renaming": {
                "FUN_00103b2b": "print_if_debug_mode_00103b2b",
                "param_1": "moduleName",
                "param_2": "moduleNameAbbreviation"
            },
            "code": "\nvoid printIfDebugMode_00103b2b(undefined8 moduleName,undefined8 moduleNameAbbreviation)\n\n{\n  if (DAT_0010b818 == 0) {\n    printf(\"%s[%s]:\\n\",moduleName,moduleNameAbbreviation);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103b2b",
            "calling": [],
            "imported": false,
            "current_name": "print_if_debug_mode_00103b2b"
        },
        "FUN_00104740": {
            "renaming": {
                "FUN_00104740": "print_formatted_message_00104740",
                "param_1": "formatString",
                "param_2": "paramArray",
                "param_3": "demangledName",
                "param_4": "options",
                "puVar1": "ptr1",
                "bVar2": "byte1",
                "bVar3": "byte2",
                "iVar4": "intVal",
                "sVar5": "length",
                "pcVar6": "strPtr",
                "puVar7": "ptr2",
                "pcVar8": "strPtr2",
                "__ptr": "result",
                "uVar9": "ulongVal",
                "uVar10": "undefinedVal",
                "puVar11": "ptr3",
                "puVar12": "ptr4",
                "__s": "strPtr3",
                "__s_00": "strPtr4",
                "lVar13": "longVal",
                "uVar14": "uintVal",
                "bVar15": "byte3",
                "acStack_39": "stackArr"
            },
            "code": "\n\n\nvoid printFormattedMessage_00104740(char *formatString,long *paramArray,undefined8 *demangledName,long options)\n\n{\n  undefined8 *ptr1;\n  byte byte1;\n  byte byte2;\n  int intVal;\n  size_t length;\n  char *strPtr;\n  undefined8 *ptr2;\n  char *strPtr2;\n  undefined8 *result;\n  ulong ulongVal;\n  undefined8 undefinedVal;\n  undefined *ptr3;\n  undefined8 *ptr4;\n  char *strPtr3;\n  undefined8 *strPtr4;\n  long longVal;\n  uint uintVal;\n  byte byte3;\n  char stackArr [9];\n  \n  byte3 = 0;\n  if (demangledName == (undefined8 *)0x0) {\n    demangledName = *(undefined8 **)(*paramArray + 0x10);\n    if (DAT_0010b234 == 0) {\n      print_decompiled_binary_00102739();\n      return;\n    }\nLAB_00104775:\n    ptr4 = demangledName;\n    if (DAT_0010b814 == 0) {\n      strPtr = (char *)0x0;\n      if (DAT_0010b7e0 == 0) {\nLAB_00104794:\n        ptr4 = demangledName;\n        result = (undefined8 *)0x0;\n      }\n      else {\n        result = (undefined8 *)0x0;\n        if (demangledName != (undefined8 *)0x0) goto LAB_0010269d;\n        ptr4 = (undefined8 *)0x1073a6;\n      }\n    }\n    else {\n      strPtr = (char *)0x0;\nLAB_0010482b:\n      if ((*(char *)ptr4 == '\\0') ||\n         (demangledName = (undefined8 *)bfd_demangle(options,ptr4,DAT_0010b248),\n         demangledName == (undefined8 *)0x0)) {\n        demangledName = ptr4;\n        if (DAT_0010b7e0 != 0) goto LAB_00102698;\n        result = (undefined8 *)0x0;\n      }\n      else {\n        ptr4 = demangledName;\n        result = demangledName;\n        if (DAT_0010b7e0 != 0) goto LAB_0010269d;\n      }\n    }\n  }\n  else {\n    ptr4 = demangledName;\n    if (DAT_0010b234 == 0) {\n      if (*(int *)(*(long *)(options + 8) + 8) != 5) goto LAB_00104775;\n      strPtr = strchr((char *)demangledName,0x40);\n      if (strPtr == (char *)0x0) {\n        if (DAT_0010b814 == 0) {\n          if (DAT_0010b7e0 == 0) {\n            if (paramArray == (long *)0x0) {\n              result = (undefined8 *)0x0;\n              printf(formatString,demangledName);\n            }\n            else {\n              if (paramArray[2] != 0) {\n                print_formatted_message_001047d0();\n                return;\n              }\n              result = (undefined8 *)0x0;\n              printf(formatString,demangledName);\n            }\n            goto LAB_001047ba;\n          }\n          goto LAB_00102698;\n        }\n      }\n      else {\n        *strPtr = '\\0';\n        if (DAT_0010b814 == 0) {\n          if (DAT_0010b7e0 == 0) goto LAB_00104794;\n          result = (undefined8 *)0x0;\n          goto LAB_0010269d;\n        }\n      }\n      goto LAB_0010482b;\n    }\n    strPtr = (char *)0x0;\n    if (DAT_0010b814 != 0) goto LAB_0010482b;\n    if (DAT_0010b7e0 == 0) goto LAB_00104794;\nLAB_00102698:\n    ptr4 = demangledName;\n    result = (undefined8 *)0x0;\nLAB_0010269d:\n    do {\n      byte1 = *(byte *)demangledName;\n      demangledName = (undefined8 *)((long)demangledName + 1);\n      if (byte1 == 0) goto joined_r0x00104864;\n    } while ((((&_sch_istable)[(ulong)byte1 * 2] & 2) == 0) && (byte1 < 0xc0));\n    length = strlen((char *)ptr4);\n    strPtr4 = DAT_0010b790;\n    if (_DAT_0010b798 < length * 9) {\n      free(DAT_0010b790);\n      length = strlen((char *)ptr4);\n      _DAT_0010b798 = length * 9;\n      DAT_0010b790 = (undefined8 *)xmalloc(_DAT_0010b798 + 1);\n      strPtr4 = DAT_0010b790;\n    }\n    while( true ) {\n      ptr2 = DAT_0010b790;\n      byte1 = *(byte *)ptr4;\n      ptr1 = (undefined8 *)((long)ptr4 + 1);\n      if (byte1 == 0) break;\n      if (((&_sch_istable)[(ulong)byte1 * 2] & 2) == 0) {\n        if ((byte1 < 0xc0) || (DAT_0010b7e0 == 0)) {\n          *(byte *)strPtr4 = byte1;\n          strPtr4 = (undefined8 *)((long)strPtr4 + 1);\n          ptr4 = ptr1;\n        }\n        else {\n          byte2 = *(byte *)((long)ptr4 + 1);\n          if ((byte2 & 0xc0) == 0x80) {\n            ptr2 = strPtr4;\n            if ((byte1 & 0x20) == 0) {\n              switch(DAT_0010b7e0) {\n              case 1:\n                uintVal = 2;\n                goto LAB_00102a62;\n              case 3:\n              case 5:\n                longVal = 2;\n                goto LAB_00102917;\n              case 4:\n                intVal = isatty(1);\n                if (intVal == 0) {\n                  byte2 = *(byte *)((long)ptr4 + 1);\n                }\n                else {\n                  *(undefined *)(strPtr4 + 1) = 0;\n                  *strPtr4 = 0x6d37343b31335b1b;\n                  byte2 = *(byte *)((long)ptr4 + 1);\n                  ptr2 = strPtr4 + 1;\n                }\n              case 2:\n                uintVal = 2;\n                sprintf((char *)ptr2,\"\\u%02x%02x\",(ulong)((int)(uint)*(byte *)ptr4 >> 2 & 7),\n                        (ulong)((*(byte *)ptr4 & 3) << 6 | byte2 & 0x3f));\n                ptr2 = (undefined8 *)((long)ptr2 + 6);\n                goto LAB_00102a27;\n              default:\n                uintVal = 2;\n              }\n            }\n            else {\n              byte2 = *(byte *)((long)ptr4 + 2);\n              if ((byte2 & 0xc0) != 0x80) goto LAB_0010285d;\n              if ((byte1 & 0x10) == 0) {\n                switch(DAT_0010b7e0) {\n                case 1:\n                  uintVal = 3;\nLAB_00102a62:\n                  for (ulongVal = (ulong)uintVal; ulongVal != 0; ulongVal = ulongVal - 1) {\n                    *(undefined *)ptr2 = *(undefined *)ptr4;\n                    ptr4 = (undefined8 *)((long)ptr4 + (ulong)byte3 * -2 + 1);\n                    ptr2 = (undefined8 *)((long)ptr2 + (ulong)byte3 * -2 + 1);\n                  }\n                  break;\n                case 3:\n                case 5:\n                  longVal = 3;\nLAB_00102917:\n                  undefinedVal = 0x7b;\n                  if (DAT_0010b7e0 == 3) {\n                    undefinedVal = 0x3c;\n                  }\n                  sprintf((char *)strPtr4,\"%c\",undefinedVal);\n                  *(undefined *)((long)strPtr4 + 3) = 0;\n                  ptr2 = (undefined8 *)(longVal + (long)ptr4);\n                  *(undefined2 *)((long)strPtr4 + 1) = 0x7830;\n                  strPtr2 = (char *)((long)strPtr4 + 3);\n                  do {\n                    strPtr3 = strPtr2;\n                    byte1 = *(byte *)ptr4;\n                    ptr4 = (undefined8 *)((long)ptr4 + 1);\n                    sprintf(strPtr3,\"%02x\",(ulong)byte1);\n                    strPtr2 = strPtr3 + 2;\n                  } while (ptr4 != ptr2);\n                  undefinedVal = 0x7d;\n                  if (DAT_0010b7e0 == 3) {\n                    undefinedVal = 0x3e;\n                  }\n                  uintVal = (uint)longVal;\n                  sprintf(strPtr3 + 2,\"%c\",undefinedVal);\n                  ptr2 = (undefined8 *)(strPtr3 + 3);\n                  break;\n                case 4:\n                  intVal = isatty(1);\n                  if (intVal == 0) {\n                    byte2 = *(byte *)((long)ptr4 + 2);\n                  }\n                  else {\n                    *(undefined *)(strPtr4 + 1) = 0;\n                    *strPtr4 = 0x6d37343b31335b1b;\n                    byte2 = *(byte *)((long)ptr4 + 2);\n                    ptr2 = strPtr4 + 1;\n                  }\n                case 2:\n                  uintVal = 3;\n                  sprintf((char *)ptr2,\"\\u%02x%02x\",\n                          (ulong)((uint)(((ulong)*(byte *)ptr4 & 0xf) << 4) |\n                                 (int)(uint)*(byte *)((long)ptr4 + 1) >> 2 & 0xfU),\n                          (ulong)((*(byte *)((long)ptr4 + 1) & 3) << 6 | byte2 & 0x3f));\n                  ptr2 = (undefined8 *)((long)ptr2 + 6);\nLAB_00102a27:\n                  if ((DAT_0010b7e0 == 4) && (intVal = isatty(1), intVal != 0)) {\n                    *(undefined4 *)ptr2 = 0x6d305b1b;\n                    ptr2 = (undefined8 *)((long)ptr2 + 4);\n                    *(undefined *)ptr2 = 0;\n                  }\n                  break;\n                default:\n                  uintVal = 3;\n                }\n              }\n              else {\n                byte2 = *(byte *)((long)ptr4 + 3);\n                if ((byte2 & 0xc0) != 0x80) goto LAB_0010285d;\n                switch(DAT_0010b7e0) {\n                case 1:\n                  uintVal = 4;\n                  goto LAB_00102a62;\n                case 3:\n                case 5:\n                  longVal = 4;\n                  goto LAB_00102917;\n                case 4:\n                  intVal = isatty(1);\n                  if (intVal == 0) {\n                    byte2 = *(byte *)((long)ptr4 + 3);\n                  }\n                  else {\n                    *(undefined *)(strPtr4 + 1) = 0;\n                    *strPtr4 = 0x6d37343b31335b1b;\n                    byte2 = *(byte *)((long)ptr4 + 3);\n                    ptr2 = strPtr4 + 1;\n                  }\n                case 2:\n                  uintVal = 4;\n                  intVal = sprintf((char *)ptr2,\"\\u%02x%02x%02x\",\n                                  (ulong)((*(byte *)ptr4 & 7) << 6 |\n                                         (int)(uint)*(byte *)((long)ptr4 + 1) >> 2 & 0xfU),\n                                  (ulong)((*(byte *)((long)ptr4 + 1) & 3) << 6 |\n                                         (int)(uint)*(byte *)((long)ptr4 + 2) >> 2 & 0xfU),\n                                  (ulong)((*(byte *)((long)ptr4 + 2) & 3) << 6 | byte2 & 0x3f));\n                  ptr2 = (undefined8 *)((long)ptr2 + (long)intVal);\n                  goto LAB_00102a27;\n                default:\n                  uintVal = 4;\n                }\n              }\n            }\n            ulongVal = (ulong)(uint)((int)ptr2 - (int)strPtr4);\n          }\n          else {\nLAB_0010285d:\n            *(byte *)strPtr4 = byte1;\n            uintVal = 1;\n            ulongVal = 1;\n          }\n          strPtr4 = (undefined8 *)((long)strPtr4 + ulongVal);\n          ptr4 = (undefined8 *)((long)ptr1 + (ulong)(uintVal - 1));\n        }\n      }\n      else {\n        *(undefined *)strPtr4 = 0x5e;\n        *(byte *)((long)strPtr4 + 1) = byte1 + 0x40;\n        strPtr4 = (undefined8 *)((long)strPtr4 + 2);\n        ptr4 = ptr1;\n      }\n    }\n    *(undefined *)strPtr4 = 0;\n    ptr4 = ptr2;\n  }\njoined_r0x00104864:\n  if ((((paramArray != (long *)0x0) && (paramArray[2] != 0)) && (DAT_0010b234 != 0)) &&\n     ((strPtr2 = (char *)(**(code **)(*(long *)(options + 8) + 0x220))\n                                  (options,paramArray[2],0,stackArr), strPtr2 != (char *)0x0 &&\n      (*strPtr2 != '\\0')))) {\n    ptr3 = &DAT_001071e0;\n    if ((stackArr[0] == '\\0') && (*(long *)(paramArray[2] + 0x20) != 0x10c2a8)) {\n      ptr3 = &DAT_001071df;\n    }\n    result = (undefined8 *)reconcat(result,ptr4,ptr3,strPtr2,0);\n    ptr4 = result;\n  }\n  printf(formatString,ptr4);\n  if (strPtr != (char *)0x0) {\n    *strPtr = '@';\n  }\nLAB_001047ba:\n  free(result);\n  return;\n}\n\n",
            "called": [
                "FUN_00102739"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104740",
            "calling": [
                "FUN_001064b0",
                "FUN_00103729",
                "FUN_001035a2",
                "FUN_00103b49",
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "print_formatted_message_00104740"
        },
        "bfd_check_format_matches": {
            "renaming": {},
            "code": "\nvoid bfd_check_format_matches(void)\n\n{\n  bfd_check_format_matches();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format_matches"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102380",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "bfd_check_format_matches"
        },
        "FUN_00106400": {
            "renaming": {
                "FUN_00106400": "print_error_message_00106400",
                "param_1": "errorCode",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6",
                "param_7": "param7",
                "param_8": "param8",
                "param_9": "errorMessage",
                "param_10": "param10",
                "param_11": "param11",
                "param_12": "param12",
                "param_13": "param13",
                "param_14": "param14",
                "in_AL": "flag",
                "local_d8": "size",
                "local_d4": "constant",
                "local_d0": "localArray1",
                "local_c8": "localArray2",
                "local_b8": "localBuffer",
                "local_b0": "param10Copy",
                "local_a8": "param11Copy",
                "local_a0": "param12Copy",
                "local_98": "param13Copy",
                "local_90": "param14Copy",
                "local_88": "errorCodeCopy",
                "local_78": "param2Copy",
                "local_68": "param3Copy",
                "local_58": "param4Copy",
                "local_48": "param5Copy",
                "local_38": "param6Copy",
                "local_28": "param7Copy",
                "local_18": "param8Copy"
            },
            "code": "\nvoid printErrorMessage_00106400(undefined4 errorCode,undefined4 param2,undefined4 param3,undefined4 param4,\n                 undefined4 param5,undefined4 param6,undefined4 param7,undefined4 param8,\n                 undefined8 errorMessage,undefined8 param10,undefined8 param11,undefined8 param12,\n                 undefined8 param13,undefined8 param14)\n\n{\n  char flag;\n  undefined4 size;\n  undefined4 constant;\n  undefined *localArray1;\n  undefined *localArray2;\n  undefined localBuffer [8];\n  undefined8 param10Copy;\n  undefined8 param11Copy;\n  undefined8 param12Copy;\n  undefined8 param13Copy;\n  undefined8 param14Copy;\n  undefined4 errorCodeCopy;\n  undefined4 param2Copy;\n  undefined4 param3Copy;\n  undefined4 param4Copy;\n  undefined4 param5Copy;\n  undefined4 param6Copy;\n  undefined4 param7Copy;\n  undefined4 param8Copy;\n  \n  if (flag != '\\0') {\n    errorCodeCopy = errorCode;\n    param2Copy = param2;\n    param3Copy = param3;\n    param4Copy = param4;\n    param5Copy = param5;\n    param6Copy = param6;\n    param7Copy = param7;\n    param8Copy = param8;\n  }\n  localArray1 = &stack0x00000008;\n  size = 8;\n  localArray2 = localBuffer;\n  constant = 0x30;\n  param10Copy = param10;\n  param11Copy = param11;\n  param12Copy = param12;\n  param13Copy = param13;\n  param14Copy = param14;\n  print_error_message_001063a0(errorMessage,&size);\n  return;\n}\n\n",
            "called": [
                "FUN_001063a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00106400",
            "calling": [
                "FUN_0010249f",
                "FUN_001055f0",
                "FUN_00104d5b",
                "FUN_001048e0",
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "print_error_message_00106400"
        },
        "bfd_get_arch_size": {
            "renaming": {},
            "code": "\nvoid bfd_get_arch_size(void)\n\n{\n  bfd_get_arch_size();\n  return;\n}\n\n",
            "called": [
                "bfd_get_arch_size"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102220",
            "calling": [
                "FUN_00104670"
            ],
            "imported": false,
            "current_name": "bfd_get_arch_size"
        },
        "ftell": {
            "renaming": {},
            "code": "\n\n\nlong ftell(FILE *__stream)\n\n{\n  long lVar1;\n  \n  lVar1 = ftell(__stream);\n  return lVar1;\n}\n\n",
            "called": [
                "ftell"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102270",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "ftell"
        },
        "FUN_00103533": {
            "renaming": {
                "FUN_00103533": "compare_and_call_00103533",
                "param_1": "array1",
                "param_2": "array2",
                "uVar1": "result"
            },
            "code": "\nulong compareAndCall_00103533(undefined8 *array1,undefined8 *array2)\n\n{\n  ulong result;\n  \n  if ((ulong)array1[1] < (ulong)array2[1]) {\n    return (ulong)(-(uint)(DAT_0010b7f4 == 0) | 1);\n  }\n  if ((ulong)array2[1] < (ulong)array1[1]) {\n    return (ulong)((-(uint)(DAT_0010b7f4 == 0) & 2) - 1);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00103571. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  result = (*(code *)(&PTR_FUN_0010acc0)[DAT_0010b7f4])(*array1,*array2);\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103533",
            "calling": [
                "FUN_00104d5b"
            ],
            "imported": false,
            "current_name": "compare_and_call_00103533"
        },
        "FUN_00103abc": {
            "renaming": {
                "FUN_00103abc": "FUNC_00103abc"
            },
            "code": "\nvoid FUNC_00103abc(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00103abc",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_00103abc"
        },
        "FUN_0010651a": {
            "renaming": {
                "FUN_0010651a": "print_symmetry_0010651a",
                "print_symmetry_001054d0": "print_symmetry_helper"
            },
            "code": "\nvoid print_symmetry_0010651a(void)\n\n{\n  print_symmetry_0010651a_helper();\n  return;\n}\n\n",
            "called": [
                "FUN_001054d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010651a",
            "calling": [
                "FUN_001064b0",
                "FUN_00103a66"
            ],
            "imported": false,
            "current_name": "print_symmetry_0010651a"
        },
        "FUN_00103abd": {
            "renaming": {
                "FUN_00103abd": "FUNC_00103abd"
            },
            "code": "\nvoid FUNC_00103abd(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00103abd",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_00103abd"
        },
        "FUN_00103aba": {
            "renaming": {
                "FUN_00103aba": "FUNC_00103aba"
            },
            "code": "\nvoid FUNC_00103aba(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00103aba",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_00103aba"
        },
        "FUN_00103abb": {
            "renaming": {
                "FUN_00103abb": "FUNC_00103abb"
            },
            "code": "\nvoid FUNC_00103abb(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00103abb",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_00103abb"
        },
        "FUN_001053c0": {
            "renaming": {
                "FUN_001053c0": "print_symbol_001053c0",
                "param_1": "symbol",
                "param_2": "parameter",
                "iVar1": "symbolCount",
                "cVar2": "isUndefined",
                "uVar3": "message",
                "lVar4": "symmetryOffset"
            },
            "code": "\nvoid printSymbol_001053c0(long *symbol,undefined8 parameter)\n\n{\n  int symbolCount;\n  char isUndefined;\n  undefined8 message;\n  long symmetryOffset;\n  \n  isUndefined = bfd_is_undefined_symclass((int)*(char *)(*symbol + 8));\n  symbolCount = DAT_0010b7a8;\n  if (isUndefined == '\\0') {\n    if (DAT_0010b7f8 == 0) {\n      if ((DAT_0010b7a8 - 0x20U & 0xffffffdf) != 0) {\nLAB_00103603:\n        message = dcgettext(0,\"Print width has not been initialized (%d)\",5);\n        print_error_and_exit_00106300(message,symbolCount);\n        goto LAB_00103623;\n      }\n      message = *(undefined8 *)*symbol;\n    }\n    else {\n      if (DAT_0010b7ec == 0) {\n        if (symbol[2] == 0) {\n          symmetryOffset = symbol[1];\n        }\n        else {\n          symmetryOffset = *(long *)(symbol[2] + 0x38);\n        }\n        print_symmetry_001054d0(symmetryOffset);\n        if (DAT_0010b7ec != 0) {\n          print_symmetry_info_001035a2();\n          return;\n        }\n        goto LAB_00105423;\n      }\n      message = *(undefined8 *)*symbol;\n      if ((DAT_0010b7a8 - 0x20U & 0xffffffdf) != 0) goto LAB_00103603;\n    }\n    printf(DAT_0010b7a0,message);\n    if (DAT_0010b7ec != 0) {\n      print_symmetry_info_001035a2();\n      return;\n    }\n  }\n  else if (DAT_0010b7a8 == 0x40) {\n    printf(\"        \");\n    printf(\"        \");\n  }\n  else {\n    printf(\"        \");\n  }\nLAB_00105423:\n  printf(\" %c\",(ulong)(uint)(int)*(char *)(*symbol + 8));\n  if (*(char *)(*symbol + 8) != '-') {\n    print_formatted_message_00104740(&DAT_0010712c,symbol,0,parameter);\n    return;\n  }\nLAB_00103623:\n  putchar(0x20);\n  printf(&DAT_0010b238,(ulong)(uint)(int)*(char *)(*symbol + 0x19));\n  putchar(0x20);\n  printf(&DAT_0010b23d,(ulong)(uint)(int)*(short *)(*symbol + 0x1a));\n  printf(\" %5s\",*(undefined8 *)(*symbol + 0x20));\n  print_formatted_message_00104740(&DAT_0010712c,symbol,0,parameter);\n  return;\n}\n\n",
            "called": [
                "printf",
                "FUN_00106300",
                "FUN_001035a2",
                "bfd_is_undefined_symclass",
                "FUN_001054d0",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001053c0",
            "calling": [
                "FUN_00105110"
            ],
            "imported": false,
            "current_name": "print_symbol_001053c0"
        },
        "FUN_001064b0": {
            "renaming": {
                "FUN_001064b0": "print_symbol_info_001064b0",
                "param_1": "symbol_info",
                "param_2": "additional_info",
                "cVar1": "is_undefined",
                "putchar": "print_character",
                "print_symmetry_001054d0": "print_symmetry",
                "print_symmetry_0010651a": "print_missing_symmetry"
            },
            "code": "\nvoid print_symbol_info_001064b0(long *symbol_info,undefined8 additional_info)\n\n{\n  char is_undefined;\n  \n  print_formatted_message_00104740(&DAT_00107363,symbol_info,0,additional_info);\n  printf(\"%c \",(ulong)(uint)(int)*(char *)(*symbol_info + 8));\n  is_undefined = bfd_is_undefined_symclass((int)*(char *)(*symbol_info + 8));\n  if (is_undefined != '\\0') {\n    printf(\"        \");\n    return;\n  }\n  print_symmetry(*(undefined8 *)*symbol_info);\n  putchar(0x20);\n  if (symbol_info[2] == 0) {\n    if (symbol_info[1] != 0) {\n      print_missing_symmetry();\n      return;\n    }\n  }\n  else if (*(long *)(symbol_info[2] + 0x38) != 0) {\n    print_symmetry();\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "putchar",
                "printf",
                "bfd_is_undefined_symclass",
                "FUN_001054d0",
                "FUN_00103a66",
                "FUN_0010651a",
                "FUN_00104740"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001064b0",
            "calling": [],
            "imported": false,
            "current_name": "print_symbol_info_001064b0"
        },
        "printf": {
            "renaming": {},
            "code": "\n\n\nint printf(char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = printf(__format);\n  return iVar1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102190",
            "calling": [
                "FUN_00103573",
                "FUN_00103729",
                "FUN_00102670",
                "FUN_001035a2",
                "FUN_00103abf",
                "FUN_00102f19",
                "FUN_001055f0",
                "FUN_001047d0",
                "FUN_00105110",
                "FUN_001043d0",
                "FUN_00103463",
                "FUN_00103b2b",
                "FUN_001053c0",
                "FUN_001064b0",
                "FUN_0010351b",
                "FUN_001054d0",
                "FUN_00102f7b",
                "FUN_001062d0",
                "FUN_00102739",
                "FUN_001036e0",
                "FUN_001036a7"
            ],
            "imported": false,
            "current_name": "printf"
        },
        "FUN_00103b49": {
            "renaming": {
                "FUN_00103b49": "print_formatted_message_00103b49",
                "param_1": "message",
                "param_2": "format"
            },
            "code": "\nvoid printFormattedMessage_00103b49(undefined8 message,undefined8 format)\n\n{\n  print_formatted_message_00104740(&DAT_0010712d,message,0,format);\n  return;\n}\n\n",
            "called": [
                "FUN_00104740"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103b49",
            "calling": [],
            "imported": false,
            "current_name": "print_formatted_message_00103b49"
        },
        "FUN_00103abe": {
            "renaming": {
                "FUN_00103abe": "FUNC_00103abe"
            },
            "code": "\nvoid FUNC_00103abe(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00103abe",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_00103abe"
        },
        "FUN_00103abf": {
            "renaming": {
                "FUN_00103abf": "print_undefined_symbols_00103abf",
                "param_1": "filename",
                "param_2": "symbol",
                "pcVar1": "message"
            },
            "code": "\nvoid printUndefinedSymbols_00103abf(undefined8 filename,undefined8 symbol)\n\n{\n  char *message;\n  \n  message = \"\\n\\nUndefined symbols from %s[%s]:\\n\\n\";\n  if (DAT_0010b7e8 == 0) {\n    message = \"\\n\\nSymbols from %s[%s]:\\n\\n\";\n  }\n  message = (char *)dcgettext(0,message,5);\n  printf(message,filename,symbol);\n  message = \"Name                  Value   Class        Type         Size     Line  Section\\n\\n\";\n  if (DAT_0010b7a8 != 0x20) {\n    message = \n    \"Name                  Value           Class        Type         Size             Line  Section\\n\\n\"\n    ;\n  }\n  message = (char *)dcgettext(0,message,5);\n  printf(message);\n  return;\n}\n\n",
            "called": [
                "printf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103abf",
            "calling": [],
            "imported": false,
            "current_name": "print_undefined_symbols_00103abf"
        },
        "FUN_00103bf6": {
            "renaming": {
                "FUN_00103bf6": "compare_and_negate_result_00103bf6",
                "iVar1": "result",
                "in_RAX": "input_value",
                "auVar2": "output_value"
            },
            "code": "\nundefined  [16] compare_and_negate_result_00103bf6(void)\n\n{\n  int result;\n  undefined8 input_value;\n  undefined output_value [16];\n  \n  result = compare_strings_00104fa0();\n  output_value._0_4_ = -result;\n  output_value._4_4_ = 0;\n  output_value._8_8_ = input_value;\n  return output_value;\n}\n\n",
            "called": [
                "FUN_00104fa0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103bf6",
            "calling": [],
            "imported": false,
            "current_name": "compare_and_negate_result_00103bf6"
        },
        "FUN_00102450": {
            "renaming": {
                "FUN_00102450": "print_supported_targets_00102450",
                "__ptr": "targetList",
                "unaff_RBX": "outputFile",
                "plVar3": "currentTarget",
                "in_stack_00000008": "exitCode",
                "pcVar2": "message"
            },
            "code": "\nvoid printSupportedTargets_00102450(void)\n\n{\n  long lVar1;\n  char *message;\n  long *targetList;\n  FILE *outputFile;\n  long *currentTarget;\n  int exitCode;\n  \n  message = (char *)dcgettext(0,\"Supported targets:\",5);\n  fprintf(outputFile,message);\n  targetList = (long *)bfd_target_list();\n  currentTarget = targetList;\n  while( true ) {\n    lVar1 = *currentTarget;\n    currentTarget = currentTarget + 1;\n    if (lVar1 == 0) break;\n    fprintf(outputFile,\" %s\");\n  }\n  fputc(10,outputFile);\n  free(targetList);\n  if (exitCode == 0) {\n    message = (char *)dcgettext(0,\"Report bugs to %s.\\n\",5);\n    fprintf(outputFile,message,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  exit(exitCode);\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102450",
            "calling": [
                "FUN_00103ca0"
            ],
            "imported": false,
            "current_name": "print_supported_targets_00102450"
        },
        "FUN_00102c19": {
            "renaming": {
                "FUN_00102c19": "slim_lto_object_handler_00102c19",
                "pcVar1": "ptr",
                "pcVar2": "func",
                "cVar3": "ch",
                "iVar4": "index",
                "uVar5": "val",
                "uVar6": "result",
                "lVar7": "length",
                "puVar8": "ptr1",
                "lVar9": "value",
                "puVar10": "ptr2",
                "unaff_RBX": "dst",
                "__ptr": "src",
                "unaff_RBP": "rbp",
                "puVar11": "ptr3",
                "puVar12": "ptr4",
                "puVar13": "ptr5",
                "in_R8": "size",
                "puVar14": "ptr6",
                "in_R9": "nmemb",
                "puVar15": "ptr7",
                "unaff_R12": "ptr8",
                "unaff_R13": "ptr9",
                "unaff_R14": "ptr10",
                "unaff_R15": "ptr11",
                "bVar16": "flag",
                "bVar17": "byteVal",
                "unaff_retaddr": "retaddr",
                "uVar18": "val2",
                "in_stack_00000008": "var1",
                "in_stack_00000010": "var2",
                "in_stack_00000018": "var3",
                "in_stack_00000038": "var4",
                "in_stack_00000040": "var5",
                "in_stack_00000048": "var6"
            },
            "code": "\n\n\nvoid slim_lto_object_handler_00102c19(void)\n\n{\n  char *ptr;\n  code *func;\n  char ch;\n  int index;\n  uint val;\n  undefined8 result;\n  long length;\n  undefined8 *ptr1;\n  long value;\n  undefined8 *ptr2;\n  undefined8 *dst;\n  undefined8 *src;\n  undefined8 *rbp;\n  undefined8 *ptr3;\n  undefined8 *ptr4;\n  undefined8 *size;\n  undefined8 *ptr5;\n  undefined8 *nmemb;\n  undefined8 *ptr6;\n  undefined8 *ptr8;\n  undefined8 *ptr7;\n  undefined8 *ptr9;\n  undefined8 *ptr10;\n  undefined8 *ptr11;\n  bool flag;\n  byte byteVal;\n  ulong retaddr;\n  ulong val2;\n  undefined8 var1;\n  undefined8 *var2;\n  undefined8 *var3;\n  undefined8 var4;\n  void *var5;\n  undefined8 *var6;\n  \n  byteVal = 0;\n  if (_DAT_0010b760 == 0) goto LAB_001049c3;\nLAB_00104a7b:\n  do {\n    if (dst != ptr9) {\n      if (ptr10 == (undefined8 *)0x8) {\n        *dst = *ptr9;\n        process_lto_object_001049c0();\n        return;\n      }\n      for (; ptr10 != (undefined8 *)0x0; ptr10 = (undefined8 *)((long)ptr10 + -1)) {\n        *(undefined *)dst = *(undefined *)ptr9;\n        ptr9 = (undefined8 *)((long)ptr9 + (ulong)byteVal * -2 + 1);\n        dst = (undefined8 *)((long)dst + (ulong)byteVal * -2 + 1);\n      }\n      process_lto_object_001049c0();\n      return;\n    }\n    dst = (undefined8 *)((long)dst + (long)ptr10);\nLAB_001049c3:\n    do {\n      do {\n        ptr9 = (undefined8 *)((long)ptr9 + (long)ptr10);\n        ptr7 = ptr8;\n        ptr4 = rbp;\n        if (ptr8 <= ptr9) goto LAB_00104b15;\nLAB_001049cf:\n        ptr1 = (undefined8 *)\n                 (**(code **)(rbp[1] + 0x270))\n                           (rbp,retaddr & 0xffffffff,ptr9,ptr11);\n        ptr3 = rbp;\n        ptr4 = ptr9;\n        ptr7 = ptr11;\n        if (ptr1 == (undefined8 *)0x0) goto LAB_00102eb0;\n        ptr = (char *)ptr1[1];\n        if (((ptr == (char *)0x0) || (*ptr != '_')) || (ptr[1] != '_')) {\nLAB_00104a03:\n          if (DAT_0010b7e8 == 0) goto LAB_00104a11;\nLAB_00104ae2:\n          val = (uint)(ptr1[4] == 0x10c2a8);\nLAB_00104af9:\n          if (val != 0) goto LAB_00104a2d;\n          ptr9 = (undefined8 *)((long)ptr9 + (long)ptr10);\n          ptr7 = ptr8;\n          ptr4 = rbp;\n          if (ptr8 <= ptr9) {\nLAB_00104b15:\n            dst = (undefined8 *)((long)dst - (long)var3);\n            if (ptr10 == (undefined8 *)0x8) {\n              value = ptr4[1];\n              ptr3 = (undefined8 *)((long)dst + 7);\n              if (-1 < (long)dst) {\n                ptr3 = dst;\n              }\n              size = (undefined8 *)(ulong)DAT_0010b800;\n              func = *(code **)(value + 0x208);\n              ptr3 = (undefined8 *)((long)ptr3 >> 3);\n            }\n            else {\n              ptr3 = (undefined8 *)((long)dst / (long)ptr10);\n              value = ptr4[1];\n              func = *(code **)(value + 0x208);\n            }\n            rbp = ptr4;\n            if (DAT_0010b800 == 0) {\n              DAT_0010b778 = DAT_0010b80c != 0;\n              DAT_0010b780 = ptr4;\n              DAT_0010b770 = (undefined8 *)(*func)(ptr4);\n              DAT_0010b768 = (undefined8 *)(**(code **)(ptr4[1] + 0x208))(ptr4);\n              dst = var6;\n              if ((DAT_0010b770 == (undefined8 *)0x0) || (DAT_0010b768 == (undefined8 *)0x0)) {\n                handle_error_00106530(*ptr4);\n                src = ptr11;\n                goto LAB_00102d8e;\n              }\n              ptr8 = (undefined8 *)(ulong)var4._4_4_;\n              if (DAT_0010b7f8 != 0) {\n                val2 = (ulong)(DAT_0010b80c != 0);\n                qsort(var6,(size_t)ptr3,(size_t)ptr8,check_binary_compatibility_00102fd2);\n                ptr7 = (undefined8 *)xmalloc((long)ptr3 << 4);\n                ptr5 = DAT_0010b770;\n                rbp = DAT_0010b768;\n                ptr10 = (undefined8 *)((long)ptr3 * (long)ptr8 + (long)dst);\n                ptr1 = DAT_0010b770;\n                nmemb = DAT_0010b768;\n                if (ptr10 <= dst) goto LAB_00102ec2;\n                ptr3 = (undefined8 *)\n                          (**(code **)(ptr4[1] + 0x270))(ptr4,val2 & 0xffffffff,dst);\n                src = dst;\n                size = ptr8;\n                var2 = ptr7;\n                if (ptr3 == (undefined8 *)0x0) goto LAB_00102eb9;\n                goto LAB_00104e35;\n              }\n              qsort(var6,(size_t)ptr3,(size_t)ptr8,\n                    (__compar_fn_t)(&PTR_FUN_0010acc0)[(long)DAT_0010b7f4 + (long)DAT_0010b7fc * 2])\n              ;\n              value = ptr4[1];\n            }\n            src = (undefined8 *)0x0;\n            do {\n              ptr4 = var6;\n              ptr1 = (undefined8 *)(ulong)DAT_0010b7f8;\n              ptr10 = (undefined8 *)(ulong)(DAT_0010b80c != 0);\n              if (DAT_0010b7f8 != 0) {\n                ptr7 = (undefined8 *)(**(code **)(value + 0x208))(rbp);\n                if (ptr7 == (undefined8 *)0x0) goto LAB_00102ed2;\n                dst = src + (long)ptr3 * 2;\n                ptr3 = src;\n                do {\n                  if (dst <= ptr3) {\nLAB_00104c75:\n                    if (var5 == (void *)0x0) {\n                      free(var6);\n                      free(src);\n                      return;\n                    }\n                    free(var5);\n                    free(var6);\n                    free(src);\n                    return;\n                  }\n                  ptr1 = ptr7;\n                  value = (**(code **)(rbp[1] + 0x270))(rbp,ptr10,*ptr3);\n                  if (value == 0) {\n                    handle_error_00106530(*rbp,0);\nLAB_00102ed2:\n                    ptr4 = (undefined8 *)*rbp;\n                    handle_error_00106530();\n                    ptr5 = size;\n                    ptr6 = nmemb;\n                    goto LAB_00102edb;\n                  }\n                  ptr4 = ptr3 + 1;\n                  ptr3 = ptr3 + 2;\n                  print_params_and_update_table_00105110(rbp,value,*ptr4,var1);\n                } while( true );\n              }\n              ptr8 = (undefined8 *)(ulong)var4._4_4_;\n              ptr11 = (undefined8 *)(**(code **)(value + 0x208))(rbp);\n              if (ptr11 == (undefined8 *)0x0) {\n                handle_error_00106530(*rbp);\n                ptr4 = ptr8;\n                if (DAT_0010b80c == 0) {\n                  value = (**(code **)(rbp[1] + 0x350))(rbp);\n                  ptr3 = var6;\n                  ptr7 = ptr8;\n                  if (value < 1) {\n                    ptr1 = (undefined8 *)0x0;\n                    dst = (undefined8 *)0x0;\n                  }\n                  else {\nLAB_00102d8e:\n                    dst = (undefined8 *)xmalloc();\n                    ptr1 = (undefined8 *)(**(code **)(rbp[1] + 0x358))(rbp,dst);\n                    ptr4 = ptr7;\n                    if ((long)ptr1 < 0) {\n                      ptr4 = (undefined8 *)*rbp;\n                      ptr3 = (undefined8 *)handle_error_00106530(ptr4,ptr7);\n                      goto LAB_00102dbe;\n                    }\n                  }\n                }\n                else {\n                  ptr1 = ptr8;\n                  dst = var6;\n                  ptr3 = (undefined8 *)0x0;\n                  ptr7 = (undefined8 *)0x0;\n                }\n                nmemb = &stack0x00000040;\n                size = dst;\n                value = (**(code **)(rbp[1] + 0x360))(rbp,ptr7,ptr3,ptr1);\n                ptr8 = ptr4;\n                if (0 < value) {\n                  ptr8 = (undefined8 *)((long)ptr4 + value);\n                  var6 = (undefined8 *)xrealloc(var6);\n                  length = 0;\n                  do {\n                    var6[(long)((long)ptr4 + length)] =\n                         (void *)(length * 0x30 + (long)var5);\n                    length = length + 1;\n                  } while (value != length);\n                  var6[(long)((long)ptr4 + value)] = 0;\n                }\n                if ((DAT_0010b80c == 0) && (dst != (undefined8 *)0x0)) {\n                  free(dst);\n                }\n                if ((*(byte *)((long)rbp + 0x4a) & 0x10) != 0) {\n                  dst = (undefined8 *)*rbp;\n                  DAT_0010b230 = '\\0';\n                  result = dcgettext(0,\"%s: plugin needed to handle lto object\",5);\n                  print_error_message_00106400(result);\n                }\n                ptr10 = (undefined8 *)(ulong)var4._4_4_;\n                flag = DAT_0010b80c != 0;\n                ptr3 = (undefined8 *)(ulong)flag;\n                ptr1 = var6;\n                var3 = var6;\n                ptr11 = (undefined8 *)(**(code **)(rbp[1] + 0x208))(rbp);\n                if (ptr11 != (undefined8 *)0x0) goto code_r0x00104992;\n              }\n              else {\n                ptr3 = (undefined8 *)((long)ptr3 * (long)ptr8 + (long)ptr4);\n                dst = ptr4;\n                while( true ) {\n                  if (ptr3 <= dst) goto LAB_00104c75;\n                  ptr1 = ptr11;\n                  value = (**(code **)(rbp[1] + 0x270))(rbp,ptr10,dst);\n                  if (value == 0) break;\n                  dst = (undefined8 *)((long)dst + (long)ptr8);\n                  print_params_and_update_table_00105110(rbp,value,0,var1);\n                }\n                handle_error_00106530(*rbp,0);\n              }\n              handle_error_00106530(*rbp);\n              ptr4 = rbp;\n              ptr7 = ptr11;\nLAB_00102eb0:\n              handle_error_00106530(*ptr3);\nLAB_00102eb9:\n              handle_error_00106530(*ptr4);\nLAB_00102ec2:\n              ptr3 = (undefined8 *)0x0;\n              src = dst;\n              size = ptr8;\n              ptr5 = ptr1;\n              rbp = nmemb;\n              var2 = ptr7;\nLAB_00104e35:\n              while (nmemb = ptr5, src < ptr10) {\n                dst = (undefined8 *)((long)src + (long)size);\n                if (dst < ptr10) {\n                  ptr1 = rbp;\n                  ptr5 = size;\n                  ptr6 = nmemb;\n                  ptr2 = (undefined8 *)(**(code **)(ptr4[1] + 0x270))();\n                  if (ptr2 == (undefined8 *)0x0) {\nLAB_00102edb:\n                    nmemb = ptr6;\n                    size = ptr5;\n                    ptr4 = (undefined8 *)*ptr4;\n                    ptr2 = (undefined8 *)handle_error_00106530();\n                  }\n                  else {\n                    ptr1 = (undefined8 *)ptr3[4];\n                    if ((*(uint *)(ptr3 + 3) & 0x200100) == 0) goto LAB_00104e95;\n                  }\n                  value = ptr3[2];\nLAB_00102ee7:\n                  if (ptr1 == (undefined8 *)ptr2[4]) {\n                    value = ptr2[2] - value;\n                    ptr5 = rbp;\n                    ptr6 = src;\n                    goto LAB_00104ea7;\n                  }\nLAB_00102dc4:\n                  value = ptr1[8] - value;\n                  ptr5 = rbp;\n                  ptr6 = src;\n                }\n                else {\n                  ptr1 = (undefined8 *)ptr3[4];\n                  if ((*(uint *)(ptr3 + 3) & 0x200100) != 0) {\nLAB_00102dbe:\n                    value = ptr3[2];\n                    ptr2 = (undefined8 *)0x0;\n                    goto LAB_00102dc4;\n                  }\n                  ptr2 = (undefined8 *)0x0;\nLAB_00104e95:\n                  ptr5 = rbp;\n                  ptr6 = src;\n                  if (*(int *)(ptr4[1] + 8) == 5) {\n                    value = ptr3[7];\n                  }\n                  else {\n                    value = ptr3[2];\n                    if ((*(byte *)((long)ptr1 + 0x25) & 0x10) == 0) {\n                      if (dst < ptr10) goto LAB_00102ee7;\n                      goto LAB_00102dc4;\n                    }\n                  }\n                }\nLAB_00104ea7:\n                ptr3 = ptr2;\n                src = dst;\n                rbp = nmemb;\n                if (value != 0) {\n                  *ptr7 = ptr6;\n                  ptr7[1] = value;\n                  ptr7 = ptr7 + 2;\n                }\n              }\n              ptr3 = (undefined8 *)((long)ptr7 - (long)var2 >> 4);\n              qsort(var2,(size_t)ptr3,0x10,FUN_00103533);\n              value = ptr4[1];\n              dst = src;\n              rbp = ptr4;\n              src = var2;\n            } while( true );\n          }\n          goto LAB_001049cf;\n        }\n        index = strcmp(ptr + (ptr[2] == '_'),\"__gnu_lto_slim\");\n        var2 = ptr1;\n        if (index == 0) {\n          if (DAT_0010b230 != '\\0') {\n            var2 = (undefined8 *)*rbp;\n            DAT_0010b230 = '\\0';\n            result = dcgettext(0,\"%s: plugin needed to handle lto object\",5);\n            print_error_message_00106400(result,var2);\n          }\n          goto LAB_00104a03;\n        }\n        if (DAT_0010b7e8 != 0) goto LAB_00104ae2;\nLAB_00104a11:\n        if (DAT_0010b808 == 0) {\n          if (DAT_0010b7d8 == 0) goto LAB_00104a2d;\n          val = (*(uint *)(ptr1 + 3) >> 7 ^ 1) & 1;\n          goto LAB_00104af9;\n        }\n        if ((((*(uint *)(ptr1 + 3) & 0x800082) == 0) && (ptr1[4] != 0x10c2a8)) &&\n           ((*(byte *)(ptr1[4] + 0x25) & 0x10) == 0)) goto LAB_001049c3;\nLAB_00104a2d:\n        if (DAT_0010b81c != 0) {\n          if (DAT_0010b7f8 == 0) goto LAB_00104a53;\nprocess_lto_object_00104d5b:\n          if ((ptr1[4] != 0x10c2a8) && (ptr1[4] != 0x10c3c0)) goto LAB_00104cba;\n          goto LAB_001049c3;\n        }\n      } while ((*(byte *)(ptr1 + 3) & 4) != 0);\n      if (DAT_0010b7f8 != 0) goto process_lto_object_00104d5b;\nLAB_00104a53:\n      nmemb = (undefined8 *)(ulong)DAT_0010b7e4;\n      if (DAT_0010b7e4 == 0) {\n        ch = (**(code **)(rbp[1] + 0x230))(rbp);\n        if (ch != '\\0') {\n          slim_lto_object_handler_00102c19();\n          return;\n        }\n        goto LAB_00104a7b;\n      }\n    } while (ptr1[4] == 0x10c2a8);\nLAB_00104cba:\n    ch = (**(code **)(rbp[1] + 0x230))(rbp);\n    if (ch != '\\0') {\n      slim_lto_object_handler_00102c19();\n      return;\n    }\n  } while( true );\ncode_r0x00104992:\n  ptr7 = (undefined8 *)((long)ptr8 * (long)ptr10);\n  ptr8 = (undefined8 *)((long)var3 + (long)ptr7);\n  dst = var3;\n  ptr4 = rbp;\n  if (var3 < ptr8) goto code_r0x001049aa;\n  goto LAB_00104b15;\ncode_r0x001049aa:\n  retaddr = (ulong)flag;\n  ptr9 = var3;\n  goto LAB_001049cf;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102c19",
            "calling": [
                "FUN_00104d5b"
            ],
            "imported": false,
            "current_name": "slim_lto_object_handler_00102c19"
        },
        "FUN_00106530": {
            "renaming": {
                "FUN_00106530": "handle_error_00106530",
                "in_R10": "additionalInfo",
                "iVar1": "errorCode",
                "uVar2": "errorMessage",
                "lVar3": "flag",
                "_stdout": "standardOutput",
                "_stderr": "standardError"
            },
            "code": "\n\n\nvoid handleError_00106530(void)\n\n{\n  int errorCode;\n  undefined8 errorMessage;\n  long flag;\n  undefined8 additionalInfo;\n  \n  print_error_message_00106540();\n  flag = 1;\n  xexit();\n  errorCode = bfd_get_error();\n  if (errorCode == 0) {\n    errorMessage = dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    errorMessage = bfd_errmsg(errorCode);\n  }\n  fflush(standardOutput);\n  if (flag != 0) {\n    fprintf(standardError,\"%s: %s: %s\\n\",DAT_0010b820,flag,errorMessage,additionalInfo);\n    return;\n  }\n  fprintf(standardError,\"%s: %s\\n\",DAT_0010b820,errorMessage,additionalInfo);\n  return;\n}\n\n",
            "called": [
                "xexit",
                "FUN_00106540"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00106530",
            "calling": [
                "FUN_00103c00",
                "FUN_00102f9f",
                "FUN_00102fd2",
                "FUN_00104d5b",
                "FUN_00105110",
                "FUN_00102fc3",
                "FUN_001048e0",
                "FUN_001043d0",
                "FUN_00103463"
            ],
            "imported": false,
            "current_name": "handle_error_00106530"
        },
        "FUN_00105560": {
            "renaming": {
                "FUN_00105560": "FUNC_00105560"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00105584) */\n/* WARNING: Removing unreachable block (ram,0x00105590) */\n\nvoid FUNC_00105560(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_registerTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00105560",
            "calling": [
                "_INIT_0"
            ],
            "imported": false,
            "current_name": "FUNC_00105560"
        },
        "qsort": {
            "renaming": {},
            "code": "\n\n\nvoid qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)\n\n{\n  qsort(__base,__nmemb,__size,__compar);\n  return;\n}\n\n",
            "called": [
                "qsort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020b0",
            "calling": [
                "FUN_00104d5b"
            ],
            "imported": false,
            "current_name": "qsort"
        },
        "fclose": {
            "renaming": {},
            "code": "\n\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fclose(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fclose"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102130",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "fclose"
        },
        "bfd_errmsg": {
            "renaming": {},
            "code": "\nvoid bfd_errmsg(void)\n\n{\n  bfd_errmsg();\n  return;\n}\n\n",
            "called": [
                "bfd_errmsg"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102390",
            "calling": [
                "FUN_001055f0",
                "FUN_00106540"
            ],
            "imported": false,
            "current_name": "bfd_errmsg"
        },
        "FUN_0010268b": {
            "renaming": {
                "FUN_0010268b": "reverse_and_print_string_0010268b",
                "puVar1": "pointer",
                "bVar2": "byte1",
                "bVar3": "byte2",
                "iVar4": "integer",
                "sVar5": "size",
                "puVar6": "output_pointer",
                "pcVar7": "temp_pointer",
                "uVar8": "ulong_var",
                "puVar10": "temp_pointer2",
                "puVar11": "input_pointer",
                "puVar12": "output",
                "unaff_R13": "input",
                "lVar13": "long_var",
                "bVar15": "byte_var",
                "__s": "temp_string",
                "in_stack_00000038": "stack_variable"
            },
            "code": "\n\n\nvoid reverse_and_print_string_0010268b(void)\n\n{\n  undefined8 *pointer;\n  byte byte1;\n  byte byte2;\n  int integer;\n  size_t size;\n  undefined8 *output_pointer;\n  char *temp_pointer;\n  ulong ulong_var;\n  undefined8 uVar9;\n  undefined *temp_pointer2;\n  undefined8 *input_pointer;\n  long unaff_RBP;\n  undefined8 *output;\n  undefined *unaff_R12;\n  undefined8 *input;\n  long long_var;\n  uint uVar14;\n  char *unaff_R14;\n  long unaff_R15;\n  byte byte_var;\n  char *temp_string;\n  undefined8 stack_variable;\n  \n  byte_var = 0;\n  output = input;\n  if (DAT_0010b7e0 != 0) {\n    do {\n      byte1 = *(byte *)output;\n      if (byte1 == 0) goto LAB_0010485e;\n    } while ((((&_sch_istable)[(ulong)byte1 * 2] & 2) == 0) &&\n            (output = (undefined8 *)((long)output + 1), byte1 < 0xc0));\n    size = strlen((char *)input);\n    output = DAT_0010b790;\n    input_pointer = input;\n    if (_DAT_0010b798 < size * 9) {\n      free(DAT_0010b790);\n      size = strlen((char *)input);\n      _DAT_0010b798 = size * 9;\n      DAT_0010b790 = (undefined8 *)xmalloc(_DAT_0010b798 + 1);\n      output = DAT_0010b790;\n    }\n    while( true ) {\n      input = DAT_0010b790;\n      byte1 = *(byte *)input_pointer;\n      pointer = (undefined8 *)((long)input_pointer + 1);\n      if (byte1 == 0) break;\n      if (((&_sch_istable)[(ulong)byte1 * 2] & 2) == 0) {\n        if ((byte1 < 0xc0) || (DAT_0010b7e0 == 0)) {\n          *(byte *)output = byte1;\n          output = (undefined8 *)((long)output + 1);\n          input_pointer = pointer;\n        }\n        else {\n          byte2 = *(byte *)((long)input_pointer + 1);\n          if ((byte2 & 0xc0) == 0x80) {\n            output_pointer = output;\n            if ((byte1 & 0x20) == 0) {\n              switch(DAT_0010b7e0) {\n              case 1:\n                uVar14 = 2;\n                goto LAB_00102a62;\n              case 3:\n              case 5:\n                long_var = 2;\n                goto LAB_00102917;\n              case 4:\n                integer = isatty(1);\n                if (integer == 0) {\n                  byte2 = *(byte *)((long)input_pointer + 1);\n                }\n                else {\n                  *(undefined *)(output + 1) = 0;\n                  *output = 0x6d37343b31335b1b;\n                  byte2 = *(byte *)((long)input_pointer + 1);\n                  output_pointer = output + 1;\n                }\n              case 2:\n                uVar14 = 2;\n                sprintf((char *)output_pointer,\"\\u%02x%02x\",(ulong)((int)(uint)*(byte *)input_pointer >> 2 & 7),\n                        (ulong)((*(byte *)input_pointer & 3) << 6 | byte2 & 0x3f));\n                output_pointer = (undefined8 *)((long)output_pointer + 6);\n                goto LAB_00102a27;\n              default:\n                uVar14 = 2;\n              }\n            }\n            else {\n              byte2 = *(byte *)((long)input_pointer + 2);\n              if ((byte2 & 0xc0) != 0x80) goto LAB_0010285d;\n              if ((byte1 & 0x10) == 0) {\n                switch(DAT_0010b7e0) {\n                case 1:\n                  uVar14 = 3;\nLAB_00102a62:\n                  for (ulong_var = (ulong)uVar14; ulong_var != 0; ulong_var = ulong_var - 1) {\n                    *(undefined *)output_pointer = *(undefined *)input_pointer;\n                    input_pointer = (undefined8 *)((long)input_pointer + (ulong)byte_var * -2 + 1);\n                    output_pointer = (undefined8 *)((long)output_pointer + (ulong)byte_var * -2 + 1);\n                  }\n                  break;\n                case 3:\n                case 5:\n                  long_var = 3;\nLAB_00102917:\n                  uVar9 = 0x7b;\n                  if (DAT_0010b7e0 == 3) {\n                    uVar9 = 0x3c;\n                  }\n                  sprintf((char *)output,\"%c\",uVar9);\n                  *(undefined *)((long)output + 3) = 0;\n                  output_pointer = (undefined8 *)(long_var + (long)input_pointer);\n                  *(undefined2 *)((long)output + 1) = 0x7830;\n                  temp_pointer = (char *)((long)output + 3);\n                  do {\n                    temp_string = temp_pointer;\n                    byte1 = *(byte *)input_pointer;\n                    input_pointer = (undefined8 *)((long)input_pointer + 1);\n                    sprintf(temp_string,\"%02x\",(ulong)byte1);\n                    temp_pointer = temp_string + 2;\n                  } while (input_pointer != output_pointer);\n                  uVar9 = 0x7d;\n                  if (DAT_0010b7e0 == 3) {\n                    uVar9 = 0x3e;\n                  }\n                  uVar14 = (uint)long_var;\n                  sprintf(temp_string + 2,\"%c\",uVar9);\n                  output_pointer = (undefined8 *)(temp_string + 3);\n                  break;\n                case 4:\n                  integer = isatty(1);\n                  if (integer == 0) {\n                    byte2 = *(byte *)((long)input_pointer + 2);\n                  }\n                  else {\n                    *(undefined *)(output + 1) = 0;\n                    *output = 0x6d37343b31335b1b;\n                    byte2 = *(byte *)((long)input_pointer + 2);\n                    output_pointer = output + 1;\n                  }\n                case 2:\n                  uVar14 = 3;\n                  sprintf((char *)output_pointer,\"\\u%02x%02x\",\n                          (ulong)((uint)(((ulong)*(byte *)input_pointer & 0xf) << 4) |\n                                 (int)(uint)*(byte *)((long)input_pointer + 1) >> 2 & 0xfU),\n                          (ulong)((*(byte *)((long)input_pointer + 1) & 3) << 6 | byte2 & 0x3f));\n                  output_pointer = (undefined8 *)((long)output_pointer + 6);\nLAB_00102a27:\n                  if ((DAT_0010b7e0 == 4) && (integer = isatty(1), integer != 0)) {\n                    *(undefined4 *)output_pointer = 0x6d305b1b;\n                    output_pointer = (undefined8 *)((long)output_pointer + 4);\n                    *(undefined *)output_pointer = 0;\n                  }\n                  break;\n                default:\n                  uVar14 = 3;\n                }\n              }\n              else {\n                if ((*(byte *)((long)input_pointer + 3) & 0xc0) != 0x80) goto LAB_0010285d;\n                switch(DAT_0010b7e0) {\n                case 1:\n                  uVar14 = 4;\n                  goto LAB_00102a62;\n                case 3:\n                case 5:\n                  long_var = 4;\n                  goto LAB_00102917;\n                case 4:\n                  integer = isatty(1);\n                  if (integer != 0) {\n                    *(undefined *)(output + 1) = 0;\n                    *output = 0x6d37343b31335b1b;\n                    output_pointer = output + 1;\n                  }\n                case 2:\n                  uVar14 = 4;\n                  integer = sprintf((char *)output_pointer,\"\\u%02x%02x%02x\",\n                                  (ulong)((*(byte *)input_pointer & 7) << 6 |\n                                         (int)(uint)*(byte *)((long)input_pointer + 1) >> 2 & 0xfU),\n                                  (ulong)((*(byte *)((long)input_pointer + 1) & 3) << 6 |\n                                         (int)(uint)*(byte *)((long)input_pointer + 2) >> 2 & 0xfU));\n                  output_pointer = (undefined8 *)((long)output_pointer + (long)integer);\n                  goto LAB_00102a27;\n                default:\n                  uVar14 = 4;\n                }\n              }\n            }\n            ulong_var = (ulong)(uint)((int)output_pointer - (int)output);\n          }\n          else {\nLAB_0010285d:\n            *(byte *)output = byte1;\n            uVar14 = 1;\n            ulong_var = 1;\n          }\n          output = (undefined8 *)((long)output + ulong_var);\n          input_pointer = (undefined8 *)((long)pointer + (ulong)(uVar14 - 1));\n        }\n      }\n      else {\n        *(undefined *)output = 0x5e;\n        *(byte *)((long)output + 1) = byte1 + 0x40;\n        output = (undefined8 *)((long)output + 2);\n        input_pointer = pointer;\n      }\n    }\n    *(undefined *)output = 0;\n  }\nLAB_0010485e:\n  output = (undefined8 *)0x0;\n  if ((((unaff_RBP != 0) && (*(long *)(unaff_RBP + 0x10) != 0)) && (DAT_0010b234 != 0)) &&\n     ((temp_pointer = (char *)(**(code **)(*(long *)(unaff_R15 + 8) + 0x220))\n                                  (unaff_R15,*(long *)(unaff_RBP + 0x10),0,\n                                   (long)&stack0x00000038 + 7), temp_pointer != (char *)0x0 &&\n      (*temp_pointer != '\\0')))) {\n    temp_pointer2 = &DAT_001071e0;\n    if ((stack_variable._7_1_ == '\\0') &&\n       (*(long *)(*(long *)(unaff_RBP + 0x10) + 0x20) != 0x10c2a8)) {\n      temp_pointer2 = &DAT_001071df;\n    }\n    output = (undefined8 *)reconcat(0,input,temp_pointer2,temp_pointer,0);\n    input = output;\n  }\n  printf(unaff_R14,input);\n  if (unaff_R12 != (undefined *)0x0) {\n    *unaff_R12 = 0x40;\n  }\n  free(output);\n  return;\n}\n\n",
            "called": [
                "sprintf",
                "isatty",
                "strlen",
                "free",
                "FUN_001047d0",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010268b",
            "calling": [
                "FUN_00102739"
            ],
            "imported": false,
            "current_name": "reverse_and_print_string_0010268b"
        },
        "FUN_00103bec": {
            "renaming": {
                "FUN_00103bec": "compare_and_return_error_code_00103bec",
                "in_RAX": "inputArgument",
                "iVar1": "comparisonResult",
                "auVar2": "returnValue"
            },
            "code": "\nundefined  [16] compareAndReturnErrorCode_00103bec(void)\n\n{\n  int comparisonResult;\n  undefined8 inputArgument;\n  undefined returnValue [16];\n  \n  comparisonResult = compare_binary_files_00105050();\n  returnValue._0_4_ = -comparisonResult;\n  returnValue._4_4_ = 0;\n  returnValue._8_8_ = inputArgument;\n  return returnValue;\n}\n\n",
            "called": [
                "FUN_00105050"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103bec",
            "calling": [],
            "imported": false,
            "current_name": "compare_and_return_error_code_00103bec"
        },
        "bfd_get_next_mapent": {
            "renaming": {},
            "code": "\nvoid bfd_get_next_mapent(void)\n\n{\n  bfd_get_next_mapent();\n  return;\n}\n\n",
            "called": [
                "bfd_get_next_mapent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102430",
            "calling": [
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "bfd_get_next_mapent"
        },
        "FUN_001063a0": {
            "renaming": {
                "FUN_001063a0": "print_error_message_001063a0",
                "param_1": "message",
                "param_2": "arguments"
            },
            "code": "\n\n\nvoid printErrorMessage_001063a0(char *message,__gnuc_va_list arguments)\n\n{\n  fflush(_stdout);\n  fprintf(_stderr,\"%s: \",DAT_0010b820);\n  vfprintf(_stderr,message,arguments);\n  putc(10,_stderr);\n  return;\n}\n\n",
            "called": [
                "fflush",
                "putc",
                "vfprintf",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001063a0",
            "calling": [
                "FUN_00106300",
                "FUN_00106400"
            ],
            "imported": false,
            "current_name": "print_error_message_001063a0"
        },
        "FUN_00102739": {
            "renaming": {
                "FUN_00102739": "print_decompiled_binary_00102739",
                "puVar1": "pointer1",
                "bVar2": "byte1",
                "bVar3": "byte2",
                "iVar4": "intVal",
                "sVar5": "size",
                "pcVar6": "charPtr1",
                "puVar7": "pointer2",
                "pcVar8": "charPtr2",
                "__ptr": "output",
                "uVar9": "ulongVal",
                "uVar10": "uVar",
                "puVar11": "pointer3",
                "unaff_RBP": "RBP",
                "puVar12": "pointer4",
                "unaff_R13": "R13",
                "lVar13": "longVal",
                "uVar14": "uintVal",
                "unaff_R14": "R14",
                "unaff_R15": "R15",
                "bVar15": "byte3",
                "__s": "stringPtr",
                "in_stack_00000038": "inStackVal"
            },
            "code": "\n\n\nvoid printDecompiledBinary_00102739(void)\n\n{\n  undefined8 *pointer1;\n  byte byte1;\n  byte byte2;\n  int intVal;\n  size_t size;\n  char *charPtr1;\n  undefined8 *pointer2;\n  char *charPtr2;\n  undefined8 *output;\n  ulong ulongVal;\n  undefined8 uVar;\n  undefined *pointer3;\n  long RBP;\n  undefined8 *pointer4;\n  undefined8 *R13;\n  long longVal;\n  uint uintVal;\n  char *R14;\n  long R15;\n  byte byte3;\n  char *stringPtr;\n  undefined8 inStackVal;\n  \n  byte3 = 0;\n  pointer4 = R13;\n  if (*(int *)(*(long *)(R15 + 8) + 8) != 5) {\n    if (DAT_0010b814 != 0) {\n      charPtr1 = (char *)0x0;\n      goto LAB_0010482b;\n    }\n    charPtr1 = (char *)0x0;\n    if (DAT_0010b7e0 == 0) {\nLAB_00104794:\n      output = (undefined8 *)0x0;\n    }\n    else {\n      output = (undefined8 *)0x0;\n      if (R13 != (undefined8 *)0x0) goto LAB_0010269d;\n      output = (undefined8 *)0x0;\n      R13 = (undefined8 *)0x1073a6;\n    }\n    goto joined_r0x00104799;\n  }\n  charPtr1 = strchr((char *)R13,0x40);\n  if (charPtr1 == (char *)0x0) {\n    if (DAT_0010b814 != 0) goto LAB_0010482b;\n    if (DAT_0010b7e0 == 0) {\n      if (RBP == 0) {\n        output = (undefined8 *)0x0;\n        printf(R14);\n      }\n      else {\n        if (*(long *)(RBP + 0x10) != 0) {\n          print_formatted_message_001047d0();\n          return;\n        }\n        output = (undefined8 *)0x0;\n        printf(R14);\n      }\n      goto LAB_001047ba;\n    }\nLAB_00102698:\n    pointer4 = R13;\n    output = (undefined8 *)0x0;\nLAB_0010269d:\n    do {\n      byte1 = *(byte *)pointer4;\n      if (byte1 == 0) goto joined_r0x00104799;\n    } while ((((&_sch_istable)[(ulong)byte1 * 2] & 2) == 0) &&\n            (pointer4 = (undefined8 *)((long)pointer4 + 1), byte1 < 0xc0));\n    size = strlen((char *)R13);\n    pointer4 = DAT_0010b790;\n    if (_DAT_0010b798 < size * 9) {\n      free(DAT_0010b790);\n      size = strlen((char *)R13);\n      _DAT_0010b798 = size * 9;\n      DAT_0010b790 = (undefined8 *)xmalloc(_DAT_0010b798 + 1);\n      pointer4 = DAT_0010b790;\n    }\n    while( true ) {\n      pointer2 = DAT_0010b790;\n      byte1 = *(byte *)R13;\n      pointer1 = (undefined8 *)((long)R13 + 1);\n      if (byte1 == 0) break;\n      if (((&_sch_istable)[(ulong)byte1 * 2] & 2) == 0) {\n        if ((byte1 < 0xc0) || (DAT_0010b7e0 == 0)) {\n          *(byte *)pointer4 = byte1;\n          pointer4 = (undefined8 *)((long)pointer4 + 1);\n          R13 = pointer1;\n        }\n        else {\n          byte2 = *(byte *)((long)R13 + 1);\n          if ((byte2 & 0xc0) == 0x80) {\n            pointer2 = pointer4;\n            if ((byte1 & 0x20) == 0) {\n              switch(DAT_0010b7e0) {\n              case 1:\n                uintVal = 2;\n                goto LAB_00102a62;\n              case 3:\n              case 5:\n                longVal = 2;\n                goto LAB_00102917;\n              case 4:\n                intVal = isatty(1);\n                if (intVal == 0) {\n                  byte2 = *(byte *)((long)R13 + 1);\n                }\n                else {\n                  *(undefined *)(pointer4 + 1) = 0;\n                  *pointer4 = 0x6d37343b31335b1b;\n                  byte2 = *(byte *)((long)R13 + 1);\n                  pointer2 = pointer4 + 1;\n                }\n              case 2:\n                uintVal = 2;\n                sprintf((char *)pointer2,\"\\u%02x%02x\",(ulong)((int)(uint)*(byte *)R13 >> 2 & 7)\n                        ,(ulong)((*(byte *)R13 & 3) << 6 | byte2 & 0x3f));\n                pointer2 = (undefined8 *)((long)pointer2 + 6);\n                goto LAB_00102a27;\n              default:\n                uintVal = 2;\n              }\n            }\n            else {\n              byte2 = *(byte *)((long)R13 + 2);\n              if ((byte2 & 0xc0) != 0x80) goto LAB_0010285d;\n              if ((byte1 & 0x10) == 0) {\n                switch(DAT_0010b7e0) {\n                case 1:\n                  uintVal = 3;\nLAB_00102a62:\n                  for (ulongVal = (ulong)uintVal; ulongVal != 0; ulongVal = ulongVal - 1) {\n                    *(undefined *)pointer2 = *(undefined *)R13;\n                    R13 = (undefined8 *)((long)R13 + (ulong)byte3 * -2 + 1);\n                    pointer2 = (undefined8 *)((long)pointer2 + (ulong)byte3 * -2 + 1);\n                  }\n                  break;\n                case 3:\n                case 5:\n                  longVal = 3;\nLAB_00102917:\n                  uVar = 0x7b;\n                  if (DAT_0010b7e0 == 3) {\n                    uVar = 0x3c;\n                  }\n                  sprintf((char *)pointer4,\"%c\",uVar);\n                  *(undefined *)((long)pointer4 + 3) = 0;\n                  pointer2 = (undefined8 *)(longVal + (long)R13);\n                  *(undefined2 *)((long)pointer4 + 1) = 0x7830;\n                  charPtr2 = (char *)((long)pointer4 + 3);\n                  do {\n                    stringPtr = charPtr2;\n                    byte1 = *(byte *)R13;\n                    R13 = (undefined8 *)((long)R13 + 1);\n                    sprintf(stringPtr,\"%02x\",(ulong)byte1);\n                    charPtr2 = stringPtr + 2;\n                  } while (R13 != pointer2);\n                  uVar = 0x7d;\n                  if (DAT_0010b7e0 == 3) {\n                    uVar = 0x3e;\n                  }\n                  uintVal = (uint)longVal;\n                  sprintf(stringPtr + 2,\"%c\",uVar);\n                  pointer2 = (undefined8 *)(stringPtr + 3);\n                  break;\n                case 4:\n                  intVal = isatty(1);\n                  if (intVal == 0) {\n                    byte2 = *(byte *)((long)R13 + 2);\n                  }\n                  else {\n                    *(undefined *)(pointer4 + 1) = 0;\n                    *pointer4 = 0x6d37343b31335b1b;\n                    byte2 = *(byte *)((long)R13 + 2);\n                    pointer2 = pointer4 + 1;\n                  }\n                case 2:\n                  uintVal = 3;\n                  sprintf((char *)pointer2,\"\\u%02x%02x\",\n                          (ulong)((uint)(((ulong)*(byte *)R13 & 0xf) << 4) |\n                                 (int)(uint)*(byte *)((long)R13 + 1) >> 2 & 0xfU),\n                          (ulong)((*(byte *)((long)R13 + 1) & 3) << 6 | byte2 & 0x3f));\n                  pointer2 = (undefined8 *)((long)pointer2 + 6);\nLAB_00102a27:\n                  if ((DAT_0010b7e0 == 4) && (intVal = isatty(1), intVal != 0)) {\n                    *(undefined4 *)pointer2 = 0x6d305b1b;\n                    pointer2 = (undefined8 *)((long)pointer2 + 4);\n                    *(undefined *)pointer2 = 0;\n                  }\n                  break;\n                default:\n                  uintVal = 3;\n                }\n              }\n              else {\n                if ((*(byte *)((long)R13 + 3) & 0xc0) != 0x80) goto LAB_0010285d;\n                switch(DAT_0010b7e0) {\n                case 1:\n                  uintVal = 4;\n                  goto LAB_00102a62;\n                case 3:\n                case 5:\n                  longVal = 4;\n                  goto LAB_00102917;\n                case 4:\n                  intVal = isatty(1);\n                  if (intVal != 0) {\n                    *(undefined *)(pointer4 + 1) = 0;\n                    *pointer4 = 0x6d37343b31335b1b;\n                    pointer2 = pointer4 + 1;\n                  }\n                case 2:\n                  uintVal = 4;\n                  intVal = sprintf((char *)pointer2,\"\\u%02x%02x%02x\",\n                                  (ulong)((*(byte *)R13 & 7) << 6 |\n                                         (int)(uint)*(byte *)((long)R13 + 1) >> 2 & 0xfU),\n                                  (ulong)((*(byte *)((long)R13 + 1) & 3) << 6 |\n                                         (int)(uint)*(byte *)((long)R13 + 2) >> 2 & 0xfU));\n                  pointer2 = (undefined8 *)((long)pointer2 + (long)intVal);\n                  goto LAB_00102a27;\n                default:\n                  uintVal = 4;\n                }\n              }\n            }\n            ulongVal = (ulong)(uint)((int)pointer2 - (int)pointer4);\n          }\n          else {\nLAB_0010285d:\n            *(byte *)pointer4 = byte1;\n            uintVal = 1;\n            ulongVal = 1;\n          }\n          pointer4 = (undefined8 *)((long)pointer4 + ulongVal);\n          R13 = (undefined8 *)((long)pointer1 + (ulong)(uintVal - 1));\n        }\n      }\n      else {\n        *(undefined *)pointer4 = 0x5e;\n        *(byte *)((long)pointer4 + 1) = byte1 + 0x40;\n        pointer4 = (undefined8 *)((long)pointer4 + 2);\n        R13 = pointer1;\n      }\n    }\n    *(undefined *)pointer4 = 0;\n    R13 = pointer2;\n  }\n  else {\n    *charPtr1 = '\\0';\n    if (DAT_0010b814 == 0) {\n      if (DAT_0010b7e0 == 0) goto LAB_00104794;\n      output = (undefined8 *)0x0;\n      goto LAB_0010269d;\n    }\nLAB_0010482b:\n    if ((*(char *)R13 == '\\0') ||\n       (pointer4 = (undefined8 *)bfd_demangle(), pointer4 == (undefined8 *)0x0)) {\n      if (DAT_0010b7e0 != 0) goto LAB_00102698;\n      output = (undefined8 *)0x0;\n    }\n    else {\n      R13 = pointer4;\n      output = pointer4;\n      if (DAT_0010b7e0 != 0) goto LAB_0010269d;\n    }\n  }\njoined_r0x00104799:\n  if ((((RBP != 0) && (*(long *)(RBP + 0x10) != 0)) && (DAT_0010b234 != 0)) &&\n     ((charPtr2 = (char *)(**(code **)(*(long *)(R15 + 8) + 0x220))\n                                  (R15,*(long *)(RBP + 0x10),0,\n                                   (long)&stack0x00000038 + 7), charPtr2 != (char *)0x0 &&\n      (*charPtr2 != '\\0')))) {\n    pointer3 = &DAT_001071e0;\n    if ((inStackVal._7_1_ == '\\0') &&\n       (*(long *)(*(long *)(RBP + 0x10) + 0x20) != 0x10c2a8)) {\n      pointer3 = &DAT_001071df;\n    }\n    output = (undefined8 *)reconcat(output,R13,pointer3,charPtr2,0);\n    R13 = output;\n  }\n  printf(R14,R13);\n  if (charPtr1 != (char *)0x0) {\n    *charPtr1 = '@';\n  }\nLAB_001047ba:\n  free(output);\n  return;\n}\n\n",
            "called": [
                "printf",
                "bfd_demangle",
                "strchr",
                "FUN_001047d0",
                "FUN_0010268b"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102739",
            "calling": [
                "FUN_00104740"
            ],
            "imported": false,
            "current_name": "print_decompiled_binary_00102739"
        },
        "FUN_00105050": {
            "renaming": {
                "FUN_00105050": "compare_binary_files_00105050",
                "param_1": "file1",
                "param_2": "file2",
                "__s": "string1",
                "__s_00": "string2",
                "lVar3": "file1_address",
                "uVar2": "file2_address",
                "sVar5": "string1_length",
                "sVar6": "string2_length",
                "pcVar7": "substring1",
                "pcVar8": "substring2",
                "lVar9": "file1_result",
                "lVar10": "file2_result",
                "uVar11": "comparison_result",
                "uVar12": "address1_calculated",
                "uVar13": "address2_calculated",
                "uVar14": "address1_plus_length",
                "uVar15": "data",
                "unaff_R13": "file2_address_copy",
                "bVar16": "flag",
                "uVar4": "flag2"
            },
            "code": "\nulong compareBinaryFiles_00105050(undefined8 file1,undefined8 file2)\n\n{\n  char cVar1;\n  ulong file2_address;\n  char *string1;\n  char *string2;\n  long file1_address;\n  uint flag2;\n  size_t string1_length;\n  size_t string2_length;\n  char *substring1;\n  char *substring2;\n  long file1_result;\n  long file2_result;\n  ulong comparison_result;\n  ulong address1_calculated;\n  ulong address2_calculated;\n  ulong address1_plus_length;\n  undefined8 data;\n  long file2_address_copy;\n  bool flag;\n  \n  file1_result = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,DAT_0010b778,file1,DAT_0010b770);\n  comparison_result = (ulong)DAT_0010b778;\n  file2_result = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,comparison_result,file2,DAT_0010b768);\n  if ((file1_result != 0) && (file2_result != 0)) {\n    file1_address = *(long *)(file2_result + 0x20);\n    if (*(long *)(file1_result + 0x20) == 0x10c2a8) {\n      comparison_result = 0xffffffff;\n      if (file1_address == 0x10c2a8) {\nLAB_001050fa:\n        comparison_result = compare_strings_00104fa0(file1,file2);\n        return comparison_result;\n      }\n    }\n    else if (file1_address == 0x10c2a8) {\n      comparison_result = 1;\n    }\n    else {\n      address2_calculated = *(long *)(file1_result + 0x10) + *(long *)(*(long *)(file1_result + 0x20) + 0x30);\n      comparison_result = *(long *)(file2_result + 0x10) + *(long *)(file1_address + 0x30);\n      if (address2_calculated == comparison_result) goto LAB_001050fa;\n      comparison_result = (ulong)(-(uint)(address2_calculated < comparison_result) | 1);\n    }\n    return comparison_result;\n  }\n  data = *DAT_0010b780;\n  handle_error_00106530();\n  file1_result = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,DAT_0010b778,data,DAT_0010b770);\n  file2_result = (**(code **)(DAT_0010b780[1] + 0x270))(DAT_0010b780,DAT_0010b778,comparison_result,DAT_0010b768);\n  if ((file1_result == 0) || (file2_address_copy = file2_result, file2_result == 0)) {\n    file2_result = handle_error_00106530(*DAT_0010b780);\n  }\n  if ((*(long *)(file1_result + 0x20) == 0x10c2a8) || (*(long *)(file2_result + 0x20) == 0x10c2a8)) {\n                    \n    abort();\n  }\n  address2_calculated = *(ulong *)(*(long *)(file1_result + 0x20) + 0x30);\n  file2_address = *(ulong *)(*(long *)(file2_result + 0x20) + 0x30);\n  address1_plus_length = *(long *)(file1_result + 0x10) + address2_calculated;\n  address1_calculated = *(long *)(file2_address_copy + 0x10) + file2_address;\n  flag = address1_plus_length < address1_calculated;\n  if ((address1_plus_length != address1_calculated) || (flag = address2_calculated < file2_address, address2_calculated != file2_address)) {\n    return (ulong)(-(uint)flag | 1);\n  }\n  string1 = *(char **)(file1_result + 8);\n  string2 = *(char **)(file2_address_copy + 8);\n  string1_length = strlen(string1);\n  string2_length = strlen(string2);\n  substring1 = strstr(string1,\"gnu_compiled\");\n  if (substring1 == (char *)0x0) {\n    substring2 = strstr(string1,\"gcc2_compiled\");\n    substring1 = strstr(string2,\"gnu_compiled\");\n    if ((substring1 == (char *)0x0) && (substring1 = strstr(string2,\"gcc2_compiled\"), substring1 == (char *)0x0))\n    goto joined_r0x00103157;\n    if (substring2 == (char *)0x0) {\n      return 1;\n    }\n  }\n  else {\n    substring1 = strstr(string2,\"gnu_compiled\");\n    if (substring1 == (char *)0x0) {\n      substring2 = strstr(string2,\"gcc2_compiled\");\njoined_r0x00103157:\n      if (substring2 != (char *)0x0) {\n        return 0xffffffff;\n      }\n    }\n  }\n  flag2 = *(uint *)(file2_address_copy + 0x18) & 0x4000;\n  if ((*(byte *)(file1_result + 0x19) & 0x40) == 0) {\n    if ((string1_length < 3) || (string1[string1_length - 2] != '.')) {\n      if (flag2 != 0) {\n        return 1;\n      }\n      if ((string2_length < 3) || (string2[string2_length - 2] != '.')) goto LAB_00103202;\n      flag = false;\n      goto LAB_001031e7;\n    }\n    cVar1 = string1[string1_length - 1];\n    flag = cVar1 == 'o' || cVar1 == 'a';\n    if (flag2 == 0) {\n      if ((string2_length < 3) || (string2[string2_length - 2] != '.')) {\n        if (cVar1 == 'o' || cVar1 == 'a') {\n          return 0xffffffff;\n        }\n        goto LAB_00103202;\n      }\n      goto LAB_001031e7;\n    }\n  }\n  else {\n    if (flag2 != 0) goto LAB_00103202;\n    if (string2_length < 3) {\n      return 0xffffffff;\n    }\n    if (string2[string2_length - 2] != '.') {\n      return 0xffffffff;\n    }\n    flag = true;\nLAB_001031e7:\n    if ((string2[string2_length - 1] != 'o') && (string2[string2_length - 1] != 'a')) {\n      if (flag) {\n        return 0xffffffff;\n      }\n      goto LAB_00103202;\n    }\n  }\n  if (!flag) {\n    return 1;\n  }\nLAB_00103202:\n  comparison_result = compare_strings_00104fa0(data,comparison_result);\n  return comparison_result;\n}\n\n",
            "called": [
                "FUN_00104fa0",
                "FUN_00102fc3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105050",
            "calling": [
                "FUN_00103bec"
            ],
            "imported": false,
            "current_name": "compare_binary_files_00105050"
        },
        "bfd_plugin_set_program_name": {
            "renaming": {},
            "code": "\nvoid bfd_plugin_set_program_name(void)\n\n{\n  bfd_plugin_set_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_plugin_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022a0",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "bfd_plugin_set_program_name"
        },
        "FUN_001049c0": {
            "renaming": {
                "FUN_001049c0": "process_lto_object_001049c0",
                "pcVar1": "moduleName",
                "pcVar2": "processFunc",
                "cVar3": "result",
                "iVar4": "comparisonResult",
                "uVar5": "isSlimLTO",
                "uVar6": "errorMessage",
                "lVar7": "tempLong",
                "puVar8": "tempPointer",
                "lVar9": "tempLong2",
                "puVar10": "tempPointer2",
                "puVar11": "funcReturnValue",
                "puVar12": "basePointer",
                "puVar13": "tempPointer3",
                "puVar14": "tempPointer4",
                "puVar15": "inputPointer",
                "unaff_RBX": "loopVariable",
                "unaff_RBP": "basePointer",
                "unaff_R12": "inputLength",
                "unaff_R13": "outputPointer",
                "unaff_R14": "loopStep",
                "unaff_R15": "outputPointer",
                "bVar16": "loopCondition",
                "bVar17": "loopStep",
                "unaff_retaddr": "loopCounter",
                "uVar18": "loopCounter",
                "in_stack_00000008": "extraData",
                "in_stack_00000010": "outputPointer",
                "in_stack_00000018": "loopCounter",
                "in_stack_00000038": "loopCounter",
                "in_stack_00000040": "tempPointer5",
                "in_stack_00000048": "loopCounter"
            },
            "code": "\nvoid processLTOObject_001049c0(void)\n\n{\n  char *moduleName;\n  code *processFunc;\n  char result;\n  int comparisonResult;\n  uint isSlimLTO;\n  undefined8 errorMessage;\n  long tempLong;\n  undefined8 *tempPointer;\n  long tempLong2;\n  undefined8 *tempPointer2;\n  undefined8 *loopVariable;\n  undefined8 *__ptr;\n  undefined8 *basePointer;\n  undefined8 *funcReturnValue;\n  undefined8 *basePointer;\n  undefined8 *in_R8;\n  undefined8 *tempPointer3;\n  undefined8 *in_R9;\n  undefined8 *tempPointer4;\n  undefined8 *inputPointer;\n  undefined8 *inputLength;\n  undefined8 *outputPointer;\n  undefined8 *loopStep;\n  undefined8 *outputPointer;\n  bool loopCondition;\n  byte loopStep;\n  ulong loopCounter;\n  ulong loopCounter;\n  undefined8 extraData;\n  undefined8 *outputPointer;\n  undefined8 *loopCounter;\n  undefined8 loopCounter;\n  void *tempPointer5;\n  undefined8 *loopCounter;\n  \n  loopStep = 0;\n  do {\n    loopVariable = (undefined8 *)((long)loopVariable + (long)loopStep);\nLAB_001049c3:\n    do {\n      do {\n        outputPointer = (undefined8 *)((long)outputPointer + (long)loopStep);\n        inputPointer = inputLength;\n        basePointer = basePointer;\n        if (inputLength <= outputPointer) goto LAB_00104b15;\nLAB_001049cf:\n        tempPointer = (undefined8 *)\n                 (**(code **)(basePointer[1] + 0x270))\n                           (basePointer,loopCounter & 0xffffffff,outputPointer,outputPointer);\n        funcReturnValue = basePointer;\n        basePointer = outputPointer;\n        inputPointer = outputPointer;\n        if (tempPointer == (undefined8 *)0x0) goto LAB_00102eb0;\n        moduleName = (char *)tempPointer[1];\n        if (((moduleName == (char *)0x0) || (*moduleName != '_')) || (moduleName[1] != '_')) {\nLAB_00104a03:\n          if (DAT_0010b7e8 == 0) goto LAB_00104a11;\nLAB_00104ae2:\n          isSlimLTO = (uint)(tempPointer[4] == 0x10c2a8);\nLAB_00104af9:\n          if (isSlimLTO != 0) goto LAB_00104a2d;\n          outputPointer = (undefined8 *)((long)outputPointer + (long)loopStep);\n          inputPointer = inputLength;\n          basePointer = basePointer;\n          if (inputLength <= outputPointer) {\nLAB_00104b15:\n            loopVariable = (undefined8 *)((long)loopVariable - (long)loopCounter);\n            if (loopStep == (undefined8 *)0x8) {\n              tempLong2 = basePointer[1];\n              funcReturnValue = (undefined8 *)((long)loopVariable + 7);\n              if (-1 < (long)loopVariable) {\n                funcReturnValue = loopVariable;\n              }\n              in_R8 = (undefined8 *)(ulong)DAT_0010b800;\n              processFunc = *(code **)(tempLong2 + 0x208);\n              funcReturnValue = (undefined8 *)((long)funcReturnValue >> 3);\n            }\n            else {\n              funcReturnValue = (undefined8 *)((long)loopVariable / (long)loopStep);\n              tempLong2 = basePointer[1];\n              processFunc = *(code **)(tempLong2 + 0x208);\n            }\n            basePointer = basePointer;\n            if (DAT_0010b800 == 0) {\n              DAT_0010b778 = DAT_0010b80c != 0;\n              DAT_0010b780 = basePointer;\n              DAT_0010b770 = (undefined8 *)(*processFunc)(basePointer);\n              DAT_0010b768 = (undefined8 *)(**(code **)(basePointer[1] + 0x208))(basePointer);\n              loopVariable = loopCounter;\n              if ((DAT_0010b770 == (undefined8 *)0x0) || (DAT_0010b768 == (undefined8 *)0x0)) {\n                handle_error_00106530(*basePointer);\n                __ptr = outputPointer;\n                goto LAB_00102d8e;\n              }\n              inputLength = (undefined8 *)(ulong)loopCounter._4_4_;\n              if (DAT_0010b7f8 != 0) {\n                loopCounter = (ulong)(DAT_0010b80c != 0);\n                qsort(loopCounter,(size_t)funcReturnValue,(size_t)inputLength,check_binary_compatibility_00102fd2);\n                inputPointer = (undefined8 *)xmalloc((long)funcReturnValue << 4);\n                tempPointer3 = DAT_0010b770;\n                basePointer = DAT_0010b768;\n                loopStep = (undefined8 *)((long)funcReturnValue * (long)inputLength + (long)loopVariable);\n                tempPointer = DAT_0010b770;\n                in_R9 = DAT_0010b768;\n                if (loopStep <= loopVariable) goto LAB_00102ec2;\n                funcReturnValue = (undefined8 *)\n                          (**(code **)(basePointer[1] + 0x270))(basePointer,loopCounter & 0xffffffff,loopVariable);\n                __ptr = loopVariable;\n                in_R8 = inputLength;\n                outputPointer = inputPointer;\n                if (funcReturnValue == (undefined8 *)0x0) goto LAB_00102eb9;\n                goto LAB_00104e35;\n              }\n              qsort(loopCounter,(size_t)funcReturnValue,(size_t)inputLength,\n                    (__compar_fn_t)(&PTR_FUN_0010acc0)[(long)DAT_0010b7f4 + (long)DAT_0010b7fc * 2])\n              ;\n              tempLong2 = basePointer[1];\n            }\n            __ptr = (undefined8 *)0x0;\n            do {\n              basePointer = loopCounter;\n              tempPointer = (undefined8 *)(ulong)DAT_0010b7f8;\n              loopStep = (undefined8 *)(ulong)(DAT_0010b80c != 0);\n              if (DAT_0010b7f8 != 0) {\n                inputPointer = (undefined8 *)(**(code **)(tempLong2 + 0x208))(basePointer);\n                if (inputPointer == (undefined8 *)0x0) goto LAB_00102ed2;\n                loopVariable = __ptr + (long)funcReturnValue * 2;\n                funcReturnValue = __ptr;\n                do {\n                  if (loopVariable <= funcReturnValue) {\nLAB_00104c75:\n                    if (tempPointer5 == (void *)0x0) {\n                      free(loopCounter);\n                      free(__ptr);\n                      return;\n                    }\n                    free(tempPointer5);\n                    free(loopCounter);\n                    free(__ptr);\n                    return;\n                  }\n                  tempPointer = inputPointer;\n                  tempLong2 = (**(code **)(basePointer[1] + 0x270))(basePointer,loopStep,*funcReturnValue);\n                  if (tempLong2 == 0) {\n                    handle_error_00106530(*basePointer,0);\nLAB_00102ed2:\n                    basePointer = (undefined8 *)*basePointer;\n                    handle_error_00106530();\n                    tempPointer3 = in_R8;\n                    tempPointer4 = in_R9;\n                    goto LAB_00102edb;\n                  }\n                  basePointer = funcReturnValue + 1;\n                  funcReturnValue = funcReturnValue + 2;\n                  print_params_and_update_table_00105110(basePointer,tempLong2,*basePointer,extraData);\n                } while( true );\n              }\n              inputLength = (undefined8 *)(ulong)loopCounter._4_4_;\n              outputPointer = (undefined8 *)(**(code **)(tempLong2 + 0x208))(basePointer);\n              if (outputPointer == (undefined8 *)0x0) {\n                handle_error_00106530(*basePointer);\n                basePointer = inputLength;\n                if (DAT_0010b80c == 0) {\n                  tempLong2 = (**(code **)(basePointer[1] + 0x350))(basePointer);\n                  funcReturnValue = loopCounter;\n                  inputPointer = inputLength;\n                  if (tempLong2 < 1) {\n                    tempPointer = (undefined8 *)0x0;\n                    loopVariable = (undefined8 *)0x0;\n                  }\n                  else {\nLAB_00102d8e:\n                    loopVariable = (undefined8 *)xmalloc();\n                    tempPointer = (undefined8 *)(**(code **)(basePointer[1] + 0x358))(basePointer,loopVariable);\n                    basePointer = inputPointer;\n                    if ((long)tempPointer < 0) {\n                      basePointer = (undefined8 *)*basePointer;\n                      funcReturnValue = (undefined8 *)handle_error_00106530(basePointer,inputPointer);\n                      goto LAB_00102dbe;\n                    }\n                  }\n                }\n                else {\n                  tempPointer = inputLength;\n                  loopVariable = loopCounter;\n                  funcReturnValue = (undefined8 *)0x0;\n                  inputPointer = (undefined8 *)0x0;\n                }\n                in_R9 = &stack0x00000040;\n                in_R8 = loopVariable;\n                tempLong2 = (**(code **)(basePointer[1] + 0x360))(basePointer,inputPointer,funcReturnValue,tempPointer);\n                inputLength = basePointer;\n                if (0 < tempLong2) {\n                  inputLength = (undefined8 *)((long)basePointer + tempLong2);\n                  loopCounter = (undefined8 *)xrealloc(loopCounter);\n                  tempLong = 0;\n                  do {\n                    loopCounter[(long)((long)basePointer + tempLong)] =\n                         (void *)(tempLong * 0x30 + (long)tempPointer5);\n                    tempLong = tempLong + 1;\n                  } while (tempLong2 != tempLong);\n                  loopCounter[(long)((long)basePointer + tempLong2)] = 0;\n                }\n                if ((DAT_0010b80c == 0) && (loopVariable != (undefined8 *)0x0)) {\n                  free(loopVariable);\n                }\n                if ((*(byte *)((long)basePointer + 0x4a) & 0x10) != 0) {\n                  loopVariable = (undefined8 *)*basePointer;\n                  DAT_0010b230 = '\\0';\n                  errorMessage = dcgettext(0,\"%s: plugin needed to handle lto object\",5);\n                  print_error_message_00106400(errorMessage);\n                }\n                loopStep = (undefined8 *)(ulong)loopCounter._4_4_;\n                loopCondition = DAT_0010b80c != 0;\n                funcReturnValue = (undefined8 *)(ulong)loopCondition;\n                tempPointer = loopCounter;\n                loopCounter = loopCounter;\n                outputPointer = (undefined8 *)(**(code **)(basePointer[1] + 0x208))(basePointer);\n                if (outputPointer != (undefined8 *)0x0) goto code_r0x00104992;\n              }\n              else {\n                funcReturnValue = (undefined8 *)((long)funcReturnValue * (long)inputLength + (long)basePointer);\n                loopVariable = basePointer;\n                while( true ) {\n                  if (funcReturnValue <= loopVariable) goto LAB_00104c75;\n                  tempPointer = outputPointer;\n                  tempLong2 = (**(code **)(basePointer[1] + 0x270))(basePointer,loopStep,loopVariable);\n                  if (tempLong2 == 0) break;\n                  loopVariable = (undefined8 *)((long)loopVariable + (long)inputLength);\n                  print_params_and_update_table_00105110(basePointer,tempLong2,0,extraData);\n                }\n                handle_error_00106530(*basePointer,0);\n              }\n              handle_error_00106530(*basePointer);\n              basePointer = basePointer;\n              inputPointer = outputPointer;\nLAB_00102eb0:\n              handle_error_00106530(*funcReturnValue);\nLAB_00102eb9:\n              handle_error_00106530(*basePointer);\nLAB_00102ec2:\n              funcReturnValue = (undefined8 *)0x0;\n              __ptr = loopVariable;\n              in_R8 = inputLength;\n              tempPointer3 = tempPointer;\n              basePointer = in_R9;\n              outputPointer = inputPointer;\nLAB_00104e35:\n              while (in_R9 = tempPointer3, __ptr < loopStep) {\n                loopVariable = (undefined8 *)((long)__ptr + (long)in_R8);\n                if (loopVariable < loopStep) {\n                  tempPointer = basePointer;\n                  tempPointer3 = in_R8;\n                  tempPointer4 = in_R9;\n                  tempPointer2 = (undefined8 *)(**(code **)(basePointer[1] + 0x270))();\n                  if (tempPointer2 == (undefined8 *)0x0) {\nLAB_00102edb:\n                    in_R9 = tempPointer4;\n                    in_R8 = tempPointer3;\n                    basePointer = (undefined8 *)*basePointer;\n                    tempPointer2 = (undefined8 *)handle_error_00106530();\n                  }\n                  else {\n                    tempPointer = (undefined8 *)funcReturnValue[4];\n                    if ((*(uint *)(funcReturnValue + 3) & 0x200100) == 0) goto LAB_00104e95;\n                  }\n                  tempLong2 = funcReturnValue[2];\nLAB_00102ee7:\n                  if (tempPointer == (undefined8 *)tempPointer2[4]) {\n                    tempLong2 = tempPointer2[2] - tempLong2;\n                    tempPointer3 = basePointer;\n                    tempPointer4 = __ptr;\n                    goto LAB_00104ea7;\n                  }\nLAB_00102dc4:\n                  tempLong2 = tempPointer[8] - tempLong2;\n                  tempPointer3 = basePointer;\n                  tempPointer4 = __ptr;\n                }\n                else {\n                  tempPointer = (undefined8 *)funcReturnValue[4];\n                  if ((*(uint *)(funcReturnValue + 3) & 0x200100) != 0) {\nLAB_00102dbe:\n                    tempLong2 = funcReturnValue[2];\n                    tempPointer2 = (undefined8 *)0x0;\n                    goto LAB_00102dc4;\n                  }\n                  tempPointer2 = (undefined8 *)0x0;\nLAB_00104e95:\n                  tempPointer3 = basePointer;\n                  tempPointer4 = __ptr;\n                  if (*(int *)(basePointer[1] + 8) == 5) {\n                    tempLong2 = funcReturnValue[7];\n                  }\n                  else {\n                    tempLong2 = funcReturnValue[2];\n                    if ((*(byte *)((long)tempPointer + 0x25) & 0x10) == 0) {\n                      if (loopVariable < loopStep) goto LAB_00102ee7;\n                      goto LAB_00102dc4;\n                    }\n                  }\n                }\nLAB_00104ea7:\n                funcReturnValue = tempPointer2;\n                __ptr = loopVariable;\n                basePointer = in_R9;\n                if (tempLong2 != 0) {\n                  *inputPointer = tempPointer4;\n                  inputPointer[1] = tempLong2;\n                  inputPointer = inputPointer + 2;\n                }\n              }\n              funcReturnValue = (undefined8 *)((long)inputPointer - (long)outputPointer >> 4);\n              qsort(outputPointer,(size_t)funcReturnValue,0x10,FUN_00103533);\n              tempLong2 = basePointer[1];\n              loopVariable = __ptr;\n              basePointer = basePointer;\n              __ptr = outputPointer;\n            } while( true );\n          }\n          goto LAB_001049cf;\n        }\n        comparisonResult = strcmp(moduleName + (moduleName[2] == '_'),\"__gnu_lto_slim\");\n        outputPointer = tempPointer;\n        if (comparisonResult == 0) {\n          if (DAT_0010b230 != '\\0') {\n            outputPointer = (undefined8 *)*basePointer;\n            DAT_0010b230 = '\\0';\n            errorMessage = dcgettext(0,\"%s: plugin needed to handle lto object\",5);\n            print_error_message_00106400(errorMessage,outputPointer);\n          }\n          goto LAB_00104a03;\n        }\n        if (DAT_0010b7e8 != 0) goto LAB_00104ae2;\nLAB_00104a11:\n        if (DAT_0010b808 == 0) {\n          if (DAT_0010b7d8 == 0) goto LAB_00104a2d;\n          isSlimLTO = (*(uint *)(tempPointer + 3) >> 7 ^ 1) & 1;\n          goto LAB_00104af9;\n        }\n        if ((((*(uint *)(tempPointer + 3) & 0x800082) == 0) && (tempPointer[4] != 0x10c2a8)) &&\n           ((*(byte *)(tempPointer[4] + 0x25) & 0x10) == 0)) goto LAB_001049c3;\nLAB_00104a2d:\n        if (DAT_0010b81c != 0) {\n          if (DAT_0010b7f8 == 0) goto LAB_00104a53;\nprocess_lto_object_00104d5b:\n          if ((tempPointer[4] != 0x10c2a8) && (tempPointer[4] != 0x10c3c0)) goto LAB_00104cba;\n          goto LAB_001049c3;\n        }\n      } while ((*(byte *)(tempPointer + 3) & 4) != 0);\n      if (DAT_0010b7f8 != 0) goto process_lto_object_00104d5b;\nLAB_00104a53:\n      in_R9 = (undefined8 *)(ulong)DAT_0010b7e4;\n      if (DAT_0010b7e4 == 0) {\n        result = (**(code **)(basePointer[1] + 0x230))(basePointer);\n        if (result != '\\0') {\n          FUN_00102c19();\n          return;\n        }\n        goto LAB_00104a7b;\n      }\n    } while (tempPointer[4] == 0x10c2a8);\nLAB_00104cba:\n    result = (**(code **)(basePointer[1] + 0x230))(basePointer);\n    if (result != '\\0') {\n      FUN_00102c19();\n      return;\n    }\nLAB_00104a7b:\n    if (loopVariable != outputPointer) {\n      if (loopStep == (undefined8 *)0x8) {\n        *loopVariable = *outputPointer;\n        processLTOObject_001049c0();\n        return;\n      }\n      for (; loopStep != (undefined8 *)0x0; loopStep = (undefined8 *)((long)loopStep + -1)) {\n        *(undefined *)loopVariable = *(undefined *)outputPointer;\n        outputPointer = (undefined8 *)((long)outputPointer + (ulong)loopStep * -2 + 1);\n        loopVariable = (undefined8 *)((long)loopVariable + (ulong)loopStep * -2 + 1);\n      }\n      processLTOObject_001049c0();\n      return;\n    }\n  } while( true );\ncode_r0x00104992:\n  inputPointer = (undefined8 *)((long)inputLength * (long)loopStep);\n  inputLength = (undefined8 *)((long)loopCounter + (long)inputPointer);\n  loopVariable = loopCounter;\n  basePointer = basePointer;\n  if (loopCounter < inputLength) goto code_r0x001049aa;\n  goto LAB_00104b15;\ncode_r0x001049aa:\n  loopCounter = (ulong)loopCondition;\n  outputPointer = loopCounter;\n  goto LAB_001049cf;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001049c0",
            "calling": [
                "FUN_00104d5b"
            ],
            "imported": false,
            "current_name": "process_lto_object_001049c0"
        },
        "FUN_00103ca0": {
            "renaming": {
                "FUN_00103ca0": "print_symbol_info_00103ca0",
                "param_1": "outputFile",
                "param_2": "exitCode",
                "lVar1": "targetString",
                "iVar2": "formatLength",
                "iVar3": "formatSymbolLength",
                "pcVar4": "formatString",
                "lVar5": "spaceCount",
                "sVar6": "symbolLength",
                "__ptr": "targetList",
                "plVar7": "targetListPtr",
                "ppcVar8": "demanglerPtr",
                "pcVar9": "separator",
                "local_3c": "localCounter"
            },
            "code": "\nvoid printSymbolInfo_00103ca0(FILE *outputFile,int exitCode)\n\n{\n  long targetString;\n  int formatLength;\n  int formatSymbolLength;\n  char *formatString;\n  long spaceCount;\n  size_t symbolLength;\n  long *targetList;\n  long *targetListPtr;\n  char **demanglerPtr;\n  char *separator;\n  uint localCounter;\n  \n  targetString = DAT_0010b820;\n  formatString = (char *)dcgettext(0,\"Usage: %s [option(s)] [file(s)]\\n\",5);\n  fprintf(outputFile,formatString,targetString);\n  formatString = (char *)dcgettext(0,\" List symbols in [file(s)] (a.out by default).\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\" The options are:\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  -a, --debug-syms       Display debugger-only symbols\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\n                             \"  -A, --print-file-name  Print name of the input file before every symbol\\n\"\n                             ,5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  -B                     Same as --format=bsd\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  -C, --demangle[=STYLE] Decode mangled/processed symbol names\\n\",5)\n  ;\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"                           STYLE can be \",5);\n  if (*formatString == ' ') {\n    targetString = 1;\n    do {\n      spaceCount = targetString;\n      targetString = spaceCount + 1;\n    } while (formatString[spaceCount] == ' ');\n    localCounter = (uint)spaceCount;\n  }\n  else {\n    localCounter = 0;\n  }\n  formatLength = fprintf(outputFile,\"%s\",formatString);\n  separator = \"\";\n  for (demanglerPtr = (char **)&libiberty_demanglers; *demanglerPtr != (char *)0x0; demanglerPtr = demanglerPtr + 3) {\n    symbolLength = strlen(*demanglerPtr);\n    if (0x4a < (long)formatLength + symbolLength) {\n      fprintf(outputFile,\"%.1s\\n\",separator);\n      separator = \"\";\n      formatLength = fprintf(outputFile,\"%.*s\",(ulong)localCounter,formatString);\n    }\n    formatSymbolLength = fprintf(outputFile,\"%s\\\"%s\\\"\",separator,*demanglerPtr);\n    formatLength = formatLength + formatSymbolLength;\n    separator = \", \";\n  }\n  fputc(10,outputFile);\n  formatString = (char *)dcgettext(0,\"      --no-demangle      Do not demangle low-level symbol names\\n\",5\n                            );\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\n                             \"      --recurse-limit    Enable a demangling recursion limit.  (default)\\n\"\n                             ,5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"      --no-recurse-limit Disable a demangling recursion limit.\\n\",5)\n  ;\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\n                             \"  -D, --dynamic          Display dynamic symbols instead of normal symbols\\n\"\n                             ,5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  -e                     (ignored)\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\n                             \"  -f, --format=FORMAT    Use the output format FORMAT.  FORMAT can be `bsd\\',\\n                           `sysv\\', `posix\\' or \\'just-symbols\\'.\\n                           The default is `bsd\\'\\n\"\n                             ,5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  -g, --extern-only      Display only external symbols\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\n                             \"    --ifunc-chars=CHARS  Characters to use when displaying ifunc symbols\\n\"\n                             ,5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  -j, --just-symbols     Same as --format=just-symbols\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\n                             \"  -l, --line-numbers     Use debugging information to find a filename and\\n                           line number for each symbol\\n\"\n                             ,5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  -n, --numeric-sort     Sort symbols numerically by address\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  -o                     Same as -A\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  -p, --no-sort          Do not sort the symbols\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  -P, --portability      Same as --format=posix\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  -r, --reverse-sort     Reverse the sense of the sort\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"      --plugin NAME      Load the specified plugin\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  -S, --print-size       Print size of defined symbols\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\n                             \"  -s, --print-armap      Include index for symbols from archive members\\n\"\n                             ,5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"      --quiet            Suppress \\\"no symbols\\\" diagnostic\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"      --size-sort        Sort symbols by size\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"      --special-syms     Include special symbols in the output\\n\",5)\n  ;\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"      --synthetic        Display synthetic symbols as well\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  -t, --radix=RADIX      Use RADIX for printing symbol values\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\n                             \"      --target=BFDNAME   Specify the target object format as BFDNAME\\n\"\n                             ,5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  -u, --undefined-only   Display only undefined symbols\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  -U, --defined-only     Display only defined symbols\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\n                             \"      --unicode={default|show|invalid|hex|escape|highlight}\\n                         Specify how to treat UTF-8 encoded unicode characters\\n\"\n                             ,5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  -W, --no-weak          Ignore weak symbols\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\n                             \"      --with-symbol-versions  Display version strings after symbol names\\n\"\n                             ,5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  -X 32_64               (ignored)\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  @FILE                  Read options from FILE\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  -h, --help             Display this information\\n\",5);\n  fprintf(outputFile,formatString);\n  formatString = (char *)dcgettext(0,\"  -V, --version          Display this program\\'s version number\\n\",5\n                            );\n  fprintf(outputFile,formatString);\n  targetString = DAT_0010b820;\n  if (DAT_0010b820 == 0) {\n    formatString = (char *)dcgettext(0,\"Supported targets:\",5);\n    fprintf(outputFile,formatString);\n  }\n  else {\n    formatString = (char *)dcgettext(0,\"%s: supported targets:\",5);\n    fprintf(outputFile,formatString,targetString);\n  }\n  targetList = (long *)bfd_target_list();\n  targetListPtr = targetList;\n  while( true ) {\n    targetString = *targetListPtr;\n    targetListPtr = targetListPtr + 1;\n    if (targetString == 0) break;\n    fprintf(outputFile,\" %s\");\n  }\n  fputc(10,outputFile);\n  free(targetList);\n  if (exitCode == 0) {\n    formatString = (char *)dcgettext(0,\"Report bugs to %s.\\n\",5);\n    fprintf(outputFile,formatString,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  exit(exitCode);\n}\n\n",
            "called": [
                "fseek",
                "bfd_target_list",
                "exit",
                "fprintf",
                "strlen",
                "dcgettext",
                "fputc",
                "free",
                "FUN_00102450"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103ca0",
            "calling": [
                "FUN_001055f0"
            ],
            "imported": false,
            "current_name": "print_symbol_info_00103ca0"
        },
        "FUN_00104d5b": {
            "renaming": {
                "FUN_00104d5b": "process_lto_object_00104d5b",
                "pcVar1": "ptr",
                "pcVar2": "func_ptr",
                "cVar3": "char_var",
                "iVar4": "int_var",
                "uVar5": "uint_var",
                "uVar6": "ulong_var",
                "puVar7": "ptr_var",
                "lVar8": "long_var",
                "lVar9": "var2",
                "param_7": "param_var",
                "param_8": "param_var",
                "param_9": "param_var",
                "param_13": "param_var",
                "param_14": "param_var",
                "in_RCX": "param_var",
                "in_R8": "param_var",
                "in_R9": "param_var",
                "unaff_RBX": "var3",
                "unaff_RBP": "var4",
                "unaff_R12": "var5",
                "unaff_R13": "var6",
                "unaff_R14": "var7",
                "unaff_R15": "var8",
                "bVar16": "bool_var",
                "bVar17": "byte_var",
                "unaff_retaddr": "ulong_var",
                "uVar18": "ulong_var",
                "__ptr": "ptr_var",
                "puVar10": "ptr_var",
                "puVar11": "ptr_var",
                "puVar12": "ptr_var",
                "puVar13": "ptr_var",
                "puVar14": "var9",
                "puVar15": "var10"
            },
            "code": "\nvoid process_lto_object_00104d5b(void)\n\n{\n  char *ptr;\n  code *func_ptr;\n  char char_var;\n  int int_var;\n  uint uint_var;\n  undefined8 ulong_var;\n  undefined8 *ptr_var;\n  long long_var;\n  long var2;\n  undefined8 *ptr_var;\n  undefined8 *param_var;\n  undefined8 *var3;\n  undefined8 *ptr_var;\n  undefined8 *ptr_var;\n  undefined8 *var4;\n  undefined8 *ptr_var;\n  undefined8 *param_var;\n  undefined8 *ptr_var;\n  undefined8 *param_var;\n  undefined8 *var9;\n  undefined8 *var10;\n  undefined8 *var5;\n  undefined8 *var6;\n  undefined8 *var7;\n  undefined8 *var8;\n  bool bool_var;\n  byte byte_var;\n  ulong ulong_var;\n  ulong ulong_var;\n  undefined8 param_var;\n  undefined8 *param_var;\n  undefined8 *param_var;\n  undefined8 in_stack_00000038;\n  void *param_var;\n  undefined8 *param_var;\n  \n  byte_var = 0;\n  do {\n    if ((param_var[4] != 0x10c2a8) && (param_var[4] != 0x10c3c0)) goto LAB_00104cba;\nLAB_001049c3:\n    do {\n      var6 = (undefined8 *)((long)var6 + (long)var7);\n      var10 = var5;\n      ptr_var = var4;\n      if (var5 <= var6) goto LAB_00104b15;\nLAB_001049cf:\n      param_var = (undefined8 *)\n               (**(code **)(var4[1] + 0x270))\n                         (var4,ulong_var & 0xffffffff,var6,var8);\n      ptr_var = var4;\n      ptr_var = var6;\n      var10 = var8;\n      if (param_var == (undefined8 *)0x0) goto LAB_00102eb0;\n      ptr = (char *)param_var[1];\n      if (((ptr == (char *)0x0) || (*ptr != '_')) || (ptr[1] != '_')) {\nLAB_00104a03:\n        if (DAT_0010b7e8 == 0) goto LAB_00104a11;\nLAB_00104ae2:\n        uint_var = (uint)(param_var[4] == 0x10c2a8);\nLAB_00104af9:\n        if (uint_var != 0) goto LAB_00104a2d;\n        var6 = (undefined8 *)((long)var6 + (long)var7);\n        var10 = var5;\n        ptr_var = var4;\n        if (var5 <= var6) {\nLAB_00104b15:\n          var3 = (undefined8 *)((long)var3 - (long)param_var);\n          if (var7 == (undefined8 *)0x8) {\n            var2 = ptr_var[1];\n            ptr_var = (undefined8 *)((long)var3 + 7);\n            if (-1 < (long)var3) {\n              ptr_var = var3;\n            }\n            param_var = (undefined8 *)(ulong)DAT_0010b800;\n            func_ptr = *(code **)(var2 + 0x208);\n            ptr_var = (undefined8 *)((long)ptr_var >> 3);\n          }\n          else {\n            ptr_var = (undefined8 *)((long)var3 / (long)var7);\n            var2 = ptr_var[1];\n            func_ptr = *(code **)(var2 + 0x208);\n          }\n          var4 = ptr_var;\n          if (DAT_0010b800 == 0) {\n            DAT_0010b778 = DAT_0010b80c != 0;\n            DAT_0010b780 = ptr_var;\n            DAT_0010b770 = (undefined8 *)(*func_ptr)(ptr_var);\n            DAT_0010b768 = (undefined8 *)(**(code **)(ptr_var[1] + 0x208))(ptr_var);\n            var3 = param_var;\n            if ((DAT_0010b770 == (undefined8 *)0x0) || (DAT_0010b768 == (undefined8 *)0x0)) {\n              handle_error_00106530(*ptr_var);\n              ptr_var = var8;\n              goto LAB_00102d8e;\n            }\n            var5 = (undefined8 *)(ulong)in_stack_00000038._4_4_;\n            if (DAT_0010b7f8 != 0) {\n              ulong_var = (ulong)(DAT_0010b80c != 0);\n              qsort(param_var,(size_t)ptr_var,(size_t)var5,check_binary_compatibility_00102fd2);\n              var10 = (undefined8 *)xmalloc((long)ptr_var << 4);\n              ptr_var = DAT_0010b770;\n              var4 = DAT_0010b768;\n              var7 = (undefined8 *)((long)ptr_var * (long)var5 + (long)var3);\n              param_var = DAT_0010b770;\n              param_var = DAT_0010b768;\n              if (var7 <= var3) goto LAB_00102ec2;\n              ptr_var = (undefined8 *)\n                        (**(code **)(ptr_var[1] + 0x270))(ptr_var,ulong_var & 0xffffffff,var3);\n              ptr_var = var3;\n              param_var = var5;\n              param_var = var10;\n              if (ptr_var == (undefined8 *)0x0) goto LAB_00102eb9;\n              goto LAB_00104e35;\n            }\n            qsort(param_var,(size_t)ptr_var,(size_t)var5,\n                  (__compar_fn_t)(&PTR_FUN_0010acc0)[(long)DAT_0010b7f4 + (long)DAT_0010b7fc * 2]);\n            var2 = ptr_var[1];\n          }\n          ptr_var = (undefined8 *)0x0;\n          do {\n            ptr_var = param_var;\n            ptr_var = (undefined8 *)(ulong)DAT_0010b7f8;\n            var7 = (undefined8 *)(ulong)(DAT_0010b80c != 0);\n            if (DAT_0010b7f8 != 0) {\n              var10 = (undefined8 *)(**(code **)(var2 + 0x208))(var4);\n              if (var10 == (undefined8 *)0x0) goto LAB_00102ed2;\n              var3 = ptr_var + (long)ptr_var * 2;\n              ptr_var = ptr_var;\n              do {\n                if (var3 <= ptr_var) {\nLAB_00104c75:\n                  if (param_var != (void *)0x0) {\n                    free(param_var);\n                    free(param_var);\n                    free(ptr_var);\n                    return;\n                  }\n                  free(param_var);\n                  free(ptr_var);\n                  return;\n                }\n                ptr_var = var10;\n                var2 = (**(code **)(var4[1] + 0x270))(var4,var7,*ptr_var);\n                if (var2 == 0) {\n                  handle_error_00106530(*var4,0);\nLAB_00102ed2:\n                  ptr_var = (undefined8 *)*var4;\n                  handle_error_00106530();\n                  ptr_var = param_var;\n                  var9 = param_var;\n                  goto LAB_00102edb;\n                }\n                ptr_var = ptr_var + 1;\n                ptr_var = ptr_var + 2;\n                print_params_and_update_table_00105110(var4,var2,*ptr_var,param_var);\n              } while( true );\n            }\n            var5 = (undefined8 *)(ulong)in_stack_00000038._4_4_;\n            var8 = (undefined8 *)(**(code **)(var2 + 0x208))(var4);\n            if (var8 == (undefined8 *)0x0) {\n              handle_error_00106530(*var4);\n              ptr_var = var5;\n              if (DAT_0010b80c == 0) {\n                var2 = (**(code **)(var4[1] + 0x350))(var4);\n                ptr_var = param_var;\n                var10 = var5;\n                if (var2 < 1) {\n                  ptr_var = (undefined8 *)0x0;\n                  var3 = (undefined8 *)0x0;\n                }\n                else {\nLAB_00102d8e:\n                  var3 = (undefined8 *)xmalloc();\n                  ptr_var = (undefined8 *)(**(code **)(var4[1] + 0x358))(var4,var3);\n                  ptr_var = var10;\n                  if ((long)ptr_var < 0) {\n                    ptr_var = (undefined8 *)*var4;\n                    ptr_var = (undefined8 *)handle_error_00106530(ptr_var,var10);\n                    goto LAB_00102dbe;\n                  }\n                }\n              }\n              else {\n                ptr_var = var5;\n                var3 = param_var;\n                ptr_var = (undefined8 *)0x0;\n                var10 = (undefined8 *)0x0;\n              }\n              param_var = &stack0x00000040;\n              param_var = var3;\n              var2 = (**(code **)(var4[1] + 0x360))(var4,var10,ptr_var,ptr_var);\n              var5 = ptr_var;\n              if (0 < var2) {\n                var5 = (undefined8 *)((long)ptr_var + var2);\n                param_var = (undefined8 *)xrealloc(param_var);\n                long_var = 0;\n                do {\n                  param_var[(long)ptr_var + long_var] = (void *)(long_var * 0x30 + (long)param_var);\n                  long_var = long_var + 1;\n                } while (var2 != long_var);\n                param_var[(long)ptr_var + var2] = 0;\n              }\n              if ((DAT_0010b80c == 0) && (var3 != (undefined8 *)0x0)) {\n                free(var3);\n              }\n              if ((*(byte *)((long)var4 + 0x4a) & 0x10) != 0) {\n                var3 = (undefined8 *)*var4;\n                DAT_0010b230 = '\\0';\n                ulong_var = dcgettext(0,\"%s: plugin needed to handle lto object\",5);\n                print_error_message_00106400(ulong_var);\n              }\n              var7 = (undefined8 *)(ulong)in_stack_00000038._4_4_;\n              bool_var = DAT_0010b80c != 0;\n              ptr_var = (undefined8 *)(ulong)bool_var;\n              param_var = param_var;\n              param_var = param_var;\n              var8 = (undefined8 *)(**(code **)(var4[1] + 0x208))(var4);\n              if (var8 != (undefined8 *)0x0) goto code_r0x00104992;\n            }\n            else {\n              ptr_var = (undefined8 *)((long)ptr_var * (long)var5 + (long)ptr_var);\n              var3 = ptr_var;\n              while( true ) {\n                if (ptr_var <= var3) goto LAB_00104c75;\n                param_var = var8;\n                var2 = (**(code **)(var4[1] + 0x270))(var4,var7,var3);\n                if (var2 == 0) break;\n                var3 = (undefined8 *)((long)var3 + (long)var5);\n                print_params_and_update_table_00105110(var4,var2,0,param_var);\n              }\n              handle_error_00106530(*var4,0);\n            }\n            handle_error_00106530(*var4);\n            ptr_var = var4;\n            var10 = var8;\nLAB_00102eb0:\n            handle_error_00106530(*ptr_var);\nLAB_00102eb9:\n            handle_error_00106530(*ptr_var);\nLAB_00102ec2:\n            ptr_var = (undefined8 *)0x0;\n            ptr_var = var3;\n            param_var = var5;\n            ptr_var = param_var;\n            var4 = param_var;\n            param_var = var10;\nLAB_00104e35:\n            while (param_var = ptr_var, ptr_var < var7) {\n              var3 = (undefined8 *)((long)ptr_var + (long)param_var);\n              if (var3 < var7) {\n                ptr_var = var4;\n                ptr_var = param_var;\n                var9 = param_var;\n                ptr_var = (undefined8 *)(**(code **)(ptr_var[1] + 0x270))();\n                if (ptr_var == (undefined8 *)0x0) {\nLAB_00102edb:\n                  param_var = var9;\n                  param_var = ptr_var;\n                  ptr_var = (undefined8 *)*ptr_var;\n                  ptr_var = (undefined8 *)handle_error_00106530();\n                }\n                else {\n                  ptr_var = (undefined8 *)ptr_var[4];\n                  if ((*(uint *)(ptr_var + 3) & 0x200100) == 0) goto LAB_00104e95;\n                }\n                var2 = ptr_var[2];\nLAB_00102ee7:\n                if (ptr_var == (undefined8 *)ptr_var[4]) {\n                  var2 = ptr_var[2] - var2;\n                  ptr_var = var4;\n                  var9 = ptr_var;\n                  goto LAB_00104ea7;\n                }\nLAB_00102dc4:\n                var2 = ptr_var[8] - var2;\n                ptr_var = var4;\n                var9 = ptr_var;\n              }\n              else {\n                ptr_var = (undefined8 *)ptr_var[4];\n                if ((*(uint *)(ptr_var + 3) & 0x200100) != 0) {\nLAB_00102dbe:\n                  var2 = ptr_var[2];\n                  ptr_var = (undefined8 *)0x0;\n                  goto LAB_00102dc4;\n                }\n                ptr_var = (undefined8 *)0x0;\nLAB_00104e95:\n                ptr_var = var4;\n                var9 = ptr_var;\n                if (*(int *)(ptr_var[1] + 8) == 5) {\n                  var2 = ptr_var[7];\n                }\n                else {\n                  var2 = ptr_var[2];\n                  if ((*(byte *)((long)ptr_var + 0x25) & 0x10) == 0) {\n                    if (var3 < var7) goto LAB_00102ee7;\n                    goto LAB_00102dc4;\n                  }\n                }\n              }\nLAB_00104ea7:\n              ptr_var = ptr_var;\n              ptr_var = var3;\n              var4 = param_var;\n              if (var2 != 0) {\n                *var10 = var9;\n                var10[1] = var2;\n                var10 = var10 + 2;\n              }\n            }\n            ptr_var = (undefined8 *)((long)var10 - (long)param_var >> 4);\n            qsort(param_var,(size_t)ptr_var,0x10,compare_and_call_00103533);\n            var2 = ptr_var[1];\n            var3 = ptr_var;\n            var4 = ptr_var;\n            ptr_var = param_var;\n          } while( true );\n        }\n        goto LAB_001049cf;\n      }\n      int_var = strcmp(ptr + (ptr[2] == '_'),\"__gnu_lto_slim\");\n      param_var = param_var;\n      if (int_var == 0) {\n        if (DAT_0010b230 != '\\0') {\n          param_var = (undefined8 *)*var4;\n          DAT_0010b230 = '\\0';\n          ulong_var = dcgettext(0,\"%s: plugin needed to handle lto object\",5);\n          print_error_message_00106400(ulong_var,param_var);\n        }\n        goto LAB_00104a03;\n      }\n      if (DAT_0010b7e8 != 0) goto LAB_00104ae2;\nLAB_00104a11:\n      if (DAT_0010b808 == 0) {\n        if (DAT_0010b7d8 == 0) goto LAB_00104a2d;\n        uint_var = (*(uint *)(param_var + 3) >> 7 ^ 1) & 1;\n        goto LAB_00104af9;\n      }\n      if ((((*(uint *)(param_var + 3) & 0x800082) == 0) && (param_var[4] != 0x10c2a8)) &&\n         ((*(byte *)(param_var[4] + 0x25) & 0x10) == 0)) goto LAB_001049c3;\nLAB_00104a2d:\n    } while ((DAT_0010b81c == 0) && ((*(byte *)(param_var + 3) & 4) != 0));\n  } while (DAT_0010b7f8 != 0);\n  param_var = (undefined8 *)(ulong)DAT_0010b7e4;\n  if (DAT_0010b7e4 == 0) {\n    char_var = (**(code **)(var4[1] + 0x230))(var4);\n    if (char_var != '\\0') {\n      slim_lto_object_handler_00102c19();\n      return;\n    }\n  }\n  else {\n    if (param_var[4] == 0x10c2a8) goto LAB_001049c3;\nLAB_00104cba:\n    char_var = (**(code **)(var4[1] + 0x230))(var4);\n    if (char_var != '\\0') {\n      slim_lto_object_handler_00102c19();\n      return;\n    }\n  }\n  if (var3 != var6) {\n    if (var7 != (undefined8 *)0x8) {\n      for (; var7 != (undefined8 *)0x0; var7 = (undefined8 *)((long)var7 + -1)) {\n        *(undefined *)var3 = *(undefined *)var6;\n        var6 = (undefined8 *)((long)var6 + (ulong)byte_var * -2 + 1);\n        var3 = (undefined8 *)((long)var3 + (ulong)byte_var * -2 + 1);\n      }\n      process_lto_object_00104d5b_001049c0();\n      return;\n    }\n    *var3 = *var6;\n    process_lto_object_00104d5b_001049c0();\n    return;\n  }\n  var3 = (undefined8 *)((long)var3 + (long)var7);\n  goto LAB_001049c3;\ncode_r0x00104992:\n  var10 = (undefined8 *)((long)var5 * (long)var7);\n  var5 = (undefined8 *)((long)param_var + (long)var10);\n  var3 = param_var;\n  ptr_var = var4;\n  if (param_var < var5) goto code_r0x001049aa;\n  goto LAB_00104b15;\ncode_r0x001049aa:\n  ulong_var = (ulong)bool_var;\n  var6 = param_var;\n  goto LAB_001049cf;\n}\n\n",
            "called": [
                "strcmp",
                "FUN_00102c19",
                "qsort",
                "FUN_001049c0",
                "FUN_00106530",
                "FUN_00104d5b",
                "FUN_00105110",
                "FUN_00103533",
                "FUN_00102fd2",
                "dcgettext",
                "free",
                "xrealloc",
                "FUN_00106400",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104d5b",
            "calling": [
                "FUN_00104d5b"
            ],
            "imported": false,
            "current_name": "process_lto_object_00104d5b"
        },
        "FUN_00106300": {
            "renaming": {
                "FUN_00106300": "print_error_and_exit_00106300",
                "param_1": "error_code",
                "param_2": "parameter_2",
                "param_3": "parameter_3",
                "param_4": "parameter_4",
                "param_5": "parameter_5",
                "param_6": "parameter_6",
                "param_7": "parameter_7",
                "param_8": "parameter_8",
                "param_9": "parameter_9",
                "param_10": "error_message",
                "param_11": "error_arg1",
                "param_12": "error_arg2",
                "param_13": "error_arg3",
                "param_14": "error_arg4",
                "in_AL": "input_flag",
                "__arg": "pointer_args",
                "__format": "format_string",
                "local_d8": "local_var1",
                "local_d4": "local_var2",
                "local_d0": "local_ptr1",
                "local_c8": "local_ptr2",
                "local_b8": "local_buffer",
                "local_b0": "local_arg1",
                "local_a8": "local_arg2",
                "local_a0": "local_arg3",
                "local_98": "local_arg4",
                "local_90": "local_arg5",
                "local_88": "local_var3",
                "local_78": "local_var4",
                "local_68": "local_var5",
                "local_58": "local_var6",
                "local_48": "local_var7",
                "local_38": "local_var8",
                "local_28": "local_var9",
                "local_18": "local_var10",
                "_stdout": "standard_output",
                "_stderr": "standard_error"
            },
            "code": "\n\n\nvoid print_error_and_exit_00106300(undefined4 error_code,undefined4 parameter_2,undefined4 parameter_3,undefined4 parameter_4,\n                 undefined4 parameter_5,undefined4 parameter_6,undefined4 parameter_7,undefined4 parameter_8,\n                 undefined8 parameter_9,undefined8 error_message,undefined8 error_arg1,undefined8 error_arg2,\n                 undefined8 error_arg3,undefined8 error_arg4)\n\n{\n  char input_flag;\n  undefined4 *pointer_args;\n  char *format_string;\n  undefined4 local_var1;\n  undefined4 local_var2;\n  undefined *local_ptr1;\n  undefined *local_ptr2;\n  undefined local_buffer [8];\n  undefined8 local_arg1;\n  undefined8 local_arg2;\n  undefined8 local_arg3;\n  undefined8 local_arg4;\n  undefined8 local_arg5;\n  undefined4 local_var3;\n  undefined4 local_var4;\n  undefined4 local_var5;\n  undefined4 local_var6;\n  undefined4 local_var7;\n  undefined4 local_var8;\n  undefined4 local_var9;\n  undefined4 local_var10;\n  \n  pointer_args = &local_var1;\n  if (input_flag != '\\0') {\n    local_var3 = error_code;\n    local_var4 = parameter_2;\n    local_var5 = parameter_3;\n    local_var6 = parameter_4;\n    local_var7 = parameter_5;\n    local_var8 = parameter_6;\n    local_var9 = parameter_7;\n    local_var10 = parameter_8;\n  }\n  local_ptr1 = &stack0x00000008;\n  local_var1 = 8;\n  local_ptr2 = local_buffer;\n  local_var2 = 0x30;\n  local_arg1 = error_message;\n  local_arg2 = error_arg1;\n  local_arg3 = error_arg2;\n  local_arg4 = error_arg3;\n  local_arg5 = error_arg4;\n  print_error_message_001063a0();\n  format_string = (char *)0x1;\n  xexit();\n  fflush(standard_output);\n  fprintf(standard_error,\"%s: \",DAT_0010b820);\n  vfprintf(standard_error,format_string,pointer_args);\n  putc(10,standard_error);\n  return;\n}\n\n",
            "called": [
                "FUN_001063a0",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00106300",
            "calling": [
                "FUN_001053c0",
                "FUN_00103729",
                "FUN_00104370",
                "FUN_001055f0",
                "FUN_0010370a"
            ],
            "imported": false,
            "current_name": "print_error_and_exit_00106300"
        },
        "FUN_00102f7b": {
            "renaming": {
                "FUN_00102f7b": "print_if_condition_met_00102f7b",
                "param_1": "message"
            },
            "code": "\n\n\nvoid print_if_condition_met_00102f7b(undefined8 message)\n\n{\n  if ((_DAT_0010b7c4 != 0) && (DAT_0010b818 == 0)) {\n    printf(\"%s:\\n\",message);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f7b",
            "calling": [],
            "imported": false,
            "current_name": "print_if_condition_met_00102f7b"
        },
        "FUN_00106540": {
            "renaming": {
                "FUN_00106540": "print_error_message_00106540",
                "param_1": "errorCode",
                "iVar1": "error",
                "uVar2": "errorMessage",
                "in_R10": "unusedVariable"
            },
            "code": "\n\n\nvoid printErrorMessage_00106540(long errorCode)\n\n{\n  int error;\n  undefined8 errorMessage;\n  undefined8 unusedVariable;\n  \n  error = bfd_get_error();\n  if (error == 0) {\n    errorMessage = dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    errorMessage = bfd_errmsg(error);\n  }\n  fflush(_stdout);\n  if (errorCode != 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",DAT_0010b820,errorCode,errorMessage,unusedVariable);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",DAT_0010b820,errorMessage,unusedVariable);\n  return;\n}\n\n",
            "called": [
                "FUN_00103a78",
                "fflush",
                "bfd_get_error",
                "bfd_errmsg",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00106540",
            "calling": [
                "FUN_00106530",
                "FUN_001043d0"
            ],
            "imported": false,
            "current_name": "print_error_message_00106540"
        }
    },
    "used_tokens": 73998,
    "layers": [
        [
            "FUN_00103b5d",
            "FUN_001036a7",
            "FUN_00102f19",
            "FUN_00103573",
            "FUN_00104397",
            "FUN_00104670",
            "FUN_00103a78",
            "FUN_00102020",
            "FUN_001062d0",
            "FUN_00103238",
            "FUN_001036e0",
            "FUN_001047d0",
            "FUN_001025f5",
            "FUN_00102670",
            "FUN_001064a0",
            "FUN_001053b0",
            "FUN_0010351b",
            "FUN_00103b2b",
            "FUN_00103533",
            "FUN_00103abf",
            "FUN_00102450",
            "FUN_00102c19",
            "FUN_0010268b",
            "FUN_001063a0",
            "FUN_001049c0",
            "FUN_00103ca0",
            "FUN_00102f7b",
            "FUN_00106540"
        ],
        [
            "FUN_00106400",
            "FUN_00106530",
            "FUN_00102739",
            "FUN_00106300"
        ],
        [
            "FUN_00103c00",
            "FUN_00104370",
            "FUN_00102f9f",
            "FUN_00103463",
            "FUN_0010249f",
            "FUN_00104fa0",
            "FUN_00104740"
        ],
        [
            "FUN_00102fc3",
            "FUN_00105110",
            "FUN_00102fd2",
            "FUN_00103b49",
            "FUN_00103bf6",
            "FUN_00105050"
        ],
        [
            "FUN_00103bec",
            "FUN_00104d5b"
        ],
        [
            "FUN_001048e0"
        ],
        [
            "FUN_001043d0"
        ],
        [
            "FUN_001055f0"
        ],
        [
            "FUN_001054d0"
        ],
        [
            "FUN_0010370a",
            "FUN_00103729",
            "FUN_001035a2",
            "FUN_0010651a"
        ],
        [
            "FUN_00103a66",
            "FUN_001053c0",
            "FUN_001064b0"
        ]
    ],
    "locked_functions": []
}