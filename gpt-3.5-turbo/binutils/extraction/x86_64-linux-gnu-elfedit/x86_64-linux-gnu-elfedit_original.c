
////>>0x00102000>>_init>>////

int _init(EVP_PKEY_CTX *ctx)

{
  int iVar1;
  
  iVar1 = __gmon_start__();
  return iVar1;
}


////>>0x00102020>>FUN_00102020>>////

void FUN_00102020(void)

{
                    /* WARNING: Treating indirect jump as call */
  (*(code *)(undefined *)0x0)();
  return;
}


////>>0x00102030>>free>>////



void free(void *__ptr)

{
  free(__ptr);
  return;
}


////>>0x00102040>>strcasecmp>>////



int strcasecmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcasecmp(__s1,__s2);
  return iVar1;
}


////>>0x00102050>>abort>>////



void abort(void)

{
                    
  abort();
}


////>>0x00102060>>__errno_location>>////



int * __errno_location(void)

{
  int *piVar1;
  
  piVar1 = __errno_location();
  return piVar1;
}


////>>0x00102070>>strncmp>>////



int strncmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = strncmp(__s1,__s2,__n);
  return iVar1;
}


////>>0x00102080>>ferror>>////



int ferror(FILE *__stream)

{
  int iVar1;
  
  iVar1 = ferror(__stream);
  return iVar1;
}


////>>0x00102090>>fread>>////



size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)

{
  size_t sVar1;
  
  sVar1 = fread(__ptr,__size,__n,__stream);
  return sVar1;
}


////>>0x001020a0>>textdomain>>////

void textdomain(void)

{
  textdomain();
  return;
}


////>>0x001020b0>>fclose>>////



int fclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fclose(__stream);
  return iVar1;
}


////>>0x001020c0>>bindtextdomain>>////

void bindtextdomain(void)

{
  bindtextdomain();
  return;
}


////>>0x001020d0>>dcgettext>>////

void dcgettext(void)

{
  dcgettext();
  return;
}


////>>0x001020e0>>strlen>>////



size_t strlen(char *__s)

{
  size_t sVar1;
  
  sVar1 = strlen(__s);
  return sVar1;
}


////>>0x001020f0>>mmap>>////



void * mmap(void *__addr,size_t __len,int __prot,int __flags,int __fd,__off_t __offset)

{
  void *pvVar1;
  
  pvVar1 = mmap(__addr,__len,__prot,__flags,__fd,__offset);
  return pvVar1;
}


////>>0x00102100>>getopt_long>>////

void getopt_long(void)

{
  getopt_long();
  return;
}


////>>0x00102110>>printf>>////



int printf(char *__format,...)

{
  int iVar1;
  
  iVar1 = printf(__format);
  return iVar1;
}


////>>0x00102120>>rewind>>////



void rewind(FILE *__stream)

{
  rewind(__stream);
  return;
}


////>>0x00102130>>snprintf>>////



int snprintf(char *__s,size_t __maxlen,char *__format,...)

{
  int iVar1;
  
  iVar1 = snprintf(__s,__maxlen,__format);
  return iVar1;
}


////>>0x00102140>>sbrk>>////



void * sbrk(intptr_t __delta)

{
  void *pvVar1;
  
  pvVar1 = sbrk(__delta);
  return pvVar1;
}


////>>0x00102150>>strcmp>>////



int strcmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcmp(__s1,__s2);
  return iVar1;
}


////>>0x00102160>>fprintf>>////



int fprintf(FILE *__stream,char *__format,...)

{
  int iVar1;
  
  iVar1 = fprintf(__stream,__format);
  return iVar1;
}


////>>0x00102170>>ftell>>////



long ftell(FILE *__stream)

{
  long lVar1;
  
  lVar1 = ftell(__stream);
  return lVar1;
}


////>>0x00102180>>stat>>////



int stat(char *__file,stat *__buf)

{
  int iVar1;
  
  iVar1 = stat(__file,__buf);
  return iVar1;
}


////>>0x00102190>>memcpy>>////



void * memcpy(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memcpy(__dest,__src,__n);
  return pvVar1;
}


////>>0x001021a0>>fileno>>////



int fileno(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fileno(__stream);
  return iVar1;
}


////>>0x001021b0>>malloc>>////



void * malloc(size_t __size)

{
  void *pvVar1;
  
  pvVar1 = malloc(__size);
  return pvVar1;
}


////>>0x001021c0>>fflush>>////



int fflush(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fflush(__stream);
  return iVar1;
}


////>>0x001021d0>>fseek>>////



int fseek(FILE *__stream,long __off,int __whence)

{
  int iVar1;
  
  iVar1 = fseek(__stream,__off,__whence);
  return iVar1;
}


////>>0x001021e0>>realloc>>////



void * realloc(void *__ptr,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = realloc(__ptr,__size);
  return pvVar1;
}


////>>0x001021f0>>munmap>>////



int munmap(void *__addr,size_t __len)

{
  int iVar1;
  
  iVar1 = munmap(__addr,__len);
  return iVar1;
}


////>>0x00102200>>setlocale>>////



char * setlocale(int __category,char *__locale)

{
  char *pcVar1;
  
  pcVar1 = setlocale(__category,__locale);
  return pcVar1;
}


////>>0x00102210>>memmove>>////



void * memmove(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memmove(__dest,__src,__n);
  return pvVar1;
}


////>>0x00102220>>fopen>>////



FILE * fopen(char *__filename,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fopen(__filename,__modes);
  return pFVar1;
}


////>>0x00102230>>vfprintf>>////



int vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)

{
  int iVar1;
  
  iVar1 = vfprintf(__s,__format,__arg);
  return iVar1;
}


////>>0x00102240>>strtoul>>////



ulong strtoul(char *__nptr,char **__endptr,int __base)

{
  ulong uVar1;
  
  uVar1 = strtoul(__nptr,__endptr,__base);
  return uVar1;
}


////>>0x00102250>>exit>>////



void exit(int __status)

{
                    
  exit(__status);
}


////>>0x00102260>>fwrite>>////



size_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)

{
  size_t sVar1;
  
  sVar1 = fwrite(__ptr,__size,__n,__s);
  return sVar1;
}


////>>0x00102270>>strdup>>////



char * strdup(char *__s)

{
  char *pcVar1;
  
  pcVar1 = strdup(__s);
  return pcVar1;
}


////>>0x00102280>>strerror>>////



char * strerror(int __errnum)

{
  char *pcVar1;
  
  pcVar1 = strerror(__errnum);
  return pcVar1;
}


////>>0x00102290>>fstat>>////



int fstat(int __fd,stat *__buf)

{
  int iVar1;
  
  iVar1 = fstat(__fd,__buf);
  return iVar1;
}


////>>0x001022a0>>getc>>////



int getc(FILE *__stream)

{
  int iVar1;
  
  iVar1 = getc(__stream);
  return iVar1;
}


////>>0x001022b0>>__cxa_finalize>>////

void __cxa_finalize(void)

{
  __cxa_finalize();
  return;
}


////>>0x001022c0>>elf_x86_feature.cold>>////

undefined  [16] elf_x86_feature_cold(void)

{
  int iVar1;
  uint uVar2;
  undefined8 uVar3;
  char *unaff_RBX;
  int unaff_EBP;
  undefined auVar4 [16];
  undefined8 unaff_retaddr;
  
  iVar1 = strcasecmp(unaff_RBX,"lam_u48");
  if (iVar1 == 0) {
    uVar2 = 4;
  }
  else {
    iVar1 = strcasecmp(unaff_RBX,"lam_u57");
    uVar2 = 8;
    if (iVar1 != 0) {
      uVar3 = dcgettext(0,"Unknown x86 feature: %s\n",5);
      error(uVar3);
      uVar3 = 0xffffffff;
      goto LAB_00104ca5;
    }
  }
  if (unaff_EBP == 0) {
    disable_x86_features = uVar2 | disable_x86_features;
    enable_x86_features = ~uVar2 & enable_x86_features;
  }
  else {
    enable_x86_features = uVar2 | enable_x86_features;
    disable_x86_features = disable_x86_features & ~uVar2;
  }
  uVar3 = 0;
LAB_00104ca5:
  auVar4._8_8_ = unaff_retaddr;
  auVar4._0_8_ = uVar3;
  return auVar4;
}


////>>0x00102323>>elf_osabi.cold>>////

undefined  [16] elf_osabi_cold(void)

{
  undefined8 uVar1;
  undefined auVar2 [16];
  undefined8 unaff_retaddr;
  
  uVar1 = dcgettext(0,"Unknown OSABI: %s\n",5);
  error(uVar1);
  auVar2._8_8_ = unaff_retaddr;
  auVar2._0_8_ = 0xffffffff;
  return auVar2;
}


////>>0x0010234b>>elf_machine.cold>>////

int elf_machine_cold(void)

{
  int iVar1;
  undefined8 uVar2;
  char *unaff_RBX;
  
  iVar1 = strcasecmp(unaff_RBX,"x86_64");
  if (iVar1 == 0) {
    iVar1 = 0x3e;
  }
  else {
    iVar1 = strcasecmp(unaff_RBX,"x86-64");
    if (iVar1 == 0) {
      iVar1 = 0x3e;
    }
    else {
      iVar1 = strcasecmp(unaff_RBX,"none");
      if (iVar1 != 0) {
        uVar2 = dcgettext(0,"Unknown machine type: %s\n",5);
        error(uVar2);
        iVar1 = -1;
      }
    }
  }
  return iVar1;
}


////>>0x001023ce>>elf_type.cold>>////

undefined8 elf_type_cold(void)

{
  return 1;
}


////>>0x00102434>>process_object.cold>>////

undefined8 process_object_cold(void)

{
  undefined8 uVar1;
  size_t sVar2;
  FILE *unaff_RBX;
  char *pcVar3;
  
  uVar1 = dcgettext(0,"%s: Failed to seek to ELF header\n",5);
  error(uVar1);
  if (elf_header[6] == '\x01') {
    if ((ushort)elf_header._58_2_ == output_elf_machine) {
      return 0;
    }
    if (input_elf_class == 0xffffffff) {
      if (elf_header._58_2_ == 6) {
        input_elf_class = 1;
      }
      else if ((ushort)elf_header._58_2_ < 7) {
        input_elf_class = (elf_header._58_2_ != 3) + 1 + (uint)(elf_header._58_2_ != 3);
      }
      else {
        input_elf_class = 3 - ((ushort)(elf_header._58_2_ - 0xb4) < 2);
      }
    }
    if ((elf_header[4] == input_elf_class) || (input_elf_class == 3)) {
      if ((elf_header[4] == output_elf_class) || (output_elf_class == 3)) {
        if (((ushort)elf_header._58_2_ == input_elf_machine) || (input_elf_machine == 0xffffffff)) {
          if ((input_elf_type == 0xffffffff) || ((ushort)elf_header._56_2_ == input_elf_type)) {
            if ((input_elf_osabi == 0xffffffff) || (elf_header[7] == input_elf_osabi)) {
              if ((elf_header[8] == input_elf_abiversion) || (input_elf_abiversion == 0xffffffff)) {
                if (elf_header[4] == 1) {
                  if (output_elf_machine != 0xffffffff) {
                    (*byte_put)(0x109392,(long)(int)output_elf_machine,2);
                  }
                  if (output_elf_type != -1) {
                    (*byte_put)(0x109390,(long)output_elf_type,2);
                  }
                  if (output_elf_osabi != -1) {
                    ehdr32[7] = (undefined)output_elf_osabi;
                  }
                  if (output_elf_abiversion != -1) {
                    ehdr32[8] = (undefined)output_elf_abiversion;
                  }
                  sVar2 = fwrite(ehdr32,0x34,1,unaff_RBX);
                  if (sVar2 == 1) {
                    return 0;
                  }
                  uVar1 = FUN_001024ec();
                  return uVar1;
                }
                if (elf_header[4] != 2) {
                    
                  abort();
                }
                if (output_elf_machine != 0xffffffff) {
                  (*byte_put)(0x109352,(long)(int)output_elf_machine,2);
                }
                if (output_elf_type != -1) {
                  (*byte_put)(0x109350,(long)output_elf_type,2);
                }
                if (output_elf_osabi != -1) {
                  ehdr64[7] = (undefined)output_elf_osabi;
                }
                if (output_elf_abiversion != -1) {
                  ehdr64[8] = (undefined)output_elf_abiversion;
                }
                sVar2 = fwrite(ehdr64,0x40,1,unaff_RBX);
                if (sVar2 == 1) {
                  return 0;
                }
                uVar1 = FUN_001024ec();
                return uVar1;
              }
              pcVar3 = "%s: Unmatched EI_ABIVERSION: %d is not %d\n";
            }
            else {
              pcVar3 = "%s: Unmatched EI_OSABI: %d is not %d\n";
            }
          }
          else {
            pcVar3 = "%s: Unmatched e_type: %d is not %d\n";
          }
        }
        else {
          pcVar3 = "%s: Unmatched e_machine: %d is not %d\n";
        }
        uVar1 = dcgettext(0,pcVar3,5);
        error(uVar1);
        return 1;
      }
      pcVar3 = "%s: Unmatched output EI_CLASS: %d is not %d\n";
    }
    else {
      pcVar3 = "%s: Unmatched input EI_CLASS: %d is not %d\n";
    }
    uVar1 = dcgettext(0,pcVar3,5);
    error(uVar1);
  }
  else {
    uVar1 = dcgettext(0,"%s: Unsupported EI_VERSION: %d is not %d\n",5);
    error(uVar1);
  }
  return 1;
}


////>>0x001024ec>>FUN_001024ec>>////

undefined8 FUN_001024ec(void)

{
  int *piVar1;
  undefined8 uVar2;
  
  piVar1 = __errno_location();
  strerror(*piVar1);
  uVar2 = dcgettext(0,"%s: Failed to update ELF header: %s\n",5);
  error(uVar2);
  return 1;
}


////>>0x00102558>>FUN_00102558>>////

undefined8 FUN_00102558(void)

{
  undefined8 uVar1;
  
  uVar1 = dcgettext(0,"%s: Failed to read ELF header\n",5);
  error(uVar1);
  return 1;
}


////>>0x001025ab>>setup_archive.constprop.0>>////

undefined4
setup_archive_constprop_0
          (char **param_1,char *param_2,FILE *param_3,long param_4,undefined4 param_5)

{
  char **__ptr;
  undefined uVar1;
  char cVar2;
  int iVar3;
  char *pcVar4;
  size_t sVar5;
  undefined8 uVar6;
  char *pcVar7;
  
  pcVar4 = strdup(param_2);
  param_1[2] = (char *)0x0;
  *(undefined4 *)((long)param_1 + 0x54) = 0;
  *param_1 = pcVar4;
  param_1[1] = (char *)param_3;
  param_1[5] = (char *)0x0;
  param_1[6] = (char *)0x0;
  *(undefined4 *)(param_1 + 10) = param_5;
  param_1[9] = (char *)0x8;
  *(undefined (*) [16])(param_1 + 3) = ZEXT816(0);
  *(undefined (*) [16])(param_1 + 7) = ZEXT816(0);
  iVar3 = fseek(param_3,8,0);
  pcVar4 = "%s: failed to seek to first archive header\n";
  if (iVar3 != 0) goto LAB_00102658;
  __ptr = param_1 + 0xb;
  sVar5 = fread(__ptr,1,0x3c,param_3);
  if (sVar5 != 0x3c) {
    if (sVar5 == 0) {
      return 0;
    }
    pcVar4 = "%s: failed to read archive header\n";
    goto LAB_00102658;
  }
  cVar2 = startswith(__ptr,"/               ");
  if (cVar2 == '\0') {
    cVar2 = startswith(__ptr,"/SYM64/         ");
    if (cVar2 != '\0') {
      *(undefined4 *)((long)param_1 + 0x54) = 1;
      iVar3 = process_archive_index_and_symbols_constprop_0(param_1,8);
      goto joined_r0x001026dd;
    }
  }
  else {
    iVar3 = process_archive_index_and_symbols_constprop_0(param_1,4);
joined_r0x001026dd:
    if (iVar3 == 0) {
      return 1;
    }
  }
  cVar2 = startswith(__ptr);
  if (cVar2 == '\0') {
    return 0;
  }
  uVar1 = *(undefined *)((long)param_1 + 0x92);
  *(undefined *)((long)param_1 + 0x92) = 0;
  pcVar4 = (char *)strtoul((char *)(param_1 + 0x11),(char **)0x0,10);
  pcVar7 = "%s: long name table is too small, (size = %ld)\n";
  param_1[7] = pcVar4;
  *(undefined *)((long)param_1 + 0x92) = uVar1;
  if ((char *)0x7 < pcVar4) {
    if (((long)pcVar4 <= param_4) && (-1 < (long)pcVar4)) {
      param_1[9] = pcVar4 + 0x3c + (long)param_1[9];
      pcVar7 = (char *)malloc((size_t)(pcVar4 + 1));
      param_1[6] = pcVar7;
      if (pcVar7 == (char *)0x0) {
        uVar6 = dcgettext(0,"Out of memory reading long symbol names in archive\n",5);
        error(uVar6);
        return 1;
      }
      sVar5 = fread(pcVar7,(size_t)pcVar4,1,param_3);
      if (sVar5 == 1) {
        if ((*(byte *)(param_1 + 7) & 1) != 0) {
          getc(param_3);
        }
        param_1[6][(long)param_1[7]] = '\0';
        return 0;
      }
      free(param_1[6]);
      pcVar4 = "%s: failed to read long symbol name string table\n";
      param_1[6] = (char *)0x0;
LAB_00102658:
      uVar6 = dcgettext(0,pcVar4,5);
      error(uVar6,param_2);
      return 1;
    }
    pcVar7 = "%s: long name table is too big, (size = %#lx)\n";
  }
  uVar6 = dcgettext(0,pcVar7,5);
  error(uVar6,param_2,pcVar4);
  return 1;
}


////>>0x001027fd>>startswith>>////

undefined  [16] startswith(char *param_1,char *param_2)

{
  int iVar1;
  undefined8 in_RAX;
  size_t __n;
  undefined4 extraout_var;
  undefined auVar2 [16];
  
  __n = strlen(param_2);
  iVar1 = strncmp(param_1,param_2,__n);
  auVar2._1_7_ = (undefined7)(CONCAT44(extraout_var,iVar1) >> 8);
  auVar2[0] = iVar1 == 0;
  auVar2._8_8_ = in_RAX;
  return auVar2;
}


////>>0x00102825>>byte_get_little_endian.cold>>////

void byte_get_little_endian_cold(long param_1,undefined8 param_2)

{
  FUN_00103ab3(param_1,param_2,
               (ulong)*(byte *)(param_1 + 1) << 8 | (ulong)*(byte *)(param_1 + 2) << 0x10);
  return;
}


////>>0x0010289a>>caseD_0>>////

void switchD_00103aac::caseD_0(void)

{
  undefined8 uVar1;
  undefined4 unaff_EBX;
  
  uVar1 = dcgettext(0,"Unhandled data length: %d\n",5);
  error(uVar1,unaff_EBX);
                    
  abort();
}


////>>0x001028be>>process_archive_index_and_symbols.constprop.0>>////

undefined8 process_archive_index_and_symbols_constprop_0(undefined8 *param_1)

{
  undefined uVar1;
  int iVar2;
  ulong uVar3;
  undefined8 uVar4;
  size_t sVar5;
  undefined8 uVar6;
  char *pcVar7;
  
  uVar1 = *(undefined *)((long)param_1 + 0x92);
  *(undefined *)((long)param_1 + 0x92) = 0;
  uVar3 = strtoul((char *)(param_1 + 0x11),(char **)0x0,10);
  *(undefined *)((long)param_1 + 0x92) = uVar1;
  if ((long)uVar3 < 0) {
    uVar6 = *param_1;
    uVar4 = dcgettext(0,"%s: invalid archive header size: %ld\n",5);
    error(uVar4,uVar6,uVar3);
  }
  else {
    uVar3 = uVar3 + 1 & 0xfffffffffffffffe;
    param_1[9] = uVar3 + 0x3c + param_1[9];
    iVar2 = fseek((FILE *)param_1[1],uVar3,1);
    if (iVar2 == 0) {
      sVar5 = fread(param_1 + 0xb,1,0x3c,(FILE *)param_1[1]);
      if ((sVar5 == 0x3c) || (sVar5 == 0)) {
        return 1;
      }
      uVar6 = *param_1;
      pcVar7 = "%s: failed to read archive header following archive index\n";
    }
    else {
      uVar6 = *param_1;
      pcVar7 = "%s: failed to skip archive symbol table\n";
    }
    uVar4 = dcgettext(0,pcVar7,5);
    error(uVar4,uVar6);
  }
  return 0;
}


////>>0x001029a5>>get_archive_member_name>>////

undefined4 * get_archive_member_name(undefined8 *param_1,char **param_2)

{
  undefined uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  int iVar6;
  ulong uVar7;
  ulong uVar8;
  ulong uVar9;
  undefined8 uVar10;
  FILE *__stream;
  size_t sVar11;
  undefined4 *puVar12;
  long lVar13;
  char *pcVar14;
  char *pcVar15;
  char *pcVar16;
  char *local_c0;
  stat local_b8;
  
  if (*(char *)(param_1 + 0xb) != '/') {
    lVar13 = 0;
    do {
      if (*(char *)((long)param_1 + lVar13 + 0x58) == '/') {
        *(undefined *)((long)param_1 + lVar13 + 0x58) = 0;
        puVar12 = (undefined4 *)xstrdup(param_1 + 0xb);
        return puVar12;
      }
      lVar13 = lVar13 + 1;
    } while (lVar13 != 0x10);
    puVar12 = (undefined4 *)xmalloc(0x11);
    uVar2 = *(undefined4 *)(param_1 + 0xb);
    uVar3 = *(undefined4 *)((long)param_1 + 0x5c);
    uVar4 = *(undefined4 *)(param_1 + 0xc);
    uVar5 = *(undefined4 *)((long)param_1 + 100);
    *(undefined *)(puVar12 + 4) = 0;
    *puVar12 = uVar2;
    puVar12[1] = uVar3;
    puVar12[2] = uVar4;
    puVar12[3] = uVar5;
    return puVar12;
  }
  if ((param_1[6] == 0) || (param_1[7] == 0)) {
    pcVar15 = "Archive member uses long names, but no longname table found\n";
LAB_00102acd:
    uVar10 = dcgettext(0,pcVar15,5);
    error(uVar10);
    return (undefined4 *)0x0;
  }
  uVar1 = *(undefined *)((long)param_1 + 0x92);
  param_1[8] = 0;
  *(undefined *)((long)param_1 + 0x92) = 0;
  uVar7 = strtoul((char *)((long)param_1 + 0x59),&local_c0,10);
  if (((*(int *)(param_1 + 10) != 0) && (local_c0 != (char *)0x0)) && (*local_c0 == ':')) {
    uVar8 = strtoul(local_c0 + 1,(char **)0x0,10);
    param_1[8] = uVar8;
  }
  uVar8 = param_1[7];
  *(undefined *)((long)param_1 + 0x92) = uVar1;
  if (uVar8 < uVar7) {
    uVar10 = dcgettext(0,"Found long name index (%ld) beyond end of long name table\n",5);
    error(uVar10,uVar7);
    return (undefined4 *)0x0;
  }
  lVar13 = param_1[6];
  for (uVar9 = uVar7;
      ((uVar8 != uVar9 && (*(char *)(lVar13 + uVar9) != '\0')) &&
      (*(char *)(lVar13 + uVar9) != '\n')); uVar9 = uVar9 + 1) {
  }
  if ((uVar9 != 0) && (*(char *)(lVar13 + -1 + uVar9) == '/')) {
    uVar9 = uVar9 - 1;
  }
  if (uVar9 < uVar8) {
    uVar8 = uVar9;
  }
  *(undefined *)(lVar13 + uVar8) = 0;
  if ((*(int *)(param_1 + 10) == 0) || (param_1[8] == 0)) goto LAB_00102c2d;
  if (uVar8 <= uVar7) {
    pcVar15 = "Invalid Thin archive member name\n";
    goto LAB_00102acd;
  }
  pcVar15 = (char *)adjust_relative_path(*param_1,param_1[6] + uVar7,uVar8 - uVar7);
  if (pcVar15 != (char *)0x0) {
    if ((*param_2 == (char *)0x0) || (iVar6 = strcmp(*param_2,pcVar15), iVar6 != 0)) {
      if ((FILE *)param_2[1] != (FILE *)0x0) {
        fclose((FILE *)param_2[1]);
        param_2[1] = (char *)0x0;
      }
      release_archive(param_2);
      __stream = fopen(pcVar15,"rb");
      if (__stream != (FILE *)0x0) {
        iVar6 = fileno(__stream);
        iVar6 = fstat(iVar6,&local_b8);
        if ((-1 < iVar6) &&
           (iVar6 = setup_archive_constprop_0(param_2,pcVar15,__stream,local_b8.st_size,0),
           iVar6 == 0)) goto LAB_00102b84;
      }
    }
    else {
LAB_00102b84:
      iVar6 = fseek((FILE *)param_2[1],param_1[8],0);
      if (iVar6 == 0) {
        sVar11 = fread(param_2 + 0xb,1,0x3c,(FILE *)param_2[1]);
        if (sVar11 == 0x3c) {
          if (*(short *)((long)param_2 + 0x92) == 0xa60) {
            puVar12 = (undefined4 *)get_archive_member_name(param_2,0);
            if (puVar12 != (undefined4 *)0x0) {
              free(pcVar15);
              return puVar12;
            }
            goto LAB_00102c25;
          }
          pcVar14 = *param_2;
          pcVar16 = "%s: did not find a valid archive header\n";
        }
        else {
          pcVar14 = *param_2;
          pcVar16 = "%s: failed to read archive header\n";
        }
      }
      else {
        pcVar14 = *param_2;
        pcVar16 = "%s: failed to seek to next file name\n";
      }
      uVar10 = dcgettext(0,pcVar16,5);
      error(uVar10,pcVar14);
    }
  }
LAB_00102c25:
  free(pcVar15);
LAB_00102c2d:
  puVar12 = (undefined4 *)xstrdup(param_1[6] + uVar7);
  return puVar12;
}


////>>0x00102c98>>byte_put_little_endian.cold>>////

void byte_put_little_endian_cold(void)

{
  undefined8 uVar1;
  undefined4 unaff_EBX;
  
  uVar1 = dcgettext(0,"Unhandled data length: %d\n",5);
  error(uVar1,unaff_EBX);
                    
  abort();
}


////>>0x00102cbc>>xmalloc.cold>>////

char * xmalloc_cold(undefined8 param_1,char *param_2)

{
  ulong __size;
  long lVar1;
  char cVar2;
  char *pcVar3;
  char *pcVar4;
  undefined8 uVar5;
  ulong uVar6;
  ulong extraout_RDX;
  char *unaff_RBX;
  ulong uVar7;
  byte bVar8;
  
  bVar8 = 0;
  xmalloc_failed();
  pcVar3 = unaff_RBX;
  pcVar4 = unaff_RBX;
  while (cVar2 = *pcVar3, cVar2 != '\0') {
    pcVar3 = pcVar3 + 1;
    if (cVar2 == '/') {
      pcVar4 = pcVar3;
    }
  }
  if ((*param_2 == '/') || (unaff_RBX == pcVar4)) {
    if (extraout_RDX + 1 == 0) {
      return (char *)0x0;
    }
    pcVar4 = (char *)malloc(extraout_RDX + 1);
    uVar6 = extraout_RDX;
    pcVar3 = pcVar4;
    if (pcVar4 != (char *)0x0) {
      for (; uVar6 != 0; uVar6 = uVar6 - 1) {
        *pcVar3 = *param_2;
        param_2 = param_2 + (ulong)bVar8 * -2 + 1;
        pcVar3 = pcVar3 + (ulong)bVar8 * -2 + 1;
      }
      pcVar4[extraout_RDX] = '\0';
      return pcVar4;
    }
  }
  else {
    uVar7 = (long)pcVar4 - (long)unaff_RBX;
    lVar1 = uVar7 + extraout_RDX;
    uVar6 = extraout_RDX;
    if (extraout_RDX <= uVar7) {
      uVar6 = uVar7;
    }
    __size = lVar1 + 1;
    if (__size < uVar6) {
      uVar5 = dcgettext(0,"Abnormal length of thin archive member name: %lx\n",5);
      error(uVar5,extraout_RDX);
      return (char *)0x0;
    }
    pcVar4 = (char *)malloc(__size);
    pcVar3 = pcVar4;
    if (pcVar4 != (char *)0x0) {
      for (; uVar6 = extraout_RDX, uVar7 != 0; uVar7 = uVar7 - 1) {
        *pcVar3 = *unaff_RBX;
        unaff_RBX = unaff_RBX + (ulong)bVar8 * -2 + 1;
        pcVar3 = pcVar3 + (ulong)bVar8 * -2 + 1;
      }
      for (; uVar6 != 0; uVar6 = uVar6 - 1) {
        *pcVar3 = *param_2;
        param_2 = param_2 + (ulong)bVar8 * -2 + 1;
        pcVar3 = pcVar3 + (ulong)bVar8 * -2 + 1;
      }
      pcVar4[lVar1] = '\0';
      return pcVar4;
    }
  }
  uVar5 = dcgettext(0,"Out of memory\n",5);
  error(uVar5);
  return (char *)0x0;
}


////>>0x00102cc4>>adjust_relative_path>>////

char * adjust_relative_path(char *param_1,char *param_2,ulong param_3)

{
  ulong __size;
  long lVar1;
  char cVar2;
  char *pcVar3;
  char *pcVar4;
  undefined8 uVar5;
  ulong uVar6;
  ulong uVar7;
  byte bVar8;
  
  bVar8 = 0;
  pcVar3 = param_1;
  pcVar4 = param_1;
  while (cVar2 = *pcVar3, cVar2 != '\0') {
    pcVar3 = pcVar3 + 1;
    if (cVar2 == '/') {
      pcVar4 = pcVar3;
    }
  }
  if ((*param_2 == '/') || (param_1 == pcVar4)) {
    if (param_3 + 1 == 0) {
      return (char *)0x0;
    }
    pcVar4 = (char *)malloc(param_3 + 1);
    uVar6 = param_3;
    pcVar3 = pcVar4;
    if (pcVar4 != (char *)0x0) {
      for (; uVar6 != 0; uVar6 = uVar6 - 1) {
        *pcVar3 = *param_2;
        param_2 = param_2 + (ulong)bVar8 * -2 + 1;
        pcVar3 = pcVar3 + (ulong)bVar8 * -2 + 1;
      }
      pcVar4[param_3] = '\0';
      return pcVar4;
    }
  }
  else {
    uVar7 = (long)pcVar4 - (long)param_1;
    lVar1 = uVar7 + param_3;
    uVar6 = param_3;
    if (param_3 <= uVar7) {
      uVar6 = uVar7;
    }
    __size = lVar1 + 1;
    if (__size < uVar6) {
      uVar5 = dcgettext(0,"Abnormal length of thin archive member name: %lx\n",5);
      error(uVar5,param_3);
      return (char *)0x0;
    }
    pcVar4 = (char *)malloc(__size);
    pcVar3 = pcVar4;
    if (pcVar4 != (char *)0x0) {
      for (; uVar7 != 0; uVar7 = uVar7 - 1) {
        *pcVar3 = *param_1;
        param_1 = param_1 + (ulong)bVar8 * -2 + 1;
        pcVar3 = pcVar3 + (ulong)bVar8 * -2 + 1;
      }
      for (; param_3 != 0; param_3 = param_3 - 1) {
        *pcVar3 = *param_2;
        param_2 = param_2 + (ulong)bVar8 * -2 + 1;
        pcVar3 = pcVar3 + (ulong)bVar8 * -2 + 1;
      }
      pcVar4[lVar1] = '\0';
      return pcVar4;
    }
  }
  uVar5 = dcgettext(0,"Out of memory\n",5);
  error(uVar5);
  return (char *)0x0;
}


////>>0x00102da5>>warn>>////



void warn(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
         undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,char *param_9,
         undefined8 param_10,undefined8 param_11,undefined8 param_12,undefined8 param_13,
         undefined8 param_14)

{
  char in_AL;
  char *__format;
  undefined4 local_e0;
  undefined4 local_dc;
  undefined *local_d8;
  undefined *local_d0;
  undefined local_c8 [8];
  undefined8 local_c0;
  undefined8 local_b8;
  undefined8 local_b0;
  undefined8 local_a8;
  undefined8 local_a0;
  undefined4 local_98;
  undefined4 local_88;
  undefined4 local_78;
  undefined4 local_68;
  undefined4 local_58;
  undefined4 local_48;
  undefined4 local_38;
  undefined4 local_28;
  
  if (in_AL != '\0') {
    local_98 = param_1;
    local_88 = param_2;
    local_78 = param_3;
    local_68 = param_4;
    local_58 = param_5;
    local_48 = param_6;
    local_38 = param_7;
    local_28 = param_8;
  }
  local_c0 = param_10;
  local_b8 = param_11;
  local_b0 = param_12;
  local_a8 = param_13;
  local_a0 = param_14;
  fflush(_stdout);
  local_d8 = &stack0x00000008;
  local_d0 = local_c8;
  local_e0 = 8;
  local_dc = 0x30;
  __format = (char *)dcgettext(0,"%s: Warning: ",5);
  fprintf(_stderr,__format,"elfedit");
  vfprintf(_stderr,param_9,&local_e0);
  return;
}


////>>0x00102e85>>error>>////



void error(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
          undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,char *param_9,
          undefined8 param_10,undefined8 param_11,undefined8 param_12,undefined8 param_13,
          undefined8 param_14)

{
  char in_AL;
  char *__format;
  undefined4 local_e0;
  undefined4 local_dc;
  undefined *local_d8;
  undefined *local_d0;
  undefined local_c8 [8];
  undefined8 local_c0;
  undefined8 local_b8;
  undefined8 local_b0;
  undefined8 local_a8;
  undefined8 local_a0;
  undefined4 local_98;
  undefined4 local_88;
  undefined4 local_78;
  undefined4 local_68;
  undefined4 local_58;
  undefined4 local_48;
  undefined4 local_38;
  undefined4 local_28;
  
  if (in_AL != '\0') {
    local_98 = param_1;
    local_88 = param_2;
    local_78 = param_3;
    local_68 = param_4;
    local_58 = param_5;
    local_48 = param_6;
    local_38 = param_7;
    local_28 = param_8;
  }
  local_c0 = param_10;
  local_b8 = param_11;
  local_b0 = param_12;
  local_a8 = param_13;
  local_a0 = param_14;
  fflush(_stdout);
  local_d8 = &stack0x00000008;
  local_d0 = local_c8;
  local_e0 = 8;
  local_dc = 0x30;
  __format = (char *)dcgettext(0,"%s: Error: ",5);
  fprintf(_stderr,__format,"elfedit");
  vfprintf(_stderr,param_9,&local_e0);
  return;
}


////>>0x00102f65>>release_archive>>////

void release_archive(void **param_1)

{
  free(*param_1);
  free(param_1[3]);
  free(param_1[4]);
  free(param_1[6]);
  *param_1 = (void *)0x0;
  param_1[6] = (void *)0x0;
  *(undefined (*) [16])(param_1 + 3) = ZEXT816(0);
  return;
}


////>>0x00102fa0>>consume_whitespace>>////

void consume_whitespace(byte **param_1)

{
  while ((_sch_istable[(ulong)**param_1 * 2] & 0x40) != 0) {
    *param_1 = *param_1 + 1;
  }
  return;
}


////>>0x00102fbc>>xexit.constprop.0>>////

void xexit_constprop_0(void)

{
                    
  exit(1);
}


////>>0x00102fc7>>xmalloc_failed>>////



char * xmalloc_failed(undefined8 param_1)

{
  char cVar1;
  void *pvVar2;
  size_t sVar3;
  ulong uVar4;
  char *pcVar5;
  char **ppcVar6;
  undefined8 extraout_RDX;
  long lVar7;
  char *__s;
  FILE *__ptr;
  char *pcVar8;
  byte bVar9;
  undefined8 extraout_XMM0_Qa;
  uint uStack_f8;
  char **ppcVar10;
  char **ppcVar11;
  char *apcStack_e0 [4];
  undefined8 uStack_c0;
  long lStack_b8;
  undefined8 uStack_b0;
  undefined8 uStack_28;
  
  bVar9 = 0;
  pvVar2 = sbrk(0);
  lStack_b8 = (long)pvVar2 + -0x10a0e0;
  apcStack_e0[3] = "";
  __s = "\n%s%sout of memory allocating %lu bytes after a total of %lu bytes\n";
  __ptr = _stderr;
  uStack_c0 = param_1;
  fprintf(_stderr,"\n%s%sout of memory allocating %lu bytes after a total of %lu bytes\n");
  cVar1 = xexit_constprop_0();
  if (cVar1 != '\0') {
    uStack_b0 = extraout_XMM0_Qa;
  }
  lVar7 = 0;
  uStack_f8 = 0x10;
  pcVar8 = __s;
  ppcVar10 = (char **)register0x00000020;
  apcStack_e0[2] = (char *)extraout_RDX;
  uStack_28 = param_1;
  do {
    sVar3 = strlen(pcVar8);
    lVar7 = lVar7 + sVar3;
    if (uStack_f8 < 0x30) {
      uVar4 = (ulong)uStack_f8;
      uStack_f8 = uStack_f8 + 8;
      ppcVar6 = (char **)((long)apcStack_e0 + uVar4);
      ppcVar11 = ppcVar10;
    }
    else {
      ppcVar11 = ppcVar10 + 1;
      ppcVar6 = ppcVar10;
    }
    pcVar8 = *ppcVar6;
    ppcVar10 = ppcVar11;
  } while (pcVar8 != (char *)0x0);
  pcVar5 = (char *)xmalloc(lVar7 + 1);
  uStack_f8 = 0x10;
  pcVar8 = pcVar5;
  ppcVar10 = (char **)register0x00000020;
  do {
    sVar3 = strlen(__s);
    for (; sVar3 != 0; sVar3 = sVar3 - 1) {
      *pcVar8 = *__s;
      __s = __s + (ulong)bVar9 * -2 + 1;
      pcVar8 = pcVar8 + (ulong)bVar9 * -2 + 1;
    }
    if (uStack_f8 < 0x30) {
      uVar4 = (ulong)uStack_f8;
      uStack_f8 = uStack_f8 + 8;
      ppcVar6 = (char **)((long)apcStack_e0 + uVar4);
      ppcVar11 = ppcVar10;
    }
    else {
      ppcVar11 = ppcVar10 + 1;
      ppcVar6 = ppcVar10;
    }
    __s = *ppcVar6;
    ppcVar10 = ppcVar11;
  } while (__s != (char *)0x0);
  *pcVar8 = '\0';
  free(__ptr);
  return pcVar5;
}


////>>0x00103006>>reconcat>>////

char * reconcat(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
               undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
               void *param_9,char *param_10,undefined8 param_11,undefined8 param_12,
               undefined8 param_13,undefined8 param_14)

{
  char in_AL;
  size_t sVar1;
  ulong uVar2;
  char *pcVar3;
  char **ppcVar4;
  long lVar5;
  char *pcVar6;
  byte bVar7;
  uint local_f0;
  char **local_e8;
  char *local_d8 [4];
  undefined8 local_b8;
  undefined8 local_b0;
  undefined4 local_a8;
  undefined4 local_98;
  undefined4 local_88;
  undefined4 local_78;
  undefined4 local_68;
  undefined4 local_58;
  undefined4 local_48;
  undefined4 local_38;
  
  bVar7 = 0;
  if (in_AL != '\0') {
    local_a8 = param_1;
    local_98 = param_2;
    local_88 = param_3;
    local_78 = param_4;
    local_68 = param_5;
    local_58 = param_6;
    local_48 = param_7;
    local_38 = param_8;
  }
  local_e8 = (char **)&stack0x00000008;
  lVar5 = 0;
  local_f0 = 0x10;
  pcVar6 = param_10;
  local_d8[2] = (char *)param_11;
  local_d8[3] = (char *)param_12;
  local_b8 = param_13;
  local_b0 = param_14;
  do {
    sVar1 = strlen(pcVar6);
    lVar5 = lVar5 + sVar1;
    if (local_f0 < 0x30) {
      uVar2 = (ulong)local_f0;
      local_f0 = local_f0 + 8;
      ppcVar4 = (char **)((long)local_d8 + uVar2);
    }
    else {
      ppcVar4 = local_e8;
      local_e8 = local_e8 + 1;
    }
    pcVar6 = *ppcVar4;
  } while (pcVar6 != (char *)0x0);
  pcVar3 = (char *)xmalloc(lVar5 + 1);
  local_f0 = 0x10;
  local_e8 = (char **)&stack0x00000008;
  pcVar6 = pcVar3;
  do {
    sVar1 = strlen(param_10);
    for (; sVar1 != 0; sVar1 = sVar1 - 1) {
      *pcVar6 = *param_10;
      param_10 = param_10 + (ulong)bVar7 * -2 + 1;
      pcVar6 = pcVar6 + (ulong)bVar7 * -2 + 1;
    }
    if (local_f0 < 0x30) {
      uVar2 = (ulong)local_f0;
      local_f0 = local_f0 + 8;
      ppcVar4 = (char **)((long)local_d8 + uVar2);
    }
    else {
      ppcVar4 = local_e8;
      local_e8 = local_e8 + 1;
    }
    param_10 = *ppcVar4;
  } while (param_10 != (char *)0x0);
  *pcVar6 = '\0';
  free(param_9);
  return pcVar3;
}


////>>0x00103160>>xstrdup>>////

void xstrdup(char *param_1)

{
  size_t sVar1;
  char *pcVar2;
  long lVar3;
  byte bVar4;
  
  bVar4 = 0;
  sVar1 = strlen(param_1);
  lVar3 = sVar1 + 1;
  pcVar2 = (char *)xmalloc(lVar3);
  for (; lVar3 != 0; lVar3 = lVar3 + -1) {
    *pcVar2 = *param_1;
    param_1 = param_1 + (ulong)bVar4 * -2 + 1;
    pcVar2 = pcVar2 + (ulong)bVar4 * -2 + 1;
  }
  return;
}


////>>0x00103186>>concat.constprop.0>>////

char * concat_constprop_0(undefined4 param_1,undefined4 param_2,undefined4 param_3,
                         undefined4 param_4,undefined4 param_5,undefined4 param_6,undefined4 param_7
                         ,undefined4 param_8,undefined8 param_9,undefined8 param_10,
                         undefined8 param_11,undefined8 param_12,undefined8 param_13,
                         undefined8 param_14)

{
  char in_AL;
  size_t sVar1;
  ulong uVar2;
  char *pcVar3;
  char **ppcVar4;
  long lVar5;
  char *pcVar6;
  char *pcVar7;
  byte bVar8;
  uint local_e0;
  char **local_d8;
  char *local_c8 [4];
  undefined8 local_a8;
  undefined8 local_a0;
  undefined4 local_98;
  undefined4 local_88;
  undefined4 local_78;
  undefined4 local_68;
  undefined4 local_58;
  undefined4 local_48;
  undefined4 local_38;
  undefined4 local_28;
  
  bVar8 = 0;
  if (in_AL != '\0') {
    local_98 = param_1;
    local_88 = param_2;
    local_78 = param_3;
    local_68 = param_4;
    local_58 = param_5;
    local_48 = param_6;
    local_38 = param_7;
    local_28 = param_8;
  }
  local_d8 = (char **)&stack0x00000008;
  lVar5 = 0;
  local_e0 = 8;
  pcVar6 = "none";
  local_c8[1] = (char *)param_10;
  local_c8[2] = (char *)param_11;
  local_c8[3] = (char *)param_12;
  local_a8 = param_13;
  local_a0 = param_14;
  do {
    sVar1 = strlen(pcVar6);
    lVar5 = lVar5 + sVar1;
    if (local_e0 < 0x30) {
      uVar2 = (ulong)local_e0;
      local_e0 = local_e0 + 8;
      ppcVar4 = (char **)((long)local_c8 + uVar2);
    }
    else {
      ppcVar4 = local_d8;
      local_d8 = local_d8 + 1;
    }
    pcVar6 = *ppcVar4;
  } while (pcVar6 != (char *)0x0);
  pcVar6 = "none";
  pcVar3 = (char *)xmalloc(lVar5 + 1);
  local_e0 = 8;
  local_d8 = (char **)&stack0x00000008;
  pcVar7 = pcVar3;
  do {
    sVar1 = strlen(pcVar6);
    for (; sVar1 != 0; sVar1 = sVar1 - 1) {
      *pcVar7 = *pcVar6;
      pcVar6 = pcVar6 + (ulong)bVar8 * -2 + 1;
      pcVar7 = pcVar7 + (ulong)bVar8 * -2 + 1;
    }
    if (local_e0 < 0x30) {
      uVar2 = (ulong)local_e0;
      local_e0 = local_e0 + 8;
      ppcVar4 = (char **)((long)local_c8 + uVar2);
    }
    else {
      ppcVar4 = local_d8;
      local_d8 = local_d8 + 1;
    }
    pcVar6 = *ppcVar4;
  } while (pcVar6 != (char *)0x0);
  *pcVar7 = '\0';
  return pcVar3;
}


////>>0x001032de>>usage>>////

void usage(FILE *param_1,int param_2)

{
  undefined8 *puVar1;
  void *__ptr;
  char *pcVar2;
  undefined4 *puVar3;
  
  puVar3 = &osabis;
  __ptr = (void *)concat_constprop_0(&DAT_00106137,0);
  do {
    puVar1 = (undefined8 *)(puVar3 + 6);
    puVar3 = puVar3 + 4;
    __ptr = (void *)reconcat(__ptr,__ptr,&DAT_001061ef,*puVar1,0);
  } while (puVar3 != (undefined4 *)&DAT_00108d90);
  pcVar2 = (char *)dcgettext(0,"Usage: %s <option(s)> elffile(s)\n",5);
  fprintf(param_1,pcVar2,"elfedit");
  pcVar2 = (char *)dcgettext(0," Update the ELF header of ELF files\n",5);
  fprintf(param_1,pcVar2);
  pcVar2 = (char *)dcgettext(0," The options are:\n",5);
  fprintf(param_1,pcVar2);
  pcVar2 = (char *)dcgettext(0,
                             "  --input-mach [none|i386|iamcu|l1om|k1om|x86_64]\n                              Set input machine type\n  --output-mach [none|i386|iamcu|l1om|k1om|x86_64]\n                              Set output machine type\n  --input-type [none|rel|exec|dyn]\n                              Set input file type\n  --output-type [none|rel|exec|dyn]\n                              Set output file type\n  --input-osabi [%s]\n                              Set input OSABI\n  --output-osabi [%s]\n                              Set output OSABI\n  --input-abiversion [0-255]  Set input ABIVERSION\n  --output-abiversion [0-255] Set output ABIVERSION\n"
                             ,5);
  fprintf(param_1,pcVar2,__ptr,__ptr);
  pcVar2 = (char *)dcgettext(0,
                             "  --enable-x86-feature [ibt|shstk|lam_u48|lam_u57]\n                              Enable x86 feature\n  --disable-x86-feature [ibt|shstk|lam_u48|lam_u57]\n                              Disable x86 feature\n"
                             ,5);
  fprintf(param_1,pcVar2);
  pcVar2 = (char *)dcgettext(0,
                             "  -h --help                   Display this information\n  -v --version                Display the version number of %s\n"
                             ,5);
  fprintf(param_1,pcVar2,"elfedit");
  if (param_2 == 0) {
    pcVar2 = (char *)dcgettext(0,"Report bugs to %s\n",5);
    fprintf(param_1,pcVar2,"<https://sourceware.org/bugzilla/>");
  }
  free(__ptr);
                    
  exit(param_2);
}


////>>0x00103449>>xrealloc>>////

void xrealloc(void *param_1,size_t param_2)

{
  size_t __size;
  void *pvVar1;
  
  __size = 1;
  if (param_2 != 0) {
    __size = param_2;
  }
  if (param_1 == (void *)0x0) {
    pvVar1 = malloc(__size);
  }
  else {
    pvVar1 = realloc(param_1,__size);
  }
  if (pvVar1 == (void *)0x0) {
    xmalloc_failed(__size);
  }
  return;
}


////>>0x0010347f>>byte_get_big_endian>>////

ulong byte_get_big_endian(ulong *param_1,undefined4 param_2)

{
  uint uVar1;
  ulong uVar2;
  undefined8 uVar3;
  
  switch(param_2) {
  case 1:
    return (ulong)*(byte *)param_1;
  case 2:
    return (ulong)CONCAT11((char)*(undefined2 *)param_1,(char)((ushort)*(undefined2 *)param_1 >> 8))
    ;
  case 3:
    return (ulong)*(byte *)((long)param_1 + 1) << 8 | (ulong)*(byte *)param_1 << 0x10 |
           (ulong)*(byte *)((long)param_1 + 2);
  case 4:
    uVar1 = *(uint *)param_1;
    return (ulong)(uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18);
  case 5:
    uVar1 = *(uint *)((long)param_1 + 1);
    return (ulong)CONCAT14(*(byte *)param_1,
                           uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 |
                           uVar1 << 0x18);
  case 6:
    uVar1 = *(uint *)((long)param_1 + 2);
    return (ulong)*(byte *)((long)param_1 + 1) << 0x20 | (ulong)*(byte *)param_1 << 0x28 |
           (ulong)(uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18);
  case 7:
    uVar1 = *(uint *)((long)param_1 + 3);
    return (ulong)*(byte *)((long)param_1 + 2) << 0x20 | (ulong)*(byte *)((long)param_1 + 1) << 0x28
           | (ulong)*(byte *)param_1 << 0x30 |
           (ulong)(uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18);
  case 8:
    uVar2 = *param_1;
    return uVar2 >> 0x38 | (uVar2 & 0xff000000000000) >> 0x28 | (uVar2 & 0xff0000000000) >> 0x18 |
           (uVar2 & 0xff00000000) >> 8 | (uVar2 & 0xff000000) << 8 | (uVar2 & 0xff0000) << 0x18 |
           (uVar2 & 0xff00) << 0x28 | uVar2 << 0x38;
  default:
    uVar3 = dcgettext(0,"Unhandled data length: %d\n",5);
    error(uVar3,param_2);
                    
    abort();
  }
}


////>>0x0010354e>>byte_put_big_endian>>////

void byte_put_big_endian(long param_1,ulong param_2,uint param_3)

{
  undefined8 uVar1;
  int iVar2;
  ulong uVar3;
  
  uVar3 = (ulong)param_3;
  if (8 < param_3) {
    uVar1 = dcgettext(0,"Unhandled data length: %d\n",5);
    error(uVar1,param_3);
                    
    abort();
  }
  while (iVar2 = (int)uVar3, uVar3 = (ulong)(iVar2 - 1), iVar2 != 0) {
    *(char *)(param_1 + uVar3) = (char)param_2;
    param_2 = param_2 >> 8;
  }
  return;
}


////>>0x0010358d>>process_archive>>////

uint process_archive(undefined8 param_1,FILE *param_2,char param_3)

{
  long lVar1;
  char *pcVar2;
  int iVar3;
  uint uVar4;
  undefined8 uVar5;
  size_t sVar6;
  undefined8 uVar7;
  ulong uVar8;
  size_t sVar9;
  char *__s;
  size_t sVar10;
  size_t sVar11;
  char *__s_00;
  char *pcVar12;
  FILE *__stream;
  char *pcVar13;
  uint uVar14;
  stat local_208;
  undefined local_178 [24];
  undefined local_160 [16];
  undefined8 local_148;
  undefined local_d8 [16];
  undefined local_c0 [16];
  undefined8 local_a8;
  long local_98;
  long local_90;
  int local_88;
  undefined local_80 [48];
  char local_50 [10];
  short local_46;
  
  local_148 = 0;
  local_d8 = ZEXT816(0);
  local_c0 = ZEXT816(0);
  local_178._0_16_ = ZEXT816(0);
  local_160 = ZEXT816(0);
  local_a8 = 0;
  iVar3 = fileno(param_2);
  iVar3 = fstat(iVar3,&local_208);
  if ((iVar3 < 0) ||
     (iVar3 = setup_archive_constprop_0(local_d8,param_1,param_2,local_208.st_size,param_3),
     iVar3 != 0)) {
LAB_001036cc:
    uVar14 = 1;
LAB_00103a46:
    if ((FILE *)local_178._8_8_ != (FILE *)0x0) {
      fclose((FILE *)local_178._8_8_);
    }
    release_archive(local_178);
    release_archive(local_d8);
  }
  else {
    uVar14 = 0;
    while (iVar3 = fseek(param_2,local_90,0), iVar3 == 0) {
      sVar6 = fread(local_80,1,0x3c,param_2);
      if (sVar6 != 0x3c) {
        if (sVar6 == 0) goto LAB_00103a46;
        pcVar13 = "%s: failed to read archive header\n";
LAB_001036b8:
        uVar5 = dcgettext(0,pcVar13,5);
        error(uVar5,param_1);
        goto LAB_001036cc;
      }
      if (local_46 != 0xa60) {
        uVar5 = local_d8._0_8_;
        uVar7 = dcgettext(0,"%s: did not find a valid archive header\n",5);
        error(uVar7,uVar5);
        goto LAB_001036cc;
      }
      local_90 = local_90 + 0x3c;
      uVar8 = strtoul(local_50,(char **)0x0,10);
      archive_file_size = (uVar8 + 1) - (ulong)((uVar8 & 1) == 0);
      pcVar13 = (char *)get_archive_member_name(local_d8,local_178);
      if (pcVar13 == (char *)0x0) {
        pcVar13 = "%s: bad archive file name\n";
        goto LAB_001036b8;
      }
      sVar9 = strlen(pcVar13);
      __s = (char *)dcgettext(0,"<corrupt>",5);
      pcVar12 = (char *)local_d8._0_8_;
      sVar10 = strlen((char *)local_d8._0_8_);
      sVar11 = strlen(pcVar13);
      sVar6 = sVar10 + sVar11 + 3;
      if (local_88 == 0) {
        __s_00 = (char *)malloc(sVar6);
        if (__s_00 == (char *)0x0) goto LAB_001037d3;
        snprintf(__s_00,sVar6,"%s(%s)",pcVar12,pcVar13);
      }
      else if (local_98 == 0) {
        __s_00 = (char *)malloc(sVar6);
        if (__s_00 == (char *)0x0) {
LAB_001037d3:
          uVar5 = dcgettext(0,"Out of memory\n",5);
          error(uVar5);
          uVar5 = dcgettext(0,"%s: bad archive file name\n",5);
          error(uVar5,param_1);
          free(pcVar13);
          goto LAB_001036cc;
        }
        snprintf(__s_00,sVar6,"%s[%s]",pcVar12,pcVar13);
      }
      else {
        pcVar2 = (char *)local_178._0_8_;
        lVar1 = sVar10 + sVar11 + 5;
        if ((char *)local_178._0_8_ == (char *)0x0) {
          sVar6 = strlen(__s);
          sVar6 = lVar1 + sVar6;
          __s_00 = (char *)malloc(sVar6);
          pcVar2 = __s;
        }
        else {
          sVar6 = strlen((char *)local_178._0_8_);
          sVar6 = lVar1 + sVar6;
          __s_00 = (char *)malloc(sVar6);
        }
        if (__s_00 == (char *)0x0) goto LAB_001037d3;
        snprintf(__s_00,sVar6,"%s[%s(%s)]",pcVar12,pcVar2,pcVar13);
      }
      if (param_3 == '\0') {
        free(pcVar13);
        local_90 = local_90 + archive_file_size;
        uVar4 = process_object(__s_00,param_2);
        uVar14 = uVar14 | uVar4;
      }
      else {
        if (local_98 == 0) {
          pcVar12 = (char *)adjust_relative_path(param_1,pcVar13,sVar9);
          free(pcVar13);
          if (pcVar12 != (char *)0x0) {
            __stream = fopen(pcVar12,"r+b");
            if (__stream != (FILE *)0x0) {
              uVar4 = process_object(__s_00,__stream);
              uVar14 = uVar14 | uVar4;
              fclose(__stream);
              free(pcVar12);
              goto LAB_00103a39;
            }
            uVar5 = dcgettext(0,"Input file \'%s\' is not readable\n",5);
            error(uVar5,pcVar12);
            free(pcVar12);
          }
          free(__s_00);
          goto LAB_001036cc;
        }
        free(pcVar13);
        iVar3 = fseek((FILE *)local_178._8_8_,local_98 + 0x3c,0);
        if (iVar3 != 0) {
          uVar5 = local_178._0_8_;
          uVar7 = dcgettext(0,"%s: failed to seek to archive member\n",5);
          error(uVar7,uVar5);
          free(__s_00);
          goto LAB_001036cc;
        }
        uVar4 = process_object(__s_00,local_178._8_8_);
        uVar14 = uVar14 | uVar4;
      }
LAB_00103a39:
      free(__s_00);
    }
    uVar5 = dcgettext(0,"%s: failed to seek to next archive header\n",5);
    uVar14 = 1;
    error(uVar5,param_1);
  }
  return uVar14;
}


////>>0x00103a90>>byte_get_little_endian>>////

ulong byte_get_little_endian(ulong *param_1,ulong param_2)

{
  ulong uVar1;
  undefined8 uVar2;
  
  switch(param_2 & 0xffffffff) {
  default:
    uVar2 = dcgettext(0,"Unhandled data length: %d\n",5);
    error(uVar2,param_2 & 0xffffffff);
                    
    abort();
  case 1:
    return (ulong)*(byte *)param_1;
  case 2:
    return (ulong)*(ushort *)param_1;
  case 3:
    uVar1 = FUN_00103ab3(param_1,param_2,
                         (ulong)*(byte *)((long)param_1 + 1) << 8 |
                         (ulong)*(byte *)((long)param_1 + 2) << 0x10);
    return uVar1;
  case 4:
    return (ulong)*(uint *)param_1;
  case 5:
    uVar1 = FUN_00103ab3(param_1,param_2,(ulong)*(byte *)((long)param_1 + 4) << 0x20);
    return uVar1;
  case 6:
    uVar1 = FUN_00103ab3(param_1,param_2,
                         (ulong)*(byte *)((long)param_1 + 4) << 0x20 |
                         (ulong)*(byte *)((long)param_1 + 5) << 0x28);
    return uVar1;
  case 7:
    uVar1 = FUN_00103ab3(param_1,param_2,
                         (ulong)*(byte *)((long)param_1 + 4) << 0x20 |
                         (ulong)*(byte *)((long)param_1 + 5) << 0x28 | (ulong)*(uint *)param_1);
    return uVar1;
  case 8:
    return *param_1;
  }
}


////>>0x00103ab3>>FUN_00103ab3>>////

void FUN_00103ab3(void)

{
  return;
}


////>>0x00103ad0>>byte_put_little_endian>>////

void byte_put_little_endian(long param_1,ulong param_2,uint param_3)

{
  undefined8 uVar1;
  ulong uVar2;
  
  if (param_3 < 9) {
    for (uVar2 = 0; param_3 != uVar2; uVar2 = uVar2 + 1) {
      *(char *)(param_1 + uVar2) = (char)param_2;
      param_2 = param_2 >> 8;
    }
    return;
  }
  uVar1 = dcgettext(0,"Unhandled data length: %d\n",5);
  error(uVar1,param_3);
                    
  abort();
}


////>>0x00103b00>>_start>>////

void processEntry _start(undefined8 param_1,undefined8 param_2)

{
  undefined auStack_8 [8];
  
  __libc_start_main(main,param_2,&stack0x00000008,0,0,param_1,auStack_8);
  do {
                    /* WARNING: Do nothing block with infinite loop */
  } while( true );
}


////>>0x00103b30>>deregister_tm_clones>>////

/* WARNING: Removing unreachable block (ram,0x00103b43) */
/* WARNING: Removing unreachable block (ram,0x00103b4f) */

void deregister_tm_clones(void)

{
  return;
}


////>>0x00103b60>>register_tm_clones>>////

/* WARNING: Removing unreachable block (ram,0x00103b84) */
/* WARNING: Removing unreachable block (ram,0x00103b90) */

void register_tm_clones(void)

{
  return;
}


////>>0x00103ba0>>__do_global_dtors_aux>>////

void __do_global_dtors_aux(void)

{
  if (completed_0 != '\0') {
    return;
  }
  __cxa_finalize(__dso_handle);
  deregister_tm_clones();
  completed_0 = 1;
  return;
}


////>>0x00103be0>>frame_dummy>>////

void frame_dummy(void)

{
  register_tm_clones();
  return;
}


////>>0x00103bf0>>main>>////

/* WARNING: Type propagation algorithm not settling */


uint main(int param_1,long *param_2)

{
  char cVar1;
  byte bVar2;
  ulong uVar3;
  bool bVar4;
  bool bVar5;
  bool bVar6;
  bool bVar7;
  int iVar8;
  uint uVar9;
  int iVar10;
  void *__addr;
  void *__ptr;
  undefined8 uVar11;
  long *plVar12;
  ulong uVar13;
  ulong uVar14;
  ulong uVar15;
  ulong uVar16;
  FILE *pFVar17;
  size_t sVar18;
  byte *__s;
  size_t sVar19;
  int *piVar20;
  long lVar21;
  long *plVar22;
  byte *pbVar23;
  long lVar24;
  long *plVar25;
  undefined8 uVar26;
  ulong uVar27;
  byte *pbVar28;
  uint uVar29;
  long lVar30;
  uint uVar31;
  int iVar32;
  undefined1 *puVar33;
  uint uVar34;
  char *pcVar35;
  ulong uVar36;
  char *pcVar37;
  undefined8 *puVar38;
  ulong uVar39;
  undefined8 *local_138;
  ulong local_120;
  char *local_d8;
  byte *local_d0;
  stat local_c8;
  
  iVar8 = 0;
  iVar32 = 2000;
  setlocale(5,"");
  setlocale(0,"");
  bindtextdomain("binutils","/usr/share/locale");
  textdomain("binutils");
  plVar22 = param_2;
LAB_00103c54:
  lVar30 = (long)(iVar8 + 1);
  do {
    iVar8 = (int)lVar30;
    if (param_1 <= iVar8) {
      puVar33 = options;
      break;
    }
    if (*(char *)plVar22[lVar30] == '@') {
      iVar32 = iVar32 + -1;
      if (iVar32 == 0) {
        lVar30 = *plVar22;
        pcVar37 = "%s: error: too many @-files encountered\n";
        goto LAB_00104739;
      }
      pcVar37 = (char *)plVar22[lVar30] + 1;
      iVar10 = stat(pcVar37,&local_c8);
      if (-1 < iVar10) {
        if ((local_c8.st_mode & 0xf000) == 0x4000) {
          do {
            lVar30 = *plVar22;
            pcVar37 = "%s: error: @-file refers to a directory\n";
LAB_00104739:
            fprintf(_stderr,pcVar37,lVar30);
            xexit_constprop_0();
          } while( true );
        }
        pFVar17 = fopen(pcVar37,"r");
        if (pFVar17 != (FILE *)0x0) goto code_r0x00104650;
      }
    }
    lVar30 = lVar30 + 1;
  } while( true );
LAB_00103c87:
  iVar8 = getopt_long(param_1,plVar22,&DAT_0010604c,puVar33,0);
  if (iVar8 == -1) {
    if ((_optind == param_1) ||
       (((enable_x86_features | disable_x86_features) == 0 &&
        (puVar33 = (undefined1 *)0x0,
        (output_elf_machine & output_elf_type & output_elf_osabi & output_elf_abiversion) ==
        0xffffffff)))) goto switchD_00103cba_caseD_69;
    uVar31 = 0;
    goto LAB_00103d1c;
  }
  switch(iVar8) {
  case 0x68:
    usage(_stdout,0);
  default:
switchD_00103cba_caseD_69:
    usage(_stderr,1);
    goto switchD_00103cba_caseD_9a;
  case 0x76:
    printf("GNU %s %s\n","elfedit","(GNU Binutils for Debian) 2.40");
    pcVar37 = (char *)dcgettext(0,"Copyright (C) 2023 Free Software Foundation, Inc.\n",5);
    printf(pcVar37);
    pcVar37 = (char *)dcgettext(0,
                                "This program is free software; you may redistribute it under the terms of\nthe GNU General Public License version 3 or (at your option) any later version.\nThis program has absolutely no warranty.\n"
                                ,5);
    printf(pcVar37);
                    
    exit(0);
  case 0x96:
    input_elf_machine = elf_machine(_optarg);
    if (input_elf_machine < 0) {
      return 1;
    }
    if (input_elf_machine == 6) {
      input_elf_class = 1;
    }
    else if (input_elf_machine < 7) {
      input_elf_class = (input_elf_machine != 3) + 1 + (uint)(input_elf_machine != 3);
    }
    else {
      input_elf_class = 3 - (uint)(input_elf_machine - 0xb4U < 2);
    }
    goto LAB_00103c87;
  case 0x97:
    output_elf_machine = elf_machine(_optarg);
    if ((int)output_elf_machine < 0) {
      return 1;
    }
    if ((int)output_elf_machine < 0xb6) {
      output_elf_class = 2;
      if (((int)output_elf_machine < 0xb4) && (output_elf_class = 1, output_elf_machine != 3)) {
        output_elf_class = (output_elf_machine != 6) + 1 + (uint)(output_elf_machine != 6);
      }
    }
    else {
      output_elf_class = 3;
    }
    goto LAB_00103c87;
  case 0x98:
    input_elf_type = elf_type(_optarg);
    uVar31 = input_elf_type;
    break;
  case 0x99:
    output_elf_type = elf_type(_optarg);
    uVar31 = output_elf_type;
    break;
  case 0x9a:
    goto switchD_00103cba_caseD_9a;
  case 0x9b:
    output_elf_osabi = elf_osabi(_optarg);
    uVar31 = output_elf_osabi;
    break;
  case 0x9c:
    uVar16 = strtoul(_optarg,&local_d8,0);
    uVar31 = (uint)uVar16;
    cVar1 = *local_d8;
    input_elf_abiversion = uVar31;
    pcVar37 = _optarg;
    goto joined_r0x00104334;
  case 0x9d:
    uVar16 = strtoul(_optarg,&local_d8,0);
    uVar31 = (uint)uVar16;
    cVar1 = *local_d8;
    output_elf_abiversion = uVar31;
    pcVar37 = _optarg;
joined_r0x00104334:
    _optarg = pcVar37;
    if ((cVar1 != '\0') || (0xff < uVar31)) {
      uVar26 = dcgettext(0,"Invalid ABIVERSION: %s\n",5);
      error(uVar26,pcVar37);
      return 1;
    }
    goto LAB_00103c87;
  case 0x9e:
    uVar26 = 1;
    goto LAB_00103e9d;
  case 0x9f:
    uVar26 = 0;
LAB_00103e9d:
    uVar31 = elf_x86_feature(_optarg,uVar26);
  }
joined_r0x00103eae:
  if ((int)uVar31 < 0) {
    return 1;
  }
  goto LAB_00103c87;
LAB_00103d1c:
  lVar30 = (long)_optind;
  if (param_1 <= _optind) {
    return uVar31;
  }
  _optind = _optind + 1;
  pcVar37 = (char *)plVar22[lVar30];
  iVar8 = stat(pcVar37,&local_c8);
  if (iVar8 < 0) {
    piVar20 = __errno_location();
    pcVar35 = "\'%s\': No such file\n";
    if (*piVar20 == 2) goto LAB_00104497;
    pcVar35 = strerror(*piVar20);
    uVar26 = dcgettext(0,"Could not locate \'%s\'.  System error message: %s\n",5);
    error(uVar26,pcVar37,pcVar35);
LAB_001044ab:
    uVar9 = 1;
  }
  else {
    if ((local_c8.st_mode & 0xf000) != 0x8000) {
      pcVar35 = "\'%s\' is not an ordinary file\n";
LAB_00104497:
      uVar26 = dcgettext(0,pcVar35,5);
      error(uVar26,pcVar37);
      goto LAB_001044ab;
    }
    pFVar17 = fopen(pcVar37,"r+b");
    if (pFVar17 == (FILE *)0x0) {
      pcVar35 = "Input file \'%s\' is not readable\n";
      goto LAB_00104497;
    }
    sVar18 = fread(&local_d0,8,1,pFVar17);
    if (sVar18 != 1) {
      uVar26 = dcgettext(0,"%s: Failed to read file\'s magic number\n",5);
      error(uVar26,pcVar37);
      fclose(pFVar17);
      goto LAB_001044ab;
    }
    if (local_d0 == (byte *)0xa3e686372613c21) {
      uVar9 = process_archive(pcVar37,pFVar17,0);
    }
    else if (local_d0 == (byte *)0xa3e6e6968743c21) {
      uVar9 = process_archive(pcVar37,pFVar17,1);
    }
    else {
      rewind(pFVar17);
      archive_file_size = 0;
      uVar9 = process_object(pcVar37,pFVar17);
      if (((uVar9 == 0) && ((ushort)(elf_header._56_2_ - 2) < 2)) &&
         ((enable_x86_features | disable_x86_features) != 0)) {
        if ((elf_header._58_2_ == 3) ||
           (pcVar35 = "%s: Not an i386 nor x86-64 ELF file\n", elf_header._58_2_ == 0x3e)) {
          iVar8 = fileno(pFVar17);
          iVar8 = fstat(iVar8,&local_c8);
          if (iVar8 < 0) {
            uVar26 = dcgettext(0,"%s: stat () failed\n",5);
            error(uVar26,pcVar37);
            uVar9 = 1;
          }
          else {
            iVar8 = fileno(pFVar17);
            __addr = mmap((void *)0x0,local_c8.st_size,3,1,iVar8,0);
            if (__addr == (void *)0xffffffffffffffff) {
              pcVar35 = "%s: mmap () failed\n";
              goto LAB_0010438d;
            }
            __ptr = (void *)xmalloc((ulong)(uint)elf_header._68_4_ << 6);
            uVar26 = elf_header._24_8_;
            if (elf_header[4] == '\x01') {
              for (uVar16 = 0; (uint)uVar16 < (uint)elf_header._68_4_;
                  uVar16 = (ulong)((uint)uVar16 + 1)) {
                lVar30 = uVar16 * 0x20 + uVar26 + (long)__addr;
                puVar38 = (undefined8 *)((long)__ptr + uVar16 * 0x40);
                uVar11 = (*byte_get)(lVar30,4);
                *puVar38 = uVar11;
                uVar11 = (*byte_get)(lVar30 + 4,4);
                puVar38[2] = uVar11;
                uVar11 = (*byte_get)(lVar30 + 8,4);
                puVar38[3] = uVar11;
                uVar11 = (*byte_get)(lVar30 + 0xc,4);
                puVar38[4] = uVar11;
                uVar11 = (*byte_get)(lVar30 + 0x10,4);
                puVar38[5] = uVar11;
                uVar11 = (*byte_get)(lVar30 + 0x14,4);
                puVar38[6] = uVar11;
                uVar11 = (*byte_get)(lVar30 + 0x18,4);
                puVar38[1] = uVar11;
                uVar11 = (*byte_get)(lVar30 + 0x1c,4);
                puVar38[7] = uVar11;
              }
            }
            else {
              for (uVar29 = 0; uVar29 < (uint)elf_header._68_4_; uVar29 = uVar29 + 1) {
                lVar30 = (ulong)uVar29 * 0x38 + uVar26 + (long)__addr;
                puVar38 = (undefined8 *)((ulong)uVar29 * 0x40 + (long)__ptr);
                uVar11 = (*byte_get)(lVar30,4);
                *puVar38 = uVar11;
                uVar11 = (*byte_get)(lVar30 + 8,8);
                puVar38[2] = uVar11;
                uVar11 = (*byte_get)(lVar30 + 0x10,8);
                puVar38[3] = uVar11;
                uVar11 = (*byte_get)(lVar30 + 0x18,8);
                puVar38[4] = uVar11;
                uVar11 = (*byte_get)(lVar30 + 0x20,8);
                puVar38[5] = uVar11;
                uVar11 = (*byte_get)(lVar30 + 0x28,8);
                puVar38[6] = uVar11;
                uVar11 = (*byte_get)(lVar30 + 4,4);
                puVar38[1] = uVar11;
                uVar11 = (*byte_get)(lVar30 + 0x30,8);
                puVar38[7] = uVar11;
              }
            }
            for (uVar16 = 0; (uint)uVar16 < (uint)elf_header._68_4_;
                uVar16 = (ulong)((uint)uVar16 + 1)) {
              plVar12 = (long *)(uVar16 * 0x40 + (long)__ptr);
              if (*plVar12 == 4) {
                lVar30 = plVar12[5];
                uVar3 = plVar12[7];
                uVar36 = (long)__addr + plVar12[2];
                for (local_120 = uVar36; local_120 < uVar36 + lVar30;
                    local_120 = local_120 + ((uVar3 - 1) + uVar15 + uVar14 & uVar27)) {
                  if ((uVar36 - local_120) + lVar30 < 0xc) {
LAB_001044cb:
                    uVar26 = dcgettext(0,"%s: Invalid PT_NOTE segment\n",5);
                    error(uVar26,pcVar37);
                    uVar9 = 1;
                    goto LAB_001042bf;
                  }
                  lVar21 = (*byte_get)(local_120 + 8,4);
                  uVar13 = (*byte_get)(local_120,4);
                  if ((uVar36 - (long)(char *)(local_120 + 0xc)) + lVar30 < uVar13)
                  goto LAB_001044cb;
                  uVar14 = (*byte_get)(local_120 + 4,4);
                  uVar27 = -uVar3;
                  uVar15 = uVar3 + 0xb + uVar13 & uVar27;
                  uVar39 = local_120 + uVar15;
                  if ((uVar14 != 0) &&
                     ((uVar36 + lVar30 <= uVar39 || ((uVar36 - uVar39) + lVar30 < uVar14))))
                  goto LAB_001044cb;
                  if ((uVar13 == 4) &&
                     ((iVar8 = strcmp((char *)(local_120 + 0xc),"GNU"), iVar8 == 0 && (lVar21 == 5))
                     )) {
                    if ((uVar14 < 8) || (uVar14 % uVar3 != 0)) goto LAB_001044cb;
                    uVar13 = uVar39 + uVar14;
                    do {
                      iVar8 = (*byte_get)(uVar39,4);
                      uVar29 = (*byte_get)(uVar39 + 4,4);
                      lVar21 = uVar39 + 8;
                      if (uVar13 < lVar21 + (ulong)uVar29) goto LAB_001044cb;
                      if (iVar8 == -0x3ffffffe) {
                        if (uVar29 != 4) goto LAB_001044cb;
                        uVar29 = (*byte_get)(lVar21,4);
                        if (enable_x86_features == 0) {
                          uVar34 = uVar29;
                          if (disable_x86_features == 0) goto LAB_001042bf;
LAB_001042ac:
                          uVar34 = uVar34 & ~disable_x86_features;
                        }
                        else {
                          uVar34 = enable_x86_features | uVar29;
                          if (disable_x86_features != 0) goto LAB_001042ac;
                        }
                        if (uVar29 != uVar34) {
                          (*byte_put)(lVar21,uVar34,4);
                        }
                        goto LAB_001042bf;
                      }
                      uVar39 = lVar21 + ((ulong)uVar29 + (uVar3 - 1) & uVar27);
                    } while (7 < (long)(uVar13 - uVar39));
                  }
                }
              }
            }
LAB_001042bf:
            free(__ptr);
            munmap(__addr,local_c8.st_size);
          }
        }
        else {
LAB_0010438d:
          uVar26 = dcgettext(0,pcVar35,5);
          error(uVar26,pcVar37);
        }
      }
    }
    fclose(pFVar17);
  }
  uVar31 = uVar31 | uVar9;
  goto LAB_00103d1c;
switchD_00103cba_caseD_9a:
  input_elf_osabi = elf_osabi(_optarg);
  uVar31 = input_elf_osabi;
  goto joined_r0x00103eae;
code_r0x00104650:
  iVar10 = fseek(pFVar17,0,2);
  if (((iVar10 != -1) && (sVar18 = ftell(pFVar17), sVar18 != 0xffffffffffffffff)) &&
     (iVar10 = fseek(pFVar17,0,0), iVar10 != -1)) {
    __s = (byte *)xmalloc(sVar18 + 1);
    sVar19 = fread(__s,1,sVar18,pFVar17);
    if ((sVar18 == sVar19) || (iVar10 = ferror(pFVar17), iVar10 == 0)) {
      __s[sVar19] = 0;
      pbVar28 = __s;
LAB_001046fc:
      if (*pbVar28 == 0) {
        local_138 = (undefined8 *)xmalloc(8);
        *local_138 = 0;
      }
      else {
        if ((_sch_istable[(ulong)*pbVar28 * 2] & 0x40) != 0) goto code_r0x00104718;
        local_d0 = __s;
        strlen((char *)__s);
        pbVar28 = (byte *)xmalloc();
        local_138 = (undefined8 *)0x0;
        iVar10 = 0;
        bVar6 = false;
        bVar5 = false;
        bVar7 = false;
        lVar21 = 0;
        do {
          consume_whitespace(&local_d0);
          pbVar23 = pbVar28;
          if ((iVar10 == 0) || (iVar10 + -1 <= (int)lVar21)) {
            if (local_138 == (undefined8 *)0x0) {
              iVar10 = 8;
              local_138 = (undefined8 *)xmalloc(0x40);
            }
            else {
              iVar10 = iVar10 * 2;
              local_138 = (undefined8 *)xrealloc(local_138,(long)iVar10 << 3);
            }
            local_138[lVar21] = 0;
          }
          for (; bVar2 = *local_d0, bVar2 != 0; local_d0 = local_d0 + 1) {
            if (((_sch_istable[(ulong)bVar2 * 2] & 0x40) != 0) &&
               (bVar4 = (bool)(bVar5 | bVar7 | bVar6), !bVar4)) {
              bVar6 = false;
              bVar7 = false;
              bVar5 = bVar4;
              break;
            }
            if (bVar6) {
              *pbVar23 = bVar2;
              bVar6 = false;
              pbVar23 = pbVar23 + 1;
            }
            else if (bVar2 == 0x5c) {
              bVar6 = true;
            }
            else if (bVar5) {
              if (bVar2 == 0x27) {
                bVar5 = false;
              }
              else {
LAB_00104c08:
                *pbVar23 = bVar2;
                pbVar23 = pbVar23 + 1;
              }
            }
            else if (bVar7) {
              if (bVar2 != 0x22) goto LAB_00104c08;
              bVar7 = false;
            }
            else if (bVar2 == 0x27) {
              bVar5 = true;
            }
            else {
              if (bVar2 != 0x22) goto LAB_00104c08;
              bVar7 = true;
            }
          }
          *pbVar23 = 0;
          uVar26 = xstrdup();
          local_138[lVar21] = uVar26;
          local_138[lVar21 + 1] = 0;
          consume_whitespace(&local_d0);
          lVar21 = lVar21 + 1;
        } while (*local_d0 != 0);
        free(pbVar28);
      }
      if (plVar22 == param_2) {
        lVar21 = 1;
        do {
          lVar24 = lVar21;
          lVar21 = lVar24 + 1;
        } while (plVar22[lVar24 + -1] != 0);
        plVar25 = (long *)xmalloc((long)(int)lVar24 << 3);
        plVar12 = plVar25;
        while (lVar21 = *plVar22, plVar22 = plVar22 + 1, lVar21 != 0) {
          lVar21 = xstrdup();
          *plVar12 = lVar21;
          plVar12 = plVar12 + 1;
        }
        *plVar12 = 0;
        lVar21 = 0;
      }
      else {
        lVar21 = 0;
        plVar25 = plVar22;
      }
      for (; local_138[lVar21] != 0; lVar21 = lVar21 + 1) {
      }
      free((void *)plVar25[lVar30]);
      plVar22 = (long *)xrealloc(plVar25,(lVar21 + 1 + (long)param_1) * 8);
      memmove(plVar22 + lVar30 + lVar21,plVar22 + lVar30 + 1,(long)(param_1 - iVar8) << 3);
      param_1 = param_1 + -1 + (int)lVar21;
      memcpy(plVar22 + lVar30,local_138,lVar21 * 8);
      free(local_138);
      free(__s);
      iVar8 = iVar8 + -1;
    }
    else {
      free(__s);
    }
  }
  fclose(pFVar17);
  goto LAB_00103c54;
code_r0x00104718:
  pbVar28 = pbVar28 + 1;
  goto LAB_001046fc;
}


////>>0x00104c60>>elf_x86_feature>>////

undefined  [16] elf_x86_feature(char *param_1,int param_2,undefined8 param_3,undefined8 param_4)

{
  int iVar1;
  uint uVar2;
  undefined8 uVar3;
  undefined auVar4 [16];
  
  iVar1 = strcasecmp(param_1,"ibt");
  uVar2 = 1;
  if (iVar1 != 0) {
    iVar1 = strcasecmp(param_1,"shstk");
    uVar2 = 2;
    if (iVar1 != 0) {
      iVar1 = strcasecmp(param_1,"lam_u48");
      if (iVar1 == 0) {
        uVar2 = 4;
      }
      else {
        iVar1 = strcasecmp(param_1,"lam_u57");
        uVar2 = 8;
        if (iVar1 != 0) {
          uVar3 = dcgettext(0,"Unknown x86 feature: %s\n",5);
          error(uVar3,param_1);
          uVar3 = 0xffffffff;
          goto LAB_00104ca5;
        }
      }
    }
  }
  if (param_2 == 0) {
    disable_x86_features = uVar2 | disable_x86_features;
    enable_x86_features = ~uVar2 & enable_x86_features;
  }
  else {
    enable_x86_features = uVar2 | enable_x86_features;
    disable_x86_features = disable_x86_features & ~uVar2;
  }
  uVar3 = 0;
LAB_00104ca5:
  auVar4._8_8_ = param_4;
  auVar4._0_8_ = uVar3;
  return auVar4;
}


////>>0x00104ce0>>elf_osabi>>////

undefined  [16] elf_osabi(char *param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)

{
  int iVar1;
  undefined8 uVar2;
  ulong uVar3;
  uint uVar4;
  undefined4 *puVar5;
  undefined auVar6 [16];
  
  puVar5 = &osabis;
  uVar3 = 0;
  do {
    iVar1 = strcasecmp(param_1,*(char **)(puVar5 + 2));
    if (iVar1 == 0) {
      uVar3 = (ulong)(uint)(&osabis)[uVar3 * 4];
      goto LAB_00104d20;
    }
    uVar4 = (int)uVar3 + 1;
    uVar3 = (ulong)uVar4;
    puVar5 = puVar5 + 4;
  } while (uVar4 != 0x10);
  uVar2 = dcgettext(0,"Unknown OSABI: %s\n",5);
  error(uVar2,param_1);
  uVar3 = 0xffffffff;
LAB_00104d20:
  auVar6._8_8_ = param_4;
  auVar6._0_8_ = uVar3;
  return auVar6;
}


////>>0x00104d30>>elf_machine>>////

int elf_machine(char *param_1)

{
  int iVar1;
  int iVar2;
  undefined8 uVar3;
  
  iVar1 = strcasecmp(param_1,"i386");
  if (iVar1 == 0) {
    iVar1 = 3;
  }
  else {
    iVar1 = strcasecmp(param_1,"iamcu");
    if (iVar1 == 0) {
      return 6;
    }
    iVar2 = strcasecmp(param_1,"l1om");
    iVar1 = 0xb4;
    if (iVar2 != 0) {
      iVar1 = strcasecmp(param_1,"k1om");
      if (iVar1 == 0) {
        return 0xb5;
      }
      iVar1 = strcasecmp(param_1,"x86_64");
      if (iVar1 == 0) {
        iVar1 = 0x3e;
      }
      else {
        iVar1 = strcasecmp(param_1,"x86-64");
        if (iVar1 == 0) {
          iVar1 = 0x3e;
        }
        else {
          iVar1 = strcasecmp(param_1,"none");
          if (iVar1 != 0) {
            uVar3 = dcgettext(0,"Unknown machine type: %s\n",5);
            error(uVar3,param_1);
            iVar1 = -1;
          }
        }
      }
    }
  }
  return iVar1;
}


////>>0x00104da0>>elf_type>>////

int elf_type(char *param_1)

{
  int iVar1;
  int iVar2;
  undefined8 uVar3;
  
  iVar1 = strcasecmp(param_1,"rel");
  if (iVar1 == 0) {
    iVar1 = 1;
  }
  else {
    iVar2 = strcasecmp(param_1,"exec");
    iVar1 = 2;
    if (iVar2 != 0) {
      iVar1 = strcasecmp(param_1,"dyn");
      if (iVar1 == 0) {
        iVar1 = 3;
      }
      else {
        iVar1 = strcasecmp(param_1,"none");
        if (iVar1 != 0) {
          uVar3 = dcgettext(0,"Unknown type: %s\n",5);
          error(uVar3,param_1);
          iVar1 = -1;
        }
      }
    }
  }
  return iVar1;
}


////>>0x00104de0>>process_object>>////

undefined8 process_object(undefined8 param_1,FILE *param_2)

{
  int iVar1;
  long __off;
  size_t sVar2;
  undefined8 uVar3;
  char *pcVar4;
  uint uVar5;
  uint uVar6;
  
  __off = ftell(param_2);
  sVar2 = fread(elf_header,0x10,1,param_2);
  if ((sVar2 == 1) && (elf_header._0_4_ == 0x464c457f)) {
    byte_put = byte_put_big_endian;
    if (elf_header[5] != '\x02') {
      byte_put = byte_put_little_endian;
    }
    byte_get = byte_get_big_endian;
    if (elf_header[5] != '\x02') {
      byte_get = byte_get_little_endian;
    }
    if ((char)elf_header._4_4_ == '\x01') {
      sVar2 = fread(ehdr32 + 0x10,0x24,1,param_2);
      if (sVar2 != 1) goto code_r0x00102558;
      elf_header._56_2_ = (*byte_get)(0x109390,2);
      elf_header._58_2_ = (*byte_get)(0x109392,2);
      elf_header._40_8_ = (*byte_get)(0x109394,4);
      elf_header._16_8_ = (*byte_get)(0x109398,4);
      elf_header._24_8_ = (*byte_get)(0x10939c,4);
      elf_header._32_8_ = (*byte_get)(0x1093a0,4);
      elf_header._48_8_ = (*byte_get)(0x1093a4,4);
      elf_header._60_4_ = (*byte_get)(0x1093a8,2);
      elf_header._64_4_ = (*byte_get)(0x1093aa,2);
      elf_header._68_4_ = (*byte_get)(0x1093ac,2);
      elf_header._72_4_ = (*byte_get)(0x1093ae,2);
      elf_header._76_4_ = (*byte_get)(0x1093b0,2);
      elf_header._80_4_ = (*byte_get)(0x1093b2,2);
      ehdr32._0_4_ = elf_header._0_4_;
      ehdr32._4_4_ = elf_header._4_4_;
      ehdr32._8_4_ = elf_header._8_4_;
      ehdr32._12_4_ = elf_header._12_4_;
    }
    else {
      if ((char)elf_header._4_4_ != '\x02') {
        uVar3 = FUN_00102558();
        return uVar3;
      }
      sVar2 = fread(ehdr64 + 0x10,0x30,1,param_2);
      if (sVar2 != 1) goto code_r0x00102558;
      elf_header._56_2_ = (*byte_get)(0x109350,2);
      elf_header._58_2_ = (*byte_get)(0x109352,2);
      elf_header._40_8_ = (*byte_get)(0x109354,4);
      elf_header._16_8_ = (*byte_get)(0x109358,8);
      elf_header._24_8_ = (*byte_get)(0x109360,8);
      elf_header._32_8_ = (*byte_get)(0x109368,8);
      elf_header._48_8_ = (*byte_get)(0x109370,4);
      elf_header._60_4_ = (*byte_get)(0x109374,2);
      elf_header._64_4_ = (*byte_get)(0x109376,2);
      elf_header._68_4_ = (*byte_get)(0x109378,2);
      elf_header._72_4_ = (*byte_get)(0x10937a,2);
      elf_header._76_4_ = (*byte_get)(0x10937c,2);
      elf_header._80_4_ = (*byte_get)(0x10937e,2);
      ehdr64._0_4_ = elf_header._0_4_;
      ehdr64._4_4_ = elf_header._4_4_;
      ehdr64._8_4_ = elf_header._8_4_;
      ehdr64._12_4_ = elf_header._12_4_;
    }
    iVar1 = fseek(param_2,__off,0);
    if (iVar1 != 0) {
      uVar3 = dcgettext(0,"%s: Failed to seek to ELF header\n",5);
      error(uVar3,param_1);
    }
    uVar5 = (uint)elf_header._4_4_ >> 0x10 & 0xff;
    if ((char)uVar5 == '\x01') {
      uVar5 = (uint)(ushort)elf_header._58_2_;
      if (uVar5 == output_elf_machine) {
        return 0;
      }
      uVar6 = elf_header._4_4_ & 0xff;
      if (input_elf_class == 0xffffffff) {
        if (elf_header._58_2_ == 6) {
          input_elf_class = 1;
        }
        else if ((ushort)elf_header._58_2_ < 7) {
          input_elf_class = (elf_header._58_2_ != 3) + 1 + (uint)(elf_header._58_2_ != 3);
        }
        else {
          input_elf_class = 3 - ((ushort)(elf_header._58_2_ - 0xb4) < 2);
        }
      }
      if ((uVar6 == input_elf_class) || (input_elf_class == 3)) {
        if ((uVar6 == output_elf_class) || (output_elf_class == 3)) {
          if ((uVar5 == input_elf_machine) || (input_elf_machine == 0xffffffff)) {
            uVar5 = (uint)(ushort)elf_header._56_2_;
            if ((input_elf_type == 0xffffffff) || (uVar5 == input_elf_type)) {
              uVar5 = (uint)elf_header._4_4_ >> 0x18;
              if ((input_elf_osabi == 0xffffffff) || (uVar5 == input_elf_osabi)) {
                uVar5 = elf_header._8_4_ & 0xff;
                if ((uVar5 == input_elf_abiversion) || (input_elf_abiversion == 0xffffffff)) {
                  if ((char)uVar6 == '\x01') {
                    if (output_elf_machine != 0xffffffff) {
                      (*byte_put)(0x109392,(long)(int)output_elf_machine,2);
                    }
                    if (output_elf_type != -1) {
                      (*byte_put)(0x109390,(long)output_elf_type,2);
                    }
                    if (output_elf_osabi != -1) {
                      ehdr32[7] = (char)output_elf_osabi;
                    }
                    if (output_elf_abiversion != -1) {
                      ehdr32[8] = (char)output_elf_abiversion;
                    }
                    sVar2 = fwrite(ehdr32,0x34,1,param_2);
                    if (sVar2 == 1) {
                      return 0;
                    }
                    uVar3 = FUN_001024ec();
                    return uVar3;
                  }
                  if ((char)uVar6 != '\x02') {
                    
                    abort();
                  }
                  if (output_elf_machine != 0xffffffff) {
                    (*byte_put)(0x109352,(long)(int)output_elf_machine,2);
                  }
                  if (output_elf_type != -1) {
                    (*byte_put)(0x109350,(long)output_elf_type,2);
                  }
                  if (output_elf_osabi != -1) {
                    ehdr64[7] = (char)output_elf_osabi;
                  }
                  if (output_elf_abiversion != -1) {
                    ehdr64[8] = (char)output_elf_abiversion;
                  }
                  sVar2 = fwrite(ehdr64,0x40,1,param_2);
                  if (sVar2 == 1) {
                    return 0;
                  }
                  uVar3 = FUN_001024ec();
                  return uVar3;
                }
                pcVar4 = "%s: Unmatched EI_ABIVERSION: %d is not %d\n";
                uVar6 = input_elf_abiversion;
              }
              else {
                pcVar4 = "%s: Unmatched EI_OSABI: %d is not %d\n";
                uVar6 = input_elf_osabi;
              }
            }
            else {
              pcVar4 = "%s: Unmatched e_type: %d is not %d\n";
              uVar6 = input_elf_type;
            }
          }
          else {
            pcVar4 = "%s: Unmatched e_machine: %d is not %d\n";
            uVar6 = input_elf_machine;
          }
          uVar3 = dcgettext(0,pcVar4,5);
          error(uVar3,param_1,uVar5,uVar6);
          return 1;
        }
        pcVar4 = "%s: Unmatched output EI_CLASS: %d is not %d\n";
        uVar5 = output_elf_class;
      }
      else {
        pcVar4 = "%s: Unmatched input EI_CLASS: %d is not %d\n";
        uVar5 = input_elf_class;
      }
      uVar3 = dcgettext(0,pcVar4,5);
      error(uVar3,param_1,uVar6,uVar5);
    }
    else {
      uVar3 = dcgettext(0,"%s: Unsupported EI_VERSION: %d is not %d\n",5);
      error(uVar3,param_1,uVar5,1);
    }
  }
  else {
code_r0x00102558:
    uVar3 = dcgettext(0,"%s: Failed to read ELF header\n",5);
    error(uVar3,param_1);
  }
  return 1;
}


////>>0x00105370>>xmalloc>>////

char * xmalloc(char *param_1,char *param_2)

{
  ulong __size;
  long lVar1;
  char cVar2;
  undefined8 uVar3;
  char *pcVar4;
  char *pcVar5;
  char *pcVar6;
  ulong uVar7;
  ulong extraout_RDX;
  ulong uVar8;
  byte bVar9;
  
  bVar9 = 0;
  pcVar5 = (char *)0x1;
  if (param_1 != (char *)0x0) {
    pcVar5 = param_1;
  }
  pcVar6 = (char *)malloc((size_t)pcVar5);
  if (pcVar6 != (char *)0x0) {
    return pcVar6;
  }
  xmalloc_failed();
  pcVar6 = pcVar5;
  pcVar4 = pcVar5;
  while (cVar2 = *pcVar6, cVar2 != '\0') {
    pcVar6 = pcVar6 + 1;
    if (cVar2 == '/') {
      pcVar4 = pcVar6;
    }
  }
  if ((*param_2 == '/') || (pcVar5 == pcVar4)) {
    if (extraout_RDX + 1 == 0) {
      return (char *)0x0;
    }
    pcVar6 = (char *)malloc(extraout_RDX + 1);
    uVar7 = extraout_RDX;
    pcVar5 = pcVar6;
    if (pcVar6 != (char *)0x0) {
      for (; uVar7 != 0; uVar7 = uVar7 - 1) {
        *pcVar5 = *param_2;
        param_2 = param_2 + (ulong)bVar9 * -2 + 1;
        pcVar5 = pcVar5 + (ulong)bVar9 * -2 + 1;
      }
      pcVar6[extraout_RDX] = '\0';
      return pcVar6;
    }
  }
  else {
    uVar8 = (long)pcVar4 - (long)pcVar5;
    lVar1 = uVar8 + extraout_RDX;
    uVar7 = extraout_RDX;
    if (extraout_RDX <= uVar8) {
      uVar7 = uVar8;
    }
    __size = lVar1 + 1;
    if (__size < uVar7) {
      uVar3 = dcgettext(0,"Abnormal length of thin archive member name: %lx\n",5);
      error(uVar3,extraout_RDX);
      return (char *)0x0;
    }
    pcVar4 = (char *)malloc(__size);
    pcVar6 = pcVar4;
    if (pcVar4 != (char *)0x0) {
      for (; uVar7 = extraout_RDX, uVar8 != 0; uVar8 = uVar8 - 1) {
        *pcVar6 = *pcVar5;
        pcVar5 = pcVar5 + (ulong)bVar9 * -2 + 1;
        pcVar6 = pcVar6 + (ulong)bVar9 * -2 + 1;
      }
      for (; uVar7 != 0; uVar7 = uVar7 - 1) {
        *pcVar6 = *param_2;
        param_2 = param_2 + (ulong)bVar9 * -2 + 1;
        pcVar6 = pcVar6 + (ulong)bVar9 * -2 + 1;
      }
      pcVar4[lVar1] = '\0';
      return pcVar4;
    }
  }
  uVar3 = dcgettext(0,"Out of memory\n",5);
  error(uVar3);
  return (char *)0x0;
}


////>>0x00105394>>_fini>>////

void _fini(void)

{
  return;
}


////>>0x0010a000>>free>>////




void free(void *__ptr)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* free@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a008>>strcasecmp>>////




int strcasecmp(char *__s1,char *__s2)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* strcasecmp@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a010>>__libc_start_main>>////



void __libc_start_main(void)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* __libc_start_main@GLIBC_2.34 */
  halt_baddata();
}


////>>0x0010a018>>abort>>////




void abort(void)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* abort@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a020>>__errno_location>>////




int * __errno_location(void)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* __errno_location@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a028>>strncmp>>////




int strncmp(char *__s1,char *__s2,size_t __n)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* strncmp@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a040>>ferror>>////




int ferror(FILE *__stream)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* ferror@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a048>>fread>>////




size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* fread@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a050>>textdomain>>////



void textdomain(void)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* textdomain@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a058>>fclose>>////




int fclose(FILE *__stream)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* fclose@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a068>>bindtextdomain>>////



void bindtextdomain(void)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* bindtextdomain@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a070>>dcgettext>>////



void dcgettext(void)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* dcgettext@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a078>>strlen>>////




size_t strlen(char *__s)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* strlen@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a080>>mmap>>////




void * mmap(void *__addr,size_t __len,int __prot,int __flags,int __fd,__off_t __offset)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* mmap@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a088>>getopt_long>>////



void getopt_long(void)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* getopt_long@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a090>>printf>>////




int printf(char *__format,...)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* printf@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a098>>rewind>>////




void rewind(FILE *__stream)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* rewind@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a0a0>>snprintf>>////




int snprintf(char *__s,size_t __maxlen,char *__format,...)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* snprintf@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a0a8>>sbrk>>////




void * sbrk(intptr_t __delta)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* sbrk@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a0b0>>strcmp>>////




int strcmp(char *__s1,char *__s2)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* strcmp@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a0c0>>fprintf>>////




int fprintf(FILE *__stream,char *__format,...)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* fprintf@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a0c8>>ftell>>////




long ftell(FILE *__stream)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* ftell@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a0d8>>stat>>////




int stat(char *__file,stat *__buf)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* stat@GLIBC_2.33 */
  halt_baddata();
}


////>>0x0010a0e8>>memcpy>>////




void * memcpy(void *__dest,void *__src,size_t __n)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* memcpy@GLIBC_2.14 */
  halt_baddata();
}


////>>0x0010a0f0>>fileno>>////




int fileno(FILE *__stream)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* fileno@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a0f8>>malloc>>////




void * malloc(size_t __size)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* malloc@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a100>>fflush>>////




int fflush(FILE *__stream)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* fflush@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a108>>fseek>>////




int fseek(FILE *__stream,long __off,int __whence)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* fseek@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a110>>realloc>>////




void * realloc(void *__ptr,size_t __size)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* realloc@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a118>>munmap>>////




int munmap(void *__addr,size_t __len)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* munmap@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a120>>setlocale>>////




char * setlocale(int __category,char *__locale)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* setlocale@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a128>>memmove>>////




void * memmove(void *__dest,void *__src,size_t __n)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* memmove@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a130>>fopen>>////




FILE * fopen(char *__filename,char *__modes)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* fopen@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a138>>vfprintf>>////




int vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* vfprintf@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a140>>strtoul>>////




ulong strtoul(char *__nptr,char **__endptr,int __base)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* strtoul@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a150>>exit>>////




void exit(int __status)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* exit@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a158>>fwrite>>////




size_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* fwrite@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a168>>strdup>>////




char * strdup(char *__s)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* strdup@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a170>>strerror>>////




char * strerror(int __errnum)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* strerror@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a178>>fstat>>////




int fstat(int __fd,stat *__buf)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* fstat@GLIBC_2.33 */
  halt_baddata();
}


////>>0x0010a180>>getc>>////




int getc(FILE *__stream)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* getc@GLIBC_2.2.5 */
  halt_baddata();
}


////>>0x0010a190>>__cxa_finalize>>////



void __cxa_finalize(void)

{
                    /* WARNING: Bad instruction - Truncating control flow here */
                    /* __cxa_finalize@GLIBC_2.2.5 */
  halt_baddata();
}

