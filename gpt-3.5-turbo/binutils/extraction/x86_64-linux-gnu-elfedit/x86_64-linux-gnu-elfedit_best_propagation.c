java.nio.HeapByteBuffer[pos=0 lim=0 cap=0]
////>>0x00102000>>FUN_00102000>>////

void FUN_00102000(void)

{
  __gmon_start__();
  return;
}


////>>0x00102020>>FUN_00102020>>////

void FUN_00102020(void)

{
                    /* WARNING: Treating indirect jump as call */
  (*(code *)(undefined *)0x0)();
  return;
}


////>>0x00102030>>FUN_00102030>>////



void free(void *__ptr)

{
  free(__ptr);
  return;
}


////>>0x00102040>>FUN_00102040>>////



int strcasecmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcasecmp(__s1,__s2);
  return iVar1;
}


////>>0x00102050>>FUN_00102050>>////



void abort(void)

{
                    
  abort();
}


////>>0x00102060>>FUN_00102060>>////



int * __errno_location(void)

{
  int *piVar1;
  
  piVar1 = __errno_location();
  return piVar1;
}


////>>0x00102070>>FUN_00102070>>////



int strncmp(char *__s1,char *__s2,size_t __n)

{
  int iVar1;
  
  iVar1 = strncmp(__s1,__s2,__n);
  return iVar1;
}


////>>0x00102080>>FUN_00102080>>////



int ferror(FILE *__stream)

{
  int iVar1;
  
  iVar1 = ferror(__stream);
  return iVar1;
}


////>>0x00102090>>FUN_00102090>>////



size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)

{
  size_t sVar1;
  
  sVar1 = fread(__ptr,__size,__n,__stream);
  return sVar1;
}


////>>0x001020a0>>FUN_001020a0>>////

void textdomain(void)

{
  textdomain();
  return;
}


////>>0x001020b0>>FUN_001020b0>>////



int fclose(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fclose(__stream);
  return iVar1;
}


////>>0x001020c0>>FUN_001020c0>>////

void bindtextdomain(void)

{
  bindtextdomain();
  return;
}


////>>0x001020d0>>FUN_001020d0>>////

void dcgettext(void)

{
  dcgettext();
  return;
}


////>>0x001020e0>>FUN_001020e0>>////



size_t strlen(char *__s)

{
  size_t sVar1;
  
  sVar1 = strlen(__s);
  return sVar1;
}


////>>0x001020f0>>FUN_001020f0>>////



void * mmap(void *__addr,size_t __len,int __prot,int __flags,int __fd,__off_t __offset)

{
  void *pvVar1;
  
  pvVar1 = mmap(__addr,__len,__prot,__flags,__fd,__offset);
  return pvVar1;
}


////>>0x00102100>>FUN_00102100>>////

void getopt_long(void)

{
  getopt_long();
  return;
}


////>>0x00102110>>FUN_00102110>>////



int printf(char *__format,...)

{
  int iVar1;
  
  iVar1 = printf(__format);
  return iVar1;
}


////>>0x00102120>>FUN_00102120>>////



void rewind(FILE *__stream)

{
  rewind(__stream);
  return;
}


////>>0x00102130>>FUN_00102130>>////



int snprintf(char *__s,size_t __maxlen,char *__format,...)

{
  int iVar1;
  
  iVar1 = snprintf(__s,__maxlen,__format);
  return iVar1;
}


////>>0x00102140>>FUN_00102140>>////



void * sbrk(intptr_t __delta)

{
  void *pvVar1;
  
  pvVar1 = sbrk(__delta);
  return pvVar1;
}


////>>0x00102150>>FUN_00102150>>////



int strcmp(char *__s1,char *__s2)

{
  int iVar1;
  
  iVar1 = strcmp(__s1,__s2);
  return iVar1;
}


////>>0x00102160>>FUN_00102160>>////



int fprintf(FILE *__stream,char *__format,...)

{
  int iVar1;
  
  iVar1 = fprintf(__stream,__format);
  return iVar1;
}


////>>0x00102170>>FUN_00102170>>////



long ftell(FILE *__stream)

{
  long lVar1;
  
  lVar1 = ftell(__stream);
  return lVar1;
}


////>>0x00102180>>FUN_00102180>>////



int stat(char *__file,stat *__buf)

{
  int iVar1;
  
  iVar1 = stat(__file,__buf);
  return iVar1;
}


////>>0x00102190>>FUN_00102190>>////



void * memcpy(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memcpy(__dest,__src,__n);
  return pvVar1;
}


////>>0x001021a0>>FUN_001021a0>>////



int fileno(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fileno(__stream);
  return iVar1;
}


////>>0x001021b0>>FUN_001021b0>>////



void * malloc(size_t __size)

{
  void *pvVar1;
  
  pvVar1 = malloc(__size);
  return pvVar1;
}


////>>0x001021c0>>FUN_001021c0>>////



int fflush(FILE *__stream)

{
  int iVar1;
  
  iVar1 = fflush(__stream);
  return iVar1;
}


////>>0x001021d0>>FUN_001021d0>>////



int fseek(FILE *__stream,long __off,int __whence)

{
  int iVar1;
  
  iVar1 = fseek(__stream,__off,__whence);
  return iVar1;
}


////>>0x001021e0>>FUN_001021e0>>////



void * realloc(void *__ptr,size_t __size)

{
  void *pvVar1;
  
  pvVar1 = realloc(__ptr,__size);
  return pvVar1;
}


////>>0x001021f0>>FUN_001021f0>>////



int munmap(void *__addr,size_t __len)

{
  int iVar1;
  
  iVar1 = munmap(__addr,__len);
  return iVar1;
}


////>>0x00102200>>FUN_00102200>>////



char * setlocale(int __category,char *__locale)

{
  char *pcVar1;
  
  pcVar1 = setlocale(__category,__locale);
  return pcVar1;
}


////>>0x00102210>>FUN_00102210>>////



void * memmove(void *__dest,void *__src,size_t __n)

{
  void *pvVar1;
  
  pvVar1 = memmove(__dest,__src,__n);
  return pvVar1;
}


////>>0x00102220>>FUN_00102220>>////



FILE * fopen(char *__filename,char *__modes)

{
  FILE *pFVar1;
  
  pFVar1 = fopen(__filename,__modes);
  return pFVar1;
}


////>>0x00102230>>FUN_00102230>>////



int vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)

{
  int iVar1;
  
  iVar1 = vfprintf(__s,__format,__arg);
  return iVar1;
}


////>>0x00102240>>FUN_00102240>>////



ulong strtoul(char *__nptr,char **__endptr,int __base)

{
  ulong uVar1;
  
  uVar1 = strtoul(__nptr,__endptr,__base);
  return uVar1;
}


////>>0x00102250>>FUN_00102250>>////



void exit(int __status)

{
                    
  exit(__status);
}


////>>0x00102260>>FUN_00102260>>////



size_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)

{
  size_t sVar1;
  
  sVar1 = fwrite(__ptr,__size,__n,__s);
  return sVar1;
}


////>>0x00102270>>FUN_00102270>>////



char * strdup(char *__s)

{
  char *pcVar1;
  
  pcVar1 = strdup(__s);
  return pcVar1;
}


////>>0x00102280>>FUN_00102280>>////



char * strerror(int __errnum)

{
  char *pcVar1;
  
  pcVar1 = strerror(__errnum);
  return pcVar1;
}


////>>0x00102290>>FUN_00102290>>////



int fstat(int __fd,stat *__buf)

{
  int iVar1;
  
  iVar1 = fstat(__fd,__buf);
  return iVar1;
}


////>>0x001022a0>>FUN_001022a0>>////



int getc(FILE *__stream)

{
  int iVar1;
  
  iVar1 = getc(__stream);
  return iVar1;
}


////>>0x001022b0>>FUN_001022b0>>////

void __cxa_finalize(void)

{
  __cxa_finalize();
  return;
}


////>>0x001022c0>>FUN_001022c0>>////

undefined  [16] FUN_001022c0(void)

{
  int iVar1;
  uint uVar2;
  undefined8 uVar3;
  char *unaff_RBX;
  int unaff_EBP;
  undefined auVar4 [16];
  undefined8 unaff_retaddr;
  
  iVar1 = strcasecmp(unaff_RBX,"lam_u48");
  if (iVar1 == 0) {
    uVar2 = 4;
  }
  else {
    iVar1 = strcasecmp(unaff_RBX,"lam_u57");
    uVar2 = 8;
    if (iVar1 != 0) {
      uVar3 = dcgettext(0,"Unknown x86 feature: %s\n",5);
      error(uVar3);
      uVar3 = 0xffffffff;
      goto LAB_00104ca5;
    }
  }
  if (unaff_EBP == 0) {
    DAT_00109440 = uVar2 | DAT_00109440;
    DAT_00109444 = ~uVar2 & DAT_00109444;
  }
  else {
    DAT_00109444 = uVar2 | DAT_00109444;
    DAT_00109440 = DAT_00109440 & ~uVar2;
  }
  uVar3 = 0;
LAB_00104ca5:
  auVar4._8_8_ = unaff_retaddr;
  auVar4._0_8_ = uVar3;
  return auVar4;
}


////>>0x00102323>>FUN_00102323>>////

undefined  [16] FUN_00102323(void)

{
  undefined8 uVar1;
  undefined auVar2 [16];
  undefined8 unaff_retaddr;
  
  uVar1 = dcgettext(0,"Unknown OSABI: %s\n",5);
  error(uVar1);
  auVar2._8_8_ = unaff_retaddr;
  auVar2._0_8_ = 0xffffffff;
  return auVar2;
}


////>>0x0010234b>>FUN_0010234b>>////

int FUN_0010234b(void)

{
  int iVar1;
  undefined8 uVar2;
  char *unaff_RBX;
  
  iVar1 = strcasecmp(unaff_RBX,"x86_64");
  if (iVar1 == 0) {
    iVar1 = 0x3e;
  }
  else {
    iVar1 = strcasecmp(unaff_RBX,"x86-64");
    if (iVar1 == 0) {
      iVar1 = 0x3e;
    }
    else {
      iVar1 = strcasecmp(unaff_RBX,"none");
      if (iVar1 != 0) {
        uVar2 = dcgettext(0,"Unknown machine type: %s\n",5);
        error(uVar2);
        iVar1 = -1;
      }
    }
  }
  return iVar1;
}


////>>0x001023ce>>FUN_001023ce>>////

undefined8 FUN_001023ce(void)

{
  return 1;
}


////>>0x00102434>>FUN_00102434>>////

undefined8 FUN_00102434(void)

{
  undefined8 uVar1;
  size_t sVar2;
  FILE *unaff_RBX;
  char *pcVar3;
  
  uVar1 = dcgettext(0,"%s: Failed to seek to ELF header\n",5);
  error(uVar1);
  if (DAT_001093e6 == '\x01') {
    if (DAT_0010941a == DAT_0010916c) {
      return 0;
    }
    if (DAT_00109170 == 0xffffffff) {
      if (DAT_0010941a == 6) {
        DAT_00109170 = 1;
      }
      else if (DAT_0010941a < 7) {
        DAT_00109170 = (DAT_0010941a != 3) + 1 + (uint)(DAT_0010941a != 3);
      }
      else {
        DAT_00109170 = 3 - ((ushort)(DAT_0010941a - 0xb4) < 2);
      }
    }
    if ((DAT_001093e4 == DAT_00109170) || (DAT_00109170 == 3)) {
      if ((DAT_001093e4 == DAT_00109168) || (DAT_00109168 == 3)) {
        if ((DAT_0010941a == DAT_00109174) || (DAT_00109174 == 0xffffffff)) {
          if ((DAT_00109164 == 0xffffffff) || (DAT_00109418 == DAT_00109164)) {
            if ((DAT_0010915c == 0xffffffff) || (DAT_001093e7 == DAT_0010915c)) {
              if ((DAT_001093e8 == DAT_00109154) || (DAT_00109154 == 0xffffffff)) {
                if (DAT_001093e4 == 1) {
                  if (DAT_0010916c != 0xffffffff) {
                    (*DAT_001093b8)(&DAT_00109392,(long)(int)DAT_0010916c,2);
                  }
                  if (DAT_00109160 != -1) {
                    (*DAT_001093b8)(&DAT_00109390,(long)DAT_00109160,2);
                  }
                  if (DAT_00109158 != -1) {
                    DAT_00109387 = (undefined)DAT_00109158;
                  }
                  if (DAT_00109150 != -1) {
                    DAT_00109388 = (undefined)DAT_00109150;
                  }
                  sVar2 = fwrite(&DAT_00109380,0x34,1,unaff_RBX);
                  if (sVar2 == 1) {
                    return 0;
                  }
                  uVar1 = FUN_001024ec();
                  return uVar1;
                }
                if (DAT_001093e4 != 2) {
                    
                  abort();
                }
                if (DAT_0010916c != 0xffffffff) {
                  (*DAT_001093b8)(&DAT_00109352,(long)(int)DAT_0010916c,2);
                }
                if (DAT_00109160 != -1) {
                  (*DAT_001093b8)(&DAT_00109350,(long)DAT_00109160,2);
                }
                if (DAT_00109158 != -1) {
                  DAT_00109347 = (undefined)DAT_00109158;
                }
                if (DAT_00109150 != -1) {
                  DAT_00109348 = (undefined)DAT_00109150;
                }
                sVar2 = fwrite(&DAT_00109340,0x40,1,unaff_RBX);
                if (sVar2 == 1) {
                  return 0;
                }
                uVar1 = FUN_001024ec();
                return uVar1;
              }
              pcVar3 = "%s: Unmatched EI_ABIVERSION: %d is not %d\n";
            }
            else {
              pcVar3 = "%s: Unmatched EI_OSABI: %d is not %d\n";
            }
          }
          else {
            pcVar3 = "%s: Unmatched e_type: %d is not %d\n";
          }
        }
        else {
          pcVar3 = "%s: Unmatched e_machine: %d is not %d\n";
        }
        uVar1 = dcgettext(0,pcVar3,5);
        error(uVar1);
        return 1;
      }
      pcVar3 = "%s: Unmatched output EI_CLASS: %d is not %d\n";
    }
    else {
      pcVar3 = "%s: Unmatched input EI_CLASS: %d is not %d\n";
    }
    uVar1 = dcgettext(0,pcVar3,5);
    error(uVar1);
  }
  else {
    uVar1 = dcgettext(0,"%s: Unsupported EI_VERSION: %d is not %d\n",5);
    error(uVar1);
  }
  return 1;
}


////>>0x001024ec>>FUN_001024ec>>////

undefined8 FUN_001024ec(void)

{
  int *piVar1;
  undefined8 uVar2;
  
  piVar1 = __errno_location();
  strerror(*piVar1);
  uVar2 = dcgettext(0,"%s: Failed to update ELF header: %s\n",5);
  error(uVar2);
  return 1;
}


////>>0x00102558>>FUN_00102558>>////

undefined8 FUN_00102558(void)

{
  undefined8 uVar1;
  
  uVar1 = dcgettext(0,"%s: Failed to read ELF header\n",5);
  error(uVar1);
  return 1;
}


////>>0x001025ab>>FUN_001025ab>>////

undefined4 FUN_001025ab(char **param_1,char *param_2,FILE *param_3,long param_4,undefined4 param_5)

{
  char **__ptr;
  undefined uVar1;
  char cVar2;
  int iVar3;
  char *pcVar4;
  size_t sVar5;
  undefined8 uVar6;
  char *pcVar7;
  
  pcVar4 = strdup(param_2);
  param_1[2] = (char *)0x0;
  *(undefined4 *)((long)param_1 + 0x54) = 0;
  *param_1 = pcVar4;
  param_1[1] = (char *)param_3;
  param_1[5] = (char *)0x0;
  param_1[6] = (char *)0x0;
  *(undefined4 *)(param_1 + 10) = param_5;
  param_1[9] = (char *)0x8;
  *(undefined (*) [16])(param_1 + 3) = ZEXT816(0);
  *(undefined (*) [16])(param_1 + 7) = ZEXT816(0);
  iVar3 = fseek(param_3,8,0);
  pcVar4 = "%s: failed to seek to first archive header\n";
  if (iVar3 != 0) goto LAB_00102658;
  __ptr = param_1 + 0xb;
  sVar5 = fread(__ptr,1,0x3c,param_3);
  if (sVar5 != 0x3c) {
    if (sVar5 == 0) {
      return 0;
    }
    pcVar4 = "%s: failed to read archive header\n";
    goto LAB_00102658;
  }
  cVar2 = startswith(__ptr,"/               ");
  if (cVar2 == '\0') {
    cVar2 = startswith(__ptr,"/SYM64/         ");
    if (cVar2 != '\0') {
      *(undefined4 *)((long)param_1 + 0x54) = 1;
      iVar3 = process_archive_index_and_symbols_constprop_0(param_1,8);
      goto joined_r0x001026dd;
    }
  }
  else {
    iVar3 = process_archive_index_and_symbols_constprop_0(param_1,4);
joined_r0x001026dd:
    if (iVar3 == 0) {
      return 1;
    }
  }
  cVar2 = startswith(__ptr);
  if (cVar2 == '\0') {
    return 0;
  }
  uVar1 = *(undefined *)((long)param_1 + 0x92);
  *(undefined *)((long)param_1 + 0x92) = 0;
  pcVar4 = (char *)strtoul((char *)(param_1 + 0x11),(char **)0x0,10);
  pcVar7 = "%s: long name table is too small, (size = %ld)\n";
  param_1[7] = pcVar4;
  *(undefined *)((long)param_1 + 0x92) = uVar1;
  if ((char *)0x7 < pcVar4) {
    if (((long)pcVar4 <= param_4) && (-1 < (long)pcVar4)) {
      param_1[9] = pcVar4 + 0x3c + (long)param_1[9];
      pcVar7 = (char *)malloc((size_t)(pcVar4 + 1));
      param_1[6] = pcVar7;
      if (pcVar7 == (char *)0x0) {
        uVar6 = dcgettext(0,"Out of memory reading long symbol names in archive\n",5);
        error(uVar6);
        return 1;
      }
      sVar5 = fread(pcVar7,(size_t)pcVar4,1,param_3);
      if (sVar5 == 1) {
        if ((*(byte *)(param_1 + 7) & 1) != 0) {
          getc(param_3);
        }
        param_1[6][(long)param_1[7]] = '\0';
        return 0;
      }
      free(param_1[6]);
      pcVar4 = "%s: failed to read long symbol name string table\n";
      param_1[6] = (char *)0x0;
LAB_00102658:
      uVar6 = dcgettext(0,pcVar4,5);
      error(uVar6,param_2);
      return 1;
    }
    pcVar7 = "%s: long name table is too big, (size = %#lx)\n";
  }
  uVar6 = dcgettext(0,pcVar7,5);
  error(uVar6,param_2,pcVar4);
  return 1;
}


////>>0x001027fd>>FUN_001027fd>>////

undefined  [16] FUN_001027fd(char *param_1,char *param_2)

{
  int iVar1;
  undefined8 in_RAX;
  size_t __n;
  undefined4 extraout_var;
  undefined auVar2 [16];
  
  __n = strlen(param_2);
  iVar1 = strncmp(param_1,param_2,__n);
  auVar2._1_7_ = (undefined7)(CONCAT44(extraout_var,iVar1) >> 8);
  auVar2[0] = iVar1 == 0;
  auVar2._8_8_ = in_RAX;
  return auVar2;
}


////>>0x00102825>>FUN_00102825>>////

void switchD_00103aac::FUN_00102825(long param_1,undefined8 param_2)

{
  FUN_00103ab3(param_1,param_2,
               (ulong)*(byte *)(param_1 + 1) << 8 | (ulong)*(byte *)(param_1 + 2) << 0x10);
  return;
}


////>>0x0010289a>>FUN_0010289a>>////

void switchD_00103aac::FUN_0010289a(void)

{
  undefined8 uVar1;
  undefined4 unaff_EBX;
  
  uVar1 = dcgettext(0,"Unhandled data length: %d\n",5);
  error(uVar1,unaff_EBX);
                    
  abort();
}


////>>0x001028be>>FUN_001028be>>////

undefined8 FUN_001028be(undefined8 *param_1)

{
  undefined uVar1;
  int iVar2;
  ulong uVar3;
  undefined8 uVar4;
  size_t sVar5;
  undefined8 uVar6;
  char *pcVar7;
  
  uVar1 = *(undefined *)((long)param_1 + 0x92);
  *(undefined *)((long)param_1 + 0x92) = 0;
  uVar3 = strtoul((char *)(param_1 + 0x11),(char **)0x0,10);
  *(undefined *)((long)param_1 + 0x92) = uVar1;
  if ((long)uVar3 < 0) {
    uVar6 = *param_1;
    uVar4 = dcgettext(0,"%s: invalid archive header size: %ld\n",5);
    error(uVar4,uVar6,uVar3);
  }
  else {
    uVar3 = uVar3 + 1 & 0xfffffffffffffffe;
    param_1[9] = uVar3 + 0x3c + param_1[9];
    iVar2 = fseek((FILE *)param_1[1],uVar3,1);
    if (iVar2 == 0) {
      sVar5 = fread(param_1 + 0xb,1,0x3c,(FILE *)param_1[1]);
      if ((sVar5 == 0x3c) || (sVar5 == 0)) {
        return 1;
      }
      uVar6 = *param_1;
      pcVar7 = "%s: failed to read archive header following archive index\n";
    }
    else {
      uVar6 = *param_1;
      pcVar7 = "%s: failed to skip archive symbol table\n";
    }
    uVar4 = dcgettext(0,pcVar7,5);
    error(uVar4,uVar6);
  }
  return 0;
}


////>>0x001029a5>>FUN_001029a5>>////

undefined4 * FUN_001029a5(undefined8 *param_1,char **param_2)

{
  undefined uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  int iVar6;
  ulong uVar7;
  ulong uVar8;
  ulong uVar9;
  undefined8 uVar10;
  FILE *__stream;
  size_t sVar11;
  undefined4 *puVar12;
  long lVar13;
  char *pcVar14;
  char *pcVar15;
  char *pcVar16;
  char *local_c0;
  stat local_b8;
  
  if (*(char *)(param_1 + 0xb) != '/') {
    lVar13 = 0;
    do {
      if (*(char *)((long)param_1 + lVar13 + 0x58) == '/') {
        *(undefined *)((long)param_1 + lVar13 + 0x58) = 0;
        puVar12 = (undefined4 *)xstrdup(param_1 + 0xb);
        return puVar12;
      }
      lVar13 = lVar13 + 1;
    } while (lVar13 != 0x10);
    puVar12 = (undefined4 *)xmalloc(0x11);
    uVar2 = *(undefined4 *)(param_1 + 0xb);
    uVar3 = *(undefined4 *)((long)param_1 + 0x5c);
    uVar4 = *(undefined4 *)(param_1 + 0xc);
    uVar5 = *(undefined4 *)((long)param_1 + 100);
    *(undefined *)(puVar12 + 4) = 0;
    *puVar12 = uVar2;
    puVar12[1] = uVar3;
    puVar12[2] = uVar4;
    puVar12[3] = uVar5;
    return puVar12;
  }
  if ((param_1[6] == 0) || (param_1[7] == 0)) {
    pcVar15 = "Archive member uses long names, but no longname table found\n";
LAB_00102acd:
    uVar10 = dcgettext(0,pcVar15,5);
    error(uVar10);
    return (undefined4 *)0x0;
  }
  uVar1 = *(undefined *)((long)param_1 + 0x92);
  param_1[8] = 0;
  *(undefined *)((long)param_1 + 0x92) = 0;
  uVar7 = strtoul((char *)((long)param_1 + 0x59),&local_c0,10);
  if (((*(int *)(param_1 + 10) != 0) && (local_c0 != (char *)0x0)) && (*local_c0 == ':')) {
    uVar8 = strtoul(local_c0 + 1,(char **)0x0,10);
    param_1[8] = uVar8;
  }
  uVar8 = param_1[7];
  *(undefined *)((long)param_1 + 0x92) = uVar1;
  if (uVar8 < uVar7) {
    uVar10 = dcgettext(0,"Found long name index (%ld) beyond end of long name table\n",5);
    error(uVar10,uVar7);
    return (undefined4 *)0x0;
  }
  lVar13 = param_1[6];
  for (uVar9 = uVar7;
      ((uVar8 != uVar9 && (*(char *)(lVar13 + uVar9) != '\0')) &&
      (*(char *)(lVar13 + uVar9) != '\n')); uVar9 = uVar9 + 1) {
  }
  if ((uVar9 != 0) && (*(char *)(lVar13 + -1 + uVar9) == '/')) {
    uVar9 = uVar9 - 1;
  }
  if (uVar9 < uVar8) {
    uVar8 = uVar9;
  }
  *(undefined *)(lVar13 + uVar8) = 0;
  if ((*(int *)(param_1 + 10) == 0) || (param_1[8] == 0)) goto LAB_00102c2d;
  if (uVar8 <= uVar7) {
    pcVar15 = "Invalid Thin archive member name\n";
    goto LAB_00102acd;
  }
  pcVar15 = (char *)adjust_relative_path(*param_1,param_1[6] + uVar7,uVar8 - uVar7);
  if (pcVar15 != (char *)0x0) {
    if ((*param_2 == (char *)0x0) || (iVar6 = strcmp(*param_2,pcVar15), iVar6 != 0)) {
      if ((FILE *)param_2[1] != (FILE *)0x0) {
        fclose((FILE *)param_2[1]);
        param_2[1] = (char *)0x0;
      }
      release_archive(param_2);
      __stream = fopen(pcVar15,"rb");
      if (__stream != (FILE *)0x0) {
        iVar6 = fileno(__stream);
        iVar6 = fstat(iVar6,&local_b8);
        if ((-1 < iVar6) &&
           (iVar6 = setup_archive_constprop_0(param_2,pcVar15,__stream,local_b8.st_size,0),
           iVar6 == 0)) goto LAB_00102b84;
      }
    }
    else {
LAB_00102b84:
      iVar6 = fseek((FILE *)param_2[1],param_1[8],0);
      if (iVar6 == 0) {
        sVar11 = fread(param_2 + 0xb,1,0x3c,(FILE *)param_2[1]);
        if (sVar11 == 0x3c) {
          if (*(short *)((long)param_2 + 0x92) == 0xa60) {
            puVar12 = (undefined4 *)FUN_001029a5(param_2,0);
            if (puVar12 != (undefined4 *)0x0) {
              free(pcVar15);
              return puVar12;
            }
            goto LAB_00102c25;
          }
          pcVar14 = *param_2;
          pcVar16 = "%s: did not find a valid archive header\n";
        }
        else {
          pcVar14 = *param_2;
          pcVar16 = "%s: failed to read archive header\n";
        }
      }
      else {
        pcVar14 = *param_2;
        pcVar16 = "%s: failed to seek to next file name\n";
      }
      uVar10 = dcgettext(0,pcVar16,5);
      error(uVar10,pcVar14);
    }
  }
LAB_00102c25:
  free(pcVar15);
LAB_00102c2d:
  puVar12 = (undefined4 *)xstrdup(param_1[6] + uVar7);
  return puVar12;
}


////>>0x00102c98>>FUN_00102c98>>////

void FUN_00102c98(void)

{
  undefined8 uVar1;
  undefined4 unaff_EBX;
  
  uVar1 = dcgettext(0,"Unhandled data length: %d\n",5);
  error(uVar1,unaff_EBX);
                    
  abort();
}


////>>0x00102cbc>>FUN_00102cbc>>////

char * FUN_00102cbc(undefined8 param_1,char *param_2)

{
  ulong __size;
  long lVar1;
  char cVar2;
  char *pcVar3;
  char *pcVar4;
  undefined8 uVar5;
  ulong uVar6;
  ulong extraout_RDX;
  char *unaff_RBX;
  ulong uVar7;
  byte bVar8;
  
  bVar8 = 0;
  xmalloc_failed();
  pcVar3 = unaff_RBX;
  pcVar4 = unaff_RBX;
  while (cVar2 = *pcVar3, cVar2 != '\0') {
    pcVar3 = pcVar3 + 1;
    if (cVar2 == '/') {
      pcVar4 = pcVar3;
    }
  }
  if ((*param_2 == '/') || (unaff_RBX == pcVar4)) {
    if (extraout_RDX + 1 == 0) {
      return (char *)0x0;
    }
    pcVar4 = (char *)malloc(extraout_RDX + 1);
    uVar6 = extraout_RDX;
    pcVar3 = pcVar4;
    if (pcVar4 != (char *)0x0) {
      for (; uVar6 != 0; uVar6 = uVar6 - 1) {
        *pcVar3 = *param_2;
        param_2 = param_2 + (ulong)bVar8 * -2 + 1;
        pcVar3 = pcVar3 + (ulong)bVar8 * -2 + 1;
      }
      pcVar4[extraout_RDX] = '\0';
      return pcVar4;
    }
  }
  else {
    uVar7 = (long)pcVar4 - (long)unaff_RBX;
    lVar1 = uVar7 + extraout_RDX;
    uVar6 = extraout_RDX;
    if (extraout_RDX <= uVar7) {
      uVar6 = uVar7;
    }
    __size = lVar1 + 1;
    if (__size < uVar6) {
      uVar5 = dcgettext(0,"Abnormal length of thin archive member name: %lx\n",5);
      error(uVar5,extraout_RDX);
      return (char *)0x0;
    }
    pcVar4 = (char *)malloc(__size);
    pcVar3 = pcVar4;
    if (pcVar4 != (char *)0x0) {
      for (; uVar6 = extraout_RDX, uVar7 != 0; uVar7 = uVar7 - 1) {
        *pcVar3 = *unaff_RBX;
        unaff_RBX = unaff_RBX + (ulong)bVar8 * -2 + 1;
        pcVar3 = pcVar3 + (ulong)bVar8 * -2 + 1;
      }
      for (; uVar6 != 0; uVar6 = uVar6 - 1) {
        *pcVar3 = *param_2;
        param_2 = param_2 + (ulong)bVar8 * -2 + 1;
        pcVar3 = pcVar3 + (ulong)bVar8 * -2 + 1;
      }
      pcVar4[lVar1] = '\0';
      return pcVar4;
    }
  }
  uVar5 = dcgettext(0,"Out of memory\n",5);
  error(uVar5);
  return (char *)0x0;
}


////>>0x00102cc4>>FUN_00102cc4>>////

char * FUN_00102cc4(char *param_1,char *param_2,ulong param_3)

{
  ulong __size;
  long lVar1;
  char cVar2;
  char *pcVar3;
  char *pcVar4;
  undefined8 uVar5;
  ulong uVar6;
  ulong uVar7;
  byte bVar8;
  
  bVar8 = 0;
  pcVar3 = param_1;
  pcVar4 = param_1;
  while (cVar2 = *pcVar3, cVar2 != '\0') {
    pcVar3 = pcVar3 + 1;
    if (cVar2 == '/') {
      pcVar4 = pcVar3;
    }
  }
  if ((*param_2 == '/') || (param_1 == pcVar4)) {
    if (param_3 + 1 == 0) {
      return (char *)0x0;
    }
    pcVar4 = (char *)malloc(param_3 + 1);
    uVar6 = param_3;
    pcVar3 = pcVar4;
    if (pcVar4 != (char *)0x0) {
      for (; uVar6 != 0; uVar6 = uVar6 - 1) {
        *pcVar3 = *param_2;
        param_2 = param_2 + (ulong)bVar8 * -2 + 1;
        pcVar3 = pcVar3 + (ulong)bVar8 * -2 + 1;
      }
      pcVar4[param_3] = '\0';
      return pcVar4;
    }
  }
  else {
    uVar7 = (long)pcVar4 - (long)param_1;
    lVar1 = uVar7 + param_3;
    uVar6 = param_3;
    if (param_3 <= uVar7) {
      uVar6 = uVar7;
    }
    __size = lVar1 + 1;
    if (__size < uVar6) {
      uVar5 = dcgettext(0,"Abnormal length of thin archive member name: %lx\n",5);
      error(uVar5,param_3);
      return (char *)0x0;
    }
    pcVar4 = (char *)malloc(__size);
    pcVar3 = pcVar4;
    if (pcVar4 != (char *)0x0) {
      for (; uVar7 != 0; uVar7 = uVar7 - 1) {
        *pcVar3 = *param_1;
        param_1 = param_1 + (ulong)bVar8 * -2 + 1;
        pcVar3 = pcVar3 + (ulong)bVar8 * -2 + 1;
      }
      for (; param_3 != 0; param_3 = param_3 - 1) {
        *pcVar3 = *param_2;
        param_2 = param_2 + (ulong)bVar8 * -2 + 1;
        pcVar3 = pcVar3 + (ulong)bVar8 * -2 + 1;
      }
      pcVar4[lVar1] = '\0';
      return pcVar4;
    }
  }
  uVar5 = dcgettext(0,"Out of memory\n",5);
  error(uVar5);
  return (char *)0x0;
}


////>>0x00102da5>>FUN_00102da5>>////



void FUN_00102da5(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
                 char *param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,
                 undefined8 param_13,undefined8 param_14)

{
  char in_AL;
  char *__format;
  undefined4 local_e0;
  undefined4 local_dc;
  undefined *local_d8;
  undefined *local_d0;
  undefined local_c8 [8];
  undefined8 local_c0;
  undefined8 local_b8;
  undefined8 local_b0;
  undefined8 local_a8;
  undefined8 local_a0;
  undefined4 local_98;
  undefined4 local_88;
  undefined4 local_78;
  undefined4 local_68;
  undefined4 local_58;
  undefined4 local_48;
  undefined4 local_38;
  undefined4 local_28;
  
  if (in_AL != '\0') {
    local_98 = param_1;
    local_88 = param_2;
    local_78 = param_3;
    local_68 = param_4;
    local_58 = param_5;
    local_48 = param_6;
    local_38 = param_7;
    local_28 = param_8;
  }
  local_c0 = param_10;
  local_b8 = param_11;
  local_b0 = param_12;
  local_a8 = param_13;
  local_a0 = param_14;
  fflush(_stdout);
  local_d8 = &stack0x00000008;
  local_d0 = local_c8;
  local_e0 = 8;
  local_dc = 0x30;
  __format = (char *)dcgettext(0,"%s: Warning: ",5);
  fprintf(_stderr,__format,"elfedit");
  vfprintf(_stderr,param_9,&local_e0);
  return;
}


////>>0x00102e85>>FUN_00102e85>>////



void FUN_00102e85(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
                 char *param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,
                 undefined8 param_13,undefined8 param_14)

{
  char in_AL;
  char *__format;
  undefined4 local_e0;
  undefined4 local_dc;
  undefined *local_d8;
  undefined *local_d0;
  undefined local_c8 [8];
  undefined8 local_c0;
  undefined8 local_b8;
  undefined8 local_b0;
  undefined8 local_a8;
  undefined8 local_a0;
  undefined4 local_98;
  undefined4 local_88;
  undefined4 local_78;
  undefined4 local_68;
  undefined4 local_58;
  undefined4 local_48;
  undefined4 local_38;
  undefined4 local_28;
  
  if (in_AL != '\0') {
    local_98 = param_1;
    local_88 = param_2;
    local_78 = param_3;
    local_68 = param_4;
    local_58 = param_5;
    local_48 = param_6;
    local_38 = param_7;
    local_28 = param_8;
  }
  local_c0 = param_10;
  local_b8 = param_11;
  local_b0 = param_12;
  local_a8 = param_13;
  local_a0 = param_14;
  fflush(_stdout);
  local_d8 = &stack0x00000008;
  local_d0 = local_c8;
  local_e0 = 8;
  local_dc = 0x30;
  __format = (char *)dcgettext(0,"%s: Error: ",5);
  fprintf(_stderr,__format,"elfedit");
  vfprintf(_stderr,param_9,&local_e0);
  return;
}


////>>0x00102f65>>FUN_00102f65>>////

void FUN_00102f65(void **param_1)

{
  free(*param_1);
  free(param_1[3]);
  free(param_1[4]);
  free(param_1[6]);
  *param_1 = (void *)0x0;
  param_1[6] = (void *)0x0;
  *(undefined (*) [16])(param_1 + 3) = ZEXT816(0);
  return;
}


////>>0x00102fa0>>FUN_00102fa0>>////

void FUN_00102fa0(byte **param_1)

{
  while (((&DAT_00107040)[(ulong)**param_1 * 2] & 0x40) != 0) {
    *param_1 = *param_1 + 1;
  }
  return;
}


////>>0x00102fbc>>FUN_00102fbc>>////

void FUN_00102fbc(void)

{
                    
  exit(1);
}


////>>0x00102fc7>>FUN_00102fc7>>////



char * FUN_00102fc7(undefined8 param_1)

{
  char cVar1;
  void *pvVar2;
  size_t sVar3;
  ulong uVar4;
  char *pcVar5;
  char **ppcVar6;
  undefined8 extraout_RDX;
  long lVar7;
  char *__s;
  FILE *__ptr;
  char *pcVar8;
  byte bVar9;
  undefined8 extraout_XMM0_Qa;
  uint uStack_f8;
  char **ppcVar10;
  char **ppcVar11;
  char *apcStack_e0 [4];
  undefined8 uStack_c0;
  long lStack_b8;
  undefined8 uStack_b0;
  undefined8 uStack_28;
  
  bVar9 = 0;
  pvVar2 = sbrk(0);
  lStack_b8 = (long)pvVar2 + -0x10a0e0;
  apcStack_e0[3] = "";
  __s = "\n%s%sout of memory allocating %lu bytes after a total of %lu bytes\n";
  __ptr = _stderr;
  uStack_c0 = param_1;
  fprintf(_stderr,"\n%s%sout of memory allocating %lu bytes after a total of %lu bytes\n");
  cVar1 = xexit_constprop_0();
  if (cVar1 != '\0') {
    uStack_b0 = extraout_XMM0_Qa;
  }
  lVar7 = 0;
  uStack_f8 = 0x10;
  pcVar8 = __s;
  ppcVar10 = (char **)register0x00000020;
  apcStack_e0[2] = (char *)extraout_RDX;
  uStack_28 = param_1;
  do {
    sVar3 = strlen(pcVar8);
    lVar7 = lVar7 + sVar3;
    if (uStack_f8 < 0x30) {
      uVar4 = (ulong)uStack_f8;
      uStack_f8 = uStack_f8 + 8;
      ppcVar6 = (char **)((long)apcStack_e0 + uVar4);
      ppcVar11 = ppcVar10;
    }
    else {
      ppcVar11 = ppcVar10 + 1;
      ppcVar6 = ppcVar10;
    }
    pcVar8 = *ppcVar6;
    ppcVar10 = ppcVar11;
  } while (pcVar8 != (char *)0x0);
  pcVar5 = (char *)xmalloc(lVar7 + 1);
  uStack_f8 = 0x10;
  pcVar8 = pcVar5;
  ppcVar10 = (char **)register0x00000020;
  do {
    sVar3 = strlen(__s);
    for (; sVar3 != 0; sVar3 = sVar3 - 1) {
      *pcVar8 = *__s;
      __s = __s + (ulong)bVar9 * -2 + 1;
      pcVar8 = pcVar8 + (ulong)bVar9 * -2 + 1;
    }
    if (uStack_f8 < 0x30) {
      uVar4 = (ulong)uStack_f8;
      uStack_f8 = uStack_f8 + 8;
      ppcVar6 = (char **)((long)apcStack_e0 + uVar4);
      ppcVar11 = ppcVar10;
    }
    else {
      ppcVar11 = ppcVar10 + 1;
      ppcVar6 = ppcVar10;
    }
    __s = *ppcVar6;
    ppcVar10 = ppcVar11;
  } while (__s != (char *)0x0);
  *pcVar8 = '\0';
  free(__ptr);
  return pcVar5;
}


////>>0x00103006>>FUN_00103006>>////

char * FUN_00103006(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                   undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
                   void *param_9,char *param_10,undefined8 param_11,undefined8 param_12,
                   undefined8 param_13,undefined8 param_14)

{
  char in_AL;
  size_t sVar1;
  ulong uVar2;
  char *pcVar3;
  char **ppcVar4;
  long lVar5;
  char *pcVar6;
  byte bVar7;
  uint local_f0;
  char **local_e8;
  char *local_d8 [4];
  undefined8 local_b8;
  undefined8 local_b0;
  undefined4 local_a8;
  undefined4 local_98;
  undefined4 local_88;
  undefined4 local_78;
  undefined4 local_68;
  undefined4 local_58;
  undefined4 local_48;
  undefined4 local_38;
  
  bVar7 = 0;
  if (in_AL != '\0') {
    local_a8 = param_1;
    local_98 = param_2;
    local_88 = param_3;
    local_78 = param_4;
    local_68 = param_5;
    local_58 = param_6;
    local_48 = param_7;
    local_38 = param_8;
  }
  local_e8 = (char **)&stack0x00000008;
  lVar5 = 0;
  local_f0 = 0x10;
  pcVar6 = param_10;
  local_d8[2] = (char *)param_11;
  local_d8[3] = (char *)param_12;
  local_b8 = param_13;
  local_b0 = param_14;
  do {
    sVar1 = strlen(pcVar6);
    lVar5 = lVar5 + sVar1;
    if (local_f0 < 0x30) {
      uVar2 = (ulong)local_f0;
      local_f0 = local_f0 + 8;
      ppcVar4 = (char **)((long)local_d8 + uVar2);
    }
    else {
      ppcVar4 = local_e8;
      local_e8 = local_e8 + 1;
    }
    pcVar6 = *ppcVar4;
  } while (pcVar6 != (char *)0x0);
  pcVar3 = (char *)xmalloc(lVar5 + 1);
  local_f0 = 0x10;
  local_e8 = (char **)&stack0x00000008;
  pcVar6 = pcVar3;
  do {
    sVar1 = strlen(param_10);
    for (; sVar1 != 0; sVar1 = sVar1 - 1) {
      *pcVar6 = *param_10;
      param_10 = param_10 + (ulong)bVar7 * -2 + 1;
      pcVar6 = pcVar6 + (ulong)bVar7 * -2 + 1;
    }
    if (local_f0 < 0x30) {
      uVar2 = (ulong)local_f0;
      local_f0 = local_f0 + 8;
      ppcVar4 = (char **)((long)local_d8 + uVar2);
    }
    else {
      ppcVar4 = local_e8;
      local_e8 = local_e8 + 1;
    }
    param_10 = *ppcVar4;
  } while (param_10 != (char *)0x0);
  *pcVar6 = '\0';
  free(param_9);
  return pcVar3;
}


////>>0x00103160>>FUN_00103160>>////

void FUN_00103160(char *param_1)

{
  size_t sVar1;
  char *pcVar2;
  long lVar3;
  byte bVar4;
  
  bVar4 = 0;
  sVar1 = strlen(param_1);
  lVar3 = sVar1 + 1;
  pcVar2 = (char *)xmalloc(lVar3);
  for (; lVar3 != 0; lVar3 = lVar3 + -1) {
    *pcVar2 = *param_1;
    param_1 = param_1 + (ulong)bVar4 * -2 + 1;
    pcVar2 = pcVar2 + (ulong)bVar4 * -2 + 1;
  }
  return;
}


////>>0x00103186>>FUN_00103186>>////

char * FUN_00103186(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
                   undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
                   undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,
                   undefined8 param_13,undefined8 param_14)

{
  char in_AL;
  size_t sVar1;
  ulong uVar2;
  char *pcVar3;
  char **ppcVar4;
  long lVar5;
  char *pcVar6;
  char *pcVar7;
  byte bVar8;
  uint local_e0;
  char **local_d8;
  char *local_c8 [4];
  undefined8 local_a8;
  undefined8 local_a0;
  undefined4 local_98;
  undefined4 local_88;
  undefined4 local_78;
  undefined4 local_68;
  undefined4 local_58;
  undefined4 local_48;
  undefined4 local_38;
  undefined4 local_28;
  
  bVar8 = 0;
  if (in_AL != '\0') {
    local_98 = param_1;
    local_88 = param_2;
    local_78 = param_3;
    local_68 = param_4;
    local_58 = param_5;
    local_48 = param_6;
    local_38 = param_7;
    local_28 = param_8;
  }
  local_d8 = (char **)&stack0x00000008;
  lVar5 = 0;
  local_e0 = 8;
  pcVar6 = "none";
  local_c8[1] = (char *)param_10;
  local_c8[2] = (char *)param_11;
  local_c8[3] = (char *)param_12;
  local_a8 = param_13;
  local_a0 = param_14;
  do {
    sVar1 = strlen(pcVar6);
    lVar5 = lVar5 + sVar1;
    if (local_e0 < 0x30) {
      uVar2 = (ulong)local_e0;
      local_e0 = local_e0 + 8;
      ppcVar4 = (char **)((long)local_c8 + uVar2);
    }
    else {
      ppcVar4 = local_d8;
      local_d8 = local_d8 + 1;
    }
    pcVar6 = *ppcVar4;
  } while (pcVar6 != (char *)0x0);
  pcVar6 = "none";
  pcVar3 = (char *)xmalloc(lVar5 + 1);
  local_e0 = 8;
  local_d8 = (char **)&stack0x00000008;
  pcVar7 = pcVar3;
  do {
    sVar1 = strlen(pcVar6);
    for (; sVar1 != 0; sVar1 = sVar1 - 1) {
      *pcVar7 = *pcVar6;
      pcVar6 = pcVar6 + (ulong)bVar8 * -2 + 1;
      pcVar7 = pcVar7 + (ulong)bVar8 * -2 + 1;
    }
    if (local_e0 < 0x30) {
      uVar2 = (ulong)local_e0;
      local_e0 = local_e0 + 8;
      ppcVar4 = (char **)((long)local_c8 + uVar2);
    }
    else {
      ppcVar4 = local_d8;
      local_d8 = local_d8 + 1;
    }
    pcVar6 = *ppcVar4;
  } while (pcVar6 != (char *)0x0);
  *pcVar7 = '\0';
  return pcVar3;
}


////>>0x001032de>>FUN_001032de>>////

void FUN_001032de(FILE *param_1,int param_2)

{
  undefined8 *puVar1;
  void *__ptr;
  char *pcVar2;
  undefined4 *puVar3;
  
  puVar3 = &DAT_00108ca0;
  __ptr = (void *)concat_constprop_0(&DAT_00106137,0);
  do {
    puVar1 = (undefined8 *)(puVar3 + 6);
    puVar3 = puVar3 + 4;
    __ptr = (void *)reconcat(__ptr,__ptr,&DAT_001061ef,*puVar1,0);
  } while (puVar3 != (undefined4 *)&DAT_00108d90);
  pcVar2 = (char *)dcgettext(0,"Usage: %s <option(s)> elffile(s)\n",5);
  fprintf(param_1,pcVar2,"elfedit");
  pcVar2 = (char *)dcgettext(0," Update the ELF header of ELF files\n",5);
  fprintf(param_1,pcVar2);
  pcVar2 = (char *)dcgettext(0," The options are:\n",5);
  fprintf(param_1,pcVar2);
  pcVar2 = (char *)dcgettext(0,
                             "  --input-mach [none|i386|iamcu|l1om|k1om|x86_64]\n                              Set input machine type\n  --output-mach [none|i386|iamcu|l1om|k1om|x86_64]\n                              Set output machine type\n  --input-type [none|rel|exec|dyn]\n                              Set input file type\n  --output-type [none|rel|exec|dyn]\n                              Set output file type\n  --input-osabi [%s]\n                              Set input OSABI\n  --output-osabi [%s]\n                              Set output OSABI\n  --input-abiversion [0-255]  Set input ABIVERSION\n  --output-abiversion [0-255] Set output ABIVERSION\n"
                             ,5);
  fprintf(param_1,pcVar2,__ptr,__ptr);
  pcVar2 = (char *)dcgettext(0,
                             "  --enable-x86-feature [ibt|shstk|lam_u48|lam_u57]\n                              Enable x86 feature\n  --disable-x86-feature [ibt|shstk|lam_u48|lam_u57]\n                              Disable x86 feature\n"
                             ,5);
  fprintf(param_1,pcVar2);
  pcVar2 = (char *)dcgettext(0,
                             "  -h --help                   Display this information\n  -v --version                Display the version number of %s\n"
                             ,5);
  fprintf(param_1,pcVar2,"elfedit");
  if (param_2 == 0) {
    pcVar2 = (char *)dcgettext(0,"Report bugs to %s\n",5);
    fprintf(param_1,pcVar2,"<https://sourceware.org/bugzilla/>");
  }
  free(__ptr);
                    
  exit(param_2);
}


////>>0x00103449>>FUN_00103449>>////

void FUN_00103449(void *param_1,size_t param_2)

{
  size_t __size;
  void *pvVar1;
  
  __size = 1;
  if (param_2 != 0) {
    __size = param_2;
  }
  if (param_1 == (void *)0x0) {
    pvVar1 = malloc(__size);
  }
  else {
    pvVar1 = realloc(param_1,__size);
  }
  if (pvVar1 == (void *)0x0) {
    xmalloc_failed(__size);
  }
  return;
}


////>>0x0010347f>>FUN_0010347f>>////

ulong FUN_0010347f(ulong *param_1,undefined4 param_2)

{
  uint uVar1;
  ulong uVar2;
  undefined8 uVar3;
  
  switch(param_2) {
  case 1:
    return (ulong)*(byte *)param_1;
  case 2:
    return (ulong)CONCAT11((char)*(undefined2 *)param_1,(char)((ushort)*(undefined2 *)param_1 >> 8))
    ;
  case 3:
    return (ulong)*(byte *)((long)param_1 + 1) << 8 | (ulong)*(byte *)param_1 << 0x10 |
           (ulong)*(byte *)((long)param_1 + 2);
  case 4:
    uVar1 = *(uint *)param_1;
    return (ulong)(uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18);
  case 5:
    uVar1 = *(uint *)((long)param_1 + 1);
    return (ulong)CONCAT14(*(byte *)param_1,
                           uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 |
                           uVar1 << 0x18);
  case 6:
    uVar1 = *(uint *)((long)param_1 + 2);
    return (ulong)*(byte *)((long)param_1 + 1) << 0x20 | (ulong)*(byte *)param_1 << 0x28 |
           (ulong)(uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18);
  case 7:
    uVar1 = *(uint *)((long)param_1 + 3);
    return (ulong)*(byte *)((long)param_1 + 2) << 0x20 | (ulong)*(byte *)((long)param_1 + 1) << 0x28
           | (ulong)*(byte *)param_1 << 0x30 |
           (ulong)(uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18);
  case 8:
    uVar2 = *param_1;
    return uVar2 >> 0x38 | (uVar2 & 0xff000000000000) >> 0x28 | (uVar2 & 0xff0000000000) >> 0x18 |
           (uVar2 & 0xff00000000) >> 8 | (uVar2 & 0xff000000) << 8 | (uVar2 & 0xff0000) << 0x18 |
           (uVar2 & 0xff00) << 0x28 | uVar2 << 0x38;
  default:
    uVar3 = dcgettext(0,"Unhandled data length: %d\n",5);
    error(uVar3,param_2);
                    
    abort();
  }
}


////>>0x0010354e>>FUN_0010354e>>////

void FUN_0010354e(long param_1,ulong param_2,uint param_3)

{
  undefined8 uVar1;
  int iVar2;
  ulong uVar3;
  
  uVar3 = (ulong)param_3;
  if (8 < param_3) {
    uVar1 = dcgettext(0,"Unhandled data length: %d\n",5);
    error(uVar1,param_3);
                    
    abort();
  }
  while (iVar2 = (int)uVar3, uVar3 = (ulong)(iVar2 - 1), iVar2 != 0) {
    *(char *)(param_1 + uVar3) = (char)param_2;
    param_2 = param_2 >> 8;
  }
  return;
}


////>>0x0010358d>>FUN_0010358d>>////

uint FUN_0010358d(undefined8 param_1,FILE *param_2,char param_3)

{
  long lVar1;
  char *pcVar2;
  int iVar3;
  uint uVar4;
  undefined8 uVar5;
  size_t sVar6;
  undefined8 uVar7;
  ulong uVar8;
  size_t sVar9;
  char *__s;
  size_t sVar10;
  size_t sVar11;
  char *__s_00;
  char *pcVar12;
  FILE *__stream;
  char *pcVar13;
  uint uVar14;
  stat local_208;
  undefined local_178 [24];
  undefined local_160 [16];
  undefined8 local_148;
  undefined local_d8 [16];
  undefined local_c0 [16];
  undefined8 local_a8;
  long local_98;
  long local_90;
  int local_88;
  undefined local_80 [48];
  char local_50 [10];
  short local_46;
  
  local_148 = 0;
  local_d8 = ZEXT816(0);
  local_c0 = ZEXT816(0);
  local_178._0_16_ = ZEXT816(0);
  local_160 = ZEXT816(0);
  local_a8 = 0;
  iVar3 = fileno(param_2);
  iVar3 = fstat(iVar3,&local_208);
  if ((iVar3 < 0) ||
     (iVar3 = setup_archive_constprop_0(local_d8,param_1,param_2,local_208.st_size,param_3),
     iVar3 != 0)) {
LAB_001036cc:
    uVar14 = 1;
LAB_00103a46:
    if ((FILE *)local_178._8_8_ != (FILE *)0x0) {
      fclose((FILE *)local_178._8_8_);
    }
    release_archive(local_178);
    release_archive(local_d8);
  }
  else {
    uVar14 = 0;
    while (iVar3 = fseek(param_2,local_90,0), iVar3 == 0) {
      sVar6 = fread(local_80,1,0x3c,param_2);
      if (sVar6 != 0x3c) {
        if (sVar6 == 0) goto LAB_00103a46;
        pcVar13 = "%s: failed to read archive header\n";
LAB_001036b8:
        uVar5 = dcgettext(0,pcVar13,5);
        error(uVar5,param_1);
        goto LAB_001036cc;
      }
      if (local_46 != 0xa60) {
        uVar5 = local_d8._0_8_;
        uVar7 = dcgettext(0,"%s: did not find a valid archive header\n",5);
        error(uVar7,uVar5);
        goto LAB_001036cc;
      }
      local_90 = local_90 + 0x3c;
      uVar8 = strtoul(local_50,(char **)0x0,10);
      DAT_00109438 = (uVar8 + 1) - (ulong)((uVar8 & 1) == 0);
      pcVar13 = (char *)get_archive_member_name(local_d8,local_178);
      if (pcVar13 == (char *)0x0) {
        pcVar13 = "%s: bad archive file name\n";
        goto LAB_001036b8;
      }
      sVar9 = strlen(pcVar13);
      __s = (char *)dcgettext(0,"<corrupt>",5);
      pcVar12 = (char *)local_d8._0_8_;
      sVar10 = strlen((char *)local_d8._0_8_);
      sVar11 = strlen(pcVar13);
      sVar6 = sVar10 + sVar11 + 3;
      if (local_88 == 0) {
        __s_00 = (char *)malloc(sVar6);
        if (__s_00 == (char *)0x0) goto LAB_001037d3;
        snprintf(__s_00,sVar6,"%s(%s)",pcVar12,pcVar13);
      }
      else if (local_98 == 0) {
        __s_00 = (char *)malloc(sVar6);
        if (__s_00 == (char *)0x0) {
LAB_001037d3:
          uVar5 = dcgettext(0,"Out of memory\n",5);
          error(uVar5);
          uVar5 = dcgettext(0,"%s: bad archive file name\n",5);
          error(uVar5,param_1);
          free(pcVar13);
          goto LAB_001036cc;
        }
        snprintf(__s_00,sVar6,"%s[%s]",pcVar12,pcVar13);
      }
      else {
        pcVar2 = (char *)local_178._0_8_;
        lVar1 = sVar10 + sVar11 + 5;
        if ((char *)local_178._0_8_ == (char *)0x0) {
          sVar6 = strlen(__s);
          sVar6 = lVar1 + sVar6;
          __s_00 = (char *)malloc(sVar6);
          pcVar2 = __s;
        }
        else {
          sVar6 = strlen((char *)local_178._0_8_);
          sVar6 = lVar1 + sVar6;
          __s_00 = (char *)malloc(sVar6);
        }
        if (__s_00 == (char *)0x0) goto LAB_001037d3;
        snprintf(__s_00,sVar6,"%s[%s(%s)]",pcVar12,pcVar2,pcVar13);
      }
      if (param_3 == '\0') {
        free(pcVar13);
        local_90 = local_90 + DAT_00109438;
        uVar4 = process_object(__s_00,param_2);
        uVar14 = uVar14 | uVar4;
      }
      else {
        if (local_98 == 0) {
          pcVar12 = (char *)adjust_relative_path(param_1,pcVar13,sVar9);
          free(pcVar13);
          if (pcVar12 != (char *)0x0) {
            __stream = fopen(pcVar12,"r+b");
            if (__stream != (FILE *)0x0) {
              uVar4 = process_object(__s_00,__stream);
              uVar14 = uVar14 | uVar4;
              fclose(__stream);
              free(pcVar12);
              goto LAB_00103a39;
            }
            uVar5 = dcgettext(0,"Input file \'%s\' is not readable\n",5);
            error(uVar5,pcVar12);
            free(pcVar12);
          }
          free(__s_00);
          goto LAB_001036cc;
        }
        free(pcVar13);
        iVar3 = fseek((FILE *)local_178._8_8_,local_98 + 0x3c,0);
        if (iVar3 != 0) {
          uVar5 = local_178._0_8_;
          uVar7 = dcgettext(0,"%s: failed to seek to archive member\n",5);
          error(uVar7,uVar5);
          free(__s_00);
          goto LAB_001036cc;
        }
        uVar4 = process_object(__s_00,local_178._8_8_);
        uVar14 = uVar14 | uVar4;
      }
LAB_00103a39:
      free(__s_00);
    }
    uVar5 = dcgettext(0,"%s: failed to seek to next archive header\n",5);
    uVar14 = 1;
    error(uVar5,param_1);
  }
  return uVar14;
}


////>>0x00103a90>>FUN_00103a90>>////

ulong FUN_00103a90(ulong *param_1,ulong param_2)

{
  ulong uVar1;
  undefined8 uVar2;
  
  switch(param_2 & 0xffffffff) {
  default:
    uVar2 = dcgettext(0,"Unhandled data length: %d\n",5);
    error(uVar2,param_2 & 0xffffffff);
                    
    abort();
  case 1:
    return (ulong)*(byte *)param_1;
  case 2:
    return (ulong)*(ushort *)param_1;
  case 3:
    uVar1 = FUN_00103ab3(param_1,param_2,
                         (ulong)*(byte *)((long)param_1 + 1) << 8 |
                         (ulong)*(byte *)((long)param_1 + 2) << 0x10);
    return uVar1;
  case 4:
    return (ulong)*(uint *)param_1;
  case 5:
    uVar1 = FUN_00103ab3(param_1,param_2,(ulong)*(byte *)((long)param_1 + 4) << 0x20);
    return uVar1;
  case 6:
    uVar1 = FUN_00103ab3(param_1,param_2,
                         (ulong)*(byte *)((long)param_1 + 4) << 0x20 |
                         (ulong)*(byte *)((long)param_1 + 5) << 0x28);
    return uVar1;
  case 7:
    uVar1 = FUN_00103ab3(param_1,param_2,
                         (ulong)*(byte *)((long)param_1 + 4) << 0x20 |
                         (ulong)*(byte *)((long)param_1 + 5) << 0x28 | (ulong)*(uint *)param_1);
    return uVar1;
  case 8:
    return *param_1;
  }
}


////>>0x00103ab3>>FUN_00103ab3>>////

void FUN_00103ab3(void)

{
  return;
}


////>>0x00103ad0>>FUN_00103ad0>>////

void FUN_00103ad0(long param_1,ulong param_2,uint param_3)

{
  undefined8 uVar1;
  ulong uVar2;
  
  if (param_3 < 9) {
    for (uVar2 = 0; param_3 != uVar2; uVar2 = uVar2 + 1) {
      *(char *)(param_1 + uVar2) = (char)param_2;
      param_2 = param_2 >> 8;
    }
    return;
  }
  uVar1 = dcgettext(0,"Unhandled data length: %d\n",5);
  error(uVar1,param_3);
                    
  abort();
}


////>>0x00103b00>>FUN_00103b00>>////

void processEntry FUN_00103b00(undefined8 param_1,undefined8 param_2)

{
  undefined auStack_8 [8];
  
  __libc_start_main(main,param_2,&stack0x00000008,0,0,param_1,auStack_8);
  do {
                    /* WARNING: Do nothing block with infinite loop */
  } while( true );
}


////>>0x00103b30>>FUN_00103b30>>////

/* WARNING: Removing unreachable block (ram,0x00103b43) */
/* WARNING: Removing unreachable block (ram,0x00103b4f) */

void FUN_00103b30(void)

{
  return;
}


////>>0x00103b60>>FUN_00103b60>>////

/* WARNING: Removing unreachable block (ram,0x00103b84) */
/* WARNING: Removing unreachable block (ram,0x00103b90) */

void FUN_00103b60(void)

{
  return;
}


////>>0x00103ba0>>FUN_00103ba0>>////

void FUN_00103ba0(void)

{
  if (DAT_00109320 != '\0') {
    return;
  }
  __cxa_finalize(PTR_LOOP_00109148);
  deregister_tm_clones();
  DAT_00109320 = 1;
  return;
}


////>>0x00103be0>>FUN_00103be0>>////

void register_tm_clones(void)

{
  register_tm_clones();
  return;
}


////>>0x00103bf0>>FUN_00103bf0>>////

/* WARNING: Type propagation algorithm not settling */


uint FUN_00103bf0(int param_1,long *param_2)

{
  char cVar1;
  byte bVar2;
  ulong uVar3;
  bool bVar4;
  bool bVar5;
  bool bVar6;
  bool bVar7;
  int iVar8;
  uint uVar9;
  int iVar10;
  void *__addr;
  void *__ptr;
  long *plVar11;
  ulong uVar12;
  ulong uVar13;
  ulong uVar14;
  ulong uVar15;
  FILE *pFVar16;
  size_t sVar17;
  byte *__s;
  size_t sVar18;
  int *piVar19;
  long lVar20;
  long *plVar21;
  byte *pbVar22;
  long lVar23;
  long *plVar24;
  undefined8 uVar25;
  ulong uVar26;
  byte *pbVar27;
  uint uVar28;
  long lVar29;
  uint uVar30;
  int iVar31;
  undefined **ppuVar32;
  uint uVar33;
  char *pcVar34;
  ulong uVar35;
  char *pcVar36;
  undefined8 *puVar37;
  ulong uVar38;
  undefined8 *local_138;
  ulong local_120;
  char *local_d8;
  byte *local_d0;
  stat local_c8;
  
  iVar8 = 0;
  iVar31 = 2000;
  setlocale(5,"");
  setlocale(0,"");
  bindtextdomain("binutils","/usr/share/locale");
  textdomain("binutils");
  plVar21 = param_2;
LAB_00103c54:
  lVar29 = (long)(iVar8 + 1);
  do {
    iVar8 = (int)lVar29;
    if (param_1 <= iVar8) {
      ppuVar32 = &PTR_s_input_mach_00109180;
      break;
    }
    if (*(char *)plVar21[lVar29] == '@') {
      iVar31 = iVar31 + -1;
      if (iVar31 == 0) {
        lVar29 = *plVar21;
        pcVar36 = "%s: error: too many @-files encountered\n";
        goto LAB_00104739;
      }
      pcVar36 = (char *)plVar21[lVar29] + 1;
      iVar10 = stat(pcVar36,&local_c8);
      if (-1 < iVar10) {
        if ((local_c8.st_mode & 0xf000) == 0x4000) {
          do {
            lVar29 = *plVar21;
            pcVar36 = "%s: error: @-file refers to a directory\n";
LAB_00104739:
            fprintf(_stderr,pcVar36,lVar29);
            xexit_constprop_0();
          } while( true );
        }
        pFVar16 = fopen(pcVar36,"r");
        if (pFVar16 != (FILE *)0x0) goto code_r0x00104650;
      }
    }
    lVar29 = lVar29 + 1;
  } while( true );
LAB_00103c87:
  iVar8 = getopt_long(param_1,plVar21,&DAT_0010604c,ppuVar32,0);
  if (iVar8 == -1) {
    if ((_optind == param_1) ||
       (((DAT_00109444 | DAT_00109440) == 0 &&
        (ppuVar32 = (undefined **)0x0,
        (DAT_0010916c & DAT_00109160 & DAT_00109158 & DAT_00109150) == 0xffffffff))))
    goto switchD_00103cba_caseD_69;
    uVar30 = 0;
    goto LAB_00103d1c;
  }
  switch(iVar8) {
  case 0x68:
    usage(_stdout,0);
  default:
switchD_00103cba_caseD_69:
    usage(_stderr,1);
    goto switchD_00103cba_caseD_9a;
  case 0x76:
    printf("GNU %s %s\n","elfedit","(GNU Binutils for Debian) 2.40");
    pcVar36 = (char *)dcgettext(0,"Copyright (C) 2023 Free Software Foundation, Inc.\n",5);
    printf(pcVar36);
    pcVar36 = (char *)dcgettext(0,
                                "This program is free software; you may redistribute it under the terms of\nthe GNU General Public License version 3 or (at your option) any later version.\nThis program has absolutely no warranty.\n"
                                ,5);
    printf(pcVar36);
                    
    exit(0);
  case 0x96:
    DAT_00109174 = elf_machine(_optarg);
    if (DAT_00109174 < 0) {
      return 1;
    }
    if (DAT_00109174 == 6) {
      DAT_00109170 = 1;
    }
    else if (DAT_00109174 < 7) {
      DAT_00109170 = (DAT_00109174 != 3) + 1 + (uint)(DAT_00109174 != 3);
    }
    else {
      DAT_00109170 = 3 - (uint)(DAT_00109174 - 0xb4U < 2);
    }
    goto LAB_00103c87;
  case 0x97:
    DAT_0010916c = elf_machine(_optarg);
    if ((int)DAT_0010916c < 0) {
      return 1;
    }
    if ((int)DAT_0010916c < 0xb6) {
      DAT_00109168 = 2;
      if (((int)DAT_0010916c < 0xb4) && (DAT_00109168 = 1, DAT_0010916c != 3)) {
        DAT_00109168 = (DAT_0010916c != 6) + 1 + (uint)(DAT_0010916c != 6);
      }
    }
    else {
      DAT_00109168 = 3;
    }
    goto LAB_00103c87;
  case 0x98:
    DAT_00109164 = elf_type(_optarg);
    uVar30 = DAT_00109164;
    break;
  case 0x99:
    DAT_00109160 = elf_type(_optarg);
    uVar30 = DAT_00109160;
    break;
  case 0x9a:
    goto switchD_00103cba_caseD_9a;
  case 0x9b:
    DAT_00109158 = elf_osabi(_optarg);
    uVar30 = DAT_00109158;
    break;
  case 0x9c:
    uVar15 = strtoul(_optarg,&local_d8,0);
    uVar30 = (uint)uVar15;
    cVar1 = *local_d8;
    DAT_00109154 = uVar30;
    pcVar36 = _optarg;
    goto joined_r0x00104334;
  case 0x9d:
    uVar15 = strtoul(_optarg,&local_d8,0);
    uVar30 = (uint)uVar15;
    cVar1 = *local_d8;
    DAT_00109150 = uVar30;
    pcVar36 = _optarg;
joined_r0x00104334:
    _optarg = pcVar36;
    if ((cVar1 != '\0') || (0xff < uVar30)) {
      uVar25 = dcgettext(0,"Invalid ABIVERSION: %s\n",5);
      error(uVar25,pcVar36);
      return 1;
    }
    goto LAB_00103c87;
  case 0x9e:
    uVar25 = 1;
    goto LAB_00103e9d;
  case 0x9f:
    uVar25 = 0;
LAB_00103e9d:
    uVar30 = elf_x86_feature(_optarg,uVar25);
  }
joined_r0x00103eae:
  if ((int)uVar30 < 0) {
    return 1;
  }
  goto LAB_00103c87;
LAB_00103d1c:
  lVar29 = (long)_optind;
  if (param_1 <= _optind) {
    return uVar30;
  }
  _optind = _optind + 1;
  pcVar36 = (char *)plVar21[lVar29];
  iVar8 = stat(pcVar36,&local_c8);
  if (iVar8 < 0) {
    piVar19 = __errno_location();
    pcVar34 = "\'%s\': No such file\n";
    if (*piVar19 == 2) goto LAB_00104497;
    pcVar34 = strerror(*piVar19);
    uVar25 = dcgettext(0,"Could not locate \'%s\'.  System error message: %s\n",5);
    error(uVar25,pcVar36,pcVar34);
LAB_001044ab:
    uVar9 = 1;
  }
  else {
    if ((local_c8.st_mode & 0xf000) != 0x8000) {
      pcVar34 = "\'%s\' is not an ordinary file\n";
LAB_00104497:
      uVar25 = dcgettext(0,pcVar34,5);
      error(uVar25,pcVar36);
      goto LAB_001044ab;
    }
    pFVar16 = fopen(pcVar36,"r+b");
    if (pFVar16 == (FILE *)0x0) {
      pcVar34 = "Input file \'%s\' is not readable\n";
      goto LAB_00104497;
    }
    sVar17 = fread(&local_d0,8,1,pFVar16);
    if (sVar17 != 1) {
      uVar25 = dcgettext(0,"%s: Failed to read file\'s magic number\n",5);
      error(uVar25,pcVar36);
      fclose(pFVar16);
      goto LAB_001044ab;
    }
    if (local_d0 == (byte *)0xa3e686372613c21) {
      uVar9 = process_archive(pcVar36,pFVar16,0);
    }
    else if (local_d0 == (byte *)0xa3e6e6968743c21) {
      uVar9 = process_archive(pcVar36,pFVar16,1);
    }
    else {
      rewind(pFVar16);
      DAT_00109438 = 0;
      uVar9 = process_object(pcVar36,pFVar16);
      if (((uVar9 == 0) && ((ushort)(DAT_00109418 - 2U) < 2)) &&
         ((DAT_00109444 | DAT_00109440) != 0)) {
        if ((DAT_0010941a == 3) ||
           (pcVar34 = "%s: Not an i386 nor x86-64 ELF file\n", DAT_0010941a == 0x3e)) {
          iVar8 = fileno(pFVar16);
          iVar8 = fstat(iVar8,&local_c8);
          if (iVar8 < 0) {
            uVar25 = dcgettext(0,"%s: stat () failed\n",5);
            error(uVar25,pcVar36);
            uVar9 = 1;
          }
          else {
            iVar8 = fileno(pFVar16);
            __addr = mmap((void *)0x0,local_c8.st_size,3,1,iVar8,0);
            if (__addr == (void *)0xffffffffffffffff) {
              pcVar34 = "%s: mmap () failed\n";
              goto LAB_0010438d;
            }
            __ptr = (void *)xmalloc((ulong)DAT_00109424 << 6);
            lVar29 = DAT_001093f8;
            if (DAT_001093e4 == '\x01') {
              for (uVar15 = 0; (uint)uVar15 < DAT_00109424; uVar15 = (ulong)((uint)uVar15 + 1)) {
                lVar20 = uVar15 * 0x20 + lVar29 + (long)__addr;
                puVar37 = (undefined8 *)((long)__ptr + uVar15 * 0x40);
                uVar25 = (*DAT_001093c0)(lVar20,4);
                *puVar37 = uVar25;
                uVar25 = (*DAT_001093c0)(lVar20 + 4,4);
                puVar37[2] = uVar25;
                uVar25 = (*DAT_001093c0)(lVar20 + 8,4);
                puVar37[3] = uVar25;
                uVar25 = (*DAT_001093c0)(lVar20 + 0xc,4);
                puVar37[4] = uVar25;
                uVar25 = (*DAT_001093c0)(lVar20 + 0x10,4);
                puVar37[5] = uVar25;
                uVar25 = (*DAT_001093c0)(lVar20 + 0x14,4);
                puVar37[6] = uVar25;
                uVar25 = (*DAT_001093c0)(lVar20 + 0x18,4);
                puVar37[1] = uVar25;
                uVar25 = (*DAT_001093c0)(lVar20 + 0x1c,4);
                puVar37[7] = uVar25;
              }
            }
            else {
              for (uVar28 = 0; uVar28 < DAT_00109424; uVar28 = uVar28 + 1) {
                lVar20 = (ulong)uVar28 * 0x38 + lVar29 + (long)__addr;
                puVar37 = (undefined8 *)((ulong)uVar28 * 0x40 + (long)__ptr);
                uVar25 = (*DAT_001093c0)(lVar20,4);
                *puVar37 = uVar25;
                uVar25 = (*DAT_001093c0)(lVar20 + 8,8);
                puVar37[2] = uVar25;
                uVar25 = (*DAT_001093c0)(lVar20 + 0x10,8);
                puVar37[3] = uVar25;
                uVar25 = (*DAT_001093c0)(lVar20 + 0x18,8);
                puVar37[4] = uVar25;
                uVar25 = (*DAT_001093c0)(lVar20 + 0x20,8);
                puVar37[5] = uVar25;
                uVar25 = (*DAT_001093c0)(lVar20 + 0x28,8);
                puVar37[6] = uVar25;
                uVar25 = (*DAT_001093c0)(lVar20 + 4,4);
                puVar37[1] = uVar25;
                uVar25 = (*DAT_001093c0)(lVar20 + 0x30,8);
                puVar37[7] = uVar25;
              }
            }
            for (uVar15 = 0; (uint)uVar15 < DAT_00109424; uVar15 = (ulong)((uint)uVar15 + 1)) {
              plVar11 = (long *)(uVar15 * 0x40 + (long)__ptr);
              if (*plVar11 == 4) {
                lVar29 = plVar11[5];
                uVar3 = plVar11[7];
                uVar35 = (long)__addr + plVar11[2];
                for (local_120 = uVar35; local_120 < uVar35 + lVar29;
                    local_120 = local_120 + ((uVar3 - 1) + uVar14 + uVar13 & uVar26)) {
                  if ((uVar35 - local_120) + lVar29 < 0xc) {
LAB_001044cb:
                    uVar25 = dcgettext(0,"%s: Invalid PT_NOTE segment\n",5);
                    error(uVar25,pcVar36);
                    uVar9 = 1;
                    goto LAB_001042bf;
                  }
                  lVar20 = (*DAT_001093c0)(local_120 + 8,4);
                  uVar12 = (*DAT_001093c0)(local_120,4);
                  if ((uVar35 - (long)(char *)(local_120 + 0xc)) + lVar29 < uVar12)
                  goto LAB_001044cb;
                  uVar13 = (*DAT_001093c0)(local_120 + 4,4);
                  uVar26 = -uVar3;
                  uVar14 = uVar3 + 0xb + uVar12 & uVar26;
                  uVar38 = local_120 + uVar14;
                  if ((uVar13 != 0) &&
                     ((uVar35 + lVar29 <= uVar38 || ((uVar35 - uVar38) + lVar29 < uVar13))))
                  goto LAB_001044cb;
                  if ((uVar12 == 4) &&
                     ((iVar8 = strcmp((char *)(local_120 + 0xc),"GNU"), iVar8 == 0 && (lVar20 == 5))
                     )) {
                    if ((uVar13 < 8) || (uVar13 % uVar3 != 0)) goto LAB_001044cb;
                    uVar12 = uVar38 + uVar13;
                    do {
                      iVar8 = (*DAT_001093c0)(uVar38,4);
                      uVar28 = (*DAT_001093c0)(uVar38 + 4,4);
                      lVar20 = uVar38 + 8;
                      if (uVar12 < lVar20 + (ulong)uVar28) goto LAB_001044cb;
                      if (iVar8 == -0x3ffffffe) {
                        if (uVar28 != 4) goto LAB_001044cb;
                        uVar28 = (*DAT_001093c0)(lVar20,4);
                        if (DAT_00109444 == 0) {
                          uVar33 = uVar28;
                          if (DAT_00109440 == 0) goto LAB_001042bf;
LAB_001042ac:
                          uVar33 = uVar33 & ~DAT_00109440;
                        }
                        else {
                          uVar33 = DAT_00109444 | uVar28;
                          if (DAT_00109440 != 0) goto LAB_001042ac;
                        }
                        if (uVar28 != uVar33) {
                          (*DAT_001093b8)(lVar20,uVar33,4);
                        }
                        goto LAB_001042bf;
                      }
                      uVar38 = lVar20 + ((ulong)uVar28 + (uVar3 - 1) & uVar26);
                    } while (7 < (long)(uVar12 - uVar38));
                  }
                }
              }
            }
LAB_001042bf:
            free(__ptr);
            munmap(__addr,local_c8.st_size);
          }
        }
        else {
LAB_0010438d:
          uVar25 = dcgettext(0,pcVar34,5);
          error(uVar25,pcVar36);
        }
      }
    }
    fclose(pFVar16);
  }
  uVar30 = uVar30 | uVar9;
  goto LAB_00103d1c;
switchD_00103cba_caseD_9a:
  DAT_0010915c = elf_osabi(_optarg);
  uVar30 = DAT_0010915c;
  goto joined_r0x00103eae;
code_r0x00104650:
  iVar10 = fseek(pFVar16,0,2);
  if (((iVar10 != -1) && (sVar17 = ftell(pFVar16), sVar17 != 0xffffffffffffffff)) &&
     (iVar10 = fseek(pFVar16,0,0), iVar10 != -1)) {
    __s = (byte *)xmalloc(sVar17 + 1);
    sVar18 = fread(__s,1,sVar17,pFVar16);
    if ((sVar17 == sVar18) || (iVar10 = ferror(pFVar16), iVar10 == 0)) {
      __s[sVar18] = 0;
      pbVar27 = __s;
LAB_001046fc:
      if (*pbVar27 == 0) {
        local_138 = (undefined8 *)xmalloc(8);
        *local_138 = 0;
      }
      else {
        if (((&DAT_00107040)[(ulong)*pbVar27 * 2] & 0x40) != 0) goto code_r0x00104718;
        local_d0 = __s;
        strlen((char *)__s);
        pbVar27 = (byte *)xmalloc();
        local_138 = (undefined8 *)0x0;
        iVar10 = 0;
        bVar6 = false;
        bVar5 = false;
        bVar7 = false;
        lVar20 = 0;
        do {
          consume_whitespace(&local_d0);
          pbVar22 = pbVar27;
          if ((iVar10 == 0) || (iVar10 + -1 <= (int)lVar20)) {
            if (local_138 == (undefined8 *)0x0) {
              iVar10 = 8;
              local_138 = (undefined8 *)xmalloc(0x40);
            }
            else {
              iVar10 = iVar10 * 2;
              local_138 = (undefined8 *)xrealloc(local_138,(long)iVar10 << 3);
            }
            local_138[lVar20] = 0;
          }
          for (; bVar2 = *local_d0, bVar2 != 0; local_d0 = local_d0 + 1) {
            if ((((&DAT_00107040)[(ulong)bVar2 * 2] & 0x40) != 0) &&
               (bVar4 = (bool)(bVar5 | bVar7 | bVar6), !bVar4)) {
              bVar6 = false;
              bVar7 = false;
              bVar5 = bVar4;
              break;
            }
            if (bVar6) {
              *pbVar22 = bVar2;
              bVar6 = false;
              pbVar22 = pbVar22 + 1;
            }
            else if (bVar2 == 0x5c) {
              bVar6 = true;
            }
            else if (bVar5) {
              if (bVar2 == 0x27) {
                bVar5 = false;
              }
              else {
LAB_00104c08:
                *pbVar22 = bVar2;
                pbVar22 = pbVar22 + 1;
              }
            }
            else if (bVar7) {
              if (bVar2 != 0x22) goto LAB_00104c08;
              bVar7 = false;
            }
            else if (bVar2 == 0x27) {
              bVar5 = true;
            }
            else {
              if (bVar2 != 0x22) goto LAB_00104c08;
              bVar7 = true;
            }
          }
          *pbVar22 = 0;
          uVar25 = xstrdup();
          local_138[lVar20] = uVar25;
          local_138[lVar20 + 1] = 0;
          consume_whitespace(&local_d0);
          lVar20 = lVar20 + 1;
        } while (*local_d0 != 0);
        free(pbVar27);
      }
      if (plVar21 == param_2) {
        lVar20 = 1;
        do {
          lVar23 = lVar20;
          lVar20 = lVar23 + 1;
        } while (plVar21[lVar23 + -1] != 0);
        plVar24 = (long *)xmalloc((long)(int)lVar23 << 3);
        plVar11 = plVar24;
        while (lVar20 = *plVar21, plVar21 = plVar21 + 1, lVar20 != 0) {
          lVar20 = xstrdup();
          *plVar11 = lVar20;
          plVar11 = plVar11 + 1;
        }
        *plVar11 = 0;
        lVar20 = 0;
      }
      else {
        lVar20 = 0;
        plVar24 = plVar21;
      }
      for (; local_138[lVar20] != 0; lVar20 = lVar20 + 1) {
      }
      free((void *)plVar24[lVar29]);
      plVar21 = (long *)xrealloc(plVar24,(lVar20 + 1 + (long)param_1) * 8);
      memmove(plVar21 + lVar29 + lVar20,plVar21 + lVar29 + 1,(long)(param_1 - iVar8) << 3);
      param_1 = param_1 + -1 + (int)lVar20;
      memcpy(plVar21 + lVar29,local_138,lVar20 * 8);
      free(local_138);
      free(__s);
      iVar8 = iVar8 + -1;
    }
    else {
      free(__s);
    }
  }
  fclose(pFVar16);
  goto LAB_00103c54;
code_r0x00104718:
  pbVar27 = pbVar27 + 1;
  goto LAB_001046fc;
}


////>>0x00104c60>>FUN_00104c60>>////

undefined  [16] FUN_00104c60(char *param_1,int param_2,undefined8 param_3,undefined8 param_4)

{
  int iVar1;
  uint uVar2;
  undefined8 uVar3;
  undefined auVar4 [16];
  
  iVar1 = strcasecmp(param_1,"ibt");
  uVar2 = 1;
  if (iVar1 != 0) {
    iVar1 = strcasecmp(param_1,"shstk");
    uVar2 = 2;
    if (iVar1 != 0) {
      iVar1 = strcasecmp(param_1,"lam_u48");
      if (iVar1 == 0) {
        uVar2 = 4;
      }
      else {
        iVar1 = strcasecmp(param_1,"lam_u57");
        uVar2 = 8;
        if (iVar1 != 0) {
          uVar3 = dcgettext(0,"Unknown x86 feature: %s\n",5);
          error(uVar3,param_1);
          uVar3 = 0xffffffff;
          goto LAB_00104ca5;
        }
      }
    }
  }
  if (param_2 == 0) {
    DAT_00109440 = uVar2 | DAT_00109440;
    DAT_00109444 = ~uVar2 & DAT_00109444;
  }
  else {
    DAT_00109444 = uVar2 | DAT_00109444;
    DAT_00109440 = DAT_00109440 & ~uVar2;
  }
  uVar3 = 0;
LAB_00104ca5:
  auVar4._8_8_ = param_4;
  auVar4._0_8_ = uVar3;
  return auVar4;
}


////>>0x00104ce0>>FUN_00104ce0>>////

undefined  [16] FUN_00104ce0(char *param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)

{
  int iVar1;
  undefined8 uVar2;
  ulong uVar3;
  uint uVar4;
  undefined4 *puVar5;
  undefined auVar6 [16];
  
  puVar5 = &DAT_00108ca0;
  uVar3 = 0;
  do {
    iVar1 = strcasecmp(param_1,*(char **)(puVar5 + 2));
    if (iVar1 == 0) {
      uVar3 = (ulong)(uint)(&DAT_00108ca0)[uVar3 * 4];
      goto LAB_00104d20;
    }
    uVar4 = (int)uVar3 + 1;
    uVar3 = (ulong)uVar4;
    puVar5 = puVar5 + 4;
  } while (uVar4 != 0x10);
  uVar2 = dcgettext(0,"Unknown OSABI: %s\n",5);
  error(uVar2,param_1);
  uVar3 = 0xffffffff;
LAB_00104d20:
  auVar6._8_8_ = param_4;
  auVar6._0_8_ = uVar3;
  return auVar6;
}


////>>0x00104d30>>FUN_00104d30>>////

int FUN_00104d30(char *param_1)

{
  int iVar1;
  int iVar2;
  undefined8 uVar3;
  
  iVar1 = strcasecmp(param_1,"i386");
  if (iVar1 == 0) {
    iVar1 = 3;
  }
  else {
    iVar1 = strcasecmp(param_1,"iamcu");
    if (iVar1 == 0) {
      return 6;
    }
    iVar2 = strcasecmp(param_1,"l1om");
    iVar1 = 0xb4;
    if (iVar2 != 0) {
      iVar1 = strcasecmp(param_1,"k1om");
      if (iVar1 == 0) {
        return 0xb5;
      }
      iVar1 = strcasecmp(param_1,"x86_64");
      if (iVar1 == 0) {
        iVar1 = 0x3e;
      }
      else {
        iVar1 = strcasecmp(param_1,"x86-64");
        if (iVar1 == 0) {
          iVar1 = 0x3e;
        }
        else {
          iVar1 = strcasecmp(param_1,"none");
          if (iVar1 != 0) {
            uVar3 = dcgettext(0,"Unknown machine type: %s\n",5);
            error(uVar3,param_1);
            iVar1 = -1;
          }
        }
      }
    }
  }
  return iVar1;
}


////>>0x00104da0>>FUN_00104da0>>////

int FUN_00104da0(char *param_1)

{
  int iVar1;
  int iVar2;
  undefined8 uVar3;
  
  iVar1 = strcasecmp(param_1,"rel");
  if (iVar1 == 0) {
    iVar1 = 1;
  }
  else {
    iVar2 = strcasecmp(param_1,"exec");
    iVar1 = 2;
    if (iVar2 != 0) {
      iVar1 = strcasecmp(param_1,"dyn");
      if (iVar1 == 0) {
        iVar1 = 3;
      }
      else {
        iVar1 = strcasecmp(param_1,"none");
        if (iVar1 != 0) {
          uVar3 = dcgettext(0,"Unknown type: %s\n",5);
          error(uVar3,param_1);
          iVar1 = -1;
        }
      }
    }
  }
  return iVar1;
}


////>>0x00104de0>>FUN_00104de0>>////



undefined8 FUN_00104de0(undefined8 param_1,FILE *param_2)

{
  int iVar1;
  long __off;
  size_t sVar2;
  undefined8 uVar3;
  char *pcVar4;
  uint uVar5;
  uint uVar6;
  
  __off = ftell(param_2);
  sVar2 = fread(&DAT_001093e0,0x10,1,param_2);
  if ((sVar2 == 1) && (_DAT_001093e0 == 0x464c457f)) {
    DAT_001093b8 = byte_put_big_endian;
    if (DAT_001093e5 != '\x02') {
      DAT_001093b8 = byte_put_little_endian;
    }
    DAT_001093c0 = byte_get_big_endian;
    if (DAT_001093e5 != '\x02') {
      DAT_001093c0 = byte_get_little_endian;
    }
    if ((char)_DAT_001093e4 == '\x01') {
      sVar2 = fread(&DAT_00109390,0x24,1,param_2);
      if (sVar2 != 1) goto code_r0x00102558;
      DAT_00109418 = (*DAT_001093c0)(&DAT_00109390,2);
      DAT_0010941a = (*DAT_001093c0)(&DAT_00109392,2);
      _DAT_00109408 = (*DAT_001093c0)(&DAT_00109394,4);
      _DAT_001093f0 = (*DAT_001093c0)(&DAT_00109398,4);
      DAT_001093f8 = (*DAT_001093c0)(&DAT_0010939c,4);
      _DAT_00109400 = (*DAT_001093c0)(&DAT_001093a0,4);
      _DAT_00109410 = (*DAT_001093c0)(&DAT_001093a4,4);
      _DAT_0010941c = (*DAT_001093c0)(&DAT_001093a8,2);
      _DAT_00109420 = (*DAT_001093c0)(&DAT_001093aa,2);
      DAT_00109424 = (*DAT_001093c0)(&DAT_001093ac,2);
      _DAT_00109428 = (*DAT_001093c0)(&DAT_001093ae,2);
      _DAT_0010942c = (*DAT_001093c0)(&DAT_001093b0,2);
      _DAT_00109430 = (*DAT_001093c0)(&DAT_001093b2,2);
      _DAT_00109380 = _DAT_001093e0;
      uRam0000000000109384 = _DAT_001093e4;
      _DAT_00109388 = _DAT_001093e8;
      uRam000000000010938c = uRam00000000001093ec;
    }
    else {
      if ((char)_DAT_001093e4 != '\x02') {
        uVar3 = FUN_00102558();
        return uVar3;
      }
      sVar2 = fread(&DAT_00109350,0x30,1,param_2);
      if (sVar2 != 1) goto code_r0x00102558;
      DAT_00109418 = (*DAT_001093c0)(&DAT_00109350,2);
      DAT_0010941a = (*DAT_001093c0)(&DAT_00109352,2);
      _DAT_00109408 = (*DAT_001093c0)(&DAT_00109354,4);
      _DAT_001093f0 = (*DAT_001093c0)(&DAT_00109358,8);
      DAT_001093f8 = (*DAT_001093c0)(&DAT_00109360,8);
      _DAT_00109400 = (*DAT_001093c0)(&DAT_00109368,8);
      _DAT_00109410 = (*DAT_001093c0)(&DAT_00109370,4);
      _DAT_0010941c = (*DAT_001093c0)(&DAT_00109374,2);
      _DAT_00109420 = (*DAT_001093c0)(&DAT_00109376,2);
      DAT_00109424 = (*DAT_001093c0)(&DAT_00109378,2);
      _DAT_00109428 = (*DAT_001093c0)(&DAT_0010937a,2);
      _DAT_0010942c = (*DAT_001093c0)(&DAT_0010937c,2);
      _DAT_00109430 = (*DAT_001093c0)(&DAT_0010937e,2);
      _DAT_00109340 = _DAT_001093e0;
      uRam0000000000109344 = _DAT_001093e4;
      _DAT_00109348 = _DAT_001093e8;
      uRam000000000010934c = uRam00000000001093ec;
    }
    iVar1 = fseek(param_2,__off,0);
    if (iVar1 != 0) {
      uVar3 = dcgettext(0,"%s: Failed to seek to ELF header\n",5);
      error(uVar3,param_1);
    }
    uVar5 = _DAT_001093e4 >> 0x10 & 0xff;
    if ((char)uVar5 == '\x01') {
      uVar5 = (uint)DAT_0010941a;
      if (uVar5 == DAT_0010916c) {
        return 0;
      }
      uVar6 = _DAT_001093e4 & 0xff;
      if (DAT_00109170 == 0xffffffff) {
        if (DAT_0010941a == 6) {
          DAT_00109170 = 1;
        }
        else if (DAT_0010941a < 7) {
          DAT_00109170 = (DAT_0010941a != 3) + 1 + (uint)(DAT_0010941a != 3);
        }
        else {
          DAT_00109170 = 3 - ((ushort)(DAT_0010941a - 0xb4) < 2);
        }
      }
      if ((uVar6 == DAT_00109170) || (DAT_00109170 == 3)) {
        if ((uVar6 == DAT_00109168) || (DAT_00109168 == 3)) {
          if ((uVar5 == DAT_00109174) || (DAT_00109174 == 0xffffffff)) {
            uVar5 = (uint)DAT_00109418;
            if ((DAT_00109164 == 0xffffffff) || (uVar5 == DAT_00109164)) {
              uVar5 = _DAT_001093e4 >> 0x18;
              if ((DAT_0010915c == 0xffffffff) || (uVar5 == DAT_0010915c)) {
                uVar5 = _DAT_001093e8 & 0xff;
                if ((uVar5 == DAT_00109154) || (DAT_00109154 == 0xffffffff)) {
                  if ((char)uVar6 == '\x01') {
                    if (DAT_0010916c != 0xffffffff) {
                      (*DAT_001093b8)(&DAT_00109392,(long)(int)DAT_0010916c,2);
                    }
                    if (DAT_00109160 != -1) {
                      (*DAT_001093b8)(&DAT_00109390,(long)DAT_00109160,2);
                    }
                    if (DAT_00109158 != -1) {
                      uRam0000000000109384 =
                           CONCAT13((char)DAT_00109158,(undefined3)uRam0000000000109384);
                    }
                    if (DAT_00109150 != -1) {
                      _DAT_00109388 = CONCAT31(DAT_00109388_1,(char)DAT_00109150);
                    }
                    sVar2 = fwrite(&DAT_00109380,0x34,1,param_2);
                    if (sVar2 == 1) {
                      return 0;
                    }
                    uVar3 = FUN_001024ec();
                    return uVar3;
                  }
                  if ((char)uVar6 != '\x02') {
                    
                    abort();
                  }
                  if (DAT_0010916c != 0xffffffff) {
                    (*DAT_001093b8)(&DAT_00109352,(long)(int)DAT_0010916c,2);
                  }
                  if (DAT_00109160 != -1) {
                    (*DAT_001093b8)(&DAT_00109350,(long)DAT_00109160,2);
                  }
                  if (DAT_00109158 != -1) {
                    uRam0000000000109344 =
                         CONCAT13((char)DAT_00109158,(undefined3)uRam0000000000109344);
                  }
                  if (DAT_00109150 != -1) {
                    _DAT_00109348 = CONCAT31(DAT_00109348_1,(char)DAT_00109150);
                  }
                  sVar2 = fwrite(&DAT_00109340,0x40,1,param_2);
                  if (sVar2 == 1) {
                    return 0;
                  }
                  uVar3 = FUN_001024ec();
                  return uVar3;
                }
                pcVar4 = "%s: Unmatched EI_ABIVERSION: %d is not %d\n";
                uVar6 = DAT_00109154;
              }
              else {
                pcVar4 = "%s: Unmatched EI_OSABI: %d is not %d\n";
                uVar6 = DAT_0010915c;
              }
            }
            else {
              pcVar4 = "%s: Unmatched e_type: %d is not %d\n";
              uVar6 = DAT_00109164;
            }
          }
          else {
            pcVar4 = "%s: Unmatched e_machine: %d is not %d\n";
            uVar6 = DAT_00109174;
          }
          uVar3 = dcgettext(0,pcVar4,5);
          error(uVar3,param_1,uVar5,uVar6);
          return 1;
        }
        pcVar4 = "%s: Unmatched output EI_CLASS: %d is not %d\n";
        uVar5 = DAT_00109168;
      }
      else {
        pcVar4 = "%s: Unmatched input EI_CLASS: %d is not %d\n";
        uVar5 = DAT_00109170;
      }
      uVar3 = dcgettext(0,pcVar4,5);
      error(uVar3,param_1,uVar6,uVar5);
    }
    else {
      uVar3 = dcgettext(0,"%s: Unsupported EI_VERSION: %d is not %d\n",5);
      error(uVar3,param_1,uVar5,1);
    }
  }
  else {
code_r0x00102558:
    uVar3 = dcgettext(0,"%s: Failed to read ELF header\n",5);
    error(uVar3,param_1);
  }
  return 1;
}


////>>0x00105370>>FUN_00105370>>////

char * FUN_00105370(char *param_1,char *param_2)

{
  ulong __size;
  long lVar1;
  char cVar2;
  undefined8 uVar3;
  char *pcVar4;
  char *pcVar5;
  char *pcVar6;
  ulong uVar7;
  ulong extraout_RDX;
  ulong uVar8;
  byte bVar9;
  
  bVar9 = 0;
  pcVar5 = (char *)0x1;
  if (param_1 != (char *)0x0) {
    pcVar5 = param_1;
  }
  pcVar6 = (char *)malloc((size_t)pcVar5);
  if (pcVar6 != (char *)0x0) {
    return pcVar6;
  }
  xmalloc_failed();
  pcVar6 = pcVar5;
  pcVar4 = pcVar5;
  while (cVar2 = *pcVar6, cVar2 != '\0') {
    pcVar6 = pcVar6 + 1;
    if (cVar2 == '/') {
      pcVar4 = pcVar6;
    }
  }
  if ((*param_2 == '/') || (pcVar5 == pcVar4)) {
    if (extraout_RDX + 1 == 0) {
      return (char *)0x0;
    }
    pcVar6 = (char *)malloc(extraout_RDX + 1);
    uVar7 = extraout_RDX;
    pcVar5 = pcVar6;
    if (pcVar6 != (char *)0x0) {
      for (; uVar7 != 0; uVar7 = uVar7 - 1) {
        *pcVar5 = *param_2;
        param_2 = param_2 + (ulong)bVar9 * -2 + 1;
        pcVar5 = pcVar5 + (ulong)bVar9 * -2 + 1;
      }
      pcVar6[extraout_RDX] = '\0';
      return pcVar6;
    }
  }
  else {
    uVar8 = (long)pcVar4 - (long)pcVar5;
    lVar1 = uVar8 + extraout_RDX;
    uVar7 = extraout_RDX;
    if (extraout_RDX <= uVar8) {
      uVar7 = uVar8;
    }
    __size = lVar1 + 1;
    if (__size < uVar7) {
      uVar3 = dcgettext(0,"Abnormal length of thin archive member name: %lx\n",5);
      error(uVar3,extraout_RDX);
      return (char *)0x0;
    }
    pcVar4 = (char *)malloc(__size);
    pcVar6 = pcVar4;
    if (pcVar4 != (char *)0x0) {
      for (; uVar7 = extraout_RDX, uVar8 != 0; uVar8 = uVar8 - 1) {
        *pcVar6 = *pcVar5;
        pcVar5 = pcVar5 + (ulong)bVar9 * -2 + 1;
        pcVar6 = pcVar6 + (ulong)bVar9 * -2 + 1;
      }
      for (; uVar7 != 0; uVar7 = uVar7 - 1) {
        *pcVar6 = *param_2;
        param_2 = param_2 + (ulong)bVar9 * -2 + 1;
        pcVar6 = pcVar6 + (ulong)bVar9 * -2 + 1;
      }
      pcVar4[lVar1] = '\0';
      return pcVar4;
    }
  }
  uVar3 = dcgettext(0,"Out of memory\n",5);
  error(uVar3);
  return (char *)0x0;
}


////>>0x00105394>>FUN_00105394>>////

void FUN_00105394(void)

{
  return;
}

