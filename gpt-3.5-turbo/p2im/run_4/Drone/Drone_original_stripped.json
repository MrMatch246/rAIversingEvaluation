{
    "functions": {
        "FUN_08000110": {
            "entrypoint": "0x08000110",
            "current_name": "set_completed_flag_08000110",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800011c) */\n\nundefined4 set_completed_flag_08000110(undefined4 input_param)\n\n{\n  if ((char)completed_flag == '\\0') {\n    completed_flag._0_1_ = '\\x01';\n  }\n  return input_param;\n}\n\n",
            "renaming": {
                "FUN_08000110": "set_completed_flag_08000110",
                "param_1": "input_param",
                "completed_8672": "completed_flag"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000134": {
            "entrypoint": "0x08000134",
            "current_name": "concatenate_values_08000134",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800013a) */\n\nundefined8 concatenate_values_08000134(undefined4 value1,undefined4 value2)\n\n{\n  return CONCAT44(value2,value1);\n}\n\n",
            "renaming": {
                "FUN_08000134": "concatenate_values_08000134",
                "param_1": "value1",
                "param_2": "value2"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000150": {
            "entrypoint": "0x08000150",
            "current_name": "calculate_string_length_08000150",
            "code": "\nsize_t calculateStringLength_08000150(char *string)\n\n{\n  char currentChar;\n  char *nextCharPtr;\n  char *currentCharPtr;\n  \n  currentCharPtr = string;\n  do {\n    nextCharPtr = currentCharPtr + 1;\n    currentChar = *currentCharPtr;\n    currentCharPtr = nextCharPtr;\n  } while (currentChar != '\\0');\n  return (size_t)(nextCharPtr + (-1 - (int)string));\n}\n\n",
            "renaming": {
                "FUN_08000150": "calculate_string_length_08000150",
                "__s": "string",
                "cVar1": "currentChar",
                "pcVar2": "nextCharPtr",
                "pcVar3": "currentCharPtr"
            },
            "calling": [
                "serialPrint"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000160": {
            "entrypoint": "0x08000160",
            "current_name": "addition_operation_08000160",
            "code": "\nvoid additionOperation_08000160(undefined4 result,uint input)\n\n{\n  __aeabi_dadd(result,input ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000160": "addition_operation_08000160",
                "param_1": "result",
                "param_2": "input"
            },
            "calling": [],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000168": {
            "entrypoint": "0x08000168",
            "current_name": "calculate_08000168",
            "code": "\nulonglong calculate_08000168(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int var1;\n  byte var2;\n  uint var3;\n  uint var4;\n  uint var5;\n  uint var6;\n  uint var7;\n  int var8;\n  uint var9;\n  uint var10;\n  uint var11;\n  uint var12;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  \n  var6 = input4 ^ 0x80000000;\n  var9 = input2 << 1;\n  input4 = input4 << 1;\n  flag1 = ((input2 ^ var6) & 0x7fffffff) == 0;\n  flag2 = flag1 && input1 == input3;\n  if (!flag1 || input1 != input3) {\n    flag2 = (var9 | input1) == 0;\n  }\n  if (!flag2) {\n    flag2 = (input4 | input3) == 0;\n  }\n  var8 = (int)var9 >> 0x15;\n  if (!flag2) {\n    flag2 = var8 == -1;\n  }\n  var1 = (int)input4 >> 0x15;\n  if (!flag2) {\n    flag2 = var1 == -1;\n  }\n  if (flag2) {\n    if (var8 == -1 || var1 == -1) {\n      var9 = var6;\n      var11 = input3;\n      if (var8 == -1) {\n        var9 = input2;\n        var11 = input1;\n      }\n      if (var8 != -1 || var1 != -1) {\n        input3 = var11;\n        var6 = var9;\n      }\n      flag2 = (var11 | var9 << 0xc) == 0;\n      if (flag2) {\n        flag2 = (input3 | var6 << 0xc) == 0;\n      }\n      if (flag2) {\n        flag2 = var9 == var6;\n      }\n      if (!flag2) {\n        var9 = var9 | 0x80000;\n      }\n      return CONCAT44(var9,var11);\n    }\n    if (((input2 ^ var6) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((var9 | input1) == 0) {\n        input1 = input3;\n        input2 = var6;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != var6) {\n      return 0;\n    }\n    if (var9 >> 0x15 == 0) {\n      flag2 = (input1 & 0x80000000) != 0;\n      var6 = input2 * 2 + (uint)flag2;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)flag2)) {\n        var6 = var6 | 0x80000000;\n      }\n      return CONCAT44(var6,input1 << 1);\n    }\n    if (var9 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_080003ac:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  var9 = var9 >> 0x15;\n  input4 = input4 >> 0x15;\n  var11 = input4 - var9;\n  flag2 = var11 != 0;\n  if (input4 < var9) {\n    var11 = -var11;\n  }\n  var10 = input1;\n  var7 = input2;\n  if (flag2 && var9 <= input4) {\n    var9 = var9 + var11;\n    var10 = input3;\n    var7 = var6;\n    input3 = input1;\n    var6 = input2;\n  }\n  if (0x36 < var11) {\n    return CONCAT44(var7,var10);\n  }\n  var4 = var7 & 0xfffff | 0x100000;\n  if ((var7 & 0x80000000) != 0) {\n    flag2 = var10 != 0;\n    var10 = -var10;\n    var4 = -var4 - (uint)flag2;\n  }\n  var7 = var6 & 0xfffff | 0x100000;\n  if ((var6 & 0x80000000) != 0) {\n    flag2 = input3 != 0;\n    input3 = -input3;\n    var7 = -var7 - (uint)flag2;\n  }\n  if (var9 == var11) {\n    var7 = var7 ^ 0x100000;\n    if (var9 == 0) {\n      var4 = var4 ^ 0x100000;\n      var9 = 1;\n    }\n    else {\n      var11 = var11 - 1;\n    }\n  }\n  var6 = -var11 + 0x20;\n  if ((int)var11 < 0x21) {\n    var12 = input3 << (var6 & 0xff);\n    input3 = input3 >> (var11 & 0xff);\n    var3 = var10 + input3;\n    var5 = var7 << (var6 & 0xff);\n    var6 = var3 + var5;\n    var4 = var4 + CARRY4(var10,input3) + ((int)var7 >> (var11 & 0xff)) +\n            (uint)CARRY4(var3,var5);\n  }\n  else {\n    var12 = var7 << (-var11 + 0x40 & 0xff);\n    if (input3 != 0) {\n      var12 = var12 | 2;\n    }\n    var7 = (int)var7 >> (var11 - 0x20 & 0xff);\n    var6 = var10 + var7;\n    var4 = var4 + ((int)var7 >> 0x1f) + (uint)CARRY4(var10,var7);\n  }\n  input2 = var4 & 0x80000000;\n  var11 = var4;\n  if ((int)var4 < 0) {\n    flag2 = var12 == 0;\n    var12 = -var12;\n    var11 = -var6;\n    var6 = -(uint)!flag2 - var6;\n    var11 = -(uint)(flag2 <= var11) - var4;\n  }\n  if (0xfffff < var11) {\n    var10 = var9 - 1;\n    if (0x1fffff < var11) {\n      var10 = var11 & 1;\n      var11 = var11 >> 1;\n      var2 = (byte)var6;\n      var6 = (uint)(var10 != 0) << 0x1f | var6 >> 1;\n      var12 = (uint)(var2 & 1) << 0x1f | var12 >> 1;\n      var10 = var9;\n      if (0xffbfffff < var9 * 0x200000) goto LAB_080003ac;\n    }\nLAB_08000278:\n    flag2 = 0x7fffffff < var12;\n    if (var12 == 0x80000000) {\n      flag2 = (var6 & 1) != 0;\n    }\n    return CONCAT44(var11 + var10 * 0x100000 + (uint)CARRY4(var6,(uint)flag2) | input2,\n                    var6 + flag2);\n  }\n  flag1 = (var12 & 0x80000000) != 0;\n  var12 = var12 << 1;\n  var10 = var6 * 2;\n  flag2 = CARRY4(var6,var6);\n  var6 = var6 * 2 + (uint)flag1;\n  var11 = var11 * 2 + (uint)(flag2 || CARRY4(var10,(uint)flag1));\n  var10 = var9 - 2;\n  if ((var11 & 0x100000) != 0) goto LAB_08000278;\n  var7 = var6;\n  var9 = var11;\n  if (var11 == 0) {\n    var7 = 0;\n    var9 = var6;\n  }\n  var8 = LZCOUNT(var9);\n  if (var11 == 0) {\n    var8 = var8 + 0x20;\n  }\n  var11 = var8 - 0xb;\n  flag3 = SBORROW4(var11,0x20);\n  var6 = var8 - 0x2b;\n  flag2 = (int)var6 < 0;\n  flag1 = var6 == 0;\n  if ((int)var11 < 0x20) {\n    flag3 = SCARRY4(var6,0xc);\n    var8 = var8 + -0x1f;\n    flag2 = var8 < 0;\n    flag1 = var8 == 0;\n    var6 = var11;\n    if (!flag1 && flag2 == flag3) {\n      var7 = var9 << (var11 & 0xff);\n      var9 = var9 >> (0xcU - var8 & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (flag1 || flag2 != flag3) {\n    var12 = 0x20 - var6;\n  }\n  var9 = var9 << (var6 & 0xff);\n  if (flag1 || flag2 != flag3) {\n    var9 = var9 | var7 >> (var12 & 0xff);\n  }\n  if (flag1 || flag2 != flag3) {\n    var7 = var7 << (var6 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)var11 <= (int)var10) {\n    return CONCAT44(var9 + (var10 - var11) * 0x100000 | input2,var7);\n  }\n  var6 = ~(var10 - var11);\n  if ((int)var6 < 0x1f) {\n    var8 = var6 - 0x13;\n    if (var8 != 0 && var8 < 0 == SCARRY4(var6 - 0x1f,0xc)) {\n      return CONCAT44(var4,var7 >> (0x20 - (0xcU - var8) & 0xff) | var9 << (0xcU - var8 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    var6 = var6 + 1;\n    return CONCAT44(input2 | var9 >> (var6 & 0xff),\n                    var7 >> (var6 & 0xff) | var9 << (0x20 - var6 & 0xff));\n  }\n  return CONCAT44(var4,var9 >> (var6 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000168": "calculate_08000168",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "var1",
                "bVar2": "var2",
                "uVar3": "var3",
                "uVar4": "var4",
                "uVar5": "var5",
                "uVar6": "var6",
                "uVar7": "var7",
                "iVar8": "var8",
                "uVar9": "var9",
                "uVar10": "var10",
                "uVar11": "var11",
                "uVar12": "var12",
                "bVar13": "flag1",
                "bVar14": "flag2",
                "bVar15": "flag3"
            },
            "calling": [
                "__ieee754_atan2",
                "rint",
                "atan",
                "__ieee754_sqrt",
                "__ieee754_asin",
                "MS5611_Update",
                "__ieee754_pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800016c": {
            "entrypoint": "0x0800016c",
            "current_name": "calculate_0800016c",
            "code": "\nulonglong calculate_0800016c(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int firstShift;\n  byte tempByte;\n  uint carry;\n  uint sum1;\n  uint sum2;\n  int secondShift;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  \n  temp1 = param_2 << 1;\n  temp3 = param_4 << 1;\n  flag1 = ((param_2 ^ param_4) & 0x7fffffff) == 0;\n  flag2 = flag1 && param_1 == param_3;\n  if (!flag1 || param_1 != param_3) {\n    flag2 = (temp1 | param_1) == 0;\n  }\n  if (!flag2) {\n    flag2 = (temp3 | param_3) == 0;\n  }\n  secondShift = (int)temp1 >> 0x15;\n  if (!flag2) {\n    flag2 = secondShift == -1;\n  }\n  firstShift = (int)temp3 >> 0x15;\n  if (!flag2) {\n    flag2 = firstShift == -1;\n  }\n  if (flag2) {\n    if (secondShift == -1 || firstShift == -1) {\n      temp3 = param_4;\n      temp1 = param_3;\n      if (secondShift == -1) {\n        temp3 = param_2;\n        temp1 = param_1;\n      }\n      if (secondShift != -1 || firstShift != -1) {\n        param_3 = temp1;\n        param_4 = temp3;\n      }\n      flag2 = (temp1 | temp3 << 0xc) == 0;\n      if (flag2) {\n        flag2 = (param_3 | param_4 << 0xc) == 0;\n      }\n      if (flag2) {\n        flag2 = temp3 == param_4;\n      }\n      if (!flag2) {\n        temp3 = temp3 | 0x80000;\n      }\n      return CONCAT44(temp3,temp1);\n    }\n    if (((param_2 ^ param_4) & 0x7fffffff) != 0 || param_1 != param_3) {\n      if ((temp1 | param_1) == 0) {\n        param_1 = param_3;\n        param_2 = param_4;\n      }\n      return CONCAT44(param_2,param_1);\n    }\n    if (param_2 != param_4) {\n      return 0;\n    }\n    if (temp1 >> 0x15 == 0) {\n      flag2 = (param_1 & 0x80000000) != 0;\n      temp3 = param_2 * 2 + (uint)flag2;\n      if (CARRY4(param_2,param_2) || CARRY4(param_2 * 2,(uint)flag2)) {\n        temp3 = temp3 | 0x80000000;\n      }\n      return CONCAT44(temp3,param_1 << 1);\n    }\n    if (temp1 < 0xffc00000) {\n      return CONCAT44(param_2 + 0x100000,param_1);\n    }\n    param_2 = param_2 & 0x80000000;\nLAB_080003ac:\n    return (ulonglong)(param_2 | 0x7ff00000) << 0x20;\n  }\n  temp1 = temp1 >> 0x15;\n  temp3 = temp3 >> 0x15;\n  temp4 = temp3 - temp1;\n  flag2 = temp4 != 0;\n  if (temp3 < temp1) {\n    temp4 = -temp4;\n  }\n  temp2 = param_1;\n  sum2 = param_2;\n  if (flag2 && temp1 <= temp3) {\n    temp1 = temp1 + temp4;\n    temp2 = param_3;\n    sum2 = param_4;\n    param_3 = param_1;\n    param_4 = param_2;\n  }\n  if (0x36 < temp4) {\n    return CONCAT44(sum2,temp2);\n  }\n  temp3 = sum2 & 0xfffff | 0x100000;\n  if ((sum2 & 0x80000000) != 0) {\n    flag2 = temp2 != 0;\n    temp2 = -temp2;\n    temp3 = -temp3 - (uint)flag2;\n  }\n  sum2 = param_4 & 0xfffff | 0x100000;\n  if ((param_4 & 0x80000000) != 0) {\n    flag2 = param_3 != 0;\n    param_3 = -param_3;\n    sum2 = -sum2 - (uint)flag2;\n  }\n  if (temp1 == temp4) {\n    sum2 = sum2 ^ 0x100000;\n    if (temp1 == 0) {\n      temp3 = temp3 ^ 0x100000;\n      temp1 = 1;\n    }\n    else {\n      temp4 = temp4 - 1;\n    }\n  }\n  temp6 = -temp4 + 0x20;\n  if ((int)temp4 < 0x21) {\n    temp5 = param_3 << (temp6 & 0xff);\n    param_3 = param_3 >> (temp4 & 0xff);\n    carry = temp2 + param_3;\n    sum1 = sum2 << (temp6 & 0xff);\n    temp6 = carry + sum1;\n    temp3 = temp3 + CARRY4(temp2,param_3) + ((int)sum2 >> (temp4 & 0xff)) +\n            (uint)CARRY4(carry,sum1);\n  }\n  else {\n    temp5 = sum2 << (-temp4 + 0x40 & 0xff);\n    if (param_3 != 0) {\n      temp5 = temp5 | 2;\n    }\n    sum2 = (int)sum2 >> (temp4 - 0x20 & 0xff);\n    temp6 = temp2 + sum2;\n    temp3 = temp3 + ((int)sum2 >> 0x1f) + (uint)CARRY4(temp2,sum2);\n  }\n  param_2 = temp3 & 0x80000000;\n  temp4 = temp3;\n  if ((int)temp3 < 0) {\n    flag2 = temp5 == 0;\n    temp5 = -temp5;\n    temp4 = -temp6;\n    temp6 = -(uint)!flag2 - temp6;\n    temp4 = -(uint)(flag2 <= temp4) - temp3;\n  }\n  if (0xfffff < temp4) {\n    temp2 = temp1 - 1;\n    if (0x1fffff < temp4) {\n      temp3 = temp4 & 1;\n      temp4 = temp4 >> 1;\n      tempByte = (byte)temp6;\n      temp6 = (uint)(temp3 != 0) << 0x1f | temp6 >> 1;\n      temp5 = (uint)(tempByte & 1) << 0x1f | temp5 >> 1;\n      temp2 = temp1;\n      if (0xffbfffff < temp1 * 0x200000) goto LAB_080003ac;\n    }\nLAB_08000278:\n    flag2 = 0x7fffffff < temp5;\n    if (temp5 == 0x80000000) {\n      flag2 = (temp6 & 1) != 0;\n    }\n    return CONCAT44(temp4 + temp2 * 0x100000 + (uint)CARRY4(temp6,(uint)flag2) | param_2,\n                    temp6 + flag2);\n  }\n  flag1 = (temp5 & 0x80000000) != 0;\n  temp5 = temp5 << 1;\n  temp2 = temp6 * 2;\n  flag2 = CARRY4(temp6,temp6);\n  temp6 = temp6 * 2 + (uint)flag1;\n  temp4 = temp4 * 2 + (uint)(flag2 || CARRY4(temp2,(uint)flag1));\n  temp2 = temp1 - 2;\n  if ((temp4 & 0x100000) != 0) goto LAB_08000278;\n  sum2 = temp6;\n  temp1 = temp4;\n  if (temp4 == 0) {\n    sum2 = 0;\n    temp1 = temp6;\n  }\n  secondShift = LZCOUNT(temp1);\n  if (temp4 == 0) {\n    secondShift = secondShift + 0x20;\n  }\n  temp6 = secondShift - 0xb;\n  flag3 = SBORROW4(temp6,0x20);\n  temp4 = secondShift - 0x2b;\n  flag2 = (int)temp4 < 0;\n  flag1 = temp4 == 0;\n  if ((int)temp6 < 0x20) {\n    flag3 = SCARRY4(temp4,0xc);\n    secondShift = secondShift + -0x1f;\n    flag2 = secondShift < 0;\n    flag1 = secondShift == 0;\n    temp4 = temp6;\n    if (!flag1 && flag2 == flag3) {\n      sum2 = temp1 << (temp6 & 0xff);\n      temp1 = temp1 >> (0xcU - secondShift & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (flag1 || flag2 != flag3) {\n    temp5 = 0x20 - temp4;\n  }\n  temp1 = temp1 << (temp4 & 0xff);\n  if (flag1 || flag2 != flag3) {\n    temp1 = temp1 | sum2 >> (temp5 & 0xff);\n  }\n  if (flag1 || flag2 != flag3) {\n    sum2 = sum2 << (temp4 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)temp6 <= (int)temp2) {\n    return CONCAT44(temp1 + (temp2 - temp6) * 0x100000 | param_2,sum2);\n  }\n  temp4 = ~(temp2 - temp6);\n  if ((int)temp4 < 0x1f) {\n    secondShift = temp4 - 0x13;\n    if (secondShift != 0 && secondShift < 0 == SCARRY4(temp4 - 0x1f,0xc)) {\n      return CONCAT44(temp3,sum2 >> (0x20 - (0xcU - secondShift) & 0xff) | temp1 << (0xcU - secondShift & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    temp4 = temp4 + 1;\n    return CONCAT44(param_2 | temp1 >> (temp4 & 0xff),\n                    sum2 >> (temp4 & 0xff) | temp1 << (0x20 - temp4 & 0xff));\n  }\n  return CONCAT44(temp3,temp1 >> (temp4 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800016c": "calculate_0800016c",
                "iVar1": "firstShift",
                "bVar2": "tempByte",
                "uVar3": "carry",
                "uVar4": "sum1",
                "uVar5": "sum2",
                "iVar6": "secondShift",
                "uVar7": "temp1",
                "uVar8": "temp2",
                "uVar9": "temp3",
                "uVar10": "temp4",
                "uVar11": "temp5",
                "uVar12": "temp6",
                "bVar13": "flag1",
                "bVar14": "flag2",
                "bVar15": "flag3"
            },
            "calling": [
                "scalbn",
                "__ieee754_atan2",
                "rint",
                "atan",
                "__ieee754_sqrt",
                "__ieee754_asin",
                "__aeabi_drsub",
                "__ieee754_pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003e4": {
            "entrypoint": "0x080003e4",
            "current_name": "bitwise_shift_080003e4",
            "code": "\nulonglong bitwiseShift_080003e4(uint input)\n\n{\n  uint result;\n  uint shiftAmount;\n  int count;\n  uint offset;\n  uint mask;\n  bool isNegative;\n  bool isZero;\n  bool isCarry;\n  \n  if (input == 0) {\n    return 0;\n  }\n  result = 0;\n  count = LZCOUNT(input);\n  offset = count + 0x15;\n  isCarry = SBORROW4(offset,0x20);\n  shiftAmount = count - 0xb;\n  isNegative = (int)shiftAmount < 0;\n  isZero = shiftAmount == 0;\n  if (offset < 0x20) {\n    isCarry = SCARRY4(shiftAmount,0xc);\n    isNegative = false;\n    isZero = count + 1 == 0;\n    shiftAmount = offset;\n    if (!isZero && isCarry == false) {\n      result = input << offset;\n      input = input >> (0xcU - (count + 1) & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (isZero || isNegative != isCarry) {\n    mask = 0x20 - shiftAmount;\n  }\n  input = input << (shiftAmount & 0xff);\n  if (isZero || isNegative != isCarry) {\n    input = input | 0U >> (mask & 0xff);\n  }\n  if (isZero || isNegative != isCarry) {\n    result = 0 << (shiftAmount & 0xff);\n  }\nLAB_080002f0:\n  if (offset < 0x433) {\n    return CONCAT44(input + (0x432 - offset) * 0x100000,result);\n  }\n  shiftAmount = ~(0x432 - offset);\n  if (0x1e < (int)shiftAmount) {\n    return (ulonglong)(input >> (shiftAmount - 0x1f & 0xff));\n  }\n  count = shiftAmount - 0x13;\n  if (count == 0 || count < 0 != SCARRY4(shiftAmount - 0x1f,0xc)) {\n    shiftAmount = shiftAmount + 1;\n    return CONCAT44(input >> (shiftAmount & 0xff),\n                    result >> (shiftAmount & 0xff) | input << (0x20 - shiftAmount & 0xff));\n  }\n  return (ulonglong)(result >> (0x20 - (0xcU - count) & 0xff) | input << (0xcU - count & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080003e4": "bitwise_shift_080003e4",
                "param_1": "input",
                "uVar1": "result",
                "uVar2": "shiftAmount",
                "iVar3": "count",
                "uVar4": "offset",
                "in_r12": "mask",
                "bVar5": "isNegative",
                "bVar6": "isZero",
                "bVar7": "isCarry"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000404": {
            "entrypoint": "0x08000404",
            "current_name": "calculate_shifted_value_08000404",
            "code": "\nulonglong calculate_shifted_value_08000404(uint input_number)\n\n{\n  uint shift_amount;\n  uint abs_input_number;\n  uint shifted_number;\n  int leading_zeros;\n  uint shifted_number_threshold;\n  uint sign_bit;\n  uint remaining_bits;\n  bool negative_shift;\n  bool zero_shift;\n  bool carry_bit;\n  \n  if (input_number == 0) {\n    return 0;\n  }\n  sign_bit = input_number & 0x80000000;\n  abs_input_number = input_number;\n  if ((int)sign_bit < 0) {\n    abs_input_number = -input_number;\n  }\n  shift_amount = 0;\n  leading_zeros = LZCOUNT(abs_input_number);\n  shifted_number_threshold = leading_zeros + 0x15;\n  carry_bit = SBORROW4(shifted_number_threshold,0x20);\n  shifted_number = leading_zeros - 0xb;\n  negative_shift = (int)shifted_number < 0;\n  zero_shift = shifted_number == 0;\n  if (shifted_number_threshold < 0x20) {\n    carry_bit = SCARRY4(shifted_number,0xc);\n    negative_shift = false;\n    zero_shift = leading_zeros + 1 == 0;\n    shifted_number = shifted_number_threshold;\n    if (!zero_shift && carry_bit == false) {\n      shift_amount = abs_input_number << shifted_number_threshold;\n      abs_input_number = abs_input_number >> (0xcU - (leading_zeros + 1) & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (zero_shift || negative_shift != carry_bit) {\n    remaining_bits = 0x20 - shifted_number;\n  }\n  abs_input_number = abs_input_number << (shifted_number & 0xff);\n  if (zero_shift || negative_shift != carry_bit) {\n    abs_input_number = abs_input_number | 0U >> (remaining_bits & 0xff);\n  }\n  if (zero_shift || negative_shift != carry_bit) {\n    shift_amount = 0 << (shifted_number & 0xff);\n  }\nLAB_080002f0:\n  if (shifted_number_threshold < 0x433) {\n    return CONCAT44(abs_input_number + (0x432 - shifted_number_threshold) * 0x100000 | sign_bit,shift_amount);\n  }\n  shifted_number = ~(0x432 - shifted_number_threshold);\n  if (0x1e < (int)shifted_number) {\n    return CONCAT44(input_number,abs_input_number >> (shifted_number - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leading_zeros = shifted_number - 0x13;\n  if (leading_zeros == 0 || leading_zeros < 0 != SCARRY4(shifted_number - 0x1f,0xc)) {\n    shifted_number = shifted_number + 1;\n    return CONCAT44(sign_bit | abs_input_number >> (shifted_number & 0xff),\n                    shift_amount >> (shifted_number & 0xff) | abs_input_number << (0x20 - shifted_number & 0xff));\n  }\n  return CONCAT44(input_number,shift_amount >> (0x20 - (0xcU - leading_zeros) & 0xff) | abs_input_number << (0xcU - leading_zeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000404": "calculate_shifted_value_08000404",
                "param_1": "input_number",
                "uVar1": "shift_amount",
                "uVar2": "abs_input_number",
                "uVar3": "shifted_number",
                "iVar4": "leading_zeros",
                "uVar5": "shifted_number_threshold",
                "uVar6": "sign_bit",
                "in_r12": "remaining_bits",
                "bVar7": "negative_shift",
                "bVar8": "zero_shift",
                "bVar9": "carry_bit"
            },
            "calling": [
                "__ieee754_pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000428": {
            "entrypoint": "0x08000428",
            "current_name": "reverse_bits_08000428",
            "code": "\nulonglong reverseBits_08000428(uint input,undefined4 unused1,undefined4 unused2,uint checkValue)\n\n{\n  uint bit31;\n  uint resultBits;\n  uint combinedBits;\n  uint shiftValue;\n  uint tempBits;\n  int numBits;\n  uint shiftedBits;\n  uint mask;\n  bool isLessThan;\n  bool isEqual;\n  bool isGreaterThanOrEqual;\n  \n  tempBits = input << 1;\n  isEqual = tempBits == 0;\n  bit31 = (uint)((input & 0x80000000) != 0) << 0x1f;\n  shiftValue = (uint)((int)tempBits >> 3) >> 1;\n  combinedBits = bit31 | shiftValue;\n  input = input << 0x1d;\n  if (!isEqual) {\n    checkValue = tempBits & 0xff000000;\n    isEqual = checkValue == 0;\n  }\n  if (!isEqual) {\n    isEqual = checkValue == 0xff000000;\n  }\n  if (!isEqual) {\n    return CONCAT44(combinedBits,input) ^ 0x3800000000000000;\n  }\n  if (tempBits == 0 || checkValue == 0xff000000) {\n    return CONCAT44(combinedBits,input);\n  }\n  resultBits = input;\n  tempBits = shiftValue;\n  if (shiftValue == 0) {\n    resultBits = 0;\n    tempBits = input;\n  }\n  numBits = LZCOUNT(tempBits);\n  if (shiftValue == 0) {\n    numBits = numBits + 0x20;\n  }\n  shiftedBits = numBits - 0xb;\n  isGreaterThanOrEqual = SBORROW4(shiftedBits,0x20);\n  shiftValue = numBits - 0x2b;\n  isEqual = (int)shiftValue < 0;\n  isLessThan = shiftValue == 0;\n  if ((int)shiftedBits < 0x20) {\n    isGreaterThanOrEqual = SCARRY4(shiftValue,0xc);\n    numBits = numBits + -0x1f;\n    isEqual = numBits < 0;\n    isLessThan = numBits == 0;\n    shiftValue = shiftedBits;\n    if (!isLessThan && isEqual == isGreaterThanOrEqual) {\n      resultBits = tempBits << (shiftedBits & 0xff);\n      tempBits = tempBits >> (0xcU - numBits & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (isLessThan || isEqual != isGreaterThanOrEqual) {\n    mask = 0x20 - shiftValue;\n  }\n  tempBits = tempBits << (shiftValue & 0xff);\n  if (isLessThan || isEqual != isGreaterThanOrEqual) {\n    tempBits = tempBits | resultBits >> (mask & 0xff);\n  }\n  if (isLessThan || isEqual != isGreaterThanOrEqual) {\n    resultBits = resultBits << (shiftValue & 0xff);\n  }\nLAB_080002f0:\n  if ((int)shiftedBits < 0x381) {\n    return CONCAT44(tempBits + (0x380 - shiftedBits) * 0x100000 | bit31,resultBits);\n  }\n  shiftValue = ~(0x380 - shiftedBits);\n  if ((int)shiftValue < 0x1f) {\n    numBits = shiftValue - 0x13;\n    if (numBits != 0 && numBits < 0 == SCARRY4(shiftValue - 0x1f,0xc)) {\n      return CONCAT44(combinedBits,resultBits >> (0x20 - (0xcU - numBits) & 0xff) | tempBits << (0xcU - numBits & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    shiftValue = shiftValue + 1;\n    return CONCAT44(bit31 | tempBits >> (shiftValue & 0xff),\n                    resultBits >> (shiftValue & 0xff) | tempBits << (0x20 - shiftValue & 0xff));\n  }\n  return CONCAT44(combinedBits,tempBits >> (shiftValue - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000428": "reverse_bits_08000428",
                "param_1": "input",
                "param_2": "unused1",
                "param_3": "unused2",
                "param_4": "checkValue",
                "uVar1": "bit31",
                "uVar2": "resultBits",
                "uVar3": "combinedBits",
                "uVar4": "shiftValue",
                "uVar5": "tempBits",
                "iVar6": "numBits",
                "uVar7": "shiftedBits",
                "in_r12": "mask",
                "bVar8": "isLessThan",
                "bVar9": "isEqual",
                "bVar10": "isGreaterThanOrEqual"
            },
            "calling": [
                "MadgwickQuaternionUpdate",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000464": {
            "entrypoint": "0x08000464",
            "current_name": "concatenate_and_shift_08000464",
            "code": "\nulonglong concatenateAndShift_08000464(uint input1,uint input2)\n\n{\n  byte byteVal;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int temp4;\n  uint temp5;\n  int temp6;\n  uint temp7;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  \n  if ((input1 | input2) == 0) {\n    return CONCAT44(input2,input1);\n  }\n  temp6 = 0x432;\n  temp7 = input2 >> 0x16;\n  if (temp7 != 0) {\n    temp6 = 3;\n    if (input2 >> 0x19 != 0) {\n      temp6 = 6;\n    }\n    if (input2 >> 0x1c != 0) {\n      temp6 = temp6 + 3;\n    }\n    temp3 = temp6 - ((int)input2 >> 0x1f);\n    temp7 = input1 << (0x20 - temp3 & 0xff);\n    input1 = input1 >> (temp3 & 0xff) | input2 << (0x20 - temp3 & 0xff);\n    input2 = input2 >> (temp3 & 0xff);\n    temp6 = temp3 + 0x432;\n  }\n  if (0xfffff < input2) {\n    if (0x1fffff < input2) {\n      temp3 = input2 & 1;\n      input2 = input2 >> 1;\n      byteVal = (byte)input1;\n      input1 = (uint)(temp3 != 0) << 0x1f | input1 >> 1;\n      temp7 = (uint)(byteVal & 1) << 0x1f | temp7 >> 1;\n      temp6 = temp6 + 1;\n      if (0xffbfffff < (uint)(temp6 * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_08000278:\n    flag2 = 0x7fffffff < temp7;\n    if (temp7 == 0x80000000) {\n      flag2 = (input1 & 1) != 0;\n    }\n    return CONCAT44(input2 + temp6 * 0x100000 + (uint)CARRY4(input1,(uint)flag2),input1 + flag2\n                   );\n  }\n  flag1 = (temp7 & 0x80000000) != 0;\n  temp7 = temp7 << 1;\n  temp3 = input1 * 2;\n  flag2 = CARRY4(input1,input1);\n  input1 = input1 * 2 + (uint)flag1;\n  input2 = input2 * 2 + (uint)(flag2 || CARRY4(temp3,(uint)flag1));\n  temp6 = temp6 + -1;\n  if ((input2 & 0x100000) != 0) goto LAB_08000278;\n  temp1 = input1;\n  temp3 = input2;\n  if (input2 == 0) {\n    temp1 = 0;\n    temp3 = input1;\n  }\n  temp4 = LZCOUNT(temp3);\n  if (input2 == 0) {\n    temp4 = temp4 + 0x20;\n  }\n  temp5 = temp4 - 0xb;\n  flag3 = SBORROW4(temp5,0x20);\n  temp2 = temp4 - 0x2b;\n  flag2 = (int)temp2 < 0;\n  flag1 = temp2 == 0;\n  if ((int)temp5 < 0x20) {\n    flag3 = SCARRY4(temp2,0xc);\n    temp4 = temp4 + -0x1f;\n    flag2 = temp4 < 0;\n    flag1 = temp4 == 0;\n    temp2 = temp5;\n    if (!flag1 && flag2 == flag3) {\n      temp1 = temp3 << (temp5 & 0xff);\n      temp3 = temp3 >> (0xcU - temp4 & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (flag1 || flag2 != flag3) {\n    temp7 = 0x20 - temp2;\n  }\n  temp3 = temp3 << (temp2 & 0xff);\n  if (flag1 || flag2 != flag3) {\n    temp3 = temp3 | temp1 >> (temp7 & 0xff);\n  }\n  if (flag1 || flag2 != flag3) {\n    temp1 = temp1 << (temp2 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)temp5 <= temp6) {\n    return CONCAT44(temp3 + (temp6 - temp5) * 0x100000,temp1);\n  }\n  temp7 = ~(temp6 - temp5);\n  if (0x1e < (int)temp7) {\n    return (ulonglong)(temp3 >> (temp7 - 0x1f & 0xff));\n  }\n  temp6 = temp7 - 0x13;\n  if (temp6 == 0 || temp6 < 0 != SCARRY4(temp7 - 0x1f,0xc)) {\n    temp7 = temp7 + 1;\n    return CONCAT44(temp3 >> (temp7 & 0xff),temp1 >> (temp7 & 0xff) | temp3 << (0x20 - temp7 & 0xff)\n                   );\n  }\n  return (ulonglong)(temp1 >> (0x20 - (0xcU - temp6) & 0xff) | temp3 << (0xcU - temp6 & 0xff));\n}\n\n",
            "renaming": {
                "FUN_08000464": "concatenate_and_shift_08000464",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "byteVal",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "iVar5": "temp4",
                "uVar6": "temp5",
                "iVar7": "temp6",
                "uVar8": "temp7",
                "bVar9": "flag1",
                "bVar10": "flag2",
                "bVar11": "flag3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000474": {
            "entrypoint": "0x08000474",
            "current_name": "divide_and_round_08000474",
            "code": "\nulonglong divide_and_round_08000474(uint dividend,uint divisor)\n\n{\n  byte lsb_dividend;\n  uint quotient;\n  uint shifted_dividend;\n  uint shifted_divisor;\n  int shift_amount;\n  uint partial_dividend;\n  int temp;\n  uint sign_bit;\n  uint partial_remainder;\n  bool carry_flag;\n  bool bit11_flag;\n  bool borrow_flag;\n  \n  if ((dividend | divisor) == 0) {\n    return CONCAT44(divisor,dividend);\n  }\n  sign_bit = divisor & 0x80000000;\n  shifted_dividend = divisor;\n  if ((int)sign_bit < 0) {\n    bit11_flag = dividend != 0;\n    dividend = -dividend;\n    shifted_dividend = -divisor - (uint)bit11_flag;\n  }\n  temp = 0x432;\n  partial_remainder = shifted_dividend >> 0x16;\n  if (partial_remainder != 0) {\n    temp = 3;\n    if (shifted_dividend >> 0x19 != 0) {\n      temp = 6;\n    }\n    if (shifted_dividend >> 0x1c != 0) {\n      temp = temp + 3;\n    }\n    shifted_divisor = temp - ((int)shifted_dividend >> 0x1f);\n    partial_remainder = dividend << (0x20 - shifted_divisor & 0xff);\n    dividend = dividend >> (shifted_divisor & 0xff) | shifted_dividend << (0x20 - shifted_divisor & 0xff);\n    shifted_dividend = shifted_dividend >> (shifted_divisor & 0xff);\n    temp = shifted_divisor + 0x432;\n  }\n  if (0xfffff < shifted_dividend) {\n    if (0x1fffff < shifted_dividend) {\n      shifted_divisor = shifted_dividend & 1;\n      shifted_dividend = shifted_dividend >> 1;\n      lsb_dividend = (byte)dividend;\n      dividend = (uint)(shifted_divisor != 0) << 0x1f | dividend >> 1;\n      partial_remainder = (uint)(lsb_dividend & 1) << 0x1f | partial_remainder >> 1;\n      temp = temp + 1;\n      if (0xffbfffff < (uint)(temp * 0x200000)) {\n        return (ulonglong)(sign_bit | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_08000278:\n    bit11_flag = 0x7fffffff < partial_remainder;\n    if (partial_remainder == 0x80000000) {\n      bit11_flag = (dividend & 1) != 0;\n    }\n    return CONCAT44(shifted_dividend + temp * 0x100000 + (uint)CARRY4(dividend,(uint)bit11_flag) | sign_bit,\n                    dividend + bit11_flag);\n  }\n  carry_flag = (partial_remainder & 0x80000000) != 0;\n  partial_remainder = partial_remainder << 1;\n  shifted_divisor = dividend * 2;\n  bit11_flag = CARRY4(dividend,dividend);\n  dividend = dividend * 2 + (uint)carry_flag;\n  shifted_dividend = shifted_dividend * 2 + (uint)(bit11_flag || CARRY4(shifted_divisor,(uint)carry_flag));\n  temp = temp + -1;\n  if ((shifted_dividend & 0x100000) != 0) goto LAB_08000278;\n  quotient = dividend;\n  shifted_divisor = shifted_dividend;\n  if (shifted_dividend == 0) {\n    quotient = 0;\n    shifted_divisor = dividend;\n  }\n  shift_amount = LZCOUNT(shifted_divisor);\n  if (shifted_dividend == 0) {\n    shift_amount = shift_amount + 0x20;\n  }\n  partial_dividend = shift_amount - 0xb;\n  borrow_flag = SBORROW4(partial_dividend,0x20);\n  shifted_dividend = shift_amount - 0x2b;\n  bit11_flag = (int)shifted_dividend < 0;\n  carry_flag = shifted_dividend == 0;\n  if ((int)partial_dividend < 0x20) {\n    borrow_flag = SCARRY4(shifted_dividend,0xc);\n    shift_amount = shift_amount + -0x1f;\n    bit11_flag = shift_amount < 0;\n    carry_flag = shift_amount == 0;\n    shifted_dividend = partial_dividend;\n    if (!carry_flag && bit11_flag == borrow_flag) {\n      quotient = shifted_divisor << (partial_dividend & 0xff);\n      shifted_divisor = shifted_divisor >> (0xcU - shift_amount & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (carry_flag || bit11_flag != borrow_flag) {\n    partial_remainder = 0x20 - shifted_dividend;\n  }\n  shifted_divisor = shifted_divisor << (shifted_dividend & 0xff);\n  if (carry_flag || bit11_flag != borrow_flag) {\n    shifted_divisor = shifted_divisor | quotient >> (partial_remainder & 0xff);\n  }\n  if (carry_flag || bit11_flag != borrow_flag) {\n    quotient = quotient << (shifted_dividend & 0xff);\n  }\nLAB_080002f0:\n  if ((int)partial_dividend <= temp) {\n    return CONCAT44(shifted_divisor + (temp - partial_dividend) * 0x100000 | sign_bit,quotient);\n  }\n  shifted_dividend = ~(temp - partial_dividend);\n  if (0x1e < (int)shifted_dividend) {\n    return CONCAT44(divisor,shifted_divisor >> (shifted_dividend - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  temp = shifted_dividend - 0x13;\n  if (temp == 0 || temp < 0 != SCARRY4(shifted_dividend - 0x1f,0xc)) {\n    shifted_dividend = shifted_dividend + 1;\n    return CONCAT44(sign_bit | shifted_divisor >> (shifted_dividend & 0xff),\n                    quotient >> (shifted_dividend & 0xff) | shifted_divisor << (0x20 - shifted_dividend & 0xff));\n  }\n  return CONCAT44(divisor,quotient >> (0x20 - (0xcU - temp) & 0xff) | shifted_divisor << (0xcU - temp & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000474": "divide_and_round_08000474",
                "param_1": "dividend",
                "param_2": "divisor",
                "bVar1": "lsb_dividend",
                "uVar2": "quotient",
                "uVar3": "shifted_dividend",
                "uVar4": "shifted_divisor",
                "iVar5": "shift_amount",
                "uVar6": "partial_dividend",
                "iVar7": "temp",
                "uVar8": "sign_bit",
                "uVar9": "partial_remainder",
                "bVar10": "carry_flag",
                "bVar11": "bit11_flag",
                "bVar12": "borrow_flag"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004d0": {
            "entrypoint": "0x080004d0",
            "current_name": "calculate_updated_result_080004d0",
            "code": "\nulonglong calculate_updated_result_080004d0(undefined4 input_param_1,uint input_param_2,uint input_param_3,uint input_param_4)\n\n{\n  ulonglong temp_var_1;\n  longlong temp_var_2;\n  uint temp_var_3;\n  uint temp_var_4;\n  int temp_var_5;\n  uint temp_var_6;\n  uint temp_var_7;\n  uint temp_var_8;\n  uint temp_var_9;\n  bool temp_var_10;\n  bool temp_var_11;\n  bool temp_var_12;\n  ulonglong temp_var_13;\n  \n  temp_var_13 = CONCAT44(input_param_2,input_param_1);\n  temp_var_8 = 0x7ff;\n  temp_var_4 = input_param_2 >> 0x14 & 0x7ff;\n  temp_var_10 = temp_var_4 == 0;\n  if (!temp_var_10) {\n    temp_var_7 = input_param_4 >> 0x14 & 0x7ff;\n    temp_var_10 = temp_var_7 == 0;\n  }\n  if (!temp_var_10) {\n    temp_var_10 = temp_var_4 == 0x7ff;\n  }\n  if (!temp_var_10) {\n    temp_var_10 = temp_var_7 == 0x7ff;\n  }\n  if (temp_var_10) {\n    temp_var_13 = calculate_result_080006ac();\n  }\n  temp_var_3 = (uint)(temp_var_13 >> 0x20);\n  temp_var_5 = temp_var_4 + temp_var_7;\n  temp_var_4 = temp_var_3 ^ input_param_4;\n  temp_var_3 = temp_var_3 & ~(temp_var_8 << 0x15);\n  input_param_4 = input_param_4 & ~(temp_var_8 << 0x15);\n  temp_var_10 = ((uint)temp_var_13 | temp_var_3 << 0xc) == 0;\n  if (!temp_var_10) {\n    temp_var_10 = (input_param_3 | input_param_4 << 0xc) == 0;\n  }\n  temp_var_3 = temp_var_3 | 0x100000;\n  input_param_4 = input_param_4 | 0x100000;\n  if (temp_var_10) {\n    input_param_3 = (uint)temp_var_13 | input_param_3;\n    input_param_4 = (temp_var_4 & 0x80000000 | temp_var_3) ^ input_param_4;\n    temp_var_4 = temp_var_8 >> 1;\n    temp_var_12 = SBORROW4(temp_var_5,temp_var_4);\n    temp_var_6 = temp_var_5 - temp_var_4;\n    temp_var_10 = temp_var_6 == 0;\n    temp_var_3 = temp_var_6;\n    if (!temp_var_10 && (int)temp_var_4 <= temp_var_5) {\n      temp_var_12 = SBORROW4(temp_var_8,temp_var_6);\n      temp_var_3 = temp_var_8 - temp_var_6;\n      temp_var_10 = temp_var_8 == temp_var_6;\n    }\n    if (!temp_var_10 && (int)temp_var_3 < 0 == temp_var_12) {\n      input_param_4 = input_param_4 | temp_var_6 * 0x100000;\n    }\n    if (!temp_var_10 && (int)temp_var_3 < 0 == temp_var_12) {\n      return CONCAT44(input_param_4,input_param_3);\n    }\n    input_param_4 = input_param_4 | 0x100000;\n    temp_var_8 = 0;\n    temp_var_12 = SBORROW4(temp_var_6,1);\n    temp_var_6 = temp_var_6 - 1;\n    temp_var_10 = temp_var_6 == 0;\n    temp_var_4 = temp_var_6;\n  }\n  else {\n    temp_var_1 = (temp_var_13 & 0xffffffff) * (ulonglong)input_param_3;\n    temp_var_13 = (temp_var_13 & 0xffffffff) * (ulonglong)input_param_4 +\n             (ulonglong)temp_var_3 * (ulonglong)input_param_3 + (temp_var_1 >> 0x20);\n    temp_var_9 = (uint)temp_var_13;\n    temp_var_2 = (ulonglong)temp_var_3 * (ulonglong)input_param_4 + (temp_var_13 >> 0x20);\n    temp_var_8 = (uint)temp_var_2;\n    temp_var_3 = (uint)((ulonglong)temp_var_2 >> 0x20);\n    if ((int)temp_var_1 != 0) {\n      temp_var_9 = temp_var_9 | 1;\n    }\n    temp_var_6 = (temp_var_5 + -0x3ff) - (uint)(temp_var_3 < 0x200);\n    if (temp_var_3 < 0x200) {\n      temp_var_10 = (temp_var_9 & 0x80000000) != 0;\n      temp_var_9 = temp_var_9 << 1;\n      temp_var_2 = CONCAT44(temp_var_3 * 2 + (uint)(CARRY4(temp_var_8,temp_var_8) || CARRY4(temp_var_8 * 2,(uint)temp_var_10)),\n                       temp_var_8 * 2 + (uint)temp_var_10);\n    }\n    input_param_4 = temp_var_4 & 0x80000000 | (int)((ulonglong)temp_var_2 >> 0x20) << 0xb | (uint)temp_var_2 >> 0x15;\n    input_param_3 = (uint)temp_var_2 << 0xb | temp_var_9 >> 0x15;\n    temp_var_8 = temp_var_9 * 0x800;\n    temp_var_11 = 0xfc < temp_var_6;\n    temp_var_12 = SBORROW4(temp_var_6,0xfd);\n    temp_var_3 = temp_var_6 - 0xfd;\n    temp_var_10 = temp_var_3 == 0;\n    temp_var_4 = temp_var_3;\n    if (temp_var_11 && !temp_var_10) {\n      temp_var_11 = 0x6ff < temp_var_3;\n      temp_var_12 = SBORROW4(temp_var_3,0x700);\n      temp_var_4 = temp_var_6 - 0x7fd;\n      temp_var_10 = temp_var_3 == 0x700;\n    }\n    if (!temp_var_11 || temp_var_10) {\n      temp_var_10 = 0x7fffffff < temp_var_8;\n      if (temp_var_8 == 0x80000000) {\n        temp_var_10 = (temp_var_9 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(input_param_4 + temp_var_6 * 0x100000 + (uint)CARRY4(input_param_3,(uint)temp_var_10),input_param_3 + temp_var_10\n                     );\n    }\n  }\n  if (!temp_var_10 && (int)temp_var_4 < 0 == temp_var_12) {\n    return (ulonglong)(input_param_4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  temp_var_11 = SCARRY4(temp_var_6,0x36);\n  temp_var_10 = (int)(temp_var_6 + 0x36) < 0;\n  temp_var_12 = temp_var_6 == 0xffffffca;\n  if (temp_var_12 || temp_var_10 != temp_var_11) {\n    input_param_3 = 0;\n  }\n  if (temp_var_12 || temp_var_10 != temp_var_11) {\n    input_param_4 = input_param_4 & 0x80000000;\n  }\n  if (temp_var_12 || temp_var_10 != temp_var_11) {\n    return CONCAT44(input_param_4,input_param_3);\n  }\n  temp_var_4 = -temp_var_6;\n  temp_var_3 = temp_var_4 - 0x20;\n  if (0x1f < (int)temp_var_4) {\n    temp_var_6 = input_param_3 >> (temp_var_3 & 0xff) | input_param_4 << (0x20 - temp_var_3 & 0xff);\n    temp_var_4 = (input_param_4 >> (temp_var_3 & 0xff) & ~((input_param_4 & 0x80000000) >> (temp_var_3 & 0xff))) -\n            ((int)temp_var_6 >> 0x1f);\n    if ((temp_var_8 | input_param_3 << (0x20 - temp_var_3 & 0xff) | temp_var_6 << 1) == 0) {\n      temp_var_4 = temp_var_4 & ~(temp_var_6 >> 0x1f);\n    }\n    return CONCAT44(input_param_4,temp_var_4) & 0x80000000ffffffff;\n  }\n  temp_var_5 = temp_var_4 - 0x14;\n  if (temp_var_5 == 0 || temp_var_5 < 0 != SCARRY4(temp_var_3,0xc)) {\n    temp_var_9 = input_param_3 << (temp_var_6 + 0x20 & 0xff);\n    temp_var_3 = input_param_3 >> (temp_var_4 & 0xff) | input_param_4 << (temp_var_6 + 0x20 & 0xff);\n    temp_var_6 = temp_var_3 + -((int)temp_var_9 >> 0x1f);\n    if ((temp_var_8 | temp_var_9 << 1) == 0) {\n      temp_var_6 = temp_var_6 & ~(temp_var_9 >> 0x1f);\n    }\n    return CONCAT44((input_param_4 & 0x80000000) +\n                    ((input_param_4 & 0x7fffffff) >> (temp_var_4 & 0xff)) +\n                    (uint)CARRY4(temp_var_3,-((int)temp_var_9 >> 0x1f)),temp_var_6);\n  }\n  temp_var_4 = 0xc - temp_var_5;\n  temp_var_6 = input_param_3 << (temp_var_4 & 0xff);\n  temp_var_4 = input_param_3 >> (0x20 - temp_var_4 & 0xff) | input_param_4 << (temp_var_4 & 0xff);\n  temp_var_3 = temp_var_4 + -((int)temp_var_6 >> 0x1f);\n  if ((temp_var_8 | temp_var_6 << 1) == 0) {\n    temp_var_3 = temp_var_3 & ~(temp_var_6 >> 0x1f);\n  }\n  return CONCAT44((input_param_4 & 0x80000000) + (uint)CARRY4(temp_var_4,-((int)temp_var_6 >> 0x1f)),temp_var_3);\n}\n\n",
            "renaming": {
                "FUN_080004d0": "calculate_updated_result_080004d0",
                "param_1": "input_param_1",
                "param_2": "input_param_2",
                "param_3": "input_param_3",
                "param_4": "input_param_4",
                "uVar1": "temp_var_1",
                "lVar2": "temp_var_2",
                "uVar3": "temp_var_3",
                "uVar4": "temp_var_4",
                "iVar5": "temp_var_5",
                "uVar6": "temp_var_6",
                "unaff_r5": "temp_var_7",
                "uVar7": "temp_var_8",
                "uVar8": "temp_var_9",
                "bVar9": "temp_var_10",
                "bVar10": "temp_var_11",
                "bVar11": "temp_var_12",
                "uVar12": "temp_var_13"
            },
            "calling": [
                "pow",
                "scalbn",
                "atan",
                "__ieee754_sqrt",
                "MadgwickQuaternionUpdate",
                "__ieee754_asin",
                "MS5611_Update",
                "__ieee754_pow"
            ],
            "called": [
                "FUN_080006ac"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006ac": {
            "entrypoint": "0x080006ac",
            "current_name": "calculate_result_080006ac",
            "code": "\nulonglong calculate_result_080006ac(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  bool condition;\n  \n  temp3 = temp5 & input4 >> 0x14;\n  if (temp2 != temp5 && temp3 != temp5) {\n    condition = (input1 | input2 << 1) == 0;\n    if (!condition) {\n      condition = (input3 | input4 << 1) == 0;\n    }\n    if (condition) {\n      return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n    }\n    if (temp2 == 0) {\n      temp4 = input2 & 0x80000000;\n      do {\n        temp1 = input1 & 0x80000000;\n        input1 = input1 << 1;\n        input2 = input2 * 2 + (uint)(temp1 != 0);\n      } while ((input2 & 0x100000) == 0);\n      input2 = input2 | temp4;\n      if (temp3 != 0) {\n        return CONCAT44(input2,input1);\n      }\n    }\n    do {\n      temp3 = input3 & 0x80000000;\n      input3 = input3 << 1;\n      input4 = input4 * 2 + (uint)(temp3 != 0);\n    } while ((input4 & 0x100000) == 0);\n    return CONCAT44(input2,input1);\n  }\n  condition = (input1 | input2 << 1) == 0;\n  if (condition) {\n    input2 = input4;\n    input1 = input3;\n  }\n  if (!condition) {\n    condition = (input3 | input4 << 1) == 0;\n  }\n  temp4 = input2;\n  if (((!condition) && ((temp2 != temp5 || ((input1 | input2 << 0xc) == 0)))) &&\n     ((temp3 != temp5 || (input1 = input3, temp4 = input4, (input3 | input4 << 0xc) == 0)))) {\n    return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(temp4,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006ac": "calculate_result_080006ac",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "temp1",
                "unaff_r4": "temp2",
                "uVar2": "temp3",
                "uVar3": "temp4",
                "in_r12": "temp5",
                "bVar4": "condition"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000724": {
            "entrypoint": "0x08000724",
            "current_name": "calculate_floating_point_08000724",
            "code": "\nulonglong calculateFloatingPoint_08000724(undefined4 value1,uint value2,uint value3,uint value4)\n\n{\n  uint upperBits;\n  uint lowerBits;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  int difference;\n  uint adjustedUpperBits;\n  uint unaff_r5;\n  uint adjustedLowerBits;\n  uint resultUpper1;\n  uint resultUpper2;\n  uint zero;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  undefined8 result;\n  \n  result = CONCAT44(value2,value1);\n  zero = 0x7ff;\n  temp5 = value2 >> 0x14 & 0x7ff;\n  condition1 = temp5 == 0;\n  if (!condition1) {\n    unaff_r5 = value4 >> 0x14 & 0x7ff;\n    condition1 = unaff_r5 == 0;\n  }\n  if (!condition1) {\n    condition1 = temp5 == 0x7ff;\n  }\n  if (!condition1) {\n    condition1 = unaff_r5 == 0x7ff;\n  }\n  if (condition1) {\n    result = extract_bits_08000892();\n  }\n  adjustedUpperBits = (uint)((ulonglong)result >> 0x20);\n  resultUpper1 = (uint)result;\n  difference = temp5 - unaff_r5;\n  if ((value3 | value4 << 0xc) == 0) {\n    temp5 = (adjustedUpperBits ^ value4) & 0x80000000 | adjustedUpperBits & 0xfffff;\n    condition3 = SCARRY4(difference,zero >> 1);\n    adjustedUpperBits = difference + (zero >> 1);\n    condition1 = (int)adjustedUpperBits < 0;\n    condition2 = adjustedUpperBits == 0;\n    if (!condition2 && condition1 == condition3) {\n      condition3 = SBORROW4(zero,adjustedUpperBits);\n      condition1 = (int)(zero - adjustedUpperBits) < 0;\n      condition2 = zero == adjustedUpperBits;\n    }\n    if (!condition2 && condition1 == condition3) {\n      temp5 = temp5 | adjustedUpperBits * 0x100000;\n    }\n    if (!condition2 && condition1 == condition3) {\n      return CONCAT44(temp5,resultUpper1);\n    }\n    temp5 = temp5 | 0x100000;\n    zero = 0;\n    condition2 = SBORROW4(adjustedUpperBits,1);\n    adjustedUpperBits = adjustedUpperBits - 1;\n    condition1 = adjustedUpperBits == 0;\n    temp1 = adjustedUpperBits;\n  }\n  else {\n    temp1 = (value4 << 0xc) >> 4 | 0x10000000 | value3 >> 0x18;\n    zero = value3 << 8;\n    adjustedLowerBits = (adjustedUpperBits << 0xc) >> 4 | 0x10000000 | resultUpper1 >> 0x18;\n    resultUpper1 = resultUpper1 * 0x100;\n    temp5 = (adjustedUpperBits ^ value4) & 0x80000000;\n    condition1 = temp1 <= adjustedLowerBits;\n    if (adjustedLowerBits == temp1) {\n      condition1 = zero <= resultUpper1;\n    }\n    difference = difference + (uint)condition1;\n    adjustedUpperBits = difference + 0x3fd;\n    if (condition1 == false) {\n      temp1 = temp1 >> 1;\n      zero = (uint)((value3 >> 0x18 & 1) != 0) << 0x1f | zero >> 1;\n    }\n    resultUpper2 = resultUpper1 - zero;\n    adjustedLowerBits = (adjustedLowerBits - temp1) - (uint)(resultUpper1 < zero);\n    temp2 = temp1 >> 1;\n    upperBits = (uint)((temp1 & 1) != 0) << 0x1f | zero >> 1;\n    resultUpper1 = 0x100000;\n    temp1 = 0x80000;\n    while( true ) {\n      condition1 = upperBits <= resultUpper2;\n      if (temp2 < adjustedLowerBits || adjustedLowerBits - temp2 < (uint)condition1) {\n        resultUpper2 = resultUpper2 - upperBits;\n        resultUpper1 = resultUpper1 | temp1;\n        adjustedLowerBits = (adjustedLowerBits - temp2) - (uint)!condition1;\n      }\n      temp3 = temp2 >> 1;\n      upperBits = (uint)((temp2 & 1) != 0) << 0x1f | upperBits >> 1;\n      condition2 = upperBits <= resultUpper2;\n      condition1 = adjustedLowerBits - temp3 < (uint)condition2;\n      zero = adjustedLowerBits;\n      if (temp3 < adjustedLowerBits || condition1) {\n        resultUpper2 = resultUpper2 - upperBits;\n        zero = (adjustedLowerBits - temp3) - (uint)!condition2;\n      }\n      if (temp3 < adjustedLowerBits || condition1) {\n        resultUpper1 = resultUpper1 | temp1 >> 1;\n      }\n      adjustedLowerBits = temp2 >> 2;\n      lowerBits = (uint)((temp3 & 1) != 0) << 0x1f | upperBits >> 1;\n      condition2 = lowerBits <= resultUpper2;\n      condition1 = zero - adjustedLowerBits < (uint)condition2;\n      temp3 = zero;\n      if (adjustedLowerBits < zero || condition1) {\n        resultUpper2 = resultUpper2 - lowerBits;\n        temp3 = (zero - adjustedLowerBits) - (uint)!condition2;\n      }\n      if (adjustedLowerBits < zero || condition1) {\n        resultUpper1 = resultUpper1 | temp1 >> 2;\n      }\n      temp4 = temp2 >> 3;\n      upperBits = (uint)((adjustedLowerBits & 1) != 0) << 0x1f | lowerBits >> 1;\n      condition2 = upperBits <= resultUpper2;\n      condition1 = temp3 - temp4 < (uint)condition2;\n      adjustedLowerBits = temp3;\n      if (temp4 < temp3 || condition1) {\n        resultUpper2 = resultUpper2 - upperBits;\n        adjustedLowerBits = (temp3 - temp4) - (uint)!condition2;\n      }\n      if (temp4 < temp3 || condition1) {\n        resultUpper1 = resultUpper1 | temp1 >> 3;\n      }\n      zero = adjustedLowerBits | resultUpper2;\n      if (zero == 0) break;\n      adjustedLowerBits = adjustedLowerBits << 4 | resultUpper2 >> 0x1c;\n      resultUpper2 = resultUpper2 << 4;\n      temp2 = temp2 & 0xfffffff8 | upperBits >> 0x1d;\n      upperBits = (lowerBits >> 1) << 3;\n      temp1 = temp1 >> 4;\n      if (temp1 == 0) {\n        temp4 = temp2;\n        if ((temp5 & 0x100000) != 0) goto LAB_08000842;\n        temp5 = temp5 | resultUpper1;\n        resultUpper1 = 0;\n        temp1 = 0x80000000;\n      }\n    }\n    if ((temp5 & 0x100000) == 0) {\n      temp5 = temp5 | resultUpper1;\n      resultUpper1 = 0;\n    }\nLAB_08000842:\n    condition3 = 0xfc < adjustedUpperBits;\n    condition2 = SBORROW4(adjustedUpperBits,0xfd);\n    temp2 = difference + 0x300;\n    condition1 = temp2 == 0;\n    temp1 = temp2;\n    if (condition3 && !condition1) {\n      condition3 = 0x6ff < temp2;\n      condition2 = SBORROW4(temp2,0x700);\n      temp1 = difference - 0x400;\n      condition1 = temp2 == 0x700;\n    }\n    if (!condition3 || condition1) {\n      condition1 = temp4 <= adjustedLowerBits;\n      if (adjustedLowerBits == temp4) {\n        condition1 = upperBits <= resultUpper2;\n      }\n      if (adjustedLowerBits == temp4 && resultUpper2 == upperBits) {\n        condition1 = (resultUpper1 & 1) != 0;\n      }\n      return CONCAT44(temp5 + adjustedUpperBits * 0x100000 + (uint)CARRY4(resultUpper1,(uint)condition1),resultUpper1 + condition1);\n    }\n  }\n  if (!condition1 && (int)temp1 < 0 == condition2) {\n    return (ulonglong)(temp5 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  condition3 = SCARRY4(adjustedUpperBits,0x36);\n  condition1 = (int)(adjustedUpperBits + 0x36) < 0;\n  condition2 = adjustedUpperBits == 0xffffffca;\n  if (condition2 || condition1 != condition3) {\n    resultUpper1 = 0;\n  }\n  if (condition2 || condition1 != condition3) {\n    temp5 = temp5 & 0x80000000;\n  }\n  if (condition2 || condition1 != condition3) {\n    return CONCAT44(temp5,resultUpper1);\n  }\n  temp1 = -adjustedUpperBits;\n  adjustedLowerBits = temp1 - 0x20;\n  if (0x1f < (int)temp1) {\n    temp1 = resultUpper1 >> (adjustedLowerBits & 0xff) | temp5 << (0x20 - adjustedLowerBits & 0xff);\n    adjustedUpperBits = (temp5 >> (adjustedLowerBits & 0xff) & ~((temp5 & 0x80000000) >> (adjustedLowerBits & 0xff))) -\n            ((int)temp1 >> 0x1f);\n    if ((zero | resultUpper1 << (0x20 - adjustedLowerBits & 0xff) | temp1 << 1) == 0) {\n      adjustedUpperBits = adjustedUpperBits & ~(temp1 >> 0x1f);\n    }\n    return CONCAT44(temp5,adjustedUpperBits) & 0x80000000ffffffff;\n  }\n  difference = temp1 - 0x14;\n  if (difference != 0 && difference < 0 == SCARRY4(adjustedLowerBits,0xc)) {\n    adjustedUpperBits = 0xc - difference;\n    temp1 = resultUpper1 << (adjustedUpperBits & 0xff);\n    resultUpper1 = resultUpper1 >> (0x20 - adjustedUpperBits & 0xff) | temp5 << (adjustedUpperBits & 0xff);\n    adjustedUpperBits = resultUpper1 + -((int)temp1 >> 0x1f);\n    if ((zero | temp1 << 1) == 0) {\n      adjustedUpperBits = adjustedUpperBits & ~(temp1 >> 0x1f);\n    }\n    return CONCAT44((temp5 & 0x80000000) + (uint)CARRY4(resultUpper1,-((int)temp1 >> 0x1f)),adjustedUpperBits);\n  }\n  adjustedLowerBits = resultUpper1 << (adjustedUpperBits + 0x20 & 0xff);\n  resultUpper1 = resultUpper1 >> (temp1 & 0xff) | temp5 << (adjustedUpperBits + 0x20 & 0xff);\n  adjustedUpperBits = resultUpper1 + -((int)adjustedLowerBits >> 0x1f);\n  if ((zero | adjustedLowerBits << 1) == 0) {\n    adjustedUpperBits = adjustedUpperBits & ~(adjustedLowerBits >> 0x1f);\n  }\n  return CONCAT44((temp5 & 0x80000000) +\n                  ((temp5 & 0x7fffffff) >> (temp1 & 0xff)) +\n                  (uint)CARRY4(resultUpper1,-((int)adjustedLowerBits >> 0x1f)),adjustedUpperBits);\n}\n\n",
            "renaming": {
                "FUN_08000724": "calculate_floating_point_08000724",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "upperBits",
                "uVar2": "lowerBits",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "uVar6": "temp4",
                "uVar7": "temp5",
                "iVar8": "difference",
                "uVar9": "adjustedUpperBits",
                "uVar10": "adjustedLowerBits",
                "uVar11": "resultUpper1",
                "uVar12": "resultUpper2",
                "uVar13": "zero",
                "bVar14": "condition1",
                "bVar15": "condition2",
                "bVar16": "condition3",
                "uVar17": "result"
            },
            "calling": [
                "pow",
                "__ieee754_atan2",
                "atan",
                "__ieee754_sqrt",
                "MadgwickQuaternionUpdate",
                "__ieee754_asin",
                "sqrt",
                "__ieee754_pow"
            ],
            "called": [
                "FUN_08000892"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000892": {
            "entrypoint": "0x08000892",
            "current_name": "extract_bits_08000892",
            "code": "\nulonglong extract_bits_08000892(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint bit1;\n  uint bit2;\n  uint extracted_bits1;\n  uint extracted_bits2;\n  uint mask;\n  bool are_zero_bits;\n  \n  extracted_bits1 = mask & input4 >> 0x14;\n  extracted_bits2 = input2;\n  if (bit2 != mask || extracted_bits1 != mask) {\n    if (bit2 == mask) {\n      if (((input1 | input2 << 0xc) == 0) && (input1 = input3, extracted_bits2 = input4, extracted_bits1 != mask)\n         ) {\nreturn_case1:\n        return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (extracted_bits1 == mask) {\n      input1 = input3;\n      extracted_bits2 = input4;\n      if ((input3 | input4 << 0xc) == 0) {\nreturn_case2:\n        return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      are_zero_bits = (input1 | input2 << 1) == 0;\n      if (!are_zero_bits) {\n        are_zero_bits = (input3 | input4 << 1) == 0;\n      }\n      if (!are_zero_bits) {\n        if (bit2 == 0) {\n          extracted_bits2 = input2 & 0x80000000;\n          do {\n            bit1 = input1 & 0x80000000;\n            input1 = input1 << 1;\n            input2 = input2 * 2 + (uint)(bit1 != 0);\n          } while ((input2 & 0x100000) == 0);\n          input2 = input2 | extracted_bits2;\n          if (extracted_bits1 != 0) {\n            return CONCAT44(input2,input1);\n          }\n        }\n        do {\n          extracted_bits2 = input3 & 0x80000000;\n          input3 = input3 << 1;\n          input4 = input4 * 2 + (uint)(extracted_bits2 != 0);\n        } while ((input4 & 0x100000) == 0);\n        return CONCAT44(input2,input1);\n      }\n      if ((input1 | input2 << 1) != 0) goto return_case1;\n      if ((input3 | input4 << 1) != 0) goto return_case2;\n    }\n  }\n  return CONCAT44(extracted_bits2,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_08000892": "extract_bits_08000892",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "bit1",
                "unaff_r4": "bit2",
                "uVar2": "extracted_bits1",
                "uVar3": "extracted_bits2",
                "in_r12": "mask",
                "bVar4": "are_zero_bits",
                "LAB_08000704": "return_case1",
                "LAB_080006c8": "return_case2"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008f4": {
            "entrypoint": "0x080008f4",
            "current_name": "check_parameters_080008f4",
            "code": "\nuint check_parameters_080008f4(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint result;\n  bool isZero1;\n  bool isZero2;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  isZero1 = (value1 | value2 << 1) == 0;\n  if (isZero1) {\n    isZero1 = (value3 | value4 << 1) == 0;\n  }\n  if (!isZero1) {\n    isZero1 = value2 == value4;\n  }\n  if (isZero1) {\n    isZero1 = value1 == value3;\n  }\n  if (!isZero1) {\n    result = value2 ^ value4;\n    isZero1 = result == 0;\n    if (-1 < (int)result) {\n      isZero1 = value2 == value4;\n    }\n    isZero2 = -1 < (int)result && value4 <= value2;\n    if (isZero1) {\n      isZero2 = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!isZero2) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008f4": "check_parameters_080008f4",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result",
                "bVar2": "isZero1",
                "bVar3": "isZero2"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008fc": {
            "entrypoint": "0x080008fc",
            "current_name": "compare_params_080008fc",
            "code": "\nuint compare_params_080008fc(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint result;\n  bool isZero;\n  bool isPositive;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (value1 | value2 << 1) == 0;\n  if (isZero) {\n    isZero = (value3 | value4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = value2 == value4;\n  }\n  if (isZero) {\n    isZero = value1 == value3;\n  }\n  if (!isZero) {\n    result = value2 ^ value4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = value2 == value4;\n    }\n    isPositive = -1 < (int)result && value4 <= value2;\n    if (isZero) {\n      isPositive = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!isPositive) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008fc": "compare_params_080008fc",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isPositive"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000904": {
            "entrypoint": "0x08000904",
            "current_name": "check_equality_08000904",
            "code": "\nuint checkEquality_08000904(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint result;\n  bool isZero;\n  bool isNegative;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (value1 | value2 << 1) == 0;\n  if (isZero) {\n    isZero = (value3 | value4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = value2 == value4;\n  }\n  if (isZero) {\n    isZero = value1 == value3;\n  }\n  if (!isZero) {\n    result = value2 ^ value4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = value2 == value4;\n    }\n    isNegative = -1 < (int)result && value4 <= value2;\n    if (isZero) {\n      isNegative = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!isNegative) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08000904": "check_equality_08000904",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isNegative"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000980": {
            "entrypoint": "0x08000980",
            "current_name": "compare_floating_point_numbers_08000980",
            "code": "\nvoid compareFloatingPointNumbers_08000980(undefined4 comparisonResult,undefined4 param2,undefined4 float1,undefined4 float2)\n\n{\n  __aeabi_cdcmpeq(float1,float2,comparisonResult,param2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000980": "compare_floating_point_numbers_08000980",
                "param_1": "comparisonResult",
                "param_2": "param2",
                "param_3": "float1",
                "param_4": "float2"
            },
            "calling": [
                "__aeabi_dcmpge",
                "__aeabi_dcmpgt"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000990": {
            "entrypoint": "0x08000990",
            "current_name": "convert_to_float_08000990",
            "code": "\nundefined4 convertToFloat_08000990(undefined4 inputValue)\n\n{\n  __nedf2();\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_08000990": "convert_to_float_08000990",
                "param_1": "inputValue"
            },
            "calling": [
                "__aeabi_dcmpeq",
                "__aeabi_cdrcmple",
                "__aeabi_dcmplt",
                "__aeabi_dcmple"
            ],
            "called": [
                "__nedf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009a0": {
            "entrypoint": "0x080009a0",
            "current_name": "is_zero_080009a0",
            "code": "\nbool is_zero_080009a0(void)\n\n{\n  char flag;\n  \n  __aeabi_cdcmpeq();\n  return flag != '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009a0": "is_zero_080009a0",
                "in_ZR": "flag"
            },
            "calling": [
                "pow"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009b4": {
            "entrypoint": "0x080009b4",
            "current_name": "is_character_zero_080009b4",
            "code": "\nbool is_character_zero_080009b4(void)\n\n{\n  char character;\n  \n  compare_characters();\n  return character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009b4": "is_character_zero_080009b4",
                "in_CY": "character",
                "__aeabi_cdcmpeq": "compare_characters"
            },
            "calling": [
                "pow",
                "sqrt"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c8": {
            "entrypoint": "0x080009c8",
            "current_name": "is_zero_or_equal_080009c8",
            "code": "\nbool is_zero_or_equal_080009c8(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_result;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)is_carry_result || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_080009c8": "is_zero_or_equal_080009c8",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_result"
            },
            "calling": [
                "__ieee754_pow"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009dc": {
            "entrypoint": "0x080009dc",
            "current_name": "check_zr_cy_080009dc",
            "code": "\nbool check_ZR_CY_080009dc(void)\n\n{\n  undefined is_zero;\n  undefined is_carry;\n  \n  __aeabi_cdrcmple();\n  return !(bool)is_carry || (bool)is_zero;\n}\n\n",
            "renaming": {
                "FUN_080009dc": "check_zr_cy_080009dc",
                "in_ZR": "is_zero",
                "in_CY": "is_carry"
            },
            "calling": [],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009f0": {
            "entrypoint": "0x080009f0",
            "current_name": "check_null_termination_080009f0",
            "code": "\nbool checkNullTermination_080009f0(void)\n\n{\n  char inputChar;\n  \n  __aeabi_cdrcmple();\n  return inputChar == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009f0": "check_null_termination_080009f0",
                "in_CY": "inputChar"
            },
            "calling": [
                "atan",
                "__ieee754_asin",
                "__ieee754_pow",
                "asin"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a04": {
            "entrypoint": "0x08000a04",
            "current_name": "is_valid_combination_08000a04",
            "code": "\nundefined4 is_valid_combination_08000a04(uint input1,int input2,uint input3,int input4)\n\n{\n  if ((((input2 << 1) >> 0x15 != -1) || ((input1 | input2 << 0xc) == 0)) &&\n     (((input4 << 1) >> 0x15 != -1 || ((input3 | input4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08000a04": "is_valid_combination_08000a04",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4"
            },
            "calling": [
                "pow",
                "sqrt",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a30": {
            "entrypoint": "0x08000a30",
            "current_name": "convert_to_float_08000a30",
            "code": "\nuint convertToFloat_08000a30(uint input,uint flags)\n\n{\n  uint result;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  bool isZero;\n  bool isTemp1LessThanBoundary;\n  \n  temp1 = flags * 2;\n  isTemp1LessThanBoundary = temp1 < 0x70000000;\n  temp2 = temp1 + 0x90000000;\n  result = temp2;\n  if (!isTemp1LessThanBoundary) {\n    temp3 = temp1 + 0x8fe00000;\n    result = temp3;\n  }\n  isZero = result == 0;\n  if (!isTemp1LessThanBoundary && temp2 >= 0x200000) {\n    isZero = temp3 == 0x1fc00000;\n  }\n  if (((isTemp1LessThanBoundary || temp2 < 0x200000) || 0x1fc00000 < temp3) || isZero) {\n    if ((flags & 0x40000000) != 0) {\n      if (((int)temp1 >> 0x15 == -1) && ((input | flags << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return flags & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(temp1 + 0x92e00000) < 0 != SCARRY4(temp2,0x2e00000)) {\n      return flags & 0x80000000;\n    }\n    temp1 = 0x18 - (temp1 + 0x92e00000 >> 0x15);\n    result = input >> (temp1 & 0xff);\n    if (input << (0x20 - temp1 & 0xff) != 0) {\n      result = result | 1;\n    }\n    temp2 = flags & 0x1fffff | 0x100000;\n    input = result | temp2 << (0x20 - temp1 & 0xff);\n    temp2 = (temp2 >> (temp1 & 0xff)) << 1;\n  }\n  result = (flags & 0x80000000 | input >> 0x1d) + temp2 * 4 + (uint)(0x7fffffff < input * 8);\n  if (input * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08000a30": "convert_to_float_08000a30",
                "param_1": "input",
                "param_2": "flags",
                "uVar1": "result",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "in_r12": "temp3",
                "bVar4": "isZero",
                "bVar5": "isTemp1LessThanBoundary"
            },
            "calling": [
                "MadgwickQuaternionUpdate",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ad0": {
            "entrypoint": "0x08000ad0",
            "current_name": "normalize_float_08000ad0",
            "code": "\nvoid normalizeFloat_08000ad0(uint value)\n\n{\n  normalizeSign(value ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ad0": "normalize_float_08000ad0",
                "param_1": "value",
                "__addsf3": "normalizeSign"
            },
            "calling": [],
            "called": [
                "__addsf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ad8": {
            "entrypoint": "0x08000ad8",
            "current_name": "calculate_floating_point_08000ad8",
            "code": "\nuint calculateFloatingPoint_08000ad8(uint inputValue1,uint inputValue2,undefined4 operand1,uint operand2)\n\n{\n  int shiftedInputValue1Sign;\n  int shiftedValueSign;\n  uint inputValue2Negated;\n  uint tempValue1;\n  uint shiftedInputValue1;\n  uint shiftedValue;\n  uint difference;\n  bool isConditionMet;\n  \n  inputValue2Negated = inputValue2 ^ 0x80000000;\n  shiftedInputValue1 = inputValue1 << 1;\n  isConditionMet = shiftedInputValue1 == 0;\n  if (!isConditionMet) {\n    operand2 = inputValue2 << 1;\n    isConditionMet = operand2 == 0;\n  }\n  if (!isConditionMet) {\n    isConditionMet = shiftedInputValue1 == operand2;\n  }\n  shiftedInputValue1Sign = (int)shiftedInputValue1 >> 0x18;\n  if (!isConditionMet) {\n    isConditionMet = shiftedInputValue1Sign == -1;\n  }\n  if (!isConditionMet) {\n    isConditionMet = (int)operand2 >> 0x18 == -1;\n  }\n  if (isConditionMet) {\n    shiftedValueSign = (int)(inputValue2 << 1) >> 0x18;\n    if (shiftedInputValue1Sign == -1 || shiftedValueSign == -1) {\n      shiftedInputValue1 = inputValue2Negated;\n      if (shiftedInputValue1Sign == -1) {\n        shiftedInputValue1 = inputValue1;\n      }\n      if (shiftedInputValue1Sign != -1 || shiftedValueSign != -1) {\n        inputValue2Negated = shiftedInputValue1;\n      }\n      isConditionMet = (shiftedInputValue1 & 0x7fffff) == 0;\n      if (isConditionMet) {\n        isConditionMet = (inputValue2Negated & 0x7fffff) == 0;\n      }\n      if (isConditionMet) {\n        isConditionMet = shiftedInputValue1 == inputValue2Negated;\n      }\n      if (!isConditionMet) {\n        shiftedInputValue1 = shiftedInputValue1 | 0x400000;\n      }\n      return shiftedInputValue1;\n    }\n    if (((inputValue1 ^ inputValue2Negated) & 0x7fffffff) != 0) {\n      if (shiftedInputValue1 == 0) {\n        inputValue1 = inputValue2Negated;\n      }\n      return inputValue1;\n    }\n    if (inputValue1 != inputValue2Negated) {\n      return 0;\n    }\n    if ((shiftedInputValue1 & 0xff000000) == 0) {\n      inputValue2Negated = inputValue1 << 1;\n      if ((inputValue1 & 0x80000000) != 0) {\n        inputValue2Negated = inputValue2Negated | 0x80000000;\n      }\n      return inputValue2Negated;\n    }\n    if (shiftedInputValue1 < 0xfe000000) {\n      return inputValue1 + 0x800000;\n    }\n    inputValue1 = inputValue1 & 0x80000000;\nLAB_08000c12:\n    return inputValue1 | 0x7f800000;\n  }\n  shiftedInputValue1 = shiftedInputValue1 >> 0x18;\n  operand2 = operand2 >> 0x18;\n  difference = operand2 - shiftedInputValue1;\n  isConditionMet = difference != 0;\n  shiftedValue = shiftedInputValue1;\n  if (isConditionMet && shiftedInputValue1 <= operand2) {\n    shiftedValue = shiftedInputValue1 + difference;\n  }\n  if (isConditionMet && shiftedInputValue1 <= operand2) {\n    inputValue2Negated = inputValue2Negated ^ inputValue1;\n  }\n  if (isConditionMet && shiftedInputValue1 <= operand2) {\n    inputValue1 = inputValue1 ^ inputValue2Negated;\n  }\n  if (isConditionMet && shiftedInputValue1 <= operand2) {\n    inputValue2Negated = inputValue2Negated ^ inputValue1;\n  }\n  if (operand2 < shiftedInputValue1) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return inputValue1;\n  }\n  shiftedInputValue1 = inputValue1 & 0xffffff | 0x800000;\n  if ((inputValue1 & 0x80000000) != 0) {\n    shiftedInputValue1 = -shiftedInputValue1;\n  }\n  tempValue1 = inputValue2Negated & 0xffffff | 0x800000;\n  if ((inputValue2Negated & 0x80000000) != 0) {\n    tempValue1 = -tempValue1;\n  }\n  if (shiftedValue == difference) {\n    tempValue1 = tempValue1 ^ 0x800000;\n    if (shiftedValue == 0) {\n      shiftedInputValue1 = shiftedInputValue1 ^ 0x800000;\n      shiftedValue = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  shiftedInputValue1 = shiftedInputValue1 + ((int)tempValue1 >> (difference & 0xff));\n  tempValue1 = tempValue1 << (0x20 - difference & 0xff);\n  inputValue1 = shiftedInputValue1 & 0x80000000;\n  if ((int)shiftedInputValue1 < 0) {\n    isConditionMet = tempValue1 != 0;\n    tempValue1 = -tempValue1;\n    shiftedInputValue1 = -shiftedInputValue1 - (uint)isConditionMet;\n  }\n  if (shiftedInputValue1 < 0x800000) {\n    inputValue2Negated = tempValue1 & 0x80000000;\n    tempValue1 = tempValue1 << 1;\n    shiftedInputValue1 = shiftedInputValue1 * 2 + (uint)(inputValue2Negated != 0);\n    inputValue2Negated = shiftedValue - 2;\n    if ((shiftedInputValue1 & 0x800000) == 0) {\n      difference = LZCOUNT(shiftedInputValue1) - 8;\n      shiftedInputValue1 = shiftedInputValue1 << (difference & 0xff);\n      if ((int)inputValue2Negated < (int)difference) {\n        shiftedInputValue1 = shiftedInputValue1 >> (-(inputValue2Negated - difference) & 0xff);\n      }\n      else {\n        shiftedInputValue1 = shiftedInputValue1 + (inputValue2Negated - difference) * 0x800000;\n      }\n      return shiftedInputValue1 | inputValue1;\n    }\n  }\n  else {\n    inputValue2Negated = shiftedValue - 1;\n    if (0xffffff < shiftedInputValue1) {\n      inputValue2Negated = shiftedInputValue1 & 1;\n      shiftedInputValue1 = shiftedInputValue1 >> 1;\n      tempValue1 = (uint)(inputValue2Negated != 0) << 0x1f | tempValue1 >> 1;\n      inputValue2Negated = shiftedValue;\n      if (0xfd < shiftedValue) goto LAB_08000c12;\n    }\n  }\n  shiftedInputValue1 = shiftedInputValue1 + inputValue2Negated * 0x800000 + (uint)(0x7fffffff < tempValue1);\n  if (tempValue1 == 0x80000000) {\n    shiftedInputValue1 = shiftedInputValue1 & 0xfffffffe;\n  }\n  return shiftedInputValue1 | inputValue1;\n}\n\n",
            "renaming": {
                "FUN_08000ad8": "calculate_floating_point_08000ad8",
                "param_1": "inputValue1",
                "param_2": "inputValue2",
                "param_3": "operand1",
                "param_4": "operand2",
                "uVar3": "inputValue2Negated",
                "uVar4": "tempValue1",
                "uVar5": "shiftedInputValue1",
                "uVar6": "shiftedValue",
                "uVar7": "difference",
                "bVar8": "isConditionMet",
                "iVar1": "shiftedInputValue1Sign",
                "iVar2": "shiftedValueSign"
            },
            "calling": [
                "PID_Compute",
                "lowPassFilter",
                "Motor_DistributeSpeed",
                "AK8963_ReadData",
                "MadgwickQuaternionUpdate",
                "MPU9250_ReadGyroData",
                "AHRS_GetYaw"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000adc": {
            "entrypoint": "0x08000adc",
            "current_name": "calculate_floating_point_08000adc",
            "code": "\nuint calculateFloatingPoint_08000adc(uint input_1,uint input_2,undefined4 undefined_param,uint shifted_input_2)\n\n{\n  int shifted_input_1_msb;\n  int shifted_input_2_msb;\n  uint temp_1;\n  uint shifted_input_1;\n  uint temp_2;\n  uint temp_3;\n  bool isZero;\n  \n  shifted_input_1 = input_1 << 1;\n  isZero = shifted_input_1 == 0;\n  if (!isZero) {\n    shifted_input_2 = input_2 << 1;\n    isZero = shifted_input_2 == 0;\n  }\n  if (!isZero) {\n    isZero = shifted_input_1 == shifted_input_2;\n  }\n  shifted_input_1_msb = (int)shifted_input_1 >> 0x18;\n  if (!isZero) {\n    isZero = shifted_input_1_msb == -1;\n  }\n  if (!isZero) {\n    isZero = (int)shifted_input_2 >> 0x18 == -1;\n  }\n  if (isZero) {\n    shifted_input_2_msb = (int)(input_2 << 1) >> 0x18;\n    if (shifted_input_1_msb == -1 || shifted_input_2_msb == -1) {\n      shifted_input_1 = input_2;\n      if (shifted_input_1_msb == -1) {\n        shifted_input_1 = input_1;\n      }\n      if (shifted_input_1_msb != -1 || shifted_input_2_msb != -1) {\n        input_2 = shifted_input_1;\n      }\n      isZero = (shifted_input_1 & 0x7fffff) == 0;\n      if (isZero) {\n        isZero = (input_2 & 0x7fffff) == 0;\n      }\n      if (isZero) {\n        isZero = shifted_input_1 == input_2;\n      }\n      if (!isZero) {\n        shifted_input_1 = shifted_input_1 | 0x400000;\n      }\n      return shifted_input_1;\n    }\n    if (((input_1 ^ input_2) & 0x7fffffff) != 0) {\n      if (shifted_input_1 == 0) {\n        input_1 = input_2;\n      }\n      return input_1;\n    }\n    if (input_1 != input_2) {\n      return 0;\n    }\n    if ((shifted_input_1 & 0xff000000) == 0) {\n      shifted_input_1 = input_1 << 1;\n      if ((input_1 & 0x80000000) != 0) {\n        shifted_input_1 = shifted_input_1 | 0x80000000;\n      }\n      return shifted_input_1;\n    }\n    if (shifted_input_1 < 0xfe000000) {\n      return input_1 + 0x800000;\n    }\n    input_1 = input_1 & 0x80000000;\nLAB_08000c12:\n    return input_1 | 0x7f800000;\n  }\n  shifted_input_1 = shifted_input_1 >> 0x18;\n  shifted_input_2 = shifted_input_2 >> 0x18;\n  temp_3 = shifted_input_2 - shifted_input_1;\n  isZero = temp_3 != 0;\n  temp_2 = shifted_input_1;\n  if (isZero && shifted_input_1 <= shifted_input_2) {\n    temp_2 = shifted_input_1 + temp_3;\n  }\n  if (isZero && shifted_input_1 <= shifted_input_2) {\n    input_2 = input_2 ^ input_1;\n  }\n  if (isZero && shifted_input_1 <= shifted_input_2) {\n    input_1 = input_1 ^ input_2;\n  }\n  if (isZero && shifted_input_1 <= shifted_input_2) {\n    input_2 = input_2 ^ input_1;\n  }\n  if (shifted_input_2 < shifted_input_1) {\n    temp_3 = -temp_3;\n  }\n  if (0x19 < temp_3) {\n    return input_1;\n  }\n  shifted_input_1 = input_1 & 0xffffff | 0x800000;\n  if ((input_1 & 0x80000000) != 0) {\n    shifted_input_1 = -shifted_input_1;\n  }\n  temp_1 = input_2 & 0xffffff | 0x800000;\n  if ((input_2 & 0x80000000) != 0) {\n    temp_1 = -temp_1;\n  }\n  if (temp_2 == temp_3) {\n    temp_1 = temp_1 ^ 0x800000;\n    if (temp_2 == 0) {\n      shifted_input_1 = shifted_input_1 ^ 0x800000;\n      temp_2 = 1;\n    }\n    else {\n      temp_3 = temp_3 - 1;\n    }\n  }\n  shifted_input_1 = shifted_input_1 + ((int)temp_1 >> (temp_3 & 0xff));\n  temp_1 = temp_1 << (0x20 - temp_3 & 0xff);\n  input_1 = shifted_input_1 & 0x80000000;\n  if ((int)shifted_input_1 < 0) {\n    isZero = temp_1 != 0;\n    temp_1 = -temp_1;\n    shifted_input_1 = -shifted_input_1 - (uint)isZero;\n  }\n  if (shifted_input_1 < 0x800000) {\n    temp_3 = temp_1 & 0x80000000;\n    temp_1 = temp_1 << 1;\n    shifted_input_1 = shifted_input_1 * 2 + (uint)(temp_3 != 0);\n    temp_3 = temp_2 - 2;\n    if ((shifted_input_1 & 0x800000) == 0) {\n      temp_2 = LZCOUNT(shifted_input_1) - 8;\n      shifted_input_1 = shifted_input_1 << (temp_2 & 0xff);\n      if ((int)temp_3 < (int)temp_2) {\n        shifted_input_1 = shifted_input_1 >> (-(temp_3 - temp_2) & 0xff);\n      }\n      else {\n        shifted_input_1 = shifted_input_1 + (temp_3 - temp_2) * 0x800000;\n      }\n      return shifted_input_1 | input_1;\n    }\n  }\n  else {\n    temp_3 = temp_2 - 1;\n    if (0xffffff < shifted_input_1) {\n      temp_3 = shifted_input_1 & 1;\n      shifted_input_1 = shifted_input_1 >> 1;\n      temp_1 = (uint)(temp_3 != 0) << 0x1f | temp_1 >> 1;\n      temp_3 = temp_2;\n      if (0xfd < temp_2) goto LAB_08000c12;\n    }\n  }\n  shifted_input_1 = shifted_input_1 + temp_3 * 0x800000 + (uint)(0x7fffffff < temp_1);\n  if (temp_1 == 0x80000000) {\n    shifted_input_1 = shifted_input_1 & 0xfffffffe;\n  }\n  return shifted_input_1 | input_1;\n}\n\n",
            "renaming": {
                "FUN_08000adc": "calculate_floating_point_08000adc",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "undefined_param",
                "param_4": "shifted_input_2",
                "uVar4": "shifted_input_1",
                "bVar7": "isZero",
                "iVar1": "shifted_input_1_msb",
                "iVar2": "shifted_input_2_msb",
                "uVar3": "temp_1",
                "uVar5": "temp_2",
                "uVar6": "temp_3"
            },
            "calling": [
                "PID_Update",
                "PID_Compute",
                "lowPassFilter",
                "Motor_DistributeSpeed",
                "AK8963_Init",
                "MadgwickQuaternionUpdate",
                "__aeabi_frsub",
                "AHRS_GetYaw",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c3c": {
            "entrypoint": "0x08000c3c",
            "current_name": "calculate_checksum_08000c3c",
            "code": "\nuint calculateChecksum_08000c3c(uint inputValue)\n\n{\n  uint leadingZerosCount;\n  uint shiftAmount;\n  int constantValue;\n  uint maskValue;\n  \n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZerosCount = LZCOUNT(inputValue);\n  shiftAmount = leadingZerosCount - 8;\n  constantValue = shiftAmount * -0x800000 + 0x4a800000;\n  if (7 < leadingZerosCount) {\n    maskValue = 0 << (shiftAmount & 0xff);\n    leadingZerosCount = constantValue + (inputValue << (shiftAmount & 0xff)) +\n            (0U >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < maskValue);\n    if (maskValue == 0x80000000) {\n      leadingZerosCount = leadingZerosCount & 0xfffffffe;\n    }\n    return leadingZerosCount;\n  }\n  shiftAmount = inputValue << leadingZerosCount + 0x18;\n  leadingZerosCount = constantValue + ((inputValue >> (0x20 - (leadingZerosCount + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n  if ((shiftAmount & 0x7fffffff) == 0) {\n    leadingZerosCount = leadingZerosCount & ~(shiftAmount >> 0x1f);\n  }\n  return leadingZerosCount;\n}\n\n",
            "renaming": {
                "FUN_08000c3c": "calculate_checksum_08000c3c",
                "param_1": "inputValue",
                "uVar1": "leadingZerosCount",
                "uVar2": "shiftAmount",
                "iVar3": "constantValue",
                "uVar4": "maskValue"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c44": {
            "entrypoint": "0x08000c44",
            "current_name": "extract_bit_from_integer_08000c44",
            "code": "\nuint extractBitFromInteger_08000c44(uint inputNumber)\n\n{\n  uint leadingZeros;\n  uint shiftAmount;\n  uint signBit;\n  int result;\n  \n  signBit = inputNumber & 0x80000000;\n  if ((int)signBit < 0) {\n    inputNumber = -inputNumber;\n  }\n  if (inputNumber == 0) {\n    return 0;\n  }\n  leadingZeros = countLeadingZeros(inputNumber);\n  shiftAmount = leadingZeros - 8;\n  result = ((signBit | 0x4b000000) - 0x800000) + shiftAmount * -0x800000;\n  if (7 < leadingZeros) {\n    leadingZeros = 0 << (shiftAmount & 0xff);\n    signBit = result + (inputNumber << (shiftAmount & 0xff)) +\n            (0U >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < leadingZeros);\n    if (leadingZeros == 0x80000000) {\n      signBit = signBit & 0xfffffffe;\n    }\n    return signBit;\n  }\n  shiftAmount = inputNumber << leadingZeros + 0x18;\n  signBit = result + ((inputNumber >> (0x20 - (leadingZeros + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n  if ((shiftAmount & 0x7fffffff) == 0) {\n    signBit = signBit & ~(shiftAmount >> 0x1f);\n  }\n  return signBit;\n}\n\n",
            "renaming": {
                "FUN_08000c44": "extract_bit_from_integer_08000c44",
                "param_1": "inputNumber",
                "uVar1": "leadingZeros",
                "uVar2": "shiftAmount",
                "uVar3": "signBit",
                "iVar4": "result",
                "LZCOUNT": "countLeadingZeros"
            },
            "calling": [
                "PID_Compute",
                "AK8963_Init",
                "MPU9250_ReadAccelData",
                "AK8963_ReadData",
                "MPU9250_ReadGyroData",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c60": {
            "entrypoint": "0x08000c60",
            "current_name": "calculate_result_08000c60",
            "code": "\nuint calculateResult_08000c60(uint input1,uint input2)\n\n{\n  uint result1;\n  uint result2;\n  uint count;\n  uint shift;\n  int constant;\n  \n  if ((input1 | input2) == 0) {\n    return input1;\n  }\n  result1 = input1;\n  result2 = input2;\n  if (input2 == 0) {\n    result1 = 0;\n    result2 = input1;\n  }\n  constant = 0x5b000000;\n  if (input2 == 0) {\n    constant = 0x4b000000;\n  }\n  count = leadingZeroCount(result2);\n  shift = count - 8;\n  constant = constant + -0x800000 + shift * -0x800000;\n  if (count < 8) {\n    shift = result2 << count + 0x18;\n    result2 = constant + ((result2 >> (0x20 - (count + 0x18) & 0xff)) - ((int)shift >> 0x1f));\n    if ((result1 | shift << 1) == 0) {\n      result2 = result2 & ~(shift >> 0x1f);\n    }\n    return result2;\n  }\n  count = result1 << (shift & 0xff);\n  result2 = constant + (result2 << (shift & 0xff)) +\n          (result1 >> (0x20 - shift & 0xff)) + (uint)(0x7fffffff < count);\n  if (count == 0x80000000) {\n    result2 = result2 & 0xfffffffe;\n  }\n  return result2;\n}\n\n",
            "renaming": {
                "FUN_08000c60": "calculate_result_08000c60",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "count",
                "uVar4": "shift",
                "iVar5": "constant",
                "LZCOUNT": "leadingZeroCount"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c70": {
            "entrypoint": "0x08000c70",
            "current_name": "calculate_08000c70",
            "code": "\nuint calculate_08000c70(uint input1,uint input2)\n\n{\n  uint result1;\n  uint result2;\n  uint count;\n  uint shift;\n  uint mask;\n  int offset;\n  bool isNegative;\n  \n  if ((input1 | input2) == 0) {\n    return input1;\n  }\n  mask = input2 & 0x80000000;\n  if ((int)mask < 0) {\n    isNegative = input1 != 0;\n    input1 = -input1;\n    input2 = -input2 - (uint)isNegative;\n  }\n  result2 = input1;\n  result1 = input2;\n  if (input2 == 0) {\n    result2 = 0;\n    result1 = input1;\n  }\n  mask = mask | 0x5b000000;\n  if (input2 == 0) {\n    mask = mask + 0xf0000000;\n  }\n  count = LZCOUNT(result1);\n  shift = count - 8;\n  offset = (mask - 0x800000) + shift * -0x800000;\n  if (count < 8) {\n    shift = result1 << count + 0x18;\n    mask = offset + ((result1 >> (0x20 - (count + 0x18) & 0xff)) - ((int)shift >> 0x1f));\n    if ((result2 | shift << 1) == 0) {\n      mask = mask & ~(shift >> 0x1f);\n    }\n    return mask;\n  }\n  count = result2 << (shift & 0xff);\n  mask = offset + (result1 << (shift & 0xff)) +\n          (result2 >> (0x20 - shift & 0xff)) + (uint)(0x7fffffff < count);\n  if (count == 0x80000000) {\n    mask = mask & 0xfffffffe;\n  }\n  return mask;\n}\n\n",
            "renaming": {
                "FUN_08000c70": "calculate_08000c70",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "count",
                "uVar4": "shift",
                "uVar5": "mask",
                "iVar6": "offset",
                "bVar7": "isNegative"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cec": {
            "entrypoint": "0x08000cec",
            "current_name": "calculate_float_08000cec",
            "code": "\nuint calculate_float_08000cec(uint numA,uint numB,undefined4 varA,uint varB)\n\n{\n  longlong product;\n  uint result;\n  uint shiftA;\n  int sum;\n  int diff;\n  uint temp;\n  int shiftB;\n  uint bits;\n  bool isZero;\n  bool isNegative;\n  \n  shiftA = numA >> 0x17 & 0xff;\n  isZero = shiftA == 0;\n  if (!isZero) {\n    varB = numB >> 0x17 & 0xff;\n    isZero = varB == 0;\n  }\n  if (!isZero) {\n    isZero = shiftA == 0xff;\n  }\n  if (!isZero) {\n    isZero = varB == 0xff;\n  }\n  if (isZero) {\n    varB = numB >> 0x17 & 0xff;\n    if (shiftA == 0xff || varB == 0xff) {\n      isZero = numA == 0 || numA == 0x80000000;\n      result = numB;\n      if (numA != 0 && numA != 0x80000000) {\n        isZero = numB == 0;\n        result = numA;\n      }\n      if (!isZero) {\n        isZero = numB == 0x80000000;\n      }\n      bits = result;\n      if (((isZero) || ((shiftA == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((varB == 0xff && (bits = numB, (numB & 0x7fffff) != 0)))) {\n        return bits | 0x7fc00000;\n      }\n      result = result ^ numB;\n      goto LAB_08000e3c;\n    }\n    isZero = (numA & 0x7fffffff) == 0;\n    if (!isZero) {\n      isZero = (numB & 0x7fffffff) == 0;\n    }\n    if (isZero) {\n      return (numA ^ numB) & 0x80000000;\n    }\n    isZero = shiftA == 0;\n    result = numA & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        numA = numA << 1;\n        isZero = (numA & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      shiftA = shiftA - 1;\n    }\n    numA = numA | result;\n    isZero = varB == 0;\n    result = numB & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        numB = numB << 1;\n        isZero = (numB & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      varB = varB - 1;\n    }\n    numB = numB | result;\n  }\n  sum = shiftA + varB;\n  bits = numA ^ numB;\n  shiftA = numA << 9;\n  isZero = shiftA == 0;\n  if (!isZero) {\n    numB = numB << 9;\n    isZero = numB == 0;\n  }\n  if (isZero) {\n    if (shiftA == 0) {\n      numB = numB << 9;\n    }\n    result = bits & 0x80000000 | numA & 0x7fffff | numB >> 9;\n    isNegative = SBORROW4(sum,0x7f);\n    diff = sum + -0x7f;\n    isZero = diff == 0;\n    shiftB = diff;\n    if (!isZero && 0x7e < sum) {\n      isNegative = SBORROW4(0xff,diff);\n      shiftB = 0xff - diff;\n      isZero = diff == 0xff;\n    }\n    if (!isZero && shiftB < 0 == isNegative) {\n      result = result | diff * 0x800000;\n    }\n    if (!isZero && shiftB < 0 == isNegative) {\n      return result;\n    }\n    result = result | 0x800000;\n    temp = 0;\n    isNegative = SBORROW4(diff,1);\n    bits = sum - 0x80;\n    isZero = bits == 0;\n    shiftA = bits;\n  }\n  else {\n    product = (ulonglong)(shiftA >> 5 | 0x8000000) * (ulonglong)(numB >> 5 | 0x8000000);\n    temp = (uint)product;\n    result = (uint)((ulonglong)product >> 0x20);\n    isZero = result < 0x800000;\n    if (isZero) {\n      result = result << 1;\n    }\n    if (isZero) {\n      result = result | temp >> 0x1f;\n      temp = temp << 1;\n    }\n    result = bits & 0x80000000 | result;\n    bits = (sum + -0x7f) - (uint)isZero;\n    isNegative = SBORROW4(bits,0xfd);\n    isZero = bits == 0xfd;\n    shiftA = bits - 0xfd;\n    if (bits < 0xfe) {\n      result = result + bits * 0x800000 + (uint)(0x7fffffff < temp);\n      if (temp == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (isZero || (int)shiftA < 0 != isNegative) {\n    isZero = (int)(bits + 0x19) < 0;\n    if (bits == 0xffffffe7 || isZero != SCARRY4(bits,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (bits != 0xffffffe7 && isZero == SCARRY4(bits,0x19)) {\n      shiftA = (result << 1) >> (-bits & 0xff);\n      bits = result << (bits + 0x20 & 0xff);\n      shiftA = ((uint)((result & 0x80000000) != 0) << 0x1f | shiftA >> 1) + (uint)((byte)shiftA & 1);\n      if ((temp | bits << 1) == 0) {\n        shiftA = shiftA & ~(bits >> 0x1f);\n      }\n      return shiftA;\n    }\n    return result;\n  }\nLAB_08000e3c:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000cec": "calculate_float_08000cec",
                "param_1": "numA",
                "param_2": "numB",
                "param_3": "varA",
                "param_4": "varB",
                "lVar1": "product",
                "uVar2": "result",
                "uVar3": "shiftA",
                "iVar4": "sum",
                "iVar5": "diff",
                "uVar6": "temp",
                "iVar7": "shiftB",
                "uVar8": "bits",
                "bVar9": "isZero",
                "bVar10": "isNegative"
            },
            "calling": [
                "PID_Update",
                "PID_Compute",
                "lowPassFilter",
                "AK8963_Init",
                "AHRS_ComputeAngles",
                "MPU9250_ReadAccelData",
                "AK8963_ReadData",
                "MadgwickQuaternionUpdate",
                "MPU9250_ReadGyroData",
                "PID_UpdateAltitude"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e54": {
            "entrypoint": "0x08000e54",
            "current_name": "calculate_float_08000e54",
            "code": "\nuint calculateFloat_08000e54(uint firstOperand,uint secondOperand,undefined4 param_3,uint param_4)\n\n{\n  uint shiftedSecondOperand1;\n  uint shiftedFirstOperand1;\n  int difference;\n  uint uVar4;\n  int iVar5;\n  uint result;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  \n  shiftedFirstOperand1 = firstOperand >> 0x17 & 0xff;\n  condition1 = shiftedFirstOperand1 == 0;\n  if (!condition1) {\n    param_4 = secondOperand >> 0x17 & 0xff;\n    condition1 = param_4 == 0;\n  }\n  if (!condition1) {\n    condition1 = shiftedFirstOperand1 == 0xff;\n  }\n  if (!condition1) {\n    condition1 = param_4 == 0xff;\n  }\n  if (condition1) {\n    param_4 = secondOperand >> 0x17 & 0xff;\n    result = firstOperand;\n    if (shiftedFirstOperand1 == 0xff) {\n      if (((firstOperand & 0x7fffff) != 0) || (result = secondOperand, param_4 == 0xff)) {\nLAB_08000e4a:\n        return result | 0x7fc00000;\n      }\n    }\n    else {\n      if (param_4 == 0xff) {\n        result = secondOperand;\n        if ((secondOperand & 0x7fffff) == 0) {\nLAB_08000e00:\n          return (firstOperand ^ secondOperand) & 0x80000000;\n        }\n        goto LAB_08000e4a;\n      }\n      condition1 = (firstOperand & 0x7fffffff) == 0;\n      if (!condition1) {\n        condition1 = (secondOperand & 0x7fffffff) == 0;\n      }\n      if (!condition1) {\n        condition1 = shiftedFirstOperand1 == 0;\n        result = firstOperand & 0x80000000;\n        while( true ) {\n          if (condition1) {\n            firstOperand = firstOperand << 1;\n            condition1 = (firstOperand & 0x800000) == 0;\n          }\n          if (!condition1) break;\n          shiftedFirstOperand1 = shiftedFirstOperand1 - 1;\n        }\n        firstOperand = firstOperand | result;\n        condition1 = param_4 == 0;\n        result = secondOperand & 0x80000000;\n        while( true ) {\n          if (condition1) {\n            secondOperand = secondOperand << 1;\n            condition1 = (secondOperand & 0x800000) == 0;\n          }\n          if (!condition1) break;\n          param_4 = param_4 - 1;\n        }\n        secondOperand = secondOperand | result;\n        goto LAB_08000e6c;\n      }\n      if ((firstOperand & 0x7fffffff) == 0) {\n        if ((secondOperand & 0x7fffffff) != 0) goto LAB_08000e00;\n        goto LAB_08000e4a;\n      }\n    }\n    firstOperand = firstOperand ^ secondOperand;\n  }\n  else {\nLAB_08000e6c:\n    difference = shiftedFirstOperand1 - param_4;\n    if (secondOperand << 9 == 0) {\n      firstOperand = (firstOperand ^ secondOperand) & 0x80000000 | firstOperand & 0x7fffff;\n      condition3 = SCARRY4(difference,0x7f);\n      iVar5 = difference + 0x7f;\n      condition1 = iVar5 < 0;\n      condition2 = iVar5 == 0;\n      if (!condition2 && condition1 == condition3) {\n        condition3 = SBORROW4(0xff,iVar5);\n        condition1 = 0xff - iVar5 < 0;\n        condition2 = iVar5 == 0xff;\n      }\n      if (!condition2 && condition1 == condition3) {\n        firstOperand = firstOperand | iVar5 * 0x800000;\n      }\n      if (!condition2 && condition1 == condition3) {\n        return firstOperand;\n      }\n      firstOperand = firstOperand | 0x800000;\n      shiftedFirstOperand1 = 0;\n      condition2 = SBORROW4(iVar5,1);\n      uVar4 = difference + 0x7e;\n      condition1 = uVar4 == 0;\n      result = uVar4;\n    }\n    else {\n      shiftedSecondOperand1 = (secondOperand << 9) >> 4 | 0x10000000;\n      shiftedFirstOperand1 = (firstOperand << 9) >> 4 | 0x10000000;\n      firstOperand = (firstOperand ^ secondOperand) & 0x80000000;\n      condition1 = shiftedSecondOperand1 <= shiftedFirstOperand1;\n      if (!condition1) {\n        shiftedFirstOperand1 = shiftedFirstOperand1 << 1;\n      }\n      uVar4 = difference + 0x7d + (uint)condition1;\n      result = 0x800000;\n      do {\n        if (shiftedSecondOperand1 <= shiftedFirstOperand1) {\n          shiftedFirstOperand1 = shiftedFirstOperand1 - shiftedSecondOperand1;\n          firstOperand = firstOperand | result;\n        }\n        condition1 = shiftedSecondOperand1 >> 1 <= shiftedFirstOperand1;\n        if (condition1) {\n          shiftedFirstOperand1 = shiftedFirstOperand1 - (shiftedSecondOperand1 >> 1);\n        }\n        if (condition1) {\n          firstOperand = firstOperand | result >> 1;\n        }\n        condition1 = shiftedSecondOperand1 >> 2 <= shiftedFirstOperand1;\n        if (condition1) {\n          shiftedFirstOperand1 = shiftedFirstOperand1 - (shiftedSecondOperand1 >> 2);\n        }\n        if (condition1) {\n          firstOperand = firstOperand | result >> 2;\n        }\n        condition1 = shiftedSecondOperand1 >> 3 <= shiftedFirstOperand1;\n        if (condition1) {\n          shiftedFirstOperand1 = shiftedFirstOperand1 - (shiftedSecondOperand1 >> 3);\n        }\n        if (condition1) {\n          firstOperand = firstOperand | result >> 3;\n        }\n        shiftedFirstOperand1 = shiftedFirstOperand1 * 0x10;\n        condition1 = shiftedFirstOperand1 == 0;\n        if (!condition1) {\n          result = result >> 4;\n          condition1 = result == 0;\n        }\n      } while (!condition1);\n      condition2 = SBORROW4(uVar4,0xfd);\n      condition1 = uVar4 == 0xfd;\n      result = uVar4 - 0xfd;\n      if (uVar4 < 0xfe) {\n        firstOperand = firstOperand + uVar4 * 0x800000 + (uint)(shiftedSecondOperand1 <= shiftedFirstOperand1);\n        if (shiftedFirstOperand1 - shiftedSecondOperand1 == 0) {\n          firstOperand = firstOperand & 0xfffffffe;\n        }\n        return firstOperand;\n      }\n    }\n    if (condition1 || (int)result < 0 != condition2) {\n      condition1 = (int)(uVar4 + 0x19) < 0;\n      if (uVar4 == 0xffffffe7 || condition1 != SCARRY4(uVar4,0x19)) {\n        firstOperand = firstOperand & 0x80000000;\n      }\n      if (uVar4 == 0xffffffe7 || condition1 != SCARRY4(uVar4,0x19)) {\n        return firstOperand;\n      }\n      result = (firstOperand << 1) >> (-uVar4 & 0xff);\n      uVar4 = firstOperand << (uVar4 + 0x20 & 0xff);\n      result = ((uint)((firstOperand & 0x80000000) != 0) << 0x1f | result >> 1) + (uint)((byte)result & 1);\n      if ((shiftedFirstOperand1 | uVar4 << 1) == 0) {\n        result = result & ~(uVar4 >> 0x1f);\n      }\n      return result;\n    }\n  }\n  return firstOperand & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000e54": "calculate_float_08000e54",
                "param_1": "firstOperand",
                "param_2": "secondOperand",
                "uVar1": "shiftedSecondOperand1",
                "uVar2": "shiftedFirstOperand1",
                "iVar3": "difference",
                "uVar6": "result",
                "bVar7": "condition1",
                "bVar8": "condition2",
                "bVar9": "condition3"
            },
            "calling": [
                "PID_Compute",
                "AHRS_ComputeAngles",
                "MadgwickQuaternionUpdate",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f8c": {
            "entrypoint": "0x08000f8c",
            "current_name": "compute_bitwise_operations_08000f8c",
            "code": "\nuint compute_bitwise_operations_08000f8c(uint input_value1,uint input_value2)\n\n{\n  bool is_negative_result;\n  uint double_input_value1;\n  uint double_input_value2;\n  uint combined_values;\n  bool is_zero_result;\n  \n  double_input_value1 = input_value1 * 2;\n  double_input_value2 = input_value2 * 2;\n  if (((int)double_input_value1 >> 0x18 == -1 || (int)double_input_value2 >> 0x18 == -1) &&\n     ((((int)double_input_value1 >> 0x18 == -1 && ((input_value1 & 0x7fffff) != 0)) ||\n      (((int)double_input_value2 >> 0x18 == -1 && ((input_value2 & 0x7fffff) != 0)))))) {\n    return 0xffffffff;\n  }\n  combined_values = double_input_value1 | input_value2 & 0x7fffffff;\n  is_zero_result = combined_values == 0;\n  if (!is_zero_result) {\n    combined_values = input_value1 ^ input_value2;\n    is_zero_result = combined_values == 0;\n  }\n  is_negative_result = -1 < (int)combined_values;\n  if (is_negative_result) {\n    input_value1 = double_input_value1 + input_value2 * -2;\n    is_zero_result = input_value1 == 0;\n  }\n  if ((is_negative_result && double_input_value2 <= double_input_value1) && !is_zero_result) {\n    input_value1 = (int)input_value2 >> 0x1f;\n  }\n  if (!is_negative_result || double_input_value2 > double_input_value1) {\n    input_value1 = ~((int)input_value2 >> 0x1f);\n  }\n  if (!is_zero_result) {\n    input_value1 = input_value1 | 1;\n  }\n  return input_value1;\n}\n\n",
            "renaming": {
                "FUN_08000f8c": "compute_bitwise_operations_08000f8c",
                "param_1": "input_value1",
                "param_2": "input_value2",
                "uVar2": "double_input_value1",
                "uVar3": "double_input_value2",
                "uVar4": "combined_values",
                "bVar1": "is_negative_result",
                "bVar5": "is_zero_result"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f94": {
            "entrypoint": "0x08000f94",
            "current_name": "calculate_result_08000f94",
            "code": "\nuint calculate_result_08000f94(uint input_1,uint input_2)\n\n{\n  bool is_negative;\n  uint calculated_value_1;\n  uint calculated_value_2;\n  uint combined_value;\n  bool is_zero;\n  \n  calculated_value_1 = input_1 * 2;\n  calculated_value_2 = input_2 * 2;\n  if (((int)calculated_value_1 >> 0x18 == -1 || (int)calculated_value_2 >> 0x18 == -1) &&\n     ((((int)calculated_value_1 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)calculated_value_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined_value = calculated_value_1 | input_2 & 0x7fffffff;\n  is_zero = combined_value == 0;\n  if (!is_zero) {\n    combined_value = input_1 ^ input_2;\n    is_zero = combined_value == 0;\n  }\n  is_negative = -1 < (int)combined_value;\n  if (is_negative) {\n    input_1 = calculated_value_1 + input_2 * -2;\n    is_zero = input_1 == 0;\n  }\n  if ((is_negative && calculated_value_2 <= calculated_value_1) && !is_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_negative || calculated_value_2 > calculated_value_1) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "renaming": {
                "FUN_08000f94": "calculate_result_08000f94",
                "param_1": "input_1",
                "param_2": "input_2",
                "bVar1": "is_negative",
                "uVar2": "calculated_value_1",
                "uVar3": "calculated_value_2",
                "uVar4": "combined_value",
                "bVar5": "is_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f9c": {
            "entrypoint": "0x08000f9c",
            "current_name": "calculate_08000f9c",
            "code": "\nuint calculate_08000f9c(uint input_1,uint input_2)\n\n{\n  bool isNegative;\n  uint input_1_times_2;\n  uint input_2_times_2;\n  uint result;\n  bool isZero;\n  \n  input_1_times_2 = input_1 * 2;\n  input_2_times_2 = input_2 * 2;\n  if (((int)input_1_times_2 >> 0x18 == -1 || (int)input_2_times_2 >> 0x18 == -1) &&\n     ((((int)input_1_times_2 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)input_2_times_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  result = input_1_times_2 | input_2 & 0x7fffffff;\n  isZero = result == 0;\n  if (!isZero) {\n    result = input_1 ^ input_2;\n    isZero = result == 0;\n  }\n  isNegative = -1 < (int)result;\n  if (isNegative) {\n    input_1 = input_1_times_2 + input_2 * -2;\n    isZero = input_1 == 0;\n  }\n  if ((isNegative && input_2_times_2 <= input_1_times_2) && !isZero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!isNegative || input_2_times_2 > input_1_times_2) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!isZero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "renaming": {
                "FUN_08000f9c": "calculate_08000f9c",
                "param_1": "input_1",
                "param_2": "input_2",
                "bVar1": "isNegative",
                "uVar2": "input_1_times_2",
                "uVar3": "input_2_times_2",
                "uVar4": "result",
                "bVar5": "isZero"
            },
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ffc": {
            "entrypoint": "0x08000ffc",
            "current_name": "compare_floats_08000ffc",
            "code": "\nvoid compareFloats_08000ffc(undefined4 float1,undefined4 float2)\n\n{\n  __aeabi_cfcmpeq(float2,float1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ffc": "compare_floats_08000ffc",
                "param_1": "float1",
                "param_2": "float2"
            },
            "calling": [
                "__aeabi_fcmpgt",
                "__aeabi_fcmpge"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001004": {
            "entrypoint": "0x08001004",
            "current_name": "concatenate_parameters_08001004",
            "code": "\nundefined8 concatenateParameters_08001004(undefined4 firstParam,undefined4 secondParam)\n\n{\n  __cmpsf2();\n  return CONCAT44(secondParam,firstParam);\n}\n\n",
            "renaming": {
                "FUN_08001004": "concatenate_parameters_08001004",
                "param_1": "firstParam",
                "param_2": "secondParam"
            },
            "calling": [
                "__aeabi_fcmpeq",
                "__aeabi_cfrcmple",
                "__aeabi_fcmple",
                "__aeabi_fcmplt"
            ],
            "called": [
                "__cmpsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001014": {
            "entrypoint": "0x08001014",
            "current_name": "is_not_null_08001014",
            "code": "\nbool is_not_null_08001014(void)\n\n{\n  char is_equal;\n  \n  compare_floating_point();\n  return is_equal != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001014": "is_not_null_08001014",
                "in_ZR": "is_equal",
                "__aeabi_cfcmpeq": "compare_floating_point"
            },
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001028": {
            "entrypoint": "0x08001028",
            "current_name": "check_if_null_08001028",
            "code": "\nbool check_if_null_08001028(void)\n\n{\n  char input_char;\n  \n  __aeabi_cfcmpeq();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001028": "check_if_null_08001028",
                "in_CY": "input_char"
            },
            "calling": [
                "PID_Update",
                "PID_Compute",
                "AHRS_GetYaw"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800103c": {
            "entrypoint": "0x0800103c",
            "current_name": "compare_floating_point_values_0800103c",
            "code": "\nbool compareFloatingPointValues_0800103c(void)\n\n{\n  undefined isZeroResult;\n  undefined isCarry;\n  \n  __aeabi_cfcmpeq();\n  return !(bool)isCarry || (bool)isZeroResult;\n}\n\n",
            "renaming": {
                "FUN_0800103c": "compare_floating_point_values_0800103c",
                "in_ZR": "isZeroResult",
                "in_CY": "isCarry"
            },
            "calling": [],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001050": {
            "entrypoint": "0x08001050",
            "current_name": "check_cfrcmpl_condition_08001050",
            "code": "\nbool check_CFRCMPL_condition_08001050(void)\n\n{\n  undefined is_zero_flag_set;\n  undefined is_carry_flag_set;\n  \n  __aeabi_cfrcmple();\n  return !(bool)is_carry_flag_set || (bool)is_zero_flag_set;\n}\n\n",
            "renaming": {
                "FUN_08001050": "check_cfrcmpl_condition_08001050",
                "in_ZR": "is_zero_flag_set",
                "in_CY": "is_carry_flag_set"
            },
            "calling": [
                "AHRS_GetYaw"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001064": {
            "entrypoint": "0x08001064",
            "current_name": "is_end_of_string_08001064",
            "code": "\nbool is_end_of_string_08001064(void)\n\n{\n  char character;\n  \n  __aeabi_cfrcmple();\n  return character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001064": "is_end_of_string_08001064",
                "in_CY": "character"
            },
            "calling": [
                "PID_Update",
                "PID_Compute"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001078": {
            "entrypoint": "0x08001078",
            "current_name": "extract_data_08001078",
            "code": "\nuint extract_data_08001078(uint value)\n\n{\n  uint processed_value;\n  uint offset;\n  \n  if (value << 1 < 0x7f000000) {\n    return 0;\n  }\n  processed_value = (value << 1) >> 0x18;\n  offset = 0x9e - processed_value;\n  if (processed_value < 0x9f && offset != 0) {\n    processed_value = (value << 8 | 0x80000000) >> (offset & 0xff);\n    if ((value & 0x80000000) != 0) {\n      processed_value = -processed_value;\n    }\n    return processed_value;\n  }\n  if ((offset == 0xffffff9f) && ((value & 0x7fffff) != 0)) {\n    return 0;\n  }\n  value = value & 0x80000000;\n  if (value == 0) {\n    value = 0x7fffffff;\n  }\n  return value;\n}\n\n",
            "renaming": {
                "FUN_08001078": "extract_data_08001078",
                "param_1": "value",
                "uVar1": "processed_value",
                "uVar2": "offset"
            },
            "calling": [
                "Motor_DistributeSpeed",
                "AHRS_ComputeAngles",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080010c4": {
            "entrypoint": "0x080010c4",
            "current_name": "validate_unsigned_integer_080010c4",
            "code": "\nuint validateUnsignedInteger_080010c4(uint inputValue)\n\n{\n  uint shiftAmount;\n  \n  if (((inputValue & 0x80000000) != 0) || (inputValue << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shiftAmount = 0x9e - ((inputValue << 1) >> 0x18);\n  if (-1 < (int)shiftAmount) {\n    return (inputValue << 8 | 0x80000000) >> (shiftAmount & 0xff);\n  }\n  if ((shiftAmount == 0xffffff9f) && ((inputValue & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080010c4": "validate_unsigned_integer_080010c4",
                "param_1": "inputValue",
                "uVar1": "shiftAmount"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001104": {
            "entrypoint": "0x08001104",
            "current_name": "configure_sys_tick_08001104",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureSysTick_08001104(uint32_t priority)\n\n{\n  uint32_t hclkFreq;\n  \n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFreq / 1000);\n  HAL_NVIC_SetPriority(SysTick_IRQn,priority,0);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001104": "configure_sys_tick_08001104",
                "TickPriority": "priority",
                "uVar1": "hclkFreq"
            },
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_RCC_GetHCLKFreq",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001128": {
            "entrypoint": "0x08001128",
            "current_name": "initialize_hardware_08001128",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nStatus initializeHardware_08001128(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  setPriorityGrouping(3);\n  initTick(0);\n  initializeMsp();\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_08001128": "initialize_hardware_08001128",
                "HAL_StatusTypeDef": "Status",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping",
                "HAL_InitTick": "initTick",
                "HAL_MspInit": "initializeMsp",
                "HAL_OK": "OK"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800114c": {
            "entrypoint": "0x0800114c",
            "current_name": "increment_tick_count_0800114c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid incrementTickCount_0800114c(void)\n\n{\n  tickCounter = tickCounter + 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800114c": "increment_tick_count_0800114c",
                "uwTick": "tickCounter"
            },
            "calling": [
                "SysTick_Handler",
                "main"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800115c": {
            "entrypoint": "0x0800115c",
            "current_name": "get_tick_count_0800115c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTickCount_0800115c(void)\n\n{\n  return tickValue;\n}\n\n",
            "renaming": {
                "FUN_0800115c": "get_tick_count_0800115c",
                "uwTick": "tickValue"
            },
            "calling": [
                "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig",
                "I2C_RequestMemoryWrite",
                "I2C_RequestMemoryRead",
                "HAL_I2C_Mem_Read",
                "HAL_UART_Transmit",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_I2C_Mem_Write",
                "millis",
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "micros",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001168": {
            "entrypoint": "0x08001168",
            "current_name": "FUNC_08001168",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001168(uint32_t Delay)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001168": "FUNC_08001168"
            },
            "calling": [
                "HAL_RCC_OscConfig",
                "delay_ms"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001170": {
            "entrypoint": "0x08001170",
            "current_name": "configure_priority_group_08001170",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configurePriorityGroup_08001170(uint32_t priorityGroup)\n\n{\n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | 0x5fa0000 | (priorityGroup & 7) << 8;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001170": "configure_priority_group_08001170",
                "PriorityGroup": "priorityGroup"
            },
            "calling": [
                "HAL_Init",
                "HAL_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001194": {
            "entrypoint": "0x08001194",
            "current_name": "set_interrupt_priority_08001194",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setInterruptPriority_08001194(interruptNumber_Type interruptNumber,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint uVar1;\n  undefined uVar2;\n  uint32_t preemptPriorityBits;\n  uint uVar3;\n  uint32_t priorityGroupTmp;\n  uint32_t subPriorityBits;\n  uint uVar4;\n  \n  uVar1 = (uint)interruptNumber;\n  subPriorityBits = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  preemptPriorityBits = 7 - subPriorityBits;\n  uVar4 = subPriorityBits + 4;\n  if (3 < preemptPriorityBits) {\n    preemptPriorityBits = 4;\n  }\n  if (uVar4 < 7) {\n    subPriorityBits = 0;\n  }\n  uVar3 = (1 << (preemptPriorityBits & 0xff)) - 1;\n  if (6 < uVar4) {\n    subPriorityBits = subPriorityBits - 3;\n  }\n  uVar2 = (undefined)\n          ((subPriority & (1 << (subPriorityBits & 0xff)) - 1U |\n           (preemptPriority & uVar3) << (subPriorityBits & 0xff)) << 4);\n  if (-1 < (int)uVar1) {\n    uVar4 = uVar1 + 0xe000e100;\n  }\n  else {\n    uVar3 = 0xe000ed14;\n    uVar4 = uVar1 & 0xf;\n  }\n  if (-1 < (int)uVar1) {\n    *(undefined *)(uVar4 + 0x300) = uVar2;\n  }\n  else {\n    *(undefined *)(uVar3 + uVar4) = uVar2;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001194": "set_interrupt_priority_08001194",
                "IRQn": "interruptNumber",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "PreemptPriorityBits": "preemptPriorityBits",
                "PriorityGroupTmp": "priorityGroupTmp",
                "SubPriorityBits": "subPriorityBits"
            },
            "calling": [
                "HAL_UART_MspInit",
                "HAL_MspInit",
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011fc": {
            "entrypoint": "0x080011fc",
            "current_name": "set_irq_enabled_080011fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_IRQ_enabled_080011fc(interrupt_number_Type interrupt_number)\n\n{\n  *(int *)(((uint)(int)interrupt_number >> 5) * 4 + -0x1fff1f00) = 1 << ((int)interrupt_number & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080011fc": "set_irq_enabled_080011fc",
                "IRQn": "interrupt_number"
            },
            "calling": [
                "HAL_UART_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001214": {
            "entrypoint": "0x08001214",
            "current_name": "initialize_timer_08001214",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t initializeTimer_08001214(uint32_t ticksNumber)\n\n{\n  if (ticksNumber - 1 < 0x1000000) {\n    _DAT_e000e014 = ticksNumber - 1;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08001214": "initialize_timer_08001214",
                "TicksNumb": "ticksNumber"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001240": {
            "entrypoint": "0x08001240",
            "current_name": "update_clk_source_08001240",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid updateCLKSource_08001240(uint32_t source)\n\n{\n  if (source == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001240": "update_clk_source_08001240",
                "CLKSource": "source"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001258": {
            "entrypoint": "0x08001258",
            "current_name": "FUNC_08001258",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001258(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001258": "FUNC_08001258"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800125a": {
            "entrypoint": "0x0800125a",
            "current_name": "handle_sys_tick_callback_0800125a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickCallback_0800125a(void)\n\n{\n  processSysTick();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800125a": "handle_sys_tick_callback_0800125a",
                "HAL_SYSTICK_Callback": "processSysTick"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001264": {
            "entrypoint": "0x08001264",
            "current_name": "configure_gpio_08001264",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureGPIO_08001264(GPIO *GPIOx,GPIO_Configuration *GPIO_Init)\n\n{\n  uint32_t *config_register;\n  uint32_t speed;\n  uint pin_check;\n  uint mode;\n  int port_index;\n  uint pin_index;\n  uint pin;\n  uint alternate_mode;\n  GPIO *GPIO_struct;\n  int shift;\n  uint32_t temporary_register;\n  \n  speed = 0;\n  pin_index = 0;\n  do {\n    pin = 1 << (pin_index & 0xff);\n    pin_check = pin & GPIO_Init->Pin;\n    if (pin == pin_check) {\n      mode = GPIO_Init->Mode;\n      if (mode == 0x12) {\n        speed = GPIO_Init->Speed + 0xc;\n      }\n      else if (mode < 0x13) {\n        if (mode == 2) {\n          speed = GPIO_Init->Speed + 8;\n        }\n        else if (mode < 3) {\n          if (mode == 0) goto LAB_080013be;\n          if (mode == 1) {\n            speed = GPIO_Init->Speed;\n          }\n        }\n        else if (mode == 3) {\n          speed = 0;\n        }\n        else if (mode == 0x11) {\n          speed = GPIO_Init->Speed + 4;\n        }\n      }\n      else {\n        if (mode != 0x10210000) {\n          if (mode < 0x10210001) {\n            if (mode != 0x10110000) {\n              alternate_mode = 0x10120000;\nLAB_080013b8:\n              if (mode != alternate_mode) goto LAB_080012a8;\n            }\n          }\n          else if ((mode != 0x10310000) && (mode != 0x10320000)) {\n            alternate_mode = 0x10220000;\n            goto LAB_080013b8;\n          }\n        }\nLAB_080013be:\n        speed = GPIO_Init->Pull;\n        if (speed == 0) {\n          speed = 4;\n        }\n        else {\n          if (speed == 1) {\n            GPIOx->BSRR = pin;\n          }\n          if (speed != 1) {\n            GPIOx->BRR = pin;\n          }\n          speed = 8;\n        }\n      }\nLAB_080012a8:\n      if (pin_check < 0x100) {\n        pin = GPIOx->CRL;\n        mode = pin_index << 2;\n        GPIO_struct = GPIOx;\n      }\n      else {\n        pin = GPIOx->CRH;\n        mode = (pin_index + 0x3ffffff8) * 4;\n      }\n      if (0xff < pin_check) {\n        GPIO_struct = (GPIO *)&GPIOx->CRH;\n      }\n      GPIO_struct->CRL = pin & ~(0xf << (mode & 0xff)) | speed << (mode & 0xff);\n      GPIO_struct = (GPIO *)GPIO_Init->Mode;\n      if (((uint)GPIO_struct & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        shift = (pin_index & 3) << 2;\n        if (GPIOx == (GPIO *)0x40010800) {\n          port_index = 0;\n        }\n        else if (GPIOx == (GPIO *)0x40010c00) {\n          port_index = 1;\n        }\n        else if (GPIOx == (GPIO *)0x40011000) {\n          port_index = 2;\n        }\n        else if (GPIOx == (GPIO *)0x40011400) {\n          port_index = 3;\n        }\n        else {\n          port_index = 4;\n        }\n        *(uint *)((pin_index & 0xfffffffc) + 0x40010008) =\n             port_index << shift | *(uint *)((pin_index & 0xfffffffc) + 0x40010008) & ~(0xf << shift);\n        if (((uint)GPIO_struct & 0x10000) == 0) {\n          _DAT_40010400 = _DAT_40010400 & ~pin_check;\n        }\n        else {\n          _DAT_40010400 = _DAT_40010400 | pin_check;\n        }\n        if (((uint)GPIO_struct & 0x20000) == 0) {\n          _DAT_40010404 = _DAT_40010404 & ~pin_check;\n        }\n        else {\n          _DAT_40010404 = _DAT_40010404 | pin_check;\n        }\n        if (((uint)GPIO_struct & 0x100000) == 0) {\n          _DAT_40010408 = _DAT_40010408 & ~pin_check;\n        }\n        else {\n          _DAT_40010408 = _DAT_40010408 | pin_check;\n        }\n        if (((uint)GPIO_struct & 0x200000) == 0) {\n          _DAT_4001040c = _DAT_4001040c & ~pin_check;\n        }\n        else {\n          _DAT_4001040c = pin_check | _DAT_4001040c;\n        }\n      }\n    }\n    pin_index = pin_index + 1;\n    if (pin_index == 0x10) {\n      return;\n    }\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08001264": "configure_gpio_08001264",
                "GPIO_TypeDef": "GPIO",
                "GPIO_InitTypeDef": "GPIO_Configuration",
                "configregister": "config_register",
                "uVar1": "speed",
                "uVar2": "pin_check",
                "uVar3": "mode",
                "iVar4": "port_index",
                "uVar5": "pin_index",
                "uVar6": "pin",
                "uVar7": "alternate_mode",
                "unaff_r10": "GPIO_struct",
                "iVar8": "shift",
                "tmpreg": "temporary_register"
            },
            "calling": [
                "HAL_UART_MspInit",
                "Peripherals_Init",
                "HAL_I2C_MspInit",
                "HAL_TIM_MspPostInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001424": {
            "entrypoint": "0x08001424",
            "current_name": "set_pin_state_08001424",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinState_08001424(GPIO_TypeDef *port,uint16_t pinNumber,pinNumberState state)\n\n{\n  uint32_t mask;\n  \n  mask = (uint32_t)pinNumber;\n  if (state == GPIO_PIN_RESET) {\n    mask = mask << 0x10;\n  }\n  port->BSRR = mask;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001424": "set_pin_state_08001424",
                "GPIOx": "port",
                "GPIO_Pin": "pinNumber",
                "PinState": "state",
                "uVar1": "mask"
            },
            "calling": [
                "Peripherals_Init",
                "toggleLED",
                "_Error_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800142e": {
            "entrypoint": "0x0800142e",
            "current_name": "update_gpio_output_0800142e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateGpioOutput_0800142e(GPIO_TypeDef *gpioPort,uint16_t pinNumber)\n\n{\n  gpioPort->ODR = (uint)pinNumber ^ gpioPort->ODR;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800142e": "update_gpio_output_0800142e",
                "GPIOx": "gpioPort",
                "GPIO_Pin": "pinNumber"
            },
            "calling": [
                "_Error_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001436": {
            "entrypoint": "0x08001436",
            "current_name": "check_i2_c_status_08001436",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatus checkI2CStatus_08001436(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2C_TypeDef *i2cInstance;\n  \n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->statusRegister & 0x400) != 0) {\n    i2cInstance->statusRegister = i2cInstance->statusRegister & 0xfffffbff;\n    i2cHandle->error = 4;\n    i2cHandle->currentState = I2C_STATE_READY;\n    i2cHandle->lockState = UNLOCKED;\n    return ERROR;\n  }\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_08001436": "check_i2_c_status_08001436",
                "hi2c": "i2cHandle",
                "pIVar1": "i2cInstance",
                "SR1": "statusRegister",
                "ErrorCode": "error",
                "State": "currentState",
                "Lock": "lockState",
                "HAL_StatusTypeDef": "Status",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_UNLOCKED": "UNLOCKED",
                "HAL_ERROR": "ERROR",
                "HAL_OK": "OK"
            },
            "calling": [
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001460": {
            "entrypoint": "0x08001460",
            "current_name": "check_i2_c_status_08001460",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef checkI2CStatus_08001460(I2C_HandleTypeDef *i2cHandler,uint32_t statusFlag,uint32_t timeout)\n\n{\n  uint32_t startTick;\n  uint32_t currentTick;\n  uint statusRegValue;\n  I2C_TypeDef *i2cInstance;\n  \n  startTick = HAL_GetTick();\n  do {\n    i2cInstance = i2cHandler->Instance;\n    if ((statusFlag << 8) >> 0x18 == 1) {\n      statusRegValue = i2cInstance->SR1;\n    }\n    else {\n      statusRegValue = i2cInstance->SR2;\n    }\n    if ((statusFlag & 0xffff & ~statusRegValue) == 0) {\n      return HAL_OK;\n    }\n    if ((int)(i2cInstance->SR1 << 0x15) < 0) {\n      i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n      i2cInstance->SR1 = i2cInstance->SR1 & 0xfffffbff;\n      i2cHandler->ErrorCode = 4;\n      i2cHandler->State = HAL_I2C_STATE_READY;\n      i2cHandler->Lock = HAL_UNLOCKED;\n      return HAL_ERROR;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - startTick <= timeout))));\n  i2cHandler->State = HAL_I2C_STATE_READY;\n  i2cHandler->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08001460": "check_i2_c_status_08001460",
                "hi2c": "i2cHandler",
                "Flag": "statusFlag",
                "Timeout": "timeout",
                "uVar1": "startTick",
                "uVar2": "currentTick",
                "uVar3": "statusRegValue",
                "pIVar4": "i2cInstance"
            },
            "calling": [
                "I2C_RequestMemoryWrite",
                "I2C_RequestMemoryRead"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014e2": {
            "entrypoint": "0x080014e2",
            "current_name": "check_i2_c_acknowledge_080014e2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef checkI2CAcknowledge_080014e2(I2C_HandleTypeDef *i2cHandle,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTick;\n  uint32_t currentTick;\n  uint32_t startTime;\n  \n  startTick = HAL_GetTick();\n  while( true ) {\n    if ((int)(i2cHandle->Instance->SR1 << 0x18) < 0) {\n      return HAL_OK;\n    }\n    status = I2C_IsAcknowledgeFailed(i2cHandle);\n    if (status != HAL_OK) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (currentTick = HAL_GetTick(), timeout < currentTick - startTick)))) {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 0x20;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_080014e2": "check_i2_c_acknowledge_080014e2",
                "hi2c": "i2cHandle",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "startTick",
                "uVar3": "currentTick",
                "tickstart": "startTime"
            },
            "calling": [
                "I2C_RequestMemoryWrite",
                "I2C_RequestMemoryRead",
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_IsAcknowledgeFailed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001530": {
            "entrypoint": "0x08001530",
            "current_name": "configure_i2_c_08001530",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nconfigureI2C_08001530(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTime;\n  uint32_t currentTime;\n  I2C_TypeDef *i2cInstance;\n  uint32_t tempReg;\n  \n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n  startTime = HAL_GetTick();\n  do {\n    do {\n      if ((int)(i2cHandle->Instance->SR1 << 0x1f) < 0) {\n        i2cHandle->Instance->DR = deviceAddress & 0xfe;\n        status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout);\n        if (status == HAL_OK) {\n          status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n          if (status == HAL_OK) {\n            i2cInstance = i2cHandle->Instance;\n            if (memoryAddressSize == 1) {\nLAB_080015ca:\n              i2cInstance->DR = (uint)(byte)memoryAddress;\n              return HAL_OK;\n            }\n            i2cInstance->DR = (uint)(memoryAddress >> 8);\n            status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n            if (status == HAL_OK) {\n              i2cInstance = i2cHandle->Instance;\n              goto LAB_080015ca;\n            }\n          }\n          if (i2cHandle->ErrorCode != 4) {\n            return HAL_TIMEOUT;\n          }\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        }\n        else if (i2cHandle->ErrorCode != 4) {\n          return HAL_TIMEOUT;\n        }\n        return HAL_ERROR;\n      }\n    } while (timeout == 0xffffffff);\n    if ((timeout == 0) || (currentTime = HAL_GetTick(), timeout < currentTime - startTime)) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08001530": "configure_i2_c_08001530",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "startTime",
                "uVar3": "currentTime",
                "pIVar4": "i2cInstance",
                "tmpreg": "tempReg"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015e8": {
            "entrypoint": "0x080015e8",
            "current_name": "i2c_transfer_080015e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\ni2c_transfer_080015e8(I2C_HandleTypeDef *i2c_handle,uint16_t device_address,uint16_t memory_address,uint16_t memory_address_size,\n            uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t start_time;\n  uint32_t current_time;\n  I2C_TypeDef *i2c_instance;\n  uint32_t temporary_register;\n  \n  i2c_instance = i2c_handle->Instance;\n  i2c_instance->CR1 = i2c_instance->CR1 | 0x400;\n  i2c_instance->CR1 = i2c_instance->CR1 | 0x100;\n  start_time = HAL_GetTick();\nLAB_0800160e:\n  while (-1 < (int)(i2c_handle->Instance->SR1 << 0x1f)) {\n    if (timeout != 0xffffffff) goto code_r0x08001658;\n  }\n  i2c_handle->Instance->DR = (byte)device_address & 0xfe;\n  status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2c_handle,0x10002,timeout);\n  if (status != HAL_OK) goto LAB_080016ba;\n  status = I2C_WaitOnTXEFlagUntiltimeout(i2c_handle,timeout);\n  if (status == HAL_OK) {\n    i2c_instance = i2c_handle->Instance;\n    if (memory_address_size != 1) {\n      i2c_instance->DR = (uint)(memory_address >> 8);\n      status = I2C_WaitOnTXEFlagUntiltimeout(i2c_handle,timeout);\n      if (status != HAL_OK) goto LAB_08001642;\n      i2c_instance = i2c_handle->Instance;\n    }\n    i2c_instance->DR = (uint)(byte)memory_address;\n    status = I2C_WaitOnTXEFlagUntiltimeout(i2c_handle,timeout);\n    if (status == HAL_OK) {\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x100;\n      start_time = HAL_GetTick();\n      do {\n        do {\n          if ((int)(i2c_handle->Instance->SR1 << 0x1f) < 0) {\n            i2c_handle->Instance->DR = (byte)device_address | 1;\n            status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2c_handle,0x10002,timeout);\n            if (status == HAL_OK) {\n              return HAL_OK;\n            }\nLAB_080016ba:\n            if (i2c_handle->ErrorCode != 4) {\n              return HAL_TIMEOUT;\n            }\n            return HAL_ERROR;\n          }\n        } while (timeout == 0xffffffff);\n      } while ((timeout != 0) && (current_time = HAL_GetTick(), current_time - start_time <= timeout));\nLAB_0800165a:\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\nLAB_08001642:\n  if (i2c_handle->ErrorCode == 4) {\n    i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n    return HAL_ERROR;\n  }\n  return HAL_TIMEOUT;\ncode_r0x08001658:\n  if ((timeout == 0) || (current_time = HAL_GetTick(), timeout < current_time - start_time)) goto LAB_0800165a;\n  goto LAB_0800160e;\n}\n\n",
            "renaming": {
                "FUN_080015e8": "i2c_transfer_080015e8",
                "hi2c": "i2c_handle",
                "DevAddress": "device_address",
                "MemAddress": "memory_address",
                "MemAddSize": "memory_address_size",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "start_time",
                "uVar3": "current_time",
                "pIVar4": "i2c_instance",
                "tmpreg": "temporary_register"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016f4": {
            "entrypoint": "0x080016f4",
            "current_name": "wait_for_i2_c_flag_080016f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef waitForI2CFlag_080016f4(I2C_HandleTypeDef *i2cHandle,uint32_t timeout)\n\n{\n  uint32_t startTime;\n  uint32_t currTime;\n  I2C_TypeDef *i2cInstance;\n  \n  startTime = HAL_GetTick();\n  while( true ) {\n    i2cInstance = i2cHandle->Instance;\n    if ((i2cInstance->SR1 & 0x40) != 0) {\n      return HAL_OK;\n    }\n    if ((int)(i2cInstance->SR1 << 0x1b) < 0) break;\n    if ((timeout == 0) || (currTime = HAL_GetTick(), timeout < currTime - startTime)) {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 0x20;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  i2cInstance->SR1 = i2cInstance->SR1 & 0xffffffef;\n  i2cHandle->ErrorCode = 0;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_080016f4": "wait_for_i2_c_flag_080016f4",
                "hi2c": "i2cHandle",
                "Timeout": "timeout",
                "uVar1": "startTime",
                "uVar2": "currTime",
                "pIVar3": "i2cInstance"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001754": {
            "entrypoint": "0x08001754",
            "current_name": "initialize_i2_c_08001754",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatusTypeDef initializeI2C_08001754(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t sysClkFreq;\n  uint extraRetVal;\n  uint prescaler;\n  I2C_TypeDef *i2cInstance;\n  uint clockSpeed;\n  uint prescalerValue;\n  \n  if (i2cHandle != (I2C_HandleTypeDef *)0x0) {\n    if (i2cHandle->State == HAL_I2C_STATE_RESET) {\n      i2cHandle->Lock = HAL_UNLOCKED;\n      HAL_I2C_MspInit(i2cHandle);\n    }\n    i2cHandle->State = HAL_I2C_STATE_BUSY;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n    sysClkFreq = HAL_RCC_GetPCLK1Freq();\n    clockSpeed = (i2cHandle->Init).ClockSpeed;\n    prescalerValue = sysClkFreq / 1000000;\n    prescaler = extraRetVal;\n    if (100000 < clockSpeed) {\n      prescaler = 300;\n    }\n    i2cInstance = i2cHandle->Instance;\n    if (100000 < clockSpeed) {\n      prescaler = prescalerValue * prescaler;\n    }\n    i2cInstance->CR2 = prescalerValue;\n    if (100000 < clockSpeed) {\n      prescalerValue = prescaler / 1000;\n    }\n    i2cInstance->TRISE = prescalerValue + 1;\n    if (clockSpeed < 0x186a1) {\n      sysClkFreq = sysClkFreq / (clockSpeed << 1);\n      if ((sysClkFreq & 0xfff) < 4) {\n        sysClkFreq = 4;\n      }\n    }\n    else {\n      if ((i2cHandle->Init).DutyCycle == 0) {\n        sysClkFreq = sysClkFreq / (clockSpeed * 3) | 0x8000;\n      }\n      else {\n        sysClkFreq = sysClkFreq / (clockSpeed * 0x19) | 0xc000;\n      }\n      if ((sysClkFreq & 0xfff) == 0) {\n        sysClkFreq = 1;\n      }\n    }\n    prescalerValue = (i2cHandle->Init).NoStretchMode;\n    prescaler = (i2cHandle->Init).GeneralCallMode;\n    i2cInstance->CCR = sysClkFreq;\n    i2cInstance->CR1 = prescaler | prescalerValue;\n    i2cInstance->OAR1 = (i2cHandle->Init).AddressingMode | (i2cHandle->Init).OwnAddress1;\n    i2cInstance->OAR2 = (i2cHandle->Init).DualAddressMode | (i2cHandle->Init).OwnAddress2;\n    i2cInstance->CR1 = i2cInstance->CR1 | 1;\n    i2cHandle->ErrorCode = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08001754": "initialize_i2_c_08001754",
                "hi2c": "i2cHandle",
                "uVar1": "sysClkFreq",
                "extraout_r1": "extraRetVal",
                "uVar2": "prescaler",
                "pIVar3": "i2cInstance",
                "uVar4": "clockSpeed",
                "uVar5": "prescalerValue",
                "HAL_StatusTypeDef": "StatusTypeDef"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_I2C_MspInit",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001828": {
            "entrypoint": "0x08001828",
            "current_name": "write_i2_c_memory_08001828",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nwriteI2CMemory_08001828(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint8_t *data,uint16_t dataSize,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTicks;\n  uint32_t currentTicks;\n  I2C_TypeDef *i2cInstance;\n  uint cr1Value;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_READY) {\n    if (data == (uint8_t *)0x0) {\n      return HAL_ERROR;\n    }\n    if (dataSize == 0) {\n      return HAL_ERROR;\n    }\n    startTicks = HAL_GetTick();\n    do {\n      i2cInstance = i2cHandle->Instance;\n      if ((~i2cInstance->SR2 & 2) != 0) {\n        if (i2cHandle->Lock == HAL_LOCKED) {\n          return HAL_BUSY;\n        }\n        cr1Value = i2cInstance->CR1;\n        i2cHandle->Lock = HAL_LOCKED;\n        i2cInstance->CR1 = cr1Value & 0xfffff7ff;\n        i2cHandle->State = HAL_I2C_STATE_BUSY_TX;\n        i2cHandle->Mode = HAL_I2C_MODE_MEM;\n        i2cHandle->ErrorCode = 0;\n        status = I2C_RequestMemoryWrite(i2cHandle,deviceAddress,memoryAddress,memoryAddressSize,timeout);\n        if (status != HAL_OK) {\n          i2cHandle->Lock = HAL_UNLOCKED;\n          if (i2cHandle->ErrorCode == 4) {\n            return HAL_ERROR;\n          }\n          return HAL_TIMEOUT;\n        }\n        goto LAB_080018e2;\n      }\n      currentTicks = HAL_GetTick();\n    } while (currentTicks - startTicks < 0x2711);\n    i2cHandle->Lock = HAL_UNLOCKED;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n  }\n  return HAL_BUSY;\n  while (dataSize != 0) {\nLAB_080018e2:\n    status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n    if (status != HAL_OK) goto LAB_080018ee;\n    i2cInstance = i2cHandle->Instance;\n    i2cInstance->DR = (uint)*data;\n    if ((int)(i2cInstance->SR1 << 0x1d) < 0) {\n      if ((uint16_t)(dataSize - 1) == 0) break;\n      dataSize = dataSize - 2;\n      i2cInstance->DR = (uint)data[1];\n      data = data + 2;\n    }\n    else {\n      data = data + 1;\n      dataSize = dataSize - 1;\n    }\n  }\n  status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n  if (status == HAL_OK) {\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n    i2cHandle->Lock = HAL_UNLOCKED;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    return HAL_OK;\n  }\nLAB_080018ee:\n  if (i2cHandle->ErrorCode == 4) {\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n    return HAL_ERROR;\n  }\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08001828": "write_i2_c_memory_08001828",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "pData": "data",
                "Size": "dataSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "startTicks",
                "uVar3": "currentTicks",
                "pIVar4": "i2cInstance",
                "uVar5": "cr1Value"
            },
            "calling": [
                "I2C_WriteByte"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_RequestMemoryWrite",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001938": {
            "entrypoint": "0x08001938",
            "current_name": "read_from_i2_c_memory_08001938",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nreadFromI2CMemory_08001938(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint8_t *data,uint16_t dataSize,uint32_t timeout)\n\n{\n  uint8_t *ptr1;\n  HAL_StatusTypeDef status;\n  uint32_t currentTime;\n  uint32_t startTime;\n  I2C_TypeDef *i2cInstance;\n  uint value;\n  uint8_t *ptr2;\n  bool flag;\n  uint32_t tmpReg;\n  uint32_t tmpReg1;\n  uint32_t tmpReg2;\n  \n  if (i2cHandle->State != HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (data == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (dataSize == 0) {\n    return HAL_ERROR;\n  }\n  currentTime = HAL_GetTick();\n  while (i2cInstance = i2cHandle->Instance, (~i2cInstance->SR2 & 2) == 0) {\n    startTime = HAL_GetTick();\n    if (10000 < startTime - currentTime) {\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      return HAL_BUSY;\n    }\n  }\n  if (i2cHandle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  value = i2cInstance->CR1;\n  i2cHandle->Lock = HAL_LOCKED;\n  i2cInstance->CR1 = value & 0xfffff7ff;\n  i2cHandle->State = HAL_I2C_STATE_BUSY_RX;\n  i2cHandle->Mode = HAL_I2C_MODE_MEM;\n  i2cHandle->ErrorCode = 0;\n  status = I2C_RequestMemoryRead(i2cHandle,deviceAddress,memoryAddress,memoryAddressSize,timeout);\n  if (status != HAL_OK) {\n    i2cHandle->Lock = HAL_UNLOCKED;\n    if (i2cHandle->ErrorCode == 4) {\n      return HAL_ERROR;\n    }\n    return HAL_TIMEOUT;\n  }\n  i2cInstance = i2cHandle->Instance;\n  value = i2cInstance->CR1;\n  if (dataSize == 1) {\n    i2cInstance->CR1 = value & 0xfffffbff;\n    disableIRQinterrupts();\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n    enableIRQinterrupts();\n    status = I2C_WaitOnRXNEFlagUntiltimeout(i2cHandle,timeout);\n    if (status == HAL_OK) {\n      *data = (uint8_t)i2cHandle->Instance->DR;\nLAB_08001ab8:\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_OK;\n    }\nLAB_08001a18:\n    if (i2cHandle->ErrorCode != 0x20) {\n      return HAL_ERROR;\n    }\n    return HAL_TIMEOUT;\n  }\n  if (dataSize == 2) {\n    i2cInstance->CR1 = value | 0x800;\n    disableIRQinterrupts();\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    enableIRQinterrupts();\n  }\n  else {\n    i2cInstance->CR1 = value | 0x400;\n    while (3 < dataSize) {\n      status = I2C_WaitOnRXNEFlagUntiltimeout(i2cHandle,timeout);\n      if (status != HAL_OK) goto LAB_08001a18;\n      *data = (uint8_t)i2cHandle->Instance->DR;\n      i2cInstance = i2cHandle->Instance;\n      flag = (int)(i2cInstance->SR1 << 0x1d) < 0;\n      if (flag) {\n        i2cInstance = (I2C_TypeDef *)i2cInstance->DR;\n        ptr2 = data + 2;\n        dataSize = dataSize - 2;\n      }\n      else {\n        ptr2 = data + 1;\n        dataSize = dataSize - 1;\n      }\n      ptr1 = data + 1;\n      data = ptr2;\n      if (flag) {\n        *ptr1 = (uint8_t)i2cInstance;\n      }\n    }\n    if (dataSize != 2) {\n      currentTime = HAL_GetTick();\n      do {\n        i2cInstance = i2cHandle->Instance;\n        do {\n          if ((int)(i2cInstance->SR1 << 0x1d) < 0) {\n            i2cInstance->CR1 = i2cInstance->CR1 & 0xfffffbff;\n            disableIRQinterrupts();\n            *data = (uint8_t)i2cHandle->Instance->DR;\n            currentTime = HAL_GetTick();\n            goto LAB_08001b3a;\n          }\n        } while (timeout == 0xffffffff);\n      } while ((timeout != 0) && (startTime = HAL_GetTick(), startTime - currentTime <= timeout));\n      goto LAB_08001afa;\n    }\n  }\n  currentTime = HAL_GetTick();\n  do {\n    do {\n      if ((int)(i2cHandle->Instance->SR1 << 0x1d) < 0) {\n        disableIRQinterrupts();\n        i2cInstance = i2cHandle->Instance;\n        i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n        *data = (uint8_t)i2cInstance->DR;\n        enableIRQinterrupts();\n        data[1] = (uint8_t)i2cHandle->Instance->DR;\n        goto LAB_08001ab8;\n      }\n    } while (timeout == 0xffffffff);\n  } while ((timeout != 0) && (startTime = HAL_GetTick(), startTime - currentTime <= timeout));\nLAB_08001afa:\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\nLAB_08001b3a:\n  do {\n    i2cInstance = i2cHandle->Instance;\n    do {\n      if ((int)(i2cInstance->SR1 << 0x1d) < 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n        data[1] = (uint8_t)i2cInstance->DR;\n        enableIRQinterrupts();\n        data[2] = (uint8_t)i2cHandle->Instance->DR;\n        goto LAB_08001ab8;\n      }\n    } while (timeout == 0xffffffff);\n  } while ((timeout != 0) && (startTime = HAL_GetTick(), startTime - currentTime <= timeout));\n  goto LAB_08001afa;\n}\n\n",
            "renaming": {
                "FUN_08001938": "read_from_i2_c_memory_08001938",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "pData": "data",
                "Size": "dataSize",
                "Timeout": "timeout",
                "puVar1": "ptr1",
                "HVar2": "status",
                "uVar3": "currentTime",
                "uVar4": "startTime",
                "pIVar5": "i2cInstance",
                "uVar6": "value",
                "puVar7": "ptr2",
                "bVar8": "flag",
                "tmpreg": "tmpReg",
                "tmpreg_1": "tmpReg1",
                "tmpreg_2": "tmpReg2"
            },
            "calling": [
                "I2C_ReadByte",
                "I2C_ReadBytes"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_RequestMemoryRead",
                "I2C_WaitOnRXNEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b58": {
            "entrypoint": "0x08001b58",
            "current_name": "initialize_rcc_oscillators_08001b58",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001eec) initializeRCCOscillators_08001b58\n/* WARNING: Removing unreachable block (ram,0x08001ee8) initializeRCCOscillators_08001b58\n\n/* WARNING: Unknown calling convention initializeRCCOscillators_08001b58\n\nHAL_StatusTypeDef initializeRCCOscillators_08001b58(RCCOscInit *oscInit)\n\n{\n  unsignedInt tempVar1;\n  unsignedInt tempVar2;\n  uint tempVar3;\n  unsignedInt tempReg;\n  \n  if ((int)(oscInit->OscillatorType << 0x1f) < 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((int)(_DAT_40021004 << 0xf) < 0)))) {\n      if (((int)((_DAT_40021000 >> 0x11) << 0x1f) < 0) && (oscInit->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      tempVar1 = oscInit->HSEState;\n      if (tempVar1 == 0x10000) {\nLAB_08001c1e:\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else {\n        if (tempVar1 == 0) {\n          _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n          tempVar1 = getTickCount();\n          while ((int)((_DAT_40021000 >> 0x11) << 0x1f) < 0) {\n            tempVar2 = getTickCount();\n            if (100 < tempVar2 - tempVar1) {\n              return HAL_TIMEOUT;\n            }\n          }\n          goto LAB_08001b64;\n        }\n        if (tempVar1 == 0x50000) {\n          _DAT_40021000 = _DAT_40021000 | 0x40000;\n          goto LAB_08001c1e;\n        }\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      tempVar1 = getTickCount();\n      while (-1 < (int)((_DAT_40021000 >> 0x11) << 0x1f)) {\n        tempVar2 = getTickCount();\n        if (100 < tempVar2 - tempVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\nLAB_08001b64:\n  if ((int)(oscInit->OscillatorType << 0x1e) < 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && (-1 < (int)(_DAT_40021004 << 0xf))))) {\n      if (((int)((_DAT_40021000 >> 1) << 0x1f) < 0) && (oscInit->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      uRam42420000 = oscInit->HSIState;\n      if (uRam42420000 == 0) {\n        tempVar1 = getTickCount();\n        while ((int)((_DAT_40021000 >> 1) << 0x1f) < 0) {\n          tempVar2 = getTickCount();\n          if (2 < tempVar2 - tempVar1) {\n            return HAL_TIMEOUT;\n          }\n        }\n        goto LAB_08001b6c;\n      }\n      uRam42420000 = 1;\n      tempVar1 = getTickCount();\n      while (-1 < (int)((_DAT_40021000 >> 1) << 0x1f)) {\n        tempVar2 = getTickCount();\n        if (2 < tempVar2 - tempVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    _DAT_40021000 = oscInit->HSICalibrationValue << 3 | _DAT_40021000 & 0xffffff07;\n  }\nLAB_08001b6c:\n  if ((int)(oscInit->OscillatorType << 0x1c) < 0) {\n    uRam42420480 = oscInit->LSIState;\n    if (uRam42420480 == 0) {\n      tempVar1 = getTickCount();\n      while ((int)((_DAT_40021024 >> 1) << 0x1f) < 0) {\n        tempVar2 = getTickCount();\n        if (2 < tempVar2 - tempVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      uRam42420480 = 1;\n      tempVar1 = getTickCount();\n      while (-1 < (int)((_DAT_40021024 >> 1) << 0x1f)) {\n        tempVar2 = getTickCount();\n        if (2 < tempVar2 - tempVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n      delay(1);\n    }\n  }\n  if (-1 < (int)(oscInit->OscillatorType << 0x1d)) goto LAB_08001bc2;\n  _DAT_4002101c = _DAT_4002101c | 0x10000000;\n  _DAT_40007000 = _DAT_40007000 | 0x100;\n  tempVar1 = getTickCount();\n  while (-1 < (int)(_DAT_40007000 << 0x17)) {\n    tempVar2 = getTickCount();\n    if (100 < tempVar2 - tempVar1) {\n      return HAL_TIMEOUT;\n    }\n  }\n  tempVar1 = oscInit->LSEState;\n  if (tempVar1 == 1) {\nLAB_08001e1a:\n    _DAT_40021020 = _DAT_40021020 | 1;\n  }\n  else {\n    if (tempVar1 == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n      tempVar1 = getTickCount();\n      while ((int)((_DAT_40021020 >> 1) << 0x1f) < 0) {\n        tempVar2 = getTickCount();\n        if (5000 < tempVar2 - tempVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n      goto LAB_08001bc2;\n    }\n    if (tempVar1 == 5) {\n      _DAT_40021020 = _DAT_40021020 | 4;\n      goto LAB_08001e1a;\n    }\n    _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n  }\n  tempVar1 = getTickCount();\n  while (-1 < (int)((_DAT_40021020 >> 1) << 0x1f)) {\n    tempVar2 = getTickCount();\n    if (5000 < tempVar2 - tempVar1) {\n      return HAL_TIMEOUT;\n    }\n  }\nLAB_08001bc2:\n  tempVar1 = (oscInit->PLL).PLLState;\n  if (tempVar1 == 0) {\n    return HAL_OK;\n  }\n  if ((_DAT_40021004 & 0xc) != 8) {\n    if (tempVar1 != 2) {\n      pllConfigured = 0;\n      tempVar1 = getTickCount();\n      do {\n        if (-1 < (int)((_DAT_40021000 >> 0x19) << 0x1f)) {\n          return HAL_OK;\n        }\n        tempVar2 = getTickCount();\n      } while (tempVar2 - tempVar1 < 3);\n      return HAL_TIMEOUT;\n    }\n    pllConfigured = 0;\n    tempVar1 = getTickCount();\n    do {\n      if (-1 < (int)((_DAT_40021000 >> 0x19) << 0x1f)) {\n        tempVar3 = (oscInit->PLL).PLLSource;\n        if (tempVar3 == 0x10000) {\n          _DAT_40021004 = _DAT_40021004 & 0xfffdffff | oscInit->HSEPredivValue;\n        }\n        _DAT_40021004 = tempVar3 | (oscInit->PLL).PLLMultiplier | _DAT_40021004 & 0xffc2ffff;\n        pllConfigured = 1;\n        tempVar1 = getTickCount();\n        do {\n          if ((int)((_DAT_40021000 >> 0x19) << 0x1f) < 0) {\n            return HAL_OK;\n          }\n          tempVar2 = getTickCount();\n        } while (tempVar2 - tempVar1 < 3);\n        return HAL_TIMEOUT;\n      }\n      tempVar2 = getTickCount();\n    } while (tempVar2 - tempVar1 < 3);\n    return HAL_TIMEOUT;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08001b58": "initialize_rcc_oscillators_08001b58",
                "RCC_OscInitTypeDef": "RCCOscInit",
                "RCC_OscInitStruct": "oscInit",
                "uint32_t": "unsignedInt",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "uVar3": "tempVar3",
                "tmpreg": "tempReg",
                "HAL_GetTick": "getTickCount",
                "HAL_Delay": "delay",
                "PLLMUL": "PLLMultiplier",
                "uRam42420060": "pllConfigured"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002008": {
            "entrypoint": "0x08002008",
            "current_name": "calculate_clock_frequency_08002008",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateClockFrequency_08002008(void)\n\n{\n  undefined4 pllMulFactor;\n  uint32_t clockFrequency;\n  undefined4 predivFactor;\n  undefined4 *factorTablePtr;\n  uint predivValue;\n  undefined4 *mulFactorTablePtr;\n  uint8_t predivFactorTable [2];\n  uint8_t mulFactorTable [16];\n  \n  factorTablePtr = &DAT_080072f0;\n  mulFactorTablePtr = (undefined4 *)mulFactorTable;\n  do {\n    pllMulFactor = *factorTablePtr;\n    predivFactor = factorTablePtr[1];\n    factorTablePtr = factorTablePtr + 2;\n    *mulFactorTablePtr = pllMulFactor;\n    mulFactorTablePtr[1] = predivFactor;\n    mulFactorTablePtr = mulFactorTablePtr + 2;\n  } while (factorTablePtr != (undefined4 *)\"../Src/MPU9250.c\");\n  predivFactorTable[0] = '\\x01';\n  predivFactorTable[1] = '\\x02';\n  if ((_DAT_40021004 & 0xc) == 8) {\n    if ((int)(_DAT_40021004 << 0xf) < 0) {\n      predivValue = 8000000 / predivFactorTable[(_DAT_40021004 & 0x20000) >> 0x11];\n    }\n    else {\n      predivValue = 4000000;\n    }\n    clockFrequency = predivValue * mulFactorTable[(_DAT_40021004 & 0x3c0000) >> 0x12];\n  }\n  else {\n    clockFrequency = 8000000;\n  }\n  return clockFrequency;\n}\n\n",
            "renaming": {
                "FUN_08002008": "calculate_clock_frequency_08002008",
                "uVar1": "pllMulFactor",
                "uVar2": "clockFrequency",
                "uVar3": "predivFactor",
                "puVar4": "factorTablePtr",
                "uVar5": "predivValue",
                "puVar6": "mulFactorTablePtr",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "mulFactorTable"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800209c": {
            "entrypoint": "0x0800209c",
            "current_name": "configure_system_clock_0800209c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nStatusTypeDef configureSystemClock_0800209c(RCC_ClkInitTypeDef *clockInitStruct,uint32_t latency)\n\n{\n  char cVar1;\n  char cVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  uint uVar5;\n  \n  if ((latency <= (_DAT_40022000 & 7)) ||\n     (_DAT_40022000 = _DAT_40022000 & 0xfffffff8 | latency, latency == (latency & 7))) {\n    if ((int)(clockInitStruct->ClockType << 0x1e) < 0) {\n      _DAT_40021004 = _DAT_40021004 & 0xffffff0f | clockInitStruct->AHBCLKDivider;\n    }\n    if (-1 < (int)(clockInitStruct->ClockType << 0x1f)) {\nLAB_080020ba:\n      if ((latency < (_DAT_40022000 & 7)) &&\n         (_DAT_40022000 = _DAT_40022000 & 0xfffffff8 | latency, latency != (latency & 7))) {\n        return HAL_ERROR;\n      }\n      if ((clockInitStruct->ClockType & 4) != 0) {\n        _DAT_40021004 = _DAT_40021004 & 0xfffff8ff | clockInitStruct->APB1CLKDivider;\n      }\n      if ((int)(clockInitStruct->ClockType << 0x1c) < 0) {\n        _DAT_40021004 = _DAT_40021004 & 0xffffc7ff | clockInitStruct->APB2CLKDivider << 3;\n      }\n      uVar3 = HAL_RCC_GetSysClockFreq();\n      systemCoreClock = uVar3 >> \"\"[(_DAT_40021004 & 0xf0) >> 4];\n      HAL_InitTick(0);\n      return HAL_OK;\n    }\n    uVar5 = clockInitStruct->SYSCLKSource;\n    if (uVar5 == 1) {\n      cVar2 = '\\x01';\n      cVar1 = '\\0';\n    }\n    else {\n      if (uVar5 == 2) goto LAB_08002176;\n      cVar2 = '\\0';\n      cVar1 = '\\x01';\n    }\n    if ((int)((_DAT_40021000 >>\n              (LZCOUNT((uint)(byte)(cVar1 << 6) << 0x18 | (uint)(byte)(cVar2 << 6) << 8) & 0x1fU))\n             << 0x1f) < 0) {\nLAB_08002176:\n      _DAT_40021004 = _DAT_40021004 & 0xfffffffc | uVar5;\n      uVar3 = HAL_GetTick();\n      if (clockInitStruct->SYSCLKSource == 1) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 4) goto LAB_080020ba;\n          uVar4 = HAL_GetTick();\n        } while (uVar4 - uVar3 < 0x1389);\n      }\n      else if (clockInitStruct->SYSCLKSource == 2) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 8) goto LAB_080020ba;\n          uVar4 = HAL_GetTick();\n        } while (uVar4 - uVar3 < 0x1389);\n      }\n      else {\n        do {\n          if ((_DAT_40021004 & 0xc) == 0) goto LAB_080020ba;\n          uVar4 = HAL_GetTick();\n        } while (uVar4 - uVar3 < 0x1389);\n      }\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_0800209c": "configure_system_clock_0800209c",
                "RCC_ClkInitStruct": "clockInitStruct",
                "FLatency": "latency",
                "HAL_StatusTypeDef": "StatusTypeDef",
                "SystemCoreClock": "systemCoreClock"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_GetTick",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002214": {
            "entrypoint": "0x08002214",
            "current_name": "get_system_core_clock_08002214",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_08002214(void)\n\n{\n  return systemClock;\n}\n\n",
            "renaming": {
                "FUN_08002214": "get_system_core_clock_08002214",
                "SystemCoreClock": "systemClock"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002220": {
            "entrypoint": "0x08002220",
            "current_name": "get_system_core_clock_divided_by_config_08002220",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClockDividedByConfig_08002220(void)\n\n{\n  return systemClockFrequency >> \"\"[(_DAT_40021004 & 0x700) >> 8];\n}\n\n",
            "renaming": {
                "FUN_08002220": "get_system_core_clock_divided_by_config_08002220",
                "SystemCoreClock": "systemClockFrequency"
            },
            "calling": [
                "HAL_I2C_Init",
                "UART_SetConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002250": {
            "entrypoint": "0x08002250",
            "current_name": "get_clock_speed_08002250",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getClockSpeed_08002250(void)\n\n{\n  return clockSpeed >> \"\"[(_DAT_40021004 & 0x3800) >> 0xb];\n}\n\n",
            "renaming": {
                "FUN_08002250": "get_clock_speed_08002250",
                "SystemCoreClock": "clockSpeed"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002280": {
            "entrypoint": "0x08002280",
            "current_name": "configure_timer_08002280",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimer_08002280(Timer_TypeDef *timer,TIM_OC_InitTypeDef *ocConfig)\n\n{\n  uint32_t ccerValue;\n  uint32_t cr2Value;\n  uint ocMode;\n  \n  timer->CCER = timer->CCER & 0xfffffffe;\n  cr2Value = timer->CR2;\n  ocMode = ocConfig->OCMode;\n  ccerValue = timer->CCER & 0xfffffffd | ocConfig->OCPolarity;\n  if (timer == (Timer_TypeDef *)0x40012c00) {\n    ccerValue = (ccerValue & 0xfffffff7 | ocConfig->OCNPolarity) & 0xfffffffb;\n    cr2Value = cr2Value & 0xfffffcff | ocConfig->OCIdleState | ocConfig->OCNIdleState;\n  }\n  timer->CR2 = cr2Value;\n  timer->CCMR1 = timer->CCMR1 & 0xffffff8c | ocMode;\n  timer->CCR1 = ocConfig->Pulse;\n  timer->CCER = ccerValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002280": "configure_timer_08002280",
                "TIMx": "timer",
                "OC_Config": "ocConfig",
                "uVar1": "ccerValue",
                "uVar2": "cr2Value",
                "uVar3": "ocMode",
                "TIM_TypeDef": "Timer_TypeDef"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080022d0": {
            "entrypoint": "0x080022d0",
            "current_name": "configure_timer_output_080022d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerOutput_080022d0(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputConfig)\n\n{\n  uint32_t ccerBitmask;\n  uint32_t cr2Value;\n  uint ocModeValue;\n  \n  timer->CCER = timer->CCER & 0xfffffeff;\n  cr2Value = timer->CR2;\n  ocModeValue = outputConfig->OCMode;\n  ccerBitmask = timer->CCER & 0xfffffdff | outputConfig->OCPolarity << 8;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    ccerBitmask = (ccerBitmask & 0xfffff7ff | outputConfig->OCNPolarity << 8) & 0xfffffbff;\n    cr2Value = cr2Value & 0xffffcfff | (outputConfig->OCIdleState | outputConfig->OCNIdleState) << 4;\n  }\n  timer->CR2 = cr2Value;\n  timer->CCMR2 = timer->CCMR2 & 0xffffff8c | ocModeValue;\n  timer->CCR3 = outputConfig->Pulse;\n  timer->CCER = ccerBitmask;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080022d0": "configure_timer_output_080022d0",
                "TIMx": "timer",
                "OC_Config": "outputConfig",
                "uVar1": "ccerBitmask",
                "uVar2": "cr2Value",
                "uVar3": "ocModeValue"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002324": {
            "entrypoint": "0x08002324",
            "current_name": "configure_tim_output_compare_08002324",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimOutputCompare_08002324(TIM_TypeDef *timInstance,TIM_OC_InitTypeDef *outputCompareConfig)\n\n{\n  uint32_t cr2Value;\n  uint32_t ocModeValue;\n  uint32_t ocPolarityValue;\n  uint32_t ocIdleStateValue;\n  \n  timInstance->CCER = timInstance->CCER & 0xffffefff;\n  cr2Value = timInstance->CR2;\n  ocModeValue = outputCompareConfig->OCMode;\n  ocPolarityValue = outputCompareConfig->OCPolarity;\n  ocIdleStateValue = 0x40012c00;\n  if (timInstance == (TIM_TypeDef *)0x40012c00) {\n    ocIdleStateValue = outputCompareConfig->OCIdleState;\n    cr2Value = cr2Value & 0xffffbfff;\n  }\n  if (timInstance == (TIM_TypeDef *)0x40012c00) {\n    cr2Value = cr2Value | ocIdleStateValue << 6;\n  }\n  timInstance->CR2 = cr2Value;\n  timInstance->CCMR2 = timInstance->CCMR2 & 0xffff8cff | ocModeValue << 8;\n  timInstance->CCR4 = outputCompareConfig->Pulse;\n  timInstance->CCER = timInstance->CCER & 0xffffdfff | ocPolarityValue << 0xc;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002324": "configure_tim_output_compare_08002324",
                "TIMx": "timInstance",
                "OC_Config": "outputCompareConfig",
                "uVar1": "cr2Value",
                "uVar2": "ocModeValue",
                "uVar3": "ocPolarityValue",
                "uVar4": "ocIdleStateValue"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002368": {
            "entrypoint": "0x08002368",
            "current_name": "initialize_timer_08002368",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimer_08002368(TIM_TypeDef *timer,TIM_Base_InitTypeDef *timerConfig)\n\n{\n  uint32_t modifiedFlags;\n  \n  modifiedFlags = timer->CR1;\n  if (((((timer == (TIM_TypeDef *)0x40012c00) || (timer == (TIM_TypeDef *)0x40000000)) ||\n       (timer == (TIM_TypeDef *)0x40000400)) || (timer == (TIM_TypeDef *)0x40000800)) &&\n     (((modifiedFlags = modifiedFlags & 0xffffff8f | timerConfig->CounterMode, timer == (TIM_TypeDef *)0x40012c00 ||\n       (timer == (TIM_TypeDef *)0x40000000)) ||\n      ((timer == (TIM_TypeDef *)0x40000400 || (timer == (TIM_TypeDef *)0x40000800)))))) {\n    modifiedFlags = modifiedFlags & 0xfffffcff | timerConfig->ClockDivision;\n  }\n  timer->CR1 = modifiedFlags;\n  timer->ARR = timerConfig->Period;\n  timer->PSC = timerConfig->Prescaler;\n  modifiedFlags = 0x40012c00;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    modifiedFlags = timerConfig->RepetitionCounter;\n  }\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    timer->RCR = modifiedFlags;\n  }\n  timer->EGR = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002368": "initialize_timer_08002368",
                "TIMx": "timer",
                "Structure": "timerConfig",
                "uVar1": "modifiedFlags"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080023d0": {
            "entrypoint": "0x080023d0",
            "current_name": "initialize_tim_080023d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeTIM_080023d0(TIM_HandleTypeDef *timer)\n\n{\n  if (timer != (TIM_HandleTypeDef *)0x0) {\n    if (timer->State == timerStateReset) {\n      timer->Lock = unlocked;\n      initializePWM(timer);\n    }\n    timer->State = timerStateBusy;\n    setTimerConfig(timer->timerInstance,&timer->timerInit);\n    timer->State = timerStateReady;\n    return statusOK;\n  }\n  return statusError;\n}\n\n",
            "renaming": {
                "FUN_080023d0": "initialize_tim_080023d0",
                "htim": "timer",
                "HAL_TIM_STATE_RESET": "timerStateReset",
                "HAL_UNLOCKED": "unlocked",
                "HAL_TIM_STATE_BUSY": "timerStateBusy",
                "HAL_TIM_STATE_READY": "timerStateReady",
                "HAL_OK": "statusOK",
                "HAL_ERROR": "statusError",
                "HAL_TIM_PWM_MspInit": "initializePWM",
                "TIM_Base_SetConfig": "setTimerConfig",
                "Instance": "timerInstance",
                "Init": "timerInit"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "TIM_Base_SetConfig",
                "HAL_TIM_PWM_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002404": {
            "entrypoint": "0x08002404",
            "current_name": "configure_timers_08002404",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimers_08002404(TIM_TypeDef *timer,TIM_OC_InitTypeDef *ocConfig)\n\n{\n  uint32_t ccerValue;\n  uint32_t cr2Value;\n  uint32_t ocModeValue;\n  \n  timer->CCER = timer->CCER & 0xffffffef;\n  cr2Value = timer->CR2;\n  ocModeValue = ocConfig->OCMode;\n  ccerValue = timer->CCER & 0xffffffdf | ocConfig->OCPolarity << 4;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    ccerValue = (ccerValue & 0xffffff7f | ocConfig->OCNPolarity << 4) & 0xffffffbf;\n    cr2Value = cr2Value & 0xfffff3ff | (ocConfig->OCIdleState | ocConfig->OCNIdleState) << 2;\n  }\n  timer->CR2 = cr2Value;\n  timer->CCMR1 = timer->CCMR1 & 0xffff8cff | ocModeValue << 8;\n  timer->CCR2 = ocConfig->Pulse;\n  timer->CCER = ccerValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002404": "configure_timers_08002404",
                "TIMx": "timer",
                "OC_Config": "ocConfig",
                "uVar1": "ccerValue",
                "uVar2": "cr2Value",
                "uVar3": "ocModeValue"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800245c": {
            "entrypoint": "0x0800245c",
            "current_name": "configure_timer_output_compare_0800245c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureTimerOutputCompare_0800245c(TIM_HandleTypeDef *timerHandle,TIM_OC_InitTypeDef *outputCompareConfig,uint32_t channel)\n\n{\n  int extraOut1;\n  int extraOut2;\n  int extraOut3;\n  uint tempVar1;\n  int extraOut4;\n  int tempVar2;\n  uint32_t tempVar3;\n  TIM_TypeDef *timerInstance;\n  \n  if (timerHandle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  timerHandle->State = HAL_TIM_STATE_BUSY;\n  timerHandle->Lock = HAL_LOCKED;\n  switch(channel) {\n  case 0:\n    TIM_OC1_SetConfig(timerHandle->Instance,outputCompareConfig);\n    timerInstance = timerHandle->Instance;\n    tempVar1 = *(uint *)(extraOut1 + 0x10);\n    timerInstance->CCMR1 = timerInstance->CCMR1 | 8;\n    timerInstance->CCMR1 = timerInstance->CCMR1 & 0xfffffffb;\n    tempVar3 = timerInstance->CCMR1 | tempVar1;\n    break;\n  default:\n    goto switchD_0800247a_caseD_1;\n  case 4:\n    TIM_OC2_SetConfig(timerHandle->Instance,outputCompareConfig);\n    timerInstance = timerHandle->Instance;\n    tempVar2 = *(int *)(extraOut2 + 0x10);\n    timerInstance->CCMR1 = timerInstance->CCMR1 | 0x800;\n    timerInstance->CCMR1 = timerInstance->CCMR1 & 0xfffffbff;\n    tempVar3 = timerInstance->CCMR1 | tempVar2 << 8;\n    break;\n  case 8:\n    TIM_OC3_SetConfig(timerHandle->Instance,outputCompareConfig);\n    timerInstance = timerHandle->Instance;\n    tempVar1 = *(uint *)(extraOut3 + 0x10);\n    timerInstance->CCMR2 = timerInstance->CCMR2 | 8;\n    timerInstance->CCMR2 = timerInstance->CCMR2 & 0xfffffffb;\n    tempVar3 = timerInstance->CCMR2 | tempVar1;\n    goto LAB_080024fa;\n  case 0xc:\n    TIM_OC4_SetConfig(timerHandle->Instance,outputCompareConfig);\n    timerInstance = timerHandle->Instance;\n    tempVar2 = *(int *)(extraOut4 + 0x10);\n    timerInstance->CCMR2 = timerInstance->CCMR2 | 0x800;\n    timerInstance->CCMR2 = timerInstance->CCMR2 & 0xfffffbff;\n    tempVar3 = timerInstance->CCMR2 | tempVar2 << 8;\nLAB_080024fa:\n    timerInstance->CCMR2 = tempVar3;\n    goto switchD_0800247a_caseD_1;\n  }\n  timerInstance->CCMR1 = tempVar3;\nswitchD_0800247a_caseD_1:\n  timerHandle->State = HAL_TIM_STATE_READY;\n  timerHandle->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800245c": "configure_timer_output_compare_0800245c",
                "htim": "timerHandle",
                "sConfig": "outputCompareConfig",
                "Channel": "channel",
                "extraout_r1": "extraOut1",
                "extraout_r1_00": "extraOut2",
                "extraout_r1_01": "extraOut3",
                "extraout_r1_02": "extraOut4",
                "uVar1": "tempVar1",
                "iVar2": "tempVar2",
                "uVar3": "tempVar3",
                "pTVar4": "timerInstance"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC2_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002520": {
            "entrypoint": "0x08002520",
            "current_name": "update_channel_state_08002520",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateChannelState_08002520(TIM_TypeDef *timer,uint32_t channel,uint32_t channelState)\n\n{\n  timer->CCER = timer->CCER & ~(1 << (channel & 0xff));\n  timer->CCER = channelState << (channel & 0xff) | timer->CCER;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002520": "update_channel_state_08002520",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "channelState"
            },
            "calling": [
                "HAL_TIM_PWM_Start"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002538": {
            "entrypoint": "0x08002538",
            "current_name": "configure_timer_channel_08002538",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureTimerChannel_08002538(TIM_HandleTypeDef *timerHandle,uint32_t channel)\n\n{\n  uint32_t initialValue;\n  TIM_TypeDef *timerInstance;\n  \n  TIM_CCxchannelCmd(timerHandle->Instance,channel,1);\n  timerInstance = timerHandle->Instance;\n  initialValue = 0x40012c00;\n  if (timerInstance == (TIM_TypeDef *)0x40012c00) {\n    initialValue = uRam40012c44 | 0x8000;\n  }\n  if (timerInstance == (TIM_TypeDef *)0x40012c00) {\n    timerInstance->BDTR = initialValue;\n  }\n  timerInstance->CR1 = timerInstance->CR1 | 1;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002538": "configure_timer_channel_08002538",
                "htim": "timerHandle",
                "Channel": "channel",
                "uVar1": "initialValue",
                "pTVar2": "timerInstance"
            },
            "calling": [
                "PWM_Init"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002564": {
            "entrypoint": "0x08002564",
            "current_name": "configure_break_dead_time_08002564",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nconfigureBreakDeadTime_08002564(TIM_HandleTypeDef *timer,TIM_BreakDeadTimeConfigTypeDef *breakDeadTimeConfig)\n\n{\n  HAL_StatusTypeDef status;\n  \n  status = BUSY;\n  if (timer->Lock != LOCKED) {\n    timer->State = STATE_BUSY;\n    timer->Instance->BDTR =\n         breakDeadTimeConfig->OffStateRunMode | breakDeadTimeConfig->OffStateIDLEMode |\n         breakDeadTimeConfig->LockLevel | breakDeadTimeConfig->DeadTime |\n         breakDeadTimeConfig->BreakState | breakDeadTimeConfig->BreakPolarity |\n         breakDeadTimeConfig->AutomaticOutput;\n    timer->State = STATE_READY;\n    status = OK;\n    timer->Lock = UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002564": "configure_break_dead_time_08002564",
                "htim": "timer",
                "sBreakDeadTimeConfig": "breakDeadTimeConfig",
                "HVar1": "status",
                "HAL_BUSY": "BUSY",
                "HAL_LOCKED": "LOCKED",
                "HAL_TIM_STATE_BUSY": "STATE_BUSY",
                "HAL_TIM_STATE_READY": "STATE_READY",
                "HAL_OK": "OK",
                "HAL_UNLOCKED": "UNLOCKED"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025a4": {
            "entrypoint": "0x080025a4",
            "current_name": "configure_master_config_080025a4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureMasterConfig_080025a4(TIM_HandleTypeDef *timerHandle,TIM_MasterConfigTypeDef *masterConfig)\n\n{\n  uint slaveMode;\n  HAL_StatusTypeDef status;\n  TIM_TypeDef *timerInstance;\n  uint outputTrigger;\n  \n  status = HAL_BUSY;\n  if (timerHandle->Lock != HAL_LOCKED) {\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    timerInstance = timerHandle->Instance;\n    outputTrigger = masterConfig->MasterOutputTrigger;\n    slaveMode = masterConfig->MasterSlaveMode;\n    timerInstance->CR2 = timerInstance->CR2 & 0xffffff8f;\n    timerInstance->CR2 = timerInstance->CR2 | outputTrigger;\n    timerInstance->SMCR = timerInstance->SMCR & 0xffffff7f;\n    timerInstance->SMCR = timerInstance->SMCR | slaveMode;\n    timerHandle->State = HAL_TIM_STATE_READY;\n    status = HAL_OK;\n    timerHandle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080025a4": "configure_master_config_080025a4",
                "htim": "timerHandle",
                "sMasterConfig": "masterConfig",
                "HVar2": "status",
                "pTVar3": "timerInstance",
                "uVar4": "outputTrigger",
                "uVar1": "slaveMode"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025e8": {
            "entrypoint": "0x080025e8",
            "current_name": "initialize_uart_080025e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_uart_080025e8(UART_HandleTypeDef *uart_handle)\n\n{\n  uint32_t freq1;\n  uint32_t freq2;\n  uint parity;\n  int baudrate_divisor;\n  uint32_t baudrate;\n  int baudrate_calibration;\n  usart_type_def *usart_instance;\n  \n  usart_instance = uart_handle->Instance;\n  parity = (uart_handle->Init).Parity;\n  usart_instance->CR2 = usart_instance->CR2 & 0xffffcfff | (uart_handle->Init).StopBits;\n  usart_instance->CR1 = (uart_handle->Init).WordLength | parity | (uart_handle->Init).Mode | usart_instance->CR1 & 0xffffe9f3;\n  usart_instance->CR3 = usart_instance->CR3 & 0xfffffcff | (uart_handle->Init).HwFlowCtl;\n  if (usart_instance == (usart_type_def *)0x40013800) {\n    freq1 = HAL_RCC_GetPCLK2Freq();\n    baudrate_divisor = (int)(((ulonglong)(freq1 * 0x19) / (ulonglong)((uart_handle->Init).BaudRate << 2)) / 100);\n    freq1 = HAL_RCC_GetPCLK2Freq();\n    baudrate = (uart_handle->Init).BaudRate;\n    freq2 = HAL_RCC_GetPCLK2Freq();\n    baudrate_calibration = (freq1 * 0x19) / (baudrate << 2) +\n            (int)(((ulonglong)(freq2 * 0x19) / (ulonglong)((uart_handle->Init).BaudRate << 2)) / 100) *\n            -100;\n    freq1 = HAL_RCC_GetPCLK2Freq();\n    parity = (freq1 * 0x19) / ((uart_handle->Init).BaudRate << 2);\n    freq1 = HAL_RCC_GetPCLK2Freq();\n  }\n  else {\n    freq1 = HAL_RCC_GetPCLK1Freq();\n    baudrate_divisor = (int)(((ulonglong)(freq1 * 0x19) / (ulonglong)((uart_handle->Init).BaudRate << 2)) / 100);\n    freq1 = HAL_RCC_GetPCLK1Freq();\n    baudrate = (uart_handle->Init).BaudRate;\n    freq2 = HAL_RCC_GetPCLK1Freq();\n    baudrate_calibration = (freq1 * 0x19) / (baudrate << 2) +\n            (int)(((ulonglong)(freq2 * 0x19) / (ulonglong)((uart_handle->Init).BaudRate << 2)) / 100) *\n            -100;\n    freq1 = HAL_RCC_GetPCLK1Freq();\n    parity = (freq1 * 0x19) / ((uart_handle->Init).BaudRate << 2);\n    freq1 = HAL_RCC_GetPCLK1Freq();\n  }\n  usart_instance->BRR = (((parity + (int)(((ulonglong)(freq1 * 0x19) /\n                                 (ulonglong)((uart_handle->Init).BaudRate << 2)) / 100) * -100) * 0x10 +\n                 0x32) / 100 & 0xf | (baudrate_calibration * 0x10 + 0x32U) / 100 & 0xf0) + baudrate_divisor * 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080025e8": "initialize_uart_080025e8",
                "huart": "uart_handle",
                "USART_TypeDef": "usart_type_def",
                "uVar1": "freq1",
                "uVar2": "freq2",
                "uVar3": "parity",
                "iVar4": "baudrate_divisor",
                "uVar5": "baudrate",
                "iVar6": "baudrate_calibration",
                "pUVar7": "usart_instance"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002724": {
            "entrypoint": "0x08002724",
            "current_name": "initialize_uart_08002724",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initialize_UART_08002724(UART_HandleTypeDef *UART_handle)\n\n{\n  USART_TypeDef *USART_instance;\n  \n  if (UART_handle != (UART_HandleTypeDef *)0x0) {\n    if (UART_handle->State == UART_STATE_RESET) {\n      UART_handle->Lock = UNLOCKED;\n      initialize_UART_08002724_peripheral(UART_handle);\n    }\n    UART_handle->State = HAL_UART_STATE_BUSY;\n    UART_handle->Instance->CR1 = UART_handle->Instance->CR1 & 0xffffdfff;\n    set_UART_Configuration(UART_handle);\n    USART_instance = UART_handle->Instance;\n    USART_instance->CR2 = USART_instance->CR2 & 0xffffb7ff;\n    USART_instance->CR3 = USART_instance->CR3 & 0xffffffd5;\n    USART_instance->CR1 = USART_instance->CR1 | 0x2000;\n    UART_handle->ErrorCode = 0;\n    UART_handle->State = HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002724": "initialize_uart_08002724",
                "huart": "UART_handle",
                "pUVar1": "USART_instance",
                "HAL_UART_STATE_RESET": "UART_STATE_RESET",
                "HAL_UNLOCKED": "UNLOCKED",
                "HAL_UART_MspInit": "initialize_UART_peripheral",
                "UART_SetConfig": "set_UART_Configuration"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800277c": {
            "entrypoint": "0x0800277c",
            "current_name": "send_data_over_uart_0800277c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nsendDataOverUART_0800277c(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t dataSize,uint32_t timeout)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  HAL_UART_StateTypeDef uartState;\n  USART_TypeDef *uartInstance;\n  uint16_t *tmp;\n  \n  if ((uartHandle->State == HAL_UART_STATE_READY) || (uartHandle->State == HAL_UART_STATE_BUSY_RX)) {\n    if ((data == (uint8_t *)0x0) || (dataSize == 0)) {\n      return HAL_ERROR;\n    }\n    if (uartHandle->Lock != HAL_LOCKED) {\n      uartHandle->Lock = HAL_LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->TxXferdataSize = dataSize;\n      if (uartHandle->State == HAL_UART_STATE_BUSY_RX) {\n        uartState = HAL_UART_STATE_BUSY_TX_RX;\n      }\n      else {\n        uartState = HAL_UART_STATE_BUSY_TX;\n      }\n      uartHandle->TxXferCount = dataSize;\n      uartHandle->State = uartState;\nLAB_080027c4:\n      if (uartHandle->TxXferCount == 0) {\n        uVar1 = HAL_GetTick();\n        do {\n          do {\n            if ((int)(uartHandle->Instance->SR << 0x19) < 0) {\n              if (uartHandle->State == HAL_UART_STATE_BUSY_TX_RX) {\n                uartState = HAL_UART_STATE_BUSY_RX;\n              }\n              else {\n                uartState = HAL_UART_STATE_READY;\n              }\n              uartHandle->State = uartState;\n              uartHandle->Lock = HAL_UNLOCKED;\n              return HAL_OK;\n            }\n          } while (timeout == 0xffffffff);\n        } while ((timeout != 0) && (uVar2 = HAL_GetTick(), uVar2 - uVar1 <= timeout));\n      }\n      else {\n        uartHandle->TxXferCount = uartHandle->TxXferCount - 1;\n        if ((uartHandle->Init).WordLength == 0x1000) {\n          uVar1 = HAL_GetTick();\n          do {\n            do {\n              if ((int)(uartHandle->Instance->SR << 0x18) < 0) {\n                uartHandle->Instance->DR = *(ushort *)data & 0x1ff;\n                if ((uartHandle->Init).Parity == 0) {\n                  data = (uint8_t *)((int)data + 2);\n                }\n                else {\nLAB_08002812:\n                  data = (uint8_t *)((int)data + 1);\n                }\n                goto LAB_080027c4;\n              }\n            } while (timeout == 0xffffffff);\n          } while ((timeout != 0) && (uVar2 = HAL_GetTick(), uVar2 - uVar1 <= timeout));\n        }\n        else {\n          uVar1 = HAL_GetTick();\n          do {\n            do {\n              if ((int)(uartHandle->Instance->SR << 0x18) < 0) {\n                uartHandle->Instance->DR = (uint)*data;\n                goto LAB_08002812;\n              }\n            } while (timeout == 0xffffffff);\n          } while ((timeout != 0) && (uVar2 = HAL_GetTick(), uVar2 - uVar1 <= timeout));\n        }\n      }\n      uartInstance = uartHandle->Instance;\n      uartInstance->CR1 = uartInstance->CR1 & 0xffffff7f;\n      uartInstance->CR1 = uartInstance->CR1 & 0xffffffdf;\n      uartInstance->CR1 = uartInstance->CR1 & 0xfffffeff;\n      uartInstance->CR3 = uartInstance->CR3 & 0xfffffffe;\n      uartHandle->State = HAL_UART_STATE_READY;\n      uartHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_0800277c": "send_data_over_uart_0800277c",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "dataSize",
                "Timeout": "timeout",
                "HVar3": "uartState",
                "pUVar4": "uartInstance"
            },
            "calling": [
                "serialWrite"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028a6": {
            "entrypoint": "0x080028a6",
            "current_name": "handle_uart_transmission_080028a6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleUartTransmission_080028a6(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t size)\n\n{\n  HAL_UART_StateTypeDef uartState;\n  uint cr1Value;\n  USART_TypeDef *uartInstance;\n  \n  if ((uartHandle->State == HAL_UART_STATE_READY) || (uartHandle->State == HAL_UART_STATE_BUSY_TX)) {\n    if ((data == (uint8_t *)0x0) || (size == 0)) {\n      return HAL_ERROR;\n    }\n    if (uartHandle->Lock != HAL_LOCKED) {\n      uartHandle->Lock = HAL_LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->RxXfersize = size;\n      uartHandle->RxXferCount = size;\n      uartHandle->Lock = HAL_UNLOCKED;\n      if (uartHandle->State == HAL_UART_STATE_BUSY_TX) {\n        uartState = HAL_UART_STATE_BUSY_TX_RX;\n      }\n      else {\n        uartState = HAL_UART_STATE_BUSY_RX;\n      }\n      uartInstance = uartHandle->Instance;\n      uartHandle->State = uartState;\n      cr1Value = uartInstance->CR1;\n      uartHandle->pRxBuffPtr = data;\n      uartInstance->CR1 = cr1Value | 0x100;\n      uartInstance->CR3 = uartInstance->CR3 | 1;\n      uartInstance->CR1 = uartInstance->CR1 | 0x20;\n      return HAL_OK;\n    }\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_080028a6": "handle_uart_transmission_080028a6",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "size",
                "HVar1": "uartState",
                "uVar2": "cr1Value",
                "pUVar3": "uartInstance"
            },
            "calling": [
                "HAL_UART_RxCpltCallback",
                "serialBegin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800290a": {
            "entrypoint": "0x0800290a",
            "current_name": "FUNC_0800290a",
            "code": "\nvoid FUNC_0800290a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800290a": "FUNC_0800290a"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800290c": {
            "entrypoint": "0x0800290c",
            "current_name": "handle_received_data_0800290c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleReceivedData_0800290c(UART_HandleTypeDef *uartHandle)\n\n{\n  uint32_t parity;\n  byte receivedByte;\n  USART_TypeDef *usartInstance;\n  uint16_t remainingBytes;\n  ushort *rxBufferPtr;\n  uint16_t *tmp;\n  ushort *nextRxBufferPtr;\n  bool isBusy;\n  \n  if ((uartHandle->State & 0xef) != 0x22) {\n    return HAL_BUSY;\n  }\n  parity = (uartHandle->Init).Parity;\n  usartInstance = uartHandle->Instance;\n  rxBufferPtr = (ushort *)uartHandle->pRxBuffPtr;\n  if ((uartHandle->Init).WordLength == 0x1000) {\n    if (parity == 0) {\n      nextRxBufferPtr = rxBufferPtr + 1;\n      *rxBufferPtr = (ushort)((usartInstance->DR << 0x17) >> 0x17);\n    }\n    else {\n      nextRxBufferPtr = (ushort *)((int)rxBufferPtr + 1);\n      *rxBufferPtr = (ushort)usartInstance->DR & 0xff;\n    }\n    uartHandle->pRxBuffPtr = (uint8_t *)nextRxBufferPtr;\n  }\n  else {\n    if (parity == 0) {\n      receivedByte = (byte)usartInstance->DR;\n      uartHandle->pRxBuffPtr = (uint8_t *)((int)rxBufferPtr + 1);\n    }\n    else {\n      parity = usartInstance->DR;\n      uartHandle->pRxBuffPtr = (uint8_t *)((int)rxBufferPtr + 1);\n      receivedByte = (byte)parity & 0x7f;\n    }\n    *(byte *)rxBufferPtr = receivedByte;\n  }\n  remainingBytes = uartHandle->RxXferCount - 1;\n  uartHandle->RxXferCount = remainingBytes;\n  if (remainingBytes == 0) {\n    usartInstance = uartHandle->Instance;\n    usartInstance->CR1 = usartInstance->CR1 & 0xffffffdf;\n    isBusy = uartHandle->State != HAL_UART_STATE_BUSY_TX_RX;\n    if (isBusy) {\n      parity = usartInstance->CR1 & 0xfffffeff;\n    }\n    else {\n      usartInstance = (USART_TypeDef *)0x12;\n      parity = 0x32;\n    }\n    if (isBusy) {\n      usartInstance->CR1 = parity;\n      parity = usartInstance->CR3 & 0xfffffffe;\n    }\n    if (isBusy) {\n      usartInstance->CR3 = parity;\n      usartInstance = (USART_TypeDef *)0x1;\n    }\n    uartHandle->State = (HAL_UART_StateTypeDef)usartInstance;\n    HAL_UART_RxCpltCallback(uartHandle);\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800290c": "handle_received_data_0800290c",
                "huart": "uartHandle",
                "uVar1": "parity",
                "bVar2": "receivedByte",
                "pUVar3": "usartInstance",
                "uVar4": "remainingBytes",
                "puVar5": "rxBufferPtr",
                "puVar6": "nextRxBufferPtr",
                "bVar7": "isBusy"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002998": {
            "entrypoint": "0x08002998",
            "current_name": "FUNC_08002998",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002998(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002998": "FUNC_08002998"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800299a": {
            "entrypoint": "0x0800299a",
            "current_name": "handle_uart_interrupt_0800299a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_uart_interrupt_0800299a(UART_HandleTypeDef *uart_handle)\n\n{\n  uint status_reg;\n  uint32_t cr1_its;\n  uint16_t data;\n  uint status;\n  uint32_t isr_flags;\n  ushort *tx_buff_ptr;\n  uint16_t *tmp_ptr;\n  uart_state_type uart_state;\n  USART_TypeDef *uart_instance;\n  uint32_t error_code_flag;\n  uint32_t cr3_its;\n  uint is_tx_rx_enabled;\n  bool is_error;\n  \n  uart_instance = uart_handle->Instance;\n  status = uart_instance->SR;\n  status_reg = uart_instance->CR1;\n  if ((status & 0xf) == 0) {\n    if (((int)(status << 0x1a) < 0) && ((int)(status_reg << 0x1a) < 0)) {\n      uart_receive_it(uart_handle);\n      return;\n    }\n  }\n  else {\n    is_tx_rx_enabled = uart_instance->CR3 & 1;\n    if ((is_tx_rx_enabled != 0) || ((status_reg & 0x120) != 0)) {\n      error_code_flag = status << 0x1f;\n      if ((int)error_code_flag < 0) {\n        is_error = (int)(status_reg << 0x17) < 0;\n        if (is_error) {\n          error_code_flag = uart_handle->error_code | 1;\n        }\n        if (is_error) {\n          uart_handle->error_code = error_code_flag;\n        }\n      }\n      if (((int)(status << 0x1d) < 0) && (is_tx_rx_enabled != 0)) {\n        uart_handle->error_code = uart_handle->error_code | 2;\n      }\n      if (((int)(status << 0x1e) < 0) && (is_tx_rx_enabled != 0)) {\n        uart_handle->error_code = uart_handle->error_code | 4;\n      }\n      if (((int)(status << 0x1c) < 0) && (is_tx_rx_enabled != 0)) {\n        uart_handle->error_code = uart_handle->error_code | 8;\n      }\n      if (uart_handle->error_code == 0) {\n        return;\n      }\n      if (((int)(status << 0x1a) < 0) && ((int)(status_reg << 0x1a) < 0)) {\n        uart_receive_it(uart_handle);\n      }\n      uart_instance = uart_handle->Instance;\n      if ((-1 < (int)(uart_handle->error_code << 0x1c)) && ((uart_instance->CR3 & 0x40) == 0)) {\n        uart_error_callback(uart_handle);\n        uart_handle->error_code = 0;\n        return;\n      }\n      uart_instance->CR1 = uart_instance->CR1 & 0xfffffedf;\n      uart_instance->CR3 = uart_instance->CR3 & 0xfffffffe;\n      uart_handle->State = state_ready;\n      uart_error_callback(uart_handle);\n      return;\n    }\n  }\n  if (((int)(status << 0x18) < 0) && ((int)(status_reg << 0x18) < 0)) {\n    if ((uart_handle->State & 0xdf) == 0x12) {\n      tx_buff_ptr = (ushort *)uart_handle->pTxBuffPtr;\n      if ((uart_handle->Init).word_length == 0x1000) {\n        uart_instance->DR = *tx_buff_ptr & 0x1ff;\n        if ((uart_handle->Init).parity == 0) {\n          tx_buff_ptr = tx_buff_ptr + 1;\n        }\n        else {\n          tx_buff_ptr = (ushort *)((int)tx_buff_ptr + 1);\n        }\n        uart_handle->pTxBuffPtr = (uint8_t *)tx_buff_ptr;\n      }\n      else {\n        uart_handle->pTxBuffPtr = (byte *)((int)tx_buff_ptr + 1);\n        uart_instance->DR = (uint)*(byte *)tx_buff_ptr;\n      }\n      data = uart_handle->tx_remaining_count - 1;\n      uart_handle->tx_remaining_count = data;\n      if (data == 0) {\n        uart_instance->CR1 = uart_instance->CR1 & 0xffffff7f;\n        uart_instance->CR1 = uart_instance->CR1 | 0x40;\n        return;\n      }\n    }\n  }\n  else if (((int)(status << 0x19) < 0) && ((int)(status_reg << 0x19) < 0)) {\n    uart_instance->CR1 = uart_instance->CR1 & 0xffffffbf;\n    if (uart_handle->State == state_busy_tx_rx) {\n      uart_state = state_busy_rx;\n    }\n    else {\n      uart_state = state_ready;\n    }\n    uart_handle->State = uart_state;\n    uart_tx_complete_callback(uart_handle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800299a": "handle_uart_interrupt_0800299a",
                "huart": "uart_handle",
                "uVar1": "status_reg",
                "cr1its": "cr1_its",
                "uVar2": "data",
                "uVar3": "status",
                "isrflags": "isr_flags",
                "puVar4": "tx_buff_ptr",
                "tmp": "tmp_ptr",
                "HVar5": "uart_state",
                "pUVar6": "uart_instance",
                "uVar7": "error_code_flag",
                "cr3its": "cr3_its",
                "uVar8": "is_tx_rx_enabled",
                "bVar9": "is_error",
                "UART_Receive_IT": "uart_receive_it",
                "HAL_UART_StateTypeDef": "uart_state_type",
                "ErrorCode": "error_code",
                "HAL_UART_ErrorCallback": "uart_error_callback",
                "HAL_UART_TxCpltCallback": "uart_tx_complete_callback",
                "TxXferCount": "tx_remaining_count",
                "HAL_UART_STATE_BUSY_TX_RX": "state_busy_tx_rx",
                "HAL_UART_STATE_BUSY_RX": "state_busy_rx",
                "HAL_UART_STATE_READY": "state_ready",
                "WordLength": "word_length",
                "Parity": "parity"
            },
            "calling": [
                "USART1_IRQHandler"
            ],
            "called": [
                "HAL_UART_ErrorCallback",
                "HAL_UART_TxCpltCallback",
                "UART_Receive_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad0": {
            "entrypoint": "0x08002ad0",
            "current_name": "initialize_mpu9250_08002ad0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeMPU9250_08002ad0(void)\n\n{\n  readI2CByte(0xd0,0x75,\"../Src/MPU9250.c\",0x3b);\n  writeI2CByte(0xd0,0x6b,0x80,'\\x01');\n  writeI2CByte(0xd0,0x6b,'\\x01','\\x01');\n  writeI2CByte(0xd0,0x6c,'\\0','\\x01');\n  writeI2CByte(0xd0,0x19,'\\0','\\x01');\n  writeI2CByte(0xd0,0x1d,'\\x03','\\x01');\n  writeI2CByte(0xd0,0x1a,'\\x03','\\x01');\n  writeI2CByte(0xd0,0x1b,'\\x10','\\x01');\n  writeI2CByte(0xd0,0x1c,'\\b','\\x01');\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ad0": "initialize_mpu9250_08002ad0",
                "I2C_ReadByte": "readI2CByte",
                "I2C_WriteByte": "writeI2CByte"
            },
            "calling": [
                "IMU_Init"
            ],
            "called": [
                "I2C_ReadByte",
                "I2C_WriteByte"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002b48": {
            "entrypoint": "0x08002b48",
            "current_name": "read_accelerometer_data_08002b48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readAccelerometerData_08002b48(void)\n\n{\n  undefined4 result;\n  uint input;\n  int var2;\n  int var3;\n  uint8_t accelerometerRawData [6];\n  \n  accelerometerRawData[0] = '\\0';\n  accelerometerRawData[1] = '\\0';\n  accelerometerRawData[2] = '\\0';\n  accelerometerRawData[3] = '\\0';\n  stackVar = input & 0xffff0000;\n  I2C_ReadByteArray(0xd0,0x3b,accelerometerRawData,6,\"../Src/MPU9250.c\",0x58);\n  accelerometerRaw.y = CONCAT11(accelerometerRawData[2],accelerometerRawData[3]);\n  accelerometerRaw.x = CONCAT11(accelerometerRawData[0],accelerometerRawData[1]);\n  accelerometerRaw.z = CONCAT11(accelerometerRawData[4],accelerometerRawData[5]);\n  var3 = (int)accelerometerRaw.y;\n  var2 = (int)accelerometerRaw.z;\n  result = __floatsisf();\n  result = __aeabi_fmul(result,0x40800000);\n  accelerometerData.x = (float)__aeabi_fmul(result,0x38000000);\n  result = __floatsisf(var3);\n  result = __aeabi_fmul(result,0x40800000);\n  accelerometerData.y = (float)__aeabi_fmul(result,0x38000000);\n  result = __floatsisf(var2);\n  result = __aeabi_fmul(result,0x40800000);\n  accelerometerData.z = (float)__aeabi_fmul(result,0x38000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002b48": "read_accelerometer_data_08002b48",
                "in_r3": "input",
                "raw_data": "accelerometerRawData",
                "stack0xffffffec": "stackVar",
                "accelRaw": "accelerometerRaw",
                "accelData": "accelerometerData",
                "iVar2": "var2",
                "iVar3": "var3",
                "uVar1": "result"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002bf0": {
            "entrypoint": "0x08002bf0",
            "current_name": "read_and_process_gyro_data_08002bf0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readAndProcessGyroData_08002bf0(void)\n\n{\n  undefined4 gyroDataMultiplier;\n  int gyroRawZ;\n  int gyroRawY;\n  uint8_t gyroRawData [6];\n  \n  gyroRawData[0] = '\\0';\n  gyroRawData[1] = '\\0';\n  gyroRawData[2] = '\\0';\n  gyroRawData[3] = '\\0';\n  gyroRawData[4] = '\\0';\n  gyroRawData[5] = '\\0';\n  I2C_ReadByteArray(0xd0,0x43,gyroRawData,6,\"../Src/MPU9250.c\",0x7b);\n  processedGyroRawData.y = CONCAT11(gyroRawData[2],gyroRawData[3]);\n  processedGyroRawData.x = CONCAT11(gyroRawData[0],gyroRawData[1]);\n  processedGyroRawData.z = CONCAT11(gyroRawData[4],gyroRawData[5]);\n  gyroRawY = (int)processedGyroRawData.y;\n  gyroRawZ = (int)processedGyroRawData.z;\n  gyroDataMultiplier = __floatsisf();\n  gyroDataMultiplier = __aeabi_fmul(gyroDataMultiplier,0x447a0000);\n  gyroDataMultiplier = __aeabi_fmul(gyroDataMultiplier,0x38000000);\n  finalGyroDataX = (float)__aeabi_fsub(gyroDataMultiplier,gyroBiasData.x);\n  gyroDataMultiplier = __floatsisf(gyroRawY);\n  gyroDataMultiplier = __aeabi_fmul(gyroDataMultiplier,0x447a0000);\n  gyroDataMultiplier = __aeabi_fmul(gyroDataMultiplier,0x38000000);\n  finalGyroDataY = (float)__aeabi_fsub(gyroDataMultiplier,gyroBiasData.y);\n  gyroDataMultiplier = __floatsisf(gyroRawZ);\n  gyroDataMultiplier = __aeabi_fmul(gyroDataMultiplier,0x447a0000);\n  gyroDataMultiplier = __aeabi_fmul(gyroDataMultiplier,0x38000000);\n  finalGyroDataZ = (float)__aeabi_fsub(gyroDataMultiplier,gyroBiasData.z);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002bf0": "read_and_process_gyro_data_08002bf0",
                "raw_data": "gyroRawData",
                "gyroRaw": "processedGyroRawData",
                "iVar3": "gyroRawY",
                "iVar2": "gyroRawZ",
                "uVar1": "gyroDataMultiplier",
                "gyroData.x": "finalGyroDataX",
                "gyroData.y": "finalGyroDataY",
                "gyroData.z": "finalGyroDataZ",
                "gyroBias": "gyroBiasData"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__aeabi_fsub",
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002cb0": {
            "entrypoint": "0x08002cb0",
            "current_name": "configure_and_calibrate_sensor_08002cb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureAndCalibrateSensor_08002cb0(void)\n\n{\n  undefined4 uVar1;\n  uint sensorConfiguration;\n  uint8_t sensorData [3];\n  \n  sensorDataRaw = sensorConfiguration;\n  writeI2CByte(0xd0,0x37,'\\\"','\\x01');\n  writeI2CByte(0xd0,0x6a,'\\x01','\\x01');\n  readI2CByte(0x18,0,\"../Src/MPU9250.c\",0xad);\n  writeI2CByte(0x18,0xb,'\\x01','\\x01');\n  writeI2CByte(0x18,10,'\\0','\\x01');\n  writeI2CByte(0x18,10,'\\x0f','\\x01');\n  readI2CByteArray(0x18,0x10,sensorData,3,\"../Src/MPU9250.c\",0xb6);\n  uVar1 = convertIntToFloat((sensorDataRaw & 0xff) - 0x80);\n  uVar1 = multiplyFloats(uVar1,0x3b800000);\n  calibratedMagX = (float)addFloats(uVar1,0x3f800000);\n  uVar1 = convertIntToFloat((sensorDataRaw >> 8 & 0xff) - 0x80);\n  uVar1 = multiplyFloats(uVar1,0x3b800000);\n  calibratedMagY = (float)addFloats(uVar1,0x3f800000);\n  uVar1 = convertIntToFloat(sensorData[2] - 0x80);\n  uVar1 = multiplyFloats(uVar1,0x3b800000);\n  calibratedMagZ = (float)addFloats(uVar1,0x3f800000);\n  writeI2CByte(0x18,10,'\\0','\\x01');\n  writeI2CByte(0x18,10,'\\x16','\\x01');\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002cb0": "configure_and_calibrate_sensor_08002cb0",
                "in_r3": "sensorConfiguration",
                "rawData": "sensorData",
                "_rawData": "sensorDataRaw",
                "I2C_WriteByte": "writeI2CByte",
                "I2C_ReadByte": "readI2CByte",
                "I2C_ReadByteArray": "readI2CByteArray",
                "__floatsisf": "convertIntToFloat",
                "__aeabi_fmul": "multiplyFloats",
                "__addsf3": "addFloats",
                "magCalib.x": "calibratedMagX",
                "magCalib.y": "calibratedMagY",
                "magCalib.z": "calibratedMagZ"
            },
            "calling": [
                "IMU_Init"
            ],
            "called": [
                "I2C_ReadByte",
                "__addsf3",
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_WriteByte",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d88": {
            "entrypoint": "0x08002d88",
            "current_name": "read_and_process_mpu9250_data_08002d88",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid read_and_process_mpu9250_data_08002d88(void)\n\n{\n  float magneticRes;\n  byte byteValue;\n  undefined4 uVar3;\n  undefined4 param;\n  int magRaw_z;\n  int magRaw_y;\n  int16_t magRaw_x;\n  undefined magRaw_y_high;\n  undefined magRaw_y_low;\n  undefined magRaw_z_high;\n  undefined magRaw_z_low;\n  uint8_t overflow_flag;\n  undefined stack_21;\n  \n  stack_21 = (undefined)((uint)param >> 0x18);\n  magRaw_x = 0;\n  magRaw_y_high = 0;\n  magRaw_y_low = 0;\n  magRaw_z_high = 0;\n  magRaw_z_low = 0;\n  overflow_flag = '\\0';\n  byteValue = I2C_ReadByte(0x18,2,\"../Src/MPU9250.c\",0xd7);\n  if ((int)((uint)byteValue << 0x1f) < 0) {\n    I2C_ReadByteArray(0x18,3,(uint8_t *)&magRaw_x,7,\"../Src/MPU9250.c\",0xda);\n    magneticRes = mRes;\n    if ((int)((uint)overflow_flag << 0x1c) < 0) {\n      i2cErrorsCount = i2cErrorsCount + 1;\n    }\n    else {\n      magRaw.y = CONCAT11(magRaw_y_low,magRaw_y_high);\n      magRaw.z = CONCAT11(magRaw_z_low,magRaw_z_high);\n      magRaw_y = (int)magRaw.y;\n      magRaw_z = (int)magRaw.z;\n      magRaw.x = magRaw_x;\n      uVar3 = __floatsisf();\n      uVar3 = __aeabi_fmul(uVar3,magneticRes);\n      uVar3 = __aeabi_fmul(uVar3,magCalib_x);\n      uVar3 = __aeabi_fsub(uVar3,magBias_x);\n      processedMagData_x = (float)__aeabi_fmul(uVar3,magScale_x);\n      uVar3 = __floatsisf(magRaw_y);\n      uVar3 = __aeabi_fmul(uVar3,magneticRes);\n      uVar3 = __aeabi_fmul(uVar3,magCalib_y);\n      uVar3 = __aeabi_fsub(uVar3,magBias_y);\n      processedMagData_y = (float)__aeabi_fmul(uVar3,magScale_y);\n      uVar3 = __floatsisf(magRaw_z);\n      uVar3 = __aeabi_fmul(uVar3,magneticRes);\n      uVar3 = __aeabi_fmul(uVar3,magCalib_z);\n      uVar3 = __aeabi_fsub(uVar3,magBias_z);\n      processedMagData_z = (float)__aeabi_fmul(uVar3,magScale_z);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d88": "read_and_process_mpu9250_data_08002d88",
                "in_r3": "param",
                "iVar4": "magRaw_z",
                "iVar5": "magRaw_y",
                "local_23": "magRaw_z_low",
                "local_24": "magRaw_z_high",
                "local_28": "magRaw_x",
                "OVF": "overflow_flag",
                "bVar2": "byteValue",
                "fVar1": "magneticRes",
                "uStack_21": "stack_21",
                "uStack_25": "magRaw_y_low",
                "uStack_26": "magRaw_y_high",
                "magBias.x": "magBias_x",
                "magBias.y": "magBias_y",
                "magBias.z": "magBias_z",
                "magCalib.x": "magCalib_x",
                "magCalib.y": "magCalib_y",
                "magCalib.z": "magCalib_z",
                "magData.x": "processedMagData_x",
                "magData.y": "processedMagData_y",
                "magData.z": "processedMagData_z",
                "magScale.x": "magScale_x",
                "magScale.y": "magScale_y",
                "magScale.z": "magScale_z",
                "msp_txf_status.i2c_errors_count": "i2cErrorsCount"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "I2C_ReadByte",
                "__aeabi_fsub",
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ea0": {
            "entrypoint": "0x08002ea0",
            "current_name": "initialize_sensors_08002ea0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSensors_08002ea0(void)\n\n{\n  initializeMPU9250();\n  initializeAK8963();\n  setMadgwickBeta(0.6);\n  setMadgwickDelta(0.0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ea0": "initialize_sensors_08002ea0",
                "MPU9250_Init": "initializeMPU9250",
                "AK8963_Init": "initializeAK8963",
                "MadgwickSetBeta": "setMadgwickBeta",
                "MadgwickSetDelta": "setMadgwickDelta"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "MPU9250_Init",
                "AK8963_Init",
                "MadgwickSetDelta",
                "MadgwickSetBeta"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ec0": {
            "entrypoint": "0x08002ec0",
            "current_name": "calculate_filtered_pitch_08002ec0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat calculateFilteredPitch_08002ec0(void)\n\n{\n  float fVar1;\n  \n  fVar1 = lowPassFilter(&lowPassFilterPitch,ahrsAngles[1]);\n  return fVar1;\n}\n\n",
            "renaming": {
                "FUN_08002ec0": "calculate_filtered_pitch_08002ec0",
                "lpf_pitch": "lowPassFilterPitch",
                "AHRS_Angle": "ahrsAngles"
            },
            "calling": [
                "PID_Update",
                "AHRS_ComputeAngles"
            ],
            "called": [
                "lowPassFilter"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ed4": {
            "entrypoint": "0x08002ed4",
            "current_name": "filtered_roll_angle_08002ed4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat filteredRollAngle_08002ed4(void)\n\n{\n  float filteredAngle;\n  \n  filteredAngle = lowPassFilter(&rollFilter,angleData[0]);\n  return filteredAngle;\n}\n\n",
            "renaming": {
                "FUN_08002ed4": "filtered_roll_angle_08002ed4",
                "fVar1": "filteredAngle",
                "&lpf_roll": "&rollFilter",
                "AHRS_Angle[0]": "angleData[0]"
            },
            "calling": [
                "PID_Update",
                "AHRS_ComputeAngles"
            ],
            "called": [
                "lowPassFilter"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ee8": {
            "entrypoint": "0x08002ee8",
            "current_name": "calculate_adjusted_angle_08002ee8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat calculateAdjustedAngle_08002ee8(void)\n\n{\n  int isGreaterOrEqual;\n  float angle;\n  float adjustedAngle;\n  \n  adjustedAngle = angle[2];\n  isGreaterOrEqual = __aeabi_fcmpge(angle[2],0xc3340000);\n  if ((isGreaterOrEqual != 0) && (isGreaterOrEqual = __aeabi_fcmplt(adjustedAngle,0x42b40000), isGreaterOrEqual != 0)) {\n    adjustedAngle = (float)__addsf3(adjustedAngle,0x42b40000);\n    return adjustedAngle;\n  }\n  adjustedAngle = (float)__aeabi_fsub(adjustedAngle,0x43870000);\n  return adjustedAngle;\n}\n\n",
            "renaming": {
                "FUN_08002ee8": "calculate_adjusted_angle_08002ee8",
                "AHRS_Angle": "angle",
                "iVar1": "isGreaterOrEqual",
                "fVar2": "adjustedAngle"
            },
            "calling": [
                "PID_Update",
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__aeabi_fcmpge",
                "__addsf3",
                "__aeabi_fsub",
                "__aeabi_fcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f28": {
            "entrypoint": "0x08002f28",
            "current_name": "update_ahrs_data_08002f28",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateAHRSData_08002f28(void)\n\n{\n  undefined4 timeDifference;\n  float timeElapsed;\n  \n  MPU9250_ReadAccelData();\n  MPU9250_ReadGyroData();\n  AK8963_ReadData();\n  AHRS_timeNow = micros();\n  timeDifference = __floatunsisf(AHRS_timeNow - AHRS_lastUpdate);\n  timeElapsed = (float)__aeabi_fdiv(timeDifference,0x447a0000);\n  MadgwickSetDelta(timeElapsed);\n  AHRS_lastUpdate = AHRS_timeNow;\n  MadgwickQuaternionUpdate\n            ((float)((int)accelerationY + -0x80000000),(float)((int)accelerationX + -0x80000000),\n             accelerationZ,gyroY,gyroX,(float)((int)gyroZ + -0x80000000),magneticFieldX,\n             magneticFieldY,magneticFieldZ,angle);\n  msp_txf_raw_imu.accx = (int16_t)((uint)(int)rawAccelerationX / 100);\n  msp_txf_raw_imu.accz = (int16_t)((uint)(int)rawAccelerationZ / 100);\n  msp_txf_raw_imu.accy = (int16_t)((uint)(int)rawAccelerationY / 100);\n  msp_txf_raw_imu.gyrx = rawGyroX;\n  msp_txf_raw_imu.gyry = rawGyroY;\n  msp_txf_raw_imu.gyrz = rawGyroZ;\n  msp_txf_raw_imu.magx = rawMagneticFieldX;\n  msp_txf_raw_imu.magy = rawMagneticFieldY;\n  msp_txf_raw_imu.magz = rawMagneticFieldZ;\n  AHRS_GetRoll();\n  __aeabi_fmul();\n  msp_txf_attitude.angx = __aeabi_f2iz();\n  AHRS_GetPitch();\n  __aeabi_fmul();\n  msp_txf_attitude.angy = __aeabi_f2iz();\n  AHRS_GetYaw();\n  msp_txf_attitude.heading = __aeabi_f2iz();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f28": "update_ahrs_data_08002f28",
                "_deltat": "timeElapsed",
                "uVar1": "timeDifference",
                "accelData.y": "accelerationY",
                "accelData.x": "accelerationX",
                "accelData.z": "accelerationZ",
                "gyroData.y": "gyroY",
                "gyroData.x": "gyroX",
                "gyroData.z": "gyroZ",
                "magData.x": "magneticFieldX",
                "magData.y": "magneticFieldY",
                "magData.z": "magneticFieldZ",
                "AHRS_Angle": "angle",
                "accelRaw.x": "rawAccelerationX",
                "accelRaw.y": "rawAccelerationY",
                "accelRaw.z": "rawAccelerationZ",
                "gyroRaw.x": "rawGyroX",
                "gyroRaw.y": "rawGyroY",
                "gyroRaw.z": "rawGyroZ",
                "magRaw.x": "rawMagneticFieldX",
                "magRaw.y": "rawMagneticFieldY",
                "magRaw.z": "rawMagneticFieldZ"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "__aeabi_f2iz",
                "__aeabi_fdiv",
                "__aeabi_fmul",
                "MPU9250_ReadAccelData",
                "micros",
                "MPU9250_ReadGyroData",
                "AHRS_GetRoll",
                "AHRS_GetPitch",
                "MadgwickQuaternionUpdate",
                "AK8963_ReadData",
                "AHRS_GetYaw",
                "MadgwickSetDelta",
                "__floatunsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003034": {
            "entrypoint": "0x08003034",
            "current_name": "read_sensor_data_08003034",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t readSensorData_08003034(void)\n\n{\n  undefined4 inputArg;\n  uint8_t receivedBuffer [3];\n  \n  _receivedBuffer = inputArg;\n  I2C_ReadBytes(0xee,0,receivedBuffer,3,\"../Src/MS5611.c\",0x8c);\n  return (uint)CONCAT12(receivedBuffer[0],CONCAT11(receivedBuffer[1],receivedBuffer[2]));\n}\n\n",
            "renaming": {
                "FUN_08003034": "read_sensor_data_08003034",
                "in_r3": "inputArg",
                "rxbuf": "receivedBuffer"
            },
            "calling": [
                "MS5611_Update"
            ],
            "called": [
                "I2C_ReadBytes"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003068": {
            "entrypoint": "0x08003068",
            "current_name": "calculate_result_08003068",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat calculate_result_08003068(void)\n\n{\n  float input_value;\n  \n  return input_value;\n}\n\n",
            "renaming": {
                "FUN_08003068": "calculate_result_08003068",
                "in_s0": "input_value"
            },
            "calling": [
                "PID_UpdateAltitude"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003078": {
            "entrypoint": "0x08003078",
            "current_name": "calculate_compensated_values_08003078",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calculateCompensatedValues_08003078(void)\n\n{\n  float *currentValue;\n  longlong tempValue;\n  uint tempValue1;\n  uint tempValue2;\n  uint tempValue3;\n  undefined4 floatResult;\n  float compensatedPressure;\n  uint32_t currentTime;\n  undefined4 extraOutput;\n  uint tempValue4;\n  undefined4 unusedVariable1;\n  uint tempValue5;\n  uint tempValue6;\n  uint tempValue7;\n  float *filteredAltitude;\n  undefined4 unusedVariable2;\n  undefined4 unusedVariable3;\n  undefined4 unusedVariable4;\n  int estimatedAltitude;\n  int32_t TEMP;\n  int tempValue8;\n  int tempValue9;\n  int32_t dT;\n  bool isNegative;\n  undefined8 uVar18;\n  \n  if ((TEMP_READY != '\\0') && (pressureReady != '\\0')) {\n    tempValue9 = rawTemp + (uint)coefficients[5] * -0x100;\n    tempValue4 = (uint)((longlong)(int)(uint)coefficients[6] * (longlong)tempValue9) >> 0x17 |\n            (int)((ulonglong)((longlong)(int)(uint)coefficients[6] * (longlong)tempValue9) >>\n                 0x20) << 9;\n    tempValue5 = (uint)((longlong)(int)(uint)coefficients[4] * (longlong)tempValue9 >> 7);\n    tempValue6 = tempValue5 + (uint)coefficients[2] * 0x10000;\n    tempValue2 = (uint)((ulonglong)((longlong)(int)(uint)coefficients[3] * (longlong)tempValue9) >> 8)\n    ;\n    estimatedAltitude = tempValue4 + 2000;\n    tempValue3 = tempValue2 + (uint)coefficients[1] * 0x8000;\n    isNegative = (int)tempValue4 < 0;\n    if (1999 < estimatedAltitude) {\n      tempValue4 = 0;\n    }\n    tempValue1 = tempValue4;\n    if (isNegative != SBORROW4(estimatedAltitude,2000)) {\n      tempValue8 = tempValue4 * tempValue4 * 5;\n      tempValue4 = tempValue8 >> 2;\n      tempValue1 = tempValue8 >> 1;\n    }\n    tempValue7 = tempValue6 - tempValue1;\n    tempValue = (ulonglong)(tempValue3 - tempValue4) * (ulonglong)rawPressure;\n    tempValue8 = rawPressure *\n             ((((int)((longlong)(int)(uint)coefficients[3] * (longlong)tempValue9 >> 0x28) +\n               (uint)CARRY4(tempValue2,(uint)coefficients[1] * 0x8000)) - ((int)tempValue4 >> 0x1f)) -\n             (uint)(tempValue3 < tempValue4)) + (int)((ulonglong)tempValue >> 0x20);\n    tempValue2 = (uint)tempValue >> 0x15 | tempValue8 * 0x800;\n    floatResult = __floatsisf(tempValue2 - tempValue7 >> 0xf |\n                        (((tempValue8 >> 0x15) -\n                         ((((int)((longlong)(int)(uint)coefficients[4] * (longlong)tempValue9 >>\n                                 0x27) + (uint)CARRY4(tempValue5,(uint)coefficients[2] * 0x10000)\n                           ) - ((int)tempValue1 >> 0x1f)) - (uint)(tempValue6 < tempValue1))) -\n                        (uint)(tempValue2 < tempValue7)) * 0x20000);\n    compensatedPressure = (float)__aeabi_fdiv(floatResult,0x42c80000);\n    compensatedPressureResult = compensatedPressure;\n    floatResult = __floatsisf(estimatedAltitude);\n    compensatedTemperatureResult = (float)__aeabi_fdiv(floatResult,0x42c80000);\n    __aeabi_fdiv(compensatedPressure,0x447d5000);\n    floatResult = __aeabi_f2d();\n    pow((double)CONCAT44(unusedVariable2,unusedVariable1),(double)CONCAT44(unusedVariable4,unusedVariable3));\n    uVar18 = __subdf3(0,0x3ff00000,floatResult,extraOutput);\n    __muldf3((int)uVar18,(int)((ulonglong)uVar18 >> 0x20),0,0x40e5a540);\n    compensatedPressure = (float)__truncdfsf2();\n    floatResult = 0;\n    filteredAltitude = altFilter;\n    altitude = compensatedPressure;\n    do {\n      currentValue = filteredAltitude + 1;\n      *filteredAltitude = *currentValue;\n      floatResult = __addsf3(floatResult);\n      filteredAltitude = currentValue;\n    } while (currentValue != altFilter + 0x13);\n    altFilter[19] = compensatedPressure;\n    floatResult = __addsf3(floatResult,compensatedPressure);\n    filteredAltitudeResult = (float)__aeabi_fdiv(floatResult,0x41a00000);\n    estimatedAltitude = __aeabi_f2iz();\n    mspTxfAltitude.est_alt = estimatedAltitude * 100;\n    TEMP_READY = '\\0';\n    pressureReady = '\\0';\n    writeI2CByte(0xee,osr + 0x50,'\\x01','\\0');\n    tempTime = getMillis();\n  }\n  currentTime = getMillis();\n  if (((10 < currentTime - tempTime) && (TEMP_READY == '\\0')) && (pressureReady == '\\0')) {\n    rawTemp = readADC();\n    TEMP_READY = '\\x01';\n    writeI2CByte(0xee,osr + 0x40,'\\x01','\\0');\n    pressureTime = getMillis();\n  }\n  currentTime = getMillis();\n  if (((10 < currentTime - pressureTime) && (TEMP_READY != '\\0')) && (pressureReady == '\\0')) {\n    rawPressure = readADC();\n    pressureReady = '\\x01';\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003078": "calculate_compensated_values_08003078",
                "pfVar1": "currentValue",
                "lVar2": "tempValue",
                "uVar3": "tempValue1",
                "uVar4": "tempValue2",
                "uVar5": "tempValue3",
                "uVar6": "floatResult",
                "fVar7": "compensatedPressure",
                "uVar8": "currentTime",
                "extraout_r1": "extraOutput",
                "uVar9": "tempValue4",
                "unaff_r4": "unusedVariable1",
                "uVar10": "tempValue5",
                "uVar11": "tempValue6",
                "uVar12": "tempValue7",
                "pfVar13": "filteredAltitude",
                "unaff_r5": "unusedVariable2",
                "unaff_r6": "unusedVariable3",
                "unaff_r7": "unusedVariable4",
                "iVar14": "estimatedAltitude",
                "iVar15": "tempValue8",
                "iVar16": "tempValue9",
                "bVar17": "isNegative",
                "MS5611_RawTemperature": "rawTemp",
                "MS5611_Coefficients": "coefficients",
                "MS5611_RawPressure": "rawPressure",
                "MS5611_CompensatedPressure": "compensatedPressureResult",
                "MS5611_CompensatedTemperature": "compensatedTemperatureResult",
                "MS5611_Altitude": "altitude",
                "alt_filter": "altFilter",
                "MS5611_FilteredAltitude": "filteredAltitudeResult",
                "msp_txf_altitude": "mspTxfAltitude",
                "temp_time": "tempTime",
                "PRESSURE_READY": "pressureReady",
                "I2C_WriteByte": "writeI2CByte",
                "millis": "getMillis",
                "MS5611_OSR": "osr",
                "pressure_time": "pressureTime",
                "MS5611_ReadADC": "readADC"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "__aeabi_f2d",
                "pow",
                "__truncdfsf2",
                "__aeabi_f2iz",
                "__aeabi_fdiv",
                "__addsf3",
                "__floatsisf",
                "__muldf3",
                "millis",
                "MS5611_ReadADC",
                "I2C_WriteByte",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003298": {
            "entrypoint": "0x08003298",
            "current_name": "initialize_ms5611_sensor_08003298",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeMS5611Sensor_08003298(void)\n\n{\n  int i;\n  int index;\n  uint8_t receiveBuffer [2];\n  \n  index = 0;\n  writeByteToI2C(0xee,0x1e,'\\x01','\\x01');\n  delayMilliseconds(10);\n  sensorOversamplingRate = '\\b';\n  do {\n    receiveBuffer[0] = '\\0';\n    receiveBuffer[1] = '\\0';\n    readByteArrayFromI2C(0xee,(short)index + 0xa0,receiveBuffer,2,\"../Src/MS5611.c\",0x7c);\n    *(ushort *)((int)sensorCoefficients + index) = concatenate(receiveBuffer[0],receiveBuffer[1]);\n    index = index + 2;\n  } while (index != 0x10);\n  index = 0;\n  do {\n    altitudeFilter[index] = 0.0;\n    index = index + 1;\n  } while (index != 0x14);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003298": "initialize_ms5611_sensor_08003298",
                "rxbuf": "receiveBuffer",
                "iVar1": "index",
                "I2C_WriteByte": "writeByteToI2C",
                "delay_ms": "delayMilliseconds",
                "MS5611_OSR": "sensorOversamplingRate",
                "I2C_ReadByteArray": "readByteArrayFromI2C",
                "MS5611_Coefficients": "sensorCoefficients",
                "CONCAT11": "concatenate",
                "alt_filter": "altitudeFilter"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "delay_ms",
                "I2C_WriteByte",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003314": {
            "entrypoint": "0x08003314",
            "current_name": "set_beta_08003314",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setBeta_08003314(float newBeta)\n\n{\n  currentBeta = newBeta;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003314": "set_beta_08003314",
                "_beta": "newBeta",
                "beta": "currentBeta"
            },
            "calling": [
                "IMU_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003320": {
            "entrypoint": "0x08003320",
            "current_name": "update_delta_time_08003320",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateDeltaTime_08003320(float deltaTime)\n\n{\n  deltat = deltaTime;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003320": "update_delta_time_08003320",
                "_deltat": "deltaTime"
            },
            "calling": [
                "AHRS_ComputeAngles",
                "IMU_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003330": {
            "entrypoint": "0x08003330",
            "current_name": "calculate_orientation_angles_08003330",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calculateOrientationAngles_08003330(float accelX,float accelY,float accelZ,float gyroX,float gyroY,float gyroZ,float magX,float magY,float magZ,\n                 float *orientationAngles)\n\n{\n  float normAccel;\n  float normMag;\n  undefined4 AXIS_SCALE;\n  undefined4 AYIS_SCALE;\n  float norm;\n  undefined4 AZIS_SCALE;\n  int isAccelNonZero;\n  undefined4 GXIS_SCALE;\n  undefined4 GYIS_SCALE;\n  undefined4 GZIS_SCALE;\n  int iVar10;\n  undefined4 fVar11;\n  undefined4 q0Squared;\n  undefined4 q1Squared;\n  undefined4 q2Squared;\n  undefined4 q3Squared;\n  undefined4 q0q1;\n  undefined4 q0q2;\n  undefined4 q0q3;\n  undefined4 q1q1;\n  undefined4 q1q2;\n  int q1q3;\n  float _2q1mX;\n  undefined4 _2q1mY;\n  float _2q1mY;\n  undefined4 _2q1mZ;\n  float _2q1mZ;\n  undefined4 _2q2mX;\n  float _2q2mX;\n  undefined4 q0q0MinusHalf;\n  undefined4 _2bx;\n  undefined4 uVar27;\n  int iVar28;\n  float _2bX;\n  float _2bZ;\n  float _4bZ;\n  float s1;\n  float s2;\n  float s3;\n  float s4;\n  float q0;\n  float q1;\n  float q2;\n  float q3;\n  float q4;\n  float q5;\n  float q6;\n  undefined8 fVar32;\n  undefined8 fVar33;\n  undefined4 fVar34;\n  float fVar34;\n  float fYh;\n  float fXh;\n  \n  q2 = q[3];\n  q1 = q[2];\n  q0 = q[0];\n  fVar34 = q[1];\n  AXIS_SCALE = __aeabi_fmul(accelX,accelX);\n  AYIS_SCALE = __aeabi_fmul(accelY);\n  AXIS_SCALE = __addsf3(AXIS_SCALE,AYIS_SCALE);\n  AYIS_SCALE = __aeabi_fmul(accelZ);\n  __addsf3(AXIS_SCALE,AYIS_SCALE);\n  __aeabi_f2d();\n  sqrt((double)CONCAT44(fVar34,fVar34));\n  AXIS_SCALE = __truncdfsf2();\n  norm = (float)__aeabi_fcmpeq(AXIS_SCALE,0);\n  if (norm == 0.0) {\n    AYIS_SCALE = __aeabi_fmul(magX);\n    AZIS_SCALE = __aeabi_fmul(magY);\n    AYIS_SCALE = __addsf3(AYIS_SCALE,AZIS_SCALE);\n    AZIS_SCALE = __aeabi_fmul(magZ);\n    __addsf3(AYIS_SCALE,AZIS_SCALE);\n    __aeabi_f2d();\n    sqrt((double)CONCAT44(fVar34,fVar34));\n    AYIS_SCALE = __truncdfsf2();\n    isAccelNonZero = __aeabi_fcmpeq(AYIS_SCALE,0);\n    if (isAccelNonZero == 0) {\n      fVar32 = __aeabi_f2d(gyroX);\n      __muldf3((int)fVar32,(int)((ulonglong)fVar32 >> 0x20),0xa2529d39,0x3f91df46);\n      AZIS_SCALE = __truncdfsf2();\n      fVar32 = __aeabi_f2d(gyroY);\n      __muldf3((int)fVar32,(int)((ulonglong)fVar32 >> 0x20),0xa2529d39,0x3f91df46);\n      GXIS_SCALE = __truncdfsf2();\n      fVar32 = __aeabi_f2d(gyroZ);\n      __muldf3((int)fVar32,(int)((ulonglong)fVar32 >> 0x20),0xa2529d39,0x3f91df46);\n      GYIS_SCALE = __truncdfsf2();\n      isAccelNonZero = __addsf3(q0);\n      GZIS_SCALE = __addsf3(fVar34);\n      iVar10 = __addsf3(q1,q1);\n      fVar11 = __addsf3(q2,q2);\n      q0Squared = __aeabi_fmul(q0);\n      q1Squared = __aeabi_fmul(q0,fVar34);\n      q2Squared = __aeabi_fmul(q0,q1);\n      q3Squared = __aeabi_fmul(fVar34);\n      q0q1 = __aeabi_fmul(fVar34,q2);\n      q0q2 = __aeabi_fmul(q1,q1);\n      q0q3 = __aeabi_fmul(q2,q2);\n      AXIS_SCALE = __aeabi_fdiv(0x3f800000,AXIS_SCALE);\n      AYIS_SCALE = __aeabi_fdiv(0x3f800000,AYIS_SCALE);\n      q1q1 = __aeabi_fmul(magX,AYIS_SCALE);\n      q1q2 = __aeabi_fmul(magY,AYIS_SCALE);\n      AYIS_SCALE = __aeabi_fmul(magZ,AYIS_SCALE);\n      q1q3 = __aeabi_fmul(isAccelNonZero,q1q1);\n      _2q1mY = __aeabi_fmul(isAccelNonZero,q1q2);\n      _2q1mZ = __aeabi_fmul(isAccelNonZero,AYIS_SCALE);\n      _2q2mX = __aeabi_fmul(GZIS_SCALE,q1q1);\n      q0q0MinusHalf = __aeabi_fmul(q0Squared,q1q1);\n      _2bx = __aeabi_fmul(q2,_2q1mY);\n      q0q0MinusHalf = __aeabi_fsub(q0q0MinusHalf,_2bx);\n      _2bx = __aeabi_fmul(q1,_2q1mZ);\n      q0q0MinusHalf = __addsf3(q0q0MinusHalf,_2bx);\n      _2bx = __aeabi_fmul(q3Squared,q1q1);\n      q0q0MinusHalf = __addsf3(q0q0MinusHalf,_2bx);\n      _2bx = __aeabi_fmul(GZIS_SCALE,q1q2);\n      _2bx = __aeabi_fmul(_2bx,q1);\n      q0q0MinusHalf = __addsf3(q0q0MinusHalf,_2bx);\n      _2bx = __aeabi_fmul(GZIS_SCALE,AYIS_SCALE);\n      _2bx = __aeabi_fmul(_2bx,q2);\n      q0q0MinusHalf = __addsf3(q0q0MinusHalf,_2bx);\n      _2bx = __aeabi_fmul(q0q2,q1q1);\n      q0q0MinusHalf = __aeabi_fsub(q0q0MinusHalf,_2bx);\n      _2bx = __aeabi_fmul(q0q3,q1q1);\n      q0q0MinusHalf = __aeabi_fsub(q0q0MinusHalf,_2bx);\n      _2bx = __aeabi_fmul(q2,q1q3);\n      uVar27 = __aeabi_fmul(q0Squared,q1q2);\n      _2bx = __addsf3(_2bx,uVar27);\n      _2q1mZ = __aeabi_fmul(fVar34,_2q1mZ);\n      _2q1mZ = __aeabi_fsub(_2bx,_2q1mZ);\n      _2bx = __aeabi_fmul(q1,_2q2mX);\n      _2q1mZ = __addsf3(_2q1mZ,_2bx);\n      _2bx = __aeabi_fmul(q3Squared,q1q2);\n      _2q1mZ = __aeabi_fsub(_2q1mZ,_2bx);\n      _2bx = __aeabi_fmul(q0q2,q1q2);\n      _2q1mZ = __addsf3(_2q1mZ,_2bx);\n      _2bx = __aeabi_fmul(iVar10,AYIS_SCALE);\n      _2bx = __aeabi_fmul(_2bx,q2);\n      _2q1mZ = __addsf3(_2q1mZ,_2bx);\n      _2bx = __aeabi_fmul(q0q3,q1q2);\n      _2q1mZ = __aeabi_fsub(_2q1mZ,_2bx);\n      q0q0MinusHalf = __aeabi_fmul(q0q0MinusHalf,q0q0MinusHalf);\n      _2q1mZ = __aeabi_fmul(_2q1mZ,_2q1mZ);\n      __addsf3(q0q0MinusHalf,_2q1mZ);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(fVar34,fVar34));\n      iVar28 = __truncdfsf2();\n      _2q1mZ = __aeabi_fmul(q1q3 + -0x80000000,q1);\n      _2q1mY = __aeabi_fmul(fVar34,_2q1mY);\n      _2q1mY = __addsf3(_2q1mZ,_2q1mY);\n      q0Squared = __aeabi_fmul(q0Squared,AYIS_SCALE);\n      q0Squared = __addsf3(_2q1mY,q0Squared);\n      _2q1mY = __aeabi_fmul(q2,_2q2mX);\n      q0Squared = __addsf3(q0Squared,_2q1mY);\n      _2q1mY = __aeabi_fmul(q3Squared,AYIS_SCALE);\n      q0Squared = __aeabi_fsub(q0Squared,_2q1mY);\n      _2q1mY = __aeabi_fmul(iVar10,q1q2);\n      _2q1mY = __aeabi_fmul(_2q1mY,q2);\n      q0Squared = __addsf3(q0Squared,_2q1mY);\n      _2q1mY = __aeabi_fmul(q0q2,AYIS_SCALE);\n      q0Squared = __aeabi_fsub(q0Squared,_2q1mY);\n      _2q1mY = __aeabi_fmul(q0q3,AYIS_SCALE);\n      q0Squared = __addsf3(q0Squared,_2q1mY);\n      _2bZ = (float)__addsf3(q0Squared,q0Squared);\n      _2q1mY = __addsf3(q0q1);\n      _2q1mZ = __aeabi_fmul(q1,isAccelNonZero);\n      _2q1mY = __aeabi_fsub(_2q1mY,_2q1mZ);\n      _2q1mZ = __aeabi_fmul(accelX,AXIS_SCALE);\n      _2q1mY = __aeabi_fsub(_2q1mY,_2q1mZ);\n      _2q1mZ = __aeabi_fmul(q2,iVar10);\n      _2q2mX = __addsf3(q1Squared);\n      _2q1mZ = __addsf3(_2q1mZ,_2q2mX);\n      _2q2mX = __aeabi_fmul(accelY,AXIS_SCALE);\n      _2q1mZ = __aeabi_fsub(_2q1mZ,_2q2mX);\n      _2q2mX = __aeabi_fmul(q1,q0Squared);\n      q0q0MinusHalf = __aeabi_fsub(0x3f000000,q0q2);\n      q0q3 = __aeabi_fsub(q0q0MinusHalf,q0q3);\n      q0q3 = __aeabi_fmul(q0q3,iVar28);\n      q0q0MinusHalf = __aeabi_fsub(q0q1,q2Squared);\n      q0q0MinusHalf = __aeabi_fmul(q0q0MinusHalf,q0Squared);\n      q0q3 = __addsf3(q0q3,q0q0MinusHalf);\n      q0q3 = __aeabi_fsub(q0q3,q1q1);\n      q1q1 = __aeabi_fmul(fVar34,q0Squared);\n      q0q0MinusHalf = __aeabi_fmul(fVar34,q1);\n      _2bx = __aeabi_fmul(q0,q2);\n      q0q0MinusHalf = __aeabi_fsub(q0q0MinusHalf,_2bx);\n      q0q0MinusHalf = __aeabi_fmul(q0q0MinusHalf,iVar28);\n      _2bx = __aeabi_fmul(q1,q2);\n      q1Squared = __addsf3(_2bx,q1Squared);\n      q1Squared = __aeabi_fmul(q1Squared,q0Squared);\n      q1Squared = __addsf3(q0q0MinusHalf,q1Squared);\n      q1Squared = __aeabi_fsub(q1Squared,q1q2);\n      q1q2 = __aeabi_fmul(q1,iVar28);\n      q0q0MinusHalf = __aeabi_fsub(0x3f000000,q3Squared);\n      q0q0MinusHalf = __aeabi_fsub(q0q0MinusHalf,q0q2);\n      q0q0MinusHalf = __aeabi_fmul(q0q0MinusHalf,q0Squared);\n      q2Squared = __addsf3(q2Squared,q0q1);\n      q2Squared = __aeabi_fmul(q2Squared,iVar28);\n      q2Squared = __addsf3(q0q0MinusHalf,q2Squared);\n      AYIS_SCALE = __aeabi_fsub(q2Squared,AYIS_SCALE);\n      q2Squared = __aeabi_fmul(iVar10 + -0x80000000,_2q1mY);\n      q0q1 = __aeabi_fmul(GZIS_SCALE,_2q1mZ);\n      q2Squared = __addsf3(q2Squared,q0q1);\n      q0q1 = __aeabi_fmul(_2q2mX,q0q3);\n      q2Squared = __aeabi_fsub(q2Squared,q0q1);\n      q0q1 = __aeabi_fmul(q2,iVar28 + -0x80000000);\n      q0q1 = __addsf3(q0q1,q1q1);\n      q0q1 = __aeabi_fmul(q0q1,q1Squared);\n      q2Squared = __addsf3(q2Squared,q0q1);\n      q0q1 = __aeabi_fmul(q1q2,AYIS_SCALE);\n      q2Squared = __addsf3(q2Squared,q0q1);\n      q3Squared = __addsf3(q3Squared);\n      q3Squared = __aeabi_fsub(0x3f800000,q3Squared);\n      q0q1 = __addsf3(q0q2);\n      q3Squared = __aeabi_fsub(q3Squared,q0q1);\n      AXIS_SCALE = __aeabi_fmul(accelZ,AXIS_SCALE);\n      AXIS_SCALE = __aeabi_fsub(q3Squared,AXIS_SCALE);\n      q3Squared = __aeabi_fmul(q2,q0Squared);\n      q0Squared = __aeabi_fmul(q0,q0Squared);\n      q0q1 = __aeabi_fmul(fVar11,_2q1mY);\n      q0q2 = __aeabi_fmul(isAccelNonZero,_2q1mZ);\n      q0q1 = __addsf3(q0q1,q0q2);\n      q0q2 = __aeabi_fmul(fVar34,0x40800000);\n      q0q2 = __aeabi_fmul(q0q2,AXIS_SCALE);\n      q0q1 = __aeabi_fsub(q0q1,q0q2);\n      q0q2 = __aeabi_fmul(q0q3,q3Squared);\n      q0q1 = __addsf3(q0q1,q0q2);\n      q0q2 = __addsf3(q1q2,q0Squared);\n      q0q2 = __aeabi_fmul(q0q2,q1Squared);\n      q0q1 = __addsf3(q0q1,q0q2);\n      q0q2 = __aeabi_fmul(q2,iVar28);\n      q1q2 = __aeabi_fmul(fVar34,_2bZ);\n      q0q2 = __aeabi_fsub(q0q2,q1q2);\n      q0q2 = __aeabi_fmul(q0q2,AYIS_SCALE);\n      q0q1 = __addsf3(q0q1,q0q2);\n      q1q3 = __addsf3(iVar28,iVar28);\n      q0q2 = __aeabi_fmul(fVar34,iVar28);\n      q1q2 = __aeabi_fmul(isAccelNonZero + -0x80000000,_2q1mY);\n      fVar11 = __aeabi_fmul(fVar11,_2q1mZ);\n      fVar11 = __addsf3(q1q2,fVar11);\n      q1q2 = __aeabi_fmul(q1,0x40800000);\n      AXIS_SCALE = __aeabi_fmul(q1q2,AXIS_SCALE);\n      AXIS_SCALE = __aeabi_fsub(fVar11,AXIS_SCALE);\n      fVar11 = __aeabi_fmul(q1,q1q3 + -0x80000000);\n      fVar11 = __aeabi_fsub(fVar11,q0Squared);\n      fVar11 = __aeabi_fmul(fVar11,q0q3);\n      AXIS_SCALE = __addsf3(AXIS_SCALE,fVar11);\n      fVar11 = __addsf3(q3Squared,q0q2);\n      fVar11 = __aeabi_fmul(fVar11,q1Squared);\n      AXIS_SCALE = __addsf3(AXIS_SCALE,fVar11);\n      fVar11 = __aeabi_fmul(q0,iVar28);\n      q0Squared = __aeabi_fmul(q1,_2bZ);\n      fVar11 = __aeabi_fsub(fVar11,q0Squared);\n      fVar11 = __aeabi_fmul(fVar11,AYIS_SCALE);\n      AXIS_SCALE = __addsf3(AXIS_SCALE,fVar11);\n      GZIS_SCALE = __aeabi_fmul(GZIS_SCALE,_2q1mY);\n      fVar11 = __aeabi_fmul(iVar10,_2q1mZ);\n      GZIS_SCALE = __addsf3(GZIS_SCALE,fVar11);\n      fVar11 = __aeabi_fmul(q2,q1q3 + -0x80000000);\n      fVar11 = __addsf3(fVar11,q1q1);\n      fVar11 = __aeabi_fmul(fVar11,q0q3);\n      GZIS_SCALE = __addsf3(GZIS_SCALE,fVar11);\n      fVar11 = __aeabi_fmul(q0,iVar28 + -0x80000000);\n      fVar11 = __addsf3(fVar11,_2q2mX);\n      fVar11 = __aeabi_fmul(fVar11,q1Squared);\n      GZIS_SCALE = __addsf3(GZIS_SCALE,fVar11);\n      AYIS_SCALE = __aeabi_fmul(AYIS_SCALE,q0q2);\n      AYIS_SCALE = __addsf3(GZIS_SCALE,AYIS_SCALE);\n      GZIS_SCALE = __aeabi_fmul(q2Squared);\n      fVar11 = __aeabi_fmul(q0q1);\n      GZIS_SCALE = __addsf3(GZIS_SCALE,fVar11);\n      fVar11 = __aeabi_fmul(AXIS_SCALE,AXIS_SCALE);\n      GZIS_SCALE = __addsf3(GZIS_SCALE,fVar11);\n      fVar11 = __aeabi_fmul(AYIS_SCALE,AYIS_SCALE);\n      __addsf3(GZIS_SCALE,fVar11);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(fVar34,fVar34));\n      GZIS_SCALE = __truncdfsf2();\n      GZIS_SCALE = __aeabi_fdiv(0x3f800000,GZIS_SCALE);\n      normAccel = beta;\n      fVar11 = __aeabi_fmul((int)fVar34 + -0x80000000,AZIS_SCALE);\n      q0Squared = __aeabi_fmul(q1,GXIS_SCALE);\n      fVar11 = __aeabi_fsub(fVar11,q0Squared);\n      q0Squared = __aeabi_fmul(q2,GYIS_SCALE);\n      fVar11 = __aeabi_fsub(fVar11,q0Squared);\n      fVar11 = __aeabi_fmul(fVar11,0x3f000000);\n      q0Squared = __aeabi_fmul(q2Squared,GZIS_SCALE);\n      normMag = deltat;\n      q0Squared = __aeabi_fmul(q0Squared,normAccel);\n      fVar11 = __aeabi_fsub(fVar11,q0Squared);\n      fVar11 = __aeabi_fmul(fVar11,normMag);\n      fVar11 = __addsf3(fVar11,q0);\n      q0Squared = __aeabi_fmul(q0,AZIS_SCALE);\n      q1Squared = __aeabi_fmul(q1,GYIS_SCALE);\n      normMag = deltat;\n      q0Squared = __addsf3(q0Squared,q1Squared);\n      q1Squared = __aeabi_fmul(q2,GXIS_SCALE);\n      q0Squared = __aeabi_fsub(q0Squared,q1Squared);\n      q0Squared = __aeabi_fmul(q0Squared,0x3f000000);\n      q1Squared = __aeabi_fmul(q0q1,GZIS_SCALE);\n      q1Squared = __aeabi_fmul(q1Squared,normAccel);\n      q0Squared = __aeabi_fsub(q0Squared,q1Squared);\n      q0Squared = __aeabi_fmul(q0Squared,normMag);\n      q0Squared = __addsf3(q0Squared,fVar34);\n      normMag = deltat;\n      q1Squared = __aeabi_fmul(q0,GXIS_SCALE);\n      q2Squared = __aeabi_fmul(fVar34,GYIS_SCALE);\n      q1Squared = __aeabi_fsub(q1Squared,q2Squared);\n      q2Squared = __aeabi_fmul(q2,AZIS_SCALE);\n      q1Squared = __addsf3(q1Squared,q2Squared);\n      q1Squared = __aeabi_fmul(q1Squared,0x3f000000);\n      AXIS_SCALE = __aeabi_fmul(AXIS_SCALE,GZIS_SCALE);\n      AXIS_SCALE = __aeabi_fmul(AXIS_SCALE,normAccel);\n      AXIS_SCALE = __aeabi_fsub(q1Squared,AXIS_SCALE);\n      AXIS_SCALE = __aeabi_fmul(AXIS_SCALE,normMag);\n      AXIS_SCALE = __addsf3(AXIS_SCALE,q1);\n      GYIS_SCALE = __aeabi_fmul(q0,GYIS_SCALE);\n      GXIS_SCALE = __aeabi_fmul(fVar34,GXIS_SCALE);\n      GXIS_SCALE = __addsf3(GYIS_SCALE,GXIS_SCALE);\n      AZIS_SCALE = __aeabi_fmul(q1,AZIS_SCALE);\n      AZIS_SCALE = __aeabi_fsub(GXIS_SCALE,AZIS_SCALE);\n      AZIS_SCALE = __aeabi_fmul(AZIS_SCALE,0x3f000000);\n      AYIS_SCALE = __aeabi_fmul(AYIS_SCALE,GZIS_SCALE);\n      AYIS_SCALE = __aeabi_fmul(AYIS_SCALE,normAccel);\n      q0 = deltat;\n      AYIS_SCALE = __aeabi_fsub(AZIS_SCALE,AYIS_SCALE);\n      AYIS_SCALE = __aeabi_fmul(AYIS_SCALE,q0);\n      AYIS_SCALE = __addsf3(AYIS_SCALE,q2);\n      AZIS_SCALE = __aeabi_fmul(fVar11,fVar11);\n      GYIS_SCALE = __aeabi_fmul(q0Squared,q0Squared);\n      AZIS_SCALE = __addsf3(AZIS_SCALE,GYIS_SCALE);\n      GYIS_SCALE = __aeabi_fmul(AXIS_SCALE,AXIS_SCALE);\n      AZIS_SCALE = __addsf3(AZIS_SCALE,GYIS_SCALE);\n      GYIS_SCALE = __aeabi_fmul(AYIS_SCALE,AYIS_SCALE);\n      __addsf3(AZIS_SCALE,GYIS_SCALE);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(GXIS_SCALE,fVar34));\n      AZIS_SCALE = __truncdfsf2();\n      AZIS_SCALE = __aeabi_fdiv(0x3f800000,AZIS_SCALE);\n      q0 = (float)__aeabi_fmul(fVar11,AZIS_SCALE);\n      q[0] = q0;\n      q1 = (float)__aeabi_fmul(q0Squared,AZIS_SCALE);\n      q[1] = q1;\n      q2 = (float)__aeabi_fmul(AXIS_SCALE,AZIS_SCALE);\n      q[2] = q2;\n      q[3] = (float)__aeabi_fmul(AYIS_SCALE,AZIS_SCALE);\n      AXIS_SCALE = __aeabi_fmul(q1,q[3]);\n      AYIS_SCALE = __aeabi_fmul(q0,q2);\n      AXIS_SCALE = __aeabi_fsub(AXIS_SCALE,AYIS_SCALE);\n      __addsf3(AXIS_SCALE,AXIS_SCALE);\n      __aeabi_f2d();\n      asin((double)CONCAT44(GXIS_SCALE,fVar34));\n      fVar32 = __muldf3();\n      __divdf3((int)fVar32,(int)((ulonglong)fVar32 >> 0x20),0x54442d18,0x400921fb);\n      q0 = (float)__truncdfsf2();\n      *orientationAngles = q0;\n      q1 = q[1];\n      q0 = q[0];\n      AXIS_SCALE = __aeabi_fmul(q[0],q[0]);\n      AYIS_SCALE = __aeabi_fmul(q1,q1);\n      AXIS_SCALE = __aeabi_fsub(AXIS_SCALE,AYIS_SCALE);\n      q2 = q[2];\n      AYIS_SCALE = __aeabi_fmul(q[2],q[2]);\n      AXIS_SCALE = __aeabi_fsub(AXIS_SCALE,AYIS_SCALE);\n      fVar34 = q[3];\n      AYIS_SCALE = __aeabi_fmul(q[3],q[3]);\n      __addsf3(AXIS_SCALE,AYIS_SCALE);\n      fVar32 = __aeabi_f2d();\n      AXIS_SCALE = __aeabi_fmul(q0,q1);\n      AYIS_SCALE = __aeabi_fmul(q2,fVar34);\n      AXIS_SCALE = __addsf3(AXIS_SCALE,AYIS_SCALE);\n      __addsf3(AXIS_SCALE,AXIS_SCALE);\n      fVar33 = __aeabi_f2d();\n      fVar32 = atan2((int)fVar33,(int)((ulonglong)fVar33 >> 0x20),(int)fVar32,\n                     (int)((ulonglong)fVar32 >> 0x20));\n      fVar32 = __muldf3((int)fVar32,(int)((ulonglong)fVar32 >> 0x20),0,0x40668000);\n      __divdf3((int)fVar32,(int)((ulonglong)fVar32 >> 0x20),0x54442d18,0x400921fb);\n      q0 = (float)__truncdfsf2();\n      orientationAngles[1] = q0;\n      q1 = q[1];\n      q0 = q[0];\n      AXIS_SCALE = __aeabi_fmul(q[0],q[0]);\n      AYIS_SCALE = __aeabi_fmul(q1,q1);\n      AXIS_SCALE = __addsf3(AXIS_SCALE,AYIS_SCALE);\n      q2 = q[2];\n      AYIS_SCALE = __aeabi_fmul(q[2],q[2]);\n      AXIS_SCALE = __aeabi_fsub(AXIS_SCALE,AYIS_SCALE);\n      fVar34 = q[3];\n      AYIS_SCALE = __aeabi_fmul(q[3],q[3]);\n      __aeabi_fsub(AXIS_SCALE,AYIS_SCALE);\n      fVar32 = __aeabi_f2d();\n      AXIS_SCALE = __aeabi_fmul(q1,q2);\n      AYIS_SCALE = __aeabi_fmul(q0,fVar34);\n      AXIS_SCALE = __addsf3(AXIS_SCALE,AYIS_SCALE);\n      __addsf3(AXIS_SCALE,AXIS_SCALE);\n      fVar33 = __aeabi_f2d();\n      fVar32 = atan2((int)fVar33,(int)((ulonglong)fVar33 >> 0x20),(int)fVar32,\n                     (int)((ulonglong)fVar32 >> 0x20));\n      fVar32 = __muldf3((int)fVar32,(int)((ulonglong)fVar32 >> 0x20),0,0x40668000);\n      __divdf3((int)fVar32,(int)((ulonglong)fVar32 >> 0x20),0x54442d18,0x400921fb);\n      q0 = (float)__truncdfsf2();\n      orientationAngles[2] = q0;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003330": "calculate_orientation_angles_08003330",
                "ax": "accelX",
                "ay": "accelY",
                "az": "accelZ",
                "gx": "gyroX",
                "gy": "gyroY",
                "gz": "gyroZ",
                "mx": "magX",
                "my": "magY",
                "mz": "magZ",
                "angle": "orientationAngles",
                "fVar1": "normAccel",
                "fVar2": "normMag",
                "uVar3": "AXIS_SCALE",
                "uVar4": "AYIS_SCALE",
                "uVar5": "AZIS_SCALE",
                "iVar6": "isAccelNonZero",
                "uVar7": "GXIS_SCALE",
                "uVar8": "GYIS_SCALE",
                "uVar9": "GZIS_SCALE",
                "uVar11": "fVar11",
                "uVar12": "q0Squared",
                "uVar13": "q1Squared",
                "uVar14": "q2Squared",
                "uVar15": "q3Squared",
                "uVar16": "q0q1",
                "uVar17": "q0q2",
                "uVar18": "q0q3",
                "uVar19": "q1q1",
                "uVar20": "q1q2",
                "iVar21": "q1q3",
                "_2q1mx": "_2q1mX",
                "uVar22": "_2q1mY",
                "_2q1my": "_2q1mY",
                "uVar23": "_2q1mZ",
                "_2q1mz": "_2q1mZ",
                "uVar24": "_2q2mX",
                "_2q2mx": "_2q2mX",
                "uVar25": "q0q0MinusHalf",
                "_2bx": "_2bX",
                "uVar26": "_2bx",
                "_2bz": "_2bZ",
                "_4bz": "_4bZ",
                "fVar29": "q0",
                "fVar30": "q1",
                "fVar31": "q2",
                "q1": "q3",
                "q2": "q4",
                "q4": "q5",
                "q3": "q6",
                "uVar32": "fVar32",
                "uVar33": "fVar33",
                "in_stack_ffffff78": "fVar34",
                "hy": "fYh",
                "hx": "fXh"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__aeabi_f2d",
                "__truncdfsf2",
                "__aeabi_fdiv",
                "__aeabi_fcmpeq",
                "__addsf3",
                "__aeabi_fsub",
                "__muldf3",
                "__aeabi_fmul",
                "atan2",
                "sqrt",
                "__divdf3",
                "asin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003eac": {
            "entrypoint": "0x08003eac",
            "current_name": "execute_system_call_08003eac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_system_call_08003eac(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_08003eac": "execute_system_call_08003eac"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003eb0": {
            "entrypoint": "0x08003eb0",
            "current_name": "hyper_call_08003eb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint hyper_call_08003eb0(int num_ticks)\n\n{\n  uint32_t afl_result;\n  \n  if (noHyperCall == 0) {\n    afl_result = aflCall(1,num_ticks,0);\n    return afl_result;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08003eb0": "hyper_call_08003eb0",
                "ticks": "num_ticks",
                "uVar1": "afl_result"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ec8": {
            "entrypoint": "0x08003ec8",
            "current_name": "append_to_circular_buffer_08003ec8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint appendToCircularBuffer_08003ec8(CircularBuffer *cb,uint8_t newData)\n\n{\n  cb->size = cb->size + 1;\n  cb->buffer[cb->tail] = newData;\n  cb->tail = cb->tail + 1 & 0x7ff;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08003ec8": "append_to_circular_buffer_08003ec8",
                "data": "newData"
            },
            "calling": [
                "HAL_UART_RxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ef2": {
            "entrypoint": "0x08003ef2",
            "current_name": "initialize_circular_buffer_08003ef2",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd initializeCircularBuffer_08003ef2(CindexrcularBuffer *cb)\n\n{\n  indexnt index;\n  \n  index = 0;\n  cb->head = 0;\n  cb->taindexl = 0;\n  cb->sindexze = 0;\n  do {\n    cb->buffer[index] = '\\0';\n    index = index + 1;\n  } whindexle (index != 0x800);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ef2": "initialize_circular_buffer_08003ef2",
                "i": "index"
            },
            "calling": [
                "serialFlush"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f0e": {
            "entrypoint": "0x08003f0e",
            "current_name": "update_last_and_return_08003f0e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat updateLastAndReturn_08003f0e(LPF *inputData,float newValue)\n\n{\n  undefined4 difference;\n  undefined4 product;\n  float betaValue;\n  float result;\n  \n  betaValue = inputData->beta;\n  difference = __aeabi_fsub(0x3f800000,betaValue);\n  difference = __aeabi_fmul(difference,newValue);\n  product = __aeabi_fmul(betaValue,inputData->last);\n  betaValue = (float)__addsf3(product,difference);\n  inputData->last = betaValue;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003f0e": "update_last_and_return_08003f0e",
                "var": "inputData",
                "current": "newValue",
                "uVar1": "difference",
                "uVar2": "product",
                "fVar3": "betaValue",
                "extraout_s0": "result"
            },
            "calling": [
                "AHRS_GetRoll",
                "AHRS_GetPitch"
            ],
            "called": [
                "__addsf3",
                "__aeabi_fsub",
                "__aeabi_fmul"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f3c": {
            "entrypoint": "0x08003f3c",
            "current_name": "set_led_colors_08003f3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_led_colors_08003f3c(int is_white_led_on,int is_red_led_on,int is_blue_led_on)\n\n{\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x8000,is_white_led_on == 0);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x4000,is_red_led_on == 0);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x2000,is_blue_led_on == 0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f3c": "set_led_colors_08003f3c",
                "led_white": "is_white_led_on",
                "led_red": "is_red_led_on",
                "led_blue": "is_blue_led_on"
            },
            "calling": [
                "PID_Update",
                "LED_StartupSequence"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f7c": {
            "entrypoint": "0x08003f7c",
            "current_name": "blink_le_ds_08003f7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid blinkLEDs_08003f7c(void)\n\n{\n  int count;\n  \n  count = 3;\n  do {\n    changeLEDs(1,0,0);\n    delayMilliseconds(100);\n    changeLEDs(0,1,0);\n    delayMilliseconds(100);\n    changeLEDs(0,0,1);\n    delayMilliseconds(100);\n    count = count + -1;\n  } while (count != 0);\n  changeLEDs(1,1,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f7c": "blink_le_ds_08003f7c",
                "iVar1": "count",
                "toggleLED": "changeLEDs",
                "delay_ms": "delayMilliseconds"
            },
            "calling": [
                "Devices_Init"
            ],
            "called": [
                "toggleLED",
                "delay_ms"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fc4": {
            "entrypoint": "0x08003fc4",
            "current_name": "set_pwm_value_08003fc4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_pwm_value_08003fc4(int new_pwm_value)\n\n{\n  (htim4.Instance)->CCR4 = new_pwm_value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fc4": "set_pwm_value_08003fc4",
                "pwm": "new_pwm_value"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fd0": {
            "entrypoint": "0x08003fd0",
            "current_name": "set_pwm_08003fd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_pwm_08003fd0(int pwm_value)\n\n{\n  (htim4.Instance)->CCR3 = pwm_value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fd0": "set_pwm_08003fd0",
                "pwm": "pwm_value"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fdc": {
            "entrypoint": "0x08003fdc",
            "current_name": "FUNC_08003fdc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003fdc(int pwm)\n\n{\n  (htim2.Instance)->CCR2 = pwm;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fdc": "FUNC_08003fdc"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003fe8": {
            "entrypoint": "0x08003fe8",
            "current_name": "set_pwm_value_08003fe8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_pwm_value_08003fe8(int new_pwm_value)\n\n{\n  (htim3.Instance)->CCR3 = new_pwm_value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fe8": "set_pwm_value_08003fe8",
                "pwm": "new_pwm_value"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ff4": {
            "entrypoint": "0x08003ff4",
            "current_name": "initialize_pwm_08003ff4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_PWM_08003ff4(void)\n\n{\n  HAL_TIM_PWM_Start(TIM2_handler,4);\n  HAL_TIM_PWM_Start(TIM3_handler,8);\n  HAL_TIM_PWM_Start(TIM4_handler,8);\n  HAL_TIM_PWM_Start(TIM4_handler,0xc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ff4": "initialize_pwm_08003ff4",
                "&htim2": "TIM2_handler",
                "&htim3": "TIM3_handler",
                "&htim4": "TIM4_handler"
            },
            "calling": [
                "Devices_Init"
            ],
            "called": [
                "HAL_TIM_PWM_Start"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004028": {
            "entrypoint": "0x08004028",
            "current_name": "initialize_peripherals_08004028",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_peripherals_08004028(void)\n\n{\n  initialize_peripherals_08004028();\n  initialize_pwm();\n  run_led_startup_sequence();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004028": "initialize_peripherals_08004028",
                "Peripherals_Init": "initialize_peripherals",
                "PWM_Init": "initialize_pwm",
                "LED_StartupSequence": "run_led_startup_sequence"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "Peripherals_Init",
                "LED_StartupSequence",
                "PWM_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800403c": {
            "entrypoint": "0x0800403c",
            "current_name": "write_to_i2_c_device_0800403c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid writeToI2CDevice_0800403c(uint16_t deviceAddress,uint16_t registerAddress,uint8_t registerValue,uint8_t delayMode)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t returnValue;\n  uint8_t dataBuffer [1];\n  \n  dataBuffer[0] = registerValue;\n  status = HAL_I2C_Mem_Write(&hi2c1,deviceAddress,registerAddress,1,dataBuffer,1,200);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../Src/i2c.c\",0x1b);\n  }\n  if (delayMode != '\\0') {\n    delay_ms(0x32);\n  }\n  returnValueurn;\n}\n\n",
            "renaming": {
                "FUN_0800403c": "write_to_i2_c_device_0800403c",
                "device_add": "deviceAddress",
                "register_add": "registerAddress",
                "register_val": "registerValue",
                "delay_mode": "delayMode",
                "HVar1": "status",
                "ret": "returnValue",
                "byte": "dataBuffer"
            },
            "calling": [
                "MPU9250_Init",
                "AK8963_Init",
                "MS5611_Init",
                "MS5611_Update"
            ],
            "called": [
                "delay_ms",
                "HAL_I2C_Mem_Write",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800407c": {
            "entrypoint": "0x0800407c",
            "current_name": "read_i2_c_memory_0800407c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t read_I2C_memory_0800407c(uint16_t device_address,uint16_t register_address,char *source_file,int line_number)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t result;\n  uint8_t data [1];\n  \n  data[0] = '\\0';\n  status = HAL_I2C_Mem_Read(&hi2c1,device_address,register_address,1,data,1,200);\n  if (status != HAL_OK) {\n    _Error_Handler(source_file,line_number);\n  }\n  resulturn data[0];\n}\n\n",
            "renaming": {
                "FUN_0800407c": "read_i2_c_memory_0800407c",
                "device_add": "device_address",
                "register_add": "register_address",
                "file": "source_file",
                "line": "line_number",
                "HVar1": "status",
                "ret": "result",
                "byte": "data"
            },
            "calling": [
                "MPU9250_Init",
                "AK8963_Init",
                "AK8963_ReadData",
                "I2C_ReadByteArray"
            ],
            "called": [
                "HAL_I2C_Mem_Read",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040b8": {
            "entrypoint": "0x080040b8",
            "current_name": "read_i2_c_data_080040b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readI2CData_080040b8(uint16_t deviceAddress,uint16_t registerAddress,uint8_t *data,uint16_t dataSize,char *fileName,\n                 int lineNumber)\n\n{\n  HAL_StatusTypeDef readStatus;\n  uint8_t returnValue;\n  \n  readStatus = HAL_I2C_Mem_Read(&hi2c1,deviceAddress,registerAddress,1,data,dataSize,200);\n  if (readStatus != HAL_OK) {\n    _Error_Handler(fileName,lineNumber);\n    returnValueurn;\n  }\n  returnValueurn;\n}\n\n",
            "renaming": {
                "FUN_080040b8": "read_i2_c_data_080040b8",
                "device_add": "deviceAddress",
                "register_add": "registerAddress",
                "bytes": "data",
                "size": "dataSize",
                "file": "fileName",
                "line": "lineNumber",
                "HVar1": "readStatus",
                "ret": "returnValue"
            },
            "calling": [
                "MS5611_ReadADC"
            ],
            "called": [
                "HAL_I2C_Mem_Read",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e8": {
            "entrypoint": "0x080040e8",
            "current_name": "read_from_i2_c_device_080040e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readFromI2CDevice_080040e8(uint16_t deviceAddress,uint16_t registerAddress,uint8_t *dataArray,uint16_t dataSize,\n                 char *sourceFile,int lineNumber)\n\n{\n  uint8_t readValue;\n  int index;\n  uint8_t *currentData;\n  \n  currentData = dataArray + -1;\n  for (index = 0; index < (int)(uint)dataSize; index = index + 1) {\n    readValue = I2C_ReadByte(deviceAddress,registerAddress + (short)index,\"../Src/i2c.c\",0x4c);\n    currentData = currentData + 1;\n    *currentData = readValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040e8": "read_from_i2_c_device_080040e8",
                "device_add": "deviceAddress",
                "register_add": "registerAddress",
                "byte_array": "dataArray",
                "size": "dataSize",
                "file": "sourceFile",
                "line": "lineNumber",
                "uVar1": "readValue",
                "iVar2": "index",
                "puVar3": "currentData"
            },
            "calling": [
                "AK8963_Init",
                "MS5611_Init",
                "MPU9250_ReadAccelData",
                "AK8963_ReadData",
                "MPU9250_ReadGyroData"
            ],
            "called": [
                "I2C_ReadByte"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800411c": {
            "entrypoint": "0x0800411c",
            "current_name": "update_sensor_data_0800411c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid update_sensor_data_0800411c(void)\n\n{\n  uint32_t current_time;\n  \n  current_time = millis();\n  if (1 < current_time - previous_tick1) {\n    previous_tick1 = millis();\n    AHRS_ComputeAngles();\n  }\n  current_time = millis();\n  if (2 < current_time - previous_tick3) {\n    previous_tick3 = millis();\n    PID_Update();\n  }\n  current_time = millis();\n  if (3 < current_time - previous_tick2) {\n    previous_tick2 = millis();\n    MSP_SendIdent();\n    MSP_SendStatus();\n    MSP_SendMotor();\n    MSP_SendAttitude();\n    MSP_SendAltitude();\n    MSP_SendRawIMU();\n    MSP_SendPID();\n  }\n  MS5611_Update();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800411c": "update_sensor_data_0800411c",
                "uVar1": "current_time",
                "last_tick1": "previous_tick1",
                "last_tick3": "previous_tick3",
                "last_tick2": "previous_tick2"
            },
            "calling": [
                "main"
            ],
            "called": [
                "MSP_SendMotor",
                "PID_Update",
                "MSP_SendAttitude",
                "MSP_SendAltitude",
                "MSP_SendStatus",
                "AHRS_ComputeAngles",
                "MSP_SendPID",
                "millis",
                "MSP_SendIdent",
                "MS5611_Update",
                "MSP_SendRawIMU"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004194": {
            "entrypoint": "0x08004194",
            "current_name": "initialize_system_08004194",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_08004194(void)\n\n{\n  initializeDevices();\n  initializeSerialConnection();\n  initializeIMU();\n  initializePressureSensor();\n  initializePID();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004194": "initialize_system_08004194",
                "Devices_Init": "initializeDevices",
                "serialBegin": "initializeSerialConnection",
                "IMU_Init": "initializeIMU",
                "MS5611_Init": "initializePressureSensor",
                "PID_Init": "initializePID"
            },
            "calling": [
                "main"
            ],
            "called": [
                "PID_Init",
                "Devices_Init",
                "MS5611_Init",
                "IMU_Init",
                "serialBegin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041ae": {
            "entrypoint": "0x080041ae",
            "current_name": "main_program_loop_080041ae",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint mainProgramLoop_080041ae(void)\n\n{\n  initializeForkserver(0);\n  initialize();\n  do {\n    incrementHardwareTick();\n    executeTaskScheduler();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080041ae": "main_program_loop_080041ae",
                "startForkserver": "initializeForkserver",
                "setup": "initialize",
                "HAL_IncTick": "incrementHardwareTick",
                "taskScheduler": "executeTaskScheduler"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "startForkserver",
                "taskScheduler",
                "HAL_IncTick",
                "setup"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041c4": {
            "entrypoint": "0x080041c4",
            "current_name": "stop_all_motors_080041c4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopAllMotors_080041c4(void)\n\n{\n  setMotor1PWM(0);\n  setMotor2PWM(0);\n  setMotor3PWM(0);\n  setMotor4PWM(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041c4": "stop_all_motors_080041c4",
                "Motor1_SetPWM": "setMotor1PWM",
                "Motor2_SetPWM": "setMotor2PWM",
                "Motor3_SetPWM": "setMotor3PWM",
                "Motor4_SetPWM": "setMotor4PWM"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "Motor4_SetPWM",
                "Motor3_SetPWM",
                "Motor2_SetPWM",
                "Motor1_SetPWM"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041e4": {
            "entrypoint": "0x080041e4",
            "current_name": "update_motor_pwm_080041e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateMotorPWM_080041e4(int motor1_pwm,int motor2_pwm,int motor3_pwm,int motor4_pwm)\n\n{\n  if (999 < motor1_pwm) {\n    motor1_pwm = 1000;\n  }\n  if (999 < motor2_pwm) {\n    motor2_pwm = 1000;\n  }\n  if (999 < motor3_pwm) {\n    motor3_pwm = 1000;\n  }\n  if (999 < motor4_pwm) {\n    motor4_pwm = 1000;\n  }\n  motor_pwm_values[2] = motor3_pwm & ~(motor3_pwm >> 0x1f);\n  motor_pwm_values[3] = motor4_pwm & ~(motor4_pwm >> 0x1f);\n  motor_pwm_values[1] = motor2_pwm & ~(motor2_pwm >> 0x1f);\n  motor_pwm_values[0] = motor1_pwm & ~(motor1_pwm >> 0x1f);\n  Motor1_SetPWM(motor_pwm_values[0]);\n  Motor2_SetPWM(motor_pwm_values[1]);\n  Motor3_SetPWM(motor_pwm_values[2]);\n  Motor4_SetPWM(motor_pwm_values[3]);\n  msp_txf_motor.motor[0] = (short)motor_pwm_values[0] + 1000;\n  msp_txf_motor.motor[1] = (short)motor_pwm_values[1] + 1000;\n  msp_txf_motor.motor[2] = (short)motor_pwm_values[2] + 1000;\n  msp_txf_motor.motor[3] = (short)motor_pwm_values[3] + 1000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041e4": "update_motor_pwm_080041e4",
                "m1": "motor1_pwm",
                "m2": "motor2_pwm",
                "m3": "motor3_pwm",
                "m4": "motor4_pwm",
                "motor_pwm": "motor_pwm_values"
            },
            "calling": [
                "Motor_DistributeSpeed"
            ],
            "called": [
                "Motor4_SetPWM",
                "Motor3_SetPWM",
                "Motor2_SetPWM",
                "Motor1_SetPWM"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800426c": {
            "entrypoint": "0x0800426c",
            "current_name": "calculate_motor_speeds_0800426c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calculateMotorSpeeds_0800426c(float throttle,float pitch,float roll,float yaw)\n\n{\n  undefined4 throttleRollYawDiff;\n  undefined4 throttlePitchSum;\n  undefined4 throttlePitchRollYawSum;\n  int motor4Speed;\n  int motor3Speed;\n  int motor2Speed;\n  int motor1Speed;\n  \n  throttleRollYawDiff = __aeabi_fsub();\n  throttlePitchSum = __addsf3(throttle,pitch);\n  throttlePitchRollYawSum = __aeabi_fsub(throttleRollYawDiff,roll);\n  throttlePitchRollYawSum = __addsf3(throttlePitchRollYawSum,yaw);\n  __aeabi_fsub(throttlePitchRollYawSum,0x447a0000);\n  motor4Speed = __aeabi_f2iz();\n  throttlePitchRollYawSum = __aeabi_fsub(throttlePitchSum,roll);\n  throttlePitchRollYawSum = __aeabi_fsub(throttlePitchRollYawSum,yaw);\n  __aeabi_fsub(throttlePitchRollYawSum,0x447a0000);\n  motor3Speed = __aeabi_f2iz();\n  throttleRollYawDiff = __addsf3(throttleRollYawDiff,roll);\n  throttleRollYawDiff = __aeabi_fsub(throttleRollYawDiff,yaw);\n  __aeabi_fsub(throttleRollYawDiff,0x447a0000);\n  motor2Speed = __aeabi_f2iz();\n  throttleRollYawDiff = __addsf3(roll,throttlePitchSum);\n  throttleRollYawDiff = __addsf3(throttleRollYawDiff,yaw);\n  __aeabi_fsub(throttleRollYawDiff,0x447a0000);\n  motor1Speed = __aeabi_f2iz();\n  Motor_SetSpeed(motor1Speed,motor2Speed,motor3Speed,motor4Speed);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800426c": "calculate_motor_speeds_0800426c",
                "uVar1": "throttleRollYawDiff",
                "uVar2": "throttlePitchSum",
                "uVar3": "throttlePitchRollYawSum",
                "m4": "motor4Speed",
                "m3": "motor3Speed",
                "m2": "motor2Speed",
                "m1": "motor1Speed"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "__aeabi_f2iz",
                "__addsf3",
                "__aeabi_fsub",
                "Motor_SetSpeed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004300": {
            "entrypoint": "0x08004300",
            "current_name": "send_coded_data_08004300",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendCodedData_08004300(uint8_t encryptionKey,uint8_t *inputData,uint16_t inputLength)\n\n{\n  byte checksum;\n  byte *currentByte;\n  \n  serialPrint(\"$M>\");\n  serialWrite((byte)inputLength);\n  checksum = (byte)inputLength ^ encryptionKey;\n  serialWrite(encryptionKey);\n  for (currentByte = inputData; (int)currentByte - (int)inputData < (int)(uint)inputLength; currentByte = currentByte + 1) {\n    serialWrite(*currentByte);\n    checksum = checksum ^ *currentByte;\n  }\n  serialWrite(checksum);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004300": "send_coded_data_08004300",
                "code": "encryptionKey",
                "data": "inputData",
                "data_length": "inputLength",
                "ch": "checksum",
                "pbVar1": "currentByte"
            },
            "calling": [
                "MSP_SendMotor",
                "MSP_SendAttitude",
                "MSP_SendStatus",
                "MSP_SendAltitude",
                "MSP_SendPID",
                "MSP_SendIdent",
                "MSP_SendRawIMU"
            ],
            "called": [
                "serialWrite",
                "serialPrint"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004348": {
            "entrypoint": "0x08004348",
            "current_name": "send_data_frame_08004348",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid send_data_frame_08004348(void)\n\n{\n  uint input_data;\n  uint8_t buffer [7];\n  undefined4 frame_identifier;\n  uint masked_input;\n  \n  msp_txf_ident._0_4_ = 0x40003e9;\n  msp_txf_ident.capability._1_2_ = 0;\n  msp_txf_ident.capability._3_1_ = 0;\n  frame_identifier = 0x40003e9;\n  masked_input = input_data & 0xff000000;\n  send_frame('d',(uint8_t *)&frame_identifier,7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004348": "send_data_frame_08004348",
                "in_r1": "input_data",
                "buff": "buffer",
                "local_10": "frame_identifier",
                "local_c": "masked_input",
                "MSP_SendFrame": "send_frame"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004384": {
            "entrypoint": "0x08004384",
            "current_name": "send_frame_data_08004384",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendFrameData_08004384(void)\n\n{\n  uint inputData;\n  undefined4 statusValue;\n  undefined4 previousStatusValue;\n  uint maskedInputData;\n  \n  msp_txf_status._4_4_ = 0x2a0007;\n  statusValue = msp_txf_status._0_4_;\n  previousStatusValue = 0x2a0007;\n  msp_txf_status.flag._2_2_ = 0;\n  msp_txf_status.current_set = '\\0';\n  maskedInputData = inputData & 0xff000000;\n  MSP_SendFrame('e',(uint8_t *)&statusValue,0xb);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004384": "send_frame_data_08004384",
                "in_r3": "inputData",
                "local_14": "statusValue",
                "uStack_10": "previousStatusValue",
                "local_c": "maskedInputData"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080043bc": {
            "entrypoint": "0x080043bc",
            "current_name": "extract_and_send_raw_imu_data_080043bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid extractAndSendRawIMUData_080043bc(void)\n\n{\n  undefined4 accx;\n  undefined4 accy;\n  undefined4 *bufferPtr;\n  msp_raw_imu *imuDataPtr;\n  uint8_t rawIMUBuffer [18];\n  \n  imuDataPtr = &msp_txf_raw_imu;\n  bufferPtr = (undefined4 *)rawIMUBuffer;\n  do {\n    accx = *(undefined4 *)imuDataPtr;\n    accy = *(undefined4 *)&imuDataPtr->accz;\n    imuDataPtr = (msp_raw_imu *)&imuDataPtr->gyry;\n    *bufferPtr = accx;\n    bufferPtr[1] = accy;\n    bufferPtr = bufferPtr + 2;\n  } while (imuDataPtr != (msp_raw_imu *)&msp_txf_raw_imu.magz);\n  *(int16_t *)bufferPtr = msp_txf_raw_imu.magz;\n  MSP_SendFrame('f',rawIMUBuffer,0x12);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080043bc": "extract_and_send_raw_imu_data_080043bc",
                "uVar1": "accx",
                "uVar2": "accy",
                "puVar3": "bufferPtr",
                "pmVar4": "imuDataPtr",
                "buff": "rawIMUBuffer"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080043f0": {
            "entrypoint": "0x080043f0",
            "current_name": "send_motor_data_080043f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendMotorData_080043f0(void)\n\n{\n  uint8_t buffer [8];\n  undefined4 motorData1;\n  undefined4 motorData2;\n  \n  motorData1 = msp_txf_motor.motor._0_4_;\n  motorData2 = msp_txf_motor.motor._4_4_;\n  MSP_SendFrame('h',(uint8_t *)&motorData1,8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080043f0": "send_motor_data_080043f0",
                "buff": "buffer",
                "local_10": "motorData1",
                "uStack_c": "motorData2"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004410": {
            "entrypoint": "0x08004410",
            "current_name": "send_attitude_data_08004410",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendAttitudeData_08004410(void)\n\n{\n  undefined4 inputValue;\n  uint8_t buffer [6];\n  undefined4 attitudeX;\n  undefined4 attitudeHeading;\n  \n  attitudeX = msp_txf_attitude._0_4_;\n  attitudeHeading = CONCAT22((short)((uint)inputValue >> 0x10),msp_txf_attitude.heading);\n  MSP_SendFrame('l',(uint8_t *)&attitudeX,6);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004410": "send_attitude_data_08004410",
                "in_r1": "inputValue",
                "buff": "buffer",
                "local_10": "attitudeX",
                "local_c": "attitudeHeading"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004434": {
            "entrypoint": "0x08004434",
            "current_name": "send_altitude_frame_08004434",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendAltitudeFrame_08004434(void)\n\n{\n  undefined4 input_register1;\n  uint8_t buffer [6];\n  int32_t estimated_altitude;\n  undefined4 vario_value;\n  \n  estimated_altitude = msp_txf_altitude.est_alt;\n  vario_value = CONCAT22((short)((uint)input_register1 >> 0x10),msp_txf_altitude.vario);\n  MSP_SendFrame('m',(uint8_t *)&estimated_altitude,6);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004434": "send_altitude_frame_08004434",
                "in_r1": "input_register1",
                "buff": "buffer",
                "local_10": "estimated_altitude",
                "local_c": "vario_value"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004458": {
            "entrypoint": "0x08004458",
            "current_name": "send_pitch_data_08004458",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendPitchData_08004458(void)\n\n{\n  undefined4 *localDataArray;\n  undefined4 pitchValue;\n  undefined4 *destArray;\n  msp_pid *sourcePid;\n  msp_pid *nextPid;\n  uint8_t buffer [30];\n  undefined4 dataArray [3];\n  undefined2 posArray [10];\n  \n  localDataArray = dataArray;\n  nextPid = &msp_txf_pid;\n  do {\n    sourcePid = nextPid;\n    destArray = localDataArray;\n    pitchValue = *(undefined4 *)&(sourcePid->pitch).i;\n    nextPid = (msp_pid *)&(sourcePid->yaw).d;\n    *destArray = *(undefined4 *)sourcePid;\n    destArray[1] = pitchValue;\n    localDataArray = destArray + 2;\n  } while (nextPid != (msp_pid *)&msp_txf_pid.mag);\n  destArray[2] = msp_txf_pid._24_4_;\n  *(undefined2 *)(destArray + 3) = *(undefined2 *)&sourcePid->pos;\n  MSP_SendFrame('p',(uint8_t *)dataArray,0x1e);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004458": "send_pitch_data_08004458",
                "puVar1": "localDataArray",
                "uVar2": "pitchValue",
                "puVar3": "destArray",
                "pmVar4": "sourcePid",
                "pmVar5": "nextPid",
                "buff": "buffer",
                "local_30": "dataArray",
                "local_24": "posArray"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004490": {
            "entrypoint": "0x08004490",
            "current_name": "handle_error_08004490",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleError_08004490(char *fileName,int lineNum)\n\n{\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x4000,GPIO_PIN_SET);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x8000,GPIO_PIN_RESET);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x2000,GPIO_PIN_RESET);\n  do {\n    HAL_GPIO_TogglePin((GPIO_TypeDef *)0x40011000,0x4000);\n    HAL_GPIO_TogglePin((GPIO_TypeDef *)0x40011000,0x8000);\n    HAL_GPIO_TogglePin((GPIO_TypeDef *)0x40011000,0x2000);\n    serialPrint(\"Error with \");\n    serialPrint(fileName);\n    serialPrint(\" at lineNum: \");\n    serialInt(lineNum);\n    serialWrite('\\n');\n    delay_ms(500);\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004490": "handle_error_08004490",
                "file": "fileName",
                "line": "lineNum"
            },
            "calling": [
                "Peripherals_Init",
                "I2C_ReadByte",
                "I2C_ReadBytes",
                "I2C_WriteByte",
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GPIO_WritePin",
                "serialWrite",
                "delay_ms",
                "serialInt",
                "serialPrint",
                "HAL_GPIO_TogglePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004514": {
            "entrypoint": "0x08004514",
            "current_name": "initialize_clocks_08004514",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeClocks_08004514(void)\n\n{\n  HAL_StatusTypeDef halStatus;\n  char *file;\n  uint32_t hclkFreq;\n  int counter;\n  uint flashLatency;\n  RCC_ClkInitTypeDef rccClkInit;\n  RCC_OscInitTypeDef rccOscInit;\n  \n  rccOscInit.HSIState = 1;\n  rccOscInit.HSICalibrationValue = 0x10;\n  flashLatency = 2;\n  rccOscInit.PLL.PLLSource = 0;\n  rccOscInit.OscillatorType = 2;\n  rccOscInit.PLL.PLLState = 2;\n  rccOscInit.PLL.PLLMUL = 0x380000;\n  halStatus = HAL_RCC_OscConfig(&rccOscInit);\n  file = (char *)(uint)halStatus;\n  if (file == (char *)0x0) goto LAB_08004540;\n  counter = 0x3c;\n  while( true ) {\n    file = \"../Src/peripherals.c\";\n    _Error_Handler(\"../Src/peripherals.c\",counter);\nLAB_08004540:\n    rccClkInit.ClockType = 0xf;\n    rccClkInit.APB1CLKDivider = 0x400;\n    rccClkInit.SYSCLKSource = flashLatency;\n    rccClkInit.AHBCLKDivider = (uint32_t)file;\n    rccClkInit.APB2CLKDivider = (uint32_t)file;\n    halStatus = HAL_RCC_ClockConfig(&rccClkInit,flashLatency);\n    flashLatency = (uint)halStatus;\n    if (flashLatency == 0) break;\n    counter = 0x49;\n  }\n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFreq / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004514": "initialize_clocks_08004514",
                "RCC_OscInitStruct": "rccOscInit",
                "RCC_ClkInitStruct": "rccClkInit",
                "HVar1": "halStatus",
                "pcVar2": "file",
                "uVar3": "hclkFreq",
                "line": "counter",
                "FLatency": "flashLatency"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_ClockConfig",
                "HAL_RCC_OscConfig",
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_GetHCLKFreq",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800458c": {
            "entrypoint": "0x0800458c",
            "current_name": "initialize_peripherals_0800458c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializePeripherals_0800458c(void)\n\n{\n  HAL_StatusTypeDef status;\n  char *errorHandler;\n  uint result;\n  int currentLine;\n  uint prescaler;\n  uint32_t temp_reg;\n  uint32_t temp_reg_1;\n  uint32_t temp_reg_2;\n  TIM_MasterConfigTypeDef masterConfig;\n  TIM_OC_InitTypeDef ocConfig;\n  GPIO_InitTypeDef gpioConfig;\n  \n  initializeHAL();\n  configureSystemClock();\n  prescaler = 2;\n  _DAT_40021018 = _DAT_40021018 | 0x1c;\n  writeGPIO_Pin((GPIO_TypeDef *)0x40011000,0xe000,GPIO_PIN_RESET);\n  writeGPIO_Pin((GPIO_TypeDef *)0x40010800,0x20,GPIO_PIN_RESET);\n  timer1GPIO_Pin = 0xe000;\n  gpioConfig.Mode = 1;\n  gpioConfig.Speed = 2;\n  HAL_GPIO_Init((GPIO_TypeDef *)0x40011000,&gpioConfig);\n  timer1GPIO_Pin = 0x20;\n  gpioConfig.Mode = 1;\n  gpioConfig.Speed = 2;\n  HAL_GPIO_Init((GPIO_TypeDef *)0x40010800,&gpioConfig);\n  i2cConfig.Instance = (I2C_TypeDef *)0x40005400;\n  i2cConfig.Init.ClockSpeed = 400000;\n  i2cConfig.Init.AddressingMode = 0x4000;\n  i2cConfig.Init.DutyCycle = 0;\n  i2cConfig.Init.OwnAddress1 = 0;\n  i2cConfig.Init.DualAddressMode = 0;\n  i2cConfig.Init.OwnAddress2 = 0;\n  i2cConfig.Init.GeneralCallMode = 0;\n  i2cConfig.Init.NoStretchMode = 0;\n  status = initializeI2C(&i2cConfig);\n  errorHandler = (char *)(uint)status;\n  if (errorHandler == (char *)0x0) goto LAB_0800463a;\n  currentLine = 0x6b;\n  while( true ) {\n    while( true ) {\n      while( true ) {\n        while( true ) {\n          while( true ) {\n            while( true ) {\n              while( true ) {\n                while( true ) {\n                  while( true ) {\n                    while( true ) {\n                      while( true ) {\n                        while( true ) {\n                          while( true ) {\n                            while( true ) {\n                              while( true ) {\n                                while( true ) {\n                                  errorHandler = \"../Src/peripherals.c\";\n                                  handleError(\"../Src/peripherals.c\",currentLine);\nLAB_0800463a:\n                                  uartConfig.Instance = (USART_TypeDef *)0x40013800;\n                                  uartConfig.Init.BaudRate = 0x1c200;\n                                  uartConfig.Init.Mode = 0xc;\n                                  uartConfig.Init.WordLength = (uint32_t)errorHandler;\n                                  uartConfig.Init.StopBits = (uint32_t)errorHandler;\n                                  uartConfig.Init.Parity = (uint32_t)errorHandler;\n                                  uartConfig.Init.HwFlowCtl = (uint32_t)errorHandler;\n                                  uartConfig.Init.OverSampling = (uint32_t)errorHandler;\n                                  status = initializeUART(&uartConfig);\n                                  result = (uint)status;\n                                  if (result == 0) break;\n                                  currentLine = 0x151;\n                                }\n                                timer1Config.Instance = (TIM_TypeDef *)0x40012c00;\n                                timer1Config.Init.Period = 1000;\n                                timer1Config.Init.Prescaler = prescaler;\n                                timer1Config.Init.CounterMode = result;\n                                timer1Config.Init.ClockDivision = result;\n                                timer1Config.Init.RepetitionCounter = result;\n                                status = initializeTimer4PWM(&timer1Config);\n                                result = (uint)status;\n                                if (result == 0) break;\n                                currentLine = 0x88;\n                              }\n                              masterConfig.MasterOutputTrigger = result;\n                              masterConfig.MasterSlaveMode = result;\n                              status = configureTimer1Master(&timer1Config,&masterConfig);\n                              result = (uint)status;\n                              if (result == 0) break;\n                              currentLine = 0x8f;\n                            }\n                            ocConfig.OCMode = 0x60;\n                            ocConfig.Pulse = result;\n                            ocConfig.OCPolarity = result;\n                            ocConfig.OCFastMode = result;\n                            ocConfig.OCIdleState = result;\n                            ocConfig.OCNIdleState = result;\n                            status = configureTimer1Channel(&timer1Config,&ocConfig,0xc);\n                            result = (uint)status;\n                            if (result == 0) break;\n                            currentLine = 0x9a;\n                          }\n                          timer1GPIO_Pin = result;\n                          gpioConfig.Mode = result;\n                          gpioConfig.Pull = result;\n                          gpioConfig.Speed = result;\n                          status = HAL_TIMEx_ConfigBreakDeadTime\n                                            (&timer1Config,(TIM_BreakDeadTimeConfigTypeDef *)\n                                                    &gpioConfig);\n                          result = (uint)status;\n                          if (result == 0) break;\n                          currentLine = 0xa6;\n                        }\n                        HAL_TIM_MspPostInit(&timer1Config);\n                        timer2Config.Instance = (TIM_TypeDef *)0x40000000;\n                        timer2Config.Init.Period = 1000;\n                        timer2Config.Init.Prescaler = prescaler;\n                        timer2Config.Init.CounterMode = result;\n                        timer2Config.Init.ClockDivision = result;\n                        status = initializeTimer4PWM(&timer2Config);\n                        result = (uint)status;\n                        if (result == 0) break;\n                        currentLine = 0xc3;\n                      }\n                      ocConfig.OCMode = result;\n                      ocConfig.Pulse = result;\n                      status = configureTimer1Master\n                                        (&timer2Config,(TIM_MasterConfigTypeDef *)&ocConfig);\n                      result = (uint)status;\n                      if (result == 0) break;\n                      currentLine = 0xca;\n                    }\n                    timer1GPIO_Pin = 0x60;\n                    gpioConfig.Mode = result;\n                    gpioConfig.Pull = result;\n                    status = configureTimer1Channel\n                                      (&timer2Config,(TIM_OC_InitTypeDef *)&gpioConfig,4);\n                    result = (uint)status;\n                    if (result == 0) break;\n                    currentLine = 0xd3;\n                  }\n                  HAL_TIM_MspPostInit(&timer2Config);\n                  timer3Config.Init.Period = 1000;\n                  timer3Config.Instance = (TIM_TypeDef *)0x40000400;\n                  timer3Config.Init.Prescaler = prescaler;\n                  timer3Config.Init.CounterMode = result;\n                  timer3Config.Init.ClockDivision = result;\n                  status = initializeTimer4PWM(&timer3Config);\n                  if (status == HAL_OK) break;\n                  currentLine = 0xf0;\n                }\n                ocConfig.OCMode = 0;\n                ocConfig.Pulse = 0;\n                status = configureTimer1Master\n                                  (&timer3Config,(TIM_MasterConfigTypeDef *)&ocConfig);\n                result = (uint)status;\n                if (result == 0) break;\n                currentLine = 0xf7;\n              }\n              timer1GPIO_Pin = 0x60;\n              gpioConfig.Mode = result;\n              gpioConfig.Pull = result;\n              status = configureTimer1Channel(&timer3Config,(TIM_OC_InitTypeDef *)&gpioConfig,8);\n              if (status == HAL_OK) break;\n              currentLine = 0x100;\n            }\n            status = configureTimer1Channel(&timer3Config,(TIM_OC_InitTypeDef *)&gpioConfig,0xc);\n            prescaler = (uint)status;\n            if (prescaler == 0) break;\n            currentLine = 0x105;\n          }\n          HAL_TIM_MspPostInit(&timer3Config);\n          timer4Config.Instance = (TIM_TypeDef *)0x40000800;\n          timer4Config.Init.Prescaler = 2;\n          timer4Config.Init.Period = 1000;\n          timer4Config.Init.CounterMode = prescaler;\n          timer4Config.Init.ClockDivision = prescaler;\n          status = initializeTimer4PWM(&timer4Config);\n          result = (uint)status;\n          if (result == 0) break;\n          currentLine = 0x122;\n        }\n        ocConfig.OCMode = result;\n        ocConfig.Pulse = result;\n        status = configureTimer1Master(&timer4Config,(TIM_MasterConfigTypeDef *)&ocConfig);\n        result = (uint)status;\n        if (result == 0) break;\n        currentLine = 0x129;\n      }\n      timer1GPIO_Pin = 0x60;\n      gpioConfig.Mode = result;\n      gpioConfig.Pull = result;\n      status = configureTimer1Channel(&timer4Config,(TIM_OC_InitTypeDef *)&gpioConfig,8);\n      if (status == HAL_OK) break;\n      currentLine = 0x132;\n    }\n    status = configureTimer1Channel(&timer4Config,(TIM_OC_InitTypeDef *)&gpioConfig,0xc);\n    if (status == HAL_OK) break;\n    currentLine = 0x137;\n  }\n  HAL_TIM_MspPostInit(&timer4Config);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800458c": "initialize_peripherals_0800458c",
                "HVar1": "status",
                "pcVar2": "errorHandler",
                "uVar3": "result",
                "line": "currentLine",
                "uVar4": "prescaler",
                "tmpreg": "temp_reg",
                "tmpreg_1": "temp_reg_1",
                "tmpreg_2": "temp_reg_2",
                "sMasterConfig": "masterConfig",
                "sConfigOC": "ocConfig",
                "GPIO_InitStruct": "gpioConfig",
                "HAL_Init": "initializeHAL",
                "SystemClock_Config": "configureSystemClock",
                "HAL_GPIO_WritePin": "writeGPIO_Pin",
                "hi2c1": "i2cConfig",
                "HAL_I2C_Init": "initializeI2C",
                "_Error_Handler": "handleError",
                "huart1": "uartConfig",
                "HAL_UART_Init": "initializeUART",
                "htim1": "timer1Config",
                "HAL_TIM_PWM_Init": "initializeTimer4PWM",
                "HAL_TIMEx_MasterConfigSynchronization": "configureTimer1Master",
                "HAL_TIM_PWM_ConfigChannel": "configureTimer1Channel",
                "GPIO_InitStruct.Pin": "timer1GPIO_Pin",
                "htim2": "timer2Config",
                "htim3": "timer3Config",
                "htim4": "timer4Config"
            },
            "calling": [
                "Devices_Init"
            ],
            "called": [
                "HAL_GPIO_WritePin",
                "HAL_UART_Init",
                "HAL_Init",
                "HAL_GPIO_Init",
                "HAL_I2C_Init",
                "HAL_TIMEx_ConfigBreakDeadTime",
                "HAL_TIMEx_MasterConfigSynchronization",
                "HAL_TIM_PWM_ConfigChannel",
                "_Error_Handler",
                "HAL_TIM_PWM_Init",
                "HAL_TIM_MspPostInit",
                "SystemClock_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800483c": {
            "entrypoint": "0x0800483c",
            "current_name": "calculate_pid_output_0800483c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calculatePIDOutput_0800483c(PID_TypeDef *pidData)\n\n{\n  undefined4 setPointPlusOffset;\n  int comparisonResult;\n  undefined4 derivativeTerm;\n  float inputError;\n  float proportionalTerm;\n  float integralGain;\n  \n  inputError = pidData->input;\n  setPointPlusOffset = __addsf3(pidData->setPoint,pidData->offset);\n  inputError = (float)__aeabi_fsub(setPointPlusOffset,inputError);\n  pidData->error = inputError;\n  if (pidData->instance == 3) {\n    comparisonResult = __aeabi_fcmpgt(pidData->error,0);\n    if (comparisonResult == 0) {\n      comparisonResult = __aeabi_fcmplt(pidData->error,0xc3340000);\n    }\n    else {\n      comparisonResult = __aeabi_fcmpgt(pidData->error,0x43340000);\n    }\n    if (comparisonResult != 0) {\n      proportionalTerm = pidData->error;\n      setPointPlusOffset = __aeabi_fmul(pidData->error,0x43b40000);\n      comparisonResult = __aeabi_fcmpgt(pidData->error,0);\n      inputError = pidData->error;\n      if (comparisonResult == 0) {\n        inputError = (float)((int)inputError + -0x80000000);\n      }\n      setPointPlusOffset = __aeabi_fdiv(setPointPlusOffset,inputError);\n      inputError = (float)__aeabi_fsub(proportionalTerm,setPointPlusOffset);\n      pidData->error = inputError;\n    }\n  }\n  integralGain = pidData->integralGainConstant;\n  proportionalTerm = pidData->derivativeGainConstant;\n  inputError = (float)__aeabi_fmul(pidData->proportionalGainConstant,pidData->error);\n  pidData->proportional = inputError;\n  inputError = (float)__addsf3(pidData->error,pidData->integral);\n  pidData->integral = inputError;\n  comparisonResult = __aeabi_fcmplt(pidData->integral,0xc3fa0000);\n  if (comparisonResult == 0) {\n    comparisonResult = __aeabi_fcmpgt(pidData->integral,0x43fa0000);\n    if (comparisonResult == 0) {\n      inputError = pidData->integral;\n    }\n    else {\n      inputError = 500.0;\n    }\n  }\n  else {\n    inputError = -500.0;\n  }\n  pidData->integral = inputError;\n  inputError = (float)__aeabi_fsub(pidData->input,pidData->previousInput);\n  pidData->derivative = inputError;\n  inputError = pidData->proportional;\n  setPointPlusOffset = __aeabi_fmul(integralGain,pidData->integral);\n  setPointPlusOffset = __addsf3(setPointPlusOffset,inputError);\n  derivativeTerm = __aeabi_fmul(proportionalTerm,pidData->derivative);\n  inputError = (float)__aeabi_fsub(setPointPlusOffset,derivativeTerm);\n  pidData->output = inputError;\n  setPointPlusOffset = __floatsisf(pidData->direction);\n  comparisonResult = __aeabi_fcmplt(pidData->output,0xc3fa0000);\n  if (comparisonResult == 0) {\n    comparisonResult = __aeabi_fcmpgt(pidData->output,0x43fa0000);\n    if (comparisonResult == 0) {\n      inputError = pidData->output;\n    }\n    else {\n      inputError = 500.0;\n    }\n  }\n  else {\n    inputError = -500.0;\n  }\n  inputError = (float)__aeabi_fmul(inputError,setPointPlusOffset);\n  pidData->output = inputError;\n  pidData->previousInput = pidData->input;\n  pidData->previousError = pidData->error;\n  pidData->previousTime = pidData->time;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800483c": "calculate_pid_output_0800483c",
                "pid": "pidData",
                "uVar1": "setPointPlusOffset",
                "iVar2": "comparisonResult",
                "fVar4": "inputError",
                "fVar5": "proportionalTerm",
                "fVar6": "integralGain",
                "uVar3": "derivativeTerm",
                "set_point": "setPoint",
                "con_KI": "integralGainConstant",
                "con_KD": "derivativeGainConstant",
                "con_KP": "proportionalGainConstant",
                "last_input": "previousInput",
                "last_error": "previousError",
                "last_time": "previousTime"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "__aeabi_fcmpgt",
                "__aeabi_fdiv",
                "__addsf3",
                "__aeabi_fsub",
                "__floatsisf",
                "__aeabi_fmul",
                "__aeabi_fcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004978": {
            "entrypoint": "0x08004978",
            "current_name": "initialize_pid_controllers_08004978",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePIDControllers_08004978(void)\n\n{\n  pitchController.dir = 1;\n  rollController.dir = 1;\n  yawController.dir = -1;\n  altitudeController.dir = 1;\n  pitchController.brkp = 1500.0;\n  rollController.brkp = 1450.0;\n  yawController.brkp = 2000.0;\n  altitudeController.brkp = 0.0;\n  pitchController.conProportional = 4.4;\n  pitchController.conIntegral = 0.02;\n  pitchController.conDerivative = 280.0;\n  pitchController.agrProportional = 4.5;\n  pitchController.agrIntegral = 0.02;\n  pitchController.agrDerivative = 360.0;\n  rollController.conProportional = 3.8;\n  rollController.conIntegral = 0.02;\n  rollController.conDerivative = 260.0;\n  rollController.agrProportional = 3.8;\n  rollController.agrIntegral = 0.02;\n  rollController.agrDerivative = 320.0;\n  yawController.conProportional = 3.0;\n  yawController.conIntegral = 0.01;\n  yawController.conDerivative = 280.0;\n  yawController.agrProportional = 0.0;\n  yawController.agrIntegral = 0.0;\n  yawController.agrDerivative = 0.0;\n  altitudeController.conProportional = 10.0;\n  altitudeController.conIntegral = 0.0;\n  altitudeController.conDerivative = 0.0;\n  altitudeController.agrProportional = 0.0;\n  altitudeController.agrIntegral = 0.0;\n  altitudeController.agrDerivative = 0.0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004978": "initialize_pid_controllers_08004978",
                "pid_pitch": "pitchController",
                "pid_roll": "rollController",
                "pid_yaw": "yawController",
                "pid_altitude": "altitudeController",
                "direction": "dir",
                "breakpoint": "brkp",
                "con_KP": "conProportional",
                "con_KI": "conIntegral",
                "con_KD": "conDerivative",
                "agr_KP": "agrProportional",
                "agr_KI": "agrIntegral",
                "agr_KD": "agrDerivative"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a30": {
            "entrypoint": "0x08004a30",
            "current_name": "update_altitude_controller_08004a30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateAltitudeController_08004a30(void)\n\n{\n  if (isAltitudeHoldEnabled != '\\0') {\n    if (altitudeFlag == '\\0') {\n      getFilteredAltitude();\n      altitudeSetPoint = (float)__aeabi_fmul();\n      altitudeFlag = '\\x01';\n    }\n    else {\n      getFilteredAltitude();\n      altitudeInput = (float)__aeabi_fmul();\n    }\n  }\n  if (isAltitudeHoldEnabled == '\\0') {\n    if (altitudeFlag != '\\0') {\n      altitudeFlag = isAltitudeHoldEnabled;\n    }\n    altitudeOutput = throttleValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a30": "update_altitude_controller_08004a30",
                "joystick.ALT_HOLD": "isAltitudeHoldEnabled",
                "ALT_FLAG": "altitudeFlag",
                "MS5611_GetFilteredAltitude": "getFilteredAltitude",
                "pid_altitude.set_point": "altitudeSetPoint",
                "pid_altitude.input": "altitudeInput",
                "pid_altitude.output": "altitudeOutput",
                "joystick.throttle": "throttleValue"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "MS5611_GetFilteredAltitude",
                "__aeabi_fmul"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a84": {
            "entrypoint": "0x08004a84",
            "current_name": "flight_controller_08004a84",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid flightController_08004a84(void)\n\n{\n  float pitchInput;\n  int comparisonResult;\n  \n  AHRS_GetPitch();\n  pitchInput = pitchInput;\n  AHRS_GetRoll();\n  rollInput = pitchInput;\n  AHRS_GetYaw();\n  yawInput = pitchInput;\n  PID_UpdateAltitude();\n  comparisonResult = __aeabi_fcmpgt(pitchInput,0);\n  if (comparisonResult == 0) {\n    comparisonResult = __aeabi_fcmplt(pitchInput,0xc2a00000);\n  }\n  else {\n    comparisonResult = __aeabi_fcmpgt(pitchInput,0x42a00000);\n  }\n  if (comparisonResult == 0) {\n    comparisonResult = __aeabi_fcmpgt(rollInput,0);\n    if (comparisonResult == 0) {\n      comparisonResult = __aeabi_fcmplt(rollInput,0xc2a00000);\n    }\n    else {\n      comparisonResult = __aeabi_fcmpgt(rollInput,0x42a00000);\n    }\n    if (comparisonResult == 0) {\n      toggleLED(1,1,1);\n      PID_Compute(&pid_pitch);\n      PID_Compute(&pid_roll);\n      PID_Compute(&pid_yaw);\n      if (altitudeHold != '\\0') {\n        PID_Compute(&pid_altitude);\n        __addsf3(altitudeOutput,0x44bb8000);\n      }\n      altitudeOutput = throttle;\n      if (motorArmed == '\\0') {\n        Motor_StopAll();\n      }\n      else {\n        Motor_DistributeSpeed(throttle,pitchOutput,rollOutput,yawOutput);\n      }\n      __aeabi_fmul(kpPitch,0x437f0000);\n      pitchP = __fixunssfsi();\n      __aeabi_fmul(kiPitch,0x437f0000);\n      pitchI = __fixunssfsi();\n      __aeabi_fmul(kpRoll,0x437f0000);\n      rollP = __fixunssfsi();\n      __aeabi_fmul(kiRoll,0x437f0000);\n      rollI = __fixunssfsi();\n      __aeabi_fmul(kdRoll,0x437f0000);\n      rollD = __fixunssfsi();\n      __aeabi_fmul(kpYaw,0x437f0000);\n      yawP = __fixunssfsi();\n      __aeabi_fmul(kiYaw,0x437f0000);\n      yawI = __fixunssfsi();\n      __aeabi_fmul(kdYaw,0x437f0000);\n      yawD = __fixunssfsi();\n      __aeabi_fmul(kpAltitude,0x437f0000);\n      altitudeP = __fixunssfsi();\n      __aeabi_fmul(kiAltitude,0x437f0000);\n      altitudeI = __fixunssfsi();\n      __aeabi_fmul(kdAltitude,0x437f0000);\n      altitudeD = __fixunssfsi();\n      return;\n    }\n  }\n  Motor_StopAll();\n  toggleLED(0,1,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a84": "flight_controller_08004a84",
                "in_r0": "pitchInput",
                "iVar1": "comparisonResult",
                "pid_pitch.input": "pitchInput",
                "pid_roll.input": "rollInput",
                "pid_yaw.input": "yawInput",
                "joystick.ALT_HOLD": "altitudeHold",
                "joystick.MOTOR_ARM": "motorArmed",
                "joystick.throttle": "throttle",
                "pid_altitude.output": "altitudeOutput",
                "pid_pitch.output": "pitchOutput",
                "pid_roll.output": "rollOutput",
                "pid_yaw.output": "yawOutput",
                "pid_pitch.con_KP": "kpPitch",
                "pid_pitch.con_KI": "kiPitch",
                "pid_roll.con_KP": "kpRoll",
                "pid_roll.con_KI": "kiRoll",
                "pid_roll.con_KD": "kdRoll",
                "pid_yaw.con_KP": "kpYaw",
                "pid_yaw.con_KI": "kiYaw",
                "pid_yaw.con_KD": "kdYaw",
                "pid_altitude.con_KP": "kpAltitude",
                "pid_altitude.con_KI": "kiAltitude",
                "pid_altitude.con_KD": "kdAltitude",
                "msp_txf_pid.pitch.p": "pitchP",
                "msp_txf_pid.pitch.i": "pitchI",
                "msp_txf_pid.roll.p": "rollP",
                "msp_txf_pid.roll.i": "rollI",
                "msp_txf_pid.roll.d": "rollD",
                "msp_txf_pid.yaw.p": "yawP",
                "msp_txf_pid.yaw.i": "yawI",
                "msp_txf_pid.yaw.d": "yawD",
                "msp_txf_pid.alt.p": "altitudeP",
                "msp_txf_pid.alt.i": "altitudeI",
                "msp_txf_pid.alt.d": "altitudeD"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "__aeabi_fcmpgt",
                "Motor_StopAll",
                "__aeabi_fmul",
                "__aeabi_fcmplt",
                "AHRS_GetRoll",
                "PID_Compute",
                "__addsf3",
                "toggleLED",
                "Motor_DistributeSpeed",
                "AHRS_GetPitch",
                "__fixunssfsi",
                "AHRS_GetYaw",
                "PID_UpdateAltitude"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c18": {
            "entrypoint": "0x08004c18",
            "current_name": "transmit_character_08004c18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitCharacter_08004c18(ucharacterar character)\n\n{\n  buffer[0] = character;\n  transmitData(&huart1,(uint8_t *)buffer,1,5);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c18": "transmit_character_08004c18",
                "ch": "character",
                "tx_buffer": "buffer",
                "HAL_UART_Transmit": "transmitData"
            },
            "calling": [
                "MSP_SendFrame",
                "serialPrint",
                "_Error_Handler"
            ],
            "called": [
                "HAL_UART_Transmit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c30": {
            "entrypoint": "0x08004c30",
            "current_name": "handle_uart_receive_08004c30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_uart_receive_08004c30(UART_HandleTypeDef *uart_handle)\n\n{\n  if (uart_handle->Instance == (usart *)0x40013800) {\n    write_to_buffer(&receive_buffer,read_buffer[0]);\n    configure_uart_interrupt(&uart_handle1,read_buffer,1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c30": "handle_uart_receive_08004c30",
                "huart": "uart_handle",
                "USART_TypeDef": "usart",
                "CB_Write": "write_to_buffer",
                "rxc": "receive_buffer",
                "rx_buffer": "read_buffer",
                "HAL_UART_Receive_IT": "configure_uart_interrupt"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "CB_Write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c64": {
            "entrypoint": "0x08004c64",
            "current_name": "initialize_rxc_08004c64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeRXC_08004c64(void)\n\n{\n  CB_Init(&rxcBuffer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c64": "initialize_rxc_08004c64",
                "rxc": "rxcBuffer"
            },
            "calling": [
                "serialBegin"
            ],
            "called": [
                "CB_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c70": {
            "entrypoint": "0x08004c70",
            "current_name": "receive_serial_data_08004c70",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid receive_serial_data_08004c70(void)\n\n{\n  serialFlush();\n  HAL_UART_Receive_IT(&huart1,receive_buffer,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c70": "receive_serial_data_08004c70",
                "rx_buffer": "receive_buffer"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "serialFlush",
                "HAL_UART_Receive_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c8c": {
            "entrypoint": "0x08004c8c",
            "current_name": "write_data_08004c8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid writeData_08004c8c(char *inputData)\n\n{\n  size_t dataLength;\n  uchar *currentChar;\n  \n  for (currentChar = (uchar *)inputData; dataLength = strlen(inputData), (uint)((int)currentChar - (int)inputData) < dataLength;\n      currentChar = currentChar + 1) {\n    serialWrite(*currentChar);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c8c": "write_data_08004c8c",
                "data": "inputData",
                "sVar1": "dataLength",
                "puVar2": "currentChar"
            },
            "calling": [
                "MSP_SendFrame",
                "serialInt",
                "_Error_Handler"
            ],
            "called": [
                "strlen",
                "serialWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cac": {
            "entrypoint": "0x08004cac",
            "current_name": "print_integer_value_08004cac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid printIntegerValue_08004cac(int value)\n\n{\n  siprintf(buffer,\"%i\",value);\n  serialPrint(buffer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004cac": "print_integer_value_08004cac",
                "val": "value",
                "tx_buffer": "buffer"
            },
            "calling": [
                "_Error_Handler"
            ],
            "called": [
                "siprintf",
                "serialPrint"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ccc": {
            "entrypoint": "0x08004ccc",
            "current_name": "enable_interrupts_08004ccc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid enableInterrupts_08004ccc(void)\n\n{\n  uint32_t temporaryRegister;\n  \n  _DAT_40021018 = _DAT_40021018 | 1;\n  HAL_NVIC_SetPriorityGrouping(3);\n  HAL_NVIC_SetPriority(MemoryManagement_IRQn,0,0);\n  HAL_NVIC_SetPriority(BusFault_IRQn,0,0);\n  HAL_NVIC_SetPriority(UsageFault_IRQn,0,0);\n  HAL_NVIC_SetPriority(SVCall_IRQn,0,0);\n  HAL_NVIC_SetPriority(DebugMonitor_IRQn,0,0);\n  HAL_NVIC_SetPriority(PendSV_IRQn,0,0);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ccc": "enable_interrupts_08004ccc",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d48": {
            "entrypoint": "0x08004d48",
            "current_name": "initialize_i2_cgpio_08004d48",
            "code": "\n/* WARNING: Variable defined which should be unmapped: gpioInitStruct */\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeI2CGPIO_08004d48(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t temporaryRegister;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  if (i2cHandle->Instance == (I2C_TypeDef *)0x40005400) {\n    gpioInitStruct.Pin = 0xc0;\n    gpioInitStruct.Mode = 0x12;\n    gpioInitStruct.Speed = 3;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40010c00,&gpioInitStruct);\n    _DAT_4002101c = _DAT_4002101c | 0x200000;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d48": "initialize_i2_cgpio_08004d48",
                "hi2c": "i2cHandle",
                "tmpreg": "temporaryRegister",
                "GPIO_InitStruct": "gpioInitStruct"
            },
            "calling": [
                "HAL_I2C_Init"
            ],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d8c": {
            "entrypoint": "0x08004d8c",
            "current_name": "initialize_timer_08004d8c",
            "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimer_08004d8c(TIM_HandleTypeDef *timerHandle)\n\n{\n  TIM_TypeDef *timerInstance;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister_1;\n  uint32_t temporaryRegister_2;\n  uint32_t temporaryRegister_3;\n  \n  timerInstance = timerHandle->Instance;\n  if (timerInstance == (TIM_TypeDef *)0x40012c00) {\n    _DAT_40021018 = _DAT_40021018 | 0x800;\n  }\n  else if (timerInstance == (TIM_TypeDef *)0x40000000) {\n    _DAT_4002101c = _DAT_4002101c | 1;\n  }\n  else if (timerInstance == (TIM_TypeDef *)0x40000400) {\n    _DAT_4002101c = _DAT_4002101c | 2;\n  }\n  else if (timerInstance == (TIM_TypeDef *)0x40000800) {\n    _DAT_4002101c = _DAT_4002101c | 4;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d8c": "initialize_timer_08004d8c",
                "htim_pwm": "timerHandle",
                "pTVar1": "timerInstance",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister_1",
                "tmpreg_2": "temporaryRegister_2",
                "tmpreg_3": "temporaryRegister_3"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e14": {
            "entrypoint": "0x08004e14",
            "current_name": "initialize_gpio_08004e14",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeGPIO_08004e14(TIM_HandleTypeDef *timerHandle)\n\n{\n  GPIO_TypeDef *gpioPort;\n  TIM_TypeDef *timerInstance;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  timerInstance = timerHandle->Instance;\n  if (timerInstance == (TIM_TypeDef *)0x40012c00) {\n    gpioInitStruct.Pin = 0x800;\n  }\n  else {\n    if (timerInstance != (TIM_TypeDef *)0x40000000) {\n      if (timerInstance == (TIM_TypeDef *)0x40000400) {\n        gpioInitStruct.Pin = 3;\n      }\n      else {\n        if (timerInstance != (TIM_TypeDef *)0x40000800) {\n          return;\n        }\n        gpioInitStruct.Pin = 0x300;\n      }\n      gpioPort = (GPIO_TypeDef *)0x40010c00;\n      goto LAB_08004e2e;\n    }\n    gpioInitStruct.Pin = 2;\n  }\n  gpioPort = (GPIO_TypeDef *)0x40010800;\nLAB_08004e2e:\n  gpioInitStruct.Speed = 2;\n  gpioInitStruct.Mode = 2;\n  HAL_GPIO_Init(gpioPort,&gpioInitStruct);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e14": "initialize_gpio_08004e14",
                "htim": "timerHandle",
                "GPIOx": "gpioPort",
                "pTVar1": "timerInstance",
                "GPIO_InitStruct": "gpioInitStruct"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e7c": {
            "entrypoint": "0x08004e7c",
            "current_name": "initialize_usart1_08004e7c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_USART1_08004e7c(UART_HandleTypeDef *USART1_handle)\n\n{\n  uint32_t tmp_register;\n  GPIO_InitTypeDef GPIO_init_config;\n  \n  if (USART1_handle->Instance == (USART_TypeDef *)0x40013800) {\n    _DAT_40021018 = _DAT_40021018 | 0x4000;\n    GPIO_pin = 0x200;\n    GPIO_mode = 2;\n    GPIO_speed = 3;\n    initialize_GPIO((GPIO_TypeDef *)0x40010800,&GPIO_init_config);\n    GPIO_pin = 0x400;\n    GPIO_mode = 0;\n    GPIO_init_config.Pull = 0;\n    initialize_GPIO((GPIO_TypeDef *)0x40010800,&GPIO_init_config);\n    set_interrupt_priority(USART1_interrupt,0,0);\n    enable_interrupt(USART1_interrupt);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e7c": "initialize_usart1_08004e7c",
                "huart": "USART1_handle",
                "tmpreg": "tmp_register",
                "GPIO_InitStruct": "GPIO_init_config",
                "GPIO_InitStruct.Pin": "GPIO_pin",
                "GPIO_InitStruct.Mode": "GPIO_mode",
                "GPIO_InitStruct.Speed": "GPIO_speed",
                "HAL_GPIO_Init": "initialize_GPIO",
                "USART1_IRQn": "USART1_interrupt",
                "HAL_NVIC_SetPriority": "set_interrupt_priority",
                "HAL_NVIC_EnableIRQ": "enable_interrupt"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_GPIO_Init",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee4": {
            "entrypoint": "0x08004ee4",
            "current_name": "FUNC_08004ee4",
            "code": "\nvoid FUNC_08004ee4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ee4": "FUNC_08004ee4"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee6": {
            "entrypoint": "0x08004ee6",
            "current_name": "do_nothing_loop_08004ee6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid doNothingLoop_08004ee6(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004ee6": "do_nothing_loop_08004ee6"
            },
            "calling": [
                "HardFault_Handler"
            ],
            "called": [
                "HardFault_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee8": {
            "entrypoint": "0x08004ee8",
            "current_name": "infinite_loop_08004ee8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08004ee8(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004ee8": "infinite_loop_08004ee8"
            },
            "calling": [
                "MemManage_Handler"
            ],
            "called": [
                "MemManage_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004eea": {
            "entrypoint": "0x08004eea",
            "current_name": "infinite_loop_08004eea",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08004eea(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004eea": "infinite_loop_08004eea"
            },
            "calling": [
                "BusFault_Handler"
            ],
            "called": [
                "BusFault_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004eec": {
            "entrypoint": "0x08004eec",
            "current_name": "infinite_loop_08004eec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08004eec(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004eec": "infinite_loop_08004eec"
            },
            "calling": [
                "UsageFault_Handler"
            ],
            "called": [
                "UsageFault_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004eee": {
            "entrypoint": "0x08004eee",
            "current_name": "FUNC_08004eee",
            "code": "\nvoid FUNC_08004eee(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004eee": "FUNC_08004eee"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef0": {
            "entrypoint": "0x08004ef0",
            "current_name": "FUNC_08004ef0",
            "code": "\nvoid FUNC_08004ef0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef0": "FUNC_08004ef0"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef2": {
            "entrypoint": "0x08004ef2",
            "current_name": "FUNC_08004ef2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004ef2(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef2": "FUNC_08004ef2"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef4": {
            "entrypoint": "0x08004ef4",
            "current_name": "initialize_system_tick_08004ef4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystemTick_08004ef4(void)\n\n{\n  incrementTick();\n  handleSysTickInterrupt();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef4": "initialize_system_tick_08004ef4",
                "HAL_IncTick": "incrementTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTickInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_IncTick",
                "HAL_SYSTICK_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f04": {
            "entrypoint": "0x08004f04",
            "current_name": "handle_uart_interrupt_08004f04",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART_interrupt_08004f04(void)\n\n{\n  HAL_UART_IRQHandler(UART_handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f04": "handle_uart_interrupt_08004f04",
                "&huart1": "UART_handle"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f10": {
            "entrypoint": "0x08004f10",
            "current_name": "initialize_peripheral_registers_08004f10",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializePeripheralRegisters_08004f10(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f10": "initialize_peripheral_registers_08004f10"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f5c": {
            "entrypoint": "0x08004f5c",
            "current_name": "FUN_08004f5c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_GetTick(void)\n\n{\n  return uwTick;\n}\n\n",
            "renaming": {},
            "calling": [
                "taskScheduler",
                "MS5611_Update"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f60": {
            "entrypoint": "0x08004f60",
            "current_name": "get_system_tick_08004f60",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemTick_08004f60(void)\n\n{\n  return systemTick;\n}\n\n",
            "renaming": {
                "FUN_08004f60": "get_system_tick_08004f60",
                "uwTick": "systemTick"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f64": {
            "entrypoint": "0x08004f64",
            "current_name": "FUNC_08004f64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004f64(uint32_t Delay)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f64": "FUNC_08004f64"
            },
            "calling": [
                "LED_StartupSequence",
                "MS5611_Init",
                "I2C_WriteByte",
                "_Error_Handler"
            ],
            "called": [
                "HAL_Delay"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004f68": {
            "entrypoint": "0x08004f68",
            "current_name": "initialize_system_08004f68",
            "code": "\nvoid initializeSystem_08004f68(void)\n\n{\n  int index;\n  undefined4 *ptr;\n  code *jumptablePtr;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &completed_8672; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&_sidata + index);\n  }\n  for (ptr = &completed_8672; ptr < &_ebss; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumptablePtr = (code *)0x8004f9a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08004f9a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumptablePtr)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f68": "initialize_system_08004f68",
                "iVar1": "index",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "jumptablePtr"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004fb0": {
            "entrypoint": "0x08004fb0",
            "current_name": "infinite_loop_08004fb0",
            "code": "\nvoid infiniteLoop_08004fb0(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004fb0": "infinite_loop_08004fb0"
            },
            "calling": [
                "USBWakeUp_IRQHandler"
            ],
            "called": [
                "USBWakeUp_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004fb4": {
            "entrypoint": "0x08004fb4",
            "current_name": "initialize_evp_context_08004fb4",
            "code": "\nvoid initializeEVPContext_08004fb4(EVP_PKEY_CTX *ctx)\n\n{\n  int index;\n  \n  for (index = 0; index != 0; index = index + 1) {\n    ctx = (EVP_PKEY_CTX *)(*(code *)(&__frame_dummy_init_array_entry)[index])();\n  }\n  _init(ctx);\n  for (index = 0; index != 1; index = index + 1) {\n    (*(code *)(&__frame_dummy_init_array_entry)[index])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004fb4": "initialize_evp_context_08004fb4",
                "param_1": "ctx",
                "iVar1": "index"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "_init",
                "frame_dummy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ffc": {
            "entrypoint": "0x08004ffc",
            "current_name": "clear_string_and_printf_08004ffc",
            "code": "\nint clearStringAndPrintf_08004ffc(char *string,char *format,...)\n\n{\n  int result;\n  undefined4 param2;\n  undefined4 param3;\n  char *stringArray [2];\n  undefined4 maxStringLength1;\n  undefined2 initialStringLength;\n  undefined2 maxStringLength2;\n  char *currentStringPosition;\n  undefined4 maxArrayLength;\n  char *formatPointer;\n  undefined4 register2;\n  undefined4 register3;\n  \n  initialStringLength = 0x208;\n  maxStringLength1 = 0x7fffffff;\n  maxArrayLength = 0x7fffffff;\n  maxStringLength2 = 0xffff;\n  stringArray[0] = string;\n  currentStringPosition = string;\n  formatPointer = format;\n  register2 = param2;\n  register3 = param3;\n  result = _svfiprintf_r(_impure_ptr,stringArray,format);\n  *stringArray[0] = '\\0';\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004ffc": "clear_string_and_printf_08004ffc",
                "__s": "string",
                "__format": "format",
                "iVar1": "result",
                "in_r2": "param2",
                "in_r3": "param3",
                "local_78": "stringArray",
                "local_70": "maxStringLength1",
                "local_6c": "initialStringLength",
                "local_6a": "maxStringLength2",
                "local_68": "currentStringPosition",
                "local_64": "maxArrayLength",
                "pcStack_c": "formatPointer",
                "uStack_8": "register2",
                "uStack_4": "register3"
            },
            "calling": [
                "serialInt"
            ],
            "called": [
                "_svfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005044": {
            "entrypoint": "0x08005044",
            "current_name": "resize_and_copy_memory_08005044",
            "code": "\nundefined4 resizeAndCopyMemory_08005044(undefined4 *errorCode,void **buffer,void *source,void *sourceSize)\n\n{\n  void *newBuffer;\n  void *currentBuffer;\n  size_t sizeDifference;\n  \n  currentBuffer = buffer[2];\n  if ((currentBuffer <= sourceSize) && ((*(ushort *)(buffer + 3) & 0x480) != 0)) {\n    sizeDifference = (int)*buffer - (int)buffer[4];\n    currentBuffer = (void *)((uint)((int)buffer[5] * 3) / 2);\n    newBuffer = (void *)((int)sourceSize + sizeDifference + 1);\n    if (currentBuffer < newBuffer) {\n      currentBuffer = newBuffer;\n    }\n    if ((int)((uint)*(ushort *)(buffer + 3) << 0x15) < 0) {\n      newBuffer = (void *)_malloc_r(errorCode,currentBuffer);\n      if (newBuffer == (void *)0x0) {\nLAB_0800508a:\n        *errorCode = 0xc;\n        *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) | 0x40;\n        return 0xffffffff;\n      }\n      memcpy(newBuffer,buffer[4],sizeDifference);\n      *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) & 0xfb7f | 0x80;\n    }\n    else {\n      newBuffer = (void *)_realloc_r(errorCode,buffer[4],currentBuffer);\n      if (newBuffer == (void *)0x0) {\n        _free_r(errorCode,buffer[4]);\n        goto LAB_0800508a;\n      }\n    }\n    buffer[4] = newBuffer;\n    *buffer = (void *)((int)newBuffer + sizeDifference);\n    buffer[5] = currentBuffer;\n    buffer[2] = (void *)((int)currentBuffer - sizeDifference);\n    currentBuffer = sourceSize;\n  }\n  if (sourceSize <= currentBuffer) {\n    currentBuffer = sourceSize;\n  }\n  memmove(*buffer,source,(size_t)currentBuffer);\n  buffer[2] = (void *)((int)buffer[2] - (int)currentBuffer);\n  *buffer = (void *)((int)currentBuffer + (int)*buffer);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005044": "resize_and_copy_memory_08005044",
                "param_1": "errorCode",
                "param_2": "buffer",
                "param_3": "source",
                "param_4": "sourceSize",
                "pvVar1": "newBuffer",
                "pvVar2": "currentBuffer",
                "__n": "sizeDifference"
            },
            "calling": [
                "_svfiprintf_r"
            ],
            "called": [
                "_free_r",
                "memmove",
                "_malloc_r",
                "memcpy",
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080050fc": {
            "entrypoint": "0x080050fc",
            "current_name": "parse_and_format_string_080050fc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005294) */\n\nint parseAndFormatString_080050fc(undefined4 *output,int *flags,byte *format,int *args)\n\n{\n  bool isNumber;\n  int numValue;\n  int result;\n  void *memResult;\n  int *argIndex;\n  byte *currentChar;\n  byte *startChar;\n  int status;\n  int *argList;\n  uint flagMask;\n  int precision;\n  undefined4 padChar;\n  int width;\n  int resultCount;\n  byte specifier;\n  undefined STAR_FLAG;\n  undefined HASH_FLAG;\n  undefined PLUS_FLAG;\n  undefined4 lengthModifier;\n  \n  argList = args;\n  if (((int)((uint)*(ushort *)(flags + 3) << 0x18) < 0) && (flags[4] == 0)) {\n    numValue = _malloc_r(output,0x40);\n    *flags = numValue;\n    flags[4] = numValue;\n    if (numValue == 0) {\n      *output = 0xc;\n      return -1;\n    }\n    flags[5] = 0x40;\n  }\n  resultCount = 0;\n  STAR_FLAG = 0x20;\n  HASH_FLAG = 0x30;\n  currentChar = format;\nLAB_08005146:\n  startChar = currentChar;\n  if (*startChar != 0) goto LAB_080051ca;\n  goto LAB_08005150;\nLAB_080051ca:\n  currentChar = startChar + 1;\n  if (*startChar != 0x25) goto LAB_08005146;\nLAB_08005150:\n  numValue = (int)startChar - (int)format;\n  if (numValue != 0) {\n    result = __ssputs_r(output,flags,format,numValue);\n    if (result == -1) {\nLAB_080052ac:\n      if ((int)((uint)*(ushort *)(flags + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return resultCount;\n    }\n    resultCount = resultCount + numValue;\n  }\n  if (*startChar == 0) goto LAB_080052ac;\n  flagMask = 0;\n  width = 0;\n  precision = -1;\n  padChar = 0;\n  PLUS_FLAG = 0;\n  lengthModifier = 0;\n  currentChar = startChar + 1;\n  while( true ) {\n    memResult = memchr(&DAT_08007379,(uint)*currentChar,5);\n    format = currentChar + 1;\n    if (memResult == (void *)0x0) break;\n    flagMask = 1 << ((int)memResult + 0xf7ff8c87U & 0xff) | flagMask;\n    currentChar = format;\n  }\n  if ((int)(flagMask << 0x1b) < 0) {\n    PLUS_FLAG = 0x20;\n  }\n  if ((int)(flagMask << 0x1c) < 0) {\n    PLUS_FLAG = 0x2b;\n  }\n  if (*currentChar == 0x2a) {\n    argIndex = argList + 1;\n    numValue = *argList;\n    argList = argIndex;\n    if (numValue < 0) {\n      width = -numValue;\n      flagMask = flagMask | 2;\n      goto LAB_080051fc;\n    }\n  }\n  else {\n    isNumber = false;\n    numValue = width;\n    format = currentChar;\n    while( true ) {\n      if (9 < *format - 0x30) break;\n      numValue = numValue * 10 + (*format - 0x30);\n      isNumber = true;\n      format = format + 1;\n    }\n    if (!isNumber) goto LAB_080051fc;\n  }\n  width = numValue;\nLAB_080051fc:\n  if (*format == 0x2e) {\n    if (format[1] == 0x2a) {\n      format = format + 2;\n      argIndex = argList + 1;\n      precision = *argList;\n      argList = argIndex;\n      if (precision < 0) {\n        precision = -1;\n      }\n    }\n    else {\n      isNumber = false;\n      numValue = 0;\n      precision = 0;\n      while( true ) {\n        format = format + 1;\n        if (9 < *format - 0x30) break;\n        numValue = numValue * 10 + (*format - 0x30);\n        isNumber = true;\n      }\n      if (isNumber) {\n        precision = numValue;\n      }\n    }\n  }\n  memResult = memchr(&DAT_0800737f,(uint)*format,3);\n  if (memResult != (void *)0x0) {\n    format = format + 1;\n    flagMask = flagMask | 0x40 << ((int)memResult + 0xf7ff8c81U & 0xff);\n  }\n  specifier = *format;\n  format = format + 1;\n  memResult = memchr(\"efgEFG\",(uint)specifier,6);\n  if (memResult == (void *)0x0) {\n    status = _printf_i(output,&flagMask,flags,0x8005045,&argList);\n    if (status == -1) goto LAB_080052ac;\n  }\n  else {\n    argList = (int *)(((int)argList + 7U & 0xfffffff8) + 8);\n  }\n  resultCount = resultCount + status;\n  currentChar = format;\n  goto LAB_08005146;\n}\n\n",
            "renaming": {
                "FUN_080050fc": "parse_and_format_string_080050fc",
                "param_1": "output",
                "param_2": "flags",
                "param_3": "format",
                "param_4": "args",
                "bVar1": "isNumber",
                "iVar2": "numValue",
                "iVar3": "result",
                "pvVar4": "memResult",
                "piVar5": "argIndex",
                "pbVar6": "currentChar",
                "pbVar7": "startChar",
                "unaff_r9": "status",
                "local_8c": "argList",
                "local_88": "flagMask",
                "local_84": "precision",
                "local_80": "padChar",
                "local_7c": "width",
                "local_74": "resultCount",
                "local_70": "specifier",
                "local_6f": "STAR_FLAG",
                "local_6e": "HASH_FLAG",
                "local_45": "PLUS_FLAG",
                "local_30": "lengthModifier"
            },
            "calling": [
                "siprintf"
            ],
            "called": [
                "__ssputs_r",
                "memchr",
                "_malloc_r",
                "_printf_i"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052e4": {
            "entrypoint": "0x080052e4",
            "current_name": "process_data_080052e4",
            "code": "\nundefined4\nprocess_data_080052e4(undefined4 input,uint *data,uint *result,undefined4 param,code *callback)\n\n{\n  int index;\n  int returnValue;\n  uint maxValue;\n  uint newValue;\n  bool flag;\n  \n  maxValue = data[4];\n  if ((int)data[4] < (int)data[2]) {\n    maxValue = data[2];\n  }\n  *result = maxValue;\n  if (*(char *)((int)data + 0x43) != '\\0') {\n    *result = maxValue + 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *result = *result + 2;\n  }\n  if ((*data & 6) == 0) {\n    for (index = 0; index < (int)(data[3] - *result); index = index + 1) {\n      returnValue = (*callback)(input,param,(int)data + 0x19,1);\n      if (returnValue == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  maxValue = (uint)*(byte *)((int)data + 0x43);\n  if (maxValue != 0) {\n    maxValue = 1;\n  }\n  newValue = maxValue;\n  if ((int)(*data << 0x1a) < 0) {\n    *(undefined *)((int)data + maxValue + 0x43) = 0x30;\n    newValue = maxValue + 2;\n    *(undefined *)((int)data + maxValue + 0x44) = *(undefined *)((int)data + 0x45);\n  }\n  index = (*callback)(input,param,(int)data + 0x43,newValue);\n  if (index != -1) {\n    maxValue = data[3];\n    flag = (*data & 6) != 4;\n    if (flag) {\n      maxValue = 0;\n    }\n    newValue = 0;\n    if (!flag) {\n      maxValue = maxValue - *result;\n    }\n    if (!flag) {\n      maxValue = maxValue & ~((int)maxValue >> 0x1f);\n    }\n    if ((int)data[4] < (int)data[2]) {\n      maxValue = maxValue + (data[2] - data[4]);\n    }\n    while( true ) {\n      if (maxValue == newValue) {\n        return 0;\n      }\n      index = (*callback)(input,param,(int)data + 0x1a,1);\n      if (index == -1) break;\n      newValue = newValue + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080052e4": "process_data_080052e4",
                "param_1": "input",
                "param_2": "data",
                "param_3": "result",
                "param_4": "param",
                "param_5": "callback",
                "iVar1": "index",
                "iVar2": "returnValue",
                "uVar3": "maxValue",
                "uVar4": "newValue",
                "bVar5": "flag"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053d4": {
            "entrypoint": "0x080053d4",
            "current_name": "format_and_print_value_080053d4",
            "code": "\nuint formatAndPrintValue_080053d4(undefined4 arg_1,uint *value,undefined4 arg_3,code *printFunc,uint **arg_5)\n\n{\n  byte byteVal;\n  int result;\n  uint *ptr;\n  void *ptr2;\n  int index;\n  char *digits;\n  uint temp;\n  uint **ppuVar8;\n  char **ppcVar9;\n  uint base;\n  uint length;\n  char *str;\n  char *strPtr;\n  uint localArray [2];\n  \n  byteVal = *(byte *)(value + 6);\n  strPtr = (char *)((int)value + 0x43);\n  if (byteVal != 0x6e) {\n    if (byteVal < 0x6f) {\n      if (byteVal != 99) {\n        if (byteVal < 100) {\n          if (byteVal == 0) goto LAB_0800558e;\n          if (byteVal != 0x58) goto LAB_08005404;\n          *(undefined *)((int)value + 0x45) = 0x58;\n          digits = \"0123456789ABCDEF\";\nLAB_0800551e:\n          temp = *value;\n          ptr = *arg_5;\n          *arg_5 = ptr + 1;\n          if (((temp & 0x80) == 0) && ((int)(temp << 0x19) < 0)) {\n            base = (uint)*(ushort *)ptr;\n          }\n          else {\n            base = *ptr;\n          }\n          if ((int)(temp << 0x1f) < 0) {\n            *value = temp | 0x20;\n          }\n          if (base == 0) {\n            *value = *value & 0xffffffdf;\n          }\n          temp = 0x10;\nLAB_080054b4:\n          *(undefined *)((int)value + 0x43) = 0;\n        }\n        else {\n          if ((byteVal != 100) && (byteVal != 0x69)) goto LAB_08005404;\n          base = *value;\n          ptr = *arg_5;\n          if ((base & 0x80) == 0) {\n            *arg_5 = ptr + 1;\n            if ((base & 0x40) == 0) goto LAB_08005424;\n            base = (uint)(short)*(ushort *)ptr;\n          }\n          else {\n            *arg_5 = ptr + 1;\nLAB_08005424:\n            base = *ptr;\n          }\n          if ((int)base < 0) {\n            base = -base;\n            *(undefined *)((int)value + 0x43) = 0x2d;\n          }\n          digits = \"0123456789ABCDEF\";\n          temp = 10;\n        }\n        length = value[1];\n        value[2] = length;\n        str = strPtr;\n        if ((int)length < 0) {\n          if (base != 0) goto LAB_08005552;\nLAB_08005600:\n          *(char *)((int)value + 0x42) = *digits;\n          str = (char *)((int)value + 0x42);\n        }\n        else {\n          *value = *value & 0xfffffffb;\n          if (base == 0) {\n            if (length != 0) goto LAB_08005600;\n          }\n          else {\nLAB_08005552:\n            do {\n              length = base / temp;\n              str = str + -1;\n              *str = digits[base - temp * length];\n              base = length;\n            } while (length != 0);\n          }\n        }\n        if (((temp == 8) && ((int)(*value << 0x1f) < 0)) && ((int)value[1] <= (int)value[4]))\n        {\n          str[-1] = '0';\n          str = str + -1;\n        }\n        value[4] = (int)strPtr - (int)str;\n        strPtr = str;\n        goto LAB_080054fa;\n      }\n      ptr = *arg_5;\n      *arg_5 = ptr + 1;\n      *(char *)((int)value + 0x42) = (char)*ptr;\nLAB_08005464:\n      strPtr = (char *)((int)value + 0x42);\n      base = 1;\n    }\n    else {\n      if (byteVal != 0x73) {\n        if (byteVal < 0x74) {\n          if (byteVal == 0x6f) {\nLAB_0800548a:\n            base = *value;\n            ptr = *arg_5;\n            if ((base & 0x80) == 0) {\n              *arg_5 = ptr + 1;\n              if ((base & 0x40) == 0) goto LAB_08005498;\n              base = (uint)*(ushort *)ptr;\n            }\n            else {\n              *arg_5 = ptr + 1;\nLAB_08005498:\n              base = *ptr;\n            }\n            if (byteVal == 0x6f) {\n              temp = 8;\n            }\n            else {\n              temp = 10;\n            }\n            digits = \"0123456789ABCDEF\";\n            goto LAB_080054b4;\n          }\n          if (byteVal == 0x70) {\n            *value = *value | 0x20;\nLAB_0800544a:\n            digits = \"0123456789abcdef\";\n            *(undefined *)((int)value + 0x45) = 0x78;\n            goto LAB_0800551e;\n          }\n        }\n        else {\n          if (byteVal == 0x75) goto LAB_0800548a;\n          if (byteVal == 0x78) goto LAB_0800544a;\n        }\nLAB_08005404:\n        *(byte *)((int)value + 0x42) = byteVal;\n        goto LAB_08005464;\n      }\n      ppcVar9 = (char **)*arg_5;\n      *arg_5 = (uint *)(ppcVar9 + 1);\n      strPtr = *ppcVar9;\n      ptr2 = memchr(strPtr,0,value[1]);\n      if (ptr2 != (void *)0x0) {\n        value[1] = (int)ptr2 - (int)strPtr;\n      }\n      base = value[1];\n    }\n    value[4] = base;\n    *(undefined *)((int)value + 0x43) = 0;\n    goto LAB_080054fa;\n  }\n  base = *value;\n  ppuVar8 = (uint **)*arg_5;\n  temp = value[5];\n  if ((base & 0x80) == 0) {\n    *arg_5 = (uint *)(ppuVar8 + 1);\n    ptr = *ppuVar8;\n    if ((base & 0x40) == 0) goto LAB_0800557a;\n    *(short *)ptr = (short)temp;\n  }\n  else {\n    *arg_5 = (uint *)(ppuVar8 + 1);\n    ptr = *ppuVar8;\nLAB_0800557a:\n    *ptr = temp;\n  }\nLAB_0800558e:\n  value[4] = 0;\nLAB_080054fa:\n  result = _printf_common(arg_1,value,localArray,arg_3,printFunc);\n  if ((result == -1) || (result = (*printFunc)(arg_1,arg_3,strPtr,value[4]), result == -1)) {\nLAB_0800550e:\n    base = 0xffffffff;\n  }\n  else {\n    if ((int)(*value << 0x1e) < 0) {\n      for (result = 0; result < (int)(value[3] - localArray[0]); result = result + 1) {\n        index = (*printFunc)(arg_1,arg_3,(int)value + 0x19,1);\n        if (index == -1) goto LAB_0800550e;\n      }\n    }\n    base = value[3];\n    if ((int)value[3] < (int)localArray[0]) {\n      base = localArray[0];\n    }\n  }\n  return base;\n}\n\n",
            "renaming": {
                "FUN_080053d4": "format_and_print_value_080053d4",
                "param_1": "arg_1",
                "param_2": "value",
                "param_3": "arg_3",
                "param_4": "printFunc",
                "param_5": "arg_5",
                "bVar1": "byteVal",
                "iVar2": "result",
                "puVar3": "ptr",
                "pvVar4": "ptr2",
                "iVar5": "index",
                "pcVar6": "digits",
                "uVar7": "temp",
                "uVar10": "base",
                "uVar11": "length",
                "pcVar12": "str",
                "__s": "strPtr",
                "local_24": "localArray"
            },
            "calling": [
                "_svfiprintf_r"
            ],
            "called": [
                "_printf_common",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005614": {
            "entrypoint": "0x08005614",
            "current_name": "find_byte_in_buffer_08005614",
            "code": "\nvoid * find_byte_in_buffer_08005614(void *buffer,int byte_to_find,size_t buffer_length)\n\n{\n  byte *buffer_ptr;\n  byte *current_ptr;\n  \n  buffer_ptr = (byte *)buffer;\n  do {\n    current_ptr = buffer_ptr;\n    if (current_ptr == (byte *)(buffer_length + (int)buffer)) {\n      return (void *)0x0;\n    }\n    buffer_ptr = current_ptr + 1;\n  } while ((uint)*current_ptr != (byte_to_find & 0xffU));\n  return current_ptr;\n}\n\n",
            "renaming": {
                "FUN_08005614": "find_byte_in_buffer_08005614",
                "__s": "buffer",
                "__c": "byte_to_find",
                "__n": "buffer_length",
                "pbVar1": "buffer_ptr",
                "pbVar2": "current_ptr"
            },
            "calling": [
                "_svfiprintf_r",
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005630": {
            "entrypoint": "0x08005630",
            "current_name": "memcpy_reverse_08005630",
            "code": "\nvoid * memcpy_reverse_08005630(void *destination,void *source,size_t size)\n\n{\n  undefined *dest_ptr;\n  undefined *src_ptr;\n  \n  src_ptr = (undefined *)((int)destination + -1);\n  dest_ptr = (undefined *)(size + (int)source);\n  for (; (undefined *)source != dest_ptr; source = (void *)((int)source + 1)) {\n    src_ptr = src_ptr + 1;\n    *src_ptr = *source;\n                    /* WARNING: Load size is inaccurate */\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08005630": "memcpy_reverse_08005630",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr"
            },
            "calling": [
                "__ssputs_r",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005646": {
            "entrypoint": "0x08005646",
            "current_name": "mem_move_backward_08005646",
            "code": "\nvoid * mem_move_backward_08005646(void *dest,void *src,size_t size)\n\n{\n  undefined *dest_ptr;\n  int remaining_size;\n  undefined *src_ptr;\n  \n  src_ptr = (undefined *)((int)src + size);\n  if ((src < dest) && (dest < src_ptr)) {\n    dest_ptr = (undefined *)((int)dest + size);\n    remaining_size = size - (int)src_ptr;\n    while (src_ptr + remaining_size != (undefined *)0x0) {\n      src_ptr = src_ptr + -1;\n      dest_ptr = dest_ptr + -1;\n      *dest_ptr = *src_ptr;\n    }\n    return dest;\n  }\n  dest_ptr = (undefined *)((int)dest + -1);\n  for (; (undefined *)src != src_ptr; src = (void *)((int)src + 1)) {\n    dest_ptr = dest_ptr + 1;\n    *dest_ptr = *src;\n                    /* WARNING: Load size is inaccurate */\n  }\n  return dest;\n}\n\n",
            "renaming": {
                "FUN_08005646": "mem_move_backward_08005646",
                "__dest": "dest",
                "__src": "src",
                "__n": "size",
                "puVar1": "dest_ptr",
                "iVar2": "remaining_size",
                "puVar3": "src_ptr"
            },
            "calling": [
                "__ssputs_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800567c": {
            "entrypoint": "0x0800567c",
            "current_name": "initialize_memory_pool_0800567c",
            "code": "\nvoid initializeMemoryPool_0800567c(undefined4 *errorPtr,int poolSize,undefined4 param3,undefined4 param4)\n\n{\n  int **nextPool;\n  int **currentPool;\n  int **nextPool;\n  int *tempPtr;\n  int **previousPool;\n  int **poolPtr;\n  \n  if (poolSize == 0) {\n    return;\n  }\n  poolPtr = (int **)(poolSize + -4);\n  if (*(int *)(poolSize + -4) < 0) {\n    poolPtr = (int **)((int)poolPtr + *(int *)(poolSize + -4));\n  }\n  __malloc_lock();\n  nextPool = (int **)&__malloc_free_list;\n  if (__malloc_free_list == (int **)0x0) {\n    poolPtr[1] = (int *)0x0;\n    currentPool = nextPool;\n    __malloc_free_list = poolPtr;\n  }\n  else {\n    nextPool = __malloc_free_list;\n    if (poolPtr < __malloc_free_list) {\n      currentPool = (int **)*poolPtr;\n      nextPool = (int **)((int)poolPtr + (int)currentPool);\n      if (__malloc_free_list == nextPool) {\n        tempPtr = *__malloc_free_list;\n        __malloc_free_list = (int **)__malloc_free_list[1];\n        nextPool = (int **)((int)tempPtr + (int)currentPool);\n        *poolPtr = (int *)nextPool;\n      }\n      poolPtr[1] = (int *)__malloc_free_list;\n      __malloc_free_list = poolPtr;\n    }\n    else {\n      do {\n        previousPool = nextPool;\n        nextPool = (int **)previousPool[1];\n        if (nextPool == (int **)0x0) break;\n      } while (nextPool <= poolPtr);\n      currentPool = (int **)*previousPool;\n      if ((int **)((int)previousPool + (int)currentPool) == poolPtr) {\n        currentPool = (int **)((int)currentPool + (int)*poolPtr);\n        *previousPool = (int *)currentPool;\n        if (nextPool == (int **)((int)previousPool + (int)currentPool)) {\n          tempPtr = *nextPool;\n          nextPool = (int **)nextPool[1];\n          currentPool = (int **)((int)currentPool + (int)tempPtr);\n          *previousPool = (int *)currentPool;\n          previousPool[1] = (int *)nextPool;\n        }\n      }\n      else if (poolPtr < (int **)((int)previousPool + (int)currentPool)) {\n        *errorPtr = 0xc;\n      }\n      else {\n        currentPool = (int **)((int)poolPtr + (int)*poolPtr);\n        if (nextPool == currentPool) {\n          tempPtr = *nextPool;\n          nextPool = (int **)nextPool[1];\n          currentPool = (int **)((int)tempPtr + (int)*poolPtr);\n          *poolPtr = (int *)currentPool;\n        }\n        poolPtr[1] = (int *)nextPool;\n        previousPool[1] = (int *)poolPtr;\n      }\n    }\n  }\n  __malloc_unlock(errorPtr,currentPool,nextPool,param4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800567c": "initialize_memory_pool_0800567c",
                "param_1": "errorPtr",
                "param_2": "poolSize",
                "param_3": "param3",
                "param_4": "param4",
                "extraout_r1": "nextPool",
                "ppiVar1": "currentPool",
                "ppiVar2": "nextPool",
                "piVar3": "tempPtr",
                "ppiVar4": "previousPool",
                "ppiVar5": "poolPtr"
            },
            "calling": [
                "__ssputs_r",
                "_realloc_r"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "allocate_memory_08005714",
            "code": "\nuint allocate_memory_08005714(undefined4 *size_ptr,uint size)\n\n{\n  uint *current_block;\n  int block_size;\n  uint *previous_block;\n  uint size_diff;\n  uint *new_block;\n  uint allocated_size;\n  \n  allocated_size = (size + 3 & 0xfffffffc) + 8;\n  if (allocated_size < 0xc) {\n    allocated_size = 0xc;\n  }\n  if (((int)allocated_size < 0) || (allocated_size < size)) {\n    *size_ptr = 0xc;\n  }\n  else {\n    lock_memory();\n    current_block = free_list;\n    new_block = free_list;\n    while (previous_block = current_block, previous_block != (uint *)0x0) {\n      size_diff = *previous_block - allocated_size;\n      if (-1 < (int)size_diff) {\n        if (size_diff < 0xc) {\n          if (new_block == previous_block) {\n            current_block = (uint *)new_block[1];\n            free_list = current_block;\n          }\n          else {\n            current_block = (uint *)previous_block[1];\n          }\n          if (new_block != previous_block) {\n            new_block[1] = (uint)current_block;\n            new_block = previous_block;\n          }\n        }\n        else {\n          *previous_block = size_diff;\n          *(uint *)((int)previous_block + size_diff) = allocated_size;\n          new_block = (uint *)((int)previous_block + size_diff);\n        }\n        goto LAB_08005778;\n      }\n      new_block = previous_block;\n      current_block = (uint *)previous_block[1];\n    }\n    if (sbrk_start == 0) {\n      sbrk_start = sbrk_wrapper(size_ptr);\n    }\n    current_block = (uint *)sbrk_wrapper(size_ptr,allocated_size);\n    if ((current_block != (uint *)0xffffffff) &&\n       ((new_block = (uint *)((int)current_block + 3U & 0xfffffffc), current_block == new_block ||\n        (block_size = sbrk_wrapper(size_ptr,(int)new_block - (int)current_block), block_size != -1)))) {\n      *new_block = allocated_size;\nLAB_08005778:\n      unlock_memory(size_ptr);\n      allocated_size = (int)new_block + 0xbU & 0xfffffff8;\n      block_size = allocated_size - (int)(new_block + 1);\n      if (block_size != 0) {\n        *(int *)((int)new_block + block_size) = -block_size;\n        return allocated_size;\n      }\n      return allocated_size;\n    }\n    *size_ptr = 0xc;\n    unlock_memory(size_ptr);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005714": "allocate_memory_08005714",
                "param_1": "size_ptr",
                "param_2": "size",
                "puVar1": "current_block",
                "iVar2": "block_size",
                "puVar3": "previous_block",
                "uVar4": "size_diff",
                "puVar5": "new_block",
                "uVar6": "allocated_size",
                "__malloc_lock": "lock_memory",
                "__malloc_free_list": "free_list",
                "__malloc_sbrk_start": "sbrk_start",
                "_sbrk_r": "sbrk_wrapper",
                "__malloc_unlock": "unlock_memory"
            },
            "calling": [
                "__ssputs_r",
                "_svfiprintf_r",
                "_realloc_r"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock",
                "_sbrk_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057d0": {
            "entrypoint": "0x080057d0",
            "current_name": "allocate_or_copy_memory_080057d0",
            "code": "\nvoid * allocateOrCopyMemory_080057d0(undefined4 ptrInput,void *ptrData,uint size,undefined4 ptrOutput)\n\n{\n  void *newPtr;\n  uint usableSize;\n  \n  if (ptrData != (void *)0x0) {\n    if (size == 0) {\n      _free_r();\n      newPtr = (void *)0x0;\n    }\n    else {\n      usableSize = _malloc_usable_size_r();\n      newPtr = ptrData;\n      if ((usableSize < size) && (newPtr = (void *)_malloc_r(ptrInput,size), newPtr != (void *)0x0))\n      {\n        memcpy(newPtr,ptrData,size);\n        _free_r(ptrInput,ptrData);\n      }\n    }\n    return newPtr;\n  }\n  newPtr = (void *)_malloc_r(ptrInput,size,size,ptrOutput);\n  return newPtr;\n}\n\n",
            "renaming": {
                "FUN_080057d0": "allocate_or_copy_memory_080057d0",
                "param_1": "ptrInput",
                "param_2": "ptrData",
                "param_3": "size",
                "param_4": "ptrOutput",
                "pvVar1": "newPtr",
                "uVar2": "usableSize"
            },
            "calling": [
                "__ssputs_r"
            ],
            "called": [
                "_free_r",
                "_malloc_usable_size_r",
                "_malloc_r",
                "memcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800581c": {
            "entrypoint": "0x0800581c",
            "current_name": "allocate_memory_0800581c",
            "code": "\nvoid allocate_memory_0800581c(int *error_code_ptr,intptr_t size)\n\n{\n  void *allocated_memory;\n  \n  errno = 0;\n  allocated_memory = _sbrk(size);\n  if ((allocated_memory == (void *)0xffffffff) && (errno != 0)) {\n    *error_code_ptr = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800581c": "allocate_memory_0800581c",
                "param_1": "error_code_ptr",
                "param_2": "size",
                "pvVar1": "allocated_memory"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800583c": {
            "entrypoint": "0x0800583c",
            "current_name": "FUNC_0800583c",
            "code": "\nvoid FUNC_0800583c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800583c": "FUNC_0800583c"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800583e": {
            "entrypoint": "0x0800583e",
            "current_name": "FUNC_0800583e",
            "code": "\nvoid FUNC_0800583e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800583e": "FUNC_0800583e"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005840": {
            "entrypoint": "0x08005840",
            "current_name": "calculate_result_08005840",
            "code": "\nint calculateResult_08005840(undefined4 unknownValue,int pointerOffset)\n\n{\n  int adjustedOffset;\n  \n  adjustedOffset = *(int *)(pointerOffset + -4) + -4;\n  if (*(int *)(pointerOffset + -4) < 0) {\n    adjustedOffset = adjustedOffset + *(int *)(pointerOffset + adjustedOffset);\n  }\n  return adjustedOffset;\n}\n\n",
            "renaming": {
                "FUN_08005840": "calculate_result_08005840",
                "param_1": "unknownValue",
                "param_2": "pointerOffset",
                "iVar1": "adjustedOffset"
            },
            "calling": [
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005854": {
            "entrypoint": "0x08005854",
            "current_name": "calculate_asin_08005854",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080058d4) */\n\ndouble calculate_asin_08005854(double input_value)\n\n{\n  int comparison_result;\n  undefined4 *error_pointer;\n  double result;\n  double temp_result_1;\n  double temp_result_2;\n  double temp_result_3;\n  double temp_result_4;\n  int stack_value_1;\n  char *stack_value_2;\n  \n  result = (double)__ieee754_asin();\n  if ((__fdlib_version != -1) && (comparison_result = __unorddf2(), result = temp_result_1, comparison_result == 0)) {\n    fabs((double)CONCAT44(stack_value_2,stack_value_1));\n    comparison_result = __aeabi_dcmpgt();\n    result = temp_result_2;\n    if ((comparison_result != 0) &&\n       ((nan(\"\"), __fdlib_version == '\\x02' ||\n        (comparison_result = matherr((exception *)&stack0xffffffb8), result = temp_result_4, comparison_result == 0)))) {\n      error_pointer = (undefined4 *)__errno();\n      *error_pointer = 0x21;\n      result = temp_result_3;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005854": "calculate_asin_08005854",
                "__x": "input_value",
                "iVar1": "comparison_result",
                "puVar2": "error_pointer",
                "dVar3": "result",
                "extraout_d0": "temp_result_1",
                "extraout_d0_00": "temp_result_2",
                "extraout_d0_01": "temp_result_3",
                "extraout_d0_02": "temp_result_4",
                "in_stack_ffffffb8": "stack_value_1",
                "in_stack_ffffffbc": "stack_value_2"
            },
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__errno",
                "fabs",
                "matherr",
                "__aeabi_dcmpgt",
                "nan",
                "__ieee754_asin",
                "__unorddf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058fc": {
            "entrypoint": "0x080058fc",
            "current_name": "FUN_080058fc",
            "code": "\nundefined8 __ieee754_atan2(uint param_1,uint param_2,uint param_3,uint param_4,double param_5)\n\n{\n  undefined4 uVar1;\n  undefined4 extraout_r1;\n  int extraout_r1_00;\n  undefined4 unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  uint uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  \n  uVar5 = param_4 & 0x7fffffff;\n  if ((0x7ff00000 < (uVar5 | (-param_3 | param_3) >> 0x1f)) ||\n     (uVar3 = param_2 & 0x7fffffff, 0x7ff00000 < (uVar3 | (-param_1 | param_1) >> 0x1f))) {\n    uVar6 = __aeabi_dadd(param_1,param_2);\n    return uVar6;\n  }\n  if ((param_4 + 0xc0100000 | param_3) == 0) {\n    atan(param_5);\n    return CONCAT44(extraout_r1,param_1);\n  }\n  uVar2 = (int)param_4 >> 0x1e & 2U | param_2 >> 0x1f;\n  if ((param_1 | uVar3) == 0) {\n    if (uVar2 == 2) {\n      return 0x400921fb54442d18;\n    }\n    if (uVar2 != 3) {\n      return CONCAT44(param_2,param_1);\n    }\nLAB_0800613e:\n    uVar6 = 0xc00921fb54442d18;\n  }\n  else {\n    if ((param_3 | uVar5) != 0) {\n      if (uVar5 == 0x7ff00000) {\n        if (uVar3 == 0x7ff00000) {\n          if (uVar2 == 2) {\n            return 0x4002d97c7f3321d2;\n          }\n          if (uVar2 == 3) {\n            return 0xc002d97c7f3321d2;\n          }\n          if (uVar2 != 1) {\n            return 0x3fe921fb54442d18;\n          }\n          return 0xbfe921fb54442d18;\n        }\n        if (uVar2 == 2) {\n          return 0x400921fb54442d18;\n        }\n        if (uVar2 != 3) {\n          if (uVar2 != 1) {\n            return 0;\n          }\n          return 0x8000000000000000;\n        }\n        goto LAB_0800613e;\n      }\n      if (uVar3 != 0x7ff00000) {\n        iVar4 = (int)(uVar3 - uVar5) >> 0x14;\n        if (iVar4 < 0x3d) {\n          if (((int)param_4 < 0) && (iVar4 + 0x3c < 0 != SCARRY4(iVar4,0x3c))) {\n            uVar1 = 0;\n            iVar4 = 0;\n          }\n          else {\n            uVar1 = __divdf3(param_1,param_2);\n            fabs((double)CONCAT44(unaff_r4,param_4));\n            atan((double)CONCAT44(unaff_r4,param_4));\n            iVar4 = extraout_r1_00;\n          }\n        }\n        else {\n          uVar1 = 0x54442d18;\n          iVar4 = 0x3ff921fb;\n        }\n        if (uVar2 == 1) {\n          return CONCAT44(iVar4 + -0x80000000,uVar1);\n        }\n        if (uVar2 == 2) {\n          uVar7 = __subdf3(uVar1,iVar4,0x33145c07,0x3ca1a626);\n          uVar6 = 0x400921fb54442d18;\n        }\n        else {\n          if (uVar2 == 0) {\n            return CONCAT44(iVar4,uVar1);\n          }\n          uVar6 = __subdf3(uVar1,iVar4,0x33145c07,0x3ca1a626);\n          uVar7 = 0x400921fb54442d18;\n        }\n        uVar6 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),(int)uVar7,\n                         (int)((ulonglong)uVar7 >> 0x20));\n        return uVar6;\n      }\n    }\n    if ((int)param_2 < 0) {\n      uVar6 = 0xbff921fb54442d18;\n    }\n    else {\n      uVar6 = 0x3ff921fb54442d18;\n    }\n  }\n  return uVar6;\n}\n\n",
            "renaming": {},
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__ieee754_atan2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005900": {
            "entrypoint": "0x08005900",
            "current_name": "calculate_power_08005900",
            "code": "\ndouble calculatePower_08005900(double base,double exponent)\n\n{\n  char versionCheck;\n  int comparisonResult;\n  int *errnoPtr;\n  undefined4 *errnoRet;\n  int finiteCheck;\n  undefined4 tempOut1;\n  undefined4 tempOut2;\n  undefined4 errorVal;\n  double retValue1;\n  double retValue2;\n  double retValue3;\n  double retValue4;\n  double retValue5;\n  double retValue6;\n  double retValue7;\n  double retValue8;\n  double retValue9;\n  double retValue10;\n  double retValue11;\n  double retValue12;\n  double retValue13;\n  double retValue14;\n  double tempValue;\n  undefined8 tempValueMul;\n  undefined exception [24];\n  undefined8 retValue;\n  int errnoVal;\n  \n  tempValue = (double)__ieee754_pow();\n  versionCheck = __fdlib_version;\n  if (__fdlib_version == -1) {\n    return retValue1;\n  }\n  comparisonResult = __unorddf2();\n  if (comparisonResult != 0) {\n    return retValue2;\n  }\n  comparisonResult = __unorddf2();\n  if (comparisonResult != 0) {\n    comparisonResult = __aeabi_dcmpeq();\n    if (comparisonResult == 0) {\n      return retValue3;\n    }\n    exception._0_4_ = 1;\n    exception._4_4_ = \"pow\";\n    retValue = 1.0;\n    errnoVal = 0;\n    if (versionCheck == '\\x02') {\n      return retValue3;\n    }\n    goto LAB_08005978;\n  }\n  comparisonResult = __aeabi_dcmpeq();\n  if (comparisonResult == 0) {\n    comparisonResult = finite(tempValue);\n    if ((comparisonResult == 0) && (finiteCheck = finite(tempValue), finiteCheck != 0)) {\n      finiteCheck = finite(tempValue);\n      if (finiteCheck == 0) goto LAB_08005b4c;\n      errnoVal = __unorddf2(SUB84(tempValue,0),(int)((ulonglong)tempValue >> 0x20));\n      versionCheck = __fdlib_version;\n      if (errnoVal != 0) {\n        exception._4_4_ = \"pow\";\n        exception._0_4_ = 1;\n        errnoVal = comparisonResult;\n        if (__fdlib_version == '\\0') goto LAB_08005a22;\n        retValue = (double)__divdf3(0,0,0,0);\n        goto LAB_08005a32;\n      }\n      exception._4_4_ = \"pow\";\n      exception._0_4_ = 3;\n      if (__fdlib_version != '\\0') {\n        retValue._0_4_ = 0;\n        retValue._4_4_ = 0x7ff00000;\n        comparisonResult = __aeabi_dcmplt();\n        if (comparisonResult != 0) {\n          tempValueMul = __muldf3();\n          errorVal = (int)tempValueMul;\n          rint(tempValue);\n          comparisonResult = __aeabi_dcmpeq((int)tempValueMul,(int)((ulonglong)tempValueMul >> 0x20),errorVal,tempOut2);\n          if (comparisonResult == 0) {\n            retValue._0_4_ = 0;\n            retValue._4_4_ = 0xfff00000;\n          }\n        }\n        goto LAB_08005afa;\n      }\n      retValue._0_4_ = 0xe0000000;\n      retValue._4_4_ = 0x47efffff;\n      comparisonResult = __aeabi_dcmplt();\n      if (comparisonResult != 0) {\n        tempValueMul = __muldf3();\n        errorVal = (int)tempValueMul;\n        rint(tempValue);\n        comparisonResult = __aeabi_dcmpeq((int)tempValueMul,(int)((ulonglong)tempValueMul >> 0x20),errorVal,tempOut1);\n        if (comparisonResult == 0) {\n          retValue._0_4_ = 0xe0000000;\n          retValue._4_4_ = 0xc7efffff;\n        }\n        goto LAB_08005afa;\n      }\nLAB_08005b98:\n      comparisonResult = matherr((exception *)exception);\n      tempValue = retValue14;\n      if (comparisonResult != 0) goto LAB_080059d0;\n    }\n    else {\nLAB_08005b4c:\n      comparisonResult = __aeabi_dcmpeq(SUB84(tempValue,0),(int)((ulonglong)tempValue >> 0x20),0,0);\n      if (comparisonResult == 0) {\n        return retValue11;\n      }\n      comparisonResult = finite(tempValue);\n      if (comparisonResult == 0) {\n        return retValue12;\n      }\n      comparisonResult = finite(tempValue);\n      if (comparisonResult == 0) {\n        return retValue13;\n      }\n      exception._0_4_ = 4;\n      exception._4_4_ = \"pow\";\n      errnoVal = 0;\n      retValue._0_4_ = 0;\n      retValue._4_4_ = 0;\nLAB_08005afa:\n      if (__fdlib_version != '\\x02') goto LAB_08005b98;\n    }\n    errnoRet = (undefined4 *)__errno();\n    errorVal = 0x22;\n    tempValue = retValue10;\n  }\n  else {\n    comparisonResult = __aeabi_dcmpeq();\n    if (comparisonResult == 0) {\n      comparisonResult = finite(tempValue);\n      if (comparisonResult == 0) {\n        return retValue7;\n      }\n      comparisonResult = __aeabi_dcmplt();\n      if (comparisonResult == 0) {\n        return retValue8;\n      }\n      exception._0_4_ = 1;\n      exception._4_4_ = \"pow\";\n      errnoVal = 0;\n      if (__fdlib_version == '\\0') {\nLAB_08005a22:\n        exception._4_4_ = \"pow\";\n        exception._0_4_ = 1;\n        retValue = 0.0;\n        goto LAB_08005978;\n      }\n      retValue = -INFINITY;\n      errnoVal = 0;\n      versionCheck = __fdlib_version;\nLAB_08005a32:\n      if (versionCheck != '\\x02') goto LAB_08005978;\n    }\n    else {\n      exception._0_4_ = 1;\n      exception._4_4_ = \"pow\";\n      retValue = 0.0;\n      errnoVal = 0;\n      if (versionCheck != '\\0') {\n        retValue = 1.0;\n        tempValue = retValue5;\n        goto LAB_080059d0;\n      }\nLAB_08005978:\n      comparisonResult = matherr((exception *)exception);\n      tempValue = retValue4;\n      if (comparisonResult != 0) goto LAB_080059d0;\n    }\n    errnoRet = (undefined4 *)__errno();\n    errorVal = 0x21;\n    tempValue = retValue9;\n  }\n  *errnoRet = errorVal;\nLAB_080059d0:\n  if (errnoVal != 0) {\n    errnoPtr = (int *)__errno();\n    *errnoPtr = errnoVal;\n    tempValue = retValue6;\n  }\n  return tempValue;\n}\n\n",
            "renaming": {
                "FUN_08005900": "calculate_power_08005900",
                "__x": "base",
                "__y": "exponent",
                "cVar1": "versionCheck",
                "iVar2": "comparisonResult",
                "piVar3": "errnoPtr",
                "puVar4": "errnoRet",
                "iVar5": "finiteCheck",
                "local_50": "exception",
                "local_38": "retValue",
                "local_30": "errnoVal",
                "extraout_r1": "tempOut1",
                "extraout_r1_00": "tempOut2",
                "uVar6": "errorVal",
                "extraout_d0": "retValue1",
                "extraout_d0_00": "retValue2",
                "extraout_d0_01": "retValue3",
                "extraout_d0_02": "retValue4",
                "extraout_d0_03": "retValue5",
                "extraout_d0_04": "retValue6",
                "extraout_d0_05": "retValue7",
                "extraout_d0_06": "retValue8",
                "extraout_d0_07": "retValue9",
                "extraout_d0_08": "retValue10",
                "extraout_d0_09": "retValue11",
                "extraout_d0_10": "retValue12",
                "extraout_d0_11": "retValue13",
                "extraout_d0_12": "retValue14",
                "dVar7": "tempValue",
                "uVar8": "tempValueMul"
            },
            "calling": [
                "MS5611_Update"
            ],
            "called": [
                "__aeabi_dcmpeq",
                "__aeabi_dcmplt",
                "__errno",
                "rint",
                "matherr",
                "__muldf3",
                "finite",
                "__ieee754_pow",
                "__unorddf2",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bc8": {
            "entrypoint": "0x08005bc8",
            "current_name": "calculate_square_root_with_error_handling_08005bc8",
            "code": "\ndouble calculateSquareRootWithErrorHandling_08005bc8(double input)\n\n{\n  char versionFlag;\n  int comparisonResult;\n  int *errorPointer;\n  undefined4 *errnoPointer;\n  double squareRoot;\n  double output1;\n  double output2;\n  double output3;\n  double output4;\n  double output5;\n  undefined exceptionData [24];\n  undefined8 zero;\n  int exceptionCode;\n  \n  squareRoot = (double)__ieee754_sqrt();\n  versionFlag = __fdlib_version;\n  if (__fdlib_version == -1) {\n    return squareRoot;\n  }\n  exceptionCode = __unorddf2();\n  if (exceptionCode != 0) {\n    return output1;\n  }\n  comparisonResult = __aeabi_dcmplt();\n  if (comparisonResult == 0) {\n    return output2;\n  }\n  exceptionData._0_4_ = 1;\n  exceptionData._4_4_ = \"sqrt\";\n  if (versionFlag == '\\0') {\n    zero = 0.0;\nLAB_08005c26:\n    comparisonResult = matherr((exception *)exceptionData);\n    squareRoot = output3;\n    if (comparisonResult != 0) goto LAB_08005c2e;\n  }\n  else {\n    zero = (double)__divdf3(0,0,0,0);\n    if (versionFlag != '\\x02') goto LAB_08005c26;\n  }\n  errnoPointer = (undefined4 *)__errno();\n  *errnoPointer = 0x21;\n  squareRoot = output5;\nLAB_08005c2e:\n  if (exceptionCode != 0) {\n    errorPointer = (int *)__errno();\n    *errorPointer = exceptionCode;\n    squareRoot = output4;\n  }\n  return squareRoot;\n}\n\n",
            "renaming": {
                "FUN_08005bc8": "calculate_square_root_with_error_handling_08005bc8",
                "__x": "input",
                "cVar1": "versionFlag",
                "iVar2": "comparisonResult",
                "piVar3": "errorPointer",
                "puVar4": "errnoPointer",
                "dVar5": "squareRoot",
                "extraout_d0": "output1",
                "extraout_d0_00": "output2",
                "extraout_d0_01": "output3",
                "extraout_d0_02": "output4",
                "extraout_d0_03": "output5",
                "local_50": "exceptionData",
                "local_38": "zero",
                "local_30": "exceptionCode"
            },
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__aeabi_dcmplt",
                "__errno",
                "matherr",
                "__ieee754_sqrt",
                "__divdf3",
                "__unorddf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c70": {
            "entrypoint": "0x08005c70",
            "current_name": "calculate_sqrt_division_08005c70",
            "code": "\nundefined8 calculate_sqrt_division_08005c70(uint value1,uint value2)\n\n{\n  int comparisonResult;\n  undefined4 extraOutput1;\n  undefined4 var1;\n  undefined4 var2;\n  undefined4 var3;\n  undefined4 var4;\n  undefined4 var5;\n  undefined4 var6;\n  uint unsignedVar;\n  undefined8 result;\n  undefined8 tempVar1;\n  undefined8 tempVar2;\n  undefined4 stackVar;\n  \n  result = CONCAT44(value2,value1);\n  unsignedVar = value2 & 0x7fffffff;\n  if (unsignedVar < 0x3ff00000) {\n    if (unsignedVar < 0x3fe00000) {\n      if (0x3e3fffff < unsignedVar) {\n        tempVar1 = __muldf3(value1,value2,value1,value2);\n        var6 = (undefined4)((ulonglong)tempVar1 >> 0x20);\n        var5 = (undefined4)tempVar1;\n        tempVar1 = __muldf3(var5,var6,0xdfdf709,0x3f023de1);\n        tempVar1 = __aeabi_dadd((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0x7501b288,0x3f49efe0);\n        tempVar1 = __muldf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),var5,var6);\n        tempVar1 = __subdf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0xb5688f3b,0x3fa48228);\n        tempVar1 = __muldf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),var5,var6);\n        tempVar1 = __aeabi_dadd((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0xe884455,0x3fc9c155);\n        tempVar1 = __muldf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),var5,var6);\n        tempVar1 = __subdf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0x3eb6f7d,0x3fd4d612);\n        tempVar1 = __muldf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),var5,var6);\n        tempVar1 = __aeabi_dadd((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0x55555555,0x3fc55555);\n        tempVar1 = __muldf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),var5,var6);\n        tempVar2 = __muldf3(var5,var6,0xb12e9282,0x3fb3b8c5);\n        tempVar2 = __subdf3((int)tempVar2,(int)((ulonglong)tempVar2 >> 0x20),0x1b8d0159,0x3fe6066c);\n        tempVar2 = __muldf3((int)tempVar2,(int)((ulonglong)tempVar2 >> 0x20),var5,var6);\n        tempVar2 = __aeabi_dadd((int)tempVar2,(int)((ulonglong)tempVar2 >> 0x20),0x9c598ac8,0x40002ae5);\n        tempVar2 = __muldf3((int)tempVar2,(int)((ulonglong)tempVar2 >> 0x20),var5,var6);\n        tempVar2 = __subdf3((int)tempVar2,(int)((ulonglong)tempVar2 >> 0x20),0x1c8a2d4b,0x40033a27);\n        tempVar2 = __muldf3((int)tempVar2,(int)((ulonglong)tempVar2 >> 0x20),var5,var6);\n        tempVar2 = __aeabi_dadd((int)tempVar2,(int)((ulonglong)tempVar2 >> 0x20),0,0x3ff00000);\n        tempVar1 = __divdf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),(int)tempVar2,\n                          (int)((ulonglong)tempVar2 >> 0x20));\n        tempVar1 = __muldf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),value1,value2);\n        goto LAB_08005cba;\n      }\n      tempVar1 = __aeabi_dadd(value1,value2,0x8800759c,0x7e37e43c);\n      comparisonResult = __aeabi_dcmpgt((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0,0x3ff00000);\n      if (comparisonResult != 0) {\n        return result;\n      }\n    }\n    fabs((double)CONCAT44(value2,stackVar));\n    result = __subdf3(0,0x3ff00000,value1,extraOutput1);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),0,0x3fe00000);\n    var1 = (undefined4)((ulonglong)result >> 0x20);\n    var5 = (undefined4)result;\n    result = __muldf3(var5,var1,0xdfdf709,0x3f023de1);\n    result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),0x7501b288,0x3f49efe0);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),var5,var1);\n    result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),0xb5688f3b,0x3fa48228);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),var5,var1);\n    result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),0xe884455,0x3fc9c155);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),var5,var1);\n    result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),0x3eb6f7d,0x3fd4d612);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),var5,var1);\n    result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),0x55555555,0x3fc55555);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),var5,var1);\n    var2 = (undefined4)((ulonglong)result >> 0x20);\n    tempVar1 = __muldf3(var5,var1,0xb12e9282,0x3fb3b8c5);\n    tempVar1 = __subdf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0x1b8d0159,0x3fe6066c);\n    tempVar1 = __muldf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),var5,var1);\n    tempVar1 = __aeabi_dadd((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0x9c598ac8,0x40002ae5);\n    tempVar1 = __muldf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),var5,var1);\n    tempVar1 = __subdf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0x1c8a2d4b,0x40033a27);\n    tempVar1 = __muldf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),var5,var1);\n    tempVar1 = __aeabi_dadd((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0,0x3ff00000);\n    var3 = (undefined4)((ulonglong)tempVar1 >> 0x20);\n    tempVar2 = __ieee754_sqrt(var5,var1);\n    var4 = (undefined4)((ulonglong)tempVar2 >> 0x20);\n    var6 = (undefined4)tempVar2;\n    if (unsignedVar < 0x3fef3333) {\n      result = __divdf3((int)result,var2,(int)tempVar1,var3);\n      tempVar1 = __aeabi_dadd(var6,var4,var6,var4);\n      result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),(int)tempVar1,\n                       (int)((ulonglong)tempVar1 >> 0x20));\n      tempVar1 = __muldf3(0,var4,0,var4);\n      tempVar1 = __subdf3(var5,var1,(int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20));\n      tempVar2 = __aeabi_dadd(var6,var4,0,var4);\n      tempVar1 = __divdf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),(int)tempVar2,\n                        (int)((ulonglong)tempVar2 >> 0x20));\n      var5 = (undefined4)((ulonglong)tempVar1 >> 0x20);\n      tempVar1 = __aeabi_dadd((int)tempVar1,var5,(int)tempVar1,var5);\n      tempVar1 = __subdf3(0x33145c07,0x3c91a626,(int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20));\n      result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),(int)tempVar1,\n                       (int)((ulonglong)tempVar1 >> 0x20));\n      tempVar1 = __aeabi_dadd(0,var4,0,var4);\n      tempVar1 = __subdf3(0x54442d18,0x3fe921fb,(int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20));\n      result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),(int)tempVar1,\n                       (int)((ulonglong)tempVar1 >> 0x20));\n      var5 = 0x3fe921fb;\n    }\n    else {\n      result = __divdf3((int)result,var2,(int)tempVar1,var3);\n      result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),var6,var4);\n      result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),var6,var4);\n      var5 = (undefined4)((ulonglong)result >> 0x20);\n      result = __aeabi_dadd((int)result,var5,(int)result,var5);\n      result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),0x33145c07,0x3c91a626);\n      var5 = 0x3ff921fb;\n    }\n    result = __subdf3(0x54442d18,var5,(int)result,(int)((ulonglong)result >> 0x20));\n    if ((int)value2 < 1) {\n      result = CONCAT44((int)((ulonglong)result >> 0x20) + -0x80000000,(int)result);\n    }\n  }\n  else {\n    if ((unsignedVar + 0xc0100000 | value1) != 0) {\n      result = __subdf3(value1,value2,value1,value2);\n      var5 = (undefined4)((ulonglong)result >> 0x20);\n      result = __divdf3((int)result,var5,(int)result,var5);\n      return result;\n    }\n    result = __muldf3(value1,value2,0x54442d18,0x3ff921fb);\n    tempVar1 = __muldf3(value1,value2,0x33145c07,0x3c91a626);\nLAB_08005cba:\n    result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),(int)tempVar1,\n                         (int)((ulonglong)tempVar1 >> 0x20));\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005c70": "calculate_sqrt_division_08005c70",
                "param_1": "value1",
                "param_2": "value2",
                "iVar1": "comparisonResult",
                "extraout_r1": "extraOutput1",
                "uVar2": "var1",
                "uVar3": "var2",
                "uVar4": "var3",
                "uVar5": "var4",
                "uVar6": "var5",
                "uVar7": "var6",
                "uVar8": "unsignedVar",
                "uVar9": "result",
                "uVar10": "tempVar1",
                "uVar11": "tempVar2",
                "in_stack_ffffffc8": "stackVar"
            },
            "calling": [
                "asin"
            ],
            "called": [
                "fabs",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__ieee754_sqrt",
                "__muldf3",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006070": {
            "entrypoint": "0x08006070",
            "current_name": "calculate_result_08006070",
            "code": "\nundefined8 calculate_result_08006070(uint input1,uint input2,uint input3,uint input4,double input5)\n\n{\n  undefined4 result1;\n  undefined4 result2;\n  int result3;\n  undefined4 result4;\n  uint flag1;\n  uint flag2;\n  int flag3;\n  uint masked_input4;\n  undefined8 output1;\n  undefined8 output2;\n  \n  masked_input4 = input4 & 0x7fffffff;\n  if ((0x7ff00000 < (masked_input4 | (-input3 | input3) >> 0x1f)) ||\n     (flag2 = input2 & 0x7fffffff, 0x7ff00000 < (flag2 | (-input1 | input1) >> 0x1f))) {\n    output1 = __aeabi_dadd(input1,input2);\n    return output1;\n  }\n  if ((input4 + 0xc0100000 | input3) == 0) {\n    atan(input5);\n    return CONCAT44(result2,input1);\n  }\n  flag1 = (int)input4 >> 0x1e & 2U | input2 >> 0x1f;\n  if ((input1 | flag2) == 0) {\n    if (flag1 == 2) {\n      return 0x400921fb54442d18;\n    }\n    if (flag1 != 3) {\n      return CONCAT44(input2,input1);\n    }\nLAB_0800613e:\n    output1 = 0xc00921fb54442d18;\n  }\n  else {\n    if ((input3 | masked_input4) != 0) {\n      if (masked_input4 == 0x7ff00000) {\n        if (flag2 == 0x7ff00000) {\n          if (flag1 == 2) {\n            return 0x4002d97c7f3321d2;\n          }\n          if (flag1 == 3) {\n            return 0xc002d97c7f3321d2;\n          }\n          if (flag1 != 1) {\n            return 0x3fe921fb54442d18;\n          }\n          return 0xbfe921fb54442d18;\n        }\n        if (flag1 == 2) {\n          return 0x400921fb54442d18;\n        }\n        if (flag1 != 3) {\n          if (flag1 != 1) {\n            return 0;\n          }\n          return 0x8000000000000000;\n        }\n        goto LAB_0800613e;\n      }\n      if (flag2 != 0x7ff00000) {\n        flag3 = (int)(flag2 - masked_input4) >> 0x14;\n        if (flag3 < 0x3d) {\n          if (((int)input4 < 0) && (flag3 + 0x3c < 0 != SCARRY4(flag3,0x3c))) {\n            result1 = 0;\n            flag3 = 0;\n          }\n          else {\n            result1 = __divdf3(input1,input2);\n            fabs((double)CONCAT44(result4,input4));\n            atan((double)CONCAT44(result4,input4));\n            flag3 = result3;\n          }\n        }\n        else {\n          result1 = 0x54442d18;\n          flag3 = 0x3ff921fb;\n        }\n        if (flag1 == 1) {\n          return CONCAT44(flag3 + -0x80000000,result1);\n        }\n        if (flag1 == 2) {\n          output2 = __subdf3(result1,flag3,0x33145c07,0x3ca1a626);\n          output1 = 0x400921fb54442d18;\n        }\n        else {\n          if (flag1 == 0) {\n            return CONCAT44(flag3,result1);\n          }\n          output1 = __subdf3(result1,flag3,0x33145c07,0x3ca1a626);\n          output2 = 0x400921fb54442d18;\n        }\n        output1 = __subdf3((int)output1,(int)((ulonglong)output1 >> 0x20),(int)output2,\n                         (int)((ulonglong)output2 >> 0x20));\n        return output1;\n      }\n    }\n    if ((int)input2 < 0) {\n      output1 = 0xbff921fb54442d18;\n    }\n    else {\n      output1 = 0x3ff921fb54442d18;\n    }\n  }\n  return output1;\n}\n\n",
            "renaming": {
                "FUN_08006070": "calculate_result_08006070",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "param_5": "input5",
                "uVar1": "result1",
                "extraout_r1": "result2",
                "extraout_r1_00": "result3",
                "unaff_r4": "result4",
                "uVar2": "flag1",
                "uVar3": "flag2",
                "iVar4": "flag3",
                "uVar5": "masked_input4",
                "uVar6": "output1",
                "uVar7": "output2"
            },
            "calling": [
                "atan2"
            ],
            "called": [
                "fabs",
                "atan",
                "__aeabi_dadd",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006228": {
            "entrypoint": "0x08006228",
            "current_name": "calculate_square_root_08006228",
            "code": "\nvoid calculateSquareRoot_08006228(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint temp1;\n  undefined4 temp2;\n  uint temp3;\n  undefined4 temp4;\n  undefined4 temp5;\n  undefined4 temp6;\n  uint temp7;\n  undefined4 temp8;\n  undefined4 temp9;\n  int temp10;\n  uint temp11;\n  int temp12;\n  undefined4 temp13;\n  uint temp14;\n  undefined4 temp15;\n  uint temp16;\n  undefined4 temp17;\n  undefined4 temp18;\n  undefined8 temp19;\n  undefined8 temp20;\n  undefined8 temp21;\n  undefined8 temp22;\n  longlong lVar17;\n  ulonglong temp23;\n  undefined8 temp24;\n  undefined4 temp25;\n  undefined4 temp26;\n  undefined4 localVar1;\n  undefined4 localVar2;\n  int localVar3;\n  \n  temp16 = input4 & 0x7fffffff;\n  if ((temp16 | input3) == 0) {\n    return;\n  }\n  temp14 = input2 & 0x7fffffff;\n  if (temp14 < 0x7ff00001) {\n    if (temp14 == 0x7ff00000) {\n      if (input1 == 0) {\n        if (0x7ff00000 < temp16) goto LAB_08006278;\nLAB_08006262:\n        if ((temp16 != 0x7ff00000) || (input3 == 0)) {\n          if (-1 < (int)input2) goto LAB_0800632a;\n          if (temp16 < 0x43400000) {\n            if (temp16 < 0x3ff00000) {\nLAB_0800632a:\n              temp1 = 0;\n              goto LAB_080062ba;\n            }\n            temp10 = ((int)temp16 >> 0x14) + -0x3ff;\n            if (0x14 < temp10) {\n              temp1 = input3 >> (0x34U - temp10 & 0xff);\n              if (input3 == temp1 << (0x34U - temp10 & 0xff)) {\n                temp1 = 2 - (temp1 & 1);\n                goto LAB_080062ba;\n              }\n              goto LAB_0800632a;\n            }\n            if (input3 == 0) {\n              temp1 = (int)temp16 >> (0x14U - temp10 & 0xff);\n              if (temp16 == temp1 << (0x14U - temp10 & 0xff)) {\n                temp1 = 2 - (temp1 & 1);\n              }\n              else {\n                temp1 = 0;\n              }\n              goto LAB_0800630c;\n            }\n            temp1 = 0;\n          }\n          else {\n            temp1 = 2;\nLAB_080062ba:\n            if (input3 == 0) {\n              if (temp16 == 0x7ff00000) {\n                return;\n              }\nLAB_0800630c:\n              if (temp16 == 0x3ff00000) {\n                if (-1 < (int)input4) {\n                  return;\n                }\n                temp19 = 0x3ff0000000000000;\n                temp20 = CONCAT44(input2,input1);\n                goto LAB_08006320;\n              }\n              if (input4 == 0x40000000) goto LAB_0800634a;\n              if ((input4 == 0x3fe00000) && (-1 < (int)input2)) {\n                __ieee754_sqrt(input1,input2);\n                return;\n              }\n            }\n          }\n          temp11 = input1;\n          fabs((double)CONCAT44(temp26,temp1));\n          temp23 = CONCAT44(input2,temp11) & 0x7fffffffffffffff;\n          if ((input1 == 0) && ((temp14 == 0 || ((input2 & 0x3fffffff) == 0x3ff00000)))) {\n            if ((int)input4 < 0) {\n              __divdf3(0,0x3ff00000,temp11,temp2);\n            }\n            if (-1 < (int)input2) {\n              return;\n            }\n            if ((temp1 | temp14 + 0xc0100000) != 0) {\n              return;\n            }\n          }\n          else {\n            temp11 = 0xffffffff - ((int)input2 >> 0x1f);\n            if ((temp1 | temp11) != 0) {\n              if (temp16 < 0x41e00001) {\n                localVar3 = 0;\n                if (temp14 < 0x100000) {\n                  temp23 = __muldf3();\n                  localVar3 = -0x35;\n                }\n                temp16 = (uint)(temp23 >> 0x20);\n                localVar3 = ((int)temp16 >> 0x14) + -0x3ff + localVar3;\n                temp16 = temp16 & 0xfffff;\n                temp14 = temp16 | 0x3ff00000;\n                if (temp16 < 0x3988f) {\nLAB_08006628:\n                  temp10 = 0;\n                }\n                else {\n                  if (0xbb679 < temp16) {\n                    temp14 = temp14 - 0x100000;\n                    localVar3 = localVar3 + 1;\n                    goto LAB_08006628;\n                  }\n                  temp10 = 1;\n                }\n                temp12 = temp10 * 8;\n                temp13 = (&bp)[temp10 * 2];\n                temp25 = (&DAT_080073c4)[temp10 * 2];\n                temp19 = __subdf3();\n                temp17 = (undefined4)((ulonglong)temp19 >> 0x20);\n                temp20 = __aeabi_dadd((int)temp23,temp14,temp13,temp25);\n                temp20 = __divdf3(0,0x3ff00000,(int)temp20,(int)((ulonglong)temp20 >> 0x20));\n                temp18 = (undefined4)((ulonglong)temp20 >> 0x20);\n                temp21 = __muldf3((int)temp19,temp17,(int)temp20,temp18);\n                temp4 = (undefined4)((ulonglong)temp21 >> 0x20);\n                temp15 = (undefined4)temp21;\n                temp21 = __muldf3(0,temp4);\n                temp19 = __subdf3((int)temp19,temp17,(int)temp21,(int)((ulonglong)temp21 >> 0x20));\n                temp21 = __subdf3(0,((int)temp14 >> 1 | 0x20000000U) + 0x80000 + temp10 * 0x40000,\n                                  temp13,temp25);\n                temp21 = __subdf3((int)temp23,temp14,(int)temp21,(int)((ulonglong)temp21 >> 0x20));\n                temp21 = __muldf3((int)temp21,(int)((ulonglong)temp21 >> 0x20),0,temp4);\n                temp19 = __subdf3((int)temp19,(int)((ulonglong)temp19 >> 0x20),(int)temp21,\n                                  (int)((ulonglong)temp21 >> 0x20));\n                temp19 = __muldf3((int)temp19,(int)((ulonglong)temp19 >> 0x20),(int)temp20,temp18);\n                temp18 = (undefined4)((ulonglong)temp19 >> 0x20);\n                temp20 = __muldf3(temp15,temp4);\n                temp13 = (undefined4)((ulonglong)temp20 >> 0x20);\n                temp17 = (undefined4)temp20;\n                temp20 = __muldf3(temp17,temp13,0x4a454eef,0x3fca7e28);\n                temp20 = __aeabi_dadd((int)temp20,(int)((ulonglong)temp20 >> 0x20),0x93c9db65,\n                                      0x3fcd864a);\n                temp20 = __muldf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),temp17,temp13);\n                temp20 = __aeabi_dadd((int)temp20,(int)((ulonglong)temp20 >> 0x20),0xa91d4101,\n                                      0x3fd17460);\n                temp20 = __muldf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),temp17,temp13);\n                temp20 = __aeabi_dadd((int)temp20,(int)((ulonglong)temp20 >> 0x20),0x518f264d,\n                                      0x3fd55555);\n                temp20 = __muldf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),temp17,temp13);\n                temp20 = __aeabi_dadd((int)temp20,(int)((ulonglong)temp20 >> 0x20),0xdb6fabff,\n                                      0x3fdb6db6);\n                temp20 = __muldf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),temp17,temp13);\n                temp20 = __aeabi_dadd((int)temp20,(int)((ulonglong)temp20 >> 0x20),0x33333303,\n                                      0x3fe33333);\n                temp21 = __muldf3(temp17,temp13,temp17,temp13);\n                temp20 = __muldf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),(int)temp21,\n                                  (int)((ulonglong)temp21 >> 0x20));\n                temp21 = __aeabi_dadd(temp15,temp4,0,temp4);\n                temp21 = __muldf3((int)temp21,(int)((ulonglong)temp21 >> 0x20),(int)temp19,temp18);\n                temp20 = __aeabi_dadd((int)temp21,(int)((ulonglong)temp21 >> 0x20),(int)temp20,\n                                      (int)((ulonglong)temp20 >> 0x20));\n                temp17 = (undefined4)((ulonglong)temp20 >> 0x20);\n                temp21 = __muldf3(0,temp4,0,temp4);\n                temp13 = (undefined4)((ulonglong)temp21 >> 0x20);\n                temp22 = __aeabi_dadd((int)temp21,temp13,0,0x40080000);\n                __aeabi_dadd((int)temp22,(int)((ulonglong)temp22 >> 0x20),(int)temp20,temp17);\n                temp22 = __muldf3(0,temp4,0,temp5);\n                temp25 = (undefined4)((ulonglong)temp22 >> 0x20);\n                temp24 = __subdf3(0,temp5,0,0x40080000);\n                temp21 = __subdf3((int)temp24,(int)((ulonglong)temp24 >> 0x20),(int)temp21,temp13);\n                temp20 = __subdf3((int)temp20,temp17,(int)temp21,(int)((ulonglong)temp21 >> 0x20));\n                temp20 = __muldf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),temp15,temp4);\n                temp19 = __muldf3((int)temp19,temp18,0,temp5);\n                temp20 = __aeabi_dadd((int)temp20,(int)((ulonglong)temp20 >> 0x20),(int)temp19,\n                                      (int)((ulonglong)temp19 >> 0x20));\n                temp15 = (undefined4)((ulonglong)temp20 >> 0x20);\n                __aeabi_dadd((int)temp22,temp25,(int)temp20,temp15);\n                temp19 = __muldf3(0,temp6,0xe0000000,0x3feec709);\n                temp21 = __subdf3(0,temp6,(int)temp22,temp25);\n                temp20 = __subdf3((int)temp20,temp15,(int)temp21,(int)((ulonglong)temp21 >> 0x20));\n                temp20 = __muldf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),0xdc3a03fd,0x3feec709\n                                 );\n                temp21 = __muldf3(0,temp6,0x145b01f5,0xbe3e2fe0);\n                temp20 = __aeabi_dadd((int)temp20,(int)((ulonglong)temp20 >> 0x20),(int)temp21,\n                                      (int)((ulonglong)temp21 >> 0x20));\n                temp20 = __aeabi_dadd((int)temp20,(int)((ulonglong)temp20 >> 0x20),\n                                      *(undefined4 *)(&dp_l + temp12),\n                                      *(undefined4 *)(&DAT_080073e4 + temp12));\n                temp21 = __aeabi_i2d(localVar3);\n                temp15 = (undefined4)((ulonglong)temp21 >> 0x20);\n                temp17 = *(undefined4 *)(&dp_h + temp12);\n                temp18 = *(undefined4 *)(&DAT_080073d4 + temp12);\n                temp22 = __aeabi_dadd((int)temp19,(int)((ulonglong)temp19 >> 0x20),(int)temp20,\n                                      (int)((ulonglong)temp20 >> 0x20));\n                temp22 = __aeabi_dadd((int)temp22,(int)((ulonglong)temp22 >> 0x20),temp17,temp18);\n                __aeabi_dadd((int)temp22,(int)((ulonglong)temp22 >> 0x20),(int)temp21,temp15);\n                temp21 = __subdf3(0,temp7,(int)temp21,temp15);\n                lVar17 = __subdf3((int)temp21,(int)((ulonglong)temp21 >> 0x20),temp17,temp18);\n                temp16 = temp7;\n              }\n              else {\n                if (0x43f00000 < temp16) {\n                  if (0x3fefffff < temp14) {\nLAB_08006418:\n                    if ((int)input4 < 1) {\n                      return;\n                    }\n                    goto LAB_0800634a;\n                  }\nLAB_080063fa:\n                  if (-1 < (int)input4) {\n                    return;\n                  }\n                  goto LAB_0800634a;\n                }\n                if (temp14 < 0x3fefffff) goto LAB_080063fa;\n                if (0x3ff00000 < temp14) goto LAB_08006418;\n                temp19 = __subdf3();\n                temp17 = (undefined4)((ulonglong)temp19 >> 0x20);\n                temp15 = (undefined4)temp19;\n                temp19 = __muldf3(temp15,temp17,0x60000000,0x3ff71547);\n                temp20 = __muldf3(temp15,temp17,0xf85ddf44,0x3e54ae0b);\n                temp21 = __muldf3(temp15,temp17,0,0x3fd00000);\n                temp21 = __subdf3(0x55555555,0x3fd55555,(int)temp21,(int)((ulonglong)temp21 >> 0x20)\n                                 );\n                temp21 = __muldf3((int)temp21,(int)((ulonglong)temp21 >> 0x20),temp15,temp17);\n                temp21 = __subdf3(0,0x3fe00000,(int)temp21,(int)((ulonglong)temp21 >> 0x20));\n                temp22 = __muldf3(temp15,temp17,temp15,temp17);\n                temp21 = __muldf3((int)temp21,(int)((ulonglong)temp21 >> 0x20),(int)temp22,\n                                  (int)((ulonglong)temp22 >> 0x20));\n                temp21 = __muldf3((int)temp21,(int)((ulonglong)temp21 >> 0x20),0x652b82fe,0x3ff71547\n                                 );\n                temp20 = __subdf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),(int)temp21,\n                                  (int)((ulonglong)temp21 >> 0x20));\n                __aeabi_dadd((int)temp19,(int)((ulonglong)temp19 >> 0x20),(int)temp20,\n                             (int)((ulonglong)temp20 >> 0x20));\n                lVar17 = (ulonglong)temp3 << 0x20;\n                temp16 = temp3;\n              }\n              temp19 = __subdf3((int)lVar17,(int)((ulonglong)lVar17 >> 0x20),(int)temp19,\n                                (int)((ulonglong)temp19 >> 0x20));\n              temp19 = __subdf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),(int)temp19,\n                                (int)((ulonglong)temp19 >> 0x20));\n              if ((temp1 - 1 | temp11) == 0) {\n                temp15 = 0xbff00000;\n              }\n              else {\n                temp15 = 0x3ff00000;\n              }\n              temp25 = 0;\n              temp20 = __subdf3(input3,input4,0,input4);\n              temp20 = __muldf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),0,temp16);\n              temp19 = __muldf3((int)temp19,(int)((ulonglong)temp19 >> 0x20),input3,input4);\n              temp19 = __aeabi_dadd((int)temp20,(int)((ulonglong)temp20 >> 0x20),(int)temp19,\n                                    (int)((ulonglong)temp19 >> 0x20));\n              temp4 = (undefined4)((ulonglong)temp19 >> 0x20);\n              temp17 = (undefined4)temp19;\n              temp19 = __muldf3(0,temp16,0,input4);\n              temp13 = (undefined4)((ulonglong)temp19 >> 0x20);\n              temp18 = (undefined4)temp19;\n              lVar17 = __aeabi_dadd(temp17,temp4,temp18,temp13);\n              temp14 = (uint)((ulonglong)lVar17 >> 0x20);\n              temp16 = (uint)lVar17;\n              if (0x408fffffffffffff < lVar17) {\n                if ((temp14 + 0xbf700000 | temp16) == 0) {\n                  temp20 = __aeabi_dadd(temp17,temp4,0x652b82fe,0x3c971547);\n                  temp21 = __subdf3(temp16,temp14,temp18,temp13);\n                  temp10 = __aeabi_dcmpgt((int)temp20,(int)((ulonglong)temp20 >> 0x20),(int)temp21,\n                                         (int)((ulonglong)temp21 >> 0x20));\n                  if (temp10 == 0) goto LAB_08006968;\n                }\n                __muldf3(temp25,temp15,0x8800759c,0x7e37e43c);\n                goto LAB_0800634a;\n              }\n              if ((temp14 & 0x7fffffff) < 0x4090cc00) {\nLAB_08006968:\n                if ((temp14 & 0x7fffffff) < 0x3fe00001) {\n                  temp10 = 0;\n                }\n                else {\n                  temp14 = (0x100000 >> (((int)(temp14 & 0x7fffffff) >> 0x14) - 0x3feU & 0xff)) +\n                          temp14;\n                  temp16 = (temp14 * 2 >> 0x15) - 0x3ff;\n                  temp10 = (int)(temp14 & 0xfffff | 0x100000) >> (0x14 - temp16 & 0xff);\n                  if (lVar17 < 0) {\n                    temp10 = -temp10;\n                  }\n                  temp19 = __subdf3(temp18,temp13,0,temp14 & ~(0xfffff >> (temp16 & 0xff)));\n                }\n                localVar2 = (undefined4)((ulonglong)temp19 >> 0x20);\n                localVar1 = (undefined4)temp19;\n                __aeabi_dadd(localVar1,localVar2,temp17,temp4);\n                temp19 = __muldf3(0,temp8,0,0x3fe62e43);\n                temp18 = (undefined4)((ulonglong)temp19 >> 0x20);\n                temp20 = __subdf3(0,temp8,localVar1,localVar2);\n                temp20 = __subdf3(temp17,temp4,(int)temp20,(int)((ulonglong)temp20 >> 0x20));\n                temp20 = __muldf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),0xfefa39ef,0x3fe62e42\n                                 );\n                temp21 = __muldf3(0,temp8,0xca86c39,0xbe205c61);\n                temp20 = __aeabi_dadd((int)temp20,(int)((ulonglong)temp20 >> 0x20),(int)temp21,\n                                      (int)((ulonglong)temp21 >> 0x20));\n                temp4 = (undefined4)((ulonglong)temp20 >> 0x20);\n                temp21 = __aeabi_dadd((int)temp19,temp18,(int)temp20,temp4);\n                temp13 = (undefined4)((ulonglong)temp21 >> 0x20);\n                temp17 = (undefined4)temp21;\n                temp19 = __subdf3(temp17,temp13,(int)temp19,temp18);\n                temp19 = __subdf3((int)temp20,temp4,(int)temp19,(int)((ulonglong)temp19 >> 0x20));\n                temp4 = (undefined4)((ulonglong)temp19 >> 0x20);\n                temp20 = __muldf3(temp17,temp13,temp17,temp13);\n                temp9 = (undefined4)((ulonglong)temp20 >> 0x20);\n                temp18 = (undefined4)temp20;\n                temp20 = __muldf3(temp18,temp9,0x72bea4d0,0x3e663769);\n                temp20 = __subdf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),0xc5d26bf1,0x3ebbbd41\n                                 );\n                temp20 = __muldf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),temp18,temp9);\n                temp20 = __aeabi_dadd((int)temp20,(int)((ulonglong)temp20 >> 0x20),0xaf25de2c,\n                                      0x3f11566a);\n                temp20 = __muldf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),temp18,temp9);\n                temp20 = __subdf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),0x16bebd93,0x3f66c16c\n                                 );\n                temp20 = __muldf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),temp18,temp9);\n                temp20 = __aeabi_dadd((int)temp20,(int)((ulonglong)temp20 >> 0x20),0x5555553e,\n                                      0x3fc55555);\n                temp20 = __muldf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),temp18,temp9);\n                temp20 = __subdf3(temp17,temp13,(int)temp20,(int)((ulonglong)temp20 >> 0x20));\n                temp18 = (undefined4)((ulonglong)temp20 >> 0x20);\n                temp21 = __muldf3(temp17,temp13,(int)temp20,temp18);\n                temp20 = __subdf3((int)temp20,temp18,0,0x40000000);\n                temp20 = __divdf3((int)temp21,(int)((ulonglong)temp21 >> 0x20),(int)temp20,\n                                  (int)((ulonglong)temp20 >> 0x20));\n                temp21 = __muldf3(temp17,temp13,(int)temp19,temp4);\n                temp19 = __aeabi_dadd((int)temp21,(int)((ulonglong)temp21 >> 0x20),(int)temp19,temp4\n                                     );\n                temp19 = __subdf3((int)temp20,(int)((ulonglong)temp20 >> 0x20),(int)temp19,\n                                  (int)((ulonglong)temp19 >> 0x20));\n                temp19 = __subdf3((int)temp19,(int)((ulonglong)temp19 >> 0x20),temp17,temp13);\n                temp19 = __subdf3(0,0x3ff00000,(int)temp19,(int)((ulonglong)temp19 >> 0x20));\n                if ((int)((ulonglong)temp19 >> 0x20) + temp10 * 0x100000 < 0x100000) {\n                  scalbn((double)CONCAT44(temp15,temp25),(int)temp19);\n                }\n              }\n              else {\n                if ((temp14 + 0x3f6f3400 | temp16) == 0) {\n                  temp20 = __subdf3(temp16,temp14,temp18,temp13);\n                  temp10 = __aeabi_dcmple(temp17,temp4,(int)temp20,(int)((ulonglong)temp20 >> 0x20));\n                  if (temp10 == 0) goto LAB_08006968;\n                }\n                __muldf3(temp25,temp15,0xc2f8f359,0x1a56e1f);\n              }\nLAB_0800634a:\n              __muldf3();\n              return;\n            }\n          }\n          temp19 = __subdf3();\n          temp20 = temp19;\nLAB_08006320:\n          __divdf3((int)temp19,(int)((ulonglong)temp19 >> 0x20),(int)temp20,\n                   (int)((ulonglong)temp20 >> 0x20));\n          return;\n        }\n      }\n    }\n    else if (temp16 < 0x7ff00001) goto LAB_08006262;\n  }\n  if ((temp14 + 0xc0100000 | input1) == 0) {\n    return;\n  }\nLAB_08006278:\n  nan(\"\");\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006228": "calculate_square_root_08006228",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "temp1",
                "extraout_r1": "temp2",
                "extraout_r1_00": "temp3",
                "uVar2": "temp4",
                "extraout_r1_01": "temp5",
                "extraout_r1_02": "temp6",
                "extraout_r1_03": "temp7",
                "extraout_r1_04": "temp8",
                "uVar3": "temp9",
                "iVar4": "temp10",
                "uVar5": "temp11",
                "iVar6": "temp12",
                "uVar7": "temp13",
                "uVar8": "temp14",
                "uVar9": "temp15",
                "uVar10": "temp16",
                "uVar11": "temp17",
                "uVar12": "temp18",
                "uVar13": "temp19",
                "uVar14": "temp20",
                "uVar15": "temp21",
                "uVar16": "temp22",
                "uVar18": "temp23",
                "uVar19": "temp24",
                "uVar20": "temp25",
                "in_stack_ffffff94": "temp26",
                "local_68": "localVar1",
                "local_64": "localVar2",
                "local_54": "localVar3"
            },
            "calling": [
                "pow"
            ],
            "called": [
                "__aeabi_i2d",
                "scalbn",
                "fabs",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__ieee754_sqrt",
                "__muldf3",
                "__aeabi_dcmple",
                "nan",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c0c": {
            "entrypoint": "0x08006c0c",
            "current_name": "calculate_decimal_product_08006c0c",
            "code": "\nundefined8 calculate_decimal_product_08006c0c(uint decimal1,uint decimal2)\n\n{\n  undefined4 temp1;\n  uint temp2;\n  int shift1;\n  int shift2;\n  uint remainder1;\n  uint remainder2;\n  int sum;\n  uint result;\n  uint mask;\n  int count1;\n  uint count2;\n  undefined8 final_result;\n  \n  if ((~decimal2 & 0x7ff00000) == 0) {\n    final_result = __muldf3(decimal1,decimal2,decimal1,decimal2);\n    final_result = __aeabi_dadd(decimal1,decimal2,(int)final_result,(int)((ulonglong)final_result >> 0x20));\n    return final_result;\n  }\n  if ((int)decimal2 < 1) {\n    if ((decimal2 & 0x7fffffff | decimal1) == 0) {\n      return CONCAT44(decimal2,decimal1);\n    }\n    if (decimal2 != 0) {\n      final_result = __subdf3(decimal1,decimal2,decimal1,decimal2);\n      temp1 = (undefined4)((ulonglong)final_result >> 0x20);\n      final_result = __divdf3((int)final_result,temp1,(int)final_result,temp1);\n      return final_result;\n    }\n  }\n  shift1 = (int)decimal2 >> 0x14;\n  if (shift1 == 0) {\n    while (decimal2 == 0) {\n      shift1 = shift1 + -0x15;\n      decimal2 = decimal1 >> 0xb;\n      decimal1 = decimal1 << 0x15;\n    }\n    temp2 = 0;\n    for (; -1 < (int)(decimal2 << 0xb); decimal2 = decimal2 << 1) {\n      temp2 = temp2 + 1;\n    }\n    shift1 = shift1 - (temp2 - 1);\n    decimal2 = decimal2 | decimal1 >> (0x20 - temp2 & 0xff);\n    decimal1 = decimal1 << (temp2 & 0xff);\n  }\n  sum = 0;\n  temp2 = decimal2 & 0xfffff | 0x100000;\n  if ((shift1 + -0x3ff) * -0x80000000 < 0) {\n    temp2 = temp2 * 2 - ((int)decimal1 >> 0x1f);\n    decimal1 = decimal1 << 1;\n  }\n  temp2 = temp2 * 2 - ((int)decimal1 >> 0x1f);\n  shift2 = 0x16;\n  remainder1 = 0;\n  result = 0x200000;\n  decimal1 = decimal1 << 1;\n  do {\n    count1 = remainder1 + result;\n    if (count1 <= (int)temp2) {\n      temp2 = temp2 - count1;\n      remainder1 = count1 + result;\n      sum = sum + result;\n    }\n    shift2 = shift2 + -1;\n    temp2 = temp2 * 2 - ((int)decimal1 >> 0x1f);\n    result = result >> 1;\n    decimal1 = decimal1 << 1;\n  } while (shift2 != 0);\n  count1 = 0x20;\n  mask = 0x80000000;\n  result = 0;\n  shift2 = 0;\n  do {\n    count2 = mask + shift2;\n    remainder2 = remainder1;\n    if (((int)remainder1 < (int)temp2) || ((temp2 == remainder1 && (count2 <= decimal1)))) {\n      shift2 = count2 + mask;\n      if (((int)count2 < 0) && (-1 < shift2)) {\n        remainder2 = remainder1 + 1;\n      }\n      temp2 = temp2 - remainder1;\n      if (decimal1 < count2) {\n        temp2 = temp2 - 1;\n      }\n      decimal1 = decimal1 - count2;\n      result = result + mask;\n    }\n    temp2 = temp2 * 2 - ((int)decimal1 >> 0x1f);\n    count1 = count1 + -1;\n    decimal1 = decimal1 << 1;\n    mask = mask >> 1;\n    remainder1 = remainder2;\n  } while (count1 != 0);\n  if ((decimal1 | temp2) != 0) {\n    if (result == 0xffffffff) {\n      sum = sum + 1;\n      result = 0;\n    }\n    else {\n      result = result + 1 & 0xfffffffe;\n    }\n  }\n  result = result >> 1;\n  if (sum << 0x1f < 0) {\n    result = result | 0x80000000;\n  }\n  return CONCAT44((sum >> 1) + 0x3fe00000 + (shift1 + -0x3ff >> 1) * 0x100000,result);\n}\n\n",
            "renaming": {
                "FUN_08006c0c": "calculate_decimal_product_08006c0c",
                "param_1": "decimal1",
                "param_2": "decimal2",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "iVar3": "shift1",
                "iVar4": "shift2",
                "uVar5": "remainder1",
                "uVar6": "remainder2",
                "iVar7": "sum",
                "uVar8": "result",
                "uVar9": "mask",
                "iVar10": "count1",
                "uVar11": "count2",
                "uVar12": "final_result"
            },
            "calling": [
                "__ieee754_asin",
                "sqrt",
                "__ieee754_pow"
            ],
            "called": [
                "__aeabi_dadd",
                "__muldf3",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d68": {
            "entrypoint": "0x08006d68",
            "current_name": "calculate_polynomial_08006d68",
            "code": "\ndouble calculatePolynomial_08006d68(double inputValue)\n\n{\n  int integerPart;\n  int caseValue;\n  undefined4 multiplier1;\n  undefined4 multiplier2;\n  uint fractionalPart;\n  undefined4 temp2;\n  undefined4 multiplier3;\n  undefined4 multiplier4;\n  undefined4 temp1;\n  undefined4 temp3;\n  undefined4 multiplier5;\n  undefined4 multiplier6;\n  uint absFractionalPart;\n  double result;\n  double tempResult;\n  undefined8 temp4;\n  undefined8 temp5;\n  \n  temp5 = CONCAT44(fractionalPart,integerPart);\n  absFractionalPart = fractionalPart & 0x7fffffff;\n  if (absFractionalPart < 0x44100000) {\n    if (absFractionalPart < 0x3fdc0000) {\n      if (absFractionalPart < 0x3e200000) {\n        temp4 = __aeabi_dadd(integerPart,fractionalPart,0x8800759c,0x7e37e43c);\n        caseValue = __aeabi_dcmpgt((int)temp4,(int)((ulonglong)temp4 >> 0x20),0,0x3ff00000);\n        if (caseValue != 0) {\n          return tempResult;\n        }\n      }\n      caseValue = -1;\n    }\n    else {\n      fabs((double)CONCAT44(temp3,temp1));\n      if (absFractionalPart < 0x3ff30000) {\n        if (absFractionalPart < 0x3fe60000) {\n          temp5 = __aeabi_dadd();\n          temp5 = __subdf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),0,0x3ff00000);\n          temp4 = __aeabi_dadd(integerPart,temp2,0,0x40000000);\n          temp5 = __divdf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),(int)temp4,\n                            (int)((ulonglong)temp4 >> 0x20));\n          caseValue = 0;\n        }\n        else {\n          temp5 = __subdf3();\n          temp4 = __aeabi_dadd(integerPart,temp2,0,0x3ff00000);\n          temp5 = __divdf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),(int)temp4,\n                            (int)((ulonglong)temp4 >> 0x20));\n          caseValue = 1;\n        }\n      }\n      else if (absFractionalPart < 0x40038000) {\n        temp5 = __subdf3();\n        temp4 = __muldf3(integerPart,temp2,0,0x3ff80000);\n        temp4 = __aeabi_dadd((int)temp4,(int)((ulonglong)temp4 >> 0x20),0,0x3ff00000);\n        temp5 = __divdf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),(int)temp4,\n                          (int)((ulonglong)temp4 >> 0x20));\n        caseValue = 2;\n      }\n      else {\n        temp5 = __divdf3(0,0xbff00000,integerPart,temp2);\n        caseValue = 3;\n      }\n    }\n    multiplier6 = (undefined4)((ulonglong)temp5 >> 0x20);\n    multiplier5 = (undefined4)temp5;\n    temp5 = __muldf3(multiplier5,multiplier6,multiplier5,multiplier6);\n    multiplier3 = (undefined4)((ulonglong)temp5 >> 0x20);\n    multiplier1 = (undefined4)temp5;\n    temp5 = __muldf3(multiplier1,multiplier3,multiplier1,multiplier3);\n    multiplier4 = (undefined4)((ulonglong)temp5 >> 0x20);\n    multiplier2 = (undefined4)temp5;\n    temp5 = __muldf3(multiplier2,multiplier4,0xe322da11,0x3f90ad3a);\n    temp5 = __aeabi_dadd((int)temp5,(int)((ulonglong)temp5 >> 0x20),0x24760deb,0x3fa97b4b);\n    temp5 = __muldf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),multiplier2,multiplier4);\n    temp5 = __aeabi_dadd((int)temp5,(int)((ulonglong)temp5 >> 0x20),0xa0d03d51,0x3fb10d66);\n    temp5 = __muldf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),multiplier2,multiplier4);\n    temp5 = __aeabi_dadd((int)temp5,(int)((ulonglong)temp5 >> 0x20),0xc54c206e,0x3fb745cd);\n    temp5 = __muldf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),multiplier2,multiplier4);\n    temp5 = __aeabi_dadd((int)temp5,(int)((ulonglong)temp5 >> 0x20),0x920083ff,0x3fc24924);\n    temp5 = __muldf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),multiplier2,multiplier4);\n    temp5 = __aeabi_dadd((int)temp5,(int)((ulonglong)temp5 >> 0x20),0x5555550d,0x3fd55555);\n    temp5 = __muldf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),multiplier1,multiplier3);\n    multiplier1 = (undefined4)((ulonglong)temp5 >> 0x20);\n    temp4 = __muldf3(multiplier2,multiplier4,0x2c6a6c2f,0xbfa2b444);\n    temp4 = __subdf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),0x52defd9a,0x3fadde2d);\n    temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),multiplier2,multiplier4);\n    temp4 = __subdf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),multiplier2,multiplier4);\n    temp4 = __subdf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),0xfe231671,0x3fbc71c6);\n    temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),multiplier2,multiplier4);\n    temp4 = __subdf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),0x9998ebc4,0x3fc99999);\n    temp4 = __muldf3((int)temp4,(int)((ulonglong)temp4 >> 0x20),multiplier2,multiplier4);\n    multiplier2 = (undefined4)((ulonglong)temp4 >> 0x20);\n    if (caseValue == -1) {\n      temp5 = __aeabi_dadd((int)temp5,multiplier1,(int)temp4,multiplier2);\n      temp5 = __muldf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),multiplier5,multiplier6);\n      result = (double)__subdf3(multiplier5,multiplier6,(int)temp5,(int)((ulonglong)temp5 >> 0x20));\n    }\n    else {\n      temp5 = __aeabi_dadd((int)temp5,multiplier1,(int)temp4,multiplier2);\n      temp5 = __muldf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),multiplier5,multiplier6);\n      caseValue = caseValue * 8;\n      temp5 = __subdf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),\n                        *(undefined4 *)(&atanlo + caseValue),*(undefined4 *)(&UNK_08007414 + caseValue));\n      temp5 = __subdf3((int)temp5,(int)((ulonglong)temp5 >> 0x20),multiplier5,multiplier6);\n      result = (double)__subdf3(*(undefined4 *)(&atanhi + caseValue),\n                               *(undefined4 *)(&UNK_080073f4 + caseValue),(int)temp5,\n                               (int)((ulonglong)temp5 >> 0x20));\n    }\n  }\n  else if ((0x7ff00000 < absFractionalPart) || ((absFractionalPart == 0x7ff00000 && (integerPart != 0)))) {\n    result = (double)__aeabi_dadd();\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006d68": "calculate_polynomial_08006d68",
                "__x": "inputValue",
                "in_r0": "integerPart",
                "in_r1": "fractionalPart",
                "in_r3": "temp1",
                "extraout_r1": "temp2",
                "unaff_r4": "temp3",
                "uVar2": "multiplier1",
                "uVar3": "multiplier2",
                "uVar4": "multiplier3",
                "uVar5": "multiplier4",
                "uVar6": "multiplier5",
                "uVar7": "multiplier6",
                "uVar8": "absFractionalPart",
                "in_d0": "result",
                "extraout_d0": "tempResult",
                "uVar9": "temp4",
                "uVar10": "temp5",
                "iVar1": "caseValue"
            },
            "calling": [
                "__ieee754_atan2"
            ],
            "called": [
                "fabs",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__muldf3",
                "__divdf3",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800708c": {
            "entrypoint": "0x0800708c",
            "current_name": "calculate_0800708c",
            "code": "\ndouble calculate_0800708c(double input_value)\n\n{\n  double result;\n  \n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800708c": "calculate_0800708c",
                "__x": "input_value",
                "in_d0": "result"
            },
            "calling": [
                "__ieee754_atan2",
                "atan",
                "__ieee754_asin",
                "__ieee754_pow",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007092": {
            "entrypoint": "0x08007092",
            "current_name": "calculate_offset_08007092",
            "code": "\nint calculateOffset_08007092(double inputValue)\n\n{\n  uint result;\n  \n  return (result | 0x80000000) + 0x100000 >> 0x1f;\n}\n\n",
            "renaming": {
                "FUN_08007092": "calculate_offset_08007092",
                "__value": "inputValue",
                "in_r1": "result"
            },
            "calling": [
                "pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800709e": {
            "entrypoint": "0x0800709e",
            "current_name": "handle_exception_0800709e",
            "code": "\nint handle_exception_0800709e(exception *exception_object)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800709e": "handle_exception_0800709e",
                "__exc": "exception_object"
            },
            "calling": [
                "pow",
                "sqrt",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080070a4": {
            "entrypoint": "0x080070a4",
            "current_name": "calculate_tag_080070a4",
            "code": "\ndouble calculateTag_080070a4(char *tag)\n\n{\n  double result;\n  \n  return result;\n}\n\n",
            "renaming": {
                "FUN_080070a4": "calculate_tag_080070a4",
                "__tagb": "tag",
                "in_d0": "result"
            },
            "calling": [
                "__ieee754_pow",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080070b0": {
            "entrypoint": "0x080070b0",
            "current_name": "calculate_inverse_square_root_080070b0",
            "code": "\ndouble calculate_inverse_square_root_080070b0(double input)\n\n{\n  int sign_bit;\n  uint lower_bits;\n  uint upper_bits;\n  undefined4 constant_1;\n  undefined4 constant_2;\n  uint exponent_offset;\n  uint mask;\n  double result;\n  double temp_result;\n  undefined8 temp_value;\n  \n  mask = (upper_bits << 1) >> 0x15;\n  exponent_offset = mask - 0x3ff;\n  sign_bit = (int)upper_bits >> 0x1f;\n  if ((int)exponent_offset < 0x14) {\n    if ((int)exponent_offset < 0) {\n      if ((upper_bits & 0x7fffffff | lower_bits) == 0) {\n        return result;\n      }\n      exponent_offset = upper_bits & 0xfffff | lower_bits;\n      sign_bit = sign_bit * -8;\n      constant_1 = *(undefined4 *)(&TWO52 + sign_bit);\n      constant_2 = *(undefined4 *)(&DAT_08007434 + sign_bit);\n      temp_value = __aeabi_dadd(lower_bits,(-exponent_offset | exponent_offset) >> 0xc & 0x80000 | upper_bits & 0xfffe0000,constant_1,constant_2)\n      ;\n      temp_result = (double)__subdf3((int)temp_value,(int)((ulonglong)temp_value >> 0x20),constant_1,constant_2);\n      return temp_result;\n    }\n    mask = 0xfffff >> (exponent_offset & 0xff);\n    if ((upper_bits & mask | lower_bits) == 0) {\n      return result;\n    }\n    mask = mask >> 1;\n    lower_bits = upper_bits & mask | lower_bits;\n    if (lower_bits != 0) {\n      if (exponent_offset == 0x13) {\n        lower_bits = 0x80000000;\n      }\n      else {\n        lower_bits = 0;\n      }\n      upper_bits = 0x40000 >> (exponent_offset & 0xff) | upper_bits & ~mask;\n    }\n  }\n  else {\n    if (0x33 < (int)exponent_offset) {\n      if (exponent_offset != 0x400) {\n        return result;\n      }\n      temp_result = (double)__aeabi_dadd();\n      return temp_result;\n    }\n    mask = mask - 0x413;\n    exponent_offset = 0xffffffff >> (mask & 0xff);\n    if ((lower_bits & exponent_offset) == 0) {\n      return result;\n    }\n    exponent_offset = exponent_offset >> 1;\n    if ((lower_bits & exponent_offset) != 0) {\n      lower_bits = 0x40000000 >> (mask & 0xff) | lower_bits & ~exponent_offset;\n    }\n  }\n  sign_bit = sign_bit * -8;\n  constant_1 = *(undefined4 *)(&TWO52 + sign_bit);\n  constant_2 = *(undefined4 *)(&DAT_08007434 + sign_bit);\n  temp_value = __aeabi_dadd(lower_bits,upper_bits,constant_1,constant_2);\n  temp_result = (double)__subdf3((int)temp_value,(int)((ulonglong)temp_value >> 0x20),constant_1,constant_2);\n  return temp_result;\n}\n\n",
            "renaming": {
                "FUN_080070b0": "calculate_inverse_square_root_080070b0",
                "__x": "input",
                "iVar1": "sign_bit",
                "in_r0": "lower_bits",
                "in_r1": "upper_bits",
                "uVar2": "constant_1",
                "uVar3": "constant_2",
                "uVar4": "exponent_offset",
                "uVar5": "mask",
                "in_d0": "result",
                "dVar6": "temp_result",
                "uVar7": "temp_value"
            },
            "calling": [
                "pow"
            ],
            "called": [
                "__aeabi_dadd",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080071c0": {
            "entrypoint": "0x080071c0",
            "current_name": "calculate_exponential_080071c0",
            "code": "\ndouble calculateExponential_080071c0(double base,int exponent)\n\n{\n  uint temp1;\n  int temp2;\n  int temp3;\n  uint shiftedTemp1;\n  int sum;\n  undefined4 signPart1;\n  undefined4 signPart2;\n  undefined4 signPart3;\n  undefined4 signPart4;\n  double result;\n  double finalResult;\n  \n  shiftedTemp1 = (temp1 << 1) >> 0x15;\n  if (shiftedTemp1 == 0) {\n    if ((temp1 & 0x7fffffff | exponent) == 0) {\n      return result;\n    }\n    result = (double)__muldf3(exponent,temp1,0,0x43500000);\n    if (temp3 < -50000) goto LAB_0800722e;\n    shiftedTemp1 = ((uint)(temp2 << 1) >> 0x15) - 0x36;\n  }\n  else if (shiftedTemp1 == 0x7ff) {\n    finalResult = (double)__aeabi_dadd(exponent,temp1,exponent);\n    return finalResult;\n  }\n  sum = shiftedTemp1 + temp3;\n  if (sum < 0x7ff) {\n    if (0 < sum) {\n      return result;\n    }\n    if (sum + 0x35 < 0 == SCARRY4(sum,0x35)) goto LAB_0800722e;\n    if (temp3 < 0xc351) {\n      copysign((double)CONCAT44(signPart2,signPart1),(double)CONCAT44(signPart4,signPart3));\n      goto LAB_0800722e;\n    }\n  }\n  copysign((double)CONCAT44(signPart2,signPart1),(double)CONCAT44(signPart4,signPart3));\nLAB_0800722e:\n  finalResult = (double)__muldf3();\n  return finalResult;\n}\n\n",
            "renaming": {
                "FUN_080071c0": "calculate_exponential_080071c0",
                "__x": "base",
                "__n": "exponent",
                "in_r1": "temp1",
                "extraout_r1": "temp2",
                "in_r2": "temp3",
                "uVar1": "shiftedTemp1",
                "iVar2": "sum",
                "in_d0": "result",
                "dVar3": "finalResult",
                "in_r3": "signPart1",
                "unaff_r4": "signPart2",
                "unaff_r5": "signPart3",
                "unaff_r6": "signPart4"
            },
            "calling": [
                "__ieee754_pow"
            ],
            "called": [
                "__aeabi_dadd",
                "__muldf3",
                "copysign"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800729c": {
            "entrypoint": "0x0800729c",
            "current_name": "calculate_distance_0800729c",
            "code": "\ndouble calculate_distance_0800729c(double point1_x,double point1_y)\n\n{\n  double distance;\n  \n  return distance;\n}\n\n",
            "renaming": {
                "FUN_0800729c": "calculate_distance_0800729c",
                "__x": "point1_x",
                "__y": "point1_y",
                "in_d0": "distance"
            },
            "calling": [
                "scalbn"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072ac": {
            "entrypoint": "0x080072ac",
            "current_name": "get_impure_ptr_080072ac",
            "code": "\nundefined4 getImpurePtr_080072ac(void)\n\n{\n  return ptrToImpureData;\n}\n\n",
            "renaming": {
                "FUN_080072ac": "get_impure_ptr_080072ac",
                "_impure_ptr": "ptrToImpureData"
            },
            "calling": [
                "pow",
                "sqrt",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072b8": {
            "entrypoint": "0x080072b8",
            "current_name": "extend_heap_080072b8",
            "code": "\nvoid * extendHeap_080072b8(intptr_t size)\n\n{\n  undefined *oldHeapEnd;\n  \n  if (currentHeapEnd == (undefined *)0x0) {\n    currentHeapEnd = &endOfBSS;\n  }\n  oldHeapEnd = currentHeapEnd;\n  currentHeapEnd = currentHeapEnd + size;\n  return oldHeapEnd;\n}\n\n",
            "renaming": {
                "FUN_080072b8": "extend_heap_080072b8",
                "__delta": "size",
                "puVar1": "oldHeapEnd",
                "heap_end_4116": "currentHeapEnd",
                "_ebss": "endOfBSS"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072d4": {
            "entrypoint": "0x080072d4",
            "current_name": "extract_key_context_080072d4",
            "code": "\nint extractKeyContext_080072d4(EVP_PKEY_CTX *keyContext)\n\n{\n  return (int)keyContext;\n}\n\n",
            "renaming": {
                "FUN_080072d4": "extract_key_context_080072d4",
                "ctx": "keyContext"
            },
            "calling": [
                "__libc_init_array",
                "__do_global_dtors_aux",
                "frame_dummy"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072e0": {
            "entrypoint": "0x080072e0",
            "current_name": "FUNC_080072e0",
            "code": "\nvoid FUNC_080072e0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080072e0": "FUNC_080072e0"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 164941,
    "layers": [
        [
            "FUN_08000110",
            "FUN_08000134",
            "FUN_08000150",
            "FUN_08000160",
            "FUN_08000168",
            "FUN_0800016c",
            "FUN_080003e4",
            "FUN_08000404",
            "FUN_08000428",
            "FUN_08000464",
            "FUN_08000474",
            "FUN_080006ac",
            "FUN_08000892",
            "FUN_080008f4",
            "FUN_080008fc",
            "FUN_08000904",
            "FUN_08000980",
            "FUN_08000990",
            "FUN_080009a0",
            "FUN_080009b4",
            "FUN_080009c8",
            "FUN_080009dc",
            "FUN_080009f0",
            "FUN_08000a04",
            "FUN_08000a30",
            "FUN_08000ad0",
            "FUN_08000ad8",
            "FUN_08000adc",
            "FUN_08000c3c",
            "FUN_08000c44",
            "FUN_08000c60",
            "FUN_08000c70",
            "FUN_08000cec",
            "FUN_08000e54",
            "FUN_08000f8c",
            "FUN_08000f94",
            "FUN_08000f9c",
            "FUN_08000ffc",
            "FUN_08001004",
            "FUN_08001014",
            "FUN_08001028",
            "FUN_0800103c",
            "FUN_08001050",
            "FUN_08001064",
            "FUN_08001078",
            "FUN_080010c4",
            "FUN_08001104",
            "FUN_08001128",
            "FUN_0800114c",
            "FUN_0800115c",
            "FUN_08001170",
            "FUN_08001194",
            "FUN_080011fc",
            "FUN_08001214",
            "FUN_08001240",
            "FUN_0800125a",
            "FUN_08001264",
            "FUN_08001424",
            "FUN_0800142e",
            "FUN_08001436",
            "FUN_08001460",
            "FUN_080014e2",
            "FUN_08001530",
            "FUN_080015e8",
            "FUN_080016f4",
            "FUN_08001754",
            "FUN_08001828",
            "FUN_08001938",
            "FUN_08001b58",
            "FUN_08002008",
            "FUN_0800209c",
            "FUN_08002214",
            "FUN_08002220",
            "FUN_08002250",
            "FUN_08002280",
            "FUN_080022d0",
            "FUN_08002324",
            "FUN_08002368",
            "FUN_080023d0",
            "FUN_08002404",
            "FUN_0800245c",
            "FUN_08002520",
            "FUN_08002538",
            "FUN_08002564",
            "FUN_080025a4",
            "FUN_080025e8",
            "FUN_08002724",
            "FUN_0800277c",
            "FUN_080028a6",
            "FUN_0800290c",
            "FUN_0800299a",
            "FUN_08002ad0",
            "FUN_08002b48",
            "FUN_08002bf0",
            "FUN_08002cb0",
            "FUN_08002d88",
            "FUN_08002ea0",
            "FUN_08002ec0",
            "FUN_08002ed4",
            "FUN_08002ee8",
            "FUN_08002f28",
            "FUN_08003034",
            "FUN_08003068",
            "FUN_08003078",
            "FUN_08003298",
            "FUN_08003314",
            "FUN_08003320",
            "FUN_08003330",
            "FUN_08003eac",
            "FUN_08003eb0",
            "FUN_08003ec8",
            "FUN_08003ef2",
            "FUN_08003f0e",
            "FUN_08003f3c",
            "FUN_08003f7c",
            "FUN_08003fc4",
            "FUN_08003fd0",
            "FUN_08003fdc",
            "FUN_08003fe8",
            "FUN_08003ff4",
            "FUN_08004028",
            "FUN_0800403c",
            "FUN_0800407c",
            "FUN_080040b8",
            "FUN_080040e8",
            "FUN_0800411c",
            "FUN_08004194",
            "FUN_080041ae",
            "FUN_080041c4",
            "FUN_080041e4",
            "FUN_0800426c",
            "FUN_08004300",
            "FUN_08004348",
            "FUN_08004384",
            "FUN_080043bc",
            "FUN_080043f0",
            "FUN_08004410",
            "FUN_08004434",
            "FUN_08004458",
            "FUN_08004490",
            "FUN_08004514",
            "FUN_0800458c",
            "FUN_0800483c",
            "FUN_08004978",
            "FUN_08004a30",
            "FUN_08004a84",
            "FUN_08004c18",
            "FUN_08004c30",
            "FUN_08004c64",
            "FUN_08004c70",
            "FUN_08004c8c",
            "FUN_08004cac",
            "FUN_08004ccc",
            "FUN_08004d48",
            "FUN_08004d8c",
            "FUN_08004e14",
            "FUN_08004e7c",
            "FUN_08004ee6",
            "FUN_08004ee8",
            "FUN_08004eea",
            "FUN_08004eec",
            "FUN_08004ef4",
            "FUN_08004f04",
            "FUN_08004f10",
            "FUN_08004f60",
            "FUN_08004f68",
            "FUN_08004fb0",
            "FUN_08004fb4",
            "FUN_08004ffc",
            "FUN_08005044",
            "FUN_080050fc",
            "FUN_080052e4",
            "FUN_080053d4",
            "FUN_08005614",
            "FUN_08005630",
            "FUN_08005646",
            "FUN_0800567c",
            "FUN_08005714",
            "FUN_080057d0",
            "FUN_0800581c",
            "FUN_08005840",
            "FUN_08005854",
            "FUN_08005900",
            "FUN_08005bc8",
            "FUN_08005c70",
            "FUN_08006070",
            "FUN_08006228",
            "FUN_08006c0c",
            "FUN_08006d68",
            "FUN_0800708c",
            "FUN_08007092",
            "FUN_0800709e",
            "FUN_080070a4",
            "FUN_080070b0",
            "FUN_080071c0",
            "FUN_0800729c",
            "FUN_080072ac",
            "FUN_080072b8",
            "FUN_080072d4"
        ],
        [
            "FUN_080004d0",
            "FUN_08000724"
        ]
    ],
    "locked_functions": []
}