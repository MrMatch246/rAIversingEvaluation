{
    "functions": {
        "FUN_0800010c": {
            "entrypoint": "0x0800010c",
            "current_name": "initialize_completed_flag_0800010c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08000118) */\n\nundefined4 initializeCompletedFlag_0800010c(undefined4 inputParameter)\n\n{\n  if ((char)completedFlag == '\\0') {\n    completedFlag._0_1_ = '\\x01';\n  }\n  return inputParameter;\n}\n\n",
            "renaming": {
                "FUN_0800010c": "initialize_completed_flag_0800010c",
                "param_1": "inputParameter",
                "completed_8667": "completedFlag"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000130": {
            "entrypoint": "0x08000130",
            "current_name": "FUNC_08000130",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08000134) */\n/* WARNING: Removing unreachable block (ram,0x0800014e) */\n/* WARNING: Removing unreachable block (ram,0x08000144) */\n/* WARNING: Removing unreachable block (ram,0x08000160) */\n/* WARNING: Removing unreachable block (ram,0x08000154) */\n\n\nvoid FUNC_08000130(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000130": "FUNC_08000130"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000178": {
            "entrypoint": "0x08000178",
            "current_name": "calculate_string_length_08000178",
            "code": "\nsize_t calculateStringLength_08000178(char *string)\n\n{\n  char currentChar;\n  char *nextCharPtr;\n  char *currentCharPtr;\n  \n  currentCharPtr = string;\n  do {\n    nextCharPtr = currentCharPtr + 1;\n    currentChar = *currentCharPtr;\n    currentCharPtr = nextCharPtr;\n  } while (currentChar != '\\0');\n  return (size_t)(nextCharPtr + (-1 - (int)string));\n}\n\n",
            "renaming": {
                "FUN_08000178": "calculate_string_length_08000178",
                "__s": "string",
                "cVar1": "currentChar",
                "pcVar2": "nextCharPtr",
                "pcVar3": "currentCharPtr"
            },
            "calling": [
                "print",
                "printNumber"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000188": {
            "entrypoint": "0x08000188",
            "current_name": "add_undecoded_bits_08000188",
            "code": "\nvoid addUndecodedBits_08000188(undefined4 output,uint input)\n\n{\n  __aeabi_dadd(output,input ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000188": "add_undecoded_bits_08000188",
                "param_1": "output",
                "param_2": "input"
            },
            "calling": [],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000190": {
            "entrypoint": "0x08000190",
            "current_name": "calculate_result_08000190",
            "code": "\nulonglong calculateResult_08000190(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int shift_amount1;\n  byte carry1;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  int shift_amount2;\n  uint result1;\n  uint temp6;\n  uint result2;\n  uint temp7;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  \n  temp4 = input4 ^ 0x80000000;\n  result1 = input2 << 1;\n  input4 = input4 << 1;\n  condition1 = ((input2 ^ temp4) & 0x7fffffff) == 0;\n  condition2 = condition1 && input1 == input3;\n  if (!condition1 || input1 != input3) {\n    condition2 = (result1 | input1) == 0;\n  }\n  if (!condition2) {\n    condition2 = (input4 | input3) == 0;\n  }\n  shift_amount2 = (int)result1 >> 0x15;\n  if (!condition2) {\n    condition2 = shift_amount2 == -1;\n  }\n  shift_amount1 = (int)input4 >> 0x15;\n  if (!condition2) {\n    condition2 = shift_amount1 == -1;\n  }\n  if (condition2) {\n    if (shift_amount2 == -1 || shift_amount1 == -1) {\n      result1 = temp4;\n      result2 = input3;\n      if (shift_amount2 == -1) {\n        result1 = input2;\n        result2 = input1;\n      }\n      if (shift_amount2 != -1 || shift_amount1 != -1) {\n        input3 = result2;\n        temp4 = result1;\n      }\n      condition2 = (result2 | result1 << 0xc) == 0;\n      if (condition2) {\n        condition2 = (input3 | temp4 << 0xc) == 0;\n      }\n      if (condition2) {\n        condition2 = result1 == temp4;\n      }\n      if (!condition2) {\n        result1 = result1 | 0x80000;\n      }\n      return CONCAT44(result1,result2);\n    }\n    if (((input2 ^ temp4) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((result1 | input1) == 0) {\n        input1 = input3;\n        input2 = temp4;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != temp4) {\n      return 0;\n    }\n    if (result1 >> 0x15 == 0) {\n      condition2 = (input1 & 0x80000000) != 0;\n      temp4 = input2 * 2 + (uint)condition2;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)condition2)) {\n        temp4 = temp4 | 0x80000000;\n      }\n      return CONCAT44(temp4,input1 << 1);\n    }\n    if (result1 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  result1 = result1 >> 0x15;\n  input4 = input4 >> 0x15;\n  result2 = input4 - result1;\n  condition2 = result2 != 0;\n  if (input4 < result1) {\n    result2 = -result2;\n  }\n  temp6 = input1;\n  temp5 = input2;\n  if (condition2 && result1 <= input4) {\n    result1 = result1 + result2;\n    temp6 = input3;\n    temp5 = temp4;\n    input3 = input1;\n    temp4 = input2;\n  }\n  if (0x36 < result2) {\n    return CONCAT44(temp5,temp6);\n  }\n  temp2 = temp5 & 0xfffff | 0x100000;\n  if ((temp5 & 0x80000000) != 0) {\n    condition2 = temp6 != 0;\n    temp6 = -temp6;\n    temp2 = -temp2 - (uint)condition2;\n  }\n  temp5 = temp4 & 0xfffff | 0x100000;\n  if ((temp4 & 0x80000000) != 0) {\n    condition2 = input3 != 0;\n    input3 = -input3;\n    temp5 = -temp5 - (uint)condition2;\n  }\n  if (result1 == result2) {\n    temp5 = temp5 ^ 0x100000;\n    if (result1 == 0) {\n      temp2 = temp2 ^ 0x100000;\n      result1 = 1;\n    }\n    else {\n      result2 = result2 - 1;\n    }\n  }\n  temp4 = -result2 + 0x20;\n  if ((int)result2 < 0x21) {\n    temp7 = input3 << (temp4 & 0xff);\n    input3 = input3 >> (result2 & 0xff);\n    temp1 = temp6 + input3;\n    temp3 = temp5 << (temp4 & 0xff);\n    temp4 = temp1 + temp3;\n    temp2 = temp2 + CARRY4(temp6,input3) + ((int)temp5 >> (result2 & 0xff)) +\n            (uint)CARRY4(temp1,temp3);\n  }\n  else {\n    temp7 = temp5 << (-result2 + 0x40 & 0xff);\n    if (input3 != 0) {\n      temp7 = temp7 | 2;\n    }\n    temp5 = (int)temp5 >> (result2 - 0x20 & 0xff);\n    temp4 = temp6 + temp5;\n    temp2 = temp2 + ((int)temp5 >> 0x1f) + (uint)CARRY4(temp6,temp5);\n  }\n  input2 = temp2 & 0x80000000;\n  result2 = temp2;\n  if ((int)temp2 < 0) {\n    condition2 = temp7 == 0;\n    temp7 = -temp7;\n    result2 = -temp4;\n    temp4 = -(uint)!condition2 - temp4;\n    result2 = -(uint)(condition2 <= result2) - temp2;\n  }\n  if (0xfffff < result2) {\n    temp6 = result1 - 1;\n    if (0x1fffff < result2) {\n      temp6 = result2 & 1;\n      result2 = result2 >> 1;\n      carry1 = (byte)temp4;\n      temp4 = (uint)(temp6 != 0) << 0x1f | temp4 >> 1;\n      temp7 = (uint)(carry1 & 1) << 0x1f | temp7 >> 1;\n      temp6 = result1;\n      if (0xffbfffff < result1 * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    condition2 = 0x7fffffff < temp7;\n    if (temp7 == 0x80000000) {\n      condition2 = (temp4 & 1) != 0;\n    }\n    return CONCAT44(result2 + temp6 * 0x100000 + (uint)CARRY4(temp4,(uint)condition2) | input2,\n                    temp4 + condition2);\n  }\n  condition1 = (temp7 & 0x80000000) != 0;\n  temp7 = temp7 << 1;\n  temp6 = temp4 * 2;\n  condition2 = CARRY4(temp4,temp4);\n  temp4 = temp4 * 2 + (uint)condition1;\n  result2 = result2 * 2 + (uint)(condition2 || CARRY4(temp6,(uint)condition1));\n  temp6 = result1 - 2;\n  if ((result2 & 0x100000) != 0) goto LAB_080002a0;\n  temp5 = temp4;\n  result1 = result2;\n  if (result2 == 0) {\n    temp5 = 0;\n    result1 = temp4;\n  }\n  shift_amount2 = LZCOUNT(result1);\n  if (result2 == 0) {\n    shift_amount2 = shift_amount2 + 0x20;\n  }\n  result2 = shift_amount2 - 0xb;\n  condition3 = SBORROW4(result2,0x20);\n  temp4 = shift_amount2 - 0x2b;\n  condition2 = (int)temp4 < 0;\n  condition1 = temp4 == 0;\n  if ((int)result2 < 0x20) {\n    condition3 = SCARRY4(temp4,0xc);\n    shift_amount2 = shift_amount2 + -0x1f;\n    condition2 = shift_amount2 < 0;\n    condition1 = shift_amount2 == 0;\n    temp4 = result2;\n    if (!condition1 && condition2 == condition3) {\n      temp5 = result1 << (result2 & 0xff);\n      result1 = result1 >> (0xcU - shift_amount2 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (condition1 || condition2 != condition3) {\n    temp7 = 0x20 - temp4;\n  }\n  result1 = result1 << (temp4 & 0xff);\n  if (condition1 || condition2 != condition3) {\n    result1 = result1 | temp5 >> (temp7 & 0xff);\n  }\n  if (condition1 || condition2 != condition3) {\n    temp5 = temp5 << (temp4 & 0xff);\n  }\nLAB_08000318:\n  if ((int)result2 <= (int)temp6) {\n    return CONCAT44(result1 + (temp6 - result2) * 0x100000 | input2,temp5);\n  }\n  temp4 = ~(temp6 - result2);\n  if ((int)temp4 < 0x1f) {\n    shift_amount2 = temp4 - 0x13;\n    if (shift_amount2 != 0 && shift_amount2 < 0 == SCARRY4(temp4 - 0x1f,0xc)) {\n      return CONCAT44(temp2,temp5 >> (0x20 - (0xcU - shift_amount2) & 0xff) | result1 << (0xcU - shift_amount2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    temp4 = temp4 + 1;\n    return CONCAT44(input2 | result1 >> (temp4 & 0xff),\n                    temp5 >> (temp4 & 0xff) | result1 << (0x20 - temp4 & 0xff));\n  }\n  return CONCAT44(temp2,result1 >> (temp4 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000190": "calculate_result_08000190",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shift_amount1",
                "bVar2": "carry1",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "uVar6": "temp4",
                "uVar7": "temp5",
                "iVar8": "shift_amount2",
                "uVar9": "result1",
                "uVar10": "temp6",
                "uVar11": "result2",
                "uVar12": "temp7",
                "bVar13": "condition1",
                "bVar14": "condition2",
                "bVar15": "condition3"
            },
            "calling": [
                "SetTunings",
                "Compute",
                "SetControllerDirection",
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000194": {
            "entrypoint": "0x08000194",
            "current_name": "calculate_concatenation_08000194",
            "code": "\nulonglong calculate_concatenation_08000194(uint x1,uint x2,uint x3,uint x4)\n\n{\n  int shift_2;\n  byte carry;\n  uint result_lower_1;\n  uint result_lower_2;\n  uint temp_2;\n  int shift_4;\n  uint temp_1;\n  uint result_upper_1;\n  uint result_upper_2;\n  uint temp_3;\n  uint temp_4;\n  uint temp_5;\n  bool is_zero;\n  bool is_negative;\n  bool borrow;\n  \n  temp_1 = x2 << 1;\n  result_upper_2 = x4 << 1;\n  is_zero = ((x2 ^ x4) & 0x7fffffff) == 0;\n  is_negative = is_zero && x1 == x3;\n  if (!is_zero || x1 != x3) {\n    is_negative = (temp_1 | x1) == 0;\n  }\n  if (!is_negative) {\n    is_negative = (result_upper_2 | x3) == 0;\n  }\n  shift_4 = (int)temp_1 >> 0x15;\n  if (!is_negative) {\n    is_negative = shift_4 == -1;\n  }\n  shift_2 = (int)result_upper_2 >> 0x15;\n  if (!is_negative) {\n    is_negative = shift_2 == -1;\n  }\n  if (is_negative) {\n    if (shift_4 == -1 || shift_2 == -1) {\n      result_upper_2 = x4;\n      temp_1 = x3;\n      if (shift_4 == -1) {\n        result_upper_2 = x2;\n        temp_1 = x1;\n      }\n      if (shift_4 != -1 || shift_2 != -1) {\n        x3 = temp_1;\n        x4 = result_upper_2;\n      }\n      is_negative = (temp_1 | result_upper_2 << 0xc) == 0;\n      if (is_negative) {\n        is_negative = (x3 | x4 << 0xc) == 0;\n      }\n      if (is_negative) {\n        is_negative = result_upper_2 == x4;\n      }\n      if (!is_negative) {\n        result_upper_2 = result_upper_2 | 0x80000;\n      }\n      return CONCAT44(result_upper_2,temp_1);\n    }\n    if (((x2 ^ x4) & 0x7fffffff) != 0 || x1 != x3) {\n      if ((temp_1 | x1) == 0) {\n        x1 = x3;\n        x2 = x4;\n      }\n      return CONCAT44(x2,x1);\n    }\n    if (x2 != x4) {\n      return 0;\n    }\n    if (temp_1 >> 0x15 == 0) {\n      is_negative = (x1 & 0x80000000) != 0;\n      result_upper_2 = x2 * 2 + (uint)is_negative;\n      if (CARRY4(x2,x2) || CARRY4(x2 * 2,(uint)is_negative)) {\n        result_upper_2 = result_upper_2 | 0x80000000;\n      }\n      return CONCAT44(result_upper_2,x1 << 1);\n    }\n    if (temp_1 < 0xffc00000) {\n      return CONCAT44(x2 + 0x100000,x1);\n    }\n    x2 = x2 & 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(x2 | 0x7ff00000) << 0x20;\n  }\n  temp_1 = temp_1 >> 0x15;\n  result_upper_2 = result_upper_2 >> 0x15;\n  temp_3 = result_upper_2 - temp_1;\n  is_negative = temp_3 != 0;\n  if (result_upper_2 < temp_1) {\n    temp_3 = -temp_3;\n  }\n  result_upper_1 = x1;\n  temp_2 = x2;\n  if (is_negative && temp_1 <= result_upper_2) {\n    temp_1 = temp_1 + temp_3;\n    result_upper_1 = x3;\n    temp_2 = x4;\n    x3 = x1;\n    x4 = x2;\n  }\n  if (0x36 < temp_3) {\n    return CONCAT44(temp_2,result_upper_1);\n  }\n  result_upper_2 = temp_2 & 0xfffff | 0x100000;\n  if ((temp_2 & 0x80000000) != 0) {\n    is_negative = result_upper_1 != 0;\n    result_upper_1 = -result_upper_1;\n    result_upper_2 = -result_upper_2 - (uint)is_negative;\n  }\n  temp_2 = x4 & 0xfffff | 0x100000;\n  if ((x4 & 0x80000000) != 0) {\n    is_negative = x3 != 0;\n    x3 = -x3;\n    temp_2 = -temp_2 - (uint)is_negative;\n  }\n  if (temp_1 == temp_3) {\n    temp_2 = temp_2 ^ 0x100000;\n    if (temp_1 == 0) {\n      result_upper_2 = result_upper_2 ^ 0x100000;\n      temp_1 = 1;\n    }\n    else {\n      temp_3 = temp_3 - 1;\n    }\n  }\n  temp_5 = -temp_3 + 0x20;\n  if ((int)temp_3 < 0x21) {\n    temp_4 = x3 << (temp_5 & 0xff);\n    x3 = x3 >> (temp_3 & 0xff);\n    result_lower_1 = result_upper_1 + x3;\n    result_lower_2 = temp_2 << (temp_5 & 0xff);\n    temp_5 = result_lower_1 + result_lower_2;\n    result_upper_2 = result_upper_2 + CARRY4(result_upper_1,x3) + ((int)temp_2 >> (temp_3 & 0xff)) +\n            (uint)CARRY4(result_lower_1,result_lower_2);\n  }\n  else {\n    temp_4 = temp_2 << (-temp_3 + 0x40 & 0xff);\n    if (x3 != 0) {\n      temp_4 = temp_4 | 2;\n    }\n    temp_2 = (int)temp_2 >> (temp_3 - 0x20 & 0xff);\n    temp_5 = result_upper_1 + temp_2;\n    result_upper_2 = result_upper_2 + ((int)temp_2 >> 0x1f) + (uint)CARRY4(result_upper_1,temp_2);\n  }\n  x2 = result_upper_2 & 0x80000000;\n  temp_3 = result_upper_2;\n  if ((int)result_upper_2 < 0) {\n    is_negative = temp_4 == 0;\n    temp_4 = -temp_4;\n    temp_3 = -temp_5;\n    temp_5 = -(uint)!is_negative - temp_5;\n    temp_3 = -(uint)(is_negative <= temp_3) - result_upper_2;\n  }\n  if (0xfffff < temp_3) {\n    result_upper_1 = temp_1 - 1;\n    if (0x1fffff < temp_3) {\n      result_upper_2 = temp_3 & 1;\n      temp_3 = temp_3 >> 1;\n      carry = (byte)temp_5;\n      temp_5 = (uint)(result_upper_2 != 0) << 0x1f | temp_5 >> 1;\n      temp_4 = (uint)(carry & 1) << 0x1f | temp_4 >> 1;\n      result_upper_1 = temp_1;\n      if (0xffbfffff < temp_1 * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    is_negative = 0x7fffffff < temp_4;\n    if (temp_4 == 0x80000000) {\n      is_negative = (temp_5 & 1) != 0;\n    }\n    return CONCAT44(temp_3 + result_upper_1 * 0x100000 + (uint)CARRY4(temp_5,(uint)is_negative) | x2,\n                    temp_5 + is_negative);\n  }\n  is_zero = (temp_4 & 0x80000000) != 0;\n  temp_4 = temp_4 << 1;\n  result_upper_1 = temp_5 * 2;\n  is_negative = CARRY4(temp_5,temp_5);\n  temp_5 = temp_5 * 2 + (uint)is_zero;\n  temp_3 = temp_3 * 2 + (uint)(is_negative || CARRY4(result_upper_1,(uint)is_zero));\n  result_upper_1 = temp_1 - 2;\n  if ((temp_3 & 0x100000) != 0) goto LAB_080002a0;\n  temp_2 = temp_5;\n  temp_1 = temp_3;\n  if (temp_3 == 0) {\n    temp_2 = 0;\n    temp_1 = temp_5;\n  }\n  shift_4 = LZCOUNT(temp_1);\n  if (temp_3 == 0) {\n    shift_4 = shift_4 + 0x20;\n  }\n  temp_5 = shift_4 - 0xb;\n  borrow = SBORROW4(temp_5,0x20);\n  temp_3 = shift_4 - 0x2b;\n  is_negative = (int)temp_3 < 0;\n  is_zero = temp_3 == 0;\n  if ((int)temp_5 < 0x20) {\n    borrow = SCARRY4(temp_3,0xc);\n    shift_4 = shift_4 + -0x1f;\n    is_negative = shift_4 < 0;\n    is_zero = shift_4 == 0;\n    temp_3 = temp_5;\n    if (!is_zero && is_negative == borrow) {\n      temp_2 = temp_1 << (temp_5 & 0xff);\n      temp_1 = temp_1 >> (0xcU - shift_4 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (is_zero || is_negative != borrow) {\n    temp_4 = 0x20 - temp_3;\n  }\n  temp_1 = temp_1 << (temp_3 & 0xff);\n  if (is_zero || is_negative != borrow) {\n    temp_1 = temp_1 | temp_2 >> (temp_4 & 0xff);\n  }\n  if (is_zero || is_negative != borrow) {\n    temp_2 = temp_2 << (temp_3 & 0xff);\n  }\nLAB_08000318:\n  if ((int)temp_5 <= (int)result_upper_1) {\n    return CONCAT44(temp_1 + (result_upper_1 - temp_5) * 0x100000 | x2,temp_2);\n  }\n  temp_3 = ~(result_upper_1 - temp_5);\n  if ((int)temp_3 < 0x1f) {\n    shift_4 = temp_3 - 0x13;\n    if (shift_4 != 0 && shift_4 < 0 == SCARRY4(temp_3 - 0x1f,0xc)) {\n      return CONCAT44(result_upper_2,temp_2 >> (0x20 - (0xcU - shift_4) & 0xff) | temp_1 << (0xcU - shift_4 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    temp_3 = temp_3 + 1;\n    return CONCAT44(x2 | temp_1 >> (temp_3 & 0xff),\n                    temp_2 >> (temp_3 & 0xff) | temp_1 << (0x20 - temp_3 & 0xff));\n  }\n  return CONCAT44(result_upper_2,temp_1 >> (temp_3 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000194": "calculate_concatenation_08000194",
                "param_1": "x1",
                "param_2": "x2",
                "param_3": "x3",
                "param_4": "x4",
                "iVar1": "shift_2",
                "bVar2": "carry",
                "uVar3": "result_lower_1",
                "uVar4": "result_lower_2",
                "uVar5": "temp_2",
                "iVar6": "shift_4",
                "uVar7": "temp_1",
                "uVar8": "result_upper_1",
                "uVar9": "result_upper_2",
                "uVar10": "temp_3",
                "uVar11": "temp_4",
                "uVar12": "temp_5",
                "bVar13": "is_zero",
                "bVar14": "is_negative",
                "bVar15": "borrow"
            },
            "calling": [
                "loop",
                "Compute",
                "__aeabi_drsub",
                "readThermocouple",
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800040c": {
            "entrypoint": "0x0800040c",
            "current_name": "calculate_shifted_value_0800040c",
            "code": "\nulonglong calculate_shifted_value_0800040c(uint input_value)\n\n{\n  uint shifted_value_upper;\n  uint shifted_value_lower;\n  int leading_zeros;\n  uint shift_amount;\n  uint remaining_bits;\n  bool is_negative_shift;\n  bool is_zero_shift;\n  bool is_shift_valid;\n  \n  if (input_value == 0) {\n    return 0;\n  }\n  shifted_value_upper = 0;\n  leading_zeros = LZCOUNT(input_value);\n  shift_amount = leading_zeros + 0x15;\n  is_shift_valid = SBORROW4(shift_amount,0x20);\n  shifted_value_lower = leading_zeros - 0xb;\n  is_negative_shift = (int)shifted_value_lower < 0;\n  is_zero_shift = shifted_value_lower == 0;\n  if (shift_amount < 0x20) {\n    is_shift_valid = SCARRY4(shifted_value_lower,0xc);\n    is_negative_shift = false;\n    is_zero_shift = leading_zeros + 1 == 0;\n    shifted_value_lower = shift_amount;\n    if (!is_zero_shift && is_shift_valid == false) {\n      shifted_value_upper = input_value << shift_amount;\n      input_value = input_value >> (0xcU - (leading_zeros + 1) & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (is_zero_shift || is_negative_shift != is_shift_valid) {\n    remaining_bits = 0x20 - shifted_value_lower;\n  }\n  input_value = input_value << (shifted_value_lower & 0xff);\n  if (is_zero_shift || is_negative_shift != is_shift_valid) {\n    input_value = input_value | 0U >> (remaining_bits & 0xff);\n  }\n  if (is_zero_shift || is_negative_shift != is_shift_valid) {\n    shifted_value_upper = 0 << (shifted_value_lower & 0xff);\n  }\nLAB_08000318:\n  if (shift_amount < 0x433) {\n    return CONCAT44(input_value + (0x432 - shift_amount) * 0x100000,shifted_value_upper);\n  }\n  shifted_value_lower = ~(0x432 - shift_amount);\n  if (0x1e < (int)shifted_value_lower) {\n    return (ulonglong)(input_value >> (shifted_value_lower - 0x1f & 0xff));\n  }\n  leading_zeros = shifted_value_lower - 0x13;\n  if (leading_zeros == 0 || leading_zeros < 0 != SCARRY4(shifted_value_lower - 0x1f,0xc)) {\n    shifted_value_lower = shifted_value_lower + 1;\n    return CONCAT44(input_value >> (shifted_value_lower & 0xff),\n                    shifted_value_upper >> (shifted_value_lower & 0xff) | input_value << (0x20 - shifted_value_lower & 0xff));\n  }\n  return (ulonglong)(shifted_value_upper >> (0x20 - (0xcU - leading_zeros) & 0xff) | input_value << (0xcU - leading_zeros & 0xff));\n}\n\n",
            "renaming": {
                "FUN_0800040c": "calculate_shifted_value_0800040c",
                "param_1": "input_value",
                "uVar1": "shifted_value_upper",
                "uVar2": "shifted_value_lower",
                "iVar3": "leading_zeros",
                "uVar4": "shift_amount",
                "in_r12": "remaining_bits",
                "bVar5": "is_negative_shift",
                "bVar6": "is_zero_shift",
                "bVar7": "is_shift_valid"
            },
            "calling": [
                "loop",
                "SetTunings",
                "readThermocouple",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800042c": {
            "entrypoint": "0x0800042c",
            "current_name": "calculate_shifted_value_0800042c",
            "code": "\nulonglong calculate_shifted_value_0800042c(uint input_value)\n\n{\n  uint shift_amount;\n  uint absolute_input_value;\n  uint shifted_value;\n  int leading_zeros;\n  uint shifted_amount;\n  uint sign_bit;\n  uint bitmask;\n  bool is_negative;\n  bool is_zero;\n  bool carry_flag;\n  \n  if (input_value == 0) {\n    return 0;\n  }\n  sign_bit = input_value & 0x80000000;\n  absolute_input_value = input_value;\n  if ((int)sign_bit < 0) {\n    absolute_input_value = -input_value;\n  }\n  shift_amount = 0;\n  leading_zeros = LZCOUNT(absolute_input_value);\n  shifted_amount = leading_zeros + 0x15;\n  carry_flag = SBORROW4(shifted_amount,0x20);\n  shifted_value = leading_zeros - 0xb;\n  is_negative = (int)shifted_value < 0;\n  is_zero = shifted_value == 0;\n  if (shifted_amount < 0x20) {\n    carry_flag = SCARRY4(shifted_value,0xc);\n    is_negative = false;\n    is_zero = leading_zeros + 1 == 0;\n    shifted_value = shifted_amount;\n    if (!is_zero && carry_flag == false) {\n      shift_amount = absolute_input_value << shifted_amount;\n      absolute_input_value = absolute_input_value >> (0xcU - (leading_zeros + 1) & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (is_zero || is_negative != carry_flag) {\n    bitmask = 0x20 - shifted_value;\n  }\n  absolute_input_value = absolute_input_value << (shifted_value & 0xff);\n  if (is_zero || is_negative != carry_flag) {\n    absolute_input_value = absolute_input_value | 0U >> (bitmask & 0xff);\n  }\n  if (is_zero || is_negative != carry_flag) {\n    shift_amount = 0 << (shifted_value & 0xff);\n  }\nLAB_08000318:\n  if (shifted_amount < 0x433) {\n    return CONCAT44(absolute_input_value + (0x432 - shifted_amount) * 0x100000 | sign_bit,shift_amount);\n  }\n  shifted_value = ~(0x432 - shifted_amount);\n  if (0x1e < (int)shifted_value) {\n    return CONCAT44(input_value,absolute_input_value >> (shifted_value - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leading_zeros = shifted_value - 0x13;\n  if (leading_zeros == 0 || leading_zeros < 0 != SCARRY4(shifted_value - 0x1f,0xc)) {\n    shifted_value = shifted_value + 1;\n    return CONCAT44(sign_bit | absolute_input_value >> (shifted_value & 0xff),\n                    shift_amount >> (shifted_value & 0xff) | absolute_input_value << (0x20 - shifted_value & 0xff));\n  }\n  return CONCAT44(input_value,shift_amount >> (0x20 - (0xcU - leading_zeros) & 0xff) | absolute_input_value << (0xcU - leading_zeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800042c": "calculate_shifted_value_0800042c",
                "param_1": "input_value",
                "uVar1": "shift_amount",
                "uVar2": "absolute_input_value",
                "uVar3": "shifted_value",
                "iVar4": "leading_zeros",
                "uVar5": "shifted_amount",
                "uVar6": "sign_bit",
                "in_r12": "bitmask",
                "bVar7": "is_negative",
                "bVar8": "is_zero",
                "bVar9": "carry_flag"
            },
            "calling": [
                "loop",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000450": {
            "entrypoint": "0x08000450",
            "current_name": "reverse_bits_08000450",
            "code": "\nulonglong reverseBits_08000450(uint input,undefined4 param_2,undefined4 param_3,uint param_4)\n\n{\n  uint signExtension;\n  uint shiftedInput;\n  uint resultHigh;\n  uint shiftValue1;\n  uint shiftValue2;\n  int index;\n  uint shiftAmount;\n  uint remainder;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  \n  shiftValue2 = input << 1;\n  condition2 = shiftValue2 == 0;\n  signExtension = (uint)((input & 0x80000000) != 0) << 0x1f;\n  shiftValue1 = (uint)((int)shiftValue2 >> 3) >> 1;\n  resultHigh = signExtension | shiftValue1;\n  input = input << 0x1d;\n  if (!condition2) {\n    param_4 = shiftValue2 & 0xff000000;\n    condition2 = param_4 == 0;\n  }\n  if (!condition2) {\n    condition2 = param_4 == 0xff000000;\n  }\n  if (!condition2) {\n    return CONCAT44(resultHigh,input) ^ 0x3800000000000000;\n  }\n  if (shiftValue2 == 0 || param_4 == 0xff000000) {\n    return CONCAT44(resultHigh,input);\n  }\n  shiftedInput = input;\n  shiftValue2 = shiftValue1;\n  if (shiftValue1 == 0) {\n    shiftedInput = 0;\n    shiftValue2 = input;\n  }\n  index = LZCOUNT(shiftValue2);\n  if (shiftValue1 == 0) {\n    index = index + 0x20;\n  }\n  shiftAmount = index - 0xb;\n  condition3 = SBORROW4(shiftAmount,0x20);\n  shiftValue1 = index - 0x2b;\n  condition2 = (int)shiftValue1 < 0;\n  condition1 = shiftValue1 == 0;\n  if ((int)shiftAmount < 0x20) {\n    condition3 = SCARRY4(shiftValue1,0xc);\n    index = index + -0x1f;\n    condition2 = index < 0;\n    condition1 = index == 0;\n    shiftValue1 = shiftAmount;\n    if (!condition1 && condition2 == condition3) {\n      shiftedInput = shiftValue2 << (shiftAmount & 0xff);\n      shiftValue2 = shiftValue2 >> (0xcU - index & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (condition1 || condition2 != condition3) {\n    remainder = 0x20 - shiftValue1;\n  }\n  shiftValue2 = shiftValue2 << (shiftValue1 & 0xff);\n  if (condition1 || condition2 != condition3) {\n    shiftValue2 = shiftValue2 | shiftedInput >> (remainder & 0xff);\n  }\n  if (condition1 || condition2 != condition3) {\n    shiftedInput = shiftedInput << (shiftValue1 & 0xff);\n  }\nLAB_08000318:\n  if ((int)shiftAmount < 0x381) {\n    return CONCAT44(shiftValue2 + (0x380 - shiftAmount) * 0x100000 | signExtension,shiftedInput);\n  }\n  shiftValue1 = ~(0x380 - shiftAmount);\n  if ((int)shiftValue1 < 0x1f) {\n    index = shiftValue1 - 0x13;\n    if (index != 0 && index < 0 == SCARRY4(shiftValue1 - 0x1f,0xc)) {\n      return CONCAT44(resultHigh,shiftedInput >> (0x20 - (0xcU - index) & 0xff) | shiftValue2 << (0xcU - index & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    shiftValue1 = shiftValue1 + 1;\n    return CONCAT44(signExtension | shiftValue2 >> (shiftValue1 & 0xff),\n                    shiftedInput >> (shiftValue1 & 0xff) | shiftValue2 << (0x20 - shiftValue1 & 0xff));\n  }\n  return CONCAT44(resultHigh,shiftValue2 >> (shiftValue1 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000450": "reverse_bits_08000450",
                "param_1": "input",
                "uVar1": "signExtension",
                "uVar2": "shiftedInput",
                "uVar3": "resultHigh",
                "uVar4": "shiftValue1",
                "uVar5": "shiftValue2",
                "iVar6": "index",
                "uVar7": "shiftAmount",
                "in_r12": "remainder",
                "bVar8": "condition1",
                "bVar9": "condition2",
                "bVar10": "condition3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800048c": {
            "entrypoint": "0x0800048c",
            "current_name": "reverse_computation_0800048c",
            "code": "\nulonglong reverse_computation_0800048c(uint input1,uint input2)\n\n{\n  byte temp_byte;\n  uint result1_tmp;\n  uint result2_tmp;\n  uint result;\n  int shift_amount;\n  uint carry_amount;\n  int offset;\n  uint temp;\n  bool is_negative;\n  bool is_overflow;\n  bool is_borrow;\n  \n  if ((input1 | input2) == 0) {\n    return CONCAT44(input2,input1);\n  }\n  offset = 0x432;\n  temp = input2 >> 0x16;\n  if (temp != 0) {\n    offset = 3;\n    if (input2 >> 0x19 != 0) {\n      offset = 6;\n    }\n    if (input2 >> 0x1c != 0) {\n      offset = offset + 3;\n    }\n    result = offset - ((int)input2 >> 0x1f);\n    temp = input1 << (0x20 - result & 0xff);\n    input1 = input1 >> (result & 0xff) | input2 << (0x20 - result & 0xff);\n    input2 = input2 >> (result & 0xff);\n    offset = result + 0x432;\n  }\n  if (0xfffff < input2) {\n    if (0x1fffff < input2) {\n      result = input2 & 1;\n      input2 = input2 >> 1;\n      temp_byte = (byte)input1;\n      input1 = (uint)(result != 0) << 0x1f | input1 >> 1;\n      temp = (uint)(temp_byte & 1) << 0x1f | temp >> 1;\n      offset = offset + 1;\n      if (0xffbfffff < (uint)(offset * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_080002a0:\n    is_overflow = 0x7fffffff < temp;\n    if (temp == 0x80000000) {\n      is_overflow = (input1 & 1) != 0;\n    }\n    return CONCAT44(input2 + offset * 0x100000 + (uint)CARRY4(input1,(uint)is_overflow),input1 + is_overflow\n                   );\n  }\n  is_negative = (temp & 0x80000000) != 0;\n  temp = temp << 1;\n  result = input1 * 2;\n  is_overflow = CARRY4(input1,input1);\n  input1 = input1 * 2 + (uint)is_negative;\n  input2 = input2 * 2 + (uint)(is_overflow || CARRY4(result,(uint)is_negative));\n  offset = offset + -1;\n  if ((input2 & 0x100000) != 0) goto LAB_080002a0;\n  result1_tmp = input1;\n  result = input2;\n  if (input2 == 0) {\n    result1_tmp = 0;\n    result = input1;\n  }\n  shift_amount = LZCOUNT(result);\n  if (input2 == 0) {\n    shift_amount = shift_amount + 0x20;\n  }\n  carry_amount = shift_amount - 0xb;\n  is_borrow = SBORROW4(carry_amount,0x20);\n  result2_tmp = shift_amount - 0x2b;\n  is_overflow = (int)result2_tmp < 0;\n  is_negative = result2_tmp == 0;\n  if ((int)carry_amount < 0x20) {\n    is_borrow = SCARRY4(result2_tmp,0xc);\n    shift_amount = shift_amount + -0x1f;\n    is_overflow = shift_amount < 0;\n    is_negative = shift_amount == 0;\n    result2_tmp = carry_amount;\n    if (!is_negative && is_overflow == is_borrow) {\n      result1_tmp = result << (carry_amount & 0xff);\n      result = result >> (0xcU - shift_amount & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (is_negative || is_overflow != is_borrow) {\n    temp = 0x20 - result2_tmp;\n  }\n  result = result << (result2_tmp & 0xff);\n  if (is_negative || is_overflow != is_borrow) {\n    result = result | result1_tmp >> (temp & 0xff);\n  }\n  if (is_negative || is_overflow != is_borrow) {\n    result1_tmp = result1_tmp << (result2_tmp & 0xff);\n  }\nLAB_08000318:\n  if ((int)carry_amount <= offset) {\n    return CONCAT44(result + (offset - carry_amount) * 0x100000,result1_tmp);\n  }\n  temp = ~(offset - carry_amount);\n  if (0x1e < (int)temp) {\n    return (ulonglong)(result >> (temp - 0x1f & 0xff));\n  }\n  offset = temp - 0x13;\n  if (offset == 0 || offset < 0 != SCARRY4(temp - 0x1f,0xc)) {\n    temp = temp + 1;\n    return CONCAT44(result >> (temp & 0xff),result1_tmp >> (temp & 0xff) | result << (0x20 - temp & 0xff)\n                   );\n  }\n  return (ulonglong)(result1_tmp >> (0x20 - (0xcU - offset) & 0xff) | result << (0xcU - offset & 0xff));\n}\n\n",
            "renaming": {
                "FUN_0800048c": "reverse_computation_0800048c",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "temp_byte",
                "uVar2": "result1_tmp",
                "uVar3": "result2_tmp",
                "uVar4": "result",
                "iVar5": "shift_amount",
                "uVar6": "carry_amount",
                "iVar7": "offset",
                "uVar8": "temp",
                "bVar9": "is_negative",
                "bVar10": "is_overflow",
                "bVar11": "is_borrow"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800049c": {
            "entrypoint": "0x0800049c",
            "current_name": "calculate_product_and_remainder_0800049c",
            "code": "\nulonglong calculate_product_and_remainder_0800049c(uint dividend,uint divisor)\n\n{\n  byte byteVar1;\n  uint quotient;\n  uint remainder;\n  uint tempVar1;\n  int shiftCount;\n  uint tempVar2;\n  int tempVar3;\n  uint signBit;\n  uint tempVar4;\n  bool boolVar1;\n  bool boolVar2;\n  bool boolVar3;\n  \n  if ((dividend | divisor) == 0) {\n    return CONCAT44(divisor,dividend);\n  }\n  signBit = divisor & 0x80000000;\n  remainder = divisor;\n  if ((int)signBit < 0) {\n    boolVar2 = dividend != 0;\n    dividend = -dividend;\n    remainder = -divisor - (uint)boolVar2;\n  }\n  tempVar3 = 0x432;\n  tempVar4 = remainder >> 0x16;\n  if (tempVar4 != 0) {\n    tempVar3 = 3;\n    if (remainder >> 0x19 != 0) {\n      tempVar3 = 6;\n    }\n    if (remainder >> 0x1c != 0) {\n      tempVar3 = tempVar3 + 3;\n    }\n    tempVar1 = tempVar3 - ((int)remainder >> 0x1f);\n    tempVar4 = dividend << (0x20 - tempVar1 & 0xff);\n    dividend = dividend >> (tempVar1 & 0xff) | remainder << (0x20 - tempVar1 & 0xff);\n    remainder = remainder >> (tempVar1 & 0xff);\n    tempVar3 = tempVar1 + 0x432;\n  }\n  if (0xfffff < remainder) {\n    if (0x1fffff < remainder) {\n      tempVar1 = remainder & 1;\n      remainder = remainder >> 1;\n      byteVar1 = (byte)dividend;\n      dividend = (uint)(tempVar1 != 0) << 0x1f | dividend >> 1;\n      tempVar4 = (uint)(byteVar1 & 1) << 0x1f | tempVar4 >> 1;\n      tempVar3 = tempVar3 + 1;\n      if (0xffbfffff < (uint)(tempVar3 * 0x200000)) {\n        return (ulonglong)(signBit | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_080002a0:\n    boolVar2 = 0x7fffffff < tempVar4;\n    if (tempVar4 == 0x80000000) {\n      boolVar2 = (dividend & 1) != 0;\n    }\n    return CONCAT44(remainder + tempVar3 * 0x100000 + (uint)CARRY4(dividend,(uint)boolVar2) | signBit,\n                    dividend + boolVar2);\n  }\n  boolVar1 = (tempVar4 & 0x80000000) != 0;\n  tempVar4 = tempVar4 << 1;\n  tempVar1 = dividend * 2;\n  boolVar2 = CARRY4(dividend,dividend);\n  dividend = dividend * 2 + (uint)boolVar1;\n  remainder = remainder * 2 + (uint)(boolVar2 || CARRY4(tempVar1,(uint)boolVar1));\n  tempVar3 = tempVar3 + -1;\n  if ((remainder & 0x100000) != 0) goto LAB_080002a0;\n  quotient = dividend;\n  tempVar1 = remainder;\n  if (remainder == 0) {\n    quotient = 0;\n    tempVar1 = dividend;\n  }\n  shiftCount = LZCOUNT(tempVar1);\n  if (remainder == 0) {\n    shiftCount = shiftCount + 0x20;\n  }\n  tempVar2 = shiftCount - 0xb;\n  boolVar3 = SBORROW4(tempVar2,0x20);\n  remainder = shiftCount - 0x2b;\n  boolVar2 = (int)remainder < 0;\n  boolVar1 = remainder == 0;\n  if ((int)tempVar2 < 0x20) {\n    boolVar3 = SCARRY4(remainder,0xc);\n    shiftCount = shiftCount + -0x1f;\n    boolVar2 = shiftCount < 0;\n    boolVar1 = shiftCount == 0;\n    remainder = tempVar2;\n    if (!boolVar1 && boolVar2 == boolVar3) {\n      quotient = tempVar1 << (tempVar2 & 0xff);\n      tempVar1 = tempVar1 >> (0xcU - shiftCount & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (boolVar1 || boolVar2 != boolVar3) {\n    tempVar4 = 0x20 - remainder;\n  }\n  tempVar1 = tempVar1 << (remainder & 0xff);\n  if (boolVar1 || boolVar2 != boolVar3) {\n    tempVar1 = tempVar1 | quotient >> (tempVar4 & 0xff);\n  }\n  if (boolVar1 || boolVar2 != boolVar3) {\n    quotient = quotient << (remainder & 0xff);\n  }\nLAB_08000318:\n  if ((int)tempVar2 <= tempVar3) {\n    return CONCAT44(tempVar1 + (tempVar3 - tempVar2) * 0x100000 | signBit,quotient);\n  }\n  remainder = ~(tempVar3 - tempVar2);\n  if (0x1e < (int)remainder) {\n    return CONCAT44(divisor,tempVar1 >> (remainder - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  tempVar3 = remainder - 0x13;\n  if (tempVar3 == 0 || tempVar3 < 0 != SCARRY4(remainder - 0x1f,0xc)) {\n    remainder = remainder + 1;\n    return CONCAT44(signBit | tempVar1 >> (remainder & 0xff),\n                    quotient >> (remainder & 0xff) | tempVar1 << (0x20 - remainder & 0xff));\n  }\n  return CONCAT44(divisor,quotient >> (0x20 - (0xcU - tempVar3) & 0xff) | tempVar1 << (0xcU - tempVar3 & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800049c": "calculate_product_and_remainder_0800049c",
                "param_1": "dividend",
                "param_2": "divisor",
                "bVar1": "byteVar1",
                "uVar2": "quotient",
                "uVar3": "remainder",
                "uVar4": "tempVar1",
                "iVar5": "shiftCount",
                "uVar6": "tempVar2",
                "iVar7": "tempVar3",
                "uVar8": "signBit",
                "uVar9": "tempVar4",
                "bVar10": "boolVar1",
                "bVar11": "boolVar2",
                "bVar12": "boolVar3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004f8": {
            "entrypoint": "0x080004f8",
            "current_name": "calculate_result_080004f8",
            "code": "\nulonglong calculate_result_080004f8(undefined4 input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  ulonglong result_1;\n  longlong result_2;\n  uint temp1;\n  uint temp2;\n  int temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  ulonglong combined_input;\n  \n  combined_input = CONCAT44(input_2,input_1);\n  temp6 = 0x7ff;\n  temp2 = input_2 >> 0x14 & 0x7ff;\n  flag1 = temp2 == 0;\n  if (!flag1) {\n    temp5 = input_4 >> 0x14 & 0x7ff;\n    flag1 = temp5 == 0;\n  }\n  if (!flag1) {\n    flag1 = temp2 == 0x7ff;\n  }\n  if (!flag1) {\n    flag1 = temp5 == 0x7ff;\n  }\n  if (flag1) {\n    combined_input = calculate_bitwise_result_080006d4();\n  }\n  temp1 = (uint)(combined_input >> 0x20);\n  temp3 = temp2 + temp5;\n  temp2 = temp1 ^ input_4;\n  temp1 = temp1 & ~(temp6 << 0x15);\n  input_4 = input_4 & ~(temp6 << 0x15);\n  flag1 = ((uint)combined_input | temp1 << 0xc) == 0;\n  if (!flag1) {\n    flag1 = (input_3 | input_4 << 0xc) == 0;\n  }\n  temp1 = temp1 | 0x100000;\n  input_4 = input_4 | 0x100000;\n  if (flag1) {\n    input_3 = (uint)combined_input | input_3;\n    input_4 = (temp2 & 0x80000000 | temp1) ^ input_4;\n    temp2 = temp6 >> 1;\n    flag3 = SBORROW4(temp3,temp2);\n    temp4 = temp3 - temp2;\n    flag1 = temp4 == 0;\n    temp1 = temp4;\n    if (!flag1 && (int)temp2 <= temp3) {\n      flag3 = SBORROW4(temp6,temp4);\n      temp1 = temp6 - temp4;\n      flag1 = temp6 == temp4;\n    }\n    if (!flag1 && (int)temp1 < 0 == flag3) {\n      input_4 = input_4 | temp4 * 0x100000;\n    }\n    if (!flag1 && (int)temp1 < 0 == flag3) {\n      return CONCAT44(input_4,input_3);\n    }\n    input_4 = input_4 | 0x100000;\n    temp6 = 0;\n    flag3 = SBORROW4(temp4,1);\n    temp4 = temp4 - 1;\n    flag1 = temp4 == 0;\n    temp2 = temp4;\n  }\n  else {\n    result_1 = (combined_input & 0xffffffff) * (ulonglong)input_3;\n    combined_input = (combined_input & 0xffffffff) * (ulonglong)input_4 +\n             (ulonglong)temp1 * (ulonglong)input_3 + (result_1 >> 0x20);\n    temp7 = (uint)combined_input;\n    result_2 = (ulonglong)temp1 * (ulonglong)input_4 + (combined_input >> 0x20);\n    temp6 = (uint)result_2;\n    temp1 = (uint)((ulonglong)result_2 >> 0x20);\n    if ((int)result_1 != 0) {\n      temp7 = temp7 | 1;\n    }\n    temp4 = (temp3 + -0x3ff) - (uint)(temp1 < 0x200);\n    if (temp1 < 0x200) {\n      flag1 = (temp7 & 0x80000000) != 0;\n      temp7 = temp7 << 1;\n      result_2 = CONCAT44(temp1 * 2 + (uint)(CARRY4(temp6,temp6) || CARRY4(temp6 * 2,(uint)flag1)),\n                       temp6 * 2 + (uint)flag1);\n    }\n    input_4 = temp2 & 0x80000000 | (int)((ulonglong)result_2 >> 0x20) << 0xb | (uint)result_2 >> 0x15;\n    input_3 = (uint)result_2 << 0xb | temp7 >> 0x15;\n    temp6 = temp7 * 0x800;\n    flag2 = 0xfc < temp4;\n    flag3 = SBORROW4(temp4,0xfd);\n    temp1 = temp4 - 0xfd;\n    flag1 = temp1 == 0;\n    temp2 = temp1;\n    if (flag2 && !flag1) {\n      flag2 = 0x6ff < temp1;\n      flag3 = SBORROW4(temp1,0x700);\n      temp2 = temp4 - 0x7fd;\n      flag1 = temp1 == 0x700;\n    }\n    if (!flag2 || flag1) {\n      flag1 = 0x7fffffff < temp6;\n      if (temp6 == 0x80000000) {\n        flag1 = (temp7 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(input_4 + temp4 * 0x100000 + (uint)CARRY4(input_3,(uint)flag1),input_3 + flag1\n                     );\n    }\n  }\n  if (!flag1 && (int)temp2 < 0 == flag3) {\n    return (ulonglong)(input_4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag2 = SCARRY4(temp4,0x36);\n  flag1 = (int)(temp4 + 0x36) < 0;\n  flag3 = temp4 == 0xffffffca;\n  if (flag3 || flag1 != flag2) {\n    input_3 = 0;\n  }\n  if (flag3 || flag1 != flag2) {\n    input_4 = input_4 & 0x80000000;\n  }\n  if (flag3 || flag1 != flag2) {\n    return CONCAT44(input_4,input_3);\n  }\n  temp2 = -temp4;\n  temp1 = temp2 - 0x20;\n  if (0x1f < (int)temp2) {\n    temp4 = input_3 >> (temp1 & 0xff) | input_4 << (0x20 - temp1 & 0xff);\n    temp2 = (input_4 >> (temp1 & 0xff) & ~((input_4 & 0x80000000) >> (temp1 & 0xff))) -\n            ((int)temp4 >> 0x1f);\n    if ((temp6 | input_3 << (0x20 - temp1 & 0xff) | temp4 << 1) == 0) {\n      temp2 = temp2 & ~(temp4 >> 0x1f);\n    }\n    return CONCAT44(input_4,temp2) & 0x80000000ffffffff;\n  }\n  temp3 = temp2 - 0x14;\n  if (temp3 == 0 || temp3 < 0 != SCARRY4(temp1,0xc)) {\n    temp7 = input_3 << (temp4 + 0x20 & 0xff);\n    temp1 = input_3 >> (temp2 & 0xff) | input_4 << (temp4 + 0x20 & 0xff);\n    temp4 = temp1 + -((int)temp7 >> 0x1f);\n    if ((temp6 | temp7 << 1) == 0) {\n      temp4 = temp4 & ~(temp7 >> 0x1f);\n    }\n    return CONCAT44((input_4 & 0x80000000) +\n                    ((input_4 & 0x7fffffff) >> (temp2 & 0xff)) +\n                    (uint)CARRY4(temp1,-((int)temp7 >> 0x1f)),temp4);\n  }\n  temp2 = 0xc - temp3;\n  temp4 = input_3 << (temp2 & 0xff);\n  temp2 = input_3 >> (0x20 - temp2 & 0xff) | input_4 << (temp2 & 0xff);\n  temp1 = temp2 + -((int)temp4 >> 0x1f);\n  if ((temp6 | temp4 << 1) == 0) {\n    temp1 = temp1 & ~(temp4 >> 0x1f);\n  }\n  return CONCAT44((input_4 & 0x80000000) + (uint)CARRY4(temp2,-((int)temp4 >> 0x1f)),temp1);\n}\n\n",
            "renaming": {
                "FUN_080004f8": "calculate_result_080004f8",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "result_1",
                "lVar2": "result_2",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "iVar5": "temp3",
                "uVar6": "temp4",
                "unaff_r5": "temp5",
                "uVar7": "temp6",
                "uVar8": "temp7",
                "bVar9": "flag1",
                "bVar10": "flag2",
                "bVar11": "flag3",
                "uVar12": "combined_input"
            },
            "calling": [
                "SetTunings",
                "Compute",
                "readThermocouple",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [
                "FUN_080006d4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006d4": {
            "entrypoint": "0x080006d4",
            "current_name": "calculate_bitwise_result_080006d4",
            "code": "\nulonglong calculate_bitwise_result_080006d4(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint msb_input_1;\n  uint mask_1;\n  uint masked_input_4;\n  uint output_2;\n  uint constant_1;\n  bool is_zero;\n  \n  masked_input_4 = constant_1 & input_4 >> 0x14;\n  if (mask_1 != constant_1 && masked_input_4 != constant_1) {\n    is_zero = (input_1 | input_2 << 1) == 0;\n    if (!is_zero) {\n      is_zero = (input_3 | input_4 << 1) == 0;\n    }\n    if (is_zero) {\n      return (ulonglong)((input_2 ^ input_4) & 0x80000000) << 0x20;\n    }\n    if (mask_1 == 0) {\n      output_2 = input_2 & 0x80000000;\n      do {\n        msb_input_1 = input_1 & 0x80000000;\n        input_1 = input_1 << 1;\n        input_2 = input_2 * 2 + (uint)(msb_input_1 != 0);\n      } while ((input_2 & 0x100000) == 0);\n      input_2 = input_2 | output_2;\n      if (masked_input_4 != 0) {\n        return CONCAT44(input_2,input_1);\n      }\n    }\n    do {\n      masked_input_4 = input_3 & 0x80000000;\n      input_3 = input_3 << 1;\n      input_4 = input_4 * 2 + (uint)(masked_input_4 != 0);\n    } while ((input_4 & 0x100000) == 0);\n    return CONCAT44(input_2,input_1);\n  }\n  is_zero = (input_1 | input_2 << 1) == 0;\n  if (is_zero) {\n    input_2 = input_4;\n    input_1 = input_3;\n  }\n  if (!is_zero) {\n    is_zero = (input_3 | input_4 << 1) == 0;\n  }\n  output_2 = input_2;\n  if (((!is_zero) && ((mask_1 != constant_1 || ((input_1 | input_2 << 0xc) == 0)))) &&\n     ((masked_input_4 != constant_1 || (input_1 = input_3, output_2 = input_4, (input_3 | input_4 << 0xc) == 0)))) {\n    return (ulonglong)((input_2 ^ input_4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(output_2,input_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006d4": "calculate_bitwise_result_080006d4",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "msb_input_1",
                "unaff_r4": "mask_1",
                "uVar2": "masked_input_4",
                "uVar3": "output_2",
                "in_r12": "constant_1",
                "bVar4": "is_zero"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800074c": {
            "entrypoint": "0x0800074c",
            "current_name": "calculate_float_0800074c",
            "code": "\nulonglong calculate_float_0800074c(undefined4 floating_point_param_1,uint floating_point_param_2,uint floating_point_param_3,uint floating_point_param_4)\n\n{\n  uint result1;\n  uint result2;\n  uint result3;\n  uint result4;\n  uint result5;\n  uint result6;\n  uint result7;\n  int difference;\n  uint exponent1;\n  uint unaff_r5;\n  uint exponent2;\n  uint mantissa1;\n  uint difference_mantissa;\n  uint bit_mask;\n  bool is_equal;\n  bool is_zero;\n  bool overflow;\n  undefined8 converted_float;\n  \n  converted_float = CONCAT44(floating_point_param_2,floating_point_param_1);\n  bit_mask = 0x7ff;\n  result7 = floating_point_param_2 >> 0x14 & 0x7ff;\n  is_equal = result7 == 0;\n  if (!is_equal) {\n    unaff_r5 = floating_point_param_4 >> 0x14 & 0x7ff;\n    is_equal = unaff_r5 == 0;\n  }\n  if (!is_equal) {\n    is_equal = result7 == 0x7ff;\n  }\n  if (!is_equal) {\n    is_equal = unaff_r5 == 0x7ff;\n  }\n  if (is_equal) {\n    converted_float = convert_float_to_binary64_080008ba();\n  }\n  exponent1 = (uint)((ulonglong)converted_float >> 0x20);\n  mantissa1 = (uint)converted_float;\n  difference = result7 - unaff_r5;\n  if ((floating_point_param_3 | floating_point_param_4 << 0xc) == 0) {\n    result7 = (exponent1 ^ floating_point_param_4) & 0x80000000 | exponent1 & 0xfffff;\n    overflow = SCARRY4(difference,bit_mask >> 1);\n    exponent1 = difference + (bit_mask >> 1);\n    is_equal = (int)exponent1 < 0;\n    is_zero = exponent1 == 0;\n    if (!is_zero && is_equal == overflow) {\n      overflow = SBORROW4(bit_mask,exponent1);\n      is_equal = (int)(bit_mask - exponent1) < 0;\n      is_zero = bit_mask == exponent1;\n    }\n    if (!is_zero && is_equal == overflow) {\n      result7 = result7 | exponent1 * 0x100000;\n    }\n    if (!is_zero && is_equal == overflow) {\n      return CONCAT44(result7,mantissa1);\n    }\n    result7 = result7 | 0x100000;\n    bit_mask = 0;\n    is_zero = SBORROW4(exponent1,1);\n    exponent1 = exponent1 - 1;\n    is_equal = exponent1 == 0;\n    result3 = exponent1;\n  }\n  else {\n    result3 = (floating_point_param_4 << 0xc) >> 4 | 0x10000000 | floating_point_param_3 >> 0x18;\n    bit_mask = floating_point_param_3 << 8;\n    exponent2 = (exponent1 << 0xc) >> 4 | 0x10000000 | mantissa1 >> 0x18;\n    mantissa1 = mantissa1 * 0x100;\n    result7 = (exponent1 ^ floating_point_param_4) & 0x80000000;\n    is_equal = result3 <= exponent2;\n    if (exponent2 == result3) {\n      is_equal = bit_mask <= mantissa1;\n    }\n    difference = difference + (uint)is_equal;\n    exponent1 = difference + 0x3fd;\n    if (is_equal == false) {\n      result3 = result3 >> 1;\n      bit_mask = (uint)((floating_point_param_3 >> 0x18 & 1) != 0) << 0x1f | bit_mask >> 1;\n    }\n    difference_mantissa = mantissa1 - bit_mask;\n    exponent2 = (exponent2 - result3) - (uint)(mantissa1 < bit_mask);\n    result4 = result3 >> 1;\n    result1 = (uint)((result3 & 1) != 0) << 0x1f | bit_mask >> 1;\n    mantissa1 = 0x100000;\n    result3 = 0x80000;\n    while( true ) {\n      is_equal = result1 <= difference_mantissa;\n      if (result4 < exponent2 || exponent2 - result4 < (uint)is_equal) {\n        difference_mantissa = difference_mantissa - result1;\n        mantissa1 = mantissa1 | result3;\n        exponent2 = (exponent2 - result4) - (uint)!is_equal;\n      }\n      result5 = result4 >> 1;\n      result1 = (uint)((result4 & 1) != 0) << 0x1f | result1 >> 1;\n      is_zero = result1 <= difference_mantissa;\n      is_equal = exponent2 - result5 < (uint)is_zero;\n      bit_mask = exponent2;\n      if (result5 < exponent2 || is_equal) {\n        difference_mantissa = difference_mantissa - result1;\n        bit_mask = (exponent2 - result5) - (uint)!is_zero;\n      }\n      if (result5 < exponent2 || is_equal) {\n        mantissa1 = mantissa1 | result3 >> 1;\n      }\n      exponent2 = result4 >> 2;\n      result2 = (uint)((result5 & 1) != 0) << 0x1f | result1 >> 1;\n      is_zero = result2 <= difference_mantissa;\n      is_equal = bit_mask - exponent2 < (uint)is_zero;\n      result5 = bit_mask;\n      if (exponent2 < bit_mask || is_equal) {\n        difference_mantissa = difference_mantissa - result2;\n        result5 = (bit_mask - exponent2) - (uint)!is_zero;\n      }\n      if (exponent2 < bit_mask || is_equal) {\n        mantissa1 = mantissa1 | result3 >> 2;\n      }\n      result6 = result4 >> 3;\n      result1 = (uint)((exponent2 & 1) != 0) << 0x1f | result2 >> 1;\n      is_zero = result1 <= difference_mantissa;\n      is_equal = result5 - result6 < (uint)is_zero;\n      exponent2 = result5;\n      if (result6 < result5 || is_equal) {\n        difference_mantissa = difference_mantissa - result1;\n        exponent2 = (result5 - result6) - (uint)!is_zero;\n      }\n      if (result6 < result5 || is_equal) {\n        mantissa1 = mantissa1 | result3 >> 3;\n      }\n      bit_mask = exponent2 | difference_mantissa;\n      if (bit_mask == 0) break;\n      exponent2 = exponent2 << 4 | difference_mantissa >> 0x1c;\n      difference_mantissa = difference_mantissa << 4;\n      result4 = result4 & 0xfffffff8 | result1 >> 0x1d;\n      result1 = (result2 >> 1) << 3;\n      result3 = result3 >> 4;\n      if (result3 == 0) {\n        result6 = result4;\n        if ((result7 & 0x100000) != 0) goto LAB_0800086a;\n        result7 = result7 | mantissa1;\n        mantissa1 = 0;\n        result3 = 0x80000000;\n      }\n    }\n    if ((result7 & 0x100000) == 0) {\n      result7 = result7 | mantissa1;\n      mantissa1 = 0;\n    }\nLAB_0800086a:\n    overflow = 0xfc < exponent1;\n    is_zero = SBORROW4(exponent1,0xfd);\n    result4 = difference + 0x300;\n    is_equal = result4 == 0;\n    result3 = result4;\n    if (overflow && !is_equal) {\n      overflow = 0x6ff < result4;\n      is_zero = SBORROW4(result4,0x700);\n      result3 = difference - 0x400;\n      is_equal = result4 == 0x700;\n    }\n    if (!overflow || is_equal) {\n      is_equal = result6 <= exponent2;\n      if (exponent2 == result6) {\n        is_equal = result1 <= difference_mantissa;\n      }\n      if (exponent2 == result6 && difference_mantissa == result1) {\n        is_equal = (mantissa1 & 1) != 0;\n      }\n      return CONCAT44(result7 + exponent1 * 0x100000 + (uint)CARRY4(mantissa1,(uint)is_equal),mantissa1 + is_equal);\n    }\n  }\n  if (!is_equal && (int)result3 < 0 == is_zero) {\n    return (ulonglong)(result7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  overflow = SCARRY4(exponent1,0x36);\n  is_equal = (int)(exponent1 + 0x36) < 0;\n  is_zero = exponent1 == 0xffffffca;\n  if (is_zero || is_equal != overflow) {\n    mantissa1 = 0;\n  }\n  if (is_zero || is_equal != overflow) {\n    result7 = result7 & 0x80000000;\n  }\n  if (is_zero || is_equal != overflow) {\n    return CONCAT44(result7,mantissa1);\n  }\n  result3 = -exponent1;\n  exponent2 = result3 - 0x20;\n  if (0x1f < (int)result3) {\n    result3 = mantissa1 >> (exponent2 & 0xff) | result7 << (0x20 - exponent2 & 0xff);\n    exponent1 = (result7 >> (exponent2 & 0xff) & ~((result7 & 0x80000000) >> (exponent2 & 0xff))) -\n            ((int)result3 >> 0x1f);\n    if ((bit_mask | mantissa1 << (0x20 - exponent2 & 0xff) | result3 << 1) == 0) {\n      exponent1 = exponent1 & ~(result3 >> 0x1f);\n    }\n    return CONCAT44(result7,exponent1) & 0x80000000ffffffff;\n  }\n  difference = result3 - 0x14;\n  if (difference != 0 && difference < 0 == SCARRY4(exponent2,0xc)) {\n    exponent1 = 0xc - difference;\n    result3 = mantissa1 << (exponent1 & 0xff);\n    mantissa1 = mantissa1 >> (0x20 - exponent1 & 0xff) | result7 << (exponent1 & 0xff);\n    exponent1 = mantissa1 + -((int)result3 >> 0x1f);\n    if ((bit_mask | result3 << 1) == 0) {\n      exponent1 = exponent1 & ~(result3 >> 0x1f);\n    }\n    return CONCAT44((result7 & 0x80000000) + (uint)CARRY4(mantissa1,-((int)result3 >> 0x1f)),exponent1);\n  }\n  exponent2 = mantissa1 << (exponent1 + 0x20 & 0xff);\n  mantissa1 = mantissa1 >> (result3 & 0xff) | result7 << (exponent1 + 0x20 & 0xff);\n  exponent1 = mantissa1 + -((int)exponent2 >> 0x1f);\n  if ((bit_mask | exponent2 << 1) == 0) {\n    exponent1 = exponent1 & ~(exponent2 >> 0x1f);\n  }\n  return CONCAT44((result7 & 0x80000000) +\n                  ((result7 & 0x7fffffff) >> (result3 & 0xff)) +\n                  (uint)CARRY4(mantissa1,-((int)exponent2 >> 0x1f)),exponent1);\n}\n\n",
            "renaming": {
                "FUN_0800074c": "calculate_float_0800074c",
                "param_1": "floating_point_param_1",
                "param_2": "floating_point_param_2",
                "param_3": "floating_point_param_3",
                "param_4": "floating_point_param_4",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "result3",
                "uVar4": "result4",
                "uVar5": "result5",
                "uVar6": "result6",
                "uVar7": "result7",
                "iVar8": "difference",
                "uVar9": "exponent1",
                "uVar10": "exponent2",
                "uVar11": "mantissa1",
                "uVar12": "difference_mantissa",
                "uVar13": "bit_mask",
                "bVar14": "is_equal",
                "bVar15": "is_zero",
                "bVar16": "overflow",
                "uVar17": "converted_float"
            },
            "calling": [
                "SetTunings",
                "readThermocouple",
                "printFloat",
                "SetSampleTime"
            ],
            "called": [
                "FUN_080008ba"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008ba": {
            "entrypoint": "0x080008ba",
            "current_name": "convert_float_to_binary64_080008ba",
            "code": "\nulonglong convertFloatToBinary64_080008ba(uint exponentBits,uint mantissaBits,uint exponentBitsTemp,uint signBit)\n\n{\n  uint bit1;\n  uint exponentBitsTest;\n  uint exponentBitsShifted;\n  uint mantissaBitsTemp;\n  uint exponentBitsConstant;\n  bool isBitShifted;\n  \n  exponentBitsShifted = exponentBitsConstant & signBit >> 0x14;\n  mantissaBitsTemp = mantissaBits;\n  if (exponentBitsTest != exponentBitsConstant || exponentBitsShifted != exponentBitsConstant) {\n    if (exponentBitsTest == exponentBitsConstant) {\n      if (((exponentBits | mantissaBits << 0xc) == 0) && (exponentBits = exponentBitsTemp, mantissaBitsTemp = signBit, exponentBitsShifted != exponentBitsConstant)\n         ) {\nLAB_0800072c:\n        return (ulonglong)((mantissaBits ^ signBit) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (exponentBitsShifted == exponentBitsConstant) {\n      exponentBits = exponentBitsTemp;\n      mantissaBitsTemp = signBit;\n      if ((exponentBitsTemp | signBit << 0xc) == 0) {\nLAB_080006f0:\n        return (ulonglong)((mantissaBits ^ signBit) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      isBitShifted = (exponentBits | mantissaBits << 1) == 0;\n      if (!isBitShifted) {\n        isBitShifted = (exponentBitsTemp | signBit << 1) == 0;\n      }\n      if (!isBitShifted) {\n        if (exponentBitsTest == 0) {\n          mantissaBitsTemp = mantissaBits & 0x80000000;\n          do {\n            bit1 = exponentBits & 0x80000000;\n            exponentBits = exponentBits << 1;\n            mantissaBits = mantissaBits * 2 + (uint)(bit1 != 0);\n          } while ((mantissaBits & 0x100000) == 0);\n          mantissaBits = mantissaBits | mantissaBitsTemp;\n          if (exponentBitsShifted != 0) {\n            return CONCAT44(mantissaBits,exponentBits);\n          }\n        }\n        do {\n          mantissaBitsTemp = exponentBitsTemp & 0x80000000;\n          exponentBitsTemp = exponentBitsTemp << 1;\n          signBit = signBit * 2 + (uint)(mantissaBitsTemp != 0);\n        } while ((signBit & 0x100000) == 0);\n        return CONCAT44(mantissaBits,exponentBits);\n      }\n      if ((exponentBits | mantissaBits << 1) != 0) goto LAB_0800072c;\n      if ((exponentBitsTemp | signBit << 1) != 0) goto LAB_080006f0;\n    }\n  }\n  return CONCAT44(mantissaBitsTemp,exponentBits) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080008ba": "convert_float_to_binary64_080008ba",
                "param_1": "exponentBits",
                "param_2": "mantissaBits",
                "param_3": "exponentBitsTemp",
                "param_4": "signBit",
                "uVar1": "bit1",
                "unaff_r4": "exponentBitsTest",
                "uVar2": "exponentBitsShifted",
                "uVar3": "mantissaBitsTemp",
                "in_r12": "exponentBitsConstant",
                "bVar4": "isBitShifted"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800091c": {
            "entrypoint": "0x0800091c",
            "current_name": "check_parameters_0800091c",
            "code": "\nuint check_parameters_0800091c(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint xor_result;\n  bool is_zero;\n  bool is_negative;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  is_zero = (value1 | value2 << 1) == 0;\n  if (is_zero) {\n    is_zero = (value3 | value4 << 1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = value2 == value4;\n  }\n  if (is_zero) {\n    is_zero = value1 == value3;\n  }\n  if (!is_zero) {\n    xor_result = value2 ^ value4;\n    is_zero = xor_result == 0;\n    if (-1 < (int)xor_result) {\n      is_zero = value2 == value4;\n    }\n    is_negative = -1 < (int)xor_result && value4 <= value2;\n    if (is_zero) {\n      is_negative = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!is_negative) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800091c": "check_parameters_0800091c",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "xor_result",
                "bVar2": "is_zero",
                "bVar3": "is_negative"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000924": {
            "entrypoint": "0x08000924",
            "current_name": "check_parameters_08000924",
            "code": "\nuint check_parameters_08000924(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint result;\n  bool isZero;\n  bool isNegative;\n  \n  if (((int)(input2 << 1) >> 0x15 == -1 || (int)(input4 << 1) >> 0x15 == -1) &&\n     ((((int)(input2 << 1) >> 0x15 == -1 && ((input1 | input2 << 0xc) != 0)) ||\n      (((int)(input4 << 1) >> 0x15 == -1 && ((input3 | input4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (input1 | input2 << 1) == 0;\n  if (isZero) {\n    isZero = (input3 | input4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = input2 == input4;\n  }\n  if (isZero) {\n    isZero = input1 == input3;\n  }\n  if (!isZero) {\n    result = input2 ^ input4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = input2 == input4;\n    }\n    isNegative = -1 < (int)result && input4 <= input2;\n    if (isZero) {\n      isNegative = input3 <= input1;\n    }\n    input4 = (int)input4 >> 0x1f;\n    if (!isNegative) {\n      input4 = ~input4;\n    }\n    return input4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08000924": "check_parameters_08000924",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isNegative"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800092c": {
            "entrypoint": "0x0800092c",
            "current_name": "check_collision_0800092c",
            "code": "\nuint check_collision_0800092c(uint value_1,uint value_2,uint value_3,uint value_4)\n\n{\n  uint temp;\n  bool isZero;\n  bool isNegative;\n  \n  if (((int)(value_2 << 1) >> 0x15 == -1 || (int)(value_4 << 1) >> 0x15 == -1) &&\n     ((((int)(value_2 << 1) >> 0x15 == -1 && ((value_1 | value_2 << 0xc) != 0)) ||\n      (((int)(value_4 << 1) >> 0x15 == -1 && ((value_3 | value_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (value_1 | value_2 << 1) == 0;\n  if (isZero) {\n    isZero = (value_3 | value_4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = value_2 == value_4;\n  }\n  if (isZero) {\n    isZero = value_1 == value_3;\n  }\n  if (!isZero) {\n    temp = value_2 ^ value_4;\n    isZero = temp == 0;\n    if (-1 < (int)temp) {\n      isZero = value_2 == value_4;\n    }\n    isNegative = -1 < (int)temp && value_4 <= value_2;\n    if (isZero) {\n      isNegative = value_3 <= value_1;\n    }\n    value_4 = (int)value_4 >> 0x1f;\n    if (!isNegative) {\n      value_4 = ~value_4;\n    }\n    return value_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800092c": "check_collision_0800092c",
                "param_1": "value_1",
                "param_2": "value_2",
                "param_3": "value_3",
                "param_4": "value_4",
                "uVar1": "temp",
                "bVar2": "isZero",
                "bVar3": "isNegative"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009a8": {
            "entrypoint": "0x080009a8",
            "current_name": "compare_floats_080009a8",
            "code": "\nvoid compareFloats_080009a8(undefined4 result,undefined4 flag,undefined4 param_3,undefined4 param_4)\n\n{\n  __aeabi_cdcmpeq(param_3,param_4,result,flag);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080009a8": "compare_floats_080009a8",
                "param_1": "result",
                "param_2": "flag"
            },
            "calling": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009b8": {
            "entrypoint": "0x080009b8",
            "current_name": "calculate_080009b8",
            "code": "\nundefined4 calculate_080009b8(undefined4 input)\n\n{\n  performCalculation();\n  return input;\n}\n\n",
            "renaming": {
                "FUN_080009b8": "calculate_080009b8",
                "param_1": "input",
                "__eqdf2": "performCalculation"
            },
            "calling": [
                "__aeabi_dcmpeq",
                "__aeabi_cdrcmple",
                "__aeabi_dcmplt",
                "__aeabi_dcmple"
            ],
            "called": [
                "__eqdf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c8": {
            "entrypoint": "0x080009c8",
            "current_name": "check_if_cdcmpeq_returns_true_080009c8",
            "code": "\nbool check_if_cdcmpeq_returns_true_080009c8(void)\n\n{\n  char is_not_zero;\n  \n  __aeabi_cdcmpeq();\n  return is_not_zero != '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009c8": "check_if_cdcmpeq_returns_true_080009c8",
                "in_ZR": "is_not_zero"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009dc": {
            "entrypoint": "0x080009dc",
            "current_name": "check_if_null_value_080009dc",
            "code": "\nbool check_if_null_value_080009dc(void)\n\n{\n  char input_character;\n  \n  __aeabi_cdcmpeq();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009dc": "check_if_null_value_080009dc",
                "in_CY": "input_character"
            },
            "calling": [
                "SetOutputLimits",
                "Initialize",
                "loop",
                "SetTunings",
                "Compute",
                "printFloat"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009f0": {
            "entrypoint": "0x080009f0",
            "current_name": "check_equality_080009f0",
            "code": "\nbool check_equality_080009f0(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_set;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)is_carry_set || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_080009f0": "check_equality_080009f0",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_set"
            },
            "calling": [
                "loop",
                "printFloat"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a04": {
            "entrypoint": "0x08000a04",
            "current_name": "check_comparison_result_08000a04",
            "code": "\nbool check_comparison_result_08000a04(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_set;\n  \n  __aeabi_cdrcmple();\n  return !(bool)is_carry_set || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_08000a04": "check_comparison_result_08000a04",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_set"
            },
            "calling": [
                "SetOutputLimits",
                "loop"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a18": {
            "entrypoint": "0x08000a18",
            "current_name": "is_char_null_08000a18",
            "code": "\nbool isCharNull_08000a18(void)\n\n{\n  char inputChar;\n  \n  __aeabi_cdrcmple();\n  return inputChar == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000a18": "is_char_null_08000a18",
                "in_CY": "inputChar"
            },
            "calling": [
                "SetOutputLimits",
                "Initialize",
                "loop",
                "Compute",
                "printFloat"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a2c": {
            "entrypoint": "0x08000a2c",
            "current_name": "check_parameters_08000a2c",
            "code": "\nundefined4 check_parameters_08000a2c(uint input1,int input2,uint input3,int input4)\n\n{\n  if ((((input2 << 1) >> 0x15 != -1) || ((input1 | input2 << 0xc) == 0)) &&\n     (((input4 << 1) >> 0x15 != -1 || ((input3 | input4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08000a2c": "check_parameters_08000a2c",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4"
            },
            "calling": [
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a58": {
            "entrypoint": "0x08000a58",
            "current_name": "apply_conversions_08000a58",
            "code": "\nuint applyConversions_08000a58(uint inputValue,uint multiplier)\n\n{\n  uint shiftedValue;\n  int modifiedMultiplier;\n  uint adjustedShift;\n  \n  modifiedMultiplier = multiplier * 2 + 0x200000;\n  if (multiplier * 2 < 0xffe00000) {\n    if (-1 < modifiedMultiplier) {\n      return 0;\n    }\n    shiftedValue = modifiedMultiplier >> 0x15;\n    adjustedShift = -shiftedValue - 0x3e1;\n    if (shiftedValue < 0xfffffc20 && adjustedShift != 0) {\n      shiftedValue = (multiplier << 0xb | 0x80000000 | inputValue >> 0x15) >> (adjustedShift & 0xff);\n      if ((multiplier & 0x80000000) != 0) {\n        shiftedValue = -shiftedValue;\n      }\n      return shiftedValue;\n    }\n  }\n  else if ((inputValue | multiplier << 0xc) != 0) {\n    return 0;\n  }\n  multiplier = multiplier & 0x80000000;\n  if (multiplier == 0) {\n    multiplier = 0x7fffffff;\n  }\n  return multiplier;\n}\n\n",
            "renaming": {
                "FUN_08000a58": "apply_conversions_08000a58",
                "param_1": "inputValue",
                "param_2": "multiplier",
                "uVar1": "shiftedValue",
                "iVar2": "modifiedMultiplier",
                "uVar3": "adjustedShift"
            },
            "calling": [
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa8": {
            "entrypoint": "0x08000aa8",
            "current_name": "calculate_shift_amount_08000aa8",
            "code": "\nuint calculate_shift_amount_08000aa8(uint input_parameter_1,uint input_parameter_2)\n\n{\n  int shifted_value;\n  uint shift_amount;\n  \n  if ((input_parameter_2 & 0x80000000) != 0) {\n    return 0;\n  }\n  shifted_value = input_parameter_2 * 2 + 0x200000;\n  if (input_parameter_2 * 2 < 0xffe00000) {\n    if (-1 < shifted_value) {\n      return 0;\n    }\n    shift_amount = -(shifted_value >> 0x15) - 0x3e1;\n    if (-1 < (int)shift_amount) {\n      return (input_parameter_2 << 0xb | 0x80000000 | input_parameter_1 >> 0x15) >> (shift_amount & 0xff);\n    }\n  }\n  else if ((input_parameter_1 | input_parameter_2 << 0xc) != 0) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000aa8": "calculate_shift_amount_08000aa8",
                "param_1": "input_parameter_1",
                "param_2": "input_parameter_2",
                "iVar1": "shifted_value",
                "uVar2": "shift_amount"
            },
            "calling": [
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ae8": {
            "entrypoint": "0x08000ae8",
            "current_name": "software_interrupt_handler_08000ae8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t software_interrupt_handler_08000ae8(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_08000ae8": "software_interrupt_handler_08000ae8"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aec": {
            "entrypoint": "0x08000aec",
            "current_name": "call_afl_with_ticks_08000aec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint call_afl_with_ticks_08000aec(int ticks)\n\n{\n  uint32_t call_result;\n  \n  if (hyper_call_disabled != 0) {\n    return 0;\n  }\n  call_result = aflCall(1,ticks,0);\n  return call_result;\n}\n\n",
            "renaming": {
                "FUN_08000aec": "call_afl_with_ticks_08000aec",
                "noHyperCall": "hyper_call_disabled",
                "uVar1": "call_result"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b08": {
            "entrypoint": "0x08000b08",
            "current_name": "initialize_peripherals_08000b08",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePeripherals_08000b08(int initializeFlag,int priority)\n\n{\n  if ((initializeFlag == 1) && (priority == 0xffff)) {\n    PID::PID(&pidController,&inputSignal,&outputSignal,&desiredValue,(double)combineValues(proportionalGainHigher,proportionalGainLower),\n             (double)combineValues(integralGainHigher,integralGainLower),(double)combineValues(derivativeGainHigher,derivativeGainLower),0);\n    LiquidCrystal::LiquidCrystal\n              (&lcdController,(uint8_t)lcdRsPinNumber,(uint8_t)lcdEPinNumber,(uint8_t)lcdD4PinNumber,(uint8_t)lcdD5PinNumber,\n               (uint8_t)lcdD6PinNumber,(uint8_t)lcdD7PinNumber);\n    thermocoupleReader::thermocoupleReader(&thermocoupleData,(uchar)thermocoupleSOPinNumber,(uchar)thermocoupleCSPinNumber,\n                       (uchar)thermocoupleCLKPinNumber);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000b08": "initialize_peripherals_08000b08",
                "__initialize_p": "initializeFlag",
                "__priority": "priority",
                "reflowOvenPID": "pidController",
                "input": "inputSignal",
                "output": "outputSignal",
                "setpoint": "desiredValue",
                "CONCAT44": "combineValues",
                "kp._4_4_": "proportionalGainHigher",
                "kp._0_4_": "proportionalGainLower",
                "ki._4_4_": "integralGainHigher",
                "ki._0_4_": "integralGainLower",
                "kd._4_4_": "derivativeGainHigher",
                "kd._0_4_": "derivativeGainLower",
                "lcd": "lcdController",
                "lcdRsPin": "lcdRsPinNumber",
                "lcdEPin": "lcdEPinNumber",
                "lcdD4Pin": "lcdD4PinNumber",
                "lcdD5Pin": "lcdD5PinNumber",
                "lcdD6Pin": "lcdD6PinNumber",
                "lcdD7Pin": "lcdD7PinNumber",
                "MAX31855": "thermocoupleReader",
                "thermocouple": "thermocoupleData",
                "thermocoupleSOPin": "thermocoupleSOPinNumber",
                "thermocoupleCSPin": "thermocoupleCSPinNumber",
                "thermocoupleCLKPin": "thermocoupleCLKPinNumber"
            },
            "calling": [
                "_GLOBAL__sub_I_lcdMessagesReflowStatus"
            ],
            "called": [
                "MAX31855",
                "LiquidCrystal",
                "PID"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000bcc": {
            "entrypoint": "0x08000bcc",
            "current_name": "initialize_oven_08000bcc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeOven_08000bcc(void)\n\n{\n  digitalWrite(temperatureControlPin,0);\n  pinMode(temperatureControlPin,1);\n  digitalWrite(buzzerPin,0);\n  pinMode(buzzerPin,1);\n  digitalWrite(statusLedPin,0);\n  pinMode(statusLedPin,1);\n  digitalWrite(buzzerPin,1);\n  LiquidCrystal::begin(&display,'\\b','\\x02','\\0');\n  LiquidCrystal::createChar(&display,'\\0',customCharacter);\n  LiquidCrystal::clear(&display);\n  printer::print(&display.super_printer,\"Reflow\");\n  LiquidCrystal::setCursor(&display,'\\0','\\x01');\n  printer::print(&display.super_printer,\"Oven 1.2\");\n  digitalWrite(buzzerPin,0);\n  delay(0x9c4);\n  LiquidCrystal::clear(&display);\n  HardwareSerial::begin(&Serial2,0xe100,'\\x06');\n  digitalWrite(statusLedPin,1);\n  bufferSize = 2000;\n  nextCheckTime = millis();\n  nextReadTime = millis();\n  startServer(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000bcc": "initialize_oven_08000bcc",
                "ssrPin": "temperatureControlPin",
                "ledRedPin": "statusLedPin",
                "lcd": "display",
                "degree": "customCharacter",
                "Print": "printer",
                "windowSize": "bufferSize",
                "nextCheck": "nextCheckTime",
                "nextRead": "nextReadTime",
                "startForkserver": "startServer"
            },
            "calling": [
                "main"
            ],
            "called": [
                "begin",
                "digitalWrite",
                "startForkserver",
                "delay",
                "setCursor",
                "print",
                "begin",
                "millis",
                "createChar",
                "pinMode",
                "clear"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cbc": {
            "entrypoint": "0x08000cbc",
            "current_name": "initialize_static_variables_08000cbc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_variables_08000cbc(void)\n\n{\n  initialize_destructor(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000cbc": "initialize_static_variables_08000cbc",
                "__static_initialization_and_destruction_0": "initialize_destructor"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cd0": {
            "entrypoint": "0x08000cd0",
            "current_name": "reflow_controller_08000cd0",
            "code": "\n/* WARNING: UnkcurrentMillisn calling convention */\n\nvoid reflowController_08000cd0(void)\n\n{\n  double dVar1;\n  uint32_t millisValue;\n  MAX31855 *thermocouplePtr;\n  int redLedState;\n  ulong currentMillis;\n  int comparisonResult;\n  size_t readResult;\n  int digitsValue;\n  int digitsValue_00;\n  int digitsValue_01;\n  size_t writeResult;\n  undefined4 unaffVar4;\n  undefined4 unaffVar5;\n  undefined8 floatConversion;\n  undefined4 stackVar1;\n  undefined4 stackVar2;\n  undefined4 stackVar3;\n  \n  millisValue = millis();\n  if (nextReadTime < millisValue) {\n    nextReadTime = nextReadTime + 1000;\n    thermocouplePtr = &thermocouple;\n    MAX31855::readThermocouple(&thermocouple,tempTypeCelsius);\n    temperatureInput._0_4_ = thermocouplePtr;\n    temperatureInput._4_4_ = readResult;\n    comparisonResult = __aeabi_dcmpeq();\n    if (((comparisonResult != 0) || (comparisonResult = __aeabi_dcmpeq(thermocouplePtr,readResult,0,0x40c38880), comparisonResult != 0)) ||\n       (comparisonResult = __aeabi_dcmpeq(thermocouplePtr,readResult,0,0x40c38900), comparisonResult != 0)) {\n      currentState = REFLOW_STATE_ERROR;\n      currentStatus = REFLOW_STATUS_OFF;\n    }\n  }\n  millisValue = millis();\n  comparisonResult = redLedPin;\n  if (nextCheckTime < millisValue) {\n    nextCheckTime = nextCheckTime + 1000;\n    if (currentStatus == REFLOW_STATUS_ON) {\n      redLedState = digitalRead(redLedPin);\n      digitalWrite(comparisonResult,(uint)(redLedState == 0));\n      timerSeconds = timerSeconds + 1;\n      Print::print((Print *)&serialDisplay,timerSeconds,10);\n      Print::print((Print *)&serialDisplay,\" \");\n      Print::print((Print *)&serialDisplay,(double)CONCAT44(stackVar1,2),digitsValue);\n      Print::print((Print *)&serialDisplay,\" \");\n      Print::print((Print *)&serialDisplay,(double)CONCAT44(stackVar1,2),digitsValue_00);\n      Print::print((Print *)&serialDisplay,\" \");\n      Print::println((Print *)&serialDisplay,(double)CONCAT44(stackVar1,2),digitsValue_01);\n    }\n    else {\n      digitalWrite(redLedPin,1);\n    }\n    LiquidCrystal::clear(&lcdDisplay);\n    Print::print(&lcdDisplay.super_Print,lcdDisplayMessagesReflowStatus[currentState]);\n    LiquidCrystal::setCursor(&lcdDisplay,'\\0','\\x01');\n    if (currentState == REFLOW_STATE_ERROR) {\n      Print::print(&lcdDisplay.super_Print,\"TC Error!\");\n    }\n    else {\n      thermocouplePtr = temperatureInput._0_4_;\n      writeResult = temperatureInput._4_4_;\n      Print::print(&lcdDisplay.super_Print,(double)CONCAT44(stackVar1,2),2);\n      LiquidCrystal::write(&lcdDisplay,0,thermocouplePtr,writeResult);\n      Print::print(&lcdDisplay.super_Print,\"C \");\n    }\n  }\n  writeResult = temperatureInput._4_4_;\n  thermocouplePtr = temperatureInput._0_4_;\n  setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n  switch(currentState) {\n  case REFLOW_STATE_IDLE:\n    comparisonResult = __aeabi_dcmpge(temperatureInput._0_4_,temperatureInput._4_4_,0,0x40490000);\n    if (comparisonResult == 0) {\n      if (currentSwitchStatus == SWITCH_1) {\n        Print::println((Print *)&serialDisplay,\"Time Setpoint Input Output\");\n        timerSeconds = 0;\n        windowStartTime = millis();\n        setpoint._0_4_ = 0;\n        setpoint._4_4_ = 0x4062c000;\n        dVar1 = (double)__floatsidf(windowPeriod);\n        setPIDOutputLimits\n                  (&ovenPID,dVar1,(double)CONCAT44(stackVar3,stackVar2));\n        setPIDSampleTime(&ovenPID,1000);\n        setPIDMode(&ovenPID,1);\n        currentState = REFLOW_STATE_PREHEAT;\n      }\n    }\n    else {\n      currentState = REFLOW_STATE_TOO_HOT;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_PREHEAT:\n    currentStatus = REFLOW_STATUS_ON;\n    comparisonResult = __aeabi_dcmpge(temperatureInput._0_4_,temperatureInput._4_4_,0,0x4062c000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (comparisonResult != 0) {\n      millisValue = millis();\n      timerSoak = millisValue + 9000;\n      setPIDTunings(&ovenPID,0.05,250.0,(double)CONCAT44(unaffVar5,unaffVar4));\n      currentState = REFLOW_STATE_SOAK;\n      setpoint = 155.0;\n    }\n    break;\n  case REFLOW_STATE_SOAK:\n    millisValue = millis();\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (timerSoak < millisValue) {\n      millisValue = millis();\n      timerSoak = millisValue + 9000;\n      setpoint = (double)__aeabi_dadd(setpoint._0_4_,setpoint._4_4_,0,0x40140000);\n      comparisonResult = __aeabi_dcmpgt(SUB84(setpoint,0),(int)((ulonglong)setpoint >> 0x20),0,0x40690000);\n      if (comparisonResult != 0) {\n        setPIDTunings(&ovenPID,0.05,350.0,(double)CONCAT44(unaffVar5,unaffVar4));\n        currentState = REFLOW_STATE_REFLOW;\n        setpoint = 250.0;\n      }\n    }\n    break;\n  case REFLOW_STATE_REFLOW:\n    comparisonResult = __aeabi_dcmpge(temperatureInput._0_4_,temperatureInput._4_4_,0,0x406ea000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (comparisonResult != 0) {\n      setPIDTunings(&ovenPID,0.05,350.0,(double)CONCAT44(unaffVar5,unaffVar4));\n      currentState = REFLOW_STATE_COOL;\n      setpoint = 100.0;\n    }\n    break;\n  case REFLOW_STATE_COOL:\n    comparisonResult = __aeabi_dcmple(temperatureInput._0_4_,temperatureInput._4_4_,0,0x40590000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (comparisonResult != 0) {\n      millisValue = millis();\n      buzzerEndTime = millisValue + 1000;\n      digitalWrite(buzzerOutputPin,1);\n      currentStatus = REFLOW_STATUS_OFF;\n      currentState = REFLOW_STATE_COMPLETE;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_COMPLETE:\n    millisValue = millis();\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (buzzerEndTime < millisValue) {\n      digitalWrite(buzzerOutputPin,0);\n      currentState = REFLOW_STATE_IDLE;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_TOO_HOT:\n    comparisonResult = __aeabi_dcmplt(temperatureInput._0_4_,temperatureInput._4_4_,0,0x40490000);\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    if (comparisonResult != 0) {\n      currentState = REFLOW_STATE_IDLE;\n      setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n    }\n    break;\n  case REFLOW_STATE_ERROR:\n    comparisonResult = __aeabi_dcmpeq(temperatureInput._0_4_,temperatureInput._4_4_,0,0x40c38800);\n    if ((comparisonResult == 0) && (comparisonResult = __aeabi_dcmpeq(thermocouplePtr,writeResult,0,0x40c38880), comparisonResult == 0)) {\n      comparisonResult = __aeabi_dcmpeq(thermocouplePtr,writeResult,0,0x40c38900);\n      if (comparisonResult == 0) {\n        currentState = REFLOW_STATE_IDLE;\n        setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n        break;\n      }\n    }\n    currentState = REFLOW_STATE_ERROR;\n    setpoint = (double)CONCAT44(setpoint._4_4_,setpoint._0_4_);\n  }\n  if ((currentSwitchStatus == SWITCH_1) && (currentStatus == REFLOW_STATUS_ON)) {\n    currentStatus = REFLOW_STATUS_OFF;\n    currentState = REFLOW_STATE_IDLE;\n  }\n  if (currentDebounceState == checkDebounceState) {\n    millisValue = analogRead(switchInputPin);\n    if (millisValue == 0) {\n      millisValue = millis();\n      if (0x32 < millisValue - lastDebounceTime) {\n        currentDebounceState = releaseDebounceState;\n      }\n    }\n    else {\n      currentDebounceState = idleDebounceState;\n    }\n  }\n  else if (currentDebounceState == idleDebounceState) {\n    currentSwitchStatus = SWITCH_NONE;\n    millisValue = analogRead(switchInputPin);\n    if (millisValue == 0) {\n      lastDebounceTime = millis();\n      currentDebounceState = checkDebounceState;\n    }\n  }\n  else if (currentDebounceState == releaseDebounceState) {\n    millisValue = analogRead(switchInputPin);\n    if (millisValue != 0) {\n      currentSwitchStatus = SWITCH_1;\n      currentDebounceState = idleDebounceState;\n    }\n  }\n  if (currentStatus == REFLOW_STATUS_ON) {\n    millisValue = millis();\n    computePID(&ovenPID);\n    if ((uint)windowPeriod < millisValue - windowStartTime) {\n      windowStartTime = windowStartTime + windowPeriod;\n    }\n    floatConversion = __floatunsidf(millisValue - windowStartTime);\n    comparisonResult = __aeabi_dcmplt((int)floatConversion,(int)((ulonglong)floatConversion >> 0x20),output._0_4_,output._4_4_);\n    if (comparisonResult == 0) {\n      digitalWrite(ssrPin,0);\n      dVar1 = setpoint;\n    }\n    else {\n      digitalWrite(ssrPin,1);\n      dVar1 = setpoint;\n    }\n  }\n  else {\n    digitalWrite(ssrPin,0);\n    dVar1 = setpoint;\n  }\n  setpoint._4_4_ = (undefined4)((ulonglong)dVar1 >> 0x20);\n  setpoint._0_4_ = SUB84(dVar1,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000cd0": "reflow_controller_08000cd0",
                "uVar2": "millisValue",
                "pMVar3": "thermocouplePtr",
                "iVar4": "redLedState",
                "now": "currentMillis",
                "iVar5": "comparisonResult",
                "extraout_r1": "readResult",
                "digits": "digitsValue",
                "digits_00": "digitsValue_00",
                "digits_01": "digitsValue_01",
                "sVar6": "writeResult",
                "unaff_r4": "unaffVar4",
                "unaff_r5": "unaffVar5",
                "uVar7": "floatConversion",
                "in_stack_ffffffe4": "stackVar1",
                "in_stack_ffffffe8": "stackVar2",
                "in_stack_ffffffec": "stackVar3",
                "nextRead": "nextReadTime",
                "nextCheck": "nextCheckTime",
                "reflowState": "currentState",
                "reflowStatus": "currentStatus",
                "ledRedPin": "redLedPin",
                "reflowOvenPID": "ovenPID",
                "input": "temperatureInput",
                "CELSIUS": "tempTypeCelsius",
                "windowSize": "windowPeriod",
                "PID::Compute": "computePID",
                "PID::SetTunings": "setPIDTunings",
                "PID::SetSampleTime": "setPIDSampleTime",
                "PID::SetMode": "setPIDMode",
                "PID::SetOutputLimits": "setPIDOutputLimits",
                "Serial2": "serialDisplay",
                "lcd": "lcdDisplay",
                "buzzerPeriod": "buzzerEndTime",
                "buzzerPin": "buzzerOutputPin",
                "switchPin": "switchInputPin",
                "switchStatus": "currentSwitchStatus",
                "debounceState": "currentDebounceState",
                "DEBOUNCE_STATE_CHECK": "checkDebounceState",
                "DEBOUNCE_STATE_IDLE": "idleDebounceState",
                "DEBOUNCE_STATE_RELEASE": "releaseDebounceState"
            },
            "calling": [
                "main"
            ],
            "called": [
                "SetOutputLimits",
                "write",
                "print",
                "setCursor",
                "analogRead",
                "millis",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "print",
                "__aeabi_dcmpeq",
                "println",
                "digitalRead",
                "__aeabi_dcmpge",
                "clear",
                "__aeabi_dcmple",
                "readThermocouple",
                "digitalWrite",
                "__floatsidf",
                "print",
                "Compute",
                "SetTunings",
                "SetSampleTime",
                "SetMode",
                "__floatunsidf",
                "__aeabi_dcmplt",
                "println"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001294": {
            "entrypoint": "0x08001294",
            "current_name": "set_row_offsets_08001294",
            "code": "\n/* DWARF original prototype: void  setRowOffsets_08001294(LiquidCrystal * lcd, int offset0, int offset1, int offset2,\n   int offset3) */\n\nvoid __lcdcall LiquidCrystal::setRowOffsets_08001294(LiquidCrystal *lcd,int offset0,int offset1,int offset2,int offset3)\n\n{\n  lcd->_row_offsets[0] = (uint8_t)offset0;\n  lcd->_row_offsets[1] = (uint8_t)offset1;\n  lcd->_row_offsets[2] = (uint8_t)offset2;\n  lcd->_row_offsets[3] = (uint8_t)offset3;\n  return;\n}\n\n",
            "renaming": {
                "this": "lcd",
                "row0": "offset0",
                "row1": "offset1",
                "row2": "offset2",
                "row3": "offset3",
                "FUN_08001294": "set_row_offsets_08001294"
            },
            "calling": [
                "begin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080012a2": {
            "entrypoint": "0x080012a2",
            "current_name": "pulse_enable_080012a2",
            "code": "\n/* DWARF original prototype: void  pulseEnable_080012a2(LiquidCrystal * lcd) */\n\nvoid __lcdcall LiquidCrystal::pulseEnable_080012a2(LiquidCrystal *lcd)\n\n{\n  digitalWrite((uint)lcd->enablePin,0);\n  digitalWrite((uint)lcd->enablePin,1);\n  digitalWrite((uint)lcd->enablePin,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080012a2": "pulse_enable_080012a2",
                "this": "lcd",
                "_enable_pin": "enablePin"
            },
            "calling": [
                "write4bits",
                "write8bits"
            ],
            "called": [
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080012c0": {
            "entrypoint": "0x080012c0",
            "current_name": "write4_bits_080012c0",
            "code": "\n/* DWARF original prototype: void  write4bits(LiquidCrystal * lcd, uint8_t bits) */\n\nvoid __lcdcall LiquidCrystal::write4Bits_080012c0(LiquidCrystal *lcd,uint8_t bits)\n\n{\n  uint bitIndex;\n  \n  for (bitIndex = 0; (int)bitIndex < 4; bitIndex = bitIndex + 1) {\n    digitalWrite((uint)lcd->_data_pins[bitIndex],(int)(uint)bits >> (bitIndex & 0xff) & 1);\n  }\n  pulseEnable(lcd);\n  return;\n}\n\n",
            "renaming": {
                "this": "lcd",
                "value": "bits",
                "uVar1": "bitIndex",
                "FUN_080012c0": "write4_bits_080012c0"
            },
            "calling": [
                "send",
                "begin"
            ],
            "called": [
                "digitalWrite",
                "pulseEnable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080012e8": {
            "entrypoint": "0x080012e8",
            "current_name": "write8bits_080012e8",
            "code": "\n/* DWARF original prototype: void  write8bits_080012e8(LCD * lcd, uint8_t data) */\n\nvoid __lcdcall LCD::write8bits_080012e8(LCD *lcd,uint8_t data)\n\n{\n  uint bitIndex;\n  \n  for (bitIndex = 0; (int)bitIndex < 8; bitIndex = bitIndex + 1) {\n    digitalWrite((uint)lcd->_data_pins[bitIndex],(int)(uint)data >> (bitIndex & 0xff) & 1);\n  }\n  pulseEnable(lcd);\n  return;\n}\n\n",
            "renaming": {
                "LiquidCrystal": "LCD",
                "this": "lcd",
                "value": "data",
                "uVar1": "bitIndex",
                "FUN_080012e8": "write8bits_080012e8"
            },
            "calling": [
                "send"
            ],
            "called": [
                "digitalWrite",
                "pulseEnable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001310": {
            "entrypoint": "0x08001310",
            "current_name": "send_08001310",
            "code": "\n/* DWARF original prototype: void  send_08001310(LCD * lcd, uint8_t value, uint8_t mode) */\n\nssize_t send_08001310\nLCD::send_08001310(LCD *lcd,int value,void *mode,size_t count,int flags)\n\n{\n  digitalWrite((uint)lcd->rs_pin,(uint32_t)mode);\n  if (lcd->rw_pin != 0xff) {\n    digitalWrite((uint)lcd->rw_pin,0);\n  }\n  if ((lcd->display_function & 0x10) == 0) {\n    write_4_bits(lcd,(uint8_t)((uint)value >> 4));\n    write_4_bits(lcd,(uint8_t)value);\n    return (ssize_t)lcd;\n  }\n  write_8_bits(lcd,(uint8_t)value);\n  return (ssize_t)lcd;\n}\n\n",
            "renaming": {
                "FUN_08001310": "send_08001310",
                "__thiscall": "send",
                "LiquidCrystal": "LCD",
                "this": "lcd",
                "__fd": "value",
                "__buf": "mode",
                "__n": "count",
                "__flags": "flags",
                "_rs_pin": "rs_pin",
                "_rw_pin": "rw_pin",
                "_displayfunction": "display_function",
                "write4bits": "write_4_bits",
                "write8bits": "write_8_bits"
            },
            "calling": [
                "write",
                "setCursor",
                "begin",
                "display",
                "createChar",
                "clear"
            ],
            "called": [
                "digitalWrite",
                "write4bits",
                "write8bits"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800134e": {
            "entrypoint": "0x0800134e",
            "current_name": "send_data_0800134e",
            "code": "\n/* DWARF original prototype: size_t  write(LiquidCrystal * lcd, uint8_t value) */\n\nssize_t __lcdcall LiquidCrystal::send_data_0800134e(LiquidCrystal *lcd,int file_descriptor,void *buffer,size_t size)\n\n{\n  send(lcd,file_descriptor,(void *)0x1,size,size);\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0800134e": "send_data_0800134e",
                "this": "lcd",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "size"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800135a": {
            "entrypoint": "0x0800135a",
            "current_name": "clear_display_0800135a",
            "code": "\n/* DWARF original prototype: void  clear(LiquidCrystal * lcd) */\n\nvoid __lcdcall LiquidCrystal::clearDisplay_0800135a(LiquidCrystal *lcd)\n\n{\n  size_t size;\n  \n  send(lcd,1,(void *)0x0,size,size);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800135a": "clear_display_0800135a",
                "this": "lcd",
                "in_r3": "size"
            },
            "calling": [
                "setup",
                "begin",
                "loop"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001366": {
            "entrypoint": "0x08001366",
            "current_name": "set_cursor_08001366",
            "code": "\n/* DWARF original prototype: void  setCursor_08001366(LiquidCrystal * lcd, uint8_t column, uint8_t row) */\n\nvoid __lcdcall LiquidCrystal::setCursor_08001366(LiquidCrystal *lcd,uint8_t column,uint8_t row)\n\n{\n  uint clampedRow;\n  int extraFlag;\n  \n  clampedRow = (uint)row;\n  if (3 < clampedRow) {\n    clampedRow = 3;\n  }\n  if (lcd->_numlines <= clampedRow) {\n    clampedRow = lcd->_numlines - 1 & 0xff;\n  }\n  send(lcd,(uint)(byte)(column + lcd->_row_offsets[clampedRow] | 0x80),(void *)0x0,\n       (uint)lcd->_row_offsets[clampedRow],extraFlag);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001366": "set_cursor_08001366",
                "this": "lcd",
                "col": "column",
                "uVar1": "clampedRow",
                "in_r3": "extraFlag"
            },
            "calling": [
                "setup",
                "loop"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800138e": {
            "entrypoint": "0x0800138e",
            "current_name": "initialize_display_0800138e",
            "code": "\n/* DWARF original prototype: void  display(LiquidCrystal * lcd) */\n\nvoid __lcdcall LiquidCrystal::initializeDisplay_0800138e(LiquidCrystal *lcd)\n\n{\n  byte displayControl;\n  size_t size;\n  \n  displayControl = lcd->_displaycontrol;\n  lcd->_displaycontrol = displayControl | 4;\n  sendData(lcd,displayControl | 0xc,(void *)0x0,size,size);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800138e": "initialize_display_0800138e",
                "this": "lcd",
                "bVar1": "displayControl",
                "in_r3": "size",
                "send": "sendData"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080013a4": {
            "entrypoint": "0x080013a4",
            "current_name": "initialize_lcd_080013a4",
            "code": "\n/* DWARF original prototype: void  begin(LiquidCrystal * lcd, uint8_t numCols, uint8_t numLines, uint8_t\n   dotSize) */\n\nvoid __lcdcall\nLiquidCrystal::initializeLCD_080013a4(LiquidCrystal *lcd,uint8_t numCols,uint8_t numLines,uint8_t dotSize)\n\n{\n  int rowOffset;\n  size_t numPins;\n  int pinIndex;\n  \n  if (1 < numLines) {\n    lcd->_displayfunction = lcd->_displayfunction | 8;\n  }\n  lcd->_numnumLines = numLines;\n  rowOffset = numCols + 0x40;\n  setRowOffsets(lcd,0,0x40,(uint)numCols,rowOffset);\n  if ((dotSize != '\\0') && (numLines == '\\x01')) {\n    lcd->_displayfunction = lcd->_displayfunction | 4;\n  }\n  pinMode((uint)lcd->_rs_pin,1);\n  if (lcd->_rw_pin != 0xff) {\n    pinMode((uint)lcd->_rw_pin,1);\n  }\n  pinMode((uint)lcd->_enable_pin,1);\n  pinIndex = 0;\n  while( true ) {\n    if ((lcd->_displayfunction & 0x10) == 0) {\n      numPins = 4;\n    }\n    else {\n      numPins = 8;\n    }\n    if ((int)numPins <= pinIndex) break;\n    pinMode((uint)lcd->_data_pins[pinIndex],1);\n    pinIndex = pinIndex + 1;\n  }\n  digitalWrite((uint)lcd->_rs_pin,0);\n  digitalWrite((uint)lcd->_enable_pin,0);\n  if (lcd->_rw_pin != 0xff) {\n    digitalWrite((uint)lcd->_rw_pin,0);\n  }\n  if ((lcd->_displayfunction & 0x10) == 0) {\n    write4bits(lcd,'\\x03');\n    write4bits(lcd,'\\x03');\n    write4bits(lcd,'\\x03');\n    write4bits(lcd,'\\x02');\n  }\n  else {\n    send(lcd,lcd->_displayfunction | 0x20,(void *)0x0,numPins,rowOffset);\n    send(lcd,lcd->_displayfunction | 0x20,(void *)0x0,numPins,rowOffset);\n    send(lcd,lcd->_displayfunction | 0x20,(void *)0x0,numPins,rowOffset);\n  }\n  send(lcd,lcd->_displayfunction | 0x20,(void *)0x0,numPins,rowOffset);\n  lcd->_displaycontrol = '\\x04';\n  display(lcd);\n  clear(lcd);\n  lcd->_displaymode = '\\x02';\n  send(lcd,6,(void *)0x0,2,rowOffset);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080013a4": "initialize_lcd_080013a4",
                "this": "lcd",
                "cols": "numCols",
                "lines": "numLines",
                "dotsize": "dotSize",
                "row3": "rowOffset",
                "__n": "numPins",
                "iVar1": "pinIndex"
            },
            "calling": [
                "setup",
                "init"
            ],
            "called": [
                "digitalWrite",
                "send",
                "display",
                "pinMode",
                "clear",
                "setRowOffsets",
                "write4bits"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014ba": {
            "entrypoint": "0x080014ba",
            "current_name": "initialize_lcd_080014ba",
            "code": "\n/* DWARF original prototype: void  init(LiquidCrystal * lcdObj, uint8_t fourbitmode, uint8_t rs,\n   uint8_t rw, uint8_t enable, uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3, uint8_t d4, uint8_t\n   d5, uint8_t d6, uint8_t d7) */\n\nint __lcdObjcall LiquidCrystal::initializeLCD_080014ba(LiquidCrystal *lcdObj,EVP_PKEY_CTX *evpContext)\n\n{\n  uint8_t rsPin;\n  uint8_t rwPin;\n  uint8_t enablePin;\n  uint8_t dataPin0;\n  uint8_t dataPin1;\n  uint8_t dataPin2;\n  uint8_t dataPin3;\n  uint8_t dataPin4;\n  uint8_t dataPin5;\n  uint8_t dataPin6;\n  uint8_t dataPin7;\n  \n  lcdObj->_rs_pin = rsPin;\n  lcdObj->_rw_pin = rwPin;\n  lcdObj->_enable_pin = enablePin;\n  lcdObj->_data_pins[0] = dataPin0;\n  lcdObj->_data_pins[1] = dataPin1;\n  lcdObj->_data_pins[2] = dataPin2;\n  lcdObj->_data_pins[3] = dataPin3;\n  lcdObj->_data_pins[4] = dataPin4;\n  lcdObj->_data_pins[5] = dataPin5;\n  lcdObj->_data_pins[6] = dataPin6;\n  lcdObj->_data_pins[7] = dataPin7;\n  if (evpContext == (EVP_PKEY_CTX *)0x0) {\n    lcdObj->_displayfunction = '\\x10';\n  }\n  else {\n    lcdObj->_displayfunction = '\\0';\n  }\n  begin(lcdObj,'\\x10','\\x01','\\0');\n  return (int)lcdObj;\n}\n\n",
            "renaming": {
                "FUN_080014ba": "initialize_lcd_080014ba",
                "this": "lcdObj",
                "ctx": "evpContext",
                "in_r2": "rsPin",
                "in_r3": "rwPin",
                "in_stack_00000000": "enablePin",
                "in_stack_00000004": "dataPin0",
                "in_stack_00000008": "dataPin1",
                "in_stack_0000000c": "dataPin2",
                "in_stack_00000010": "dataPin3",
                "in_stack_00000014": "dataPin4",
                "in_stack_00000018": "dataPin5",
                "in_stack_0000001c": "dataPin6",
                "in_stack_00000020": "dataPin7"
            },
            "calling": [
                "LiquidCrystal"
            ],
            "called": [
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001510": {
            "entrypoint": "0x08001510",
            "current_name": "initialize_lcd_08001510",
            "code": "\n/* DWARF original prototype: LiquidCrystal *  LiquidCrystal(LiquidCrystal * lcdObject, uint8_t pinRS,\n   uint8_t pinEnable, uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3) */\n\nLiquidCrystal * __lcdObjectcall\nLiquidCrystal::initializeLCD_08001510(LiquidCrystal *lcdObject,uint8_t pinRS,uint8_t pinEnable,uint8_t d0,uint8_t d1,uint8_t d2,uint8_t d3\n          )\n\n{\n  (lcdObject->super_Print).write_error = 0;\n  (lcdObject->super_Print)._vptr_Print = (_func_int_varargs **)&PTR_write_1_080073f8;\n  init(lcdObject,(EVP_PKEY_CTX *)0x1);\n  return lcdObject;\n}\n\n",
            "renaming": {
                "FUN_08001510": "initialize_lcd_08001510",
                "this": "lcdObject",
                "rs": "pinRS",
                "enable": "pinEnable"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001550": {
            "entrypoint": "0x08001550",
            "current_name": "create_character_08001550",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example charLocation: r0 : 0x08001574 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  createChar(LiquidCrystal * this, uint8_t charLocation, uint8_t *\n   characterMap) */\n\nvoid __thiscall LiquidCrystal::createCharacter_08001550(LiquidCrystal *this,uint8_t charLocation,uint8_t *characterMap)\n\n{\n  size_t characterSize;\n  int unusedVar;\n  int index;\n  \n  send(this,(charLocation & 7) << 3 | 0x40,(void *)0x0,characterSize,unusedVar);\n  for (index = 0; index < 8; index = index + 1) {\n    (**(this->super_Print)._vptr_Print)(this,(uint)characterMap[index]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "location": "charLocation",
                "charmap": "characterMap",
                "in_r3": "characterSize",
                "unaff_r4": "unusedVar",
                "iVar1": "index",
                "FUN_08001550": "create_character_08001550"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800157c": {
            "entrypoint": "0x0800157c",
            "current_name": "initialize_max31855_0800157c",
            "code": "\n/* DWARF original prototype: MAX31855 *  MAX31855(MAX31855 * max31855Instance, uchar dataOutPin, uchar chipSelectPin, uchar clockPin) */\n\nMAX31855 * __max31855Instancecall MAX31855::initializeMAX31855_0800157c(MAX31855 *max31855Instance,uchar dataOutPin,uchar chipSelectPin,uchar clockPin)\n\n{\n  max31855Instance->so = dataOutPin;\n  max31855Instance->cs = chipSelectPin;\n  max31855Instance->sck = clockPin;\n  pinMode((uint)dataOutPin,0);\n  pinMode((uint)max31855Instance->cs,1);\n  pinMode((uint)max31855Instance->sck,1);\n  digitalWrite((uint)max31855Instance->cs,1);\n  digitalWrite((uint)max31855Instance->sck,0);\n  return max31855Instance;\n}\n\n",
            "renaming": {
                "SO": "dataOutPin",
                "CS": "chipSelectPin",
                "SCK": "clockPin",
                "this": "max31855Instance",
                "FUN_0800157c": "initialize_max31855_0800157c"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "digitalWrite",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b2": {
            "entrypoint": "0x080015b2",
            "current_name": "read_max31855_data_080015b2",
            "code": "\n/* DWARF original prototype: ulong  readData(MAX31855 * sensor) */\n\nulong __sensorcall MAX31855::readMAX31855Data_080015b2(MAX31855 *sensor)\n\n{\n  int digitalValue;\n  uint bitIndex;\n  uint dataValue;\n  \n  digitalWrite((uint)sensor->cs,0);\n  dataValue = 0;\n  for (bitIndex = 0x1f; -1 < (int)bitIndex; bitIndex = bitIndex - 1) {\n    digitalWrite((uint)sensor->sck,1);\n    digitalValue = digitalRead((uint)sensor->so);\n    if (digitalValue != 0) {\n      dataValue = dataValue | 1 << (bitIndex & 0xff);\n    }\n    digitalWrite((uint)sensor->sck,0);\n  }\n  digitalWrite((uint)sensor->cs,1);\n  return dataValue;\n}\n\n",
            "renaming": {
                "FUN_080015b2": "read_max31855_data_080015b2",
                "this": "sensor",
                "iVar1": "digitalValue",
                "uVar2": "bitIndex",
                "uVar3": "dataValue"
            },
            "calling": [
                "readThermocouple"
            ],
            "called": [
                "digitalWrite",
                "digitalRead"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015f8": {
            "entrypoint": "0x080015f8",
            "current_name": "calculate_temperature_080015f8",
            "code": "\n/* DWARF original prototype: double  readThermocouple(MAX31855 * thermocouple, temperatureUnit_t temperatureUnit) */\n\ndouble __thermocouplecall MAX31855::calculateTemperature_080015f8(MAX31855 *thermocouple,temperatureUnit_t temperatureUnit)\n\n{\n  ulong data;\n  ulong data;\n  uint shiftedData;\n  double result;\n  double dVar;\n  double temperature;\n  undefined8 convertedValue;\n  \n  data = readData(thermocouple);\n  if ((data & 0x10000) == 0) {\n    shiftedData = data >> 0x12;\n    convertedValue = __floatunsidf(shiftedData & 0x1fff);\n    if ((shiftedData & 0x2000) != 0) {\n      convertedValue = __floatunsidf(~shiftedData & 0x1fff);\n      convertedValue = __aeabi_dadd((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20),0,0x3ff00000);\n      convertedValue = CONCAT44((int)((ulonglong)convertedValue >> 0x20) + -0x80000000,(int)convertedValue);\n    }\n    convertedValue = __muldf3((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20),0,0x3fd00000);\n    temperature = dVar;\n    if (temperatureUnit == FAHRENHEIT) {\n      convertedValue = __muldf3((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20),0,0x40220000);\n      convertedValue = __divdf3((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20),0,0x40140000);\n      temperature = (double)__aeabi_dadd((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20),0,0x40400000);\n      return temperature;\n    }\n  }\n  else {\n    shiftedData = data & 7;\n    if (shiftedData == 2) {\n      return result;\n    }\n    if (shiftedData == 4) {\n      return result;\n    }\n    temperature = result;\n    if (shiftedData != 1) {\n      return result;\n    }\n  }\n  return temperature;\n}\n\n",
            "renaming": {
                "FUN_080015f8": "calculate_temperature_080015f8",
                "this": "thermocouple",
                "unit": "temperatureUnit",
                "uVar1": "data",
                "uVar2": "shiftedData",
                "extraout_d0": "result",
                "extraout_d0_00": "dVar",
                "dVar3": "temperature",
                "uVar4": "convertedValue"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "__floatunsidf",
                "__divdf3",
                "readData"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016b4": {
            "entrypoint": "0x080016b4",
            "current_name": "compute_pid_080016b4",
            "code": "\n/* DWARF original prototype: bool  Compute(PID * pid) */\n\nbool __pidcall PID::computePID_080016b4(PID *pid)\n\n{\n  bool inAuto;\n  uint32_t currentTime;\n  ulong currentTime;\n  int comparisonResult;\n  undefined4 difference;\n  undefined4 input1;\n  undefined4 input1;\n  undefined4 minOutput;\n  ulong timeChange;\n  undefined4 input2;\n  undefined4 input2;\n  undefined4 maxOutput;\n  char inAuto;\n  undefined4 tempVar;\n  undefined4 tempVar;\n  undefined4 tempVar;\n  undefined8 proportionalTerm;\n  undefined8 errorDifference;\n  undefined8 integralTerm;\n  double output;\n  double output;\n  double output;\n  \n  inAuto = pid->inAuto;\n  if ((bool)inAuto != false) {\n    currentTime = millis();\n    if (currentTime - pid->lastTime < pid->SampleTime) {\n      inAuto = '\\0';\n    }\n    else {\n      input1 = *(undefined4 *)pid->myInput;\n      input2 = *(undefined4 *)((int)pid->myInput + 4);\n      proportionalTerm = __subdf3(*(undefined4 *)pid->mySetpoint,*(undefined4 *)((int)pid->mySetpoint + 4));\n      tempVar = (undefined4)((ulonglong)proportionalTerm >> 0x20);\n      errorDifference = __subdf3(input1,input2,*(undefined4 *)&pid->lastInput,\n                        *(undefined4 *)((int)&pid->lastInput + 4));\n      difference = (undefined4)((ulonglong)errorDifference >> 0x20);\n      integralTerm = __muldf3((int)proportionalTerm,tempVar,*(undefined4 *)&pid->ki,\n                        *(undefined4 *)((int)&pid->ki + 4));\n      output = (double)__aeabi_dadd((int)integralTerm,(int)((ulonglong)integralTerm >> 0x20),\n                                    *(undefined4 *)&pid->outputSum,\n                                    *(undefined4 *)((int)&pid->outputSum + 4));\n      pid->outputSum = output;\n      inAuto = pid->pOnE;\n      if (inAuto == false) {\n        integralTerm = __muldf3((int)errorDifference,difference,*(undefined4 *)&pid->kp,\n                          *(undefined4 *)((int)&pid->kp + 4));\n        output = (double)__subdf3(SUB84(output,0),(int)((ulonglong)output >> 0x20),(int)integralTerm,\n                                  (int)((ulonglong)integralTerm >> 0x20));\n        pid->outputSum = output;\n      }\n      input1 = *(undefined4 *)&pid->outputSum;\n      input2 = *(undefined4 *)((int)&pid->outputSum + 4);\n      tempVar = *(undefined4 *)&pid->outMax;\n      tempVar = *(undefined4 *)((int)&pid->outMax + 4);\n      output = pid->outMax;\n      comparisonResult = __aeabi_dcmpgt(input1,input2,tempVar,tempVar);\n      if (comparisonResult == 0) {\n        minOutput = *(undefined4 *)&pid->outMin;\n        maxOutput = *(undefined4 *)((int)&pid->outMin + 4);\n        comparisonResult = __aeabi_dcmplt(input1,input2);\n        if (comparisonResult != 0) {\n          *(undefined4 *)&pid->outputSum = minOutput;\n          *(undefined4 *)((int)&pid->outputSum + 4) = maxOutput;\n        }\n      }\n      else {\n        *(undefined4 *)&pid->outputSum = tempVar;\n        *(undefined4 *)((int)&pid->outputSum + 4) = tempVar;\n      }\n      if (inAuto == false) {\n        proportionalTerm = 0;\n      }\n      else {\n        proportionalTerm = __muldf3((int)proportionalTerm,tempVar,*(undefined4 *)&pid->kp,\n                          *(undefined4 *)((int)&pid->kp + 4));\n      }\n      output._4_4_ = (undefined4)((ulonglong)proportionalTerm >> 0x20);\n      output._0_4_ = (undefined4)proportionalTerm;\n      tempVar = *(undefined4 *)&pid->outputSum;\n      input1 = *(undefined4 *)((int)&pid->outputSum + 4);\n      proportionalTerm = __muldf3((int)errorDifference,difference,*(undefined4 *)&pid->kd,\n                        *(undefined4 *)((int)&pid->kd + 4));\n      proportionalTerm = __subdf3(tempVar,input1,(int)proportionalTerm,(int)((ulonglong)proportionalTerm >> 0x20));\n      output = (double)__aeabi_dadd(output._0_4_,output._4_4_,(int)proportionalTerm,\n                                    (int)((ulonglong)proportionalTerm >> 0x20));\n      tempVar = (undefined4)((ulonglong)output >> 0x20);\n      comparisonResult = __aeabi_dcmplt(tempVar,tempVar,SUB84(output,0),tempVar);\n      if (comparisonResult == 0) {\n        output = pid->outMin;\n        comparisonResult = __aeabi_dcmplt(SUB84(output,0),tempVar,*(undefined4 *)&pid->outMin,\n                               *(undefined4 *)((int)&pid->outMin + 4));\n        if (comparisonResult == 0) {\n          output = output;\n        }\n      }\n      *pid->myOutput = output;\n      *(undefined4 *)&pid->lastInput = input1;\n      *(undefined4 *)((int)&pid->lastInput + 4) = input2;\n      pid->lastTime = currentTime;\n    }\n  }\n  return (bool)inAuto;\n}\n\n",
            "renaming": {
                "FUN_080016b4": "compute_pid_080016b4",
                "this": "pid",
                "bVar1": "inAuto",
                "uVar2": "currentTime",
                "now": "currentTime",
                "iVar3": "comparisonResult",
                "uVar4": "difference",
                "uVar5": "input1",
                "uVar6": "input1",
                "uVar7": "minOutput",
                "uVar8": "input2",
                "uVar9": "input2",
                "uVar10": "maxOutput",
                "uVar12": "tempVar",
                "uVar13": "tempVar",
                "uVar14": "tempVar",
                "uVar15": "proportionalTerm",
                "uVar16": "errorDifference",
                "uVar17": "integralTerm",
                "dVar18": "output",
                "dVar19": "output",
                "cVar11": "inAuto"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__muldf3",
                "__subdf3",
                "__aeabi_dadd",
                "millis",
                "__aeabi_dcmpgt",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001814": {
            "entrypoint": "0x08001814",
            "current_name": "set_tunings_08001814",
            "code": "\n/* DWARF original prototype: void  SetTunings(PID * pidObject, double proportionalGain, double integralGain, double derivativeGain, int proportionalOn)\n    */\n\nvoid __pidObjectcall PID::setTunings_08001814(PID *pidObject,double proportionalGain,double integralGain,double derivativeGain,int proportionalOn)\n\n{\n  int comparisonResult;\n  undefined4 undefinedVar2;\n  undefined4 inputRegister2;\n  undefined4 inputRegister3;\n  undefined undefinedVar3;\n  bool booleanVar;\n  undefined8 undefinedVar5;\n  double doubleVar6;\n  double doubleVar7;\n  double doubleVar8;\n  \n  comparisonResult = __aeabi_dcmplt();\n  if (((comparisonResult == 0) && (comparisonResult = __aeabi_dcmplt(proportionalGain._0_4_,proportionalGain._4_4_,0,0), comparisonResult == 0)) &&\n     (comparisonResult = __aeabi_dcmplt(integralGain._0_4_,integralGain._4_4_,0,0), comparisonResult == 0)) {\n    pidObject->pOn = derivativeGain._0_4_;\n    booleanVar = derivativeGain._0_4_ != 1;\n    if (booleanVar) {\n      derivativeGain._0_4_ = 0;\n    }\n    undefinedVar3 = (undefined)derivativeGain._0_4_;\n    if (!booleanVar) {\n      undefinedVar3 = true;\n    }\n    pidObject->pOnE = (bool)undefinedVar3;\n    *(undefined4 *)&pidObject->dispproportionalGain = inputRegister2;\n    *(undefined4 *)((int)&pidObject->dispproportionalGain + 4) = inputRegister3;\n    pidObject->dispintegralGain = proportionalGain;\n    pidObject->dispderivativeGain = integralGain;\n    undefinedVar5 = __floatunsidf(pidObject->SampleTime);\n    undefinedVar5 = __divdf3((int)undefinedVar5,(int)((ulonglong)undefinedVar5 >> 0x20),0,0x408f4000);\n    undefinedVar2 = (undefined4)((ulonglong)undefinedVar5 >> 0x20);\n    *(undefined4 *)&pidObject->kp = inputRegister2;\n    *(undefined4 *)((int)&pidObject->kp + 4) = inputRegister3;\n    doubleVar6 = (double)__muldf3(proportionalGain._0_4_,proportionalGain._4_4_,(int)undefinedVar5,undefinedVar2);\n    pidObject->ki = doubleVar6;\n    doubleVar7 = (double)__divdf3(integralGain._0_4_,integralGain._4_4_,(int)undefinedVar5,undefinedVar2);\n    pidObject->kd = doubleVar7;\n    if (pidObject->controllerDirection == 1) {\n      doubleVar8 = (double)__subdf3(0,0);\n      pidObject->kp = doubleVar8;\n      doubleVar6 = (double)__subdf3(0,0,SUB84(doubleVar6,0),(int)((ulonglong)doubleVar6 >> 0x20));\n      pidObject->ki = doubleVar6;\n      doubleVar6 = (double)__subdf3(0,0,SUB84(doubleVar7,0),(int)((ulonglong)doubleVar7 >> 0x20));\n      pidObject->kd = doubleVar6;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001814": "set_tunings_08001814",
                "this": "pidObject",
                "Kp": "proportionalGain",
                "Ki": "integralGain",
                "Kd": "derivativeGain",
                "POn": "proportionalOn",
                "iVar1": "comparisonResult",
                "uVar2": "undefinedVar2",
                "in_r2": "inputRegister2",
                "in_r3": "inputRegister3",
                "uVar3": "undefinedVar3",
                "bVar4": "booleanVar",
                "uVar5": "undefinedVar5",
                "dVar6": "doubleVar6",
                "dVar7": "doubleVar7",
                "dVar8": "doubleVar8"
            },
            "calling": [
                "PID",
                "SetTunings"
            ],
            "called": [
                "__muldf3",
                "__subdf3",
                "__floatunsidf",
                "__divdf3",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080018f8": {
            "entrypoint": "0x080018f8",
            "current_name": "set_pid_tunings_080018f8",
            "code": "\n/* DWARF original prototype: void  SetTunings(PIDController * this, double proportionalGain, double integralGain, double derivativeGain) */\n\nvoid __thiscall PIDController::setPIDTunings_080018f8(PIDController *this,double proportionalGain,double integralGain,double derivativeGain)\n\n{\n  undefined4 tempValue;\n  \n  SetTunings(this,proportionalGain,integralGain,(double)CONCAT44(tempValue,this->pOn),this->pOn);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080018f8": "set_pid_tunings_080018f8",
                "PID": "PIDController",
                "Kp": "proportionalGain",
                "Ki": "integralGain",
                "Kd": "derivativeGain",
                "in_stack_ffffffec": "tempValue"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "SetTunings"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001918": {
            "entrypoint": "0x08001918",
            "current_name": "set_sample_time_08001918",
            "code": "\n/* DWARF original prototype: void  SetSampleTime(PID * pid_instance, int new_sample_time) */\n\nvoid __pid_instancecall PID::set_sample_time_08001918(PID *pid_instance,int new_sample_time)\n\n{\n  undefined4 div_result;\n  undefined8 float_sample_time;\n  undefined8 float_this_sample_time;\n  double temp_calculation;\n  \n  if (0 < new_sample_time) {\n    float_sample_time = __floatsidf(new_sample_time);\n    float_this_sample_time = __floatunsidf(pid_instance->SampleTime);\n    float_sample_time = __divdf3((int)float_sample_time,(int)((ulonglong)float_sample_time >> 0x20),(int)float_this_sample_time,\n                     (int)((ulonglong)float_this_sample_time >> 0x20));\n    div_result = (undefined4)((ulonglong)float_sample_time >> 0x20);\n    temp_calculation = (double)__muldf3((int)float_sample_time,div_result,*(undefined4 *)&pid_instance->ki_value,\n                             *(undefined4 *)((int)&pid_instance->ki_value + 4));\n    pid_instance->ki_value = temp_calculation;\n    temp_calculation = (double)__divdf3(*(undefined4 *)&pid_instance->kd_value,*(undefined4 *)((int)&pid_instance->kd_value + 4),(int)float_sample_time\n                             ,div_result);\n    pid_instance->kd_value = temp_calculation;\n    pid_instance->SampleTime = new_sample_time;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001918": "set_sample_time_08001918",
                "this": "pid_instance",
                "NewSampleTime": "new_sample_time",
                "uVar1": "div_result",
                "uVar2": "float_sample_time",
                "uVar3": "float_this_sample_time",
                "dVar4": "temp_calculation",
                "ki": "ki_value",
                "kd": "kd_value"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__muldf3",
                "__floatsidf",
                "__floatunsidf",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001960": {
            "entrypoint": "0x08001960",
            "current_name": "set_output_limits_08001960",
            "code": "\n/* DWARF original prototype: void  SetOutputLimits(PID * this, double newMin, double newMax) */\n\nvoid __thiscall PID::setOutputLimits_08001960(PID *this,double newMin,double newMax)\n\n{\n  int comparisonResult;\n  undefined4 outMin1;\n  undefined4 outMin2;\n  double *myOutputPtr;\n  undefined4 outputSum1;\n  undefined4 outputSum2;\n  undefined4 outMax1;\n  undefined4 outMax2;\n  \n  comparisonResult = __aeabi_dcmpge();\n  if (comparisonResult == 0) {\n    *(undefined4 *)&this->outnewMin = outMin1;\n    *(undefined4 *)((int)&this->outnewMin + 4) = outMin2;\n    this->outnewMax = newMin;\n    if (this->inAuto != false) {\n      myOutputPtr = this->myOutput;\n      comparisonResult = __aeabi_dcmplt(newMin._0_4_,newMin._4_4_,*(undefined4 *)myOutputPtr,\n                             *(undefined4 *)((int)myOutputPtr + 4));\n      if (comparisonResult == 0) {\n        comparisonResult = __aeabi_dcmpgt();\n        if (comparisonResult != 0) {\n          *(undefined4 *)myOutputPtr = outMin1;\n          *(undefined4 *)((int)myOutputPtr + 4) = outMin2;\n        }\n      }\n      else {\n        *myOutputPtr = newMin;\n      }\n      outputSum1 = *(undefined4 *)&this->outputSum;\n      outputSum2 = *(undefined4 *)((int)&this->outputSum + 4);\n      outMax1 = *(undefined4 *)&this->outnewMax;\n      outMax2 = *(undefined4 *)((int)&this->outnewMax + 4);\n      comparisonResult = __aeabi_dcmpgt(outputSum1,outputSum2,outMax1,outMax2);\n      if (comparisonResult != 0) {\n        *(undefined4 *)&this->outputSum = outMax1;\n        *(undefined4 *)((int)&this->outputSum + 4) = outMax2;\n        return;\n      }\n      outMax1 = *(undefined4 *)&this->outnewMin;\n      outMax2 = *(undefined4 *)((int)&this->outnewMin + 4);\n      comparisonResult = __aeabi_dcmplt(outputSum1,outputSum2,outMax1,outMax2);\n      if (comparisonResult != 0) {\n        *(undefined4 *)&this->outputSum = outMax1;\n        *(undefined4 *)((int)&this->outputSum + 4) = outMax2;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001960": "set_output_limits_08001960",
                "Min": "newMin",
                "Max": "newMax",
                "iVar1": "comparisonResult",
                "in_r2": "outMin1",
                "in_r3": "outMin2",
                "pdVar2": "myOutputPtr",
                "uVar3": "outputSum1",
                "uVar4": "outputSum2",
                "uVar5": "outMax1",
                "uVar6": "outMax2"
            },
            "calling": [
                "PID",
                "loop"
            ],
            "called": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080019f6": {
            "entrypoint": "0x080019f6",
            "current_name": "initialize_pid_080019f6",
            "code": "\n/* DWARF original prototype: void  Initialize(PID * pid) */\n\nvoid __pidcall PID::initializePid_080019f6(PID *pid)\n\n{\n  int comparisonResult;\n  undefined4 inputValue;\n  undefined4 outputValue;\n  undefined4 outputValueNext;\n  undefined4 outputRangeNext;\n  \n  outputValue = *(undefined4 *)pid->myOutput;\n  outputValueNext = *(undefined4 *)((int)pid->myOutput + 4);\n  *(undefined4 *)&pid->outputSum = outputValue;\n  *(undefined4 *)((int)&pid->outputSum + 4) = outputValueNext;\n  inputValue = *(undefined4 *)((int)pid->myInput + 4);\n  *(undefined4 *)&pid->lastInput = *(undefined4 *)pid->myInput;\n  *(undefined4 *)((int)&pid->lastInput + 4) = inputValue;\n  inputValue = *(undefined4 *)&pid->outMax;\n  outputRangeNext = *(undefined4 *)((int)&pid->outMax + 4);\n  comparisonResult = __aeabi_dcmpgt(outputValue,outputValueNext,inputValue,outputRangeNext);\n  if (comparisonResult == 0) {\n    inputValue = *(undefined4 *)&pid->outMin;\n    outputRangeNext = *(undefined4 *)((int)&pid->outMin + 4);\n    comparisonResult = __aeabi_dcmplt(outputValue,outputValueNext,inputValue,outputRangeNext);\n    if (comparisonResult != 0) {\n      *(undefined4 *)&pid->outputSum = inputValue;\n      *(undefined4 *)((int)&pid->outputSum + 4) = outputRangeNext;\n    }\n    return;\n  }\n  *(undefined4 *)&pid->outputSum = inputValue;\n  *(undefined4 *)((int)&pid->outputSum + 4) = outputRangeNext;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080019f6": "initialize_pid_080019f6",
                "this": "pid",
                "iVar1": "comparisonResult",
                "uVar2": "inputValue",
                "uVar3": "outputValue",
                "uVar4": "outputValueNext",
                "uVar5": "outputRangeNext"
            },
            "calling": [
                "SetMode"
            ],
            "called": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a44": {
            "entrypoint": "0x08001a44",
            "current_name": "set_pid_mode_08001a44",
            "code": "\n/* DWARF original prototype: void  Setnew_mode(PID * pid, int new_mode) */\n\nvoid __pidcall PID::set_pid_mode_08001a44(PID *pid,int new_mode)\n\n{\n  bool is_auto;\n  bool is_set_auto;\n  \n  if (new_mode == 1) {\n    is_set_auto = true;\n    if (pid->inAuto == false) {\n      Initialize(pid);\n    }\n  }\n  else {\n    is_set_auto = false;\n  }\n  pid->inAuto = is_set_auto;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a44": "set_pid_mode_08001a44",
                "this": "pid",
                "Mode": "new_mode",
                "newAuto": "is_auto",
                "bVar1": "is_set_auto"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "Initialize"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a66": {
            "entrypoint": "0x08001a66",
            "current_name": "set_controller_direction_08001a66",
            "code": "\n/* DWARF original prototype: void  SetControllernew_direction(PID * pid_instance, int new_direction) */\n\nvoid __pid_instancecall PID::set_controller_direction_08001a66(PID *pid_instance,int new_direction)\n\n{\n  double temp_variable;\n  \n  if ((pid_instance->inAuto != false) && (pid_instance->controllernew_direction != new_direction)) {\n    temp_variable = (double)__subdf3(0,0,*(undefined4 *)&pid_instance->kp,*(undefined4 *)((int)&pid_instance->kp + 4));\n    pid_instance->kp = temp_variable;\n    temp_variable = (double)__subdf3(0,0,*(undefined4 *)&pid_instance->ki,*(undefined4 *)((int)&pid_instance->ki + 4));\n    pid_instance->ki = temp_variable;\n    temp_variable = (double)__subdf3(0,0,*(undefined4 *)&pid_instance->kd,*(undefined4 *)((int)&pid_instance->kd + 4));\n    pid_instance->kd = temp_variable;\n  }\n  pid_instance->controllernew_direction = new_direction;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a66": "set_controller_direction_08001a66",
                "this": "pid_instance",
                "Direction": "new_direction",
                "dVar1": "temp_variable"
            },
            "calling": [
                "PID"
            ],
            "called": [
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "initialize_pid_08001ab0",
            "code": "\n/* DWARF original prototype: PID *  PID(PID * pidInstance, double * input, double * output, double *\n   setpoint, double proportionalGain, double integralGain, double derivativeGain, int proportionalOn, int controllerDirection) */\n\nPID * __pidInstancecall\nPID::initializePID_08001ab0(PID *pidInstance,double *input,double *output,double *setpoint,double proportionalGain,double integralGain,\n                 double derivativeGain,int proportionalOn,int controllerDirection)\n\n{\n  uint32_t currentTime;\n  int proportionalOn_00;\n  undefined4 in_stack_ffffffe8;\n  undefined4 in_stack_ffffffec;\n  undefined4 in_stack_fffffff4;\n  \n  pidInstance->myoutput = output;\n  pidInstance->myinput = input;\n  pidInstance->mysetpoint = setpoint;\n  pidInstance->inAuto = false;\n  SetoutputLimits(pidInstance,255.0,(double)CONCAT44(in_stack_ffffffec,in_stack_ffffffe8));\n  pidInstance->SampleTime = 100;\n  SetcontrollerDirection(pidInstance,controllerDirection);\n  SetTunings(pidInstance,integralGain,derivativeGain,(double)CONCAT44(in_stack_fffffff4,proportionalOn),proportionalOn_00);\n  currentTime = millis();\n  pidInstance->lastTime = currentTime - pidInstance->SampleTime;\n  return pidInstance;\n}\n\n",
            "renaming": {
                "this": "pidInstance",
                "Input": "input",
                "Output": "output",
                "Setpoint": "setpoint",
                "Kp": "proportionalGain",
                "Ki": "integralGain",
                "Kd": "derivativeGain",
                "POn": "proportionalOn",
                "ControllerDirection": "controllerDirection",
                "uVar1": "currentTime",
                "POn_00": "proportionalOn_00",
                "FUN_08001ab0": "initialize_pid_08001ab0"
            },
            "calling": [
                "PID"
            ],
            "called": [
                "SetOutputLimits",
                "millis",
                "SetTunings",
                "SetControllerDirection"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b18": {
            "entrypoint": "0x08001b18",
            "current_name": "initialize_pid_08001b18",
            "code": "\n/* DWARF original prototype: PID *  PID(PID * pidObject, double * input, double * output, double *\n   setpoint, double proportionalGain, double integralGain, double derivativeGain, int controllerDirection) */\n\nPID * __pidObjectcall\nPID::initializePID_08001b18(PID *pidObject,double *input,double *output,double *setpoint,double proportionalGain,double integralGain,\n                 double derivativeGain,int controllerDirection)\n\n{\n  PID(pidObject,input,output,setpoint,proportionalGain,integralGain,derivativeGain,1,controllerDirection);\n  return pidObject;\n}\n\n",
            "renaming": {
                "FUN_08001b18": "initialize_pid_08001b18",
                "this": "pidObject",
                "Input": "input",
                "Output": "output",
                "Setpoint": "setpoint",
                "Kp": "proportionalGain",
                "Ki": "integralGain",
                "Kd": "derivativeGain",
                "ControllerDirection": "controllerDirection"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "PID"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b48": {
            "entrypoint": "0x08001b48",
            "current_name": "initialize_rcc_08001b48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_RCC_08001b48(void)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t frequency;\n  PeriphClkInit PeriphClkInit;\n  ClkInitStruct RCC_ClkInitStruct;\n  OscInitStruct RCC_OscInitStruct;\n  \n  OscillatorType = 2;\n  HSIState = 1;\n  HSICalibrationValue = 0x10;\n  PLLState = 2;\n  PLLSource = 0;\n  PLLMUL = 0x380000;\n  status = HAL_RCC_OscConfig((OscInitStruct_conflict *)&RCC_OscInitStruct);\n  if (status != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x88);\n  }\n  ClockType = 0xf;\n  SYSCLKSource = 2;\n  AHBCLKDivider = 0;\n  APB1CLKDivider = 0x400;\n  APB2CLKDivider = 0;\n  status = HAL_RCC_ClockConfig((ClkInitStruct_conflict *)&RCC_ClkInitStruct,2);\n  if (status != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x95);\n  }\n  PeriphClockSelection = 2;\n  AdcClockSelection = 0x8000;\n  status = HAL_RCCEx_PeriphCLKConfig((PeriphClkInit_conflict *)&PeriphClkInit);\n  if (status != HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x9c);\n  }\n  frequency = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(frequency / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001b48": "initialize_rcc_08001b48",
                "HVar1": "status",
                "uVar2": "frequency",
                "RCC_PeriphCLKInitTypeDef": "PeriphClkInit",
                "RCC_ClkInitTypeDef": "ClkInitStruct",
                "RCC_OscInitTypeDef": "OscInitStruct",
                "RCC_OscInitStruct.OscillatorType": "OscillatorType",
                "RCC_OscInitStruct.HSIState": "HSIState",
                "RCC_OscInitStruct.HSICalibrationValue": "HSICalibrationValue",
                "RCC_OscInitStruct.PLL.PLLState": "PLLState",
                "RCC_OscInitStruct.PLL.PLLSource": "PLLSource",
                "RCC_OscInitStruct.PLL.PLLMUL": "PLLMUL",
                "RCC_ClkInitStruct.ClockType": "ClockType",
                "RCC_ClkInitStruct.SYSCLKSource": "SYSCLKSource",
                "RCC_ClkInitStruct.AHBCLKDivider": "AHBCLKDivider",
                "RCC_ClkInitStruct.APB1CLKDivider": "APB1CLKDivider",
                "RCC_ClkInitStruct.APB2CLKDivider": "APB2CLKDivider",
                "PeriphClkInit.PeriphClockSelection": "PeriphClockSelection",
                "PeriphClkInit.AdcClockSelection": "AdcClockSelection"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_RCCEx_PeriphCLKConfig",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_ClockConfig",
                "HAL_SYSTICK_Config",
                "_Error_Handler",
                "HAL_RCC_OscConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001be8": {
            "entrypoint": "0x08001be8",
            "current_name": "initialize_system_08001be8",
            "code": "\nvoid initializeSystem_08001be8(void)\n\n{\n  int index;\n  undefined4 *ptr;\n  code *jumpTable;\n  \n  for (index = 0; (undefined *)(index + 0x20000000) < &_edata; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&_sidata + index);\n  }\n  for (ptr = &completed_8667; ptr < &_ebss; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x8001c1a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08001c1a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001be8": "initialize_system_08001be8",
                "iVar1": "index",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c30": {
            "entrypoint": "0x08001c30",
            "current_name": "infinite_loop_08001c30",
            "code": "\nvoid infiniteLoop_08001c30(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08001c30": "infinite_loop_08001c30"
            },
            "calling": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "called": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c32": {
            "entrypoint": "0x08001c32",
            "current_name": "initialize_hardware_configuration_08001c32",
            "code": "\nint initializeHardwareConfiguration_08001c32(EVP_PKEY_CTX *context)\n\n{\n  initializeHardwareConfig();\n  return returnVal;\n}\n\n",
            "renaming": {
                "FUN_08001c32": "initialize_hardware_configuration_08001c32",
                "ctx": "context",
                "hw_config_init": "initializeHardwareConfig",
                "(int)ctx": "returnVal"
            },
            "calling": [
                "premain"
            ],
            "called": [
                "hw_config_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c3a": {
            "entrypoint": "0x08001c3a",
            "current_name": "FUNC_08001c3a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001c3a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001c3a": "FUNC_08001c3a"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001c3c": {
            "entrypoint": "0x08001c3c",
            "current_name": "configure_systick_08001c3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureSystick_08001c3c(uint32_t priority)\n\n{\n  uint32_t configResult;\n  \n  configResult = HAL_SYSTICK_Config((uint32_t)((ulonglong)SystemCoreClock / (1000 / (ulonglong)uwTickFreq))\n                            );\n  if (configResult != 0) {\n    return HAL_ERROR;\n  }\n  if (0xf < priority) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn,priority,0);\n  uwTickPrio = priority;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001c3c": "configure_systick_08001c3c",
                "TickPriority": "priority",
                "uVar1": "configResult"
            },
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c88": {
            "entrypoint": "0x08001c88",
            "current_name": "initialize_hardware_08001c88",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHALStatus initializeHardware_08001c88(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  configureInterruptPriorityGrouping(3);\n  configureTick(0xf);\n  initializePeripheral();\n  return HALSuccess;\n}\n\n",
            "renaming": {
                "FUN_08001c88": "initialize_hardware_08001c88",
                "HAL_StatusTypeDef_conflict": "HALStatus",
                "HAL_NVIC_SetPriorityGrouping": "configureInterruptPriorityGrouping",
                "HAL_InitTick": "configureTick",
                "HAL_MspInit": "initializePeripheral",
                "HAL_OK": "HALSuccess"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cac": {
            "entrypoint": "0x08001cac",
            "current_name": "update_tick_value_08001cac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateTickValue_08001cac(void)\n\n{\n  updatedTickValue = originalTickValue + updatedTickValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cac": "update_tick_value_08001cac",
                "uwTickFreq": "originalTickValue",
                "uwTick": "updatedTickValue"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cc4": {
            "entrypoint": "0x08001cc4",
            "current_name": "get_current_tick_08001cc4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getCurrentTick_08001cc4(void)\n\n{\n  return currentTick;\n}\n\n",
            "renaming": {
                "FUN_08001cc4": "get_current_tick_08001cc4",
                "uwTick": "currentTick"
            },
            "calling": [
                "HAL_RCCEx_PeriphCLKConfig",
                "ADC_ConversionStop_Disable",
                "HAL_ADC_PollForConversion",
                "GetCurrentMilli",
                "HAL_RCC_ClockConfig",
                "HAL_ADCEx_Calibration_Start",
                "UART_WaitOnFlagUntilTimeout",
                "HAL_UART_Transmit",
                "ADC_Enable",
                "HAL_RCC_OscConfig",
                "uart_debug_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cd0": {
            "entrypoint": "0x08001cd0",
            "current_name": "perform_adc_conversion_08001cd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict perform_adc_conversion_08001cd0(ADC_HandleTypeDef *adc_handle,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t start_tick;\n  uint32_t periph_clk_freq;\n  int sampling_time;\n  uint32_t current_tick;\n  ADC_TypeDef *adc_instance;\n  uint cpu_cycles;\n  uint32_t current_cpu_cycles;\n  \n  current_cpu_cycles = 0;\n  start_tick = HAL_GetTick();\n  current_tick = SystemCoreClock;\n  adc_instance = adc_handle->Instance;\n  if ((adc_instance->CR2 & 0x100) == 0) {\n    if (((adc_instance->CR1 & 0x100) == 0) && ((adc_instance->SQR1 & 0xf00000) == 0)) {\n      do {\n        if ((adc_handle->Instance->SR & 2) != 0) goto LAB_08001de2;\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (current_tick = HAL_GetTick(), current_tick - start_tick <= timeout))));\n      adc_handle->State = adc_handle->State | 4;\n      adc_handle->Lock = HAL_UNLOCKED;\n      status = HAL_TIMEOUT;\n    }\n    else {\n      periph_clk_freq = HAL_RCCEx_GetPeriphCLKFreq(2);\n      adc_instance = adc_handle->Instance;\n      if (((adc_instance->SMPR2 & 0x24924924) == 0) && ((adc_instance->SMPR1 & 0x924924) == 0)) {\n        if ((adc_instance->SMPR2 & 0x12492492) == 0) {\n          if ((adc_instance->SMPR1 & 0x492492) == 0) {\n            sampling_time = 0x14;\n          }\n          else {\n            sampling_time = 0x29;\n          }\n        }\n        else {\n          sampling_time = 0x29;\n        }\n      }\n      else if (((adc_instance->SMPR2 & 0x12492492) == 0) && ((adc_instance->SMPR1 & 0x492492) == 0)) {\n        sampling_time = 0x54;\n      }\n      else if ((adc_instance->SMPR2 & 0x249249) == 0) {\n        if ((adc_instance->SMPR1 & 0x249249) == 0) {\n          sampling_time = 0x54;\n        }\n        else {\n          sampling_time = 0xfc;\n        }\n      }\n      else {\n        sampling_time = 0xfc;\n      }\n      cpu_cycles = (current_tick / periph_clk_freq) * sampling_time;\n      for (; current_cpu_cycles <= cpu_cycles && cpu_cycles - current_cpu_cycles != 0;\n          current_cpu_cycles = current_cpu_cycles + 1) {\n        if ((timeout != 0xffffffff) &&\n           ((timeout == 0 || (current_tick = HAL_GetTick(), timeout < current_tick - start_tick)))) {\n          adc_handle->State = adc_handle->State | 4;\n          adc_handle->Lock = HAL_UNLOCKED;\n          return HAL_TIMEOUT;\n        }\n      }\nLAB_08001de2:\n      adc_handle->Instance->SR = 0xffffffed;\n      adc_handle->State = adc_handle->State | 0x200;\n      if ((adc_handle->Instance->CR2 & 0xe0000) == 0xe0000) {\n        if ((adc_handle->Init).ContinuousConvMode == 0) {\n          adc_handle->State = adc_handle->State & 0xfffffeff;\n          if ((adc_handle->State & 0x1000) == 0) {\n            adc_handle->State = adc_handle->State | 1;\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        status = HAL_OK;\n      }\n    }\n  }\n  else {\n    adc_handle->State = adc_handle->State | 0x20;\n    adc_handle->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001cd0": "perform_adc_conversion_08001cd0",
                "hadc": "adc_handle",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "start_tick",
                "uVar3": "periph_clk_freq",
                "iVar4": "sampling_time",
                "uVar5": "current_tick",
                "pAVar6": "adc_instance",
                "uVar7": "cpu_cycles",
                "Conversion_Timeout_CPU_cycles": "current_cpu_cycles"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e40": {
            "entrypoint": "0x08001e40",
            "current_name": "get_adc_data_08001e40",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getADCData_08001e40(ADC_HandleTypeDef *adcHandle)\n\n{\n  return adcHandle->Instance->DR;\n}\n\n",
            "renaming": {
                "FUN_08001e40": "get_adc_data_08001e40",
                "hadc": "adcHandle"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e48": {
            "entrypoint": "0x08001e48",
            "current_name": "configure_adc_channel_08001e48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureADCChannel_08001e48(ADC_HandleTypeDef *adcHandle,ADC_ChannelConfTypeDef *channelConfig)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint rankOffset;\n  uint32_t loopIndex;\n  \n  if (adcHandle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    adcHandle->Lock = HAL_LOCKED;\n    rankOffset = channelConfig->Rank;\n    if (rankOffset < 7) {\n      rankOffset = rankOffset * 5 - 5;\n      adcHandle->Instance->SQR3 =\n           channelConfig->Channel << (rankOffset & 0xff) | adcHandle->Instance->SQR3 & ~(0x1f << (rankOffset & 0xff));\n    }\n    else if (rankOffset < 0xd) {\n      rankOffset = rankOffset * 5 - 0x23;\n      adcHandle->Instance->SQR2 =\n           channelConfig->Channel << (rankOffset & 0xff) | adcHandle->Instance->SQR2 & ~(0x1f << (rankOffset & 0xff));\n    }\n    else {\n      rankOffset = rankOffset * 5 - 0x41;\n      adcHandle->Instance->SQR1 =\n           channelConfig->Channel << (rankOffset & 0xff) | adcHandle->Instance->SQR1 & ~(0x1f << (rankOffset & 0xff));\n    }\n    rankOffset = channelConfig->Channel;\n    if (rankOffset < 10) {\n      adcHandle->Instance->SMPR2 =\n           channelConfig->SamplingTime << (rankOffset * 3 & 0xff) |\n           adcHandle->Instance->SMPR2 & ~(7 << (rankOffset * 3 & 0xff));\n    }\n    else {\n      rankOffset = rankOffset * 3 - 0x1e;\n      adcHandle->Instance->SMPR1 =\n           channelConfig->SamplingTime << (rankOffset & 0xff) | adcHandle->Instance->SMPR1 & ~(7 << (rankOffset & 0xff));\n    }\n    if (channelConfig->Channel - 0x10 < 2) {\n      if (adcHandle->Instance == (ADC_TypeDef *)0x40012400) {\n        if ((uRam40012408 & 0x800000) == 0) {\n          uRam40012408 = uRam40012408 | 0x800000;\n          if (channelConfig->Channel == 0x10) {\n            for (loopIndex = (SystemCoreClock / 1000000) * 10; loopIndex != 0;\n                loopIndex = loopIndex - 1) {\n            }\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        adcHandle->State = adcHandle->State | 0x20;\n        status = HAL_ERROR;\n      }\n    }\n    else {\n      status = HAL_OK;\n    }\n    adcHandle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001e48": "configure_adc_channel_08001e48",
                "hadc": "adcHandle",
                "sConfig": "channelConfig",
                "HVar1": "status",
                "uVar2": "rankOffset",
                "wait_loop_index": "loopIndex"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f80": {
            "entrypoint": "0x08001f80",
            "current_name": "get_adc_state_08001f80",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_ADC_state_08001f80(ADC_HandleTypeDef *adc_handler)\n\n{\n  return adc_handler->State;\n}\n\n",
            "renaming": {
                "FUN_08001f80": "get_adc_state_08001f80",
                "hadc": "adc_handler"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f84": {
            "entrypoint": "0x08001f84",
            "current_name": "initialize_adc_08001f84",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeADC_08001f84(ADC_HandleTypeDef *adcHandler)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t startTime;\n  uint32_t currentTime;\n  ADC_TypeDef *adcInstance;\n  uint32_t loopIndex;\n  \n  adcInstance = adcHandler->Instance;\n  if ((adcInstance->CR2 & 1) == 0) {\n    adcInstance->CR2 = adcInstance->CR2 | 1;\n    for (loopIndex = SystemCoreClock / 1000000; loopIndex != 0;\n        loopIndex = loopIndex - 1) {\n    }\n    startTime = HAL_GetTick();\n    do {\n      if ((adcHandler->Instance->CR2 & 1) != 0) {\n        return HAL_OK;\n      }\n      currentTime = HAL_GetTick();\n    } while (currentTime - startTime < 3);\n    adcHandler->State = adcHandler->State | 0x10;\n    adcHandler->ErrorCode = adcHandler->ErrorCode | 1;\n    adcHandler->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  else {\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001f84": "initialize_adc_08001f84",
                "hadc": "adcHandler",
                "HVar1": "status",
                "uVar2": "startTime",
                "uVar3": "currentTime",
                "pAVar4": "adcInstance",
                "wait_loop_index": "loopIndex"
            },
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Start"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002004": {
            "entrypoint": "0x08002004",
            "current_name": "configure_adc_08002004",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configureADC_08002004(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  ADC_TypeDef *adcInstance;\n  \n  if (adcHandle->Lock != HAL_LOCKED) {\n    adcHandle->Lock = HAL_LOCKED;\n    status = ADC_Enable(adcHandle);\n    if (status == HAL_OK) {\n      adcHandle->State = adcHandle->State & 0xfffffcfe | 0x100;\n      adcInstance = adcHandle->Instance;\n      if ((adcInstance == (ADC_TypeDef *)0x40012800) && ((_DAT_40012404 & 0xf0000) != 0)) {\n        adcHandle->State = adcHandle->State | 0x100000;\n        if ((_DAT_40012404 & 0x400) != 0) {\n          adcHandle->State = adcHandle->State & 0xffffcfff | 0x1000;\n        }\n      }\n      else {\n        adcHandle->State = adcHandle->State & 0xffefffff;\n        if ((adcInstance->CR1 & 0x400) != 0) {\n          adcHandle->State = adcHandle->State & 0xffffcfff | 0x1000;\n        }\n      }\n      if ((adcHandle->State & 0x1000) == 0) {\n        adcHandle->ErrorCode = 0;\n      }\n      else {\n        adcHandle->ErrorCode = adcHandle->ErrorCode & 0xfffffff9;\n      }\n      adcHandle->Lock = HAL_UNLOCKED;\n      adcInstance->SR = 0xfffffffd;\n      adcInstance = adcHandle->Instance;\n      if (((adcInstance->CR2 & 0xe0000) == 0xe0000) &&\n         ((adcInstance != (ADC_TypeDef *)0x40012800 || ((_DAT_40012404 & 0xf0000) == 0)))) {\n        adcInstance->CR2 = adcInstance->CR2 | 0x500000;\n      }\n      else {\n        adcInstance->CR2 = adcInstance->CR2 | 0x100000;\n      }\n    }\n    else {\n      adcHandle->Lock = HAL_UNLOCKED;\n    }\n    return status;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_08002004": "configure_adc_08002004",
                "hadc": "adcHandle",
                "HVar1": "status",
                "pAVar2": "adcInstance"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_Enable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080020f0": {
            "entrypoint": "0x080020f0",
            "current_name": "check_adc_status_080020f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict checkADCStatus_080020f0(ADC_HandleTypeDef *adcHandle)\n\n{\n  uint32_t startTime;\n  uint32_t currentTime;\n  ADC_TypeDef *adcInstance;\n  \n  adcInstance = adcHandle->Instance;\n  if ((adcInstance->CR2 & 1) == 0) {\n    return HAL_OK;\n  }\n  adcInstance->CR2 = adcInstance->CR2 & 0xfffffffe;\n  startTime = HAL_GetTick();\n  do {\n    if ((adcHandle->Instance->CR2 & 1) == 0) {\n      return HAL_OK;\n    }\n    currentTime = HAL_GetTick();\n  } while (currentTime - startTime < 3);\n  adcHandle->State = adcHandle->State | 0x10;\n  adcHandle->ErrorCode = adcHandle->ErrorCode | 1;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_080020f0": "check_adc_status_080020f0",
                "hadc": "adcHandle",
                "pAVar3": "adcInstance",
                "uVar1": "startTime",
                "uVar2": "currentTime"
            },
            "calling": [
                "HAL_ADC_DeInit",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Stop",
                "HAL_ADC_Init"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800213c": {
            "entrypoint": "0x0800213c",
            "current_name": "initialize_adc_0800213c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initialize_ADC_0800213c(ADC_HandleTypeDef *adc_handle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t value_2;\n  uint value_3;\n  uint value_4;\n  uint32_t value_5;\n  \n  if (adc_handle == (ADC_HandleTypeDef *)0x0) {\n    return HAL_ERROR;\n  }\n  if (adc_handle->State == 0) {\n    adc_handle->ErrorCode = 0;\n    adc_handle->Lock = HAL_UNLOCKED;\n    HAL_ADC_MspInit(adc_handle);\n  }\n  status = ADC_ConversionStop_Disable(adc_handle);\n  if (((adc_handle->State & 0x10) == 0) && (status == HAL_OK)) {\n    adc_handle->State = adc_handle->State & 0xffffeefd | 2;\n    value_5 = (adc_handle->Init).ContinuousConvMode;\n    value_3 = (adc_handle->Init).DataAlign | (adc_handle->Init).ExternalTrigConv | value_5 << 1;\n    value_2 = (adc_handle->Init).ScanConvMode;\n    if (value_2 == 0x100) {\n      value_4 = 0x100;\n    }\n    else {\n      value_4 = 0;\n      if (value_2 == 1) {\n        value_4 = 0x100;\n      }\n    }\n    if ((adc_handle->Init).DiscontinuousConvMode == 1) {\n      if (value_5 == 0) {\n        value_4 = value_4 | ((adc_handle->Init).NbrOfDiscConversion - 1) * 0x2000 | 0x800;\n      }\n      else {\n        adc_handle->State = adc_handle->State | 0x20;\n        adc_handle->ErrorCode = adc_handle->ErrorCode | 1;\n      }\n    }\n    adc_handle->Instance->CR1 = value_4 | adc_handle->Instance->CR1 & 0xffff16ff;\n    adc_handle->Instance->CR2 = adc_handle->Instance->CR2 & 0xffe1f7fd | value_3;\n    value_2 = (adc_handle->Init).ScanConvMode;\n    if ((value_2 == 0x100) || (value_2 == 1)) {\n      value_4 = ((adc_handle->Init).NbrOfConversion - 1) * 0x100000;\n    }\n    else {\n      value_4 = 0;\n    }\n    adc_handle->Instance->SQR1 = value_4 | adc_handle->Instance->SQR1 & 0xff0fffff;\n    if (value_3 != (adc_handle->Instance->CR2 & 0xff1f0efe)) {\n      adc_handle->State = adc_handle->State & 0xffffffed | 0x10;\n      adc_handle->ErrorCode = adc_handle->ErrorCode | 1;\n      return HAL_ERROR;\n    }\n    adc_handle->ErrorCode = 0;\n    adc_handle->State = adc_handle->State & 0xfffffffc | 1;\n    return HAL_OK;\n  }\n  adc_handle->State = adc_handle->State | 0x10;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_0800213c": "initialize_adc_0800213c",
                "hadc": "adc_handle",
                "HVar1": "status",
                "uVar2": "value_2",
                "uVar3": "value_3",
                "uVar4": "value_4",
                "uVar5": "value_5"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800224c": {
            "entrypoint": "0x0800224c",
            "current_name": "stop_adc_conversion_and_reset_0800224c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict stopADCConversionAndReset_0800224c(ADC_HandleTypeDef *adcHandle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  \n  if (adcHandle == (ADC_HandleTypeDef *)0x0) {\n    status = HAL_STATUS_ERROR;\n  }\n  else {\n    adcHandle->state = adcHandle->state | 2;\n    status = stopADCConversion(adcHandle);\n    if (status == HAL_OK) {\n      adcHandle->adcInstance->statusRegister = 0xffffffe0;\n      adcHandle->adcInstance->controlRegister1 = adcHandle->adcInstance->controlRegister1 & 0xff3f0000;\n      adcHandle->adcInstance->controlRegister2 = adcHandle->adcInstance->controlRegister2 & 0xff0106f0;\n      adcHandle->adcInstance->samplingTimeRegister1 = adcHandle->adcInstance->samplingTimeRegister1 & 0xff000000;\n      adcHandle->adcInstance->samplingTimeRegister2 = adcHandle->adcInstance->samplingTimeRegister2 & 0xc0000000;\n      adcHandle->adcInstance->offsetRegister1 = adcHandle->adcInstance->offsetRegister1 & 0xfffff000;\n      adcHandle->adcInstance->offsetRegister2 = adcHandle->adcInstance->offsetRegister2 & 0xfffff000;\n      adcHandle->adcInstance->offsetRegister3 = adcHandle->adcInstance->offsetRegister3 & 0xfffff000;\n      adcHandle->adcInstance->offsetRegister4 = adcHandle->adcInstance->offsetRegister4 & 0xfffff000;\n      adcHandle->adcInstance->highThresholdRegister = adcHandle->adcInstance->highThresholdRegister & 0xfffff000;\n      adcHandle->adcInstance->lowThresholdRegister = adcHandle->adcInstance->lowThresholdRegister & 0xfffff000;\n      adcHandle->adcInstance->regularSequenceRegister1 = adcHandle->adcInstance->regularSequenceRegister1 & 0xff000000;\n      adcHandle->adcInstance->regularSequenceRegister1 = adcHandle->adcInstance->regularSequenceRegister1 & 0xff000000;\n      adcHandle->adcInstance->regularSequenceRegister2 = adcHandle->adcInstance->regularSequenceRegister2 & 0xc0000000;\n      adcHandle->adcInstance->regularSequenceRegister3 = adcHandle->adcInstance->regularSequenceRegister3 & 0xc0000000;\n      adcHandle->adcInstance->injectedSequenceRegister = adcHandle->adcInstance->injectedSequenceRegister & 0xffc00000;\n      adcHandle->adcInstance->injectedSequenceRegister = adcHandle->adcInstance->injectedSequenceRegister & 0xffc00000;\n      deinitializeADCPeripheral(adcHandle);\n      adcHandle->WMBstatusRegisterWPTKD = 0;\n      adcHandle->state = 0;\n    }\n    adcHandle->lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800224c": "stop_adc_conversion_and_reset_0800224c",
                "hadc": "adcHandle",
                "HVar1": "status",
                "HAL_ERROR": "HAL_STATUS_ERROR",
                "State": "state",
                "ADC_ConversionStop_Disable": "stopADCConversion",
                "Instance": "adcInstance",
                "SR": "statusRegister",
                "CR1": "controlRegister1",
                "CR2": "controlRegister2",
                "SMPR1": "samplingTimeRegister1",
                "SMPR2": "samplingTimeRegister2",
                "JOFR1": "offsetRegister1",
                "JOFR2": "offsetRegister2",
                "JOFR3": "offsetRegister3",
                "JOFR4": "offsetRegister4",
                "HTR": "highThresholdRegister",
                "LTR": "lowThresholdRegister",
                "SQR1": "regularSequenceRegister1",
                "SQR2": "regularSequenceRegister2",
                "SQR3": "regularSequenceRegister3",
                "JSQR": "injectedSequenceRegister",
                "HAL_ADC_MspDeInit": "deinitializeADCPeripheral",
                "ErrorCode": "errorCode",
                "Lock": "lock"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002348": {
            "entrypoint": "0x08002348",
            "current_name": "stop_and_disable_conversion_08002348",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict stopAndDisableConversion_08002348(ADC_HandleTypeDef *adcHandler)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  \n  if (adcHandler->Lock == LOCKED) {\n    return BUSY;\n  }\n  adcHandler->Lock = LOCKED;\n  status = stopConversionAndDisable(adcHandler);\n  if (status == OK) {\n    adcHandler->State = adcHandler->State & 0xffffeefe | 1;\n  }\n  adcHandler->Lock = UNLOCKED;\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002348": "stop_and_disable_conversion_08002348",
                "hadc": "adcHandler",
                "HVar1": "status",
                "HAL_LOCKED": "LOCKED",
                "HAL_BUSY": "BUSY",
                "HAL_OK": "OK",
                "HAL_UNLOCKED": "UNLOCKED",
                "ADC_ConversionStop_Disable": "stopConversionAndDisable"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002384": {
            "entrypoint": "0x08002384",
            "current_name": "initialize_adc_08002384",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initialize_ADC_08002384(ADC_HandleTypeDef *adc_handle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t clock_frequency;\n  uint32_t system_clock;\n  ADC_TypeDef *adc_instance;\n  uint32_t start_tick;\n  uint32_t loop_index;\n  \n  if (adc_handle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  adc_handle->Lock = HAL_LOCKED;\n  status = ADC_ConversionStop_Disable(adc_handle);\n  if (status == HAL_OK) {\n    adc_handle->State = adc_handle->State & 0xffffeefd | 2;\n    system_clock = SystemCoreClock;\n    clock_frequency = HAL_RCCEx_GetPeriphCLKFreq(2);\n    for (loop_index = system_clock / clock_frequency << 1; loop_index != 0;\n        loop_index = loop_index - 1) {\n    }\n    ADC_Enable(adc_handle);\n    adc_handle->Instance->CR2 = adc_handle->Instance->CR2 | 8;\n    system_clock = HAL_GetTick();\n    while (adc_instance = adc_handle->Instance, (adc_instance->CR2 & 8) != 0) {\n      clock_frequency = HAL_GetTick();\n      if (10 < clock_frequency - system_clock) {\n        adc_handle->State = adc_handle->State & 0xffffffed | 0x10;\n        adc_handle->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adc_instance->CR2 = adc_instance->CR2 | 4;\n    system_clock = HAL_GetTick();\n    while ((adc_handle->Instance->CR2 & 4) != 0) {\n      clock_frequency = HAL_GetTick();\n      if (10 < clock_frequency - system_clock) {\n        adc_handle->State = adc_handle->State & 0xffffffed | 0x10;\n        adc_handle->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adc_handle->State = adc_handle->State & 0xfffffffc | 1;\n  }\n  adc_handle->Lock = HAL_UNLOCKED;\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002384": "initialize_adc_08002384",
                "hadc": "adc_handle",
                "HVar1": "status",
                "uVar2": "clock_frequency",
                "uVar3": "system_clock",
                "pAVar4": "adc_instance",
                "tickstart": "start_tick",
                "wait_loop_index": "loop_index"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_GetTick",
                "ADC_ConversionStop_Disable",
                "HAL_RCCEx_GetPeriphCLKFreq",
                "ADC_Enable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002470": {
            "entrypoint": "0x08002470",
            "current_name": "initialize_priority_group_08002470",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializePriorityGroup_08002470(uint32_t newPriorityGroup)\n\n{\n  uint32_t registerValue;\n  \n  _DAT_e000ed0c = (newPriorityGroup & 7) << 8 | _DAT_e000ed0c & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002470": "initialize_priority_group_08002470",
                "PriorityGroup": "newPriorityGroup",
                "reg_value": "registerValue"
            },
            "calling": [
                "premain",
                "HAL_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002494": {
            "entrypoint": "0x08002494",
            "current_name": "configure_interrupt_priority_08002494",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureInterruptPriority_08002494(interruptNumber_Type_conflict interruptNumber,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint interruptNum;\n  uint priorityGroupIndex;\n  uint32_t priorityGroupTemp;\n  uint32_t subPriorityBits;\n  uint32_t preemptPriorityBits;\n  \n  interruptNum = (uint)interruptNumber;\n  priorityGroupIndex = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  preemptPriorityBits = 7 - priorityGroupIndex;\n  if (3 < preemptPriorityBits) {\n    preemptPriorityBits = 4;\n  }\n  if (priorityGroupIndex + 4 < 7) {\n    subPriorityBits = 0;\n  }\n  else {\n    subPriorityBits = priorityGroupIndex - 3;\n  }\n  priorityGroupIndex = (preemptPriority & (1 << (preemptPriorityBits & 0xff)) - 1U) << (subPriorityBits & 0xff) |\n          (1 << (subPriorityBits & 0xff)) - 1U & subPriority;\n  if ((int)interruptNum < 0) {\n    *(char *)((interruptNum & 0xf) + 0xe000ed14) = (char)(priorityGroupIndex << 4);\n  }\n  else {\n    *(char *)(interruptNum + 0xe000e400) = (char)(priorityGroupIndex << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002494": "configure_interrupt_priority_08002494",
                "IRQn": "interruptNumber",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "uVar1": "interruptNum",
                "uVar2": "priorityGroupIndex",
                "PriorityGroupTmp": "priorityGroupTemp",
                "SubPriorityBits": "subPriorityBits",
                "PreemptPriorityBits": "preemptPriorityBits"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback",
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080024f8": {
            "entrypoint": "0x080024f8",
            "current_name": "set_interrupt_flag_080024f8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setInterruptFlag_080024f8(interruptNumber_Type_conflict interruptNumber)\n\n{\n  uint convertedNumber;\n  \n  convertedNumber = (uint)interruptNumber;\n  if (-1 < (int)convertedNumber) {\n    *(int *)((convertedNumber >> 5) * 4 + -0x1fff1f00) = 1 << (convertedNumber & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080024f8": "set_interrupt_flag_080024f8",
                "IRQn": "interruptNumber",
                "uVar1": "convertedNumber"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002514": {
            "entrypoint": "0x08002514",
            "current_name": "initialize_system_08002514",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t initializeSystem_08002514(uint32_t ticks)\n\n{\n  if (ticks - 1 < 0x1000000) {\n    _DAT_e000e014 = ticks - 1;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002514": "initialize_system_08002514",
                "TicksNumb": "ticks"
            },
            "calling": [
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002540": {
            "entrypoint": "0x08002540",
            "current_name": "set_interrupt_enable_bit_08002540",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setInterruptEnableBit_08002540(irqNumber_Type_conflict irqNumber)\n\n{\n  uint convertedIRQn;\n  \n  convertedIRQn = (uint)irqNumber;\n  if (-1 < (int)convertedIRQn) {\n    *(int *)(((convertedIRQn >> 5) + 0x60) * 4 + -0x1fff1f00) = 1 << (convertedIRQn & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002540": "set_interrupt_enable_bit_08002540",
                "IRQn": "irqNumber",
                "uVar1": "convertedIRQn"
            },
            "calling": [
                "USART2_IRQHandler",
                "USART3_IRQHandler",
                "USART1_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002560": {
            "entrypoint": "0x08002560",
            "current_name": "configure_clock_source_08002560",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureClockSource_08002560(uint32_t source)\n\n{\n  if (source != 4) {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n    return;\n  }\n  _DAT_e000e010 = _DAT_e000e010 | 4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002560": "configure_clock_source_08002560",
                "CLKSource": "source"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002580": {
            "entrypoint": "0x08002580",
            "current_name": "FUNC_08002580",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002580(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002580": "FUNC_08002580"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002582": {
            "entrypoint": "0x08002582",
            "current_name": "init_hal_systick_08002582",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid init_HAL_SYSTICK_08002582(void)\n\n{\n  handle_SYSTICK_Callback();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002582": "init_hal_systick_08002582",
                "HAL_SYSTICK_Callback": "handle_SYSTICK_Callback"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800258c": {
            "entrypoint": "0x0800258c",
            "current_name": "set_dma_channel_priority_0800258c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef set_DMA_channel_priority_0800258c(DMA_HandleTypeDef *dma_handle)\n\n{\n  DMA_Channel_TypeDef *channel_instance;\n  \n  if (dma_handle->State != DMA_STATE_BUSY) {\n    dma_handle->ErrorCode = 4;\n    return HAL_ERROR;\n  }\n  dma_handle->Instance->CCR = dma_handle->Instance->CCR & 0xfffffff1;\n  dma_handle->Instance->CCR = dma_handle->Instance->CCR & 0xfffffffe;\n  channel_instance = dma_handle->Instance;\n  if (channel_instance == (DMA_Channel_TypeDef *)0x40020008) {\n    _DAT_40020004 = 1;\n  }\n  else if (channel_instance == (DMA_Channel_TypeDef *)0x4002001c) {\n    _DAT_40020004 = 0x10;\n  }\n  else if (channel_instance == (DMA_Channel_TypeDef *)0x40020030) {\n    _DAT_40020004 = 0x100;\n  }\n  else if (channel_instance == (DMA_Channel_TypeDef *)0x40020044) {\n    _DAT_40020004 = 0x1000;\n  }\n  else if (channel_instance == (DMA_Channel_TypeDef *)0x40020058) {\n    _DAT_40020004 = 0x10000;\n  }\n  else if (channel_instance == (DMA_Channel_TypeDef *)0x4002006c) {\n    _DAT_40020004 = 0x100000;\n  }\n  else {\n    _DAT_40020004 = 0x1000000;\n  }\n  dma_handle->State = HAL_DMA_STATE_READY;\n  dma_handle->Lock = HAL_UNLOCKED;\n  if (dma_handle->XferAbortCallback != (callback_function *)0x0) {\n    (*dma_handle->XferAbortCallback)(dma_handle);\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800258c": "set_dma_channel_priority_0800258c",
                "hdma": "dma_handle",
                "pDVar1": "channel_instance",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_DMA_STATE_BUSY": "DMA_STATE_BUSY",
                "_func_void___DMA_HandleTypeDef_ptr": "callback_function"
            },
            "calling": [
                "I2C_ITError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002624": {
            "entrypoint": "0x08002624",
            "current_name": "configure_gpio_08002624",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureGPIO_08002624(GPIO_TypeDef *gpioPort,gpioConfigTypeDef *gpioConfig)\n\n{\n  GPIO_TypeDef *gpio;\n  uint pinMask;\n  uint pinFlag;\n  uint pinIndex;\n  uint gpioMode;\n  uint32_t gpioSpeed;\n  int portOffset;\n  uint32_t *gpioConfigReg;\n  int portIndex;\n  uint32_t tempReg;\n  \n  gpioSpeed = 0;\n  pinIndex = 0;\n  do {\n    if (0xf < pinIndex) {\n      return;\n    }\n    pinMask = 1 << (pinIndex & 0xff);\n    pinFlag = gpioConfig->Pin & pinMask;\n    if (pinMask == pinFlag) {\n      gpioMode = gpioConfig->Mode;\n      if (gpioMode == 0x12) {\n        gpioSpeed = gpioConfig->Speed + 0xc;\n      }\n      else if (gpioMode < 0x13) {\n        if (gpioMode == 2) {\n          gpioSpeed = gpioConfig->Speed + 8;\n        }\n        else if (gpioMode < 3) {\n          if (gpioMode == 0) goto LAB_08002776;\n          if (gpioMode == 1) {\n            gpioSpeed = gpioConfig->Speed;\n          }\n        }\n        else if (gpioMode == 3) {\n          gpioSpeed = 0;\n        }\n        else if (gpioMode == 0x11) {\n          gpioSpeed = gpioConfig->Speed + 4;\n        }\n      }\n      else if (gpioMode == 0x10210000) {\nLAB_08002776:\n        if (gpioConfig->Pull == 0) {\n          gpioSpeed = 4;\n        }\n        else if (gpioConfig->Pull == 1) {\n          gpioPort->BSRR = pinMask;\n          gpioSpeed = 8;\n        }\n        else {\n          gpioPort->BRR = pinMask;\n          gpioSpeed = 8;\n        }\n      }\n      else if (gpioMode < 0x10210001) {\n        if ((gpioMode == 0x10110000) || (gpioMode == 0x10120000)) goto LAB_08002776;\n      }\n      else if ((gpioMode == 0x10310000) || ((gpioMode == 0x10320000 || (gpioMode == 0x10220000))))\n      goto LAB_08002776;\n      pinMask = pinIndex;\n      gpio = gpioPort;\n      if (0xff < pinFlag) {\n        pinMask = pinIndex - 8;\n        gpio = (GPIO_TypeDef *)&gpioPort->CRH;\n      }\n      gpio->CRL = gpio->CRL & ~(0xf << (pinMask << 2 & 0xff)) | gpioSpeed << (pinMask << 2 & 0xff);\n      if ((gpioConfig->Mode & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        portOffset = (pinIndex & 3) << 2;\n        if (gpioPort == (GPIO_TypeDef *)0x40010800) {\n          portIndex = 0;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40010c00) {\n          portIndex = 1;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40011000) {\n          portIndex = 2;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40011400) {\n          portIndex = 3;\n        }\n        else {\n          portIndex = 4;\n        }\n        *(uint *)(((pinIndex >> 2) + 2) * 4 + 0x40010000) =\n             *(uint *)(((pinIndex >> 2) + 2) * 4 + 0x40010000) & ~(0xf << portOffset) | portIndex << portOffset;\n        if ((gpioConfig->Mode & 0x10000) == 0) {\n          _DAT_40010400 = _DAT_40010400 & ~pinFlag;\n        }\n        else {\n          _DAT_40010400 = _DAT_40010400 | pinFlag;\n        }\n        if ((gpioConfig->Mode & 0x20000) == 0) {\n          _DAT_40010404 = _DAT_40010404 & ~pinFlag;\n        }\n        else {\n          _DAT_40010404 = _DAT_40010404 | pinFlag;\n        }\n        if ((gpioConfig->Mode & 0x100000) == 0) {\n          _DAT_40010408 = _DAT_40010408 & ~pinFlag;\n        }\n        else {\n          _DAT_40010408 = _DAT_40010408 | pinFlag;\n        }\n        if ((gpioConfig->Mode & 0x200000) == 0) {\n          _DAT_4001040c = _DAT_4001040c & ~pinFlag;\n        }\n        else {\n          _DAT_4001040c = pinFlag | _DAT_4001040c;\n        }\n      }\n    }\n    pinIndex = pinIndex + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08002624": "configure_gpio_08002624",
                "GPIOx": "gpioPort",
                "GPIO_Init": "gpioConfig",
                "pGVar1": "gpio",
                "uVar2": "pinMask",
                "uVar3": "pinFlag",
                "uVar4": "pinIndex",
                "uVar5": "gpioMode",
                "uVar6": "gpioSpeed",
                "configregister": "gpioConfigReg",
                "iVar7": "portOffset",
                "iVar8": "portIndex",
                "tmpreg": "tempReg"
            },
            "calling": [
                "digital_io_init",
                "uart_init",
                "HAL_ADC_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002810": {
            "entrypoint": "0x08002810",
            "current_name": "check_pin_state_08002810",
            "code": "\n/* WARNING: Unknown calling convention */\n\npinState checkPinState_08002810(GPIO_TypeDef *gpio,uint16_t pin)\n\n{\n  pinState status;\n  \n  if (((uint)pin & gpio->IDR) == 0) {\n    status = GPIO_PIN_RESET;\n    return status;\n  }\n  return GPIO_PIN_SET;\n}\n\n",
            "renaming": {
                "FUN_08002810": "check_pin_state_08002810",
                "GPIOx": "gpio",
                "GPIO_Pin": "pin",
                "bitstatus": "status"
            },
            "calling": [
                "digital_io_read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800281e": {
            "entrypoint": "0x0800281e",
            "current_name": "set_pin_state_0800281e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinState_0800281e(GPIO_TypeDef *gpioPort,uint16_t pinNumber,pinNumberState pinState)\n\n{\n  if (pinState == GPIO_PIN_RESET) {\n    gpioPort->BSRR = (uint)pinNumber << 0x10;\n    return;\n  }\n  gpioPort->BSRR = (uint)pinNumber;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800281e": "set_pin_state_0800281e",
                "GPIOx": "gpioPort",
                "GPIO_Pin": "pinNumber",
                "PinState": "pinState"
            },
            "calling": [
                "digital_io_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800282c": {
            "entrypoint": "0x0800282c",
            "current_name": "handle_gpio_pin_0800282c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_Pin_0800282c(uint16_t pin)\n\n{\n  if ((_DAT_40010414 & pin) != 0) {\n    _DAT_40010414 = (uint)pin;\n    handle_ext_interrupt(pin);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800282c": "handle_gpio_pin_0800282c",
                "GPIO_Pin": "pin",
                "HAL_GPIO_EXTI_Callback": "handle_ext_interrupt"
            },
            "calling": [
                "EXTI4_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI15_10_IRQHandler",
                "EXTI2_IRQHandler",
                "EXTI9_5_IRQHandler",
                "EXTI0_IRQHandler",
                "EXTI1_IRQHandler"
            ],
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002848": {
            "entrypoint": "0x08002848",
            "current_name": "set_i2_c_device_address_08002848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict setI2CDeviceAddress_08002848(I2C_HandleTypeDef *i2cHandle)\n\n{\n  if (i2cHandle->i2cMode == HAL_I2C_MODE_MEM) {\n    if (i2cHandle->eventCount == 0) {\n      i2cHandle->Instance->deviceRegister = i2cHandle->deviceAddress & 0xfe;\n    }\n    else {\n      i2cHandle->Instance->deviceRegister = i2cHandle->deviceAddress & 0xff | 1;\n    }\n  }\n  else if ((i2cHandle->Init).addressingMode == 0x4000) {\n    if (i2cHandle->i2cState == HAL_I2C_STATE_BUSY_TX) {\n      i2cHandle->Instance->deviceRegister = i2cHandle->deviceAddress & 0xfe;\n    }\n    else {\n      i2cHandle->Instance->deviceRegister = i2cHandle->deviceAddress & 0xff | 1;\n    }\n  }\n  else if (i2cHandle->eventCount == 0) {\n    i2cHandle->Instance->deviceRegister = (i2cHandle->deviceAddress << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (i2cHandle->eventCount == 1) {\n    i2cHandle->Instance->deviceRegister = (i2cHandle->deviceAddress << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return HAL_StatusTypeDef_OK;\n}\n\n",
            "renaming": {
                "FUN_08002848": "set_i2_c_device_address_08002848",
                "hi2c": "i2cHandle",
                "Mode": "i2cMode",
                "EventCount": "eventCount",
                "AddressingMode": "addressingMode",
                "State": "i2cState",
                "DR": "deviceRegister",
                "Devaddress": "deviceAddress",
                "HAL_OK": "HAL_StatusTypeDef_OK"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028d2": {
            "entrypoint": "0x080028d2",
            "current_name": "set_i2_c_device_address_080028d2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict setI2CDeviceAddress_080028d2(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2cHandle->Instance->DR = i2cHandle->Devaddress & 0xff;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080028d2": "set_i2_c_device_address_080028d2",
                "hi2c": "i2cHandle"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028de": {
            "entrypoint": "0x080028de",
            "current_name": "handle_i2_c_state_transition_080028de",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CStateTransition_080028de(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t temporaryVar1;\n  I2C_TypeDef *i2cInstance;\n  uint32_t previousState;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister1;\n  uint32_t temporaryRegister2;\n  uint32_t temporaryRegister3;\n  uint32_t temporaryRegister4;\n  uint32_t temporaryRegister5;\n  uint32_t temporaryRegister6;\n  uint32_t temporaryRegister7;\n  uint32_t temporaryRegister8;\n  uint32_t temporaryRegister9;\n  uint32_t temporaryRegister10;\n  \n  temporaryVar1 = i2cHandle->XferOptions;\n  if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) &&\n     ((i2cHandle->EventCount != 0 || (i2cHandle->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((i2cHandle->EventCount == 0) && ((i2cHandle->Init).AddressingMode == 0xc000)) {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n      i2cHandle->EventCount = i2cHandle->EventCount + 1;\n    }\n    else {\n      if (i2cHandle->XferCount == 0) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      }\n      else if (i2cHandle->XferCount == 1) {\n        if (temporaryVar1 == 0xffff0000) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cInstance = i2cHandle->Instance;\n          if ((i2cInstance->CR2 & 0x800) == 0) {\n            i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n          }\n          else {\n            i2cInstance->CR1 = i2cInstance->CR1 & 0xfffffbff;\n          }\n        }\n        else if (((temporaryVar1 == 4) || (temporaryVar1 == 8)) || (i2cHandle->PreviousState == 0x12)) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        }\n        else if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n      }\n      else if (i2cHandle->XferCount == 2) {\n        if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x800;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      else {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      i2cHandle->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080028de": "handle_i2_c_state_transition_080028de",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "uVar1": "temporaryVar1",
                "pIVar2": "i2cInstance",
                "Prev_State": "previousState",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister1",
                "tmpreg_2": "temporaryRegister2",
                "tmpreg_3": "temporaryRegister3",
                "tmpreg_4": "temporaryRegister4",
                "tmpreg_5": "temporaryRegister5",
                "tmpreg_6": "temporaryRegister6",
                "tmpreg_7": "temporaryRegister7",
                "tmpreg_8": "temporaryRegister8",
                "tmpreg_9": "temporaryRegister9",
                "tmpreg_10": "temporaryRegister10"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ab8": {
            "entrypoint": "0x08002ab8",
            "current_name": "write_byte_08002ab8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict writeByte_08002ab8(I2C_HandleTypeDef *i2c_handle)\n\n{\n  byte *pbVar1;\n  \n  if (i2c_handle->transfer_count != 0) {\n    pbVar1 = i2c_handle->buffer_pointer;\n    i2c_handle->buffer_pointer = pbVar1 + 1;\n    i2c_handle->i2c_instance->data_register = (uint)*pbVar1;\n    i2c_handle->transfer_count = i2c_handle->transfer_count - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002ab8": "write_byte_08002ab8",
                "hi2c": "i2c_handle",
                "XferCount": "transfer_count",
                "pBuffPtr": "buffer_pointer",
                "Instance": "i2c_instance",
                "DR": "data_register"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad8": {
            "entrypoint": "0x08002ad8",
            "current_name": "transfer_from_i2_c_08002ad8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nTransferStatus transferFromI2C_08002ad8(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint8_t *bufferPtr;\n  \n  if (i2cHandle->transferCount != 0) {\n    bufferPtr = i2cHandle->bufferPointer;\n    i2cHandle->bufferPointer = bufferPtr + 1;\n    *bufferPtr = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002ad8": "transfer_from_i2_c_08002ad8",
                "hi2c": "i2cHandle",
                "puVar1": "bufferPtr",
                "XferCount": "transferCount",
                "pBuffPtr": "bufferPointer",
                "Instance": "i2cInstance",
                "DR": "dataRegister",
                "HAL_StatusTypeDef_conflict": "TransferStatus"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002af8": {
            "entrypoint": "0x08002af8",
            "current_name": "configure_i2_c_08002af8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_Status\nconfigureI2C_08002af8(I2C_HandleTypeDef *i2cHandle,uint8_t *data,uint16_t size,uint32_t transferOptions)\n\n{\n  HAL_Status HVar1;\n  I2C_RegistersTypeDef *pIVar2;\n  uint32_t temporaryRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == (uint8_t *)0x0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (size == 0) {\n      HVar1 = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      HVar1 = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      pIVar2 = i2cHandle->Instance;\n      if ((pIVar2->controlRegister1 & 1) == 0) {\n        pIVar2->controlRegister1 = pIVar2->controlRegister1 | 1;\n      }\n      i2cHandle->Instance->controlRegister1 = i2cHandle->Instance->controlRegister1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      HVar1 = HAL_OK;\n      i2cHandle->errorCode = 0;\n      i2cHandle->bufferPointer = data;\n      i2cHandle->transferCount = size;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->transferSize = i2cHandle->transferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->controlRegister2 = i2cHandle->Instance->controlRegister2 | 0x700;\n    }\n  }\n  else {\n    HVar1 = HAL_BUSY;\n  }\n  return HVar1;\n}\n\n",
            "renaming": {
                "FUN_08002af8": "configure_i2_c_08002af8",
                "hi2c": "i2cHandle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "transferOptions",
                "HAL_StatusTypeDef_conflict": "HAL_Status",
                "I2C_TypeDef": "I2C_RegistersTypeDef",
                "tmpreg": "temporaryRegister",
                "CR1": "controlRegister1",
                "ErrorCode": "errorCode",
                "pBuffPtr": "bufferPointer",
                "XferCount": "transferCount",
                "XferSize": "transferSize",
                "CR2": "controlRegister2"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002b84": {
            "entrypoint": "0x08002b84",
            "current_name": "configure_i2_c_08002b84",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nconfigureI2C_08002b84(I2C_HandleTypeDef *i2cHandle,uint8_t *data,uint16_t size,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef *i2cInstance;\n  uint32_t temporaryRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = data;\n      i2cHandle->XferCount = size;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->Xfersize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002b84": "configure_i2_c_08002b84",
                "hi2c": "i2cHandle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c10": {
            "entrypoint": "0x08002c10",
            "current_name": "configure_i2_c_08002c10",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatus configureI2C_08002c10(I2C_HandleTypeDef *i2cHandle)\n\n{\n  TypeDef *i2cInstance;\n  \n  if (i2cHandle->State != Ready) {\n    return Busy;\n  }\n  i2cHandle->State = Listen;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->ControlRegister1 & 1) == 0) {\n    i2cInstance->ControlRegister1 = i2cInstance->ControlRegister1 | 1;\n  }\n  i2cHandle->Instance->ControlRegister1 = i2cHandle->Instance->ControlRegister1 | 0x400;\n  i2cHandle->Instance->ControlRegister2 = i2cHandle->Instance->ControlRegister2 | 0x300;\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_08002c10": "configure_i2_c_08002c10",
                "hi2c": "i2cHandle",
                "pIVar1": "i2cInstance",
                "HAL_StatusTypeDef_conflict": "Status",
                "HAL_I2C_STATE_READY": "Ready",
                "HAL_BUSY": "Busy",
                "HAL_I2C_STATE_LISTEN": "Listen",
                "I2C_TypeDef": "TypeDef",
                "CR1": "ControlRegister1",
                "CR2": "ControlRegister2",
                "HAL_OK": "OK"
            },
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c4e": {
            "entrypoint": "0x08002c4e",
            "current_name": "FUNC_08002c4e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002c4e(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c4e": "FUNC_08002c4e"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002c50": {
            "entrypoint": "0x08002c50",
            "current_name": "FUNC_08002c50",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002c50(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c50": "FUNC_08002c50"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002c52": {
            "entrypoint": "0x08002c52",
            "current_name": "FUNC_08002c52",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002c52(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c52": "FUNC_08002c52"
            },
            "calling": [
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_AF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002c54": {
            "entrypoint": "0x08002c54",
            "current_name": "process_i2_c_data_08002c54",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict processI2CData_08002c54(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef i2cState;\n  byte *bufferPtr;\n  \n  i2cState = i2cHandle->State;\n  if (i2cHandle->XferCount != 0) {\n    bufferPtr = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPtr + 1;\n    i2cHandle->Instance->DR = (uint)*bufferPtr;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    if ((i2cHandle->XferCount == 0) && (i2cState == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      i2cHandle->PreviousState = 0x21;\n      i2cHandle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(i2cHandle);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002c54": "process_i2_c_data_08002c54",
                "hi2c": "i2cHandle",
                "HVar1": "i2cState",
                "pbVar2": "bufferPtr"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca4": {
            "entrypoint": "0x08002ca4",
            "current_name": "FUNC_08002ca4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002ca4(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ca4": "FUNC_08002ca4"
            },
            "calling": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca6": {
            "entrypoint": "0x08002ca6",
            "current_name": "handle_i2_c_received_data_08002ca6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CReceivedData_08002ca6(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  uint8_t *dataPointer;\n  \n  currentState = i2cHandle->State;\n  if (i2cHandle->XferCount != 0) {\n    dataPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = dataPointer + 1;\n    *dataPointer = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    if ((i2cHandle->XferCount == 0) && (currentState == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      i2cHandle->PreviousState = 0x22;\n      i2cHandle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002ca6": "handle_i2_c_received_data_08002ca6",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "puVar2": "dataPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002cf2": {
            "entrypoint": "0x08002cf2",
            "current_name": "handle_i2_c_address_match_08002cf2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CAddressMatch_08002cf2(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint16_t addressMatchCode;\n  \n  if ((i2cHandle->Instance->SR2 & 0x80) == 0) {\n    addressMatchCode = *(uint16_t *)&(i2cHandle->Init).OwnAddress1;\n  }\n  else {\n    addressMatchCode = *(uint16_t *)&(i2cHandle->Init).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(i2cHandle,(i2cHandle->Instance->SR2 & 4) == 0,addressMatchCode);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002cf2": "handle_i2_c_address_match_08002cf2",
                "hi2c": "i2cHandle",
                "AddrMatchCode": "addressMatchCode"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d1c": {
            "entrypoint": "0x08002d1c",
            "current_name": "handle_i2_c_state_08002d1c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CState_08002d1c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t currentState;\n  \n  if (((i2cHandle->XferOptions == 4) || (i2cHandle->XferOptions == 8)) &&\n     (i2cHandle->State == HAL_I2C_STATE_LISTEN)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandle);\n  }\n  else if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->PreviousState = 0x21;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback(i2cHandle);\n  }\n  else {\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002d1c": "handle_i2_c_state_08002d1c",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "CurrentState": "currentState"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002db0": {
            "entrypoint": "0x08002db0",
            "current_name": "FUNC_08002db0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002db0(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002db0": "FUNC_08002db0"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002db2": {
            "entrypoint": "0x08002db2",
            "current_name": "update_i2_c_state_08002db2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict updateI2CState_08002db2(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_i2cStateTypeDef currentState;\n  uint32_t currentI2CState;\n  byte *bufferPointer;\n  uint32_t currentTransferOptions;\n  uint32_t transferOptions;\n  \n  currentState = i2cHandle->i2cState;\n  transferOptions = i2cHandle->transferOptions;\n  if ((i2cHandle->transferSize == 0) && (currentState == HAL_I2C_STATE_BUSY_TX)) {\n    if ((transferOptions == 4) || ((transferOptions == 8 || (transferOptions == 0xffff0000)))) {\n      i2cHandle->i2cInstance->cr2Register = i2cHandle->i2cInstance->cr2Register & 0xfffff8ff;\n      i2cHandle->i2cInstance->cr1Register = i2cHandle->i2cInstance->cr1Register | 0x200;\n      i2cHandle->previousI2CState = 0;\n      i2cHandle->i2cState = HAL_I2C_STATE_READY;\n      if (i2cHandle->i2cMode == HAL_I2C_MODE_MEM) {\n        i2cHandle->i2cMode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(i2cHandle);\n      }\n      else {\n        i2cHandle->i2cMode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      i2cHandle->i2cInstance->cr2Register = i2cHandle->i2cInstance->cr2Register & 0xfffff8ff;\n      i2cHandle->previousI2CState = 0x11;\n      i2cHandle->i2cMode = HAL_I2C_MODE_NONE;\n      i2cHandle->i2cState = HAL_I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(i2cHandle);\n    }\n  }\n  else if ((currentState == HAL_I2C_STATE_BUSY_TX) ||\n          ((i2cHandle->i2cMode == HAL_I2C_MODE_MEM && (currentState == HAL_I2C_STATE_BUSY_RX)))) {\n    if (i2cHandle->transferCount == 0) {\n      i2cHandle->i2cInstance->cr2Register = i2cHandle->i2cInstance->cr2Register & 0xfffffbff;\n    }\n    else if (i2cHandle->i2cMode == HAL_I2C_MODE_MEM) {\n      if (i2cHandle->eventCount == 0) {\n        if (i2cHandle->memoryAddressSize == 1) {\n          i2cHandle->i2cInstance->dataRegister = i2cHandle->memoryAddress & 0xff;\n          i2cHandle->eventCount = i2cHandle->eventCount + 2;\n        }\n        else {\n          i2cHandle->i2cInstance->dataRegister = (i2cHandle->memoryAddress << 0x10) >> 0x18;\n          i2cHandle->eventCount = i2cHandle->eventCount + 1;\n        }\n      }\n      else if (i2cHandle->eventCount == 1) {\n        i2cHandle->i2cInstance->dataRegister = i2cHandle->memoryAddress & 0xff;\n        i2cHandle->eventCount = i2cHandle->eventCount + 1;\n      }\n      else if (i2cHandle->eventCount == 2) {\n        if (i2cHandle->i2cState == HAL_I2C_STATE_BUSY_RX) {\n          i2cHandle->i2cInstance->cr1Register = i2cHandle->i2cInstance->cr1Register | 0x100;\n        }\n        else if (i2cHandle->i2cState == HAL_I2C_STATE_BUSY_TX) {\n          bufferPointer = i2cHandle->bufferPointer;\n          i2cHandle->bufferPointer = bufferPointer + 1;\n          i2cHandle->i2cInstance->dataRegister = (uint)*bufferPointer;\n          i2cHandle->transferCount = i2cHandle->transferCount - 1;\n        }\n      }\n    }\n    else {\n      bufferPointer = i2cHandle->bufferPointer;\n      i2cHandle->bufferPointer = bufferPointer + 1;\n      i2cHandle->i2cInstance->dataRegister = (uint)*bufferPointer;\n      i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002db2": "update_i2_c_state_08002db2",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "CurrentState": "currentI2CState",
                "pbVar2": "bufferPointer",
                "CurrentXferOptions": "currentTransferOptions",
                "uVar3": "transferOptions",
                "Instance": "i2cInstance",
                "CR2": "cr2Register",
                "CR1": "cr1Register",
                "PreviousState": "previousI2CState",
                "State": "i2cState",
                "Mode": "i2cMode",
                "XferSize": "transferSize",
                "XferOptions": "transferOptions",
                "MemaddSize": "memoryAddressSize",
                "Memaddress": "memoryAddress",
                "EventCount": "eventCount",
                "DR": "dataRegister",
                "pBuffPtr": "bufferPointer",
                "XferCount": "transferCount"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002efc": {
            "entrypoint": "0x08002efc",
            "current_name": "handle_i2_c_transfer_08002efc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CTransfer_08002efc(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t transferOptions;\n  uint32_t currentTransferOptions;\n  byte *bytePtr;\n  \n  transferOptions = i2cHandle->XferOptions;\n  if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    if (i2cHandle->XferCount == 0) {\n      if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        i2cHandle->PreviousState = 0;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(i2cHandle);\n        }\n        else {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(i2cHandle);\n        }\n      }\n      else {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->PreviousState = 0x11;\n        i2cHandle->Mode = HAL_I2C_MODE_NONE;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      bytePtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bytePtr + 1;\n      i2cHandle->Instance->DR = (uint)*bytePtr;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002efc": "handle_i2_c_transfer_08002efc",
                "hi2c": "i2cHandle",
                "uVar1": "transferOptions",
                "CurrentXferOptions": "currentTransferOptions",
                "pbVar2": "bytePtr"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f9a": {
            "entrypoint": "0x08002f9a",
            "current_name": "FUNC_08002f9a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002f9a(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f9a": "FUNC_08002f9a"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002f9c": {
            "entrypoint": "0x08002f9c",
            "current_name": "handle_i2_c_rx_08002f9c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2CRx_08002f9c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint8_t *dataPtr;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_BUSY_RX) {\n    if (i2cHandle->XferCount < 4) {\n      if (i2cHandle->XferCount - 2 < 2) {\n        if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x800;\n        }\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      }\n      else {\n        if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        dataPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = dataPtr + 1;\n        *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n        i2cHandle->XferCount = i2cHandle->XferCount - 1;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        i2cHandle->PreviousState = 0;\n        if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemRxCpltCallback(i2cHandle);\n        }\n        else {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterRxCpltCallback(i2cHandle);\n        }\n      }\n    }\n    else {\n      dataPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPtr + 1;\n      *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002f9c": "handle_i2_c_rx_08002f9c",
                "hi2c": "i2cHandle",
                "puVar1": "dataPtr"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800306c": {
            "entrypoint": "0x0800306c",
            "current_name": "process_i2_c_transfer_0800306c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict processI2CTransfer_0800306c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t transferOptions;\n  uint32_t currentTransferOptions;\n  uint8_t *bufferPointer;\n  \n  transferOptions = i2cHandle->XferOptions;\n  if (i2cHandle->XferCount == 3) {\n    if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    }\n    bufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n  }\n  else if (i2cHandle->XferCount == 2) {\n    if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffcff;\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n    }\n    else {\n      if (transferOptions == 2) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n      }\n      else {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n      }\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffcff;\n    }\n    bufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    bufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->PreviousState = 0;\n    if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MemRxCpltCallback(i2cHandle);\n    }\n    else {\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_MasterRxCpltCallback(i2cHandle);\n    }\n  }\n  else {\n    bufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800306c": "process_i2_c_transfer_0800306c",
                "hi2c": "i2cHandle",
                "uVar1": "transferOptions",
                "CurrentXferOptions": "currentTransferOptions",
                "puVar2": "bufferPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800316a": {
            "entrypoint": "0x0800316a",
            "current_name": "FUNC_0800316a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800316a(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800316a": "FUNC_0800316a"
            },
            "calling": [
                "I2C_DMAAbort",
                "I2C_ITError"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800316c": {
            "entrypoint": "0x0800316c",
            "current_name": "handle_i2_c_state_0800316c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_I2C_state_0800316c(I2C_HandleTypeDef *i2c_handle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint8_t *data_ptr;\n  I2C_TypeDef *i2c_instance;\n  \n  if (i2c_handle->State - 0x29 < 2) {\n    i2c_handle->PreviousState = 0;\n    i2c_handle->State = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((i2c_handle->State != HAL_I2C_STATE_ABORT) && ((i2c_handle->Instance->CR2 & 0x800) == 0)) {\n      i2c_handle->State = HAL_I2C_STATE_READY;\n    }\n    i2c_handle->PreviousState = 0;\n    i2c_handle->Mode = HAL_I2C_MODE_NONE;\n  }\n  i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffff7ff;\n  i2c_instance = i2c_handle->Instance;\n  if ((i2c_instance->CR2 & 0x800) == 0) {\n    if (i2c_handle->State == HAL_I2C_STATE_ABORT) {\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->ErrorCode = 0;\n      if ((i2c_instance->SR1 & 0x40) != 0) {\n        data_ptr = i2c_handle->pBuffPtr;\n        i2c_handle->pBuffPtr = data_ptr + 1;\n        *data_ptr = (uint8_t)i2c_instance->DR;\n      }\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(i2c_handle);\n    }\n    else {\n      if ((i2c_instance->SR1 & 0x40) != 0) {\n        data_ptr = i2c_handle->pBuffPtr;\n        i2c_handle->pBuffPtr = data_ptr + 1;\n        *data_ptr = (uint8_t)i2c_instance->DR;\n      }\n      HAL_I2C_ErrorCallback(i2c_handle);\n    }\n  }\n  else {\n    i2c_instance->CR2 = i2c_instance->CR2 & 0xfffff7ff;\n    if (i2c_handle->hdmatx->State == HAL_DMA_STATE_READY) {\n      i2c_handle->hdmarx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2c_handle->hdmarx);\n      if (status != HAL_OK) {\n        if ((i2c_handle->Instance->SR1 & 0x40) != 0) {\n          data_ptr = i2c_handle->pBuffPtr;\n          i2c_handle->pBuffPtr = data_ptr + 1;\n          *data_ptr = (uint8_t)i2c_handle->Instance->DR;\n        }\n        i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffffffe;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        (*i2c_handle->hdmarx->XferAbortCallback)(i2c_handle->hdmarx);\n      }\n    }\n    else {\n      i2c_handle->hdmatx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2c_handle->hdmatx);\n      if (status != HAL_OK) {\n        i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffffffe;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        (*i2c_handle->hdmatx->XferAbortCallback)(i2c_handle->hdmatx);\n      }\n    }\n  }\n  if ((i2c_handle->State == HAL_I2C_STATE_LISTEN) && ((i2c_handle->ErrorCode & 4) != 0)) {\n    i2c_handle->XferOptions = 0xffff0000;\n    i2c_handle->PreviousState = 0;\n    i2c_handle->State = HAL_I2C_STATE_READY;\n    i2c_handle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2c_handle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800316c": "handle_i2_c_state_0800316c",
                "hi2c": "i2c_handle",
                "HVar1": "status",
                "puVar2": "data_ptr",
                "pIVar3": "i2c_instance"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "HAL_DMA_Abort_IT",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080032b4": {
            "entrypoint": "0x080032b4",
            "current_name": "handle_i2_c_080032b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict handleI2C_080032b4(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef prevState;\n  I2C_TypeDef *i2cInstance;\n  uint8_t *dataPtr;\n  uint32_t currentState;\n  uint32_t tempRegister;\n  \n  prevState = i2cHandle->State;\n  i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) != 0) {\n    if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) || (i2cHandle->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmarx->Instance->CNDTR;\n    }\n    else {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmatx->Instance->CNDTR;\n    }\n  }\n  if (i2cHandle->XferCount != 0) {\n    if ((i2cInstance->SR1 & 4) != 0) {\n      dataPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPtr + 1;\n      *dataPtr = (uint8_t)i2cInstance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n      dataPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPtr + 1;\n      *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n  }\n  if (i2cHandle->ErrorCode == 0) {\n    if (((prevState == HAL_I2C_STATE_LISTEN) || (prevState == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (prevState == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2cHandle->XferOptions = 0xffff0000;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(i2cHandle);\n    }\n    else if ((i2cHandle->PreviousState == 0x22) || (prevState == HAL_I2C_STATE_BUSY_RX)) {\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  else {\n    I2C_ITError(i2cHandle);\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080032b4": "handle_i2_c_080032b4",
                "hi2c": "i2cHandle",
                "HVar1": "prevState",
                "pIVar2": "i2cInstance",
                "puVar3": "dataPtr",
                "CurrentState": "currentState",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback",
                "I2C_ITError",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033b8": {
            "entrypoint": "0x080033b8",
            "current_name": "handle_i2_c_interrupt_080033b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CInterrupt_080033b8(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2C_TypeDef *i2cInstance;\n  uint32_t currentMode;\n  uint statusReg1;\n  uint32_t statusReg1InterruptFlags;\n  uint controlReg2;\n  uint32_t interruptSources;\n  uint statusReg2;\n  uint32_t sr2itflags;\n  \n  i2cInstance = i2cHandle->Instance;\n  statusReg2 = i2cInstance->SR2;\n  statusReg1 = i2cInstance->SR1;\n  controlReg2 = i2cInstance->CR2;\n  if ((i2cHandle->Mode == HAL_I2C_MODE_MASTER) || (i2cHandle->Mode == HAL_I2C_MODE_MEM)) {\n    if (((statusReg1 & 0x10001) == 0) || ((controlReg2 & 0x200) == 0)) {\n      if (((statusReg1 & 0x10008) == 0) || ((controlReg2 & 0x200) == 0)) {\n        if (((statusReg1 & 0x10002) != 0) && ((controlReg2 & 0x200) != 0)) {\n          masterAddress(i2cHandle);\n        }\n      }\n      else {\n        masterAddTen(i2cHandle);\n      }\n    }\n    else {\n      masterStartByte(i2cHandle);\n    }\n    if ((statusReg2 & 0x100004) == 0) {\n      if ((((statusReg1 & 0x10040) != 0) && ((controlReg2 & 0x400) != 0)) && ((statusReg1 & 0x10004) == 0)) {\n        masterReceiveDataByte(i2cHandle);\n        return;\n      }\n      if (((statusReg1 & 0x10004) != 0) && ((controlReg2 & 0x200) != 0)) {\n        masterReceiveByteTransferFinished(i2cHandle);\n        return;\n      }\n    }\n    else {\n      if ((((statusReg1 & 0x10080) != 0) && ((controlReg2 & 0x400) != 0)) && ((statusReg1 & 0x10004) == 0)) {\n        masterTransmitEmpty(i2cHandle);\n        return;\n      }\n      if (((statusReg1 & 0x10004) != 0) && ((controlReg2 & 0x200) != 0)) {\n        masterTransmitByteTransferFinished(i2cHandle);\n        return;\n      }\n    }\n  }\n  else {\n    if (((statusReg1 & 0x10002) != 0) && ((controlReg2 & 0x200) != 0)) {\n      slaveAddress(i2cHandle);\n      return;\n    }\n    if (((statusReg1 & 0x10010) != 0) && ((controlReg2 & 0x200) != 0)) {\n      slaveStopFlag(i2cHandle);\n      return;\n    }\n    if ((statusReg2 & 0x100004) == 0) {\n      if ((((statusReg1 & 0x10040) != 0) && ((controlReg2 & 0x400) != 0)) && ((statusReg1 & 0x10004) == 0)) {\n        slaveReceiveDataByte(i2cHandle);\n        return;\n      }\n      if (((statusReg1 & 0x10004) != 0) && ((controlReg2 & 0x200) != 0)) {\n        slaveReceiveByteTransferFinished(i2cHandle);\n      }\n    }\n    else {\n      if ((((statusReg1 & 0x10080) != 0) && ((controlReg2 & 0x400) != 0)) && ((statusReg1 & 0x10004) == 0)) {\n        slaveTransmitEmpty(i2cHandle);\n        return;\n      }\n      if (((statusReg1 & 0x10004) != 0) && ((controlReg2 & 0x200) != 0)) {\n        slaveTransmitByteTransferFinished(i2cHandle);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033b8": "handle_i2_c_interrupt_080033b8",
                "hi2c": "i2cHandle",
                "pIVar1": "i2cInstance",
                "CurrentMode": "currentMode",
                "uVar2": "statusReg1",
                "sr1itflags": "statusReg1InterruptFlags",
                "uVar3": "controlReg2",
                "itsources": "interruptSources",
                "uVar4": "statusReg2",
                "I2C_Master_ADDR": "masterAddress",
                "I2C_Master_ADD10": "masterAddTen",
                "I2C_Master_SB": "masterStartByte",
                "I2C_MasterReceive_RXNE": "masterReceiveDataByte",
                "I2C_MasterReceive_BTF": "masterReceiveByteTransferFinished",
                "I2C_MasterTransmit_TXE": "masterTransmitEmpty",
                "I2C_MasterTransmit_BTF": "masterTransmitByteTransferFinished",
                "I2C_Slave_ADDR": "slaveAddress",
                "I2C_Slave_STOPF": "slaveStopFlag",
                "I2C_SlaveReceive_RXNE": "slaveReceiveDataByte",
                "I2C_SlaveReceive_BTF": "slaveReceiveByteTransferFinished",
                "I2C_SlaveTransmit_TXE": "slaveTransmitEmpty",
                "I2C_SlaveTransmit_BTF": "slaveTransmitByteTransferFinished"
            },
            "calling": [
                "I2C1_EV_IRQHandler",
                "I2C2_EV_IRQHandler"
            ],
            "called": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterReceive_BTF",
                "I2C_Master_ADD10",
                "I2C_Slave_ADDR",
                "I2C_SlaveTransmit_BTF",
                "I2C_MasterReceive_RXNE",
                "I2C_SlaveTransmit_TXE",
                "I2C_Master_SB",
                "I2C_SlaveReceive_BTF",
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF",
                "I2C_Master_ADDR",
                "I2C_MasterTransmit_TXE"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003520": {
            "entrypoint": "0x08003520",
            "current_name": "handle_i2_c_errors_08003520",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CErrors_08003520(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef i2cState;\n  I2C_TypeDef *i2cInstance;\n  uint32_t sr1Flags;\n  uint sr1Value;\n  uint32_t itsources;\n  uint cr2Value;\n  \n  i2cInstance = i2cHandle->Instance;\n  sr1Value = i2cInstance->SR1;\n  cr2Value = i2cInstance->CR2;\n  if (((sr1Value & 0x10100) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 1;\n    i2cInstance->SR1 = 0xfffffeff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x8000;\n  }\n  if (((sr1Value & 0x10200) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 2;\n    i2cHandle->Instance->SR1 = 0xfffffdff;\n  }\n  if (((sr1Value & 0x10400) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cState = i2cHandle->State;\n    if (((i2cHandle->Mode == HAL_I2C_MODE_SLAVE) && (i2cHandle->XferCount == 0)) &&\n       (((i2cState == HAL_I2C_STATE_BUSY_TX || (i2cState == HAL_I2C_STATE_BUSY_TX_LISTEN)) ||\n        ((i2cState == HAL_I2C_STATE_LISTEN && (i2cHandle->PreviousState == 0x21)))))) {\n      I2C_Slave_AF(i2cHandle);\n    }\n    else {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n      if (i2cHandle->Mode == HAL_I2C_MODE_MASTER) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      }\n      i2cHandle->Instance->SR1 = 0xfffffbff;\n    }\n  }\n  if (((sr1Value & 0x10800) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 8;\n    i2cHandle->Instance->SR1 = 0xfffff7ff;\n  }\n  if (i2cHandle->ErrorCode != 0) {\n    I2C_ITError(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003520": "handle_i2_c_errors_08003520",
                "hi2c": "i2cHandle",
                "HVar1": "i2cState",
                "pIVar2": "i2cInstance",
                "sr1itflags": "sr1Flags",
                "uVar3": "sr1Value",
                "uVar4": "cr2Value"
            },
            "calling": [
                "I2C1_ER_IRQHandler",
                "I2C2_ER_IRQHandler"
            ],
            "called": [
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fc": {
            "entrypoint": "0x080035fc",
            "current_name": "reset_i2_c_080035fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetI2C_080035fc(DMA_HandleTypeDef *dmaHandle)\n\n{\n  I2C_HandleTypeDef *i2cHandleParent;\n  I2C_HandleTypeDef *i2cHandle;\n  \n  i2cHandleParent = (I2C_HandleTypeDef *)dmaHandle->Parent;\n  i2cHandleParent->Instance->CR1 = i2cHandleParent->Instance->CR1 & 0xfffffbff;\n  i2cHandleParent->XferCount = 0;\n  i2cHandleParent->dmaHandletx->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  i2cHandleParent->dmaHandlerx->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  if (i2cHandleParent->State != HAL_I2C_STATE_ABORT) {\n    i2cHandleParent->State = HAL_I2C_STATE_READY;\n    i2cHandleParent->Mode = HAL_I2C_MODE_NONE;\n    i2cHandleParent->Instance->CR1 = i2cHandleParent->Instance->CR1 & 0xfffffffe;\n    handleI2CError(i2cHandleParent);\n    return;\n  }\n  i2cHandleParent->State = HAL_I2C_STATE_READY;\n  i2cHandleParent->Mode = HAL_I2C_MODE_NONE;\n  i2cHandleParent->ErrorCode = 0;\n  i2cHandleParent->Instance->CR1 = i2cHandleParent->Instance->CR1 & 0xfffffffe;\n  handleI2CAbortComplete(i2cHandleParent);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fc": "reset_i2_c_080035fc",
                "hdma": "dmaHandle",
                "hi2c_00": "i2cHandleParent",
                "hi2c": "i2cHandle",
                "HAL_I2C_ErrorCallback": "handleI2CError",
                "HAL_I2C_AbortCpltCallback": "handleI2CAbortComplete"
            },
            "calling": [],
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800365c": {
            "entrypoint": "0x0800365c",
            "current_name": "delay_function_0800365c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid delayFunction_0800365c(uint32_t milliseconds)\n\n{\n  bool isDelayNotZero;\n  uint32_t cycles;\n  \n  cycles = milliseconds * (SystemCoreClock / 8000);\n  do {\n    isDelayNotZero = cycles != 0;\n    cycles = cycles - 1;\n  } while (isDelayNotZero);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800365c": "delay_function_0800365c",
                "mdelay": "milliseconds",
                "Delay": "cycles",
                "bVar1": "isDelayNotZero"
            },
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003688": {
            "entrypoint": "0x08003688",
            "current_name": "configure_oscillators_08003688",
            "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureOscillators_08003688(RCC_OscInitTypeDef_conflict *oscillatorConfig)\n\n{\n  HAL_StatusTypeDef HVar1;\n  uint32_t currentTick;\n  uint32_t startTick;\n  bool isNotSet;\n  uint32_t temporaryRegister;\n  \n  if ((oscillatorConfig->OscillatorType & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) != 0)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (oscillatorConfig->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      startTick = oscillatorConfig->HSEState;\n      if (startTick == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (startTick == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (startTick == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (oscillatorConfig->HSEState == 0) {\n        startTick = getTick();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          currentTick = getTick();\n          if (100 < currentTick - startTick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        startTick = getTick();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          currentTick = getTick();\n          if (100 < currentTick - startTick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (oscillatorConfig->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      _DAT_40021000 = _DAT_40021000 & 0xffffff07 | oscillatorConfig->HSICalibrationValue << 3;\n    }\n    else if (oscillatorConfig->HSIState == 0) {\n      _DAT_42420000 = 0;\n      startTick = getTick();\n      while ((_DAT_40021000 & 2) != 0) {\n        currentTick = getTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      startTick = getTick();\n      while ((_DAT_40021000 & 2) == 0) {\n        currentTick = getTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40021000 = _DAT_40021000 & 0xffffff07 | oscillatorConfig->HSICalibrationValue << 3;\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 8) != 0) {\n    if (oscillatorConfig->LSIState == 0) {\n      _DAT_42420480 = 0;\n      startTick = getTick();\n      while ((_DAT_40021024 & 2) != 0) {\n        currentTick = getTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      startTick = getTick();\n      while ((_DAT_40021024 & 2) == 0) {\n        currentTick = getTick();\n        if (2 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n      delay(1);\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 4) != 0) {\n    isNotSet = (_DAT_4002101c & 0x10000000) == 0;\n    if (isNotSet) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTick = getTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTick = getTick();\n        if (100 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    startTick = oscillatorConfig->LSEState;\n    if (startTick == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (startTick == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (startTick == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (oscillatorConfig->LSEState == 0) {\n      startTick = getTick();\n      while ((_DAT_40021020 & 2) != 0) {\n        currentTick = getTick();\n        if (5000 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      startTick = getTick();\n      while ((_DAT_40021020 & 2) == 0) {\n        currentTick = getTick();\n        if (5000 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (isNotSet) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  startTick = (oscillatorConfig->PLL).PLLState;\n  if (startTick == 0) {\n    HVar1 = HAL_OK;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    HVar1 = HAL_ERROR;\n  }\n  else if (startTick == 2) {\n    _DAT_42420060 = 0;\n    startTick = getTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if ((oscillatorConfig->PLL).PLLSource == 0x10000) {\n          _DAT_40021004 = _DAT_40021004 & 0xfffdffff | oscillatorConfig->HSEPredivValue;\n        }\n        _DAT_40021004 =\n             _DAT_40021004 & 0xffc2ffff |\n             (oscillatorConfig->PLL).PLLSource | (oscillatorConfig->PLL).PLLMUL;\n        _DAT_42420060 = 1;\n        startTick = getTick();\n        do {\n          if ((_DAT_40021000 & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          currentTick = getTick();\n        } while (currentTick - startTick < 3);\n        return HAL_TIMEOUT;\n      }\n      currentTick = getTick();\n    } while (currentTick - startTick < 3);\n    HVar1 = HAL_TIMEOUT;\n  }\n  else {\n    _DAT_42420060 = 0;\n    startTick = getTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      currentTick = getTick();\n    } while (currentTick - startTick < 3);\n    HVar1 = HAL_TIMEOUT;\n  }\n  return HVar1;\n}\n\n",
            "renaming": {
                "FUN_08003688": "configure_oscillators_08003688",
                "RCC_OscInitStruct": "oscillatorConfig",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "uVar2": "currentTick",
                "uVar3": "startTick",
                "bVar4": "isNotSet",
                "tmpreg": "temporaryRegister",
                "HAL_GetTick": "getTick",
                "RCC_Delay": "delay"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a68": {
            "entrypoint": "0x08003a68",
            "current_name": "calculate_clock_frequency_08003a68",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateClockFrequency_08003a68(void)\n\n{\n  uint32_t clockFrequency;\n  uint8_t predivFactors [2];\n  uint8_t pllmulFactors [16];\n  \n  pllmulFactors[12] = '\\x0e';\n  pllmulFactors[13] = '\\x0f';\n  pllmulFactors[14] = '\\x10';\n  pllmulFactors[15] = '\\x10';\n  pllmulFactors[8] = '\\n';\n  pllmulFactors[9] = '\\v';\n  pllmulFactors[10] = '\\f';\n  pllmulFactors[11] = '\\r';\n  pllmulFactors[4] = '\\x06';\n  pllmulFactors[5] = '\\a';\n  pllmulFactors[6] = '\\b';\n  pllmulFactors[7] = '\\t';\n  pllmulFactors[0] = '\\x02';\n  pllmulFactors[1] = '\\x03';\n  pllmulFactors[2] = '\\x04';\n  pllmulFactors[3] = '\\x05';\n  predivFactors[0] = '\\x01';\n  predivFactors[1] = '\\x02';\n  if ((_DAT_40021004 & 0xc) == 8) {\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      clockFrequency = (uint)pllmulFactors[(_DAT_40021004 << 10) >> 0x1c] * 4000000;\n    }\n    else {\n      clockFrequency = ((uint)pllmulFactors[(_DAT_40021004 << 10) >> 0x1c] * 8000000) /\n              (uint)predivFactors[-((int)(_DAT_40021004 << 0xe) >> 0x1f)];\n    }\n  }\n  else {\n    clockFrequency = 8000000;\n  }\n  return clockFrequency;\n}\n\n",
            "renaming": {
                "FUN_08003a68": "calculate_clock_frequency_08003a68",
                "aPredivFactorTable": "predivFactors",
                "aPLLMULFactorTable": "pllmulFactors",
                "uVar1": "clockFrequency"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ad4": {
            "entrypoint": "0x08003ad4",
            "current_name": "set_system_clock_08003ad4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nsetSystemClock_08003ad4(RCC_ClkInitTypeDef_conflict *clockConfig,uint32_t flashLatency)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  \n  if ((_DAT_40022000 & 7) < flashLatency) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | flashLatency;\n    if (flashLatency != (flashLatency & 7)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((clockConfig->ClockType & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffff0f | clockConfig->AHBCLKDivider;\n  }\n  if ((clockConfig->ClockType & 1) != 0) {\n    uVar3 = clockConfig->SYSCLKSource;\n    if (uVar3 == 1) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((uVar3 != 2) && ((_DAT_40021000 & 2) == 0)) {\n      return HAL_ERROR;\n    }\n    _DAT_40021004 = uVar3 | _DAT_40021004 & 0xfffffffc;\n    uVar1 = getTick();\n    if (clockConfig->SYSCLKSource == 1) {\n      while ((_DAT_40021004 & 0xc) != 4) {\n        uVar2 = getTick();\n        if (5000 < uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else if (clockConfig->SYSCLKSource == 2) {\n      while ((_DAT_40021004 & 0xc) != 8) {\n        uVar2 = getTick();\n        if (5000 < uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      while ((_DAT_40021004 & 0xc) != 0) {\n        uVar2 = getTick();\n        if (5000 < uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if (flashLatency < (_DAT_40022000 & 7)) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | flashLatency;\n    if (flashLatency != (flashLatency & 7)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((clockConfig->ClockType & 4) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xfffff8ff | clockConfig->APB1CLKDivider;\n  }\n  if ((clockConfig->ClockType & 8) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffc7ff | clockConfig->APB2CLKDivider << 3;\n  }\n  uVar1 = getSysClockFreq();\n  coreClock = uVar1 >> \"\"[(_DAT_40021004 << 0x18) >> 0x1c];\n  initTick(0xf);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08003ad4": "set_system_clock_08003ad4",
                "RCC_ClkInitStruct": "clockConfig",
                "FLatency": "flashLatency",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_GetTick()": "getTick()",
                "SystemCoreClock": "coreClock",
                "HAL_RCC_GetSysClockFreq()": "getSysClockFreq()",
                "HAL_InitTick(0xf)": "initTick(0xf)"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_RCC_GetSysClockFreq",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c44": {
            "entrypoint": "0x08003c44",
            "current_name": "get_system_core_clock_08003c44",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_08003c44(void)\n\n{\n  return systemClock;\n}\n\n",
            "renaming": {
                "FUN_08003c44": "get_system_core_clock_08003c44",
                "SystemCoreClock": "systemClock"
            },
            "calling": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c50": {
            "entrypoint": "0x08003c50",
            "current_name": "get_adjusted_hclk_freq_08003c50",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getAdjustedHCLKFreq_08003c50(void)\n\n{\n  uint32_t adjustedHCLKFreq;\n  \n  adjustedHCLKFreq = HAL_RCC_GetHCLKFreq();\n  return adjustedHCLKFreq >> \"\"[(uint)(_DAT_40021004 << 0x15) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_08003c50": "get_adjusted_hclk_freq_08003c50",
                "uVar1": "adjustedHCLKFreq"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c70": {
            "entrypoint": "0x08003c70",
            "current_name": "get_hclk_frequency_08003c70",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getHCLKFrequency_08003c70(void)\n\n{\n  uint32_t hclkFrequency;\n  \n  hclkFrequency = HAL_RCC_GetHCLKFreq();\n  return hclkFrequency >> \"\"[(uint)(_DAT_40021004 << 0x12) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_08003c70": "get_hclk_frequency_08003c70",
                "uVar1": "hclkFrequency"
            },
            "calling": [
                "UART_SetConfig",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c90": {
            "entrypoint": "0x08003c90",
            "current_name": "configure_periph_clocks_08003c90",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict configurePeriphClocks_08003c90(RCC_PeriphCLKInitTypeDef_conflict *peripheralClockInit)\n\n{\n  uint tempVar1;\n  uint tempVar2;\n  uint32_t tempVar3;\n  uint32_t tempVar4;\n  bool isBitSet;\n  uint32_t temporaryRegister;\n  \n  if ((peripheralClockInit->PeriphClockSelection & 1) != 0) {\n    isBitSet = (_DAT_4002101c & 0x10000000) == 0;\n    if (isBitSet) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      tempVar3 = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        tempVar4 = HAL_GetTick();\n        if (100 < tempVar4 - tempVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (((_DAT_40021020 & 0x300) != 0) &&\n       ((_DAT_40021020 & 0x300) != (peripheralClockInit->RTCClockSelection & 0x300))) {\n      tempVar2 = _DAT_40021020 & 0xfffffcff;\n      _DAT_42420440 = 0;\n      tempVar1 = _DAT_40021020 & 1;\n      _DAT_40021020 = tempVar2;\n      if (tempVar1 != 0) {\n        tempVar3 = HAL_GetTick();\n        while ((_DAT_40021020 & 2) == 0) {\n          tempVar4 = HAL_GetTick();\n          if (5000 < tempVar4 - tempVar3) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    _DAT_40021020 = _DAT_40021020 & 0xfffffcff | peripheralClockInit->RTCClockSelection;\n    if (isBitSet) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if ((peripheralClockInit->PeriphClockSelection & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffff3fff | peripheralClockInit->AdcClockSelection;\n  }\n  if ((peripheralClockInit->PeriphClockSelection & 0x10) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffbfffff | peripheralClockInit->UsbClockSelection;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08003c90": "configure_periph_clocks_08003c90",
                "PeriphClkInit": "peripheralClockInit",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "uVar3": "tempVar3",
                "uVar4": "tempVar4",
                "bVar5": "isBitSet",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003da4": {
            "entrypoint": "0x08003da4",
            "current_name": "calculate_clock_frequency_08003da4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateClockFrequency_08003da4(uint32_t clockSource)\n\n{\n  uint32_t frequency;\n  uint divider;\n  uint8_t predivFactorTable [2];\n  uint8_t pllMulFactorTable [16];\n  \n  pllMulFactorTable[12] = '\\x0e';\n  pllMulFactorTable[13] = '\\x0f';\n  pllMulFactorTable[14] = '\\x10';\n  pllMulFactorTable[15] = '\\x10';\n  pllMulFactorTable[8] = '\\n';\n  pllMulFactorTable[9] = '\\v';\n  pllMulFactorTable[10] = '\\f';\n  pllMulFactorTable[11] = '\\r';\n  pllMulFactorTable[4] = '\\x06';\n  pllMulFactorTable[5] = '\\a';\n  pllMulFactorTable[6] = '\\b';\n  pllMulFactorTable[7] = '\\t';\n  pllMulFactorTable[0] = '\\x02';\n  pllMulFactorTable[1] = '\\x03';\n  pllMulFactorTable[2] = '\\x04';\n  pllMulFactorTable[3] = '\\x05';\n  predivFactorTable[0] = '\\x01';\n  predivFactorTable[1] = '\\x02';\n  if (clockSource == 2) {\n    frequency = HAL_RCC_GetPCLK2Freq();\n    frequency = frequency / ((((_DAT_40021004 << 0x10) >> 0x1e) + 1) * 2);\n  }\n  else if (clockSource == 0x10) {\n    if ((_DAT_40021000 & 0x1000000) == 0) {\n      frequency = 0;\n    }\n    else {\n      if ((_DAT_40021004 & 0x10000) == 0) {\n        divider = 4000000;\n      }\n      else {\n        divider = 8000000 / predivFactorTable[-((int)(_DAT_40021004 << 0xe) >> 0x1f)];\n      }\n      frequency = divider * pllMulFactorTable[(_DAT_40021004 << 10) >> 0x1c];\n      if ((_DAT_40021004 & 0x400000) == 0) {\n        frequency = (frequency * 2) / 3;\n      }\n    }\n  }\n  else if (clockSource == 1) {\n    if ((_DAT_40021020 & 0x302) == 0x102) {\n      frequency = 0x8000;\n    }\n    else if (((_DAT_40021020 & 0x300) == 0x200) && ((_DAT_40021024 & 2) != 0)) {\n      frequency = 32000;\n    }\n    else if ((_DAT_40021020 & 0x300) == 0x300) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        frequency = 0;\n      }\n      else {\n        frequency = 0xf424;\n      }\n    }\n    else {\n      frequency = 0;\n    }\n  }\n  else {\n    frequency = 0;\n  }\n  return frequency;\n}\n\n",
            "renaming": {
                "FUN_08003da4": "calculate_clock_frequency_08003da4",
                "PeriphClk": "clockSource",
                "uVar1": "frequency",
                "uVar2": "divider",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllMulFactorTable"
            },
            "calling": [
                "HAL_ADC_PollForConversion",
                "HAL_ADCEx_Calibration_Start"
            ],
            "called": [
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ea0": {
            "entrypoint": "0x08003ea0",
            "current_name": "handle_rtc_alarm_callback_08003ea0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_RTC_Alarm_callback_08003ea0(RTC_HandleTypeDef *RTC_handle)\n\n{\n  if (((RTC_handle->RTC_instance->control_register_high & 2) != 0) && ((RTC_handle->RTC_instance->control_register_low & 2) != 0)) {\n    handle_RTC_AlarmAEvent(RTC_handle);\n    RTC_handle->RTC_instance->control_register_low = 0xfffffffd;\n  }\n  _DAT_40010414 = 0x20000;\n  RTC_handle->State = HAL_RTC_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ea0": "handle_rtc_alarm_callback_08003ea0",
                "hrtc": "RTC_handle",
                "Instance": "RTC_instance",
                "CRH": "control_register_high",
                "CRL": "control_register_low",
                "HAL_RTC_AlarmAEventCallback": "handle_RTC_AlarmAEvent"
            },
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "called": [
                "HAL_RTC_AlarmAEventCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ed8": {
            "entrypoint": "0x08003ed8",
            "current_name": "reset_timer_and_de_init_pwm_08003ed8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef resetTimerAndDeInitPWM_08003ed8(TIM_HandleTypeDef *timer)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  timer->State = HAL_TIM_STATE_BUSY;\n  timerInstance = timer->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  HAL_TIM_PWM_MspDeInit(timer);\n  timer->State = HAL_TIM_STATE_RESET;\n  timer->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08003ed8": "reset_timer_and_de_init_pwm_08003ed8",
                "htim": "timer",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f12": {
            "entrypoint": "0x08003f12",
            "current_name": "FUNC_08003f12",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003f12(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f12": "FUNC_08003f12"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003f14": {
            "entrypoint": "0x08003f14",
            "current_name": "FUNC_08003f14",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003f14(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f14": "FUNC_08003f14"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003f16": {
            "entrypoint": "0x08003f16",
            "current_name": "FUNC_08003f16",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003f16(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f16": "FUNC_08003f16"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003f18": {
            "entrypoint": "0x08003f18",
            "current_name": "handle_timer_interrupts_08003f18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupts_08003f18(TIM_HandleTypeDef *timerHandle)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 2) != 0) && ((timerInstance->DIER & 2) != 0)) {\n    timerInstance->SR = 0xfffffffd;\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n    if ((timerHandle->Instance->CCMR1 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandle);\n    }\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 4) != 0) && ((timerInstance->DIER & 4) != 0)) {\n    timerInstance->SR = 0xfffffffb;\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n    if ((timerHandle->Instance->CCMR1 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandle);\n    }\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 8) != 0) && ((timerInstance->DIER & 8) != 0)) {\n    timerInstance->SR = 0xfffffff7;\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n    if ((timerHandle->Instance->CCMR2 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandle);\n    }\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 0x10) != 0) && ((timerInstance->DIER & 0x10) != 0)) {\n    timerInstance->SR = 0xffffffef;\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n    if ((timerHandle->Instance->CCMR2 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandle);\n    }\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 1) != 0) && ((timerInstance->DIER & 1) != 0)) {\n    timerInstance->SR = 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(timerHandle);\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 0x80) != 0) && ((timerInstance->DIER & 0x80) != 0)) {\n    timerInstance->SR = 0xffffff7f;\n    HAL_TIMEx_BreakCallback(timerHandle);\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 0x40) != 0) && ((timerInstance->DIER & 0x40) != 0)) {\n    timerInstance->SR = 0xffffffbf;\n    HAL_TIM_TriggerCallback(timerHandle);\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->SR & 0x20) != 0) && ((timerInstance->DIER & 0x20) != 0)) {\n    timerInstance->SR = 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(timerHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f18": "handle_timer_interrupts_08003f18",
                "htim": "timerHandle",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "TIM1_UP_IRQHandler",
                "TIM3_IRQHandler",
                "TIM4_IRQHandler",
                "TIM2_IRQHandler"
            ],
            "called": [
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIMEx_BreakCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_PWM_PulseFinishedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004092": {
            "entrypoint": "0x08004092",
            "current_name": "configure_timer_channel_08004092",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerChannel_08004092(TIM_TypeDef *timer,uint32_t channel,uint32_t channelState)\n\n{\n  timer->CCER = timer->CCER & ~(1 << (channel & 0xff));\n  timer->CCER = timer->CCER | channelState << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004092": "configure_timer_channel_08004092",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "channelState"
            },
            "calling": [
                "HAL_TIM_PWM_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040b0": {
            "entrypoint": "0x080040b0",
            "current_name": "disable_timer_channel_080040b0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict disableTimerChannel_080040b0(TIM_HandleTypeDef *timerHandle,uint32_t channel)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  TIM_CCxchannelCmd(timerHandle->Instance,channel,0);\n  if (((timerHandle->Instance == (TIM_TypeDef *)0x40012c00) && ((RAM_CONSTANT_2 & 0x1111) == 0)) &&\n     ((RAM_CONSTANT_2 & 0x444) == 0)) {\n    RAM_CONSTANT_3 = RAM_CONSTANT_3 & 0xffff7fff;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  timerHandle->State = HAL_TIM_STATE_READY;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080040b0": "disable_timer_channel_080040b0",
                "htim": "timerHandle",
                "Channel": "channel",
                "pTVar1": "timerInstance",
                "uRam40012c20": "RAM_CONSTANT_2",
                "uRam40012c44": "RAM_CONSTANT_3"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004110": {
            "entrypoint": "0x08004110",
            "current_name": "update_channel_state_08004110",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateChannelState_08004110(TIM_TypeDef *timer,uint32_t channel,uint32_t newState)\n\n{\n  timer->CCER = timer->CCER & ~(4 << (channel & 0xff));\n  timer->CCER = timer->CCER | newState << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004110": "update_channel_state_08004110",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelNState": "newState"
            },
            "calling": [
                "HAL_TIMEx_PWMN_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800412c": {
            "entrypoint": "0x0800412c",
            "current_name": "disable_tim_channel_0800412c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict disableTimChannel_0800412c(TIM_HandleTypeDef *htim,uint32_t channelNumber)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  TIM_CCxNchannelNumberCmd(htim->Instance,channelNumber,0);\n  timerInstance = htim->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->BDTR = timerInstance->BDTR & 0xffff7fff;\n  }\n  timerInstance = htim->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800412c": "disable_tim_channel_0800412c",
                "Channel": "channelNumber",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004178": {
            "entrypoint": "0x08004178",
            "current_name": "FUNC_08004178",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004178(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004178": "FUNC_08004178"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800417a": {
            "entrypoint": "0x0800417a",
            "current_name": "FUNC_0800417a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800417a(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800417a": "FUNC_0800417a"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800417c": {
            "entrypoint": "0x0800417c",
            "current_name": "reset_uart_configuration_0800417c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetUartConfiguration_0800417c(UART_HandleTypeDef *uartHandle)\n\n{\n  uartHandle->uartInstance->controlRegister1 = uartHandle->uartInstance->controlRegister1 & 0xfffffedf;\n  uartHandle->uartInstance->controlRegister3 = uartHandle->uartInstance->controlRegister3 & 0xfffffffe;\n  uartHandle->receiveState = HAL_UART_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800417c": "reset_uart_configuration_0800417c",
                "huart": "uartHandle",
                "Instance": "uartInstance",
                "CR1": "controlRegister1",
                "CR3": "controlRegister3",
                "RxState": "receiveState"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004198": {
            "entrypoint": "0x08004198",
            "current_name": "uart_transmit_data_08004198",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict UART_TransmitData_08004198(UART_HandleTypeDef *uart)\n\n{\n  uint16_t remainingCount;\n  byte *byteToTransmit;\n  uint16_t *temporary;\n  \n  if (uart->gState != UART_STATE_TRANSMITTING) {\n    return BUSY;\n  }\n  if ((uart->Init).WordLength == 0x1000) {\n    uart->Instance->DR = *(ushort *)uart->pTxBuffPtr & 0x1ff;\n    if ((uart->Init).Parity == 0) {\n      uart->pTxBuffPtr = uart->pTxBuffPtr + 2;\n    }\n    else {\n      uart->pTxBuffPtr = uart->pTxBuffPtr + 1;\n    }\n  }\n  else {\n    byteToTransmit = uart->pTxBuffPtr;\n    uart->pTxBuffPtr = byteToTransmit + 1;\n    uart->Instance->DR = (uint)*byteToTransmit;\n  }\n  remainingCount = uart->TxXferCount - 1;\n  uart->TxXferCount = remainingCount;\n  if (remainingCount == 0) {\n    uart->Instance->CR1 = uart->Instance->CR1 & 0xffffff7f;\n    uart->Instance->CR1 = uart->Instance->CR1 | 0x40;\n    return OK;\n  }\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_08004198": "uart_transmit_data_08004198",
                "huart": "uart",
                "uVar1": "remainingCount",
                "pbVar2": "byteToTransmit",
                "tmp": "temporary",
                "HAL_UART_STATE_BUSY_TX": "UART_STATE_TRANSMITTING",
                "HAL_BUSY": "BUSY",
                "HAL_OK": "OK"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004204": {
            "entrypoint": "0x08004204",
            "current_name": "configure_uart_08004204",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configure_UART_08004204(UART_HandleTypeDef *UART_instance)\n\n{\n  uint32_t pclk1_freq;\n  uint32_t pclk1_freq_copy;\n  uint32_t pclk1_freq_copy2;\n  uint32_t pclk1_freq_copy3;\n  uint32_t pclk1_freq_copy4;\n  uint32_t baudRate;\n  uint32_t baudRate_copy;\n  uint32_t baudRate_copy2;\n  uint32_t baudRate_copy3;\n  USART_TypeDef *pUVar10;\n  \n  UART_instance->Instance->CR2 = UART_instance->Instance->CR2 & 0xffffcfff | (UART_instance->Init).StopBits;\n  UART_instance->Instance->CR1 =\n       (UART_instance->Init).WordLength | (UART_instance->Init).Parity | (UART_instance->Init).Mode |\n       UART_instance->Instance->CR1 & 0xffffe9f3;\n  UART_instance->Instance->CR3 = UART_instance->Instance->CR3 & 0xfffffcff | (UART_instance->Init).HwFlowCtl;\n  pUVar10 = UART_instance->Instance;\n  if (pUVar10 != (USART_TypeDef *)0x40013800) {\n    pclk1_freq = HAL_RCC_GetPCLK1Freq();\n    baudRate = (UART_instance->Init).BaudRate;\n    pclk1_freq_copy = HAL_RCC_GetPCLK1Freq();\n    baudRate_copy = (UART_instance->Init).BaudRate;\n    pclk1_freq_copy2 = HAL_RCC_GetPCLK1Freq();\n    baudRate_copy2 = (UART_instance->Init).BaudRate;\n    pclk1_freq_copy3 = HAL_RCC_GetPCLK1Freq();\n    baudRate_copy3 = (UART_instance->Init).BaudRate;\n    pclk1_freq_copy4 = HAL_RCC_GetPCLK1Freq();\n    pUVar10->BRR = ((uint)((int)((ulonglong)\n                                 (((pclk1_freq_copy3 * 0x19) / (baudRate_copy3 << 2) +\n                                  (int)(((ulonglong)(pclk1_freq_copy4 * 0x19) /\n                                        (ulonglong)((UART_instance->Init).BaudRate << 2)) / 100) * -100) *\n                                  0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                   ((((pclk1_freq_copy * 0x19) / (baudRate_copy << 2) +\n                     (int)(((ulonglong)(pclk1_freq_copy2 * 0x19) / (ulonglong)(baudRate_copy2 << 2)) / 100) * -100) *\n                     0x10 + 0x32) / 100 & 0xf0) +\n                   (int)(((ulonglong)(pclk1_freq * 0x19) / (ulonglong)(baudRate << 2)) / 100) * 0x10;\n    return;\n  }\n  pclk1_freq = HAL_RCC_GetPCLK2Freq();\n  baudRate = (UART_instance->Init).BaudRate;\n  pclk1_freq_copy = HAL_RCC_GetPCLK2Freq();\n  baudRate_copy = (UART_instance->Init).BaudRate;\n  pclk1_freq_copy2 = HAL_RCC_GetPCLK2Freq();\n  baudRate_copy2 = (UART_instance->Init).BaudRate;\n  pclk1_freq_copy3 = HAL_RCC_GetPCLK2Freq();\n  baudRate_copy3 = (UART_instance->Init).BaudRate;\n  pclk1_freq_copy4 = HAL_RCC_GetPCLK2Freq();\n  iRam40013808 = ((uint)((int)((ulonglong)\n                               (((pclk1_freq_copy3 * 0x19) / (baudRate_copy3 << 2) +\n                                (int)(((ulonglong)(pclk1_freq_copy4 * 0x19) /\n                                      (ulonglong)((UART_instance->Init).BaudRate << 2)) / 100) * -100) *\n                                0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                 ((((pclk1_freq_copy * 0x19) / (baudRate_copy << 2) +\n                   (int)(((ulonglong)(pclk1_freq_copy2 * 0x19) / (ulonglong)(baudRate_copy2 << 2)) / 100) * -100) * 0x10\n                  + 0x32) / 100 & 0xf0) +\n                 (int)(((ulonglong)(pclk1_freq * 0x19) / (ulonglong)(baudRate << 2)) / 100) * 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004204": "configure_uart_08004204",
                "huart": "UART_instance",
                "uVar1": "pclk1_freq",
                "uVar2": "pclk1_freq_copy",
                "uVar3": "pclk1_freq_copy2",
                "uVar4": "pclk1_freq_copy3",
                "uVar5": "pclk1_freq_copy4",
                "uVar6": "baudRate",
                "uVar7": "baudRate_copy",
                "uVar8": "baudRate_copy2",
                "uVar9": "baudRate_copy3"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080043b4": {
            "entrypoint": "0x080043b4",
            "current_name": "check_flag_080043b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nstatus\ncheckFlag_080043b4(UART_HandleTypeDef *uartHandle,uint32_t flag,flagdesiredStatus desiredStatus,uint32_t tickStart,\n            uint32_t timeout)\n\n{\n  uint32_t currentTick;\n  \n  do {\n    if (((flag & ~uartHandle->Instance->SR) == 0) != (bool)desiredStatus) {\n      return OK;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - tickStart <= timeout))));\n  uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffe5f;\n  uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n  uartHandle->gState = HAL_UART_STATE_READY;\n  uartHandle->RxState = HAL_UART_STATE_READY;\n  uartHandle->Lock = HAL_UNLOCKED;\n  return TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_080043b4": "check_flag_080043b4",
                "huart": "uartHandle",
                "Flag": "flag",
                "Status": "desiredStatus",
                "Tickstart": "tickStart",
                "Timeout": "timeout",
                "uVar1": "currentTick",
                "HAL_StatusTypeDef_conflict": "status",
                "HAL_OK": "OK",
                "HAL_TIMEOUT": "TIMEOUT"
            },
            "calling": [
                "HAL_UART_Transmit"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004418": {
            "entrypoint": "0x08004418",
            "current_name": "FUNC_08004418",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004418(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004418": "FUNC_08004418"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800441a": {
            "entrypoint": "0x0800441a",
            "current_name": "initialize_uart_0800441a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initialize_UART_0800441a(UART_HandleTypeDef *uart_handle)\n\n{\n  if (uart_handle != (UART_HandleTypeDef *)0x0) {\n    if (uart_handle->general_state == reset_state) {\n      uart_handle->uart_lock = unlocked;\n      initialize_uart_peripherals(uart_handle);\n    }\n    uart_handle->general_state = busy_state;\n    uart_handle->uart_instance->uart_control_register_1 = uart_handle->uart_instance->uart_control_register_1 & 0xffffdfff;\n    UART_SetConfig(uart_handle);\n    uart_handle->uart_instance->uart_control_register_2 = uart_handle->uart_instance->uart_control_register_2 & 0xffffb7ff;\n    uart_handle->uart_instance->uart_control_register_3 = uart_handle->uart_instance->uart_control_register_3 & 0xffffffd5;\n    uart_handle->uart_instance->uart_control_register_1 = uart_handle->uart_instance->uart_control_register_1 | 0x2000;\n    uart_handle->uart_error_code = 0;\n    uart_handle->general_state = ready_state;\n    uart_handle->receive_state = ready_state;\n    return success;\n  }\n  return error;\n}\n\n",
            "renaming": {
                "FUN_0800441a": "initialize_uart_0800441a",
                "huart": "uart_handle",
                "gState": "general_state",
                "Lock": "uart_lock",
                "Instance": "uart_instance",
                "CR1": "uart_control_register_1",
                "CR2": "uart_control_register_2",
                "CR3": "uart_control_register_3",
                "ErrorCode": "uart_error_code",
                "RxState": "receive_state",
                "HAL_UART_MspInit": "initialize_uart_peripherals",
                "HAL_UNLOCKED": "unlocked",
                "HAL_UART_STATE_RESET": "reset_state",
                "HAL_UART_STATE_BUSY": "busy_state",
                "HAL_UART_STATE_READY": "ready_state",
                "HAL_OK": "success",
                "HAL_ERROR": "error"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004478": {
            "entrypoint": "0x08004478",
            "current_name": "transmit_data_08004478",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\ntransmitData_08004478(UART_HandleTypeDef *uartHandle,uint8_t *dataBuffer,uint16_t dataSize,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t tickStart;\n  uint16_t *tmp;\n  \n  if (uartHandle->gState == UART_STATE_READY) {\n    if (dataBuffer == (uint8_t *)0x0) {\n      status = ERROR;\n    }\n    else if (dataSize == 0) {\n      status = ERROR;\n    }\n    else if (uartHandle->Lock == LOCKED) {\n      status = BUSY;\n    }\n    else {\n      uartHandle->Lock = LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n      tickStart = HAL_GetTick();\n      uartHandle->TxXferdataSize = dataSize;\n      uartHandle->TxXferCount = dataSize;\n      while (uartHandle->TxXferCount != 0) {\n        uartHandle->TxXferCount = uartHandle->TxXferCount - 1;\n        if ((uartHandle->Init).WordLength == 0x1000) {\n          status = waitOnFlagUntilTimeout(uartHandle,0x80,RESET,tickStart,timeout);\n          if (status != OK) {\n            return TIMEOUT;\n          }\n          uartHandle->Instance->DR = *(ushort *)dataBuffer & 0x1ff;\n          if ((uartHandle->Init).Parity == 0) {\n            dataBuffer = (uint8_t *)((int)dataBuffer + 2);\n          }\n          else {\n            dataBuffer = (uint8_t *)((int)dataBuffer + 1);\n          }\n        }\n        else {\n          status = waitOnFlagUntilTimeout(uartHandle,0x80,RESET,tickStart,timeout);\n          if (status != OK) {\n            return TIMEOUT;\n          }\n          uartHandle->Instance->DR = (uint)*dataBuffer;\n          dataBuffer = (uint8_t *)((int)dataBuffer + 1);\n        }\n      }\n      status = waitOnFlagUntilTimeout(uartHandle,0x40,RESET,tickStart,timeout);\n      if (status == OK) {\n        uartHandle->gState = UART_STATE_READY;\n        uartHandle->Lock = UNLOCKED;\n        status = OK;\n      }\n      else {\n        status = TIMEOUT;\n      }\n    }\n  }\n  else {\n    status = BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08004478": "transmit_data_08004478",
                "huart": "uartHandle",
                "pData": "dataBuffer",
                "Size": "dataSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "tickStart",
                "HAL_UART_STATE_READY": "UART_STATE_READY",
                "HAL_ERROR": "ERROR",
                "HAL_LOCKED": "LOCKED",
                "HAL_BUSY": "BUSY",
                "UART_WaitOnFlagUntilTimeout": "waitOnFlagUntilTimeout",
                "HAL_TIMEOUT": "TIMEOUT",
                "HAL_OK": "OK",
                "HAL_UNLOCKED": "UNLOCKED"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800455a": {
            "entrypoint": "0x0800455a",
            "current_name": "initialize_uart_transfer_0800455a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nUartStatus initializeUartTransfer_0800455a(UART_HandleTypeDef *uartHandle,uint8_t *dataPtr,uint16_t dataSize)\n\n{\n  if (uartHandle->gState != UartState.READY) {\n    return UartStatus.BUSY;\n  }\n  if (dataPtr == (uint8_t *)0x0) {\n    return UartStatus.ERROR;\n  }\n  if (dataSize == 0) {\n    return UartStatus.ERROR;\n  }\n  if (uartHandle->Lock != UartLock.LOCKED) {\n    uartHandle->pTxBuffPtr = dataPtr;\n    uartHandle->TxXferdataSize = dataSize;\n    uartHandle->TxXferCount = dataSize;\n    uartHandle->uartErrorCode = 0;\n    uartHandle->gState = UartState.BUSY_TX;\n    uartHandle->Lock = UartLock.UNLOCKED;\n    uartHandle->uartInstance->uartCR1 = uartHandle->uartInstance->uartCR1 | 0x80;\n    return UartStatus.OK;\n  }\n  return UartStatus.BUSY;\n}\n\n",
            "renaming": {
                "FUN_0800455a": "initialize_uart_transfer_0800455a",
                "huart": "uartHandle",
                "pData": "dataPtr",
                "Size": "dataSize",
                "HAL_StatusTypeDef_conflict": "UartStatus",
                "HAL_BUSY": "UartStatus.BUSY",
                "HAL_ERROR": "UartStatus.ERROR",
                "HAL_OK": "UartStatus.OK",
                "HAL_UART_STATE_READY": "UartState.READY",
                "HAL_UART_STATE_BUSY_TX": "UartState.BUSY_TX",
                "HAL_LOCKED": "UartLock.LOCKED",
                "HAL_UNLOCKED": "UartLock.UNLOCKED",
                "ErrorCode": "uartErrorCode",
                "Instance": "uartInstance",
                "CR1": "uartCR1"
            },
            "calling": [
                "uart_attach_tx_callback",
                "HAL_UART_TxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045a2": {
            "entrypoint": "0x080045a2",
            "current_name": "initialize_uart_receive_080045a2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initialize_UART_receive_080045a2(UART_HandleTypeDef *UART_handle,uint8_t *receive_buffer,uint16_t buffer_size)\n\n{\n  if (UART_handle->RxState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (receive_buffer == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (buffer_size == 0) {\n    return HAL_ERROR;\n  }\n  if (UART_handle->Lock != HAL_LOCKED) {\n    UART_handle->pRxBuffPtr = receive_buffer;\n    UART_handle->RxXferbuffer_size = buffer_size;\n    UART_handle->RxXferCount = buffer_size;\n    UART_handle->ErrorCode = 0;\n    UART_handle->RxState = HAL_UART_STATE_BUSY_RX;\n    UART_handle->Lock = HAL_UNLOCKED;\n    UART_handle->Instance->CR1 = UART_handle->Instance->CR1 | 0x100;\n    UART_handle->Instance->CR3 = UART_handle->Instance->CR3 | 1;\n    UART_handle->Instance->CR1 = UART_handle->Instance->CR1 | 0x20;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_080045a2": "initialize_uart_receive_080045a2",
                "huart": "UART_handle",
                "pData": "receive_buffer",
                "Size": "buffer_size"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045fe": {
            "entrypoint": "0x080045fe",
            "current_name": "initialize_uart_080045fe",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict initializeUART_080045fe(UART_HandleTypeDef *uartHandler)\n\n{\n  uartHandler->uartInstance->controlRegister1 = uartHandler->uartInstance->controlRegister1 & 0xffffffbf;\n  uartHandler->uartState = UART_READY;\n  transmitCompleteCallback(uartHandler);\n  return HAL_SUCCESS;\n}\n\n",
            "renaming": {
                "FUN_080045fe": "initialize_uart_080045fe",
                "huart": "uartHandler",
                "Instance": "uartInstance",
                "CR1": "controlRegister1",
                "gState": "uartState",
                "HAL_UART_STATE_READY": "UART_READY",
                "HAL_UART_TxCpltCallback": "transmitCompleteCallback",
                "HAL_OK": "HAL_SUCCESS"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004618": {
            "entrypoint": "0x08004618",
            "current_name": "receive_data_08004618",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict receiveData_08004618(UART_HandleTypeDef *uartHandle)\n\n{\n  uint16_t *tmp;\n  byte *pbVar1;\n  uint16_t uVar2;\n  uint8_t *puVar3;\n  \n  if (uartHandle->receiverState != HAL_BUSY_RECEIVING) {\n    return FCOHPGdataRegisterIW;\n  }\n  if ((uartHandle->configuration).dataLength == 0x1000) {\n    if ((uartHandle->configuration).parity == 0) {\n      *(uint16_t *)uartHandle->receiveBufferPointer = (uint16_t)((uartHandle->uartInstance->dataRegister << 0x17) >> 0x17);\n      uartHandle->receiveBufferPointer = uartHandle->receiveBufferPointer + 2;\n    }\n    else {\n      *(uint16_t *)uartHandle->receiveBufferPointer = (uint16_t)uartHandle->uartInstance->dataRegister & 0xff;\n      uartHandle->receiveBufferPointer = uartHandle->receiveBufferPointer + 1;\n    }\n  }\n  else if ((uartHandle->configuration).parity == 0) {\n    puVar3 = uartHandle->receiveBufferPointer;\n    uartHandle->receiveBufferPointer = puVar3 + 1;\n    *puVar3 = (uint8_t)uartHandle->uartInstance->dataRegister;\n  }\n  else {\n    pbVar1 = uartHandle->receiveBufferPointer;\n    uartHandle->receiveBufferPointer = pbVar1 + 1;\n    *pbVar1 = (byte)uartHandle->uartInstance->dataRegister & 0x7f;\n  }\n  uVar2 = uartHandle->receiveTransferCount - 1;\n  uartHandle->receiveTransferCount = uVar2;\n  if (uVar2 != 0) {\n    return HAL_SUCCESS;\n  }\n  uartHandle->uartInstance->controlRegister1 = uartHandle->uartInstance->controlRegister1 & 0xffffffdf;\n  uartHandle->uartInstance->controlRegister1 = uartHandle->uartInstance->controlRegister1 & 0xfffffeff;\n  uartHandle->uartInstance->controlRegister3 = uartHandle->uartInstance->controlRegister3 & 0xfffffffe;\n  uartHandle->receiverState = HAL_READY;\n  HAL_UART_RxCpltCallback(uartHandle);\n  return HAL_SUCCESS;\n}\n\n",
            "renaming": {
                "FUN_08004618": "receive_data_08004618",
                "huart": "uartHandle",
                "RxState": "receiverState",
                "HAL_UART_STATE_BUSY_RX": "HAL_BUSY_RECEIVING",
                "Init": "configuration",
                "WordLength": "dataLength",
                "Parity": "parity",
                "pRxBuffPtr": "receiveBufferPointer",
                "Instance": "uartInstance",
                "DR": "dataRegister",
                "HAL_BUSY": "HAL_ERROR_BUSY",
                "ushort": "uint16_t",
                "HAL_OK": "HAL_SUCCESS",
                "RxXferCount": "receiveTransferCount",
                "CR1": "controlRegister1",
                "CR3": "controlRegister3",
                "HAL_UART_STATE_READY": "HAL_READY"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046b8": {
            "entrypoint": "0x080046b8",
            "current_name": "handle_uart_errors_080046b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_uart_errors_080046b8(UART_HandleTypeDef *uart_handle)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint cr1_bits;\n  uint32_t cr1_its;\n  USART_TypeDef *uart_instance;\n  uint32_t cr3_its;\n  uint cr3_bit;\n  uint sr_bits;\n  uint32_t isr_flags;\n  \n  uart_instance = uart_handle->Instance;\n  sr_bits = uart_instance->SR;\n  cr1_bits = uart_instance->CR1;\n  if ((((sr_bits & 0xf) == 0) && ((sr_bits & 0x20) != 0)) && ((cr1_bits & 0x20) != 0)) {\n    UART_Receive_IT(uart_handle);\n    return;\n  }\n  if (((sr_bits & 0xf) == 0) || ((cr3_bit = uart_instance->CR3 & 1, cr3_bit == 0 && ((cr1_bits & 0x120) == 0)))) {\n    if (((sr_bits & 0x80) != 0) && ((cr1_bits & 0x80) != 0)) {\n      UART_Transmit_IT(uart_handle);\n      return;\n    }\n    if (((sr_bits & 0x40) != 0) && ((cr1_bits & 0x40) != 0)) {\n      UART_EndTransmit_IT(uart_handle);\n    }\n  }\n  else {\n    if (((sr_bits & 1) != 0) && ((cr1_bits & 0x100) != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 1;\n    }\n    if (((sr_bits & 4) != 0) && (cr3_bit != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 2;\n    }\n    if (((sr_bits & 2) != 0) && (cr3_bit != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 4;\n    }\n    if (((sr_bits & 8) != 0) && (cr3_bit != 0)) {\n      uart_handle->ErrorCode = uart_handle->ErrorCode | 8;\n    }\n    if (uart_handle->ErrorCode != 0) {\n      if (((sr_bits & 0x20) != 0) && ((cr1_bits & 0x20) != 0)) {\n        UART_Receive_IT(uart_handle);\n      }\n      if (((uart_handle->ErrorCode & 8) == 0) && ((uart_handle->Instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(uart_handle);\n        uart_handle->ErrorCode = 0;\n        return;\n      }\n      UART_EndRxTransfer(uart_handle);\n      uart_instance = uart_handle->Instance;\n      if ((uart_instance->CR3 & 0x40) == 0) {\n        HAL_UART_ErrorCallback(uart_handle);\n        return;\n      }\n      uart_instance->CR3 = uart_instance->CR3 & 0xffffffbf;\n      if (uart_handle->hdmarx == (DMA_HandleTypeDef *)0x0) {\n        HAL_UART_ErrorCallback(uart_handle);\n        return;\n      }\n      uart_handle->hdmarx->XferAbortCallback = UART_DMAAbortOnError + 1;\n      status = HAL_DMA_Abort_IT(uart_handle->hdmarx);\n      if (status != HAL_OK) {\n        (*uart_handle->hdmarx->XferAbortCallback)(uart_handle->hdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046b8": "handle_uart_errors_080046b8",
                "huart": "uart_handle",
                "HVar1": "status",
                "uVar2": "cr1_bits",
                "uVar4": "cr3_bit",
                "uVar5": "sr_bits",
                "cr1its": "cr1_its",
                "cr3its": "cr3_its",
                "isrflags": "isr_flags",
                "pUVar3": "uart_instance"
            },
            "calling": [
                "USART2_IRQHandler",
                "USART3_IRQHandler",
                "USART1_IRQHandler"
            ],
            "called": [
                "HAL_DMA_Abort_IT",
                "HAL_UART_ErrorCallback",
                "UART_EndRxTransfer",
                "UART_EndTransmit_IT",
                "UART_Transmit_IT",
                "UART_Receive_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047d8": {
            "entrypoint": "0x080047d8",
            "current_name": "reset_uart_rx_tx_counts_and_trigger_error_callback_080047d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetUARTRxTxCountsAndTriggerErrorCallback_080047d8(DMA_HandleTypeDef *dmaHandle)\n\n{\n  UART_HandleTypeDef *uartHandle;\n  UART_HandleTypeDef *newUartHandle;\n  \n  uartHandle = (UART_HandleTypeDef *)dmaHandle->Parent;\n  uartHandle->RxXferCount = 0;\n  uartHandle->TxXferCount = 0;\n  HAL_UART_ErrorCallback(uartHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047d8": "reset_uart_rx_tx_counts_and_trigger_error_callback_080047d8",
                "hdma": "dmaHandle",
                "huart_00": "uartHandle",
                "huart": "newUartHandle"
            },
            "calling": [],
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047e8": {
            "entrypoint": "0x080047e8",
            "current_name": "combine_uart_states_080047e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_UART_StateTypeDef combine_uart_states_080047e8(UART_HandleTypeDef *uart_handler)\n\n{\n  return uart_handler->receive_state | uart_handler->general_state;\n}\n\n",
            "renaming": {
                "FUN_080047e8": "combine_uart_states_080047e8",
                "huart": "uart_handler",
                "RxState": "receive_state",
                "gState": "general_state"
            },
            "calling": [
                "serial_tx_active",
                "serial_rx_active"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047f4": {
            "entrypoint": "0x080047f4",
            "current_name": "check_pin_state_080047f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool checkPinState_080047f4(pin pin,uint32_t *pinMap)\n\n{\n  uint32_t pinIndex;\n  \n  pinIndex = pinMap[(uint)((int)pin << 0x18) >> 0x1c];\n  return (_Bool)((byte)(pinIndex >> ((int)pin & 0xfU)) & 1);\n}\n\n",
            "renaming": {
                "FUN_080047f4": "check_pin_state_080047f4",
                "PinName_conflict": "pin",
                "map": "pinMap",
                "index": "pinIndex"
            },
            "calling": [
                "digitalWrite",
                "digitalRead",
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800480a": {
            "entrypoint": "0x0800480a",
            "current_name": "update_pin_map_0800480a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updatePinMap_0800480a(PinName_conflict pinConf,uint32_t *pinMap)\n\n{\n  uint shiftedIndex;\n  uint32_t index;\n  \n  shiftedIndex = (uint)((int)pinConf << 0x18) >> 0x1c;\n  pinMap[shiftedIndex] = pinMap[shiftedIndex] | 1 << ((int)pinConf & 0xfU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800480a": "update_pin_map_0800480a",
                "pin": "pinConf",
                "map": "pinMap",
                "uVar1": "shiftedIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004828": {
            "entrypoint": "0x08004828",
            "current_name": "update_map_08004828",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateMap_08004828(PinName_conflict pinName,uint32_t *map)\n\n{\n  uint shiftedIndex;\n  uint32_t unmodifiedIndex;\n  \n  shiftedIndex = (uint)((int)pinName << 0x18) >> 0x1c;\n  map[shiftedIndex] = map[shiftedIndex] & ~(1 << ((int)pinName & 0xfU));\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004828": "update_map_08004828",
                "pin": "pinName",
                "uVar1": "shiftedIndex",
                "index": "unmodifiedIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004848": {
            "entrypoint": "0x08004848",
            "current_name": "get_gpio_by_port_index_08004848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * getGPIOByPortIndex_08004848(uint32_t portIndex)\n\n{\n  switch(portIndex) {\n  case 0:\n    return (GPIO_TypeDef *)0x40010800;\n  case 1:\n    return (GPIO_TypeDef *)0x40010c00;\n  case 2:\n    return (GPIO_TypeDef *)0x40011000;\n  case 3:\n    return (GPIO_TypeDef *)0x40011400;\n  case 4:\n    return (GPIO_TypeDef *)0x40011800;\n  default:\n    return (GPIO_TypeDef *)0x0;\n  }\n}\n\n",
            "renaming": {
                "FUN_08004848": "get_gpio_by_port_index_08004848",
                "port_idx": "portIndex"
            },
            "calling": [
                "digitalWrite",
                "digitalRead"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004884": {
            "entrypoint": "0x08004884",
            "current_name": "get_gpio_08004884",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * getGPIO_08004884(uint32_t portIndex)\n\n{\n  GPIO_TypeDef *gpioPtr;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister1;\n  uint32_t temporaryRegister2;\n  uint32_t temporaryRegister3;\n  uint32_t temporaryRegister4;\n  \n  switch(portIndex) {\n  case 0:\n    _DAT_40021018 = _DAT_40021018 | 4;\n    gpioPtr = (GPIO_TypeDef *)0x40010800;\n    break;\n  case 1:\n    _DAT_40021018 = _DAT_40021018 | 8;\n    gpioPtr = (GPIO_TypeDef *)0x40010c00;\n    break;\n  case 2:\n    _DAT_40021018 = _DAT_40021018 | 0x10;\n    gpioPtr = (GPIO_TypeDef *)0x40011000;\n    break;\n  case 3:\n    _DAT_40021018 = _DAT_40021018 | 0x20;\n    gpioPtr = (GPIO_TypeDef *)0x40011400;\n    break;\n  case 4:\n    _DAT_40021018 = _DAT_40021018 | 0x40;\n    gpioPtr = (GPIO_TypeDef *)0x40011800;\n    break;\n  default:\n    gpioPtr = (GPIO_TypeDef *)0x0;\n  }\n  return gpioPtr;\n}\n\n",
            "renaming": {
                "FUN_08004884": "get_gpio_08004884",
                "port_idx": "portIndex",
                "pGVar1": "gpioPtr",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister1",
                "tmpreg_2": "temporaryRegister2",
                "tmpreg_3": "temporaryRegister3",
                "tmpreg_4": "temporaryRegister4"
            },
            "calling": [
                "digital_io_init",
                "uart_init",
                "HAL_ADC_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800492c": {
            "entrypoint": "0x0800492c",
            "current_name": "get_mapped_function_0800492c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getMappedFunction_0800492c(PinName_conflict pin)\n\n{\n  uint32_t functionMapping;\n  uint32_t mappedFunction;\n  \n  functionMapping = pinmap_mappedFunction(pin,(PinMap_conflict *)&PinMap_ADC);\n  mappedFunction = functionMapping << 0xc;\n  mappedFunction = mappedFunction >> 0x1b;\n  if (0x10 < mappedFunction - 1) {\n    mappedFunction = 0;\n  }\n  return mappedFunction;\n}\n\n",
            "renaming": {
                "FUN_0800492c": "get_mapped_function_0800492c",
                "uVar1": "functionMapping",
                "function": "mappedFunction"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004948": {
            "entrypoint": "0x08004948",
            "current_name": "get_pwm_function_08004948",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_pwm_function_08004948(PinName_conflict pin)\n\n{\n  uint32_t function_code;\n  uint32_t mapped_function;\n  \n  function_code = pinmap_mapped_function(pin,(PinMap_conflict *)&PinMap_PWM);\n  mapped_function = function_code << 0xc;\n  mapped_function = mapped_function >> 0x1b;\n  if (mapped_function == 3) {\n    return 8;\n  }\n  if (mapped_function != 4) {\n    if (mapped_function != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
            "renaming": {
                "FUN_08004948": "get_pwm_function_08004948",
                "uVar1": "function_code",
                "function": "mapped_function"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004974": {
            "entrypoint": "0x08004974",
            "current_name": "configure_adc_08004974",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureADC_08004974(ADC_HandleTypeDef *adcHandle)\n\n{\n  GPIO_TypeDef *gpioPort;\n  GPIO_TypeDef *gpioPort;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister1;\n  GPIO_InitTypeDef gpioInitStructure;\n  \n  if (adcHandle->Instance == (ADC_TypeDef *)0x40012400) {\n    _DAT_40021018 = _DAT_40021018 | 0x200;\n  }\n  else if (adcHandle->Instance == (ADC_TypeDef *)0x40012800) {\n    _DAT_40021018 = _DAT_40021018 | 0x400;\n  }\n  gpioPort = set_GPIO_Port_Clock((uint)((int)g_current_pin << 0x18) >> 0x1c);\n  gpioInitStructure.Pin = 1 << (g_current_pin & 0xfU) & 0xffff;\n  gpioInitStructure.Mode = 3;\n  gpioInitStructure.Pull = 0;\n  HAL_GPIO_Init(gpioPort,&gpioInitStructure);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004974": "configure_adc_08004974",
                "hadc": "adcHandle",
                "GPIOx": "gpioPort",
                "port": "gpioPort",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister1",
                "GPIO_InitStruct": "gpioInitStructure"
            },
            "calling": [
                "HAL_ADC_Init"
            ],
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049f0": {
            "entrypoint": "0x080049f0",
            "current_name": "update_adc_registers_080049f0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid update_ADC_registers_080049f0(ADC_HandleTypeDef *ADC_handle)\n\n{\n  if (ADC_handle->ADC_Instance != (ADC_TypeDef *)0x40012400) {\n    if (ADC_handle->ADC_Instance == (ADC_TypeDef *)0x40012800) {\n      _DAT_4002100c = _DAT_4002100c & 0xfffffbff;\n      _DAT_40021018 = _DAT_40021018 & 0xfffffbff;\n    }\n    return;\n  }\n  _DAT_4002100c = _DAT_4002100c & 0xfffffdff;\n  _DAT_40021018 = _DAT_40021018 & 0xfffffdff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080049f0": "update_adc_registers_080049f0",
                "hadc": "ADC_handle",
                "Instance": "ADC_Instance"
            },
            "calling": [
                "HAL_ADC_DeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a4c": {
            "entrypoint": "0x08004a4c",
            "current_name": "get_adc_converted_value_08004a4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint16_t get_ADC_converted_value_08004a4c(PinName_conflict pin_name)\n\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t converted_value;\n  uint16_t ADC_converted_value;\n  ADC_ChannelConfTypeDef ADC_channel_config;\n  ADC_HandleTypeDef ADC_handle;\n  \n  memset(&ADC_handle,0,0x30);\n  ADC_channel_config.Channel = 0;\n  ADC_channel_config.Rank = 0;\n  ADC_channel_config.SamplingTime = 0;\n  ADC_converted_value = 0;\n  ADC_handle.Instance = (ADC_TypeDef *)pin_namemap_peripheral(pin_name,(PinMap_conflict *)&PinMap_ADC);\n  if (ADC_handle.Instance == (ADC_TypeDef *)0x0) {\n    ADC_converted_value = 0;\n  }\n  else {\n    ADC_handle.Init.DataAlign = 0;\n    ADC_handle.Init.ScanConvMode = 0;\n    ADC_handle.Init.ContinuousConvMode = 0;\n    ADC_handle.Init.DiscontinuousConvMode = 0;\n    ADC_handle.Init.ExternalTrigConv = 0xe0000;\n    ADC_handle.State = 0;\n    ADC_handle.Init.NbrOfConversion = 1;\n    ADC_handle.Init.NbrOfDiscConversion = 0;\n    g_current_pin_name = pin_name;\n    status = HAL_ADC_Init(&ADC_handle);\n    if (status == HAL_OK) {\n      ADC_channel_config.Channel = get_adc_channel(pin_name);\n      if (ADC_channel_config.Channel < 0x12) {\n        ADC_channel_config.Rank = 1;\n        ADC_channel_config.SamplingTime = 2;\n        status = HAL_ADC_ConfigChannel(&ADC_handle,&ADC_channel_config);\n        if (status == HAL_OK) {\n          status = HAL_ADCEx_Calibration_Start(&ADC_handle);\n          if (status == HAL_OK) {\n            status = HAL_ADC_Start(&ADC_handle);\n            if (status == HAL_OK) {\n              status = HAL_ADC_PollForConversion(&ADC_handle,10);\n              if (status == HAL_OK) {\n                converted_value = HAL_ADC_GetState(&ADC_handle);\n                if ((converted_value & 0x200) != 0) {\n                  converted_value = HAL_ADC_GetValue(&ADC_handle);\n                  ADC_converted_value = (uint16_t)converted_value;\n                }\n                status = HAL_ADC_Stop(&ADC_handle);\n                if (status == HAL_OK) {\n                  status = HAL_ADC_DeInit(&ADC_handle);\n                  if (status != HAL_OK) {\n                    ADC_converted_value = 0;\n                  }\n                }\n                else {\n                  ADC_converted_value = 0;\n                }\n              }\n              else {\n                ADC_converted_value = 0;\n              }\n            }\n            else {\n              ADC_converted_value = 0;\n            }\n          }\n          else {\n            ADC_converted_value = 0;\n          }\n        }\n        else {\n          ADC_converted_value = 0;\n        }\n      }\n      else {\n        ADC_converted_value = 0;\n      }\n    }\n    else {\n      ADC_converted_value = 0;\n    }\n  }\n  return ADC_converted_value;\n}\n\n",
            "renaming": {
                "FUN_08004a4c": "get_adc_converted_value_08004a4c",
                "pin": "pin_name",
                "HVar1": "status",
                "uVar2": "converted_value",
                "uhADCxConvertedValue": "ADC_converted_value",
                "AdcChannelConf": "ADC_channel_config",
                "AdcHandle": "ADC_handle"
            },
            "calling": [
                "analogRead"
            ],
            "called": [
                "HAL_ADC_DeInit",
                "HAL_ADC_GetState",
                "get_adc_channel",
                "HAL_ADC_PollForConversion",
                "HAL_ADC_ConfigChannel",
                "HAL_ADC_GetValue",
                "memset",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Stop",
                "pinmap_peripheral",
                "HAL_ADC_Init",
                "HAL_ADC_Start"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b34": {
            "entrypoint": "0x08004b34",
            "current_name": "disable_timer_clock_08004b34",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_timer_clock_08004b34(TIM_HandleTypeDef *timer_handle)\n\n{\n  disable_timer_clock_08004b34(timer_handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b34": "disable_timer_clock_08004b34",
                "htim": "timer_handle",
                "timer_disable_clock": "disable_timer_clock"
            },
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "called": [
                "timer_disable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b3c": {
            "entrypoint": "0x08004b3c",
            "current_name": "stop_pwm_channel_08004b3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopPwmChannel_08004b3c(pin pin)\n\n{\n  uint32_t pwmChannel;\n  uint32_t timpwmChannel;\n  uint32_t functionResult;\n  TIM_HandleTypeDef timHandle;\n  \n  timHandle.Instance = (TIM_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)&PinMap_PWM);\n  if ((timHandle.Instance != (TIM_TypeDef *)0x0) &&\n     ((((pwmChannel = get_pwm_channel(pin), pwmChannel == 0 || (pwmChannel == 4)) || (pwmChannel == 8)) ||\n      ((pwmChannel == 0xc || (pwmChannel == 0x18)))))) {\n    functionResult = pinmap_function(pin,(PinMap_conflict *)&PinMap_PWM);\n    if ((functionResult & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(&timHandle,pwmChannel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(&timHandle,pwmChannel);\n    }\n    HAL_TIM_PWM_DeInit(&timHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b3c": "stop_pwm_channel_08004b3c",
                "PinName_conflict": "pin",
                "Channel": "pwmChannel",
                "uVar1": "functionResult"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_TIM_PWM_DeInit",
                "HAL_TIM_PWM_Stop",
                "get_pwm_channel",
                "pinmap_peripheral",
                "HAL_TIMEx_PWMN_Stop",
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b94": {
            "entrypoint": "0x08004b94",
            "current_name": "get_tick_count_08004b94",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTickCount_08004b94(void)\n\n{\n  uint32_t tickCount;\n  \n  tickCount = HAL_GetTick();\n  return tickCount;\n}\n\n",
            "renaming": {
                "FUN_08004b94": "get_tick_count_08004b94",
                "uVar1": "tickCount"
            },
            "calling": [
                "millis"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b9c": {
            "entrypoint": "0x08004b9c",
            "current_name": "FUNC_08004b9c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004b9c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b9c": "FUNC_08004b9c"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004b9e": {
            "entrypoint": "0x08004b9e",
            "current_name": "handle_sys_tick_event_08004b9e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickEvent_08004b9e(void)\n\n{\n  incrementTick();\n  handleSysTickInterrupt();\n  customSysTickHandler();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b9e": "handle_sys_tick_event_08004b9e",
                "HAL_IncTick": "incrementTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTickInterrupt",
                "noOsSystickHandler": "customSysTickHandler"
            },
            "calling": [],
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "noOsSystickHandler",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bb0": {
            "entrypoint": "0x08004bb0",
            "current_name": "initialize_gpio_08004bb0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeGPIO_08004bb0(pin pin,uint32_t pinMode,uint32_t pullMode)\n\n{\n  uint pinIndex;\n  GPIO_TypeDef *selectedPort;\n  GPIO_TypeDef *port;\n  uint32_t tempRegister2;\n  uint32_t tempRegister1;\n  uint32_t tempRegister;\n  GPIO_InitTypeDef GPIOInitStructure;\n  \n  pinIndex = (uint)pin;\n  selectedPort = set_GPIO_Port_Clock((pinIndex << 0x18) >> 0x1c);\n  GPIOInitStructure.Pin = 1 << (pinIndex & 0xf) & 0xffff;\n  GPIOInitStructure.Speed = 3;\n  _DAT_40021018 = _DAT_40021018 | 1;\n  if ((pinIndex - 0xd & 0xff) < 2) {\n    _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x4000000;\n  }\n  if (((pinIndex == 0xf) || (pinIndex == 0x13)) || (pinIndex == 0x14)) {\n    tempRegister1 = _DAT_40010004 & 0xf8ffffff;\n    _DAT_40010004 = tempRegister1 | 0x2000000;\n  }\n  GPIOInitStructure.Mode = pinMode;\n  GPIOInitStructure.Pull = pullMode;\n  HAL_GPIO_Init(selectedPort,&GPIOInitStructure);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bb0": "initialize_gpio_08004bb0",
                "PinName_conflict": "pin",
                "mode": "pinMode",
                "pull": "pullMode",
                "uVar1": "pinIndex",
                "GPIOx": "selectedPort",
                "tmpreg_2": "tempRegister2",
                "tmpreg_1": "tempRegister1",
                "tmpreg": "tempRegister",
                "GPIO_InitStructure": "GPIOInitStructure"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c30": {
            "entrypoint": "0x08004c30",
            "current_name": "set_gpio_pin_state_08004c30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setGPIOPinState_08004c30(GPIO_TypeDef *gpioPort,uint32_t pinNumber,uint32_t pinState)\n\n{\n  if (pinState == 0) {\n    HAL_GPIO_WritePin(gpioPort,(uint16_t)pinNumber,GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(gpioPort,(uint16_t)pinNumber,GPIO_PIN_SET);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c30": "set_gpio_pin_state_08004c30",
                "port": "gpioPort",
                "pin": "pinNumber",
                "val": "pinState"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c48": {
            "entrypoint": "0x08004c48",
            "current_name": "read_pin_state_08004c48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t readPinState_08004c48(GPIO_TypeDef *gpioPort,uint32_t pinNumber)\n\n{\n  GPIO_PinState pinState;\n  \n  pinState = HAL_GPIO_ReadPin(gpioPort,(uint16_t)pinNumber);\n  return (uint)pinState;\n}\n\n",
            "renaming": {
                "FUN_08004c48": "read_pin_state_08004c48",
                "port": "gpioPort",
                "pin": "pinNumber",
                "GVar1": "pinState"
            },
            "calling": [
                "digitalRead"
            ],
            "called": [
                "HAL_GPIO_ReadPin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c52": {
            "entrypoint": "0x08004c52",
            "current_name": "initialize_hardware_08004c52",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeHardware_08004c52(void)\n\n{\n  initializeHardware_08004c52AbstractionLayer();\n  configureSystemClock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c52": "initialize_hardware_08004c52",
                "HAL_Init": "initializeHardwareAbstractionLayer",
                "SystemClock_Config": "configureSystemClock"
            },
            "calling": [
                "init"
            ],
            "called": [
                "HAL_Init",
                "SystemClock_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c5e": {
            "entrypoint": "0x08004c5e",
            "current_name": "find_peripheral_from_pin_08004c5e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * findPeripheralFromPin_08004c5e(PinName targetPin,PinMap *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->targetPin == NC) {\n      return (void *)0x0;\n    }\n    if (pinMap->targetPin == targetPin) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->peripheral;\n}\n\n",
            "renaming": {
                "FUN_08004c5e": "find_peripheral_from_pin_08004c5e",
                "pin": "targetPin",
                "map": "pinMap",
                "PinName_conflict": "PinName",
                "PinMap_conflict": "PinMap"
            },
            "calling": [
                "pinmap_find_peripheral",
                "pinmap_peripheral"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c78": {
            "entrypoint": "0x08004c78",
            "current_name": "find_peripheral_08004c78",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * find_peripheral_08004c78(PinName_conflict pin_number,PinMap_conflict *pin_map)\n\n{\n  void *peripheral;\n  \n  if (pin_number != NC) {\n    peripheral = pin_numberpin_map_find_peripheral_08004c78(pin_number,pin_map);\n    return peripheral;\n  }\n  return (void *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08004c78": "find_peripheral_08004c78",
                "pin": "pin_number",
                "map": "pin_map",
                "pvVar1": "peripheral"
            },
            "calling": [
                "uart_debug_init",
                "adc_read_value",
                "pwm_stop",
                "uart_init",
                "uart_debug_write"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c8a": {
            "entrypoint": "0x08004c8a",
            "current_name": "find_pin_name_08004c8a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict findPinName_08004c8a(void *device,PinMap_conflict *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->device == (void *)0x0) {\n      return NotConnected;\n    }\n    if (pinMap->device == device) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->pin;\n}\n\n",
            "renaming": {
                "FUN_08004c8a": "find_pin_name_08004c8a",
                "peripheral": "device",
                "map": "pinMap",
                "NC": "NotConnected"
            },
            "calling": [
                "pinmap_pin",
                "pinmap_find_pin"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ca2": {
            "entrypoint": "0x08004ca2",
            "current_name": "find_pin_by_peripheral_08004ca2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict find_pin_by_peripheral_08004ca2(void *peripheral,PinMap_conflict *pin_map)\n\n{\n  PinName_conflict found_pin;\n  \n  if (peripheral != (void *)0x0) {\n    found_pin = pinpin_map_find_pin(peripheral,pin_map);\n    return found_pin;\n  }\n  return NC;\n}\n\n",
            "renaming": {
                "FUN_08004ca2": "find_pin_by_peripheral_08004ca2",
                "map": "pin_map",
                "PVar1": "found_pin"
            },
            "calling": [
                "uart_debug_init",
                "HardwareSerial"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cb2": {
            "entrypoint": "0x08004cb2",
            "current_name": "find_pin_function_08004cb2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t findPinFunction_08004cb2(pinToFind pin,pinMap *map)\n\n{\n  while( true ) {\n    if (map->pin == NC) {\n      return 0xffffffff;\n    }\n    if (map->pin == pin) break;\n    map = map + 1;\n  }\n  return map->function;\n}\n\n",
            "renaming": {
                "FUN_08004cb2": "find_pin_function_08004cb2",
                "PinName_conflict": "pinToFind",
                "PinMap_conflict": "pinMap"
            },
            "calling": [
                "pinmap_find_function",
                "pinmap_function"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cce": {
            "entrypoint": "0x08004cce",
            "current_name": "find_pin_function_08004cce",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t find_pin_function_08004cce(PinName_conflict pin,PinMap_conflict *pin_map)\n\n{\n  uint32_t result;\n  \n  if (pin == NC) {\n    return 0xffffffff;\n  }\n  result = pinpin_map_find_function(pin,pin_map);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004cce": "find_pin_function_08004cce",
                "map": "pin_map",
                "uVar1": "result"
            },
            "calling": [
                "get_adc_channel",
                "pwm_stop",
                "get_pwm_channel",
                "uart_init"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ce2": {
            "entrypoint": "0x08004ce2",
            "current_name": "pin_is_valid_08004ce2",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool pinIsValid_08004ce2(PinName_conflict pinToCheck,PinMap_conflict *pinMap)\n\n{\n  if (pinToCheck == NotConnected) {\n    return false;\n  }\n  while( true ) {\n    if (pinMap->pinToCheck == NotConnected) {\n      return false;\n    }\n    if (pinToCheck == pinMap->pinToCheck) break;\n    pinMap = pinMap + 1;\n  }\n  return true;\n}\n\n",
            "renaming": {
                "FUN_08004ce2": "pin_is_valid_08004ce2",
                "pin": "pinToCheck",
                "map": "pinMap",
                "NC": "NotConnected"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d06": {
            "entrypoint": "0x08004d06",
            "current_name": "merge_pointers_08004d06",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * merge_pointers_08004d06(void *a,void *b)\n\n{\n  if (a != b) {\n    if (a == (void *)0x0) {\n      return b;\n    }\n    if (b == (void *)0x0) {\n      return a;\n    }\n    a = (void *)0x0;\n  }\n  return a;\n}\n\n",
            "renaming": {
                "FUN_08004d06": "merge_pointers_08004d06"
            },
            "calling": [
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d18": {
            "entrypoint": "0x08004d18",
            "current_name": "execute_rtc_user_callback_08004d18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid executeRTCUserCallback_08004d18(rtcHandler *hrtc)\n\n{\n  if (userCallback != (callbackFunctionPtr)0x0) {\n    (*userCallback)(userData);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d18": "execute_rtc_user_callback_08004d18",
                "RTC_HandleTypeDef": "rtcHandler",
                "RTCUserCallback": "userCallback",
                "voidCallbackPtr": "callbackFunctionPtr",
                "callbackUserData": "userData"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d30": {
            "entrypoint": "0x08004d30",
            "current_name": "handle_alarm_irq_08004d30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleAlarmIRQ_08004d30(void)\n\n{\n  HAL_RTC_AlarmIRQHandler(rtcHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d30": "handle_alarm_irq_08004d30",
                "&RtcHandle": "rtcHandle"
            },
            "calling": [],
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d40": {
            "entrypoint": "0x08004d40",
            "current_name": "loop_forever_08004d40",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid loopForever_08004d40(char *message,int value)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004d40": "loop_forever_08004d40",
                "msg": "message",
                "val": "value"
            },
            "calling": [
                "_Error_Handler",
                "SystemClock_Config"
            ],
            "called": [
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d44": {
            "entrypoint": "0x08004d44",
            "current_name": "initialize_peripheral_08004d44",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializePeripheral_08004d44(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d44": "initialize_peripheral_08004d44"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d90": {
            "entrypoint": "0x08004d90",
            "current_name": "configure_timers_08004d90",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureTimers_08004d90(TIM_HandleTypeDef *timer)\n\n{\n  if (timer->Instance == (TIM_TypeDef *)0x40012c00) {\n    _DAT_40021018 = _DAT_40021018 & 0xfffff7ff;\n  }\n  if (timer->Instance == (TIM_TypeDef *)0x40000000) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffe;\n  }\n  if (timer->Instance == (TIM_TypeDef *)0x40000400) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffd;\n  }\n  if (timer->Instance == (TIM_TypeDef *)0x40000800) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d90": "configure_timers_08004d90",
                "htim": "timer"
            },
            "calling": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004df4": {
            "entrypoint": "0x08004df4",
            "current_name": "get_stimer_08004df4",
            "code": "\n/* WARNING: Unknown calling convention */\n\ntimer_struct * get_stimer_08004df4(TIM_HandleTypeDef *timer_handle)\n\n{\n  return (timer_struct *)&timer_handle[-1].lock;\n}\n\n",
            "renaming": {
                "FUN_08004df4": "get_stimer_08004df4",
                "htim": "timer_handle",
                "stimer_t": "timer_struct",
                "Lock": "lock"
            },
            "calling": [
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004df8": {
            "entrypoint": "0x08004df8",
            "current_name": "handle_timer_irq_08004df8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_timer_IRQ_08004df8(TIM_HandleTypeDef *timer_handle)\n\n{\n  stimer_t *timer_obj;\n  stimer_t *timer_obj;\n  \n  timer_obj = get_timer_timer_obj(timer_handle);\n  if ((timer_obj->timer_interrupt_handler != (function_pointer *)0x0) &&\n     (timer_handle->active_channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*timer_obj->timer_interrupt_handler)(timer_obj,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004df8": "handle_timer_irq_08004df8",
                "htim": "timer_handle",
                "psVar1": "timer_obj",
                "obj": "timer_obj",
                "irqHandleOC": "timer_interrupt_handler",
                "_func_void_stimer_t_ptr_uint32_t": "function_pointer",
                "Channel": "active_channel"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e12": {
            "entrypoint": "0x08004e12",
            "current_name": "handle_timer_interrupt_08004e12",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08004e12(timerHandle *htim)\n\n{\n  timerObject *timerObj;\n  timerObject *pointerToObject;\n  \n  timerObj = get_timer_pointerToObject(htim);\n  if (timerObj->irqHandle != (timerInterruptFunctionPtr *)0x0) {\n    (*timerObj->irqHandle)(timerObj);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e12": "handle_timer_interrupt_08004e12",
                "TIM_HandleTypeDef": "timerHandle",
                "stimer_t": "timerObject",
                "psVar1": "timerObj",
                "obj": "pointerToObject",
                "_func_void_stimer_t_ptr": "timerInterruptFunctionPtr"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e20": {
            "entrypoint": "0x08004e20",
            "current_name": "handle_timer_interrupt_08004e20",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08004e20(void)\n\n{\n  if (timerHandles[0] != (TimerHandleType *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[0]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e20": "handle_timer_interrupt_08004e20",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandleType"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e34": {
            "entrypoint": "0x08004e34",
            "current_name": "handle_timer_interrupt_08004e34",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08004e34(void)\n\n{\n  if (timerHandles[1] != (TimerHandle *)0x0) {\n    handleTimerIRQ(timerHandles[1]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e34": "handle_timer_interrupt_08004e34",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleTimerIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e48": {
            "entrypoint": "0x08004e48",
            "current_name": "handle_timer2_interrupt_08004e48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimer2Interrupt_08004e48(void)\n\n{\n  if (timerHandles[2] != (TimerHandle *)0x0) {\n    handleTimerInterrupt(timerHandles[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e48": "handle_timer2_interrupt_08004e48",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleTimerInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e5c": {
            "entrypoint": "0x08004e5c",
            "current_name": "handle_timer_interrupt_08004e5c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08004e5c(void)\n\n{\n  if (timerHandles[3] != (TimerHandler *)0x0) {\n    handleTimerIRQ(timerHandles[3]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e5c": "handle_timer_interrupt_08004e5c",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandler",
                "HAL_TIM_IRQHandler": "handleTimerIRQ"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e70": {
            "entrypoint": "0x08004e70",
            "current_name": "get_i2c_t_from_hi2c_08004e70",
            "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_struct * get_i2c_t_from_hi2c_08004e70(I2C_HandleTypeDef *i2c_handle)\n\n{\n  return (i2c_struct *)&i2c_handle[-1].event_count;\n}\n\n",
            "renaming": {
                "FUN_08004e70": "get_i2c_t_from_hi2c_08004e70",
                "hi2c": "i2c_handle",
                "i2c_t": "i2c_struct",
                ".EventCount": ".event_count"
            },
            "calling": [
                "HAL_I2C_AddrCallback",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e74": {
            "entrypoint": "0x08004e74",
            "current_name": "handle_transfer_08004e74",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTransfer_08004e74(I2C_HandleTypeDef *i2cHandle,uint8_t direction,uint16_t addressCode)\n\n{\n  i2c_t *i2cObj;\n  i2c_t *i2cObj2;\n  \n  i2cObj = get_i2c_i2cObj2(i2cHandle);\n  if ((uint)addressCode == (i2cHandle->Init).OwnAddress1) {\n    if (direction == '\\0') {\n      i2cObj->i2cTxRxBufferSize = '\\0';\n      i2cObj->slaveMode = '\\0';\n      if (i2cObj->i2c_onSlaveTransmit != (_func_void *)0x0) {\n        (*i2cObj->i2c_onSlaveTransmit)();\n      }\n      HAL_I2C_Slave_Sequential_Transmit_IT\n                (i2cHandle,i2cObj->i2cTxRxBuffer,(ushort)i2cObj->i2cTxRxBufferSize,8);\n      return;\n    }\n    i2cObj->slaveMode = '\\x01';\n    HAL_I2C_Slave_Sequential_Receive_IT(i2cHandle,i2cObj->i2cTxRxBuffer,0x20,8);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e74": "handle_transfer_08004e74",
                "hi2c": "i2cHandle",
                "TransferDirection": "direction",
                "AddrMatchCode": "addressCode",
                "piVar1": "i2cObj",
                "obj": "i2cObj2"
            },
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "called": [
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "HAL_I2C_Slave_Sequential_Transmit_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ec4": {
            "entrypoint": "0x08004ec4",
            "current_name": "enable_slave_receive_interrupt_08004ec4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableSlaveReceiveInterrupt_08004ec4(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2cStructure *i2cObjPtr;\n  I2cStructure *i2cObj;\n  uint numBytesToSend;\n  \n  i2cObjPtr = getI2cObject(i2cHandle);\n  if (((i2cObjPtr->i2c_onSlaveReceive != (_func_void_uint8_t_ptr_int *)0x0) &&\n      (i2cObjPtr->slaveMode == '\\x01')) &&\n     (numBytesToSend = 0x20 - *(byte *)&(i2cObjPtr->handle).XferSize & 0xff, numBytesToSend != 0)) {\n    (*i2cObjPtr->i2c_onSlaveReceive)(i2cObjPtr->i2cTxRxBuffer,numBytesToSend);\n  }\n  HAL_I2C_EnableListen_IT(i2cHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ec4": "enable_slave_receive_interrupt_08004ec4",
                "hi2c": "i2cHandle",
                "get_i2c_obj": "getI2cObject",
                "i2c_t": "I2cStructure",
                "piVar1": "i2cObjPtr",
                "obj": "i2cObj",
                "uVar2": "numBytesToSend"
            },
            "calling": [
                "I2C_ITError",
                "I2C_Slave_AF",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef4": {
            "entrypoint": "0x08004ef4",
            "current_name": "enable_listen_interrupt_08004ef4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableListenInterrupt_08004ef4(I2C_HandleTypeDef *i2cHandler)\n\n{\n  i2c_t *i2cObject;\n  i2c_t *i2cObjectTemp;\n  \n  i2cObject = get_i2c_i2cObjectTemp(i2cHandler);\n  if (i2cObject->isMaster == '\\0') {\n    HAL_I2C_EnableListen_IT(i2cHandler);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef4": "enable_listen_interrupt_08004ef4",
                "hi2c": "i2cHandler",
                "piVar1": "i2cObject",
                "obj": "i2cObjectTemp"
            },
            "calling": [
                "I2C_DMAAbort",
                "I2C_ITError"
            ],
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f0c": {
            "entrypoint": "0x08004f0c",
            "current_name": "handle_i2_c_event_08004f0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvent_08004f0c(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2cHandles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f0c": "handle_i2_c_event_08004f0c",
                "i2c_handles": "i2cHandles"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f1c": {
            "entrypoint": "0x08004f1c",
            "current_name": "handle_i2_c_error_interrupt_08004f1c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CErrorInterrupt_08004f1c(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c_handles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f1c": "handle_i2_c_error_interrupt_08004f1c"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f2c": {
            "entrypoint": "0x08004f2c",
            "current_name": "handle_i2_c_events_08004f2c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvents_08004f2c(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2c2ErrorHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f2c": "handle_i2_c_events_08004f2c",
                "I2C2_ER_IRQHandler::handle": "i2c2ErrorHandler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "handle_i2_c_error_interrupt_08004f3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CErrorInterrupt_08004f3c(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2cHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "handle_i2_c_error_interrupt_08004f3c",
                "I2C2_ER_IRQHandler::handle": "i2cHandler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f4c": {
            "entrypoint": "0x08004f4c",
            "current_name": "initialize_serial_08004f4c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerial_08004f4c(serial_t *serialObject)\n\n{\n  void *a;\n  USART_TypeDef *txUART;\n  void *b;\n  USART_TypeDef *rxUART;\n  USART_TypeDef *mergedPeripheral;\n  GPIO_TypeDef *gpioPort;\n  GPIO_TypeDef *gpioPort;\n  uint32_t pinFunction;\n  uint32_t tempRegister_4;\n  uint32_t tempRegister_5;\n  uint32_t tempRegister_6;\n  uint32_t tempRegister_7;\n  uint32_t tempRegister_8;\n  uint32_t tempRegister_9;\n  uint32_t tempRegister_10;\n  uint32_t tempRegister_11;\n  uint32_t tempRegister_12;\n  uint32_t tempRegister_13;\n  uint32_t tempRegister_14;\n  uint32_t tempRegister_15;\n  uint32_t tempRegister_16;\n  UART_HandleTypeDef *uartHandle;\n  uint32_t tempRegister;\n  uint32_t tempRegister_1;\n  uint32_t tempRegister_2;\n  uint32_t tempRegister_3;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  if (serialObject != (serial_t *)0x0) {\n    a = pinmap_peripheral(serialObject->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n    b = pinmap_peripheral(serialObject->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(\"ERROR: at least one UART pin has no peripheral\\n\");\n    }\n    else {\n      mergedPeripheral = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      serialObject->uart = mergedPeripheral;\n      if (mergedPeripheral == (USART_TypeDef *)0x0) {\n        iprintf(\"ERROR: U(S)ART pins mismatch\\n\");\n      }\n      else {\n        if (mergedPeripheral == (USART_TypeDef *)0x40013800) {\n          _DAT_4002100c = _DAT_4002100c & 0xffffbfff;\n          _DAT_40021018 = _DAT_40021018 | 0x4000;\n          serialObject->index = '\\0';\n          serialObject->irq = USART1_IRQn;\n        }\n        else if (mergedPeripheral == (USART_TypeDef *)0x40004400) {\n          _DAT_40021010 = _DAT_40021010 & 0xfffdffff;\n          _DAT_4002101c = _DAT_4002101c | 0x20000;\n          serialObject->index = '\\x01';\n          serialObject->irq = USART2_IRQn;\n        }\n        else if (mergedPeripheral == (USART_TypeDef *)0x40004800) {\n          _DAT_40021010 = _DAT_40021010 & 0xfffbffff;\n          _DAT_4002101c = _DAT_4002101c | 0x40000;\n          serialObject->index = '\\x02';\n          serialObject->irq = USART3_IRQn;\n        }\n        gpioPort = set_GPIO_Port_Clock((uint)((int)serialObject->pin_rx << 0x18) >> 0x1c);\n        pinFunction = pinmap_function(serialObject->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n        gpioInitStruct.Pin = 1 << (serialObject->pin_rx & 0xfU) & 0xffff;\n        gpioInitStruct.Mode = (pinFunction >> 3 & 1) << 4 | pinFunction & 7;\n        gpioInitStruct.Pull = (pinFunction << 0x1a) >> 0x1e;\n        _DAT_40021018 = _DAT_40021018 | 1;\n        switch((pinFunction << 0x11) >> 0x19) {\n        case 1:\n          tempRegister_13 = tempRegister_13 | 0x7000001;\n          break;\n        case 2:\n          tempRegister_13 = tempRegister_13 & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          tempRegister_13 = tempRegister_13 | 0x7000002;\n          break;\n        case 4:\n          tempRegister_13 = tempRegister_13 & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          tempRegister_13 = tempRegister_13 | 0x7000004;\n          break;\n        case 6:\n          tempRegister_13 = tempRegister_13 & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          tempRegister_13 = tempRegister_13 | 0x7000008;\n          break;\n        case 8:\n          tempRegister_13 = tempRegister_13 & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          tempRegister_13 = tempRegister_13 | 0x7000030;\n          break;\n        case 10:\n          tempRegister_4 = tempRegister_13 & 0xffffffcf;\n          tempRegister_13 = tempRegister_4 | 0x7000010;\n          break;\n        case 0xb:\n          tempRegister_5 = tempRegister_13 & 0xffffffcf;\n          tempRegister_13 = tempRegister_5 | 0x7000000;\n          break;\n        case 0xc:\n          tempRegister_13 = tempRegister_13 | 0x70000c0;\n          break;\n        case 0xd:\n          tempRegister_6 = tempRegister_13 & 0xffffff3f;\n          tempRegister_13 = tempRegister_6 | 0x7000040;\n          break;\n        case 0xe:\n          tempRegister_7 = tempRegister_13 & 0xffffff3f;\n          tempRegister_13 = tempRegister_7 | 0x7000000;\n          break;\n        case 0xf:\n          tempRegister_13 = tempRegister_13 | 0x7000300;\n          break;\n        case 0x10:\n          tempRegister_8 = tempRegister_13 & 0xfffffcff;\n          tempRegister_13 = tempRegister_8 | 0x7000200;\n          break;\n        case 0x11:\n          tempRegister_9 = tempRegister_13 & 0xfffffcff;\n          tempRegister_13 = tempRegister_9 | 0x7000100;\n          break;\n        case 0x12:\n          tempRegister_10 = tempRegister_13 & 0xfffffcff;\n          tempRegister_13 = tempRegister_10 | 0x7000000;\n          break;\n        case 0x13:\n          tempRegister_13 = tempRegister_13 | 0x7000c00;\n          break;\n        case 0x14:\n          tempRegister_11 = tempRegister_13 & 0xfffff3ff;\n          tempRegister_13 = tempRegister_11 | 0x7000800;\n          break;\n        case 0x15:\n          tempRegister_12 = tempRegister_13 & 0xfffff3ff;\n          tempRegister_13 = tempRegister_12 | 0x7000000;\n          break;\n        case 0x16:\n          tempRegister_13 = tempRegister_13 | 0x7001000;\n          break;\n        case 0x17:\n          tempRegister_13 = tempRegister_13 & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          tempRegister_13 = tempRegister_13 | 0x7008000;\n          break;\n        case 0x1c:\n          tempRegister_13 = tempRegister_13 & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          tempRegister_13 = tempRegister_13 & 0xf8ffffff;\n          break;\n        case 0x22:\n          tempRegister_14 = tempRegister_13 & 0xf8ffffff;\n          tempRegister_13 = tempRegister_14 | 0x1000000;\n          break;\n        case 0x23:\n          tempRegister_15 = tempRegister_13 & 0xf8ffffff;\n          tempRegister_13 = tempRegister_15 | 0x2000000;\n          break;\n        case 0x24:\n          tempRegister_16 = tempRegister_13 & 0xf8ffffff;\n          tempRegister_13 = tempRegister_16 | 0x4000000;\n        }\n        gpioInitStruct.Speed = 3;\n        HAL_GPIO_Init(gpioPort,&gpioInitStruct);\n        gpioPort = set_GPIO_Port_Clock((uint)((int)serialObject->pin_tx << 0x18) >> 0x1c);\n        pinFunction = pinmap_function(serialObject->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n        gpioInitStruct.Pin = 1 << (serialObject->pin_tx & 0xfU) & 0xffff;\n        gpioInitStruct.Mode = (pinFunction >> 3 & 1) << 4 | pinFunction & 7;\n        gpioInitStruct.Pull = (pinFunction << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(gpioPort,&gpioInitStruct);\n        uart_handlers[serialObject->index] = &serialObject->handle;\n        (serialObject->handle).Instance = serialObject->uart;\n        (serialObject->handle).Init.BaudRate = serialObject->baudrate;\n        (serialObject->handle).Init.WordLength = serialObject->databits;\n        (serialObject->handle).Init.StopBits = serialObject->stopbits;\n        (serialObject->handle).Init.Parity = serialObject->parity;\n        (serialObject->handle).Init.Mode = 0xc;\n        (serialObject->handle).Init.HwFlowCtl = 0;\n        (serialObject->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&serialObject->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f4c": "initialize_serial_08004f4c",
                "obj": "serialObject",
                "uart_tx": "txUART",
                "uart_rx": "rxUART",
                "pUVar1": "mergedPeripheral",
                "pGVar2": "gpioPort",
                "port": "gpioPort",
                "uVar3": "pinFunction",
                "huart": "uartHandle",
                "tmpreg": "tempRegister",
                "GPIO_InitStruct": "gpioInitStruct"
            },
            "calling": [
                "begin",
                "uart_debug_init"
            ],
            "called": [
                "HAL_GPIO_Init",
                "pinmap_merge_peripheral",
                "HAL_UART_Init",
                "set_GPIO_Port_Clock",
                "pinmap_peripheral",
                "iprintf",
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005384": {
            "entrypoint": "0x08005384",
            "current_name": "initialize_serial_debug_08005384",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialDebug_08005384(void)\n\n{\n  void *peripheralPtr;\n  \n  peripheralPtr = getPeripheralPtr(PA_2,(ConflictPinMap *)&PinMap_UART_TX);\n  if (peripheralPtr != (void *)0x0) {\n    peripheralPtr = getPeripheralPtr(PA_2,(ConflictPinMap *)&PinMap_UART_TX);\n    debugSerial.pin_rx = getPin(peripheralPtr,(ConflictPinMap *)&UART_RX_PinMap);\n    debugSerial.pin_tx = PA_2;\n    debugSerial.baudrate = 0x2580;\n    debugSerial.parity = 0;\n    debugSerial.databits = 0;\n    debugSerial.stopbits = 0;\n    initializeUART(&debugSerial);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005384": "initialize_serial_debug_08005384",
                "pvVar1": "peripheralPtr",
                "pinmap_peripheral": "getPeripheralPtr",
                "PinMap_conflict": "ConflictPinMap",
                "&PinMap_UART_RX": "&UART_RX_PinMap",
                "serial_debug": "debugSerial",
                "pinmap_pin": "getPin",
                "uart_init": "initializeUART"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "pinmap_pin",
                "pinmap_peripheral",
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053d4": {
            "entrypoint": "0x080053d4",
            "current_name": "transmit_data_080053d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nbufferSize_t transmitData_080053d4(uint8_t *dataBuffer,uint32_t bufferSize)\n\n{\n  HAL_StatusTypeDef_conflict transmitStatus;\n  uint32_t startTick;\n  uint32_t tickstart;\n  void *peripheralPointer;\n  USART_TypeDef *usartInstance;\n  uint32_t currentTick;\n  uint handlerIndex;\n  \n  startTick = HAL_GetTick();\n  peripheralPointer = pinmap_peripheral(PA_2,(PinMap_conflict *)&PinMap_UART_TX);\n  if (peripheralPointer == (void *)0x0) {\n    return 0;\n  }\n  handlerIndex = 0;\n  while ((handlerIndex < 5 &&\n         ((uart_handlers[handlerIndex] == (UART_HandleTypeDef *)0x0 ||\n          (usartInstance = (USART_TypeDef *)pinmap_peripheral(PA_2,(PinMap_conflict *)&PinMap_UART_TX),\n          uart_handlers[handlerIndex]->Instance != usartInstance))))) {\n    handlerIndex = handlerIndex + 1 & 0xff;\n  }\n  if (4 < handlerIndex) {\n    if ((4 < serial_debug.index) && (uart_debug_init(), 4 < serial_debug.index)) {\n      return 0;\n    }\n    handlerIndex = (uint)serial_debug.index;\n  }\n  do {\n    transmitStatus = HAL_UART_Transmit(uart_handlers[handlerIndex],dataBuffer,(uint16_t)bufferSize,1000);\n    if (transmitStatus == HAL_OK) {\n      return bufferSize;\n    }\n    currentTick = HAL_GetTick();\n  } while (currentTick - startTick < 1000);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080053d4": "transmit_data_080053d4",
                "data": "dataBuffer",
                "size": "bufferSize",
                "HVar1": "transmitStatus",
                "uVar2": "startTick",
                "pvVar3": "peripheralPointer",
                "pUVar4": "usartInstance",
                "uVar5": "currentTick",
                "uVar6": "handlerIndex"
            },
            "calling": [
                "_write"
            ],
            "called": [
                "HAL_GetTick",
                "uart_debug_init",
                "pinmap_peripheral",
                "HAL_UART_Transmit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800548c": {
            "entrypoint": "0x0800548c",
            "current_name": "is_uart_state_valid_0800548c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t is_uart_state_valid_0800548c(serial_t *serial_obj)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(uart_handlers[serial_obj->index]);\n  return (uart_state & 0x22) == 0x22;\n}\n\n",
            "renaming": {
                "FUN_0800548c": "is_uart_state_valid_0800548c",
                "obj": "serial_obj",
                "HVar1": "uart_state"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054b0": {
            "entrypoint": "0x080054b0",
            "current_name": "check_uart_state_080054b0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_state_080054b0(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(handlers_array[serial_object->index]);\n  return (uart_state & 0x21) == 0x21;\n}\n\n",
            "renaming": {
                "FUN_080054b0": "check_uart_state_080054b0",
                "obj": "serial_object",
                "HVar1": "uart_state",
                "uart_handlers": "handlers_array"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054d4": {
            "entrypoint": "0x080054d4",
            "current_name": "receive_data_080054d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint receive_data_080054d4(serial_t *serial_object,uchar *c)\n\n{\n  uint8_t is_rx_active;\n  \n  if (serial_object == (serial_t *)0x0) {\n    return -1;\n  }\n  is_rx_active = serial_rx_active(serial_object);\n  if (is_rx_active == '\\0') {\n    *c = serial_object->recv;\n    HAL_UART_Receive_IT(uart_handlers[serial_object->index],&serial_object->recv,1);\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_080054d4": "receive_data_080054d4",
                "obj": "serial_object",
                "uVar1": "is_rx_active"
            },
            "calling": [
                "_rx_complete_irq"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005510": {
            "entrypoint": "0x08005510",
            "current_name": "initialize_serial_communication_08005510",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_08005510(serial_t *obj,_func_void_serial_t_ptr *callback)\n\n{\n  byte index;\n  uint8_t rxActive;\n  \n  if (obj != (serial_t *)0x0) {\n    rxActive = serial_rx_active(obj);\n    if (rxActive == '\\0') {\n      index = obj->index;\n      receiveCallback[index] = callback;\n      callbackObject[index] = obj;\n      setInterruptPriority(obj->irq,0,1);\n      enableInterrupt(obj->irq);\n      startReceivingData(uart_handlers[obj->index],&obj->recv,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005510": "initialize_serial_communication_08005510",
                "uVar2": "rxActive",
                "bVar1": "index",
                "rx_callback": "receiveCallback",
                "rx_callback_obj": "callbackObject",
                "HAL_NVIC_SetPriority": "setInterruptPriority",
                "HAL_NVIC_EnableIRQ": "enableInterrupt",
                "HAL_UART_Receive_IT": "startReceivingData"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_UART_Receive_IT",
                "HAL_NVIC_EnableIRQ",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005568": {
            "entrypoint": "0x08005568",
            "current_name": "initialize_serial_transmission_08005568",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialTransmission_08005568(serial_t *serialObject,_func_int_serial_t_ptr *serialCallback)\n\n{\n  byte index;\n  \n  if (serialObject != (serial_t *)0x0) {\n    index = serialObject->index;\n    transmitCallback[index] = serialCallback;\n    transmitCallbackObject[index] = serialObject;\n    setInterruptPriority(serialObject->irq,0,2);\n    enableInterrupt(serialObject->irq);\n    transmitDataWithInterrupt(UARTHandlers[serialObject->index],serialObject->transmitBuffer + serialObject->transmitTail,1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005568": "initialize_serial_transmission_08005568",
                "obj": "serialObject",
                "callback": "serialCallback",
                "bVar1": "index",
                "tx_callback": "transmitCallback",
                "tx_callback_obj": "transmitCallbackObject",
                "HAL_NVIC_SetPriority": "setInterruptPriority",
                "HAL_NVIC_EnableIRQ": "enableInterrupt",
                "HAL_UART_Transmit_IT": "transmitDataWithInterrupt",
                "uart_handlers": "UARTHandlers",
                "tx_buff": "transmitBuffer",
                "tx_tail": "transmitTail"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_EnableIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055bc": {
            "entrypoint": "0x080055bc",
            "current_name": "identify_uart_handler_index_080055bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t identify_UART_handler_index_080055bc(UART_HandleTypeDef *uart_handler)\n\n{\n  uint index;\n  \n  if (uart_handler == (UART_HandleTypeDef *)0x0) {\n    index = 5;\n  }\n  else {\n    index = 0;\n    while( true ) {\n      if (4 < index) {\n        return (uint8_t)index;\n      }\n      if (uart_handler == uart_handlers[index]) break;\n      index = index + 1 & 0xff;\n    }\n  }\n  return (uint8_t)index;\n}\n\n",
            "renaming": {
                "FUN_080055bc": "identify_uart_handler_index_080055bc",
                "huart": "uart_handler",
                "uVar1": "index"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "HAL_UART_RxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055e0": {
            "entrypoint": "0x080055e0",
            "current_name": "handle_uart_data_080055e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_uart_data_080055e0(UART_HandleTypeDef *uart_handle)\n\n{\n  byte index;\n  uint8_t index;\n  uint converted_index;\n  \n  index = uart_index(uart_handle);\n  converted_index = (uint)index;\n  if (converted_index < 5) {\n    (*rx_callback[converted_index])(rx_callback_obj[converted_index]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055e0": "handle_uart_data_080055e0",
                "huart": "uart_handle",
                "bVar1": "index",
                "uVar2": "converted_index"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005604": {
            "entrypoint": "0x08005604",
            "current_name": "transmit_data_08005604",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitData_08005604(UART_HandleTypeDef *uartHandler)\n\n{\n  byte uartIndex;\n  uint8_t serialIndex;\n  int returnValue;\n  serial_t *callbackObject;\n  serial_t *callbackObjectPtr;\n  uint unsignedVar;\n  \n  uartIndex = uart_serialIndex(uartHandler);\n  unsignedVar = (uint)uartIndex;\n  callbackObjectPtr = callbackObjectArray[unsignedVar];\n  if ((unsignedVar < 5) && (returnValue = (*callbackArray[unsignedVar])(callbackObjectPtr), returnValue != -1)) {\n    transmitData_08005604IT(uartHandlersArray[callbackObjectPtr->serialIndex],callbackObjectPtr->tx_buff + callbackObjectPtr->tx_tail,1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005604": "transmit_data_08005604",
                "huart": "uartHandler",
                "bVar1": "uartIndex",
                "index": "serialIndex",
                "iVar3": "returnValue",
                "obj": "callbackObject",
                "psVar4": "callbackObjectPtr",
                "uVar2": "unsignedVar",
                "tx_callback_obj": "callbackObjectArray",
                "tx_callback": "callbackArray",
                "HAL_UART_Transmit_IT": "transmitDataIT",
                "uart_handlers": "uartHandlersArray"
            },
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005650": {
            "entrypoint": "0x08005650",
            "current_name": "initialize_uart_08005650",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeUART_08005650(UART_HandleTypeDef *uartHandle)\n\n{\n  uint32_t temporaryValue;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08005650": "initialize_uart_08005650",
                "huart": "uartHandle",
                "tmpval": "temporaryValue"
            },
            "calling": [
                "UART_DMAAbortOnError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005690": {
            "entrypoint": "0x08005690",
            "current_name": "handle_usart1_interrupt_08005690",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_USART1_interrupt_08005690(void)\n\n{\n  clear_pending_IRQ(USART1_Interrupt);\n  handle_UART_IRQ(UART_handlers[0]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005690": "handle_usart1_interrupt_08005690",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_IRQ",
                "USART1_IRQn": "USART1_Interrupt",
                "HAL_UART_IRQHandler": "handle_UART_IRQ",
                "uart_handlers": "UART_handlers"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056a8": {
            "entrypoint": "0x080056a8",
            "current_name": "handle_usart2_irq_080056a8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_USART2_IRQ_080056a8(void)\n\n{\n  clear_pending_IRQ(USART2_IRQn);\n  handle_UART_IRQ(UARTs[1]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056a8": "handle_usart2_irq_080056a8",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_IRQ",
                "HAL_UART_IRQHandler": "handle_UART_IRQ",
                "uart_handlers": "UARTs"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056c0": {
            "entrypoint": "0x080056c0",
            "current_name": "handle_usart3_interrupt_080056c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_USART3_interrupt_080056c0(void)\n\n{\n  clear_pending_IRQ(USART3_interrupt);\n  if (uart_handles[2] != (UART_HandleTypeDef *)0x0) {\n    handle_UART_IRQ(uart_handles[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056c0": "handle_usart3_interrupt_080056c0",
                "uart_handlers": "uart_handles",
                "USART3_IRQn": "USART3_interrupt",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_IRQ",
                "HAL_UART_IRQHandler": "handle_UART_IRQ"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056d8": {
            "entrypoint": "0x080056d8",
            "current_name": "expand_heap_080056d8",
            "code": "\nvoid * expandHeap_080056d8(intptr_t delta)\n\n{\n  char *currentHeapEnd;\n  char *previousHeapEnd;\n  \n  if (_sbrk::heap_end == (char *)0x0) {\n    _sbrk::heap_end = &_ebss;\n  }\n  currentHeapEnd = _sbrk::heap_end;\n  if (_sbrk::heap_end + delta <= &stack0x00000000) {\n    _sbrk::heap_end = _sbrk::heap_end + delta;\n    return currentHeapEnd;\n  }\n  errno = 0xc;\n  return (void *)0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080056d8": "expand_heap_080056d8",
                "__delta": "delta",
                "pcVar1": "currentHeapEnd",
                "prev_heap_end": "previousHeapEnd"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "check_file_validity_08005714",
            "code": "\nint check_file_validity_08005714(int file_descriptor)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08005714": "check_file_validity_08005714",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_close_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800571a": {
            "entrypoint": "0x0800571a",
            "current_name": "set_default_file_permissions_0800571a",
            "code": "\nint setDefaultFilePermissions_0800571a(int fileDescriptor,stat *fileStatBuffer)\n\n{\n  *(undefined4 *)((int)&fileStatBuffer->st_dev + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800571a": "set_default_file_permissions_0800571a",
                "__fd": "fileDescriptor",
                "__buf": "fileStatBuffer"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005724": {
            "entrypoint": "0x08005724",
            "current_name": "check_connection_08005724",
            "code": "\nint check_connection_08005724(int file_descriptor)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08005724": "check_connection_08005724",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005728": {
            "entrypoint": "0x08005728",
            "current_name": "get_file_offset_08005728",
            "code": "\n__off_t get_file_offset_08005728(int file_descriptor,__off_t offset,int origin)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005728": "get_file_offset_08005728",
                "__fd": "file_descriptor",
                "__offset": "offset",
                "__whence": "origin"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800572c": {
            "entrypoint": "0x0800572c",
            "current_name": "process_file_0800572c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint process_file_0800572c(int file_descriptor,char *buffer_ptr,int buffer_length)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800572c": "process_file_0800572c",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "buffer_ptr",
                "len_UNUSED": "buffer_length"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005730": {
            "entrypoint": "0x08005730",
            "current_name": "write_to_uart_debug_08005730",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint write_to_uart_debug_08005730(int unused_file,char *data_pointer,int data_length)\n\n{\n  size_t write_result;\n  \n  write_result = uart_debug_write((uint8_t *)data_pointer,data_length);\n  return write_result;\n}\n\n",
            "renaming": {
                "FUN_08005730": "write_to_uart_debug_08005730",
                "file_UNUSED": "unused_file",
                "ptr": "data_pointer",
                "len": "data_length",
                "sVar1": "write_result"
            },
            "calling": [
                "_write_r"
            ],
            "called": [
                "uart_debug_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800573c": {
            "entrypoint": "0x0800573c",
            "current_name": "infinite_loop_0800573c",
            "code": "\nvoid infiniteLoop_0800573c(int status)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_0800573c": "infinite_loop_0800573c",
                "__status": "status"
            },
            "calling": [
                "_exit",
                "abort"
            ],
            "called": [
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005740": {
            "entrypoint": "0x08005740",
            "current_name": "set_errno_value_08005740",
            "code": "\nint setErrnoValue_08005740(processId_t processId,int signalNumber)\n\n{\n  errno = 0x16;\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08005740": "set_errno_value_08005740",
                "__pid": "processId",
                "__sig": "signalNumber"
            },
            "calling": [
                "_kill_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005750": {
            "entrypoint": "0x08005750",
            "current_name": "get_process_id_08005750",
            "code": "\n\n\nprocess_id get_process_id_08005750(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08005750": "get_process_id_08005750",
                "__pid_t": "process_id"
            },
            "calling": [
                "_getpid_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005754": {
            "entrypoint": "0x08005754",
            "current_name": "get_analog_value_08005754",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getAnalogValue_08005754(uint32_t pinIndex)\n\n{\n  bool validPinIndex;\n  PinName_conflict pin;\n  uint16_t adcValue;\n  uint32_t analogValue;\n  \n  if (pinIndex < 0xe) {\n    if (pinIndex + 0x2e < 0x3c) {\n      validPinIndex = true;\n    }\n    else {\n      validPinIndex = false;\n    }\n  }\n  else {\n    validPinIndex = pinIndex < 0x3c;\n  }\n  if (validPinIndex) {\n    if (pinIndex < 0xe) {\n      pinIndex = pinIndex + 0x2e;\n    }\n    pin = (&digitalPin)[pinIndex];\n  }\n  else {\n    pin = NC;\n  }\n  if (pin == NC) {\n    analogValue = 0;\n  }\n  else {\n    adcValue = adc_read_value(pin);\n    analogValue = (uint32_t)adcValue;\n    if (_readResolution != 0xc) {\n      if ((uint)_readResolution < 0xc) {\n        return (uint)(adcValue >> (0xcU - _readResolution & 0xff));\n      }\n      return analogValue << (_readResolution - 0xcU & 0xff);\n    }\n  }\n  return analogValue;\n}\n\n",
            "renaming": {
                "FUN_08005754": "get_analog_value_08005754",
                "ulPin": "pinIndex",
                "bVar1": "validPinIndex",
                "p": "pin",
                "uVar2": "adcValue",
                "uVar3": "analogValue"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "adc_read_value"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057b4": {
            "entrypoint": "0x080057b4",
            "current_name": "configure_pin_080057b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_080057b4(uint32_t pinNumber,uint32_t pinMode)\n\n{\n  _Bool configuredPin;\n  PinName_conflict pin;\n  \n  if (pinNumber < 0x3c) {\n    pin = (&allDigitalPins)[pinNumber];\n  }\n  else {\n    pin = notConnected;\n  }\n  if (pin != notConnected) {\n    configuredPin = isPinConfigured(pin,outputPinConfigurations);\n    if (configuredPin) {\n      configuredPin = isPinInPinmap(pin,(PinMapin_conflict *)&pwmPinMap);\n      if (configuredPin) {\n        stopPWM(pin);\n      }\n      resetPinConfigured(pin,outputPinConfigurations);\n    }\n    switch(pinMode) {\n    case 0:\n      initializeDigitalIO(pin,0,0);\n      break;\n    case 1:\n      initializeDigitalIO(pin,1,0);\n      break;\n    case 2:\n      initializeDigitalIO(pin,0,1);\n      break;\n    case 3:\n      initializeDigitalIO(pin,0,2);\n    }\n    setPinConfigured(pin,digitalPinConfigurations);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080057b4": "configure_pin_080057b4",
                "ulPin": "pinNumber",
                "ulMode": "pinMode",
                "_Var1": "configuredPin",
                "p": "pin",
                "digitalPin": "allDigitalPins",
                "NC": "notConnected",
                "is_pin_configured": "isPinConfigured",
                "g_anOutputPinConfigured": "outputPinConfigurations",
                "pin_in_pinmap": "isPinInPinmap",
                "PinMap_PWM": "pwmPinMap",
                "pwm_stop": "stopPWM",
                "reset_pin_configured": "resetPinConfigured",
                "digital_io_init": "initializeDigitalIO",
                "set_pin_configured": "setPinConfigured",
                "g_digPinConfigured": "digitalPinConfigurations"
            },
            "calling": [
                "setup",
                "MAX31855",
                "begin"
            ],
            "called": [
                "set_pin_configured",
                "pin_in_pinmap",
                "is_pin_configured",
                "digital_io_init",
                "pwm_stop",
                "reset_pin_configured"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005848": {
            "entrypoint": "0x08005848",
            "current_name": "set_digital_pin_state_08005848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setDigitalPinState_08005848(uint32_t pinNumber,uint32_t pinValue)\n\n{\n  _Bool isConfigured;\n  GPIO_TypinConflicteDef *gpioPort;\n  PinName_conflict pinConflict;\n  uint digitalPinIndex;\n  \n  if (pinNumber < 0x3c) {\n    digitalPinIndex = (uint)(char)(&digitalPin)[pinNumber];\n  }\n  else {\n    digitalPinIndex = 0xffffffff;\n  }\n  if ((digitalPinIndex != 0xffffffff) &&\n     (isConfigured = is_pinConflictin_configured((PinName_conflict)digitalPinIndex,g_digPinConfigured), isConfigured)) {\n    gpioPort = get_GPIO_Port((digitalPinIndex << 0x18) >> 0x1c);\n    digital_io_write(gpioPort,1 << (digitalPinIndex & 0xf) & 0xffff,pinValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005848": "set_digital_pin_state_08005848",
                "ulPin": "pinNumber",
                "ulVal": "pinValue",
                "_Var1": "isConfigured",
                "port": "gpioPort",
                "p": "pinConflict",
                "uVar2": "digitalPinIndex"
            },
            "calling": [
                "setup",
                "pulseEnable",
                "send",
                "MAX31855",
                "begin",
                "loop",
                "readData",
                "write4bits",
                "write8bits"
            ],
            "called": [
                "is_pin_configured",
                "get_GPIO_Port",
                "digital_io_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005890": {
            "entrypoint": "0x08005890",
            "current_name": "read_digital_pin_value_08005890",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint readDigitalPinValue_08005890(uint32_t pinNumber)\n\n{\n  _Bool isConfigured;\n  GPIO_TypinConflicteDef *gpioPort;\n  uint32_t ioReadValue;\n  PinName_conflict pinConflict;\n  uint mappedPinNumber;\n  \n  if (pinNumber < 0x3c) {\n    mappedPinNumber = (uint)(char)(&digitalPin)[pinNumber];\n  }\n  else {\n    mappedPinNumber = 0xffffffff;\n  }\n  if (mappedPinNumber == 0xffffffff) {\n    mappedPinNumber = 0;\n  }\n  else {\n    isConfigured = is_pinConflictin_configured((PinName_conflict)mappedPinNumber,g_digPinConfigured);\n    if (isConfigured) {\n      gpioPort = get_GPIO_Port((mappedPinNumber << 0x18) >> 0x1c);\n      ioReadValue = digital_io_read(gpioPort,1 << (mappedPinNumber & 0xf) & 0xffff);\n      mappedPinNumber = ioReadValue & 0xff;\n    }\n    else {\n      mappedPinNumber = 0;\n    }\n  }\n  if (mappedPinNumber != 0) {\n    mappedPinNumber = 1;\n  }\n  return mappedPinNumber;\n}\n\n",
            "renaming": {
                "FUN_08005890": "read_digital_pin_value_08005890",
                "ulPin": "pinNumber",
                "_Var1": "isConfigured",
                "port": "gpioPort",
                "uVar2": "ioReadValue",
                "p": "pinConflict",
                "uVar3": "mappedPinNumber"
            },
            "calling": [
                "loop",
                "readData"
            ],
            "called": [
                "is_pin_configured",
                "get_GPIO_Port",
                "digital_io_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058e0": {
            "entrypoint": "0x080058e0",
            "current_name": "get_current_millisecond_080058e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getCurrentMillisecond_080058e0(void)\n\n{\n  uint32_t currentTime;\n  \n  currentTime = GetCurrentMilli();\n  return currentTime;\n}\n\n",
            "renaming": {
                "FUN_080058e0": "get_current_millisecond_080058e0",
                "uVar1": "currentTime"
            },
            "calling": [
                "setup",
                "PID",
                "loop",
                "Compute"
            ],
            "called": [
                "GetCurrentMilli"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058e8": {
            "entrypoint": "0x080058e8",
            "current_name": "FUNC_080058e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080058e8(uint32_t ms)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080058e8": "FUNC_080058e8"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080058ea": {
            "entrypoint": "0x080058ea",
            "current_name": "check_serial_transmission_080058ea",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint HardwareSerial::checkSerialTransmission_080058ea(serial_t_conflict *serialObject)\n\n{\n  ushort unsignedValue1;\n  uint16_t unsignedValue2;\n  int nextIndex;\n  \n  nextIndex = serialObject->tx_tail + 1;\n  unsignedValue1 = (ushort)nextIndex;\n  unsignedValue2 = unsignedValue1 & 0x7f;\n  if (nextIndex == 0) {\n    unsignedValue2 = -(-unsignedValue1 & 0x7f);\n  }\n  serialObject->tx_tail = unsignedValue2;\n  if (serialObject->tx_head != serialObject->tx_tail) {\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "obj": "serialObject",
                "iVar3": "nextIndex",
                "uVar1": "unsignedValue1",
                "uVar2": "unsignedValue2",
                "FUN_080058ea": "check_serial_transmission_080058ea"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800591e": {
            "entrypoint": "0x0800591e",
            "current_name": "calculate_available_bytes_0800591e",
            "code": "\n/* DWARF original prototype: int  available(HardwareSerial * serialObject) */\n\nint __serialObjectcall HardwareSerial::calculateAvailableBytes_0800591e(HardwareSerial *serialObject)\n\n{\n  return ((serialObject->_serial).receiveHead + 0x40) - (uint)(serialObject->_serial).receiveTail & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_0800591e": "calculate_available_bytes_0800591e",
                "this": "serialObject",
                "rx_head": "receiveHead",
                "rx_tail": "receiveTail"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005932": {
            "entrypoint": "0x08005932",
            "current_name": "get_next_received_byte_08005932",
            "code": "\n/* DWARF original prototype: int  peek(HardwareSerial * serial) */\n\nint __serialcall HardwareSerial::get_next_received_byte_08005932(HardwareSerial *serial)\n\n{\n  uint rx_tail;\n  \n  rx_tail = (uint)(serial->serial_data).rx_tail;\n  if ((serial->serial_data).received_head != rx_tail) {\n    return (uint)(serial->serial_data).received_buffer[rx_tail];\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "this": "serial",
                "uVar1": "rx_tail",
                "_serial": "serial_data",
                "rx_head": "received_head",
                "rx_buff": "received_buffer",
                "FUN_08005932": "get_next_received_byte_08005932"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800594e": {
            "entrypoint": "0x0800594e",
            "current_name": "read_serial_data_0800594e",
            "code": "\n/* DWARF original prototype: int  read(HardwareSerial * serial) */\n\nssize_t __serialcall\nHardwareSerial::readSerialData_0800594e(HardwareSerial *serial,int fileDescriptor,void *buffer,size_t numBytes)\n\n{\n  byte receivedByte;\n  ushort tailIndex;\n  uchar c;\n  \n  tailIndex = (serial->_serial).rx_tail;\n  if ((uint)(serial->_serial).rx_head != (uint)tailIndex) {\n    receivedByte = (serial->_serial).rx_buff[tailIndex];\n    (serial->_serial).rx_tail = tailIndex + 1 & 0x3f;\n    return (uint)receivedByte;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_0800594e": "read_serial_data_0800594e",
                "this": "serial",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "bVar1": "receivedByte",
                "uVar2": "tailIndex"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005976": {
            "entrypoint": "0x08005976",
            "current_name": "flush_serial_buffer_08005976",
            "code": "\n/* DWARF original prototype: void  flush(HardwareSerial * serialPort) */\n\nvoid __serialPortcall HardwareSerial::flushSerialBuffer_08005976(HardwareSerial *serialPort)\n\n{\n  if (serialPort->_written != false) {\n    do {\n    } while ((serialPort->_serial).tx_head != (serialPort->_serial).tx_tail);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005976": "flush_serial_buffer_08005976",
                "this": "serialPort"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800598a": {
            "entrypoint": "0x0800598a",
            "current_name": "receive_serial_data_0800598a",
            "code": "\n/* WARNING: Unknown callbufferIndexng conventbufferIndexon */\n\nvobufferIndexd HardwareSerbufferIndexal::receiveSerialData_0800598a(serbufferIndexal_t_conflbufferIndexct *serialObject)\n\n{\n  bufferIndexnt returnValue;\n  rx_buffer_bufferIndexndex_t bufferIndex;\n  ushort newHeadIndex;\n  uchar c;\n  \n  returnValue = uart_getc((serbufferIndexal_t *)serialObject,&c);\n  bufferIndexf ((returnValue == 0) && (newHeadIndex = serialObject->rx_head + 1 & 0x3f, newHeadIndex != serialObject->rx_tabufferIndexl)) {\n    serialObject->rx_buff[serialObject->rx_head] = c;\n    serialObject->rx_head = newHeadIndex;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800598a": "receive_serial_data_0800598a",
                "obj": "serialObject",
                "iVar1": "returnValue",
                "i": "bufferIndex",
                "uVar2": "newHeadIndex"
            },
            "calling": [],
            "called": [
                "uart_getc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059c8": {
            "entrypoint": "0x080059c8",
            "current_name": "write_data_080059c8",
            "code": "\n/* DWARF orindexgindexnal prototype: sindexze_t  wrindexte(HardwareSerindexal * serial, uindexnt8_t c) */\n\nssindexze_t __serialcall\nHardwareSerindexal::writeData_080059c8(HardwareSerindexal *serial,indexnt data,voindexd *buffer,sindexze_t size)\n\n{\n  byte temp;\n  uindexnt8_t isActive;\n  byte modifiedTemp;\n  indexnt temp2;\n  uindexnt txHead;\n  tx_buffer_indexndex_t index;\n  \n  serial->_wrindextten = true;\n  txHead = (uindexnt)(serial->_serindexal).tx_head;\n  temp2 = txHead + 1;\n  temp = (byte)temp2;\n  modifiedTemp = temp & 0x7f;\n  indexf (temp2 == 0) {\n    modifiedTemp = -(-temp & 0x7f);\n  }\n  do {\n  } whindexle ((serial->_serindexal).tx_taindexl == (ushort)modifiedTemp);\n  (serial->_serindexal).tx_buff[txHead] = (uindexnt8_t)data;\n  (serial->_serindexal).tx_head = (ushort)modifiedTemp;\n  isActive = serindexal_tx_actindexve((serindexal_t *)&serial->_serindexal);\n  indexf (isActive == '\\0') {\n    uart_attach_tx_callback((serindexal_t *)&serial->_serindexal,_tx_complete_indexrq + 1);\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "this": "serial",
                "__fd": "data",
                "__buf": "buffer",
                "__n": "size",
                "bVar1": "temp",
                "uVar2": "isActive",
                "bVar3": "modifiedTemp",
                "iVar4": "temp2",
                "uVar5": "txHead",
                "i": "index",
                "FUN_080059c8": "write_data_080059c8"
            },
            "calling": [],
            "called": [
                "uart_attach_tx_callback",
                "serial_tx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a18": {
            "entrypoint": "0x08005a18",
            "current_name": "FUNC_08005a18",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005a1e) */\n/* WARNING: Removing unreachable block (ram,0x08005a30) */\n/* WARNING: Removing unreachable block (ram,0x08005a26) */\n/* WARNING: Removing unreachable block (ram,0x08005a38) */\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005a18(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a18": "FUNC_08005a18"
            },
            "calling": [
                "main"
            ],
            "called": [
                "available"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005a44": {
            "entrypoint": "0x08005a44",
            "current_name": "initialize_serial_08005a44",
            "code": "\n/* DWARF original prototype: void  init(HardwareSerial * serial) */\n\nint __serialcall HardwareSerial::initializeSerial_08005a44(HardwareSerial *serial,EVP_PKEY_CTX *context)\n\n{\n  (serial->_serial).rx_buff = serial->_rx_buffer;\n  (serial->_serial).rx_head = 0;\n  (serial->_serial).rx_tail = 0;\n  (serial->_serial).tx_buff = serial->_tx_buffer;\n  (serial->_serial).tx_head = 0;\n  (serial->_serial).tx_tail = 0;\n  return (int)serial;\n}\n\n",
            "renaming": {
                "FUN_08005a44": "initialize_serial_08005a44",
                "this": "serial",
                "ctx": "context"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a68": {
            "entrypoint": "0x08005a68",
            "current_name": "initialize_serial_08005a68",
            "code": "\n/* DWARF original prototype: void  begin(HardwareSerial * serialObj, ulong baudRate, byte serialConfig) */\n\nvoid __serialObjcall HardwareSerial::initializeSerial_08005a68(HardwareSerial *serialObj,ulong baudRate,byte serialConfig)\n\n{\n  byte configBits;\n  int dataBits;\n  \n  (serialObj->_serial).baudRaterate = baudRate;\n  serialObj->_serialConfig = serialConfig;\n  configBits = serialConfig & 7;\n  if (configBits == 4) {\n    dataBits = 7;\n  }\n  else if (configBits == 6) {\n    dataBits = 8;\n  }\n  else if (configBits == 2) {\n    dataBits = 6;\n  }\n  else {\n    dataBits = 0;\n  }\n  if ((serialConfig & 0x30) == 0x30) {\n    (serialObj->_serial).parity = 0x600;\n    dataBits = dataBits + 1;\n  }\n  else if ((serialConfig & 0x20) == 0) {\n    (serialObj->_serial).parity = 0;\n  }\n  else {\n    (serialObj->_serial).parity = 0x400;\n    dataBits = dataBits + 1;\n  }\n  if ((serialConfig & 8) == 0) {\n    (serialObj->_serial).stopbits = 0;\n  }\n  else {\n    (serialObj->_serial).stopbits = 0x2000;\n  }\n  if (dataBits == 8) {\n    (serialObj->_serial).databits = 0;\n  }\n  else if (dataBits == 9) {\n    (serialObj->_serial).databits = 0x1000;\n  }\n  else {\n    dataBits = 0;\n  }\n  if (dataBits != 0) {\n    uart_init((serial_t *)&serialObj->_serial);\n    uart_attach_rx_callback((serial_t *)&serialObj->_serial,_rx_complete_irq + 1);\n    return;\n  }\n                    \n  __assert_func(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/cores/arduino/HardwareSerial.cpp\"\n                ,299,\"void HardwareSerial::begin(long unsigned int, byte)\",\"databits!=0\");\n}\n\n",
            "renaming": {
                "this": "serialObj",
                "baud": "baudRate",
                "config": "serialConfig",
                "bVar1": "configBits",
                "iVar2": "dataBits",
                "FUN_08005a68": "initialize_serial_08005a68"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "__assert_func",
                "uart_attach_rx_callback",
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b24": {
            "entrypoint": "0x08005b24",
            "current_name": "set_rx_08005b24",
            "code": "\n/* DWARF original prototype: void  setRx_08005b24(HardwareSerial * this, uint32_t rxPin) */\n\nvoid __thiscall HardwareSerial::setRx_08005b24(HardwareSerial *this,uint32_t rxPin)\n\n{\n  PinName pin;\n  \n  if (rxPin < 0x3c) {\n    pin = (&pinList)[rxPin];\n  }\n  else {\n    pin = NotConnected;\n  }\n  (this->_serial).pinrxPin = pin;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b24": "set_rx_08005b24",
                "_rx": "rxPin",
                "PVar1": "pin",
                "digitalPin": "pinList",
                "NC": "NotConnected"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b3c": {
            "entrypoint": "0x08005b3c",
            "current_name": "set_tx_pin_08005b3c",
            "code": "\n/* DWARF original prototype: void  setTx(HardwareSerial * serial, uint32_t pinIndex) */\n\nvoid __serialcall HardwareSerial::setTxPin_08005b3c(HardwareSerial *serial,uint32_t pinIndex)\n\n{\n  PinName pinName;\n  \n  if (pinIndex < 0x3c) {\n    pinName = (&digitalPin)[pinIndex];\n  }\n  else {\n    pinName = NC;\n  }\n  (serial->_serial).pinpinIndex = pinName;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b3c": "set_tx_pin_08005b3c",
                "this": "serial",
                "_tx": "pinIndex",
                "PVar1": "pinName"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b54": {
            "entrypoint": "0x08005b54",
            "current_name": "initialize_hardware_serial_08005b54",
            "code": "\n/* DWARF original prototype: HardwareSerial *  HardwareSerial(HardwareSerial * serial, void *\n   device) */\n\nHardwareSerial * __serialcall HardwareSerial::initializeHardwareSerial_08005b54(HardwareSerial *serial,void *device)\n\n{\n  PinName_conflict rxPin;\n  EVP_PKEY_CTX *context;\n  EVP_PKEY_CTX *selectedContext;\n  EVP_PKEY_CTX *context2;\n  \n  (serial->super_Stream).super_Print.write_error = 0;\n  (serial->super_Stream)._timeout = 1000;\n  (serial->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)&PTR_write_1_08007804;\n  if (serial == &Serial2) {\n    setRx(&Serial2,0);\n    setTx(&Serial2,1);\n    selectedContext = context2;\n  }\n  else {\n    rxPin = pinmap_pin(device,(PinMap_conflict *)&PinMap_UART_RX);\n    (serial->_serial).pin_rx = rxPin;\n    rxPin = pinmap_pin(device,(PinMap_conflict *)&PinMap_UART_TX);\n    (serial->_serial).pin_tx = rxPin;\n    selectedContext = context;\n  }\n  init(serial,selectedContext);\n  return serial;\n}\n\n",
            "renaming": {
                "this": "serial",
                "peripheral": "device",
                "PVar1": "rxPin",
                "extraout_r1": "context",
                "extraout_r1_00": "context2",
                "ctx": "selectedContext",
                "FUN_08005b54": "initialize_hardware_serial_08005b54"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "setTx",
                "init",
                "pinmap_pin",
                "setRx"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bb0": {
            "entrypoint": "0x08005bb0",
            "current_name": "initialize_hardware_serial_08005bb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeHardwareSerial_08005bb0(int initializeFlag,int priority)\n\n{\n  if (initializeFlag != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    initializeSerial(serial2Address,(void *)0x40004400);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005bb0": "initialize_hardware_serial_08005bb0",
                "__initialize_p": "initializeFlag",
                "__priority": "priority",
                "HardwareSerial::HardwareSerial": "initializeSerial",
                "&Serial2": "serial2Address"
            },
            "calling": [
                "_GLOBAL__sub_I_Serial2"
            ],
            "called": [
                "HardwareSerial"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bd4": {
            "entrypoint": "0x08005bd4",
            "current_name": "initialize_static_data_08005bd4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_08005bd4(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005bd4": "initialize_static_data_08005bd4"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005be2": {
            "entrypoint": "0x08005be2",
            "current_name": "print_ip_address_08005be2",
            "code": "\n/* DWARF original printerrototyprintere: size_t  printerrintTo(IPAddress * ipAddress, Print * printer) */\n\nsize_t __ipAddresscall IPAddress::printIPAddress_08005be2(IPAddress *ipAddress,Print *printer)\n\n{\n  size_t bytesPrinted;\n  size_t dotPrinted;\n  int index;\n  int total;\n  \n  total = 0;\n  for (index = 0; index < 3; index = index + 1) {\n    bytesPrinted = Print::printerrint(printer,(ipAddress->_address).bytes[index],10);\n    dotPrinted = Print::printerrint(printer,'.');\n    total = total + bytesPrinted + dotPrinted;\n  }\n  bytesPrinted = Print::printerrint(printer,(ipAddress->_address).bytes[3],10);\n  return bytesPrinted + total;\n}\n\n",
            "renaming": {
                "FUN_08005be2": "print_ip_address_08005be2",
                "this": "ipAddress",
                "p": "printer",
                "iVar3": "index",
                "iVar4": "total",
                "sVar1": "bytesPrinted",
                "sVar2": "dotPrinted"
            },
            "calling": [],
            "called": [
                "print",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c1c": {
            "entrypoint": "0x08005c1c",
            "current_name": "initialize_ip_address_08005c1c",
            "code": "\n/* DWARF original prototype: IPAddress *  IPAddress(IPAddress * ipAddress, uint8_t octet1, uint8_t\n   octet2, uint8_t octet3, uint8_t octet4) */\n\nIPAddress * __ipAddresscall\nIPAddress::initializeIPAddress_08005c1c(IPAddress *ipAddress,uint8_t octet1,uint8_t octet2,uint8_t octet3,\n          uint8_t octet4)\n\n{\n  (ipAddress->super_Printable)._vptr_Printable = (_func_int_varargs **)&DAT_08007858;\n  (ipAddress->_address).bytes[0] = octet1;\n  (ipAddress->_address).bytes[1] = octet2;\n  (ipAddress->_address).bytes[2] = octet3;\n  (ipAddress->_address).bytes[3] = octet4;\n  return ipAddress;\n}\n\n",
            "renaming": {
                "this": "ipAddress",
                "first_octet": "octet1",
                "second_octet": "octet2",
                "third_octet": "octet3",
                "fourth_octet": "octet4",
                "FUN_08005c1c": "initialize_ip_address_08005c1c"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c38": {
            "entrypoint": "0x08005c38",
            "current_name": "initialize_ip_address_08005c38",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIPAddress_08005c38(int shouldInitialize,int priority)\n\n{\n  if ((shouldInitialize == 1) && (priority == 0xffff)) {\n    IP::IP(&invalidAddress,'\\0','\\0','\\0','\\0');\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005c38": "initialize_ip_address_08005c38",
                "__initialize_p": "shouldInitialize",
                "__priority": "priority",
                "IPAddress": "IP",
                "INADDR_NONE": "invalidAddress"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "called": [
                "IPAddress"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c64": {
            "entrypoint": "0x08005c64",
            "current_name": "initialize_static_variables_08005c64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_variables_08005c64(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005c64": "initialize_static_variables_08005c64"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c72": {
            "entrypoint": "0x08005c72",
            "current_name": "write_to_file_08005c72",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005c86 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * printer, uint8_t * buffer, size_t size) */\n\nssize_t __printercall Print::writeToFile_08005c72(Print *printer,int fileDescriptor,void *buffer,size_t size)\n\n{\n  Print *currentPrinter;\n  int bytesWritten;\n  \n  bytesWritten = 0;\n  currentPrinter = printer;\n  while( true ) {\n    if (buffer == (void *)0x0) {\n      return bytesWritten;\n    }\n    currentPrinter = (Print *)(**printer->_vptr_Print)(currentPrinter,(uint)*(byte *)fileDescriptor,buffer,*printer->_vptr_Print,size)\n    ;\n    if (currentPrinter == (Print *)0x0) break;\n    bytesWritten = bytesWritten + 1;\n    fileDescriptor = (int)(fileDescriptor + 1);\n    buffer = (void *)((int)buffer + -1);\n  }\n  return bytesWritten;\n}\n\n",
            "renaming": {
                "this": "printer",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__n": "size",
                "pPVar1": "currentPrinter",
                "iVar2": "bytesWritten",
                "FUN_08005c72": "write_to_file_08005c72"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c96": {
            "entrypoint": "0x08005c96",
            "current_name": "print_string_08005c96",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005cae */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * printer, char * string) */\n\nsize_t __printercall Print::printString_08005c96(Print *printer,char *string)\n\n{\n  size_t sVar1;\n  size_t sVar2;\n  \n  if (string != (char *)0x0) {\n    sVar1 = stringlen(string);\n    sVar2 = (*printer->_vptr_Print[1])(sVar1,string,sVar1);\n    return sVar2;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005c96": "print_string_08005c96",
                "this": "printer",
                "str": "string"
            },
            "calling": [
                "setup",
                "loop",
                "printFloat",
                "println"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cb6": {
            "entrypoint": "0x08005cb6",
            "current_name": "print_character_08005cb6",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005cbc */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Printer * printer, char c) */\n\nsize_t __printercall Printer::printCharacter_08005cb6(Printer *printer,char c)\n\n{\n  size_t size;\n  \n  size = (**printer->_vptr_Printer)(printer,(int)c);\n  return size;\n}\n\n",
            "renaming": {
                "Print": "Printer",
                "this": "printer",
                "sVar1": "size",
                "FUN_08005cb6": "print_character_08005cb6"
            },
            "calling": [
                "print",
                "printTo",
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cc0": {
            "entrypoint": "0x08005cc0",
            "current_name": "print_line_08005cc0",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08005cca */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  println(Print * printObject) */\n\nsize_t __printObjectcall Print::printLine_08005cc0(Print *printObject)\n\n{\n  size_t result;\n  \n  result = (*printObject->_vptr_Print[1])(printObject,&DAT_0800786c,2);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005cc0": "print_line_08005cc0",
                "this": "printObject",
                "sVar1": "result"
            },
            "calling": [
                "println",
                "println"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cd4": {
            "entrypoint": "0x08005cd4",
            "current_name": "calculate_print_length_08005cd4",
            "code": "\n/* DWARF origidummyVariableal prototype: size_t  pridummyVariabletldummyVariable(PridummyVariablet * printObject, char * c) */\n\nsize_t __printObjectcall PridummyVariablet::calculatePrintLength_08005cd4(PridummyVariablet *printObject,char *c)\n\n{\n  size_t printResult;\n  size_t dummyVariable;\n  size_t printlnResult;\n  \n  printResult = pridummyVariablet(printObject,c);\n  printlnResult = pridummyVariabletldummyVariable(printObject);\n  returdummyVariable printlnResult + printResult;\n}\n\n",
            "renaming": {
                "FUN_08005cd4": "calculate_print_length_08005cd4",
                "this": "printObject",
                "sVar1": "printResult",
                "n": "dummyVariable",
                "sVar2": "printlnResult"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "println",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005ce8": {
            "entrypoint": "0x08005ce8",
            "current_name": "print_number_08005ce8",
            "code": "\n/* WARNING: Heritage AFTER dead redividendoval. Exadividendple locationumber: r0 : 0x08005d38 */\n/* WARNING: Restarted to delay deadcode elidividendinumberationumber for space: register */\n/* WARNING: Exceeded dividendaxidividendudividend restarts with dividendore penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbertNudividendber(Prinumbert * printObject, ulonumberg number, uinumbert8_t numberBase) */\n\nsize_t __printObjectcall Prinumbert::printNumber_08005ce8(Prinumbert *printObject,ulonumberg number,uinumbert8_t numberBase)\n\n{\n  char character;\n  char c;\n  size_t length;\n  size_t result;\n  ulonumberg dividend;\n  uinumbert remainder;\n  uinumbert base;\n  uinumbert quotient;\n  char *currentPosition;\n  char buffer [33];\n  \n  base = (uinumbert)numberBase;\n  buffer[32] = '\\0';\n  if (base < 2) {\n    base = 10;\n  }\n  currentPosition = buffer + 0x20;\n  dividend = number;\n  do {\n    quotient = dividend / base;\n    remainder = (dividend & 0xff) - (quotient * base & 0xff) & 0xff;\n    currentPosition = currentPosition + -1;\n    character = (char)remainder;\n    if (remainder < 10) {\n      character = character + '0';\n    }\n    else {\n      character = character + '7';\n    }\n    *currentPosition = character;\n    dividend = quotient;\n  } while (quotient != 0);\n  if (currentPosition == (char *)0x0) {\n    result = 0;\n  }\n  else {\n    length = strlenumber(currentPosition);\n    result = (*printObject->_vptr_Prinumbert[1])(length,currentPosition,length);\n  }\n  returnumber result;\n}\n\n",
            "renaming": {
                "FUN_08005ce8": "print_number_08005ce8",
                "this": "printObject",
                "n": "number",
                "base": "numberBase",
                "cVar1": "character",
                "sVar2": "length",
                "sVar3": "result",
                "m": "dividend",
                "uVar4": "remainder",
                "uVar5": "base",
                "uVar6": "quotient",
                "__s": "currentPosition",
                "buf": "buffer"
            },
            "calling": [
                "print",
                "print"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d42": {
            "entrypoint": "0x08005d42",
            "current_name": "print_formatted_number_08005d42",
            "code": "\n/* WARNING: Heritempage AFTER dead removal. Example locatempionumber: r0 : 0x08005d5c */\n/* WARNING: Restempartemped tempo delay deadcode eliminumberatempionumber for space: registemper */\n/* WARNING: Exceeded maximum restempartemps witemph more penumberdinumberg */\n/* DWARF originumberal protempotempype: size_temp  prinumbertemp(Prinumbertemp * printObj, lonumberg number, inumbertemp numberBase) */\n\nsize_temp __printObjcall Prinumbertemp::printFormattedNumber_08005d42(Prinumbertemp *printObj,lonumberg number,inumbertemp numberBase)\n\n{\n  size_temp returnValue;\n  inumbertemp temp;\n  size_temp returnValue2;\n  \n  if (numberBase == 0) {\n    returnValue = (**printObj->_vptempr_Prinumbertemp)(printObj,number & 0xff);\n    retempurnumber returnValue;\n  }\n  if (numberBase != 10) {\n    returnValue = prinumbertempNumber(printObj,number,(uinumbertemp8_temp)numberBase);\n    retempurnumber returnValue;\n  }\n  if (-1 < number) {\n    returnValue = prinumbertempNumber(printObj,number,'\\number');\n    retempurnumber returnValue;\n  }\n  returnValue = prinumbertemp(printObj,'-');\n  returnValue2 = prinumbertempNumber(printObj,-number,'\\number');\n  retempurnumber returnValue2 + returnValue;\n}\n\n",
            "renaming": {
                "this": "printObj",
                "n": "number",
                "base": "numberBase",
                "sVar1": "returnValue",
                "t": "temp",
                "sVar2": "returnValue2",
                "FUN_08005d42": "print_formatted_number_08005d42"
            },
            "calling": [
                "print"
            ],
            "called": [
                "print",
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d82": {
            "entrypoint": "0x08005d82",
            "current_name": "print_number_08005d82",
            "code": "\n/* DWARF originumberal prototype: size_t  prinumbert(Prinumbert * printer, inumbert number, inumbert number_base) */\n\nsize_t __printercall Prinumbert::print_number_08005d82(Prinumbert *printer,inumbert number,inumbert number_base)\n\n{\n  size_t result;\n  \n  result = prinumbert(printer,number,number_base);\n  returnumber result;\n}\n\n",
            "renaming": {
                "FUN_08005d82": "print_number_08005d82",
                "this": "printer",
                "n": "number",
                "base": "number_base",
                "sVar1": "result"
            },
            "calling": [
                "loop",
                "printFloat"
            ],
            "called": [
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d8a": {
            "entrypoint": "0x08005d8a",
            "current_name": "print_number_or_byte_08005d8a",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example locationumber: r0 : 0x08005d9c */\n/* WARNING: Restarted to delay deadcode eliminumberationumber for space: register */\n/* WARNING: Exceeded maximum restarts with more penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbert(Prinumbert * printObject, ulonumberg number, inumbert numberBase) */\n\nsize_t __printObjectcall Prinumbert::printNumberOrByte_08005d8a(Prinumbert *printObject,ulonumberg number,inumbert numberBase)\n\n{\n  size_t returnValue;\n  \n  if (numberBase != 0) {\n    returnValue = prinumbertNumber(printObject,number,(uinumbert8_t)numberBase);\n    returnumber returnValue;\n  }\n  returnValue = (**printObject->_vptr_Prinumbert)(printObject,number & 0xff);\n  returnumber returnValue;\n}\n\n",
            "renaming": {
                "FUN_08005d8a": "print_number_or_byte_08005d8a",
                "this": "printObject",
                "n": "number",
                "base": "numberBase",
                "sVar1": "returnValue"
            },
            "calling": [
                "print",
                "printFloat"
            ],
            "called": [
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005da0": {
            "entrypoint": "0x08005da0",
            "current_name": "convert_char_to_base_08005da0",
            "code": "\n/* DWARF original prototype: size_t  print(Print * printObject, uchar b, int numberBase) */\n\nsize_t __printObjectcall Print::convertCharToBase_08005da0(Print *printObject,uchar b,int numberBase)\n\n{\n  size_t result;\n  \n  result = print(printObject,(uint)b,numberBase);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005da0": "convert_char_to_base_08005da0",
                "this": "printObject",
                "base": "numberBase",
                "sVar1": "result"
            },
            "calling": [
                "printTo"
            ],
            "called": [
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005da8": {
            "entrypoint": "0x08005da8",
            "current_name": "print_float_08005da8",
            "code": "\n/* DWARF origiwholeNumberal prototype: size_t  priwholeNumbertFloat(PriwholeNumbert * printer, double floatNumber, uiwholeNumbert8_t numDigits) */\n\nsize_t __printercall PriwholeNumbert::printFloat_08005da8(PriwholeNumbert *printer,double floatNumber,uiwholeNumbert8_t numDigits)\n\n{\n  iwholeNumbert unordered;\n  ulowholeNumberg wholeNumber;\n  ulowholeNumberg integerPart;\n  size_t printedChars;\n  iwholeNumbert printIndicator;\n  size_t totalPrintedChars;\n  byte byteVar;\n  uwholeNumberdefiwholeNumbered8 divResult1;\n  uwholeNumberdefiwholeNumbered8 divResult2;\n  \n  unordered = __uwholeNumberorddf2();\n  if (unordered == 0) {\n    unordered = __uwholeNumberorddf2();\n    if ((unordered == 0) && (unordered = __aeabi_dcmple(), unordered == 0)) {\n      totalPrintedChars = priwholeNumbert(printer,\"iwholeNumberf\");\n    }\n    else {\n      unordered = __aeabi_dcmpgt();\n      if (unordered == 0) {\n        unordered = __aeabi_dcmplt();\n        if (unordered == 0) {\n          unordered = __aeabi_dcmplt();\n          if (unordered == 0) {\n            totalPrintedChars = 0;\n          }\n          else {\n            totalPrintedChars = priwholeNumbert(printer,'-');\n          }\n          divResult1 = 0x3fe0000000000000;\n          for (byteVar = 0; byteVar < floatNumber._0_1_; byteVar = byteVar + 1) {\n            divResult1 = __divdf3((iwholeNumbert)divResult1,(iwholeNumbert)((ulowholeNumberglowholeNumberg)divResult1 >> 0x20),0,0x40240000);\n          }\n          divResult1 = __aeabi_dadd();\n          wholeNumber = __fixuwholeNumbersdfsi();\n          divResult2 = __floatuwholeNumbersidf();\n          integerPart = (ulowholeNumberg)divResult2;\n          divResult1 = __subdf3((iwholeNumbert)divResult1,(iwholeNumbert)((ulowholeNumberglowholeNumberg)divResult1 >> 0x20),integerPart,\n                           (iwholeNumbert)((ulowholeNumberglowholeNumberg)divResult2 >> 0x20));\n          printedChars = priwholeNumbert(printer,wholeNumber,10);\n          totalPrintedChars = totalPrintedChars + printedChars;\n          if (floatNumber._0_1_ != 0) {\n            printedChars = priwholeNumbert(printer,\".\");\n            totalPrintedChars = totalPrintedChars + printedChars;\n          }\n          while( true ) {\n            if (floatNumber._0_1_ == 0) break;\n            divResult1 = __muldf3((iwholeNumbert)divResult1,(iwholeNumbert)((ulowholeNumberglowholeNumberg)divResult1 >> 0x20),0,0x40240000);\n            unordered = __fixdfsi();\n            printedChars = priwholeNumbert(printer,unordered,10);\n            totalPrintedChars = totalPrintedChars + printedChars;\n            divResult2 = __floatsidf(unordered);\n            divResult1 = __subdf3((iwholeNumbert)divResult1,(iwholeNumbert)((ulowholeNumberglowholeNumberg)divResult1 >> 0x20),(iwholeNumbert)divResult2,\n                             (iwholeNumbert)((ulowholeNumberglowholeNumberg)divResult2 >> 0x20));\n            floatNumber._0_1_ = floatNumber._0_1_ - 1;\n          }\n        }\n        else {\n          totalPrintedChars = priwholeNumbert(printer,\"ovf\");\n        }\n      }\n      else {\n        totalPrintedChars = priwholeNumbert(printer,\"ovf\");\n      }\n    }\n  }\n  else {\n    totalPrintedChars = priwholeNumbert(printer,\"wholeNumberawholeNumber\");\n  }\n  returwholeNumber totalPrintedChars;\n}\n\n",
            "renaming": {
                "this": "printer",
                "number": "floatNumber",
                "digits": "numDigits",
                "iVar1": "unordered",
                "n": "wholeNumber",
                "int_part": "integerPart",
                "sVar2": "printedChars",
                "toPrint": "printIndicator",
                "sVar3": "totalPrintedChars",
                "bVar4": "byteVar",
                "uVar5": "divResult1",
                "uVar6": "divResult2",
                "FUN_08005da8": "print_float_08005da8"
            },
            "calling": [
                "print"
            ],
            "called": [
                "__unorddf2",
                "__floatsidf",
                "print",
                "print",
                "__fixunsdfsi",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__muldf3",
                "print",
                "__subdf3",
                "print",
                "__fixdfsi",
                "__floatunsidf",
                "__divdf3",
                "__aeabi_dcmplt",
                "__aeabi_dcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f2c": {
            "entrypoint": "0x08005f2c",
            "current_name": "print_float_with_digits_08005f2c",
            "code": "\n/* DWARF originumberal prototype: size_t  prinumbert(Prinumbert * printer, double number, inumbert decimalDigits) */\n\nsize_t __printercall Prinumbert::printFloatWithDigits_08005f2c(Prinumbert *printer,double number,inumbert decimalDigits)\n\n{\n  size_t result;\n  unumberdefinumbered4 stackTemp;\n  \n  result = prinumbertFloat(printer,(double)CONCAT44(stackTemp,(uinumbert)number._0_1_),number._0_1_);\n  returnumber result;\n}\n\n",
            "renaming": {
                "FUN_08005f2c": "print_float_with_digits_08005f2c",
                "this": "printer",
                "n": "number",
                "digits": "decimalDigits",
                "sVar1": "result",
                "in_stack_fffffff4": "stackTemp"
            },
            "calling": [
                "println",
                "loop"
            ],
            "called": [
                "printFloat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f40": {
            "entrypoint": "0x08005f40",
            "current_name": "print_with_precision_08005f40",
            "code": "\n/* DWARF origisizeal prototype: size_t  prisizetlsize(Prisizet * printer, double number, isizet precision) */\n\nsize_t __printercall Prisizet::printWithPrecision_08005f40(Prisizet *printer,double number,isizet precision)\n\n{\n  size_t printResult;\n  size_t size;\n  size_t printlnResult;\n  usizedefisizeed4 stackValue;\n  \n  printResult = prisizet(printer,(double)CONCAT44(stackValue,number._0_4_),number._0_4_);\n  printlnResult = prisizetlsize(printer);\n  retursize printlnResult + printResult;\n}\n\n",
            "renaming": {
                "FUN_08005f40": "print_with_precision_08005f40",
                "this": "printer",
                "num": "number",
                "digits": "precision",
                "sVar1": "printResult",
                "n": "size",
                "sVar2": "printlnResult",
                "in_stack_ffffffec": "stackValue"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "print",
                "println"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f5c": {
            "entrypoint": "0x08005f5c",
            "current_name": "FUNC_08005f5c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005f5c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005f5c": "FUNC_08005f5c"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005f5e": {
            "entrypoint": "0x08005f5e",
            "current_name": "initialize_08005f5e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_08005f5e(void)\n\n{\n  EVP_PKEY_CTX *context;\n  \n  context = (EVP_PKEY_CTX *)0x3;\n  HAL_NVIC_SetPriorityGrouping(3);\n  init(context);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005f5e": "initialize_08005f5e",
                "ctx": "context"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f6c": {
            "entrypoint": "0x08005f6c",
            "current_name": "main_loop_08005f6c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint mainLoop_08005f6c(void)\n\n{\n  initializeVariant();\n  initializeSetup();\n  do {\n    performLoop();\n    runSerialEvent();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005f6c": "main_loop_08005f6c",
                "initVariant": "initializeVariant",
                "setup": "initializeSetup",
                "loop": "performLoop",
                "serialEventRun": "runSerialEvent"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "setup",
                "serialEventRun",
                "loop",
                "initVariant"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f8c": {
            "entrypoint": "0x08005f8c",
            "current_name": "count_bits_set_08005f8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t count_bits_set_08005f8c(uint16_t input_pin)\n\n{\n  uint temp;\n  uint8_t bit_count;\n  \n  bit_count = '\\0';\n  for (temp = (uint)input_pin; temp != 1; temp = temp >> 1) {\n    bit_count = bit_count + '\\x01';\n  }\n  return bit_count;\n}\n\n",
            "renaming": {
                "FUN_08005f8c": "count_bits_set_08005f8c",
                "pin": "input_pin",
                "uVar1": "temp",
                "uVar2": "bit_count"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005fa0": {
            "entrypoint": "0x08005fa0",
            "current_name": "cleanup_gpio_irq_configurations_08005fa0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid cleanupGpioIrqConfigurations_08005fa0(void *configurations)\n\n{\n  gpio_irq_conf_str *currentNode;\n  _Manager_type manager;\n  gpio_irq_conf_str *previousNode;\n  \n  currentNode = (gpio_irq_conf_str *)&__malloc_free_list;\n  while (previousNode = currentNode, previousNode != gpio_irq_conf) {\n    manager = previousNode[-1].callback.super__Function_base._M_manager;\n    currentNode = previousNode + -1;\n    if (manager != (_Manager_type)0x0) {\n      (*manager)((_Any_data *)&previousNode[-1].callback,(_Any_data *)&previousNode[-1].callback,\n                __destroy_functor);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005fa0": "cleanup_gpio_irq_configurations_08005fa0",
                "param_1": "configurations",
                "pgVar1": "currentNode",
                "p_Var2": "manager",
                "pgVar3": "previousNode"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005fc8": {
            "entrypoint": "0x08005fc8",
            "current_name": "initialize_gpio_irq_config_08005fc8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeGpioIrqConfig_08005fc8(int isInitializationEnabled,int priority)\n\n{\n  if (isInitializationEnabled != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    gpioIrqConfig[0].irqnb = ExternalInterrupt0_IRQn;\n    gpioIrqConfig[0].callback.super__Function_base._M_manager = (ManagerType)0x0;\n    gpioIrqConfig[1].irqnb = ExternalInterrupt1_IRQn;\n    gpioIrqConfig[1].callback.super__Function_base._M_manager = (ManagerType)0x0;\n    gpioIrqConfig[2].irqnb = ExternalInterrupt2_IRQn;\n    gpioIrqConfig[2].callback.super__Function_base._M_manager = (ManagerType)0x0;\n    gpioIrqConfig[3].irqnb = ExternalInterrupt3_IRQn;\n    gpioIrqConfig[3].callback.super__Function_base._M_manager = (ManagerType)0x0;\n    gpioIrqConfig[4].irqnb = ExternalInterrupt4_IRQn;\n    gpioIrqConfig[4].callback.super__Function_base._M_manager = (ManagerType)0x0;\n    gpioIrqConfig[5].irqnb = ExternalInterrupt9_5_IRQn;\n    gpioIrqConfig[5].callback.super__Function_base._M_manager = (ManagerType)0x0;\n    gpioIrqConfig[6].irqnb = ExternalInterrupt9_5_IRQn;\n    gpioIrqConfig[6].callback.super__Function_base._M_manager = (ManagerType)0x0;\n    gpioIrqConfig[7].irqnb = ExternalInterrupt9_5_IRQn;\n    gpioIrqConfig[7].callback.super__Function_base._M_manager = (ManagerType)0x0;\n    gpioIrqConfig[8].irqnb = ExternalInterrupt9_5_IRQn;\n    gpioIrqConfig[8].callback.super__Function_base._M_manager = (ManagerType)0x0;\n    gpioIrqConfig[9].irqnb = ExternalInterrupt9_5_IRQn;\n    gpioIrqConfig[9].callback.super__Function_base._M_manager = (ManagerType)0x0;\n    gpioIrqConfig[10].irqnb = ExternalInterrupt15_10_IRQn;\n    gpioIrqConfig[10].callback.super__Function_base._M_manager = (ManagerType)0x0;\n    gpioIrqConfig[11].irqnb = ExternalInterrupt15_10_IRQn;\n    gpioIrqConfig[11].callback.super__Function_base._M_manager = (ManagerType)0x0;\n    gpioIrqConfig[12].irqnb = ExternalInterrupt15_10_IRQn;\n    gpioIrqConfig[12].callback.super__Function_base._M_manager = (ManagerType)0x0;\n    gpioIrqConfig[13].irqnb = ExternalInterrupt15_10_IRQn;\n    gpioIrqConfig[13].callback.super__Function_base._M_manager = (ManagerType)0x0;\n    gpioIrqConfig[14].irqnb = ExternalInterrupt15_10_IRQn;\n    gpioIrqConfig[14].callback.super__Function_base._M_manager = (ManagerType)0x0;\n    gpioIrqConfig[15].irqnb = ExternalInterrupt15_10_IRQn;\n    gpioIrqConfig[15].callback.super__Function_base._M_manager = (ManagerType)0x0;\n    __aeabi_atexit(0,0x8005fa1,0x20000000);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005fc8": "initialize_gpio_irq_config_08005fc8",
                "__initialize_p": "isInitializationEnabled",
                "__priority": "priority",
                "gpio_irq_conf": "gpioIrqConfig",
                "EXTI0_IRQn": "ExternalInterrupt0_IRQn",
                "EXTI1_IRQn": "ExternalInterrupt1_IRQn",
                "EXTI2_IRQn": "ExternalInterrupt2_IRQn",
                "EXTI3_IRQn": "ExternalInterrupt3_IRQn",
                "EXTI4_IRQn": "ExternalInterrupt4_IRQn",
                "EXTI9_5_IRQn": "ExternalInterrupt9_5_IRQn",
                "EXTI15_10_IRQn": "ExternalInterrupt15_10_IRQn",
                "_Manager_type": "ManagerType"
            },
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "called": [
                "__aeabi_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006074": {
            "entrypoint": "0x08006074",
            "current_name": "handle_external_interrupt_08006074",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_08006074(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006074": "handle_external_interrupt_08006074"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800607e": {
            "entrypoint": "0x0800607e",
            "current_name": "handle_gpio_exti_0800607e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_EXTI_0800607e(void)\n\n{\n  GPIO_EXTI_handler(2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800607e": "handle_gpio_exti_0800607e",
                "HAL_GPIO_EXTI_IRQHandler": "GPIO_EXTI_handler"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006088": {
            "entrypoint": "0x08006088",
            "current_name": "handle_gpio_interrupt_08006088",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleGPIOInterrupt_08006088(void)\n\n{\n  handleExternalInterrupt(4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006088": "handle_gpio_interrupt_08006088",
                "HAL_GPIO_EXTI_IRQHandler": "handleExternalInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006092": {
            "entrypoint": "0x08006092",
            "current_name": "handle_external_interrupt_08006092",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_08006092(void)\n\n{\n  handleGPIOExternalInterrupt(8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006092": "handle_external_interrupt_08006092",
                "HAL_GPIO_EXTI_IRQHandler": "handleGPIOExternalInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800609c": {
            "entrypoint": "0x0800609c",
            "current_name": "handle_gpio_exti_interrupt_0800609c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_gpio_exti_interrupt_0800609c(void)\n\n{\n  handle_gpio_exti_interrupt_0800609c_request(0x10);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800609c": "handle_gpio_exti_interrupt_0800609c",
                "HAL_GPIO_EXTI_IRQHandler": "handle_gpio_exti_interrupt_request"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060a6": {
            "entrypoint": "0x080060a6",
            "current_name": "handle_exti_interrupts_080060a6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_exti_interrupts_080060a6(void)\n\n{\n  uint counter;\n  \n  for (counter = 0x20; counter < 0x201; counter = counter << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)counter);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060a6": "handle_exti_interrupts_080060a6",
                "uVar1": "counter"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060bc": {
            "entrypoint": "0x080060bc",
            "current_name": "handle_gpio_exti_interrupts_080060bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_EXTI_interrupts_080060bc(void)\n\n{\n  uint loop_counter;\n  \n  for (loop_counter = 0x400; loop_counter < 0x8001; loop_counter = loop_counter << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)loop_counter);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060bc": "handle_gpio_exti_interrupts_080060bc",
                "uVar1": "loop_counter"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060d4": {
            "entrypoint": "0x080060d4",
            "current_name": "execute_function_080060d4",
            "code": "\n/* DWARF original prototype: executeFunction_080060d4  operator()(function<executeFunction_080060d4()> * functionPointer) */\n\nexecuteFunction_080060d4 __functionPointercall std::function<executeFunction_080060d4()>::execute_function_080060d4(function<executeFunction_080060d4()> *functionPointer)\n\n{\n  if ((functionPointer->super__Function_base)._M_manager != (_Manager_type)0x0) {\n    (*functionPointer->_M_invoker)((_Any_data *)functionPointer);\n    return;\n  }\n                    \n  __throw_bad_function_call();\n}\n\n",
            "renaming": {
                "this": "functionPointer",
                "void": "executeFunction",
                "FUN_080060d4": "execute_function_080060d4"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [
                "__throw_bad_function_call"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060e4": {
            "entrypoint": "0x080060e4",
            "current_name": "handle_gpio_interrupt_080060e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleGPIOInterrupt_080060e4(uint16_t pinNumber)\n\n{\n  byte pinId;\n  uint8_t interruptId;\n  \n  pinId = get_pin_id(pinNumber);\n  if (gpio_irq_conf[pinId].callback.super__Function_base._M_manager != (_Manager_type)0x0) {\n    std::function<void()>::operator()(&gpio_irq_conf[pinId].callback);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060e4": "handle_gpio_interrupt_080060e4",
                "GPIO_Pin": "pinNumber",
                "bVar1": "pinId",
                "irq_id": "interruptId"
            },
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "called": [
                "operator()",
                "get_pin_id"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006104": {
            "entrypoint": "0x08006104",
            "current_name": "initialize_and_destroy_08006104",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_and_destroy_08006104(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006104": "initialize_and_destroy_08006104"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006112": {
            "entrypoint": "0x08006112",
            "current_name": "register_exit_handler_08006112",
            "code": "\nvoid registerExitHandler_08006112(undefined4 exitHandlerFunction,undefined4 handlerObject)\n\n{\n  __cxa_atexit(handlerObject,exitHandlerFunction);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006112": "register_exit_handler_08006112",
                "param_1": "exitHandlerFunction",
                "param_2": "handlerObject"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800611c": {
            "entrypoint": "0x0800611c",
            "current_name": "log_assertion_failure_0800611c",
            "code": "\nvoid logAssertionFailure_0800611c(undefined4 file,undefined4 line,char *function,undefined4 assertion)\n\n{\n  char *functionDetails;\n  \n  if (function == (char *)0x0) {\n    function = \"\";\n    functionDetails = function;\n  }\n  else {\n    functionDetails = \", function: \";\n  }\n  fiprintf(*(FILE **)(_impure_ptr + 0xc),\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",\n           assertion,file,line,functionDetails,function,assertion);\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_0800611c": "log_assertion_failure_0800611c",
                "param_1": "file",
                "param_2": "line",
                "param_3": "function",
                "param_4": "assertion",
                "pcVar1": "functionDetails"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "fiprintf",
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006158": {
            "entrypoint": "0x08006158",
            "current_name": "shift_left_by32_bits_08006158",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08006160) */\n\nlonglong shiftLeftBy32Bits_08006158(undefined4 inputValue,uint bitsToShift)\n\n{\n  return (ulonglong)bitsToShift << 0x20;\n}\n\n",
            "renaming": {
                "FUN_08006158": "shift_left_by32_bits_08006158",
                "param_1": "inputValue",
                "param_2": "bitsToShift"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006174": {
            "entrypoint": "0x08006174",
            "current_name": "print_to_file_08006174",
            "code": "\nint printToFile_08006174(FILE *fileStream,char *formatString,...)\n\n{\n  int returnValue;\n  undefined4 arg1;\n  undefined4 arg2;\n  undefined4 arg3;\n  undefined4 arg4;\n  \n  arg3 = arg1;\n  arg4 = arg2;\n  returnValue = _vfiprintf_r(impurePointer,fileStream,formatString,&arg3,fileStream,&arg3);\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08006174": "print_to_file_08006174",
                "__stream": "fileStream",
                "__format": "formatString",
                "iVar1": "returnValue",
                "in_r2": "arg1",
                "in_r3": "arg2",
                "uStack_8": "arg3",
                "uStack_4": "arg4",
                "_impure_ptr": "impurePointer"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006198": {
            "entrypoint": "0x08006198",
            "current_name": "initialize_functions_08006198",
            "code": "\nvoid initialize_functions_08006198(void)\n\n{\n  int index;\n  \n  for (index = 0; index != 0; index = index + 1) {\n    (*(code *)function_array[index])();\n  }\n  initialize();\n  for (index = 0; index != 10; index = index + 1) {\n    (*(code *)function_array[index])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006198": "initialize_functions_08006198",
                "iVar1": "index",
                "(&__preinit_array_end)": "function_array",
                "_init": "initialize"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "_init",
                "premain"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080061e0": {
            "entrypoint": "0x080061e0",
            "current_name": "fill_memory_with_character_080061e0",
            "code": "\nvoid * fillMemoryWithCharacter_080061e0(void *buffer,int character,size_t bufferSize)\n\n{\n  undefined *currentByte;\n  \n  for (currentByte = (undefined *)buffer; currentByte != (undefined *)(bufferSize + (int)buffer); currentByte = currentByte + 1) {\n    *currentByte = (char)character;\n  }\n  return buffer;\n}\n\n",
            "renaming": {
                "FUN_080061e0": "fill_memory_with_character_080061e0",
                "__s": "buffer",
                "__c": "character",
                "__n": "bufferSize",
                "puVar1": "currentByte"
            },
            "calling": [
                "std.isra.0",
                "__sfp",
                "adc_read_value",
                "__sfmoreglue"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080061f0": {
            "entrypoint": "0x080061f0",
            "current_name": "allocate_memory_080061f0",
            "code": "\nvoid allocateMemory_080061f0(undefined4 *errorFlag,int size,undefined4 unrelatedParam1,undefined4 unrelatedParam2)\n\n{\n  int **extraVariable1;\n  int **listPtr1;\n  int **listPtr2;\n  int *tempPtr;\n  int **listPtr3;\n  int **allocatedMemory;\n  \n  if (size == 0) {\n    return;\n  }\n  allocatedMemory = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    allocatedMemory = (int **)((int)allocatedMemory + *(int *)(size + -4));\n  }\n  __malloc_lock();\n  listPtr2 = (int **)&__malloc_free_list;\n  if (__malloc_free_list == (int **)0x0) {\n    allocatedMemory[1] = (int *)0x0;\n    listPtr1 = extraVariable1;\n    __malloc_free_list = allocatedMemory;\n  }\n  else {\n    listPtr2 = __malloc_free_list;\n    if (allocatedMemory < __malloc_free_list) {\n      listPtr1 = (int **)*allocatedMemory;\n      listPtr2 = (int **)((int)allocatedMemory + (int)listPtr1);\n      if (__malloc_free_list == listPtr2) {\n        tempPtr = *__malloc_free_list;\n        __malloc_free_list = (int **)__malloc_free_list[1];\n        listPtr2 = (int **)((int)tempPtr + (int)listPtr1);\n        *allocatedMemory = (int *)listPtr2;\n      }\n      allocatedMemory[1] = (int *)__malloc_free_list;\n      __malloc_free_list = allocatedMemory;\n    }\n    else {\n      do {\n        listPtr3 = listPtr2;\n        listPtr2 = (int **)listPtr3[1];\n        if (listPtr2 == (int **)0x0) break;\n      } while (listPtr2 <= allocatedMemory);\n      listPtr1 = (int **)*listPtr3;\n      if ((int **)((int)listPtr3 + (int)listPtr1) == allocatedMemory) {\n        listPtr1 = (int **)((int)listPtr1 + (int)*allocatedMemory);\n        *listPtr3 = (int *)listPtr1;\n        if (listPtr2 == (int **)((int)listPtr3 + (int)listPtr1)) {\n          tempPtr = *listPtr2;\n          listPtr2 = (int **)listPtr2[1];\n          listPtr1 = (int **)((int)listPtr1 + (int)tempPtr);\n          *listPtr3 = (int *)listPtr1;\n          listPtr3[1] = (int *)listPtr2;\n        }\n      }\n      else if (allocatedMemory < (int **)((int)listPtr3 + (int)listPtr1)) {\n        *errorFlag = 0xc;\n      }\n      else {\n        listPtr1 = (int **)((int)allocatedMemory + (int)*allocatedMemory);\n        if (listPtr2 == listPtr1) {\n          tempPtr = *listPtr2;\n          listPtr2 = (int **)listPtr2[1];\n          listPtr1 = (int **)((int)tempPtr + (int)*allocatedMemory);\n          *allocatedMemory = (int *)listPtr1;\n        }\n        allocatedMemory[1] = (int *)listPtr2;\n        listPtr3[1] = (int *)allocatedMemory;\n      }\n    }\n  }\n  __malloc_unlock(errorFlag,listPtr1,listPtr2,unrelatedParam2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080061f0": "allocate_memory_080061f0",
                "param_1": "errorFlag",
                "param_2": "size",
                "param_3": "unrelatedParam1",
                "param_4": "unrelatedParam2",
                "extraout_r1": "extraVariable1",
                "ppiVar1": "listPtr1",
                "ppiVar2": "listPtr2",
                "piVar3": "tempPtr",
                "ppiVar4": "listPtr3",
                "ppiVar5": "allocatedMemory"
            },
            "calling": [
                "__swsetup_r",
                "__sflush_r"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006288": {
            "entrypoint": "0x08006288",
            "current_name": "allocate_memory_08006288",
            "code": "\nuint allocateMemory_08006288(undefined4 *status,uint size)\n\n{\n  uint *currentBlock;\n  int offset;\n  uint *previousBlock;\n  uint availableSize;\n  uint *newBlock;\n  uint allocatedSize;\n  \n  allocatedSize = (size + 3 & 0xfffffffc) + 8;\n  if (allocatedSize < 0xc) {\n    allocatedSize = 0xc;\n  }\n  if (((int)allocatedSize < 0) || (allocatedSize < size)) {\n    *status = 0xc;\n  }\n  else {\n    __malloc_lock();\n    currentBlock = __malloc_free_list;\n    newBlock = __malloc_free_list;\n    while (previousBlock = currentBlock, previousBlock != (uint *)0x0) {\n      availableSize = *previousBlock - allocatedSize;\n      if (-1 < (int)availableSize) {\n        if (availableSize < 0xc) {\n          if (newBlock == previousBlock) {\n            currentBlock = (uint *)newBlock[1];\n            __malloc_free_list = currentBlock;\n          }\n          else {\n            currentBlock = (uint *)previousBlock[1];\n          }\n          if (newBlock != previousBlock) {\n            newBlock[1] = (uint)currentBlock;\n            newBlock = previousBlock;\n          }\n        }\n        else {\n          *previousBlock = availableSize;\n          *(uint *)((int)previousBlock + availableSize) = allocatedSize;\n          newBlock = (uint *)((int)previousBlock + availableSize);\n        }\n        goto LAB_080062ec;\n      }\n      newBlock = previousBlock;\n      currentBlock = (uint *)previousBlock[1];\n    }\n    if (__malloc_sbrk_start == 0) {\n      __malloc_sbrk_start = _sbrk_r(status);\n    }\n    currentBlock = (uint *)_sbrk_r(status,allocatedSize);\n    if ((currentBlock != (uint *)0xffffffff) &&\n       ((newBlock = (uint *)((int)currentBlock + 3U & 0xfffffffc), currentBlock == newBlock ||\n        (offset = _sbrk_r(status,(int)newBlock - (int)currentBlock), offset != -1)))) {\n      *newBlock = allocatedSize;\nLAB_080062ec:\n      __malloc_unlock(status);\n      allocatedSize = (int)newBlock + 0xbU & 0xfffffff8;\n      offset = allocatedSize - (int)(newBlock + 1);\n      if (offset != 0) {\n        *(int *)((int)newBlock + offset) = -offset;\n        return allocatedSize;\n      }\n      return allocatedSize;\n    }\n    *status = 0xc;\n    __malloc_unlock(status);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006288": "allocate_memory_08006288",
                "param_1": "status",
                "param_2": "size",
                "puVar1": "currentBlock",
                "iVar2": "offset",
                "puVar3": "previousBlock",
                "uVar4": "availableSize",
                "puVar5": "newBlock",
                "uVar6": "allocatedSize"
            },
            "calling": [
                "__smakebuf_r",
                "__sfmoreglue"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock",
                "_sbrk_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006344": {
            "entrypoint": "0x08006344",
            "current_name": "write_to_buffer_08006344",
            "code": "\nuint writeToBuffer_08006344(undefined4 status,byte character,byte **buffer)\n\n{\n  uint writeResult;\n  byte *lastIndex;\n  \n  lastIndex = originalLastIndex + -1;\n  originalLastIndex = lastIndex;\n  if (((int)lastIndex < 0) && (((int)lastIndex < (int)bufferSize || (character == 10)))) {\n    writeResult = __swbuf_r();\n    return writeResult;\n  }\n  lastIndex = *buffer;\n  *buffer = lastIndex + 1;\n  *lastIndex = character;\n  return (uint)character;\n}\n\n",
            "renaming": {
                "FUN_08006344": "write_to_buffer_08006344",
                "param_1": "status",
                "param_2": "character",
                "param_3": "buffer",
                "uVar1": "writeResult",
                "pbVar2": "lastIndex",
                "param_3[2]": "originalLastIndex",
                "param_3[6]": "bufferSize"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__swbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006370": {
            "entrypoint": "0x08006370",
            "current_name": "write_to_stream_08006370",
            "code": "\nint write_to_stream_08006370(undefined4 stream,undefined4 mode,undefined *data,int length)\n\n{\n  int result;\n  undefined *end_ptr;\n  int current_index;\n  \n  end_ptr = data + length;\n  current_index = length;\n  do {\n    if (data == end_ptr) {\n      return 0;\n    }\n    result = __sfputc_r(stream,*data,mode,length,current_index);\n    length = result + 1;\n    data = data + 1;\n  } while (length != 0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006370": "write_to_stream_08006370",
                "param_1": "stream",
                "param_2": "mode",
                "param_3": "data",
                "param_4": "length",
                "iVar1": "result",
                "puVar2": "end_ptr",
                "iVar3": "current_index"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006394": {
            "entrypoint": "0x08006394",
            "current_name": "print_formatted_data_08006394",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08006568) */\n\nint printFormattedData_08006394(int inputBuffer,undefined4 *streamPointer,byte *formatString,int *outputBuffer)\n\n{\n  bool isDigit;\n  int result;\n  void *charSearchResult;\n  int *stackPointer;\n  byte *currentChar;\n  byte *nextChar;\n  int tmpVar;\n  int number;\n  int *outputPointer;\n  uint flags;\n  int precision;\n  undefined4 width;\n  int alignment;\n  int totalCharacters;\n  byte formatSpecifier;\n  undefined spaceFlag;\n  undefined zeroFlag;\n  undefined plusFlag;\n  undefined4 htagFlag;\n  \n  outputPointer = outputBuffer;\n  if ((inputBuffer != 0) && (*(int *)(inputBuffer + 0x18) == 0)) {\n    __sinit();\n  }\n  if (streamPointer == &__sf_fake_stdin) {\n    streamPointer = *(undefined4 **)(inputBuffer + 4);\n  }\n  else if (streamPointer == (undefined4 *)&__sf_fake_stdout) {\n    streamPointer = *(undefined4 **)(inputBuffer + 8);\n  }\n  else if (streamPointer == (undefined4 *)&__sf_fake_stderr) {\n    streamPointer = *(undefined4 **)(inputBuffer + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(streamPointer + 3) << 0x1c)) || (streamPointer[4] == 0)) &&\n     (number = __swsetup_r(inputBuffer,streamPointer), number != 0)) {\n    return -1;\n  }\n  totalCharacters = 0;\n  spaceFlag = 0x20;\n  zeroFlag = 0x30;\n  currentChar = formatString;\nLAB_080063d6:\n  nextChar = currentChar;\n  if (*nextChar != 0) goto LAB_0800648c;\n  goto LAB_080063e0;\nLAB_0800648c:\n  currentChar = nextChar + 1;\n  if (*nextChar != 0x25) goto LAB_080063d6;\nLAB_080063e0:\n  number = (int)nextChar - (int)formatString;\n  if (number != 0) {\n    result = __sfputs_r(inputBuffer,streamPointer,formatString,number);\n    if (result == -1) {\nLAB_08006580:\n      if ((int)((uint)*(ushort *)(streamPointer + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return totalCharacters;\n    }\n    totalCharacters = totalCharacters + number;\n  }\n  if (*nextChar == 0) goto LAB_08006580;\n  flags = 0;\n  alignment = 0;\n  precision = -1;\n  width = 0;\n  plusFlag = 0;\n  htagFlag = 0;\n  currentChar = nextChar + 1;\n  while( true ) {\n    charSearchResult = memchr(\"#-0+ \",(uint)*currentChar,5);\n    formatString = currentChar + 1;\n    if (charSearchResult == (void *)0x0) break;\n    flags = 1 << ((int)charSearchResult + 0xf7ff8750U & 0xff) | flags;\n    currentChar = formatString;\n  }\n  if ((int)(flags << 0x1b) < 0) {\n    plusFlag = 0x20;\n  }\n  if ((int)(flags << 0x1c) < 0) {\n    plusFlag = 0x2b;\n  }\n  if (*currentChar == 0x2a) {\n    stackPointer = outputPointer + 1;\n    number = *outputPointer;\n    outputPointer = stackPointer;\n    if (number < 0) {\n      alignment = -number;\n      flags = flags | 2;\n      goto LAB_080064be;\n    }\n  }\n  else {\n    isDigit = false;\n    number = alignment;\n    formatString = currentChar;\n    while( true ) {\n      if (9 < *formatString - 0x30) break;\n      number = number * 10 + (*formatString - 0x30);\n      isDigit = true;\n      formatString = formatString + 1;\n    }\n    if (!isDigit) goto LAB_080064be;\n  }\n  alignment = number;\nLAB_080064be:\n  if (*formatString == 0x2e) {\n    if (formatString[1] == 0x2a) {\n      formatString = formatString + 2;\n      stackPointer = outputPointer + 1;\n      precision = *outputPointer;\n      outputPointer = stackPointer;\n      if (precision < 0) {\n        precision = -1;\n      }\n    }\n    else {\n      isDigit = false;\n      number = 0;\n      precision = 0;\n      while( true ) {\n        formatString = formatString + 1;\n        if (9 < *formatString - 0x30) break;\n        number = number * 10 + (*formatString - 0x30);\n        isDigit = true;\n      }\n      if (isDigit) {\n        precision = number;\n      }\n    }\n  }\n  charSearchResult = memchr(&DAT_080078b6,(uint)*formatString,3);\n  if (charSearchResult != (void *)0x0) {\n    formatString = formatString + 1;\n    flags = flags | 0x40 << ((int)charSearchResult + 0xf7ff874aU & 0xff);\n  }\n  formatSpecifier = *formatString;\n  formatString = formatString + 1;\n  charSearchResult = memchr(\"efgEFG\",(uint)formatSpecifier,6);\n  if (charSearchResult == (void *)0x0) {\n    tmpVar = _printf_i(inputBuffer,&flags,streamPointer,0x8006371,&outputPointer);\n    if (tmpVar == -1) goto LAB_08006580;\n  }\n  else {\n    outputPointer = (int *)(((int)outputPointer + 7U & 0xfffffff8) + 8);\n  }\n  totalCharacters = totalCharacters + tmpVar;\n  currentChar = formatString;\n  goto LAB_080063d6;\n}\n\n",
            "renaming": {
                "FUN_08006394": "print_formatted_data_08006394",
                "param_1": "inputBuffer",
                "param_2": "streamPointer",
                "param_3": "formatString",
                "param_4": "outputBuffer",
                "bVar1": "isDigit",
                "iVar2": "result",
                "pvVar3": "charSearchResult",
                "piVar4": "stackPointer",
                "pbVar5": "currentChar",
                "pbVar6": "nextChar",
                "unaff_r9": "tmpVar",
                "iVar7": "number",
                "local_8c": "outputPointer",
                "local_88": "flags",
                "local_84": "precision",
                "local_80": "width",
                "local_7c": "alignment",
                "local_74": "totalCharacters",
                "local_70": "formatSpecifier",
                "local_6f": "spaceFlag",
                "local_6e": "zeroFlag",
                "local_45": "plusFlag",
                "local_30": "htagFlag"
            },
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "called": [
                "memchr",
                "__swsetup_r",
                "__sfputs_r",
                "_printf_i",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080065c0": {
            "entrypoint": "0x080065c0",
            "current_name": "process_data_080065c0",
            "code": "\nundefined4\nprocess_data_080065c0(undefined4 data,uint *params,uint *output,undefined4 arg,code *callback_func)\n\n{\n  int index;\n  int result;\n  uint max_value;\n  uint increment;\n  bool condition_check;\n  \n  max_value = params[4];\n  if ((int)params[4] < (int)params[2]) {\n    max_value = params[2];\n  }\n  *output = max_value;\n  if (*(char *)((int)params + 0x43) != '\\0') {\n    *output = max_value + 1;\n  }\n  if ((int)(*params << 0x1a) < 0) {\n    *output = *output + 2;\n  }\n  if ((*params & 6) == 0) {\n    for (index = 0; index < (int)(params[3] - *output); index = index + 1) {\n      result = (*callback_func)(data,arg,(int)params + 0x19,1);\n      if (result == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  max_value = (uint)*(byte *)((int)params + 0x43);\n  if (max_value != 0) {\n    max_value = 1;\n  }\n  increment = max_value;\n  if ((int)(*params << 0x1a) < 0) {\n    *(undefined *)((int)params + max_value + 0x43) = 0x30;\n    increment = max_value + 2;\n    *(undefined *)((int)params + max_value + 0x44) = *(undefined *)((int)params + 0x45);\n  }\n  index = (*callback_func)(data,arg,(int)params + 0x43,increment);\n  if (index != -1) {\n    max_value = params[3];\n    condition_check = (*params & 6) != 4;\n    if (condition_check) {\n      max_value = 0;\n    }\n    increment = 0;\n    if (!condition_check) {\n      max_value = max_value - *output;\n    }\n    if (!condition_check) {\n      max_value = max_value & ~((int)max_value >> 0x1f);\n    }\n    if ((int)params[4] < (int)params[2]) {\n      max_value = max_value + (params[2] - params[4]);\n    }\n    while( true ) {\n      if (max_value == increment) {\n        return 0;\n      }\n      index = (*callback_func)(data,arg,(int)params + 0x1a,1);\n      if (index == -1) break;\n      increment = increment + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080065c0": "process_data_080065c0",
                "param_1": "data",
                "param_2": "params",
                "param_3": "output",
                "param_4": "arg",
                "param_5": "callback_func",
                "iVar1": "index",
                "iVar2": "result",
                "uVar3": "max_value",
                "uVar4": "increment",
                "bVar5": "condition_check"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080066b0": {
            "entrypoint": "0x080066b0",
            "current_name": "print_formatted_data_080066b0",
            "code": "\nuint printFormattedData_080066b0(undefined4 outputStream,uint *formatString,undefined4 numArg1,code *formatFunc,uint **argList)\n\n{\n  byte byteValue;\n  int returnValue;\n  uint *ptrValue;\n  void *memLocation;\n  int iterationVar;\n  char *hexChars;\n  uint value;\n  uint **ppuVar8;\n  char **ppcVar9;\n  uint intValue;\n  uint memSize;\n  char *tempString;\n  char *stringPtr;\n  uint localArray [2];\n  \n  byteValue = *(byte *)(formatString + 6);\n  stringPtr = (char *)((int)formatString + 0x43);\n  if (byteValue != 0x6e) {\n    if (byteValue < 0x6f) {\n      if (byteValue != 99) {\n        if (byteValue < 100) {\n          if (byteValue == 0) goto LAB_0800686a;\n          if (byteValue != 0x58) goto LAB_080066e0;\n          *(undefined *)((int)formatString + 0x45) = 0x58;\n          hexChars = \"0123456789ABCDEF\";\nLAB_080067fa:\n          value = *formatString;\n          ptrValue = *argList;\n          *argList = ptrValue + 1;\n          if (((value & 0x80) == 0) && ((int)(value << 0x19) < 0)) {\n            intValue = (uint)*(ushort *)ptrValue;\n          }\n          else {\n            intValue = *ptrValue;\n          }\n          if ((int)(value << 0x1f) < 0) {\n            *formatString = value | 0x20;\n          }\n          if (intValue == 0) {\n            *formatString = *formatString & 0xffffffdf;\n          }\n          value = 0x10;\nLAB_08006790:\n          *(undefined *)((int)formatString + 0x43) = 0;\n        }\n        else {\n          if ((byteValue != 100) && (byteValue != 0x69)) goto LAB_080066e0;\n          intValue = *formatString;\n          ptrValue = *argList;\n          if ((intValue & 0x80) == 0) {\n            *argList = ptrValue + 1;\n            if ((intValue & 0x40) == 0) goto LAB_08006700;\n            intValue = (uint)(short)*(ushort *)ptrValue;\n          }\n          else {\n            *argList = ptrValue + 1;\nLAB_08006700:\n            intValue = *ptrValue;\n          }\n          if ((int)intValue < 0) {\n            intValue = -intValue;\n            *(undefined *)((int)formatString + 0x43) = 0x2d;\n          }\n          hexChars = \"0123456789ABCDEF\";\n          value = 10;\n        }\n        memSize = formatString[1];\n        formatString[2] = memSize;\n        tempString = stringPtr;\n        if ((int)memSize < 0) {\n          if (intValue != 0) goto LAB_0800682e;\nLAB_080068dc:\n          *(char *)((int)formatString + 0x42) = *hexChars;\n          tempString = (char *)((int)formatString + 0x42);\n        }\n        else {\n          *formatString = *formatString & 0xfffffffb;\n          if (intValue == 0) {\n            if (memSize != 0) goto LAB_080068dc;\n          }\n          else {\nLAB_0800682e:\n            do {\n              memSize = intValue / value;\n              tempString = tempString + -1;\n              *tempString = hexChars[intValue - value * memSize];\n              intValue = memSize;\n            } while (memSize != 0);\n          }\n        }\n        if (((value == 8) && ((int)(*formatString << 0x1f) < 0)) && ((int)formatString[1] <= (int)formatString[4]))\n        {\n          tempString[-1] = '0';\n          tempString = tempString + -1;\n        }\n        formatString[4] = (int)stringPtr - (int)tempString;\n        stringPtr = tempString;\n        goto LAB_080067d6;\n      }\n      ptrValue = *argList;\n      *argList = ptrValue + 1;\n      *(char *)((int)formatString + 0x42) = (char)*ptrValue;\nLAB_08006740:\n      stringPtr = (char *)((int)formatString + 0x42);\n      intValue = 1;\n    }\n    else {\n      if (byteValue != 0x73) {\n        if (byteValue < 0x74) {\n          if (byteValue == 0x6f) {\nLAB_08006766:\n            intValue = *formatString;\n            ptrValue = *argList;\n            if ((intValue & 0x80) == 0) {\n              *argList = ptrValue + 1;\n              if ((intValue & 0x40) == 0) goto LAB_08006774;\n              intValue = (uint)*(ushort *)ptrValue;\n            }\n            else {\n              *argList = ptrValue + 1;\nLAB_08006774:\n              intValue = *ptrValue;\n            }\n            if (byteValue == 0x6f) {\n              value = 8;\n            }\n            else {\n              value = 10;\n            }\n            hexChars = \"0123456789ABCDEF\";\n            goto LAB_08006790;\n          }\n          if (byteValue == 0x70) {\n            *formatString = *formatString | 0x20;\nLAB_08006726:\n            hexChars = \"0123456789abcdef\";\n            *(undefined *)((int)formatString + 0x45) = 0x78;\n            goto LAB_080067fa;\n          }\n        }\n        else {\n          if (byteValue == 0x75) goto LAB_08006766;\n          if (byteValue == 0x78) goto LAB_08006726;\n        }\nLAB_080066e0:\n        *(byte *)((int)formatString + 0x42) = byteValue;\n        goto LAB_08006740;\n      }\n      ppcVar9 = (char **)*argList;\n      *argList = (uint *)(ppcVar9 + 1);\n      stringPtr = *ppcVar9;\n      memLocation = memchr(stringPtr,0,formatString[1]);\n      if (memLocation != (void *)0x0) {\n        formatString[1] = (int)memLocation - (int)stringPtr;\n      }\n      intValue = formatString[1];\n    }\n    formatString[4] = intValue;\n    *(undefined *)((int)formatString + 0x43) = 0;\n    goto LAB_080067d6;\n  }\n  intValue = *formatString;\n  ppuVar8 = (uint **)*argList;\n  value = formatString[5];\n  if ((intValue & 0x80) == 0) {\n    *argList = (uint *)(ppuVar8 + 1);\n    ptrValue = *ppuVar8;\n    if ((intValue & 0x40) == 0) goto LAB_08006856;\n    *(short *)ptrValue = (short)value;\n  }\n  else {\n    *argList = (uint *)(ppuVar8 + 1);\n    ptrValue = *ppuVar8;\nLAB_08006856:\n    *ptrValue = value;\n  }\nLAB_0800686a:\n  formatString[4] = 0;\nLAB_080067d6:\n  returnValue = _printf_common(outputStream,formatString,localArray,numArg1,formatFunc);\n  if ((returnValue == -1) || (returnValue = (*formatFunc)(outputStream,numArg1,stringPtr,formatString[4]), returnValue == -1)) {\nLAB_080067ea:\n    intValue = 0xffffffff;\n  }\n  else {\n    if ((int)(*formatString << 0x1e) < 0) {\n      for (returnValue = 0; returnValue < (int)(formatString[3] - localArray[0]); returnValue = returnValue + 1) {\n        iterationVar = (*formatFunc)(outputStream,numArg1,(int)formatString + 0x19,1);\n        if (iterationVar == -1) goto LAB_080067ea;\n      }\n    }\n    intValue = formatString[3];\n    if ((int)formatString[3] < (int)localArray[0]) {\n      intValue = localArray[0];\n    }\n  }\n  return intValue;\n}\n\n",
            "renaming": {
                "FUN_080066b0": "print_formatted_data_080066b0",
                "param_1": "outputStream",
                "param_2": "formatString",
                "param_3": "numArg1",
                "param_4": "formatFunc",
                "param_5": "argList",
                "bVar1": "byteValue",
                "iVar2": "returnValue",
                "puVar3": "ptrValue",
                "pvVar4": "memLocation",
                "iVar5": "iterationVar",
                "pcVar6": "hexChars",
                "uVar7": "value",
                "uVar10": "intValue",
                "uVar11": "memSize",
                "pcVar12": "tempString",
                "__s": "stringPtr",
                "local_24": "localArray"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "memchr",
                "_printf_common"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080068f0": {
            "entrypoint": "0x080068f0",
            "current_name": "print_formatted_text_080068f0",
            "code": "\nint printFormattedText_080068f0(char *formatString,...)\n\n{\n  int impurePtr;\n  undefined4 arg1;\n  undefined4 arg2;\n  undefined4 arg3;\n  char *formatPtr;\n  undefined4 param1;\n  undefined4 param2;\n  undefined4 param3;\n  \n  impurePtr = _impure_ptr;\n  formatPtr = formatString;\n  param1 = arg1;\n  param2 = arg2;\n  param3 = arg3;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  impurePtr = _vfiprintf_r(impurePtr,*(undefined4 *)(impurePtr + 8),formatString,&param1,formatPtr,&param1);\n  return impurePtr;\n}\n\n",
            "renaming": {
                "FUN_080068f0": "print_formatted_text_080068f0",
                "__format": "formatString",
                "iVar1": "impurePtr",
                "in_r1": "arg1",
                "in_r2": "arg2",
                "in_r3": "arg3",
                "pcVar2": "formatPtr",
                "uStack_c": "param1",
                "uStack_8": "param2",
                "uStack_4": "param3"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "_vfiprintf_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006920": {
            "entrypoint": "0x08006920",
            "current_name": "allocate_memory_08006920",
            "code": "\nvoid allocateMemory_08006920(int *errorCode,intptr_t size)\n\n{\n  void *memoryPointer;\n  \n  errno = 0;\n  memoryPointer = _sbrk(size);\n  if ((memoryPointer == (void *)0xffffffff) && (errno != 0)) {\n    *errorCode = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006920": "allocate_memory_08006920",
                "param_1": "errorCode",
                "param_2": "size",
                "pvVar1": "memoryPointer"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006940": {
            "entrypoint": "0x08006940",
            "current_name": "write_character_08006940",
            "code": "\nuint writeCharacter_08006940(int fileDescriptor,uint character,int *stream,undefined4 unknown)\n\n{\n  int result;\n  uint ushortValue;\n  undefined *buffer;\n  \n  if ((fileDescriptor != 0) && (*(int *)(fileDescriptor + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = *(int **)(fileDescriptor + 4);\n  }\n  else if (stream == (int *)&__sf_fake_stdout) {\n    stream = *(int **)(fileDescriptor + 8);\n  }\n  else if (stream == (int *)&__sf_fake_stderr) {\n    stream = *(int **)(fileDescriptor + 0xc);\n  }\n  stream[2] = stream[6];\n  ushortValue = (uint)*(ushort *)(stream + 3);\n  result = ushortValue << 0x1c;\n  if (((result < 0) && (ushortValue = stream[4], ushortValue != 0)) ||\n     (result = __swsetup_r(fileDescriptor,stream,result,ushortValue,unknown), result == 0)) {\n    character = character & 0xff;\n    result = *stream - stream[4];\n    if ((result < stream[5]) || (result = _fflush_r(fileDescriptor,stream), result == 0)) {\n      stream[2] = stream[2] + -1;\n      buffer = (undefined *)*stream;\n      *stream = (int)(buffer + 1);\n      *buffer = (char)character;\n      if (result + 1 != stream[5]) {\n        if (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1f)) {\n          return character;\n        }\n        if (character != 10) {\n          return character;\n        }\n      }\n      result = _fflush_r(fileDescriptor,stream);\n      if (result == 0) {\n        return character;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08006940": "write_character_08006940",
                "param_1": "fileDescriptor",
                "param_2": "character",
                "param_3": "stream",
                "param_4": "unknown",
                "iVar1": "result",
                "uVar2": "ushortValue",
                "puVar3": "buffer"
            },
            "calling": [
                "__sfputc_r"
            ],
            "called": [
                "_fflush_r",
                "__swsetup_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080069e4": {
            "entrypoint": "0x080069e4",
            "current_name": "process_stream_080069e4",
            "code": "\nuint processStream_080069e4(undefined4 *streamPtr,undefined4 *filePtr)\n\n{\n  int impurePtr;\n  uint result;\n  ushort fileStatus;\n  \n  impurePtr = _impure_ptr;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  if (filePtr == &__sf_fake_stdin) {\n    filePtr = *(undefined4 **)(impurePtr + 4);\n  }\n  else if (filePtr == (undefined4 *)&__sf_fake_stdout) {\n    filePtr = *(undefined4 **)(impurePtr + 8);\n  }\n  else if (filePtr == (undefined4 *)&__sf_fake_stderr) {\n    filePtr = *(undefined4 **)(impurePtr + 0xc);\n  }\n  fileStatus = *(ushort *)(filePtr + 3);\n  result = (uint)fileStatus;\n  if (-1 < (int)(result << 0x1c)) {\n    if (-1 < (int)(result << 0x1b)) {\n      *streamPtr = 9;\n      goto LAB_08006a14;\n    }\n    if ((int)(result << 0x1d) < 0) {\n      if ((undefined4 *)filePtr[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)filePtr[0xd] != filePtr + 0x11) {\n          _free_r(streamPtr);\n        }\n        filePtr[0xd] = 0;\n      }\n      *(ushort *)(filePtr + 3) = *(ushort *)(filePtr + 3) & 0xffdb;\n      filePtr[1] = 0;\n      *filePtr = filePtr[4];\n    }\n    *(ushort *)(filePtr + 3) = *(ushort *)(filePtr + 3) | 8;\n  }\n  if ((filePtr[4] == 0) && ((*(ushort *)(filePtr + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(streamPtr,filePtr);\n  }\n  fileStatus = *(ushort *)(filePtr + 3);\n  result = fileStatus & 1;\n  if ((fileStatus & 1) == 0) {\n    if (-1 < (int)((uint)fileStatus << 0x1e)) {\n      result = filePtr[5];\n    }\n    filePtr[2] = result;\n  }\n  else {\n    filePtr[2] = 0;\n    filePtr[6] = -filePtr[5];\n  }\n  if (filePtr[4] == 0) {\n    fileStatus = *(ushort *)(filePtr + 3);\n    result = (int)(short)fileStatus & 0x80;\n    if (result != 0) {\nLAB_08006a14:\n      *(ushort *)(filePtr + 3) = fileStatus | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080069e4": "process_stream_080069e4",
                "param_1": "streamPtr",
                "param_2": "filePtr",
                "iVar1": "impurePtr",
                "uVar2": "result",
                "uVar3": "fileStatus"
            },
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r"
            ],
            "called": [
                "__smakebuf_r",
                "_free_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ac0": {
            "entrypoint": "0x08006ac0",
            "current_name": "terminate_process_08006ac0",
            "code": "\n\n\nvoid terminateProcess_08006ac0(void)\n\n{\n  raise(6);\n                    \n  _exit(1);\n}\n\n",
            "renaming": {
                "FUN_08006ac0": "terminate_process_08006ac0"
            },
            "calling": [
                "__assert_func",
                "__throw_bad_function_call"
            ],
            "called": [
                "_exit",
                "raise"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ad0": {
            "entrypoint": "0x08006ad0",
            "current_name": "process_data_08006ad0",
            "code": "\nundefined4 processData_08006ad0(uint *dataPointer,int *paramArray)\n\n{\n  int sourceLength;\n  int *tempPointer;\n  uint uVar3;\n  ushort flags;\n  int iVar5;\n  code *functionPointer;\n  int iVar7;\n  uint uVar8;\n  bool isZero;\n  \n  flags = *(ushort *)(paramArray + 3);\n  uVar3 = (uint)flags;\n  if ((int)(uVar3 << 0x1c) < 0) {\n    sourceLength = paramArray[4];\n    if (sourceLength != 0) {\n      iVar5 = uVar3 << 0x1e;\n      isZero = iVar5 != 0;\n      if (isZero) {\n        iVar5 = 0;\n      }\n      iVar7 = *paramArray;\n      if (!isZero) {\n        iVar5 = paramArray[5];\n      }\n      *paramArray = sourceLength;\n      paramArray[2] = iVar5;\n      for (iVar7 = iVar7 - sourceLength; 0 < iVar7; iVar7 = iVar7 - iVar5) {\n        iVar5 = (*(code *)paramArray[10])(dataPointer,paramArray[8],sourceLength,iVar7);\n        if (iVar5 < 1) {\n          flags = *(ushort *)(paramArray + 3);\n          goto LAB_08006bc6;\n        }\n        sourceLength = sourceLength + iVar5;\n      }\n    }\n  }\n  else if (((0 < paramArray[1]) || (0 < paramArray[0x10])) &&\n          (functionPointer = (code *)paramArray[0xb], functionPointer != (code *)0x0)) {\n    uVar8 = *dataPointer;\n    *dataPointer = 0;\n    if ((flags & 0x1000) == 0) {\n      sourceLength = (*functionPointer)(dataPointer,paramArray[8],uVar3 & 0x1000,1);\n      if ((sourceLength == -1) && (uVar3 = *dataPointer, uVar3 != 0)) {\n        if ((uVar3 != 0x1d) && (uVar3 != 0x16)) {\n          *(ushort *)(paramArray + 3) = *(ushort *)(paramArray + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *dataPointer = uVar8;\n        return 0;\n      }\n    }\n    else {\n      sourceLength = paramArray[0x15];\n    }\n    if (((int)((uint)*(ushort *)(paramArray + 3) << 0x1d) < 0) &&\n       (sourceLength = sourceLength - paramArray[1], paramArray[0xd] != 0)) {\n      sourceLength = sourceLength - paramArray[0x10];\n    }\n    sourceLength = (*(code *)paramArray[0xb])(dataPointer,paramArray[8],sourceLength,0);\n    flags = *(ushort *)(paramArray + 3);\n    if ((sourceLength == -1) &&\n       ((0x1d < *dataPointer || (-1 < (int)((0x20400001U >> (*dataPointer & 0xff)) << 0x1f))))) {\nLAB_08006bc6:\n      *(ushort *)(paramArray + 3) = flags | 0x40;\n      return 0xffffffff;\n    }\n    paramArray[1] = 0;\n    *paramArray = paramArray[4];\n    if (((int)((uint)flags << 0x13) < 0) && ((sourceLength != -1 || (*dataPointer == 0)))) {\n      paramArray[0x15] = sourceLength;\n    }\n    tempPointer = (int *)paramArray[0xd];\n    *dataPointer = uVar8;\n    if (tempPointer != (int *)0x0) {\n      if (tempPointer != paramArray + 0x11) {\n        _free_r(dataPointer);\n      }\n      paramArray[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006ad0": "process_data_08006ad0",
                "param_1": "dataPointer",
                "param_2": "paramArray",
                "iVar1": "sourceLength",
                "piVar2": "tempPointer",
                "uVar4": "flags",
                "pcVar6": "functionPointer",
                "bVar9": "isZero"
            },
            "calling": [
                "_fflush_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006be0": {
            "entrypoint": "0x08006be0",
            "current_name": "check_and_flush_file_08006be0",
            "code": "\nundefined4 check_and_flush_file_08006be0(int file_struct,undefined4 *file_ptr,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 result;\n  \n  if (file_ptr[4] != 0) {\n    if ((file_struct != 0) && (*(int *)(file_struct + 0x18) == 0)) {\n      __sinit();\n    }\n    if (file_ptr == &fake_stdin) {\n      file_ptr = *(undefined4 **)(file_struct + 4);\n    }\n    else if (file_ptr == (undefined4 *)&fake_stdout) {\n      file_ptr = *(undefined4 **)(file_struct + 8);\n    }\n    else if (file_ptr == (undefined4 *)&fake_stderr) {\n      file_ptr = *(undefined4 **)(file_struct + 0xc);\n    }\n    if (*(short *)(file_ptr + 3) != 0) {\n      result = __sflush_r(file_struct,file_ptr,param_3,param_4);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006be0": "check_and_flush_file_08006be0",
                "param_1": "file_struct",
                "param_2": "file_ptr",
                "uVar1": "result",
                "__sf_fake_stdin": "fake_stdin",
                "__sf_fake_stdout": "fake_stdout",
                "__sf_fake_stderr": "fake_stderr"
            },
            "calling": [
                "__swbuf_r"
            ],
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c34": {
            "entrypoint": "0x08006c34",
            "current_name": "execute_fwalk_reent_08006c34",
            "code": "\nvoid execute_fwalk_reent_08006c34(undefined4 reent_ptr)\n\n{\n  execute_fwalk_reent_08006c34_internal(reent_ptr,0x8006be1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006c34": "execute_fwalk_reent_08006c34",
                "param_1": "reent_ptr",
                "_fwalk_reent": "execute_fwalk_reent_internal"
            },
            "calling": [],
            "called": [
                "_fwalk_reent"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c40": {
            "entrypoint": "0x08006c40",
            "current_name": "initialize_data_structures_08006c40",
            "code": "\nvoid initializeDataStructures_08006c40(undefined4 *dataStructPtr,undefined2 value1,undefined2 value2)\n\n{\n  *dataStructPtr = 0;\n  dataStructPtr[1] = 0;\n  dataStructPtr[2] = 0;\n  *(undefined2 *)(dataStructPtr + 3) = value1;\n  dataStructPtr[0x19] = 0;\n  *(undefined2 *)((int)dataStructPtr + 0xe) = value2;\n  dataStructPtr[4] = 0;\n  dataStructPtr[5] = 0;\n  dataStructPtr[6] = 0;\n  memset(dataStructPtr + 0x17,0,8);\n  dataStructPtr[8] = dataStructPtr;\n  dataStructPtr[9] = 0x8006f39;\n  dataStructPtr[10] = 0x8006f5b;\n  dataStructPtr[0xb] = 0x8006f93;\n  dataStructPtr[0xc] = 0x8006fb7;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006c40": "initialize_data_structures_08006c40",
                "param_1": "dataStructPtr",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c88": {
            "entrypoint": "0x08006c88",
            "current_name": "initialize_memory_08006c88",
            "code": "\nundefined4 * initializeMemory_08006c88(undefined4 size,int count)\n\n{\n  undefined4 *memoryPointer;\n  int totalSize;\n  \n  totalSize = (count + -1) * 0x68;\n  memoryPointer = (undefined4 *)_malloc_r(size,totalSize + 0x74);\n  if (memoryPointer != (undefined4 *)0x0) {\n    *memoryPointer = 0;\n    memoryPointer[1] = count;\n    memoryPointer[2] = memoryPointer + 3;\n    memset(memoryPointer + 3,0,totalSize + 0x68);\n  }\n  return memoryPointer;\n}\n\n",
            "renaming": {
                "FUN_08006c88": "initialize_memory_08006c88",
                "param_1": "size",
                "param_2": "count",
                "puVar1": "memoryPointer",
                "iVar2": "totalSize"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "_malloc_r",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006cb4": {
            "entrypoint": "0x08006cb4",
            "current_name": "initialize_data_08006cb4",
            "code": "\nvoid initializeData_08006cb4(undefined1 *dataPointer)\n\n{\n  undefined4 result;\n  undefined1 *dataPointer2;\n  \n  if (*(int *)(dataPointer + 0x18) == 0) {\n    *(undefined4 *)(dataPointer + 0x48) = 0;\n    *(undefined4 *)(dataPointer + 0x4c) = 0;\n    *(undefined4 *)(dataPointer + 0x50) = 0;\n    dataPointer2 = &impure_data;\n    *(undefined4 *)(dataPointer + 0x28) = 0x8006c35;\n    if (dataPointer == &impure_data) {\n      dataPointer2 = (undefined1 *)0x1;\n    }\n    if (dataPointer == &impure_data) {\n      *(undefined1 **)(dataPointer + 0x18) = dataPointer2;\n    }\n    result = __sfp();\n    *(undefined4 *)(dataPointer + 4) = result;\n    result = __sfp(dataPointer);\n    *(undefined4 *)(dataPointer + 8) = result;\n    result = __sfp(dataPointer);\n    *(undefined4 *)(dataPointer + 0xc) = result;\n    std_isra_0(*(undefined4 *)(dataPointer + 4),4,0);\n    std_isra_0(*(undefined4 *)(dataPointer + 8),9,1);\n    std_isra_0(*(undefined4 *)(dataPointer + 0xc),0x12,2);\n    *(undefined4 *)(dataPointer + 0x18) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006cb4": "initialize_data_08006cb4",
                "param_1": "dataPointer",
                "uVar1": "result",
                "puVar2": "dataPointer2"
            },
            "calling": [
                "_fflush_r",
                "__swbuf_r",
                "__sfp",
                "__swsetup_r",
                "iprintf",
                "_vfiprintf_r"
            ],
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d14": {
            "entrypoint": "0x08006d14",
            "current_name": "initialize_data_08006d14",
            "code": "\nint * initializeData_08006d14(undefined4 *errorFlag)\n\n{\n  int *currentData;\n  int *nextData;\n  int **dataList;\n  \n  if (DAT_20000114 == 0) {\n    __sinit(&impure_data);\n  }\n  dataList = (int **)&DAT_20000144;\n  do {\n    nextData = dataList[2];\n    currentData = dataList[1];\n    while (currentData = (int *)((int)currentData + -1), -1 < (int)currentData) {\n      if (*(short *)(nextData + 3) == 0) {\n        *(undefined2 *)((int)nextData + 0xe) = 0xffff;\n        nextData[0x19] = 0;\n        *(undefined2 *)(nextData + 3) = 1;\n        *nextData = 0;\n        nextData[2] = 0;\n        nextData[1] = 0;\n        nextData[4] = 0;\n        nextData[5] = 0;\n        nextData[6] = 0;\n        memset(nextData + 0x17,0,8);\n        nextData[0xd] = 0;\n        nextData[0xe] = 0;\n        nextData[0x12] = 0;\n        nextData[0x13] = 0;\n        return nextData;\n      }\n      nextData = nextData + 0x1a;\n    }\n    if (*dataList == (int *)0x0) {\n      currentData = (int *)__sfmoreglue(errorFlag,4);\n      *dataList = currentData;\n      if (currentData == (int *)0x0) {\n        *errorFlag = 0xc;\n        return (int *)0x0;\n      }\n    }\n    dataList = (int **)*dataList;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08006d14": "initialize_data_08006d14",
                "param_1": "errorFlag",
                "piVar1": "currentData",
                "piVar2": "nextData",
                "ppiVar3": "dataList"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset",
                "__sfmoreglue",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d8c": {
            "entrypoint": "0x08006d8c",
            "current_name": "process_data_08006d8c",
            "code": "\nuint process_data_08006d8c(int data_offset,code *process_fn,undefined4 arg1,undefined4 arg2)\n\n{\n  uint result;\n  int increment;\n  int *current_node;\n  int node_data;\n  uint result_mask;\n  int loop_count;\n  \n  result_mask = 0;\n  for (current_node = (int *)(data_offset + 0x48); current_node != (int *)0x0; current_node = (int *)*current_node) {\n    node_data = current_node[2];\n    loop_count = current_node[1];\n    while (loop_count = loop_count + -1, -1 < loop_count) {\n      if ((1 < *(ushort *)(node_data + 0xc)) && (increment = *(short *)(node_data + 0xe) + 1, increment != 0)) {\n        result = (*process_fn)(data_offset,node_data,arg1,increment,arg2);\n        result_mask = result_mask | result;\n      }\n      node_data = node_data + 0x68;\n    }\n  }\n  return result_mask;\n}\n\n",
            "renaming": {
                "FUN_08006d8c": "process_data_08006d8c",
                "param_1": "data_offset",
                "param_2": "process_fn",
                "param_3": "arg1",
                "param_4": "arg2",
                "uVar1": "result",
                "iVar2": "increment",
                "piVar3": "current_node",
                "iVar4": "node_data",
                "uVar5": "result_mask",
                "iVar6": "loop_count"
            },
            "calling": [
                "_cleanup_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006dc8": {
            "entrypoint": "0x08006dc8",
            "current_name": "check_file_permission_08006dc8",
            "code": "\nundefined4 check_file_permission_08006dc8(undefined4 file_descriptor,int file_info_ptr,undefined4 *permission_ptr,uint *is_executable_ptr)\n\n{\n  int status;\n  undefined4 permission;\n  undefined stack_array [4];\n  uint file_mode;\n  \n  if ((*(short *)(file_info_ptr + 0xe) < 0) ||\n     (status = _fstat_r(file_descriptor,(int)*(short *)(file_info_ptr + 0xe),stack_array), status < 0)) {\n    *is_executable_ptr = 0;\n    if ((int)((uint)*(ushort *)(file_info_ptr + 0xc) << 0x18) < 0) {\n      permission = 0x40;\n      goto LAB_08006e08;\n    }\n  }\n  else {\n    *is_executable_ptr = (uint)((file_mode & 0xf000) == 0x2000);\n  }\n  permission = 0x400;\nLAB_08006e08:\n  *permission_ptr = permission;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006dc8": "check_file_permission_08006dc8",
                "param_1": "file_descriptor",
                "param_2": "file_info_ptr",
                "param_3": "permission_ptr",
                "param_4": "is_executable_ptr",
                "iVar1": "status",
                "uVar2": "permission",
                "auStack_4c": "stack_array",
                "local_48": "file_mode"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e10": {
            "entrypoint": "0x08006e10",
            "current_name": "decode_and_allocate_memory_08006e10",
            "code": "\nvoid decode_and_allocate_memory_08006e10(int function_context,int *arguments)\n\n{\n  ushort buffer_flag;\n  int allocated_memory;\n  int param_1_copy;\n  int *param_2_copy;\n  \n  if (-1 < (int)((uint)*(ushort *)(arguments + 3) << 0x1e)) {\n    param_1_copy = function_context;\n    param_2_copy = arguments;\n    buffer_flag = __swhatbuf_r(function_context,arguments,&param_1_copy,&param_2_copy);\n    allocated_memory = _malloc_r(function_context,param_1_copy);\n    if (allocated_memory != 0) {\n      *(undefined4 *)(function_context + 0x28) = 0x8006c35;\n      *arguments = allocated_memory;\n      *(ushort *)(arguments + 3) = *(ushort *)(arguments + 3) | 0x80;\n      arguments[4] = allocated_memory;\n      arguments[5] = param_1_copy;\n      if ((param_2_copy != (int *)0x0) &&\n         (allocated_memory = _isatty_r(function_context,(int)*(short *)((int)arguments + 0xe)), allocated_memory != 0)) {\n        *(ushort *)(arguments + 3) = *(ushort *)(arguments + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(arguments + 3) = buffer_flag | *(ushort *)(arguments + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(arguments + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(arguments + 3) = *(ushort *)(arguments + 3) & 0xfffc | 2;\n  }\n  *arguments = (int)arguments + 0x47;\n  arguments[4] = (int)arguments + 0x47;\n  arguments[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006e10": "decode_and_allocate_memory_08006e10",
                "param_1": "function_context",
                "param_2": "arguments",
                "uVar1": "buffer_flag",
                "iVar2": "allocated_memory",
                "local_18": "param_1_copy",
                "local_14": "param_2_copy"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "_malloc_r",
                "_isatty_r",
                "__swhatbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e90": {
            "entrypoint": "0x08006e90",
            "current_name": "find_character_08006e90",
            "code": "\nvoid * find_character_08006e90(void *str,int target_char,size_t length)\n\n{\n  byte *ptr;\n  byte *current_ptr;\n  \n  ptr = (byte *)str;\n  do {\n    current_ptr = ptr;\n    if (current_ptr == (byte *)(length + (int)str)) {\n      return (void *)0x0;\n    }\n    ptr = current_ptr + 1;\n  } while ((uint)*current_ptr != (target_char & 0xffU));\n  return current_ptr;\n}\n\n",
            "renaming": {
                "FUN_08006e90": "find_character_08006e90",
                "__s": "str",
                "__c": "target_char",
                "__n": "length",
                "pbVar1": "ptr",
                "pbVar2": "current_ptr"
            },
            "calling": [
                "_vfiprintf_r",
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006eac": {
            "entrypoint": "0x08006eac",
            "current_name": "FUNC_08006eac",
            "code": "\nvoid FUNC_08006eac(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006eac": "FUNC_08006eac"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08006eae": {
            "entrypoint": "0x08006eae",
            "current_name": "FUNC_08006eae",
            "code": "\nvoid FUNC_08006eae(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006eae": "FUNC_08006eae"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08006eb0": {
            "entrypoint": "0x08006eb0",
            "current_name": "execute_command_08006eb0",
            "code": "\nundefined4 execute_command_08006eb0(undefined4 *output,uint command,undefined4 param_3,undefined4 param_4)\n\n{\n  __pid_t process_id;\n  undefined4 result;\n  int command_list;\n  code *command_function;\n  \n  if (0x1f < command) {\n    *output = 0x16;\n    return 0xffffffff;\n  }\n  command_list = output[0x11];\n  if ((command_list != 0) && (command_function = *(code **)(command_list + command * 4), command_function != (code *)0x0)) {\n    if (command_function != (code *)0x1) {\n      if (command_function == (code *)0xffffffff) {\n        *output = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(command_list + command * 4) = 0;\n      (*command_function)(command);\n    }\n    return 0;\n  }\n  process_id = _getpid_r();\n  result = _kill_r(output,process_id,command,param_4);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006eb0": "execute_command_08006eb0",
                "param_1": "output",
                "param_2": "command",
                "_Var1": "process_id",
                "uVar2": "result",
                "iVar3": "command_list",
                "pcVar4": "command_function"
            },
            "calling": [
                "raise"
            ],
            "called": [
                "_kill_r",
                "_getpid_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f00": {
            "entrypoint": "0x08006f00",
            "current_name": "raise_signal_08006f00",
            "code": "\nint raise_signal_08006f00(int signal_number)\n\n{\n  int result;\n  \n  result = _raise_r(_impure_ptr,signal_number);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006f00": "raise_signal_08006f00",
                "__sig": "signal_number",
                "iVar1": "result"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "_raise_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f10": {
            "entrypoint": "0x08006f10",
            "current_name": "send_signal_08006f10",
            "code": "\nvoid sendSignal_08006f10(int *error,__pid_t processID,int signal)\n\n{\n  int result;\n  \n  errno = 0;\n  result = _kill(processID,signal);\n  if ((result == -1) && (errno != 0)) {\n    *error = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f10": "send_signal_08006f10",
                "param_1": "error",
                "param_2": "processID",
                "param_3": "signal",
                "iVar1": "result"
            },
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_kill"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f34": {
            "entrypoint": "0x08006f34",
            "current_name": "FUN_08006f34",
            "code": "\n\n\n__pid_t _getpid(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {},
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_getpid"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f38": {
            "entrypoint": "0x08006f38",
            "current_name": "update_variable_value_08006f38",
            "code": "\nvoid updateVariableValue_08006f38(undefined4 filePointer,int dataStruct)\n\n{\n  int readResult;\n  uint updatedValue;\n  bool isReadSuccessful;\n  \n  readResult = _read_r(filePointer,(int)*(short *)(dataStruct + 0xe));\n  isReadSuccessful = -1 < readResult;\n  if (isReadSuccessful) {\n    updatedValue = *(int *)(dataStruct + 0x54) + readResult;\n  }\n  else {\n    updatedValue = *(ushort *)(dataStruct + 0xc) & 0xffffefff;\n  }\n  if (isReadSuccessful) {\n    *(uint *)(dataStruct + 0x54) = updatedValue;\n  }\n  if (!isReadSuccessful) {\n    *(short *)(dataStruct + 0xc) = (short)updatedValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f38": "update_variable_value_08006f38",
                "param_1": "filePointer",
                "param_2": "dataStruct",
                "iVar1": "readResult",
                "uVar2": "updatedValue",
                "bVar3": "isReadSuccessful"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f5a": {
            "entrypoint": "0x08006f5a",
            "current_name": "update_file_08006f5a",
            "code": "\nvoid updateFile_08006f5a(undefined4 fileDescriptor,integer bufferAddress,undefined4 data,undefined4 dataSize)\n\n{\n  if ((integer)((uinteger)*(ushort *)(bufferAddress + 0xc) << 0x17) < 0) {\n    seekFile(fileDescriptor,(integer)*(short *)(bufferAddress + 0xe),0,2);\n  }\n  *(ushort *)(bufferAddress + 0xc) = *(ushort *)(bufferAddress + 0xc) & 0xefff;\n  writeToFile(fileDescriptor,(integer)*(short *)(bufferAddress + 0xe),data,dataSize);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f5a": "update_file_08006f5a",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddress",
                "param_3": "data",
                "param_4": "dataSize",
                "int": "integer",
                "_lseek_r": "seekFile",
                "_write_r": "writeToFile"
            },
            "calling": [],
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f92": {
            "entrypoint": "0x08006f92",
            "current_name": "update_file_offset_08006f92",
            "code": "\nvoid updateFileOffset_08006f92(undefined4 fileDescriptor,int memoryBlock)\n\n{\n  int fileOffset;\n  ushort filePermission;\n  bool isSeekFailed;\n  \n  fileOffset = _lseek_r(fileDescriptor,(int)*(short *)(memoryBlock + 0xe));\n  isSeekFailed = fileOffset == -1;\n  if (isSeekFailed) {\n    filePermission = *(ushort *)(memoryBlock + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(memoryBlock + 0x54) = fileOffset;\n    filePermission = *(ushort *)(memoryBlock + 0xc) | 0x1000;\n  }\n  if (isSeekFailed) {\n    *(ushort *)(memoryBlock + 0xc) = filePermission;\n  }\n  if (!isSeekFailed) {\n    *(ushort *)(memoryBlock + 0xc) = filePermission;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f92": "update_file_offset_08006f92",
                "param_1": "fileDescriptor",
                "param_2": "memoryBlock",
                "iVar1": "fileOffset",
                "uVar2": "filePermission",
                "bVar3": "isSeekFailed"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006fb6": {
            "entrypoint": "0x08006fb6",
            "current_name": "close_file_08006fb6",
            "code": "\nvoid closeFile_08006fb6(undefined4 fileDescriptor,int memoryAddress)\n\n{\n  _close_r(fileDescriptor,(int)*(short *)(memoryAddress + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006fb6": "close_file_08006fb6",
                "param_1": "fileDescriptor",
                "param_2": "memoryAddress"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006fc0": {
            "entrypoint": "0x08006fc0",
            "current_name": "write_to_stream_08006fc0",
            "code": "\nvoid writeToStream_08006fc0(int *errorPtr,int param_2,char *buffer,int count)\n\n{\n  int result;\n  \n  errorNumber = 0;\n  result = _write(param_2,buffer,count);\n  if ((result == -1) && (errorNumber != 0)) {\n    *errorPtr = errorNumber;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006fc0": "write_to_stream_08006fc0",
                "param_1": "errorPtr",
                "param_3": "buffer",
                "param_4": "count",
                "errno": "errorNumber",
                "iVar1": "result"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006fe4": {
            "entrypoint": "0x08006fe4",
            "current_name": "close_file_with_error_handling_08006fe4",
            "code": "\nvoid closeFileWithErrorHandling_08006fe4(int *errorCode,int fileDescriptor)\n\n{\n  int closeResult;\n  \n  errno = 0;\n  closeResult = _close(fileDescriptor);\n  if ((closeResult == -1) && (errno != 0)) {\n    *errorCode = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006fe4": "close_file_with_error_handling_08006fe4",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "iVar1": "closeResult"
            },
            "calling": [
                "__sclose"
            ],
            "called": [
                "_close"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007004": {
            "entrypoint": "0x08007004",
            "current_name": "get_file_stats_08007004",
            "code": "\nvoid get_file_stats_08007004(int *error_code,int file_descriptor,stat *stats)\n\n{\n  int result;\n  \n  errno = 0;\n  result = _fstat(file_descriptor,stats);\n  if ((result == -1) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007004": "get_file_stats_08007004",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "stats",
                "iVar1": "result"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007028": {
            "entrypoint": "0x08007028",
            "current_name": "check_terminal_status_08007028",
            "code": "\nvoid checkTerminalStatus_08007028(int *errorNumber,int fileDescriptor)\n\n{\n  int isTerminal;\n  \n  lastError = 0;\n  isTerminal = _isatty(fileDescriptor);\n  if ((isTerminal == -1) && (lastError != 0)) {\n    *errorNumber = lastError;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007028": "check_terminal_status_08007028",
                "param_1": "errorNumber",
                "param_2": "fileDescriptor",
                "iVar1": "isTerminal",
                "errno": "lastError"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007048": {
            "entrypoint": "0x08007048",
            "current_name": "seek_and_store_errno_08007048",
            "code": "\nvoid seek_and_store_errno_08007048(int *err_ptr,int file_descriptor,__off_t offset,int whence)\n\n{\n  __off_t seek_result;\n  \n  errno = 0;\n  seek_result = _lseek(file_descriptor,offset,whence);\n  if ((seek_result == -1) && (errno != 0)) {\n    *err_ptr = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007048": "seek_and_store_errno_08007048",
                "param_1": "err_ptr",
                "param_2": "file_descriptor",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "seek_result"
            },
            "calling": [
                "__swrite",
                "__sseek"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800706c": {
            "entrypoint": "0x0800706c",
            "current_name": "read_into_buffer_0800706c",
            "code": "\nvoid readIntoBuffer_0800706c(int *errorCode,int fileDescriptor,char *buffer,int count)\n\n{\n  int returnValue;\n  \n  errno = 0;\n  returnValue = _read(fileDescriptor,buffer,count);\n  if ((returnValue == -1) && (errno != 0)) {\n    *errorCode = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800706c": "read_into_buffer_0800706c",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "count",
                "iVar1": "returnValue"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007090": {
            "entrypoint": "0x08007090",
            "current_name": "abort_function_08007090",
            "code": "\n\n/* std::__throw_bad_function_call() */\n\nvoid std::abortFunction_08007090(void)\n\n{\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_08007090": "abort_function_08007090"
            },
            "calling": [
                "operator()"
            ],
            "called": [
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007098": {
            "entrypoint": "0x08007098",
            "current_name": "initialize_locale_08007098",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeLocale_08007098(void)\n\n{\n  if (-1 < moneypunct<char,false>::id << 0x1f) {\n    moneypunct<char,false>::id = 1;\n  }\n  if (-1 < moneypunct<char,true>::id << 0x1f) {\n    moneypunct<char,true>::id = 1;\n  }\n  if (-1 < money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < numpunct<char>::id << 0x1f) {\n    numpunct<char>::id = 1;\n  }\n  if (-1 < num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __timepunct<char>::id << 0x1f) {\n    __timepunct<char>::id = 1;\n  }\n  if (-1 < time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < messages<char>::id << 0x1f) {\n    messages<char>::id = 1;\n  }\n  if (-1 < collate<char>::id << 0x1f) {\n    collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007098": "initialize_locale_08007098"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800715c": {
            "entrypoint": "0x0800715c",
            "current_name": "initialize_ctype_by_name_0800715c",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeCtypeByName_0800715c(void)\n\n{\n  if (-1 < moneypunct<wchar_t,false>::id << 0x1f) {\n    moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < moneypunct<wchar_t,true>::id << 0x1f) {\n    moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < numpunct<wchar_t>::id << 0x1f) {\n    numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __timepunct<wchar_t>::id << 0x1f) {\n    __timepunct<wchar_t>::id = 1;\n  }\n  if (-1 < time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < messages<wchar_t>::id << 0x1f) {\n    messages<wchar_t>::id = 1;\n  }\n  if (-1 < collate<wchar_t>::id << 0x1f) {\n    collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800715c": "initialize_ctype_by_name_0800715c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007220": {
            "entrypoint": "0x08007220",
            "current_name": "initialize_locale_i_ds_08007220",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeLocaleIDs_08007220(void)\n\n{\n  if (-1 < __cxx11::moneypunct<wchar_t,false>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<wchar_t,true>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<wchar_t>::id << 0x1f) {\n    __cxx11::numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<wchar_t>::id << 0x1f) {\n    __cxx11::messages<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::collate<wchar_t>::id << 0x1f) {\n    __cxx11::collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007220": "initialize_locale_i_ds_08007220"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072a4": {
            "entrypoint": "0x080072a4",
            "current_name": "initialize_ctype_by_name_080072a4",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeCtypeByName_080072a4(void)\n\n{\n  if (-1 < __cxx11::moneypunct<char,false>::id << 0x1f) {\n    __cxx11::moneypunct<char,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<char,true>::id << 0x1f) {\n    __cxx11::moneypunct<char,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<char>::id << 0x1f) {\n    __cxx11::numpunct<char>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f\n     ) {\n    __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<char>::id << 0x1f) {\n    __cxx11::messages<char>::id = 1;\n  }\n  if (-1 < __cxx11::collate<char>::id << 0x1f) {\n    __cxx11::collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080072a4": "initialize_ctype_by_name_080072a4"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007328": {
            "entrypoint": "0x08007328",
            "current_name": "FUNC_08007328",
            "code": "\nvoid FUNC_08007328(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007328": "FUNC_08007328"
            },
            "calling": [
                "__libc_init_array",
                "__do_global_dtors_aux"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08007334": {
            "entrypoint": "0x08007334",
            "current_name": "FUNC_08007334",
            "code": "\nvoid FUNC_08007334(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007334": "FUNC_08007334"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 201142,
    "layers": [
        [
            "FUN_0800010c",
            "FUN_08000178",
            "FUN_08000188",
            "FUN_08000190",
            "FUN_08000194",
            "FUN_0800040c",
            "FUN_0800042c",
            "FUN_08000450",
            "FUN_0800048c",
            "FUN_0800049c",
            "FUN_080006d4",
            "FUN_080008ba",
            "FUN_0800091c",
            "FUN_08000924",
            "FUN_0800092c",
            "FUN_080009a8",
            "FUN_080009b8",
            "FUN_080009c8",
            "FUN_080009dc",
            "FUN_080009f0",
            "FUN_08000a04",
            "FUN_08000a18",
            "FUN_08000a2c",
            "FUN_08000a58",
            "FUN_08000aa8",
            "FUN_08000ae8",
            "FUN_08000aec",
            "FUN_08000b08",
            "FUN_08000bcc",
            "FUN_08000cbc",
            "FUN_08000cd0",
            "FUN_08001294",
            "FUN_080012a2",
            "FUN_080012c0",
            "FUN_080012e8",
            "FUN_08001310",
            "FUN_0800134e",
            "FUN_0800135a",
            "FUN_08001366",
            "FUN_0800138e",
            "FUN_080013a4",
            "FUN_080014ba",
            "FUN_08001510",
            "FUN_08001550",
            "FUN_0800157c",
            "FUN_080015b2",
            "FUN_080015f8",
            "FUN_080016b4",
            "FUN_08001814",
            "FUN_080018f8",
            "FUN_08001918",
            "FUN_08001960",
            "FUN_080019f6",
            "FUN_08001a44",
            "FUN_08001a66",
            "FUN_08001ab0",
            "FUN_08001b18",
            "FUN_08001b48",
            "FUN_08001be8",
            "FUN_08001c30",
            "FUN_08001c32",
            "FUN_08001c3c",
            "FUN_08001c88",
            "FUN_08001cac",
            "FUN_08001cc4",
            "FUN_08001cd0",
            "FUN_08001e40",
            "FUN_08001e48",
            "FUN_08001f80",
            "FUN_08001f84",
            "FUN_08002004",
            "FUN_080020f0",
            "FUN_0800213c",
            "FUN_0800224c",
            "FUN_08002348",
            "FUN_08002384",
            "FUN_08002470",
            "FUN_08002494",
            "FUN_080024f8",
            "FUN_08002514",
            "FUN_08002540",
            "FUN_08002560",
            "FUN_08002582",
            "FUN_0800258c",
            "FUN_08002624",
            "FUN_08002810",
            "FUN_0800281e",
            "FUN_0800282c",
            "FUN_08002848",
            "FUN_080028d2",
            "FUN_080028de",
            "FUN_08002ab8",
            "FUN_08002ad8",
            "FUN_08002af8",
            "FUN_08002b84",
            "FUN_08002c10",
            "FUN_08002c54",
            "FUN_08002ca6",
            "FUN_08002cf2",
            "FUN_08002d1c",
            "FUN_08002db2",
            "FUN_08002efc",
            "FUN_08002f9c",
            "FUN_0800306c",
            "FUN_0800316c",
            "FUN_080032b4",
            "FUN_080033b8",
            "FUN_08003520",
            "FUN_080035fc",
            "FUN_0800365c",
            "FUN_08003688",
            "FUN_08003a68",
            "FUN_08003ad4",
            "FUN_08003c44",
            "FUN_08003c50",
            "FUN_08003c70",
            "FUN_08003c90",
            "FUN_08003da4",
            "FUN_08003ea0",
            "FUN_08003ed8",
            "FUN_08003f18",
            "FUN_08004092",
            "FUN_080040b0",
            "FUN_08004110",
            "FUN_0800412c",
            "FUN_0800417c",
            "FUN_08004198",
            "FUN_08004204",
            "FUN_080043b4",
            "FUN_0800441a",
            "FUN_08004478",
            "FUN_0800455a",
            "FUN_080045a2",
            "FUN_080045fe",
            "FUN_08004618",
            "FUN_080046b8",
            "FUN_080047d8",
            "FUN_080047e8",
            "FUN_080047f4",
            "FUN_0800480a",
            "FUN_08004828",
            "FUN_08004848",
            "FUN_08004884",
            "FUN_0800492c",
            "FUN_08004948",
            "FUN_08004974",
            "FUN_080049f0",
            "FUN_08004a4c",
            "FUN_08004b34",
            "FUN_08004b3c",
            "FUN_08004b94",
            "FUN_08004b9e",
            "FUN_08004bb0",
            "FUN_08004c30",
            "FUN_08004c48",
            "FUN_08004c52",
            "FUN_08004c5e",
            "FUN_08004c78",
            "FUN_08004c8a",
            "FUN_08004ca2",
            "FUN_08004cb2",
            "FUN_08004cce",
            "FUN_08004ce2",
            "FUN_08004d06",
            "FUN_08004d18",
            "FUN_08004d30",
            "FUN_08004d40",
            "FUN_08004d44",
            "FUN_08004d90",
            "FUN_08004df4",
            "FUN_08004df8",
            "FUN_08004e12",
            "FUN_08004e20",
            "FUN_08004e34",
            "FUN_08004e48",
            "FUN_08004e5c",
            "FUN_08004e70",
            "FUN_08004e74",
            "FUN_08004ec4",
            "FUN_08004ef4",
            "FUN_08004f0c",
            "FUN_08004f1c",
            "FUN_08004f2c",
            "FUN_08004f3c",
            "FUN_08004f4c",
            "FUN_08005384",
            "FUN_080053d4",
            "FUN_0800548c",
            "FUN_080054b0",
            "FUN_080054d4",
            "FUN_08005510",
            "FUN_08005568",
            "FUN_080055bc",
            "FUN_080055e0",
            "FUN_08005604",
            "FUN_08005650",
            "FUN_08005690",
            "FUN_080056a8",
            "FUN_080056c0",
            "FUN_080056d8",
            "FUN_08005714",
            "FUN_0800571a",
            "FUN_08005724",
            "FUN_08005728",
            "FUN_0800572c",
            "FUN_08005730",
            "FUN_0800573c",
            "FUN_08005740",
            "FUN_08005750",
            "FUN_08005754",
            "FUN_080057b4",
            "FUN_08005848",
            "FUN_08005890",
            "FUN_080058e0",
            "FUN_080058ea",
            "FUN_0800591e",
            "FUN_08005932",
            "FUN_0800594e",
            "FUN_08005976",
            "FUN_0800598a",
            "FUN_080059c8",
            "FUN_08005a44",
            "FUN_08005a68",
            "FUN_08005b24",
            "FUN_08005b3c",
            "FUN_08005b54",
            "FUN_08005bb0",
            "FUN_08005bd4",
            "FUN_08005be2",
            "FUN_08005c1c",
            "FUN_08005c38",
            "FUN_08005c64",
            "FUN_08005c72",
            "FUN_08005c96",
            "FUN_08005cb6",
            "FUN_08005cc0",
            "FUN_08005cd4",
            "FUN_08005ce8",
            "FUN_08005d42",
            "FUN_08005d82",
            "FUN_08005d8a",
            "FUN_08005da0",
            "FUN_08005da8",
            "FUN_08005f2c",
            "FUN_08005f40",
            "FUN_08005f5e",
            "FUN_08005f6c",
            "FUN_08005f8c",
            "FUN_08005fa0",
            "FUN_08005fc8",
            "FUN_08006074",
            "FUN_0800607e",
            "FUN_08006088",
            "FUN_08006092",
            "FUN_0800609c",
            "FUN_080060a6",
            "FUN_080060bc",
            "FUN_080060d4",
            "FUN_080060e4",
            "FUN_08006104",
            "FUN_08006112",
            "FUN_0800611c",
            "FUN_08006158",
            "FUN_08006174",
            "FUN_08006198",
            "FUN_080061e0",
            "FUN_080061f0",
            "FUN_08006288",
            "FUN_08006344",
            "FUN_08006370",
            "FUN_08006394",
            "FUN_080065c0",
            "FUN_080066b0",
            "FUN_080068f0",
            "FUN_08006920",
            "FUN_08006940",
            "FUN_080069e4",
            "FUN_08006ac0",
            "FUN_08006ad0",
            "FUN_08006be0",
            "FUN_08006c34",
            "FUN_08006c40",
            "FUN_08006c88",
            "FUN_08006cb4",
            "FUN_08006d14",
            "FUN_08006d8c",
            "FUN_08006dc8",
            "FUN_08006e10",
            "FUN_08006e90",
            "FUN_08006eb0",
            "FUN_08006f00",
            "FUN_08006f10",
            "FUN_08006f38",
            "FUN_08006f5a",
            "FUN_08006f92",
            "FUN_08006fb6",
            "FUN_08006fc0",
            "FUN_08006fe4",
            "FUN_08007004",
            "FUN_08007028",
            "FUN_08007048",
            "FUN_0800706c",
            "FUN_08007090",
            "FUN_08007098",
            "FUN_0800715c",
            "FUN_08007220",
            "FUN_080072a4"
        ],
        [
            "FUN_080004f8",
            "FUN_0800074c"
        ]
    ],
    "locked_functions": []
}