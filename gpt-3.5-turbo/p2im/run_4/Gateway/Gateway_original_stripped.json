{
    "functions": {
        "FUN_08007246": {
            "renaming": {
                "FUN_08007246": "increment_and_handle_systick_08007246"
            },
            "code": "void increment_and_handle_systick_08007246(void)\n{\n  HAL_IncTick();\n  HAL_SYSTICK_IRQHandler();\n  noOsSystickHandler();\n  return;\n}",
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "noOsSystickHandler",
                "HAL_IncTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007246",
            "calling": [],
            "imported": false,
            "current_name": "increment_and_handle_systick_08007246"
        },
        "FUN_0800a042": {
            "renaming": {
                "FUN_0800a042": "write_to_file_0800a042",
                "param_1": "file_descriptor",
                "param_2": "buffer_address",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "PTR_": "",
                "DAT_": "",
                "offset": "buffer_offset"
            },
            "code": "void write_to_file_0800a042(int file_descriptor, int buffer_address, void* buffer, int buffer_size) {\n    int offset = *(ushort *)(buffer_address + 0xc);\n    if ((int)((uint)offset << 0x17) < 0) {\n        _lseek_r(file_descriptor, (int)*(short *)(buffer_address + 0xe), 0, 2);\n    }\n    *(ushort *)(buffer_address + 0xc) = *(ushort *)(buffer_address + 0xc) & 0xefff;\n    _write_r(file_descriptor, offset, buffer, buffer_size);\n    return;\n}",
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a042",
            "calling": [],
            "imported": false,
            "current_name": "write_to_file_0800a042"
        },
        "FUN_08008e4e": {
            "renaming": {
                "__thiscall Print::FUN_08008e4e": "print_buffer",
                "this": "print_obj",
                "buffer": "buffer",
                "size": "buffer_size",
                "pPVar1": "print_ptr",
                "sVar2": "bytes_printed",
                "FUN_08008e4e": "print_buffer_08008e4e"
            },
            "code": "size_t __thiscall print_buffer_08008e4e(Print *print_obj, uint8_t *buffer, size_t buffer_size)\n{\n  Print *print_ptr;\n  size_t bytes_printed = 0;\n  print_ptr = print_obj;\n  while(buffer_size > 0) {\n    print_ptr = (Print *)(**print_obj->_vptr_Print)(print_ptr, (uint)*buffer);\n    if (print_ptr == (Print *)0x0) {\n        break;\n    }\n    bytes_printed++;\n    buffer++;\n    buffer_size--;\n  }\n  return bytes_printed;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e4e",
            "calling": [],
            "imported": false,
            "current_name": "print_buffer_08008e4e"
        },
        "FUN_08008694": {
            "renaming": {
                "FUN_08008694": "setup_serial_08008694",
                "obj": "serial_obj",
                "callback": "callback_function",
                "bVar1": "index",
                "PTR_tx_callback_080086dc": "tx_callback",
                "PTR_tx_callback_obj_080086e0": "tx_callback_obj",
                "PTR_uart_handlers_080086e4": "uart_handler"
            },
            "code": "void setup_serial_08008694(serial_t *serial_obj, _func_int_serial_t_ptr *callback_function){\n    if (serial_obj != NULL){\n        byte index = serial_obj->index;\n        _func_int_serial_t_ptr **PTR_tx_callback_080086dc = (PTR_PTR_tx_callback_080086dc_080086dc + (uint)index * 4);\n        *PTR_tx_callback_080086dc = callback_function;\n        serial_t **PTR_PTR_tx_callback_080086dc_obj_080086e0 = (PTR_PTR_PTR_tx_callback_080086dc_obj_080086e0_080086e0 + (uint)index * 4);\n        *PTR_PTR_tx_callback_080086dc_obj_080086e0 = serial_obj;\n        HAL_NVIC_SetPriority(serial_obj->irq, 0, 2);\n        HAL_NVIC_EnableIRQ(serial_obj->irq);\n        UART_HandleTypeDef **PTR_uart_handlers_080086e4 = (PTR_PTR_uart_handlers_080086e4s_080086e4 + (uint)serial_obj->index * 4);\n        HAL_UART_Transmit_IT(*PTR_uart_handlers_080086e4, serial_obj->tx_buff + serial_obj->tx_tail, 1);\n    }\n}",
            "called": [
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_SetPriority",
                "HAL_NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008694",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "setup_serial_08008694"
        },
        "FUN_08002ce0": {
            "renaming": {
                "__thiscall firmata::FUN_08002ce0::FUN_08002ce0": "initialize",
                "this_00": "firmata_parser",
                "marshaller": "firmata_marshaller",
                "parser": "firmata_parser",
                "firmwareVersionCount": "firmware_version_count",
                "firmwareVersionVector": "firmware_version_vector",
                "blinkVersionDisabled": "blink_version_disabled",
                "0xe0": "reportAnalog",
                "0x90": "reportDigital",
                "0xc0": "reportVersion",
                "0xd0": "systemReset",
                "0xf4": "sendString",
                "0xf5": "sendSysex",
                "'q'": "samplingInterval",
                "0xf0": "sysexNonRealtime",
                "'y'": "reportFirmware",
                "0xf9": "extendedAnalog",
                "0xff": "sysexRealtime",
                "FUN_08002ce0": "initialize_08002ce0"
            },
            "code": "initialize_08002ce0 * __thiscall firmata::initialize_08002ce0(initialize_08002ce0 *this)\\n{\\n  FirmataParser *firmata_parser;\\n  FirmataMarshaller::FirmataMarshaller(&this->marshaller);\\n  firmata_parser = &this->parser;\\n  FirmataParser::FirmataParser(firmata_parser, this->parserBuffer, 0x40);\\n  this->firmwareVersionCount = \"\\0\";\\n  this->firmwareVersionVector = (byte *)0x0;\\n  this->blinkVersionDisabled = false;\\n  FirmataParser::attach(firmata_parser, 0xe0, reportAnalog, (void *)0x0);\\n  FirmataParser::attach(firmata_parser, 0x90, reportDigital, (void *)0x0);\\n  FirmataParser::attach(firmata_parser, 0xc0, reportVersion, (void *)0x0);\\n  FirmataParser::attach(firmata_parser, 0xd0, systemReset, (void *)0x0);\\n  FirmataParser::attach(firmata_parser, 0xf4, sendString, (void *)0x0);\\n  FirmataParser::attach(firmata_parser, 0xf5, sendSysex, (void *)0x0);\\n  FirmataParser::attach(firmata_parser, \"q\", samplingInterval, (void *)0x0);\\n  FirmataParser::attach(firmata_parser, 0xf0, sysexNonRealtime, (void *)0x0);\\n  FirmataParser::attach(firmata_parser, \"y\", reportFirmware, this);\\n  FirmataParser::attach(firmata_parser, 0xf9, extendedAnalog, this);\\n  FirmataParser::attach(firmata_parser, 0xff, sysexRealtime, (void *)0x0);\\n  return this;\\n}",
            "called": [
                "attach",
                "attach",
                "FirmataMarshaller",
                "attach",
                "FirmataParser",
                "attach",
                "attach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ce0",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_08002ce0"
        },
        "FUN_08005188": {
            "renaming": {
                "FUN_08005188": "i2c_handle_interrupt_08005188",
                "hi2c": "handle",
                "pIVar1": "instance",
                "uVar2": "status_reg_1",
                "uVar3": "control_reg_2",
                "uVar4": "status_reg_2",
                "I2C_Master_ADDR": "i2c_master_addr",
                "I2C_Master_ADD10": "i2c_master_add10",
                "I2C_Master_SB": "i2c_master_sb",
                "I2C_MasterReceive_RXNE": "i2c_master_receive_rxne",
                "I2C_MasterReceive_BTF": "i2c_master_receive_btf",
                "I2C_MasterTransmit_TXE": "i2c_master_transmit_txe",
                "I2C_MasterTransmit_BTF": "i2c_master_transmit_btf",
                "I2C_Slave_ADDR": "i2c_slave_addr",
                "I2C_Slave_STOPF": "i2c_slave_stopf",
                "I2C_SlaveReceive_RXNE": "i2c_slave_receive_rxne",
                "I2C_SlaveReceive_BTF": "i2c_slave_receive_btf",
                "I2C_SlaveTransmit_TXE": "i2c_slave_transmit_txe",
                "I2C_SlaveTransmit_BTF": "i2c_slave_transmit_btf"
            },
            "code": "void i2c_handle_interrupt_08005188(I2C_HandleTypeDef_conflict *handle)\n{\n  I2C_TypeDef_conflict *instance;\n  uint16_t status_reg_1;\n  uint16_t status_reg_2;\n  uint16_t control_reg_2;\n  instance = handle->Instance;\n  status_reg_2 = instance->SR2;\n  status_reg_1 = instance->SR1;\n  control_reg_2 = instance->CR2;\n  if (handle->Mode == HAL_I2C_MODE_MASTER || handle->Mode == HAL_I2C_MODE_MEM) {\n    if ((status_reg_1 & 0x10001) == 0 || (control_reg_2 & 0x200) == 0) {\n      if ((0x08 & status_reg_1) == 0 || (control_reg_2 & 0x200) == 0) {\n        if ((0x02 & status_reg_1) != 0 && (control_reg_2 & 0x200) != 0) {\n          I2C_Master_ADDR(handle);\n        }\n      }\n      else {\n        I2C_Master_ADD10(handle);\n      }\n    }\n    else {\n      I2C_Master_SB(handle);\n    }\n    if ((0x04 & status_reg_2) == 0) {\n      if ((0x40 & status_reg_1) != 0 && (control_reg_2 & 0x400) != 0 && (0x10 & status_reg_1) == 0) {\n        I2C_MasterReceive_RXNE(handle);\n        return;\n      }\n      if ((0x10 & status_reg_1) != 0 && (control_reg_2 & 0x200) != 0) {\n        I2C_MasterReceive_BTF(handle);\n        return;\n      }\n    }\n    else {\n      if ((0x20 & status_reg_1) != 0 && (control_reg_2 & 0x400) != 0 && (0x10 & status_reg_1) == 0) {\n        I2C_MasterTransmit_TXE(handle);\n        return;\n      }\n      if ((0x10 & status_reg_1) != 0 && (control_reg_2 & 0x200) != 0) {\n        I2C_MasterTransmit_BTF(handle);\n        return;\n      }\n    }\n  }\n  else {\n    if ((0x02 & status_reg_1) != 0 && (control_reg_2 & 0x200) != 0) {\n      I2C_Slave_ADDR(handle);\n      return;\n    }\n    if ((0x01 & status_reg_1) != 0 && (control_reg_2 & 0x200) != 0) {\n      I2C_Slave_STOPF(handle);\n      return;\n    }\n    if ((0x04 & status_reg_2) == 0) {\n      if ((0x40 & status_reg_1) != 0 && (control_reg_2 & 0x400) != 0 && (0x10 & status_reg_1) == 0) {\n        I2C_SlaveReceive_RXNE(handle);\n        return;\n      }\n      if ((0x10 & status_reg_1) != 0 && (control_reg_2 & 0x200) != 0) {\n        I2C_SlaveReceive_BTF(handle);\n      }\n    }\n    else {\n      if ((0x20 & status_reg_1) != 0 && (control_reg_2 & 0x400) != 0 && (0x10 & status_reg_1) == 0) {\n        I2C_SlaveTransmit_TXE(handle);\n        return;\n      }\n      if ((0x10 & status_reg_1) != 0 && (control_reg_2 & 0x200) != 0) {\n        I2C_SlaveTransmit_BTF(handle);\n        return;\n      }\n    }\n  }\n}",
            "called": [
                "I2C_MasterTransmit_BTF",
                "I2C_Master_ADD10",
                "I2C_Master_ADDR",
                "I2C_MasterTransmit_TXE",
                "I2C_SlaveReceive_RXNE",
                "I2C_Master_SB",
                "I2C_SlaveReceive_BTF",
                "I2C_MasterReceive_BTF",
                "I2C_Slave_ADDR",
                "I2C_SlaveTransmit_TXE",
                "I2C_SlaveTransmit_BTF",
                "I2C_Slave_STOPF",
                "I2C_MasterReceive_RXNE"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005188",
            "calling": [
                "I2C1_EV_IRQHandler",
                "I2C2_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_handle_interrupt_08005188"
        },
        "FUN_08007244": {
            "renaming": {
                "FUN_08007244": "do_nothing_08007244"
            },
            "code": "\nvoid do_nothing_08007244(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007244",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "do_nothing_08007244"
        },
        "FUN_08001bf8": {
            "renaming": {
                "FUN_08001bf8": "write_data_to_wire_08001bf8",
                "data": "data",
                "PTR_Wire_08001c04": "PTR_Wire_08001c04"
            },
            "code": "void write_data_to_wire_08001bf8(byte data)\n{\n  TwoWire::write((TwoWire *)PTR_Wire_08001c04,data);\n  return;\n}",
            "called": [
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001bf8",
            "calling": [
                "sysexCallback",
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "write_data_to_wire_08001bf8"
        },
        "FUN_080069ec": {
            "renaming": {
                "FUN_080069ec": "handle_UART_interrupt_080069ec",
                "*huart": "huart",
                "HVar1": "status",
                "uVar2": "CR1_register",
                "pUVar3": "UART_instance",
                "uVar4": "CR3_flag",
                "uVar5": "SR_register",
                "UART_Receive_IT": "UART_Receive_IT",
                "UART_Transmit_IT": "UART_Transmit_IT",
                "UART_EndTransmit_IT": "UART_EndTransmit_IT",
                "huart->ErrorCode": "error_code",
                "huart->hdmarx": "hdma_rx",
                "DAT_08006b08": "DMA_XferAbort",
                "HAL_UART_ErrorCallback": "HAL_UART_ErrorCallback",
                "HAL_DMA_Abort_IT": "HAL_DMA_Abort_IT"
            },
            "code": "void handle_UART_interrupt_080069ec(UART_HandleTypeDef *huart)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t SR_register;\n  USART_TypeDef *UART_instance;\n  uint32_t CR1_register;\n  uint32_t CR3_register;\n  uint32_t error_code = 0;\n  DMA_HandleTypeDef_conflict *hdma_rx;\n\n  UART_instance = huart->Instance;\n  SR_register = UART_instance->SR;\n  CR1_register = UART_instance->CR1;\n  CR3_register = UART_instance->CR3;\n\n  if ((SR_register & USART_SR_RXNE) && (CR1_register & USART_CR1_RXNEIE))\n  {\n    UART_Receive_IT(huart);\n    return;\n  }\n  if ((SR_register & USART_SR_TXE) && (CR1_register & USART_CR1_TXEIE))\n  {\n    UART_Transmit_IT(huart);\n    return;\n  }\n  if ((SR_register & USART_SR_TC) && (CR1_register & USART_CR1_TCIE))\n  {\n    UART_EndTransmit_IT(huart);\n    return;\n  }\n  if ((SR_register & USART_SR_NE) || (SR_register & USART_SR_FE) || (SR_register & USART_SR_ORE))\n  {\n    if ((SR_register & USART_SR_ORE) && (CR3_register & USART_CR3_EIE))\n    {\n      error_code |= 1;\n    }\n    if ((SR_register & USART_SR_NE) && (CR3_register & USART_CR3_EIE))\n    {\n      error_code |= 2;\n    }\n    if ((SR_register & USART_SR_FE) && (CR3_register & USART_CR3_EIE))\n    {\n      error_code |= 4;\n    }\n    if (error_code != 0)\n    {\n      if ((SR_register & USART_SR_RXNE) && (CR1_register & USART_CR1_RXNEIE))\n      {\n        UART_Receive_IT(huart);\n      }\n      if ((error_code & 4) == 0 && (UART_instance->CR3 & USART_CR3_ERRIE) == 0)\n      {\n        HAL_UART_ErrorCallback(huart);\n        error_code = 0;\n        return;\n      }\n      UART_EndRxTransfer(huart);\n      if ((UART_instance->CR3 & USART_CR3_ERRIE) == 0)\n      {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      UART_instance->CR3 &= ~USART_CR3_DMAR;\n      hdma_rx = huart->hdmarx;\n      if (hdma_rx == (DMA_HandleTypeDef_conflict *)0x0)\n      {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      hdma_rx->XferAbortCallback = DAT_08006b08;\n      status = HAL_DMA_Abort_IT(hdma_rx);\n      if (status != HAL_OK)\n      {\n        (*hdma_rx->XferAbortCallback)(hdma_rx);\n        return;\n      }\n    }\n  }\n}\n",
            "called": [
                "UART_EndTransmit_IT",
                "HAL_DMA_Abort_IT",
                "UART_EndRxTransfer",
                "UART_Receive_IT",
                "UART_Transmit_IT",
                "HAL_UART_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080069ec",
            "calling": [
                "USART2_IRQHandler",
                "USART1_IRQHandler",
                "USART3_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_UART_interrupt_080069ec"
        },
        "FUN_0800a168": {
            "renaming": {
                "FUN_0800a168": "read_file_0800a168",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "puVar1": "errno_ptr",
                "iVar2": "read_result"
            },
            "code": "void read_file_0800a168(int *error_code, int file_descriptor, char *buffer, int buffer_size) {\n    int read_result;\n    int *errno_ptr = PTR_errno_0800a188;\n    *(int *)PTR_errno_0800a188 = 0;\n    read_result = _read(file_descriptor, buffer, buffer_size);\n    if ((read_result == -1) && (*(int *)errno_ptr != 0)) {\n        *error_code = *(int *)errno_ptr;\n    }\n    return;\n}",
            "called": [
                "_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a168",
            "calling": [
                "__sread"
            ],
            "imported": false,
            "current_name": "read_file_0800a168"
        },
        "FUN_080067ac": {
            "renaming": {
                "FUN_080067ac": "transmitData_080067ac",
                "*huart": "*uartHandle",
                "pData": "*data",
                "Size": "dataSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "startTime",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "(uint8_t *)0x0": "NULL",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_LOCKED": "HAL_LOCKED",
                "HAL_BUSY": "HAL_BUSY",
                "huart->Lock": "uartHandle->Lock",
                "huart->ErrorCode": "uartHandle->ErrorCode",
                "huart->gState": "uartHandle->gState",
                "HAL_UART_STATE_BUSY_TX": "HAL_UART_STATE_BUSY_TX",
                "HAL_GetTick()": "HAL_GetTick()",
                "huart->TxXferSize": "uartHandle->TxXferSize",
                "huart->TxXferCount": "uartHandle->TxXferCount",
                "(huart->Init).WordLength": "(uartHandle->Init).WordLength",
                "UART_WaitOnFlagUntilTimeout(huart,0x80,RESET,Tickstart,Timeout)": "UART_WaitOnFlagUntilTimeout(uartHandle, UART_FLAG_TXE, RESET, startTime, timeout)",
                "HAL_TIMEOUT": "HAL_TIMEOUT",
                "huart->Instance->DR": "uartHandle->Instance->DR",
                "*(ushort *)pData & 0x1ff": "*(uint16_t*)data & 0x1FF",
                "(uint8_t *)((int)pData + 2)": "data += 2",
                "(uint8_t *)((int)pData + 1)": "data++",
                "(uint)*pData": "(uint32_t)*data",
                "UART_FLAG_TXE": "UART_FLAG_TXE",
                "UART_WORDLENGTH_9B": "UART_WORDLENGTH_9B",
                "UART_PARITY_NONE": "UART_PARITY_NONE",
                "UART_FLAG_TC": "UART_FLAG_TC",
                "uartHandle->gState = HAL_UART_STATE_READY": "uartHandle->gState = HAL_UART_STATE_READY",
                "uartHandle->Lock = HAL_UNLOCKED": "uartHandle->Lock = HAL_UNLOCKED"
            },
            "code": "HAL_StatusTypeDef_conflict transmitData_080067ac(UART_HandleTypeDef *uartHandle, uint8_t *data, uint16_t dataSize, uint32_t timeout)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t startTime;\n  \n  if (uartHandle->gState != HAL_UART_STATE_READY) {\n    status = HAL_BUSY;\n    return status;\n  }\n  \n  if (data == NULL || dataSize == 0) {\n    status = HAL_ERROR;\n    return status;\n  }\n  \n  if (uartHandle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n    return status;\n  }\n  \n  uartHandle->Lock = HAL_LOCKED;\n  uartHandle->ErrorCode = 0;\n  uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n  startTime = HAL_GetTick();\n  uartHandle->TxXferSize = dataSize;\n  uartHandle->TxXferCount = dataSize;\n  \n  while (uartHandle->TxXferCount != 0) {\n    uartHandle->TxXferCount--;\n    if ((uartHandle->Init).WordLength == UART_WORDLENGTH_9B) {\n      status = UART_WaitOnFlagUntilTimeout(uartHandle, UART_FLAG_TXE, RESET, startTime, timeout);\n      if (status != HAL_OK) {\n        uartHandle->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      uartHandle->Instance->DR = *(uint16_t*)data & 0x1FF;\n      if ((uartHandle->Init).Parity == UART_PARITY_NONE) {\n        data += 2;\n      }\n      else {\n        data++;\n      }\n    }\n    else {\n      status = UART_WaitOnFlagUntilTimeout(uartHandle, UART_FLAG_TXE, RESET, startTime, timeout);\n      if (status != HAL_OK) {\n        uartHandle->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      uartHandle->Instance->DR = (uint32_t)*data;\n      data++;\n    }\n  }\n  \n  status = UART_WaitOnFlagUntilTimeout(uartHandle, UART_FLAG_TC, RESET, startTime, timeout);\n  if (status == HAL_OK) {\n    uartHandle->gState = HAL_UART_STATE_READY;\n    uartHandle->Lock = HAL_UNLOCKED;\n  }\n  else {\n    status = HAL_TIMEOUT;\n  }\n  \n  return status;\n}",
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080067ac",
            "calling": [
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "transmitData_080067ac"
        },
        "FUN_0800735a": {
            "renaming": {
                "FUN_0800735a": "find_pin_function_0800735a",
                "pin": "pin_name",
                "map": "pin_map",
                "PinName_conflict": "PinName",
                "PinMap_conflict": "PinMap",
                "NC": "NoConnection"
            },
            "code": "uint32_t find_pin_function_0800735a(PinName_conflict pin, PinMap_conflict *pin_map) {\n    while (true) {\n        if (pin_map->pin == NC) {\n            return 0xffffffff;\n        }\n        if (pin_map->pin == pin) {\n            break;\n        }\n        pin_map = pin_map + 1;\n    }\n    return pin_map->function;\n}",
            "called": [
                "pinmap_find_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800735a",
            "calling": [
                "pinmap_function",
                "pinmap_find_function"
            ],
            "imported": false,
            "current_name": "find_pin_function_0800735a"
        },
        "FUN_08008c20": {
            "renaming": {
                "FUN_08008c20": "initializeSerial_08008c20",
                "this": "serial",
                "ctx": "context",
                "_serial": "serial",
                "rx_buff": "rx_buffer",
                "_rx_buffer": "_rx_buffer",
                "rx_head": "rx_head",
                "rx_tail": "rx_tail",
                "tx_buff": "tx_buffer",
                "_tx_buffer": "_tx_buffer",
                "tx_head": "tx_head",
                "tx_tail": "tx_tail"
            },
            "code": "int __thiscall initializeSerial_08008c20(HardwareSerial *serial, EVP_PKEY_CTX *context) {\n  serial->rx_buffer = serial->_rx_buffer;\n  serial->rx_head = 0;\n  serial->rx_tail = 0;\n  serial->tx_buffer = serial->_tx_buffer;\n  serial->tx_head = 0;\n  serial->tx_tail = 0;\n  return (int)serial;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008c20",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "initializeSerial_08008c20"
        },
        "FUN_0800723c": {
            "renaming": {
                "FUN_0800723c": "get_current_tick_0800723c",
                "uVar1": "current_tick"
            },
            "code": "uint32_t get_current_tick_0800723c(void)\n{\n  uint32_t current_tick = HAL_GetTick();\n  return current_tick;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800723c",
            "calling": [
                "millis"
            ],
            "imported": false,
            "current_name": "get_current_tick_0800723c"
        },
        "FUN_080043a2": {
            "renaming": {
                "FUN_080043a2": "handle_I2C_events_080043a2",
                "*hi2c": "*hi2c",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "uint32_t": "uint32_t",
                "I2C_TypeDef_conflict": "I2C_TypeDef",
                "*pIVar2": "*instance",
                "tmpreg": "N/A",
                "tmpreg_1": "N/A",
                "tmpreg_2": "N/A",
                "tmpreg_3": "N/A",
                "tmpreg_4": "N/A",
                "tmpreg_5": "N/A",
                "tmpreg_6": "N/A",
                "tmpreg_7": "N/A",
                "tmpreg_8": "N/A",
                "tmpreg_9": "N/A",
                "tmpreg_10": "N/A",
                "uVar1": "transfer_options",
                "pIVar2": "instance",
                "hi2c->Instance->CR1": "instance->CR1",
                "hi2c->Instance": "instance",
                "hi2c->EventCount": "event_count",
                "hi2c->XferCount": "transfer_count",
                "hi2c->PreviousState": "previous_state",
                "(hi2c->Init).AddressingMode": "addressing_mode",
                "hi2c->Mode": "mode",
                "hi2c->State": "state"
            },
            "code": "HAL_StatusTypeDef handle_I2C_events_080043a2(I2C_HandleTypeDef *hi2c) {\n  uint32_t transfer_options = hi2c->XferOptions;\n  I2C_TypeDef *instance = hi2c->Instance;\n  uint32_t cr1_reg = instance->CR1;\n  uint32_t cr2_reg = instance->CR2;\n  uint32_t event_count = hi2c->EventCount;\n  uint32_t transfer_count = hi2c->XferCount;\n  uint32_t previous_state = hi2c->PreviousState;\n  uint16_t addressing_mode = (hi2c->Init).AddressingMode;\n  uint16_t mode = hi2c->Mode;\n  uint16_t state = hi2c->State;\n  \n  if (state == HAL_I2C_STATE_BUSY_RX && (event_count != 0 || mode != HAL_I2C_MODE_MEM)) {\n    if (event_count == 0 && addressing_mode == 0xc000) {\n      cr1_reg |= 0x100;\n      event_count++;\n    }\n    else {\n      if (transfer_count == 0) {\n        cr1_reg |= 0x200;\n      }\n      else if (transfer_count == 1) {\n        if (transfer_options == 0xffff0000) {\n          cr1_reg &= 0xfffffbff;\n          if ((cr2_reg & 0x800) == 0) {\n            cr1_reg |= 0x200;\n          }\n          else {\n            cr1_reg &= 0xfffffbff;\n          }\n        }\n        else if ((transfer_options == 4 || transfer_options == 8) || previous_state == 0x12) {\n          cr1_reg &= 0xfffffbff;\n          cr1_reg |= 0x200;\n        }\n        else if (transfer_options == 2) {\n          cr1_reg |= 0x400;\n        }\n        else {\n          cr1_reg &= 0xfffffbff;\n        }\n      }\n      else if (transfer_count == 2) {\n        if (transfer_options == 2) {\n          cr1_reg |= 0x400;\n        }\n        else {\n          cr1_reg |= 0x800;\n          cr1_reg &= 0xfffffbff;\n        }\n        if ((cr2_reg & 0x800) != 0) {\n          cr2_reg |= 0x1000;\n        }\n      }\n      else {\n        cr1_reg |= 0x400;\n        if ((cr2_reg & 0x800) != 0) {\n          cr2_reg |= 0x1000;\n        }\n      }\n      event_count = 0;\n    }\n  }\n  instance->CR1 = cr1_reg;\n  instance->CR2 = cr2_reg;\n  hi2c->EventCount = event_count;\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080043a2",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_I2C_events_080043a2"
        },
        "FUN_08006280": {
            "renaming": {
                "FUN_08006280": "configureTimerChannel_08006280",
                "htim": "timerHandle",
                "Channel": "channel",
                "TIM_TypeDef_conflict": "timerInstance",
                "pTVar1": "timerInstance",
                "DAT_080062f0": "TIM1"
            },
            "code": "HAL_StatusTypeDef_conflict configureTimerChannel_08006280(TIM_HandleTypeDef_conflict *timerHandle, uint32_t channel) { \\n\\\n        TIM_TypeDef_conflict *timerInstance = timerHandle->Instance; \\n\\\n        switch(channel) { \\n\\\n            case 0: \\n\\\n                timerInstance->DIER |= 0x02; \\n\\\n                break; \\n\\\n            case 4: \\n\\\n                timerInstance->DIER |= 0x04; \\n\\\n                break; \\n\\\n            case 8: \\n\\\n                timerInstance->DIER |= 0x08; \\n\\\n                break; \\n\\\n            case 0xc: \\n\\\n                timerInstance->DIER |= 0x10; \\n\\\n        } \\n\\\n        TIM_CCxChannelCmd(timerInstance, channel, 1); \\n\\\n        if (timerInstance == DAT_080062f0) { \\n\\\n            timerInstance->BDTR |= 0x8000; \\n\\\n        } \\n\\\n        timerInstance->CR1 |= 0x01; \\n\\\n        return HAL_OK; \\n\\\n    }",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006280",
            "calling": [
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "configureTimerChannel_08006280"
        },
        "FUN_08007258": {
            "renaming": {
                "FUN_08007258": "configure_GPIO_pin_08007258",
                "pin": "pin_name",
                "mode": "pin_mode",
                "pull": "pin_pull",
                "uVar1": "pin_number",
                "GPIOx": "GPIO_port",
                "tmpreg": "temporary_register",
                "GPIO_InitStructure": "GPIO_InitStruct"
            },
            "code": "void configure_GPIO_pin_08007258(PinName_conflict pin, uint32_t mode, uint32_t pull)\n{\n  uint32_t pin_number = (uint32_t)pin;\n  GPIO_TypeDef *GPIOx = set_GPIO_Port_Clock((pin_number << 24) >> 28);\n  GPIO_InitTypeDef GPIO_InitStruct;\n  GPIO_InitStruct.Pin = (1 << (pin_number & 0x0F)) & 0xFFFF;\n  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;\n  *(uint32_t *)(DAT_080072D0 + 0x18) |= 1;\n  if ((pin_number - 0xD & 0xFF) < 2) {\n    *(uint32_t *)(DAT_080072D4 + 4) = (*(uint32_t *)(DAT_080072D4 + 4) & 0xF8FFFFFF) | 0x4000000;\n  }\n  if ((pin_number == 0xF) || (pin_number == 0x13) || (pin_number == 0x14)) {\n    *(uint32_t *)(DAT_080072D4 + 4) = (*(uint32_t *)(DAT_080072D4 + 4) & 0xF8FFFFFF) | 0x2000000;\n  }\n  GPIO_InitStruct.Mode = mode;\n  GPIO_InitStruct.Pull = pull;\n  HAL_GPIO_Init(GPIOx, &GPIO_InitStruct);\n}\n",
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007258",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "configure_GPIO_pin_08007258"
        },
        "FUN_08009f4c": {
            "renaming": {
                "FUN_08009f4c": "allocate_memory_08009f4c",
                "param_1": "size",
                "param_2": "ptr1",
                "param_3": "ptr2",
                "param_4": "size2",
                "pvVar1": "new_ptr",
                "pvVar2": "usable_size"
            },
            "code": "void * allocate_memory_08009f4c(size_t size, void *ptr1, void *ptr2, size_t size2){\n    void *new_ptr;\n    void *usable_size;\n    if (ptr1 != NULL){\n        if (ptr2 == NULL){\n            free(ptr1);\n            new_ptr = ptr2;\n        }\n        else{\n            usable_size = malloc_usable_size(ptr1);\n            new_ptr = ptr1;\n            if (usable_size < ptr2 && (new_ptr = malloc(size2)) != NULL){\n                memcpy(new_ptr, ptr1, size2);\n                free(ptr1);\n            }\n        }\n        return new_ptr;\n    }\n    new_ptr = malloc(size);\n    return new_ptr;\n}",
            "called": [
                "_free_r",
                "memcpy",
                "_malloc_usable_size_r",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f4c",
            "calling": [
                "realloc"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009f4c"
        },
        "FUN_08009f4a": {
            "renaming": {
                "FUN_08009f4a": "do_nothing_08009f4a"
            },
            "code": "\nvoid do_nothing_08009f4a(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f4a",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_08009f4a"
        },
        "FUN_08006c7c": {
            "renaming": {
                "FUN_08006c7c": "get_pwm_pin_mode_08006c7c",
                "pin": "pin_name",
                "uVar1": "pin_function",
                "uVar2": "pin_mode"
            },
            "code": "uint32_t get_pwm_pin_mode_08006c7c(PinName_conflict pin)\n{\n  uint32_t pin_function = pinmap_function(pin,(PinMap_conflict *)PTR_PinMap_PWM_08006ca4);\n  uint32_t pin_mode = (pin_function << 12) >> 27;\n  if (pin_mode == 3) {\n    return 8;\n  }\n  if (pin_mode != 4) {\n    if (pin_mode != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 12;\n}\n",
            "called": [
                "pinmap_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c7c",
            "calling": [
                "pwm_stop",
                "pwm_start"
            ],
            "imported": false,
            "current_name": "get_pwm_pin_mode_08006c7c"
        },
        "FUN_08006b5c": {
            "renaming": {
                "FUN_08006b5c": "set_pin_to_low_08006b5c",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "pin_index",
                "pin_mask": "pin_mask"
            },
            "code": "void set_pin_to_low_08006b5c(PinName_conflict pin, uint32_t *pin_map) {\n    uint32_t pin_index = (uint32_t)((int)pin << 0x18) >> 0x1c;\n    uint32_t pin_mask = ~(1 << ((int)pin & 0xfU));\n    pin_map[pin_index] &= pin_mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b5c",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "set_pin_to_low_08006b5c"
        },
        "FUN_08007376": {
            "renaming": {
                "FUN_08007376": "find_pin_function_08007376",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "function_index"
            },
            "code": "uint32_t find_pin_function_08007376(PinName_conflict pin_name, PinMap_conflict *pin_map) {\n  uint32_t function_index;\n\n  if (pin_name == NC) {\n    return 0xffffffff;\n  }\n\n  function_index = pinmap_find_function(pin_name, pin_map);\n  return function_index;\n}",
            "called": [
                "pinmap_find_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007376",
            "calling": [
                "pwm_stop",
                "get_adc_channel",
                "get_pwm_channel",
                "HAL_TIM_PWM_MspInit",
                "pwm_start",
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "find_pin_function_08007376"
        },
        "FUN_080033cc": {
            "renaming": {
                "FUN_080033cc": "parse_080033cc",
                "this": "parser",
                "uVar1": "current_byte",
                "sVar2": "bytes_decoded",
                "puVar3": "data_buffer",
                "bufferDataAtPosition": "buffer_data_at_position",
                "decodeByteStream": "decode_byte_stream",
                "stringCallbackFunction": "string_callback_function",
                "currentStringCallback": "current_string_callback",
                "currentStringCallbackContext": "current_string_callback_context",
                "versionCallbackFunction": "version_callback_function",
                "currentReportFirmwareCallback": "current_report_firmware_callback",
                "currentReportFirmwareCallbackContext": "current_report_firmware_callback_context",
                "sysexCallbackFunction": "sysex_callback_function",
                "currentSysexCallback": "current_sysex_callback",
                "sysexBytesRead": "sysex_bytes_read",
                "dataBuffer": "data_buffer",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void __thiscall firmata::FirmataParser::parse_080033cc(FirmataParser *parse_080033ccr)\n{\n  uint8_t current_byte;\n  size_t bytes_decoded;\n  uint8_t *data_buffer;\n  data_buffer = parse_080033ccr->data_buffer;\n  current_byte = *data_buffer;\n  if (current_byte == 'q') {\n    if (parse_080033ccr->current_string_callback != (stringCallbackFunction)0x0) {\n      bytes_decoded = decode_byte_stream(parse_080033ccr, parse_080033ccr->sysex_bytes_read - 1, data_buffer + 1);\n      buffer_data_at_position(parse_080033ccr, '\\0', bytes_decoded + 1);\n      (*parse_080033ccr->current_string_callback)\n                (parse_080033ccr->current_string_callback_context, (char *)(parse_080033ccr->data_buffer + 1));\n      return;\n    }\n  }\n  else if (current_byte == 'y') {\n    if (parse_080033ccr->current_report_firmware_callback != (versionCallbackFunction)0x0) {\n      if (parse_080033ccr->sysex_bytes_read < 3) {\n        (*parse_080033ccr->current_report_firmware_callback)\n                  (parse_080033ccr->current_report_firmware_callback_context, 0, 0, (char *)0x0);\n        return;\n      }\n      bytes_decoded = decode_byte_stream(parse_080033ccr, parse_080033ccr->sysex_bytes_read - 3, data_buffer + 3);\n      buffer_data_at_position(parse_080033ccr, '\\0', bytes_decoded + 3);\n      data_buffer = parse_080033ccr->data_buffer;\n      (*parse_080033ccr->current_report_firmware_callback)\n                (parse_080033ccr->current_report_firmware_callback_context, (uint)data_buffer[1], (uint)data_buffer[2], (char *)(data_buffer + 3));\n      return;\n    }\n  }\n  else if (parse_080033ccr->current_sysex_callback != (sysexCallbackFunction)0x0) {\n    (*parse_080033ccr->current_sysex_callback)\n              (parse_080033ccr->current_sysex_callback_context, current_byte, parse_080033ccr->sysex_bytes_read - 1, data_buffer + 1);\n  }\n  return;\n}",
            "called": [
                "bufferDataAtPosition",
                "decodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080033cc",
            "calling": [
                "parse"
            ],
            "imported": false,
            "current_name": "parse_080033cc"
        },
        "FUN_08003de4": {
            "renaming": {
                "FUN_08003de4": "stop_adc_conversion_08003de4",
                "hadc": "adc_handle",
                "HVar1": "status",
                "HAL_LOCKED": "ADC_LOCKED",
                "HAL_UNLOCKED": "ADC_UNLOCKED",
                "ADC_ConversionStop_Disable": "stop_adc_conversion_disable",
                "State": "adc_state",
                "Lock": "adc_lock"
            },
            "code": "HAL_StatusTypeDef_conflict stop_adc_conversion_08003de4(ADC_HandleTypeDef *hadc)\n{\n  HAL_StatusTypeDef_conflict status;\n  if (hadc->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  hadc->Lock = HAL_LOCKED;\n  status = ADC_ConversionStop_Disable(hadc);\n  if (status == HAL_OK) {\n    hadc->State &= 0xffffeefe | 1;\n  }\n  hadc->Lock = HAL_UNLOCKED;\n  return status;\n}",
            "called": [
                "ADC_ConversionStop_Disable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003de4",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "stop_adc_conversion_08003de4"
        },
        "FUN_08000500": {
            "renaming": {
                "FUN_08000500": "attachServo_08000500",
                "byte pin": "byte servoPin",
                "int minPulse": "int minPulseWidth",
                "int maxPulse": "int maxPulseWidth",
                "pin_00": "servoPin",
                "bVar1": "servoCount",
                "PTR_servoCount_0800056c": "servoCountPtr",
                "firmata::FirmataClass::sendString": "firmata::FirmataClass::sendString",
                "FirmataClass *PTR_Firmata_08000584": "FirmataClass *firmataPtr",
                "PTR_s_Max_servos_attached_08000580": "maxServosAttachedMsg",
                "bVar2": "detachedServoCount",
                "PTR_detachedServoCount_08000570": "detachedServoCountPtr",
                "PTR_servoPinMap_08000578": "servoPinMap",
                "PTR_detachedServos_08000574": "detachedServos",
                "Servo::attach": "Servo::attach",
                "PTR_servos_0800057c": "servosPtr"
            },
            "code": "void attachServo_08000500(byte servoPin, int minPulseWidth, int maxPulseWidth)\n{\n  byte servoCount = *PTR_servoCount_0800056c;\n  if (servoCount > 11) {\n    firmata::FirmataClass::sendString((FirmataClass*)firmataPtr, PTR_s_Max_servos_attached_08000580);\n    return;\n  }\n  byte detachedServoCount = *PTR_detachedServoCount_08000570;\n  if (detachedServoCount == 0) {\n    PTR_servoPinMap_08000578[servoPin] = servoCount;\n    *PTR_servoCount_0800056c = servoCount + 1;\n  }\n  else {\n    PTR_servoPinMap_08000578[servoPin] = PTR_detachedServos_08000574[detachedServoCount - 1];\n    *PTR_detachedServoCount_08000570 = detachedServoCount - 1;\n  }\n  if ((minPulseWidth > 0) && (maxPulseWidth > 0)) {\n    Servo::attach((Servo*)(PTR_servos_0800057c + (uint8_t)PTR_servoPinMap_08000578[servoPin] * 3), servoPin, minPulseWidth, maxPulseWidth);\n    return;\n  }\n  Servo::attach((Servo*)(PTR_servos_0800057c + (uint8_t)PTR_servoPinMap_08000578[servoPin] * 3), servoPin);\n}",
            "called": [
                "attach",
                "attach",
                "sendString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000500",
            "calling": [
                "sysexCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "attachServo_08000500"
        },
        "FUN_08009d24": {
            "renaming": {
                "FUN_08009d24": "allocate_memory_08009d24",
                "param_1": "size_of_memory_block",
                "param_2": "num_blocks",
                "puVar1": "memory_block",
                "iVar2": "total_size"
            },
            "code": "_malloc_r allocate_memory_08009d24(int size_of_memory_block, int num_blocks) {\n  int total_size = (num_blocks - 1) * 104;\n  undefined4 *memory_block = (_malloc_r)(size_of_memory_block, total_size + 116);\n  if (memory_block != (undefined4 *)0x0) {\n    *memory_block = 0;\n    memory_block[1] = num_blocks;\n    memory_block[2] = memory_block + 3;\n    memset(memory_block + 3, 0, total_size + 104);\n  }\n  return memory_block;\n}",
            "called": [
                "memset",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009d24",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009d24"
        },
        "FUN_08008e72": {
            "renaming": {
                "__thiscall Print::FUN_08008e72": "printCharacter",
                "this": "printer",
                "c": "character",
                "sVar1": "result",
                "FUN_08008e72": "printCharacter_08008e72"
            },
            "code": "size_t __thiscall printCharacter_08008e72(Print* printer, char character) {\n  size_t result;\n  result = (**printer->_vptr_Print)(printer, (int)character);\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e72",
            "calling": [
                "printTo"
            ],
            "imported": false,
            "current_name": "printCharacter_08008e72"
        },
        "FUN_080022f8": {
            "renaming": {
                "FUN_080022f8": "checkAndUpdateInputs_080022f8",
                "bVar1": "input_changed",
                "PVar2": "pin_name",
                "bVar3": "pin_mode",
                "iVar4": "available_bytes",
                "uVar5": "current_millis",
                "uVar6": "i",
                "ulPin": "digital_pin",
                "PTR_Firmata_080023e0": "firmata_instance",
                "PTR_currentMillis_080023e4": "current_millis_ptr",
                "PTR_samplingInterval_080023ec": "sampling_interval_ptr",
                "PTR_previousMillis_080023e8": "previous_millis_ptr",
                "PTR_digitalPin_080023f4": "digital_pin_array",
                "NC": "NotConnected",
                "PTR_analogInputsToReport_080023f0": "analog_input_report_ptr",
                "PTR_queryIndex_080023f8": "query_index_ptr",
                "PTR_query_080023fc": "query_array_ptr",
                "readAndReportData": "read_and_report_data",
                "millis": "get_current_millis",
                "pinNametoDigitalPin": "get_digital_pin_number",
                "analogRead": "read_analog_input",
                "firmata::FirmataClass::available": "get_available_bytes",
                "firmata::FirmataClass::processInput": "process_firmata_input",
                "firmata::FirmataClass::getPinMode": "get_pin_mode",
                "firmata::FirmataClass::sendAnalog": "send_analog_to_firmata"
            },
            "code": "void checkAndUpdateInputs_080022f8() {\n    bool input_changed;\n    PinName_conflict pin_name;\n    byte pin_mode;\n    int available_bytes;\n    uint32_t current_millis = millis();\n    *(uint32_t *)PTR_currentMillis_080023e4 = current_millis;\n    if (*(uint *)PTR_samplingInterval_080023ec < current_millis - *(int *)PTR_previousMillis_080023e8) {\n        *(uint *)PTR_previousMillis_080023e8 = *(int *)PTR_previousMillis_080023e8 + *(uint *)PTR_samplingInterval_080023ec;\n        for (uint i = 0; i < 0x3c; i++) {\n            uint digital_pin = i - 0x2e & 0xff;\n            if (digital_pin < 0xe) {\n                if (i < 0x3c) {\n                    pin_name = PTR_digitalPin_080023f4[i];\n                }\n                else {\n                    pin_name = NC;\n                }\n                uint digital_pin_number = pinNametoDigitalPin(pin_name);\n                if (digital_pin_number == 0) {\n                    input_changed = false;\n                }\n                else if (digital_pin_number == 1) {\n                    input_changed = false;\n                }\n                else {\n                    pin_mode = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_080023e0,(byte)i);\n                    input_changed = pin_mode == 2;\n                }\n            }\n            else {\n                input_changed = false;\n            }\n            if (input_changed && ((*(int *)PTR_analogInputsToReport_080023f0 >> digital_pin & 1U) != 0)) {\n                uint analog_input_value = analogRead(digital_pin);\n                firmata::FirmataClass::sendAnalog((FirmataClass *)PTR_Firmata_080023e0,(byte)digital_pin,analog_input_value);\n            }\n        }\n        if (-1 < (char)*PTR_queryIndex_080023f8) {\n            for (uint i = 0; (int)i < (char)*PTR_queryIndex_080023f8 + 1; i++) {\n                int query_index = i * 0xc;\n                readAndReportData(PTR_query_080023fc[query_index],*(int *)(PTR_query_080023fc + query_index + 4),PTR_query_080023fc[query_index + 8],PTR_query_080023fc[query_index + 9]);\n            }\n        }\n    }\n}",
            "called": [
                "processInput",
                "checkDigitalInputs",
                "millis",
                "pinNametoDigitalPin",
                "sendAnalog",
                "analogRead",
                "readAndReportData",
                "getPinMode",
                "available"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080022f8",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "checkAndUpdateInputs_080022f8"
        },
        "FUN_08005084": {
            "renaming": {
                "FUN_08005084": "read_i2c_08005084",
                "hi2c": "i2c_handle",
                "HVar1": "state",
                "pIVar2": "i2c_instance",
                "puVar3": "buff_ptr"
            },
            "code": "HAL_StatusTypeDef_conflict read_i2c_08005084(I2C_HandleTypeDef_conflict *i2c_handle) {\n  HAL_I2C_StateTypeDef_conflict state = i2c_handle->State;\n  I2C_TypeDef_conflict *i2c_instance = i2c_handle->Instance;\n  uint8_t *buff_ptr;\n  uint32_t tmpreg;\n  \n  i2c_instance->CR2 &= 0xfffff8ff;\n  i2c_instance->CR1 |= 1;\n  i2c_instance->CR1 &= 0xfffffbff;\n  \n  if ((i2c_instance->CR2 & 0x800) != 0) {\n    if ((i2c_handle->State == HAL_I2C_STATE_BUSY_RX) || (i2c_handle->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2c_handle->XferCount = (uint16_t)i2c_handle->hdmarx->Instance->CNDTR;\n    }\n    else {\n      i2c_handle->XferCount = (uint16_t)i2c_handle->hdmatx->Instance->CNDTR;\n    }\n  }\n  \n  if (i2c_handle->XferCount != 0) {\n    if ((i2c_instance->SR1 & 4) != 0) {\n      buff_ptr = i2c_handle->pBuffPtr;\n      i2c_handle->pBuffPtr = buff_ptr + 1;\n      *buff_ptr = (uint8_t)i2c_instance->DR;\n      i2c_handle->XferCount--;\n    }\n    if ((i2c_instance->SR1 & 0x40) != 0) {\n      buff_ptr = i2c_handle->pBuffPtr;\n      i2c_handle->pBuffPtr = buff_ptr + 1;\n      *buff_ptr = (uint8_t)i2c_instance->DR;\n      i2c_handle->XferCount--;\n    }\n    i2c_handle->ErrorCode |= 4;\n  }\n  \n  if (i2c_handle->ErrorCode == 0) {\n    if (((state == HAL_I2C_STATE_LISTEN) || (state == HAL_I2C_STATE_BUSY_RX_LISTEN)) || (state == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2c_handle->XferOptions = DAT_08005184;\n      i2c_handle->PreviousState = 0;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(i2c_handle);\n    }\n    else if ((i2c_handle->PreviousState == 0x22) || (state == HAL_I2C_STATE_BUSY_RX)) {\n      i2c_handle->PreviousState = 0;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(i2c_handle);\n    }\n  }\n  else {\n    I2C_ITError(i2c_handle);\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveRxCpltCallback",
                "I2C_ITError"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005084",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "read_i2c_08005084"
        },
        "FUN_08008b0e": {
            "renaming": {
                "FUN_08008b0e": "readNextByteFromSerialBuffer_08008b0e",
                "this": "serialObj",
                "uVar1": "tailIndex",
                "_serial": "serialData",
                "rx_tail": "tailIndex",
                "rx_head": "headIndex",
                "rx_buff": "buffer"
            },
            "code": "int readNextByteFromSerialBuffer_08008b0e(HardwareSerial *serialObj) {\n  uint32_t tailIndex = (uint32_t)(serialObj->_serial).rx_tail;\n  if ((serialObj->_serial).rx_head != tailIndex) {\n    return (uint32_t)(serialObj->_serial).rx_buff[tailIndex];\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b0e",
            "calling": [],
            "imported": false,
            "current_name": "readNextByteFromSerialBuffer_08008b0e"
        },
        "FUN_0800291c": {
            "renaming": {
                "FUN_0800291c::FUN_0800291c": "initialize_i2c",
                "this": "this_i2c",
                "(this->super_Stream).super_Print.write_error": "write_error",
                "(this->super_Stream)._timeout": "timeout",
                "(this->super_Stream).super_Print._vptr_Print": "write_function_pointer",
                "PTR_digitalPin_08002944": "digital_pin_array",
                "(this->_i2c).sda": "i2c_sda_pin",
                "(this->_i2c).scl": "i2c_scl_pin",
                "FUN_0800291c": "initialize_i2c_0800291c"
            },
            "code": "initialize_i2c_0800291c * __thiscall initialize_i2c_0800291c(initialize_i2c_0800291c *this)\n{\n    undefined *digital_pins;\n    this->super_Stream.super_Print.write_error = 0;\n    this->super_Stream._timeout = 1000;\n    this->super_Stream.super_Print._vptr_Print = (_func_int_varargs **)write_function_pointer;\n    digital_pins = PTR_digitalPin_08002944;\n    (this->_i2c).sda = digital_pins[14];\n    (this->_i2c).scl = digital_pins[15];\n    return this;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800291c",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_i2c_0800291c"
        },
        "FUN_08002ac0": {
            "renaming": {
                "FUN_08002ac0": "readByte_08002ac0",
                "this": "wire",
                "uVar1": "byte"
            },
            "code": "uint8_t __thiscall TwoWire::readByte_08002ac0(TwoWire *wire)\n{\n  uint8_t byte;\n  byte = readByte_08002ac0(wire, '\\x01');\n  return byte;\n}",
            "called": [
                "endTransmission"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ac0",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "readByte_08002ac0"
        },
        "FUN_080032bc": {
            "renaming": {
                "FUN_080032bc": "Firmata_080032bc",
                "this": "self",
                "dataBuffer": "data_buffer",
                "dataBufferSize": "data_buffer_size",
                "executeMultiByteCommand": "execute_multi_byte_command",
                "multiByteChannel": "multi_byte_channel",
                "waitForData": "wait_for_data",
                "parsingSysex": "parsing_sysex",
                "sysexBytesRead": "sysex_bytes_read",
                "currentAnalogCallbackContext": "current_analog_callback_context",
                "currentDigitalCallbackContext": "current_digital_callback_context",
                "currentReportAnalogCallbackContext": "current_report_analog_callback_context",
                "currentReportDigitalCallbackContext": "current_report_digital_callback_context",
                "currentPinModeCallbackContext": "current_pin_mode_callback_context",
                "currentPinValueCallbackContext": "current_pin_value_callback_context",
                "currentReportFirmwareCallbackContext": "current_report_firmware_callback_context",
                "currentReportVersionCallbackContext": "current_report_version_callback_context",
                "currentDataBufferOverflowCallbackContext": "current_data_buffer_overflow_callback_context",
                "currentStringCallbackContext": "current_string_callback_context",
                "currentSysexCallbackContext": "current_sysex_callback_context",
                "currentSystemResetCallbackContext": "current_system_reset_callback_context",
                "currentAnalogCallback": "current_analog_callback",
                "currentDigitalCallback": "current_digital_callback",
                "currentReportAnalogCallback": "current_report_analog_callback",
                "currentReportDigitalCallback": "current_report_digital_callback",
                "currentPinModeCallback": "current_pin_mode_callback",
                "currentPinValueCallback": "current_pin_value_callback",
                "currentDataBufferOverflowCallback": "current_data_buffer_overflow_callback",
                "currentStringCallback": "current_string_callback",
                "currentSysexCallback": "current_sysex_callback",
                "currentReportFirmwareCallback": "current_report_firmware_callback",
                "currentReportVersionCallback": "current_report_version_callback",
                "currentSystemResetCallback": "current_system_reset_callback",
                "count_leading_zeroes": "count_leading_zeroes"
            },
            "code": "__thiscall Firmata_080032bc::Firmata_080032bc(Firmata_080032bc *this, uint8_t *dataBuffer, size_t dataBufferSize) {\\n\"\n                      \"    this->dataBuffer = dataBuffer;\\n\"\n                      \"    this->dataBufferSize = dataBufferSize;\\n\"\n                      \"    this->executeMultiByteCommand = \"\\0\";\\n\"\n                      \"    this->multiByteChannel = \"\\0\";\\n\"\n                      \"    this->waitForData = 0;\\n\"\n                      \"    this->parsingSysex = false;\\n\"\n                      \"    this->sysexBytesRead = 0;\\n\"\n                      \"    this->currentAnalogCallbackContext = nullptr;\\n\"\n                      \"    this->currentDigitalCallbackContext = nullptr;\\n\"\n                      \"    this->currentReportAnalogCallbackContext = nullptr;\\n\"\n                      \"    this->currentReportDigitalCallbackContext = nullptr;\\n\"\n                      \"    this->currentPinModeCallbackContext = nullptr;\\n\"\n                      \"    this->currentPinValueCallbackContext = nullptr;\\n\"\n                      \"    this->currentReportFirmwareCallbackContext = nullptr;\\n\"\n                      \"    this->currentReportVersionCallbackContext = nullptr;\\n\"\n                      \"    this->currentDataBufferOverflowCallbackContext = nullptr;\\n\"\n                      \"    this->currentStringCallbackContext = nullptr;\\n\"\n                      \"    this->currentSysexCallbackContext = nullptr;\\n\"\n                      \"    this->currentSystemResetCallbackContext = nullptr;\\n\"\n                      \"    this->currentAnalogCallback = nullptr;\\n\"\n                      \"    this->currentDigitalCallback = nullptr;\\n\"\n                      \"    this->currentReportAnalogCallback = nullptr;\\n\"\n                      \"    this->currentReportDigitalCallback = nullptr;\\n\"\n                      \"    this->currentPinModeCallback = nullptr;\\n\"\n                      \"    this->currentPinValueCallback = nullptr;\\n\"\n                      \"    this->currentDataBufferOverflowCallback = nullptr;\\n\"\n                      \"    this->currentStringCallback = nullptr;\\n\"\n                      \"    this->currentSysexCallback = nullptr;\\n\"\n                      \"    this->currentReportFirmwareCallback = nullptr;\\n\"\n                      \"    this->currentReportVersionCallback = nullptr;\\n\"\n                      \"    this->currentSystemResetCallback = nullptr;\\n\"\n                      \"    uint leadingZeroes = count_leading_zeroes(dataBuffer);\\n\"\n                      \"    this->allowBufferUpdate = (leadingZeroes >> 5) & 1;\\n\"\n                      \"    return this;\\n\"\n                      \"}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080032bc",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "Firmata_080032bc"
        },
        "FUN_080077b0": {
            "renaming": {
                "FUN_080077b0": "FUNC_080077b0"
            },
            "code": "\nvoid FUNC_080077b0(i2c_t_conflict *obj,i2c_timing_e_conflict timing,uint32_t addressingMode,\n                    uint32_t ownAddress,uint8_t master)\n\n{\n  undefined *puVar1;\n  I2C_TypeDef_conflict *pIVar2;\n  void *a;\n  void *b;\n  I2C_TypeDef_conflict *pIVar3;\n  GPIO_TypeDef *pGVar4;\n  uint32_t uVar5;\n  uint32_t uVar6;\n  I2C_HandleTypeDef_conflict *hi2c;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_2;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (obj != (i2c_t_conflict *)0x0) {\n    hi2c = &obj->handle;\n    a = pinmap_peripheral(obj->sda,(PinMap_conflict *)PTR_PinMap_I2C_SDA_08007a74);\n    b = pinmap_peripheral(obj->scl,(PinMap_conflict *)PTR_PinMap_I2C_SCL_08007a78);\n    if ((a == (void *)0x0) || (b == (void *)0x0)) {\n      iprintf(PTR_s_ERROR__at_least_one_I2C_pin_has_n_08007a88);\n    }\n    else {\n      pIVar3 = (I2C_TypeDef_conflict *)pinmap_merge_peripheral(a,b);\n      obj->i2c = pIVar3;\n      pIVar2 = DAT_08007a7c;\n      if (pIVar3 == (I2C_TypeDef_conflict *)0x0) {\n        iprintf(PTR_s_ERROR__I2C_pins_mismatch_08007a8c);\n      }\n      else {\n        if (pIVar3 == DAT_08007a7c) {\n          DAT_08007a7c[0xc56].CR2 = DAT_08007a7c[0xc56].CR2 | 0x200000;\n          pIVar2[0xc55].CCR = pIVar2[0xc55].CCR | 0x200000;\n          pIVar2[0xc55].CCR = pIVar2[0xc55].CCR & 0xffdfffff;\n          obj->irq = I2C1_EV_IRQn;\n          obj->irqER = I2C1_ER_IRQn;\n          *(I2C_HandleTypeDef_conflict **)PTR_i2c_handles_08007a90 = hi2c;\n        }\n        pIVar2 = DAT_08007a80;\n        if (obj->i2c == DAT_08007a80) {\n          DAT_08007a80[0xc39].SR2 = DAT_08007a80[0xc39].SR2 | 0x400000;\n          pIVar2[0xc39].OAR2 = pIVar2[0xc39].OAR2 | 0x400000;\n          pIVar2[0xc39].OAR2 = pIVar2[0xc39].OAR2 & 0xffbfffff;\n          obj->irq = I2C2_EV_IRQn;\n          obj->irqER = I2C2_ER_IRQn;\n          *(I2C_HandleTypeDef_conflict **)(PTR_i2c_handles_08007a90 + 4) = hi2c;\n        }\n        pGVar4 = set_GPIO_Port_Clock((uint)((int)obj->scl << 0x18) >> 0x1c);\n        puVar1 = PTR_PinMap_I2C_SCL_08007a78;\n        GPIO_InitStruct.Pin = 1 << ((int)obj->scl & 0xfU) & 0xffff;\n        uVar5 = pinmap_function(obj->scl,(PinMap_conflict *)PTR_PinMap_I2C_SCL_08007a78);\n        uVar6 = pinmap_function(obj->scl,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Mode = (uVar5 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Speed = 3;\n        uVar5 = pinmap_function(obj->scl,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Pull = (uVar5 << 0x1a) >> 0x1e;\n        uVar5 = pinmap_function(obj->scl,(PinMap_conflict *)puVar1);\n        *(uint *)(DAT_08007a84 + 0x18) = *(uint *)(DAT_08007a84 + 0x18) | 1;\n        switch((uVar5 << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08007a94 + 4) = *(uint *)(DAT_08007a94 + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xf8ffffff | 0x4000000;\n        }\n        HAL_GPIO_Init(pGVar4,&GPIO_InitStruct);\n        pGVar4 = set_GPIO_Port_Clock((uint)((int)obj->sda << 0x18) >> 0x1c);\n        puVar1 = PTR_PinMap_I2C_SDA_08007a74;\n        GPIO_InitStruct.Pin = 1 << ((int)obj->sda & 0xfU) & 0xffff;\n        uVar5 = pinmap_function(obj->sda,(PinMap_conflict *)PTR_PinMap_I2C_SDA_08007a74);\n        uVar6 = pinmap_function(obj->sda,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Mode = (uVar5 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Speed = 3;\n        uVar5 = pinmap_function(obj->sda,(PinMap_conflict *)puVar1);\n        GPIO_InitStruct.Pull = (uVar5 << 0x1a) >> 0x1e;\n        uVar5 = pinmap_function(obj->sda,(PinMap_conflict *)puVar1);\n        *(uint *)(DAT_08007a84 + 0x18) = *(uint *)(DAT_08007a84 + 0x18) | 1;\n        switch((uVar5 << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_08007d4c + 4) = *(uint *)(DAT_08007d4c + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_08007e70 + 4) = *(uint *)(DAT_08007e70 + 4) & 0xf8ffffff | 0x4000000;\n        }\n        HAL_GPIO_Init(pGVar4,&GPIO_InitStruct);\n        (obj->handle).Instance = obj->i2c;\n        (obj->handle).Init.ClockSpeed = timing;\n        (obj->handle).Init.DutyCycle = 0;\n        (obj->handle).Init.OwnAddress1 = ownAddress;\n        (obj->handle).Init.OwnAddress2 = 0xff;\n        (obj->handle).Init.AddressingMode = addressingMode;\n        (obj->handle).Init.DualAddressMode = 0;\n        (obj->handle).Init.GeneralCallMode = 0;\n        (obj->handle).Init.NoStretchMode = 0;\n        (obj->handle).State = HAL_I2C_STATE_RESET;\n        HAL_NVIC_SetPriority(obj->irq,0,1);\n        HAL_NVIC_EnableIRQ(obj->irq);\n        HAL_NVIC_SetPriority(obj->irqER,0,1);\n        HAL_NVIC_EnableIRQ(obj->irqER);\n        HAL_I2C_Init(hi2c);\n        obj->isMaster = master;\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "pinmap_function",
                "HAL_GPIO_Init",
                "pinmap_merge_peripheral",
                "pinmap_peripheral",
                "set_GPIO_Port_Clock",
                "HAL_NVIC_SetPriority",
                "HAL_I2C_Init",
                "HAL_NVIC_EnableIRQ",
                "iprintf"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080077b0",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "FUNC_080077b0"
        },
        "FUN_08008c44": {
            "renaming": {
                "__thiscall HardwareSerial::FUN_08008c44": "configureSerial",
                "this": "serial",
                "baud": "baudrate",
                "config": "config",
                "bVar1": "configMask",
                "iVar2": "databits",
                "_serial": "serialData",
                "PTR_s__home_bo__arduino15_packages_STM_08008cfc": "assertionMessage",
                "PTR___PRETTY_FUNCTION___08008cf8": "functionName",
                "PTR_s_databits__0_08008cf4": "databitsAssertionMessage",
                "FUN_08008c44": "configureSerial_08008c44"
            },
            "code": "void configureSerial_08008c44(HardwareSerial *serial, unsigned long baudrate, byte config) {\n  byte configMask = config & 7;\n  int databits = 0;\n  int parity = 0;\n  int stopbits = 0;\n\n  switch (configMask) {\n    case 4:\n      databits = 7;\n      break;\n    case 6:\n      databits = 8;\n      break;\n    case 2:\n      databits = 6;\n      break;\n    default:\n      break;\n  }\n\n  if ((config & 0x30) == 0x30) {\n    parity = 0x600;\n    databits++;\n  } else if ((config & 0x20) == 0) {\n    parity = 0;\n  } else {\n    parity = 0x400;\n    databits++;\n  }\n\n  if ((config & 8) == 0) {\n    stopbits = 0;\n  } else {\n    stopbits = 0x2000;\n  }\n\n  if (databits == 8) {\n    serial->databits = 0;\n  } else if (databits == 9) {\n    serial->databits = 0x1000;\n  }\n\n  if (databits != 0) {\n    serial->baudrate = baudrate;\n    serial->parity = parity;\n    serial->stopbits = stopbits;\n    uart_init((serial_t *)serial);\n    uart_attach_rx_callback((serial_t *)serial, receiveSerialData);\n    return;\n  }\n\n  __assert_func(PTR_s__home_bo__arduino15_packages_STM_08008cfc, 299, PTR___PRETTY_FUNCTION___08008cf8, PTR_s_databits__0_08008cf4);\n}",
            "called": [
                "uart_attach_rx_callback",
                "__assert_func",
                "uart_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008c44",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "configureSerial_08008c44"
        },
        "FUN_08006060": {
            "renaming": {
                "FUN_08006060": "configure_timer_08006060",
                "htim": "timer",
                "State": "state",
                "Lock": "lock",
                "HAL_TIM_OC_MspInit": "HAL_TIM_OC_MspInit",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_TIM_STATE_RESET": "HAL_TIM_STATE_RESET",
                "HAL_TIM_STATE_BUSY": "HAL_TIM_STATE_BUSY",
                "TIM_Base_SetConfig": "TIM_Base_SetConfig",
                "Instance": "Instance",
                "Init": "Init",
                "HAL_TIM_STATE_READY": "HAL_TIM_STATE_READY",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef_conflict",
                "HAL_OK": "HAL_OK",
                "HAL_ERROR": "HAL_ERROR"
            },
            "code": "HAL_StatusTypeDef_conflict configure_timer_08006060(TIM_HandleTypeDef_conflict *timer)\n{\n    if (timer != NULL) {\n        if (timer->state == HAL_TIM_STATE_RESET) {\n            timer->lock = HAL_UNLOCKED;\n            HAL_TIM_OC_MspInit(timer);\n        }\n        timer->state = HAL_TIM_STATE_BUSY;\n        TIM_Base_SetConfig(timer->Instance, &(timer->Init));\n        timer->state = HAL_TIM_STATE_READY;\n        return HAL_OK;\n    }\n    return HAL_ERROR;\n}",
            "called": [
                "TIM_Base_SetConfig",
                "HAL_TIM_OC_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006060",
            "calling": [
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "configure_timer_08006060"
        },
        "FUN_08009698": {
            "renaming": {
                "FUN_08009698": "FUNC_08009698"
            },
            "code": "\nuint FUNC_08009698(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  byte bVar1;\n  int iVar2;\n  uint *puVar3;\n  void *pvVar4;\n  int iVar5;\n  undefined *puVar6;\n  uint uVar7;\n  uint **ppuVar8;\n  uint uVar9;\n  uint uVar10;\n  undefined *puVar11;\n  undefined *__s;\n  uint local_24 [2];\n  \n  bVar1 = *(byte *)(param_2 + 6);\n  __s = (undefined *)((int)param_2 + 0x43);\n  if (bVar1 != 0x6e) {\n    if (bVar1 < 0x6f) {\n      if (bVar1 != 99) {\n        if (bVar1 < 100) {\n          if (bVar1 == 0) goto LAB_08009852;\n          if (bVar1 != 0x58) goto LAB_080096c8;\n          *(undefined *)((int)param_2 + 0x45) = 0x58;\n          puVar6 = PTR_s_0123456789ABCDEF_080098d4;\nLAB_080097e2:\n          uVar7 = *param_2;\n          puVar3 = *param_5;\n          *param_5 = puVar3 + 1;\n          if (((uVar7 & 0x80) == 0) && ((int)(uVar7 << 0x19) < 0)) {\n            uVar9 = (uint)*(ushort *)puVar3;\n          }\n          else {\n            uVar9 = *puVar3;\n          }\n          if ((int)(uVar7 << 0x1f) < 0) {\n            *param_2 = uVar7 | 0x20;\n          }\n          if (uVar9 == 0) {\n            *param_2 = *param_2 & 0xffffffdf;\n          }\n          uVar7 = 0x10;\nLAB_08009778:\n          *(undefined *)((int)param_2 + 0x43) = 0;\n        }\n        else {\n          if ((bVar1 != 100) && (bVar1 != 0x69)) goto LAB_080096c8;\n          uVar9 = *param_2;\n          puVar3 = *param_5;\n          if ((uVar9 & 0x80) == 0) {\n            *param_5 = puVar3 + 1;\n            if ((uVar9 & 0x40) == 0) goto LAB_080096e8;\n            uVar9 = (uint)(short)*(ushort *)puVar3;\n          }\n          else {\n            *param_5 = puVar3 + 1;\nLAB_080096e8:\n            uVar9 = *puVar3;\n          }\n          if ((int)uVar9 < 0) {\n            uVar9 = -uVar9;\n            *(undefined *)((int)param_2 + 0x43) = 0x2d;\n          }\n          uVar7 = 10;\n          puVar6 = PTR_s_0123456789ABCDEF_080098d4;\n        }\n        uVar10 = param_2[1];\n        param_2[2] = uVar10;\n        puVar11 = __s;\n        if ((int)uVar10 < 0) {\n          if (uVar9 != 0) goto LAB_08009816;\nLAB_080098c4:\n          *(undefined *)((int)param_2 + 0x42) = *puVar6;\n          puVar11 = (undefined *)((int)param_2 + 0x42);\n        }\n        else {\n          *param_2 = *param_2 & 0xfffffffb;\n          if (uVar9 == 0) {\n            if (uVar10 != 0) goto LAB_080098c4;\n          }\n          else {\nLAB_08009816:\n            do {\n              uVar10 = uVar9 / uVar7;\n              puVar11 = puVar11 + -1;\n              *puVar11 = puVar6[uVar9 - uVar7 * uVar10];\n              uVar9 = uVar10;\n            } while (uVar10 != 0);\n          }\n        }\n        if (((uVar7 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4]))\n        {\n          puVar11[-1] = 0x30;\n          puVar11 = puVar11 + -1;\n        }\n        param_2[4] = (int)__s - (int)puVar11;\n        __s = puVar11;\n        goto LAB_080097be;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      *(char *)((int)param_2 + 0x42) = (char)*puVar3;\nLAB_08009728:\n      __s = (undefined *)((int)param_2 + 0x42);\n      uVar9 = 1;\n    }\n    else {\n      if (bVar1 != 0x73) {\n        if (bVar1 < 0x74) {\n          if (bVar1 == 0x6f) {\nLAB_0800974e:\n            uVar9 = *param_2;\n            puVar3 = *param_5;\n            if ((uVar9 & 0x80) == 0) {\n              *param_5 = puVar3 + 1;\n              if ((uVar9 & 0x40) == 0) goto LAB_0800975c;\n              uVar9 = (uint)*(ushort *)puVar3;\n            }\n            else {\n              *param_5 = puVar3 + 1;\nLAB_0800975c:\n              uVar9 = *puVar3;\n            }\n            puVar6 = PTR_s_0123456789ABCDEF_080098d4;\n            if (bVar1 == 0x6f) {\n              uVar7 = 8;\n            }\n            else {\n              uVar7 = 10;\n            }\n            goto LAB_08009778;\n          }\n          if (bVar1 == 0x70) {\n            *param_2 = *param_2 | 0x20;\nLAB_0800970e:\n            puVar6 = PTR_s_0123456789abcdef_080098d0;\n            *(undefined *)((int)param_2 + 0x45) = 0x78;\n            goto LAB_080097e2;\n          }\n        }\n        else {\n          if (bVar1 == 0x75) goto LAB_0800974e;\n          if (bVar1 == 0x78) goto LAB_0800970e;\n        }\nLAB_080096c8:\n        *(byte *)((int)param_2 + 0x42) = bVar1;\n        goto LAB_08009728;\n      }\n      puVar3 = *param_5;\n      *param_5 = puVar3 + 1;\n      __s = (undefined *)*puVar3;\n      pvVar4 = memchr(__s,0,param_2[1]);\n      if (pvVar4 != (void *)0x0) {\n        param_2[1] = (int)pvVar4 - (int)__s;\n      }\n      uVar9 = param_2[1];\n    }\n    param_2[4] = uVar9;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_080097be;\n  }\n  uVar9 = *param_2;\n  ppuVar8 = (uint **)*param_5;\n  uVar7 = param_2[5];\n  if ((uVar9 & 0x80) == 0) {\n    *param_5 = (uint *)(ppuVar8 + 1);\n    puVar3 = *ppuVar8;\n    if ((uVar9 & 0x40) == 0) goto LAB_0800983e;\n    *(short *)puVar3 = (short)uVar7;\n  }\n  else {\n    *param_5 = (uint *)(ppuVar8 + 1);\n    puVar3 = *ppuVar8;\nLAB_0800983e:\n    *puVar3 = uVar7;\n  }\nLAB_08009852:\n  param_2[4] = 0;\nLAB_080097be:\n  iVar2 = _printf_common(param_1,param_2,local_24,param_3,param_4);\n  if ((iVar2 == -1) || (iVar2 = (*param_4)(param_1,param_3,__s,param_2[4]), iVar2 == -1)) {\nLAB_080097d2:\n    uVar9 = 0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar2 = 0; iVar2 < (int)(param_2[3] - local_24[0]); iVar2 = iVar2 + 1) {\n        iVar5 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar5 == -1) goto LAB_080097d2;\n      }\n    }\n    uVar9 = param_2[3];\n    if ((int)param_2[3] < (int)local_24[0]) {\n      uVar9 = local_24[0];\n    }\n  }\n  return uVar9;\n}\n\n",
            "called": [
                "_printf_common",
                "memchr"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08009698",
            "calling": [
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "FUNC_08009698"
        },
        "FUN_08006186": {
            "renaming": {
                "FUN_08006186": "configureTimer_08006186",
                "*htim": "*timer_handle",
                "*sConfig": "*output_config",
                "Channel": "channel",
                "Lock": "lock_status",
                "State": "state",
                "HAL_LOCKED": "HAL_LOCKED",
                "HAL_TIM_STATE_BUSY": "HAL_TIM_STATE_BUSY",
                "HAL_TIM_STATE_READY": "HAL_TIM_STATE_READY",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "TIM_OC1_SetConfig": "TIM_OC1_SetConfig",
                "TIM_OC2_SetConfig": "TIM_OC2_SetConfig",
                "TIM_OC3_SetConfig": "TIM_OC3_SetConfig",
                "TIM_OC4_SetConfig": "TIM_OC4_SetConfig",
                "OCFastMode": "OCFastMode",
                "Instance": "Instance"
            },
            "code": "HAL_StatusTypeDef configureTimer_08006186(TIM_HandleTypeDef *timer_handle, TIM_OC_InitTypeDef *output_config, uint32_t channel)\n{\n  if (timer_handle->lock_status != HAL_LOCKED) {\n    timer_handle->lock_status = HAL_LOCKED;\n    timer_handle->state = HAL_TIM_STATE_BUSY;\n    switch(channel) {\n        case 0:\n            TIM_OC1_SetConfig(timer_handle->Instance, output_config);\n            timer_handle->Instance->CCMR1 |= 8;\n            timer_handle->Instance->CCMR1 &= 0xfffffffb;\n            timer_handle->Instance->CCMR1 |= output_config->OCFastMode;\n            break;\n        case 4:\n            TIM_OC2_SetConfig(timer_handle->Instance, output_config);\n            timer_handle->Instance->CCMR1 |= 0x800;\n            timer_handle->Instance->CCMR1 &= 0xfffffbff;\n            timer_handle->Instance->CCMR1 |= output_config->OCFastMode << 8;\n            break;\n        case 8:\n            TIM_OC3_SetConfig(timer_handle->Instance, output_config);\n            timer_handle->Instance->CCMR2 |= 8;\n            timer_handle->Instance->CCMR2 &= 0xfffffffb;\n            timer_handle->Instance->CCMR2 |= output_config->OCFastMode;\n            break;\n        case 0xc:\n            TIM_OC4_SetConfig(timer_handle->Instance, output_config);\n            timer_handle->Instance->CCMR2 |= 0x800;\n            timer_handle->Instance->CCMR2 &= 0xfffffbff;\n            timer_handle->Instance->CCMR2 |= output_config->OCFastMode << 8;\n    }\n    timer_handle->state = HAL_TIM_STATE_READY;\n    timer_handle->lock_status = HAL_UNLOCKED;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}",
            "called": [
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC2_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006186",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "configureTimer_08006186"
        },
        "FUN_08006b7c": {
            "renaming": {
                "FUN_08006b7c": "get_gpio_type_08006b7c",
                "port_idx": "port_index",
                "DAT_08006ba4": "port0_gpio",
                "DAT_08006bb4": "port1_gpio",
                "DAT_08006ba8": "port2_gpio",
                "DAT_08006bac": "port3_gpio",
                "DAT_08006bb0": "port4_gpio"
            },
            "code": "GPIO_TypeDef* get_gpio_type_08006b7c(uint32_t port_index) {\n  switch(port_index) {\n    case 0:\n      return DAT_08006ba4;\n    case 1:\n      return DAT_08006bb4;\n    case 2:\n      return DAT_08006ba8;\n    case 3:\n      return DAT_08006bac;\n    case 4:\n      return DAT_08006bb0;\n    default:\n      return (GPIO_TypeDef*)0x0;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b7c",
            "calling": [
                "digitalRead",
                "digitalWrite"
            ],
            "imported": false,
            "current_name": "get_gpio_type_08006b7c"
        },
        "FUN_08008e7c": {
            "renaming": {
                "__thiscall Print::FUN_08008e7c": "printNumber",
                "this": "this",
                "n": "number",
                "base": "base",
                "cVar1": "digit",
                "sVar2": "length",
                "sVar3": "length",
                "uVar4": "remainder",
                "uVar5": "baseValue",
                "uVar6": "quotient",
                "__s": "currentDigit",
                "buf": "buffer",
                "FUN_08008e7c": "printNumber_08008e7c"
            },
            "code": "size_t __thiscall Print::printNumber_08008e7c(Print *this, ulong number, uint8_t base)\n{\n  char digit;\n  size_t length;\n  char buffer[33];\n  uint baseValue = (uint)base;\n  buffer[32] = '\\0';\n  if (baseValue < 2) {\n    baseValue = 10;\n  }\n  char *currentDigit = buffer + 0x20;\n  do {\n    uint quotient = number / baseValue;\n    uint remainder = (number & 0xff) - (quotient * baseValue & 0xff) & 0xff;\n    currentDigit = currentDigit - 1;\n    digit = (char)remainder;\n    if (remainder < 10) {\n      digit = digit + '0';\n    }\n    else {\n      digit = digit + '7';\n    }\n    *currentDigit = digit;\n    number = quotient;\n  } while (quotient != 0);\n  if (currentDigit == (char *)0x0) {\n    length = 0;\n  }\n  else {\n    size_t digitCount = strlen(currentDigit);\n    length = (*this->_vptr_Print[1])(digitCount, currentDigit, digitCount);\n  }\n  return length;\n}",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e7c",
            "calling": [
                "print"
            ],
            "imported": false,
            "current_name": "printNumber_08008e7c"
        },
        "FUN_0800a194": {
            "renaming": {
                "std::ctype_byname<char>::FUN_0800a194": "set_pointers_to_one",
                "FUN_0800a194": "set_pointers_to_one_0800a194"
            },
            "code": "void set_pointers_to_one_0800a194(void)\n{\n    if (-1 < *(int *)PTR_id_0800a228 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a228 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a22c << 0x1f) {\n        *(undefined4 *)PTR_id_0800a22c = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a230 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a230 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a234 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a234 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a238 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a238 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a23c << 0x1f) {\n        *(undefined4 *)PTR_id_0800a23c = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a240 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a240 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a244 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a244 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a248 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a248 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a24c << 0x1f) {\n        *(undefined4 *)PTR_id_0800a24c = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a250 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a250 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a254 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a254 = 1;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a194",
            "calling": [],
            "imported": false,
            "current_name": "set_pointers_to_one_0800a194"
        },
        "FUN_08003aa0": {
            "renaming": {
                "FUN_08003aa0": "enable_ADC_08003aa0",
                "*hadc": "*adc_handle",
                "HVar1": "status",
                "pAVar2": "adc_instance"
            },
            "code": "HAL_StatusTypeDef_conflict enable_ADC_08003aa0(ADC_HandleTypeDef *hadc)\n{\n  HAL_StatusTypeDef_conflict status;\n  ADC_TypeDef *adc_instance;\n  \n  if (hadc->Lock != HAL_LOCKED) {\n    hadc->Lock = HAL_LOCKED;\n    status = ADC_Enable(hadc);\n    if (status == HAL_OK) {\n      hadc->State = (hadc->State & 0xfffffcfe) | 0x100;\n      adc_instance = hadc->Instance;\n      if ((adc_instance == PTR_08003b84) && ((PTR_08003b84[-0xd].JOFR1 & 0xf0000) != 0)) {\n        hadc->State |= 0x100000;\n        if ((*(uint *)(PTR_08003b88 + 4) & 0x400) != 0) {\n          hadc->State = (hadc->State & 0xffffcfff) | 0x1000;\n        }\n      }\n      else {\n        hadc->State &= 0xffefffff;\n        if ((adc_instance->CR1 & 0x400) != 0) {\n          hadc->State = (hadc->State & 0xffffcfff) | 0x1000;\n        }\n      }\n      if ((hadc->State & 0x1000) == 0) {\n        hadc->ErrorCode = 0;\n      }\n      else {\n        hadc->ErrorCode &= 0xfffffff9;\n      }\n      hadc->Lock = HAL_UNLOCKED;\n      adc_instance->SR = 0xfffffffd;\n      adc_instance = hadc->Instance;\n      if (((adc_instance->CR2 & 0xe0000) == 0xe0000) && ((adc_instance != PTR_08003b84) || ((PTR_08003b84[-0xd].JOFR1 & 0xf0000) == 0))) {\n        adc_instance->CR2 |= 0x500000;\n      }\n      else {\n        adc_instance->CR2 |= 0x100000;\n      }\n    }\n    else {\n      hadc->Lock = HAL_UNLOCKED;\n    }\n    return status;\n  }\n  return HAL_BUSY;\n}",
            "called": [
                "ADC_Enable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003aa0",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "enable_ADC_08003aa0"
        },
        "FUN_08005fe8": {
            "renaming": {
                "FUN_08005fe8": "set_timer_08005fe8",
                "TIMx": "timer",
                "Structure": "config",
                "uVar1": "control_register_value",
                "DAT_0800605c": "timer1"
            },
            "code": "void set_timer_08005fe8(TIM_TypeDef_conflict *timer,TIM_Base_InitTypeDef_conflict *config)\n{\n    uint32_t control_register_value = timer->CR1;\n    \n    if ((((timer == DAT_0800605c) || (timer == (TIM_TypeDef_conflict *)0x40000000)) ||\n        (timer == (TIM_TypeDef_conflict *)&DAT_0800605c[-0x387].DMAR)) ||\n        (timer == (TIM_TypeDef_conflict *)&DAT_0800605c[-0x37A].SMCR)) {\n        control_register_value = control_register_value & 0xffffff8f | config->CounterMode;\n    }\n    if (((timer == DAT_0800605c) || (timer == (TIM_TypeDef_conflict *)0x40000000)) ||\n        ((timer == (TIM_TypeDef_conflict *)&DAT_0800605c[-0x387].DMAR ||\n        (timer == (TIM_TypeDef_conflict *)&DAT_0800605c[-0x37A].SMCR)))) {\n        control_register_value = control_register_value & 0xfffffcff | config->ClockDivision;\n    }\n    timer->CR1 = control_register_value & 0xffffff7f | config->AutoReloadPreload;\n    timer->ARR = config->Period;\n    timer->PSC = config->Prescaler;\n    if (timer == DAT_0800605c) {\n        timer->RCR = config->RepetitionCounter;\n    }\n    timer->EGR = 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005fe8",
            "calling": [
                "HAL_TIM_PWM_Init",
                "HAL_TIM_OC_Init"
            ],
            "imported": false,
            "current_name": "set_timer_08005fe8"
        },
        "FUN_08003ce8": {
            "renaming": {
                "FUN_08003ce8": "stop_and_reset_ADC_08003ce8",
                "*hadc": "*ADC_handle",
                "HVar1": "status"
            },
            "code": "HAL_StatusTypeDef_conflict stop_and_reset_ADC_08003ce8(ADC_HandleTypeDef *hadc)\n{\n  HAL_StatusTypeDef_conflict status;\n  if (hadc == NULL) {\n    status = HAL_ERROR;\n  }\n  else {\n    hadc->State |= 2;\n    status = ADC_ConversionStop_Disable(hadc);\n    if (status == HAL_OK) {\n      hadc->Instance->SR = 0xffffffe0;\n      hadc->Instance->CR1 &= DAT_08003ddc;\n      hadc->Instance->CR2 &= DAT_08003de0;\n      hadc->Instance->SMPR1 &= 0xff000000;\n      hadc->Instance->SMPR2 &= 0xc0000000;\n      hadc->Instance->JOFR1 &= 0xfffff000;\n      hadc->Instance->JOFR2 &= 0xfffff000;\n      hadc->Instance->JOFR3 &= 0xfffff000;\n      hadc->Instance->JOFR4 &= 0xfffff000;\n      hadc->Instance->HTR &= 0xfffff000;\n      hadc->Instance->LTR &= 0xfffff000;\n      hadc->Instance->SQR1 &= 0xff000000;\n      hadc->Instance->SQR2 &= 0xc0000000;\n      hadc->Instance->SQR3 &= 0xc0000000;\n      hadc->Instance->JSQR &= 0xffc00000;\n      HAL_ADC_MspDeInit(hadc);\n      hadc->ErrorCode = 0;\n      hadc->State = 0;\n    }\n    hadc->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}",
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003ce8",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "stop_and_reset_ADC_08003ce8"
        },
        "FUN_0800738a": {
            "renaming": {
                "FUN_0800738a": "is_valid_pin_0800738a",
                "pin": "pin_name",
                "map": "pin_map"
            },
            "code": "_Bool is_valid_pin_0800738a(PinName_conflict pin, PinMap_conflict *pin_map) {\n  if (pin == NC) {\n    return false;\n  }\n  while (true) {\n    if (pin_map->pin == NC) {\n      return false;\n    }\n    if (pin == pin_map->pin) {\n      break;\n    }\n    pin_map++;\n  }\n  return true;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800738a",
            "calling": [
                "enableI2CPins",
                "analogWrite",
                "pinMode",
                "sysexCallback",
                "analogWriteCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "is_valid_pin_0800738a"
        },
        "FUN_08002948": {
            "renaming": {
                "FUN_08002948": "initializeWire_08002948",
                "__initialize_p": "should_initialize",
                "__priority": "priority_level",
                "TwoWire": "Wire",
                "PTR_Wire_08002964": "Wire_pointer"
            },
            "code": "void initializeWire_08002948(int should_initialize, int priority_level) {\n                      if (should_initialize != 1) {\n                        return;\n                      }\n                      if (priority_level == 0xffff) {\n                        TwoWire::TwoWire((TwoWire *)PTR_Wire_08002964);\n                      }\n                      return;\n                  }",
            "called": [
                "TwoWire"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002948",
            "calling": [
                "_GLOBAL__sub_I__ZN7TwoWire8rxBufferE"
            ],
            "imported": false,
            "current_name": "initializeWire_08002948"
        },
        "FUN_08009e64": {
            "renaming": {
                "FUN_08009e64": "check_file_permission_08009e64",
                "param_1": "file_descriptor",
                "param_2": "file_info_ptr",
                "param_3": "result_ptr",
                "param_4": "permission_ptr",
                "iVar1": "file_stat_result",
                "uVar2": "permission",
                "auStack_4c": "permission_buffer",
                "local_48": "file_mode"
            },
            "code": "int check_file_permission_08009e64(int file_descriptor, int file_info_ptr, int* result_ptr, uint* permission_ptr) {\n    int file_stat_result;\n    uint permission = 0x400;\n    if (*(short *)(file_info_ptr + 0xe) >= 0) {\n        file_stat_result = _fstat_r(file_descriptor, (int)*(short *)(file_info_ptr + 0xe), (undefined4 *)permission_ptr);\n        if (file_stat_result >= 0) {\n            permission = (uint)((*permission_ptr & 0xf000) == 0x2000);\n        }\n    }\n    if ((int)((uint)*(ushort *)(file_info_ptr + 0xc) << 0x18) < 0) {\n        permission = 0x40;\n    }\n    *result_ptr = permission;\n    return 0;\n}",
            "called": [
                "_fstat_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009e64",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_file_permission_08009e64"
        },
        "FUN_08002acc": {
            "renaming": {
                "TwoWire::FUN_08002acc": "allocate_rx_buffer",
                "length": "buffer_length",
                "puVar1": "rx_buffer_ptr",
                "pvVar2": "new_buffer_ptr",
                "uVar3": "buffer_length_undefined",
                "PTR_rxBuffer_08002afc": "rx_buffer_ptr_global",
                "*PTR_rxBuffer_08002afc": "*(void **)rx_buffer_ptr_global",
                "PTR_rxBufferAllocated_08002af8": "rx_buffer_allocated_ptr_global",
                "*PTR_rxBufferAllocated_08002af8": "*rx_buffer_allocated_ptr_global",
                "FUN_08002acc": "allocate_rx_buffer_08002acc"
            },
            "code": "void allocate_rx_buffer_08002acc(size_t buffer_length)\n{\n  undefined *rx_buffer_ptr;\n  void *new_buffer_ptr;\n  undefined buffer_length_undefined;\n  \n  rx_buffer_ptr = PTR_rxBuffer_08002afc;\n  if ((byte)*PTR_rxBufferAllocated_08002af8 < buffer_length) {\n    if (buffer_length < 0x20) {\n      buffer_length = 0x20;\n    }\n    new_buffer_ptr = realloc(*PTR_rxBuffer_08002afc, buffer_length);\n    *(void **)rx_buffer_ptr = new_buffer_ptr;\n    if (new_buffer_ptr == (void *)0x0) {\n      buffer_length_undefined = 0;\n    }\n    else {\n      buffer_length_undefined = (undefined)buffer_length;\n    }\n    *PTR_rxBufferAllocated_08002af8 = buffer_length_undefined;\n  }\n  return;\n}",
            "called": [
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002acc",
            "calling": [
                "requestFrom",
                "onReceiveService"
            ],
            "imported": false,
            "current_name": "allocate_rx_buffer_08002acc"
        },
        "FUN_0800932c": {
            "renaming": {
                "FUN_0800932c": "write_buffer_to_stream_0800932c",
                "param_1": "stream",
                "param_2": "character",
                "param_3": "buffer_ptr",
                "uVar1": "result",
                "pbVar2": "end_of_buffer",
                "param_3[2]": "*buffer_ptr",
                "param_3[6]": "(*buffer_ptr + 6)",
                "*param_3": "buffer",
                "*pbVar2": "character"
            },
            "code": "uint write_buffer_to_stream_0800932c(undefined4 stream, byte character, byte **buffer_ptr)\n{\n  uint result;\n  byte *end_of_buffer = (*buffer_ptr + -1);\n  *buffer_ptr = end_of_buffer;\n  if (((int)end_of_buffer < 0) && (((int)end_of_buffer < (int)(*buffer_ptr + 6) || (character == 10)))) {\n    result = __swbuf_r();\n    return result;\n  }\n  byte *buffer = *buffer_ptr;\n  *buffer_ptr = buffer + 1;\n  *buffer = character;\n  return (uint)character;\n}",
            "called": [
                "__swbuf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800932c",
            "calling": [
                "__sfputs_r"
            ],
            "imported": false,
            "current_name": "write_buffer_to_stream_0800932c"
        },
        "FUN_080099a4": {
            "renaming": {
                "FUN_080099a4": "find_substring_080099a4",
                "__haystack": "string",
                "__needle": "substring",
                "pcVar1": "string_ptr",
                "pcVar2": "match_ptr",
                "pcVar3": "substring_ptr"
            },
            "code": "char* find_substring_080099a4(char* string, char* substring) {\n    char* string_ptr;\n    char* substring_ptr;\n    char* match_ptr;\n    \n    if (*string == \"\\0\") {\n        if (*substring != \"\\0\") {\n            string = NULL;\n        }\n        return string;\n    }\n    \n    do {\n        string_ptr = string;\n        if (*string_ptr == \"\\0\") {\n            return NULL;\n        }\n        match_ptr = string_ptr;\n        substring_ptr = substring;\n        do {\n            substring_ptr++;\n            if (*substring_ptr == \"\\0\") {\n                return string_ptr;\n            }\n            match_ptr++;\n            string = string_ptr + 1;\n        } while (*match_ptr == *substring_ptr);\n    } while (true);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080099a4",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "find_substring_080099a4"
        },
        "FUN_08005a1c": {
            "renaming": {
                "FUN_08005a1c": "getSystemCoreClock_08005a1c",
                "PTR_SystemCoreClock_08005a24": "systemCoreClockPtr"
            },
            "code": "uint32_t getSystemCoreClock_08005a1c(void)\n{\n  uint32_t* PTR_SystemCoreClock_08005a24 = (uint32_t*) PTR_SystemCoreClock_08005a24;\n  return *PTR_SystemCoreClock_08005a24;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a1c",
            "calling": [
                "HAL_RCC_GetPCLK1Freq",
                "SystemClock_Config",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "imported": false,
            "current_name": "getSystemCoreClock_08005a1c"
        },
        "FUN_08006b0c": {
            "renaming": {
                "FUN_08006b0c": "reset_uart_transfer_counts_08006b0c",
                "hdma": "dma_handle",
                "huart": "uart_handle",
                "RxXferCount": "receive_transfer_count",
                "TxXferCount": "transmit_transfer_count",
                "HAL_UART_ErrorCallback": "handle_uart_error_callback",
                "Parent": "parent"
            },
            "code": "void reset_uart_transfer_counts_08006b0c(DMA_HandleTypeDef_conflict *dma_handle)\n{\n  UART_HandleTypeDef *uart_handle;\n  uart_handle = (UART_HandleTypeDef *)dma_handle->Parent;\n  uart_handle->RxXferCount = 0;\n  uart_handle->TxXferCount = 0;\n  HAL_UART_ErrorCallback(uart_handle);\n  return;\n}",
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b0c",
            "calling": [],
            "imported": false,
            "current_name": "reset_uart_transfer_counts_08006b0c"
        },
        "FUN_08001cd0": {
            "renaming": {
                "FUN_08001cd0": "FUNC_08001cd0"
            },
            "code": "\nvoid FUNC_08001cd0(byte command,byte argc,byte *argv)\n\n{\n  byte bVar1;\n  uint8_t address;\n  byte bVar2;\n  byte bVar3;\n  byte bVar4;\n  byte bVar5;\n  char cVar6;\n  undefined *puVar7;\n  undefined *this;\n  PinName_conflict PVar8;\n  _Bool _Var9;\n  byte bVar10;\n  uint32_t uVar11;\n  uint uVar12;\n  int iVar13;\n  int iVar14;\n  char cVar15;\n  uint uVar16;\n  int iVar17;\n  bool bVar18;\n  \n  this = PTR_Firmata_080022e8;\n  puVar7 = PTR_Firmata_08002044;\n  uVar16 = (uint)argc;\n  switch(command) {\n  case 'i':\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf0);\n    firmata::FirmataClass::write((FirmataClass *)this,'j');\n    for (uVar16 = 0; uVar16 < 0x3c; uVar16 = uVar16 + 1 & 0xff) {\n      uVar12 = uVar16 - 0x2e & 0xff;\n      bVar10 = (byte)uVar12;\n      if (uVar12 < 0xe) {\n        if (uVar16 < 0x3c) {\n          PVar8 = PTR_digitalPin_080022e4[uVar16];\n        }\n        else {\n          PVar8 = NC;\n        }\n        uVar11 = pinNametoDigitalPin(PVar8);\n        if (uVar11 == 0) {\n          bVar10 = '\\x7f';\n        }\n        else {\n          if (uVar16 < 0x3c) {\n            PVar8 = PTR_digitalPin_080022e4[uVar16];\n          }\n          else {\n            PVar8 = NC;\n          }\n          uVar11 = pinNametoDigitalPin(PVar8);\n          if (uVar11 == 1) {\n            bVar10 = '\\x7f';\n          }\n        }\n      }\n      else {\n        bVar10 = '\\x7f';\n      }\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,bVar10);\n    }\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf7);\n    break;\n  case 'k':\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_08002044,0xf0);\n    firmata::FirmataClass::write((FirmataClass *)puVar7,'l');\n    for (uVar16 = 0; uVar16 < 0x3c; uVar16 = uVar16 + 1 & 0xff) {\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          bVar18 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            bVar18 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_08002060[uVar16]);\n            if (uVar11 == 1) {\n              bVar18 = false;\n            }\n            else {\n              bVar18 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      puVar7 = PTR_Firmata_08002044;\n      if (bVar18) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_08002044,'\\0');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\v');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n      }\n      if ((uVar16 - 0x2e & 0xff) < 0xe) {\n        if (uVar16 < 0x3c) {\n          PVar8 = PTR_digitalPin_08002060[uVar16];\n        }\n        else {\n          PVar8 = NC;\n        }\n        uVar11 = pinNametoDigitalPin(PVar8);\n        if (uVar11 == 0) {\n          bVar18 = false;\n        }\n        else {\n          if (uVar16 < 0x3c) {\n            PVar8 = PTR_digitalPin_08002060[uVar16];\n          }\n          else {\n            PVar8 = NC;\n          }\n          uVar11 = pinNametoDigitalPin(PVar8);\n          if (uVar11 == 1) {\n            bVar18 = false;\n          }\n          else {\n            bVar18 = true;\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (bVar18) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x02');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\n');\n      }\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          _Var9 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            _Var9 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n            if (uVar11 == 1) {\n              _Var9 = false;\n            }\n            else {\n              _Var9 = pin_in_pinmap(PTR_digitalPin_080022e4[uVar16],\n                                    (PinMap_conflict *)PTR_PinMap_PWM_080022ec);\n            }\n          }\n        }\n      }\n      else {\n        _Var9 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (_Var9 != false) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x03');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\b');\n      }\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          bVar18 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            bVar18 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n            if (uVar11 == 1) {\n              bVar18 = false;\n            }\n            else {\n              bVar18 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (bVar18) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x04');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x0e');\n      }\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_080022e4[uVar16] == NC) {\n          _Var9 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n          if (uVar11 == 0) {\n            _Var9 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_080022e4[uVar16]);\n            if (uVar11 == 1) {\n              _Var9 = false;\n            }\n            else {\n              _Var9 = pin_in_pinmap(PTR_digitalPin_080022e4[uVar16],\n                                    (PinMap_conflict *)PTR_PinMap_I2C_SDA_080022f0);\n              if (!_Var9) {\n                _Var9 = pin_in_pinmap(PTR_digitalPin_080022e4[uVar16],\n                                      (PinMap_conflict *)PTR_PinMap_I2C_SCL_080022f4);\n              }\n            }\n          }\n        }\n      }\n      else {\n        _Var9 = false;\n      }\n      puVar7 = PTR_Firmata_080022e8;\n      if (_Var9 != false) {\n        firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x06');\n        firmata::FirmataClass::write((FirmataClass *)puVar7,'\\x01');\n      }\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,'\\x7f');\n    }\n    firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf7);\n    return;\n  case 'm':\n    if (uVar16 != 0) {\n      bVar1 = *argv;\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf0);\n      firmata::FirmataClass::write((FirmataClass *)this,'n');\n      firmata::FirmataClass::write((FirmataClass *)this,bVar1);\n      if (bVar1 < 0x3c) {\n        bVar10 = firmata::FirmataClass::getPinMode((FirmataClass *)this,bVar1);\n        firmata::FirmataClass::write((FirmataClass *)this,bVar10);\n        iVar13 = firmata::FirmataClass::getPinState((FirmataClass *)this,bVar1);\n        firmata::FirmataClass::write((FirmataClass *)this,(byte)iVar13 & 0x7f);\n        uVar16 = firmata::FirmataClass::getPinState((FirmataClass *)this,bVar1);\n        if ((uVar16 & 0xff80) != 0) {\n          iVar13 = firmata::FirmataClass::getPinState((FirmataClass *)this,bVar1);\n          firmata::FirmataClass::write((FirmataClass *)this,(byte)((uint)(iVar13 << 0x12) >> 0x19));\n        }\n        uVar16 = firmata::FirmataClass::getPinState((FirmataClass *)PTR_Firmata_080022e8,bVar1);\n        puVar7 = PTR_Firmata_080022e8;\n        if ((uVar16 & 0xc000) != 0) {\n          iVar13 = firmata::FirmataClass::getPinState((FirmataClass *)PTR_Firmata_080022e8,bVar1);\n          firmata::FirmataClass::write((FirmataClass *)puVar7,(byte)((uint)(iVar13 << 0xb) >> 0x19))\n          ;\n        }\n      }\n      firmata::FirmataClass::write((FirmataClass *)PTR_Firmata_080022e8,0xf7);\n      return;\n    }\n    break;\n  case 'o':\n    if (1 < uVar16) {\n      uVar12 = (uint)argv[1];\n      if (2 < uVar16) {\n        uVar12 = uVar12 | (uint)argv[2] << 7;\n      }\n      if (3 < uVar16) {\n        uVar12 = uVar12 | (uint)argv[3] << 0xe;\n      }\n      analogWriteCallback(*argv,uVar12);\n      return;\n    }\n    break;\n  case 'p':\n    if (4 < uVar16) {\n      bVar1 = *argv;\n      uVar16 = (uint)bVar1;\n      bVar2 = argv[1];\n      bVar3 = argv[2];\n      bVar4 = argv[3];\n      bVar5 = argv[4];\n      if (uVar16 < 0x3c) {\n        if (PTR_digitalPin_08002060[uVar16] == NC) {\n          bVar18 = false;\n        }\n        else {\n          uVar11 = pinNametoDigitalPin(PTR_digitalPin_08002060[uVar16]);\n          if (uVar11 == 0) {\n            bVar18 = false;\n          }\n          else {\n            uVar11 = pinNametoDigitalPin(PTR_digitalPin_08002060[uVar16]);\n            if (uVar11 == 1) {\n              bVar18 = false;\n            }\n            else {\n              bVar18 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar18 = false;\n      }\n      if (bVar18) {\n        if ((byte)PTR_servoPinMap_08002064[uVar16] < 0xc) {\n          bVar18 = Servo::attached((Servo *)(PTR_servos_08002068 +\n                                            (uint)(byte)PTR_servoPinMap_08002064[uVar16] * 3));\n        }\n        else {\n          bVar18 = false;\n        }\n        if (bVar18 != false) {\n          detachServo(bVar1);\n        }\n        attachServo(bVar1,(uint)bVar2 + (uint)bVar3 * 0x80,(uint)bVar4 + (uint)bVar5 * 0x80);\n        setPinModeCallback(bVar1,4);\n        return;\n      }\n    }\n    break;\n  case 'v':\n    bVar1 = argv[1];\n    if ((bVar1 & 0x20) != 0) {\n      firmata::FirmataClass::sendString\n                ((FirmataClass *)PTR_Firmata_08002044,PTR_s_10_bit_addressing_not_supported_08002040\n                );\n      return;\n    }\n    address = *argv;\n    bVar18 = (bVar1 & 0x40) == 0;\n    if ((bVar1 & 0x18) < 0x19) {\n      switch(bVar1 & 0x18) {\n      case 0:\n        TwoWire::beginTransmission((TwoWire *)PTR_Wire_08002048,address);\n        for (uVar12 = 2; uVar12 < uVar16; uVar12 = uVar12 + 2 & 0xff) {\n          wireWrite(argv[uVar12 + 1] * -0x80 + argv[uVar12]);\n        }\n        TwoWire::endTransmission((TwoWire *)PTR_Wire_08002048);\n        return;\n      case 8:\n        if (uVar16 == 6) {\n          iVar13 = (uint)argv[2] + (uint)argv[3] * 0x80;\n          bVar10 = argv[4] + argv[5] * -0x80;\n        }\n        else {\n          bVar10 = argv[2] + argv[3] * -0x80;\n          iVar13 = -1;\n        }\n        readAndReportData(address,iVar13,bVar10,bVar18);\n        return;\n      case 0x10:\n        if ((char)*PTR_queryIndex_0800204c + 1 < 8) {\n          if (uVar16 == 6) {\n            iVar13 = (uint)argv[2] + (uint)argv[3] * 0x80;\n            cVar15 = argv[4] + argv[5] * -0x80;\n          }\n          else {\n            cVar15 = argv[2] + argv[3] * -0x80;\n            iVar13 = -1;\n          }\n          cVar6 = *PTR_queryIndex_0800204c + '\\x01';\n          *PTR_queryIndex_0800204c = cVar6;\n          puVar7 = PTR_query_08002050;\n          iVar14 = cVar6 * 0xc;\n          PTR_query_08002050[iVar14] = address;\n          *(int *)(puVar7 + iVar14 + 4) = iVar13;\n          puVar7[iVar14 + 8] = cVar15;\n          puVar7[iVar14 + 9] = bVar18;\n          return;\n        }\n        firmata::FirmataClass::sendString\n                  ((FirmataClass *)PTR_Firmata_08002044,PTR_s_too_many_queries_08002054);\n        return;\n      case 0x18:\n        cVar15 = *PTR_queryIndex_0800204c;\n        if (cVar15 < 1) {\n          *PTR_queryIndex_0800204c = 0xff;\n          return;\n        }\n      }\n      for (uVar16 = 0; iVar13 = cVar15 + 1, (int)uVar16 < iVar13; uVar16 = uVar16 + 1 & 0xff) {\n        if (address == PTR_query_08002050[uVar16 * 0xc]) goto LAB_08001e66;\n      }\n      uVar16 = 0;\nLAB_08001e66:\n      for (; puVar7 = PTR_query_08002050, (int)uVar16 < iVar13; uVar16 = uVar16 + 1 & 0xff) {\n        if (uVar16 < 8) {\n          iVar14 = (uVar16 + 1) * 0xc;\n          iVar17 = uVar16 * 0xc;\n          PTR_query_08002050[iVar17] = PTR_query_08002050[iVar14];\n          *(undefined4 *)(puVar7 + iVar17 + 4) = *(undefined4 *)(puVar7 + iVar14 + 4);\n          puVar7[iVar17 + 8] = puVar7[iVar14 + 8];\n          puVar7[iVar17 + 9] = puVar7[iVar14 + 9];\n        }\n      }\n      *PTR_queryIndex_0800204c = cVar15 + -1;\n      return;\n    }\n    break;\n  case 'x':\n    iVar13 = (uint)*argv + (uint)argv[1] * 0x80;\n    if ((1 < uVar16) && (iVar13 != 0)) {\n      *(int *)PTR_i2cReadDelayTime_08002058 = iVar13;\n    }\n    if (*PTR_isI2CEnabled_0800205c == '\\0') {\n      enableI2CPins();\n      return;\n    }\n    break;\n  case 'z':\n    if ((1 < uVar16) &&\n       (iVar13 = (uint)*argv + (uint)argv[1] * 0x80, *(int *)PTR_samplingInterval_0800206c = iVar13,\n       iVar13 == 0)) {\n      *(undefined4 *)PTR_samplingInterval_0800206c = 1;\n      return;\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "enableI2CPins",
                "attached",
                "pin_in_pinmap",
                "beginTransmission",
                "pinNametoDigitalPin",
                "wireWrite",
                "sendString",
                "write",
                "endTransmission",
                "attachServo",
                "getPinState",
                "detachServo",
                "getPinMode",
                "readAndReportData",
                "analogWriteCallback",
                "setPinModeCallback"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08001cd0",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_08001cd0"
        },
        "FUN_08007320": {
            "renaming": {
                "FUN_08007320": "find_peripheral_08007320",
                "pin": "pin_name",
                "map": "pin_map",
                "pvVar1": "peripheral"
            },
            "code": "void * find_peripheral_08007320(PinName_conflict pin, PinMap_conflict *pin_map) {\n  void *peripheral;\n  if (pin != NC) {\n    peripheral = pinmap_find_peripheral_08007320(pin, pin_map);\n    return peripheral;\n  }\n  return (void *)0x0;\n}",
            "called": [
                "pinmap_find_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007320",
            "calling": [
                "pwm_stop",
                "uart_debug_init",
                "pwm_start",
                "uart_init",
                "adc_read_value",
                "i2c_custom_init",
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "find_peripheral_08007320"
        },
        "FUN_080002ec": {
            "renaming": {
                "FUN_080002ec": "setPortValue_080002ec",
                "port": "portIndex",
                "value": "portValue",
                "bVar1": "isPinValid",
                "bVar2": "pinModeValue",
                "uVar3": "portIndex",
                "uVar4": "digitalPin",
                "iVar5": "pinState",
                "pin": "pinIndex",
                "ulPin": "pinIndex",
                "ulPin_00": "inputPinStartIndex",
                "uVar6": "pinValue",
                "uVar7": "outputPinStartIndex",
                "uVar8": "outputPinsMask",
                "PTR_digitalPin_08000480": "digitalPinName",
                "PTR_Firmata_08000484": "Firmata",
                "NC": "NC"
            },
            "code": "void setPortValue_080002ec(byte port, int value) {\n  bool isPinValid;\n  byte pinIndex;\n  byte pin;\n  uint32_t pinMask;\n  uint32_t outputPinsMask = 0;\n  uint32_t inputPinsMask = 0;\n  uint32_t portIndex = (uint)port;\n  if (portIndex < 5) {\n    uint32_t outputPinStartIndex = (portIndex + 1) * 8;\n    if (outputPinStartIndex > 60) {\n      outputPinStartIndex = 60;\n    }\n    uint32_t inputPinStartIndex = portIndex * 8;\n    for (uint32_t pinIndex = inputPinStartIndex; pinIndex < outputPinStartIndex; pinIndex++) {\n      if (pinIndex < 60) {\n        if (PTR_digitalPin_08000480[pinIndex] == NC) {\n          isPinValid = false;\n        }\n        else {\n          uint32_t digitalPin = pinNametoDigitalPin(PTR_digitalPin_08000480[pinIndex]);\n          if (digitalPin == 0 || digitalPin == 1) {\n            isPinValid = false;\n          }\n          else {\n            isPinValid = true;\n          }\n        }\n      }\n      else {\n        isPinValid = false;\n      }\n      if (isPinValid) {\n        pin = (byte)pinIndex;\n        byte pinModeValue = PTR_Firmata_08000484.getPinMode(pin);\n        if (pinModeValue != INPUT && pinModeValue != INPUT_PULLUP) {\n          isPinValid = false;\n        }\n        if (isPinValid) {\n          uint32_t pinValue = (uint32_t)((1 << (pinIndex - inputPinStartIndex)) & value);\n          if (pinModeValue == INPUT_PULLUP) {\n            outputPinsMask |= (1 << (pinIndex - inputPinStartIndex));\n          }\n          else if (pinModeValue == INPUT) {\n            if (pinValue != 0) {\n              int pinState = PTR_Firmata_08000484.getPinState(pin);\n              if (pinState == 1) {\n                isPinValid = false;\n              }\n            }\n            else {\n              isPinValid = false;\n            }\n            if (isPinValid) {\n              pinMode(pinIndex, OUTPUT);\n              outputPinsMask |= (1 << (pinIndex - inputPinStartIndex));\n            }\n          }\n          PTR_Firmata_08000484.setPinState(pin, pinValue);\n        }\n      }\n      inputPinsMask |= (1 << (pinIndex - inputPinStartIndex));\n    }\n    for (uint32_t i = 0; i < 8; i++) {\n      if ((outputPinsMask & (1 << i)) != 0) {\n        digitalWrite(inputPinStartIndex + i, (value & (1 << i)) != 0);\n      }\n    }\n  }\n}",
            "called": [
                "digitalWrite",
                "pinNametoDigitalPin",
                "setPinState",
                "pinMode",
                "getPinState",
                "getPinMode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080002ec",
            "calling": [],
            "imported": false,
            "current_name": "setPortValue_080002ec"
        },
        "FUN_08000be8": {
            "renaming": {
                "FUN_08000be8": "sendDigitalPortIfChanged_08000be8",
                "portNumber": "portNumber",
                "portValue": "portValue",
                "forceSend": "forceSend",
                "PTR_portConfigInputs_08000c0c": "portConfigInputs",
                "PTR_previousPINs_08000c10": "previousPINs",
                "PTR_Firmata_08000c14": "Firmata"
            },
            "code": "void sendDigitalPortIfChanged_08000be8(byte portNumber, byte portValue, byte forceSend) {\n  byte inputConfig = PTR_portConfigInputs_08000c0c[portNumber];\n  byte maskedValue = inputConfig & portValue;\n  if (forceSend || (PTR_previousPINs_08000c10[portNumber] != maskedValue)) {\n    PTR_Firmata_08000c14.sendDigitalPort(portNumber, maskedValue);\n    PTR_previousPINs_08000c10[portNumber] = maskedValue;\n  }\n  return;\n}",
            "called": [
                "sendDigitalPort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000be8",
            "calling": [
                "checkDigitalInputs",
                "reportDigitalCallback"
            ],
            "imported": false,
            "current_name": "sendDigitalPortIfChanged_08000be8"
        },
        "FUN_08003fd8": {
            "renaming": {
                "FUN_08003fd8": "calculate_ticks_08003fd8",
                "TicksNumb": "ticks_number",
                "puVar1": "ticks_pointer",
                "DAT_08003ffc": "ticks_data",
                "DAT_08004000": "memory_address"
            },
            "code": "uint32_t calculate_ticks_08003fd8(uint32_t ticks_number) {\n  undefined4 *ticks_pointer;\n  ticks_pointer = DAT_08003ffc;\n  if (ticks_number - 1 < 0x1000000) {\n    DAT_08003ffc[1] = ticks_number - 1;\n    *(undefined *)(DAT_08004000 + 0x23) = 0xf0;\n    ticks_pointer[2] = 0;\n    *ticks_pointer = 7;\n    return 0;\n  }\n  return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fd8",
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "calculate_ticks_08003fd8"
        },
        "FUN_0800307a": {
            "renaming": {
                "FUN_0800307a": "encodeAndSend_0800307a",
                "this": "marshaller",
                "bytec": "numBytes",
                "bytev": "byteArray",
                "max_bytes": "maxBytes",
                "uVar1": "currentByte",
                "uVar2": "bitIndex",
                "uVar3": "encodedByte",
                "uVar4": "byteIndex"
            },
            "code": "void __thiscall FirmataMarshaller::encodeAndSend_0800307a(FirmataMarshaller *this,size_t numBytes,uint8_t *byteArray,size_t maxBytes){\n    uint currentByte = (uint)*byteArray;\n    if (maxBytes == 0) {\n        maxBytes = 0xffffffff;\n    }\n    uint byteIndex = 0;\n    uint bitIndex = 0;\n    uint encodedByte = 0;\n    while ((byteIndex < numBytes) && (bitIndex < maxBytes)) {\n        (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream,((uint)byteArray[byteIndex] << (bitIndex & 0xff) | currentByte) & 0x7f);\n        currentByte = (int)(uint)byteArray[byteIndex] >> (7 - bitIndex & 0xff) & 0xff;\n        bitIndex++;\n        while ((encodedByte = encodedByte + 1, 6 < bitIndex && (encodedByte < maxBytes))) {\n            (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream,currentByte & 0x7f);\n            currentByte = currentByte >> 7;\n            bitIndex = bitIndex - 7;\n        }\n        byteIndex++;\n    }\n    if ((bitIndex != 0) && (encodedByte < maxBytes)) {\n        (**(this->FirmataStream->super_Print)._vptr_Print)(this->FirmataStream,(1 << (bitIndex & 0xff)) - 1U & currentByte);\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800307a",
            "calling": [
                "sendExtendedAnalog",
                "sendSysex",
                "sendFirmwareVersion",
                "sendDigitalPort",
                "sendAnalog"
            ],
            "imported": false,
            "current_name": "encodeAndSend_0800307a"
        },
        "FUN_08004b80": {
            "renaming": {
                "FUN_08004b80": "do_nothing_08004b80"
            },
            "code": "\nvoid do_nothing_08004b80(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004b80",
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004b80"
        },
        "FUN_08002ca4": {
            "renaming": {
                "FUN_08002ca4": "sendStringCallback_08002ca4",
                "param_1": "callback",
                "c_str": "message",
                "PTR_currentStringCallback_08002cb4": "currentStringCallback"
            },
            "code": "void firmata::FirmataClass::sendStringCallback_08002ca4(void *callback, char *message) {\n  if (*(code **)PTR_currentStringCallback_08002cb4 != (code *)0x0) {\n    (**(code **)PTR_currentStringCallback_08002cb4)(message);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ca4",
            "calling": [],
            "imported": false,
            "current_name": "sendStringCallback_08002ca4"
        },
        "FUN_0800319e": {
            "renaming": {
                "FUN_0800319e": "sendPortData_0800319e",
                "this": "marshaller",
                "portNumber": "portNumber",
                "portData": "portData",
                "local_a": "encodedPortData",
                "FirmataStream": "firmataStream",
                "_vptr_Print": "_vptr_Print",
                "encodeByteStream": "encodeByteStream"
            },
            "code": "void __thiscall firmata::FirmataMarshaller::sendPortData_0800319e(FirmataMarshaller *marshaller, uint8_t portNumber, uint16_t portData)\n{\n  uint16_t encodedPortData;\n  if (marshaller->firmataStream != (Stream *)0x0) {\n    encodedPortData = portData;\n    (**(marshaller->firmataStream->super_Print)._vptr_Print)(marshaller, portNumber & 0xf | 0x90);\n    encodeByteStream(marshaller, 2, (uint8_t *)&encodedPortData, 2);\n  }\n  return;\n}",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800319e",
            "calling": [
                "sendDigitalPort"
            ],
            "imported": false,
            "current_name": "sendPortData_0800319e"
        },
        "FUN_08008d00": {
            "renaming": {
                "FUN_08008d00": "setRxPin_08008d00",
                "this": "serial",
                "_rx": "pinIndex",
                "PVar1": "pin",
                "PTR_digitalPin_08008d14": "digitalPinMapping"
            },
            "code": "void __thiscall HardwareSerial::setRxPin_08008d00(HardwareSerial *serial, uint32_t pinIndex) {\n  PinName pin;\n  if (pinIndex < 0x3c) {\n    pin = PTR_digitalPin_08008d14[pinIndex];\n  }\n  else {\n    pin = NC;\n  }\n  (serial->_serial).pin_rx = pin;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d00",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "setRxPin_08008d00"
        },
        "FUN_08004b82": {
            "renaming": {
                "FUN_08004b82": "i2c_transfer_08004b82",
                "hi2c": "i2c_handle",
                "HVar1": "current_state",
                "pbVar2": "data_ptr",
                "uVar3": "options"
            },
            "code": "HAL_StatusTypeDef_conflict i2c_transfer_08004b82(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  HAL_I2C_StateTypeDef_conflict current_state;\n  byte *data_ptr;\n  uint32_t options;\n\n  current_state = i2c_handle->State;\n  options = i2c_handle->XferOptions;\n\n  if ((i2c_handle->XferSize == 0) && (current_state == HAL_I2C_STATE_BUSY_TX)) {\n    if ((options == 4) || ((options == 8 || (options == 0xffff0000)))) {\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffff8ff;\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x200;\n      i2c_handle->PreviousState = 0;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      if (i2c_handle->Mode == HAL_I2C_MODE_MEM) {\n        i2c_handle->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(i2c_handle);\n      }\n      else {\n        i2c_handle->Mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(i2c_handle);\n      }\n    }\n    else {\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffff8ff;\n      i2c_handle->PreviousState = 0x11;\n      i2c_handle->Mode = HAL_I2C_MODE_NONE;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(i2c_handle);\n    }\n  }\n  else if ((current_state == HAL_I2C_STATE_BUSY_TX) ||\n          ((i2c_handle->Mode == HAL_I2C_MODE_MEM && (current_state == HAL_I2C_STATE_BUSY_RX)))) {\n    if (i2c_handle->XferCount == 0) {\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffffbff;\n    }\n    else if (i2c_handle->Mode == HAL_I2C_MODE_MEM) {\n      if (i2c_handle->EventCount == 0) {\n        if (i2c_handle->MemaddSize == 1) {\n          i2c_handle->Instance->DR = i2c_handle->Memaddress & 0xff;\n          i2c_handle->EventCount = i2c_handle->EventCount + 2;\n        }\n        else {\n          i2c_handle->Instance->DR = (i2c_handle->Memaddress << 0x10) >> 0x18;\n          i2c_handle->EventCount = i2c_handle->EventCount + 1;\n        }\n      }\n      else if (i2c_handle->EventCount == 1) {\n        i2c_handle->Instance->DR = i2c_handle->Memaddress & 0xff;\n        i2c_handle->EventCount = i2c_handle->EventCount + 1;\n      }\n      else if (i2c_handle->EventCount == 2) {\n        if (current_state == HAL_I2C_STATE_BUSY_RX) {\n          i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x100;\n        }\n        else if (current_state == HAL_I2C_STATE_BUSY_TX) {\n          data_ptr = i2c_handle->pBuffPtr;\n          i2c_handle->pBuffPtr = data_ptr + 1;\n          i2c_handle->Instance->DR = (uint)*data_ptr;\n          i2c_handle->XferCount = i2c_handle->XferCount - 1;\n        }\n      }\n    }\n    else {\n      data_ptr = i2c_handle->pBuffPtr;\n      i2c_handle->pBuffPtr = data_ptr + 1;\n      i2c_handle->Instance->DR = (uint)*data_ptr;\n      i2c_handle->XferCount = i2c_handle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MasterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004b82",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_transfer_08004b82"
        },
        "FUN_0800997e": {
            "renaming": {
                "FUN_0800997e": "find_last_occurrence_0800997e",
                "__s": "string",
                "__c": "character",
                "pcVar1": "occurrence",
                "pcVar2": "last_occurrence"
            },
            "code": "char* find_last_occurrence_0800997e(char* string, int character) {\n  char* last_occurrence = NULL;\n  if (character != 0) {\n    while (char* occurrence = strchr(string, character)) {\n      last_occurrence = occurrence;\n      string = occurrence + 1;\n    }\n    return last_occurrence;\n  }\n  return strchr(string, 0);\n}",
            "called": [
                "strchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800997e",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "find_last_occurrence_0800997e"
        },
        "FUN_0800779c": {
            "renaming": {
                "FUN_0800779c": "handle_timer_interrupt_0800779c",
                "PTR_timer_handles_080077ac": "PTR_timer_handles",
                "TIM_HandleTypeDef_conflict": "TimerHandle",
                "timer_handle": "current_timer_handle"
            },
            "code": "void handle_timer_interrupt_0800779c(void)\n{\n    TIM_HandleTypeDef_conflict* timer_handle = *(TIM_HandleTypeDef_conflict**)(PTR_timer_handles_080077ac_080077ac + 0xc);\n    if (timer_handle != NULL)\n    {\n        HAL_TIM_IRQHandler(timer_handle);\n    }\n    return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800779c",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_0800779c"
        },
        "FUN_08002dbc": {
            "renaming": {
                "FUN_08002dbc": "initializeFirmata_08002dbc",
                "__initialize_p": "shouldInitialize",
                "__priority": "priority",
                "PTR_Firmata_08002dd8": "PTR_Firmata_08002dd8",
                "firmata::FirmataClass::FirmataClass": "FirmataClass",
                "FirmataClass": "firmataInstance"
            },
            "code": "void initializeFirmata_08002dbc(int shouldInitialize, int priority) {\n  if (shouldInitialize != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    FirmataClass firmataInstance(PTR_Firmata_08002dd8);\n  }\n  return;\n}",
            "called": [
                "FirmataClass"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002dbc",
            "calling": [
                "_GLOBAL__sub_I_Firmata"
            ],
            "imported": false,
            "current_name": "initializeFirmata_08002dbc"
        },
        "FUN_08007f78": {
            "renaming": {
                "FUN_08007f78": "i2c_handle_to_i2c_t_conflict_08007f78",
                "hi2c": "i2c_handle",
                "i2c_t_conflict": "i2c_struct",
                "EventCount": "event_count"
            },
            "code": "i2c_t_conflict* i2c_handle_to_i2c_t_conflict_08007f78(I2C_HandleTypeDef_conflict* i2c_handle) {\n    return (i2c_t_conflict*) &i2c_handle[-1].EventCount;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f78",
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_AddrCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "imported": false,
            "current_name": "i2c_handle_to_i2c_t_conflict_08007f78"
        },
        "FUN_08006b28": {
            "renaming": {
                "FUN_08006b28": "is_pin_high_08006b28",
                "pin": "pin_name",
                "map": "pin_map"
            },
            "code": "_Bool is_pin_high_08006b28(PinName_conflict pin, uint32_t *pin_map) {\n    uint32_t shifted_pin = (uint32_t)pin << 24;\n    uint32_t index = shifted_pin >> 28;\n    uint32_t bit_shift = (uint32_t)pin & 0xF;\n    uint32_t shifted_value = pin_map[index] >> bit_shift;\n    return (_Bool)(shifted_value & 1);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b28",
            "calling": [
                "digitalRead",
                "digitalWrite",
                "analogWrite",
                "pinMode"
            ],
            "imported": false,
            "current_name": "is_pin_high_08006b28"
        },
        "FUN_08006b1c": {
            "renaming": {
                "FUN_08006b1c": "get_uart_rx_and_g_state_08006b1c",
                "*huart": "*uart_handle",
                "huart": "uart_handle",
                "RxState": "rx_state",
                "gState": "g_state",
                "HAL_UART_StateTypeDef": "HAL_UART_StateTypeDef"
            },
            "code": "HAL_UART_StateTypeDef get_uart_rx_and_g_state_08006b1c(UART_HandleTypeDef *uart_handle)\n{\n  HAL_UART_StateTypeDef rx_state = uart_handle->RxState;\n  HAL_UART_StateTypeDef g_state = uart_handle->gState;\n  return rx_state | g_state;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b1c",
            "calling": [
                "serial_tx_active",
                "serial_rx_active"
            ],
            "imported": false,
            "current_name": "get_uart_rx_and_g_state_08006b1c"
        },
        "FUN_0800a130": {
            "renaming": {
                "FUN_0800a130": "seek_file_0800a130",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "offset",
                "param_4": "whence",
                "puVar1": "error_ptr",
                "iVar2": "seek_result"
            },
            "code": "void seek_file_0800a130(int *error_code, int file_descriptor, int offset, int whence)\n{\n  undefined *error_ptr;\n  int seek_result;\n  \n  error_ptr = PTR_errno_0800a150;\n  *(undefined4 *)PTR_errno_0800a150 = 0;\n  seek_result = _lseek(file_descriptor, offset, whence);\n  if ((seek_result == -1) && (*(int *)error_ptr != 0)) {\n    *error_code = *(int *)error_ptr;\n  }\n  return;\n}",
            "called": [
                "_lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a130",
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "imported": false,
            "current_name": "seek_file_0800a130"
        },
        "FUN_08008f3c": {
            "renaming": {
                "FUN_08008f3c": "count_bits_set_08008f3c",
                "pin": "input_pin",
                "uVar1": "bit_shifted_pin",
                "uVar2": "bit_count"
            },
            "code": "uint8_t count_bits_set_08008f3c(uint16_t input_pin) {\n  uint16_t pin = input_pin;\n  uint8_t bit_count = 0;\n  while (pin != 1) {\n    bit_count++;\n    pin = pin >> 1;\n  }\n  return bit_count;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f3c",
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "imported": false,
            "current_name": "count_bits_set_08008f3c"
        },
        "FUN_08002ef2": {
            "renaming": {
                "FUN_08002ef2": "sendPinValue_08002ef2",
                "pin": "pin",
                "value": "value",
                "FirmataMarshaller::FUN_08002ef2": "sendPinValue",
                "this": "this",
                "&this->marshaller": "&this->marshaller"
            },
            "code": "void __thiscall firmata::FirmataClass::sendPinValue_08002ef2(FirmataClass *this, byte pin, int value)\n{\n  FirmataMarshaller::sendPinValue_08002ef2(&this->marshaller, pin, (uint16_t)value);\n  return;\n}",
            "called": [
                "sendAnalog"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ef2",
            "calling": [
                "reportAnalogCallback",
                "loop"
            ],
            "imported": false,
            "current_name": "sendPinValue_08002ef2"
        },
        "FUN_08007332": {
            "renaming": {
                "FUN_08007332": "find_pin_for_peripheral_08007332",
                "PinName_conflict": "PinName",
                "*peripheral": "void *peripheral",
                "PinMap_conflict": "PinMap",
                "*map": "PinMap *map_array"
            },
            "code": "PinName find_pin_for_peripheral_08007332(void *peripheral, PinMap *map_array) {\n  while (true) {\n    if (map_array->peripheral == NULL) {\n      return NC;\n    }\n    if (map_array->peripheral == peripheral) {\n      break;\n    }\n    map_array++;\n  }\n  return map_array->pin;\n}",
            "called": [
                "pinmap_find_pin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007332",
            "calling": [
                "pinmap_pin",
                "pinmap_find_pin"
            ],
            "imported": false,
            "current_name": "find_pin_for_peripheral_08007332"
        },
        "FUN_08006128": {
            "renaming": {
                "FUN_08006128": "configure_TIM_oc_08006128",
                "htim": "timer_handle",
                "sConfig": "oc_config",
                "Channel": "channel",
                "HAL_LOCKED": "HAL_LOCKED",
                "HAL_TIM_STATE_BUSY": "HAL_TIM_STATE_BUSY",
                "HAL_TIM_STATE_READY": "HAL_TIM_STATE_READY",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "TIM_OC1_SetConfig": "TIM_OC1_SetConfig",
                "TIM_OC2_SetConfig": "TIM_OC2_SetConfig",
                "TIM_OC3_SetConfig": "TIM_OC3_SetConfig",
                "TIM_OC4_SetConfig": "TIM_OC4_SetConfig"
            },
            "code": "HAL_StatusTypeDef configure_TIM_oc_08006128(TIM_HandleTypeDef *timer_handle, TIM_OC_InitTypeDef *oc_config, uint32_t channel) {\\n\\\n    if (timer_handle->Lock != HAL_LOCKED) {\\n\\\n        timer_handle->Lock = HAL_LOCKED;\\n\\\n        timer_handle->State = HAL_TIM_STATE_BUSY;\\n\\\n        switch(channel) {\\n\\\n            case 0:\\n\\\n                TIM_OC1_SetConfig(timer_handle->Instance, oc_config);\\n\\\n                break;\\n\\\n            case 4:\\n\\\n                TIM_OC2_SetConfig(timer_handle->Instance, oc_config);\\n\\\n                break;\\n\\\n            case 8:\\n\\\n                TIM_OC3_SetConfig(timer_handle->Instance, oc_config);\\n\\\n                break;\\n\\\n            case 0xc:\\n\\\n                TIM_OC4_SetConfig(timer_handle->Instance, oc_config);\\n\\\n                break;\\n\\\n        }\\n\\\n        timer_handle->State = HAL_TIM_STATE_READY;\\n\\\n        timer_handle->Lock = HAL_UNLOCKED;\\n\\\n        return HAL_OK;\\n\\\n    }\\n\\\n    return HAL_BUSY;\\n\\\n}",
            "called": [
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC2_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006128",
            "calling": [
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "configure_TIM_oc_08006128"
        },
        "FUN_0800a258": {
            "renaming": {
                "std::ctype_byname<wchar_t>::FUN_0800a258": "set_flags",
                "PTR_id_0800a2ec": "id_0800a2ec",
                "PTR_id_0800a2f0": "id_0800a2f0",
                "PTR_id_0800a2f4": "id_0800a2f4",
                "PTR_id_0800a2f8": "id_0800a2f8",
                "PTR_id_0800a2fc": "id_0800a2fc",
                "PTR_id_0800a300": "id_0800a300",
                "PTR_id_0800a304": "id_0800a304",
                "PTR_id_0800a308": "id_0800a308",
                "PTR_id_0800a30c": "id_0800a30c",
                "PTR_id_0800a310": "id_0800a310",
                "PTR_id_0800a314": "id_0800a314",
                "PTR_id_0800a318": "id_0800a318",
                "FUN_0800a258": "set_flags_0800a258"
            },
            "code": "void set_flags_0800a258() {\n  if (PTR_id_0800a2ec < 0) {\n    *(int *)PTR_PTR_id_0800a2ec = 1;\n  }\n  if (PTR_id_0800a2f0 < 0) {\n    *(int *)PTR_PTR_id_0800a2f0 = 1;\n  }\n  if (PTR_id_0800a2f4 < 0) {\n    *(int *)PTR_PTR_id_0800a2f4 = 1;\n  }\n  if (PTR_id_0800a2f8 < 0) {\n    *(int *)PTR_PTR_id_0800a2f8 = 1;\n  }\n  if (PTR_id_0800a2fc < 0) {\n    *(int *)PTR_PTR_id_0800a2fc = 1;\n  }\n  if (PTR_id_0800a300 < 0) {\n    *(int *)PTR_PTR_id_0800a300 = 1;\n  }\n  if (PTR_id_0800a304 < 0) {\n    *(int *)PTR_PTR_id_0800a304 = 1;\n  }\n  if (PTR_id_0800a308 < 0) {\n    *(int *)PTR_PTR_id_0800a308 = 1;\n  }\n  if (PTR_id_0800a30c < 0) {\n    *(int *)PTR_PTR_id_0800a30c = 1;\n  }\n  if (PTR_id_0800a310 < 0) {\n    *(int *)PTR_PTR_id_0800a310 = 1;\n  }\n  if (PTR_id_0800a314 < 0) {\n    *(int *)PTR_PTR_id_0800a314 = 1;\n  }\n  if (PTR_id_0800a318 < 0) {\n    *(int *)PTR_PTR_id_0800a318 = 1;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a258",
            "calling": [],
            "imported": false,
            "current_name": "set_flags_0800a258"
        },
        "FUN_08002cb8": {
            "renaming": {
                "FUN_08002cb8": "handleSysex_08002cb8",
                "param_1": "sysexData",
                "PTR_currentSysexCallback_08002ccc": "currentSysexCallback",
                "command": "command",
                "argc": "argc",
                "argv": "argv"
            },
            "code": "void firmata::FirmataClass::handleSysex_08002cb8(void *sysexData, uint8_t command, size_t argc, uint8_t *argv) {\n  if (*(code **)PTR_currentSysexCallback_08002ccc != (code *)0x0) {\n    (**(code **)PTR_currentSysexCallback_08002ccc)(command, argc & 0xff, argv, argv, argv);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002cb8",
            "calling": [],
            "imported": false,
            "current_name": "handleSysex_08002cb8"
        },
        "FUN_08004a74": {
            "renaming": {
                "FUN_08004a74": "do_nothing_08004a74"
            },
            "code": "\nvoid do_nothing_08004a74(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a74",
            "calling": [
                "I2C_SlaveReceive_RXNE",
                "I2C_Slave_STOPF"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a74"
        },
        "FUN_08008f50": {
            "renaming": {
                "FUN_08008f50": "free_gpio_irq_configuration_08008f50",
                "param_1": "list_start",
                "puVar1": "current_node",
                "puVar2": "previous_node"
            },
            "code": "void free_gpio_irq_configuration_08008f50(void *list_start) {\n  \n  undefined *current_node = PTR___malloc_free_list_08008f70;\n  while (current_node != PTR_gpio_irq_conf_08008f74) {\n    undefined *previous_node = current_node - 0x14;\n    if (*(code **)(current_node - 8) != (code *)0x0) {\n      (**(code **)(current_node - 8))(current_node - 0x10, current_node - 0x10, 3);\n    }\n    current_node = previous_node;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f50",
            "calling": [],
            "imported": false,
            "current_name": "free_gpio_irq_configuration_08008f50"
        },
        "FUN_08004a76": {
            "renaming": {
                "FUN_08004a76": "transferData_08004a76",
                "hi2c": "i2c_handle",
                "HVar1": "i2c_state",
                "puVar2": "buffer_ptr",
                "XferCount": "TransferCount",
                "pBuffPtr": "BufferPtr",
                "Instance": "i2c_handle->Instance",
                "HAL_I2C_STATE_BUSY_RX_LISTEN": "HAL_I2C_STATE_BUSY_RX_LISTEN",
                "PreviousState": "PreviousState",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_STATE_LISTEN",
                "HAL_I2C_SlaveRxCpltCallback": "HAL_I2C_SlaveRxCpltCallback"
            },
            "code": "HAL_StatusTypeDef_conflict transferData_08004a76(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  HAL_I2C_StateTypeDef_conflict i2c_state;\n  uint8_t *buffer_ptr;\n  i2c_state = i2c_handle->State;\n  if (i2c_handle->TransferCount != 0) {\n    buffer_ptr = i2c_handle->BufferPtr;\n    i2c_handle->BufferPtr = buffer_ptr + 1;\n    *buffer_ptr = (uint8_t)i2c_handle->Instance->DR;\n    i2c_handle->TransferCount = i2c_handle->TransferCount - 1;\n    if ((i2c_handle->TransferCount == 0) && (i2c_state == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 & 0xfffffbff;\n      i2c_handle->PreviousState = 0x22;\n      i2c_handle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveRxCpltCallback(i2c_handle);\n    }\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a76",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "transferData_08004a76"
        },
        "FUN_0800877c": {
            "renaming": {
                "FUN_0800877c": "initialize_uart_0800877c",
                "huart": "uart_handle",
                "tmpval": "tmp_value"
            },
            "code": "void initialize_uart_0800877c(UART_HandleTypeDef *uart_handle)\n{\n  uint32_t tmp_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800877c",
            "calling": [
                "HAL_UART_IRQHandler",
                "UART_DMAAbortOnError"
            ],
            "imported": false,
            "current_name": "initialize_uart_0800877c"
        },
        "FUN_080047f4": {
            "renaming": {
                "FUN_080047f4": "check_i2c_status_080047f4",
                "hi2c": "i2c_handle",
                "DevAddress": "device_address",
                "pData": "data",
                "Size": "size",
                "HVar1": "status",
                "pIVar2": "i2c_instance",
                "count": "count",
                "clock_cycle_divider": "DAT_080048c0",
                "system_clock_ptr": "PTR_SystemCoreClock_080048bc",
                "transfer_option": "DAT_080048c4"
            },
            "code": "HAL_StatusTypeDef_conflict check_i2c_status_080047f4(I2C_HandleTypeDef_conflict *i2c_handle, uint16_t device_address, uint8_t *data, uint16_t size)\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *i2c_instance;\n  uint32_t count;\n  \n  if (i2c_handle->State == HAL_I2C_STATE_READY) {\n    count = (uint)((ulonglong)clock_cycle_divider * (ulonglong)(*(uint *)system_clock_ptr >> 3) >> 0x28) * 0x19;\n    do {\n      if (count == 0) {\n        i2c_handle->PreviousState = 0;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        i2c_handle->Lock = HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      i2c_instance = i2c_handle->Instance;\n      count = count - 1;\n    } while ((i2c_instance->SR2 & 2) != 0);\n    if (i2c_handle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2c_handle->Lock = HAL_LOCKED;\n      if ((i2c_instance->CR1 & 1) == 0) {\n        i2c_instance->CR1 = i2c_instance->CR1 | 1;\n      }\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffff7ff;\n      i2c_handle->State = HAL_I2C_STATE_BUSY_RX;\n      i2c_handle->Mode = HAL_I2C_MODE_MASTER;\n      status = HAL_OK;\n      i2c_handle->ErrorCode = 0;\n      i2c_handle->pBuffPtr = data;\n      i2c_handle->XferCount = size;\n      i2c_handle->XferOptions = transfer_option;\n      i2c_handle->XferSize = i2c_handle->XferCount;\n      i2c_handle->Devaddress = (uint)device_address;\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x400;\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 | 0x100;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080047f4",
            "calling": [
                "i2c_master_read"
            ],
            "imported": false,
            "current_name": "check_i2c_status_080047f4"
        },
        "FUN_08005a48": {
            "renaming": {
                "FUN_08005a48": "get_HCLK_frequency_08005a48",
                "PTR_APBPrescTable_08005a64": "prescaler_table",
                "DAT_08005a60": "data_pointer"
            },
            "code": "uint32_t get_HCLK_frequency_08005a48(void)\n{\n  uint32_t frequency = HAL_RCC_GetHCLKFreq();\n  uint32_t prescaler_index = (uint)(*(int *)(DAT_08005a60 + 4) << 0x12) >> 0x1d;\n  uint32_t prescaler_value = PTR_APBPrescTable_08005a64[prescaler_index];\n  return frequency >> prescaler_value;\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a48",
            "calling": [
                "HAL_RCCEx_GetPeriphCLKFreq",
                "getTimerClkFreq",
                "UART_SetConfig"
            ],
            "imported": false,
            "current_name": "get_HCLK_frequency_08005a48"
        },
        "FUN_080033a8": {
            "renaming": {
                "FUN_080033a8": "parseFirmataMessage_080033a8",
                "this": "parserInstance",
                "bytec": "messageLength",
                "bytev": "messageBytes",
                "bVar1": "firstByte",
                "sVar2": "outputLength",
                "uVar3": "i"
            },
            "code": "size_t __thiscall firmata::FirmataParser::parseFirmataMessage_080033a8(FirmataParser *this, size_t messageLength, uint8_t *messageBytes)\n{\n  size_t outputLength = 0;\n  for (uint i = 0; i < messageLength; i += 2) {\n    uint8_t firstByte = messageBytes[i];\n    uint8_t secondByte = messageBytes[i + 1];\n    messageBytes[outputLength] = firstByte;\n    messageBytes[outputLength] = (secondByte << 7) | firstByte;\n    outputLength++;\n  }\n  return outputLength;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080033a8",
            "calling": [
                "processSysexMessage"
            ],
            "imported": false,
            "current_name": "parseFirmataMessage_080033a8"
        },
        "FUN_08008d18": {
            "renaming": {
                "FUN_08008d18": "set_tx_pin_08008d18",
                "_tx": "tx_pin",
                "PVar1": "pin",
                "PTR_digitalPin_08008d2c": "digitalPin"
            },
            "code": "void __thiscall HardwareSerial::set_tx_pin_08008d18(HardwareSerial *this,uint32_t tx_pin)\n{\n  PinName pin;\n  if (tx_pin < 0x3c) {\n    pin = PTR_digitalPin_08008d2c[tx_pin];\n  }\n  else {\n    pin = NC;\n  }\n  (this->_serial).pin_tx = pin;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d18",
            "calling": [
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "set_tx_pin_08008d18"
        },
        "FUN_0800a020": {
            "renaming": {
                "FUN_0800a020": "read_and_update_data_0800a020",
                "param_1": "file_descriptor",
                "param_2": "data_address",
                "iVar1": "read_result",
                "uVar2": "updated_data_address",
                "bVar3": "is_read_successful"
            },
            "code": "void read_and_update_data_0800a020(undefined4 file_descriptor,int data_address)\n{\n  int read_result;\n  uint updated_data_address;\n  bool is_read_successful;\n  \n  read_result = _read_r(file_descriptor, (int)*(short *)(data_address + 0xe));\n  is_read_successful = read_result >= 0;\n  if (is_read_successful) {\n    updated_data_address = *(int *)(data_address + 0x54) + read_result;\n  }\n  else {\n    updated_data_address = *(ushort *)(data_address + 0xc) & 0xffffefff;\n  }\n  if (is_read_successful) {\n    *(uint *)(data_address + 0x54) = updated_data_address;\n  }\n  if (!is_read_successful) {\n    *(short *)(data_address + 0xc) = (short)updated_data_address;\n  }\n  return;\n}",
            "called": [
                "_read_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a020",
            "calling": [],
            "imported": false,
            "current_name": "read_and_update_data_0800a020"
        },
        "FUN_08007f7c": {
            "renaming": {
                "FUN_08007f7c": "set_on_slave_receive_callback_08007f7c",
                "obj": "i2c_obj",
                "function": "callback_func",
                "i2c_t_conflict": "i2c_obj",
                "_func_void_uint8_t_ptr_int": "callback_func",
                "i2c_onSlaveReceive": "callback_func",
                "HAL_I2C_EnableListen_IT": "enable_i2c_listen_interrupt",
                "handle": "i2c_handle"
            },
            "code": "void set_on_slave_receive_callback_08007f7c(i2c_t_conflict *i2c_obj, _func_void_uint8_t_ptr_int *callback_func) {\n  if (i2c_obj != NULL && callback_func != NULL) {\n    i2c_obj->i2c_onSlaveReceive = callback_func;\n    HAL_I2C_EnableListen_IT(&i2c_obj->handle);\n  }\n}",
            "called": [
                "HAL_I2C_EnableListen_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f7c",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "set_on_slave_receive_callback_08007f7c"
        },
        "FUN_08006d80": {
            "renaming": {
                "FUN_08006d80": "readADC_08006d80",
                "pin": "pin",
                "HVar1": "status",
                "uVar2": "rawValue",
                "uhADCxConvertedValue": "convertedValue",
                "AdcChannelConf": "channelConfig",
                "AdcHandle": "adcHandle",
                "PTR_PinMap_ADC_08006e60": "PTR_PinMap_ADC",
                "AdcHandle.Instance": "adcHandle.Instance",
                "ADC_TypeDef": "ADC",
                "PTR_g_current_pin_08006e64": "g_currentPin",
                "HAL_ADC_Init": "HAL_ADC_Init",
                "get_adc_channel": "getADCChannel",
                "HAL_ADC_ConfigChannel": "HAL_ADC_ConfigChannel",
                "HAL_ADCEx_Calibration_Start": "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Start": "HAL_ADC_Start",
                "HAL_ADC_PollForConversion": "HAL_ADC_PollForConversion",
                "HAL_ADC_GetState": "HAL_ADC_GetState",
                "ADC_FLAG_EOC": "ADC_FLAG_EOC",
                "HAL_ADC_GetValue": "HAL_ADC_GetValue",
                "HAL_ADC_Stop": "HAL_ADC_Stop",
                "HAL_ADC_DeInit": "HAL_ADC_DeInit"
            },
            "code": "uint16_t readADC_08006d80(PinName_conflict pin)\n{\n    HAL_StatusTypeDef_conflict status;\n    uint32_t rawValue;\n    uint16_t convertedValue = 0;\n    ADC_ChannelConfTypeDef channelConfig;\n    ADC_HandleTypeDef adcHandle;\n    memset(&adcHandle, 0, sizeof(adcHandle));\n    channelConfig.Channel = 0;\n    channelConfig.Rank = 0;\n    channelConfig.SamplingTime = 0;\n    adcHandle.Instance = (ADC_TypeDef *)pinmap_peripheral(pin, (PinMap_conflict *)PTR_PinMap_ADC_08006e60_08006e60);\n    if (adcHandle.Instance == (ADC_TypeDef *)0x0) {\n        convertedValue = 0;\n    }\n    else {\n        adcHandle.Init.DataAlign = ADC_DATAALIGN_RIGHT;\n        adcHandle.Init.ScanConvMode = DISABLE;\n        adcHandle.Init.ContinuousConvMode = DISABLE;\n        adcHandle.Init.DiscontinuousConvMode = DISABLE;\n        adcHandle.Init.ExternalTrigConv = ADC_SOFTWARE_START;\n        adcHandle.State = 0;\n        adcHandle.Init.NbrOfConversion = 1;\n        adcHandle.Init.NbrOfDiscConversion = 0;\n        *PTR_g_current_pin_08006e64 = pin;\n        status = HAL_ADC_Init(&adcHandle);\n        if (status == HAL_OK) {\n            channelConfig.Channel = getADCChannel(pin);\n            if (channelConfig.Channel < 0x12) {\n                channelConfig.Rank = 1;\n                channelConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;\n                status = HAL_ADC_ConfigChannel(&adcHandle, &channelConfig);\n                if (status == HAL_OK) {\n                    status = HAL_ADCEx_Calibration_Start(&adcHandle);\n                    if (status == HAL_OK) {\n                        status = HAL_ADC_Start(&adcHandle);\n                        if (status == HAL_OK) {\n                            status = HAL_ADC_PollForConversion(&adcHandle, 10);\n                            if (status == HAL_OK) {\n                                uint32_t state = HAL_ADC_GetState(&adcHandle);\n                                if ((state & ADC_FLAG_EOC) != 0) {\n                                    rawValue = HAL_ADC_GetValue(&adcHandle);\n                                    convertedValue = (uint16_t)rawValue;\n                                }\n                                status = HAL_ADC_Stop(&adcHandle);\n                                if (status != HAL_OK) {\n                                    convertedValue = 0;\n                                }\n                            }\n                            else {\n                                convertedValue = 0;\n                            }\n                        }\n                        else {\n                            convertedValue = 0;\n                        }\n                    }\n                    else {\n                        convertedValue = 0;\n                    }\n                }\n                else {\n                    convertedValue = 0;\n                }\n            }\n            else {\n                convertedValue = 0;\n            }\n            status = HAL_ADC_DeInit(&adcHandle);\n        }\n        else {\n            convertedValue = 0;\n        }\n    }\n    return convertedValue;\n}",
            "called": [
                "get_adc_channel",
                "memset",
                "HAL_ADC_Init",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_PollForConversion",
                "HAL_ADC_Stop",
                "HAL_ADC_GetState",
                "pinmap_peripheral",
                "HAL_ADC_DeInit",
                "HAL_ADC_ConfigChannel",
                "HAL_ADC_GetValue",
                "HAL_ADC_Start"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d80",
            "calling": [
                "analogRead"
            ],
            "imported": false,
            "current_name": "readADC_08006d80"
        },
        "FUN_08006c60": {
            "renaming": {
                "FUN_08006c60": "get_adc_channel_08006c60",
                "pin": "adc_pin",
                "uVar1": "function_mapping_result",
                "PTR_PinMap_ADC_08006c78": "PTR_PinMap_ADC_08006c78",
                "uVar2": "shifted_result"
            },
            "code": "uint32_t get_adc_channel_08006c60(PinName_conflict adc_pin)\n{\n  uint32_t function_mapping_result;\n  function_mapping_result = pinmap_function(adc_pin, (PinMap_conflict *)PTR_PinMap_ADC_08006c78);\n  uint32_t shifted_result = (function_mapping_result << 12) >> 27;\n  if (shifted_result > 0x10) {\n    shifted_result = 0;\n  }\n  return shifted_result;\n}",
            "called": [
                "pinmap_function"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006c60",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "get_adc_channel_08006c60"
        },
        "FUN_08008e40": {
            "renaming": {
                "FUN_08008e40": "initialize_static_variables_08008e40"
            },
            "code": "void initialize_static_variables_08008e40(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e40",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_08008e40"
        },
        "FUN_080045c0": {
            "renaming": {
                "FUN_080045c0": "configureI2C_080045c0",
                "*hi2c": "*handle",
                "hi2c": "handle",
                "bVar1": "isClockSpeedValid",
                "uVar2": "pclk1Freq",
                "uVar3": "trise",
                "uVar4": "ccr",
                "uVar5": "dutyCycle"
            },
            "code": "HAL_StatusTypeDef configureI2C_080045c0(I2C_HandleTypeDef *handle)\n{\n  bool isClockSpeedValid;\n  uint32_t pclk1Freq, trise, ccr, uVar;\n  uint32_t clockSpeed = handle->Init.ClockSpeed;\n\n  if (handle == NULL) {\n    return HAL_ERROR;\n  }\n  if (handle->State == HAL_I2C_STATE_RESET) {\n    handle->Lock = HAL_UNLOCKED;\n    HAL_I2C_MspInit(handle);\n  }\n  handle->State = HAL_I2C_STATE_BUSY;\n  handle->Instance->CR1 &= ~(1U);\n  pclk1Freq = HAL_RCC_GetPCLK1Freq();\n  if (DAT_08004714 < clockSpeed) {\n    isClockSpeedValid = pclk1Freq <= DAT_08004720;\n  }\n  else if (DAT_08004718 < pclk1Freq) {\n    isClockSpeedValid = false;\n  }\n  else {\n    isClockSpeedValid = true;\n  }\n  if (isClockSpeedValid) {\n    return HAL_ERROR;\n  }\n  trise = (uint)((ulonglong)DAT_0800471c * (ulonglong)pclk1Freq >> 0x32);\n  handle->Instance->CR2 = trise;\n  if (DAT_08004714 < clockSpeed) {\n    trise = (uint)((ulonglong)DAT_08004724 * (ulonglong)(trise * 300) >> 0x26);\n  }\n  handle->Instance->TRISE = trise + 1;\n  if (DAT_08004714 < clockSpeed) {\n    uint32_t dutyCycle = handle->Init.DutyCycle;\n    if (dutyCycle == 0) {\n      uVar = count_leading_zeroes((pclk1Freq - 1) / (clockSpeed * 3) + 1 & 0xfff);\n      ccr = (pclk1Freq - 1) / (clockSpeed * 3) + 1 & 0xfff | 0x8000;\n    }\n    else {\n      uVar = count_leading_zeroes((pclk1Freq - 1) / (clockSpeed * 0x19) + 1 & 0xfff);\n      ccr = (pclk1Freq - 1) / (clockSpeed * 0x19) + 1 & 0xfff | 0xc000;\n    }\n    if (uVar >> 5 == 0) {\n      handle->Instance->CCR = ccr;\n    }\n    else {\n      handle->Instance->CCR = 1;\n    }\n  }\n  else {\n    ccr = (pclk1Freq - 1) / (clockSpeed << 1) + 1 & 0xfff;\n    if (ccr < 4) {\n      ccr = 4;\n    }\n    handle->Instance->CCR = ccr;\n  }\n  handle->Instance->CR1 = handle->Init.GeneralCallMode | handle->Init.NoStretchMode | 1U;\n  handle->Instance->OAR1 = handle->Init.AddressingMode | handle->Init.OwnAddress1;\n  handle->Instance->OAR2 = handle->Init.DualAddressMode | handle->Init.OwnAddress2;\n  handle->ErrorCode = 0;\n  handle->State = HAL_I2C_STATE_READY;\n  handle->PreviousState = 0;\n  handle->Mode = HAL_I2C_MODE_NONE;\n  return HAL_OK;\n}",
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_I2C_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080045c0",
            "calling": [
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "configureI2C_080045c0"
        },
        "FUN_08007e74": {
            "renaming": {
                "FUN_08007e74": "check_i2c_status_08007e74",
                "*obj": "i2c_obj",
                "dev_address": "dev_address",
                "*data": "data",
                "size": "size",
                "HAL_I2C_StateTypeDef_conflict": "HAL_I2C_StateTypeDef",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "uVar3": "start_time",
                "uVar4": "i2c_error",
                "uVar5": "time_elapsed",
                "iVar6": "status",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "*hi2c": "hi2c",
                "HVar1": "i2c_state",
                "HVar2": "i2c_status"
            },
            "code": "i2c_status_e check_i2c_status_08007e74(i2c_t *i2c_obj, uint8_t dev_address, uint8_t *data, uint16_t size)\n{\n  HAL_I2C_StateTypeDef i2c_state;\n  HAL_StatusTypeDef i2c_status;\n  uint32_t start_time = HAL_GetTick();\n  uint32_t time_elapsed = 0;\n  i2c_status_e status = I2C_ERROR;\n  I2C_HandleTypeDef *hi2c;\n  do {\n    hi2c = &i2c_obj->handle;\n    i2c_status = HAL_I2C_Master_Transmit_IT(hi2c, (uint16_t)dev_address, data, size);\n    if (i2c_status == HAL_OK) {\n      status = I2C_OK;\n      while ((i2c_state = HAL_I2C_GetState(hi2c), i2c_state != HAL_I2C_STATE_READY && (status == I2C_OK))) {\n        uint32_t current_time = HAL_GetTick();\n        time_elapsed = current_time - start_time;\n        if (time_elapsed < 0x65) {\n          uint32_t i2c_error = HAL_I2C_GetError(hi2c);\n          if (i2c_error != 0) {\n            status = I2C_ERROR;\n          }\n        }\n        else {\n          status = I2C_TIMEOUT;\n        }\n      }\n    }\n    uint32_t i2c_error = HAL_I2C_GetError(hi2c);\n  } while ((i2c_error == 4) && (time_elapsed < 100));\n  return status;\n}",
            "called": [
                "HAL_GetTick",
                "HAL_I2C_Master_Transmit_IT",
                "HAL_I2C_GetState",
                "HAL_I2C_GetError"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007e74",
            "calling": [
                "endTransmission"
            ],
            "imported": false,
            "current_name": "check_i2c_status_08007e74"
        },
        "FUN_08002efe": {
            "renaming": {
                "FirmataClass::FUN_08002efe": "sendPortDataToMarshaller",
                "portNumber": "portNumber",
                "portData": "portData",
                "FirmataMarshaller::FUN_08002efe": "sendPortData",
                "FUN_08002efe": "sendPortDataToMarshaller_08002efe"
            },
            "code": "void __thiscall firmata::FirmataClass::sendPortDataToMarshaller_08002efe(FirmataClass *this, byte portNumber, int portData)\n{\n  FirmataMarshaller::sendPortData(&this->marshaller, portNumber, (uint16_t)portData);\n  return;\n}",
            "called": [
                "sendDigitalPort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002efe",
            "calling": [
                "outputPort"
            ],
            "imported": false,
            "current_name": "sendPortDataToMarshaller_08002efe"
        },
        "FUN_08002ddc": {
            "renaming": {
                "FUN_08002ddc": "sendFirmwareVersion_08002ddc",
                "this": "firmataInstance",
                "&this->marshaller": "&firmataInstance->marshaller",
                "'\\x02'": "2",
                "'\\x05'": "5"
            },
            "code": "void __thiscall firmata::FirmataClass::sendFirmwareVersion_08002ddc(FirmataClass *firmataInstance) {\n  FirmataMarshaller::sendVersion(&firmataInstance->marshaller, 2, 5);\n  return;\n}",
            "called": [
                "sendVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ddc",
            "calling": [
                "staticReportVersionCallback",
                "begin"
            ],
            "imported": false,
            "current_name": "sendFirmwareVersion_08002ddc"
        },
        "FUN_08009f2c": {
            "renaming": {
                "FUN_08009f2c": "find_byte_in_memory_08009f2c",
                "__s": "memory",
                "__c": "byte_to_find",
                "__n": "memory_size",
                "pbVar1": "current_byte",
                "pbVar2": "current_byte_checked"
            },
            "code": "void* find_byte_in_memory_08009f2c(void* memory, int byte_to_find, size_t memory_size) {\n  unsigned char* current_byte = (unsigned char*)memory;\n  while (current_byte != (unsigned char*)(memory_size + (int)memory)) {\n    if (*current_byte == (byte_to_find & 0xffU)) {\n      return current_byte;\n    }\n    current_byte++;\n  }\n  return NULL;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f2c",
            "calling": [
                "_vfiprintf_r",
                "_printf_i"
            ],
            "imported": false,
            "current_name": "find_byte_in_memory_08009f2c"
        },
        "FUN_0800a154": {
            "renaming": {
                "FUN_0800a154": "calculate_value_0800a154",
                "param_1": "previous_value",
                "param_2": "data_array",
                "iVar1": "current_index"
            },
            "code": "int calculate_value_0800a154(int previous_value, int* data_array) {\n  int current_index = previous_value - 4;\n  if (previous_value < 0) {\n    current_index += data_array[current_index];\n  }\n  return current_index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a154",
            "calling": [
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "calculate_value_0800a154"
        },
        "FUN_08007f8e": {
            "renaming": {
                "FUN_08007f8e": "set_i2c_slave_transmit_callback_08007f8e",
                "obj": "i2c_conflict_obj",
                "function": "callback_func",
                "i2c_onSlaveTransmit": "callback_func_ptr",
                "HAL_I2C_EnableListen_IT": "enable_i2c_listen_interrupt",
                "handle": "i2c_handle"
            },
            "code": "void set_i2c_slave_transmit_callback_08007f8e(i2c_t_conflict *i2c_conflict_obj, _func_void *callback_func) {\n  if (i2c_conflict_obj != NULL && callback_func != NULL) {\n    i2c_conflict_obj->i2c_onSlaveTransmit = callback_func;\n    HAL_I2C_EnableListen_IT(&(i2c_conflict_obj->handle));\n  }\n}",
            "called": [
                "HAL_I2C_EnableListen_IT"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f8e",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "set_i2c_slave_transmit_callback_08007f8e"
        },
        "FUN_08006b3e": {
            "renaming": {
                "FUN_08006b3e": "set_pin_map_08006b3e",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "pin_index"
            },
            "code": "void set_pin_map_08006b3e(PinName_conflict pin, uint32_t *pin_map) {\n  uint32_t pin_index = ((uint32_t)pin << 0x18) >> 0x1c;\n  pin_map[pin_index] |= 1 << ((uint32_t)pin & 0xfU);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006b3e",
            "calling": [
                "analogWrite",
                "pinMode"
            ],
            "imported": false,
            "current_name": "set_pin_map_08006b3e"
        },
        "FUN_08006262": {
            "renaming": {
                "FUN_08006262": "set_Channel_State_08006262",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "channel_state",
                "CCER": "channel_control_register",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void set_Channel_State_08006262(TIM_TypeDef_conflict *timer, uint32_t channel, uint32_t channel_state)\n{\n  uint32_t channel_mask = 1 << (channel & 0xff);\n  timer->CCER = (timer->CCER & ~channel_mask) | (channel_state << (channel & 0xff));\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006262",
            "calling": [
                "HAL_TIM_PWM_Stop",
                "HAL_TIM_OC_Stop_IT",
                "HAL_TIM_OC_Start_IT",
                "HAL_TIM_PWM_Start"
            ],
            "imported": false,
            "current_name": "set_Channel_State_08006262"
        },
        "FUN_08007110": {
            "renaming": {
                "FUN_08007110": "disable_timer_clock_08007110",
                "htim": "timer_handle"
            },
            "code": "void disable_timer_clock_08007110(TIM_HandleTypeDef_conflict *timer_handle)\n{\n    timer_disable_clock(timer_handle);\n    return;\n}",
            "called": [
                "timer_disable_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007110",
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "imported": false,
            "current_name": "disable_timer_clock_08007110"
        },
        "FUN_08007594": {
            "renaming": {
                "FUN_08007594": "get_timer_instance_type_08007594",
                "tim": "timer",
                "DAT_080075d0": "original_timer_instance",
                "DAT_080075d4": "second_timer_instance",
                "PTR_s_TIM__Unknown_timer_instance_080075d8": "unknown_timer_instance_message"
            },
            "code": "uint8_t get_timer_instance_type_08007594(TIM_TypeDef_conflict *timer) {\\n  if (timer == (TIM_TypeDef_conflict *)0xffffffff) {\\n    return \"\\0\";\\n  }\\n  if (timer == DAT_080075d0) {\\n    return \"\\x01\";\\n  }\\n  if (DAT_080075d0 < timer) {\\n    if (timer == DAT_080075d4) {\\n      return \"\\x01\";\\n    }\\n    if (timer == (TIM_TypeDef_conflict *)&DAT_080075d4[0x379].DMAR) {\\n      return \"\\x02\";\\n    }\\n  }\\n  else if (timer == (TIM_TypeDef_conflict *)0x40000000) {\\n    return \"\\x01\";\\n  }\\n  iprintf(PTR_s_TIM__Unknown_timer_instance_080075d8);\\n  return \"\\0\";\\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007594",
            "calling": [
                "getTimerClkFreq"
            ],
            "imported": false,
            "current_name": "get_timer_instance_type_08007594"
        },
        "FUN_08002cd0": {
            "renaming": {
                "FUN_08002cd0": "system_reset_callback_08002cd0",
                "param_1": "callback_function_ptr",
                "PTR_currentSystemResetCallback_08002cdc": "current_system_reset_callback_ptr",
                "code": "function_pointer"
            },
            "code": "void firmata::FirmataClass::system_reset_callback_08002cd0(void *callback_function_ptr) {\n  if (*(code **)PTR_currentSystemResetCallback_08002cdc != (code *)0x0) {\n    (**(code **)PTR_currentSystemResetCallback_08002cdc)();\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002cd0",
            "calling": [],
            "imported": false,
            "current_name": "system_reset_callback_08002cd0"
        },
        "FUN_08002df6": {
            "renaming": {
                "FUN_08002df6": "sendFirmwareVersionIfPresent_08002df6",
                "this": "firmataInstance",
                "puVar1": "firmwareVersions",
                "firmwareVersionCount": "firmwareVersionCount",
                "FirmataMarshaller::sendFirmwareVersion": "FirmataMarshaller::sendFirmwareVersion",
                "&this->marshaller": "&firmataInstance->marshaller"
            },
            "code": "void __thiscall firmata::FirmataClass::sendFirmwareVersionIfPresent_08002df6(FirmataClass *firmataInstance)\n{\n    uint8_t *firmwareVersions = firmataInstance->firmwareVersionVector;\n    uint8_t firmwareVersionCount = firmataInstance->firmwareVersionCount;\n\n    if (firmwareVersionCount > 0) {\n        FirmataMarshaller::sendFirmwareVersion(&firmataInstance->marshaller,\n                                              firmwareVersions[0],\n                                              firmwareVersions[1],\n                                              firmwareVersionCount - 2,\n                                              firmwareVersions + 2);\n    }\n}\n",
            "called": [
                "sendFirmwareVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002df6",
            "calling": [
                "begin",
                "staticReportFirmwareCallback"
            ],
            "imported": false,
            "current_name": "sendFirmwareVersionIfPresent_08002df6"
        },
        "FUN_080045bc": {
            "renaming": {
                "FUN_080045bc": "do_nothing_080045bc"
            },
            "code": "\nvoid do_nothing_080045bc(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080045bc",
            "calling": [
                "HAL_I2C_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_080045bc"
        },
        "FUN_08007118": {
            "renaming": {
                "FUN_08007118": "set_pwm_08007118",
                "PinName_conflict": "PinName",
                "clock_freq": "clock_frequency",
                "period": "period",
                "value": "duty_cycle",
                "do_init": "init",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HVar1": "status",
                "uVar2": "timer_clk_freq",
                "uVar3": "function",
                "timConfig": "timer_config",
                "timHandle": "timer_handle",
                "TIM_OC_InitTypeDef": "TIM_OC_InitTypeDef",
                "TIM_HandleTypeDef_conflict": "TIM_HandleTypeDef",
                "timHandle.Instance": "timer_handle.Instance",
                "getTimerClkFreq": "getTimerClkFreq",
                "HAL_TIM_PWM_Init": "HAL_TIM_PWM_Init",
                "PTR_g_current_pin_080071e0": "g_current_pin",
                "HAL_TIM_PWM_ConfigChannel": "HAL_TIM_PWM_ConfigChannel",
                "get_pwm_channel": "get_pwm_channel",
                "PTR_PinMap_PWM_080071dc": "PinMap_PWM"
            },
            "code": "void set_pwm_08007118(PinName pin, uint32_t clock_frequency, uint32_t period, uint32_t duty_cycle, uint8_t init){\n  HAL_StatusTypeDef status;\n  uint32_t timer_clk_freq;\n  uint32_t pwm_channel;\n  TIM_OC_InitTypeDef timer_config;\n  TIM_HandleTypeDef timer_handle;\n  memset(&timer_handle, 0, sizeof(timer_handle));\n  timer_config.OCMode = TIM_OCMODE_PWM1;\n  timer_config.Pulse = 0;\n  timer_config.OCPolarity = TIM_OCPOLARITY_HIGH;\n  timer_config.OCNPolarity = TIM_OCNPOLARITY_HIGH;\n  timer_config.OCFastMode = TIM_OCFAST_DISABLE;\n  timer_config.OCIdleState = TIM_OCIDLESTATE_RESET;\n  timer_config.OCNIdleState = TIM_OCNIDLESTATE_RESET;\n  timer_handle.Instance = (TIM_TypeDef *)pinmap_peripheral(pin, (PinMap *)PTR_PinMap_PWM_080071dc);\n  if (timer_handle.Instance != NULL){\n    timer_clk_freq = getTimerClkFreq(timer_handle.Instance);\n    timer_handle.Init.Prescaler = timer_clk_freq / clock_frequency - 1;\n    timer_handle.Init.Period = period - 1;\n    timer_handle.Init.ClockDivision = 0;\n    timer_handle.Init.CounterMode = TIM_COUNTERMODE_UP;\n    timer_handle.Init.RepetitionCounter = 0;\n    timer_handle.State = HAL_TIM_STATE_RESET;\n    if (init == 1){\n      PTR_g_current_pin_080071e0 = pin;\n      status = HAL_TIM_PWM_Init(&timer_handle);\n      if (status != HAL_OK){\n        return;\n      }\n    }\n    pwm_channel = get_pwm_channel(pin);\n    if ((pwm_channel == 0) || (pwm_channel == 4) || (pwm_channel == 8) || (pwm_channel == 12) || (pwm_channel == 24)){\n      timer_config.Pulse = duty_cycle;\n      status = HAL_TIM_PWM_ConfigChannel(&timer_handle, &timer_config, pwm_channel);\n      if (status == HAL_OK){\n        uint32_t function = pinmap_function(pin, (PinMap *)PTR_PinMap_PWM_080071dc);\n        if ((function & 0x100000) == 0){\n          HAL_TIM_PWM_Start(&timer_handle, pwm_channel);\n        }\n        else{\n          HAL_TIMEx_PWMN_Start(&timer_handle, pwm_channel);\n        }\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "pinmap_function",
                "memset",
                "get_pwm_channel",
                "HAL_TIM_PWM_Init",
                "getTimerClkFreq",
                "HAL_TIMEx_PWMN_Start",
                "pinmap_peripheral",
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_PWM_Start"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007118",
            "calling": [
                "analogWrite"
            ],
            "imported": false,
            "current_name": "set_pwm_08007118"
        },
        "FUN_08001be8": {
            "renaming": {
                "FUN_08001be8": "initialize_static_data_08001be8"
            },
            "code": "void initialize_static_data_08001be8(void)\n{\n    __static_initialization_and_destruction_0(1, 0xffff);\n    return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001be8",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_data_08001be8"
        },
        "FUN_08005a68": {
            "renaming": {
                "FUN_08005a68": "configureClock_08005a68",
                "*RCC_ClkInitStruct": "*clockInitStruct",
                "*pFLatency": "*flashLatency",
                "DAT_08005a9c": "data",
                "RCC_ClkInitStruct->ClockType": "RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2",
                "RCC_ClkInitStruct->SYSCLKSource": "*(uint32_t *)(data + 4) & RCC_SYSCLKSOURCE_PLLCLK",
                "RCC_ClkInitStruct->AHBCLKDivider": "*(uint32_t *)(data + 4) & RCC_SYSCLK_DIV1",
                "RCC_ClkInitStruct->APB1CLKDivider": "*(uint32_t *)(data + 4) & RCC_HCLK_DIV1",
                "RCC_ClkInitStruct->APB2CLKDivider": "*(uint32_t *)(data + 4) >> 3 & RCC_HCLK_DIV1",
                "*pFLatency = *DAT_08005aa0 & 7": "*flashLatency = *DAT_08005aa0 & FLASH_LATENCY_7"
            },
            "code": "void configureClock_08005a68(RCC_ClkInitTypeDef_conflict *clockInitStruct, uint32_t *flashLatency) {\n  int DAT_08005a9c = DAT_08005a9c;\n  clockInitStruct->ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;\n  clockInitStruct->SYSCLKSource = *(uint32_t *)(DAT_08005a9c + 4) & RCC_SYSCLKSOURCE_PLLCLK;\n  clockInitStruct->AHBCLKDivider = *(uint32_t *)(DAT_08005a9c + 4) & RCC_SYSCLK_DIV1;\n  clockInitStruct->APB1CLKDivider = *(uint32_t *)(DAT_08005a9c + 4) & RCC_HCLK_DIV1;\n  clockInitStruct->APB2CLKDivider = *(uint32_t *)(DAT_08005a9c + 4) >> 3 & RCC_HCLK_DIV1;\n  *pFLatency = *DAT_08005aa0 & 7;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a68",
            "calling": [
                "getTimerClkFreq"
            ],
            "imported": false,
            "current_name": "configureClock_08005a68"
        },
        "FUN_08008f78": {
            "renaming": {
                "FUN_08008f78": "initialize_gpio_irq_08008f78",
                "__initialize_p": "should_initialize",
                "__priority": "priority",
                "PTR_gpio_irq_conf_08009018": "gpio_irq_conf_ptr",
                "DAT_08009020": "DAT_exit_function_ptr_08009020",
                "PTR___dso_handle_0800901c": "PTR___dso_handle_0800901c"
            },
            "code": "void initialize_gpio_irq_08008f78(int should_initialize, int priority) {\n  if (should_initialize == 1 && priority == 0xffff) {\n    int* PTR_gpio_irq_conf_08009018 = PTR_gpio_irq_conf_08009018;\n    PTR_gpio_irq_conf_08009018[0] = 6;\n    PTR_gpio_irq_conf_08009018[3] = 0;\n    PTR_gpio_irq_conf_08009018[5] = 7;\n    PTR_gpio_irq_conf_08009018[8] = 0;\n    PTR_gpio_irq_conf_08009018[10] = 8;\n    PTR_gpio_irq_conf_08009018[13] = 0;\n    PTR_gpio_irq_conf_08009018[15] = 9;\n    PTR_gpio_irq_conf_08009018[18] = 0;\n    PTR_gpio_irq_conf_08009018[20] = 10;\n    PTR_gpio_irq_conf_08009018[23] = 0;\n    PTR_gpio_irq_conf_08009018[25] = 23;\n    PTR_gpio_irq_conf_08009018[28] = 0;\n    PTR_gpio_irq_conf_08009018[30] = 23;\n    PTR_gpio_irq_conf_08009018[33] = 0;\n    PTR_gpio_irq_conf_08009018[35] = 23;\n    PTR_gpio_irq_conf_08009018[38] = 0;\n    PTR_gpio_irq_conf_08009018[40] = 23;\n    PTR_gpio_irq_conf_08009018[43] = 0;\n    PTR_gpio_irq_conf_08009018[45] = 40;\n    PTR_gpio_irq_conf_08009018[48] = 0;\n    PTR_gpio_irq_conf_08009018[50] = 40;\n    PTR_gpio_irq_conf_08009018[53] = 0;\n    PTR_gpio_irq_conf_08009018[55] = 40;\n    PTR_gpio_irq_conf_08009018[58] = 0;\n    PTR_gpio_irq_conf_08009018[60] = 40;\n    PTR_gpio_irq_conf_08009018[63] = 0;\n    __aeabi_atexit(0, DAT_08009020, PTR___dso_handle_0800901c);\n  }\n}\n",
            "called": [
                "__aeabi_atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f78",
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "imported": false,
            "current_name": "initialize_gpio_irq_08008f78"
        },
        "FUN_08002dea": {
            "renaming": {
                "FUN_08002dea": "printFirmataVersionIfContextExists_08002dea",
                "context": "context",
                "printVersion": "printVersion",
                "FirmataClass": "FirmataClass"
            },
            "code": "void firmata::FirmataClass::printFirmataVersionIfContextExists_08002dea(void *context)\n{\n  if (context != nullptr) {\n    printVersion((FirmataClass *)context);\n    return;\n  }\n  return;\n}",
            "called": [
                "printVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002dea",
            "calling": [],
            "imported": false,
            "current_name": "printFirmataVersionIfContextExists_08002dea"
        },
        "FUN_08008d30": {
            "renaming": {
                "FUN_08008d30::FUN_08008d30": "initializeSerialCommunication",
                "this": "serialObject",
                "peripheral": "peripheral",
                "PVar1": "rxPin",
                "extraout_r1": "ctx1",
                "extraout_r1_00": "ctx2",
                "ctx": "ctx1",
                "PTR_Serial2_08008d80": "serial2Pointer",
                "PTR_PinMap_UART_RX_08008d84": "rxPinMapPointer",
                "PTR_PinMap_UART_TX_08008d88": "txPinMapPointer",
                "FUN_08008d30": "initializeSerialCommunication_08008d30"
            },
            "code": "initializeSerialCommunication_08008d30 * __thiscall initializeSerialCommunication_08008d30(initializeSerialCommunication_08008d30 *serialObject, void *peripheral)\n{\n  PinName_conflict rxPin;\n  EVP_PKEY_CTX *ctx1, *ctx2;\n  \n  (serialObject->super_Stream).super_Print.write_error = 0;\n  (serialObject->super_Stream)._timeout = 1000;\n  (serialObject->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)writePointer;\n  if (serialObject == (initializeSerialCommunication_08008d30 *)PTR_Serial2_08008d80) {\n    setRx(serialObject, 0);\n    setTx(serialObject, 1);\n    ctx1 = extraout_r1_00;\n  }\n  else {\n    rxPin = pinmap_pin(peripheral, (PinMap_conflict *)PTR_PinMap_UART_RX_08008d84);\n    (serialObject->_serial).pin_rx = rxPin;\n    txPin = pinmap_pin(peripheral, (PinMap_conflict *)PTR_PinMap_UART_TX_08008d88);\n    (serialObject->_serial).pin_tx = txPin;\n    ctx1 = extraout_r1;\n  }\n  init(serialObject, ctx1);\n  return serialObject;\n}",
            "called": [
                "init",
                "pinmap_pin",
                "setTx",
                "setRx"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d30",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initializeSerialCommunication_08008d30"
        },
        "FUN_0800734a": {
            "renaming": {
                "FUN_0800734a": "find_pin_for_peripheral_0800734a",
                "PVar1": "pin_name",
                "peripheral": "peripheral",
                "map": "map",
                "NC": "NC"
            },
            "code": "PinName_conflict find_pin_for_peripheral_0800734a(void *peripheral, PinMap_conflict *map) {\n  PinName_conflict pin_name;\n  if (peripheral != NULL) {\n    pin_name = pinmap_find_pin(peripheral,map);\n    return pin_name;\n  }\n  return NC;\n}",
            "called": [
                "pinmap_find_pin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800734a",
            "calling": [
                "uart_debug_init",
                "HardwareSerial"
            ],
            "imported": false,
            "current_name": "find_pin_for_peripheral_0800734a"
        },
        "FUN_08000aec": {
            "renaming": {
                "FUN_08000aec": "initializePins_08000aec",
                "PTR_isResetting_08000bc0": "is_resetting_ptr",
                "PTR_isI2CEnabled_08000bc4": "is_i2c_enabled_ptr",
                "disableI2CPins": "disableI2CPins",
                "PTR_reportPINs_08000bc8": "report_pins_ptr",
                "PTR_portConfigInputs_08000bcc": "port_config_inputs_ptr",
                "PTR_previousPINs_08000bd0": "previous_pins_ptr",
                "PTR_digitalPin_08000bd4": "digital_pin_ptr",
                "NC": "NC",
                "pinNametoDigitalPin": "pinNametoDigitalPin",
                "setPinModeCallback": "setPinModeCallback",
                "PTR_servoPinMap_08000bd8": "servo_pin_map_ptr",
                "PTR_analogInputsToReport_08000bdc": "analog_inputs_to_report_ptr",
                "PTR_detachedServoCount_08000be0": "detached_servo_count_ptr",
                "PTR_servoCount_08000be4": "servo_count_ptr"
            },
            "code": "void initializePins_08000aec(void)\n{\n  bool is_i2c_enabled = *PTR_isI2CEnabled_08000bc4;\n  *PTR_isResetting_08000bc0 = true;\n  if (is_i2c_enabled) {\n    disableI2CPins();\n  }\n  for (uint pin_index = 0; pin_index < 5; pin_index++) {\n    PTR_reportPINs_08000bc8[pin_index] = 0;\n    PTR_portConfigInputs_08000bcc[pin_index] = 0;\n    PTR_previousPINs_08000bd0[pin_index] = 0;\n  }\n  for (uint pin_index = 0; pin_index < 0x3c; pin_index++) {\n    bool is_valid_pin = false;\n    if ((pin_index - 0x2e) < 0xe) {\n      PinName_conflict pin_name = PTR_digitalPin_08000bd4[pin_index];\n      uint32_t digital_pin = pinNametoDigitalPin(pin_name);\n      if (digital_pin == 0) {\n        is_valid_pin = false;\n      }\n      else {\n        digital_pin = pinNametoDigitalPin(pin_name);\n        if (digital_pin == 1) {\n          is_valid_pin = false;\n        }\n        else {\n          is_valid_pin = true;\n        }\n      }\n    }\n    if (is_valid_pin) {\n      setPinModeCallback((byte)pin_index, 2);\n    }\n    else {\n      if ((PTR_digitalPin_08000bd4[pin_index] != NC) && (pinNametoDigitalPin(PTR_digitalPin_08000bd4[pin_index]) != 0) && (pinNametoDigitalPin(PTR_digitalPin_08000bd4[pin_index]) != 1)) {\n        is_valid_pin = true;\n      }\n      if (is_valid_pin) {\n        setPinModeCallback((byte)pin_index, 1);\n      }\n    }\n    PTR_servoPinMap_08000bd8[pin_index] = 0xff;\n  }\n  *PTR_analogInputsToReport_08000bdc = 0;\n  *PTR_detachedServoCount_08000be0 = 0;\n  *PTR_servoCount_08000be4 = 0;\n  *PTR_isResetting_08000bc0 = false;\n}",
            "called": [
                "disableI2CPins",
                "pinNametoDigitalPin",
                "setPinModeCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000aec",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "initializePins_08000aec"
        },
        "FUN_080068d6": {
            "renaming": {
                "FUN_080068d6": "configureUartReceive_080068d6",
                "huart": "uartHandler",
                "pData": "receiveData",
                "Size": "dataSize",
                "pRxBuffPtr": "receiveBufferPointer",
                "RxXferSize": "receiveTransferSize",
                "RxXferCount": "receiveTransferCount",
                "ErrorCode": "errorStatus",
                "RxState": "receiveState",
                "Lock": "lockStatus",
                "Instance": "uartInstance",
                "CR1": "controlRegister1",
                "CR3": "controlRegister3",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "code": "HAL_StatusTypeDef configureUartReceive_080068d6(UART_HandleTypeDef *uartHandler, uint8_t *receiveData, uint16_t dataSize)\n{\n  if (uartHandler->RxState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (receiveData == NULL) {\n    return HAL_ERROR;\n  }\n  if (dataSize == 0) {\n    return HAL_ERROR;\n  }\n  if (uartHandler->Lock != HAL_LOCKED) {\n    uartHandler->pRxBuffPtr = receiveData;\n    uartHandler->RxXferSize = dataSize;\n    uartHandler->RxXferCount = dataSize;\n    uartHandler->ErrorCode = 0;\n    uartHandler->RxState = HAL_UART_STATE_BUSY_RX;\n    uartHandler->Lock = HAL_UNLOCKED;\n    uartHandler->Instance->CR1 |= USART_CR1_RXNEIE;\n    uartHandler->Instance->CR3 |= USART_CR3_EIE;\n    uartHandler->Instance->CR1 |= USART_CR1_RE;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080068d6",
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "imported": false,
            "current_name": "configureUartReceive_080068d6"
        },
        "FUN_080032a2": {
            "renaming": {
                "FUN_080032a2": "sendSysexMessage_080032a2",
                "this": "marshaller",
                "string": "message",
                "bytec": "message_size"
            },
            "code": "void __thiscall FirmataMarshaller::sendSysexMessage_080032a2(FirmataMarshaller *marshaller, char *message) {\n  size_t message_size;\n  message_size = strlen(message);\n  sendSysex(marshaller, 'q', message_size, (uint8_t *)message);\n  return;\n}",
            "called": [
                "sendSysex",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080032a2",
            "calling": [
                "sendString"
            ],
            "imported": false,
            "current_name": "sendSysexMessage_080032a2"
        },
        "FUN_08009e28": {
            "renaming": {
                "FUN_08009e28": "process_data_08009e28",
                "param_1": "data_count",
                "param_2": "data_processor",
                "param_3": "param_3",
                "param_4": "param_4",
                "piVar3": "data_ptr",
                "iVar4": "data_offset",
                "iVar6": "data_size",
                "uVar1": "processed_data",
                "uVar5": "result"
            },
            "code": "uint process_data_08009e28(int data_count, code* data_processor, undefined4 param_3, undefined4 param_4) {\n  uint result = 0;\n  for (int* data_ptr = (int *)(data_count + 0x48); data_ptr != (int *)0x0; data_ptr = (int *)*data_ptr) {\n    int data_offset = data_ptr[2];\n    int data_size = data_ptr[1];\n    while (data_size = data_size - 1, -1 < data_size) {\n      if ((1 < *(ushort *)(data_offset + 0xc)) && (int data_increment = *(short *)(data_offset + 0xe) + 1, data_increment != 0)) {\n        uint processed_data = (*data_processor)(data_count, data_offset, param_3, data_increment, param_4);\n        result = result | processed_data;\n      }\n      data_offset = data_offset + 0x68;\n    }\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009e28",
            "calling": [
                "_cleanup_r"
            ],
            "imported": false,
            "current_name": "process_data_08009e28"
        },
        "FUN_0800a01c": {
            "renaming": {
                "FUN_0800a01c": "get_process_id_0800a01c"
            },
            "code": "__pid_t get_process_id_0800a01c(void)\n{\n  return 1;\n}",
            "called": [
                "_getpid"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a01c",
            "calling": [
                "_raise_r"
            ],
            "imported": false,
            "current_name": "get_process_id_0800a01c"
        },
        "FUN_08006390": {
            "renaming": {
                "FUN_08006390": "configureTimer_08006390",
                "htim": "timerHandle",
                "Channel": "channel",
                "pTVar1": "timerInstance",
                "DAT_080063bc": "instanceToCheck"
            },
            "code": "HAL_StatusTypeDef_conflict configureTimer_08006390(TIM_HandleTypeDef_conflict *timerHandle, uint32_t channel) {\n  TIM_TypeDef_conflict *timerInstance;\n  TIM_CCxChannelCmd(timerHandle->Instance, channel, 1);\n  timerInstance = timerHandle->Instance;\n  if (timerInstance == DAT_080063bc) {\n    timerInstance->BDTR |= 0x8000;\n  }\n  timerHandle->Instance->CR1 |= 1;\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006390",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "configureTimer_08006390"
        },
        "FUN_08009f48": {
            "renaming": {
                "FUN_08009f48": "do_nothing_08009f48"
            },
            "code": "\nvoid do_nothing_08009f48(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f48",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_08009f48"
        },
        "FUN_08004d6a": {
            "renaming": {
                "FUN_08004d6a": "do_nothing_08004d6a"
            },
            "code": "\nvoid do_nothing_08004d6a(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d6a",
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004d6a"
        },
        "FUN_08008730": {
            "renaming": {
                "FUN_08008730": "transmit_data_08008730",
                "huart": "uart_handle",
                "bVar1": "uart_index",
                "uVar2": "uart_index_uint",
                "iVar3": "callback_index",
                "iVar4": "callback_obj",
                "PTR_tx_callback_obj_08008770": "callback_obj_pointer",
                "PTR_tx_callback_08008774": "callback_pointer",
                "PTR_uart_handlers_08008778": "uart_handlers_pointer"
            },
            "code": "void transmit_data_08008730(UART_HandleTypeDef *uart_handle)\n{\n  int callback_index;\n  int callback_obj;\n  uint8_t* data_ptr;\n  uint8_t data_size = 1;\n  uint8_t uart_index = uart_index(uart_handle);\n  if (uart_index < 5)\n  {\n    callback_obj = *(int *)(PTR_tx_callback_obj_08008770 + uart_index * 4);\n    callback_index = (**(code **)(PTR_tx_callback_08008774 + uart_index * 4))(callback_obj);\n    if (callback_index != -1)\n    {\n      data_ptr = (uint8_t *)(*(int *)(callback_obj + 100) + (uint)*(ushort *)(callback_obj + 0x6a));\n      HAL_UART_Transmit_IT(*(UART_HandleTypeDef **)(PTR_uart_handlers_08008778 + (uint)*(byte *)(callback_obj + 0x44) * 4), data_ptr, data_size);\n    }\n  }\n}",
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008730",
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "imported": false,
            "current_name": "transmit_data_08008730"
        },
        "FUN_08005460": {
            "renaming": {
                "FUN_08005460": "FUNC_08005460"
            },
            "code": "\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nHAL_StatusTypeDef_conflict FUNC_08005460(RCC_OscInitTypeDef_conflict *RCC_OscInitStruct)\n\n{\n  uint *puVar1;\n  uint *puVar2;\n  HAL_StatusTypeDef_conflict HVar3;\n  uint32_t uVar4;\n  uint32_t uVar5;\n  bool bVar6;\n  uint32_t tmpreg;\n  \n  puVar1 = DAT_08005720;\n  if ((RCC_OscInitStruct->OscillatorType & 1) != 0) {\n    if (((DAT_08005720[1] & 0xc) == 4) ||\n       (((DAT_08005720[1] & 0xc) == 8 && ((DAT_08005720[1] & 0x10000) != 0)))) {\n      if (((*DAT_08005720 & 0x20000) != 0) && (RCC_OscInitStruct->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      uVar5 = RCC_OscInitStruct->HSEState;\n      if (uVar5 == 0x10000) {\n        *DAT_08005720 = *DAT_08005720 | 0x10000;\n      }\n      else if (uVar5 == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (uVar5 == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        *DAT_08005720 = *DAT_08005720 & 0xfffeffff;\n        *puVar1 = *puVar1 & 0xfffbffff;\n      }\n      if (RCC_OscInitStruct->HSEState == 0) {\n        uVar5 = HAL_GetTick();\n        while ((*DAT_08005720 & 0x20000) != 0) {\n          uVar4 = HAL_GetTick();\n          if (100 < uVar4 - uVar5) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        uVar5 = HAL_GetTick();\n        while ((*DAT_08005720 & 0x20000) == 0) {\n          uVar4 = HAL_GetTick();\n          if (100 < uVar4 - uVar5) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 2) != 0) {\n    if (((DAT_08005720[1] & 0xc) == 0) ||\n       (((DAT_08005720[1] & 0xc) == 8 && ((DAT_08005720[1] & 0x10000) == 0)))) {\n      if (((*DAT_08005720 & 2) != 0) && (RCC_OscInitStruct->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      *DAT_08005720 = *DAT_08005720 & 0xffffff07 | RCC_OscInitStruct->HSICalibrationValue << 3;\n    }\n    else if (RCC_OscInitStruct->HSIState == 0) {\n      *DAT_08005724 = 0;\n      uVar5 = HAL_GetTick();\n      while ((*DAT_08005720 & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005724 = 1;\n      uVar5 = HAL_GetTick();\n      while ((*DAT_08005720 & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n      *DAT_08005720 = *DAT_08005720 & 0xffffff07 | RCC_OscInitStruct->HSICalibrationValue << 3;\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 8) != 0) {\n    if (RCC_OscInitStruct->LSIState == 0) {\n      *DAT_08005728 = 0;\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005720[9] & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      *DAT_08005728 = 1;\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005720[9] & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (2 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((RCC_OscInitStruct->OscillatorType & 4) != 0) {\n    bVar6 = (DAT_08005720[7] & 0x10000000) == 0;\n    if (bVar6) {\n      DAT_08005720[7] = DAT_08005720[7] | 0x10000000;\n    }\n    if ((*DAT_0800572c & 0x100) == 0) {\n      *DAT_0800572c = *DAT_0800572c | 0x100;\n      uVar5 = HAL_GetTick();\n      while ((*DAT_0800572c & 0x100) == 0) {\n        uVar4 = HAL_GetTick();\n        if (100 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    puVar2 = DAT_08005838;\n    puVar1 = DAT_08005720;\n    uVar5 = RCC_OscInitStruct->LSEState;\n    if (uVar5 == 1) {\n      DAT_08005720[8] = DAT_08005720[8] | 1;\n    }\n    else if (uVar5 == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (uVar5 == 5) {\n      DAT_08005838[8] = DAT_08005838[8] | 4;\n      puVar2[8] = puVar2[8] | 1;\n    }\n    else {\n      DAT_08005720[8] = DAT_08005720[8] & 0xfffffffe;\n      puVar1[8] = puVar1[8] & 0xfffffffb;\n    }\n    if (RCC_OscInitStruct->LSEState == 0) {\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005838[8] & 2) != 0) {\n        uVar4 = HAL_GetTick();\n        if (5000 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      uVar5 = HAL_GetTick();\n      while ((DAT_08005720[8] & 2) == 0) {\n        uVar4 = HAL_GetTick();\n        if (5000 < uVar4 - uVar5) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (bVar6) {\n      DAT_08005838[7] = DAT_08005838[7] & 0xefffffff;\n    }\n  }\n  uVar5 = (RCC_OscInitStruct->PLL).PLLState;\n  if (uVar5 == 0) {\n    HVar3 = HAL_OK;\n  }\n  else if ((DAT_08005838[1] & 0xc) == 8) {\n    HVar3 = HAL_ERROR;\n  }\n  else if (uVar5 == 2) {\n    *DAT_0800583c = 0;\n    uVar5 = HAL_GetTick();\n    do {\n      if ((*DAT_08005838 & 0x2000000) == 0) {\n        if ((RCC_OscInitStruct->PLL).PLLSource == 0x10000) {\n          DAT_08005838[1] = DAT_08005838[1] & 0xfffdffff | RCC_OscInitStruct->HSEPredivValue;\n        }\n        DAT_08005838[1] =\n             DAT_08005838[1] & 0xffc2ffff |\n             (RCC_OscInitStruct->PLL).PLLSource | (RCC_OscInitStruct->PLL).PLLMUL;\n        *DAT_0800583c = 1;\n        uVar5 = HAL_GetTick();\n        do {\n          if ((*DAT_08005838 & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          uVar4 = HAL_GetTick();\n        } while (uVar4 - uVar5 < 3);\n        return HAL_TIMEOUT;\n      }\n      uVar4 = HAL_GetTick();\n    } while (uVar4 - uVar5 < 3);\n    HVar3 = HAL_TIMEOUT;\n  }\n  else {\n    *DAT_0800583c = 0;\n    uVar5 = HAL_GetTick();\n    do {\n      if ((*DAT_08005838 & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      uVar4 = HAL_GetTick();\n    } while (uVar4 - uVar5 < 3);\n    HVar3 = HAL_TIMEOUT;\n  }\n  return HVar3;\n}\n\n",
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08005460",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "FUNC_08005460"
        },
        "FUN_08008854": {
            "renaming": {
                "FUN_08008854": "calculate_file_size_08008854",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "pointer_to_buffer",
                "dir_UNUSED": "directory_index"
            },
            "code": "int calculate_file_size_08008854(int file_descriptor, int pointer_to_buffer, int directory_index) {\n    return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008854",
            "calling": [
                "_lseek_r"
            ],
            "imported": false,
            "current_name": "calculate_file_size_08008854"
        },
        "FUN_08004d6c": {
            "renaming": {
                "FUN_08004d6c": "receive_data_08004d6c",
                "hi2c": "i2c_handler",
                "puVar1": "buffer_pointer"
            },
            "code": "HAL_StatusTypeDef_conflict receive_data_08004d6c(I2C_HandleTypeDef_conflict *i2c_handler)\n{\n    uint8_t *buffer_pointer;\n\n    if (i2c_handler->State == HAL_I2C_STATE_BUSY_RX) {\n        if (i2c_handler->XferCount < 4) {\n            if (i2c_handler->XferCount - 2 < 2) {\n                if (i2c_handler->XferOptions == 2) {\n                    i2c_handler->Instance->CR1 |= 0x400;\n                }\n                else {\n                    i2c_handler->Instance->CR1 &= 0xfffffbff;\n                    i2c_handler->Instance->CR1 |= 0x800;\n                }\n                i2c_handler->Instance->CR2 &= 0xfffffbff;\n            }\n            else {\n                if (i2c_handler->XferOptions == 2) {\n                    i2c_handler->Instance->CR1 |= 0x400;\n                }\n                else {\n                    i2c_handler->Instance->CR1 &= 0xfffffbff;\n                }\n                i2c_handler->Instance->CR2 &= 0xfffff8ff;\n                buffer_pointer = i2c_handler->pBuffPtr;\n                i2c_handler->pBuffPtr = buffer_pointer + 1;\n                *buffer_pointer = (uint8_t)i2c_handler->Instance->DR;\n                i2c_handler->XferCount--;\n                i2c_handler->State = HAL_I2C_STATE_READY;\n                i2c_handler->PreviousState = 0;\n                if (i2c_handler->Mode == HAL_I2C_MODE_MEM) {\n                    i2c_handler->Mode = HAL_I2C_MODE_NONE;\n                    HAL_I2C_MemRxCpltCallback(i2c_handler);\n                }\n                else {\n                    i2c_handler->Mode = HAL_I2C_MODE_NONE;\n                    HAL_I2C_MasterRxCpltCallback(i2c_handler);\n                }\n            }\n        }\n        else {\n            buffer_pointer = i2c_handler->pBuffPtr;\n            i2c_handler->pBuffPtr = buffer_pointer + 1;\n            *buffer_pointer = (uint8_t)i2c_handler->Instance->DR;\n            i2c_handler->XferCount--;\n        }\n    }\n    return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004d6c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "receive_data_08004d6c"
        },
        "FUN_08007760": {
            "renaming": {
                "FUN_08007760": "handle_timer_interrupt_08007760",
                "PTR_timer_handles_08007770": "PTR_timer_handles_08007770",
                "TIM_HandleTypeDef_conflict": "TIM_HandleTypeDef"
            },
            "code": "void handle_timer_interrupt_08007760(void)\n{\n  TIM_HandleTypeDef_conflict* timer_handle = *(TIM_HandleTypeDef_conflict **)PTR_timer_handles_08007770;\n  if (timer_handle != NULL) {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007760",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08007760"
        },
        "FUN_08008850": {
            "renaming": {
                "FUN_08008850": "always_return_one_08008850",
                "file_UNUSED": "file_unused"
            },
            "code": "int always_return_one_08008850(int file_unused) {\n  return 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008850",
            "calling": [
                "_isatty_r"
            ],
            "imported": false,
            "current_name": "always_return_one_08008850"
        },
        "FUN_08002fc2": {
            "renaming": {
                "FUN_08002fc2": "setPinState_08002fc2",
                "pin": "pinNumber",
                "state": "pinState"
            },
            "code": "void __thiscall firmata::FirmataClass::setPinState_08002fc2(FirmataClass *this, byte pin, int state) {\n  this->pinState[pin] = state;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fc2",
            "calling": [
                "digitalWriteCallback",
                "analogWriteCallback",
                "setPinValueCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "setPinState_08002fc2"
        },
        "FUN_08008afa": {
            "renaming": {
                "FUN_08008afa": "get_num_bytes_in_rx_buffer_08008afa",
                "this": "serial_obj",
                "_serial": "serial_data",
                "rx_head": "rx_buffer_head",
                "rx_tail": "rx_buffer_tail",
                "uint": "unsigned int",
                "num_bytes": "num_bytes_in_rx_buffer"
            },
            "code": "int __thiscall HardwareSerial::get_num_bytes_in_rx_buffer_08008afa(HardwareSerial *serial_obj) {\n  uint rx_head = (serial_obj->_serial).rx_head;\n  uint rx_tail = (serial_obj->_serial).rx_tail;\n  uint num_bytes = (rx_head - rx_tail) & 0x3f;\n  return num_bytes;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008afa",
            "calling": [
                "serialEventRun"
            ],
            "imported": false,
            "current_name": "get_num_bytes_in_rx_buffer_08008afa"
        },
        "FUN_08003048": {
            "renaming": {
                "__thiscall firmata::FirmataClass::FUN_08003048": "sendDataToSerial2",
                "this": "firmataObject",
                "speed": "baudRate",
                "s": "serialPointer",
                "PTR_Serial2_08003068": "serialPointer",
                "HardwareSerial::FUN_08003048": "HardwareSerial::sendDataToSerial",
                "FUN_08003048": "sendDataToSerial_08003048",
                "Stream": "SerialStream"
            },
            "code": "void __thiscall firmata::FirmataClass::sendDataToSerial_08003048(FirmataClass *firmataObject,long speed)\n{\n  undefined *PTR_Serial2_08003068;\n  PTR_Serial2_08003068 = PTR_Serial2_08003068;\n  HardwareSerial::sendDataToSerial_08003048((HardwareSerial *)PTR_Serial2_08003068,speed,'\\x06');\n  blinkVersion(firmataObject);\n  sendDataToSerial_08003048(firmataObject,(Stream *)PTR_Serial2_08003068);\n  return;\n}",
            "called": [
                "begin",
                "blinkVersion",
                "begin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003048",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "sendDataToSerial_08003048"
        },
        "FUN_080038dc": {
            "renaming": {
                "FUN_080038dc": "getADCData_080038dc",
                "hadc": "adc_handle",
                "Instance": "adc_instance",
                "DR": "adc_data"
            },
            "code": "uint32_t getADCData_080038dc(ADC_HandleTypeDef *adc_handle)\n{\n  return adc_handle->Instance->DR;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080038dc",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "getADCData_080038dc"
        },
        "FUN_080025ac": {
            "renaming": {
                "__thiscall Servo::FUN_080025ac": "setServoPinAndRange",
                "this": "servo",
                "pin": "pin",
                "min": "minPulseWidth",
                "max": "maxPulseWidth",
                "obj": "timerPtr",
                "bVar1": "isTimerActive",
                "iVar2": "pulseWidthAdjusted",
                "timer": "timer",
                "PTR_servos_08002628": "servoDataArray",
                "DAT_0800262c": "timerPrescale",
                "PTR__timer_08002630": "timerRegisters",
                "FUN_080025ac": "setServoPinAndRange_080025ac"
            },
            "code": "uint8_t __thiscall setServoPinAndRange_080025ac(Servo *servo, int pin, int minPulseWidth, int maxPulseWidth)\n{\n  boolean isTimerActive;\n  int minPulseWidthAdjusted;\n  int maxPulseWidthAdjusted;\n  timer16_Sequence_t timer;\n  undefined *timerPtr;\n  if (servo->servoIndex < 0xc) {\n    pinMode(pin, OUTPUT);\n    PTR_servos_08002628[(uint)servo->servoIndex * 8] = PTR_servos_08002628[(uint)servo->servoIndex * 8] & 0xc0 | (byte)pin & 0x3f;\n    minPulseWidthAdjusted = -minPulseWidth + 0x220;\n    if (minPulseWidthAdjusted < 0) {\n      minPulseWidthAdjusted = -minPulseWidth + 0x223;\n    }\n    servo->minPulseWidth = (int8_t)((uint)(minPulseWidthAdjusted << 0x16) >> 0x18);\n    maxPulseWidthAdjusted = -maxPulseWidth + 0x960;\n    if (maxPulseWidthAdjusted < 0) {\n      maxPulseWidthAdjusted = -maxPulseWidth + 0x963;\n    }\n    servo->maxPulseWidth = (int8_t)((uint)(maxPulseWidthAdjusted << 0x16) >> 0x18);\n    timer = (timer16_Sequence_t)(uint)((ulonglong)DAT_0800262c * (ulonglong)servo->servoIndex >> 0x23);\n    isTimerActive = isTimerActive(timer);\n    timerPtr = PTR__timer_08002630;\n    if (!isTimerActive) {\n      timerPtr[0x44] = timer;\n      initISR((stimer_t *)timerPtr);\n    }\n    PTR_servos_08002628[(uint)servo->servoIndex * 8] = PTR_servos_08002628[(uint)servo->servoIndex * 8] | 0x40;\n  }\n  return servo->servoIndex;\n}",
            "called": [
                "initISR",
                "isTimerActive",
                "pinMode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080025ac",
            "calling": [
                "attachServo",
                "attach"
            ],
            "imported": false,
            "current_name": "setServoPinAndRange_080025ac"
        },
        "FUN_08007648": {
            "renaming": {
                "FUN_08007648": "initialize_timer_08007648",
                "obj": "timer_obj",
                "period": "period",
                "pulseWidth": "pulse_width",
                "irqHandle": "irq_handler",
                "HVar1": "hal_status",
                "uVar2": "timer_clk_freq",
                "htim": "timer_handle",
                "sConfig": "timer_oc_config"
            },
            "code": "void initialize_timer_08007648(stimer_t_conflict *timer_obj, uint16_t period, uint16_t pulse_width, _func_void_stimer_t_ptr_uint32_t_conflict *irq_handler) {\n  HAL_StatusTypeDef_conflict hal_status;\n  uint32_t timer_clk_freq;\n  TIM_HandleTypeDef_conflict *timer_handle;\n  TIM_OC_InitTypeDef timer_oc_config;\n  \n  timer_oc_config.OCMode = TIM_OCMODE_PWM1;\n  timer_oc_config.Pulse = pulse_width;\n  timer_oc_config.OCPolarity = TIM_OCPOLARITY_HIGH;\n  timer_oc_config.OCNPolarity = TIM_OCNPOLARITY_HIGH;\n  timer_oc_config.OCFastMode = TIM_OCFAST_DISABLE;\n  timer_oc_config.OCIdleState = TIM_OCIDLESTATE_RESET;\n  timer_oc_config.OCNIdleState = TIM_OCNIDLESTATE_RESET;\n  timer_handle = &timer_obj->handle;\n  timer_obj->timer = (TIM_TypeDef_conflict *)0x40000000;\n  timer_handle->Instance = (TIM_TypeDef_conflict *)0x40000000;\n  timer_handle->Init.Period = period;\n  timer_clk_freq = getTimerClkFreq((TIM_TypeDef_conflict *)0x40000000);\n  timer_handle->Init.Prescaler = (uint32_t)((uint64_t)PTR_DAT_080076dc * (uint64_t)timer_clk_freq >> 0x32) - 1;\n  timer_handle->Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;\n  timer_handle->Init.CounterMode = TIM_COUNTERMODE_UP;\n  timer_handle->Init.RepetitionCounter = 0;\n  timer_obj->irqHandleOC = irq_handler;\n  timer_oc_config.OCMode = TIM_OCMODE_PWM1;\n  timer_oc_config.OCPolarity = TIM_OCPOLARITY_HIGH;\n  timer_oc_config.OCFastMode = TIM_OCFAST_DISABLE;\n  timer_oc_config.OCNPolarity = TIM_OCNPOLARITY_HIGH;\n  timer_oc_config.OCIdleState = TIM_OCIDLESTATE_RESET;\n  timer_oc_config.OCNIdleState = TIM_OCNIDLESTATE_RESET;\n  timer_oc_config.Pulse = pulse_width;\n  timer_clk_freq = getTimerIrq(timer_obj->timer);\n  HAL_NVIC_SetPriority((IRQn_Type_conflict)timer_clk_freq, 0xE, 0);\n  timer_clk_freq = getTimerIrq(timer_obj->timer);\n  HAL_NVIC_EnableIRQ((IRQn_Type_conflict)timer_clk_freq);\n  hal_status = HAL_TIM_OC_Init(timer_handle);\n  if ((hal_status == HAL_OK) && (hal_status = HAL_TIM_OC_ConfigChannel(timer_handle, &timer_oc_config, 0), hal_status == HAL_OK)) {\n    HAL_TIM_OC_Start_IT(timer_handle, 0);\n  }\n}",
            "called": [
                "HAL_TIM_OC_Init",
                "getTimerClkFreq",
                "getTimerIrq",
                "HAL_NVIC_SetPriority",
                "HAL_TIM_OC_ConfigChannel",
                "HAL_TIM_OC_Start_IT",
                "HAL_NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007648",
            "calling": [
                "initISR"
            ],
            "imported": false,
            "current_name": "initialize_timer_08007648"
        },
        "FUN_08008858": {
            "renaming": {
                "FUN_08008858": "calculate_checksum_08008858",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "buffer",
                "len_UNUSED": "buffer_length"
            },
            "code": "int calculate_checksum_08008858(int file_descriptor, char *buffer, int buffer_length)\n{\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008858",
            "calling": [
                "_read_r"
            ],
            "imported": false,
            "current_name": "calculate_checksum_08008858"
        },
        "FUN_08004a20": {
            "renaming": {
                "FUN_08004a20": "do_nothing_08004a20"
            },
            "code": "\nvoid do_nothing_08004a20(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a20",
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a20"
        },
        "FUN_08004a24": {
            "renaming": {
                "FUN_08004a24": "transmit_byte_08004a24",
                "hi2c": "i2c_handle",
                "HVar1": "current_state",
                "pbVar2": "data_ptr"
            },
            "code": "HAL_StatusTypeDef_conflict transmit_byte_08004a24(I2C_HandleTypeDef_conflict *i2c_handle) {\n  HAL_I2C_StateTypeDef_conflict current_state = i2c_handle->State;\n  if (i2c_handle->XferCount != 0) {\n    byte *data_ptr = i2c_handle->pBuffPtr;\n    i2c_handle->pBuffPtr = data_ptr + 1;\n    i2c_handle->Instance->DR = (uint)*data_ptr;\n    i2c_handle->XferCount--;\n    if ((i2c_handle->XferCount == 0) && (current_state == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2c_handle->Instance->CR2 &= 0xfffffbff;\n      i2c_handle->PreviousState = 0x21;\n      i2c_handle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(i2c_handle);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a24",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "transmit_byte_08004a24"
        },
        "FUN_08004a22": {
            "renaming": {
                "FUN_08004a22": "do_nothing_08004a22"
            },
            "code": "\nvoid do_nothing_08004a22(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a22",
            "calling": [
                "I2C_Slave_AF",
                "I2C_SlaveTransmit_TXE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a22"
        },
        "FUN_08002fba": {
            "renaming": {
                "FUN_08002fba": "getPinState_08002fba",
                "pin": "pinNumber",
                "this": "firmataObject",
                "pinState": "pinStateArray"
            },
            "code": "int __thiscall firmata::FirmataClass::getPinState_08002fba(FirmataClass *this, byte pin)\n{\n  return this->pinState[pin];\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fba",
            "calling": [
                "digitalWriteCallback",
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "getPinState_08002fba"
        },
        "FUN_080090cc": {
            "renaming": {
                "FUN_080090cc": "print_assertion_failed_080090cc",
                "param_1": "error_code",
                "param_2": "line",
                "param_3": "value",
                "param_4": "expression",
                "puVar1": "value_description",
                "puVar2": "function_name",
                "PTR_s__08009104": "assertion",
                "PTR_s___function__080090fc": "default_function_name",
                "PTR_s_assertion___s__failed__file___s__08009100": "assertion_format_string",
                "PTR__impure_ptr_080090f8": "impure_ptr"
            },
            "code": "void print_assertion_failed_080090cc(FILE* output_file, char* PTR_s__08009104, char* file, int line, char* function, char* expression, char* value, int error_code) {\n  char* value_description = value ? value : \"\";\n  char* function_name = function ? function : \"\";\n  char* file_name = file ? file : \"\";\n  fprintf(output_file, PTR_s__08009104, file_name, line, function_name, expression, value_description, error_code);\n  abort();\n}",
            "called": [
                "fiprintf",
                "abort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090cc",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "print_assertion_failed_080090cc"
        },
        "FUN_080049e0": {
            "renaming": {
                "FUN_080049e0": "set_i2c_to_listen_mode_080049e0",
                "hi2c": "i2c_handle",
                "pIVar1": "i2c_instance"
            },
            "code": "HAL_StatusTypeDef_conflict set_i2c_to_listen_mode_080049e0(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  I2C_TypeDef_conflict *i2c_instance;\n  if (i2c_handle->State != HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  i2c_handle->State = HAL_I2C_STATE_LISTEN;\n  i2c_instance = i2c_handle->Instance;\n  if ((i2c_instance->CR1 & 1) == 0) {\n    i2c_instance->CR1 = i2c_instance->CR1 | 1;\n  }\n  i2c_instance->CR1 |= 0x400;\n  i2c_instance->CR2 |= 0x300;\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080049e0",
            "calling": [
                "i2c_attachSlaveRxEvent",
                "i2c_attachSlaveTxEvent",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "imported": false,
            "current_name": "set_i2c_to_listen_mode_080049e0"
        },
        "FUN_08006d24": {
            "renaming": {
                "FUN_08006d24": "update_ADC_status_08006d24",
                "hadc": "adc_handle",
                "iVar1": "adc_status_memory_location",
                "DAT_08006d7c": "adc_status_memory_location_initial_value",
                "DAT_08006d74": "adc_instance_memory_location",
                "DAT_08006d78": "second_adc_instance_memory_location",
                "uint": "unsigned_integer"
            },
            "code": "void update_ADC_status_08006d24(ADC_HandleTypeDef *adc_handle)\n{\n  int adc_status_memory_location = DAT_08006d7c;\n  if (adc_handle->Instance != DAT_08006d74) {\n    if (adc_handle->Instance == DAT_08006d78) {\n      *(uint *)(adc_status_memory_location + 0xc) = *(uint *)(adc_status_memory_location + 0xc) | 0x400;\n      *(uint *)(adc_status_memory_location + 0xc) = *(uint *)(adc_status_memory_location + 0xc) & 0xfffffbff;\n      *(uint *)(adc_status_memory_location + 0x18) = *(uint *)(adc_status_memory_location + 0x18) & 0xfffffbff;\n      *(uint *)(adc_status_memory_location + 0x18) = *(uint *)(adc_status_memory_location + 0x18) & 0xfffffbff;\n    }\n    return;\n  }\n  *(uint *)(adc_status_memory_location + 0xc) = *(uint *)(adc_status_memory_location + 0xc) | 0x200;\n  *(uint *)(adc_status_memory_location + 0xc) = *(uint *)(adc_status_memory_location + 0xc) & 0xfffffdff;\n  *(uint *)(adc_status_memory_location + 0x18) = *(uint *)(adc_status_memory_location + 0x18) & 0xfffffdff;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006d24",
            "calling": [
                "HAL_ADC_DeInit"
            ],
            "imported": false,
            "current_name": "update_ADC_status_08006d24"
        },
        "FUN_08008500": {
            "renaming": {
                "FUN_08008500": "transmit_data_08008500",
                "*data": "data",
                "size": "size",
                "PinName_conflict": "PinName",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "uint32_t": "uint32_t",
                "void *": "void *",
                "uint": "uint8_t",
                "uVar2": "start_time",
                "PTR_digitalPin_080085a8": "PIN_MAP",
                "pin": "pin_name",
                "pinmap_peripheral": "pinmap_peripheral",
                "PinMap_conflict": "PinMap_UART_TX",
                "PTR_PinMap_UART_TX_080085ac": "PinMap_UART_TX",
                "pvVar3": "uart_tx_pin",
                "uart_handlers": "uart_handlers",
                "PTR_uart_handlers_080085b0": "uart_handlers",
                "uVar5": "uart_index",
                "byte": "uint8_t",
                "PTR_serial_debug_080085b4": "serial_debug_level",
                "HAL_UART_Transmit": "HAL_UART_Transmit",
                "HAL_OK": "HAL_OK"
            },
            "code": "size_t transmit_data_08008500(uint8_t *data, uint32_t size) {\n  PinName pin_name;\n  HAL_StatusTypeDef hal_status;\n  uint32_t start_time = HAL_GetTick();\n  pin_name = digitalPinToPinName(PTR_digitalPin_080085a8[1].pin);\n  void *uart_tx_pin = pinmap_peripheral(pin_name, PTR_PinMap_UART_TX_080085ac);\n  if (uart_tx_pin == NULL) {\n    return 0;\n  }\n  uint8_t uart_index = 0;\n  while ((uart_index < 5) && ((PTR_uart_handlers_080085b0[uart_index] == NULL) || (*(void **)PTR_uart_handlers_080085b0[uart_index] != uart_tx_pin))) {\n    uart_index++;\n  }\n  if (uart_index > 4) {\n    if ((PTR_serial_debug_080085b4 > 4) && (uart_debug_init(), PTR_serial_debug_080085b4 > 4)) {\n      return 0;\n    }\n    uart_index = PTR_serial_debug_080085b4;\n  }\n  do {\n    hal_status = HAL_UART_Transmit(PTR_uart_handlers_080085b0[uart_index], data, (uint16_t)size, 1000);\n    if (hal_status == HAL_OK) {\n      return size;\n    }\n  } while (HAL_GetTick() - start_time < 1000);\n  return 0;\n}",
            "called": [
                "HAL_GetTick",
                "uart_debug_init",
                "pinmap_peripheral",
                "HAL_UART_Transmit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008500",
            "calling": [
                "_write"
            ],
            "imported": false,
            "current_name": "transmit_data_08008500"
        },
        "FUN_08007774": {
            "renaming": {
                "FUN_08007774": "handle_timer_interrupt_08007774",
                "PTR_timer_handles_08007784": "PTR_timer_handles",
                "TIM_HandleTypeDef_conflict": "TimerHandleTypeDef",
                "timer_handle": "timer_handle",
                "HAL_TIM_IRQHandler": "handle_timer_interrupt_request"
            },
            "code": "void handle_timer_interrupt_08007774(void)\n{\n  TIM_HandleTypeDef_conflict* timer_handle = *(TIM_HandleTypeDef_conflict**)(PTR_timer_handles_08007784_08007784 + 4);\n  if (timer_handle != NULL) {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007774",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08007774"
        },
        "FUN_08005e6c": {
            "renaming": {
                "FUN_08005e6c": "do_nothing_08005e6c"
            },
            "code": "\nvoid do_nothing_08005e6c(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e6c",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08005e6c"
        },
        "FUN_080001a8": {
            "renaming": {
                "FUN_080001a8": "checkAndSetPinState_080001a8",
                "pin": "pinNumber",
                "value": "pinValue",
                "bVar1": "isPinValid",
                "bVar2": "pinMode",
                "ulPin": "digitalPin"
            },
            "code": "void checkAndSetPinState_080001a8(byte pin, int value) {\n  bool isPinValid;\n  byte pinMode;\n  uint digitalPin;\n\n  digitalPin = (uint)pin;\n  if (digitalPin < 0x3c) {\n    if (PTR_digitalPin_0800020c[digitalPin] == NC) {\n      isPinValid = false;\n    }\n    else {\n      uint32_t pinIndex = pinNametoDigitalPin(PTR_digitalPin_0800020c[digitalPin]);\n      if (pinIndex == 0 || pinIndex == 1) {\n        isPinValid = false;\n      }\n      else {\n        isPinValid = true;\n      }\n    }\n  }\n  else {\n    isPinValid = false;\n  }\n  if (isPinValid && (pinMode = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000210, pin), pinMode == '\\x01')) {\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_08000210, pin, value);\n    digitalWrite(digitalPin, value);\n  }\n}",
            "called": [
                "digitalWrite",
                "pinNametoDigitalPin",
                "setPinState",
                "getPinMode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080001a8",
            "calling": [],
            "imported": false,
            "current_name": "checkAndSetPinState_080001a8"
        },
        "FUN_080048c8": {
            "renaming": {
                "FUN_080048c8": "i2c_listen_080048c8",
                "hi2c": "i2c_handle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "transfer_options",
                "HVar1": "status",
                "pIVar2": "i2c_instance",
                "tmpreg": "tmpreg"
            },
            "code": "HAL_StatusTypeDef_conflict i2c_listen_080048c8(I2C_HandleTypeDef_conflict *i2c_handle, uint8_t *data, uint16_t size, uint32_t transfer_options)\n{\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *i2c_instance;\n  uint32_t tmpreg;\n  if (i2c_handle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == NULL) {\n      status = HAL_ERROR;\n    }\n    else if (size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2c_handle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2c_handle->Lock = HAL_LOCKED;\n      i2c_instance = i2c_handle->Instance;\n      if ((i2c_instance->CR1 & 1) == 0) {\n        i2c_instance->CR1 = i2c_instance->CR1 | 1;\n      }\n      i2c_handle->Instance->CR1 = i2c_handle->Instance->CR1 & 0xfffff7ff;\n      i2c_handle->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      i2c_handle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2c_handle->ErrorCode = 0;\n      i2c_handle->pBuffPtr = data;\n      i2c_handle->XferCount = size;\n      i2c_handle->XferOptions = transfer_options;\n      i2c_handle->XferSize = i2c_handle->XferCount;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      i2c_handle->Instance->CR2 = i2c_handle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080048c8",
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "imported": false,
            "current_name": "i2c_listen_080048c8"
        },
        "FUN_08009954": {
            "renaming": {
                "FUN_08009954": "copy_string_08009954",
                "__dest": "destination",
                "__src": "source",
                "__n": "num_chars_to_copy",
                "cVar1": "current_char",
                "sVar2": "num_chars_copied",
                "pcVar3": "destination",
                "pcVar4": "destination_start"
            },
            "code": "char* copy_string_08009954(char* destination, const char* source, size_t num_chars_to_copy)\n{\n  char current_char;\n  size_t num_chars_copied = 0;\n  char* destination_start = destination;\n  do \n  {\n    current_char = *source;\n    *destination = current_char;\n    destination++;\n    source++;\n    num_chars_copied++;\n  } while (current_char != '\\0' && num_chars_copied < num_chars_to_copy);\n  for (; num_chars_copied < num_chars_to_copy; num_chars_copied++)\n  {\n    *destination = '\\0';\n    destination++;\n  }\n  return destination_start;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009954",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "copy_string_08009954"
        },
        "FUN_08005e6e": {
            "renaming": {
                "FUN_08005e6e": "handle_tim_interrupts_08005e6e",
                "htim": "tim_handle",
                "pTVar1": "tim_instance",
                "SR": "status_register",
                "DIER": "interrupt_enable_register",
                "Instance": "tim_instance",
                "Channel": "active_channel"
            },
            "code": "void handle_tim_interrupts_08005e6e(TIM_HandleTypeDef_conflict *htim)\n{\n    TIM_TypeDef_conflict *tim_instance = htim->Instance;\n    \n    if (((tim_instance->SR & TIM_FLAG_CC1) != 0) && ((tim_instance->DIER & TIM_IT_CC1) != 0)) {\n        tim_instance->SR = ~(TIM_FLAG_CC1);\n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) == 0) {\n            HAL_TIM_OC_DelayElapsedCallback(htim);\n            HAL_TIM_PWM_PulseFinishedCallback(htim);\n        }\n        else {\n            HAL_TIM_IC_CaptureCallback(htim);\n        }\n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n    }\n    \n    if (((tim_instance->SR & TIM_FLAG_CC2) != 0) && ((tim_instance->DIER & TIM_IT_CC2) != 0)) {\n        tim_instance->SR = ~(TIM_FLAG_CC2);\n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) == 0) {\n            HAL_TIM_OC_DelayElapsedCallback(htim);\n            HAL_TIM_PWM_PulseFinishedCallback(htim);\n        }\n        else {\n            HAL_TIM_IC_CaptureCallback(htim);\n        }\n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n    }\n    \n    if (((tim_instance->SR & TIM_FLAG_CC3) != 0) && ((tim_instance->DIER & TIM_IT_CC3) != 0)) {\n        tim_instance->SR = ~(TIM_FLAG_CC3);\n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n        if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) == 0) {\n            HAL_TIM_OC_DelayElapsedCallback(htim);\n            HAL_TIM_PWM_PulseFinishedCallback(htim);\n        }\n        else {\n            HAL_TIM_IC_CaptureCallback(htim);\n        }\n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n    }\n    \n    if (((tim_instance->SR & TIM_FLAG_CC4) != 0) && ((tim_instance->DIER & TIM_IT_CC4) != 0)) {\n        tim_instance->SR = ~(TIM_FLAG_CC4);\n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n        if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) == 0) {\n            HAL_TIM_OC_DelayElapsedCallback(htim);\n            HAL_TIM_PWM_PulseFinishedCallback(htim);\n        }\n        else {\n            HAL_TIM_IC_CaptureCallback(htim);\n        }\n        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n    }\n    \n    if (((tim_instance->SR & TIM_FLAG_UPDATE) != 0) && ((tim_instance->DIER & TIM_IT_UPDATE) != 0)) {\n        tim_instance->SR = ~(TIM_FLAG_UPDATE);\n        HAL_TIM_PeriodElapsedCallback(htim);\n    }\n    \n    if (((tim_instance->SR & TIM_FLAG_BREAK) != 0) && ((tim_instance->DIER & TIM_IT_BREAK) != 0)) {\n        tim_instance->SR = ~(TIM_FLAG_BREAK);\n        HAL_TIMEx_BreakCallback(htim);\n    }\n    \n    if (((tim_instance->SR & TIM_FLAG_TRIGGER) != 0) && ((tim_instance->DIER & TIM_IT_TRIGGER) != 0)) {\n        tim_instance->SR = ~(TIM_FLAG_TRIGGER);\n        HAL_TIM_TriggerCallback(htim);\n    }\n    \n    if (((tim_instance->SR & TIM_FLAG_COM) != 0) && ((tim_instance->DIER & TIM_IT_COM) != 0)) {\n        tim_instance->SR = ~(TIM_FLAG_COM);\n        HAL_TIMEx_CommutationCallback(htim);\n    }\n}",
            "called": [
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIMEx_BreakCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e6e",
            "calling": [
                "TIM2_IRQHandler",
                "TIM4_IRQHandler",
                "TIM1_UP_IRQHandler",
                "TIM3_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_tim_interrupts_08005e6e"
        },
        "FUN_08004024": {
            "renaming": {
                "FUN_08004024": "set_clk_source_08004024",
                "CLKSource": "clk_source",
                "DAT_08004040": "data_register"
            },
            "code": "void set_clk_source_08004024(uint32_t clk_source)\n{\n  if (clk_source != 4) {\n    *DAT_08004040 = *DAT_08004040 & 0xfffffffb;\n    return;\n  }\n  *DAT_08004040 = *DAT_08004040 | 4;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004024",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "set_clk_source_08004024"
        },
        "FUN_08005e6a": {
            "renaming": {
                "FUN_08005e6a": "do_nothing_08005e6a"
            },
            "code": "\nvoid do_nothing_08005e6a(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e6a",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08005e6a"
        },
        "FUN_08004a1e": {
            "renaming": {
                "FUN_08004a1e": "do_nothing_08004a1e"
            },
            "code": "\nvoid do_nothing_08004a1e(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004a1e",
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "imported": false,
            "current_name": "do_nothing_08004a1e"
        },
        "FUN_08008868": {
            "renaming": {
                "FUN_08008868": "wait_indefinitely_08008868",
                "status_UNUSED": "status_unused"
            },
            "code": "void wait_indefinitely_08008868(int status_unused)\n{\n  while(true)\n  {\n    // Do nothing\n  }\n}",
            "called": [
                "_exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008868",
            "calling": [
                "abort",
                "_exit"
            ],
            "imported": false,
            "current_name": "wait_indefinitely_08008868"
        },
        "FUN_080036ac": {
            "renaming": {
                "FUN_080036ac": "find_digital_pin_080036ac",
                "p": "pin",
                "uVar1": "index",
                "PTR_digitalPin_080036d0": "digital_pin_array"
            },
            "code": "uint32_t find_digital_pin_080036ac(PinName_conflict pin) {\n  uint32_t index;\n  if ((uint)((int)pin << 0x18) >> 0x1c < 5) {\n    for (index = 0; (index < 0x3c && ((int)pin != (int)(char)PTR_digitalPin_080036d0[index])); index++) {\n    }\n  }\n  else {\n    index = 0xffffffff;\n  }\n  return index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036ac",
            "calling": [
                "enableI2CPins",
                "checkDigitalInputs",
                "loop",
                "digitalWriteCallback",
                "sysexCallback",
                "systemResetCallback",
                "analogWriteCallback",
                "setPinValueCallback",
                "setPinModeCallback",
                "reportDigitalCallback"
            ],
            "imported": false,
            "current_name": "find_digital_pin_080036ac"
        },
        "FUN_0800885c": {
            "renaming": {
                "FUN_0800885c": "send_uart_debug_message_0800885c",
                "file_UNUSED": "file_descriptor_unused",
                "ptr": "message_pointer",
                "len": "message_length",
                "sVar1": "message_size"
            },
            "code": "int send_uart_debug_message_0800885c(int file_descriptor_unused, char *message_pointer, int message_length) {\n  size_t message_size;\n  message_size = send_uart_debug_message_0800885c((uint8_t *)message_pointer, message_length);\n  return message_size;\n}",
            "called": [
                "uart_debug_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800885c",
            "calling": [
                "_write_r"
            ],
            "imported": false,
            "current_name": "send_uart_debug_message_0800885c"
        },
        "FUN_0800643c": {
            "renaming": {
                "FUN_0800643c": "set_tim_channel_0800643c",
                "htim": "timer_handle",
                "Channel": "channel",
                "BDTR": "TIM_BDTR_MOE",
                "CR1": "TIM_CR1_CEN",
                "Instance": "timer_handle->Instance",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "code": "HAL_StatusTypeDef set_tim_channel_0800643c(TIM_HandleTypeDef *timer_handle, uint32_t channel)\n{\n  TIM_CCxNChannelCmd(timer_handle->Instance, channel, TIM_CCxN_ENABLE);\n  timer_handle->Instance->BDTR |= TIM_BDTR_MOE;\n  timer_handle->Instance->CR1 |= TIM_CR1_CEN;\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800643c",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "set_tim_channel_0800643c"
        },
        "FUN_08002fca": {
            "renaming": {
                "FUN_08002fca": "blinkPin_08002fca",
                "pin": "pinNumber",
                "count": "blinkCount",
                "onInterval": "onTime",
                "offInterval": "offTime",
                "uVar1": "count"
            },
            "code": "void __thiscall firmata::FirmataClass::blinkPin_08002fca(FirmataClass *this, byte pin, int blinkCount, int onTime, int offTime) {\n  uint8_t count = 0;\n  while (count < blinkCount) {\n    delay(offTime);\n    digitalWrite((uint8_t)pin, HIGH);\n    delay(onTime);\n    digitalWrite((uint8_t)pin, LOW);\n    count++;\n  }\n  return;\n}",
            "called": [
                "delay",
                "digitalWrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fca",
            "calling": [
                "blinkVersion"
            ],
            "imported": false,
            "current_name": "blinkPin_08002fca"
        },
        "FUN_0800a31c": {
            "renaming": {
                "std::ctype_byname<wchar_t>::FUN_0800a31c": "set_wchar_t_ctype_flags",
                "FUN_0800a31c": "set_wchar_t_ctype_flags_0800a31c"
            },
            "code": "void set_wchar_t_ctype_flags_0800a31c()\n{\n    if (-1 < *(int *)PTR_id_0800a380 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a380 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a384 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a384 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a388 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a388 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a38c << 0x1f) {\n        *(undefined4 *)PTR_id_0800a38c = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a390 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a390 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a394 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a394 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a398 << 0x1f) {\n        *(undefined4 *)PTR_id_0800a398 = 1;\n    }\n    if (-1 < *(int *)PTR_id_0800a39c << 0x1f) {\n        *(undefined4 *)PTR_id_0800a39c = 1;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a31c",
            "calling": [],
            "imported": false,
            "current_name": "set_wchar_t_ctype_flags_0800a31c"
        },
        "FUN_080026f8": {
            "renaming": {
                "FUN_080026f8": "servo_is_enabled_080026f8",
                "this": "servo",
                "PTR_servos_08002708": "servo_ptr",
                "servoIndex": "servo_index",
                "shifted_value": "shifted_value"
            },
            "code": "bool servo_is_enabled_080026f8(Servo *servo) {\n    uint8_t *PTR_servos_08002708 = PTR_servos_08002708 + ((uint)servo->servoIndex * 8);\n    uint32_t shifted_value = ((uint32_t)(*PTR_servos_08002708) << 0x19) >> 0x1f;\n    return (bool) shifted_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080026f8",
            "calling": [
                "sysexCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "servo_is_enabled_080026f8"
        },
        "FUN_08007544": {
            "renaming": {
                "FUN_08007544": "get_timer_status_08007544",
                "tim": "timer",
                "DAT_08007588": "timer1",
                "DAT_0800758c": "timer2"
            },
            "code": "uint32_t get_timer_status_08007544(TIM_TypeDef_conflict *timer) {\n  if (timer == (TIM_TypeDef_conflict *)0xffffffff) {\n    return 0;\n  }\n  if (timer == DAT_08007588) {\n    return 0x1d;\n  }\n  if (DAT_08007588 < timer) {\n    if (timer == DAT_0800758c) {\n      return 0x1e;\n    }\n    if (timer == (TIM_TypeDef_conflict *)&DAT_0800758c[0x379].DMAR) {\n      return 0x19;\n    }\n  }\n  else if (timer == (TIM_TypeDef_conflict *)0x40000000) {\n    return 0x1c;\n  }\n  iprintf(PTR_s_TIM__Unknown_timer_IRQn_08007590);\n  return 0;\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007544",
            "calling": [
                "TimerPulseDeinit",
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "get_timer_status_08007544"
        },
        "FUN_08008990": {
            "renaming": {
                "FUN_08008990": "configure_digital_pin_08008990",
                "ulPin": "pin_number",
                "ulMode": "mode",
                "_Var1": "is_pin_PWM",
                "pin": "pin",
                "PTR_digitalPin_08008a14": "digitalPinName",
                "NC": "NC",
                "is_pin_configured": "is_pin_already_configured",
                "PTR_g_anOutputPinConfigured_08008a18": "g_anOutputPinConfigured",
                "is_pin_PWM": "is_pin_in_PWM_pinmap",
                "PinMap_conflict": "PinMap_PWM",
                "pwm_stop": "pwm_stop",
                "reset_pin_configured": "reset_pin_configured",
                "digital_io_init": "digital_io_init",
                "set_pin_configured": "set_pin_configured",
                "PTR_g_digPinConfigured_08008a20": "g_digPinConfigured"
            },
            "code": "void configure_digital_pin_08008990(uint32_t pin_number, uint32_t mode)\n{\n    PinName_conflict pin;\n    if (pin_number < 0x3c) {\n        pin = PTR_digitalPin_08008a14[pin_number];\n    }\n    else {\n        pin = NC;\n    }\n    if (pin != NC) {\n        bool is_pin_configured = is_pin_already_configured(pin, (uint32_t *)PTR_g_anOutputPinConfigured_08008a18);\n        if (is_pin_configured) {\n            bool is_pin_PWM = is_pin_in_PWM_pinmap(pin, (PinMap_conflict *)PinMap_PWM);\n            if (is_pin_PWM) {\n                pwm_stop(pin);\n            }\n            reset_pin_configured(pin, (uint32_t *)PTR_g_anOutputPinConfigured_08008a18);\n        }\n        switch(mode) {\n            case 0:\n                digital_io_init(pin, 0, 0);\n                break;\n            case 1:\n                digital_io_init(pin, 1, 0);\n                break;\n            case 2:\n                digital_io_init(pin, 0, 1);\n                break;\n            case 3:\n                digital_io_init(pin, 0, 2);\n        }\n        set_pin_configured(pin, (uint32_t *)PTR_g_digPinConfigured_08008a20);\n    }\n    return;\n}",
            "called": [
                "pwm_stop",
                "pin_in_pinmap",
                "digital_io_init",
                "set_pin_configured",
                "reset_pin_configured",
                "is_pin_configured"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008990",
            "calling": [
                "attach",
                "analogWrite",
                "digitalWriteCallback",
                "blinkVersion",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "configure_digital_pin_08008990"
        },
        "FUN_08004396": {
            "renaming": {
                "FUN_08004396": "write_i2c_device_address_08004396",
                "hi2c": "i2c_handle",
                "Instance": "i2c_instance",
                "DR": "data_register",
                "Devaddress": "device_address"
            },
            "code": "HAL_StatusTypeDef write_i2c_device_address_08004396(I2C_HandleTypeDef *i2c_handle)\n{\n  uint8_t device_address = i2c_handle->Devaddress & 0xff;\n  i2c_handle->Instance->DR = device_address;\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004396",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "write_i2c_device_address_08004396"
        },
        "FUN_08003fb0": {
            "renaming": {
                "FUN_08003fb0": "set_interrupt_enable_bit_08003fb0",
                "IRQn_Type_conflict": "irq",
                "uVar1": "irq_num",
                "DAT_08003fd4": "interrupt_enable_base",
                "interrupt_enable_reg": "interrupt_enable_register"
            },
            "code": "void set_interrupt_enable_bit_08003fb0(IRQn_Type_conflict irq) {\n  uint irq_num = (uint)irq;\n  if (irq_num >= 0) {\n    int* interrupt_enable_reg = (int*)(DAT_08003fd4 + ((irq_num >> 5) + 0x20) * 4);\n    *interrupt_enable_reg = 1 << (irq_num & 0x1f);\n    DataSynchronizationBarrier(0xf);\n    InstructionSynchronizationBarrier(0xf);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003fb0",
            "calling": [
                "TimerPulseDeinit"
            ],
            "imported": false,
            "current_name": "set_interrupt_enable_bit_08003fb0"
        },
        "FUN_08007788": {
            "renaming": {
                "FUN_08007788": "handle_timer_interrupt_08007788",
                "PTR_timer_handles_08007798": "PTR_timer_handles",
                "TIM_HandleTypeDef_conflict": "TimerHandleConflict"
            },
            "code": "void handle_timer_interrupt_08007788(void)\n{\n  TIM_HandleTypeDef_conflict* timer_handle = *(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_08007798_08007798 + 8);\n  if (timer_handle != NULL) {\n    HAL_TIM_IRQHandler(timer_handle);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007788",
            "calling": [],
            "imported": false,
            "current_name": "handle_timer_interrupt_08007788"
        },
        "FUN_08008f0c": {
            "renaming": {
                "FUN_08008f0c": "do_nothing_08008f0c"
            },
            "code": "\nvoid do_nothing_08008f0c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f0c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "do_nothing_08008f0c"
        },
        "FUN_08002ec4": {
            "renaming": {
                "FUN_08002ec4": "printData_08002ec4",
                "this": "firmataObj",
                "iVar1": "printResult",
                "FirmataStream": "firmataStream",
                "_vptr_Print": "virtualFunctionTable_Print"
            },
            "code": "int __thiscall firmata::FirmataClass::printData_08002ec4(FirmataClass *firmataObj) { \n  int printResult; \n  printResult = (*(firmataObj->FirmataStream->super_Print)._vptr_Print[2])(); \n  return printResult; \n }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ec4",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "printData_08002ec4"
        },
        "FUN_08007306": {
            "renaming": {
                "FUN_08007306": "get_peripheral_from_pin_08007306",
                "pin": "target_pin",
                "map": "pin_map"
            },
            "code": "void* get_peripheral_from_pin_08007306(PinName_conflict target_pin, PinMap_conflict* pin_map) {\n  while (true) {\n    if (pin_map->pin == NC) {\n      return (void*)0x0;\n    }\n    if (pin_map->pin == target_pin) break;\n    pin_map++;\n  }\n  return pin_map->peripheral;\n}",
            "called": [
                "pinmap_find_peripheral"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007306",
            "calling": [
                "pinmap_peripheral",
                "pinmap_find_peripheral"
            ],
            "imported": false,
            "current_name": "get_peripheral_from_pin_08007306"
        },
        "FUN_08008f0e": {
            "renaming": {
                "FUN_08008f0e": "initialize_EVP_PKEY_CTX_08008f0e",
                "ctx": "context",
                "PTR_": "no renaming",
                "DAT_": "no renaming"
            },
            "code": "void initialize_EVP_PKEY_CTX_08008f0e(void)\n{\n  EVP_PKEY_CTX *context;\n  context = (EVP_PKEY_CTX *)0x3;\n  HAL_NVIC_SetPriorityGrouping(3);\n  init(context);\n  return;\n}",
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f0e",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "initialize_EVP_PKEY_CTX_08008f0e"
        },
        "FUN_0800886c": {
            "renaming": {
                "FUN_0800886c": "set_errno_0800886c",
                "pid_UNUSED": "unused_pid",
                "sig_UNUSED": "unused_sig",
                "PTR_errno_08008878": "PTR_errno",
                "undefined4": "Errno_value"
            },
            "code": "int set_errno_0800886c(int pid_UNUSED, int sig_UNUSED)\n{\n    *(undefined4 *)PTR_errno_08008878_08008878 = 0x16;\n    return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800886c",
            "calling": [
                "_kill_r"
            ],
            "imported": false,
            "current_name": "set_errno_0800886c"
        },
        "FUN_080036d4": {
            "renaming": {
                "FUN_080036d4": "do_nothing_080036d4"
            },
            "code": "\nvoid do_nothing_080036d4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036d4",
            "calling": [
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_080036d4"
        },
        "FUN_08006e68": {
            "renaming": {
                "FUN_08006e68": "FUNC_08006e68"
            },
            "code": "\nvoid FUNC_08006e68(TIM_HandleTypeDef_conflict *htim)\n\n{\n  undefined *puVar1;\n  uint32_t uVar2;\n  GPIO_TypeDef *GPIOx;\n  uint32_t tmpreg;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  puVar1 = PTR_g_current_pin_08007100;\n  uVar2 = pinmap_function(*PTR_g_current_pin_08007100,(PinMap_conflict *)PTR_PinMap_PWM_08007104);\n  timer_enable_clock(htim);\n  GPIOx = set_GPIO_Port_Clock((uint)((int)(char)*puVar1 << 0x18) >> 0x1c);\n  GPIO_InitStruct.Mode = 2;\n  GPIO_InitStruct.Pull = 0;\n  GPIO_InitStruct.Speed = 3;\n  *(uint *)(DAT_08007108 + 0x18) = *(uint *)(DAT_08007108 + 0x18) | 1;\n  switch((uVar2 << 0x11) >> 0x19) {\n  case 1:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000001;\n    break;\n  case 2:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffe | 0x7000000;\n    break;\n  case 3:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000002;\n    break;\n  case 4:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffd | 0x7000000;\n    break;\n  case 5:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000004;\n    break;\n  case 6:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffffb | 0x7000000;\n    break;\n  case 7:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000008;\n    break;\n  case 8:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffff7 | 0x7000000;\n    break;\n  case 9:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000030;\n    break;\n  case 10:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffffcf | 0x7000010;\n    break;\n  case 0xb:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffffcf | 0x7000000;\n    break;\n  case 0xc:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x70000c0;\n    break;\n  case 0xd:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffff3f | 0x7000040;\n    break;\n  case 0xe:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffff3f | 0x7000000;\n    break;\n  case 0xf:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000300;\n    break;\n  case 0x10:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000200;\n    break;\n  case 0x11:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000100;\n    break;\n  case 0x12:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffffcff | 0x7000000;\n    break;\n  case 0x13:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7000c00;\n    break;\n  case 0x14:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffff3ff | 0x7000800;\n    break;\n  case 0x15:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xfffff3ff | 0x7000000;\n    break;\n  case 0x16:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7001000;\n    break;\n  case 0x17:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffffefff | 0x7000000;\n    break;\n  case 0x1b:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) | 0x7008000;\n    break;\n  case 0x1c:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xffff7fff | 0x7000000;\n    break;\n  case 0x21:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff;\n    break;\n  case 0x22:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x1000000;\n    break;\n  case 0x23:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x2000000;\n    break;\n  case 0x24:\n    *(uint *)(DAT_0800710c + 4) = *(uint *)(DAT_0800710c + 4) & 0xf8ffffff | 0x4000000;\n  }\n  GPIO_InitStruct.Pin = 1 << (*PTR_g_current_pin_08007100 & 0xf) & 0xffff;\n  HAL_GPIO_Init(GPIOx,&GPIO_InitStruct);\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_Init",
                "pinmap_function",
                "timer_enable_clock",
                "set_GPIO_Port_Clock"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08006e68",
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "imported": false,
            "current_name": "FUNC_08006e68"
        },
        "FUN_080036d8": {
            "renaming": {
                "FUN_080036d8": "configureSysTick_080036d8",
                "TickPriority": "tickPriority",
                "uVar1": "configResult",
                "sysTickClock": "sysTickClock",
                "tickFreq": "tickFreq",
                "sysTickConfig": "sysTickConfig"
            },
            "code": "HAL_StatusTypeDef configureSysTick_080036d8(uint32_t tickPriority)\n{\n  uint32_t sysTickClock = *(uint *)PTR_SystemCoreClock_0800371c;\n  uint32_t tickFreq = *(byte *)PTR_uwTickFreq_08003718;\n  uint32_t sysTickConfig = sysTickClock / (1000 / tickFreq);\n  uint32_t configResult = HAL_SYSTICK_Config(sysTickConfig);\n  if (configResult != 0) {\n    return HAL_ERROR;\n  }\n  if (tickPriority > 0xf) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn, tickPriority, 0);\n  *(uint32_t *)PTR_uwTickPrio_08003720 = tickPriority;\n  return HAL_OK;\n}",
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036d8",
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "imported": false,
            "current_name": "configureSysTick_080036d8"
        },
        "FUN_0800a110": {
            "renaming": {
                "FUN_0800a110": "checkIfTerminal_0800a110",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "puVar1": "errorPointer",
                "iVar2": "isTerminal"
            },
            "code": "void checkIfTerminal_0800a110(int *errorCode, int fileDescriptor)\n{\n  undefined *errorPointer = PTR_errno_0800a12c;\n  *(undefined4 *)PTR_errno_0800a12c = 0;\n  int isTerminal = _isatty(fileDescriptor);\n  if ((isTerminal == -1) && (*(int *)errorPointer != 0)) {\n    *errorCode = *(int *)errorPointer;\n  }\n  return;\n}",
            "called": [
                "_isatty"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a110",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "checkIfTerminal_0800a110"
        },
        "FUN_08003b8c": {
            "renaming": {
                "FUN_08003b8c": "check_adc_conversion_complete_08003b8c",
                "hadc": "adc_handle",
                "uVar1": "start_time",
                "uVar2": "current_time",
                "pAVar3": "adc_instance"
            },
            "code": "HAL_StatusTypeDef check_adc_conversion_complete_08003b8c(ADC_HandleTypeDef *adc_handle)\n{\n  uint32_t start_time;\n  uint32_t current_time;\n  ADC_TypeDef *adc_instance;\n  adc_instance = adc_handle->Instance;\n  if ((adc_instance->CR2 & 1) == 0) {\n    return HAL_OK;\n  }\n  adc_instance->CR2 = adc_instance->CR2 & 0xfffffffe;\n  start_time = HAL_GetTick();\n  do {\n    if ((adc_handle->Instance->CR2 & 1) == 0) {\n      return HAL_OK;\n    }\n    current_time = HAL_GetTick();\n  } while (current_time - start_time < 3);\n  adc_handle->State = adc_handle->State | 0x10;\n  adc_handle->ErrorCode = adc_handle->ErrorCode | 1;\n  return HAL_ERROR;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003b8c",
            "calling": [
                "HAL_ADC_Init",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_DeInit",
                "HAL_ADC_Stop"
            ],
            "imported": false,
            "current_name": "check_adc_conversion_complete_08003b8c"
        },
        "FUN_080035b8": {
            "renaming": {
                "FUN_080035b8": "initialize_clocks_080035b8",
                "HVar1": "status",
                "uVar2": "hclk_freq",
                "PeriphClkInit": "periph_clk_init",
                "RCC_ClkInitStruct": "clk_init_struct",
                "RCC_OscInitStruct": "osc_init_struct",
                "OscillatorType": "OscillatorType",
                "HSIState": "HSIState",
                "HSICalibrationValue": "HSICalibrationValue",
                "PLLState": "PLLState",
                "PLLSource": "PLLSource",
                "PLLMUL": "PLLMUL",
                "ClockType": "ClockType",
                "SYSCLKSource": "SYSCLKSource",
                "AHBCLKDivider": "AHBCLKDivider",
                "APB1CLKDivider": "APB1CLKDivider",
                "APB2CLKDivider": "APB2CLKDivider",
                "PeriphClockSelection": "PeriphClockSelection",
                "AdcClockSelection": "AdcClockSelection",
                "DAT_08003650": "SYSTICK_FREQ",
                "HAL_RCC_OscConfig": "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig": "HAL_RCC_ClockConfig",
                "HAL_RCCEx_PeriphCLKConfig": "HAL_RCCEx_PeriphCLKConfig",
                "HAL_RCC_GetHCLKFreq": "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_Config": "HAL_SYSTICK_Config",
                "HAL_SYSTICK_CLKSourceConfig": "HAL_SYSTICK_CLKSourceConfig",
                "HAL_NVIC_SetPriority": "HAL_NVIC_SetPriority",
                "SysTick_IRQn": "SysTick_IRQn",
                "_Error_Handler": "_Error_Handler"
            },
            "code": "void initialize_clocks_080035b8(void)\n{\n  HAL_StatusTypeDef status;\n  uint32_t hclk_freq;\n  RCC_PeriphCLKInitTypeDef periph_clk_init;\n  RCC_ClkInitTypeDef clk_init_struct;\n  RCC_OscInitTypeDef osc_init_struct;\n  osc_init_struct.OscillatorType = RCC_OSCILLATORTYPE_HSI;\n  osc_init_struct.HSIState = RCC_HSI_ON;\n  osc_init_struct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;\n  osc_init_struct.PLL.PLLState = RCC_PLL_ON;\n  osc_init_struct.PLL.PLLSource = RCC_PLLSOURCE_HSI;\n  osc_init_struct.PLL.PLLMUL = RCC_PLL_MUL16;\n  status = HAL_RCC_OscConfig(&osc_init_struct);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08003654,0x88);\n  }\n  clk_init_struct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;\n  clk_init_struct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;\n  clk_init_struct.AHBCLKDivider = RCC_SYSCLK_DIV1;\n  clk_init_struct.APB1CLKDivider = RCC_HCLK_DIV2;\n  clk_init_struct.APB2CLKDivider = RCC_HCLK_DIV1;\n  status = HAL_RCC_ClockConfig(&clk_init_struct, FLASH_LATENCY_2);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08003654,0x95);\n  }\n  periph_clk_init.PeriphClockSelection = RCC_PERIPHCLK_ADC;\n  periph_clk_init.AdcClockSelection = RCC_ADCPCLK2_DIV6;\n  status = HAL_RCCEx_PeriphCLKConfig(&periph_clk_init);\n  if (status != HAL_OK) {\n    _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08003654,0x9c);\n  }\n  hclk_freq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config((uint32_t)((uint64_t)DAT_08003650 * (uint64_t)hclk_freq / (1 << 26)));\n  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);\n  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);\n}\n",
            "called": [
                "_Error_Handler",
                "HAL_RCC_ClockConfig",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_OscConfig",
                "HAL_SYSTICK_Config",
                "HAL_RCCEx_PeriphCLKConfig",
                "HAL_NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080035b8",
            "calling": [
                "hw_config_init"
            ],
            "imported": false,
            "current_name": "initialize_clocks_080035b8"
        },
        "FUN_08006460": {
            "renaming": {
                "FUN_08006460": "disable_timer_channel_08006460",
                "htim": "timer_handle",
                "Channel": "channel",
                "pTVar1": "timer_instance"
            },
            "code": "HAL_StatusTypeDef_conflict disable_timer_channel_08006460(TIM_HandleTypeDef_conflict *timer_handle, uint32_t channel)\n{\n  TIM_TypeDef_conflict *timer_instance = timer_handle->Instance;\n  TIM_CCxNChannelCmd(timer_instance, channel, 0);\n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->BDTR &= 0xffff7fff;\n  }\n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->CR1 &= 0xfffffffe;\n  }\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006460",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "disable_timer_channel_08006460"
        },
        "FUN_08004046": {
            "renaming": {
                "FUN_08004046": "run_systick_callback_08004046"
            },
            "code": "void run_systick_callback_08004046(void)\n{\n  HAL_SYSTICK_Callback();\n  return;\n}",
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004046",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "run_systick_callback_08004046"
        },
        "FUN_08008880": {
            "renaming": {
                "FUN_08008880": "read_adc_value_08008880",
                "ulPin": "pin_number",
                "bVar1": "is_valid_pin",
                "pin": "pin",
                "uVar2": "adc_value",
                "uVar3": "result",
                "uVar4": "read_resolution"
            },
            "code": "uint32_t read_adc_value_08008880(uint32_t pin_number)\n{\n  bool is_valid_pin;\n  PinName_conflict pin;\n  uint16_t adc_value;\n  uint read_resolution;\n  uint32_t result;\n  \n  if (pin_number < 0xe) {\n    if (pin_number + 0x2e < 0x3c) {\n      is_valid_pin = true;\n    }\n    else {\n      is_valid_pin = false;\n    }\n  }\n  else {\n    is_valid_pin = pin_number < 0x3c;\n  }\n  if (is_valid_pin) {\n    if (pin_number < 0xe) {\n      pin_number = pin_number + 0x2e;\n    }\n    pin = PTR_digitalPin_080088d8[pin_number];\n  }\n  else {\n    pin = NC;\n  }\n  if (pin == NC) {\n    result = 0;\n  }\n  else {\n    adc_value = adc_read_value(pin);\n    result = (uint32_t)adc_value;\n    read_resolution = *(uint *)PTR__readResolution_080088dc;\n    if (read_resolution != 0xc) {\n      if (read_resolution < 0xc) {\n        return (uint)(adc_value >> (0xc - read_resolution & 0xff));\n      }\n      return result << (read_resolution - 0xc & 0xff);\n    }\n  }\n  return result;\n}",
            "called": [
                "adc_read_value"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008880",
            "calling": [
                "reportAnalogCallback",
                "loop"
            ],
            "imported": false,
            "current_name": "read_adc_value_08008880"
        },
        "FUN_08004044": {
            "renaming": {
                "FUN_08004044": "do_nothing_08004044"
            },
            "code": "\nvoid do_nothing_08004044(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004044",
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08004044"
        },
        "FUN_08002ed2": {
            "renaming": {
                "FUN_08002ed2": "parseSerialData_08002ed2",
                "this": "firmataInstance",
                "iVar1": "incomingByte",
                "FirmataParser::parse": "parseFirmata",
                "this->parser": "firmataInstance->parser",
                "this->FirmataStream->super_Print": "firmataInstance->FirmataStream->super_Print"
            },
            "code": "void __thiscall FirmataClass::parseSerialData_08002ed2(FirmataClass *firmataInstance) {\n  int incomingByte = (*(firmataInstance->FirmataStream->super_Print)._vptr_Print[3])();\n  if (incomingByte != -1) {\n    FirmataParser::parse(&firmataInstance->parser,(uint8_t)incomingByte);\n  }\n  return;\n}",
            "called": [
                "parse"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002ed2",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "parseSerialData_08002ed2"
        },
        "FUN_08008f1c": {
            "renaming": {
                "FUN_08008f1c": "main_loop_08008f1c",
                "DAT_08008f38": "continue_looping",
                "serialEventRun": "run_serial_events"
            },
            "code": "int main_loop_08008f1c(void)\n{\n  init_variant();\n  setup();\n  do {\n    do {\n      loop();\n    } while (DAT_08008f38 == 0);\n    run_serial_events();\n  } while( true );\n}",
            "called": [
                "loop",
                "initVariant",
                "serialEventRun",
                "setup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008f1c",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "main_loop_08008f1c"
        },
        "FUN_080058ac": {
            "renaming": {
                "FUN_080058ac": "configureClocks_080058ac",
                "RCC_ClkInitTypeDef_conflict": "RCC_ClkInitTypeDef",
                "RCC_ClkInitStruct": "clock_init_struct",
                "FLatency": "flash_latency",
                "puVar1": "flash_latency_ptr",
                "uVar2": "timeout",
                "uVar3": "current_tick",
                "uVar4": "sysclk_source"
            },
            "code": "HAL_StatusTypeDef configureClocks_080058ac(RCC_ClkInitTypeDef* clock_init_struct, uint32_t flash_latency)\n{\n    uint32_t* flash_latency_ptr = DAT_08005a0c;\n    uint32_t current_flash_latency = *flash_latency_ptr & 7;\n    if (current_flash_latency < flash_latency && clock_init_struct->SYSCLKSource == 1 && (*DAT_08005a10 & 0x20000) == 0) {\n        return HAL_ERROR;\n    }\n    *flash_latency_ptr = *flash_latency_ptr & 0xfffffff8 | flash_latency;\n    if (flash_latency != current_flash_latency) {\n        return HAL_ERROR;\n    }\n    if (clock_init_struct->ClockType & RCC_CLOCKTYPE_AHB) {\n        DAT_08005a10[1] = (DAT_08005a10[1] & 0xffffff0f) | clock_init_struct->AHBCLKDivider;\n    }\n    if (clock_init_struct->ClockType & RCC_CLOCKTYPE_SYSCLK) {\n        uint32_t sysclk_source = clock_init_struct->SYSCLKSource;\n        uint32_t timeout = 5000;\n        uint32_t start_tick = HAL_GetTick();\n        while ((DAT_08005a10[1] & 0xc) != (sysclk_source << 2)) {\n            uint32_t current_tick = HAL_GetTick();\n            if (current_tick - start_tick > timeout) {\n                return HAL_TIMEOUT;\n            }\n        }\n    }\n    if (clock_init_struct->ClockType & RCC_CLOCKTYPE_APB1) {\n        DAT_08005a10[1] = (DAT_08005a10[1] & 0xfffff8ff) | (clock_init_struct->APB1CLKDivider << 8);\n    }\n    if (clock_init_struct->ClockType & RCC_CLOCKTYPE_APB2) {\n        DAT_08005a10[1] = (DAT_08005a10[1] & 0xffffc7ff) | (clock_init_struct->APB2CLKDivider << 11);\n    }\n    uint32_t sysclk_freq = HAL_RCC_GetSysClockFreq();\n    uint32_t ahb_presc_index = (DAT_08005a10[1] << 24) >> 30;\n    *(uint32_t*)PTR_SystemCoreClock_08005a18 = sysclk_freq >> PTR_AHBPrescTable_08005a14[ahb_presc_index];\n    HAL_InitTick(0xf);\n    return HAL_OK;\n}",
            "called": [
                "HAL_GetTick",
                "HAL_InitTick",
                "HAL_RCC_GetSysClockFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080058ac",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configureClocks_080058ac"
        },
        "FUN_08007438": {
            "renaming": {
                "FUN_08007438": "configure_timer_08007438",
                "htim": "timer_handle",
                "DAT_080074d0": "timer_1",
                "PTR_timer_handles_080074dc": "timer_handles_ptr",
                "TIM_TypeDef_conflict": "Timer_TypeDef",
                "_DAT_4002101c": "timer_2",
                "DAT_080074d4": "timer_3",
                "DAT_080074d8": "timer_4",
                "tmpreg": "temporary_register_1",
                "tmpreg_1": "temporary_register_2",
                "tmpreg_2": "temporary_register_3",
                "tmpreg_3": "temporary_register_4"
            },
            "code": "void configure_timer_08007438(TIM_HandleTypeDef_conflict *timer_handle) {\n  if (timer_handle->Instance == DAT_080074d0) {\n    DAT_080074d0[0x2b7].DIER |= 0x800;\n    *(TIM_HandleTypeDef_conflict **)PTR_timer_handles_080074dc = timer_handle;\n  }\n  if (timer_handle->Instance == _DAT_4002101c) {\n    _DAT_4002101c[0x0].CR1 |= 1;\n    *(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_080074dc + 4) = timer_handle;\n  }\n  if (timer_handle->Instance == DAT_080074d4) {\n    DAT_080074d4[0x63d].CCMR1 |= 2;\n    *(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_080074dc + 8) = timer_handle;\n  }\n  if (timer_handle->Instance == DAT_080074d8) {\n    DAT_080074d8[0x631].SMCR |= 4;\n    *(TIM_HandleTypeDef_conflict **)(PTR_timer_handles_080074dc + 0xc) = timer_handle;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007438",
            "calling": [
                "HAL_TIM_PWM_MspInit",
                "HAL_TIM_OC_MspInit"
            ],
            "imported": false,
            "current_name": "configure_timer_08007438"
        },
        "FUN_0800306c": {
            "renaming": {
                "FUN_0800306c": "initialize_static_data_and_destructors_0800306c"
            },
            "code": "void initialize_static_data_and_destructors_0800306c(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800306c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_data_and_destructors_0800306c"
        },
        "FUN_0800887c": {
            "renaming": {
                "FUN_0800887c": "return_one_0800887c"
            },
            "code": "__pid_t return_one_0800887c(void)\n{\n  __pid_t pid = 1;\n  return pid;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800887c",
            "calling": [
                "_getpid_r"
            ],
            "imported": false,
            "current_name": "return_one_0800887c"
        },
        "FUN_0800863c": {
            "renaming": {
                "FUN_0800863c": "receive_data_0800863c",
                "obj": "serial_obj",
                "callback": "callback_func",
                "uVar2": "rx_active",
                "bVar1": "index",
                "PTR_rx_callback_08008688": "rx_callback_ptr",
                "PTR_rx_callback_obj_0800868c": "rx_callback_obj_ptr",
                "PTR_uart_handlers_08008690": "uart_handlers_ptr"
            },
            "code": "void receive_data_0800863c(serial_t *serial_obj, _func_void_serial_t_ptr *callback_func)\n{\n  byte index;\n  uint8_t rx_active;\n  \n  if (serial_obj != NULL) {\n    rx_active = serial_rx_active(serial_obj);\n    if (rx_active == 0) {\n      index = serial_obj->index;\n      *(_func_void_serial_t_ptr **)(PTR_rx_callback_08008688 + (uint)index * 4) = callback_func;\n      *(serial_t **)(PTR_rx_callback_obj_0800868c + (uint)index * 4) = serial_obj;\n      HAL_NVIC_SetPriority(serial_obj->irq, 0, 1);\n      HAL_NVIC_EnableIRQ(serial_obj->irq);\n      HAL_UART_Receive_IT(*(UART_HandleTypeDef **)(PTR_uart_handlers_08008690 + (uint)serial_obj->index * 4), &serial_obj->recv, 1);\n    }\n    return;\n  }\n  return;\n}",
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_UART_Receive_IT",
                "HAL_NVIC_EnableIRQ",
                "serial_rx_active"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800863c",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "receive_data_0800863c"
        },
        "FUN_08004050": {
            "renaming": {
                "FUN_08004050": "clear_DMA_flags_08004050",
                "hdma": "dma_handle",
                "hdma->State": "dma_handle->State",
                "HAL_DMA_STATE_BUSY": "HAL_DMA_STATE_BUSY",
                "hdma->ErrorCode": "dma_handle->ErrorCode",
                "HAL_DMA_ERROR_BUSY": "HAL_DMA_ERROR_BUSY",
                "HAL_ERROR": "HAL_ERROR",
                "hdma->Instance->CCR": "dma_handle->Instance->CCR",
                "DMA_CCR_EN": "DMA_CCR_EN",
                "DMA_CCR_TCIE": "DMA_CCR_TCIE",
                "DMA_Channel_TypeDef": "DMA_Channel_TypeDef",
                "pDVar2": "dma_channel",
                "DAT_080040e0": "PTR_DAT_080040e0",
                "CNDTR": "CNDTR",
                "CPAR": "CPAR",
                "CMAR": "CMAR",
                "HAL_DMA_STATE_READY": "HAL_DMA_STATE_READY",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "hdma->XferAbortCallback": "dma_handle->XferAbortCallback",
                "_func_void___DMA_HandleTypeDef_ptr_conflict": "_func_void___DMA_HandleTypeDef_ptr_conflict",
                "HAL_OK": "HAL_OK"
            },
            "code": "HAL_StatusTypeDef clear_DMA_flags_08004050(DMA_HandleTypeDef *dma_handle) {\n  \n  if (dma_handle->State != HAL_DMA_STATE_BUSY) {\n    dma_handle->ErrorCode = HAL_DMA_ERROR_BUSY;\n    return HAL_ERROR;\n  }\n  dma_handle->Instance->CCR &= ~(DMA_CCR_EN | DMA_CCR_TCIE);\n  DMA_Channel_TypeDef *dma_channel = dma_handle->Instance;\n  uint32_t flag = 0;\n  if (dma_channel == DAT_080040e0) {\n    flag = 1;\n  }\n  else if (dma_channel == (DAT_080040e0 + 1)->CNDTR) {\n    flag = 0x10;\n  }\n  else if (dma_channel == (DAT_080040e0 + 2)->CPAR) {\n    flag = 0x100;\n  }\n  else if (dma_channel == (DAT_080040e0 + 3)->CMAR) {\n    flag = 0x1000;\n  }\n  else if (dma_channel == DAT_080040e0 + 5) {\n    flag = 0x10000;\n  }\n  else if (dma_channel == (DAT_080040e0 + 6)->CNDTR) {\n    flag = 0x100000;\n  }\n  else {\n    flag = 0x1000000;\n  }\n  *(uint32_t *)(PTR_DAT_080040e4 + 4) = flag;\n  dma_handle->State = HAL_DMA_STATE_READY;\n  dma_handle->Lock = HAL_UNLOCKED;\n  if (dma_handle->XferAbortCallback != NULL) {\n    (*dma_handle->XferAbortCallback)(dma_handle);\n    return HAL_OK;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004050",
            "calling": [
                "HAL_UART_IRQHandler",
                "I2C_ITError"
            ],
            "imported": false,
            "current_name": "clear_DMA_flags_08004050"
        },
        "FUN_08008e14": {
            "renaming": {
                "FUN_08008e14": "initializeIPAddress_08008e14",
                "__initialize_p": "shouldInitialize",
                "__priority": "priorityLevel",
                "PTR_INADDR_NONE_08008e3c": "invalidAddress"
            },
            "code": "void initializeIPAddress_08008e14(int shouldInitialize, int priorityLevel) {\n    if (shouldInitialize && priorityLevel == 0xffff) {\n        IPAddress::IPAddress(&PTR_INADDR_NONE_08008e3c, '\\0', '\\0', '\\0', '\\0');\n        return;\n    }\n    return;\n}",
            "called": [
                "IPAddress"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008e14",
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "imported": false,
            "current_name": "initializeIPAddress_08008e14"
        },
        "FUN_08005a28": {
            "renaming": {
                "FUN_08005a28": "calculate_HCLK_frequency_08005a28",
                "DAT_08005a40": "data_08005a40",
                "PTR_APBPrescTable_08005a44": "pointer_APB_prescaler_table_08005a44"
            },
            "code": "uint32_t calculate_HCLK_frequency_08005a28(void)\n{\n  uint32_t HCLK_frequency = HAL_RCC_GetHCLKFreq();\n  uint32_t index = (*(int *)(DAT_08005a40 + 4) << 0x15) >> 0x1d;\n  uint32_t divisor = PTR_APBPrescTable_08005a44[index];\n  return HCLK_frequency >> divisor;\n}",
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005a28",
            "calling": [
                "getTimerClkFreq",
                "HAL_I2C_Init",
                "UART_SetConfig"
            ],
            "imported": false,
            "current_name": "calculate_HCLK_frequency_08005a28"
        },
        "FUN_08008ac6": {
            "renaming": {
                "FUN_08008ac6": "calculate_next_tx_position_08008ac6",
                "obj": "serial_obj",
                "iVar3": "next_tx_pos",
                "uVar1": "next_tx_pos_ushort",
                "uVar2": "masked_tx_pos"
            },
            "code": "int calculate_next_tx_position_08008ac6(serial_t_conflict *serial_obj)\n{\n  int next_tx_pos = serial_obj->tx_tail + 1;\n  ushort next_tx_pos_ushort = (ushort)next_tx_pos;\n  uint16_t masked_tx_pos = next_tx_pos_ushort & 0x7f;\n  if (next_tx_pos == 0) {\n    masked_tx_pos = -(-next_tx_pos_ushort & 0x7f);\n  }\n  serial_obj->tx_tail = masked_tx_pos;\n  if (serial_obj->tx_head != serial_obj->tx_tail) {\n    return 0;\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ac6",
            "calling": [],
            "imported": false,
            "current_name": "calculate_next_tx_position_08008ac6"
        },
        "FUN_08003002": {
            "renaming": {
                "FUN_08003002": "initializeFirmata_08003002",
                "this->FUN_08003002Disabled": "this->isDisabled",
                "0xd": "LED_BUILTIN",
                "strobeBlinkPin": "strobeBlinkPin",
                "'\\r'": "'\\r'",
                "2": "2",
                "0x28": "0x28",
                "0xd2": "0xd2",
                "0xfa": "250",
                "5": "5",
                "0x7d": "125"
            },
            "code": "void __thiscall firmata::FirmataClass::initializeFirmata_08003002(FirmataClass *this)\n{\n  if (this->isDisabled != false) {\n    return;\n  }\n  pinMode(LED_BUILTIN, OUTPUT);\n  strobeBlinkPin(this, '\r', 2, 0x28, 0xd2);\n  delay(250);\n  strobeBlinkPin(this, '\r', 5, 0x28, 0xd2);\n  delay(125);\n  return;\n}",
            "called": [
                "delay",
                "strobeBlinkPin",
                "pinMode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003002",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "initializeFirmata_08003002"
        },
        "FUN_08008ac4": {
            "renaming": {
                "FUN_08008ac4": "do_nothing_08008ac4"
            },
            "code": "\nvoid do_nothing_08008ac4(uint32_t ms)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ac4",
            "calling": [
                "strobeBlinkPin",
                "blinkVersion"
            ],
            "imported": false,
            "current_name": "do_nothing_08008ac4"
        },
        "FUN_08003366": {
            "renaming": {
                "FUN_08003366": "setStringCallback_08003366",
                "command": "receivedCommand",
                "newFunction": "callbackFunction",
                "context": "callbackContext",
                "currentStringCallback": "stringCallback",
                "currentStringCallbackContext": "stringCallbackContext"
            },
            "code": "void __thiscall firmata::FirmataParser::setStringCallback_08003366(FirmataParser *this, uint8_t command, stringCallbackFunction newFunction, void *context) {\n  if (command == 'q') {\n    this->currentStringCallback = newFunction;\n    this->currentStringCallbackContext = context;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003366",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "setStringCallback_08003366"
        },
        "FUN_080091b0": {
            "renaming": {
                "FUN_080091b0": "copy_memory_080091b0",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "puVar1": "destination_ptr",
                "puVar2": "source_ptr"
            },
            "code": "void * copy_memory_080091b0(void *destination, const void *source, size_t size)\n{\n    unsigned char *destination_ptr = (unsigned char*)destination;\n    const unsigned char *source_ptr = (const unsigned char*)source + size;\n    while (size--)\n    {\n        *(--destination_ptr) = *(--source_ptr);\n    }\n    return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091b0",
            "calling": [
                "write",
                "_realloc_r",
                "onReceiveService"
            ],
            "imported": false,
            "current_name": "copy_memory_080091b0"
        },
        "FUN_08009908": {
            "renaming": {
                "FUN_08009908": "allocate_memory_08009908",
                "__ptr": "ptr",
                "__size": "size",
                "pvVar1": "allocated_ptr"
            },
            "code": "void * allocate_memory_08009908(void *ptr, size_t size)\n{\n  void *allocated_ptr;\n  allocated_ptr = (void *)_allocate_memory_08009908_r(*(undefined4 *)PTR__impure_ptr_08009914, ptr, size);\n  return allocated_ptr;\n}",
            "called": [
                "_realloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009908",
            "calling": [
                "write",
                "write",
                "allocateRxBuffer"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009908"
        },
        "FUN_08008abc": {
            "renaming": {
                "FUN_08008abc": "get_current_milli_08008abc",
                "uVar1": "current_milli"
            },
            "code": "uint32_t get_current_milli_08008abc()\n{\n  uint32_t current_milli = GetCurrentMilli();\n  return current_milli;\n}",
            "called": [
                "GetCurrentMilli"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008abc",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "get_current_milli_08008abc"
        },
        "FUN_08002b68": {
            "renaming": {
                "__thiscall": "",
                "TwoWire": "wire",
                "this": "wire",
                "address": "address",
                "quantity": "quantity",
                "iaddress": "internalAddress",
                "isize": "internalAddressSize",
                "sendStop": "sendStop",
                "iVar1": "status",
                "uVar2": "remainingBytes",
                "master": "master",
                "PTR_rxBuffer_08002bf4": "rxBuffer",
                "PTR_rxBufferIndex_08002bf8": "rxBufferIndex",
                "PTR_rxBufferLength_08002bfc": "rxBufferLength",
                "allocateRxBuffer": "allocateRxBuffer",
                "beginTransmission": "beginTransmission",
                "endTransmission": "endTransmission",
                "i2c_master_read": "i2c_master_read",
                "I2C_OK": "I2C_OK",
                "(this->super_Stream).super_Print._vptr_Print": "wire->print",
                "(this->super_Stream).super_Print.write_error": "wire->write_error",
                "FUN_08002b68": "readFromAddress_08002b68"
            },
            "code": "uint8_t readFromAddress_08002b68(TwoWire *wire, uint8_t address, uint8_t quantity, uint32_t internalAddress, uint8_t internalAddressSize, uint8_t sendStop) {\n  i2c_status_e_conflict status;\n  uint8_t remainingBytes = (uint8_t)internalAddressSize;\n\n  if (wire->master == false) {\n    return 0;\n  }\n\n  allocateRxBuffer((uint)quantity);\n\n  if (PTR_rxBuffer_08002bf4 != NULL) {\n    if (remainingBytes != 0) {\n      beginTransmission(wire, address);\n\n      if (remainingBytes > 3) {\n        remainingBytes = 3;\n      }\n\n      while (remainingBytes > 0) {\n        uint8_t byteToSend = (internalAddress >> ((remainingBytes - 1) * 8)) & 0xFF;\n        wire->print(byteToSend);\n        remainingBytes--;\n      }\n\n      endTransmission(wire, sendStop);\n    }\n\n    status = i2c_master_read(&wire->_i2c, address << 1, &PTR_rxBuffer_08002bf4[0], (ushort)quantity);\n\n    if (status == I2C_OK) {\n      PTR_PTR_rxBuffer_08002bf4Index_08002bf8 = 0;\n      PTR_PTR_rxBuffer_08002bf4Length_08002bfc = quantity;\n      return quantity;\n    }\n  }\n\n  wire->write_error = 1;\n  return 0;\n}",
            "called": [
                "beginTransmission",
                "endTransmission",
                "i2c_master_read",
                "allocateRxBuffer"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002b68",
            "calling": [
                "requestFrom"
            ],
            "imported": false,
            "current_name": "readFromAddress_08002b68"
        },
        "FUN_080005e0": {
            "renaming": {
                "FUN_080005e0": "disable_I2C_080005e0",
                "PTR_isI2CEnabled_080005f0": "is_I2C_Enabled",
                "PTR_queryIndex_080005f4": "query_Index"
            },
            "code": "void disable_I2C_080005e0(void)\n{\n  *PTR_isI2CEnabled_080005f0 = 0;\n  *PTR_queryIndex_080005f4 = 0xff;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080005e0",
            "calling": [
                "systemResetCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "disable_I2C_080005e0"
        },
        "FUN_0800674c": {
            "renaming": {
                "FUN_0800674c": "do_nothing_0800674c"
            },
            "code": "\nvoid do_nothing_0800674c(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800674c",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "do_nothing_0800674c"
        },
        "FUN_0800674e": {
            "renaming": {
                "FUN_0800674e": "initialize_uart_0800674e",
                "huart": "uart_handle",
                "HAL_UART_StateTypeDef": "HAL_StatusTypeDef",
                "HAL_UART_MspInit": "initialize_uart_msp",
                "PTR_": "",
                "DAT_": "",
                "gState": "global_state",
                "Instance": "instance",
                "Lock": "lock",
                "ErrorCode": "error_code",
                "RxState": "receive_state",
                "HAL_UNLOCKED": "0",
                "HAL_UART_STATE_RESET": "0",
                "HAL_UART_STATE_BUSY": "1",
                "HAL_UART_STATE_READY": "2",
                "CR1": "control_register_1",
                "CR2": "control_register_2",
                "CR3": "control_register_3",
                "UART_SetConfig": "set_uart_config"
            },
            "code": "HAL_StatusTypeDef initialize_uart_0800674e(UART_HandleTypeDef *uart_handle)\n{\n  if (uart_handle != NULL) {\n    if (uart_handle->gState == HAL_UART_STATE_RESET) {\n      uart_handle->Lock = HAL_UNLOCKED;\n      HAL_UART_MspInit(uart_handle);\n    }\n    uart_handle->gState = HAL_UART_STATE_BUSY;\n    uart_handle->Instance->CR1 &= ~(1 << 13);\n    UART_SetConfig(uart_handle);\n    uart_handle->Instance->CR2 &= ~(1 << 11);\n    uart_handle->Instance->CR3 &= ~(1 << 2);\n    uart_handle->Instance->CR1 |= (1 << 13);\n    uart_handle->ErrorCode = 0;\n    uart_handle->gState = HAL_UART_STATE_READY;\n    uart_handle->RxState = HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}",
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800674e",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_0800674e"
        },
        "FUN_0800771c": {
            "renaming": {
                "FUN_0800771c": "handle_timer_interrupt_0800771c",
                "htim": "timer_handle",
                "psVar1": "timer_obj",
                "get_timer_obj": "get_timer_object",
                "irqHandleOC": "interrupt_handler_OC"
            },
            "code": "void handle_timer_interrupt_0800771c(TIM_HandleTypeDef_conflict *timer_handle)\n{\n  stimer_t_conflict *timer_obj;\n  timer_obj = get_timer_object(timer_handle);\n  if ((timer_obj->interrupt_handler_OC != (_func_void_stimer_t_ptr_uint32_t_conflict *)0x0) && (timer_handle->Channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*timer_obj->interrupt_handler_OC)(timer_obj,0);\n  }\n  return;\n}",
            "called": [
                "get_timer_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800771c",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_timer_interrupt_0800771c"
        },
        "FUN_08003370": {
            "renaming": {
                "FUN_08003370": "setSysexCallback_08003370",
                "command": "command",
                "newFunction": "sysexCallback",
                "context": "sysexCallbackContext",
                "this": "this"
            },
            "code": "void __thiscall firmata::FirmataParser::setSysexCallback_08003370(FirmataParser *this, uint8_t command, sysexCallbackFunction newFunction, void *context) {\n  this->currentSysexCallback = newFunction;\n  this->currentSysexCallbackContext = context;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003370",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "setSysexCallback_08003370"
        },
        "FUN_08003376": {
            "renaming": {
                "FUN_08003376": "checkAndUpdateDataBuffer_08003376",
                "this": "parser",
                "data": "data",
                "pos": "position",
                "bVar1": "buffer_overflow",
                "currentDataBufferOverflowCallback": "current_data_buffer_overflow_callback",
                "dataBufferOverflowCallbackFunction": "data_buffer_overflow_callback_function",
                "allowBufferUpdate": "allow_buffer_update",
                "currentDataBufferOverflowCallbackContext": "current_data_buffer_overflow_callback_context",
                "dataBufferSize": "data_buffer_size",
                "dataBuffer": "data_buffer"
            },
            "code": "bool __thiscall firmata::FirmataParser::checkAndUpdateDataBuffer_08003376(FirmataParser *parser, uint8_t data, size_t position) {\n  bool buffer_overflow = false;\n  if (position >= parser->data_buffer_size) {\n    buffer_overflow = true;\n    if (parser->current_data_buffer_overflow_callback != (data_buffer_overflow_callback_function)0x0) {\n      parser->allow_buffer_update = true;\n      (*parser->current_data_buffer_overflow_callback)(parser->current_data_buffer_overflow_callback_context);\n      if (position >= parser->data_buffer_size) {\n        buffer_overflow = true;\n      }\n      else {\n        buffer_overflow = false;\n      }\n    }\n  }\n  if (!buffer_overflow) {\n    parser->data_buffer[position] = data;\n  }\n  return buffer_overflow;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003376",
            "calling": [
                "parse",
                "processSysexMessage"
            ],
            "imported": false,
            "current_name": "checkAndUpdateDataBuffer_08003376"
        },
        "FUN_08008bf4": {
            "renaming": {
                "FUN_08008bf4": "checkSerial2Availability_08008bf4",
                "DAT_08008c18": "serial2Enabled",
                "PTR_Serial2_08008c1c": "serial2"
            },
            "code": "void checkSerial2Availability_08008bf4(void)\n{\n  if (DAT_08008c18 != 0)\n  {\n    HardwareSerial::available(PTR_Serial2_08008c1c);\n  }\n  return;\n}",
            "called": [
                "available"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008bf4",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "checkSerial2Availability_08008bf4"
        },
        "FUN_08002c7c": {
            "renaming": {
                "FUN_08002c7c": "reportAnalogCallback_08002c7c",
                "param_1": "analogCallback",
                "command": "command",
                "value": "value",
                "PTR_currentReportAnalogCallback_08002c8c": "currentReportAnalogCallback"
            },
            "code": "void FirmataClass::reportAnalogCallback_08002c7c(void *analogCallback, uint8_t command, uint16_t value) {\n  if (*(code **)PTR_currentReportAnalogCallback_08002c8c != (code *)0x0) {\n    (**(code **)PTR_currentReportAnalogCallback_08002c8c)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c7c",
            "calling": [],
            "imported": false,
            "current_name": "reportAnalogCallback_08002c7c"
        },
        "FUN_08005430": {
            "renaming": {
                "FUN_08005430": "get_i2c_error_code_08005430",
                "hi2c": "i2c_handler"
            },
            "code": "uint32_t get_i2c_error_code_08005430(I2C_HandleTypeDef_conflict *i2c_handler)\n{\n  return i2c_handler->ErrorCode;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005430",
            "calling": [
                "i2c_master_read",
                "i2c_master_write"
            ],
            "imported": false,
            "current_name": "get_i2c_error_code_08005430"
        },
        "FUN_08009918": {
            "renaming": {
                "FUN_08009918": "allocate_memory_08009918",
                "param_1": "memory_location",
                "param_2": "memory_size",
                "puVar1": "error_ptr",
                "pcVar2": "ptr",
                "PTR_errno_08009934": "errno_address"
            },
            "code": "void allocate_memory_08009918(int *memory_location, int memory_size) {\n  undefined *error_ptr;\n  caddr_t ptr;\n  error_ptr = PTR_errno_08009934;\n  *(undefined4 *)PTR_errno_08009934 = 0;\n  ptr = _sbrk(memory_size);\n  if ((ptr == (caddr_t)0xffffffff) && (*(int *)error_ptr != 0)) {\n    *memory_location = *(int *)error_ptr;\n  }\n  return;\n}",
            "called": [
                "_sbrk"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009918",
            "calling": [
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009918"
        },
        "FUN_08005434": {
            "renaming": {
                "FUN_08005434": "delay_08005434",
                "mdelay": "milliseconds",
                "Delay": "cycles",
                "bVar1": "delay_finished",
                "PTR_SystemCoreClock_08005458": "system_core_clock_ptr",
                "DAT_0800545c": "delay_factor"
            },
            "code": "void delay_08005434(uint32_t milliseconds)\n{\n    uint32_t cycles_per_ms = *(uint *)PTR_SystemCoreClock_08005458 / 1000;\n    uint32_t cycles = mdelay_08005434 * cycles_per_ms * DAT_0800545c;\n    while(cycles--);\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005434",
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "imported": false,
            "current_name": "delay_08005434"
        },
        "FUN_08005e2e": {
            "renaming": {
                "FUN_08005e2e": "resetTimer_08005e2e",
                "htim": "timer",
                "pTVar1": "timerInstance",
                "HAL_TIM_STATE_BUSY": "TIMER_STATE_BUSY",
                "HAL_TIM_STATE_RESET": "TIMER_STATE_RESET",
                "HAL_UNLOCKED": "TIMER_UNLOCKED",
                "HAL_TIM_PWM_MspDeInit": "deinitializeTimerPWM",
                "HAL_OK": "TIMER_RESET_SUCCESSFUL"
            },
            "code": "HAL_StatusTypeDef_conflict resetTimer_08005e2e(TIM_HandleTypeDef_conflict *timer)\n{\n  TIM_TypeDef_conflict *timerInstance;\n  timer->State = HAL_TIM_STATE_BUSY;\n  timerInstance = timer->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  HAL_TIM_PWM_MspDeInit(timer);\n  timer->State = HAL_TIM_STATE_RESET;\n  timer->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}",
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e2e",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "resetTimer_08005e2e"
        },
        "FUN_08007736": {
            "renaming": {
                "FUN_08007736": "execute_timer_irq_callback_08007736",
                "htim": "timer_handle",
                "psVar1": "timer_obj",
                "get_timer_obj": "get_timer_object",
                "irqHandle": "irq_callback",
                "_func_void_stimer_t_ptr_conflict": "NULL"
            },
            "code": "void execute_timer_irq_callback_08007736(TIM_HandleTypeDef *timer_handle)\n{\n  stimer_t *timer_obj = get_timer_object(timer_handle);\n  if (timer_obj->irq_callback != NULL) {\n    (*timer_obj->irq_callback)(timer_obj);\n  }\n  return;\n}",
            "called": [
                "get_timer_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007736",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "execute_timer_irq_callback_08007736"
        },
        "FUN_08002c90": {
            "renaming": {
                "FUN_08002c90": "report_digital_callback_08002c90",
                "param_1": "callback_function",
                "command": "command",
                "value": "value",
                "PTR_currentReportDigitalCallback_08002ca0": "current_report_digital_callback"
            },
            "code": "void firmata::FirmataClass::report_digital_callback_08002c90(void *callback_function, uint8_t command, uint16_t value)\n{\n  if (*(code **)PTR_currentReportDigitalCallback_08002ca0 != (code *)0x0) {\n    (**(code **)PTR_currentReportDigitalCallback_08002ca0)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c90",
            "calling": [],
            "imported": false,
            "current_name": "report_digital_callback_08002c90"
        },
        "FUN_0800542a": {
            "renaming": {
                "FUN_0800542a": "get_i2c_state_0800542a",
                "hi2c": "i2c_handle",
                "HAL_I2C_StateTypeDef_conflict": "HAL_I2C_StateTypeDef",
                "I2C_HandleTypeDef_conflict": "I2C_HandleTypeDef",
                "hi2c->State": "i2c_handle->State"
            },
            "code": "HAL_I2C_StateTypeDef get_i2c_state_0800542a(I2C_HandleTypeDef *i2c_handle)\n{\n  return i2c_handle->State;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800542a",
            "calling": [
                "i2c_master_read",
                "i2c_master_write"
            ],
            "imported": false,
            "current_name": "get_i2c_state_0800542a"
        },
        "FUN_0800457c": {
            "renaming": {
                "FUN_0800457c": "transfer_byte_0800457c",
                "hi2c": "i2c_handle",
                "pbVar1": "buffer_pointer",
                "pBuffPtr": "buffer_pointer",
                "Instance": "i2c_instance",
                "DR": "data_register",
                "XferCount": "transfer_count",
                "HAL_StatusTypeDef_conflict": "HAL_status"
            },
            "code": "HAL_StatusTypeDef_conflict transfer_byte_0800457c(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  byte *buffer_pointer;\n  \n  if (i2c_handle->XferCount != 0) {\n    buffer_pointer = i2c_handle->pBuffPtr;\n    i2c_handle->pBuffPtr = buffer_pointer + 1;\n    i2c_handle->Instance->DR = (uint)*buffer_pointer;\n    i2c_handle->XferCount = i2c_handle->XferCount - 1;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800457c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "transfer_byte_0800457c"
        },
        "FUN_080091c6": {
            "renaming": {
                "FUN_080091c6": "memset_custom_080091c6",
                "__s": "destination",
                "__c": "character",
                "__n": "length",
                "puVar1": "ptr_destination"
            },
            "code": "void * memset_custom_080091c6(void *destination, int character, size_t length) {\n  unsigned char *ptr_destination = (unsigned char *) destination;\n  \n  for (; ptr_destination < (unsigned char *)destination + length; ptr_destination++) {\n    *ptr_destination = (unsigned char) character;\n  }\n  return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091c6",
            "calling": [
                "begin",
                "std.isra.0",
                "endTransmission",
                "pwm_start",
                "__sfp",
                "adc_read_value",
                "flush",
                "__sfmoreglue"
            ],
            "imported": false,
            "current_name": "memset_custom_080091c6"
        },
        "FUN_08003a20": {
            "renaming": {
                "FUN_08003a20": "check_ADC_status_08003a20",
                "*hadc": "*hadc",
                "HVar1": "status",
                "uVar2": "start_time",
                "uVar3": "current_time",
                "*pAVar4": "*adc_instance",
                "wait_loop_index": "i"
            },
            "code": "HAL_StatusTypeDef_conflict check_ADC_status_08003a20(ADC_HandleTypeDef *hadc)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t wait_time, start_time, current_time;\n  ADC_TypeDef *adc_instance;\n  \n  adc_instance = hadc->Instance;\n  if ((adc_instance->CR2 & 1) == 0) {\n    adc_instance->CR2 = adc_instance->CR2 | 1;\n    wait_time = (uint32_t)(((uint64_t)DAT_08003a9c * (uint64_t)*(uint *)PTR_SystemCoreClock_08003a98) >> 0x32);\n    for (uint32_t i = wait_time; i != 0; i--) {\n    }\n    start_time = HAL_GetTick();\n    do {\n      if ((hadc->Instance->CR2 & 1) != 0) {\n        return HAL_OK;\n      }\n      current_time = HAL_GetTick();\n    } while (current_time - start_time < 3);\n    hadc->State |= 0x10;\n    hadc->ErrorCode |= 1;\n    hadc->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  else {\n    status = HAL_OK;\n  }\n  return status;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a20",
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Start"
            ],
            "imported": false,
            "current_name": "check_ADC_status_08003a20"
        },
        "FUN_08009cdc": {
            "renaming": {
                "std_isra_0": "initialize_data",
                "param_1": "data_array",
                "param_2": "initial_value_1",
                "param_3": "initial_value_2",
                "uVar1": "constant_value_1",
                "DAT_08009d14": "constant_value_2",
                "DAT_08009d18": "constant_value_3",
                "DAT_08009d1c": "constant_value_4",
                "DAT_08009d20": "constant_value_5",
                "FUN_08009cdc": "initialize_data_08009cdc"
            },
            "code": "void initialize_data_08009cdc(undefined4 *data_array, undefined2 initial_value_1, undefined2 initial_value_2)\n{\n    // Initialize data array\n    *data_array = 0;\n    data_array[1] = 0;\n    data_array[2] = 0;\n    *(undefined2 *)(data_array + 3) = initial_value_1;\n    data_array[25] = 0;\n    *(undefined2 *)((int)data_array + 0xe) = initial_value_2;\n    data_array[4] = 0;\n    data_array[5] = 0;\n    data_array[6] = 0;\n    memset(data_array + 23, 0, 8);\n    // Set constant values\n    data_array[8] = data_array;\n    data_array[9] = DAT_08009d14;\n    data_array[10] = DAT_08009d18;\n    data_array[11] = DAT_08009d1c;\n    data_array[12] = DAT_08009d20;\n    return;\n}",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009cdc",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "initialize_data_08009cdc"
        },
        "FUN_080026b0": {
            "renaming": {
                "FUN_080026b0": "mapValueToMicroseconds_080026b0",
                "value": "inputValue",
                "minPulse": "minimumPulseWidth",
                "maxPulse": "maximumPulseWidth"
            },
            "code": "void __thiscall Servo::mapValueToMicroseconds_080026b0(Servo *servo, int value){\n  int minPulse = (0x88 - servo->min) * 4;\n  int maxPulse = (600 - servo->max) * 4;\n  if (value < 0x220) {\n    if (value < 0) {\n      value = 0;\n    }\n    else if (0xb4 < value) {\n      value = 0xb4;\n    }\n    value = map(value,0,0xb4,minPulse,maxPulse);\n  }\n  mapValueToMicroseconds_080026b0Microseconds(servo,value);\n  return;\n}",
            "called": [
                "map",
                "writeMicroseconds"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080026b0",
            "calling": [
                "analogWriteCallback"
            ],
            "imported": false,
            "current_name": "mapValueToMicroseconds_080026b0"
        },
        "FUN_08002a58": {
            "renaming": {
                "__thiscall TwoWire::FUN_08002a58": "sendData",
                "sendStop": "sendStop",
                "i2c_status_e_conflict": "i2cStatus",
                "iVar1": "i2cStatus",
                "uVar2": "returnStatus",
                "this": "this",
                "master": "master",
                "i2c_master_write": "i2c_master_write",
                "i2c_t_conflict": "i2c_t_conflict",
                "_i2c": "_i2c",
                "PTR_txAddress_08002ab0": "txAddress",
                "txBuffer": "txBuffer",
                "PTR_txBuffer_08002aac": "txBuffer",
                "byte": "byte",
                "PTR_txBufferLength_08002aa8": "txBufferLength",
                "I2C_OK": "I2C_OK",
                "I2C_TIMEOUT": "I2C_TIMEOUT",
                "memset": "memset",
                "PTR_txBufferAllocated_08002ab4": "txBufferAllocated",
                "PTR_txBufferIndex_08002ab8": "txBufferIndex",
                "PTR_transmitting_08002abc": "transmitting",
                "FUN_08002a58": "sendData_08002a58"
            },
            "code": "uint8_t __thiscall TwoWire::sendData_08002a58(TwoWire *this, uint8_t sendStop)\\n{\\n  i2c_status_e_conflict i2cStatus;\\n  uint8_t returnStatus;\\n  \\n  if (this->master == false) {\\n    returnStatus = \"\\x04\";\\n  }\\n  else {\\n    i2cStatus = i2c_master_write((i2c_t_conflict *)&this->_i2c, PTR_txAddress_08002ab0, PTR_txBuffer_08002aac, (ushort)(byte)*PTR_PTR_txBuffer_08002aacLength_08002aa8);\\n    if (i2cStatus == I2C_OK) {\\n      returnStatus = \"\\0\";\\n    }\\n    else if (i2cStatus == I2C_TIMEOUT) {\\n      returnStatus = \"\\x01\";\\n    }\\n    else {\\n      returnStatus = \"\\x04\";\\n    }\\n    if (*PTR_txBuffer_08002aac != (void *)0x0) {\\n      memset(*PTR_txBuffer_08002aac, 0, (uint)(byte)*PTR_PTR_txBuffer_08002aacAllocated_08002ab4);\\n    }\\n    *PTR_PTR_txBuffer_08002aacIndex_08002ab8 = 0;\\n    *PTR_PTR_txBuffer_08002aacLength_08002aa8 = 0;\\n    *PTR_transmitting_08002abc = 0;\\n  }\\n  return returnStatus;\\n}",
            "called": [
                "memset",
                "i2c_master_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a58",
            "calling": [
                "requestFrom",
                "endTransmission",
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "sendData_08002a58"
        },
        "FUN_080004d4": {
            "renaming": {
                "FUN_080004d4": "initialize_servos_080004d4",
                "__initialize_p": "should_initialize",
                "__priority": "priority_level",
                "iVar1": "servo_index",
                "this": "servo_list_ptr"
            },
            "code": "void initialize_servos_080004d4(int should_initialize, int priority_level)\n{\n  int servo_index;\n  Servo *servo_list_ptr;\n  if (should_initialize != 1) {\n    return;\n  }\n  if (priority_level == 0xffff) {\n    servo_list_ptr = (Servo *)PTR_servos_080004fc;\n    for (servo_index = 0xb; servo_index >= 0; servo_index--) {\n      Servo::Servo(servo_list_ptr);\n      servo_list_ptr++;\n    }\n  }\n  return;\n}",
            "called": [
                "Servo"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080004d4",
            "calling": [
                "_GLOBAL__sub_I_analogInputsToReport"
            ],
            "imported": false,
            "current_name": "initialize_servos_080004d4"
        },
        "FUN_080005f8": {
            "renaming": {
                "FUN_080005f8": "FUNC_080005f8"
            },
            "code": "\nvoid FUNC_080005f8(byte pin,int mode)\n\n{\n  undefined *this;\n  byte bVar1;\n  PinName_conflict PVar2;\n  bool bVar3;\n  bool bVar4;\n  _Bool _Var5;\n  uint ulPin;\n  uint32_t uVar6;\n  char cVar7;\n  uint uVar8;\n  \n  ulPin = (uint)pin;\n  bVar1 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000874,pin);\n  if (bVar1 != '\\x7f') {\n    bVar1 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000874,pin);\n    if (bVar1 == '\\x06') {\n      cVar7 = *PTR_isI2CEnabled_0800087c;\n      if (cVar7 == '\\0') {\n        cVar7 = '\\0';\n      }\n      else if (mode == 6) {\n        cVar7 = '\\0';\n      }\n    }\n    else {\n      cVar7 = '\\0';\n    }\n    if (cVar7 != '\\0') {\n      disableI2CPins();\n    }\n    if (ulPin < 0x3c) {\n      if (PTR_digitalPin_08000878[ulPin] == NC) {\n        bVar3 = false;\n      }\n      else {\n        uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n        if (uVar6 == 0) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 1) {\n            bVar3 = false;\n          }\n          else if (mode == 4) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    else {\n      bVar3 = false;\n    }\n    if (bVar3) {\n      if ((byte)PTR_servoPinMap_08000880[ulPin] < 0xc) {\n        bVar3 = Servo::attached((Servo *)(PTR_servos_08000884 +\n                                         (uint)(byte)PTR_servoPinMap_08000880[ulPin] * 3));\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3 != false) {\n        detachServo(pin);\n      }\n    }\n    uVar8 = ulPin - 0x2e & 0xff;\n    if (uVar8 < 0xe) {\n      if (ulPin < 0x3c) {\n        PVar2 = PTR_digitalPin_08000878[ulPin];\n      }\n      else {\n        PVar2 = NC;\n      }\n      uVar6 = pinNametoDigitalPin(PVar2);\n      if (uVar6 == 0) {\n        bVar3 = false;\n      }\n      else {\n        if (ulPin < 0x3c) {\n          PVar2 = PTR_digitalPin_08000878[ulPin];\n        }\n        else {\n          PVar2 = NC;\n        }\n        uVar6 = pinNametoDigitalPin(PVar2);\n        if (uVar6 == 1) {\n          bVar3 = false;\n        }\n        else {\n          bVar3 = true;\n        }\n      }\n    }\n    else {\n      bVar3 = false;\n    }\n    if (bVar3) {\n      reportAnalogCallback((byte)uVar8,(uint)(mode == 2));\n    }\n    if (ulPin < 0x3c) {\n      if (PTR_digitalPin_08000878[ulPin] == NC) {\n        bVar3 = false;\n      }\n      else {\n        uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n        if (uVar6 == 0) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 1) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n    }\n    else {\n      bVar3 = false;\n    }\n    if (bVar3) {\n      if ((mode == 0) || (mode == 0xb)) {\n        PTR_portConfigInputs_08000888[pin >> 3] =\n             PTR_portConfigInputs_08000888[pin >> 3] | (byte)(1 << (ulPin & 7));\n      }\n      else {\n        PTR_portConfigInputs_08000888[pin >> 3] =\n             PTR_portConfigInputs_08000888[pin >> 3] & ~(byte)(1 << (ulPin & 7));\n      }\n    }\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_08000874,pin,0);\n    switch(mode) {\n    case 0:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000878[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        pinMode(ulPin,0);\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000874,pin,'\\0');\n        return;\n      }\n      break;\n    case 1:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        bVar1 = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_08000a44,pin);\n        if (bVar1 == '\\x03') {\n          digitalWrite(ulPin,0);\n        }\n        pinMode(ulPin,1);\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x01');\n        return;\n      }\n      break;\n    case 2:\n      if (uVar8 < 0xe) {\n        if (ulPin < 0x3c) {\n          PVar2 = PTR_digitalPin_08000878[ulPin];\n        }\n        else {\n          PVar2 = NC;\n        }\n        uVar6 = pinNametoDigitalPin(PVar2);\n        if (uVar6 == 0) {\n          bVar3 = false;\n        }\n        else {\n          if (ulPin < 0x3c) {\n            PVar2 = PTR_digitalPin_08000878[ulPin];\n          }\n          else {\n            PVar2 = NC;\n          }\n          uVar6 = pinNametoDigitalPin(PVar2);\n          if (uVar6 == 1) {\n            bVar3 = false;\n          }\n          else {\n            bVar3 = true;\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        if (ulPin < 0x3c) {\n          if (PTR_digitalPin_08000878[ulPin] == NC) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n            if (uVar6 == 0) {\n              bVar3 = false;\n            }\n            else {\n              uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n              if (uVar6 == 1) {\n                bVar3 = false;\n              }\n            }\n          }\n        }\n        else {\n          bVar3 = false;\n        }\n        if (bVar3) {\n          pinMode(ulPin,0);\n        }\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000874,pin,'\\x02');\n        return;\n      }\n      break;\n    case 3:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          _Var5 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            _Var5 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              _Var5 = false;\n            }\n            else {\n              _Var5 = pin_in_pinmap(PTR_digitalPin_08000a48[ulPin],\n                                    (PinMap_conflict *)PTR_PinMap_PWM_08000a4c);\n            }\n          }\n        }\n      }\n      else {\n        _Var5 = false;\n      }\n      if (_Var5 != false) {\n        pinMode(ulPin,1);\n        analogWrite(ulPin,0);\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x03');\n        return;\n      }\n      break;\n    case 4:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x04');\n        if (((byte)PTR_servoPinMap_08000a50[ulPin] != 0xff) &&\n           (bVar4 = Servo::attached((Servo *)(PTR_servos_08000a54 +\n                                             (uint)(byte)PTR_servoPinMap_08000a50[ulPin] * 3)),\n           bVar4)) {\n          bVar3 = false;\n        }\n        if (bVar3) {\n          attachServo(pin,-1,-1);\n          return;\n        }\n      }\n      break;\n    default:\n      firmata::FirmataClass::sendString\n                ((FirmataClass *)PTR_Firmata_08000a44,PTR_s_Unknown_pin_mode_08000a60);\n      break;\n    case 6:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000a48[ulPin] == NC) {\n          _Var5 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n          if (uVar6 == 0) {\n            _Var5 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000a48[ulPin]);\n            if (uVar6 == 1) {\n              _Var5 = false;\n            }\n            else {\n              _Var5 = pin_in_pinmap(PTR_digitalPin_08000a48[ulPin],\n                                    (PinMap_conflict *)PTR_PinMap_I2C_SDA_08000a58);\n              if (!_Var5) {\n                _Var5 = pin_in_pinmap(PTR_digitalPin_08000a48[ulPin],\n                                      (PinMap_conflict *)PTR_PinMap_I2C_SCL_08000a5c);\n              }\n            }\n          }\n        }\n      }\n      else {\n        _Var5 = false;\n      }\n      if (_Var5 != false) {\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\x06');\n        return;\n      }\n      break;\n    case 10:\n      break;\n    case 0xb:\n      if (ulPin < 0x3c) {\n        if (PTR_digitalPin_08000878[ulPin] == NC) {\n          bVar3 = false;\n        }\n        else {\n          uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n          if (uVar6 == 0) {\n            bVar3 = false;\n          }\n          else {\n            uVar6 = pinNametoDigitalPin(PTR_digitalPin_08000878[ulPin]);\n            if (uVar6 == 1) {\n              bVar3 = false;\n            }\n            else {\n              bVar3 = true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 = false;\n      }\n      if (bVar3) {\n        pinMode(ulPin,2);\n        this = PTR_Firmata_08000a44;\n        firmata::FirmataClass::setPinMode((FirmataClass *)PTR_Firmata_08000a44,pin,'\\v');\n        firmata::FirmataClass::setPinState((FirmataClass *)this,pin,1);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "attached",
                "pin_in_pinmap",
                "disableI2CPins",
                "digitalWrite",
                "pinNametoDigitalPin",
                "analogWrite",
                "pinMode",
                "sendString",
                "reportAnalogCallback",
                "setPinState",
                "attachServo",
                "detachServo",
                "getPinMode",
                "setPinMode"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080005f8",
            "calling": [
                "enableI2CPins",
                "sysexCallback",
                "systemResetCallback"
            ],
            "imported": false,
            "current_name": "FUNC_080005f8"
        },
        "FUN_08002fa0": {
            "renaming": {
                "__thiscall firmata::FirmataClass::FUN_08002fa0": "getPinConfig",
                "this": "firmata",
                "pin": "pin",
                "FUN_08002fa0": "getPinConfig_08002fa0"
            },
            "code": "byte getPinConfig_08002fa0(FirmataClass *firmata, byte pin) {\n  return firmata->pinConfig[pin];\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fa0",
            "calling": [
                "loop",
                "digitalWriteCallback",
                "sysexCallback",
                "analogWriteCallback",
                "setPinValueCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "getPinConfig_08002fa0"
        },
        "FUN_0800a424": {
            "renaming": {
                "FUN_0800a424": "do_nothing_0800a424"
            },
            "code": "\nvoid do_nothing_0800a424(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a424",
            "calling": [
                "__do_global_dtors_aux",
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "do_nothing_0800a424"
        },
        "FUN_08003a1c": {
            "renaming": {
                "FUN_08003a1c": "get_adc_state_08003a1c",
                "*hadc": "*adc_handle"
            },
            "code": "uint32_t get_adc_state_08003a1c(ADC_HandleTypeDef *adc_handle)\n{\n  return adc_handle->State;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003a1c",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "get_adc_state_08003a1c"
        },
        "FUN_08007744": {
            "renaming": {
                "FUN_08007744": "get_stimer_counter_08007744",
                "obj": "timer_conf",
                "(obj->handle).Instance": "timer_handle",
                "((obj->handle).Instance)->CNT": "timer_handle->Instance->CNT"
            },
            "code": "uint32_t get_stimer_counter_08007744(stimer_t_conflict *timer_conf) {\n    TIM_HandleTypeDef *timer_handle = &(timer_conf->handle);\n    return timer_handle->Instance->CNT;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007744",
            "calling": [
                "ServoIrqHandle"
            ],
            "imported": false,
            "current_name": "get_stimer_counter_08007744"
        },
        "FUN_08006538": {
            "renaming": {
                "FUN_08006538": "configure_uart_08006538",
                "huart": "uart",
                "uVar1": "baud_rate",
                "uVar2": "mantissa",
                "uVar3": "pclk_freq",
                "uVar4": "pclk_freq",
                "uVar5": "pclk_freq",
                "uVar6": "pclk_freq",
                "uVar7": "pclk_freq",
                "uVar8": "baud_rate",
                "uVar9": "baud_rate",
                "uVar10": "baud_rate",
                "uVar11": "baud_rate",
                "pUVar12": "uart_instance",
                "DAT_080066e0": "PTR_DAT_080066e0"
            },
            "code": "void configure_uart_08006538(UART_HandleTypeDef *uart)\n{\n  uint32_t pclk_freq, baud_rate;\n  USART_TypeDef *uart_instance = uart->Instance;\n  uint32_t cr2 = uart_instance->CR2 & 0xffffcfff;\n  uint32_t cr1 = uart_instance->CR1 & 0xffffe9f3;\n  uint32_t cr3 = uart_instance->CR3 & 0xfffffcff;\n\n  cr2 |= uart->Init.StopBits;\n  cr1 |= uart->Init.WordLength | uart->Init.Parity | uart->Init.Mode;\n  cr3 |= uart->Init.HwFlowCtl;\n\n  if (uart_instance != DAT_080066e0) {\n    pclk_freq = HAL_RCC_GetPCLK1Freq();\n  } else {\n    pclk_freq = HAL_RCC_GetPCLK2Freq();\n  }\n\n  baud_rate = uart->Init.BaudRate;\n  uint32_t mantissa = (pclk_freq * 2) / baud_rate;\n  uint32_t fraction = (mantissa & 0x07) << 1;\n  mantissa >>= 3;\n  uart_instance->BRR = (mantissa << 4) | fraction;\n}\n",
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006538",
            "calling": [
                "HAL_UART_Init"
            ],
            "imported": false,
            "current_name": "configure_uart_08006538"
        },
        "FUN_08002fa8": {
            "renaming": {
                "FUN_08002fa8": "setPinConfig_08002fa8",
                "pin": "pinNumber",
                "config": "pinConfigValue",
                "this": "firmataInstance",
                "pinConfig": "firmataPinConfig"
            },
            "code": "void __thiscall firmata::FirmataClass::setPinConfig_08002fa8(FirmataClass *this, byte pin, byte config) {\n  if (this->pinConfig[pin] != '\\x7f') {\n    this->pinConfig[pin] = config;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002fa8",
            "calling": [
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "setPinConfig_08002fa8"
        },
        "FUN_0800325a": {
            "renaming": {
                "FUN_0800325a": "sendCommand_0800325a",
                "this": "marshaller",
                "command": "command",
                "bytec": "numBytes",
                "bytev": "byteArray",
                "uVar1": "byteIndex",
                "FirmataStream": "FirmataStream",
                "Stream": "Stream",
                "super_Print": "super_Print",
                "_vptr_Print": "_vptr_Print",
                "encodeByteStream": "encodeByteStream"
            },
            "code": "void __thiscall FirmataMarshaller::sendCommand_0800325a(FirmataMarshaller *marshaller, uint8_t command, size_t numBytes, uint8_t *byteArray) {\n  uint byteIndex;\n  if (marshaller->FirmataStream != (Stream *)0x0) {\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller,0xf0);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,(uint)command);\n    for (byteIndex = 0; byteIndex < numBytes; byteIndex++) {\n      encodeByteStream(marshaller, 1, byteArray + byteIndex, 0);\n    }\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,0xf7);\n  }\n  return;\n}",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800325a",
            "calling": [
                "sendString",
                "sendSysex"
            ],
            "imported": false,
            "current_name": "sendCommand_0800325a"
        },
        "FUN_080091d8": {
            "renaming": {
                "FUN_080091d8": "allocate_and_lock_memory_list_080091d8",
                "param_1": "error_code",
                "param_2": "size",
                "param_3": "param_3",
                "param_4": "param_4",
                "puVar1": "free_list",
                "extraout_r1": "next_block_end",
                "ppiVar2": "next_block",
                "ppiVar3": "prev_block",
                "piVar4": "block_data",
                "ppiVar5": "free_list_head",
                "ppiVar6": "current_block",
                "ppiVar7": "next_block_end"
            },
            "code": "void allocate_and_lock_memory_list_080091d8(undefined4 *error_code, int size, undefined4 param_3, undefined4 param_4)\n{\n    int **current_block = (int **)(size - 4);\n    if (*(int *)(size - 4) < 0) {\n        current_block = (int **)((int)current_block + *(int *)(size - 4));\n    }\n    __malloc_lock();\n    undefined *free_list = PTR___malloc_free_list_0800926c;\n    int **free_list_head = *(int ***)free_list;\n    if (free_list_head == (int **)0x0) {\n        current_block[1] = (int *)0x0;\n        *(int ***)free_list = current_block;\n    }\n    else if (current_block < free_list_head) {\n        int **next_block = (int **)*current_block;\n        int **next_block_end = (int **)((int)current_block + (int)next_block);\n        if (free_list_head == next_block_end) {\n            int *block_data = *free_list_head;\n            free_list_head = (int **)free_list_head[1];\n            next_block_end = (int **)((int)block_data + (int)next_block);\n            *current_block = (int *)next_block_end;\n        }\n        current_block[1] = (int *)free_list_head;\n        *(int ***)free_list = current_block;\n    }\n    else {\n        int **next_block = free_list_head;\n        int **next_block_end;\n        do {\n            next_block_end = (int **)next_block[1];\n            if (next_block_end == (int **)0x0) break;\n            next_block = next_block_end;\n        } while (next_block_end <= current_block);\n        int **prev_block = (int **)*next_block;\n        if ((int **)((int)next_block + (int)prev_block) == current_block) {\n            int **new_block_end = (int **)((int)prev_block + (int)*current_block);\n            *next_block = (int *)new_block_end;\n            if (next_block_end == (int **)((int)next_block + (int)new_block_end)) {\n                int *block_data = *next_block_end;\n                next_block_end = (int **)next_block_end[1];\n                new_block_end = (int **)((int)block_data + (int)prev_block);\n                *next_block = (int *)new_block_end;\n                next_block[1] = (int *)next_block_end;\n            }\n        }\n        else if (current_block < (int **)((int)next_block + (int)prev_block)) {\n            *error_code = 0xc;\n        }\n        else {\n            int **new_block_end = (int **)((int)current_block + (int)*current_block);\n            if (next_block_end == new_block_end) {\n                int *block_data = *next_block_end;\n                next_block_end = (int **)next_block_end[1];\n                new_block_end = (int **)((int)block_data + (int)*current_block);\n                *current_block = (int *)new_block_end;\n            }\n            current_block[1] = (int *)next_block_end;\n            prev_block[1] = (int *)current_block;\n        }\n    }\n    __malloc_unlock(error_code, free_list_head, next_block_end, param_4);\n    return;\n}",
            "called": [
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080091d8",
            "calling": [
                "free",
                "__swsetup_r",
                "_realloc_r",
                "__sflush_r"
            ],
            "imported": false,
            "current_name": "allocate_and_lock_memory_list_080091d8"
        },
        "FUN_0800688e": {
            "renaming": {
                "FUN_0800688e": "transmitData_0800688e",
                "*huart": "*uart",
                "*pData": "*data",
                "Size": "size",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "HAL_BUSY": "HAL_BUSY",
                "uint8_t": "uint8_t",
                "NULL": "NULL",
                "HAL_ERROR": "HAL_ERROR",
                "HAL_LOCKED": "HAL_LOCKED",
                "pTxBuffPtr": "pTxBuffPtr",
                "TxXferSize": "TxXferSize",
                "TxXferCount": "TxXferCount",
                "ErrorCode": "ErrorCode",
                "HAL_UART_STATE_BUSY_TX": "HAL_UART_STATE_BUSY_TX",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "Instance": "Instance",
                "CR1": "CR1"
            },
            "code": "HAL_StatusTypeDef transmitData_0800688e(UART_HandleTypeDef *uart, uint8_t *data, uint16_t size) {\n    if (uart->gState != HAL_UART_STATE_READY) {\n        return HAL_BUSY;\n    }\n    if (data == NULL) {\n        return HAL_ERROR;\n    }\n    if (size == 0) {\n        return HAL_ERROR;\n    }\n    if (uart->Lock != HAL_LOCKED) {\n        uart->pTxBuffPtr = data;\n        uart->TxXferSize = size;\n        uart->TxXferCount = size;\n        uart->ErrorCode = 0;\n        uart->gState = HAL_UART_STATE_BUSY_TX;\n        uart->Lock = HAL_UNLOCKED;\n        uart->Instance->CR1 |= 0x80;\n        return HAL_OK;\n    }\n    return HAL_BUSY;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800688e",
            "calling": [
                "uart_attach_tx_callback",
                "HAL_UART_TxCpltCallback"
            ],
            "imported": false,
            "current_name": "transmitData_0800688e"
        },
        "FUN_080090b4": {
            "renaming": {
                "FUN_080090b4": "initialize_static_variables_080090b4"
            },
            "code": "void initialize_static_variables_080090b4(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090b4",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_080090b4"
        },
        "FUN_0800870c": {
            "renaming": {
                "FUN_0800870c": "process_received_data_0800870c",
                "*huart": "*uart_handle",
                "byte bVar1": "byte uart_index",
                "uint uVar2": "uint8_t callback_index",
                "uart_index(huart)": "get_uart_index(uart_handle)",
                "PTR_rx_callback_08008728": "PTR_rx_callback_table",
                "PTR_rx_callback_obj_0800872c": "PTR_rx_callback_obj_table"
            },
            "code": "void process_received_data_0800870c(UART_HandleTypeDef *uart_handle)\n{\n  byte uart_index;\n  uint8_t callback_index;\n  \n  uart_index = get_uart_index(uart_handle);\n  callback_index = (uint8_t)uart_index;\n  if (callback_index < 5) {\n    (**(void (**)(void))(PTR_rx_callback_08008728 + callback_index * 4))\n              (*(void **)(PTR_rx_callback_obj_0800872c + callback_index * 4));\n  }\n  return;\n}",
            "called": [
                "uart_index"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800870c",
            "calling": [
                "UART_Receive_IT"
            ],
            "imported": false,
            "current_name": "process_received_data_0800870c"
        },
        "FUN_08008840": {
            "renaming": {
                "FUN_08008840": "return_error_08008840",
                "file_UNUSED": "file_not_used"
            },
            "code": "int return_error_08008840(int file_not_used) {\n    return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008840",
            "calling": [
                "_close_r"
            ],
            "imported": false,
            "current_name": "return_error_08008840"
        },
        "FUN_08008600": {
            "renaming": {
                "FUN_08008600": "receive_data_from_serial_port_08008600",
                "obj": "serial_port",
                "c": "received_char",
                "uVar1": "is_rx_active"
            },
            "code": "int receive_data_from_serial_port_08008600(serial_t *serial_port, uchar *received_char)\n{\n  uint8_t is_rx_active;\n  \n  if (serial_port == NULL) {\n    return -1;\n  }\n  \n  is_rx_active = serial_rx_active(serial_port);\n  \n  if (is_rx_active == 0) {\n    *received_char = serial_port->recv;\n    HAL_UART_Receive_IT(*(UART_HandleTypeDef **)(PTR_uart_handlers_08008638 + (uint)serial_port->index * 4),\n                        &serial_port->recv,1);\n    return 0;\n  }\n  \n  return -1;\n}",
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008600",
            "calling": [
                "_rx_complete_irq"
            ],
            "imported": false,
            "current_name": "receive_data_from_serial_port_08008600"
        },
        "FUN_08003154": {
            "renaming": {
                "FUN_08003154": "setFirmataStream_08003154",
                "s": "stream",
                "FirmataStream": "FirmataStream"
            },
            "code": "void __thiscall firmata::FirmataMarshaller::setFirmataStream_08003154(Stream *stream)\n{\n  this->FirmataStream = stream;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003154",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "setFirmataStream_08003154"
        },
        "FUN_08006420": {
            "renaming": {
                "FUN_08006420": "updateChannelState_08006420",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelNState": "newChannelState",
                "CCER": "channelControlRegister",
                "PTR_": "PTR_ (unchanged)",
                "DAT_": "DAT_ (unchanged)"
            },
            "code": "void updateChannelState_08006420(TIM_TypeDef_conflict *timer, uint32_t channel, uint32_t newChannelState) {\n  uint32_t channelMask = 4 << (channel & 0xff);\n  timer->CCER = (timer->CCER & ~channelMask) | (newChannelState << (channel & 0xff));\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006420",
            "calling": [
                "HAL_TIMEx_PWMN_Start",
                "HAL_TIMEx_PWMN_Stop"
            ],
            "imported": false,
            "current_name": "updateChannelState_08006420"
        },
        "FUN_08007750": {
            "renaming": {
                "FUN_08007750": "set_timer_channel_08007750",
                "obj": "timer",
                "channel": "channel",
                "value": "value",
                "&((obj->handle).Instance)->CCR1": "channel_register"
            },
            "code": "void set_timer_channel_08007750(stimer_t_conflict *timer, uint32_t channel, uint32_t value)\n{\n    uint32_t *channel_register = &((timer->handle).Instance)->CCR1;\n    channel_register[channel] = value;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007750",
            "calling": [
                "ServoIrqHandle"
            ],
            "imported": false,
            "current_name": "set_timer_channel_08007750"
        },
        "FUN_08009938": {
            "renaming": {
                "FUN_08009938": "find_char_in_string_08009938",
                "__s": "string",
                "__c": "character",
                "pbVar1": "byte_string"
            },
            "code": "char* find_char_in_string_08009938(char* string, int character) {\n  byte* byte_string = (byte*)string;\n  while (*byte_string != 0) {\n    if (*byte_string == (byte)character) {\n      return (char*)byte_string;\n    }\n    byte_string++;\n  }\n  if ((character & 0xff) != 0) {\n    return NULL;\n  }\n  return (char*)byte_string;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009938",
            "calling": [
                "strrchr"
            ],
            "imported": false,
            "current_name": "find_char_in_string_08009938"
        },
        "FUN_08007f0e": {
            "renaming": {
                "FUN_08007f0e": "receive_data_from_i2c_device_08007f0e",
                "*obj": "*i2c_obj",
                "dev_address": "device_address",
                "*data": "*receive_buffer",
                "size": "receive_buffer_size",
                "HVar1": "i2c_state",
                "HVar2": "i2c_status",
                "uVar3": "start_time",
                "uVar4": "error_code",
                "uVar5": "elapsed_time",
                "iVar6": "return_status",
                "*hi2c": "*i2c_handle"
            },
            "code": "i2c_status_e_conflict receive_data_from_i2c_device_08007f0e(i2c_t_conflict *i2c_obj, uint8_t device_address, uint8_t *receive_buffer, uint16_t receive_buffer_size)\n{\n  HAL_I2C_StateTypeDef_conflict i2c_state;\n  HAL_StatusTypeDef_conflict i2c_status;\n  uint32_t start_time = HAL_GetTick();\n  uint32_t elapsed_time = 0;\n  uint32_t error_code;\n  i2c_status_e_conflict return_status = I2C_ERROR;\n  I2C_HandleTypeDef_conflict *i2c_handle;\n  do {\n    i2c_handle = &i2c_obj->handle;\n    i2c_status = HAL_I2C_Master_Receive_IT(i2c_handle, (ushort)device_address, receive_buffer, receive_buffer_size);\n    if (i2c_status == HAL_OK) {\n      return_status = I2C_OK;\n      while ((i2c_state = HAL_I2C_GetState(i2c_handle), i2c_state != HAL_I2C_STATE_READY && (return_status == I2C_OK))) {\n        elapsed_time = HAL_GetTick() - start_time;\n        if (elapsed_time < 0x65) {\n          error_code = HAL_I2C_GetError(i2c_handle);\n          if (error_code != 0) {\n            return_status = I2C_ERROR;\n          }\n        }\n        else {\n          return_status = I2C_TIMEOUT;\n        }\n      }\n    }\n    error_code = HAL_I2C_GetError(i2c_handle);\n  } while ((error_code == 4) && (elapsed_time < 100));\n  return return_status;\n}",
            "called": [
                "HAL_GetTick",
                "HAL_I2C_Master_Receive_IT",
                "HAL_I2C_GetState",
                "HAL_I2C_GetError"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007f0e",
            "calling": [
                "requestFrom"
            ],
            "imported": false,
            "current_name": "receive_data_from_i2c_device_08007f0e"
        },
        "FUN_08004004": {
            "renaming": {
                "FUN_08004004": "set_interrupt_handler_08004004",
                "IRQn_Type_conflict": "irq",
                "uVar1": "irq_num",
                "bit_pos": "bit_position",
                "reg_index": "register_index",
                "reg_ptr": "register_pointer"
            },
            "code": "void set_interrupt_handler_08004004(IRQn_Type_conflict irq) {\n  uint32_t irq_num = (uint32_t)irq;\n  if (irq_num >= 0) {\n    uint32_t bit_pos = irq_num & 0x1f;\n    uint32_t reg_index = (irq_num >> 5) + 0x60;\n    uint32_t* reg_ptr = (uint32_t*)(DAT_08004020 + reg_index * 4);\n    *reg_ptr = 1 << bit_pos;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004004",
            "calling": [
                "USART2_IRQHandler",
                "USART1_IRQHandler",
                "USART3_IRQHandler"
            ],
            "imported": false,
            "current_name": "set_interrupt_handler_08004004"
        },
        "FUN_08003158": {
            "renaming": {
                "FUN_08003158": "sendAnalogValue_08003158",
                "this": "marshaller",
                "pin": "pin",
                "value": "value",
                "local_a": "encoded_value"
            },
            "code": "void __thiscall firmata::FirmataMarshaller::sendAnalogValue_08003158(FirmataMarshaller *marshaller, uint8_t pin, uint16_t value) {\n    uint16_t encoded_value;\n\n    if (marshaller->FirmataStream != (Stream *)0x0) {\n        encoded_value = value;\n        if ((pin < 0x10) && (value < 0x4000)) {\n            (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller, pin | 0xe0);\n            encodeByteStream(marshaller, 2, (uint8_t *)&encoded_value, 2);\n        }\n        else {\n            sendExtendedAnalog(marshaller, pin, 2, (uint8_t *)&encoded_value);\n        }\n    }\n    return;\n}",
            "called": [
                "encodeByteStream",
                "sendExtendedAnalog"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003158",
            "calling": [
                "sendAnalog"
            ],
            "imported": false,
            "current_name": "sendAnalogValue_08003158"
        },
        "FUN_080090c2": {
            "renaming": {
                "FUN_080090c2": "register_exit_function_080090c2",
                "param_1": "func",
                "param_2": "arg"
            },
            "code": "void register_exit_function_080090c2(void (*func)(void), void *arg)\n{\n  __cxa_atexit(func, arg);\n  return;\n}",
            "called": [
                "__cxa_atexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080090c2",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "register_exit_function_080090c2"
        },
        "FUN_08000ef8": {
            "renaming": {
                "FUN_08000ef8": "FUNC_08000ef8"
            },
            "code": "\nvoid FUNC_08000ef8(void)\n\n{\n  byte bVar1;\n  bool bVar2;\n  uint32_t uVar3;\n  int iVar4;\n  byte bVar5;\n  \n  if (*PTR_reportPINs_08001188 != '\\0') {\n    bVar1 = *PTR_portConfigInputs_0800118c;\n    if (*PTR_digitalPin_08001190 == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(*PTR_digitalPin_08001190);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(*PTR_digitalPin_08001190);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_08001190[1] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[1]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[1]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(1);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001190[2] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[2]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[2]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(2);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001190[3] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[3]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[3]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(3);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001190[4] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[4]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[4]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(4);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001190[5] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[5]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[5]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(5);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001190[6] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[6]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[6]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(6);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001190[7] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[7]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[7]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(7);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\0',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_08001188[1] != '\\0') {\n    bVar1 = PTR_portConfigInputs_0800118c[1];\n    if (PTR_digitalPin_08001190[8] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001190[8]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[8]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(8);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_08001424[9] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[9]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[9]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(9);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001424[10] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[10]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[10]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(10);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001424[0xb] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xb]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xb]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xb);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001424[0xc] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xc]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xc]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xc);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001424[0xd] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xd]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xd]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xd);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001424[0xe] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xe]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xe]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xe);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001424[0xf] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xf]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0xf]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0xf);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x01',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_08001428[2] != '\\0') {\n    bVar1 = PTR_portConfigInputs_0800142c[2];\n    if (PTR_digitalPin_08001424[0x10] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0x10]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001424[0x10]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0x10);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_080016c4[0x11] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x11]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x11]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x11);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_080016c4[0x12] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x12]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x12]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x12);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_080016c4[0x13] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x13]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x13]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x13);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_080016c4[0x14] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x14]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x14]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x14);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_080016c4[0x15] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x15]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x15]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x15);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_080016c4[0x16] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x16]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x16]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x16);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_080016c4[0x17] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x17]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x17]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x17);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x02',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_080016c8[3] != '\\0') {\n    bVar1 = PTR_portConfigInputs_080016cc[3];\n    if (PTR_digitalPin_080016c4[0x18] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x18]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x18]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0x18);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_080016c4[0x19] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_080016c4[0x19]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x19]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x19);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001960[0x1a] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1a]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1a]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1a);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001960[0x1b] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1b]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1b]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1b);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001960[0x1c] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1c]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1c]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1c);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001960[0x1d] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1d]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1d]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1d);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001960[0x1e] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1e]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1e]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1e);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001960[0x1f] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1f]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x1f]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x1f);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x03',bVar5,'\\0');\n  }\n  if (PTR_reportPINs_08001964[4] != '\\0') {\n    bVar1 = PTR_portConfigInputs_08001968[4];\n    if (PTR_digitalPin_08001960[0x20] == NC) {\n      bVar5 = 0;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x20]);\n      if (uVar3 == 0) {\n        bVar5 = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x20]);\n        if (uVar3 == 1) {\n          bVar5 = 0;\n        }\n        else if ((bVar1 & 1) == 0) {\n          bVar5 = 0;\n        }\n        else {\n          iVar4 = digitalRead(0x20);\n          if (iVar4 == 0) {\n            bVar5 = 0;\n          }\n          else {\n            bVar5 = 1;\n          }\n        }\n      }\n    }\n    if (PTR_digitalPin_08001960[0x21] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x21]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001960[0x21]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 2) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x21);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 2;\n    }\n    if (PTR_digitalPin_08001b44[0x22] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x22]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x22]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 4) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x22);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 4;\n    }\n    if (PTR_digitalPin_08001b44[0x23] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x23]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x23]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 8) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x23);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 8;\n    }\n    if (PTR_digitalPin_08001b44[0x24] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x24]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x24]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x10) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x24);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x10;\n    }\n    if (PTR_digitalPin_08001b44[0x25] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x25]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x25]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x20) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x25);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x20;\n    }\n    if (PTR_digitalPin_08001b44[0x26] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x26]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x26]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x40) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x26);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x40;\n    }\n    if (PTR_digitalPin_08001b44[0x27] == NC) {\n      bVar2 = false;\n    }\n    else {\n      uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x27]);\n      if (uVar3 == 0) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08001b44[0x27]);\n        if (uVar3 == 1) {\n          bVar2 = false;\n        }\n        else if ((bVar1 & 0x80) == 0) {\n          bVar2 = false;\n        }\n        else {\n          iVar4 = digitalRead(0x27);\n          if (iVar4 == 0) {\n            bVar2 = false;\n          }\n          else {\n            bVar2 = true;\n          }\n        }\n      }\n    }\n    if (bVar2) {\n      bVar5 = bVar5 | 0x80;\n    }\n    outputPort('\\x04',bVar5,'\\0');\n  }\n  return;\n}\n\n",
            "called": [
                "digitalRead",
                "pinNametoDigitalPin",
                "outputPort"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08000ef8",
            "calling": [
                "loop"
            ],
            "imported": false,
            "current_name": "FUNC_08000ef8"
        },
        "FUN_08008846": {
            "renaming": {
                "FUN_08008846": "set_file_mode_to_directory_08008846",
                "file_UNUSED": "file_descriptor",
                "st": "file_status",
                "st_mode": "S_IFDIR"
            },
            "code": "int set_file_mode_to_directory_08008846(int file_descriptor, stat *file_status) {\n    file_status->st_mode = S_IFDIR;\n    return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008846",
            "calling": [
                "_fstat_r"
            ],
            "imported": false,
            "current_name": "set_file_mode_to_directory_08008846"
        },
        "FUN_0800a430": {
            "renaming": {
                "FUN_0800a430": "do_nothing_0800a430"
            },
            "code": "\nvoid do_nothing_0800a430(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a430",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0800a430"
        },
        "FUN_0800459c": {
            "renaming": {
                "FUN_0800459c": "transferData_0800459c",
                "hi2c": "i2c_handle",
                "puVar1": "buffer_ptr",
                "XferCount": "transfer_count",
                "pBuffPtr": "p_buffer_ptr",
                "Instance": "i2c_instance"
            },
            "code": "HAL_StatusTypeDef_conflict transferData_0800459c(I2C_HandleTypeDef_conflict *i2c_handle)\n{\n  uint8_t *buffer_ptr;\n  \n  if (i2c_handle->transfer_count != 0) {\n    buffer_ptr = i2c_handle->p_buffer_ptr;\n    i2c_handle->p_buffer_ptr = buffer_ptr + 1;\n    *buffer_ptr = (uint8_t)i2c_handle->Instance->DR;\n    i2c_handle->transfer_count--;\n  }\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800459c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "transferData_0800459c"
        },
        "FUN_0800774a": {
            "renaming": {
                "FUN_0800774a": "set_timer_0800774a",
                "obj": "timer_object",
                "value": "timer_value",
                "(obj->handle).Instance": "timer_handle",
                "CNT": "timer_value"
            },
            "code": "void set_timer_0800774a(stimer_t_conflict *timer_object, uint32_t timer_value)\n{\n  TIM_TypeDef *timer_handle = (timer_object->handle).Instance;\n  timer_handle->CNT = timer_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800774a",
            "calling": [
                "ServoIrqHandle"
            ],
            "imported": false,
            "current_name": "set_timer_0800774a"
        },
        "FUN_080027f0": {
            "renaming": {
                "__thiscall TwoWire::FUN_080027f0": "transmitData",
                "*this": "wire",
                "*data": "data",
                "quantity": "dataSize",
                "cVar1": "currentChar",
                "puVar2": "txBufferPtr",
                "iVar3": "i2cStatus",
                "pvVar4": "reallocPtr",
                "uVar5": "allocatedSize",
                "__size": "totalSize",
                "FUN_080027f0": "transmitData_080027f0"
            },
            "code": "size_t __thiscall TwoWire::transmitData_080027f0(TwoWire *this, uint8_t *data, size_t quantity) {\\n  char currentChar;\\n  undefined *txBufferPtr;\\n  i2c_status_e_conflict i2cStatus;\\n  void *reallocPtr;\\n  undefined allocatedSize;\\n  \\n  txBufferPtr = PTR_txBuffer_08002884;\\n  if (*PTR_transmitting_08002878 == \"\\0\") {\\n    i2cStatus = i2c_slave_transmitData_080027f0_IT((i2c_t_conflict *)&this->_i2c,data,(uint16_t)quantity);\\n    if (i2cStatus != I2C_OK) {\\n      return 0;\\n    }\\n    return quantity;\\n  }\\n  size_t totalSize = (byte)*PTR_txBufferLength_0800287c + quantity;\\n  if ((byte)*PTR_txBufferAllocated_08002880 < totalSize) {\\n    if (totalSize < 0x20) {\\n      totalSize = 0x20;\\n    }\\n    reallocPtr = realloc(*(void **)PTR_txBuffer_08002884, totalSize);\\n    *(void **)txBufferPtr = reallocPtr;\\n    if (reallocPtr == (void *)0x0) {\\n      allocatedSize = 0;\\n    }\\n    else {\\n      allocatedSize = (undefined)totalSize;\\n    }\\n    *PTR_txBufferAllocated_08002880 = allocatedSize;\\n  }\\n  txBufferPtr = PTR_txBufferIndex_08002888;\\n  if (*(int *)PTR_txBuffer_08002884 != 0) {\\n    memcpy((void *)((uint)(byte)*PTR_txBufferIndex_08002888 + *(int *)PTR_txBuffer_08002884), data, quantity);\\n    currentChar = *txBufferPtr + (char)quantity;\\n    *txBufferPtr = currentChar;\\n    *PTR_txBufferLength_0800287c = currentChar;\\n    return quantity;\\n  }\\n  (this->super_Stream).super_Print.transmitData_080027f0_error = 1;\\n  return 0;\\n}",
            "called": [
                "memcpy",
                "i2c_slave_write_IT",
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080027f0",
            "calling": [],
            "imported": false,
            "current_name": "transmitData_080027f0"
        },
        "FUN_0800314e": {
            "renaming": {
                "FUN_0800314e": "initialize_firmata_stream_0800314e",
                "this": "obj",
                "FirmataStream": "nullptr"
            },
            "code": "initialize_firmata_stream_0800314e* __thiscall initialize_firmata_stream_0800314e(initialize_firmata_stream_0800314e* obj) {\n  obj->FirmataStream = nullptr;\n  return obj;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800314e",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "initialize_firmata_stream_0800314e"
        },
        "FUN_080036a0": {
            "renaming": {
                "FUN_080036a0": "wait_forever_080036a0"
            },
            "code": "void wait_forever_080036a0(void)\n{\n    while(true)\n    {\n        // Do nothing, just wait\n    }\n}",
            "called": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036a0",
            "calling": [
                "USB_HP_CAN1_TX_IRQHandler"
            ],
            "imported": false,
            "current_name": "wait_forever_080036a0"
        },
        "FUN_080036a2": {
            "renaming": {
                "FUN_080036a2": "initialize_hardware_080036a2",
                "ctx": "context",
                "hw_config_FUN_080036a2": "initialize_hardware_config"
            },
            "code": "int initialize_hardware_080036a2(EVP_PKEY_CTX *context) {\n  initialize_hardware_080036a2_config();\n  return (int)context;\n}",
            "called": [
                "hw_config_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080036a2",
            "calling": [
                "premain"
            ],
            "imported": false,
            "current_name": "initialize_hardware_080036a2"
        },
        "FUN_080038e4": {
            "renaming": {
                "FUN_080038e4": "adc_configure_080038e4",
                "*hadc": "hadc",
                "*sConfig": "config",
                "HVar1": "status",
                "uVar2": "rank",
                "*pAVar3": "instance",
                "wait_loop_index": "wait_loop_index",
                "HAL_LOCKED": "HAL_LOCKED",
                "HAL_BUSY": "HAL_BUSY",
                "ADC1": "ADC1",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "DAT_08003a10": "DAT_08003a10",
                "DAT_08003a18": "DAT_08003a18",
                "PTR_SystemCoreClock_08003a14": "PTR_SystemCoreClock_08003a14",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "code": "HAL_StatusTypeDef adc_configure_080038e4(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *config)\n{\n    HAL_StatusTypeDef status;\n    uint32_t rank = config->Rank;\n    uint32_t channel = config->Channel;\n    uint32_t sampling_time = config->SamplingTime;\n    ADC_TypeDef *instance = hadc->Instance;\n    uint32_t wait_loop_index;\n\n    if (hadc->Lock == HAL_LOCKED) {\n        status = HAL_BUSY;\n    }\n    else {\n        hadc->Lock = HAL_LOCKED;\n        if (rank < 7) {\n            rank = rank * 5 - 5;\n            instance->SQR3 = channel << (rank & 0xff) | instance->SQR3 & ~(0x1f << (rank & 0xff));\n        }\n        else if (rank < 0xd) {\n            rank = rank * 5 - 0x23;\n            instance->SQR2 = channel << (rank & 0xff) | instance->SQR2 & ~(0x1f << (rank & 0xff));\n        }\n        else {\n            rank = rank * 5 - 0x41;\n            instance->SQR1 = channel << (rank & 0xff) | instance->SQR1 & ~(0x1f << (rank & 0xff));\n        }\n        if (channel < 10) {\n            instance->SMPR2 = sampling_time << (channel * 3 & 0xff) | instance->SMPR2 & ~(7 << (channel * 3 & 0xff));\n        }\n        else {\n            channel = channel * 3 - 0x1e;\n            instance->SMPR1 = sampling_time << (channel & 0xff) | instance->SMPR1 & ~(7 << (channel & 0xff));\n        }\n        if (channel - 0x10 < 2) {\n            if (instance == ADC1) {\n                if ((instance->CR2 & 0x800000) == 0) {\n                    instance->CR2 |= 0x800000;\n                    if (channel == 0x10) {\n                        for (wait_loop_index = (uint)((uint64_t)CLOCKS_PER_SEC * (uint64_t)*(uint *)SystemCoreClock >> 0x32) * 10; wait_loop_index != 0; wait_loop_index--);\n                        status = HAL_OK;\n                    }\n                    else {\n                        status = HAL_OK;\n                    }\n                }\n                else {\n                    status = HAL_OK;\n                }\n            }\n            else {\n                hadc->State |= 0x20;\n                status = HAL_ERROR;\n            }\n        }\n        else {\n            status = HAL_OK;\n        }\n        hadc->Lock = HAL_UNLOCKED;\n    }\n    return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080038e4",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "adc_configure_080038e4"
        },
        "FUN_08005e68": {
            "renaming": {
                "FUN_08005e68": "do_nothing_08005e68"
            },
            "code": "\nvoid do_nothing_08005e68(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005e68",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_08005e68"
        },
        "FUN_08005d48": {
            "renaming": {
                "FUN_08005d48": "configure_timer_08005d48",
                "TIMx": "timer",
                "OC_Config": "output_channel_config",
                "uVar1": "temp_reg_value",
                "uVar2": "timer_cr2_value",
                "uVar3": "output_channel_mode"
            },
            "code": "void configure_timer_08005d48(TIM_TypeDef_conflict *timer, TIM_OC_InitTypeDef *output_channel_config) {\n  uint32_t temp_reg_value;\n  uint32_t timer_cr2_value;\n  uint8_t output_channel_mode;\n  uint8_t output_channel_polarity;\n  uint8_t output_channel_n_polarity;\n  uint8_t output_channel_idle_state;\n  uint8_t output_channel_n_idle_state;\n\n  // Disable output channel 3\n  timer->CCER &= ~(1 << 8);\n\n  // Save CR2 register\n  timer_cr2_value = timer->CR2;\n\n  // Extract output channel mode\n  output_channel_mode = output_channel_config->OCMode;\n\n  // Extract output channel polarity\n  output_channel_polarity = output_channel_config->OCPolarity;\n  temp_reg_value = timer->CCER & ~(1 << 9);\n  temp_reg_value |= (output_channel_polarity << 8);\n\n  // Configure output channel 3 for timer 2\n  if (timer == PTR_TIM2) {\n    output_channel_n_polarity = output_channel_config->OCNPolarity;\n    output_channel_idle_state = output_channel_config->OCIdleState;\n    output_channel_n_idle_state = output_channel_config->OCNIdleState;\n    temp_reg_value &= ~(1 << 11);\n    temp_reg_value |= (output_channel_n_polarity << 8) & ~(1 << 10);\n    timer_cr2_value &= ~(3 << 12);\n    timer_cr2_value |= ((output_channel_idle_state << 4) | (output_channel_n_idle_state << 4)) & (3 << 12);\n  }\n\n  // Write back register values\n  timer->CR2 = timer_cr2_value;\n  timer->CCMR2 = (timer->CCMR2 & ~(7 << 12)) | (output_channel_mode << 12);\n  timer->CCR3 = output_channel_config->Pulse;\n  timer->CCER = temp_reg_value;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005d48",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_08005d48"
        },
        "FUN_08008ba4": {
            "renaming": {
                "FUN_08008ba4": "writeByte_08008ba4",
                "this": "serial",
                "c": "byte",
                "_written": "is_written",
                "uVar2": "tx_active",
                "bVar1": "next_head",
                "uVar5": "tx_head",
                "bVar3": "next_head_masked",
                "iVar4": "next_head_int"
            },
            "code": "size_t __thiscall HardwareSerial::writeByte_08008ba4(HardwareSerial *serial, uint8_t byte)\n{\n  bool is_written;\n  byte next_head;\n  byte next_head_masked;\n  int next_head_int;\n  uint tx_head;\n  uint tx_tail;\n  serial_t* serial_ptr;\n  uint8_t tx_active;\n  \n  is_written = true;\n  tx_head = (uint)serial->_serial.tx_head;\n  next_head_int = tx_head + 1;\n  next_head = (byte)next_head_int;\n  next_head_masked = next_head & 0x7f;\n  if (next_head_int == 0) {\n    next_head_masked = -(-next_head & 0x7f);\n  }\n  do {\n  } while (serial->_serial.tx_tail == (ushort)next_head_masked);\n  serial->_serial.tx_buff[tx_head] = byte;\n  serial->_serial.tx_head = (ushort)next_head_masked;\n  tx_tail = (uint)serial->_serial.tx_tail;\n  serial_ptr = (serial_t*)&serial->_serial;\n  tx_active = serial_tx_active(serial_ptr);\n  if (tx_active == \"\\0\") {\n    uart_attach_tx_callback(serial_ptr, DAT_08008bf0);\n  }\n  return 1;\n}",
            "called": [
                "uart_attach_tx_callback",
                "serial_tx_active"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ba4",
            "calling": [],
            "imported": false,
            "current_name": "writeByte_08008ba4"
        },
        "FUN_08009ff8": {
            "renaming": {
                "FUN_08009ff8": "kill_process_if_running_08009ff8",
                "param_1": "error_code",
                "param_2": "process_id",
                "param_3": "signal_number",
                "puVar1": "error_ptr",
                "iVar2": "kill_result"
            },
            "code": "void kill_process_if_running_08009ff8(int *error_code, int process_id, int signal_number)\n{\n  undefined *error_ptr;\n  int kill_result;\n  error_ptr = PTR_errno_0800a018;\n  *(undefined4 *)PTR_errno_0800a018 = 0;\n  kill_result = _kill(process_id, signal_number);\n  if ((kill_result == -1) && (*(int *)error_ptr != 0)) {\n    *error_code = *(int *)error_ptr;\n  }\n  return;\n}",
            "called": [
                "_kill"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009ff8",
            "calling": [
                "_raise_r"
            ],
            "imported": false,
            "current_name": "kill_process_if_running_08009ff8"
        },
        "FUN_08009db0": {
            "renaming": {
                "FUN_08009db0": "initialize_array_08009db0",
                "param_1": "array_ptr",
                "piVar1": "current_ptr",
                "piVar2": "last_ptr",
                "iVar3": "global_impure_ptr",
                "ppiVar4": "last_ptr_ptr"
            },
            "code": "int * initialize_array_08009db0(int *array_ptr)\n{\n  int *current_ptr;\n  int *last_ptr;\n  int global_impure_ptr = *(int *)PTR__global_impure_ptr_08009e24;\n  if (*(int *)(global_impure_ptr + 0x18) == 0) {\n    __sinit(global_impure_ptr);\n  }\n  last_ptr = (int *)(global_impure_ptr + 0x48);\n  do {\n    current_ptr = last_ptr[2];\n    last_ptr = last_ptr[1];\n    while (current_ptr = (int *)((int)current_ptr + -1), -1 < (int)current_ptr) {\n      if (*(short *)(last_ptr + 3) == 0) {\n        *(undefined2 *)((int)last_ptr + 0xe) = 0xffff;\n        last_ptr[0x19] = 0;\n        *(undefined2 *)(last_ptr + 3) = 1;\n        *last_ptr = 0;\n        last_ptr[2] = 0;\n        last_ptr[1] = 0;\n        last_ptr[4] = 0;\n        last_ptr[5] = 0;\n        last_ptr[6] = 0;\n        memset(last_ptr + 0x17,0,8);\n        last_ptr[0xd] = 0;\n        last_ptr[0xe] = 0;\n        last_ptr[0x12] = 0;\n        last_ptr[0x13] = 0;\n        return last_ptr;\n      }\n      last_ptr = last_ptr + 0x1a;\n    }\n    if (*last_ptr == (int *)0x0) {\n      current_ptr = (int *)__sfmoreglue(array_ptr,4);\n      *last_ptr = current_ptr;\n      if (current_ptr == (int *)0x0) {\n        *array_ptr = 0xc;\n        return (int *)0x0;\n      }\n    }\n    last_ptr = (int **)*last_ptr;\n  } while( true );\n}",
            "called": [
                "memset",
                "__sinit",
                "__sfmoreglue"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009db0",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "initialize_array_08009db0"
        },
        "FUN_08002c2c": {
            "renaming": {
                "FUN_08002c2c": "analog_callback_handler_08002c2c",
                "param_1": "callback_function",
                "command": "command",
                "value": "value",
                "PTR_currentAnalogCallback_08002c3c": "current_analog_callback"
            },
            "code": "void firmata::FirmataClass::analog_callback_handler_08002c2c(void *callback_function, uint8_t command, uint16_t value)\n{\n  if (*(code **)PTR_currentAnalogCallback_08002c3c != (code *)0x0) {\n    (**(code **)PTR_currentAnalogCallback_08002c3c)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c2c",
            "calling": [],
            "imported": false,
            "current_name": "analog_callback_handler_08002c2c"
        },
        "FUN_080072f0": {
            "renaming": {
                "FUN_080072f0": "read_GPIO_Pin_State_080072f0",
                "port": "GPIO_port",
                "pin": "GPIO_pin",
                "GVar1": "pin_state"
            },
            "code": "uint32_t read_GPIO_Pin_State_080072f0(GPIO_TypeDef *port, uint32_t pin)\n{\n  GPIO_PinState pin_state;\n  pin_state = HAL_GPIO_ReadPin(port, (uint16_t)pin);\n  return (uint32_t)pin_state;\n}",
            "called": [
                "HAL_GPIO_ReadPin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072f0",
            "calling": [
                "digitalRead"
            ],
            "imported": false,
            "current_name": "read_GPIO_Pin_State_080072f0"
        },
        "FUN_08000178": {
            "renaming": {
                "FUN_08000178": "string_length_08000178",
                "__s": "str",
                "pcVar3": "current_position",
                "pcVar2": "next_position",
                "cVar1": "current_char"
            },
            "code": "size_t string_length_08000178(char* str) {\n  char current_char;\n  char* current_position = str;\n  while (current_char = *current_position) {\n    current_position++;\n  }\n  return (size_t)(current_position - str);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000178",
            "calling": [
                "sendString",
                "setFirmwareNameAndVersion",
                "printNumber"
            ],
            "imported": false,
            "current_name": "string_length_08000178"
        },
        "FUN_08000a64": {
            "renaming": {
                "FUN_08000a64": "checkI2CPins_08000a64",
                "_Var1": "is_valid_pin",
                "uVar2": "digital_pin",
                "uVar3": "pin_index"
            },
            "code": "void checkI2CPins_08000a64()\n{\n  bool is_valid_pin;\n  uint32_t digital_pin;\n  uint pin_index;\n  for (pin_index = 0; pin_index < 0x3c; pin_index = (pin_index + 1) & 0xff) {\n    if (pin_index < 0x3c) {\n      if (PTR_digitalPin_08000ad8[pin_index] == NC) {\n        is_valid_pin = false;\n      }\n      else {\n        digital_pin = pinNametoDigitalPin(PTR_digitalPin_08000ad8[pin_index]);\n        if (digital_pin == 0 || digital_pin == 1) {\n          is_valid_pin = false;\n        }\n        else {\n          is_valid_pin = pin_in_pinmap(PTR_digitalPin_08000ad8[pin_index], (PinMap_conflict *)PTR_PinMap_I2C_SDA_08000adc);\n          if (!is_valid_pin) {\n            is_valid_pin = pin_in_pinmap(PTR_digitalPin_08000ad8[pin_index], (PinMap_conflict *)PTR_PinMap_I2C_SCL_08000ae0);\n          }\n        }\n      }\n    }\n    else {\n      is_valid_pin = false;\n    }\n    if (is_valid_pin) {\n      setPinModeCallback((byte)pin_index, 6);\n    }\n  }\n  *PTR_isI2CEnabled_08000ae4 = 1;\n  TwoWire::begin((TwoWire *)PTR_Wire_08000ae8);\n  return;\n}",
            "called": [
                "pin_in_pinmap",
                "pinNametoDigitalPin",
                "begin",
                "setPinModeCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000a64",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "checkI2CPins_08000a64"
        },
        "FUN_08002c40": {
            "renaming": {
                "FUN_08002c40": "handleDigitalInput_08002c40",
                "param_1": "callbackFunction",
                "command": "command",
                "value": "value",
                "PTR_currentDigitalCallback_08002c50": "currentDigitalCallback"
            },
            "code": "void firmata::FirmataClass::handleDigitalInput_08002c40(void *callbackFunction, uint8_t command, uint16_t value)\n{\n  if (*(code **)PTR_currentDigitalCallback_08002c50 != (code *)0x0) {\n    (**(code **)PTR_currentDigitalCallback_08002c50)(command,value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c40",
            "calling": [],
            "imported": false,
            "current_name": "handleDigitalInput_08002c40"
        },
        "FUN_0800694c": {
            "renaming": {
                "FUN_0800694c": "receive_data_0800694c",
                "huart": "uart",
                "pbVar1": "rx_byte",
                "uVar2": "xfer_count",
                "puVar3": "rx_byte_ptr",
                "WordLength": "word_length",
                "Parity": "parity",
                "pRxBuffPtr": "rx_buffer",
                "Instance": "uart_instance",
                "DR": "received_data",
                "RxXferCount": "xfer_count",
                "RxState": "uart_state",
                "HAL_BUSY": "HAL_BUSY",
                "HAL_OK": "HAL_OK",
                "HAL_UART_STATE_BUSY_RX": "HAL_UART_STATE_BUSY_RX",
                "HAL_UART_STATE_READY": "HAL_UART_STATE_READY",
                "HAL_UART_RxCpltCallback": "HAL_UART_RxCpltCallback"
            },
            "code": "HAL_StatusTypeDef receive_data_0800694c(UART_HandleTypeDef *uart)\n{\n  uint16_t word_length = (uart->Init).WordLength;\n  uint8_t parity = (uart->Init).Parity;\n  uint8_t *rx_buffer = uart->pRxBuffPtr;\n  uint16_t received_data = uart->Instance->DR;\n  uint16_t xfer_count = uart->RxXferCount;\n  if (uart->RxState != HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  if (word_length == 0x1000) {\n    if (parity == 0) {\n      *(uint16_t *)rx_buffer = (received_data & 0x7FFF);\n      rx_buffer += 2;\n    }\n    else {\n      *(uint16_t *)rx_buffer = (received_data & 0xFF);\n      rx_buffer++;\n    }\n  }\n  else if (parity == 0) {\n    *rx_buffer = (uint8_t)received_data;\n    rx_buffer++;\n  }\n  else {\n    *rx_buffer = (received_data & 0x7F);\n    rx_buffer++;\n  }\n  xfer_count--;\n  uart->RxXferCount = xfer_count;\n  if (xfer_count != 0) {\n    return HAL_OK;\n  }\n  uart->Instance->CR1 &= 0xFFFFFFDF;\n  uart->Instance->CR1 &= 0xFFFFFEFF;\n  uart->Instance->CR3 &= 0xFFFFFFFE;\n  uart->RxState = HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(uart);\n  return HAL_OK;\n}",
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800694c",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "receive_data_0800694c"
        },
        "FUN_0800a0ec": {
            "renaming": {
                "FUN_0800a0ec": "get_file_status_0800a0ec",
                "param_1": "status",
                "param_2": "file_descriptor",
                "param_3": "file_stat",
                "puVar1": "errno_ptr",
                "iVar2": "file_status"
            },
            "code": "void get_file_status_0800a0ec(int *status, int file_descriptor, stat *file_stat) {\n  int *errno_ptr = PTR_errno_0800a10c;\n  * (int *) PTR_errno_0800a10c = 0;\n  int file_status = _fstat(file_descriptor, file_stat);\n  if ((file_status == -1) && (*errno_ptr != 0)) {\n    *status = *errno_ptr;\n  }\n  return;\n}",
            "called": [
                "_fstat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a0ec",
            "calling": [
                "__swhatbuf_r"
            ],
            "imported": false,
            "current_name": "get_file_status_0800a0ec"
        },
        "FUN_08008df8": {
            "renaming": {
                "FUN_08008df8::FUN_08008df8": "createIPAddress",
                "this": "ipAddressObj",
                "first_octet": "octet1",
                "second_octet": "octet2",
                "third_octet": "octet3",
                "fourth_octet": "octet4",
                "super_Printable": "superPrintableObj",
                "_vptr_Printable": "vptrPrintable",
                "PTR_DAT_08008e10": "PTR_DAT_08008e10",
                "_address": "ipAddress",
                "bytes": "ipAddressBytes",
                "FUN_08008df8": "createIPAddress_08008df8"
            },
            "code": "createIPAddress_08008df8 * __thiscall createIPAddress_08008df8(createIPAddress_08008df8 *this, uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)\n{\n  (this->superPrintable)._vptrPrintable = (_func_int_varargs **)PTR_DAT_08008e10;\n  (this->ipAddress).bytes[0] = first_octet;\n  (this->ipAddress).bytes[1] = second_octet;\n  (this->ipAddress).bytes[2] = third_octet;\n  (this->ipAddress).bytes[3] = fourth_octet;\n  return this;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008df8",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "createIPAddress_08008df8"
        },
        "FUN_08000188": {
            "renaming": {
                "FUN_08000188": "read_cpu_id_08000188",
                "a0": "id",
                "a1": "mask",
                "a2": "interrupt_type"
            },
            "code": "uint32_t read_cpu_id_08000188(uint32_t id, uint32_t mask, int32_t interrupt_type)\n{\n  software_interrupt(0x3f);\n  return id;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000188",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "read_cpu_id_08000188"
        },
        "FUN_08004f3c": {
            "renaming": {
                "FUN_08004f3c": "i2c_handle_state_08004f3c",
                "hi2c": "handle",
                "HVar1": "status",
                "puVar2": "buffer_ptr",
                "pIVar3": "instance"
            },
            "code": "void i2c_handle_state_08004f3c(I2C_HandleTypeDef_conflict *handle)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint8_t *buffer_ptr;\n  I2C_TypeDef_conflict *instance;\n  \n  if ((byte)handle->State - 0x29 < 2) {\n    handle->PreviousState = 0;\n    handle->State = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((handle->State != HAL_I2C_STATE_ABORT) && ((handle->Instance->CR2 & 0x800) == 0)) {\n      handle->State = HAL_I2C_STATE_READY;\n    }\n    handle->PreviousState = 0;\n    handle->Mode = HAL_I2C_MODE_NONE;\n  }\n  handle->Instance->CR1 = handle->Instance->CR1 & 0xfffff7ff;\n  instance = handle->Instance;\n  if ((instance->CR2 & 0x800) == 0) {\n    if (handle->State == HAL_I2C_STATE_ABORT) {\n      handle->State = HAL_I2C_STATE_READY;\n      handle->ErrorCode = 0;\n      if ((instance->SR1 & 0x40) != 0) {\n        buffer_ptr = handle->pBuffPtr;\n        handle->pBuffPtr = buffer_ptr + 1;\n        *buffer_ptr = (uint8_t)instance->DR;\n      }\n      handle->Instance->CR1 = handle->Instance->CR1 & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(handle);\n    }\n    else {\n      if ((instance->SR1 & 0x40) != 0) {\n        buffer_ptr = handle->pBuffPtr;\n        handle->pBuffPtr = buffer_ptr + 1;\n        *buffer_ptr = (uint8_t)instance->DR;\n      }\n      HAL_I2C_ErrorCallback(handle);\n    }\n  }\n  else {\n    instance->CR2 = instance->CR2 & 0xfffff7ff;\n    if (handle->hdmatx->State == HAL_DMA_STATE_READY) {\n      handle->hdmarx->XferAbortCallback = handle->hdmatx->XferAbortCallback;\n      status = HAL_DMA_Abort_IT(handle->hdmarx);\n      if (status != HAL_OK) {\n        if ((handle->Instance->SR1 & 0x40) != 0) {\n          buffer_ptr = handle->pBuffPtr;\n          handle->pBuffPtr = buffer_ptr + 1;\n          *buffer_ptr = (uint8_t)handle->Instance->DR;\n        }\n        handle->Instance->CR1 = handle->Instance->CR1 & 0xfffffffe;\n        handle->State = HAL_I2C_STATE_READY;\n        (*handle->hdmarx->XferAbortCallback)(handle->hdmarx);\n      }\n    }\n    else {\n      handle->hdmatx->XferAbortCallback = handle->hdmarx->XferAbortCallback;\n      status = HAL_DMA_Abort_IT(handle->hdmatx);\n      if (status != HAL_OK) {\n        handle->Instance->CR1 = handle->Instance->CR1 & 0xfffffffe;\n        handle->State = HAL_I2C_STATE_READY;\n        (*handle->hdmatx->XferAbortCallback)(handle->hdmatx);\n      }\n    }\n  }\n  if ((handle->State == HAL_I2C_STATE_LISTEN) && ((handle->ErrorCode & 4) != 0)) {\n    handle->XferOptions = I2C_TRANSFER_OPTIONS;\n    handle->PreviousState = 0;\n    handle->State = HAL_I2C_STATE_READY;\n    handle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(handle);\n  }\n  return;\n}",
            "called": [
                "HAL_DMA_Abort_IT",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f3c",
            "calling": [
                "HAL_I2C_ER_IRQHandler",
                "I2C_Slave_STOPF"
            ],
            "imported": false,
            "current_name": "i2c_handle_state_08004f3c"
        },
        "FUN_08004f3a": {
            "renaming": {
                "FUN_08004f3a": "do_nothing_08004f3a"
            },
            "code": "\nvoid do_nothing_08004f3a(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004f3a",
            "calling": [
                "I2C_DMAAbort",
                "I2C_ITError"
            ],
            "imported": false,
            "current_name": "do_nothing_08004f3a"
        },
        "FUN_0800344a": {
            "renaming": {
                "FUN_0800344a": "resetState_0800344a",
                "this": "parser",
                "uVar1": "dataBufferIndex"
            },
            "code": "void __thiscall firmata::FirmataParser::resetState_0800344a(FirmataParser *parser)\\n{\\n  uint dataBufferIndex;\\n  parser->waitForData = 0;\\n  parser->executeMultiByteCommand = \"\\0\";\\n  parser->multiByteChannel = \"\\0\";\\n  for (dataBufferIndex = 0; dataBufferIndex < parser->dataBufferSize; dataBufferIndex = dataBufferIndex + 1) {\\n    parser->dataBuffer[dataBufferIndex] = \"\\0\";\\n  }\\n  parser->parsingSysex = false;\\n  parser->sysexBytesRead = 0;\\n  if (parser->currentSystemResetCallback != (systemCallbackFunction)0x0) {\\n    (*parser->currentSystemResetCallback)(parser->currentSystemResetCallbackContext);\\n  }\\n  return;\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800344a",
            "calling": [
                "parse"
            ],
            "imported": false,
            "current_name": "resetState_0800344a"
        },
        "FUN_080071e4": {
            "renaming": {
                "FUN_080071e4": "stop_pwm_signal_080071e4",
                "pin": "pin_name",
                "Channel": "channel",
                "uVar1": "function_code",
                "timHandle": "tim_handle",
                "TIM_HandleTypeDef_conflict": "TIM_HandleTypeDef",
                "TIM_TypeDef_conflict": "TIM_TypeDef",
                "get_pwm_channel": "get_channel",
                "PinMap_conflict": "PinMap",
                "pinmap_peripheral": "map_pin_to_peripheral",
                "pinmap_function": "map_pin_to_function",
                "HAL_TIM_PWM_Stop": "stop_tim_pwm",
                "HAL_TIMEx_PWMN_Stop": "stop_tim_pwmn",
                "HAL_TIM_PWM_DeInit": "deinit_tim_pwm"
            },
            "code": "void stop_pwm_signal_080071e4(PinName_conflict pin)\n{\n  uint32_t channel;\n  uint32_t function_code;\n  TIM_HandleTypeDef_conflict tim_handle;\n  tim_handle.Instance = (TIM_TypeDef_conflict *)pinmap_peripheral(pin, (PinMap_conflict *)PTR_PinMap_PWM_08007238);\n  if ((tim_handle.Instance != (TIM_TypeDef_conflict *)0x0) && (((channel = get_pwm_channel(pin), channel == 0 || channel == 4) || channel == 8) || (channel == 0xc || channel == 0x18)))\n  {\n    function_code = pinmap_function(pin, (PinMap_conflict *)PTR_PinMap_PWM_08007238);\n    if ((function_code & 0x100000) == 0)\n    {\n      HAL_TIM_PWM_Stop(&tim_handle, channel);\n    }\n    else\n    {\n      HAL_TIMEx_PWMN_Stop(&tim_handle, channel);\n    }\n    HAL_TIM_PWM_DeInit(&tim_handle);\n  }\n  return;\n}",
            "called": [
                "pinmap_function",
                "HAL_TIM_PWM_Stop",
                "get_pwm_channel",
                "pinmap_peripheral",
                "HAL_TIM_PWM_DeInit",
                "HAL_TIMEx_PWMN_Stop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080071e4",
            "calling": [
                "pinMode"
            ],
            "imported": false,
            "current_name": "stop_pwm_signal_080071e4"
        },
        "FUN_08002c54": {
            "renaming": {
                "FUN_08002c54": "handlePinModeChange_08002c54",
                "param_1": "pinModeCallback",
                "command": "command",
                "value": "value",
                "PTR_currentPinModeCallback_08002c64": "currentPinModeCallback"
            },
            "code": "void firmata::FirmataClass::handlePinModeChange_08002c54(void *pinModeCallback, uint8_t command, uint16_t value) {\n  if (*(code **)PTR_currentPinModeCallback_08002c64 != (code *)0x0) {\n    (**(code **)PTR_currentPinModeCallback_08002c64)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c54",
            "calling": [],
            "imported": false,
            "current_name": "handlePinModeChange_08002c54"
        },
        "FUN_080072fa": {
            "renaming": {
                "FUN_080072fa": "initialize_system_080072fa"
            },
            "code": "void initialize_system_080072fa(void)\n{\n  HAL_Init();\n  SystemClock_Config();\n  return;\n}",
            "called": [
                "HAL_Init",
                "SystemClock_Config"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072fa",
            "calling": [
                "init"
            ],
            "imported": false,
            "current_name": "initialize_system_080072fa"
        },
        "FUN_08003346": {
            "renaming": {
                "FUN_08003346": "setReportFirmwareCallback_08003346",
                "this": "thisParser",
                "command": "firmwareCommand",
                "newFunction": "firmwareCallback",
                "context": "firmwareCallbackContext",
                "currentReportFirmwareCallback": "firmwareCallbackFunction",
                "currentReportFirmwareCallbackContext": "firmwareCallbackFunctionContext"
            },
            "code": "void __thiscall firmata::FirmataParser::setReportFirmwareCallback_08003346(FirmataParser *thisParser, uint8_t command, versionCallbackFunction newFunction, void *context) {\n  if (command == 'y') {\n    thisParser->currentReportFirmwareCallback = newFunction;\n    thisParser->currentReportFirmwareCallbackContext = context;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003346",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "setReportFirmwareCallback_08003346"
        },
        "FUN_08003106": {
            "renaming": {
                "FUN_08003106": "sendPinState_08003106",
                "this": "marshaller",
                "pin": "pinNumber",
                "bytec": "byteCount",
                "bytev": "byteValues",
                "FirmataStream": "stream",
                "_vptr_Print": "vptrPrint",
                "encodeByteStream": "encodeBytes"
            },
            "code": "void __thiscall firmata::FirmataMarshaller::sendPinState_08003106(FirmataMarshaller *marshaller, uint8_t pin, size_t byteCount, uint8_t *byteValues) {\n    if (marshaller->stream != nullptr) {\n        marshaller->stream->write(0xf0);\n        marshaller->stream->write(0x6f);\n        marshaller->stream->write(pin);\n        encodeByteStream(marshaller, byteCount, byteValues, byteCount);\n        marshaller->stream->write(0xf7);\n    }\n    return;\n}",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003106",
            "calling": [
                "sendAnalog"
            ],
            "imported": false,
            "current_name": "sendPinState_08003106"
        },
        "FUN_08007708": {
            "renaming": {
                "FUN_08007708": "enable_timer_clock_08007708",
                "htim": "timer_handle"
            },
            "code": "void enable_timer_clock_08007708(TIM_HandleTypeDef_conflict *timer_handle)\n{\n  timer_enable_clock(timer_handle);\n  return;\n}",
            "called": [
                "timer_enable_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007708",
            "calling": [
                "HAL_TIM_OC_Init"
            ],
            "imported": false,
            "current_name": "enable_timer_clock_08007708"
        },
        "FUN_0800018c": {
            "renaming": {
                "FUN_0800018c": "execute_afl_call_0800018c",
                "ticks": "num_ticks",
                "uVar1": "result"
            },
            "code": "uint32_t execute_afl_call_0800018c(int ticks)\n{\n    uint32_t result = 0;\n    if (*(int *)PTR_noHyperCall_080001a4 != 0) {\n        return result;\n    }\n    result = aflCall(1, ticks, 0);\n    return result;\n}",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800018c",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "execute_afl_call_0800018c"
        },
        "FUN_08003f94": {
            "renaming": {
                "FUN_08003f94": "set_interrupt_priority_08003f94",
                "IRQn": "interrupt_number",
                "uVar1": "interrupt_register_index",
                "DAT_08003fac": "INTERRUPT_REGISTER_BASE_ADDRESS"
            },
            "code": "void set_interrupt_priority_08003f94(IRQn_Type_conflict interrupt_number)\n{\n  uint32_t interrupt_register_index;\n  interrupt_register_index = (uint32_t)interrupt_number;\n  if (interrupt_register_index >= 0) {\n    *(int *)(interrupt_register_index * 4 + DAT_08003fac) = 1 << (interrupt_register_index % 32);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f94",
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback",
                "TimerPulseInit",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_08003f94"
        },
        "FUN_08002c68": {
            "renaming": {
                "FUN_08002c68": "processPinValue_08002c68",
                "param_1": "callbackPointer",
                "command": "command",
                "value": "value",
                "PTR_currentPinValueCallback_08002c78": "currentPinValueCallback"
            },
            "code": "void firmata::FirmataClass::processPinValue_08002c68(void *callbackPointer, uint8_t command, uint16_t value) {\n  if (*(code **)PTR_currentPinValueCallback_08002c78 != (code *)0x0) {\n    (**(code **)callbackPointer)(command, value);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c68",
            "calling": [],
            "imported": false,
            "current_name": "processPinValue_08002c68"
        },
        "FUN_08002a26": {
            "renaming": {
                "TwoWire::FUN_08002a26": "TwoWire::sendData",
                "this": "wireInstance",
                "FUN_08002a26": "sendData_08002a26"
            },
            "code": "void __thiscall TwoWire::sendData_08002a26(TwoWire *wireInstance)\n{\n  sendData_08002a26(wireInstance, 0x33);\n  return;\n}",
            "called": [
                "begin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a26",
            "calling": [
                "enableI2CPins"
            ],
            "imported": false,
            "current_name": "sendData_08002a26"
        },
        "FUN_0800430c": {
            "renaming": {
                "FUN_0800430c": "configureI2C_0800430c",
                "hi2c": "i2cHandler",
                "Mode": "transmissionMode",
                "EventCount": "eventCount",
                "Instance": "i2cInstance",
                "Devaddress": "deviceAddress",
                "AddressingMode": "addressingMode",
                "State": "i2cState"
            },
            "code": "HAL_StatusTypeDef configureI2C_0800430c(I2C_HandleTypeDef *i2cHandler)\n{\n    uint8_t deviceAddress = i2cHandler->Devaddress;\n    uint8_t deviceAddressLSB = deviceAddress & 0xff;\n    uint8_t deviceAddressMSB = ((deviceAddress << 0x10) >> 0x17) & 6;\n    uint8_t transmissionMode = i2cHandler->Mode;\n    uint16_t eventCount = i2cHandler->EventCount;\n    I2C_TypeDef *i2cInstance = i2cHandler->Instance;\n\n    if (transmissionMode == HAL_I2C_MODE_MEM)\n    {\n        if (eventCount == 0)\n        {\n            i2cInstance->DR = deviceAddress & 0xfe;\n        }\n        else\n        {\n            i2cInstance->DR = deviceAddressLSB | 1;\n        }\n    }\n    else if ((i2cHandler->Init).AddressingMode == 0x4000)\n    {\n        if (i2cHandler->State == HAL_I2C_STATE_BUSY_TX)\n        {\n            i2cInstance->DR = deviceAddress & 0xfe;\n        }\n        else\n        {\n            i2cInstance->DR = deviceAddressLSB | 1;\n        }\n    }\n    else if (eventCount == 0)\n    {\n        i2cInstance->DR = deviceAddressMSB | 0xf0;\n    }\n    else if (eventCount == 1)\n    {\n        i2cInstance->DR = deviceAddressMSB | 0xf1;\n    }\n    return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800430c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "configureI2C_0800430c"
        },
        "FUN_08003350": {
            "renaming": {
                "FUN_08003350": "setCallbackFunctions_08003350",
                "command": "commandByte",
                "newFunction": "callbackFunction",
                "context": "callbackContext",
                "currentReportVersionCallback": "reportVersionCallback",
                "currentReportVersionCallbackContext": "reportVersionCallbackContext",
                "currentSystemResetCallback": "systemResetCallback",
                "currentSystemResetCallbackContext": "systemResetCallbackContext"
            },
            "code": "void __thiscall firmata::FirmataParser::setCallbackFunctions_08003350(FirmataParser *this, uint8_t command, systemCallbackFunction newFunction, void *context) {\n  if (command == REPORT_VERSION_COMMAND) {\n    this->currentReportVersionCallback = newFunction;\n    this->currentReportVersionCallbackContext = context;\n    return;\n  }\n  if (command != SYSTEM_RESET_COMMAND) {\n    return;\n  }\n  this->currentSystemResetCallback = newFunction;\n  this->currentSystemResetCallbackContext = context;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003350",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "setCallbackFunctions_08003350"
        },
        "FUN_08007710": {
            "renaming": {
                "FUN_08007710": "disable_timer_clock_08007710",
                "htim": "timer_handle"
            },
            "code": "void disable_timer_clock_08007710(TIM_HandleTypeDef_conflict *timer_handle)\n{\n  timer_disable_clock(timer_handle);\n  return;\n}",
            "called": [
                "timer_disable_clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007710",
            "calling": [
                "HAL_TIM_OC_DeInit"
            ],
            "imported": false,
            "current_name": "disable_timer_clock_08007710"
        },
        "FUN_08003474": {
            "renaming": {
                "FUN_08003474": "parseInputData_08003474",
                "this": "parser",
                "inputData": "inputData",
                "bVar1": "byteData",
                "uVar2": "inputDataAsUint",
                "pos": "pos"
            },
            "code": "void __thiscall firmata::FirmataParser::parseInputData_08003474(FirmataParser *parser, uint8_t inputData) {\n  byte byteData;\n  uint inputDataAsUint = (uint)inputData;\n  size_t pos;\n  if (parser->parsingSysex != false) {\n    if (inputDataAsUint != 0xf7) {\n      bufferDataAtPosition(parser, inputData, parser->sysexBytesRead);\n      parser->sysexBytesRead = parser->sysexBytesRead + 1;\n      return;\n    }\n    parser->parsingSysex = false;\n    processSysexMessage(parser);\n    return;\n  }\n  if ((parser->waitForData == 0) || (0x7f < inputDataAsUint)) {\n    if (inputDataAsUint < 0xf0) {\n      parser->multiByteChannel = inputData & 0xf;\n      inputDataAsUint = inputDataAsUint & 0xf0;\n    }\n    if (inputDataAsUint == 0xf0) {\n      parser->parsingSysex = true;\n      parser->sysexBytesRead = 0;\n      return;\n    }\n    if (inputDataAsUint < 0xf1) {\n      if (inputDataAsUint != 0xc0) {\n        if (inputDataAsUint < 0xc1) {\n          if (inputDataAsUint != 0x90) {\n            return;\n          }\n        }\n        else {\n          if (inputDataAsUint == 0xd0) goto LAB_0800359c;\n          if (inputDataAsUint != 0xe0) {\n            return;\n          }\n        }\nLAB_08003586:\n        parser->waitForData = 2;\n        parser->executeMultiByteCommand = (uint8_t)inputDataAsUint;\n        return;\n      }\nLAB_0800359c:\n      parser->waitForData = 1;\n      parser->executeMultiByteCommand = (uint8_t)inputDataAsUint;\n      return;\n    }\n    if (inputDataAsUint != 0xf9) {\n      if (0xf9 < inputDataAsUint) {\n        if (inputDataAsUint == 0xff) {\n          systemReset(parser);\n          return;\n        }\n        return;\n      }\n      if (1 < inputDataAsUint - 0xf4) {\n        return;\n      }\n      goto LAB_08003586;\n    }\n    if (parser->currentReportVersionCallback != (systemCallbackFunction)0x0) {\n      (*parser->currentReportVersionCallback)(parser->currentReportVersionCallbackContext);\n    }\n  }\n  else {\n    pos = parser->waitForData - 1;\n    parser->waitForData = pos;\n    bufferDataAtPosition(parser, inputData, pos);\n    if ((parser->waitForData == 0) && (byteData = parser->executeMultiByteCommand, byteData != 0)) {\n      if (byteData == 0xd0) {\n        if (parser->currentReportDigitalCallback != (callbackFunction)0x0) {\n          (*parser->currentReportDigitalCallback)(parser->currentReportDigitalCallbackContext, parser->multiByteChannel, (uint16_t)*parser->dataBuffer);\n        }\n      }\n      else if (byteData < 0xd1) {\n        if (byteData == 0x90) {\n          if (parser->currentDigitalCallback != (callbackFunction)0x0) {\n            (*parser->currentDigitalCallback)(parser->currentDigitalCallbackContext, parser->multiByteChannel, (ushort)parser->dataBuffer[1] + (ushort)*parser->dataBuffer * 0x80);\n          }\n        }\n        else if ((byteData == 0xc0) && (parser->currentReportAnalogCallback != (callbackFunction)0x0)) {\n          (*parser->currentReportAnalogCallback)(parser->currentReportAnalogCallbackContext, parser->multiByteChannel, (uint16_t)*parser->dataBuffer);\n        }\n      }\n      else if (byteData == 0xf4) {\n        if (parser->currentPinModeCallback != (callbackFunction)0x0) {\n          (*parser->currentPinModeCallback)(parser->currentPinModeCallbackContext, parser->dataBuffer[1], (uint16_t)*parser->dataBuffer);\n        }\n      }\n      else if (byteData == 0xf5) {\n        if (parser->currentPinValueCallback != (callbackFunction)0x0) {\n          (*parser->currentPinValueCallback)(parser->currentPinValueCallbackContext, parser->dataBuffer[1], (uint16_t)*parser->dataBuffer);\n        }\n      }\n      else if ((byteData == 0xe0) && (parser->currentAnalogCallback != (callbackFunction)0x0)) {\n        (*parser->currentAnalogCallback)(parser->currentAnalogCallbackContext, parser->multiByteChannel, (ushort)parser->dataBuffer[1] + (ushort)*parser->dataBuffer * 0x80);\n      }\n      parser->executeMultiByteCommand = '\\0';\n      return;\n    }\n  }\n  return;\n}",
            "called": [
                "systemReset",
                "bufferDataAtPosition",
                "processSysexMessage"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003474",
            "calling": [
                "processInput"
            ],
            "imported": false,
            "current_name": "parseInputData_08003474"
        },
        "FUN_08008804": {
            "renaming": {
                "FUN_08008804": "allocate_memory_08008804",
                "incr": "increment",
                "pcVar1": "current_pointer",
                "pcVar2": "new_pointer"
            },
            "code": "caddr_t allocate_memory_08008804(int increment)\n{\n  caddr_t current_pointer;\n  caddr_t new_pointer;\n  \n  if (*(int *)PTR_heap_end_08008834 == 0) {\n    *(undefined **)PTR_heap_end_08008834 = PTR__ebss_08008838;\n  }\n  current_pointer = *(caddr_t *)PTR_heap_end_08008834;\n  new_pointer = current_pointer + increment;\n  if (new_pointer <= &stack0x00000000) {\n    *(caddr_t *)PTR_heap_end_08008834 = new_pointer;\n    return current_pointer;\n  }\n  *(undefined4 *)PTR_errno_0800883c = 0xc;\n  return (caddr_t)0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008804",
            "calling": [
                "_sbrk_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_08008804"
        },
        "FUN_08004e3c": {
            "renaming": {
                "FUN_08004e3c": "handle_i2c_transfer_08004e3c",
                "hi2c": "i2c_handle",
                "uVar1": "transfer_options",
                "puVar2": "buffer_pointer"
            },
            "code": "HAL_StatusTypeDef_conflict handle_i2c_transfer_08004e3c(I2C_HandleTypeDef_conflict *hi2c) {\n    uint32_t transfer_options = hi2c->XferOptions;\n    uint8_t *buffer_pointer;\n    if (hi2c->XferCount == 3) {\n        if (((transfer_options == 4) || (transfer_options == 8)) || (transfer_options == 0xffff0000)) {\n            hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n        }\n        buffer_pointer = hi2c->pBuffPtr;\n        hi2c->pBuffPtr = buffer_pointer + 1;\n        *buffer_pointer = (uint8_t)hi2c->Instance->DR;\n        hi2c->XferCount = hi2c->XferCount - 1;\n    }\n    else if (hi2c->XferCount == 2) {\n        if (((transfer_options == 4) || (transfer_options == 8)) || (transfer_options == 0xffff0000)) {\n            hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffcff;\n            hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n        }\n        else {\n            if (transfer_options == 2) {\n                hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x400;\n            }\n            else {\n                hi2c->Instance->CR1 = hi2c->Instance->CR1 & 0xfffffbff;\n            }\n            hi2c->Instance->CR2 = hi2c->Instance->CR2 & 0xfffffcff;\n        }\n        buffer_pointer = hi2c->pBuffPtr;\n        hi2c->pBuffPtr = buffer_pointer + 1;\n        *buffer_pointer = (uint8_t)hi2c->Instance->DR;\n        hi2c->XferCount = hi2c->XferCount - 1;\n        buffer_pointer = hi2c->pBuffPtr;\n        hi2c->pBuffPtr = buffer_pointer + 1;\n        *buffer_pointer = (uint8_t)hi2c->Instance->DR;\n        hi2c->XferCount = hi2c->XferCount - 1;\n        hi2c->State = HAL_I2C_STATE_READY;\n        hi2c->PreviousState = 0;\n        if (hi2c->Mode == HAL_I2C_MODE_MEM) {\n            hi2c->Mode = HAL_I2C_MODE_NONE;\n            HAL_I2C_MemRxCpltCallback(hi2c);\n        }\n        else {\n            hi2c->Mode = HAL_I2C_MODE_NONE;\n            HAL_I2C_MasterRxCpltCallback(hi2c);\n        }\n    }\n    else {\n        buffer_pointer = hi2c->pBuffPtr;\n        hi2c->pBuffPtr = buffer_pointer + 1;\n        *buffer_pointer = (uint8_t)hi2c->Instance->DR;\n        hi2c->XferCount = hi2c->XferCount - 1;\n    }\n    return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004e3c",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_i2c_transfer_08004e3c"
        },
        "FUN_080091a0": {
            "renaming": {
                "FUN_080091a0": "FUNC_080091a0"
            },
            "code": "\nvoid FUNC_080091a0(void *__ptr)\n\n{\n  _FUNC_080091a0_r(*(undefined4 *)PTR__impure_ptr_080091ac,__ptr);\n  return;\n}\n\n",
            "called": [
                "_free_r"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x080091a0",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "FUNC_080091a0"
        },
        "FUN_08002a1c": {
            "renaming": {
                "FUN_08002a1c": "setAddress_08002a1c",
                "this": "wire",
                "address": "newAddress"
            },
            "code": "void __thiscall TwoWire::setAddress_08002a1c(TwoWire *wire, int address)\n{\n  setAddress_08002a1c(wire, (uint8_t)address);\n  return;\n}",
            "called": [
                "begin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a1c",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "setAddress_08002a1c"
        },
        "FUN_08007718": {
            "renaming": {
                "FUN_08007718": "get_stimer_from_htim_08007718",
                "htim": "TIM_HandleTypeDef_conflict *htim",
                "previous_htim": "TIM_HandleTypeDef_conflict *previous_htim",
                "stimer": "stimer_t_conflict *stimer"
            },
            "code": "stimer_t_conflict *get_stimer_from_htim_08007718(TIM_HandleTypeDef_conflict *htim)\n{\n    TIM_HandleTypeDef_conflict *previous_htim = &htim[-1];\n    stimer_t_conflict *stimer = (stimer_t_conflict *)&previous_htim->Lock;\n    return stimer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007718",
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_OC_DelayElapsedCallback"
            ],
            "imported": false,
            "current_name": "get_stimer_from_htim_08007718"
        },
        "FUN_08002a30": {
            "renaming": {
                "TwoWire::FUN_08002a30": "initializeTransmission",
                "this": "wire",
                "address": "address",
                "PTR_transmitting_08002a48": "isTransmitting",
                "PTR_txAddress_08002a4c": "txAddress",
                "PTR_txBufferIndex_08002a50": "txBufferIndex",
                "PTR_txBufferLength_08002a54": "txBufferLength",
                "FUN_08002a30": "initializeTransmission_08002a30"
            },
            "code": "void initializeTransmission_08002a30(TwoWire *wire, uint8_t address) {\n  bool PTR_transmitting_08002a48 = true;\n  uint8_t PTR_txAddress_08002a4c = address << 1;\n  uint8_t PTR_txBufferIndex_08002a50 = 0;\n  uint8_t PTR_txBufferLength_08002a54 = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002a30",
            "calling": [
                "requestFrom",
                "sysexCallback",
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "initializeTransmission_08002a30"
        },
        "FUN_08009cd0": {
            "renaming": {
                "FUN_08009cd0": "walk_reentrant_functions_08009cd0",
                "param_1": "reent_structure",
                "DAT_08009cd8": "reentrant_function_list"
            },
            "code": "void walk_reentrant_functions_08009cd0(void* reent_structure){\n  _fwalk_reent(reent_structure, DAT_08009cd8);\n  return;\n}",
            "called": [
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009cd0",
            "calling": [],
            "imported": false,
            "current_name": "walk_reentrant_functions_08009cd0"
        },
        "FUN_0800322c": {
            "renaming": {
                "FUN_0800322c": "sendFirmwareVersion_0800322c",
                "this": "marshaller",
                "major": "firmwareMajorVersion",
                "minor": "firmwareMinorVersion",
                "FirmataStream": "firmataStream",
                "Stream": "stream",
                "_vptr_Print": "virtualFunctionTable",
                "0xf9": "firmwareVersionCommand"
            },
            "code": "void __thiscall FirmataMarshaller::sendFirmwareVersion_0800322c(FirmataMarshaller *this, uint8_t major, uint8_t minor) {\n    if (this->firmataStream != nullptr) {\n        (**(this->firmataStream->super_Print)._vptr_Print)(this, 0xF9);\n        (**(this->firmataStream->super_Print)._vptr_Print)(this->firmataStream, (uint)major);\n        (**(this->firmataStream->super_Print)._vptr_Print)(this->firmataStream, (uint)minor);\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800322c",
            "calling": [
                "printVersion"
            ],
            "imported": false,
            "current_name": "sendFirmwareVersion_0800322c"
        },
        "FUN_08003760": {
            "renaming": {
                "FUN_08003760": "get_uwTick_value_08003760",
                "PTR_uwTick_08003768": "uwTick_ptr"
            },
            "code": "uint32_t get_uwTick_value_08003760(void)\n{\n  uint32_t* PTR_uwTick_08003768 = (uint32_t*)PTR_uwTick_08003768;\n  return *PTR_uwTick_08003768;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003760",
            "calling": [
                "ADC_ConversionStop_Disable",
                "ADC_Enable",
                "HAL_ADCEx_Calibration_Start",
                "UART_WaitOnFlagUntilTimeout",
                "HAL_RCC_OscConfig",
                "HAL_RCCEx_PeriphCLKConfig",
                "HAL_ADC_PollForConversion",
                "i2c_master_write",
                "uart_debug_write",
                "HAL_RCC_ClockConfig",
                "GetCurrentMilli",
                "i2c_master_read",
                "HAL_UART_Transmit"
            ],
            "imported": false,
            "current_name": "get_uwTick_value_08003760"
        },
        "FUN_08000130": {
            "renaming": {
                "FUN_08000130": "execute_completed_task_if_available_08000130",
                "PTR_completed_8667_08000170": "completed",
                "DAT_08000174": "task",
                "PTR_object_8672_0800016c": "object"
            },
            "code": "void execute_completed_task_if_available_08000130(void)\n{\n  int* PTR_completed_8667_08000170 = (int*) PTR_PTR_completed_8667_08000170_8667_08000170;\n  code* DAT_08000174 = DAT_08000174;\n  if (DAT_08000164 == 0) {\n    return;\n  }\n  if (*PTR_completed_8667_08000170 != 0 && DAT_08000174 != (code*)0x0) {\n    DAT_08000174(PTR_PTR_completed_8667_08000170_8667_08000170, PTR_PTR_object_8672_0800016c_8672_0800016c);\n    return;\n  }\n  if (*PTR_completed_8667_08000170 != 0 && DAT_08000174 != (code*)0x0) {\n    DAT_08000174();\n    return;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000130",
            "calling": [],
            "imported": false,
            "current_name": "execute_completed_task_if_available_08000130"
        },
        "FUN_08002798": {
            "renaming": {
                "FUN_08002798": "resetWireBuffers_08002798",
                "PTR_rxBufferIndex_080027d0": "wire->rxBufferIndex",
                "PTR_rxBufferLength_080027d4": "wire->rxBufferLength",
                "PTR_rxBuffer_080027d8": "wire->rxBuffer",
                "PTR_rxBufferAllocated_080027dc": "wire->rxBufferAllocated",
                "PTR_txBufferIndex_080027e0": "wire->txBufferIndex",
                "PTR_txBufferLength_080027e4": "wire->txBufferLength",
                "PTR_txBuffer_080027e8": "wire->txBuffer",
                "PTR_txBufferAllocated_080027ec": "wire->txBufferAllocated"
            },
            "code": "void __thiscall resetWireBuffers_08002798(TwoWire *wire) {\n  PTR_rxBufferIndex_080027d0 = 0;\n  PTR_rxBufferLength_080027d4 = 0;\n  if (*(void **)PTR_rxBuffer_080027d8 != (void *)0x0) {\n    memset(*(void **)PTR_rxBuffer_080027d8, 0, (uint)(byte)*PTR_rxBufferAllocated_080027dc);\n  }\n  PTR_txBufferIndex_080027e0 = 0;\n  PTR_txBufferLength_080027e4 = 0;\n  if (*(void **)PTR_txBuffer_080027e8 != (void *)0x0) {\n    memset(*(void **)PTR_txBuffer_080027e8, 0, (uint)(byte)*PTR_txBufferAllocated_080027ec);\n  }\n  return;\n}",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002798",
            "calling": [],
            "imported": false,
            "current_name": "resetWireBuffers_08002798"
        },
        "FUN_08009190": {
            "renaming": {
                "FUN_08009190": "allocate_memory_08009190",
                "__size": "size",
                "pvVar1": "allocated_memory",
                "_FUN_08009190_r": "recursive_allocate"
            },
            "code": "void * allocate_memory_08009190(size_t size)\n{\n  void *allocated_memory;\n  allocated_memory = (void *)recursive_allocate(*(undefined4 *)PTR__impure_ptr_0800919c, size);\n  return allocated_memory;\n}",
            "called": [
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009190",
            "calling": [
                "setFirmwareNameAndVersion"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009190"
        },
        "FUN_0800242c": {
            "renaming": {
                "FUN_0800242c": "initialize_timer_0800242c",
                "obj": "timer_object",
                "60000": "timer_duration",
                "0x5dc": "timer_pulse",
                "DAT_08002440": "timer_callback",
                "(stimer_t_conflict *)obj": "(stimer_t_conflict *)timer_object"
            },
            "code": "void initialize_timer_0800242c(stimer_t *timer_object)\n{\n  int timer_duration = 60000;\n  int timer_pulse = 0x5dc;\n  void *DAT_08002440 = DAT_08002440;\n  TimerPulseInit((stimer_t_conflict *)timer_object, timer_duration, timer_pulse, DAT_08002440);\n}",
            "called": [
                "TimerPulseInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800242c",
            "calling": [
                "attach"
            ],
            "imported": false,
            "current_name": "initialize_timer_0800242c"
        },
        "FUN_08002e44": {
            "renaming": {
                "FUN_08002e44": "parseFirmwareVersion_08002e44",
                "name": "firmwareName",
                "major": "majorVersion",
                "minor": "minorVersion",
                "bVar1": "count",
                "pcVar2": "versionStringStart",
                "pcVar3": "versionStringEnd",
                "pbVar4": "versionString",
                "sVar5": "versionStringLength",
                "PTR_s__cpp_08002ec0": "firmwareNamePrefix",
                "DAT_08002f24": "firmwareVersionVector"
            },
            "code": "void __thiscall firmata::FirmataClass::parseFirmwareVersion_08002e44(char *firmwareName, byte majorVersion, byte minorVersion) {\n  byte count;\n  char *versionStringStart;\n  char *versionStringEnd;\n  byte *versionString;\n  size_t versionStringLength;\n  \n  versionStringStart = strstr(firmwareName, PTR_s__cpp_08002ec0);\n  versionStringEnd = strrchr(firmwareName, '/');\n  if (versionStringEnd == 0) {\n    versionStringEnd = strrchr(firmwareName, '\\');\n  }\n  if (versionStringEnd != 0) {\n    firmwareName = versionStringEnd + 1;\n  }\n  if (versionStringStart == 0) {\n    versionStringLength = strlen(firmwareName);\n    count = (byte)versionStringLength + 2;\n  }\n  else {\n    count = ((byte)versionStringStart - (byte)firmwareName) + 2;\n  }\n  free(DAT_08002f24);\n  versionString = (byte *)malloc(count + 1);\n  DAT_08002f24 = versionString;\n  versionString[count] = 0;\n  *versionString = majorVersion;\n  versionString[1] = minorVersion;\n  strncpy((char *)(versionString + 2), firmwareName, count - 2);\n  return;\n}",
            "called": [
                "free",
                "strncpy",
                "strstr",
                "strrchr",
                "malloc",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002e44",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "parseFirmwareVersion_08002e44"
        },
        "FUN_0800a0a8": {
            "renaming": {
                "FUN_0800a0a8": "write_to_file_0800a0a8",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "puVar1": "errno_pointer",
                "iVar2": "bytes_written"
            },
            "code": "void write_to_file_0800a0a8(int* error_code, int file_descriptor, char* buffer, int buffer_size) {\n  undefined* errno_pointer = PTR_errno_0800a0c8;\n  *(undefined4*)PTR_errno_0800a0c8 = 0;\n  int bytes_written = _write(file_descriptor, buffer, buffer_size);\n  if ((bytes_written == -1) && (*(int*)errno_pointer != 0)) {\n    *error_code = *(int*)errno_pointer;\n  }\n  return;\n}",
            "called": [
                "_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a0a8",
            "calling": [
                "__swrite"
            ],
            "imported": false,
            "current_name": "write_to_file_0800a0a8"
        },
        "FUN_08002c00": {
            "renaming": {
                "FUN_08002c00": "sendMultipleBytes_08002c00",
                "this": "wire",
                "address": "address",
                "quantity": "quantity",
                "sendStop": "sendStop",
                "uVar1": "result"
            },
            "code": "uint8_t __thiscall sendMultipleBytes_08002c00(TwoWire *wire, uint8_t address, uint8_t quantity, uint8_t sendStop) {\\\n                        uint8_t result;\\\n                        result = sendMultipleBytes_08002c00(wire, address, quantity, 0, \"\\0\", sendStop);\\\n                        return result;\\\n                    }",
            "called": [
                "requestFrom"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c00",
            "calling": [
                "requestFrom"
            ],
            "imported": false,
            "current_name": "sendMultipleBytes_08002c00"
        },
        "FUN_08003f30": {
            "renaming": {
                "FUN_08003f30": "set_interrupt_priority_08003f30",
                "IRQn_Type_conflict": "IRQn",
                "PreemptPriority": "preempt_priority",
                "SubPriority": "sub_priority",
                "uVar1": "IRQn_val",
                "uVar2": "priority_bits",
                "uVar3": "preempt_shift",
                "DAT_08003f8c": "priority_val_1",
                "DAT_08003f90": "priority_val_2"
            },
            "code": "void set_interrupt_priority_08003f30(IRQn_Type_conflict IRQn, uint32_t preempt_priority, uint32_t sub_priority)\n{\n    uint8_t priority_bits = (*(int *)(DAT_08003f8c + 0xc) << 0x15) >> 0x1d;\n    uint8_t preempt_shift = 7 - priority_bits;\n    if (preempt_shift > 3) {\n        preempt_shift = 4;\n    }\n    uint8_t sub_shift = (priority_bits + 4 < 7) ? 0 : preempt_shift - 3;\n    uint32_t preempt_mask = (1 << (preempt_shift & 0xff)) - 1U;\n    uint32_t preempt_bits = (preempt_priority & preempt_mask) << (sub_shift & 0xff);\n    uint32_t sub_mask = (1 << (sub_shift & 0xff)) - 1U;\n    uint32_t sub_bits = sub_priority & sub_mask;\n    uint32_t priority = preempt_bits | sub_bits;\n    if ((int)IRQn < 0) {\n        *(char *)(DAT_08003f90 + (IRQn & 0xf)) = (char)(priority << 4);\n    }\n    else {\n        *(char *)(IRQn + 0xe000e400) = (char)(priority << 4);\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f30",
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback",
                "HAL_InitTick",
                "TimerPulseInit",
                "SystemClock_Config",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_08003f30"
        },
        "FUN_080073d8": {
            "renaming": {
                "FUN_080073d8": "handle_rtc_alarm_interrupt_080073d8",
                "PTR_RtcHandle_080073e4": "rtc_handle"
            },
            "code": "void handle_rtc_alarm_interrupt_080073d8(void)\n{\n  RTC_HandleTypeDef *PTR_RtcHandle_080073e4 = (RTC_HandleTypeDef *)PTR_RtcHandle_080073e4;\n  HAL_RTC_AlarmIRQHandler(PTR_RtcHandle_080073e4);\n  return;\n}",
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073d8",
            "calling": [],
            "imported": false,
            "current_name": "handle_rtc_alarm_interrupt_080073d8"
        },
        "FUN_080085dc": {
            "renaming": {
                "FUN_080085dc": "is_uart_transmit_complete_080085dc",
                "obj": "serial",
                "HVar1": "uart_state"
            },
            "code": "bool is_uart_transmit_complete_080085dc(serial_t *serial)\n{\n    HAL_UART_StateTypeDef uart_state = HAL_UART_GetState(*((UART_HandleTypeDef **)(PTR_uart_handlers_080085fc + (uint)serial->index * 4)));\n    return (uart_state & 0x21U) == 0x21;\n}",
            "called": [
                "HAL_UART_GetState"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080085dc",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "is_uart_transmit_complete_080085dc"
        },
        "FUN_08008ed6": {
            "renaming": {
                "__thiscall Print::FUN_08008ed6": "printNumber",
                "this": "self",
                "n": "number",
                "base": "base",
                "sVar1": "size",
                "FUN_08008ed6": "printNumber_08008ed6"
            },
            "code": "size_t Print::printNumber_08008ed6(Print *this, ulong number, int base) {\n  size_t size;\n  if (base != 0) {\n    size = printNumber_08008ed6(this, number, (uint8_t)base);\n  } else {\n    size = (**this->_vptr_Print)(this, number & 0xff);\n  }\n  return size;\n}",
            "called": [
                "printNumber"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ed6",
            "calling": [
                "print"
            ],
            "imported": false,
            "current_name": "printNumber_08008ed6"
        },
        "FUN_08008db0": {
            "renaming": {
                "FUN_08008db0": "initialize_static_data_08008db0"
            },
            "code": "void initialize_static_data_08008db0(void)\n{\n  __static_initialization_and_destruction_0(1, 0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008db0",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_data_08008db0"
        },
        "FUN_08002444": {
            "renaming": {
                "FUN_08002444": "servoHandler_08002444",
                "obj": "servoTimer",
                "channel": "channel",
                "bVar1": "isServoActive",
                "puVar2": "timerChannelPtr",
                "uVar3": "timerCounter",
                "iVar4": "servoOffset",
                "uVar5": "servoIndex"
            },
            "code": "void servoHandler_08002444(stimer_t *servoTimer, uint32_t channel) {\n  bool isServoActive;\n  undefined *timerChannelPtr;\n  uint32_t servoIndex = (uint)servoTimer->idx;\n  timerChannelPtr = PTR_timerChannel_0800256c;\n  if ((timerChannelPtr[servoIndex] & 0x80) == 0) {\n    int servoOffset = servoIndex * 0xc;\n    int servoCount = (int)(uint)(byte)*PTR_ServoCount_08002570;\n    int currentServo = (char)timerChannelPtr[servoIndex] + servoOffset;\n    if (currentServo < servoCount) {\n      if ((PTR_servos_08002574[currentServo * 8] & 0x40) == 0) {\n        isServoActive = false;\n      }\n      else {\n        isServoActive = true;\n      }\n    }\n    else {\n      isServoActive = false;\n    }\n    if (isServoActive) {\n      int servoPin = (byte)PTR_servos_08002574[currentServo * 8] & 0x3f;\n      digitalWrite(servoPin, 0);\n    }\n  }\n  else {\n    setTimerCounter((stimer_t_conflict *)servoTimer, 0);\n  }\n  timerChannelPtr[servoIndex]++;\n  int servoOffset = servoIndex * 0xc;\n  int currentServo = (char)timerChannelPtr[servoIndex] + servoOffset;\n  int servoCount = (int)(uint)(byte)*PTR_ServoCount_08002570;\n  if (currentServo < servoCount) {\n    if ((char)timerChannelPtr[servoIndex] < '\f') {\n      isServoActive = true;\n    }\n    else {\n      isServoActive = false;\n    }\n  }\n  else {\n    isServoActive = false;\n  }\n  if (isServoActive) {\n    int servoPin = (byte)PTR_servos_08002574[currentServo * 8] & 0x3f;\n    if ((PTR_servos_08002574[currentServo * 8] & 0x40) != 0) {\n      digitalWrite(servoPin, 1);\n    }\n    uint32_t timerCounter = getTimerCounter((stimer_t_conflict *)servoTimer);\n    int servoOffset = servoIndex * 0xc;\n    int servoDelay = *(int *)(PTR_servos_08002574 + (currentServo * 8) + 4) + timerCounter;\n    setCCRRegister((stimer_t_conflict *)servoTimer, channel, servoDelay);\n    return;\n  }\n  uint32_t timerCounter = getTimerCounter((stimer_t_conflict *)servoTimer);\n  if (timerCounter + 4 < 20000) {\n    setCCRRegister((stimer_t_conflict *)servoTimer, channel, 20000);\n  }\n  else {\n    timerCounter = getTimerCounter((stimer_t_conflict *)servoTimer);\n    setCCRRegister((stimer_t_conflict *)servoTimer, channel, timerCounter + 4);\n  }\n  timerChannelPtr[servoIndex] = 0xff;\n}",
            "called": [
                "digitalWrite",
                "getTimerCounter",
                "setCCRRegister",
                "setTimerCounter"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002444",
            "calling": [],
            "imported": false,
            "current_name": "servoHandler_08002444"
        },
        "FUN_0800906c": {
            "renaming": {
                "FUN_0800906c": "handle_GPIO_EXTI_IRQs_0800906c",
                "uVar1": "pin_number"
            },
            "code": "void handle_GPIO_EXTI_IRQs_0800906c(void)\n{\n  uint16_t pin_number;\n  for (pin_number = 0x400; pin_number < 0x8001; pin_number = pin_number << 1) {\n    HAL_GPIO_EXTI_IRQHandler(pin_number);\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800906c",
            "calling": [],
            "imported": false,
            "current_name": "handle_GPIO_EXTI_IRQs_0800906c"
        },
        "FUN_08003658": {
            "renaming": {
                "FUN_08003658": "initialize_system_08003658",
                "iVar1": "i",
                "puVar2": "completed_ptr",
                "UNRECOVERED_JUMPTABLE": "jumptable_ptr"
            },
            "code": "void initialize_system_08003658(void)\n{\n  int i;\n  undefined4 *completed_ptr = (undefined4 *)PTR_completed_8667_08003698;\n  undefined4 *dso_handle_ptr = (undefined4 *)PTR___dso_handle_08003690;\n  code *jumptable_ptr;\n  for (i = 0; dso_handle_ptr + i < (undefined4 *)PTR_completed_8667_08003694; i += 4)\n  {\n    *(undefined4 *)(dso_handle_ptr + i) = *(undefined4 *)(PTR__sidata_0800368c + i);\n  }\n  for (; completed_ptr < (undefined4 *)PTR__ebss_0800369c; completed_ptr++)\n  {\n    *completed_ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumptable_ptr = (code *)0x800368a;\n  main();\n  (*jumptable_ptr)();\n  return;\n}",
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003658",
            "calling": [],
            "imported": false,
            "current_name": "initialize_system_08003658"
        },
        "FUN_08009a80": {
            "renaming": {
                "FUN_08009a80": "read_input_08009a80",
                "param_1": "error_code",
                "param_2": "input_stream",
                "uVar1": "stream_status",
                "uVar2": "stream_flags",
                "iVar3": "impure_ptr"
            },
            "code": "uint read_input_08009a80(uint* error_code, uint* input_stream) {\n  uint stream_status;\n  ushort stream_flags;\n  int impure_ptr = *(int*)PTR__impure_ptr_08009b4c;\n  if (impure_ptr != 0 && *(int*)(impure_ptr + 0x18) == 0) {\n    __sinit(impure_ptr);\n  }\n  if (input_stream == (uint*)PTR___sf_fake_stdin_08009b50) {\n    input_stream = *(uint**)(impure_ptr + 4);\n  }\n  else if (input_stream == (uint*)PTR___sf_fake_stdout_08009b54) {\n    input_stream = *(uint**)(impure_ptr + 8);\n  }\n  else if (input_stream == (uint*)PTR___sf_fake_stderr_08009b58) {\n    input_stream = *(uint**)(impure_ptr + 0xc);\n  }\n  stream_flags = *(ushort*)(input_stream + 3);\n  stream_status = (uint)stream_flags;\n  if (-1 < (int)(stream_status << 0x1c)) {\n    if (-1 < (int)(stream_status << 0x1b)) {\n      *error_code = 9;\n      goto LAB_08009ab0;\n    }\n    if ((int)(stream_status << 0x1d) < 0) {\n      if ((uint*)input_stream[0xd] != (uint*)0x0) {\n        if ((uint*)input_stream[0xd] != input_stream + 0x11) {\n          _free_r(error_code);\n        }\n        input_stream[0xd] = 0;\n      }\n      *(ushort*)(input_stream + 3) = *(ushort*)(input_stream + 3) & 0xffdb;\n      input_stream[1] = 0;\n      *input_stream = input_stream[4];\n    }\n    *(ushort*)(input_stream + 3) = *(ushort*)(input_stream + 3) | 8;\n  }\n  if (input_stream[4] == 0 && (*(ushort*)(input_stream + 3) & 0x280) != 0x200) {\n    __smakebuf_r(error_code, input_stream);\n  }\n  stream_flags = *(ushort*)(input_stream + 3);\n  stream_status = stream_flags & 1;\n  if ((stream_flags & 1) == 0) {\n    if (-1 < (int)((uint)stream_flags << 0x1e)) {\n      stream_status = input_stream[5];\n    }\n    input_stream[2] = stream_status;\n  }\n  else {\n    input_stream[2] = 0;\n    input_stream[6] = -input_stream[5];\n  }\n  if (input_stream[4] == 0) {\n    stream_flags = *(ushort*)(input_stream + 3);\n    stream_status = (int)(short)stream_flags & 0x80;\n    if (stream_status != 0) {\n      *(ushort*)(input_stream + 3) = stream_flags | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    stream_status = 0;\n  }\n  return stream_status;\n}",
            "called": [
                "_free_r",
                "__smakebuf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009a80",
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "read_input_08009a80"
        },
        "FUN_080062f4": {
            "renaming": {
                "FUN_080062f4": "disable_timer_interrupts_080062f4",
                "htim": "timer_handle",
                "Channel": "channel",
                "TIM_TypeDef_conflict": "timer_instance",
                "pTVar1": "timer_instance",
                "DAT_0800638c": "DAT_0800638c",
                "Instance": "Instance",
                "DIER": "DIER",
                "TIM_CCxChannelCmd": "TIM_CCxChannelCmd",
                "CCER": "CCER",
                "BDTR": "BDTR",
                "CR1": "CR1",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef_conflict",
                "uint32_t": "uint32_t",
                "TIM_HandleTypeDef_conflict": "TIM_HandleTypeDef_conflict",
                "*htim": "*timer_handle"
            },
            "code": "HAL_StatusTypeDef_conflict disable_timer_interrupts_080062f4(TIM_HandleTypeDef_conflict *timer_handle, uint32_t channel) {\n  TIM_TypeDef_conflict *timer_instance = timer_handle->Instance;\n  switch(channel) {\n    case 0:\n      timer_instance->DIER &= 0xfffffffd;\n      break;\n    case 4:\n      timer_instance->DIER &= 0xfffffffb;\n      break;\n    case 8:\n      timer_instance->DIER &= 0xfffffff7;\n      break;\n    case 0xc:\n      timer_instance->DIER &= 0xffffffef;\n      break;\n  }\n  TIM_CCxChannelCmd(timer_instance, channel, 0);\n  if (((timer_instance == DAT_0800638c) && ((timer_instance->CCER & 0x1111) == 0)) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->BDTR &= 0xffff7fff;\n  }\n  if (((timer_instance->CCER & 0x1111) == 0) && ((timer_instance->CCER & 0x444) == 0)) {\n    timer_instance->CR1 &= 0xfffffffe;\n  }\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080062f4",
            "calling": [
                "TimerPulseDeinit"
            ],
            "imported": false,
            "current_name": "disable_timer_interrupts_080062f4"
        },
        "FUN_080073e8": {
            "renaming": {
                "FUN_080073e8": "infiniteLoop_080073e8",
                "msg": "message",
                "val": "value"
            },
            "code": "void infiniteLoop_080073e8(char *message, int value) {\n    while(true) {\n        // do nothing\n    }\n}",
            "called": [
                "_Error_Handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073e8",
            "calling": [
                "_Error_Handler",
                "SystemClock_Config",
                "onReceiveService"
            ],
            "imported": false,
            "current_name": "infiniteLoop_080073e8"
        },
        "FUN_0800267c": {
            "renaming": {
                "FUN_0800267c": "setServoPosition_0800267c",
                "value": "position",
                "iVar1": "minPosition",
                "iVar2": "maxPosition"
            },
            "code": "void __thiscall Servo::setServoPosition_0800267c(Servo *this, int position)\n{\n  int minPosition = (0x88 - this->min) * 4;\n  int maxPosition = (600 - this->max) * 4;\n\n  if (this->servoIndex < 0xc && (maxPosition - position == 0 || maxPosition < position) && (position == minPosition || position + maxPosition * -1 < 0 != SBORROW4(position, minPosition))) {\n    position = position;\n  }\n\n  *(int *)(PTR_servos_080026ac + (uint)this->servoIndex * 8 + 4) = position;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800267c",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "setServoPosition_0800267c"
        },
        "FUN_0800376c": {
            "renaming": {
                "FUN_0800376c": "perform_adc_conversion_0800376c",
                "*hadc": "*adc_handle",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "start_time",
                "pAVar5": "adc_instance",
                "uVar6": "system_core_clock",
                "uVar3": "periph_clk_freq",
                "Conversion_Timeout_CPU_cycles": "conversion_timeout_cpu_cycles",
                "sample_time": "sample_time",
                "iVar4": "sample_time",
                "PTR_SystemCoreClock_080038c8": "PTR_SystemCoreClock_080038c8",
                "DAT_080038cc": "DAT_080038cc",
                "DAT_080038d0": "DAT_080038d0",
                "DAT_080038d4": "DAT_080038d4",
                "DAT_080038d8": "DAT_080038d8",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef_conflict",
                "uint32_t": "uint32_t",
                "ADC_HandleTypeDef": "ADC_HandleTypeDef",
                "ADC_TypeDef": "ADC_TypeDef",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_OK": "HAL_OK",
                "HAL_TIMEOUT": "HAL_TIMEOUT",
                "HAL_ERROR": "HAL_ERROR"
            },
            "code": "HAL_StatusTypeDef_conflict perform_adc_conversion_0800376c(ADC_HandleTypeDef *adc_handle, uint32_t timeout)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t start_time = HAL_GetTick();\n  ADC_TypeDef *adc_instance = adc_handle->Instance;\n  uint32_t conversion_timeout_cpu_cycles = 0;\n  \n  if ((adc_instance->CR2 & 0x100) == 0) {\n    if (((adc_instance->CR1 & 0x100) == 0) && ((adc_instance->SQR1 & 0xf00000) == 0)) {\n      do {\n        if ((adc_handle->Instance->SR & 2) != 0) goto conversion_complete;\n      } while ((timeout == 0xffffffff) || ((timeout != 0 && (HAL_GetTick() - start_time <= timeout))));\n      adc_handle->State |= 4;\n      adc_handle->Lock = HAL_UNLOCKED;\n      status = HAL_TIMEOUT;\n    }\n    else {\n      uint32_t system_core_clock = *(uint *)PTR_SystemCoreClock_080038c8;\n      uint32_t periph_clk_freq = HAL_RCCEx_GetPeriphCLKFreq(2);\n      adc_instance = adc_handle->Instance;\n      uint32_t sample_time;\n      if (((adc_instance->SMPR2 & DAT_080038cc) == 0) && ((adc_instance->SMPR1 & DAT_080038cc + 0xdc000000) == 0)) {\n        if ((adc_instance->SMPR2 & DAT_080038d0) == 0) {\n          if ((adc_instance->SMPR1 & DAT_080038d4) == 0) {\n            sample_time = 0x14;\n          }\n          else {\n            sample_time = 0x29;\n          }\n        }\n        else {\n          sample_time = 0x29;\n        }\n      }\n      else if (((adc_instance->SMPR2 & DAT_080038d0) == 0) && ((adc_instance->SMPR1 & DAT_080038d0 + 0xee000000) == 0)) {\n        sample_time = 0x54;\n      }\n      else if ((DAT_080038d8 & adc_instance->SMPR2) == 0) {\n        if ((DAT_080038d8 & adc_instance->SMPR1) == 0) {\n          sample_time = 0x54;\n        }\n        else {\n          sample_time = 0xfc;\n        }\n      }\n      else {\n        sample_time = 0xfc;\n      }\n      uint32_t cpu_cycles_per_conversion = (system_core_clock / periph_clk_freq) * sample_time;\n      for (; conversion_timeout_cpu_cycles <= cpu_cycles_per_conversion && cpu_cycles_per_conversion - conversion_timeout_cpu_cycles != 0; conversion_timeout_cpu_cycles = conversion_timeout_cpu_cycles + 1) {\n        if ((timeout != 0xffffffff) && ((timeout == 0 || (HAL_GetTick() - start_time > timeout)))) {\n          adc_handle->State |= 4;\n          adc_handle->Lock = HAL_UNLOCKED;\n          return HAL_TIMEOUT;\n        }\n      }\nconversion_complete:\n      adc_handle->Instance->SR = 0xffffffed;\n      adc_handle->State |= 0x200;\n      if ((adc_handle->Instance->CR2 & 0xe0000) == 0xe0000) {\n        if ((adc_handle->Init).ContinuousConvMode == 0) {\n          adc_handle->State &= 0xfffffeff;\n          if ((adc_handle->State & 0x1000) == 0) {\n            adc_handle->State |= 1;\n            status = HAL_OK;\n          }\n          else {\n            status = HAL_OK;\n          }\n        }\n        else {\n          status = HAL_OK;\n        }\n      }\n      else {\n        status = HAL_OK;\n      }\n    }\n  }\n  else {\n    adc_handle->State |= 0x20;\n    adc_handle->Lock = HAL_UNLOCKED;\n    status = HAL_ERROR;\n  }\n  return status;\n}",
            "called": [
                "HAL_GetTick",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800376c",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "perform_adc_conversion_0800376c"
        },
        "FUN_08003e20": {
            "renaming": {
                "FUN_08003e20": "stop_and_disable_adc_conversion_08003e20",
                "hadc": "adc_handle",
                "HVar1": "status",
                "uVar2": "clock_frequency",
                "uVar3": "current_tick",
                "pAVar4": "adc_instance",
                "uVar5": "system_core_clock",
                "wait_loop_index": "wait_loop_index",
                "PTR_SystemCoreClock_08003f08": "SystemCoreClock",
                "Lock": "Lock",
                "HAL_LOCKED": "HAL_LOCKED",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_BUSY": "HAL_BUSY",
                "HAL_OK": "HAL_OK",
                "State": "State",
                "ADC_ConversionStop_Disable": "ADC_ConversionStop_Disable",
                "ADC_Enable": "ADC_Enable",
                "CR2": "CR2",
                "HAL_RCCEx_GetPeriphCLKFreq": "HAL_RCCEx_GetPeriphCLKFreq",
                "HAL_GetTick": "HAL_GetTick"
            },
            "code": "HAL_StatusTypeDef_conflict stop_and_disable_adc_conversion_08003e20(ADC_HandleTypeDef *hadc)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t wait_loop_index;\n  ADC_TypeDef *adc_instance;\n  uint32_t start_tick, current_tick;\n  \n  if (hadc->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  hadc->Lock = HAL_LOCKED;\n  status = ADC_ConversionStop_Disable(hadc);\n  if (status == HAL_OK) {\n    hadc->State &= 0xffffeefd | 2;\n    uint32_t clock_frequency = HAL_RCCEx_GetPeriphCLKFreq(2);\n    uint32_t wait_time = (PTR_SystemCoreClock_08003f08 / clock_frequency) << 1;\n    for (wait_loop_index = wait_time; wait_loop_index != 0; wait_loop_index = wait_loop_index - 1) {\n    }\n    ADC_Enable(hadc);\n    hadc->Instance->CR2 |= 8;\n    start_tick = HAL_GetTick();\n    while (adc_instance = hadc->Instance, (adc_instance->CR2 & 8) != 0) {\n      current_tick = HAL_GetTick();\n      if (10 < current_tick - start_tick) {\n        hadc->State &= 0xffffffed | 0x10;\n        hadc->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    adc_instance->CR2 |= 4;\n    start_tick = HAL_GetTick();\n    while ((hadc->Instance->CR2 & 4) != 0) {\n      current_tick = HAL_GetTick();\n      if (10 < current_tick - start_tick) {\n        hadc->State &= 0xffffffed | 0x10;\n        hadc->Lock = HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    hadc->State &= 0xfffffffc | 1;\n  }\n  hadc->Lock = HAL_UNLOCKED;\n  return status;\n}",
            "called": [
                "HAL_GetTick",
                "ADC_ConversionStop_Disable",
                "ADC_Enable",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003e20",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "stop_and_disable_adc_conversion_08003e20"
        },
        "FUN_08002c14": {
            "renaming": {
                "FUN_08002c14": "readFromAddressWithQuantityAndMode_08002c14",
                "this": "wire",
                "address": "address",
                "quantity": "quantity",
                "uVar1": "result"
            },
            "code": "uint8_t __thiscall TwoWire::readFromAddressWithQuantityAndMode_08002c14(TwoWire *wire,uint8_t address,uint8_t quantity)\n{\n  uint8_t result;\n  result = readFromAddressWithQuantityAndMode_08002c14AndMode(wire,address,quantity,'\\x01');\n  return result;\n}",
            "called": [
                "requestFrom"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c14",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "readFromAddressWithQuantityAndMode_08002c14"
        },
        "FUN_08009084": {
            "renaming": {
                "__thiscall std::function<void>::operator__": "invoke_function",
                "this": "function",
                "super__Function_base": "base",
                "_M_manager": "_manager",
                "_M_invoker": "invoker",
                "_Any_data": "any_data",
                "__throw_bad_function_call": "throw_bad_function_call",
                "FUN_08009084": "invoke_function_08009084"
            },
            "code": "void invoke_function_08009084(function_void___ *function) {\n  if ((function->base)._M_manager != (_Manager_type)0x0) {\n    (*function->invoker)((_Any_data *)function);\n    return;\n  }\n  __throw_bad_function_call();\n}",
            "called": [
                "__throw_bad_function_call"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009084",
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "imported": false,
            "current_name": "invoke_function_08009084"
        },
        "FUN_08005840": {
            "renaming": {
                "FUN_08005840": "calculate_result_08005840",
                "uVar1": "result",
                "uVar2": "bitmask",
                "local_1c": "constant4",
                "abStack_18": "stack_values",
                "uStack_14": "constant1",
                "uStack_10": "constant2",
                "uStack_c": "constant3"
            },
            "code": "uint calculate_result_08005840(void)\n{\n  uint result;\n  uint bitmask;\n  byte stack_values[4];\n  undefined4 constant3 = *(undefined4 *)(PTR__etext_0800589c + 8);\n  undefined4 constant2 = *(undefined4 *)(PTR__etext_0800589c + 4);\n  undefined4 constant1 = *(undefined4 *)PTR__etext_0800589c;\n  undefined2 constant4 = *(undefined2 *)(PTR__etext_0800589c + 0x10);\n  bitmask = *(uint *)(DAT_080058a0 + 4);\n  result = DAT_080058a8;\n  if ((bitmask & 0xc) == 8) {\n    if ((bitmask & 0x10000) == 0) {\n      result = DAT_080058a4 * (uint)stack_values[(bitmask << 10) >> 0x1c];\n    }\n    else {\n      result = (DAT_080058a8 * stack_values[(bitmask << 10) >> 0x1c]) / (uint)*(byte *)((int)&constant4 - ((*(int *)(DAT_080058a0 + 4) << 0xe) >> 0x1f));\n    }\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005840",
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "imported": false,
            "current_name": "calculate_result_08005840"
        },
        "FUN_08003306": {
            "renaming": {
                "FUN_08003306": "parseCommand_08003306",
                "this": "parser",
                "command": "command",
                "newFunction": "newFunction",
                "context": "context",
                "currentReportDigitalCallback": "parser->currentReportDigitalCallback",
                "currentReportDigitalCallbackContext": "parser->currentReportDigitalCallbackContext",
                "currentPinModeCallback": "parser->currentPinModeCallback",
                "currentPinModeCallbackContext": "parser->currentPinModeCallbackContext",
                "currentPinValueCallback": "parser->currentPinValueCallback",
                "currentPinValueCallbackContext": "parser->currentPinValueCallbackContext",
                "currentAnalogCallback": "parser->currentAnalogCallback",
                "currentAnalogCallbackContext": "parser->currentAnalogCallbackContext",
                "currentDigitalCallback": "parser->currentDigitalCallback",
                "currentDigitalCallbackContext": "parser->currentDigitalCallbackContext",
                "currentReportAnalogCallback": "parser->currentReportAnalogCallback",
                "currentReportAnalogCallbackContext": "parser->currentReportAnalogCallbackContext",
                "0xd0": "DIGITAL_REPORT",
                "0xf4": "PIN_MODE_RESPONSE",
                "0xf5": "PIN_STATE_RESPONSE",
                "0xe0": "ANALOG_REPORT",
                "0x90": "DIGITAL_MESSAGE",
                "0xc0": "ANALOG_MESSAGE"
            },
            "code": "void __thiscall firmata::FirmataParser::parseCommand_08003306(FirmataParser *parser, uint8_t command, callbackFunction newFunction, void *context) {\n  if (command == DIGITAL_REPORT) {\n    parser->currentReportDigitalCallback = newFunction;\n    parser->currentReportDigitalCallbackContext = context;\n    return;\n  }\n  if (command > DIGITAL_REPORT) {\n    if (command == PIN_MODE_RESPONSE) {\n      parser->currentPinModeCallback = newFunction;\n      parser->currentPinModeCallbackContext = context;\n      return;\n    }\n    if (command == PIN_STATE_RESPONSE) {\n      parser->currentPinValueCallback = newFunction;\n      parser->currentPinValueCallbackContext = context;\n      return;\n    }\n    if (command == ANALOG_REPORT) {\n      parser->currentAnalogCallback = newFunction;\n      parser->currentAnalogCallbackContext = context;\n      return;\n    }\n    return;\n  }\n  if (command == DIGITAL_MESSAGE) {\n    parser->currentDigitalCallback = newFunction;\n    parser->currentDigitalCallbackContext = context;\n    return;\n  }\n  if (command == ANALOG_MESSAGE) {\n    parser->currentReportAnalogCallback = newFunction;\n    parser->currentReportAnalogCallbackContext = context;\n    return;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003306",
            "calling": [
                "FirmataClass"
            ],
            "imported": false,
            "current_name": "parseCommand_08003306"
        },
        "FUN_08002578": {
            "renaming": {
                "FUN_08002578": "DeinitializeTimer_08002578",
                "obj": "timer_object"
            },
            "code": "void DeinitializeTimer_08002578(stimer_t *timer_object)\n{\n  TimerPulseDeinit((stimer_t_conflict *)timer_object);\n  return;\n}",
            "called": [
                "TimerPulseDeinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002578",
            "calling": [
                "detach"
            ],
            "imported": false,
            "current_name": "DeinitializeTimer_08002578"
        },
        "FUN_08006932": {
            "renaming": {
                "FUN_08006932": "set_uart_to_ready_state_08006932",
                "*huart": "*uart_handle",
                "Instance": "instance",
                "CR1": "control_register_1",
                "gState": "general_state",
                "HAL_UART_TxCpltCallback": "UART_transmission_complete_callback",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef"
            },
            "code": "HAL_StatusTypeDef set_uart_to_ready_state_08006932(UART_HandleTypeDef *uart_handle) {\n  uart_handle->Instance->CR1 &= ~(1 << 6);\n  uart_handle->gState = HAL_UART_STATE_READY;\n  HAL_UART_TxCpltCallback(uart_handle);\n  return HAL_OK;\n}",
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006932",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "set_uart_to_ready_state_08006932"
        },
        "FUN_080060c4": {
            "renaming": {
                "FUN_080060c4": "initialize_TIM_080060c4",
                "TIMx": "timer",
                "OC_Config": "config",
                "uVar1": "CCER_value",
                "uVar2": "CR2_value",
                "uVar3": "OCMode_value",
                "PTR_TIM1": "timer_1",
                "DAT_08006124": "timer_2"
            },
            "code": "void initialize_TIM_080060c4(TIM_TypeDef_conflict *timer,TIM_OC_InitTypeDef *config)\n{\n  uint32_t CCER_mask = 0xffffffef;\n  uint32_t CR2_value = timer->CR2;\n  uint32_t OCMode_value = config->OCMode;\n  uint32_t CCER_value = (timer->CCER & 0xffffffdf) | (config->OCPolarity << 4);\n  if (timer == PTR_TIM1)\n  {\n    CCER_value = (CCER_value & 0xffffff7f) | (config->OCNPolarity << 4);\n    CR2_value = (CR2_value & 0xfffff3ff) | (config->OCIdleState << 2) | (config->OCNIdleState << 2);\n  }\n  timer->CR2 = CR2_value;\n  timer->CCMR1 = (timer->CCMR1 & 0xffff8cff) | (OCMode_value << 8);\n  timer->CCR2 = config->Pulse;\n  timer->CCER = CCER_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080060c4",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "initialize_TIM_080060c4"
        },
        "FUN_08009eac": {
            "renaming": {
                "FUN_08009eac": "allocate_memory_08009eac",
                "param_1": "memory_param",
                "param_2": "memory_ptr",
                "local_18": "size",
                "local_14": "buffer_ptr",
                "uVar1": "buffer",
                "iVar2": "allocated_memory"
            },
            "code": "void allocate_memory_08009eac(int memory_param, int *memory_ptr){\n  ushort buffer;\n  int size;\n  int buffer_ptr;\n  \n  if (-1 < (int)((uint)*(ushort *)(memory_ptr + 3) << 0x1e)) {\n    size = memory_param;\n    buffer_ptr = memory_ptr;\n    buffer = __swhatbuf_r(memory_param, memory_ptr, &size, &buffer_ptr);\n    int allocated_memory = _malloc_r(memory_param, size);\n    if (allocated_memory != 0) {\n      *(undefined4 *)(memory_param + 0x28) = DAT_08009f28;\n      *memory_ptr = allocated_memory;\n      *(ushort *)(memory_ptr + 3) = *(ushort *)(memory_ptr + 3) | 0x80;\n      memory_ptr[4] = allocated_memory;\n      memory_ptr[5] = size;\n      if ((buffer_ptr != (int *)0x0) && (allocated_memory = _isatty_r(memory_param, (int)*(short *)((int)memory_ptr + 0xe)), allocated_memory != 0)) {\n        *(ushort *)(memory_ptr + 3) = *(ushort *)(memory_ptr + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(memory_ptr + 3) = buffer | *(ushort *)(memory_ptr + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(memory_ptr + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(memory_ptr + 3) = *(ushort *)(memory_ptr + 3) & 0xfffc | 2;\n  }\n  *memory_ptr = (int)memory_ptr + 0x47;\n  memory_ptr[4] = (int)memory_ptr + 0x47;\n  memory_ptr[5] = 1;\n  return;\n}",
            "called": [
                "_isatty_r",
                "__swhatbuf_r",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009eac",
            "calling": [
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_08009eac"
        },
        "FUN_08008dbe": {
            "renaming": {
                "FUN_08008dbe": "printIPAddress_08008dbe",
                "this": "address",
                "p": "printer",
                "iVar3": "i",
                "iVar4": "totalPrinted",
                "sVar1": "bytesPrinted",
                "sVar2": "dotPrinted"
            },
            "code": "size_t printIPAddress_08008dbe(IPAddress *address, Print *printer) {\n  size_t totalPrinted = 0;\n  for (int i = 0; i < 3; i++) {\n    size_t bytesPrinted = Print::print(printer, address->bytes[i], 10);\n    size_t dotPrinted = Print::print(printer, '.');\n    totalPrinted += bytesPrinted + dotPrinted;\n  }\n  totalPrinted += Print::print(printer, address->bytes[3], 10);\n  return totalPrinted;\n}",
            "called": [
                "print",
                "print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008dbe",
            "calling": [],
            "imported": false,
            "current_name": "printIPAddress_08008dbe"
        },
        "FUN_080072d8": {
            "renaming": {
                "FUN_080072d8": "set_GPIO_pin_state_080072d8",
                "port": "gpio_port",
                "pin": "pin_num",
                "val": "pin_state",
                "GPIO_PIN_RESET": "GPIO_PIN_RESET",
                "GPIO_PIN_SET": "GPIO_PIN_SET",
                "HAL_GPIO_WritePin": "HAL_GPIO_WritePin"
            },
            "code": "void set_GPIO_pin_state_080072d8(GPIO_TypeDef *gpio_port, uint32_t pin_num, uint32_t pin_state) {\n    if (pin_state == 0) {\n        HAL_GPIO_WritePin(gpio_port, (uint16_t)pin_num, GPIO_PIN_RESET);\n        return;\n    }\n    HAL_GPIO_WritePin(gpio_port, (uint16_t)pin_num, GPIO_PIN_SET);\n    return;\n}",
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080072d8",
            "calling": [
                "digitalWrite"
            ],
            "imported": false,
            "current_name": "set_GPIO_pin_state_080072d8"
        },
        "FUN_08002b00": {
            "renaming": {
                "FUN_08002b00": "receiveData_08002b00",
                "inBytes": "receivedBytes",
                "numBytes": "numReceivedBytes",
                "PTR_user_onReceive_08002b54": "userOnReceivePtr",
                "PTR_rxBufferLength_08002b5c": "bufferLengthPtr",
                "PTR_rxBufferIndex_08002b58": "bufferIndexPtr",
                "PTR_rxBuffer_08002b60": "bufferPtr"
            },
            "code": "void receiveData_08002b00(uint8_t *receivedBytes, int numReceivedBytes) {\n  int* PTR_user_onReceive_08002b54 = (int*)PTR_user_onReceive_08002b54;\n  char* PTR_rxBufferLength_08002b5c = (char*)PTR_rxBufferLength_08002b5c;\n  char* PTR_rxBufferIndex_08002b58 = (char*)PTR_rxBufferIndex_08002b58;\n  void** PTR_rxBuffer_08002b60 = *(void***)PTR_rxBuffer_08002b60;\n  \n  if (*PTR_user_onReceive_08002b54 != 0 && *PTR_rxBufferLength_08002b5c <= *PTR_rxBufferIndex_08002b58) {\n    allocateRxBuffer(numReceivedBytes);\n    if (*PTR_rxBuffer_08002b60 == 0) {\n      _Error_Handler(PTR_s__home_bo__arduino15_packages_STM_08002b64,0x183);\n    }\n    memcpy(*PTR_rxBuffer_08002b60, receivedBytes, numReceivedBytes);\n    *PTR_rxBufferIndex_08002b58 = 0;\n    *PTR_rxBufferLength_08002b5c = (char)numReceivedBytes;\n    (**(code **)PTR_user_onReceive_08002b54)(numReceivedBytes);\n  }\n  return;\n}",
            "called": [
                "_Error_Handler",
                "memcpy",
                "allocateRxBuffer"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002b00",
            "calling": [],
            "imported": false,
            "current_name": "receiveData_08002b00"
        },
        "FUN_08002f84": {
            "renaming": {
                "FUN_08002f84": "setSystemResetCallback_08002f84",
                "this": "this",
                "command": "command",
                "newFunction": "newFunction",
                "PTR_currentSystemResetCallback_08002f90": "currentSystemResetCallback",
                "systemCallbackFunction": "systemCallbackFunction"
            },
            "code": "void __thiscall FirmataClass::setSystemResetCallback_08002f84(FirmataClass *this, uint8_t command, systemCallbackFunction newFunction)\n{\n  if (command == 0xff) {\n    *(systemCallbackFunction *)PTR_currentSystemResetCallback_08002f90 = newFunction;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f84",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "setSystemResetCallback_08002f84"
        },
        "FUN_08009094": {
            "renaming": {
                "FUN_08009094": "handle_gpio_irq_08009094",
                "GPIO_Pin": "pin_id",
                "bVar1": "pin_index",
                "PTR_gpio_irq_conf_080090b0": "gpio_irq_conf"
            },
            "code": "void handle_gpio_irq_08009094(uint16_t pin_id)\n{\n  int* PTR_gpio_irq_conf_080090b0 = (int*) PTR_PTR_gpio_irq_conf_080090b0_080090b0;\n  int* irq_conf = PTR_gpio_irq_conf_080090b0 + (pin_id * 0x14 / sizeof(int));\n  if (*irq_conf != 0) {\n    std::function<void()> irq_handler = (std::function<void()>*)(irq_conf + 1);\n    irq_handler();\n  }\n  return;\n}",
            "called": [
                "operator()",
                "get_pin_id"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009094",
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_gpio_irq_08009094"
        },
        "FUN_0800a0cc": {
            "renaming": {
                "FUN_0800a0cc": "close_file_and_return_errno_0800a0cc",
                "param_1": "p_errno",
                "param_2": "file_descriptor",
                "puVar1": "errno_pointer",
                "iVar2": "close_result"
            },
            "code": "void close_file_and_return_errno_0800a0cc(int *p_errno, int file_descriptor) {\n    undefined *errno_pointer = PTR_errno_0800a0e8;\n    *(undefined4 *)PTR_errno_0800a0e8 = 0;\n    int close_result = _close(file_descriptor);\n    if ((close_result == -1) && (*(int *)errno_pointer != 0)) {\n        *p_errno = *(int *)errno_pointer;\n    }\n    return;\n}",
            "called": [
                "_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a0cc",
            "calling": [
                "__sclose"
            ],
            "imported": false,
            "current_name": "close_file_and_return_errno_0800a0cc"
        },
        "FUN_08002580": {
            "renaming": {
                "FUN_08002580::FUN_08002580": "initialize_servo",
                "*this": "servo",
                "bVar1": "servo_count",
                "*PTR_FUN_08002580Count_080025a4": "servo_count_ptr",
                "servoIndex": "index",
                "*PTR_servos_080025a8": "servo_array_ptr",
                "FUN_08002580": "initialize_servo_08002580"
            },
            "code": "initialize_servo_08002580 * __thiscall initialize_servo_08002580(initialize_servo_08002580 *servo)\n{\n  byte servo_count;\n  servo_count = **PTR_initialize_servo_08002580Count_080025a4;\n  if (servo_count > 11) {\n    servo->servoIndex = 0xff;\n    return servo;\n  }\n  **PTR_initialize_servo_08002580Count_080025a4 = servo_count + 1;\n  servo->servoIndex = servo_count;\n  *(undefined4 *)(*PTR_servos_080025a8 + (uint)servo_count * 8 + 4) = 0x5dc;\n  return servo;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002580",
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "imported": false,
            "current_name": "initialize_servo_08002580"
        },
        "FUN_080073ec": {
            "renaming": {
                "FUN_080073ec": "set_bit_080073ec",
                "puVar1": "ptr",
                "DAT_0800742c": "data",
                "DAT_08007430": "mask"
            },
            "code": "void set_bit_080073ec(uint *DAT_0800742c)\n{\n  uint *ptr = DAT_0800742c;\n  *ptr |= 1;\n  ptr[1] &= DAT_08007430;\n  *ptr &= 0xfef6ffff;\n  *ptr &= 0xfffbffff;\n  ptr[1] &= 0xff80ffff;\n  ptr[2] = 0x9f0000;\n  *(uint *)(DAT_08007434 + 8) = 0x8000000;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073ec",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "set_bit_080073ec"
        },
        "FUN_08008ef4": {
            "renaming": {
                "FUN_08008ef4": "map_value_08008ef4",
                "x": "input_value",
                "in_min": "input_min",
                "in_max": "input_max",
                "out_min": "output_min",
                "out_max": "output_max",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "uint32_t map_value_08008ef4(uint32_t input_value, uint32_t input_min, uint32_t input_max, uint32_t output_min, uint32_t output_max){\n    uint32_t mapped_value = ((output_max - output_min) * (input_value - input_min)) / (input_max - input_min) + output_min;\n    return mapped_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008ef4",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "map_value_08008ef4"
        },
        "FUN_08009fe8": {
            "renaming": {
                "FUN_08009fe8": "signal_handler_08009fe8",
                "__sig": "signal_number",
                "iVar1": "result",
                "_FUN_08009fe8_r": "signal_handler_r"
            },
            "code": "int signal_handler_08009fe8(int signal_number)\n{\n  int result = signal_handler_08009fe8_r(*(undefined4 *)PTR__impure_ptr_08009ff4, signal_number);\n  return result;\n}",
            "called": [
                "_raise_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009fe8",
            "calling": [
                "abort"
            ],
            "imported": false,
            "current_name": "signal_handler_08009fe8"
        },
        "FUN_08002c1e": {
            "renaming": {
                "FUN_08002c1e": "initialize_static_variables_08002c1e"
            },
            "code": "void initialize_static_variables_08002c1e(void)\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}",
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002c1e",
            "calling": [],
            "imported": false,
            "current_name": "initialize_static_variables_08002c1e"
        },
        "FUN_08002f94": {
            "renaming": {
                "FUN_08002f94": "setSysexCallback_08002f94",
                "command": "command",
                "newFunction": "newFunction",
                "PTR_currentSysexCallback_08002f9c": "currentSysexCallback"
            },
            "code": "void __thiscall firmata::FirmataClass::setSysexCallback_08002f94(FirmataClass *this, uint8_t command, sysexCallbackFunction newFunction)\n{\n  *(sysexCallbackFunction *)PTR_currentSysexCallback_08002f9c = newFunction;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f94",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "setSysexCallback_08002f94"
        },
        "FUN_08008eec": {
            "renaming": {
                "FUN_08008eec": "print_character_08008eec",
                "this": "this",
                "b": "character",
                "base": "base",
                "sVar1": "result"
            },
            "code": "size_t __thiscall Print::print_character_08008eec(Print *this, uchar character, int base)\n{\n  size_t result;\n  result = print_character_08008eec(this, (uint)character, base);\n  return result;\n}",
            "called": [
                "print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008eec",
            "calling": [
                "printTo"
            ],
            "imported": false,
            "current_name": "print_character_08008eec"
        },
        "FUN_08001b48": {
            "renaming": {
                "FUN_08001b48": "initializeFirmata_08001b48",
                "this": "firmataInstance"
            },
            "code": "void initializeFirmata_08001b48(void)\n{\n  undefined *firmataInstance = PTR_Firmata_08001bc0;\n  firmataInstance->setFirmwareNameAndVersion(PTR_Firmata_08001bc0, PTR_s__home_bo_p2im_p2im_real_firmware_08001bc4, '2', '5');\n  firmataInstance->attach(0xe0, DAT_08001bc8);\n  firmataInstance->attach(0x90, DAT_08001bcc);\n  firmataInstance->attach(0xc0, DAT_08001bd0);\n  firmataInstance->attach(0xd0, DAT_08001bd4);\n  firmataInstance->attach(0xf4, DAT_08001bd8);\n  firmataInstance->attach(0xf5, DAT_08001bdc);\n  firmataInstance->attach(0xf0, DAT_08001be0);\n  firmataInstance->attach(0xff, DAT_08001be4);\n  firmataInstance->begin(0xe100);\n  systemResetCallback();\n  startForkserver(0);\n  return;\n}",
            "called": [
                "begin",
                "startForkserver",
                "attach",
                "attach",
                "setFirmwareNameAndVersion",
                "attach",
                "systemResetCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001b48",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initializeFirmata_08001b48"
        },
        "FUN_08005df4": {
            "renaming": {
                "FUN_08005df4": "configureTimer_08005df4",
                "htim": "timer",
                "pTVar1": "timerInstance",
                "HAL_TIM_STATE_BUSY": "TIMER_CONFIGURATION_BUSY",
                "HAL_TIM_STATE_RESET": "TIMER_CONFIGURATION_RESET",
                "HAL_UNLOCKED": "TIMER_CONFIGURATION_UNLOCKED"
            },
            "code": "HAL_StatusTypeDef_conflict configureTimer_08005df4(TIM_HandleTypeDef_conflict *timer)\n{\n  TIM_TypeDef_conflict *timerInstance;\n  \n  timer->State = HAL_TIM_STATE_BUSY;\n  timerInstance = timer->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  HAL_TIM_OC_MspDeInit(timer);\n  timer->State = HAL_TIM_STATE_RESET;\n  timer->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}",
            "called": [
                "HAL_TIM_OC_MspDeInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005df4",
            "calling": [
                "TimerPulseDeinit"
            ],
            "imported": false,
            "current_name": "configureTimer_08005df4"
        },
        "FUN_08009148": {
            "renaming": {
                "FUN_08009148": "execute_preinit_and_global_dtors_08009148",
                "puVar1": "preinit_func_ptr",
                "iVar2": "preinit_func_count",
                "iVar3": "i",
                "dtor_func_ptr": "dtor_func_ptr",
                "PTR___preinit_array_end_08009180": "PTR___preinit_array_end_08009180",
                "PTR___preinit_array_end_08009184": "PTR___preinit_array_end_08009184",
                "PTR___preinit_array_end_08009188": "PTR___preinit_array_end_08009188",
                "PTR___do_global_dtors_aux_fini_array_entry_0800918c": "PTR___do_global_dtors_aux_fini_array_entry_0800918c"
            },
            "code": "void execute_preinit_and_global_dtors_08009148(void)\n{\n  void (**preinit_func_ptr)() = PTR___preinit_array_end_08009180;\n  int preinit_func_count = (int)PTR___preinit_array_end_08009184 - (int)PTR___preinit_array_end_08009180;\n  for (int i = 0; i < preinit_func_count / sizeof(void(*)()); i++) {\n    (*preinit_func_ptr)();\n    preinit_func_ptr++;\n  }\n  _init();\n  void (**dtor_func_ptr)() = PTR___preinit_array_end_08009188;\n  int dtor_func_count = (int)PTR___do_global_dtors_aux_fini_array_entry_0800918c - (int)PTR___preinit_array_end_08009188;\n  for (int i = 0; i < dtor_func_count / sizeof(void(*)()); i++) {\n    (*dtor_func_ptr)();\n    dtor_func_ptr++;\n  }\n  return;\n}",
            "called": [
                "premain",
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009148",
            "calling": [
                "Reset_Handler"
            ],
            "imported": false,
            "current_name": "execute_preinit_and_global_dtors_08009148"
        },
        "FUN_080099dc": {
            "renaming": {
                "FUN_080099dc": "send_char_080099dc",
                "param_1": "file_descriptor",
                "param_2": "character",
                "param_3": "stream_buffer",
                "param_4": "arg_4",
                "iVar1": "bytes_written",
                "uVar2": "ushort_value",
                "puVar3": "buffer_pointer",
                "PTR___sf_fake_stdin_08009a74": "original_stdin_ptr",
                "PTR___sf_fake_stdout_08009a78": "original_stdout_ptr",
                "PTR___sf_fake_stderr_08009a7c": "original_stderr_ptr",
                "shift": "shift_value"
            },
            "code": "uint send_char_080099dc(int file_descriptor, uint character, int *stream_buffer, undefined4 arg_4)\n{\n  int bytes_written;\n  uint uVar2;\n  undefined *buffer_pointer;\n  if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream_buffer == (int *)PTR___sf_fake_stdin_08009a74) {\n    stream_buffer = *(int **)(file_descriptor + 4);\n  }\n  else if (stream_buffer == (int *)PTR___sf_fake_stdout_08009a78) {\n    stream_buffer = *(int **)(file_descriptor + 8);\n  }\n  else if (stream_buffer == (int *)PTR___sf_fake_stderr_08009a7c) {\n    stream_buffer = *(int **)(file_descriptor + 0xc);\n  }\n  stream_buffer[2] = stream_buffer[6];\n  uVar2 = (uint)*(ushort *)(stream_buffer + 3);\n  int shift = uVar2 << 0x1c;\n  if (((shift < 0) && (uVar2 = stream_buffer[4], uVar2 != 0)) || (shift = __swsetup_r(file_descriptor,stream_buffer,shift,uVar2,arg_4), shift == 0)) {\n    character = character & 0xff;\n    bytes_written = *stream_buffer - stream_buffer[4];\n    if ((bytes_written < stream_buffer[5]) || (bytes_written = _fflush_r(file_descriptor,stream_buffer), bytes_written == 0)) {\n      stream_buffer[2] = stream_buffer[2] + -1;\n      buffer_pointer = (undefined *)*stream_buffer;\n      *stream_buffer = (int)(buffer_pointer + 1);\n      *buffer_pointer = (char)character;\n      if (bytes_written + 1 != stream_buffer[5]) {\n        if (-1 < (int)((uint)*(ushort *)(stream_buffer + 3) << 0x1f)) {\n          return character;\n        }\n        if (character != 10) {\n          return character;\n        }\n      }\n      bytes_written = _fflush_r(file_descriptor,stream_buffer);\n      if (bytes_written == 0) {\n        return character;\n      }\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "_fflush_r",
                "__swsetup_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080099dc",
            "calling": [
                "__sfputc_r"
            ],
            "imported": false,
            "current_name": "send_char_080099dc"
        },
        "FUN_08000c18": {
            "renaming": {
                "FUN_08000c18": "FUNC_08000c18"
            },
            "code": "\nvoid FUNC_08000c18(byte port,int value)\n\n{\n  byte bVar1;\n  bool bVar2;\n  uint32_t uVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  byte portValue;\n  \n  uVar6 = (uint)port;\n  if ((uVar6 < 5) && (PTR_reportPINs_08000ebc[uVar6] = (char)value, value != 0)) {\n    bVar1 = PTR_portConfigInputs_08000ec0[uVar6];\n    uVar6 = (uVar6 & 0x1f) * 8;\n    if (uVar6 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar6] == NC) {\n        portValue = 0;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n        if (uVar3 == 0) {\n          portValue = 0;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n          if (uVar3 == 1) {\n            portValue = 0;\n          }\n          else if ((bVar1 & 1) == 0) {\n            portValue = 0;\n          }\n          else {\n            iVar4 = digitalRead(uVar6);\n            if (iVar4 == 0) {\n              portValue = 0;\n            }\n            else {\n              portValue = 1;\n            }\n          }\n        }\n      }\n    }\n    else {\n      portValue = 0;\n    }\n    uVar5 = uVar6 + 1;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 2) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 2;\n    }\n    uVar5 = uVar6 + 2;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 4) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 4;\n    }\n    uVar5 = uVar6 + 3;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 8) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 8;\n    }\n    uVar5 = uVar6 + 4;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x10) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x10;\n    }\n    uVar5 = uVar6 + 5;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x20) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x20;\n    }\n    uVar5 = uVar6 + 6;\n    if (uVar5 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar5] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar5]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x40) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar5);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x40;\n    }\n    uVar6 = uVar6 + 7;\n    if (uVar6 < 0x3c) {\n      if (PTR_digitalPin_08000ec4[uVar6] == NC) {\n        bVar2 = false;\n      }\n      else {\n        uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n        if (uVar3 == 0) {\n          bVar2 = false;\n        }\n        else {\n          uVar3 = pinNametoDigitalPin(PTR_digitalPin_08000ec4[uVar6]);\n          if (uVar3 == 1) {\n            bVar2 = false;\n          }\n          else if ((bVar1 & 0x80) == 0) {\n            bVar2 = false;\n          }\n          else {\n            iVar4 = digitalRead(uVar6);\n            if (iVar4 == 0) {\n              bVar2 = false;\n            }\n            else {\n              bVar2 = true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (bVar2) {\n      portValue = portValue | 0x80;\n    }\n    outputPort(port,portValue,'\\x01');\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "digitalRead",
                "pinNametoDigitalPin",
                "outputPort"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08000c18",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_08000c18"
        },
        "FUN_08009024": {
            "renaming": {
                "FUN_08009024": "handle_external_interrupt_08009024"
            },
            "code": "void handle_external_interrupt_08009024(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(1);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009024",
            "calling": [],
            "imported": false,
            "current_name": "handle_external_interrupt_08009024"
        },
        "FUN_080064cc": {
            "renaming": {
                "FUN_080064cc": "sendNextByte_080064cc",
                "huart": "UART_HandleTypeDef",
                "huart->gState": "huart.gState",
                "huart->Init": "huart.init",
                "huart->Init).WordLength": "(huart.init).wordLength",
                "huart->Init).Parity": "(huart.init).parity",
                "huart->pTxBuffPtr": "huart.txBuffPtr",
                "huart->Instance->DR": "huart.instance->DR",
                "huart->TxXferCount": "huart.txCount",
                "HAL_BUSY": "HAL_StatusTypeDef_busy",
                "HAL_OK": "HAL_StatusTypeDef_ok"
            },
            "code": "HAL_StatusTypeDef sendNextByte_080064cc(UART_HandleTypeDef *huart)\n{\n  uint16_t txCount = huart->TxXferCount - 1;\n  if (huart->gState != HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  if ((huart->Init).WordLength == 0x1000) {\n    uint16_t *txBuffPtr = (uint16_t *)huart->pTxBuffPtr;\n    huart->Instance->DR = (*txBuffPtr) & 0x1ff;\n    huart->pTxBuffPtr += ((huart->Init).Parity == 0) ? 2 : 1;\n  }\n  else {\n    byte *txBuffPtr = huart->pTxBuffPtr;\n    huart->Instance->DR = (uint)*txBuffPtr;\n    huart->pTxBuffPtr++;\n  }\n  if (txCount == 0) {\n    huart->Instance->CR1 &= 0xffffff7f;\n    huart->Instance->CR1 |= 0x40;\n    return HAL_OK;\n  }\n  huart->TxXferCount = txCount;\n  return HAL_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064cc",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "sendNextByte_080064cc"
        },
        "FUN_08008058": {
            "renaming": {
                "FUN_08008058": "handle_I2C_event_interrupt_08008058",
                "PTR_i2c_handles_08008064": "i2c_handles_pointer",
                "I2C_HandleTypeDef_conflict": "I2C_handle_type"
            },
            "code": "void handle_I2C_event_interrupt_08008058(void)\n{\n  I2C_HandleTypeDef_conflict *i2c_handle = *(I2C_HandleTypeDef_conflict **)(PTR_i2c_handles_08008064 + 4);\n  HAL_I2C_EV_IRQHandler(i2c_handle);\n  return;\n}",
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008058",
            "calling": [],
            "imported": false,
            "current_name": "handle_I2C_event_interrupt_08008058"
        },
        "FUN_08004ac2": {
            "renaming": {
                "FUN_08004ac2": "check_address_match_08004ac2",
                "hi2c": "i2c_handler",
                "AddrMatchCode": "address_match_code",
                "hi2c->Instance": "i2c_handler->Instance",
                "hi2c->Init": "i2c_handler->Init"
            },
            "code": "HAL_StatusTypeDef check_address_match_08004ac2(I2C_HandleTypeDef *i2c_handler)\n{\n  uint16_t address_match_code;\n  if ((i2c_handler->Instance->SR2 & 0x80) == 0) {\n    address_match_code = *(uint16_t *)&(i2c_handler->Init).OwnAddress1;\n  }\n  else {\n    address_match_code = *(uint16_t *)&(i2c_handler->Init).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(i2c_handler, (i2c_handler->Instance->SR2 & 4) == 0, address_match_code);\n  return HAL_OK;\n}",
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ac2",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "check_address_match_08004ac2"
        },
        "FUN_08006ca8": {
            "renaming": {
                "FUN_08006ca8": "init_ADC_Pin_Mode_08006ca8",
                "hadc": "adc_handle",
                "puVar1": "pin_pointer",
                "GPIOx": "gpio",
                "tmpreg": "tmp_reg",
                "tmpreg_1": "unused_reg",
                "GPIO_InitStruct": "gpio_init_struct",
                "DAT_08006d14": "ADC1",
                "DAT_08006d18": "ADC2",
                "PTR_g_current_pin_08006d1c": "g_current_pin",
                "Pin": "pin_number"
            },
            "code": "void init_ADC_Pin_Mode_08006ca8(ADC_HandleTypeDef *adc_handle)\n{\n  uint32_t tmp_reg;\n  GPIO_InitTypeDef gpio_init_struct;\n  uint32_t pin_number;\n  GPIO_TypeDef *gpio;\n  if (adc_handle->Instance == DAT_08006d14) {\n    tmp_reg = *(uint *)(GPIOC_BASE + 0x18);\n    tmp_reg |= GPIO_PIN_9;\n    *(uint *)(GPIOC_BASE + 0x18) = tmp_reg;\n  }\n  else if (adc_handle->Instance == DAT_08006d18) {\n    tmp_reg = *(uint *)(GPIOC_BASE + 0x18);\n    tmp_reg |= GPIO_PIN_10;\n    *(uint *)(GPIOC_BASE + 0x18) = tmp_reg;\n  }\n  pin_number = *PTR_g_current_pin_08006d1c;\n  gpio = set_GPIO_Port_Clock((uint)(pin_number << 0x18) >> 0x1c);\n  gpio_init_struct.Pin = 1 << (pin_number & 0xf) & 0xffff;\n  gpio_init_struct.Mode = GPIO_MODE_ANALOG;\n  gpio_init_struct.Pull = GPIO_NOPULL;\n  HAL_GPIO_Init(gpio, &gpio_init_struct);\n}",
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006ca8",
            "calling": [
                "HAL_ADC_Init"
            ],
            "imported": false,
            "current_name": "init_ADC_Pin_Mode_08006ca8"
        },
        "FUN_0800937c": {
            "renaming": {
                "FUN_0800937c": "FUNC_0800937c"
            },
            "code": "\nint FUNC_0800937c(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  bool bVar1;\n  undefined *puVar2;\n  int iVar3;\n  void *pvVar4;\n  int *piVar5;\n  byte *pbVar6;\n  byte *pbVar7;\n  int unaff_r9;\n  int iVar8;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 local_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  local_8c = param_4;\n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_2 == PTR___sf_fake_stdin_08009588) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR___sf_fake_stdout_08009590) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR___sf_fake_stderr_08009594) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar8 = __swsetup_r(param_1,param_2), iVar8 != 0)) {\n    return -1;\n  }\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar6 = param_3;\nLAB_080093be:\n  pbVar7 = pbVar6;\n  if (*pbVar7 != 0) goto LAB_08009474;\n  goto LAB_080093c8;\nLAB_08009474:\n  pbVar6 = pbVar7 + 1;\n  if (*pbVar7 != 0x25) goto LAB_080093be;\nLAB_080093c8:\n  iVar8 = (int)pbVar7 - (int)param_3;\n  if (iVar8 != 0) {\n    iVar3 = __sfputs_r(param_1,param_2,param_3,iVar8);\n    if (iVar3 == -1) {\nLAB_08009568:\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar8;\n  }\n  if (*pbVar7 == 0) goto LAB_08009568;\n  local_88 = 0;\n  local_7c = 0;\n  local_84 = -1;\n  local_80 = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar6 = pbVar7 + 1;\n  while( true ) {\n    pvVar4 = memchr(PTR_s___0__0800958c,(uint)*pbVar6,5);\n    puVar2 = PTR_DAT_08009598;\n    param_3 = pbVar6 + 1;\n    if (pvVar4 == (void *)0x0) break;\n    local_88 = 1 << ((int)pvVar4 - (int)PTR_s___0__0800958c & 0xffU) | local_88;\n    pbVar6 = param_3;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar6 == 0x2a) {\n    piVar5 = local_8c + 1;\n    iVar8 = *local_8c;\n    local_8c = piVar5;\n    if (-1 < iVar8) goto LAB_08009498;\n    local_7c = -iVar8;\n    local_88 = local_88 | 2;\n  }\n  else {\n    bVar1 = false;\n    iVar8 = local_7c;\n    param_3 = pbVar6;\n    while( true ) {\n      if (9 < *param_3 - 0x30) break;\n      iVar8 = iVar8 * 10 + (*param_3 - 0x30);\n      bVar1 = true;\n      param_3 = param_3 + 1;\n    }\n    if (bVar1) {\nLAB_08009498:\n      local_7c = iVar8;\n    }\n  }\n  if (*param_3 == 0x2e) {\n    if (param_3[1] == 0x2a) {\n      param_3 = param_3 + 2;\n      piVar5 = local_8c + 1;\n      local_84 = *local_8c;\n      local_8c = piVar5;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n    }\n    else {\n      bVar1 = false;\n      iVar8 = 0;\n      local_84 = 0;\n      while( true ) {\n        param_3 = param_3 + 1;\n        if (9 < *param_3 - 0x30) break;\n        iVar8 = iVar8 * 10 + (*param_3 - 0x30);\n        bVar1 = true;\n      }\n      if (bVar1) {\n        local_84 = iVar8;\n      }\n    }\n  }\n  pvVar4 = memchr(PTR_DAT_08009598,(uint)*param_3,3);\n  if (pvVar4 != (void *)0x0) {\n    param_3 = param_3 + 1;\n    local_88 = local_88 | 0x40 << ((int)pvVar4 - (int)puVar2 & 0xffU);\n  }\n  local_70 = *param_3;\n  param_3 = param_3 + 1;\n  pvVar4 = memchr(PTR_s_efgEFG_0800959c,(uint)local_70,6);\n  if (pvVar4 == (void *)0x0) {\n    iVar8 = _printf_i(param_1,&local_88,param_2,DAT_080095a4,&local_8c);\n  }\n  else {\n    iVar8 = param_1;\n    if (DAT_080095a0 == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar8 = unaff_r9;\n      goto LAB_0800951a;\n    }\n  }\n  if (iVar8 == -1) goto LAB_08009568;\nLAB_0800951a:\n  local_74 = local_74 + iVar8;\n  pbVar6 = param_3;\n  unaff_r9 = iVar8;\n  goto LAB_080093be;\n}\n\n",
            "called": [
                "memchr",
                "__sfputs_r",
                "__swsetup_r",
                "_printf_i",
                "__sinit"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0800937c",
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "imported": false,
            "current_name": "FUNC_0800937c"
        },
        "FUN_08000214": {
            "renaming": {
                "FUN_08000214": "write_to_pin_08000214",
                "pin": "pin_number",
                "value": "value",
                "bVar1": "valid_pin",
                "bVar2": "pin_mode",
                "_Var3": "valid_pin",
                "ulPin": "pin_number",
                "uVar4": "digital_pin"
            },
            "code": "void write_to_pin_08000214(byte pin, int value) {\n  uint pin_number = (uint)pin;\n  if (pin_number > 59) {\n    return;\n  }\n  byte pin_mode = firmata::FirmataClass::getPinMode((FirmataClass *)PTR_Firmata_080002d8, pin);\n  if (pin_mode == 3) {\n    if (pin_number < 60) {\n      if (PTR_digitalPin_080002dc[pin_number] == NC) {\n        bool valid_pin = false;\n      }\n      else {\n        uint32_t digital_pin = pinNametoDigitalPin(PTR_digitalPin_080002dc[pin_number]);\n        if (digital_pin == 0 || digital_pin == 1) {\n          bool valid_pin = false;\n        }\n        else {\n          bool valid_pin = pin_in_pinmap(PTR_digitalPin_080002dc[pin_number], (PinMap_conflict *)PTR_PinMap_PWM_080002e8);\n        }\n      }\n    }\n    else {\n      bool valid_pin = false;\n    }\n    if (valid_pin) {\n      analogWrite(pin_number, value);\n    }\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_080002d8, pin, value);\n  }\n  else if (pin_mode == 4) {\n    if (pin_number < 60) {\n      if (PTR_digitalPin_080002dc[pin_number] == NC) {\n        bool valid_pin = false;\n      }\n      else {\n        bool valid_pin = true;\n      }\n    }\n    else {\n      bool valid_pin = false;\n    }\n    if (valid_pin) {\n      Servo::write((Servo *)(PTR_servos_080002e4 + (uint)(byte)PTR_servoPinMap_080002e0[pin_number] * 3), value);\n    }\n    firmata::FirmataClass::setPinState((FirmataClass *)PTR_Firmata_080002d8, pin, value);\n    return;\n  }\n  return;\n}",
            "called": [
                "pin_in_pinmap",
                "pinNametoDigitalPin",
                "setPinState",
                "analogWrite",
                "getPinMode",
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000214",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "write_to_pin_08000214"
        },
        "FUN_08003724": {
            "renaming": {
                "FUN_08003724": "set_up_system_08003724",
                "DAT_08003744": "data_register",
                "FUN_08003724Tick": "set_up_system_tick"
            },
            "code": "HAL_StatusTypeDef_conflict set_up_system_08003724(void)\n{\n  *DAT_08003744 = *DAT_08003744 | 0x10;\n  HAL_NVIC_SetPriorityGrouping(3);\n  set_up_system_08003724_tick(0xf);\n  HAL_MspInit();\n  return HAL_OK;\n}",
            "called": [
                "HAL_InitTick",
                "HAL_MspInit",
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003724",
            "calling": [
                "hw_config_init"
            ],
            "imported": false,
            "current_name": "set_up_system_08003724"
        },
        "FUN_08005bb8": {
            "renaming": {
                "FUN_08005bb8": "calculateClockFrequency_08005bb8",
                "PeriphClk": "peripheralClock",
                "uVar1": "frequency",
                "uVar2": "temp",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllMulFactorTable",
                "PTR_DAT_08005ca0": "PREDIV_FACTOR_TABLE_START",
                "PTR_DAT_08005ca4": "PLLMUL_FACTOR_TABLE_START",
                "DAT_08005ca4": "PLLMUL_FACTOR_TABLE_START",
                "DAT_08005ca8": "PLLMUL_FACTOR_TABLE_START[2]",
                "DAT_08005cac": "PLLMUL_FACTOR_TABLE_START[3]",
                "DAT_08005cb0": "PLLMUL_FACTOR_TABLE_START[2]"
            },
            "code": "uint32_t calculateClockFrequency_08005bb8(uint32_t peripheralClock)\n{\n  uint32_t frequency = 0;\n  uint8_t predivFactorTable [2];\n  uint8_t pllMulFactorTable [16];\n  pllMulFactorTable[0] = *(uint32_t *)(PTR_DAT_08005ca4 + 0);\n  pllMulFactorTable[1] = *(uint32_t *)(PTR_DAT_08005ca4 + 4);\n  pllMulFactorTable[2] = *(uint32_t *)(PTR_DAT_08005ca4 + 8);\n  predivFactorTable = *(uint8_t (*) [2])(PTR_DAT_08005ca0);\n  if (peripheralClock == 2) {\n    frequency = HAL_RCC_GetPCLK2Freq();\n    frequency = frequency / ((((PTR_DAT_08005ca4[1] << 0x10) >> 0x1e) + 1) * 2);\n  }\n  else if (peripheralClock == 0x10) {\n    if ((*PTR_DAT_08005ca4 & 0x1000000) == 0) {\n      frequency = 0;\n    }\n    else {\n      uint32_t temp = 0;\n      if ((PTR_DAT_08005ca4[1] & 0x10000) != 0) {\n        temp = DAT_08005ca8 / predivFactorTable[-((int)(PTR_DAT_08005ca4[1] << 0xe) >> 0x1f)];\n      }\n      frequency = temp * pllMulFactorTable[(PTR_DAT_08005ca4[1] << 10) >> 0x1c];\n      if ((PTR_DAT_08005ca4[1] & 0x400000) == 0) {\n        frequency = (uint32_t)((uint64_t)DAT_08005cac * (uint64_t)(frequency * 2) >> 0x21);\n      }\n    }\n  }\n  else if (peripheralClock == 1) {\n    if ((PTR_DAT_08005ca4[8] & 0x302) == 0x102) {\n      frequency = 0x8000;\n    }\n    else {\n      uint32_t temp = PTR_DAT_08005ca4[8] & 0x300;\n      if ((temp == 0x200) && ((PTR_DAT_08005ca4[9] & 2) != 0)) {\n        frequency = 32000;\n      }\n      else if (temp == 0x300) {\n        if ((*PTR_DAT_08005ca4 & 0x20000) == 0) {\n          frequency = 0;\n        }\n        else {\n          frequency = 0xf424;\n        }\n      }\n    }\n  }\n  return frequency;\n}",
            "called": [
                "HAL_RCC_GetPCLK2Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005bb8",
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_PollForConversion"
            ],
            "imported": false,
            "current_name": "calculateClockFrequency_08005bb8"
        },
        "FUN_08002f0a": {
            "renaming": {
                "FUN_08002f0a": "sendCommand_08002f0a",
                "this": "firmataInstance",
                "command": "commandByte",
                "bytec": "numBytes",
                "bytev": "byteArray"
            },
            "code": "void __thiscall firmata::FirmataClass::sendCommand_08002f0a(byte command, byte numBytes, byte *byteArray) {\n FirmataMarshaller::sendCommand_08002f0a(&marshaller, command, (uint)numBytes, byteArray);\n return;\n}",
            "called": [
                "sendSysex"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f0a",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "sendCommand_08002f0a"
        },
        "FUN_08002634": {
            "renaming": {
                "FUN_08002634": "setPinAndLimits_08002634",
                "this": "servo",
                "pin": "pinNumber",
                "uVar1": "result"
            },
            "code": "uint8_t __thiscall Servo::setPinAndLimits_08002634(Servo *servo, int pinNumber)\n{\n  uint8_t result;\n  result = setPinAndLimits_08002634(servo, pinNumber, 0x220, 0x960);\n  return result;\n}",
            "called": [
                "attach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002634",
            "calling": [
                "attachServo"
            ],
            "imported": false,
            "current_name": "setPinAndLimits_08002634"
        },
        "FUN_080063c0": {
            "renaming": {
                "FUN_080063c0": "disableTimerChannel_080063c0",
                "htim": "timerHandle",
                "Channel": "channel",
                "pTVar1": "timerInstance",
                "DAT_0800641c": "instanceToCheck"
            },
            "code": "HAL_StatusTypeDef_conflict disableTimerChannel_080063c0(TIM_HandleTypeDef_conflict *timerHandle, uint32_t channel)\n{\n  TIM_TypeDef_conflict *timerInstance = timerHandle->Instance;\n  TIM_CCxChannelCmd(timerInstance, channel, 0);\n\n  if (((timerInstance == DAT_0800641c) && ((timerInstance->CCER & 0x1111) == 0)) && ((timerInstance->CCER & 0x444) == 0))\n  {\n    timerInstance->BDTR &= 0xffff7fff;\n  }\n\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0))\n  {\n    timerInstance->CR1 &= 0xfffffffe;\n  }\n\n  timerHandle->State = HAL_TIM_STATE_READY;\n  return HAL_OK;\n}",
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080063c0",
            "calling": [
                "pwm_stop"
            ],
            "imported": false,
            "current_name": "disableTimerChannel_080063c0"
        },
        "FUN_0800274c": {
            "renaming": {
                "FUN_0800274c": "receive_byte_from_rx_buffer_0800274c",
                "this": "wire",
                "*PTR_rxBufferIndex_08002768": "rx_buffer_index_pointer",
                "*PTR_rxBufferLength_0800276c": "rx_buffer_length_pointer",
                "*(int *)PTR_rxBuffer_08002770": "rx_buffer_pointer"
            },
            "code": "int __thiscall receive_byte_from_rx_buffer_0800274c(TwoWire *wire) {\n  int rx_buffer_index = **PTR_rxBufferIndex_08002768;\n  int rx_buffer_length = **PTR_rxBufferLength_0800276c;\n  if (rx_buffer_index < rx_buffer_length) {\n    int byte_received = *(int *)*(int *)PTR_rxBuffer_08002770 + rx_buffer_index;\n    return (uint)*(byte *)byte_received;\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800274c",
            "calling": [],
            "imported": false,
            "current_name": "receive_byte_from_rx_buffer_0800274c"
        },
        "FUN_080098d8": {
            "renaming": {
                "FUN_080098d8": "print_formatted_string_080098d8",
                "__format": "format",
                "in_r1": "arg1",
                "in_r2": "arg2",
                "in_r3": "arg3",
                "iVar1": "impure_ptr",
                "pcVar2": "current_arg",
                "uStack_c": "stack_var1",
                "uStack_8": "stack_var2",
                "uStack_4": "stack_var3"
            },
            "code": "int print_formatted_string_080098d8(char* format, ...) {\n  int impure_ptr = *(int *)PTR__impure_ptr_08009904;\n  char *current_arg = format;\n  undefined4 arg1;\n  undefined4 arg2;\n  undefined4 arg3;\n  undefined4 stack_var1;\n  undefined4 stack_var2;\n  undefined4 stack_var3;\n  if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n    __sinit(impure_ptr);\n  }\n  int result = _vfprint_r(impure_ptr, *(undefined4 *)(impure_ptr + 8), format, &arg1, current_arg, &arg2);\n  return result;\n}",
            "called": [
                "_vfiprintf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080098d8",
            "calling": [
                "getTimerClkFreq",
                "getTimerIrq",
                "getTimerClkSrc",
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "print_formatted_string_080098d8"
        },
        "FUN_08009270": {
            "renaming": {
                "FUN_08009270": "allocate_memory_block_08009270",
                "param_1": "error_code",
                "param_2": "requested_size",
                "puVar1": "start_of_heap",
                "uVar2": "sbrk_result",
                "puVar3": "current_block",
                "iVar4": "sbrk_error",
                "puVar5": "previous_block",
                "uVar6": "block_remainder",
                "puVar7": "block_header",
                "uVar8": "block_size"
            },
            "code": "uint allocate_memory_block_08009270(undefined4 *error_code, uint requested_size)\n{\n  uint *current_block;\n  uint block_size;\n  uint *previous_block;\n  uint block_remainder;\n  \n  block_size = (requested_size + 3 & 0xfffffffc) + 8;\n  if (block_size < 0xc) {\n    block_size = 0xc;\n  }\n  if (((int)block_size < 0) || (block_size < requested_size)) {\n    *error_code = 0xc;\n  }\n  else {\n    __malloc_lock();\n    previous_block = *(uint **)PTR___malloc_free_list_08009324;\n    current_block = previous_block;\n    while (current_block != (uint *)0x0) {\n      block_remainder = *current_block - block_size;\n      if (-1 < (int)block_remainder) {\n        if (block_remainder < 0xc) {\n          if (previous_block == current_block) {\n            block_size = previous_block[1];\n            *(uint *)PTR___malloc_free_list_08009324 = block_size;\n          }\n          else {\n            block_size = current_block[1];\n          }\n          if (previous_block != current_block) {\n            previous_block[1] = block_size;\n            previous_block = current_block;\n          }\n        }\n        else {\n          *current_block = block_remainder;\n          *(uint *)((int)current_block + block_remainder) = block_size;\n          previous_block = (uint *)((int)current_block + block_remainder);\n        }\n        goto LAB_080092d4;\n      }\n      previous_block = current_block;\n      current_block = (uint *)current_block[1];\n    }\n    if (*(int *)PTR___malloc_sbrk_start_08009328 == 0) {\n      uVar2 = _sbrk_r(error_code);\n      *(undefined4 *)PTR___malloc_sbrk_start_08009328 = uVar2;\n    }\n    current_block = (uint *)_sbrk_r(error_code,block_size);\n    if ((current_block != (uint *)0xffffffff) &&\n       ((previous_block = (uint *)((int)current_block + 3U & 0xfffffffc), current_block == previous_block ||\n        (block_remainder = _sbrk_r(error_code,(int)previous_block - (int)current_block), block_remainder != -1)))) {\n      *previous_block = block_size;\nLAB_080092d4:\n      __malloc_unlock(error_code);\n      block_size = (int)previous_block + 0xbU & 0xfffffff8;\n      block_remainder = block_size - (int)(previous_block + 1);\n      if (block_remainder != 0) {\n        *(int *)((int)previous_block + block_remainder) = -block_remainder;\n        return block_size;\n      }\n      return block_size;\n    }\n    *error_code = 0xc;\n    __malloc_unlock(error_code);\n  }\n  return 0;\n}",
            "called": [
                "__malloc_lock",
                "_sbrk_r",
                "__malloc_unlock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009270",
            "calling": [
                "__smakebuf_r",
                "malloc",
                "_realloc_r",
                "__sfmoreglue"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_08009270"
        },
        "FUN_08009038": {
            "renaming": {
                "FUN_08009038": "handle_GPIO_EXTI4_08009038"
            },
            "code": "void handle_GPIO_EXTI4_08009038(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009038",
            "calling": [],
            "imported": false,
            "current_name": "handle_GPIO_EXTI4_08009038"
        },
        "FUN_08005aa4": {
            "renaming": {
                "FUN_08005aa4": "configurePeriphClocks_08005aa4",
                "*PeriphClkInit": "PeriphClkInit",
                "iVar1": "index",
                "*puVar2": "flagReg2",
                "uVar3": "startTick",
                "uVar4": "currentTick",
                "uVar5": "clockSel",
                "bVar6": "isClockEnabled",
                "tmpreg": "status",
                "DAT_08005bac": "clockReg",
                "DAT_08005bb0": "flagReg",
                "DAT_08005bb4": "flagReg2",
                "HAL_StatusTypeDef_conflict": "HAL_StatusTypeDef",
                "RCC_PeriphCLKInitTypeDef_conflict": "RCC_PeriphCLKInitTypeDef",
                "HAL_GetTick": "HAL_GetTick",
                "HAL_TIMEOUT": "HAL_TIMEOUT",
                "RCC_PERIPHCLK_RTC": "RCC_PERIPHCLK_RTC",
                "RCC_FLAG_HSIRDY": "RCC_FLAG_HSIRDY",
                "RCC_FLAG_HSION": "RCC_FLAG_HSION",
                "RCC_PERIPHCLK_ADC": "RCC_PERIPHCLK_ADC",
                "RCC_PERIPHCLK_USB": "RCC_PERIPHCLK_USB"
            },
            "code": "HAL_StatusTypeDef configurePeriphClocks_08005aa4(RCC_PeriphCLKInitTypeDef *PeriphClkInit)\n{\n  bool isClockEnabled = false;\n  uint32_t startTick = 0;\n  uint32_t currentTick = 0;\n  uint32_t *DAT_08005bac = (uint32_t*)0x08005bac;\n  uint32_t *DAT_08005bb0 = (uint32_t*)0x08005bb0;\n  uint32_t *DAT_08005bb4 = (uint32_t*)0x08005bb4;\n  uint32_t clockSel = 0;\n  HAL_StatusTypeDef status = HAL_OK;\n\n  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) != 0) {\n    isClockEnabled = ((*DAT_08005bac + 0x1C) & 0x10000000) == 0;\n    if (isClockEnabled) {\n      *DAT_08005bac = *DAT_08005bac | 0x10000000;\n    }\n    if ((*DAT_08005bb0 & RCC_FLAG_HSIRDY) == 0) {\n      *DAT_08005bb0 = *DAT_08005bb0 | RCC_FLAG_HSION;\n      startTick = HAL_GetTick();\n      while ((*DAT_08005bb0 & RCC_FLAG_HSIRDY) == 0) {\n        currentTick = HAL_GetTick();\n        if (100 < currentTick - startTick) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    clockSel = (*DAT_08005bac + 0x20) & 0x300;\n    if ((clockSel != 0) && (clockSel != (PeriphClkInit->RTCClockSelection & 0x300))) {\n      clockSel = (*DAT_08005bac + 0x20);\n      *DAT_08005bb4 = 1;\n      *DAT_08005bb4 = 0;\n      *(DAT_08005bac + 0x20) = clockSel & 0xfffffcff;\n      if ((clockSel & 1) != 0) {\n        startTick = HAL_GetTick();\n        while ((*(DAT_08005bac + 0x20) & 2) == 0) {\n          currentTick = HAL_GetTick();\n          if (5000 < currentTick - startTick) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    *(DAT_08005bac + 0x20) = *(DAT_08005bac + 0x20) & 0xfffffcff | PeriphClkInit->RTCClockSelection;\n    if (isClockEnabled) {\n      *DAT_08005bac = *DAT_08005bac & 0xefffffff;\n    }\n  }\n  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) != 0) {\n    *(DAT_08005bac + 4) = *(DAT_08005bac + 4) & 0xffff3fff | PeriphClkInit->AdcClockSelection;\n  }\n  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USB) != 0) {\n    *(DAT_08005bac + 4) = *(DAT_08005bac + 4) & 0xffbfffff | PeriphClkInit->UsbClockSelection;\n  }\n  return status;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005aa4",
            "calling": [
                "SystemClock_Config"
            ],
            "imported": false,
            "current_name": "configurePeriphClocks_08005aa4"
        },
        "FUN_08008068": {
            "renaming": {
                "FUN_08008068": "handle_I2C_errors_08008068",
                "PTR_i2c_handles_08008074": "PTR_i2c_handles",
                "i2c_handle": "i2c_handle"
            },
            "code": "void handle_I2C_errors_08008068(void)\n{\n  I2C_HandleTypeDef* i2c_handle = *(I2C_HandleTypeDef_conflict **)(PTR_i2c_handles_08008074_08008074 + 4);\n  HAL_I2C_ER_IRQHandler(i2c_handle);\n  return;\n}",
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008068",
            "calling": [],
            "imported": false,
            "current_name": "handle_I2C_errors_08008068"
        },
        "FUN_08002400": {
            "renaming": {
                "FUN_08002400": "is_timer_sequence_valid_08002400",
                "timer": "timer16_Sequence_t",
                "uVar1": "servo_index",
                "PTR_servos_08002428": "PTR_servos_08002428"
            },
            "code": "bool is_timer_sequence_valid_08002400(timer16_Sequence_t timer) {\n  uint8_t servo_index = 0;\n  while (true) {\n    if (servo_index > 11) {\n      return false;\n    }\n    if ((PTR_servos_08002428[((uint)timer * 0xc + servo_index) * 8] & 0x40) != 0) {\n      break;\n    }\n    servo_index = (servo_index + 1) % 256;\n  }\n  return true;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002400",
            "calling": [
                "attach",
                "detach"
            ],
            "imported": false,
            "current_name": "is_timer_sequence_valid_08002400"
        },
        "FUN_08000588": {
            "renaming": {
                "FUN_08000588": "detach_servo_08000588",
                "pin": "pin",
                "PTR_servoPinMap_080005cc": "servo_pin_map",
                "Servo::detach": "Servo::detach",
                "PTR_servos_080005d0": "servos",
                "PTR_servoCount_080005d4": "servo_count_ptr",
                "cVar1": "servo_count",
                "cVar2": "servo_pin",
                "PTR_detachedServoCount_080005d8": "detached_servo_count_ptr",
                "PTR_detachedServos_080005dc": "detached_servos"
            },
            "code": "void detach_servo_08000588(byte pin)\\n{\\n  char servo_pin = PTR_servoPinMap_080005cc[pin];\\n  Servo::detach(PTR_servos_080005d0[servo_pin]);\\n  char servo_count = *PTR_servoCount_080005d4;\\n  if ((servo_pin == servo_count) && (servo_count != \"\\0\")) {\\n    *PTR_servoCount_080005d4 = servo_count - 1;\\n  }\\n  else if (servo_count != \"\\0\") {\\n    char detached_count = *PTR_detachedServoCount_080005d8;\\n    *PTR_detachedServoCount_080005d8 = detached_count + 1;\\n    PTR_detachedServos_080005dc[detached_count] = servo_pin;\\n  }\\n  PTR_servoPinMap_080005cc[pin] = 0xff;\\n  return;\\n}",
            "called": [
                "detach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000588",
            "calling": [
                "sysexCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "detach_servo_08000588"
        },
        "FUN_08002644": {
            "renaming": {
                "FUN_08002644": "updateServo_08002644",
                "this": "servo",
                "uVar2": "servoIndex",
                "bVar1": "isTimerActiveResult"
            },
            "code": "void __thiscall updateServo_08002644(Servo *servo) {\n  boolean isTimerActiveResult;\n  uint servoIndex = (uint)servo->servoIndex;\n  PTR_servos_08002670[servoIndex * 8] = PTR_servos_08002670[servoIndex * 8] & 0xbf;\n  isTimerActiveResult = isTimerActive((timer16_Sequence_t)((ulonglong)DAT_08002674 * (ulonglong)servoIndex >> 0x23));\n  if (!isTimerActiveResult) {\n    finISR((stimer_t *)PTR__timer_08002678);\n  }\n  return;\n}",
            "called": [
                "isTimerActive",
                "finISR"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002644",
            "calling": [
                "detachServo"
            ],
            "imported": false,
            "current_name": "updateServo_08002644"
        },
        "FUN_08002f1e": {
            "renaming": {
                "FUN_08002f1e": "printByte_08002f1e",
                "this": "firmata",
                "c": "data",
                "FirmataStream": "stream",
                "super_Print": "parent_Print"
            },
            "code": "void __thiscall FirmataClass::printByte_08002f1e(FirmataClass *firmata, byte data){\n\t(**(firmata->FirmataStream->super_Print)._vptr_Print)(firmata->FirmataStream,(uint)data);\n\treturn;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f1e",
            "calling": [
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "printByte_08002f1e"
        },
        "FUN_0800902e": {
            "renaming": {
                "FUN_0800902e": "handle_GPIO_interrupt_0800902e",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void handle_GPIO_interrupt_0800902e(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_2);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800902e",
            "calling": [],
            "imported": false,
            "current_name": "handle_GPIO_interrupt_0800902e"
        },
        "FUN_08009042": {
            "renaming": {
                "FUN_08009042": "handle_GPIO_interrupt_08009042",
                "PTR_": "",
                "DAT_": "",
                "8": "GPIO_PIN_8"
            },
            "code": "void handle_GPIO_interrupt_08009042(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_8);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009042",
            "calling": [],
            "imported": false,
            "current_name": "handle_GPIO_interrupt_08009042"
        },
        "FUN_08009c7c": {
            "renaming": {
                "FUN_08009c7c": "flush_if_buffered_08009c7c",
                "param_1": "file_descriptor",
                "param_2": "stream",
                "param_3": "flags",
                "param_4": "mode",
                "uVar1": "result",
                "stream_flags": "stream_flags",
                "PTR___sf_fake_stdin_08009cc4": "PTR___sf_fake_stdin_08009cc4",
                "PTR___sf_fake_stdout_08009cc8": "PTR___sf_fake_stdout_08009cc8",
                "PTR___sf_fake_stderr_08009ccc": "PTR___sf_fake_stderr_08009ccc",
                "stream_flags_2": "stream_flags_2"
            },
            "code": "int flush_if_buffered_08009c7c(int file_descriptor, void *stream, int flags, int mode) {\n    int result = 0;\n    int *stream_flags = (int *)(stream + 0x10);\n    if (*stream_flags != 0) {\n        if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n            __sinit();\n        }\n        if (stream == PTR___sf_fake_stdin_08009cc4) {\n            stream = *(void **)(file_descriptor + 4);\n        }\n        else if (stream == PTR___sf_fake_stdout_08009cc8) {\n            stream = *(void **)(file_descriptor + 8);\n        }\n        else if (stream == PTR___sf_fake_stderr_08009ccc) {\n            stream = *(void **)(file_descriptor + 0xc);\n        }\n        short *stream_flags_2 = (short *)(stream + 0xc);\n        if (*stream_flags_2 != 0) {\n            result = __sflush_r(file_descriptor, stream, flags, mode);\n            return result;\n        }\n    }\n    return result;\n}",
            "called": [
                "__sinit",
                "__sflush_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009c7c",
            "calling": [
                "__swbuf_r"
            ],
            "imported": false,
            "current_name": "flush_if_buffered_08009c7c"
        },
        "FUN_08009b5c": {
            "renaming": {
                "FUN_08009b5c": "raise_signal_and_exit_program_08009b5c",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void raise_signal_and_exit_program_08009b5c(void)\n{\n  raise(SIGABRT);\n  _exit(EXIT_FAILURE);\n}",
            "called": [
                "_exit",
                "raise"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009b5c",
            "calling": [
                "__throw_bad_function_call",
                "__assert_func"
            ],
            "imported": false,
            "current_name": "raise_signal_and_exit_program_08009b5c"
        },
        "FUN_08008a6c": {
            "renaming": {
                "FUN_08008a6c": "read_digital_pin_08008a6c",
                "ulPin": "pin_num",
                "_Var1": "is_pin_configured",
                "port": "port",
                "uVar2": "digital_pin_value",
                "uVar3": "digital_pin_num",
                "PTR_digitalPin_08008ab4": "digitalPinArray",
                "0x3c": "0x3c",
                "0xffffffff": "0xffffffff",
                "is_pin_configured": "is_pin_configured",
                "PinName_conflict": "PinName_conflict",
                "PTR_g_digPinConfigured_08008ab8": "pin_configured_array",
                "get_GPIO_Port": "get_GPIO_Port",
                "digital_io_read": "digital_io_read",
                "0xf": "0xf",
                "0xffff": "0xffff"
            },
            "code": "int read_digital_pin_08008a6c(uint32_t pin_num) {\n  bool is_pin_configured;\n  GPIO_TypeDef *port;\n  uint32_t digital_pin_num;\n  uint8_t digital_pin_value;\n  if (pin_num < 0x3c) {\n    digital_pin_num = (uint32_t)(char)PTR_digitalPin_08008ab4[pin_num];\n  }\n  else {\n    digital_pin_num = 0xffffffff;\n  }\n  if (digital_pin_num == 0xffffffff) {\n    digital_pin_value = 0;\n  }\n  else {\n    is_pin_configured = is_pin_configured((PinName_conflict)digital_pin_num, (uint32_t *)PTR_g_digPinConfigured_08008ab8);\n    if (is_pin_configured) {\n      port = get_GPIO_Port((digital_pin_num << 0x18) >> 0x1c);\n      digital_pin_value = digital_io_read(port, 1 << (digital_pin_num & 0xf) & 0xffff) & 0xff;\n    }\n    else {\n      digital_pin_value = 0;\n    }\n  }\n  if (digital_pin_value != 0) {\n    digital_pin_value = 1;\n  }\n  return digital_pin_value;\n}",
            "called": [
                "digital_io_read",
                "get_GPIO_Port",
                "is_pin_configured"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a6c",
            "calling": [
                "checkDigitalInputs",
                "reportDigitalCallback"
            ],
            "imported": false,
            "current_name": "read_digital_pin_08008a6c"
        },
        "FUN_080085b8": {
            "renaming": {
                "FUN_080085b8": "is_uart_transmit_complete_080085b8",
                "obj": "serial_obj",
                "HVar1": "uart_state",
                "PTR_uart_handlers_080085d8": "PTR_uart_handlers",
                "uint": "unsigned int"
            },
            "code": "bool is_uart_transmit_complete_080085b8(serial_t *serial_obj)\n{\n  HAL_UART_StateTypeDef uart_state;\n  UART_HandleTypeDef *uart_handle = *(UART_HandleTypeDef **)(PTR_uart_handlers_080085d8_080085d8 + (uint)serial_obj->index * 4);\n  uart_state = HAL_UART_GetState(uart_handle);\n  return (uart_state & 0x22U) == 0x22;\n}",
            "called": [
                "HAL_UART_GetState"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080085b8",
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "imported": false,
            "current_name": "is_uart_transmit_complete_080085b8"
        },
        "FUN_08001c08": {
            "renaming": {
                "FUN_08001c08": "read_data_from_wire_08001c08",
                "in_r1": "read_address",
                "in_r2": "read_buffer",
                "in_r3": "read_length",
                "sVar1": "data_read"
            },
            "code": "byte read_data_from_wire_08001c08(void)\n{\n  ssize_t data_read;\n  int read_address;\n  void *read_buffer;\n  size_t read_length;\n  data_read = TwoWire::read((TwoWire *)PTR_Wire_08001c14, read_address, read_buffer, read_length);\n  return (byte)data_read;\n}",
            "called": [
                "read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001c08",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "read_data_from_wire_08001c08"
        },
        "FUN_080075dc": {
            "renaming": {
                "FUN_080075dc": "getTimerClockFrequency_080075dc",
                "*tim": "*timer",
                "uVar1": "frequency",
                "uVar2": "timerClockSource",
                "uVar3": "frequency",
                "uVar4": "apb1ClockDivider",
                "pFLatency": "latency",
                "clkconfig": "clockConfig"
            },
            "code": "uint32_t getTimerClockFrequency_080075dc(TIM_TypeDef_conflict *timer)\n{\n  uint32_t frequency = 0;\n  uint8_t timerClockSource = getTimerClkSrc(timer);\n  RCC_ClkInitTypeDef_conflict clockConfig;\n  clockConfig.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;\n  uint32_t latency = 0;\n  HAL_RCC_GetClockConfig(&clockConfig, &latency);\n  uint32_t apb1ClockDivider = clockConfig.APB1CLKDivider;\n  uint32_t apb2ClockDivider = clockConfig.APB2CLKDivider;\n  if (timerClockSource == TIMER_CLOCK_SOURCE_APB1)\n  {\n    frequency = HAL_RCC_GetPCLK1Freq();\n  }\n  else if (timerClockSource == TIMER_CLOCK_SOURCE_APB2)\n  {\n    frequency = HAL_RCC_GetPCLK2Freq();\n    apb1ClockDivider = apb2ClockDivider;\n  }\n  else\n  {\n    iprintf(PTR_s_TIM__Unknown_clock_source_08007644);\n  }\n  if (apb1ClockDivider != 0x500)\n  {\n    if (apb1ClockDivider < 0x501)\n    {\n      if (apb1ClockDivider != 0x400)\n      {\n        return frequency;\n      }\n    }\n    else if ((apb1ClockDivider != 0x600) && (apb1ClockDivider != 0x700))\n    {\n      return frequency;\n    }\n  }\n  return frequency << 1;\n}",
            "called": [
                "HAL_RCC_GetClockConfig",
                "HAL_RCC_GetPCLK1Freq",
                "getTimerClkSrc",
                "iprintf",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080075dc",
            "calling": [
                "pwm_start",
                "TimerPulseInit"
            ],
            "imported": false,
            "current_name": "getTimerClockFrequency_080075dc"
        },
        "FUN_080087ec": {
            "renaming": {
                "FUN_080087ec": "handle_USART3_interrupt_080087ec",
                "USART3_IRQn": "USART3_interrupt_number",
                "PTR_uart_handlers_08008800": "uart_handlers_pointer",
                "UART_HandleTypeDef": "UART_handler_structure",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "HAL_UART_IRQHandler": "handle_UART_interrupt",
                "uart_handler": "current_UART_handler"
            },
            "code": "void handle_USART3_interrupt_080087ec(void)\n{\n  HAL_NVIC_ClearPendingIRQ(USART3_IRQn);\n  UART_HandleTypeDef *uart_handler = *(UART_HandleTypeDef **)(PTR_uart_handlers_08008800 + 8);\n  if (uart_handler != NULL) {\n    HAL_UART_IRQHandler(uart_handler);\n  }\n  return;\n}",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080087ec",
            "calling": [],
            "imported": false,
            "current_name": "handle_USART3_interrupt_080087ec"
        },
        "FUN_08007ff0": {
            "renaming": {
                "FUN_08007ff0": "i2c_slave_receive_handler_08007ff0",
                "hi2c": "i2c_handle",
                "piVar1": "i2c_obj",
                "uVar2": "data_len",
                "i2c_onSlaveReceive": "i2c_on_slave_receive",
                "slaveMode": "slave_mode",
                "handle": "i2c_handle",
                "XferSize": "xfer_size",
                "i2cTxRxBuffer": "i2c_tx_rx_buffer"
            },
            "code": "void i2c_slave_receive_handler_08007ff0(I2C_HandleTypeDef_conflict *i2c_handle) {\n  i2c_t_conflict *i2c_obj = get_i2c_object(i2c_handle);\n  if (i2c_obj->i2c_on_slave_receive != (_func_void_uint8_t_ptr_int *)0x0 && i2c_obj->slave_mode == '\\x01') {\n    uint8_t data_len = 0x20 - *(uint8_t *)&i2c_obj->handle.XferSize & 0xff;\n    if (data_len != 0) {\n      (*i2c_obj->i2c_on_slave_receive)(i2c_obj->i2c_tx_rx_buffer, data_len);\n    }\n  }\n  HAL_I2C_EnableListen_IT(i2c_handle);\n  return;\n}",
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007ff0",
            "calling": [
                "I2C_Slave_AF",
                "I2C_ITError",
                "I2C_Slave_STOPF"
            ],
            "imported": false,
            "current_name": "i2c_slave_receive_handler_08007ff0"
        },
        "FUN_08008078": {
            "renaming": {
                "FUN_08008078": "FUNC_08008078"
            },
            "code": "\nvoid FUNC_08008078(serial_t *obj)\n\n{\n  USART_TypeDef *pUVar1;\n  USART_TypeDef *pUVar2;\n  USART_TypeDef *pUVar3;\n  void *a;\n  void *b;\n  USART_TypeDef *pUVar4;\n  GPIO_TypeDef *pGVar5;\n  uint32_t uVar6;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (obj != (serial_t *)0x0) {\n    a = pinmap_peripheral(obj->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08008330);\n    b = pinmap_peripheral(obj->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08008334);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(PTR_s_ERROR__at_least_one_UART_pin_has_08008348);\n    }\n    else {\n      pUVar4 = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      obj->uart = pUVar4;\n      pUVar3 = DAT_08008340;\n      pUVar2 = DAT_0800833c;\n      pUVar1 = DAT_08008338;\n      if (pUVar4 == (USART_TypeDef *)0x0) {\n        iprintf(PTR_s_ERROR__U_S_ART_pins_mismatch_0800834c);\n      }\n      else {\n        if (pUVar4 == DAT_08008338) {\n          DAT_08008338[0x7b7].BRR = DAT_08008338[0x7b7].BRR | 0x4000;\n          pUVar1[0x7b7].BRR = pUVar1[0x7b7].BRR & 0xffffbfff;\n          pUVar1[0x7b7].CR3 = pUVar1[0x7b7].CR3 | 0x4000;\n          obj->index = '\\0';\n          obj->irq = USART1_IRQn;\n        }\n        else if (pUVar4 == DAT_0800833c) {\n          DAT_0800833c[0x106e].BRR = DAT_0800833c[0x106e].BRR | 0x20000;\n          pUVar2[0x106e].BRR = pUVar2[0x106e].BRR & 0xfffdffff;\n          pUVar2[0x106e].CR3 = pUVar2[0x106e].CR3 | 0x20000;\n          obj->index = '\\x01';\n          obj->irq = USART2_IRQn;\n        }\n        else if (pUVar4 == DAT_08008340) {\n          DAT_08008340[0x1049].CR3 = DAT_08008340[0x1049].CR3 | 0x40000;\n          pUVar3[0x1049].CR3 = pUVar3[0x1049].CR3 & 0xfffbffff;\n          pUVar3[0x104a].DR = pUVar3[0x104a].DR | 0x40000;\n          obj->index = '\\x02';\n          obj->irq = USART3_IRQn;\n        }\n        pGVar5 = set_GPIO_Port_Clock((uint)((int)obj->pin_rx << 0x18) >> 0x1c);\n        uVar6 = pinmap_function(obj->pin_rx,(PinMap_conflict *)PTR_PinMap_UART_RX_08008334);\n        GPIO_InitStruct.Pin = 1 << (obj->pin_rx & 0xfU) & 0xffff;\n        GPIO_InitStruct.Mode = (uVar6 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Pull = (uVar6 << 0x1a) >> 0x1e;\n        *(uint *)(DAT_08008344 + 0x18) = *(uint *)(DAT_08008344 + 0x18) | 1;\n        switch((uVar6 << 0x11) >> 0x19) {\n        case 1:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000001;\n          break;\n        case 2:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000002;\n          break;\n        case 4:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000004;\n          break;\n        case 6:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000008;\n          break;\n        case 8:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          *(uint *)(DAT_08008350 + 4) = *(uint *)(DAT_08008350 + 4) | 0x7000030;\n          break;\n        case 10:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x70000c0;\n          break;\n        case 0xd:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7000300;\n          break;\n        case 0x10:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7000c00;\n          break;\n        case 0x14:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7001000;\n          break;\n        case 0x17:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) | 0x7008000;\n          break;\n        case 0x1c:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff;\n          break;\n        case 0x22:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          *(uint *)(DAT_080084ac + 4) = *(uint *)(DAT_080084ac + 4) & 0xf8ffffff | 0x4000000;\n        }\n        GPIO_InitStruct.Speed = 3;\n        HAL_GPIO_Init(pGVar5,&GPIO_InitStruct);\n        pGVar5 = set_GPIO_Port_Clock((uint)((int)obj->pin_tx << 0x18) >> 0x1c);\n        uVar6 = pinmap_function(obj->pin_tx,(PinMap_conflict *)PTR_PinMap_UART_TX_08008330);\n        GPIO_InitStruct.Pin = 1 << (obj->pin_tx & 0xfU) & 0xffff;\n        GPIO_InitStruct.Mode = (uVar6 >> 3 & 1) << 4 | uVar6 & 7;\n        GPIO_InitStruct.Pull = (uVar6 << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(pGVar5,&GPIO_InitStruct);\n        *(UART_HandleTypeDef **)(PTR_uart_handlers_08008354 + (uint)obj->index * 4) = &obj->handle;\n        (obj->handle).Instance = obj->uart;\n        (obj->handle).Init.BaudRate = obj->baudrate;\n        (obj->handle).Init.WordLength = obj->databits;\n        (obj->handle).Init.StopBits = obj->stopbits;\n        (obj->handle).Init.Parity = obj->parity;\n        (obj->handle).Init.Mode = 0xc;\n        (obj->handle).Init.HwFlowCtl = 0;\n        (obj->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&obj->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "HAL_GPIO_Init",
                "pinmap_function",
                "pinmap_merge_peripheral",
                "pinmap_peripheral",
                "HAL_UART_Init",
                "set_GPIO_Port_Clock",
                "iprintf"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x08008078",
            "calling": [
                "begin",
                "uart_debug_init"
            ],
            "imported": false,
            "current_name": "FUNC_08008078"
        },
        "FUN_08002774": {
            "renaming": {
                "FUN_08002774": "handle_request_08002774",
                "pcVar1": "request_handler",
                "PTR_user_onRequest_0800278c": "user_onRequest",
                "PTR_txBufferIndex_08002790": "tx_buffer_index",
                "PTR_txBufferLength_08002794": "tx_buffer_length"
            },
            "code": "void handle_request_08002774(void)\n{\n  code *request_handler = *(code **)PTR_user_onRequest_0800278c;\n  if (request_handler != NULL) {\n    *PTR_txBufferIndex_08002790 = 0;\n    *PTR_txBufferLength_08002794 = 0;\n    (*request_handler)();\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002774",
            "calling": [],
            "imported": false,
            "current_name": "handle_request_08002774"
        },
        "FUN_080052f0": {
            "renaming": {
                "FUN_080052f0": "check_i2c_errors_080052f0",
                "hi2c": "i2c_handle",
                "HVar1": "state",
                "pIVar2": "i2c_instance",
                "uVar3": "sr1_reg",
                "uVar4": "cr2_reg",
                "DAT_080053c8": "I2C_SR1_ARLO",
                "I2C_Slave_AF": "i2c_slave_af",
                "HAL_I2C_StateTypeDef_conflict": "HAL_I2C_StateTypeDef",
                "I2C_TypeDef_conflict": "I2C_TypeDef",
                "I2C_CR2_AUTOEND": "I2C_CR2_AUTOEND",
                "I2C_ERROR_ARLO": "I2C_ERROR_ARLO",
                "I2C_CLEAR_ARLO_FLAG": "I2C_CLEAR_ARLO_FLAG",
                "I2C_CR1_STOP": "I2C_CR1_STOP",
                "I2C_SR1_ARLO": "I2C_SR1_ARLO",
                "I2C_ERROR_AF": "I2C_ERROR_AF",
                "I2C_CLEAR_AF_FLAG": "I2C_CLEAR_AF_FLAG",
                "I2C_SR1_AF": "I2C_SR1_AF",
                "I2C_SR1_BERR": "I2C_SR1_BERR",
                "I2C_ERROR_BERR": "I2C_ERROR_BERR",
                "I2C_CLEAR_BERR_FLAG": "I2C_CLEAR_BERR_FLAG",
                "I2C_STATE_ADDR": "I2C_STATE_ADDR",
                "I2C_ERROR_OVR": "I2C_ERROR_OVR",
                "I2C_CLEAR_OVR_FLAG": "I2C_CLEAR_OVR_FLAG",
                "HAL_I2C_MODE_SLAVE": "HAL_I2C_MODE_SLAVE",
                "HAL_I2C_MODE_MASTER": "HAL_I2C_MODE_MASTER",
                "HAL_I2C_STATE_BUSY_TX_LISTEN": "HAL_I2C_STATE_BUSY_TX_LISTEN",
                "HAL_I2C_STATE_BUSY_TX": "HAL_I2C_STATE_BUSY_TX",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_STATE_LISTEN",
                "hi2c->Instance": "i2c_handle->Instance",
                "hi2c->ErrorCode": "i2c_handle->ErrorCode",
                "hi2c->XferCount": "i2c_handle->XferCount",
                "hi2c->Mode": "i2c_handle->Mode",
                "hi2c->State": "i2c_handle->State",
                "hi2c->PreviousState": "i2c_handle->PreviousState"
            },
            "code": "void check_i2c_errors_080052f0(I2C_HandleTypeDef_conflict *hi2c) {\n  HAL_I2C_StateTypeDef_conflict state;\n  I2C_TypeDef_conflict *i2c_instance;\n  uint sr1_reg;\n  uint cr2_reg;\n  i2c_instance = hi2c->Instance;\n  sr1_reg = i2c_instance->SR1;\n  cr2_reg = i2c_instance->CR2;\n  if (((sr1_reg & DAT_080053c8) != 0) && ((cr2_reg & I2C_CR2_AUTOEND) != 0)) {\n    hi2c->ErrorCode |= I2C_ERROR_ARLO;\n    i2c_instance->SR1 = I2C_CLEAR_ARLO_FLAG;\n    i2c_instance->CR1 |= I2C_CR1_STOP;\n  }\n  if (((sr1_reg & I2C_SR1_AF) != 0) && ((cr2_reg & I2C_CR2_AUTOEND) != 0)) {\n    hi2c->ErrorCode |= I2C_ERROR_AF;\n    i2c_instance->SR1 = I2C_CLEAR_AF_FLAG;\n  }\n  if (((sr1_reg & I2C_SR1_BERR) != 0) && ((cr2_reg & I2C_CR2_AUTOEND) != 0)) {\n    state = hi2c->State;\n    if (((hi2c->Mode == HAL_I2C_MODE_SLAVE) && (hi2c->XferCount == 0)) && (((state == HAL_I2C_STATE_BUSY_TX) || (state == HAL_I2C_STATE_BUSY_TX_LISTEN)) || ((state == HAL_I2C_STATE_LISTEN) && (hi2c->PreviousState == I2C_STATE_ADDR)))) {\n      I2C_Slave_AF(hi2c);\n    }\n    else {\n      hi2c->ErrorCode |= I2C_ERROR_BERR;\n      if (hi2c->Mode == HAL_I2C_MODE_MASTER) {\n        i2c_instance->CR1 |= I2C_CR1_STOP;\n      }\n      i2c_instance->SR1 = I2C_CLEAR_BERR_FLAG;\n    }\n  }\n  if (((sr1_reg & I2C_SR1_OVR) != 0) && ((cr2_reg & I2C_CR2_AUTOEND) != 0)) {\n    hi2c->ErrorCode |= I2C_ERROR_OVR;\n    i2c_instance->SR1 = I2C_CLEAR_OVR_FLAG;\n  }\n  if (hi2c->ErrorCode != 0) {\n    I2C_ITError(hi2c);\n  }\n  return;\n}",
            "called": [
                "I2C_Slave_AF",
                "I2C_ITError"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080052f0",
            "calling": [
                "I2C1_ER_IRQHandler",
                "I2C2_ER_IRQHandler"
            ],
            "imported": false,
            "current_name": "check_i2c_errors_080052f0"
        },
        "FUN_08002f2c": {
            "renaming": {
                "FUN_08002f2c": "setCallbackFunction_08002f2c",
                "this": "firmataClassInstance",
                "command": "callbackCommand",
                "newFunction": "callbackFunction"
            },
            "code": "void __thiscall firmata::FirmataClass::setCallbackFunction_08002f2c(FirmataClass *this, uint8_t command, callbackFunction newFunction) {\n    if (command == 0xd0) {\n        *(callbackFunction *)PTR_currentReportDigitalCallback_08002f78 = newFunction;\n        return;\n    }\n    if (0xd0 < command) {\n        if (command == 0xf4) {\n            *(callbackFunction *)PTR_currentPinModeCallback_08002f7c = newFunction;\n            return;\n        }\n        if (command == 0xf5) {\n            *(callbackFunction *)PTR_currentPinValueCallback_08002f80 = newFunction;\n        } else if (command == 0xe0) {\n            *(callbackFunction *)PTR_currentAnalogCallback_08002f6c = newFunction;\n            return;\n        }\n        return;\n    }\n    if (command == 0x90) {\n        *(callbackFunction *)PTR_currentDigitalCallback_08002f74 = newFunction;\n        return;\n    }\n    if (command == 0xc0) {\n        *(callbackFunction *)PTR_currentReportAnalogCallback_08002f70 = newFunction;\n        return;\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f2c",
            "calling": [
                "setup"
            ],
            "imported": false,
            "current_name": "setCallbackFunction_08002f2c"
        },
        "FUN_08004954": {
            "renaming": {
                "FUN_08004954": "i2c_listen_08004954",
                "hi2c": "handle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "options",
                "HVar1": "status",
                "pIVar2": "instance",
                "tmpreg": "tmp_reg"
            },
            "code": "HAL_StatusTypeDef_conflict i2c_listen_08004954(I2C_HandleTypeDef_conflict *handle, uint8_t *data, uint16_t size, uint32_t options) {\n  HAL_StatusTypeDef_conflict status;\n  I2C_TypeDef_conflict *instance;\n  uint32_t tmp_reg;\n  \n  if (handle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == NULL || size == 0 || handle->Lock == HAL_LOCKED) {\n      status = HAL_ERROR;\n    }\n    else {\n      handle->Lock = HAL_LOCKED;\n      instance = handle->Instance;\n      if ((instance->CR1 & 1) == 0) {\n        instance->CR1 |= 1;\n      }\n      instance->CR1 &= 0xfffff7ff;\n      handle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      handle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      handle->ErrorCode = 0;\n      handle->pBuffPtr = data;\n      handle->XferCount = size;\n      handle->XferOptions = options;\n      handle->XferSize = handle->XferCount;\n      handle->Lock = HAL_UNLOCKED;\n      instance->CR2 |= 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004954",
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "imported": false,
            "current_name": "i2c_listen_08004954"
        },
        "FUN_08005cec": {
            "renaming": {
                "FUN_08005cec": "configure_timer_08005cec",
                "TIMx": "timer",
                "OC_Config": "output_channel_config",
                "uVar1": "cc_enabled_and_polarity",
                "uVar2": "cr2",
                "uVar3": "oc_mode",
                "DAT_08005d44": "PTR_08005d44"
            },
            "code": "void configure_timer_08005cec(TIM_TypeDef_conflict *timer, TIM_OC_InitTypeDef *output_channel_config)\n{\n  uint32_t cc_enabled_mask = 0xfffffffe;\n  uint32_t cr2 = timer->CR2;\n  uint32_t oc_mode = output_channel_config->OCMode;\n  uint32_t cc_enabled_and_polarity = (timer->CCER & 0xfffffffd) | output_channel_config->OCPolarity;\n  if (timer == DAT_08005d44) {\n    cc_enabled_and_polarity = (cc_enabled_and_polarity & 0xfffffff7 | output_channel_config->OCNPolarity) & 0xfffffffb;\n    cr2 = (cr2 & 0xfffffcff) | output_channel_config->OCIdleState | output_channel_config->OCNIdleState;\n  }\n  timer->CR2 = cr2;\n  timer->CCMR1 = (timer->CCMR1 & 0xffffff8c) | oc_mode;\n  timer->CCR1 = output_channel_config->Pulse;\n  timer->CCER = cc_enabled_and_polarity;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005cec",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_08005cec"
        },
        "FUN_08003748": {
            "renaming": {
                "FUN_08003748": "update_uwTick_08003748",
                "PTR_uwTick_08003758": "uwTick",
                "PTR_uwTickFreq_0800375c": "uwTickFreq"
            },
            "code": "void update_uwTick_08003748(void)\n{\n  uint8_t tickFreq = *PTR_PTR_uwTick_08003758Freq_0800375c;\n  uint32_t* tick = PTR_uwTick_08003758;\n  *tick = tickFreq + *tick;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003748",
            "calling": [
                "SysTick_Handler"
            ],
            "imported": false,
            "current_name": "update_uwTick_08003748"
        },
        "FUN_080040e8": {
            "renaming": {
                "FUN_080040e8": "configure_gpio_pins_080040e8",
                "GPIOx": "gpio_port",
                "GPIO_Init": "gpio_init",
                "pGVar1": "gpio_port",
                "uVar2": "temp_var_1",
                "uVar3": "pin_mask",
                "uVar4": "pin_mask_result",
                "uVar5": "pin_index",
                "uVar6": "gpio_mode",
                "uVar7": "config_value",
                "iVar8": "shift_amount",
                "uVar9": "temp_var_2",
                "iVar10": "reg_index",
                "tmpreg": "temp_reg",
                "DAT_080042bc": "EXTI_BASE",
                "DAT_080042c0": "AFIO_BASE",
                "DAT_080042c4": "AFIO_EXTICR1_OFFSET",
                "DAT_080042c8": "GPIO_MODE_IT_RISING",
                "DAT_080042cc": "GPIO_MODE_IT_EVT_MASK",
                "DAT_080042d0": "GPIOA"
            },
            "code": "void configure_gpio_pins_080040e8(GPIO_TypeDef *gpio_port, GPIO_InitTypeDef *gpio_init)\n{\n    uint32_t pin_mask = 0;\n    uint8_t pin_index = 0;\n    uint32_t crl_mask = 0;\n    uint32_t config_value = 0;\n    uint32_t speed_offset = 0;\n    \n    while (pin_index < 16) {\n        pin_mask = 1 << pin_index;\n        if ((gpio_init->Pin & pin_mask) == pin_mask) {\n            switch (gpio_init->Mode) {\n                case GPIO_MODE_INPUT:\n                    config_value = GPIO_CNF_INPUT_FLOAT;\n                    break;\n                case GPIO_MODE_OUTPUT_PP:\n                    config_value = GPIO_CNF_OUTPUT_PUSHPULL;\n                    break;\n                case GPIO_MODE_OUTPUT_OD:\n                    config_value = GPIO_CNF_OUTPUT_OPENDRAIN;\n                    break;\n                case GPIO_MODE_AF_PP:\n                    config_value = GPIO_CNF_ALT_OUTPUT_PUSHPULL;\n                    break;\n                case GPIO_MODE_AF_OD:\n                    config_value = GPIO_CNF_ALT_OUTPUT_OPENDRAIN;\n                    break;\n                default:\n                    return;\n            }\n            \n            if (gpio_init->Pull == GPIO_NOPULL) {\n                speed_offset = GPIO_MODE_SPEED_LOW;\n            }\n            else if (gpio_init->Pull == GPIO_PULLUP) {\n                gpio_port->BSRR = pin_mask;\n                speed_offset = GPIO_MODE_SPEED_LOW;\n            }\n            else {\n                gpio_port->BRR = pin_mask;\n                speed_offset = GPIO_MODE_SPEED_LOW;\n            }\n            \n            if (pin_index < 8) {\n                crl_mask = 0x0F << (pin_index * 4);\n                gpio_port->CRL = (gpio_port->CRL & ~crl_mask) | (config_value << (pin_index * 4));\n            }\n            else {\n                crl_mask = 0x0F << ((pin_index - 8) * 4);\n                gpio_port->CRH = (gpio_port->CRH & ~crl_mask) | (config_value << ((pin_index - 8) * 4));\n            }\n            \n            if ((gpio_init->Mode & GPIO_MODE_ANALOG) == 0) {\n                uint32_t reg_index = pin_index / 4;\n                uint32_t shift_amount = (pin_index % 4) * 4;\n                uint32_t clear_mask = 0xF << shift_amount;\n                uint32_t set_value = 0;\n                if ((gpio_init->Mode & DAT_080042c8) != 0) {\n                    *(uint32_t *)(DAT_080042bc + EXTI_RTSR_OFFSET) |= pin_mask;\n                }\n                if ((gpio_init->Mode & GPIO_MODE_IT_FALLING) != 0) {\n                    *(uint32_t *)(DAT_080042bc + EXTI_FTSR_OFFSET) |= pin_mask;\n                }\n                if ((gpio_init->Mode & GPIO_MODE_EVT_RISING) != 0) {\n                    *(uint32_t *)(DAT_080042bc + EXTI_RTSR_OFFSET) |= pin_mask;\n                    *(uint32_t *)(DAT_080042bc + EXTI_EMR_OFFSET) |= pin_mask;\n                }\n                if ((gpio_init->Mode & GPIO_MODE_EVT_FALLING) != 0) {\n                    *(uint32_t *)(DAT_080042bc + EXTI_FTSR_OFFSET) |= pin_mask;\n                    *(uint32_t *)(DAT_080042bc + EXTI_EMR_OFFSET) |= pin_mask;\n                }\n                if ((gpio_init->Mode & GPIO_MODE_EVT_RISING_FALLING) != 0) {\n                    *(uint32_t *)(DAT_080042bc + EXTI_RTSR_OFFSET) |= pin_mask;\n                    *(uint32_t *)(DAT_080042bc + EXTI_FTSR_OFFSET) |= pin_mask;\n                    *(uint32_t *)(DAT_080042bc + EXTI_EMR_OFFSET) |= pin_mask;\n                }\n                if ((gpio_init->Mode & DAT_080042cc) != 0) {\n                    set_value = (gpio_init->Mode & DAT_080042cc) >> 16;\n                    set_value = set_value << shift_amount;\n                    *(uint32_t *)(DAT_080042c0 + DAT_080042c4 + (reg_index * 4)) = (*(uint32_t *)(DAT_080042c0 + DAT_080042c4 + (reg_index * 4)) & ~clear_mask) | set_value;\n                }\n            }\n        }\n        \n        pin_index++;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080040e8",
            "calling": [
                "HAL_ADC_MspInit",
                "digital_io_init",
                "HAL_TIM_PWM_MspInit",
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "configure_gpio_pins_080040e8"
        },
        "FUN_08009b6c": {
            "renaming": {
                "FUN_08009b6c": "decode_08009b6c",
                "param_1": "input",
                "param_2": "params",
                "iVar1": "temp_int_1",
                "piVar2": "temp_int_ptr",
                "uVar3": "temp_uint_1",
                "uVar4": "temp_uint_2",
                "iVar5": "temp_int_2",
                "pcVar6": "function_ptr",
                "iVar7": "temp_int_3",
                "bVar9": "flag"
            },
            "code": "uint32_t decode_08009b6c(uint32_t *input, int *params)\n{\n  uint32_t uVar1;\n  uint16_t uVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  uint32_t uVar8;\n  bool flag;\n  code *function_ptr;\n  iVar6 = *(int *)(params + 3);\n  uVar2 = *(uint16_t *)(params + 3);\n  uVar1 = (uint32_t)uVar2;\n  if ((int)(uVar1 << 0x1c) < 0) {\n    iVar3 = params[4];\n    if (iVar3 != 0) {\n      iVar5 = uVar1 << 0x1e;\n      flag = iVar5 == 0;\n      if (flag) {\n        iVar5 = 0;\n      }\n      iVar7 = *params;\n      if (!flag) {\n        iVar5 = params[5];\n      }\n      *params = iVar3;\n      params[2] = iVar5;\n      for (iVar7 = iVar7 - iVar3; 0 < iVar7; iVar7 = iVar7 - iVar5) {\n        iVar5 = (*(code *)params[10])(input,params[8],iVar3,iVar7);\n        if (iVar5 < 1) {\n          uVar2 = *(uint16_t *)(params + 3);\n          goto LAB_08009c62;\n        }\n        iVar3 = iVar3 + iVar5;\n      }\n    }\n  }\n  else if (((0 < params[1]) || (0 < params[0x10])) &&\n          (function_ptr = (code *)params[0xb], function_ptr != (code *)0x0)) {\n    uVar8 = *input;\n    *input = 0;\n    if ((uVar2 & 0x1000) == 0) {\n      iVar3 = (*function_ptr)(input,params[8],uVar1 & 0x1000,1);\n      if ((iVar3 == -1) && (uVar1 = *input, uVar1 != 0)) {\n        if ((uVar1 != 0x1d) && (uVar1 != 0x16)) {\n          *(uint16_t *)(params + 3) = *(uint16_t *)(params + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *input = uVar8;\n        return 0;\n      }\n    }\n    else {\n      iVar3 = params[0x15];\n    }\n    if (((int)((uint)*(uint16_t *)(params + 3) << 0x1d) < 0) &&\n       (iVar3 = iVar3 - params[1], params[0xd] != 0)) {\n      iVar3 = iVar3 - params[0x10];\n    }\n    iVar3 = (*(code *)params[0xb])(input,params[8],iVar3,0);\n    uVar2 = *(uint16_t *)(params + 3);\n    if ((iVar3 == -1) &&\n       ((0x1d < *input || (-1 < (int)((DAT_08009c78 >> (*input & 0xff)) << 0x1f))))) {\nLAB_08009c62:\n      *(uint16_t *)(params + 3) = uVar2 | 0x40;\n      return 0xffffffff;\n    }\n    params[1] = 0;\n    *params = params[4];\n    if (((int)((uint)uVar2 << 0x13) < 0) && ((iVar3 != -1 || (*input == 0)))) {\n      params[0x15] = iVar3;\n    }\n    iVar4 = *(int *)(params + 0xd);\n    *input = uVar8;\n    if (iVar4 != 0) {\n      if (iVar4 != params + 0x11) {\n        free(input);\n      }\n      params[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009b6c",
            "calling": [
                "_fflush_r"
            ],
            "imported": false,
            "current_name": "decode_08009b6c"
        },
        "FUN_0800288c": {
            "renaming": {
                "TwoWire::FUN_0800288c": "transmitData",
                "this": "wire",
                "data": "localData",
                "puVar1": "txBuffer",
                "iVar2": "status",
                "pvVar3": "newBuffer",
                "sVar4": "transmitted",
                "cVar5": "updatedIndex",
                "uVar6": "bufferSize",
                "__size": "bufferSize",
                "local_11": "localData",
                "*PTR_txBuffer_08002914": "*txBuffer",
                "*PTR_transmitting_08002908": "*transmitting",
                "i2c_slave_FUN_0800288c_IT": "i2c_slave_transmit",
                "(i2c_t_conflict *)&this->_i2c": "&wire->_i2c",
                "PTR_txBufferLength_0800290c": "txBufferLength",
                "PTR_txBufferAllocated_08002910": "txBufferAllocated",
                "PTR_txBufferIndex_08002918": "txBufferIndex",
                "*(int *)PTR_txBuffer_08002914": "txBufferPtr",
                "FUN_0800288c": "transmitData_0800288c"
            },
            "code": "size_t __thiscall transmitData_0800288c(TwoWire *wire, uint8_t data) {\\n  undefined *PTR_txBuffer_08002914 = PTR_txBuffer_08002914;\\n  uint8_t localData = data;\\n  if (*PTR_transmitting_08002908 == \"\\0\") {\\n    i2c_status_e_conflict status = i2c_slave_transmit((i2c_t_conflict *)&wire->_i2c,&localData,1);\\n    return status == I2C_OK ? 1 : 0;\\n  }\\n  else {\\n    size_t bufferSize = (byte)*PTR_PTR_txBufferLength_0800290c_0800290c + 1;\\n    if ((byte)*PTR_PTR_txBufferAllocated_08002910_08002910 < bufferSize) {\\n      if (bufferSize < 0x20) {\\n        bufferSize = 0x20;\\n      }\\n      void *newBuffer = realloc(*(void **)PTR_txBuffer_08002914, bufferSize);\\n      *(void **)txBuffer = newBuffer;\\n      *PTR_PTR_txBufferAllocated_08002910_08002910 = newBuffer == (void *)0x0 ? 0 : (undefined)bufferSize;\\n    }\\n    undefined *PTR_txBufferIndex_08002918 = PTR_PTR_txBufferIndex_08002918_08002918;\\n    if (*(int *)PTR_txBuffer_08002914 == 0) {\\n      (wire->super_Stream).super_Print.transmitData_0800288c_error = 1;\\n      return 0;\\n    }\\n    *(uint8_t *)(*(int *)PTR_txBuffer_08002914 + (uint)(byte)*PTR_txBufferIndex_08002918) = localData;\\n    char updatedIndex = *PTR_txBufferIndex_08002918 + \"\\x01\";\\n    *PTR_txBufferIndex_08002918 = updatedIndex;\\n    *PTR_PTR_txBufferLength_0800290c_0800290c = updatedIndex;\\n    return 1;\\n  }\\n}",
            "called": [
                "i2c_slave_write_IT",
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800288c",
            "calling": [
                "wireWrite"
            ],
            "imported": false,
            "current_name": "transmitData_0800288c"
        },
        "FUN_08002e26": {
            "renaming": {
                "FUN_08002e26": "initializeFirmata_08002e26",
                "this": "firmataInstance",
                "s": "firmataStream",
                "FirmataStream": "firmataStream",
                "FirmataMarshaller::FUN_08002e26": "initializeMarshaller",
                "printVersion": "printFirmataVersion",
                "printFirmwareVersion": "printFirmwareVersion"
            },
            "code": "void __thiscall firmata::FirmataClass::initializeFirmata_08002e26(Stream *firmataStream)\n{\n  this->FirmataStream = firmataStream;\n  FirmataMarshaller::initializeMarshaller(&this->marshaller, firmataStream);\n  printFirmataVersion(this);\n  printFirmwareVersion(this);\n  return;\n}",
            "called": [
                "printVersion",
                "begin",
                "printFirmwareVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002e26",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "initializeFirmata_08002e26"
        },
        "FUN_0800010c": {
            "renaming": {
                "FUN_0800010c": "isInitializationComplete_0800010c",
                "param_1": "initializationArray",
                "*PTR_completed_8667_08000124": "*isCompleted",
                "DAT_08000128": "*initValue",
                "PTR__init_0800012c": "initializationArray"
            },
            "code": "bool isInitializationComplete_0800010c(bool *PTR_completed_8667_08000124, int DAT_08000128, char *initArray) {\n  if (*PTR_completed_8667_08000124 == false) {\n    if (DAT_08000128 != 0) {\n      initArray = PTR__init_0800012c;\n    }\n    *PTR_completed_8667_08000124 = true;\n  }\n  return initArray;\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800010c",
            "calling": [],
            "imported": false,
            "current_name": "isInitializationComplete_0800010c"
        },
        "FUN_080086e8": {
            "renaming": {
                "FUN_080086e8": "get_uart_handler_index_080086e8",
                "huart": "uart_handler",
                "uVar1": "index"
            },
            "code": "uint8_t get_uart_handler_index_080086e8(UART_HandleTypeDef *uart_handler)\n{\n  uint8_t index;\n  if (uart_handler == NULL) {\n    index = 5;\n  }\n  else {\n    index = 0;\n    while(1) {\n      if (index > 4) {\n        return index;\n      }\n      if (uart_handler == *(UART_HandleTypeDef **)(PTR_uart_handlers_08008708 + index * 4)) {\n        break;\n      }\n      index = (index + 1) % 256;\n    }\n  }\n  return index;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080086e8",
            "calling": [
                "HAL_UART_TxCpltCallback",
                "HAL_UART_RxCpltCallback"
            ],
            "imported": false,
            "current_name": "get_uart_handler_index_080086e8"
        },
        "FUN_08001c18": {
            "renaming": {
                "FUN_08001c18": "readI2CDataFromAddress_08001c18",
                "address": "deviceAddress",
                "theRegister": "registerAddress",
                "numBytes": "numBytesToRead",
                "stopTX": "stopTransmission",
                "bVar1": "dataAvailable",
                "puVar2": "wirePointer",
                "bVar3": "byteRead",
                "iVar4": "bytesRead",
                "iVar5": "bytesAvailable",
                "uVar6": "numBytes"
            },
            "code": "void readI2CDataFromAddress_08001c18(byte address, int registerAddress, byte numBytesToRead, byte stopTX)\n{\n  bool dataAvailable;\n  undefined *wirePointer;\n  byte byteRead;\n  int bytesRead = 0;\n  int bytesAvailable;\n  uint numBytes = (uint)numBytesToRead;\n  if (registerAddress == -1) {\n    registerAddress = 0;\n  }\n  else {\n    TwoWire::beginTransmission((TwoWire *)PTR_Wire_08001cbc,address);\n    wireWrite((byte)registerAddress);\n    TwoWire::endTransmission((TwoWire *)PTR_Wire_08001cbc,stopTX);\n  }\n  wirePointer = PTR_Wire_08001cbc;\n  TwoWire::requestFrom((TwoWire *)PTR_Wire_08001cbc,address,numBytes);\n  bytesAvailable = TwoWire::available((TwoWire *)wirePointer);\n  if ((int)numBytes < bytesAvailable) {\n    firmata::FirmataClass::sendString((FirmataClass *)PTR_Firmata_08001cc4,PTR_s_I2C__Too_many_bytes_received_08001cc0);\n  }\n  else {\n    bytesAvailable = TwoWire::available((TwoWire *)PTR_Wire_08001cbc);\n    if (bytesAvailable < (int)numBytes) {\n      firmata::FirmataClass::sendString((FirmataClass *)PTR_Firmata_08001cc4,PTR_s_I2C__Too_few_bytes_received_08001ccc);\n    }\n  }\n  *PTR_i2cRxData_08001cc8 = address;\n  *(PTR_i2cRxData_08001cc8 + 1) = (char)registerAddress;\n  while(bytesRead < (int)numBytes) {\n    bytesAvailable = TwoWire::available((TwoWire *)PTR_Wire_08001cbc);\n    if (bytesAvailable == 0) {\n      dataAvailable = false;\n    }\n    else {\n      dataAvailable = true;\n    }\n    if (!dataAvailable) break;\n    byteRead = wireRead();\n    *(PTR_i2cRxData_08001cc8 + bytesRead + 2) = byteRead;\n    bytesRead = bytesRead + 1;\n  }\n  firmata::FirmataClass::sendSysex((FirmataClass *)PTR_Firmata_08001cc4,'w',numBytesToRead + '\\x02',PTR_i2cRxData_08001cc8);\n  return;\n}",
            "called": [
                "beginTransmission",
                "endTransmission",
                "available",
                "wireWrite",
                "wireRead",
                "sendString",
                "sendSysex",
                "requestFrom"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08001c18",
            "calling": [
                "loop",
                "sysexCallback"
            ],
            "imported": false,
            "current_name": "readI2CDataFromAddress_08001c18"
        },
        "FUN_08009056": {
            "renaming": {
                "FUN_08009056": "handle_gpio_exti_irq_08009056",
                "uVar1": "gpio_pin"
            },
            "code": "void handle_gpio_exti_irq_08009056(void)\n{\n  uint16_t gpio_pin = 0x20;\n  while(gpio_pin < 0x201)\n  {\n    HAL_GPIO_EXTI_IRQHandler(gpio_pin);\n    gpio_pin <<= 1;\n  }\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009056",
            "calling": [],
            "imported": false,
            "current_name": "handle_gpio_exti_irq_08009056"
        },
        "FUN_08002e1a": {
            "renaming": {
                "<original_function_name>": "FUN_08002e1a",
                "<original_parameter_name_1>": "context",
                "<original_parameter_name_2>": "param_2",
                "<original_parameter_name_3>": "param_3",
                "<original_parameter_name_4>": "param_4",
                "<original_variable_name_1>": "nullptr",
                "<original_variable_name_2>": "printFirmwareVersion",
                "<original_variable_name_3>": "FirmataClass",
                "<original_variable_name_4>": "static_cast",
                "FUN_08002e1a": "printFirmwareVersionIfContextNotNull_08002e1a"
            },
            "code": "void firmata::FirmataClass::printFirmwareVersionIfContextNotNull_08002e1a(void *context, size_t sizeOfParam2, size_t sizeOfParam3, char *param4) {\n                      if (context != nullptr) {\n                        printFirmwareVersion(static_cast<FirmataClass *>(context));\n                      }\n                    }",
            "called": [
                "printFirmwareVersion"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002e1a",
            "calling": [],
            "imported": false,
            "current_name": "printFirmwareVersionIfContextNotNull_08002e1a"
        },
        "FUN_0800904c": {
            "renaming": {
                "FUN_0800904c": "handle_ext_interrupt_0800904c",
                "PTR_": "PTR_ (unchanged)",
                "DAT_": "DAT_ (unchanged)"
            },
            "code": "void handle_ext_interrupt_0800904c(void)\n{\n  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);\n  return;\n}",
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800904c",
            "calling": [],
            "imported": false,
            "current_name": "handle_ext_interrupt_0800904c"
        },
        "FUN_080073ae": {
            "renaming": {
                "FUN_080073ae": "find_non_null_080073ae",
                "a": "first",
                "b": "second"
            },
            "code": "void * find_non_null_080073ae(void *first, void *second) {\n  if (first != second) {\n    if (first == NULL) {\n      return second;\n    }\n    if (second == NULL) {\n      return first;\n    }\n    first = NULL;\n  }\n  return first;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073ae",
            "calling": [
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "find_non_null_080073ae"
        },
        "FUN_08003f0c": {
            "renaming": {
                "FUN_08003f0c": "set_priority_group_08003f0c",
                "PriorityGroup": "priority_group",
                "PTR_DAT_08003f2c": "priority_reg",
                "DAT_08003f2c": "priority_reg_address",
                "priority_mask": "priority_mask",
                "priority_shift": "priority_shift",
                "priority_value": "priority_value"
            },
            "code": "void set_priority_group_08003f0c(uint32_t priority_group) {\n    uint32_t* PTR_DAT_08003f2c = (uint32_t*)(DAT_08003f2c + 0xc);\n    uint32_t priority_mask = 0xf8ff;\n    uint32_t priority_shift = 8;\n    uint32_t priority_value = 0x5fa0000;\n    *PTR_DAT_08003f2c = (*PTR_DAT_08003f2c & priority_mask) | ((priority_group & 7) << priority_shift) | priority_value;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003f0c",
            "calling": [
                "HAL_Init",
                "premain"
            ],
            "imported": false,
            "current_name": "set_priority_group_08003f0c"
        },
        "FUN_08000488": {
            "renaming": {
                "FUN_08000488": "reportAnalogInput_08000488",
                "analogPin": "analog_pin",
                "value": "value",
                "ulPin": "pin_number",
                "value_00": "analog_value",
                "PTR_analogInputsToReport_080004c8": "analogInputsToReport",
                "PTR_isResetting_080004cc": "isResetting",
                "PTR_Firmata_080004d0": "Firmata"
            },
            "code": "void reportAnalogInput_08000488(byte analog_pin, int value)\n{\n\tuint pin_number;\n\tuint32_t analog_value;\n\t\n\tpin_number = (uint)analog_pin;\n\tif (pin_number < 0xe) {\n\t\tif (value == 0) {\n\t\t\tPTR_analogInputsToReport_080004c8 &= ~(1 << pin_number);\n\t\t\treturn;\n\t\t}\n\t\tPTR_analogInputsToReport_080004c8 |= 1 << pin_number;\n\t\tif (!PTR_isResetting_080004cc) {\n\t\t\tanalog_value = analogRead(pin_number);\n\t\t\tfirmata::PTR_Firmata_080004d0Class::sendAnalog(&PTR_Firmata_080004d0, analog_pin, analog_value);\n\t\t\treturn;\n\t\t}\n\t}\n\treturn;\n}",
            "called": [
                "sendAnalog",
                "analogRead"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08000488",
            "calling": [
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "reportAnalogInput_08000488"
        },
        "FUN_08006bb8": {
            "renaming": {
                "FUN_08006bb8": "get_GPIO_08006bb8",
                "port_idx": "port_index",
                "pGVar1": "gpio_type",
                "tmpreg": "register_value",
                "tmpreg_1": "bit_mask",
                "tmpreg_2": "register_address",
                "tmpreg_3": "register_value",
                "tmpreg_4": "register_value",
                "DAT_08006c48": "register_address",
                "DAT_08006c4c": "GPIO_TypeDef_0",
                "DAT_08006c50": "GPIO_TypeDef_1",
                "DAT_08006c54": "GPIO_TypeDef_2",
                "DAT_08006c58": "GPIO_TypeDef_3",
                "DAT_08006c5c": "GPIO_TypeDef_4"
            },
            "code": "GPIO_TypeDef * get_GPIO_08006bb8(uint32_t port_idx)\n{\n  GPIO_TypeDef *gpio_type;\n  uint32_t register_value;\n  uint32_t bit_mask;\n  uint32_t* DAT_08006c48 = (uint32_t *)(0x08006c48 + 0x18);\n  switch(port_idx) {\n  case 0:\n    bit_mask = 4;\n    gpio_type = (GPIO_TypeDef*)0x08006c4c;\n    break;\n  case 1:\n    bit_mask = 8;\n    gpio_type = (GPIO_TypeDef*)0x08006c50;\n    break;\n  case 2:\n    bit_mask = 0x10;\n    gpio_type = (GPIO_TypeDef*)0x08006c54;\n    break;\n  case 3:\n    bit_mask = 0x20;\n    gpio_type = (GPIO_TypeDef*)0x08006c58;\n    break;\n  case 4:\n    bit_mask = 0x40;\n    gpio_type = (GPIO_TypeDef*)0x08006c5c;\n    break;\n  default:\n    gpio_type = (GPIO_TypeDef*)0x0;\n    return gpio_type;\n  }\n  register_value = *DAT_08006c48;\n  register_value |= bit_mask;\n  *DAT_08006c48 = register_value;\n  return gpio_type;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006bb8",
            "calling": [
                "HAL_ADC_MspInit",
                "digital_io_init",
                "HAL_TIM_PWM_MspInit",
                "uart_init",
                "i2c_custom_init"
            ],
            "imported": false,
            "current_name": "get_GPIO_08006bb8"
        },
        "FUN_08004aec": {
            "renaming": {
                "FUN_08004aec": "handle_I2C_events_08004aec",
                "*hi2c": "*handle_I2C",
                "XferOptions": "transfer_options",
                "State": "state",
                "PreviousState": "previous_state",
                "Mode": "mode",
                "Instance": "instance",
                "CR2": "control_register_2",
                "SR1": "status_register_1",
                "CR1": "control_register_1",
                "HAL_I2C_STATE_LISTEN": "HAL_I2C_STATE_LISTEN",
                "DAT_08004b7c": "DAT_08004b7c",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_READY",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NONE",
                "HAL_I2C_STATE_BUSY_TX": "HAL_I2C_STATE_BUSY_TX",
                "HAL_I2C_ListenCpltCallback": "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveTxCpltCallback": "HAL_I2C_SlaveTxCpltCallback"
            },
            "code": "HAL_StatusTypeDef_conflict handle_I2C_events_08004aec(I2C_HandleTypeDef_conflict *hi2c) {\n    if (((hi2c->transfer_options == I2C_TRANSFER_OPTIONS_RX) || (hi2c->transfer_options == I2C_TRANSFER_OPTIONS_TX)) && (hi2c->state == HAL_I2C_STATE_LISTEN)) {\n        hi2c->transfer_options = DAT_08004b7c;\n        hi2c->instance->CR2 &= 0xfffff8ff;\n        hi2c->instance->SR1 = 0xfffffbff;\n        hi2c->instance->CR1 &= 0xfffffbff;\n        hi2c->previous_state = 0;\n        hi2c->state = HAL_I2C_STATE_READY;\n        hi2c->mode = HAL_I2C_MODE_NONE;\n        HAL_I2C_ListenCpltCallback(hi2c);\n    }\n    else if (hi2c->state == HAL_I2C_STATE_BUSY_TX) {\n        hi2c->transfer_options = DAT_08004b7c;\n        hi2c->previous_state = 0x21;\n        hi2c->state = HAL_I2C_STATE_READY;\n        hi2c->mode = HAL_I2C_MODE_NONE;\n        hi2c->instance->CR2 &= 0xfffff8ff;\n        hi2c->instance->SR1 = 0xfffffbff;\n        hi2c->instance->CR1 &= 0xfffffbff;\n        HAL_I2C_SlaveTxCpltCallback(hi2c);\n    }\n    else {\n        hi2c->instance->SR1 = 0xfffffbff;\n    }\n    return HAL_OK;\n}",
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004aec",
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "imported": false,
            "current_name": "handle_I2C_events_08004aec"
        },
        "FUN_08007ede": {
            "renaming": {
                "FUN_08007ede": "write_i2c_data_08007ede",
                "obj": "i2c_obj",
                "data": "data",
                "size": "size",
                "uVar1": "index",
                "I2C_ERROR": "I2C_ERROR",
                "I2C_OK": "I2C_OK",
                "i2cTxRxBuffer": "i2c_obj->i2cTxRxBuffer",
                "i2cTxRxBufferSize": "i2c_obj->i2cTxRxBufferSize"
            },
            "code": "i2c_status_e write_i2c_data_08007ede(i2c_t_conflict *i2c_obj, uint8_t *data, uint16_t size)\n{\n  uint16_t index;\n  if (size > 32)\n  {\n    return I2C_ERROR;\n  }\n  for (index = 0; index < size; index++)\n  {\n    i2c_obj->i2cTxRxBuffer[index] = data[index];\n    i2c_obj->i2cTxRxBufferSize++;\n  }\n  return I2C_OK;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007ede",
            "calling": [
                "write",
                "write"
            ],
            "imported": false,
            "current_name": "write_i2c_data_08007ede"
        },
        "FUN_08004728": {
            "renaming": {
                "FUN_08004728": "transmitData_08004728",
                "hi2c": "i2c_handle",
                "DevAddress": "device_address",
                "pData": "data",
                "Size": "size",
                "HVar1": "status",
                "pIVar2": "i2c_instance",
                "count": "count",
                "DAT_080047ec": "count_delay_080047ec",
                "PTR_SystemCoreClock_080047e8": "system_core_clock_ptr_080047e8",
                "DAT_080047f0": "data_xfer_options_080047f0"
            },
            "code": "HAL_StatusTypeDef_conflict transmitData_08004728(I2C_HandleTypeDef_conflict *i2c_handle, uint16_t device_address, uint8_t *data, uint16_t size)\n{\n  HAL_StatusTypeDef_conflict status = HAL_OK;\n  I2C_TypeDef_conflict *i2c_instance = i2c_handle->Instance;\n  uint32_t count = (uint)((ulonglong)DAT_080047ec * (ulonglong)(*(uint *)PTR_SystemCoreClock_080047e8 >> 3) >> 0x28) * 0x19;\n  if (i2c_handle->State == HAL_I2C_STATE_READY) {\n    do {\n      if (count == 0) {\n        i2c_handle->PreviousState = 0;\n        i2c_handle->State = HAL_I2C_STATE_READY;\n        i2c_handle->Lock = HAL_UNLOCKED;\n        status = HAL_TIMEOUT;\n        break;\n      }\n      count--;\n    } while ((i2c_instance->SR2 & 2) != 0);\n    if (i2c_handle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2c_handle->Lock = HAL_LOCKED;\n      if ((i2c_instance->CR1 & 1) == 0) {\n        i2c_instance->CR1 |= 1;\n      }\n      i2c_handle->Instance->CR1 &= 0xfffff7ff;\n      i2c_handle->State = HAL_I2C_STATE_BUSY_TX;\n      i2c_handle->Mode = HAL_I2C_MODE_MASTER;\n      i2c_handle->ErrorCode = 0;\n      i2c_handle->pBuffPtr = data;\n      i2c_handle->XferCount = size;\n      i2c_handle->XferOptions = DAT_080047f0;\n      i2c_handle->XferSize = i2c_handle->XferCount;\n      i2c_handle->Devaddress = (uint)device_address;\n      i2c_instance->CR1 |= 0x100;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      i2c_instance->CR2 |= 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004728",
            "calling": [
                "i2c_master_write"
            ],
            "imported": false,
            "current_name": "transmitData_08004728"
        },
        "FUN_080074e0": {
            "renaming": {
                "FUN_080074e0": "clearTimerInterruptFlag_080074e0",
                "htim": "timer_handle",
                "Instance": "timer_instance",
                "DAT_08007534": "TIMER_1",
                "DAT_08007538": "TIMER_3",
                "DAT_0800753c": "TIMER_4",
                "TIM_TypeDef_conflict": "Timer_TypeDef",
                "uint": "uint32_t",
                "DAT_08007540": "TIMER_INTERRUPT_FLAG_ADDRESS"
            },
            "code": "void clearTimerInterruptFlag_080074e0(TIM_HandleTypeDef_conflict *timer_handle)\n{\n    if (timer_handle->Instance == DAT_08007534) {\n        *(uint *)(DAT_08007540 + 0x18) &= 0xfffff7ff;\n    }\n    if (timer_handle->Instance == TIMER_2) {\n        *(uint *)(DAT_08007540 + 0x1c) &= 0xfffffffe;\n    }\n    if (timer_handle->Instance == DAT_08007538) {\n        *(uint *)(DAT_08007540 + 0x1c) &= 0xfffffffd;\n    }\n    if (timer_handle->Instance == DAT_0800753c) {\n        *(uint *)(DAT_08007540 + 0x1c) &= 0xfffffffb;\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080074e0",
            "calling": [
                "HAL_TIM_PWM_MspDeInit",
                "HAL_TIM_OC_MspDeInit"
            ],
            "imported": false,
            "current_name": "clearTimerInterruptFlag_080074e0"
        },
        "FUN_080073c0": {
            "renaming": {
                "FUN_080073c0": "call_RTC_user_callback_080073c0",
                "*hrtc": "*rtc_handle",
                "PTR_RTCUserCallback_080073d0": "user_callback_ptr",
                "PTR_callbackUserData_080073d4": "user_data_ptr"
            },
            "code": "void call_RTC_user_callback_080073c0(RTC_HandleTypeDef *rtc_handle) {\n  code* user_callback = *(code**)PTR_RTCUserCallback_080073d0;\n  if (user_callback != (code*)0x0) {\n    user_callback(*(undefined4*)PTR_callbackUserData_080073d4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080073c0",
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "imported": false,
            "current_name": "call_RTC_user_callback_080073c0"
        },
        "FUN_080084b0": {
            "renaming": {
                "FUN_080084b0": "initialize_uart_debug_080084b0",
                "PinName_conflict": "PinName",
                "PTR_digitalPin_080084f0": "digitalPin_1",
                "void *pvVar2": "peripheral",
                "PTR_PinMap_UART_TX_080084f4": "PinMap_UART_TX",
                "void *obj": "serial_debug_obj",
                "PinName_conflict PVar1": "uart_rx_pin",
                "PTR_PinMap_UART_RX_080084f8": "PinMap_UART_RX",
                "PTR_serial_debug_080084fc": "serial_debug"
            },
            "code": "void initialize_uart_debug_080084b0(void)\n{\n  PinName_conflict digital_pin;\n  undefined *PTR_serial_debug_080084fc_obj;\n  PinName_conflict uart_tx_pin;\n  void *peripheral;\n  digital_pin = PTR_digitalPin_080084f0;\n  peripheral = pinmap_peripheral(digital_pin,(PinMap_conflict *)PTR_PinMap_UART_TX_080084f4);\n  if (peripheral != (void *)0x0) {\n    peripheral = pinmap_peripheral(digital_pin,(PinMap_conflict *)PTR_PinMap_UART_TX_080084f4);\n    uart_tx_pin = pinmap_pin(peripheral,(PinMap_conflict *)PTR_PinMap_UART_RX_080084f8);\n    PTR_serial_debug_080084fc_obj = PTR_serial_debug_080084fc;\n    PTR_serial_debug_080084fc[0x59] = uart_tx_pin;\n    PTR_serial_debug_080084fc[0x58] = digital_pin;\n    *(undefined4 *)(PTR_serial_debug_080084fc + 0x48) = 0x2580;\n    *(undefined4 *)(PTR_serial_debug_080084fc + 0x54) = 0;\n    *(undefined4 *)(PTR_serial_debug_080084fc + 0x4c) = 0;\n    *(undefined4 *)(PTR_serial_debug_080084fc + 0x50) = 0;\n    uart_init((serial_t *)PTR_serial_debug_080084fc_obj);\n  }\n  return;\n}",
            "called": [
                "pinmap_pin",
                "pinmap_peripheral",
                "uart_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080084b0",
            "calling": [
                "uart_debug_write"
            ],
            "imported": false,
            "current_name": "initialize_uart_debug_080084b0"
        },
        "FUN_080095a8": {
            "renaming": {
                "FUN_080095a8": "encode_data_080095a8",
                "param_1": "input_value",
                "param_2": "output_buffer",
                "param_3": "output_length",
                "param_4": "additional_value",
                "param_5": "encoding_function",
                "iVar1": "result",
                "uVar2": "max_output_length",
                "uVar3": "encoding_offset",
                "bVar4": "is_encoding_type_four",
                "encoding_type": "encoding_type",
                "has_additional_value": "has_additional_value",
                "remaining_output_length": "remaining_output_length",
                "status": "status"
            },
            "code": "int encode_data_080095a8(uint32_t input_value, uint32_t *output_length, uint32_t *output_buffer, uint32_t additional_value, code *encoding_function)\\n\\\n    {\\n\\\n        int status = 0;\\n\\\n        uint32_t max_output_length = output_buffer[4];\\n\\\n        if (max_output_length < output_buffer[2]) {\\n\\\n            max_output_length = output_buffer[2];\\n\\\n        }\\n\\\n        *output_length = max_output_length;\\n\\\n        if (*(char *)((int)output_buffer + 0x43) != \"\\0\") {\\n\\\n            *output_length = max_output_length + 1;\\n\\\n        }\\n\\\n        if ((int)(*output_buffer << 0x1a) < 0) {\\n\\\n            *output_length = *output_length + 2;\\n\\\n        }\\n\\\n        uint32_t encoding_type = *output_buffer & 6;\\n\\\n        if (encoding_type == 0) {\\n\\\n            for (; (int)encoding_type < (int)(output_buffer[3] - *output_length); encoding_type++) {\\n\\\n                int result = (*encoding_function)(input_value, additional_value, (int)output_buffer + 0x19, 1);\\n\\\n                if (result == -1) {\\n\\\n                    return -1;\\n\\\n                }\\n\\\n            }\\n\\\n        }\\n\\\n        uint32_t has_additional_value = (uint32_t)*(byte *)((int)output_buffer + 0x43);\\n\\\n        if (has_additional_value != 0) {\\n\\\n            has_additional_value = 1;\\n\\\n        }\\n\\\n        uint32_t encoding_offset = has_additional_value;\\n\\\n        if ((int)(*output_buffer << 0x1a) < 0) {\\n\\\n            *(undefined *)((int)output_buffer + encoding_offset + 0x43) = 0x30;\\n\\\n            encoding_offset += 2;\\n\\\n            *(undefined *)((int)output_buffer + encoding_offset + 0x44) = *(undefined *)((int)output_buffer + 0x45);\\n\\\n        }\\n\\\n        int result = (*encoding_function)(input_value, additional_value, (int)output_buffer + 0x43, encoding_offset);\\n\\\n        if (result != -1) {\\n\\\n            uint32_t remaining_output_length = output_buffer[3];\\n\\\n            bool is_encoding_type_four = (*output_buffer & 6) != 4;\\n\\\n            if (is_encoding_type_four) {\\n\\\n                remaining_output_length = 0;\\n\\\n            }\\n\\\n            uint32_t encoding_offset = 0;\\n\\\n            if (!is_encoding_type_four) {\\n\\\n                remaining_output_length = remaining_output_length - *output_length;\\n\\\n                remaining_output_length = remaining_output_length & ~((int)remaining_output_length >> 0x1f);\\n\\\n            }\\n\\\n            if (max_output_length < output_buffer[2]) {\\n\\\n                remaining_output_length = remaining_output_length + (output_buffer[2] - output_buffer[4]);\\n\\\n            }\\n\\\n            while (encoding_offset != remaining_output_length) {\\n\\\n                result = (*encoding_function)(input_value, additional_value, (int)output_buffer + 0x1a, 1);\\n\\\n                if (result == -1) {\\n\\\n                    status = -1;\\n\\\n                    break;\\n\\\n                }\\n\\\n                encoding_offset++;\\n\\\n            }\\n\\\n        }\\n\\\n        else {\\n\\\n            status = -1;\\n\\\n        }\\n\\\n        return status;\\n\\\n    }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080095a8",
            "calling": [
                "_printf_i"
            ],
            "imported": false,
            "current_name": "encode_data_080095a8"
        },
        "FUN_08008b2a": {
            "renaming": {
                "FUN_08008b2a": "readByte_08008b2a",
                "__thiscall HardwareSerial::": "",
                "this": "serial",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numberOfBytes",
                "bVar1": "byteValue",
                "uVar2": "tailIndex"
            },
            "code": "ssize_t __thiscall HardwareSerial::readByte_08008b2a(HardwareSerial *serial, int fileDescriptor, void *buffer, size_t numberOfBytes)\n{\n  byte byteValue;\n  ushort tailIndex;\n  \n  tailIndex = (serial->_serial).rx_tail;\n  if ((uint)(serial->_serial).rx_head != (uint)tailIndex) {\n    byteValue = (serial->_serial).rx_buff[tailIndex];\n    (serial->_serial).rx_tail = (tailIndex + 1) & 0x3f;\n    return (uint)byteValue;\n  }\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b2a",
            "calling": [],
            "imported": false,
            "current_name": "readByte_08008b2a"
        },
        "FUN_08003bd8": {
            "renaming": {
                "FUN_08003bd8": "configureADC_08003bd8",
                "*hadc": "*adc",
                "HVar1": "status",
                "uVar2": "conversionBits",
                "uVar3": "modeBits",
                "uVar4": "stateBit",
                "uVar5": "discModeBits",
                "DAT_08003ce0": "CR2_MASK",
                "DAT_08003ce4": "CR2_MODE_MASK"
            },
            "code": "HAL_StatusTypeDef_conflict configureADC_08003bd8(ADC_HandleTypeDef *adc)\n{\n  HAL_StatusTypeDef_conflict status;\n  uint32_t stateBit;\n  uint32_t cr1Reg;\n  uint32_t cr2Reg;\n  uint32_t sqr1Reg;\n  uint32_t modeBits;\n  uint32_t conversionBits;\n  uint32_t discModeBits;\n  uint32_t discConvBits;\n  \n  if (adc == NULL) {\n    return HAL_ERROR;\n  }\n  \n  if (adc->State == 0) {\n    adc->ErrorCode = 0;\n    adc->Lock = HAL_UNLOCKED;\n    HAL_ADC_MspInit(adc);\n  }\n  \n  status = ADC_ConversionStop_Disable(adc);\n  stateBit = adc->State & 0x10;\n  \n  if ((stateBit == 0) && (status == HAL_OK)) {\n    adc->State = adc->State & 0xffffeefd | 2;\n    modeBits = (adc->Init).DataAlign | (adc->Init).ExternalTrigConv | ((adc->Init).ContinuousConvMode << 1);\n    conversionBits = 0;\n    discModeBits = 0;\n    discConvBits = 0;\n    \n    if ((adc->Init).ScanConvMode <= 1) {\n      conversionBits = ((adc->Init).NbrOfConversion - 1) << 20;\n    }\n    \n    if ((adc->Init).ScanConvMode == 1) {\n      conversionBits |= 0x100000;\n    }\n    \n    if ((adc->Init).DiscontinuousConvMode == 1) {\n      if ((adc->Init).ContinuousConvMode == 0) {\n        discConvBits = ((adc->Init).NbrOfDiscConversion - 1) << 14 | 0x800;\n        discModeBits = 0x20;\n      }\n      else {\n        adc->State |= 0x20;\n        adc->ErrorCode |= 1;\n      }\n    }\n    \n    cr1Reg = adc->Instance->CR1 & 0xffff16ff | conversionBits | discConvBits;\n    cr2Reg = adc->Instance->CR2 & DAT_08003ce0 | modeBits;\n    sqr1Reg = adc->Instance->SQR1 & 0xff0fffff | conversionBits;\n    \n    if (modeBits != (DAT_08003ce4 & adc->Instance->CR2)) {\n      adc->State = adc->State & 0xffffffed | 0x10;\n      adc->ErrorCode |= 1;\n      return HAL_ERROR;\n    }\n    \n    adc->ErrorCode = 0;\n    adc->State = adc->State & 0xfffffffc | 1;\n    adc->Instance->CR1 = cr1Reg;\n    adc->Instance->CR2 = cr2Reg;\n    adc->Instance->SQR1 = sqr1Reg;\n    return HAL_OK;\n  }\n  \n  adc->State |= 0x10;\n  return HAL_ERROR;\n}",
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspInit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08003bd8",
            "calling": [
                "adc_read_value"
            ],
            "imported": false,
            "current_name": "configureADC_08003bd8"
        },
        "FUN_08009d50": {
            "renaming": {
                "FUN_08009d50": "initialize_data_08009d50",
                "param_1": "data_address",
                "PTR__global_impure_ptr_08009da8": "GLOBAL_PTR_ADDRESS",
                "DAT_08009dac": "GLOBAL_VAR",
                "iVar2": "global_impure_ptr",
                "bVar3": "is_global_ptr",
                "__sfp()": "get_float_value()",
                "std_isra_0": "some_std_function()",
                "uVar1": "float_value",
                "DATA_FLAG_OFFSET": "0x18",
                "DATA_FIELD1_OFFSET": "0x48",
                "DATA_FIELD2_OFFSET": "0x4c",
                "DATA_FIELD3_OFFSET": "0x50",
                "DATA_FIELD4_OFFSET": "0x28"
            },
            "code": "void initialize_data_08009d50(int data_address)\n{\n  if (*(int *)(data_address + DATA_FLAG_OFFSET) == 0) {\n    *(int *)(data_address + DATA_FIELD1_OFFSET) = 0;\n    *(int *)(data_address + DATA_FIELD2_OFFSET) = 0;\n    *(int *)(data_address + DATA_FIELD3_OFFSET) = 0;\n    int global_impure_ptr = *(int *)PTR__global_impure_ptr_08009da8;\n    *(int *)(data_address + DATA_FIELD4_OFFSET) = DAT_08009dac;\n    bool is_global_ptr = data_address == global_impure_ptr;\n    if (is_global_ptr) {\n      global_impure_ptr = 1;\n    }\n    if (is_global_ptr) {\n      *(int *)(data_address + DATA_FLAG_OFFSET) = global_impure_ptr;\n    }\n    float first_field_value = __sfp();\n    *(float *)(data_address + DATA_FIELD1_OFFSET) = first_field_value;\n    float second_field_value = __sfp(data_address);\n    *(float *)(data_address + DATA_FIELD2_OFFSET) = second_field_value;\n    float third_field_value = __sfp(data_address);\n    *(float *)(data_address + DATA_FIELD3_OFFSET) = third_field_value;\n    std_isra_0(first_field_value, 4, 0);\n    std_isra_0(second_field_value, 9, 1);\n    std_isra_0(third_field_value, 0x12, 2);\n    *(int *)(data_address + DATA_FLAG_OFFSET) = 1;\n  }\n  return;\n}",
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009d50",
            "calling": [
                "_fflush_r",
                "__swbuf_r",
                "_vfiprintf_r",
                "__swsetup_r",
                "__sfp",
                "iprintf"
            ],
            "imported": false,
            "current_name": "initialize_data_08009d50"
        },
        "FUN_08009108": {
            "renaming": {
                "FUN_08009108": "convert_to_64bit_address_08009108",
                "param_1": "is_address_32bit",
                "param_2": "address",
                "DAT_08009120": "has_address_offset"
            },
            "code": "longlong convert_to_64bit_address_08009108(undefined4 is_address_32bit, uint64_t address)\n{\n  if (DAT_08009120 != 0) {\n    return CONCAT44(is_address_32bit,2);\n  }\n  return (ulonglong)address << 0x20;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009108",
            "calling": [
                "__aeabi_atexit"
            ],
            "imported": false,
            "current_name": "convert_to_64bit_address_08009108"
        },
        "FUN_08009f98": {
            "renaming": {
                "FUN_08009f98": "execute_function_08009f98",
                "param_1": "result",
                "param_2": "function_index",
                "param_3": "arg1",
                "param_4": "arg2",
                "_Var1": "pid",
                "uVar2": "status",
                "iVar3": "function_table",
                "pcVar4": "function"
            },
            "code": "int execute_function_08009f98(int *result, uint function_index, int arg1, int arg2)\n{\n  __pid_t pid;\n  int status;\n  void (*function)(int);\n  if (function_index > 31) {\n    *result = 22;\n    return -1;\n  }\n  int *function_table = result + 17;\n  function = function_table[function_index];\n  if (function == NULL) {\n    pid = _getpid_r();\n    status = _kill_r(result, pid, function_index, arg2);\n    return status;\n  }\n  if (function == (void*)0x1) {\n    return 0;\n  }\n  if (function == (void*)-1) {\n    *result = 22;\n    return 1;\n  }\n  function_table[function_index] = NULL;\n  function(arg1);\n  return 0;\n}",
            "called": [
                "_getpid_r",
                "_kill_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009f98",
            "calling": [
                "raise"
            ],
            "imported": false,
            "current_name": "execute_function_08009f98"
        },
        "FUN_0800a18c": {
            "renaming": {
                "FUN_0800a18c": "abort_function_0800a18c"
            },
            "code": "/* WARNING: Unknown calling convention -- yet parameter storage is locked */\n/* std::abort_function_0800a18c() */\n\nvoid std::abort_function_0800a18c(void)\n{\n    /* WARNING: Subroutine does not return */\n    abort();\n}",
            "called": [
                "abort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a18c",
            "calling": [
                "operator()"
            ],
            "imported": false,
            "current_name": "abort_function_0800a18c"
        },
        "FUN_08008a24": {
            "renaming": {
                "FUN_08008a24": "digital_io_write_08008a24",
                "ulPin": "pin",
                "ulVal": "value",
                "PTR_digitalPin_08008a64": "digitalPin",
                "PTR_g_digPinConfigured_08008a68": "g_digital_pin_configured",
                "_Var1": "is_pin_configured_result",
                "port": "gpio_port",
                "uVar2": "pin_number"
            },
            "code": "void digital_io_write_08008a24(uint32_t pin, uint32_t value)\n{\n  _Bool is_pin_configured_result;\n  GPIO_TypeDef *gpio_port;\n  uint32_t pin_number;\n\n  if (pin < 0x3c) {\n    pin_number = (uint32_t)(char)PTR_digitalPin_08008a64[pin];\n  }\n  else {\n    pin_number = 0xffffffff;\n  }\n  if ((pin_number != 0xffffffff) && (is_pin_configured_result = is_pin_configured((PinName_conflict)pin_number, &PTR_g_digPinConfigured_08008a68))) {\n    gpio_port = get_gpio_port((pin_number << 0x18) >> 0x1c);\n    digital_io_write_08008a24(gpio_port, 1 << (pin_number & 0xf) & 0xffff, value);\n  }\n  return;\n}",
            "called": [
                "digital_io_write",
                "get_GPIO_Port",
                "is_pin_configured"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008a24",
            "calling": [
                "strobeBlinkPin",
                "analogWrite",
                "digitalWriteCallback",
                "ServoIrqHandle",
                "setPinValueCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "digital_io_write_08008a24"
        },
        "FUN_08008020": {
            "renaming": {
                "FUN_08008020": "enable_i2c_listen_interrupt_08008020",
                "hi2c": "i2c_handle",
                "piVar1": "i2c_obj",
                "isMaster": "is_master"
            },
            "code": "void enable_i2c_listen_interrupt_08008020(I2C_HandleTypeDef_conflict *i2c_handle)\\n{\\n  i2c_t_conflict *i2c_obj;\\n  i2c_obj = get_i2c_object(i2c_handle);\\n  if (i2c_obj->is_master == \"\\0\") {\\n    HAL_I2C_EnableListen_IT(i2c_handle);\\n  }\\n  return;\\n}",
            "called": [
                "HAL_I2C_EnableListen_IT",
                "get_i2c_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008020",
            "calling": [
                "I2C_DMAAbort",
                "I2C_ITError"
            ],
            "imported": false,
            "current_name": "enable_i2c_listen_interrupt_08008020"
        },
        "FUN_08005dac": {
            "renaming": {
                "FUN_08005dac": "configure_timer_08005dac",
                "TIMx": "timer",
                "OC_Config": "output_channel_config",
                "uVar1": "cr2_register_value",
                "uVar2": "output_channel_mode_value",
                "uVar3": "output_channel_polarity_value",
                "DAT_08005df0": "PTR_08005df0"
            },
            "code": "void configure_timer_08005dac(TIM_TypeDef_conflict *timer, TIM_OC_InitTypeDef *output_channel_config)\n{\n  uint32_t cr2_register_value;\n  uint32_t output_channel_mode_value;\n  uint32_t output_channel_polarity_value;\n  \n  timer->CCER = timer->CCER & 0xffffefff;\n  cr2_register_value = timer->CR2;\n  output_channel_mode_value = output_channel_config->OCMode;\n  output_channel_polarity_value = output_channel_config->OCPolarity;\n  if (timer == DAT_08005df0) {\n    cr2_register_value = cr2_register_value & 0xffffbfff | output_channel_config->OCIdleState << 6;\n  }\n  timer->CR2 = cr2_register_value;\n  timer->CCMR2 = timer->CCMR2 & 0xffff8cff | output_channel_mode_value << 8;\n  timer->CCR4 = output_channel_config->Pulse;\n  timer->CCER = timer->CCER & 0xffffdfff | output_channel_polarity_value << 0xc;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005dac",
            "calling": [
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_OC_ConfigChannel"
            ],
            "imported": false,
            "current_name": "configure_timer_08005dac"
        },
        "FUN_080066e8": {
            "renaming": {
                "FUN_080066e8": "check_uart_flag_status_080066e8",
                "huart": "uart_handle",
                "Flag": "flag",
                "Status": "status",
                "Tickstart": "start_time",
                "Timeout": "timeout",
                "uVar1": "current_time"
            },
            "code": "HAL_StatusTypeDef check_uart_flag_status_080066e8(UART_HandleTypeDef *uart_handle, uint32_t flag, FlagStatus status, uint32_t start_time, uint32_t timeout)\n{\n  uint32_t current_time;\n  do {\n    bool flag_status = ((flag & ~uart_handle->Instance->SR) == 0);\n    if (flag_status != (bool)status) {\n      return HAL_OK;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (current_time = HAL_GetTick(), current_time - start_time <= timeout))));\n  uart_handle->Instance->CR1 = uart_handle->Instance->CR1 & 0xfffffe5f;\n  uart_handle->Instance->CR3 = uart_handle->Instance->CR3 & 0xfffffffe;\n  uart_handle->gState = HAL_UART_STATE_READY;\n  uart_handle->RxState = HAL_UART_STATE_READY;\n  uart_handle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}",
            "called": [
                "HAL_GetTick"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080066e8",
            "calling": [
                "HAL_UART_Transmit"
            ],
            "imported": false,
            "current_name": "check_uart_flag_status_080066e8"
        },
        "FUN_08009358": {
            "renaming": {
                "FUN_08009358": "write_to_stream_08009358",
                "param_1": "stream",
                "param_2": "character",
                "param_3": "buffer",
                "param_4": "count",
                "puVar2": "end_of_buffer",
                "iVar1": "result",
                "iVar3": "bytes_written"
            },
            "code": "int write_to_stream_08009358(int stream, int character, void *buffer, int count)\n{\n  int result;\n  void *end_of_buffer = buffer + count;\n  int bytes_written = count;\n  do {\n    if (buffer == end_of_buffer) {\n      return 0;\n    }\n    result = __sfputc_r(stream, *buffer, character, count, bytes_written);\n    count = result + 1;\n    buffer = buffer + 1;\n  } while (count != 0);\n  return result;\n}",
            "called": [
                "__sfputc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009358",
            "calling": [
                "_vfiprintf_r"
            ],
            "imported": false,
            "current_name": "write_to_stream_08009358"
        },
        "FUN_0800270c": {
            "renaming": {
                "FUN_0800270c": "calculateBufferLengthDifference_0800270c",
                "this": "wireObject",
                "*PTR_rxBufferLength_08002718": "bufferLength",
                "*PTR_rxBufferIndex_0800271c": "bufferIndex"
            },
            "code": "int __thiscall calculateBufferLengthDifference_0800270c(TwoWire *wireObject) {\n    int *PTR_rxBufferLength_08002718 = (int)(byte)*PTR_rxBufferLength_08002718;\n    int *PTR_rxBufferIndex_0800271c = (int)(byte)*PTR_rxBufferIndex_0800271c;\n    return *PTR_rxBufferLength_08002718 - *PTR_rxBufferIndex_0800271c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800270c",
            "calling": [
                "readAndReportData"
            ],
            "imported": false,
            "current_name": "calculateBufferLengthDifference_0800270c"
        },
        "FUN_08007fa0": {
            "renaming": {
                "FUN_08007fa0": "i2c_slave_transfer_08007fa0",
                "hi2c": "i2c_handle",
                "TransferDirection": "transfer_direction",
                "AddrMatchCode": "address_match_code",
                "piVar1": "i2c_obj",
                "get_i2c_obj": "get_i2c_object",
                "i2cTxRxBufferSize": "tx_rx_buffer_size",
                "slaveMode": "slave_mode",
                "i2c_onSlaveTransmit": "on_slave_transmit",
                "i2cTxRxBuffer": "tx_rx_buffer",
                "_func_void": "_func_void"
            },
            "code": "void i2c_slave_transfer_08007fa0(I2C_HandleTypeDef_conflict *i2c_handle, uint8_t transfer_direction, uint16_t address_match_code) {\n  i2c_t_conflict *i2c_obj;\n  i2c_obj = get_i2c_object(i2c_handle);\n  if ((uint)address_match_code == (i2c_handle->Init).OwnAddress1) {\n    if (transfer_direction == 0) {\n      i2c_obj->tx_rx_buffer_size = 0;\n      i2c_obj->slave_mode = 0;\n      if (i2c_obj->on_slave_transmit != (_func_void *)0x0) {\n        (*i2c_obj->on_slave_transmit)();\n      }\n      HAL_I2C_Slave_Sequential_Transmit_IT(i2c_handle, i2c_obj->tx_rx_buffer, (ushort)i2c_obj->tx_rx_buffer_size, 8);\n      return;\n    }\n    i2c_obj->slave_mode = 1;\n    HAL_I2C_Slave_Sequential_Receive_IT(i2c_handle, i2c_obj->tx_rx_buffer, 0x20, 8);\n  }\n  return;\n}",
            "called": [
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "HAL_I2C_Slave_Sequential_Transmit_IT",
                "get_i2c_obj"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08007fa0",
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "imported": false,
            "current_name": "i2c_slave_transfer_08007fa0"
        },
        "FUN_08002720": {
            "renaming": {
                "FUN_08002720": "readByteFromRxBuffer_08002720",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "bVar1": "rxBufferIndex",
                "bVar2": "receivedByte",
                "PTR_rxBufferIndex_08002740": "wireObj->rxBufferIndex",
                "PTR_rxBufferLength_08002744": "*wireObj->rxBufferLength",
                "PTR_rxBuffer_08002748": "*(int *)wireObj->rxBuffer"
            },
            "code": "ssize_t __thiscall TwoWire::readByteFromRxBuffer_08002720(TwoWire *wireObj,int fileDescriptor,void *buffer,size_t numBytes){\n\n    byte rxBufferIndex = *(PTR_rxBufferIndex_08002740);\n    \n    if ((uint)rxBufferIndex < (uint)(byte)PTR_rxBufferLength_08002744) {\n        byte receivedByte = *(byte *)(PTR_rxBuffer_08002748 + (uint)rxBufferIndex);\n        *(PTR_rxBufferIndex_08002740) = rxBufferIndex + 1;\n        return (uint)receivedByte;\n    }\n    return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002720",
            "calling": [
                "wireRead"
            ],
            "imported": false,
            "current_name": "readByteFromRxBuffer_08002720"
        },
        "FUN_080031ce": {
            "renaming": {
                "FUN_080031ce": "sendFirmwareVersion_080031ce",
                "this": "marshaller",
                "major": "majorVersion",
                "minor": "minorVersion",
                "bytec": "byteCount",
                "bytev": "byteArray",
                "p_Var1": "printFunction",
                "uVar2": "index",
                "encodeByteStream": "encodeByteStream"
            },
            "code": "void __thiscall FirmataMarshaller::sendFirmwareVersion_080031ce(FirmataMarshaller *marshaller,uint8_t major,uint8_t minor,size_t byteCount,uint8_t *byteArray)\n{\n  _func_int_varargs *printFunction;\n  uint index;\n  if (marshaller->FirmataStream != (Stream *)0x0) {\n    printFunction = *(marshaller->FirmataStream->super_Print)._vptr_Print;\n    (*printFunction)(marshaller,0xf0,(uint)minor,printFunction,byteCount);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,0x79);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,(uint)major);\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,(uint)minor);\n    for (index = 0; index < byteCount; index = index + 1) {\n      encodeByteStream(marshaller,1,byteArray + index,0);\n    }\n    (**(marshaller->FirmataStream->super_Print)._vptr_Print)(marshaller->FirmataStream,0xf7);\n  }\n  return;\n}",
            "called": [
                "encodeByteStream"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080031ce",
            "calling": [
                "printFirmwareVersion"
            ],
            "imported": false,
            "current_name": "sendFirmwareVersion_080031ce"
        },
        "FUN_08008b52": {
            "renaming": {
                "FUN_08008b52": "wait_until_transmit_complete_08008b52",
                "this": "serial_instance",
                "_written": "is_written",
                "_serial": "serial_data",
                "tx_head": "transmit_head",
                "tx_tail": "transmit_tail"
            },
            "code": "void __thiscall HardwareSerial::wait_until_transmit_complete_08008b52(HardwareSerial *serial_instance)\n{\n    bool is_written = serial_instance->_written;\n    if (is_written) {\n        while ((serial_instance->_serial).tx_head != (serial_instance->_serial).tx_tail) {\n        }\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b52",
            "calling": [],
            "imported": false,
            "current_name": "wait_until_transmit_complete_08008b52"
        },
        "FUN_08002968": {
            "renaming": {
                "FUN_08002968": "initializeI2C_08002968",
                "this": "wire",
                "address": "address",
                "PTR_rxBufferIndex_080029ec": "wire->rxBufferIndex",
                "PTR_rxBufferLength_080029f0": "wire->rxBufferLength",
                "PTR_rxBuffer_080029f4": "wire->rxBuffer",
                "PTR_rxBufferAllocated_080029f8": "wire->rxBufferAllocated",
                "PTR_txBufferIndex_080029fc": "wire->txBufferIndex",
                "PTR_txBufferLength_08002a00": "wire->txBufferLength",
                "PTR_txBuffer_08002a04": "wire->txBuffer",
                "PTR_txBufferAllocated_08002a08": "wire->txBufferAllocated",
                "PTR_transmitting_08002a0c": "wire->transmitting",
                "ownAddress": "ownAddress",
                "obj": "i2c"
            },
            "code": "void __thiscall initializeI2C_08002968(TwoWire *wire, uint8_t address) {\n  uint32_t ownAddress;\n  i2c_t *i2c;\n  PTR_rxBufferIndex_080029ec = 0;\n  PTR_rxBufferLength_080029f0 = 0;\n  if (*(void **)PTR_rxBuffer_080029f4 != (void *)0x0) {\n    memset(*(void **)PTR_rxBuffer_080029f4, 0, (uint)(byte)*PTR_rxBufferAllocated_080029f8);\n  }\n  PTR_txBufferIndex_080029fc = 0;\n  PTR_txBufferLength_08002a00 = 0;\n  if (*(void **)PTR_txBuffer_08002a04 != (void *)0x0) {\n    memset(*(void **)PTR_txBuffer_08002a04, 0, (uint)(byte)*PTR_txBufferAllocated_08002a08);\n  }\n  PTR_transmitting_08002a0c = 0;\n  ownAddress = (address & 0x7f) << 1;\n  wire->ownAddress = (uint8_t)ownAddress;\n  if (address == 0x33) {\n    wire->master = true;\n  }\n  else {\n    wire->master = false;\n  }\n  i2c = &wire->_i2c;\n  i2c_custom_init((i2c_t_conflict *)i2c, PTR_rxBuffer_080029f4, PTR_txBufferAllocated_08002a08, ownAddress, wire->master);\n  if (wire->master == false) {\n    i2c_attachSlaveTxEvent((i2c_t_conflict *)i2c, PTR_txBuffer_08002a04);\n    i2c_attachSlaveRxEvent((i2c_t_conflict *)i2c, PTR_rxBuffer_080029f4);\n  }\n  return;\n}",
            "called": [
                "i2c_attachSlaveRxEvent",
                "i2c_attachSlaveTxEvent",
                "memset",
                "i2c_custom_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002968",
            "calling": [
                "begin"
            ],
            "imported": false,
            "current_name": "initializeI2C_08002968"
        },
        "FUN_08004ccc": {
            "renaming": {
                "FUN_08004ccc": "i2c_transfer_complete_08004ccc",
                "hi2c": "handle",
                "uVar1": "transfer_options",
                "pbVar2": "buffer"
            },
            "code": "HAL_StatusTypeDef i2c_transfer_complete_08004ccc(I2C_HandleTypeDef *handle)\n{\n    uint32_t transfer_options = handle->XferOptions;\n    if (handle->State == HAL_I2C_STATE_BUSY_TX)\n    {\n        if (handle->XferCount == 0)\n        {\n            if ((transfer_options == 4) || (transfer_options == 8) || (transfer_options == 0xffff0000))\n            {\n                handle->Instance->CR2 &= 0xfffff8ff;\n                handle->Instance->CR1 |= 0x200;\n                handle->PreviousState = 0;\n                handle->State = HAL_I2C_STATE_READY;\n                if (handle->Mode == HAL_I2C_MODE_MEM)\n                {\n                    handle->Mode = HAL_I2C_MODE_NONE;\n                    HAL_I2C_MemTxCpltCallback(handle);\n                }\n                else\n                {\n                    handle->Mode = HAL_I2C_MODE_NONE;\n                    HAL_I2C_MasterTxCpltCallback(handle);\n                }\n            }\n            else\n            {\n                handle->Instance->CR2 &= 0xfffff8ff;\n                handle->PreviousState = 0x11;\n                handle->Mode = HAL_I2C_MODE_NONE;\n                handle->State = HAL_I2C_STATE_READY;\n                HAL_I2C_MasterTxCpltCallback(handle);\n            }\n        }\n        else\n        {\n            uint8_t *buffer = handle->pBuffPtr;\n            handle->pBuffPtr = buffer + 1;\n            handle->Instance->DR = (uint16_t)*buffer;\n            handle->XferCount--;\n        }\n    }\n    return HAL_OK;\n}",
            "called": [
                "HAL_I2C_MasterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08004ccc",
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "imported": false,
            "current_name": "i2c_transfer_complete_08004ccc"
        },
        "FUN_080042d4": {
            "renaming": {
                "FUN_080042d4": "get_pin_state_080042d4",
                "GPIOx": "gpio",
                "GPIO_Pin": "pin",
                "GPIO_PIN_RESET": "GPIO_PIN_STATE_RESET",
                "GPIO_PIN_SET": "GPIO_PIN_STATE_SET"
            },
            "code": "GPIO_PinState get_pin_state_080042d4(GPIO_TypeDef *gpio, uint16_t pin) {\n  if ((pin & gpio->IDR) == 0) {\n    return GPIO_PIN_RESET;\n  }\n  return GPIO_PIN_SET;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042d4",
            "calling": [
                "digital_io_read"
            ],
            "imported": false,
            "current_name": "get_pin_state_080042d4"
        },
        "FUN_0800a07a": {
            "renaming": {
                "FUN_0800a07a": "read_file_at_offset_0800a07a",
                "param_1": "file_descriptor",
                "param_2": "offset_info",
                "iVar1": "seek_result",
                "uVar2": "flag",
                "bVar3": "seek_failed"
            },
            "code": "void read_file_at_offset_0800a07a(int file_descriptor, int* offset_info) {\n  int seek_result = _lseek_r(file_descriptor, (int)*(short *)(offset_info + 0xe));\n  bool seek_failed = seek_result == -1;\n  ushort flag;\n  if (seek_failed) {\n    flag = *(ushort *)(offset_info + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(offset_info + 0x54) = seek_result;\n    flag = *(ushort *)(offset_info + 0xc) | 0x1000;\n  }\n  *(ushort *)(offset_info + 0xc) = flag;\n}",
            "called": [
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a07a",
            "calling": [],
            "imported": false,
            "current_name": "read_file_at_offset_0800a07a"
        },
        "FUN_080064b0": {
            "renaming": {
                "FUN_080064b0": "reset_UART_080064b0",
                "huart": "UART_instance",
                "Instance": "UART_instance_pointer",
                "CR1": "control_register_1",
                "CR3": "control_register_3",
                "RxState": "receive_state",
                "HAL_UART_STATE_READY": "UART_receive_ready_state"
            },
            "code": "void reset_UART_080064b0(UART_HandleTypeDef *huart)\n{\n  huart->Instance->CR1 &= ~(1 << 13);\n  huart->Instance->CR3 &= ~(1 << 0);\n  huart->RxState = HAL_UART_STATE_READY;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064b0",
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "imported": false,
            "current_name": "reset_UART_080064b0"
        },
        "FUN_08006092": {
            "renaming": {
                "FUN_08006092": "configure_timer_08006092",
                "htim": "timer",
                "HAL_TIM_STATE_RESET": "HAL_TIM_STATE_RESET",
                "HAL_UNLOCKED": "HAL_UNLOCKED",
                "HAL_TIM_PWM_MspInit": "HAL_TIM_PWM_MspInit",
                "HAL_TIM_STATE_BUSY": "HAL_TIM_STATE_BUSY",
                "TIM_Base_SetConfig": "TIM_Base_SetConfig",
                "HAL_TIM_STATE_READY": "HAL_TIM_STATE_READY",
                "HAL_OK": "HAL_OK",
                "HAL_ERROR": "HAL_ERROR"
            },
            "code": "HAL_StatusTypeDef_conflict configure_timer_08006092(TIM_HandleTypeDef_conflict *timer)\n{\n  if (timer != NULL) {\n    if (timer->State == HAL_TIM_STATE_RESET) {\n      timer->Lock = HAL_UNLOCKED;\n      HAL_TIM_PWM_MspInit(timer);\n    }\n    timer->State = HAL_TIM_STATE_BUSY;\n    TIM_Base_SetConfig(timer->Instance,&timer->Init);\n    timer->State = HAL_TIM_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}",
            "called": [
                "HAL_TIM_PWM_MspInit",
                "TIM_Base_SetConfig"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08006092",
            "calling": [
                "pwm_start"
            ],
            "imported": false,
            "current_name": "configure_timer_08006092"
        },
        "FUN_08008d8c": {
            "renaming": {
                "FUN_08008d8c": "initializeHardwareSerial_08008d8c",
                "__initialize_p": "shouldInitialize",
                "__priority": "priorityLevel",
                "PTR_Serial2_08008dac": "serial2",
                "DAT_08008da8": "data"
            },
            "code": "void initializeHardwareSerial_08008d8c(int shouldInitialize, int priorityLevel)\n{\n  if (shouldInitialize != 1) {\n    return;\n  }\n  if (priorityLevel == 0xffff) {\n    HardwareSerial::HardwareSerial(&PTR_Serial2_08008dac, DAT_08008da8);\n  }\n  return;\n}",
            "called": [
                "HardwareSerial"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008d8c",
            "calling": [
                "_GLOBAL__sub_I_Serial2"
            ],
            "imported": false,
            "current_name": "initializeHardwareSerial_08008d8c"
        },
        "FUN_08008038": {
            "renaming": {
                "FUN_08008038": "handle_I2C_events_08008038",
                "PTR_i2c_handles_08008044": "i2c_handles"
            },
            "code": "void handle_I2C_events_08008038(void)\n{\n  I2C_HandleTypeDef_conflict **PTR_i2c_handles_08008044 = PTR_PTR_i2c_handles_08008044_08008044;\n  HAL_I2C_EV_IRQHandler(*PTR_i2c_handles_08008044);\n  return;\n}",
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008038",
            "calling": [],
            "imported": false,
            "current_name": "handle_I2C_events_08008038"
        },
        "FUN_08009124": {
            "renaming": {
                "FUN_08009124": "file_format_output_08009124",
                "__stream": "__stream",
                "__format": "__format",
                "PTR__impure_ptr_08009144": "PTR__impure_ptr_08009144",
                "in_r2": "stack_arg1",
                "in_r3": "stack_arg2",
                "uStack_8": "uStack_8",
                "uStack_4": "uStack_4",
                "_vFUN_08009124_r": "_vfile_format_output_r",
                "iVar1": "result"
            },
            "code": "int file_format_output_08009124(FILE *__stream,char *__format,...)\n{\n  int result;\n  undefined4 stack_arg1;\n  undefined4 stack_arg2;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  stack_arg1 = in_r2;\n  stack_arg2 = in_r3;\n  result = _vfile_format_output_08009124_r(*(undefined4 *)PTR__impure_ptr_08009144,__stream,__format,&uStack_8,__stream,\n                       &uStack_8);\n  return result;\n}",
            "called": [
                "_vfiprintf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08009124",
            "calling": [
                "__assert_func"
            ],
            "imported": false,
            "current_name": "file_format_output_08009124"
        },
        "FUN_080064ae": {
            "renaming": {
                "FUN_080064ae": "do_nothing_080064ae"
            },
            "code": "\nvoid do_nothing_080064ae(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064ae",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_080064ae"
        },
        "FUN_080064ac": {
            "renaming": {
                "FUN_080064ac": "do_nothing_080064ac"
            },
            "code": "\nvoid do_nothing_080064ac(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080064ac",
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "imported": false,
            "current_name": "do_nothing_080064ac"
        },
        "FUN_08005cb4": {
            "renaming": {
                "FUN_08005cb4": "check_RTC_alarm_08005cb4",
                "*hrtc": "*rtc_handle",
                "CRH": "RTC_CRH_ALRIE",
                "CRL": "RTC_CRL_ALRF"
            },
            "code": "void check_RTC_alarm_08005cb4(RTC_HandleTypeDef *rtc_handle) {\n    if (((rtc_handle->Instance->CRH & RTC_CRH_ALRIE) != 0) && ((rtc_handle->Instance->CRL & RTC_CRL_ALRF) != 0)) {\n        HAL_RTC_AlarmAEventCallback(rtc_handle);\n        rtc_handle->Instance->CRL &= ~RTC_CRL_ALRF;\n    }\n    *(uint32_t *)(DAT_08005ce8 + 0x14) = 0x20000;\n    rtc_handle->State = HAL_RTC_STATE_READY;\n    return;\n}",
            "called": [
                "HAL_RTC_AlarmAEventCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08005cb4",
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "imported": false,
            "current_name": "check_RTC_alarm_08005cb4"
        },
        "FUN_080042e2": {
            "renaming": {
                "FUN_080042e2": "set_gpio_pin_state_080042e2",
                "GPIOx": "gpio_port",
                "GPIO_Pin": "gpio_pin",
                "PinState": "pin_state",
                "BSRR": "bit_set_reset_register",
                "GPIO_PIN_RESET": "GPIO_PIN_RESET",
                "uint": "unsigned_integer"
            },
            "code": "void set_gpio_pin_state_080042e2(GPIO_TypeDef* gpio_port, uint16_t gpio_pin, GPIO_PinState pin_state)\n{\n if (pin_state == GPIO_PIN_RESET) {\n gpio_port->BSRR = (uint)gpio_pin << 0x10;\n return;\n }\n gpio_port->BSRR = (uint)gpio_pin;\n return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042e2",
            "calling": [
                "digital_io_write"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_state_080042e2"
        },
        "FUN_080088e0": {
            "renaming": {
                "FUN_080088e0": "configure_pwm_pin_080088e0",
                "ulPin": "pin_number",
                "ulValue": "value",
                "_Var1": "is_pin_pwm",
                "uVar2": "write_resolution",
                "pin": "pin",
                "PTR_digitalPin_0800897c": "digital_pin_array",
                "NC": "NC",
                "pin_in_pinmap": "is_pin_pwm_in_pinmap",
                "PinMap_conflict": "PinMap_conflict",
                "is_pin_configured": "is_pin_configured",
                "set_pin_configured": "set_pin_configured",
                "PTR_g_anOutputPinConfigured_08008984": "output_pin_configured_array",
                "PTR__writeResolution_08008988": "_write_resolution_pointer",
                "pwm_start": "pwm_start",
                "DAT_0800898c": "DAT_0800898c",
                "pinMode": "set_pin_mode",
                "digitalWrite": "set_pin_output"
            },
            "code": "void configure_pwm_pin_080088e0(uint32_t pin_number, uint32_t value) {\n  bool is_pin_pwm = false;\n  uint32_t write_resolution = *(uint32_t*)PTR__writeResolution_08008988;\n  PinName_conflict pin = (pin_number < 0x3c) ? PTR_digitalPin_0800897c[pin_number] : NC;\n  if (pin != NC) {\n    is_pin_pwm = pin_in_pinmap(pin, (PinMap_conflict*)PTR_PinMap_PWM_08008980);\n    if (is_pin_pwm) {\n      bool is_pin_configured = is_pin_configured(pin, (uint32_t*)PTR_g_anOutputPinConfigured_08008984);\n      if (!is_pin_configured) {\n        set_pin_configured(pin, (uint32_t*)PTR_g_anOutputPinConfigured_08008984);\n      }\n      if (write_resolution != 8) {\n        if (write_resolution < 9) {\n          value <<= (8 - write_resolution & 0xff);\n        }\n        else {\n          value >>= (write_resolution - 8 & 0xff);\n        }\n      }\n      pwm_start(pin, DAT_0800898c, 0xff, value, !is_pin_configured);\n    }\n    else {\n      pinMode(pin_number, OUTPUT);\n      if (write_resolution != 8) {\n        if (write_resolution < 9) {\n          value <<= (8 - write_resolution & 0xff);\n        }\n        else {\n          value >>= (write_resolution - 8 & 0xff);\n        }\n      }\n      digitalWrite(pin_number, (value < 0x80) ? LOW : HIGH);\n    }\n  }\n}",
            "called": [
                "pin_in_pinmap",
                "set_pin_configured",
                "digitalWrite",
                "pinMode",
                "pwm_start",
                "is_pin_configured"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080088e0",
            "calling": [
                "analogWriteCallback",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "configure_pwm_pin_080088e0"
        },
        "FUN_08008b66": {
            "renaming": {
                "FUN_08008b66": "receive_serial_data_08008b66",
                "*obj": "*serial_conflict",
                "iVar1": "uart_read_status",
                "uVar2": "next_rx_head",
                "c": "received_char"
            },
            "code": "void receive_serial_data_08008b66(serial_t_conflict *serial_conflict) {\n  int uart_read_status;\n  ushort next_rx_head;\n  uchar received_char;\n  \n  uart_read_status = uart_getc((serial_t *)serial_conflict, &received_char);\n  if ((uart_read_status == 0) && ((next_rx_head = serial_conflict->rx_head + 1 & 0x3f) != serial_conflict->rx_tail)) {\n    serial_conflict->rx_buff[serial_conflict->rx_head] = received_char;\n    serial_conflict->rx_head = next_rx_head;\n  }\n  return;\n}",
            "called": [
                "uart_getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008b66",
            "calling": [],
            "imported": false,
            "current_name": "receive_serial_data_08008b66"
        },
        "FUN_0800a3a0": {
            "renaming": {
                "std::ctype_byname<char>::FUN_0800a3a0": "set_ctype_flags",
                "FUN_0800a3a0": "set_ctype_flags_0800a3a0"
            },
            "code": "void set_ctype_flags_0800a3a0() {\n  if (-1 < *(int *)PTR_id_0800a404 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a404 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a408 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a408 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a40c << 0x1f) {\n    *(undefined4 *)PTR_id_0800a40c = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a410 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a410 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a414 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a414 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a418 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a418 = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a41c << 0x1f) {\n    *(undefined4 *)PTR_id_0800a41c = 1;\n  }\n  if (-1 < *(int *)PTR_id_0800a420 << 0x1f) {\n    *(undefined4 *)PTR_id_0800a420 = 1;\n  }\n  return;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a3a0",
            "calling": [],
            "imported": false,
            "current_name": "set_ctype_flags_0800a3a0"
        },
        "FUN_08008048": {
            "renaming": {
                "FUN_08008048": "handle_I2C_errors_08008048",
                "PTR_i2c_handles_08008054": "i2c_handles"
            },
            "code": "void handle_I2C_errors_08008048(void)\n{\n  HAL_I2C_ER_IRQHandler(*(I2C_HandleTypeDef_conflict **)PTR_i2c_handles_08008054);\n  return;\n}",
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08008048",
            "calling": [],
            "imported": false,
            "current_name": "handle_I2C_errors_08008048"
        },
        "FUN_080053cc": {
            "renaming": {
                "FUN_080053cc": "reset_i2c_080053cc",
                "hdma": "dma_handle",
                "hi2c": "i2c_handle"
            },
            "code": "void reset_i2c_080053cc(I2C_HandleTypeDef *i2c_handle)\n{\n  I2C_HandleTypeDef *i2c = i2c_handle;\n  i2c->Instance->CR1 &= 0xfffffbff;\n  i2c->XferCount = 0;\n  i2c->hdmatx->XferAbortCallback = NULL;\n  i2c->hdmarx->XferAbortCallback = NULL;\n  if (i2c->State != HAL_I2C_STATE_ABORT) {\n    i2c->State = HAL_I2C_STATE_READY;\n    i2c->Mode = HAL_I2C_MODE_NONE;\n    i2c->Instance->CR1 &= 0xfffffffe;\n    HAL_I2C_ErrorCallback(i2c);\n    return;\n  }\n  i2c->State = HAL_I2C_STATE_READY;\n  i2c->Mode = HAL_I2C_MODE_NONE;\n  i2c->ErrorCode = 0;\n  i2c->Instance->CR1 &= 0xfffffffe;\n  HAL_I2C_AbortCpltCallback(i2c);\n  return;\n}",
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080053cc",
            "calling": [],
            "imported": false,
            "current_name": "reset_i2c_080053cc"
        },
        "FUN_080087bc": {
            "renaming": {
                "FUN_080087bc": "handle_uart_interrupt_080087bc",
                "PTR_uart_handlers_080087d0": "uart_handlers"
            },
            "code": "void handle_uart_interrupt_080087bc(void)\n{\n  HAL_NVIC_ClearPendingIRQ(USART1_IRQn);\n  HAL_UART_IRQHandler(*PTR_uart_handlers_080087d0);\n  return;\n}",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080087bc",
            "calling": [],
            "imported": false,
            "current_name": "handle_uart_interrupt_080087bc"
        },
        "FUN_080042f0": {
            "renaming": {
                "FUN_080042f0": "update_GPIO_Pin_080042f0",
                "GPIO_Pin": "pin",
                "DAT_08004308": "GPIO_REG"
            },
            "code": "void update_GPIO_Pin_080042f0(uint16_t pin){\n    uint* DAT_08004308 = (uint*)(DAT_08004308 + 0x14);\n    if((*DAT_08004308 & (uint)pin) != 0){\n        *DAT_08004308 = (uint)pin;\n        HAL_GPIO_EXTI_Callback(pin);\n    }\n    return;\n}",
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080042f0",
            "calling": [
                "EXTI2_IRQHandler",
                "EXTI0_IRQHandler",
                "EXTI1_IRQHandler",
                "EXTI9_5_IRQHandler",
                "EXTI15_10_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI4_IRQHandler"
            ],
            "imported": false,
            "current_name": "update_GPIO_Pin_080042f0"
        },
        "FUN_080087d4": {
            "renaming": {
                "FUN_080087d4": "handle_USART2_interrupt_080087d4",
                "PTR_uart_handlers_080087e8": "uart_handlers"
            },
            "code": "void handle_USART2_interrupt_080087d4(void)\n{\n  HAL_NVIC_ClearPendingIRQ(USART2_IRQn);\n  HAL_UART_IRQHandler(*PTR_uart_handlers_080087e8[1]);\n  return;\n}",
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080087d4",
            "calling": [],
            "imported": false,
            "current_name": "handle_USART2_interrupt_080087d4"
        },
        "FUN_0800a09e": {
            "renaming": {
                "FUN_0800a09e": "close_file_descriptor_0800a09e",
                "param_1": "stream",
                "param_2": "file_descriptor_offset"
            },
            "code": "void close_file_descriptor_0800a09e(void* stream, int file_descriptor_offset) {\n  int file_descriptor = *(short *)(file_descriptor_offset + 0xe);\n  _close_r(stream, file_descriptor);\n  return;\n}",
            "called": [
                "_close_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0800a09e",
            "calling": [],
            "imported": false,
            "current_name": "close_file_descriptor_0800a09e"
        },
        "FUN_080076e0": {
            "renaming": {
                "FUN_080076e0": "disableTimerInterrupt_080076e0",
                "*obj": "timerObj",
                "HVar1": "halStatus",
                "uVar2": "timerIrqNum",
                "obj->irqHandleOC": "timerObj->irqHandleOC"
            },
            "code": "void disableTimerInterrupt_080076e0(stimer_t_conflict *timerObj)\n{\n  HAL_StatusTypeDef_conflict halStatus;\n  uint32_t timerIrqNum;\n\n  timerObj->irqHandleOC = (_func_void_stimer_t_ptr_uint32_t_conflict *)0x0;\n  timerIrqNum = getTimerIrq(timerObj->timer);\n  HAL_NVIC_DisableIRQ((IRQn_Type_conflict)timerIrqNum);\n  halStatus = HAL_TIM_OC_DeInit(&timerObj->handle);\n  if (halStatus == HAL_OK) {\n    HAL_TIM_OC_Stop_IT(&timerObj->handle,0);\n  }\n  return;\n}",
            "called": [
                "HAL_TIM_OC_DeInit",
                "getTimerIrq",
                "HAL_TIM_OC_Stop_IT",
                "HAL_NVIC_DisableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x080076e0",
            "calling": [
                "finISR"
            ],
            "imported": false,
            "current_name": "disableTimerInterrupt_080076e0"
        },
        "FUN_08002f14": {
            "renaming": {
                "FUN_08002f14": "sendStringToMarshaller_08002f14",
                "this": "firmataInstance",
                "string": "stringToSend",
                "FirmataMarshaller::FUN_08002f14": "sendStringToMarshaller",
                "&this->marshaller": "&firmataInstance->marshaller"
            },
            "code": "void __thiscall firmata::FirmataClass::sendStringToMarshaller_08002f14(FirmataClass *firmataInstance,char *stringToSend)\n{\n  FirmataMarshaller::sendStringToMarshaller_08002f14(&firmataInstance->marshaller,stringToSend);\n  return;\n}",
            "called": [
                "sendString"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x08002f14",
            "calling": [
                "attachServo",
                "sysexCallback",
                "readAndReportData",
                "setPinModeCallback"
            ],
            "imported": false,
            "current_name": "sendStringToMarshaller_08002f14"
        }
    },
    "used_tokens": 323303,
    "layers": [
        [
            "FUN_08007246",
            "FUN_0800a042",
            "FUN_08008e4e",
            "FUN_08008694",
            "FUN_08005188",
            "FUN_08001bf8",
            "FUN_080069ec",
            "FUN_0800a168",
            "FUN_080067ac",
            "FUN_0800735a",
            "FUN_08008c20",
            "FUN_0800723c",
            "FUN_080043a2",
            "FUN_08006280",
            "FUN_08007258",
            "FUN_08009f4c",
            "FUN_08006c7c",
            "FUN_08006b5c",
            "FUN_08007376",
            "FUN_080033cc",
            "FUN_08003de4",
            "FUN_08000500",
            "FUN_08009d24",
            "FUN_08008e72",
            "FUN_080022f8",
            "FUN_08005084",
            "FUN_08008b0e",
            "FUN_0800291c",
            "FUN_080032bc",
            "FUN_08008c44",
            "FUN_08006060",
            "FUN_08006186",
            "FUN_08006b7c",
            "FUN_08008e7c",
            "FUN_0800a194",
            "FUN_08003aa0",
            "FUN_08005fe8",
            "FUN_08003ce8",
            "FUN_0800738a",
            "FUN_08002948",
            "FUN_08009e64",
            "FUN_08002acc",
            "FUN_0800932c",
            "FUN_080099a4",
            "FUN_08005a1c",
            "FUN_08006b0c",
            "FUN_08007320",
            "FUN_080002ec",
            "FUN_08000be8",
            "FUN_08003fd8",
            "FUN_0800307a",
            "FUN_08002ca4",
            "FUN_0800319e",
            "FUN_08008d00",
            "FUN_08004b82",
            "FUN_0800997e",
            "FUN_0800779c",
            "FUN_08002dbc",
            "FUN_08007f78",
            "FUN_08006b28",
            "FUN_08006b1c",
            "FUN_0800a130",
            "FUN_08008f3c",
            "FUN_08007332",
            "FUN_08006128",
            "FUN_0800a258",
            "FUN_08002cb8",
            "FUN_08008f50",
            "FUN_08004a76",
            "FUN_0800877c",
            "FUN_080047f4",
            "FUN_08005a48",
            "FUN_080033a8",
            "FUN_08008d18",
            "FUN_0800a020",
            "FUN_08007f7c",
            "FUN_08006d80",
            "FUN_08006c60",
            "FUN_08008e40",
            "FUN_080045c0",
            "FUN_08007e74",
            "FUN_08002ddc",
            "FUN_08009f2c",
            "FUN_0800a154",
            "FUN_08007f8e",
            "FUN_08006b3e",
            "FUN_08006262",
            "FUN_08007110",
            "FUN_08007594",
            "FUN_08002cd0",
            "FUN_08002df6",
            "FUN_08007118",
            "FUN_08001be8",
            "FUN_08005a68",
            "FUN_08008f78",
            "FUN_08002dea",
            "FUN_0800734a",
            "FUN_08000aec",
            "FUN_080068d6",
            "FUN_080032a2",
            "FUN_08009e28",
            "FUN_0800a01c",
            "FUN_08006390",
            "FUN_08008730",
            "FUN_08008854",
            "FUN_08004d6c",
            "FUN_08007760",
            "FUN_08008850",
            "FUN_08002fc2",
            "FUN_08008afa",
            "FUN_080038dc",
            "FUN_080025ac",
            "FUN_08007648",
            "FUN_08008858",
            "FUN_08004a24",
            "FUN_08002fba",
            "FUN_080090cc",
            "FUN_080049e0",
            "FUN_08006d24",
            "FUN_08008500",
            "FUN_08007774",
            "FUN_080001a8",
            "FUN_080048c8",
            "FUN_08009954",
            "FUN_08005e6e",
            "FUN_08004024",
            "FUN_08008868",
            "FUN_080036ac",
            "FUN_0800643c",
            "FUN_08002fca",
            "FUN_0800a31c",
            "FUN_080026f8",
            "FUN_08007544",
            "FUN_08008990",
            "FUN_08004396",
            "FUN_08003fb0",
            "FUN_08007788",
            "FUN_08002ec4",
            "FUN_08007306",
            "FUN_08008f0e",
            "FUN_0800886c",
            "FUN_080036d8",
            "FUN_0800a110",
            "FUN_08003b8c",
            "FUN_080035b8",
            "FUN_08006460",
            "FUN_08004046",
            "FUN_08008880",
            "FUN_08002ed2",
            "FUN_08008f1c",
            "FUN_080058ac",
            "FUN_08007438",
            "FUN_0800306c",
            "FUN_0800887c",
            "FUN_0800863c",
            "FUN_08004050",
            "FUN_08008e14",
            "FUN_08005a28",
            "FUN_08008ac6",
            "FUN_08003366",
            "FUN_080091b0",
            "FUN_08008abc",
            "FUN_08002b68",
            "FUN_080005e0",
            "FUN_0800674e",
            "FUN_0800771c",
            "FUN_08003370",
            "FUN_08003376",
            "FUN_08008bf4",
            "FUN_08002c7c",
            "FUN_08005430",
            "FUN_08009918",
            "FUN_08005434",
            "FUN_08005e2e",
            "FUN_08007736",
            "FUN_08002c90",
            "FUN_0800542a",
            "FUN_0800457c",
            "FUN_080091c6",
            "FUN_08003a20",
            "FUN_08002a58",
            "FUN_080004d4",
            "FUN_08002fa0",
            "FUN_08003a1c",
            "FUN_08007744",
            "FUN_08006538",
            "FUN_08002fa8",
            "FUN_0800325a",
            "FUN_080091d8",
            "FUN_0800688e",
            "FUN_080090b4",
            "FUN_0800870c",
            "FUN_08008840",
            "FUN_08008600",
            "FUN_08003154",
            "FUN_08006420",
            "FUN_08007750",
            "FUN_08009938",
            "FUN_08007f0e",
            "FUN_08004004",
            "FUN_08003158",
            "FUN_080090c2",
            "FUN_08008846",
            "FUN_0800459c",
            "FUN_0800774a",
            "FUN_0800314e",
            "FUN_080036a0",
            "FUN_080038e4",
            "FUN_08005d48",
            "FUN_08008ba4",
            "FUN_08009ff8",
            "FUN_08009db0",
            "FUN_08002c2c",
            "FUN_080072f0",
            "FUN_08000178",
            "FUN_08000a64",
            "FUN_08002c40",
            "FUN_0800694c",
            "FUN_0800a0ec",
            "FUN_08008df8",
            "FUN_08000188",
            "FUN_08004f3c",
            "FUN_0800344a",
            "FUN_080071e4",
            "FUN_08002c54",
            "FUN_080072fa",
            "FUN_08003346",
            "FUN_08003106",
            "FUN_08007708",
            "FUN_0800018c",
            "FUN_08003f94",
            "FUN_08002c68",
            "FUN_0800430c",
            "FUN_08003350",
            "FUN_08007710",
            "FUN_08003474",
            "FUN_08008804",
            "FUN_08004e3c",
            "FUN_08007718",
            "FUN_08002a30",
            "FUN_08009cd0",
            "FUN_0800322c",
            "FUN_08003760",
            "FUN_08000130",
            "FUN_08002798",
            "FUN_0800242c",
            "FUN_08002e44",
            "FUN_0800a0a8",
            "FUN_08003f30",
            "FUN_080073d8",
            "FUN_080085dc",
            "FUN_08008db0",
            "FUN_08002444",
            "FUN_0800906c",
            "FUN_08003658",
            "FUN_08009a80",
            "FUN_080062f4",
            "FUN_080073e8",
            "FUN_0800267c",
            "FUN_0800376c",
            "FUN_08003e20",
            "FUN_08005840",
            "FUN_08003306",
            "FUN_08002578",
            "FUN_08006932",
            "FUN_080060c4",
            "FUN_08009eac",
            "FUN_08008dbe",
            "FUN_080072d8",
            "FUN_08002b00",
            "FUN_08002f84",
            "FUN_08009094",
            "FUN_0800a0cc",
            "FUN_08002580",
            "FUN_080073ec",
            "FUN_08008ef4",
            "FUN_08002c1e",
            "FUN_08002f94",
            "FUN_08001b48",
            "FUN_08005df4",
            "FUN_08009148",
            "FUN_080099dc",
            "FUN_08009024",
            "FUN_080064cc",
            "FUN_08008058",
            "FUN_08004ac2",
            "FUN_08006ca8",
            "FUN_08000214",
            "FUN_08005bb8",
            "FUN_080063c0",
            "FUN_0800274c",
            "FUN_08009270",
            "FUN_08009038",
            "FUN_08005aa4",
            "FUN_08008068",
            "FUN_08002400",
            "FUN_08000588",
            "FUN_08002644",
            "FUN_08002f1e",
            "FUN_0800902e",
            "FUN_08009042",
            "FUN_08009c7c",
            "FUN_08009b5c",
            "FUN_08008a6c",
            "FUN_080085b8",
            "FUN_08001c08",
            "FUN_080075dc",
            "FUN_080087ec",
            "FUN_08007ff0",
            "FUN_08002774",
            "FUN_080052f0",
            "FUN_08002f2c",
            "FUN_08004954",
            "FUN_08005cec",
            "FUN_08003748",
            "FUN_080040e8",
            "FUN_08009b6c",
            "FUN_0800010c",
            "FUN_080086e8",
            "FUN_08001c18",
            "FUN_08009056",
            "FUN_08002e1a",
            "FUN_0800904c",
            "FUN_080073ae",
            "FUN_08003f0c",
            "FUN_08000488",
            "FUN_08006bb8",
            "FUN_08004aec",
            "FUN_08007ede",
            "FUN_08004728",
            "FUN_080074e0",
            "FUN_080073c0",
            "FUN_080084b0",
            "FUN_080095a8",
            "FUN_08008b2a",
            "FUN_08003bd8",
            "FUN_08009d50",
            "FUN_08009108",
            "FUN_08009f98",
            "FUN_08008a24",
            "FUN_08008020",
            "FUN_08005dac",
            "FUN_080066e8",
            "FUN_08009358",
            "FUN_0800270c",
            "FUN_08007fa0",
            "FUN_08002720",
            "FUN_080031ce",
            "FUN_08008b52",
            "FUN_08002968",
            "FUN_08004ccc",
            "FUN_080042d4",
            "FUN_0800a07a",
            "FUN_080064b0",
            "FUN_08006092",
            "FUN_08008d8c",
            "FUN_08008038",
            "FUN_08005cb4",
            "FUN_080042e2",
            "FUN_080088e0",
            "FUN_08008b66",
            "FUN_0800a3a0",
            "FUN_08008048",
            "FUN_080053cc",
            "FUN_080087bc",
            "FUN_080042f0",
            "FUN_080087d4",
            "FUN_0800a09e",
            "FUN_080076e0"
        ],
        [
            "FUN_08002ce0",
            "FUN_08002ac0",
            "FUN_08002ef2",
            "FUN_08002efe",
            "FUN_08008d30",
            "FUN_08003048",
            "FUN_0800885c",
            "FUN_08003002",
            "FUN_08009908",
            "FUN_08009cdc",
            "FUN_080026b0",
            "FUN_080027f0",
            "FUN_080036a2",
            "FUN_08002a26",
            "FUN_080091a0",
            "FUN_08002a1c",
            "FUN_08009190",
            "FUN_08002c00",
            "FUN_08008ed6",
            "FUN_08002c14",
            "FUN_08009084",
            "FUN_08009fe8",
            "FUN_08008eec",
            "FUN_08003724",
            "FUN_08002f0a",
            "FUN_08002634",
            "FUN_080098d8",
            "FUN_0800288c",
            "FUN_08002e26",
            "FUN_0800a18c",
            "FUN_08009124",
            "FUN_08002f14"
        ]
    ],
    "locked_functions": []
}