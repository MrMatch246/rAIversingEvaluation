{
    "functions": {
        "FUN_08000188": {
            "entrypoint": "0x08000188",
            "current_name": "initialize_completed_flag_08000188",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08000194) */\n\nundefined4 initializeCompletedFlag_08000188(undefined4 param)\n\n{\n  if ((char)completedFlag == '\\0') {\n    completedFlag._0_1_ = '\\x01';\n  }\n  return param;\n}\n\n",
            "renaming": {
                "FUN_08000188": "initialize_completed_flag_08000188",
                "param_1": "param",
                "completed_8911": "completedFlag"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080001ac": {
            "entrypoint": "0x080001ac",
            "current_name": "concatenate_parameters_080001ac",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080001b2) */\n\nundefined8 concatenate_parameters_080001ac(undefined4 source_param,undefined4 dest_param)\n\n{\n  return CONCAT44(dest_param,source_param);\n}\n\n",
            "renaming": {
                "FUN_080001ac": "concatenate_parameters_080001ac",
                "param_1": "source_param",
                "param_2": "dest_param"
            },
            "calling": [
                "__libc_init_array",
                "__libc_fini_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080001c8": {
            "entrypoint": "0x080001c8",
            "current_name": "FUNC_080001c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080001c8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080001c8": "FUNC_080001c8"
            },
            "calling": [
                "coolant_run"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080001d4": {
            "entrypoint": "0x080001d4",
            "current_name": "FUNC_080001d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080001d4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080001d4": "FUNC_080001d4"
            },
            "calling": [
                "coolant_stop"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080001e0": {
            "entrypoint": "0x080001e0",
            "current_name": "FUNC_080001e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080001e0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080001e0": "FUNC_080001e0"
            },
            "calling": [
                "coolant_run"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080001ec": {
            "entrypoint": "0x080001ec",
            "current_name": "FUNC_080001ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080001ec(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080001ec": "FUNC_080001ec"
            },
            "calling": [
                "coolant_stop"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080001f8": {
            "entrypoint": "0x080001f8",
            "current_name": "initialize_coolant_system_080001f8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeCoolantSystem_080001f8(void)\n\n{\n  coolantMode = '\\0';\n  stopCoolant();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080001f8": "initialize_coolant_system_080001f8",
                "current_coolant_mode": "coolantMode",
                "coolant_stop": "stopCoolant"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [
                "coolant_stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000210": {
            "entrypoint": "0x08000210",
            "current_name": "turn_off_coolant_system_08000210",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid turn_off_coolant_system_08000210(void)\n\n{\n  turn_off_coolant_mist();\n  turn_off_coolant_flood();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000210": "turn_off_coolant_system_08000210",
                "coolant_mist_off": "turn_off_coolant_mist",
                "coolant_flood_off": "turn_off_coolant_flood"
            },
            "calling": [
                "mc_reset",
                "coolant_run",
                "coolant_init"
            ],
            "called": [
                "coolant_mist_off",
                "coolant_flood_off"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000220": {
            "entrypoint": "0x08000220",
            "current_name": "update_coolant_mode_08000220",
            "code": "\nvoid updateCoolantMode_08000220(uint8_t newMode)\n\n{\n  uint8_t localMode;\n  \n  if (newMode != currentMode) {\n    plan_synchronize();\n    if (newMode == '\\x01') {\n      coolant_flood_on();\n      currentMode = newMode;\n    }\n    else if (newMode == '\\x02') {\n      coolant_mist_on();\n      currentMode = newMode;\n    }\n    else {\n      coolant_stop();\n      currentMode = newMode;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000220": "update_coolant_mode_08000220",
                "mode": "newMode",
                "mode_local": "localMode",
                "current_coolant_mode": "currentMode"
            },
            "calling": [
                "gc_execute_line"
            ],
            "called": [
                "coolant_mist_on",
                "plan_synchronize",
                "coolant_flood_on",
                "coolant_stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000268": {
            "entrypoint": "0x08000268",
            "current_name": "calculate_elapsed_time_08000268",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint64_t calculateElapsedTime_08000268(void)\n\n{\n  uint32_t tick;\n  \n  tick = HAL_GetTick();\n  return (uint64_t)((tick + 1) * 1000 - _DAT_e000e018 / 0xa8);\n}\n\n",
            "renaming": {
                "FUN_08000268": "calculate_elapsed_time_08000268",
                "uVar1": "tick"
            },
            "calling": [
                "_delay_us"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080002a0": {
            "entrypoint": "0x080002a0",
            "current_name": "delay_milliseconds_080002a0",
            "code": "\nvoid delayMilliseconds_080002a0(uint milliseconds)\n\n{\n  uint milliseconds_local;\n  \n  HAL_Delay(milliseconds);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080002a0": "delay_milliseconds_080002a0",
                "_ms": "milliseconds"
            },
            "calling": [
                "mc_dwell"
            ],
            "called": [
                "HAL_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080002b6": {
            "entrypoint": "0x080002b6",
            "current_name": "delay_microseconds_080002b6",
            "code": "\nvoid delayMicroseconds_080002b6(uint microseconds)\n\n{\n  uint upperBits;\n  bool isTimeout;\n  uint64_t currentTimestamp;\n  uint64_t currentTimestamp2;\n  uint microsecondsCopy;\n  uint64_t timeoutTimestamp;\n  \n  currentTimestamp = get_currentmicrosecondsecs();\n  do {\n    currentTimestamp2 = get_currentmicrosecondsecs();\n    upperBits = (uint)(currentTimestamp2 >> 0x20);\n    timeoutTimestamp._0_4_ = (uint)(currentTimestamp + microseconds);\n    timeoutTimestamp._4_4_ = (uint)(currentTimestamp + microseconds >> 0x20);\n    isTimeout = timeoutTimestamp._4_4_ <= upperBits;\n    if (upperBits == timeoutTimestamp._4_4_) {\n      isTimeout = (uint)timeoutTimestamp <= (uint)currentTimestamp2;\n    }\n  } while (!isTimeout);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080002b6": "delay_microseconds_080002b6",
                "_us": "microseconds",
                "uVar1": "upperBits",
                "bVar2": "isTimeout",
                "uVar3": "currentTimestamp",
                "uVar4": "currentTimestamp2",
                "_us_local": "microsecondsCopy",
                "timeout": "timeoutTimestamp"
            },
            "calling": [],
            "called": [
                "get_current_usecs"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080002f0": {
            "entrypoint": "0x080002f0",
            "current_name": "initialize_eeprom_data_080002f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeEepromData_080002f0(void)\n\n{\n  memset(eepromData,0xff,4);\n  eepromReady = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080002f0": "initialize_eeprom_data_080002f0",
                "eeprom_data": "eepromData",
                "eeprom_ready": "eepromReady"
            },
            "calling": [
                "eeprom_put_char",
                "memcpy_to_eeprom_with_checksum",
                "eeprom_get_char",
                "memcpy_from_eeprom_with_checksum"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000310": {
            "entrypoint": "0x08000310",
            "current_name": "read_eeprom_data_08000310",
            "code": "\nchar readEEPROMData_08000310(uint address)\n\n{\n  uint localAddress;\n  \n  if (eeprom_ready == 0) {\n    eeprom_init();\n  }\n  return eeprom_data[address & 0x3ff];\n}\n\n",
            "renaming": {
                "FUN_08000310": "read_eeprom_data_08000310",
                "addr": "address",
                "addr_local": "localAddress"
            },
            "calling": [
                "read_global_settings",
                "memcpy_from_eeprom_with_checksum"
            ],
            "called": [
                "eeprom_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000340": {
            "entrypoint": "0x08000340",
            "current_name": "write_to_eeprom_08000340",
            "code": "\nvoid writeToEEPROM_08000340(uint address,uchar value)\n\n{\n  uchar localValue;\n  uint localAddress;\n  \n  if (eeprom_ready == 0) {\n    eeprom_init();\n  }\n  eeprom_data[address & 0x3ff] = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000340": "write_to_eeprom_08000340",
                "addr": "address",
                "new_value": "value",
                "new_value_local": "localValue",
                "addr_local": "localAddress"
            },
            "calling": [
                "write_global_settings",
                "memcpy_to_eeprom_with_checksum"
            ],
            "called": [
                "eeprom_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000374": {
            "entrypoint": "0x08000374",
            "current_name": "copy_and_checksum_08000374",
            "code": "\nvoid copyAndChecksum_08000374(uint destAddress,char *srcAddress,uint numBytes)\n\n{\n  uint remainingBytes;\n  char *currentSrcAddr;\n  uint currentDestAddr;\n  uchar checkSum;\n  \n  checkSum = '\\0';\n  remainingBytes = numBytes;\n  currentSrcAddr = srcAddress;\n  currentDestAddr = destAddress;\n  if (eeprom_ready == 0) {\n    eeprom_init();\n    currentSrcAddr = srcAddress;\n    currentDestAddr = destAddress;\n  }\n  for (; remainingBytes != 0; remainingBytes = remainingBytes - 1) {\n    checkSum = (checkSum != '\\0') + *currentSrcAddr;\n    eeprom_put_char(currentDestAddr,*currentSrcAddr);\n    currentSrcAddr = currentSrcAddr + 1;\n    currentDestAddr = currentDestAddr + 1;\n  }\n  eeprom_put_char(currentDestAddr,checkSum);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000374": "copy_and_checksum_08000374",
                "destination": "destAddress",
                "source": "srcAddress",
                "size": "numBytes",
                "size_local": "remainingBytes",
                "source_local": "currentSrcAddr",
                "destination_local": "currentDestAddr",
                "checksum": "checkSum"
            },
            "calling": [
                "write_global_settings",
                "settings_write_coord_data",
                "settings_store_startup_line"
            ],
            "called": [
                "eeprom_init",
                "eeprom_put_char"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003ec": {
            "entrypoint": "0x080003ec",
            "current_name": "verify_data_integrity_080003ec",
            "code": "\nint verify_data_integrity_080003ec(char *output,uint input_source,uint num_bytes)\n\n{\n  char cVar1;\n  uint remaining_bytes;\n  uint current_source;\n  char *current_output;\n  uchar current_byte;\n  uchar calculated_checksum;\n  \n  calculated_checksum = '\\0';\n  remaining_bytes = num_bytes;\n  current_source = input_source;\n  current_output = output;\n  if (is_eeprom_ready == 0) {\n    initialize_eeprom();\n    current_source = input_source;\n    current_output = output;\n  }\n  for (; remaining_bytes != 0; remaining_bytes = remaining_bytes - 1) {\n    cVar1 = read_eeprom_byte(current_source);\n    calculated_checksum = cVar1 + (calculated_checksum != '\\0');\n    *current_output = cVar1;\n    current_source = current_source + 1;\n    current_output = current_output + 1;\n  }\n  cVar1 = read_eeprom_byte(current_source);\n  return (uint)((uint)calculated_checksum == (int)cVar1);\n}\n\n",
            "renaming": {
                "FUN_080003ec": "verify_data_integrity_080003ec",
                "destination": "output",
                "source": "input_source",
                "size": "num_bytes",
                "size_local": "remaining_bytes",
                "source_local": "current_source",
                "destination_local": "current_output",
                "data": "current_byte",
                "checksum": "calculated_checksum",
                "eeprom_ready": "is_eeprom_ready",
                "eeprom_init": "initialize_eeprom",
                "eeprom_get_char": "read_eeprom_byte"
            },
            "calling": [
                "settings_read_startup_line",
                "read_global_settings",
                "settings_read_coord_data"
            ],
            "called": [
                "eeprom_init",
                "eeprom_get_char"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000478": {
            "entrypoint": "0x08000478",
            "current_name": "set_plane_axes_08000478",
            "code": "\nvoid setPlaneAxes_08000478(uint8_t newAxis0,uint8_t newAxis1,uint8_t newAxis2)\n\n{\n  uint8_t localAxis2;\n  uint8_t localAxis1;\n  uint8_t localAxis0;\n  \n  gc.plane_newAxis0 = newAxis0;\n  gc.plane_newAxis1 = newAxis1;\n  gc.plane_newAxis2 = newAxis2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000478": "set_plane_axes_08000478",
                "axis_0": "newAxis0",
                "axis_1": "newAxis1",
                "axis_2": "newAxis2",
                "axis_2_local": "localAxis2",
                "axis_1_local": "localAxis1",
                "axis_0_local": "localAxis0"
            },
            "calling": [
                "gc_execute_line",
                "gc_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004ac": {
            "entrypoint": "0x080004ac",
            "current_name": "initialize_machine_080004ac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeMachine_080004ac(void)\n\n{\n  uint8_t coordDataStatus;\n  \n  memset(&gc,0,0x38);\n  gc.feed_rate = settings.default_feed_rate;\n  select_plane('\\0','\\x01','\\x02');\n  gc.absolute_mode = '\\x01';\n  coordDataStatus = settings_read_coord_data(gc.coord_select,gc.coord_system);\n  if (coordDataStatus == '\\0') {\n    report_status_message('\\n');\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080004ac": "initialize_machine_080004ac",
                "uVar1": "coordDataStatus"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [
                "select_plane",
                "report_status_message",
                "settings_read_coord_data",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004fc": {
            "entrypoint": "0x080004fc",
            "current_name": "update_position_080004fc",
            "code": "\nvoid updatePosition_080004fc(int32_t x_input,int32_t y_input,int32_t z_input)\n\n{\n  undefined4 x_asFloat;\n  int32_t z_input_local;\n  int32_t y_input_local;\n  int32_t x_input_local;\n  \n  x_asFloat = __floatsisf(x_input);\n  positionX = (float)__aeabi_fdiv(x_asFloat,stepsPerMmX);\n  x_asFloat = __floatsisf(y_input);\n  positionY = (float)__aeabi_fdiv(x_asFloat,stepsPerMmY);\n  x_asFloat = __floatsisf(z_input);\n  positionZ = (float)__aeabi_fdiv(x_asFloat,stepsPerMmZ);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080004fc": "update_position_080004fc",
                "x": "x_input",
                "y": "y_input",
                "z": "z_input",
                "uVar1": "x_asFloat",
                "gc.position[0]": "positionX",
                "gc.position[1]": "positionY",
                "gc.position[2]": "positionZ",
                "settings.steps_per_mm[0]": "stepsPerMmX",
                "settings.steps_per_mm[1]": "stepsPerMmY",
                "settings.steps_per_mm[2]": "stepsPerMmZ"
            },
            "calling": [
                "sys_sync_current_position"
            ],
            "called": [
                "__floatsisf",
                "__aeabi_fdiv"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800056c": {
            "entrypoint": "0x0800056c",
            "current_name": "convert_value_if_needed_0800056c",
            "code": "\nfloat convertValueIfNeeded_0800056c(float inputValue)\n\n{\n  undefined4 inputRegister;\n  undefined8 doubleValue;\n  float localValue;\n  \n  if (gc.inches_mode != '\\0') {\n    doubleValue = __aeabi_f2d(inputRegister);\n    doubleValue = __muldf3((int)doubleValue,(int)((ulonglong)doubleValue >> 0x20),0x66666666,0x40396666);\n    inputValue = (float)__truncdfsf2((int)doubleValue,(int)((ulonglong)doubleValue >> 0x20));\n  }\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_0800056c": "convert_value_if_needed_0800056c",
                "value": "inputValue",
                "in_r0": "inputRegister",
                "uVar1": "doubleValue",
                "value_local": "localValue"
            },
            "calling": [
                "gc_execute_line"
            ],
            "called": [
                "__aeabi_f2d",
                "__muldf3",
                "__truncdfsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005b4": {
            "entrypoint": "0x080005b4",
            "current_name": "process_gcode_080005b4",
            "code": "\nuloopIteratornt8_t processGcode_080005b4(charadius *inputString)\n\n{\n  uloopIteratornt8_t errorCode;\n  loopIteratornt result;\n  fbitFlagLoat tempFloat1;\n  undefloopIteratorned4 tempUInt1;\n  undefloopIteratorned4 tempUInt2;\n  undefloopIteratorned4 tempUInt3;\n  undefloopIteratorned4 tempUInt4;\n  undefloopIteratorned4 tempUInt5;\n  undefloopIteratorned4 tempUInt6;\n  undefloopIteratorned4 tempUInt7;\n  undefloopIteratorned4 tempUInt8;\n  uloopIteratornt tempUInt9;\n  undefloopIteratorned4 tempUInt10;\n  undefloopIteratorned4 tempUInt11;\n  uloopIteratornt uVaradius6;\n  fbitFlagLoat fVaradius7;\n  fbitFlagLoat tempFloat2;\n  undefloopIteratorned8 tempDouble1;\n  undefloopIteratorned8 tempDouble2;\n  undefloopIteratorned8 tempDouble3;\n  undefloopIteratorned8 tempDouble4;\n  undefloopIteratorned8 tempDouble5;\n  undefloopIteratorned8 tempDouble6;\n  undefloopIteratorned8 tempDouble7;\n  undefloopIteratorned8 tempDouble8;\n  undefloopIteratorned8 tempDouble9;\n  undefloopIteratorned8 tempDouble10;\n  undefloopIteratorned8 tempDouble11;\n  undefloopIteratorned8 tempDouble12;\n  undefloopIteratorned8 tempDouble13;\n  undefloopIteratorned8 tempDouble14;\n  undefloopIteratorned8 tempDouble15;\n  undefloopIteratorned8 tempDouble16;\n  undefloopIteratorned8 tempDouble17;\n  undefloopIteratorned8 tempDouble18;\n  undefloopIteratorned8 tempDouble19;\n  fbitFlagLoat tempFloat3;\n  undefloopIteratorned8 tempDouble20;\n  undefloopIteratorned8 tempDouble21;\n  fbitFlagLoat tempFloat4;\n  fbitFlagLoat tempFloat5;\n  fbitFlagLoat tempFloat6;\n  fbitFlagLoat tempFloat7;\n  fbitFlagLoat tempFloat8;\n  fbitFlagLoat tempFloat9;\n  fbitFlagLoat tempFloat10;\n  fbitFlagLoat tempFloat11;\n  fbitFlagLoat tempFloat12;\n  fbitFlagLoat tempFloat13;\n  fbitFlagLoat tempFloat14;\n  fbitFlagLoat tempFloat15;\n  fbitFlagLoat tempFloat16;\n  fbitFlagLoat tempFloat17;\n  fbitFlagLoat tempFloat18;\n  fbitFlagLoat tempFloat19;\n  fbitFlagLoat tempFloat20;\n  fbitFlagLoat tempFloat21;\n  fbitFlagLoat tempFloat22;\n  fbitFlagLoat tempFloat23;\n  fbitFlagLoat tempFloat24;\n  fbitFlagLoat tempFloat25;\n  fbitFlagLoat tempFloat26;\n  fbitFlagLoat tempFloat27;\n  fbitFlagLoat tempFloat28;\n  fbitFlagLoat tempFloat29;\n  fbitFlagLoat tempFloat30;\n  fbitFlagLoat tempFloat31;\n  fbitFlagLoat tempFloat32;\n  fbitFlagLoat tempFloat33;\n  fbitFlagLoat tempFloat34;\n  fbitFlagLoat tempFloat35;\n  fbitFlagLoat tempFloat36;\n  fbitFlagLoat tempFloat37;\n  fbitFlagLoat tempFloat38;\n  fbitFlagLoat tempFloat39;\n  fbitFlagLoat tempFloat40;\n  fbitFlagLoat tempFloat41;\n  undefloopIteratorned8 tempDouble22;\n  undefloopIteratorned4 tempUInt12;\n  undefloopIteratorned4 tempUInt13;\n  undefloopIteratorned4 tempUInt14;\n  undefloopIteratorned4 tempUInt15;\n  charadius *localString;\n  fbitFlagLoat coordinateData2 [3];\n  fbitFlagLoat coordinateData1 [3];\n  fbitFlagLoat coordinateData [3];\n  fbitFlagLoat offset [3];\n  fbitFlagLoat taradiusget [3];\n  fbitFlagLoat vabitFlagLue;\n  charadius currentLetter;\n  uloopIteratornt8_t characterCounter;\n  fbitFlagLoat yPos;\n  fbitFlagLoat xPos;\n  uloopIteratornt8_t isClockwise;\n  fbitFlagLoat hOver2DivD;\n  uloopIteratornt8_t loopIterator3;\n  uloopIteratornt8_t loopIterator2;\n  uloopIteratornt8_t loopIterator1;\n  uloopIteratornt8_t loopIterator;\n  uloopIteratornt8_t bitFlagL;\n  fbitFlagLoat radius;\n  fbitFlagLoat pVal;\n  uloopIteratornt8_t groupNumber;\n  uloopIteratornt8_t nonModalAction;\n  uloopIteratornt8_t absoluteOverride;\n  fbitFlagLoat inverseFeedRate;\n  uloopIteratornt8_t axisWords;\n  uloopIteratornt16_t modalGroupWords;\n  loopIteratornt intValue;\n  \n  loopIteratorf (sysState == '\\xPos06') {\n    errorCode = '\\f';\n  }\n  ebitFlagLse {\n    characterCounter = '\\0';\n    modalGroupWords = 0;\n    axisWords = '\\0';\n    inverseFeedRate = -1.0;\n    absoluteOverride = '\\0';\n    nonModalAction = '\\0';\n    memset(taradiusget,0,0xPosc);\n    memset(offset,0,0xPosc);\n    gcStatusCode = '\\0';\n    groupNumber = '\\0';\n    whloopIteratorbitFlagLe (result = nexPost_statement(&currentLetter,&vabitFlagLue,inputString,&characterCounter), result != 0) {\n      tempUInt1 = __aeabloopIterator_f2d(vabitFlagLue);\n      tradiusunc((doubbitFlagLe)CONCAT44(tempUInt13,tempUInt12));\n      intValue = __aeabloopIterator_d2loopIteratorz(tempUInt1,tempUInt3);\n      loopIteratorf (currentLetter == 'G') {\n        swloopIteratortch(intValue) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 0xPos50:\n          groupNumber = '\\xPos02';\n          bradiuseak;\n        case 4:\n        case 10:\n        case 0xPos1c:\n        case 0xPos1e:\n        case 0xPos35:\n        case 0xPos5c:\n          groupNumber = '\\xPos01';\n          bradiuseak;\n        case 0xPos11:\n        case 0xPos12:\n        case 0xPos13:\n          groupNumber = '\\xPos03';\n          bradiuseak;\n        case 0xPos14:\n        case 0xPos15:\n          groupNumber = '\\a';\n          bradiuseak;\n        case 0xPos36:\n        case 0xPos37:\n        case 0xPos38:\n        case 0xPos39:\n        case 0xPos3a:\n        case 0xPos3b:\n          groupNumber = '\\t';\n          bradiuseak;\n        case 0xPos5a:\n        case 0xPos5b:\n          groupNumber = '\\xPos04';\n          bradiuseak;\n        case 0xPos5d:\n        case 0xPos5e:\n          groupNumber = '\\xPos06';\n        }\n        swloopIteratortch(intValue) {\n        case 0:\n          gcMotionMode = '\\0';\n          bradiuseak;\n        case 1:\n          gcMotionMode = '\\xPos01';\n          bradiuseak;\n        case 2:\n          gcMotionMode = '\\xPos02';\n          bradiuseak;\n        case 3:\n          gcMotionMode = '\\xPos03';\n          bradiuseak;\n        case 4:\n          nonModalAction = '\\xPos01';\n          bradiuseak;\n        defaubitFlagLt:\n          gcStatusCode = '\\xPos03';\n          bradiuseak;\n        case 10:\n          nonModalAction = '\\xPos02';\n          bradiuseak;\n        case 0xPos11:\n          sebitFlagLect_pValbitFlagLane('\\0','\\xPos01','\\xPos02');\n          bradiuseak;\n        case 0xPos12:\n          sebitFlagLect_pValbitFlagLane('\\xPos02','\\0','\\xPos01');\n          bradiuseak;\n        case 0xPos13:\n          sebitFlagLect_pValbitFlagLane('\\xPos01','\\xPos02','\\0');\n          bradiuseak;\n        case 0xPos14:\n          gcInchesMode = '\\xPos01';\n          bradiuseak;\n        case 0xPos15:\n          gcInchesMode = '\\0';\n          bradiuseak;\n        case 0xPos1c:\n        case 0xPos1e:\n          tempUInt1 = __aeabloopIterator_fmubitFlagL(vabitFlagLue,0xPos41200000);\n          tempUInt1 = __aeabloopIterator_f2d(tempUInt1);\n          tradiusunc((doubbitFlagLe)CONCAT44(tempUInt13,tempUInt12));\n          intValue = __aeabloopIterator_d2loopIteratorz(tempUInt1,tempUInt4);\n          swloopIteratortch(intValue) {\n          case 0xPos118:\n            nonModalAction = '\\xPos03';\n            bradiuseak;\n          case 0xPos119:\n            nonModalAction = '\\xPos04';\n            bradiuseak;\n          defaubitFlagLt:\n            gcStatusCode = '\\xPos03';\n            bradiuseak;\n          case 300:\n            nonModalAction = '\\xPos05';\n            bradiuseak;\n          case 0xPos12d:\n            nonModalAction = '\\xPos06';\n          }\n          bradiuseak;\n        case 0xPos35:\n          absoluteOverride = '\\xPos01';\n          bradiuseak;\n        case 0xPos36:\n        case 0xPos37:\n        case 0xPos38:\n        case 0xPos39:\n        case 0xPos3a:\n        case 0xPos3b:\n          gcCoordSelect = (charadius)intValue + 0xPosca;\n          bradiuseak;\n        case 0xPos50:\n          gcMotionMode = '\\xPos04';\n          bradiuseak;\n        case 0xPos5a:\n          gcAbsoluteMode = '\\xPos01';\n          bradiuseak;\n        case 0xPos5b:\n          gcAbsoluteMode = '\\0';\n          bradiuseak;\n        case 0xPos5c:\n          tempUInt1 = __aeabloopIterator_fmubitFlagL(vabitFlagLue,0xPos41200000);\n          tempUInt1 = __aeabloopIterator_f2d(tempUInt1);\n          tradiusunc((doubbitFlagLe)CONCAT44(tempUInt13,tempUInt12));\n          intValue = __aeabloopIterator_d2loopIteratorz(tempUInt1,tempUInt5);\n          loopIteratorf (intValue == 0xPos398) {\n            nonModalAction = '\\a';\n          }\n          ebitFlagLse loopIteratorf (intValue == 0xPos399) {\n            nonModalAction = '\\b';\n          }\n          ebitFlagLse {\n            gcStatusCode = '\\xPos03';\n          }\n          bradiuseak;\n        case 0xPos5d:\n          gcInverseFeedRateMode = '\\xPos01';\n          bradiuseak;\n        case 0xPos5e:\n          gcInverseFeedRateMode = '\\0';\n        }\n      }\n      ebitFlagLse loopIteratorf (currentLetter == 'M') {\n        loopIteratorf (intValue == 0xPos1e) {\nLAB_08000b96:\n          groupNumber = '\\xPos05';\n        }\n        ebitFlagLse loopIteratorf (intValue < 0xPos1f) {\n          loopIteratorf (intValue < 3) {\n            loopIteratorf (-1 < intValue) goto LAB_08000b96;\n          }\n          ebitFlagLse loopIteratorf (intValue - 3U < 3) {\n            groupNumber = '\\b';\n          }\n        }\n        swloopIteratortch(intValue) {\n        case 0:\n          gcProgramFlow = '\\xPos01';\n          bradiuseak;\n        case 1:\n          bradiuseak;\n        case 2:\n        case 0xPos1e:\n          gcProgramFlow = '\\xPos02';\n          bradiuseak;\n        case 3:\n          gcSpindleDirection = '\\xPos01';\n          bradiuseak;\n        case 4:\n          gcSpindleDirection = -1;\n          bradiuseak;\n        case 5:\n          gcSpindleDirection = '\\0';\n          bradiuseak;\n        defaubitFlagLt:\n          gcStatusCode = '\\xPos03';\n          bradiuseak;\n        case 7:\n          gcCoolantMode = '\\xPos02';\n          bradiuseak;\n        case 8:\n          gcCoolantMode = '\\xPos01';\n          bradiuseak;\n        case 9:\n          gcCoolantMode = '\\0';\n        }\n      }\n      loopIteratorf (groupNumber != '\\0') {\n        loopIteratorf (((loopIteratornt)(uloopIteratornt)modalGroupWords >> groupNumber & 1U) == 0) {\n          modalGroupWords = modalGroupWords | (ushoradiust)(1 << groupNumber);\n        }\n        ebitFlagLse {\n          gcStatusCode = '\\xPos05';\n        }\n        groupNumber = '\\0';\n      }\n    }\n    errorCode = gcStatusCode;\n    loopIteratorf (gcStatusCode == '\\0') {\n      pVal = 0.0;\n      radius = 0.0;\n      bitFlagL = '\\0';\n      characterCounter = '\\0';\nswloopIteratortchD_08000d18_caseD_47:\n      result = nexPost_statement(&currentLetter,&vabitFlagLue,inputString,&characterCounter);\n      loopIteratorf (result != 0) {\n        fVaradius7 = (fbitFlagLoat)tempDouble1;\n        swloopIteratortch(currentLetter) {\n        case 'F':\n          result = __aeabloopIterator_fcmpValbitFlagLe(vabitFlagLue,0);\n          loopIteratorf (result != 0) {\n            gcStatusCode = '\\xPos06';\n          }\n          loopIteratorf (gcInverseFeedRateMode == '\\0') {\n            fVaradius7 = vabitFlagLue;\n            to_mloopIteratorbitFlagLbitFlagLloopIteratormeteradiuss(tempFloat2);\n            gcFeedRate = fVaradius7;\n          }\n          ebitFlagLse {\n            fVaradius7 = vabitFlagLue;\n            to_mloopIteratorbitFlagLbitFlagLloopIteratormeteradiuss(tempFloat2);\n            inverseFeedRate = fVaradius7;\n          }\n          bradiuseak;\n        case 'G':\n        case 'M':\n        case 'N':\n          bradiuseak;\n        defaubitFlagLt:\n          gcStatusCode = '\\xPos03';\n          bradiuseak;\n        case 'I':\n        case 'J':\n        case 'K':\n          uVaradius6 = (uloopIteratornt)(byPoste)currentLetter;\n          tempFloat1 = vabitFlagLue;\n          to_mloopIteratorbitFlagLbitFlagLloopIteratormeteradiuss(fVaradius7);\n          offset[uVaradius6 - 0xPos49] = tempFloat1;\n          bradiuseak;\n        case 'L':\n          tempUInt1 = __aeabloopIterator_f2d(vabitFlagLue);\n          tradiusunc((doubbitFlagLe)CONCAT44(tempUInt13,tempUInt12));\n          bitFlagL = __aeabloopIterator_d2uloopIteratorz(tempUInt1,tempUInt6);\n          bradiuseak;\n        case 'P':\n          pVal = vabitFlagLue;\n          bradiuseak;\n        case 'R':\n          tempFloat1 = vabitFlagLue;\n          to_mloopIteratorbitFlagLbitFlagLloopIteratormeteradiuss(fVaradius7);\n          radius = tempFloat1;\n          bradiuseak;\n        case 'S':\n          result = __aeabloopIterator_fcmpValbitFlagLt(vabitFlagLue,0);\n          loopIteratorf (result != 0) {\n            gcStatusCode = '\\xPos06';\n          }\n          bradiuseak;\n        case 'T':\n          result = __aeabloopIterator_fcmpValbitFlagLt(vabitFlagLue,0);\n          loopIteratorf (result != 0) {\n            gcStatusCode = '\\xPos06';\n          }\n          tempUInt1 = __aeabloopIterator_f2d(vabitFlagLue);\n          tradiusunc((doubbitFlagLe)CONCAT44(tempUInt13,tempUInt12));\n          gcTool = __aeabloopIterator_d2uloopIteratorz(tempUInt1,tempUInt7);\n          bradiuseak;\n        case 'X':\n          taradiusget[0] = vabitFlagLue;\n          to_mloopIteratorbitFlagLbitFlagLloopIteratormeteradiuss(fVaradius7);\n          axisWords = axisWords | 1;\n          bradiuseak;\n        case 'Y':\n          taradiusget[1] = vabitFlagLue;\n          to_mloopIteratorbitFlagLbitFlagLloopIteratormeteradiuss(fVaradius7);\n          axisWords = axisWords | 2;\n          bradiuseak;\n        case 'Z':\n          taradiusget[2] = vabitFlagLue;\n          to_mloopIteratorbitFlagLbitFlagLloopIteratormeteradiuss(fVaradius7);\n          axisWords = axisWords | 4;\n        }\n        goto swloopIteratortchD_08000d18_caseD_47;\n      }\n      errorCode = gcStatusCode;\n      loopIteratorf (gcStatusCode == '\\0') {\n        tempDouble22 = tempDouble1;\n        fVaradius7 = tempFloat4;\n        tempFloat1 = tempFloat23;\n        loopIteratorf (sysState != '\\a') {\n          spValloopIteratorndbitFlagLe_radiusun(gcSpindleDirection);\n          coobitFlagLant_radiusun(gcCoolantMode);\n          tempDouble22 = tempDouble2;\n          fVaradius7 = tempFloat5;\n          tempFloat1 = tempFloat24;\n        }\n        loopIteratorf ((modalGroupWords & 0xPos200) != 0) {\n          errorCode = settloopIteratorngs_radiusead_coordinateData(gcCoordSelect,coordinateData);\n          loopIteratorf (errorCode == '\\0') {\n            radiuseturadiusn '\\n';\n          }\n          gcCoordSystem[0] = coordinateData[0];\n          gcCoordSystem[1] = coordinateData[1];\n          gcCoordSystem[2] = coordinateData[2];\n          tempDouble22 = tempDouble3;\n          fVaradius7 = tempFloat6;\n          tempFloat1 = tempFloat25;\n        }\n        swloopIteratortch(nonModalAction) {\n        case '\\xPos01':\n          result = __aeabloopIterator_fcmpValbitFlagLt(pVal,0);\n          tempDouble22 = tempDouble4;\n          fVaradius7 = tempFloat7;\n          tempFloat1 = tempFloat26;\n          loopIteratorf (result == 0) {\n            loopIteratorf (sysState != '\\a') {\n              mc_dwebitFlagLbitFlagL((fbitFlagLoat)tempDouble4);\n              tempDouble22 = tempDouble5;\n              fVaradius7 = tempFloat8;\n              tempFloat1 = tempFloat27;\n            }\n          }\n          ebitFlagLse {\n            gcStatusCode = '\\xPos06';\n          }\n          bradiuseak;\n        case '\\xPos02':\n          tempUInt1 = __aeabloopIterator_f2d(pVal);\n          tradiusunc((doubbitFlagLe)CONCAT44(tempUInt13,tempUInt12));\n          intValue = __aeabloopIterator_d2loopIteratorz(tempUInt1,tempUInt8);\n          tempDouble22 = tempDouble6;\n          fVaradius7 = tempFloat9;\n          tempFloat1 = tempFloat28;\n          loopIteratorf ((((bitFlagL == '\\xPos02') || (bitFlagL == '\\xPos14')) && (-1 < intValue)) && (intValue < 7)) {\n            loopIteratorf ((axisWords == '\\0') && (bitFlagL == '\\xPos02')) {\n              gcStatusCode = '\\xPos06';\n            }\n            ebitFlagLse {\n              loopIteratorf (intValue < 1) {\n                intValue = (loopIteratornt)gcCoordSelect;\n              }\n              ebitFlagLse {\n                intValue = intValue + -1;\n              }\n              errorCode = settloopIteratorngs_radiusead_coordinateData((uloopIteratornt8_t)intValue,coordinateData2);\n              loopIteratorf (errorCode == '\\0') {\n                radiuseturadiusn '\\n';\n              }\n              foradius (loopIterator = '\\0'; loopIterator < 3; loopIterator = loopIterator + '\\xPos01') {\n                loopIteratorf (((loopIteratornt)(uloopIteratornt)axisWords >> loopIterator & 1U) != 0) {\n                  loopIteratorf (bitFlagL == '\\xPos14') {\n                    uVaradius6 = (uloopIteratornt)loopIterator;\n                    fVaradius7 = (fbitFlagLoat)__aeabloopIterator_fsub(gcPosition[loopIterator],taradiusget[loopIterator]);\n                    coordinateData2[uVaradius6] = fVaradius7;\n                  }\n                  ebitFlagLse {\n                    coordinateData2[loopIterator] = taradiusget[loopIterator];\n                  }\n                }\n              }\n              settloopIteratorngs_wradiusloopIteratorte_coordinateData((uloopIteratornt8_t)intValue,coordinateData2);\n              tempDouble22 = tempDouble7;\n              fVaradius7 = tempFloat10;\n              tempFloat1 = tempFloat29;\n              loopIteratorf (intValue == (uloopIteratornt)gcCoordSelect) {\n                gcCoordSystem[0] = coordinateData2[0];\n                gcCoordSystem[1] = coordinateData2[1];\n                gcCoordSystem[2] = coordinateData2[2];\n              }\n            }\n          }\n          ebitFlagLse {\n            gcStatusCode = '\\xPos03';\n          }\n          axisWords = '\\0';\n          bradiuseak;\n        case '\\xPos03':\n        case '\\xPos05':\n          loopIteratorf (axisWords != '\\0') {\n            foradius (loopIterator1 = '\\0'; loopIterator1 < 3; loopIterator1 = loopIterator1 + '\\xPos01') {\n              loopIteratorf (((loopIteratornt)(uloopIteratornt)axisWords >> loopIterator1 & 1U) == 0) {\n                taradiusget[loopIterator1] = gcPosition[loopIterator1];\n              }\n              ebitFlagLse loopIteratorf (gcAbsoluteMode == '\\0') {\n                uVaradius6 = (uloopIteratornt)loopIterator1;\n                fVaradius7 = (fbitFlagLoat)__addsf3(taradiusget[loopIterator1],gcPosition[loopIterator1]);\n                taradiusget[uVaradius6] = fVaradius7;\n                tempDouble22 = tempDouble9;\n                fVaradius7 = tempFloat12;\n                tempFloat1 = tempFloat31;\n              }\n              ebitFlagLse {\n                fVaradius7 = taradiusget[loopIterator1];\n                tempUInt1 = __addsf3(gcCoordSystem[loopIterator1],gcCoordOffset[loopIterator1]);\n                uVaradius6 = (uloopIteratornt)loopIterator1;\n                fVaradius7 = (fbitFlagLoat)__addsf3(fVaradius7,tempUInt1);\n                taradiusget[uVaradius6] = fVaradius7;\n                tempDouble22 = tempDouble8;\n                fVaradius7 = tempFloat11;\n                tempFloat1 = tempFloat30;\n              }\n            }\n            mc_inputString((fbitFlagLoat)tempDouble22,(fbitFlagLoat)((ubitFlagLongbitFlagLong)tempDouble22 >> 0xPos20),fVaradius7,tempFloat1,SUB41(taradiusget[0],0));\n          }\n          loopIteratorf (nonModalAction == '\\xPos05') {\n            errorCode = settloopIteratorngs_radiusead_coordinateData('\\a',coordinateData1);\n            tempDouble22 = tempDouble10;\n            fVaradius7 = tempFloat13;\n            tempFloat1 = tempFloat32;\n            loopIteratorf (errorCode == '\\0') {\n              radiuseturadiusn '\\n';\n            }\n          }\n          ebitFlagLse {\n            errorCode = settloopIteratorngs_radiusead_coordinateData('\\xPos06',coordinateData1);\n            tempDouble22 = tempDouble11;\n            fVaradius7 = tempFloat14;\n            tempFloat1 = tempFloat33;\n            loopIteratorf (errorCode == '\\0') {\n              radiuseturadiusn '\\n';\n            }\n          }\n          tempUInt12 = 0;\n          mc_inputString((fbitFlagLoat)tempDouble22,(fbitFlagLoat)((ubitFlagLongbitFlagLong)tempDouble22 >> 0xPos20),fVaradius7,tempFloat1,\n                  SUB41(coordinateData1[0],0));\n          gcPosition[0] = coordinateData1[0];\n          gcPosition[1] = coordinateData1[1];\n          gcPosition[2] = coordinateData1[2];\n          axisWords = '\\0';\n          tempDouble22 = tempDouble12;\n          fVaradius7 = tempFloat15;\n          tempFloat1 = tempFloat34;\n          bradiuseak;\n        case '\\xPos04':\n        case '\\xPos06':\n          loopIteratorf (nonModalAction == '\\xPos06') {\n            settloopIteratorngs_wradiusloopIteratorte_coordinateData('\\a',gcPosition);\n            tempDouble22 = tempDouble13;\n            fVaradius7 = tempFloat16;\n            tempFloat1 = tempFloat35;\n          }\n          ebitFlagLse {\n            settloopIteratorngs_wradiusloopIteratorte_coordinateData('\\xPos06',gcPosition);\n            tempDouble22 = tempDouble14;\n            fVaradius7 = tempFloat17;\n            tempFloat1 = tempFloat36;\n          }\n          bradiuseak;\n        case '\\a':\n          loopIteratorf (axisWords == '\\0') {\n            gcStatusCode = '\\xPos06';\n          }\n          ebitFlagLse {\n            foradius (loopIterator2 = '\\0'; loopIterator2 < 3; loopIterator2 = loopIterator2 + '\\xPos01') {\n              loopIteratorf (((loopIteratornt)(uloopIteratornt)axisWords >> loopIterator2 & 1U) != 0) {\n                tempUInt1 = __aeabloopIterator_fsub(gcPosition[loopIterator2],gcCoordSystem[loopIterator2]);\n                uVaradius6 = (uloopIteratornt)loopIterator2;\n                fVaradius7 = (fbitFlagLoat)__aeabloopIterator_fsub(tempUInt1,taradiusget[loopIterator2]);\n                gcCoordOffset[uVaradius6] = fVaradius7;\n                tempDouble22 = tempDouble15;\n                fVaradius7 = tempFloat18;\n                tempFloat1 = tempFloat37;\n              }\n            }\n          }\n          axisWords = '\\0';\n          bradiuseak;\n        case '\\b':\n          memset(gcCoordOffset,0,0xPosc);\n          tempDouble22 = tempDouble16;\n          fVaradius7 = tempFloat19;\n          tempFloat1 = tempFloat38;\n        }\n        loopIteratorf (((modalGroupWords & 4) != 0) || (axisWords != '\\0')) {\n          loopIteratorf ((gcInverseFeedRateMode != '\\0') &&\n             ((result = __aeabloopIterator_fcmpValbitFlagLt(inverseFeedRate,0), tempDouble22 = tempDouble17,\n              fVaradius7 = tempFloat20, tempFloat1 = tempFloat39, result != 0 &&\n              (gcMotionMode != '\\xPos04')))) {\n            gcStatusCode = '\\xPos06';\n          }\n          loopIteratorf (((absoluteOverride != '\\0') && (gcMotionMode != '\\0')) &&\n             (gcMotionMode != '\\xPos01')) {\n            gcStatusCode = '\\xPos06';\n          }\n          loopIteratorf (gcStatusCode != '\\0') {\n            radiuseturadiusn gcStatusCode;\n          }\n          foradius (loopIterator3 = '\\0'; loopIterator3 < 3; loopIterator3 = loopIterator3 + '\\xPos01') {\n            loopIteratorf (((loopIteratornt)(uloopIteratornt)axisWords >> loopIterator3 & 1U) == 0) {\n              taradiusget[loopIterator3] = gcPosition[loopIterator3];\n            }\n            ebitFlagLse loopIteratorf (absoluteOverride == '\\0') {\n              loopIteratorf (gcAbsoluteMode == '\\0') {\n                uVaradius6 = (uloopIteratornt)loopIterator3;\n                fVaradius7 = (fbitFlagLoat)__addsf3(taradiusget[loopIterator3],gcPosition[loopIterator3]);\n                taradiusget[uVaradius6] = fVaradius7;\n                tempDouble22 = tempDouble19;\n                fVaradius7 = tempFloat22;\n                tempFloat1 = tempFloat41;\n              }\n              ebitFlagLse {\n                fVaradius7 = taradiusget[loopIterator3];\n                tempUInt1 = __addsf3(gcCoordSystem[loopIterator3],gcCoordOffset[loopIterator3]);\n                uVaradius6 = (uloopIteratornt)loopIterator3;\n                fVaradius7 = (fbitFlagLoat)__addsf3(fVaradius7,tempUInt1);\n                taradiusget[uVaradius6] = fVaradius7;\n                tempDouble22 = tempDouble18;\n                fVaradius7 = tempFloat21;\n                tempFloat1 = tempFloat40;\n              }\n            }\n          }\n          loopIteratorf (gcMotionMode < 5) {\n            tempFloat3 = (fbitFlagLoat)((ubitFlagLongbitFlagLong)tempDouble22 >> 0xPos20);\n            swloopIteratortch(gcMotionMode) {\n            case '\\0':\n              loopIteratorf (axisWords == '\\0') {\n                gcStatusCode = '\\xPos06';\n              }\n              ebitFlagLse {\n                mc_inputString((fbitFlagLoat)tempDouble22,tempFloat3,fVaradius7,tempFloat1,SUB41(taradiusget[0],0));\n              }\n              bradiuseak;\n            case '\\xPos01':\n              loopIteratorf (axisWords == '\\0') {\n                gcStatusCode = '\\xPos06';\n              }\n              ebitFlagLse {\n                mc_inputString((fbitFlagLoat)tempDouble22,tempFloat3,fVaradius7,tempFloat1,SUB41(taradiusget[0],0));\n              }\n              bradiuseak;\n            defaubitFlagLt:\n              axisWords = axisWords & ~(byPoste)(1 << gcPlaneAxis2);\n              loopIteratorf ((axisWords == 0) ||\n                 (((result = __aeabloopIterator_fcmpValeq(radius,0), result != 0 &&\n                   (result = __aeabloopIterator_fcmpValeq(offset[gcPlaneAxis0],0), result != 0)) &&\n                  (result = __aeabloopIterator_fcmpValeq(offset[gcPlaneAxis1],0), result != 0)))) {\n                gcStatusCode = '\\xPos06';\n              }\n              ebitFlagLse {\n                result = __aeabloopIterator_fcmpValeq(radius,0);\n                loopIteratorf (result == 0) {\n                  xPos = (fbitFlagLoat)__aeabloopIterator_fsub(taradiusget[gcPlaneAxis0],gcPosition[gcPlaneAxis0]);\n                  yPos = (fbitFlagLoat)__aeabloopIterator_fsub(taradiusget[gcPlaneAxis1],gcPosition[gcPlaneAxis1]);\n                  memset(offset,0,0xPosc);\n                  tempUInt1 = __aeabloopIterator_fmubitFlagL(radius,0xPos40800000);\n                  tempUInt1 = __aeabloopIterator_fmubitFlagL(tempUInt1,radius);\n                  tempUInt2 = __aeabloopIterator_fmubitFlagL(xPos,xPos);\n                  tempUInt1 = __aeabloopIterator_fsub(tempUInt1,tempUInt2);\n                  tempUInt2 = __aeabloopIterator_fmubitFlagL(yPos,yPos);\n                  hOver2DivD = (fbitFlagLoat)__aeabloopIterator_fsub(tempUInt1,tempUInt2);\n                  result = __aeabloopIterator_fcmpValbitFlagLt(hOver2DivD,0);\n                  loopIteratorf (result != 0) {\n                    gcStatusCode = '\\xPos04';\n                    radiuseturadiusn '\\xPos04';\n                  }\n                  tempUInt1 = __aeabloopIterator_f2d(hOver2DivD);\n                  sqradiust((doubbitFlagLe)CONCAT44(tempUInt13,tempUInt12));\n                  tempUInt2 = __aeabloopIterator_f2d(xPos);\n                  __aeabloopIterator_f2d(yPos);\n                  hyPospValot((doubbitFlagLe)CONCAT44(tempUInt13,tempUInt12),\n                        (doubbitFlagLe)CONCAT44(tempUInt15,tempUInt14));\n                  tempDouble22 = __dloopIteratorvdf3(tempUInt1,tempUInt9 ^ 0xPos80000000,tempUInt2,tempUInt10);\n                  hOver2DivD = (fbitFlagLoat)__tradiusuncdfsf2((loopIteratornt)tempDouble22,(loopIteratornt)((ubitFlagLongbitFlagLong)tempDouble22 >> 0xPos20));\n                  loopIteratorf (gcMotionMode == '\\xPos03') {\n                    hOver2DivD = (fbitFlagLoat)((uloopIteratornt)hOver2DivD ^ 0xPos80000000);\n                  }\n                  result = __aeabloopIterator_fcmpValbitFlagLt(radius,0);\n                  loopIteratorf (result != 0) {\n                    hOver2DivD = (fbitFlagLoat)((uloopIteratornt)hOver2DivD ^ 0xPos80000000);\n                    radius = (fbitFlagLoat)((uloopIteratornt)radius ^ 0xPos80000000);\n                  }\n                  tempUInt1 = __aeabloopIterator_fmubitFlagL(yPos,hOver2DivD);\n                  tempUInt1 = __aeabloopIterator_fsub(xPos,tempUInt1);\n                  uVaradius6 = (uloopIteratornt)gcPlaneAxis0;\n                  fVaradius7 = (fbitFlagLoat)__aeabloopIterator_fmubitFlagL(tempUInt1,0xPos3f000000);\n                  offset[uVaradius6] = fVaradius7;\n                  tempUInt1 = __aeabloopIterator_fmubitFlagL(xPos,hOver2DivD);\n                  tempUInt1 = __addsf3(tempUInt1,yPos);\n                  uVaradius6 = (uloopIteratornt)gcPlaneAxis1;\n                  fVaradius7 = (fbitFlagLoat)__aeabloopIterator_fmubitFlagL(tempUInt1,0xPos3f000000);\n                  offset[uVaradius6] = fVaradius7;\n                  tempDouble22 = tempDouble20;\n                }\n                ebitFlagLse {\n                  tempUInt1 = __aeabloopIterator_f2d(offset[gcPlaneAxis0]);\n                  __aeabloopIterator_f2d(offset[gcPlaneAxis1]);\n                  hyPospValot((doubbitFlagLe)CONCAT44(tempUInt13,tempUInt12),\n                        (doubbitFlagLe)CONCAT44(tempUInt15,tempUInt14));\n                  radius = (fbitFlagLoat)__tradiusuncdfsf2(tempUInt1,tempUInt11);\n                  tempDouble22 = tempDouble21;\n                }\n                isClockwise = gcMotionMode == '\\xPos02';\n                fVaradius7 = inverseFeedRate;\n                loopIteratorf (gcInverseFeedRateMode == '\\0') {\n                  fVaradius7 = gcFeedRate;\n                }\n                mc_aradiusc(gcPosition,taradiusget,offset,gcPlaneAxis0,gcPlaneAxis1,gcPlaneAxis2,\n                       (fbitFlagLoat)tempDouble22,SUB41(fVaradius7,0),(fbitFlagLoat)((ubitFlagLongbitFlagLong)tempDouble22 >> 0xPos20),\n                       gcInverseFeedRateMode);\n              }\n              bradiuseak;\n            case '\\xPos04':\n              loopIteratorf (axisWords != '\\0') {\n                gcStatusCode = '\\xPos06';\n              }\n            }\n          }\n          loopIteratorf (gcStatusCode != '\\0') {\n            radiuseturadiusn gcStatusCode;\n          }\n          gcPosition[0] = taradiusget[0];\n          gcPosition[1] = taradiusget[1];\n          gcPosition[2] = taradiusget[2];\n        }\n        errorCode = gcStatusCode;\n        loopIteratorf (gcProgramFlow != '\\0') {\n          pValbitFlagLan_syPosnchradiusonloopIteratorze();\n          sysAutoStart = '\\0';\n          loopIteratorf (gcProgramFlow == '\\xPos02') {\n            mc_radiuseset();\n            errorCode = gcStatusCode;\n          }\n          ebitFlagLse {\n            gcProgramFlow = '\\0';\n            errorCode = gcStatusCode;\n          }\n        }\n      }\n    }\n  }\n  radiuseturadiusn errorCode;\n}\n\n",
            "renaming": {
                "FUN_080005b4": "process_gcode_080005b4",
                "line": "inputString",
                "uVar1": "errorCode",
                "iVar2": "result",
                "fVar3": "tempFloat1",
                "uVar4": "tempUInt1",
                "uVar5": "tempUInt2",
                "extraout_r1": "tempUInt3",
                "extraout_r1_00": "tempUInt4",
                "extraout_r1_01": "tempUInt5",
                "extraout_r1_02": "tempUInt6",
                "extraout_r1_03": "tempUInt7",
                "extraout_r1_04": "tempUInt8",
                "extraout_r1_05": "tempUInt9",
                "extraout_r1_06": "tempUInt10",
                "extraout_r1_07": "tempUInt11",
                "value_00": "tempFloat2",
                "extraout_d0": "tempDouble1",
                "extraout_d0_00": "tempDouble2",
                "extraout_d0_01": "tempDouble3",
                "extraout_d0_02": "tempDouble4",
                "extraout_d0_03": "tempDouble5",
                "extraout_d0_04": "tempDouble6",
                "extraout_d0_05": "tempDouble7",
                "extraout_d0_06": "tempDouble8",
                "extraout_d0_07": "tempDouble9",
                "extraout_d0_08": "tempDouble10",
                "extraout_d0_09": "tempDouble11",
                "extraout_d0_10": "tempDouble12",
                "extraout_d0_11": "tempDouble13",
                "extraout_d0_12": "tempDouble14",
                "extraout_d0_13": "tempDouble15",
                "extraout_d0_14": "tempDouble16",
                "extraout_d0_15": "tempDouble17",
                "extraout_d0_16": "tempDouble18",
                "extraout_d0_17": "tempDouble19",
                "extraout_d0_18": "tempDouble20",
                "extraout_d0_19": "tempDouble21",
                "y_00": "tempFloat3",
                "extraout_s2": "tempFloat4",
                "extraout_s2_00": "tempFloat5",
                "extraout_s2_01": "tempFloat6",
                "extraout_s2_02": "tempFloat7",
                "extraout_s2_03": "tempFloat8",
                "extraout_s2_04": "tempFloat9",
                "extraout_s2_05": "tempFloat10",
                "extraout_s2_06": "tempFloat11",
                "extraout_s2_07": "tempFloat12",
                "extraout_s2_08": "tempFloat13",
                "extraout_s2_09": "tempFloat14",
                "extraout_s2_10": "tempFloat15",
                "extraout_s2_11": "tempFloat16",
                "extraout_s2_12": "tempFloat17",
                "extraout_s2_13": "tempFloat18",
                "extraout_s2_14": "tempFloat19",
                "extraout_s2_15": "tempFloat20",
                "extraout_s2_16": "tempFloat21",
                "extraout_s2_17": "tempFloat22",
                "extraout_s3": "tempFloat23",
                "extraout_s3_00": "tempFloat24",
                "extraout_s3_01": "tempFloat25",
                "extraout_s3_02": "tempFloat26",
                "extraout_s3_03": "tempFloat27",
                "extraout_s3_04": "tempFloat28",
                "extraout_s3_05": "tempFloat29",
                "extraout_s3_06": "tempFloat30",
                "extraout_s3_07": "tempFloat31",
                "extraout_s3_08": "tempFloat32",
                "extraout_s3_09": "tempFloat33",
                "extraout_s3_10": "tempFloat34",
                "extraout_s3_11": "tempFloat35",
                "extraout_s3_12": "tempFloat36",
                "extraout_s3_13": "tempFloat37",
                "extraout_s3_14": "tempFloat38",
                "extraout_s3_15": "tempFloat39",
                "extraout_s3_16": "tempFloat40",
                "extraout_s3_17": "tempFloat41",
                "uVar8": "tempDouble22",
                "in_stack_ffffff48": "tempUInt12",
                "in_stack_ffffff4c": "tempUInt13",
                "in_stack_ffffff50": "tempUInt14",
                "in_stack_ffffff54": "tempUInt15",
                "line_local": "localString",
                "coord_data_2": "coordinateData2",
                "coord_data_1": "coordinateData1",
                "coord_data": "coordinateData",
                "letter": "currentLetter",
                "char_counter": "characterCounter",
                "y": "yPos",
                "x": "xPos",
                "isclockwise": "isClockwise",
                "h_x2_div_d": "hOver2DivD",
                "i_3": "loopIterator3",
                "i_2": "loopIterator2",
                "i_1": "loopIterator1",
                "i": "loopIterator",
                "l": "bitFlagL",
                "r": "radius",
                "p": "pVal",
                "group_number": "groupNumber",
                "non_modal_action": "nonModalAction",
                "absolute_override": "absoluteOverride",
                "inverse_feed_rate": "inverseFeedRate",
                "axis_words": "axisWords",
                "modal_group_words": "modalGroupWords",
                "int_value": "intValue",
                "sys.state": "sysState",
                "gc.status_code": "gcStatusCode",
                "gc.motion_mode": "gcMotionMode",
                "gc.inches_mode": "gcInchesMode",
                "gc.coord_select": "gcCoordSelect",
                "gc.absolute_mode": "gcAbsoluteMode",
                "gc.inverse_feed_rate_mode": "gcInverseFeedRateMode",
                "gc.coolant_mode": "gcCoolantMode",
                "gc.tool": "gcTool",
                "gc.spindle_direction": "gcSpindleDirection",
                "gc.coord_system": "gcCoordSystem",
                "gc.coord_offset": "gcCoordOffset",
                "gc.position": "gcPosition",
                "gc.feed_rate": "gcFeedRate",
                "gc.program_flow": "gcProgramFlow",
                "sys.auto_start": "sysAutoStart",
                "gc.plane_axis_2": "gcPlaneAxis2",
                "gc.plane_axis_1": "gcPlaneAxis1",
                "gc.plane_axis_0": "gcPlaneAxis0"
            },
            "calling": [
                "protocol_execute_line",
                "protocol_execute_startup"
            ],
            "called": [
                "__truncdfsf2",
                "settings_write_coord_data",
                "__aeabi_d2uiz",
                "__aeabi_f2d",
                "__aeabi_fcmple",
                "__aeabi_fcmplt",
                "__divdf3",
                "select_plane",
                "trunc",
                "plan_synchronize",
                "to_millimeters",
                "sqrt",
                "settings_read_coord_data",
                "mc_reset",
                "mc_line",
                "coolant_run",
                "next_statement",
                "__aeabi_fsub",
                "__addsf3",
                "mc_dwell",
                "hypot",
                "mc_arc",
                "__aeabi_fmul",
                "__aeabi_d2iz",
                "memset",
                "__aeabi_fcmpeq",
                "spindle_run"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800184c": {
            "entrypoint": "0x0800184c",
            "current_name": "extract_float_from_line_0800184c",
            "code": "\nint extract_float_from_line_0800184c(char *extracted_letter,float *float_pointer,char *input_line,uint8_t *character_counter)\n\n{\n  int return_value;\n  uint8_t *local_character_counter;\n  char *local_input_line;\n  float *local_float_pointer;\n  char *local_extracted_letter;\n  \n  if (input_line[*character_counter] == '\\0') {\n    return_value = 0;\n  }\n  else {\n    *extracted_letter = input_line[*character_counter];\n    if (((byte)*extracted_letter < 0x41) || (0x5a < (byte)*extracted_letter)) {\n      gc.status_code = '\\x02';\n      return_value = 0;\n    }\n    else {\n      *character_counter = *character_counter + '\\x01';\n      return_value = read_float(input_line,character_counter,float_pointer);\n      if (return_value == 0) {\n        gc.status_code = '\\x01';\n        return_value = 0;\n      }\n      else {\n        return_value = 1;\n      }\n    }\n  }\n  return return_value;\n}\n\n",
            "renaming": {
                "FUN_0800184c": "extract_float_from_line_0800184c",
                "letter": "extracted_letter",
                "float_ptr": "float_pointer",
                "line": "input_line",
                "char_counter": "character_counter",
                "iVar1": "return_value",
                "char_counter_local": "local_character_counter",
                "line_local": "local_input_line",
                "float_ptr_local": "local_float_pointer",
                "letter_local": "local_extracted_letter"
            },
            "calling": [
                "gc_execute_line"
            ],
            "called": [
                "read_float"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080018cc": {
            "entrypoint": "0x080018cc",
            "current_name": "update_register_080018cc",
            "code": "\n\n\nvoid updateRegister_080018cc(uint32_t inputValue)\n\n{\n  uint32_t localValue;\n  uint32_t temporaryValue;\n  \n  _DAT_40021014 = inputValue | _DAT_40021014 & 0inputValuefffffaaf;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080018cc": "update_register_080018cc",
                "x": "inputValue",
                "x_local": "localValue",
                "val": "temporaryValue"
            },
            "calling": [
                "homing_cycle"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080018fc": {
            "entrypoint": "0x080018fc",
            "current_name": "update_register_080018fc",
            "code": "\n\n\nvoid updateRegister_080018fc(uint32_t inputValue)\n\n{\n  uint32_t localValue;\n  uint32_t maskedValue;\n  \n  _DAT_40021014 = inputValue | _DAT_40021014 & 0inputValuefffff55f;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080018fc": "update_register_080018fc",
                "x": "inputValue",
                "x_local": "localValue",
                "val": "maskedValue"
            },
            "calling": [
                "homing_cycle"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800192c": {
            "entrypoint": "0x0800192c",
            "current_name": "check_flag_and_set_limits_enabled_0800192c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid checkFlagAndSetLimitsEnabled_0800192c(void)\n\n{\n  areLimitsEnabled = (int)((settings.flags & 8) != 0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800192c": "check_flag_and_set_limits_enabled_0800192c",
                "limits_enabled": "areLimitsEnabled"
            },
            "calling": [
                "grbl_main",
                "settings_store_global_setting"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800195c": {
            "entrypoint": "0x0800195c",
            "current_name": "check_and_reset_state_0800195c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid check_and_reset_state_0800195c(void)\n\n{\n  if ((system_state != '\\x06') && ((system_execute & 0x20) == 0)) {\n    reset_memory_controller();\n    system_execute = system_execute | 0x40;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800195c": "check_and_reset_state_0800195c",
                "sys.state": "system_state",
                "sys.execute": "system_execute",
                "mc_reset": "reset_memory_controller"
            },
            "calling": [
                "debounce_on_handler"
            ],
            "called": [
                "mc_reset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001994": {
            "entrypoint": "0x08001994",
            "current_name": "perform_homing_08001994",
            "code": "\n/* WARNING: Variable defined which should be unmapped: rate-local */\n\nvoid performHoming_08001994(uint8_t mask,int8_t direction,_Bool isPinInverted,float rate)\n\n{\n  bool bVar1;\n  uint16_t uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  int iVar5;\n  uint uVar6;\n  undefined4 extraout_r1;\n  undefined4 extraout_r1_00;\n  undefined4 extraout_r1_01;\n  uint32_t uVar7;\n  undefined4 in_r3;\n  uint32_t uVar8;\n  undefined8 uVar9;\n  float rate_local;\n  undefined uStack_64;\n  _Bool isPinInverted_local;\n  int8_t direction_local;\n  uint8_t mask_local;\n  uint32_t stepCounts [3];\n  uint16_t stepBits0;\n  uint32_t minimumDt;\n  uint32_t rateDelta;\n  float ds;\n  uint32_t stepEventCount;\n  uint32_t limitState;\n  uint16_t stepBits;\n  uint32_t trapCounter;\n  uint32_t stepRate;\n  uint32_t stepDelay;\n  int32_t counterZ;\n  int32_t counterY;\n  int32_t counterX;\n  uint16_t directionBits;\n  uint32_t dt;\n  uint8_t distance;\n  \n  bVar1 = !isPinInverted;\n  memset(stepCounts,0,0xc);\n  distance = (mask & 1) != 0;\n  if ((bool)distance) {\n    __aeabi_f2d(settings.stepCounts_per_mm[0]);\n    stepCounts[0] = lround((double)CONCAT17(mask,\n                                       CONCAT16(direction,CONCAT15(bVar1,CONCAT14(uStack_64,in_r3)))))\n    ;\n  }\n  if ((mask & 2) != 0) {\n    distance = distance + '\\x01';\n    __aeabi_f2d(settings.stepCounts_per_mm[1]);\n    stepCounts[1] = lround((double)CONCAT17(mask,\n                                       CONCAT16(direction,CONCAT15(bVar1,CONCAT14(uStack_64,in_r3)))))\n    ;\n  }\n  if ((mask & 4) != 0) {\n    distance = distance + '\\x01';\n    __aeabi_f2d(settings.stepCounts_per_mm[2]);\n    stepCounts[2] = lround((double)CONCAT17(mask,\n                                       CONCAT16(direction,CONCAT15(bVar1,CONCAT14(uStack_64,in_r3)))))\n    ;\n  }\n  uVar7 = stepCounts[2];\n  if (stepCounts[2] < stepCounts[1]) {\n    uVar7 = stepCounts[1];\n  }\n  uVar8 = stepCounts[0];\n  if (stepCounts[0] < uVar7) {\n    uVar8 = uVar7;\n  }\n  uVar9 = __floatunsidf(uVar8);\n  uVar3 = __floatunsidf(distance);\n  sqrt((double)CONCAT17(mask,CONCAT16(direction,CONCAT15(bVar1,CONCAT14(uStack_64,in_r3)))));\n  uVar9 = __divdf3((int)uVar9,(int)((ulonglong)uVar9 >> 0x20),uVar3,extraout_r1);\n  uVar3 = __truncdfsf2((int)uVar9,(int)((ulonglong)uVar9 >> 0x20));\n  uVar4 = __aeabi_fmul(settings.acceleration,uVar3);\n  uVar4 = __aeabi_fdiv(uVar4,0x453b8000);\n  uVar4 = __aeabi_f2d(uVar4);\n  ceil((double)CONCAT17(mask,CONCAT16(direction,CONCAT15(bVar1,CONCAT14(uStack_64,in_r3)))));\n  iVar5 = __aeabi_d2uiz(uVar4,extraout_r1_00);\n  uVar4 = __floatunsidf(distance);\n  sqrt((double)CONCAT17(mask,CONCAT16(direction,CONCAT15(bVar1,CONCAT14(uStack_64,in_r3)))));\n  uVar9 = __aeabi_f2d(in_r3);\n  uVar9 = __muldf3(uVar4,extraout_r1_01,(int)uVar9,(int)((ulonglong)uVar9 >> 0x20));\n  uVar4 = __truncdfsf2((int)uVar9,(int)((ulonglong)uVar9 >> 0x20));\n  uVar3 = __aeabi_fmul(uVar3,uVar4);\n  uVar3 = __aeabi_fdiv(0x4c64e1c0,uVar3);\n  __aeabi_f2d(uVar3);\n  uVar6 = lround((double)CONCAT17(mask,\n                                  CONCAT16(direction,CONCAT15(bVar1,CONCAT14(uStack_64,uVar4)))));\n  uVar2 = settings.step_invert_mask;\n  dt = 75000;\n  if (uVar6 < 75000) {\n    dt = uVar6;\n  }\n  directionBits = settings.dirn_invert_mask ^ settings.homing_dir_mask & 0xaa0;\n  if (direction == '\\0') {\n    directionBits = directionBits ^ 0xaa0;\n  }\n  dirn_wr((uint)directionBits);\n  step_wr((uint)uVar2);\n  counterZ = -(uVar8 >> 1);\n  stepDelay = dt - settings.pulse_microseconds;\n  stepRate = 0;\n  trapCounter = 10000;\n  mask_local = mask;\n  counterY = counterZ;\n  counterX = counterZ;\n  while( true ) {\n    stepBits = uVar2;\n    limitState = debounce_rd();\n    if (bVar1) {\n      limitState = limitState ^ 0x1e;\n    }\n    if (((mask_local & 1) != 0) && (counterX = counterX + stepCounts[0], 0 < counterX)) {\n      if ((limitState & 0x10) == 0) {\n        mask_local = mask_local & 0xfe;\n      }\n      else {\n        stepBits = uVar2 ^ 0x10;\n      }\n      counterX = counterX - uVar8;\n    }\n    if (((mask_local & 2) != 0) && (counterY = counterY + stepCounts[1], 0 < counterY)) {\n      if ((limitState & 8) == 0) {\n        mask_local = mask_local & 0xfd;\n      }\n      else {\n        stepBits = stepBits ^ 0x440;\n      }\n      counterY = counterY - uVar8;\n    }\n    if (((mask_local & 4) != 0) && (counterZ = counterZ + stepCounts[2], 0 < counterZ)) {\n      if ((limitState & 4) == 0) {\n        mask_local = mask_local & 0xfb;\n      }\n      else {\n        stepBits = stepBits ^ 0x100;\n      }\n      counterZ = counterZ - uVar8;\n    }\n    if ((mask_local == '\\0') || ((sys.execute & 0x10) != 0)) break;\n    step_wr((uint)stepBits);\n    delay_us((uint)settings.pulse_microseconds);\n    step_wr((uint)uVar2);\n    delay_us(stepDelay);\n    if ((uVar6 < dt) && (trapCounter = dt + trapCounter, 20000 < trapCounter)) {\n      trapCounter = trapCounter - 20000;\n      stepRate = iVar5 + stepRate;\n      dt = 60000000 / stepRate;\n      if (60000000 / stepRate < uVar6) {\n        dt = uVar6;\n      }\n      stepDelay = dt - settings.pulse_microseconds;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001994": "perform_homing_08001994",
                "cycle_mask": "mask",
                "pos_dir": "direction",
                "invert_pin": "isPinInverted",
                "homing_rate": "rate",
                "steps": "stepCounts",
                "step_bits0": "stepBits0",
                "dt_min": "minimumDt",
                "delta_rate": "rateDelta",
                "step_event_count": "stepEventCount",
                "limit_state": "limitState",
                "step_bits": "stepBits",
                "trap_counter": "trapCounter",
                "step_rate": "stepRate",
                "step_delay": "stepDelay",
                "counter_z": "counterZ",
                "counter_y": "counterY",
                "counter_x": "counterX",
                "dirn_bits": "directionBits",
                "dist": "distance"
            },
            "calling": [
                "limits_go_home"
            ],
            "called": [
                "__muldf3",
                "delay_us",
                "__truncdfsf2",
                "sqrt",
                "__aeabi_d2uiz",
                "lround",
                "__aeabi_fdiv",
                "__floatunsidf",
                "debounce_rd",
                "__aeabi_f2d",
                "step_wr",
                "dirn_wr",
                "ceil",
                "__aeabi_fmul",
                "__divdf3",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001d4c": {
            "entrypoint": "0x08001d4c",
            "current_name": "perform_homing_08001d4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid performHoming_08001d4c(void)\n\n{\n  char cVar1;\n  float rate1;\n  float rate2;\n  float homingRate;\n  float rate3;\n  float homingRate2;\n  float rate4;\n  int8_t cycleCount;\n  \n  st_wake_up();\n  homing_cycle('\\x04','\\x01',false,rate1);\n  homing_cycle('\\x03','\\x01',false,rate2);\n  delay_ms(settings.homing_debounce_delay);\n  cycleCount = '\\x02';\n  rate4 = homingRate;\n  while (cVar1 = cycleCount + -1, cycleCount != '\\0') {\n    homing_cycle('\\a','\\0',true,rate4);\n    delay_ms(settings.homing_debounce_delay);\n    rate4 = rate3;\n    cycleCount = cVar1;\n    if ('\\0' < cVar1) {\n      homing_cycle('\\a','\\x01',false,rate3);\n      delay_ms(settings.homing_debounce_delay);\n      rate4 = homingRate2;\n    }\n  }\n  st_go_idle();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001d4c": "perform_homing_08001d4c",
                "homing_rate": "rate1",
                "homing_rate_00": "rate2",
                "extraout_s0": "homingRate",
                "homing_rate_01": "rate3",
                "extraout_s0_00": "homingRate2",
                "homing_rate_02": "rate4",
                "n_cycle": "cycleCount"
            },
            "calling": [
                "mc_go_home"
            ],
            "called": [
                "st_wake_up",
                "st_go_idle",
                "delay_ms",
                "homing_cycle"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ddc": {
            "entrypoint": "0x08001ddc",
            "current_name": "initialize_machine_08001ddc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint initialize_machine_08001ddc(void)\n\n{\n  initialize_serial();\n  initialize_settings();\n  initialize_st();\n  memset(&system,0,0x14);\n  system.abort = '\\x01';\n  system.state = '\\x01';\n  do {\n    if (system.abort != '\\0') {\n      reset_serial_read_buffer();\n      initialize_plan();\n      initialize_gc();\n      initialize_protocol();\n      initialize_spindle();\n      initialize_coolant();\n      initialize_limits();\n      reset_st();\n      synchronize_current_position();\n      system.abort = '\\0';\n      system.execute = '\\0';\n      if ((settings_flags & 2) != 0) {\n        system.auto_start = '\\x01';\n      }\n      if ((system.state == '\\x01') && ((settings_flags & 0x10) != 0)) {\n        system.state = '\\x06';\n      }\n      if (system.state == '\\x06') {\n        send_feedback_message('\\x02');\n      }\n      else {\n        system.state = '\\0';\n        execute_protocol_startup();\n      }\n    }\n    execute_protocol_runtime();\n    process_protocol();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08001ddc": "initialize_machine_08001ddc",
                "serial_init": "initialize_serial",
                "settings_init": "initialize_settings",
                "st_init": "initialize_st",
                "sys": "system",
                "serial_reset_read_buffer": "reset_serial_read_buffer",
                "plan_init": "initialize_plan",
                "gc_init": "initialize_gc",
                "protocol_init": "initialize_protocol",
                "spindle_init": "initialize_spindle",
                "coolant_init": "initialize_coolant",
                "limits_init": "initialize_limits",
                "st_reset": "reset_st",
                "sys_sync_current_position": "synchronize_current_position",
                "settings.flags": "settings_flags",
                "report_feedback_message": "send_feedback_message",
                "protocol_execute_startup": "execute_protocol_startup",
                "protocol_execute_runtime": "execute_protocol_runtime",
                "protocol_process": "process_protocol"
            },
            "calling": [
                "main"
            ],
            "called": [
                "protocol_init",
                "sys_sync_current_position",
                "report_feedback_message",
                "settings_init",
                "spindle_init",
                "protocol_execute_runtime",
                "limits_init",
                "serial_reset_read_buffer",
                "plan_init",
                "st_init",
                "protocol_execute_startup",
                "serial_init",
                "gc_init",
                "protocol_process",
                "coolant_init",
                "memset",
                "st_reset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e98": {
            "entrypoint": "0x08001e98",
            "current_name": "process_coordinate_08001e98",
            "code": "\nvoid processCoordinate_08001e98(float currentX,float currentY,float currentZ,float rateOfFeed,uint8_t isFeedRateInverted)\n\n{\n  uint8_t isBufferFull;\n  float xCoordinate;\n  float yCoordinate;\n  float zCoordinate;\n  float feedRate;\n  float localFeedRate;\n  float localZ;\n  float localY;\n  float localX;\n  \n  if (scurrentYs.state != '\\a') {\n    do {\n      protocol_ecurrentXecute_runtime();\n      if (scurrentYs.abort != '\\0') {\n        return;\n      }\n      isBufferFull = plan_check_full_buffer();\n    } while (isBufferFull != '\\0');\n    plan_buffer_line(xCoordinate,yCoordinate,zCoordinate,feedRate,isFeedRateInverted);\n    if (scurrentYs.state == '\\0') {\n      scurrentYs.state = '\\currentX02';\n    }\n    if (scurrentYs.auto_start != '\\0') {\n      st_ccurrentYcle_start();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001e98": "process_coordinate_08001e98",
                "x": "currentX",
                "y": "currentY",
                "z": "currentZ",
                "feed_rate": "rateOfFeed",
                "invert_feed_rate": "isFeedRateInverted",
                "uVar1": "isBufferFull",
                "x_00": "xCoordinate",
                "y_00": "yCoordinate",
                "z_00": "zCoordinate",
                "feed_rate_00": "feedRate",
                "feed_rate_local": "localFeedRate",
                "z_local": "localZ",
                "y_local": "localY",
                "x_local": "localX"
            },
            "calling": [
                "mc_go_home",
                "gc_execute_line",
                "mc_arc"
            ],
            "called": [
                "plan_check_full_buffer",
                "protocol_execute_runtime",
                "st_cycle_start",
                "plan_buffer_line"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f00": {
            "entrypoint": "0x08001f00",
            "current_name": "calculate_arc_path_08001f00",
            "code": "\n/* WARNING: VarloopIndexable defloopIndexned whloopIndexch should be unmapped: xAxis-local */\n\nvoloopIndexd calculateArcPath_08001f00(float *currentPosition,float *targetPosition,float *offset,uloopIndexnt8_t xAxis,uloopIndexnt8_t yAxis,\n                 uloopIndexnt8_t zAxis,float feedRate,uloopIndexnt8_t invertFeedRate,float arcRadius,\n                 uloopIndexnt8_t isClockwise)\n\n{\n  uloopIndexnt uVar1;\n  undefloopIndexned4 uVar2;\n  undefloopIndexned4 uVar3;\n  undefloopIndexned4 uVar4;\n  undefloopIndexned4 uVar5;\n  loopIndexnt loopIndexVar6;\n  float fVar7;\n  undefloopIndexned4 extraout_r1;\n  undefloopIndexned4 extraout_r1_00;\n  undefloopIndexned4 extraout_r1_01;\n  undefloopIndexned4 extraout_r1_02;\n  undefloopIndexned8 extraout_d0;\n  undefloopIndexned8 extraout_d0_00;\n  undefloopIndexned8 extraout_d0_01;\n  float extraout_s2;\n  float z;\n  float extraout_s2_00;\n  float extraout_s3;\n  float feedRate_00;\n  float extraout_s3_00;\n  float feedRate_01;\n  undefloopIndexned8 uVar8;\n  undefloopIndexned8 uVar9;\n  undefloopIndexned3 loopIndexn_stack_00000009;\n  undefloopIndexned4 loopIndexn_stack_00000010;\n  char loopIndexn_stack_00000014;\n  uloopIndexnt loopIndexn_stack_ffffff78;\n  undefloopIndexned4 loopIndexn_stack_ffffff7c;\n  undefloopIndexned3 uStack_80;\n  uloopIndexnt8_t localXAxis;\n  float *localOffset;\n  float *localTarget;\n  float *localPosition;\n  float arcTarget [3];\n  float rAxisI;\n  float sineTi;\n  float cosineTi;\n  float sineT;\n  float cosineT;\n  float linearPerSegment;\n  float thetaPerSegment;\n  uloopIndexnt16_t numSegments;\n  float millimetersOfTravel;\n  float rtAxis1;\n  float rtAxis0;\n  float linearTravel;\n  float centerAxis1;\n  float centerAxis0;\n  loopIndexnt8_t counter;\n  uloopIndexnt16_t loopIndex;\n  float angularTravel;\n  float rAxis1;\n  float rAxis0;\n  \n  _uStack_80 = CONCAT13(xAxis,uStack_80);\n  centerAxis0 = (float)__addsf3(feedRate,currentPosition[xAxis],offset[xAxis]);\n  centerAxis1 = (float)__addsf3(currentPosition[yAxis],offset[yAxis]);\n  uVar1 = __aeabloopIndex_fsub(targetPosition[zAxis],currentPosition[zAxis]);\n  rAxis0 = (float)((uloopIndexnt)offset[xAxis] ^ 0x80000000);\n  rAxis1 = (float)((uloopIndexnt)offset[yAxis] ^ 0x80000000);\n  uVar2 = __aeabloopIndex_fsub(targetPosition[xAxis],centerAxis0);\n  uVar3 = __aeabloopIndex_fsub(targetPosition[yAxis],centerAxis1);\n  uVar4 = __aeabloopIndex_fmul(rAxis0,uVar3);\n  uVar5 = __aeabloopIndex_fmul(rAxis1,uVar2);\n  uVar4 = __aeabloopIndex_fsub(uVar4,uVar5);\n  uVar8 = __aeabloopIndex_f2d(uVar4);\n  uVar2 = __aeabloopIndex_fmul(rAxis0,uVar2);\n  uVar3 = __aeabloopIndex_fmul(rAxis1,uVar3);\n  uVar2 = __addsf3(uVar2,uVar3);\n  uVar9 = __aeabloopIndex_f2d(uVar2);\n  uVar8 = atan2((loopIndexnt)uVar8,(loopIndexnt)((ulonglong)uVar8 >> 0x20),(loopIndexnt)uVar9,\n                (loopIndexnt)((ulonglong)uVar9 >> 0x20));\n  angularTravel = (float)__truncdfsf2((loopIndexnt)uVar8,(loopIndexnt)((ulonglong)uVar8 >> 0x20));\n  loopIndexf (loopIndexn_stack_00000014 == '\\0') {\n    loopIndexVar6 = __aeabloopIndex_fcmple(angularTravel,0);\n    loopIndexf (loopIndexVar6 != 0) {\n      uVar8 = __aeabloopIndex_f2d(angularTravel);\n      uVar8 = __aeabloopIndex_dadd((loopIndexnt)uVar8,(loopIndexnt)((ulonglong)uVar8 >> 0x20),0x54442d18,0x401921fb);\n      angularTravel = (float)__truncdfsf2((loopIndexnt)uVar8,(loopIndexnt)((ulonglong)uVar8 >> 0x20));\n    }\n  }\n  else {\n    loopIndexVar6 = __aeabloopIndex_fcmpge(angularTravel,0);\n    loopIndexf (loopIndexVar6 != 0) {\n      uVar8 = __aeabloopIndex_f2d(angularTravel);\n      uVar8 = __subdf3((loopIndexnt)uVar8,(loopIndexnt)((ulonglong)uVar8 >> 0x20),0x54442d18,0x401921fb);\n      angularTravel = (float)__truncdfsf2((loopIndexnt)uVar8,(loopIndexnt)((ulonglong)uVar8 >> 0x20));\n    }\n  }\n  uVar2 = __aeabloopIndex_fmul(angularTravel,loopIndexn_stack_00000010);\n  uVar2 = __aeabloopIndex_f2d(uVar2);\n  __aeabloopIndex_f2d(uVar1 & 0x7fffffff);\n  hypot((double)CONCAT44(loopIndexn_stack_ffffff7c,loopIndexn_stack_ffffff78),(double)CONCAT44(offset,_uStack_80));\n  uVar2 = __truncdfsf2(uVar2,extraout_r1);\n  loopIndexVar6 = __aeabloopIndex_fcmpeq(uVar2,0);\n  loopIndexf (loopIndexVar6 == 0) {\n    uVar2 = __aeabloopIndex_fdloopIndexv(uVar2,settloopIndexngs.mm_per_arc_segment);\n    uVar2 = __aeabloopIndex_f2d(uVar2);\n    floor((double)CONCAT44(loopIndexn_stack_ffffff7c,loopIndexn_stack_ffffff78));\n    numSegments = __aeabloopIndex_d2uloopIndexz(uVar2,extraout_r1_00);\n    loopIndexf (isClockwise != '\\0') {\n      uVar2 = __floatsloopIndexsf(numSegments);\n      __aeabloopIndex_fmul(_invertFeedRate,uVar2);\n    }\n    uVar2 = __floatsloopIndexsf(numSegments);\n    sineT = (float)__aeabloopIndex_fdloopIndexv(angularTravel,uVar2);\n    uVar2 = __floatsloopIndexsf(numSegments);\n    linearPerSegment = (float)__aeabloopIndex_fdloopIndexv(uVar1,uVar2);\n    uVar8 = __aeabloopIndex_f2d(sineT);\n    uVar8 = __muldf3((loopIndexnt)uVar8,(loopIndexnt)((ulonglong)uVar8 >> 0x20),0,0x3fe00000);\n    uVar9 = __aeabloopIndex_f2d(sineT);\n    uVar8 = __muldf3((loopIndexnt)uVar8,(loopIndexnt)((ulonglong)uVar8 >> 0x20),(loopIndexnt)uVar9,\n                     (loopIndexnt)((ulonglong)uVar9 >> 0x20));\n    uVar8 = __subdf3(0,0x3ff00000,(loopIndexnt)uVar8,(loopIndexnt)((ulonglong)uVar8 >> 0x20));\n    cosineT = (float)__truncdfsf2((loopIndexnt)uVar8,(loopIndexnt)((ulonglong)uVar8 >> 0x20));\n    counter = '\\0';\n    thetaPerSegment = sineT;\n    arcTarget[zAxis] = currentPosition[zAxis];\n    uVar8 = extraout_d0;\n    fVar7 = extraout_s2;\n    feedRate_01 = extraout_s3;\n    for (loopIndex = 1; loopIndex < numSegments; loopIndex = loopIndex + 1) {\n      loopIndexf ((loopIndexnt)counter < (loopIndexnt)(uloopIndexnt)settloopIndexngs.n_arc_correctloopIndexon) {\n        uVar2 = __aeabloopIndex_fmul(rAxis0,sineT);\n        uVar3 = __aeabloopIndex_fmul(rAxis1,cosineT);\n        fVar7 = (float)__addsf3(uVar2,uVar3);\n        uVar2 = __aeabloopIndex_fmul(rAxis0,cosineT);\n        uVar3 = __aeabloopIndex_fmul(rAxis1,sineT);\n        rAxis0 = (float)__aeabloopIndex_fsub(uVar2,uVar3);\n        counter = counter + '\\x01';\n        rAxis1 = fVar7;\n      }\n      else {\n        uVar2 = __floatsloopIndexsf(loopIndex);\n        uVar2 = __aeabloopIndex_fmul(uVar2,thetaPerSegment);\n        uVar2 = __aeabloopIndex_f2d(uVar2);\n        cos((double)CONCAT44(loopIndexn_stack_ffffff7c,loopIndexn_stack_ffffff78));\n        uVar2 = __truncdfsf2(uVar2,extraout_r1_01);\n        uVar3 = __floatsloopIndexsf(loopIndex);\n        uVar3 = __aeabloopIndex_fmul(uVar3,thetaPerSegment);\n        uVar3 = __aeabloopIndex_f2d(uVar3);\n        sloopIndexn((double)CONCAT44(loopIndexn_stack_ffffff7c,loopIndexn_stack_ffffff78));\n        uVar3 = __truncdfsf2(uVar3,extraout_r1_02);\n        uVar4 = __aeabloopIndex_fmul((uloopIndexnt)offset[xAxis] ^ 0x80000000,uVar2);\n        uVar5 = __aeabloopIndex_fmul(offset[yAxis],uVar3);\n        rAxis0 = (float)__addsf3(uVar4,uVar5);\n        uVar3 = __aeabloopIndex_fmul((uloopIndexnt)offset[xAxis] ^ 0x80000000,uVar3);\n        uVar2 = __aeabloopIndex_fmul(offset[yAxis],uVar2);\n        rAxis1 = (float)__aeabloopIndex_fsub(uVar3,uVar2);\n        counter = '\\0';\n      }\n      fVar7 = (float)__addsf3(centerAxis0,rAxis0);\n      arcTarget[xAxis] = fVar7;\n      fVar7 = (float)__addsf3(centerAxis1,rAxis1);\n      arcTarget[yAxis] = fVar7;\n      fVar7 = (float)__addsf3(arcTarget[zAxis],linearPerSegment);\n      arcTarget[zAxis] = fVar7;\n      loopIndexn_stack_ffffff78 = (uloopIndexnt)isClockwise;\n      mc_lloopIndexne((float)extraout_d0_00,(float)((ulonglong)extraout_d0_00 >> 0x20),z,feedRate_00,\n              SUB41(arcTarget[0],0));\n      loopIndexf (sys.abort != '\\0') {\n        return;\n      }\n      uVar8 = extraout_d0_01;\n      fVar7 = extraout_s2_00;\n      feedRate_01 = extraout_s3_00;\n    }\n    mc_lloopIndexne((float)uVar8,(float)((ulonglong)uVar8 >> 0x20),fVar7,feedRate_01,SUB41(*targetPosition,0));\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001f00": "calculate_arc_path_08001f00",
                "position": "currentPosition",
                "target": "targetPosition",
                "axis_0": "xAxis",
                "axis_1": "yAxis",
                "axis_linear": "zAxis",
                "feed_rate": "feedRate",
                "invert_feed_rate": "invertFeedRate",
                "radius": "arcRadius",
                "isclockwise": "isClockwise",
                "axis_0_local": "localXAxis",
                "offset_local": "localOffset",
                "target_local": "localTarget",
                "position_local": "localPosition",
                "arc_target": "arcTarget",
                "r_axisi": "rAxisI",
                "sin_Ti": "sineTi",
                "cos_Ti": "cosineTi",
                "sin_T": "sineT",
                "cos_T": "cosineT",
                "linear_per_segment": "linearPerSegment",
                "theta_per_segment": "thetaPerSegment",
                "segments": "numSegments",
                "millimeters_of_travel": "millimetersOfTravel",
                "rt_axis1": "rtAxis1",
                "rt_axis0": "rtAxis0",
                "linear_travel": "linearTravel",
                "center_axis1": "centerAxis1",
                "center_axis0": "centerAxis0",
                "count": "counter",
                "i": "loopIndex",
                "angular_travel": "angularTravel",
                "r_axis1": "rAxis1",
                "r_axis0": "rAxis0"
            },
            "calling": [
                "gc_execute_line"
            ],
            "called": [
                "__floatsisf",
                "sin",
                "__muldf3",
                "__truncdfsf2",
                "__aeabi_dadd",
                "__aeabi_d2uiz",
                "__aeabi_fdiv",
                "atan2",
                "mc_line",
                "__subdf3",
                "__aeabi_f2d",
                "__aeabi_fsub",
                "__addsf3",
                "__aeabi_fcmple",
                "hypot",
                "__aeabi_fmul",
                "cos",
                "__aeabi_fcmpge",
                "__aeabi_fcmpeq",
                "floor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002408": {
            "entrypoint": "0x08002408",
            "current_name": "calculate_delay_and_execute_operations_08002408",
            "code": "\n/* WARNING: VarloopCounterable defloopCounterned whloopCounterch should be unmapped: inputSeconds-local */\n\nvoloopCounterd calculateDelayAndExecuteOperations_08002408(float inputSeconds)\n\n{\n  uloopCounternt16_t milliseconds;\n  undefloopCounterned4 conversionFactor;\n  undefloopCounterned4 product;\n  undefloopCounterned4 subtraction;\n  undefloopCounterned4 conversionError1;\n  undefloopCounterned4 conversionError2;\n  undefloopCounterned4 unmappedVariable;\n  float secondsLocal;\n  uloopCounternt16_t loopCounter;\n  \n  product = __aeabloopCounter_fmul(inputSeconds,conversionFactor,0x41a00000);\n  product = __aeabloopCounter_f2d(product);\n  floor((double)CONCAT44(conversionFactor,unmappedVariable));\n  loopCounter = __aeabloopCounter_d2uloopCounterz(product,conversionError1);\n  plan_synchronloopCounterze();\n  product = __aeabloopCounter_fmul(conversionFactor,0x447a0000);\n  subtraction = __floatsloopCountersf((uloopCounternt)loopCounter * 0x32);\n  product = __aeabloopCounter_fsub(product,subtraction);\n  product = __aeabloopCounter_f2d(product);\n  floor((double)CONCAT44(conversionFactor,unmappedVariable));\n  milliseconds = __aeabloopCounter_d2uloopCounterz(product,conversionError2);\n  delay_milliseconds(milliseconds);\n  whloopCounterle ((loopCounter != 0 && (protocol_execute_runtloopCounterme(), sys.abort == '\\0'))) {\n    _delay_milliseconds(0x32);\n    loopCounter = loopCounter - 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002408": "calculate_delay_and_execute_operations_08002408",
                "seconds": "inputSeconds",
                "ms": "milliseconds",
                "in_r0": "conversionFactor",
                "uVar1": "product",
                "uVar2": "subtraction",
                "extraout_r1": "conversionError1",
                "extraout_r1_00": "conversionError2",
                "uStack_20": "unmappedVariable",
                "seconds_local": "secondsLocal",
                "i": "loopCounter"
            },
            "calling": [
                "gc_execute_line"
            ],
            "called": [
                "__floatsisf",
                "__aeabi_f2d",
                "plan_synchronize",
                "__aeabi_fsub",
                "__aeabi_fmul",
                "__aeabi_d2uiz",
                "delay_ms",
                "protocol_execute_runtime",
                "_delay_ms",
                "floor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080024c4": {
            "entrypoint": "0x080024c4",
            "current_name": "initialize_system_080024c4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_system_080024c4(void)\n\n{\n  uint8_t inverted_feed_rate;\n  undefined4 converted_x_dir;\n  undefined8 converted_z_dir;\n  float z_coordinate;\n  float feed_rate;\n  int8_t z_direction;\n  int8_t y_direction;\n  int8_t x_direction;\n  \n  sys.state = '\\x05';\n  limits_enabled = 0;\n  limits_go_home();\n  protocol_execute_runtime();\n  if (sys.abort == '\\0') {\n    memset(sys.position,0,0xc);\n    sys_sync_current_position();\n    sys.state = '\\0';\n    if ((settings.homing_dir_mask & 0x20) == 0) {\n      x_direction = -1;\n    }\n    else {\n      x_direction = '\\x01';\n    }\n    if ((settings.homing_dir_mask & 0x80) == 0) {\n      y_direction = -1;\n    }\n    else {\n      y_direction = '\\x01';\n    }\n    if ((settings.homing_dir_mask & 0x200) == 0) {\n      z_direction = -1;\n    }\n    else {\n      z_direction = '\\x01';\n    }\n    converted_x_dir = __floatsisf((int)x_direction);\n    inverted_feed_rate = __aeabi_fmul(converted_x_dir,settings.homing_pulloff);\n    converted_x_dir = __floatsisf((int)y_direction);\n    __aeabi_fmul(converted_x_dir,settings.homing_pulloff);\n    converted_x_dir = __floatsisf((int)z_direction);\n    converted_z_dir = __aeabi_fmul(converted_x_dir,settings.homing_pulloff);\n    mc_line((float)converted_z_dir,(float)((ulonglong)converted_z_dir >> 0x20),z_coordinate,feed_rate,inverted_feed_rate);\n    st_cycle_start();\n    plan_synchroniz_coordinatee();\n    sys_sync_current_position();\n    if ((settings.flags & 8) != 0) {\n      limits_enabled = 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080024c4": "initialize_system_080024c4",
                "x_dir": "x_direction",
                "y_dir": "y_direction",
                "z_dir": "z_direction",
                "invert_feed_rate": "inverted_feed_rate",
                "uVar1": "converted_x_dir",
                "uVar2": "converted_z_dir",
                "z": "z_coordinate"
            },
            "calling": [
                "protocol_execute_line"
            ],
            "called": [
                "__floatsisf",
                "sys_sync_current_position",
                "limits_go_home",
                "plan_synchronize",
                "__aeabi_fmul",
                "protocol_execute_runtime",
                "st_cycle_start",
                "mc_line",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025e8": {
            "entrypoint": "0x080025e8",
            "current_name": "execute_and_check_state_080025e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid execute_and_check_state_080025e8(void)\n\n{\n  if ((sys_execute & 0x10) == 0) {\n    sys_execute = sys_execute | 0x10;\n    stop_spindle();\n    stop_coolant();\n    if (sys_state - 3 < 3) {\n      sys_execute = sys_execute | 0x20;\n      go_idle();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080025e8": "execute_and_check_state_080025e8",
                "sys.execute": "sys_execute",
                "spindle_stop": "stop_spindle",
                "coolant_stop": "stop_coolant",
                "sys.state": "sys_state",
                "st_go_idle": "go_idle"
            },
            "calling": [
                "gc_execute_line",
                "limits_isr",
                "protocol_execute_line",
                "serial_rx_hook",
                "buttons_isr"
            ],
            "called": [
                "spindle_stop",
                "st_go_idle",
                "coolant_stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002638": {
            "entrypoint": "0x08002638",
            "current_name": "parse_float_08002638",
            "code": "\nint parseFloat_08002638(char *inputString,uint8_t *charCounter,float *outputFloat)\n\n{\n  byte digit;\n  bool isNegative;\n  bool isExponent;\n  uchar *nextChar;\n  uchar *currentChar;\n  int returnValue;\n  undefined8 convertedValue;\n  float *localFloatPtr;\n  uint8_t *localCharCounter;\n  char *localInputString;\n  float floatValue;\n  _Bool isDecimal;\n  uint8_t digitCount;\n  int8_t exponent;\n  uint32_t integerValue;\n  _Bool isNegativeValue;\n  uchar c;\n  char *nextCharPointer;\n  \n  currentChar = (uchar *)(inputString + *charCounter);\n  nextChar = currentChar + 1;\n  c = *currentChar;\n  isNegative = false;\n  if (c == '-') {\n    isNegative = true;\n    c = *nextChar;\n    nextCharPointer = (char *)(currentChar + 2);\n  }\n  else {\n    nextCharPointer = (char *)nextChar;\n    if (c == '+') {\n      nextCharPointer = (char *)(currentChar + 2);\n      c = *nextChar;\n    }\n  }\n  integerValue = 0;\n  exponent = '\\0';\n  digitCount = '\\0';\n  isExponent = false;\n  do {\n    digit = c - 0x30;\n    if (digit < 10) {\n      digitCount = digitCount + 1;\n      if (digitCount < 9) {\n        if (isExponent) {\n          exponent = exponent + -1;\n        }\n        integerValue = (uint)digit + integerValue * 10;\n      }\n      else if (!isExponent) {\n        exponent = exponent + '\\x01';\n      }\n    }\n    else {\n      if ((digit != 0xfe) || (isExponent)) {\n        if (digitCount == '\\0') {\n          returnValue = 0;\n        }\n        else {\n          floatValue = (float)__floatunsisf(integerValue);\n          returnValue = __aeabi_fcmpeq(floatValue,0);\n          if (returnValue == 0) {\n            for (; exponent < -1; exponent = exponent + '\\x02') {\n              convertedValue = __aeabi_f2d(floatValue);\n              convertedValue = __muldf3((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20),0x47ae147b,0x3f847ae1);\n              floatValue = (float)__truncdfsf2((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20));\n            }\n            if (exponent < '\\0') {\n              convertedValue = __aeabi_f2d(floatValue);\n              convertedValue = __muldf3((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20),0x9999999a,0x3fb99999);\n              floatValue = (float)__truncdfsf2((int)convertedValue,(int)((ulonglong)convertedValue >> 0x20));\n            }\n            else {\n              for (; '\\0' < exponent; exponent = exponent + -1) {\n                floatValue = (float)__aeabi_fmul(floatValue,0x41200000);\n              }\n            }\n          }\n          if (isNegative) {\n            *outputFloat = (float)((uint)floatValue ^ 0x80000000);\n          }\n          else {\n            *outputFloat = floatValue;\n          }\n          *charCounter = ((char)nextCharPointer - (char)inputString) + 0xff;\n          returnValue = 1;\n        }\n        return returnValue;\n      }\n      isExponent = true;\n    }\n    c = *nextCharPointer;\n    nextCharPointer = nextCharPointer + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08002638": "parse_float_08002638",
                "line": "inputString",
                "char_counter": "charCounter",
                "float_ptr": "outputFloat",
                "bVar1": "digit",
                "bVar2": "isNegative",
                "bVar3": "isExponent",
                "puVar4": "nextChar",
                "puVar5": "currentChar",
                "iVar6": "returnValue",
                "uVar7": "convertedValue",
                "float_ptr_local": "localFloatPtr",
                "char_counter_local": "localCharCounter",
                "line_local": "localInputString",
                "fval": "floatValue",
                "isdecimal": "isDecimal",
                "ndigit": "digitCount",
                "exp": "exponent",
                "intval": "integerValue",
                "isnegative": "isNegativeValue",
                "ptr": "nextCharPointer"
            },
            "calling": [
                "protocol_execute_line",
                "next_statement"
            ],
            "called": [
                "__aeabi_f2d",
                "__muldf3",
                "__floatunsisf",
                "__truncdfsf2",
                "__aeabi_fmul",
                "__aeabi_fcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002814": {
            "entrypoint": "0x08002814",
            "current_name": "delay_function_08002814",
            "code": "\nvoid delayFunction_08002814(uint16_t milliseconds)\n\n{\n  uint16_t localMilliseconds;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08002814": "delay_function_08002814",
                "ms": "milliseconds",
                "ms_local": "localMilliseconds"
            },
            "calling": [
                "limits_go_home",
                "mc_dwell",
                "report_alarm_message"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002828": {
            "entrypoint": "0x08002828",
            "current_name": "initialize_value_08002828",
            "code": "\nvoid initializeValue_08002828(uint32_t inputValue)\n\n{\n  uint32_t localValue;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08002828": "initialize_value_08002828",
                "us": "inputValue",
                "us_local": "localValue"
            },
            "calling": [
                "homing_cycle"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800283a": {
            "entrypoint": "0x0800283a",
            "current_name": "set_position_0800283a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_position_0800283a(void)\n\n{\n  plan_set_current_position(current_x,current_y,current_z);\n  gc_set_current_position(current_x,current_y,current_z);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800283a": "set_position_0800283a",
                "sys.position[0]": "current_x",
                "sys.position[1]": "current_y",
                "sys.position[2]": "current_z"
            },
            "calling": [
                "mc_go_home",
                "grbl_main"
            ],
            "called": [
                "gc_set_current_position",
                "plan_set_current_position"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002870": {
            "entrypoint": "0x08002870",
            "current_name": "increment_and_reset_block_index_08002870",
            "code": "\nuint8_t incrementAndResetBlockIndex_08002870(uint8_t originalBlockIndex)\n\n{\n  uint8_t incrementedBlockIndex;\n  \n  incrementedBlockIndex = originalBlockIndex + '\\x01';\n  if (incrementedBlockIndex == '\\x12') {\n    incrementedBlockIndex = '\\0';\n  }\n  return incrementedBlockIndex;\n}\n\n",
            "renaming": {
                "FUN_08002870": "increment_and_reset_block_index_08002870",
                "block_index": "originalBlockIndex",
                "block_index_local": "incrementedBlockIndex"
            },
            "calling": [
                "plan_reset_buffer",
                "planner_forward_pass",
                "planner_recalculate_trapezoids",
                "plan_discard_current_block",
                "plan_buffer_line"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002896": {
            "entrypoint": "0x08002896",
            "current_name": "calculate_adjusted_block_index_08002896",
            "code": "\nuint8_t calculateAdjustedBlockIndex_08002896(uint8_t originalBlockIndex)\n\n{\n  uint8_t adjustedBlockIndex;\n  \n  adjustedBlockIndex = originalBlockIndex;\n  if (originalBlockIndex == '\\0') {\n    adjustedBlockIndex = '\\x12';\n  }\n  return adjustedBlockIndex + 0xff;\n}\n\n",
            "renaming": {
                "FUN_08002896": "calculate_adjusted_block_index_08002896",
                "block_index": "originalBlockIndex",
                "block_index_local": "adjustedBlockIndex"
            },
            "calling": [
                "planner_reverse_pass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028bc": {
            "entrypoint": "0x080028bc",
            "current_name": "calculate_rate_080028bc",
            "code": "\nfloat calculateRate_080028bc(float initialRate,float targetRate,float acceleration)\n\n{\n  undefined4 initial_rate_local;\n  undefined4 initial_rate_squared;\n  undefined4 acceleration_doubled;\n  undefined4 target_rate_local;\n  undefined4 acceleration_local;\n  float rate_difference;\n  float acceleration_local;\n  float targetRate_local;\n  float initialRate_local;\n  \n  initial_rate_squared = __aeabi_fmul(target_rate_local,target_rate_local);\n  acceleration_doubled = __aeabi_fmul(initial_rate_local,initial_rate_local);\n  initial_rate_squared = __aeabi_fsub(initial_rate_squared,acceleration_doubled);\n  acceleration_doubled = __addsf3(acceleration_local,acceleration_local);\n  rate_difference = (float)__aeabi_fdiv(initial_rate_squared,acceleration_doubled);\n  return rate_difference;\n}\n\n",
            "renaming": {
                "FUN_080028bc": "calculate_rate_080028bc",
                "initial_rate": "initialRate",
                "target_rate": "targetRate",
                "in_r0": "initial_rate_local",
                "uVar1": "initial_rate_squared",
                "uVar2": "acceleration_doubled",
                "in_r1": "target_rate_local",
                "in_r2": "acceleration_local",
                "fVar3": "rate_difference"
            },
            "calling": [
                "calculate_trapezoid_for_block"
            ],
            "called": [
                "__aeabi_fsub",
                "__addsf3",
                "__aeabi_fmul",
                "__aeabi_fdiv"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002908": {
            "entrypoint": "0x08002908",
            "current_name": "calculate_acceleration_08002908",
            "code": "\nfloat calculateAcceleration_08002908(float initialRate,float finalRate,float acceleration,float distance)\n\n{\n  undefined4 firstOperand;\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined4 secondOperand;\n  undefined4 thirdOperand;\n  undefined4 fourthOperand;\n  float result;\n  float localDistance;\n  float localAcceleration;\n  float localFinalRate;\n  float localInitialRate;\n  \n  temp1 = __addsf3(thirdOperand,thirdOperand);\n  temp1 = __aeabi_fmul(temp1,fourthOperand);\n  temp2 = __aeabi_fmul(firstOperand,firstOperand);\n  temp1 = __aeabi_fsub(temp1,temp2);\n  temp2 = __aeabi_fmul(secondOperand,secondOperand);\n  temp1 = __addsf3(temp1,temp2);\n  temp2 = __aeabi_fmul(thirdOperand,0x40800000);\n  result = (float)__aeabi_fdiv(temp1,temp2);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002908": "calculate_acceleration_08002908",
                "initial_rate": "initialRate",
                "final_rate": "finalRate",
                "in_r0": "firstOperand",
                "in_r1": "secondOperand",
                "in_r2": "thirdOperand",
                "in_r3": "fourthOperand",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "fVar3": "result",
                "distance_local": "localDistance",
                "acceleration_local": "localAcceleration",
                "final_rate_local": "localFinalRate",
                "initial_rate_local": "localInitialRate"
            },
            "calling": [
                "calculate_trapezoid_for_block"
            ],
            "called": [
                "__aeabi_fsub",
                "__addsf3",
                "__aeabi_fmul",
                "__aeabi_fdiv"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002978": {
            "entrypoint": "0x08002978",
            "current_name": "calculate_final_velocity_08002978",
            "code": "\n/* WARNING: Variable defined which should be unmapped: initialDistance-local */\n\nfloat calculateFinalVelocity_08002978(float acceleration,float targetVelocity,float initialDistance)\n\n{\n  undefined4 tempVar1;\n  undefined4 product1;\n  undefined4 product2;\n  undefined4 tempVar2;\n  undefined4 tempVar4;\n  undefined4 tempVar3;\n  float finalVelocity;\n  undefined4 stackVariable1;\n  float localDistance;\n  float localTargetVelocity;\n  float localAcceleration;\n  \n  product1 = __aeabi_fmul(acceleration,tempVar2,tempVar2);\n  product2 = __addsf3(tempVar1,tempVar1);\n  product2 = __aeabi_fmul(product2,tempVar3);\n  product1 = __aeabi_fsub(product1,product2);\n  product1 = __aeabi_f2d(product1);\n  sqrt((double)CONCAT44(tempVar3,stackVariable1));\n  finalVelocity = (float)__truncdfsf2(product1,tempVar4);\n  return finalVelocity;\n}\n\n",
            "renaming": {
                "FUN_08002978": "calculate_final_velocity_08002978",
                "target_velocity": "targetVelocity",
                "distance": "initialDistance",
                "in_r0": "tempVar1",
                "in_r1": "tempVar2",
                "in_r2": "tempVar3",
                "extraout_r1": "tempVar4",
                "uVar1": "product1",
                "uVar2": "product2",
                "fVar3": "finalVelocity",
                "uStack_20": "stackVariable1",
                "distance_local": "localDistance",
                "target_velocity_local": "localTargetVelocity",
                "acceleration_local": "localAcceleration"
            },
            "calling": [
                "planner_forward_pass_kernel",
                "planner_reverse_pass_kernel",
                "plan_buffer_line"
            ],
            "called": [
                "__aeabi_f2d",
                "__aeabi_fsub",
                "__truncdfsf2",
                "__addsf3",
                "sqrt",
                "__aeabi_fmul"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080029d8": {
            "entrypoint": "0x080029d8",
            "current_name": "update_entry_speed_080029d8",
            "code": "\nvoid updateEntrySpeed_080029d8(block_t *previousBlock,block_t *currentBlock,block_t *nextBlock)\n\n{\n  int comparisonResult;\n  uint negativeAcceleration;\n  float newEntrySpeed;\n  float accelerationValue;\n  float accelerationValue_00;\n  float targetVelocity;\n  float targetVelocity_00;\n  float distanceValue;\n  float distanceValue_00;\n  block_t *localNextBlock;\n  block_t *localCurrentBlock;\n  block_t *localPreviousBlock;\n  \n  if (((currentBlock != (block_t *)0x0) && (nextBlock != (block_t *)0x0)) &&\n     (comparisonResult = __aeabi_fcmpeq(currentBlock->entry_speed,currentBlock->max_entry_speed), comparisonResult == 0)) {\n    if ((currentBlock->nominal_length_flag == '\\0') &&\n       (comparisonResult = __aeabi_fcmpgt(currentBlock->max_entry_speed,nextBlock->entry_speed), comparisonResult != 0)) {\n      newEntrySpeed = currentBlock->max_entry_speed;\n      negativeAcceleration = (uint)settings.accelerationValue ^ 0x80000000;\n      max_allowable_speed(accelerationValue,targetVelocity,distanceValue);\n      comparisonResult = __aeabi_fcmplt(newEntrySpeed,negativeAcceleration);\n      if (comparisonResult == 0) {\n        newEntrySpeed = (float)((uint)settings.accelerationValue ^ 0x80000000);\n        max_allowable_speed(accelerationValue_00,targetVelocity_00,distanceValue_00);\n      }\n      else {\n        newEntrySpeed = currentBlock->max_entry_speed;\n      }\n      currentBlock->entry_speed = newEntrySpeed;\n    }\n    else {\n      currentBlock->entry_speed = currentBlock->max_entry_speed;\n    }\n    currentBlock->recalculate_flag = '\\x01';\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080029d8": "update_entry_speed_080029d8",
                "previous": "previousBlock",
                "current": "currentBlock",
                "next": "nextBlock",
                "iVar1": "comparisonResult",
                "uVar2": "negativeAcceleration",
                "fVar3": "newEntrySpeed",
                "acceleration": "accelerationValue",
                "acceleration_00": "accelerationValue_00",
                "target_velocity": "targetVelocity",
                "target_velocity_00": "targetVelocity_00",
                "distance": "distanceValue",
                "distance_00": "distanceValue_00",
                "next_local": "localNextBlock",
                "current_local": "localCurrentBlock",
                "previous_local": "localPreviousBlock"
            },
            "calling": [
                "planner_reverse_pass"
            ],
            "called": [
                "__aeabi_fcmplt",
                "__aeabi_fcmpgt",
                "__aeabi_fcmpeq",
                "max_allowable_speed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002a94": {
            "entrypoint": "0x08002a94",
            "current_name": "reverse_blocks_08002a94",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reverse_blocks_08002a94(void)\n\n{\n  blocks_t *next_block;\n  blocks_t *blocks [3];\n  uint8_t current_block_index;\n  \n  current_block_index = head_block_buffer;\n  blocks[0] = (blocks_t *)0x0;\n  blocks[1] = (blocks_t *)0x0;\n  while (next_block = blocks[1], current_block_index != tail_block_buffer) {\n    current_block_index = get_previous_block_index(current_block_index);\n    blocks[1] = blocks[0];\n    reverse_pass_kernel(buffer + current_block_index,blocks[0],next_block);\n    blocks[0] = buffer + current_block_index;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002a94": "reverse_blocks_08002a94",
                "block_index": "current_block_index",
                "block": "blocks",
                "next": "next_block",
                "block_buffer_head": "head_block_buffer",
                "block_buffer_tail": "tail_block_buffer",
                "block_buffer": "buffer",
                "prev_block_index": "get_previous_block_index",
                "planner_reverse_pass_kernel": "reverse_pass_kernel"
            },
            "calling": [
                "planner_recalculate"
            ],
            "called": [
                "prev_block_index",
                "planner_reverse_pass_kernel"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002afc": {
            "entrypoint": "0x08002afc",
            "current_name": "update_entry_speed_08002afc",
            "code": "\nvoid updateEntrySpeed_08002afc(block_t *prevBlock,block_t *currentBlock,block_t *nextBlock)\n\n{\n  int comparisonResult;\n  uint flippedAcceleration;\n  float newEntrySpeed;\n  float maxAcceleration;\n  float maxAcceleration2;\n  float maxVelocity;\n  float maxVelocity2;\n  float maxDistance;\n  float maxDistance2;\n  block_t *localNextBlock;\n  block_t *localCurrentBlock;\n  block_t *localPrevBlock;\n  float entrySpeed;\n  \n  if (((prevBlock != (block_t *)0x0) && (prevBlock->nominal_length_flag == '\\0')) &&\n     (comparisonResult = __aeabi_fcmplt(prevBlock->entrySpeed,currentBlock->entrySpeed), comparisonResult != 0)) {\n    newEntrySpeed = currentBlock->entrySpeed;\n    flippedAcceleration = (uint)settings.maxAcceleration ^ 0x80000000;\n    max_allowable_speed(maxAcceleration,maxVelocity,maxDistance);\n    comparisonResult = __aeabi_fcmplt(newEntrySpeed,flippedAcceleration);\n    if (comparisonResult == 0) {\n      newEntrySpeed = (float)((uint)settings.maxAcceleration ^ 0x80000000);\n      max_allowable_speed(maxAcceleration2,maxVelocity2,maxDistance2);\n    }\n    else {\n      newEntrySpeed = currentBlock->entrySpeed;\n    }\n    comparisonResult = __aeabi_fcmpeq(newEntrySpeed,currentBlock->entrySpeed);\n    if (comparisonResult == 0) {\n      currentBlock->entrySpeed = newEntrySpeed;\n      currentBlock->recalculate_flag = '\\x01';\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002afc": "update_entry_speed_08002afc",
                "previous": "prevBlock",
                "current": "currentBlock",
                "next": "nextBlock",
                "iVar1": "comparisonResult",
                "uVar2": "flippedAcceleration",
                "fVar3": "newEntrySpeed",
                "acceleration": "maxAcceleration",
                "acceleration_00": "maxAcceleration2",
                "target_velocity": "maxVelocity",
                "target_velocity_00": "maxVelocity2",
                "distance": "maxDistance",
                "distance_00": "maxDistance2",
                "next_local": "localNextBlock",
                "current_local": "localCurrentBlock",
                "previous_local": "localPrevBlock",
                "entry_speed": "entrySpeed"
            },
            "calling": [
                "planner_forward_pass"
            ],
            "called": [
                "__aeabi_fcmplt",
                "max_allowable_speed",
                "__aeabi_fcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ba8": {
            "entrypoint": "0x08002ba8",
            "current_name": "perform_forward_pass_08002ba8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid performForwardPass_08002ba8(void)\n\n{\n  blocks_t *previousBlock;\n  uint index;\n  blocks_t *blocks [3];\n  uint8_t currentIndex;\n  \n  blocks[1] = (blocks_t *)0x0;\n  blocks[2] = (blocks_t *)0x0;\n  currentIndex = blocks_buffer_tail;\n  while (previousBlock = blocks[1], currentIndex != blocks_buffer_head) {\n    blocks[1] = blocks[2];\n    index = (uint)currentIndex;\n    planner_forward_pass_kernel(previousBlock,blocks[2],blocks_buffer + index);\n    currentIndex = next_currentIndex(currentIndex);\n    blocks[2] = blocks_buffer + index;\n  }\n  planner_forward_pass_kernel(blocks[1],blocks[2],(blocks_t *)0x0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ba8": "perform_forward_pass_08002ba8",
                "previous": "previousBlock",
                "uVar1": "index",
                "block": "blocks",
                "block_index": "currentIndex"
            },
            "calling": [
                "planner_recalculate"
            ],
            "called": [
                "planner_forward_pass_kernel",
                "next_block_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c18": {
            "entrypoint": "0x08002c18",
            "current_name": "estimate_acceleration_08002c18",
            "code": "\n/* WARNING: Variable defined which should be unmapped: exitFactor-local */\n\nvoid estimateAcceleration_08002c18(inputBlock_t *inputBlock,float entryFactor,float exitFactor)\n\n{\n  undefined4 convertedRate1;\n  uint32_t convertedRate2;\n  int rateDelta;\n  int estimatedRate1;\n  uint estimatedRate2;\n  undefined4 constant1;\n  undefined4 constant2;\n  undefined4 constant3;\n  undefined4 constant4;\n  undefined4 constant5;\n  undefined4 constant6;\n  undefined4 constant7;\n  float estimatedAccel1;\n  float estimatedAccel2;\n  float estimatedAccel3;\n  float estimatedDistance;\n  undefined8 convertedDistance;\n  undefined4 temporary;\n  float exitFactorLocal;\n  float entryFactorLocal;\n  inputBlock_t *blockLocal;\n  int32_t decelerateSteps;\n  int32_t accelerationPerMinute;\n  int32_t plateauSteps;\n  int32_t accelerateSteps;\n  \n  convertedRate1 = __floatunsisf(entryFactor,inputBlock->nominal_rate);\n  convertedRate1 = __aeabi_fmul(convertedRate1,constant1);\n  convertedRate1 = __aeabi_f2d(convertedRate1);\n  ceil((double)CONCAT44(constant7,temporary));\n  convertedRate2 = __aeabi_d2uiz(convertedRate1,constant2);\n  inputBlock->initial_rate = convertedRate2;\n  convertedRate1 = __floatunsisf(inputBlock->nominal_rate);\n  convertedRate1 = __aeabi_fmul(convertedRate1,constant7);\n  convertedRate1 = __aeabi_f2d(convertedRate1);\n  ceil((double)CONCAT44(constant7,temporary));\n  convertedRate2 = __aeabi_d2uiz(convertedRate1,constant3);\n  inputBlock->final_rate = convertedRate2;\n  convertedDistance = __aeabi_i2d(inputBlock->rate_delta * 0x32);\n  convertedDistance = __muldf3((int)convertedDistance,(int)((ulonglong)convertedDistance >> 0x20),0,0x404e0000);\n  rateDelta = __aeabi_d2iz((int)convertedDistance,(int)((ulonglong)convertedDistance >> 0x20));\n  convertedRate1 = __floatunsisf(inputBlock->initial_rate);\n  __floatunsisf(inputBlock->nominal_rate);\n  convertedDistance = __floatsisf(rateDelta);\n  estimate_estimatedAccel1_estimatedDistance((float)convertedDistance,(float)((ulonglong)convertedDistance >> 0x20),estimatedAccel1);\n  convertedRate1 = __aeabi_f2d(convertedRate1);\n  ceil((double)CONCAT44(constant7,temporary));\n  accelerateSteps = __aeabi_d2iz(convertedRate1,constant4);\n  convertedRate1 = __floatunsisf(inputBlock->nominal_rate);\n  __floatunsisf(inputBlock->final_rate);\n  convertedDistance = __floatsisf(-rateDelta);\n  estimate_estimatedAccel1_estimatedDistance((float)convertedDistance,(float)((ulonglong)convertedDistance >> 0x20),estimatedAccel2);\n  convertedRate1 = __aeabi_f2d(convertedRate1);\n  floor((double)CONCAT44(constant7,temporary));\n  estimatedRate1 = __aeabi_d2iz(convertedRate1,constant5);\n  plateauSteps = (inputBlock->step_event_count - accelerateSteps) - estimatedRate1;\n  if (plateauSteps < 0) {\n    convertedRate1 = __floatunsisf(inputBlock->initial_rate);\n    __floatunsisf(inputBlock->final_rate);\n    __floatsisf(rateDelta);\n    convertedDistance = __floatsisf(inputBlock->step_event_count);\n    intersection_estimatedDistance((float)convertedDistance,(float)((ulonglong)convertedDistance >> 0x20),estimatedAccel3,estimatedDistance);\n    convertedRate1 = __aeabi_f2d(convertedRate1);\n    ceil((double)CONCAT44(constant7,temporary));\n    estimatedRate2 = __aeabi_d2iz(convertedRate1,constant6);\n    estimatedRate2 = estimatedRate2 & ~((int)estimatedRate2 >> 0x1f);\n    accelerateSteps = inputBlock->step_event_count;\n    if ((int)estimatedRate2 <= inputBlock->step_event_count) {\n      accelerateSteps = estimatedRate2;\n    }\n    plateauSteps = 0;\n  }\n  inputBlock->accelerate_until = accelerateSteps;\n  inputBlock->decelerate_after = plateauSteps + accelerateSteps;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c18": "estimate_acceleration_08002c18",
                "block": "inputBlock",
                "entry_factor": "entryFactor",
                "exit_factor": "exitFactor",
                "uVar1": "convertedRate1",
                "uVar2": "convertedRate2",
                "iVar3": "rateDelta",
                "iVar4": "estimatedRate1",
                "uVar5": "estimatedRate2",
                "in_r1": "constant1",
                "extraout_r1": "constant2",
                "extraout_r1_00": "constant3",
                "extraout_r1_01": "constant4",
                "extraout_r1_02": "constant5",
                "extraout_r1_03": "constant6",
                "in_r2": "constant7",
                "acceleration": "estimatedAccel1",
                "acceleration_00": "estimatedAccel2",
                "acceleration_01": "estimatedAccel3",
                "distance": "estimatedDistance",
                "uVar6": "convertedDistance",
                "uStack_38": "temporary",
                "exit_factor_local": "exitFactorLocal",
                "entry_factor_local": "entryFactorLocal",
                "block_local": "blockLocal",
                "decelerate_steps": "decelerateSteps",
                "acceleration_per_minute": "accelerationPerMinute",
                "plateau_steps": "plateauSteps",
                "accelerate_steps": "accelerateSteps"
            },
            "calling": [
                "planner_recalculate_trapezoids"
            ],
            "called": [
                "__floatsisf",
                "__aeabi_f2d",
                "__muldf3",
                "intersection_distance",
                "__floatunsisf",
                "ceil",
                "__aeabi_d2uiz",
                "__aeabi_fmul",
                "estimate_acceleration_distance",
                "__aeabi_i2d",
                "__aeabi_d2iz",
                "floor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002e08": {
            "entrypoint": "0x08002e08",
            "current_name": "calculate_block_trapezoids_08002e08",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calculate_block_trapezoids_08002e08(void)\n\n{\n  uint blockIndex;\n  undefined8 divisionResult;\n  block_t *currentBlock;\n  block_t *nextBlock;\n  uint8_t blockIndex;\n  \n  nextBlock = (block_t *)0x0;\n  blockIndex = blockBufferTail;\n  while (blockIndex != blockBufferHead) {\n    blockIndex = (uint)blockIndex;\n    if ((nextBlock != (block_t *)0x0) &&\n       ((nextBlock->recalculate_flag != '\\0' || (blockBuffer[blockIndex].recalculate_flag != '\\0')))) {\n      __aeabi_fdiv(nextBlock->entry_speed,nextBlock->nominal_speed);\n      divisionResult = __aeabi_fdiv(blockBuffer[blockIndex].entry_speed,nextBlock->nominal_speed);\n      calculate_trapezoid_for_block(nextBlock,(float)divisionResult,(float)((ulonglong)divisionResult >> 0x20));\n      nextBlock->recalculate_flag = '\\0';\n    }\n    blockIndex = nextBlock_blockIndex(blockIndex);\n    nextBlock = blockBuffer + blockIndex;\n  }\n  __aeabi_fdiv(nextBlock->entry_speed,nextBlock->nominal_speed);\n  divisionResult = __aeabi_fdiv(0,nextBlock->nominal_speed);\n  calculate_trapezoid_for_block(nextBlock,(float)divisionResult,(float)((ulonglong)divisionResult >> 0x20));\n  nextBlock->recalculate_flag = '\\0';\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002e08": "calculate_block_trapezoids_08002e08",
                "uVar1": "blockIndex",
                "uVar2": "divisionResult",
                "current": "currentBlock",
                "next": "nextBlock",
                "block_index": "blockIndex",
                "block_buffer_tail": "blockBufferTail",
                "block_buffer_head": "blockBufferHead",
                "block_buffer": "blockBuffer"
            },
            "calling": [
                "planner_recalculate"
            ],
            "called": [
                "calculate_trapezoid_for_block",
                "__aeabi_fdiv",
                "next_block_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002edc": {
            "entrypoint": "0x08002edc",
            "current_name": "optimize_planner_08002edc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid optimize_planner_08002edc(void)\n\n{\n  planner_reverse_pass();\n  planner_forward_pass();\n  planner_recalculate_trapezoids();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002edc": "optimize_planner_08002edc"
            },
            "calling": [
                "plan_cycle_reinitialize",
                "plan_buffer_line"
            ],
            "called": [
                "planner_reverse_pass",
                "planner_recalculate_trapezoids",
                "planner_forward_pass"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ef0": {
            "entrypoint": "0x08002ef0",
            "current_name": "update_buffer_08002ef0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateBuffer_08002ef0(void)\n\n{\n  currentTail = currentHead;\n  nextHead = next_block_index(currentHead);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ef0": "update_buffer_08002ef0",
                "block_buffer_tail": "currentTail",
                "block_buffer_head": "currentHead",
                "next_buffer_head": "nextHead"
            },
            "calling": [
                "plan_init"
            ],
            "called": [
                "next_block_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f24": {
            "entrypoint": "0x08002f24",
            "current_name": "initialize_buffer_08002f24",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_buffer_08002f24(void)\n\n{\n  reset_buffer();\n  memset(&plan,0,0x1c);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f24": "initialize_buffer_08002f24",
                "plan_reset_buffer": "reset_buffer",
                "pl": "plan"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [
                "plan_reset_buffer",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f40": {
            "entrypoint": "0x08002f40",
            "current_name": "update_block_buffer_tail_08002f40",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid update_block_buffer_tail_08002f40(void)\n\n{\n  if (original_block_buffer_head != updated_block_buffer_tail) {\n    updated_block_buffer_tail = get_next_block_index(updated_block_buffer_tail);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f40": "update_block_buffer_tail_08002f40",
                "block_buffer_head": "original_block_buffer_head",
                "block_buffer_tail": "updated_block_buffer_tail",
                "next_block_index": "get_next_block_index"
            },
            "calling": [
                "step_period_isr"
            ],
            "called": [
                "next_block_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f74": {
            "entrypoint": "0x08002f74",
            "current_name": "get_next_block_08002f74",
            "code": "\n/* WARNING: Unknown calling convention */\n\nblock_t * get_next_block_08002f74(void)\n\n{\n  block_t *next_block;\n  \n  if (buffer_head == buffer_tail) {\n    next_block = (block_t *)0x0;\n  }\n  else {\n    next_block = buffer + buffer_tail;\n  }\n  return next_block;\n}\n\n",
            "renaming": {
                "FUN_08002f74": "get_next_block_08002f74",
                "pbVar1": "next_block",
                "block_buffer_head": "buffer_head",
                "block_buffer_tail": "buffer_tail",
                "block_buffer": "buffer"
            },
            "calling": [
                "plan_synchronize",
                "step_period_isr"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002fac": {
            "entrypoint": "0x08002fac",
            "current_name": "is_block_buffer_tail_equal_next_buffer_head_08002fac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t isBlockBufferTailEqualNextBufferHead_08002fac(void)\n\n{\n  return block_buffer_tail == next_buffer_head;\n}\n\n",
            "renaming": {
                "FUN_08002fac": "is_block_buffer_tail_equal_next_buffer_head_08002fac"
            },
            "calling": [
                "mc_line"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002fd4": {
            "entrypoint": "0x08002fd4",
            "current_name": "execute_until_abort_08002fd4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid execute_until_abort_08002fd4(void)\n\n{\n  block_t *current_block;\n  \n  while ((current_block = get_current_block(), current_block != (block_t *)0x0 || (system_state == '\\x03'))) {\n    execute_runtime_protocol();\n    if (abort_flag != '\\0') {\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002fd4": "execute_until_abort_08002fd4",
                "pbVar1": "current_block",
                "plan_get_current_block": "get_current_block",
                "sys.state": "system_state",
                "protocol_execute_runtime": "execute_runtime_protocol",
                "sys.abort": "abort_flag"
            },
            "calling": [
                "gc_execute_line",
                "mc_go_home",
                "mc_dwell",
                "coolant_run",
                "spindle_run"
            ],
            "called": [
                "protocol_execute_runtime",
                "plan_get_current_block"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003004": {
            "entrypoint": "0x08003004",
            "current_name": "calculate_motion_08003004",
            "code": "\n/* WARNING: Variable defined which should be unmapped: feedRate-local */\n\nvoid calculateMotion_08003004(float currentX,float currentY,float currentZ,float feedRate,uint8_t invertFeedRate)\n\n{\n  undefined4 stepsX;\n  long targetX;\n  long targetY;\n  long targetZ;\n  undefined4 stepsY;\n  undefined4 stepsZ;\n  undefined4 distanceSquared;\n  undefined4 uVar8;\n  float millimeters;\n  int32_t iVar10;\n  float unitVecX;\n  float unitVecY;\n  float unitVecZ;\n  int iVar14;\n  float fVar15;\n  undefined4 in_r1;\n  undefined4 ecurrentXtraout_r1;\n  undefined4 ecurrentXtraout_r1_00;\n  undefined4 ecurrentXtraout_r1_01;\n  undefined4 ecurrentXtraout_r1_02;\n  undefined4 ecurrentXtraout_r1_03;\n  undefined4 ecurrentXtraout_r1_04;\n  undefined4 in_r2;\n  uint stepsX6;\n  undefined4 in_r3;\n  uint stepsX7;\n  currentBlock_t *currentBlock;\n  uint32_t diffX;\n  uint maxDiff;\n  undefined8 ecurrentXtraout_d0;\n  undefined8 ecurrentXtraout_d0_00;\n  undefined8 ecurrentXtraout_d0_01;\n  undefined8 ecurrentXtraout_d0_02;\n  undefined8 ecurrentXtraout_d0_03;\n  undefined8 ecurrentXtraout_d0_04;\n  float ecurrentXtraout_s2;\n  float ecurrentXtraout_s2_00;\n  float ecurrentXtraout_s2_01;\n  float ecurrentXtraout_s2_02;\n  float ecurrentXtraout_s2_03;\n  float ecurrentXtraout_s2_04;\n  undefined8 diffSquared;\n  undefined8 uVar22;\n  undefined8 uVar23;\n  char shouldInvert;\n  float localFeedRate;\n  float localZ;\n  float localY;\n  float localX;\n  float unitVector [3];\n  float delta [3];\n  int32_t target [3];\n  float vAllowable;\n  float sinThetaDiv2;\n  float cosTheta;\n  float invMillimeters;\n  currentBlock_t *currentBlock;\n  float maxJunctionSpeed;\n  float inverseMinute;\n  \n  stepsX7 = (uint)currentBlock_buffer_head;\n  currentBlock = currentBlock_buffer + stepsX7;\n  stepsX = __aeabi_fmul(currentX,settings.steps_per_mm[0],invertFeedRate);\n  __aeabi_f2d(stepsX);\n  targetX = lround((double)CONCAT44(in_r2,in_r3));\n  stepsX = __aeabi_fmul(settings.steps_per_mm[1],in_r1);\n  __aeabi_f2d(stepsX);\n  targetY = lround((double)CONCAT44(in_r2,in_r3));\n  stepsX = __aeabi_fmul(settings.steps_per_mm[2],in_r2);\n  __aeabi_f2d(stepsX);\n  targetZ = lround((double)CONCAT44(in_r2,in_r3));\n  currentBlock->direction_bits = 0;\n  if (targetX < pl.position[0]) {\n    currentBlock->direction_bits = currentBlock->direction_bits | 0currentX20;\n  }\n  if (targetY < pl.position[1]) {\n    currentBlock->direction_bits = currentBlock->direction_bits | 0currentX880;\n  }\n  if (targetZ < pl.position[2]) {\n    currentBlock->direction_bits = currentBlock->direction_bits | 0currentX200;\n  }\n  diffX = targetX - pl.position[0];\n  if ((int)diffX < 0) {\n    diffX = -diffX;\n  }\n  currentBlock_buffer[stepsX7].steps_currentX = diffX;\n  diffX = targetY - pl.position[1];\n  if ((int)diffX < 0) {\n    diffX = -diffX;\n  }\n  currentBlock_buffer[stepsX7].steps_currentY = diffX;\n  diffX = targetZ - pl.position[2];\n  if ((int)diffX < 0) {\n    diffX = -diffX;\n  }\n  currentBlock_buffer[stepsX7].steps_currentZ = diffX;\n  stepsX6 = currentBlock_buffer[stepsX7].steps_currentZ;\n  if (currentBlock_buffer[stepsX7].steps_currentZ < currentBlock_buffer[stepsX7].steps_currentY) {\n    stepsX6 = currentBlock_buffer[stepsX7].steps_currentY;\n  }\n  maxDiff = currentBlock_buffer[stepsX7].steps_currentX;\n  if (currentBlock_buffer[stepsX7].steps_currentX < stepsX6) {\n    maxDiff = stepsX6;\n  }\n  currentBlock_buffer[stepsX7].step_event_count = maxDiff;\n  if (currentBlock_buffer[stepsX7].step_event_count != 0) {\n    stepsX = __floatsisf(targetX - pl.position[0]);\n    stepsX = __aeabi_fdiv(stepsX,settings.steps_per_mm[0]);\n    stepsY = __floatsisf(targetY - pl.position[1]);\n    stepsY = __aeabi_fdiv(stepsY,settings.steps_per_mm[1]);\n    stepsZ = __floatsisf(targetZ - pl.position[2]);\n    stepsZ = __aeabi_fdiv(stepsZ,settings.steps_per_mm[2]);\n    distanceSquared = __aeabi_fmul(stepsX,stepsX);\n    uVar8 = __aeabi_fmul(stepsY,stepsY);\n    distanceSquared = __addsf3(distanceSquared,uVar8);\n    uVar8 = __aeabi_fmul(stepsZ,stepsZ);\n    distanceSquared = __addsf3(distanceSquared,uVar8);\n    distanceSquared = __aeabi_f2d(distanceSquared);\n    sqrt((double)CONCAT44(in_r2,in_r3));\n    millimeters = (float)__truncdfsf2(distanceSquared,ecurrentXtraout_r1);\n    currentBlock_buffer[stepsX7].millimeters = millimeters;\n    distanceSquared = __aeabi_fdiv(0currentX3f800000,currentBlock_buffer[stepsX7].millimeters);\n    if (shouldInvert == '\\0') {\n      inverseMinute = (float)__aeabi_fmul(in_r3,distanceSquared);\n    }\n    else {\n      inverseMinute = (float)__aeabi_fdiv(0currentX3f800000,in_r3);\n    }\n    millimeters = (float)__aeabi_fmul(currentBlock_buffer[stepsX7].millimeters,inverseMinute);\n    currentBlock_buffer[stepsX7].nominal_speed = millimeters;\n    uVar8 = __floatsisf(currentBlock_buffer[stepsX7].step_event_count);\n    uVar8 = __aeabi_fmul(uVar8,inverseMinute);\n    uVar8 = __aeabi_f2d(uVar8);\n    ceil((double)CONCAT44(in_r2,in_r3));\n    diffX = __aeabi_d2uicurrentZ(uVar8,ecurrentXtraout_r1_00);\n    currentBlock_buffer[stepsX7].nominal_rate = diffX;\n    uVar8 = __floatsisf(currentBlock_buffer[stepsX7].step_event_count);\n    uVar8 = __aeabi_fmul(uVar8,distanceSquared);\n    uVar8 = __aeabi_fmul(uVar8,settings.acceleration);\n    uVar8 = __aeabi_fdiv(uVar8,0currentX453b8000);\n    uVar8 = __aeabi_f2d(uVar8);\n    ceil((double)CONCAT44(in_r2,in_r3));\n    iVar10 = __aeabi_d2icurrentZ(uVar8,ecurrentXtraout_r1_01);\n    currentBlock_buffer[stepsX7].rate_delta = iVar10;\n    unitVecX = (float)__aeabi_fmul(stepsX,distanceSquared);\n    unitVecY = (float)__aeabi_fmul(stepsY,distanceSquared);\n    unitVecZ = (float)__aeabi_fmul(stepsZ,distanceSquared);\n    maxJunctionSpeed = 0.0;\n    diffSquared = ecurrentXtraout_d0;\n    millimeters = ecurrentXtraout_s2;\n    if ((currentBlock_buffer_head != currentBlock_buffer_tail) &&\n       (iVar14 = __aeabi_fcmpgt(pl.previous_nominal_speed,0), diffSquared = ecurrentXtraout_d0_00,\n       millimeters = ecurrentXtraout_s2_00, iVar14 != 0)) {\n      stepsX = __aeabi_fmul((uint)pl.previous_unitVector[0] ^ 0currentX80000000,unitVecX);\n      stepsY = __aeabi_fmul(pl.previous_unitVector[1],unitVecY);\n      stepsX = __aeabi_fsub(stepsX,stepsY);\n      stepsY = __aeabi_fmul(pl.previous_unitVector[2],unitVecZ);\n      stepsX = __aeabi_fsub(stepsX,stepsY);\n      diffSquared = __aeabi_f2d(stepsX);\n      iVar14 = __aeabi_dcmplt((int)diffSquared,(int)((ulonglong)diffSquared >> 0currentX20),0currentX66666666,0currentX3fee6666);\n      diffSquared = ecurrentXtraout_d0_01;\n      millimeters = ecurrentXtraout_s2_01;\n      if (iVar14 != 0) {\n        iVar14 = __aeabi_fcmplt(pl.previous_nominal_speed,currentBlock_buffer[stepsX7].nominal_speed);\n        maxJunctionSpeed = pl.previous_nominal_speed;\n        if (iVar14 == 0) {\n          maxJunctionSpeed = currentBlock_buffer[stepsX7].nominal_speed;\n        }\n        diffSquared = __aeabi_f2d(stepsX);\n        iVar14 = __aeabi_dcmpgt((int)diffSquared,(int)((ulonglong)diffSquared >> 0currentX20),0currentX66666666,0currentXbfee6666);\n        diffSquared = ecurrentXtraout_d0_02;\n        millimeters = ecurrentXtraout_s2_02;\n        if (iVar14 != 0) {\n          diffSquared = __aeabi_f2d(stepsX);\n          diffSquared = __subdf3(0,0currentX3ff00000,(int)diffSquared,(int)((ulonglong)diffSquared >> 0currentX20));\n          stepsX = __muldf3((int)diffSquared,(int)((ulonglong)diffSquared >> 0currentX20),0,0currentX3fe00000);\n          sqrt((double)CONCAT44(in_r2,in_r3));\n          stepsX = __truncdfsf2(stepsX,ecurrentXtraout_r1_02);\n          diffSquared = __aeabi_f2d(maxJunctionSpeed);\n          stepsY = __aeabi_fmul(settings.acceleration,settings.junction_deviation);\n          stepsY = __aeabi_fmul(stepsY,stepsX);\n          uVar22 = __aeabi_f2d(stepsY);\n          uVar23 = __aeabi_f2d(stepsX);\n          uVar23 = __subdf3(0,0currentX3ff00000,(int)uVar23,(int)((ulonglong)uVar23 >> 0currentX20));\n          stepsY = __divdf3((int)uVar22,(int)((ulonglong)uVar22 >> 0currentX20),(int)uVar23,\n                           (int)((ulonglong)uVar23 >> 0currentX20));\n          sqrt((double)CONCAT44(in_r2,in_r3));\n          iVar14 = __aeabi_dcmplt((int)diffSquared,(int)((ulonglong)diffSquared >> 0currentX20),stepsY,ecurrentXtraout_r1_03)\n          ;\n          diffSquared = ecurrentXtraout_d0_03;\n          millimeters = ecurrentXtraout_s2_03;\n          if (iVar14 == 0) {\n            stepsY = __aeabi_fmul(settings.acceleration,settings.junction_deviation);\n            stepsY = __aeabi_fmul(stepsY,stepsX);\n            diffSquared = __aeabi_f2d(stepsY);\n            uVar22 = __aeabi_f2d(stepsX);\n            uVar22 = __subdf3(0,0currentX3ff00000,(int)uVar22,(int)((ulonglong)uVar22 >> 0currentX20));\n            stepsX = __divdf3((int)diffSquared,(int)((ulonglong)diffSquared >> 0currentX20),(int)uVar22,\n                             (int)((ulonglong)uVar22 >> 0currentX20));\n            sqrt((double)CONCAT44(in_r2,in_r3));\n            maxJunctionSpeed = (float)__truncdfsf2(stepsX,ecurrentXtraout_r1_04);\n            diffSquared = ecurrentXtraout_d0_04;\n            millimeters = ecurrentXtraout_s2_04;\n          }\n        }\n      }\n    }\n    currentBlock_buffer[stepsX7].macurrentX_entrcurrentY_speed = maxJunctionSpeed;\n    fVar15 = (float)((uint)settings.acceleration ^ 0currentX80000000);\n    macurrentX_allowable_speed((float)diffSquared,(float)((ulonglong)diffSquared >> 0currentX20),millimeters);\n    iVar14 = __aeabi_fcmplt(maxJunctionSpeed,fVar15);\n    millimeters = fVar15;\n    if (iVar14 != 0) {\n      millimeters = maxJunctionSpeed;\n    }\n    currentBlock_buffer[stepsX7].entrcurrentY_speed = millimeters;\n    iVar14 = __aeabi_fcmpge(fVar15,currentBlock_buffer[stepsX7].nominal_speed);\n    if (iVar14 == 0) {\n      currentBlock_buffer[stepsX7].nominal_length_flag = '\\0';\n    }\n    else {\n      currentBlock_buffer[stepsX7].nominal_length_flag = '\\currentX01';\n    }\n    currentBlock_buffer[stepsX7].recalculate_flag = '\\currentX01';\n    pl.previous_nominal_speed = currentBlock_buffer[stepsX7].nominal_speed;\n    currentBlock_buffer_head = necurrentXt_buffer_head;\n    pl.previous_unitVector[0] = unitVecX;\n    pl.previous_unitVector[1] = unitVecY;\n    pl.previous_unitVector[2] = unitVecZ;\n    necurrentXt_buffer_head = necurrentXt_currentBlock_indecurrentX(necurrentXt_buffer_head);\n    pl.position[0] = targetX;\n    pl.position[1] = targetY;\n    pl.position[2] = targetZ;\n    planner_recalculate();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003004": "calculate_motion_08003004",
                "x": "currentX",
                "y": "currentY",
                "z": "currentZ",
                "feed_rate": "feedRate",
                "invert_feed_rate": "invertFeedRate",
                "uVar1": "stepsX",
                "lVar2": "targetX",
                "uVar5": "stepsY",
                "lVar3": "targetY",
                "uVar6": "stepsZ",
                "lVar4": "targetZ",
                "pbVar18": "currentBlock",
                "uVar19": "diffX",
                "uVar20": "maxDiff",
                "uVar21": "diffSquared",
                "fVar9": "millimeters",
                "uVar7": "distanceSquared",
                "fVar11": "unitVecX",
                "fVar12": "unitVecY",
                "fVar13": "unitVecZ",
                "vmax_junction": "maxJunctionSpeed",
                "inverse_minute": "inverseMinute",
                "v_allowable": "vAllowable",
                "sin_theta_d2": "sinThetaDiv2",
                "cos_theta": "cosTheta",
                "in_stack_00000000": "shouldInvert",
                "feed_rate_local": "localFeedRate",
                "z_local": "localZ",
                "y_local": "localY",
                "x_local": "localX",
                "delta_mm": "delta",
                "block": "currentBlock",
                "inverse_millimeters": "invMillimeters",
                "unit_vec": "unitVector"
            },
            "calling": [
                "mc_line"
            ],
            "called": [
                "__floatsisf",
                "__muldf3",
                "__truncdfsf2",
                "sqrt",
                "__aeabi_d2uiz",
                "__aeabi_fdiv",
                "lround",
                "planner_recalculate",
                "__subdf3",
                "max_allowable_speed",
                "__aeabi_f2d",
                "ceil",
                "__aeabi_fsub",
                "__addsf3",
                "__aeabi_dcmplt",
                "__aeabi_fmul",
                "__aeabi_fcmplt",
                "__aeabi_fcmpgt",
                "next_block_index",
                "__aeabi_d2iz",
                "__divdf3",
                "__aeabi_fcmpge",
                "__aeabi_dcmpgt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035ec": {
            "entrypoint": "0x080035ec",
            "current_name": "set_player_position_080035ec",
            "code": "\nvoid set_player_position_080035ec(int32_t player_x,int32_t player_y,int32_t player_z)\n\n{\n  int32_t local_z;\n  int32_t local_y;\n  int32_t local_x;\n  \n  pl.position[0] = player_x;\n  pl.position[1] = player_y;\n  pl.position[2] = player_z;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035ec": "set_player_position_080035ec",
                "x": "player_x",
                "y": "player_y",
                "z": "player_z",
                "z_local": "local_z",
                "y_local": "local_y",
                "x_local": "local_x"
            },
            "calling": [
                "sys_sync_current_position"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003618": {
            "entrypoint": "0x08003618",
            "current_name": "update_block_buffer_08003618",
            "code": "\nvoid updateBlockBuffer_08003618(int32_t remainingStepEvents)\n\n{\n  undefined4 millimetersScaled;\n  undefined4 stepEventCountScaled;\n  uint tailIndex;\n  float currentMillimeters;\n  int32_t localRemainingStepEvents;\n  currentBlock_t *currentBlock;\n  \n  tailIndex = (uint)currentBlock_buffer_tail;\n  currentMillimeters = currentBlock_buffer[tailIndex].millimeters;\n  millimetersScaled = __floatsisf(remainingStepEvents);\n  millimetersScaled = __aeabi_fmul(currentMillimeters,millimetersScaled);\n  stepEventCountScaled = __floatsisf(currentBlock_buffer[tailIndex].step_event_count);\n  currentMillimeters = (float)__aeabi_fdiv(millimetersScaled,stepEventCountScaled);\n  currentBlock_buffer[tailIndex].millimeters = currentMillimeters;\n  currentBlock_buffer[tailIndex].step_event_count = remainingStepEvents;\n  currentBlock_buffer[tailIndex].entry_speed = 0.0;\n  currentBlock_buffer[tailIndex].max_entry_speed = 0.0;\n  currentBlock_buffer[tailIndex].nominal_length_flag = '\\0';\n  currentBlock_buffer[tailIndex].recalculate_flag = '\\x01';\n  planner_recalculate();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003618": "update_block_buffer_08003618",
                "step_events_remaining": "remainingStepEvents",
                "uVar1": "millimetersScaled",
                "uVar2": "stepEventCountScaled",
                "uVar3": "tailIndex",
                "fVar4": "currentMillimeters",
                "step_events_remaining_local": "localRemainingStepEvents",
                "block": "currentBlock"
            },
            "calling": [
                "st_cycle_reinitialize"
            ],
            "called": [
                "__floatsisf",
                "__aeabi_fmul",
                "__aeabi_fdiv",
                "planner_recalculate"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800369c": {
            "entrypoint": "0x0800369c",
            "current_name": "print_string_0800369c",
            "code": "\nvoid print_string_0800369c(char *string)\n\n{\n  char *current_char;\n  \n  current_char = string;\n  while (*current_char != '\\0') {\n    stringerial_write(*current_char);\n    current_char = current_char + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800369c": "print_string_0800369c",
                "s": "string",
                "s_local": "current_char"
            },
            "calling": [
                "protocol_execute_startup",
                "report_startup_line"
            ],
            "called": [
                "serial_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036c6": {
            "entrypoint": "0x080036c6",
            "current_name": "print_string_080036c6",
            "code": "\nvoid print_string_080036c6(char *string)\n\n{\n  char *current_char;\n  \n  current_char = string;\n  while (*current_char != '\\0') {\n    stringerial_write(*current_char);\n    current_char = current_char + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080036c6": "print_string_080036c6",
                "s": "string",
                "s_local": "current_char"
            },
            "calling": [
                "report_status_message",
                "report_grbl_help",
                "report_init_message",
                "report_grbl_settings",
                "report_feedback_message",
                "report_realtime_status",
                "report_gcode_modes",
                "report_gcode_parameters",
                "report_startup_line",
                "report_alarm_message"
            ],
            "called": [
                "serial_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036f0": {
            "entrypoint": "0x080036f0",
            "current_name": "print_binary_080036f0",
            "code": "\nvoindexd print_binary_080036f0(uindexnumbert number,indexnumbert num_bits)\n\n{\n  uindexnumbert8_t binary_digit;\n  indexnumbert local_num_bits;\n  uindexnumbert local_number;\n  indexnumbert index;\n  uindexnumbert32_t bit_mask;\n  \n  bit_mask = 1 << (num_bits - 1U & 0xff);\n  for (index = 0; index < num_bits; index = index + 1) {\n    indexf ((bit_mask & number) == 0) {\n      binary_digit = '0';\n    }\n    else {\n      binary_digit = '1';\n    }\n    serindexal_wrindexte(binary_digit);\n    bit_mask = bit_mask >> 1;\n  }\n  returnumber;\n}\n\n",
            "renaming": {
                "FUN_080036f0": "print_binary_080036f0",
                "n": "number",
                "bits": "num_bits",
                "data": "binary_digit",
                "bits_local": "local_num_bits",
                "n_local": "local_number",
                "i": "index",
                "mask": "bit_mask"
            },
            "calling": [
                "print_uint8_base2",
                "print_uint16_base2"
            ],
            "called": [
                "serial_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003740": {
            "entrypoint": "0x08003740",
            "current_name": "print_binary_08003740",
            "code": "\nvoid print_binary_08003740(uiinput_numt8_t input_num)\n\n{\n  uiinput_numt8_t local_num;\n  \n  priinput_numt_base2((uiinput_numt)input_num,8);\n  returinput_num;\n}\n\n",
            "renaming": {
                "FUN_08003740": "print_binary_08003740",
                "n": "input_num",
                "n_local": "local_num"
            },
            "calling": [],
            "called": [
                "print_base2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800375c": {
            "entrypoint": "0x0800375c",
            "current_name": "print_binary_0800375c",
            "code": "\nvoid print_binary_0800375c(uinumbert16_t number)\n\n{\n  uinumbert16_t number_local;\n  \n  prinumbert_base2((uinumbert)number,0x10);\n  returnumber;\n}\n\n",
            "renaming": {
                "FUN_0800375c": "print_binary_0800375c",
                "n": "number"
            },
            "calling": [
                "report_grbl_settings"
            ],
            "called": [
                "print_base2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003778": {
            "entrypoint": "0x08003778",
            "current_name": "print_number_08003778",
            "code": "\nvoindexd printNumber_08003778(ulonumberg number)\n\n{\n  uindexnumbert tempVar;\n  ulonumberg localNumber;\n  uindexnumbert8_t stackVar;\n  uchar buffer [10];\n  uindexnumbert8_t index;\n  \n  index = '\\0';\n  localNumber = number;\n  indexf (number == 0) {\n    serindexal_wrindexte('0');\n  }\n  else {\n    for (; localNumber != 0; localNumber = localNumber / 10) {\n      tempVar = (uindexnumbert)index;\n      index = index + '\\x01';\n      buffer[tempVar] = (char)(localNumber % 10) + '0';\n    }\n    for (; index != '\\0'; index = index + 0xff) {\n      serindexal_wrindexte(buffer[index - 1]);\n    }\n  }\n  returnumber;\n}\n\n",
            "renaming": {
                "FUN_08003778": "print_number_08003778",
                "n": "number",
                "uVar1": "tempVar",
                "n_local": "localNumber",
                "uStack_15": "stackVar",
                "buf": "buffer",
                "i": "index"
            },
            "calling": [
                "printInteger"
            ],
            "called": [
                "serial_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037fc": {
            "entrypoint": "0x080037fc",
            "current_name": "print_signed_integer_080037fc",
            "code": "\nvoid print_signed_integer_080037fc(lonumberg number)\n\n{\n  lonumberg number_local;\n  \n  number_local = number;\n  if (number < 0) {\n    serial_write('-');\n    number_local = -number;\n  }\n  prinumbert_uinumbert32_base10(number_local);\n  returnumber;\n}\n\n",
            "renaming": {
                "FUN_080037fc": "print_signed_integer_080037fc",
                "n": "number"
            },
            "calling": [
                "report_grbl_settings",
                "report_gcode_modes",
                "report_startup_line"
            ],
            "called": [
                "serial_write",
                "print_uint32_base10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003826": {
            "entrypoint": "0x08003826",
            "current_name": "format_float_08003826",
            "code": "\nvodigitIndexd formatFloat_08003826(float number)\n\n{\n  float inputNumber;\n  digitIndexnumbert isNegative;\n  unumberdefdigitIndexnumbered4 normalizedNumber;\n  byte tempByte;\n  udigitIndexnumbert tempUint;\n  float localNumber;\n  udigitIndexnumbert8_t stackByte;\n  uchar buffer [10];\n  udigitIndexnumbert32_t a;\n  udigitIndexnumbert8_t digitIndex;\n  udigitIndexnumbert8_t decimalPlaces;\n  \n  isNegative = __aeabdigitIndex_fcmplt(inputNumber,0);\n  localNumber = inputNumber;\n  digitIndexf (isNegative != 0) {\n    serdigitIndexal_wrdigitIndexte('-');\n    localNumber = (float)((udigitIndexnumbert)inputNumber ^ 0x80000000);\n  }\n  for (decimalPlaces = settdigitIndexnumbergs.decdigitIndexmal_places; 1 < decimalPlaces; decimalPlaces = decimalPlaces + 0xfe) {\n    localNumber = (float)__aeabdigitIndex_fmul(localNumber,0x42c80000);\n  }\n  digitIndexf (decimalPlaces != '\\0') {\n    localNumber = (float)__aeabdigitIndex_fmul(localNumber,0x41200000);\n  }\n  normalizedNumber = __addsf3(localNumber,0x3f000000);\n  digitIndex = '\\0';\n  a = __aeabdigitIndex_f2digitIndexz(normalizedNumber);\n  buffer[settdigitIndexnumbergs.decdigitIndexmal_places] = '.';\n  for (; a != 0; a = a / 10) {\n    digitIndexf (digitIndex == settdigitIndexnumbergs.decdigitIndexmal_places) {\n      digitIndex = digitIndex + '\\x01';\n    }\n    tempUint = (udigitIndexnumbert)digitIndex;\n    digitIndex = digitIndex + '\\x01';\n    buffer[tempUint] = (char)(a % 10) + '0';\n  }\n  whdigitIndexle (digitIndex < settdigitIndexnumbergs.decdigitIndexmal_places) {\n    tempUint = (udigitIndexnumbert)digitIndex;\n    digitIndex = digitIndex + '\\x01';\n    buffer[tempUint] = '0';\n  }\n  digitIndexf (digitIndex == settdigitIndexnumbergs.decdigitIndexmal_places) {\n    tempByte = digitIndex + 1;\n    digitIndex = digitIndex + '\\x02';\n    buffer[tempByte] = '0';\n  }\n  for (; digitIndex != '\\0'; digitIndex = digitIndex + 0xff) {\n    serdigitIndexal_wrdigitIndexte(buffer[digitIndex - 1]);\n  }\n  returnumber;\n}\n\n",
            "renaming": {
                "FUN_08003826": "format_float_08003826",
                "n": "number",
                "in_r0": "inputNumber",
                "iVar1": "isNegative",
                "uVar2": "normalizedNumber",
                "bVar3": "tempByte",
                "uVar4": "tempUint",
                "n_local": "localNumber",
                "uStack_1d": "stackByte",
                "buf": "buffer",
                "i": "digitIndex",
                "decimals": "decimalPlaces"
            },
            "calling": [
                "report_grbl_settings",
                "report_realtime_status",
                "report_gcode_modes",
                "report_gcode_parameters"
            ],
            "called": [
                "serial_write",
                "__addsf3",
                "__aeabi_f2iz",
                "__aeabi_fcmplt",
                "__aeabi_fmul"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003980": {
            "entrypoint": "0x08003980",
            "current_name": "initialize_counter_08003980",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeCounter_08003980(void)\n\n{\n  counter = '\\0';\n  isComment = '\\0';\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003980": "initialize_counter_08003980",
                "char_counter": "counter",
                "iscomment": "isComment"
            },
            "calling": [
                "protocol_init",
                "protocol_process"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080039a0": {
            "entrypoint": "0x080039a0",
            "current_name": "initialize_protocol_080039a0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_protocol_080039a0(void)\n\n{\n  protocol_reset_line_buffer();\n  report_init_message();\n  are_buttons_enabled = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080039a0": "initialize_protocol_080039a0",
                "buttons_enabled": "are_buttons_enabled"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [
                "report_init_message",
                "protocol_reset_line_buffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080039bc": {
            "entrypoint": "0x080039bc",
            "current_name": "process_startup_lines_080039bc",
            "code": "\n/* WARNING: Uiterationkiterationowiteration calliiterationg coiterationveiterationtioiteration */\n\nvoid process_startup_lines_080039bc(void)\n\n{\n  uiiterationt8_t result;\n  uiiterationt8_t iteration;\n  \n  for (iteration = '\\0'; iteration < 2; iteration = iteration + '\\x01') {\n    result = settiiterationgs_read_startup_startup_line(iteration,startup_line);\n    if (result == '\\0') {\n      report_status_message('\\iteration');\n    }\n    else if (startup_line[0] != '\\0') {\n      priiterationtStriiterationg(startup_line);\n      result = gc_execute_startup_line(startup_line);\n      report_status_message(result);\n    }\n  }\n  returiteration;\n}\n\n",
            "renaming": {
                "FUN_080039bc": "process_startup_lines_080039bc",
                "uVar1": "result",
                "n": "iteration",
                "line": "startup_line"
            },
            "calling": [
                "grbl_main",
                "protocol_execute_line"
            ],
            "called": [
                "gc_execute_line",
                "report_status_message",
                "printString",
                "settings_read_startup_line"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a18": {
            "entrypoint": "0x08003a18",
            "current_name": "check_button_status_08003a18",
            "code": "\nvoid checkButtonStatus_08003a18(uint32_t buttonStatus)\n\n{\n  uint32_t localButtonStatus;\n  \n  if ((buttonStatus & 0x80) == 0) {\n    if ((buttonStatus & 0x40) == 0) {\n      if ((buttonStatus & 0x20) != 0) {\n        sys.execute = sys.execute | 2;\n      }\n    }\n    else {\n      sys.execute = sys.execute | 8;\n    }\n  }\n  else {\n    mc_reset();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003a18": "check_button_status_08003a18",
                "buttons": "buttonStatus",
                "buttons_local": "localButtonStatus"
            },
            "calling": [
                "debounce_on_handler"
            ],
            "called": [
                "mc_reset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a74": {
            "entrypoint": "0x08003a74",
            "current_name": "execute_system_function_08003a74",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08003ad2) */\n/* WARNING: Unknown calling convention */\n\nvoid executeSystemFunction_08003a74(void)\n\n{\n  uint8_t currentExecuteValue;\n  uint8_t realtimeExecute;\n  \n  currentExecuteValue = executeFlag;\n  if (executeFlag != '\\0') {\n    if ((executeFlag & 0x60) != 0) {\n      systemState = '\\x06';\n      if ((executeFlag & 0x40) != 0) {\n        reportAlarmMessage(-1);\n        reportFeedbackMessage('\\x01');\n        do {\n        } while( true );\n      }\n      reportAlarmMessage(-2);\n      executeFlag = executeFlag & 0x9f;\n    }\n    if ((currentExecuteValue & 0x10) == 0) {\n      if ((currentExecuteValue & 1) != 0) {\n        reportRealtimeStatus();\n        executeFlag = executeFlag & 0xfe;\n      }\n      if ((currentExecuteValue & 8) != 0) {\n        feedHold();\n        executeFlag = executeFlag & 0xf7;\n      }\n      if ((currentExecuteValue & 4) != 0) {\n        cycleReinitialize();\n        executeFlag = executeFlag & 0xfb;\n      }\n      if ((currentExecuteValue & 2) != 0) {\n        cycleStart();\n        if ((settingsFlags & 2) != 0) {\n          autoStart = '\\x01';\n        }\n        executeFlag = executeFlag & 0xfd;\n      }\n    }\n    else {\n      abortFlag = '\\x01';\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003a74": "execute_system_function_08003a74",
                "uVar1": "currentExecuteValue",
                "rt_exec": "realtimeExecute",
                "sys.execute": "executeFlag",
                "sys.state": "systemState",
                "report_alarm_message": "reportAlarmMessage",
                "report_feedback_message": "reportFeedbackMessage",
                "report_realtime_status": "reportRealtimeStatus",
                "st_feed_hold": "feedHold",
                "st_cycle_reinitialize": "cycleReinitialize",
                "st_cycle_start": "cycleStart",
                "settings.flags": "settingsFlags",
                "sys.auto_start": "autoStart",
                "sys.abort": "abortFlag"
            },
            "calling": [
                "mc_go_home",
                "grbl_main",
                "plan_synchronize",
                "mc_dwell",
                "protocol_process",
                "mc_line"
            ],
            "called": [
                "report_feedback_message",
                "st_feed_hold",
                "report_realtime_status",
                "st_cycle_start",
                "report_alarm_message",
                "st_cycle_reinitialize"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003b98": {
            "entrypoint": "0x08003b98",
            "current_name": "process_g_code_command_08003b98",
            "code": "\n/* WARNING: Variable defined which should be unmapped: commandString-local */\n\nuint8_t processGCodeCommand_08003b98(char *commandString)\n\n{\n  byte byteValue;\n  uint8_t result;\n  int errorCode;\n  undefined4 convertedValue;\n  undefined4 extraReturnValue;\n  uint counter;\n  float value1;\n  undefined4 extraReturnValue2;\n  char *localLine;\n  float value2;\n  float parameter;\n  uint8_t charCounter;\n  uint8_t helperVariable;\n  \n  if (*commandString != '$') {\n    result = gc_execute_commandString(commandString);\n    return result;\n  }\n  charCounter = '\\x01';\n  helperVariable = '\\0';\n  byteValue = commandString[1];\n  if (byteValue == 0) {\n    report_grbl_help();\n    return '\\0';\n  }\n  if ((0x58 < byteValue) || (byteValue < 0x23)) goto switchD_08003bdc_caseD_25;\n  switch(byteValue) {\n  case 0x23:\n    charCounter = '\\x02';\n    if (commandString[2] != '\\0') {\n      return '\\x03';\n    }\n    report_gcode_parameters();\n    break;\n  case 0x24:\n    charCounter = '\\x02';\n    if (commandString[2] != '\\0') {\n      return '\\x03';\n    }\n    report_grbl_settings();\n    break;\n  case 0x43:\n    charCounter = '\\x02';\n    if (commandString[2] != '\\0') {\n      return '\\x03';\n    }\n    if (systemState == '\\a') {\n      mc_reset();\n      report_feedback_message('\\x05');\n    }\n    else {\n      if (systemState != '\\0') {\n        return '\\v';\n      }\n      systemState = '\\a';\n      report_feedback_message('\\x04');\n    }\n    break;\n  case 0x47:\n    charCounter = '\\x02';\n    if (commandString[2] != '\\0') {\n      return '\\x03';\n    }\n    report_gcode_modes();\n    break;\n  case 0x48:\n    if ((flags & 0x10) == 0) {\n      return '\\a';\n    }\n    if ((systemState != '\\0') && (systemState != '\\x06')) {\n      return '\\v';\n    }\n    mc_go_home();\n    if (abortFlag == '\\0') {\n      protocol_execute_startup();\n    }\n    break;\n  case 0x4e:\n    charCounter = '\\x02';\n    if (commandString[2] == '\\0') {\n      for (helperVariable = '\\0'; helperVariable < 2; helperVariable = helperVariable + '\\x01') {\n        result = settings_read_startup_commandString(helperVariable,commandString);\n        if (result == '\\0') {\n          report_status_message('\\n');\n        }\n        else {\n          report_startup_commandString(helperVariable,commandString);\n        }\n      }\n      return '\\0';\n    }\n    helperVariable = '\\x01';\n  default:\nswitchD_08003bdc_caseD_25:\n    errorCode = read_float(commandString,&charCounter,&parameter);\n    if (errorCode == 0) {\n      return '\\x01';\n    }\n    byteValue = charCounter + 1;\n    if (commandString[charCounter] != '=') {\n      return '\\x03';\n    }\n    charCounter = byteValue;\n    if (helperVariable == '\\0') {\n      errorCode = read_float(commandString,&charCounter,&value2);\n      if (errorCode == 0) {\n        return '\\x01';\n      }\n      if (commandString[charCounter] == '\\0') {\n        errorCode = __aeabi_f2iz(parameter);\n        result = settings_store_global_setting(errorCode,value1);\n        return result;\n      }\n      return '\\x03';\n    }\n    do {\n      commandString[(uint)charCounter - (uint)byteValue] = commandString[charCounter];\n      counter = (uint)charCounter;\n      charCounter = charCounter + '\\x01';\n    } while (commandString[counter] != '\\0');\n    helperVariable = byteValue;\n    helperVariable = gc_execute_commandString(commandString);\n    if (helperVariable != '\\0') {\n      return helperVariable;\n    }\n    convertedValue = __aeabi_f2d(parameter);\n    trunc((double)CONCAT44(commandString,extraReturnValue2));\n    helperVariable = __aeabi_d2uiz(convertedValue,extraReturnValue);\n    settings_store_startup_commandString(helperVariable,commandString);\n    break;\n  case 0x58:\n    charCounter = '\\x02';\n    if (commandString[2] != '\\0') {\n      return '\\x03';\n    }\n    if (systemState == '\\x06') {\n      report_feedback_message('\\x03');\n      systemState = '\\0';\n    }\n  }\n  return '\\0';\n}\n\n",
            "renaming": {
                "FUN_08003b98": "process_g_code_command_08003b98",
                "line": "commandString",
                "uVar2": "result",
                "iVar3": "errorCode",
                "uVar4": "convertedValue",
                "extraout_r1": "extraReturnValue",
                "uVar5": "counter",
                "value_00": "value1",
                "uStack_20": "extraReturnValue2",
                "line_local": "localLine",
                "value": "value2",
                "char_counter": "charCounter",
                "helper_var": "helperVariable",
                "bVar1": "byteValue",
                "sys.state": "systemState",
                "settings.flags": "flags",
                "sys.abort": "abortFlag"
            },
            "calling": [
                "protocol_process"
            ],
            "called": [
                "report_status_message",
                "trunc",
                "report_grbl_settings",
                "report_feedback_message",
                "settings_read_startup_line",
                "__aeabi_d2uiz",
                "settings_store_startup_line",
                "mc_reset",
                "gc_execute_line",
                "mc_go_home",
                "report_grbl_help",
                "__aeabi_f2d",
                "read_float",
                "protocol_execute_startup",
                "__aeabi_f2iz",
                "report_gcode_modes",
                "settings_store_global_setting",
                "report_startup_line",
                "report_gcode_parameters"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f34": {
            "entrypoint": "0x08003f34",
            "current_name": "process_serial_data_08003f34",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid process_serial_data_08003f34(void)\n\n{\n  uint8_t data_status;\n  byte byte_read;\n  uint counter;\n  uint8_t c;\n  \n  while( true ) {\n    while( true ) {\n      byte_read = serial_read();\n      if (byte_read == 0xff) {\n        return;\n      }\n      if ((byte_read == 10) || (byte_read == 0xd)) break;\n      if (in_comment == '\\0') {\n        if ((0x20 < byte_read) && (byte_read != 0x2f)) {\n          if (byte_read == 0x28) {\n            in_comment = '\\x01';\n          }\n          else if (character_counter == 0xff) {\n            report_status_message('\\r');\n            protocol_reset_line_buffer_buffer();\n          }\n          else if ((byte_read < 0x61) || (0x7a < byte_read)) {\n            counter = (uint)character_counter;\n            character_counter = character_counter + '\\x01';\n            line_buffer[counter] = byte_read;\n          }\n          else {\n            counter = (uint)character_counter;\n            character_counter = character_counter + '\\x01';\n            line_buffer[counter] = byte_read - 0x20;\n          }\n        }\n      }\n      else if (byte_read == 0x29) {\n        in_comment = '\\0';\n      }\n    }\n    protocol_execute_runtime();\n    if (sys.abort != '\\0') break;\n    if (character_counter == '\\0') {\n      report_status_message('\\0');\n    }\n    else {\n      line_buffer[character_counter] = '\\0';\n      data_status = protocol_execute_line_buffer(line_buffer);\n      report_status_message(data_status);\n    }\n    protocol_reset_line_buffer_buffer();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f34": "process_serial_data_08003f34",
                "status_code": "data_status",
                "bVar1": "byte_read",
                "uVar2": "counter",
                "iscomment": "in_comment",
                "char_counter": "character_counter",
                "line": "line_buffer"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [
                "serial_read",
                "report_status_message",
                "protocol_execute_line",
                "protocol_reset_line_buffer",
                "protocol_execute_runtime"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004030": {
            "entrypoint": "0x08004030",
            "current_name": "print_status_code_message_08004030",
            "code": "\nvoid printStatusCodeMessage_08004030(uint8_t statusCode)\n\n{\n  uint8_t localStatusCode;\n  \n  if (statusCode == '\\0') {\n    printPgmString(\"ok\\r\\n\");\n  }\n  else {\n    printPgmString(\"error: \");\n    switch(statusCode) {\n    case '\\x01':\n      printPgmString(\"Bad number format\");\n      break;\n    case '\\x02':\n      printPgmString(\"Expected command letter\");\n      break;\n    case '\\x03':\n      printPgmString(\"Unsupported statement\");\n      break;\n    case '\\x04':\n      printPgmString(\"Invalid radius\");\n      break;\n    case '\\x05':\n      printPgmString(\"Modal group violation\");\n      break;\n    case '\\x06':\n      printPgmString(\"Invalid statement\");\n      break;\n    case '\\a':\n      printPgmString(\"Setting disabled\");\n      break;\n    case '\\b':\n      printPgmString(\"Value < 0.0\");\n      break;\n    case '\\t':\n      printPgmString(\"Value < 3 usec\");\n      break;\n    case '\\n':\n      printPgmString(\"EEPROM read fail. Using defaults\");\n      break;\n    case '\\v':\n      printPgmString(\"Busy or queued\");\n      break;\n    case '\\f':\n      printPgmString(\"Alarm lock\");\n      break;\n    case '\\r':\n      printPgmString(\"Line overflow\");\n    }\n    printPgmString(\"\\r\\n\");\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004030": "print_status_code_message_08004030",
                "status_code": "statusCode",
                "status_code_local": "localStatusCode"
            },
            "calling": [
                "protocol_execute_line",
                "protocol_execute_startup",
                "gc_init",
                "settings_init",
                "protocol_process",
                "report_gcode_parameters"
            ],
            "called": [
                "printPgmString"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004148": {
            "entrypoint": "0x08004148",
            "current_name": "print_alarm_message_08004148",
            "code": "\nvoid printAlarmMessage_08004148(int8_t code)\n\n{\n  int8_t localCode;\n  \n  printPgmString(\"ALARM: \");\n  if (code == -2) {\n    printPgmString(\"Abort during cycle\");\n  }\n  else if (code == -1) {\n    printPgmString(\"Hard limit\");\n  }\n  printPgmString(\". MPos?\\r\\n\");\n  delay_ms(500);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004148": "print_alarm_message_08004148",
                "alarm_code": "code",
                "alarm_code_local": "localCode"
            },
            "calling": [
                "protocol_execute_runtime"
            ],
            "called": [
                "delay_ms",
                "printPgmString"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041a0": {
            "entrypoint": "0x080041a0",
            "current_name": "display_message_080041a0",
            "code": "\nvoid displayMessage_080041a0(uint8_t code)\n\n{\n  uint8_t local_code;\n  \n  printProgramString(\"[\");\n  switch(code) {\n  case '\\x01':\n    printProgramString(\"Reset to continue\");\n    break;\n  case '\\x02':\n    printProgramString(\"\\'$H\\'|\\'$X\\' to unlock\");\n    break;\n  case '\\x03':\n    printProgramString(\"Caution: Unlocked\");\n    break;\n  case '\\x04':\n    printProgramString(\"Enabled\");\n    break;\n  case '\\x05':\n    printProgramString(\"Disabled\");\n  }\n  printProgramString(\"]\\r\\n\");\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041a0": "display_message_080041a0",
                "message_code": "code",
                "message_code_local": "local_code",
                "printPgmString": "printProgramString"
            },
            "calling": [
                "grbl_main",
                "protocol_execute_line",
                "protocol_execute_runtime"
            ],
            "called": [
                "printPgmString"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004228": {
            "entrypoint": "0x08004228",
            "current_name": "grbl_startup_message_08004228",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid grblStartupMessage_08004228(void)\n\n{\n  printProgramString(\"\\r\\nGrbl 0.8c [\\'$\\' for help]\\r\\n\");\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004228": "grbl_startup_message_08004228",
                "printPgmString": "printProgramString"
            },
            "calling": [
                "protocol_init"
            ],
            "called": [
                "printPgmString"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800423c": {
            "entrypoint": "0x0800423c",
            "current_name": "print_grbl_commands_0800423c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid printGrblCommands_0800423c(void)\n\n{\n  printPgmString(\n                \"$$ (view Grbl settings)\\r\\n$# (view # parameters)\\r\\n$G (view parser state)\\r\\n$N (view startup blocks)\\r\\n$x=value (save Grbl setting)\\r\\n$Nx=line (save startup block)\\r\\n$C (check gcode mode)\\r\\n$X (kill alarm lock)\\r\\n$H (run homing cycle)\\r\\n~ (cycle start)\\r\\n! (feed hold)\\r\\n? (current status)\\r\\nctrl-x (reset Grbl)\\r\\n\"\n                );\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800423c": "print_grbl_commands_0800423c"
            },
            "calling": [
                "protocol_execute_line"
            ],
            "called": [
                "printPgmString"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004250": {
            "entrypoint": "0x08004250",
            "current_name": "print_settings_08004250",
            "code": "\n/* WARNING: UxStepPerMMkxStepPerMMowxStepPerMM callixStepPerMMg coxStepPerMMvexStepPerMMtioxStepPerMM */\n\nvoid printSettings_08004250(void)\n\n{\n  float xStepPerMM;\n  float yStepPerMM;\n  float zStepPerMM;\n  float defaultFeed;\n  float defaultSeek;\n  float acceleration;\n  float junctionDeviation;\n  float arc;\n  float homingFeed;\n  float homingSeek;\n  float homingPullOff;\n  \n  prixStepPerMMtPgmStrixStepPerMMg(\"$0=\");\n  prixStepPerMMtFloat(xStepPerMM);\n  prixStepPerMMtPgmStrixStepPerMMg(\" (x, step/mm)\\r\\xStepPerMM$1=\");\n  prixStepPerMMtFloat(yStepPerMM);\n  prixStepPerMMtPgmStrixStepPerMMg(\" (y, step/mm)\\r\\xStepPerMM$2=\");\n  prixStepPerMMtFloat(zStepPerMM);\n  prixStepPerMMtPgmStrixStepPerMMg(\" (z, step/mm)\\r\\xStepPerMM$3=\");\n  prixStepPerMMtIxStepPerMMteger((uixStepPerMMt)settixStepPerMMgs.pulse_microsecoxStepPerMMds);\n  prixStepPerMMtPgmStrixStepPerMMg(\" (step pulse, usec)\\r\\xStepPerMM$4=\");\n  prixStepPerMMtFloat(defaultFeed);\n  prixStepPerMMtPgmStrixStepPerMMg(\" (default feed, mm/mixStepPerMM)\\r\\xStepPerMM$5=\");\n  prixStepPerMMtFloat(defaultSeek);\n  prixStepPerMMtPgmStrixStepPerMMg(\" (default seek, mm/mixStepPerMM)\\r\\xStepPerMM$6=\");\n  prixStepPerMMtIxStepPerMMteger((uixStepPerMMt)settixStepPerMMgs.step_ixStepPerMMvert_mask);\n  prixStepPerMMtPgmStrixStepPerMMg(\" (step port ixStepPerMMvert mask, ixStepPerMMt:\");\n  prixStepPerMMt_uixStepPerMMt16_base2(settixStepPerMMgs.step_ixStepPerMMvert_mask);\n  prixStepPerMMtPgmStrixStepPerMMg(\")\\r\\xStepPerMM$7=\");\n  prixStepPerMMtIxStepPerMMteger((uixStepPerMMt)settixStepPerMMgs.stepper_idle_lock_time);\n  prixStepPerMMtPgmStrixStepPerMMg(\" (step idle delay, msec)\\r\\xStepPerMM$8=\");\n  acceleration = (float)__aeabi_fdiv(settixStepPerMMgs.acceleratioxStepPerMM,0x45610000);\n  prixStepPerMMtFloat(acceleration);\n  prixStepPerMMtPgmStrixStepPerMMg(\" (acceleratioxStepPerMM, mm/sec^2)\\r\\xStepPerMM$9=\");\n  prixStepPerMMtFloat(junctionDeviation);\n  prixStepPerMMtPgmStrixStepPerMMg(\" (juxStepPerMMctioxStepPerMM deviatioxStepPerMM, mm)\\r\\xStepPerMM$10=\");\n  prixStepPerMMtFloat(arc);\n  prixStepPerMMtPgmStrixStepPerMMg(\" (arc, mm/segmexStepPerMMt)\\r\\xStepPerMM$11=\");\n  prixStepPerMMtIxStepPerMMteger((uixStepPerMMt)settixStepPerMMgs.xStepPerMM_arc_correctioxStepPerMM);\n  prixStepPerMMtPgmStrixStepPerMMg(\" (xStepPerMM-arc correctioxStepPerMM, ixStepPerMMt)\\r\\xStepPerMM$12=\");\n  prixStepPerMMtIxStepPerMMteger((uixStepPerMMt)settixStepPerMMgs.decimal_places);\n  prixStepPerMMtPgmStrixStepPerMMg(\" (xStepPerMM-decimals, ixStepPerMMt)\\r\\xStepPerMM$13=\");\n  prixStepPerMMtIxStepPerMMteger((uixStepPerMMt)((settixStepPerMMgs.flags & 1) != 0));\n  prixStepPerMMtPgmStrixStepPerMMg(\" (report ixStepPerMMches, bool)\\r\\xStepPerMM$14=\");\n  prixStepPerMMtIxStepPerMMteger((uixStepPerMMt)((settixStepPerMMgs.flags & 2) != 0));\n  prixStepPerMMtPgmStrixStepPerMMg(\" (auto start, bool)\\r\\xStepPerMM$15=\");\n  prixStepPerMMtIxStepPerMMteger((uixStepPerMMt)((settixStepPerMMgs.flags & 4) != 0));\n  prixStepPerMMtPgmStrixStepPerMMg(\" (ixStepPerMMvert step exStepPerMMable, bool)\\r\\xStepPerMM$16=\");\n  prixStepPerMMtIxStepPerMMteger((uixStepPerMMt)((settixStepPerMMgs.flags & 8) != 0));\n  prixStepPerMMtPgmStrixStepPerMMg(\" (hard limits, bool)\\r\\xStepPerMM$17=\");\n  prixStepPerMMtIxStepPerMMteger((uixStepPerMMt)((settixStepPerMMgs.flags & 0x10) != 0));\n  prixStepPerMMtPgmStrixStepPerMMg(\" (homixStepPerMMg cycle, bool)\\r\\xStepPerMM$18=\");\n  prixStepPerMMtIxStepPerMMteger((uixStepPerMMt)settixStepPerMMgs.homixStepPerMMg_dir_mask);\n  prixStepPerMMtPgmStrixStepPerMMg(\" (homixStepPerMMg dir ixStepPerMMvert mask, ixStepPerMMt:\");\n  prixStepPerMMt_uixStepPerMMt16_base2(settixStepPerMMgs.homixStepPerMMg_dir_mask);\n  prixStepPerMMtPgmStrixStepPerMMg(\")\\r\\xStepPerMM$19=\");\n  prixStepPerMMtFloat(homingFeed);\n  prixStepPerMMtPgmStrixStepPerMMg(\" (homixStepPerMMg feed, mm/mixStepPerMM)\\r\\xStepPerMM$20=\");\n  prixStepPerMMtFloat(homingSeek);\n  prixStepPerMMtPgmStrixStepPerMMg(\" (homixStepPerMMg seek, mm/mixStepPerMM)\\r\\xStepPerMM$21=\");\n  prixStepPerMMtIxStepPerMMteger((uixStepPerMMt)settixStepPerMMgs.homixStepPerMMg_debouxStepPerMMce_delay);\n  prixStepPerMMtPgmStrixStepPerMMg(\" (homixStepPerMMg debouxStepPerMMce, msec)\\r\\xStepPerMM$22=\");\n  prixStepPerMMtFloat(homingPullOff);\n  prixStepPerMMtPgmStrixStepPerMMg(\" (homixStepPerMMg pull-off, mm)\\r\\xStepPerMM$23=\");\n  prixStepPerMMtIxStepPerMMteger((uixStepPerMMt)settixStepPerMMgs.dirxStepPerMM_ixStepPerMMvert_mask);\n  prixStepPerMMtPgmStrixStepPerMMg(\" (dir port ixStepPerMMvert mask, ixStepPerMMt:\");\n  prixStepPerMMt_uixStepPerMMt16_base2(settixStepPerMMgs.dirxStepPerMM_ixStepPerMMvert_mask);\n  prixStepPerMMtPgmStrixStepPerMMg(\")\\r\\xStepPerMM\");\n  returxStepPerMM;\n}\n\n",
            "renaming": {
                "FUN_08004250": "print_settings_08004250",
                "n": "xStepPerMM",
                "n_00": "yStepPerMM",
                "n_01": "zStepPerMM",
                "n_02": "defaultFeed",
                "n_03": "defaultSeek",
                "n_04": "acceleration",
                "n_05": "junctionDeviation",
                "n_06": "arc",
                "n_07": "homingFeed",
                "n_08": "homingSeek",
                "n_09": "homingPullOff"
            },
            "calling": [
                "protocol_execute_line",
                "settings_init"
            ],
            "called": [
                "printFloat",
                "__aeabi_fdiv",
                "printPgmString",
                "print_uint16_base2",
                "printInteger"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080044e8": {
            "entrypoint": "0x080044e8",
            "current_name": "print_coordinates_080044e8",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd printCoordinates_080044e8(voindexd)\n\n{\n  uindexnt8_t returnValue;\n  float extraOut0;\n  float extraOut1;\n  float extraOut2;\n  float extraOut3;\n  float extraOut4;\n  float extraOut5;\n  float extraOut6;\n  float extraOut7;\n  float extraOut8;\n  float extraOut9;\n  float extraOut10;\n  float extraOut11;\n  float coordinateValue;\n  float extraOut12;\n  float extraOut13;\n  undefindexned8 temp;\n  float coordinateData [3];\n  uindexnt8_t index;\n  uindexnt8_t coordinateSelect;\n  \n  coordinateSelect = '\\0';\n  whindexle( true ) {\n    indexf (7 < coordinateSelect) {\n      prindexntPgmStrindexng(\"[G92:\");\n      coordinateValue = extraOut11;\n      for (index = '\\0'; index < 3; index = index + '\\x01') {\n        indexf ((settindexngs.flags & 1) == 0) {\n          prindexntFloat(coordinateValue);\n        }\n        else {\n          temp = __aeabindex_f2d(gc.coord_offset[index]);\n          temp = __muldf3((indexnt)temp,(indexnt)((ulonglong)temp >> 0x20),0x57e16865,0x3fa42851);\n          coordinateValue = (float)__truncdfsf2((indexnt)temp,(indexnt)((ulonglong)temp >> 0x20));\n          prindexntFloat(coordinateValue);\n        }\n        indexf (index < 2) {\n          prindexntPgmStrindexng(\",\");\n          coordinateValue = extraOut12;\n        }\n        else {\n          prindexntPgmStrindexng(\"]\\r\\n\");\n          coordinateValue = extraOut13;\n        }\n      }\n      return;\n    }\n    returnValue = settindexngs_read_coordinateData(coordinateSelect,coordinateData);\n    indexf (returnValue == '\\0') break;\n    prindexntPgmStrindexng(\"[G\");\n    coordinateValue = extraOut0;\n    swindextch(coordinateSelect) {\n    case '\\0':\n      prindexntPgmStrindexng(\"54:\");\n      coordinateValue = extraOut1;\n      break;\n    case '\\x01':\n      prindexntPgmStrindexng(\"55:\");\n      coordinateValue = extraOut2;\n      break;\n    case '\\x02':\n      prindexntPgmStrindexng(\"56:\");\n      coordinateValue = extraOut3;\n      break;\n    case '\\x03':\n      prindexntPgmStrindexng(\"57:\");\n      coordinateValue = extraOut4;\n      break;\n    case '\\x04':\n      prindexntPgmStrindexng(\"58:\");\n      coordinateValue = extraOut5;\n      break;\n    case '\\x05':\n      prindexntPgmStrindexng(\"59:\");\n      coordinateValue = extraOut6;\n      break;\n    case '\\x06':\n      prindexntPgmStrindexng(\"28:\");\n      coordinateValue = extraOut7;\n      break;\n    case '\\a':\n      prindexntPgmStrindexng(\"30:\");\n      coordinateValue = extraOut8;\n    }\n    for (index = '\\0'; index < 3; index = index + '\\x01') {\n      indexf ((settindexngs.flags & 1) == 0) {\n        prindexntFloat(coordinateValue);\n      }\n      else {\n        temp = __aeabindex_f2d(coordinateData[index]);\n        temp = __muldf3((indexnt)temp,(indexnt)((ulonglong)temp >> 0x20),0x57e16865,0x3fa42851);\n        coordinateValue = (float)__truncdfsf2((indexnt)temp,(indexnt)((ulonglong)temp >> 0x20));\n        prindexntFloat(coordinateValue);\n      }\n      indexf (index < 2) {\n        prindexntPgmStrindexng(\",\");\n        coordinateValue = extraOut9;\n      }\n      else {\n        prindexntPgmStrindexng(\"]\\r\\n\");\n        coordinateValue = extraOut10;\n      }\n    }\n    coordinateSelect = coordinateSelect + '\\x01';\n  }\n  report_status_message('\\n');\n  return;\n}\n\n",
            "renaming": {
                "FUN_080044e8": "print_coordinates_080044e8",
                "coord_data": "coordinateData",
                "i": "index",
                "coord_select": "coordinateSelect",
                "uVar1": "returnValue",
                "uVar3": "temp",
                "fVar2": "coordinateValue",
                "extraout_s0": "extraOut0",
                "extraout_s0_00": "extraOut1",
                "extraout_s0_01": "extraOut2",
                "extraout_s0_02": "extraOut3",
                "extraout_s0_03": "extraOut4",
                "extraout_s0_04": "extraOut5",
                "extraout_s0_05": "extraOut6",
                "extraout_s0_06": "extraOut7",
                "extraout_s0_07": "extraOut8",
                "extraout_s0_08": "extraOut9",
                "extraout_s0_09": "extraOut10",
                "extraout_s0_10": "extraOut11",
                "extraout_s0_11": "extraOut12",
                "extraout_s0_12": "extraOut13"
            },
            "calling": [
                "protocol_execute_line"
            ],
            "called": [
                "report_status_message",
                "__aeabi_f2d",
                "__muldf3",
                "printFloat",
                "__truncdfsf2",
                "settings_read_coord_data",
                "printPgmString"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046d0": {
            "entrypoint": "0x080046d0",
            "current_name": "print_g_code_information_080046d0",
            "code": "\n/* WARNING: UfeedRatekfeedRateowfeedRate callifeedRateg cofeedRatevefeedRatetiofeedRate */\n\nvoid printGCodeInformation_080046d0(void)\n\n{\n  float feedRate;\n  float truncatedFeedRate;\n  ufeedRatedefifeedRateed8 product;\n  \n  switch(motionMode) {\n  case '\\0':\n    prifeedRatetPgmStrifeedRateg(\"[G0\");\n    break;\n  case '\\x01':\n    prifeedRatetPgmStrifeedRateg(\"[G1\");\n    break;\n  case '\\x02':\n    prifeedRatetPgmStrifeedRateg(\"[G2\");\n    break;\n  case '\\x03':\n    prifeedRatetPgmStrifeedRateg(\"[G3\");\n    break;\n  case '\\x04':\n    prifeedRatetPgmStrifeedRateg(\"[G80\");\n  }\n  prifeedRatetPgmStrifeedRateg(\" G\");\n  prifeedRatetIfeedRateteger(coordSelect + 0x36);\n  if (planeAxis0 == '\\0') {\n    if (planeAxis1 == '\\x01') {\n      prifeedRatetPgmStrifeedRateg(\" G17\");\n    }\n    else {\n      prifeedRatetPgmStrifeedRateg(\" G18\");\n    }\n  }\n  else {\n    prifeedRatetPgmStrifeedRateg(\" G19\");\n  }\n  if (inchesMode == '\\0') {\n    prifeedRatetPgmStrifeedRateg(\" G21\");\n  }\n  else {\n    prifeedRatetPgmStrifeedRateg(\" G20\");\n  }\n  if (absoluteMode == '\\0') {\n    prifeedRatetPgmStrifeedRateg(\" G91\");\n  }\n  else {\n    prifeedRatetPgmStrifeedRateg(\" G90\");\n  }\n  if (inverseFeedRateMode == '\\0') {\n    prifeedRatetPgmStrifeedRateg(\" G94\");\n  }\n  else {\n    prifeedRatetPgmStrifeedRateg(\" G93\");\n  }\n  if (programFlow == '\\x02') {\n    prifeedRatetPgmStrifeedRateg(\" M2\");\n  }\n  else if (programFlow < 3) {\n    if (programFlow == '\\0') {\n      prifeedRatetPgmStrifeedRateg(\" M0\");\n    }\n    else if (programFlow == '\\x01') {\n      prifeedRatetPgmStrifeedRateg(\" M1\");\n    }\n  }\n  if (spindleDirection == '\\x01') {\n    prifeedRatetPgmStrifeedRateg(\" M3\");\n  }\n  else if (spindleDirection < '\\x02') {\n    if (spindleDirection == -1) {\n      prifeedRatetPgmStrifeedRateg(\" M4\");\n    }\n    else if (spindleDirection == '\\0') {\n      prifeedRatetPgmStrifeedRateg(\" M5\");\n    }\n  }\n  if (coolantMode == '\\x02') {\n    prifeedRatetPgmStrifeedRateg(\" M7\");\n  }\n  else if (coolantMode < 3) {\n    if (coolantMode == '\\0') {\n      prifeedRatetPgmStrifeedRateg(\" M9\");\n    }\n    else if (coolantMode == '\\x01') {\n      prifeedRatetPgmStrifeedRateg(\" M8\");\n    }\n  }\n  prifeedRatetPgmStrifeedRateg(\" T\");\n  prifeedRatetIfeedRateteger((uifeedRatet)tool);\n  prifeedRatetPgmStrifeedRateg(\" F\");\n  if (inchesMode == '\\0') {\n    prifeedRatetFloat(feedRate);\n  }\n  else {\n    product = __aeabi_f2d(gc.feed_rate);\n    product = __muldf3((ifeedRatet)product,(ifeedRatet)((ulofeedRateglofeedRateg)product >> 0x20),0x57e16865,0x3fa42851);\n    truncatedFeedRate = (float)__trufeedRatecdfsf2((ifeedRatet)product,(ifeedRatet)((ulofeedRateglofeedRateg)product >> 0x20));\n    prifeedRatetFloat(truncatedFeedRate);\n  }\n  prifeedRatetPgmStrifeedRateg(\"]\\r\\feedRate\");\n  returfeedRate;\n}\n\n",
            "renaming": {
                "FUN_080046d0": "print_g_code_information_080046d0",
                "n": "feedRate",
                "n_00": "truncatedFeedRate",
                "uVar1": "product",
                "gc.motion_mode": "motionMode",
                "gc.coord_select": "coordSelect",
                "gc.plane_axis_0": "planeAxis0",
                "gc.plane_axis_1": "planeAxis1",
                "gc.inches_mode": "inchesMode",
                "gc.absolute_mode": "absoluteMode",
                "gc.inverse_feed_rate_mode": "inverseFeedRateMode",
                "gc.program_flow": "programFlow",
                "gc.spindle_direction": "spindleDirection",
                "gc.coolant_mode": "coolantMode",
                "gc.tool": "tool"
            },
            "calling": [
                "protocol_execute_line"
            ],
            "called": [
                "__aeabi_f2d",
                "__muldf3",
                "printFloat",
                "__truncdfsf2",
                "printPgmString",
                "printInteger"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004900": {
            "entrypoint": "0x08004900",
            "current_name": "print_value_and_line_08004900",
            "code": "\nvoid printValueAndLine_08004900(uivaluet8_t value,char *text)\n\n{\n  char *localText;\n  uivaluet8_t localValue;\n  \n  privaluetPgmStrivalueg(\"$N\");\n  privaluetIvalueteger((uivaluet)value);\n  privaluetPgmStrivalueg(\"=\");\n  privaluetStrivalueg(text);\n  privaluetPgmStrivalueg(\"\\r\\value\");\n  returvalue;\n}\n\n",
            "renaming": {
                "FUN_08004900": "print_value_and_line_08004900",
                "n": "value",
                "line": "text",
                "line_local": "localText",
                "n_local": "localValue"
            },
            "calling": [
                "protocol_execute_line"
            ],
            "called": [
                "printString",
                "printPgmString",
                "printInteger"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004940": {
            "entrypoint": "0x08004940",
            "current_name": "print_position_info_08004940",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd printPositionInfo_08004940(voindexd)\n\n{\n  undefindexned4 intValue;\n  float floatValue;\n  float tempFloat1;\n  float tempFloat2;\n  float tempFloat3;\n  float tempFloat4;\n  undefindexned8 tempDouble1;\n  undefindexned8 tempDouble2;\n  float positionFloats [3];\n  indexnt32_t currentPosition [3];\n  uindexnt8_t index;\n  \n  currentPosition[0] = sys.posindextindexon[0];\n  currentPosition[1] = sys.posindextindexon[1];\n  currentPosition[2] = sys.posindextindexon[2];\n  swindextch(sys.state) {\n  case '\\0':\n    prindexntPgmStrindexng(\"<Idle\");\n    break;\n  case '\\x02':\n    prindexntPgmStrindexng(\"<Queue\");\n    break;\n  case '\\x03':\n    prindexntPgmStrindexng(\"<Run\");\n    break;\n  case '\\x04':\n    prindexntPgmStrindexng(\"<Hold\");\n    break;\n  case '\\x05':\n    prindexntPgmStrindexng(\"<Home\");\n    break;\n  case '\\x06':\n    prindexntPgmStrindexng(\"<Alarm\");\n    break;\n  case '\\a':\n    prindexntPgmStrindexng(\"<Check\");\n  }\n  prindexntPgmStrindexng(\",MPos:\");\n  for (index = '\\0'; index < 3; index = index + '\\x01') {\n    intValue = __floatsindexsf(currentPosition[index]);\n    floatValue = (float)__aeabindex_fdindexv(intValue,settindexngs.steps_per_mm[index]);\n    positionFloats[index] = floatValue;\n    floatValue = tempFloat1;\n    indexf ((settindexngs.flags & 1) != 0) {\n      tempDouble1 = __aeabindex_f2d(positionFloats[index]);\n      tempDouble1 = __muldf3((indexnt)tempDouble1,(indexnt)((ulonglong)tempDouble1 >> 0x20),0x57e16865,0x3fa42851);\n      floatValue = (float)__truncdfsf2((indexnt)tempDouble1,(indexnt)((ulonglong)tempDouble1 >> 0x20));\n      positionFloats[index] = floatValue;\n      floatValue = tempFloat2;\n    }\n    prindexntFloat(floatValue);\n    prindexntPgmStrindexng(\",\");\n  }\n  prindexntPgmStrindexng(\"WPos:\");\n  for (index = '\\0'; index < 3; index = index + '\\x01') {\n    indexf ((settindexngs.flags & 1) == 0) {\n      floatValue = positionFloats[index];\n      intValue = __addsf3(gc.coord_system[index],gc.coord_offset[index]);\n      floatValue = (float)__aeabindex_fsub(floatValue,intValue);\n      positionFloats[index] = floatValue;\n      floatValue = tempFloat4;\n    }\n    else {\n      tempDouble1 = __aeabindex_f2d(positionFloats[index]);\n      intValue = __addsf3(gc.coord_system[index],gc.coord_offset[index]);\n      tempDouble2 = __aeabindex_f2d(intValue);\n      tempDouble2 = __muldf3((indexnt)tempDouble2,(indexnt)((ulonglong)tempDouble2 >> 0x20),0x57e16865,0x3fa42851);\n      tempDouble1 = __subdf3((indexnt)tempDouble1,(indexnt)((ulonglong)tempDouble1 >> 0x20),(indexnt)tempDouble2,\n                       (indexnt)((ulonglong)tempDouble2 >> 0x20));\n      floatValue = (float)__truncdfsf2((indexnt)tempDouble1,(indexnt)((ulonglong)tempDouble1 >> 0x20));\n      positionFloats[index] = floatValue;\n      floatValue = tempFloat3;\n    }\n    prindexntFloat(floatValue);\n    indexf (index < 2) {\n      prindexntPgmStrindexng(\",\");\n    }\n  }\n  prindexntPgmStrindexng(\">\\r\\n\");\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004940": "print_position_info_08004940",
                "uVar1": "intValue",
                "fVar2": "floatValue",
                "extraout_s0": "tempFloat1",
                "extraout_s0_00": "tempFloat2",
                "extraout_s0_01": "tempFloat3",
                "extraout_s0_02": "tempFloat4",
                "uVar3": "tempDouble1",
                "uVar4": "tempDouble2",
                "print_position": "positionFloats",
                "current_position": "currentPosition",
                "i": "index"
            },
            "calling": [
                "protocol_execute_runtime"
            ],
            "called": [
                "__floatsisf",
                "__aeabi_f2d",
                "__muldf3",
                "printFloat",
                "__truncdfsf2",
                "__aeabi_fsub",
                "__addsf3",
                "__aeabi_fdiv",
                "printPgmString",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bc0": {
            "entrypoint": "0x08004bc0",
            "current_name": "write_line_to_eeprom_08004bc0",
            "code": "\nvoid writeLineToEEPROM_08004bc0(uilineIndext8_t lineIndex,char *inputLine)\n\n{\n  char *localLine;\n  uilineIndext8_t localLineIndex;\n  uilineIndext16_t eepromAddress;\n  \n  memcpy_to_eeprom_with_checksum((uilineIndext)(ushort)((ushort)lineIndex * 0x101 + 0x300),inputLine,0x100);\n  returlineIndex;\n}\n\n",
            "renaming": {
                "FUN_08004bc0": "write_line_to_eeprom_08004bc0",
                "n": "lineIndex",
                "line": "inputLine",
                "line_local": "localLine",
                "n_local": "localLineIndex",
                "addr": "eepromAddress"
            },
            "calling": [
                "protocol_execute_line",
                "settings_read_startup_line"
            ],
            "called": [
                "memcpy_to_eeprom_with_checksum"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bf4": {
            "entrypoint": "0x08004bf4",
            "current_name": "store_coord_data_in_eeprom_08004bf4",
            "code": "\nvoid store_coord_data_in_eeprom_08004bf4(uint8_t selection,float *data)\n\n{\n  float *local_data;\n  uint8_t local_selection;\n  uint16_t address;\n  \n  memcpy_to_eeprom_with_checksum\n            ((uint)(ushort)((ushort)selection * 0xd + 0x200),(char *)data,0xc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bf4": "store_coord_data_in_eeprom_08004bf4",
                "coord_select": "selection",
                "coord_data": "data",
                "coord_data_local": "local_data",
                "coord_select_local": "local_selection",
                "addr": "address"
            },
            "calling": [
                "gc_execute_line",
                "settings_read_coord_data"
            ],
            "called": [
                "memcpy_to_eeprom_with_checksum"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c2a": {
            "entrypoint": "0x08004c2a",
            "current_name": "store_settings_to_eeprom_08004c2a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid storeSettingsToEEPROM_08004c2a(void)\n\n{\n  writeCharToEEPROM(0,'\\x05');\n  writeDataToEEPROMWithChecksum(1,(char *)&settingsData,0x40);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c2a": "store_settings_to_eeprom_08004c2a",
                "eeprom_put_char": "writeCharToEEPROM",
                "memcpy_to_eeprom_with_checksum": "writeDataToEEPROMWithChecksum",
                "settings": "settingsData"
            },
            "calling": [
                "settings_reset",
                "settings_store_global_setting"
            ],
            "called": [
                "eeprom_put_char",
                "memcpy_to_eeprom_with_checksum"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c48": {
            "entrypoint": "0x08004c48",
            "current_name": "initialize_settings_08004c48",
            "code": "\nvoid initializeSettings_08004c48(_Bool shouldResetAll)\n\n{\n  _Bool shouldResetAllLocal;\n  \n  if (shouldResetAll) {\n    settings.x_steps_per_mm = 157.4803;\n    settings.y_steps_per_mm = 157.4803;\n    settings.z_steps_per_mm = 157.4803;\n    settings.default_pulse_microseconds = '\\n';\n    settings.default_feed_rate = 250.0;\n    settings.default_seek_rate = 500.0;\n    settings.acceleration = 36000.0;\n    settings.mm_per_arc_segment = 0.1;\n    settings.step_invert_mask = 0;\n    settings.dirn_invert_mask = 0xa80;\n    settings.junction_deviation = 0.05;\n  }\n  settings.parameter_flags = '\\x12';\n  settings.homing_direction_mask = 0;\n  settings.homing_feed_rate = 25.0;\n  settings.homing_seek_rate = 250.0;\n  settings.homing_debounce_delay = 100;\n  settings.homing_pulloff = 1.0;\n  settings.stepper_idle_lock_time = '\\x19';\n  settings.decimal_places = '\\x03';\n  settings.arc_correction_value = '\\x19';\n  write_global_settings();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c48": "initialize_settings_08004c48",
                "reset_all": "shouldResetAll",
                "reset_all_local": "shouldResetAllLocal",
                "settings.steps_per_mm[0]": "settings.x_steps_per_mm",
                "settings.steps_per_mm[1]": "settings.y_steps_per_mm",
                "settings.steps_per_mm[2]": "settings.z_steps_per_mm",
                "settings.pulse_microseconds": "settings.default_pulse_microseconds",
                "settings.flags": "settings.parameter_flags",
                "settings.homing_dir_mask": "settings.homing_direction_mask",
                "settings.n_arc_correction": "settings.arc_correction_value"
            },
            "calling": [
                "read_global_settings",
                "settings_init"
            ],
            "called": [
                "write_global_settings"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d2c": {
            "entrypoint": "0x08004d2c",
            "current_name": "load_line_from_eeprom_08004d2c",
            "code": "\nuiline_numbert8_t load_line_from_eeprom_08004d2c(uiline_numbert8_t line_number,char *output_line)\n\n{\n  iline_numbert iVar1;\n  char *local_line;\n  uiline_numbert8_t local_line_number;\n  uiline_numbert16_t address;\n  \n  iVar1 = memcpy_from_eeprom_with_checksum(output_line,(uiline_numbert)(ushort)((ushort)line_number * 0x101 + 0x300),0x100);\n  if (iVar1 == 0) {\n    *output_line = '\\0';\n    settiline_numbergs_store_startup_output_line(line_number,output_line);\n  }\n  returline_number iVar1 != 0;\n}\n\n",
            "renaming": {
                "FUN_08004d2c": "load_line_from_eeprom_08004d2c",
                "n": "line_number",
                "line": "output_line",
                "line_local": "local_line",
                "n_local": "local_line_number",
                "addr": "address"
            },
            "calling": [
                "protocol_execute_line",
                "protocol_execute_startup"
            ],
            "called": [
                "settings_store_startup_line",
                "memcpy_from_eeprom_with_checksum"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d7c": {
            "entrypoint": "0x08004d7c",
            "current_name": "read_and_write_coordinates_08004d7c",
            "code": "\nuint8_t readAndWriteCoordinates_08004d7c(uint8_t selection,float *coordinates)\n\n{\n  int result;\n  float *localCoordinates;\n  uint8_t localSelection;\n  uint16_t address;\n  \n  result = memcpy_from_eeprom_with_checksum\n                    ((char *)coordinates,(uint)(ushort)((ushort)selection * 0xd + 0x200),0xc);\n  if (result == 0) {\n    memset(coordinates,0,0xc);\n    settings_write_coordinates(selection,coordinates);\n  }\n  return result != 0;\n}\n\n",
            "renaming": {
                "FUN_08004d7c": "read_and_write_coordinates_08004d7c",
                "coord_select": "selection",
                "coord_data": "coordinates",
                "coord_data_local": "localCoordinates",
                "coord_select_local": "localSelection",
                "addr": "address",
                "iVar1": "result"
            },
            "calling": [
                "gc_execute_line",
                "gc_init",
                "settings_init",
                "report_gcode_parameters"
            ],
            "called": [
                "settings_write_coord_data",
                "memcpy_from_eeprom_with_checksum",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004dd2": {
            "entrypoint": "0x08004dd2",
            "current_name": "get_settings_version_08004dd2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t get_settings_version_08004dd2(void)\n\n{\n  byte version;\n  int result;\n  uint8_t version;\n  \n  version = eeprom_get_char(0);\n  if (version == 5) {\n    result = memcpy_from_eeprom_with_checksum((char *)&device_settings,1,0x40);\n    if (result == 0) {\n      return '\\0';\n    }\n  }\n  else {\n    if (4 < version) {\n      return '\\0';\n    }\n    result = memcpy_from_eeprom_with_checksum((char *)&device_settings,1,0x28);\n    if (result == 0) {\n      return '\\0';\n    }\n    device_settings_reset(false);\n  }\n  return '\\x01';\n}\n\n",
            "renaming": {
                "FUN_08004dd2": "get_settings_version_08004dd2",
                "bVar1": "version",
                "iVar2": "result",
                "settings": "device_settings"
            },
            "calling": [
                "settings_init"
            ],
            "called": [
                "settings_reset",
                "eeprom_get_char",
                "memcpy_from_eeprom_with_checksum"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e30": {
            "entrypoint": "0x08004e30",
            "current_name": "update_settings_08004e30",
            "code": "\n/* WARNING: Variable defined which should be unmapped: settingValue-local */\n\nuint8_t updateSettings_08004e30(int settingIndex,float settingValue)\n\n{\n  int comparisonResult;\n  undefined4 convertedValue;\n  float inputValue;\n  undefined4 conversionError1;\n  undefined4 conversionError2;\n  undefined4 conversionError3;\n  undefined4 conversionError4;\n  undefined4 conversionError5;\n  undefined4 conversionError6;\n  undefined4 conversionError7;\n  undefined4 conversionError8;\n  float localValue;\n  int localParameter;\n  \n  switch(settingIndex) {\n  case 0:\n  case 1:\n  case 2:\n    comparisonResult = __aeabi_fcmple(settingValue,inputValue,0);\n    if (comparisonResult != 0) {\n      return '\\b';\n    }\n    settings.steps_per_mm[settingIndex] = inputValue;\n    break;\n  case 3:\n    comparisonResult = __aeabi_fcmplt(inputValue,0x40400000);\n    if (comparisonResult != 0) {\n      return '\\t';\n    }\n    convertedValue = __aeabi_f2d(inputValue);\n    round((double)CONCAT44(settingIndex,inputValue));\n    settings.pulse_microseconds = __aeabi_d2uiz(convertedValue,conversionError1);\n    break;\n  case 4:\n    settings.default_feed_rate = inputValue;\n    break;\n  case 5:\n    settings.default_seek_rate = inputValue;\n    break;\n  case 6:\n    convertedValue = __aeabi_f2d(inputValue);\n    trunc((double)CONCAT44(settingIndex,inputValue));\n    settings.step_invert_mask = __aeabi_d2uiz(convertedValue,conversionError2);\n    break;\n  case 7:\n    convertedValue = __aeabi_f2d(inputValue);\n    round((double)CONCAT44(settingIndex,inputValue));\n    settings.stepper_idle_lock_time = __aeabi_d2uiz(convertedValue,conversionError3);\n    break;\n  case 8:\n    convertedValue = __aeabi_fmul(inputValue,0x42700000);\n    settings.acceleration = (float)__aeabi_fmul(convertedValue,0x42700000);\n    break;\n  case 9:\n    settings.junction_deviation = (float)((uint)inputValue & 0x7fffffff);\n    break;\n  case 10:\n    settings.mm_per_arc_segment = inputValue;\n    break;\n  case 0xb:\n    convertedValue = __aeabi_f2d(inputValue);\n    round((double)CONCAT44(settingIndex,inputValue));\n    settings.n_arc_correction = __aeabi_d2uiz(convertedValue,conversionError4);\n    break;\n  case 0xc:\n    convertedValue = __aeabi_f2d(inputValue);\n    round((double)CONCAT44(settingIndex,inputValue));\n    settings.decimal_places = __aeabi_d2uiz(convertedValue,conversionError5);\n    break;\n  case 0xd:\n    comparisonResult = __aeabi_fcmpeq(inputValue,0);\n    if (comparisonResult == 0) {\n      settings.flags = settings.flags | 1;\n    }\n    else {\n      settings.flags = settings.flags & 0xfe;\n    }\n    break;\n  case 0xe:\n    comparisonResult = __aeabi_fcmpeq(inputValue,0);\n    if (comparisonResult == 0) {\n      settings.flags = settings.flags | 2;\n    }\n    else {\n      settings.flags = settings.flags & 0xfd;\n    }\n    break;\n  case 0xf:\n    comparisonResult = __aeabi_fcmpeq(inputValue,0);\n    if (comparisonResult == 0) {\n      settings.flags = settings.flags | 4;\n    }\n    else {\n      settings.flags = settings.flags & 0xfb;\n    }\n    break;\n  case 0x10:\n    comparisonResult = __aeabi_fcmpeq(inputValue,0);\n    if (comparisonResult == 0) {\n      settings.flags = settings.flags | 8;\n    }\n    else {\n      settings.flags = settings.flags & 0xf7;\n    }\n    limits_init();\n    break;\n  case 0x11:\n    comparisonResult = __aeabi_fcmpeq(inputValue,0);\n    if (comparisonResult == 0) {\n      settings.flags = settings.flags | 0x10;\n    }\n    else {\n      settings.flags = settings.flags & 0xef;\n    }\n    break;\n  case 0x12:\n    convertedValue = __aeabi_f2d(inputValue);\n    trunc((double)CONCAT44(settingIndex,inputValue));\n    settings.homing_dir_mask = __aeabi_d2uiz(convertedValue,conversionError6);\n    break;\n  case 0x13:\n    settings.homing_feed_rate = inputValue;\n    break;\n  case 0x14:\n    settings.homing_seek_rate = inputValue;\n    break;\n  case 0x15:\n    convertedValue = __aeabi_f2d(inputValue);\n    round((double)CONCAT44(settingIndex,inputValue));\n    settings.homing_debounce_delay = __aeabi_d2uiz(convertedValue,conversionError7);\n    break;\n  case 0x16:\n    settings.homing_pulloff = inputValue;\n    break;\n  case 0x17:\n    convertedValue = __aeabi_f2d(inputValue);\n    trunc((double)CONCAT44(settingIndex,inputValue));\n    settings.dirn_invert_mask = __aeabi_d2uiz(convertedValue,conversionError8);\n    break;\n  default:\n    return '\\x06';\n  }\n  write_global_settings();\n  return '\\0';\n}\n\n",
            "renaming": {
                "FUN_08004e30": "update_settings_08004e30",
                "parameter": "settingIndex",
                "value": "settingValue",
                "iVar1": "comparisonResult",
                "in_r1": "inputValue",
                "uVar2": "convertedValue",
                "extraout_r1": "conversionError1",
                "extraout_r1_00": "conversionError2",
                "extraout_r1_01": "conversionError3",
                "extraout_r1_02": "conversionError4",
                "extraout_r1_03": "conversionError5",
                "extraout_r1_04": "conversionError6",
                "extraout_r1_05": "conversionError7",
                "extraout_r1_06": "conversionError8",
                "value_local": "localValue",
                "parameter_local": "localParameter"
            },
            "calling": [
                "protocol_execute_line"
            ],
            "called": [
                "__aeabi_f2d",
                "limits_init",
                "trunc",
                "write_global_settings",
                "__aeabi_fcmple",
                "__aeabi_fcmplt",
                "__aeabi_d2uiz",
                "__aeabi_fmul",
                "round",
                "__aeabi_fcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080051b4": {
            "entrypoint": "0x080051b4",
            "current_name": "initialize_settings_080051b4",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd initializeSettings_080051b4(voindexd)\n\n{\n  uindexnt8_t globalSettings;\n  float coordinates [3];\n  uindexnt8_t index;\n  \n  globalSettings = read_global_settindexngs();\n  indexf (globalSettings == '\\0') {\n    report_status_message('\\n');\n    settindexngs_reset(true);\n    report_grbl_settindexngs();\n  }\n  for (index = '\\0'; index < 8; index = index + '\\x01') {\n    globalSettings = settindexngs_read_coordinates(index,coordinates);\n    indexf (globalSettings == '\\0') {\n      report_status_message('\\n');\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080051b4": "initialize_settings_080051b4",
                "coord_data": "coordinates",
                "i": "index",
                "uVar1": "globalSettings"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [
                "report_status_message",
                "report_grbl_settings",
                "read_global_settings",
                "settings_reset",
                "settings_read_coord_data"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005208": {
            "entrypoint": "0x08005208",
            "current_name": "FUNC_08005208",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005208(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005208": "FUNC_08005208"
            },
            "calling": [
                "spindle_run"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005214": {
            "entrypoint": "0x08005214",
            "current_name": "FUNC_08005214",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005214(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005214": "FUNC_08005214"
            },
            "calling": [
                "spindle_stop"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005220": {
            "entrypoint": "0x08005220",
            "current_name": "FUNC_08005220",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005220(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005220": "FUNC_08005220"
            },
            "calling": [
                "spindle_run"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800522c": {
            "entrypoint": "0x0800522c",
            "current_name": "FUNC_0800522c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800522c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800522c": "FUNC_0800522c"
            },
            "calling": [
                "spindle_run"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005238": {
            "entrypoint": "0x08005238",
            "current_name": "stop_spindle_08005238",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopSpindle_08005238(void)\n\n{\n  direction = '\\0';\n  spindle_stop();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005238": "stop_spindle_08005238",
                "current_direction": "direction"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [
                "spindle_stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005250": {
            "entrypoint": "0x08005250",
            "current_name": "turn_spindle_off_08005250",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid turnSpindleOff_08005250(void)\n\n{\n  spindleControl();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005250": "turn_spindle_off_08005250",
                "spindle_off": "spindleControl"
            },
            "calling": [
                "spindle_init",
                "mc_reset",
                "spindle_run"
            ],
            "called": [
                "spindle_off"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800525c": {
            "entrypoint": "0x0800525c",
            "current_name": "update_spindle_direction_0800525c",
            "code": "\nvoid updateSpindleDirection_0800525c(int8_t newDirection)\n\n{\n  int8_t localDirection;\n  \n  if ((int)newDirection != (uint)currentDirection) {\n    synchronizePlan();\n    if (newDirection == '\\0') {\n      stopSpindle();\n      currentDirection = newDirection;\n    }\n    else {\n      if (newDirection < '\\x01') {\n        reverseSpindle();\n      }\n      else {\n        forwardSpindle();\n      }\n      turnOnSpindle();\n      currentDirection = newDirection;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800525c": "update_spindle_direction_0800525c",
                "direction": "newDirection",
                "direction_local": "localDirection",
                "current_direction": "currentDirection",
                "plan_synchronize": "synchronizePlan",
                "spindle_stop": "stopSpindle",
                "spindle_rev": "reverseSpindle",
                "spindle_fwd": "forwardSpindle",
                "spindle_on": "turnOnSpindle"
            },
            "calling": [
                "gc_execute_line"
            ],
            "called": [
                "spindle_fwd",
                "spindle_stop",
                "plan_synchronize",
                "spindle_rev",
                "spindle_on"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052ac": {
            "entrypoint": "0x080052ac",
            "current_name": "update_register_value_080052ac",
            "code": "\n\n\nvoid updateRegisterValue_080052ac(uint32_t input)\n\n{\n  uint32_t localCopy;\n  uint32_t value;\n  \n  _DAT_40021014 = input | _DAT_40021014 & 0inputfffffaaf;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052ac": "update_register_value_080052ac",
                "x": "input",
                "x_local": "localCopy",
                "val": "value"
            },
            "calling": [
                "st_init",
                "step_delay_isr",
                "step_pulse_isr"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052dc": {
            "entrypoint": "0x080052dc",
            "current_name": "update_configuration_080052dc",
            "code": "\n\n\nvoid updateConfiguration_080052dc(uint32_t inputValue)\n\n{\n  uint32_t localValue;\n  uint32_t value;\n  \n  _DAT_40021014 = inputValue | _DAT_40021014 & 0inputValuefffff55f;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052dc": "update_configuration_080052dc",
                "x": "inputValue",
                "x_local": "localValue",
                "val": "value"
            },
            "calling": [
                "step_period_isr"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800530c": {
            "entrypoint": "0x0800530c",
            "current_name": "FUNC_0800530c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800530c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800530c": "FUNC_0800530c"
            },
            "calling": [
                "st_go_idle"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005318": {
            "entrypoint": "0x08005318",
            "current_name": "FUNC_08005318",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005318(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005318": "FUNC_08005318"
            },
            "calling": [
                "st_wake_up"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005324": {
            "entrypoint": "0x08005324",
            "current_name": "configure_step_period_08005324",
            "code": "\nvoid configureStepPeriod_08005324(uint32_t inputStepsPerMinute)\n\n{\n  uint32_t adjustedStepsPerMinute;\n  uint32_t calculatedTicks;\n  \n  adjustedStepsPerMinute = inputStepsPerMinute;\n  if (inputStepsPerMinute < 800) {\n    adjustedStepsPerMinute = 800;\n  }\n  st.cycles_per_step_event = 1260000000 / adjustedStepsPerMinute;\n  set_step_period(st.cycles_per_step_event);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005324": "configure_step_period_08005324",
                "steps_per_minute": "inputStepsPerMinute",
                "steps_per_minute_local": "adjustedStepsPerMinute",
                "ticks": "calculatedTicks"
            },
            "calling": [
                "step_period_isr",
                "st_cycle_reinitialize",
                "st_reset"
            ],
            "called": [
                "set_step_period"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005360": {
            "entrypoint": "0x08005360",
            "current_name": "calculate_trapezoid_tick_08005360",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint calculateTrapezoidTick_08005360(void)\n\n{\n  bool isExceedingThreshold;\n  \n  trapezoidTickCycleCounter = cyclesPerStepEvent + trapezoidTickCycleCounter;\n  isExceedingThreshold = 420000 < trapezoidTickCycleCounter;\n  if (isExceedingThreshold) {\n    trapezoidTickCycleCounter = trapezoidTickCycleCounter - 420000;\n  }\n  return (uint)isExceedingThreshold;\n}\n\n",
            "renaming": {
                "FUN_08005360": "calculate_trapezoid_tick_08005360",
                "st.trapezoid_tick_cycle_counter": "trapezoidTickCycleCounter",
                "st.cycles_per_step_event": "cyclesPerStepEvent",
                "bVar1": "isExceedingThreshold"
            },
            "calling": [
                "step_period_isr"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053a0": {
            "entrypoint": "0x080053a0",
            "current_name": "process_current_block_080053a0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processCurrentBlock_080053a0(void)\n\n{\n  int iterationResult;\n  \n  writeDirection((uint)directionBits);\n  savedStepBits = step_bits;\n  if (currentBlock == (block_t *)0x0) {\n    currentBlock = getCurrentBlock();\n    if (currentBlock == (block_t *)0x0) {\n      setIdleState();\n      sysExecution = sysExecution | 4;\n    }\n    else {\n      if (sysState == '\\x03') {\n        adjustedRate = currentBlock->initial_rate;\n        setStepEventsPerMinute(adjustedRate);\n        tickCycleCounter = 210000;\n      }\n      minSafeRate = (currentBlock->rate_delta >> 1) + currentBlock->rate_delta;\n      counterX = -(currentBlock->step_event_count >> 1);\n      eventCount = currentBlock->step_event_count;\n      stepEventsCompleted = 0;\n      counterY = counterX;\n      counterZ = counterX;\n    }\n  }\n  if (currentBlock != (block_t *)0x0) {\n    directionBits = currentBlock->direction_bits;\n    step_bits = 0;\n    counterX = currentBlock->steps_x + counterX;\n    if (0 < counterX) {\n      step_bits = 0x10;\n      counterX = counterX - eventCount;\n      if ((directionBits & 0x20) == 0) {\n        sys.position[0] = sys.position[0] + 1;\n      }\n      else {\n        sys.position[0] = sys.position[0] + -1;\n      }\n    }\n    counterY = currentBlock->steps_y + counterY;\n    if (0 < counterY) {\n      step_bits = step_bits | 0x440;\n      counterY = counterY - eventCount;\n      if ((directionBits & 0x80) == 0) {\n        sys.position[1] = sys.position[1] + 1;\n      }\n      else {\n        sys.position[1] = sys.position[1] + -1;\n      }\n    }\n    counterZ = currentBlock->steps_z + counterZ;\n    if (0 < counterZ) {\n      step_bits = step_bits | 0x100;\n      counterZ = counterZ - eventCount;\n      if ((directionBits & 0x200) == 0) {\n        sys.position[2] = sys.position[2] + 1;\n      }\n      else {\n        sys.position[2] = sys.position[2] + -1;\n      }\n    }\n    stepEventsCompleted = stepEventsCompleted + 1;\n    if (stepEventsCompleted < (uint)currentBlock->step_event_count) {\n      if (sysState == '\\x04') {\n        iterationResult = iterate_trapezoid_cycle_counter();\n        if (iterationResult != 0) {\n          if ((uint)currentBlock->rate_delta < adjustedRate) {\n            adjustedRate = adjustedRate - currentBlock->rate_delta;\n            setStepEventsPerMinute(adjustedRate);\n          }\n          else {\n            setIdleState();\n            sysExecution = sysExecution | 4;\n          }\n        }\n      }\n      else if (stepEventsCompleted < currentBlock->accelerate_until) {\n        iterationResult = iterate_trapezoid_cycle_counter();\n        if (iterationResult != 0) {\n          adjustedRate = adjustedRate + currentBlock->rate_delta;\n          if (currentBlock->nominal_rate <= adjustedRate) {\n            adjustedRate = currentBlock->nominal_rate;\n          }\n          setStepEventsPerMinute(adjustedRate);\n        }\n      }\n      else if (stepEventsCompleted < currentBlock->decelerate_after) {\n        if (adjustedRate != currentBlock->nominal_rate) {\n          adjustedRate = currentBlock->nominal_rate;\n          setStepEventsPerMinute(adjustedRate);\n        }\n      }\n      else if (stepEventsCompleted == currentBlock->decelerate_after) {\n        if (adjustedRate == currentBlock->nominal_rate) {\n          tickCycleCounter = 210000;\n        }\n        else {\n          tickCycleCounter = 420000 - tickCycleCounter;\n        }\n      }\n      else {\n        iterationResult = iterate_trapezoid_cycle_counter();\n        if (iterationResult != 0) {\n          if (minSafeRate < adjustedRate) {\n            adjustedRate = adjustedRate - currentBlock->rate_delta;\n          }\n          else {\n            adjustedRate = adjustedRate >> 1;\n          }\n          if (adjustedRate < currentBlock->final_rate) {\n            adjustedRate = currentBlock->final_rate;\n          }\n          setStepEventsPerMinute(adjustedRate);\n        }\n      }\n    }\n    else {\n      step_bits = 0;\n      currentBlock = (block_t *)0x0;\n      plan_discard_currentBlock();\n    }\n  }\n  step_bits = step_bits ^ stepInvertMask;\n  directionBits = directionBits ^ dirnInvertMask;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053a0": "process_current_block_080053a0",
                "iVar1": "iterationResult",
                "dirn_wr": "writeDirection",
                "dirn_bits": "directionBits",
                "saved_step_bits": "savedStepBits",
                "current_block": "currentBlock",
                "plan_get_current_block": "getCurrentBlock",
                "st_go_idle": "setIdleState",
                "sys.execute": "sysExecution",
                "sys.state": "sysState",
                "st.trapezoid_adjusted_rate": "adjustedRate",
                "set_step_events_per_minute": "setStepEventsPerMinute",
                "st.trapezoid_tick_cycle_counter": "tickCycleCounter",
                "st.min_safe_rate": "minSafeRate",
                "st.counter_x": "counterX",
                "st.event_count": "eventCount",
                "st.counter_y": "counterY",
                "st.counter_z": "counterZ",
                "st.step_events_completed": "stepEventsCompleted",
                "settings.step_invert_mask": "stepInvertMask",
                "settings.dirn_invert_mask": "dirnInvertMask"
            },
            "calling": [
                "TIM2_IRQHandler"
            ],
            "called": [
                "dirn_wr",
                "iterate_trapezoid_cycle_counter",
                "st_go_idle",
                "plan_discard_current_block",
                "set_step_events_per_minute",
                "plan_get_current_block"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005760": {
            "entrypoint": "0x08005760",
            "current_name": "set_inverted_step_08005760",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_inverted_step_08005760(void)\n\n{\n  set_step_inverted((uint)step_mask);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005760": "set_inverted_step_08005760",
                "settings.step_invert_mask": "step_mask",
                "step_wr": "set_step_inverted"
            },
            "calling": [
                "TIM2_IRQHandler"
            ],
            "called": [
                "step_wr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005778": {
            "entrypoint": "0x08005778",
            "current_name": "perform_step_08005778",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid performStep_08005778(void)\n\n{\n  step_wr((uint)stepBits);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005778": "perform_step_08005778",
                "saved_step_bits": "stepBits"
            },
            "calling": [
                "TIM2_IRQHandler"
            ],
            "called": [
                "step_wr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005790": {
            "entrypoint": "0x08005790",
            "current_name": "initialize_stepper_motor_08005790",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeStepperMotor_08005790(void)\n\n{\n  stepper_motor_enable();\n  if (currentState == '\\x03') {\n    stepInversionMask = settings.step_invert_mask;\n    directionInversionMask = settings.dirn_invert_mask;\n    setStepPulseDelay(0x69);\n    setStepPulseTime((pulseDuration + 5) * 0x15);\n    enableStepInterrupt();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005790": "initialize_stepper_motor_08005790",
                "sys.state": "currentState",
                "step_bits": "stepInversionMask",
                "dirn_bits": "directionInversionMask",
                "set_step_pulse_delay": "setStepPulseDelay",
                "set_step_pulse_time": "setStepPulseTime",
                "settings.pulse_microseconds": "pulseDuration",
                "step_isr_enable": "enableStepInterrupt"
            },
            "calling": [
                "limits_go_home",
                "st_init",
                "st_cycle_start"
            ],
            "called": [
                "step_isr_enable",
                "stepper_motor_enable",
                "set_step_pulse_delay",
                "set_step_pulse_time"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057e4": {
            "entrypoint": "0x080057e4",
            "current_name": "disable_stepper_motor_080057e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_stepper_motor_080057e4(void)\n\n{\n  step_isr_disable();\n  if ((stepper_settings.idle_lock_time != 0xff) || ((execution_flags & 0x20) != 0)) {\n    stepper_motor_disable();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080057e4": "disable_stepper_motor_080057e4",
                "settings": "stepper_settings",
                "stepper_idle_lock_time": "idle_lock_time",
                "sys.execute": "execution_flags"
            },
            "calling": [
                "limits_go_home",
                "st_init",
                "step_period_isr",
                "mc_reset"
            ],
            "called": [
                "stepper_motor_disable",
                "step_isr_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005814": {
            "entrypoint": "0x08005814",
            "current_name": "initialize_blocks_08005814",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeBlocks_08005814(void)\n\n{\n  memset(&state,0,0x24);\n  setStepEventsPerMinute(800);\n  currentBlock = (block_t *)0x0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005814": "initialize_blocks_08005814",
                "st": "state",
                "set_step_events_per_minute": "setStepEventsPerMinute",
                "current_block": "currentBlock"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [
                "set_step_events_per_minute",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800583c": {
            "entrypoint": "0x0800583c",
            "current_name": "initialize_system_0800583c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_0800583c(void)\n\n{\n  writeStep((uint)stepInvertMask);\n  wakeUp();\n  goIdle();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800583c": "initialize_system_0800583c",
                "settings.step_invert_mask": "stepInvertMask",
                "step_wr": "writeStep",
                "st_wake_up": "wakeUp",
                "st_go_idle": "goIdle"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [
                "st_wake_up",
                "st_go_idle",
                "step_wr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800585c": {
            "entrypoint": "0x0800585c",
            "current_name": "change_state_and_wake_up_0800585c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid change_state_and_wake_up_0800585c(void)\n\n{\n  if (current_state == '\\x02') {\n    current_state = '\\x03';\n    wake_up();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800585c": "change_state_and_wake_up_0800585c",
                "sys.state": "current_state",
                "st_wake_up": "wake_up"
            },
            "calling": [
                "mc_go_home",
                "protocol_execute_runtime",
                "mc_line"
            ],
            "called": [
                "st_wake_up"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800587c": {
            "entrypoint": "0x0800587c",
            "current_name": "update_system_state_0800587c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid update_system_state_0800587c(void)\n\n{\n  if (current_state == '\\x03') {\n    current_state = '\\x04';\n    auto_start_enabled = '\\0';\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800587c": "update_system_state_0800587c",
                "sys.state": "current_state",
                "sys.auto_start": "auto_start_enabled"
            },
            "calling": [
                "protocol_execute_runtime"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058a0": {
            "entrypoint": "0x080058a0",
            "current_name": "initialize_system_080058a0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_080058a0(void)\n\n{\n  if (currentBlock == (blockType *)0x0) {\n    system.stateate = '\\0';\n  }\n  else {\n    plan_cycle_reinitialize(currentBlock->numberOfStepEvents - state.completedStepEvents);\n    state.adjustedTrapezoidRate = 0;\n    setStepEventsPerMinute(0);\n    state.trapezoidTickCycleCounter = 210000;\n    state.completedStepEvents = 0;\n    system.stateate = '\\x02';\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080058a0": "initialize_system_080058a0",
                "current_block": "currentBlock",
                "sys": "system",
                "block_t": "blockType",
                "st": "state",
                "step_event_count": "numberOfStepEvents",
                "step_events_completed": "completedStepEvents",
                "trapezoid_adjusted_rate": "adjustedTrapezoidRate",
                "set_step_events_per_minute": "setStepEventsPerMinute",
                "trapezoid_tick_cycle_counter": "trapezoidTickCycleCounter"
            },
            "calling": [
                "protocol_execute_runtime"
            ],
            "called": [
                "plan_cycle_reinitialize",
                "set_step_events_per_minute"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005900": {
            "entrypoint": "0x08005900",
            "current_name": "process_data_08005900",
            "code": "\nint process_data_08005900(uint8_t input_data)\n\n{\n  uint8_t local_data;\n  int return_code;\n  \n  if (input_data == '~') {\n    execution_flag = execution_flag | 2;\n    return 1;\n  }\n  if (input_data < 0x7f) {\n    if (input_data == '?') {\n      execution_flag = execution_flag | 1;\n      return 1;\n    }\n    if (input_data < 0x40) {\n      if (input_data == '\\x18') {\n        mc_reset();\n        return 1;\n      }\n      if (input_data == '!') {\n        execution_flag = execution_flag | 8;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005900": "process_data_08005900",
                "data": "input_data",
                "data_local": "local_data",
                "rc": "return_code",
                "sys.execute": "execution_flag"
            },
            "calling": [
                "serial_read"
            ],
            "called": [
                "mc_reset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800597c": {
            "entrypoint": "0x0800597c",
            "current_name": "execute_software_interrupt_0800597c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_software_interrupt_0800597c(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_0800597c": "execute_software_interrupt_0800597c"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005984": {
            "entrypoint": "0x08005984",
            "current_name": "execute_afl_call_08005984",
            "code": "\nint executeAflCall_08005984(int ticks)\n\n{\n  uint32_t aflReturnValue;\n  int localTicks;\n  \n  if (noHyperCall == 0) {\n    aflReturnValue = aflCall(1,ticks,0);\n  }\n  else {\n    aflReturnValue = 0;\n  }\n  return aflReturnValue;\n}\n\n",
            "renaming": {
                "FUN_08005984": "execute_afl_call_08005984",
                "uVar1": "aflReturnValue",
                "ticks_local": "localTicks"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059b4": {
            "entrypoint": "0x080059b4",
            "current_name": "initialize_system_080059b4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nSystemStatus initializeSystem_080059b4(void)\n\n{\n  _DAT_40023c00 = _DAT_40023c00 | 0x700;\n  configureSysTick(16000);\n  setPriorityGrouping(3);\n  initializeMsp();\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080059b4": "initialize_system_080059b4",
                "HAL_StatusTypeDef": "SystemStatus",
                "HAL_SYSTICK_Config": "configureSysTick",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping",
                "HAL_MspInit": "initializeMsp"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_MspInit",
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f8": {
            "entrypoint": "0x080059f8",
            "current_name": "deinitialize_hal_080059f8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef deinitialize_HAL_080059f8(void)\n\n{\n  _DAT_40023820 = 0;\n  _DAT_40023824 = 0;\n  _DAT_40023810 = 0;\n  _DAT_40023814 = 0;\n  _DAT_40023818 = 0;\n  HAL_MspDeInit();\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080059f8": "deinitialize_hal_080059f8"
            },
            "calling": [],
            "called": [
                "HAL_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a50": {
            "entrypoint": "0x08005a50",
            "current_name": "FUNC_08005a50",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005a50(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a50": "FUNC_08005a50"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005a5c": {
            "entrypoint": "0x08005a5c",
            "current_name": "FUNC_08005a5c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08005a5c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a5c": "FUNC_08005a5c"
            },
            "calling": [
                "HAL_DeInit"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005a68": {
            "entrypoint": "0x08005a68",
            "current_name": "increment_system_tick_08005a68",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid incrementSystemTick_08005a68(void)\n\n{\n  systemTick = systemTick + 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a68": "increment_system_tick_08005a68",
                "uwTick": "systemTick"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a84": {
            "entrypoint": "0x08005a84",
            "current_name": "get_tick_count_08005a84",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTickCount_08005a84(void)\n\n{\n  return tickValue;\n}\n\n",
            "renaming": {
                "FUN_08005a84": "get_tick_count_08005a84",
                "uwTick": "tickValue"
            },
            "calling": [
                "get_current_usecs",
                "HAL_RCC_ClockConfig",
                "SysTick_Handler",
                "HAL_RCC_OscConfig",
                "HAL_Delay"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a98": {
            "entrypoint": "0x08005a98",
            "current_name": "delay_milliseconds_08005a98",
            "code": "\nvoid delayMilliseconds_08005a98(uint32_t initialDelay)\n\n{\n  uint32_t startTime;\n  uint32_t currentTime;\n  uint32_t finalDelay;\n  uint32_t timeElapsed;\n  \n  startTime = HAL_GetTick();\n  do {\n    currentTime = HAL_GetTick();\n  } while (currentTime < initialDelay + startTime);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a98": "delay_milliseconds_08005a98",
                "Delay": "initialDelay",
                "uVar1": "startTime",
                "uVar2": "currentTime",
                "Delay_local": "finalDelay",
                "timingdelay": "timeElapsed"
            },
            "calling": [
                "_delay_ms"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005ac4": {
            "entrypoint": "0x08005ac4",
            "current_name": "get_constant_value_08005ac4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getConstantValue_08005ac4(void)\n\n{\n  return 0x1000000;\n}\n\n",
            "renaming": {
                "FUN_08005ac4": "get_constant_value_08005ac4"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005ad4": {
            "entrypoint": "0x08005ad4",
            "current_name": "get_upper_word_08005ad4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getUpperWord_08005ad4(void)\n\n{\n  return _DAT_e0042000 >> 0x10;\n}\n\n",
            "renaming": {
                "FUN_08005ad4": "get_upper_word_08005ad4"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005aec": {
            "entrypoint": "0x08005aec",
            "current_name": "get_lower_12_bits_08005aec",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_lower_12_bits_08005aec(void)\n\n{\n  return _DAT_e0042000 & 0xfff;\n}\n\n",
            "renaming": {
                "FUN_08005aec": "get_lower_12_bits_08005aec"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b04": {
            "entrypoint": "0x08005b04",
            "current_name": "set_e0042004_bit_08005b04",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid set_e0042004_bit_08005b04(void)\n\n{\n  _DAT_e0042004 = _DAT_e0042004 | 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b04": "set_e0042004_bit_08005b04"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b20": {
            "entrypoint": "0x08005b20",
            "current_name": "clear_least_significant_bit_08005b20",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid clear_least_significant_bit_08005b20(void)\n\n{\n  _DAT_e0042004 = _DAT_e0042004 & 0xfffffffe;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b20": "clear_least_significant_bit_08005b20"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b3c": {
            "entrypoint": "0x08005b3c",
            "current_name": "enable_interrupt_08005b3c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid enableInterrupt_08005b3c(void)\n\n{\n  _DAT_e0042004 = _DAT_e0042004 | 2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b3c": "enable_interrupt_08005b3c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b58": {
            "entrypoint": "0x08005b58",
            "current_name": "clear_flag_08005b58",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid clearFlag_08005b58(void)\n\n{\n  _DAT_e0042004 = _DAT_e0042004 & 0xfffffffd;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b58": "clear_flag_08005b58"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b74": {
            "entrypoint": "0x08005b74",
            "current_name": "set_flag_in_memory_08005b74",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setFlagInMemory_08005b74(void)\n\n{\n  _DAT_e0042004 = _DAT_e0042004 | 4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b74": "set_flag_in_memory_08005b74"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b90": {
            "entrypoint": "0x08005b90",
            "current_name": "clear_interrupt_flag_08005b90",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid clearInterruptFlag_08005b90(void)\n\n{\n  _DAT_e0042004 = _DAT_e0042004 & 0xfffffffb;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b90": "clear_interrupt_flag_08005b90"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bac": {
            "entrypoint": "0x08005bac",
            "current_name": "initialize_flag_08005bac",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeFlag_08005bac(void)\n\n{\n  _DAT_42270400 = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005bac": "initialize_flag_08005bac"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bc4": {
            "entrypoint": "0x08005bc4",
            "current_name": "initialize_data_08005bc4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeData_08005bc4(void)\n\n{\n  _DAT_42270400 = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005bc4": "initialize_data_08005bc4"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bdc": {
            "entrypoint": "0x08005bdc",
            "current_name": "set_irq_priority_08005bdc",
            "code": "\nvoid setIRQPriority_08005bdc(interruptNumber_Type interruptNumber,uint32_t newPriority)\n\n{\n  uint32_t localPriority;\n  interruptNumber_Type localInterruptNumber;\n  \n  if (interruptNumber < WWDG_interruptNumber) {\n    *(char *)(((byte)interruptNumber & 0xf) + 0xe000ed14) = (char)((newPriority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interruptNumber + -0x1fff1c00) = (char)((newPriority & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005bdc": "set_irq_priority_08005bdc",
                "IRQn": "interruptNumber",
                "priority": "newPriority",
                "priority_local": "localPriority",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "SysTick_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c30": {
            "entrypoint": "0x08005c30",
            "current_name": "check_ticks_validity_08005c30",
            "code": "\n\n\nuint32_t checkTicksValidity_08005c30(uint32_t inputTicks)\n\n{\n  bool validTicks;\n  uint32_t adjustedTicks;\n  \n  validTicks = inputTicks - 1 < 0x1000000;\n  if (validTicks) {\n    _DAT_e000e014 = inputTicks - 1;\n    NVIC_SetPriority(SysTick_IRQn,0xf);\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n  }\n  return (uint)!validTicks;\n}\n\n",
            "renaming": {
                "FUN_08005c30": "check_ticks_validity_08005c30",
                "ticks": "inputTicks",
                "bVar1": "validTicks",
                "ticks_local": "adjustedTicks"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c74": {
            "entrypoint": "0x08005c74",
            "current_name": "initialize_memory_08005c74",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeMemory_08005c74(void)\n\n{\n  _DAT_40023808 = 0;\n  _DAT_40023804 = 0x4003010;\n  _DAT_40023884 = 0x20003000;\n  _DAT_40023800 = _DAT_40023800 & 0xfaf2ffff | 0x81;\n  _DAT_4002380c = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005c74": "initialize_memory_08005c74"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cec": {
            "entrypoint": "0x08005cec",
            "current_name": "initialize_rcc_oscillators_08005cec",
            "code": "\n\n\nHAL_StatusTypeDef initializeRCCOscillators_08005cec(RCC_OscInitTypeDef *oscillatorConfig)\n\n{\n  uint32_t startTime;\n  uint32_t endTime;\n  RCC_OscInitTypeDef *localOscillatorConfig;\n  uint32_t result2;\n  uint32_t result3;\n  uint32_t result4;\n  uint32_t result5;\n  uint32_t result6;\n  uint32_t result7;\n  uint32_t result1;\n  uint32_t result2;\n  uint32_t maxTimeout;\n  \n  if ((oscillatorConfig->OscillatorType & 1) != 0) {\n    if (((_DAT_40023808 & 0xc) == 4) ||\n       (((_DAT_40023808 & 0xc) == 8 && ((_DAT_40023804 & 0x400000) == 0x400000)))) {\n      if (((_DAT_40023800 & 0x20000) != 0) && (oscillatorConfig->HSEState != 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      _DAT_40023800 = (uint3)_DAT_40023800;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023800 & 0x20000) != 0) {\n        endTime = HAL_GetTick();\n        if (startTime + 5000 <= endTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40023800 = CONCAT12((char)oscillatorConfig->HSEState,_DAT_40023800);\n      if (oscillatorConfig->HSEState == 1) {\n        startTime = HAL_GetTick();\n        while ((_DAT_40023800 & 0x20000) == 0) {\n          endTime = HAL_GetTick();\n          if (startTime + 5000 <= endTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        startTime = HAL_GetTick();\n        while ((_DAT_40023800 & 0x20000) != 0) {\n          endTime = HAL_GetTick();\n          if (startTime + 5000 <= endTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 2) != 0) {\n    if (((_DAT_40023808 & 0xc) == 0) ||\n       (((_DAT_40023808 & 0xc) == 8 && ((_DAT_40023804 & 0x400000) == 0)))) {\n      if (((_DAT_40023800 & 2) != 0) && (oscillatorConfig->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else if (oscillatorConfig->HSIState == 0) {\n      _DAT_42470000 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023800 & 2) != 0) {\n        endTime = HAL_GetTick();\n        if (startTime + 100 <= endTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470000 = 1;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023800 & 2) == 0) {\n        endTime = HAL_GetTick();\n        if (startTime + 100 <= endTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40023800 = oscillatorConfig->HSICalibrationValue << 3 | _DAT_40023800 & 0xffffff07;\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 8) != 0) {\n    if (oscillatorConfig->LSIState == 0) {\n      _DAT_42470e80 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023874 & 2) != 0) {\n        endTime = HAL_GetTick();\n        if (startTime + 100 <= endTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470e80 = 1;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023874 & 2) == 0) {\n        endTime = HAL_GetTick();\n        if (startTime + 100 <= endTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((oscillatorConfig->OscillatorType & 4) != 0) {\n    _DAT_40023840 = _DAT_40023840 | 0x10000000;\n    _DAT_40007000 = _DAT_40007000 | 0x100;\n    startTime = HAL_GetTick();\n    while ((_DAT_40007000 & 0x100) == 0) {\n      endTime = HAL_GetTick();\n      if (startTime + 100 <= endTime) {\n        return HAL_TIMEOUT;\n      }\n    }\n    _DAT_40023870 = _DAT_40023870 & 0xffffff00;\n    startTime = HAL_GetTick();\n    while ((_DAT_40023870 & 2) != 0) {\n      endTime = HAL_GetTick();\n      if (startTime + 5000 <= endTime) {\n        return HAL_TIMEOUT;\n      }\n    }\n    _DAT_40023870 = CONCAT31(DAT_40023870_1,(char)oscillatorConfig->LSEState);\n    if (oscillatorConfig->LSEState == 1) {\n      startTime = HAL_GetTick();\n      while ((_DAT_40023870 & 2) == 0) {\n        endTime = HAL_GetTick();\n        if (startTime + 5000 <= endTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      startTime = HAL_GetTick();\n      while ((_DAT_40023870 & 2) != 0) {\n        endTime = HAL_GetTick();\n        if (startTime + 5000 <= endTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((oscillatorConfig->PLL).PLLState != 0) {\n    if ((_DAT_40023808 & 0xc) == 8) {\n      return HAL_ERROR;\n    }\n    if ((oscillatorConfig->PLL).PLLState == 2) {\n      _DAT_42470060 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023800 & 0x2000000) != 0) {\n        endTime = HAL_GetTick();\n        if (startTime + 100 <= endTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40023804 =\n           (oscillatorConfig->PLL).PLLQ << 0x18 |\n           (oscillatorConfig->PLL).PLLM | (oscillatorConfig->PLL).PLLN << 6 |\n           (((oscillatorConfig->PLL).PLLP >> 1) - 1) * 0x10000 | (oscillatorConfig->PLL).PLLSource\n           | 0x20000000;\n      _DAT_42470060 = 1;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023800 & 0x2000000) == 0) {\n        endTime = HAL_GetTick();\n        if (startTime + 100 <= endTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470060 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40023800 & 0x2000000) != 0) {\n        endTime = HAL_GetTick();\n        if (startTime + 100 <= endTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08005cec": "initialize_rcc_oscillators_08005cec",
                "RCC_OscInitStruct": "oscillatorConfig",
                "uVar1": "startTime",
                "uVar2": "endTime",
                "RCC_OscInitStruct_local": "localOscillatorConfig",
                "result_2": "result2",
                "result_3": "result3",
                "result_4": "result4",
                "result_5": "result5",
                "result_6": "result6",
                "result_7": "result7",
                "result": "result1",
                "result_1": "result2",
                "timeout": "maxTimeout"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800618c": {
            "entrypoint": "0x0800618c",
            "current_name": "configure_clocks_0800618c",
            "code": "\n\n\nHAL_StatusTypeDef configureClocks_0800618c(RCC_ClkInitTypeDef *clockConfig,uint32_t flashLatency)\n\n{\n  uint32_t currentTime;\n  uint timeout;\n  uint32_t localFlashLatency;\n  RCC_ClkInitTypeDef *localClockConfig;\n  uint32_t timeout;\n  \n  if ((_DAT_40023c00 & 0xf) < flashLatency) {\n    _DAT_40023c00 = CONCAT31(DAT_40023c00_1,(char)flashLatency);\n    if (flashLatency != (flashLatency & 0xf)) {\n      return HAL_ERROR;\n    }\n    if ((clockConfig->ClockType & 1) != 0) {\n      if (clockConfig->SYSCLKSource == 1) {\n        if ((_DAT_40023800 & 0x20000) == 0) {\n          return HAL_ERROR;\n        }\n      }\n      else if ((clockConfig->SYSCLKSource != 2) && ((_DAT_40023800 & 2) == 0)) {\n        return HAL_ERROR;\n      }\n      _DAT_40023808 = clockConfig->SYSCLKSource | _DAT_40023808 & 0xfffffffc;\n      currentTime = HAL_GetTick();\n      timeout = currentTime + 5000;\n      if (clockConfig->SYSCLKSource == 1) {\n        while ((_DAT_40023808 & 0xc) != 4) {\n          currentTime = HAL_GetTick();\n          if (timeout <= currentTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else if (clockConfig->SYSCLKSource == 2) {\n        while ((_DAT_40023808 & 0xc) != 8) {\n          currentTime = HAL_GetTick();\n          if (timeout <= currentTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        while ((_DAT_40023808 & 0xc) != 0) {\n          currentTime = HAL_GetTick();\n          if (timeout <= currentTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  else {\n    if ((clockConfig->ClockType & 1) != 0) {\n      if (clockConfig->SYSCLKSource == 1) {\n        if ((_DAT_40023800 & 0x20000) == 0) {\n          return HAL_ERROR;\n        }\n      }\n      else if (clockConfig->SYSCLKSource == 2) {\n        if ((_DAT_40023800 & 0x2000000) == 0) {\n          return HAL_ERROR;\n        }\n      }\n      else if ((_DAT_40023800 & 2) == 0) {\n        return HAL_ERROR;\n      }\n      _DAT_40023808 = clockConfig->SYSCLKSource | _DAT_40023808 & 0xfffffffc;\n      currentTime = HAL_GetTick();\n      timeout = currentTime + 5000;\n      if (clockConfig->SYSCLKSource == 1) {\n        while ((_DAT_40023808 & 0xc) != 4) {\n          currentTime = HAL_GetTick();\n          if (timeout <= currentTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else if (clockConfig->SYSCLKSource == 2) {\n        while ((_DAT_40023808 & 0xc) != 8) {\n          currentTime = HAL_GetTick();\n          if (timeout <= currentTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        while ((_DAT_40023808 & 0xc) != 0) {\n          currentTime = HAL_GetTick();\n          if (timeout <= currentTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    _DAT_40023c00 = CONCAT31(DAT_40023c00_1,(char)flashLatency);\n    if (flashLatency != (flashLatency & 0xf)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((clockConfig->ClockType & 2) != 0) {\n    _DAT_40023808 = clockConfig->AHBCLKDivider | _DAT_40023808 & 0xffffff0f;\n  }\n  if ((clockConfig->ClockType & 4) != 0) {\n    _DAT_40023808 = clockConfig->APB1CLKDivider | _DAT_40023808 & 0xffffe3ff;\n  }\n  if ((clockConfig->ClockType & 8) != 0) {\n    _DAT_40023808 = clockConfig->APB2CLKDivider << 3 | _DAT_40023808 & 0xffff1fff;\n  }\n  currentTime = HAL_RCC_GetHCLKFreq();\n  SysTick_Config(currentTime / 1000);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800618c": "configure_clocks_0800618c",
                "RCC_ClkInitStruct": "clockConfig",
                "FLatency": "flashLatency",
                "uVar1": "currentTime",
                "uVar2": "timeout",
                "FLatency_local": "localFlashLatency",
                "RCC_ClkInitStruct_local": "localClockConfig"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "SysTick_Config",
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800640c": {
            "entrypoint": "0x0800640c",
            "current_name": "configure_rcc_mco_0800640c",
            "code": "\n\n\nvoid configureRCC_MCO_0800640c(uint32_t MCOx,uint32_t MCOSource,uint32_t MCODiv)\n\n{\n  uint32_t MCODiv_local;\n  uint32_t MCOSource_local;\n  uint32_t MCOx_local;\n  GPIO_InitTypeDef GPIO_config;\n  \n  if (MCOx == 0) {\n    _DAT_40023830 = _DAT_40023830 | 1;\n    GPIO_config.Pin = 0x100;\n    GPIO_config.Mode = 2;\n    GPIO_config.Speed = 3;\n    GPIO_config.Pull = 0;\n    GPIO_config.Alternate = 0;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40020000,&GPIO_config);\n    _DAT_40023808 = MCODiv | MCOSource | _DAT_40023808 & 0xf89fffff;\n  }\n  else {\n    _DAT_40023830 = _DAT_40023830 | 4;\n    GPIO_config.Pin = 0x200;\n    GPIO_config.Mode = 2;\n    GPIO_config.Speed = 3;\n    GPIO_config.Pull = 0;\n    GPIO_config.Alternate = 0;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40020800,&GPIO_config);\n    _DAT_40023808 = MCOSource | MCODiv << 3 | _DAT_40023808 & 0x7ffffff;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800640c": "configure_rcc_mco_0800640c",
                "RCC_MCOx": "MCOx",
                "RCC_MCOSource": "MCOSource",
                "RCC_MCODiv": "MCODiv",
                "RCC_MCODiv_local": "MCODiv_local",
                "RCC_MCOSource_local": "MCOSource_local",
                "RCC_MCOx_local": "MCOx_local",
                "GPIO_InitStruct": "GPIO_config"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080064bc": {
            "entrypoint": "0x080064bc",
            "current_name": "initialize_flag_080064bc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeFlag_080064bc(void)\n\n{\n  _DAT_4247004c = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080064bc": "initialize_flag_080064bc"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080064d4": {
            "entrypoint": "0x080064d4",
            "current_name": "initialize_data_080064d4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeData_080064d4(void)\n\n{\n  _DAT_4247004c = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080064d4": "initialize_data_080064d4"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080064ec": {
            "entrypoint": "0x080064ec",
            "current_name": "calculate_sys_clock_freq_080064ec",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateSysClockFreq_080064ec(void)\n\n{\n  uint uVar1;\n  uint32_t factor1;\n  uint32_t factor2;\n  uint32_t factor1;\n  uint32_t factor2;\n  uint32_t pllVCO;\n  uint32_t divisor;\n  uint32_t sysClockFreq;\n  uint32_t sysClockFreq;\n  uint32_t factor1;\n  uint32_t factor2;\n  uint32_t sysclockfreq;\n  uint32_t pllvco;\n  \n  uVar1 = _DAT_40023808 & 0xc;\n  if (uVar1 == 8) {\n    if ((_DAT_40023804 & 0x400000) == 0) {\n      pllvco = ((_DAT_40023804 & 0x7fc0) >> 6) * (16000000 / (_DAT_40023804 & 0x3f));\n    }\n    else {\n      pllvco = ((_DAT_40023804 & 0x7fc0) >> 6) * (8000000 / (_DAT_40023804 & 0x3f));\n    }\n    return pllvco / ((((_DAT_40023804 & 0x30000) >> 0x10) + 1) * 2);\n  }\n  if (uVar1 < 9) {\n    if (uVar1 == 0) {\n      return 16000000;\n    }\n    if (uVar1 == 4) {\n      return 8000000;\n    }\n  }\n  return 16000000;\n}\n\n",
            "renaming": {
                "FUN_080064ec": "calculate_sys_clock_freq_080064ec",
                "result": "sysClockFreq",
                "result_1": "sysClockFreq",
                "result_2": "pllVCO",
                "result_3": "divisor",
                "result_4": "factor1",
                "result_5": "factor2",
                "result_6": "factor1",
                "result_7": "factor2",
                "pllp": "factor1",
                "pllm": "factor2"
            },
            "calling": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006628": {
            "entrypoint": "0x08006628",
            "current_name": "get_sys_clock_frequency_08006628",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_sys_clock_frequency_08006628(void)\n\n{\n  uint32_t sys_clock_freq;\n  uint32_t shifted_sys_clock;\n  uint32_t shifted_sys_clock_1;\n  \n  sys_clock_freq = HAL_RCC_GetSysClockFreq();\n  SystemCoreClock = sys_clock_freq >> \"\"[(_DAT_40023808 & 0xf0) >> 4];\n  return sys_clock_freq >> \"\"[(_DAT_40023808 & 0xf0) >> 4];\n}\n\n",
            "renaming": {
                "FUN_08006628": "get_sys_clock_frequency_08006628",
                "uVar1": "sys_clock_freq",
                "result": "shifted_sys_clock",
                "result_1": "shifted_sys_clock_1"
            },
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "called": [
                "HAL_RCC_GetSysClockFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006680": {
            "entrypoint": "0x08006680",
            "current_name": "get_system_clock_frequency_08006680",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemClockFrequency_08006680(void)\n\n{\n  uint32_t systemClockFrequency;\n  uint32_t shiftedFrequency;\n  uint32_t finalFrequency;\n  \n  systemClockFrequency = HAL_RCC_GetHCLKFreq();\n  return systemClockFrequency >> \"\"[(_DAT_40023808 & 0x1c00) >> 10];\n}\n\n",
            "renaming": {
                "FUN_08006680": "get_system_clock_frequency_08006680",
                "uVar1": "systemClockFrequency",
                "result": "shiftedFrequency",
                "result_1": "finalFrequency"
            },
            "calling": [
                "set_baud_rate"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080066cc": {
            "entrypoint": "0x080066cc",
            "current_name": "get_hclk_frequency_080066cc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_HCLK_frequency_080066cc(void)\n\n{\n  uint32_t HCLK_freq;\n  uint32_t shifted_value;\n  uint32_t final_result;\n  \n  HCLK_freq = HAL_RCC_GetHCLKFreq();\n  return HCLK_freq >> \"\"[(_DAT_40023808 & 0xe000) >> 0xd];\n}\n\n",
            "renaming": {
                "FUN_080066cc": "get_hclk_frequency_080066cc",
                "uVar1": "HCLK_freq",
                "result": "shifted_value",
                "result_1": "final_result"
            },
            "calling": [
                "set_baud_rate"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006718": {
            "entrypoint": "0x08006718",
            "current_name": "initialize_rcc_oscillators_08006718",
            "code": "\n\n\nvoid initialize_RCC_Oscillators_08006718(RCC_OscInitTypeDef *oscillator_init)\n\n{\n  RCC_OscInitTypeDef *local_oscillator_init;\n  uint32_t result_2;\n  uint32_t result_3;\n  uint32_t result_4;\n  uint32_t result_5;\n  uint32_t result_6;\n  uint32_t result_7;\n  uint32_t result;\n  uint32_t result_1;\n  \n  oscillator_init->OscillatorType = 0xf;\n  if ((_DAT_40023800 & 0x40000) == 0x40000) {\n    oscillator_init->HSEState = 5;\n  }\n  else if ((_DAT_40023800 & 0x10000) == 0x10000) {\n    oscillator_init->HSEState = 1;\n  }\n  else {\n    oscillator_init->HSEState = 0;\n  }\n  if ((_DAT_40023800 & 1) == 1) {\n    oscillator_init->HSIState = 1;\n  }\n  else {\n    oscillator_init->HSIState = 0;\n  }\n  oscillator_init->HSICalibrationValue = (_DAT_40023800 & 0xf8) >> 3;\n  if ((_DAT_40023870 & 4) == 4) {\n    oscillator_init->LSEState = 5;\n  }\n  else if ((_DAT_40023870 & 1) == 1) {\n    oscillator_init->LSEState = 1;\n  }\n  else {\n    oscillator_init->LSEState = 0;\n  }\n  if ((_DAT_40023874 & 1) == 1) {\n    oscillator_init->LSIState = 1;\n  }\n  else {\n    oscillator_init->LSIState = 0;\n  }\n  if ((_DAT_40023800 & 0x1000000) == 0x1000000) {\n    (oscillator_init->PLL).PLLState = 2;\n  }\n  else {\n    (oscillator_init->PLL).PLLState = 1;\n  }\n  (oscillator_init->PLL).PLLSource = _DAT_40023804 & 0x400000;\n  (oscillator_init->PLL).PLLM = _DAT_40023804 & 0x3f;\n  (oscillator_init->PLL).PLLN = (_DAT_40023804 & 0x7fc0) >> 6;\n  (oscillator_init->PLL).PLLP = ((_DAT_40023804 & 0x30000) + 0x10000) * 2 >> 0x10;\n  (oscillator_init->PLL).PLLQ = (_DAT_40023804 & 0xf000000) >> 0x18;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006718": "initialize_rcc_oscillators_08006718",
                "RCC_OscInitStruct": "oscillator_init",
                "RCC_OscInitStruct_local": "local_oscillator_init"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080068bc": {
            "entrypoint": "0x080068bc",
            "current_name": "initialize_clock_080068bc",
            "code": "\n\n\nvoid initializeClock_080068bc(RCC_ClkInitTypeDef *clkInitStruct,uint32_t *pFlashLatency)\n\n{\n  uint32_t *pFlashLatency_local;\n  RCC_ClkInitTypeDef *clkInitStruct_local;\n  \n  clkInitStruct->ClockType = 0xf;\n  clkInitStruct->SYSCLKSource = _DAT_40023808 & 3;\n  clkInitStruct->AHBCLKDivider = _DAT_40023808 & 0xf0;\n  clkInitStruct->APB1CLKDivider = _DAT_40023808 & 0x1c00;\n  clkInitStruct->APB2CLKDivider = _DAT_40023808 >> 3 & 0x1c00;\n  *pFlashLatency = _DAT_40023c00 & 0xf;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080068bc": "initialize_clock_080068bc",
                "RCC_ClkInitStruct": "clkInitStruct",
                "pFLatency": "pFlashLatency",
                "pFLatency_local": "pFlashLatency_local",
                "RCC_ClkInitStruct_local": "clkInitStruct_local"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800691c": {
            "entrypoint": "0x0800691c",
            "current_name": "check_and_invoke_ccs_callback_0800691c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid checkAndInvokeCCSCallback_0800691c(void)\n\n{\n  if ((_DAT_4002380c & 0x80) == 0x80) {\n    HAL_RCC_CCSCallback();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800691c": "check_and_invoke_ccs_callback_0800691c"
            },
            "calling": [],
            "called": [
                "HAL_RCC_CCSCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006944": {
            "entrypoint": "0x08006944",
            "current_name": "FUNC_08006944",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08006944(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006944": "FUNC_08006944"
            },
            "calling": [
                "HAL_RCC_NMI_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08006950": {
            "entrypoint": "0x08006950",
            "current_name": "set_priority_group_08006950",
            "code": "\n\n\nvoid setPriorityGroup_08006950(uint32_t priorityGroup)\n\n{\n  uint32_t localPriorityGroup;\n  uint32_t registerValue;\n  uint32_t temporaryPriorityGroup;\n  \n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | (priorityGroup & 7) << 8 | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006950": "set_priority_group_08006950",
                "PriorityGroup": "priorityGroup",
                "PriorityGroup_local": "localPriorityGroup",
                "reg_value": "registerValue",
                "PriorityGroupTmp": "temporaryPriorityGroup"
            },
            "calling": [
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006998": {
            "entrypoint": "0x08006998",
            "current_name": "get_shifted_value_08006998",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getShiftedValue_08006998(void)\n\n{\n  return _DAT_e000ed0c >> 8 & 7;\n}\n\n",
            "renaming": {
                "FUN_08006998": "get_shifted_value_08006998"
            },
            "calling": [
                "HAL_NVIC_GetPriorityGrouping",
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080069b4": {
            "entrypoint": "0x080069b4",
            "current_name": "set_interrupt_enable_080069b4",
            "code": "\nvoid setInterruptEnable_080069b4(interruptNumber_Type interruptNumber)\n\n{\n  interruptNumber_Type localInterruptNumber;\n  \n  *(int *)(((uint)(int)interruptNumber >> 5) * 4 + -0x1fff1f00) = 1 << (interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080069b4": "set_interrupt_enable_080069b4",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "HAL_NVIC_EnableIRQ"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080069e4": {
            "entrypoint": "0x080069e4",
            "current_name": "set_interrupt_enable_bit_080069e4",
            "code": "\nvoid setInterruptEnableBit_080069e4(interruptNumber_Type interruptNumber)\n\n{\n  interruptNumber_Type localInterruptNumber;\n  \n  *(int *)((((uint)(int)interruptNumber >> 5) + 0x20) * 4 + -0x1fff1f00) = 1 << (interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080069e4": "set_interrupt_enable_bit_080069e4",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "HAL_NVIC_DisableIRQ"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006a18": {
            "entrypoint": "0x08006a18",
            "current_name": "check_irq_status_08006a18",
            "code": "\nuint32_t checkIRQStatus_08006a18(interruptNumber_Type interruptNumber)\n\n{\n  interruptNumber_Type localInterruptNumber;\n  \n  return (uint)((*(uint *)((((uint)(int)interruptNumber >> 5) + 0x40) * 4 + -0x1fff1f00) & 1 << (interruptNumber & 0x1fU))\n               != 0);\n}\n\n",
            "renaming": {
                "FUN_08006a18": "check_irq_status_08006a18",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "HAL_NVIC_GetPendingIRQ"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006a58": {
            "entrypoint": "0x08006a58",
            "current_name": "set_interrupt_priority_08006a58",
            "code": "\nvoid setInterruptPriority_08006a58(interrupt_Type interrupt)\n\n{\n  interrupt_Type localInterrupt;\n  \n  *(int *)((((uint)(int)interrupt >> 5) + 0x40) * 4 + -0x1fff1f00) = 1 << (interrupt & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006a58": "set_interrupt_priority_08006a58",
                "IRQn": "interrupt",
                "IRQn_local": "localInterrupt"
            },
            "calling": [
                "HAL_NVIC_SetPendingIRQ"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006a8c": {
            "entrypoint": "0x08006a8c",
            "current_name": "set_ir_qn_priority_bit_08006a8c",
            "code": "\nvoid setIRQnPriorityBit_08006a8c(interruptNumber_Type interruptNumber)\n\n{\n  interruptNumber_Type localInterruptNumber;\n  \n  *(int *)((((uint)(int)interruptNumber >> 5) + 0x60) * 4 + -0x1fff1f00) = 1 << (interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006a8c": "set_ir_qn_priority_bit_08006a8c",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ac0": {
            "entrypoint": "0x08006ac0",
            "current_name": "check_irq_enabled_08006ac0",
            "code": "\nuint32_t checkIRQEnabled_08006ac0(interruptType_Type interruptType)\n\n{\n  interruptType_Type localInterruptType;\n  \n  return (uint)((*(uint *)((((uint)(int)interruptType >> 5) + 0x80) * 4 + -0x1fff1f00) & 1 << (interruptType & 0x1fU))\n               != 0);\n}\n\n",
            "renaming": {
                "FUN_08006ac0": "check_irq_enabled_08006ac0",
                "IRQn": "interruptType",
                "IRQn_local": "localInterruptType"
            },
            "calling": [
                "HAL_NVIC_GetActive"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b00": {
            "entrypoint": "0x08006b00",
            "current_name": "set_interrupt_priority_08006b00",
            "code": "\nvoid setInterruptPriority_08006b00(interruptNumber_Type interruptNumber,uint32_t priorityLevel)\n\n{\n  uint32_t localPriority;\n  interruptNumber_Type localInterruptNumber;\n  \n  if (interruptNumber < WWDG_interruptNumber) {\n    *(char *)(((byte)interruptNumber & 0xf) + 0xe000ed14) = (char)((priorityLevel & 0xff) << 4);\n  }\n  else {\n    *(char *)(interruptNumber + -0x1fff1c00) = (char)((priorityLevel & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006b00": "set_interrupt_priority_08006b00",
                "IRQn": "interruptNumber",
                "priority": "priorityLevel",
                "priority_local": "localPriority",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "SysTick_Config",
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006b54": {
            "entrypoint": "0x08006b54",
            "current_name": "get_priority_level_08006b54",
            "code": "\nuint32_t getPriorityLevel_08006b54(interrupt_Type interrupt)\n\n{\n  byte priority;\n  interrupt_Type localInterrupt;\n  \n  if (interrupt < WWDG_interrupt) {\n    priority = *(byte *)(((byte)interrupt & 0xf) + 0xe000ed14);\n  }\n  else {\n    priority = *(byte *)(interrupt + -0x1fff1c00);\n  }\n  return (uint)(priority >> 4);\n}\n\n",
            "renaming": {
                "FUN_08006b54": "get_priority_level_08006b54",
                "IRQn": "interrupt",
                "bVar1": "priority",
                "IRQn_local": "localInterrupt"
            },
            "calling": [
                "HAL_NVIC_GetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ba0": {
            "entrypoint": "0x08006ba0",
            "current_name": "calculate_priority_08006ba0",
            "code": "\nuint32_t calculatePriority_08006ba0(uint32_t group,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint bitMask1;\n  uint bitMask2;\n  uint32_t localSubPriority;\n  uint32_t localPreemptPriority;\n  uint32_t localPriorityGroup;\n  uint32_t subPriorityBits;\n  uint32_t preemptPriorityBits;\n  uint32_t priorityGroupTmp;\n  \n  bitMask1 = group & 7;\n  bitMask2 = 7 - bitMask1;\n  if (3 < bitMask2) {\n    bitMask2 = 4;\n  }\n  if (bitMask1 + 4 < 7) {\n    bitMask1 = 0;\n  }\n  else {\n    bitMask1 = bitMask1 - 3;\n  }\n  return subPriority & (1 << (bitMask1 & 0xff)) - 1U |\n         ((1 << (bitMask2 & 0xff)) - 1U & preemptPriority) << (bitMask1 & 0xff);\n}\n\n",
            "renaming": {
                "FUN_08006ba0": "calculate_priority_08006ba0",
                "PriorityGroup": "group",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "uVar1": "bitMask1",
                "uVar2": "bitMask2",
                "SubPriority_local": "localSubPriority",
                "PreemptPriority_local": "localPreemptPriority",
                "PriorityGroup_local": "localPriorityGroup",
                "SubPriorityBits": "subPriorityBits",
                "PreemptPriorityBits": "preemptPriorityBits",
                "PriorityGroupTmp": "priorityGroupTmp"
            },
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c04": {
            "entrypoint": "0x08006c04",
            "current_name": "calculate_priority_bits_08006c04",
            "code": "\nvoid calculatePriorityBits_08006c04(uint32_t inputPriority,uint32_t inputPriorityGroup,uint32_t *preemptPriorityResult,\n                 uint32_t *subPriorityResult)\n\n{\n  uint groupBits;\n  uint shiftBits;\n  uint32_t *subPriorityLocal;\n  uint32_t *preemptPriorityLocal;\n  uint32_t priorityGroupLocal;\n  uint32_t priorityLocal;\n  uint32_t subPriorityBits;\n  uint32_t preemptPriorityBits;\n  uint32_t priorityGroupTmp;\n  \n  groupBits = inputPriorityGroup & 7;\n  shiftBits = 7 - groupBits;\n  if (3 < shiftBits) {\n    shiftBits = 4;\n  }\n  if (groupBits + 4 < 7) {\n    groupBits = 0;\n  }\n  else {\n    groupBits = groupBits - 3;\n  }\n  *preemptPriorityResult = (1 << (shiftBits & 0xff)) - 1U & inputPriority >> (groupBits & 0xff);\n  *subPriorityResult = (1 << (groupBits & 0xff)) - 1U & inputPriority;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006c04": "calculate_priority_bits_08006c04",
                "Priority": "inputPriority",
                "PriorityGroup": "inputPriorityGroup",
                "pPreemptPriority": "preemptPriorityResult",
                "pSubPriority": "subPriorityResult",
                "uVar1": "groupBits",
                "uVar2": "shiftBits",
                "pSubPriority_local": "subPriorityLocal",
                "pPreemptPriority_local": "preemptPriorityLocal",
                "PriorityGroup_local": "priorityGroupLocal",
                "Priority_local": "priorityLocal",
                "SubPriorityBits": "subPriorityBits",
                "PreemptPriorityBits": "preemptPriorityBits",
                "PriorityGroupTmp": "priorityGroupTmp"
            },
            "calling": [
                "HAL_NVIC_GetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c70": {
            "entrypoint": "0x08006c70",
            "current_name": "data_synchronization_08006c70",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid data_synchronization_08006c70(void)\n\n{\n  sync_barrier(0xf);\n  sync_barrier(0xf);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08006c70": "data_synchronization_08006c70",
                "DataSynchronizationBarrier": "sync_barrier"
            },
            "calling": [
                "HAL_NVIC_SystemReset"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c9c": {
            "entrypoint": "0x08006c9c",
            "current_name": "check_tick_validity_08006c9c",
            "code": "\n\n\nuint32_t checkTickValidity_08006c9c(uint32_t inputTicks)\n\n{\n  bool isTickValid;\n  uint32_t localTicks;\n  \n  isTickValid = inputTicks - 1 < 0x1000000;\n  if (isTickValid) {\n    _DAT_e000e014 = inputTicks - 1;\n    NVIC_SetPriority(SysTick_IRQn,0xf);\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n  }\n  return (uint)!isTickValid;\n}\n\n",
            "renaming": {
                "FUN_08006c9c": "check_tick_validity_08006c9c",
                "ticks": "inputTicks",
                "bVar1": "isTickValid",
                "ticks_local": "localTicks"
            },
            "calling": [
                "HAL_SYSTICK_Config"
            ],
            "called": [
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ce0": {
            "entrypoint": "0x08006ce0",
            "current_name": "set_priority_group_08006ce0",
            "code": "\nvoid setPriorityGroup_08006ce0(uint32_t priorityGroup)\n\n{\n  uint32_t localPriorityGroup;\n  \n  NVIC_SetpriorityGrouping(priorityGroup);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006ce0": "set_priority_group_08006ce0",
                "PriorityGroup": "priorityGroup",
                "PriorityGroup_local": "localPriorityGroup"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [
                "NVIC_SetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006cf6": {
            "entrypoint": "0x08006cf6",
            "current_name": "set_irq_priority_08006cf6",
            "code": "\nvoid setIRQPriority_08006cf6(interruptNumber_Type interruptNumber,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint32_t priorityGroup;\n  uint32_t localSubPriority;\n  uint32_t localPreemptPriority;\n  interruptNumber_Type localInterruptNumber;\n  uint32_t encodedPriority;\n  \n  priorityGroup = NVIC_GetPriorityGrouping();\n  priorityGroup = NVIC_EncodePriority(priorityGroup,preemptPriority,subPriority);\n  NVIC_SetPriority(interruptNumber,priorityGroup);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006cf6": "set_irq_priority_08006cf6",
                "IRQn": "interruptNumber",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "uVar1": "priorityGroup",
                "SubPriority_local": "localSubPriority",
                "PreemptPriority_local": "localPreemptPriority",
                "IRQn_local": "localInterruptNumber",
                "prioritygroup": "encodedPriority"
            },
            "calling": [
                "enable_tim_interrupt"
            ],
            "called": [
                "NVIC_EncodePriority",
                "NVIC_SetPriority",
                "NVIC_GetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d2e": {
            "entrypoint": "0x08006d2e",
            "current_name": "enable_interrupt_08006d2e",
            "code": "\nvoid enableInterrupt_08006d2e(interrupt_Type interrupt)\n\n{\n  interrupt_Type localInterrupt;\n  \n  NVIC_EnableIRQ(interrupt);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006d2e": "enable_interrupt_08006d2e",
                "IRQn": "interrupt",
                "IRQn_local": "localInterrupt"
            },
            "calling": [],
            "called": [
                "NVIC_EnableIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d4a": {
            "entrypoint": "0x08006d4a",
            "current_name": "disable_irq_08006d4a",
            "code": "\nvoid disableIRQ_08006d4a(interruptNumber_Type interruptNumber)\n\n{\n  interruptNumber_Type localInterruptNumber;\n  \n  NVIC_DisableIRQ(interruptNumber);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006d4a": "disable_irq_08006d4a",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [],
            "called": [
                "NVIC_DisableIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d66": {
            "entrypoint": "0x08006d66",
            "current_name": "reset_08006d66",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_08006d66(void)\n\n{\n  reset_08006d66_system();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006d66": "reset_08006d66",
                "NVIC_SystemReset": "reset_system"
            },
            "calling": [],
            "called": [
                "NVIC_SystemReset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d72": {
            "entrypoint": "0x08006d72",
            "current_name": "configure_sys_tick_08006d72",
            "code": "\nuint32_t configureSysTick_08006d72(uint32_t ticksNumber)\n\n{\n  uint32_t configSuccess;\n  uint32_t localTicksNumber;\n  \n  configSuccess = SysTick_Config(ticksNumber);\n  return configSuccess;\n}\n\n",
            "renaming": {
                "FUN_08006d72": "configure_sys_tick_08006d72",
                "TicksNumb": "ticksNumber",
                "uVar1": "configSuccess",
                "TicksNumb_local": "localTicksNumber"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [
                "SysTick_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d8a": {
            "entrypoint": "0x08006d8a",
            "current_name": "get_priority_grouping_08006d8a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getPriorityGrouping_08006d8a(void)\n\n{\n  uint32_t priorityGrouping;\n  \n  priorityGrouping = NVIC_GetPriorityGrouping();\n  return priorityGrouping;\n}\n\n",
            "renaming": {
                "FUN_08006d8a": "get_priority_grouping_08006d8a",
                "uVar1": "priorityGrouping"
            },
            "calling": [],
            "called": [
                "NVIC_GetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d98": {
            "entrypoint": "0x08006d98",
            "current_name": "decode_priority_08006d98",
            "code": "\nvoid decodePriority_08006d98(interruptType_Type interruptType,uint32_t priorityGroup,uint32_t *preemptPriorityPointer,\n                 uint32_t *subPriorityPointer)\n\n{\n  uint32_t priority;\n  uint32_t *localSubPriorityPointer;\n  uint32_t *localPreemptPriorityPointer;\n  uint32_t localPriorityGroup;\n  interruptType_Type localInterruptType;\n  \n  priority = NVIC_Getpriority(interruptType);\n  NVIC_Decodepriority(priority,priorityGroup,preemptPriorityPointer,subPriorityPointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006d98": "decode_priority_08006d98",
                "IRQn": "interruptType",
                "PriorityGroup": "priorityGroup",
                "pPreemptPriority": "preemptPriorityPointer",
                "pSubPriority": "subPriorityPointer",
                "Priority": "priority",
                "pSubPriority_local": "localSubPriorityPointer",
                "pPreemptPriority_local": "localPreemptPriorityPointer",
                "PriorityGroup_local": "localPriorityGroup",
                "IRQn_local": "localInterruptType"
            },
            "calling": [],
            "called": [
                "NVIC_GetPriority",
                "NVIC_DecodePriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006dc4": {
            "entrypoint": "0x08006dc4",
            "current_name": "set_pending_irq_08006dc4",
            "code": "\nvoid setPendingIRQ_08006dc4(interrupt_Type interrupt)\n\n{\n  interrupt_Type interrupt_local;\n  \n  NVIC_SetPendingIRQ(interrupt);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006dc4": "set_pending_irq_08006dc4",
                "IRQn": "interrupt"
            },
            "calling": [],
            "called": [
                "NVIC_SetPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006de0": {
            "entrypoint": "0x08006de0",
            "current_name": "get_pending_interrupt_08006de0",
            "code": "\nuint32_t getPendingInterrupt_08006de0(interruptNumber_Type interruptNumber)\n\n{\n  uint32_t pendingInterrupt;\n  interruptNumber_Type localInterruptNumber;\n  \n  pendingInterrupt = NVIC_GetPendingIRQ(interruptNumber);\n  return pendingInterrupt;\n}\n\n",
            "renaming": {
                "FUN_08006de0": "get_pending_interrupt_08006de0",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber",
                "uVar1": "pendingInterrupt"
            },
            "calling": [],
            "called": [
                "NVIC_GetPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006dfe": {
            "entrypoint": "0x08006dfe",
            "current_name": "clear_pending_irq_08006dfe",
            "code": "\nvoid clearPendingIRQ_08006dfe(interrupt_Type interrupt)\n\n{\n  interrupt_Type interrupt_local;\n  \n  NVIC_ClearPendingIRQ(interrupt);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006dfe": "clear_pending_irq_08006dfe",
                "IRQn": "interrupt",
                "IRQn_local": "interrupt_local"
            },
            "calling": [],
            "called": [
                "NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e1a": {
            "entrypoint": "0x08006e1a",
            "current_name": "get_active_interrupt_08006e1a",
            "code": "\nuint32_t getActiveInterrupt_08006e1a(interruptNumber_Type interruptNumber)\n\n{\n  uint32_t activeStatus;\n  interruptNumber_Type interruptNumberLocal;\n  \n  activeStatus = NVIC_GetActive(interruptNumber);\n  return activeStatus;\n}\n\n",
            "renaming": {
                "FUN_08006e1a": "get_active_interrupt_08006e1a",
                "IRQn": "interruptNumber",
                "IRQn_local": "interruptNumberLocal",
                "uVar1": "activeStatus"
            },
            "calling": [],
            "called": [
                "NVIC_GetActive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e38": {
            "entrypoint": "0x08006e38",
            "current_name": "set_clock_source_08006e38",
            "code": "\n\n\nvoid setClockSource_08006e38(uint32_t source)\n\n{\n  uint32_t localSource;\n  \n  if (source == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006e38": "set_clock_source_08006e38",
                "CLKSource": "source",
                "CLKSource_local": "localSource"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e70": {
            "entrypoint": "0x08006e70",
            "current_name": "handle_sys_tick_interrupt_08006e70",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickInterrupt_08006e70(void)\n\n{\n  performSystemTickCallback();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006e70": "handle_sys_tick_interrupt_08006e70",
                "HAL_SYSTICK_Callback": "performSystemTickCallback"
            },
            "calling": [],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e7c": {
            "entrypoint": "0x08006e7c",
            "current_name": "FUNC_08006e7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08006e7c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006e7c": "FUNC_08006e7c"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08006e88": {
            "entrypoint": "0x08006e88",
            "current_name": "configure_gpio_08006e88",
            "code": "\n\n\nvoid configureGPIO_08006e88(GPIO_TypeDef *gpioPort,gpioConfigTypeDef *gpioConfig)\n\n{\n  uint32_t alternate;\n  uint positionMask;\n  uint maskedPin;\n  int gpioIndex;\n  gpioConfigTypeDef *localGpioConfig;\n  GPIO_TypeDef *localGpioPort;\n  uint32_t temporary;\n  uint32_t currentIO;\n  uint32_t ioPosition;\n  uint32_t bitPosition;\n  \n  for (bitPosition = 0; bitPosition < 0x10; bitPosition = bitPosition + 1) {\n    positionMask = 1 << (bitPosition & 0xff);\n    maskedPin = gpioConfig->Pin & positionMask;\n    if (maskedPin == positionMask) {\n      if ((gpioConfig->Mode == 2) || (gpioConfig->Mode == 0x12)) {\n        alternate = gpioConfig->Alternate;\n        gpioPort->AFR[bitPosition >> 3] = gpioPort->AFR[bitPosition >> 3] & ~(0xf << ((bitPosition & 7) << 2));\n        gpioPort->AFR[bitPosition >> 3] = gpioPort->AFR[bitPosition >> 3] | alternate << ((bitPosition & 7) << 2);\n      }\n      gpioPort->MODER = gpioPort->MODER & ~(3 << ((bitPosition & 0x7f) << 1));\n      gpioPort->MODER = gpioPort->MODER | (gpioConfig->Mode & 3) << ((bitPosition & 0x7f) << 1);\n      if ((((gpioConfig->Mode == 1) || (gpioConfig->Mode == 2)) || (gpioConfig->Mode == 0x11)) ||\n         (gpioConfig->Mode == 0x12)) {\n        gpioPort->OSPEEDR = gpioPort->OSPEEDR & ~(3 << ((bitPosition & 0x7f) << 1));\n        gpioPort->OSPEEDR = gpioPort->OSPEEDR | gpioConfig->Speed << ((bitPosition & 0x7f) << 1);\n        gpioPort->OTYPER = gpioPort->OTYPER & ~(1 << (bitPosition & 0xff));\n        gpioPort->OTYPER = gpioPort->OTYPER | (gpioConfig->Mode >> 4 & 1) << (bitPosition & 0xff);\n      }\n      gpioPort->PUPDR = gpioPort->PUPDR & ~(3 << ((bitPosition & 0x7f) << 1));\n      gpioPort->PUPDR = gpioPort->PUPDR | gpioConfig->Pull << ((bitPosition & 0x7f) << 1);\n      if ((gpioConfig->Mode & 0x10000000) != 0) {\n        _DAT_40023844 = _DAT_40023844 | 0x4000;\n        *(uint *)(((bitPosition >> 2) + 2) * 4 + 0x40013800) =\n             ~(0xf << ((bitPosition & 3) << 2)) & *(uint *)(((bitPosition >> 2) + 2) * 4 + 0x40013800);\n        if (gpioPort == (GPIO_TypeDef *)0x40020000) {\n          gpioIndex = 0;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40020400) {\n          gpioIndex = 1;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40020800) {\n          gpioIndex = 2;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40020c00) {\n          gpioIndex = 3;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40021000) {\n          gpioIndex = 4;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40021400) {\n          gpioIndex = 5;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40021800) {\n          gpioIndex = 6;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40021c00) {\n          gpioIndex = 7;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40022000) {\n          gpioIndex = 8;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40022400) {\n          gpioIndex = 9;\n        }\n        else {\n          gpioIndex = 10;\n        }\n        *(uint *)(((bitPosition >> 2) + 2) * 4 + 0x40013800) =\n             gpioIndex << ((bitPosition & 3) << 2) | *(uint *)(((bitPosition >> 2) + 2) * 4 + 0x40013800);\n        _DAT_40013c00 = ~maskedPin & _DAT_40013c00;\n        _DAT_40013c04 = ~maskedPin & _DAT_40013c04;\n        if ((gpioConfig->Mode & 0x10000) != 0) {\n          _DAT_40013c00 = maskedPin | _DAT_40013c00;\n        }\n        if ((gpioConfig->Mode & 0x20000) != 0) {\n          _DAT_40013c04 = maskedPin | _DAT_40013c04;\n        }\n        _DAT_40013c08 = ~maskedPin & _DAT_40013c08;\n        _DAT_40013c0c = ~maskedPin & _DAT_40013c0c;\n        if ((gpioConfig->Mode & 0x100000) != 0) {\n          _DAT_40013c08 = maskedPin | _DAT_40013c08;\n        }\n        if ((gpioConfig->Mode & 0x200000) != 0) {\n          _DAT_40013c0c = maskedPin | _DAT_40013c0c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006e88": "configure_gpio_08006e88",
                "GPIOx": "gpioPort",
                "GPIO_Init": "gpioConfig",
                "uVar1": "alternate",
                "uVar2": "positionMask",
                "uVar3": "maskedPin",
                "iVar4": "gpioIndex",
                "GPIO_Init_local": "localGpioConfig",
                "GPIOx_local": "localGpioPort",
                "temp": "temporary",
                "iocurrent": "currentIO",
                "ioposition": "ioPosition",
                "position": "bitPosition"
            },
            "calling": [
                "gpio_init",
                "HAL_RCC_MCOConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080071d0": {
            "entrypoint": "0x080071d0",
            "current_name": "configure_gpio_080071d0",
            "code": "\n\n\nvoid configureGPIO_080071d0(GPIO_TypeDef *gpioPort,uint32_t pinNumber)\n\n{\n  uint bitMask;\n  uint pinMask;\n  uint32_t localPinNumber;\n  GPIO_TypeDef *localGpioPort;\n  uint32_t temp;\n  uint32_t ioCurrent;\n  uint32_t ioPosition;\n  uint32_t currentPosition;\n  \n  for (currentPosition = 0; currentPosition < 0x10; currentPosition = currentPosition + 1) {\n    bitMask = 1 << (currentPosition & 0xff);\n    pinMask = bitMask & pinNumber;\n    if (pinMask == bitMask) {\n      gpioPort->MODER = gpioPort->MODER & ~(3 << ((currentPosition & 0x7f) << 1));\n      gpioPort->AFR[currentPosition >> 3] = gpioPort->AFR[currentPosition >> 3] & ~(0xf << ((currentPosition & 7) << 2));\n      gpioPort->OSPEEDR = gpioPort->OSPEEDR & ~(3 << ((currentPosition & 0x7f) << 1));\n      gpioPort->OTYPER = gpioPort->OTYPER & ~(1 << (currentPosition & 0xff));\n      gpioPort->PUPDR = gpioPort->PUPDR & ~(3 << ((currentPosition & 0x7f) << 1));\n      *(uint *)(((currentPosition >> 2) + 2) * 4 + 0x40013800) =\n           ~(0xf << ((currentPosition & 3) << 2)) & *(uint *)(((currentPosition >> 2) + 2) * 4 + 0x40013800);\n      _DAT_40013c00 = ~pinMask & _DAT_40013c00;\n      _DAT_40013c04 = ~pinMask & _DAT_40013c04;\n      _DAT_40013c08 = ~pinMask & _DAT_40013c08;\n      _DAT_40013c0c = ~pinMask & _DAT_40013c0c;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080071d0": "configure_gpio_080071d0",
                "GPIOx": "gpioPort",
                "GPIO_Pin": "pinNumber",
                "uVar1": "bitMask",
                "uVar2": "pinMask",
                "GPIO_Pin_local": "localPinNumber",
                "GPIOx_local": "localGpioPort",
                "tmp": "temp",
                "iocurrent": "ioCurrent",
                "ioposition": "ioPosition",
                "position": "currentPosition"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007310": {
            "entrypoint": "0x08007310",
            "current_name": "is_gpio_pin_set_08007310",
            "code": "\npin_numberState is_GPIO_Pin_Set_08007310(GPIO_TypeDef *GPIO_port,uint16_t pin_number)\n\n{\n  uint16_t local_pin_number;\n  GPIO_TypeDef *local_GPIO_port;\n  pin_numberState pin_status;\n  \n  return ((uint)pin_number & GPIO_port->IDR) != 0;\n}\n\n",
            "renaming": {
                "FUN_08007310": "is_gpio_pin_set_08007310",
                "GPIOx": "GPIO_port",
                "GPIO_Pin": "pin_number",
                "GPIO_Pin_local": "local_pin_number",
                "GPIOx_local": "local_GPIO_port",
                "bitstatus": "pin_status"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800733e": {
            "entrypoint": "0x0800733e",
            "current_name": "set_pin_state_0800733e",
            "code": "\nvoid setPinState_0800733e(GPIO_TypeDef *port,uint16_t pin,pinState state)\n\n{\n  pinState state_local;\n  uint16_t pin_local;\n  GPIO_TypeDef *port_local;\n  \n  if (state == GPIO_PIN_RESET) {\n    port->BSRRH = pin;\n  }\n  else {\n    port->BSRRL = pin;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800733e": "set_pin_state_0800733e",
                "GPIOx": "port",
                "GPIO_Pin": "pin",
                "PinState": "state",
                "PinState_local": "state_local",
                "GPIO_Pin_local": "pin_local",
                "GPIOx_local": "port_local"
            },
            "calling": [
                "gpio_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800736c": {
            "entrypoint": "0x0800736c",
            "current_name": "toggle_pin_state_0800736c",
            "code": "\nvoid togglePinState_0800736c(GPIO_TypeDef *port,uint16_t pin)\n\n{\n  uint16_t local_pin;\n  GPIO_TypeDef *local_port;\n  \n  port->ODR = port->ODR ^ (uint)pin;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800736c": "toggle_pin_state_0800736c",
                "GPIOx": "port",
                "GPIO_Pin": "pin",
                "GPIO_Pin_local": "local_pin",
                "GPIOx_local": "local_port"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800738e": {
            "entrypoint": "0x0800738e",
            "current_name": "handle_gpio_pin_0800738e",
            "code": "\n\n\nvoid handle_GPIO_Pin_0800738e(uint16_t gpioPin)\n\n{\n  uint16_t localPin;\n  \n  if ((gpioPin & _DAT_40013c14) != 0) {\n    _DAT_40013c14 = (uint)gpioPin;\n    HAL_GPIO_EXTI_Callback(gpioPin);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800738e": "handle_gpio_pin_0800738e",
                "GPIO_Pin": "gpioPin",
                "GPIO_Pin_local": "localPin"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080073c0": {
            "entrypoint": "0x080073c0",
            "current_name": "initialize_gpio_080073c0",
            "code": "\nvoid initializeGPIO_080073c0(uint16_t pinNumber)\n\n{\n  uint16_t localPin;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_080073c0": "initialize_gpio_080073c0",
                "GPIO_Pin": "pinNumber",
                "GPIO_Pin_local": "localPin"
            },
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080073d4": {
            "entrypoint": "0x080073d4",
            "current_name": "set_bit_080073d4",
            "code": "\nvoid setBit_080073d4(inumbert number)\n\n{\n  inumbert localNumber;\n  \n  *(short *)((number >> 4) * 0x400 + 0x4002001a) = (short)(1 << (number & 0xfU));\n  returnumber;\n}\n\n",
            "renaming": {
                "FUN_080073d4": "set_bit_080073d4",
                "n": "number",
                "n_local": "localNumber"
            },
            "calling": [
                "debounce_off_handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007402": {
            "entrypoint": "0x08007402",
            "current_name": "set_bit_in_memory_08007402",
            "code": "\nvoid setBitInMemory_08007402(iinputValuet inputValue)\n\n{\n  iinputValuet localValue;\n  \n  *(short *)((inputValue >> 4) * 0x400 + 0x40020018) = (short)(1 << (inputValue & 0xfU));\n  returinputValue;\n}\n\n",
            "renaming": {
                "FUN_08007402": "set_bit_in_memory_08007402",
                "n": "inputValue",
                "n_local": "localValue"
            },
            "calling": [
                "debounce_on_handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007430": {
            "entrypoint": "0x08007430",
            "current_name": "infinite_loop_08007430",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08007430(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08007430": "infinite_loop_08007430"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007436": {
            "entrypoint": "0x08007436",
            "current_name": "initialize_system_clock_08007436",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystemClock_08007436(void)\n\n{\n  HAL_StatusTypeDef status;\n  RCC_OscInitTypeDef oscInit;\n  RCC_ClkInitTypeDef clkInit;\n  \n  _DAT_40023840 = _DAT_40023840 | 0x10000000;\n  _DAT_40007000 = _DAT_40007000 | 0xc000;\n  oscInit.OscillatorType = 1;\n  oscInit.HSEState = 1;\n  oscInit.PLL.PLLState = 2;\n  oscInit.PLL.PLLSource = 0x400000;\n  oscInit.PLL.PLLM = 8;\n  oscInit.PLL.PLLN = 0x150;\n  oscInit.PLL.PLLP = 2;\n  oscInit.PLL.PLLQ = 7;\n  status = HAL_RCC_OscConfig(&oscInit);\n  if (status != HAL_OK) {\n    Error_Handler();\n  }\n  clkInit.ClockType = 0xf;\n  clkInit.SYSCLKSource = 2;\n  clkInit.AHBCLKDivider = 0;\n  clkInit.APB1CLKDivider = 0x1400;\n  clkInit.APB2CLKDivider = 0x1000;\n  status = HAL_RCC_ClockConfig(&clkInit,5);\n  if (status != HAL_OK) {\n    Error_Handler();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007436": "initialize_system_clock_08007436",
                "HVar1": "status",
                "RCC_OscInitStruct": "oscInit",
                "RCC_ClkInitStruct": "clkInit"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_RCC_ClockConfig",
                "Error_Handler",
                "HAL_RCC_OscConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080074c8": {
            "entrypoint": "0x080074c8",
            "current_name": "update_gpio_080074c8",
            "code": "\nvoid updateGPIO_080074c8(uint32_t inputBits)\n\n{\n  uint32_t localBits;\n  \n  if ((inputBits & 1) != 0) {\n    gpio_set(0x3e);\n  }\n  if ((limits_enabled != 0) && ((inputBits & 0x1e) != 0)) {\n    limits_isr();\n  }\n  if ((buttons_enabled != 0) && ((inputBits & 0x80) != 0)) {\n    buttons_isr(inputBits);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080074c8": "update_gpio_080074c8",
                "bits": "inputBits",
                "bits_local": "localBits"
            },
            "calling": [
                "debounce_isr"
            ],
            "called": [
                "limits_isr",
                "gpio_set",
                "buttons_isr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007520": {
            "entrypoint": "0x08007520",
            "current_name": "clear_gpio_bit_08007520",
            "code": "\nvoid clearGpioBit_08007520(uint32_t bitsToClear)\n\n{\n  uint32_t localBits;\n  \n  if ((bitsToClear & 1) != 0) {\n    gpio_clr(0x3e);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007520": "clear_gpio_bit_08007520",
                "bits": "bitsToClear",
                "bits_local": "localBits"
            },
            "calling": [
                "debounce_isr"
            ],
            "called": [
                "gpio_clr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007540": {
            "entrypoint": "0x08007540",
            "current_name": "initialize_machine_08007540",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint initializeMachine_08007540(void)\n\n{\n  initializeHardwareAbstractionLayer();\n  configureSystemClock();\n  initializeGPIO();\n  initializeTimers();\n  initializeDebounce();\n  initializeUSART();\n  startForkServer(0);\n  executeMainProgram();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08007540": "initialize_machine_08007540",
                "HAL_Init": "initializeHardwareAbstractionLayer",
                "SystemClock_Config": "configureSystemClock",
                "gpio_init": "initializeGPIO",
                "timers_init": "initializeTimers",
                "debounce_init": "initializeDebounce",
                "usart_init": "initializeUSART",
                "startForkserver": "startForkServer",
                "grbl_main": "executeMainProgram"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "SystemClock_Config",
                "gpio_init",
                "grbl_main",
                "usart_init",
                "HAL_Init",
                "debounce_init",
                "timers_init",
                "startForkserver"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800756c": {
            "entrypoint": "0x0800756c",
            "current_name": "initialize_hardware_0800756c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeHardware_0800756c(void)\n\n{\n  _DAT_40023808 = 0;\n  _DAT_40023804 = 0x24003010;\n  _DAT_40023800 = _DAT_40023800 & 0xfef2ffff | 1;\n  _DAT_4002380c = 0;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800756c": "initialize_hardware_0800756c"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080075c8": {
            "entrypoint": "0x080075c8",
            "current_name": "calculate_system_core_clock_080075c8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid calculateSystemCoreClock_080075c8(void)\n\n{\n  uint uVar1;\n  uint32_t pllM;\n  uint32_t pllSource;\n  uint32_t pllP;\n  uint32_t temporary;\n  uint32_t pllVCO;\n  \n  uVar1 = _DAT_40023808 & 0xc;\n  if (uVar1 == 8) {\n    if ((_DAT_40023804 >> 0x16 & 1) == 0) {\n      pllVCO = (_DAT_40023804 >> 6 & 0x1ff) * (16000000 / (_DAT_40023804 & 0x3f));\n    }\n    else {\n      pllVCO = (_DAT_40023804 >> 6 & 0x1ff) * (8000000 / (_DAT_40023804 & 0x3f));\n    }\n    coreClock = pllVCO / (((_DAT_40023804 >> 0x10 & 3) + 1) * 2);\n    goto LAB_0800768a;\n  }\n  if (uVar1 < 9) {\n    if (uVar1 == 0) {\n      coreClock = 16000000;\n      goto LAB_0800768a;\n    }\n    if (uVar1 == 4) {\n      coreClock = 8000000;\n      goto LAB_0800768a;\n    }\n  }\n  coreClock = 16000000;\nLAB_0800768a:\n  coreClock = coreClock >> ahbPrescalerTable[_DAT_40023808 >> 4 & 0xf];\n  return;\n}\n\n",
            "renaming": {
                "FUN_080075c8": "calculate_system_core_clock_080075c8",
                "pllm": "pllM",
                "pllsource": "pllSource",
                "pllp": "pllP",
                "tmp": "temporary",
                "pllvco": "pllVCO",
                "SystemCoreClock": "coreClock",
                "AHBPrescTable": "ahbPrescalerTable"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080076c8": {
            "entrypoint": "0x080076c8",
            "current_name": "update_bit_value_080076c8",
            "code": "\nvoid updateBitValue_080076c8(ivaluet value)\n\n{\n  ivaluet localValue;\n  \n  *(uivaluet *)((value >> 4) * 0x400 + 0x40020014) =\n       *(uivaluet *)((value >> 4) * 0x400 + 0x40020014) ^ 1 << (value & 0xfU);\n  returvalue;\n}\n\n",
            "renaming": {
                "FUN_080076c8": "update_bit_value_080076c8",
                "n": "value",
                "n_local": "localValue"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800770e": {
            "entrypoint": "0x0800770e",
            "current_name": "FUNC_0800770e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800770e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800770e": "FUNC_0800770e"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800771a": {
            "entrypoint": "0x0800771a",
            "current_name": "infinite_loop_0800771a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_0800771a(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_0800771a": "infinite_loop_0800771a"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007720": {
            "entrypoint": "0x08007720",
            "current_name": "infinite_loop_08007720",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08007720(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08007720": "infinite_loop_08007720"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007726": {
            "entrypoint": "0x08007726",
            "current_name": "infinite_loop_08007726",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08007726(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08007726": "infinite_loop_08007726"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800772c": {
            "entrypoint": "0x0800772c",
            "current_name": "infinite_loop_0800772c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_0800772c(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_0800772c": "infinite_loop_0800772c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007732": {
            "entrypoint": "0x08007732",
            "current_name": "FUNC_08007732",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08007732(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007732": "FUNC_08007732"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800773e": {
            "entrypoint": "0x0800773e",
            "current_name": "FUNC_0800773e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800773e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800773e": "FUNC_0800773e"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800774a": {
            "entrypoint": "0x0800774a",
            "current_name": "FUNC_0800774a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800774a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800774a": "FUNC_0800774a"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08007756": {
            "entrypoint": "0x08007756",
            "current_name": "update_tick_and_debounce_08007756",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid update_tick_and_debounce_08007756(void)\n\n{\n  uint32_t current_tick;\n  uint32_t tick_count;\n  \n  current_tick = HAL_GetTick();\n  if ((current_tick & 0x1ff) == 0) {\n    gpio_toggle(0x3c);\n  }\n  if ((current_tick & 0xf) == 0) {\n    debounce_isr();\n  }\n  HAL_IncTick();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007756": "update_tick_and_debounce_08007756",
                "uVar1": "current_tick",
                "ticks": "tick_count"
            },
            "calling": [],
            "called": [
                "HAL_GetTick",
                "debounce_isr",
                "gpio_toggle",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800778c": {
            "entrypoint": "0x0800778c",
            "current_name": "initialize_gpio_0800778c",
            "code": "\n\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd initializeGPIO_0800778c(voindexd)\n\n{\n  GPIO_INFO *currentInfo;\n  GPIOConfig gpioConfig;\n  GPIO_INFO *currentGPIO;\n  indexnt index;\n  \n  for (index = 0; (uindexnt)index < 0x11; index = index + 1) {\n    currentInfo = GPIOinfo + index;\n    _DAT_40023830 = _DAT_40023830 | 1 << (currentInfo->num >> 4 & 0xff);\n    pinConfig = 1 << (currentInfo->num & 0xf);\n    mode = GPIOinfo[index].mode;\n    pull = GPIOinfo[index].pull;\n    speed = GPIOinfo[index].speed;\n    alternate = GPIOinfo[index].alt;\n    initializePin((GPIO_TypeDef *)(((currentInfo->num >> 4) + 0x100080) * 0x400),&gpioConfig);\n    indexf (-1 < GPIOinfo[index].indexnindext) {\n      writePin((GPIO_TypeDef *)(((currentInfo->num >> 4) + 0x100080) * 0x400),\n                        (uindexnt16_t)(1 << (currentInfo->num & 0xf)),(GPIO_PindexnState)GPIOinfo[index].indexnindext);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800778c": "initialize_gpio_0800778c",
                "GPIO_InitStruct": "gpioConfig",
                "gpio": "currentGPIO",
                "i": "index",
                "pGVar1": "currentInfo",
                "GPIO_InitTypeDef": "GPIOConfig",
                "GPIO_InitStruct.Pin": "pinConfig",
                "GPIO_InitStruct.Mode": "mode",
                "GPIO_InitStruct.Pull": "pull",
                "GPIO_InitStruct.Speed": "speed",
                "GPIO_InitStruct.Alternate": "alternate",
                "HAL_GPIO_Init": "initializePin",
                "HAL_GPIO_WritePin": "writePin",
                "gpio_info": "GPIOinfo"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_GPIO_Init",
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007854": {
            "entrypoint": "0x08007854",
            "current_name": "retrieve_bit_at_index_08007854",
            "code": "\niindext retrieveBitAtIndex_08007854(iindext index)\n\n{\n  iindext bitValue;\n  \n  returindex *(uiindext *)((index >> 4) * 0x400 + 0x40020010) >> (index & 0xfU) & 1;\n}\n\n",
            "renaming": {
                "FUN_08007854": "retrieve_bit_at_index_08007854",
                "n": "index",
                "n_local": "bitValue"
            },
            "calling": [
                "debounce_input"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007884": {
            "entrypoint": "0x08007884",
            "current_name": "get_gpio_value_08007884",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_gpio_value_08007884(void)\n\n{\n  int gpio_0x36_value;\n  int gpio_0x37_value;\n  int gpio_0x38_value;\n  int gpio_0x39_value;\n  int gpio_0xf_value;\n  uint gpio_0_value;\n  \n  gpio_0x36_value = gpio_rd(0x36);\n  gpio_0x37_value = gpio_rd(0x37);\n  gpio_0x38_value = gpio_rd(0x38);\n  gpio_0x39_value = gpio_rd(0x39);\n  gpio_0xf_value = gpio_rd(0xf);\n  gpio_0_value = gpio_rd(0);\n  return gpio_0_value | gpio_0x36_value << 4 | gpio_0x37_value << 3 | gpio_0x38_value << 2 | gpio_0x39_value << 1 | gpio_0xf_value << 7;\n}\n\n",
            "renaming": {
                "FUN_08007884": "get_gpio_value_08007884",
                "iVar1": "gpio_0x36_value",
                "iVar2": "gpio_0x37_value",
                "iVar3": "gpio_0x38_value",
                "iVar4": "gpio_0x39_value",
                "iVar5": "gpio_0xf_value",
                "uVar6": "gpio_0_value"
            },
            "calling": [
                "debounce_isr"
            ],
            "called": [
                "gpio_rd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080078d0": {
            "entrypoint": "0x080078d0",
            "current_name": "update_bits_080078d0",
            "code": "\nvoid updateBits_080078d0(uint32_t numBits)\n\n{\n  uint uVar1;\n  int value1;\n  undefined4 value2;\n  undefined4 value3;\n  uint value4;\n  int result;\n  int address;\n  char isNegative;\n  undefined isCarry;\n  char isOverflow;\n  undefined4 controlRegister;\n  uint32_t localBits;\n  \n  if (isNegative != isOverflow) {\n    result = value1 + numBits * 0x200;\n  }\n  if ((bool)isOverflow) {\n    uVar1 = numBits * 0x40000000;\n    isCarry = value4 <= uVar1;\n    isOverflow = SBORROW4(uVar1,value4);\n    isNegative = (int)(uVar1 - value4) < 0;\n  }\n  if (!(bool)isCarry) {\n    *(int *)(address + numBits * -0x40000000) = result;\n  }\n  if (isNegative == isOverflow) {\n    software_interrupt(0xb083);\n  }\n  else {\n    coprocessor_store(6,controlRegister,numBits);\n    *(undefined4 *)numBits = value2;\n    software_interrupt(0x6078);\n  }\n  if ((bool)isNegative) {\n    registerPtr = (BADSPACEBASE *)(&stack0x00000000 + address * 0x4000);\n  }\n  *(undefined4 *)((int)registerPtr + -4) = value3;\n  *(undefined4 *)((int)registerPtr + -0xc) = 0;\n  *(undefined4 *)((int)registerPtr + -0x10) = 0;\n  while (*(int *)((int)registerPtr + -0x10) < 4) {\n    *(uint32_t *)((int)registerPtr + -0xc) =\n         debounce.sample[*(int *)((int)registerPtr + -0x10)] |\n         *(uint *)((int)registerPtr + -0xc);\n    *(int *)((int)registerPtr + -0x10) = *(int *)((int)registerPtr + -0x10) + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080078d0": "update_bits_080078d0",
                "bits": "numBits",
                "in_r3": "value1",
                "unaff_r4": "value2",
                "unaff_r7": "value3",
                "unaff_r8": "value4",
                "unaff_r11": "result",
                "in_r12": "address",
                "in_NG": "isNegative",
                "in_CY": "isCarry",
                "in_OV": "isOverflow",
                "in_cr4": "controlRegister",
                "bits_local": "localBits",
                "register0x00000054": "registerPtr"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080078e2": {
            "entrypoint": "0x080078e2",
            "current_name": "store_bits_080078e2",
            "code": "\nvoid storeBits_080078e2(uint32_t inputBits)\n\n{\n  uint multipliedBits;\n  int offset;\n  undefined4 returnValue;\n  uint comparisonValue;\n  int modifiedOffset;\n  int baseAddress;\n  char negativeFlag;\n  undefined carryFlag;\n  char overflowFlag;\n  undefined4 coprocessorData;\n  uint32_t localBits;\n  \n  if (negativeFlag != overflowFlag) {\n    modifiedOffset = offset + inputBits * 0x200;\n  }\n  if ((bool)overflowFlag) {\n    multipliedBits = inputBits * 0x40000000;\n    carryFlag = comparisonValue <= multipliedBits;\n    overflowFlag = SBORROW4(multipliedBits,comparisonValue);\n    negativeFlag = (int)(multipliedBits - comparisonValue) < 0;\n  }\n  if (!(bool)carryFlag) {\n    *(int *)(baseAddress + inputBits * -0x40000000) = modifiedOffset;\n  }\n  if (negativeFlag != overflowFlag) {\n    coprocessor_store(6,coprocessorData,inputBits);\n    *(undefined4 *)inputBits = returnValue;\n  }\n  for (localBits = 0; (int)localBits < 4; localBits = localBits + 1) {\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080078e2": "store_bits_080078e2",
                "bits": "inputBits",
                "uVar1": "multipliedBits",
                "in_r3": "offset",
                "unaff_r4": "returnValue",
                "unaff_r8": "comparisonValue",
                "unaff_r11": "modifiedOffset",
                "in_r12": "baseAddress",
                "in_NG": "negativeFlag",
                "in_CY": "carryFlag",
                "in_OV": "overflowFlag",
                "in_cr4": "coprocessorData",
                "bits_local": "localBits"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080078f4": {
            "entrypoint": "0x080078f4",
            "current_name": "calculate_state_080078f4",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nuindexnt32_t calculateState_080078f4(voindexd)\n\n{\n  indexnt index;\n  uindexnt32_t state;\n  \n  state = 0;\n  for (index = 0; index < 4; index = index + 1) {\n    state = debounce.sample[index] | state;\n  }\n  return state;\n}\n\n",
            "renaming": {
                "FUN_080078f4": "calculate_state_080078f4",
                "i": "index"
            },
            "calling": [
                "debounce_isr",
                "homing_cycle"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007930": {
            "entrypoint": "0x08007930",
            "current_name": "debounce_handler_08007930",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid debounce_handler_08007930(void)\n\n{\n  int index;\n  uint32_t current_state;\n  uint32_t new_state;\n  uint changed_bits;\n  uint32_t bits_turned_off;\n  uint32_t bits_turned_on;\n  uint32_t debounce_state;\n  DEBOUNCE_CTRL *db;\n  \n  index = debounce.idx;\n  current_state = debounce.debounce_state;\n  if (debounce_ready != 0) {\n    current_state = debounce_input();\n    debounce.sample[index] = current_state;\n    if (debounce.idx == 3) {\n      debounce.idx = 0;\n    }\n    else {\n      debounce.idx = debounce.idx + 1;\n    }\n    new_state = debounce_rd();\n    current_state = debounce.debounce_state;\n    if (new_state != debounce.debounce_state) {\n      changed_bits = ~new_state & debounce.debounce_state;\n      if ((~debounce.debounce_state & new_state) != 0) {\n        debounce_on_handler(~debounce.debounce_state & new_state);\n      }\n      current_state = new_state;\n      if (changed_bits != 0) {\n        debounce_off_handler(changed_bits);\n      }\n    }\n  }\n  debounce.debounce_state = current_state;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007930": "debounce_handler_08007930",
                "iVar1": "index",
                "uVar2": "current_state",
                "uVar3": "new_state",
                "bits": "changed_bits",
                "off_bits": "bits_turned_off",
                "on_bits": "bits_turned_on",
                "state": "debounce_state"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "debounce_input",
                "debounce_off_handler",
                "debounce_on_handler",
                "debounce_rd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080079c0": {
            "entrypoint": "0x080079c0",
            "current_name": "initialize_debounce_080079c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeDebounce_080079c0(void)\n\n{\n  memset(&debounceData,0,0x18);\n  isDebounceReady = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080079c0": "initialize_debounce_080079c0",
                "debounce": "debounceData",
                "debounce_ready": "isDebounceReady"
            },
            "calling": [
                "main"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080079e0": {
            "entrypoint": "0x080079e0",
            "current_name": "set_interrupt_priority_080079e0",
            "code": "\nvoid setInterruptPriority_080079e0(interruptNumber_Type interruptNumber)\n\n{\n  interruptNumber_Type localInterruptNumber;\n  \n  *(int *)(((uint)(int)interruptNumber >> 5) * 4 + -0x1fff1f00) = 1 << (interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080079e0": "set_interrupt_priority_080079e0",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "enable_tim_interrupt"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007a10": {
            "entrypoint": "0x08007a10",
            "current_name": "set_tim_type_def_08007a10",
            "code": "\n\n\nvoid set_TIM_TypeDef_08007a10(TIM_TypeDef *input_TIM_TypeDef)\n\n{\n  TIM_TypeDef *local_TIM_TypeDef;\n  \n  if (input_TIM_TypeDef == (TIM_TypeDef *)&DAT_40000000) {\n    _DAT_40023840 = _DAT_40023840 | 1;\n  }\n  else if (input_TIM_TypeDef == (TIM_TypeDef *)0x40000400) {\n    _DAT_40023840 = _DAT_40023840 | 2;\n  }\n  else if (input_TIM_TypeDef == (TIM_TypeDef *)&DAT_40000800) {\n    _DAT_40023840 = _DAT_40023840 | 4;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007a10": "set_tim_type_def_08007a10",
                "tim": "input_TIM_TypeDef",
                "tim_local": "local_TIM_TypeDef"
            },
            "calling": [
                "step_timer_init",
                "g540_timer_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007a70": {
            "entrypoint": "0x08007a70",
            "current_name": "configure_timer_interrupt_08007a70",
            "code": "\nvoid configureTimerInterrupt_08007a70(TIM_TypeDef *timer,uint32_t priority,uint32_t subpriority)\n\n{\n  uint32_t localSub;\n  uint32_t localPre;\n  TIM_TypeDef *localTimer;\n  uint32_t timerIRQ;\n  \n  if (timer == (TIM_TypeDef *)&DAT_40000000) {\n    timerIRQ._0_1_ = TIM2_IRQn;\n  }\n  else if (timer == (TIM_TypeDef *)0x40000400) {\n    timerIRQ._0_1_ = TIM3_IRQn;\n  }\n  else {\n    if (timer != (TIM_TypeDef *)&DAT_40000800) {\n      return;\n    }\n    timerIRQ._0_1_ = TIM4_IRQn;\n  }\n  HAL_NVIC_SetPriority((IRQn_Type)timerIRQ,priority,subpriority);\n  NVIC_EnableIRQ((IRQn_Type)timerIRQ);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007a70": "configure_timer_interrupt_08007a70",
                "tim": "timer",
                "pre": "priority",
                "sub": "subpriority",
                "sub_local": "localSub",
                "pre_local": "localPre",
                "tim_local": "localTimer",
                "irq": "timerIRQ"
            },
            "calling": [
                "step_timer_init"
            ],
            "called": [
                "NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007ad0": {
            "entrypoint": "0x08007ad0",
            "current_name": "initialize_tim_08007ad0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_TIM_08007ad0(void)\n\n{\n  TIM_TypeDef *tim_instance;\n  \n  enable_TIM_clock((TIM_TypeDef *)&DAT_40000000);\n  _DAT_40000000 = 0;\n  _DAT_40000004 = 0;\n  _DAT_40000008 = 0;\n  _DAT_4000000c = 0;\n  _DAT_40000010 = 0;\n  _DAT_40000018 = 0;\n  _DAT_4000001c = 0;\n  _DAT_40000020 = 0;\n  _DAT_40000024 = 0;\n  _DAT_40000028 = SystemCoreClock / 42000000 - 1;\n  _DAT_4000002c = 0;\n  _DAT_40000034 = 0;\n  _DAT_40000038 = 0;\n  _DAT_4000003c = 0;\n  _DAT_40000040 = 0;\n  _DAT_40000048 = 0;\n  _DAT_4000004c = 0;\n  enable_TIM_interrupt((TIM_TypeDef *)&DAT_40000000,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007ad0": "initialize_tim_08007ad0",
                "TIMx": "tim_instance",
                "enable_tim_clock": "enable_TIM_clock",
                "enable_tim_interrupt": "enable_TIM_interrupt"
            },
            "calling": [
                "timers_init"
            ],
            "called": [
                "enable_tim_clock",
                "enable_tim_interrupt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007b70": {
            "entrypoint": "0x08007b70",
            "current_name": "enable_timer_interrupts_08007b70",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid enableTimerInterrupts_08007b70(void)\n\n{\n  TIM_TypeDef *timer;\n  uint32_t interruptFlag;\n  \n  interruptFlag = 1;\n  if (_DAT_40000034 != 0) {\n    interruptFlag = 3;\n  }\n  if (_DAT_40000038 != 0) {\n    interruptFlag = interruptFlag | 4;\n  }\n  _DAT_4000000c = _DAT_4000000c | interruptFlag;\n  _DAT_40000000 = _DAT_40000000 | 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007b70": "enable_timer_interrupts_08007b70",
                "TIMx": "timer",
                "enable": "interruptFlag"
            },
            "calling": [
                "st_wake_up"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007bc2": {
            "entrypoint": "0x08007bc2",
            "current_name": "clear_ti_mx_registers_08007bc2",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid clear_TIMx_registers_08007bc2(void)\n\n{\n  TIM_TypeDef *TIM_instance;\n  \n  _DAT_40000000 = _DAT_40000000 & 0xfffffffe;\n  _DAT_4000000c = _DAT_4000000c & 0xfffffff8;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007bc2": "clear_ti_mx_registers_08007bc2",
                "TIMx": "TIM_instance"
            },
            "calling": [
                "st_go_idle"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007bf0": {
            "entrypoint": "0x08007bf0",
            "current_name": "update_tick_value_08007bf0",
            "code": "\n\n\nvoid updateTickValue_08007bf0(uint32_t ticksValue)\n\n{\n  uint32_t localTicks;\n  uint32_t savedTicks;\n  TIM_TypeDef *timer;\n  \n  _DAT_4000002c = ticksValue;\n  if (ticksValue <= _DAT_40000024) {\n    _DAT_40000024 = ticksValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007bf0": "update_tick_value_08007bf0",
                "ticks": "ticksValue",
                "ticks_local": "localTicks",
                "saved": "savedTicks",
                "TIMx": "timer"
            },
            "calling": [
                "set_step_events_per_minute"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007c40": {
            "entrypoint": "0x08007c40",
            "current_name": "set_timer_ticks_08007c40",
            "code": "\n\n\nvoid setTimerTicks_08007c40(uint32_t ticks)\n\n{\n  uint32_t localTicks;\n  TIM_TypeDef *timer;\n  \n  _DAT_40000034 = ticks;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007c40": "set_timer_ticks_08007c40",
                "ticks_local": "localTicks",
                "TIMx": "timer"
            },
            "calling": [
                "st_wake_up"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007c5e": {
            "entrypoint": "0x08007c5e",
            "current_name": "set_timer_ticks_08007c5e",
            "code": "\n\n\nvoid setTimerTicks_08007c5e(uint32_t ticksValue)\n\n{\n  uint32_t localTicks;\n  TIM_TypeDef *timerInstance;\n  \n  _DAT_40000038 = ticksValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007c5e": "set_timer_ticks_08007c5e",
                "ticks": "ticksValue",
                "ticks_local": "localTicks",
                "TIMx": "timerInstance"
            },
            "calling": [
                "st_wake_up"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007c7c": {
            "entrypoint": "0x08007c7c",
            "current_name": "handle_interrupts_08007c7c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_interrupts_08007c7c(void)\n\n{\n  TIM_TypeDef *timer_registers;\n  \n  if (((_DAT_40000010 & 2) != 0) && ((_DAT_4000000c & 2) != 0)) {\n    _DAT_40000010 = _DAT_40000010 & 0xfffffffd;\n    handle_delay_interrupt();\n  }\n  if (((_DAT_40000010 & 4) != 0) && ((_DAT_4000000c & 4) != 0)) {\n    _DAT_40000010 = _DAT_40000010 & 0xfffffffb;\n    handle_pulse_interrupt();\n  }\n  if (((_DAT_40000010 & 1) != 0) && ((_DAT_4000000c & 1) != 0)) {\n    _DAT_40000010 = _DAT_40000010 & 0xfffffffe;\n    handle_period_interrupt();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007c7c": "handle_interrupts_08007c7c",
                "TIMx": "timer_registers",
                "step_delay_isr": "handle_delay_interrupt",
                "step_pulse_isr": "handle_pulse_interrupt",
                "step_period_isr": "handle_period_interrupt"
            },
            "calling": [],
            "called": [
                "step_delay_isr",
                "step_period_isr",
                "step_pulse_isr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007d08": {
            "entrypoint": "0x08007d08",
            "current_name": "initialize_timer_08007d08",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimer_08007d08(void)\n\n{\n  TIM_TypeDef *timer;\n  \n  enableTimerClock((TIM_TypeDef *)&DAT_40000800);\n  _DAT_40000800 = 0x80;\n  _DAT_40000804 = 0;\n  _DAT_40000808 = 0;\n  _DAT_4000080c = 0;\n  _DAT_40000810 = 0;\n  _DAT_40000818 = 0x6800;\n  _DAT_4000081c = 0;\n  _DAT_40000820 = 0;\n  _DAT_40000824 = 0;\n  _DAT_40000828 = coreClock / 4800000 - 1;\n  _DAT_4000082c = 199;\n  _DAT_40000834 = 0;\n  _DAT_40000838 = 100;\n  _DAT_4000083c = 0;\n  _DAT_40000840 = 0;\n  _DAT_40000848 = 0;\n  _DAT_4000084c = 0;\n  _DAT_40000814 = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007d08": "initialize_timer_08007d08",
                "TIMx": "timer",
                "enable_tim_clock": "enableTimerClock",
                "SystemCoreClock": "coreClock"
            },
            "calling": [
                "timers_init"
            ],
            "called": [
                "enable_tim_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007da8": {
            "entrypoint": "0x08007da8",
            "current_name": "initialize_timers_08007da8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimers_08007da8(void)\n\n{\n  TIM_TypeDef *timer;\n  \n  _DAT_40000820 = _DAT_40000820 | 0x10;\n  _DAT_40000800 = _DAT_40000800 | 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007da8": "initialize_timers_08007da8",
                "TIMx": "timer"
            },
            "calling": [
                "timers_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007dd8": {
            "entrypoint": "0x08007dd8",
            "current_name": "initialize_ti_mx_08007dd8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_TIMx_08007dd8(void)\n\n{\n  TIM_TypeDef *timer;\n  \n  _DAT_40000800 = _DAT_40000800 & 0xfffffffe;\n  _DAT_40000820 = _DAT_40000820 & 0xffffffef;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007dd8": "initialize_ti_mx_08007dd8",
                "TIMx": "timer"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007e08": {
            "entrypoint": "0x08007e08",
            "current_name": "init_timers_08007e08",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid init_timers_08007e08(void)\n\n{\n  initialize_step_timer();\n  initialize_g540_timer();\n  start_g540_timer();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007e08": "init_timers_08007e08",
                "step_timer_init": "initialize_step_timer",
                "g540_timer_init": "initialize_g540_timer",
                "g540_timer_start": "start_g540_timer"
            },
            "calling": [
                "main"
            ],
            "called": [
                "step_timer_init",
                "g540_timer_start",
                "g540_timer_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007e1c": {
            "entrypoint": "0x08007e1c",
            "current_name": "send_char_to_usart_08007e1c",
            "code": "\n\n\nvoid sendCharToUSART_08007e1c(char c)\n\n{\n  char localCharacter;\n  USART_TypeDef *USART;\n  \n  do {\n  } while ((_DAT_40004400 & 0x80) == 0);\n  _DAT_40004404 = (uint)(byte)c;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007e1c": "send_char_to_usart_08007e1c",
                "c_local": "localCharacter",
                "usart": "USART"
            },
            "calling": [
                "serial_write",
                "__io_putchar"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007e4c": {
            "entrypoint": "0x08007e4c",
            "current_name": "FUNC_08007e4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08007e4c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007e4c": "FUNC_08007e4c"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08007e58": {
            "entrypoint": "0x08007e58",
            "current_name": "check_usart_status_08007e58",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nint checkUSARTStatus_08007e58(void)\n\n{\n  USART_TypeDef *USART;\n  \n  return (uint)((_DAT_40004400 & 0x20) != 0);\n}\n\n",
            "renaming": {
                "FUN_08007e58": "check_usart_status_08007e58",
                "usart": "USART"
            },
            "calling": [
                "serial_read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007e84": {
            "entrypoint": "0x08007e84",
            "current_name": "get_usart_data_08007e84",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nchar get_USART_data_08007e84(void)\n\n{\n  USART_TypeDef *usart_data;\n  \n  return (char)_DAT_40004404;\n}\n\n",
            "renaming": {
                "FUN_08007e84": "get_usart_data_08007e84",
                "usart": "usart_data"
            },
            "calling": [
                "serial_read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007ea4": {
            "entrypoint": "0x08007ea4",
            "current_name": "initialize_usart_interrupt_flags_08007ea4",
            "code": "\n\n\nvoid initializeUSARTInterruptFlags_08007ea4(USART_TypeDef *usartInstance)\n\n{\n  USART_TypeDef *localUsartInstance;\n  \n  if (usartInstance == (USART_TypeDef *)0x40011000) {\n    _DAT_40023844 = _DAT_40023844 | 0x10;\n  }\n  else if (usartInstance == (USART_TypeDef *)&DAT_40004400) {\n    _DAT_40023840 = _DAT_40023840 | 0x20000;\n  }\n  else if (usartInstance == (USART_TypeDef *)0x40004800) {\n    _DAT_40023840 = _DAT_40023840 | 0x40000;\n  }\n  else if (usartInstance == (USART_TypeDef *)0x40004c00) {\n    _DAT_40023840 = _DAT_40023840 | 0x80000;\n  }\n  else if (usartInstance == (USART_TypeDef *)0x40005000) {\n    _DAT_40023840 = _DAT_40023840 | 0x100000;\n  }\n  else if (usartInstance == (USART_TypeDef *)0x40011400) {\n    _DAT_40023844 = _DAT_40023844 | 0x20;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007ea4": "initialize_usart_interrupt_flags_08007ea4",
                "usart": "usartInstance",
                "usart_local": "localUsartInstance"
            },
            "calling": [
                "usart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007f54": {
            "entrypoint": "0x08007f54",
            "current_name": "configure_usart_baud_rate_08007f54",
            "code": "\nvoid configureUSARTBaudRate_08007f54(USART_TypeDef *usartPeripheral,int baudRate)\n\n{\n  uint32_t pclkFreq1;\n  uint32_t pclkFreq2;\n  uint32_t pclkFreq3;\n  int localBaudRate;\n  USART_TypeDef *localUSART;\n  \n  if ((usartPeripheral->CR1 & 0x8000) == 0) {\n    if ((usartPeripheral == (USART_TypeDef *)0x40011000) || (usartPeripheral == (USART_TypeDef *)0x40011400)) {\n      pclkFreq1 = HAL_RCC_GetPCLK2Freq();\n      pclkFreq2 = HAL_RCC_GetPCLK2Freq();\n      pclkFreq3 = HAL_RCC_GetPCLK2Freq();\n      usartPeripheral->BRR = (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(uint)(baudRate << 2)) / 100) << 4 |\n                   (((pclkFreq2 * 0x19) / (uint)(baudRate << 2) +\n                    (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(uint)(baudRate << 2)) / 100) * -100)\n                    * 0x10 + 0x32) / 100 & 0xf;\n    }\n    else {\n      pclkFreq1 = HAL_RCC_GetPCLK1Freq();\n      pclkFreq2 = HAL_RCC_GetPCLK1Freq();\n      pclkFreq3 = HAL_RCC_GetPCLK1Freq();\n      usartPeripheral->BRR = (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(uint)(baudRate << 2)) / 100) << 4 |\n                   (((pclkFreq2 * 0x19) / (uint)(baudRate << 2) +\n                    (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(uint)(baudRate << 2)) / 100) * -100)\n                    * 0x10 + 0x32) / 100 & 0xf;\n    }\n  }\n  else if ((usartPeripheral == (USART_TypeDef *)0x40011000) || (usartPeripheral == (USART_TypeDef *)0x40011400)) {\n    pclkFreq1 = HAL_RCC_GetPCLK2Freq();\n    pclkFreq2 = HAL_RCC_GetPCLK2Freq();\n    pclkFreq3 = HAL_RCC_GetPCLK2Freq();\n    usartPeripheral->BRR = (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(uint)(baudRate << 1)) / 100) << 4 |\n                 (((pclkFreq2 * 0x19) / (uint)(baudRate << 1) +\n                  (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(uint)(baudRate << 1)) / 100) * -100) *\n                  0x10 + 0x32) / 100 & 0xf;\n  }\n  else {\n    pclkFreq1 = HAL_RCC_GetPCLK1Freq();\n    pclkFreq2 = HAL_RCC_GetPCLK1Freq();\n    pclkFreq3 = HAL_RCC_GetPCLK1Freq();\n    usartPeripheral->BRR = (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(uint)(baudRate << 1)) / 100) << 4 |\n                 (((pclkFreq2 * 0x19) / (uint)(baudRate << 1) +\n                  (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(uint)(baudRate << 1)) / 100) * -100) *\n                  0x10 + 0x32) / 100 & 0xf;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007f54": "configure_usart_baud_rate_08007f54",
                "usart": "usartPeripheral",
                "baud": "baudRate",
                "usart_local": "localUSART",
                "baud_local": "localBaudRate",
                "uVar1": "pclkFreq1",
                "uVar2": "pclkFreq2",
                "uVar3": "pclkFreq3"
            },
            "calling": [
                "usart_init"
            ],
            "called": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008190": {
            "entrypoint": "0x08008190",
            "current_name": "initialize_usart_08008190",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeUSART_08008190(void)\n\n{\n  uint32_t value;\n  USART_TypeDef *USART;\n  \n  enable_USART_clock((USART_TypeDef *)&DAT_40004400);\n  _DAT_4000440c = _DAT_4000440c & 0xffff400c | 0xc;\n  _DAT_40004410 = _DAT_40004410 & 0xffff8090;\n  _DAT_40004414 = _DAT_40004414 & 0xfffff000;\n  _DAT_40004400 = _DAT_40004400 & 0xfffffc00;\n  set_baud_rate((USART_TypeDef *)&DAT_40004400,0x1c200);\n  _DAT_4000440c = _DAT_4000440c | 0x2000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008190": "initialize_usart_08008190",
                "val": "value",
                "usart": "USART"
            },
            "calling": [
                "main"
            ],
            "called": [
                "set_baud_rate",
                "enable_usart_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008244": {
            "entrypoint": "0x08008244",
            "current_name": "FUNC_08008244",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08008244(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008244": "FUNC_08008244"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008250": {
            "entrypoint": "0x08008250",
            "current_name": "send_data_08008250",
            "code": "\nvoid sendData_08008250(uint8_t inputData)\n\n{\n  uint8_t localData;\n  \n  usart_putc(inputData);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008250": "send_data_08008250",
                "data": "inputData",
                "data_local": "localData"
            },
            "calling": [
                "printString",
                "print_base2",
                "printFloat",
                "printPgmString",
                "print_uint32_base10",
                "printInteger"
            ],
            "called": [
                "usart_putc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800826a": {
            "entrypoint": "0x0800826a",
            "current_name": "print_character_0800826a",
            "code": "\nint print_character_0800826a(int character)\n\n{\n  int local_character;\n  \n  usart_putc((characterar)character);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800826a": "print_character_0800826a",
                "ch": "character",
                "ch_local": "local_character"
            },
            "calling": [],
            "called": [
                "usart_putc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008286": {
            "entrypoint": "0x08008286",
            "current_name": "read_serial_data_08008286",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t read_serial_data_08008286(void)\n\n{\n  uint8_t received_data;\n  int has_data;\n  uint8_t c;\n  \n  has_data = usart_tstc();\n  if (has_data != 0) {\n    received_data = usart_getc();\n    has_data = serial_rx_hook(received_data);\n    if (has_data == 0) {\n      return received_data;\n    }\n  }\n  return 0xff;\n}\n\n",
            "renaming": {
                "FUN_08008286": "read_serial_data_08008286",
                "iVar1": "has_data",
                "data": "received_data"
            },
            "calling": [
                "protocol_process"
            ],
            "called": [
                "usart_getc",
                "usart_tstc",
                "serial_rx_hook"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080082ba": {
            "entrypoint": "0x080082ba",
            "current_name": "FUNC_080082ba",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080082ba(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080082ba": "FUNC_080082ba"
            },
            "calling": [
                "grbl_main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080082c8": {
            "entrypoint": "0x080082c8",
            "current_name": "decode_and_add_080082c8",
            "code": "\nvoid decode_and_add_080082c8(undefined4 result,uint input_value)\n\n{\n  add_double(result,input_value ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080082c8": "decode_and_add_080082c8",
                "param_1": "result",
                "param_2": "input_value",
                "__aeabi_dadd": "add_double"
            },
            "calling": [],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080082d0": {
            "entrypoint": "0x080082d0",
            "current_name": "calculate_sum_080082d0",
            "code": "\nulonglong calculate_sum_080082d0(uint num1,uint num2,uint num3,uint num4)\n\n{\n  int shiftedBits1;\n  byte carry1;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  int shiftedBits2;\n  uint result1_lower;\n  uint result1_upper;\n  uint result2_lower;\n  uint result2_upper;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  \n  temp4 = num4 ^ 0x80000000;\n  result1_lower = num2 << 1;\n  num4 = num4 << 1;\n  condition1 = ((num2 ^ temp4) & 0x7fffffff) == 0;\n  condition2 = condition1 && num1 == num3;\n  if (!condition1 || num1 != num3) {\n    condition2 = (result1_lower | num1) == 0;\n  }\n  if (!condition2) {\n    condition2 = (num4 | num3) == 0;\n  }\n  shiftedBits2 = (int)result1_lower >> 0x15;\n  if (!condition2) {\n    condition2 = shiftedBits2 == -1;\n  }\n  shiftedBits1 = (int)num4 >> 0x15;\n  if (!condition2) {\n    condition2 = shiftedBits1 == -1;\n  }\n  if (condition2) {\n    if (shiftedBits2 == -1 || shiftedBits1 == -1) {\n      result1_lower = temp4;\n      result2_lower = num3;\n      if (shiftedBits2 == -1) {\n        result1_lower = num2;\n        result2_lower = num1;\n      }\n      if (shiftedBits2 != -1 || shiftedBits1 != -1) {\n        num3 = result2_lower;\n        temp4 = result1_lower;\n      }\n      condition2 = (result2_lower | result1_lower << 0xc) == 0;\n      if (condition2) {\n        condition2 = (num3 | temp4 << 0xc) == 0;\n      }\n      if (condition2) {\n        condition2 = result1_lower == temp4;\n      }\n      if (!condition2) {\n        result1_lower = result1_lower | 0x80000;\n      }\n      return CONCAT44(result1_lower,result2_lower);\n    }\n    if (((num2 ^ temp4) & 0x7fffffff) != 0 || num1 != num3) {\n      if ((result1_lower | num1) == 0) {\n        num1 = num3;\n        num2 = temp4;\n      }\n      return CONCAT44(num2,num1);\n    }\n    if (num2 != temp4) {\n      return 0;\n    }\n    if (result1_lower >> 0x15 == 0) {\n      condition2 = (num1 & 0x80000000) != 0;\n      temp4 = num2 * 2 + (uint)condition2;\n      if (CARRY4(num2,num2) || CARRY4(num2 * 2,(uint)condition2)) {\n        temp4 = temp4 | 0x80000000;\n      }\n      return CONCAT44(temp4,num1 << 1);\n    }\n    if (result1_lower < 0xffc00000) {\n      return CONCAT44(num2 + 0x100000,num1);\n    }\n    num2 = num2 & 0x80000000;\nLAB_08008514:\n    return (ulonglong)(num2 | 0x7ff00000) << 0x20;\n  }\n  result1_lower = result1_lower >> 0x15;\n  num4 = num4 >> 0x15;\n  result2_lower = num4 - result1_lower;\n  condition2 = result2_lower != 0;\n  if (num4 < result1_lower) {\n    result2_lower = -result2_lower;\n  }\n  result1_upper = num1;\n  temp5 = num2;\n  if (condition2 && result1_lower <= num4) {\n    result1_lower = result1_lower + result2_lower;\n    result1_upper = num3;\n    temp5 = temp4;\n    num3 = num1;\n    temp4 = num2;\n  }\n  if (0x36 < result2_lower) {\n    return CONCAT44(temp5,result1_upper);\n  }\n  temp2 = temp5 & 0xfffff | 0x100000;\n  if ((temp5 & 0x80000000) != 0) {\n    condition2 = result1_upper != 0;\n    result1_upper = -result1_upper;\n    temp2 = -temp2 - (uint)condition2;\n  }\n  temp5 = temp4 & 0xfffff | 0x100000;\n  if ((temp4 & 0x80000000) != 0) {\n    condition2 = num3 != 0;\n    num3 = -num3;\n    temp5 = -temp5 - (uint)condition2;\n  }\n  if (result1_lower == result2_lower) {\n    temp5 = temp5 ^ 0x100000;\n    if (result1_lower == 0) {\n      temp2 = temp2 ^ 0x100000;\n      result1_lower = 1;\n    }\n    else {\n      result2_lower = result2_lower - 1;\n    }\n  }\n  temp4 = -result2_lower + 0x20;\n  if ((int)result2_lower < 0x21) {\n    result2_upper = num3 << (temp4 & 0xff);\n    num3 = num3 >> (result2_lower & 0xff);\n    temp1 = result1_upper + num3;\n    temp3 = temp5 << (temp4 & 0xff);\n    temp4 = temp1 + temp3;\n    temp2 = temp2 + CARRY4(result1_upper,num3) + ((int)temp5 >> (result2_lower & 0xff)) +\n            (uint)CARRY4(temp1,temp3);\n  }\n  else {\n    result2_upper = temp5 << (-result2_lower + 0x40 & 0xff);\n    if (num3 != 0) {\n      result2_upper = result2_upper | 2;\n    }\n    temp5 = (int)temp5 >> (result2_lower - 0x20 & 0xff);\n    temp4 = result1_upper + temp5;\n    temp2 = temp2 + ((int)temp5 >> 0x1f) + (uint)CARRY4(result1_upper,temp5);\n  }\n  num2 = temp2 & 0x80000000;\n  result2_lower = temp2;\n  if ((int)temp2 < 0) {\n    condition2 = result2_upper == 0;\n    result2_upper = -result2_upper;\n    result2_lower = -temp4;\n    temp4 = -(uint)!condition2 - temp4;\n    result2_lower = -(uint)(condition2 <= result2_lower) - temp2;\n  }\n  if (0xfffff < result2_lower) {\n    result1_upper = result1_lower - 1;\n    if (0x1fffff < result2_lower) {\n      result1_upper = result2_lower & 1;\n      result2_lower = result2_lower >> 1;\n      carry1 = (byte)temp4;\n      temp4 = (uint)(result1_upper != 0) << 0x1f | temp4 >> 1;\n      result2_upper = (uint)(carry1 & 1) << 0x1f | result2_upper >> 1;\n      result1_upper = result1_lower;\n      if (0xffbfffff < result1_lower * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    condition2 = 0x7fffffff < result2_upper;\n    if (result2_upper == 0x80000000) {\n      condition2 = (temp4 & 1) != 0;\n    }\n    return CONCAT44(result2_lower + result1_upper * 0x100000 + (uint)CARRY4(temp4,(uint)condition2) | num2,\n                    temp4 + condition2);\n  }\n  condition1 = (result2_upper & 0x80000000) != 0;\n  result2_upper = result2_upper << 1;\n  result1_upper = temp4 * 2;\n  condition2 = CARRY4(temp4,temp4);\n  temp4 = temp4 * 2 + (uint)condition1;\n  result2_lower = result2_lower * 2 + (uint)(condition2 || CARRY4(result1_upper,(uint)condition1));\n  result1_upper = result1_lower - 2;\n  if (result1_lower - 1 != 0 && 0xfffff < result2_lower) goto LAB_080083e0;\n  temp5 = temp4;\n  result1_lower = result2_lower;\n  if (result2_lower == 0) {\n    temp5 = 0;\n    result1_lower = temp4;\n  }\n  shiftedBits2 = LZCOUNT(result1_lower);\n  if (result2_lower == 0) {\n    shiftedBits2 = shiftedBits2 + 0x20;\n  }\n  result2_lower = shiftedBits2 - 0xb;\n  condition3 = SBORROW4(result2_lower,0x20);\n  temp4 = shiftedBits2 - 0x2b;\n  condition2 = (int)temp4 < 0;\n  condition1 = temp4 == 0;\n  if ((int)result2_lower < 0x20) {\n    condition3 = SCARRY4(temp4,0xc);\n    shiftedBits2 = shiftedBits2 + -0x1f;\n    condition2 = shiftedBits2 < 0;\n    condition1 = shiftedBits2 == 0;\n    temp4 = result2_lower;\n    if (!condition1 && condition2 == condition3) {\n      temp5 = result1_lower << (result2_lower & 0xff);\n      result1_lower = result1_lower >> (0xcU - shiftedBits2 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (condition1 || condition2 != condition3) {\n    result2_upper = 0x20 - temp4;\n  }\n  result1_lower = result1_lower << (temp4 & 0xff);\n  if (condition1 || condition2 != condition3) {\n    result1_lower = result1_lower | temp5 >> (result2_upper & 0xff);\n  }\n  if (condition1 || condition2 != condition3) {\n    temp5 = temp5 << (temp4 & 0xff);\n  }\nLAB_08008458:\n  if ((int)result2_lower <= (int)result1_upper) {\n    return CONCAT44(result1_lower + (result1_upper - result2_lower) * 0x100000 | num2,temp5);\n  }\n  temp4 = ~(result1_upper - result2_lower);\n  if ((int)temp4 < 0x1f) {\n    shiftedBits2 = temp4 - 0x13;\n    if (shiftedBits2 != 0 && shiftedBits2 < 0 == SCARRY4(temp4 - 0x1f,0xc)) {\n      return CONCAT44(temp2,temp5 >> (0x20 - (0xcU - shiftedBits2) & 0xff) | result1_lower << (0xcU - shiftedBits2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    temp4 = temp4 + 1;\n    return CONCAT44(num2 | result1_lower >> (temp4 & 0xff),\n                    temp5 >> (temp4 & 0xff) | result1_lower << (0x20 - temp4 & 0xff));\n  }\n  return CONCAT44(temp2,result1_lower >> (temp4 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_080082d0": "calculate_sum_080082d0",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "num3",
                "param_4": "num4",
                "iVar1": "shiftedBits1",
                "bVar2": "carry1",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "uVar6": "temp4",
                "uVar7": "temp5",
                "iVar8": "shiftedBits2",
                "uVar9": "result1_lower",
                "uVar10": "result1_upper",
                "uVar11": "result2_lower",
                "uVar12": "result2_upper",
                "bVar13": "condition1",
                "bVar14": "condition2",
                "bVar15": "condition3"
            },
            "calling": [
                "sin",
                "__ieee754_rem_pio2",
                "__ieee754_atan2",
                "atan",
                "report_realtime_status",
                "__kernel_rem_pio2",
                "__kernel_sin",
                "plan_buffer_line",
                "__ieee754_sqrt",
                "mc_arc",
                "__ieee754_hypot",
                "cos",
                "__kernel_cos"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080082d4": {
            "entrypoint": "0x080082d4",
            "current_name": "calculate_product_080082d4",
            "code": "\nulonglong calculate_product_080082d4(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int shift1;\n  byte carry;\n  uint result1;\n  uint result2;\n  uint temp1;\n  int shift2;\n  uint shifted_b;\n  uint shifted_d;\n  uint new_b;\n  uint new_d;\n  uint temp2;\n  uint temp3;\n  bool cond1;\n  bool cond2;\n  bool cond3;\n  \n  shifted_b = param_2 << 1;\n  new_b = param_4 << 1;\n  cond1 = ((param_2 ^ param_4) & 0x7fffffff) == 0;\n  cond2 = cond1 && param_1 == param_3;\n  if (!cond1 || param_1 != param_3) {\n    cond2 = (shifted_b | param_1) == 0;\n  }\n  if (!cond2) {\n    cond2 = (new_b | param_3) == 0;\n  }\n  shift2 = (int)shifted_b >> 0x15;\n  if (!cond2) {\n    cond2 = shift2 == -1;\n  }\n  shift1 = (int)new_b >> 0x15;\n  if (!cond2) {\n    cond2 = shift1 == -1;\n  }\n  if (cond2) {\n    if (shift2 == -1 || shift1 == -1) {\n      new_b = param_4;\n      shifted_b = param_3;\n      if (shift2 == -1) {\n        new_b = param_2;\n        shifted_b = param_1;\n      }\n      if (shift2 != -1 || shift1 != -1) {\n        param_3 = shifted_b;\n        param_4 = new_b;\n      }\n      cond2 = (shifted_b | new_b << 0xc) == 0;\n      if (cond2) {\n        cond2 = (param_3 | param_4 << 0xc) == 0;\n      }\n      if (cond2) {\n        cond2 = new_b == param_4;\n      }\n      if (!cond2) {\n        new_b = new_b | 0x80000;\n      }\n      return CONCAT44(new_b,shifted_b);\n    }\n    if (((param_2 ^ param_4) & 0x7fffffff) != 0 || param_1 != param_3) {\n      if ((shifted_b | param_1) == 0) {\n        param_1 = param_3;\n        param_2 = param_4;\n      }\n      return CONCAT44(param_2,param_1);\n    }\n    if (param_2 != param_4) {\n      return 0;\n    }\n    if (shifted_b >> 0x15 == 0) {\n      cond2 = (param_1 & 0x80000000) != 0;\n      new_b = param_2 * 2 + (uint)cond2;\n      if (CARRY4(param_2,param_2) || CARRY4(param_2 * 2,(uint)cond2)) {\n        new_b = new_b | 0x80000000;\n      }\n      return CONCAT44(new_b,param_1 << 1);\n    }\n    if (shifted_b < 0xffc00000) {\n      return CONCAT44(param_2 + 0x100000,param_1);\n    }\n    param_2 = param_2 & 0x80000000;\nLAB_08008514:\n    return (ulonglong)(param_2 | 0x7ff00000) << 0x20;\n  }\n  shifted_b = shifted_b >> 0x15;\n  new_b = new_b >> 0x15;\n  new_d = new_b - shifted_b;\n  cond2 = new_d != 0;\n  if (new_b < shifted_b) {\n    new_d = -new_d;\n  }\n  shifted_d = param_1;\n  temp1 = param_2;\n  if (cond2 && shifted_b <= new_b) {\n    shifted_b = shifted_b + new_d;\n    shifted_d = param_3;\n    temp1 = param_4;\n    param_3 = param_1;\n    param_4 = param_2;\n  }\n  if (0x36 < new_d) {\n    return CONCAT44(temp1,shifted_d);\n  }\n  new_b = temp1 & 0xfffff | 0x100000;\n  if ((temp1 & 0x80000000) != 0) {\n    cond2 = shifted_d != 0;\n    shifted_d = -shifted_d;\n    new_b = -new_b - (uint)cond2;\n  }\n  temp1 = param_4 & 0xfffff | 0x100000;\n  if ((param_4 & 0x80000000) != 0) {\n    cond2 = param_3 != 0;\n    param_3 = -param_3;\n    temp1 = -temp1 - (uint)cond2;\n  }\n  if (shifted_b == new_d) {\n    temp1 = temp1 ^ 0x100000;\n    if (shifted_b == 0) {\n      new_b = new_b ^ 0x100000;\n      shifted_b = 1;\n    }\n    else {\n      new_d = new_d - 1;\n    }\n  }\n  temp3 = -new_d + 0x20;\n  if ((int)new_d < 0x21) {\n    temp2 = param_3 << (temp3 & 0xff);\n    param_3 = param_3 >> (new_d & 0xff);\n    result1 = shifted_d + param_3;\n    result2 = temp1 << (temp3 & 0xff);\n    temp3 = result1 + result2;\n    new_b = new_b + CARRY4(shifted_d,param_3) + ((int)temp1 >> (new_d & 0xff)) +\n            (uint)CARRY4(result1,result2);\n  }\n  else {\n    temp2 = temp1 << (-new_d + 0x40 & 0xff);\n    if (param_3 != 0) {\n      temp2 = temp2 | 2;\n    }\n    temp1 = (int)temp1 >> (new_d - 0x20 & 0xff);\n    temp3 = shifted_d + temp1;\n    new_b = new_b + ((int)temp1 >> 0x1f) + (uint)CARRY4(shifted_d,temp1);\n  }\n  param_2 = new_b & 0x80000000;\n  new_d = new_b;\n  if ((int)new_b < 0) {\n    cond2 = temp2 == 0;\n    temp2 = -temp2;\n    new_d = -temp3;\n    temp3 = -(uint)!cond2 - temp3;\n    new_d = -(uint)(cond2 <= new_d) - new_b;\n  }\n  if (0xfffff < new_d) {\n    shifted_d = shifted_b - 1;\n    if (0x1fffff < new_d) {\n      new_b = new_d & 1;\n      new_d = new_d >> 1;\n      carry = (byte)temp3;\n      temp3 = (uint)(new_b != 0) << 0x1f | temp3 >> 1;\n      temp2 = (uint)(carry & 1) << 0x1f | temp2 >> 1;\n      shifted_d = shifted_b;\n      if (0xffbfffff < shifted_b * 0x200000) goto LAB_08008514;\n    }\nLAB_080083e0:\n    cond2 = 0x7fffffff < temp2;\n    if (temp2 == 0x80000000) {\n      cond2 = (temp3 & 1) != 0;\n    }\n    return CONCAT44(new_d + shifted_d * 0x100000 + (uint)CARRY4(temp3,(uint)cond2) | param_2,\n                    temp3 + cond2);\n  }\n  cond1 = (temp2 & 0x80000000) != 0;\n  temp2 = temp2 << 1;\n  shifted_d = temp3 * 2;\n  cond2 = CARRY4(temp3,temp3);\n  temp3 = temp3 * 2 + (uint)cond1;\n  new_d = new_d * 2 + (uint)(cond2 || CARRY4(shifted_d,(uint)cond1));\n  shifted_d = shifted_b - 2;\n  if (shifted_b - 1 != 0 && 0xfffff < new_d) goto LAB_080083e0;\n  temp1 = temp3;\n  shifted_b = new_d;\n  if (new_d == 0) {\n    temp1 = 0;\n    shifted_b = temp3;\n  }\n  shift2 = LZCOUNT(shifted_b);\n  if (new_d == 0) {\n    shift2 = shift2 + 0x20;\n  }\n  temp3 = shift2 - 0xb;\n  cond3 = SBORROW4(temp3,0x20);\n  new_d = shift2 - 0x2b;\n  cond2 = (int)new_d < 0;\n  cond1 = new_d == 0;\n  if ((int)temp3 < 0x20) {\n    cond3 = SCARRY4(new_d,0xc);\n    shift2 = shift2 + -0x1f;\n    cond2 = shift2 < 0;\n    cond1 = shift2 == 0;\n    new_d = temp3;\n    if (!cond1 && cond2 == cond3) {\n      temp1 = shifted_b << (temp3 & 0xff);\n      shifted_b = shifted_b >> (0xcU - shift2 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (cond1 || cond2 != cond3) {\n    temp2 = 0x20 - new_d;\n  }\n  shifted_b = shifted_b << (new_d & 0xff);\n  if (cond1 || cond2 != cond3) {\n    shifted_b = shifted_b | temp1 >> (temp2 & 0xff);\n  }\n  if (cond1 || cond2 != cond3) {\n    temp1 = temp1 << (new_d & 0xff);\n  }\nLAB_08008458:\n  if ((int)temp3 <= (int)shifted_d) {\n    return CONCAT44(shifted_b + (shifted_d - temp3) * 0x100000 | param_2,temp1);\n  }\n  new_d = ~(shifted_d - temp3);\n  if ((int)new_d < 0x1f) {\n    shift2 = new_d - 0x13;\n    if (shift2 != 0 && shift2 < 0 == SCARRY4(new_d - 0x1f,0xc)) {\n      return CONCAT44(new_b,temp1 >> (0x20 - (0xcU - shift2) & 0xff) | shifted_b << (0xcU - shift2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    new_d = new_d + 1;\n    return CONCAT44(param_2 | shifted_b >> (new_d & 0xff),\n                    temp1 >> (new_d & 0xff) | shifted_b << (0x20 - new_d & 0xff));\n  }\n  return CONCAT44(new_b,shifted_b >> (new_d - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_080082d4": "calculate_product_080082d4",
                "iVar1": "shift1",
                "bVar2": "carry",
                "uVar3": "result1",
                "uVar4": "result2",
                "uVar5": "temp1",
                "iVar6": "shift2",
                "uVar7": "shifted_b",
                "uVar8": "shifted_d",
                "uVar9": "new_b",
                "uVar10": "new_d",
                "uVar11": "temp2",
                "uVar12": "temp3",
                "bVar13": "cond1",
                "bVar14": "cond2",
                "bVar15": "cond3"
            },
            "calling": [
                "__ieee754_rem_pio2",
                "trunc",
                "__ieee754_atan2",
                "atan",
                "__aeabi_drsub",
                "__kernel_rem_pio2",
                "round",
                "__kernel_sin",
                "scalbn",
                "ceil",
                "__ieee754_sqrt",
                "mc_arc",
                "__ieee754_hypot",
                "__kernel_cos",
                "floor"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800854c": {
            "entrypoint": "0x0800854c",
            "current_name": "bit_shift_and_concat_0800854c",
            "code": "\nulonglong bitShiftAndConcat_0800854c(uint input)\n\n{\n  uint shiftedResult;\n  uint shiftAmount;\n  int leadingZeros;\n  uint totalBits;\n  uint remainingBits;\n  bool isNegative;\n  bool isZero;\n  bool isCarry;\n  \n  if (input == 0) {\n    return 0;\n  }\n  shiftedResult = 0;\n  leadingZeros = countLeadingZeros(input);\n  totalBits = leadingZeros + 0x15;\n  isCarry = SBORROW4(totalBits,0x20);\n  shiftAmount = leadingZeros - 0xb;\n  isNegative = (int)shiftAmount < 0;\n  isZero = shiftAmount == 0;\n  if (totalBits < 0x20) {\n    isCarry = isCarrySubtraction(shiftAmount,0xc);\n    isNegative = false;\n    isZero = leadingZeros + 1 == 0;\n    shiftAmount = totalBits;\n    if (!isZero && isCarry == false) {\n      shiftedResult = input << totalBits;\n      input = input >> (0xcU - (leadingZeros + 1) & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (isZero || isNegative != isCarry) {\n    remainingBits = 0x20 - shiftAmount;\n  }\n  input = input << (shiftAmount & 0xff);\n  if (isZero || isNegative != isCarry) {\n    input = input | 0U >> (remainingBits & 0xff);\n  }\n  if (isZero || isNegative != isCarry) {\n    shiftedResult = 0 << (shiftAmount & 0xff);\n  }\nLAB_08008458:\n  if (totalBits < 0x433) {\n    return CONCAT44(input + (0x432 - totalBits) * 0x100000,shiftedResult);\n  }\n  shiftAmount = ~(0x432 - totalBits);\n  if (0x1e < (int)shiftAmount) {\n    return (ulonglong)(input >> (shiftAmount - 0x1f & 0xff));\n  }\n  leadingZeros = shiftAmount - 0x13;\n  if (leadingZeros == 0 || leadingZeros < 0 != isCarrySubtraction(shiftAmount - 0x1f,0xc)) {\n    shiftAmount = shiftAmount + 1;\n    return CONCAT44(input >> (shiftAmount & 0xff),\n                    shiftedResult >> (shiftAmount & 0xff) | input << (0x20 - shiftAmount & 0xff));\n  }\n  return (ulonglong)(shiftedResult >> (0x20 - (0xcU - leadingZeros) & 0xff) | input << (0xcU - leadingZeros & 0xff));\n}\n\n",
            "renaming": {
                "FUN_0800854c": "bit_shift_and_concat_0800854c",
                "param_1": "input",
                "uVar1": "shiftedResult",
                "uVar2": "shiftAmount",
                "iVar3": "leadingZeros",
                "uVar4": "totalBits",
                "in_r12": "remainingBits",
                "bVar5": "isNegative",
                "bVar6": "isZero",
                "bVar7": "isCarry",
                "SCARRY4": "isCarrySubtraction",
                "LZCOUNT": "countLeadingZeros"
            },
            "calling": [
                "homing_cycle"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800856c": {
            "entrypoint": "0x0800856c",
            "current_name": "reverse_bits_0800856c",
            "code": "\nulonglong reverse_bits_0800856c(uint input)\n\n{\n  uint shifted_input;\n  uint abs_input;\n  uint shift_amount;\n  int leading_zeros;\n  uint final_shift;\n  uint sign_bit;\n  uint remaining_zeros;\n  bool is_negative;\n  bool is_zero;\n  bool carry_flag;\n  \n  if (input == 0) {\n    return 0;\n  }\n  sign_bit = input & 0x80000000;\n  abs_input = input;\n  if ((int)sign_bit < 0) {\n    abs_input = -input;\n  }\n  shifted_input = 0;\n  leading_zeros = LZCOUNT(abs_input);\n  final_shift = leading_zeros + 0x15;\n  carry_flag = SBORROW4(final_shift,0x20);\n  shift_amount = leading_zeros - 0xb;\n  is_negative = (int)shift_amount < 0;\n  is_zero = shift_amount == 0;\n  if (final_shift < 0x20) {\n    carry_flag = SCARRY4(shift_amount,0xc);\n    is_negative = false;\n    is_zero = leading_zeros + 1 == 0;\n    shift_amount = final_shift;\n    if (!is_zero && carry_flag == false) {\n      shifted_input = abs_input << final_shift;\n      abs_input = abs_input >> (0xcU - (leading_zeros + 1) & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (is_zero || is_negative != carry_flag) {\n    remaining_zeros = 0x20 - shift_amount;\n  }\n  abs_input = abs_input << (shift_amount & 0xff);\n  if (is_zero || is_negative != carry_flag) {\n    abs_input = abs_input | 0U >> (remaining_zeros & 0xff);\n  }\n  if (is_zero || is_negative != carry_flag) {\n    shifted_input = 0 << (shift_amount & 0xff);\n  }\nLAB_08008458:\n  if (final_shift < 0x433) {\n    return CONCAT44(abs_input + (0x432 - final_shift) * 0x100000 | sign_bit,shifted_input);\n  }\n  shift_amount = ~(0x432 - final_shift);\n  if (0x1e < (int)shift_amount) {\n    return CONCAT44(input,abs_input >> (shift_amount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leading_zeros = shift_amount - 0x13;\n  if (leading_zeros == 0 || leading_zeros < 0 != SCARRY4(shift_amount - 0x1f,0xc)) {\n    shift_amount = shift_amount + 1;\n    return CONCAT44(sign_bit | abs_input >> (shift_amount & 0xff),\n                    shifted_input >> (shift_amount & 0xff) | abs_input << (0x20 - shift_amount & 0xff));\n  }\n  return CONCAT44(input,shifted_input >> (0x20 - (0xcU - leading_zeros) & 0xff) | abs_input << (0xcU - leading_zeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800856c": "reverse_bits_0800856c",
                "param_1": "input",
                "uVar1": "shifted_input",
                "uVar2": "abs_input",
                "uVar3": "shift_amount",
                "iVar4": "leading_zeros",
                "uVar5": "final_shift",
                "uVar6": "sign_bit",
                "in_r12": "remaining_zeros",
                "bVar7": "is_negative",
                "bVar8": "is_zero",
                "bVar9": "carry_flag"
            },
            "calling": [
                "__ieee754_rem_pio2",
                "calculate_trapezoid_for_block",
                "__kernel_rem_pio2"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008590": {
            "entrypoint": "0x08008590",
            "current_name": "decode_unsigned_long_long_08008590",
            "code": "\nulonglong decode_unsigned_long_long_08008590(uint input_value,undefined4 param2,undefined4 param3,uint param4)\n\n{\n  uint mask;\n  uint result;\n  uint shifted_value;\n  uint shifted_bits;\n  uint temp_value;\n  int count;\n  uint shift_amount;\n  uint temp_register;\n  bool is_less_than;\n  bool is_equal;\n  bool is_less_than_signed;\n  \n  temp_value = input_value << 1;\n  is_equal = temp_value == 0;\n  mask = (uint)((input_value & 0x80000000) != 0) << 0x1f;\n  shifted_bits = (uint)((int)temp_value >> 3) >> 1;\n  shifted_value = mask | shifted_bits;\n  input_value = input_value << 0x1d;\n  if (!is_equal) {\n    param4 = temp_value & 0xff000000;\n    is_equal = param4 == 0;\n  }\n  if (!is_equal) {\n    is_equal = param4 == 0xff000000;\n  }\n  if (!is_equal) {\n    return CONCAT44(shifted_value,input_value) ^ 0x3800000000000000;\n  }\n  if ((temp_value & 0xffffff) == 0) {\n    return CONCAT44(shifted_value,input_value);\n  }\n  if (param4 == 0xff000000) {\n    return CONCAT44(shifted_value,input_value) | 0x8000000000000;\n  }\n  result = input_value;\n  temp_value = shifted_bits;\n  if (shifted_bits == 0) {\n    result = 0;\n    temp_value = input_value;\n  }\n  count = LZCOUNT(temp_value);\n  if (shifted_bits == 0) {\n    count = count + 0x20;\n  }\n  shift_amount = count - 0xb;\n  is_less_than_signed = SBORROW4(shift_amount,0x20);\n  shifted_bits = count - 0x2b;\n  is_equal = (int)shifted_bits < 0;\n  is_less_than = shifted_bits == 0;\n  if ((int)shift_amount < 0x20) {\n    is_less_than_signed = SCARRY4(shifted_bits,0xc);\n    count = count + -0x1f;\n    is_equal = count < 0;\n    is_less_than = count == 0;\n    shifted_bits = shift_amount;\n    if (!is_less_than && is_equal == is_less_than_signed) {\n      result = temp_value << (shift_amount & 0xff);\n      temp_value = temp_value >> (0xcU - count & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (is_less_than || is_equal != is_less_than_signed) {\n    temp_register = 0x20 - shifted_bits;\n  }\n  temp_value = temp_value << (shifted_bits & 0xff);\n  if (is_less_than || is_equal != is_less_than_signed) {\n    temp_value = temp_value | result >> (temp_register & 0xff);\n  }\n  if (is_less_than || is_equal != is_less_than_signed) {\n    result = result << (shifted_bits & 0xff);\n  }\nLAB_08008458:\n  if ((int)shift_amount < 0x381) {\n    return CONCAT44(temp_value + (0x380 - shift_amount) * 0x100000 | mask,result);\n  }\n  shifted_bits = ~(0x380 - shift_amount);\n  if (0x1e < (int)shifted_bits) {\n    return CONCAT44(shifted_value,temp_value >> (shifted_bits - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  count = shifted_bits - 0x13;\n  if (count == 0 || count < 0 != SCARRY4(shifted_bits - 0x1f,0xc)) {\n    shifted_bits = shifted_bits + 1;\n    return CONCAT44(mask | temp_value >> (shifted_bits & 0xff),\n                    result >> (shifted_bits & 0xff) | temp_value << (0x20 - shifted_bits & 0xff));\n  }\n  return CONCAT44(shifted_value,result >> (0x20 - (0xcU - count) & 0xff) | temp_value << (0xcU - count & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08008590": "decode_unsigned_long_long_08008590",
                "param_1": "input_value",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "mask",
                "uVar2": "result",
                "uVar3": "shifted_value",
                "uVar4": "shifted_bits",
                "uVar5": "temp_value",
                "iVar6": "count",
                "uVar7": "shift_amount",
                "in_r12": "temp_register",
                "bVar8": "is_less_than",
                "bVar9": "is_equal",
                "bVar10": "is_less_than_signed"
            },
            "calling": [
                "to_millimeters",
                "calculate_trapezoid_for_block",
                "report_realtime_status",
                "homing_cycle",
                "max_allowable_speed",
                "plan_buffer_line",
                "gc_execute_line",
                "protocol_execute_line",
                "read_float",
                "mc_dwell",
                "mc_arc",
                "report_gcode_modes",
                "settings_store_global_setting",
                "report_gcode_parameters"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080085d4": {
            "entrypoint": "0x080085d4",
            "current_name": "calculate_result_080085d4",
            "code": "\nulonglong calculateResult_080085d4(uint input1,uint input2)\n\n{\n  byte bit1;\n  uint result1;\n  uint shift1;\n  uint result2;\n  int count1;\n  uint shift2;\n  int count2;\n  uint extracted;\n  bool carry1;\n  bool carry2;\n  bool carry3;\n  \n  if ((input1 | input2) == 0) {\n    return CONCAT44(input2,input1);\n  }\n  count2 = 0x432;\n  extracted = input2 >> 0x16;\n  if (extracted != 0) {\n    count2 = 3;\n    if (input2 >> 0x19 != 0) {\n      count2 = 6;\n    }\n    if (input2 >> 0x1c != 0) {\n      count2 = count2 + 3;\n    }\n    result2 = count2 - ((int)input2 >> 0x1f);\n    extracted = input1 << (0x20 - result2 & 0xff);\n    input1 = input1 >> (result2 & 0xff) | input2 << (0x20 - result2 & 0xff);\n    input2 = input2 >> (result2 & 0xff);\n    count2 = result2 + 0x432;\n  }\n  if (0xfffff < input2) {\n    if (0x1fffff < input2) {\n      result2 = input2 & 1;\n      input2 = input2 >> 1;\n      bit1 = (byte)input1;\n      input1 = (uint)(result2 != 0) << 0x1f | input1 >> 1;\n      extracted = (uint)(bit1 & 1) << 0x1f | extracted >> 1;\n      count2 = count2 + 1;\n      if (0xffbfffff < (uint)(count2 * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_080083e0:\n    carry2 = 0x7fffffff < extracted;\n    if (extracted == 0x80000000) {\n      carry2 = (input1 & 1) != 0;\n    }\n    return CONCAT44(input2 + count2 * 0x100000 + (uint)CARRY4(input1,(uint)carry2),input1 + carry2\n                   );\n  }\n  carry1 = (extracted & 0x80000000) != 0;\n  extracted = extracted << 1;\n  result2 = input1 * 2;\n  carry2 = CARRY4(input1,input1);\n  input1 = input1 * 2 + (uint)carry1;\n  input2 = input2 * 2 + (uint)(carry2 || CARRY4(result2,(uint)carry1));\n  carry2 = count2 != 0;\n  count2 = count2 + -1;\n  if (carry2 && 0xfffff < input2) goto LAB_080083e0;\n  result1 = input1;\n  result2 = input2;\n  if (input2 == 0) {\n    result1 = 0;\n    result2 = input1;\n  }\n  count1 = LZCOUNT(result2);\n  if (input2 == 0) {\n    count1 = count1 + 0x20;\n  }\n  shift2 = count1 - 0xb;\n  carry3 = SBORROW4(shift2,0x20);\n  shift1 = count1 - 0x2b;\n  carry2 = (int)shift1 < 0;\n  carry1 = shift1 == 0;\n  if ((int)shift2 < 0x20) {\n    carry3 = SCARRY4(shift1,0xc);\n    count1 = count1 + -0x1f;\n    carry2 = count1 < 0;\n    carry1 = count1 == 0;\n    shift1 = shift2;\n    if (!carry1 && carry2 == carry3) {\n      result1 = result2 << (shift2 & 0xff);\n      result2 = result2 >> (0xcU - count1 & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (carry1 || carry2 != carry3) {\n    extracted = 0x20 - shift1;\n  }\n  result2 = result2 << (shift1 & 0xff);\n  if (carry1 || carry2 != carry3) {\n    result2 = result2 | result1 >> (extracted & 0xff);\n  }\n  if (carry1 || carry2 != carry3) {\n    result1 = result1 << (shift1 & 0xff);\n  }\nLAB_08008458:\n  if ((int)shift2 <= count2) {\n    return CONCAT44(result2 + (count2 - shift2) * 0x100000,result1);\n  }\n  extracted = ~(count2 - shift2);\n  if ((int)extracted < 0x1f) {\n    count2 = extracted - 0x13;\n    if (count2 != 0 && count2 < 0 == SCARRY4(extracted - 0x1f,0xc)) {\n      return (ulonglong)(result1 >> (0x20 - (0xcU - count2) & 0xff) | result2 << (0xcU - count2 & 0xff));\n    }\n    extracted = extracted + 1;\n    return CONCAT44(result2 >> (extracted & 0xff),result1 >> (extracted & 0xff) | result2 << (0x20 - extracted & 0xff)\n                   );\n  }\n  return (ulonglong)(result2 >> (extracted - 0x1f & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080085d4": "calculate_result_080085d4",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "bit1",
                "uVar2": "result1",
                "uVar3": "shift1",
                "uVar4": "result2",
                "iVar5": "count1",
                "uVar6": "shift2",
                "iVar7": "count2",
                "uVar8": "extracted",
                "bVar9": "carry1",
                "bVar10": "carry2",
                "bVar11": "carry3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080085e4": {
            "entrypoint": "0x080085e4",
            "current_name": "reverse_bits_080085e4",
            "code": "\nulonglong reverseBits_080085e4(uint input1,uint input2)\n\n{\n  byte bit1;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int count;\n  uint shift;\n  int shiftCount;\n  uint resultUpper;\n  uint resultLower;\n  bool carry;\n  bool flag;\n  bool isOverflow;\n  \n  if ((input1 | input2) == 0) {\n    return CONCAT44(input2,input1);\n  }\n  resultUpper = input2 & 0x80000000;\n  temp2 = input2;\n  if ((int)resultUpper < 0) {\n    flag = input1 != 0;\n    input1 = -input1;\n    temp2 = -input2 - (uint)flag;\n  }\n  shiftCount = 0x432;\n  resultLower = temp2 >> 0x16;\n  if (resultLower != 0) {\n    shiftCount = 3;\n    if (temp2 >> 0x19 != 0) {\n      shiftCount = 6;\n    }\n    if (temp2 >> 0x1c != 0) {\n      shiftCount = shiftCount + 3;\n    }\n    temp3 = shiftCount - ((int)temp2 >> 0x1f);\n    resultLower = input1 << (0x20 - temp3 & 0xff);\n    input1 = input1 >> (temp3 & 0xff) | temp2 << (0x20 - temp3 & 0xff);\n    temp2 = temp2 >> (temp3 & 0xff);\n    shiftCount = temp3 + 0x432;\n  }\n  if (0xfffff < temp2) {\n    if (0x1fffff < temp2) {\n      temp3 = temp2 & 1;\n      temp2 = temp2 >> 1;\n      bit1 = (byte)input1;\n      input1 = (uint)(temp3 != 0) << 0x1f | input1 >> 1;\n      resultLower = (uint)(bit1 & 1) << 0x1f | resultLower >> 1;\n      shiftCount = shiftCount + 1;\n      if (0xffbfffff < (uint)(shiftCount * 0x200000)) {\n        return (ulonglong)(resultUpper | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_080083e0:\n    flag = 0x7fffffff < resultLower;\n    if (resultLower == 0x80000000) {\n      flag = (input1 & 1) != 0;\n    }\n    return CONCAT44(temp2 + shiftCount * 0x100000 + (uint)CARRY4(input1,(uint)flag) | resultUpper,\n                    input1 + flag);\n  }\n  carry = (resultLower & 0x80000000) != 0;\n  resultLower = resultLower << 1;\n  temp3 = input1 * 2;\n  flag = CARRY4(input1,input1);\n  input1 = input1 * 2 + (uint)carry;\n  temp2 = temp2 * 2 + (uint)(flag || CARRY4(temp3,(uint)carry));\n  flag = shiftCount != 0;\n  shiftCount = shiftCount + -1;\n  if (flag && 0xfffff < temp2) goto LAB_080083e0;\n  temp1 = input1;\n  temp3 = temp2;\n  if (temp2 == 0) {\n    temp1 = 0;\n    temp3 = input1;\n  }\n  count = LZCOUNT(temp3);\n  if (temp2 == 0) {\n    count = count + 0x20;\n  }\n  shift = count - 0xb;\n  isOverflow = SBORROW4(shift,0x20);\n  temp2 = count - 0x2b;\n  flag = (int)temp2 < 0;\n  carry = temp2 == 0;\n  if ((int)shift < 0x20) {\n    isOverflow = SCARRY4(temp2,0xc);\n    count = count + -0x1f;\n    flag = count < 0;\n    carry = count == 0;\n    temp2 = shift;\n    if (!carry && flag == isOverflow) {\n      temp1 = temp3 << (shift & 0xff);\n      temp3 = temp3 >> (0xcU - count & 0xff);\n      goto LAB_08008458;\n    }\n  }\n  if (carry || flag != isOverflow) {\n    resultLower = 0x20 - temp2;\n  }\n  temp3 = temp3 << (temp2 & 0xff);\n  if (carry || flag != isOverflow) {\n    temp3 = temp3 | temp1 >> (resultLower & 0xff);\n  }\n  if (carry || flag != isOverflow) {\n    temp1 = temp1 << (temp2 & 0xff);\n  }\nLAB_08008458:\n  if ((int)shift <= shiftCount) {\n    return CONCAT44(temp3 + (shiftCount - shift) * 0x100000 | resultUpper,temp1);\n  }\n  temp2 = ~(shiftCount - shift);\n  if ((int)temp2 < 0x1f) {\n    shiftCount = temp2 - 0x13;\n    if (shiftCount != 0 && shiftCount < 0 == SCARRY4(temp2 - 0x1f,0xc)) {\n      return CONCAT44(input2,temp1 >> (0x20 - (0xcU - shiftCount) & 0xff) |\n                              temp3 << (0xcU - shiftCount & 0xff)) & 0x80000000ffffffff;\n    }\n    temp2 = temp2 + 1;\n    return CONCAT44(resultUpper | temp3 >> (temp2 & 0xff),\n                    temp1 >> (temp2 & 0xff) | temp3 << (0x20 - temp2 & 0xff));\n  }\n  return CONCAT44(input2,temp3 >> (temp2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_080085e4": "reverse_bits_080085e4",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "bit1",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "iVar5": "count",
                "uVar6": "shift",
                "iVar7": "shiftCount",
                "uVar8": "resultUpper",
                "uVar9": "resultLower",
                "bVar10": "carry",
                "bVar11": "flag",
                "bVar12": "isOverflow"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008640": {
            "entrypoint": "0x08008640",
            "current_name": "calculate_result_08008640",
            "code": "\nulonglong calculate_result_08008640(undefined4 input_param_1,uint input_param_2,uint input_param_3,uint input_param_4)\n\n{\n  ulonglong mul_result;\n  longlong temp_var;\n  uint temp_var_1;\n  uint temp_var_2;\n  int temp_var_3;\n  uint temp_var_4;\n  uint unaff_r5;\n  uint temp_var_5;\n  uint temp_var_6;\n  bool bool_var_1;\n  bool bool_var_2;\n  bool bool_var_3;\n  ulonglong concat_result;\n  \n  concat_result = CONCAT44(input_param_2,input_param_1);\n  temp_var_5 = 0x7ff;\n  temp_var_2 = input_param_2 >> 0x14 & 0x7ff;\n  bool_var_1 = temp_var_2 == 0;\n  if (!bool_var_1) {\n    unaff_r5 = input_param_4 >> 0x14 & 0x7ff;\n    bool_var_1 = unaff_r5 == 0;\n  }\n  if (!bool_var_1) {\n    bool_var_1 = temp_var_2 == 0x7ff;\n  }\n  if (!bool_var_1) {\n    bool_var_1 = unaff_r5 == 0x7ff;\n  }\n  if (bool_var_1) {\n    concat_result = calculate_bitwise_and_shift_0800881c();\n  }\n  temp_var_1 = (uint)(concat_result >> 0x20);\n  temp_var_3 = temp_var_2 + unaff_r5;\n  temp_var_2 = temp_var_1 ^ input_param_4;\n  temp_var_1 = temp_var_1 & ~(temp_var_5 << 0x15);\n  input_param_4 = input_param_4 & ~(temp_var_5 << 0x15);\n  bool_var_1 = ((uint)concat_result | temp_var_1 << 0xc) == 0;\n  if (!bool_var_1) {\n    bool_var_1 = (input_param_3 | input_param_4 << 0xc) == 0;\n  }\n  temp_var_1 = temp_var_1 | 0x100000;\n  input_param_4 = input_param_4 | 0x100000;\n  if (bool_var_1) {\n    input_param_3 = (uint)concat_result | input_param_3;\n    input_param_4 = (temp_var_2 & 0x80000000 | temp_var_1) ^ input_param_4;\n    temp_var_2 = temp_var_5 >> 1;\n    bool_var_3 = SBORROW4(temp_var_3,temp_var_2);\n    temp_var_4 = temp_var_3 - temp_var_2;\n    bool_var_1 = temp_var_4 == 0;\n    temp_var_1 = temp_var_4;\n    if (!bool_var_1 && (int)temp_var_2 <= temp_var_3) {\n      bool_var_3 = SBORROW4(temp_var_5,temp_var_4);\n      temp_var_1 = temp_var_5 - temp_var_4;\n      bool_var_1 = temp_var_5 == temp_var_4;\n    }\n    if (!bool_var_1 && (int)temp_var_1 < 0 == bool_var_3) {\n      input_param_4 = input_param_4 | temp_var_4 * 0x100000;\n    }\n    if (!bool_var_1 && (int)temp_var_1 < 0 == bool_var_3) {\n      return CONCAT44(input_param_4,input_param_3);\n    }\n    input_param_4 = input_param_4 | 0x100000;\n    temp_var_5 = 0;\n    bool_var_3 = SBORROW4(temp_var_4,1);\n    temp_var_4 = temp_var_4 - 1;\n    bool_var_1 = temp_var_4 == 0;\n    temp_var_2 = temp_var_4;\n  }\n  else {\n    mul_result = (concat_result & 0xffffffff) * (ulonglong)input_param_3;\n    concat_result = (concat_result & 0xffffffff) * (ulonglong)input_param_4 +\n             (ulonglong)temp_var_1 * (ulonglong)input_param_3 + (mul_result >> 0x20);\n    temp_var_6 = (uint)concat_result;\n    temp_var = (ulonglong)temp_var_1 * (ulonglong)input_param_4 + (concat_result >> 0x20);\n    temp_var_5 = (uint)temp_var;\n    temp_var_1 = (uint)((ulonglong)temp_var >> 0x20);\n    if ((int)mul_result != 0) {\n      temp_var_6 = temp_var_6 | 1;\n    }\n    temp_var_4 = (temp_var_3 + -0x3ff) - (uint)(temp_var_1 < 0x200);\n    if (temp_var_1 < 0x200) {\n      bool_var_1 = (temp_var_6 & 0x80000000) != 0;\n      temp_var_6 = temp_var_6 << 1;\n      temp_var = CONCAT44(temp_var_1 * 2 + (uint)(CARRY4(temp_var_5,temp_var_5) || CARRY4(temp_var_5 * 2,(uint)bool_var_1)),\n                       temp_var_5 * 2 + (uint)bool_var_1);\n    }\n    input_param_4 = temp_var_2 & 0x80000000 | (int)((ulonglong)temp_var >> 0x20) << 0xb | (uint)temp_var >> 0x15;\n    input_param_3 = (uint)temp_var << 0xb | temp_var_6 >> 0x15;\n    temp_var_5 = temp_var_6 * 0x800;\n    bool_var_2 = 0xfc < temp_var_4;\n    bool_var_3 = SBORROW4(temp_var_4,0xfd);\n    temp_var_1 = temp_var_4 - 0xfd;\n    bool_var_1 = temp_var_1 == 0;\n    temp_var_2 = temp_var_1;\n    if (bool_var_2 && !bool_var_1) {\n      bool_var_2 = 0x6ff < temp_var_1;\n      bool_var_3 = SBORROW4(temp_var_1,0x700);\n      temp_var_2 = temp_var_4 - 0x7fd;\n      bool_var_1 = temp_var_1 == 0x700;\n    }\n    if (!bool_var_2 || bool_var_1) {\n      bool_var_1 = 0x7fffffff < temp_var_5;\n      if (temp_var_5 == 0x80000000) {\n        bool_var_1 = (temp_var_6 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(input_param_4 + temp_var_4 * 0x100000 + (uint)CARRY4(input_param_3,(uint)bool_var_1),input_param_3 + bool_var_1\n                     );\n    }\n  }\n  if (!bool_var_1 && (int)temp_var_2 < 0 == bool_var_3) {\n    return (ulonglong)(input_param_4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  bool_var_2 = SCARRY4(temp_var_4,0x36);\n  bool_var_1 = (int)(temp_var_4 + 0x36) < 0;\n  bool_var_3 = temp_var_4 == 0xffffffca;\n  if (bool_var_3 || bool_var_1 != bool_var_2) {\n    input_param_3 = 0;\n  }\n  if (bool_var_3 || bool_var_1 != bool_var_2) {\n    input_param_4 = input_param_4 & 0x80000000;\n  }\n  if (bool_var_3 || bool_var_1 != bool_var_2) {\n    return CONCAT44(input_param_4,input_param_3);\n  }\n  temp_var_2 = -temp_var_4;\n  temp_var_1 = temp_var_2 - 0x20;\n  if (0x1f < (int)temp_var_2) {\n    temp_var_4 = input_param_3 >> (temp_var_1 & 0xff) | input_param_4 << (0x20 - temp_var_1 & 0xff);\n    temp_var_2 = (input_param_4 >> (temp_var_1 & 0xff) & ~((input_param_4 & 0x80000000) >> (temp_var_1 & 0xff))) -\n            ((int)temp_var_4 >> 0x1f);\n    if ((temp_var_5 | input_param_3 << (0x20 - temp_var_1 & 0xff) | temp_var_4 << 1) == 0) {\n      temp_var_2 = temp_var_2 & ~(temp_var_4 >> 0x1f);\n    }\n    return CONCAT44(input_param_4,temp_var_2) & 0x80000000ffffffff;\n  }\n  temp_var_3 = temp_var_2 - 0x14;\n  if (temp_var_3 == 0 || temp_var_3 < 0 != SCARRY4(temp_var_1,0xc)) {\n    temp_var_6 = input_param_3 << (temp_var_4 + 0x20 & 0xff);\n    temp_var_1 = input_param_3 >> (temp_var_2 & 0xff) | input_param_4 << (temp_var_4 + 0x20 & 0xff);\n    temp_var_4 = temp_var_1 + -((int)temp_var_6 >> 0x1f);\n    if ((temp_var_5 | temp_var_6 << 1) == 0) {\n      temp_var_4 = temp_var_4 & ~(temp_var_6 >> 0x1f);\n    }\n    return CONCAT44((input_param_4 & 0x80000000) +\n                    ((input_param_4 & 0x7fffffff) >> (temp_var_2 & 0xff)) +\n                    (uint)CARRY4(temp_var_1,-((int)temp_var_6 >> 0x1f)),temp_var_4);\n  }\n  temp_var_2 = 0xc - temp_var_3;\n  temp_var_4 = input_param_3 << (temp_var_2 & 0xff);\n  temp_var_2 = input_param_3 >> (0x20 - temp_var_2 & 0xff) | input_param_4 << (temp_var_2 & 0xff);\n  temp_var_1 = temp_var_2 + -((int)temp_var_4 >> 0x1f);\n  if ((temp_var_5 | temp_var_4 << 1) == 0) {\n    temp_var_1 = temp_var_1 & ~(temp_var_4 >> 0x1f);\n  }\n  return CONCAT44((input_param_4 & 0x80000000) + (uint)CARRY4(temp_var_2,-((int)temp_var_4 >> 0x1f)),temp_var_1);\n}\n\n",
            "renaming": {
                "FUN_08008640": "calculate_result_08008640",
                "param_1": "input_param_1",
                "param_2": "input_param_2",
                "param_3": "input_param_3",
                "param_4": "input_param_4",
                "uVar1": "mul_result",
                "lVar2": "temp_var",
                "uVar3": "temp_var_1",
                "uVar4": "temp_var_2",
                "iVar5": "temp_var_3",
                "uVar6": "temp_var_4",
                "uVar7": "temp_var_5",
                "uVar8": "temp_var_6",
                "bVar9": "bool_var_1",
                "bVar10": "bool_var_2",
                "bVar11": "bool_var_3",
                "uVar12": "concat_result"
            },
            "calling": [
                "__ieee754_rem_pio2",
                "to_millimeters",
                "calculate_trapezoid_for_block",
                "atan",
                "report_realtime_status",
                "__kernel_rem_pio2",
                "homing_cycle",
                "__kernel_sin",
                "plan_buffer_line",
                "scalbn",
                "read_float",
                "__ieee754_sqrt",
                "mc_arc",
                "__ieee754_hypot",
                "report_gcode_modes",
                "__kernel_cos",
                "report_gcode_parameters"
            ],
            "called": [
                "FUN_0800881c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800881c": {
            "entrypoint": "0x0800881c",
            "current_name": "calculate_bitwise_and_shift_0800881c",
            "code": "\nulonglong calculate_bitwise_and_shift_0800881c(uint input_param_1,uint input_param_2,uint input_param_3,uint input_param_4)\n\n{\n  uint temp_var_1;\n  uint temp_var_2;\n  uint temp_var_3;\n  uint temp_var_4;\n  uint temp_var_5;\n  bool temp_var_6;\n  \n  temp_var_3 = temp_var_5 & input_param_4 >> 0x14;\n  if (temp_var_2 != temp_var_5 && temp_var_3 != temp_var_5) {\n    temp_var_6 = (input_param_1 | input_param_2 << 1) == 0;\n    if (!temp_var_6) {\n      temp_var_6 = (input_param_3 | input_param_4 << 1) == 0;\n    }\n    if (temp_var_6) {\n      return (ulonglong)((input_param_2 ^ input_param_4) & 0x80000000) << 0x20;\n    }\n    if (temp_var_2 == 0) {\n      temp_var_4 = input_param_2 & 0x80000000;\n      do {\n        temp_var_1 = input_param_1 & 0x80000000;\n        input_param_1 = input_param_1 << 1;\n        input_param_2 = input_param_2 * 2 + (uint)(temp_var_1 != 0);\n      } while ((input_param_2 & 0x100000) == 0);\n      input_param_2 = input_param_2 | temp_var_4;\n      if (temp_var_3 != 0) {\n        return CONCAT44(input_param_2,input_param_1);\n      }\n    }\n    do {\n      temp_var_3 = input_param_3 & 0x80000000;\n      input_param_3 = input_param_3 << 1;\n      input_param_4 = input_param_4 * 2 + (uint)(temp_var_3 != 0);\n    } while ((input_param_4 & 0x100000) == 0);\n    return CONCAT44(input_param_2,input_param_1);\n  }\n  temp_var_6 = (input_param_1 | input_param_2 << 1) == 0;\n  if (temp_var_6) {\n    input_param_2 = input_param_4;\n    input_param_1 = input_param_3;\n  }\n  if (!temp_var_6) {\n    temp_var_6 = (input_param_3 | input_param_4 << 1) == 0;\n  }\n  temp_var_4 = input_param_2;\n  if (((!temp_var_6) && ((temp_var_2 != temp_var_5 || ((input_param_1 | input_param_2 << 0xc) == 0)))) &&\n     ((temp_var_3 != temp_var_5 || (input_param_1 = input_param_3, temp_var_4 = input_param_4, (input_param_3 | input_param_4 << 0xc) == 0)))) {\n    return (ulonglong)((input_param_2 ^ input_param_4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(temp_var_4,input_param_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_0800881c": "calculate_bitwise_and_shift_0800881c",
                "param_1": "input_param_1",
                "param_2": "input_param_2",
                "param_3": "input_param_3",
                "param_4": "input_param_4",
                "uVar1": "temp_var_1",
                "unaff_r4": "temp_var_2",
                "uVar2": "temp_var_3",
                "uVar3": "temp_var_4",
                "in_r12": "temp_var_5",
                "bVar4": "temp_var_6"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008894": {
            "entrypoint": "0x08008894",
            "current_name": "calculate_floating_point_08008894",
            "code": "\nulonglong calculateFloatingPoint_08008894(undefined4 num1,uint num2,uint num3,uint num4)\n\n{\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  int temp8;\n  uint temp9;\n  uint temp10;\n  uint temp11;\n  uint temp12;\n  uint temp13;\n  uint temp14;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  undefined8 result;\n  \n  result = CONCAT44(num2,num1);\n  temp14 = 0x7ff;\n  temp7 = num2 >> 0x14 & 0x7ff;\n  flag1 = temp7 == 0;\n  if (!flag1) {\n    temp10 = num4 >> 0x14 & 0x7ff;\n    flag1 = temp10 == 0;\n  }\n  if (!flag1) {\n    flag1 = temp7 == 0x7ff;\n  }\n  if (!flag1) {\n    flag1 = temp10 == 0x7ff;\n  }\n  if (flag1) {\n    result = convert_to_double_08008a02();\n  }\n  temp9 = (uint)((ulonglong)result >> 0x20);\n  temp12 = (uint)result;\n  temp8 = temp7 - temp10;\n  if ((num3 | num4 << 0xc) == 0) {\n    temp7 = (temp9 ^ num4) & 0x80000000 | temp9 & 0xfffff;\n    flag3 = SCARRY4(temp8,temp14 >> 1);\n    temp9 = temp8 + (temp14 >> 1);\n    flag1 = (int)temp9 < 0;\n    flag2 = temp9 == 0;\n    if (!flag2 && flag1 == flag3) {\n      flag3 = SBORROW4(temp14,temp9);\n      flag1 = (int)(temp14 - temp9) < 0;\n      flag2 = temp14 == temp9;\n    }\n    if (!flag2 && flag1 == flag3) {\n      temp7 = temp7 | temp9 * 0x100000;\n    }\n    if (!flag2 && flag1 == flag3) {\n      return CONCAT44(temp7,temp12);\n    }\n    temp7 = temp7 | 0x100000;\n    temp14 = 0;\n    flag2 = SBORROW4(temp9,1);\n    temp9 = temp9 - 1;\n    flag1 = temp9 == 0;\n    temp3 = temp9;\n  }\n  else {\n    temp3 = (num4 << 0xc) >> 4 | 0x10000000 | num3 >> 0x18;\n    temp14 = num3 << 8;\n    temp11 = (temp9 << 0xc) >> 4 | 0x10000000 | temp12 >> 0x18;\n    temp12 = temp12 * 0x100;\n    temp7 = (temp9 ^ num4) & 0x80000000;\n    flag1 = temp3 <= temp11;\n    if (temp11 == temp3) {\n      flag1 = temp14 <= temp12;\n    }\n    temp8 = temp8 + (uint)flag1;\n    temp9 = temp8 + 0x3fd;\n    if (flag1 == false) {\n      temp3 = temp3 >> 1;\n      temp14 = (uint)((num3 >> 0x18 & 1) != 0) << 0x1f | temp14 >> 1;\n    }\n    temp13 = temp12 - temp14;\n    temp11 = (temp11 - temp3) - (uint)(temp12 < temp14);\n    temp4 = temp3 >> 1;\n    temp1 = (uint)((temp3 & 1) != 0) << 0x1f | temp14 >> 1;\n    temp12 = 0x100000;\n    temp3 = 0x80000;\n    while( true ) {\n      flag1 = temp1 <= temp13;\n      if (temp4 < temp11 || temp11 - temp4 < (uint)flag1) {\n        temp13 = temp13 - temp1;\n        temp12 = temp12 | temp3;\n        temp11 = (temp11 - temp4) - (uint)!flag1;\n      }\n      temp5 = temp4 >> 1;\n      temp1 = (uint)((temp4 & 1) != 0) << 0x1f | temp1 >> 1;\n      flag2 = temp1 <= temp13;\n      flag1 = temp11 - temp5 < (uint)flag2;\n      temp14 = temp11;\n      if (temp5 < temp11 || flag1) {\n        temp13 = temp13 - temp1;\n        temp14 = (temp11 - temp5) - (uint)!flag2;\n      }\n      if (temp5 < temp11 || flag1) {\n        temp12 = temp12 | temp3 >> 1;\n      }\n      temp11 = temp4 >> 2;\n      temp2 = (uint)((temp5 & 1) != 0) << 0x1f | temp1 >> 1;\n      flag2 = temp2 <= temp13;\n      flag1 = temp14 - temp11 < (uint)flag2;\n      temp5 = temp14;\n      if (temp11 < temp14 || flag1) {\n        temp13 = temp13 - temp2;\n        temp5 = (temp14 - temp11) - (uint)!flag2;\n      }\n      if (temp11 < temp14 || flag1) {\n        temp12 = temp12 | temp3 >> 2;\n      }\n      temp6 = temp4 >> 3;\n      temp1 = (uint)((temp11 & 1) != 0) << 0x1f | temp2 >> 1;\n      flag2 = temp1 <= temp13;\n      flag1 = temp5 - temp6 < (uint)flag2;\n      temp11 = temp5;\n      if (temp6 < temp5 || flag1) {\n        temp13 = temp13 - temp1;\n        temp11 = (temp5 - temp6) - (uint)!flag2;\n      }\n      if (temp6 < temp5 || flag1) {\n        temp12 = temp12 | temp3 >> 3;\n      }\n      temp14 = temp11 | temp13;\n      if (temp14 == 0) break;\n      temp11 = temp11 << 4 | temp13 >> 0x1c;\n      temp13 = temp13 << 4;\n      temp4 = temp4 & 0xfffffff8 | temp1 >> 0x1d;\n      temp1 = (temp2 >> 1) << 3;\n      temp3 = temp3 >> 4;\n      if (temp3 == 0) {\n        temp6 = temp4;\n        if ((temp7 & 0x100000) != 0) goto LAB_080089b2;\n        temp7 = temp7 | temp12;\n        temp12 = 0;\n        temp3 = 0x80000000;\n      }\n    }\n    if ((temp7 & 0x100000) == 0) {\n      temp7 = temp7 | temp12;\n      temp12 = 0;\n    }\nLAB_080089b2:\n    flag3 = 0xfc < temp9;\n    flag2 = SBORROW4(temp9,0xfd);\n    temp4 = temp8 + 0x300;\n    flag1 = temp4 == 0;\n    temp3 = temp4;\n    if (flag3 && !flag1) {\n      flag3 = 0x6ff < temp4;\n      flag2 = SBORROW4(temp4,0x700);\n      temp3 = temp8 - 0x400;\n      flag1 = temp4 == 0x700;\n    }\n    if (!flag3 || flag1) {\n      flag1 = temp6 <= temp11;\n      if (temp11 == temp6) {\n        flag1 = temp1 <= temp13;\n      }\n      if (temp11 == temp6 && temp13 == temp1) {\n        flag1 = (temp12 & 1) != 0;\n      }\n      return CONCAT44(temp7 + temp9 * 0x100000 + (uint)CARRY4(temp12,(uint)flag1),temp12 + flag1);\n    }\n  }\n  if (!flag1 && (int)temp3 < 0 == flag2) {\n    return (ulonglong)(temp7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag3 = SCARRY4(temp9,0x36);\n  flag1 = (int)(temp9 + 0x36) < 0;\n  flag2 = temp9 == 0xffffffca;\n  if (flag2 || flag1 != flag3) {\n    temp12 = 0;\n  }\n  if (flag2 || flag1 != flag3) {\n    temp7 = temp7 & 0x80000000;\n  }\n  if (flag2 || flag1 != flag3) {\n    return CONCAT44(temp7,temp12);\n  }\n  temp3 = -temp9;\n  temp11 = temp3 - 0x20;\n  if (0x1f < (int)temp3) {\n    temp3 = temp12 >> (temp11 & 0xff) | temp7 << (0x20 - temp11 & 0xff);\n    temp9 = (temp7 >> (temp11 & 0xff) & ~((temp7 & 0x80000000) >> (temp11 & 0xff))) -\n            ((int)temp3 >> 0x1f);\n    if ((temp14 | temp12 << (0x20 - temp11 & 0xff) | temp3 << 1) == 0) {\n      temp9 = temp9 & ~(temp3 >> 0x1f);\n    }\n    return CONCAT44(temp7,temp9) & 0x80000000ffffffff;\n  }\n  temp8 = temp3 - 0x14;\n  if (temp8 != 0 && temp8 < 0 == SCARRY4(temp11,0xc)) {\n    temp9 = 0xc - temp8;\n    temp3 = temp12 << (temp9 & 0xff);\n    temp12 = temp12 >> (0x20 - temp9 & 0xff) | temp7 << (temp9 & 0xff);\n    temp9 = temp12 + -((int)temp3 >> 0x1f);\n    if ((temp14 | temp3 << 1) == 0) {\n      temp9 = temp9 & ~(temp3 >> 0x1f);\n    }\n    return CONCAT44((temp7 & 0x80000000) + (uint)CARRY4(temp12,-((int)temp3 >> 0x1f)),temp9);\n  }\n  temp11 = temp12 << (temp9 + 0x20 & 0xff);\n  temp12 = temp12 >> (temp3 & 0xff) | temp7 << (temp9 + 0x20 & 0xff);\n  temp9 = temp12 + -((int)temp11 >> 0x1f);\n  if ((temp14 | temp11 << 1) == 0) {\n    temp9 = temp9 & ~(temp11 >> 0x1f);\n  }\n  return CONCAT44((temp7 & 0x80000000) +\n                  ((temp7 & 0x7fffffff) >> (temp3 & 0xff)) +\n                  (uint)CARRY4(temp12,-((int)temp11 >> 0x1f)),temp9);\n}\n\n",
            "renaming": {
                "FUN_08008894": "calculate_floating_point_08008894",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "num3",
                "param_4": "num4",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "uVar6": "temp6",
                "uVar7": "temp7",
                "iVar8": "temp8",
                "uVar9": "temp9",
                "unaff_r5": "temp10",
                "uVar10": "temp11",
                "uVar11": "temp12",
                "uVar12": "temp13",
                "uVar13": "temp14",
                "bVar14": "flag1",
                "bVar15": "flag2",
                "bVar16": "flag3",
                "uVar17": "result"
            },
            "calling": [
                "gc_execute_line",
                "__ieee754_atan2",
                "__ieee754_sqrt",
                "sqrt",
                "atan",
                "homing_cycle",
                "plan_buffer_line"
            ],
            "called": [
                "FUN_08008a02"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008a02": {
            "entrypoint": "0x08008a02",
            "current_name": "convert_to_double_08008a02",
            "code": "\nulonglong convertToDouble_08008a02(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint bit1;\n  uint bit2;\n  uint bit3;\n  uint bit4;\n  uint mask;\n  bool isZero;\n  \n  bit3 = mask & input4 >> 0x14;\n  bit4 = input2;\n  if (bit2 != mask || bit3 != mask) {\n    if (bit2 == mask) {\n      if (((input1 | input2 << 0xc) == 0) && (input1 = input3, bit4 = input4, bit3 != mask)\n         ) {\nreturnSpecial1:\n        return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (bit3 == mask) {\n      input1 = input3;\n      bit4 = input4;\n      if ((input3 | input4 << 0xc) == 0) {\nreturnSpecial2:\n        return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      isZero = (input1 | input2 << 1) == 0;\n      if (!isZero) {\n        isZero = (input3 | input4 << 1) == 0;\n      }\n      if (!isZero) {\n        if (bit2 == 0) {\n          bit4 = input2 & 0x80000000;\n          do {\n            bit1 = input1 & 0x80000000;\n            input1 = input1 << 1;\n            input2 = input2 * 2 + (uint)(bit1 != 0);\n          } while ((input2 & 0x100000) == 0);\n          input2 = input2 | bit4;\n          if (bit3 != 0) {\n            return CONCAT44(input2,input1);\n          }\n        }\n        do {\n          bit4 = input3 & 0x80000000;\n          input3 = input3 << 1;\n          input4 = input4 * 2 + (uint)(bit4 != 0);\n        } while ((input4 & 0x100000) == 0);\n        return CONCAT44(input2,input1);\n      }\n      if ((input1 | input2 << 1) != 0) goto returnSpecial1;\n      if ((input3 | input4 << 1) != 0) goto returnSpecial2;\n    }\n  }\n  return CONCAT44(bit4,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_08008a02": "convert_to_double_08008a02",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "bit1",
                "unaff_r4": "bit2",
                "uVar2": "bit3",
                "uVar3": "bit4",
                "in_r12": "mask",
                "bVar4": "isZero",
                "LAB_08008874": "returnSpecial1",
                "LAB_08008838": "returnSpecial2"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008a64": {
            "entrypoint": "0x08008a64",
            "current_name": "check_parameters_08008a64",
            "code": "\nuint check_parameters_08008a64(uint num1,uint num2,uint num3,uint num4)\n\n{\n  uint result;\n  bool isZero;\n  bool isLessOrEqual;\n  \n  if (((int)(num2 << 1) >> 0x15 == -1 || (int)(num4 << 1) >> 0x15 == -1) &&\n     ((((int)(num2 << 1) >> 0x15 == -1 && ((num1 | num2 << 0xc) != 0)) ||\n      (((int)(num4 << 1) >> 0x15 == -1 && ((num3 | num4 << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  isZero = (num1 | num2 << 1) == 0;\n  if (isZero) {\n    isZero = (num3 | num4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = num2 == num4;\n  }\n  if (isZero) {\n    isZero = num1 == num3;\n  }\n  if (!isZero) {\n    result = num2 ^ num4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = num2 == num4;\n    }\n    isLessOrEqual = -1 < (int)result && num4 <= num2;\n    if (isZero) {\n      isLessOrEqual = num3 <= num1;\n    }\n    num4 = (int)num4 >> 0x1f;\n    if (!isLessOrEqual) {\n      num4 = ~num4;\n    }\n    return num4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08008a64": "check_parameters_08008a64",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "num3",
                "param_4": "num4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isLessOrEqual"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008a6c": {
            "entrypoint": "0x08008a6c",
            "current_name": "check_equality_and_bitwise_08008a6c",
            "code": "\nuint check_equality_and_bitwise_08008a6c(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint result;\n  bool input1_and_input2_zero;\n  bool input4_less_than_or_equal_input2;\n  \n  if (((int)(input2 << 1) >> 0x15 == -1 || (int)(input4 << 1) >> 0x15 == -1) &&\n     ((((int)(input2 << 1) >> 0x15 == -1 && ((input1 | input2 << 0xc) != 0)) ||\n      (((int)(input4 << 1) >> 0x15 == -1 && ((input3 | input4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  input1_and_input2_zero = (input1 | input2 << 1) == 0;\n  if (input1_and_input2_zero) {\n    input1_and_input2_zero = (input3 | input4 << 1) == 0;\n  }\n  if (!input1_and_input2_zero) {\n    input1_and_input2_zero = input2 == input4;\n  }\n  if (input1_and_input2_zero) {\n    input1_and_input2_zero = input1 == input3;\n  }\n  if (!input1_and_input2_zero) {\n    result = input2 ^ input4;\n    input1_and_input2_zero = result == 0;\n    if (-1 < (int)result) {\n      input1_and_input2_zero = input2 == input4;\n    }\n    input4_less_than_or_equal_input2 = -1 < (int)result && input4 <= input2;\n    if (input1_and_input2_zero) {\n      input4_less_than_or_equal_input2 = input3 <= input1;\n    }\n    input4 = (int)input4 >> 0x1f;\n    if (!input4_less_than_or_equal_input2) {\n      input4 = ~input4;\n    }\n    return input4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08008a6c": "check_equality_and_bitwise_08008a6c",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "result",
                "bVar2": "input1_and_input2_zero",
                "bVar3": "input4_less_than_or_equal_input2"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008a74": {
            "entrypoint": "0x08008a74",
            "current_name": "check_conditions_08008a74",
            "code": "\nuint check_conditions_08008a74(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint result;\n  bool is_zero;\n  bool is_less_than_zero;\n  \n  if (((int)(input_2 << 1) >> 0x15 == -1 || (int)(input_4 << 1) >> 0x15 == -1) &&\n     ((((int)(input_2 << 1) >> 0x15 == -1 && ((input_1 | input_2 << 0xc) != 0)) ||\n      (((int)(input_4 << 1) >> 0x15 == -1 && ((input_3 | input_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  is_zero = (input_1 | input_2 << 1) == 0;\n  if (is_zero) {\n    is_zero = (input_3 | input_4 << 1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = input_2 == input_4;\n  }\n  if (is_zero) {\n    is_zero = input_1 == input_3;\n  }\n  if (!is_zero) {\n    result = input_2 ^ input_4;\n    is_zero = result == 0;\n    if (-1 < (int)result) {\n      is_zero = input_2 == input_4;\n    }\n    is_less_than_zero = -1 < (int)result && input_4 <= input_2;\n    if (is_zero) {\n      is_less_than_zero = input_3 <= input_1;\n    }\n    input_4 = (int)input_4 >> 0x1f;\n    if (!is_less_than_zero) {\n      input_4 = ~input_4;\n    }\n    return input_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08008a74": "check_conditions_08008a74",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "result",
                "bVar2": "is_zero",
                "bVar3": "is_less_than_zero"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008af0": {
            "entrypoint": "0x08008af0",
            "current_name": "compare_floating_point_values_08008af0",
            "code": "\nvoid compareFloatingPointValues_08008af0(undefined4 input1,undefined4 input2,undefined4 value1,undefined4 value2)\n\n{\n  __aeabi_cdcmpeq(value1,value2,input1,input2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af0": "compare_floating_point_values_08008af0",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "value1",
                "param_4": "value2"
            },
            "calling": [
                "__aeabi_dcmpge",
                "__aeabi_dcmpgt"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b00": {
            "entrypoint": "0x08008b00",
            "current_name": "calculate_result_08008b00",
            "code": "\nundefined4 calculateResult_08008b00(undefined4 input)\n\n{\n  performCalculation();\n  return input;\n}\n\n",
            "renaming": {
                "FUN_08008b00": "calculate_result_08008b00",
                "param_1": "input",
                "__nedf2": "performCalculation"
            },
            "calling": [
                "__aeabi_dcmplt",
                "__aeabi_dcmpeq",
                "__aeabi_dcmple",
                "__aeabi_cdrcmple"
            ],
            "called": [
                "__nedf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b10": {
            "entrypoint": "0x08008b10",
            "current_name": "check_condition_08008b10",
            "code": "\nbool check_condition_08008b10(void)\n\n{\n  char comparison_result;\n  \n  __aeabi_cdcmpeq();\n  return comparison_result != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08008b10": "check_condition_08008b10",
                "in_ZR": "comparison_result"
            },
            "calling": [
                "__ieee754_rem_pio2",
                "__kernel_rem_pio2"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b24": {
            "entrypoint": "0x08008b24",
            "current_name": "check_if_in_cy_is_null_08008b24",
            "code": "\nbool check_if_in_CY_is_null_08008b24(void)\n\n{\n  char input_character;\n  \n  __aeabi_cdcmpeq();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08008b24": "check_if_in_cy_is_null_08008b24",
                "in_CY": "input_character"
            },
            "calling": [
                "sqrt",
                "__ieee754_hypot",
                "plan_buffer_line"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b38": {
            "entrypoint": "0x08008b38",
            "current_name": "is_either_zero_08008b38",
            "code": "\nbool is_either_zero_08008b38(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_flag_set;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)is_carry_flag_set || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_08008b38": "is_either_zero_08008b38",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_flag_set"
            },
            "calling": [],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b4c": {
            "entrypoint": "0x08008b4c",
            "current_name": "check_least_upper_bound_08008b4c",
            "code": "\nbool check_least_upper_bound_08008b4c(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_enabled;\n  \n  __aeabi_cdrcmple();\n  return !(bool)is_carry_enabled || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_08008b4c": "check_least_upper_bound_08008b4c",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_enabled"
            },
            "calling": [
                "__kernel_rem_pio2"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b60": {
            "entrypoint": "0x08008b60",
            "current_name": "check_if_string_empty_08008b60",
            "code": "\nbool check_if_string_empty_08008b60(void)\n\n{\n  char input_character;\n  \n  __aeabi_cdrcmple();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08008b60": "check_if_string_empty_08008b60",
                "in_CY": "input_character"
            },
            "calling": [
                "ceil",
                "atan",
                "plan_buffer_line",
                "floor"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008b74": {
            "entrypoint": "0x08008b74",
            "current_name": "check_conditions_08008b74",
            "code": "\nundefined4 check_conditions_08008b74(uint value1,int value2,uint value3,int value4)\n\n{\n  if ((((value2 << 1) >> 0x15 != -1) || ((value1 | value2 << 0xc) == 0)) &&\n     (((value4 << 1) >> 0x15 != -1 || ((value3 | value4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08008b74": "check_conditions_08008b74",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4"
            },
            "calling": [
                "sqrt"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ba0": {
            "entrypoint": "0x08008ba0",
            "current_name": "extract_bits_08008ba0",
            "code": "\nuint extract_bits_08008ba0(uint input_value_1,uint input_value_2)\n\n{\n  uint result;\n  int shifted_value;\n  uint shift_amount;\n  \n  shifted_value = input_value_2 * 2 + 0x200000;\n  if (input_value_2 * 2 < 0xffe00000) {\n    if (-1 < shifted_value) {\n      return 0;\n    }\n    result = shifted_value >> 0x15;\n    shift_amount = -result - 0x3e1;\n    if (result < 0xfffffc20 && shift_amount != 0) {\n      result = (input_value_2 << 0xb | 0x80000000 | input_value_1 >> 0x15) >> (shift_amount & 0xff);\n      if ((input_value_2 & 0x80000000) != 0) {\n        result = -result;\n      }\n      return result;\n    }\n  }\n  else if ((input_value_1 | input_value_2 << 0xc) != 0) {\n    return 0;\n  }\n  input_value_2 = input_value_2 & 0x80000000;\n  if (input_value_2 == 0) {\n    input_value_2 = 0x7fffffff;\n  }\n  return input_value_2;\n}\n\n",
            "renaming": {
                "FUN_08008ba0": "extract_bits_08008ba0",
                "param_1": "input_value_1",
                "param_2": "input_value_2",
                "uVar1": "result",
                "iVar2": "shifted_value",
                "uVar3": "shift_amount"
            },
            "calling": [
                "gc_execute_line",
                "__ieee754_rem_pio2",
                "calculate_trapezoid_for_block",
                "lround",
                "__kernel_rem_pio2",
                "__kernel_sin",
                "__kernel_cos",
                "plan_buffer_line"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008bf0": {
            "entrypoint": "0x08008bf0",
            "current_name": "calculate_right_shift_08008bf0",
            "code": "\nuint calculateRightShift_08008bf0(uint input1,uint input2)\n\n{\n  int shiftedValue;\n  uint shiftAmount;\n  \n  if ((input2 & 0x80000000) != 0) {\n    return 0;\n  }\n  shiftedValue = input2 * 2 + 0x200000;\n  if (input2 * 2 < 0xffe00000) {\n    if (-1 < shiftedValue) {\n      return 0;\n    }\n    shiftAmount = -(shiftedValue >> 0x15) - 0x3e1;\n    if (-1 < (int)shiftAmount) {\n      return (input2 << 0xb | 0x80000000 | input1 >> 0x15) >> (shiftAmount & 0xff);\n    }\n  }\n  else if ((input1 | input2 << 0xc) != 0) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08008bf0": "calculate_right_shift_08008bf0",
                "param_1": "input1",
                "param_2": "input2",
                "iVar1": "shiftedValue",
                "uVar2": "shiftAmount"
            },
            "calling": [
                "gc_execute_line",
                "protocol_execute_line",
                "calculate_trapezoid_for_block",
                "mc_dwell",
                "mc_arc",
                "homing_cycle",
                "settings_store_global_setting",
                "plan_buffer_line"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008c30": {
            "entrypoint": "0x08008c30",
            "current_name": "floating_point_conversion_08008c30",
            "code": "\nuint floatingPointConversion_08008c30(uint inputValueNormalized,uint inputFlags)\n\n{\n  uint bitShiftedValue;\n  uint bitShift;\n  uint fraction;\n  uint adjustedValue;\n  bool isZero;\n  bool isNotLarge;\n  \n  bitShift = inputFlags * 2;\n  isNotLarge = bitShift < 0x70000000;\n  fraction = bitShift + 0x90000000;\n  bitShiftedValue = fraction;\n  if (!isNotLarge) {\n    adjustedValue = bitShift + 0x8fe00000;\n    bitShiftedValue = adjustedValue;\n  }\n  isZero = bitShiftedValue == 0;\n  if (!isNotLarge && fraction >= 0x200000) {\n    isZero = adjustedValue == 0x1fc00000;\n  }\n  if (((isNotLarge || fraction < 0x200000) || 0x1fc00000 < adjustedValue) || isZero) {\n    if ((inputFlags & 0x40000000) != 0) {\n      if (((int)bitShift >> 0x15 == -1) && ((inputValueNormalized | inputFlags << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return inputFlags & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(bitShift + 0x92e00000) < 0 != subtractionCarry(fraction,0x2e00000)) {\n      return inputFlags & 0x80000000;\n    }\n    bitShift = 0x18 - (bitShift + 0x92e00000 >> 0x15);\n    bitShiftedValue = inputValueNormalized >> (bitShift & 0xff);\n    if (inputValueNormalized << (0x20 - bitShift & 0xff) != 0) {\n      bitShiftedValue = bitShiftedValue | 1;\n    }\n    fraction = inputFlags & 0x1fffff | 0x100000;\n    inputValueNormalized = bitShiftedValue | fraction << (0x20 - bitShift & 0xff);\n    fraction = (fraction >> (bitShift & 0xff)) << 1;\n  }\n  bitShiftedValue = (inputFlags & 0x80000000 | inputValueNormalized >> 0x1d) + fraction * 4 + (uint)(0x7fffffff < inputValueNormalized * 8);\n  if (inputValueNormalized * 8 == 0x80000000) {\n    bitShiftedValue = bitShiftedValue & 0xfffffffe;\n  }\n  return bitShiftedValue;\n}\n\n",
            "renaming": {
                "FUN_08008c30": "floating_point_conversion_08008c30",
                "param_1": "inputValueNormalized",
                "param_2": "inputFlags",
                "uVar1": "bitShiftedValue",
                "uVar2": "bitShift",
                "uVar3": "fraction",
                "in_r12": "adjustedValue",
                "bVar4": "isZero",
                "bVar5": "isNotLarge",
                "SCARRY4": "subtractionCarry"
            },
            "calling": [
                "gc_execute_line",
                "to_millimeters",
                "read_float",
                "mc_arc",
                "report_realtime_status",
                "homing_cycle",
                "report_gcode_modes",
                "max_allowable_speed",
                "plan_buffer_line",
                "report_gcode_parameters"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008cd0": {
            "entrypoint": "0x08008cd0",
            "current_name": "apply_bitwise_complement_08008cd0",
            "code": "\nvoid applyBitwiseComplement_08008cd0(uint value)\n\n{\n  __addsf3(value ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008cd0": "apply_bitwise_complement_08008cd0",
                "param_1": "value"
            },
            "calling": [],
            "called": [
                "__addsf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008cd8": {
            "entrypoint": "0x08008cd8",
            "current_name": "float_to_fixed_point_08008cd8",
            "code": "\nuint floatToFixedPoint_08008cd8(uint value,uint fractionalBits,undefined4 param3,uint param4)\n\n{\n  int shiftRight;\n  int shiftRight2;\n  uint valueWithFractionalBits;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint difference;\n  bool isNegative;\n  \n  valueWithFractionalBits = fractionalBits ^ 0x80000000;\n  temp2 = value << 1;\n  isNegative = temp2 == 0;\n  if (!isNegative) {\n    param4 = fractionalBits << 1;\n    isNegative = param4 == 0;\n  }\n  if (!isNegative) {\n    isNegative = temp2 == param4;\n  }\n  shiftRight = (int)temp2 >> 0x18;\n  if (!isNegative) {\n    isNegative = shiftRight == -1;\n  }\n  if (!isNegative) {\n    isNegative = (int)param4 >> 0x18 == -1;\n  }\n  if (isNegative) {\n    shiftRight2 = (int)(fractionalBits << 1) >> 0x18;\n    if (shiftRight == -1 || shiftRight2 == -1) {\n      temp2 = valueWithFractionalBits;\n      if (shiftRight == -1) {\n        temp2 = value;\n      }\n      if (shiftRight != -1 || shiftRight2 != -1) {\n        valueWithFractionalBits = temp2;\n      }\n      isNegative = (temp2 & 0x7fffff) == 0;\n      if (isNegative) {\n        isNegative = (valueWithFractionalBits & 0x7fffff) == 0;\n      }\n      if (isNegative) {\n        isNegative = temp2 == valueWithFractionalBits;\n      }\n      if (!isNegative) {\n        temp2 = temp2 | 0x400000;\n      }\n      return temp2;\n    }\n    if (((value ^ valueWithFractionalBits) & 0x7fffffff) != 0) {\n      if (temp2 == 0) {\n        value = valueWithFractionalBits;\n      }\n      return value;\n    }\n    if (value != valueWithFractionalBits) {\n      return 0;\n    }\n    if ((temp2 & 0xff000000) == 0) {\n      valueWithFractionalBits = value << 1;\n      if ((value & 0x80000000) != 0) {\n        valueWithFractionalBits = valueWithFractionalBits | 0x80000000;\n      }\n      return valueWithFractionalBits;\n    }\n    if (temp2 < 0xfe000000) {\n      return value + 0x800000;\n    }\n    value = value & 0x80000000;\nLAB_08008e12:\n    return value | 0x7f800000;\n  }\n  temp2 = temp2 >> 0x18;\n  param4 = param4 >> 0x18;\n  difference = param4 - temp2;\n  isNegative = difference != 0;\n  temp3 = temp2;\n  if (isNegative && temp2 <= param4) {\n    temp3 = temp2 + difference;\n  }\n  if (isNegative && temp2 <= param4) {\n    valueWithFractionalBits = valueWithFractionalBits ^ value;\n  }\n  if (isNegative && temp2 <= param4) {\n    value = value ^ valueWithFractionalBits;\n  }\n  if (isNegative && temp2 <= param4) {\n    valueWithFractionalBits = valueWithFractionalBits ^ value;\n  }\n  if (param4 < temp2) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return value;\n  }\n  temp2 = value & 0xffffff | 0x800000;\n  if ((value & 0x80000000) != 0) {\n    temp2 = -temp2;\n  }\n  temp1 = valueWithFractionalBits & 0xffffff | 0x800000;\n  if ((valueWithFractionalBits & 0x80000000) != 0) {\n    temp1 = -temp1;\n  }\n  if (temp3 == difference) {\n    temp1 = temp1 ^ 0x800000;\n    if (temp3 == 0) {\n      temp2 = temp2 ^ 0x800000;\n      temp3 = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  temp2 = temp2 + ((int)temp1 >> (difference & 0xff));\n  temp1 = temp1 << (0x20 - difference & 0xff);\n  value = temp2 & 0x80000000;\n  if ((int)temp2 < 0) {\n    isNegative = temp1 != 0;\n    temp1 = -temp1;\n    temp2 = -temp2 - (uint)isNegative;\n  }\n  if (temp2 < 0x800000) {\n    valueWithFractionalBits = temp1 & 0x80000000;\n    temp1 = temp1 << 1;\n    temp2 = temp2 * 2 + (uint)(valueWithFractionalBits != 0);\n    valueWithFractionalBits = temp3 - 2;\n    if (temp3 - 1 == 0 || temp2 < 0x800000) {\n      difference = leadingZerosCount(temp2) - 8;\n      temp2 = temp2 << (difference & 0xff);\n      if ((int)valueWithFractionalBits < (int)difference) {\n        temp2 = temp2 >> (-(valueWithFractionalBits - difference) & 0xff);\n      }\n      else {\n        temp2 = temp2 + (valueWithFractionalBits - difference) * 0x800000;\n      }\n      return temp2 | value;\n    }\n  }\n  else {\n    valueWithFractionalBits = temp3 - 1;\n    if (0xffffff < temp2) {\n      valueWithFractionalBits = temp2 & 1;\n      temp2 = temp2 >> 1;\n      temp1 = (uint)(valueWithFractionalBits != 0) << 0x1f | temp1 >> 1;\n      valueWithFractionalBits = temp3;\n      if (0xfd < temp3) goto LAB_08008e12;\n    }\n  }\n  temp2 = temp2 + valueWithFractionalBits * 0x800000 + (uint)(0x7fffffff < temp1);\n  if (temp1 == 0x80000000) {\n    temp2 = temp2 & 0xfffffffe;\n  }\n  return temp2 | value;\n}\n\n",
            "renaming": {
                "FUN_08008cd8": "float_to_fixed_point_08008cd8",
                "param_1": "value",
                "param_2": "fractionalBits",
                "param_3": "param3",
                "param_4": "param4",
                "iVar1": "shiftRight",
                "iVar2": "shiftRight2",
                "uVar3": "valueWithFractionalBits",
                "uVar4": "temp1",
                "uVar5": "temp2",
                "uVar6": "temp3",
                "uVar7": "difference",
                "bVar8": "isNegative",
                "LZCOUNT": "leadingZerosCount"
            },
            "calling": [
                "gc_execute_line",
                "intersection_distance",
                "mc_dwell",
                "mc_arc",
                "report_realtime_status",
                "estimate_acceleration_distance",
                "max_allowable_speed",
                "plan_buffer_line"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008cdc": {
            "entrypoint": "0x08008cdc",
            "current_name": "calculate_float_08008cdc",
            "code": "\nuint calculateFloat_08008cdc(uint num1,uint num2,undefined4 value1,uint value2)\n\n{\n  int shiftedNum1;\n  int shiftedNum2;\n  uint fractionNum1;\n  uint fractionNum2;\n  uint diff;\n  uint absDiff;\n  bool isEqual;\n  \n  fractionNum2 = num1 << 1;\n  isEqual = fractionNum2 == 0;\n  if (!isEqual) {\n    value2 = num2 << 1;\n    isEqual = value2 == 0;\n  }\n  if (!isEqual) {\n    isEqual = fractionNum2 == value2;\n  }\n  shiftedNum1 = (int)fractionNum2 >> 0x18;\n  if (!isEqual) {\n    isEqual = shiftedNum1 == -1;\n  }\n  if (!isEqual) {\n    isEqual = (int)value2 >> 0x18 == -1;\n  }\n  if (isEqual) {\n    shiftedNum2 = (int)(num2 << 1) >> 0x18;\n    if (shiftedNum1 == -1 || shiftedNum2 == -1) {\n      fractionNum2 = num2;\n      if (shiftedNum1 == -1) {\n        fractionNum2 = num1;\n      }\n      if (shiftedNum1 != -1 || shiftedNum2 != -1) {\n        num2 = fractionNum2;\n      }\n      isEqual = (fractionNum2 & 0x7fffff) == 0;\n      if (isEqual) {\n        isEqual = (num2 & 0x7fffff) == 0;\n      }\n      if (isEqual) {\n        isEqual = fractionNum2 == num2;\n      }\n      if (!isEqual) {\n        fractionNum2 = fractionNum2 | 0x400000;\n      }\n      return fractionNum2;\n    }\n    if (((num1 ^ num2) & 0x7fffffff) != 0) {\n      if (fractionNum2 == 0) {\n        num1 = num2;\n      }\n      return num1;\n    }\n    if (num1 != num2) {\n      return 0;\n    }\n    if ((fractionNum2 & 0xff000000) == 0) {\n      fractionNum2 = num1 << 1;\n      if ((num1 & 0x80000000) != 0) {\n        fractionNum2 = fractionNum2 | 0x80000000;\n      }\n      return fractionNum2;\n    }\n    if (fractionNum2 < 0xfe000000) {\n      return num1 + 0x800000;\n    }\n    num1 = num1 & 0x80000000;\nLAB_08008e12:\n    return num1 | 0x7f800000;\n  }\n  fractionNum2 = fractionNum2 >> 0x18;\n  value2 = value2 >> 0x18;\n  absDiff = value2 - fractionNum2;\n  isEqual = absDiff != 0;\n  diff = fractionNum2;\n  if (isEqual && fractionNum2 <= value2) {\n    diff = fractionNum2 + absDiff;\n  }\n  if (isEqual && fractionNum2 <= value2) {\n    num2 = num2 ^ num1;\n  }\n  if (isEqual && fractionNum2 <= value2) {\n    num1 = num1 ^ num2;\n  }\n  if (isEqual && fractionNum2 <= value2) {\n    num2 = num2 ^ num1;\n  }\n  if (value2 < fractionNum2) {\n    absDiff = -absDiff;\n  }\n  if (0x19 < absDiff) {\n    return num1;\n  }\n  fractionNum2 = num1 & 0xffffff | 0x800000;\n  if ((num1 & 0x80000000) != 0) {\n    fractionNum2 = -fractionNum2;\n  }\n  fractionNum1 = num2 & 0xffffff | 0x800000;\n  if ((num2 & 0x80000000) != 0) {\n    fractionNum1 = -fractionNum1;\n  }\n  if (diff == absDiff) {\n    fractionNum1 = fractionNum1 ^ 0x800000;\n    if (diff == 0) {\n      fractionNum2 = fractionNum2 ^ 0x800000;\n      diff = 1;\n    }\n    else {\n      absDiff = absDiff - 1;\n    }\n  }\n  fractionNum2 = fractionNum2 + ((int)fractionNum1 >> (absDiff & 0xff));\n  fractionNum1 = fractionNum1 << (0x20 - absDiff & 0xff);\n  num1 = fractionNum2 & 0x80000000;\n  if ((int)fractionNum2 < 0) {\n    isEqual = fractionNum1 != 0;\n    fractionNum1 = -fractionNum1;\n    fractionNum2 = -fractionNum2 - (uint)isEqual;\n  }\n  if (fractionNum2 < 0x800000) {\n    absDiff = fractionNum1 & 0x80000000;\n    fractionNum1 = fractionNum1 << 1;\n    fractionNum2 = fractionNum2 * 2 + (uint)(absDiff != 0);\n    absDiff = diff - 2;\n    if (diff - 1 == 0 || fractionNum2 < 0x800000) {\n      diff = LZCOUNT(fractionNum2) - 8;\n      fractionNum2 = fractionNum2 << (diff & 0xff);\n      if ((int)absDiff < (int)diff) {\n        fractionNum2 = fractionNum2 >> (-(absDiff - diff) & 0xff);\n      }\n      else {\n        fractionNum2 = fractionNum2 + (absDiff - diff) * 0x800000;\n      }\n      return fractionNum2 | num1;\n    }\n  }\n  else {\n    absDiff = diff - 1;\n    if (0xffffff < fractionNum2) {\n      absDiff = fractionNum2 & 1;\n      fractionNum2 = fractionNum2 >> 1;\n      fractionNum1 = (uint)(absDiff != 0) << 0x1f | fractionNum1 >> 1;\n      absDiff = diff;\n      if (0xfd < diff) goto LAB_08008e12;\n    }\n  }\n  fractionNum2 = fractionNum2 + absDiff * 0x800000 + (uint)(0x7fffffff < fractionNum1);\n  if (fractionNum1 == 0x80000000) {\n    fractionNum2 = fractionNum2 & 0xfffffffe;\n  }\n  return fractionNum2 | num1;\n}\n\n",
            "renaming": {
                "FUN_08008cdc": "calculate_float_08008cdc",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "value1",
                "param_4": "value2",
                "iVar1": "shiftedNum1",
                "iVar2": "shiftedNum2",
                "uVar3": "fractionNum1",
                "uVar4": "fractionNum2",
                "uVar5": "diff",
                "uVar6": "absDiff",
                "bVar7": "isEqual"
            },
            "calling": [
                "gc_execute_line",
                "printFloat",
                "intersection_distance",
                "mc_arc",
                "__aeabi_frsub",
                "report_realtime_status",
                "estimate_acceleration_distance",
                "max_allowable_speed",
                "plan_buffer_line"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008e3c": {
            "entrypoint": "0x08008e3c",
            "current_name": "binary_reverse_and_improve_08008e3c",
            "code": "\nuint binaryReverseAndImprove_08008e3c(uint inputValue)\n\n{\n  uint leadingZeros;\n  uint shiftValue;\n  int constantValue;\n  uint signExtension;\n  \n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZeros = LZCOUNT(inputValue);\n  shiftValue = leadingZeros - 8;\n  constantValue = shiftValue * -0x800000 + 0x4a800000;\n  if (7 < leadingZeros) {\n    signExtension = 0 << (shiftValue & 0xff);\n    leadingZeros = constantValue + (inputValue << (shiftValue & 0xff)) +\n            (0U >> (0x20 - shiftValue & 0xff)) + (uint)(0x7fffffff < signExtension);\n    if (signExtension == 0x80000000) {\n      leadingZeros = leadingZeros & 0xfffffffe;\n    }\n    return leadingZeros;\n  }\n  shiftValue = inputValue << leadingZeros + 0x18;\n  leadingZeros = constantValue + ((inputValue >> (0x20 - (leadingZeros + 0x18) & 0xff)) - ((int)shiftValue >> 0x1f));\n  if ((shiftValue & 0x7fffffff) == 0) {\n    leadingZeros = leadingZeros & ~(shiftValue >> 0x1f);\n  }\n  return leadingZeros;\n}\n\n",
            "renaming": {
                "FUN_08008e3c": "binary_reverse_and_improve_08008e3c",
                "param_1": "inputValue",
                "uVar1": "leadingZeros",
                "uVar2": "shiftValue",
                "iVar3": "constantValue",
                "uVar4": "signExtension"
            },
            "calling": [
                "calculate_trapezoid_for_block",
                "read_float"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008e44": {
            "entrypoint": "0x08008e44",
            "current_name": "calculate_result_08008e44",
            "code": "\nuint calculateResult_08008e44(uint inputNumber)\n\n{\n  uint leadingZeros;\n  uint shiftAmount;\n  uint highestBit;\n  int result;\n  \n  highestBit = inputNumber & 0x80000000;\n  if ((int)highestBit < 0) {\n    inputNumber = -inputNumber;\n  }\n  if (inputNumber == 0) {\n    return 0;\n  }\n  leadingZeros = countLeadingZeros(inputNumber);\n  shiftAmount = leadingZeros - 8;\n  result = ((highestBit | 0x4b000000) - 0x800000) + shiftAmount * -0x800000;\n  if (7 < leadingZeros) {\n    leadingZeros = 0 << (shiftAmount & 0xff);\n    highestBit = result + (inputNumber << (shiftAmount & 0xff)) +\n            (0U >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < leadingZeros);\n    if (leadingZeros == 0x80000000) {\n      highestBit = highestBit & 0xfffffffe;\n    }\n    return highestBit;\n  }\n  shiftAmount = inputNumber << leadingZeros + 0x18;\n  highestBit = result + ((inputNumber >> (0x20 - (leadingZeros + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n  if ((shiftAmount & 0x7fffffff) == 0) {\n    highestBit = highestBit & ~(shiftAmount >> 0x1f);\n  }\n  return highestBit;\n}\n\n",
            "renaming": {
                "FUN_08008e44": "calculate_result_08008e44",
                "param_1": "inputNumber",
                "uVar1": "leadingZeros",
                "uVar2": "shiftAmount",
                "uVar3": "highestBit",
                "iVar4": "result",
                "LZCOUNT": "countLeadingZeros"
            },
            "calling": [
                "gc_set_current_position",
                "mc_go_home",
                "calculate_trapezoid_for_block",
                "mc_dwell",
                "mc_arc",
                "report_realtime_status",
                "plan_cycle_reinitialize",
                "plan_buffer_line"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008e60": {
            "entrypoint": "0x08008e60",
            "current_name": "calculate_hash_08008e60",
            "code": "\nuint calculateHash_08008e60(uint input1,uint input2)\n\n{\n  uint temp;\n  uint output;\n  uint shiftCount;\n  uint temp2;\n  int constant;\n  \n  if ((input1 | input2) == 0) {\n    return input1;\n  }\n  temp = input1;\n  output = input2;\n  if (input2 == 0) {\n    temp = 0;\n    output = input1;\n  }\n  constant = 0x5b000000;\n  if (input2 == 0) {\n    constant = 0x4b000000;\n  }\n  shiftCount = LZCOUNT(output);\n  temp2 = shiftCount - 8;\n  constant = constant + -0x800000 + temp2 * -0x800000;\n  if (shiftCount < 8) {\n    temp2 = output << shiftCount + 0x18;\n    output = constant + ((output >> (0x20 - (shiftCount + 0x18) & 0xff)) - ((int)temp2 >> 0x1f));\n    if ((temp | temp2 << 1) == 0) {\n      output = output & ~(temp2 >> 0x1f);\n    }\n    return output;\n  }\n  shiftCount = temp << (temp2 & 0xff);\n  output = constant + (output << (temp2 & 0xff)) +\n          (temp >> (0x20 - temp2 & 0xff)) + (uint)(0x7fffffff < shiftCount);\n  if (shiftCount == 0x80000000) {\n    output = output & 0xfffffffe;\n  }\n  return output;\n}\n\n",
            "renaming": {
                "FUN_08008e60": "calculate_hash_08008e60",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "temp",
                "uVar2": "output",
                "uVar3": "shiftCount",
                "uVar4": "temp2",
                "iVar5": "constant"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008e70": {
            "entrypoint": "0x08008e70",
            "current_name": "calculate_bitwise_operation_08008e70",
            "code": "\nuint calculate_bitwise_operation_08008e70(uint input_value_1,uint input_value_2)\n\n{\n  uint updated_value_1;\n  uint updated_value_2;\n  uint count;\n  uint shift_value;\n  uint combined_flag;\n  int result;\n  bool is_nonzero;\n  \n  if ((input_value_1 | input_value_2) == 0) {\n    return input_value_1;\n  }\n  combined_flag = input_value_2 & 0x80000000;\n  if ((int)combined_flag < 0) {\n    is_nonzero = input_value_1 != 0;\n    input_value_1 = -input_value_1;\n    input_value_2 = -input_value_2 - (uint)is_nonzero;\n  }\n  updated_value_2 = input_value_1;\n  updated_value_1 = input_value_2;\n  if (input_value_2 == 0) {\n    updated_value_2 = 0;\n    updated_value_1 = input_value_1;\n  }\n  combined_flag = combined_flag | 0x5b000000;\n  if (input_value_2 == 0) {\n    combined_flag = combined_flag + 0xf0000000;\n  }\n  count = leading_zero_count(updated_value_1);\n  shift_value = count - 8;\n  result = (combined_flag - 0x800000) + shift_value * -0x800000;\n  if (count < 8) {\n    shift_value = updated_value_1 << count + 0x18;\n    combined_flag = result + ((updated_value_1 >> (0x20 - (count + 0x18) & 0xff)) - ((int)shift_value >> 0x1f));\n    if ((updated_value_2 | shift_value << 1) == 0) {\n      combined_flag = combined_flag & ~(shift_value >> 0x1f);\n    }\n    return combined_flag;\n  }\n  count = updated_value_2 << (shift_value & 0xff);\n  combined_flag = result + (updated_value_1 << (shift_value & 0xff)) +\n          (updated_value_2 >> (0x20 - shift_value & 0xff)) + (uint)(0x7fffffff < count);\n  if (count == 0x80000000) {\n    combined_flag = combined_flag & 0xfffffffe;\n  }\n  return combined_flag;\n}\n\n",
            "renaming": {
                "FUN_08008e70": "calculate_bitwise_operation_08008e70",
                "param_1": "input_value_1",
                "param_2": "input_value_2",
                "uVar1": "updated_value_1",
                "uVar2": "updated_value_2",
                "uVar3": "count",
                "uVar4": "shift_value",
                "uVar5": "combined_flag",
                "iVar6": "result",
                "bVar7": "is_nonzero",
                "LZCOUNT": "leading_zero_count"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008eec": {
            "entrypoint": "0x08008eec",
            "current_name": "calculate_floating_point_08008eec",
            "code": "\nuint calculateFloatingPoint_08008eec(uint inputA,uint inputB,undefined4 param_3,uint param_4)\n\n{\n  longlong tempLong;\n  uint result;\n  uint firstByteOfInputA;\n  int sum;\n  int difference;\n  uint multiplier;\n  int difference2;\n  uint tempValue;\n  bool condition1;\n  bool condition2;\n  \n  firstByteOfInputA = inputA >> 0x17 & 0xff;\n  condition1 = firstByteOfInputA == 0;\n  if (!condition1) {\n    param_4 = inputB >> 0x17 & 0xff;\n    condition1 = param_4 == 0;\n  }\n  if (!condition1) {\n    condition1 = firstByteOfInputA == 0xff;\n  }\n  if (!condition1) {\n    condition1 = param_4 == 0xff;\n  }\n  if (condition1) {\n    param_4 = inputB >> 0x17 & 0xff;\n    if (firstByteOfInputA == 0xff || param_4 == 0xff) {\n      condition1 = inputA == 0 || inputA == 0x80000000;\n      result = inputB;\n      if (inputA != 0 && inputA != 0x80000000) {\n        condition1 = inputB == 0;\n        result = inputA;\n      }\n      if (!condition1) {\n        condition1 = inputB == 0x80000000;\n      }\n      tempValue = result;\n      if (((condition1) || ((firstByteOfInputA == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((param_4 == 0xff && (tempValue = inputB, (inputB & 0x7fffff) != 0)))) {\n        return tempValue | 0x7fc00000;\n      }\n      result = result ^ inputB;\n      goto LAB_0800903c;\n    }\n    condition1 = (inputA & 0x7fffffff) == 0;\n    if (!condition1) {\n      condition1 = (inputB & 0x7fffffff) == 0;\n    }\n    if (condition1) {\n      return (inputA ^ inputB) & 0x80000000;\n    }\n    condition1 = firstByteOfInputA == 0;\n    result = inputA & 0x80000000;\n    while( true ) {\n      if (condition1) {\n        inputA = inputA << 1;\n        condition1 = (inputA & 0x800000) == 0;\n      }\n      if (!condition1) break;\n      firstByteOfInputA = firstByteOfInputA - 1;\n    }\n    inputA = inputA | result;\n    condition1 = param_4 == 0;\n    result = inputB & 0x80000000;\n    while( true ) {\n      if (condition1) {\n        inputB = inputB << 1;\n        condition1 = (inputB & 0x800000) == 0;\n      }\n      if (!condition1) break;\n      param_4 = param_4 - 1;\n    }\n    inputB = inputB | result;\n  }\n  sum = firstByteOfInputA + param_4;\n  tempValue = inputA ^ inputB;\n  firstByteOfInputA = inputA << 9;\n  condition1 = firstByteOfInputA == 0;\n  if (!condition1) {\n    inputB = inputB << 9;\n    condition1 = inputB == 0;\n  }\n  if (condition1) {\n    if (firstByteOfInputA == 0) {\n      inputB = inputB << 9;\n    }\n    result = tempValue & 0x80000000 | inputA & 0x7fffff | inputB >> 9;\n    condition2 = SBORROW4(sum,0x7f);\n    difference = sum + -0x7f;\n    condition1 = difference == 0;\n    difference2 = difference;\n    if (!condition1 && 0x7e < sum) {\n      condition2 = SBORROW4(0xff,difference);\n      difference2 = 0xff - difference;\n      condition1 = difference == 0xff;\n    }\n    if (!condition1 && difference2 < 0 == condition2) {\n      result = result | difference * 0x800000;\n    }\n    if (!condition1 && difference2 < 0 == condition2) {\n      return result;\n    }\n    result = result | 0x800000;\n    multiplier = 0;\n    condition2 = SBORROW4(difference,1);\n    tempValue = sum - 0x80;\n    condition1 = tempValue == 0;\n    firstByteOfInputA = tempValue;\n  }\n  else {\n    tempLong = (ulonglong)(firstByteOfInputA >> 5 | 0x8000000) * (ulonglong)(inputB >> 5 | 0x8000000);\n    multiplier = (uint)tempLong;\n    result = (uint)((ulonglong)tempLong >> 0x20);\n    condition1 = result < 0x800000;\n    if (condition1) {\n      result = result << 1;\n    }\n    if (condition1) {\n      result = result | multiplier >> 0x1f;\n      multiplier = multiplier << 1;\n    }\n    result = tempValue & 0x80000000 | result;\n    tempValue = (sum + -0x7f) - (uint)condition1;\n    condition2 = SBORROW4(tempValue,0xfd);\n    condition1 = tempValue == 0xfd;\n    firstByteOfInputA = tempValue - 0xfd;\n    if (tempValue < 0xfe) {\n      result = result + tempValue * 0x800000 + (uint)(0x7fffffff < multiplier);\n      if (multiplier == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (condition1 || (int)firstByteOfInputA < 0 != condition2) {\n    condition1 = (int)(tempValue + 0x19) < 0;\n    if (tempValue == 0xffffffe7 || condition1 != SCARRY4(tempValue,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (tempValue != 0xffffffe7 && condition1 == SCARRY4(tempValue,0x19)) {\n      firstByteOfInputA = (result << 1) >> (-tempValue & 0xff);\n      tempValue = result << (tempValue + 0x20 & 0xff);\n      firstByteOfInputA = ((uint)((result & 0x80000000) != 0) << 0x1f | firstByteOfInputA >> 1) + (uint)((byte)firstByteOfInputA & 1);\n      if ((multiplier | tempValue << 1) == 0) {\n        firstByteOfInputA = firstByteOfInputA & ~(tempValue >> 0x1f);\n      }\n      return firstByteOfInputA;\n    }\n    return result;\n  }\nLAB_0800903c:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08008eec": "calculate_floating_point_08008eec",
                "param_1": "inputA",
                "param_2": "inputB",
                "lVar1": "tempLong",
                "uVar2": "result",
                "uVar3": "firstByteOfInputA",
                "iVar4": "sum",
                "iVar5": "difference",
                "uVar6": "multiplier",
                "iVar7": "difference2",
                "uVar8": "tempValue",
                "bVar9": "condition1",
                "bVar10": "condition2"
            },
            "calling": [
                "printFloat",
                "calculate_trapezoid_for_block",
                "estimate_acceleration_distance",
                "plan_cycle_reinitialize",
                "homing_cycle",
                "max_allowable_speed",
                "plan_buffer_line",
                "gc_execute_line",
                "mc_go_home",
                "intersection_distance",
                "read_float",
                "mc_dwell",
                "mc_arc",
                "settings_store_global_setting"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009054": {
            "entrypoint": "0x08009054",
            "current_name": "calculate_floating_point_08009054",
            "code": "\nuint calculateFloatingPoint_08009054(uint input1,uint input2,undefined4 input3,uint input4)\n\n{\n  uint result;\n  uint count1;\n  int difference;\n  uint count2;\n  int sum;\n  uint result;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  \n  count1 = input1 >> 0x17 & 0xff;\n  flag1 = count1 == 0;\n  if (!flag1) {\n    input4 = input2 >> 0x17 & 0xff;\n    flag1 = input4 == 0;\n  }\n  if (!flag1) {\n    flag1 = count1 == 0xff;\n  }\n  if (!flag1) {\n    flag1 = input4 == 0xff;\n  }\n  if (flag1) {\n    input4 = input2 >> 0x17 & 0xff;\n    result = input1;\n    if (count1 == 0xff) {\n      if (((input1 & 0x7fffff) != 0) || (result = input2, input4 == 0xff)) {\nLAB_0800904a:\n        return result | 0x7fc00000;\n      }\n    }\n    else {\n      if (input4 == 0xff) {\n        result = input2;\n        if ((input2 & 0x7fffff) == 0) {\nLAB_08009000:\n          return (input1 ^ input2) & 0x80000000;\n        }\n        goto LAB_0800904a;\n      }\n      flag1 = (input1 & 0x7fffffff) == 0;\n      if (!flag1) {\n        flag1 = (input2 & 0x7fffffff) == 0;\n      }\n      if (!flag1) {\n        flag1 = count1 == 0;\n        result = input1 & 0x80000000;\n        while( true ) {\n          if (flag1) {\n            input1 = input1 << 1;\n            flag1 = (input1 & 0x800000) == 0;\n          }\n          if (!flag1) break;\n          count1 = count1 - 1;\n        }\n        input1 = input1 | result;\n        flag1 = input4 == 0;\n        result = input2 & 0x80000000;\n        while( true ) {\n          if (flag1) {\n            input2 = input2 << 1;\n            flag1 = (input2 & 0x800000) == 0;\n          }\n          if (!flag1) break;\n          input4 = input4 - 1;\n        }\n        input2 = input2 | result;\n        goto LAB_0800906c;\n      }\n      if ((input1 & 0x7fffffff) == 0) {\n        if ((input2 & 0x7fffffff) != 0) goto LAB_08009000;\n        goto LAB_0800904a;\n      }\n    }\n    input1 = input1 ^ input2;\n  }\n  else {\nLAB_0800906c:\n    difference = count1 - input4;\n    if (input2 << 9 == 0) {\n      input1 = (input1 ^ input2) & 0x80000000 | input1 & 0x7fffff;\n      flag3 = SCARRY4(difference,0x7f);\n      sum = difference + 0x7f;\n      flag1 = sum < 0;\n      flag2 = sum == 0;\n      if (!flag2 && flag1 == flag3) {\n        flag3 = SBORROW4(0xff,sum);\n        flag1 = 0xff - sum < 0;\n        flag2 = sum == 0xff;\n      }\n      if (!flag2 && flag1 == flag3) {\n        input1 = input1 | sum * 0x800000;\n      }\n      if (!flag2 && flag1 == flag3) {\n        return input1;\n      }\n      input1 = input1 | 0x800000;\n      count1 = 0;\n      flag2 = SBORROW4(sum,1);\n      count2 = difference + 0x7e;\n      flag1 = count2 == 0;\n      result = count2;\n    }\n    else {\n      result = (input2 << 9) >> 4 | 0x10000000;\n      count1 = (input1 << 9) >> 4 | 0x10000000;\n      input1 = (input1 ^ input2) & 0x80000000;\n      flag1 = result <= count1;\n      if (!flag1) {\n        count1 = count1 << 1;\n      }\n      count2 = difference + 0x7d + (uint)flag1;\n      result = 0x800000;\n      do {\n        if (result <= count1) {\n          count1 = count1 - result;\n          input1 = input1 | result;\n        }\n        flag1 = result >> 1 <= count1;\n        if (flag1) {\n          count1 = count1 - (result >> 1);\n        }\n        if (flag1) {\n          input1 = input1 | result >> 1;\n        }\n        flag1 = result >> 2 <= count1;\n        if (flag1) {\n          count1 = count1 - (result >> 2);\n        }\n        if (flag1) {\n          input1 = input1 | result >> 2;\n        }\n        flag1 = result >> 3 <= count1;\n        if (flag1) {\n          count1 = count1 - (result >> 3);\n        }\n        if (flag1) {\n          input1 = input1 | result >> 3;\n        }\n        count1 = count1 * 0x10;\n        flag1 = count1 == 0;\n        if (!flag1) {\n          result = result >> 4;\n          flag1 = result == 0;\n        }\n      } while (!flag1);\n      flag2 = SBORROW4(count2,0xfd);\n      flag1 = count2 == 0xfd;\n      result = count2 - 0xfd;\n      if (count2 < 0xfe) {\n        input1 = input1 + count2 * 0x800000 + (uint)(result <= count1);\n        if (count1 - result == 0) {\n          input1 = input1 & 0xfffffffe;\n        }\n        return input1;\n      }\n    }\n    if (flag1 || (int)result < 0 != flag2) {\n      flag1 = (int)(count2 + 0x19) < 0;\n      if (count2 == 0xffffffe7 || flag1 != SCARRY4(count2,0x19)) {\n        input1 = input1 & 0x80000000;\n      }\n      if (count2 == 0xffffffe7 || flag1 != SCARRY4(count2,0x19)) {\n        return input1;\n      }\n      result = (input1 << 1) >> (-count2 & 0xff);\n      count2 = input1 << (count2 + 0x20 & 0xff);\n      result = ((uint)((input1 & 0x80000000) != 0) << 0x1f | result >> 1) + (uint)((byte)result & 1);\n      if ((count1 | count2 << 1) == 0) {\n        result = result & ~(count2 >> 0x1f);\n      }\n      return result;\n    }\n  }\n  return input1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08009054": "calculate_floating_point_08009054",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "result",
                "uVar2": "count1",
                "iVar3": "difference",
                "uVar4": "count2",
                "iVar5": "sum",
                "uVar6": "result",
                "bVar7": "flag1",
                "bVar8": "flag2",
                "bVar9": "flag3"
            },
            "calling": [
                "gc_set_current_position",
                "intersection_distance",
                "report_grbl_settings",
                "planner_recalculate_trapezoids",
                "mc_arc",
                "report_realtime_status",
                "estimate_acceleration_distance",
                "plan_cycle_reinitialize",
                "homing_cycle",
                "plan_buffer_line"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800918c": {
            "entrypoint": "0x0800918c",
            "current_name": "calculate_bitwise_value_0800918c",
            "code": "\nuint calculateBitwiseValue_0800918c(uint inputValue1,uint inputValue2)\n\n{\n  bool isValueNegative;\n  uint multipliedValue1;\n  uint multipliedValue2;\n  uint bitwiseORValue;\n  bool isValueZero;\n  \n  multipliedValue1 = inputValue1 * 2;\n  multipliedValue2 = inputValue2 * 2;\n  if (((int)multipliedValue1 >> 0x18 == -1 || (int)multipliedValue2 >> 0x18 == -1) &&\n     ((((int)multipliedValue1 >> 0x18 == -1 && ((inputValue1 & 0x7fffff) != 0)) ||\n      (((int)multipliedValue2 >> 0x18 == -1 && ((inputValue2 & 0x7fffff) != 0)))))) {\n    return 0xffffffff;\n  }\n  bitwiseORValue = multipliedValue1 | inputValue2 & 0x7fffffff;\n  isValueZero = bitwiseORValue == 0;\n  if (!isValueZero) {\n    bitwiseORValue = inputValue1 ^ inputValue2;\n    isValueZero = bitwiseORValue == 0;\n  }\n  isValueNegative = -1 < (int)bitwiseORValue;\n  if (isValueNegative) {\n    inputValue1 = multipliedValue1 + inputValue2 * -2;\n    isValueZero = inputValue1 == 0;\n  }\n  if ((isValueNegative && multipliedValue2 <= multipliedValue1) && !isValueZero) {\n    inputValue1 = (int)inputValue2 >> 0x1f;\n  }\n  if (!isValueNegative || multipliedValue2 > multipliedValue1) {\n    inputValue1 = ~((int)inputValue2 >> 0x1f);\n  }\n  if (!isValueZero) {\n    inputValue1 = inputValue1 | 1;\n  }\n  return inputValue1;\n}\n\n",
            "renaming": {
                "FUN_0800918c": "calculate_bitwise_value_0800918c",
                "param_1": "inputValue1",
                "param_2": "inputValue2",
                "bVar1": "isValueNegative",
                "uVar2": "multipliedValue1",
                "uVar3": "multipliedValue2",
                "uVar4": "bitwiseORValue",
                "bVar5": "isValueZero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009194": {
            "entrypoint": "0x08009194",
            "current_name": "check_overflow_08009194",
            "code": "\nuint check_overflow_08009194(uint input_1,uint input_2)\n\n{\n  bool is_negative;\n  uint doubled_input_1;\n  uint doubled_input_2;\n  uint combined_input;\n  bool is_zero;\n  \n  doubled_input_1 = input_1 * 2;\n  doubled_input_2 = input_2 * 2;\n  if (((int)doubled_input_1 >> 0x18 == -1 || (int)doubled_input_2 >> 0x18 == -1) &&\n     ((((int)doubled_input_1 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)doubled_input_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined_input = doubled_input_1 | input_2 & 0x7fffffff;\n  is_zero = combined_input == 0;\n  if (!is_zero) {\n    combined_input = input_1 ^ input_2;\n    is_zero = combined_input == 0;\n  }\n  is_negative = -1 < (int)combined_input;\n  if (is_negative) {\n    input_1 = doubled_input_1 + input_2 * -2;\n    is_zero = input_1 == 0;\n  }\n  if ((is_negative && doubled_input_2 <= doubled_input_1) && !is_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_negative || doubled_input_2 > doubled_input_1) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "renaming": {
                "FUN_08009194": "check_overflow_08009194",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar2": "doubled_input_1",
                "uVar3": "doubled_input_2",
                "uVar4": "combined_input",
                "bVar1": "is_negative",
                "bVar5": "is_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800919c": {
            "entrypoint": "0x0800919c",
            "current_name": "determine_overflow_0800919c",
            "code": "\nuint determineOverflow_0800919c(uint input1,uint input2)\n\n{\n  bool isOverflow;\n  uint input1Times2;\n  uint input2Times2;\n  uint combinedValue;\n  bool isZero;\n  \n  input1Times2 = input1 * 2;\n  input2Times2 = input2 * 2;\n  if (((int)input1Times2 >> 0x18 == -1 || (int)input2Times2 >> 0x18 == -1) &&\n     ((((int)input1Times2 >> 0x18 == -1 && ((input1 & 0x7fffff) != 0)) ||\n      (((int)input2Times2 >> 0x18 == -1 && ((input2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combinedValue = input1Times2 | input2 & 0x7fffffff;\n  isZero = combinedValue == 0;\n  if (!isZero) {\n    combinedValue = input1 ^ input2;\n    isZero = combinedValue == 0;\n  }\n  isOverflow = -1 < (int)combinedValue;\n  if (isOverflow) {\n    input1 = input1Times2 + input2 * -2;\n    isZero = input1 == 0;\n  }\n  if ((isOverflow && input2Times2 <= input1Times2) && !isZero) {\n    input1 = (int)input2 >> 0x1f;\n  }\n  if (!isOverflow || input2Times2 > input1Times2) {\n    input1 = ~((int)input2 >> 0x1f);\n  }\n  if (!isZero) {\n    input1 = input1 | 1;\n  }\n  return input1;\n}\n\n",
            "renaming": {
                "FUN_0800919c": "determine_overflow_0800919c",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "isOverflow",
                "uVar2": "input1Times2",
                "uVar3": "input2Times2",
                "uVar4": "combinedValue",
                "bVar5": "isZero"
            },
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091fc": {
            "entrypoint": "0x080091fc",
            "current_name": "compare_floats_080091fc",
            "code": "\nvoid compareFloats_080091fc(undefined4 value1,undefined4 value2)\n\n{\n  __aeabi_cfcmpeq(value2,value1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080091fc": "compare_floats_080091fc",
                "param_1": "value1",
                "param_2": "value2"
            },
            "calling": [
                "__aeabi_fcmpgt",
                "__aeabi_fcmpge"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009204": {
            "entrypoint": "0x08009204",
            "current_name": "concatenate_parameters_08009204",
            "code": "\nundefined8 concatenateParameters_08009204(undefined4 firstParameter,undefined4 secondParameter)\n\n{\n  __cmpsf2();\n  return CONCAT44(secondParameter,firstParameter);\n}\n\n",
            "renaming": {
                "FUN_08009204": "concatenate_parameters_08009204",
                "param_1": "firstParameter",
                "param_2": "secondParameter"
            },
            "calling": [
                "__aeabi_fcmple",
                "__aeabi_fcmplt",
                "__aeabi_cfrcmple",
                "__aeabi_fcmpeq"
            ],
            "called": [
                "__cmpsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009214": {
            "entrypoint": "0x08009214",
            "current_name": "check_if_zero_08009214",
            "code": "\nbool check_if_zero_08009214(void)\n\n{\n  char is_not_zero;\n  \n  __aeabi_cfcmpeq();\n  return is_not_zero != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08009214": "check_if_zero_08009214",
                "in_ZR": "is_not_zero"
            },
            "calling": [
                "gc_execute_line",
                "read_float",
                "planner_forward_pass_kernel",
                "mc_arc",
                "settings_store_global_setting",
                "planner_reverse_pass_kernel"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009228": {
            "entrypoint": "0x08009228",
            "current_name": "check_if_null_08009228",
            "code": "\nbool check_if_null_08009228(void)\n\n{\n  char input_character;\n  \n  __aeabi_cfcmpeq();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08009228": "check_if_null_08009228",
                "in_CY": "input_character"
            },
            "calling": [
                "gc_execute_line",
                "printFloat",
                "planner_forward_pass_kernel",
                "settings_store_global_setting",
                "planner_reverse_pass_kernel",
                "plan_buffer_line"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800923c": {
            "entrypoint": "0x0800923c",
            "current_name": "check_equality_0800923c",
            "code": "\nbool check_equality_0800923c(void)\n\n{\n  undefined zero_flag;\n  undefined carry_flag;\n  \n  __aeabi_cfcmpeq();\n  return !(bool)carry_flag || (bool)zero_flag;\n}\n\n",
            "renaming": {
                "FUN_0800923c": "check_equality_0800923c",
                "in_ZR": "zero_flag",
                "in_CY": "carry_flag"
            },
            "calling": [
                "gc_execute_line",
                "mc_arc",
                "settings_store_global_setting"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009250": {
            "entrypoint": "0x08009250",
            "current_name": "check_condition_08009250",
            "code": "\nbool check_condition_08009250(void)\n\n{\n  undefined zero_flag;\n  undefined carry_flag;\n  \n  __aeabi_cfrcmple();\n  return !(bool)carry_flag || (bool)zero_flag;\n}\n\n",
            "renaming": {
                "FUN_08009250": "check_condition_08009250",
                "in_CY": "carry_flag",
                "in_ZR": "zero_flag"
            },
            "calling": [
                "mc_arc",
                "plan_buffer_line"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009264": {
            "entrypoint": "0x08009264",
            "current_name": "check_if_null_terminated_08009264",
            "code": "\nbool check_if_null_terminated_08009264(void)\n\n{\n  char input_character;\n  \n  __aeabi_cfrcmple();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08009264": "check_if_null_terminated_08009264",
                "in_CY": "input_character"
            },
            "calling": [
                "planner_reverse_pass_kernel",
                "plan_buffer_line"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009278": {
            "entrypoint": "0x08009278",
            "current_name": "convert_to_signed_integer_08009278",
            "code": "\nuint convertToSignedInteger_08009278(uint input)\n\n{\n  uint shiftedBits;\n  uint exponent;\n  \n  if (input << 1 < 0x7f000000) {\n    return 0;\n  }\n  shiftedBits = (input << 1) >> 0x18;\n  exponent = 0x9e - shiftedBits;\n  if (shiftedBits < 0x9f && exponent != 0) {\n    shiftedBits = (input << 8 | 0x80000000) >> (exponent & 0xff);\n    if ((input & 0x80000000) != 0) {\n      shiftedBits = -shiftedBits;\n    }\n    return shiftedBits;\n  }\n  if ((exponent == 0xffffff9f) && ((input & 0x7fffff) != 0)) {\n    return 0;\n  }\n  input = input & 0x80000000;\n  if (input == 0) {\n    input = 0x7fffffff;\n  }\n  return input;\n}\n\n",
            "renaming": {
                "FUN_08009278": "convert_to_signed_integer_08009278",
                "param_1": "input",
                "uVar1": "shiftedBits",
                "uVar2": "exponent"
            },
            "calling": [
                "printFloat",
                "protocol_execute_line"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080092c4": {
            "entrypoint": "0x080092c4",
            "current_name": "initialize_system_080092c4",
            "code": "\n/* WARNING: This function may have set the stack pointer */\n\nvoid initializeSystem_080092c4(void)\n\n{\n  int offset;\n  undefined4 *ptr;\n  code *jumpTable;\n  \n  for (offset = 0; (undefined4 *)(offset + 0x20000000) < &completed_8911; offset = offset + 4) {\n    *(undefined4 *)(offset + 0x20000000) = *(undefined4 *)(&__fini_array_end + offset);\n  }\n  for (ptr = &completed_8911; ptr < &_ebss; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x80092fa;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x080092fa. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080092c4": "initialize_system_080092c4",
                "iVar1": "offset",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "SystemInit",
                "__libc_init_array",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009314": {
            "entrypoint": "0x08009314",
            "current_name": "infinite_loop_08009314",
            "code": "\nvoid infiniteLoop_08009314(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08009314": "infinite_loop_08009314"
            },
            "calling": [
                "DMA1_Stream3_IRQHandler"
            ],
            "called": [
                "DMA1_Stream3_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009318": {
            "entrypoint": "0x08009318",
            "current_name": "calculate_exponent_08009318",
            "code": "\ndouble calculateExponent_08009318(double inputValue)\n\n{\n  uint tempVar1;\n  uint tempVar2;\n  uint exponent;\n  uint shiftedBits;\n  double outputValue;\n  double tempOut1;\n  double tempOut2;\n  double tempOut3;\n  undefined8 result;\n  \n  shiftedBits = (tempVar2 << 1) >> 0x15;\n  exponent = shiftedBits - 0x3ff;\n  if ((int)exponent < 0x14) {\n    if ((int)exponent < 0) {\n      result = __aeabi_dadd(tempVar1,tempVar2,0x8800759c,0x7e37e43c);\n      __aeabi_dcmpgt((int)result,(int)((ulonglong)result >> 0x20),0,0);\n      outputValue = tempOut2;\n    }\n    else if ((tempVar2 & 0xfffff >> (exponent & 0xff) | tempVar1) != 0) {\n      result = __aeabi_dadd(tempVar1,tempVar2,0x8800759c,0x7e37e43c);\n      __aeabi_dcmpgt((int)result,(int)((ulonglong)result >> 0x20),0,0);\n      outputValue = tempOut1;\n    }\n  }\n  else if ((int)exponent < 0x34) {\n    if ((0xffffffffU >> (shiftedBits - 0x413 & 0xff) & tempVar1) != 0) {\n      result = __aeabi_dadd(tempVar1,tempVar2,0x8800759c,0x7e37e43c);\n      __aeabi_dcmpgt((int)result,(int)((ulonglong)result >> 0x20),0,0);\n      outputValue = tempOut3;\n    }\n  }\n  else if (exponent == 0x400) {\n    outputValue = (double)__aeabi_dadd();\n  }\n  return outputValue;\n}\n\n",
            "renaming": {
                "FUN_08009318": "calculate_exponent_08009318",
                "__x": "inputValue",
                "in_r0": "tempVar1",
                "in_r1": "tempVar2",
                "uVar1": "exponent",
                "uVar2": "shiftedBits",
                "uVar3": "result",
                "in_d0": "outputValue",
                "extraout_d0": "tempOut1",
                "extraout_d0_00": "tempOut2",
                "extraout_d0_01": "tempOut3"
            },
            "calling": [
                "calculate_trapezoid_for_block",
                "homing_cycle",
                "plan_buffer_line"
            ],
            "called": [
                "__aeabi_dadd",
                "__aeabi_dcmpgt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009410": {
            "entrypoint": "0x08009410",
            "current_name": "trig_function_08009410",
            "code": "\ndouble trigFunction_08009410(double input)\n\n{\n  undefined4 integerPart;\n  uint remainder;\n  uint fractionPart;\n  double result;\n  undefined4 localVar1;\n  undefined4 localVar2;\n  undefined4 localVar3;\n  undefined4 localVar4;\n  \n  if (0x3fe921fb < (fractionPart & 0x7fffffff)) {\n    if ((fractionPart & 0x7fffffff) < 0x7ff00000) {\n      remainder = __ieee754_rem_pio2(integerPart,fractionPart,&localVar1);\n      remainder = remainder & 3;\n      if (remainder == 1) {\n        result = (double)__kernel_sin(localVar1,localVar2,localVar3,localVar4,1);\n      }\n      else if (remainder == 2) {\n        result = (double)__kernel_cos(localVar1,localVar2,localVar3,localVar4);\n      }\n      else if (remainder == 0) {\n        result = (double)__kernel_cos(localVar1,localVar2,localVar3,localVar4);\n      }\n      else {\n        result = (double)__kernel_sin(localVar1,localVar2,localVar3,localVar4,1);\n      }\n    }\n    else {\n      result = (double)__subdf3();\n    }\n    return result;\n  }\n  result = (double)__kernel_cos(integerPart,fractionPart,0,0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009410": "trig_function_08009410",
                "__x": "input",
                "in_r0": "integerPart",
                "in_r1": "fractionPart",
                "uVar1": "remainder",
                "dVar2": "result",
                "local_28": "localVar1",
                "uStack_24": "localVar2",
                "local_20": "localVar3",
                "uStack_1c": "localVar4"
            },
            "calling": [
                "mc_arc"
            ],
            "called": [
                "__ieee754_rem_pio2",
                "__kernel_sin",
                "__kernel_cos",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080094c0": {
            "entrypoint": "0x080094c0",
            "current_name": "calculate_value_080094c0",
            "code": "\ndouble calculateValue_080094c0(double input)\n\n{\n  uint lowerBits;\n  uint upperBits;\n  uint bitDifference;\n  uint shiftAmount;\n  double result;\n  double temp1;\n  double temp2;\n  double temp3;\n  undefined8 temp;\n  \n  shiftAmount = (upperBits << 1) >> 0x15;\n  bitDifference = shiftAmount - 0x3ff;\n  if ((int)bitDifference < 0x14) {\n    if ((int)bitDifference < 0) {\n      temp = __aeabi_dadd(lowerBits,upperBits,0x8800759c,0x7e37e43c);\n      __aeabi_dcmpgt((int)temp,(int)((ulonglong)temp >> 0x20),0,0);\n      result = temp3;\n    }\n    else if ((upperBits & 0xfffff >> (bitDifference & 0xff) | lowerBits) != 0) {\n      temp = __aeabi_dadd(lowerBits,upperBits,0x8800759c,0x7e37e43c);\n      __aeabi_dcmpgt((int)temp,(int)((ulonglong)temp >> 0x20),0,0);\n      result = temp1;\n    }\n  }\n  else if ((int)bitDifference < 0x34) {\n    if ((0xffffffffU >> (shiftAmount - 0x413 & 0xff) & lowerBits) != 0) {\n      temp = __aeabi_dadd(lowerBits,upperBits,0x8800759c,0x7e37e43c);\n      __aeabi_dcmpgt((int)temp,(int)((ulonglong)temp >> 0x20),0,0);\n      result = temp2;\n    }\n  }\n  else if (bitDifference == 0x400) {\n    result = (double)__aeabi_dadd();\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080094c0": "calculate_value_080094c0",
                "__x": "input",
                "in_r0": "lowerBits",
                "in_r1": "upperBits",
                "uVar1": "bitDifference",
                "uVar2": "shiftAmount",
                "uVar3": "temp",
                "in_d0": "result",
                "extraout_d0": "temp1",
                "extraout_d0_00": "temp2",
                "extraout_d0_01": "temp3"
            },
            "calling": [
                "calculate_trapezoid_for_block",
                "mc_dwell",
                "mc_arc",
                "__kernel_rem_pio2"
            ],
            "called": [
                "__aeabi_dadd",
                "__aeabi_dcmpgt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080095b8": {
            "entrypoint": "0x080095b8",
            "current_name": "calculate_power_080095b8",
            "code": "\nlong calculate_power_080095b8(double number)\n\n{\n  uint exponent;\n  uint bit_shift;\n  uint carry;\n  uint shift_count;\n  uint result;\n  long sign;\n  uint power_diff;\n  \n  shift_count = (bit_shift << 1) >> 0x15;\n  power_diff = shift_count - 0x3ff;\n  if ((int)bit_shift < 0) {\n    sign = -1;\n  }\n  else {\n    sign = 1;\n  }\n  result = bit_shift & 0xfffff | 0x100000;\n  if ((int)power_diff < 0x14) {\n    if ((int)power_diff < 0) {\n      if (power_diff != 0xffffffff) {\n        sign = 0;\n      }\n      return sign;\n    }\n    result = result + (0x80000 >> (power_diff & 0xff)) >> (0x14 - power_diff & 0xff);\n  }\n  else {\n    if (0x1e < power_diff) {\n      sign = __aeabi_d2iz();\n      return sign;\n    }\n    if ((int)power_diff < 0x34) {\n      carry = 0x80000000 >> (shift_count - 0x413 & 0xff);\n      if (CARRY4(carry,exponent) != false) {\n        result = result + 1;\n      }\n      result = result << (shift_count - 0x413 & 0xff);\n      if (power_diff != 0x14) {\n        result = result | carry + exponent >> (0x34 - power_diff & 0xff);\n      }\n    }\n    else {\n      result = result << (shift_count - 0x413 & 0xff) | exponent << (shift_count - 0x433 & 0xff);\n    }\n  }\n  return result * sign;\n}\n\n",
            "renaming": {
                "FUN_080095b8": "calculate_power_080095b8",
                "__x": "number",
                "in_r0": "exponent",
                "in_r1": "bit_shift",
                "uVar1": "carry",
                "uVar2": "shift_count",
                "uVar3": "result",
                "lVar4": "sign",
                "uVar5": "power_diff"
            },
            "calling": [
                "homing_cycle",
                "plan_buffer_line"
            ],
            "called": [
                "__aeabi_d2iz"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009654": {
            "entrypoint": "0x08009654",
            "current_name": "calculate_modified_number_08009654",
            "code": "\ndouble calculateModifiedNumber_08009654(double inputNumber)\n\n{\n  int intValue;\n  int shiftedValue;\n  double result;\n  \n  shiftedValue = ((uint)(intValue << 1) >> 0x15) - 0x3ff;\n  if (((0x13 < shiftedValue) && (0x33 < shiftedValue)) && (shiftedValue == 0x400)) {\n    result = (double)__aeabi_dadd();\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009654": "calculate_modified_number_08009654",
                "__x": "inputNumber",
                "in_r1": "intValue",
                "iVar1": "shiftedValue",
                "in_d0": "result"
            },
            "calling": [
                "settings_store_global_setting"
            ],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080096e8": {
            "entrypoint": "0x080096e8",
            "current_name": "calculate_trigonometric_value_080096e8",
            "code": "\ndouble calculate_trigonometric_value_080096e8(double input_value)\n\n{\n  undefined4 input_value_high_bits;\n  uint rem_pio2_result;\n  uint input_value_low_bits;\n  double trigonometric_value;\n  undefined4 output_ptr;\n  undefined4 result_ptr;\n  undefined4 output_ptr_1;\n  undefined4 result_ptr_1;\n  \n  if (0x3fe921fb < (input_value_low_bits & 0x7fffffff)) {\n    if ((input_value_low_bits & 0x7fffffff) < 0x7ff00000) {\n      rem_pio2_result = __ieee754_rem_pio2(input_value_high_bits,input_value_low_bits,&output_ptr);\n      rem_pio2_result = rem_pio2_result & 3;\n      if (rem_pio2_result == 1) {\n        trigonometric_value = (double)__kernel_cos(output_ptr,result_ptr,output_ptr_1,result_ptr_1);\n      }\n      else if (rem_pio2_result == 2) {\n        trigonometric_value = (double)__kernel_sin(output_ptr,result_ptr,output_ptr_1,result_ptr_1,1);\n      }\n      else if (rem_pio2_result == 0) {\n        trigonometric_value = (double)__kernel_sin(output_ptr,result_ptr,output_ptr_1,result_ptr_1,1);\n      }\n      else {\n        trigonometric_value = (double)__kernel_cos(output_ptr,result_ptr,output_ptr_1,result_ptr_1);\n      }\n    }\n    else {\n      trigonometric_value = (double)__subdf3();\n    }\n    return trigonometric_value;\n  }\n  trigonometric_value = (double)__kernel_sin(input_value_high_bits,input_value_low_bits,0,0,0);\n  return trigonometric_value;\n}\n\n",
            "renaming": {
                "FUN_080096e8": "calculate_trigonometric_value_080096e8",
                "__x": "input_value",
                "in_r0": "input_value_high_bits",
                "in_r1": "input_value_low_bits",
                "uVar1": "rem_pio2_result",
                "dVar2": "trigonometric_value",
                "local_28": "output_ptr",
                "uStack_24": "result_ptr",
                "local_20": "output_ptr_1",
                "uStack_1c": "result_ptr_1"
            },
            "calling": [
                "mc_arc"
            ],
            "called": [
                "__ieee754_rem_pio2",
                "__kernel_sin",
                "__kernel_cos",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009798": {
            "entrypoint": "0x08009798",
            "current_name": "calculate_result_08009798",
            "code": "\ndouble calculateResult_08009798(double inputValue)\n\n{\n  int inputInteger1;\n  int shiftedBits;\n  double result;\n  \n  shiftedBits = ((uint)(inputInteger1 << 1) >> 0x15) - 0x3ff;\n  if (shiftedBits < 0x14) {\n    if (shiftedBits < 0) {\n      return result;\n    }\n  }\n  else {\n    if (shiftedBits < 0x34) {\n      return result;\n    }\n    if (shiftedBits != 0x400) {\n      return result;\n    }\n    result = (double)__aeabi_dadd();\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009798": "calculate_result_08009798",
                "__x": "inputValue",
                "in_r1": "inputInteger1",
                "iVar1": "shiftedBits",
                "in_d0": "result"
            },
            "calling": [
                "gc_execute_line",
                "protocol_execute_line",
                "settings_store_global_setting"
            ],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009818": {
            "entrypoint": "0x08009818",
            "current_name": "FUN_08009818",
            "code": "\nvoid __ieee754_atan2(uint param_1,uint param_2,uint param_3,uint param_4,double param_5)\n\n{\n  int iVar1;\n  undefined4 unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  \n  uVar3 = param_4 & 0x7fffffff;\n  if (((uVar3 | (-param_3 | param_3) >> 0x1f) < 0x7ff00001) &&\n     (uVar4 = param_2 & 0x7fffffff, (uVar4 | (-param_1 | param_1) >> 0x1f) < 0x7ff00001)) {\n    if ((param_4 + 0xc0100000 | param_3) == 0) {\n      atan(param_5);\n      return;\n    }\n    uVar2 = (int)param_4 >> 0x1e & 2U | param_2 >> 0x1f;\n    if (((((uVar4 | param_1) != 0) && ((uVar3 | param_3) != 0)) && (uVar3 != 0x7ff00000)) &&\n       (uVar4 != 0x7ff00000)) {\n      iVar1 = (int)(uVar4 - uVar3) >> 0x14;\n      if (((int)(uVar4 - uVar3) < 0x3d00000) &&\n         ((-1 < (int)param_4 || (iVar1 + 0x3c < 0 == SCARRY4(iVar1,0x3c))))) {\n        __divdf3(param_1,param_2,param_3,param_4);\n        fabs((double)CONCAT44(unaff_r4,param_4));\n        atan((double)CONCAT44(unaff_r4,param_4));\n      }\n      if (uVar2 != 1) {\n        if (uVar2 == 2) {\n          uVar5 = __subdf3();\n          __subdf3(0x54442d18,0x400921fb,(int)uVar5,(int)((ulonglong)uVar5 >> 0x20));\n        }\n        else if (uVar2 != 0) {\n          uVar5 = __subdf3();\n          __subdf3((int)uVar5,(int)((ulonglong)uVar5 >> 0x20),0x54442d18,0x400921fb);\n        }\n      }\n    }\n  }\n  else {\n    __aeabi_dadd(param_3,param_4,param_1,param_2);\n  }\n  return;\n}\n\n",
            "renaming": {},
            "calling": [
                "mc_arc"
            ],
            "called": [
                "__ieee754_atan2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800981c": {
            "entrypoint": "0x0800981c",
            "current_name": "calculate_hypotenuse_0800981c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080098b6) */\n\ndouble calculateHypotenuse_0800981c(double sideLength1,double sideLength2)\n\n{\n  int checkResult;\n  undefined4 *errnoPtr;\n  double hypotenuse;\n  double temp0;\n  double temp1;\n  double temp2;\n  double errorValue;\n  double temp3;\n  int parameter1;\n  char *parameter2;\n  \n  hypotenuse = (double)__ieee754_hypot();\n  if ((((__fdlib_version != -1) &&\n       (checkResult = finite((double)CONCAT44(parameter2,parameter1)), hypotenuse = temp0,\n       checkResult == 0)) &&\n      (checkResult = finite((double)CONCAT44(parameter2,parameter1)), hypotenuse = temp1\n      , checkResult != 0)) &&\n     ((checkResult = finite((double)CONCAT44(parameter2,parameter1)), hypotenuse = temp2\n      , checkResult != 0 &&\n      (((__fdlib_version != '\\0' && (__fdlib_version == '\\x02')) ||\n       (checkResult = matherr((exception *)&stack0xffffffb0), hypotenuse = temp3, checkResult == 0)))))) {\n    errnoPtr = (undefined4 *)__errno();\n    *errnoPtr = 0x22;\n    hypotenuse = errorValue;\n  }\n  return hypotenuse;\n}\n\n",
            "renaming": {
                "FUN_0800981c": "calculate_hypotenuse_0800981c",
                "__x": "sideLength1",
                "__y": "sideLength2",
                "iVar1": "checkResult",
                "puVar2": "errnoPtr",
                "dVar3": "hypotenuse",
                "extraout_d0": "temp0",
                "extraout_d0_00": "temp1",
                "extraout_d0_01": "temp2",
                "extraout_d0_02": "errorValue",
                "extraout_d0_03": "temp3",
                "in_stack_ffffffb0": "parameter1",
                "in_stack_ffffffb4": "parameter2"
            },
            "calling": [
                "gc_execute_line",
                "mc_arc"
            ],
            "called": [
                "__errno",
                "finite",
                "__ieee754_hypot",
                "matherr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080098d0": {
            "entrypoint": "0x080098d0",
            "current_name": "calculate_square_root_080098d0",
            "code": "\ndouble calculateSquareRoot_080098d0(double input)\n\n{\n  char versionFlag;\n  int comparisonResult;\n  undefined4 *errorPointer;\n  int *errnoPointer;\n  double result;\n  double temporaryResult;\n  double temporaryResult_2;\n  double temporaryResult_3;\n  double temporaryResult_4;\n  double temporaryResult_5;\n  undefined exceptionData [24];\n  undefined8 tempVariable;\n  int errorValue;\n  \n  result = (double)__ieee754_sqrt();\n  versionFlag = __fdlib_version;\n  if (((__fdlib_version == -1) || (errorValue = __unorddf2(), result = temporaryResult, errorValue != 0)) ||\n     (comparisonResult = __aeabi_dcmplt(), result = temporaryResult_2, comparisonResult == 0)) {\n    return result;\n  }\n  exceptionData._0_4_ = 1;\n  exceptionData._4_4_ = \"sqrt\";\n  if (versionFlag == '\\0') {\n    tempVariable = 0.0;\nLAB_0800996c:\n    comparisonResult = matherr((exception *)exceptionData);\n    result = temporaryResult_4;\n    if (comparisonResult != 0) goto joined_r0x0800997a;\n  }\n  else {\n    tempVariable = (double)__divdf3(0,0,0,0);\n    if (versionFlag != '\\x02') goto LAB_0800996c;\n  }\n  errorPointer = (undefined4 *)__errno();\n  *errorPointer = 0x21;\n  result = temporaryResult_3;\njoined_r0x0800997a:\n  if (errorValue != 0) {\n    errnoPointer = (int *)__errno();\n    *errnoPointer = errorValue;\n    result = temporaryResult_5;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080098d0": "calculate_square_root_080098d0",
                "__x": "input",
                "cVar1": "versionFlag",
                "iVar2": "comparisonResult",
                "puVar3": "errorPointer",
                "piVar4": "errnoPointer",
                "dVar5": "result",
                "extraout_d0": "temporaryResult",
                "extraout_d0_00": "temporaryResult_2",
                "extraout_d0_01": "temporaryResult_3",
                "extraout_d0_02": "temporaryResult_4",
                "extraout_d0_03": "temporaryResult_5",
                "local_50": "exceptionData",
                "local_38": "tempVariable",
                "local_30": "errorValue"
            },
            "calling": [
                "gc_execute_line",
                "homing_cycle",
                "max_allowable_speed",
                "plan_buffer_line"
            ],
            "called": [
                "__errno",
                "__ieee754_sqrt",
                "__aeabi_dcmplt",
                "__unorddf2",
                "__divdf3",
                "matherr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009990": {
            "entrypoint": "0x08009990",
            "current_name": "calculate_arc_tan_08009990",
            "code": "\nvoid calculateArcTan_08009990(uint input1,uint input2,uint input3,uint input4,double angle)\n\n{\n  int tempVar1;\n  undefined4 tempVar2;\n  uint tempVar3;\n  uint tempVar4;\n  uint tempVar5;\n  undefined8 tempVar6;\n  \n  tempVar4 = input4 & 0x7fffffff;\n  if (((tempVar4 | (-input3 | input3) >> 0x1f) < 0x7ff00001) &&\n     (tempVar5 = input2 & 0x7fffffff, (tempVar5 | (-input1 | input1) >> 0x1f) < 0x7ff00001)) {\n    if ((input4 + 0xc0100000 | input3) == 0) {\n      atan(angle);\n      return;\n    }\n    tempVar3 = (int)input4 >> 0x1e & 2U | input2 >> 0x1f;\n    if (((((tempVar5 | input1) != 0) && ((tempVar4 | input3) != 0)) && (tempVar4 != 0x7ff00000)) &&\n       (tempVar5 != 0x7ff00000)) {\n      tempVar1 = (int)(tempVar5 - tempVar4) >> 0x14;\n      if (((int)(tempVar5 - tempVar4) < 0x3d00000) &&\n         ((-1 < (int)input4 || (tempVar1 + 0x3c < 0 == SCARRY4(tempVar1,0x3c))))) {\n        __divdf3(input1,input2,input3,input4);\n        fabs((double)CONCAT44(tempVar2,input4));\n        atan((double)CONCAT44(tempVar2,input4));\n      }\n      if (tempVar3 != 1) {\n        if (tempVar3 == 2) {\n          tempVar6 = __subdf3();\n          __subdf3(0x54442d18,0x400921fb,(int)tempVar6,(int)((ulonglong)tempVar6 >> 0x20));\n        }\n        else if (tempVar3 != 0) {\n          tempVar6 = __subdf3();\n          __subdf3((int)tempVar6,(int)((ulonglong)tempVar6 >> 0x20),0x54442d18,0x400921fb);\n        }\n      }\n    }\n  }\n  else {\n    __aeabi_dadd(input3,input4,input1,input2);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009990": "calculate_arc_tan_08009990",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "param_5": "angle",
                "iVar1": "tempVar1",
                "unaff_r4": "tempVar2",
                "uVar2": "tempVar3",
                "uVar3": "tempVar4",
                "uVar4": "tempVar5",
                "uVar5": "tempVar6"
            },
            "calling": [
                "atan2"
            ],
            "called": [
                "fabs",
                "atan",
                "__aeabi_dadd",
                "__divdf3",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009b24": {
            "entrypoint": "0x08009b24",
            "current_name": "calculate_result_08009b24",
            "code": "\nuint calculateResult_08009b24(uint input1,uint input2,uint input3,uint input4)\n\n{\n  undefined4 result1;\n  int result2;\n  uint temp1;\n  int temp2;\n  undefined4 temp3;\n  int temp4;\n  uint temp5;\n  undefined4 temp6;\n  undefined4 temp7;\n  undefined8 temp8;\n  undefined8 temp9;\n  undefined8 temp10;\n  undefined8 temp11;\n  int localVar;\n  \n  input2 = input2 & 0x7fffffff;\n  input4 = input4 & 0x7fffffff;\n  temp1 = input1;\n  temp5 = input2;\n  if (input2 < input4) {\n    temp1 = input3;\n    input3 = input1;\n    temp5 = input4;\n    input4 = input2;\n  }\n  if (0x3c00000 < (int)(temp5 - input4)) {\n    temp1 = __aeabi_dadd(temp1,temp5,input3,input4);\n    return temp1;\n  }\n  if (temp5 < 0x5f300001) {\n    localVar = 0;\n  }\n  else {\n    if (0x7fefffff < temp5) {\n      if ((temp5 & 0xfffff | temp1) != 0) {\n        temp1 = __aeabi_dadd(temp1,temp5,input3,input4);\n      }\n      if ((input4 ^ 0x7ff00000 | input3) != 0) {\n        return temp1;\n      }\n      return input3;\n    }\n    temp5 = temp5 + 0xda800000;\n    input4 = input4 + 0xda800000;\n    localVar = 600;\n  }\n  temp9 = CONCAT44(temp5,temp1);\n  temp8 = CONCAT44(input4,input3);\n  if ((int)input4 < 0x20b00000) {\n    if ((int)input4 < 0x100000) {\n      if ((input4 | input3) == 0) {\n        return temp1;\n      }\n      temp8 = __muldf3(input3,input4,0,0x7fd00000);\n      temp9 = __muldf3(temp1,temp5,0,0x7fd00000);\n      localVar = localVar + -0x3fe;\n    }\n    else {\n      temp5 = temp5 + 0x25800000;\n      temp9 = CONCAT44(temp5,temp1);\n      input4 = input4 + 0x25800000;\n      temp8 = CONCAT44(input4,input3);\n      localVar = localVar + -600;\n    }\n  }\n  temp7 = (undefined4)((ulonglong)temp9 >> 0x20);\n  temp6 = (undefined4)temp9;\n  temp4 = (int)((ulonglong)temp8 >> 0x20);\n  temp3 = (undefined4)temp8;\n  temp8 = __subdf3(temp6,temp7,temp3,temp4);\n  temp2 = (int)((ulonglong)temp8 >> 0x20);\n  result1 = (undefined4)temp8;\n  result2 = __aeabi_dcmplt(temp3,temp4,result1,temp2);\n  if (result2 == 0) {\n    temp8 = __muldf3(0,input4,0);\n    temp9 = __muldf3(result1,temp2 + -0x80000000,result1,temp2);\n    temp10 = __aeabi_dadd(temp6,temp7,temp6,temp7);\n    temp10 = __subdf3((int)temp10,(int)((ulonglong)temp10 >> 0x20),0,temp5 + 0x100000);\n    temp10 = __muldf3((int)temp10,(int)((ulonglong)temp10 >> 0x20),temp3,temp4);\n    temp11 = __subdf3(temp3,temp4,0,input4);\n    temp11 = __muldf3((int)temp11,(int)((ulonglong)temp11 >> 0x20),0,temp5 + 0x100000);\n    temp10 = __aeabi_dadd((int)temp10,(int)((ulonglong)temp10 >> 0x20),(int)temp11,\n                          (int)((ulonglong)temp11 >> 0x20));\n    temp9 = __subdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),(int)temp10,\n                      (int)((ulonglong)temp10 >> 0x20));\n    __subdf3((int)temp8,(int)((ulonglong)temp8 >> 0x20),(int)temp9,\n             (int)((ulonglong)temp9 >> 0x20));\n    temp8 = __ieee754_sqrt();\n  }\n  else {\n    temp8 = __muldf3(0,temp5,0,temp5);\n    temp9 = __muldf3(temp3,temp4 + -0x80000000,temp3,temp4);\n    temp10 = __aeabi_dadd(temp6,temp7,0,temp5);\n    temp11 = __subdf3(temp6,temp7,0,temp5);\n    temp10 = __muldf3((int)temp10,(int)((ulonglong)temp10 >> 0x20),(int)temp11,\n                      (int)((ulonglong)temp11 >> 0x20));\n    temp9 = __subdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),(int)temp10,\n                      (int)((ulonglong)temp10 >> 0x20));\n    __subdf3((int)temp8,(int)((ulonglong)temp8 >> 0x20),(int)temp9,\n             (int)((ulonglong)temp9 >> 0x20));\n    temp8 = __ieee754_sqrt();\n  }\n  temp1 = (uint)temp8;\n  if (localVar != 0) {\n    temp1 = __muldf3(temp1,(int)((ulonglong)temp8 >> 0x20),0,localVar * 0x100000 + 0x3ff00000);\n  }\n  return temp1;\n}\n\n",
            "renaming": {
                "FUN_08009b24": "calculate_result_08009b24",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "result1",
                "iVar2": "result2",
                "uVar3": "temp1",
                "iVar4": "temp2",
                "uVar5": "temp3",
                "iVar6": "temp4",
                "uVar7": "temp5",
                "uVar8": "temp6",
                "uVar9": "temp7",
                "uVar10": "temp8",
                "uVar11": "temp9",
                "uVar12": "temp10",
                "uVar13": "temp11",
                "local_3c": "localVar"
            },
            "calling": [
                "hypot"
            ],
            "called": [
                "__muldf3",
                "__ieee754_sqrt",
                "__aeabi_dcmplt",
                "__aeabi_dadd",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009d78": {
            "entrypoint": "0x08009d78",
            "current_name": "calculate_floating_point_08009d78",
            "code": "\nint calculateFloatingPoint_08009d78(undefined4 inputValue,uint flags,undefined8 *result)\n\n{\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined4 temp3;\n  undefined4 temp4;\n  undefined4 temp5;\n  undefined4 temp6;\n  undefined4 temp7;\n  undefined4 temp8;\n  uint absoluteFlags;\n  int returnValue;\n  undefined8 temp9;\n  undefined8 temp10;\n  undefined8 temp11;\n  undefined4 temp12;\n  undefined4 temp13;\n  undefined4 var1;\n  undefined4 var2;\n  undefined8 var3;\n  undefined8 var4;\n  undefined8 var5;\n  \n  absoluteFlags = flags & 0x7fffffff;\n  if (absoluteFlags < 0x3fe921fc) {\n    *(undefined4 *)result = inputValue;\n    *(uint *)((int)result + 4) = flags;\n    *(undefined4 *)(result + 1) = 0;\n    *(undefined4 *)((int)result + 0xc) = 0;\n    return 0;\n  }\n  if (absoluteFlags < 0x4002d97c) {\n    if ((int)flags < 1) {\n      temp9 = __aeabi_dadd(inputValue,flags,0x54400000,0x3ff921fb);\n      temp2 = (undefined4)((ulonglong)temp9 >> 0x20);\n      temp1 = (undefined4)temp9;\n      if (absoluteFlags != 0x3ff921fb) {\n        temp9 = __aeabi_dadd(temp1,temp2,0x1a626331,0x3dd0b461);\n        *result = temp9;\n        temp9 = __subdf3(temp1,temp2);\n        temp9 = __aeabi_dadd((int)temp9,(int)((ulonglong)temp9 >> 0x20),0x1a626331,0x3dd0b461);\n        result[1] = temp9;\n        return -1;\n      }\n      temp9 = __aeabi_dadd(temp1,temp2,0x1a600000,0x3dd0b461);\n      temp1 = (undefined4)((ulonglong)temp9 >> 0x20);\n      temp10 = __aeabi_dadd((int)temp9,temp1,0x2e037073,0x3ba3198a);\n      *result = temp10;\n      temp9 = __subdf3((int)temp9,temp1);\n      temp9 = __aeabi_dadd((int)temp9,(int)((ulonglong)temp9 >> 0x20),0x2e037073,0x3ba3198a);\n      result[1] = temp9;\n      return -1;\n    }\n    temp9 = __subdf3();\n    temp2 = (undefined4)((ulonglong)temp9 >> 0x20);\n    temp1 = (undefined4)temp9;\n    if (absoluteFlags != 0x3ff921fb) {\n      temp9 = __subdf3(temp1,temp2,0x1a626331,0x3dd0b461);\n      *result = temp9;\n      temp9 = __subdf3(temp1,temp2);\n      temp9 = __subdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),0x1a626331,0x3dd0b461);\n      result[1] = temp9;\n      return 1;\n    }\n    temp9 = __subdf3(temp1,temp2,0x1a600000,0x3dd0b461);\n    temp1 = (undefined4)((ulonglong)temp9 >> 0x20);\n    temp10 = __subdf3((int)temp9,temp1,0x2e037073,0x3ba3198a);\n    *result = temp10;\n    temp9 = __subdf3((int)temp9,temp1);\n    temp9 = __subdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),0x2e037073,0x3ba3198a);\n    result[1] = temp9;\n    return 1;\n  }\n  if (0x413921fb < absoluteFlags) {\n    if (0x7fefffff < absoluteFlags) {\n      temp9 = __subdf3(inputValue,flags,inputValue,flags);\n      result[1] = temp9;\n      *result = temp9;\n      return 0;\n    }\n    returnValue = ((int)absoluteFlags >> 0x14) + -0x416;\n    __aeabi_d2iz();\n    var3 = __aeabi_i2d();\n    temp9 = __subdf3(inputValue,absoluteFlags + returnValue * -0x100000,(int)var3,\n                      (int)((ulonglong)var3 >> 0x20));\n    temp9 = __muldf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),0,0x41700000);\n    __aeabi_d2iz();\n    var4 = __aeabi_i2d();\n    temp9 = __subdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20));\n    var5 = __muldf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),0,0x41700000);\n    __aeabi_dcmpeq((int)var5,(int)((ulonglong)var5 >> 0x20),0,0);\n    returnValue = __kernel_rem_pio2(&var3,result,returnValue);\n    if (-1 < (int)flags) {\n      return returnValue;\n    }\n    *(int *)((int)result + 4) = *(int *)((int)result + 4) + -0x80000000;\n    *(int *)((int)result + 0xc) = *(int *)((int)result + 0xc) + -0x80000000;\n    return -returnValue;\n  }\n  fabs((double)CONCAT44(temp13,temp12));\n  temp9 = __muldf3();\n  __aeabi_dadd((int)temp9,(int)((ulonglong)temp9 >> 0x20),0,0x3fe00000);\n  returnValue = __aeabi_d2iz();\n  temp9 = __aeabi_i2d();\n  temp5 = (undefined4)((ulonglong)temp9 >> 0x20);\n  temp1 = (undefined4)temp9;\n  temp9 = __muldf3(temp1,temp5,0x54400000,0x3ff921fb);\n  temp9 = __subdf3(inputValue,temp4,(int)temp9,(int)((ulonglong)temp9 >> 0x20));\n  temp6 = (undefined4)((ulonglong)temp9 >> 0x20);\n  temp2 = (undefined4)temp9;\n  temp10 = __muldf3(temp1,temp5,0x1a626331,0x3dd0b461);\n  if ((0x1f < returnValue) || (*(uint *)(&npio2_hw + (returnValue + -1) * 4) == absoluteFlags)) {\n    temp11 = __subdf3(temp2,temp6,(int)temp10,(int)((ulonglong)temp10 >> 0x20));\n    if ((int)((absoluteFlags >> 0x14) - ((uint)((int)((ulonglong)temp11 >> 0x20) << 1) >> 0x15)) < 0x11)\n    goto LAB_0800a0ce;\n    temp10 = __muldf3(temp1,temp5,0x1a600000,0x3dd0b461);\n    temp7 = (undefined4)((ulonglong)temp10 >> 0x20);\n    temp9 = __subdf3(temp2,temp6,(int)temp10,temp7);\n    temp8 = (undefined4)((ulonglong)temp9 >> 0x20);\n    temp3 = (undefined4)temp9;\n    temp11 = __subdf3(temp2,temp6,temp3,temp8);\n    temp10 = __subdf3((int)temp11,(int)((ulonglong)temp11 >> 0x20),(int)temp10,temp7);\n    temp11 = __muldf3(temp1,temp5,0x2e037073,0x3ba3198a);\n    temp10 = __subdf3((int)temp11,(int)((ulonglong)temp11 >> 0x20),(int)temp10,\n                      (int)((ulonglong)temp10 >> 0x20));\n    temp11 = __subdf3(temp3,temp8,(int)temp10,(int)((ulonglong)temp10 >> 0x20));\n    if ((int)(((int)absoluteFlags >> 0x14) - ((uint)((int)((ulonglong)temp11 >> 0x20) << 1) >> 0x15)) < 0x32\n       ) goto LAB_0800a0ce;\n    temp10 = __muldf3(temp1,temp5,0x2e000000,0x3ba3198a);\n    temp2 = (undefined4)((ulonglong)temp10 >> 0x20);\n    temp9 = __subdf3(temp3,temp8,(int)temp10,temp2);\n    temp11 = __subdf3(temp3,temp8);\n    temp10 = __subdf3((int)temp11,(int)((ulonglong)temp11 >> 0x20),(int)temp10,temp2);\n    temp11 = __muldf3(temp1,temp5,0x252049c1,0x397b839a);\n    temp10 = __subdf3((int)temp11,(int)((ulonglong)temp11 >> 0x20),(int)temp10,\n                      (int)((ulonglong)temp10 >> 0x20));\n  }\n  temp11 = __subdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),(int)temp10,\n                    (int)((ulonglong)temp10 >> 0x20));\nLAB_0800a0ce:\n  var2 = (undefined4)((ulonglong)temp9 >> 0x20);\n  var1 = (undefined4)temp9;\n  *result = temp11;\n  temp9 = __subdf3(var1,var2);\n  temp9 = __subdf3((int)temp9,(int)((ulonglong)temp9 >> 0x20),(int)temp10,\n                    (int)((ulonglong)temp10 >> 0x20));\n  result[1] = temp9;\n  if ((int)flags < 0) {\n    *(int *)result = (int)temp11;\n    *(int *)((int)result + 4) = (int)((ulonglong)temp11 >> 0x20) + -0x80000000;\n    *(int *)(result + 1) = (int)temp9;\n    *(int *)((int)result + 0xc) = (int)((ulonglong)temp9 >> 0x20) + -0x80000000;\n    returnValue = -returnValue;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08009d78": "calculate_floating_point_08009d78",
                "param_1": "inputValue",
                "param_2": "flags",
                "param_3": "result",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "extraout_r1": "temp4",
                "uVar4": "temp5",
                "uVar5": "temp6",
                "uVar6": "temp7",
                "uVar7": "temp8",
                "uVar8": "absoluteFlags",
                "iVar9": "returnValue",
                "uVar10": "temp9",
                "uVar11": "temp10",
                "uVar12": "temp11",
                "in_stack_ffffffa8": "temp12",
                "in_stack_ffffffac": "temp13",
                "local_50": "var1",
                "uStack_4c": "var2",
                "local_40": "var3",
                "local_38": "var4",
                "local_30": "var5"
            },
            "calling": [
                "sin",
                "cos"
            ],
            "called": [
                "__muldf3",
                "fabs",
                "__aeabi_dadd",
                "__aeabi_dcmpeq",
                "__kernel_rem_pio2",
                "__aeabi_i2d",
                "__aeabi_d2iz",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a1bc": {
            "entrypoint": "0x0800a1bc",
            "current_name": "calculate_sum_0800a1bc",
            "code": "\nuint calculate_sum_0800a1bc(uint input_1,uint input_2)\n\n{\n  uint result;\n  int counter;\n  uint temp_1;\n  undefined4 temp_2;\n  uint temp_3;\n  uint temp_4;\n  uint temp_5;\n  uint temp_6;\n  uint temp_7;\n  int temp_8;\n  uint temp_9;\n  uint temp_10;\n  undefined8 temp_11;\n  \n  if ((~input_2 & 0x7ff00000) == 0) {\n    temp_11 = __muldf3(input_1,input_2,input_1,input_2);\n    temp_5 = __aeabi_dadd((int)temp_11,(int)((ulonglong)temp_11 >> 0x20),input_1,input_2);\n    return temp_5;\n  }\n  if ((int)input_2 < 1) {\n    if ((input_2 & 0x7fffffff | input_1) == 0) {\n      return input_1;\n    }\n    if (input_2 != 0) {\n      temp_11 = __subdf3(input_1,input_2,input_1);\n      temp_2 = (undefined4)((ulonglong)temp_11 >> 0x20);\n      temp_5 = __divdf3((int)temp_11,temp_2,(int)temp_11,temp_2);\n      return temp_5;\n    }\n    do {\n      temp_7 = input_1;\n      temp_5 = temp_7 >> 0xb;\n      input_2 = input_2 - 0x15;\n      input_1 = temp_7 << 0x15;\n    } while (temp_5 == 0);\n    result = input_2;\n    if (-1 < (int)temp_7) goto LAB_0800a290;\n    temp_10 = 0x20;\n    temp_3 = 0xffffffff;\n    temp_7 = input_1;\n  }\n  else {\n    result = (int)input_2 >> 0x14;\n    temp_5 = input_2;\n    temp_7 = input_1;\n    if (result != 0) goto LAB_0800a1da;\nLAB_0800a290:\n    temp_7 = 0;\n    temp_10 = temp_5;\n    do {\n      temp_3 = temp_7;\n      temp_5 = temp_10 << 1;\n      temp_8 = temp_10 << 0xc;\n      temp_7 = temp_3 + 1;\n      temp_10 = temp_5;\n    } while (-1 < temp_8);\n    temp_10 = 0x20 - temp_7;\n    input_2 = result;\n    temp_7 = input_1 << (temp_7 & 0xff);\n  }\n  temp_5 = input_1 >> (temp_10 & 0xff) | temp_5;\n  result = input_2 - temp_3;\nLAB_0800a1da:\n  temp_5 = temp_5 & 0xfffff | 0x100000;\n  if (-1 < (int)(result << 0x1f)) {\n    temp_5 = temp_5 * 2 - ((int)temp_7 >> 0x1f);\n    temp_7 = temp_7 << 1;\n  }\n  temp_10 = 0;\n  temp_5 = temp_5 * 2 - ((int)temp_7 >> 0x1f);\n  temp_7 = temp_7 << 1;\n  result = 0;\n  temp_8 = 0x16;\n  temp_3 = 0x200000;\n  do {\n    counter = result + temp_3;\n    if (counter <= (int)temp_5) {\n      temp_5 = temp_5 - counter;\n      result = counter + temp_3;\n      temp_10 = temp_10 + temp_3;\n    }\n    temp_8 = temp_8 + -1;\n    temp_5 = temp_5 * 2 - ((int)temp_7 >> 0x1f);\n    temp_3 = temp_3 >> 1;\n    temp_7 = temp_7 << 1;\n  } while (temp_8 != 0);\n  counter = 0x20;\n  temp_4 = 0x80000000;\n  temp_8 = 0;\n  temp_3 = 0;\n  do {\n    temp_1 = temp_4 + temp_8;\n    temp_9 = result;\n    if ((int)result < (int)temp_5) {\n      if ((int)temp_1 < 0) {\nLAB_0800a26a:\n        if (-1 < (int)(temp_1 + temp_4)) {\n          temp_9 = result + 1;\n        }\n      }\n      temp_6 = temp_5 - result;\n      result = temp_9;\n      if (temp_7 < temp_1) {\n        temp_6 = temp_6 - 1;\n      }\nLAB_0800a262:\n      temp_8 = temp_1 + temp_4;\n      temp_7 = temp_7 - temp_1;\n      temp_3 = temp_3 + temp_4;\n      temp_5 = temp_6;\n    }\n    else if ((temp_5 == result) && (temp_1 <= temp_7)) {\n      if ((int)temp_1 < 0) goto LAB_0800a26a;\n      temp_6 = 0;\n      result = temp_5;\n      goto LAB_0800a262;\n    }\n    counter = counter + -1;\n    temp_4 = temp_4 >> 1;\n    temp_5 = temp_5 * 2 - ((int)temp_7 >> 0x1f);\n    temp_7 = temp_7 << 1;\n    if (counter == 0) {\n      if ((temp_5 | temp_7) == 0) {\n        temp_3 = temp_3 >> 1;\n      }\n      else if (temp_3 == 0xffffffff) {\n        temp_10 = temp_10 + 1;\n        temp_3 = 0;\n      }\n      else {\n        temp_3 = temp_3 + 1 >> 1;\n      }\n      if ((temp_10 & 1) != 0) {\n        temp_3 = temp_3 | 0x80000000;\n      }\n      return temp_3;\n    }\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_0800a1bc": "calculate_sum_0800a1bc",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar1": "result",
                "iVar2": "counter",
                "uVar3": "temp_1",
                "uVar4": "temp_2",
                "uVar5": "temp_3",
                "uVar6": "temp_4",
                "uVar7": "temp_5",
                "uVar8": "temp_6",
                "uVar9": "temp_7",
                "iVar10": "temp_8",
                "uVar11": "temp_9",
                "uVar12": "temp_10",
                "uVar13": "temp_11"
            },
            "calling": [
                "sqrt",
                "__ieee754_hypot"
            ],
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "__divdf3",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a348": {
            "entrypoint": "0x0800a348",
            "current_name": "calculate_squared_difference_0800a348",
            "code": "\nundefined4 calculate_squared_difference_0800a348(undefined4 base,uint exponent,undefined4 multiplier1,undefined4 multiplier2)\n\n{\n  int is_zero;\n  undefined4 base_low;\n  undefined4 base_high;\n  uint abs_exponent;\n  undefined8 product_low;\n  undefined8 product_high;\n  undefined8 temp_product;\n  undefined4 result_low;\n  undefined4 result_high;\n  undefined4 inner_result_low;\n  undefined4 inner_result_high;\n  \n  abs_exponent = exponent & 0x7fffffff;\n  if (abs_exponent < 0x3e400000) {\n    is_zero = __aeabi_d2iz();\n    if (is_zero == 0) {\n      return 0;\n    }\n    product_low = __muldf3(base,exponent,base,exponent);\n    base_high = (undefined4)((ulonglong)product_low >> 0x20);\n    base_low = (undefined4)product_low;\n    product_high = __muldf3(base_low,base_high,0xbe8838d4,0xbda8fae9);\n    product_high = __aeabi_dadd((int)product_high,(int)((ulonglong)product_high >> 0x20),0xbdb4b1c4,0x3e21ee9e);\n    product_high = __muldf3((int)product_high,(int)((ulonglong)product_high >> 0x20),base_low,base_high);\n    product_high = __subdf3((int)product_high,(int)((ulonglong)product_high >> 0x20),0x809c52ad,0x3e927e4f);\n    product_high = __muldf3((int)product_high,(int)((ulonglong)product_high >> 0x20),base_low,base_high);\n    product_high = __aeabi_dadd((int)product_high,(int)((ulonglong)product_high >> 0x20),0x19cb1590,0x3efa01a0);\n    product_high = __muldf3((int)product_high,(int)((ulonglong)product_high >> 0x20),base_low,base_high);\n    product_high = __subdf3((int)product_high,(int)((ulonglong)product_high >> 0x20),0x16c15177,0x3f56c16c);\n    product_high = __muldf3((int)product_high,(int)((ulonglong)product_high >> 0x20),base_low,base_high);\n    product_high = __aeabi_dadd((int)product_high,(int)((ulonglong)product_high >> 0x20),0x5555554c,0x3fa55555);\n    product_high = __muldf3((int)product_high,(int)((ulonglong)product_high >> 0x20),base_low,base_high);\n  }\n  else {\n    product_low = __muldf3(base,exponent,base,exponent);\n    base_high = (undefined4)((ulonglong)product_low >> 0x20);\n    base_low = (undefined4)product_low;\n    product_high = __muldf3(base_low,base_high,0xbe8838d4,0xbda8fae9);\n    product_high = __aeabi_dadd((int)product_high,(int)((ulonglong)product_high >> 0x20),0xbdb4b1c4,0x3e21ee9e);\n    product_high = __muldf3((int)product_high,(int)((ulonglong)product_high >> 0x20),base_low,base_high);\n    product_high = __subdf3((int)product_high,(int)((ulonglong)product_high >> 0x20),0x809c52ad,0x3e927e4f);\n    product_high = __muldf3((int)product_high,(int)((ulonglong)product_high >> 0x20),base_low,base_high);\n    product_high = __aeabi_dadd((int)product_high,(int)((ulonglong)product_high >> 0x20),0x19cb1590,0x3efa01a0);\n    product_high = __muldf3((int)product_high,(int)((ulonglong)product_high >> 0x20),base_low,base_high);\n    product_high = __subdf3((int)product_high,(int)((ulonglong)product_high >> 0x20),0x16c15177,0x3f56c16c);\n    product_high = __muldf3((int)product_high,(int)((ulonglong)product_high >> 0x20),base_low,base_high);\n    product_high = __aeabi_dadd((int)product_high,(int)((ulonglong)product_high >> 0x20),0x5555554c,0x3fa55555);\n    product_high = __muldf3((int)product_high,(int)((ulonglong)product_high >> 0x20),base_low,base_high);\n    if (0x3fd33332 < abs_exponent) {\n      if (abs_exponent < 0x3fe90001) {\n        is_zero = abs_exponent - 0x200000;\n        product_low = __subdf3(0,0x3ff00000,0,is_zero);\n      }\n      else {\n        is_zero = 0x3fd20000;\n        product_low = 0x3fe7000000000000;\n      }\n      inner_result_high = (undefined4)((ulonglong)product_low >> 0x20);\n      inner_result_low = (undefined4)product_low;\n      product_low = __muldf3(base_low,base_high,0,0x3fe00000);\n      product_low = __subdf3((int)product_low,(int)((ulonglong)product_low >> 0x20),0,is_zero);\n      product_high = __muldf3(base_low,base_high,(int)product_high,(int)((ulonglong)product_high >> 0x20));\n      temp_product = __muldf3(base,exponent,multiplier1,multiplier2);\n      product_high = __subdf3((int)product_high,(int)((ulonglong)product_high >> 0x20),(int)temp_product,\n                       (int)((ulonglong)temp_product >> 0x20));\n      product_low = __subdf3((int)product_low,(int)((ulonglong)product_low >> 0x20),(int)product_high,\n                       (int)((ulonglong)product_high >> 0x20));\n      base_low = __subdf3(inner_result_low,inner_result_high,(int)product_low,(int)((ulonglong)product_low >> 0x20));\n      return base_low;\n    }\n  }\n  result_high = (undefined4)((ulonglong)product_high >> 0x20);\n  result_low = (undefined4)product_high;\n  base_low = (undefined4)((ulonglong)product_low >> 0x20);\n  product_high = __muldf3((int)product_low,base_low,0,0x3fe00000);\n  product_low = __muldf3((int)product_low,base_low,result_low,result_high);\n  temp_product = __muldf3(base,exponent,multiplier1,multiplier2);\n  product_low = __subdf3((int)product_low,(int)((ulonglong)product_low >> 0x20),(int)temp_product,\n                   (int)((ulonglong)temp_product >> 0x20));\n  product_low = __subdf3((int)product_high,(int)((ulonglong)product_high >> 0x20),(int)product_low,\n                   (int)((ulonglong)product_low >> 0x20));\n  base_low = __subdf3(0,0x3ff00000,(int)product_low,(int)((ulonglong)product_low >> 0x20));\n  return base_low;\n}\n\n",
            "renaming": {
                "FUN_0800a348": "calculate_squared_difference_0800a348",
                "param_1": "base",
                "param_2": "exponent",
                "param_3": "multiplier1",
                "param_4": "multiplier2",
                "uVar2": "base_low",
                "uVar3": "base_high",
                "uVar4": "abs_exponent",
                "uVar5": "product_low",
                "uVar6": "product_high",
                "uVar7": "temp_product",
                "local_30": "result_low",
                "uStack_2c": "result_high",
                "local_28": "inner_result_low",
                "uStack_24": "inner_result_high",
                "iVar1": "is_zero"
            },
            "calling": [
                "sin",
                "cos"
            ],
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "__aeabi_d2iz",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800a5a0": {
            "entrypoint": "0x0800a5a0",
            "current_name": "reverse_and_improve_0800a5a0",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nuint reverseAndImprove_0800a5a0(int input,undefined8 *output,int length,int param_4,int param_5,int param_6)\n\n{\n  undefined4 *ptr1;\n  uint result;\n  undefined4 temp1;\n  uint temp2;\n  undefined4 extra_result1;\n  int temp3;\n  uint *ptr2;\n  undefined4 extra_result2;\n  undefined4 extra_result3;\n  undefined4 extra_result4;\n  undefined4 temp4;\n  uint **ptr_ptr;\n  int temp5;\n  int temp6;\n  undefined4 *ptr3;\n  undefined4 temp7;\n  uint temp8;\n  uint *ptr4;\n  int temp9;\n  int temp10;\n  undefined8 *ptr5;\n  undefined8 *ptr6;\n  undefined8 *ptr7;\n  undefined4 *ptr8;\n  undefined8 *ptr9;\n  undefined4 temp11;\n  int temp12;\n  undefined4 *ptr10;\n  bool flag;\n  undefined8 result1;\n  undefined8 result2;\n  undefined8 result3;\n  undefined4 stack_param;\n  int local_var1;\n  int local_var2;\n  uint *local_array1 [2];\n  uint local_array2 [20];\n  undefined8 local_var3;\n  undefined4 local_var4;\n  undefined4 local_var5;\n  undefined8 local_var6;\n  undefined8 local_var7;\n  \n  temp10 = *(int *)(&init_jk + param_5 * 4);\n  temp5 = param_4 + -1;\n  local_array1[1] = (uint *)output;\n  if (length + 0x14 < 0 == SCARRY4(length,0x14)) {\n    local_var2 = (length + -3) / 0x18;\n    temp6 = (local_var2 + 1) * -0x18;\n  }\n  else {\n    temp6 = -0x18;\n    local_var2 = 0;\n  }\n  length = length + temp6;\n  temp6 = local_var2 - temp5;\n  if (-1 < temp10 + temp5) {\n    temp12 = temp10 + temp5 + 1 + temp6;\n    ptr7 = &local_var3;\n    do {\n      while (temp6 < 0) {\n        temp6 = temp6 + 1;\n        *(undefined4 *)ptr7 = 0;\n        *(undefined4 *)((int)ptr7 + 4) = 0;\n        ptr7 = ptr7 + 1;\n        if (temp6 == temp12) goto LAB_0800a626;\n      }\n      result2 = __aeabi_i2d(*(undefined4 *)(param_6 + temp6 * 4));\n      temp6 = temp6 + 1;\n      *ptr7 = result2;\n      ptr7 = ptr7 + 1;\n    } while (temp6 != temp12);\n  }\nLAB_0800a626:\n  ptr3 = (undefined4 *)(input + -8);\n  if (-1 < temp10) {\n    ptr5 = &local_var3 + param_4;\n    temp12 = temp10 + param_4;\n    temp6 = temp5;\n    ptr7 = &local_var7;\n    do {\n      if (temp5 < 0) {\n        result2 = 0;\n      }\n      else {\n        result2 = 0;\n        ptr10 = ptr3;\n        ptr9 = ptr5;\n        do {\n          ptr8 = ptr10 + 2;\n          result1 = __muldf3(*ptr8,ptr10[3],*(undefined4 *)(ptr9 + -1),\n                            *(undefined4 *)((int)ptr9 + -4));\n          result2 = __aeabi_dadd((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result1,\n                                (int)((ulonglong)result1 >> 0x20));\n          ptr10 = ptr8;\n          ptr9 = ptr9 + -1;\n        } while (ptr8 != ptr3 + param_4 * 2);\n      }\n      temp6 = temp6 + 1;\n      *ptr7 = result2;\n      ptr5 = ptr5 + 1;\n      ptr7 = ptr7 + 1;\n    } while (temp6 != temp12);\n  }\n  local_array1[0] = local_array2 + temp10 + -1;\n  local_var1 = temp10;\n  do {\n    temp12 = *(int *)(&local_var7 + local_var1);\n    result2 = CONCAT44(*(undefined4 *)((int)&local_var7 + local_var1 * 8 + 4),temp12);\n    temp6 = local_var1;\n    if (0 < local_var1) {\n      ptr7 = &local_var7 + local_var1;\n      ptr2 = local_array2;\n      do {\n        temp4 = (undefined4)((ulonglong)result2 >> 0x20);\n        __muldf3((int)result2,temp4,0,0x3e700000);\n        __aeabi_d2iz();\n        result1 = __aeabi_i2d();\n        temp1 = (undefined4)((ulonglong)result1 >> 0x20);\n        result3 = __muldf3((int)result1,temp1,0,0x41700000);\n        __subdf3((int)result2,temp4,(int)result3,(int)((ulonglong)result3 >> 0x20));\n        result = __aeabi_d2iz();\n        ptr5 = ptr7 + -1;\n        temp4 = *(undefined4 *)ptr5;\n        temp7 = *(undefined4 *)((int)ptr7 + -4);\n        *ptr2 = result;\n        result2 = __aeabi_dadd((int)result1,temp1,temp4,temp7);\n        temp12 = (int)result2;\n        ptr7 = ptr5;\n        ptr2 = ptr2 + 1;\n      } while (ptr5 != &local_var7);\n    }\n    scalbn((double)CONCAT44(temp6,stack_param),temp12);\n    __muldf3();\n    floor((double)CONCAT44(temp6,stack_param));\n    result2 = __muldf3();\n    result2 = __subdf3(temp12,extra_result1,(int)result2,(int)((ulonglong)result2 >> 0x20));\n    result = __aeabi_d2iz();\n    result1 = __aeabi_i2d();\n    result2 = __subdf3((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result1,\n                      (int)((ulonglong)result1 >> 0x20));\n    temp4 = (undefined4)((ulonglong)result2 >> 0x20);\n    temp1 = (undefined4)result2;\n    if (length < 1) {\n      if (length == 0) {\n        temp12 = (int)local_array2[temp6 + -1] >> 0x17;\n        goto joined_r0x0800a8b8;\n      }\n      temp12 = __aeabi_dcmpge(temp1,temp4,0,0x3fe00000);\n      if (temp12 != 0) {\n        result = result + 1;\n        if (temp6 < 1) {\n          result2 = __subdf3(0,0x3ff00000,temp1,temp4);\n          temp12 = 2;\n          goto LAB_0800a7a4;\n        }\n        temp12 = 2;\n        goto LAB_0800a8c8;\n      }\n    }\n    else {\n      temp3 = (int)local_array2[temp6 + -1] >> (0x18U - length & 0xff);\n      temp8 = local_array2[temp6 + -1] - (temp3 << (0x18U - length & 0xff));\n      temp12 = (int)temp8 >> (0x17U - length & 0xff);\n      local_array2[temp6 + -1] = temp8;\n      result = result + temp3;\njoined_r0x0800a8b8:\n      if (0 < temp12) {\n        result = result + 1;\n        if (temp6 < 1) {\n          flag = false;\n        }\n        else {\nLAB_0800a8c8:\n          if (local_array2[0] == 0) {\n            flag = false;\n            if (temp6 != 1) {\n              ptr2 = local_array2;\n              temp3 = 1;\n              do {\n                ptr2 = ptr2 + 1;\n                if (*ptr2 != 0) {\n                  temp9 = temp3 + 1;\n                  temp8 = *ptr2;\n                  goto LAB_0800a8e2;\n                }\n                temp3 = temp3 + 1;\n              } while (temp3 != temp6);\n              flag = false;\n            }\n          }\n          else {\n            temp9 = 1;\n            temp3 = 0;\n            temp8 = local_array2[0];\nLAB_0800a8e2:\n            local_array2[temp3] = 0x1000000 - temp8;\n            if (temp9 < temp6) {\n              temp8 = local_array2[temp9];\n              ptr2 = local_array2 + temp9;\n              while( true ) {\n                ptr4 = ptr2 + 1;\n                *ptr2 = 0xffffff - temp8;\n                if (ptr4 == local_array2 + temp6) break;\n                temp8 = *ptr4;\n                ptr2 = ptr4;\n              }\n            }\n            flag = true;\n          }\n        }\n        if (0 < length) {\n          if (length == 1) {\n            local_array2[temp6 + -1] = local_array2[temp6 + -1] & 0x7fffff;\n          }\n          else if (length == 2) {\n            local_array2[temp6 + -1] = local_array2[temp6 + -1] & 0x3fffff;\n          }\n        }\n        if (temp12 == 2) {\n          result2 = __subdf3(0,0x3ff00000,temp1,temp4);\n          if (flag) {\n            temp1 = 0;\n            scalbn((double)CONCAT44(temp6,stack_param),0);\n            result2 = __subdf3((int)result2,(int)((ulonglong)result2 >> 0x20),temp1,extra_result2);\n          }\n        }\n      }\n    }\nLAB_0800a7a4:\n    temp9 = (int)result2;\n    temp3 = __aeabi_dcmpeq(temp9,(int)((ulonglong)result2 >> 0x20),0,0);\n    if (temp3 == 0) {\n      scalbn((double)CONCAT44(temp6,stack_param),temp9);\n      temp5 = __aeabi_dcmpge();\n      if (temp5 == 0) {\n        temp3 = temp6;\n        temp8 = __aeabi_d2iz(temp9,extra_result4);\n        local_array2[temp3] = temp8;\n        temp6 = temp3;\n      }\n      else {\n        __muldf3(temp9,extra_result4,0,0x3e700000);\n        temp8 = __aeabi_d2iz();\n        result2 = __aeabi_i2d();\n        result2 = __muldf3((int)result2,(int)((ulonglong)result2 >> 0x20),0,0x41700000);\n        __subdf3(temp9,extra_result4,(int)result2,(int)((ulonglong)result2 >> 0x20));\n        temp5 = temp6;\n        temp2 = __aeabi_d2iz();\n        temp3 = temp6 + 1;\n        local_array2[temp6] = temp2;\n        local_array2[temp3] = temp8;\n        temp6 = temp5;\n      }\n      goto LAB_0800a9f6;\n    }\n    temp3 = temp6 + -1;\n    if (temp10 <= temp3) {\n      temp8 = 0;\n      ptr2 = local_array2 + temp6 + 0x3fffffff;\n      do {\n        ptr4 = ptr2 + -1;\n        temp8 = temp8 | *ptr2;\n        ptr2 = ptr4;\n      } while (ptr4 != local_array1[0]);\n      if (temp8 != 0) break;\n    }\n    if (local_array2[temp10 + -1] == 0) {\n      local_var1 = 1;\n      ptr_ptr = local_array1 + temp10;\n      do {\n        ptr2 = *ptr_ptr;\n        local_var1 = local_var1 + 1;\n        ptr_ptr = ptr_ptr + -1;\n      } while (ptr2 == (uint *)0x0);\n      local_var1 = temp6 + local_var1;\n    }\n    else {\n      local_var1 = temp6 + 1;\n    }\n    temp12 = temp6 + 1;\n    ptr10 = (undefined4 *)(param_6 + (temp12 + local_var2 + 0x3fffffff) * 4);\n    ptr7 = &local_var3 + temp6 + param_4;\n    ptr5 = &local_var7 + temp12;\n    do {\n      ptr10 = ptr10 + 1;\n      result2 = __aeabi_i2d(*ptr10);\n      *ptr7 = result2;\n      ptr9 = ptr7 + 1;\n      if (temp5 < 0) {\n        result1 = 0;\n      }\n      else {\n        result1 = 0;\n        ptr8 = ptr3;\n        while( true ) {\n          ptr7 = ptr7 + -1;\n          ptr1 = ptr8 + 2;\n          result2 = __muldf3((int)result2,(int)((ulonglong)result2 >> 0x20),*ptr1,ptr8[3]);\n          result1 = __aeabi_dadd((int)result1,(int)((ulonglong)result1 >> 0x20),(int)result2,\n                                (int)((ulonglong)result2 >> 0x20));\n          if (ptr1 == ptr3 + param_4 * 2) break;\n          result2 = *ptr7;\n          ptr8 = ptr1;\n        }\n      }\n      *ptr5 = result1;\n      temp12 = temp12 + 1;\n      ptr7 = ptr9;\n      ptr5 = ptr5 + 1;\n    } while (temp12 <= local_var1);\n  } while( true );\n  if (local_array2[temp3] == 0) {\n    ptr2 = local_array2 + temp6 + 0x3ffffffe;\n    do {\n      temp8 = *ptr2;\n      temp3 = temp3 + -1;\n      ptr2 = ptr2 + -1;\n    } while (temp8 == 0);\n  }\nLAB_0800a9f6:\n  temp1 = 0;\n  scalbn((double)CONCAT44(temp6,stack_param),0);\n  result2 = CONCAT44(extra_result3,temp1);\n  if (temp3 < 0) {\n    if (2 < param_5) {\n      if (param_5 == 3) {\n        ptr7 = (undefined8 *)&local_var4;\n        result2 = 0;\nLAB_0800abe4:\n        if (temp12 == 0) {\n          temp1 = *(undefined4 *)(ptr7 + 1);\n          temp4 = *(undefined4 *)((int)ptr7 + 0xc);\n          *local_array1[1] = local_var4;\n          *(undefined4 *)((int)local_array1[1] + 4) = local_var5;\n          *(undefined8 *)((int)local_array1[1] + 0x10) = result2;\n          *(undefined4 *)((int)local_array1[1] + 8) = temp1;\n          *(undefined4 *)((int)local_array1[1] + 0xc) = temp4;\n          return result & 7;\n        }\n        temp5 = *(int *)((int)ptr7 + 4);\n        *(int *)((int)local_array1[1] + 0x10) = (int)result2;\n        temp10 = *(int *)((int)ptr7 + 0xc);\n        *(undefined4 *)((int)local_array1[1] + 8) = *(undefined4 *)(ptr7 + 1);\n        *(int *)((int)local_array1[1] + 0x14) = (int)((ulonglong)result2 >> 0x20) + -0x80000000;\n        temp1 = *(undefined4 *)ptr7;\n        *(int *)((int)local_array1[1] + 4) = temp5 + -0x80000000;\n        *(int *)((int)local_array1[1] + 0xc) = temp10 + -0x80000000;\n        *local_array1[1] = temp1;\n        return result & 7;\n      }\n      goto LAB_0800ab0e;\n    }\n    if (param_5 < 1) {\n      if (param_5 != 0) goto LAB_0800ab0e;\n      result2 = 0;\nLAB_0800aafc:\n      temp5 = (int)((ulonglong)result2 >> 0x20);\n      if (temp12 != 0) {\n        temp5 = temp5 + -0x80000000;\n      }\n      *local_array1[1] = (int)result2;\n      *(int *)((int)local_array1[1] + 4) = temp5;\nLAB_0800ab0e:\n      return result & 7;\n    }\n    result2 = 0;\n  }\n  else {\n    ptr5 = &local_var7 + temp3;\n    ptr2 = local_array2 + temp3 + 1;\n    ptr7 = &local_var7 + temp3 + 1;\n    do {\n      temp1 = (undefined4)((ulonglong)result2 >> 0x20);\n      ptr2 = ptr2 + -1;\n      result1 = __aeabi_i2d(*ptr2);\n      result1 = __muldf3((int)result1,(int)((ulonglong)result1 >> 0x20),(int)result2,temp1);\n      ptr7 = ptr7 + -1;\n      *ptr7 = result1;\n      result2 = __muldf3((int)result2,temp1,0,0x3e700000);\n    } while (ptr2 != local_array2);\n    ptr7 = (undefined8 *)&local_var4;\n    temp5 = 0;\n    do {\n      if (temp10 < 0) {\n        result2 = 0;\n      }\n      else {\n        temp1 = 0x40000000;\n        temp4 = 0x3ff921fb;\n        result2 = 0;\n        temp6 = 0;\n        ptr9 = ptr5;\n        ptr3 = &DAT_0800c028;\n        while( true ) {\n          result1 = __muldf3(*(undefined4 *)ptr9,*(undefined4 *)((int)ptr9 + 4),temp1,temp4);\n          result2 = __aeabi_dadd((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result1,\n                                (int)((ulonglong)result1 >> 0x20));\n          temp6 = temp6 + 1;\n          if ((temp10 < temp6) || (temp5 < temp6)) break;\n          temp1 = *ptr3;\n          temp4 = ptr3[1];\n          ptr9 = ptr9 + 1;\n          ptr3 = ptr3 + 2;\n        }\n      }\n      flag = temp5 != temp3;\n      ptr7[temp5] = result2;\n      ptr5 = ptr5 + -1;\n      temp5 = temp5 + 1;\n    } while (flag);\n    if (2 < param_5) {\n      if (param_5 == 3) {\n        if (temp3 != 0) {\n          ptr5 = ptr7 + temp3;\n          result2 = *ptr5;\n          do {\n            temp4 = (undefined4)((ulonglong)result2 >> 0x20);\n            temp1 = (undefined4)result2;\n            temp7 = *(undefined4 *)(ptr5 + -1);\n            temp11 = *(undefined4 *)((int)ptr5 + -4);\n            result2 = __aeabi_dadd(temp1,temp4,temp7,temp11);\n            result1 = __subdf3(temp7,temp11,(int)result2,(int)((ulonglong)result2 >> 0x20));\n            result1 = __aeabi_dadd((int)result1,(int)((ulonglong)result1 >> 0x20),temp1,temp4);\n            *ptr5 = result1;\n            ptr5 = ptr5 + -1;\n            *ptr5 = result2;\n          } while (ptr7 != ptr5);\n          if (1 < temp3) {\n            ptr9 = ptr7 + temp3;\n            result2 = *ptr9;\n            ptr5 = ptr9;\n            do {\n              temp4 = (undefined4)((ulonglong)result2 >> 0x20);\n              temp1 = (undefined4)result2;\n              temp7 = *(undefined4 *)(ptr5 + -1);\n              temp11 = *(undefined4 *)((int)ptr5 + -4);\n              result2 = __aeabi_dadd(temp1,temp4,temp7,temp11);\n              result1 = __subdf3(temp7,temp11,(int)result2,(int)((ulonglong)result2 >> 0x20));\n              result1 = __aeabi_dadd((int)result1,(int)((ulonglong)result1 >> 0x20),temp1,temp4);\n              *ptr5 = result1;\n              ptr5 = ptr5 + -1;\n              *ptr5 = result2;\n            } while (&local_var6 != ptr5);\n            result2 = 0;\n            ptr6 = ptr7 + 2;\n            ptr5 = ptr9 + 1;\n            do {\n              ptr9 = ptr5 + -1;\n              result2 = __aeabi_dadd((int)result2,(int)((ulonglong)result2 >> 0x20),\n                                    *(undefined4 *)ptr9,*(undefined4 *)((int)ptr5 + -4));\n              ptr5 = ptr9;\n            } while (ptr6 != ptr9);\n            goto LAB_0800abe4;\n          }\n        }\n        result2 = 0;\n        goto LAB_0800abe4;\n      }\n      goto LAB_0800ab0e;\n    }\n    if (param_5 < 1) {\n      if (param_5 != 0) goto LAB_0800ab0e;\n      result2 = 0;\n      ptr5 = ptr7 + temp3 + 1;\n      do {\n        ptr9 = ptr5 + -1;\n        result2 = __aeabi_dadd((int)result2,(int)((ulonglong)result2 >> 0x20),*(undefined4 *)ptr9,\n                              *(undefined4 *)((int)ptr5 + -4));\n        ptr5 = ptr9;\n      } while (ptr7 != ptr9);\n      goto LAB_0800aafc;\n    }\n    result2 = 0;\n    ptr5 = ptr7 + temp3 + 1;\n    do {\n      ptr9 = ptr5 + -1;\n      result2 = __aeabi_dadd((int)result2,(int)((ulonglong)result2 >> 0x20),*(undefined4 *)ptr9,\n                            *(undefined4 *)((int)ptr5 + -4));\n      ptr5 = ptr9;\n    } while (ptr7 != ptr9);\n  }\n  temp5 = (int)((ulonglong)result2 >> 0x20);\n  temp1 = (undefined4)result2;\n  if (temp12 == 0) {\n    *(undefined8 *)local_array1[1] = result2;\n    result2 = __subdf3(local_var4,local_var5,temp1,temp5);\n    if (temp3 < 1) goto LAB_0800ad26;\nLAB_0800ad04:\n    temp5 = 1;\n    ptr7 = (undefined8 *)&local_var4;\n    do {\n      result2 = __aeabi_dadd((int)result2,(int)((ulonglong)result2 >> 0x20),\n                            *(undefined4 *)(ptr7 + 1),*(undefined4 *)((int)ptr7 + 0xc));\n      temp5 = temp5 + 1;\n      ptr7 = ptr7 + 1;\n    } while (temp5 <= temp3);\n    if (temp12 == 0) goto LAB_0800ad26;\n  }\n  else {\n    *local_array1[1] = temp1;\n    *(int *)((int)local_array1[1] + 4) = temp5 + -0x80000000;\n    result2 = __subdf3(local_var4,local_var5,temp1,temp5);\n    if (0 < temp3) goto LAB_0800ad04;\n  }\n  result2 = CONCAT44((int)((ulonglong)result2 >> 0x20) + -0x80000000,(int)result2);\nLAB_0800ad26:\n  *(undefined8 *)((int)local_array1[1] + 8) = result2;\n  return result & 7;\n}\n\n",
            "renaming": {
                "FUN_0800a5a0": "reverse_and_improve_0800a5a0",
                "param_1": "input",
                "param_2": "output",
                "param_3": "length",
                "puVar1": "ptr1",
                "uVar2": "result",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "extraout_r1": "extra_result1",
                "iVar5": "temp3",
                "puVar6": "ptr2",
                "extraout_r1_00": "extra_result2",
                "extraout_r1_01": "extra_result3",
                "extraout_r1_02": "extra_result4",
                "uVar7": "temp4",
                "ppuVar8": "ptr_ptr",
                "iVar9": "temp5",
                "iVar10": "temp6",
                "puVar11": "ptr3",
                "uVar12": "temp7",
                "uVar13": "temp8",
                "puVar14": "ptr4",
                "iVar15": "temp9",
                "iVar16": "temp10",
                "puVar17": "ptr5",
                "puVar18": "ptr6",
                "puVar19": "ptr7",
                "puVar20": "ptr8",
                "puVar21": "ptr9",
                "uVar22": "temp11",
                "iVar23": "temp12",
                "puVar24": "ptr10",
                "bVar25": "flag",
                "uVar26": "result1",
                "uVar27": "result2",
                "uVar28": "result3",
                "in_stack_fffffd78": "stack_param",
                "local_280": "local_var1",
                "local_26c": "local_var2",
                "local_260": "local_array1",
                "local_258": "local_array2",
                "uStack_208": "local_var3",
                "local_168": "local_var4",
                "local_164": "local_var5",
                "local_160": "local_var6",
                "uStack_c8": "local_var7"
            },
            "calling": [
                "__ieee754_rem_pio2"
            ],
            "called": [
                "__muldf3",
                "scalbn",
                "__aeabi_dcmpge",
                "__aeabi_dadd",
                "__aeabi_dcmpeq",
                "__aeabi_i2d",
                "__aeabi_d2iz",
                "__subdf3",
                "floor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800adf0": {
            "entrypoint": "0x0800adf0",
            "current_name": "calculate_0800adf0",
            "code": "\nundefined4\ncalculate_0800adf0(undefined4 result,uint value,undefined4 param1,undefined4 param2,int isReversed)\n\n{\n  int conversionResult;\n  undefined4 resultLow;\n  undefined4 resultHigh;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 temp1;\n  undefined8 temp2;\n  undefined8 temp3;\n  \n  if (((value & 0x7fffffff) < 0x3e400000) && (conversionResult = __aeabi_d2iz(), conversionResult == 0)) {\n    return result;\n  }\n  temp2 = __muldf3(result,value,result);\n  uVar4 = (undefined4)((ulonglong)temp2 >> 0x20);\n  resultHigh = (undefined4)temp2;\n  temp2 = __muldf3(result,value,resultHigh,uVar4);\n  uVar5 = (undefined4)((ulonglong)temp2 >> 0x20);\n  resultLow = (undefined4)temp2;\n  temp2 = __muldf3(resultHigh,uVar4,0x5acfd57c,0x3de5d93a);\n  temp2 = __subdf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0x8a2b9ceb,0x3e5ae5e6);\n  temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),resultHigh,uVar4);\n  temp2 = __aeabi_dadd((int)temp2,(int)((ulonglong)temp2 >> 0x20),0x57b1fe7d,0x3ec71de3);\n  temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),resultHigh,uVar4);\n  temp2 = __subdf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0x19c161d5,0x3f2a01a0);\n  temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),resultHigh,uVar4);\n  temp2 = __aeabi_dadd((int)temp2,(int)((ulonglong)temp2 >> 0x20),0x1110f8a6,0x3f811111);\n  temp1 = (undefined4)((ulonglong)temp2 >> 0x20);\n  if (isReversed != 0) {\n    temp3 = __muldf3(param1,param2,0,0x3fe00000);\n    temp2 = __muldf3(resultLow,uVar5,(int)temp2,temp1);\n    temp2 = __subdf3((int)temp3,(int)((ulonglong)temp3 >> 0x20),(int)temp2,\n                     (int)((ulonglong)temp2 >> 0x20));\n    temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),resultHigh,uVar4);\n    temp2 = __subdf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),param1,param2);\n    temp3 = __muldf3(resultLow,uVar5,0x55555549,0x3fc55555);\n    temp2 = __aeabi_dadd((int)temp2,(int)((ulonglong)temp2 >> 0x20),(int)temp3,\n                         (int)((ulonglong)temp3 >> 0x20));\n    resultHigh = __subdf3(result,value,(int)temp2,(int)((ulonglong)temp2 >> 0x20));\n    return resultHigh;\n  }\n  temp2 = __muldf3(resultHigh,uVar4,(int)temp2,temp1);\n  temp2 = __subdf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0x55555549,0x3fc55555);\n  temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),resultLow,uVar5);\n  resultHigh = __aeabi_dadd((int)temp2,(int)((ulonglong)temp2 >> 0x20),result,value);\n  return resultHigh;\n}\n\n",
            "renaming": {
                "FUN_0800adf0": "calculate_0800adf0",
                "param_1": "result",
                "param_2": "value",
                "param_3": "param1",
                "param_4": "param2",
                "param_5": "isReversed",
                "iVar1": "conversionResult",
                "uVar2": "resultLow",
                "uVar3": "resultHigh",
                "uVar6": "temp1",
                "uVar7": "temp2",
                "uVar8": "temp3"
            },
            "calling": [
                "sin",
                "cos"
            ],
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "__aeabi_d2iz",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800af78": {
            "entrypoint": "0x0800af78",
            "current_name": "calculate_polynomial_0800af78",
            "code": "\ndouble calculatePolynomial_0800af78(double input)\n\n{\n  int temporaryVariable1;\n  undefined4 temp1;\n  undefined4 temp2;\n  uint in_r1;\n  undefined4 temp3;\n  undefined4 temp4;\n  undefined4 temp5;\n  uint absoluteValue;\n  int condition;\n  double result;\n  double dVar7;\n  double temp6;\n  undefined8 temp7;\n  undefined8 temp8;\n  undefined4 temporaryVariable3;\n  uint temporaryVariable2;\n  \n  absoluteValue = in_r1 & 0x7fffffff;\n  if (absoluteValue < 0x44100000) {\n    if (absoluteValue < 0x3fdc0000) {\n      temporaryVariable2 = in_r1;\n      if (absoluteValue < 0x3e200000) {\n        temp7 = __aeabi_dadd(temporaryVariable1,in_r1,0x8800759c,0x7e37e43c);\n        condition = __aeabi_dcmpgt((int)temp7,(int)((ulonglong)temp7 >> 0x20),0,0x3ff00000);\n        if (condition != 0) {\n          return temp6;\n        }\n      }\n      condition = -1;\n    }\n    else {\n      fabs((double)CONCAT44(in_r1,temporaryVariable3));\n      if (absoluteValue < 0x3ff30000) {\n        if (absoluteValue < 0x3fe60000) {\n          temp7 = __aeabi_dadd();\n          temp7 = __subdf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),0,0x3ff00000);\n          temp8 = __aeabi_dadd(temporaryVariable1,temp5,0,0x40000000);\n          temp7 = __divdf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),(int)temp8,\n                           (int)((ulonglong)temp8 >> 0x20));\n          temporaryVariable2 = (uint)((ulonglong)temp7 >> 0x20);\n          temporaryVariable1 = (int)temp7;\n          condition = 0;\n        }\n        else {\n          temp7 = __subdf3();\n          temp8 = __aeabi_dadd(temporaryVariable1,temp5,0,0x3ff00000);\n          temp7 = __divdf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),(int)temp8,\n                           (int)((ulonglong)temp8 >> 0x20));\n          temporaryVariable2 = (uint)((ulonglong)temp7 >> 0x20);\n          temporaryVariable1 = (int)temp7;\n          condition = 1;\n        }\n      }\n      else if (absoluteValue < 0x40038000) {\n        temp7 = __subdf3();\n        temp8 = __muldf3(temporaryVariable1,temp5,0,0x3ff80000);\n        temp8 = __aeabi_dadd((int)temp8,(int)((ulonglong)temp8 >> 0x20),0,0x3ff00000);\n        temp7 = __divdf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),(int)temp8,\n                         (int)((ulonglong)temp8 >> 0x20));\n        temporaryVariable2 = (uint)((ulonglong)temp7 >> 0x20);\n        temporaryVariable1 = (int)temp7;\n        condition = 2;\n      }\n      else {\n        temp7 = __divdf3(0,0xbff00000,temporaryVariable1,temp5);\n        temporaryVariable2 = (uint)((ulonglong)temp7 >> 0x20);\n        temporaryVariable1 = (int)temp7;\n        condition = 3;\n      }\n    }\n    temp7 = __muldf3(temporaryVariable1,temporaryVariable2,temporaryVariable1);\n    temp3 = (undefined4)((ulonglong)temp7 >> 0x20);\n    temp1 = (undefined4)temp7;\n    temp7 = __muldf3(temp1,temp3,temp1,temp3);\n    temp4 = (undefined4)((ulonglong)temp7 >> 0x20);\n    temp2 = (undefined4)temp7;\n    temp7 = __muldf3(temp2,temp4,0xe322da11,0x3f90ad3a);\n    temp7 = __aeabi_dadd((int)temp7,(int)((ulonglong)temp7 >> 0x20),0x24760deb,0x3fa97b4b);\n    temp7 = __muldf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),temp2,temp4);\n    temp7 = __aeabi_dadd((int)temp7,(int)((ulonglong)temp7 >> 0x20),0xa0d03d51,0x3fb10d66);\n    temp7 = __muldf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),temp2,temp4);\n    temp7 = __aeabi_dadd((int)temp7,(int)((ulonglong)temp7 >> 0x20),0xc54c206e,0x3fb745cd);\n    temp7 = __muldf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),temp2,temp4);\n    temp7 = __aeabi_dadd((int)temp7,(int)((ulonglong)temp7 >> 0x20),0x920083ff,0x3fc24924);\n    temp7 = __muldf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),temp2,temp4);\n    temp7 = __aeabi_dadd((int)temp7,(int)((ulonglong)temp7 >> 0x20),0x5555550d,0x3fd55555);\n    temp7 = __muldf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),temp1,temp3);\n    temp1 = (undefined4)((ulonglong)temp7 >> 0x20);\n    temp8 = __muldf3(temp2,temp4,0x2c6a6c2f,0xbfa2b444);\n    temp8 = __subdf3((int)temp8,(int)((ulonglong)temp8 >> 0x20),0x52defd9a,0x3fadde2d);\n    temp8 = __muldf3((int)temp8,(int)((ulonglong)temp8 >> 0x20),temp2,temp4);\n    temp8 = __subdf3((int)temp8,(int)((ulonglong)temp8 >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    temp8 = __muldf3((int)temp8,(int)((ulonglong)temp8 >> 0x20),temp2,temp4);\n    temp8 = __subdf3((int)temp8,(int)((ulonglong)temp8 >> 0x20),0xfe231671,0x3fbc71c6);\n    temp8 = __muldf3((int)temp8,(int)((ulonglong)temp8 >> 0x20),temp2,temp4);\n    temp8 = __subdf3((int)temp8,(int)((ulonglong)temp8 >> 0x20),0x9998ebc4,0x3fc99999);\n    temp8 = __muldf3((int)temp8,(int)((ulonglong)temp8 >> 0x20),temp2,temp4);\n    temp2 = (undefined4)((ulonglong)temp8 >> 0x20);\n    if (condition == -1) {\n      temp7 = __aeabi_dadd((int)temp7,temp1,(int)temp8,temp2);\n      temp7 = __muldf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),temporaryVariable1,temporaryVariable2);\n      dVar7 = (double)__subdf3(temporaryVariable1,temporaryVariable2,(int)temp7,(int)((ulonglong)temp7 >> 0x20));\n      return dVar7;\n    }\n    temp7 = __aeabi_dadd((int)temp7,temp1,(int)temp8,temp2);\n    temp7 = __muldf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),temporaryVariable1,temporaryVariable2);\n    temp7 = __subdf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),*(undefined4 *)(&atanlo + condition * 8)\n                     ,*(undefined4 *)(&UNK_0800c094 + condition * 8));\n    temp7 = __subdf3((int)temp7,(int)((ulonglong)temp7 >> 0x20),temporaryVariable1,temporaryVariable2);\n    result = (double)__subdf3(*(undefined4 *)(&atanhi + condition * 8),\n                             *(undefined4 *)(&UNK_0800c074 + condition * 8),(int)temp7,\n                             (int)((ulonglong)temp7 >> 0x20));\n    if ((int)in_r1 < 0) {\n      return result;\n    }\n  }\n  else if ((0x7ff00000 < absoluteValue) || ((absoluteValue == 0x7ff00000 && (temporaryVariable1 != 0)))) {\n    dVar7 = (double)__aeabi_dadd();\n    return dVar7;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800af78": "calculate_polynomial_0800af78",
                "__x": "input",
                "in_r0": "temporaryVariable1",
                "in_d0": "result",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "extraout_r1": "temp5",
                "extraout_d0": "temp6",
                "uVar5": "absoluteValue",
                "iVar6": "condition",
                "uVar8": "temp7",
                "uVar9": "temp8",
                "uVar10": "temporaryVariable2",
                "in_stack_ffffffd0": "temporaryVariable3"
            },
            "calling": [
                "__ieee754_atan2"
            ],
            "called": [
                "__muldf3",
                "fabs",
                "__aeabi_dadd",
                "__divdf3",
                "__subdf3",
                "__aeabi_dcmpgt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b2cc": {
            "entrypoint": "0x0800b2cc",
            "current_name": "calculate_0800b2cc",
            "code": "\ndouble calculate_0800b2cc(double input)\n\n{\n  double result;\n  \n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800b2cc": "calculate_0800b2cc",
                "__x": "input",
                "in_d0": "result"
            },
            "calling": [
                "__ieee754_rem_pio2",
                "__ieee754_atan2",
                "atan"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b2d4": {
            "entrypoint": "0x0800b2d4",
            "current_name": "get_sign_bit_0800b2d4",
            "code": "\nint getSignBit_0800b2d4(double inputValue)\n\n{\n  uint signBit;\n  \n  return (signBit | 0x80000000) + 0x100000 >> 0x1f;\n}\n\n",
            "renaming": {
                "FUN_0800b2d4": "get_sign_bit_0800b2d4",
                "__value": "inputValue",
                "in_r1": "signBit"
            },
            "calling": [
                "hypot"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b2e0": {
            "entrypoint": "0x0800b2e0",
            "current_name": "handle_exception_0800b2e0",
            "code": "\nint handle_exception_0800b2e0(exception *exception_obj)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800b2e0": "handle_exception_0800b2e0",
                "__exc": "exception_obj"
            },
            "calling": [
                "sqrt",
                "hypot"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b2e8": {
            "entrypoint": "0x0800b2e8",
            "current_name": "calculate_exponential_0800b2e8",
            "code": "\ndouble calculateExponential_0800b2e8(double base,int exponent)\n\n{\n  uint shiftCount;\n  int addCount;\n  uint shiftedCount;\n  int finalCount;\n  uint highBits;\n  double result;\n  double extraResult;\n  double finalResult;\n  undefined8 concatenatedVars;\n  \n  concatenatedVars = CONCAT44(shiftCount,exponent);\n  shiftedCount = (shiftCount << 1) >> 0x15;\n  if (shiftedCount == 0) {\n    if ((exponent | shiftCount & 0x7fffffff) == 0) {\n      return result;\n    }\n    concatenatedVars = __muldf3(exponent,shiftCount,0,0x43500000);\n    if (addCount < -50000) goto LAB_0800b34a;\n    shiftedCount = ((uint)((int)((ulonglong)concatenatedVars >> 0x20) << 1) >> 0x15) - 0x36;\n    result = extraResult;\n  }\n  else if (shiftedCount == 0x7ff) {\n    finalResult = (double)__aeabi_dadd(exponent,shiftCount,exponent);\n    return finalResult;\n  }\n  highBits = (uint)((ulonglong)concatenatedVars >> 0x20);\n  finalCount = shiftedCount + addCount;\n  if (finalCount < 0x7ff) {\n    if (0 < finalCount) {\n      return result;\n    }\n    if (finalCount + 0x35 < 0 == SCARRY4(finalCount,0x35)) {\n      finalResult = (double)__muldf3((int)concatenatedVars,highBits & 0x800fffff | (finalCount + 0x36) * 0x100000,0,\n                               0x3c900000);\n      return finalResult;\n    }\n    if (addCount < 0xc351) {\n      concatenatedVars = CONCAT44(highBits & 0x80000000 | 0x1a56e1f,0xc2f8f359);\nLAB_0800b34a:\n      finalResult = (double)__muldf3((int)concatenatedVars,(int)((ulonglong)concatenatedVars >> 0x20),0xc2f8f359,0x1a56e1f);\n      return finalResult;\n    }\n  }\n  finalResult = (double)__muldf3(0x8800759c,highBits & 0x80000000 | 0x7e37e43c,0x8800759c,0x7e37e43c);\n  return finalResult;\n}\n\n",
            "renaming": {
                "FUN_0800b2e8": "calculate_exponential_0800b2e8",
                "__x": "base",
                "__n": "exponent",
                "in_r1": "shiftCount",
                "in_r2": "addCount",
                "uVar1": "shiftedCount",
                "iVar2": "finalCount",
                "uVar3": "highBits",
                "in_d0": "result",
                "extraout_d0": "extraResult",
                "dVar4": "finalResult",
                "uVar5": "concatenatedVars"
            },
            "calling": [
                "__kernel_rem_pio2"
            ],
            "called": [
                "__muldf3",
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b3dc": {
            "entrypoint": "0x0800b3dc",
            "current_name": "get_impure_ptr_0800b3dc",
            "code": "\nundefined4 get_impure_ptr_0800b3dc(void)\n\n{\n  return impure_ptr;\n}\n\n",
            "renaming": {
                "FUN_0800b3dc": "get_impure_ptr_0800b3dc",
                "_impure_ptr": "impure_ptr"
            },
            "calling": [
                "sqrt",
                "hypot"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b3e8": {
            "entrypoint": "0x0800b3e8",
            "current_name": "initialize_p_key_context_0800b3e8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800b3f4) */\n/* WARNING: Removing unreachable block (ram,0x0800b3f6) */\n\nvoid initializePKeyContext_0800b3e8(EVP_PKEY_CTX *pKeyContext)\n\n{\n  int counter;\n  code **functionPtrPtr;\n  \n  _init(pKeyContext);\n  counter = 0;\n  functionPtrPtr = (code **)&__preinit_array_end;\n  do {\n    counter = counter + 1;\n    (**functionPtrPtr)();\n    functionPtrPtr = functionPtrPtr + 1;\n  } while (counter != 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800b3e8": "initialize_p_key_context_0800b3e8",
                "param_1": "pKeyContext",
                "iVar1": "counter",
                "ppcVar2": "functionPtrPtr"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "_init",
                "frame_dummy",
                "register_fini"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b430": {
            "entrypoint": "0x0800b430",
            "current_name": "memset_0800b430",
            "code": "\nvoid * memset_0800b430(void *ptr,int value,size_t num_bytes)\n\n{\n  uint temp;\n  uint *ptr_temp;\n  uint *ptr_temp_2;\n  uint *ptr_temp_3;\n  uint value_temp;\n  bool is_zero;\n  \n  ptr_temp = (uint *)ptr;\n  if (((uint)ptr & 3) != 0) {\n    value_temp = num_bytes - 1;\n    ptr_temp_2 = (uint *)ptr;\n    if (num_bytes == 0) {\n      return ptr;\n    }\n    while( true ) {\n      ptr_temp = (uint *)((int)ptr_temp_2 + 1);\n      *(char *)ptr_temp_2 = (char)value;\n      num_bytes = value_temp;\n      if (((uint)ptr_temp & 3) == 0) break;\n      is_zero = value_temp == 0;\n      value_temp = value_temp - 1;\n      ptr_temp_2 = ptr_temp;\n      if (is_zero) {\n        return ptr;\n      }\n    }\n  }\n  if (3 < num_bytes) {\n    value_temp = value & 0xffU | (value & 0xffU) << 8;\n    value_temp = value_temp | value_temp << 0x10;\n    if (0xf < num_bytes) {\n      ptr_temp_2 = ptr_temp + 4;\n      do {\n        ptr_temp_2[-4] = value_temp;\n        ptr_temp_2[-3] = value_temp;\n        ptr_temp_2[-2] = value_temp;\n        ptr_temp_2[-1] = value_temp;\n        ptr_temp_2 = ptr_temp_2 + 4;\n      } while (ptr_temp_2 != (uint *)((int)ptr_temp + (num_bytes - 0x10 & 0xfffffff0) + 0x20));\n      temp = num_bytes & 0xc;\n      ptr_temp = ptr_temp + ((num_bytes - 0x10 >> 4) + 1) * 4;\n      num_bytes = num_bytes & 0xf;\n      if (temp == 0) goto joined_r0x0800b4a8;\n    }\n    ptr_temp_2 = (uint *)((num_bytes - 4 & 0xfffffffc) + 4 + (int)ptr_temp);\n    do {\n      ptr_temp_3 = ptr_temp + 1;\n      *ptr_temp = value_temp;\n      ptr_temp = ptr_temp_3;\n    } while (ptr_temp_2 != ptr_temp_3);\n    num_bytes = num_bytes & 3;\n    ptr_temp = ptr_temp_2;\n  }\njoined_r0x0800b4a8:\n  if (num_bytes != 0) {\n    ptr_temp_2 = ptr_temp;\n    do {\n      ptr_temp_3 = (uint *)((int)ptr_temp_2 + 1);\n      *(char *)ptr_temp_2 = (char)value;\n      ptr_temp_2 = ptr_temp_3;\n    } while ((uint *)(num_bytes + (int)ptr_temp) != ptr_temp_3);\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_0800b430": "memset_0800b430",
                "__s": "ptr",
                "__c": "value",
                "__n": "num_bytes",
                "uVar1": "temp",
                "puVar2": "ptr_temp",
                "puVar3": "ptr_temp_2",
                "puVar4": "ptr_temp_3",
                "uVar5": "value_temp",
                "bVar6": "is_zero"
            },
            "calling": [
                "gc_execute_line",
                "mc_go_home",
                "eeprom_init",
                "grbl_main",
                "plan_init",
                "debounce_init",
                "gc_init",
                "settings_read_coord_data",
                "homing_cycle",
                "st_reset"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b4d0": {
            "entrypoint": "0x0800b4d0",
            "current_name": "FUNC_0800b4d0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800b4d4) */\n\nvoid FUNC_0800b4d0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800b4d0": "FUNC_0800b4d0"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "atexit"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800b4e4": {
            "entrypoint": "0x0800b4e4",
            "current_name": "register_exit_handler_0800b4e4",
            "code": "\nint register_exit_handler_0800b4e4(exit_function *exit_function)\n\n{\n  int register_status;\n  \n  register_status = __register_exitproc(0,exit_function,0);\n  return register_status;\n}\n\n",
            "renaming": {
                "FUN_0800b4e4": "register_exit_handler_0800b4e4",
                "__func": "exit_function",
                "iVar1": "register_status"
            },
            "calling": [
                "register_fini"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b4f0": {
            "entrypoint": "0x0800b4f0",
            "current_name": "execute_global_dtors_0800b4f0",
            "code": "\nvoid execute_global_dtors_0800b4f0(void)\n\n{\n  int count;\n  code **dtor_pointer;\n  \n  count = 1;\n  dtor_pointer = (code **)&__do_global_dtors_aux_fini_array_entry;\n  do {\n    count = count + -1;\n    (**dtor_pointer)();\n    dtor_pointer = dtor_pointer + -1;\n  } while (count != 0);\n  _fini();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800b4f0": "execute_global_dtors_0800b4f0",
                "iVar1": "count",
                "ppcVar2": "dtor_pointer"
            },
            "calling": [],
            "called": [
                "_fini",
                "frame_dummy",
                "__do_global_dtors_aux"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b51c": {
            "entrypoint": "0x0800b51c",
            "current_name": "FUNC_0800b51c",
            "code": "\nvoid FUNC_0800b51c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800b51c": "FUNC_0800b51c"
            },
            "calling": [
                "__register_exitproc"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800b520": {
            "entrypoint": "0x0800b520",
            "current_name": "FUNC_0800b520",
            "code": "\nvoid FUNC_0800b520(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800b520": "FUNC_0800b520"
            },
            "calling": [
                "__register_exitproc"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800b524": {
            "entrypoint": "0x0800b524",
            "current_name": "update_at_exit_handlers_0800b524",
            "code": "\nundefined4 updateAtExitHandlers_0800b524(int statusCode,undefined4 handler,undefined4 data,undefined4 context)\n\n{\n  undefined *handlerTable;\n  undefined4 returnValue;\n  uint bitMask;\n  uint handlerCount;\n  \n  __retarget_lock_acquire_recursive(__atexit_recursive_mutex);\n  if (DAT_20000168 == (undefined *)0x0) {\n    DAT_20000168 = &DAT_2000016c;\n  }\n  handlerTable = DAT_20000168;\n  handlerCount = *(uint *)(DAT_20000168 + 4);\n  if ((int)handlerCount < 0x20) {\n    if (statusCode != 0) {\n      *(undefined4 *)(DAT_20000168 + handlerCount * 4 + 0x88) = data;\n      bitMask = 1 << (handlerCount & 0xff);\n      *(uint *)(handlerTable + 0x188) = *(uint *)(handlerTable + 0x188) | bitMask;\n      *(undefined4 *)(handlerTable + handlerCount * 4 + 0x108) = context;\n      if (statusCode == 2) {\n        *(uint *)(handlerTable + 0x18c) = bitMask | *(uint *)(handlerTable + 0x18c);\n      }\n    }\n    returnValue = __atexit_recursive_mutex;\n    *(uint *)(handlerTable + 4) = handlerCount + 1;\n    *(undefined4 *)(handlerTable + (handlerCount + 2) * 4) = handler;\n    __retarget_lock_release_recursive(returnValue);\n    returnValue = 0;\n  }\n  else {\n    __retarget_lock_release_recursive(__atexit_recursive_mutex);\n    returnValue = 0xffffffff;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_0800b524": "update_at_exit_handlers_0800b524",
                "param_1": "statusCode",
                "param_2": "handler",
                "param_3": "data",
                "param_4": "context",
                "puVar1": "handlerTable",
                "uVar2": "returnValue",
                "uVar3": "bitMask",
                "uVar4": "handlerCount"
            },
            "calling": [
                "atexit"
            ],
            "called": [
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b5b0": {
            "entrypoint": "0x0800b5b0",
            "current_name": "convert_context_to_int_0800b5b0",
            "code": "\nint convertContextToInt_0800b5b0(EVP_PKEY_CTX *context)\n\n{\n  return (int)context;\n}\n\n",
            "renaming": {
                "FUN_0800b5b0": "convert_context_to_int_0800b5b0",
                "ctx": "context"
            },
            "calling": [
                "frame_dummy",
                "__libc_init_array",
                "__do_global_dtors_aux"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800b5bc": {
            "entrypoint": "0x0800b5bc",
            "current_name": "FUNC_0800b5bc",
            "code": "\nvoid FUNC_0800b5bc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800b5bc": "FUNC_0800b5bc"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 209310,
    "layers": [
        [
            "FUN_08000188",
            "FUN_080001ac",
            "FUN_080001f8",
            "FUN_08000210",
            "FUN_08000220",
            "FUN_08000268",
            "FUN_080002a0",
            "FUN_080002b6",
            "FUN_080002f0",
            "FUN_08000310",
            "FUN_08000340",
            "FUN_08000374",
            "FUN_080003ec",
            "FUN_08000478",
            "FUN_080004ac",
            "FUN_080004fc",
            "FUN_0800056c",
            "FUN_080005b4",
            "FUN_0800184c",
            "FUN_080018cc",
            "FUN_080018fc",
            "FUN_0800192c",
            "FUN_0800195c",
            "FUN_08001994",
            "FUN_08001d4c",
            "FUN_08001ddc",
            "FUN_08001e98",
            "FUN_08001f00",
            "FUN_08002408",
            "FUN_080024c4",
            "FUN_080025e8",
            "FUN_08002638",
            "FUN_08002814",
            "FUN_08002828",
            "FUN_0800283a",
            "FUN_08002870",
            "FUN_08002896",
            "FUN_080028bc",
            "FUN_08002908",
            "FUN_08002978",
            "FUN_080029d8",
            "FUN_08002a94",
            "FUN_08002afc",
            "FUN_08002ba8",
            "FUN_08002c18",
            "FUN_08002e08",
            "FUN_08002edc",
            "FUN_08002ef0",
            "FUN_08002f24",
            "FUN_08002f40",
            "FUN_08002f74",
            "FUN_08002fac",
            "FUN_08002fd4",
            "FUN_08003004",
            "FUN_080035ec",
            "FUN_08003618",
            "FUN_0800369c",
            "FUN_080036c6",
            "FUN_080036f0",
            "FUN_08003740",
            "FUN_0800375c",
            "FUN_08003778",
            "FUN_080037fc",
            "FUN_08003826",
            "FUN_08003980",
            "FUN_080039a0",
            "FUN_080039bc",
            "FUN_08003a18",
            "FUN_08003a74",
            "FUN_08003b98",
            "FUN_08003f34",
            "FUN_08004030",
            "FUN_08004148",
            "FUN_080041a0",
            "FUN_08004228",
            "FUN_0800423c",
            "FUN_08004250",
            "FUN_080044e8",
            "FUN_080046d0",
            "FUN_08004900",
            "FUN_08004940",
            "FUN_08004bc0",
            "FUN_08004bf4",
            "FUN_08004c2a",
            "FUN_08004c48",
            "FUN_08004d2c",
            "FUN_08004d7c",
            "FUN_08004dd2",
            "FUN_08004e30",
            "FUN_080051b4",
            "FUN_08005238",
            "FUN_08005250",
            "FUN_0800525c",
            "FUN_080052ac",
            "FUN_080052dc",
            "FUN_08005324",
            "FUN_08005360",
            "FUN_080053a0",
            "FUN_08005760",
            "FUN_08005778",
            "FUN_08005790",
            "FUN_080057e4",
            "FUN_08005814",
            "FUN_0800583c",
            "FUN_0800585c",
            "FUN_0800587c",
            "FUN_080058a0",
            "FUN_08005900",
            "FUN_0800597c",
            "FUN_08005984",
            "FUN_080059b4",
            "FUN_080059f8",
            "FUN_08005a68",
            "FUN_08005a84",
            "FUN_08005a98",
            "FUN_08005ac4",
            "FUN_08005ad4",
            "FUN_08005aec",
            "FUN_08005b04",
            "FUN_08005b20",
            "FUN_08005b3c",
            "FUN_08005b58",
            "FUN_08005b74",
            "FUN_08005b90",
            "FUN_08005bac",
            "FUN_08005bc4",
            "FUN_08005bdc",
            "FUN_08005c30",
            "FUN_08005c74",
            "FUN_08005cec",
            "FUN_0800618c",
            "FUN_0800640c",
            "FUN_080064bc",
            "FUN_080064d4",
            "FUN_080064ec",
            "FUN_08006628",
            "FUN_08006680",
            "FUN_080066cc",
            "FUN_08006718",
            "FUN_080068bc",
            "FUN_0800691c",
            "FUN_08006950",
            "FUN_08006998",
            "FUN_080069b4",
            "FUN_080069e4",
            "FUN_08006a18",
            "FUN_08006a58",
            "FUN_08006a8c",
            "FUN_08006ac0",
            "FUN_08006b00",
            "FUN_08006b54",
            "FUN_08006ba0",
            "FUN_08006c04",
            "FUN_08006c70",
            "FUN_08006c9c",
            "FUN_08006ce0",
            "FUN_08006cf6",
            "FUN_08006d2e",
            "FUN_08006d4a",
            "FUN_08006d66",
            "FUN_08006d72",
            "FUN_08006d8a",
            "FUN_08006d98",
            "FUN_08006dc4",
            "FUN_08006de0",
            "FUN_08006dfe",
            "FUN_08006e1a",
            "FUN_08006e38",
            "FUN_08006e70",
            "FUN_08006e88",
            "FUN_080071d0",
            "FUN_08007310",
            "FUN_0800733e",
            "FUN_0800736c",
            "FUN_0800738e",
            "FUN_080073c0",
            "FUN_080073d4",
            "FUN_08007402",
            "FUN_08007430",
            "FUN_08007436",
            "FUN_080074c8",
            "FUN_08007520",
            "FUN_08007540",
            "FUN_0800756c",
            "FUN_080075c8",
            "FUN_080076c8",
            "FUN_0800771a",
            "FUN_08007720",
            "FUN_08007726",
            "FUN_0800772c",
            "FUN_08007756",
            "FUN_0800778c",
            "FUN_08007854",
            "FUN_08007884",
            "FUN_080078d0",
            "FUN_080078e2",
            "FUN_080078f4",
            "FUN_08007930",
            "FUN_080079c0",
            "FUN_080079e0",
            "FUN_08007a10",
            "FUN_08007a70",
            "FUN_08007ad0",
            "FUN_08007b70",
            "FUN_08007bc2",
            "FUN_08007bf0",
            "FUN_08007c40",
            "FUN_08007c5e",
            "FUN_08007c7c",
            "FUN_08007d08",
            "FUN_08007da8",
            "FUN_08007dd8",
            "FUN_08007e08",
            "FUN_08007e1c",
            "FUN_08007e58",
            "FUN_08007e84",
            "FUN_08007ea4",
            "FUN_08007f54",
            "FUN_08008190",
            "FUN_08008250",
            "FUN_0800826a",
            "FUN_08008286",
            "FUN_080082c8",
            "FUN_080082d0",
            "FUN_080082d4",
            "FUN_0800854c",
            "FUN_0800856c",
            "FUN_08008590",
            "FUN_080085d4",
            "FUN_080085e4",
            "FUN_0800881c",
            "FUN_08008a02",
            "FUN_08008a64",
            "FUN_08008a6c",
            "FUN_08008a74",
            "FUN_08008af0",
            "FUN_08008b00",
            "FUN_08008b10",
            "FUN_08008b24",
            "FUN_08008b38",
            "FUN_08008b4c",
            "FUN_08008b60",
            "FUN_08008b74",
            "FUN_08008ba0",
            "FUN_08008bf0",
            "FUN_08008c30",
            "FUN_08008cd0",
            "FUN_08008cd8",
            "FUN_08008cdc",
            "FUN_08008e3c",
            "FUN_08008e44",
            "FUN_08008e60",
            "FUN_08008e70",
            "FUN_08008eec",
            "FUN_08009054",
            "FUN_0800918c",
            "FUN_08009194",
            "FUN_0800919c",
            "FUN_080091fc",
            "FUN_08009204",
            "FUN_08009214",
            "FUN_08009228",
            "FUN_0800923c",
            "FUN_08009250",
            "FUN_08009264",
            "FUN_08009278",
            "FUN_080092c4",
            "FUN_08009314",
            "FUN_08009318",
            "FUN_08009410",
            "FUN_080094c0",
            "FUN_080095b8",
            "FUN_08009654",
            "FUN_080096e8",
            "FUN_08009798",
            "FUN_0800981c",
            "FUN_080098d0",
            "FUN_08009990",
            "FUN_08009b24",
            "FUN_08009d78",
            "FUN_0800a1bc",
            "FUN_0800a348",
            "FUN_0800a5a0",
            "FUN_0800adf0",
            "FUN_0800af78",
            "FUN_0800b2cc",
            "FUN_0800b2d4",
            "FUN_0800b2e0",
            "FUN_0800b2e8",
            "FUN_0800b3dc",
            "FUN_0800b3e8",
            "FUN_0800b430",
            "FUN_0800b4e4",
            "FUN_0800b4f0",
            "FUN_0800b524",
            "FUN_0800b5b0"
        ],
        [
            "FUN_08008640",
            "FUN_08008894"
        ]
    ],
    "locked_functions": []
}