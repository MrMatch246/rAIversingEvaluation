{
    "functions": {
        "FUN_08000110": {
            "entrypoint": "0x08000110",
            "current_name": "initialize_completed_flag_08000110",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800011c) */\n\nundefined4 initializeCompletedFlag_08000110(undefined4 input)\n\n{\n  if ((char)completedFlag == '\\0') {\n    completedFlag._0_1_ = '\\x01';\n  }\n  return input;\n}\n\n",
            "renaming": {
                "FUN_08000110": "initialize_completed_flag_08000110",
                "param_1": "input",
                "completed_8655": "completedFlag"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000134": {
            "entrypoint": "0x08000134",
            "current_name": "concatenate_64bit_params_08000134",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800013a) */\n\nundefined8 concatenate_64bit_params_08000134(undefined4 first_param,undefined4 second_param)\n\n{\n  return CONCAT44(second_param,first_param);\n}\n\n",
            "renaming": {
                "FUN_08000134": "concatenate_64bit_params_08000134",
                "param_1": "first_param",
                "param_2": "second_param"
            },
            "calling": [
                "__libc_init_array",
                "__libc_fini_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000150": {
            "entrypoint": "0x08000150",
            "current_name": "addition_with_xor_08000150",
            "code": "\nvoid additionWithXor_08000150(undefined4 result,uint value)\n\n{\n  __aeabi_dadd(result,value ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000150": "addition_with_xor_08000150",
                "param_1": "result",
                "param_2": "value"
            },
            "calling": [],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000158": {
            "entrypoint": "0x08000158",
            "current_name": "calculate_unsigned_division_08000158",
            "code": "\nulonglong calculateUnsignedDivision_08000158(uint dividend,uint divisor,uint quotient,uint remainder)\n\n{\n  int iVar1;\n  byte bVar2;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint bitwiseXorResult;\n  uint temp4;\n  int shiftAmount;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  uint temp8;\n  bool isConditionMet1;\n  bool isConditionMet2;\n  bool isConditionMet3;\n  \n  bitwiseXorResult = remainder ^ 0x80000000;\n  temp5 = divisor << 1;\n  remainder = remainder << 1;\n  isConditionMet1 = ((divisor ^ bitwiseXorResult) & 0x7fffffff) == 0;\n  isConditionMet2 = isConditionMet1 && dividend == quotient;\n  if (!isConditionMet1 || dividend != quotient) {\n    isConditionMet2 = (temp5 | dividend) == 0;\n  }\n  if (!isConditionMet2) {\n    isConditionMet2 = (remainder | quotient) == 0;\n  }\n  shiftAmount = (int)temp5 >> 0x15;\n  if (!isConditionMet2) {\n    isConditionMet2 = shiftAmount == -1;\n  }\n  iVar1 = (int)remainder >> 0x15;\n  if (!isConditionMet2) {\n    isConditionMet2 = iVar1 == -1;\n  }\n  if (isConditionMet2) {\n    if (shiftAmount == -1 || iVar1 == -1) {\n      temp5 = bitwiseXorResult;\n      temp7 = quotient;\n      if (shiftAmount == -1) {\n        temp5 = divisor;\n        temp7 = dividend;\n      }\n      if (shiftAmount != -1 || iVar1 != -1) {\n        quotient = temp7;\n        bitwiseXorResult = temp5;\n      }\n      isConditionMet2 = (temp7 | temp5 << 0xc) == 0;\n      if (isConditionMet2) {\n        isConditionMet2 = (quotient | bitwiseXorResult << 0xc) == 0;\n      }\n      if (isConditionMet2) {\n        isConditionMet2 = temp5 == bitwiseXorResult;\n      }\n      if (!isConditionMet2) {\n        temp5 = temp5 | 0x80000;\n      }\n      return CONCAT44(temp5,temp7);\n    }\n    if (((divisor ^ bitwiseXorResult) & 0x7fffffff) != 0 || dividend != quotient) {\n      if ((temp5 | dividend) == 0) {\n        dividend = quotient;\n        divisor = bitwiseXorResult;\n      }\n      return CONCAT44(divisor,dividend);\n    }\n    if (divisor != bitwiseXorResult) {\n      return 0;\n    }\n    if (temp5 >> 0x15 == 0) {\n      isConditionMet2 = (dividend & 0x80000000) != 0;\n      bitwiseXorResult = divisor * 2 + (uint)isConditionMet2;\n      if (CARRY4(divisor,divisor) || CARRY4(divisor * 2,(uint)isConditionMet2)) {\n        bitwiseXorResult = bitwiseXorResult | 0x80000000;\n      }\n      return CONCAT44(bitwiseXorResult,dividend << 1);\n    }\n    if (temp5 < 0xffc00000) {\n      return CONCAT44(divisor + 0x100000,dividend);\n    }\n    divisor = divisor & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(divisor | 0x7ff00000) << 0x20;\n  }\n  temp5 = temp5 >> 0x15;\n  remainder = remainder >> 0x15;\n  temp7 = remainder - temp5;\n  isConditionMet2 = temp7 != 0;\n  if (remainder < temp5) {\n    temp7 = -temp7;\n  }\n  temp6 = dividend;\n  temp4 = divisor;\n  if (isConditionMet2 && temp5 <= remainder) {\n    temp5 = temp5 + temp7;\n    temp6 = quotient;\n    temp4 = bitwiseXorResult;\n    quotient = dividend;\n    bitwiseXorResult = divisor;\n  }\n  if (0x36 < temp7) {\n    return CONCAT44(temp4,temp6);\n  }\n  temp2 = temp4 & 0xfffff | 0x100000;\n  if ((temp4 & 0x80000000) != 0) {\n    isConditionMet2 = temp6 != 0;\n    temp6 = -temp6;\n    temp2 = -temp2 - (uint)isConditionMet2;\n  }\n  temp4 = bitwiseXorResult & 0xfffff | 0x100000;\n  if ((bitwiseXorResult & 0x80000000) != 0) {\n    isConditionMet2 = quotient != 0;\n    quotient = -quotient;\n    temp4 = -temp4 - (uint)isConditionMet2;\n  }\n  if (temp5 == temp7) {\n    temp4 = temp4 ^ 0x100000;\n    if (temp5 == 0) {\n      temp2 = temp2 ^ 0x100000;\n      temp5 = 1;\n    }\n    else {\n      temp7 = temp7 - 1;\n    }\n  }\n  bitwiseXorResult = -temp7 + 0x20;\n  if ((int)temp7 < 0x21) {\n    temp8 = quotient << (bitwiseXorResult & 0xff);\n    quotient = quotient >> (temp7 & 0xff);\n    temp1 = temp6 + quotient;\n    temp3 = temp4 << (bitwiseXorResult & 0xff);\n    bitwiseXorResult = temp1 + temp3;\n    temp2 = temp2 + CARRY4(temp6,quotient) + ((int)temp4 >> (temp7 & 0xff)) +\n            (uint)CARRY4(temp1,temp3);\n  }\n  else {\n    temp8 = temp4 << (-temp7 + 0x40 & 0xff);\n    if (quotient != 0) {\n      temp8 = temp8 | 2;\n    }\n    temp4 = (int)temp4 >> (temp7 - 0x20 & 0xff);\n    bitwiseXorResult = temp6 + temp4;\n    temp2 = temp2 + ((int)temp4 >> 0x1f) + (uint)CARRY4(temp6,temp4);\n  }\n  divisor = temp2 & 0x80000000;\n  temp7 = temp2;\n  if ((int)temp2 < 0) {\n    isConditionMet2 = temp8 == 0;\n    temp8 = -temp8;\n    temp7 = -bitwiseXorResult;\n    bitwiseXorResult = -(uint)!isConditionMet2 - bitwiseXorResult;\n    temp7 = -(uint)(isConditionMet2 <= temp7) - temp2;\n  }\n  if (0xfffff < temp7) {\n    temp6 = temp5 - 1;\n    if (0x1fffff < temp7) {\n      temp6 = temp7 & 1;\n      temp7 = temp7 >> 1;\n      bVar2 = (byte)bitwiseXorResult;\n      bitwiseXorResult = (uint)(temp6 != 0) << 0x1f | bitwiseXorResult >> 1;\n      temp8 = (uint)(bVar2 & 1) << 0x1f | temp8 >> 1;\n      temp6 = temp5;\n      if (0xffbfffff < temp5 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    isConditionMet2 = 0x7fffffff < temp8;\n    if (temp8 == 0x80000000) {\n      isConditionMet2 = (bitwiseXorResult & 1) != 0;\n    }\n    return CONCAT44(temp7 + temp6 * 0x100000 + (uint)CARRY4(bitwiseXorResult,(uint)isConditionMet2) | divisor,\n                    bitwiseXorResult + isConditionMet2);\n  }\n  isConditionMet1 = (temp8 & 0x80000000) != 0;\n  temp8 = temp8 << 1;\n  temp6 = bitwiseXorResult * 2;\n  isConditionMet2 = CARRY4(bitwiseXorResult,bitwiseXorResult);\n  bitwiseXorResult = bitwiseXorResult * 2 + (uint)isConditionMet1;\n  temp7 = temp7 * 2 + (uint)(isConditionMet2 || CARRY4(temp6,(uint)isConditionMet1));\n  temp6 = temp5 - 2;\n  if ((temp7 & 0x100000) != 0) goto LAB_08000268;\n  temp4 = bitwiseXorResult;\n  temp5 = temp7;\n  if (temp7 == 0) {\n    temp4 = 0;\n    temp5 = bitwiseXorResult;\n  }\n  shiftAmount = LZCOUNT(temp5);\n  if (temp7 == 0) {\n    shiftAmount = shiftAmount + 0x20;\n  }\n  temp7 = shiftAmount - 0xb;\n  isConditionMet3 = SBORROW4(temp7,0x20);\n  bitwiseXorResult = shiftAmount - 0x2b;\n  isConditionMet2 = (int)bitwiseXorResult < 0;\n  isConditionMet1 = bitwiseXorResult == 0;\n  if ((int)temp7 < 0x20) {\n    isConditionMet3 = SCARRY4(bitwiseXorResult,0xc);\n    shiftAmount = shiftAmount + -0x1f;\n    isConditionMet2 = shiftAmount < 0;\n    isConditionMet1 = shiftAmount == 0;\n    bitwiseXorResult = temp7;\n    if (!isConditionMet1 && isConditionMet2 == isConditionMet3) {\n      temp4 = temp5 << (temp7 & 0xff);\n      temp5 = temp5 >> (0xcU - shiftAmount & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isConditionMet1 || isConditionMet2 != isConditionMet3) {\n    temp8 = 0x20 - bitwiseXorResult;\n  }\n  temp5 = temp5 << (bitwiseXorResult & 0xff);\n  if (isConditionMet1 || isConditionMet2 != isConditionMet3) {\n    temp5 = temp5 | temp4 >> (temp8 & 0xff);\n  }\n  if (isConditionMet1 || isConditionMet2 != isConditionMet3) {\n    temp4 = temp4 << (bitwiseXorResult & 0xff);\n  }\nLAB_080002e0:\n  if ((int)temp7 <= (int)temp6) {\n    return CONCAT44(temp5 + (temp6 - temp7) * 0x100000 | divisor,temp4);\n  }\n  bitwiseXorResult = ~(temp6 - temp7);\n  if ((int)bitwiseXorResult < 0x1f) {\n    shiftAmount = bitwiseXorResult - 0x13;\n    if (shiftAmount != 0 && shiftAmount < 0 == SCARRY4(bitwiseXorResult - 0x1f,0xc)) {\n      return CONCAT44(temp2,temp4 >> (0x20 - (0xcU - shiftAmount) & 0xff) | temp5 << (0xcU - shiftAmount & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    bitwiseXorResult = bitwiseXorResult + 1;\n    return CONCAT44(divisor | temp5 >> (bitwiseXorResult & 0xff),\n                    temp4 >> (bitwiseXorResult & 0xff) | temp5 << (0x20 - bitwiseXorResult & 0xff));\n  }\n  return CONCAT44(temp2,temp5 >> (bitwiseXorResult - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000158": "calculate_unsigned_division_08000158",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "uVar6": "bitwiseXorResult",
                "uVar7": "temp4",
                "iVar8": "shiftAmount",
                "uVar9": "temp5",
                "uVar10": "temp6",
                "uVar11": "temp7",
                "uVar12": "temp8",
                "bVar13": "isConditionMet1",
                "bVar14": "isConditionMet2",
                "bVar15": "isConditionMet3"
            },
            "calling": [
                "_svfprintf_r",
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800015c": {
            "entrypoint": "0x0800015c",
            "current_name": "calculate_0800015c",
            "code": "\nulonglong calculate_0800015c(uint num1,uint num2,uint num3,uint num4)\n\n{\n  int shift1;\n  byte carry;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int shift2;\n  uint shiftedNum2;\n  uint shiftedNum4;\n  uint adjustedNum2;\n  uint adjustedNum4;\n  uint carryFlag;\n  uint result1;\n  bool isEqual;\n  bool condition;\n  bool isCarry;\n  \n  shiftedNum2 = num2 << 1;\n  adjustedNum2 = num4 << 1;\n  isEqual = ((num2 ^ num4) & 0x7fffffff) == 0;\n  condition = isEqual && num1 == num3;\n  if (!isEqual || num1 != num3) {\n    condition = (shiftedNum2 | num1) == 0;\n  }\n  if (!condition) {\n    condition = (adjustedNum2 | num3) == 0;\n  }\n  shift2 = (int)shiftedNum2 >> 0x15;\n  if (!condition) {\n    condition = shift2 == -1;\n  }\n  shift1 = (int)adjustedNum2 >> 0x15;\n  if (!condition) {\n    condition = shift1 == -1;\n  }\n  if (condition) {\n    if (shift2 == -1 || shift1 == -1) {\n      adjustedNum2 = num4;\n      shiftedNum2 = num3;\n      if (shift2 == -1) {\n        adjustedNum2 = num2;\n        shiftedNum2 = num1;\n      }\n      if (shift2 != -1 || shift1 != -1) {\n        num3 = shiftedNum2;\n        num4 = adjustedNum2;\n      }\n      condition = (shiftedNum2 | adjustedNum2 << 0xc) == 0;\n      if (condition) {\n        condition = (num3 | num4 << 0xc) == 0;\n      }\n      if (condition) {\n        condition = adjustedNum2 == num4;\n      }\n      if (!condition) {\n        adjustedNum2 = adjustedNum2 | 0x80000;\n      }\n      return CONCAT44(adjustedNum2,shiftedNum2);\n    }\n    if (((num2 ^ num4) & 0x7fffffff) != 0 || num1 != num3) {\n      if ((shiftedNum2 | num1) == 0) {\n        num1 = num3;\n        num2 = num4;\n      }\n      return CONCAT44(num2,num1);\n    }\n    if (num2 != num4) {\n      return 0;\n    }\n    if (shiftedNum2 >> 0x15 == 0) {\n      condition = (num1 & 0x80000000) != 0;\n      adjustedNum2 = num2 * 2 + (uint)condition;\n      if (CARRY4(num2,num2) || CARRY4(num2 * 2,(uint)condition)) {\n        adjustedNum2 = adjustedNum2 | 0x80000000;\n      }\n      return CONCAT44(adjustedNum2,num1 << 1);\n    }\n    if (shiftedNum2 < 0xffc00000) {\n      return CONCAT44(num2 + 0x100000,num1);\n    }\n    num2 = num2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(num2 | 0x7ff00000) << 0x20;\n  }\n  shiftedNum2 = shiftedNum2 >> 0x15;\n  adjustedNum2 = adjustedNum2 >> 0x15;\n  adjustedNum4 = adjustedNum2 - shiftedNum2;\n  condition = adjustedNum4 != 0;\n  if (adjustedNum2 < shiftedNum2) {\n    adjustedNum4 = -adjustedNum4;\n  }\n  shiftedNum4 = num1;\n  temp3 = num2;\n  if (condition && shiftedNum2 <= adjustedNum2) {\n    shiftedNum2 = shiftedNum2 + adjustedNum4;\n    shiftedNum4 = num3;\n    temp3 = num4;\n    num3 = num1;\n    num4 = num2;\n  }\n  if (0x36 < adjustedNum4) {\n    return CONCAT44(temp3,shiftedNum4);\n  }\n  adjustedNum2 = temp3 & 0xfffff | 0x100000;\n  if ((temp3 & 0x80000000) != 0) {\n    condition = shiftedNum4 != 0;\n    shiftedNum4 = -shiftedNum4;\n    adjustedNum2 = -adjustedNum2 - (uint)condition;\n  }\n  temp3 = num4 & 0xfffff | 0x100000;\n  if ((num4 & 0x80000000) != 0) {\n    condition = num3 != 0;\n    num3 = -num3;\n    temp3 = -temp3 - (uint)condition;\n  }\n  if (shiftedNum2 == adjustedNum4) {\n    temp3 = temp3 ^ 0x100000;\n    if (shiftedNum2 == 0) {\n      adjustedNum2 = adjustedNum2 ^ 0x100000;\n      shiftedNum2 = 1;\n    }\n    else {\n      adjustedNum4 = adjustedNum4 - 1;\n    }\n  }\n  result1 = -adjustedNum4 + 0x20;\n  if ((int)adjustedNum4 < 0x21) {\n    carryFlag = num3 << (result1 & 0xff);\n    num3 = num3 >> (adjustedNum4 & 0xff);\n    temp1 = shiftedNum4 + num3;\n    temp2 = temp3 << (result1 & 0xff);\n    result1 = temp1 + temp2;\n    adjustedNum2 = adjustedNum2 + CARRY4(shiftedNum4,num3) + ((int)temp3 >> (adjustedNum4 & 0xff)) +\n            (uint)CARRY4(temp1,temp2);\n  }\n  else {\n    carryFlag = temp3 << (-adjustedNum4 + 0x40 & 0xff);\n    if (num3 != 0) {\n      carryFlag = carryFlag | 2;\n    }\n    temp3 = (int)temp3 >> (adjustedNum4 - 0x20 & 0xff);\n    result1 = shiftedNum4 + temp3;\n    adjustedNum2 = adjustedNum2 + ((int)temp3 >> 0x1f) + (uint)CARRY4(shiftedNum4,temp3);\n  }\n  num2 = adjustedNum2 & 0x80000000;\n  adjustedNum4 = adjustedNum2;\n  if ((int)adjustedNum2 < 0) {\n    condition = carryFlag == 0;\n    carryFlag = -carryFlag;\n    adjustedNum4 = -result1;\n    result1 = -(uint)!condition - result1;\n    adjustedNum4 = -(uint)(condition <= adjustedNum4) - adjustedNum2;\n  }\n  if (0xfffff < adjustedNum4) {\n    shiftedNum4 = shiftedNum2 - 1;\n    if (0x1fffff < adjustedNum4) {\n      adjustedNum2 = adjustedNum4 & 1;\n      adjustedNum4 = adjustedNum4 >> 1;\n      carry = (byte)result1;\n      result1 = (uint)(adjustedNum2 != 0) << 0x1f | result1 >> 1;\n      carryFlag = (uint)(carry & 1) << 0x1f | carryFlag >> 1;\n      shiftedNum4 = shiftedNum2;\n      if (0xffbfffff < shiftedNum2 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    condition = 0x7fffffff < carryFlag;\n    if (carryFlag == 0x80000000) {\n      condition = (result1 & 1) != 0;\n    }\n    return CONCAT44(adjustedNum4 + shiftedNum4 * 0x100000 + (uint)CARRY4(result1,(uint)condition) | num2,\n                    result1 + condition);\n  }\n  isEqual = (carryFlag & 0x80000000) != 0;\n  carryFlag = carryFlag << 1;\n  shiftedNum4 = result1 * 2;\n  condition = CARRY4(result1,result1);\n  result1 = result1 * 2 + (uint)isEqual;\n  adjustedNum4 = adjustedNum4 * 2 + (uint)(condition || CARRY4(shiftedNum4,(uint)isEqual));\n  shiftedNum4 = shiftedNum2 - 2;\n  if ((adjustedNum4 & 0x100000) != 0) goto LAB_08000268;\n  temp3 = result1;\n  shiftedNum2 = adjustedNum4;\n  if (adjustedNum4 == 0) {\n    temp3 = 0;\n    shiftedNum2 = result1;\n  }\n  shift2 = LZCOUNT(shiftedNum2);\n  if (adjustedNum4 == 0) {\n    shift2 = shift2 + 0x20;\n  }\n  result1 = shift2 - 0xb;\n  isCarry = SBORROW4(result1,0x20);\n  adjustedNum4 = shift2 - 0x2b;\n  condition = (int)adjustedNum4 < 0;\n  isEqual = adjustedNum4 == 0;\n  if ((int)result1 < 0x20) {\n    isCarry = SCARRY4(adjustedNum4,0xc);\n    shift2 = shift2 + -0x1f;\n    condition = shift2 < 0;\n    isEqual = shift2 == 0;\n    adjustedNum4 = result1;\n    if (!isEqual && condition == isCarry) {\n      temp3 = shiftedNum2 << (result1 & 0xff);\n      shiftedNum2 = shiftedNum2 >> (0xcU - shift2 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isEqual || condition != isCarry) {\n    carryFlag = 0x20 - adjustedNum4;\n  }\n  shiftedNum2 = shiftedNum2 << (adjustedNum4 & 0xff);\n  if (isEqual || condition != isCarry) {\n    shiftedNum2 = shiftedNum2 | temp3 >> (carryFlag & 0xff);\n  }\n  if (isEqual || condition != isCarry) {\n    temp3 = temp3 << (adjustedNum4 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)result1 <= (int)shiftedNum4) {\n    return CONCAT44(shiftedNum2 + (shiftedNum4 - result1) * 0x100000 | num2,temp3);\n  }\n  adjustedNum4 = ~(shiftedNum4 - result1);\n  if ((int)adjustedNum4 < 0x1f) {\n    shift2 = adjustedNum4 - 0x13;\n    if (shift2 != 0 && shift2 < 0 == SCARRY4(adjustedNum4 - 0x1f,0xc)) {\n      return CONCAT44(adjustedNum2,temp3 >> (0x20 - (0xcU - shift2) & 0xff) | shiftedNum2 << (0xcU - shift2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    adjustedNum4 = adjustedNum4 + 1;\n    return CONCAT44(num2 | shiftedNum2 >> (adjustedNum4 & 0xff),\n                    temp3 >> (adjustedNum4 & 0xff) | shiftedNum2 << (0x20 - adjustedNum4 & 0xff));\n  }\n  return CONCAT44(adjustedNum2,shiftedNum2 >> (adjustedNum4 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800015c": "calculate_0800015c",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "num3",
                "param_4": "num4",
                "iVar1": "shift1",
                "iVar6": "shift2",
                "bVar2": "carry",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "uVar7": "shiftedNum2",
                "uVar8": "shiftedNum4",
                "uVar9": "adjustedNum2",
                "uVar10": "adjustedNum4",
                "uVar11": "carryFlag",
                "uVar12": "result1",
                "bVar13": "isEqual",
                "bVar14": "condition",
                "bVar15": "isCarry"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "__aeabi_drsub",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003d4": {
            "entrypoint": "0x080003d4",
            "current_name": "reverse_and_shift_080003d4",
            "code": "\nulonglong reverseAndShift_080003d4(uint input)\n\n{\n  uint result1;\n  uint result2;\n  int bitCount;\n  uint shiftAmount;\n  uint shiftedBits;\n  bool isNegative;\n  bool isZero;\n  bool isCarry;\n  \n  if (input == 0) {\n    return 0;\n  }\n  result1 = 0;\n  bitCount = LZCOUNT(input);\n  shiftAmount = bitCount + 0x15;\n  isCarry = SBORROW4(shiftAmount,0x20);\n  result2 = bitCount - 0xb;\n  isNegative = (int)result2 < 0;\n  isZero = result2 == 0;\n  if (shiftAmount < 0x20) {\n    isCarry = SCARRY4(result2,0xc);\n    isNegative = false;\n    isZero = bitCount + 1 == 0;\n    result2 = shiftAmount;\n    if (!isZero && isCarry == false) {\n      result1 = input << shiftAmount;\n      input = input >> (0xcU - (bitCount + 1) & 0xff);\n      goto shiftedResult;\n    }\n  }\n  if (isZero || isNegative != isCarry) {\n    shiftedBits = 0x20 - result2;\n  }\n  input = input << (result2 & 0xff);\n  if (isZero || isNegative != isCarry) {\n    input = input | 0U >> (shiftedBits & 0xff);\n  }\n  if (isZero || isNegative != isCarry) {\n    result1 = 0 << (result2 & 0xff);\n  }\nshiftedResult:\n  if (shiftAmount < 0x433) {\n    return combine64Bits(input + (0x432 - shiftAmount) * 0x100000,result1);\n  }\n  result2 = ~(0x432 - shiftAmount);\n  if (0x1e < (int)result2) {\n    return (ulonglong)(input >> (result2 - 0x1f & 0xff));\n  }\n  bitCount = result2 - 0x13;\n  if (bitCount == 0 || bitCount < 0 != SCARRY4(result2 - 0x1f,0xc)) {\n    result2 = result2 + 1;\n    return combine64Bits(input >> (result2 & 0xff),\n                    result1 >> (result2 & 0xff) | input << (0x20 - result2 & 0xff));\n  }\n  return (ulonglong)(result1 >> (0x20 - (0xcU - bitCount) & 0xff) | input << (0xcU - bitCount & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080003d4": "reverse_and_shift_080003d4",
                "param_1": "input",
                "uVar1": "result1",
                "uVar2": "result2",
                "iVar3": "bitCount",
                "uVar4": "shiftAmount",
                "in_r12": "shiftedBits",
                "bVar5": "isNegative",
                "bVar6": "isZero",
                "bVar7": "isCarry",
                "LAB_080002e0": "shiftedResult",
                "CONCAT44": "combine64Bits"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003f4": {
            "entrypoint": "0x080003f4",
            "current_name": "reverse_bit_pattern_080003f4",
            "code": "\nulonglong reverseBitPattern_080003f4(uint input)\n\n{\n  uint bitCount;\n  uint absInput;\n  uint shiftAmount;\n  int leadingZeros;\n  uint adjustedCount;\n  uint signBit;\n  uint remainingBits;\n  bool isNegative;\n  bool isZero;\n  bool isBorrow;\n  \n  if (input == 0) {\n    return 0;\n  }\n  signBit = input & 0x80000000;\n  absInput = input;\n  if ((int)signBit < 0) {\n    absInput = -input;\n  }\n  bitCount = 0;\n  leadingZeros = LZCOUNT(absInput);\n  adjustedCount = leadingZeros + 0x15;\n  isBorrow = SBORROW4(adjustedCount,0x20);\n  shiftAmount = leadingZeros - 0xb;\n  isNegative = (int)shiftAmount < 0;\n  isZero = shiftAmount == 0;\n  if (adjustedCount < 0x20) {\n    isBorrow = SCARRY4(shiftAmount,0xc);\n    isNegative = false;\n    isZero = leadingZeros + 1 == 0;\n    shiftAmount = adjustedCount;\n    if (!isZero && isBorrow == false) {\n      bitCount = absInput << adjustedCount;\n      absInput = absInput >> (0xcU - (leadingZeros + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isZero || isNegative != isBorrow) {\n    remainingBits = 0x20 - shiftAmount;\n  }\n  absInput = absInput << (shiftAmount & 0xff);\n  if (isZero || isNegative != isBorrow) {\n    absInput = absInput | 0U >> (remainingBits & 0xff);\n  }\n  if (isZero || isNegative != isBorrow) {\n    bitCount = 0 << (shiftAmount & 0xff);\n  }\nLAB_080002e0:\n  if (adjustedCount < 0x433) {\n    return CONCAT44(absInput + (0x432 - adjustedCount) * 0x100000 | signBit,bitCount);\n  }\n  shiftAmount = ~(0x432 - adjustedCount);\n  if (0x1e < (int)shiftAmount) {\n    return CONCAT44(input,absInput >> (shiftAmount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leadingZeros = shiftAmount - 0x13;\n  if (leadingZeros == 0 || leadingZeros < 0 != SCARRY4(shiftAmount - 0x1f,0xc)) {\n    shiftAmount = shiftAmount + 1;\n    return CONCAT44(signBit | absInput >> (shiftAmount & 0xff),\n                    bitCount >> (shiftAmount & 0xff) | absInput << (0x20 - shiftAmount & 0xff));\n  }\n  return CONCAT44(input,bitCount >> (0x20 - (0xcU - leadingZeros) & 0xff) | absInput << (0xcU - leadingZeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_080003f4": "reverse_bit_pattern_080003f4",
                "param_1": "input",
                "uVar1": "bitCount",
                "uVar2": "absInput",
                "uVar3": "shiftAmount",
                "iVar4": "leadingZeros",
                "uVar5": "adjustedCount",
                "uVar6": "signBit",
                "in_r12": "remainingBits",
                "bVar7": "isNegative",
                "bVar8": "isZero",
                "bVar9": "isBorrow"
            },
            "calling": [
                "_svfprintf_r",
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000418": {
            "entrypoint": "0x08000418",
            "current_name": "bitwise_rotation_08000418",
            "code": "\nulonglong bitwiseRotation_08000418(uint inputValue,undefined4 param2,undefined4 param3,uint param4)\n\n{\n  uint shiftedBit;\n  uint shiftedValue;\n  uint result;\n  uint count;\n  uint temp;\n  int index;\n  uint bitDiff;\n  uint remainder;\n  bool isLessThan;\n  bool isEqual;\n  bool isCarry;\n  \n  temp = inputValue << 1;\n  isEqual = temp == 0;\n  shiftedBit = (uint)((inputValue & 0x80000000) != 0) << 0x1f;\n  count = (uint)((int)temp >> 3) >> 1;\n  result = shiftedBit | count;\n  inputValue = inputValue << 0x1d;\n  if (!isEqual) {\n    param4 = temp & 0xff000000;\n    isEqual = param4 == 0;\n  }\n  if (!isEqual) {\n    isEqual = param4 == 0xff000000;\n  }\n  if (!isEqual) {\n    return CONCAT44(result,inputValue) ^ 0x3800000000000000;\n  }\n  if ((temp & 0xffffff) == 0) {\n    return CONCAT44(result,inputValue);\n  }\n  if (param4 == 0xff000000) {\n    return CONCAT44(result,inputValue) | 0x8000000000000;\n  }\n  shiftedValue = inputValue;\n  temp = count;\n  if (count == 0) {\n    shiftedValue = 0;\n    temp = inputValue;\n  }\n  index = LZCOUNT(temp);\n  if (count == 0) {\n    index = index + 0x20;\n  }\n  bitDiff = index - 0xb;\n  isCarry = SBORROW4(bitDiff,0x20);\n  count = index - 0x2b;\n  isEqual = (int)count < 0;\n  isLessThan = count == 0;\n  if ((int)bitDiff < 0x20) {\n    isCarry = SCARRY4(count,0xc);\n    index = index + -0x1f;\n    isEqual = index < 0;\n    isLessThan = index == 0;\n    count = bitDiff;\n    if (!isLessThan && isEqual == isCarry) {\n      shiftedValue = temp << (bitDiff & 0xff);\n      temp = temp >> (0xcU - index & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isLessThan || isEqual != isCarry) {\n    remainder = 0x20 - count;\n  }\n  temp = temp << (count & 0xff);\n  if (isLessThan || isEqual != isCarry) {\n    temp = temp | shiftedValue >> (remainder & 0xff);\n  }\n  if (isLessThan || isEqual != isCarry) {\n    shiftedValue = shiftedValue << (count & 0xff);\n  }\nLAB_080002e0:\n  if ((int)bitDiff < 0x381) {\n    return CONCAT44(temp + (0x380 - bitDiff) * 0x100000 | shiftedBit,shiftedValue);\n  }\n  count = ~(0x380 - bitDiff);\n  if (0x1e < (int)count) {\n    return CONCAT44(result,temp >> (count - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  index = count - 0x13;\n  if (index == 0 || index < 0 != SCARRY4(count - 0x1f,0xc)) {\n    count = count + 1;\n    return CONCAT44(shiftedBit | temp >> (count & 0xff),\n                    shiftedValue >> (count & 0xff) | temp << (0x20 - count & 0xff));\n  }\n  return CONCAT44(result,shiftedValue >> (0x20 - (0xcU - index) & 0xff) | temp << (0xcU - index & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000418": "bitwise_rotation_08000418",
                "param_1": "inputValue",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "shiftedBit",
                "uVar2": "shiftedValue",
                "uVar3": "result",
                "uVar4": "count",
                "uVar5": "temp",
                "iVar6": "index",
                "uVar7": "bitDiff",
                "in_r12": "remainder",
                "bVar8": "isLessThan",
                "bVar9": "isEqual",
                "bVar10": "isCarry"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800045c": {
            "entrypoint": "0x0800045c",
            "current_name": "reverse_bits_0800045c",
            "code": "\nulonglong reverseBits_0800045c(uint input1,uint input2)\n\n{\n  byte bit1;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int count;\n  uint shift1;\n  int shift2;\n  uint shift3;\n  bool carryFlag1;\n  bool carryFlag2;\n  bool carryFlag3;\n  \n  if ((input1 | input2) == 0) {\n    return CONCAT44(input2,input1);\n  }\n  shift2 = 0x432;\n  shift3 = input2 >> 0x16;\n  if (shift3 != 0) {\n    shift2 = 3;\n    if (input2 >> 0x19 != 0) {\n      shift2 = 6;\n    }\n    if (input2 >> 0x1c != 0) {\n      shift2 = shift2 + 3;\n    }\n    temp3 = shift2 - ((int)input2 >> 0x1f);\n    shift3 = input1 << (0x20 - temp3 & 0xff);\n    input1 = input1 >> (temp3 & 0xff) | input2 << (0x20 - temp3 & 0xff);\n    input2 = input2 >> (temp3 & 0xff);\n    shift2 = temp3 + 0x432;\n  }\n  if (0xfffff < input2) {\n    if (0x1fffff < input2) {\n      temp3 = input2 & 1;\n      input2 = input2 >> 1;\n      bit1 = (byte)input1;\n      input1 = (uint)(temp3 != 0) << 0x1f | input1 >> 1;\n      shift3 = (uint)(bit1 & 1) << 0x1f | shift3 >> 1;\n      shift2 = shift2 + 1;\n      if (0xffbfffff < (uint)(shift2 * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_08000268:\n    carryFlag2 = 0x7fffffff < shift3;\n    if (shift3 == 0x80000000) {\n      carryFlag2 = (input1 & 1) != 0;\n    }\n    return CONCAT44(input2 + shift2 * 0x100000 + (uint)CARRY4(input1,(uint)carryFlag2),input1 + carryFlag2\n                   );\n  }\n  carryFlag1 = (shift3 & 0x80000000) != 0;\n  shift3 = shift3 << 1;\n  temp3 = input1 * 2;\n  carryFlag2 = CARRY4(input1,input1);\n  input1 = input1 * 2 + (uint)carryFlag1;\n  input2 = input2 * 2 + (uint)(carryFlag2 || CARRY4(temp3,(uint)carryFlag1));\n  shift2 = shift2 + -1;\n  if ((input2 & 0x100000) != 0) goto LAB_08000268;\n  temp1 = input1;\n  temp3 = input2;\n  if (input2 == 0) {\n    temp1 = 0;\n    temp3 = input1;\n  }\n  count = LZCOUNT(temp3);\n  if (input2 == 0) {\n    count = count + 0x20;\n  }\n  shift1 = count - 0xb;\n  carryFlag3 = SBORROW4(shift1,0x20);\n  temp2 = count - 0x2b;\n  carryFlag2 = (int)temp2 < 0;\n  carryFlag1 = temp2 == 0;\n  if ((int)shift1 < 0x20) {\n    carryFlag3 = SCARRY4(temp2,0xc);\n    count = count + -0x1f;\n    carryFlag2 = count < 0;\n    carryFlag1 = count == 0;\n    temp2 = shift1;\n    if (!carryFlag1 && carryFlag2 == carryFlag3) {\n      temp1 = temp3 << (shift1 & 0xff);\n      temp3 = temp3 >> (0xcU - count & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (carryFlag1 || carryFlag2 != carryFlag3) {\n    shift3 = 0x20 - temp2;\n  }\n  temp3 = temp3 << (temp2 & 0xff);\n  if (carryFlag1 || carryFlag2 != carryFlag3) {\n    temp3 = temp3 | temp1 >> (shift3 & 0xff);\n  }\n  if (carryFlag1 || carryFlag2 != carryFlag3) {\n    temp1 = temp1 << (temp2 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)shift1 <= shift2) {\n    return CONCAT44(temp3 + (shift2 - shift1) * 0x100000,temp1);\n  }\n  shift3 = ~(shift2 - shift1);\n  if (0x1e < (int)shift3) {\n    return (ulonglong)(temp3 >> (shift3 - 0x1f & 0xff));\n  }\n  shift2 = shift3 - 0x13;\n  if (shift2 == 0 || shift2 < 0 != SCARRY4(shift3 - 0x1f,0xc)) {\n    shift3 = shift3 + 1;\n    return CONCAT44(temp3 >> (shift3 & 0xff),temp1 >> (shift3 & 0xff) | temp3 << (0x20 - shift3 & 0xff)\n                   );\n  }\n  return (ulonglong)(temp1 >> (0x20 - (0xcU - shift2) & 0xff) | temp3 << (0xcU - shift2 & 0xff));\n}\n\n",
            "renaming": {
                "FUN_0800045c": "reverse_bits_0800045c",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "bit1",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "iVar5": "count",
                "uVar6": "shift1",
                "iVar7": "shift2",
                "uVar8": "shift3",
                "bVar9": "carryFlag1",
                "bVar10": "carryFlag2",
                "bVar11": "carryFlag3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800046c": {
            "entrypoint": "0x0800046c",
            "current_name": "calculate_result_0800046c",
            "code": "\nulonglong calculate_result_0800046c(uint input_value1,uint input_value2)\n\n{\n  byte bit1;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int shift_amount;\n  uint temp4;\n  int result;\n  uint carry_flag;\n  uint temp5;\n  bool bit2;\n  bool condition1;\n  bool condition2;\n  \n  if ((input_value1 | input_value2) == 0) {\n    return CONCAT44(input_value2,input_value1);\n  }\n  carry_flag = input_value2 & 0x80000000;\n  temp2 = input_value2;\n  if ((int)carry_flag < 0) {\n    condition1 = input_value1 != 0;\n    input_value1 = -input_value1;\n    temp2 = -input_value2 - (uint)condition1;\n  }\n  result = 0x432;\n  temp5 = temp2 >> 0x16;\n  if (temp5 != 0) {\n    result = 3;\n    if (temp2 >> 0x19 != 0) {\n      result = 6;\n    }\n    if (temp2 >> 0x1c != 0) {\n      result = result + 3;\n    }\n    temp3 = result - ((int)temp2 >> 0x1f);\n    temp5 = input_value1 << (0x20 - temp3 & 0xff);\n    input_value1 = input_value1 >> (temp3 & 0xff) | temp2 << (0x20 - temp3 & 0xff);\n    temp2 = temp2 >> (temp3 & 0xff);\n    result = temp3 + 0x432;\n  }\n  if (0xfffff < temp2) {\n    if (0x1fffff < temp2) {\n      temp3 = temp2 & 1;\n      temp2 = temp2 >> 1;\n      bit1 = (byte)input_value1;\n      input_value1 = (uint)(temp3 != 0) << 0x1f | input_value1 >> 1;\n      temp5 = (uint)(bit1 & 1) << 0x1f | temp5 >> 1;\n      result = result + 1;\n      if (0xffbfffff < (uint)(result * 0x200000)) {\n        return (ulonglong)(carry_flag | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_08000268:\n    condition1 = 0x7fffffff < temp5;\n    if (temp5 == 0x80000000) {\n      condition1 = (input_value1 & 1) != 0;\n    }\n    return CONCAT44(temp2 + result * 0x100000 + (uint)CARRY4(input_value1,(uint)condition1) | carry_flag,\n                    input_value1 + condition1);\n  }\n  bit2 = (temp5 & 0x80000000) != 0;\n  temp5 = temp5 << 1;\n  temp3 = input_value1 * 2;\n  condition1 = CARRY4(input_value1,input_value1);\n  input_value1 = input_value1 * 2 + (uint)bit2;\n  temp2 = temp2 * 2 + (uint)(condition1 || CARRY4(temp3,(uint)bit2));\n  result = result + -1;\n  if ((temp2 & 0x100000) != 0) goto LAB_08000268;\n  temp1 = input_value1;\n  temp3 = temp2;\n  if (temp2 == 0) {\n    temp1 = 0;\n    temp3 = input_value1;\n  }\n  shift_amount = LZCOUNT(temp3);\n  if (temp2 == 0) {\n    shift_amount = shift_amount + 0x20;\n  }\n  temp4 = shift_amount - 0xb;\n  condition2 = SBORROW4(temp4,0x20);\n  temp2 = shift_amount - 0x2b;\n  condition1 = (int)temp2 < 0;\n  bit2 = temp2 == 0;\n  if ((int)temp4 < 0x20) {\n    condition2 = SCARRY4(temp2,0xc);\n    shift_amount = shift_amount + -0x1f;\n    condition1 = shift_amount < 0;\n    bit2 = shift_amount == 0;\n    temp2 = temp4;\n    if (!bit2 && condition1 == condition2) {\n      temp1 = temp3 << (temp4 & 0xff);\n      temp3 = temp3 >> (0xcU - shift_amount & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (bit2 || condition1 != condition2) {\n    temp5 = 0x20 - temp2;\n  }\n  temp3 = temp3 << (temp2 & 0xff);\n  if (bit2 || condition1 != condition2) {\n    temp3 = temp3 | temp1 >> (temp5 & 0xff);\n  }\n  if (bit2 || condition1 != condition2) {\n    temp1 = temp1 << (temp2 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)temp4 <= result) {\n    return CONCAT44(temp3 + (result - temp4) * 0x100000 | carry_flag,temp1);\n  }\n  temp2 = ~(result - temp4);\n  if (0x1e < (int)temp2) {\n    return CONCAT44(input_value2,temp3 >> (temp2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  result = temp2 - 0x13;\n  if (result == 0 || result < 0 != SCARRY4(temp2 - 0x1f,0xc)) {\n    temp2 = temp2 + 1;\n    return CONCAT44(carry_flag | temp3 >> (temp2 & 0xff),\n                    temp1 >> (temp2 & 0xff) | temp3 << (0x20 - temp2 & 0xff));\n  }\n  return CONCAT44(input_value2,temp1 >> (0x20 - (0xcU - result) & 0xff) | temp3 << (0xcU - result & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800046c": "calculate_result_0800046c",
                "param_1": "input_value1",
                "param_2": "input_value2",
                "bVar1": "bit1",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "iVar5": "shift_amount",
                "uVar6": "temp4",
                "iVar7": "result",
                "uVar8": "carry_flag",
                "uVar9": "temp5",
                "bVar10": "bit2",
                "bVar11": "condition1",
                "bVar12": "condition2"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004c8": {
            "entrypoint": "0x080004c8",
            "current_name": "compute_result_080004c8",
            "code": "\nulonglong compute_result_080004c8(undefined4 input1,uint input2,uint input3,uint input4)\n\n{\n  ulonglong result1;\n  longlong result2;\n  uint result3;\n  uint result4;\n  int result5;\n  uint result6;\n  uint result7;\n  uint result8;\n  uint result9;\n  bool isZero;\n  bool isNegative;\n  bool isOverflow;\n  ulonglong combinedInputs;\n  \n  combinedInputs = CONCAT44(input2,input1);\n  result8 = 0x7ff;\n  result4 = input2 >> 0x14 & 0x7ff;\n  isZero = result4 == 0;\n  if (!isZero) {\n    result7 = input4 >> 0x14 & 0x7ff;\n    isZero = result7 == 0;\n  }\n  if (!isZero) {\n    isZero = result4 == 0x7ff;\n  }\n  if (!isZero) {\n    isZero = result7 == 0x7ff;\n  }\n  if (isZero) {\n    combinedInputs = compute_bitwise_result_080006a4();\n  }\n  result3 = (uint)(combinedInputs >> 0x20);\n  result5 = result4 + result7;\n  result4 = result3 ^ input4;\n  result3 = result3 & ~(result8 << 0x15);\n  input4 = input4 & ~(result8 << 0x15);\n  isZero = ((uint)combinedInputs | result3 << 0xc) == 0;\n  if (!isZero) {\n    isZero = (input3 | input4 << 0xc) == 0;\n  }\n  result3 = result3 | 0x100000;\n  input4 = input4 | 0x100000;\n  if (isZero) {\n    input3 = (uint)combinedInputs | input3;\n    input4 = (result4 & 0x80000000 | result3) ^ input4;\n    result4 = result8 >> 1;\n    isOverflow = SBORROW4(result5,result4);\n    result6 = result5 - result4;\n    isZero = result6 == 0;\n    result3 = result6;\n    if (!isZero && (int)result4 <= result5) {\n      isOverflow = SBORROW4(result8,result6);\n      result3 = result8 - result6;\n      isZero = result8 == result6;\n    }\n    if (!isZero && (int)result3 < 0 == isOverflow) {\n      input4 = input4 | result6 * 0x100000;\n    }\n    if (!isZero && (int)result3 < 0 == isOverflow) {\n      return CONCAT44(input4,input3);\n    }\n    input4 = input4 | 0x100000;\n    result8 = 0;\n    isOverflow = SBORROW4(result6,1);\n    result6 = result6 - 1;\n    isZero = result6 == 0;\n    result4 = result6;\n  }\n  else {\n    result1 = (combinedInputs & 0xffffffff) * (ulonglong)input3;\n    combinedInputs = (combinedInputs & 0xffffffff) * (ulonglong)input4 +\n             (ulonglong)result3 * (ulonglong)input3 + (result1 >> 0x20);\n    result9 = (uint)combinedInputs;\n    result2 = (ulonglong)result3 * (ulonglong)input4 + (combinedInputs >> 0x20);\n    result8 = (uint)result2;\n    result3 = (uint)((ulonglong)result2 >> 0x20);\n    if ((int)result1 != 0) {\n      result9 = result9 | 1;\n    }\n    result6 = (result5 + -0x3ff) - (uint)(result3 < 0x200);\n    if (result3 < 0x200) {\n      isZero = (result9 & 0x80000000) != 0;\n      result9 = result9 << 1;\n      result2 = CONCAT44(result3 * 2 + (uint)(CARRY4(result8,result8) || CARRY4(result8 * 2,(uint)isZero)),\n                       result8 * 2 + (uint)isZero);\n    }\n    input4 = result4 & 0x80000000 | (int)((ulonglong)result2 >> 0x20) << 0xb | (uint)result2 >> 0x15;\n    input3 = (uint)result2 << 0xb | result9 >> 0x15;\n    result8 = result9 * 0x800;\n    isNegative = 0xfc < result6;\n    isOverflow = SBORROW4(result6,0xfd);\n    result3 = result6 - 0xfd;\n    isZero = result3 == 0;\n    result4 = result3;\n    if (isNegative && !isZero) {\n      isNegative = 0x6ff < result3;\n      isOverflow = SBORROW4(result3,0x700);\n      result4 = result6 - 0x7fd;\n      isZero = result3 == 0x700;\n    }\n    if (!isNegative || isZero) {\n      isZero = 0x7fffffff < result8;\n      if (result8 == 0x80000000) {\n        isZero = (result9 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(input4 + result6 * 0x100000 + (uint)CARRY4(input3,(uint)isZero),input3 + isZero\n                     );\n    }\n  }\n  if (!isZero && (int)result4 < 0 == isOverflow) {\n    return (ulonglong)(input4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  isNegative = SCARRY4(result6,0x36);\n  isZero = (int)(result6 + 0x36) < 0;\n  isOverflow = result6 == 0xffffffca;\n  if (isOverflow || isZero != isNegative) {\n    input3 = 0;\n  }\n  if (isOverflow || isZero != isNegative) {\n    input4 = input4 & 0x80000000;\n  }\n  if (isOverflow || isZero != isNegative) {\n    return CONCAT44(input4,input3);\n  }\n  result4 = -result6;\n  result3 = result4 - 0x20;\n  if (0x1f < (int)result4) {\n    result6 = input3 >> (result3 & 0xff) | input4 << (0x20 - result3 & 0xff);\n    result4 = (input4 >> (result3 & 0xff) & ~((input4 & 0x80000000) >> (result3 & 0xff))) -\n            ((int)result6 >> 0x1f);\n    if ((result8 | input3 << (0x20 - result3 & 0xff) | result6 << 1) == 0) {\n      result4 = result4 & ~(result6 >> 0x1f);\n    }\n    return CONCAT44(input4,result4) & 0x80000000ffffffff;\n  }\n  result5 = result4 - 0x14;\n  if (result5 == 0 || result5 < 0 != SCARRY4(result3,0xc)) {\n    result9 = input3 << (result6 + 0x20 & 0xff);\n    result3 = input3 >> (result4 & 0xff) | input4 << (result6 + 0x20 & 0xff);\n    result6 = result3 + -((int)result9 >> 0x1f);\n    if ((result8 | result9 << 1) == 0) {\n      result6 = result6 & ~(result9 >> 0x1f);\n    }\n    return CONCAT44((input4 & 0x80000000) +\n                    ((input4 & 0x7fffffff) >> (result4 & 0xff)) +\n                    (uint)CARRY4(result3,-((int)result9 >> 0x1f)),result6);\n  }\n  result4 = 0xc - result5;\n  result6 = input3 << (result4 & 0xff);\n  result4 = input3 >> (0x20 - result4 & 0xff) | input4 << (result4 & 0xff);\n  result3 = result4 + -((int)result6 >> 0x1f);\n  if ((result8 | result6 << 1) == 0) {\n    result3 = result3 & ~(result6 >> 0x1f);\n  }\n  return CONCAT44((input4 & 0x80000000) + (uint)CARRY4(result4,-((int)result6 >> 0x1f)),result3);\n}\n\n",
            "renaming": {
                "FUN_080004c8": "compute_result_080004c8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "result1",
                "lVar2": "result2",
                "uVar3": "result3",
                "uVar4": "result4",
                "iVar5": "result5",
                "uVar6": "result6",
                "unaff_r5": "result7",
                "uVar7": "result8",
                "uVar8": "result9",
                "bVar9": "isZero",
                "bVar10": "isNegative",
                "bVar11": "isOverflow",
                "uVar12": "combinedInputs"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "_svfprintf_r",
                "atan",
                "_dtoa_r",
                "frexp",
                "mpu6050_calc_pitch"
            ],
            "called": [
                "FUN_080006a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006a4": {
            "entrypoint": "0x080006a4",
            "current_name": "compute_bitwise_result_080006a4",
            "code": "\nulonglong compute_bitwise_result_080006a4(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint temp_1;\n  uint temp_2;\n  uint temp_2;\n  uint temp_4;\n  uint temp_5;\n  bool is_zero;\n  \n  temp_2 = temp_5 & input_4 >> 0x14;\n  if (temp_2 != temp_5 && temp_2 != temp_5) {\n    is_zero = (input_1 | input_2 << 1) == 0;\n    if (!is_zero) {\n      is_zero = (input_3 | input_4 << 1) == 0;\n    }\n    if (is_zero) {\n      return (ulonglong)((input_2 ^ input_4) & 0x80000000) << 0x20;\n    }\n    if (temp_2 == 0) {\n      temp_4 = input_2 & 0x80000000;\n      do {\n        temp_1 = input_1 & 0x80000000;\n        input_1 = input_1 << 1;\n        input_2 = input_2 * 2 + (uint)(temp_1 != 0);\n      } while ((input_2 & 0x100000) == 0);\n      input_2 = input_2 | temp_4;\n      if (temp_2 != 0) {\n        return CONCAT44(input_2,input_1);\n      }\n    }\n    do {\n      temp_2 = input_3 & 0x80000000;\n      input_3 = input_3 << 1;\n      input_4 = input_4 * 2 + (uint)(temp_2 != 0);\n    } while ((input_4 & 0x100000) == 0);\n    return CONCAT44(input_2,input_1);\n  }\n  is_zero = (input_1 | input_2 << 1) == 0;\n  if (is_zero) {\n    input_2 = input_4;\n    input_1 = input_3;\n  }\n  if (!is_zero) {\n    is_zero = (input_3 | input_4 << 1) == 0;\n  }\n  temp_4 = input_2;\n  if (((!is_zero) && ((temp_2 != temp_5 || ((input_1 | input_2 << 0xc) == 0)))) &&\n     ((temp_2 != temp_5 || (input_1 = input_3, temp_4 = input_4, (input_3 | input_4 << 0xc) == 0)))) {\n    return (ulonglong)((input_2 ^ input_4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(temp_4,input_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006a4": "compute_bitwise_result_080006a4",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "temp_1",
                "unaff_r4": "temp_2",
                "uVar2": "temp_2",
                "uVar3": "temp_4",
                "in_r12": "temp_5",
                "bVar4": "is_zero"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800071c": {
            "entrypoint": "0x0800071c",
            "current_name": "calculate_double_precision_0800071c",
            "code": "\nulonglong calculate_double_precision_0800071c(undefined4 input_param_1,uint input_param_2,uint input_param_3,uint input_param_4)\n\n{\n  uint temp_var_1;\n  uint temp_var_2;\n  uint temp_var_3;\n  uint temp_var_4;\n  uint temp_var_5;\n  uint temp_var_6;\n  uint temp_var_7;\n  int temp_var_8;\n  uint temp_var_9;\n  uint temp_var_10;\n  uint temp_var_11;\n  uint temp_var_12;\n  uint temp_var_13;\n  uint temp_var_14;\n  bool temp_var_15;\n  bool temp_var_16;\n  bool temp_var_17;\n  undefined8 temp_var_18;\n  \n  temp_var_18 = CONCAT44(input_param_2,input_param_1);\n  temp_var_14 = 0x7ff;\n  temp_var_7 = input_param_2 >> 0x14 & 0x7ff;\n  temp_var_15 = temp_var_7 == 0;\n  if (!temp_var_15) {\n    temp_var_10 = input_param_4 >> 0x14 & 0x7ff;\n    temp_var_15 = temp_var_10 == 0;\n  }\n  if (!temp_var_15) {\n    temp_var_15 = temp_var_7 == 0x7ff;\n  }\n  if (!temp_var_15) {\n    temp_var_15 = temp_var_10 == 0x7ff;\n  }\n  if (temp_var_15) {\n    temp_var_18 = calculate_double_precision_0800071c_value_0800088a();\n  }\n  temp_var_9 = (uint)((ulonglong)temp_var_18 >> 0x20);\n  temp_var_12 = (uint)temp_var_18;\n  temp_var_8 = temp_var_7 - temp_var_10;\n  if ((input_param_3 | input_param_4 << 0xc) == 0) {\n    temp_var_7 = (temp_var_9 ^ input_param_4) & 0x80000000 | temp_var_9 & 0xfffff;\n    temp_var_17 = SCARRY4(temp_var_8,temp_var_14 >> 1);\n    temp_var_9 = temp_var_8 + (temp_var_14 >> 1);\n    temp_var_15 = (int)temp_var_9 < 0;\n    temp_var_16 = temp_var_9 == 0;\n    if (!temp_var_16 && temp_var_15 == temp_var_17) {\n      temp_var_17 = SBORROW4(temp_var_14,temp_var_9);\n      temp_var_15 = (int)(temp_var_14 - temp_var_9) < 0;\n      temp_var_16 = temp_var_14 == temp_var_9;\n    }\n    if (!temp_var_16 && temp_var_15 == temp_var_17) {\n      temp_var_7 = temp_var_7 | temp_var_9 * 0x100000;\n    }\n    if (!temp_var_16 && temp_var_15 == temp_var_17) {\n      return CONCAT44(temp_var_7,temp_var_12);\n    }\n    temp_var_7 = temp_var_7 | 0x100000;\n    temp_var_14 = 0;\n    temp_var_16 = SBORROW4(temp_var_9,1);\n    temp_var_9 = temp_var_9 - 1;\n    temp_var_15 = temp_var_9 == 0;\n    temp_var_3 = temp_var_9;\n  }\n  else {\n    temp_var_3 = (input_param_4 << 0xc) >> 4 | 0x10000000 | input_param_3 >> 0x18;\n    temp_var_14 = input_param_3 << 8;\n    temp_var_11 = (temp_var_9 << 0xc) >> 4 | 0x10000000 | temp_var_12 >> 0x18;\n    temp_var_12 = temp_var_12 * 0x100;\n    temp_var_7 = (temp_var_9 ^ input_param_4) & 0x80000000;\n    temp_var_15 = temp_var_3 <= temp_var_11;\n    if (temp_var_11 == temp_var_3) {\n      temp_var_15 = temp_var_14 <= temp_var_12;\n    }\n    temp_var_8 = temp_var_8 + (uint)temp_var_15;\n    temp_var_9 = temp_var_8 + 0x3fd;\n    if (temp_var_15 == false) {\n      temp_var_3 = temp_var_3 >> 1;\n      temp_var_14 = (uint)((input_param_3 >> 0x18 & 1) != 0) << 0x1f | temp_var_14 >> 1;\n    }\n    temp_var_13 = temp_var_12 - temp_var_14;\n    temp_var_11 = (temp_var_11 - temp_var_3) - (uint)(temp_var_12 < temp_var_14);\n    temp_var_4 = temp_var_3 >> 1;\n    temp_var_1 = (uint)((temp_var_3 & 1) != 0) << 0x1f | temp_var_14 >> 1;\n    temp_var_12 = 0x100000;\n    temp_var_3 = 0x80000;\n    while( true ) {\n      temp_var_15 = temp_var_1 <= temp_var_13;\n      if (temp_var_4 < temp_var_11 || temp_var_11 - temp_var_4 < (uint)temp_var_15) {\n        temp_var_13 = temp_var_13 - temp_var_1;\n        temp_var_12 = temp_var_12 | temp_var_3;\n        temp_var_11 = (temp_var_11 - temp_var_4) - (uint)!temp_var_15;\n      }\n      temp_var_5 = temp_var_4 >> 1;\n      temp_var_1 = (uint)((temp_var_4 & 1) != 0) << 0x1f | temp_var_1 >> 1;\n      temp_var_16 = temp_var_1 <= temp_var_13;\n      temp_var_15 = temp_var_11 - temp_var_5 < (uint)temp_var_16;\n      temp_var_14 = temp_var_11;\n      if (temp_var_5 < temp_var_11 || temp_var_15) {\n        temp_var_13 = temp_var_13 - temp_var_1;\n        temp_var_14 = (temp_var_11 - temp_var_5) - (uint)!temp_var_16;\n      }\n      if (temp_var_5 < temp_var_11 || temp_var_15) {\n        temp_var_12 = temp_var_12 | temp_var_3 >> 1;\n      }\n      temp_var_11 = temp_var_4 >> 2;\n      temp_var_2 = (uint)((temp_var_5 & 1) != 0) << 0x1f | temp_var_1 >> 1;\n      temp_var_16 = temp_var_2 <= temp_var_13;\n      temp_var_15 = temp_var_14 - temp_var_11 < (uint)temp_var_16;\n      temp_var_5 = temp_var_14;\n      if (temp_var_11 < temp_var_14 || temp_var_15) {\n        temp_var_13 = temp_var_13 - temp_var_2;\n        temp_var_5 = (temp_var_14 - temp_var_11) - (uint)!temp_var_16;\n      }\n      if (temp_var_11 < temp_var_14 || temp_var_15) {\n        temp_var_12 = temp_var_12 | temp_var_3 >> 2;\n      }\n      temp_var_6 = temp_var_4 >> 3;\n      temp_var_1 = (uint)((temp_var_11 & 1) != 0) << 0x1f | temp_var_2 >> 1;\n      temp_var_16 = temp_var_1 <= temp_var_13;\n      temp_var_15 = temp_var_5 - temp_var_6 < (uint)temp_var_16;\n      temp_var_11 = temp_var_5;\n      if (temp_var_6 < temp_var_5 || temp_var_15) {\n        temp_var_13 = temp_var_13 - temp_var_1;\n        temp_var_11 = (temp_var_5 - temp_var_6) - (uint)!temp_var_16;\n      }\n      if (temp_var_6 < temp_var_5 || temp_var_15) {\n        temp_var_12 = temp_var_12 | temp_var_3 >> 3;\n      }\n      temp_var_14 = temp_var_11 | temp_var_13;\n      if (temp_var_14 == 0) break;\n      temp_var_11 = temp_var_11 << 4 | temp_var_13 >> 0x1c;\n      temp_var_13 = temp_var_13 << 4;\n      temp_var_4 = temp_var_4 & 0xfffffff8 | temp_var_1 >> 0x1d;\n      temp_var_1 = (temp_var_2 >> 1) << 3;\n      temp_var_3 = temp_var_3 >> 4;\n      if (temp_var_3 == 0) {\n        temp_var_6 = temp_var_4;\n        if ((temp_var_7 & 0x100000) != 0) goto LAB_0800083a;\n        temp_var_7 = temp_var_7 | temp_var_12;\n        temp_var_12 = 0;\n        temp_var_3 = 0x80000000;\n      }\n    }\n    if ((temp_var_7 & 0x100000) == 0) {\n      temp_var_7 = temp_var_7 | temp_var_12;\n      temp_var_12 = 0;\n    }\nLAB_0800083a:\n    temp_var_17 = 0xfc < temp_var_9;\n    temp_var_16 = SBORROW4(temp_var_9,0xfd);\n    temp_var_4 = temp_var_8 + 0x300;\n    temp_var_15 = temp_var_4 == 0;\n    temp_var_3 = temp_var_4;\n    if (temp_var_17 && !temp_var_15) {\n      temp_var_17 = 0x6ff < temp_var_4;\n      temp_var_16 = SBORROW4(temp_var_4,0x700);\n      temp_var_3 = temp_var_8 - 0x400;\n      temp_var_15 = temp_var_4 == 0x700;\n    }\n    if (!temp_var_17 || temp_var_15) {\n      temp_var_15 = temp_var_6 <= temp_var_11;\n      if (temp_var_11 == temp_var_6) {\n        temp_var_15 = temp_var_1 <= temp_var_13;\n      }\n      if (temp_var_11 == temp_var_6 && temp_var_13 == temp_var_1) {\n        temp_var_15 = (temp_var_12 & 1) != 0;\n      }\n      return CONCAT44(temp_var_7 + temp_var_9 * 0x100000 + (uint)CARRY4(temp_var_12,(uint)temp_var_15),temp_var_12 + temp_var_15);\n    }\n  }\n  if (!temp_var_15 && (int)temp_var_3 < 0 == temp_var_16) {\n    return (ulonglong)(temp_var_7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  temp_var_17 = SCARRY4(temp_var_9,0x36);\n  temp_var_15 = (int)(temp_var_9 + 0x36) < 0;\n  temp_var_16 = temp_var_9 == 0xffffffca;\n  if (temp_var_16 || temp_var_15 != temp_var_17) {\n    temp_var_12 = 0;\n  }\n  if (temp_var_16 || temp_var_15 != temp_var_17) {\n    temp_var_7 = temp_var_7 & 0x80000000;\n  }\n  if (temp_var_16 || temp_var_15 != temp_var_17) {\n    return CONCAT44(temp_var_7,temp_var_12);\n  }\n  temp_var_3 = -temp_var_9;\n  temp_var_11 = temp_var_3 - 0x20;\n  if (0x1f < (int)temp_var_3) {\n    temp_var_3 = temp_var_12 >> (temp_var_11 & 0xff) | temp_var_7 << (0x20 - temp_var_11 & 0xff);\n    temp_var_9 = (temp_var_7 >> (temp_var_11 & 0xff) & ~((temp_var_7 & 0x80000000) >> (temp_var_11 & 0xff))) -\n            ((int)temp_var_3 >> 0x1f);\n    if ((temp_var_14 | temp_var_12 << (0x20 - temp_var_11 & 0xff) | temp_var_3 << 1) == 0) {\n      temp_var_9 = temp_var_9 & ~(temp_var_3 >> 0x1f);\n    }\n    return CONCAT44(temp_var_7,temp_var_9) & 0x80000000ffffffff;\n  }\n  temp_var_8 = temp_var_3 - 0x14;\n  if (temp_var_8 != 0 && temp_var_8 < 0 == SCARRY4(temp_var_11,0xc)) {\n    temp_var_9 = 0xc - temp_var_8;\n    temp_var_3 = temp_var_12 << (temp_var_9 & 0xff);\n    temp_var_12 = temp_var_12 >> (0x20 - temp_var_9 & 0xff) | temp_var_7 << (temp_var_9 & 0xff);\n    temp_var_9 = temp_var_12 + -((int)temp_var_3 >> 0x1f);\n    if ((temp_var_14 | temp_var_3 << 1) == 0) {\n      temp_var_9 = temp_var_9 & ~(temp_var_3 >> 0x1f);\n    }\n    return CONCAT44((temp_var_7 & 0x80000000) + (uint)CARRY4(temp_var_12,-((int)temp_var_3 >> 0x1f)),temp_var_9);\n  }\n  temp_var_11 = temp_var_12 << (temp_var_9 + 0x20 & 0xff);\n  temp_var_12 = temp_var_12 >> (temp_var_3 & 0xff) | temp_var_7 << (temp_var_9 + 0x20 & 0xff);\n  temp_var_9 = temp_var_12 + -((int)temp_var_11 >> 0x1f);\n  if ((temp_var_14 | temp_var_11 << 1) == 0) {\n    temp_var_9 = temp_var_9 & ~(temp_var_11 >> 0x1f);\n  }\n  return CONCAT44((temp_var_7 & 0x80000000) +\n                  ((temp_var_7 & 0x7fffffff) >> (temp_var_3 & 0xff)) +\n                  (uint)CARRY4(temp_var_12,-((int)temp_var_11 >> 0x1f)),temp_var_9);\n}\n\n",
            "renaming": {
                "FUN_0800071c": "calculate_double_precision_0800071c",
                "param_1": "input_param_1",
                "param_2": "input_param_2",
                "param_3": "input_param_3",
                "param_4": "input_param_4",
                "uVar1": "temp_var_1",
                "uVar2": "temp_var_2",
                "uVar3": "temp_var_3",
                "uVar4": "temp_var_4",
                "uVar5": "temp_var_5",
                "uVar6": "temp_var_6",
                "uVar7": "temp_var_7",
                "iVar8": "temp_var_8",
                "uVar9": "temp_var_9",
                "unaff_r5": "temp_var_10",
                "uVar10": "temp_var_11",
                "uVar11": "temp_var_12",
                "uVar12": "temp_var_13",
                "uVar13": "temp_var_14",
                "bVar14": "temp_var_15",
                "bVar15": "temp_var_16",
                "bVar16": "temp_var_17",
                "uVar17": "temp_var_18"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch"
            ],
            "called": [
                "FUN_0800088a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800088a": {
            "entrypoint": "0x0800088a",
            "current_name": "calculate_double_precision_value_0800088a",
            "code": "\nulonglong calculate_double_precision_value_0800088a(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint bit_1;\n  uint temp_1;\n  uint temp_2;\n  uint temp_3;\n  uint constant_1;\n  bool check_result;\n  \n  temp_2 = constant_1 & input_4 >> 0x14;\n  temp_3 = input_2;\n  if (temp_1 != constant_1 || temp_2 != constant_1) {\n    if (temp_1 == constant_1) {\n      if (((input_1 | input_2 << 0xc) == 0) && (input_1 = input_3, temp_3 = input_4, temp_2 != constant_1)\n         ) {\nLAB_080006fc:\n        return (ulonglong)((input_2 ^ input_4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (temp_2 == constant_1) {\n      input_1 = input_3;\n      temp_3 = input_4;\n      if ((input_3 | input_4 << 0xc) == 0) {\nLAB_080006c0:\n        return (ulonglong)((input_2 ^ input_4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      check_result = (input_1 | input_2 << 1) == 0;\n      if (!check_result) {\n        check_result = (input_3 | input_4 << 1) == 0;\n      }\n      if (!check_result) {\n        if (temp_1 == 0) {\n          temp_3 = input_2 & 0x80000000;\n          do {\n            bit_1 = input_1 & 0x80000000;\n            input_1 = input_1 << 1;\n            input_2 = input_2 * 2 + (uint)(bit_1 != 0);\n          } while ((input_2 & 0x100000) == 0);\n          input_2 = input_2 | temp_3;\n          if (temp_2 != 0) {\n            return CONCAT44(input_2,input_1);\n          }\n        }\n        do {\n          temp_3 = input_3 & 0x80000000;\n          input_3 = input_3 << 1;\n          input_4 = input_4 * 2 + (uint)(temp_3 != 0);\n        } while ((input_4 & 0x100000) == 0);\n        return CONCAT44(input_2,input_1);\n      }\n      if ((input_1 | input_2 << 1) != 0) goto LAB_080006fc;\n      if ((input_3 | input_4 << 1) != 0) goto LAB_080006c0;\n    }\n  }\n  return CONCAT44(temp_3,input_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_0800088a": "calculate_double_precision_value_0800088a",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "bit_1",
                "unaff_r4": "temp_1",
                "uVar2": "temp_2",
                "uVar3": "temp_3",
                "in_r12": "constant_1",
                "bVar4": "check_result"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008ec": {
            "entrypoint": "0x080008ec",
            "current_name": "compare_parameters_080008ec",
            "code": "\nuint compare_parameters_080008ec(uint val_1,uint val_2,uint val_3,uint val_4)\n\n{\n  uint result;\n  bool is_zero;\n  bool is_less;\n  \n  if (((int)(val_2 << 1) >> 0x15 == -1 || (int)(val_4 << 1) >> 0x15 == -1) &&\n     ((((int)(val_2 << 1) >> 0x15 == -1 && ((val_1 | val_2 << 0xc) != 0)) ||\n      (((int)(val_4 << 1) >> 0x15 == -1 && ((val_3 | val_4 << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  is_zero = (val_1 | val_2 << 1) == 0;\n  if (is_zero) {\n    is_zero = (val_3 | val_4 << 1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = val_2 == val_4;\n  }\n  if (is_zero) {\n    is_zero = val_1 == val_3;\n  }\n  if (!is_zero) {\n    result = val_2 ^ val_4;\n    is_zero = result == 0;\n    if (-1 < (int)result) {\n      is_zero = val_2 == val_4;\n    }\n    is_less = -1 < (int)result && val_4 <= val_2;\n    if (is_zero) {\n      is_less = val_3 <= val_1;\n    }\n    val_4 = (int)val_4 >> 0x1f;\n    if (!is_less) {\n      val_4 = ~val_4;\n    }\n    return val_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008ec": "compare_parameters_080008ec",
                "param_1": "val_1",
                "param_2": "val_2",
                "param_3": "val_3",
                "param_4": "val_4",
                "uVar1": "result",
                "bVar2": "is_zero",
                "bVar3": "is_less"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008f4": {
            "entrypoint": "0x080008f4",
            "current_name": "check_params_and_return_080008f4",
            "code": "\nuint check_params_and_return_080008f4(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint result;\n  bool isZero;\n  bool isNegative;\n  \n  if (((int)(input2 << 1) >> 0x15 equal -1 || (int)(input4 << 1) >> 0x15 equal -1) bitwise_andbitwise_and\n     ((((int)(input2 << 1) >> 0x15 equal -1 bitwise_andbitwise_and ((input1 | input2 << 0xc) != 0)) ||\n      (((int)(input4 << 1) >> 0x15 equal -1 bitwise_andbitwise_and ((input3 | input4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (input1 | input2 << 1) equal 0;\n  if (isZero) {\n    isZero = (input3 | input4 << 1) equal 0;\n  }\n  if (!isZero) {\n    isZero = input2 equal input4;\n  }\n  if (isZero) {\n    isZero = input1 equal input3;\n  }\n  if (!isZero) {\n    result = input2 bitwise_xor input4;\n    isZero = result equal 0;\n    if (-1 < (int)result) {\n      isZero = input2 equal input4;\n    }\n    isNegative = -1 < (int)result bitwise_andbitwise_and input4 <= input2;\n    if (isZero) {\n      isNegative = input3 <= input1;\n    }\n    input4 = (int)input4 >> 0x1f;\n    if (!isNegative) {\n      input4 = bitwise_notinput4;\n    }\n    return input4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008f4": "check_params_and_return_080008f4",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isNegative",
                "==": "equal",
                "&": "bitwise_and",
                "^": "bitwise_xor",
                "~": "bitwise_not"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008fc": {
            "entrypoint": "0x080008fc",
            "current_name": "check_params_080008fc",
            "code": "\nuint check_params_080008fc(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint result;\n  bool all_zeros;\n  bool has_match;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  all_zeros = (value1 | value2 << 1) == 0;\n  if (all_zeros) {\n    all_zeros = (value3 | value4 << 1) == 0;\n  }\n  if (!all_zeros) {\n    all_zeros = value2 == value4;\n  }\n  if (all_zeros) {\n    all_zeros = value1 == value3;\n  }\n  if (!all_zeros) {\n    result = value2 ^ value4;\n    all_zeros = result == 0;\n    if (-1 < (int)result) {\n      all_zeros = value2 == value4;\n    }\n    has_match = -1 < (int)result && value4 <= value2;\n    if (all_zeros) {\n      has_match = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!has_match) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008fc": "check_params_080008fc",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result",
                "bVar2": "all_zeros",
                "bVar3": "has_match"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000978": {
            "entrypoint": "0x08000978",
            "current_name": "compare_real_numbers_08000978",
            "code": "\nvoid compareRealNumbers_08000978(undefined4 resultFlag,undefined4 comparisonFlag,undefined4 number1,undefined4 number2)\n\n{\n  __aeabi_cdcmpeq(number1,number2,resultFlag,comparisonFlag);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000978": "compare_real_numbers_08000978",
                "param_1": "resultFlag",
                "param_2": "comparisonFlag",
                "param_3": "number1",
                "param_4": "number2"
            },
            "calling": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000988": {
            "entrypoint": "0x08000988",
            "current_name": "convert_param_to_undefined_08000988",
            "code": "\nundefined4 convertParamToUndefined_08000988(undefined4 inputParam)\n\n{\n  performFloatConversion();\n  return inputParam;\n}\n\n",
            "renaming": {
                "FUN_08000988": "convert_param_to_undefined_08000988",
                "param_1": "inputParam",
                "__nedf2": "performFloatConversion"
            },
            "calling": [
                "__aeabi_dcmpeq",
                "__aeabi_cdrcmple",
                "__aeabi_dcmple",
                "__aeabi_dcmplt"
            ],
            "called": [
                "__nedf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "check_n_zero_character_08000998",
            "code": "\nbool checkNZeroCharacter_08000998(void)\n\n{\n  char inputChar;\n  \n  __aeabi_cdcmpeq();\n  return inputChar != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000998": "check_n_zero_character_08000998",
                "in_ZR": "inputChar"
            },
            "calling": [
                "_svfprintf_r",
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009ac": {
            "entrypoint": "0x080009ac",
            "current_name": "is_input_empty_080009ac",
            "code": "\nbool is_input_empty_080009ac(void)\n\n{\n  char input_variable;\n  \n  __aeabi_cdcmpeq();\n  return input_variable == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009ac": "is_input_empty_080009ac",
                "in_CY": "input_variable"
            },
            "calling": [
                "_svfprintf_r",
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c0": {
            "entrypoint": "0x080009c0",
            "current_name": "check_equality_080009c0",
            "code": "\nbool checkEquality_080009c0(void)\n\n{\n  undefined isZero;\n  undefined isCarry;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)isCarry || (bool)isZero;\n}\n\n",
            "renaming": {
                "FUN_080009c0": "check_equality_080009c0",
                "in_ZR": "isZero",
                "in_CY": "isCarry"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009d4": {
            "entrypoint": "0x080009d4",
            "current_name": "is_comparable_080009d4",
            "code": "\nbool is_comparable_080009d4(void)\n\n{\n  undefined is_zero;\n  undefined is_carry;\n  \n  __aeabi_cdrcmple();\n  return !(bool)is_carry || (bool)is_zero;\n}\n\n",
            "renaming": {
                "FUN_080009d4": "is_comparable_080009d4",
                "in_ZR": "is_zero",
                "in_CY": "is_carry"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009e8": {
            "entrypoint": "0x080009e8",
            "current_name": "is_null_terminated_080009e8",
            "code": "\nbool is_null_terminated_080009e8(void)\n\n{\n  char input_char;\n  \n  __aeabi_cdrcmple();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009e8": "is_null_terminated_080009e8",
                "in_CY": "input_char"
            },
            "calling": [
                "_svfprintf_r",
                "atan",
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009fc": {
            "entrypoint": "0x080009fc",
            "current_name": "calculate_modified_float_080009fc",
            "code": "\nuint calculateModifiedFloat_080009fc(uint input1,uint input2)\n\n{\n  uint result;\n  uint temp;\n  uint temp2;\n  uint temp3;\n  bool isZero;\n  bool lessThanThreshold;\n  \n  temp = input2 * 2;\n  lessThanThreshold = temp < 0x70000000;\n  temp2 = temp + 0x90000000;\n  result = temp2;\n  if (!lessThanThreshold) {\n    temp3 = temp + 0x8fe00000;\n    result = temp3;\n  }\n  isZero = result == 0;\n  if (!lessThanThreshold && temp2 >= 0x200000) {\n    isZero = temp3 == 0x1fc00000;\n  }\n  if (((lessThanThreshold || temp2 < 0x200000) || 0x1fc00000 < temp3) || isZero) {\n    if ((input2 & 0x40000000) != 0) {\n      if (((int)temp >> 0x15 == -1) && ((input1 | input2 << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return input2 & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(temp + 0x92e00000) < 0 != SCARRY4(temp2,0x2e00000)) {\n      return input2 & 0x80000000;\n    }\n    temp = 0x18 - (temp + 0x92e00000 >> 0x15);\n    result = input1 >> (temp & 0xff);\n    if (input1 << (0x20 - temp & 0xff) != 0) {\n      result = result | 1;\n    }\n    temp2 = input2 & 0x1fffff | 0x100000;\n    input1 = result | temp2 << (0x20 - temp & 0xff);\n    temp2 = (temp2 >> (temp & 0xff)) << 1;\n  }\n  result = (input2 & 0x80000000 | input1 >> 0x1d) + temp2 * 4 + (uint)(0x7fffffff < input1 * 8);\n  if (input1 * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080009fc": "calculate_modified_float_080009fc",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "result",
                "uVar2": "temp",
                "uVar3": "temp2",
                "in_r12": "temp3",
                "bVar4": "isZero",
                "bVar5": "lessThanThreshold"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a9c": {
            "entrypoint": "0x08000a9c",
            "current_name": "convert_negative_float_to_positive_08000a9c",
            "code": "\nvoid convertNegativeFloatToPositive_08000a9c(uint inputFloat)\n\n{\n  __addsf3(inputFloat ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000a9c": "convert_negative_float_to_positive_08000a9c",
                "param_1": "inputFloat"
            },
            "calling": [],
            "called": [
                "__addsf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa4": {
            "entrypoint": "0x08000aa4",
            "current_name": "calculate_float_08000aa4",
            "code": "\nuint calculate_float_08000aa4(uint input_value,uint bit_mask,undefined4 shift_amount,uint result)\n\n{\n  int upper_bits;\n  int upper_bits_shifted;\n  uint input_value_negated;\n  uint result_negated;\n  uint input_value_shifted;\n  uint incremented_shifted_value;\n  uint difference;\n  bool is_equal;\n  \n  input_value_negated = bit_mask ^ 0x80000000;\n  input_value_shifted = input_value << 1;\n  is_equal = input_value_shifted == 0;\n  if (!is_equal) {\n    result = bit_mask << 1;\n    is_equal = result == 0;\n  }\n  if (!is_equal) {\n    is_equal = input_value_shifted == result;\n  }\n  upper_bits = (int)input_value_shifted >> 0x18;\n  if (!is_equal) {\n    is_equal = upper_bits == -1;\n  }\n  if (!is_equal) {\n    is_equal = (int)result >> 0x18 == -1;\n  }\n  if (is_equal) {\n    upper_bits_shifted = (int)(bit_mask << 1) >> 0x18;\n    if (upper_bits == -1 || upper_bits_shifted == -1) {\n      input_value_shifted = input_value_negated;\n      if (upper_bits == -1) {\n        input_value_shifted = input_value;\n      }\n      if (upper_bits != -1 || upper_bits_shifted != -1) {\n        input_value_negated = input_value_shifted;\n      }\n      is_equal = (input_value_shifted & 0x7fffff) == 0;\n      if (is_equal) {\n        is_equal = (input_value_negated & 0x7fffff) == 0;\n      }\n      if (is_equal) {\n        is_equal = input_value_shifted == input_value_negated;\n      }\n      if (!is_equal) {\n        input_value_shifted = input_value_shifted | 0x400000;\n      }\n      return input_value_shifted;\n    }\n    if (((input_value ^ input_value_negated) & 0x7fffffff) != 0) {\n      if (input_value_shifted == 0) {\n        input_value = input_value_negated;\n      }\n      return input_value;\n    }\n    if (input_value != input_value_negated) {\n      return 0;\n    }\n    if ((input_value_shifted & 0xff000000) == 0) {\n      input_value_negated = input_value << 1;\n      if ((input_value & 0x80000000) != 0) {\n        input_value_negated = input_value_negated | 0x80000000;\n      }\n      return input_value_negated;\n    }\n    if (input_value_shifted < 0xfe000000) {\n      return input_value + 0x800000;\n    }\n    input_value = input_value & 0x80000000;\nLAB_08000bde:\n    return input_value | 0x7f800000;\n  }\n  input_value_shifted = input_value_shifted >> 0x18;\n  result = result >> 0x18;\n  difference = result - input_value_shifted;\n  is_equal = difference != 0;\n  incremented_shifted_value = input_value_shifted;\n  if (is_equal && input_value_shifted <= result) {\n    incremented_shifted_value = input_value_shifted + difference;\n  }\n  if (is_equal && input_value_shifted <= result) {\n    input_value_negated = input_value_negated ^ input_value;\n  }\n  if (is_equal && input_value_shifted <= result) {\n    input_value = input_value ^ input_value_negated;\n  }\n  if (is_equal && input_value_shifted <= result) {\n    input_value_negated = input_value_negated ^ input_value;\n  }\n  if (result < input_value_shifted) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return input_value;\n  }\n  input_value_shifted = input_value & 0xffffff | 0x800000;\n  if ((input_value & 0x80000000) != 0) {\n    input_value_shifted = -input_value_shifted;\n  }\n  result_negated = input_value_negated & 0xffffff | 0x800000;\n  if ((input_value_negated & 0x80000000) != 0) {\n    result_negated = -result_negated;\n  }\n  if (incremented_shifted_value == difference) {\n    result_negated = result_negated ^ 0x800000;\n    if (incremented_shifted_value == 0) {\n      input_value_shifted = input_value_shifted ^ 0x800000;\n      incremented_shifted_value = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  input_value_shifted = input_value_shifted + ((int)result_negated >> (difference & 0xff));\n  result_negated = result_negated << (0x20 - difference & 0xff);\n  input_value = input_value_shifted & 0x80000000;\n  if ((int)input_value_shifted < 0) {\n    is_equal = result_negated != 0;\n    result_negated = -result_negated;\n    input_value_shifted = -input_value_shifted - (uint)is_equal;\n  }\n  if (input_value_shifted < 0x800000) {\n    input_value_negated = result_negated & 0x80000000;\n    result_negated = result_negated << 1;\n    input_value_shifted = input_value_shifted * 2 + (uint)(input_value_negated != 0);\n    input_value_negated = incremented_shifted_value - 2;\n    if ((input_value_shifted & 0x800000) == 0) {\n      difference = LZCOUNT(input_value_shifted) - 8;\n      input_value_shifted = input_value_shifted << (difference & 0xff);\n      if ((int)input_value_negated < (int)difference) {\n        input_value_shifted = input_value_shifted >> (-(input_value_negated - difference) & 0xff);\n      }\n      else {\n        input_value_shifted = input_value_shifted + (input_value_negated - difference) * 0x800000;\n      }\n      return input_value_shifted | input_value;\n    }\n  }\n  else {\n    input_value_negated = incremented_shifted_value - 1;\n    if (0xffffff < input_value_shifted) {\n      input_value_negated = input_value_shifted & 1;\n      input_value_shifted = input_value_shifted >> 1;\n      result_negated = (uint)(input_value_negated != 0) << 0x1f | result_negated >> 1;\n      input_value_negated = incremented_shifted_value;\n      if (0xfd < incremented_shifted_value) goto LAB_08000bde;\n    }\n  }\n  input_value_shifted = input_value_shifted + input_value_negated * 0x800000 + (uint)(0x7fffffff < result_negated);\n  if (result_negated == 0x80000000) {\n    input_value_shifted = input_value_shifted & 0xfffffffe;\n  }\n  return input_value_shifted | input_value;\n}\n\n",
            "renaming": {
                "FUN_08000aa4": "calculate_float_08000aa4",
                "param_1": "input_value",
                "param_2": "bit_mask",
                "param_3": "shift_amount",
                "param_4": "result",
                "iVar1": "upper_bits",
                "iVar2": "upper_bits_shifted",
                "uVar3": "input_value_negated",
                "uVar4": "result_negated",
                "uVar5": "input_value_shifted",
                "uVar6": "incremented_shifted_value",
                "uVar7": "difference",
                "bVar8": "is_equal"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa8": {
            "entrypoint": "0x08000aa8",
            "current_name": "convert_float_to_int_08000aa8",
            "code": "\nuint convertFloatToInt_08000aa8(uint numFloat1,uint numFloat2,undefined4 flag,uint resultFlag)\n\n{\n  int numShift;\n  int tempVar;\n  uint num1;\n  uint num2;\n  uint tempNum;\n  uint difference;\n  bool isZero;\n  \n  num2 = numFloat1 << 1;\n  isZero = num2 == 0;\n  if (!isZero) {\n    resultFlag = numFloat2 << 1;\n    isZero = resultFlag == 0;\n  }\n  if (!isZero) {\n    isZero = num2 == resultFlag;\n  }\n  numShift = (int)num2 >> 0x18;\n  if (!isZero) {\n    isZero = numShift == -1;\n  }\n  if (!isZero) {\n    isZero = (int)resultFlag >> 0x18 == -1;\n  }\n  if (isZero) {\n    tempVar = (int)(numFloat2 << 1) >> 0x18;\n    if (numShift == -1 || tempVar == -1) {\n      num2 = numFloat2;\n      if (numShift == -1) {\n        num2 = numFloat1;\n      }\n      if (numShift != -1 || tempVar != -1) {\n        numFloat2 = num2;\n      }\n      isZero = (num2 & 0x7fffff) == 0;\n      if (isZero) {\n        isZero = (numFloat2 & 0x7fffff) == 0;\n      }\n      if (isZero) {\n        isZero = num2 == numFloat2;\n      }\n      if (!isZero) {\n        num2 = num2 | 0x400000;\n      }\n      return num2;\n    }\n    if (((numFloat1 ^ numFloat2) & 0x7fffffff) != 0) {\n      if (num2 == 0) {\n        numFloat1 = numFloat2;\n      }\n      return numFloat1;\n    }\n    if (numFloat1 != numFloat2) {\n      return 0;\n    }\n    if ((num2 & 0xff000000) == 0) {\n      num2 = numFloat1 << 1;\n      if ((numFloat1 & 0x80000000) != 0) {\n        num2 = num2 | 0x80000000;\n      }\n      return num2;\n    }\n    if (num2 < 0xfe000000) {\n      return numFloat1 + 0x800000;\n    }\n    numFloat1 = numFloat1 & 0x80000000;\nLAB_08000bde:\n    return numFloat1 | 0x7f800000;\n  }\n  num2 = num2 >> 0x18;\n  resultFlag = resultFlag >> 0x18;\n  difference = resultFlag - num2;\n  isZero = difference != 0;\n  tempNum = num2;\n  if (isZero && num2 <= resultFlag) {\n    tempNum = num2 + difference;\n  }\n  if (isZero && num2 <= resultFlag) {\n    numFloat2 = numFloat2 ^ numFloat1;\n  }\n  if (isZero && num2 <= resultFlag) {\n    numFloat1 = numFloat1 ^ numFloat2;\n  }\n  if (isZero && num2 <= resultFlag) {\n    numFloat2 = numFloat2 ^ numFloat1;\n  }\n  if (resultFlag < num2) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return numFloat1;\n  }\n  num2 = numFloat1 & 0xffffff | 0x800000;\n  if ((numFloat1 & 0x80000000) != 0) {\n    num2 = -num2;\n  }\n  num1 = numFloat2 & 0xffffff | 0x800000;\n  if ((numFloat2 & 0x80000000) != 0) {\n    num1 = -num1;\n  }\n  if (tempNum == difference) {\n    num1 = num1 ^ 0x800000;\n    if (tempNum == 0) {\n      num2 = num2 ^ 0x800000;\n      tempNum = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  num2 = num2 + ((int)num1 >> (difference & 0xff));\n  num1 = num1 << (0x20 - difference & 0xff);\n  numFloat1 = num2 & 0x80000000;\n  if ((int)num2 < 0) {\n    isZero = num1 != 0;\n    num1 = -num1;\n    num2 = -num2 - (uint)isZero;\n  }\n  if (num2 < 0x800000) {\n    difference = num1 & 0x80000000;\n    num1 = num1 << 1;\n    num2 = num2 * 2 + (uint)(difference != 0);\n    difference = tempNum - 2;\n    if ((num2 & 0x800000) == 0) {\n      tempNum = LZCOUNT(num2) - 8;\n      num2 = num2 << (tempNum & 0xff);\n      if ((int)difference < (int)tempNum) {\n        num2 = num2 >> (-(difference - tempNum) & 0xff);\n      }\n      else {\n        num2 = num2 + (difference - tempNum) * 0x800000;\n      }\n      return num2 | numFloat1;\n    }\n  }\n  else {\n    difference = tempNum - 1;\n    if (0xffffff < num2) {\n      difference = num2 & 1;\n      num2 = num2 >> 1;\n      num1 = (uint)(difference != 0) << 0x1f | num1 >> 1;\n      difference = tempNum;\n      if (0xfd < tempNum) goto LAB_08000bde;\n    }\n  }\n  num2 = num2 + difference * 0x800000 + (uint)(0x7fffffff < num1);\n  if (num1 == 0x80000000) {\n    num2 = num2 & 0xfffffffe;\n  }\n  return num2 | numFloat1;\n}\n\n",
            "renaming": {
                "FUN_08000aa8": "convert_float_to_int_08000aa8",
                "param_1": "numFloat1",
                "param_2": "numFloat2",
                "param_3": "flag",
                "param_4": "resultFlag",
                "iVar1": "numShift",
                "iVar2": "tempVar",
                "uVar3": "num1",
                "uVar4": "num2",
                "uVar5": "tempNum",
                "uVar6": "difference",
                "bVar7": "isZero"
            },
            "calling": [
                "__aeabi_frsub",
                "mpu6050_calibrate",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c08": {
            "entrypoint": "0x08000c08",
            "current_name": "calculate_checksum_08000c08",
            "code": "\nuint calculateChecksum_08000c08(uint input)\n\n{\n  uint leadingZeros;\n  uint shiftAmount;\n  int increment;\n  uint checkValue;\n  \n  if (input == 0) {\n    return 0;\n  }\n  leadingZeros = countLeadingZeros(input);\n  shiftAmount = leadingZeros - 8;\n  increment = shiftAmount * -0x800000 + 0x4a800000;\n  if (7 < leadingZeros) {\n    checkValue = 0 << (shiftAmount & 0xff);\n    leadingZeros = increment + (input << (shiftAmount & 0xff)) +\n            (0U >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < checkValue);\n    if (checkValue == 0x80000000) {\n      leadingZeros = leadingZeros & 0xfffffffe;\n    }\n    return leadingZeros;\n  }\n  shiftAmount = input << leadingZeros + 0x18;\n  leadingZeros = increment + ((input >> (0x20 - (leadingZeros + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n  if ((shiftAmount & 0x7fffffff) == 0) {\n    leadingZeros = leadingZeros & ~(shiftAmount >> 0x1f);\n  }\n  return leadingZeros;\n}\n\n",
            "renaming": {
                "FUN_08000c08": "calculate_checksum_08000c08",
                "param_1": "input",
                "uVar1": "leadingZeros",
                "uVar2": "shiftAmount",
                "iVar3": "increment",
                "uVar4": "checkValue",
                "LZCOUNT": "countLeadingZeros"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c10": {
            "entrypoint": "0x08000c10",
            "current_name": "count_on_bits_08000c10",
            "code": "\nuint count_on_bits_08000c10(uint input_num)\n\n{\n  uint count;\n  uint shift;\n  uint sign_bit;\n  int result;\n  \n  sign_bit = input_num & 0x80000000;\n  if ((int)sign_bit < 0) {\n    input_num = -input_num;\n  }\n  if (input_num == 0) {\n    return 0;\n  }\n  count = leading_zero_count(input_num);\n  shift = count - 8;\n  result = ((sign_bit | 0x4b000000) - 0x800000) + shift * -0x800000;\n  if (7 < count) {\n    count = 0 << (shift & 0xff);\n    sign_bit = result + (input_num << (shift & 0xff)) +\n            (0U >> (0x20 - shift & 0xff)) + (uint)(0x7fffffff < count);\n    if (count == 0x80000000) {\n      sign_bit = sign_bit & 0xfffffffe;\n    }\n    return sign_bit;\n  }\n  shift = input_num << count + 0x18;\n  sign_bit = result + ((input_num >> (0x20 - (count + 0x18) & 0xff)) - ((int)shift >> 0x1f));\n  if ((shift & 0x7fffffff) == 0) {\n    sign_bit = sign_bit & ~(shift >> 0x1f);\n  }\n  return sign_bit;\n}\n\n",
            "renaming": {
                "FUN_08000c10": "count_on_bits_08000c10",
                "param_1": "input_num",
                "uVar1": "count",
                "uVar2": "shift",
                "uVar3": "sign_bit",
                "iVar4": "result",
                "LZCOUNT": "leading_zero_count"
            },
            "calling": [
                "mpu6050_update",
                "mpu6050_calibrate",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c2c": {
            "entrypoint": "0x08000c2c",
            "current_name": "calculate_08000c2c",
            "code": "\nuint calculate_08000c2c(uint input1,uint input2)\n\n{\n  uint result1;\n  uint result2;\n  uint count;\n  uint shift;\n  int constant;\n  \n  if ((input1 | input2) == 0) {\n    return input1;\n  }\n  result1 = input1;\n  result2 = input2;\n  if (input2 == 0) {\n    result1 = 0;\n    result2 = input1;\n  }\n  constant = 0x5b000000;\n  if (input2 == 0) {\n    constant = 0x4b000000;\n  }\n  count = LZCOUNT(result2);\n  shift = count - 8;\n  constant = constant + -0x800000 + shift * -0x800000;\n  if (count < 8) {\n    shift = result2 << count + 0x18;\n    result2 = constant + ((result2 >> (0x20 - (count + 0x18) & 0xff)) - ((int)shift >> 0x1f));\n    if ((result1 | shift << 1) == 0) {\n      result2 = result2 & ~(shift >> 0x1f);\n    }\n    return result2;\n  }\n  count = result1 << (shift & 0xff);\n  result2 = constant + (result2 << (shift & 0xff)) +\n          (result1 >> (0x20 - shift & 0xff)) + (uint)(0x7fffffff < count);\n  if (count == 0x80000000) {\n    result2 = result2 & 0xfffffffe;\n  }\n  return result2;\n}\n\n",
            "renaming": {
                "FUN_08000c2c": "calculate_08000c2c",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "count",
                "uVar4": "shift",
                "iVar5": "constant"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c3c": {
            "entrypoint": "0x08000c3c",
            "current_name": "calculate_signed_multiply_add_08000c3c",
            "code": "\nuint calculate_signed_multiply_add_08000c3c(uint x,uint y)\n\n{\n  uint abs_x;\n  uint abs_y;\n  uint leading_zeros;\n  uint shift_amount;\n  uint sign_bit;\n  int result;\n  bool is_negative;\n  \n  if ((x | y) == 0) {\n    return x;\n  }\n  sign_bit = y & 0x80000000;\n  if ((int)sign_bit < 0) {\n    is_negative = x != 0;\n    x = -x;\n    y = -y - (uint)is_negative;\n  }\n  abs_y = x;\n  abs_x = y;\n  if (y == 0) {\n    abs_y = 0;\n    abs_x = x;\n  }\n  sign_bit = sign_bit | 0x5b000000;\n  if (y == 0) {\n    sign_bit = sign_bit + 0xf0000000;\n  }\n  leading_zeros = LZCOUNT(abs_x);\n  shift_amount = leading_zeros - 8;\n  result = (sign_bit - 0x800000) + shift_amount * -0x800000;\n  if (leading_zeros < 8) {\n    shift_amount = abs_x << leading_zeros + 0x18;\n    sign_bit = result + ((abs_x >> (0x20 - (leading_zeros + 0x18) & 0xff)) - ((int)shift_amount >> 0x1f));\n    if ((abs_y | shift_amount << 1) == 0) {\n      sign_bit = sign_bit & ~(shift_amount >> 0x1f);\n    }\n    return sign_bit;\n  }\n  leading_zeros = abs_y << (shift_amount & 0xff);\n  sign_bit = result + (abs_x << (shift_amount & 0xff)) +\n          (abs_y >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < leading_zeros);\n  if (leading_zeros == 0x80000000) {\n    sign_bit = sign_bit & 0xfffffffe;\n  }\n  return sign_bit;\n}\n\n",
            "renaming": {
                "FUN_08000c3c": "calculate_signed_multiply_add_08000c3c",
                "param_1": "x",
                "param_2": "y",
                "uVar1": "abs_x",
                "uVar2": "abs_y",
                "uVar3": "leading_zeros",
                "uVar4": "shift_amount",
                "uVar5": "sign_bit",
                "iVar6": "result",
                "bVar7": "is_negative"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cb8": {
            "entrypoint": "0x08000cb8",
            "current_name": "calculate_float_value_08000cb8",
            "code": "\nuint calculateFloatValue_08000cb8(uint value1,uint value2,undefined4 value3,uint value4)\n\n{\n  longlong longValue;\n  uint result;\n  uint shiftedValue1;\n  int sum;\n  int diff;\n  uint multipliedValue;\n  int remainingShift;\n  uint finalResult;\n  bool condition1;\n  bool condition2;\n  \n  shiftedValue1 = value1 >> 0x17 & 0xff;\n  condition1 = shiftedValue1 == 0;\n  if (!condition1) {\n    value4 = value2 >> 0x17 & 0xff;\n    condition1 = value4 == 0;\n  }\n  if (!condition1) {\n    condition1 = shiftedValue1 == 0xff;\n  }\n  if (!condition1) {\n    condition1 = value4 == 0xff;\n  }\n  if (condition1) {\n    value4 = value2 >> 0x17 & 0xff;\n    if (shiftedValue1 == 0xff || value4 == 0xff) {\n      condition1 = value1 == 0 || value1 == 0x80000000;\n      result = value2;\n      if (value1 != 0 && value1 != 0x80000000) {\n        condition1 = value2 == 0;\n        result = value1;\n      }\n      if (!condition1) {\n        condition1 = value2 == 0x80000000;\n      }\n      finalResult = result;\n      if (((condition1) || ((shiftedValue1 == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((value4 == 0xff && (finalResult = value2, (value2 & 0x7fffff) != 0)))) {\n        return finalResult | 0x7fc00000;\n      }\n      result = result ^ value2;\n      goto LAB_08000e08;\n    }\n    condition1 = (value1 & 0x7fffffff) == 0;\n    if (!condition1) {\n      condition1 = (value2 & 0x7fffffff) == 0;\n    }\n    if (condition1) {\n      return (value1 ^ value2) & 0x80000000;\n    }\n    condition1 = shiftedValue1 == 0;\n    result = value1 & 0x80000000;\n    while( true ) {\n      if (condition1) {\n        value1 = value1 << 1;\n        condition1 = (value1 & 0x800000) == 0;\n      }\n      if (!condition1) break;\n      shiftedValue1 = shiftedValue1 - 1;\n    }\n    value1 = value1 | result;\n    condition1 = value4 == 0;\n    result = value2 & 0x80000000;\n    while( true ) {\n      if (condition1) {\n        value2 = value2 << 1;\n        condition1 = (value2 & 0x800000) == 0;\n      }\n      if (!condition1) break;\n      value4 = value4 - 1;\n    }\n    value2 = value2 | result;\n  }\n  sum = shiftedValue1 + value4;\n  finalResult = value1 ^ value2;\n  shiftedValue1 = value1 << 9;\n  condition1 = shiftedValue1 == 0;\n  if (!condition1) {\n    value2 = value2 << 9;\n    condition1 = value2 == 0;\n  }\n  if (condition1) {\n    if (shiftedValue1 == 0) {\n      value2 = value2 << 9;\n    }\n    result = finalResult & 0x80000000 | value1 & 0x7fffff | value2 >> 9;\n    condition2 = SBORROW4(sum,0x7f);\n    diff = sum + -0x7f;\n    condition1 = diff == 0;\n    remainingShift = diff;\n    if (!condition1 && 0x7e < sum) {\n      condition2 = SBORROW4(0xff,diff);\n      remainingShift = 0xff - diff;\n      condition1 = diff == 0xff;\n    }\n    if (!condition1 && remainingShift < 0 == condition2) {\n      result = result | diff * 0x800000;\n    }\n    if (!condition1 && remainingShift < 0 == condition2) {\n      return result;\n    }\n    result = result | 0x800000;\n    multipliedValue = 0;\n    condition2 = SBORROW4(diff,1);\n    finalResult = sum - 0x80;\n    condition1 = finalResult == 0;\n    shiftedValue1 = finalResult;\n  }\n  else {\n    longValue = (ulonglong)(shiftedValue1 >> 5 | 0x8000000) * (ulonglong)(value2 >> 5 | 0x8000000);\n    multipliedValue = (uint)longValue;\n    result = (uint)((ulonglong)longValue >> 0x20);\n    condition1 = result < 0x800000;\n    if (condition1) {\n      result = result << 1;\n    }\n    if (condition1) {\n      result = result | multipliedValue >> 0x1f;\n      multipliedValue = multipliedValue << 1;\n    }\n    result = finalResult & 0x80000000 | result;\n    finalResult = (sum + -0x7f) - (uint)condition1;\n    condition2 = SBORROW4(finalResult,0xfd);\n    condition1 = finalResult == 0xfd;\n    shiftedValue1 = finalResult - 0xfd;\n    if (finalResult < 0xfe) {\n      result = result + finalResult * 0x800000 + (uint)(0x7fffffff < multipliedValue);\n      if (multipliedValue == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (condition1 || (int)shiftedValue1 < 0 != condition2) {\n    condition1 = (int)(finalResult + 0x19) < 0;\n    if (finalResult == 0xffffffe7 || condition1 != SCARRY4(finalResult,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (finalResult != 0xffffffe7 && condition1 == SCARRY4(finalResult,0x19)) {\n      shiftedValue1 = (result << 1) >> (-finalResult & 0xff);\n      finalResult = result << (finalResult + 0x20 & 0xff);\n      shiftedValue1 = ((uint)((result & 0x80000000) != 0) << 0x1f | shiftedValue1 >> 1) + (uint)((byte)shiftedValue1 & 1);\n      if ((multipliedValue | finalResult << 1) == 0) {\n        shiftedValue1 = shiftedValue1 & ~(finalResult >> 0x1f);\n      }\n      return shiftedValue1;\n    }\n    return result;\n  }\nLAB_08000e08:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000cb8": "calculate_float_value_08000cb8",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "lVar1": "longValue",
                "uVar2": "result",
                "uVar3": "shiftedValue1",
                "iVar4": "sum",
                "iVar5": "diff",
                "uVar6": "multipliedValue",
                "iVar7": "remainingShift",
                "uVar8": "finalResult",
                "bVar9": "condition1",
                "bVar10": "condition2"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e20": {
            "entrypoint": "0x08000e20",
            "current_name": "calculate_float_08000e20",
            "code": "\nuint calculateFloat_08000e20(uint value1,uint value2,undefined4 param3,uint param4)\n\n{\n  uint result1;\n  uint shift1;\n  int difference;\n  uint shift2;\n  int iVar5;\n  uint result2;\n  bool condition;\n  bool carry;\n  bool carry2;\n  \n  shift1 = value1 >> 0x17 & 0xff;\n  condition = shift1 == 0;\n  if (!condition) {\n    param4 = value2 >> 0x17 & 0xff;\n    condition = param4 == 0;\n  }\n  if (!condition) {\n    condition = shift1 == 0xff;\n  }\n  if (!condition) {\n    condition = param4 == 0xff;\n  }\n  if (condition) {\n    param4 = value2 >> 0x17 & 0xff;\n    result2 = value1;\n    if (shift1 == 0xff) {\n      if (((value1 & 0x7fffff) != 0) || (result2 = value2, param4 == 0xff)) {\nLAB_08000e16:\n        return result2 | 0x7fc00000;\n      }\n    }\n    else {\n      if (param4 == 0xff) {\n        result2 = value2;\n        if ((value2 & 0x7fffff) == 0) {\nLAB_08000dcc:\n          return (value1 ^ value2) & 0x80000000;\n        }\n        goto LAB_08000e16;\n      }\n      condition = (value1 & 0x7fffffff) == 0;\n      if (!condition) {\n        condition = (value2 & 0x7fffffff) == 0;\n      }\n      if (!condition) {\n        condition = shift1 == 0;\n        result2 = value1 & 0x80000000;\n        while( true ) {\n          if (condition) {\n            value1 = value1 << 1;\n            condition = (value1 & 0x800000) == 0;\n          }\n          if (!condition) break;\n          shift1 = shift1 - 1;\n        }\n        value1 = value1 | result2;\n        condition = param4 == 0;\n        result2 = value2 & 0x80000000;\n        while( true ) {\n          if (condition) {\n            value2 = value2 << 1;\n            condition = (value2 & 0x800000) == 0;\n          }\n          if (!condition) break;\n          param4 = param4 - 1;\n        }\n        value2 = value2 | result2;\n        goto LAB_08000e38;\n      }\n      if ((value1 & 0x7fffffff) == 0) {\n        if ((value2 & 0x7fffffff) != 0) goto LAB_08000dcc;\n        goto LAB_08000e16;\n      }\n    }\n    value1 = value1 ^ value2;\n  }\n  else {\nLAB_08000e38:\n    difference = shift1 - param4;\n    if (value2 << 9 == 0) {\n      value1 = (value1 ^ value2) & 0x80000000 | value1 & 0x7fffff;\n      carry2 = SCARRY4(difference,0x7f);\n      iVar5 = difference + 0x7f;\n      condition = iVar5 < 0;\n      carry = iVar5 == 0;\n      if (!carry && condition == carry2) {\n        carry2 = SBORROW4(0xff,iVar5);\n        condition = 0xff - iVar5 < 0;\n        carry = iVar5 == 0xff;\n      }\n      if (!carry && condition == carry2) {\n        value1 = value1 | iVar5 * 0x800000;\n      }\n      if (!carry && condition == carry2) {\n        return value1;\n      }\n      value1 = value1 | 0x800000;\n      shift1 = 0;\n      carry = SBORROW4(iVar5,1);\n      shift2 = difference + 0x7e;\n      condition = shift2 == 0;\n      result2 = shift2;\n    }\n    else {\n      result1 = (value2 << 9) >> 4 | 0x10000000;\n      shift1 = (value1 << 9) >> 4 | 0x10000000;\n      value1 = (value1 ^ value2) & 0x80000000;\n      condition = result1 <= shift1;\n      if (!condition) {\n        shift1 = shift1 << 1;\n      }\n      shift2 = difference + 0x7d + (uint)condition;\n      result2 = 0x800000;\n      do {\n        if (result1 <= shift1) {\n          shift1 = shift1 - result1;\n          value1 = value1 | result2;\n        }\n        condition = result1 >> 1 <= shift1;\n        if (condition) {\n          shift1 = shift1 - (result1 >> 1);\n        }\n        if (condition) {\n          value1 = value1 | result2 >> 1;\n        }\n        condition = result1 >> 2 <= shift1;\n        if (condition) {\n          shift1 = shift1 - (result1 >> 2);\n        }\n        if (condition) {\n          value1 = value1 | result2 >> 2;\n        }\n        condition = result1 >> 3 <= shift1;\n        if (condition) {\n          shift1 = shift1 - (result1 >> 3);\n        }\n        if (condition) {\n          value1 = value1 | result2 >> 3;\n        }\n        shift1 = shift1 * 0x10;\n        condition = shift1 == 0;\n        if (!condition) {\n          result2 = result2 >> 4;\n          condition = result2 == 0;\n        }\n      } while (!condition);\n      carry = SBORROW4(shift2,0xfd);\n      condition = shift2 == 0xfd;\n      result2 = shift2 - 0xfd;\n      if (shift2 < 0xfe) {\n        value1 = value1 + shift2 * 0x800000 + (uint)(result1 <= shift1);\n        if (shift1 - result1 == 0) {\n          value1 = value1 & 0xfffffffe;\n        }\n        return value1;\n      }\n    }\n    if (condition || (int)result2 < 0 != carry) {\n      condition = (int)(shift2 + 0x19) < 0;\n      if (shift2 == 0xffffffe7 || condition != SCARRY4(shift2,0x19)) {\n        value1 = value1 & 0x80000000;\n      }\n      if (shift2 == 0xffffffe7 || condition != SCARRY4(shift2,0x19)) {\n        return value1;\n      }\n      result2 = (value1 << 1) >> (-shift2 & 0xff);\n      shift2 = value1 << (shift2 + 0x20 & 0xff);\n      result2 = ((uint)((value1 & 0x80000000) != 0) << 0x1f | result2 >> 1) + (uint)((byte)result2 & 1);\n      if ((shift1 | shift2 << 1) == 0) {\n        result2 = result2 & ~(shift2 >> 0x1f);\n      }\n      return result2;\n    }\n  }\n  return value1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000e20": "calculate_float_08000e20",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "result1",
                "uVar2": "shift1",
                "iVar3": "difference",
                "uVar4": "shift2",
                "uVar6": "result2",
                "bVar7": "condition",
                "bVar8": "carry",
                "bVar9": "carry2"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_calibrate"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f58": {
            "entrypoint": "0x08000f58",
            "current_name": "calculate_result_08000f58",
            "code": "\nuint calculate_result_08000f58(uint num1,uint num2)\n\n{\n  bool is_negative;\n  uint doubled_num1;\n  uint doubled_num2;\n  uint combined_nums;\n  bool is_zero;\n  \n  doubled_num1 = num1 * 2;\n  doubled_num2 = num2 * 2;\n  if (((int)doubled_num1 >> 0x18 == -1 || (int)doubled_num2 >> 0x18 == -1) &&\n     ((((int)doubled_num1 >> 0x18 == -1 && ((num1 & 0x7fffff) != 0)) ||\n      (((int)doubled_num2 >> 0x18 == -1 && ((num2 & 0x7fffff) != 0)))))) {\n    return 0xffffffff;\n  }\n  combined_nums = doubled_num1 | num2 & 0x7fffffff;\n  is_zero = combined_nums == 0;\n  if (!is_zero) {\n    combined_nums = num1 ^ num2;\n    is_zero = combined_nums == 0;\n  }\n  is_negative = -1 < (int)combined_nums;\n  if (is_negative) {\n    num1 = doubled_num1 + num2 * -2;\n    is_zero = num1 == 0;\n  }\n  if ((is_negative && doubled_num2 <= doubled_num1) && !is_zero) {\n    num1 = (int)num2 >> 0x1f;\n  }\n  if (!is_negative || doubled_num2 > doubled_num1) {\n    num1 = ~((int)num2 >> 0x1f);\n  }\n  if (!is_zero) {\n    num1 = num1 | 1;\n  }\n  return num1;\n}\n\n",
            "renaming": {
                "FUN_08000f58": "calculate_result_08000f58",
                "param_1": "num1",
                "param_2": "num2",
                "uVar2": "doubled_num1",
                "uVar3": "doubled_num2",
                "uVar4": "combined_nums",
                "bVar1": "is_negative",
                "bVar5": "is_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f60": {
            "entrypoint": "0x08000f60",
            "current_name": "check_overflow_and_sign_08000f60",
            "code": "\nuint check_overflow_and_sign_08000f60(uint value_1,uint value_2)\n\n{\n  bool is_overflow;\n  uint result_1;\n  uint result_2;\n  uint combined_result;\n  bool is_result_zero;\n  \n  result_1 = value_1 * 2;\n  result_2 = value_2 * 2;\n  if (((int)result_1 >> 0x18 == -1 || (int)result_2 >> 0x18 == -1) &&\n     ((((int)result_1 >> 0x18 == -1 && ((value_1 & 0x7fffff) != 0)) ||\n      (((int)result_2 >> 0x18 == -1 && ((value_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined_result = result_1 | value_2 & 0x7fffffff;\n  is_result_zero = combined_result == 0;\n  if (!is_result_zero) {\n    combined_result = value_1 ^ value_2;\n    is_result_zero = combined_result == 0;\n  }\n  is_overflow = -1 < (int)combined_result;\n  if (is_overflow) {\n    value_1 = result_1 + value_2 * -2;\n    is_result_zero = value_1 == 0;\n  }\n  if ((is_overflow && result_2 <= result_1) && !is_result_zero) {\n    value_1 = (int)value_2 >> 0x1f;\n  }\n  if (!is_overflow || result_2 > result_1) {\n    value_1 = ~((int)value_2 >> 0x1f);\n  }\n  if (!is_result_zero) {\n    value_1 = value_1 | 1;\n  }\n  return value_1;\n}\n\n",
            "renaming": {
                "FUN_08000f60": "check_overflow_and_sign_08000f60",
                "param_1": "value_1",
                "param_2": "value_2",
                "bVar1": "is_overflow",
                "uVar2": "result_1",
                "uVar3": "result_2",
                "uVar4": "combined_result",
                "bVar5": "is_result_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f68": {
            "entrypoint": "0x08000f68",
            "current_name": "check_overflow_and_set_08000f68",
            "code": "\nuint check_overflow_and_set_08000f68(uint input1,uint input2)\n\n{\n  bool is_negative;\n  uint input1_times_2;\n  uint input2_times_2;\n  uint combined_result;\n  bool is_zero;\n  \n  input1_times_2 = input1 * 2;\n  input2_times_2 = input2 * 2;\n  if (((int)input1_times_2 >> 0x18 == -1 || (int)input2_times_2 >> 0x18 == -1) &&\n     ((((int)input1_times_2 >> 0x18 == -1 && ((input1 & 0x7fffff) != 0)) ||\n      (((int)input2_times_2 >> 0x18 == -1 && ((input2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined_result = input1_times_2 | input2 & 0x7fffffff;\n  is_zero = combined_result == 0;\n  if (!is_zero) {\n    combined_result = input1 ^ input2;\n    is_zero = combined_result == 0;\n  }\n  is_negative = -1 < (int)combined_result;\n  if (is_negative) {\n    input1 = input1_times_2 + input2 * -2;\n    is_zero = input1 == 0;\n  }\n  if ((is_negative && input2_times_2 <= input1_times_2) && !is_zero) {\n    input1 = (int)input2 >> 0x1f;\n  }\n  if (!is_negative || input2_times_2 > input1_times_2) {\n    input1 = ~((int)input2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input1 = input1 | 1;\n  }\n  return input1;\n}\n\n",
            "renaming": {
                "FUN_08000f68": "check_overflow_and_set_08000f68",
                "param_1": "input1",
                "param_2": "input2",
                "uVar2": "input1_times_2",
                "uVar3": "input2_times_2",
                "uVar4": "combined_result",
                "bVar1": "is_negative",
                "bVar5": "is_zero"
            },
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fc8": {
            "entrypoint": "0x08000fc8",
            "current_name": "compare_floats_08000fc8",
            "code": "\nvoid compareFloats_08000fc8(undefined4 num1,undefined4 num2)\n\n{\n  __aeabi_cfcmpeq(num2,num1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fc8": "compare_floats_08000fc8",
                "param_1": "num1",
                "param_2": "num2"
            },
            "calling": [
                "__aeabi_fcmpgt",
                "__aeabi_fcmpge"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fd0": {
            "entrypoint": "0x08000fd0",
            "current_name": "concatenate_values_08000fd0",
            "code": "\nundefined8 concatenateValues_08000fd0(undefined4 firstValue,undefined4 secondValue)\n\n{\n  __cmpsf2();\n  return CONCAT44(secondValue,firstValue);\n}\n\n",
            "renaming": {
                "FUN_08000fd0": "concatenate_values_08000fd0",
                "param_1": "firstValue",
                "param_2": "secondValue"
            },
            "calling": [
                "__aeabi_fcmplt",
                "__aeabi_cfrcmple",
                "__aeabi_fcmple",
                "__aeabi_fcmpeq"
            ],
            "called": [
                "__cmpsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fe0": {
            "entrypoint": "0x08000fe0",
            "current_name": "check_condition_08000fe0",
            "code": "\nbool check_condition_08000fe0(void)\n\n{\n  char is_not_zero;\n  \n  __aeabi_cfcmpeq();\n  return is_not_zero != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000fe0": "check_condition_08000fe0",
                "in_ZR": "is_not_zero"
            },
            "calling": [],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ff4": {
            "entrypoint": "0x08000ff4",
            "current_name": "is_cy_null_08000ff4",
            "code": "\nbool is_CY_null_08000ff4(void)\n\n{\n  char input_char;\n  \n  __aeabi_cfcmpeq();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000ff4": "is_cy_null_08000ff4",
                "in_CY": "input_char"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001008": {
            "entrypoint": "0x08001008",
            "current_name": "compare_floats_08001008",
            "code": "\nbool compareFloats_08001008(void)\n\n{\n  undefined isZero;\n  undefined isCarry;\n  \n  __aeabi_cfcmpeq();\n  return !(bool)isCarry || (bool)isZero;\n}\n\n",
            "renaming": {
                "FUN_08001008": "compare_floats_08001008",
                "in_ZR": "isZero",
                "in_CY": "isCarry"
            },
            "calling": [],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800101c": {
            "entrypoint": "0x0800101c",
            "current_name": "check_conditions_0800101c",
            "code": "\nbool check_conditions_0800101c(void)\n\n{\n  undefined zero_flag;\n  undefined carry_flag;\n  \n  __aeabi_cfrcmple();\n  return !(bool)carry_flag || (bool)zero_flag;\n}\n\n",
            "renaming": {
                "FUN_0800101c": "check_conditions_0800101c",
                "in_ZR": "zero_flag",
                "in_CY": "carry_flag"
            },
            "calling": [],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001030": {
            "entrypoint": "0x08001030",
            "current_name": "check_null_termination_08001030",
            "code": "\nbool check_null_termination_08001030(void)\n\n{\n  char input_character;\n  \n  __aeabi_cfrcmple();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001030": "check_null_termination_08001030",
                "in_CY": "input_character"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001044": {
            "entrypoint": "0x08001044",
            "current_name": "check_number_validity_08001044",
            "code": "\nuint check_number_validity_08001044(uint number)\n\n{\n  uint shift_amount;\n  \n  if (((number & 0x80000000) != 0) || (number << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shift_amount = 0x9e - ((number << 1) >> 0x18);\n  if (-1 < (int)shift_amount) {\n    return (number << 8 | 0x80000000) >> (shift_amount & 0xff);\n  }\n  if ((shift_amount == 0xffffff9f) && ((number & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08001044": "check_number_validity_08001044",
                "param_1": "number",
                "uVar1": "shift_amount"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001084": {
            "entrypoint": "0x08001084",
            "current_name": "copy_memory_08001084",
            "code": "\nvoid * copyMemory_08001084(void *destination,void *source,size_t size)\n\n{\n  undefined *destPtr;\n  undefined4 *destPtrAligned;\n  undefined4 *destPtrAligned;\n  undefined *tempDestPtr;\n  undefined4 *srcPtrAligned;\n  undefined *tempSrcPtr;\n  uint remainingSize;\n  uint alignment;\n  bool isLooping;\n  \n  destPtrAligned = (undefined4 *)destination;\n  if ((((uint)source | (uint)destination) & 3) != 0) {\n    if (size < 8) {\n      alignment = size - 4;\n      destPtr = (undefined *)destination;\n      if (3 < size) {\n        do {\n          tempSrcPtr = (undefined *)source;\n          tempDestPtr = destPtr;\n          isLooping = alignment != 0;\n          alignment = alignment - 1;\n          *tempDestPtr = *tempSrcPtr;\n          destPtr = tempDestPtr + 1;\n          source = tempSrcPtr + 1;\n        } while (isLooping);\n        tempDestPtr[1] = tempSrcPtr[1];\n        tempDestPtr[2] = tempSrcPtr[2];\n        tempDestPtr[3] = tempSrcPtr[3];\n        return destination;\n      }\n      goto LAB_08001108;\n    }\n    if ((((uint)source & 3) != 0) && (((uint)destination & 3) != 0)) {\n      alignment = 4 - ((uint)destination & 3);\n      size = size - alignment;\n      destPtrAligned = (undefined4 *)destination;\n      srcPtrAligned = (undefined4 *)source;\n                    /* WARNING: Load size is inaccurate */\n      if (((uint)destination & 1) != 0) {\n        srcPtrAligned = (undefined4 *)((int)source + 1);\n        destPtrAligned = (undefined4 *)((int)destination + 1);\n        *(undefined *)destination = *source;\n      }\n      destPtrAligned = destPtrAligned;\n      source = srcPtrAligned;\n      if ((alignment & 2) != 0) {\n        source = (void *)((int)srcPtrAligned + 2);\n        destPtrAligned = (undefined4 *)((int)destPtrAligned + 2);\n        *(undefined2 *)destPtrAligned = *(undefined2 *)srcPtrAligned;\n      }\n    }\n  }\n  while (0x3f < size) {\n                    /* WARNING: Load size is inaccurate */\n    *destPtrAligned = *source;\n    destPtrAligned[1] = *(undefined4 *)((int)source + 4);\n    destPtrAligned[2] = *(undefined4 *)((int)source + 8);\n    destPtrAligned[3] = *(undefined4 *)((int)source + 0xc);\n    destPtrAligned[4] = *(undefined4 *)((int)source + 0x10);\n    destPtrAligned[5] = *(undefined4 *)((int)source + 0x14);\n    destPtrAligned[6] = *(undefined4 *)((int)source + 0x18);\n    destPtrAligned[7] = *(undefined4 *)((int)source + 0x1c);\n    destPtrAligned[8] = *(undefined4 *)((int)source + 0x20);\n    destPtrAligned[9] = *(undefined4 *)((int)source + 0x24);\n    destPtrAligned[10] = *(undefined4 *)((int)source + 0x28);\n    destPtrAligned[0xb] = *(undefined4 *)((int)source + 0x2c);\n    destPtrAligned[0xc] = *(undefined4 *)((int)source + 0x30);\n    destPtrAligned[0xd] = *(undefined4 *)((int)source + 0x34);\n    destPtrAligned[0xe] = *(undefined4 *)((int)source + 0x38);\n    destPtrAligned[0xf] = *(undefined4 *)((int)source + 0x3c);\n    destPtrAligned = destPtrAligned + 0x10;\n    source = (undefined4 *)((int)source + 0x40);\n    size = size - 0x40;\n  }\n  remainingSize = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n                    /* WARNING: Load size is inaccurate */\n      *destPtrAligned = *source;\n      destPtrAligned[1] = *(undefined4 *)((int)source + 4);\n      destPtrAligned[2] = *(undefined4 *)((int)source + 8);\n      destPtrAligned[3] = *(undefined4 *)((int)source + 0xc);\n      destPtrAligned = destPtrAligned + 4;\n      source = (void *)((int)source + 0x10);\n      isLooping = 0xf < remainingSize;\n      remainingSize = remainingSize - 0x10;\n    } while (isLooping);\n  }\n  alignment = remainingSize + 0xc;\n  srcPtrAligned = destPtrAligned;\n  destPtrAligned = (undefined4 *)source;\n  if (0xfffffff3 < remainingSize) {\n    do {\n      source = destPtrAligned + 1;\n      *srcPtrAligned = *destPtrAligned;\n      isLooping = 3 < alignment;\n      alignment = alignment - 4;\n      destPtrAligned = srcPtrAligned + 1;\n      srcPtrAligned = srcPtrAligned + 1;\n      destPtrAligned = (undefined4 *)source;\n    } while (isLooping);\n  }\nLAB_08001108:\n  if (alignment + 4 != 0) {\n    destPtrAligned = destPtrAligned;\n    srcPtrAligned = (undefined4 *)source;\n                    /* WARNING: Load size is inaccurate */\n    if ((alignment & 1) != 0) {\n      srcPtrAligned = (undefined4 *)((int)source + 1);\n      destPtrAligned = (undefined4 *)((int)destPtrAligned + 1);\n      *(undefined *)destPtrAligned = *source;\n    }\n    if ((alignment + 4 & 2) != 0) {\n      *(undefined2 *)destPtrAligned = *(undefined2 *)srcPtrAligned;\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08001084": "copy_memory_08001084",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "puVar1": "destPtr",
                "puVar2": "destPtrAligned",
                "puVar3": "destPtrAligned",
                "puVar4": "tempDestPtr",
                "puVar5": "srcPtrAligned",
                "puVar6": "tempSrcPtr",
                "uVar7": "remainingSize",
                "uVar8": "alignment",
                "bVar9": "isLooping"
            },
            "calling": [
                "__ssprint_r",
                "_dtoa_r",
                "__multadd"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001170": {
            "entrypoint": "0x08001170",
            "current_name": "check_parameters_validity_08001170",
            "code": "\nundefined4 checkParametersValidity_08001170(uint input1,int input2,uint input3,int input4)\n\n{\n  if ((((input2 << 1) >> 0x15 != -1) || ((input1 | input2 << 0xc) == 0)) &&\n     (((input4 << 1) >> 0x15 != -1 || ((input3 | input4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08001170": "check_parameters_validity_08001170",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800119c": {
            "entrypoint": "0x0800119c",
            "current_name": "apply_transformation_0800119c",
            "code": "\nuint applyTransformation_0800119c(uint inputValue,uint shiftValue)\n\n{\n  uint shiftedValue;\n  int offset;\n  uint adjustedShift;\n  \n  offset = shiftValue * 2 + 0x200000;\n  if (shiftValue * 2 < 0xffe00000) {\n    if (-1 < offset) {\n      return 0;\n    }\n    shiftedValue = offset >> 0x15;\n    adjustedShift = -shiftedValue - 0x3e1;\n    if (shiftedValue < 0xfffffc20 && adjustedShift != 0) {\n      shiftedValue = (shiftValue << 0xb | 0x80000000 | inputValue >> 0x15) >> (adjustedShift & 0xff);\n      if ((shiftValue & 0x80000000) != 0) {\n        shiftedValue = -shiftedValue;\n      }\n      return shiftedValue;\n    }\n  }\n  else if ((inputValue | shiftValue << 0xc) != 0) {\n    return 0;\n  }\n  shiftValue = shiftValue & 0x80000000;\n  if (shiftValue == 0) {\n    shiftValue = 0x7fffffff;\n  }\n  return shiftValue;\n}\n\n",
            "renaming": {
                "FUN_0800119c": "apply_transformation_0800119c",
                "param_1": "inputValue",
                "param_2": "shiftValue",
                "uVar1": "shiftedValue",
                "iVar2": "offset",
                "uVar3": "adjustedShift"
            },
            "calling": [
                "_svfprintf_r",
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011ec": {
            "entrypoint": "0x080011ec",
            "current_name": "perform_division_080011ec",
            "code": "\nvoid performDivision_080011ec(int dividend,int divisor,int remainder,int isDivisible)\n\n{\n  if ((isDivisible == 0) && (remainder == 0)) {\n    if (divisor != 0 || dividend != 0) {\n      divisor = -1;\n      dividend = -1;\n    }\n    __aeabi_idiv0(dividend,divisor);\n    return;\n  }\n  __udivmoddi4();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080011ec": "perform_division_080011ec",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "remainder",
                "param_4": "isDivisible"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__udivmoddi4",
                "__aeabi_idiv0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800121c": {
            "entrypoint": "0x0800121c",
            "current_name": "calculate_quotient_and_remainder_0800121c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080014b2) */\n\nundefined8 calculateQuotientAndRemainder_0800121c(uint dividend,uint dividend_high,uint divisor,uint divisor_high,uint *quotientAndRemainder)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  ulonglong temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  int shiftAmount;\n  uint quotientAndRemainder_low;\n  uint remainder_high;\n  uint remainder_low;\n  uint *puVar9;\n  uint temp5;\n  uint mask;\n  uint temp6;\n  bool carryFlag;\n  undefined8 result;\n  \n  if (divisor_high == 0) {\n    if (dividend_high < divisor) {\n      shiftAmount = LZCOUNT(divisor);\n      remainder_high = divisor;\n      if (shiftAmount != 0) {\n        remainder_high = divisor << shiftAmount;\n        dividend_high = dividend >> (0x20U - shiftAmount & 0xff) | dividend_high << shiftAmount;\n        dividend = dividend << shiftAmount;\n      }\n      mask = remainder_high >> 0x10;\n      remainder_low = dividend_high / mask;\n      temp5 = remainder_low * (remainder_high & 0xffff);\n      quotientAndRemainder_low = dividend >> 0x10 | (dividend_high - mask * remainder_low) * 0x10000;\n      temp3 = remainder_low;\n      if (quotientAndRemainder_low <= temp5 && temp5 - quotientAndRemainder_low != 0) {\n        carryFlag = CARRY4(remainder_high,quotientAndRemainder_low);\n        quotientAndRemainder_low = remainder_high + quotientAndRemainder_low;\n        temp3 = remainder_low - 1;\n        if ((carryFlag == false) && (quotientAndRemainder_low <= temp5 && temp5 - quotientAndRemainder_low != 0)) {\n          temp3 = remainder_low - 2;\n          quotientAndRemainder_low = quotientAndRemainder_low + remainder_high;\n        }\n      }\n      temp2 = (quotientAndRemainder_low - temp5) / mask;\n      temp4 = temp2 * (remainder_high & 0xffff);\n      remainder_low = dividend & 0xffff | ((quotientAndRemainder_low - temp5) - mask * temp2) * 0x10000;\n      quotientAndRemainder_low = temp2;\n      if (remainder_low <= temp4 && temp4 - remainder_low != 0) {\n        carryFlag = CARRY4(remainder_high,remainder_low);\n        remainder_low = remainder_high + remainder_low;\n        quotientAndRemainder_low = temp2 - 1;\n        if ((carryFlag == false) && (remainder_low <= temp4 && temp4 - remainder_low != 0)) {\n          quotientAndRemainder_low = temp2 - 2;\n          remainder_low = remainder_low + remainder_high;\n        }\n      }\n      quotientAndRemainder_low = quotientAndRemainder_low | temp3 << 0x10;\n      puVar9 = (uint *)0x0;\n      remainder_low = remainder_low - temp4;\n    }\n    else {\n      if (divisor == 0) {\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x8001302);\n        result = (*UNRECOVERED_JUMPTABLE)();\n        return result;\n      }\n      shiftAmount = LZCOUNT(divisor);\n      if (shiftAmount == 0) {\n        puVar9 = (uint *)0x1;\n        dividend_high = dividend_high - divisor;\n        mask = divisor >> 0x10;\n        temp2 = divisor & 0xffff;\n        remainder_high = divisor;\n      }\n      else {\n        remainder_high = divisor << shiftAmount;\n        quotientAndRemainder_low = dividend_high >> (0x20U - shiftAmount & 0xff);\n        mask = remainder_high >> 0x10;\n        temp5 = quotientAndRemainder_low / mask;\n        temp2 = remainder_high & 0xffff;\n        temp4 = temp5 * temp2;\n        remainder_low = dividend >> (0x20U - shiftAmount & 0xff) | dividend_high << shiftAmount;\n        temp3 = remainder_low >> 0x10 | (quotientAndRemainder_low - mask * temp5) * 0x10000;\n        dividend = dividend << shiftAmount;\n        quotientAndRemainder_low = temp5;\n        if (temp3 <= temp4 && temp4 - temp3 != 0) {\n          carryFlag = CARRY4(remainder_high,temp3);\n          temp3 = remainder_high + temp3;\n          quotientAndRemainder_low = temp5 - 1;\n          if ((carryFlag == false) && (temp3 <= temp4 && temp4 - temp3 != 0)) {\n            quotientAndRemainder_low = temp5 - 2;\n            temp3 = temp3 + remainder_high;\n          }\n        }\n        temp5 = (temp3 - temp4) / mask;\n        temp6 = temp5 * temp2;\n        dividend_high = remainder_low & 0xffff | ((temp3 - temp4) - mask * temp5) * 0x10000;\n        temp3 = temp5;\n        if (dividend_high <= temp6 && temp6 - dividend_high != 0) {\n          carryFlag = CARRY4(remainder_high,dividend_high);\n          dividend_high = remainder_high + dividend_high;\n          temp3 = temp5 - 1;\n          if ((carryFlag == false) && (dividend_high <= temp6 && temp6 - dividend_high != 0)) {\n            temp3 = temp5 - 2;\n            dividend_high = dividend_high + remainder_high;\n          }\n        }\n        dividend_high = dividend_high - temp6;\n        puVar9 = (uint *)(temp3 | quotientAndRemainder_low << 0x10);\n      }\n      temp5 = dividend_high / mask;\n      quotientAndRemainder_low = temp2 * temp5;\n      remainder_low = dividend >> 0x10 | (dividend_high - mask * temp5) * 0x10000;\n      temp3 = temp5;\n      if (remainder_low <= quotientAndRemainder_low && quotientAndRemainder_low - remainder_low != 0) {\n        carryFlag = CARRY4(remainder_high,remainder_low);\n        remainder_low = remainder_high + remainder_low;\n        temp3 = temp5 - 1;\n        if ((carryFlag == false) && (remainder_low <= quotientAndRemainder_low && quotientAndRemainder_low - remainder_low != 0)) {\n          temp3 = temp5 - 2;\n          remainder_low = remainder_low + remainder_high;\n        }\n      }\n      temp5 = (remainder_low - quotientAndRemainder_low) / mask;\n      temp2 = temp2 * temp5;\n      remainder_low = dividend & 0xffff | ((remainder_low - quotientAndRemainder_low) - mask * temp5) * 0x10000;\n      quotientAndRemainder_low = temp5;\n      if (remainder_low <= temp2 && temp2 - remainder_low != 0) {\n        carryFlag = CARRY4(remainder_high,remainder_low);\n        remainder_low = remainder_high + remainder_low;\n        quotientAndRemainder_low = temp5 - 1;\n        if ((carryFlag == false) && (remainder_low <= temp2 && temp2 - remainder_low != 0)) {\n          quotientAndRemainder_low = temp5 - 2;\n          remainder_low = remainder_low + remainder_high;\n        }\n      }\n      remainder_low = remainder_low - temp2;\n      quotientAndRemainder_low = quotientAndRemainder_low | temp3 << 0x10;\n    }\n    if (quotientAndRemainder != (uint *)0x0) {\n      *quotientAndRemainder = remainder_low >> LZCOUNT(divisor);\n      quotientAndRemainder[1] = 0;\n    }\n  }\n  else {\n    puVar9 = quotientAndRemainder;\n    if (dividend_high < divisor_high) {\n      if (quotientAndRemainder != (uint *)0x0) {\n        *quotientAndRemainder = dividend;\n        quotientAndRemainder[1] = dividend_high;\n        return 0;\n      }\n      quotientAndRemainder_low = 0;\n    }\n    else {\n      shiftAmount = LZCOUNT(divisor_high);\n      if (shiftAmount == 0) {\n        if ((divisor_high < dividend_high) || (divisor <= dividend)) {\n          carryFlag = dividend < divisor;\n          dividend = dividend - divisor;\n          dividend_high = (dividend_high - divisor_high) - (uint)carryFlag;\n          quotientAndRemainder_low = 1;\n        }\n        else {\n          quotientAndRemainder_low = 0;\n        }\n        puVar9 = (uint *)0x0;\n        if (quotientAndRemainder != (uint *)0x0) {\n          *quotientAndRemainder = dividend;\n          quotientAndRemainder[1] = dividend_high;\n        }\n      }\n      else {\n        remainder_low = 0x20 - shiftAmount;\n        temp2 = divisor >> (remainder_low & 0xff) | divisor_high << shiftAmount;\n        remainder_high = dividend_high >> (remainder_low & 0xff);\n        temp4 = temp2 >> 0x10;\n        temp5 = remainder_high / temp4;\n        mask = temp5 * (temp2 & 0xffff);\n        quotientAndRemainder_low = dividend_high << shiftAmount | dividend >> (remainder_low & 0xff);\n        temp3 = quotientAndRemainder_low >> 0x10 | (remainder_high - temp4 * temp5) * 0x10000;\n        dividend = dividend << shiftAmount;\n        remainder_high = temp5;\n        if (temp3 <= mask && mask - temp3 != 0) {\n          carryFlag = CARRY4(temp2,temp3);\n          temp3 = temp2 + temp3;\n          remainder_high = temp5 - 1;\n          if ((carryFlag == false) && (temp3 <= mask && mask - temp3 != 0)) {\n            remainder_high = temp5 - 2;\n            temp3 = temp3 + temp2;\n          }\n        }\n        temp5 = (temp3 - mask) / temp4;\n        temp6 = temp5 * (temp2 & 0xffff);\n        temp3 = quotientAndRemainder_low & 0xffff | ((temp3 - mask) - temp4 * temp5) * 0x10000;\n        quotientAndRemainder_low = temp5;\n        if (temp3 <= temp6 && temp6 - temp3 != 0) {\n          carryFlag = CARRY4(temp2,temp3);\n          temp3 = temp2 + temp3;\n          quotientAndRemainder_low = temp5 - 1;\n          if ((carryFlag == false) && (temp3 <= temp6 && temp6 - temp3 != 0)) {\n            quotientAndRemainder_low = temp5 - 2;\n            temp3 = temp3 + temp2;\n          }\n        }\n        quotientAndRemainder_low = quotientAndRemainder_low | remainder_high << 0x10;\n        temp1 = (ulonglong)quotientAndRemainder_low * (ulonglong)(divisor << shiftAmount);\n        if (CONCAT44(temp3 - temp6,dividend) < temp1) {\n          quotientAndRemainder_low = quotientAndRemainder_low - 1;\n          temp1 = temp1 - CONCAT44(temp2,divisor << shiftAmount);\n        }\n        if (quotientAndRemainder != (uint *)0x0) {\n          remainder_high = ((temp3 - temp6) - (int)(temp1 >> 0x20)) - (uint)(dividend < (uint)temp1);\n          *quotientAndRemainder = remainder_high << (remainder_low & 0xff) | dividend - (uint)temp1 >> shiftAmount;\n          quotientAndRemainder[1] = remainder_high >> shiftAmount;\n          puVar9 = (uint *)0x0;\n        }\n      }\n    }\n  }\n  return CONCAT44(puVar9,quotientAndRemainder_low);\n}\n\n",
            "renaming": {
                "FUN_0800121c": "calculate_quotient_and_remainder_0800121c",
                "param_1": "dividend",
                "param_2": "dividend_high",
                "param_3": "divisor",
                "param_4": "divisor_high",
                "param_5": "quotientAndRemainder",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "iVar5": "shiftAmount",
                "uVar6": "quotientAndRemainder_low",
                "uVar7": "remainder_high",
                "uVar8": "remainder_low",
                "uVar10": "temp5",
                "uVar11": "mask",
                "uVar12": "temp6",
                "bVar13": "carryFlag",
                "uVar14": "result"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014ec": {
            "entrypoint": "0x080014ec",
            "current_name": "FUNC_080014ec",
            "code": "\nvoid FUNC_080014ec(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080014ec": "FUNC_080014ec"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080014f0": {
            "entrypoint": "0x080014f0",
            "current_name": "initialize_hal_080014f0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_Status initializeHAL_080014f0(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  setInterruptPriorityGroup(3);\n  initializeTick(0xf);\n  initializePeripheral();\n  return HAL_SUCCESS;\n}\n\n",
            "renaming": {
                "FUN_080014f0": "initialize_hal_080014f0",
                "HAL_StatusTypeDef": "HAL_Status",
                "HAL_NVIC_SetPriorityGrouping": "setInterruptPriorityGroup",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializePeripheral",
                "HAL_OK": "HAL_SUCCESS"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_MspInit",
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800151c": {
            "entrypoint": "0x0800151c",
            "current_name": "configure_sys_tick_0800151c",
            "code": "\nHAL_StatusTypeDef configureSysTick_0800151c(uint32_t priority)\n\n{\n  uint32_t configResult;\n  HAL_StatusTypeDef status;\n  uint32_t localPriority;\n  \n  configResult = HAL_SYSTICK_Config((uint32_t)((ulonglong)SystemCoreClock / (1000 / (ulonglong)uwTickFreq))\n                            );\n  if (configResult == 0) {\n    if (priority < 0x10) {\n      HAL_NVIC_SetPriority(SysTick_IRQn,priority,0);\n      status = HAL_OK;\n      uwTickPrio = priority;\n    }\n    else {\n      status = HAL_ERROR;\n    }\n  }\n  else {\n    status = HAL_ERROR;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800151c": "configure_sys_tick_0800151c",
                "TickPriority": "priority",
                "uVar1": "configResult",
                "HVar2": "status",
                "TickPriority_local": "localPriority"
            },
            "calling": [
                "HAL_Init",
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800157c": {
            "entrypoint": "0x0800157c",
            "current_name": "increment_tick_0800157c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid incrementTick_0800157c(void)\n\n{\n  currentTick = currentTick + tickFrequency;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800157c": "increment_tick_0800157c",
                "uwTick": "currentTick",
                "uwTickFreq": "tickFrequency"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015a0": {
            "entrypoint": "0x080015a0",
            "current_name": "get_system_tick_080015a0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemTick_080015a0(void)\n\n{\n  return systemTick;\n}\n\n",
            "renaming": {
                "FUN_080015a0": "get_system_tick_080015a0",
                "uwTick": "systemTick"
            },
            "calling": [
                "I2C_RequestMemoryRead",
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "HAL_I2C_Mem_Write",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_I2C_Mem_Read",
                "I2C_WaitOnBTFFlagUntilTimeout",
                "HAL_RCC_OscConfig",
                "I2C_WaitOnTXEFlagUntilTimeout",
                "I2C_RequestMemoryWrite",
                "_get_ms_tick",
                "HAL_UART_Transmit",
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b4": {
            "entrypoint": "0x080015b4",
            "current_name": "configure_priority_group_080015b4",
            "code": "\n\n\nvoid configurePriorityGroup_080015b4(uint32_t priorityGroup)\n\n{\n  uint32_t localPriorityGroup;\n  uint32_t registerValue;\n  uint32_t temporaryPriorityGroup;\n  \n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | (priorityGroup & 7) << 8 | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b4": "configure_priority_group_080015b4",
                "PriorityGroup": "priorityGroup",
                "PriorityGroup_local": "localPriorityGroup",
                "reg_value": "registerValue",
                "PriorityGroupTmp": "temporaryPriorityGroup"
            },
            "calling": [
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015fc": {
            "entrypoint": "0x080015fc",
            "current_name": "extract_bits_from_register_080015fc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t extract_bits_from_register_080015fc(void)\n\n{\n  return _DAT_e000ed0c >> 8 & 7;\n}\n\n",
            "renaming": {
                "FUN_080015fc": "extract_bits_from_register_080015fc"
            },
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001618": {
            "entrypoint": "0x08001618",
            "current_name": "set_priority_08001618",
            "code": "\nvoid setPriority_08001618(interruptNumber_Type interruptNumber,uint32_t newPriority)\n\n{\n  uint32_t localPriority;\n  interruptNumber_Type localInterruptNumber;\n  \n  if (interruptNumber < WWDG_interruptNumber) {\n    *(char *)(((byte)interruptNumber & 0xf) + 0xe000ed14) = (char)((newPriority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interruptNumber + -0x1fff1c00) = (char)((newPriority & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001618": "set_priority_08001618",
                "IRQn": "interruptNumber",
                "priority": "newPriority",
                "priority_local": "localPriority",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "HAL_NVIC_SetPriority",
                "SysTick_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800166c": {
            "entrypoint": "0x0800166c",
            "current_name": "apply_priority_and_sub_priority_0800166c",
            "code": "\nuint32_t applyPriorityAndSubPriority_0800166c(uint32_t priorityGroup,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint priorityGroupBits;\n  uint remainingBits;\n  uint32_t subPriority_local;\n  uint32_t preemptPriority_local;\n  uint32_t priorityGroup_local;\n  uint32_t subPriorityBits;\n  uint32_t preemptPriorityBits;\n  uint32_t priorityGroupTmp;\n  \n  priorityGroupBits = priorityGroup & 7;\n  remainingBits = 7 - priorityGroupBits;\n  if (3 < remainingBits) {\n    remainingBits = 4;\n  }\n  if (priorityGroupBits + 4 < 7) {\n    priorityGroupBits = 0;\n  }\n  else {\n    priorityGroupBits = priorityGroupBits - 3;\n  }\n  return subPriority & ~(-1 << (priorityGroupBits & 0xff)) |\n         (~(-1 << (remainingBits & 0xff)) & preemptPriority) << (priorityGroupBits & 0xff);\n}\n\n",
            "renaming": {
                "FUN_0800166c": "apply_priority_and_sub_priority_0800166c",
                "PriorityGroup": "priorityGroup",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "uVar1": "priorityGroupBits",
                "uVar2": "remainingBits",
                "SubPriority_local": "subPriority_local",
                "PreemptPriority_local": "preemptPriority_local",
                "PriorityGroup_local": "priorityGroup_local",
                "SubPriorityBits": "subPriorityBits",
                "PreemptPriorityBits": "preemptPriorityBits",
                "PriorityGroupTmp": "priorityGroupTmp"
            },
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016d0": {
            "entrypoint": "0x080016d0",
            "current_name": "check_and_modify_ticks_080016d0",
            "code": "\n\n\nuint32_t checkAndModifyTicks_080016d0(uint32_t originalTicks)\n\n{\n  bool isWithinRange;\n  uint32_t modifiedTicks;\n  \n  isWithinRange = originalTicks - 1 < 0x1000000;\n  if (isWithinRange) {\n    _DAT_e000e014 = originalTicks - 1;\n    NVIC_SetPriority(SysTick_IRQn,0xf);\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n  }\n  return (uint)!isWithinRange;\n}\n\n",
            "renaming": {
                "FUN_080016d0": "check_and_modify_ticks_080016d0",
                "ticks": "originalTicks",
                "bVar1": "isWithinRange",
                "ticks_local": "modifiedTicks"
            },
            "calling": [
                "HAL_SYSTICK_Config"
            ],
            "called": [
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001714": {
            "entrypoint": "0x08001714",
            "current_name": "set_priority_group_08001714",
            "code": "\nvoid setPriorityGroup_08001714(uint32_t priorityGroup)\n\n{\n  uint32_t priorityGroup_local;\n  \n  NVIC_SetpriorityGrouping(priorityGroup);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001714": "set_priority_group_08001714",
                "PriorityGroup": "priorityGroup",
                "PriorityGroup_local": "priorityGroup_local"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [
                "NVIC_SetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800172a": {
            "entrypoint": "0x0800172a",
            "current_name": "set_priority_for_irq_0800172a",
            "code": "\nvoid setPriorityForIRQ_0800172a(interruptNumber_Type interruptNumber,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint32_t priorityGroup;\n  uint32_t localSubPriority;\n  uint32_t localPreemptPriority;\n  interruptNumber_Type localInterruptNumber;\n  uint32_t priorityGrouping;\n  \n  priorityGroup = NVIC_GetPriorityGrouping();\n  priorityGroup = NVIC_EncodePriority(priorityGroup,preemptPriority,subPriority);\n  NVIC_SetPriority(interruptNumber,priorityGroup);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800172a": "set_priority_for_irq_0800172a",
                "IRQn": "interruptNumber",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "uVar1": "priorityGroup",
                "SubPriority_local": "localSubPriority",
                "PreemptPriority_local": "localPreemptPriority",
                "IRQn_local": "localInterruptNumber",
                "prioritygroup": "priorityGrouping"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [
                "NVIC_EncodePriority",
                "NVIC_GetPriorityGrouping",
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001762": {
            "entrypoint": "0x08001762",
            "current_name": "initialize_sys_tick_08001762",
            "code": "\nuint32_t initializeSysTick_08001762(uint32_t configValue)\n\n{\n  uint32_t configStatus;\n  uint32_t localConfigValue;\n  \n  configStatus = SysTick_Config(configValue);\n  return configStatus;\n}\n\n",
            "renaming": {
                "FUN_08001762": "initialize_sys_tick_08001762",
                "TicksNumb": "configValue",
                "uVar1": "configStatus",
                "TicksNumb_local": "localConfigValue"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [
                "SysTick_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800177c": {
            "entrypoint": "0x0800177c",
            "current_name": "update_clock_source_0800177c",
            "code": "\n\n\nvoid updateClockSource_0800177c(uint32_t clockSource)\n\n{\n  uint32_t localClockSource;\n  \n  if (clockSource == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800177c": "update_clock_source_0800177c",
                "CLKSource": "clockSource",
                "CLKSource_local": "localClockSource"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017b4": {
            "entrypoint": "0x080017b4",
            "current_name": "period_elapsed_callback_080017b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid periodElapsedCallback_080017b4(void)\n\n{\n  HAL_TIM_PeriodElapsedCallback((timerHandle *)0x0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080017b4": "period_elapsed_callback_080017b4",
                "TIM_HandleTypeDef": "timerHandle"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017c4": {
            "entrypoint": "0x080017c4",
            "current_name": "configure_gpio_080017c4",
            "code": "\n\n\nvoid configureGPIO_080017c4(GPIO_TypeDef *port,initConfigTypeDef *initConfig)\n\n{\n  uint positionMask;\n  uint pinMask;\n  uint mode;\n  GPIO_TypeDef *selectedGPIO;\n  int portIndex;\n  initConfigTypeDef *localInitConfig;\n  GPIO_TypeDef *localPort;\n  uint32_t tempRegister;\n  uint32_t *configRegister;\n  uint32_t registerOffset;\n  uint32_t temporary;\n  uint32_t currentIO;\n  uint32_t pinPosition;\n  uint32_t configValue;\n  uint32_t position;\n  \n  configValue = 0;\n  position = 0;\n  do {\n    if (0xf < position) {\n      return;\n    }\n    positionMask = 1 << (position & 0xff);\n    pinMask = initConfig->Pin & positionMask;\n    if (pinMask == positionMask) {\n      mode = initConfig->Mode;\n      if (mode == 0x12) {\n        configValue = initConfig->Speed + 0xc;\n      }\n      else if (mode < 0x13) {\n        if (mode == 2) {\n          configValue = initConfig->Speed + 8;\n        }\n        else if (mode < 3) {\n          if (mode == 0) goto LAB_08001882;\n          if (mode == 1) {\n            configValue = initConfig->Speed;\n          }\n        }\n        else if (mode == 3) {\n          configValue = 0;\n        }\n        else if (mode == 0x11) {\n          configValue = initConfig->Speed + 4;\n        }\n      }\n      else if (mode == 0x10210000) {\nLAB_08001882:\n        if (initConfig->Pull == 0) {\n          configValue = 4;\n        }\n        else if (initConfig->Pull == 1) {\n          configValue = 8;\n          port->BSRR = positionMask;\n        }\n        else {\n          configValue = 8;\n          port->BRR = positionMask;\n        }\n      }\n      else if (mode < 0x10210001) {\n        if ((mode == 0x10110000) || (mode == 0x10120000)) goto LAB_08001882;\n      }\n      else if (((mode == 0x10310000) || (mode == 0x10320000)) || (mode == 0x10220000))\n      goto LAB_08001882;\n      if (pinMask < 0x100) {\n        positionMask = position << 2;\n        selectedGPIO = port;\n      }\n      else {\n        selectedGPIO = (GPIO_TypeDef *)&port->CRH;\n        positionMask = (position - 8) * 4;\n      }\n      selectedGPIO->CRL = selectedGPIO->CRL & ~(0xf << (positionMask & 0xff)) | configValue << (positionMask & 0xff);\n      if ((initConfig->Mode & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        if (port == (GPIO_TypeDef *)0x40010800) {\n          portIndex = 0;\n        }\n        else if (port == (GPIO_TypeDef *)0x40010c00) {\n          portIndex = 1;\n        }\n        else if (port == (GPIO_TypeDef *)0x40011000) {\n          portIndex = 2;\n        }\n        else if (port == (GPIO_TypeDef *)0x40011400) {\n          portIndex = 3;\n        }\n        else {\n          portIndex = 4;\n        }\n        *(uint *)(((position >> 2) + 2) * 4 + 0x40010000) =\n             portIndex << ((position & 3) << 2) |\n             ~(0xf << ((position & 3) << 2)) & *(uint *)(((position >> 2) + 2) * 4 + 0x40010000);\n        if ((initConfig->Mode & 0x10000) == 0) {\n          _DAT_40010400 = ~pinMask & _DAT_40010400;\n        }\n        else {\n          _DAT_40010400 = pinMask | _DAT_40010400;\n        }\n        if ((initConfig->Mode & 0x20000) == 0) {\n          _DAT_40010404 = ~pinMask & _DAT_40010404;\n        }\n        else {\n          _DAT_40010404 = pinMask | _DAT_40010404;\n        }\n        if ((initConfig->Mode & 0x100000) == 0) {\n          _DAT_40010408 = ~pinMask & _DAT_40010408;\n        }\n        else {\n          _DAT_40010408 = pinMask | _DAT_40010408;\n        }\n        if ((initConfig->Mode & 0x200000) == 0) {\n          _DAT_4001040c = ~pinMask & _DAT_4001040c;\n        }\n        else {\n          _DAT_4001040c = pinMask | _DAT_4001040c;\n        }\n      }\n    }\n    position = position + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080017c4": "configure_gpio_080017c4",
                "GPIOx": "port",
                "GPIO_Init": "initConfig",
                "uVar1": "positionMask",
                "uVar2": "pinMask",
                "uVar3": "mode",
                "pGVar4": "selectedGPIO",
                "iVar5": "portIndex",
                "GPIO_Init_local": "localInitConfig",
                "GPIOx_local": "localPort",
                "tmpreg": "tempRegister",
                "configregister": "configRegister",
                "registeroffset": "registerOffset",
                "temp": "temporary",
                "iocurrent": "currentIO",
                "ioposition": "pinPosition",
                "config": "configValue"
            },
            "calling": [
                "MX_GPIO_Init",
                "HAL_TIM_MspPostInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a80": {
            "entrypoint": "0x08001a80",
            "current_name": "set_pin_state_08001a80",
            "code": "\nvoid setPinState_08001a80(GPIO_TypeDef *port,uint16_t pin,pinState state)\n\n{\n  pinState localState;\n  uint16_t localPin;\n  GPIO_TypeDef *localPort;\n  \n  if (state == GPIO_PIN_RESET) {\n    port->BSRR = (uint)pin << 0x10;\n  }\n  else {\n    port->BSRR = (uint)pin;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a80": "set_pin_state_08001a80",
                "GPIOx": "port",
                "GPIO_Pin": "pin",
                "PinState": "state",
                "PinState_local": "localState",
                "GPIO_Pin_local": "localPin",
                "GPIOx_local": "localPort"
            },
            "calling": [
                "MX_GPIO_Init",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "initialize_i2_c_08001ab0",
            "code": "\nHAL_StatusTypeDef initializeI2C_08001ab0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t pclk1Freq;\n  char isHighSpeed;\n  HAL_StatusTypeDef status;\n  uint32_t pclk1;\n  uint riseTime;\n  bool isZero;\n  I2C_HandleTypeDef *localI2CHandle;\n  uint32_t pclk1Freq;\n  uint32_t frequencyRange;\n  \n  if (i2cHandle == (I2C_HandleTypeDef *)0x0) {\n    status = HAL_ERROR;\n  }\n  else {\n    if (i2cHandle->State == HAL_I2C_STATE_RESET) {\n      i2cHandle->Lock = HAL_UNLOCKED;\n      HAL_I2C_MspInit(i2cHandle);\n    }\n    i2cHandle->State = HAL_I2C_STATE_BUSY;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n    pclk1Freq = HAL_RCC_GetPCLK1Freq();\n    if ((i2cHandle->Init).ClockSpeed < 0x186a1) {\n      pclk1 = pclk1Freq;\n      if (pclk1Freq < 2000000) {\n        pclk1 = 1;\n      }\n      isHighSpeed = (char)pclk1;\n      if (1999999 < pclk1Freq) {\n        isHighSpeed = '\\0';\n      }\n    }\n    else {\n      pclk1 = pclk1Freq;\n      if (pclk1Freq < 4000000) {\n        pclk1 = 1;\n      }\n      isHighSpeed = (char)pclk1;\n      if (3999999 < pclk1Freq) {\n        isHighSpeed = '\\0';\n      }\n    }\n    if (isHighSpeed == '\\0') {\n      riseTime = pclk1Freq / 1000000;\n      i2cHandle->Instance->CR2 = riseTime;\n      if (100000 < (i2cHandle->Init).ClockSpeed) {\n        riseTime = (riseTime * 300) / 1000;\n      }\n      i2cHandle->Instance->TRISE = riseTime + 1;\n      if ((i2cHandle->Init).ClockSpeed < 0x186a1) {\n        pclk1Freq = (pclk1Freq - 1) / ((i2cHandle->Init).ClockSpeed << 1) + 1 & 0xfff;\n        if (pclk1Freq < 4) {\n          pclk1Freq = 4;\n        }\n      }\n      else {\n        if ((i2cHandle->Init).DutyCycle == 0) {\n          riseTime = (pclk1Freq - 1) / ((i2cHandle->Init).ClockSpeed * 3) + 1 & 0xfff;\n          isZero = riseTime == 0;\n          if (isZero) {\n            riseTime = 1;\n          }\n          isHighSpeed = (char)riseTime;\n          if (!isZero) {\n            isHighSpeed = '\\0';\n          }\n        }\n        else {\n          riseTime = (pclk1Freq - 1) / ((i2cHandle->Init).ClockSpeed * 0x19) + 1 & 0xfff;\n          isZero = riseTime == 0;\n          if (isZero) {\n            riseTime = 1;\n          }\n          isHighSpeed = (char)riseTime;\n          if (!isZero) {\n            isHighSpeed = '\\0';\n          }\n        }\n        if (isHighSpeed == '\\0') {\n          if ((i2cHandle->Init).DutyCycle == 0) {\n            pclk1Freq = (pclk1Freq - 1) / ((i2cHandle->Init).ClockSpeed * 3) + 1 & 0xfff | 0x8000;\n          }\n          else {\n            pclk1Freq = (pclk1Freq - 1) / ((i2cHandle->Init).ClockSpeed * 0x19) + 1 & 0xfff | 0xc000;\n          }\n        }\n        else {\n          pclk1Freq = 1;\n        }\n      }\n      i2cHandle->Instance->CCR = pclk1Freq;\n      i2cHandle->Instance->CR1 = (i2cHandle->Init).NoStretchMode | (i2cHandle->Init).GeneralCallMode;\n      i2cHandle->Instance->OAR1 = (i2cHandle->Init).OwnAddress1 | (i2cHandle->Init).AddressingMode;\n      i2cHandle->Instance->OAR2 = (i2cHandle->Init).OwnAddress2 | (i2cHandle->Init).DualAddressMode;\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      status = HAL_OK;\n    }\n    else {\n      status = HAL_ERROR;\n    }\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "initialize_i2_c_08001ab0",
                "hi2c": "i2cHandle",
                "uVar1": "pclk1Freq",
                "cVar2": "isHighSpeed",
                "HVar3": "status",
                "uVar4": "pclk1",
                "uVar5": "riseTime",
                "bVar6": "isZero",
                "hi2c_local": "localI2CHandle",
                "pclk1": "pclk1Freq",
                "freqrange": "frequencyRange"
            },
            "calling": [
                "MX_I2C1_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_I2C_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cb8": {
            "entrypoint": "0x08001cb8",
            "current_name": "initialize_i2_c_08001cb8",
            "code": "\nvoid initializeI2C_08001cb8(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2C_HandleTypeDef *localI2CHandle;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cb8": "initialize_i2_c_08001cb8",
                "hi2c": "i2cHandle",
                "hi2c_local": "localI2CHandle"
            },
            "calling": [
                "HAL_I2C_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ccc": {
            "entrypoint": "0x08001ccc",
            "current_name": "write_memory_data_08001ccc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001d5e) */\n/* WARNING: Removing unreachable block (ram,0x08001d70) */\n/* WARNING: Removing unreachable block (ram,0x08001d72) */\n/* WARNING: Removing unreachable block (ram,0x08001d74) */\n\nHAL_StatusTypeDef\nwriteMemoryData_08001ccc(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint8_t *data,uint16_t dataSize,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTick;\n  uint32_t currentTick;\n  int loopCounter;\n  byte *bufferPtr;\n  uint16_t localMemAddressSize;\n  uint16_t localMemoryAddress;\n  uint16_t localDeviceAddress;\n  I2C_HandleTypeDef *localI2CHandle;\n  uint32_t localTickstart;\n  \n  startTick = HAL_GetTick();\n  if (i2cHandle->State == HAL_I2C_STATE_READY) {\n    do {\n      if ((~i2cHandle->Instance->SR2 & 2) != 0) {\n        loopCounter = 0;\n        goto LAB_08001d9c;\n      }\n      currentTick = HAL_GetTick();\n    } while (currentTick - startTick < 0x1a);\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    i2cHandle->Lock = HAL_UNLOCKED;\n    loopCounter = 3;\nLAB_08001d9c:\n    if (loopCounter == 0) {\n      if (i2cHandle->Lock == HAL_LOCKED) {\n        status = HAL_BUSY;\n      }\n      else {\n        i2cHandle->Lock = HAL_LOCKED;\n        if ((i2cHandle->Instance->CR1 & 1) != 1) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n        }\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n        i2cHandle->State = HAL_I2C_STATE_BUSY_TX;\n        i2cHandle->Mode = HAL_I2C_MODE_MEM;\n        i2cHandle->ErrorCode = 0;\n        i2cHandle->pBuffPtr = data;\n        i2cHandle->XferCount = dataSize;\n        i2cHandle->XferOptions = 0xffff0000;\n        i2cHandle->XferdataSize = i2cHandle->XferCount;\n        status = I2C_RequestMemoryWrite(i2cHandle,deviceAddress,memoryAddress,memoryAddressSize,timeout,startTick);\n        if (status == HAL_OK) {\n          while (i2cHandle->XferdataSize != 0) {\n            status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,startTick);\n            if (status != HAL_OK) {\n              if (i2cHandle->ErrorCode == 4) {\n                i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n                return HAL_ERROR;\n              }\n              return HAL_TIMEOUT;\n            }\n            bufferPtr = i2cHandle->pBuffPtr;\n            i2cHandle->pBuffPtr = bufferPtr + 1;\n            i2cHandle->Instance->DR = (uint)*bufferPtr;\n            i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n            i2cHandle->XferCount = i2cHandle->XferCount - 1;\n            if (((i2cHandle->Instance->SR1 & 4) == 4) && (i2cHandle->XferdataSize != 0)) {\n              bufferPtr = i2cHandle->pBuffPtr;\n              i2cHandle->pBuffPtr = bufferPtr + 1;\n              i2cHandle->Instance->DR = (uint)*bufferPtr;\n              i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n              i2cHandle->XferCount = i2cHandle->XferCount - 1;\n            }\n          }\n          status = I2C_WaitOnBTFFlagUntiltimeout(i2cHandle,timeout,startTick);\n          if (status == HAL_OK) {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n            i2cHandle->State = HAL_I2C_STATE_READY;\n            i2cHandle->Mode = HAL_I2C_MODE_NONE;\n            i2cHandle->Lock = HAL_UNLOCKED;\n            status = HAL_OK;\n          }\n          else if (i2cHandle->ErrorCode == 4) {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n            status = HAL_ERROR;\n          }\n          else {\n            status = HAL_TIMEOUT;\n          }\n        }\n        else if (i2cHandle->ErrorCode == 4) {\n          i2cHandle->Lock = HAL_UNLOCKED;\n          status = HAL_ERROR;\n        }\n        else {\n          i2cHandle->Lock = HAL_UNLOCKED;\n          status = HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      status = HAL_BUSY;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001ccc": "write_memory_data_08001ccc",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "pData": "data",
                "Size": "dataSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "startTick",
                "uVar2": "currentTick",
                "iVar3": "loopCounter",
                "pbVar4": "bufferPtr",
                "MemAddSize_local": "localMemAddressSize",
                "MemAddress_local": "localMemoryAddress",
                "DevAddress_local": "localDeviceAddress",
                "hi2c_local": "localI2CHandle",
                "tickstart": "localTickstart"
            },
            "calling": [
                "_i2c_write_reg"
            ],
            "called": [
                "I2C_WaitOnBTFFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnTXEFlagUntilTimeout",
                "I2C_RequestMemoryWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f6c": {
            "entrypoint": "0x08001f6c",
            "current_name": "read_i2_c_memory_08001f6c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080024e6) */\n/* WARNING: Removing unreachable block (ram,0x080024f8) */\n/* WARNING: Removing unreachable block (ram,0x080024fa) */\n/* WARNING: Removing unreachable block (ram,0x080024fc) */\n/* WARNING: Removing unreachable block (ram,0x08002000) */\n/* WARNING: Removing unreachable block (ram,0x08002012) */\n/* WARNING: Removing unreachable block (ram,0x08002014) */\n/* WARNING: Removing unreachable block (ram,0x08002016) */\n/* WARNING: Removing unreachable block (ram,0x080023f4) */\n/* WARNING: Removing unreachable block (ram,0x08002406) */\n/* WARNING: Removing unreachable block (ram,0x08002408) */\n/* WARNING: Removing unreachable block (ram,0x0800240a) */\n/* WARNING: Removing unreachable block (ram,0x080022d6) */\n/* WARNING: Removing unreachable block (ram,0x080022e8) */\n/* WARNING: Removing unreachable block (ram,0x080022ea) */\n/* WARNING: Removing unreachable block (ram,0x080022ec) */\n\nHAL_StatusTypeDef\nreadI2CMemory_08001f6c(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint8_t *dataBuffer,uint16_t dataSize,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t tickStart;\n  uint32_t tickCurrent;\n  int loopCounter;\n  uint8_t *ptrVariable;\n  uint16_t memoryAddressSizeLocal;\n  uint16_t memoryAddressLocal;\n  uint16_t deviceAddressLocal;\n  I2C_HandleTypeDef *i2cHandleLocal;\n  uint32_t tempRegister3;\n  uint32_t tempRegister2;\n  uint32_t tempRegister1;\n  uint32_t tempRegister;\n  uint32_t tickStartLocal;\n  \n  tickStart = HAL_GetTick();\n  if (i2cHandle->State == HAL_I2C_STATE_READY) {\n    do {\n      if ((~i2cHandle->Instance->SR2 & 2) != 0) {\n        loopCounter = 0;\n        goto LAB_08002040;\n      }\n      tickCurrent = HAL_GetTick();\n    } while (tickCurrent - tickStart < 0x1a);\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    i2cHandle->Lock = HAL_UNLOCKED;\n    loopCounter = 3;\nLAB_08002040:\n    if (loopCounter == 0) {\n      if (i2cHandle->Lock == HAL_LOCKED) {\n        status = HAL_BUSY;\n      }\n      else {\n        i2cHandle->Lock = HAL_LOCKED;\n        if ((i2cHandle->Instance->CR1 & 1) != 1) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n        }\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n        i2cHandle->State = HAL_I2C_STATE_BUSY_RX;\n        i2cHandle->Mode = HAL_I2C_MODE_MEM;\n        i2cHandle->ErrorCode = 0;\n        i2cHandle->pBuffPtr = dataBuffer;\n        i2cHandle->XferCount = dataSize;\n        i2cHandle->XferOptions = 0xffff0000;\n        i2cHandle->XferdataSize = i2cHandle->XferCount;\n        status = I2C_RequestMemoryRead(i2cHandle,deviceAddress,memoryAddress,memoryAddressSize,timeout,tickStart);\n        if (status == HAL_OK) {\n          if (i2cHandle->XferdataSize == 0) {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n          }\n          else if (i2cHandle->XferdataSize == 1) {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n            disableIRQinterrupts();\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n            enableIRQinterrupts();\n          }\n          else if (i2cHandle->XferdataSize == 2) {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x800;\n            disableIRQinterrupts();\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n            enableIRQinterrupts();\n          }\n          else {\n            i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n          }\n          while (i2cHandle->XferdataSize != 0) {\n            if (i2cHandle->XferdataSize < 4) {\n              if (i2cHandle->XferdataSize == 1) {\n                status = I2C_WaitOnRXNEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n                if (status != HAL_OK) {\n                  if (i2cHandle->ErrorCode == 0x20) {\n                    return HAL_TIMEOUT;\n                  }\n                  return HAL_ERROR;\n                }\n                tickCurrent = i2cHandle->Instance->DR;\n                ptrVariable = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = ptrVariable + 1;\n                *ptrVariable = (uint8_t)tickCurrent;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              }\n              else if (i2cHandle->XferdataSize == 2) {\n                do {\n                  if ((~i2cHandle->Instance->SR1 & 4) == 0) {\n                    loopCounter = 0;\n                    goto LAB_080022fa;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (tickCurrent = HAL_GetTick(), tickCurrent - tickStart <= timeout))));\n                i2cHandle->PreviousState = 0;\n                i2cHandle->State = HAL_I2C_STATE_READY;\n                i2cHandle->Mode = HAL_I2C_MODE_NONE;\n                i2cHandle->Lock = HAL_UNLOCKED;\n                loopCounter = 3;\nLAB_080022fa:\n                if (loopCounter != 0) {\n                  return HAL_TIMEOUT;\n                }\n                disableIRQinterrupts();\n                i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n                tickCurrent = i2cHandle->Instance->DR;\n                ptrVariable = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = ptrVariable + 1;\n                *ptrVariable = (uint8_t)tickCurrent;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n                enableIRQinterrupts();\n                tickCurrent = i2cHandle->Instance->DR;\n                ptrVariable = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = ptrVariable + 1;\n                *ptrVariable = (uint8_t)tickCurrent;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              }\n              else {\n                do {\n                  if ((~i2cHandle->Instance->SR1 & 4) == 0) {\n                    loopCounter = 0;\n                    goto LAB_08002418;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (tickCurrent = HAL_GetTick(), tickCurrent - tickStart <= timeout))));\n                i2cHandle->PreviousState = 0;\n                i2cHandle->State = HAL_I2C_STATE_READY;\n                i2cHandle->Mode = HAL_I2C_MODE_NONE;\n                i2cHandle->Lock = HAL_UNLOCKED;\n                loopCounter = 3;\nLAB_08002418:\n                if (loopCounter != 0) {\n                  return HAL_TIMEOUT;\n                }\n                i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n                disableIRQinterrupts();\n                tickCurrent = i2cHandle->Instance->DR;\n                ptrVariable = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = ptrVariable + 1;\n                *ptrVariable = (uint8_t)tickCurrent;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n                do {\n                  if ((~i2cHandle->Instance->SR1 & 4) == 0) {\n                    loopCounter = 0;\n                    goto LAB_0800250a;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (tickCurrent = HAL_GetTick(), tickCurrent - tickStart <= timeout))));\n                i2cHandle->PreviousState = 0;\n                i2cHandle->State = HAL_I2C_STATE_READY;\n                i2cHandle->Mode = HAL_I2C_MODE_NONE;\n                i2cHandle->Lock = HAL_UNLOCKED;\n                loopCounter = 3;\nLAB_0800250a:\n                if (loopCounter != 0) {\n                  return HAL_TIMEOUT;\n                }\n                i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n                tickCurrent = i2cHandle->Instance->DR;\n                ptrVariable = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = ptrVariable + 1;\n                *ptrVariable = (uint8_t)tickCurrent;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n                enableIRQinterrupts();\n                tickCurrent = i2cHandle->Instance->DR;\n                ptrVariable = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = ptrVariable + 1;\n                *ptrVariable = (uint8_t)tickCurrent;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              }\n            }\n            else {\n              status = I2C_WaitOnRXNEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n              if (status != HAL_OK) {\n                if (i2cHandle->ErrorCode == 0x20) {\n                  return HAL_TIMEOUT;\n                }\n                return HAL_ERROR;\n              }\n              tickCurrent = i2cHandle->Instance->DR;\n              ptrVariable = i2cHandle->pBuffPtr;\n              i2cHandle->pBuffPtr = ptrVariable + 1;\n              *ptrVariable = (uint8_t)tickCurrent;\n              i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n              i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              if ((i2cHandle->Instance->SR1 & 4) == 4) {\n                tickCurrent = i2cHandle->Instance->DR;\n                ptrVariable = i2cHandle->pBuffPtr;\n                i2cHandle->pBuffPtr = ptrVariable + 1;\n                *ptrVariable = (uint8_t)tickCurrent;\n                i2cHandle->XferdataSize = i2cHandle->XferdataSize - 1;\n                i2cHandle->XferCount = i2cHandle->XferCount - 1;\n              }\n            }\n          }\n          i2cHandle->State = HAL_I2C_STATE_READY;\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          i2cHandle->Lock = HAL_UNLOCKED;\n          status = HAL_OK;\n        }\n        else if (i2cHandle->ErrorCode == 4) {\n          i2cHandle->Lock = HAL_UNLOCKED;\n          status = HAL_ERROR;\n        }\n        else {\n          i2cHandle->Lock = HAL_UNLOCKED;\n          status = HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      status = HAL_BUSY;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001f6c": "read_i2_c_memory_08001f6c",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "pData": "dataBuffer",
                "Size": "dataSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "tickStart",
                "uVar2": "tickCurrent",
                "iVar3": "loopCounter",
                "puVar4": "ptrVariable",
                "MemAddSize_local": "memoryAddressSizeLocal",
                "MemAddress_local": "memoryAddressLocal",
                "DevAddress_local": "deviceAddressLocal",
                "hi2c_local": "i2cHandleLocal",
                "tmpreg_3": "tempRegister3",
                "tmpreg_2": "tempRegister2",
                "tmpreg_1": "tempRegister1",
                "tmpreg": "tempRegister",
                "tickstart": "tickStartLocal"
            },
            "calling": [
                "_i2c_read_reg"
            ],
            "called": [
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "I2C_RequestMemoryRead",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002640": {
            "entrypoint": "0x08002640",
            "current_name": "write_i2_c_data_08002640",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080026e8) */\n/* WARNING: Removing unreachable block (ram,0x080026fa) */\n/* WARNING: Removing unreachable block (ram,0x080026fc) */\n/* WARNING: Removing unreachable block (ram,0x080026fe) */\n\nHAL_StatusTypeDef\nwriteI2CData_08002640(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint32_t timeout,uint32_t tickStart)\n\n{\n  HAL_StatusTypeDef returnStatus;\n  uint32_t currentTick;\n  int loopCounter;\n  uint16_t memoryAddressSizeLocal;\n  uint16_t memoryAddressLocal;\n  uint16_t deviceAddressLocal;\n  I2C_HandleTypeDef *i2cHandleLocal;\n  uint32_t temporaryRegister;\n  \n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n  do {\n    if ((~i2cHandle->Instance->SR1 & 1) == 0) {\n      loopCounter = 0;\n      goto LAB_0800270a;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - tickStart <= timeout))));\n  i2cHandle->PreviousState = 0;\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  loopCounter = 3;\nLAB_0800270a:\n  if (loopCounter == 0) {\n    i2cHandle->Instance->DR = (byte)deviceAddress & 0xfe;\n    returnStatus = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout,tickStart);\n    if (returnStatus == HAL_OK) {\n      returnStatus = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n      if (returnStatus == HAL_OK) {\n        if (memoryAddressSize == 1) {\n          i2cHandle->Instance->DR = (uint)(byte)memoryAddress;\n        }\n        else {\n          i2cHandle->Instance->DR = (uint)(byte)(memoryAddress >> 8);\n          returnStatus = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n          if (returnStatus != HAL_OK) {\n            if (i2cHandle->ErrorCode == 4) {\n              i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n              return HAL_ERROR;\n            }\n            return HAL_TIMEOUT;\n          }\n          i2cHandle->Instance->DR = (uint)(byte)memoryAddress;\n        }\n        returnStatus = HAL_OK;\n      }\n      else if (i2cHandle->ErrorCode == 4) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        returnStatus = HAL_ERROR;\n      }\n      else {\n        returnStatus = HAL_TIMEOUT;\n      }\n    }\n    else if (i2cHandle->ErrorCode == 4) {\n      returnStatus = HAL_ERROR;\n    }\n    else {\n      returnStatus = HAL_TIMEOUT;\n    }\n  }\n  else {\n    returnStatus = HAL_TIMEOUT;\n  }\n  return returnStatus;\n}\n\n",
            "renaming": {
                "FUN_08002640": "write_i2_c_data_08002640",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "Timeout": "timeout",
                "Tickstart": "tickStart",
                "HVar1": "returnStatus",
                "uVar2": "currentTick",
                "iVar3": "loopCounter",
                "MemAddSize_local": "memoryAddressSizeLocal",
                "MemAddress_local": "memoryAddressLocal",
                "DevAddress_local": "deviceAddressLocal",
                "hi2c_local": "i2cHandleLocal",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080027f4": {
            "entrypoint": "0x080027f4",
            "current_name": "read_from_i2_c_device_080027f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080028ae) */\n/* WARNING: Removing unreachable block (ram,0x080028c0) */\n/* WARNING: Removing unreachable block (ram,0x080028c2) */\n/* WARNING: Removing unreachable block (ram,0x080028c4) */\n/* WARNING: Removing unreachable block (ram,0x08002a6c) */\n/* WARNING: Removing unreachable block (ram,0x08002a7e) */\n/* WARNING: Removing unreachable block (ram,0x08002a80) */\n/* WARNING: Removing unreachable block (ram,0x08002a82) */\n\nHAL_StatusTypeDef\nreadFromI2CDevice_080027f4(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint32_t timeout,uint32_t tickstart)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t tickDifference;\n  int returnValue;\n  uint16_t localMemoryAddressSize;\n  uint16_t localMemoryAddress;\n  uint16_t localDeviceAddress;\n  I2C_HandleTypeDef *localI2CHandle;\n  uint32_t tempRegister;\n  \n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n  do {\n    if ((~i2cHandle->Instance->SR1 & 1) == 0) {\n      returnValue = 0;\n      goto LAB_080028d2;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (tickDifference = HAL_GetTick(), tickDifference - tickstart <= timeout))));\n  i2cHandle->PreviousState = 0;\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  returnValue = 3;\nLAB_080028d2:\n  if (returnValue == 0) {\n    i2cHandle->Instance->DR = (byte)deviceAddress & 0xfe;\n    status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout,tickstart);\n    if (status == HAL_OK) {\n      status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,tickstart);\n      if (status == HAL_OK) {\n        if (memoryAddressSize == 1) {\n          i2cHandle->Instance->DR = (uint)(byte)memoryAddress;\n        }\n        else {\n          i2cHandle->Instance->DR = (uint)(byte)(memoryAddress >> 8);\n          status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,tickstart);\n          if (status != HAL_OK) {\n            if (i2cHandle->ErrorCode == 4) {\n              i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n              return HAL_ERROR;\n            }\n            return HAL_TIMEOUT;\n          }\n          i2cHandle->Instance->DR = (uint)(byte)memoryAddress;\n        }\n        status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,tickstart);\n        if (status == HAL_OK) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n          do {\n            if ((~i2cHandle->Instance->SR1 & 1) == 0) {\n              returnValue = 0;\n              goto LAB_08002a90;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (tickDifference = HAL_GetTick(), tickDifference - tickstart <= timeout))));\n          i2cHandle->PreviousState = 0;\n          i2cHandle->State = HAL_I2C_STATE_READY;\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          i2cHandle->Lock = HAL_UNLOCKED;\n          returnValue = 3;\nLAB_08002a90:\n          if (returnValue == 0) {\n            i2cHandle->Instance->DR = (uint)(byte)((byte)deviceAddress | 1);\n            status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout,tickstart);\n            if (status == HAL_OK) {\n              status = HAL_OK;\n            }\n            else if (i2cHandle->ErrorCode == 4) {\n              status = HAL_ERROR;\n            }\n            else {\n              status = HAL_TIMEOUT;\n            }\n          }\n          else {\n            status = HAL_TIMEOUT;\n          }\n        }\n        else if (i2cHandle->ErrorCode == 4) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n          status = HAL_ERROR;\n        }\n        else {\n          status = HAL_TIMEOUT;\n        }\n      }\n      else if (i2cHandle->ErrorCode == 4) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        status = HAL_ERROR;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n    else if (i2cHandle->ErrorCode == 4) {\n      status = HAL_ERROR;\n    }\n    else {\n      status = HAL_TIMEOUT;\n    }\n  }\n  else {\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080027f4": "read_from_i2_c_device_080027f4",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "Timeout": "timeout",
                "Tickstart": "tickstart",
                "HVar1": "status",
                "uVar2": "tickDifference",
                "iVar3": "returnValue",
                "MemAddSize_local": "localMemoryAddressSize",
                "MemAddress_local": "localMemoryAddress",
                "DevAddress_local": "localDeviceAddress",
                "hi2c_local": "localI2CHandle",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad8": {
            "entrypoint": "0x08002ad8",
            "current_name": "check_i2_c_status_08002ad8",
            "code": "\nHAL_StatusTypeDef\ncheckI2CStatus_08002ad8(I2C_HandleTypeDef *i2c,uint32_t statusFlag,uint32_t timeout,uint32_t startTickCount)\n\n{\n  uint32_t tickDiff;\n  char flagCondition;\n  uint flagValue;\n  bool isFlagSet;\n  uint32_t localTickCount;\n  uint32_t localTimeout;\n  uint32_t localFlag;\n  I2C_HandleTypeDef *localI2C;\n  \n  do {\n    if ((statusFlag >> 0x10 & 0xff) == 1) {\n      flagValue = statusFlag & ~i2c->Instance->SR1 & 0xffff;\n      isFlagSet = flagValue != 0;\n      if (isFlagSet) {\n        flagValue = 1;\n      }\n      flagCondition = (char)flagValue;\n      if (!isFlagSet) {\n        flagCondition = '\\0';\n      }\n    }\n    else {\n      flagValue = statusFlag & ~i2c->Instance->SR2 & 0xffff;\n      isFlagSet = flagValue != 0;\n      if (isFlagSet) {\n        flagValue = 1;\n      }\n      flagCondition = (char)flagValue;\n      if (!isFlagSet) {\n        flagCondition = '\\0';\n      }\n    }\n    if (flagCondition == '\\0') {\n      return HAL_OK;\n    }\n    if ((i2c->Instance->SR1 & 0x400) == 0x400) {\n      i2c->Instance->CR1 = i2c->Instance->CR1 | 0x200;\n      i2c->Instance->SR1 = 0xfffffbff;\n      i2c->ErrorCode = 4;\n      i2c->PreviousState = 0;\n      i2c->State = HAL_I2C_STATE_READY;\n      i2c->Lock = HAL_UNLOCKED;\n      return HAL_ERROR;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (tickDiff = HAL_GetTick(), tickDiff - startTickCount <= timeout))));\n  i2c->PreviousState = 0;\n  i2c->State = HAL_I2C_STATE_READY;\n  i2c->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08002ad8": "check_i2_c_status_08002ad8",
                "hi2c": "i2c",
                "Flag": "statusFlag",
                "Timeout": "timeout",
                "Tickstart": "startTickCount",
                "uVar1": "tickDiff",
                "cVar2": "flagCondition",
                "uVar3": "flagValue",
                "bVar4": "isFlagSet",
                "Tickstart_local": "localTickCount",
                "Timeout_local": "localTimeout",
                "Flag_local": "localFlag",
                "hi2c_local": "localI2C"
            },
            "calling": [
                "I2C_RequestMemoryRead",
                "I2C_RequestMemoryWrite"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002bb4": {
            "entrypoint": "0x08002bb4",
            "current_name": "wait_for_i2_c_ack_08002bb4",
            "code": "\nHAL_StatusTypeDef waitForI2CAck_08002bb4(I2C_HandleTypeDef *i2cHandle,uint32_t timeout,uint32_t tickStart)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t currentTick;\n  uint32_t localTickStart;\n  uint32_t localTimeout;\n  I2C_HandleTypeDef *localI2CHandle;\n  \n  while( true ) {\n    if ((i2cHandle->Instance->SR1 & 0x80) == 0x80) {\n      return HAL_OK;\n    }\n    status = I2C_IsAcknowledgeFailed(i2cHandle);\n    if (status != HAL_OK) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (currentTick = HAL_GetTick(), timeout < currentTick - tickStart)))) {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 0x20;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002bb4": "wait_for_i2_c_ack_08002bb4",
                "hi2c": "i2cHandle",
                "Timeout": "timeout",
                "Tickstart": "tickStart",
                "HVar1": "status",
                "uVar2": "currentTick",
                "Tickstart_local": "localTickStart",
                "Timeout_local": "localTimeout",
                "hi2c_local": "localI2CHandle"
            },
            "calling": [
                "I2C_RequestMemoryRead",
                "HAL_I2C_Mem_Write",
                "I2C_RequestMemoryWrite"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_IsAcknowledgeFailed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c2e": {
            "entrypoint": "0x08002c2e",
            "current_name": "wait_for_ack_08002c2e",
            "code": "\nHAL_StatusTypeDef waitForACK_08002c2e(I2C_HandleTypeDef *i2cHandle,uint32_t timeout,uint32_t tickStart)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t currentTick;\n  uint32_t localTickStart;\n  uint32_t localTimeout;\n  I2C_HandleTypeDef *localI2CHandle;\n  \n  while( true ) {\n    if ((i2cHandle->Instance->SR1 & 4) == 4) {\n      return HAL_OK;\n    }\n    status = I2C_IsAcknowledgeFailed(i2cHandle);\n    if (status != HAL_OK) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (currentTick = HAL_GetTick(), timeout < currentTick - tickStart)))) {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 0x20;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002c2e": "wait_for_ack_08002c2e",
                "hi2c": "i2cHandle",
                "Timeout": "timeout",
                "Tickstart": "tickStart",
                "HVar1": "status",
                "uVar2": "currentTick",
                "Tickstart_local": "localTickStart",
                "Timeout_local": "localTimeout",
                "hi2c_local": "localI2CHandle"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_IsAcknowledgeFailed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca8": {
            "entrypoint": "0x08002ca8",
            "current_name": "wait_for_i2_c_flag_08002ca8",
            "code": "\nHAL_StatusTypeDef waitForI2CFlag_08002ca8(I2C_HandleTypeDef *i2cHandle,uint32_t timeout,uint32_t tickstart)\n\n{\n  uint32_t elapsedTime;\n  uint32_t localTickstart;\n  uint32_t localTimeout;\n  I2C_HandleTypeDef *localI2CHandle;\n  \n  while( true ) {\n    if ((i2cHandle->Instance->SR1 & 0x40) == 0x40) {\n      return HAL_OK;\n    }\n    if ((i2cHandle->Instance->SR1 & 0x10) == 0x10) break;\n    if ((timeout == 0) || (elapsedTime = HAL_GetTick(), timeout < elapsedTime - tickstart)) {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 0x20;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  i2cHandle->Instance->SR1 = 0xffffffef;\n  i2cHandle->ErrorCode = 0;\n  i2cHandle->PreviousState = 0;\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002ca8": "wait_for_i2_c_flag_08002ca8",
                "hi2c": "i2cHandle",
                "Timeout": "timeout",
                "Tickstart": "tickstart",
                "uVar1": "elapsedTime",
                "Tickstart_local": "localTickstart",
                "Timeout_local": "localTimeout",
                "hi2c_local": "localI2CHandle"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d3c": {
            "entrypoint": "0x08002d3c",
            "current_name": "check_i2_c_error_08002d3c",
            "code": "\nHAL_StatusTypeDef check_I2C_error_08002d3c(I2C_HandleTypeDef *i2c_handle)\n\n{\n  bool is_error;\n  I2C_HandleTypeDef *local_i2c_handle;\n  \n  is_error = (i2c_handle->Instance->SR1 & 0x400) == 0x400;\n  if (is_error) {\n    i2c_handle->Instance->SR1 = 0xfffffbff;\n    i2c_handle->ErrorCode = 4;\n    i2c_handle->PreviousState = 0;\n    i2c_handle->State = HAL_I2C_STATE_READY;\n    i2c_handle->Lock = HAL_UNLOCKED;\n  }\n  return is_error;\n}\n\n",
            "renaming": {
                "FUN_08002d3c": "check_i2_c_error_08002d3c",
                "hi2c": "i2c_handle",
                "bVar1": "is_error",
                "hi2c_local": "local_i2c_handle"
            },
            "calling": [
                "I2C_WaitOnBTFFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d8a": {
            "entrypoint": "0x08002d8a",
            "current_name": "FUNC_08002d8a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002d8a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d8a": "FUNC_08002d8a"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d98": {
            "entrypoint": "0x08002d98",
            "current_name": "initialize_rcc_08002d98",
            "code": "\n\n\nStatus initializeRCC_08002d98(RCC_OscInitTypeDef *oscInitStruct)\n\n{\n  uint32_t startTime;\n  uint32_t currentTime;\n  Status result;\n  bool flag;\n  RCC_OscInitTypeDef *localInitStruct;\n  uint32_t tempRegister;\n  uint32_t startTick;\n  FlagStatus powerClockChanged;\n  \n  if ((oscInitStruct->OscillatorType & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0x10000)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (oscInitStruct->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      if (oscInitStruct->HSEState == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (oscInitStruct->HSEState == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (oscInitStruct->HSEState == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (oscInitStruct->HSEState == 0) {\n        startTime = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          currentTime = HAL_GetTick();\n          if (100 < currentTime - startTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        startTime = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          currentTime = HAL_GetTick();\n          if (100 < currentTime - startTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((oscInitStruct->OscillatorType & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (oscInitStruct->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      _DAT_40021000 = oscInitStruct->HSICalibrationValue << 3 | _DAT_40021000 & 0xffffff07;\n    }\n    else if (oscInitStruct->HSIState == 0) {\n      _DAT_42420000 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021000 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (2 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021000 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (2 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40021000 = oscInitStruct->HSICalibrationValue << 3 | _DAT_40021000 & 0xffffff07;\n    }\n  }\n  if ((oscInitStruct->OscillatorType & 8) != 0) {\n    if (oscInitStruct->LSIState == 0) {\n      _DAT_42420480 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021024 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (2 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021024 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (2 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((oscInitStruct->OscillatorType & 4) != 0) {\n    flag = (_DAT_4002101c & 0x10000000) == 0;\n    if (flag) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTime = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTime = HAL_GetTick();\n        if (100 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (oscInitStruct->LSEState == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (oscInitStruct->LSEState == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (oscInitStruct->LSEState == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (oscInitStruct->LSEState == 0) {\n      startTime = HAL_GetTick();\n      while ((_DAT_40021020 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (5000 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      startTime = HAL_GetTick();\n      while ((_DAT_40021020 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (5000 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (flag) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if ((oscInitStruct->PLL).PLLState == 0) {\nLAB_0800324a:\n    result = HAL_OK;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    result = HAL_ERROR;\n  }\n  else if ((oscInitStruct->PLL).PLLState == 2) {\n    _DAT_42420060 = 0;\n    startTime = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if ((oscInitStruct->PLL).PLLSource == 0x10000) {\n          _DAT_40021004 = oscInitStruct->HSEPredivValue | _DAT_40021004 & 0xfffdffff;\n        }\n        _DAT_40021004 =\n             (oscInitStruct->PLL).PLLMUL | (oscInitStruct->PLL).PLLSource |\n             _DAT_40021004 & 0xffc2ffff;\n        _DAT_42420060 = 1;\n        startTime = HAL_GetTick();\n        while ((_DAT_40021000 & 0x2000000) == 0) {\n          currentTime = HAL_GetTick();\n          if (2 < currentTime - startTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n        goto LAB_0800324a;\n      }\n      currentTime = HAL_GetTick();\n    } while (currentTime - startTime < 3);\n    result = HAL_TIMEOUT;\n  }\n  else {\n    _DAT_42420060 = 0;\n    startTime = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) goto LAB_0800324a;\n      currentTime = HAL_GetTick();\n    } while (currentTime - startTime < 3);\n    result = HAL_TIMEOUT;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002d98": "initialize_rcc_08002d98",
                "RCC_OscInitStruct": "oscInitStruct",
                "HAL_StatusTypeDef": "Status",
                "uVar1": "startTime",
                "uVar2": "currentTime",
                "HVar3": "result",
                "bVar4": "flag",
                "RCC_OscInitStruct_local": "localInitStruct",
                "tmpreg": "tempRegister",
                "tickstart": "startTick",
                "pwrclkchanged": "powerClockChanged"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003260": {
            "entrypoint": "0x08003260",
            "current_name": "configure_clocks_08003260",
            "code": "\n\n\nHAL_StatusTypeDef configureClocks_08003260(RCC_ClkInitTypeDef *clockInitStruct,uint32_t latency)\n\n{\n  uint32_t sysClockFreq;\n  uint32_t currentTick;\n  HAL_StatusTypeDef status;\n  uint32_t localLatency;\n  RCC_ClkInitTypeDef *localClockInitStruct;\n  uint32_t startTick;\n  \n  if (((_DAT_40022000 & 7) < latency) &&\n     (_DAT_40022000 = latency | _DAT_40022000 & 0xfffffff8, latency != (latency & 7))) {\n    status = ERROR;\n  }\n  else {\n    if ((clockInitStruct->ClockType & 2) != 0) {\n      _DAT_40021004 = clockInitStruct->AHBCLKDivider | _DAT_40021004 & 0xffffff0f;\n    }\n    if ((clockInitStruct->ClockType & 1) == 0) {\nLAB_08003394:\n      if ((latency < (_DAT_40022000 & 7)) &&\n         (_DAT_40022000 = latency | _DAT_40022000 & 0xfffffff8, latency != (latency & 7))) {\n        status = ERROR;\n      }\n      else {\n        if ((clockInitStruct->ClockType & 4) != 0) {\n          _DAT_40021004 = clockInitStruct->APB1CLKDivider | _DAT_40021004 & 0xfffff8ff;\n        }\n        if ((clockInitStruct->ClockType & 8) != 0) {\n          _DAT_40021004 = clockInitStruct->APB2CLKDivider << 3 | _DAT_40021004 & 0xffffc7ff;\n        }\n        sysClockFreq = getSysClockFrequency();\n        coreClock = sysClockFreq >> \"\"[_DAT_40021004 >> 4 & 0xf];\n        initializeTick(0xf);\n        status = OK;\n      }\n    }\n    else {\n      if (clockInitStruct->sysClockSource == 1) {\n        if ((_DAT_40021000 & 0x20000) == 0) {\n          return ERROR;\n        }\n      }\n      else if ((clockInitStruct->sysClockSource != 2) && ((_DAT_40021000 & 2) == 0)) {\n        return ERROR;\n      }\n      _DAT_40021004 = clockInitStruct->sysClockSource | _DAT_40021004 & 0xfffffffc;\n      sysClockFreq = getTick();\n      if (clockInitStruct->sysClockSource == 1) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 4) goto LAB_08003394;\n          currentTick = getTick();\n        } while (currentTick - sysClockFreq < 0x1389);\n        status = TIMEOUT;\n      }\n      else if (clockInitStruct->sysClockSource == 2) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 8) goto LAB_08003394;\n          currentTick = getTick();\n        } while (currentTick - sysClockFreq < 0x1389);\n        status = TIMEOUT;\n      }\n      else {\n        do {\n          if ((_DAT_40021004 & 0xc) == 0) goto LAB_08003394;\n          currentTick = getTick();\n        } while (currentTick - sysClockFreq < 0x1389);\n        status = TIMEOUT;\n      }\n    }\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003260": "configure_clocks_08003260",
                "RCC_ClkInitStruct": "clockInitStruct",
                "FLatency": "latency",
                "uVar1": "sysClockFreq",
                "uVar2": "currentTick",
                "HVar3": "status",
                "FLatency_local": "localLatency",
                "RCC_ClkInitStruct_local": "localClockInitStruct",
                "tickstart": "startTick",
                "SystemCoreClock": "coreClock",
                "SYSCLKSource": "sysClockSource",
                "HAL_ERROR": "ERROR",
                "HAL_OK": "OK",
                "HAL_TIMEOUT": "TIMEOUT",
                "HAL_RCC_GetSysClockFreq": "getSysClockFrequency",
                "HAL_InitTick": "initializeTick",
                "HAL_GetTick": "getTick"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_GetTick",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003440": {
            "entrypoint": "0x08003440",
            "current_name": "get_sys_clock_freq_08003440",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getSysClockFreq_08003440(void)\n\n{\n  uint8_t predivFactorTable [2];\n  uint8_t pllMulFactorTable [16];\n  uint32_t pllMul;\n  uint32_t prediv;\n  uint32_t tmpReg;\n  uint32_t sysClockFreq;\n  uint32_t pllClk;\n  \n  pllMulFactorTable[0] = '\\x02';\n  pllMulFactorTable[1] = '\\x03';\n  pllMulFactorTable[2] = '\\x04';\n  pllMulFactorTable[3] = '\\x05';\n  pllMulFactorTable[4] = '\\x06';\n  pllMulFactorTable[5] = '\\a';\n  pllMulFactorTable[6] = '\\b';\n  pllMulFactorTable[7] = '\\t';\n  pllMulFactorTable[8] = '\\n';\n  pllMulFactorTable[9] = '\\v';\n  pllMulFactorTable[10] = '\\f';\n  pllMulFactorTable[11] = '\\r';\n  pllMulFactorTable[12] = '\\x0e';\n  pllMulFactorTable[13] = '\\x0f';\n  pllMulFactorTable[14] = '\\x10';\n  pllMulFactorTable[15] = '\\x10';\n  predivFactorTable[0] = '\\x01';\n  predivFactorTable[1] = '\\x02';\n  if ((_DAT_40021004 & 0xc) == 4) {\n    sysClockFreq = 8000000;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      pllClk = (uint)pllMulFactorTable[_DAT_40021004 >> 0x12 & 0xf] * 4000000;\n    }\n    else {\n      pllClk = ((uint)pllMulFactorTable[_DAT_40021004 >> 0x12 & 0xf] * 8000000) /\n               (uint)predivFactorTable[_DAT_40021004 >> 0x11 & 1];\n    }\n    sysClockFreq = pllClk;\n  }\n  else {\n    sysClockFreq = 8000000;\n  }\n  return sysClockFreq;\n}\n\n",
            "renaming": {
                "FUN_08003440": "get_sys_clock_freq_08003440",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllMulFactorTable",
                "pllmul": "pllMul",
                "tmpreg": "tmpReg",
                "sysclockfreq": "sysClockFreq",
                "pllclk": "pllClk"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003504": {
            "entrypoint": "0x08003504",
            "current_name": "get_system_core_clock_08003504",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_08003504(void)\n\n{\n  return systemCoreClock;\n}\n\n",
            "renaming": {
                "FUN_08003504": "get_system_core_clock_08003504",
                "SystemCoreClock": "systemCoreClock"
            },
            "calling": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003518": {
            "entrypoint": "0x08003518",
            "current_name": "get_adjusted_hclk_freq_08003518",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getAdjustedHCLKFreq_08003518(void)\n\n{\n  uint32_t adjustedFreq;\n  \n  adjustedFreq = getHCLKFreq();\n  return adjustedFreq >> \"\"[_DAT_40021004 >> 8 & 7];\n}\n\n",
            "renaming": {
                "FUN_08003518": "get_adjusted_hclk_freq_08003518",
                "uVar1": "adjustedFreq",
                "HAL_RCC_GetHCLKFreq": "getHCLKFreq"
            },
            "calling": [
                "UART_SetConfig",
                "HAL_I2C_Init"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003540": {
            "entrypoint": "0x08003540",
            "current_name": "get_hclk_frequency_08003540",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_HCLK_frequency_08003540(void)\n\n{\n  uint32_t HCLK_frequency;\n  \n  HCLK_frequency = get_HCLKFreq();\n  return HCLK_frequency >> \"\"[_DAT_40021004 >> 0xb & 7];\n}\n\n",
            "renaming": {
                "FUN_08003540": "get_hclk_frequency_08003540",
                "uVar1": "HCLK_frequency",
                "HAL_RCC_GetHCLKFreq": "get_HCLKFreq"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003568": {
            "entrypoint": "0x08003568",
            "current_name": "delay_milliseconds_08003568",
            "code": "\nvoid delayMilliseconds_08003568(uint32_t inputDelay)\n\n{\n  bool isDelayNotZero;\n  uint32_t localDelay;\n  uint32_t calculatedDelay;\n  \n  calculatedDelay = inputDelay * (SystemCoreClock / 8000);\n  do {\n    isDelayNotZero = calculatedDelay != 0;\n    calculatedDelay = calculatedDelay - 1;\n  } while (isDelayNotZero);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003568": "delay_milliseconds_08003568",
                "mdelay": "inputDelay",
                "mdelay_local": "localDelay",
                "Delay": "calculatedDelay",
                "bVar1": "isDelayNotZero"
            },
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035a4": {
            "entrypoint": "0x080035a4",
            "current_name": "initialize_timer_080035a4",
            "code": "\nHAL_StatusTypeDef initializeTimer_080035a4(TIM_HandleTypeDef *timer)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_HandleTypeDef *localTimer;\n  \n  if (timer == (TIM_HandleTypeDef *)0x0) {\n    status = ERROR;\n  }\n  else {\n    if (timer->State == TIMER_RESET) {\n      timer->Lock = UNLOCKED;\n      initializeTimer_080035a4Base(timer);\n    }\n    timer->State = TIMER_BUSY;\n    setTimerConfig(timer->Instance,&timer->Init);\n    timer->State = TIMER_READY;\n    status = OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080035a4": "initialize_timer_080035a4",
                "htim": "timer",
                "HVar1": "status",
                "htim_local": "localTimer",
                "HAL_ERROR": "ERROR",
                "HAL_TIM_STATE_RESET": "TIMER_RESET",
                "HAL_UNLOCKED": "UNLOCKED",
                "HAL_TIM_STATE_BUSY": "TIMER_BUSY",
                "HAL_TIM_STATE_READY": "TIMER_READY",
                "HAL_OK": "OK",
                "HAL_TIM_Base_MspInit": "initializeTimerBase",
                "TIM_Base_SetConfig": "setTimerConfig"
            },
            "calling": [
                "MX_TIM2_Init",
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_TIM_Base_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fa": {
            "entrypoint": "0x080035fa",
            "current_name": "initialize_timer_080035fa",
            "code": "\nvoid initializeTimer_080035fa(TIM_HandleTypeDef *timerHandler)\n\n{\n  TIM_HandleTypeDef *localTimerHandler;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fa": "initialize_timer_080035fa",
                "htim": "timerHandler",
                "htim_local": "localTimerHandler"
            },
            "calling": [
                "HAL_TIM_Base_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800360c": {
            "entrypoint": "0x0800360c",
            "current_name": "enable_timer_interrupts_0800360c",
            "code": "\nHAL_StatusTypeDef enableTimerInterrupts_0800360c(TIM_HandleTypeDef *timer)\n\n{\n  TIM_HandleTypeDef *localTimer;\n  \n  timer->timerInstance->interruptEnableRegister = timer->timerInstance->interruptEnableRegister | 1;\n  timer->timerInstance->controlRegister1 = timer->timerInstance->controlRegister1 | 1;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800360c": "enable_timer_interrupts_0800360c",
                "htim": "timer",
                "htim_local": "localTimer",
                "Instance": "timerInstance",
                "DIER": "interruptEnableRegister",
                "CR1": "controlRegister1"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003640": {
            "entrypoint": "0x08003640",
            "current_name": "configure_tim_08003640",
            "code": "\nHAL_StatusTypeDef configure_TIM_08003640(TIM_HandleTypeDef *tim_handle)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_HandleTypeDef *local_tim_handle;\n  \n  if (tim_handle == (TIM_HandleTypeDef *)0x0) {\n    status = HAL_ERROR;\n  }\n  else {\n    if (tim_handle->State == HAL_TIM_STATE_RESET) {\n      tim_handle->Lock = HAL_UNLOCKED;\n      HAL_TIM_PWM_MspInit(tim_handle);\n    }\n    tim_handle->State = HAL_TIM_STATE_BUSY;\n    TIM_Base_SetConfig(tim_handle->Instance,&tim_handle->Init);\n    tim_handle->State = HAL_TIM_STATE_READY;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003640": "configure_tim_08003640",
                "htim": "tim_handle",
                "HVar1": "status",
                "htim_local": "local_tim_handle"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_TIM_PWM_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003696": {
            "entrypoint": "0x08003696",
            "current_name": "initialize_timer_08003696",
            "code": "\nvoid initializeTimer_08003696(TIM_HandleTypeDef *timer)\n\n{\n  TIM_HandleTypeDef *timer_local;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003696": "initialize_timer_08003696",
                "htim": "timer"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036a8": {
            "entrypoint": "0x080036a8",
            "current_name": "initialize_timer_channel_080036a8",
            "code": "\nHAL_StatusTypeDef initializeTimerChannel_080036a8(TIM_HandleTypeDef *timerHandle,uint32_t channel)\n\n{\n  uint32_t localChannel;\n  TIM_HandleTypeDef *localTimerHandle;\n  \n  TIM_CCxchannelCmd(timerHandle->Instance,channel,1);\n  if (timerHandle->Instance == (TIM_TypeDef *)0x40012c00) {\n    timerHandle->Instance->BDTR = timerHandle->Instance->BDTR | 0x8000;\n  }\n  timerHandle->Instance->CR1 = timerHandle->Instance->CR1 | 1;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080036a8": "initialize_timer_channel_080036a8",
                "htim": "timerHandle",
                "Channel": "channel",
                "Channel_local": "localChannel",
                "htim_local": "localTimerHandle"
            },
            "calling": [
                "main"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036f8": {
            "entrypoint": "0x080036f8",
            "current_name": "process_timers_080036f8",
            "code": "\nvoid processTimers_080036f8(TIM_HandleTypeDef *timer)\n\n{\n  TIM_HandleTypeDef *localTimer;\n  \n  if (((timer->Instance->SR & 2) == 2) && ((timer->Instance->DIER & 2) == 2)) {\n    timer->Instance->SR = 0xfffffffd;\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n    if ((timer->Instance->CCMR1 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timer);\n      HAL_TIM_PWM_PulseFinishedCallback(timer);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timer);\n    }\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  if (((timer->Instance->SR & 4) == 4) && ((timer->Instance->DIER & 4) == 4)) {\n    timer->Instance->SR = 0xfffffffb;\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n    if ((timer->Instance->CCMR1 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timer);\n      HAL_TIM_PWM_PulseFinishedCallback(timer);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timer);\n    }\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  if (((timer->Instance->SR & 8) == 8) && ((timer->Instance->DIER & 8) == 8)) {\n    timer->Instance->SR = 0xfffffff7;\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n    if ((timer->Instance->CCMR2 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timer);\n      HAL_TIM_PWM_PulseFinishedCallback(timer);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timer);\n    }\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  if (((timer->Instance->SR & 0x10) == 0x10) && ((timer->Instance->DIER & 0x10) == 0x10)) {\n    timer->Instance->SR = 0xffffffef;\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n    if ((timer->Instance->CCMR2 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timer);\n      HAL_TIM_PWM_PulseFinishedCallback(timer);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timer);\n    }\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  if (((timer->Instance->SR & 1) == 1) && ((timer->Instance->DIER & 1) == 1)) {\n    timer->Instance->SR = 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(timer);\n  }\n  if (((timer->Instance->SR & 0x80) == 0x80) && ((timer->Instance->DIER & 0x80) == 0x80)) {\n    timer->Instance->SR = 0xffffff7f;\n    HAL_TIMEx_BreakCallback(timer);\n  }\n  if (((timer->Instance->SR & 0x40) == 0x40) && ((timer->Instance->DIER & 0x40) == 0x40)) {\n    timer->Instance->SR = 0xffffffbf;\n    HAL_TIM_TriggerCallback(timer);\n  }\n  if (((timer->Instance->SR & 0x20) == 0x20) && ((timer->Instance->DIER & 0x20) == 0x20)) {\n    timer->Instance->SR = 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(timer);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080036f8": "process_timers_080036f8",
                "htim": "timer",
                "htim_local": "localTimer"
            },
            "calling": [
                "TIM2_IRQHandler"
            ],
            "called": [
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIMEx_BreakCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003908": {
            "entrypoint": "0x08003908",
            "current_name": "configure_timer_output_compare_08003908",
            "code": "\nHAL_StatusTypeDef configureTimerOutputCompare_08003908(TIM_HandleTypeDef *timerHandle,TIM_OC_InitTypeDef *outputCompareConfig,uint32_t channel)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t localChannel;\n  TIM_OC_InitTypeDef *localOutputCompareConfig;\n  TIM_HandleTypeDef *localTimerHandle;\n  \n  if (timerHandle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    timerHandle->Lock = HAL_LOCKED;\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    switch(channel) {\n    case 0:\n      TIM_OC1_SetConfig(timerHandle->Instance,outputCompareConfig);\n      timerHandle->Instance->CCMR1 = timerHandle->Instance->CCMR1 | 8;\n      timerHandle->Instance->CCMR1 = timerHandle->Instance->CCMR1 & 0xfffffffb;\n      timerHandle->Instance->CCMR1 = outputCompareConfig->OCFastMode | timerHandle->Instance->CCMR1;\n      break;\n    case 4:\n      TIM_OC2_SetConfig(timerHandle->Instance,outputCompareConfig);\n      timerHandle->Instance->CCMR1 = timerHandle->Instance->CCMR1 | 0x800;\n      timerHandle->Instance->CCMR1 = timerHandle->Instance->CCMR1 & 0xfffffbff;\n      timerHandle->Instance->CCMR1 = outputCompareConfig->OCFastMode << 8 | timerHandle->Instance->CCMR1;\n      break;\n    case 8:\n      TIM_OC3_SetConfig(timerHandle->Instance,outputCompareConfig);\n      timerHandle->Instance->CCMR2 = timerHandle->Instance->CCMR2 | 8;\n      timerHandle->Instance->CCMR2 = timerHandle->Instance->CCMR2 & 0xfffffffb;\n      timerHandle->Instance->CCMR2 = outputCompareConfig->OCFastMode | timerHandle->Instance->CCMR2;\n      break;\n    case 0xc:\n      TIM_OC4_SetConfig(timerHandle->Instance,outputCompareConfig);\n      timerHandle->Instance->CCMR2 = timerHandle->Instance->CCMR2 | 0x800;\n      timerHandle->Instance->CCMR2 = timerHandle->Instance->CCMR2 & 0xfffffbff;\n      timerHandle->Instance->CCMR2 = outputCompareConfig->OCFastMode << 8 | timerHandle->Instance->CCMR2;\n    }\n    timerHandle->State = HAL_TIM_STATE_READY;\n    timerHandle->Lock = HAL_UNLOCKED;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003908": "configure_timer_output_compare_08003908",
                "htim": "timerHandle",
                "sConfig": "outputCompareConfig",
                "Channel": "channel",
                "HVar1": "status",
                "Channel_local": "localChannel",
                "sConfig_local": "localOutputCompareConfig",
                "htim_local": "localTimerHandle"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "TIM_OC4_SetConfig",
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC2_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a94": {
            "entrypoint": "0x08003a94",
            "current_name": "configure_timer_clock_08003a94",
            "code": "\nHAL_StatusTypeDef configureTimerClock_08003a94(TIM_HandleTypeDef *timerHandle,TIM_ClockConfigTypeDef *clockConfig)\n\n{\n  HAL_StatusTypeDef status;\n  uint clockSource;\n  TIM_ClockConfigTypeDef *localClockConfig;\n  TIM_HandleTypeDef *localTimerHandle;\n  uint32_t tmpSMCR;\n  \n  if (timerHandle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    timerHandle->Lock = HAL_LOCKED;\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    timerHandle->Instance->SMCR = timerHandle->Instance->SMCR & 0xffff0088;\n    clockSource = clockConfig->ClockSource;\n    if (clockSource == 0x40) {\n      TIM_TI1_ConfigInputStage\n                (timerHandle->Instance,clockConfig->ClockPolarity,clockConfig->ClockFilter);\n      TIM_ITRx_SetConfig(timerHandle->Instance,0x40);\n    }\n    else if (clockSource < 0x41) {\n      if (clockSource == 0x10) {\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x10);\n      }\n      else if (clockSource < 0x11) {\n        if (clockSource == 0) {\n          TIM_ITRx_SetConfig(timerHandle->Instance,0);\n        }\n      }\n      else if (clockSource == 0x20) {\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x20);\n      }\n      else if (clockSource == 0x30) {\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x30);\n      }\n    }\n    else if (clockSource == 0x70) {\n      TIM_ETR_SetConfig(timerHandle->Instance,clockConfig->ClockPrescaler,\n                        clockConfig->ClockPolarity,clockConfig->ClockFilter);\n      timerHandle->Instance->SMCR = timerHandle->Instance->SMCR & 0xffffff88 | 0x77;\n    }\n    else if (clockSource < 0x71) {\n      if (clockSource == 0x50) {\n        TIM_TI1_ConfigInputStage\n                  (timerHandle->Instance,clockConfig->ClockPolarity,clockConfig->ClockFilter)\n        ;\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x50);\n      }\n      else if (clockSource == 0x60) {\n        TIM_TI2_ConfigInputStage\n                  (timerHandle->Instance,clockConfig->ClockPolarity,clockConfig->ClockFilter)\n        ;\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x60);\n      }\n    }\n    else if (clockSource == 0x1000) {\n      timerHandle->Instance->SMCR = timerHandle->Instance->SMCR & 0xfffffff8;\n    }\n    else if (clockSource == 0x2000) {\n      TIM_ETR_SetConfig(timerHandle->Instance,clockConfig->ClockPrescaler,\n                        clockConfig->ClockPolarity,clockConfig->ClockFilter);\n      timerHandle->Instance->SMCR = timerHandle->Instance->SMCR | 0x4000;\n    }\n    timerHandle->State = HAL_TIM_STATE_READY;\n    timerHandle->Lock = HAL_UNLOCKED;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003a94": "configure_timer_clock_08003a94",
                "htim": "timerHandle",
                "sClockSourceConfig": "clockConfig",
                "HVar1": "status",
                "uVar2": "clockSource",
                "sClockSourceConfig_local": "localClockConfig",
                "htim_local": "localTimerHandle",
                "tmpsmcr": "tmpSMCR"
            },
            "calling": [
                "MX_TIM2_Init",
                "MX_TIM1_Init"
            ],
            "called": [
                "TIM_ETR_SetConfig",
                "TIM_TI2_ConfigInputStage",
                "TIM_TI1_ConfigInputStage",
                "TIM_ITRx_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c4a": {
            "entrypoint": "0x08003c4a",
            "current_name": "initialize_timer_08003c4a",
            "code": "\nvoid initializeTimer_08003c4a(TIM_HandleTypeDef *timer)\n\n{\n  TIM_HandleTypeDef *localTimer;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c4a": "initialize_timer_08003c4a",
                "htim": "timer",
                "htim_local": "localTimer"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c5c": {
            "entrypoint": "0x08003c5c",
            "current_name": "initialize_timer_08003c5c",
            "code": "\nvoid initializeTimer_08003c5c(TIM_HandleTypeDef *timer)\n\n{\n  TIM_HandleTypeDef *localTimer;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c5c": "initialize_timer_08003c5c",
                "htim": "timer",
                "htim_local": "localTimer"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c6e": {
            "entrypoint": "0x08003c6e",
            "current_name": "initialize_timer_08003c6e",
            "code": "\nvoid initialize_timer_08003c6e(TIM_HandleTypeDef *timer_handle)\n\n{\n  TIM_HandleTypeDef *timer_handle_local;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c6e": "initialize_timer_08003c6e",
                "htim": "timer_handle"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c80": {
            "entrypoint": "0x08003c80",
            "current_name": "initialize_timer_08003c80",
            "code": "\nvoid initialize_timer_08003c80(TIM_HandleTypeDef *timer_handler)\n\n{\n  TIM_HandleTypeDef *local_timer_handler;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c80": "initialize_timer_08003c80",
                "htim": "timer_handler",
                "htim_local": "local_timer_handler"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c94": {
            "entrypoint": "0x08003c94",
            "current_name": "initialize_timer_08003c94",
            "code": "\nvoid initializeTimer_08003c94(TIM_TypeDef *timer,TIM_Base_InitTypeDef *initStructure)\n\n{\n  TIM_Base_InitTypeDef *localInitStructure;\n  TIM_TypeDef *localTimer;\n  uint32_t tempCR1;\n  \n  tempCR1 = timer->CR1;\n  if ((((timer == (TIM_TypeDef *)0x40012c00) || (timer == (TIM_TypeDef *)0x40000000)) ||\n      (timer == (TIM_TypeDef *)0x40000400)) || (timer == (TIM_TypeDef *)0x40000800)) {\n    tempCR1 = initStructure->CounterMode | tempCR1 & 0xffffff8f;\n  }\n  if (((timer == (TIM_TypeDef *)0x40012c00) || (timer == (TIM_TypeDef *)0x40000000)) ||\n     ((timer == (TIM_TypeDef *)0x40000400 || (timer == (TIM_TypeDef *)0x40000800)))) {\n    tempCR1 = initStructure->ClockDivision | tempCR1 & 0xfffffcff;\n  }\n  timer->CR1 = initStructure->AutoReloadPreload | tempCR1 & 0xffffff7f;\n  timer->ARR = initStructure->Period;\n  timer->PSC = initStructure->Prescaler;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    uRam40012c30 = initStructure->RepetitionCounter;\n  }\n  timer->EGR = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c94": "initialize_timer_08003c94",
                "TIMx": "timer",
                "Structure": "initStructure",
                "Structure_local": "localInitStructure",
                "TIMx_local": "localTimer",
                "tmpcr1": "tempCR1"
            },
            "calling": [
                "HAL_TIM_PWM_Init",
                "HAL_TIM_Base_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d60": {
            "entrypoint": "0x08003d60",
            "current_name": "initialize_timer_08003d60",
            "code": "\nvoid initializeTimer_08003d60(TIM_TypeDef *timer,TimerOutputCompareConfig *config)\n\n{\n  uint ocMode;\n  uint32_t ocPolarity;\n  TimerOutputCompareConfig *localConfig;\n  TIM_TypeDef *localTimer;\n  uint32_t modifiedCcmRx;\n  uint32_t modifiedCr2;\n  uint32_t modifiedCcer;\n  \n  timer->CCER = timer->CCER & 0xfffffffe;\n  modifiedCr2 = timer->CR2;\n  ocMode = config->OCMode;\n  ocPolarity = config->OCPolarity | timer->CCER & 0xfffffffd;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    ocPolarity = (config->OCNPolarity | ocPolarity & 0xfffffff7) & 0xfffffffb;\n    modifiedCr2 = config->OCNIdleState | config->OCIdleState | modifiedCr2 & 0xfffffcff;\n  }\n  timer->CR2 = modifiedCr2;\n  timer->CCMR1 = ocMode | timer->CCMR1 & 0xffffff8c;\n  timer->CCR1 = config->Pulse;\n  timer->CCER = ocPolarity;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003d60": "initialize_timer_08003d60",
                "TIMx": "timer",
                "OC_Config": "config",
                "TIM_OC_InitTypeDef": "TimerOutputCompareConfig",
                "uVar1": "ocMode",
                "uVar2": "ocPolarity",
                "OC_Config_local": "localConfig",
                "TIMx_local": "localTimer",
                "tmpccmrx": "modifiedCcmRx",
                "tmpcr2": "modifiedCr2",
                "tmpccer": "modifiedCcer"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e38": {
            "entrypoint": "0x08003e38",
            "current_name": "configure_timer_output_channel_08003e38",
            "code": "\nvoid configureTimerOutputChannel_08003e38(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputChannelConfig)\n\n{\n  uint32_t outputChannelMode;\n  uint32_t outputChannelPolarity;\n  TIM_OC_InitTypeDef *localOutputChannelConfig;\n  TIM_TypeDef *localTimer;\n  uint32_t temporaryCCMRX;\n  uint32_t temporaryCR2;\n  uint32_t temporaryCCER;\n  \n  timer->CCER = timer->CCER & 0xffffffef;\n  temporaryCR2 = timer->CR2;\n  outputChannelMode = outputChannelConfig->OCMode;\n  outputChannelPolarity = outputChannelConfig->OCPolarity << 4 | timer->CCER & 0xffffffdf;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    outputChannelPolarity = (outputChannelConfig->OCNPolarity << 4 | outputChannelPolarity & 0xffffff7f) & 0xffffffbf;\n    temporaryCR2 = outputChannelConfig->OCNIdleState << 2 | outputChannelConfig->OCIdleState << 2 | temporaryCR2 & 0xfffff3ff;\n  }\n  timer->CR2 = temporaryCR2;\n  timer->CCMR1 = outputChannelMode << 8 | timer->CCMR1 & 0xffff8cff;\n  timer->CCR2 = outputChannelConfig->Pulse;\n  timer->CCER = outputChannelPolarity;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e38": "configure_timer_output_channel_08003e38",
                "TIMx": "timer",
                "OC_Config": "outputChannelConfig",
                "OC_Config_local": "localOutputChannelConfig",
                "TIMx_local": "localTimer",
                "tmpccmrx": "temporaryCCMRX",
                "tmpcr2": "temporaryCR2",
                "tmpccer": "temporaryCCER",
                "uVar1": "outputChannelMode",
                "uVar2": "outputChannelPolarity"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f18": {
            "entrypoint": "0x08003f18",
            "current_name": "configure_timer_output_08003f18",
            "code": "\nvoid configureTimerOutput_08003f18(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputConfig)\n\n{\n  uint ocMode;\n  uint32_t ocPolarity;\n  TIM_OC_InitTypeDef *outputConfigLocal;\n  TIM_TypeDef *timerLocal;\n  uint32_t temporaryCCMRX;\n  uint32_t temporaryCR2;\n  uint32_t temporaryCCER;\n  \n  timer->CCER = timer->CCER & 0xfffffeff;\n  temporaryCR2 = timer->CR2;\n  ocMode = outputConfig->OCMode;\n  ocPolarity = outputConfig->OCPolarity << 8 | timer->CCER & 0xfffffdff;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    ocPolarity = (outputConfig->OCNPolarity << 8 | ocPolarity & 0xfffff7ff) & 0xfffffbff;\n    temporaryCR2 = outputConfig->OCNIdleState << 4 | outputConfig->OCIdleState << 4 | temporaryCR2 & 0xffffcfff;\n  }\n  timer->CR2 = temporaryCR2;\n  timer->CCMR2 = ocMode | timer->CCMR2 & 0xffffff8c;\n  timer->CCR3 = outputConfig->Pulse;\n  timer->CCER = ocPolarity;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f18": "configure_timer_output_08003f18",
                "TIMx": "timer",
                "OC_Config": "outputConfig",
                "OC_Config_local": "outputConfigLocal",
                "TIMx_local": "timerLocal",
                "tmpccmrx": "temporaryCCMRX",
                "tmpcr2": "temporaryCR2",
                "tmpccer": "temporaryCCER",
                "uVar1": "ocMode",
                "uVar2": "ocPolarity"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ff8": {
            "entrypoint": "0x08003ff8",
            "current_name": "configure_timer_output_08003ff8",
            "code": "\nvoid configureTimerOutput_08003ff8(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputConfig)\n\n{\n  uint32_t outputMode;\n  uint32_t outputPolarity;\n  TIM_OC_InitTypeDef *outputConfigLocal;\n  TIM_TypeDef *timerLocal;\n  uint32_t temporaryCCER;\n  uint32_t temporaryCCMRX;\n  uint32_t temporaryCR2;\n  \n  timer->CCER = timer->CCER & 0xffffefff;\n  temporaryCR2 = timer->CR2;\n  outputMode = outputConfig->OCMode;\n  outputPolarity = outputConfig->OCPolarity;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    temporaryCR2 = outputConfig->OCIdleState << 6 | temporaryCR2 & 0xffffbfff;\n  }\n  timer->CR2 = temporaryCR2;\n  timer->CCMR2 = outputMode << 8 | timer->CCMR2 & 0xffff8cff;\n  timer->CCR4 = outputConfig->Pulse;\n  timer->CCER = outputPolarity << 0xc | timer->CCER & 0xffffdfff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ff8": "configure_timer_output_08003ff8",
                "TIMx": "timer",
                "OC_Config": "outputConfig",
                "OC_Config_local": "outputConfigLocal",
                "TIMx_local": "timerLocal",
                "tmpccer": "temporaryCCER",
                "tmpccmrx": "temporaryCCMRX",
                "tmpcr2": "temporaryCR2",
                "uVar1": "outputMode",
                "uVar2": "outputPolarity"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040a0": {
            "entrypoint": "0x080040a0",
            "current_name": "configure_timer_input_capture_080040a0",
            "code": "\nvoid configureTimerInputCapture_080040a0(TIM_TypeDef *timer,uint32_t inputCapturePolarity,uint32_t inputCaptureFilter)\n\n{\n  uint ccerValue;\n  uint32_t localInputCaptureFilter;\n  uint32_t localInputCapturePolarity;\n  TIM_TypeDef *localTimer;\n  uint32_t newCcerValue;\n  uint32_t newCcmr1Value;\n  \n  ccerValue = timer->CCER;\n  timer->CCER = timer->CCER & 0xfffffffe;\n  timer->CCMR1 = inputCaptureFilter << 4 | timer->CCMR1 & 0xffffff0f;\n  timer->CCER = inputCapturePolarity | ccerValue & 0xfffffff5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040a0": "configure_timer_input_capture_080040a0",
                "TIMx": "timer",
                "TIM_ICPolarity": "inputCapturePolarity",
                "TIM_ICFilter": "inputCaptureFilter",
                "uVar1": "ccerValue",
                "TIM_ICFilter_local": "localInputCaptureFilter",
                "TIM_ICPolarity_local": "localInputCapturePolarity",
                "TIMx_local": "localTimer",
                "tmpccer": "newCcerValue",
                "tmpccmr1": "newCcmr1Value"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004104": {
            "entrypoint": "0x08004104",
            "current_name": "configure_input_capture_08004104",
            "code": "\nvoid configureInputCapture_08004104(TIM_TypeDef *timer,uint32_t inputCapturePolarity,uint32_t inputCaptureFilter)\n\n{\n  uint32_t localInputCaptureFilter;\n  uint32_t localInputCapturePolarity;\n  TIM_TypeDef *localTimer;\n  uint32_t temporaryCCER;\n  uint32_t temporaryCCMR1;\n  \n  timer->CCER = timer->CCER & 0xffffffef;\n  timer->CCMR1 = inputCaptureFilter << 0xc | timer->CCMR1 & 0xffff0fff;\n  timer->CCER = inputCapturePolarity << 4 | timer->CCER & 0xffffff5f;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004104": "configure_input_capture_08004104",
                "TIMx": "timer",
                "TIM_ICPolarity": "inputCapturePolarity",
                "TIM_ICFilter": "inputCaptureFilter",
                "TIM_ICFilter_local": "localInputCaptureFilter",
                "TIM_ICPolarity_local": "localInputCapturePolarity",
                "TIMx_local": "localTimer",
                "tmpccer": "temporaryCCER",
                "tmpccmr1": "temporaryCCMR1"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800416a": {
            "entrypoint": "0x0800416a",
            "current_name": "configure_input_trigger_0800416a",
            "code": "\nvoid configureInputTrigger_0800416a(TIM_TypeDef *timer,uint16_t inputSource)\n\n{\n  uint16_t localInputSource;\n  TIM_TypeDef *localTimer;\n  uint32_t tempSMCR;\n  \n  timer->SMCR = timer->SMCR & 0xffffff8f | (uint)(inputSource | 7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800416a": "configure_input_trigger_0800416a",
                "TIMx": "timer",
                "InputTriggerSource": "inputSource",
                "InputTriggerSource_local": "localInputSource",
                "TIMx_local": "localTimer",
                "tmpsmcr": "tempSMCR"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041a8": {
            "entrypoint": "0x080041a8",
            "current_name": "set_external_trigger_080041a8",
            "code": "\nvoid setExternalTrigger_080041a8(TIM_TypeDef *timer,uint32_t prescaler,uint32_t polarity,\n                 uint32_t filter)\n\n{\n  uint32_t localFilter;\n  uint32_t localPolarity;\n  uint32_t localPrescaler;\n  TIM_TypeDef *localTimer;\n  uint32_t temporarySmcr;\n  \n  timer->SMCR = prescaler | filter << 8 | polarity |\n               timer->SMCR & 0xffff00ff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041a8": "set_external_trigger_080041a8",
                "TIMx": "timer",
                "TIM_ExtTRGPrescaler": "prescaler",
                "TIM_ExtTRGPolarity": "polarity",
                "ExtTRGFilter": "filter",
                "ExtTRGFilter_local": "localFilter",
                "TIM_ExtTRGPolarity_local": "localPolarity",
                "TIM_ExtTRGPrescaler_local": "localPrescaler",
                "TIMx_local": "localTimer",
                "tmpsmcr": "temporarySmcr"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041ea": {
            "entrypoint": "0x080041ea",
            "current_name": "update_channel_state_080041ea",
            "code": "\nvoid updateChannelState_080041ea(TIM_TypeDef *timer,uint32_t channelNumber,uint32_t newState)\n\n{\n  uint32_t localChannelState;\n  uint32_t localChannel;\n  TIM_TypeDef *localTimer;\n  uint32_t temporary;\n  \n  timer->CCER = timer->CCER & ~(1 << (channelNumber & 0xff));\n  timer->CCER = timer->CCER | newState << (channelNumber & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041ea": "update_channel_state_080041ea",
                "TIMx": "timer",
                "Channel": "channelNumber",
                "ChannelState": "newState",
                "ChannelState_local": "localChannelState",
                "Channel_local": "localChannel",
                "TIMx_local": "localTimer",
                "tmp": "temporary"
            },
            "calling": [
                "HAL_TIM_PWM_Start"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800422e": {
            "entrypoint": "0x0800422e",
            "current_name": "configure_break_dead_time_0800422e",
            "code": "\nHAL_StatusTypeDef\nconfigureBreakDeadTime_0800422e(TIM_HandleTypeDef *timer,TIM_BreakDeadTimeConfigTypeDef *breakDeadTimeConfig)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_BreakDeadTimeConfigTypeDef *config_local;\n  TIM_HandleTypeDef *timer_local;\n  uint32_t bdtr_tmp;\n  \n  if (timer->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    timer->Lock = HAL_LOCKED;\n    timer->Instance->BDTR =\n         breakDeadTimeConfig->AutomaticOutput |\n         (breakDeadTimeConfig->AutomaticOutput |\n         (breakDeadTimeConfig->BreakPolarity |\n         (breakDeadTimeConfig->BreakState |\n         (breakDeadTimeConfig->OffStateRunMode |\n         (breakDeadTimeConfig->OffStateIDLEMode |\n         (breakDeadTimeConfig->LockLevel | breakDeadTimeConfig->DeadTime & 0xfffffcff) &\n         0xfffffbff) & 0xfffff7ff) & 0xffffefff) & 0xffffdfff) & 0xffffbfff) & 0xffff7fff;\n    timer->Lock = HAL_UNLOCKED;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800422e": "configure_break_dead_time_0800422e",
                "htim": "timer",
                "sBreakDeadTimeConfig": "breakDeadTimeConfig",
                "HVar1": "status",
                "sBreakDeadTimeConfig_local": "config_local",
                "htim_local": "timer_local",
                "tmpbdtr": "bdtr_tmp"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042de": {
            "entrypoint": "0x080042de",
            "current_name": "configure_tim_master_080042de",
            "code": "\nHAL_StatusTypeDef configureTIMMaster_080042de(TIM_HandleTypeDef *timerHandle,TIM_MasterConfigTypeDef *masterConfig)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_MasterConfigTypeDef *localMasterConfig;\n  TIM_HandleTypeDef *localTimerHandle;\n  \n  if (timerHandle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    timerHandle->Lock = HAL_LOCKED;\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    timerHandle->Instance->CR2 = timerHandle->Instance->CR2 & 0xffffff8f;\n    timerHandle->Instance->CR2 = masterConfig->MasterOutputTrigger | timerHandle->Instance->CR2;\n    timerHandle->Instance->SMCR = timerHandle->Instance->SMCR & 0xffffff7f;\n    timerHandle->Instance->SMCR = masterConfig->MasterSlaveMode | timerHandle->Instance->SMCR;\n    timerHandle->State = HAL_TIM_STATE_READY;\n    timerHandle->Lock = HAL_UNLOCKED;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080042de": "configure_tim_master_080042de",
                "htim": "timerHandle",
                "sMasterConfig": "masterConfig",
                "HVar1": "status",
                "sMasterConfig_local": "localMasterConfig",
                "htim_local": "localTimerHandle"
            },
            "calling": [
                "MX_TIM2_Init",
                "MX_TIM1_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004366": {
            "entrypoint": "0x08004366",
            "current_name": "initialize_timer_08004366",
            "code": "\nvoid initialize_timer_08004366(TIM_HandleTypeDef *timer_handle)\n\n{\n  TIM_HandleTypeDef *timer_handle_local;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08004366": "initialize_timer_08004366",
                "htim": "timer_handle"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004378": {
            "entrypoint": "0x08004378",
            "current_name": "initialize_timer_08004378",
            "code": "\nvoid initialize_timer_08004378(TIM_HandleTypeDef *timer_handler)\n\n{\n  TIM_HandleTypeDef *timer_handler_local;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08004378": "initialize_timer_08004378",
                "htim": "timer_handler"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800438a": {
            "entrypoint": "0x0800438a",
            "current_name": "initialize_uart_0800438a",
            "code": "\nHAL_StatusTypeDef initializeUART_0800438a(UART_HandleTypeDef *uartHandle)\n\n{\n  HAL_StatusTypeDef status;\n  UART_HandleTypeDef *localUartHandle;\n  \n  if (uartHandle == (UART_HandleTypeDef *)0x0) {\n    status = HAL_ERROR;\n  }\n  else {\n    if (uartHandle->gState == HAL_UART_STATE_RESET) {\n      uartHandle->Lock = HAL_UNLOCKED;\n      HAL_UART_MspInit(uartHandle);\n    }\n    uartHandle->gState = HAL_UART_STATE_BUSY;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xffffdfff;\n    UART_SetConfig(uartHandle);\n    uartHandle->Instance->CR2 = uartHandle->Instance->CR2 & 0xffffb7ff;\n    uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xffffffd5;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x2000;\n    uartHandle->ErrorCode = 0;\n    uartHandle->gState = HAL_UART_STATE_READY;\n    uartHandle->RxState = HAL_UART_STATE_READY;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800438a": "initialize_uart_0800438a",
                "huart": "uartHandle",
                "HVar1": "status",
                "huart_local": "localUartHandle"
            },
            "calling": [
                "MX_USART1_UART_Init"
            ],
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004424": {
            "entrypoint": "0x08004424",
            "current_name": "initialize_uart_08004424",
            "code": "\nvoid initialize_uart_08004424(UART_HandleTypeDef *uart_handler)\n\n{\n  UART_HandleTypeDef *local_uart_handler;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08004424": "initialize_uart_08004424",
                "huart": "uart_handler",
                "huart_local": "local_uart_handler"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004436": {
            "entrypoint": "0x08004436",
            "current_name": "transmit_data_08004436",
            "code": "\nHAL_StatusTypeDef\ntransmitData_08004436(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t size,uint32_t timeout)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  HAL_StatusTypeDef status;\n  int errorCode;\n  uint32_t localTimeout;\n  uint16_t localSize;\n  uint8_t *localData;\n  UART_HandleTypeDef *localUartHandle;\n  uint16_t *temp;\n  uint32_t startTick;\n  \n  if (uartHandle->gState == HAL_UART_STATE_READY) {\n    if ((data == (uint8_t *)0x0) || (size == 0)) {\n      status = HAL_ERROR;\n    }\n    else if (uartHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      uartHandle->Lock = HAL_LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n      uVar1 = HAL_GetTick();\n      uartHandle->TxXfersize = size;\n      uartHandle->TxXferCount = size;\n      localData = data;\n      while (uartHandle->TxXferCount != 0) {\n        uartHandle->TxXferCount = uartHandle->TxXferCount - 1;\n        if ((uartHandle->Init).WordLength == 0x1000) {\n          do {\n            if ((uartHandle->Instance->SR & 0x80) == 0x80) {\n              errorCode = 0;\n              goto LAB_0800454c;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (uVar2 = HAL_GetTick(), uVar2 - uVar1 <= timeout))));\n          uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffe5f;\n          uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n          uartHandle->gState = HAL_UART_STATE_READY;\n          uartHandle->RxState = HAL_UART_STATE_READY;\n          uartHandle->Lock = HAL_UNLOCKED;\n          errorCode = 3;\nLAB_0800454c:\n          if (errorCode != 0) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = *(ushort *)localData & 0x1ff;\n          if ((uartHandle->Init).Parity == 0) {\n            localData = localData + 2;\n          }\n          else {\n            localData = localData + 1;\n          }\n        }\n        else {\n          do {\n            if ((uartHandle->Instance->SR & 0x80) == 0x80) {\n              errorCode = 0;\n              goto LAB_08004614;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (uVar2 = HAL_GetTick(), uVar2 - uVar1 <= timeout))));\n          uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffe5f;\n          uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n          uartHandle->gState = HAL_UART_STATE_READY;\n          uartHandle->RxState = HAL_UART_STATE_READY;\n          uartHandle->Lock = HAL_UNLOCKED;\n          errorCode = 3;\nLAB_08004614:\n          if (errorCode != 0) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = (uint)*localData;\n          localData = localData + 1;\n        }\n      }\n      do {\n        if ((uartHandle->Instance->SR & 0x40) == 0x40) {\n          errorCode = 0;\n          goto LAB_080046c6;\n        }\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (uVar2 = HAL_GetTick(), uVar2 - uVar1 <= timeout))));\n      uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffe5f;\n      uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n      uartHandle->gState = HAL_UART_STATE_READY;\n      uartHandle->RxState = HAL_UART_STATE_READY;\n      uartHandle->Lock = HAL_UNLOCKED;\n      errorCode = 3;\nLAB_080046c6:\n      if (errorCode == 0) {\n        uartHandle->gState = HAL_UART_STATE_READY;\n        uartHandle->Lock = HAL_UNLOCKED;\n        status = HAL_OK;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08004436": "transmit_data_08004436",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "HVar3": "status",
                "iVar4": "errorCode",
                "Timeout_local": "localTimeout",
                "Size_local": "localSize",
                "pData_local": "localData",
                "huart_local": "localUartHandle",
                "tmp": "temp",
                "tickstart": "startTick"
            },
            "calling": [
                "uart_print"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046ec": {
            "entrypoint": "0x080046ec",
            "current_name": "configure_uart_080046ec",
            "code": "\nvoid configureUart_080046ec(UART_HandleTypeDef *uartHandle)\n\n{\n  uint32_t pclkFreq1;\n  uint32_t pclkFreq2;\n  uint32_t pclkFreq3;\n  uint32_t pclkFreq4;\n  uint32_t pclkFreq5;\n  uint32_t baudRate1;\n  uint32_t baudRate2;\n  uint32_t baudRate3;\n  uint32_t baudRate4;\n  UART_HandleTypeDef *localUartHandle;\n  uint32_t temporaryRegister;\n  \n  uartHandle->Instance->CR2 = (uartHandle->Init).StopBits | uartHandle->Instance->CR2 & 0xffffcfff;\n  uartHandle->Instance->CR1 =\n       uartHandle->Instance->CR1 & 0xffffe9f3 |\n       (uartHandle->Init).Mode | (uartHandle->Init).WordLength | (uartHandle->Init).Parity;\n  uartHandle->Instance->CR3 = (uartHandle->Init).HwFlowCtl | uartHandle->Instance->CR3 & 0xfffffcff;\n  if (uartHandle->Instance == (USART_TypeDef *)0x40013800) {\n    pclkFreq1 = HAL_RCC_GetPCLK2Freq();\n    baudRate1 = (uartHandle->Init).BaudRate;\n    pclkFreq2 = HAL_RCC_GetPCLK2Freq();\n    baudRate2 = (uartHandle->Init).BaudRate;\n    pclkFreq3 = HAL_RCC_GetPCLK2Freq();\n    baudRate3 = (uartHandle->Init).BaudRate;\n    pclkFreq4 = HAL_RCC_GetPCLK2Freq();\n    baudRate4 = (uartHandle->Init).BaudRate;\n    pclkFreq5 = HAL_RCC_GetPCLK2Freq();\n    uartHandle->Instance->BRR =\n         ((((pclkFreq4 * 0x19) / (baudRate4 << 2) +\n           (int)(((ulonglong)(pclkFreq5 * 0x19) / (ulonglong)((uartHandle->Init).BaudRate << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) +\n         (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(baudRate1 << 2)) / 100) * 0x10 +\n         ((((pclkFreq2 * 0x19) / (baudRate2 << 2) +\n           (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(baudRate3 << 2)) / 100) * -100) * 0x10 + 0x32)\n          / 100 & 0xf0);\n  }\n  else {\n    pclkFreq1 = HAL_RCC_GetPCLK1Freq();\n    baudRate1 = (uartHandle->Init).BaudRate;\n    pclkFreq2 = HAL_RCC_GetPCLK1Freq();\n    baudRate2 = (uartHandle->Init).BaudRate;\n    pclkFreq3 = HAL_RCC_GetPCLK1Freq();\n    baudRate3 = (uartHandle->Init).BaudRate;\n    pclkFreq4 = HAL_RCC_GetPCLK1Freq();\n    baudRate4 = (uartHandle->Init).BaudRate;\n    pclkFreq5 = HAL_RCC_GetPCLK1Freq();\n    uartHandle->Instance->BRR =\n         ((((pclkFreq4 * 0x19) / (baudRate4 << 2) +\n           (int)(((ulonglong)(pclkFreq5 * 0x19) / (ulonglong)((uartHandle->Init).BaudRate << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) +\n         (int)(((ulonglong)(pclkFreq1 * 0x19) / (ulonglong)(baudRate1 << 2)) / 100) * 0x10 +\n         ((((pclkFreq2 * 0x19) / (baudRate2 << 2) +\n           (int)(((ulonglong)(pclkFreq3 * 0x19) / (ulonglong)(baudRate3 << 2)) / 100) * -100) * 0x10 + 0x32)\n          / 100 & 0xf0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046ec": "configure_uart_080046ec",
                "huart": "uartHandle",
                "uVar1": "pclkFreq1",
                "uVar2": "pclkFreq2",
                "uVar3": "pclkFreq3",
                "uVar4": "pclkFreq4",
                "uVar5": "pclkFreq5",
                "uVar6": "baudRate1",
                "uVar7": "baudRate2",
                "uVar8": "baudRate3",
                "uVar9": "baudRate4",
                "huart_local": "localUartHandle",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800491c": {
            "entrypoint": "0x0800491c",
            "current_name": "initialize_mpu6050_0800491c",
            "code": "\nvoid initialize_mpu6050_0800491c(Mpu6050 *sensor)\n\n{\n  Mpu6050 *sensor_local;\n  uint8_t write_value;\n  uint8_t register_value;\n  uint8_t command_buffer [5];\n  \n  write_value = '\\0';\n  (*I2C_Write_Reg)(0xd0,'k',&write_value,1);\n  register_value = '\\x10';\n  (*I2C_Write_Reg)(0xd0,'\\x1c',&register_value,1);\n  command_buffer[0] = '\\b';\n  (*I2C_Write_Reg)(0xd0,'\\x1b',command_buffer,1);\n  sensor->accX = 0.0;\n  sensor->accY = 0.0;\n  sensor->accZ = 0.0;\n  sensor->temp = 0.0;\n  sensor->gyroX = 0.0;\n  sensor->gyroY = 0.0;\n  sensor->gyroZ = 0.0;\n  sensor->offset_gyroX = 0.0;\n  sensor->offset_gyroY = 0.0;\n  sensor->offset_acc_pitch = 0.0;\n  sensor->offset_acc_roll = 0.0;\n  sensor_calibrate(sensor);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800491c": "initialize_mpu6050_0800491c",
                "mpu6050": "sensor",
                "local_13": "write_value",
                "local_12": "register_value",
                "local_11": "command_buffer"
            },
            "calling": [
                "main"
            ],
            "called": [
                "mpu6050_calibrate"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049cc": {
            "entrypoint": "0x080049cc",
            "current_name": "calculate_offsets_080049cc",
            "code": "\nvoiteratord calculateOffsets_080049cc(IMU *imu)\n\n{\n  undefiteratorned4 uVar1;\n  float fVar2;\n  IMU *imu_local;\n  float accelerometerRoll;\n  float accelerometerPitch;\n  uiteratornt32_t currentTimestamp;\n  iteratornt sampleCount;\n  iteratornt iterator;\n  float offsetRoll;\n  float offsetPitch;\n  float offsetGyroY;\n  float offsetGyroX;\n  \n  sampleCount = 1;\n  offsetGyroX = 0.0;\n  offsetGyroY = 0.0;\n  offsetPitch = 0.0;\n  offsetRoll = 0.0;\n  currentTimestamp = (*getMilliseconds)();\n  iterator = 0;\n  whiteratorle( true ) {\n    iteratorf (sampleCount <= iterator) break;\n    accelerometerPitch = 0.0;\n    accelerometerRoll = 0.0;\n    imu_update(imu);\n    imu_calc_accelerometerPitch_roll(imu,&accelerometerPitch,&accelerometerRoll);\n    offsetPitch = (float)__addsf3(offsetPitch,accelerometerPitch);\n    offsetRoll = (float)__addsf3(offsetRoll,accelerometerRoll);\n    offsetGyroX = (float)__addsf3(offsetGyroX,imu->gyroX);\n    offsetGyroY = (float)__addsf3(offsetGyroY,imu->gyroY);\n    currentTimestamp = (*getMilliseconds)();\n    iterator = iterator + 1;\n  }\n  uVar1 = __floatsiteratorsf(sampleCount);\n  fVar2 = (float)__aeabiterator_fditeratorv(offsetGyroX,uVar1);\n  imu->offsetGyroX = fVar2;\n  uVar1 = __floatsiteratorsf(sampleCount);\n  fVar2 = (float)__aeabiterator_fditeratorv(offsetGyroY,uVar1);\n  imu->offsetGyroY = fVar2;\n  uVar1 = __floatsiteratorsf(sampleCount);\n  fVar2 = (float)__aeabiterator_fditeratorv(offsetPitch,uVar1);\n  imu->offset_accelerometerPitch = fVar2;\n  uVar1 = __floatsiteratorsf(sampleCount);\n  fVar2 = (float)__aeabiterator_fditeratorv(offsetRoll,uVar1);\n  imu->offset_accelerometerRoll = fVar2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080049cc": "calculate_offsets_080049cc",
                "Mpu6050": "IMU",
                "mpu6050": "imu",
                "acc_roll": "accelerometerRoll",
                "acc_pitch": "accelerometerPitch",
                "now": "currentTimestamp",
                "num_samples": "sampleCount",
                "i": "iterator",
                "offset_accRoll": "offsetRoll",
                "offset_accPitch": "offsetPitch",
                "offset_gyroY": "offsetGyroY",
                "offset_gyroX": "offsetGyroX",
                "Get_ms_tick": "getMilliseconds"
            },
            "calling": [
                "mpu6050_init"
            ],
            "called": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_update",
                "__addsf3",
                "__aeabi_fdiv",
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ae0": {
            "entrypoint": "0x08004ae0",
            "current_name": "read_mpu6050_data_08004ae0",
            "code": "\nvoid readMpu6050Data_08004ae0(Mpu6050 *sensor)\n\n{\n  floatemperature fVar1;\n  Mpu6050 *sensor_local;\n  uintemperature8_temperature rawData [14];\n  intemperature16_temperature gyroZ;\n  intemperature16_temperature gyroY;\n  intemperature16_temperature gyroX;\n  intemperature16_temperature temperature;\n  intemperature16_temperature accZ;\n  intemperature16_temperature accY;\n  intemperature16_temperature accX;\n  \n  (*readI2CRegister)(0xd0,';',rawData,0xe);\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[0],rawData[1]));\n  sensor->accX = fVar1;\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[2],rawData[3]));\n  sensor->accY = fVar1;\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[4],rawData[5]));\n  sensor->accZ = fVar1;\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[6],rawData[7]));\n  sensor->temperatureemp = fVar1;\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[8],rawData[9]));\n  sensor->gyroYroX = fVar1;\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[10],rawData[11]));\n  sensor->gyroYroY = fVar1;\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[12],rawData[13]));\n  sensor->gyroYroZ = fVar1;\n  retemperatureurn;\n}\n\n",
            "renaming": {
                "FUN_08004ae0": "read_mpu6050_data_08004ae0",
                "mpu6050": "sensor",
                "raw": "rawData",
                "gz": "gyroZ",
                "gy": "gyroY",
                "gx": "gyroX",
                "t": "temperature",
                "az": "accZ",
                "ay": "accY",
                "ax": "accX",
                "I2C_Read_Reg": "readI2CRegister"
            },
            "calling": [
                "mpu6050_calibrate",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bd8": {
            "entrypoint": "0x08004bd8",
            "current_name": "calculate_pitch_08004bd8",
            "code": "\nvoid calculatePitch_08004bd8(Mpu6050 *mpu6050,float *pitch)\n\n{\n  undefined4 gyroDiff;\n  float truncatedDiff;\n  undefined8 totalPitchDouble;\n  undefined8 tempDouble;\n  float *pitch_local;\n  Mpu6050 *mpu6050_local;\n  float accelerometerPitch;\n  float gyroX;\n  \n  gyroDiff = __aeabi_fsub(mpu6050->gyroX,mpu6050->offset_gyroX);\n  totalPitchDouble = __aeabi_f2d(mpu6050_calc_pitch::total_pitch);\n  tempDouble = __aeabi_f2d(gyroDiff);\n  tempDouble = __muldf3((int)tempDouble,(int)((ulonglong)tempDouble >> 0x20),0x83f5c366,0x3f340215);\n  totalPitchDouble = __aeabi_dadd((int)totalPitchDouble,(int)((ulonglong)totalPitchDouble >> 0x20),(int)tempDouble,\n                       (int)((ulonglong)tempDouble >> 0x20));\n  mpu6050_calc_pitch::total_pitch = (float)__truncdfsf2((int)totalPitchDouble,(int)((ulonglong)totalPitchDouble >> 0x20));\n  totalPitchDouble = __aeabi_f2d(mpu6050->accY);\n  totalPitchDouble = __divdf3((int)totalPitchDouble,(int)((ulonglong)totalPitchDouble >> 0x20),0,0x40b00000);\n  tempDouble = __aeabi_f2d(mpu6050->accZ);\n  tempDouble = __divdf3((int)tempDouble,(int)((ulonglong)tempDouble >> 0x20),0,0x40b00000);\n  totalPitchDouble = atan2((int)totalPitchDouble,(int)((ulonglong)totalPitchDouble >> 0x20),(int)tempDouble,\n                (int)((ulonglong)tempDouble >> 0x20));\n  totalPitchDouble = __muldf3((int)totalPitchDouble,(int)((ulonglong)totalPitchDouble >> 0x20),0,0x40668000);\n  totalPitchDouble = __divdf3((int)totalPitchDouble,(int)((ulonglong)totalPitchDouble >> 0x20),0x54442d18,0x400921fb);\n  tempDouble = __aeabi_f2d(mpu6050->offset_accelerometerPitch);\n  totalPitchDouble = __subdf3((int)totalPitchDouble,(int)((ulonglong)totalPitchDouble >> 0x20),(int)tempDouble,\n                   (int)((ulonglong)tempDouble >> 0x20));\n  totalPitchDouble = __aeabi_dadd((int)totalPitchDouble,(int)((ulonglong)totalPitchDouble >> 0x20),0,0x40568000);\n  truncatedDiff = (float)__truncdfsf2((int)totalPitchDouble,(int)((ulonglong)totalPitchDouble >> 0x20));\n  if (mpu6050_calc_pitch::first_run == false) {\n    totalPitchDouble = __aeabi_f2d(mpu6050_calc_pitch::total_pitch);\n    totalPitchDouble = __muldf3((int)totalPitchDouble,(int)((ulonglong)totalPitchDouble >> 0x20),0x9999999a,0x3fe99999);\n    tempDouble = __aeabi_f2d(truncatedDiff);\n    tempDouble = __muldf3((int)tempDouble,(int)((ulonglong)tempDouble >> 0x20),0x9999999a,0x3fc99999);\n    totalPitchDouble = __aeabi_dadd((int)totalPitchDouble,(int)((ulonglong)totalPitchDouble >> 0x20),(int)tempDouble,\n                         (int)((ulonglong)tempDouble >> 0x20));\n    mpu6050_calc_pitch::total_pitch =\n         (float)__truncdfsf2((int)totalPitchDouble,(int)((ulonglong)totalPitchDouble >> 0x20));\n  }\n  else {\n    mpu6050_calc_pitch::first_run = false;\n    mpu6050_calc_pitch::total_pitch = truncatedDiff;\n  }\n  *pitch = mpu6050_calc_pitch::total_pitch;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bd8": "calculate_pitch_08004bd8",
                "acc_pitch": "accelerometerPitch",
                "gyro_x": "gyroX",
                "uVar1": "gyroDiff",
                "fVar2": "truncatedDiff",
                "uVar3": "totalPitchDouble",
                "uVar4": "tempDouble"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_f2d",
                "__aeabi_dadd",
                "__muldf3",
                "__truncdfsf2",
                "__subdf3",
                "__aeabi_fsub",
                "__divdf3",
                "atan2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d78": {
            "entrypoint": "0x08004d78",
            "current_name": "calculate_pitch_and_roll_08004d78",
            "code": "\nvoid calculatePitchAndRoll_08004d78(Mpu6050 *sensor,float *pitchAngle,float *rollAngle)\n\n{\n  undefined4 accXNormalized;\n  undefined4 accYNormalized;\n  undefined4 accZNormalized;\n  float rollAngleRadians;\n  float pitchAngleRadians;\n  undefined8 temp1;\n  undefined8 temp2;\n  float *rollAnglePointer;\n  float *pitchAnglePointer;\n  Mpu6050 *sensorPointer;\n  float rollAcceleration;\n  float pitchAcceleration;\n  float zAcceleration;\n  float yAcceleration;\n  float xAcceleration;\n  \n  accXNormalized = __aeabi_fdiv(sensor->accX,0x45800000);\n  accYNormalized = __aeabi_fdiv(sensor->accY,0x45800000);\n  accZNormalized = __aeabi_fdiv(sensor->accZ,0x45800000);\n  temp1 = __aeabi_f2d(accYNormalized);\n  temp2 = __aeabi_f2d(accZNormalized);\n  temp1 = atan2((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                (int)((ulonglong)temp2 >> 0x20));\n  temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40668000);\n  temp1 = __divdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x54442d18,0x400921fb);\n  rollAngleRadians = (float)__truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  temp1 = __aeabi_f2d(accXNormalized);\n  temp2 = __aeabi_f2d(accZNormalized);\n  temp1 = atan2((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                (int)((ulonglong)temp2 >> 0x20));\n  temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40668000);\n  temp1 = __divdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x54442d18,0x400921fb);\n  pitchAngleRadians = (float)__truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  *pitchAngle = rollAngleRadians;\n  *rollAngle = pitchAngleRadians;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d78": "calculate_pitch_and_roll_08004d78",
                "mpu6050": "sensor",
                "pitch": "pitchAngle",
                "roll": "rollAngle",
                "fVar4": "rollAngleRadians",
                "fVar5": "pitchAngleRadians",
                "uVar1": "accXNormalized",
                "uVar2": "accYNormalized",
                "uVar3": "accZNormalized",
                "uVar6": "temp1",
                "uVar7": "temp2",
                "roll_local": "rollAnglePointer",
                "pitch_local": "pitchAnglePointer",
                "mpu6050_local": "sensorPointer",
                "acc_roll": "rollAcceleration",
                "acc_pitch": "pitchAcceleration",
                "acc_z": "zAcceleration",
                "acc_y": "yAcceleration",
                "acc_x": "xAcceleration"
            },
            "calling": [
                "mpu6050_calibrate"
            ],
            "called": [
                "__aeabi_fdiv",
                "__aeabi_f2d",
                "__muldf3",
                "__truncdfsf2",
                "atan2",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e6c": {
            "entrypoint": "0x08004e6c",
            "current_name": "execute_interrupt_08004e6c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_interrupt_08004e6c(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_08004e6c": "execute_interrupt_08004e6c"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e74": {
            "entrypoint": "0x08004e74",
            "current_name": "execute_afl_call_08004e74",
            "code": "\nint executeAflCall_08004e74(int inputTicks)\n\n{\n  uint32_t callResult;\n  int localTicks;\n  \n  if (noHyperCall == 0) {\n    callResult = aflCall(1,inputTicks,0);\n  }\n  else {\n    callResult = 0;\n  }\n  return callResult;\n}\n\n",
            "renaming": {
                "FUN_08004e74": "execute_afl_call_08004e74",
                "ticks": "inputTicks",
                "uVar1": "callResult",
                "ticks_local": "localTicks"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ea4": {
            "entrypoint": "0x08004ea4",
            "current_name": "write_data_to_i2_c_08004ea4",
            "code": "\nvoid writeDataToI2C_08004ea4(uint8_t address,uint8_t register,uint8_t *dataBuffer,uint16_t dataLength)\n\n{\n  uint8_t *localData;\n  uint16_t localDataLength;\n  uint8_t localRegister;\n  uint8_t localAddress;\n  \n  HAL_I2C_Mem_Write(&hi2c1,(ushort)address,(ushort)register,1,dataBuffer,dataLength,I2C_TIMEOUT);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ea4": "write_data_to_i2_c_08004ea4",
                "addr": "address",
                "reg": "register",
                "data": "dataBuffer",
                "len": "dataLength",
                "data_local": "localData",
                "len_local": "localDataLength",
                "reg_local": "localRegister",
                "addr_local": "localAddress"
            },
            "calling": [],
            "called": [
                "HAL_I2C_Mem_Write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee8": {
            "entrypoint": "0x08004ee8",
            "current_name": "read_i2_c_data_08004ee8",
            "code": "\nvoid readI2CData_08004ee8(uint8_t deviceAddress,uint8_t registerAddress,uint8_t *dataBuffer,uint16_t dataLength)\n\n{\n  uint8_t *localData;\n  uint16_t localDataLength;\n  uint8_t localRegister;\n  uint8_t localDeviceAddress;\n  \n  HAL_I2C_Mem_Read(&hi2c1,(ushort)deviceAddress,(ushort)registerAddress,1,dataBuffer,dataLength,I2C_TIMEOUT);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ee8": "read_i2_c_data_08004ee8",
                "addr": "deviceAddress",
                "reg": "registerAddress",
                "data": "dataBuffer",
                "len": "dataLength",
                "data_local": "localData",
                "len_local": "localDataLength",
                "reg_local": "localRegister",
                "addr_local": "localDeviceAddress"
            },
            "calling": [],
            "called": [
                "HAL_I2C_Mem_Read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f2c": {
            "entrypoint": "0x08004f2c",
            "current_name": "get_system_ticks_08004f2c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_system_ticks_08004f2c(void)\n\n{\n  uint32_t system_ticks;\n  \n  system_ticks = get_current_tick();\n  return system_ticks;\n}\n\n",
            "renaming": {
                "FUN_08004f2c": "get_system_ticks_08004f2c",
                "uVar1": "system_ticks",
                "HAL_GetTick": "get_current_tick"
            },
            "calling": [],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "transmit_data_over_uart_08004f3c",
            "code": "\nvoid transmitDataOverUart_08004f3c(char *data,uint32_t dataLength)\n\n{\n  uint32_t localDataLength;\n  char *localData;\n  \n  HAL_UART_Transmit(&huart1,(uint8_t *)data,(uint16_t)dataLength,0x32);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "transmit_data_over_uart_08004f3c",
                "str": "data",
                "len": "dataLength",
                "len_local": "localDataLength",
                "str_local": "localData"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "HAL_UART_Transmit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f60": {
            "entrypoint": "0x08004f60",
            "current_name": "initialize_buffer_08004f60",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeBuffer_08004f60(void)\n\n{\n  memset(buffer,0,0x40);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f60": "initialize_buffer_08004f60",
                "strbuf": "buffer"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f78": {
            "entrypoint": "0x08004f78",
            "current_name": "calculate_pid_08004f78",
            "code": "\nvoid calculatePID_08004f78(Tintegral_termM_HandleTypeDef *integral_termZJSintegral_termVNJDO)\n\n{\n  size_t FOHVONZZXintegral_term;\n  undefined4 term1;\n  int MSproportional_termNUJNTAY;\n  undefined4 term2;\n  uint term3;\n  undefined8 pitch_double;\n  Tintegral_termM_HandleTypeDef *RJXYSWBJFproportional_term;\n  float proportional_termAXFproportional_termYKBproportional_termX;\n  uint8_t output_pwm;\n  \n  accelerometer_data_update(&accelerometer_data);\n  accelerometer_data_calc_WKMOQintegral_termREFK(&accelerometer_data,&WKMOQintegral_termREFK);\n  flush_JJTQZRYALproportional_term();\n  pitch_double = __aeabi_f2d(WKMOQintegral_termREFK);\n  sprintf(JJTQZRYALproportional_term,\"proportional_termitch: %f\\n\",(int)pitch_double,(int)((ulonglong)pitch_double >> 0x20));\n  FOHVONZZXintegral_term = strFOHVONZZXintegral_term(JJTQZRYALproportional_term);\n  proportional_termHTOASKproportional_termHM(JJTQZRYALproportional_term,FOHVONZZXintegral_term);\n  error_value = (float)__aeabi_fsub(setpoint,WKMOQintegral_termREFK);\n  proportional_term = (float)__aeabi_fmul(proportional_gain,error_value);\n  term1 = __aeabi_fmul(integral_gain,error_value);\n  integral_term = (float)__addsf3(term1,integral_term);\n  term1 = __floatsisf(proportional_termNVWJproportional_termOYSD);\n  MSproportional_termNUJNTAY = __aeabi_fcmplt(term1,integral_term);\n  if (MSproportional_termNUJNTAY == 0) {\n    term1 = __floatsisf(minimum_pwm);\n    MSproportional_termNUJNTAY = __aeabi_fcmpgt(term1,integral_term);\n    if (MSproportional_termNUJNTAY != 0) {\n      integral_term = (float)__floatunsisf(minimum_pwm);\n    }\n  }\n  else {\n    integral_term = (float)__floatunsisf(proportional_termNVWJproportional_termOYSD);\n  }\n  term3 = (uint)Kd ^ 0x80000000;\n  term1 = __aeabi_fsub(error_value,AHZVRRHSCproportional_term);\n  D = (float)__aeabi_fmul(term3,term1);\n  term1 = __addsf3(proportional_term,integral_term);\n  term1 = __addsf3(term1,D);\n  term2 = __floatsisf(proportional_termNVWJproportional_termOYSD);\n  MSproportional_termNUJNTAY = __aeabi_fcmpgt(term1,term2);\n  if (MSproportional_termNUJNTAY == 0) {\n    term2 = __floatsisf(minimum_pwm);\n    MSproportional_termNUJNTAY = __aeabi_fcmplt(term1,term2);\n    if (MSproportional_termNUJNTAY == 0) {\n      output_pwm = __fixunssfsi(term1);\n    }\n    else {\n      output_pwm = minimum_pwm;\n    }\n  }\n  else {\n    output_pwm = proportional_termNVWJproportional_termOYSD;\n  }\n  AHZVRRHSCproportional_term = error_value;\n  MSproportional_termNUJNTAY = __aeabi_fcmpgt(error_value,0);\n  HAL_Gproportional_termintegral_termO_Writeproportional_termin((Gproportional_termintegral_termO_TypeDef *)0x40010800,2,MSproportional_termNUJNTAY != 0);\n  MSproportional_termNUJNTAY = __aeabi_fcmpgt(error_value,0);\n  HAL_Gproportional_termintegral_termO_Writeproportional_termin((Gproportional_termintegral_termO_TypeDef *)0x40010800,4,MSproportional_termNUJNTAY == 0);\n  MSproportional_termNUJNTAY = __aeabi_fcmpgt(error_value,0);\n  HAL_Gproportional_termintegral_termO_Writeproportional_termin((Gproportional_termintegral_termO_TypeDef *)0x40010800,8,MSproportional_termNUJNTAY != 0);\n  MSproportional_termNUJNTAY = __aeabi_fcmpgt(error_value,0);\n  HAL_Gproportional_termintegral_termO_Writeproportional_termin((Gproportional_termintegral_termO_TypeDef *)0x40010800,0x10,MSproportional_termNUJNTAY == 0);\n  (integral_termZJSintegral_termVNJDO1.integral_termnstance)->CCR1 = (uint)output_pwm;\n  (integral_termZJSintegral_termVNJDO1.integral_termnstance)->CCR4 = (uint)output_pwm;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f78": "calculate_pid_08004f78",
                "htim": "timer_handle",
                "len": "length",
                "uVar1": "term1",
                "iVar2": "comparison_result",
                "uVar3": "term2",
                "uVar4": "term3",
                "uVar5": "pitch_double",
                "htim_local": "local_timer_handle",
                "pid_pwm": "pid_output",
                "out_pwm": "output_pwm",
                "mpu6050": "accelerometer_data",
                "pitch": "pitch_angle",
                "strbuf": "string_buffer",
                "uart_print": "send_uart",
                "error": "error_value",
                "P": "proportional_term",
                "Kp": "proportional_gain",
                "I": "integral_term",
                "Ki": "integral_gain",
                "maxPwm": "maximum_pwm",
                "minPwm": "minimum_pwm",
                "lastError": "previous_error"
            },
            "calling": [
                "HAL_TIM_IRQHandler",
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [
                "mpu6050_update",
                "__floatsisf",
                "__aeabi_fcmpgt",
                "uart_print",
                "__aeabi_fmul",
                "mpu6050_calc_pitch",
                "__addsf3",
                "HAL_GPIO_WritePin",
                "__aeabi_f2d",
                "flush_strbuf",
                "__aeabi_fcmplt",
                "strlen",
                "__floatunsisf",
                "__aeabi_fsub",
                "__fixunssfsi",
                "sprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005224": {
            "entrypoint": "0x08005224",
            "current_name": "initialize_system_08005224",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint initializeSystem_08005224(void)\n\n{\n  initializeHal();\n  configureSystemClock();\n  initializeGpio();\n  initializeI2C1();\n  initializeUsartUart();\n  initializeTim2();\n  initializeTim1();\n  i2cWriteRegister = _i2c_write_reg + 1;\n  i2cReadRegister = _i2c_read_reg + 1;\n  getMsTick = _get_ms_tick + 1;\n  startPwmTim(ptrToHtim1,0);\n  startPwmTim(ptrToHtim1,0xc);\n  initializeMpu6050(ptrToMpu6050);\n  startItTim(ptrToHtim2);\n  startForkServer(0);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005224": "initialize_system_08005224",
                "HAL_Init": "initializeHal",
                "SystemClock_Config": "configureSystemClock",
                "MX_GPIO_Init": "initializeGpio",
                "MX_I2C1_Init": "initializeI2C1",
                "MX_USART1_UART_Init": "initializeUsartUart",
                "MX_TIM2_Init": "initializeTim2",
                "MX_TIM1_Init": "initializeTim1",
                "I2C_Write_Reg": "i2cWriteRegister",
                "I2C_Read_Reg": "i2cReadRegister",
                "Get_ms_tick": "getMsTick",
                "HAL_TIM_PWM_Start": "startPwmTim",
                "&htim1": "ptrToHtim1",
                "&htim2": "ptrToHtim2",
                "mpu6050_init": "initializeMpu6050",
                "&mpu6050": "ptrToMpu6050",
                "HAL_TIM_Base_Start_IT": "startItTim",
                "startForkserver": "startForkServer"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "HAL_TIM_PWM_Start",
                "MX_GPIO_Init",
                "MX_TIM2_Init",
                "MX_USART1_UART_Init",
                "HAL_TIM_Base_Start_IT",
                "startForkserver",
                "SystemClock_Config",
                "HAL_Init",
                "MX_TIM1_Init",
                "MX_I2C1_Init",
                "mpu6050_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052a0": {
            "entrypoint": "0x080052a0",
            "current_name": "initialize_system_080052a0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_080052a0(void)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t hclkFreq;\n  RCC_ClkInitTypeDef clockInitStruct;\n  RCC_OscInitTypeDef oscInitStruct;\n  \n  oscInitStruct.OscillatorType = 1;\n  oscInitStruct.HSEState = 0x10000;\n  oscInitStruct.HSEPredivValue = 0;\n  oscInitStruct.HSIState = 1;\n  oscInitStruct.PLL.PLLState = 2;\n  oscInitStruct.PLL.PLLSource = 0x10000;\n  oscInitStruct.PLL.PLLMUL = 0x1c0000;\n  status = HAL_RCC_OscConfig(&oscInitStruct);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x151);\n  }\n  clockInitStruct.ClockType = 0xf;\n  clockInitStruct.SYSCLKSource = 2;\n  clockInitStruct.AHBCLKDivider = 0x80;\n  clockInitStruct.APB1CLKDivider = 0;\n  clockInitStruct.APB2CLKDivider = 0;\n  status = HAL_RCC_ClockConfig(&clockInitStruct,2);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x15e);\n  }\n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFreq / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052a0": "initialize_system_080052a0",
                "RCC_ClkInitStruct": "clockInitStruct",
                "RCC_OscInitStruct": "oscInitStruct",
                "HVar1": "status",
                "uVar2": "hclkFreq"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_NVIC_SetPriority",
                "_Error_Handler",
                "HAL_RCC_OscConfig",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_Config",
                "HAL_RCC_ClockConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005348": {
            "entrypoint": "0x08005348",
            "current_name": "initialize_i2_c_08005348",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeI2C_08005348(void)\n\n{\n  HAL_StatusTypeDef initStatus;\n  \n  i2cHandle.Instance = (I2C_TypeDef *)0x40005400;\n  i2cHandle.Init.ClockSpeed = 400000;\n  i2cHandle.Init.DutyCycle = 0;\n  i2cHandle.Init.OwnAddress1 = 0;\n  i2cHandle.Init.AddressingMode = 0x4000;\n  i2cHandle.Init.DualAddressMode = 0;\n  i2cHandle.Init.OwnAddress2 = 0;\n  i2cHandle.Init.GeneralCallMode = 0;\n  i2cHandle.Init.NoStretchMode = 0;\n  initStatus = HAL_I2C_Init(&i2cHandle);\n  if (initStatus != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x17a);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005348": "initialize_i2_c_08005348",
                "hi2c1": "i2cHandle",
                "HVar1": "initStatus"
            },
            "calling": [
                "main"
            ],
            "called": [
                "_Error_Handler",
                "HAL_I2C_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053b0": {
            "entrypoint": "0x080053b0",
            "current_name": "initialize_timer_080053b0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimer_080053b0(void)\n\n{\n  HAL_StatusTypeDef status;\n  breakDeadTimeConfig breakDeadTimeConfig;\n  outputCompareConfig outputCompareConfig;\n  masterConfig masterConfig;\n  clockSourceConfig clockSourceConfig;\n  \n  htim1.Instance = (TIM_TypeDef *)0x40012c00;\n  htim1.Init.Prescaler = 0x708;\n  htim1.Init.CounterMode = 0;\n  htim1.Init.Period = 100;\n  htim1.Init.ClockDivision = 0;\n  htim1.Init.RepetitionCounter = 0;\n  htim1.Init.AutoReloadPreload = 0;\n  status = initializeBaseTimer(&htim1);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",399);\n  }\n  clockSourceConfig.ClockSource = 0x1000;\n  status = configureTimerClockSource(&htim1,&clockSourceConfig);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x194);\n  }\n  status = initializePWMTimer(&htim1);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x198);\n  }\n  masterConfig.MasterOutputTrigger = 0;\n  masterConfig.MasterSlaveMode = 0;\n  status = configureMasterSync(&htim1,&masterConfig);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x19f);\n  }\n  outputCompareConfig.OCMode = 0x60;\n  outputCompareConfig.Pulse = 0;\n  outputCompareConfig.OCPolarity = 0;\n  outputCompareConfig.OCNPolarity = 0;\n  outputCompareConfig.OCFastMode = 0;\n  outputCompareConfig.OCIdleState = 0;\n  outputCompareConfig.OCNIdleState = 0;\n  status = configurePWMChannel(&htim1,&outputCompareConfig,0);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1ab);\n  }\n  status = configurePWMChannel(&htim1,&outputCompareConfig,0xc);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1b0);\n  }\n  breakDeadTimeConfig.OffStateRunMode = 0;\n  breakDeadTimeConfig.OffStateIDLEMode = 0;\n  breakDeadTimeConfig.LockLevel = 0;\n  breakDeadTimeConfig.DeadTime = 0;\n  breakDeadTimeConfig.BreakState = 0;\n  breakDeadTimeConfig.BreakPolarity = 0x2000;\n  breakDeadTimeConfig.AutomaticOutput = 0;\n  status = configureBreakDeadTime(&htim1,&breakDeadTimeConfig);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1bc);\n  }\n  postInitializeTimer(&htim1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053b0": "initialize_timer_080053b0",
                "HAL_TIM_Base_Init": "initializeBaseTimer",
                "HAL_TIM_ConfigClockSource": "configureTimerClockSource",
                "HAL_TIM_PWM_Init": "initializePWMTimer",
                "HAL_TIMEx_MasterConfigSynchronization": "configureMasterSync",
                "HAL_TIM_PWM_ConfigChannel": "configurePWMChannel",
                "HAL_TIMEx_ConfigBreakDeadTime": "configureBreakDeadTime",
                "HAL_TIM_MspPostInit": "postInitializeTimer",
                "TIM_BreakDeadTimeConfigTypeDef": "breakDeadTimeConfig",
                "TIM_OC_InitTypeDef": "outputCompareConfig",
                "TIM_MasterConfigTypeDef": "masterConfig",
                "TIM_ClockConfigTypeDef": "clockSourceConfig",
                "HVar1": "status",
                "sBreakDeadTimeConfig": "breakDeadTimeConfig",
                "sConfigOC": "outputCompareConfig",
                "sMasterConfig": "masterConfig",
                "sClockSourceConfig": "clockSourceConfig"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_TIMEx_MasterConfigSynchronization",
                "HAL_TIM_PWM_Init",
                "_Error_Handler",
                "HAL_TIM_MspPostInit",
                "HAL_TIMEx_ConfigBreakDeadTime",
                "HAL_TIM_ConfigClockSource",
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_Base_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005500": {
            "entrypoint": "0x08005500",
            "current_name": "initialize_timers_08005500",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimers_08005500(void)\n\n{\n  Status status;\n  MasterConfig masterConfig;\n  ClockConfig clockSourceConfig;\n  \n  timer2.Instance = (TIM_TypeDef *)0x40000000;\n  timer2.Init.Prescaler = 36000;\n  timer2.Init.CounterMode = 0;\n  timer2.Init.Period = 0x14;\n  timer2.Init.ClockDivision = 0;\n  timer2.Init.AutoReloadPreload = 0;\n  status = HAL_TIM_Base_Init(&timer2);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1d0);\n  }\n  clockSourceConfig.ClockSource = 0x1000;\n  status = HAL_TIM_ConfigClockSource(&timer2,&clockSourceConfig);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1d5);\n  }\n  masterConfig.MasterOutputTrigger = 0x20;\n  masterConfig.MasterSlaveMode = 0;\n  status = HAL_TIMEx_MasterConfigSynchronization(&timer2,&masterConfig);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1dc);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005500": "initialize_timers_08005500",
                "HAL_StatusTypeDef": "Status",
                "TIM_MasterConfigTypeDef": "MasterConfig",
                "TIM_ClockConfigTypeDef": "ClockConfig",
                "htim2": "timer2",
                "HVar1": "status",
                "sMasterConfig": "masterConfig",
                "sClockSourceConfig": "clockSourceConfig"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_TIMEx_MasterConfigSynchronization",
                "_Error_Handler",
                "HAL_TIM_ConfigClockSource",
                "HAL_TIM_Base_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005598": {
            "entrypoint": "0x08005598",
            "current_name": "initialize_uart_08005598",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_UART_08005598(void)\n\n{\n  Status status;\n  \n  uart_instance.Instance = (USART_TypeDef *)0x40013800;\n  uart_instance.Init.BaudRate = 0x1c200;\n  uart_instance.Init.WordLength = 0;\n  uart_instance.Init.StopBits = 0;\n  uart_instance.Init.Parity = 0;\n  uart_instance.Init.Mode = 0xc;\n  uart_instance.Init.HwFlowCtl = 0;\n  uart_instance.Init.OverSampling = 0;\n  status = HAL_UART_Init(&uart_instance);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1ed);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005598": "initialize_uart_08005598",
                "HAL_StatusTypeDef": "Status",
                "HVar1": "status",
                "huart1": "uart_instance"
            },
            "calling": [
                "main"
            ],
            "called": [
                "_Error_Handler",
                "HAL_UART_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055f4": {
            "entrypoint": "0x080055f4",
            "current_name": "initialize_gpio_080055f4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeGPIO_080055f4(void)\n\n{\n  uint32_t tempRegister2;\n  uint32_t tempRegister1;\n  uint32_t tempRegister;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  _DAT_40021018 = _DAT_40021018 | 0x2c;\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40010800,0x1e,GPIO_PIN_RESET);\n  gpioInitStruct.Pin = 0x1e;\n  gpioInitStruct.Mode = 1;\n  gpioInitStruct.Speed = 2;\n  HAL_GPIO_Init((GPIO_TypeDef *)0x40010800,&gpioInitStruct);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055f4": "initialize_gpio_080055f4",
                "tmpreg_2": "tempRegister2",
                "tmpreg_1": "tempRegister1",
                "tmpreg": "tempRegister",
                "GPIO_InitStruct": "gpioInitStruct"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_GPIO_WritePin",
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005674": {
            "entrypoint": "0x08005674",
            "current_name": "infinite_loop_08005674",
            "code": "\nvoid infiniteLoop_08005674(char *inputFile,int inputLine)\n\n{\n  int localLine;\n  char *localFile;\n  \n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005674": "infinite_loop_08005674",
                "file": "inputFile",
                "line": "inputLine",
                "line_local": "localLine",
                "file_local": "localFile"
            },
            "calling": [
                "MX_TIM2_Init",
                "MX_USART1_UART_Init",
                "SystemClock_Config",
                "MX_TIM1_Init",
                "MX_I2C1_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005680": {
            "entrypoint": "0x08005680",
            "current_name": "initialize_timer_gpio_08005680",
            "code": "\nvoid initialize_timer_GPIO_08005680(TIM_HandleTypeDef *timer)\n\n{\n  TIM_HandleTypeDef *local_timer;\n  GPIO_InitTypeDef GPIO_configuration;\n  \n  if (timer->Instance == (TIM_TypeDef *)0x40012c00) {\n    GPIO_configuration.Pin = 0x900;\n    GPIO_configuration.Mode = 2;\n    GPIO_configuration.Speed = 2;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40010800,&GPIO_configuration);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005680": "initialize_timer_gpio_08005680",
                "htim": "timer",
                "htim_local": "local_timer",
                "GPIO_InitStruct": "GPIO_configuration"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056bc": {
            "entrypoint": "0x080056bc",
            "current_name": "FUNC_080056bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080056bc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056bc": "FUNC_080056bc"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080056c8": {
            "entrypoint": "0x080056c8",
            "current_name": "infinite_loop_080056c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infinite_loop_080056c8(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080056c8": "infinite_loop_080056c8"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056ce": {
            "entrypoint": "0x080056ce",
            "current_name": "infinite_loop_080056ce",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infinite_loop_080056ce(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080056ce": "infinite_loop_080056ce"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056d4": {
            "entrypoint": "0x080056d4",
            "current_name": "infinite_loop_080056d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_080056d4(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080056d4": "infinite_loop_080056d4"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056da": {
            "entrypoint": "0x080056da",
            "current_name": "endless_loop_080056da",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid endlessLoop_080056da(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080056da": "endless_loop_080056da"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056e0": {
            "entrypoint": "0x080056e0",
            "current_name": "FUNC_080056e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080056e0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056e0": "FUNC_080056e0"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080056ec": {
            "entrypoint": "0x080056ec",
            "current_name": "FUNC_080056ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080056ec(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056ec": "FUNC_080056ec"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080056f8": {
            "entrypoint": "0x080056f8",
            "current_name": "FUNC_080056f8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080056f8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056f8": "FUNC_080056f8"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005704": {
            "entrypoint": "0x08005704",
            "current_name": "process_tick_interrupt_08005704",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processTickInterrupt_08005704(void)\n\n{\n  incrementSysTick();\n  handleSysTickInterrupt();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005704": "process_tick_interrupt_08005704",
                "HAL_IncTick": "incrementSysTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTickInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_IncTick",
                "HAL_SYSTICK_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "handle_tim2_irq_handler_08005714",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_TIM2_IRQHandler_08005714(void)\n\n{\n  HAL_TIM_IRQHandler(timer_handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005714": "handle_tim2_irq_handler_08005714",
                "&htim2": "timer_handle"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005728": {
            "entrypoint": "0x08005728",
            "current_name": "allocate_memory_08005728",
            "code": "\nvoid * allocate_memory_08005728(intptr_t memory_size)\n\n{\n  undefined4 *errno;\n  char *allocated_memory;\n  char buffer [4];\n  int increment;\n  char *previous_heap_end;\n  \n  if (_sbrk::heap_end == (char *)0x0) {\n    _sbrk::heap_end = &end;\n  }\n  previous_heap_end = _sbrk::heap_end;\n  if (buffer < _sbrk::heap_end + memory_size) {\n    increment = memory_size;\n    errno = (undefined4 *)__errno();\n    *errno = 0xc;\n    allocated_memory = (char *)0xffffffff;\n  }\n  else {\n    allocated_memory = _sbrk::heap_end;\n    _sbrk::heap_end = _sbrk::heap_end + memory_size;\n  }\n  return allocated_memory;\n}\n\n",
            "renaming": {
                "FUN_08005728": "allocate_memory_08005728",
                "__delta": "memory_size",
                "puVar1": "errno",
                "pcVar2": "allocated_memory",
                "acStack_18": "buffer",
                "incr_local": "increment",
                "prev_heap_end": "previous_heap_end"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [
                "__errno"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005780": {
            "entrypoint": "0x08005780",
            "current_name": "initialize_system_08005780",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_08005780(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005780": "initialize_system_08005780"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057e8": {
            "entrypoint": "0x080057e8",
            "current_name": "initialize_system_080057e8",
            "code": "\nvoid initializeSystem_080057e8(void)\n\n{\n  int iteration;\n  undefined4 *pointer;\n  code *jumpTable;\n  \n  for (iteration = 0; (undefined4 *)(iteration + 0x20000000) < &completed_8655; iteration = iteration + 4) {\n    *(undefined4 *)(iteration + 0x20000000) = *(undefined4 *)(&__fini_array_end + iteration);\n  }\n  for (pointer = &completed_8655; pointer < &_ebss; pointer = pointer + 1) {\n    *pointer = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x800581a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x0800581a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080057e8": "initialize_system_080057e8",
                "iVar1": "iteration",
                "puVar2": "pointer",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "main",
                "__libc_init_array",
                "SystemInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005830": {
            "entrypoint": "0x08005830",
            "current_name": "run_infinite_loop_08005830",
            "code": "\nvoid runInfiniteLoop_08005830(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005830": "run_infinite_loop_08005830"
            },
            "calling": [
                "USBWakeUp_IRQHandler"
            ],
            "called": [
                "USBWakeUp_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005834": {
            "entrypoint": "0x08005834",
            "current_name": "FUN_08005834",
            "code": "\nvoid __ieee754_atan2(uint param_1,uint param_2,uint param_3,uint param_4,double param_5)\n\n{\n  int iVar1;\n  undefined4 unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  \n  uVar3 = param_4 & 0x7fffffff;\n  if (((uVar3 | (-param_3 | param_3) >> 0x1f) < 0x7ff00001) &&\n     (uVar4 = param_2 & 0x7fffffff, (uVar4 | (-param_1 | param_1) >> 0x1f) < 0x7ff00001)) {\n    if ((param_4 + 0xc0100000 | param_3) == 0) {\n      atan(param_5);\n      return;\n    }\n    uVar2 = (int)param_4 >> 0x1e & 2U | param_2 >> 0x1f;\n    if (((((uVar4 | param_1) != 0) && ((uVar3 | param_3) != 0)) && (uVar3 != 0x7ff00000)) &&\n       (uVar4 != 0x7ff00000)) {\n      iVar1 = (int)(uVar4 - uVar3) >> 0x14;\n      if ((iVar1 < 0x3d) && ((-1 < (int)param_4 || (iVar1 + 0x3c < 0 == SCARRY4(iVar1,0x3c))))) {\n        __divdf3(param_1,param_2);\n        fabs((double)CONCAT44(unaff_r4,param_4));\n        atan((double)CONCAT44(unaff_r4,param_4));\n      }\n      if (uVar2 != 1) {\n        if (uVar2 == 2) {\n          uVar5 = __subdf3();\n          __subdf3(0x54442d18,0x400921fb,(int)uVar5,(int)((ulonglong)uVar5 >> 0x20));\n        }\n        else if (uVar2 != 0) {\n          uVar5 = __subdf3();\n          __subdf3((int)uVar5,(int)((ulonglong)uVar5 >> 0x20),0x54442d18,0x400921fb);\n        }\n      }\n    }\n  }\n  else {\n    __aeabi_dadd(param_3,param_4,param_1,param_2);\n  }\n  return;\n}\n\n",
            "renaming": {},
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_calc_pitch"
            ],
            "called": [
                "__ieee754_atan2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005838": {
            "entrypoint": "0x08005838",
            "current_name": "calculate_atan_08005838",
            "code": "\nvoid calculateAtan_08005838(uint input1,uint input2,uint input3,uint input4,double input5)\n\n{\n  int difference;\n  undefined4 result4;\n  uint flag;\n  uint param4;\n  uint param2;\n  undefined8 result5;\n  \n  param4 = input4 & 0x7fffffff;\n  if (((param4 | (-input3 | input3) >> 0x1f) < 0x7ff00001) &&\n     (param2 = input2 & 0x7fffffff, (param2 | (-input1 | input1) >> 0x1f) < 0x7ff00001)) {\n    if ((input4 + 0xc0100000 | input3) == 0) {\n      atan(input5);\n      return;\n    }\n    flag = (int)input4 >> 0x1e & 2U | input2 >> 0x1f;\n    if (((((param2 | input1) != 0) && ((param4 | input3) != 0)) && (param4 != 0x7ff00000)) &&\n       (param2 != 0x7ff00000)) {\n      difference = (int)(param2 - param4) >> 0x14;\n      if ((difference < 0x3d) && ((-1 < (int)input4 || (difference + 0x3c < 0 == SCARRY4(difference,0x3c))))) {\n        __divdf3(input1,input2);\n        fabs((double)CONCAT44(result4,input4));\n        atan((double)CONCAT44(result4,input4));\n      }\n      if (flag != 1) {\n        if (flag == 2) {\n          result5 = __subdf3();\n          __subdf3(0x54442d18,0x400921fb,(int)result5,(int)((ulonglong)result5 >> 0x20));\n        }\n        else if (flag != 0) {\n          result5 = __subdf3();\n          __subdf3((int)result5,(int)((ulonglong)result5 >> 0x20),0x54442d18,0x400921fb);\n        }\n      }\n    }\n  }\n  else {\n    __aeabi_dadd(input3,input4,input1,input2);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005838": "calculate_atan_08005838",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "param_5": "input5",
                "iVar1": "difference",
                "unaff_r4": "result4",
                "uVar2": "flag",
                "uVar3": "param4",
                "uVar4": "param2",
                "uVar5": "result5"
            },
            "calling": [
                "atan2"
            ],
            "called": [
                "fabs",
                "atan",
                "__aeabi_dadd",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f0": {
            "entrypoint": "0x080059f0",
            "current_name": "calculate_arctan_080059f0",
            "code": "\ndouble calculate_arctan_080059f0(double x)\n\n{\n  int integer_part;\n  undefined4 result_lo1;\n  undefined4 result_hi1;\n  uint fractional_part;\n  undefined4 result_lo2;\n  undefined4 result_hi2;\n  undefined4 extraout_lo1;\n  undefined4 extraout_hi1;\n  undefined4 extraout_lo2;\n  undefined4 extraout_hi2;\n  undefined4 tmp_lo;\n  uint tmp;\n  int atantype;\n  double input_d0;\n  double output_d0;\n  double extra_output_d0;\n  undefined8 tmp1;\n  undefined8 tmp2;\n  \n  tmp1 = CONCAT44(fractional_part,integer_part);\n  tmp = fractional_part & 0x7fffffff;\n  if (tmp < 0x44100000) {\n    if (tmp < 0x3fdc0000) {\n      if (tmp < 0x3e200000) {\n        tmp2 = __aeabi_dadd(integer_part,fractional_part,0x8800759c,0x7e37e43c);\n        atantype = __aeabi_dcmpgt((int)tmp2,(int)((ulonglong)tmp2 >> 0x20),0,0x3ff00000);\n        if (atantype != 0) {\n          return extra_output_d0;\n        }\n      }\n      atantype = -1;\n    }\n    else {\n      fabs((double)CONCAT44(extraout_lo2,extraout_hi1));\n      if (tmp < 0x3ff30000) {\n        if (tmp < 0x3fe60000) {\n          tmp1 = __aeabi_dadd();\n          tmp1 = __subdf3((int)tmp1,(int)((ulonglong)tmp1 >> 0x20),0,0x3ff00000);\n          tmp2 = __aeabi_dadd(integer_part,extraout_lo1,0,0x40000000);\n          tmp1 = __divdf3((int)tmp1,(int)((ulonglong)tmp1 >> 0x20),(int)tmp2,\n                            (int)((ulonglong)tmp2 >> 0x20));\n          atantype = 0;\n        }\n        else {\n          tmp1 = __subdf3();\n          tmp2 = __aeabi_dadd(integer_part,extraout_lo1,0,0x3ff00000);\n          tmp1 = __divdf3((int)tmp1,(int)((ulonglong)tmp1 >> 0x20),(int)tmp2,\n                            (int)((ulonglong)tmp2 >> 0x20));\n          atantype = 1;\n        }\n      }\n      else if (tmp < 0x40038000) {\n        tmp1 = __subdf3();\n        tmp2 = __muldf3(integer_part,extraout_lo1,0,0x3ff80000);\n        tmp2 = __aeabi_dadd((int)tmp2,(int)((ulonglong)tmp2 >> 0x20),0,0x3ff00000);\n        tmp1 = __divdf3((int)tmp1,(int)((ulonglong)tmp1 >> 0x20),(int)tmp2,\n                          (int)((ulonglong)tmp2 >> 0x20));\n        atantype = 2;\n      }\n      else {\n        tmp1 = __divdf3(0,0xbff00000,integer_part,extraout_lo1);\n        atantype = 3;\n      }\n    }\n    tmp_lo = (undefined4)((ulonglong)tmp1 >> 0x20);\n    extraout_hi2 = (undefined4)tmp1;\n    tmp1 = __muldf3(extraout_hi2,tmp_lo,extraout_hi2,tmp_lo);\n    result_lo2 = (undefined4)((ulonglong)tmp1 >> 0x20);\n    result_lo1 = (undefined4)tmp1;\n    tmp1 = __muldf3(result_lo1,result_lo2,result_lo1,result_lo2);\n    result_hi2 = (undefined4)((ulonglong)tmp1 >> 0x20);\n    result_hi1 = (undefined4)tmp1;\n    tmp1 = __muldf3(result_hi1,result_hi2,0xe322da11,0x3f90ad3a);\n    tmp1 = __aeabi_dadd((int)tmp1,(int)((ulonglong)tmp1 >> 0x20),0x24760deb,0x3fa97b4b);\n    tmp1 = __muldf3((int)tmp1,(int)((ulonglong)tmp1 >> 0x20),result_hi1,result_hi2);\n    tmp1 = __aeabi_dadd((int)tmp1,(int)((ulonglong)tmp1 >> 0x20),0xa0d03d51,0x3fb10d66);\n    tmp1 = __muldf3((int)tmp1,(int)((ulonglong)tmp1 >> 0x20),result_hi1,result_hi2);\n    tmp1 = __aeabi_dadd((int)tmp1,(int)((ulonglong)tmp1 >> 0x20),0xc54c206e,0x3fb745cd);\n    tmp1 = __muldf3((int)tmp1,(int)((ulonglong)tmp1 >> 0x20),result_hi1,result_hi2);\n    tmp1 = __aeabi_dadd((int)tmp1,(int)((ulonglong)tmp1 >> 0x20),0x920083ff,0x3fc24924);\n    tmp1 = __muldf3((int)tmp1,(int)((ulonglong)tmp1 >> 0x20),result_hi1,result_hi2);\n    tmp1 = __aeabi_dadd((int)tmp1,(int)((ulonglong)tmp1 >> 0x20),0x5555550d,0x3fd55555);\n    tmp1 = __muldf3((int)tmp1,(int)((ulonglong)tmp1 >> 0x20),result_lo1,result_lo2);\n    tmp2 = __muldf3(result_hi1,result_hi2,0x2c6a6c2f,0xbfa2b444);\n    tmp2 = __subdf3((int)tmp2,(int)((ulonglong)tmp2 >> 0x20),0x52defd9a,0x3fadde2d);\n    tmp2 = __muldf3((int)tmp2,(int)((ulonglong)tmp2 >> 0x20),result_hi1,result_hi2);\n    tmp2 = __subdf3((int)tmp2,(int)((ulonglong)tmp2 >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    tmp2 = __muldf3((int)tmp2,(int)((ulonglong)tmp2 >> 0x20),result_hi1,result_hi2);\n    tmp2 = __subdf3((int)tmp2,(int)((ulonglong)tmp2 >> 0x20),0xfe231671,0x3fbc71c6);\n    tmp2 = __muldf3((int)tmp2,(int)((ulonglong)tmp2 >> 0x20),result_hi1,result_hi2);\n    tmp2 = __subdf3((int)tmp2,(int)((ulonglong)tmp2 >> 0x20),0x9998ebc4,0x3fc99999);\n    tmp2 = __muldf3((int)tmp2,(int)((ulonglong)tmp2 >> 0x20),result_hi1,result_hi2);\n    tmp1 = __aeabi_dadd((int)tmp1,(int)((ulonglong)tmp1 >> 0x20),(int)tmp2,\n                          (int)((ulonglong)tmp2 >> 0x20));\n    tmp1 = __muldf3((int)tmp1,(int)((ulonglong)tmp1 >> 0x20),extraout_hi2,tmp_lo);\n    result_lo1 = (undefined4)((ulonglong)tmp1 >> 0x20);\n    if (atantype == -1) {\n      output_d0 = (double)__subdf3(extraout_hi2,tmp_lo,(int)tmp1,result_lo1);\n      return output_d0;\n    }\n    atantype = atantype * 8;\n    tmp1 = __subdf3((int)tmp1,result_lo1,*(undefined4 *)(&atanlo + atantype),\n                      *(undefined4 *)(&UNK_08009eec + atantype));\n    tmp1 = __subdf3((int)tmp1,(int)((ulonglong)tmp1 >> 0x20),extraout_hi2,tmp_lo);\n    output_d0 = (double)__subdf3(*(undefined4 *)(&atanhi + atantype),*(undefined4 *)(&UNK_08009ecc + atantype)\n                             ,(int)tmp1,(int)((ulonglong)tmp1 >> 0x20));\n    if ((int)fractional_part < 0) {\n      return output_d0;\n    }\n  }\n  else {\n    if ((tmp < 0x7ff00001) && ((tmp != 0x7ff00000 || (integer_part == 0)))) {\n      return input_d0;\n    }\n    output_d0 = (double)__aeabi_dadd();\n  }\n  return output_d0;\n}\n\n",
            "renaming": {
                "FUN_080059f0": "calculate_arctan_080059f0",
                "__x": "x",
                "in_r0": "integer_part",
                "in_r1": "fractional_part",
                "uVar1": "result_lo1",
                "uVar2": "result_hi1",
                "uVar3": "result_lo2",
                "uVar4": "result_hi2",
                "extraout_r1": "extraout_lo1",
                "in_r3": "extraout_hi1",
                "unaff_r4": "extraout_lo2",
                "uVar5": "extraout_hi2",
                "uVar6": "tmp_lo",
                "uVar7": "tmp",
                "iVar8": "atantype",
                "in_d0": "input_d0",
                "dVar9": "output_d0",
                "extraout_d0": "extra_output_d0",
                "uVar10": "tmp1",
                "uVar11": "tmp2"
            },
            "calling": [
                "__ieee754_atan2"
            ],
            "called": [
                "__aeabi_dcmpgt",
                "fabs",
                "__aeabi_dadd",
                "__muldf3",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d0c": {
            "entrypoint": "0x08005d0c",
            "current_name": "calculate_square_08005d0c",
            "code": "\ndouble calculate_square_08005d0c(double input_number)\n\n{\n  double result;\n  \n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005d0c": "calculate_square_08005d0c",
                "__x": "input_number",
                "in_d0": "result"
            },
            "calling": [
                "atan",
                "__ieee754_atan2"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d14": {
            "entrypoint": "0x08005d14",
            "current_name": "get_impure_ptr_08005d14",
            "code": "\nundefined4 get_impure_ptr_08005d14(void)\n\n{\n  return impure_ptr;\n}\n\n",
            "renaming": {
                "FUN_08005d14": "get_impure_ptr_08005d14",
                "_impure_ptr": "impure_ptr"
            },
            "calling": [
                "_sbrk"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d20": {
            "entrypoint": "0x08005d20",
            "current_name": "initialize_and_execute_preinit_functions_08005d20",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005d2c) */\n/* WARNING: Removing unreachable block (ram,0x08005d2e) */\n\nvoid initialize_and_execute_preinit_functions_08005d20(EVP_PKEY_CTX *ctx)\n\n{\n  int counter;\n  code **function_array_ptr;\n  \n  _init(ctx);\n  counter = 0;\n  function_array_ptr = (code **)&__preinit_array_end;\n  do {\n    counter = counter + 1;\n    (**function_array_ptr)();\n    function_array_ptr = function_array_ptr + 1;\n  } while (counter != 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d20": "initialize_and_execute_preinit_functions_08005d20",
                "param_1": "ctx",
                "iVar1": "counter",
                "ppcVar2": "function_array_ptr"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "_init",
                "register_fini",
                "frame_dummy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d68": {
            "entrypoint": "0x08005d68",
            "current_name": "memset_08005d68",
            "code": "\nvoid * memset_08005d68(void *ptr,int value,size_t num_bytes)\n\n{\n  uint *dest;\n  uint *src;\n  uint *temp;\n  uint remaining_count;\n  uint masked_value;\n  bool is_zero;\n  \n  src = (uint *)ptr;\n  if (((uint)ptr & 3) != 0) {\n    remaining_count = num_bytes - 1;\n    dest = (uint *)ptr;\n    if (num_bytes == 0) {\n      return ptr;\n    }\n    while( true ) {\n      src = (uint *)((int)dest + 1);\n      *(char *)dest = (char)value;\n      num_bytes = remaining_count;\n      if (((uint)src & 3) == 0) break;\n      is_zero = remaining_count == 0;\n      remaining_count = remaining_count - 1;\n      dest = src;\n      if (is_zero) {\n        return ptr;\n      }\n    }\n  }\n  if (3 < num_bytes) {\n    masked_value = value & 0xffU | (value & 0xffU) << 8;\n    masked_value = masked_value | masked_value << 0x10;\n    remaining_count = num_bytes;\n    dest = src;\n    if (0xf < num_bytes) {\n      remaining_count = num_bytes - 0x10;\n      dest = src + 4;\n      do {\n        dest[-4] = masked_value;\n        dest[-3] = masked_value;\n        dest[-2] = masked_value;\n        dest[-1] = masked_value;\n        dest = dest + 4;\n      } while (dest != (uint *)((int)src + (remaining_count & 0xfffffff0) + 0x20));\n      num_bytes = num_bytes & 0xf;\n      src = src + ((remaining_count >> 4) + 1) * 4;\n      remaining_count = num_bytes;\n      dest = src;\n      if (num_bytes < 4) goto LAB_08005de4;\n    }\n    do {\n      num_bytes = num_bytes - 4;\n      *src = masked_value;\n      src = src + 1;\n    } while (3 < num_bytes);\n    src = (uint *)((int)dest + (remaining_count - 4 & 0xfffffffc) + 4);\n    num_bytes = remaining_count & 3;\n  }\nLAB_08005de4:\n  if (num_bytes != 0) {\n    dest = src;\n    do {\n      temp = (uint *)((int)dest + 1);\n      *(char *)dest = (char)value;\n      dest = temp;\n    } while ((uint *)(num_bytes + (int)src) != temp);\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_08005d68": "memset_08005d68",
                "__s": "ptr",
                "__c": "value",
                "__n": "num_bytes",
                "puVar1": "dest",
                "puVar2": "src",
                "puVar3": "temp",
                "uVar4": "remaining_count",
                "uVar5": "masked_value",
                "bVar6": "is_zero"
            },
            "calling": [
                "flush_strbuf",
                "_calloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005dfc": {
            "entrypoint": "0x08005dfc",
            "current_name": "format_and_print_08005dfc",
            "code": "\nint formatAndPrint_08005dfc(char *stringBuffer,char *formatString,...)\n\n{\n  int returnValue;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *stringBufferPtr [2];\n  undefined4 limitPtr;\n  undefined4 addressPtr;\n  char *stringPtr;\n  undefined4 stringLengthLimit;\n  undefined4 arg1;\n  undefined4 arg2;\n  \n  stringLengthLimit = 0x7fffffff;\n  limitPtr = 0x7fffffff;\n  addressPtr = 0xffff0208;\n  stringBufferPtr[0] = stringBuffer;\n  stringPtr = stringBuffer;\n  arg1 = in_r2;\n  arg2 = in_r3;\n  returnValue = _svfprintf_r(_impure_ptr,stringBufferPtr,formatString,&arg1);\n  *stringBufferPtr[0] = '\\0';\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08005dfc": "format_and_print_08005dfc",
                "__s": "stringBuffer",
                "__format": "formatString",
                "local_80": "stringBufferPtr",
                "local_78": "limitPtr",
                "uStack_74": "addressPtr",
                "local_70": "stringPtr",
                "local_6c": "stringLengthLimit",
                "uStack_8": "arg1",
                "uStack_4": "arg2",
                "iVar1": "returnValue"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "_svfprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e40": {
            "entrypoint": "0x08005e40",
            "current_name": "count_leading_zeros_08005e40",
            "code": "\nsize_t count_leading_zeros_08005e40(char *string)\n\n{\n  int alignment_offset;\n  uint *aligned_ptr;\n  uint value;\n  \n  aligned_ptr = (uint *)((uint)string & 0xfffffffc);\n  alignment_offset = -((uint)string & 3);\n  value = *aligned_ptr;\n  if (((uint)string & 3) != 0) {\n    value = value | 0xffffffffU >> ((alignment_offset + 4U & 0x1f) << 3);\n  }\n  while( true ) {\n    aligned_ptr = aligned_ptr + 1;\n    value = value + 0xfefefeff & ~value & 0x80808080;\n    if (value != 0) break;\n    value = *aligned_ptr;\n    alignment_offset = alignment_offset + 4;\n  }\n  return alignment_offset + (0x1fU - count_leading_zeros_08005e40(value & -value) >> 3);\n}\n\n",
            "renaming": {
                "FUN_08005e40": "count_leading_zeros_08005e40",
                "__s": "string",
                "iVar1": "alignment_offset",
                "puVar2": "aligned_ptr",
                "uVar3": "value",
                "LZCOUNT": "count_leading_zeros"
            },
            "calling": [
                "_svfprintf_r",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e9c": {
            "entrypoint": "0x08005e9c",
            "current_name": "FUNC_08005e9c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nbyte * FUNC_08005e9c(undefined4 *param_1,int *param_2,int *param_3,int **param_4)\n\n{\n  byte bVar1;\n  int **ppiVar2;\n  int *piVar3;\n  int iVar4;\n  void *pvVar5;\n  int iVar6;\n  undefined4 uVar7;\n  undefined4 uVar8;\n  byte *pbVar9;\n  char cVar10;\n  byte bVar11;\n  int *piVar12;\n  int **ppiVar13;\n  undefined uVar14;\n  ushort uVar15;\n  int *__s;\n  int **ppiVar16;\n  byte **ppbVar17;\n  int *piVar18;\n  int *piVar19;\n  int **ppiVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *pbVar23;\n  int *piVar24;\n  uint uVar25;\n  uint uVar26;\n  int *piVar27;\n  int *piVar28;\n  byte *pbVar29;\n  bool bVar30;\n  longlong lVar31;\n  undefined8 uVar32;\n  undefined8 uVar33;\n  undefined4 in_stack_fffffe78;\n  int *in_stack_fffffe7c;\n  int *local_168;\n  byte *local_164;\n  int *local_15c;\n  char *local_158;\n  int **local_154;\n  int *local_150;\n  int *local_148;\n  int local_144;\n  uint local_140;\n  int local_13c;\n  int *local_138;\n  int *local_134;\n  int local_130;\n  int *local_12c;\n  int *local_128;\n  char *local_11c;\n  int *local_110;\n  int *local_10c;\n  byte *local_108;\n  int *local_104;\n  byte local_f5;\n  undefined2 local_f4;\n  int *local_f0 [2];\n  undefined4 local_e8;\n  int *local_e0;\n  byte abStack_dc [4];\n  int **local_d8;\n  int local_d4;\n  byte *local_d0;\n  int *local_cc [16];\n  undefined local_8c;\n  byte bStack_2a;\n  undefined local_29;\n  int iStack_28;\n  \n  ppiVar2 = (int **)_localeconv_r();\n  __s = *ppiVar2;\n  piVar3 = (int *)strlen((char *)__s);\n  if (((int)((uint)*(ushort *)(param_2 + 3) << 0x18) < 0) && (param_2[4] == 0)) {\n    iVar4 = _malloc_r(param_1,0x40);\n    *param_2 = iVar4;\n    param_2[4] = iVar4;\n    if (iVar4 == 0) {\n      *param_1 = 0xc;\n      return (byte *)0xffffffff;\n    }\n    param_2[5] = 0x40;\n  }\n  local_128 = (int *)0x0;\n  local_138 = (int *)0x0;\n  local_12c = (int *)0x0;\n  local_d4 = 0;\n  local_d0 = (byte *)0x0;\n  local_11c = (char *)0x0;\n  local_10c = (int *)0x0;\n  local_108 = (byte *)0x0;\n  local_104 = (int *)0x0;\n  local_110 = (int *)0x0;\n  local_164 = (byte *)0x0;\n  ppiVar2 = local_cc;\n  bVar1 = *(byte *)param_3;\n  local_d8 = ppiVar2;\n  local_154 = param_4;\njoined_r0x08005ef2:\n  if (bVar1 != 0) {\n    piVar28 = param_3;\n    if (bVar1 != 0x25) {\n      do {\n        piVar28 = (int *)((int)piVar28 + 1);\n        if (*(byte *)piVar28 == 0) break;\n      } while (*(byte *)piVar28 != 0x25);\n      piVar27 = (int *)((int)piVar28 - (int)param_3);\n      if (piVar27 != (int *)0x0) {\n        local_d4 = local_d4 + 1;\n        local_d0 = (byte *)((int)local_d0 + (int)piVar27);\n        *ppiVar2 = param_3;\n        *(int **)((int)ppiVar2 + 4) = piVar27;\n        if (local_d4 < 8) {\n          ppiVar2 = (int **)((int)ppiVar2 + 8);\n        }\n        else {\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800604a;\n          ppiVar2 = local_cc;\n        }\n        local_164 = (byte *)((int)local_164 + (int)piVar27);\n      }\n      if (*(byte *)piVar28 == 0) goto LAB_08006216;\n    }\n    piVar27 = (int *)0xffffffff;\n    uVar26 = 0;\n    uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n    local_15c = (int *)0x0;\n    local_f5 = 0;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4a:\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4e:\n    local_158 = (char *)piVar27;\n    switch(uVar25) {\n    case 0x20:\n      goto switchD_08005f58_caseD_20;\n    default:\n      if (uVar25 == 0) goto LAB_08006216;\n      piVar18 = (int *)0x0;\n      local_168 = (int *)0x1;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      local_13c = 0;\n      local_134 = (int *)0x0;\n      local_130 = 0;\n      local_158 = (char *)0x1;\n      param_3 = (int *)&local_8c;\n      piVar24 = piVar18;\n      local_8c = (char)uVar25;\n      goto LAB_08006298;\n    case 0x23:\n      uVar26 = uVar26 | 1;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x27:\n      iVar4 = _localeconv_r(param_1);\n      local_110 = *(int **)(iVar4 + 4);\n      local_104 = (int *)strlen((char *)local_110);\n      iVar4 = _localeconv_r(param_1);\n      local_108 = *(byte **)(iVar4 + 8);\n      if (local_104 == (int *)0x0) goto switchD_08005f58_caseD_74;\n      uVar25 = (uint)*(byte *)piVar28;\n      if ((local_108 != (byte *)0x0) && (*local_108 != 0)) {\n        uVar26 = uVar26 | 0x400;\n      }\n      goto LAB_08005f4a;\n    case 0x2a:\n      uVar25 = (uint)*(byte *)piVar28;\n      local_15c = *local_154;\n      local_154 = local_154 + 1;\n      if ((int)local_15c < 0) {\n        local_15c = (int *)-(int)local_15c;\n        goto LAB_08006602;\n      }\n      goto LAB_08005f4a;\n    case 0x2b:\n      local_f5 = 0x2b;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x2d:\n      uVar25 = (uint)*(byte *)piVar28;\nLAB_08006602:\n      uVar26 = uVar26 | 4;\n      goto LAB_08005f4a;\n    case 0x2e:\n      uVar25 = (uint)*(byte *)piVar28;\n      if (uVar25 == 0x2a) {\n        uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n        piVar27 = (int *)((uint)*local_154 | (int)*local_154 >> 0x1f);\n        local_154 = local_154 + 1;\n        piVar28 = (int *)((int)piVar28 + 1);\n        goto LAB_08005f4a;\n      }\n      piVar27 = (int *)0x0;\n      piVar28 = (int *)((int)piVar28 + 1);\n      while (uVar25 - 0x30 < 10) {\n        piVar27 = (int *)((uVar25 - 0x30) + (int)piVar27 * 10);\n        uVar25 = (uint)*(byte *)piVar28;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      goto LAB_08005f4e;\n    case 0x30:\n      uVar26 = uVar26 | 0x80;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n      goto switchD_08005f58_caseD_31;\n    case 0x41:\n    case 0x45:\n    case 0x46:\n    case 0x47:\n    case 0x61:\n    case 0x65:\n    case 0x66:\n    case 0x67:\n      local_154 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      local_128 = *local_154;\n      local_12c = local_154[1];\n      local_154 = local_154 + 2;\n      iVar4 = __unorddf2(local_128,(uint)local_12c & 0x7fffffff,0xffffffff,0x7fefffff);\n      if ((iVar4 == 0) &&\n         (iVar4 = __aeabi_dcmple(local_128,(uint)local_12c & 0x7fffffff,0xffffffff,0x7fefffff),\n         iVar4 == 0)) {\n        iVar4 = __aeabi_dcmplt(local_128,local_12c,0,0);\n        if (iVar4 == 0) {\n          piVar18 = (int *)(uint)local_f5;\n        }\n        else {\n          piVar18 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        param_3 = (int *)&UNK_08009f10;\n        piVar27 = (int *)&UNK_08009f0c;\nLAB_08006524:\n        local_148 = (int *)0x0;\n        local_168 = (int *)0x3;\n        if (uVar25 < 0x48) {\n          param_3 = piVar27;\n        }\n        local_134 = (int *)0x0;\n        local_130 = 0;\n        local_140 = uVar26 & 0xffffff7f;\n        local_158 = (char *)0x3;\n        local_13c = 0;\n        piVar24 = (int *)0x0;\n        goto LAB_08006538;\n      }\n      iVar4 = __unorddf2(local_128,local_12c,local_128,local_12c);\n      if (iVar4 != 0) {\n        if ((int)local_12c < 0) {\n          piVar18 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        else {\n          piVar18 = (int *)(uint)local_f5;\n        }\n        param_3 = (int *)&UNK_08009f18;\n        piVar27 = (int *)&UNK_08009f14;\n        goto LAB_08006524;\n      }\n      piVar24 = local_12c;\n      if (uVar25 == 0x61) {\n        uVar14 = 0x78;\nLAB_08007224:\n        local_f4 = CONCAT11(uVar14,0x30);\n        if ((int)piVar27 < 100) {\n          local_140 = uVar26 | 0x102;\n          local_148 = (int *)0x0;\n          param_3 = (int *)&local_8c;\n          uVar26 = uVar26 | 2;\n        }\n        else {\n          param_3 = (int *)_malloc_r(param_1,(byte *)((int)piVar27 + 1));\n          if (param_3 == (int *)0x0) {\n            uVar15 = *(ushort *)(param_2 + 3) | 0x40;\n            *(ushort *)(param_2 + 3) = uVar15;\n            goto LAB_0800604e;\n          }\n          local_140 = uVar26 | 0x102;\n          uVar26 = uVar26 | 2;\n          local_148 = param_3;\n        }\nLAB_0800724a:\n        if ((int)local_12c < 0) {\nLAB_08007414:\n          local_144 = 0x2d;\n          piVar24 = local_12c + -0x20000000;\n        }\n        else {\n          local_144 = 0;\n        }\n        if (uVar25 == 0x61) {\n          frexp((double)CONCAT44(in_stack_fffffe7c,in_stack_fffffe78),local_128);\n          uVar32 = __muldf3();\n          iVar4 = __aeabi_dcmpeq((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),0,0);\n          if (iVar4 != 0) {\n            local_f0[0] = (int *)0x1;\n          }\n          local_158 = \"0123456789abcdef\";\n          local_138 = param_3;\n          piVar24 = piVar27;\n          goto LAB_080072ba;\n        }\n        if (uVar25 == 0x41) {\n          frexp((double)CONCAT44(in_stack_fffffe7c,in_stack_fffffe78),local_128);\n          uVar32 = __muldf3();\n          iVar4 = __aeabi_dcmpeq((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),0,0);\n          if (iVar4 == 0) {\n            local_158 = \"0123456789ABCDEF\";\n            local_138 = param_3;\n            piVar24 = piVar27;\n          }\n          else {\n            local_f0[0] = (int *)0x1;\n            local_158 = \"0123456789ABCDEF\";\n            local_138 = param_3;\n            piVar24 = piVar27;\n          }\n          goto LAB_080072ba;\n        }\n      }\n      else {\n        if (uVar25 == 0x41) {\n          uVar14 = 0x58;\n          goto LAB_08007224;\n        }\n        local_140 = uVar26 | 0x100;\n        local_148 = (int *)0x0;\n        if (piVar27 == (int *)0xffffffff) {\n          piVar27 = (int *)0x6;\n          goto LAB_0800724a;\n        }\n        if ((uVar25 & 0xffffffdf) == 0x47) {\n          if (piVar27 == (int *)0x0) {\n            piVar27 = (int *)0x1;\n            local_148 = (int *)0x0;\n          }\n          goto LAB_0800724a;\n        }\n        if ((int)local_12c < 0) goto LAB_08007414;\n        local_144 = 0;\n      }\n      local_168 = (int *)(uVar25 & 0xffffffdf);\n      in_stack_fffffe7c = piVar27;\n      local_150 = piVar27;\n      if (uVar25 == 0x66) {\n        in_stack_fffffe78 = 3;\n        param_3 = (int *)_dtoa_r(param_1,local_f0,local_128,piVar24);\n        piVar18 = (int *)((int)param_3 + (int)piVar27);\nLAB_0800764c:\n        if ((*(byte *)param_3 == 0x30) &&\n           (iVar4 = __aeabi_dcmpeq(local_128,piVar24,0,0), iVar4 == 0)) {\n          local_f0[0] = (int *)(1 - (int)local_150);\n        }\n        piVar18 = (int *)((int)piVar18 + (int)local_f0[0]);\n      }\n      else if (uVar25 == 0x46) {\n        in_stack_fffffe78 = 3;\n        param_3 = (int *)_dtoa_r(param_1,local_f0,local_128,piVar24);\nLAB_08007760:\n        piVar18 = (int *)((int)param_3 + (int)local_150);\n        if (uVar25 == 0x46) goto LAB_0800764c;\n      }\n      else {\n        if (local_168 == (int *)0x45) {\n          local_150 = (int *)((int)piVar27 + 1);\n        }\n        in_stack_fffffe78 = 2;\n        in_stack_fffffe7c = local_150;\n        param_3 = (int *)_dtoa_r(param_1,local_f0,local_128,piVar24);\n        local_138 = local_e0;\n        if (uVar25 == 0x67) {\n          if ((uVar26 & 1) == 0) goto LAB_08006ca6;\n        }\n        else if (uVar25 == 0x47) {\n          if ((uVar26 & 1) != 0) goto LAB_08007760;\n          goto LAB_08006ca6;\n        }\n        piVar18 = (int *)((int)local_150 + (int)param_3);\n      }\n      iVar4 = __aeabi_dcmpeq(local_128,piVar24,0,0);\n      local_138 = piVar18;\n      if (iVar4 == 0) {\n        for (; local_138 = local_e0, local_e0 < piVar18; local_e0 = (int *)((int)local_e0 + 1)) {\n          *(byte *)local_e0 = 0x30;\n        }\n      }\nLAB_08006ca6:\n      local_138 = (int *)((int)local_138 - (int)param_3);\n      goto LAB_08006cb0;\n    case 0x43:\n    case 99:\n      piVar18 = (int *)0x0;\n      piVar27 = *local_154;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      piVar24 = (int *)0x0;\n      local_13c = 0;\n      local_134 = (int *)0x0;\n      local_130 = 0;\n      local_154 = local_154 + 1;\n      local_168 = (int *)0x1;\n      local_158 = (char *)0x1;\n      local_8c = SUB41(piVar27,0);\n      param_3 = (int *)&local_8c;\n      goto LAB_08006298;\n    case 0x44:\n      uVar26 = uVar26 | 0x10;\n      if ((int)(uVar26 << 0x1a) < 0) goto LAB_080060ec;\nLAB_080065a8:\n      ppiVar16 = local_154 + 1;\n      if ((int)(uVar26 << 0x1b) < 0) {\nLAB_08006bcc:\n        piVar24 = *local_154;\n        piVar18 = (int *)((int)piVar24 >> 0x1f);\n        local_154 = ppiVar16;\n      }\n      else if ((int)(uVar26 << 0x19) < 0) {\n        piVar24 = (int *)(int)*(short *)local_154;\n        piVar18 = (int *)((int)piVar24 >> 0x1f);\n        local_154 = ppiVar16;\n      }\n      else {\n        if (-1 < (int)(uVar26 << 0x16)) goto LAB_08006bcc;\n        piVar24 = (int *)(int)*(char *)local_154;\n        piVar18 = (int *)((int)piVar24 >> 0x1f);\n        local_154 = ppiVar16;\n      }\n      goto LAB_08006102;\n    case 0x4c:\n      uVar26 = uVar26 | 8;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x4f:\n      uVar26 = uVar26 | 0x10;\n    case 0x6f:\n      if ((uVar26 & 0x20) == 0) {\n        ppiVar16 = local_154 + 1;\n        if ((uVar26 & 0x10) == 0) {\n          if ((uVar26 & 0x40) == 0) {\n            if ((uVar26 & 0x200) == 0) goto LAB_08006be2;\n            piVar24 = (int *)(uint)*(byte *)local_154;\n            piVar18 = (int *)0x0;\n            local_154 = ppiVar16;\n          }\n          else {\n            piVar24 = (int *)(uint)*(ushort *)local_154;\n            piVar18 = (int *)0x0;\n            local_154 = ppiVar16;\n          }\n        }\n        else {\nLAB_08006be2:\n          piVar24 = *local_154;\n          piVar18 = (int *)0x0;\n          local_154 = ppiVar16;\n        }\n      }\n      else {\n        ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n        piVar24 = *ppiVar16;\n        piVar18 = ppiVar16[1];\n        local_154 = ppiVar16 + 2;\n      }\n      iVar4 = 0;\n      uVar26 = uVar26 & 0xfffffbff;\n      break;\n    case 0x53:\n    case 0x73:\n      local_f5 = 0;\n      param_3 = *local_154;\n      local_154 = local_154 + 1;\n      local_140 = uVar26;\n      if (param_3 == (int *)0x0) {\n        if ((int *)0x5 < piVar27) {\n          piVar27 = (int *)0x6;\n        }\n        param_3 = (int *)&UNK_08009f44;\n        piVar18 = (int *)0x0;\n        local_148 = (int *)0x0;\n        local_13c = 0;\n        local_134 = (int *)0x0;\n        local_130 = 0;\n        piVar24 = (int *)0x0;\n        local_168 = piVar27;\n        local_158 = (char *)piVar27;\n      }\n      else {\n        if (piVar27 == (int *)0xffffffff) {\n          local_158 = (char *)strlen((char *)param_3);\n        }\n        else {\n          pvVar5 = memchr(param_3,0,(size_t)piVar27);\n          if (pvVar5 == (void *)0x0) {\n            piVar18 = (int *)(uint)local_f5;\n            local_148 = (int *)0x0;\n            local_13c = 0;\n            local_134 = (int *)0x0;\n            local_130 = 0;\n            piVar24 = (int *)0x0;\n            local_168 = piVar27;\n            goto LAB_08006538;\n          }\n          local_158 = (char *)((int)pvVar5 - (int)param_3);\n        }\n        local_148 = (int *)0x0;\n        local_13c = 0;\n        local_134 = (int *)0x0;\n        local_130 = 0;\n        piVar18 = (int *)(uint)local_f5;\n        piVar24 = (int *)0x0;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_08006538;\n    case 0x55:\n      uVar26 = uVar26 | 0x10;\n      if ((int)(uVar26 << 0x1a) < 0) goto LAB_0800618a;\nLAB_080066c0:\n      ppiVar16 = local_154 + 1;\n      if ((int)(uVar26 << 0x1b) < 0) {\nLAB_08006bf2:\n        piVar24 = *local_154;\n        piVar18 = (int *)0x0;\n        iVar4 = 1;\n        local_154 = ppiVar16;\n      }\n      else if ((int)(uVar26 << 0x19) < 0) {\n        piVar24 = (int *)(uint)*(ushort *)local_154;\n        piVar18 = (int *)0x0;\n        iVar4 = 1;\n        local_154 = ppiVar16;\n      }\n      else {\n        if (-1 < (int)(uVar26 << 0x16)) goto LAB_08006bf2;\n        piVar24 = (int *)(uint)*(byte *)local_154;\n        piVar18 = (int *)0x0;\n        iVar4 = 1;\n        local_154 = ppiVar16;\n      }\n      break;\n    case 0x58:\n      local_11c = \"0123456789ABCDEF\";\n      if ((uVar26 & 0x20) != 0) goto LAB_080061ac;\nLAB_08006696:\n      ppiVar16 = local_154 + 1;\n      if ((uVar26 & 0x10) == 0) {\n        if ((uVar26 & 0x40) == 0) {\n          if ((uVar26 & 0x200) == 0) goto LAB_08006bbc;\n          piVar24 = (int *)(uint)*(byte *)local_154;\n          piVar18 = (int *)0x0;\n          local_154 = ppiVar16;\n        }\n        else {\n          piVar24 = (int *)(uint)*(ushort *)local_154;\n          piVar18 = (int *)0x0;\n          local_154 = ppiVar16;\n        }\n      }\n      else {\nLAB_08006bbc:\n        piVar24 = *local_154;\n        piVar18 = (int *)0x0;\n        local_154 = ppiVar16;\n      }\n      goto LAB_080061be;\n    case 100:\n    case 0x69:\n      if (-1 < (int)(uVar26 << 0x1a)) goto LAB_080065a8;\nLAB_080060ec:\n      ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar24 = *ppiVar16;\n      piVar18 = ppiVar16[1];\n      local_154 = ppiVar16 + 2;\nLAB_08006102:\n      if ((int)piVar18 < 0) {\n        bVar30 = piVar24 != (int *)0x0;\n        piVar24 = (int *)-(int)piVar24;\n        piVar18 = (int *)(-(int)piVar18 - (uint)bVar30);\n        local_f5 = 0x2d;\n      }\n      if (piVar27 != (int *)0xffffffff) {\n        iVar4 = 1;\n        iVar6 = 1;\n        local_140 = uVar26 & 0xffffff7f;\n        if (((uint)piVar24 | (uint)piVar18) == 0) goto LAB_080060a4;\n        goto LAB_08006130;\n      }\n      local_140 = uVar26;\n      if (piVar18 != (int *)0x0 || (int *)0x9 < piVar24) goto LAB_08006f16;\n      goto LAB_0800698a;\n    case 0x68:\n      uVar25 = (uint)*(byte *)piVar28;\n      if (uVar25 == 0x68) {\n        uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n        uVar26 = uVar26 | 0x200;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      else {\n        uVar26 = uVar26 | 0x40;\n      }\n      goto LAB_08005f4a;\n    case 0x6a:\n    case 0x71:\n      uVar26 = uVar26 | 0x20;\n    case 0x74:\n    case 0x7a:\nswitchD_08005f58_caseD_74:\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x6c:\n      goto switchD_08005f58_caseD_6c;\n    case 0x6e:\n      ppiVar16 = local_154 + 1;\n      ppbVar17 = (byte **)*local_154;\n      local_154 = ppiVar16;\n      if ((uVar26 & 0x20) != 0) {\n        *ppbVar17 = local_164;\n        ppbVar17[1] = (byte *)((int)local_164 >> 0x1f);\n        goto LAB_0800620e;\n      }\n      if ((uVar26 & 0x10) == 0) {\n        if ((uVar26 & 0x40) != 0) {\n          *(short *)ppbVar17 = (short)local_164;\n          goto LAB_0800620e;\n        }\n        if ((uVar26 & 0x200) != 0) {\n          *(char *)ppbVar17 = (char)local_164;\n          goto LAB_0800620e;\n        }\n      }\n      *ppbVar17 = local_164;\n      goto LAB_0800620e;\n    case 0x70:\n      local_f4 = 0x7830;\n      piVar24 = *local_154;\n      local_11c = \"0123456789abcdef\";\n      uVar26 = uVar26 | 2;\n      piVar18 = (int *)0x0;\n      iVar4 = 2;\n      uVar25 = 0x78;\n      local_154 = local_154 + 1;\n      break;\n    case 0x75:\n      if (-1 < (int)(uVar26 << 0x1a)) goto LAB_080066c0;\nLAB_0800618a:\n      ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar24 = *ppiVar16;\n      piVar18 = ppiVar16[1];\n      iVar4 = 1;\n      local_154 = ppiVar16 + 2;\n      break;\n    case 0x78:\n      local_11c = \"0123456789abcdef\";\n      if ((uVar26 & 0x20) == 0) goto LAB_08006696;\nLAB_080061ac:\n      ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar24 = *ppiVar16;\n      piVar18 = ppiVar16[1];\n      local_154 = ppiVar16 + 2;\nLAB_080061be:\n      if (((uVar26 & 1) != 0) && (((uint)piVar24 | (uint)piVar18) != 0)) {\n        uVar26 = uVar26 | 2;\n        local_f4 = CONCAT11((char)uVar25,0x30);\n      }\n      iVar4 = 2;\n      uVar26 = uVar26 & 0xfffffbff;\n    }\n    local_f5 = 0;\n    if (piVar27 == (int *)0xffffffff) {\n      local_140 = uVar26;\n      if (iVar4 != 1) goto LAB_08006136;\nLAB_08006980:\n      local_140 = uVar26;\n      if (piVar18 == (int *)0x0 && piVar24 < (int *)0xa) goto LAB_0800698a;\nLAB_08006f16:\n      lVar31 = CONCAT44(piVar18,piVar24);\n      local_138 = (int *)0x0;\n      param_3 = (int *)(&bStack_2a + 2);\n      do {\n        iVar4 = (int)((ulonglong)lVar31 >> 0x20);\n        uVar26 = (uint)lVar31;\n        cVar10 = '\\n';\n        __aeabi_uldivmod(uVar26,iVar4,10,0);\n        *(byte *)((int)param_3 + -1) = cVar10 + 0x30;\n        local_138 = (int *)((int)local_138 + 1);\n        param_3 = (int *)((int)param_3 + -1);\n        if (((((local_140 & 0x400) != 0) && (local_138 == (int *)(uint)*local_108)) &&\n            (local_138 != (int *)0xff)) && (iVar4 != 0 || 9 < uVar26)) {\n          param_3 = (int *)((int)param_3 - (int)local_104);\n          strncpy((char *)param_3,(char *)local_110,(size_t)local_104);\n          if (local_108[1] == 0) {\n            local_138 = (int *)0x0;\n          }\n          else {\n            local_108 = local_108 + 1;\n            local_138 = (int *)0x0;\n          }\n        }\n        lVar31 = __aeabi_uldivmod(uVar26,iVar4,10,0);\n      } while (lVar31 != 0);\n      local_158 = (char *)((int)(&bStack_2a + 2) - (int)param_3);\n    }\n    else {\n      local_140 = uVar26 & 0xffffff7f;\n      iVar6 = iVar4;\n      if (((uint)piVar24 | (uint)piVar18) == 0) {\nLAB_080060a4:\n        if (piVar27 == (int *)0x0) {\n          if (iVar4 == 0) {\n            local_158 = (char *)(uVar26 & 1);\n            if ((int *)local_158 == (int *)0x0) {\n              param_3 = (int *)(&bStack_2a + 2);\n            }\n            else {\n              param_3 = (int *)(&bStack_2a + 1);\n              local_29 = '0';\n            }\n          }\n          else {\n            param_3 = (int *)(&bStack_2a + 2);\n          }\n        }\n        else {\n          if (iVar4 != 1) goto LAB_08006136;\nLAB_0800698a:\n          local_29 = (char)piVar24 + '0';\n          param_3 = (int *)(&bStack_2a + 1);\n          local_158 = (char *)0x1;\n        }\n      }\n      else {\nLAB_08006130:\n        iVar4 = iVar6;\n        uVar26 = local_140;\n        if (iVar6 == 1) goto LAB_08006980;\nLAB_08006136:\n        if (iVar4 == 2) {\n          param_3 = (int *)(&bStack_2a + 2);\n          do {\n            piVar19 = (int *)((uint)piVar24 >> 4 | (int)piVar18 << 0x1c);\n            piVar18 = (int *)((uint)piVar18 >> 4);\n            param_3 = (int *)((int)param_3 + -1);\n            *(char *)param_3 = local_11c[(uint)piVar24 & 0xf];\n            piVar24 = piVar19;\n          } while (((uint)piVar19 | (uint)piVar18) != 0);\n        }\n        else {\n          param_3 = (int *)(&bStack_2a + 2);\n          do {\n            piVar19 = param_3;\n            piVar12 = (int *)((uint)piVar24 >> 3 | (int)piVar18 << 0x1d);\n            piVar18 = (int *)((uint)piVar18 >> 3);\n            iVar4 = ((uint)piVar24 & 7) + 0x30;\n            *(byte *)((int)piVar19 + -1) = (byte)iVar4;\n            param_3 = (int *)((int)piVar19 + -1);\n            piVar24 = piVar12;\n          } while (((uint)piVar12 | (uint)piVar18) != 0);\n          if (((local_140 & 1) != 0) && (iVar4 != 0x30)) {\n            param_3 = (int *)((int)piVar19 + -2);\n            local_158 = (char *)(&bStack_2a + (2 - (int)param_3));\n            *(byte *)((int)piVar19 + -2) = 0x30;\n            goto LAB_0800675a;\n          }\n        }\n        local_158 = (char *)(&bStack_2a + (2 - (int)param_3));\n      }\n    }\nLAB_0800675a:\n    local_148 = (int *)0x0;\n    local_13c = 0;\n    local_134 = (int *)0x0;\n    local_130 = 0;\n    piVar18 = (int *)(uint)local_f5;\n    piVar24 = piVar27;\n    local_168 = (int *)local_158;\n    if ((int)local_158 < (int)piVar27) {\n      local_168 = piVar27;\n    }\n    goto LAB_08006538;\n  }\nLAB_08006216:\n  if (local_d0 == (byte *)0x0) {\nLAB_0800604a:\n    uVar15 = *(ushort *)(param_2 + 3);\n  }\n  else {\n    __ssprint_r(param_1,param_2,&local_d8);\n    uVar15 = *(ushort *)(param_2 + 3);\n  }\nLAB_0800604e:\n  if ((uVar15 & 0x40) != 0) {\n    local_164 = (byte *)0xffffffff;\n  }\n  return local_164;\nswitchD_08005f58_caseD_6c:\n  uVar25 = (uint)*(byte *)piVar28;\n  if (uVar25 == 0x6c) {\n    uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n    uVar26 = uVar26 | 0x20;\n    piVar28 = (int *)((int)piVar28 + 1);\n  }\n  else {\n    uVar26 = uVar26 | 0x10;\n  }\n  goto LAB_08005f4a;\n  while (iVar6 = __aeabi_dcmpeq(uVar7,uVar8,0,0), iVar6 == 0) {\nLAB_080072ba:\n    piVar18 = piVar24;\n    piVar19 = local_138;\n    piVar24 = (int *)((int)piVar18 + -1);\n    uVar32 = __muldf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),0,0x40300000);\n    iVar4 = __aeabi_d2iz();\n    uVar33 = __aeabi_i2d();\n    uVar32 = __subdf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),(int)uVar33,\n                      (int)((ulonglong)uVar33 >> 0x20));\n    uVar8 = (undefined4)((ulonglong)uVar32 >> 0x20);\n    uVar7 = (undefined4)uVar32;\n    local_138 = (int *)((int)piVar19 + 1);\n    *(char *)piVar19 = local_158[iVar4];\n    if (piVar24 == (int *)0xffffffff) break;\n  }\n  iVar6 = __aeabi_dcmpgt(uVar7,uVar8,0,0x3fe00000);\n  if ((iVar6 == 0) &&\n     ((iVar6 = __aeabi_dcmpeq(uVar7,uVar8,0,0x3fe00000), iVar6 == 0 || (-1 < iVar4 << 0x1f)))) {\n    if (-1 < (int)piVar24) {\n      piVar18 = (int *)((int)piVar18 + (int)local_138);\n      piVar24 = local_138;\n      do {\n        local_138 = (int *)((int)piVar24 + 1);\n        *(byte *)piVar24 = 0x30;\n        piVar24 = local_138;\n      } while (piVar18 != local_138);\n    }\n  }\n  else {\n    bVar1 = local_158[0xf];\n    bVar11 = *(byte *)piVar19;\n    piVar24 = local_138;\n    local_e0 = piVar19;\n    while (bVar1 == bVar11) {\n      *(byte *)((int)piVar24 + -1) = 0x30;\n      bVar11 = *(byte *)((int)local_e0 + -1);\n      piVar24 = local_e0;\n      local_e0 = (int *)((int)local_e0 + -1);\n    }\n    if (bVar11 == 0x39) {\n      bVar11 = local_158[10];\n    }\n    else {\n      bVar11 = bVar11 + 1;\n    }\n    *(byte *)((int)piVar24 + -1) = bVar11;\n  }\n  local_138 = (int *)((int)local_138 - (int)param_3);\nLAB_08006cb0:\n  local_168 = (int *)(uVar25 & 0xffffffdf);\n  local_134 = local_f0[0];\n  if (local_168 == (int *)0x47) {\n    if (((int)((int)local_f0[0] + 3) < 0 == SCARRY4((int)local_f0[0],3)) &&\n       ((int)local_f0[0] <= (int)piVar27)) {\n      if ((int)local_f0[0] < (int)local_138) {\n        local_158 = (char *)((int)local_138 + (int)piVar3);\n        if (0 < (int)local_f0[0]) {\n          uVar25 = 0x67;\n          goto LAB_080074f8;\n        }\n        local_158 = (char *)((int)local_158 + (1 - (int)local_f0[0]));\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        uVar25 = 0x67;\n      }\n      else {\n        if ((int)(uVar26 << 0x1f) < 0) {\n          local_158 = (char *)((int)local_f0[0] + (int)piVar3);\n        }\n        else {\n          local_158 = (char *)local_f0[0];\n        }\n        if (-1 < (int)(uVar26 << 0x15)) {\n          uVar25 = 0x67;\n          goto LAB_0800754a;\n        }\n        if (0 < (int)local_f0[0]) {\n          uVar25 = 0x67;\n          goto LAB_080074fc;\n        }\n        uVar25 = 0x67;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_080073d6;\n    }\n    uVar25 = uVar25 - 2;\n    local_168 = (int *)(uVar25 & 0xffffffdf);\nLAB_08006cc4:\n    local_e8._0_1_ = (char)uVar25;\n    if (local_168 == (int *)0x41) {\n      local_e8._0_1_ = (char)local_e8 + '\\x0f';\n    }\n    piVar27 = (int *)((int)local_f0[0] + -1);\n    if ((int)piVar27 < 0) {\n      local_e8._1_1_ = 0x2d;\n      local_f0[0] = (int *)(1 - (int)local_f0[0]);\n    }\n    else {\n      local_e8._1_1_ = 0x2b;\n      local_f0[0] = piVar27;\n    }\n    if ((int)local_f0[0] < 10) {\n      if (local_168 == (int *)0x41) {\n        pcVar21 = (char *)((int)&local_e8 + 2);\n      }\n      else {\n        local_e8._2_1_ = 0x30;\n        pcVar21 = (char *)((int)&local_e8 + 3);\n      }\n      *pcVar21 = (char)local_f0[0] + '0';\n      pcVar21 = pcVar21 + 1;\n    }\n    else {\n      pbVar29 = abStack_dc + 3;\n      pbVar23 = pbVar29;\n      do {\n        pbVar9 = pbVar23;\n        piVar24 = (int *)((uint)local_f0[0] / 10);\n        pbVar9[-1] = (char)local_f0[0] + (char)piVar24 * -10 + 0x30;\n        pbVar23 = pbVar9 + -1;\n        local_f0[0] = piVar24;\n      } while ((int *)0x9 < piVar24);\n      uVar22 = (uint)(piVar24 + 0xc) & 0xff;\n      pbVar9[-2] = (byte)uVar22;\n      if (pbVar9 + -2 < pbVar29) {\n        pbVar9 = pbVar23;\n        pcVar21 = (char *)((int)&local_e8 + 2);\n        while( true ) {\n          *pcVar21 = (char)uVar22;\n          if (pbVar29 == pbVar9) break;\n          uVar22 = (uint)*pbVar9;\n          pbVar9 = pbVar9 + 1;\n          pcVar21 = pcVar21 + 1;\n        }\n        pcVar21 = (char *)(((int)&stack0xfffffe78 * 2 - (int)pbVar23) + 0x152);\n      }\n      else {\n        pcVar21 = (char *)((int)&local_e8 + 2);\n      }\n    }\n    local_10c = (int *)(pcVar21 + -(int)&local_e8);\n    local_158 = (char *)((int)local_10c + (int)local_138);\n    if ((1 < (int)local_138) || ((int)(uVar26 << 0x1f) < 0)) {\n      local_158 = (char *)((int)local_158 + (int)piVar3);\n    }\n    local_13c = 0;\n    local_134 = (int *)0x0;\n    local_130 = 0;\n    local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    local_140 = uVar26 & 0xfffffbff | 0x100;\n    local_f0[0] = piVar27;\n  }\n  else {\n    if (local_168 != (int *)0x46) goto LAB_08006cc4;\n    if ((int)local_f0[0] < 1) {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)(uVar26 << 0x1f))) {\n        uVar25 = 0x66;\n        local_168 = (int *)0x1;\n        local_158 = (char *)0x1;\n      }\n      else {\n        uVar25 = 0x66;\n        local_158 = (char *)((byte *)((int)piVar3 + 1) + (int)piVar27);\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\nLAB_080073d6:\n      local_13c = 0;\n      local_130 = 0;\n    }\n    else {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)(uVar26 << 0x1f))) {\n        uVar25 = 0x66;\n        local_158 = (char *)local_f0[0];\n      }\n      else {\n        uVar25 = 0x66;\n        local_158 = (char *)((byte *)((int)local_f0[0] + (int)piVar3) + (int)piVar27);\n      }\nLAB_080074f8:\n      if (-1 < (int)(uVar26 << 0x15)) {\nLAB_0800754a:\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        goto LAB_080073d6;\n      }\nLAB_080074fc:\n      local_13c = 0;\n      local_130 = 0;\n      uVar26 = (uint)*local_108;\n      while (uVar26 != 0xff) {\n        while( true ) {\n          if ((int)local_134 <= (int)uVar26) goto LAB_08007524;\n          uVar22 = (uint)local_108[1];\n          local_134 = (int *)((int)local_134 - uVar26);\n          if (uVar22 == 0) break;\n          local_108 = local_108 + 1;\n          local_130 = local_130 + 1;\n          uVar26 = uVar22;\n          if (uVar22 == 0xff) goto LAB_08007524;\n        }\n        local_13c = local_13c + 1;\n      }\nLAB_08007524:\n      local_158 = (char *)((int)local_104 * (local_130 + local_13c) + (int)local_158);\n      local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    }\n  }\n  if (local_144 == 0) {\n    piVar18 = (int *)(uint)local_f5;\n    piVar24 = (int *)0x0;\nLAB_08006538:\n    uVar26 = local_140;\n    if (piVar18 != (int *)0x0) goto LAB_0800653e;\n  }\n  else {\n    piVar18 = (int *)0x2d;\n    piVar24 = (int *)0x0;\n    local_f5 = 0x2d;\nLAB_0800653e:\n    local_168 = (int *)((int)local_168 + 1);\n    uVar26 = local_140;\n  }\nLAB_08006298:\n  if ((uVar26 & 2) != 0) {\n    local_168 = (int *)((int)local_168 + 2);\n  }\n  if (((uVar26 & 0x84) == 0) &&\n     (piVar27 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar27)) {\n    if (0x10 < (int)piVar27) {\n      do {\n        piVar18 = piVar27;\n        local_d4 = local_d4 + 1;\n        local_d0 = local_d0 + 0x10;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = (int *)0x10;\n        if (local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        piVar27 = piVar18 + -4;\n      } while (0x10 < (int)piVar27);\n      piVar27 = piVar18 + -4;\n    }\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)piVar27;\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar27;\n    if (local_d4 < 8) {\n      piVar18 = (int *)(uint)local_f5;\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar18 = (int *)(uint)local_f5;\n    }\n  }\n  if (piVar18 != (int *)0x0) {\n    local_d0 = local_d0 + 1;\n    local_d4 = local_d4 + 1;\n    *ppiVar2 = (int *)&local_f5;\n    ppiVar2[1] = (int *)0x1;\n    if (local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  if ((uVar26 & 2) != 0) {\n    local_d0 = local_d0 + 2;\n    local_d4 = local_d4 + 1;\n    *ppiVar2 = (int *)&local_f4;\n    ppiVar2[1] = (int *)0x2;\n    if (local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  if (((uVar26 & 0x84) == 0x80) &&\n     (piVar27 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar27)) {\n    if (0x10 < (int)piVar27) {\n      do {\n        while( true ) {\n          piVar18 = piVar27;\n          local_d4 = local_d4 + 1;\n          local_d0 = local_d0 + 0x10;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if (local_d4 < 8) break;\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar27 = piVar18 + -4;\n          if ((int)(piVar18 + -4) < 0x11) goto LAB_08006882;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar27 = piVar18 + -4;\n      } while (0x10 < (int)(piVar18 + -4));\nLAB_08006882:\n      piVar27 = piVar18 + -4;\n    }\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)piVar27;\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar27;\n    if (local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar24 = (int *)((int)piVar24 - (int)local_158);\n  if (0 < (int)piVar24) {\n    if (0x10 < (int)piVar24) {\n      do {\n        while( true ) {\n          piVar27 = piVar24;\n          local_d4 = local_d4 + 1;\n          local_d0 = local_d0 + 0x10;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if (local_d4 < 8) break;\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar24 = piVar27 + -4;\n          if ((int)(piVar27 + -4) < 0x11) goto LAB_080063d2;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar24 = piVar27 + -4;\n      } while (0x10 < (int)(piVar27 + -4));\nLAB_080063d2:\n      piVar24 = piVar27 + -4;\n    }\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)piVar24;\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar24;\n    if (local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  pbVar23 = local_d0;\n  if ((uVar26 & 0x100) == 0) {\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)local_158;\n    *ppiVar2 = param_3;\n    ppiVar2[1] = (int *)local_158;\n    if (local_d4 < 8) {\nLAB_0800640e:\n      ppiVar2 = ppiVar2 + 2;\n      pbVar23 = local_d0;\n    }\n    else {\nLAB_08006a20:\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      pbVar23 = local_d0;\n    }\n  }\n  else if ((int)uVar25 < 0x66) {\n    local_158 = (char *)(local_d0 + 1);\n    iVar4 = local_d4 + 1;\n    ppiVar16 = ppiVar2 + 2;\n    local_d0 = (byte *)local_158;\n    if (((int)local_138 < 2) && ((uVar26 & 1) == 0)) {\n      *ppiVar2 = param_3;\n      ppiVar2[1] = (int *)0x1;\n      if (iVar4 < 8) {\n        local_150 = (int *)(local_d4 + 2);\n        ppiVar2 = ppiVar2 + 4;\n      }\n      else {\n        local_d4 = iVar4;\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        local_150 = (int *)(local_d4 + 1);\n        ppiVar16 = local_cc;\n        local_158 = (char *)local_d0;\n        ppiVar2 = local_cc + 2;\n      }\n    }\n    else {\n      *ppiVar2 = param_3;\n      ppiVar2[1] = (int *)0x1;\n      local_d4 = iVar4;\n      if (7 < iVar4) {\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        ppiVar16 = local_cc;\n        local_158 = (char *)local_d0;\n      }\n      local_d4 = local_d4 + 1;\n      local_d0 = (byte *)(local_158 + (int)piVar3);\n      *ppiVar16 = __s;\n      ppiVar16[1] = piVar3;\n      if (local_d4 < 8) {\n        ppiVar20 = ppiVar16 + 2;\n      }\n      else {\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        ppiVar20 = local_cc;\n      }\n      local_158 = (char *)local_d0;\n      iVar4 = local_d4;\n      local_150 = (int *)(local_d4 + 1);\n      piVar27 = (int *)((int)local_138 + -1);\n      ppiVar13 = ppiVar20 + 2;\n      iVar6 = __aeabi_dcmpeq(local_128,local_12c,0,0);\n      local_d4 = (int)local_150;\n      if (iVar6 == 0) {\n        local_158 = (char *)((byte *)local_158 + (int)piVar27);\n        *ppiVar20 = (int *)((int)param_3 + 1);\n        ppiVar20[1] = piVar27;\n        local_d0 = (byte *)local_158;\n        if ((int)local_150 < 8) {\n          local_150 = (int *)(iVar4 + 2);\n          ppiVar16 = ppiVar13;\n          ppiVar2 = ppiVar20 + 4;\n        }\n        else {\nLAB_08006d9c:\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          local_150 = (int *)(local_d4 + 1);\n          local_158 = (char *)local_d0;\n          ppiVar16 = local_cc;\n          ppiVar2 = local_cc + 2;\n        }\n      }\n      else {\n        ppiVar16 = ppiVar20;\n        ppiVar2 = ppiVar13;\n        if (0 < (int)piVar27) {\n          if (0x10 < (int)piVar27) {\n            while( true ) {\n              local_d0 = (byte *)local_158 + 0x10;\n              *ppiVar20 = (int *)0x8009f60;\n              ppiVar20[1] = (int *)0x10;\n              if (local_d4 < 8) {\n                ppiVar20 = ppiVar20 + 2;\n              }\n              else {\n                iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                if (iVar4 != 0) goto LAB_0800603e;\n                ppiVar20 = local_cc;\n              }\n              piVar27 = piVar27 + -4;\n              local_158 = (char *)local_d0;\n              if ((int)piVar27 < 0x11) break;\n              local_d4 = local_d4 + 1;\n            }\n            local_150 = (int *)(local_d4 + 1);\n            ppiVar13 = ppiVar20 + 2;\n          }\n          *ppiVar20 = (int *)0x8009f60;\n          ppiVar20[1] = piVar27;\n          local_158 = local_158 + (int)piVar27;\n          local_d4 = (int)local_150;\n          local_d0 = (byte *)local_158;\n          if (7 < (int)local_150) goto LAB_08006d9c;\n          local_150 = (int *)((int)local_150 + 1);\n          ppiVar2 = ppiVar13 + 2;\n          ppiVar16 = ppiVar13;\n        }\n      }\n    }\n    ppiVar16[1] = local_10c;\n    local_d0 = (byte *)(local_158 + (int)local_10c);\n    local_d4 = (int)local_150;\n    *ppiVar16 = &local_e8;\n    pbVar23 = local_d0;\n    if (7 < (int)local_150) {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      pbVar23 = local_d0;\n    }\n  }\n  else {\n    iVar4 = __aeabi_dcmpeq(local_128,local_12c,0,0);\n    if (iVar4 == 0) {\n      if ((int)local_f0[0] < 1) {\n        local_d4 = local_d4 + 1;\n        local_d0 = pbVar23 + 1;\n        *ppiVar2 = (int *)&DAT_08009f4c;\n        ppiVar2[1] = (int *)0x1;\n        if (local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        if (((local_f0[0] != (int *)0x0) || (local_138 != (int *)0x0)) ||\n           (pbVar23 = local_d0, (uVar26 & 1) != 0)) {\n          local_d4 = local_d4 + 1;\n          local_d0 = local_d0 + (int)piVar3;\n          *ppiVar2 = __s;\n          ppiVar2[1] = piVar3;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n          }\n          if ((int)local_f0[0] < 0) {\n            piVar27 = (int *)-(int)local_f0[0];\n            if ((int)(local_f0[0] + 4) < 0 != SCARRY4((int)local_f0[0],0x10)) {\n              do {\n                local_d4 = local_d4 + 1;\n                local_d0 = local_d0 + 0x10;\n                *ppiVar2 = (int *)0x8009f60;\n                ppiVar2[1] = (int *)0x10;\n                if (local_d4 < 8) {\n                  ppiVar2 = ppiVar2 + 2;\n                }\n                else {\n                  iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                  if (iVar4 != 0) goto LAB_0800603e;\n                  ppiVar2 = local_cc;\n                }\n                piVar27 = piVar27 + -4;\n              } while (0x10 < (int)piVar27);\n            }\n            local_d4 = local_d4 + 1;\n            local_d0 = local_d0 + (int)piVar27;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = piVar27;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\n          local_d0 = local_d0 + (int)local_138;\n          *ppiVar2 = param_3;\n          ppiVar2[1] = local_138;\n          goto joined_r0x08006a1c;\n        }\n      }\n      else {\n        piVar27 = local_134;\n        if ((int)local_138 <= (int)local_134) {\n          piVar27 = local_138;\n        }\n        if (0 < (int)piVar27) {\n          local_d0 = pbVar23 + (int)piVar27;\n          local_d4 = local_d4 + 1;\n          *ppiVar2 = param_3;\n          ppiVar2[1] = piVar27;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            pbVar23 = local_d0;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            pbVar23 = local_d0;\n          }\n        }\n        piVar24 = local_134;\n        if (-1 < (int)piVar27) {\n          piVar24 = (int *)((int)local_134 - (int)piVar27);\n        }\n        if (0 < (int)piVar24) {\n          for (; 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + 0x10;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            pbVar23 = local_d0;\n          }\n          local_d4 = local_d4 + 1;\n          pbVar23 = pbVar23 + (int)piVar24;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar24;\n          local_d0 = pbVar23;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            pbVar23 = local_d0;\n          }\n        }\n        local_134 = (int *)((int)local_134 + (int)param_3);\n        if ((uVar26 & 0x400) != 0) {\n          if (local_130 == 0) goto LAB_08007176;\nLAB_080070ba:\n          if (local_13c != 0) goto LAB_0800717e;\n          local_108 = local_108 + -1;\n          local_130 = local_130 + -1;\n          do {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + (int)local_104;\n            *ppiVar2 = local_110;\n            ppiVar2[1] = local_104;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar24 = (int *)(uint)*local_108;\n            piVar27 = (int *)((byte *)((int)param_3 + (int)local_138) + -(int)local_134);\n            if ((int)piVar24 <= (int)((byte *)((int)param_3 + (int)local_138) + -(int)local_134)) {\n              piVar27 = piVar24;\n            }\n            if (0 < (int)piVar27) {\n              local_d0 = local_d0 + (int)piVar27;\n              local_d4 = local_d4 + 1;\n              *ppiVar2 = local_134;\n              ppiVar2[1] = piVar27;\n              if (local_d4 < 8) {\n                piVar24 = (int *)(uint)*local_108;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                if (iVar4 != 0) goto LAB_0800603e;\n                ppiVar2 = local_cc;\n                piVar24 = (int *)(uint)*local_108;\n              }\n            }\n            piVar18 = piVar24;\n            if (-1 < (int)piVar27) {\n              piVar18 = (int *)((int)piVar24 - (int)piVar27);\n            }\n            if (0 < (int)piVar18) {\n              for (; 0x10 < (int)piVar18; piVar18 = piVar18 + -4) {\n                while( true ) {\n                  local_d4 = local_d4 + 1;\n                  local_d0 = local_d0 + 0x10;\n                  *ppiVar2 = (int *)0x8009f60;\n                  ppiVar2[1] = (int *)0x10;\n                  if (local_d4 < 8) break;\n                  iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                  if (iVar4 != 0) goto LAB_0800603e;\n                  piVar18 = piVar18 + -4;\n                  ppiVar2 = local_cc;\n                  if ((int)piVar18 < 0x11) goto LAB_08007156;\n                }\n                ppiVar2 = ppiVar2 + 2;\n              }\nLAB_08007156:\n              local_d4 = local_d4 + 1;\n              local_d0 = local_d0 + (int)piVar18;\n              *ppiVar2 = (int *)0x8009f60;\n              ppiVar2[1] = piVar18;\n              if (local_d4 < 8) {\n                piVar24 = (int *)(uint)*local_108;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                if (iVar4 != 0) goto LAB_0800603e;\n                piVar24 = (int *)(uint)*local_108;\n                ppiVar2 = local_cc;\n              }\n            }\n            local_134 = (int *)((int)local_134 + (int)piVar24);\n            pbVar23 = local_d0;\n            if (local_130 != 0) goto LAB_080070ba;\nLAB_08007176:\n            if (local_13c == 0) {\n              if ((int *)((int)param_3 + (int)local_138) <= local_134) {\n                local_134 = (int *)((int)param_3 + (int)local_138);\n              }\n              break;\n            }\nLAB_0800717e:\n            local_13c = local_13c + -1;\n          } while( true );\n        }\n        if (((int)local_f0[0] < (int)local_138) || ((uVar26 & 1) != 0)) {\n          local_d4 = local_d4 + 1;\n          local_d0 = pbVar23 + (int)piVar3;\n          *ppiVar2 = __s;\n          ppiVar2[1] = piVar3;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            pbVar23 = local_d0;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            pbVar23 = local_d0;\n          }\n        }\n        piVar27 = (int *)((int)local_138 - (int)local_f0[0]);\n        piVar24 = (int *)((byte *)((int)param_3 + (int)local_138) + -(int)local_134);\n        if ((int)piVar27 <= (int)((byte *)((int)param_3 + (int)local_138) + -(int)local_134)) {\n          piVar24 = piVar27;\n        }\n        if (0 < (int)piVar24) {\n          local_d0 = pbVar23 + (int)piVar24;\n          local_d4 = local_d4 + 1;\n          *ppiVar2 = local_134;\n          ppiVar2[1] = piVar24;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            pbVar23 = local_d0;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = (int *)((int)local_138 - (int)local_f0[0]);\n            pbVar23 = local_d0;\n          }\n        }\n        if (-1 < (int)piVar24) {\n          piVar27 = (int *)((int)piVar27 - (int)piVar24);\n        }\n        if (0 < (int)piVar27) {\n          for (; 0x10 < (int)piVar27; piVar27 = piVar27 + -4) {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + 0x10;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            pbVar23 = local_d0;\n          }\n          goto LAB_08007014;\n        }\n      }\n    }\n    else {\n      local_d4 = local_d4 + 1;\n      local_d0 = pbVar23 + 1;\n      *ppiVar2 = (int *)&DAT_08009f4c;\n      ppiVar2[1] = (int *)0x1;\n      if (local_d4 < 8) {\n        ppiVar2 = ppiVar2 + 2;\n      }\n      else {\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        ppiVar2 = local_cc;\n      }\n      if (((int)local_f0[0] < (int)local_138) || (pbVar23 = local_d0, (uVar26 & 1) != 0)) {\n        local_d4 = local_d4 + 1;\n        local_d0 = local_d0 + (int)piVar3;\n        *ppiVar2 = __s;\n        ppiVar2[1] = piVar3;\n        if (local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        piVar27 = (int *)((int)local_138 + -1);\n        pbVar23 = local_d0;\n        if (0 < (int)piVar27) {\n          for (; 0x10 < (int)piVar27; piVar27 = piVar27 + -4) {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + 0x10;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            pbVar23 = local_d0;\n          }\nLAB_08007014:\n          local_d0 = pbVar23 + (int)piVar27;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar27;\njoined_r0x08006a1c:\n          local_d4 = local_d4 + 1;\n          if (7 < local_d4) goto LAB_08006a20;\n          goto LAB_0800640e;\n        }\n      }\n    }\n  }\n  if (((uVar26 & 4) != 0) && (piVar27 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar27))\n  {\n    for (; local_d0 = pbVar23, 0x10 < (int)piVar27; piVar27 = piVar27 + -4) {\n      while( true ) {\n        local_d4 = local_d4 + 1;\n        local_d0 = local_d0 + 0x10;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = (int *)0x10;\n        if (local_d4 < 8) break;\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        piVar27 = piVar27 + -4;\n        ppiVar2 = local_cc;\n        if ((int)piVar27 < 0x11) goto LAB_0800647a;\n      }\n      ppiVar2 = ppiVar2 + 2;\n      pbVar23 = local_d0;\n    }\nLAB_0800647a:\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)piVar27;\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar27;\n    pbVar23 = local_d0;\n    if ((7 < local_d4) &&\n       (iVar4 = __ssprint_r(param_1,param_2,&local_d8), pbVar23 = local_d0, iVar4 != 0))\n    goto LAB_0800603e;\n  }\n  if ((int)local_15c < (int)local_168) {\n    local_15c = local_168;\n  }\n  local_164 = local_164 + (int)local_15c;\n  if ((pbVar23 == (byte *)0x0) || (iVar4 = __ssprint_r(param_1,param_2,&local_d8), iVar4 == 0)) {\n    local_d4 = 0;\n    if (local_148 != (int *)0x0) {\n      _free_r(param_1,local_148);\n    }\n    ppiVar2 = local_cc;\nLAB_0800620e:\n    bVar1 = *(byte *)piVar28;\n    param_3 = piVar28;\n    goto joined_r0x08005ef2;\n  }\nLAB_0800603e:\n  if (local_148 != (int *)0x0) {\n    _free_r(param_1,local_148);\n  }\n  goto LAB_0800604a;\nswitchD_08005f58_caseD_31:\n  local_15c = (int *)0x0;\n  uVar22 = uVar25 - 0x30;\n  piVar24 = piVar28;\n  do {\n    piVar28 = (int *)((int)piVar24 + 1);\n    uVar25 = (uint)*(byte *)piVar24;\n    local_15c = (int *)(uVar22 + (int)local_15c * 10);\n    uVar22 = uVar25 - 0x30;\n    piVar24 = piVar28;\n  } while (uVar22 < 10);\n  goto LAB_08005f4e;\nswitchD_08005f58_caseD_20:\n  uVar25 = (uint)*(byte *)piVar28;\n  if (local_f5 == 0) {\n    local_f5 = 0x20;\n  }\n  goto LAB_08005f4a;\n}\n\n",
            "renaming": {
                "FUN_08005e9c": "FUNC_08005e9c"
            },
            "calling": [
                "sprintf"
            ],
            "called": [
                "__ssprint_r",
                "__aeabi_dcmpgt",
                "__aeabi_uldivmod",
                "_dtoa_r",
                "_localeconv_r",
                "__aeabi_dcmpeq",
                "__aeabi_dcmple",
                "__unorddf2",
                "frexp",
                "__aeabi_dcmplt",
                "__subdf3",
                "strncpy",
                "__aeabi_i2d",
                "_malloc_r",
                "strlen",
                "_free_r",
                "__muldf3",
                "__aeabi_d2iz",
                "memchr"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078a0": {
            "entrypoint": "0x080078a0",
            "current_name": "FUNC_080078a0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080078a4) */\n\nvoid FUNC_080078a0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080078a0": "FUNC_080078a0"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "atexit"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078b4": {
            "entrypoint": "0x080078b4",
            "current_name": "register_exit_procedure_080078b4",
            "code": "\nint registerExitProcedure_080078b4(functionStruct *functionStruct)\n\n{\n  int returnValue;\n  \n  returnValue = __register_exitproc(0,functionStruct,0);\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080078b4": "register_exit_procedure_080078b4",
                "__func": "functionStruct",
                "iVar1": "returnValue"
            },
            "calling": [
                "register_fini"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080078c0": {
            "entrypoint": "0x080078c0",
            "current_name": "calculate_ratio_080078c0",
            "code": "\nuint calculateRatio_080078c0(int numerator,int denominator)\n\n{\n  uint result;\n  uint *numeratorPtr;\n  int carry;\n  int numeratorSize;\n  int lastIndex;\n  uint ratio;\n  uint *denominatorPtr;\n  uint *numeratorArray;\n  uint *denominatorArray;\n  uint temp;\n  uint *denominatorPtr2;\n  uint *numeratorPtr2;\n  \n  numeratorSize = *(int *)(denominator + 0x10);\n  if (*(int *)(numerator + 0x10) < numeratorSize) {\n    return 0;\n  }\n  lastIndex = numeratorSize + -1;\n  denominatorPtr = (uint *)(denominator + 0x14);\n  numeratorArray = (uint *)(numerator + 0x14);\n  ratio = numeratorArray[lastIndex] / (denominatorPtr[lastIndex] + 1);\n  denominatorArray = denominatorPtr + lastIndex;\n  if (ratio != 0) {\n    result = 0;\n    carry = 0;\n    numeratorPtr = numeratorArray;\n    denominatorPtr2 = denominatorPtr;\n    do {\n      numeratorPtr2 = denominatorPtr2 + 1;\n      result = ratio * (*denominatorPtr2 & 0xffff) + result;\n      temp = ratio * (*denominatorPtr2 >> 0x10) + (result >> 0x10);\n      result = (carry - (result & 0xffff)) + (*numeratorPtr & 0xffff);\n      carry = ((*numeratorPtr >> 0x10) - (temp & 0xffff)) + ((int)result >> 0x10);\n      *numeratorPtr = result & 0xffff | carry * 0x10000;\n      carry = carry >> 0x10;\n      result = temp >> 0x10;\n      numeratorPtr = numeratorPtr + 1;\n      denominatorPtr2 = numeratorPtr2;\n    } while (numeratorPtr2 <= denominatorArray);\n    if (numeratorArray[lastIndex] == 0) {\n      if ((numeratorArray < numeratorArray + numeratorSize + -2) && (numeratorArray[numeratorSize + -2] == 0)) {\n        numeratorPtr = numeratorArray + numeratorSize + -3;\n        do {\n          lastIndex = lastIndex + -1;\n          if (numeratorPtr <= numeratorArray) break;\n          result = *numeratorPtr;\n          numeratorPtr = numeratorPtr + -1;\n        } while (result == 0);\n      }\n      *(int *)(numerator + 0x10) = lastIndex;\n    }\n  }\n  numeratorSize = __mcmp();\n  if (-1 < numeratorSize) {\n    numeratorSize = 0;\n    ratio = ratio + 1;\n    numeratorPtr = numeratorArray;\n    do {\n      denominatorPtr2 = denominatorPtr + 1;\n      result = (numeratorSize - (*denominatorPtr & 0xffff)) + (*numeratorPtr & 0xffff);\n      numeratorSize = ((*numeratorPtr >> 0x10) - (*denominatorPtr >> 0x10)) + ((int)result >> 0x10);\n      *numeratorPtr = result & 0xffff | numeratorSize * 0x10000;\n      numeratorSize = numeratorSize >> 0x10;\n      numeratorPtr = numeratorPtr + 1;\n      denominatorPtr = denominatorPtr2;\n    } while (denominatorPtr2 <= denominatorArray);\n    if (numeratorArray[lastIndex] == 0) {\n      if ((numeratorArray < numeratorArray + lastIndex + -1) && (numeratorArray[lastIndex + -1] == 0)) {\n        denominatorPtr = numeratorArray + lastIndex + -2;\n        do {\n          lastIndex = lastIndex + -1;\n          if (denominatorPtr <= numeratorArray) break;\n          result = *denominatorPtr;\n          denominatorPtr = denominatorPtr + -1;\n        } while (result == 0);\n      }\n      *(int *)(numerator + 0x10) = lastIndex;\n    }\n  }\n  return ratio;\n}\n\n",
            "renaming": {
                "FUN_080078c0": "calculate_ratio_080078c0",
                "param_1": "numerator",
                "param_2": "denominator",
                "uVar1": "result",
                "puVar2": "numeratorPtr",
                "iVar3": "carry",
                "iVar4": "numeratorSize",
                "iVar5": "lastIndex",
                "uVar6": "ratio",
                "puVar7": "denominatorPtr",
                "puVar8": "numeratorArray",
                "puVar9": "denominatorArray",
                "uVar10": "temp",
                "puVar11": "denominatorPtr2",
                "puVar12": "numeratorPtr2"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__mcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080079e8": {
            "entrypoint": "0x080079e8",
            "current_name": "convert_double_to_string_080079e8",
            "code": "\nchar * convertDoubleToString_080079e8(int doubleValue,undefined4 undefined1,uint integerPart,uint bitwiseSign,uint exponentAndFractionLength,\n                   uint fractionPart,int *errorCode,uint *sign,char **fractionString)\n\n{\n  bool isBitwiseValueLowerThan6;\n  bool needsPadding;\n  bool isDigitCharGreater;\n  char digitChar;\n  byte byteValue;\n  undefined4 uVar6;\n  int localCounter;\n  int comparisonResult;\n  int tempVariable;\n  char *pcVar10;\n  uint tempVariable1;\n  undefined4 undefined2;\n  undefined4 undefined3;\n  int decimalPos;\n  int iVar15;\n  undefined4 undefined4;\n  uint temporaryBitwiseValue;\n  uint temporaryValue;\n  int exponentAdjustment;\n  char *pcVar20;\n  char *pcVar21;\n  undefined4 *puVar22;\n  undefined4 temporaryValue2;\n  int digitChar;\n  bool isParam4Negative;\n  undefined8 temporaryValue3;\n  undefined8 temporaryValue4;\n  undefined8 temporaryValue5;\n  uint temporaryValue7;\n  uint inputValue;\n  uint exponent;\n  int decimalPosAdjusted;\n  uint undefined7;\n  int fractionPartSizeAdjusted;\n  int exponentDiff;\n  uint isExponentGreater;\n  uint exponentValue;\n  uint temporaryValue8;\n  uint undefined6;\n  uint fractionPartSize;\n  int undefined5;\n  int local_2c [2];\n  \n  decimalPos = *(int *)(doubleValue + 0x40);\n  if (decimalPos != 0) {\n    temporaryValue = *(uint *)(doubleValue + 0x44);\n    *(uint *)(decimalPos + 4) = temporaryValue;\n    *(int *)(decimalPos + 8) = 1 << (temporaryValue & 0xff);\n    _Bfree(doubleValue,decimalPos);\n    *(undefined4 *)(doubleValue + 0x40) = 0;\n  }\n  isParam4Negative = (int)bitwiseSign < 0;\n  temporaryValue = bitwiseSign;\n  if (isParam4Negative) {\n    temporaryValue = bitwiseSign & 0x7fffffff;\n  }\n  *sign = (uint)isParam4Negative;\n  inputValue = bitwiseSign;\n  if (isParam4Negative) {\n    inputValue = temporaryValue;\n  }\n  temporaryBitwiseValue = inputValue;\n  if ((~temporaryValue & 0x7ff00000) == 0) {\n    *errorCode = 9999;\n    if ((integerPart == 0) && ((temporaryValue & 0xfffff) == 0)) {\n      pcVar10 = \"Infinity\";\n      if (fractionString == (char **)0x0) {\n        return pcVar10;\n      }\n      pcVar21 = \"\";\n    }\n    else {\n      pcVar10 = \"NaN\";\n      if (fractionString == (char **)0x0) {\n        return pcVar10;\n      }\n      pcVar21 = \"\";\n    }\n    *fractionString = pcVar21;\n    return pcVar10;\n  }\n  temporaryValue3 = __aeabi_dcmpeq(integerPart,inputValue,0,0);\n  if ((int)temporaryValue3 != 0) {\n    *errorCode = 1;\n    if (fractionString != (char **)0x0) {\n      *fractionString = \"\";\n      return \"0\";\n    }\n    return \"0\";\n  }\n  uVar6 = __d2b(doubleValue,(int)((ulonglong)temporaryValue3 >> 0x20),integerPart,inputValue,local_2c,&undefined5);\n  decimalPos = undefined5;\n  if (temporaryValue >> 0x14 == 0) {\n    exponentAdjustment = local_2c[0] + undefined5;\n    iVar15 = exponentAdjustment + 0x432;\n    if (iVar15 < 0x21) {\n      temporaryValue = integerPart << (0x20U - iVar15 & 0xff);\n    }\n    else {\n      temporaryValue = integerPart >> (exponentAdjustment + 0x412U & 0xff) | temporaryValue << (0x40U - iVar15 & 0xff);\n    }\n    temporaryValue3 = __floatunsidf(temporaryValue);\n    exponentAdjustment = exponentAdjustment + -1;\n    isParam4Negative = true;\n    tempVariable1 = (int)((ulonglong)temporaryValue3 >> 0x20) + 0xfe100000;\n    temporaryValue = (uint)temporaryValue3;\n  }\n  else {\n    exponentAdjustment = (temporaryValue >> 0x14) - 0x3ff;\n    tempVariable1 = inputValue & 0xfffff | 0x3ff00000;\n    isParam4Negative = false;\n    temporaryValue = integerPart;\n  }\n  temporaryValue3 = __subdf3(temporaryValue,tempVariable1,0,0x3ff80000);\n  temporaryValue3 = __muldf3((int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20),0x636f4361,0x3fd287a7);\n  temporaryValue3 = __aeabi_dadd((int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20),0x8b60c8b3,0x3fc68a28);\n  temporaryValue4 = __aeabi_i2d(exponentAdjustment);\n  temporaryValue4 = __muldf3((int)temporaryValue4,(int)((ulonglong)temporaryValue4 >> 0x20),0x509f79fb,0x3fd34413);\n  temporaryValue3 = __aeabi_dadd((int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20),(int)temporaryValue4,\n                        (int)((ulonglong)temporaryValue4 >> 0x20));\n  undefined3 = (undefined4)((ulonglong)temporaryValue3 >> 0x20);\n  exponent = __aeabi_d2iz();\n  iVar15 = __aeabi_dcmplt((int)temporaryValue3,undefined3,0,0);\n  if (iVar15 != 0) {\n    temporaryValue4 = __aeabi_i2d(exponent);\n    iVar15 = __aeabi_dcmpeq((int)temporaryValue4,(int)((ulonglong)temporaryValue4 >> 0x20),(int)temporaryValue3,undefined3);\n    if (iVar15 == 0) {\n      exponent = exponent - 1;\n    }\n  }\n  if (exponent < 0x17) {\n    iVar15 = __aeabi_dcmpgt(*(undefined4 *)(&__mprec_tens + exponent * 8),\n                            *(undefined4 *)(&DAT_08009fac + exponent * 8),integerPart,inputValue);\n    if (iVar15 == 0) {\n      needsPadding = false;\n    }\n    else {\n      exponent = exponent - 1;\n      needsPadding = false;\n    }\n  }\n  else {\n    needsPadding = true;\n  }\n  iVar15 = (decimalPos - exponentAdjustment) + -1;\n  if (iVar15 < 0) {\n    decimalPosAdjusted = 1 - (decimalPos - exponentAdjustment);\n    iVar15 = 0;\n  }\n  else {\n    decimalPosAdjusted = 0;\n  }\n  if ((int)exponent < 0) {\n    isExponentGreater = 0;\n    decimalPosAdjusted = decimalPosAdjusted - exponent;\n    exponentDiff = -exponent;\n  }\n  else {\n    iVar15 = iVar15 + exponent;\n    isExponentGreater = exponent;\n    exponentDiff = 0;\n  }\n  if (9 < exponentAndFractionLength) {\n    undefined6 = 0xffffffff;\n    isBitwiseValueLowerThan6 = true;\n    undefined7 = 0xffffffff;\n    isDigitCharGreater = true;\n    exponentAndFractionLength = 0;\n    fractionPart = 0;\n    goto LAB_08007c24;\n  }\n  isBitwiseValueLowerThan6 = (int)exponentAndFractionLength < 6;\n  if (!isBitwiseValueLowerThan6) {\n    exponentAndFractionLength = exponentAndFractionLength - 4;\n  }\n  switch(exponentAndFractionLength) {\n  case 2:\n    isDigitCharGreater = false;\n    break;\n  case 3:\n    isDigitCharGreater = false;\n    goto LAB_08008300;\n  case 4:\n    isDigitCharGreater = true;\n    break;\n  case 5:\n    isDigitCharGreater = true;\nLAB_08008300:\n    undefined6 = exponent + fractionPart;\n    undefined7 = undefined6 + 1;\n    temporaryValue = undefined7;\n    if ((int)undefined7 < 1) {\n      temporaryValue = 1;\n    }\n    goto LAB_08008314;\n  default:\n    *(undefined4 *)(doubleValue + 0x44) = 0;\n    pcVar10 = (char *)_Balloc(doubleValue,0);\n    undefined6 = 0xffffffff;\n    undefined7 = 0xffffffff;\n    fractionPart = 0;\n    *(char **)(doubleValue + 0x40) = pcVar10;\n    isDigitCharGreater = true;\n    goto LAB_08007e36;\n  }\n  if ((int)fractionPart < 1) {\n    undefined6 = 1;\n    fractionPart = 1;\n    undefined7 = 1;\nLAB_08007c24:\n    *(undefined4 *)(doubleValue + 0x44) = 0;\n    tempVariable1 = undefined6;\n  }\n  else {\n    undefined6 = fractionPart;\n    undefined7 = fractionPart;\n    temporaryValue = fractionPart;\nLAB_08008314:\n    *(undefined4 *)(doubleValue + 0x44) = 0;\n    tempVariable1 = undefined7;\n    if (0x17 < (int)temporaryValue) {\n      exponentAdjustment = 4;\n      decimalPos = 1;\n      do {\n        localCounter = decimalPos;\n        exponentAdjustment = exponentAdjustment * 2;\n        decimalPos = localCounter + 1;\n      } while (exponentAdjustment + 0x14U <= temporaryValue);\n      *(int *)(doubleValue + 0x44) = localCounter;\n    }\n  }\n  pcVar10 = (char *)_Balloc(doubleValue);\n  *(char **)(doubleValue + 0x40) = pcVar10;\n  if ((tempVariable1 < 0xf) && (isBitwiseValueLowerThan6)) {\n    if ((int)exponent < 1) {\n      if (exponent == 0) {\n        decimalPos = 2;\n        temporaryValue7 = integerPart;\n      }\n      else {\n        decimalPos = (-exponent & 0xf) * 8;\n        temporaryValue3 = __muldf3(integerPart,inputValue,*(undefined4 *)(&__mprec_tens + decimalPos),\n                          *(undefined4 *)(&DAT_08009fac + decimalPos));\n        inputValue = (uint)((ulonglong)temporaryValue3 >> 0x20);\n        temporaryValue7 = (uint)temporaryValue3;\n        exponentAdjustment = (int)-exponent >> 4;\n        if (exponentAdjustment == 0) {\n          decimalPos = 2;\n        }\n        else {\n          isBitwiseValueLowerThan6 = false;\n          decimalPos = 2;\n          puVar22 = &__mprec_bigtens;\n          do {\n            if (exponentAdjustment << 0x1f < 0) {\n              temporaryValue3 = __muldf3((int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20),*puVar22,puVar22[1]);\n              isBitwiseValueLowerThan6 = true;\n              decimalPos = decimalPos + 1;\n            }\n            exponentAdjustment = exponentAdjustment >> 1;\n            puVar22 = puVar22 + 2;\n          } while (exponentAdjustment != 0);\n          if (isBitwiseValueLowerThan6) {\n            temporaryValue7 = (uint)temporaryValue3;\n            inputValue = (uint)((ulonglong)temporaryValue3 >> 0x20);\n          }\n        }\n      }\n    }\n    else {\n      temporaryValue = (int)exponent >> 4;\n      temporaryValue4 = *(undefined8 *)(&__mprec_tens + (exponent & 0xf) * 8);\n      temporaryValue3 = *(undefined8 *)(&__mprec_tens + (exponent & 0xf) * 8);\n      if ((int)(temporaryValue << 0x1b) < 0) {\n        temporaryValue5 = __divdf3(integerPart,inputValue,0x7f73bf3c,0x75154fdd);\n        temporaryValue8 = (uint)((ulonglong)temporaryValue5 >> 0x20);\n        exponentValue = (uint)temporaryValue5;\n        decimalPos = 3;\n        temporaryValue = temporaryValue & 0xf;\n      }\n      else {\n        decimalPos = 2;\n        temporaryValue8 = inputValue;\n        exponentValue = integerPart;\n      }\n      if (temporaryValue != 0) {\n        puVar22 = &__mprec_bigtens;\n        do {\n          if ((int)(temporaryValue << 0x1f) < 0) {\n            temporaryValue3 = __muldf3((int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20),*puVar22,puVar22[1]);\n            decimalPos = decimalPos + 1;\n          }\n          temporaryValue = (int)temporaryValue >> 1;\n          puVar22 = puVar22 + 2;\n          temporaryValue4 = temporaryValue3;\n        } while (temporaryValue != 0);\n      }\n      inputValue = (uint)((ulonglong)temporaryValue4 >> 0x20);\n      temporaryValue7 = (uint)temporaryValue4;\n      temporaryValue3 = __divdf3(exponentValue,temporaryValue8,temporaryValue7,inputValue);\n      temporaryValue7 = (uint)temporaryValue3;\n      inputValue = (uint)((ulonglong)temporaryValue3 >> 0x20);\n    }\n    temporaryValue3 = CONCAT44(inputValue,temporaryValue7);\n    if ((needsPadding) && (exponentAdjustment = __aeabi_dcmplt(temporaryValue7,inputValue,0,0x3ff00000), exponentAdjustment != 0)) {\n      if (undefined7 == 0) {\n        temporaryValue3 = __aeabi_i2d(decimalPos);\n        temporaryValue3 = __muldf3((int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20),temporaryValue7,inputValue);\n        temporaryValue3 = __aeabi_dadd((int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20),0,0x401c0000);\n        undefined3 = (undefined4)temporaryValue3;\n        decimalPos = (int)((ulonglong)temporaryValue3 >> 0x20) + -0x3400000;\n        goto LAB_0800852e;\n      }\n      if (0 < (int)undefined6) {\n        temporaryValue3 = __muldf3(temporaryValue7,inputValue,0,0x40240000);\n        temporaryValue4 = __aeabi_i2d(decimalPos + 1);\n        temporaryValue4 = __muldf3((int)temporaryValue4,(int)((ulonglong)temporaryValue4 >> 0x20),(int)temporaryValue3,\n                          (int)((ulonglong)temporaryValue3 >> 0x20));\n        temporaryValue4 = __aeabi_dadd((int)temporaryValue4,(int)((ulonglong)temporaryValue4 >> 0x20),0,0x401c0000);\n        undefined3 = (undefined4)temporaryValue4;\n        exponentValue = undefined6;\n        fractionPartSize = exponent - 1;\n        decimalPos = (int)((ulonglong)temporaryValue4 >> 0x20) + -0x3400000;\n        goto LAB_08007cfa;\n      }\n      goto LAB_08007e36;\n    }\n    temporaryValue4 = __aeabi_i2d(decimalPos);\n    temporaryValue4 = __muldf3((int)temporaryValue4,(int)((ulonglong)temporaryValue4 >> 0x20),temporaryValue7,inputValue);\n    temporaryValue4 = __aeabi_dadd((int)temporaryValue4,(int)((ulonglong)temporaryValue4 >> 0x20),0,0x401c0000);\n    undefined3 = (undefined4)temporaryValue4;\n    decimalPos = (int)((ulonglong)temporaryValue4 >> 0x20) + -0x3400000;\n    if (undefined7 != 0) {\n      fractionPartSize = exponent;\n      exponentValue = undefined7;\nLAB_08007cfa:\n      inputValue = (uint)((ulonglong)temporaryValue3 >> 0x20);\n      temporaryValue7 = (uint)temporaryValue3;\n      digitChar = __aeabi_d2iz(temporaryValue7,inputValue);\n      digitChar = digitChar + '0';\n      undefined4 = (&DAT_08009fa0)[exponentValue * 2];\n      undefined2 = (&DAT_08009fa4)[exponentValue * 2];\n      temporaryValue3 = __aeabi_i2d();\n      temporaryValue3 = __subdf3(temporaryValue7,inputValue,(int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20));\n      temporaryValue2 = (undefined4)((ulonglong)temporaryValue3 >> 0x20);\n      pcVar21 = pcVar10 + 1;\n      if (isDigitCharGreater) {\n        temporaryValue4 = __divdf3(0,0x3fe00000,undefined4,undefined2);\n        temporaryValue4 = __subdf3((int)temporaryValue4,(int)((ulonglong)temporaryValue4 >> 0x20),undefined3,decimalPos);\n        undefined3 = (undefined4)((ulonglong)temporaryValue4 >> 0x20);\n        *pcVar10 = digitChar;\n        decimalPos = __aeabi_dcmpgt((int)temporaryValue4,undefined3,(int)temporaryValue3,temporaryValue2);\n        if (decimalPos != 0) {\nLAB_08008784:\n          exponent = fractionPartSize;\n          goto LAB_08008294;\n        }\n        temporaryValue5 = __subdf3(0,0x3ff00000,(int)temporaryValue3,temporaryValue2);\n        decimalPos = __aeabi_dcmpgt((int)temporaryValue4,undefined3,(int)temporaryValue5,(int)((ulonglong)temporaryValue5 >> 0x20));\n        if (decimalPos == 0) {\n          if (exponentValue != 1) {\n            pcVar20 = pcVar21;\n            do {\n              temporaryValue4 = __muldf3((int)temporaryValue4,(int)((ulonglong)temporaryValue4 >> 0x20),0,0x40240000);\n              undefined3 = (undefined4)((ulonglong)temporaryValue4 >> 0x20);\n              temporaryValue3 = __muldf3((int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20),0,0x40240000);\n              digitChar = __aeabi_d2iz();\n              temporaryValue5 = __aeabi_i2d();\n              temporaryValue3 = __subdf3((int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20),(int)temporaryValue5,\n                                (int)((ulonglong)temporaryValue5 >> 0x20));\n              undefined4 = (undefined4)((ulonglong)temporaryValue3 >> 0x20);\n              digitChar = digitChar + '0';\n              pcVar21 = pcVar20 + 1;\n              *pcVar20 = digitChar;\n              decimalPos = __aeabi_dcmplt((int)temporaryValue3,undefined4,(int)temporaryValue4,undefined3);\n              if (decimalPos != 0) {\n                exponent = fractionPartSize;\n                goto LAB_08008294;\n              }\n              temporaryValue5 = __subdf3(0,0x3ff00000,(int)temporaryValue3,undefined4);\n              decimalPos = __aeabi_dcmplt((int)temporaryValue5,(int)((ulonglong)temporaryValue5 >> 0x20),(int)temporaryValue4,\n                                      undefined3);\n              if (decimalPos != 0) goto LAB_08008798;\n              pcVar20 = pcVar21;\n            } while (pcVar21 != pcVar10 + exponentValue);\n          }\n          goto LAB_08007e36;\n        }\nLAB_08008798:\n        exponent = fractionPartSize;\n      }\n      else {\n        temporaryValue4 = __muldf3(undefined3,decimalPos,undefined4,undefined2);\n        undefined3 = (undefined4)((ulonglong)temporaryValue4 >> 0x20);\n        *pcVar10 = digitChar;\n        if (exponentValue != 1) {\n          pcVar20 = pcVar21;\n          do {\n            temporaryValue3 = __muldf3((int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20),0,0x40240000);\n            digitChar = __aeabi_d2iz();\n            temporaryValue5 = __aeabi_i2d();\n            temporaryValue3 = __subdf3((int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20),(int)temporaryValue5,\n                              (int)((ulonglong)temporaryValue5 >> 0x20));\n            pcVar21 = pcVar20 + 1;\n            *pcVar20 = digitChar + '0';\n            pcVar20 = pcVar21;\n          } while (pcVar21 != pcVar10 + exponentValue);\n        }\n        undefined4 = (undefined4)((ulonglong)temporaryValue3 >> 0x20);\n        temporaryValue5 = __aeabi_dadd((int)temporaryValue4,undefined3,0,0x3fe00000);\n        decimalPos = __aeabi_dcmplt((int)temporaryValue5,(int)((ulonglong)temporaryValue5 >> 0x20),(int)temporaryValue3,undefined4);\n        if (decimalPos == 0) {\n          temporaryValue4 = __subdf3(0,0x3fe00000,(int)temporaryValue4,undefined3);\n          decimalPos = __aeabi_dcmpgt((int)temporaryValue4,(int)((ulonglong)temporaryValue4 >> 0x20),(int)temporaryValue3,undefined4);\n          pcVar20 = pcVar21;\n          if (decimalPos == 0) goto LAB_08007e36;\n          do {\n            pcVar21 = pcVar20;\n            pcVar20 = pcVar21 + -1;\n          } while (pcVar21[-1] == '0');\n          goto LAB_08008784;\n        }\n        exponent = fractionPartSize;\n        digitChar = pcVar21[-1];\n      }\n      goto LAB_08007f7c;\n    }\nLAB_0800852e:\n    temporaryValue3 = __subdf3(temporaryValue7,inputValue,0,0x40140000);\n    undefined4 = (undefined4)((ulonglong)temporaryValue3 >> 0x20);\n    exponentAdjustment = __aeabi_dcmpgt((int)temporaryValue3,undefined4,undefined3,decimalPos);\n    if (exponentAdjustment == 0) {\n      decimalPos = __aeabi_dcmplt((int)temporaryValue3,undefined4,undefined3,decimalPos + -0x80000000);\n      if (decimalPos == 0) goto LAB_08007e36;\n      exponentAdjustment = 0;\n      decimalPos = 0;\n      pcVar21 = pcVar10;\n      goto LAB_080084f0;\n    }\n    iVar15 = 0;\n    localCounter = 0;\nLAB_08008406:\n    *pcVar10 = '1';\n    exponent = exponent + 1;\n    pcVar21 = pcVar10 + 1;\n    exponentAdjustment = localCounter;\n    decimalPos = iVar15;\nLAB_08008416:\n    _Bfree(doubleValue,decimalPos);\n    if (exponentAdjustment == 0) goto LAB_08008294;\n  }\n  else {\nLAB_08007e36:\n    pcVar21 = pcVar10;\n    if ((-1 < local_2c[0]) && ((int)exponent < 0xf)) {\n      undefined3 = *(undefined4 *)(&__mprec_tens + exponent * 8);\n      undefined4 = *(undefined4 *)(&DAT_08009fac + exponent * 8);\n      if ((-1 < (int)fractionPart) || (0 < (int)undefined7)) {\n        __divdf3(integerPart,temporaryBitwiseValue,undefined3,undefined4);\n        byteValue = __aeabi_d2iz();\n        temporaryValue3 = __aeabi_i2d();\n        temporaryValue3 = __muldf3((int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20),undefined3,undefined4);\n        temporaryValue3 = __subdf3(integerPart,temporaryBitwiseValue,(int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20));\n        *pcVar10 = byteValue + 0x30;\n        pcVar21 = pcVar10 + 1;\n        if (undefined7 != 1) {\n          temporaryValue3 = __muldf3((int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20),0,0x40240000);\n          decimalPos = __aeabi_dcmpeq((int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20),0,0);\n          while (decimalPos == 0) {\n            temporaryValue2 = (undefined4)((ulonglong)temporaryValue3 >> 0x20);\n            __divdf3((int)temporaryValue3,temporaryValue2,undefined3,undefined4);\n            byteValue = __aeabi_d2iz();\n            temporaryValue4 = __aeabi_i2d();\n            temporaryValue4 = __muldf3((int)temporaryValue4,(int)((ulonglong)temporaryValue4 >> 0x20),undefined3,undefined4);\n            temporaryValue3 = __subdf3((int)temporaryValue3,temporaryValue2,(int)temporaryValue4,(int)((ulonglong)temporaryValue4 >> 0x20));\n            pcVar20 = pcVar21 + 1;\n            *pcVar21 = byteValue + 0x30;\n            pcVar21 = pcVar20;\n            if (undefined7 == (int)pcVar20 - (int)pcVar10) goto LAB_08007f3a;\n            temporaryValue3 = __muldf3((int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20),0,0x40240000);\n            decimalPos = __aeabi_dcmpeq((int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20),0,0);\n          }\n          goto LAB_08008294;\n        }\nLAB_08007f3a:\n        temporaryValue3 = __aeabi_dadd((int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20));\n        temporaryValue2 = (undefined4)((ulonglong)temporaryValue3 >> 0x20);\n        decimalPos = __aeabi_dcmpgt((int)temporaryValue3,temporaryValue2,undefined3,undefined4);\n        if ((decimalPos == 0) &&\n           ((decimalPos = __aeabi_dcmpeq((int)temporaryValue3,temporaryValue2,undefined3,undefined4), decimalPos == 0 ||\n            ((byteValue & 1) == 0)))) goto LAB_08008294;\n        digitChar = pcVar21[-1];\nLAB_08007f7c:\n        while (pcVar20 = pcVar21 + -1, digitChar == '9') {\n          if (pcVar10 == pcVar20) {\n            *pcVar10 = '0';\n            digitChar = pcVar21[-1];\n            exponent = exponent + 1;\n            pcVar20 = pcVar10;\n            break;\n          }\n          digitChar = pcVar21[-2];\n          pcVar21 = pcVar20;\n        }\n        *pcVar20 = digitChar + '\\x01';\n        goto LAB_08008294;\n      }\n      if (undefined7 == 0) {\n        temporaryValue3 = __muldf3(undefined3,undefined4,0,0x40140000);\n        tempVariable = __aeabi_dcmpge((int)temporaryValue3,(int)((ulonglong)temporaryValue3 >> 0x20),integerPart,temporaryBitwiseValue);\n        exponentAdjustment = 0;\n        iVar15 = 0;\n        localCounter = 0;\n        decimalPos = 0;\n        if (tempVariable == 0) goto LAB_08008406;\n      }\n      else {\n        exponentAdjustment = 0;\n        decimalPos = 0;\n      }\nLAB_080084f0:\n      exponent = ~fractionPart;\n      pcVar10 = pcVar21;\n      goto LAB_08008416;\n    }\n    decimalPos = exponentDiff;\n    if (isDigitCharGreater) {\n      if ((int)exponentAndFractionLength < 2) {\n        if (isParam4Negative) {\n          fractionPartSizeAdjusted = decimalPosAdjusted;\n          decimalPosAdjusted = decimalPosAdjusted + local_2c[0] + 0x433;\n          iVar15 = iVar15 + local_2c[0] + 0x433;\n        }\n        else {\n          fractionPartSizeAdjusted = decimalPosAdjusted;\n          decimalPosAdjusted = decimalPosAdjusted + (0x36 - undefined5);\n          iVar15 = iVar15 + (0x36 - undefined5);\n        }\n      }\n      else {\n        exponentAdjustment = undefined7 - 1;\n        if (exponentDiff < exponentAdjustment) {\n          isExponentGreater = isExponentGreater + (exponentAdjustment - exponentDiff);\n          decimalPos = 0;\n          exponentDiff = exponentAdjustment;\n        }\n        else {\n          decimalPos = exponentDiff - exponentAdjustment;\n        }\n        if ((int)undefined7 < 0) {\n          fractionPartSizeAdjusted = decimalPosAdjusted - undefined7;\n        }\n        else {\n          iVar15 = iVar15 + undefined7;\n          fractionPartSizeAdjusted = decimalPosAdjusted;\n          decimalPosAdjusted = decimalPosAdjusted + undefined7;\n        }\n      }\n      exponentAdjustment = __i2b(doubleValue,1);\n    }\n    else {\n      fractionPartSizeAdjusted = decimalPosAdjusted;\n      exponentAdjustment = 0;\n    }\n    if ((0 < fractionPartSizeAdjusted) && (0 < iVar15)) {\n      localCounter = fractionPartSizeAdjusted;\n      if (iVar15 <= fractionPartSizeAdjusted) {\n        localCounter = iVar15;\n      }\n      iVar15 = iVar15 - localCounter;\n      decimalPosAdjusted = decimalPosAdjusted - localCounter;\n      fractionPartSizeAdjusted = fractionPartSizeAdjusted - localCounter;\n    }\n    if (exponentDiff != 0) {\n      if (isDigitCharGreater) {\n        undefined3 = uVar6;\n        if (decimalPos != 0) {\n          exponentAdjustment = __pow5mult(doubleValue,exponentAdjustment,decimalPos);\n          undefined3 = __multiply(doubleValue,exponentAdjustment,uVar6);\n          _Bfree(doubleValue,uVar6);\n          uVar6 = undefined3;\n          if (exponentDiff - decimalPos == 0) goto LAB_08008062;\n        }\n        uVar6 = __pow5mult(doubleValue,undefined3,exponentDiff - decimalPos);\n      }\n      else {\n        uVar6 = __pow5mult(doubleValue,uVar6,exponentDiff);\n      }\n    }\nLAB_08008062:\n    decimalPos = __i2b(doubleValue,1);\n    if (isExponentGreater == 0) {\n      if (((int)exponentAndFractionLength < 2) && (integerPart == 0)) {\nLAB_0800835a:\n        if ((temporaryBitwiseValue & 0xfffff) == 0) {\n          temporaryBitwiseValue = temporaryBitwiseValue & 0x7ff00000;\n          if (temporaryBitwiseValue != 0) {\n            iVar15 = iVar15 + 1;\n            decimalPosAdjusted = decimalPosAdjusted + 1;\n            temporaryBitwiseValue = 1;\n          }\n        }\n        else {\n          temporaryBitwiseValue = 0;\n        }\n        isParam4Negative = isExponentGreater != 0;\n        temporaryValue = integerPart;\n        isExponentGreater = temporaryBitwiseValue;\n        if (isParam4Negative) goto LAB_080082d4;\n      }\n      localCounter = 1;\n    }\n    else {\n      temporaryValue3 = __pow5mult(doubleValue,decimalPos);\n      decimalPos = (int)temporaryValue3;\n      if (((int)exponentAndFractionLength < 2) && (integerPart == 0)) goto LAB_0800835a;\n      isExponentGreater = 0;\n      temporaryValue = (uint)((ulonglong)temporaryValue3 >> 0x20);\nLAB_080082d4:\n      localCounter = __hi0bits(*(undefined4 *)(decimalPos + *(int *)(decimalPos + 0x10) * 4 + 0x10),temporaryValue);\n      localCounter = 0x20 - localCounter;\n    }\n    temporaryValue = localCounter + iVar15 & 0x1f;\n    if (temporaryValue == 0) {\n      localCounter = 0x1c;\nLAB_08008096:\n      iVar15 = iVar15 + localCounter;\n      decimalPosAdjusted = decimalPosAdjusted + localCounter;\n      fractionPartSizeAdjusted = fractionPartSizeAdjusted + localCounter;\n    }\n    else {\n      if (4 < (int)(0x20 - temporaryValue)) {\n        localCounter = 0x1c - temporaryValue;\n        goto LAB_08008096;\n      }\n      if (0x20 - temporaryValue != 4) {\n        localCounter = 0x3c - temporaryValue;\n        goto LAB_08008096;\n      }\n    }\n    if (0 < decimalPosAdjusted) {\n      uVar6 = __lshift(doubleValue,uVar6,decimalPosAdjusted);\n    }\n    if (0 < iVar15) {\n      decimalPos = __lshift(doubleValue,decimalPos,iVar15);\n    }\n    pcVar20 = pcVar10;\n    if ((needsPadding) && (iVar15 = __mcmp(uVar6,decimalPos), iVar15 < 0)) {\n      exponent = exponent - 1;\n      uVar6 = __multadd(doubleValue,uVar6,10,0);\n      if (isDigitCharGreater) {\n        exponentAdjustment = __multadd(doubleValue,exponentAdjustment,10,0);\n        if ((0 < (int)undefined6) || ((int)exponentAndFractionLength < 3)) {\n          undefined7 = undefined6;\n          goto LAB_080080de;\n        }\n      }\n      else if ((0 < (int)undefined6) || ((int)exponentAndFractionLength < 3)) {\n        undefined7 = undefined6;\n        goto LAB_0800820a;\n      }\n      undefined7 = undefined6;\nLAB_080084e8:\n      if (undefined7 == 0) {\n        iVar15 = __multadd(doubleValue,decimalPos,5);\n        tempVariable = __mcmp(uVar6,iVar15);\n        localCounter = exponentAdjustment;\n        decimalPos = iVar15;\n        if (0 < tempVariable) goto LAB_08008406;\n      }\n      goto LAB_080084f0;\n    }\n    if (((int)undefined7 < 1) && (2 < (int)exponentAndFractionLength)) goto LAB_080084e8;\n    if (isDigitCharGreater) {\nLAB_080080de:\n      temporaryValue7 = exponentAdjustment;\n      if (0 < fractionPartSizeAdjusted) {\n        temporaryValue7 = __lshift(doubleValue,exponentAdjustment,fractionPartSizeAdjusted);\n      }\n      exponentAdjustment = temporaryValue7;\n      if (isExponentGreater != 0) {\n        exponentAdjustment = _Balloc(doubleValue,*(undefined4 *)(temporaryValue7 + 4));\n        memcpy((void *)(exponentAdjustment + 0xc),(void *)(temporaryValue7 + 0xc),(*(int *)(temporaryValue7 + 0x10) + 2) * 4);\n        exponentAdjustment = __lshift(doubleValue,exponentAdjustment,1);\n      }\nLAB_08008108:\n      iVar15 = quorem(uVar6,decimalPos);\n      localCounter = __mcmp(uVar6,temporaryValue7);\n      tempVariable = __mdiff(doubleValue,decimalPos,exponentAdjustment);\n      digitChar = iVar15 + 0x30;\n      if (*(int *)(tempVariable + 0xc) == 0) {\n        comparisonResult = __mcmp(uVar6);\n        _Bfree(doubleValue,tempVariable);\n        if ((comparisonResult != 0) || (exponentAndFractionLength != 0)) goto LAB_0800815a;\n        if ((integerPart & 1) != 0) {\n          comparisonResult = 0;\n          goto LAB_0800815a;\n        }\n        if (digitChar != 0x39) {\n          if (0 < localCounter) goto LAB_0800874c;\n          goto LAB_080085a4;\n        }\nLAB_08008752:\n        pcVar21 = pcVar20 + 1;\n        digitChar = '9';\n        *pcVar20 = '9';\n        goto LAB_08008268;\n      }\n      _Bfree(doubleValue,tempVariable);\n      comparisonResult = 1;\nLAB_0800815a:\n      if ((localCounter < 0) || (((localCounter == 0 && (exponentAndFractionLength == 0)) && ((integerPart & 1) == 0)))) {\n        if (0 < comparisonResult) {\n          uVar6 = __lshift(doubleValue,uVar6,1);\n          localCounter = __mcmp(uVar6,decimalPos);\n          if ((0 < localCounter) || ((localCounter == 0 && (iVar15 << 0x1f < 0)))) {\n            if (digitChar == 0x39) goto LAB_08008752;\nLAB_0800874c:\n            digitChar = iVar15 + 0x31;\n          }\n        }\nLAB_080085a4:\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)digitChar;\n        goto LAB_08008274;\n      }\n      pcVar21 = pcVar20 + 1;\n      if (0 < comparisonResult) {\n        if (digitChar == 0x39) goto LAB_08008752;\n        *pcVar20 = (char)iVar15 + '1';\n        goto LAB_08008274;\n      }\n      *pcVar20 = (char)digitChar;\n      if (pcVar10 + (undefined7 - 1) != pcVar20) {\n        uVar6 = __multadd(doubleValue,uVar6,10,0);\n        pcVar20 = pcVar21;\n        if (temporaryValue7 == exponentAdjustment) {\n          temporaryValue7 = __multadd(doubleValue,temporaryValue7,10,0);\n          exponentAdjustment = temporaryValue7;\n        }\n        else {\n          temporaryValue7 = __multadd(doubleValue,temporaryValue7,10,0);\n          exponentAdjustment = __multadd(doubleValue,exponentAdjustment,10,0);\n        }\n        goto LAB_08008108;\n      }\n    }\n    else {\nLAB_0800820a:\n      while( true ) {\n        digitChar = quorem(uVar6,decimalPos);\n        digitChar = digitChar + 0x30;\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)digitChar;\n        if ((int)undefined7 <= (int)pcVar21 - (int)pcVar10) break;\n        uVar6 = __multadd(doubleValue,uVar6,10,0);\n        pcVar20 = pcVar21;\n      }\n      temporaryValue7 = 0;\n    }\n    uVar6 = __lshift(doubleValue,uVar6,1);\n    iVar15 = __mcmp(uVar6,decimalPos);\n    digitChar = pcVar21[-1];\n    if ((0 < iVar15) || ((iVar15 == 0 && (digitChar << 0x1f < 0)))) {\nLAB_08008268:\n      do {\n        pcVar20 = pcVar21 + -1;\n        if (digitChar != '9') goto code_r0x08008270;\n        if (pcVar10 == pcVar20) {\n          *pcVar10 = '1';\n          exponent = exponent + 1;\n          goto LAB_08008274;\n        }\n        digitChar = pcVar21[-2];\n        pcVar21 = pcVar20;\n      } while( true );\n    }\n    while (digitChar == '0') {\n      digitChar = pcVar21[-2];\n      pcVar21 = pcVar21 + -1;\n    }\nLAB_08008274:\n    _Bfree(doubleValue,decimalPos);\n    if (exponentAdjustment == 0) goto LAB_08008294;\n    if ((temporaryValue7 != 0) && (temporaryValue7 != exponentAdjustment)) {\n      _Bfree(doubleValue);\n    }\n  }\n  _Bfree(doubleValue,exponentAdjustment);\nLAB_08008294:\n  _Bfree(doubleValue,uVar6);\n  *pcVar21 = '\\0';\n  *errorCode = exponent + 1;\n  if (fractionString == (char **)0x0) {\n    return pcVar10;\n  }\n  *fractionString = pcVar21;\n  return pcVar10;\ncode_r0x08008270:\n  *pcVar20 = digitChar + '\\x01';\n  goto LAB_08008274;\n}\n\n",
            "renaming": {
                "FUN_080079e8": "convert_double_to_string_080079e8",
                "param_1": "doubleValue",
                "param_2": "undefined1",
                "param_3": "integerPart",
                "param_4": "bitwiseSign",
                "param_5": "exponentAndFractionLength",
                "param_6": "fractionPart",
                "param_7": "errorCode",
                "param_8": "sign",
                "param_9": "fractionString",
                "iVar14": "decimalPos",
                "iVar19": "exponentAdjustment",
                "iVar24": "digitChar",
                "iVar7": "localCounter",
                "iVar8": "comparisonResult",
                "iVar9": "tempVariable",
                "uVar11": "tempVariable1",
                "uVar12": "undefined2",
                "uVar13": "undefined3",
                "uVar16": "undefined4",
                "uVar17": "temporaryBitwiseValue",
                "uVar18": "temporaryValue",
                "uVar23": "temporaryValue2",
                "uVar26": "temporaryValue3",
                "uVar27": "temporaryValue4",
                "uVar28": "temporaryValue5",
                "bVar1": "isBitwiseValueLowerThan6",
                "bVar2": "needsPadding",
                "bVar3": "isDigitCharGreater",
                "bVar5": "byteValue",
                "bVar25": "isParam4Negative",
                "cVar4": "digitChar",
                "local_30": "undefined5",
                "local_34": "fractionPartSize",
                "local_38": "undefined6",
                "local_48": "exponentValue",
                "local_58": "isExponentGreater",
                "local_5c": "exponentDiff",
                "local_60": "fractionPartSizeAdjusted",
                "local_68": "undefined7",
                "local_70": "decimalPosAdjusted",
                "local_74": "exponent",
                "local_7c": "inputValue",
                "local_80": "temporaryValue7",
                "uStack_44": "temporaryValue8"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_dcmpgt",
                "__multiply",
                "__aeabi_dcmpge",
                "__d2b",
                "quorem",
                "__hi0bits",
                "__aeabi_dcmpeq",
                "__aeabi_dadd",
                "__multadd",
                "__i2b",
                "__floatunsidf",
                "memcpy",
                "__aeabi_dcmplt",
                "__subdf3",
                "__aeabi_i2d",
                "__lshift",
                "__mdiff",
                "__muldf3",
                "__aeabi_d2iz",
                "_Bfree",
                "_Balloc",
                "__mcmp",
                "__pow5mult",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008818": {
            "entrypoint": "0x08008818",
            "current_name": "execute_global_destructors_08008818",
            "code": "\nvoid execute_global_destructors_08008818(void)\n\n{\n  int counter;\n  code **destructor_ptr;\n  \n  counter = 1;\n  destructor_ptr = (code **)&__do_global_dtors_aux_fini_array_entry;\n  do {\n    counter = counter + -1;\n    (**destructor_ptr)();\n    destructor_ptr = destructor_ptr + -1;\n  } while (counter != 0);\n  _fini();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008818": "execute_global_destructors_08008818",
                "iVar1": "counter",
                "ppcVar2": "destructor_ptr"
            },
            "calling": [],
            "called": [
                "_fini",
                "__do_global_dtors_aux",
                "frame_dummy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800884c": {
            "entrypoint": "0x0800884c",
            "current_name": "resize_memory_0800884c",
            "code": "\nundefined4 resizeMemory_0800884c(undefined4 lock,int size)\n\n{\n  int result;\n  int newSize;\n  uint mask;\n  \n  __malloc_lock();\n  mask = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  newSize = ((0xfef - size) + mask & 0xfffff000) - 0x1000;\n  if (0xfff < newSize) {\n    result = _sbrk_r(lock,0);\n    if (result == DAT_20000454 + mask) {\n      result = _sbrk_r(lock,-newSize);\n      if (result != -1) {\n        __malloc_current_mallinfo = __malloc_current_mallinfo - newSize;\n        *(uint *)(DAT_20000454 + 4) = mask - newSize | 1;\n        __malloc_unlock(lock);\n        return 1;\n      }\n      newSize = _sbrk_r(lock,0);\n      if (0xf < newSize - DAT_20000454) {\n        __malloc_current_mallinfo = newSize - __malloc_sbrk_base;\n        *(uint *)(DAT_20000454 + 4) = newSize - DAT_20000454 | 1;\n      }\n    }\n  }\n  __malloc_unlock(lock);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800884c": "resize_memory_0800884c",
                "param_1": "lock",
                "param_2": "size",
                "iVar1": "result",
                "iVar2": "newSize",
                "uVar3": "mask"
            },
            "calling": [
                "_free_r"
            ],
            "called": [
                "_sbrk_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080088ec": {
            "entrypoint": "0x080088ec",
            "current_name": "deallocate_memory_080088ec",
            "code": "\nvoid deallocateMemory_080088ec(undefined4 lock,int ptr,undefined4 threshold,undefined4 top_pad)\n\n{\n  int index;\n  uint *ptr_prev;\n  uint *ptr_next;\n  undefined *ptr_current;\n  uint size;\n  uint block_size;\n  undefined *ptr_header;\n  undefined *ptr_footer;\n  undefined4 *ptr_block;\n  int bin_index;\n  uint prev_in_use;\n  uint next_in_use;\n  \n  if (ptr == 0) {\n    return;\n  }\n  __malloc_lock();\n  prev_in_use = *(uint *)(ptr + -4);\n  ptr_prev = (uint *)(ptr + -8);\n  size = prev_in_use & 0xfffffffe;\n  ptr_next = (uint *)((int)ptr_prev + size);\n  block_size = ptr_next[1] & 0xfffffffc;\n  if (DAT_20000454 == ptr_next) {\n    size = size + block_size;\n    if ((prev_in_use & 1) == 0) {\n      ptr_prev = (uint *)((int)ptr_prev - *(int *)(ptr + -8));\n      block_size = ptr_prev[2];\n      prev_in_use = ptr_prev[3];\n      size = size + *(int *)(ptr + -8);\n      *(uint *)(block_size + 0xc) = prev_in_use;\n      *(uint *)(prev_in_use + 8) = block_size;\n    }\n    block_size = __malloc_trim_threshold;\n    ptr_prev[1] = size | 1;\n    DAT_20000454 = ptr_prev;\n    if (block_size <= size) {\n      _malloc_trim_r(lock,__malloc_top_pad);\n    }\nLAB_080089f0:\n    __malloc_unlock(lock);\n    return;\n  }\n  ptr_next[1] = block_size;\n  if ((prev_in_use & 1) == 0) {\n    ptr_prev = (uint *)((int)ptr_prev - *(int *)(ptr + -8));\n    ptr_block = (undefined4 *)ptr_prev[2];\n    size = size + *(int *)(ptr + -8);\n    prev_in_use = *(uint *)((int)ptr_next + block_size + 4) & 1;\n    if ((uint **)ptr_block == &DAT_20000454) {\n      if (prev_in_use == 0) {\n        prev_in_use = ptr_next[2];\n        next_in_use = ptr_next[3];\n        size = size + block_size;\n        *(uint *)(prev_in_use + 0xc) = next_in_use;\n        *(uint *)(next_in_use + 8) = prev_in_use;\n        ptr_prev[1] = size | 1;\n        *(uint *)((int)ptr_prev + size) = size;\n      }\n      else {\n        ptr_prev[1] = size | 1;\n        *ptr_next = size;\n      }\n      goto LAB_080089f0;\n    }\n    next_in_use = ptr_prev[3];\n    ptr_block[3] = next_in_use;\n    *(undefined4 **)(next_in_use + 8) = ptr_block;\n  }\n  else {\n    prev_in_use = *(uint *)((int)ptr_next + block_size + 4) & 1;\n  }\n  if (prev_in_use == 0) {\n    ptr_block = (undefined4 *)ptr_next[2];\n    size = size + block_size;\n    if ((uint **)ptr_block == &DAT_20000454) {\n      DAT_2000045c = ptr_prev;\n      DAT_20000460 = ptr_prev;\n      ptr_prev[2] = (uint)&DAT_20000454;\n      ptr_prev[3] = (uint)&DAT_20000454;\n      ptr_prev[1] = size | 1;\n      *(uint *)((int)ptr_prev + size) = size;\n      goto LAB_080089f0;\n    }\n    block_size = ptr_next[3];\n    ptr_block[3] = block_size;\n    *(undefined4 **)(block_size + 8) = ptr_block;\n    ptr_prev[1] = size | 1;\n    *(uint *)((int)ptr_prev + size) = size;\n  }\n  else {\n    ptr_prev[1] = size | 1;\n    *(uint *)((int)ptr_prev + size) = size;\n  }\n  if (size < 0x200) {\n    bin_index = (size >> 3) + 1;\n    size = 1 << ((int)(size >> 3) >> 2 & 0xffU) | (uint)DAT_20000450;\n    block_size = *(uint *)(&__malloc_av_ + bin_index * 8);\n    ptr_prev[2] = block_size;\n    ptr_prev[3] = (uint)(&DAT_20000444 + bin_index * 8);\n    DAT_20000450 = (undefined *)size;\n    *(uint **)(&__malloc_av_ + bin_index * 8) = ptr_prev;\n    *(uint **)(block_size + 0xc) = ptr_prev;\n    __malloc_unlock(lock,ptr_prev,size,top_pad);\n    return;\n  }\n  block_size = size >> 9;\n  if (block_size < 5) {\n    bin_index = ((size >> 6) + 0x39) * 8;\n    index = (size >> 6) + 0x38;\n  }\n  else if (block_size < 0x15) {\n    bin_index = (block_size + 0x5c) * 8;\n    index = block_size + 0x5b;\n  }\n  else if (block_size < 0x55) {\n    bin_index = ((size >> 0xc) + 0x6f) * 8;\n    index = (size >> 0xc) + 0x6e;\n  }\n  else if (block_size < 0x155) {\n    bin_index = ((size >> 0xf) + 0x78) * 8;\n    index = (size >> 0xf) + 0x77;\n  }\n  else if (block_size < 0x555) {\n    bin_index = ((size >> 0x12) + 0x7d) * 8;\n    index = (size >> 0x12) + 0x7c;\n  }\n  else {\n    bin_index = 0x3f8;\n    index = 0x7e;\n  }\n  ptr_current = *(undefined **)(&__malloc_av_ + bin_index);\n  ptr_header = &DAT_20000444 + bin_index;\n  if (ptr_header == ptr_current) {\n    ptr_current = (undefined *)(1 << (index >> 2 & 0xffU) | (uint)DAT_20000450);\n    ptr_footer = ptr_header;\n    DAT_20000450 = ptr_current;\n  }\n  else {\n    do {\n      ptr_footer = ptr_current;\n      if ((*(uint *)(ptr_current + 4) & 0xfffffffc) <= size) break;\n      ptr_current = *(undefined **)(ptr_current + 8);\n      ptr_footer = ptr_header;\n    } while (ptr_header != ptr_current);\n    ptr_header = *(undefined **)(ptr_footer + 0xc);\n  }\n  ptr_prev[2] = (uint)ptr_footer;\n  ptr_prev[3] = (uint)ptr_header;\n  *(uint **)(ptr_header + 8) = ptr_prev;\n  *(uint **)(ptr_footer + 0xc) = ptr_prev;\n  __malloc_unlock(lock,ptr_prev,ptr_current,top_pad);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080088ec": "deallocate_memory_080088ec",
                "param_1": "lock",
                "param_2": "ptr",
                "param_3": "threshold",
                "param_4": "top_pad",
                "iVar1": "index",
                "puVar2": "ptr_prev",
                "puVar3": "ptr_next",
                "puVar4": "ptr_current",
                "uVar5": "size",
                "uVar6": "block_size",
                "puVar7": "ptr_header",
                "puVar8": "ptr_footer",
                "puVar9": "ptr_block",
                "iVar10": "bin_index",
                "uVar11": "prev_in_use",
                "uVar12": "next_in_use"
            },
            "calling": [
                "__ssprint_r",
                "_svfprintf_r",
                "_malloc_r",
                "_realloc_r"
            ],
            "called": [
                "__malloc_unlock",
                "_malloc_trim_r",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ad4": {
            "entrypoint": "0x08008ad4",
            "current_name": "get_locale_pointer_08008ad4",
            "code": "\nundefined1 * get_locale_pointer_08008ad4(void)\n\n{\n  undefined1 *locale_ptr;\n  \n  locale_ptr = *(undefined1 **)(IMPURE_PTR + 0x34);\n  if (locale_ptr == (undefined1 *)0x0) {\n    locale_ptr = &GLOBAL_LOCALE;\n  }\n  return locale_ptr + 0xf0;\n}\n\n",
            "renaming": {
                "FUN_08008ad4": "get_locale_pointer_08008ad4",
                "puVar1": "locale_ptr",
                "_impure_ptr": "IMPURE_PTR",
                "__global_locale": "GLOBAL_LOCALE"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008af0": {
            "entrypoint": "0x08008af0",
            "current_name": "FUNC_08008af0",
            "code": "\nvoid FUNC_08008af0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af0": "FUNC_08008af0"
            },
            "calling": [
                "__register_exitproc",
                "__malloc_lock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af4": {
            "entrypoint": "0x08008af4",
            "current_name": "FUNC_08008af4",
            "code": "\nvoid FUNC_08008af4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af4": "FUNC_08008af4"
            },
            "calling": [
                "__register_exitproc",
                "__malloc_unlock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af8": {
            "entrypoint": "0x08008af8",
            "current_name": "allocate_memory_08008af8",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocate_memory_08008af8(undefined4 *lock_ptr,uint size)\n\n{\n  undefined1 *temp_ptr_1;\n  undefined1 *temp_ptr_2;\n  uint temp_var_1;\n  uint temp_var_2;\n  int temp_var_3;\n  undefined *temp_ptr_3;\n  uint temp_var_4;\n  uint temp_var_5;\n  undefined4 *temp_ptr_4;\n  undefined1 *temp_ptr_5;\n  undefined *temp_ptr_6;\n  int *result_ptr;\n  uint temp_var_6;\n  uint temp_var_7;\n  int temp_var_8;\n  undefined4 *temp_ptr_7;\n  undefined1 *temp_ptr_8;\n  undefined4 *temp_ptr_9;\n  \n  temp_var_6 = size + 0xb;\n  if (temp_var_6 < 0x17) {\n    if (0x10 < size) goto LAB_08008c7a;\n    __malloc_lock();\n    temp_var_7 = 0x10;\n    temp_var_3 = 0x18;\n    temp_var_6 = 2;\nLAB_08008b18:\n    temp_ptr_6 = *(undefined **)((int)&DAT_20000450 + temp_var_3);\n    if ((temp_ptr_6 != &DAT_20000444 + temp_var_3) ||\n       (temp_ptr_6 = *(undefined **)((int)&DAT_20000458 + temp_var_3), &__malloc_av_ + temp_var_3 != temp_ptr_6)) {\n      temp_var_3 = *(int *)(temp_ptr_6 + 0xc);\n      temp_ptr_3 = temp_ptr_6 + (*(uint *)(temp_ptr_6 + 4) & 0xfffffffc);\n      temp_var_6 = *(uint *)(temp_ptr_3 + 4);\nLAB_08008b34:\n      temp_var_8 = *(int *)(temp_ptr_6 + 8);\n      *(int *)(temp_var_8 + 0xc) = temp_var_3;\n      *(int *)(temp_var_3 + 8) = temp_var_8;\n      *(uint *)(temp_ptr_3 + 4) = temp_var_6 | 1;\n      __malloc_unlock(lock_ptr);\n      return (int *)(temp_ptr_6 + 8);\n    }\n    temp_var_6 = temp_var_6 + 2;\n  }\n  else {\n    temp_var_7 = temp_var_6 & 0xfffffff8;\n    if (((int)temp_var_7 < 0) || (temp_var_7 < size)) {\nLAB_08008c7a:\n      *lock_ptr = 0xc;\n      return (int *)0x0;\n    }\n    __malloc_lock();\n    if (temp_var_7 < 0x1f8) {\n      temp_var_6 = temp_var_6 >> 3;\n      temp_var_3 = temp_var_7 + 8;\n      goto LAB_08008b18;\n    }\n    temp_var_1 = temp_var_6 >> 9;\n    if (temp_var_1 == 0) {\n      temp_var_3 = 0x200;\n      temp_var_4 = 0x40;\n      temp_var_1 = 0x3f;\n    }\n    else if (temp_var_1 < 5) {\n      temp_var_4 = (temp_var_6 >> 6) + 0x39;\n      temp_var_1 = (temp_var_6 >> 6) + 0x38;\n      temp_var_3 = temp_var_4 * 8;\n    }\n    else if (temp_var_1 < 0x15) {\n      temp_var_4 = temp_var_1 + 0x5c;\n      temp_var_1 = temp_var_1 + 0x5b;\n      temp_var_3 = temp_var_4 * 8;\n    }\n    else if (temp_var_1 < 0x55) {\n      temp_var_4 = (temp_var_6 >> 0xc) + 0x6f;\n      temp_var_1 = (temp_var_6 >> 0xc) + 0x6e;\n      temp_var_3 = temp_var_4 * 8;\n    }\n    else if (temp_var_1 < 0x155) {\n      temp_var_4 = (temp_var_6 >> 0xf) + 0x78;\n      temp_var_1 = (temp_var_6 >> 0xf) + 0x77;\n      temp_var_3 = temp_var_4 * 8;\n    }\n    else if (temp_var_1 < 0x555) {\n      temp_var_4 = (temp_var_6 >> 0x12) + 0x7d;\n      temp_var_1 = (temp_var_6 >> 0x12) + 0x7c;\n      temp_var_3 = temp_var_4 * 8;\n    }\n    else {\n      temp_var_3 = 0x3f8;\n      temp_var_4 = 0x7f;\n      temp_var_1 = 0x7e;\n    }\n    for (temp_ptr_6 = *(undefined **)((int)&DAT_20000450 + temp_var_3); temp_var_6 = temp_var_4,\n        &DAT_20000444 + temp_var_3 != temp_ptr_6; temp_ptr_6 = *(undefined **)(temp_ptr_6 + 0xc)) {\n      temp_var_8 = (*(uint *)(temp_ptr_6 + 4) & 0xfffffffc) - temp_var_7;\n      temp_var_6 = temp_var_1;\n      if (0xf < temp_var_8) break;\n      if (-1 < temp_var_8) {\n        temp_ptr_3 = temp_ptr_6 + (*(uint *)(temp_ptr_6 + 4) & 0xfffffffc);\n        temp_var_6 = *(uint *)(temp_ptr_3 + 4);\n        temp_var_3 = *(int *)(temp_ptr_6 + 0xc);\n        goto LAB_08008b34;\n      }\n    }\n  }\n  temp_ptr_7 = DAT_2000045c;\n  if ((undefined1 **)DAT_2000045c == &DAT_20000454) {\n    temp_var_4 = 1 << ((int)temp_var_6 >> 2 & 0xffU);\n    temp_var_1 = DAT_20000450;\n    if (temp_var_4 <= DAT_20000450) goto LAB_08008c06;\n  }\n  else {\n    temp_var_4 = DAT_2000045c[1];\n    temp_var_5 = temp_var_4 & 0xfffffffc;\n    temp_var_1 = temp_var_5 - temp_var_7;\n    if (0xf < (int)temp_var_1) {\n      temp_ptr_9 = (undefined4 *)(temp_var_7 + (int)DAT_2000045c);\n      DAT_2000045c[1] = temp_var_7 | 1;\n      DAT_2000045c = temp_ptr_9;\n      DAT_20000460 = temp_ptr_9;\n      temp_ptr_9[2] = &DAT_20000454;\n      temp_ptr_9[3] = &DAT_20000454;\n      temp_ptr_9[1] = temp_var_1 | 1;\n      *(uint *)((int)temp_ptr_7 + temp_var_5) = temp_var_1;\n      __malloc_unlock(lock_ptr);\n      return temp_ptr_7 + 2;\n    }\n    DAT_2000045c = &DAT_20000454;\n    DAT_20000460 = &DAT_20000454;\n    if (-1 < (int)temp_var_1) {\n      *(uint *)((int)temp_ptr_7 + temp_var_5 + 4) = *(uint *)((int)temp_ptr_7 + temp_var_5 + 4) | 1;\n      __malloc_unlock(lock_ptr);\n      return temp_ptr_7 + 2;\n    }\n    if (temp_var_5 < 0x200) {\n      temp_var_3 = (temp_var_4 >> 3) + 1;\n      temp_var_8 = *(int *)(&__malloc_av_ + temp_var_3 * 8);\n      temp_var_1 = 1 << ((int)(temp_var_4 >> 3) >> 2 & 0xffU) | DAT_20000450;\n      temp_ptr_7[2] = temp_var_8;\n      temp_ptr_7[3] = &DAT_20000444 + temp_var_3 * 8;\n      DAT_20000450 = temp_var_1;\n      *(undefined4 **)(&__malloc_av_ + temp_var_3 * 8) = temp_ptr_7;\n      *(undefined4 **)(temp_var_8 + 0xc) = temp_ptr_7;\n    }\n    else {\n      temp_var_1 = temp_var_4 >> 9;\n      if (temp_var_1 < 5) {\n        temp_var_3 = ((temp_var_4 >> 6) + 0x39) * 8;\n        temp_var_8 = (temp_var_4 >> 6) + 0x38;\n      }\n      else if (temp_var_1 < 0x15) {\n        temp_var_3 = (temp_var_1 + 0x5c) * 8;\n        temp_var_8 = temp_var_1 + 0x5b;\n      }\n      else if (temp_var_1 < 0x55) {\n        temp_var_3 = ((temp_var_4 >> 0xc) + 0x6f) * 8;\n        temp_var_8 = (temp_var_4 >> 0xc) + 0x6e;\n      }\n      else if (temp_var_1 < 0x155) {\n        temp_var_3 = ((temp_var_4 >> 0xf) + 0x78) * 8;\n        temp_var_8 = (temp_var_4 >> 0xf) + 0x77;\n      }\n      else if (temp_var_1 < 0x555) {\n        temp_var_3 = ((temp_var_4 >> 0x12) + 0x7d) * 8;\n        temp_var_8 = (temp_var_4 >> 0x12) + 0x7c;\n      }\n      else {\n        temp_var_3 = 0x3f8;\n        temp_var_8 = 0x7e;\n      }\n      temp_ptr_6 = *(undefined **)(&__malloc_av_ + temp_var_3);\n      temp_ptr_3 = &DAT_20000444 + temp_var_3;\n      if (temp_ptr_3 == temp_ptr_6) {\n        DAT_20000450 = 1 << (temp_var_8 >> 2 & 0xffU) | DAT_20000450;\n      }\n      else {\n        do {\n          if ((*(uint *)(temp_ptr_6 + 4) & 0xfffffffc) <= temp_var_5) break;\n          temp_ptr_6 = *(undefined **)(temp_ptr_6 + 8);\n        } while (temp_ptr_3 != temp_ptr_6);\n        temp_ptr_3 = *(undefined **)(temp_ptr_6 + 0xc);\n      }\n      temp_var_1 = DAT_20000450;\n      temp_ptr_7[2] = temp_ptr_6;\n      temp_ptr_7[3] = temp_ptr_3;\n      *(undefined4 **)(temp_ptr_3 + 8) = temp_ptr_7;\n      *(undefined4 **)(temp_ptr_6 + 0xc) = temp_ptr_7;\n    }\n    temp_var_4 = 1 << ((int)temp_var_6 >> 2 & 0xffU);\n    if (temp_var_4 <= temp_var_1) {\nLAB_08008c06:\n      if ((temp_var_4 & temp_var_1) == 0) {\n        temp_var_6 = temp_var_6 & 0xfffffffc;\n        do {\n          temp_var_4 = temp_var_4 << 1;\n          temp_var_6 = temp_var_6 + 4;\n        } while ((temp_var_4 & temp_var_1) == 0);\n      }\n      do {\n        temp_ptr_9 = (undefined4 *)(&__malloc_av_ + temp_var_6 * 8);\n        temp_var_1 = temp_var_6;\n        temp_ptr_7 = temp_ptr_9;\n        do {\n          for (temp_ptr_4 = (undefined4 *)temp_ptr_7[3]; temp_ptr_7 != temp_ptr_4;\n              temp_ptr_4 = (undefined4 *)temp_ptr_4[3]) {\n            temp_var_5 = temp_ptr_4[1] & 0xfffffffc;\n            temp_var_2 = temp_var_5 - temp_var_7;\n            if (0xf < (int)temp_var_2) {\n              temp_var_8 = temp_ptr_4[2];\n              temp_var_3 = temp_ptr_4[3];\n              temp_ptr_7 = (undefined4 *)(temp_var_7 + (int)temp_ptr_4);\n              temp_ptr_4[1] = temp_var_7 | 1;\n              *(int *)(temp_var_8 + 0xc) = temp_var_3;\n              *(int *)(temp_var_3 + 8) = temp_var_8;\n              DAT_2000045c = temp_ptr_7;\n              DAT_20000460 = temp_ptr_7;\n              temp_ptr_7[2] = &DAT_20000454;\n              temp_ptr_7[3] = &DAT_20000454;\n              temp_ptr_7[1] = temp_var_2 | 1;\n              *(uint *)((int)temp_ptr_4 + temp_var_5) = temp_var_2;\n              __malloc_unlock(lock_ptr);\n              return temp_ptr_4 + 2;\n            }\n            if (-1 < (int)temp_var_2) {\n              temp_var_3 = temp_ptr_4[3];\n              temp_var_8 = temp_ptr_4[2];\n              *(uint *)((int)temp_ptr_4 + temp_var_5 + 4) = *(uint *)((int)temp_ptr_4 + temp_var_5 + 4) | 1;\n              *(int *)(temp_var_8 + 0xc) = temp_var_3;\n              *(int *)(temp_var_3 + 8) = temp_var_8;\n              __malloc_unlock(lock_ptr);\n              return temp_ptr_4 + 2;\n            }\n          }\n          temp_var_1 = temp_var_1 + 1;\n          temp_ptr_7 = temp_ptr_7 + 2;\n        } while ((temp_var_1 & 3) != 0);\n        do {\n          temp_var_5 = temp_var_6 & 3;\n          temp_ptr_7 = temp_ptr_9 + -2;\n          temp_var_6 = temp_var_6 - 1;\n          if (temp_var_5 == 0) {\n            DAT_20000450 = DAT_20000450 & ~temp_var_4;\n            break;\n          }\n          temp_ptr_9 = (undefined4 *)*temp_ptr_9;\n        } while (temp_ptr_9 == temp_ptr_7);\n        temp_var_4 = temp_var_4 * 2;\n        if ((DAT_20000450 <= temp_var_4 && temp_var_4 - DAT_20000450 != 0) || (temp_var_6 = temp_var_1, temp_var_4 == 0))\n        break;\n        for (; (temp_var_4 & DAT_20000450) == 0; temp_var_4 = temp_var_4 << 1) {\n          temp_var_6 = temp_var_6 + 4;\n        }\n      } while( true );\n    }\n  }\n  temp_ptr_8 = DAT_20000454;\n  temp_var_6 = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  if ((temp_var_7 <= temp_var_6) && (temp_var_1 = temp_var_6 - temp_var_7, 0xf < (int)temp_var_1)) goto LAB_08008dac;\n  if (__malloc_sbrk_base == (undefined1 *)0xffffffff) {\n    temp_var_1 = temp_var_7 + __malloc_top_pad + 0x10;\n  }\n  else {\n    temp_var_1 = temp_var_7 + __malloc_top_pad + 0x100f & 0xfffff000;\n  }\n  temp_ptr_1 = (undefined1 *)_sbrk_r(lock_ptr,temp_var_1);\n  if (temp_ptr_1 == (undefined1 *)0xffffffff) {\nLAB_08008ed8:\n    temp_var_6 = *(uint *)(DAT_20000454 + 4);\n  }\n  else {\n    temp_ptr_2 = temp_ptr_8 + temp_var_6;\n    if (temp_ptr_2 < temp_ptr_1 || temp_ptr_2 == temp_ptr_1) {\n      temp_ptr_5 = __malloc_current_mallinfo + temp_var_1;\n      if ((temp_ptr_2 != temp_ptr_1) || (((uint)temp_ptr_2 & 0xfff) != 0)) goto LAB_08008d02;\n      __malloc_current_mallinfo = temp_ptr_5;\n      *(uint *)(DAT_20000454 + 4) = temp_var_6 + temp_var_1 | 1;\n    }\n    else {\n      if (temp_ptr_8 != &__malloc_av_) goto LAB_08008ed8;\nLAB_08008d02:\n      __malloc_current_mallinfo = __malloc_current_mallinfo + temp_var_1;\n      temp_ptr_5 = temp_ptr_1;\n      if (__malloc_sbrk_base != (undefined1 *)0xffffffff) {\n        __malloc_current_mallinfo = __malloc_current_mallinfo + ((int)temp_ptr_1 - (int)temp_ptr_2);\n        temp_ptr_5 = __malloc_sbrk_base;\n      }\n      __malloc_sbrk_base = temp_ptr_5;\n      temp_var_4 = (uint)temp_ptr_1 & 7;\n      if (temp_var_4 == 0) {\n        temp_var_3 = 0x1000;\n      }\n      else {\n        temp_ptr_1 = temp_ptr_1 + (8 - temp_var_4);\n        temp_var_3 = 0x1008 - temp_var_4;\n      }\n      temp_var_3 = temp_var_3 - ((uint)(temp_ptr_1 + temp_var_1) & 0xfff);\n      temp_var_8 = _sbrk_r(lock_ptr,temp_var_3);\n      if (temp_var_8 == -1) {\n        temp_var_1 = 1;\n        temp_var_3 = 0;\n      }\n      else {\n        temp_var_1 = (temp_var_8 - (int)temp_ptr_1) + temp_var_3 | 1;\n      }\n      temp_ptr_5 = __malloc_current_mallinfo + temp_var_3;\n      DAT_20000454 = temp_ptr_1;\n      __malloc_current_mallinfo = temp_ptr_5;\n      *(uint *)(temp_ptr_1 + 4) = temp_var_1;\n      if (temp_ptr_8 != &__malloc_av_) {\n        if (temp_var_6 < 0x10) {\n          *(undefined4 *)(temp_ptr_1 + 4) = 1;\n          goto LAB_08008eee;\n        }\n        temp_var_6 = temp_var_6 - 0xc & 0xfffffff8;\n        *(uint *)(temp_ptr_8 + 4) = *(uint *)(temp_ptr_8 + 4) & 1 | temp_var_6;\n        *(undefined4 *)(temp_ptr_8 + temp_var_6 + 4) = 5;\n        *(undefined4 *)(temp_ptr_8 + temp_var_6 + 8) = 5;\n        if (0xf < temp_var_6) {\n          _free_r(lock_ptr,temp_ptr_8 + 8);\n          temp_ptr_5 = __malloc_current_mallinfo;\n        }\n      }\n    }\n    if (__malloc_max_sbrked_mem < temp_ptr_5) {\n      __malloc_max_sbrked_mem = temp_ptr_5;\n    }\n    temp_var_6 = *(uint *)(DAT_20000454 + 4);\n    if (__malloc_max_total_mem < temp_ptr_5) {\n      __malloc_max_total_mem = temp_ptr_5;\n    }\n  }\n  temp_var_1 = (temp_var_6 & 0xfffffffc) - temp_var_7;\n  if ((temp_var_7 <= (temp_var_6 & 0xfffffffc)) && (0xf < (int)temp_var_1)) {\nLAB_08008dac:\n    temp_ptr_8 = DAT_20000454 + temp_var_7;\n    *(uint *)(DAT_20000454 + 4) = temp_var_7 | 1;\n    result_ptr = (int *)(DAT_20000454 + 8);\n    DAT_20000454 = temp_ptr_8;\n    *(uint *)(temp_ptr_8 + 4) = temp_var_1 | 1;\n    __malloc_unlock(lock_ptr);\n    return result_ptr;\n  }\nLAB_08008eee:\n  __malloc_unlock(lock_ptr);\n  return (int *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08008af8": "allocate_memory_08008af8",
                "param_1": "lock_ptr",
                "param_2": "size",
                "puVar1": "temp_ptr_1",
                "puVar2": "temp_ptr_2",
                "uVar3": "temp_var_1",
                "uVar4": "temp_var_2",
                "iVar5": "temp_var_3",
                "puVar6": "temp_ptr_3",
                "uVar7": "temp_var_4",
                "uVar8": "temp_var_5",
                "puVar9": "temp_ptr_4",
                "puVar10": "temp_ptr_5",
                "puVar11": "temp_ptr_6",
                "piVar12": "result_ptr",
                "uVar13": "temp_var_6",
                "uVar14": "temp_var_7",
                "iVar15": "temp_var_8",
                "puVar16": "temp_ptr_7",
                "puVar17": "temp_ptr_8",
                "puVar18": "temp_ptr_9"
            },
            "calling": [
                "__ssprint_r",
                "_svfprintf_r",
                "_realloc_r",
                "_calloc_r"
            ],
            "called": [
                "_free_r",
                "_sbrk_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800901c": {
            "entrypoint": "0x0800901c",
            "current_name": "find_byte_sequence_0800901c",
            "code": "\nvoid * find_byte_sequence_0800901c(void *data,int byte,size_t length)\n\n{\n  uint temp1;\n  uint temp2;\n  uint *ptr;\n  uint byte_value;\n  bool found_sequence;\n  \n  byte_value = byte & 0xff;\n  if (((uint)data & 3) == 0) {\nLAB_0800904a:\n    if (3 < length) {\n      temp2 = (byte & 0xffU) << 8 | byte_value;\n      ptr = (uint *)data;\n      do {\n        temp1 = *ptr ^ (temp2 | temp2 << 0x10);\n        data = ptr + 1;\n        if ((temp1 + 0xfefefeff & ~temp1 & 0x80808080) != 0) goto LAB_08009050;\n        length = length - 4;\n        ptr = (uint *)data;\n      } while (3 < length);\n    }\n    ptr = (uint *)data;\n    if (length == 0) {\n      data = (uint *)0x0;\n    }\n    else {\nLAB_08009050:\n      data = ptr;\n                    /* WARNING: Load size is inaccurate */\n      if (*data != byte_value) {\n        ptr = (uint *)(length + (int)data);\n        do {\n          data = (void *)((int)data + 1);\n          if (ptr == (uint *)data) goto LAB_0800906c;\n                    /* WARNING: Load size is inaccurate */\n        } while (*data != byte_value);\n      }\n    }\n  }\n  else {\n    temp2 = length - 1;\n    if (length == 0) {\nLAB_0800906c:\n      data = (uint *)0x0;\n    }\n    else {\n                    /* WARNING: Load size is inaccurate */\n      if (*data != byte_value) {\n        ptr = (uint *)((int)data + 1);\n        do {\n          data = ptr;\n          length = temp2;\n          if (((uint)data & 3) == 0) goto LAB_0800904a;\n          found_sequence = temp2 == 0;\n          temp2 = temp2 - 1;\n          if (found_sequence) goto LAB_0800906c;\n                    /* WARNING: Load size is inaccurate */\n          ptr = (uint *)((int)data + 1);\n        } while (*data != byte_value);\n      }\n    }\n  }\n  return data;\n}\n\n",
            "renaming": {
                "FUN_0800901c": "find_byte_sequence_0800901c",
                "__s": "data",
                "__c": "byte",
                "__n": "length",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "puVar3": "ptr",
                "uVar4": "byte_value",
                "bVar5": "found_sequence"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090a8": {
            "entrypoint": "0x080090a8",
            "current_name": "acquire_malloc_recursive_mutex_080090a8",
            "code": "\nvoid acquireMallocRecursiveMutex_080090a8(void)\n\n{\n  lockAcquireRecursive(mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090a8": "acquire_malloc_recursive_mutex_080090a8",
                "__retarget_lock_acquire_recursive": "lockAcquireRecursive",
                "&__lock___malloc_recursive_mutex": "mutex"
            },
            "calling": [
                "_malloc_r",
                "_free_r",
                "_malloc_trim_r",
                "_realloc_r"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090b4": {
            "entrypoint": "0x080090b4",
            "current_name": "release_recursive_lock_080090b4",
            "code": "\nvoid releaseRecursiveLock_080090b4(void)\n\n{\n  __retarget_lock_release_recursive(&recursiveLock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090b4": "release_recursive_lock_080090b4",
                "__lock___malloc_recursive_mutex": "recursiveLock"
            },
            "calling": [
                "_malloc_r",
                "_free_r",
                "_malloc_trim_r",
                "_realloc_r"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090c0": {
            "entrypoint": "0x080090c0",
            "current_name": "allocate_or_update_array_080090c0",
            "code": "\nundefined4 * allocateOrUpdateArray_080090c0(int arrayPointer,uint index)\n\n{\n  undefined4 *arrayElement;\n  int arrayHandle;\n  \n  arrayHandle = *(int *)(arrayPointer + 0x4c);\n  if (arrayHandle == 0) {\n    arrayHandle = _calloc_r(arrayPointer,4,0x21);\n    *(int *)(arrayPointer + 0x4c) = arrayHandle;\n    if (arrayHandle == 0) {\n      return (undefined4 *)0x0;\n    }\n  }\n  arrayElement = *(undefined4 **)(arrayHandle + index * 4);\n  if (arrayElement == (undefined4 *)0x0) {\n    arrayHandle = 1 << (index & 0xff);\n    arrayElement = (undefined4 *)_calloc_r(arrayPointer,1,(arrayHandle + 5) * 4);\n    if (arrayElement == (undefined4 *)0x0) {\n      return (undefined4 *)0x0;\n    }\n    arrayElement[1] = index;\n    arrayElement[2] = arrayHandle;\n  }\n  else {\n    *(undefined4 *)(arrayHandle + index * 4) = *arrayElement;\n  }\n  arrayElement[3] = 0;\n  arrayElement[4] = 0;\n  return arrayElement;\n}\n\n",
            "renaming": {
                "FUN_080090c0": "allocate_or_update_array_080090c0",
                "param_1": "arrayPointer",
                "param_2": "index",
                "puVar1": "arrayElement",
                "iVar2": "arrayHandle"
            },
            "calling": [
                "__multiply",
                "__lshift",
                "_dtoa_r",
                "__d2b",
                "__mdiff",
                "__multadd",
                "__i2b",
                "__pow5mult"
            ],
            "called": [
                "_calloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800910c": {
            "entrypoint": "0x0800910c",
            "current_name": "update_parameter_value_0800910c",
            "code": "\nvoid updateParameterValue_0800910c(int memoryAddress,undefined4 *newValue)\n\n{\n  int dataPointer;\n  \n  if (newValue != (undefined4 *)0x0) {\n    dataPointer = *(int *)(memoryAddress + 0x4c);\n    *newValue = *(undefined4 *)(dataPointer + newValue[1] * 4);\n    *(undefined4 **)(dataPointer + newValue[1] * 4) = newValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800910c": "update_parameter_value_0800910c",
                "param_1": "memoryAddress",
                "param_2": "newValue",
                "iVar1": "dataPointer"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009120": {
            "entrypoint": "0x08009120",
            "current_name": "calculate_product_08009120",
            "code": "\nundefined4 * calculateProduct_08009120(int size,undefined4 *array,int multiplier,uint carry)\n\n{\n  undefined4 *result;\n  uint tempResult;\n  int numElements;\n  uint *currentElement;\n  int index;\n  \n  index = 0;\n  numElements = array[4];\n  currentElement = array + 5;\n  do {\n    index = index + 1;\n    carry = multiplier * (*currentElement & 0xffff) + carry;\n    tempResult = multiplier * (*currentElement >> 0x10) + (carry >> 0x10);\n    *currentElement = (carry & 0xffff) + tempResult * 0x10000;\n    carry = tempResult >> 0x10;\n    currentElement = currentElement + 1;\n  } while (index < numElements);\n  result = array;\n  if (carry != 0) {\n    if ((int)array[2] <= numElements) {\n      result = (undefined4 *)_Balloc(size,array[1] + 1);\n      memcpy(result + 3,array + 3,(array[4] + 2) * 4);\n      index = *(int *)(size + 0x4c);\n      *array = *(undefined4 *)(index + array[1] * 4);\n      *(undefined4 **)(index + array[1] * 4) = array;\n    }\n    result[numElements + 5] = carry;\n    result[4] = numElements + 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009120": "calculate_product_08009120",
                "param_1": "size",
                "param_2": "array",
                "param_3": "multiplier",
                "param_4": "carry",
                "puVar1": "result",
                "uVar2": "tempResult",
                "iVar3": "numElements",
                "puVar4": "currentElement",
                "iVar5": "index"
            },
            "calling": [
                "_dtoa_r",
                "__pow5mult"
            ],
            "called": [
                "memcpy",
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091a4": {
            "entrypoint": "0x080091a4",
            "current_name": "count_leading_zeros_080091a4",
            "code": "\nint countLeadingZeros_080091a4(uint input)\n\n{\n  int leadingZerosCount;\n  \n  if ((input & 0xffff0000) == 0) {\n    input = input << 0x10;\n    leadingZerosCount = 0x10;\n  }\n  else {\n    leadingZerosCount = 0;\n  }\n  if ((input & 0xff000000) == 0) {\n    input = input << 8;\n    leadingZerosCount = leadingZerosCount + 8;\n  }\n  if ((input & 0xf0000000) == 0) {\n    input = input << 4;\n    leadingZerosCount = leadingZerosCount + 4;\n  }\n  if ((input & 0xc0000000) == 0) {\n    input = input << 2;\n    leadingZerosCount = leadingZerosCount + 2;\n  }\n  if (-1 < (int)input) {\n    if ((int)(input << 1) < 0) {\n      return leadingZerosCount + 1;\n    }\n    leadingZerosCount = 0x20;\n  }\n  return leadingZerosCount;\n}\n\n",
            "renaming": {
                "FUN_080091a4": "count_leading_zeros_080091a4",
                "param_1": "input",
                "iVar1": "leadingZerosCount"
            },
            "calling": [
                "_dtoa_r",
                "__d2b"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091e4": {
            "entrypoint": "0x080091e4",
            "current_name": "count_trailing_zeros_080091e4",
            "code": "\nint count_trailing_zeros_080091e4(uint *input)\n\n{\n  int count;\n  uint value;\n  \n  value = *input;\n  if ((value & 7) == 0) {\n    if ((value & 0xffff) == 0) {\n      value = value >> 0x10;\n      count = 0x10;\n    }\n    else {\n      count = 0;\n    }\n    if ((value & 0xff) == 0) {\n      value = value >> 8;\n      count = count + 8;\n    }\n    if ((value & 0xf) == 0) {\n      value = value >> 4;\n      count = count + 4;\n    }\n    if ((value & 3) == 0) {\n      value = value >> 2;\n      count = count + 2;\n    }\n    if (-1 < (int)(value << 0x1f)) {\n      value = value >> 1;\n      if (value == 0) {\n        return 0x20;\n      }\n      count = count + 1;\n    }\n    *input = value;\n    return count;\n  }\n  if ((int)(value << 0x1f) < 0) {\n    return 0;\n  }\n  if (-1 < (int)(value << 0x1e)) {\n    *input = value >> 2;\n    return 2;\n  }\n  *input = value >> 1;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080091e4": "count_trailing_zeros_080091e4",
                "param_1": "input",
                "iVar1": "count",
                "uVar2": "value"
            },
            "calling": [
                "__d2b"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009244": {
            "entrypoint": "0x08009244",
            "current_name": "allocate_and_initialize_08009244",
            "code": "\nvoid allocateAndInitialize_08009244(undefined4 size,undefined4 value)\n\n{\n  int allocationResult;\n  \n  allocationResult = _Balloc(size,1);\n  *(undefined4 *)(allocationResult + 0x10) = 1;\n  *(undefined4 *)(allocationResult + 0x14) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009244": "allocate_and_initialize_08009244",
                "param_1": "size",
                "param_2": "value",
                "iVar1": "allocationResult"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009258": {
            "entrypoint": "0x08009258",
            "current_name": "calculate_polynomial_product_08009258",
            "code": "\nvoid calculatePolynomialProduct_08009258(undefined4 result,int polynomial1,int polynomial2)\n\n{\n  uint *iterator1;\n  uint *iterator2;\n  int polynomialLength;\n  uint carry;\n  uint *resultIterator;\n  uint offset;\n  uint *endIterator1;\n  uint temp1;\n  int length1;\n  int length2;\n  uint temp2;\n  int length1Copy;\n  int polynomial1Copy;\n  uint *resultStart;\n  uint *resultIterator1;\n  uint *startIterator1;\n  uint *endIterator2;\n  uint *resultIterator2;\n  \n  length1Copy = *(int *)(polynomial1 + 0x10);\n  length1 = *(int *)(polynomial2 + 0x10);\n  length2 = length1;\n  polynomial1Copy = polynomial1;\n  if (length1Copy < length1) {\n    length2 = length1Copy;\n    length1Copy = length1;\n    polynomial1Copy = polynomial2;\n    polynomial2 = polynomial1;\n  }\n  length1 = length1Copy + length2;\n  polynomialLength = *(int *)(polynomial1Copy + 4);\n  if (*(int *)(polynomial1Copy + 8) < length1) {\n    polynomialLength = polynomialLength + 1;\n  }\n  polynomialLength = _Balloc(result,polynomialLength);\n  resultIterator2 = (uint *)(polynomialLength + 0x14);\n  endIterator2 = resultIterator2 + length1;\n  for (resultIterator = resultIterator2; resultIterator < endIterator2; resultIterator = resultIterator + 1) {\n    *resultIterator = 0;\n  }\n  offset = polynomial2 + 0x14;\n  temp2 = offset + length2 * 4;\n  resultIterator = (uint *)(polynomial1Copy + 0x14);\n  if (offset < temp2) {\n    endIterator1 = (uint *)(offset + ((temp2 - polynomial2) - 0x15 & 0xfffffffc));\n    startIterator1 = (uint *)(polynomial2 + 0x10);\n    do {\n      while( true ) {\n        startIterator1 = startIterator1 + 1;\n        offset = *startIterator1 & 0xffff;\n        if (offset != 0) break;\n        offset = *startIterator1 >> 0x10;\n        if (offset == 0) goto LAB_080092d2;\nLAB_0800932c:\n        temp1 = *resultIterator2;\n        carry = 0;\n        iterator1 = resultIterator;\n        resultStart = resultIterator2;\n        temp2 = temp1;\n        do {\n          resultIterator1 = resultStart;\n          carry = carry + offset * *(ushort *)iterator1 + (temp2 >> 0x10);\n          *resultIterator1 = temp1 & 0xffff | carry * 0x10000;\n          iterator2 = iterator1 + 1;\n          temp2 = resultIterator1[1];\n          temp1 = offset * (*iterator1 >> 0x10) + (temp2 & 0xffff) + (carry >> 0x10);\n          carry = temp1 >> 0x10;\n          iterator1 = iterator2;\n          resultStart = resultIterator1 + 1;\n        } while (iterator2 < resultIterator + length1Copy);\n        resultIterator1[1] = temp1;\n        resultIterator2 = resultIterator2 + 1;\n        if (endIterator1 == startIterator1) goto LAB_0800937a;\n      }\n      temp2 = 0;\n      iterator1 = resultIterator2;\n      resultStart = resultIterator;\n      do {\n        iterator2 = iterator1;\n        resultIterator1 = resultStart + 1;\n        temp1 = offset * (*resultStart & 0xffff) + (*iterator2 & 0xffff) + temp2;\n        carry = offset * (*resultStart >> 0x10) + (*iterator2 >> 0x10) + (temp1 >> 0x10);\n        temp2 = carry >> 0x10;\n        *iterator2 = temp1 & 0xffff | carry * 0x10000;\n        iterator1 = iterator2 + 1;\n        resultStart = resultIterator1;\n      } while (resultIterator1 < resultIterator + length1Copy);\n      iterator2[1] = temp2;\n      offset = *startIterator1 >> 0x10;\n      if (offset != 0) goto LAB_0800932c;\nLAB_080092d2:\n      resultIterator2 = resultIterator2 + 1;\n    } while (endIterator1 != startIterator1);\n  }\nLAB_0800937a:\n  if (0 < length1) {\n    offset = endIterator2[-1];\n    endIterator2 = endIterator2 + -1;\n    while ((offset == 0 && (length1 = length1 + -1, length1 != 0))) {\n      endIterator2 = endIterator2 + -1;\n      offset = *endIterator2;\n    }\n  }\n  *(int *)(polynomialLength + 0x10) = length1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009258": "calculate_polynomial_product_08009258",
                "param_1": "result",
                "param_2": "polynomial1",
                "param_3": "polynomial2",
                "puVar1": "iterator1",
                "puVar2": "iterator2",
                "iVar3": "polynomialLength",
                "uVar4": "carry",
                "puVar5": "resultIterator",
                "uVar6": "offset",
                "puVar7": "endIterator1",
                "puVar16": "startIterator1",
                "uVar8": "temp1",
                "iVar9": "length1",
                "iVar10": "length2",
                "uVar11": "temp2",
                "iVar12": "length1Copy",
                "iVar13": "polynomial1Copy",
                "puVar14": "resultStart",
                "puVar15": "resultIterator1",
                "puVar17": "endIterator2",
                "puVar18": "resultIterator2"
            },
            "calling": [
                "_dtoa_r",
                "__pow5mult"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080093a4": {
            "entrypoint": "0x080093a4",
            "current_name": "multiply_and_add_080093a4",
            "code": "\nundefined4 * multiplyAndAdd_080093a4(int input,undefined4 *output,uint size)\n\n{\n  int temp1;\n  int temp2;\n  undefined4 *current;\n  undefined4 *next;\n  \n  if ((size & 3) != 0) {\n    output = (undefined4 *)\n              __multadd(input,output,*(undefined4 *)(&p05_6092 + ((size & 3) - 1) * 4),0);\n  }\n  temp2 = (int)size >> 2;\n  if (temp2 != 0) {\n    next = *(undefined4 **)(input + 0x48);\n    if (next == (undefined4 *)0x0) {\n      next = (undefined4 *)_Balloc(input,1);\n      next[4] = 1;\n      next[5] = 0x271;\n      *(undefined4 **)(input + 0x48) = next;\n      *next = 0;\n    }\n    current = output;\n    if (temp2 << 0x1f < 0) goto LAB_080093d2;\nLAB_080093c4:\n    temp2 = temp2 >> 1;\n    current = next;\n    if (temp2 != 0) {\n      while( true ) {\n        next = (undefined4 *)*current;\n        if (next == (undefined4 *)0x0) {\n          next = (undefined4 *)__multiply(input,current,current);\n          *current = next;\n          *next = 0;\n        }\n        current = output;\n        if (-1 < temp2 << 0x1f) break;\nLAB_080093d2:\n        output = (undefined4 *)__multiply(input,current,next);\n        if (current == (undefined4 *)0x0) break;\n        temp1 = *(int *)(input + 0x4c);\n        temp2 = temp2 >> 1;\n        *current = *(undefined4 *)(temp1 + current[1] * 4);\n        *(undefined4 **)(temp1 + current[1] * 4) = current;\n        current = next;\n        if (temp2 == 0) {\n          return output;\n        }\n      }\n      goto LAB_080093c4;\n    }\n  }\n  return output;\n}\n\n",
            "renaming": {
                "FUN_080093a4": "multiply_and_add_080093a4",
                "param_1": "input",
                "param_2": "output",
                "param_3": "size",
                "iVar1": "temp1",
                "iVar2": "temp2",
                "puVar3": "current",
                "puVar4": "next"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__multiply",
                "__multadd",
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009444": {
            "entrypoint": "0x08009444",
            "current_name": "copy_and_shift_bits_08009444",
            "code": "\nvoid copyAndShiftBits_08009444(int destination,undefined4 *source,uint bitCount)\n\n{\n  int shiftedValue;\n  int doubledValue;\n  int sourceLength;\n  undefined4 tempValue;\n  int initialDestination;\n  int iVar6;\n  uint *puVar7;\n  uint *puVar8;\n  uint *puVar10;\n  uint *puVar11;\n  int shiftedValue2;\n  int shiftedValue3;\n  uint uVar14;\n  uint *puVar9;\n  \n  initialDestination = source[4];\n  shiftedValue2 = (int)bitCount >> 5;\n  shiftedValue3 = shiftedValue2 + initialDestination + 1;\n  sourceLength = source[1];\n  doubledValue = source[2];\n  if ((int)source[2] < shiftedValue3) {\n    do {\n      iVar6 = doubledValue * 2;\n      shiftedValue = doubledValue * -2;\n      sourceLength = sourceLength + 1;\n      doubledValue = iVar6;\n    } while (shiftedValue3 != iVar6 && shiftedValue3 + shiftedValue < 0 == SBORROW4(shiftedValue3,iVar6));\n  }\n  doubledValue = _Balloc(destination,sourceLength);\n  puVar7 = (uint *)(doubledValue + 0x14);\n  if (0 < shiftedValue2) {\n    puVar11 = puVar7 + shiftedValue2;\n    puVar8 = puVar7;\n    do {\n      puVar9 = puVar8 + 1;\n      *puVar8 = 0;\n      puVar7 = puVar11;\n      puVar8 = puVar9;\n    } while (puVar9 != puVar11);\n  }\n  sourceLength = source[4];\n  puVar8 = source + 5;\n  bitCount = bitCount & 0x1f;\n  if (bitCount == 0) {\n    puVar7 = puVar7 + -1;\n    puVar11 = puVar8;\n    do {\n      puVar9 = puVar11 + 1;\n      puVar7 = puVar7 + 1;\n      *puVar7 = *puVar11;\n      puVar11 = puVar9;\n    } while (puVar9 < puVar8 + sourceLength);\n  }\n  else {\n    uVar14 = 0;\n    puVar11 = puVar8;\n    do {\n      puVar9 = puVar7;\n      *puVar9 = *puVar11 << bitCount | uVar14;\n      puVar10 = puVar11 + 1;\n      uVar14 = *puVar11 >> (0x20 - bitCount & 0xff);\n      puVar7 = puVar9 + 1;\n      puVar11 = puVar10;\n    } while (puVar10 < puVar8 + sourceLength);\n    puVar9[1] = uVar14;\n    if (uVar14 != 0) {\n      shiftedValue3 = shiftedValue2 + initialDestination + 2;\n    }\n  }\n  initialDestination = *(int *)(destination + 0x4c);\n  sourceLength = source[1];\n  tempValue = *(undefined4 *)(initialDestination + sourceLength * 4);\n  *(int *)(doubledValue + 0x10) = shiftedValue3 + -1;\n  *source = tempValue;\n  *(undefined4 **)(initialDestination + sourceLength * 4) = source;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009444": "copy_and_shift_bits_08009444",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "bitCount",
                "iVar1": "shiftedValue",
                "iVar2": "doubledValue",
                "iVar3": "sourceLength",
                "uVar4": "tempValue",
                "iVar5": "initialDestination"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080094f8": {
            "entrypoint": "0x080094f8",
            "current_name": "compare_array_segments_080094f8",
            "code": "\nint compareArraySegments_080094f8(int array1,int array2)\n\n{\n  int difference;\n  uint *ptrArray2Element;\n  int array2Length;\n  uint *ptrArray1Element;\n  \n  array2Length = *(int *)(array2 + 0x10);\n  difference = *(int *)(array1 + 0x10) - array2Length;\n  if (difference == 0) {\n    ptrArray2Element = (uint *)(array2 + 0x14 + array2Length * 4);\n    ptrArray1Element = (uint *)(array1 + 0x14) + array2Length;\n    do {\n      ptrArray1Element = ptrArray1Element + -1;\n      ptrArray2Element = ptrArray2Element + -1;\n      if (*ptrArray1Element != *ptrArray2Element) {\n        if (*ptrArray2Element <= *ptrArray1Element) {\n          return 1;\n        }\n        return -1;\n      }\n    } while ((uint *)(array1 + 0x14) < ptrArray1Element);\n  }\n  return difference;\n}\n\n",
            "renaming": {
                "FUN_080094f8": "compare_array_segments_080094f8",
                "param_1": "array1",
                "param_2": "array2",
                "iVar3": "array2Length",
                "iVar1": "difference",
                "puVar2": "ptrArray2Element",
                "puVar4": "ptrArray1Element"
            },
            "calling": [
                "_dtoa_r",
                "quorem"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009530": {
            "entrypoint": "0x08009530",
            "current_name": "reverse_and_improve_08009530",
            "code": "\nvoid reverseAndImprove_08009530(undefined4 inputParam1,uint *inputParam2,uint *outputParam1,undefined4 inputParam4)\n\n{\n  int outputVar1;\n  uint *var1;\n  uint var2;\n  uint var3;\n  undefined4 var4;\n  uint *var5;\n  uint *var6;\n  uint *var8;\n  uint *var9;\n  uint *var10;\n  int var11;\n  uint *var12;\n  uint var13;\n  uint *var7;\n  \n  var1 = (uint *)outputParam1[4];\n  var10 = inputParam2 + 5;\n  var12 = outputParam1 + 5;\n  var6 = var10;\n  var8 = inputParam2;\n  if ((uint *)inputParam2[4] == var1) {\n    var5 = var10 + (int)var1;\n    var1 = var12 + (int)var1;\n    while( true ) {\n      var5 = var5 + -1;\n      var1 = var1 + -1;\n      if (*var5 != *var1) break;\n      if (var5 <= var10) {\n        var11 = _Balloc(inputParam1,0,var5,var1,inputParam4);\n        *(undefined4 *)(var11 + 0x10) = 1;\n        *(undefined4 *)(var11 + 0x14) = 0;\n        return;\n      }\n    }\n    var4 = 0;\n    if (*var1 <= *var5) goto LAB_08009578;\n  }\n  else if (-1 < (int)(uint *)inputParam2[4] - (int)var1) {\n    var4 = 0;\n    var5 = outputParam1;\n    goto LAB_08009578;\n  }\n  var4 = 1;\n  var5 = var10;\n  var1 = inputParam2;\n  var6 = var12;\n  var8 = outputParam1;\n  outputParam1 = inputParam2;\n  var12 = var10;\nLAB_08009578:\n  outputVar1 = _Balloc(inputParam1,var8[1],var5,var1,inputParam4);\n  var11 = 0;\n  var13 = var8[4];\n  var2 = outputParam1[4];\n  *(undefined4 *)(outputVar1 + 0xc) = var4;\n  var10 = var6 + var13;\n  var1 = (uint *)(outputVar1 + 0x14);\n  var8 = var12;\n  do {\n    var7 = var6 + 1;\n    var9 = var8 + 1;\n    var3 = ((*var6 & 0xffff) + var11) - (*var8 & 0xffff);\n    var11 = ((*var6 >> 0x10) - (*var8 >> 0x10)) + ((int)var3 >> 0x10);\n    var3 = var3 & 0xffff | var11 * 0x10000;\n    var5 = var1 + 1;\n    *var1 = var3;\n    var11 = var11 >> 0x10;\n    var1 = var5;\n    var6 = var7;\n    var8 = var9;\n  } while (var9 < var12 + var2);\n  var1 = var7;\n  var6 = var5;\n  if (var7 < var10) {\n    do {\n      var8 = var1 + 1;\n      var2 = (*var1 & 0xffff) + var11;\n      var11 = ((int)var2 >> 0x10) + (*var1 >> 0x10);\n      var3 = var2 & 0xffff | var11 * 0x10000;\n      *var6 = var3;\n      var11 = var11 >> 0x10;\n      var1 = var8;\n      var6 = var6 + 1;\n    } while (var8 < var10);\n    var5 = (uint *)((int)var5 + ((int)var10 + ~(uint)var7 & 0xfffffffc) + 4);\n  }\n  var5 = var5 + -1;\n  while (var3 == 0) {\n    var5 = var5 + -1;\n    var13 = var13 - 1;\n    var3 = *var5;\n  }\n  *(uint *)(outputVar1 + 0x10) = var13;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009530": "reverse_and_improve_08009530",
                "param_1": "inputParam1",
                "param_2": "inputParam2",
                "param_3": "outputParam1",
                "param_4": "inputParam4",
                "iVar1": "outputVar1",
                "puVar2": "var1",
                "uVar3": "var2",
                "uVar4": "var3",
                "uVar5": "var4",
                "puVar6": "var5",
                "puVar7": "var6",
                "puVar8": "var7",
                "puVar9": "var8",
                "puVar10": "var9",
                "puVar11": "var10",
                "iVar12": "var11",
                "puVar13": "var12",
                "uVar14": "var13"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009630": {
            "entrypoint": "0x08009630",
            "current_name": "decode_and_calculate_08009630",
            "code": "\nint decodeAndCalculate_08009630(undefined4 size,undefined4 flags,uint value1,uint value2,int *result1,\n                int *result2)\n\n{\n  int buffer;\n  uint shiftCount;\n  int bitCount;\n  int factor;\n  uint maskedValue;\n  uint highBits;\n  undefined8 highestBitPosition;\n  uint tempValue1;\n  uint tempValue2;\n  \n  buffer = _Balloc(size,1);\n  highBits = (value2 << 1) >> 0x15;\n  tempValue2 = value2 & 0xfffff;\n  if (highBits != 0) {\n    tempValue2 = tempValue2 | 0x100000;\n  }\n  if (value1 == 0) {\n    bitCount = __lo0bits(&tempValue2);\n    factor = 1;\n    shiftCount = bitCount + 0x20;\n    *(undefined4 *)(buffer + 0x10) = 1;\n    *(uint *)(buffer + 0x14) = tempValue2;\n  }\n  else {\n    tempValue1 = value1;\n    shiftCount = __lo0bits(&tempValue1);\n    if (shiftCount == 0) {\n      *(uint *)(buffer + 0x14) = tempValue1;\n    }\n    else {\n      maskedValue = tempValue2 << (0x20 - shiftCount & 0xff);\n      tempValue2 = tempValue2 >> (shiftCount & 0xff);\n      *(uint *)(buffer + 0x14) = maskedValue | tempValue1;\n    }\n    if (tempValue2 == 0) {\n      factor = 1;\n    }\n    else {\n      factor = 2;\n    }\n    *(uint *)(buffer + 0x18) = tempValue2;\n    *(int *)(buffer + 0x10) = factor;\n  }\n  if (highBits == 0) {\n    *result1 = shiftCount - 0x432;\n    highestBitPosition = __hi0bits(*(undefined4 *)(buffer + factor * 4 + 0x10));\n    *result2 = (int)((ulonglong)highestBitPosition >> 0x20) * 0x20 - (int)highestBitPosition;\n    return buffer;\n  }\n  *result1 = (highBits - 0x433) + shiftCount;\n  *result2 = 0x35 - shiftCount;\n  return buffer;\n}\n\n",
            "renaming": {
                "FUN_08009630": "decode_and_calculate_08009630",
                "param_1": "size",
                "param_2": "flags",
                "param_3": "value1",
                "param_4": "value2",
                "param_5": "result1",
                "param_6": "result2",
                "iVar1": "buffer",
                "uVar2": "shiftCount",
                "iVar3": "bitCount",
                "iVar4": "factor",
                "uVar5": "maskedValue",
                "uVar6": "highBits",
                "uVar7": "highestBitPosition",
                "local_20": "tempValue1",
                "local_1c": "tempValue2"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__hi0bits",
                "__lo0bits",
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080096e0": {
            "entrypoint": "0x080096e0",
            "current_name": "calculate_exponent_080096e0",
            "code": "\ndouble calculateExponent_080096e0(double input,int *output)\n\n{\n  uint x;\n  uint temp;\n  int *exponent;\n  int offset;\n  uint abs_x;\n  double result;\n  \n  offset = 0;\n  abs_x = x & 0x7fffffff;\n  *exponent = 0;\n  if ((abs_x < 0x7ff00000) && ((abs_x | (uint)output) != 0)) {\n    if (abs_x < 0x100000) {\n      result = (double)__muldf3(output,x,0,0x43500000);\n      offset = -0x36;\n      abs_x = temp & 0x7fffffff;\n    }\n    *exponent = ((int)abs_x >> 0x14) + -0x3fe + offset;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080096e0": "calculate_exponent_080096e0",
                "__x": "input",
                "__exponent": "output",
                "in_r1": "x",
                "extraout_r1": "temp",
                "in_r2": "exponent",
                "iVar1": "offset",
                "uVar2": "abs_x",
                "in_d0": "result"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__muldf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009744": {
            "entrypoint": "0x08009744",
            "current_name": "allocate_memory_08009744",
            "code": "\nvoid allocateMemory_08009744(int *errorCode,intptr_t size)\n\n{\n  void *memoryAddress;\n  \n  errno = 0;\n  memoryAddress = _sbrk(size);\n  if ((memoryAddress == (void *)0xffffffff) && (errno != 0)) {\n    *errorCode = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009744": "allocate_memory_08009744",
                "param_1": "errorCode",
                "param_2": "size",
                "pvVar1": "memoryAddress"
            },
            "calling": [
                "_malloc_r",
                "_malloc_trim_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009768": {
            "entrypoint": "0x08009768",
            "current_name": "copy_string_08009768",
            "code": "\nchar * copyString_08009768(char *destination,char *source,size_t length)\n\n{\n  char currentChar;\n  uint *srcPtr_uint;\n  uint *destPtr_uint;\n  uint *tempPtr_uint;\n  uint tempValue;\n  \n  destPtr_uint = (uint *)destination;\n  if (((((uint)destination | (uint)source) & 3) == 0) && (srcPtr_uint = (uint *)source, 3 < length)) {\n    do {\n      source = (char *)(srcPtr_uint + 1);\n      tempValue = *srcPtr_uint;\n      if ((tempValue + 0xfefefeff & ~tempValue & 0x80808080) != 0) goto LAB_0800979c;\n      length = length - 4;\n      srcPtr_uint = destPtr_uint + 1;\n      *destPtr_uint = tempValue;\n      destPtr_uint = srcPtr_uint;\n      srcPtr_uint = (uint *)source;\n    } while (3 < length);\n  }\n  srcPtr_uint = (uint *)source;\n  if (length != 0) {\nLAB_0800979c:\n    currentChar = *(char *)srcPtr_uint;\n    *(char *)destPtr_uint = currentChar;\n    while( true ) {\n      destPtr_uint = (uint *)((int)destPtr_uint + 1);\n      length = length - 1;\n      if (currentChar == '\\0') break;\n      if (length == 0) {\n        return destination;\n      }\n      srcPtr_uint = (uint *)((int)srcPtr_uint + 1);\n      currentChar = *(char *)srcPtr_uint;\n      *(char *)destPtr_uint = currentChar;\n    }\n    if (length != 0) {\n      srcPtr_uint = destPtr_uint;\n      do {\n        tempPtr_uint = (uint *)((int)srcPtr_uint + 1);\n        *(char *)srcPtr_uint = '\\0';\n        srcPtr_uint = tempPtr_uint;\n      } while (tempPtr_uint != (uint *)(length + (int)destPtr_uint));\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08009768": "copy_string_08009768",
                "__dest": "destination",
                "__src": "source",
                "__n": "length",
                "cVar1": "currentChar",
                "puVar2": "srcPtr_uint",
                "puVar3": "destPtr_uint",
                "puVar4": "tempPtr_uint",
                "uVar5": "tempValue"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080097cc": {
            "entrypoint": "0x080097cc",
            "current_name": "decomp_extract_and_copy_080097cc",
            "code": "\nundefined4 decomp_extract_and_copy_080097cc(undefined4 *error_code,void **src_dest,int *params)\n\n{\n  void *src_ptr;\n  void *dest_ptr;\n  int len;\n  void *temp_ptr;\n  void *copy_len;\n  void **s;\n  void **next_s;\n  void *src;\n  size_t num_bytes;\n  \n  if (params[2] != 0) {\n    src_ptr = *src_dest;\n    temp_ptr = src_dest[2];\n    next_s = (void **)*params;\n    do {\n      do {\n        s = next_s + 2;\n        src = *next_s;\n        copy_len = next_s[1];\n        next_s = s;\n      } while (copy_len == (void *)0x0);\n      dest_ptr = copy_len;\n      if ((temp_ptr <= copy_len) && (dest_ptr = temp_ptr, (*(ushort *)(src_dest + 3) & 0x480) != 0)) {\n        num_bytes = (int)src_ptr - (int)src_dest[4];\n        temp_ptr = (void *)(((int)src_dest[5] * 3) / 2);\n        src_ptr = (void *)((int)copy_len + num_bytes + 1);\n        if (temp_ptr < src_ptr) {\n          temp_ptr = src_ptr;\n        }\n        if ((int)((uint)*(ushort *)(src_dest + 3) << 0x15) < 0) {\n          dest_ptr = (void *)allocate_memory(error_code,temp_ptr);\n          if (dest_ptr == (void *)0x0) {\nLAB_08009896:\n            *error_code = 0xc;\n            *(ushort *)(src_dest + 3) = *(ushort *)(src_dest + 3) | 0x40;\n            params[1] = 0;\n            params[2] = 0;\n            return 0xffffffff;\n          }\n          memcpy(dest_ptr,src_dest[4],num_bytes);\n          *(ushort *)(src_dest + 3) = *(ushort *)(src_dest + 3) & 0xfb7f | 0x80;\n        }\n        else {\n          dest_ptr = (void *)reallocate_memory(error_code);\n          if (dest_ptr == (void *)0x0) {\n            free_memory(error_code,src_dest[4]);\n            goto LAB_08009896;\n          }\n        }\n        src_ptr = (void *)((int)dest_ptr + num_bytes);\n        src_dest[5] = temp_ptr;\n        src_dest[4] = dest_ptr;\n        *src_dest = src_ptr;\n        src_dest[2] = (void *)((int)temp_ptr - num_bytes);\n        dest_ptr = copy_len;\n      }\n      memmove(src_ptr,src,(size_t)dest_ptr);\n      len = params[2];\n      temp_ptr = (void *)((int)src_dest[2] - (int)dest_ptr);\n      src_ptr = (void *)((int)*src_dest + (int)dest_ptr);\n      src_dest[2] = temp_ptr;\n      *src_dest = src_ptr;\n      params[2] = len - (int)copy_len;\n    } while (len - (int)copy_len != 0);\n  }\n  params[1] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080097cc": "decomp_extract_and_copy_080097cc",
                "param_1": "error_code",
                "param_2": "src_dest",
                "param_3": "params",
                "pvVar1": "src_ptr",
                "pvVar2": "dest_ptr",
                "iVar3": "len",
                "pvVar4": "temp_ptr",
                "pvVar5": "copy_len",
                "ppvVar6": "s",
                "ppvVar7": "next_s",
                "__src": "src",
                "__n": "num_bytes",
                "_malloc_r": "allocate_memory",
                "_realloc_r": "reallocate_memory",
                "_free_r": "free_memory"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "_malloc_r",
                "memmove",
                "_free_r",
                "memcpy",
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080098c0": {
            "entrypoint": "0x080098c0",
            "current_name": "add_callback_080098c0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08009906) */\n/* WARNING: Removing unreachable block (ram,0x08009912) */\n\nundefined4 addCallback_080098c0(int callbackType,undefined4 callbackFunction,undefined4 data1,undefined4 data2)\n\n{\n  undefined *callbackList;\n  undefined4 returnValue;\n  uint bitMask;\n  uint index;\n  \n  __retarget_lock_acquire_recursive(__atexit_recursive_mutex);\n  if (DAT_20000168 == (undefined *)0x0) {\n    DAT_20000168 = &DAT_2000016c;\n  }\n  callbackList = DAT_20000168;\n  index = *(uint *)(DAT_20000168 + 4);\n  if ((int)index < 0x20) {\n    if (callbackType != 0) {\n      *(undefined4 *)(DAT_20000168 + index * 4 + 0x88) = data1;\n      bitMask = 1 << (index & 0xff);\n      *(uint *)(callbackList + 0x188) = *(uint *)(callbackList + 0x188) | bitMask;\n      *(undefined4 *)(callbackList + index * 4 + 0x108) = data2;\n      if (callbackType == 2) {\n        *(uint *)(callbackList + 0x18c) = bitMask | *(uint *)(callbackList + 0x18c);\n      }\n    }\n    *(uint *)(callbackList + 4) = index + 1;\n    returnValue = __atexit_recursive_mutex;\n    *(undefined4 *)(callbackList + (index + 2) * 4) = callbackFunction;\n    __retarget_lock_release_recursive(returnValue);\n    returnValue = 0;\n  }\n  else {\n    __retarget_lock_release_recursive(__atexit_recursive_mutex);\n    returnValue = 0xffffffff;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080098c0": "add_callback_080098c0",
                "param_1": "callbackType",
                "param_2": "callbackFunction",
                "param_3": "data1",
                "param_4": "data2",
                "puVar1": "callbackList",
                "uVar2": "returnValue",
                "uVar3": "bitMask",
                "uVar4": "index"
            },
            "calling": [
                "atexit"
            ],
            "called": [
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009980": {
            "entrypoint": "0x08009980",
            "current_name": "allocate_and_initialize_memory_08009980",
            "code": "\nundefined4 * allocate_and_initialize_memory_08009980(undefined4 element_size,int num_elements,int num_blocks)\n\n{\n  undefined4 *allocated_memory;\n  size_t allocated_size;\n  undefined4 *init_ptr;\n  \n  allocated_memory = (undefined4 *)_malloc_r(element_size,num_blocks * num_elements);\n  if (allocated_memory == (undefined4 *)0x0) {\n    return (undefined4 *)0x0;\n  }\n  allocated_size = (allocated_memory[-1] & 0xfffffffc) - 4;\n  if (allocated_size < 0x25) {\n    init_ptr = allocated_memory;\n    if (0x13 < allocated_size) {\n      *allocated_memory = 0;\n      allocated_memory[1] = 0;\n      if (0x1b < allocated_size) {\n        allocated_memory[2] = 0;\n        allocated_memory[3] = 0;\n        if (allocated_size == 0x24) {\n          allocated_memory[4] = 0;\n          allocated_memory[5] = 0;\n          init_ptr = allocated_memory + 6;\n        }\n        else {\n          init_ptr = allocated_memory + 4;\n        }\n        *init_ptr = 0;\n        init_ptr[1] = 0;\n        init_ptr[2] = 0;\n        return allocated_memory;\n      }\n      init_ptr = allocated_memory + 2;\n    }\n    *init_ptr = 0;\n    init_ptr[1] = 0;\n    init_ptr[2] = 0;\n    return allocated_memory;\n  }\n  memset(allocated_memory,0,allocated_size);\n  return allocated_memory;\n}\n\n",
            "renaming": {
                "FUN_08009980": "allocate_and_initialize_memory_08009980",
                "param_1": "element_size",
                "param_2": "num_elements",
                "param_3": "num_blocks",
                "__s": "allocated_memory",
                "__n": "allocated_size",
                "puVar1": "init_ptr"
            },
            "calling": [
                "_Balloc"
            ],
            "called": [
                "memset",
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080099ec": {
            "entrypoint": "0x080099ec",
            "current_name": "read_byte_and_check_080099ec",
            "code": "\nuint readByteAndCheck_080099ec(undefined4 inputFlag,uint *outputPtr,byte *bytePtr,int size)\n\n{\n  uint result;\n  uint defaultOutput;\n  \n  if (outputPtr == (uint *)0x0) {\n    outputPtr = &defaultOutput;\n  }\n  if (bytePtr == (byte *)0x0) {\n    return 0;\n  }\n  if (size == 0) {\n    result = 0xfffffffe;\n  }\n  else {\n    *outputPtr = (uint)*bytePtr;\n    result = (uint)*bytePtr;\n    if (result != 0) {\n      result = 1;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080099ec": "read_byte_and_check_080099ec",
                "param_1": "inputFlag",
                "param_2": "outputPtr",
                "param_3": "bytePtr",
                "param_4": "size",
                "uVar1": "result",
                "uStack_4": "defaultOutput"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009a18": {
            "entrypoint": "0x08009a18",
            "current_name": "memcpy_reverse_08009a18",
            "code": "\nvoid * memcpy_reverse_08009a18(void *dest,void *src,size_t size)\n\n{\n  undefined4 *dest_ptr;\n  undefined *src_ptr;\n  int src_index;\n  void *dest_index;\n  undefined *dest_end;\n  int temp1;\n  uint temp2;\n  int temp3;\n  uint remaining_size;\n  undefined4 *src_ptr_2;\n  \n  if ((src < dest) && (src_ptr = (undefined *)((int)src + size), dest < src_ptr)) {\n    dest_end = (undefined *)((int)dest + size);\n    if (size != 0) {\n      do {\n        src_ptr = src_ptr + -1;\n        dest_end = dest_end + -1;\n        *dest_end = *src_ptr;\n      } while ((undefined *)src != src_ptr);\n    }\n  }\n  else {\n    remaining_size = size;\n    dest_index = dest;\n    if (0xf < size) {\n      if ((((uint)dest | (uint)src) & 3) != 0) goto LAB_08009abc;\n      src_index = (int)src + 0x10;\n      temp3 = (int)dest + 0x10;\n      do {\n        temp1 = src_index + 0x10;\n        *(undefined4 *)(temp3 + -0x10) = *(undefined4 *)(src_index + -0x10);\n        *(undefined4 *)(temp3 + -0xc) = *(undefined4 *)(src_index + -0xc);\n        *(undefined4 *)(temp3 + -8) = *(undefined4 *)(src_index + -8);\n        *(undefined4 *)(temp3 + -4) = *(undefined4 *)(src_index + -4);\n        src_index = temp1;\n        temp3 = temp3 + 0x10;\n      } while (temp1 != (int)src + (size - 0x10 & 0xfffffff0) + 0x20);\n      remaining_size = size & 0xf;\n      src_index = ((size - 0x10 >> 4) + 1) * 0x10;\n      src = (void *)((int)src + src_index);\n      dest_index = (void *)(src_index + (int)dest);\n      if (3 < remaining_size) {\n        src_ptr_2 = (undefined4 *)((int)dest_index + -4);\n        temp2 = remaining_size;\n        dest_ptr = (undefined4 *)src;\n        do {\n          temp2 = temp2 - 4;\n          src_ptr_2 = src_ptr_2 + 1;\n          *src_ptr_2 = *dest_ptr;\n          dest_ptr = dest_ptr + 1;\n        } while (3 < temp2);\n        src_index = (remaining_size - 4 & 0xfffffffc) + 4;\n        src = (void *)((int)src + src_index);\n        remaining_size = size & 3;\n        dest_index = (void *)((int)dest_index + src_index);\n      }\n    }\n    size = remaining_size;\n    if (remaining_size != 0) {\nLAB_08009abc:\n      src_ptr = (undefined *)((int)dest_index + -1);\n      src_ptr_2 = (undefined4 *)src;\n      do {\n        dest_ptr = (undefined4 *)((int)src_ptr_2 + 1);\n        src_ptr = src_ptr + 1;\n        *src_ptr = *(undefined *)src_ptr_2;\n        src_ptr_2 = dest_ptr;\n      } while (dest_ptr != (undefined4 *)(size + (int)src));\n      return dest;\n    }\n  }\n  return dest;\n}\n\n",
            "renaming": {
                "FUN_08009a18": "memcpy_reverse_08009a18",
                "__dest": "dest",
                "__src": "src",
                "__n": "size",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr",
                "iVar3": "src_index",
                "pvVar4": "dest_index",
                "puVar5": "dest_end",
                "iVar6": "temp1",
                "uVar7": "temp2",
                "iVar8": "temp3",
                "uVar9": "remaining_size",
                "puVar10": "src_ptr_2"
            },
            "calling": [
                "__ssprint_r",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009adc": {
            "entrypoint": "0x08009adc",
            "current_name": "allocate_memory_08009adc",
            "code": "\nint * allocate_memory_08009adc(undefined4 *param_size,int *existing_memory,uint requested_size)\n\n{\n  int *new_memory;\n  int temp_var_1;\n  int *temp_var_2;\n  uint temp_var_3;\n  int temp_var_4;\n  uint temp_var_5;\n  size_t sVar7;\n  int *piVar8;\n  uint aligned_size;\n  uint existing_size;\n  uint combined_size;\n  int combined_memory;\n  \n  if (existing_memory == (int *)0x0) {\n    temp_var_2 = (int *)_malloc_r(param_size,requested_size);\n    return temp_var_2;\n  }\n  __malloc_lock();\n  temp_var_5 = existing_memory[-1];\n  existing_size = temp_var_5 & 0xfffffffc;\n  temp_var_2 = existing_memory + -2;\n  if (requested_size + 0xb < 0x17) {\n    aligned_size = 0x10;\n  }\n  else {\n    aligned_size = requested_size + 0xb & 0xfffffff8;\n    if ((int)aligned_size < 0) goto LAB_08009b8e;\n  }\n  if (aligned_size < requested_size) {\nLAB_08009b8e:\n    *param_size = 0xc;\n    return (int *)0x0;\n  }\n  combined_memory = (int)temp_var_2 + existing_size;\n  combined_size = existing_size;\n  if ((int)existing_size < (int)aligned_size) {\n    if (DAT_20000454 == combined_memory) {\n      combined_memory = (*(uint *)(DAT_20000454 + 4) & 0xfffffffc) + existing_size;\n      if ((int)(aligned_size + 0x10) <= combined_memory) {\n        DAT_20000454 = (int)temp_var_2 + aligned_size;\n        *(uint *)(DAT_20000454 + 4) = combined_memory - aligned_size | 1;\n        existing_memory[-1] = aligned_size | existing_memory[-1] & 1U;\n        __malloc_unlock(param_size);\n        return existing_memory;\n      }\n      if (-1 < (int)(temp_var_5 << 0x1f)) {\n        new_memory = (int *)((int)temp_var_2 - existing_memory[-2]);\n        temp_var_5 = new_memory[1] & 0xfffffffc;\n        if ((int)(aligned_size + 0x10) <= (int)(combined_memory + temp_var_5)) {\n          temp_var_4 = new_memory[3];\n          temp_var_2 = new_memory + 2;\n          temp_var_1 = *temp_var_2;\n          sVar7 = existing_size - 4;\n          *(int *)(temp_var_1 + 0xc) = temp_var_4;\n          *(int *)(temp_var_4 + 8) = temp_var_1;\n          if (sVar7 < 0x25) {\n            temp_var_1 = *existing_memory;\n            piVar8 = temp_var_2;\n            if (0x13 < sVar7) {\n              new_memory[2] = temp_var_1;\n              new_memory[3] = existing_memory[1];\n              temp_var_1 = existing_memory[2];\n              if (sVar7 < 0x1c) {\n                existing_memory = existing_memory + 2;\n                piVar8 = new_memory + 4;\n              }\n              else {\n                new_memory[4] = temp_var_1;\n                new_memory[5] = existing_memory[3];\n                temp_var_1 = existing_memory[4];\n                if (sVar7 == 0x24) {\n                  new_memory[6] = temp_var_1;\n                  new_memory[7] = existing_memory[5];\n                  temp_var_1 = existing_memory[6];\n                  existing_memory = existing_memory + 6;\n                  piVar8 = new_memory + 8;\n                }\n                else {\n                  existing_memory = existing_memory + 4;\n                  piVar8 = new_memory + 6;\n                }\n              }\n            }\n            *piVar8 = temp_var_1;\n            piVar8[1] = existing_memory[1];\n            piVar8[2] = existing_memory[2];\n          }\n          else {\n            memmove(temp_var_2,existing_memory,sVar7);\n          }\n          DAT_20000454 = (int)new_memory + aligned_size;\n          *(uint *)(DAT_20000454 + 4) = (combined_memory + temp_var_5) - aligned_size | 1;\n          new_memory[1] = aligned_size | new_memory[1] & 1U;\n          __malloc_unlock(param_size);\n          return temp_var_2;\n        }\nLAB_08009bb0:\n        combined_size = existing_size + temp_var_5;\n        if ((int)aligned_size <= (int)combined_size) {\n          temp_var_4 = new_memory[3];\n          piVar8 = new_memory + 2;\n          temp_var_1 = *piVar8;\n          *(int *)(temp_var_1 + 0xc) = temp_var_4;\n          combined_memory = (int)new_memory + combined_size;\n          *(int *)(temp_var_4 + 8) = temp_var_1;\n          temp_var_2 = new_memory;\n          if (existing_size - 4 < 0x25) goto LAB_08009bd0;\nLAB_08009d4c:\n          memmove(piVar8,existing_memory,existing_size - 4);\n          existing_memory = piVar8;\n          goto LAB_08009c00;\n        }\n      }\n    }\n    else {\n      if (-1 < *(int *)((*(uint *)(combined_memory + 4) & 0xfffffffe) + combined_memory + 4) << 0x1f) {\n        temp_var_3 = *(uint *)(combined_memory + 4) & 0xfffffffc;\n        combined_size = existing_size + temp_var_3;\n        if ((int)combined_size < (int)aligned_size) {\n          if ((int)(temp_var_5 << 0x1f) < 0) goto LAB_08009b36;\n          new_memory = (int *)((int)temp_var_2 - existing_memory[-2]);\n          temp_var_5 = new_memory[1] & 0xfffffffc;\n          combined_size = temp_var_3 + temp_var_5 + existing_size;\n          if ((int)combined_size < (int)aligned_size) goto LAB_08009bb0;\n          temp_var_1 = *(int *)(combined_memory + 8);\n          combined_memory = *(int *)(combined_memory + 0xc);\n          *(int *)(temp_var_1 + 0xc) = combined_memory;\n          *(int *)(combined_memory + 8) = temp_var_1;\n          piVar8 = new_memory + 2;\n          temp_var_1 = *piVar8;\n          temp_var_4 = new_memory[3];\n          *(int *)(temp_var_1 + 0xc) = temp_var_4;\n          combined_memory = (int)new_memory + combined_size;\n          *(int *)(temp_var_4 + 8) = temp_var_1;\n          temp_var_2 = new_memory;\n          if (0x24 < existing_size - 4) goto LAB_08009d4c;\nLAB_08009bd0:\n          existing_size = existing_size - 4;\n          temp_var_1 = *existing_memory;\n          new_memory = piVar8;\n          if (0x13 < existing_size) {\n            temp_var_2[2] = temp_var_1;\n            temp_var_2[3] = existing_memory[1];\n            temp_var_1 = existing_memory[2];\n            if (existing_size < 0x1c) {\n              existing_memory = existing_memory + 2;\n              new_memory = temp_var_2 + 4;\n            }\n            else {\n              temp_var_2[4] = temp_var_1;\n              temp_var_2[5] = existing_memory[3];\n              temp_var_1 = existing_memory[4];\n              if (existing_size == 0x24) {\n                temp_var_2[6] = temp_var_1;\n                temp_var_2[7] = existing_memory[5];\n                temp_var_1 = existing_memory[6];\n                existing_memory = existing_memory + 6;\n                new_memory = temp_var_2 + 8;\n              }\n              else {\n                existing_memory = existing_memory + 4;\n                new_memory = temp_var_2 + 6;\n              }\n            }\n          }\n          *new_memory = temp_var_1;\n          new_memory[1] = existing_memory[1];\n          new_memory[2] = existing_memory[2];\n          existing_memory = piVar8;\n        }\n        else {\n          temp_var_1 = *(int *)(combined_memory + 8);\n          temp_var_4 = *(int *)(combined_memory + 0xc);\n          *(int *)(temp_var_1 + 0xc) = temp_var_4;\n          combined_memory = (int)temp_var_2 + combined_size;\n          *(int *)(temp_var_4 + 8) = temp_var_1;\n        }\n        goto LAB_08009c00;\n      }\n      if (-1 < (int)(temp_var_5 << 0x1f)) {\n        new_memory = (int *)((int)temp_var_2 - existing_memory[-2]);\n        temp_var_5 = new_memory[1] & 0xfffffffc;\n        goto LAB_08009bb0;\n      }\n    }\nLAB_08009b36:\n    new_memory = (int *)_malloc_r(param_size,requested_size);\n    if (new_memory != (int *)0x0) {\n      if ((int *)((existing_memory[-1] & 0xfffffffeU) + (int)temp_var_2) == new_memory + -2) {\n        combined_size = existing_size + (new_memory[-1] & 0xfffffffcU);\n        combined_memory = (int)temp_var_2 + combined_size;\n        goto LAB_08009c00;\n      }\n      sVar7 = existing_size - 4;\n      if (sVar7 < 0x25) {\n        combined_memory = *existing_memory;\n        temp_var_2 = existing_memory;\n        piVar8 = new_memory;\n        if (0x13 < sVar7) {\n          *new_memory = combined_memory;\n          new_memory[1] = existing_memory[1];\n          if (sVar7 < 0x1c) {\n            combined_memory = existing_memory[2];\n            temp_var_2 = existing_memory + 2;\n            piVar8 = new_memory + 2;\n          }\n          else {\n            new_memory[2] = existing_memory[2];\n            new_memory[3] = existing_memory[3];\n            if (sVar7 == 0x24) {\n              new_memory[4] = existing_memory[4];\n              new_memory[5] = existing_memory[5];\n              combined_memory = existing_memory[6];\n              temp_var_2 = existing_memory + 6;\n              piVar8 = new_memory + 6;\n            }\n            else {\n              combined_memory = existing_memory[4];\n              temp_var_2 = existing_memory + 4;\n              piVar8 = new_memory + 4;\n            }\n          }\n        }\n        *piVar8 = combined_memory;\n        piVar8[1] = temp_var_2[1];\n        piVar8[2] = temp_var_2[2];\n      }\n      else {\n        memmove(new_memory,existing_memory,sVar7);\n      }\n      _free_r(param_size,existing_memory);\n    }\n    __malloc_unlock(param_size);\n    existing_memory = new_memory;\n  }\n  else {\nLAB_08009c00:\n    if (combined_size - aligned_size < 0x10) {\n      temp_var_2[1] = temp_var_2[1] & 1U | combined_size;\n      *(uint *)(combined_memory + 4) = *(uint *)(combined_memory + 4) | 1;\n    }\n    else {\n      temp_var_2[1] = temp_var_2[1] & 1U | aligned_size;\n      *(uint *)((int)temp_var_2 + aligned_size + 4) = combined_size - aligned_size | 1;\n      *(uint *)(combined_memory + 4) = *(uint *)(combined_memory + 4) | 1;\n      _free_r(param_size,(int)temp_var_2 + aligned_size + 8);\n    }\n    __malloc_unlock(param_size);\n  }\n  return existing_memory;\n}\n\n",
            "renaming": {
                "FUN_08009adc": "allocate_memory_08009adc",
                "param_1": "param_size",
                "param_2": "existing_memory",
                "param_3": "requested_size",
                "piVar1": "new_memory",
                "iVar2": "temp_var_1",
                "piVar3": "temp_var_2",
                "uVar4": "temp_var_3",
                "iVar5": "temp_var_4",
                "uVar6": "temp_var_5",
                "uVar9": "aligned_size",
                "uVar10": "existing_size",
                "uVar11": "combined_size",
                "iVar12": "combined_memory"
            },
            "calling": [
                "__ssprint_r"
            ],
            "called": [
                "_malloc_r",
                "memmove",
                "_free_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e50": {
            "entrypoint": "0x08009e50",
            "current_name": "validate_and_assign_value_08009e50",
            "code": "\nundefined * validate_and_assign_value_08009e50(undefined4 *output_value,undefined *buffer_address,uint input_value)\n\n{\n  if (buffer_address != (undefined *)0x0) {\n    if (input_value < 0x100) {\n      *buffer_address = (char)input_value;\n      buffer_address = (undefined *)0x1;\n    }\n    else {\n      buffer_address = (undefined *)0xffffffff;\n      *output_value = 0x8a;\n    }\n  }\n  return buffer_address;\n}\n\n",
            "renaming": {
                "FUN_08009e50": "validate_and_assign_value_08009e50",
                "param_1": "output_value",
                "param_2": "buffer_address",
                "param_3": "input_value"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e68": {
            "entrypoint": "0x08009e68",
            "current_name": "get_evp_key_context_address_08009e68",
            "code": "\nint getEVPKeyContextAddress_08009e68(EVP_PKEY_CTX *context)\n\n{\n  return (int)context;\n}\n\n",
            "renaming": {
                "FUN_08009e68": "get_evp_key_context_address_08009e68",
                "ctx": "context"
            },
            "calling": [
                "__do_global_dtors_aux",
                "__libc_init_array",
                "frame_dummy"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e74": {
            "entrypoint": "0x08009e74",
            "current_name": "FUNC_08009e74",
            "code": "\nvoid FUNC_08009e74(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e74": "FUNC_08009e74"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 165536,
    "layers": [
        [
            "FUN_08000110",
            "FUN_08000134",
            "FUN_08000150",
            "FUN_08000158",
            "FUN_0800015c",
            "FUN_080003d4",
            "FUN_080003f4",
            "FUN_08000418",
            "FUN_0800045c",
            "FUN_0800046c",
            "FUN_080006a4",
            "FUN_0800088a",
            "FUN_080008ec",
            "FUN_080008f4",
            "FUN_080008fc",
            "FUN_08000978",
            "FUN_08000988",
            "FUN_08000998",
            "FUN_080009ac",
            "FUN_080009c0",
            "FUN_080009d4",
            "FUN_080009e8",
            "FUN_080009fc",
            "FUN_08000a9c",
            "FUN_08000aa4",
            "FUN_08000aa8",
            "FUN_08000c08",
            "FUN_08000c10",
            "FUN_08000c2c",
            "FUN_08000c3c",
            "FUN_08000cb8",
            "FUN_08000e20",
            "FUN_08000f58",
            "FUN_08000f60",
            "FUN_08000f68",
            "FUN_08000fc8",
            "FUN_08000fd0",
            "FUN_08000fe0",
            "FUN_08000ff4",
            "FUN_08001008",
            "FUN_0800101c",
            "FUN_08001030",
            "FUN_08001044",
            "FUN_08001084",
            "FUN_08001170",
            "FUN_0800119c",
            "FUN_080011ec",
            "FUN_0800121c",
            "FUN_080014f0",
            "FUN_0800151c",
            "FUN_0800157c",
            "FUN_080015a0",
            "FUN_080015b4",
            "FUN_080015fc",
            "FUN_08001618",
            "FUN_0800166c",
            "FUN_080016d0",
            "FUN_08001714",
            "FUN_0800172a",
            "FUN_08001762",
            "FUN_0800177c",
            "FUN_080017b4",
            "FUN_080017c4",
            "FUN_08001a80",
            "FUN_08001ab0",
            "FUN_08001cb8",
            "FUN_08001ccc",
            "FUN_08001f6c",
            "FUN_08002640",
            "FUN_080027f4",
            "FUN_08002ad8",
            "FUN_08002bb4",
            "FUN_08002c2e",
            "FUN_08002ca8",
            "FUN_08002d3c",
            "FUN_08002d98",
            "FUN_08003260",
            "FUN_08003440",
            "FUN_08003504",
            "FUN_08003518",
            "FUN_08003540",
            "FUN_08003568",
            "FUN_080035a4",
            "FUN_080035fa",
            "FUN_0800360c",
            "FUN_08003640",
            "FUN_08003696",
            "FUN_080036a8",
            "FUN_080036f8",
            "FUN_08003908",
            "FUN_08003a94",
            "FUN_08003c4a",
            "FUN_08003c5c",
            "FUN_08003c6e",
            "FUN_08003c80",
            "FUN_08003c94",
            "FUN_08003d60",
            "FUN_08003e38",
            "FUN_08003f18",
            "FUN_08003ff8",
            "FUN_080040a0",
            "FUN_08004104",
            "FUN_0800416a",
            "FUN_080041a8",
            "FUN_080041ea",
            "FUN_0800422e",
            "FUN_080042de",
            "FUN_08004366",
            "FUN_08004378",
            "FUN_0800438a",
            "FUN_08004424",
            "FUN_08004436",
            "FUN_080046ec",
            "FUN_0800491c",
            "FUN_080049cc",
            "FUN_08004ae0",
            "FUN_08004bd8",
            "FUN_08004d78",
            "FUN_08004e6c",
            "FUN_08004e74",
            "FUN_08004ea4",
            "FUN_08004ee8",
            "FUN_08004f2c",
            "FUN_08004f3c",
            "FUN_08004f60",
            "FUN_08004f78",
            "FUN_08005224",
            "FUN_080052a0",
            "FUN_08005348",
            "FUN_080053b0",
            "FUN_08005500",
            "FUN_08005598",
            "FUN_080055f4",
            "FUN_08005674",
            "FUN_08005680",
            "FUN_080056c8",
            "FUN_080056ce",
            "FUN_080056d4",
            "FUN_080056da",
            "FUN_08005704",
            "FUN_08005714",
            "FUN_08005728",
            "FUN_08005780",
            "FUN_080057e8",
            "FUN_08005830",
            "FUN_08005838",
            "FUN_080059f0",
            "FUN_08005d0c",
            "FUN_08005d14",
            "FUN_08005d20",
            "FUN_08005d68",
            "FUN_08005dfc",
            "FUN_08005e40",
            "FUN_080078b4",
            "FUN_080078c0",
            "FUN_080079e8",
            "FUN_08008818",
            "FUN_0800884c",
            "FUN_080088ec",
            "FUN_08008ad4",
            "FUN_08008af8",
            "FUN_0800901c",
            "FUN_080090a8",
            "FUN_080090b4",
            "FUN_080090c0",
            "FUN_0800910c",
            "FUN_08009120",
            "FUN_080091a4",
            "FUN_080091e4",
            "FUN_08009244",
            "FUN_08009258",
            "FUN_080093a4",
            "FUN_08009444",
            "FUN_080094f8",
            "FUN_08009530",
            "FUN_08009630",
            "FUN_080096e0",
            "FUN_08009744",
            "FUN_08009768",
            "FUN_080097cc",
            "FUN_080098c0",
            "FUN_08009980",
            "FUN_080099ec",
            "FUN_08009a18",
            "FUN_08009adc",
            "FUN_08009e50",
            "FUN_08009e68"
        ],
        [
            "FUN_080004c8",
            "FUN_0800071c"
        ]
    ],
    "locked_functions": []
}