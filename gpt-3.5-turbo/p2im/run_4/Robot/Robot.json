{
    "functions": {
        "FUN_08000110": {
            "entrypoint": "0x08000110",
            "current_name": "initialize_flag_08000110",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800011c) */\n\nundefined4 initializeFlag_08000110(undefined4 input)\n\n{\n  if ((char)DAT_200009c8 == '\\0') {\n    DAT_200009c8._0_1_ = '\\x01';\n  }\n  return input;\n}\n\n",
            "renaming": {
                "FUN_08000110": "initialize_flag_08000110",
                "param_1": "input"
            },
            "calling": [],
            "called": [
                "FUN_08009e68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000134": {
            "entrypoint": "0x08000134",
            "current_name": "concatenate_integers_08000134",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800013a) */\n\nundefined8 concatenate_integers_08000134(undefined4 integer1,undefined4 integer2)\n\n{\n  return CONCAT44(integer2,integer1);\n}\n\n",
            "renaming": {
                "FUN_08000134": "concatenate_integers_08000134",
                "param_1": "integer1",
                "param_2": "integer2"
            },
            "calling": [
                "FUN_08005d20"
            ],
            "called": [
                "FUN_08009e68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000158": {
            "entrypoint": "0x08000158",
            "current_name": "perform_arithmetic_operation_08000158",
            "code": "\nulonglong performArithmeticOperation_08000158(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int shiftCountVar1;\n  byte carryBit;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  int shiftCountVar2;\n  uint resultLsf;\n  uint temp6;\n  uint temp7;\n  uint temp8;\n  bool checkCondition1;\n  bool checkCondition2;\n  bool checkCondition3;\n  \n  temp4 = input4 ^ 0x80000000;\n  resultLsf = input2 << 1;\n  input4 = input4 << 1;\n  checkCondition1 = ((input2 ^ temp4) & 0x7fffffff) == 0;\n  checkCondition2 = checkCondition1 && input1 == input3;\n  if (!checkCondition1 || input1 != input3) {\n    checkCondition2 = (resultLsf | input1) == 0;\n  }\n  if (!checkCondition2) {\n    checkCondition2 = (input4 | input3) == 0;\n  }\n  shiftCountVar2 = (int)resultLsf >> 0x15;\n  if (!checkCondition2) {\n    checkCondition2 = shiftCountVar2 == -1;\n  }\n  shiftCountVar1 = (int)input4 >> 0x15;\n  if (!checkCondition2) {\n    checkCondition2 = shiftCountVar1 == -1;\n  }\n  if (checkCondition2) {\n    if (shiftCountVar2 == -1 || shiftCountVar1 == -1) {\n      resultLsf = temp4;\n      temp7 = input3;\n      if (shiftCountVar2 == -1) {\n        resultLsf = input2;\n        temp7 = input1;\n      }\n      if (shiftCountVar2 != -1 || shiftCountVar1 != -1) {\n        input3 = temp7;\n        temp4 = resultLsf;\n      }\n      checkCondition2 = (temp7 | resultLsf << 0xc) == 0;\n      if (checkCondition2) {\n        checkCondition2 = (input3 | temp4 << 0xc) == 0;\n      }\n      if (checkCondition2) {\n        checkCondition2 = resultLsf == temp4;\n      }\n      if (!checkCondition2) {\n        resultLsf = resultLsf | 0x80000;\n      }\n      return CONCAT44(resultLsf,temp7);\n    }\n    if (((input2 ^ temp4) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((resultLsf | input1) == 0) {\n        input1 = input3;\n        input2 = temp4;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != temp4) {\n      return 0;\n    }\n    if (resultLsf >> 0x15 == 0) {\n      checkCondition2 = (input1 & 0x80000000) != 0;\n      temp4 = input2 * 2 + (uint)checkCondition2;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)checkCondition2)) {\n        temp4 = temp4 | 0x80000000;\n      }\n      return CONCAT44(temp4,input1 << 1);\n    }\n    if (resultLsf < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  resultLsf = resultLsf >> 0x15;\n  input4 = input4 >> 0x15;\n  temp7 = input4 - resultLsf;\n  checkCondition2 = temp7 != 0;\n  if (input4 < resultLsf) {\n    temp7 = -temp7;\n  }\n  temp6 = input1;\n  temp5 = input2;\n  if (checkCondition2 && resultLsf <= input4) {\n    resultLsf = resultLsf + temp7;\n    temp6 = input3;\n    temp5 = temp4;\n    input3 = input1;\n    temp4 = input2;\n  }\n  if (0x36 < temp7) {\n    return CONCAT44(temp5,temp6);\n  }\n  temp2 = temp5 & 0xfffff | 0x100000;\n  if ((temp5 & 0x80000000) != 0) {\n    checkCondition2 = temp6 != 0;\n    temp6 = -temp6;\n    temp2 = -temp2 - (uint)checkCondition2;\n  }\n  temp5 = temp4 & 0xfffff | 0x100000;\n  if ((temp4 & 0x80000000) != 0) {\n    checkCondition2 = input3 != 0;\n    input3 = -input3;\n    temp5 = -temp5 - (uint)checkCondition2;\n  }\n  if (resultLsf == temp7) {\n    temp5 = temp5 ^ 0x100000;\n    if (resultLsf == 0) {\n      temp2 = temp2 ^ 0x100000;\n      resultLsf = 1;\n    }\n    else {\n      temp7 = temp7 - 1;\n    }\n  }\n  temp4 = -temp7 + 0x20;\n  if ((int)temp7 < 0x21) {\n    temp8 = input3 << (temp4 & 0xff);\n    input3 = input3 >> (temp7 & 0xff);\n    temp1 = temp6 + input3;\n    temp3 = temp5 << (temp4 & 0xff);\n    temp4 = temp1 + temp3;\n    temp2 = temp2 + CARRY4(temp6,input3) + ((int)temp5 >> (temp7 & 0xff)) +\n            (uint)CARRY4(temp1,temp3);\n  }\n  else {\n    temp8 = temp5 << (-temp7 + 0x40 & 0xff);\n    if (input3 != 0) {\n      temp8 = temp8 | 2;\n    }\n    temp5 = (int)temp5 >> (temp7 - 0x20 & 0xff);\n    temp4 = temp6 + temp5;\n    temp2 = temp2 + ((int)temp5 >> 0x1f) + (uint)CARRY4(temp6,temp5);\n  }\n  input2 = temp2 & 0x80000000;\n  temp7 = temp2;\n  if ((int)temp2 < 0) {\n    checkCondition2 = temp8 == 0;\n    temp8 = -temp8;\n    temp7 = -temp4;\n    temp4 = -(uint)!checkCondition2 - temp4;\n    temp7 = -(uint)(checkCondition2 <= temp7) - temp2;\n  }\n  if (0xfffff < temp7) {\n    temp6 = resultLsf - 1;\n    if (0x1fffff < temp7) {\n      temp6 = temp7 & 1;\n      temp7 = temp7 >> 1;\n      carryBit = (byte)temp4;\n      temp4 = (uint)(temp6 != 0) << 0x1f | temp4 >> 1;\n      temp8 = (uint)(carryBit & 1) << 0x1f | temp8 >> 1;\n      temp6 = resultLsf;\n      if (0xffbfffff < resultLsf * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    checkCondition2 = 0x7fffffff < temp8;\n    if (temp8 == 0x80000000) {\n      checkCondition2 = (temp4 & 1) != 0;\n    }\n    return CONCAT44(temp7 + temp6 * 0x100000 + (uint)CARRY4(temp4,(uint)checkCondition2) | input2,\n                    temp4 + checkCondition2);\n  }\n  checkCondition1 = (temp8 & 0x80000000) != 0;\n  temp8 = temp8 << 1;\n  temp6 = temp4 * 2;\n  checkCondition2 = CARRY4(temp4,temp4);\n  temp4 = temp4 * 2 + (uint)checkCondition1;\n  temp7 = temp7 * 2 + (uint)(checkCondition2 || CARRY4(temp6,(uint)checkCondition1));\n  temp6 = resultLsf - 2;\n  if ((temp7 & 0x100000) != 0) goto LAB_08000268;\n  temp5 = temp4;\n  resultLsf = temp7;\n  if (temp7 == 0) {\n    temp5 = 0;\n    resultLsf = temp4;\n  }\n  shiftCountVar2 = LZCOUNT(resultLsf);\n  if (temp7 == 0) {\n    shiftCountVar2 = shiftCountVar2 + 0x20;\n  }\n  temp7 = shiftCountVar2 - 0xb;\n  checkCondition3 = SBORROW4(temp7,0x20);\n  temp4 = shiftCountVar2 - 0x2b;\n  checkCondition2 = (int)temp4 < 0;\n  checkCondition1 = temp4 == 0;\n  if ((int)temp7 < 0x20) {\n    checkCondition3 = SCARRY4(temp4,0xc);\n    shiftCountVar2 = shiftCountVar2 + -0x1f;\n    checkCondition2 = shiftCountVar2 < 0;\n    checkCondition1 = shiftCountVar2 == 0;\n    temp4 = temp7;\n    if (!checkCondition1 && checkCondition2 == checkCondition3) {\n      temp5 = resultLsf << (temp7 & 0xff);\n      resultLsf = resultLsf >> (0xcU - shiftCountVar2 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (checkCondition1 || checkCondition2 != checkCondition3) {\n    temp8 = 0x20 - temp4;\n  }\n  resultLsf = resultLsf << (temp4 & 0xff);\n  if (checkCondition1 || checkCondition2 != checkCondition3) {\n    resultLsf = resultLsf | temp5 >> (temp8 & 0xff);\n  }\n  if (checkCondition1 || checkCondition2 != checkCondition3) {\n    temp5 = temp5 << (temp4 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)temp7 <= (int)temp6) {\n    return CONCAT44(resultLsf + (temp6 - temp7) * 0x100000 | input2,temp5);\n  }\n  temp4 = ~(temp6 - temp7);\n  if ((int)temp4 < 0x1f) {\n    shiftCountVar2 = temp4 - 0x13;\n    if (shiftCountVar2 != 0 && shiftCountVar2 < 0 == SCARRY4(temp4 - 0x1f,0xc)) {\n      return CONCAT44(temp2,temp5 >> (0x20 - (0xcU - shiftCountVar2) & 0xff) | resultLsf << (0xcU - shiftCountVar2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    temp4 = temp4 + 1;\n    return CONCAT44(input2 | resultLsf >> (temp4 & 0xff),\n                    temp5 >> (temp4 & 0xff) | resultLsf << (0x20 - temp4 & 0xff));\n  }\n  return CONCAT44(temp2,resultLsf >> (temp4 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000158": "perform_arithmetic_operation_08000158",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shiftCountVar1",
                "bVar2": "carryBit",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "uVar6": "temp4",
                "uVar7": "temp5",
                "iVar8": "shiftCountVar2",
                "uVar9": "resultLsf",
                "uVar10": "temp6",
                "uVar11": "temp7",
                "uVar12": "temp8",
                "bVar13": "checkCondition1",
                "bVar14": "checkCondition2",
                "bVar15": "checkCondition3"
            },
            "calling": [
                "FUN_080059f0",
                "FUN_08004bd8",
                "FUN_08005e9c",
                "FUN_08005838",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800015c": {
            "entrypoint": "0x0800015c",
            "current_name": "perform_unsigned_division_0800015c",
            "code": "\nulonglong performUnsignedDivision_0800015c(uint dividend,uint divisor1,uint dividend2,uint divisor2)\n\n{\n  int shift1;\n  byte carryFlag;\n  uint quotient1;\n  uint quotient2;\n  uint temp1;\n  int shift2;\n  uint divisor1Shifted;\n  uint divisor2Shifted;\n  uint dividend1Shifted;\n  uint dividend2Shifted;\n  uint temp2;\n  uint temp3;\n  bool resultFlag1;\n  bool resultFlag2;\n  bool borrowFlag;\n  \n  divisor1Shifted = divisor1 << 1;\n  dividend1Shifted = divisor2 << 1;\n  resultFlag1 = ((divisor1 ^ divisor2) & 0x7fffffff) == 0;\n  resultFlag2 = resultFlag1 && dividend == dividend2;\n  if (!resultFlag1 || dividend != dividend2) {\n    resultFlag2 = (divisor1Shifted | dividend) == 0;\n  }\n  if (!resultFlag2) {\n    resultFlag2 = (dividend1Shifted | dividend2) == 0;\n  }\n  shift2 = (int)divisor1Shifted >> 0x15;\n  if (!resultFlag2) {\n    resultFlag2 = shift2 == -1;\n  }\n  shift1 = (int)dividend1Shifted >> 0x15;\n  if (!resultFlag2) {\n    resultFlag2 = shift1 == -1;\n  }\n  if (resultFlag2) {\n    if (shift2 == -1 || shift1 == -1) {\n      dividend1Shifted = divisor2;\n      divisor1Shifted = dividend2;\n      if (shift2 == -1) {\n        dividend1Shifted = divisor1;\n        divisor1Shifted = dividend;\n      }\n      if (shift2 != -1 || shift1 != -1) {\n        dividend2 = divisor1Shifted;\n        divisor2 = dividend1Shifted;\n      }\n      resultFlag2 = (divisor1Shifted | dividend1Shifted << 0xc) == 0;\n      if (resultFlag2) {\n        resultFlag2 = (dividend2 | divisor2 << 0xc) == 0;\n      }\n      if (resultFlag2) {\n        resultFlag2 = dividend1Shifted == divisor2;\n      }\n      if (!resultFlag2) {\n        dividend1Shifted = dividend1Shifted | 0x80000;\n      }\n      return CONCAT44(dividend1Shifted,divisor1Shifted);\n    }\n    if (((divisor1 ^ divisor2) & 0x7fffffff) != 0 || dividend != dividend2) {\n      if ((divisor1Shifted | dividend) == 0) {\n        dividend = dividend2;\n        divisor1 = divisor2;\n      }\n      return CONCAT44(divisor1,dividend);\n    }\n    if (divisor1 != divisor2) {\n      return 0;\n    }\n    if (divisor1Shifted >> 0x15 == 0) {\n      resultFlag2 = (dividend & 0x80000000) != 0;\n      dividend1Shifted = divisor1 * 2 + (uint)resultFlag2;\n      if (CARRY4(divisor1,divisor1) || CARRY4(divisor1 * 2,(uint)resultFlag2)) {\n        dividend1Shifted = dividend1Shifted | 0x80000000;\n      }\n      return CONCAT44(dividend1Shifted,dividend << 1);\n    }\n    if (divisor1Shifted < 0xffc00000) {\n      return CONCAT44(divisor1 + 0x100000,dividend);\n    }\n    divisor1 = divisor1 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(divisor1 | 0x7ff00000) << 0x20;\n  }\n  divisor1Shifted = divisor1Shifted >> 0x15;\n  dividend1Shifted = dividend1Shifted >> 0x15;\n  dividend2Shifted = dividend1Shifted - divisor1Shifted;\n  resultFlag2 = dividend2Shifted != 0;\n  if (dividend1Shifted < divisor1Shifted) {\n    dividend2Shifted = -dividend2Shifted;\n  }\n  divisor2Shifted = dividend;\n  temp1 = divisor1;\n  if (resultFlag2 && divisor1Shifted <= dividend1Shifted) {\n    divisor1Shifted = divisor1Shifted + dividend2Shifted;\n    divisor2Shifted = dividend2;\n    temp1 = divisor2;\n    dividend2 = dividend;\n    divisor2 = divisor1;\n  }\n  if (0x36 < dividend2Shifted) {\n    return CONCAT44(temp1,divisor2Shifted);\n  }\n  dividend1Shifted = temp1 & 0xfffff | 0x100000;\n  if ((temp1 & 0x80000000) != 0) {\n    resultFlag2 = divisor2Shifted != 0;\n    divisor2Shifted = -divisor2Shifted;\n    dividend1Shifted = -dividend1Shifted - (uint)resultFlag2;\n  }\n  temp1 = divisor2 & 0xfffff | 0x100000;\n  if ((divisor2 & 0x80000000) != 0) {\n    resultFlag2 = dividend2 != 0;\n    dividend2 = -dividend2;\n    temp1 = -temp1 - (uint)resultFlag2;\n  }\n  if (divisor1Shifted == dividend2Shifted) {\n    temp1 = temp1 ^ 0x100000;\n    if (divisor1Shifted == 0) {\n      dividend1Shifted = dividend1Shifted ^ 0x100000;\n      divisor1Shifted = 1;\n    }\n    else {\n      dividend2Shifted = dividend2Shifted - 1;\n    }\n  }\n  temp3 = -dividend2Shifted + 0x20;\n  if ((int)dividend2Shifted < 0x21) {\n    temp2 = dividend2 << (temp3 & 0xff);\n    dividend2 = dividend2 >> (dividend2Shifted & 0xff);\n    quotient1 = divisor2Shifted + dividend2;\n    quotient2 = temp1 << (temp3 & 0xff);\n    temp3 = quotient1 + quotient2;\n    dividend1Shifted = dividend1Shifted + CARRY4(divisor2Shifted,dividend2) + ((int)temp1 >> (dividend2Shifted & 0xff)) +\n            (uint)CARRY4(quotient1,quotient2);\n  }\n  else {\n    temp2 = temp1 << (-dividend2Shifted + 0x40 & 0xff);\n    if (dividend2 != 0) {\n      temp2 = temp2 | 2;\n    }\n    temp1 = (int)temp1 >> (dividend2Shifted - 0x20 & 0xff);\n    temp3 = divisor2Shifted + temp1;\n    dividend1Shifted = dividend1Shifted + ((int)temp1 >> 0x1f) + (uint)CARRY4(divisor2Shifted,temp1);\n  }\n  divisor1 = dividend1Shifted & 0x80000000;\n  dividend2Shifted = dividend1Shifted;\n  if ((int)dividend1Shifted < 0) {\n    resultFlag2 = temp2 == 0;\n    temp2 = -temp2;\n    dividend2Shifted = -temp3;\n    temp3 = -(uint)!resultFlag2 - temp3;\n    dividend2Shifted = -(uint)(resultFlag2 <= dividend2Shifted) - dividend1Shifted;\n  }\n  if (0xfffff < dividend2Shifted) {\n    divisor2Shifted = divisor1Shifted - 1;\n    if (0x1fffff < dividend2Shifted) {\n      dividend1Shifted = dividend2Shifted & 1;\n      dividend2Shifted = dividend2Shifted >> 1;\n      carryFlag = (byte)temp3;\n      temp3 = (uint)(dividend1Shifted != 0) << 0x1f | temp3 >> 1;\n      temp2 = (uint)(carryFlag & 1) << 0x1f | temp2 >> 1;\n      divisor2Shifted = divisor1Shifted;\n      if (0xffbfffff < divisor1Shifted * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    resultFlag2 = 0x7fffffff < temp2;\n    if (temp2 == 0x80000000) {\n      resultFlag2 = (temp3 & 1) != 0;\n    }\n    return CONCAT44(dividend2Shifted + divisor2Shifted * 0x100000 + (uint)CARRY4(temp3,(uint)resultFlag2) | divisor1,\n                    temp3 + resultFlag2);\n  }\n  resultFlag1 = (temp2 & 0x80000000) != 0;\n  temp2 = temp2 << 1;\n  divisor2Shifted = temp3 * 2;\n  resultFlag2 = CARRY4(temp3,temp3);\n  temp3 = temp3 * 2 + (uint)resultFlag1;\n  dividend2Shifted = dividend2Shifted * 2 + (uint)(resultFlag2 || CARRY4(divisor2Shifted,(uint)resultFlag1));\n  divisor2Shifted = divisor1Shifted - 2;\n  if ((dividend2Shifted & 0x100000) != 0) goto LAB_08000268;\n  temp1 = temp3;\n  divisor1Shifted = dividend2Shifted;\n  if (dividend2Shifted == 0) {\n    temp1 = 0;\n    divisor1Shifted = temp3;\n  }\n  shift2 = LZCOUNT(divisor1Shifted);\n  if (dividend2Shifted == 0) {\n    shift2 = shift2 + 0x20;\n  }\n  temp3 = shift2 - 0xb;\n  borrowFlag = SBORROW4(temp3,0x20);\n  dividend2Shifted = shift2 - 0x2b;\n  resultFlag2 = (int)dividend2Shifted < 0;\n  resultFlag1 = dividend2Shifted == 0;\n  if ((int)temp3 < 0x20) {\n    borrowFlag = SCARRY4(dividend2Shifted,0xc);\n    shift2 = shift2 + -0x1f;\n    resultFlag2 = shift2 < 0;\n    resultFlag1 = shift2 == 0;\n    dividend2Shifted = temp3;\n    if (!resultFlag1 && resultFlag2 == borrowFlag) {\n      temp1 = divisor1Shifted << (temp3 & 0xff);\n      divisor1Shifted = divisor1Shifted >> (0xcU - shift2 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (resultFlag1 || resultFlag2 != borrowFlag) {\n    temp2 = 0x20 - dividend2Shifted;\n  }\n  divisor1Shifted = divisor1Shifted << (dividend2Shifted & 0xff);\n  if (resultFlag1 || resultFlag2 != borrowFlag) {\n    divisor1Shifted = divisor1Shifted | temp1 >> (temp2 & 0xff);\n  }\n  if (resultFlag1 || resultFlag2 != borrowFlag) {\n    temp1 = temp1 << (dividend2Shifted & 0xff);\n  }\nLAB_080002e0:\n  if ((int)temp3 <= (int)divisor2Shifted) {\n    return CONCAT44(divisor1Shifted + (divisor2Shifted - temp3) * 0x100000 | divisor1,temp1);\n  }\n  dividend2Shifted = ~(divisor2Shifted - temp3);\n  if ((int)dividend2Shifted < 0x1f) {\n    shift2 = dividend2Shifted - 0x13;\n    if (shift2 != 0 && shift2 < 0 == SCARRY4(dividend2Shifted - 0x1f,0xc)) {\n      return CONCAT44(dividend1Shifted,temp1 >> (0x20 - (0xcU - shift2) & 0xff) | divisor1Shifted << (0xcU - shift2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    dividend2Shifted = dividend2Shifted + 1;\n    return CONCAT44(divisor1 | divisor1Shifted >> (dividend2Shifted & 0xff),\n                    temp1 >> (dividend2Shifted & 0xff) | divisor1Shifted << (0x20 - dividend2Shifted & 0xff));\n  }\n  return CONCAT44(dividend1Shifted,divisor1Shifted >> (dividend2Shifted - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800015c": "perform_unsigned_division_0800015c",
                "param_1": "dividend",
                "param_2": "divisor1",
                "param_3": "dividend2",
                "param_4": "divisor2",
                "iVar1": "shift1",
                "bVar2": "carryFlag",
                "uVar3": "quotient1",
                "uVar4": "quotient2",
                "uVar5": "temp1",
                "iVar6": "shift2",
                "uVar7": "divisor1Shifted",
                "uVar8": "divisor2Shifted",
                "uVar9": "dividend1Shifted",
                "uVar10": "dividend2Shifted",
                "uVar11": "temp2",
                "uVar12": "temp3",
                "bVar13": "resultFlag1",
                "bVar14": "resultFlag2",
                "bVar15": "borrowFlag"
            },
            "calling": [
                "FUN_080059f0",
                "FUN_08004bd8",
                "FUN_08005838",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003d4": {
            "entrypoint": "0x080003d4",
            "current_name": "reversed_shift_080003d4",
            "code": "\nulonglong reversed_shift_080003d4(uint input_value)\n\n{\n  uint result;\n  uint shift_amount;\n  int leading_zeros;\n  uint constant;\n  uint remaining_bits;\n  bool is_less_than_zero;\n  bool is_equal_to_zero;\n  bool is_less_than_constant;\n  \n  if (input_value == 0) {\n    return 0;\n  }\n  result = 0;\n  leading_zeros = LZCOUNT(input_value);\n  constant = leading_zeros + 0x15;\n  is_less_than_constant = SBORROW4(constant,0x20);\n  shift_amount = leading_zeros - 0xb;\n  is_less_than_zero = (int)shift_amount < 0;\n  is_equal_to_zero = shift_amount == 0;\n  if (constant < 0x20) {\n    is_less_than_constant = SCARRY4(shift_amount,0xc);\n    is_less_than_zero = false;\n    is_equal_to_zero = leading_zeros + 1 == 0;\n    shift_amount = constant;\n    if (!is_equal_to_zero && is_less_than_constant == false) {\n      result = input_value << constant;\n      input_value = input_value >> (0xcU - (leading_zeros + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_equal_to_zero || is_less_than_zero != is_less_than_constant) {\n    remaining_bits = 0x20 - shift_amount;\n  }\n  input_value = input_value << (shift_amount & 0xff);\n  if (is_equal_to_zero || is_less_than_zero != is_less_than_constant) {\n    input_value = input_value | 0U >> (remaining_bits & 0xff);\n  }\n  if (is_equal_to_zero || is_less_than_zero != is_less_than_constant) {\n    result = 0 << (shift_amount & 0xff);\n  }\nLAB_080002e0:\n  if (constant < 0x433) {\n    return CONCAT44(input_value + (0x432 - constant) * 0x100000,result);\n  }\n  shift_amount = ~(0x432 - constant);\n  if (0x1e < (int)shift_amount) {\n    return (ulonglong)(input_value >> (shift_amount - 0x1f & 0xff));\n  }\n  leading_zeros = shift_amount - 0x13;\n  if (leading_zeros == 0 || leading_zeros < 0 != SCARRY4(shift_amount - 0x1f,0xc)) {\n    shift_amount = shift_amount + 1;\n    return CONCAT44(input_value >> (shift_amount & 0xff),\n                    result >> (shift_amount & 0xff) | input_value << (0x20 - shift_amount & 0xff));\n  }\n  return (ulonglong)(result >> (0x20 - (0xcU - leading_zeros) & 0xff) | input_value << (0xcU - leading_zeros & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080003d4": "reversed_shift_080003d4",
                "param_1": "input_value",
                "uVar1": "result",
                "uVar2": "shift_amount",
                "iVar3": "leading_zeros",
                "uVar4": "constant",
                "in_r12": "remaining_bits",
                "bVar5": "is_less_than_zero",
                "bVar6": "is_equal_to_zero",
                "bVar7": "is_less_than_constant"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003f4": {
            "entrypoint": "0x080003f4",
            "current_name": "calculate_shift_and_mask_080003f4",
            "code": "\nulonglong calculate_shift_and_mask_080003f4(uint input_value)\n\n{\n  uint shift_count;\n  uint abs_input_value;\n  uint shift;\n  int leading_zeros;\n  uint shifted_value;\n  uint sign_extension;\n  uint remaining_bits;\n  bool check1;\n  bool check2;\n  bool check3;\n  \n  if (input_value == 0) {\n    return 0;\n  }\n  sign_extension = input_value & 0x80000000;\n  abs_input_value = input_value;\n  if ((int)sign_extension < 0) {\n    abs_input_value = -input_value;\n  }\n  shift_count = 0;\n  leading_zeros = LZCOUNT(abs_input_value);\n  shifted_value = leading_zeros + 0x15;\n  check3 = SBORROW4(shifted_value,0x20);\n  shift = leading_zeros - 0xb;\n  check1 = (int)shift < 0;\n  check2 = shift == 0;\n  if (shifted_value < 0x20) {\n    check3 = SCARRY4(shift,0xc);\n    check1 = false;\n    check2 = leading_zeros + 1 == 0;\n    shift = shifted_value;\n    if (!check2 && check3 == false) {\n      shift_count = abs_input_value << shifted_value;\n      abs_input_value = abs_input_value >> (0xcU - (leading_zeros + 1) & 0xff);\n      goto final_calculation;\n    }\n  }\n  if (check2 || check1 != check3) {\n    remaining_bits = 0x20 - shift;\n  }\n  abs_input_value = abs_input_value << (shift & 0xff);\n  if (check2 || check1 != check3) {\n    abs_input_value = abs_input_value | 0U >> (remaining_bits & 0xff);\n  }\n  if (check2 || check1 != check3) {\n    shift_count = 0 << (shift & 0xff);\n  }\nfinal_calculation:\n  if (shifted_value < 0x433) {\n    return CONCAT44(abs_input_value + (0x432 - shifted_value) * 0x100000 | sign_extension,shift_count);\n  }\n  shift = ~(0x432 - shifted_value);\n  if (0x1e < (int)shift) {\n    return CONCAT44(input_value,abs_input_value >> (shift - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leading_zeros = shift - 0x13;\n  if (leading_zeros == 0 || leading_zeros < 0 != SCARRY4(shift - 0x1f,0xc)) {\n    shift = shift + 1;\n    return CONCAT44(sign_extension | abs_input_value >> (shift & 0xff),\n                    shift_count >> (shift & 0xff) | abs_input_value << (0x20 - shift & 0xff));\n  }\n  return CONCAT44(input_value,shift_count >> (0x20 - (0xcU - leading_zeros) & 0xff) | abs_input_value << (0xcU - leading_zeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_080003f4": "calculate_shift_and_mask_080003f4",
                "param_1": "input_value",
                "uVar1": "shift_count",
                "uVar2": "abs_input_value",
                "uVar3": "shift",
                "iVar4": "leading_zeros",
                "uVar5": "shifted_value",
                "uVar6": "sign_extension",
                "in_r12": "remaining_bits",
                "bVar7": "check1",
                "bVar8": "check2",
                "bVar9": "check3",
                "LAB_080002e0": "final_calculation"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000418": {
            "entrypoint": "0x08000418",
            "current_name": "reverse_bits_08000418",
            "code": "\nulonglong reverse_bits_08000418(uint input,undefined4 param1,undefined4 param2,uint param3)\n\n{\n  uint msb_bit;\n  uint temp1;\n  uint result;\n  uint shift_count;\n  uint temp2;\n  int offset;\n  uint final_offset;\n  uint remaining_bits;\n  bool is_negative_shift;\n  bool is_equal;\n  bool is_borrow;\n  \n  temp2 = input << 1;\n  is_equal = temp2 == 0;\n  msb_bit = (uint)((input & 0x80000000) != 0) << 0x1f;\n  shift_count = (uint)((int)temp2 >> 3) >> 1;\n  result = msb_bit | shift_count;\n  input = input << 0x1d;\n  if (!is_equal) {\n    param3 = temp2 & 0xff000000;\n    is_equal = param3 == 0;\n  }\n  if (!is_equal) {\n    is_equal = param3 == 0xff000000;\n  }\n  if (!is_equal) {\n    return CONCAT44(result,input) ^ 0x3800000000000000;\n  }\n  if ((temp2 & 0xffffff) == 0) {\n    return CONCAT44(result,input);\n  }\n  if (param3 == 0xff000000) {\n    return CONCAT44(result,input) | 0x8000000000000;\n  }\n  temp1 = input;\n  temp2 = shift_count;\n  if (shift_count == 0) {\n    temp1 = 0;\n    temp2 = input;\n  }\n  offset = LZCOUNT(temp2);\n  if (shift_count == 0) {\n    offset = offset + 0x20;\n  }\n  final_offset = offset - 0xb;\n  is_borrow = SBORROW4(final_offset,0x20);\n  shift_count = offset - 0x2b;\n  is_equal = (int)shift_count < 0;\n  is_negative_shift = shift_count == 0;\n  if ((int)final_offset < 0x20) {\n    is_borrow = SCARRY4(shift_count,0xc);\n    offset = offset + -0x1f;\n    is_equal = offset < 0;\n    is_negative_shift = offset == 0;\n    shift_count = final_offset;\n    if (!is_negative_shift && is_equal == is_borrow) {\n      temp1 = temp2 << (final_offset & 0xff);\n      temp2 = temp2 >> (0xcU - offset & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_negative_shift || is_equal != is_borrow) {\n    remaining_bits = 0x20 - shift_count;\n  }\n  temp2 = temp2 << (shift_count & 0xff);\n  if (is_negative_shift || is_equal != is_borrow) {\n    temp2 = temp2 | temp1 >> (remaining_bits & 0xff);\n  }\n  if (is_negative_shift || is_equal != is_borrow) {\n    temp1 = temp1 << (shift_count & 0xff);\n  }\nLAB_080002e0:\n  if ((int)final_offset < 0x381) {\n    return CONCAT44(temp2 + (0x380 - final_offset) * 0x100000 | msb_bit,temp1);\n  }\n  shift_count = ~(0x380 - final_offset);\n  if (0x1e < (int)shift_count) {\n    return CONCAT44(result,temp2 >> (shift_count - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  offset = shift_count - 0x13;\n  if (offset == 0 || offset < 0 != SCARRY4(shift_count - 0x1f,0xc)) {\n    shift_count = shift_count + 1;\n    return CONCAT44(msb_bit | temp2 >> (shift_count & 0xff),\n                    temp1 >> (shift_count & 0xff) | temp2 << (0x20 - shift_count & 0xff));\n  }\n  return CONCAT44(result,temp1 >> (0x20 - (0xcU - offset) & 0xff) | temp2 << (0xcU - offset & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000418": "reverse_bits_08000418",
                "param_1": "input",
                "param_2": "param1",
                "param_3": "param2",
                "param_4": "param3",
                "uVar1": "msb_bit",
                "uVar2": "temp1",
                "uVar3": "result",
                "uVar4": "shift_count",
                "uVar5": "temp2",
                "iVar6": "offset",
                "uVar7": "final_offset",
                "in_r12": "remaining_bits",
                "bVar8": "is_negative_shift",
                "bVar9": "is_equal",
                "bVar10": "is_borrow"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_08004bd8",
                "FUN_08004d78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004c8": {
            "entrypoint": "0x080004c8",
            "current_name": "calculate_bitwise_difference_080004c8",
            "code": "\nulonglong calculate_bitwise_difference_080004c8(undefined4 input_param1,uint input_param2,uint input_param3,uint input_param4)\n\n{\n  ulonglong result1;\n  longlong result2;\n  uint temp1;\n  uint temp2;\n  int temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  ulonglong temp8;\n  \n  temp8 = CONCAT44(input_param2,input_param1);\n  temp6 = 0x7ff;\n  temp2 = input_param2 >> 0x14 & 0x7ff;\n  flag1 = temp2 == 0;\n  if (!flag1) {\n    temp5 = input_param4 >> 0x14 & 0x7ff;\n    flag1 = temp5 == 0;\n  }\n  if (!flag1) {\n    flag1 = temp2 == 0x7ff;\n  }\n  if (!flag1) {\n    flag1 = temp5 == 0x7ff;\n  }\n  if (flag1) {\n    temp8 = calculate_bitwise_difference_080004c8_080006a4();\n  }\n  temp1 = (uint)(temp8 >> 0x20);\n  temp3 = temp2 + temp5;\n  temp2 = temp1 ^ input_param4;\n  temp1 = temp1 & ~(temp6 << 0x15);\n  input_param4 = input_param4 & ~(temp6 << 0x15);\n  flag1 = ((uint)temp8 | temp1 << 0xc) == 0;\n  if (!flag1) {\n    flag1 = (input_param3 | input_param4 << 0xc) == 0;\n  }\n  temp1 = temp1 | 0x100000;\n  input_param4 = input_param4 | 0x100000;\n  if (flag1) {\n    input_param3 = (uint)temp8 | input_param3;\n    input_param4 = (temp2 & 0x80000000 | temp1) ^ input_param4;\n    temp2 = temp6 >> 1;\n    flag3 = SBORROW4(temp3,temp2);\n    temp4 = temp3 - temp2;\n    flag1 = temp4 == 0;\n    temp1 = temp4;\n    if (!flag1 && (int)temp2 <= temp3) {\n      flag3 = SBORROW4(temp6,temp4);\n      temp1 = temp6 - temp4;\n      flag1 = temp6 == temp4;\n    }\n    if (!flag1 && (int)temp1 < 0 == flag3) {\n      input_param4 = input_param4 | temp4 * 0x100000;\n    }\n    if (!flag1 && (int)temp1 < 0 == flag3) {\n      return CONCAT44(input_param4,input_param3);\n    }\n    input_param4 = input_param4 | 0x100000;\n    temp6 = 0;\n    flag3 = SBORROW4(temp4,1);\n    temp4 = temp4 - 1;\n    flag1 = temp4 == 0;\n    temp2 = temp4;\n  }\n  else {\n    result1 = (temp8 & 0xffffffff) * (ulonglong)input_param3;\n    temp8 = (temp8 & 0xffffffff) * (ulonglong)input_param4 +\n             (ulonglong)temp1 * (ulonglong)input_param3 + (result1 >> 0x20);\n    temp7 = (uint)temp8;\n    result2 = (ulonglong)temp1 * (ulonglong)input_param4 + (temp8 >> 0x20);\n    temp6 = (uint)result2;\n    temp1 = (uint)((ulonglong)result2 >> 0x20);\n    if ((int)result1 != 0) {\n      temp7 = temp7 | 1;\n    }\n    temp4 = (temp3 + -0x3ff) - (uint)(temp1 < 0x200);\n    if (temp1 < 0x200) {\n      flag1 = (temp7 & 0x80000000) != 0;\n      temp7 = temp7 << 1;\n      result2 = CONCAT44(temp1 * 2 + (uint)(CARRY4(temp6,temp6) || CARRY4(temp6 * 2,(uint)flag1)),\n                       temp6 * 2 + (uint)flag1);\n    }\n    input_param4 = temp2 & 0x80000000 | (int)((ulonglong)result2 >> 0x20) << 0xb | (uint)result2 >> 0x15;\n    input_param3 = (uint)result2 << 0xb | temp7 >> 0x15;\n    temp6 = temp7 * 0x800;\n    flag2 = 0xfc < temp4;\n    flag3 = SBORROW4(temp4,0xfd);\n    temp1 = temp4 - 0xfd;\n    flag1 = temp1 == 0;\n    temp2 = temp1;\n    if (flag2 && !flag1) {\n      flag2 = 0x6ff < temp1;\n      flag3 = SBORROW4(temp1,0x700);\n      temp2 = temp4 - 0x7fd;\n      flag1 = temp1 == 0x700;\n    }\n    if (!flag2 || flag1) {\n      flag1 = 0x7fffffff < temp6;\n      if (temp6 == 0x80000000) {\n        flag1 = (temp7 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(input_param4 + temp4 * 0x100000 + (uint)CARRY4(input_param3,(uint)flag1),input_param3 + flag1\n                     );\n    }\n  }\n  if (!flag1 && (int)temp2 < 0 == flag3) {\n    return (ulonglong)(input_param4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag2 = SCARRY4(temp4,0x36);\n  flag1 = (int)(temp4 + 0x36) < 0;\n  flag3 = temp4 == 0xffffffca;\n  if (flag3 || flag1 != flag2) {\n    input_param3 = 0;\n  }\n  if (flag3 || flag1 != flag2) {\n    input_param4 = input_param4 & 0x80000000;\n  }\n  if (flag3 || flag1 != flag2) {\n    return CONCAT44(input_param4,input_param3);\n  }\n  temp2 = -temp4;\n  temp1 = temp2 - 0x20;\n  if (0x1f < (int)temp2) {\n    temp4 = input_param3 >> (temp1 & 0xff) | input_param4 << (0x20 - temp1 & 0xff);\n    temp2 = (input_param4 >> (temp1 & 0xff) & ~((input_param4 & 0x80000000) >> (temp1 & 0xff))) -\n            ((int)temp4 >> 0x1f);\n    if ((temp6 | input_param3 << (0x20 - temp1 & 0xff) | temp4 << 1) == 0) {\n      temp2 = temp2 & ~(temp4 >> 0x1f);\n    }\n    return CONCAT44(input_param4,temp2) & 0x80000000ffffffff;\n  }\n  temp3 = temp2 - 0x14;\n  if (temp3 == 0 || temp3 < 0 != SCARRY4(temp1,0xc)) {\n    temp7 = input_param3 << (temp4 + 0x20 & 0xff);\n    temp1 = input_param3 >> (temp2 & 0xff) | input_param4 << (temp4 + 0x20 & 0xff);\n    temp4 = temp1 + -((int)temp7 >> 0x1f);\n    if ((temp6 | temp7 << 1) == 0) {\n      temp4 = temp4 & ~(temp7 >> 0x1f);\n    }\n    return CONCAT44((input_param4 & 0x80000000) +\n                    ((input_param4 & 0x7fffffff) >> (temp2 & 0xff)) +\n                    (uint)CARRY4(temp1,-((int)temp7 >> 0x1f)),temp4);\n  }\n  temp2 = 0xc - temp3;\n  temp4 = input_param3 << (temp2 & 0xff);\n  temp2 = input_param3 >> (0x20 - temp2 & 0xff) | input_param4 << (temp2 & 0xff);\n  temp1 = temp2 + -((int)temp4 >> 0x1f);\n  if ((temp6 | temp4 << 1) == 0) {\n    temp1 = temp1 & ~(temp4 >> 0x1f);\n  }\n  return CONCAT44((input_param4 & 0x80000000) + (uint)CARRY4(temp2,-((int)temp4 >> 0x1f)),temp1);\n}\n\n",
            "renaming": {
                "FUN_080004c8": "calculate_bitwise_difference_080004c8",
                "param_1": "input_param1",
                "param_2": "input_param2",
                "param_3": "input_param3",
                "param_4": "input_param4",
                "uVar1": "result1",
                "lVar2": "result2",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "iVar5": "temp3",
                "uVar6": "temp4",
                "unaff_r5": "temp5",
                "uVar7": "temp6",
                "uVar8": "temp7",
                "bVar9": "flag1",
                "bVar10": "flag2",
                "bVar11": "flag3",
                "uVar12": "temp8"
            },
            "calling": [
                "FUN_080059f0",
                "FUN_08004bd8",
                "FUN_08005e9c",
                "FUN_080096e0",
                "FUN_08004d78",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080006a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006a4": {
            "entrypoint": "0x080006a4",
            "current_name": "calculate_bitwise_difference_080006a4",
            "code": "\nulonglong calculate_bitwise_difference_080006a4(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint bit1;\n  uint bit2;\n  uint bit3;\n  uint bit4;\n  uint bit5;\n  bool isZero;\n  \n  bit3 = bit5 & input4 >> 0x14;\n  if (bit2 != bit5 && bit3 != bit5) {\n    isZero = (input1 | input2 << 1) == 0;\n    if (!isZero) {\n      isZero = (input3 | input4 << 1) == 0;\n    }\n    if (isZero) {\n      return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n    }\n    if (bit2 == 0) {\n      bit4 = input2 & 0x80000000;\n      do {\n        bit1 = input1 & 0x80000000;\n        input1 = input1 << 1;\n        input2 = input2 * 2 + (uint)(bit1 != 0);\n      } while ((input2 & 0x100000) == 0);\n      input2 = input2 | bit4;\n      if (bit3 != 0) {\n        return CONCAT44(input2,input1);\n      }\n    }\n    do {\n      bit3 = input3 & 0x80000000;\n      input3 = input3 << 1;\n      input4 = input4 * 2 + (uint)(bit3 != 0);\n    } while ((input4 & 0x100000) == 0);\n    return CONCAT44(input2,input1);\n  }\n  isZero = (input1 | input2 << 1) == 0;\n  if (isZero) {\n    input2 = input4;\n    input1 = input3;\n  }\n  if (!isZero) {\n    isZero = (input3 | input4 << 1) == 0;\n  }\n  bit4 = input2;\n  if (((!isZero) && ((bit2 != bit5 || ((input1 | input2 << 0xc) == 0)))) &&\n     ((bit3 != bit5 || (input1 = input3, bit4 = input4, (input3 | input4 << 0xc) == 0)))) {\n    return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(bit4,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006a4": "calculate_bitwise_difference_080006a4",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "bit1",
                "unaff_r4": "bit2",
                "uVar2": "bit3",
                "uVar3": "bit4",
                "in_r12": "bit5",
                "bVar4": "isZero"
            },
            "calling": [
                "FUN_080004c8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800071c": {
            "entrypoint": "0x0800071c",
            "current_name": "calculate_floating_point_0800071c",
            "code": "\nulonglong calculateFloatingPoint_0800071c(undefined4 var1,uint var2,uint var3,uint var4)\n\n{\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  int temp8;\n  uint temp9;\n  uint temp10;\n  uint temp11;\n  uint temp12;\n  uint temp13;\n  uint temp14;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  undefined8 result;\n  \n  result = CONCAT44(var2,var1);\n  temp14 = 0x7ff;\n  temp7 = var2 >> 0x14 & 0x7ff;\n  flag1 = temp7 == 0;\n  if (!flag1) {\n    temp10 = var4 >> 0x14 & 0x7ff;\n    flag1 = temp10 == 0;\n  }\n  if (!flag1) {\n    flag1 = temp7 == 0x7ff;\n  }\n  if (!flag1) {\n    flag1 = temp10 == 0x7ff;\n  }\n  if (flag1) {\n    result = calculate_double_0800088a();\n  }\n  temp9 = (uint)((ulonglong)result >> 0x20);\n  temp12 = (uint)result;\n  temp8 = temp7 - temp10;\n  if ((var3 | var4 << 0xc) == 0) {\n    temp7 = (temp9 ^ var4) & 0x80000000 | temp9 & 0xfffff;\n    flag3 = SCARRY4(temp8,temp14 >> 1);\n    temp9 = temp8 + (temp14 >> 1);\n    flag1 = (int)temp9 < 0;\n    flag2 = temp9 == 0;\n    if (!flag2 && flag1 == flag3) {\n      flag3 = SBORROW4(temp14,temp9);\n      flag1 = (int)(temp14 - temp9) < 0;\n      flag2 = temp14 == temp9;\n    }\n    if (!flag2 && flag1 == flag3) {\n      temp7 = temp7 | temp9 * 0x100000;\n    }\n    if (!flag2 && flag1 == flag3) {\n      return CONCAT44(temp7,temp12);\n    }\n    temp7 = temp7 | 0x100000;\n    temp14 = 0;\n    flag2 = SBORROW4(temp9,1);\n    temp9 = temp9 - 1;\n    flag1 = temp9 == 0;\n    temp3 = temp9;\n  }\n  else {\n    temp3 = (var4 << 0xc) >> 4 | 0x10000000 | var3 >> 0x18;\n    temp14 = var3 << 8;\n    temp11 = (temp9 << 0xc) >> 4 | 0x10000000 | temp12 >> 0x18;\n    temp12 = temp12 * 0x100;\n    temp7 = (temp9 ^ var4) & 0x80000000;\n    flag1 = temp3 <= temp11;\n    if (temp11 == temp3) {\n      flag1 = temp14 <= temp12;\n    }\n    temp8 = temp8 + (uint)flag1;\n    temp9 = temp8 + 0x3fd;\n    if (flag1 == false) {\n      temp3 = temp3 >> 1;\n      temp14 = (uint)((var3 >> 0x18 & 1) != 0) << 0x1f | temp14 >> 1;\n    }\n    temp13 = temp12 - temp14;\n    temp11 = (temp11 - temp3) - (uint)(temp12 < temp14);\n    temp4 = temp3 >> 1;\n    temp1 = (uint)((temp3 & 1) != 0) << 0x1f | temp14 >> 1;\n    temp12 = 0x100000;\n    temp3 = 0x80000;\n    while( true ) {\n      flag1 = temp1 <= temp13;\n      if (temp4 < temp11 || temp11 - temp4 < (uint)flag1) {\n        temp13 = temp13 - temp1;\n        temp12 = temp12 | temp3;\n        temp11 = (temp11 - temp4) - (uint)!flag1;\n      }\n      temp5 = temp4 >> 1;\n      temp1 = (uint)((temp4 & 1) != 0) << 0x1f | temp1 >> 1;\n      flag2 = temp1 <= temp13;\n      flag1 = temp11 - temp5 < (uint)flag2;\n      temp14 = temp11;\n      if (temp5 < temp11 || flag1) {\n        temp13 = temp13 - temp1;\n        temp14 = (temp11 - temp5) - (uint)!flag2;\n      }\n      if (temp5 < temp11 || flag1) {\n        temp12 = temp12 | temp3 >> 1;\n      }\n      temp11 = temp4 >> 2;\n      temp2 = (uint)((temp5 & 1) != 0) << 0x1f | temp1 >> 1;\n      flag2 = temp2 <= temp13;\n      flag1 = temp14 - temp11 < (uint)flag2;\n      temp5 = temp14;\n      if (temp11 < temp14 || flag1) {\n        temp13 = temp13 - temp2;\n        temp5 = (temp14 - temp11) - (uint)!flag2;\n      }\n      if (temp11 < temp14 || flag1) {\n        temp12 = temp12 | temp3 >> 2;\n      }\n      temp6 = temp4 >> 3;\n      temp1 = (uint)((temp11 & 1) != 0) << 0x1f | temp2 >> 1;\n      flag2 = temp1 <= temp13;\n      flag1 = temp5 - temp6 < (uint)flag2;\n      temp11 = temp5;\n      if (temp6 < temp5 || flag1) {\n        temp13 = temp13 - temp1;\n        temp11 = (temp5 - temp6) - (uint)!flag2;\n      }\n      if (temp6 < temp5 || flag1) {\n        temp12 = temp12 | temp3 >> 3;\n      }\n      temp14 = temp11 | temp13;\n      if (temp14 == 0) break;\n      temp11 = temp11 << 4 | temp13 >> 0x1c;\n      temp13 = temp13 << 4;\n      temp4 = temp4 & 0xfffffff8 | temp1 >> 0x1d;\n      temp1 = (temp2 >> 1) << 3;\n      temp3 = temp3 >> 4;\n      if (temp3 == 0) {\n        temp6 = temp4;\n        if ((temp7 & 0x100000) != 0) goto LAB_0800083a;\n        temp7 = temp7 | temp12;\n        temp12 = 0;\n        temp3 = 0x80000000;\n      }\n    }\n    if ((temp7 & 0x100000) == 0) {\n      temp7 = temp7 | temp12;\n      temp12 = 0;\n    }\nLAB_0800083a:\n    flag3 = 0xfc < temp9;\n    flag2 = SBORROW4(temp9,0xfd);\n    temp4 = temp8 + 0x300;\n    flag1 = temp4 == 0;\n    temp3 = temp4;\n    if (flag3 && !flag1) {\n      flag3 = 0x6ff < temp4;\n      flag2 = SBORROW4(temp4,0x700);\n      temp3 = temp8 - 0x400;\n      flag1 = temp4 == 0x700;\n    }\n    if (!flag3 || flag1) {\n      flag1 = temp6 <= temp11;\n      if (temp11 == temp6) {\n        flag1 = temp1 <= temp13;\n      }\n      if (temp11 == temp6 && temp13 == temp1) {\n        flag1 = (temp12 & 1) != 0;\n      }\n      return CONCAT44(temp7 + temp9 * 0x100000 + (uint)CARRY4(temp12,(uint)flag1),temp12 + flag1);\n    }\n  }\n  if (!flag1 && (int)temp3 < 0 == flag2) {\n    return (ulonglong)(temp7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag3 = SCARRY4(temp9,0x36);\n  flag1 = (int)(temp9 + 0x36) < 0;\n  flag2 = temp9 == 0xffffffca;\n  if (flag2 || flag1 != flag3) {\n    temp12 = 0;\n  }\n  if (flag2 || flag1 != flag3) {\n    temp7 = temp7 & 0x80000000;\n  }\n  if (flag2 || flag1 != flag3) {\n    return CONCAT44(temp7,temp12);\n  }\n  temp3 = -temp9;\n  temp11 = temp3 - 0x20;\n  if (0x1f < (int)temp3) {\n    temp3 = temp12 >> (temp11 & 0xff) | temp7 << (0x20 - temp11 & 0xff);\n    temp9 = (temp7 >> (temp11 & 0xff) & ~((temp7 & 0x80000000) >> (temp11 & 0xff))) -\n            ((int)temp3 >> 0x1f);\n    if ((temp14 | temp12 << (0x20 - temp11 & 0xff) | temp3 << 1) == 0) {\n      temp9 = temp9 & ~(temp3 >> 0x1f);\n    }\n    return CONCAT44(temp7,temp9) & 0x80000000ffffffff;\n  }\n  temp8 = temp3 - 0x14;\n  if (temp8 != 0 && temp8 < 0 == SCARRY4(temp11,0xc)) {\n    temp9 = 0xc - temp8;\n    temp3 = temp12 << (temp9 & 0xff);\n    temp12 = temp12 >> (0x20 - temp9 & 0xff) | temp7 << (temp9 & 0xff);\n    temp9 = temp12 + -((int)temp3 >> 0x1f);\n    if ((temp14 | temp3 << 1) == 0) {\n      temp9 = temp9 & ~(temp3 >> 0x1f);\n    }\n    return CONCAT44((temp7 & 0x80000000) + (uint)CARRY4(temp12,-((int)temp3 >> 0x1f)),temp9);\n  }\n  temp11 = temp12 << (temp9 + 0x20 & 0xff);\n  temp12 = temp12 >> (temp3 & 0xff) | temp7 << (temp9 + 0x20 & 0xff);\n  temp9 = temp12 + -((int)temp11 >> 0x1f);\n  if ((temp14 | temp11 << 1) == 0) {\n    temp9 = temp9 & ~(temp11 >> 0x1f);\n  }\n  return CONCAT44((temp7 & 0x80000000) +\n                  ((temp7 & 0x7fffffff) >> (temp3 & 0xff)) +\n                  (uint)CARRY4(temp12,-((int)temp11 >> 0x1f)),temp9);\n}\n\n",
            "renaming": {
                "FUN_0800071c": "calculate_floating_point_0800071c",
                "param_1": "var1",
                "param_2": "var2",
                "param_3": "var3",
                "param_4": "var4",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "uVar6": "temp6",
                "uVar7": "temp7",
                "iVar8": "temp8",
                "uVar9": "temp9",
                "unaff_r5": "temp10",
                "uVar10": "temp11",
                "uVar11": "temp12",
                "uVar12": "temp13",
                "uVar13": "temp14",
                "bVar14": "flag1",
                "bVar15": "flag2",
                "bVar16": "flag3",
                "uVar17": "result"
            },
            "calling": [
                "FUN_080059f0",
                "FUN_08004bd8",
                "FUN_08004d78",
                "FUN_08005838",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_0800088a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800088a": {
            "entrypoint": "0x0800088a",
            "current_name": "calculate_double_0800088a",
            "code": "\nulonglong calculate_double_0800088a(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint bit1;\n  uint bit2;\n  uint bit3;\n  uint bit4;\n  uint bit5;\n  bool isZero;\n  \n  bit3 = bit5 & input4 >> 0x14;\n  bit4 = input2;\n  if (bit2 != bit5 || bit3 != bit5) {\n    if (bit2 == bit5) {\n      if (((input1 | input2 << 0xc) == 0) && (input1 = input3, bit4 = input4, bit3 != bit5)\n         ) {\nLAB_080006fc:\n        return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (bit3 == bit5) {\n      input1 = input3;\n      bit4 = input4;\n      if ((input3 | input4 << 0xc) == 0) {\nLAB_080006c0:\n        return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      isZero = (input1 | input2 << 1) == 0;\n      if (!isZero) {\n        isZero = (input3 | input4 << 1) == 0;\n      }\n      if (!isZero) {\n        if (bit2 == 0) {\n          bit4 = input2 & 0x80000000;\n          do {\n            bit1 = input1 & 0x80000000;\n            input1 = input1 << 1;\n            input2 = input2 * 2 + (uint)(bit1 != 0);\n          } while ((input2 & 0x100000) == 0);\n          input2 = input2 | bit4;\n          if (bit3 != 0) {\n            return CONCAT44(input2,input1);\n          }\n        }\n        do {\n          bit4 = input3 & 0x80000000;\n          input3 = input3 << 1;\n          input4 = input4 * 2 + (uint)(bit4 != 0);\n        } while ((input4 & 0x100000) == 0);\n        return CONCAT44(input2,input1);\n      }\n      if ((input1 | input2 << 1) != 0) goto LAB_080006fc;\n      if ((input3 | input4 << 1) != 0) goto LAB_080006c0;\n    }\n  }\n  return CONCAT44(bit4,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_0800088a": "calculate_double_0800088a",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "bit1",
                "unaff_r4": "bit2",
                "uVar2": "bit3",
                "uVar3": "bit4",
                "in_r12": "bit5",
                "bVar4": "isZero"
            },
            "calling": [
                "FUN_0800071c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008fc": {
            "entrypoint": "0x080008fc",
            "current_name": "compare_parameters_080008fc",
            "code": "\nuint compareParameters_080008fc(uint value1,uint value2,uint value3,uint value4)\n\n{\n  uint result;\n  bool isZero;\n  bool isNegative;\n  \n  if (((int)(value2 << 1) >> 0x15 == -1 || (int)(value4 << 1) >> 0x15 == -1) &&\n     ((((int)(value2 << 1) >> 0x15 == -1 && ((value1 | value2 << 0xc) != 0)) ||\n      (((int)(value4 << 1) >> 0x15 == -1 && ((value3 | value4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (value1 | value2 << 1) == 0;\n  if (isZero) {\n    isZero = (value3 | value4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = value2 == value4;\n  }\n  if (isZero) {\n    isZero = value1 == value3;\n  }\n  if (!isZero) {\n    result = value2 ^ value4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = value2 == value4;\n    }\n    isNegative = -1 < (int)result && value4 <= value2;\n    if (isZero) {\n      isNegative = value3 <= value1;\n    }\n    value4 = (int)value4 >> 0x1f;\n    if (!isNegative) {\n      value4 = ~value4;\n    }\n    return value4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008fc": "compare_parameters_080008fc",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isNegative"
            },
            "calling": [
                "FUN_08000988"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000978": {
            "entrypoint": "0x08000978",
            "current_name": "compare_and_return_parameter_08000978",
            "code": "\nvoid compare_and_return_parameter_08000978(undefined4 first_param,undefined4 second_param,undefined4 third_param,undefined4 fourth_param)\n\n{\n  compare_and_return_parameter_08000978_08000988(third_param,fourth_param,first_param,second_param);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000978": "compare_and_return_parameter_08000978",
                "param_1": "first_param",
                "param_2": "second_param",
                "param_3": "third_param",
                "param_4": "fourth_param"
            },
            "calling": [
                "FUN_080009d4",
                "FUN_080009e8"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000988": {
            "entrypoint": "0x08000988",
            "current_name": "compare_and_return_parameter_08000988",
            "code": "\nundefined4 compareAndReturnParameter_08000988(undefined4 inputParameter)\n\n{\n  compare_parameters_080008fc();\n  return inputParameter;\n}\n\n",
            "renaming": {
                "FUN_08000988": "compare_and_return_parameter_08000988",
                "param_1": "inputParameter"
            },
            "calling": [
                "FUN_080009ac",
                "FUN_080009c0",
                "FUN_08000978",
                "FUN_08000998"
            ],
            "called": [
                "FUN_080008fc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "check_comparison_result_08000998",
            "code": "\nbool checkComparisonResult_08000998(void)\n\n{\n  char comparisonResult;\n  \n  compare_and_return_parameter_08000988();\n  return comparisonResult != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000998": "check_comparison_result_08000998",
                "in_ZR": "comparisonResult"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009ac": {
            "entrypoint": "0x080009ac",
            "current_name": "check_if_string_is_null_terminated_080009ac",
            "code": "\nbool checkIfStringIsNullTerminated_080009ac(void)\n\n{\n  char inputChar;\n  \n  compare_and_return_parameter_08000988();\n  return inputChar == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009ac": "check_if_string_is_null_terminated_080009ac",
                "in_CY": "inputChar"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c0": {
            "entrypoint": "0x080009c0",
            "current_name": "check_comparison_result_080009c0",
            "code": "\nbool check_comparison_result_080009c0(void)\n\n{\n  undefined zero_flag;\n  undefined carry_flag;\n  \n  compare_and_return_parameter_08000988();\n  return !(bool)carry_flag || (bool)zero_flag;\n}\n\n",
            "renaming": {
                "FUN_080009c0": "check_comparison_result_080009c0",
                "in_ZR": "zero_flag",
                "in_CY": "carry_flag"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009d4": {
            "entrypoint": "0x080009d4",
            "current_name": "check_condition_and_return_result_080009d4",
            "code": "\nbool check_condition_and_return_result_080009d4(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_flag;\n  \n  compare_and_return_parameter();\n  return !(bool)is_carry_flag || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_080009d4": "check_condition_and_return_result_080009d4",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_flag",
                "compare_and_return_parameter_08000978": "compare_and_return_parameter"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08000978"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009e8": {
            "entrypoint": "0x080009e8",
            "current_name": "is_string_terminated_080009e8",
            "code": "\nbool is_string_terminated_080009e8(void)\n\n{\n  char last_character;\n  \n  check_string_termination();\n  return last_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009e8": "is_string_terminated_080009e8",
                "in_CY": "last_character",
                "compare_and_return_parameter_08000978": "check_string_termination"
            },
            "calling": [
                "FUN_080059f0",
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08000978"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009fc": {
            "entrypoint": "0x080009fc",
            "current_name": "calculate_float_080009fc",
            "code": "\nuint calculateFloat_080009fc(uint input1,uint input2)\n\n{\n  uint result;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  bool isZero;\n  bool lessThanLimit;\n  \n  temp1 = input2 * 2;\n  lessThanLimit = temp1 < 0x70000000;\n  temp2 = temp1 + 0x90000000;\n  result = temp2;\n  if (!lessThanLimit) {\n    temp3 = temp1 + 0x8fe00000;\n    result = temp3;\n  }\n  isZero = result == 0;\n  if (!lessThanLimit && temp2 >= 0x200000) {\n    isZero = temp3 == 0x1fc00000;\n  }\n  if (((lessThanLimit || temp2 < 0x200000) || 0x1fc00000 < temp3) || isZero) {\n    if ((input2 & 0x40000000) != 0) {\n      if (((int)temp1 >> 0x15 == -1) && ((input1 | input2 << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return input2 & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(temp1 + 0x92e00000) < 0 != SCARRY4(temp2,0x2e00000)) {\n      return input2 & 0x80000000;\n    }\n    temp1 = 0x18 - (temp1 + 0x92e00000 >> 0x15);\n    result = input1 >> (temp1 & 0xff);\n    if (input1 << (0x20 - temp1 & 0xff) != 0) {\n      result = result | 1;\n    }\n    temp2 = input2 & 0x1fffff | 0x100000;\n    input1 = result | temp2 << (0x20 - temp1 & 0xff);\n    temp2 = (temp2 >> (temp1 & 0xff)) << 1;\n  }\n  result = (input2 & 0x80000000 | input1 >> 0x1d) + temp2 * 4 + (uint)(0x7fffffff < input1 * 8);\n  if (input1 * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080009fc": "calculate_float_080009fc",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "result",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "in_r12": "temp3",
                "bVar4": "isZero",
                "bVar5": "lessThanLimit"
            },
            "calling": [
                "FUN_08004bd8",
                "FUN_08004d78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa4": {
            "entrypoint": "0x08000aa4",
            "current_name": "calculate_float_08000aa4",
            "code": "\nuint calculate_float_08000aa4(uint input_num1,uint input_num2,undefined4 input_flag,uint result)\n\n{\n  int shifted_num1;\n  int shifted_num2;\n  uint result_num;\n  uint temp_num;\n  uint num1;\n  uint num2;\n  uint difference;\n  bool isValid;\n  \n  result_num = input_num2 ^ 0x80000000;\n  num1 = input_num1 << 1;\n  isValid = num1 == 0;\n  if (!isValid) {\n    result = input_num2 << 1;\n    isValid = result == 0;\n  }\n  if (!isValid) {\n    isValid = num1 == result;\n  }\n  shifted_num1 = (int)num1 >> 0x18;\n  if (!isValid) {\n    isValid = shifted_num1 == -1;\n  }\n  if (!isValid) {\n    isValid = (int)result >> 0x18 == -1;\n  }\n  if (isValid) {\n    shifted_num2 = (int)(input_num2 << 1) >> 0x18;\n    if (shifted_num1 == -1 || shifted_num2 == -1) {\n      num1 = result_num;\n      if (shifted_num1 == -1) {\n        num1 = input_num1;\n      }\n      if (shifted_num1 != -1 || shifted_num2 != -1) {\n        result_num = num1;\n      }\n      isValid = (num1 & 0x7fffff) == 0;\n      if (isValid) {\n        isValid = (result_num & 0x7fffff) == 0;\n      }\n      if (isValid) {\n        isValid = num1 == result_num;\n      }\n      if (!isValid) {\n        num1 = num1 | 0x400000;\n      }\n      return num1;\n    }\n    if (((input_num1 ^ result_num) & 0x7fffffff) != 0) {\n      if (num1 == 0) {\n        input_num1 = result_num;\n      }\n      return input_num1;\n    }\n    if (input_num1 != result_num) {\n      return 0;\n    }\n    if ((num1 & 0xff000000) == 0) {\n      result_num = input_num1 << 1;\n      if ((input_num1 & 0x80000000) != 0) {\n        result_num = result_num | 0x80000000;\n      }\n      return result_num;\n    }\n    if (num1 < 0xfe000000) {\n      return input_num1 + 0x800000;\n    }\n    input_num1 = input_num1 & 0x80000000;\nLAB_08000bde:\n    return input_num1 | 0x7f800000;\n  }\n  num1 = num1 >> 0x18;\n  result = result >> 0x18;\n  difference = result - num1;\n  isValid = difference != 0;\n  num2 = num1;\n  if (isValid && num1 <= result) {\n    num2 = num1 + difference;\n  }\n  if (isValid && num1 <= result) {\n    result_num = result_num ^ input_num1;\n  }\n  if (isValid && num1 <= result) {\n    input_num1 = input_num1 ^ result_num;\n  }\n  if (isValid && num1 <= result) {\n    result_num = result_num ^ input_num1;\n  }\n  if (result < num1) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return input_num1;\n  }\n  num1 = input_num1 & 0xffffff | 0x800000;\n  if ((input_num1 & 0x80000000) != 0) {\n    num1 = -num1;\n  }\n  temp_num = result_num & 0xffffff | 0x800000;\n  if ((result_num & 0x80000000) != 0) {\n    temp_num = -temp_num;\n  }\n  if (num2 == difference) {\n    temp_num = temp_num ^ 0x800000;\n    if (num2 == 0) {\n      num1 = num1 ^ 0x800000;\n      num2 = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  num1 = num1 + ((int)temp_num >> (difference & 0xff));\n  temp_num = temp_num << (0x20 - difference & 0xff);\n  input_num1 = num1 & 0x80000000;\n  if ((int)num1 < 0) {\n    isValid = temp_num != 0;\n    temp_num = -temp_num;\n    num1 = -num1 - (uint)isValid;\n  }\n  if (num1 < 0x800000) {\n    result_num = temp_num & 0x80000000;\n    temp_num = temp_num << 1;\n    num1 = num1 * 2 + (uint)(result_num != 0);\n    result_num = num2 - 2;\n    if ((num1 & 0x800000) == 0) {\n      difference = LZCOUNT(num1) - 8;\n      num1 = num1 << (difference & 0xff);\n      if ((int)result_num < (int)difference) {\n        num1 = num1 >> (-(result_num - difference) & 0xff);\n      }\n      else {\n        num1 = num1 + (result_num - difference) * 0x800000;\n      }\n      return num1 | input_num1;\n    }\n  }\n  else {\n    result_num = num2 - 1;\n    if (0xffffff < num1) {\n      result_num = num1 & 1;\n      num1 = num1 >> 1;\n      temp_num = (uint)(result_num != 0) << 0x1f | temp_num >> 1;\n      result_num = num2;\n      if (0xfd < num2) goto LAB_08000bde;\n    }\n  }\n  num1 = num1 + result_num * 0x800000 + (uint)(0x7fffffff < temp_num);\n  if (temp_num == 0x80000000) {\n    num1 = num1 & 0xfffffffe;\n  }\n  return num1 | input_num1;\n}\n\n",
            "renaming": {
                "FUN_08000aa4": "calculate_float_08000aa4",
                "param_1": "input_num1",
                "param_2": "input_num2",
                "param_3": "input_flag",
                "param_4": "result",
                "iVar1": "shifted_num1",
                "iVar2": "shifted_num2",
                "uVar3": "result_num",
                "uVar4": "temp_num",
                "uVar5": "num1",
                "uVar6": "num2",
                "uVar7": "difference",
                "bVar8": "isValid"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_08004bd8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa8": {
            "entrypoint": "0x08000aa8",
            "current_name": "calculate_floating_point_08000aa8",
            "code": "\nuint calculateFloatingPoint_08000aa8(uint value1,uint value2,undefined4 param3,uint param4)\n\n{\n  int shiftAmount;\n  int shiftAmount2;\n  uint result1;\n  uint result2;\n  uint temp1;\n  uint temp2;\n  bool isZero;\n  \n  result2 = value1 << 1;\n  isZero = result2 == 0;\n  if (!isZero) {\n    param4 = value2 << 1;\n    isZero = param4 == 0;\n  }\n  if (!isZero) {\n    isZero = result2 == param4;\n  }\n  shiftAmount = (int)result2 >> 0x18;\n  if (!isZero) {\n    isZero = shiftAmount == -1;\n  }\n  if (!isZero) {\n    isZero = (int)param4 >> 0x18 == -1;\n  }\n  if (isZero) {\n    shiftAmount2 = (int)(value2 << 1) >> 0x18;\n    if (shiftAmount == -1 || shiftAmount2 == -1) {\n      result2 = value2;\n      if (shiftAmount == -1) {\n        result2 = value1;\n      }\n      if (shiftAmount != -1 || shiftAmount2 != -1) {\n        value2 = result2;\n      }\n      isZero = (result2 & 0x7fffff) == 0;\n      if (isZero) {\n        isZero = (value2 & 0x7fffff) == 0;\n      }\n      if (isZero) {\n        isZero = result2 == value2;\n      }\n      if (!isZero) {\n        result2 = result2 | 0x400000;\n      }\n      return result2;\n    }\n    if (((value1 ^ value2) & 0x7fffffff) != 0) {\n      if (result2 == 0) {\n        value1 = value2;\n      }\n      return value1;\n    }\n    if (value1 != value2) {\n      return 0;\n    }\n    if ((result2 & 0xff000000) == 0) {\n      result2 = value1 << 1;\n      if ((value1 & 0x80000000) != 0) {\n        result2 = result2 | 0x80000000;\n      }\n      return result2;\n    }\n    if (result2 < 0xfe000000) {\n      return value1 + 0x800000;\n    }\n    value1 = value1 & 0x80000000;\nLAB_08000bde:\n    return value1 | 0x7f800000;\n  }\n  result2 = result2 >> 0x18;\n  param4 = param4 >> 0x18;\n  temp2 = param4 - result2;\n  isZero = temp2 != 0;\n  temp1 = result2;\n  if (isZero && result2 <= param4) {\n    temp1 = result2 + temp2;\n  }\n  if (isZero && result2 <= param4) {\n    value2 = value2 ^ value1;\n  }\n  if (isZero && result2 <= param4) {\n    value1 = value1 ^ value2;\n  }\n  if (isZero && result2 <= param4) {\n    value2 = value2 ^ value1;\n  }\n  if (param4 < result2) {\n    temp2 = -temp2;\n  }\n  if (0x19 < temp2) {\n    return value1;\n  }\n  result2 = value1 & 0xffffff | 0x800000;\n  if ((value1 & 0x80000000) != 0) {\n    result2 = -result2;\n  }\n  result1 = value2 & 0xffffff | 0x800000;\n  if ((value2 & 0x80000000) != 0) {\n    result1 = -result1;\n  }\n  if (temp1 == temp2) {\n    result1 = result1 ^ 0x800000;\n    if (temp1 == 0) {\n      result2 = result2 ^ 0x800000;\n      temp1 = 1;\n    }\n    else {\n      temp2 = temp2 - 1;\n    }\n  }\n  result2 = result2 + ((int)result1 >> (temp2 & 0xff));\n  result1 = result1 << (0x20 - temp2 & 0xff);\n  value1 = result2 & 0x80000000;\n  if ((int)result2 < 0) {\n    isZero = result1 != 0;\n    result1 = -result1;\n    result2 = -result2 - (uint)isZero;\n  }\n  if (result2 < 0x800000) {\n    temp2 = result1 & 0x80000000;\n    result1 = result1 << 1;\n    result2 = result2 * 2 + (uint)(temp2 != 0);\n    temp2 = temp1 - 2;\n    if ((result2 & 0x800000) == 0) {\n      temp1 = LZCOUNT(result2) - 8;\n      result2 = result2 << (temp1 & 0xff);\n      if ((int)temp2 < (int)temp1) {\n        result2 = result2 >> (-(temp2 - temp1) & 0xff);\n      }\n      else {\n        result2 = result2 + (temp2 - temp1) * 0x800000;\n      }\n      return result2 | value1;\n    }\n  }\n  else {\n    temp2 = temp1 - 1;\n    if (0xffffff < result2) {\n      temp2 = result2 & 1;\n      result2 = result2 >> 1;\n      result1 = (uint)(temp2 != 0) << 0x1f | result1 >> 1;\n      temp2 = temp1;\n      if (0xfd < temp1) goto LAB_08000bde;\n    }\n  }\n  result2 = result2 + temp2 * 0x800000 + (uint)(0x7fffffff < result1);\n  if (result1 == 0x80000000) {\n    result2 = result2 & 0xfffffffe;\n  }\n  return result2 | value1;\n}\n\n",
            "renaming": {
                "FUN_08000aa8": "calculate_floating_point_08000aa8",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "param3",
                "param_4": "param4",
                "iVar1": "shiftAmount",
                "iVar2": "shiftAmount2",
                "uVar3": "result1",
                "uVar4": "result2",
                "uVar5": "temp1",
                "uVar6": "temp2",
                "bVar7": "isZero"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_080049cc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c08": {
            "entrypoint": "0x08000c08",
            "current_name": "calculate_modified_value_08000c08",
            "code": "\nuint calculateModifiedValue_08000c08(uint inputValue)\n\n{\n  uint leadingZerosCount;\n  uint shiftAmount;\n  int constantOffset;\n  uint flagValue;\n  \n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZerosCount = LZCOUNT(inputValue);\n  shiftAmount = leadingZerosCount - 8;\n  constantOffset = shiftAmount * -0x800000 + 0x4a800000;\n  if (7 < leadingZerosCount) {\n    flagValue = 0 << (shiftAmount & 0xff);\n    leadingZerosCount = constantOffset + (inputValue << (shiftAmount & 0xff)) +\n            (0U >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < flagValue);\n    if (flagValue == 0x80000000) {\n      leadingZerosCount = leadingZerosCount & 0xfffffffe;\n    }\n    return leadingZerosCount;\n  }\n  shiftAmount = inputValue << leadingZerosCount + 0x18;\n  leadingZerosCount = constantOffset + ((inputValue >> (0x20 - (leadingZerosCount + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n  if ((shiftAmount & 0x7fffffff) == 0) {\n    leadingZerosCount = leadingZerosCount & ~(shiftAmount >> 0x1f);\n  }\n  return leadingZerosCount;\n}\n\n",
            "renaming": {
                "FUN_08000c08": "calculate_modified_value_08000c08",
                "param_1": "inputValue",
                "uVar1": "leadingZerosCount",
                "uVar2": "shiftAmount",
                "iVar3": "constantOffset",
                "uVar4": "flagValue"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c10": {
            "entrypoint": "0x08000c10",
            "current_name": "count_and_adjust_08000c10",
            "code": "\nuint countAndAdjust_08000c10(uint input)\n\n{\n  uint leadingZeroes;\n  uint shiftAmount;\n  uint signBit;\n  int adjustedValue;\n  \n  signBit = input & 0x80000000;\n  if ((int)signBit < 0) {\n    input = -input;\n  }\n  if (input == 0) {\n    return 0;\n  }\n  leadingZeroes = LZCOUNT(input);\n  shiftAmount = leadingZeroes - 8;\n  adjustedValue = ((signBit | 0x4b000000) - 0x800000) + shiftAmount * -0x800000;\n  if (7 < leadingZeroes) {\n    leadingZeroes = 0 << (shiftAmount & 0xff);\n    signBit = adjustedValue + (input << (shiftAmount & 0xff)) +\n            (0U >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < leadingZeroes);\n    if (leadingZeroes == 0x80000000) {\n      signBit = signBit & 0xfffffffe;\n    }\n    return signBit;\n  }\n  shiftAmount = input << leadingZeroes + 0x18;\n  signBit = adjustedValue + ((input >> (0x20 - (leadingZeroes + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n  if ((shiftAmount & 0x7fffffff) == 0) {\n    signBit = signBit & ~(shiftAmount >> 0x1f);\n  }\n  return signBit;\n}\n\n",
            "renaming": {
                "FUN_08000c10": "count_and_adjust_08000c10",
                "param_1": "input",
                "uVar1": "leadingZeroes",
                "uVar2": "shiftAmount",
                "uVar3": "signBit",
                "iVar4": "adjustedValue"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_08004ae0",
                "FUN_080049cc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cb8": {
            "entrypoint": "0x08000cb8",
            "current_name": "float_to_uint_bits_08000cb8",
            "code": "\nuint floatToUintBits_08000cb8(uint float1,uint float2,undefined4 intBits1,uint intBits2)\n\n{\n  longlong mulResult;\n  uint result;\n  uint float1Bits;\n  int exponentSum;\n  int exponentDiff;\n  uint mantissaMulResult;\n  int exponentDiffCopy;\n  uint float2Bits;\n  bool isZero;\n  bool carry;\n  \n  float1Bits = float1 >> 0x17 & 0xff;\n  isZero = float1Bits == 0;\n  if (!isZero) {\n    intBits2 = float2 >> 0x17 & 0xff;\n    isZero = intBits2 == 0;\n  }\n  if (!isZero) {\n    isZero = float1Bits == 0xff;\n  }\n  if (!isZero) {\n    isZero = intBits2 == 0xff;\n  }\n  if (isZero) {\n    intBits2 = float2 >> 0x17 & 0xff;\n    if (float1Bits == 0xff || intBits2 == 0xff) {\n      isZero = float1 == 0 || float1 == 0x80000000;\n      result = float2;\n      if (float1 != 0 && float1 != 0x80000000) {\n        isZero = float2 == 0;\n        result = float1;\n      }\n      if (!isZero) {\n        isZero = float2 == 0x80000000;\n      }\n      float2Bits = result;\n      if (((isZero) || ((float1Bits == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((intBits2 == 0xff && (float2Bits = float2, (float2 & 0x7fffff) != 0)))) {\n        return float2Bits | 0x7fc00000;\n      }\n      result = result ^ float2;\n      goto LAB_08000e08;\n    }\n    isZero = (float1 & 0x7fffffff) == 0;\n    if (!isZero) {\n      isZero = (float2 & 0x7fffffff) == 0;\n    }\n    if (isZero) {\n      return (float1 ^ float2) & 0x80000000;\n    }\n    isZero = float1Bits == 0;\n    result = float1 & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        float1 = float1 << 1;\n        isZero = (float1 & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      float1Bits = float1Bits - 1;\n    }\n    float1 = float1 | result;\n    isZero = intBits2 == 0;\n    result = float2 & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        float2 = float2 << 1;\n        isZero = (float2 & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      intBits2 = intBits2 - 1;\n    }\n    float2 = float2 | result;\n  }\n  exponentSum = float1Bits + intBits2;\n  float2Bits = float1 ^ float2;\n  float1Bits = float1 << 9;\n  isZero = float1Bits == 0;\n  if (!isZero) {\n    float2 = float2 << 9;\n    isZero = float2 == 0;\n  }\n  if (isZero) {\n    if (float1Bits == 0) {\n      float2 = float2 << 9;\n    }\n    result = float2Bits & 0x80000000 | float1 & 0x7fffff | float2 >> 9;\n    carry = signedBorrow(exponentSum,0x7f);\n    exponentDiff = exponentSum + -0x7f;\n    isZero = exponentDiff == 0;\n    exponentDiffCopy = exponentDiff;\n    if (!isZero && 0x7e < exponentSum) {\n      carry = signedBorrow(0xff,exponentDiff);\n      exponentDiffCopy = 0xff - exponentDiff;\n      isZero = exponentDiff == 0xff;\n    }\n    if (!isZero && exponentDiffCopy < 0 == carry) {\n      result = result | exponentDiff * 0x800000;\n    }\n    if (!isZero && exponentDiffCopy < 0 == carry) {\n      return result;\n    }\n    result = result | 0x800000;\n    mantissaMulResult = 0;\n    carry = signedBorrow(exponentDiff,1);\n    float2Bits = exponentSum - 0x80;\n    isZero = float2Bits == 0;\n    float1Bits = float2Bits;\n  }\n  else {\n    mulResult = (ulonglong)(float1Bits >> 5 | 0x8000000) * (ulonglong)(float2 >> 5 | 0x8000000);\n    mantissaMulResult = (uint)mulResult;\n    result = (uint)((ulonglong)mulResult >> 0x20);\n    isZero = result < 0x800000;\n    if (isZero) {\n      result = result << 1;\n    }\n    if (isZero) {\n      result = result | mantissaMulResult >> 0x1f;\n      mantissaMulResult = mantissaMulResult << 1;\n    }\n    result = float2Bits & 0x80000000 | result;\n    float2Bits = (exponentSum + -0x7f) - (uint)isZero;\n    carry = signedBorrow(float2Bits,0xfd);\n    isZero = float2Bits == 0xfd;\n    float1Bits = float2Bits - 0xfd;\n    if (float2Bits < 0xfe) {\n      result = result + float2Bits * 0x800000 + (uint)(0x7fffffff < mantissaMulResult);\n      if (mantissaMulResult == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (isZero || (int)float1Bits < 0 != carry) {\n    isZero = (int)(float2Bits + 0x19) < 0;\n    if (float2Bits == 0xffffffe7 || isZero != signedCarry(float2Bits,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (float2Bits != 0xffffffe7 && isZero == signedCarry(float2Bits,0x19)) {\n      float1Bits = (result << 1) >> (-float2Bits & 0xff);\n      float2Bits = result << (float2Bits + 0x20 & 0xff);\n      float1Bits = ((uint)((result & 0x80000000) != 0) << 0x1f | float1Bits >> 1) + (uint)((byte)float1Bits & 1);\n      if ((mantissaMulResult | float2Bits << 1) == 0) {\n        float1Bits = float1Bits & ~(float2Bits >> 0x1f);\n      }\n      return float1Bits;\n    }\n    return result;\n  }\nLAB_08000e08:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000cb8": "float_to_uint_bits_08000cb8",
                "param_1": "float1",
                "param_2": "float2",
                "param_3": "intBits1",
                "param_4": "intBits2",
                "lVar1": "mulResult",
                "uVar2": "result",
                "uVar3": "float1Bits",
                "iVar4": "exponentSum",
                "iVar5": "exponentDiff",
                "uVar6": "mantissaMulResult",
                "iVar7": "exponentDiffCopy",
                "uVar8": "float2Bits",
                "bVar9": "isZero",
                "bVar10": "carry",
                "SBORROW4": "signedBorrow",
                "SCARRY4": "signedCarry"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e20": {
            "entrypoint": "0x08000e20",
            "current_name": "calculate_floating_point_08000e20",
            "code": "\nuint calculateFloatingPoint_08000e20(uint input1,uint input2,undefined4 input3,uint input4)\n\n{\n  uint tempVar1;\n  uint tempVar2;\n  int tempVar3;\n  uint tempVar4;\n  int tempVar5;\n  uint tempVar6;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  \n  tempVar2 = input1 >> 0x17 & 0xff;\n  flag1 = tempVar2 == 0;\n  if (!flag1) {\n    input4 = input2 >> 0x17 & 0xff;\n    flag1 = input4 == 0;\n  }\n  if (!flag1) {\n    flag1 = tempVar2 == 0xff;\n  }\n  if (!flag1) {\n    flag1 = input4 == 0xff;\n  }\n  if (flag1) {\n    input4 = input2 >> 0x17 & 0xff;\n    tempVar6 = input1;\n    if (tempVar2 == 0xff) {\n      if (((input1 & 0x7fffff) != 0) || (tempVar6 = input2, input4 == 0xff)) {\nLAB_08000e16:\n        return tempVar6 | 0x7fc00000;\n      }\n    }\n    else {\n      if (input4 == 0xff) {\n        tempVar6 = input2;\n        if ((input2 & 0x7fffff) == 0) {\nLAB_08000dcc:\n          return (input1 ^ input2) & 0x80000000;\n        }\n        goto LAB_08000e16;\n      }\n      flag1 = (input1 & 0x7fffffff) == 0;\n      if (!flag1) {\n        flag1 = (input2 & 0x7fffffff) == 0;\n      }\n      if (!flag1) {\n        flag1 = tempVar2 == 0;\n        tempVar6 = input1 & 0x80000000;\n        while( true ) {\n          if (flag1) {\n            input1 = input1 << 1;\n            flag1 = (input1 & 0x800000) == 0;\n          }\n          if (!flag1) break;\n          tempVar2 = tempVar2 - 1;\n        }\n        input1 = input1 | tempVar6;\n        flag1 = input4 == 0;\n        tempVar6 = input2 & 0x80000000;\n        while( true ) {\n          if (flag1) {\n            input2 = input2 << 1;\n            flag1 = (input2 & 0x800000) == 0;\n          }\n          if (!flag1) break;\n          input4 = input4 - 1;\n        }\n        input2 = input2 | tempVar6;\n        goto LAB_08000e38;\n      }\n      if ((input1 & 0x7fffffff) == 0) {\n        if ((input2 & 0x7fffffff) != 0) goto LAB_08000dcc;\n        goto LAB_08000e16;\n      }\n    }\n    input1 = input1 ^ input2;\n  }\n  else {\nLAB_08000e38:\n    tempVar3 = tempVar2 - input4;\n    if (input2 << 9 == 0) {\n      input1 = (input1 ^ input2) & 0x80000000 | input1 & 0x7fffff;\n      flag3 = SCARRY4(tempVar3,0x7f);\n      tempVar5 = tempVar3 + 0x7f;\n      flag1 = tempVar5 < 0;\n      flag2 = tempVar5 == 0;\n      if (!flag2 && flag1 == flag3) {\n        flag3 = SBORROW4(0xff,tempVar5);\n        flag1 = 0xff - tempVar5 < 0;\n        flag2 = tempVar5 == 0xff;\n      }\n      if (!flag2 && flag1 == flag3) {\n        input1 = input1 | tempVar5 * 0x800000;\n      }\n      if (!flag2 && flag1 == flag3) {\n        return input1;\n      }\n      input1 = input1 | 0x800000;\n      tempVar2 = 0;\n      flag2 = SBORROW4(tempVar5,1);\n      tempVar4 = tempVar3 + 0x7e;\n      flag1 = tempVar4 == 0;\n      tempVar6 = tempVar4;\n    }\n    else {\n      tempVar1 = (input2 << 9) >> 4 | 0x10000000;\n      tempVar2 = (input1 << 9) >> 4 | 0x10000000;\n      input1 = (input1 ^ input2) & 0x80000000;\n      flag1 = tempVar1 <= tempVar2;\n      if (!flag1) {\n        tempVar2 = tempVar2 << 1;\n      }\n      tempVar4 = tempVar3 + 0x7d + (uint)flag1;\n      tempVar6 = 0x800000;\n      do {\n        if (tempVar1 <= tempVar2) {\n          tempVar2 = tempVar2 - tempVar1;\n          input1 = input1 | tempVar6;\n        }\n        flag1 = tempVar1 >> 1 <= tempVar2;\n        if (flag1) {\n          tempVar2 = tempVar2 - (tempVar1 >> 1);\n        }\n        if (flag1) {\n          input1 = input1 | tempVar6 >> 1;\n        }\n        flag1 = tempVar1 >> 2 <= tempVar2;\n        if (flag1) {\n          tempVar2 = tempVar2 - (tempVar1 >> 2);\n        }\n        if (flag1) {\n          input1 = input1 | tempVar6 >> 2;\n        }\n        flag1 = tempVar1 >> 3 <= tempVar2;\n        if (flag1) {\n          tempVar2 = tempVar2 - (tempVar1 >> 3);\n        }\n        if (flag1) {\n          input1 = input1 | tempVar6 >> 3;\n        }\n        tempVar2 = tempVar2 * 0x10;\n        flag1 = tempVar2 == 0;\n        if (!flag1) {\n          tempVar6 = tempVar6 >> 4;\n          flag1 = tempVar6 == 0;\n        }\n      } while (!flag1);\n      flag2 = SBORROW4(tempVar4,0xfd);\n      flag1 = tempVar4 == 0xfd;\n      tempVar6 = tempVar4 - 0xfd;\n      if (tempVar4 < 0xfe) {\n        input1 = input1 + tempVar4 * 0x800000 + (uint)(tempVar1 <= tempVar2);\n        if (tempVar2 - tempVar1 == 0) {\n          input1 = input1 & 0xfffffffe;\n        }\n        return input1;\n      }\n    }\n    if (flag1 || (int)tempVar6 < 0 != flag2) {\n      flag1 = (int)(tempVar4 + 0x19) < 0;\n      if (tempVar4 == 0xffffffe7 || flag1 != SCARRY4(tempVar4,0x19)) {\n        input1 = input1 & 0x80000000;\n      }\n      if (tempVar4 == 0xffffffe7 || flag1 != SCARRY4(tempVar4,0x19)) {\n        return input1;\n      }\n      tempVar6 = (input1 << 1) >> (-tempVar4 & 0xff);\n      tempVar4 = input1 << (tempVar4 + 0x20 & 0xff);\n      tempVar6 = ((uint)((input1 & 0x80000000) != 0) << 0x1f | tempVar6 >> 1) + (uint)((byte)tempVar6 & 1);\n      if ((tempVar2 | tempVar4 << 1) == 0) {\n        tempVar6 = tempVar6 & ~(tempVar4 >> 0x1f);\n      }\n      return tempVar6;\n    }\n  }\n  return input1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000e20": "calculate_floating_point_08000e20",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "iVar3": "tempVar3",
                "uVar4": "tempVar4",
                "iVar5": "tempVar5",
                "uVar6": "tempVar6",
                "bVar7": "flag1",
                "bVar8": "flag2",
                "bVar9": "flag3"
            },
            "calling": [
                "FUN_080049cc",
                "FUN_08004d78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f68": {
            "entrypoint": "0x08000f68",
            "current_name": "calculate_result_08000f68",
            "code": "\nuint calculate_result_08000f68(uint number1,uint number2)\n\n{\n  bool is_negative_result;\n  uint number1_times_2;\n  uint number2_times_2;\n  uint or_result;\n  bool is_result_zero;\n  \n  number1_times_2 = number1 * 2;\n  number2_times_2 = number2 * 2;\n  if (((int)number1_times_2 >> 0x18 == -1 || (int)number2_times_2 >> 0x18 == -1) &&\n     ((((int)number1_times_2 >> 0x18 == -1 && ((number1 & 0x7fffff) != 0)) ||\n      (((int)number2_times_2 >> 0x18 == -1 && ((number2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  or_result = number1_times_2 | number2 & 0x7fffffff;\n  is_result_zero = or_result == 0;\n  if (!is_result_zero) {\n    or_result = number1 ^ number2;\n    is_result_zero = or_result == 0;\n  }\n  is_negative_result = -1 < (int)or_result;\n  if (is_negative_result) {\n    number1 = number1_times_2 + number2 * -2;\n    is_result_zero = number1 == 0;\n  }\n  if ((is_negative_result && number2_times_2 <= number1_times_2) && !is_result_zero) {\n    number1 = (int)number2 >> 0x1f;\n  }\n  if (!is_negative_result || number2_times_2 > number1_times_2) {\n    number1 = ~((int)number2 >> 0x1f);\n  }\n  if (!is_result_zero) {\n    number1 = number1 | 1;\n  }\n  return number1;\n}\n\n",
            "renaming": {
                "FUN_08000f68": "calculate_result_08000f68",
                "param_1": "number1",
                "param_2": "number2",
                "bVar1": "is_negative_result",
                "uVar2": "number1_times_2",
                "uVar3": "number2_times_2",
                "uVar4": "or_result",
                "bVar5": "is_result_zero"
            },
            "calling": [
                "FUN_08000fd0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fc8": {
            "entrypoint": "0x08000fc8",
            "current_name": "concatenate_parameters_08000fc8",
            "code": "\nvoid concatenateParameters_08000fc8(undefined4 sourceParam,undefined4 targetParam)\n\n{\n  concatenate_parameters_08000fd0(targetParam,sourceParam);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fc8": "concatenate_parameters_08000fc8",
                "param_1": "sourceParam",
                "param_2": "targetParam"
            },
            "calling": [
                "FUN_08001030"
            ],
            "called": [
                "FUN_08000fd0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fd0": {
            "entrypoint": "0x08000fd0",
            "current_name": "concatenate_parameters_08000fd0",
            "code": "\nundefined8 concatenate_parameters_08000fd0(undefined4 first_parameter,undefined4 second_parameter)\n\n{\n  calculate_result();\n  return CONCAT44(second_parameter,first_parameter);\n}\n\n",
            "renaming": {
                "FUN_08000fd0": "concatenate_parameters_08000fd0",
                "param_1": "first_parameter",
                "param_2": "second_parameter",
                "calculate_result_08000f68": "calculate_result"
            },
            "calling": [
                "FUN_08000fc8",
                "FUN_08000ff4"
            ],
            "called": [
                "FUN_08000f68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ff4": {
            "entrypoint": "0x08000ff4",
            "current_name": "check_if_concatenation_complete_08000ff4",
            "code": "\nbool check_if_concatenation_complete_08000ff4(void)\n\n{\n  char concatenation_result;\n  \n  concatenate_parameters_08000fd0();\n  return concatenation_result == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000ff4": "check_if_concatenation_complete_08000ff4",
                "in_CY": "concatenation_result"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08000fd0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001030": {
            "entrypoint": "0x08001030",
            "current_name": "check_if_concatenation_is_empty_08001030",
            "code": "\nbool check_if_concatenation_is_empty_08001030(void)\n\n{\n  char concatenation_result;\n  \n  concatenate_parameters_08000fc8();\n  return concatenation_result == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001030": "check_if_concatenation_is_empty_08001030",
                "in_CY": "concatenation_result"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08000fc8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001044": {
            "entrypoint": "0x08001044",
            "current_name": "validate_param_08001044",
            "code": "\nuint validate_param_08001044(uint input)\n\n{\n  uint shift_amount;\n  \n  if (((input & 0x80000000) != 0) || (input << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shift_amount = 0x9e - ((input << 1) >> 0x18);\n  if (-1 < (int)shift_amount) {\n    return (input << 8 | 0x80000000) >> (shift_amount & 0xff);\n  }\n  if ((shift_amount == 0xffffff9f) && ((input & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08001044": "validate_param_08001044",
                "param_1": "input",
                "uVar1": "shift_amount"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001084": {
            "entrypoint": "0x08001084",
            "current_name": "copy_memory_08001084",
            "code": "\nfourbyte * copyMemory_08001084(fourbyte *dest,fourbyte *src,uint size)\n\n{\n  fourbyte *dest_ptr;\n  fourbyte *dest_ptr_temp;\n  fourbyte *src_ptr;\n  uint remain_size;\n  uint loop_count;\n  bool is_looping;\n  \n  dest_ptr_temp = dest;\n  if ((((uint)src | (uint)dest) & 3) != 0) {\n    if (size < 8) {\n      loop_count = size - 4;\n      if (3 < size) {\n        do {\n          dest_ptr = src;\n          src_ptr = dest_ptr_temp;\n          is_looping = loop_count != 0;\n          loop_count = loop_count - 1;\n          *(undefined *)src_ptr = *(undefined *)dest_ptr;\n          dest_ptr_temp = (fourbyte *)((int)src_ptr + 1);\n          src = (fourbyte *)((int)dest_ptr + 1);\n        } while (is_looping);\n        *(undefined *)(fourbyte *)((int)src_ptr + 1) =\n             *(undefined *)(fourbyte *)((int)dest_ptr + 1);\n        *(undefined *)((int)src_ptr + 2) = *(undefined *)((int)dest_ptr + 2);\n        *(undefined *)((int)src_ptr + 3) = *(undefined *)((int)dest_ptr + 3);\n        return dest;\n      }\n      goto copy_remaining;\n    }\n    if ((((uint)src & 3) != 0) && (((uint)dest & 3) != 0)) {\n      loop_count = 4 - ((uint)dest & 3);\n      size = size - loop_count;\n      dest_ptr = dest;\n      src_ptr = src;\n      if (((uint)dest & 1) != 0) {\n        src_ptr = (fourbyte *)((int)src + 1);\n        dest_ptr = (fourbyte *)((int)dest + 1);\n        *(undefined *)dest = *(undefined *)src;\n      }\n      dest_ptr_temp = dest_ptr;\n      src = src_ptr;\n      if ((loop_count & 2) != 0) {\n        src = (fourbyte *)((int)src_ptr + 2);\n        dest_ptr_temp = (fourbyte *)((int)dest_ptr + 2);\n        *(undefined2 *)dest_ptr = *(undefined2 *)src_ptr;\n      }\n    }\n  }\n  while (0x3f < size) {\n    *dest_ptr_temp = *src;\n    dest_ptr_temp[1] = src[1];\n    dest_ptr_temp[2] = src[2];\n    dest_ptr_temp[3] = src[3];\n    dest_ptr_temp[4] = src[4];\n    dest_ptr_temp[5] = src[5];\n    dest_ptr_temp[6] = src[6];\n    dest_ptr_temp[7] = src[7];\n    dest_ptr_temp[8] = src[8];\n    dest_ptr_temp[9] = src[9];\n    dest_ptr_temp[10] = src[10];\n    dest_ptr_temp[0xb] = src[0xb];\n    dest_ptr_temp[0xc] = src[0xc];\n    dest_ptr_temp[0xd] = src[0xd];\n    dest_ptr_temp[0xe] = src[0xe];\n    dest_ptr_temp[0xf] = src[0xf];\n    dest_ptr_temp = dest_ptr_temp + 0x10;\n    src = src + 0x10;\n    size = size - 0x40;\n  }\n  remain_size = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n      *dest_ptr_temp = *src;\n      dest_ptr_temp[1] = src[1];\n      dest_ptr_temp[2] = src[2];\n      dest_ptr_temp[3] = src[3];\n      dest_ptr_temp = dest_ptr_temp + 4;\n      src = src + 4;\n      is_looping = 0xf < remain_size;\n      remain_size = remain_size - 0x10;\n    } while (is_looping);\n  }\n  loop_count = remain_size + 0xc;\n  src_ptr = dest_ptr_temp;\n  dest_ptr = src;\n  if (0xfffffff3 < remain_size) {\n    do {\n      src = dest_ptr + 1;\n      *src_ptr = *dest_ptr;\n      is_looping = 3 < loop_count;\n      loop_count = loop_count - 4;\n      dest_ptr_temp = src_ptr + 1;\n      src_ptr = src_ptr + 1;\n      dest_ptr = src;\n    } while (is_looping);\n  }\ncopy_remaining:\n  if (loop_count + 4 != 0) {\n    dest_ptr = dest_ptr_temp;\n    src_ptr = src;\n    if ((loop_count & 1) != 0) {\n      src_ptr = (fourbyte *)((int)src + 1);\n      dest_ptr = (fourbyte *)((int)dest_ptr_temp + 1);\n      *(undefined *)dest_ptr_temp = *(undefined *)src;\n    }\n    if ((loop_count + 4 & 2) != 0) {\n      *(undefined2 *)dest_ptr = *(undefined2 *)src_ptr;\n    }\n  }\n  return dest;\n}\n\n",
            "renaming": {
                "FUN_08001084": "copy_memory_08001084",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "size",
                "puVar1": "dest_ptr",
                "puVar2": "dest_ptr_temp",
                "puVar3": "src_ptr",
                "uVar4": "remain_size",
                "uVar5": "loop_count",
                "bVar6": "is_looping",
                "LAB_08001108": "copy_remaining",
                "undefined4": "fourbyte"
            },
            "calling": [
                "FUN_08009120",
                "FUN_080097cc",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001170": {
            "entrypoint": "0x08001170",
            "current_name": "check_parameters_08001170",
            "code": "\nundefined4 check_parameters_08001170(uint value1,int value2,uint value3,int value4)\n\n{\n  if ((((value2 << 1) >> 0x15 != -1) || ((value1 | value2 << 0xc) == 0)) &&\n     (((value4 << 1) >> 0x15 != -1 || ((value3 | value4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08001170": "check_parameters_08001170",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800119c": {
            "entrypoint": "0x0800119c",
            "current_name": "calculate_signed_divisor_0800119c",
            "code": "\nuint calculate_signed_divisor_0800119c(uint dividend,uint divisor)\n\n{\n  uint divisor_shifted;\n  int multiplier;\n  uint subtraction_result;\n  \n  multiplier = divisor * 2 + 0x200000;\n  if (divisor * 2 < 0xffe00000) {\n    if (-1 < multiplier) {\n      return 0;\n    }\n    divisor_shifted = multiplier >> 0x15;\n    subtraction_result = -divisor_shifted - 0x3e1;\n    if (divisor_shifted < 0xfffffc20 && subtraction_result != 0) {\n      divisor_shifted = (divisor << 0xb | 0x80000000 | dividend >> 0x15) >> (subtraction_result & 0xff);\n      if ((divisor & 0x80000000) != 0) {\n        divisor_shifted = -divisor_shifted;\n      }\n      return divisor_shifted;\n    }\n  }\n  else if ((dividend | divisor << 0xc) != 0) {\n    return 0;\n  }\n  divisor = divisor & 0x80000000;\n  if (divisor == 0) {\n    divisor = 0x7fffffff;\n  }\n  return divisor;\n}\n\n",
            "renaming": {
                "FUN_0800119c": "calculate_signed_divisor_0800119c",
                "param_1": "dividend",
                "param_2": "divisor",
                "uVar1": "divisor_shifted",
                "iVar2": "multiplier",
                "uVar3": "subtraction_result"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011ec": {
            "entrypoint": "0x080011ec",
            "current_name": "calculate_result_080011ec",
            "code": "\nundefined8 calculate_result_080011ec(int input_1,int input_2,int input_3,int input_4)\n\n{\n  undefined8 result;\n  \n  if ((input_4 == 0) && (input_3 == 0)) {\n    if (input_2 != 0 || input_1 != 0) {\n      input_2 = -1;\n      input_1 = -1;\n    }\n    return CONCAT44(input_2,input_1);\n  }\n  result = divide_and_modulus_0800121c();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080011ec": "calculate_result_080011ec",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "result"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_0800121c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800121c": {
            "entrypoint": "0x0800121c",
            "current_name": "divide_and_modulus_0800121c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080014b2) */\n\nundefined8 divideAndModulus_0800121c(uint dividend,uint divisor,uint upperDividend,uint lowerDividend,uint *remainderAndQuotient)\n\n{\n  code *unrecoveredJumpTable;\n  ulonglong temp;\n  uint quotient1;\n  uint quotient2;\n  uint remainder1;\n  int shiftCount;\n  uint quotient3;\n  uint currDividend;\n  uint remainder2;\n  uint *puVar9;\n  uint quotient4;\n  uint upperQuotient;\n  uint remainder3;\n  bool carryFlag;\n  undefined8 result;\n  \n  if (lowerDividend == 0) {\n    if (divisor < upperDividend) {\n      shiftCount = LZCOUNT(upperDividend);\n      currDividend = upperDividend;\n      if (shiftCount != 0) {\n        currDividend = upperDividend << shiftCount;\n        divisor = dividend >> (0x20U - shiftCount & 0xff) | divisor << shiftCount;\n        dividend = dividend << shiftCount;\n      }\n      upperQuotient = currDividend >> 0x10;\n      remainder2 = divisor / upperQuotient;\n      quotient4 = remainder2 * (currDividend & 0xffff);\n      quotient3 = dividend >> 0x10 | (divisor - upperQuotient * remainder2) * 0x10000;\n      quotient2 = remainder2;\n      if (quotient3 <= quotient4 && quotient4 - quotient3 != 0) {\n        carryFlag = CARRY4(currDividend,quotient3);\n        quotient3 = currDividend + quotient3;\n        quotient2 = remainder2 - 1;\n        if ((carryFlag == false) && (quotient3 <= quotient4 && quotient4 - quotient3 != 0)) {\n          quotient2 = remainder2 - 2;\n          quotient3 = quotient3 + currDividend;\n        }\n      }\n      quotient1 = (quotient3 - quotient4) / upperQuotient;\n      remainder1 = quotient1 * (currDividend & 0xffff);\n      remainder2 = dividend & 0xffff | ((quotient3 - quotient4) - upperQuotient * quotient1) * 0x10000;\n      quotient3 = quotient1;\n      if (remainder2 <= remainder1 && remainder1 - remainder2 != 0) {\n        carryFlag = CARRY4(currDividend,remainder2);\n        remainder2 = currDividend + remainder2;\n        quotient3 = quotient1 - 1;\n        if ((carryFlag == false) && (remainder2 <= remainder1 && remainder1 - remainder2 != 0)) {\n          quotient3 = quotient1 - 2;\n          remainder2 = remainder2 + currDividend;\n        }\n      }\n      quotient3 = quotient3 | quotient2 << 0x10;\n      puVar9 = (uint *)0x0;\n      remainder2 = remainder2 - remainder1;\n    }\n    else {\n      if (upperDividend == 0) {\n                    /* WARNING: Treating indirect jump as call */\n        unrecoveredJumpTable = (code *)software_udf(0xff,0x8001302);\n        result = (*unrecoveredJumpTable)();\n        return result;\n      }\n      shiftCount = LZCOUNT(upperDividend);\n      if (shiftCount == 0) {\n        puVar9 = (uint *)0x1;\n        divisor = divisor - upperDividend;\n        upperQuotient = upperDividend >> 0x10;\n        quotient1 = upperDividend & 0xffff;\n        currDividend = upperDividend;\n      }\n      else {\n        currDividend = upperDividend << shiftCount;\n        quotient3 = divisor >> (0x20U - shiftCount & 0xff);\n        upperQuotient = currDividend >> 0x10;\n        quotient4 = quotient3 / upperQuotient;\n        quotient1 = currDividend & 0xffff;\n        remainder1 = quotient4 * quotient1;\n        remainder2 = dividend >> (0x20U - shiftCount & 0xff) | divisor << shiftCount;\n        quotient2 = remainder2 >> 0x10 | (quotient3 - upperQuotient * quotient4) * 0x10000;\n        dividend = dividend << shiftCount;\n        quotient3 = quotient4;\n        if (quotient2 <= remainder1 && remainder1 - quotient2 != 0) {\n          carryFlag = CARRY4(currDividend,quotient2);\n          quotient2 = currDividend + quotient2;\n          quotient3 = quotient4 - 1;\n          if ((carryFlag == false) && (quotient2 <= remainder1 && remainder1 - quotient2 != 0)) {\n            quotient3 = quotient4 - 2;\n            quotient2 = quotient2 + currDividend;\n          }\n        }\n        quotient4 = (quotient2 - remainder1) / upperQuotient;\n        remainder3 = quotient4 * quotient1;\n        divisor = remainder2 & 0xffff | ((quotient2 - remainder1) - upperQuotient * quotient4) * 0x10000;\n        quotient2 = quotient4;\n        if (divisor <= remainder3 && remainder3 - divisor != 0) {\n          carryFlag = CARRY4(currDividend,divisor);\n          divisor = currDividend + divisor;\n          quotient2 = quotient4 - 1;\n          if ((carryFlag == false) && (divisor <= remainder3 && remainder3 - divisor != 0)) {\n            quotient2 = quotient4 - 2;\n            divisor = divisor + currDividend;\n          }\n        }\n        divisor = divisor - remainder3;\n        puVar9 = (uint *)(quotient2 | quotient3 << 0x10);\n      }\n      quotient4 = divisor / upperQuotient;\n      quotient3 = quotient1 * quotient4;\n      remainder2 = dividend >> 0x10 | (divisor - upperQuotient * quotient4) * 0x10000;\n      quotient2 = quotient4;\n      if (remainder2 <= quotient3 && quotient3 - remainder2 != 0) {\n        carryFlag = CARRY4(currDividend,remainder2);\n        remainder2 = currDividend + remainder2;\n        quotient2 = quotient4 - 1;\n        if ((carryFlag == false) && (remainder2 <= quotient3 && quotient3 - remainder2 != 0)) {\n          quotient2 = quotient4 - 2;\n          remainder2 = remainder2 + currDividend;\n        }\n      }\n      quotient4 = (remainder2 - quotient3) / upperQuotient;\n      quotient1 = quotient1 * quotient4;\n      remainder2 = dividend & 0xffff | ((remainder2 - quotient3) - upperQuotient * quotient4) * 0x10000;\n      quotient3 = quotient4;\n      if (remainder2 <= quotient1 && quotient1 - remainder2 != 0) {\n        carryFlag = CARRY4(currDividend,remainder2);\n        remainder2 = currDividend + remainder2;\n        quotient3 = quotient4 - 1;\n        if ((carryFlag == false) && (remainder2 <= quotient1 && quotient1 - remainder2 != 0)) {\n          quotient3 = quotient4 - 2;\n          remainder2 = remainder2 + currDividend;\n        }\n      }\n      remainder2 = remainder2 - quotient1;\n      quotient3 = quotient3 | quotient2 << 0x10;\n    }\n    if (remainderAndQuotient != (uint *)0x0) {\n      *remainderAndQuotient = remainder2 >> LZCOUNT(upperDividend);\n      remainderAndQuotient[1] = 0;\n    }\n  }\n  else {\n    puVar9 = remainderAndQuotient;\n    if (divisor < lowerDividend) {\n      if (remainderAndQuotient != (uint *)0x0) {\n        *remainderAndQuotient = dividend;\n        remainderAndQuotient[1] = divisor;\n        return 0;\n      }\n      quotient3 = 0;\n    }\n    else {\n      shiftCount = LZCOUNT(lowerDividend);\n      if (shiftCount == 0) {\n        if ((lowerDividend < divisor) || (upperDividend <= dividend)) {\n          carryFlag = dividend < upperDividend;\n          dividend = dividend - upperDividend;\n          divisor = (divisor - lowerDividend) - (uint)carryFlag;\n          quotient3 = 1;\n        }\n        else {\n          quotient3 = 0;\n        }\n        puVar9 = (uint *)0x0;\n        if (remainderAndQuotient != (uint *)0x0) {\n          *remainderAndQuotient = dividend;\n          remainderAndQuotient[1] = divisor;\n        }\n      }\n      else {\n        remainder2 = 0x20 - shiftCount;\n        quotient1 = upperDividend >> (remainder2 & 0xff) | lowerDividend << shiftCount;\n        currDividend = divisor >> (remainder2 & 0xff);\n        remainder1 = quotient1 >> 0x10;\n        quotient4 = currDividend / remainder1;\n        upperQuotient = quotient4 * (quotient1 & 0xffff);\n        quotient3 = divisor << shiftCount | dividend >> (remainder2 & 0xff);\n        quotient2 = quotient3 >> 0x10 | (currDividend - remainder1 * quotient4) * 0x10000;\n        dividend = dividend << shiftCount;\n        currDividend = quotient4;\n        if (quotient2 <= upperQuotient && upperQuotient - quotient2 != 0) {\n          carryFlag = CARRY4(quotient1,quotient2);\n          quotient2 = quotient1 + quotient2;\n          currDividend = quotient4 - 1;\n          if ((carryFlag == false) && (quotient2 <= upperQuotient && upperQuotient - quotient2 != 0)) {\n            currDividend = quotient4 - 2;\n            quotient2 = quotient2 + quotient1;\n          }\n        }\n        quotient4 = (quotient2 - upperQuotient) / remainder1;\n        remainder3 = quotient4 * (quotient1 & 0xffff);\n        quotient2 = quotient3 & 0xffff | ((quotient2 - upperQuotient) - remainder1 * quotient4) * 0x10000;\n        quotient3 = quotient4;\n        if (quotient2 <= remainder3 && remainder3 - quotient2 != 0) {\n          carryFlag = CARRY4(quotient1,quotient2);\n          quotient2 = quotient1 + quotient2;\n          quotient3 = quotient4 - 1;\n          if ((carryFlag == false) && (quotient2 <= remainder3 && remainder3 - quotient2 != 0)) {\n            quotient3 = quotient4 - 2;\n            quotient2 = quotient2 + quotient1;\n          }\n        }\n        quotient3 = quotient3 | currDividend << 0x10;\n        temp = (ulonglong)quotient3 * (ulonglong)(upperDividend << shiftCount);\n        if (CONCAT44(quotient2 - remainder3,dividend) < temp) {\n          quotient3 = quotient3 - 1;\n          temp = temp - CONCAT44(quotient1,upperDividend << shiftCount);\n        }\n        if (remainderAndQuotient != (uint *)0x0) {\n          currDividend = ((quotient2 - remainder3) - (int)(temp >> 0x20)) - (uint)(dividend < (uint)temp);\n          *remainderAndQuotient = currDividend << (remainder2 & 0xff) | dividend - (uint)temp >> shiftCount;\n          remainderAndQuotient[1] = currDividend >> shiftCount;\n          puVar9 = (uint *)0x0;\n        }\n      }\n    }\n  }\n  return CONCAT44(puVar9,quotient3);\n}\n\n",
            "renaming": {
                "FUN_0800121c": "divide_and_modulus_0800121c",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "upperDividend",
                "param_4": "lowerDividend",
                "param_5": "remainderAndQuotient",
                "UNRECOVERED_JUMPTABLE": "unrecoveredJumpTable",
                "uVar1": "temp",
                "uVar2": "quotient1",
                "uVar3": "quotient2",
                "uVar4": "remainder1",
                "uVar6": "quotient3",
                "uVar7": "currDividend",
                "uVar8": "remainder2",
                "uVar10": "quotient4",
                "uVar11": "upperQuotient",
                "uVar12": "remainder3",
                "iVar5": "shiftCount",
                "bVar13": "carryFlag",
                "uVar14": "result"
            },
            "calling": [
                "FUN_080011ec"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014f0": {
            "entrypoint": "0x080014f0",
            "current_name": "initialize_system_080014f0",
            "code": "\n\n\nundefined4 initialize_system_080014f0(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  set_interrupt_bit(3);\n  initialize_data(0xf);\n  FUNC_08002d8a();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080014f0": "initialize_system_080014f0",
                "set_e000ed0c_bit_08001714": "set_interrupt_bit",
                "initialize_and_check_data_0800151c": "initialize_data"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_0800151c",
                "FUN_08002d8a",
                "FUN_08001714"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800151c": {
            "entrypoint": "0x0800151c",
            "current_name": "initialize_and_check_data_0800151c",
            "code": "\nundefined4 initialize_and_check_data_0800151c(uint input_value)\n\n{\n  int data_initialization_result;\n  undefined4 return_value;\n  \n  data_initialization_result = initialize_data_08001762((int)((ulonglong)DAT_20000018 / (1000 / (ulonglong)DAT_20000004)));\n  if (data_initialization_result == 0) {\n    if (input_value < 0x10) {\n      store_byte_value_0800172a(0xffffffff,input_value,0);\n      return_value = 0;\n      DAT_20000000 = input_value;\n    }\n    else {\n      return_value = 1;\n    }\n  }\n  else {\n    return_value = 1;\n  }\n  return return_value;\n}\n\n",
            "renaming": {
                "FUN_0800151c": "initialize_and_check_data_0800151c",
                "param_1": "input_value",
                "iVar1": "data_initialization_result",
                "uVar2": "return_value"
            },
            "calling": [
                "FUN_080014f0",
                "FUN_08003260"
            ],
            "called": [
                "FUN_0800172a",
                "FUN_08001762"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800157c": {
            "entrypoint": "0x0800157c",
            "current_name": "increment_data_value_0800157c",
            "code": "\nvoid incrementDataValue_0800157c(void)\n\n{\n  DAT_20000a48 = DAT_20000a48 + (uint)DAT_20000004;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800157c": "increment_data_value_0800157c"
            },
            "calling": [
                "FUN_08005704"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015a0": {
            "entrypoint": "0x080015a0",
            "current_name": "get_value_from_global_variable_080015a0",
            "code": "\nundefined4 get_value_from_global_variable_080015a0(void)\n\n{\n  return DAT_20000a48;\n}\n\n",
            "renaming": {
                "FUN_080015a0": "get_value_from_global_variable_080015a0"
            },
            "calling": [
                "FUN_08004436",
                "FUN_08001ccc",
                "FUN_08002c2e",
                "FUN_080027f4",
                "FUN_08002ca8",
                "FUN_08002bb4",
                "FUN_08002ad8",
                "FUN_08004f2c",
                "FUN_08002d98",
                "FUN_08003260",
                "FUN_08002640",
                "FUN_08001f6c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b4": {
            "entrypoint": "0x080015b4",
            "current_name": "set_e000ed0c_bit_080015b4",
            "code": "\n\n\nvoid set_e000ed0c_bit_080015b4(uint value)\n\n{\n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | (value & 7) << 8 | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b4": "set_e000ed0c_bit_080015b4",
                "param_1": "value"
            },
            "calling": [
                "FUN_08001714"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015fc": {
            "entrypoint": "0x080015fc",
            "current_name": "get_bits_from_e000_ed0_c_080015fc",
            "code": "\n\n\nuint getBitsFromE000ED0C_080015fc(void)\n\n{\n  return _DAT_e000ed0c >> 8 & 7;\n}\n\n",
            "renaming": {
                "FUN_080015fc": "get_bits_from_e000_ed0_c_080015fc"
            },
            "calling": [
                "FUN_0800172a"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001618": {
            "entrypoint": "0x08001618",
            "current_name": "store_byte_value_08001618",
            "code": "\nvoid storeByteValue_08001618(byte inputByte,uint data)\n\n{\n  if ((char)inputByte < '\\0') {\n    *(char *)((inputByte & 0xf) + 0xe000ed14) = (char)((data & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)inputByte + -0x1fff1c00) = (char)((data & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001618": "store_byte_value_08001618",
                "param_1": "inputByte",
                "param_2": "data"
            },
            "calling": [
                "FUN_0800172a",
                "FUN_080016d0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800166c": {
            "entrypoint": "0x0800166c",
            "current_name": "bitwise_combination_0800166c",
            "code": "\nuint bitwiseCombination_0800166c(uint bitsToShiftMask,uint bitsToCopy,uint bitsToCopyShifted)\n\n{\n  uint bitsToSet;\n  \n  bitsToShiftMask = bitsToShiftMask & 7;\n  bitsToSet = 7 - bitsToShiftMask;\n  if (3 < bitsToSet) {\n    bitsToSet = 4;\n  }\n  if (bitsToShiftMask + 4 < 7) {\n    bitsToShiftMask = 0;\n  }\n  else {\n    bitsToShiftMask = bitsToShiftMask - 3;\n  }\n  return bitsToCopyShifted & ~(-1 << (bitsToShiftMask & 0xff)) |\n         (~(-1 << (bitsToSet & 0xff)) & bitsToCopy) << (bitsToShiftMask & 0xff);\n}\n\n",
            "renaming": {
                "FUN_0800166c": "bitwise_combination_0800166c",
                "param_1": "bitsToShiftMask",
                "param_2": "bitsToCopy",
                "param_3": "bitsToCopyShifted",
                "uVar1": "bitsToSet"
            },
            "calling": [
                "FUN_0800172a"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016d0": {
            "entrypoint": "0x080016d0",
            "current_name": "initialize_data_080016d0",
            "code": "\n\n\nbool initializeData_080016d0(int dataValue)\n\n{\n  bool isDataValid;\n  \n  isDataValid = dataValue - 1U < 0x1000000;\n  if (isDataValid) {\n    _DAT_e000e014 = dataValue + -1;\n    store_byte_value_08001618(0xffffffff,0xf);\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n  }\n  return !isDataValid;\n}\n\n",
            "renaming": {
                "FUN_080016d0": "initialize_data_080016d0",
                "param_1": "dataValue",
                "bVar1": "isDataValid"
            },
            "calling": [
                "FUN_08001762"
            ],
            "called": [
                "FUN_08001618"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001714": {
            "entrypoint": "0x08001714",
            "current_name": "set_e000ed0c_bit_08001714",
            "code": "\nvoid set_e000ed0c_bit_08001714(undefined4 input_param)\n\n{\n  set_e000ed0c_bit_08001714_080015b4(input_param);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001714": "set_e000ed0c_bit_08001714",
                "param_1": "input_param"
            },
            "calling": [
                "FUN_080014f0"
            ],
            "called": [
                "FUN_080015b4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800172a": {
            "entrypoint": "0x0800172a",
            "current_name": "store_byte_value_0800172a",
            "code": "\nvoid storeByteValue_0800172a(char byteValue,undefined4 value1,undefined4 value2)\n\n{\n  undefined4 bits;\n  \n  bits = getBits();\n  bits = combineBits(bits,value1,value2);\n  storeByte((int)byteValue,bits);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800172a": "store_byte_value_0800172a",
                "param_1": "byteValue",
                "param_2": "value1",
                "param_3": "value2",
                "uVar1": "bits",
                "get_bits_from_e000_ed0_c_080015fc": "getBits",
                "bitwise_combination_0800166c": "combineBits",
                "store_byte_value_08001618": "storeByte"
            },
            "calling": [
                "FUN_0800151c",
                "FUN_080052a0"
            ],
            "called": [
                "FUN_08001618",
                "FUN_080015fc",
                "FUN_0800166c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001762": {
            "entrypoint": "0x08001762",
            "current_name": "initialize_data_08001762",
            "code": "\nundefined4 initialize_data_08001762(undefined4 data)\n\n{\n  undefined4 status;\n  \n  status = initialize_data_08001762_080016d0(data);\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001762": "initialize_data_08001762",
                "param_1": "data",
                "uVar1": "status"
            },
            "calling": [
                "FUN_0800151c",
                "FUN_080052a0"
            ],
            "called": [
                "FUN_080016d0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800177c": {
            "entrypoint": "0x0800177c",
            "current_name": "set_flag_0800177c",
            "code": "\n\n\nvoid setFlag_0800177c(int flagValue)\n\n{\n  if (flagValue == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800177c": "set_flag_0800177c",
                "param_1": "flagValue"
            },
            "calling": [
                "FUN_080052a0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017b4": {
            "entrypoint": "0x080017b4",
            "current_name": "process_initial_data_080017b4",
            "code": "\nvoid processInitialData_080017b4(void)\n\n{\n  processData(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080017b4": "process_initial_data_080017b4",
                "process_data_08004f78": "processData"
            },
            "calling": [
                "FUN_08005704"
            ],
            "called": [
                "FUN_08004f78"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017c4": {
            "entrypoint": "0x080017c4",
            "current_name": "update_parameter_bits_080017c4",
            "code": "\n\n\nvoid updateParameterBits_080017c4(uint *outputParameters,uint *inputParameters)\n\n{\n  uint bitMask;\n  uint bitValue;\n  uint opcode;\n  uint *outputPtr;\n  int index;\n  uint valueToUpdate;\n  uint bitIndex;\n  \n  valueToUpdate = 0;\n  bitIndex = 0;\n  do {\n    if (0xf < bitIndex) {\n      return;\n    }\n    bitMask = 1 << (bitIndex & 0xff);\n    bitValue = *inputParameters & bitMask;\n    if (bitValue == bitMask) {\n      opcode = inputParameters[1];\n      if (opcode == 0x12) {\n        valueToUpdate = inputParameters[3] + 0xc;\n      }\n      else if (opcode < 0x13) {\n        if (opcode == 2) {\n          valueToUpdate = inputParameters[3] + 8;\n        }\n        else if (opcode < 3) {\n          if (opcode == 0) goto LAB_08001882;\n          if (opcode == 1) {\n            valueToUpdate = inputParameters[3];\n          }\n        }\n        else if (opcode == 3) {\n          valueToUpdate = 0;\n        }\n        else if (opcode == 0x11) {\n          valueToUpdate = inputParameters[3] + 4;\n        }\n      }\n      else if (opcode == 0x10210000) {\nLAB_08001882:\n        if (inputParameters[2] == 0) {\n          valueToUpdate = 4;\n        }\n        else if (inputParameters[2] == 1) {\n          valueToUpdate = 8;\n          outputParameters[4] = bitMask;\n        }\n        else {\n          valueToUpdate = 8;\n          outputParameters[5] = bitMask;\n        }\n      }\n      else if (opcode < 0x10210001) {\n        if ((opcode == 0x10110000) || (opcode == 0x10120000)) goto LAB_08001882;\n      }\n      else if (((opcode == 0x10310000) || (opcode == 0x10320000)) || (opcode == 0x10220000))\n      goto LAB_08001882;\n      if (bitValue < 0x100) {\n        bitMask = bitIndex << 2;\n        outputPtr = outputParameters;\n      }\n      else {\n        outputPtr = outputParameters + 1;\n        bitMask = (bitIndex - 8) * 4;\n      }\n      *outputPtr = *outputPtr & ~(0xf << (bitMask & 0xff)) | valueToUpdate << (bitMask & 0xff);\n      if ((inputParameters[1] & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        if (outputParameters == (uint *)0x40010800) {\n          index = 0;\n        }\n        else if (outputParameters == (uint *)0x40010c00) {\n          index = 1;\n        }\n        else if (outputParameters == (uint *)0x40011000) {\n          index = 2;\n        }\n        else if (outputParameters == (uint *)0x40011400) {\n          index = 3;\n        }\n        else {\n          index = 4;\n        }\n        *(uint *)(((bitIndex >> 2) + 2) * 4 + 0x40010000) =\n             index << ((bitIndex & 3) << 2) |\n             ~(0xf << ((bitIndex & 3) << 2)) & *(uint *)(((bitIndex >> 2) + 2) * 4 + 0x40010000);\n        if ((inputParameters[1] & 0x10000) == 0) {\n          _DAT_40010400 = ~bitValue & _DAT_40010400;\n        }\n        else {\n          _DAT_40010400 = bitValue | _DAT_40010400;\n        }\n        if ((inputParameters[1] & 0x20000) == 0) {\n          _DAT_40010404 = ~bitValue & _DAT_40010404;\n        }\n        else {\n          _DAT_40010404 = bitValue | _DAT_40010404;\n        }\n        if ((inputParameters[1] & 0x100000) == 0) {\n          _DAT_40010408 = ~bitValue & _DAT_40010408;\n        }\n        else {\n          _DAT_40010408 = bitValue | _DAT_40010408;\n        }\n        if ((inputParameters[1] & 0x200000) == 0) {\n          _DAT_4001040c = ~bitValue & _DAT_4001040c;\n        }\n        else {\n          _DAT_4001040c = bitValue | _DAT_4001040c;\n        }\n      }\n    }\n    bitIndex = bitIndex + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080017c4": "update_parameter_bits_080017c4",
                "param_1": "outputParameters",
                "param_2": "inputParameters",
                "uVar1": "bitMask",
                "uVar2": "bitValue",
                "uVar3": "opcode",
                "puVar4": "outputPtr",
                "iVar5": "index",
                "local_10": "valueToUpdate",
                "local_c": "bitIndex"
            },
            "calling": [
                "FUN_08005680",
                "FUN_080055f4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a80": {
            "entrypoint": "0x08001a80",
            "current_name": "update_param_08001a80",
            "code": "\nvoid updateParam_08001a80(int baseAddress,ushort value,char flag)\n\n{\n  if (flag == '\\0') {\n    *(uint *)(baseAddress + 0x10) = (uint)value << 0x10;\n  }\n  else {\n    *(uint *)(baseAddress + 0x10) = (uint)value;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a80": "update_param_08001a80",
                "param_1": "baseAddress",
                "param_2": "value",
                "param_3": "flag"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_080055f4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "calculate_and_update_values_08001ab0",
            "code": "\nundefined4 calculateAndUpdateValues_08001ab0(uint **params)\n\n{\n  uint result;\n  char flag;\n  undefined4 status;\n  uint temp;\n  bool isZero;\n  \n  if (params == (uint **)0x0) {\n    status = 1;\n  }\n  else {\n    if (*(char *)((int)params + 0x3d) == '\\0') {\n      *(undefined *)(params + 0xf) = 0;\n      FUNC_08001cb8(params);\n    }\n    *(undefined *)((int)params + 0x3d) = 0x24;\n    **params = **params & 0xfffffffe;\n    result = extracted_data_shifted_08003518();\n    if (params[1] < (uint *)0x186a1) {\n      temp = result;\n      if (result < 2000000) {\n        temp = 1;\n      }\n      flag = (char)temp;\n      if (1999999 < result) {\n        flag = '\\0';\n      }\n    }\n    else {\n      temp = result;\n      if (result < 4000000) {\n        temp = 1;\n      }\n      flag = (char)temp;\n      if (3999999 < result) {\n        flag = '\\0';\n      }\n    }\n    if (flag == '\\0') {\n      temp = result / 1000000;\n      (*params)[1] = temp;\n      if ((uint *)0x186a0 < params[1]) {\n        temp = (temp * 300) / 1000;\n      }\n      (*params)[8] = temp + 1;\n      if (params[1] < (uint *)0x186a1) {\n        result = (result - 1) / (uint)((int)params[1] << 1) + 1 & 0xfff;\n        if (result < 4) {\n          result = 4;\n        }\n      }\n      else {\n        if (params[2] == (uint *)0x0) {\n          temp = (result - 1) / (uint)((int)params[1] * 3) + 1 & 0xfff;\n          isZero = temp == 0;\n          if (isZero) {\n            temp = 1;\n          }\n          flag = (char)temp;\n          if (!isZero) {\n            flag = '\\0';\n          }\n        }\n        else {\n          temp = (result - 1) / (uint)((int)params[1] * 0x19) + 1 & 0xfff;\n          isZero = temp == 0;\n          if (isZero) {\n            temp = 1;\n          }\n          flag = (char)temp;\n          if (!isZero) {\n            flag = '\\0';\n          }\n        }\n        if (flag == '\\0') {\n          if (params[2] == (uint *)0x0) {\n            result = (result - 1) / (uint)((int)params[1] * 3) + 1 & 0xfff | 0x8000;\n          }\n          else {\n            result = (result - 1) / (uint)((int)params[1] * 0x19) + 1 & 0xfff | 0xc000;\n          }\n        }\n        else {\n          result = 1;\n        }\n      }\n      (*params)[7] = result;\n      **params = (uint)params[8] | (uint)params[7];\n      (*params)[2] = (uint)params[3] | (uint)params[4];\n      (*params)[3] = (uint)params[6] | (uint)params[5];\n      **params = **params | 1;\n      params[0x10] = (uint *)0x0;\n      *(undefined *)((int)params + 0x3d) = 0x20;\n      params[0xc] = (uint *)0x0;\n      *(undefined *)((int)params + 0x3e) = 0;\n      status = 0;\n    }\n    else {\n      status = 1;\n    }\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "calculate_and_update_values_08001ab0",
                "param_1": "params",
                "uVar1": "result",
                "cVar2": "flag",
                "uVar3": "status",
                "uVar4": "temp",
                "bVar5": "isZero"
            },
            "calling": [
                "FUN_08005348"
            ],
            "called": [
                "FUN_08003518",
                "FUN_08001cb8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cb8": {
            "entrypoint": "0x08001cb8",
            "current_name": "FUNC_08001cb8",
            "code": "\nvoid FUNC_08001cb8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cb8": "FUNC_08001cb8"
            },
            "calling": [
                "FUN_08001ab0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001ccc": {
            "entrypoint": "0x08001ccc",
            "current_name": "process_input_08001ccc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001d5e) */\n/* WARNING: Removing unreachable block (ram,0x08001d70) */\n/* WARNING: Removing unreachable block (ram,0x08001d72) */\n/* WARNING: Removing unreachable block (ram,0x08001d74) */\n\nundefined4\nprocessInput_08001ccc(uint **inputParams,undefined2 param2,undefined2 param3,undefined2 param4,uint *param5,\n            undefined2 param6,undefined4 param7)\n\n{\n  int globalVar;\n  int localVar;\n  undefined4 returnValue;\n  uint *ptrVar;\n  \n  globalVar = get_value_from_global_variable_080015a0();\n  if (*(char *)((int)inputParams + 0x3d) == ' ') {\n    do {\n      if ((~(*inputParams)[6] & 2) != 0) {\n        localVar = 0;\n        goto LAB_08001d9c;\n      }\n      localVar = get_value_from_global_variable_080015a0();\n    } while ((uint)(localVar - globalVar) < 0x1a);\n    inputParams[0xc] = (uint *)0x0;\n    *(undefined *)((int)inputParams + 0x3d) = 0x20;\n    *(undefined *)((int)inputParams + 0x3e) = 0;\n    *(undefined *)(inputParams + 0xf) = 0;\n    localVar = 3;\nLAB_08001d9c:\n    if (localVar == 0) {\n      if (*(char *)(inputParams + 0xf) == '\\x01') {\n        returnValue = 2;\n      }\n      else {\n        *(undefined *)(inputParams + 0xf) = 1;\n        if ((**inputParams & 1) != 1) {\n          **inputParams = **inputParams | 1;\n        }\n        **inputParams = **inputParams & 0xfffff7ff;\n        *(undefined *)((int)inputParams + 0x3d) = 0x21;\n        *(undefined *)((int)inputParams + 0x3e) = 0x40;\n        inputParams[0x10] = (uint *)0x0;\n        inputParams[9] = param5;\n        *(undefined2 *)((int)inputParams + 0x2a) = param6;\n        inputParams[0xb] = (uint *)0xffff0000;\n        *(undefined2 *)(inputParams + 10) = *(undefined2 *)((int)inputParams + 0x2a);\n        localVar = process_data_08002640(inputParams,param2,param3,param4,param7,globalVar);\n        if (localVar == 0) {\n          while (*(short *)(inputParams + 10) != 0) {\n            localVar = check_and_update_flags_08002bb4(inputParams,param7,globalVar);\n            if (localVar != 0) {\n              if (inputParams[0x10] == (uint *)0x4) {\n                **inputParams = **inputParams | 0x200;\n                return 1;\n              }\n              return 3;\n            }\n            ptrVar = inputParams[9];\n            inputParams[9] = (uint *)((int)ptrVar + 1);\n            (*inputParams)[4] = (uint)*(byte *)ptrVar;\n            *(short *)(inputParams + 10) = *(short *)(inputParams + 10) + -1;\n            *(short *)((int)inputParams + 0x2a) = *(short *)((int)inputParams + 0x2a) + -1;\n            if ((((*inputParams)[5] & 4) == 4) && (*(short *)(inputParams + 10) != 0)) {\n              ptrVar = inputParams[9];\n              inputParams[9] = (uint *)((int)ptrVar + 1);\n              (*inputParams)[4] = (uint)*(byte *)ptrVar;\n              *(short *)(inputParams + 10) = *(short *)(inputParams + 10) + -1;\n              *(short *)((int)inputParams + 0x2a) = *(short *)((int)inputParams + 0x2a) + -1;\n            }\n          }\n          globalVar = validate_input_08002c2e(inputParams,param7,globalVar);\n          if (globalVar == 0) {\n            **inputParams = **inputParams | 0x200;\n            *(undefined *)((int)inputParams + 0x3d) = 0x20;\n            *(undefined *)((int)inputParams + 0x3e) = 0;\n            *(undefined *)(inputParams + 0xf) = 0;\n            returnValue = 0;\n          }\n          else if (inputParams[0x10] == (uint *)0x4) {\n            **inputParams = **inputParams | 0x200;\n            returnValue = 1;\n          }\n          else {\n            returnValue = 3;\n          }\n        }\n        else if (inputParams[0x10] == (uint *)0x4) {\n          *(undefined *)(inputParams + 0xf) = 0;\n          returnValue = 1;\n        }\n        else {\n          *(undefined *)(inputParams + 0xf) = 0;\n          returnValue = 3;\n        }\n      }\n    }\n    else {\n      returnValue = 2;\n    }\n  }\n  else {\n    returnValue = 2;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08001ccc": "process_input_08001ccc",
                "param_1": "inputParams",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6",
                "param_7": "param7",
                "iVar1": "globalVar",
                "iVar2": "localVar",
                "uVar3": "returnValue",
                "puVar4": "ptrVar"
            },
            "calling": [
                "FUN_08004ea4"
            ],
            "called": [
                "FUN_08002c2e",
                "FUN_08002bb4",
                "FUN_080015a0",
                "FUN_08002640"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f6c": {
            "entrypoint": "0x08001f6c",
            "current_name": "process_data_08001f6c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080024e6) */\n/* WARNING: Removing unreachable block (ram,0x080024f8) */\n/* WARNING: Removing unreachable block (ram,0x080024fa) */\n/* WARNING: Removing unreachable block (ram,0x080024fc) */\n/* WARNING: Removing unreachable block (ram,0x08002000) */\n/* WARNING: Removing unreachable block (ram,0x08002012) */\n/* WARNING: Removing unreachable block (ram,0x08002014) */\n/* WARNING: Removing unreachable block (ram,0x08002016) */\n/* WARNING: Removing unreachable block (ram,0x080023f4) */\n/* WARNING: Removing unreachable block (ram,0x08002406) */\n/* WARNING: Removing unreachable block (ram,0x08002408) */\n/* WARNING: Removing unreachable block (ram,0x0800240a) */\n/* WARNING: Removing unreachable block (ram,0x080022d6) */\n/* WARNING: Removing unreachable block (ram,0x080022e8) */\n/* WARNING: Removing unreachable block (ram,0x080022ea) */\n/* WARNING: Removing unreachable block (ram,0x080022ec) */\n\nundefined4\nprocessData_08001f6c(uint **data,undefined2 value1,undefined2 value2,undefined2 value3,uint *buffer,\n            undefined2 flag,uint limit)\n\n{\n  int globalValue;\n  uint tempValue;\n  int tempVariable;\n  undefined4 result;\n  uint *ptrBuffer;\n  \n  globalValue = get_value_from_global_variable_080015a0();\n  if (*(char *)((int)data + 0x3d) == ' ') {\n    do {\n      if ((~(*data)[6] & 2) != 0) {\n        tempVariable = 0;\n        goto LAB_08002040;\n      }\n      tempVariable = get_value_from_global_variable_080015a0();\n    } while ((uint)(tempVariable - globalValue) < 0x1a);\n    data[0xc] = (uint *)0x0;\n    *(undefined *)((int)data + 0x3d) = 0x20;\n    *(undefined *)((int)data + 0x3e) = 0;\n    *(undefined *)(data + 0xf) = 0;\n    tempVariable = 3;\nLAB_08002040:\n    if (tempVariable == 0) {\n      if (*(char *)(data + 0xf) == '\\x01') {\n        result = 2;\n      }\n      else {\n        *(undefined *)(data + 0xf) = 1;\n        if ((**data & 1) != 1) {\n          **data = **data | 1;\n        }\n        **data = **data & 0xfffff7ff;\n        *(undefined *)((int)data + 0x3d) = 0x22;\n        *(undefined *)((int)data + 0x3e) = 0x40;\n        data[0x10] = (uint *)0x0;\n        data[9] = buffer;\n        *(undefined2 *)((int)data + 0x2a) = flag;\n        data[0xb] = (uint *)0xffff0000;\n        *(undefined2 *)(data + 10) = *(undefined2 *)((int)data + 0x2a);\n        tempVariable = validate_and_update_flags_080027f4(data,value1,value2,value3,limit,globalValue);\n        if (tempVariable == 0) {\n          if (*(short *)(data + 10) == 0) {\n            **data = **data | 0x200;\n          }\n          else if (*(short *)(data + 10) == 1) {\n            **data = **data & 0xfffffbff;\n            disableIRQinterrupts();\n            **data = **data | 0x200;\n            enableIRQinterrupts();\n          }\n          else if (*(short *)(data + 10) == 2) {\n            **data = **data | 0x800;\n            disableIRQinterrupts();\n            **data = **data & 0xfffffbff;\n            enableIRQinterrupts();\n          }\n          else {\n            **data = **data | 0x400;\n          }\n          while (*(short *)(data + 10) != 0) {\n            if (*(ushort *)(data + 10) < 4) {\n              if (*(short *)(data + 10) == 1) {\n                tempVariable = check_flag_status_08002ca8(data,limit,globalValue);\n                if (tempVariable != 0) {\n                  if (data[0x10] == (uint *)0x20) {\n                    return 3;\n                  }\n                  return 1;\n                }\n                tempValue = (*data)[4];\n                ptrBuffer = data[9];\n                data[9] = (uint *)((int)ptrBuffer + 1);\n                *(char *)ptrBuffer = (char)tempValue;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n              }\n              else if (*(short *)(data + 10) == 2) {\n                do {\n                  if ((~(*data)[5] & 4) == 0) {\n                    tempVariable = 0;\n                    goto LAB_080022fa;\n                  }\n                } while ((limit == 0xffffffff) ||\n                        ((limit != 0 && (tempVariable = get_value_from_global_variable_080015a0(), (uint)(tempVariable - globalValue) <= limit)\n                         )));\n                data[0xc] = (uint *)0x0;\n                *(undefined *)((int)data + 0x3d) = 0x20;\n                *(undefined *)((int)data + 0x3e) = 0;\n                *(undefined *)(data + 0xf) = 0;\n                tempVariable = 3;\nLAB_080022fa:\n                if (tempVariable != 0) {\n                  return 3;\n                }\n                disableIRQinterrupts();\n                **data = **data | 0x200;\n                tempValue = (*data)[4];\n                ptrBuffer = data[9];\n                data[9] = (uint *)((int)ptrBuffer + 1);\n                *(char *)ptrBuffer = (char)tempValue;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n                enableIRQinterrupts();\n                tempValue = (*data)[4];\n                ptrBuffer = data[9];\n                data[9] = (uint *)((int)ptrBuffer + 1);\n                *(char *)ptrBuffer = (char)tempValue;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n              }\n              else {\n                do {\n                  if ((~(*data)[5] & 4) == 0) {\n                    tempVariable = 0;\n                    goto LAB_08002418;\n                  }\n                } while ((limit == 0xffffffff) ||\n                        ((limit != 0 && (tempVariable = get_value_from_global_variable_080015a0(), (uint)(tempVariable - globalValue) <= limit)\n                         )));\n                data[0xc] = (uint *)0x0;\n                *(undefined *)((int)data + 0x3d) = 0x20;\n                *(undefined *)((int)data + 0x3e) = 0;\n                *(undefined *)(data + 0xf) = 0;\n                tempVariable = 3;\nLAB_08002418:\n                if (tempVariable != 0) {\n                  return 3;\n                }\n                **data = **data & 0xfffffbff;\n                disableIRQinterrupts();\n                tempValue = (*data)[4];\n                ptrBuffer = data[9];\n                data[9] = (uint *)((int)ptrBuffer + 1);\n                *(char *)ptrBuffer = (char)tempValue;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n                do {\n                  if ((~(*data)[5] & 4) == 0) {\n                    tempVariable = 0;\n                    goto LAB_0800250a;\n                  }\n                } while ((limit == 0xffffffff) ||\n                        ((limit != 0 && (tempVariable = get_value_from_global_variable_080015a0(), (uint)(tempVariable - globalValue) <= limit)\n                         )));\n                data[0xc] = (uint *)0x0;\n                *(undefined *)((int)data + 0x3d) = 0x20;\n                *(undefined *)((int)data + 0x3e) = 0;\n                *(undefined *)(data + 0xf) = 0;\n                tempVariable = 3;\nLAB_0800250a:\n                if (tempVariable != 0) {\n                  return 3;\n                }\n                **data = **data | 0x200;\n                tempValue = (*data)[4];\n                ptrBuffer = data[9];\n                data[9] = (uint *)((int)ptrBuffer + 1);\n                *(char *)ptrBuffer = (char)tempValue;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n                enableIRQinterrupts();\n                tempValue = (*data)[4];\n                ptrBuffer = data[9];\n                data[9] = (uint *)((int)ptrBuffer + 1);\n                *(char *)ptrBuffer = (char)tempValue;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n              }\n            }\n            else {\n              tempVariable = check_flag_status_08002ca8(data,limit,globalValue);\n              if (tempVariable != 0) {\n                if (data[0x10] == (uint *)0x20) {\n                  return 3;\n                }\n                return 1;\n              }\n              tempValue = (*data)[4];\n              ptrBuffer = data[9];\n              data[9] = (uint *)((int)ptrBuffer + 1);\n              *(char *)ptrBuffer = (char)tempValue;\n              *(short *)(data + 10) = *(short *)(data + 10) + -1;\n              *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n              if (((*data)[5] & 4) == 4) {\n                tempValue = (*data)[4];\n                ptrBuffer = data[9];\n                data[9] = (uint *)((int)ptrBuffer + 1);\n                *(char *)ptrBuffer = (char)tempValue;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n              }\n            }\n          }\n          *(undefined *)((int)data + 0x3d) = 0x20;\n          *(undefined *)((int)data + 0x3e) = 0;\n          *(undefined *)(data + 0xf) = 0;\n          result = 0;\n        }\n        else if (data[0x10] == (uint *)0x4) {\n          *(undefined *)(data + 0xf) = 0;\n          result = 1;\n        }\n        else {\n          *(undefined *)(data + 0xf) = 0;\n          result = 3;\n        }\n      }\n    }\n    else {\n      result = 2;\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001f6c": "process_data_08001f6c",
                "param_1": "data",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3",
                "param_5": "buffer",
                "param_6": "flag",
                "param_7": "limit",
                "iVar1": "globalValue",
                "uVar2": "tempValue",
                "iVar3": "tempVariable",
                "uVar4": "result",
                "puVar5": "ptrBuffer"
            },
            "calling": [
                "FUN_08004ee8"
            ],
            "called": [
                "FUN_08002ca8",
                "FUN_080027f4",
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002640": {
            "entrypoint": "0x08002640",
            "current_name": "process_data_08002640",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080026e8) */\n/* WARNING: Removing unreachable block (ram,0x080026fa) */\n/* WARNING: Removing unreachable block (ram,0x080026fc) */\n/* WARNING: Removing unreachable block (ram,0x080026fe) */\n\nundefined4\nprocessData_08002640(uint **data,byte flag,undefined2 value,short mode,uint limit,int threshold)\n\n{\n  int result;\n  undefined4 status;\n  \n  **data = **data | 0x100;\n  do {\n    if ((~(*data)[5] & 1) == 0) {\n      result = 0;\n      goto LAB_0800270a;\n    }\n  } while ((limit == 0xffffffff) ||\n          ((limit != 0 && (result = getGlobalValue(), (uint)(result - threshold) <= limit))));\n  data[0xc] = (uint *)0x0;\n  *(undefined *)((int)data + 0x3d) = 0x20;\n  *(undefined *)((int)data + 0x3e) = 0;\n  *(undefined *)(data + 0xf) = 0;\n  result = 3;\nLAB_0800270a:\n  if (result == 0) {\n    (*data)[4] = flag & 0xfe;\n    result = validateParameters(data,0x10002,limit,threshold);\n    if (result == 0) {\n      result = updateFlags(data,limit,threshold,(*data)[6]);\n      if (result == 0) {\n        if (mode == 1) {\n          (*data)[4] = (uint)(byte)value;\n        }\n        else {\n          (*data)[4] = (uint)(byte)((ushort)value >> 8);\n          result = updateFlags(data,limit,threshold);\n          if (result != 0) {\n            if (data[0x10] == (uint *)0x4) {\n              **data = **data | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*data)[4] = (uint)(byte)value;\n        }\n        status = 0;\n      }\n      else if (data[0x10] == (uint *)0x4) {\n        **data = **data | 0x200;\n        status = 1;\n      }\n      else {\n        status = 3;\n      }\n    }\n    else if (data[0x10] == (uint *)0x4) {\n      status = 1;\n    }\n    else {\n      status = 3;\n    }\n  }\n  else {\n    status = 3;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002640": "process_data_08002640",
                "param_1": "data",
                "param_2": "flag",
                "param_3": "value",
                "param_4": "mode",
                "param_5": "limit",
                "param_6": "threshold",
                "iVar1": "result",
                "uVar2": "status",
                "get_value_from_global_variable_080015a0": "getGlobalValue",
                "validate_parameters_08002ad8": "validateParameters",
                "check_and_update_flags_08002bb4": "updateFlags"
            },
            "calling": [
                "FUN_08001ccc"
            ],
            "called": [
                "FUN_08002bb4",
                "FUN_08002ad8",
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080027f4": {
            "entrypoint": "0x080027f4",
            "current_name": "validate_and_update_flags_080027f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080028ae) */\n/* WARNING: Removing unreachable block (ram,0x080028c0) */\n/* WARNING: Removing unreachable block (ram,0x080028c2) */\n/* WARNING: Removing unreachable block (ram,0x080028c4) */\n/* WARNING: Removing unreachable block (ram,0x08002a6c) */\n/* WARNING: Removing unreachable block (ram,0x08002a7e) */\n/* WARNING: Removing unreachable block (ram,0x08002a80) */\n/* WARNING: Removing unreachable block (ram,0x08002a82) */\n\nundefined4\nvalidate_and_update_flags_080027f4(uint **param_list,byte flag,undefined2 parameter,short num_of_parameters,uint limit,int value)\n\n{\n  int result;\n  undefined4 output;\n  \n  **param_list = **param_list | 0x400;\n  **param_list = **param_list | 0x100;\n  do {\n    if ((~(*param_list)[5] & 1) == 0) {\n      result = 0;\n      goto LAB_080028d2;\n    }\n  } while ((limit == 0xffffffff) ||\n          ((limit != 0 && (result = get_value_from_global_variable_080015a0(), (uint)(result - value) <= limit))));\n  param_list[0xc] = (uint *)0x0;\n  *(undefined *)((int)param_list + 0x3d) = 0x20;\n  *(undefined *)((int)param_list + 0x3e) = 0;\n  *(undefined *)(param_list + 0xf) = 0;\n  result = 3;\nLAB_080028d2:\n  if (result == 0) {\n    (*param_list)[4] = flag & 0xfe;\n    result = validate_parameters_08002ad8(param_list,0x10002,limit,value);\n    if (result == 0) {\n      result = check_and_update_flags_08002bb4(param_list,limit,value,(*param_list)[6]);\n      if (result == 0) {\n        if (num_of_parameters == 1) {\n          (*param_list)[4] = (uint)(byte)parameter;\n        }\n        else {\n          (*param_list)[4] = (uint)(byte)((ushort)parameter >> 8);\n          result = check_and_update_flags_08002bb4(param_list,limit,value);\n          if (result != 0) {\n            if (param_list[0x10] == (uint *)0x4) {\n              **param_list = **param_list | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*param_list)[4] = (uint)(byte)parameter;\n        }\n        result = check_and_update_flags_08002bb4(param_list,limit,value);\n        if (result == 0) {\n          **param_list = **param_list | 0x100;\n          do {\n            if ((~(*param_list)[5] & 1) == 0) {\n              result = 0;\n              goto LAB_08002a90;\n            }\n          } while ((limit == 0xffffffff) ||\n                  ((limit != 0 && (result = get_value_from_global_variable_080015a0(), (uint)(result - value) <= limit))));\n          param_list[0xc] = (uint *)0x0;\n          *(undefined *)((int)param_list + 0x3d) = 0x20;\n          *(undefined *)((int)param_list + 0x3e) = 0;\n          *(undefined *)(param_list + 0xf) = 0;\n          result = 3;\nLAB_08002a90:\n          if (result == 0) {\n            (*param_list)[4] = (uint)(flag | 1);\n            result = validate_parameters_08002ad8(param_list,0x10002,limit,value);\n            if (result == 0) {\n              output = 0;\n            }\n            else if (param_list[0x10] == (uint *)0x4) {\n              output = 1;\n            }\n            else {\n              output = 3;\n            }\n          }\n          else {\n            output = 3;\n          }\n        }\n        else if (param_list[0x10] == (uint *)0x4) {\n          **param_list = **param_list | 0x200;\n          output = 1;\n        }\n        else {\n          output = 3;\n        }\n      }\n      else if (param_list[0x10] == (uint *)0x4) {\n        **param_list = **param_list | 0x200;\n        output = 1;\n      }\n      else {\n        output = 3;\n      }\n    }\n    else if (param_list[0x10] == (uint *)0x4) {\n      output = 1;\n    }\n    else {\n      output = 3;\n    }\n  }\n  else {\n    output = 3;\n  }\n  return output;\n}\n\n",
            "renaming": {
                "FUN_080027f4": "validate_and_update_flags_080027f4",
                "param_1": "param_list",
                "param_2": "flag",
                "param_3": "parameter",
                "param_4": "num_of_parameters",
                "param_5": "limit",
                "param_6": "value",
                "iVar1": "result",
                "uVar2": "output"
            },
            "calling": [
                "FUN_08001f6c"
            ],
            "called": [
                "FUN_08002bb4",
                "FUN_08002ad8",
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad8": {
            "entrypoint": "0x08002ad8",
            "current_name": "validate_parameters_08002ad8",
            "code": "\nundefined4 validate_parameters_08002ad8(uint **parameter_array,uint flag_value,uint comparison_value,int global_variable_value)\n\n{\n  int global_variable;\n  char result;\n  uint updated_value;\n  bool is_updated;\n  \n  do {\n    if ((flag_value >> 0x10 & 0xff) == 1) {\n      updated_value = flag_value & ~(*parameter_array)[5] & 0xffff;\n      is_updated = updated_value != 0;\n      if (is_updated) {\n        updated_value = 1;\n      }\n      result = (char)updated_value;\n      if (!is_updated) {\n        result = '\\0';\n      }\n    }\n    else {\n      updated_value = flag_value & ~(*parameter_array)[6] & 0xffff;\n      is_updated = updated_value != 0;\n      if (is_updated) {\n        updated_value = 1;\n      }\n      result = (char)updated_value;\n      if (!is_updated) {\n        result = '\\0';\n      }\n    }\n    if (result == '\\0') {\n      return 0;\n    }\n    if (((*parameter_array)[5] & 0x400) == 0x400) {\n      **parameter_array = **parameter_array | 0x200;\n      (*parameter_array)[5] = 0xfffffbff;\n      parameter_array[0x10] = (uint *)0x4;\n      parameter_array[0xc] = (uint *)0x0;\n      *(undefined *)((int)parameter_array + 0x3d) = 0x20;\n      *(undefined *)(parameter_array + 0xf) = 0;\n      return 1;\n    }\n  } while ((comparison_value == 0xffffffff) ||\n          ((comparison_value != 0 && (global_variable = get_value_from_global_variable_080015a0(), (uint)(global_variable - global_variable_value) <= comparison_value))));\n  parameter_array[0xc] = (uint *)0x0;\n  *(undefined *)((int)parameter_array + 0x3d) = 0x20;\n  *(undefined *)(parameter_array + 0xf) = 0;\n  return 3;\n}\n\n",
            "renaming": {
                "FUN_08002ad8": "validate_parameters_08002ad8",
                "param_1": "parameter_array",
                "param_2": "flag_value",
                "param_3": "comparison_value",
                "param_4": "global_variable_value",
                "iVar1": "global_variable",
                "cVar2": "result",
                "uVar3": "updated_value",
                "bVar4": "is_updated"
            },
            "calling": [
                "FUN_080027f4",
                "FUN_08002640"
            ],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002bb4": {
            "entrypoint": "0x08002bb4",
            "current_name": "check_and_update_flags_08002bb4",
            "code": "\nundefined4 checkAndUpdateFlags_08002bb4(int *ptrArray,uint value,int offset)\n\n{\n  int updateResult;\n  \n  while( true ) {\n    if ((*(uint *)(*ptrArray + 0x14) & 0x80) == 0x80) {\n      return 0;\n    }\n    updateResult = update_flags_and_state_08002d3c(ptrArray);\n    if (updateResult != 0) break;\n    if ((value != 0xffffffff) &&\n       ((value == 0 || (updateResult = get_value_from_global_variable_080015a0(), value < (uint)(updateResult - offset))))) {\n      ptrArray[0x10] = ptrArray[0x10] | 0x20;\n      ptrArray[0xc] = 0;\n      *(undefined *)((int)ptrArray + 0x3d) = 0x20;\n      *(undefined *)(ptrArray + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002bb4": "check_and_update_flags_08002bb4",
                "param_1": "ptrArray",
                "param_2": "value",
                "param_3": "offset",
                "iVar1": "updateResult"
            },
            "calling": [
                "FUN_08001ccc",
                "FUN_080027f4",
                "FUN_08002640"
            ],
            "called": [
                "FUN_080015a0",
                "FUN_08002d3c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c2e": {
            "entrypoint": "0x08002c2e",
            "current_name": "validate_input_08002c2e",
            "code": "\nundefined4 validate_input_08002c2e(int *input_array,uint length_limit,int parameter_offset)\n\n{\n  int result;\n  \n  while( true ) {\n    if ((*(uint *)(*input_array + 0x14) & 4) == 4) {\n      return 0;\n    }\n    result = update_flags_and_state(input_array);\n    if (result != 0) break;\n    if ((length_limit != 0xffffffff) &&\n       ((length_limit == 0 || (result = get_global_variable_value(), length_limit < (uint)(result - parameter_offset))))) {\n      flag_modify = flag_modify | 0x20;\n      counter = 0;\n      *(undefined *)((int)input_array + 0x3d) = 0x20;\n      *(undefined *)(input_array + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002c2e": "validate_input_08002c2e",
                "param_1": "input_array",
                "param_2": "length_limit",
                "param_3": "parameter_offset",
                "update_flags_and_state_08002d3c": "update_flags_and_state",
                "get_value_from_global_variable_080015a0": "get_global_variable_value",
                "iVar1": "result",
                "param_1[0x10]": "flag_modify",
                "param_1[0xc]": "counter"
            },
            "calling": [
                "FUN_08001ccc"
            ],
            "called": [
                "FUN_080015a0",
                "FUN_08002d3c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca8": {
            "entrypoint": "0x08002ca8",
            "current_name": "check_flag_status_08002ca8",
            "code": "\nundefined4 checkFlagStatus_08002ca8(int *flagStatus,uint availableMemory,int requiredMemory)\n\n{\n  int valueFromGlobalVariable;\n  \n  while( true ) {\n    if ((*(uint *)(*flagStatus + 0x14) & 0x40) == 0x40) {\n      return 0;\n    }\n    if ((*(uint *)(*flagStatus + 0x14) & 0x10) == 0x10) break;\n    if ((availableMemory == 0) || (valueFromGlobalVariable = get_value_from_global_variable_080015a0(), availableMemory < (uint)(valueFromGlobalVariable - requiredMemory))) {\n      flagStatusField = flagStatusField | 0x20;\n      *(undefined *)((int)flagStatus + 0x3d) = 0x20;\n      *(undefined *)(flagStatus + 0xf) = 0;\n      return 3;\n    }\n  }\n  *(undefined4 *)(*flagStatus + 0x14) = 0xffffffef;\n  flagStatusField = 0;\n  flagStatus[0xc] = 0;\n  *(undefined *)((int)flagStatus + 0x3d) = 0x20;\n  *(undefined *)(flagStatus + 0xf) = 0;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002ca8": "check_flag_status_08002ca8",
                "param_1": "flagStatus",
                "param_2": "availableMemory",
                "param_3": "requiredMemory",
                "iVar1": "valueFromGlobalVariable",
                "param_1[0x10]": "flagStatusField"
            },
            "calling": [
                "FUN_08001f6c"
            ],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d3c": {
            "entrypoint": "0x08002d3c",
            "current_name": "update_flags_and_state_08002d3c",
            "code": "\nbool updateFlagsAndState_08002d3c(int *ptr)\n\n{\n  bool flag;\n  \n  flag = (*(uint *)(*ptr + 0x14) & 0x400) == 0x400;\n  if (flag) {\n    *(undefined4 *)(*ptr + 0x14) = 0xfffffbff;\n    state = 4;\n    index = 0;\n    *(undefined *)((int)ptr + 0x3d) = 0x20;\n    *(undefined *)(ptr + 0xf) = 0;\n  }\n  return flag;\n}\n\n",
            "renaming": {
                "FUN_08002d3c": "update_flags_and_state_08002d3c",
                "param_1": "ptr",
                "bVar1": "flag",
                "param_1[0x10]": "state",
                "param_1[0xc]": "index"
            },
            "calling": [
                "FUN_08002c2e",
                "FUN_08002bb4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d8a": {
            "entrypoint": "0x08002d8a",
            "current_name": "FUNC_08002d8a",
            "code": "\nvoid FUNC_08002d8a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d8a": "FUNC_08002d8a"
            },
            "calling": [
                "FUN_080014f0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d98": {
            "entrypoint": "0x08002d98",
            "current_name": "execute_action_08002d98",
            "code": "\n\n\nundefined4 execute_action_08002d98(uint *action)\n\n{\n  int start_time;\n  int current_time;\n  undefined4 result;\n  bool flag;\n  \n  if ((*action & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0x10000)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (action[1] == 0)) {\n        return 1;\n      }\n    }\n    else {\n      if (action[1] == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (action[1] == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (action[1] == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (action[1] == 0) {\n        start_time = get_current_time();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          current_time = get_current_time();\n          if (100 < (uint)(current_time - start_time)) {\n            return 3;\n          }\n        }\n      }\n      else {\n        start_time = get_current_time();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          current_time = get_current_time();\n          if (100 < (uint)(current_time - start_time)) {\n            return 3;\n          }\n        }\n      }\n    }\n  }\n  if ((*action & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (action[4] != 1)) {\n        return 1;\n      }\n      _DAT_40021000 = action[5] << 3 | _DAT_40021000 & 0xffffff07;\n    }\n    else if (action[4] == 0) {\n      _DAT_42420000 = 0;\n      start_time = get_current_time();\n      while ((_DAT_40021000 & 2) != 0) {\n        current_time = get_current_time();\n        if (2 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      start_time = get_current_time();\n      while ((_DAT_40021000 & 2) == 0) {\n        current_time = get_current_time();\n        if (2 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n      _DAT_40021000 = action[5] << 3 | _DAT_40021000 & 0xffffff07;\n    }\n  }\n  if ((*action & 8) != 0) {\n    if (action[6] == 0) {\n      _DAT_42420480 = 0;\n      start_time = get_current_time();\n      while ((_DAT_40021024 & 2) != 0) {\n        current_time = get_current_time();\n        if (2 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      start_time = get_current_time();\n      while ((_DAT_40021024 & 2) == 0) {\n        current_time = get_current_time();\n        if (2 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n      calculate_loop_iterations(1);\n    }\n  }\n  if ((*action & 4) != 0) {\n    flag = (_DAT_4002101c & 0x10000000) == 0;\n    if (flag) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      start_time = get_current_time();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        current_time = get_current_time();\n        if (100 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n    }\n    if (action[3] == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (action[3] == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (action[3] == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (action[3] == 0) {\n      start_time = get_current_time();\n      while ((_DAT_40021020 & 2) != 0) {\n        current_time = get_current_time();\n        if (5000 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      start_time = get_current_time();\n      while ((_DAT_40021020 & 2) == 0) {\n        current_time = get_current_time();\n        if (5000 < (uint)(current_time - start_time)) {\n          return 3;\n        }\n      }\n    }\n    if (flag) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if (action[7] == 0) {\nLAB_0800324a:\n    result = 0;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    result = 1;\n  }\n  else if (action[7] == 2) {\n    _DAT_42420060 = 0;\n    start_time = get_current_time();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if (action[8] == 0x10000) {\n          _DAT_40021004 = action[2] | _DAT_40021004 & 0xfffdffff;\n        }\n        _DAT_40021004 = action[9] | action[8] | _DAT_40021004 & 0xffc2ffff;\n        _DAT_42420060 = 1;\n        start_time = get_current_time();\n        while ((_DAT_40021000 & 0x2000000) == 0) {\n          current_time = get_current_time();\n          if (2 < (uint)(current_time - start_time)) {\n            return 3;\n          }\n        }\n        goto LAB_0800324a;\n      }\n      current_time = get_current_time();\n    } while ((uint)(current_time - start_time) < 3);\n    result = 3;\n  }\n  else {\n    _DAT_42420060 = 0;\n    start_time = get_current_time();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) goto LAB_0800324a;\n      current_time = get_current_time();\n    } while ((uint)(current_time - start_time) < 3);\n    result = 3;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002d98": "execute_action_08002d98",
                "param_1": "action",
                "iVar1": "start_time",
                "iVar2": "current_time",
                "uVar3": "result",
                "bVar4": "flag",
                "get_value_from_global_variable_080015a0": "get_current_time",
                "calculate_loop_iterations_08003568": "calculate_loop_iterations"
            },
            "calling": [
                "FUN_080052a0"
            ],
            "called": [
                "FUN_08003568",
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003260": {
            "entrypoint": "0x08003260",
            "current_name": "update_data_and_calculate_processing_time_08003260",
            "code": "\n\n\nundefined4 updateDataAndCalculateProcessingTime_08003260(uint *dataPointer,uint dataLength)\n\n{\n  int initialValue;\n  int newValue;\n  uint processingTimeResult;\n  undefined4 returnValue;\n  \n  if (((_DAT_40022000 & 7) < dataLength) &&\n     (_DAT_40022000 = dataLength | _DAT_40022000 & 0xfffffff8, dataLength != (dataLength & 7))) {\n    returnValue = 1;\n  }\n  else {\n    if ((*dataPointer & 2) != 0) {\n      _DAT_40021004 = dataPointer[2] | _DAT_40021004 & 0xffffff0f;\n    }\n    if ((*dataPointer & 1) == 0) {\nLAB_08003394:\n      if ((dataLength < (_DAT_40022000 & 7)) &&\n         (_DAT_40022000 = dataLength | _DAT_40022000 & 0xfffffff8, dataLength != (dataLength & 7))) {\n        returnValue = 1;\n      }\n      else {\n        if ((*dataPointer & 4) != 0) {\n          _DAT_40021004 = dataPointer[3] | _DAT_40021004 & 0xfffff8ff;\n        }\n        if ((*dataPointer & 8) != 0) {\n          _DAT_40021004 = dataPointer[4] << 3 | _DAT_40021004 & 0xffffc7ff;\n        }\n        processingTimeResult = calculateProcessingTime();\n        DAT_20000018 = processingTimeResult >> (&DAT_08009eb0)[_DAT_40021004 >> 4 & 0xf];\n        initializeAndCheckData(0xf);\n        returnValue = 0;\n      }\n    }\n    else {\n      if (dataPointer[1] == 1) {\n        if ((_DAT_40021000 & 0x20000) == 0) {\n          return 1;\n        }\n      }\n      else if ((dataPointer[1] != 2) && ((_DAT_40021000 & 2) == 0)) {\n        return 1;\n      }\n      _DAT_40021004 = dataPointer[1] | _DAT_40021004 & 0xfffffffc;\n      initialValue = getGlobalVariableValue();\n      if (dataPointer[1] == 1) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 4) goto LAB_08003394;\n          newValue = getGlobalVariableValue();\n        } while ((uint)(newValue - initialValue) < 0x1389);\n        returnValue = 3;\n      }\n      else if (dataPointer[1] == 2) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 8) goto LAB_08003394;\n          newValue = getGlobalVariableValue();\n        } while ((uint)(newValue - initialValue) < 0x1389);\n        returnValue = 3;\n      }\n      else {\n        do {\n          if ((_DAT_40021004 & 0xc) == 0) goto LAB_08003394;\n          newValue = getGlobalVariableValue();\n        } while ((uint)(newValue - initialValue) < 0x1389);\n        returnValue = 3;\n      }\n    }\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08003260": "update_data_and_calculate_processing_time_08003260",
                "param_1": "dataPointer",
                "param_2": "dataLength",
                "calculate_processing_time_08003440": "calculateProcessingTime",
                "initialize_and_check_data_0800151c": "initializeAndCheckData",
                "get_value_from_global_variable_080015a0": "getGlobalVariableValue",
                "uVar3": "processingTimeResult",
                "uVar4": "returnValue",
                "iVar1": "initialValue",
                "iVar2": "newValue"
            },
            "calling": [
                "FUN_080052a0"
            ],
            "called": [
                "FUN_0800151c",
                "FUN_080015a0",
                "FUN_08003440"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003440": {
            "entrypoint": "0x08003440",
            "current_name": "calculate_processing_time_08003440",
            "code": "\n\n\nuint calculateProcessingTime_08003440(void)\n\n{\n  undefined2 inputData;\n  undefined4 constantA;\n  undefined4 constantB;\n  undefined4 constantC;\n  undefined4 constantD;\n  uint outputData;\n  undefined4 counter;\n  uint local_14;\n  uint processingTime;\n  uint tempValue;\n  \n  constantA = 0x5040302;\n  constantB = 0x9080706;\n  constantC = 0xd0c0b0a;\n  constantD = 0x10100f0e;\n  inputData = 0x201;\n  counter = 0;\n  tempValue = 0;\n  outputData = 0;\n  processingTime = 0;\n  local_14 = _DAT_40021004;\n  if ((_DAT_40021004 & 0xc) == 4) {\n    processingTime = 8000000;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    outputData = (uint)*(byte *)((int)&constantA + (_DAT_40021004 >> 0x12 & 0xf));\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      tempValue = outputData * 4000000;\n    }\n    else {\n      tempValue = (outputData * 8000000) / (uint)*(byte *)((int)&inputData + (_DAT_40021004 >> 0x11 & 1))\n      ;\n    }\n    processingTime = tempValue;\n  }\n  else {\n    processingTime = 8000000;\n  }\n  return processingTime;\n}\n\n",
            "renaming": {
                "FUN_08003440": "calculate_processing_time_08003440",
                "local_30": "inputData",
                "local_2c": "constantA",
                "uStack_28": "constantB",
                "uStack_24": "constantC",
                "uStack_20": "constantD",
                "local_1c": "outputData",
                "local_18": "counter",
                "local_10": "processingTime",
                "local_c": "tempValue"
            },
            "calling": [
                "FUN_08003260"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003504": {
            "entrypoint": "0x08003504",
            "current_name": "get_data_08003504",
            "code": "\nundefined4 get_data_08003504(void)\n\n{\n  return DAT_20000018;\n}\n\n",
            "renaming": {
                "FUN_08003504": "get_data_08003504"
            },
            "calling": [
                "FUN_08003518",
                "FUN_080052a0",
                "FUN_08003540"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003518": {
            "entrypoint": "0x08003518",
            "current_name": "extracted_data_shifted_08003518",
            "code": "\n\n\nuint extracted_data_shifted_08003518(void)\n\n{\n  uint extracted_data;\n  \n  extracted_data = get_data_08003504();\n  return extracted_data >> *(sbyte *)((int)&DAT_08009ec0 + (_DAT_40021004 >> 8 & 7));\n}\n\n",
            "renaming": {
                "FUN_08003518": "extracted_data_shifted_08003518",
                "uVar1": "extracted_data"
            },
            "calling": [
                "FUN_08001ab0",
                "FUN_080046ec"
            ],
            "called": [
                "FUN_08003504"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003540": {
            "entrypoint": "0x08003540",
            "current_name": "shifted_data_08003540",
            "code": "\n\n\nuint shiftedData_08003540(void)\n\n{\n  uint data;\n  \n  data = get_data_08003504();\n  return data >> *(byte *)((int)&DAT_08009ec0 + (_DAT_40021004 >> 0xb & 7));\n}\n\n",
            "renaming": {
                "FUN_08003540": "shifted_data_08003540",
                "uVar1": "data",
                "sbyte": "byte"
            },
            "calling": [
                "FUN_080046ec"
            ],
            "called": [
                "FUN_08003504"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003568": {
            "entrypoint": "0x08003568",
            "current_name": "calculate_loop_iterations_08003568",
            "code": "\nvoid calculateLoopIterations_08003568(int inputValue)\n\n{\n  bool hasIterations;\n  int result;\n  \n  result = inputValue * (DAT_20000018 / 8000);\n  do {\n    hasIterations = result != 0;\n    result = result + -1;\n  } while (hasIterations);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003568": "calculate_loop_iterations_08003568",
                "param_1": "inputValue",
                "local_c": "result",
                "bVar1": "hasIterations"
            },
            "calling": [
                "FUN_08002d98"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035a4": {
            "entrypoint": "0x080035a4",
            "current_name": "process_data_080035a4",
            "code": "\nundefined4 processData_080035a4(undefined4 *data)\n\n{\n  undefined4 result;\n  \n  if (data == (undefined4 *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)data + 0x3d) == '\\0') {\n      *(undefined *)(data + 0xf) = 0;\n      FUNC_080035fa(data);\n    }\n    *(undefined *)((int)data + 0x3d) = 2;\n    update_memory_08003c94(*data,data + 1);\n    *(undefined *)((int)data + 0x3d) = 1;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080035a4": "process_data_080035a4",
                "param_1": "data",
                "uVar1": "result"
            },
            "calling": [
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "called": [
                "FUN_080035fa",
                "FUN_08003c94"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fa": {
            "entrypoint": "0x080035fa",
            "current_name": "FUNC_080035fa",
            "code": "\nvoid FUNC_080035fa(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fa": "FUNC_080035fa"
            },
            "calling": [
                "FUN_080035a4"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800360c": {
            "entrypoint": "0x0800360c",
            "current_name": "set_flags_on_bits_0800360c",
            "code": "\nundefined4 setFlagsOnBits_0800360c(uint **array)\n\n{\n  (*array)[3] = (*array)[3] | 1;\n  **array = **array | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800360c": "set_flags_on_bits_0800360c",
                "param_1": "array"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003640": {
            "entrypoint": "0x08003640",
            "current_name": "initialize_memory_08003640",
            "code": "\nundefined4 initializeMemory_08003640(undefined4 *memoryPointer)\n\n{\n  undefined4 result;\n  \n  if (memoryPointer == (undefined4 *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)memoryPointer + 0x3d) == '\\0') {\n      *(undefined *)(memoryPointer + 0xf) = 0;\n      FUNC_08003696(memoryPointer);\n    }\n    *(undefined *)((int)memoryPointer + 0x3d) = 2;\n    updateMemory(*memoryPointer,memoryPointer + 1);\n    *(undefined *)((int)memoryPointer + 0x3d) = 1;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003640": "initialize_memory_08003640",
                "param_1": "memoryPointer",
                "uVar1": "result",
                "update_memory_08003c94": "updateMemory"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [
                "FUN_08003696",
                "FUN_08003c94"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003696": {
            "entrypoint": "0x08003696",
            "current_name": "FUNC_08003696",
            "code": "\nvoid FUNC_08003696(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003696": "FUNC_08003696"
            },
            "calling": [
                "FUN_08003640"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080036a8": {
            "entrypoint": "0x080036a8",
            "current_name": "update_bit_value_and_set_flag_080036a8",
            "code": "\nundefined4 updateBitValueAndSetFlag_080036a8(uint **dataPointer,undefined4 flag)\n\n{\n  update_bit_value_080041ea(*dataPointer,flag,1);\n  if (*dataPointer == (uint *)0x40012c00) {\n    (*dataPointer)[0x11] = (*dataPointer)[0x11] | 0x8000;\n  }\n  **dataPointer = **dataPointer | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080036a8": "update_bit_value_and_set_flag_080036a8",
                "param_1": "dataPointer",
                "param_2": "flag"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_080041ea"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036f8": {
            "entrypoint": "0x080036f8",
            "current_name": "process_flags_080036f8",
            "code": "\nvoid process_flags_080036f8(int *flags)\n\n{\n  if (((*(uint *)(*flags + 0x10) & 2) == 2) && ((*(uint *)(*flags + 0xc) & 2) == 2)) {\n    *(undefined4 *)(*flags + 0x10) = 0xfffffffd;\n    *(undefined *)(flags + 7) = 1;\n    if ((*(uint *)(*flags + 0x18) & 3) == 0) {\n      FUNC_08003c4a(flags);\n      FUNC_08003c6e(flags);\n    }\n    else {\n      FUNC_08003c5c(flags);\n    }\n    *(undefined *)(flags + 7) = 0;\n  }\n  if (((*(uint *)(*flags + 0x10) & 4) == 4) && ((*(uint *)(*flags + 0xc) & 4) == 4)) {\n    *(undefined4 *)(*flags + 0x10) = 0xfffffffb;\n    *(undefined *)(flags + 7) = 2;\n    if ((*(uint *)(*flags + 0x18) & 0x300) == 0) {\n      FUNC_08003c4a(flags);\n      FUNC_08003c6e(flags);\n    }\n    else {\n      FUNC_08003c5c(flags);\n    }\n    *(undefined *)(flags + 7) = 0;\n  }\n  if (((*(uint *)(*flags + 0x10) & 8) == 8) && ((*(uint *)(*flags + 0xc) & 8) == 8)) {\n    *(undefined4 *)(*flags + 0x10) = 0xfffffff7;\n    *(undefined *)(flags + 7) = 4;\n    if ((*(uint *)(*flags + 0x1c) & 3) == 0) {\n      FUNC_08003c4a(flags);\n      FUNC_08003c6e(flags);\n    }\n    else {\n      FUNC_08003c5c(flags);\n    }\n    *(undefined *)(flags + 7) = 0;\n  }\n  if (((*(uint *)(*flags + 0x10) & 0x10) == 0x10) && ((*(uint *)(*flags + 0xc) & 0x10) == 0x10))\n  {\n    *(undefined4 *)(*flags + 0x10) = 0xffffffef;\n    *(undefined *)(flags + 7) = 8;\n    if ((*(uint *)(*flags + 0x1c) & 0x300) == 0) {\n      FUNC_08003c4a(flags);\n      FUNC_08003c6e(flags);\n    }\n    else {\n      FUNC_08003c5c(flags);\n    }\n    *(undefined *)(flags + 7) = 0;\n  }\n  if (((*(uint *)(*flags + 0x10) & 1) == 1) && ((*(uint *)(*flags + 0xc) & 1) == 1)) {\n    *(undefined4 *)(*flags + 0x10) = 0xfffffffe;\n    process_data_08004f78(flags);\n  }\n  if (((*(uint *)(*flags + 0x10) & 0x80) == 0x80) && ((*(uint *)(*flags + 0xc) & 0x80) == 0x80))\n  {\n    *(undefined4 *)(*flags + 0x10) = 0xffffff7f;\n    FUNC_08004378(flags);\n  }\n  if (((*(uint *)(*flags + 0x10) & 0x40) == 0x40) && ((*(uint *)(*flags + 0xc) & 0x40) == 0x40))\n  {\n    *(undefined4 *)(*flags + 0x10) = 0xffffffbf;\n    FUNC_08003c80(flags);\n  }\n  if (((*(uint *)(*flags + 0x10) & 0x20) == 0x20) && ((*(uint *)(*flags + 0xc) & 0x20) == 0x20))\n  {\n    *(undefined4 *)(*flags + 0x10) = 0xffffffdf;\n    FUNC_08004366(flags);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080036f8": "process_flags_080036f8",
                "param_1": "flags"
            },
            "calling": [
                "FUN_08005714"
            ],
            "called": [
                "FUN_08004f78",
                "FUN_08003c6e",
                "FUN_08004378",
                "FUN_08003c4a",
                "FUN_08004366",
                "FUN_08003c80",
                "FUN_08003c5c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003908": {
            "entrypoint": "0x08003908",
            "current_name": "process_params_08003908",
            "code": "\nundefined4 processParams_08003908(int *paramArray,int paramSize,undefined4 paramFlag)\n\n{\n  undefined4 returnValue;\n  \n  if (*(char *)(paramArray + 0xf) == '\\x01') {\n    returnValue = 2;\n  }\n  else {\n    *(undefined *)(paramArray + 0xf) = 1;\n    *(undefined *)((int)paramArray + 0x3d) = 2;\n    switch(paramFlag) {\n    case 0:\n      updateParams(*paramArray,paramSize);\n      *(uint *)(*paramArray + 0x18) = *(uint *)(*paramArray + 0x18) | 8;\n      *(uint *)(*paramArray + 0x18) = *(uint *)(*paramArray + 0x18) & 0xfffffffb;\n      *(uint *)(*paramArray + 0x18) = *(uint *)(paramSize + 0x10) | *(uint *)(*paramArray + 0x18);\n      break;\n    case 4:\n      updateFlags(*paramArray,paramSize);\n      *(uint *)(*paramArray + 0x18) = *(uint *)(*paramArray + 0x18) | 0x800;\n      *(uint *)(*paramArray + 0x18) = *(uint *)(*paramArray + 0x18) & 0xfffffbff;\n      *(uint *)(*paramArray + 0x18) = *(int *)(paramSize + 0x10) << 8 | *(uint *)(*paramArray + 0x18);\n      break;\n    case 8:\n      updateParameters(*paramArray,paramSize);\n      *(uint *)(*paramArray + 0x1c) = *(uint *)(*paramArray + 0x1c) | 8;\n      *(uint *)(*paramArray + 0x1c) = *(uint *)(*paramArray + 0x1c) & 0xfffffffb;\n      *(uint *)(*paramArray + 0x1c) = *(uint *)(paramSize + 0x10) | *(uint *)(*paramArray + 0x1c);\n      break;\n    case 0xc:\n      updateData(*paramArray,paramSize);\n      *(uint *)(*paramArray + 0x1c) = *(uint *)(*paramArray + 0x1c) | 0x800;\n      *(uint *)(*paramArray + 0x1c) = *(uint *)(*paramArray + 0x1c) & 0xfffffbff;\n      *(uint *)(*paramArray + 0x1c) = *(int *)(paramSize + 0x10) << 8 | *(uint *)(*paramArray + 0x1c);\n    }\n    *(undefined *)((int)paramArray + 0x3d) = 1;\n    *(undefined *)(paramArray + 0xf) = 0;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08003908": "process_params_08003908",
                "param_1": "paramArray",
                "param_2": "paramSize",
                "param_3": "paramFlag",
                "uVar1": "returnValue",
                "update_params_08003d60": "updateParams",
                "update_flags_08003e38": "updateFlags",
                "update_parameters_08003f18": "updateParameters",
                "update_data_08003ff8": "updateData"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [
                "FUN_08003ff8",
                "FUN_08003d60",
                "FUN_08003f18",
                "FUN_08003e38"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a94": {
            "entrypoint": "0x08003a94",
            "current_name": "update_function_08003a94",
            "code": "\nundefined4 updateFunction_08003a94(int *paramPointer,uint *paramArray)\n\n{\n  undefined4 returnValue;\n  uint parameterValue;\n  \n  if (*(char *)(paramPointer + 0xf) == '\\x01') {\n    returnValue = 2;\n  }\n  else {\n    *(undefined *)(paramPointer + 0xf) = 1;\n    *(undefined *)((int)paramPointer + 0x3d) = 2;\n    *(uint *)(*paramPointer + 8) = *(uint *)(*paramPointer + 8) & 0xffff0088;\n    parameterValue = *paramArray;\n    if (parameterValue == 0x40) {\n      update_parameters_080040a0(*paramPointer,paramArray[1],paramArray[3]);\n      update_memory_0800416a(*paramPointer,0x40);\n    }\n    else if (parameterValue < 0x41) {\n      if (parameterValue == 0x10) {\n        update_memory_0800416a(*paramPointer,0x10);\n      }\n      else if (parameterValue < 0x11) {\n        if (parameterValue == 0) {\n          update_memory_0800416a(*paramPointer,0);\n        }\n      }\n      else if (parameterValue == 0x20) {\n        update_memory_0800416a(*paramPointer,0x20);\n      }\n      else if (parameterValue == 0x30) {\n        update_memory_0800416a(*paramPointer,0x30);\n      }\n    }\n    else if (parameterValue == 0x70) {\n      update_value_080041a8(*paramPointer,paramArray[2],paramArray[1],paramArray[3]);\n      *(uint *)(*paramPointer + 8) = *(uint *)(*paramPointer + 8) & 0xffffff88 | 0x77;\n    }\n    else if (parameterValue < 0x71) {\n      if (parameterValue == 0x50) {\n        update_parameters_080040a0(*paramPointer,paramArray[1],paramArray[3]);\n        update_memory_0800416a(*paramPointer,0x50);\n      }\n      else if (parameterValue == 0x60) {\n        update_flags_and_values_08004104(*paramPointer,paramArray[1],paramArray[3]);\n        update_memory_0800416a(*paramPointer,0x60);\n      }\n    }\n    else if (parameterValue == 0x1000) {\n      *(uint *)(*paramPointer + 8) = *(uint *)(*paramPointer + 8) & 0xfffffff8;\n    }\n    else if (parameterValue == 0x2000) {\n      update_value_080041a8(*paramPointer,paramArray[2],paramArray[1],paramArray[3]);\n      *(uint *)(*paramPointer + 8) = *(uint *)(*paramPointer + 8) | 0x4000;\n    }\n    *(undefined *)((int)paramPointer + 0x3d) = 1;\n    *(undefined *)(paramPointer + 0xf) = 0;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08003a94": "update_function_08003a94",
                "param_1": "paramPointer",
                "param_2": "paramArray",
                "uVar1": "returnValue",
                "uVar2": "parameterValue"
            },
            "calling": [
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "called": [
                "FUN_08004104",
                "FUN_080040a0",
                "FUN_0800416a",
                "FUN_080041a8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c4a": {
            "entrypoint": "0x08003c4a",
            "current_name": "FUNC_08003c4a",
            "code": "\nvoid FUNC_08003c4a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c4a": "FUNC_08003c4a"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c5c": {
            "entrypoint": "0x08003c5c",
            "current_name": "FUNC_08003c5c",
            "code": "\nvoid FUNC_08003c5c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c5c": "FUNC_08003c5c"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c6e": {
            "entrypoint": "0x08003c6e",
            "current_name": "FUNC_08003c6e",
            "code": "\nvoid FUNC_08003c6e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c6e": "FUNC_08003c6e"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c80": {
            "entrypoint": "0x08003c80",
            "current_name": "FUNC_08003c80",
            "code": "\nvoid FUNC_08003c80(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c80": "FUNC_08003c80"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c94": {
            "entrypoint": "0x08003c94",
            "current_name": "update_memory_08003c94",
            "code": "\nvoid updateMemory_08003c94(uint *memoryPointer,uint *newValues)\n\n{\n  uint oldValue;\n  \n  oldValue = *memoryPointer;\n  if ((((memoryPointer == (uint *)0x40012c00) || (memoryPointer == (uint *)0x40000000)) ||\n      (memoryPointer == (uint *)0x40000400)) || (memoryPointer == (uint *)0x40000800)) {\n    oldValue = newValues[1] | oldValue & 0xffffff8f;\n  }\n  if (((memoryPointer == (uint *)0x40012c00) || (memoryPointer == (uint *)0x40000000)) ||\n     ((memoryPointer == (uint *)0x40000400 || (memoryPointer == (uint *)0x40000800)))) {\n    oldValue = newValues[3] | oldValue & 0xfffffcff;\n  }\n  *memoryPointer = newValues[5] | oldValue & 0xffffff7f;\n  memoryPointer[0xb] = newValues[2];\n  memoryPointer[10] = *newValues;\n  if (memoryPointer == (uint *)0x40012c00) {\n    specialValue = newValues[4];\n  }\n  memoryPointer[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c94": "update_memory_08003c94",
                "param_1": "memoryPointer",
                "param_2": "newValues",
                "local_c": "oldValue",
                "uRam40012c30": "specialValue"
            },
            "calling": [
                "FUN_08003640",
                "FUN_080035a4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d60": {
            "entrypoint": "0x08003d60",
            "current_name": "update_params_08003d60",
            "code": "\nvoid updateParams_08003d60(int baseAddress,uint *paramsArray)\n\n{\n  uint newValue1;\n  uint newValue2;\n  uint tempValue;\n  \n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & 0xfffffffe;\n  tempValue = *(uint *)(baseAddress + 4);\n  newValue1 = *paramsArray;\n  newValue2 = paramsArray[2] | *(uint *)(baseAddress + 0x20) & 0xfffffffd;\n  if (baseAddress == 0x40012c00) {\n    newValue2 = (paramsArray[3] | newValue2 & 0xfffffff7) & 0xfffffffb;\n    tempValue = paramsArray[6] | paramsArray[5] | tempValue & 0xfffffcff;\n  }\n  *(uint *)(baseAddress + 4) = tempValue;\n  *(uint *)(baseAddress + 0x18) = newValue1 | *(uint *)(baseAddress + 0x18) & 0xffffff8c;\n  *(uint *)(baseAddress + 0x34) = paramsArray[1];\n  *(uint *)(baseAddress + 0x20) = newValue2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003d60": "update_params_08003d60",
                "param_1": "baseAddress",
                "param_2": "paramsArray",
                "uVar1": "newValue1",
                "uVar2": "newValue2",
                "local_10": "tempValue"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e38": {
            "entrypoint": "0x08003e38",
            "current_name": "update_flags_08003e38",
            "code": "\nvoid updateFlags_08003e38(int flagsPointer,int *valuesArray)\n\n{\n  int value1;\n  uint value2;\n  uint value3;\n  \n  *(uint *)(flagsPointer + 0x20) = *(uint *)(flagsPointer + 0x20) & 0xffffffef;\n  value3 = *(uint *)(flagsPointer + 4);\n  value1 = *valuesArray;\n  value2 = valuesArray[2] << 4 | *(uint *)(flagsPointer + 0x20) & 0xffffffdf;\n  if (flagsPointer == 0x40012c00) {\n    value2 = (valuesArray[3] << 4 | value2 & 0xffffff7f) & 0xffffffbf;\n    value3 = valuesArray[6] << 2 | valuesArray[5] << 2 | value3 & 0xfffff3ff;\n  }\n  *(uint *)(flagsPointer + 4) = value3;\n  *(uint *)(flagsPointer + 0x18) = value1 << 8 | *(uint *)(flagsPointer + 0x18) & 0xffff8cff;\n  *(int *)(flagsPointer + 0x38) = valuesArray[1];\n  *(uint *)(flagsPointer + 0x20) = value2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e38": "update_flags_08003e38",
                "param_1": "flagsPointer",
                "param_2": "valuesArray",
                "iVar1": "value1",
                "uVar2": "value2",
                "local_10": "value3"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f18": {
            "entrypoint": "0x08003f18",
            "current_name": "update_parameters_08003f18",
            "code": "\nvoid updateParameters_08003f18(int address,uint *parameters)\n\n{\n  uint var1;\n  uint var2;\n  uint localVar1;\n  \n  *(uint *)(address + 0x20) = *(uint *)(address + 0x20) & 0xfffffeff;\n  localVar1 = *(uint *)(address + 4);\n  var1 = *parameters;\n  var2 = parameters[2] << 8 | *(uint *)(address + 0x20) & 0xfffffdff;\n  if (address == 0x40012c00) {\n    var2 = (parameters[3] << 8 | var2 & 0xfffff7ff) & 0xfffffbff;\n    localVar1 = parameters[6] << 4 | parameters[5] << 4 | localVar1 & 0xffffcfff;\n  }\n  *(uint *)(address + 4) = localVar1;\n  *(uint *)(address + 0x1c) = var1 | *(uint *)(address + 0x1c) & 0xffffff8c;\n  *(uint *)(address + 0x3c) = parameters[1];\n  *(uint *)(address + 0x20) = var2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f18": "update_parameters_08003f18",
                "param_1": "address",
                "param_2": "parameters",
                "uVar1": "var1",
                "uVar2": "var2",
                "local_10": "localVar1"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ff8": {
            "entrypoint": "0x08003ff8",
            "current_name": "update_data_08003ff8",
            "code": "\nvoid updateData_08003ff8(int baseAddress,int *data)\n\n{\n  int value1;\n  int value2;\n  uint currentValue;\n  \n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & 0xffffefff;\n  currentValue = *(uint *)(baseAddress + 4);\n  value1 = *data;\n  value2 = data[2];\n  if (baseAddress == 0x40012c00) {\n    currentValue = data[5] << 6 | currentValue & 0xffffbfff;\n  }\n  *(uint *)(baseAddress + 4) = currentValue;\n  *(uint *)(baseAddress + 0x1c) = value1 << 8 | *(uint *)(baseAddress + 0x1c) & 0xffff8cff;\n  *(int *)(baseAddress + 0x40) = data[1];\n  *(uint *)(baseAddress + 0x20) = value2 << 0xc | *(uint *)(baseAddress + 0x20) & 0xffffdfff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ff8": "update_data_08003ff8",
                "param_1": "baseAddress",
                "param_2": "data",
                "iVar1": "value1",
                "iVar2": "value2",
                "local_c": "currentValue"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040a0": {
            "entrypoint": "0x080040a0",
            "current_name": "update_parameters_080040a0",
            "code": "\nvoid updateParameters_080040a0(int ptr,uint newValue,int shiftAmount)\n\n{\n  uint tempValue;\n  \n  tempValue = *(uint *)(ptr + 0x20);\n  *(uint *)(ptr + 0x20) = *(uint *)(ptr + 0x20) & 0xfffffffe;\n  *(uint *)(ptr + 0x18) = shiftAmount << 4 | *(uint *)(ptr + 0x18) & 0xffffff0f;\n  *(uint *)(ptr + 0x20) = newValue | tempValue & 0xfffffff5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040a0": "update_parameters_080040a0",
                "param_1": "ptr",
                "param_2": "newValue",
                "param_3": "shiftAmount",
                "uVar1": "tempValue"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004104": {
            "entrypoint": "0x08004104",
            "current_name": "update_flags_and_values_08004104",
            "code": "\nvoid updateFlagsAndValues_08004104(int baseAddress,int value1,int value2)\n\n{\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & 0xffffffef;\n  *(uint *)(baseAddress + 0x18) = value2 << 0xc | *(uint *)(baseAddress + 0x18) & 0xffff0fff;\n  *(uint *)(baseAddress + 0x20) = value1 << 4 | *(uint *)(baseAddress + 0x20) & 0xffffff5f;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004104": "update_flags_and_values_08004104",
                "param_1": "baseAddress",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800416a": {
            "entrypoint": "0x0800416a",
            "current_name": "update_memory_0800416a",
            "code": "\nvoid updateMemory_0800416a(int memoryPointer,ushort dataToUpdate)\n\n{\n  *(uint *)(memoryPointer + 8) = *(uint *)(memoryPointer + 8) bitwiseAnd 0xffffff8f | (uint)(dataToUpdate | 7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800416a": "update_memory_0800416a",
                "param_1": "memoryPointer",
                "param_2": "dataToUpdate",
                "&": "bitwiseAnd"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041a8": {
            "entrypoint": "0x080041a8",
            "current_name": "update_value_080041a8",
            "code": "\nvoid updateValue_080041a8(int ptr,uint newValue1,uint newValue2,int value)\n\n{\n  *(uint *)(ptr + 8) = newValue1 | value << 8 | newValue2 | *(uint *)(ptr + 8) & 0xffff00ff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041a8": "update_value_080041a8",
                "param_1": "ptr",
                "param_2": "newValue1",
                "param_3": "newValue2",
                "param_4": "value"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041ea": {
            "entrypoint": "0x080041ea",
            "current_name": "update_bit_value_080041ea",
            "code": "\nvoid updateBitValue_080041ea(int data,uint bitIndex,int bitValue)\n\n{\n  *(uint *)(data + 0x20) = *(uint *)(data + 0x20) & ~(1 << (bitIndex & 0xff));\n  *(uint *)(data + 0x20) = *(uint *)(data + 0x20) | bitValue << (bitIndex & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041ea": "update_bit_value_080041ea",
                "param_1": "data",
                "param_2": "bitIndex",
                "param_3": "bitValue"
            },
            "calling": [
                "FUN_080036a8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800422e": {
            "entrypoint": "0x0800422e",
            "current_name": "set_flag_if_true_0800422e",
            "code": "\nundefined4 setFlagIfTrue_0800422e(int *pointer,uint *values)\n\n{\n  undefined4 returnValue;\n  \n  if (*(char *)(pointer + 0xf) == '\\x01') {\n    returnValue = 2;\n  }\n  else {\n    *(undefined *)(pointer + 0xf) = 1;\n    *(uint *)(*pointer + 0x44) =\n         values[6] |\n         (values[6] |\n         (values[5] |\n         (values[4] |\n         (*values | (values[1] | (values[2] | values[3] & 0xfffffcff) & 0xfffffbff) & 0xfffff7ff\n         ) & 0xffffefff) & 0xffffdfff) & 0xffffbfff) & 0xffff7fff;\n    *(undefined *)(pointer + 0xf) = 0;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_0800422e": "set_flag_if_true_0800422e",
                "param_1": "pointer",
                "param_2": "values",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042de": {
            "entrypoint": "0x080042de",
            "current_name": "update_flag_and_data_080042de",
            "code": "\nundefined4 updateFlagAndData_080042de(int *data,uint *values)\n\n{\n  undefined4 returnValue;\n  \n  if (*(char *)(data + 0xf) == '\\x01') {\n    returnValue = 2;\n  }\n  else {\n    *(undefined *)(data + 0xf) = 1;\n    *(undefined *)((int)data + 0x3d) = 2;\n    *(uint *)(*data + 4) = *(uint *)(*data + 4) & 0xffffff8f;\n    *(uint *)(*data + 4) = *values | *(uint *)(*data + 4);\n    *(uint *)(*data + 8) = *(uint *)(*data + 8) & 0xffffff7f;\n    *(uint *)(*data + 8) = values[1] | *(uint *)(*data + 8);\n    *(undefined *)((int)data + 0x3d) = 1;\n    *(undefined *)(data + 0xf) = 0;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080042de": "update_flag_and_data_080042de",
                "param_1": "data",
                "param_2": "values",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004366": {
            "entrypoint": "0x08004366",
            "current_name": "FUNC_08004366",
            "code": "\nvoid FUNC_08004366(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004366": "FUNC_08004366"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004378": {
            "entrypoint": "0x08004378",
            "current_name": "FUNC_08004378",
            "code": "\nvoid FUNC_08004378(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004378": "FUNC_08004378"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800438a": {
            "entrypoint": "0x0800438a",
            "current_name": "initialize_device_0800438a",
            "code": "\nundefined4 initializeDevice_0800438a(int *deviceData)\n\n{\n  undefined4 result;\n  \n  if (deviceData == (int *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)deviceData + 0x39) == '\\0') {\n      *(undefined *)(deviceData + 0xe) = 0;\n      FUNC_08004424(deviceData);\n    }\n    *(undefined *)((int)deviceData + 0x39) = 0x24;\n    *(uint *)(*deviceData + 0xc) = *(uint *)(*deviceData + 0xc) & 0xffffdfff;\n    updateConfigValues(deviceData);\n    *(uint *)(*deviceData + 0x10) = *(uint *)(*deviceData + 0x10) & 0xffffb7ff;\n    *(uint *)(*deviceData + 0x14) = *(uint *)(*deviceData + 0x14) & 0xffffffd5;\n    *(uint *)(*deviceData + 0xc) = *(uint *)(*deviceData + 0xc) | 0x2000;\n    counter = 0;\n    *(undefined *)((int)deviceData + 0x39) = 0x20;\n    *(undefined *)((int)deviceData + 0x3a) = 0x20;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800438a": "initialize_device_0800438a",
                "param_1": "deviceData",
                "uVar1": "result",
                "update_config_values_080046ec": "updateConfigValues",
                "param_1[0xf]": "counter"
            },
            "calling": [
                "FUN_08005598"
            ],
            "called": [
                "FUN_08004424",
                "FUN_080046ec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004424": {
            "entrypoint": "0x08004424",
            "current_name": "FUNC_08004424",
            "code": "\nvoid FUNC_08004424(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004424": "FUNC_08004424"
            },
            "calling": [
                "FUN_0800438a"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004436": {
            "entrypoint": "0x08004436",
            "current_name": "process_data_08004436",
            "code": "\nundefined4 processData_08004436(uint **inputParam,ushort *arrayParam,short arraySize,uint limit)\n\n{\n  int value1;\n  int value2;\n  undefined4 returnValue;\n  ushort *localArray;\n  \n  if (*(char *)((int)inputParam + 0x39) == ' ') {\n    if ((arrayParam == (ushort *)0x0) || (arraySize == 0)) {\n      returnValue = 1;\n    }\n    else if (*(char *)(inputParam + 0xe) == '\\x01') {\n      returnValue = 2;\n    }\n    else {\n      *(undefined *)(inputParam + 0xe) = 1;\n      inputParam[0xf] = (uint *)0x0;\n      *(undefined *)((int)inputParam + 0x39) = 0x21;\n      value1 = get_value_from_global_variable_080015a0();\n      *(short *)(inputParam + 9) = arraySize;\n      *(short *)((int)inputParam + 0x26) = arraySize;\n      localArray = arrayParam;\n      while (*(short *)((int)inputParam + 0x26) != 0) {\n        *(short *)((int)inputParam + 0x26) = *(short *)((int)inputParam + 0x26) + -1;\n        if (inputParam[2] == (uint *)0x1000) {\n          do {\n            if ((**inputParam & 0x80) == 0x80) {\n              value2 = 0;\n              goto LAB_0800454c;\n            }\n          } while ((limit == 0xffffffff) ||\n                  ((limit != 0 && (value2 = get_value_from_global_variable_080015a0(), (uint)(value2 - value1) <= limit))));\n          (*inputParam)[3] = (*inputParam)[3] & 0xfffffe5f;\n          (*inputParam)[5] = (*inputParam)[5] & 0xfffffffe;\n          *(undefined *)((int)inputParam + 0x39) = 0x20;\n          *(undefined *)((int)inputParam + 0x3a) = 0x20;\n          *(undefined *)(inputParam + 0xe) = 0;\n          value2 = 3;\nLAB_0800454c:\n          if (value2 != 0) {\n            return 3;\n          }\n          (*inputParam)[1] = *localArray & 0x1ff;\n          if (inputParam[4] == (uint *)0x0) {\n            localArray = localArray + 1;\n          }\n          else {\n            localArray = (ushort *)((int)localArray + 1);\n          }\n        }\n        else {\n          do {\n            if ((**inputParam & 0x80) == 0x80) {\n              value2 = 0;\n              goto LAB_08004614;\n            }\n          } while ((limit == 0xffffffff) ||\n                  ((limit != 0 && (value2 = get_value_from_global_variable_080015a0(), (uint)(value2 - value1) <= limit))));\n          (*inputParam)[3] = (*inputParam)[3] & 0xfffffe5f;\n          (*inputParam)[5] = (*inputParam)[5] & 0xfffffffe;\n          *(undefined *)((int)inputParam + 0x39) = 0x20;\n          *(undefined *)((int)inputParam + 0x3a) = 0x20;\n          *(undefined *)(inputParam + 0xe) = 0;\n          value2 = 3;\nLAB_08004614:\n          if (value2 != 0) {\n            return 3;\n          }\n          (*inputParam)[1] = (uint)*(byte *)localArray;\n          localArray = (ushort *)((int)localArray + 1);\n        }\n      }\n      do {\n        if ((**inputParam & 0x40) == 0x40) {\n          value1 = 0;\n          goto LAB_080046c6;\n        }\n      } while ((limit == 0xffffffff) ||\n              ((limit != 0 && (value2 = get_value_from_global_variable_080015a0(), (uint)(value2 - value1) <= limit))));\n      (*inputParam)[3] = (*inputParam)[3] & 0xfffffe5f;\n      (*inputParam)[5] = (*inputParam)[5] & 0xfffffffe;\n      *(undefined *)((int)inputParam + 0x39) = 0x20;\n      *(undefined *)((int)inputParam + 0x3a) = 0x20;\n      *(undefined *)(inputParam + 0xe) = 0;\n      value1 = 3;\nLAB_080046c6:\n      if (value1 == 0) {\n        *(undefined *)((int)inputParam + 0x39) = 0x20;\n        *(undefined *)(inputParam + 0xe) = 0;\n        returnValue = 0;\n      }\n      else {\n        returnValue = 3;\n      }\n    }\n  }\n  else {\n    returnValue = 2;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08004436": "process_data_08004436",
                "param_1": "inputParam",
                "param_2": "arrayParam",
                "param_3": "arraySize",
                "param_4": "limit",
                "iVar1": "value1",
                "iVar2": "value2",
                "uVar3": "returnValue",
                "local_58": "localArray"
            },
            "calling": [
                "FUN_08004f3c"
            ],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046ec": {
            "entrypoint": "0x080046ec",
            "current_name": "update_config_values_080046ec",
            "code": "\nvoid updateConfigValues_080046ec(int *configArray)\n\n{\n  ulonglong mulResult;\n  int tempVar1;\n  int tempVar2;\n  uint tempVar3;\n  int tempVar4;\n  undefined8 shiftedData;\n  \n  *(uint *)(*configArray + 0x10) = configArray[3] | *(uint *)(*configArray + 0x10) & 0xffffcfff;\n  *(uint *)(*configArray + 0xc) =\n       *(uint *)(*configArray + 0xc) & 0xffffe9f3 | configArray[5] | configArray[2] | configArray[4];\n  *(uint *)(*configArray + 0x14) = configArray[6] | *(uint *)(*configArray + 0x14) & 0xfffffcff;\n  if (*configArray == 0x40013800) {\n    shiftedData = calculateData();\n    mulResult = (ulonglong)(uint)((int)shiftedData * 0x19) / (ulonglong)(uint)(configArray[1] << 2);\n    tempVar1 = calculateData((int)shiftedData,(int)((ulonglong)shiftedData >> 0x20),(int)(mulResult * 0x51eb851f));\n    tempVar2 = configArray[1];\n    shiftedData = calculateData();\n    tempVar3 = ((uint)(tempVar1 * 0x19) / (uint)(tempVar2 << 2) +\n            (int)(((ulonglong)(uint)((int)shiftedData * 0x19) / (ulonglong)(uint)(configArray[1] << 2)) / 100)\n            * -100) * 0x10 + 0x32;\n    tempVar1 = calculateData((int)shiftedData,(int)((ulonglong)shiftedData >> 0x20),tempVar3 * 0x51eb851f);\n    tempVar4 = configArray[1];\n    tempVar2 = calculateData();\n    *(uint *)(*configArray + 8) =\n         ((((uint)(tempVar1 * 0x19) / (uint)(tempVar4 << 2) +\n           (int)(((ulonglong)(uint)(tempVar2 * 0x19) / (ulonglong)(uint)(configArray[1] << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) + (int)(mulResult / 100) * 0x10 + (tempVar3 / 100 & 0xf0);\n  }\n  else {\n    shiftedData = calculateExtractedData();\n    mulResult = (ulonglong)(uint)((int)shiftedData * 0x19) / (ulonglong)(uint)(configArray[1] << 2);\n    tempVar1 = calculateExtractedData((int)shiftedData,(int)((ulonglong)shiftedData >> 0x20),(int)(mulResult * 0x51eb851f));\n    tempVar2 = configArray[1];\n    shiftedData = calculateExtractedData();\n    tempVar3 = ((uint)(tempVar1 * 0x19) / (uint)(tempVar2 << 2) +\n            (int)(((ulonglong)(uint)((int)shiftedData * 0x19) / (ulonglong)(uint)(configArray[1] << 2)) / 100)\n            * -100) * 0x10 + 0x32;\n    tempVar1 = calculateExtractedData((int)shiftedData,(int)((ulonglong)shiftedData >> 0x20),tempVar3 * 0x51eb851f);\n    tempVar4 = configArray[1];\n    tempVar2 = calculateExtractedData();\n    *(uint *)(*configArray + 8) =\n         ((((uint)(tempVar1 * 0x19) / (uint)(tempVar4 << 2) +\n           (int)(((ulonglong)(uint)(tempVar2 * 0x19) / (ulonglong)(uint)(configArray[1] << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) + (int)(mulResult / 100) * 0x10 + (tempVar3 / 100 & 0xf0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046ec": "update_config_values_080046ec",
                "param_1": "configArray",
                "uVar1": "mulResult",
                "iVar2": "tempVar1",
                "iVar3": "tempVar2",
                "uVar4": "tempVar3",
                "iVar5": "tempVar4",
                "uVar6": "shiftedData",
                "shifted_data_08003540": "calculateData",
                "param_1[1]": "configArray[1]",
                "extracted_data_shifted_08003518": "calculateExtractedData"
            },
            "calling": [
                "FUN_0800438a"
            ],
            "called": [
                "FUN_08003518",
                "FUN_08003540"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800491c": {
            "entrypoint": "0x0800491c",
            "current_name": "initialize_data_0800491c",
            "code": "\nvoid initializeData_0800491c(undefined4 *data)\n\n{\n  undefined value1;\n  undefined value2;\n  undefined buffer [5];\n  \n  value1 = 0;\n  (*DAT_20000a54)(0xd0,0x6b,&value1,1);\n  value2 = 0x10;\n  (*DAT_20000a54)(0xd0,0x1c,&value2,1);\n  buffer[0] = 8;\n  (*DAT_20000a54)(0xd0,0x1b,buffer,1);\n  *data = 0;\n  data[1] = 0;\n  data[2] = 0;\n  data[3] = 0;\n  data[4] = 0;\n  data[5] = 0;\n  data[6] = 0;\n  data[7] = 0;\n  data[8] = 0;\n  data[9] = 0;\n  data[10] = 0;\n  calculate_average_results_080049cc(data);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800491c": "initialize_data_0800491c",
                "param_1": "data",
                "local_13": "value1",
                "local_12": "value2",
                "local_11": "buffer"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_080049cc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049cc": {
            "entrypoint": "0x080049cc",
            "current_name": "calculate_average_results_080049cc",
            "code": "\nvoid calculate_average_results_080049cc(int array_length)\n\n{\n  undefined4 uVar1;\n  undefined4 temp_variable_1;\n  undefined4 temp_variable_2;\n  undefined4 timestamp;\n  int index;\n  int counter;\n  undefined4 sum_variable_1;\n  undefined4 sum_variable_2;\n  undefined4 sum_variable_3;\n  undefined4 sum_variable_4;\n  \n  index = 1;\n  sum_variable_4 = 0;\n  sum_variable_3 = 0;\n  sum_variable_2 = 0;\n  sum_variable_1 = 0;\n  timestamp = (*DAT_20000a50)();\n  counter = 0;\n  while( true ) {\n    if (index <= counter) break;\n    temp_variable_2 = 0;\n    temp_variable_1 = 0;\n    initialize_param_array_08004ae0(array_length);\n    calculate_result_08004d78(array_length,&temp_variable_2,&temp_variable_1);\n    sum_variable_2 = calculate_floating_point_08000aa8(sum_variable_2,temp_variable_2);\n    sum_variable_1 = calculate_floating_point_08000aa8(sum_variable_1,temp_variable_1);\n    sum_variable_4 = calculate_floating_point_08000aa8(sum_variable_4,*(undefined4 *)(array_length + 0x10));\n    sum_variable_3 = calculate_floating_point_08000aa8(sum_variable_3,*(undefined4 *)(array_length + 0x14));\n    timestamp = (*DAT_20000a50)();\n    counter = counter + 1;\n  }\n  uVar1 = count_and_adjust_08000c10(index);\n  uVar1 = calculate_floating_point_08000e20(sum_variable_4,uVar1);\n  *(undefined4 *)(array_length + 0x1c) = uVar1;\n  uVar1 = count_and_adjust_08000c10(index);\n  uVar1 = calculate_floating_point_08000e20(sum_variable_3,uVar1);\n  *(undefined4 *)(array_length + 0x20) = uVar1;\n  uVar1 = count_and_adjust_08000c10(index);\n  uVar1 = calculate_floating_point_08000e20(sum_variable_2,uVar1);\n  *(undefined4 *)(array_length + 0x24) = uVar1;\n  uVar1 = count_and_adjust_08000c10(index);\n  uVar1 = calculate_floating_point_08000e20(sum_variable_1,uVar1);\n  *(undefined4 *)(array_length + 0x28) = uVar1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080049cc": "calculate_average_results_080049cc",
                "param_1": "array_length",
                "local_2c": "temp_variable_1",
                "local_28": "temp_variable_2",
                "local_24": "timestamp",
                "local_20": "index",
                "local_1c": "counter",
                "local_18": "sum_variable_1",
                "local_14": "sum_variable_2",
                "local_10": "sum_variable_3",
                "local_c": "sum_variable_4"
            },
            "calling": [
                "FUN_0800491c"
            ],
            "called": [
                "FUN_08000e20",
                "FUN_08000aa8",
                "FUN_08004ae0",
                "FUN_08004d78",
                "FUN_08000c10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ae0": {
            "entrypoint": "0x08004ae0",
            "current_name": "initialize_param_array_08004ae0",
            "code": "\nvoid initializeParamArray_08004ae0(undefined4 *paramArray)\n\n{\n  undefined4 uVar1;\n  undefined value_0;\n  undefined value_1;\n  undefined value_2;\n  undefined value_3;\n  undefined value_4;\n  undefined value_5;\n  undefined value_6;\n  undefined value_7;\n  undefined value_8;\n  undefined value_9;\n  undefined value_10;\n  undefined value_11;\n  undefined value_12;\n  undefined value_13;\n  short variable_0;\n  short variable_1;\n  short variable_2;\n  short variable_3;\n  short variable_4;\n  short variable_5;\n  \n  (*DAT_20000a4c)(0xd0,0x3b,&value_0,0xe);\n  variable_5 = CONCAT11(value_2,value_3);\n  variable_4 = CONCAT11(value_4,value_5);\n  variable_3 = CONCAT11(value_6,value_7);\n  variable_2 = CONCAT11(value_8,value_9);\n  variable_1 = CONCAT11(value_10,value_11);\n  variable_0 = CONCAT11(value_12,value_13);\n  uVar1 = adjustValue((int)CONCAT11(value_0,value_1));\n  *paramArray = uVar1;\n  uVar1 = adjustValue((int)variable_5);\n  paramArray[1] = uVar1;\n  uVar1 = adjustValue((int)variable_4);\n  paramArray[2] = uVar1;\n  uVar1 = adjustValue((int)variable_3);\n  paramArray[3] = uVar1;\n  uVar1 = adjustValue((int)variable_2);\n  paramArray[4] = uVar1;\n  uVar1 = adjustValue((int)variable_1);\n  paramArray[5] = uVar1;\n  uVar1 = adjustValue((int)variable_0);\n  paramArray[6] = uVar1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ae0": "initialize_param_array_08004ae0",
                "param_1": "paramArray",
                "local_2c": "value_0",
                "local_2b": "value_1",
                "local_2a": "value_2",
                "local_29": "value_3",
                "local_28": "value_4",
                "local_27": "value_5",
                "local_26": "value_6",
                "local_25": "value_7",
                "local_24": "value_8",
                "local_23": "value_9",
                "local_22": "value_10",
                "local_21": "value_11",
                "local_20": "value_12",
                "local_1f": "value_13",
                "local_1e": "variable_0",
                "local_1c": "variable_1",
                "local_1a": "variable_2",
                "local_18": "variable_3",
                "local_16": "variable_4",
                "local_14": "variable_5",
                "count_and_adjust_08000c10": "adjustValue"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_080049cc"
            ],
            "called": [
                "FUN_08000c10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bd8": {
            "entrypoint": "0x08004bd8",
            "current_name": "calculate_result_08004bd8",
            "code": "\nvoid calculate_result_08004bd8(int input_data,undefined4 *output_data)\n\n{\n  undefined4 result1;\n  undefined8 result2;\n  undefined8 result3;\n  \n  result1 = calculate_float_08000aa4(*(undefined4 *)(input_data + 0x10),*(undefined4 *)(input_data + 0x1c));\n  result2 = reverse_bits_08000418(DAT_200009e4);\n  result3 = reverse_bits_08000418(result1);\n  result3 = calculate_bitwise_difference_080004c8((int)result3,(int)((ulonglong)result3 >> 0x20),0x83f5c366,0x3f340215);\n  result2 = perform_unsigned_division_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result3,\n                       (int)((ulonglong)result3 >> 0x20));\n  DAT_200009e4 = calculate_float_080009fc((int)result2,(int)((ulonglong)result2 >> 0x20));\n  result2 = reverse_bits_08000418(*(undefined4 *)(input_data + 4));\n  result2 = calculate_floating_point_0800071c((int)result2,(int)((ulonglong)result2 >> 0x20),0,0x40b00000);\n  result3 = reverse_bits_08000418(*(undefined4 *)(input_data + 8));\n  result3 = calculate_floating_point_0800071c((int)result3,(int)((ulonglong)result3 >> 0x20),0,0x40b00000);\n  result2 = calculate_result_08004bd8_thunk_08005838((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result3,\n                             (int)((ulonglong)result3 >> 0x20));\n  result2 = calculate_bitwise_difference_080004c8((int)result2,(int)((ulonglong)result2 >> 0x20),0,0x40668000);\n  result2 = calculate_floating_point_0800071c((int)result2,(int)((ulonglong)result2 >> 0x20),0x54442d18,0x400921fb);\n  result3 = reverse_bits_08000418(*(undefined4 *)(input_data + 0x24));\n  result2 = perform_arithmetic_operation_08000158((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result3,\n                       (int)((ulonglong)result3 >> 0x20));\n  result2 = perform_unsigned_division_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),0,0x40568000);\n  result1 = calculate_float_080009fc((int)result2,(int)((ulonglong)result2 >> 0x20));\n  if (DAT_20000005 == '\\0') {\n    result2 = reverse_bits_08000418(DAT_200009e4);\n    result2 = calculate_bitwise_difference_080004c8((int)result2,(int)((ulonglong)result2 >> 0x20),0x9999999a,0x3fe99999);\n    result3 = reverse_bits_08000418(result1);\n    result3 = calculate_bitwise_difference_080004c8((int)result3,(int)((ulonglong)result3 >> 0x20),0x9999999a,0x3fc99999);\n    result2 = perform_unsigned_division_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result3,\n                         (int)((ulonglong)result3 >> 0x20));\n    DAT_200009e4 = calculate_float_080009fc((int)result2,(int)((ulonglong)result2 >> 0x20));\n  }\n  else {\n    DAT_20000005 = '\\0';\n    DAT_200009e4 = result1;\n  }\n  *output_data = DAT_200009e4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bd8": "calculate_result_08004bd8",
                "param_1": "input_data",
                "param_2": "output_data",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "result3"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_080004c8",
                "FUN_08000158",
                "FUN_080009fc",
                "thunk_FUN_08005838",
                "FUN_08000418",
                "FUN_0800015c",
                "FUN_0800071c",
                "FUN_08000aa4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d78": {
            "entrypoint": "0x08004d78",
            "current_name": "calculate_result_08004d78",
            "code": "\nvoid calculate_result_08004d78(undefined4 *input_values,undefined4 *reversed_value1,undefined4 *reversed_value2)\n\n{\n  undefined4 result1;\n  undefined4 result2;\n  undefined4 result3;\n  undefined8 final_result1;\n  undefined8 final_result2;\n  \n  result1 = calculate_floating_point_08000e20(*input_values,0x45800000);\n  result2 = calculate_floating_point_08000e20(input_values[1],0x45800000);\n  result3 = calculate_floating_point_08000e20(input_values[2],0x45800000);\n  final_result1 = reverse_bits_08000418(result2);\n  final_result2 = reverse_bits_08000418(result3);\n  final_result1 = calculate_result_08004d78_thunk_08005838((int)final_result1,(int)((ulonglong)final_result1 >> 0x20),(int)final_result2,\n                             (int)((ulonglong)final_result2 >> 0x20));\n  final_result1 = calculate_bitwise_difference_080004c8((int)final_result1,(int)((ulonglong)final_result1 >> 0x20),0,0x40668000);\n  final_result1 = calculate_floating_point_0800071c((int)final_result1,(int)((ulonglong)final_result1 >> 0x20),0x54442d18,0x400921fb);\n  result2 = calculate_float_080009fc((int)final_result1,(int)((ulonglong)final_result1 >> 0x20));\n  final_result1 = reverse_bits_08000418(result1);\n  final_result2 = reverse_bits_08000418(result3);\n  final_result1 = calculate_result_08004d78_thunk_08005838((int)final_result1,(int)((ulonglong)final_result1 >> 0x20),(int)final_result2,\n                             (int)((ulonglong)final_result2 >> 0x20));\n  final_result1 = calculate_bitwise_difference_080004c8((int)final_result1,(int)((ulonglong)final_result1 >> 0x20),0,0x40668000);\n  final_result1 = calculate_floating_point_0800071c((int)final_result1,(int)((ulonglong)final_result1 >> 0x20),0x54442d18,0x400921fb);\n  result1 = calculate_float_080009fc((int)final_result1,(int)((ulonglong)final_result1 >> 0x20));\n  *reversed_value1 = result2;\n  *reversed_value2 = result1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d78": "calculate_result_08004d78",
                "param_1": "input_values",
                "param_2": "reversed_value1",
                "param_3": "reversed_value2",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "result3",
                "uVar4": "final_result1",
                "uVar5": "final_result2"
            },
            "calling": [
                "FUN_080049cc"
            ],
            "called": [
                "FUN_080004c8",
                "FUN_080009fc",
                "FUN_08000e20",
                "thunk_FUN_08005838",
                "FUN_08000418",
                "FUN_0800071c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e6c": {
            "entrypoint": "0x08004e6c",
            "current_name": "execute_system_interrupt_08004e6c",
            "code": "\nvoid execute_system_interrupt_08004e6c(void)\n\n{\n  software_interrupt(0x3f);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e6c": "execute_system_interrupt_08004e6c"
            },
            "calling": [
                "FUN_08004e74"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e74": {
            "entrypoint": "0x08004e74",
            "current_name": "execute_or_skip_system_interrupt_08004e74",
            "code": "\nundefined4 execute_or_skip_system_interrupt_08004e74(undefined4 input_data)\n\n{\n  undefined4 result;\n  \n  if (DAT_200009f0 == 0) {\n    result = execute_system_interrupt_08004e6c(1,input_data,0);\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004e74": "execute_or_skip_system_interrupt_08004e74",
                "param_1": "input_data",
                "uVar1": "result"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08004e6c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ea4": {
            "entrypoint": "0x08004ea4",
            "current_name": "process_input_08004ea4",
            "code": "\nvoid processInput_08004ea4(undefined input1,undefined input2,undefined4 value1,undefined2 value2)\n\n{\n  process_input_08001ccc(&DAT_20000a88,input1,input2,1,value1,value2,DAT_20000008);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ea4": "process_input_08004ea4",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "value1",
                "param_4": "value2"
            },
            "calling": [],
            "called": [
                "FUN_08001ccc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee8": {
            "entrypoint": "0x08004ee8",
            "current_name": "process_and_return_data_08004ee8",
            "code": "\nvoid process_and_return_data_08004ee8(undefined input_param1,undefined input_param2,undefined4 input_param3,undefined2 input_param4)\n\n{\n  process_data_08001f6c(&DAT_20000a88,input_param1,input_param2,1,input_param3,input_param4,DAT_20000008);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ee8": "process_and_return_data_08004ee8",
                "param_1": "input_param1",
                "param_2": "input_param2",
                "param_3": "input_param3",
                "param_4": "input_param4"
            },
            "calling": [],
            "called": [
                "FUN_08001f6c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f2c": {
            "entrypoint": "0x08004f2c",
            "current_name": "get_global_variable_value_08004f2c",
            "code": "\nundefined4 getGlobalVariableValue_08004f2c(void)\n\n{\n  undefined4 value;\n  \n  value = get_value_from_global_variable_080015a0();\n  return value;\n}\n\n",
            "renaming": {
                "FUN_08004f2c": "get_global_variable_value_08004f2c",
                "uVar1": "value"
            },
            "calling": [],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "process_and_return_data_08004f3c",
            "code": "\nvoid process_and_return_data_08004f3c(undefined4 input_param,undefined2 additional_param)\n\n{\n  process_data(&DAT_20000adc,input_param,additional_param,0x32);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "process_and_return_data_08004f3c",
                "param_1": "input_param",
                "param_2": "additional_param",
                "process_data_08004436": "process_data"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08004436"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f60": {
            "entrypoint": "0x08004f60",
            "current_name": "clear_buffer_data_08004f60",
            "code": "\nvoid clearBufferData_08004f60(void)\n\n{\n  clearMemory(&DAT_20000ba8,0,0x40);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f60": "clear_buffer_data_08004f60",
                "memset_with_offset_08005d68": "clearMemory"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08005d68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f78": {
            "entrypoint": "0x08004f78",
            "current_name": "process_data_08004f78",
            "code": "\nvoid processData_08004f78(void)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  byte local_11;\n  \n  initializeParamArray(&DAT_20000a5c);\n  calculateResult(&DAT_20000a5c,&DAT_20000ba0);\n  clearBufferData();\n  uVar5 = reverseBits(DAT_20000ba0);\n  initializeVariables(&DAT_20000ba8,\"Pitch: %f\\n\",(int)uVar5,(int)((ulonglong)uVar5 >> 0x20));\n  uVar1 = countTrailingZeros(&DAT_20000ba8);\n  processAndReturnData(&DAT_20000ba8,uVar1);\n  DAT_200009f8 = calculateFloat(DAT_20000014,DAT_20000ba0);\n  DAT_20000be8 = floatToUIntBits(DAT_20000a00,DAT_200009f8);\n  uVar1 = floatToUIntBits(DAT_20000a04,DAT_200009f8);\n  DAT_20000b5c = calculateFloatingPoint(uVar1,DAT_20000b5c);\n  uVar1 = countAndAdjust(DAT_20000010);\n  iVar2 = checkConcatenationComplete(uVar1,DAT_20000b5c);\n  if (iVar2 == 0) {\n    uVar1 = countAndAdjust(DAT_200009f4);\n    iVar2 = checkConcatenationEmpty(uVar1,DAT_20000b5c);\n    if (iVar2 != 0) {\n      DAT_20000b5c = calculateModifiedValue(DAT_200009f4);\n    }\n  }\n  else {\n    DAT_20000b5c = calculateModifiedValue(DAT_20000010);\n  }\n  uVar4 = DAT_20000a08 ^ 0x80000000;\n  uVar1 = calculateFloat(DAT_200009f8,DAT_200009fc);\n  DAT_20000a58 = floatToUIntBits(uVar4,uVar1);\n  uVar1 = calculateFloatingPoint(DAT_20000be8,DAT_20000b5c);\n  uVar1 = calculateFloatingPoint(uVar1,DAT_20000a58);\n  uVar3 = countAndAdjust(DAT_20000010);\n  iVar2 = checkConcatenationEmpty(uVar1,uVar3);\n  if (iVar2 == 0) {\n    uVar3 = countAndAdjust(DAT_200009f4);\n    iVar2 = checkConcatenationComplete(uVar1,uVar3);\n    if (iVar2 == 0) {\n      local_11 = validateParam(uVar1);\n    }\n    else {\n      local_11 = DAT_200009f4;\n    }\n  }\n  else {\n    local_11 = DAT_20000010;\n  }\n  DAT_200009fc = DAT_200009f8;\n  iVar2 = checkConcatenationEmpty(DAT_200009f8,0);\n  updateParam(0x40010800,2,iVar2 != 0);\n  iVar2 = checkConcatenationEmpty(DAT_200009f8,0);\n  updateParam(0x40010800,4,iVar2 == 0);\n  iVar2 = checkConcatenationEmpty(DAT_200009f8,0);\n  updateParam(0x40010800,8,iVar2 != 0);\n  iVar2 = checkConcatenationEmpty(DAT_200009f8,0);\n  updateParam(0x40010800,0x10,iVar2 == 0);\n  *(uint *)(DAT_20000b1c + 0x34) = (uint)local_11;\n  *(uint *)(DAT_20000b1c + 0x40) = (uint)local_11;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f78": "process_data_08004f78",
                "initialize_param_array_08004ae0": "initializeParamArray",
                "calculate_result_08004bd8": "calculateResult",
                "clear_buffer_data_08004f60": "clearBufferData",
                "reverse_bits_08000418": "reverseBits",
                "initialize_variables_08005dfc": "initializeVariables",
                "count_trailing_zeros_08005e40": "countTrailingZeros",
                "process_and_return_data_08004f3c": "processAndReturnData",
                "calculate_float_08000aa4": "calculateFloat",
                "float_to_uint_bits_08000cb8": "floatToUIntBits",
                "calculate_floating_point_08000aa8": "calculateFloatingPoint",
                "count_and_adjust_08000c10": "countAndAdjust",
                "check_if_concatenation_complete_08000ff4": "checkConcatenationComplete",
                "check_if_concatenation_is_empty_08001030": "checkConcatenationEmpty",
                "calculate_modified_value_08000c08": "calculateModifiedValue",
                "validate_param_08001044": "validateParam",
                "update_param_08001a80": "updateParam"
            },
            "calling": [
                "FUN_080017b4",
                "FUN_080036f8"
            ],
            "called": [
                "FUN_08004bd8",
                "FUN_08005e40",
                "FUN_08000418",
                "FUN_08000ff4",
                "FUN_08001030",
                "FUN_08004ae0",
                "FUN_08000c10",
                "FUN_08000cb8",
                "FUN_08005dfc",
                "FUN_08001044",
                "FUN_08001a80",
                "FUN_08000c08",
                "FUN_08000aa8",
                "FUN_08004f60",
                "FUN_08000aa4",
                "FUN_08004f3c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005224": {
            "entrypoint": "0x08005224",
            "current_name": "initialize_system_08005224",
            "code": "\nvoid initialize_system_08005224(void)\n\n{\n  initialize_system_08005224_1();\n  initialize_system_08005224_2();\n  update_configuration();\n  initialize_memory();\n  initialize_device();\n  initialize_data();\n  initialize_program();\n  DAT_20000a54 = 0x8004ea5;\n  DAT_20000a4c = 0x8004ee9;\n  DAT_20000a50 = 0x8004f2d;\n  update_bit_value_and_set_flag(&DAT_20000b1c,0);\n  update_bit_value_and_set_flag(&DAT_20000b1c,0xc);\n  initialize_data_2(&DAT_20000a5c);\n  set_flags_on_bits(&DAT_20000b60);\n  execute_or_skip_system_interrupt(0);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005224": "initialize_system_08005224",
                "initialize_system_080014f0": "initialize_system_1",
                "initialize_system_080052a0": "initialize_system_2",
                "update_configuration_080055f4": "update_configuration",
                "initialize_memory_08005348": "initialize_memory",
                "initialize_device_08005598": "initialize_device",
                "initialize_data_08005500": "initialize_data",
                "initialize_program_080053b0": "initialize_program",
                "update_bit_value_and_set_flag_080036a8": "update_bit_value_and_set_flag",
                "initialize_data_0800491c": "initialize_data_2",
                "set_flags_on_bits_0800360c": "set_flags_on_bits",
                "execute_or_skip_system_interrupt_08004e74": "execute_or_skip_system_interrupt"
            },
            "calling": [
                "entry"
            ],
            "called": [
                "FUN_080053b0",
                "FUN_0800360c",
                "FUN_080014f0",
                "FUN_08005500",
                "FUN_08005598",
                "FUN_080052a0",
                "FUN_0800491c",
                "FUN_080036a8",
                "FUN_08005348",
                "FUN_080055f4",
                "FUN_08004e74"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052a0": {
            "entrypoint": "0x080052a0",
            "current_name": "initialize_system_080052a0",
            "code": "\nvoid initializeSystem_080052a0(void)\n\n{\n  int result;\n  undefined8 data;\n  undefined4 statusFlag;\n  undefined4 actionType;\n  undefined4 processingTime;\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined4 isEnabled;\n  undefined4 constant1;\n  undefined4 constant2;\n  undefined4 constant3;\n  undefined4 constant4;\n  undefined4 constant5;\n  undefined4 constant6;\n  \n  isEnabled = 1;\n  constant1 = 0x10000;\n  constant2 = 0;\n  constant3 = 1;\n  constant4 = 2;\n  constant5 = 0x10000;\n  constant6 = 0x1c0000;\n  result = executeAction(&isEnabled);\n  if (result != 0) {\n    infiniteLoop(\"../src/main.c\",0x151);\n  }\n  statusFlag = 0xf;\n  actionType = 2;\n  processingTime = 0x80;\n  temp1 = 0;\n  temp2 = 0;\n  result = updateDataAndCalculateProcessingTime(&statusFlag,2);\n  if (result != 0) {\n    infiniteLoop(\"../src/main.c\",0x15e);\n  }\n  data = getData();\n  initializeData((uint)data / 1000,(int)((ulonglong)data >> 0x20),(uint)data * 0x10624dd3);\n  setFlag(4);\n  storeByteValue(0xffffffff,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052a0": "initialize_system_080052a0",
                "local_44": "statusFlag",
                "local_40": "actionType",
                "local_3c": "processingTime",
                "local_38": "temp1",
                "local_34": "temp2",
                "local_30": "isEnabled",
                "local_2c": "constant1",
                "local_28": "constant2",
                "local_20": "constant3",
                "local_14": "constant4",
                "local_10": "constant5",
                "local_c": "constant6",
                "iVar1": "result",
                "uVar2": "data",
                "execute_action_08002d98": "executeAction",
                "infinite_loop_08005674": "infiniteLoop",
                "update_data_and_calculate_processing_time_08003260": "updateDataAndCalculateProcessingTime",
                "get_data_08003504": "getData",
                "initialize_data_08001762": "initializeData",
                "set_flag_0800177c": "setFlag",
                "store_byte_value_0800172a": "storeByteValue"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08003504",
                "FUN_0800172a",
                "FUN_08005674",
                "FUN_08002d98",
                "FUN_08003260",
                "FUN_08001762",
                "FUN_0800177c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005348": {
            "entrypoint": "0x08005348",
            "current_name": "initialize_memory_08005348",
            "code": "\nvoid initializeMemory_08005348(void)\n\n{\n  int result;\n  \n  DAT_20000a88 = 0x40005400;\n  DAT_20000a8c = 400000;\n  DAT_20000a90 = 0;\n  DAT_20000a94 = 0;\n  DAT_20000a98 = 0x4000;\n  DAT_20000a9c = 0;\n  DAT_20000aa0 = 0;\n  DAT_20000aa4 = 0;\n  DAT_20000aa8 = 0;\n  result = calculate_and_update_values_08001ab0(&DAT_20000a88);\n  if (result != 0) {\n    infinite_loop_08005674(\"../src/main.c\",0x17a);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005348": "initialize_memory_08005348",
                "iVar1": "result"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08001ab0",
                "FUN_08005674"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053b0": {
            "entrypoint": "0x080053b0",
            "current_name": "initialize_program_080053b0",
            "code": "\nvoid initialize_program_080053b0(void)\n\n{\n  int result;\n  undefined4 flag_1;\n  undefined4 flag_2;\n  undefined4 flag_3;\n  undefined4 flag_4;\n  undefined4 flag_5;\n  undefined4 memory_size;\n  undefined4 flag_6;\n  undefined4 data_size;\n  undefined4 param_1;\n  undefined4 param_2;\n  undefined4 param_3;\n  undefined4 param_4;\n  undefined4 param_5;\n  undefined4 param_6;\n  undefined4 flag_value;\n  undefined4 data_value;\n  undefined4 array_values [4];\n  \n  DAT_20000b1c = 0x40012c00;\n  DAT_20000b20 = 0x708;\n  DAT_20000b24 = 0;\n  DAT_20000b28 = 100;\n  DAT_20000b2c = 0;\n  DAT_20000b30 = 0;\n  DAT_20000b34 = 0;\n  result = process_data_080035a4(&DAT_20000b1c);\n  if (result != 0) {\n    infinite_loop_08005674(\"../src/main.c\",399);\n  }\n  array_values[0] = 0x1000;\n  result = update_function_08003a94(&DAT_20000b1c,array_values);\n  if (result != 0) {\n    infinite_loop_08005674(\"../src/main.c\",0x194);\n  }\n  result = initialize_memory_08003640(&DAT_20000b1c);\n  if (result != 0) {\n    infinite_loop_08005674(\"../src/main.c\",0x198);\n  }\n  flag_value = 0;\n  data_value = 0;\n  result = update_flag_and_data_080042de(&DAT_20000b1c,&flag_value);\n  if (result != 0) {\n    infinite_loop_08005674(\"../src/main.c\",0x19f);\n  }\n  data_size = 0x60;\n  param_1 = 0;\n  param_2 = 0;\n  param_3 = 0;\n  param_4 = 0;\n  param_5 = 0;\n  param_6 = 0;\n  result = process_params_08003908(&DAT_20000b1c,&data_size,0);\n  if (result != 0) {\n    infinite_loop_08005674(\"../src/main.c\",0x1ab);\n  }\n  result = process_params_08003908(&DAT_20000b1c,&data_size,0xc);\n  if (result != 0) {\n    infinite_loop_08005674(\"../src/main.c\",0x1b0);\n  }\n  flag_1 = 0;\n  flag_2 = 0;\n  flag_3 = 0;\n  flag_4 = 0;\n  flag_5 = 0;\n  memory_size = 0x2000;\n  flag_6 = 0;\n  result = set_flag_if_true_0800422e(&DAT_20000b1c,&flag_1);\n  if (result != 0) {\n    infinite_loop_08005674(\"../src/main.c\",0x1bc);\n  }\n  update_parameter_if_value_matches_08005680(&DAT_20000b1c);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053b0": "initialize_program_080053b0",
                "iVar1": "result",
                "local_58": "flag_1",
                "local_54": "flag_2",
                "local_50": "flag_3",
                "local_4c": "flag_4",
                "local_48": "flag_5",
                "local_44": "memory_size",
                "local_40": "flag_6",
                "local_3c": "data_size",
                "local_38": "param_1",
                "local_34": "param_2",
                "local_30": "param_3",
                "local_2c": "param_4",
                "local_28": "param_5",
                "local_24": "param_6",
                "local_20": "flag_value",
                "local_1c": "data_value",
                "local_18": "array_values"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08003a94",
                "FUN_08003908",
                "FUN_0800422e",
                "FUN_08003640",
                "FUN_080035a4",
                "FUN_08005674",
                "FUN_08005680",
                "FUN_080042de"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005500": {
            "entrypoint": "0x08005500",
            "current_name": "initialize_data_08005500",
            "code": "\nvoid initializeData_08005500(void)\n\n{\n  int returnValue;\n  undefined4 bufferSize;\n  undefined4 flag;\n  undefined4 array [4];\n  \n  DAT_20000b60 = 0x40000000;\n  DAT_20000b64 = 36000;\n  DAT_20000b68 = 0;\n  DAT_20000b6c = 0x14;\n  DAT_20000b70 = 0;\n  DAT_20000b78 = 0;\n  returnValue = processData(&DAT_20000b60);\n  if (returnValue != 0) {\n    handleError(\"../src/main.c\",0x1d0);\n  }\n  array[0] = 0x1000;\n  returnValue = updateFunction(&DAT_20000b60,array);\n  if (returnValue != 0) {\n    handleError(\"../src/main.c\",0x1d5);\n  }\n  bufferSize = 0x20;\n  flag = 0;\n  returnValue = updateFlagAndData(&DAT_20000b60,&bufferSize);\n  if (returnValue != 0) {\n    handleError(\"../src/main.c\",0x1dc);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005500": "initialize_data_08005500",
                "iVar1": "returnValue",
                "local_20": "bufferSize",
                "local_1c": "flag",
                "local_18": "array",
                "process_data_080035a4": "processData",
                "infinite_loop_08005674": "handleError",
                "update_function_08003a94": "updateFunction",
                "update_flag_and_data_080042de": "updateFlagAndData"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08003a94",
                "FUN_080035a4",
                "FUN_08005674",
                "FUN_080042de"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005598": {
            "entrypoint": "0x08005598",
            "current_name": "initialize_device_08005598",
            "code": "\nvoid initialize_device_08005598(void)\n\n{\n  int result;\n  \n  DAT_20000adc = 0x40013800;\n  DAT_20000ae0 = 0x1c200;\n  DAT_20000ae4 = 0;\n  DAT_20000ae8 = 0;\n  DAT_20000aec = 0;\n  DAT_20000af0 = 0xc;\n  DAT_20000af4 = 0;\n  DAT_20000af8 = 0;\n  result = initialize_device_08005598_0800438a(&DAT_20000adc);\n  if (result != 0) {\n    infinite_loop_08005674(\"../src/main.c\",0x1ed);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005598": "initialize_device_08005598",
                "iVar1": "result"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_0800438a",
                "FUN_08005674"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055f4": {
            "entrypoint": "0x080055f4",
            "current_name": "update_configuration_080055f4",
            "code": "\n\n\nvoid updateConfiguration_080055f4(void)\n\n{\n  undefined4 parameter1;\n  undefined4 parameter2;\n  undefined4 parameter3;\n  \n  _DAT_40021018 = _DAT_40021018 | 0x2c;\n  update_param_08001a80(0x40010800,0x1e,0,_DAT_40021018 & 8);\n  parameter1 = 0x1e;\n  parameter2 = 1;\n  parameter3 = 2;\n  update_parameter_bits_080017c4(0x40010800,&parameter1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055f4": "update_configuration_080055f4",
                "local_18": "parameter1",
                "local_14": "parameter2",
                "local_c": "parameter3"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08001a80",
                "FUN_080017c4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005674": {
            "entrypoint": "0x08005674",
            "current_name": "infinite_loop_08005674",
            "code": "\nvoid infiniteLoop_08005674(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005674": "infinite_loop_08005674"
            },
            "calling": [
                "FUN_080053b0",
                "FUN_08005500",
                "FUN_080052a0",
                "FUN_08005598",
                "FUN_08005348"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005680": {
            "entrypoint": "0x08005680",
            "current_name": "update_parameter_if_value_matches_08005680",
            "code": "\nvoid update_parameter_if_value_matches_08005680(int *parameter_ptr)\n\n{\n  undefined4 updated_value;\n  undefined4 count_value;\n  undefined4 flag_value;\n  \n  if (*parameter_ptr == 0x40012c00) {\n    updated_value = 0x900;\n    count_value = 2;\n    flag_value = 2;\n    update_parameter_bits_080017c4(0x40010800,&updated_value);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005680": "update_parameter_if_value_matches_08005680",
                "param_1": "parameter_ptr",
                "local_18": "updated_value",
                "local_14": "count_value",
                "local_c": "flag_value"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [
                "FUN_080017c4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005704": {
            "entrypoint": "0x08005704",
            "current_name": "initialize_data_processing_08005704",
            "code": "\nvoid initialize_data_processing_08005704(void)\n\n{\n  increment_data_value();\n  process_initial_data();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005704": "initialize_data_processing_08005704",
                "increment_data_value_0800157c": "increment_data_value",
                "process_initial_data_080017b4": "process_initial_data"
            },
            "calling": [],
            "called": [
                "FUN_080017b4",
                "FUN_0800157c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "initialize_flags_08005714",
            "code": "\nvoid initialize_flags_08005714(void)\n\n{\n  process_flags_080036f8(&DAT_20000b60);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005714": "initialize_flags_08005714"
            },
            "calling": [],
            "called": [
                "FUN_080036f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005728": {
            "entrypoint": "0x08005728",
            "current_name": "initialize_data_08005728",
            "code": "\nundefined * initializeData_08005728(int size)\n\n{\n  undefined4 *dataPointer;\n  undefined *result;\n  undefined temporaryBuffer [4];\n  int remainingSize;\n  undefined *currentData;\n  \n  if (DAT_20000a10 == (undefined *)0x0) {\n    DAT_20000a10 = &DAT_20000c18;\n  }\n  currentData = DAT_20000a10;\n  if (temporaryBuffer < DAT_20000a10 + size) {\n    remainingSize = size;\n    dataPointer = (undefined4 *)get_data_08005d14();\n    *dataPointer = 0xc;\n    result = (undefined *)0xffffffff;\n  }\n  else {\n    result = DAT_20000a10;\n    DAT_20000a10 = DAT_20000a10 + size;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005728": "initialize_data_08005728",
                "param_1": "size",
                "puVar1": "dataPointer",
                "puVar2": "result",
                "auStack_18": "temporaryBuffer",
                "local_14": "remainingSize",
                "local_c": "currentData"
            },
            "calling": [
                "FUN_08009744"
            ],
            "called": [
                "FUN_08005d14"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005780": {
            "entrypoint": "0x08005780",
            "current_name": "initialize_memory_registers_08005780",
            "code": "\n\n\nvoid initializeMemoryRegisters_08005780(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005780": "initialize_memory_registers_08005780"
            },
            "calling": [
                "entry"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "entry": {
            "entrypoint": "0x080057e8",
            "current_name": "entry",
            "code": "\nvoid entry(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  code *UNRECOVERED_JUMPTABLE;\n  \n  for (iVar1 = 0; (undefined4 *)(iVar1 + 0x20000000) < &DAT_200009c8; iVar1 = iVar1 + 4) {\n    *(undefined4 *)(iVar1 + 0x20000000) = *(undefined4 *)(iVar1 + 0x800a1a4);\n  }\n  for (puVar2 = &DAT_200009c8; puVar2 < &DAT_20000c14; puVar2 = puVar2 + 1) {\n    *puVar2 = 0;\n  }\n  initialize_memory_registers_08005780();\n  execute_function_set_08005d20();\n  UNRECOVERED_JUMPTABLE = (code *)0x800581a;\n  initialize_system_08005224();\n                    /* WARNING: Could not recover jumptable at 0x0800581a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "FUN_08005d20",
                "FUN_08005780",
                "FUN_08005224"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_08005838": {
            "entrypoint": "0x08005834",
            "current_name": "calculate_result_thunk_08005838",
            "code": "\nuint calculateResult_thunk_08005838(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int temp1;\n  undefined4 temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  undefined8 temp6;\n  \n  temp4 = input4 & 0x7fffffff;\n  if ((0x7ff00000 < (temp4 | (-input3 | input3) >> 0x1f)) ||\n     (temp5 = input2 & 0x7fffffff, 0x7ff00000 < (temp5 | (-input1 | input1) >> 0x1f))) {\n    temp4 = perform_unsigned_division_0800015c(input3,input4,input1,input2);\n    return temp4;\n  }\n  if ((input4 + 0xc0100000 | input3) == 0) {\n    temp4 = perform_operation_080059f0();\n    return temp4;\n  }\n  temp3 = (int)input4 >> 0x1e & 2U | input2 >> 0x1f;\n  if ((temp5 | input1) == 0) {\n    if (temp3 == 2) {\n      return 0x54442d18;\n    }\n    if (temp3 != 3) {\n      return input1;\n    }\n  }\n  else if ((temp4 | input3) != 0) {\n    if (temp4 == 0x7ff00000) {\n      if (temp5 == 0x7ff00000) {\n        if (temp3 == 2) {\n          return 0x7f3321d2;\n        }\n        if (temp3 == 3) {\n          return 0x7f3321d2;\n        }\n        if (temp3 == 1) {\n          return 0x54442d18;\n        }\n        return 0x54442d18;\n      }\n      if (temp3 == 2) {\n        return 0x54442d18;\n      }\n      if (temp3 != 3) {\n        if (temp3 != 1) {\n          return 0;\n        }\n        return 0;\n      }\n    }\n    else if (temp5 != 0x7ff00000) {\n      temp1 = (int)(temp5 - temp4) >> 0x14;\n      if (temp1 < 0x3d) {\n        if (((int)input4 < 0) && (temp1 + 0x3c < 0 != SCARRY4(temp1,0x3c))) {\n          temp6 = 0;\n        }\n        else {\n          calculate_floating_point_0800071c(input1,input2,input3,input4,input4);\n          FUNC_08005d0c();\n          temp6 = perform_operation_080059f0();\n        }\n      }\n      else {\n        temp6 = 0x3ff921fb54442d18;\n      }\n      temp2 = (undefined4)((ulonglong)temp6 >> 0x20);\n      temp4 = (uint)temp6;\n      if (temp3 == 1) {\n        return temp4;\n      }\n      if (temp3 == 2) {\n        temp6 = perform_arithmetic_operation_08000158(temp4,temp2,0x33145c07,0x3ca1a626);\n        temp4 = perform_arithmetic_operation_08000158(0x54442d18,0x400921fb,(int)temp6,(int)((ulonglong)temp6 >> 0x20));\n        return temp4;\n      }\n      if (temp3 != 0) {\n        temp6 = perform_arithmetic_operation_08000158(temp4,temp2,0x33145c07,0x3ca1a626);\n        temp4 = perform_arithmetic_operation_08000158((int)temp6,(int)((ulonglong)temp6 >> 0x20),0x54442d18,0x400921fb);\n        return temp4;\n      }\n      return temp4;\n    }\n  }\n  return 0x54442d18;\n}\n\n",
            "renaming": {
                "thunk_FUN_08005838": "calculate_result_thunk_08005838",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "uVar6": "temp6"
            },
            "calling": [
                "FUN_08004bd8",
                "FUN_08004d78"
            ],
            "called": [
                "FUN_08005838"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005838": {
            "entrypoint": "0x08005838",
            "current_name": "calculate_floating_point_08005838",
            "code": "\nuint calculateFloatingPoint_08005838(uint inputValue1,uint inputValue2,uint inputValue3,uint inputValue4)\n\n{\n  int difference;\n  undefined4 result1;\n  uint flag;\n  uint modifiedValue4;\n  uint modifiedValue2;\n  undefined8 result2;\n  \n  modifiedValue4 = inputValue4 & 0x7fffffff;\n  if ((0x7ff00000 < (modifiedValue4 | (-inputValue3 | inputValue3) >> 0x1f)) ||\n     (modifiedValue2 = inputValue2 & 0x7fffffff, 0x7ff00000 < (modifiedValue2 | (-inputValue1 | inputValue1) >> 0x1f))) {\n    modifiedValue4 = perform_unsigned_division_0800015c(inputValue3,inputValue4,inputValue1,inputValue2);\n    return modifiedValue4;\n  }\n  if ((inputValue4 + 0xc0100000 | inputValue3) == 0) {\n    modifiedValue4 = perform_operation_080059f0();\n    return modifiedValue4;\n  }\n  flag = (int)inputValue4 >> 0x1e & 2U | inputValue2 >> 0x1f;\n  if ((modifiedValue2 | inputValue1) == 0) {\n    if (flag == 2) {\n      return 0x54442d18;\n    }\n    if (flag != 3) {\n      return inputValue1;\n    }\n  }\n  else if ((modifiedValue4 | inputValue3) != 0) {\n    if (modifiedValue4 == 0x7ff00000) {\n      if (modifiedValue2 == 0x7ff00000) {\n        if (flag == 2) {\n          return 0x7f3321d2;\n        }\n        if (flag == 3) {\n          return 0x7f3321d2;\n        }\n        if (flag == 1) {\n          return 0x54442d18;\n        }\n        return 0x54442d18;\n      }\n      if (flag == 2) {\n        return 0x54442d18;\n      }\n      if (flag != 3) {\n        if (flag != 1) {\n          return 0;\n        }\n        return 0;\n      }\n    }\n    else if (modifiedValue2 != 0x7ff00000) {\n      difference = (int)(modifiedValue2 - modifiedValue4) >> 0x14;\n      if (difference < 0x3d) {\n        if (((int)inputValue4 < 0) && (difference + 0x3c < 0 != SCARRY4(difference,0x3c))) {\n          result2 = 0;\n        }\n        else {\n          calculate_floating_point_0800071c(inputValue1,inputValue2,inputValue3,inputValue4,inputValue4);\n          FUNC_08005d0c();\n          result2 = perform_operation_080059f0();\n        }\n      }\n      else {\n        result2 = 0x3ff921fb54442d18;\n      }\n      result1 = (undefined4)((ulonglong)result2 >> 0x20);\n      modifiedValue4 = (uint)result2;\n      if (flag == 1) {\n        return modifiedValue4;\n      }\n      if (flag == 2) {\n        result2 = perform_arithmetic_operation_08000158(modifiedValue4,result1,0x33145c07,0x3ca1a626);\n        modifiedValue4 = perform_arithmetic_operation_08000158(0x54442d18,0x400921fb,(int)result2,(int)((ulonglong)result2 >> 0x20));\n        return modifiedValue4;\n      }\n      if (flag != 0) {\n        result2 = perform_arithmetic_operation_08000158(modifiedValue4,result1,0x33145c07,0x3ca1a626);\n        modifiedValue4 = perform_arithmetic_operation_08000158((int)result2,(int)((ulonglong)result2 >> 0x20),0x54442d18,0x400921fb);\n        return modifiedValue4;\n      }\n      return modifiedValue4;\n    }\n  }\n  return 0x54442d18;\n}\n\n",
            "renaming": {
                "FUN_08005838": "calculate_floating_point_08005838",
                "param_1": "inputValue1",
                "param_2": "inputValue2",
                "param_3": "inputValue3",
                "param_4": "inputValue4",
                "iVar1": "difference",
                "uVar2": "result1",
                "uVar3": "flag",
                "uVar4": "modifiedValue4",
                "uVar5": "modifiedValue2",
                "uVar6": "result2"
            },
            "calling": [
                "thunk_FUN_08005838"
            ],
            "called": [
                "FUN_08000158",
                "FUN_080059f0",
                "FUN_08005d0c",
                "FUN_0800015c",
                "FUN_0800071c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f0": {
            "entrypoint": "0x080059f0",
            "current_name": "perform_operation_080059f0",
            "code": "\nundefined8 performOperation_080059f0(int num1,uint num2,undefined4 var1,undefined4 var2)\n\n{\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined4 temp3;\n  undefined4 temp4;\n  undefined4 temp5;\n  undefined4 temp6;\n  uint absNum2;\n  int result;\n  undefined8 tempResult;\n  undefined8 finalResult;\n  \n  finalResult = CONCAT44(num2,num1);\n  absNum2 = num2 & 0x7fffffff;\n  if (absNum2 < 0x44100000) {\n    if (absNum2 < 0x3fdc0000) {\n      if (absNum2 < 0x3e200000) {\n        tempResult = perform_unsigned_division_0800015c(num1,num2,0x8800759c,0x7e37e43c,var2);\n        result = is_string_terminated_080009e8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0,0x3ff00000);\n        if (result != 0) {\n          return CONCAT44(num2,num1);\n        }\n      }\n      result = -1;\n    }\n    else {\n      finalResult = FUNC_08005d0c();\n      temp4 = (undefined4)((ulonglong)finalResult >> 0x20);\n      temp1 = (undefined4)finalResult;\n      if (absNum2 < 0x3ff30000) {\n        if (absNum2 < 0x3fe60000) {\n          finalResult = perform_unsigned_division_0800015c(temp1,temp4,temp1,temp4);\n          finalResult = perform_arithmetic_operation_08000158((int)finalResult,(int)((ulonglong)finalResult >> 0x20),0,0x3ff00000);\n          tempResult = perform_unsigned_division_0800015c(temp1,temp4,0,0x40000000);\n          finalResult = calculate_floating_point_0800071c((int)finalResult,(int)((ulonglong)finalResult >> 0x20),(int)tempResult,\n                                (int)((ulonglong)tempResult >> 0x20));\n          result = 0;\n        }\n        else {\n          finalResult = perform_arithmetic_operation_08000158(temp1,temp4,0,0x3ff00000);\n          tempResult = perform_unsigned_division_0800015c(temp1,temp4,0,0x3ff00000);\n          finalResult = calculate_floating_point_0800071c((int)finalResult,(int)((ulonglong)finalResult >> 0x20),(int)tempResult,\n                                (int)((ulonglong)tempResult >> 0x20));\n          result = 1;\n        }\n      }\n      else if (absNum2 < 0x40038000) {\n        finalResult = perform_arithmetic_operation_08000158(temp1,temp4,0,0x3ff80000);\n        tempResult = calculate_bitwise_difference_080004c8(temp1,temp4,0,0x3ff80000);\n        tempResult = perform_unsigned_division_0800015c((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0,0x3ff00000);\n        finalResult = calculate_floating_point_0800071c((int)finalResult,(int)((ulonglong)finalResult >> 0x20),(int)tempResult,\n                              (int)((ulonglong)tempResult >> 0x20));\n        result = 2;\n      }\n      else {\n        finalResult = calculate_floating_point_0800071c(0,0xbff00000,temp1,temp4);\n        result = 3;\n      }\n    }\n    temp6 = (undefined4)((ulonglong)finalResult >> 0x20);\n    temp5 = (undefined4)finalResult;\n    finalResult = calculate_bitwise_difference_080004c8(temp5,temp6,temp5,temp6);\n    temp2 = (undefined4)((ulonglong)finalResult >> 0x20);\n    temp1 = (undefined4)finalResult;\n    finalResult = calculate_bitwise_difference_080004c8(temp1,temp2,temp1,temp2);\n    temp3 = (undefined4)((ulonglong)finalResult >> 0x20);\n    temp4 = (undefined4)finalResult;\n    finalResult = calculate_bitwise_difference_080004c8(temp4,temp3,0xe322da11,0x3f90ad3a);\n    finalResult = perform_unsigned_division_0800015c((int)finalResult,(int)((ulonglong)finalResult >> 0x20),0x24760deb,0x3fa97b4b);\n    finalResult = calculate_bitwise_difference_080004c8((int)finalResult,(int)((ulonglong)finalResult >> 0x20),temp4,temp3);\n    finalResult = perform_unsigned_division_0800015c((int)finalResult,(int)((ulonglong)finalResult >> 0x20),0xa0d03d51,0x3fb10d66);\n    finalResult = calculate_bitwise_difference_080004c8((int)finalResult,(int)((ulonglong)finalResult >> 0x20),temp4,temp3);\n    finalResult = perform_unsigned_division_0800015c((int)finalResult,(int)((ulonglong)finalResult >> 0x20),0xc54c206e,0x3fb745cd);\n    finalResult = calculate_bitwise_difference_080004c8((int)finalResult,(int)((ulonglong)finalResult >> 0x20),temp4,temp3);\n    finalResult = perform_unsigned_division_0800015c((int)finalResult,(int)((ulonglong)finalResult >> 0x20),0x920083ff,0x3fc24924);\n    finalResult = calculate_bitwise_difference_080004c8((int)finalResult,(int)((ulonglong)finalResult >> 0x20),temp4,temp3);\n    finalResult = perform_unsigned_division_0800015c((int)finalResult,(int)((ulonglong)finalResult >> 0x20),0x5555550d,0x3fd55555);\n    finalResult = calculate_bitwise_difference_080004c8((int)finalResult,(int)((ulonglong)finalResult >> 0x20),temp1,temp2);\n    tempResult = calculate_bitwise_difference_080004c8(temp4,temp3,0x2c6a6c2f,0xbfa2b444);\n    tempResult = perform_arithmetic_operation_08000158((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0x52defd9a,0x3fadde2d);\n    tempResult = calculate_bitwise_difference_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),temp4,temp3);\n    tempResult = perform_arithmetic_operation_08000158((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    tempResult = calculate_bitwise_difference_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),temp4,temp3);\n    tempResult = perform_arithmetic_operation_08000158((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0xfe231671,0x3fbc71c6);\n    tempResult = calculate_bitwise_difference_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),temp4,temp3);\n    tempResult = perform_arithmetic_operation_08000158((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0x9998ebc4,0x3fc99999);\n    tempResult = calculate_bitwise_difference_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),temp4,temp3);\n    finalResult = perform_unsigned_division_0800015c((int)finalResult,(int)((ulonglong)finalResult >> 0x20),(int)tempResult,\n                          (int)((ulonglong)tempResult >> 0x20));\n    finalResult = calculate_bitwise_difference_080004c8((int)finalResult,(int)((ulonglong)finalResult >> 0x20),temp5,temp6);\n    temp1 = (undefined4)((ulonglong)finalResult >> 0x20);\n    if (result == -1) {\n      finalResult = perform_arithmetic_operation_08000158(temp5,temp6,(int)finalResult,temp1);\n      return finalResult;\n    }\n    result = result * 8;\n    finalResult = perform_arithmetic_operation_08000158((int)finalResult,temp1,*(undefined4 *)(&UNK_08009ee8 + result),\n                          *(undefined4 *)(&UNK_08009eec + result));\n    finalResult = perform_arithmetic_operation_08000158((int)finalResult,(int)((ulonglong)finalResult >> 0x20),temp5,temp6);\n    finalResult = perform_arithmetic_operation_08000158(*(undefined4 *)(&UNK_08009ec8 + result),\n                          *(undefined4 *)(&UNK_08009ecc + result),(int)finalResult,\n                          (int)((ulonglong)finalResult >> 0x20));\n    if ((int)num2 < 0) {\n      return CONCAT44((int)((ulonglong)finalResult >> 0x20) + -0x80000000,(int)finalResult);\n    }\n  }\n  else {\n    if ((absNum2 < 0x7ff00001) && ((absNum2 != 0x7ff00000 || (num1 == 0)))) {\n      temp1 = 0xbff921fb;\n      if (0 < (int)num2) {\n        temp1 = 0x3ff921fb;\n      }\n      return CONCAT44(temp1,0x54442d18);\n    }\n    finalResult = perform_unsigned_division_0800015c(num1,num2,num1,num2,var2);\n  }\n  return finalResult;\n}\n\n",
            "renaming": {
                "FUN_080059f0": "perform_operation_080059f0",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "var1",
                "param_4": "var2",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "uVar6": "temp6",
                "uVar7": "absNum2",
                "iVar8": "result",
                "uVar9": "tempResult",
                "uVar10": "finalResult"
            },
            "calling": [
                "FUN_08005838"
            ],
            "called": [
                "FUN_080004c8",
                "FUN_08000158",
                "FUN_080009e8",
                "FUN_08005d0c",
                "FUN_0800015c",
                "FUN_0800071c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d0c": {
            "entrypoint": "0x08005d0c",
            "current_name": "FUNC_08005d0c",
            "code": "\nvoid FUNC_08005d0c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d0c": "FUNC_08005d0c"
            },
            "calling": [
                "FUN_080059f0",
                "FUN_08005838"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005d14": {
            "entrypoint": "0x08005d14",
            "current_name": "get_data_08005d14",
            "code": "\nundefined4 get_data_08005d14(void)\n\n{\n  return DAT_2000001c;\n}\n\n",
            "renaming": {
                "FUN_08005d14": "get_data_08005d14"
            },
            "calling": [
                "FUN_08005728"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d20": {
            "entrypoint": "0x08005d20",
            "current_name": "execute_function_set_08005d20",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005d2c) */\n/* WARNING: Removing unreachable block (ram,0x08005d2e) */\n\nvoid executeFunctionSet_08005d20(void)\n\n{\n  int iterationCount;\n  code **functionPointer;\n  \n  FUNC_08009e68();\n  iterationCount = 0;\n  functionPointer = (code **)&DAT_0800a198;\n  do {\n    iterationCount = iterationCount + 1;\n    (**functionPointer)();\n    functionPointer = functionPointer + 1;\n  } while (iterationCount != 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d20": "execute_function_set_08005d20",
                "iVar1": "iterationCount",
                "ppcVar2": "functionPointer"
            },
            "calling": [
                "entry"
            ],
            "called": [
                "FUN_08000134",
                "FUN_08009e68",
                "FUN_080078a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d68": {
            "entrypoint": "0x08005d68",
            "current_name": "memset_with_offset_08005d68",
            "code": "\nvoid memset_with_offset_08005d68(undefined4 *dest,undefined value,uint size)\n\n{\n  undefined4 *dest_ptr;\n  undefined4 *next_dest_ptr;\n  uint remaining_size;\n  undefined4 value_32;\n  bool is_size_zero;\n  \n  if (((uint)dest & 3) != 0) {\n    remaining_size = size - 1;\n    dest_ptr = dest;\n    if (size == 0) {\n      return;\n    }\n    while( true ) {\n      dest = (undefined4 *)((int)dest_ptr + 1);\n      *(undefined *)dest_ptr = value;\n      size = remaining_size;\n      if (((uint)dest & 3) == 0) break;\n      is_size_zero = remaining_size == 0;\n      remaining_size = remaining_size - 1;\n      dest_ptr = dest;\n      if (is_size_zero) {\n        return;\n      }\n    }\n  }\n  if (3 < size) {\n    value_32 = CONCAT22(CONCAT11(value,value),CONCAT11(value,value));\n    remaining_size = size;\n    dest_ptr = dest;\n    if (0xf < size) {\n      remaining_size = size - 0x10;\n      dest_ptr = dest + 4;\n      do {\n        dest_ptr[-4] = value_32;\n        dest_ptr[-3] = value_32;\n        dest_ptr[-2] = value_32;\n        dest_ptr[-1] = value_32;\n        dest_ptr = dest_ptr + 4;\n      } while (dest_ptr != (undefined4 *)((int)dest + (remaining_size & 0xfffffff0) + 0x20));\n      size = size & 0xf;\n      dest = dest + ((remaining_size >> 4) + 1) * 4;\n      remaining_size = size;\n      dest_ptr = dest;\n      if (size < 4) goto LAB_08005de4;\n    }\n    do {\n      size = size - 4;\n      *dest = value_32;\n      dest = dest + 1;\n    } while (3 < size);\n    dest = (undefined4 *)((int)dest_ptr + (remaining_size - 4 & 0xfffffffc) + 4);\n    size = remaining_size & 3;\n  }\nLAB_08005de4:\n  if (size != 0) {\n    dest_ptr = dest;\n    do {\n      next_dest_ptr = (undefined4 *)((int)dest_ptr + 1);\n      *(undefined *)dest_ptr = value;\n      dest_ptr = next_dest_ptr;\n    } while ((undefined4 *)(size + (int)dest) != next_dest_ptr);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d68": "memset_with_offset_08005d68",
                "param_1": "dest",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "dest_ptr",
                "puVar2": "next_dest_ptr",
                "uVar3": "remaining_size",
                "uVar4": "value_32",
                "bVar5": "is_size_zero"
            },
            "calling": [
                "FUN_08004f60",
                "FUN_08009980"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005dfc": {
            "entrypoint": "0x08005dfc",
            "current_name": "initialize_variables_08005dfc",
            "code": "\nvoid initializeVariables_08005dfc(undefined *dataPointer,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  undefined *localArray [2];\n  undefined4 localVariable1;\n  undefined4 localVariable2;\n  undefined *localPointer;\n  undefined4 localVariable3;\n  undefined4 localVariable4;\n  undefined4 localVariable5;\n  \n  localVariable3 = 0x7fffffff;\n  localVariable1 = 0x7fffffff;\n  localVariable2 = 0xffff0208;\n  localArray[0] = dataPointer;\n  localPointer = dataPointer;\n  localVariable4 = param3;\n  localVariable5 = param4;\n  FUNC_08005e9c(DAT_2000001c,localArray,param2,&localVariable4);\n  *localArray[0] = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005dfc": "initialize_variables_08005dfc",
                "param_1": "dataPointer",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "local_80": "localArray",
                "local_78": "localVariable1",
                "uStack_74": "localVariable2",
                "local_70": "localPointer",
                "local_6c": "localVariable3",
                "uStack_8": "localVariable4",
                "uStack_4": "localVariable5"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08005e9c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e40": {
            "entrypoint": "0x08005e40",
            "current_name": "count_trailing_zeros_08005e40",
            "code": "\nint countTrailingZeros_08005e40(uint inputNumber)\n\n{\n  int countRemainder;\n  uint *ptrToUint;\n  uint bitwiseResult;\n  \n  ptrToUint = (uint *)(inputNumber & 0xfffffffc);\n  countRemainder = -(inputNumber & 3);\n  bitwiseResult = *ptrToUint;\n  if ((inputNumber & 3) != 0) {\n    bitwiseResult = bitwiseResult | 0xffffffffU >> ((countRemainder + 4U & 0x1f) << 3);\n  }\n  while( true ) {\n    ptrToUint = ptrToUint + 1;\n    bitwiseResult = bitwiseResult + 0xfefefeff & ~bitwiseResult & 0x80808080;\n    if (bitwiseResult != 0) break;\n    bitwiseResult = *ptrToUint;\n    countRemainder = countRemainder + 4;\n  }\n  return countRemainder + (0x1fU - LZCOUNT(bitwiseResult & -bitwiseResult) >> 3);\n}\n\n",
            "renaming": {
                "FUN_08005e40": "count_trailing_zeros_08005e40",
                "param_1": "inputNumber",
                "iVar1": "countRemainder",
                "puVar2": "ptrToUint",
                "uVar3": "bitwiseResult"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e9c": {
            "entrypoint": "0x08005e9c",
            "current_name": "FUNC_08005e9c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nbyte * FUNC_08005e9c(undefined4 *param_1,int *param_2,int *param_3,int **param_4)\n\n{\n  byte bVar1;\n  int **ppiVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char cVar6;\n  byte bVar7;\n  int iVar8;\n  int *piVar9;\n  undefined4 uVar10;\n  int **ppiVar11;\n  undefined uVar12;\n  ushort uVar13;\n  int **ppiVar14;\n  byte **ppbVar15;\n  int *piVar16;\n  int **ppiVar17;\n  char *pcVar18;\n  uint uVar19;\n  undefined *puVar20;\n  int *piVar21;\n  int *piVar22;\n  int *piVar23;\n  int *piVar24;\n  int *piVar25;\n  byte *pbVar26;\n  int *piVar27;\n  int *piVar28;\n  undefined4 *puVar29;\n  byte *pbVar30;\n  bool bVar31;\n  longlong lVar32;\n  undefined8 uVar33;\n  undefined8 uVar34;\n  undefined4 local_188;\n  int *piStack_184;\n  int **local_180;\n  undefined *puStack_17c;\n  int **local_178;\n  undefined4 *local_16c;\n  int *local_168;\n  byte *local_164;\n  int *local_160;\n  int *local_15c;\n  char *local_158;\n  int **local_154;\n  undefined8 local_150;\n  int *local_148;\n  int *local_144;\n  int *local_140;\n  int **local_13c;\n  int *local_138;\n  int *local_134;\n  int *local_130;\n  uint local_12c;\n  undefined4 local_128;\n  undefined4 local_124;\n  undefined4 local_120;\n  char *local_11c;\n  int *local_118;\n  int *local_114;\n  int *local_110;\n  int *local_10c;\n  byte *local_108;\n  int *local_104;\n  int *local_100;\n  int *local_fc;\n  byte local_f5;\n  undefined2 local_f4;\n  int *local_f0;\n  undefined auStack_ec [4];\n  char local_e8;\n  undefined local_e7;\n  char local_e6 [6];\n  int *local_e0;\n  byte abStack_dc [4];\n  int **local_d8;\n  int *local_d4;\n  int *local_d0;\n  int *local_cc [16];\n  undefined local_8c;\n  byte bStack_2a;\n  undefined local_29;\n  int iStack_28;\n  \n  local_16c = param_1;\n  local_160 = param_2;\n  local_154 = param_4;\n  ppiVar2 = (int **)get_base_offset_08008ad4();\n  local_114 = *ppiVar2;\n  local_118 = (int *)count_trailing_zeros_08005e40(local_114);\n  if (((int)((uint)*(ushort *)(param_2 + 3) << 0x18) < 0) && (param_2[4] == 0)) {\n    iVar3 = allocate_memory_08008af8(local_16c,0x40);\n    *local_160 = iVar3;\n    local_160[4] = iVar3;\n    if (iVar3 == 0) {\n      *local_16c = 0xc;\n      return (byte *)0xffffffff;\n    }\n    local_160[5] = 0x40;\n  }\n  local_128 = 0;\n  local_138 = (int *)0x0;\n  local_12c = 0;\n  local_d4 = (int *)0x0;\n  local_d0 = (int *)0x0;\n  local_11c = (char *)0x0;\n  local_10c = (int *)0x0;\n  local_108 = (byte *)0x0;\n  local_104 = (int *)0x0;\n  local_110 = (int *)0x0;\n  local_164 = (byte *)0x0;\n  local_124 = 0;\n  local_120 = 0;\n  ppiVar2 = local_cc;\n  bVar1 = *(byte *)param_3;\n  local_d8 = ppiVar2;\njoined_r0x08005ef2:\n  if (bVar1 != 0) {\n    piVar28 = param_3;\n    if (bVar1 != 0x25) {\n      do {\n        piVar28 = (int *)((int)piVar28 + 1);\n        if (*(byte *)piVar28 == 0) break;\n      } while (*(byte *)piVar28 != 0x25);\n      piVar27 = (int *)((int)piVar28 - (int)param_3);\n      if (piVar27 != (int *)0x0) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)piVar27);\n        *ppiVar2 = param_3;\n        *(int **)((int)ppiVar2 + 4) = piVar27;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = (int **)((int)ppiVar2 + 8);\n        }\n        else {\n          iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800604a;\n          ppiVar2 = local_cc;\n        }\n        local_164 = local_164 + (int)piVar27;\n      }\n      if (*(byte *)piVar28 == 0) goto LAB_08006216;\n    }\n    piVar27 = (int *)0xffffffff;\n    piVar25 = (int *)0x0;\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    local_15c = (int *)0x0;\n    local_f5 = 0;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4a:\n    puVar29 = local_16c;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4e:\n    switch(piVar24) {\n    case (int *)0x20:\n      goto switchD_08005f58_caseD_20;\n    default:\n      if (piVar24 == (int *)0x0) goto LAB_08006216;\n      piVar16 = (int *)0x0;\n      local_168 = (int *)0x1;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_158 = (char *)0x1;\n      piVar23 = (int *)&local_8c;\n      piVar22 = piVar16;\n      local_8c = (char)piVar24;\n      goto LAB_08006298;\n    case (int *)0x23:\n      piVar25 = (int *)((uint)piVar25 | 1);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x27:\n      iVar3 = get_base_offset_08008ad4(local_16c);\n      local_110 = *(int **)(iVar3 + 4);\n      piVar24 = (int *)count_trailing_zeros_08005e40(local_110);\n      local_104 = piVar24;\n      iVar3 = get_base_offset_08008ad4(puVar29);\n      local_108 = *(byte **)(iVar3 + 8);\n      if (piVar24 == (int *)0x0) goto switchD_08005f58_caseD_74;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if ((local_108 != (byte *)0x0) && (*local_108 != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 0x400);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2a:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      local_15c = *local_154;\n      local_154 = local_154 + 1;\n      if ((int)local_15c < 0) {\n        local_15c = (int *)-(int)local_15c;\n        goto LAB_08006602;\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2b:\n      local_f5 = 0x2b;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x2d:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\nLAB_08006602:\n      piVar25 = (int *)((uint)piVar25 | 4);\n      goto LAB_08005f4a;\n    case (int *)0x2e:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x2a) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar27 = (int *)((uint)*local_154 | (int)*local_154 >> 0x1f);\n        local_154 = local_154 + 1;\n        piVar28 = (int *)((int)piVar28 + 1);\n        goto LAB_08005f4a;\n      }\n      piVar27 = (int *)0x0;\n      piVar28 = (int *)((int)piVar28 + 1);\n      while (piVar24 + -0xc < (int *)0xa) {\n        piVar27 = (int *)((int)(piVar24 + -0xc) + (int)piVar27 * 10);\n        piVar24 = (int *)(uint)*(byte *)piVar28;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      goto LAB_08005f4e;\n    case (int *)0x30:\n      piVar25 = (int *)((uint)piVar25 | 0x80);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x31:\n    case (int *)0x32:\n    case (int *)0x33:\n    case (int *)0x34:\n    case (int *)0x35:\n    case (int *)0x36:\n    case (int *)0x37:\n    case (int *)0x38:\n    case (int *)0x39:\n      goto switchD_08005f58_caseD_31;\n    case (int *)0x41:\n    case (int *)0x45:\n    case (int *)0x46:\n    case (int *)0x47:\n    case (int *)0x61:\n    case (int *)0x65:\n    case (int *)0x66:\n    case (int *)0x67:\n      puVar29 = (undefined4 *)((int)local_154 + 7U & 0xfffffff8);\n      uVar10 = *puVar29;\n      local_12c = puVar29[1];\n      local_168 = (int *)(local_12c & 0x7fffffff);\n      local_154 = (int **)(puVar29 + 2);\n      local_128 = uVar10;\n      iVar3 = check_parameters_08001170(uVar10,local_168,0xffffffff,0x7fefffff);\n      if ((iVar3 == 0) && (iVar3 = check_comparison_result_080009c0(uVar10,local_168,0xffffffff,0x7fefffff), iVar3 == 0)\n         ) {\n        iVar3 = check_if_string_is_null_terminated_080009ac(local_128,local_12c,local_124,local_120);\n        if (iVar3 == 0) {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        else {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        piVar23 = (int *)&UNK_08009f10;\n        piVar27 = (int *)&UNK_08009f0c;\nLAB_08006524:\n        local_148 = (int *)0x0;\n        local_168 = (int *)0x3;\n        if (piVar24 < (int *)0x48) {\n          piVar23 = piVar27;\n        }\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar25 = (int *)((uint)piVar25 & 0xffffff7f);\n        local_158 = (char *)0x3;\n        local_13c = (int **)0x0;\n        piVar22 = (int *)0x0;\n        goto LAB_08006538;\n      }\n      iVar3 = check_parameters_08001170(local_128,local_12c,local_128,local_12c);\n      if (iVar3 != 0) {\n        if ((int)local_12c < 0) {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        else {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        piVar23 = (int *)&UNK_08009f18;\n        piVar27 = (int *)&UNK_08009f14;\n        goto LAB_08006524;\n      }\n      if (piVar24 == (int *)0x61) {\n        uVar12 = 0x78;\nLAB_08007224:\n        local_f4 = CONCAT11(uVar12,0x30);\n        if ((int)piVar27 < 100) {\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          local_148 = (int *)0x0;\n          param_3 = (int *)&local_8c;\n          piVar25 = (int *)((uint)piVar25 | 2);\n        }\n        else {\n          param_3 = (int *)allocate_memory_08008af8(local_16c,(byte *)((int)piVar27 + 1));\n          if (param_3 == (int *)0x0) {\n            uVar13 = *(ushort *)(local_160 + 3) | 0x40;\n            *(ushort *)(local_160 + 3) = uVar13;\n            goto LAB_0800604e;\n          }\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          piVar25 = (int *)((uint)piVar25 | 2);\n          local_148 = param_3;\n        }\nLAB_0800724a:\n        if ((int)local_12c < 0) {\nLAB_08007414:\n          local_144 = (int *)0x2d;\n          uVar19 = local_12c + 0x80000000;\n        }\n        else {\n          local_144 = (int *)0x0;\n          uVar19 = local_12c;\n        }\n        local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n        piVar22 = piVar27;\n        local_158 = (char *)local_128;\n        if (piVar24 == (int *)0x61) {\n          uVar33 = calculate_float_difference_080096e0(local_128,uVar19,&local_f0);\n          local_150 = calculate_bitwise_difference_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = check_comparison_result_08000998((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                               local_120);\n          if (iVar3 != 0) {\n            local_f0 = (int *)0x1;\n          }\n          local_158 = \"0123456789abcdef\";\n          local_13c = ppiVar2;\n          local_138 = piVar28;\n          local_134 = piVar24;\n          local_130 = piVar27;\n          local_100 = piVar25;\n          local_fc = param_3;\n          pcVar18 = local_158;\n          uVar33 = local_150;\n          goto LAB_080072ba;\n        }\n        if (piVar24 == (int *)0x41) {\n          uVar33 = calculate_float_difference_080096e0(local_128,uVar19,&local_f0);\n          local_150 = calculate_bitwise_difference_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = check_comparison_result_08000998((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                               local_120);\n          if (iVar3 == 0) {\n            local_158 = \"0123456789ABCDEF\";\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar27;\n            local_100 = piVar25;\n            local_fc = param_3;\n            pcVar18 = local_158;\n            uVar33 = local_150;\n          }\n          else {\n            local_f0 = (int *)0x1;\n            local_158 = \"0123456789ABCDEF\";\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar27;\n            local_100 = piVar25;\n            local_fc = param_3;\n            pcVar18 = local_158;\n            uVar33 = local_150;\n          }\n          goto LAB_080072ba;\n        }\n      }\n      else {\n        if (piVar24 == (int *)0x41) {\n          uVar12 = 0x58;\n          goto LAB_08007224;\n        }\n        local_140 = (int *)((uint)piVar25 | 0x100);\n        local_148 = (int *)0x0;\n        if (piVar27 == (int *)0xffffffff) {\n          piVar27 = (int *)0x6;\n          goto LAB_0800724a;\n        }\n        if (((uint)piVar24 & 0xffffffdf) == 0x47) {\n          if (piVar27 == (int *)0x0) {\n            piVar27 = (int *)0x1;\n            local_148 = (int *)0x0;\n          }\n          goto LAB_0800724a;\n        }\n        if ((int)local_12c < 0) goto LAB_08007414;\n        local_144 = (int *)0x0;\n        uVar19 = local_12c;\n      }\n      local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n      piStack_184 = piVar27;\n      local_158 = (char *)local_128;\n      if (piVar24 == (int *)0x66) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)formatted_float_to_string_080079e8(local_16c,local_180,local_128,uVar19);\n        piVar22 = (int *)((int)piVar23 + (int)piVar27);\n        local_150._0_4_ = piVar27;\nLAB_0800764c:\n        if ((*(byte *)piVar23 == 0x30) &&\n           (iVar3 = check_comparison_result_08000998(local_158,uVar19,local_124,local_120), iVar3 == 0)) {\n          local_f0 = (int *)(1 - (int)(int *)local_150);\n        }\n        piVar22 = (int *)((int)piVar22 + (int)local_f0);\n      }\n      else if (piVar24 == (int *)0x46) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)formatted_float_to_string_080079e8(local_16c,local_180,local_128,uVar19);\n        local_150._0_4_ = piVar27;\nLAB_08007760:\n        piVar22 = (int *)((int)piVar23 + (int)(int *)local_150);\n        if (piVar24 == (int *)0x46) goto LAB_0800764c;\n      }\n      else {\n        local_178 = &local_e0;\n        local_150._0_4_ = piVar27;\n        if (local_168 == (int *)0x45) {\n          local_150._0_4_ = (int *)((int)piVar27 + 1);\n        }\n        local_188 = 2;\n        piStack_184 = (int *)local_150;\n        local_180 = &local_f0;\n        puStack_17c = auStack_ec;\n        piVar23 = (int *)formatted_float_to_string_080079e8(local_16c,local_180,local_128,uVar19);\n        piVar16 = local_e0;\n        if (piVar24 == (int *)0x67) {\n          if (((uint)piVar25 & 1) == 0) goto LAB_08006ca6;\n        }\n        else if (piVar24 == (int *)0x47) {\n          if (((uint)piVar25 & 1) != 0) goto LAB_08007760;\n          goto LAB_08006ca6;\n        }\n        piVar22 = (int *)((int)(int *)local_150 + (int)piVar23);\n      }\n      iVar3 = check_comparison_result_08000998(local_158,uVar19,local_124,local_120);\n      piVar16 = piVar22;\n      if (iVar3 == 0) {\n        for (; piVar16 = local_e0, local_e0 < piVar22; local_e0 = (int *)((int)local_e0 + 1)) {\n          *(byte *)local_e0 = 0x30;\n        }\n      }\nLAB_08006ca6:\n      local_138 = (int *)((int)piVar16 - (int)piVar23);\n      goto LAB_08006cb0;\n    case (int *)0x43:\n    case (int *)0x63:\n      piVar16 = (int *)0x0;\n      piVar27 = *local_154;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      piVar22 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_154 = local_154 + 1;\n      local_168 = (int *)0x1;\n      local_158 = (char *)0x1;\n      local_8c = SUB41(piVar27,0);\n      piVar23 = (int *)&local_8c;\n      goto LAB_08006298;\n    case (int *)0x44:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080065a8;\nLAB_080060ec:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_08006102;\n    case (int *)0x4c:\n      piVar25 = (int *)((uint)piVar25 | 8);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x4f:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n    case (int *)0x6f:\n      if (((uint)piVar25 & 0x20) == 0) {\n        ppiVar14 = local_154 + 1;\n        if (((uint)piVar25 & 0x10) == 0) {\n          if (((uint)piVar25 & 0x40) == 0) {\n            if (((uint)piVar25 & 0x200) == 0) goto LAB_08006be2;\n            piVar22 = (int *)(uint)*(byte *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n          else {\n            piVar22 = (int *)(uint)*(ushort *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n        }\n        else {\nLAB_08006be2:\n          piVar22 = *local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\n        ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n        piVar22 = *ppiVar14;\n        piVar16 = ppiVar14[1];\n        local_154 = ppiVar14 + 2;\n      }\n      iVar3 = 0;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n      break;\n    case (int *)0x53:\n    case (int *)0x73:\n      local_f5 = 0;\n      piVar23 = *local_154;\n      ppiVar14 = local_154 + 1;\n      if (piVar23 == (int *)0x0) {\n        if ((int *)0x5 < piVar27) {\n          piVar27 = (int *)0x6;\n        }\n        piVar23 = (int *)&UNK_08009f44;\n        piVar16 = (int *)0x0;\n        local_148 = (int *)0x0;\n        local_13c = (int **)0x0;\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar22 = (int *)0x0;\n        local_168 = piVar27;\n        local_158 = (char *)piVar27;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (piVar27 == (int *)0xffffffff) {\n          local_158 = (char *)count_trailing_zeros_08005e40(piVar23);\n        }\n        else {\n          iVar3 = find_first_match_0800901c(piVar23,0,piVar27);\n          if (iVar3 == 0) {\n            piVar16 = (int *)(uint)local_f5;\n            local_148 = (int *)0x0;\n            local_13c = (int **)0x0;\n            local_134 = (int *)0x0;\n            local_130 = (int *)0x0;\n            piVar22 = (int *)0x0;\n            local_168 = piVar27;\n            local_158 = (char *)piVar27;\n            local_154 = ppiVar14;\n            goto LAB_08006538;\n          }\n          local_158 = (char *)(iVar3 - (int)piVar23);\n        }\n        local_148 = (int *)0x0;\n        local_13c = (int **)0x0;\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar16 = (int *)(uint)local_f5;\n        piVar22 = (int *)0x0;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        local_154 = ppiVar14;\n      }\n      goto LAB_08006538;\n    case (int *)0x55:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080066c0;\nLAB_0800618a:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      iVar3 = 1;\n      local_154 = ppiVar14 + 2;\n      break;\n    case (int *)0x58:\n      local_11c = \"0123456789ABCDEF\";\n      if (((uint)piVar25 & 0x20) == 0) goto LAB_08006696;\nLAB_080061ac:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_080061be;\n    case (int *)0x64:\n    case (int *)0x69:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_080060ec;\nLAB_080065a8:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bcc:\n        piVar22 = *local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(int)*(short *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bcc;\n        piVar22 = (int *)(int)*(char *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\nLAB_08006102:\n      if ((int)piVar16 < 0) {\n        bVar31 = piVar22 != (int *)0x0;\n        piVar22 = (int *)-(int)piVar22;\n        piVar16 = (int *)(-(int)piVar16 - (uint)bVar31);\n        local_f5 = 0x2d;\n      }\n      if (piVar27 != (int *)0xffffffff) {\n        iVar3 = 1;\n        iVar8 = 1;\n        piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n        if (((uint)piVar22 | (uint)piVar16) == 0) goto LAB_080060a4;\n        goto LAB_08006130;\n      }\n      piVar21 = piVar25;\n      if (piVar16 != (int *)0x0 || (int *)0x9 < piVar22) goto LAB_08006f16;\n      goto LAB_0800698a;\n    case (int *)0x68:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x68) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar25 = (int *)((uint)piVar25 | 0x200);\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      else {\n        piVar25 = (int *)((uint)piVar25 | 0x40);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x6a:\n    case (int *)0x71:\n      piVar25 = (int *)((uint)piVar25 | 0x20);\n    case (int *)0x74:\n    case (int *)0x7a:\nswitchD_08005f58_caseD_74:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x6c:\n      goto switchD_08005f58_caseD_6c;\n    case (int *)0x6e:\n      ppiVar14 = local_154 + 1;\n      ppbVar15 = (byte **)*local_154;\n      local_154 = ppiVar14;\n      if (((uint)piVar25 & 0x20) != 0) {\n        *ppbVar15 = local_164;\n        ppbVar15[1] = (byte *)((int)local_164 >> 0x1f);\n        goto LAB_0800620e;\n      }\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) != 0) {\n          *(short *)ppbVar15 = (short)local_164;\n          goto LAB_0800620e;\n        }\n        if (((uint)piVar25 & 0x200) != 0) {\n          *(char *)ppbVar15 = (char)local_164;\n          goto LAB_0800620e;\n        }\n      }\n      *ppbVar15 = local_164;\n      goto LAB_0800620e;\n    case (int *)0x70:\n      local_f4 = 0x7830;\n      piVar22 = *local_154;\n      local_11c = \"0123456789abcdef\";\n      piVar25 = (int *)((uint)piVar25 | 2);\n      piVar16 = (int *)0x0;\n      iVar3 = 2;\n      piVar24 = (int *)0x78;\n      local_154 = local_154 + 1;\n      break;\n    case (int *)0x75:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_0800618a;\nLAB_080066c0:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bf2:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(uint)*(ushort *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bf2;\n        piVar22 = (int *)(uint)*(byte *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      break;\n    case (int *)0x78:\n      local_11c = \"0123456789abcdef\";\n      if (((uint)piVar25 & 0x20) != 0) goto LAB_080061ac;\nLAB_08006696:\n      ppiVar14 = local_154 + 1;\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) == 0) {\n          if (((uint)piVar25 & 0x200) == 0) goto LAB_08006bbc;\n          piVar22 = (int *)(uint)*(byte *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n        else {\n          piVar22 = (int *)(uint)*(ushort *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\nLAB_08006bbc:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        local_154 = ppiVar14;\n      }\nLAB_080061be:\n      if ((((uint)piVar25 & 1) != 0) && (((uint)piVar22 | (uint)piVar16) != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 2);\n        local_f4 = CONCAT11((char)piVar24,0x30);\n      }\n      iVar3 = 2;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n    }\n    local_f5 = 0;\n    if (piVar27 == (int *)0xffffffff) {\n      if (iVar3 != 1) goto LAB_08006136;\nLAB_08006980:\n      piVar21 = piVar25;\n      if (piVar16 == (int *)0x0 && piVar22 < (int *)0xa) goto LAB_0800698a;\nLAB_08006f16:\n      lVar32 = CONCAT44(piVar16,piVar22);\n      piVar23 = (int *)(&bStack_2a + 2);\n      piVar22 = (int *)0x0;\n      pbVar26 = local_108;\n      local_168 = piVar23;\n      local_158 = (char *)ppiVar2;\n      local_150._0_4_ = piVar25;\n      local_148 = piVar24;\n      do {\n        iVar3 = (int)((ulonglong)lVar32 >> 0x20);\n        uVar19 = (uint)lVar32;\n        cVar6 = '\\n';\n        calculate_result_080011ec(uVar19,iVar3,10,0);\n        *(byte *)((int)piVar23 + -1) = cVar6 + 0x30;\n        piVar22 = (int *)((int)piVar22 + 1);\n        piVar23 = (int *)((int)piVar23 + -1);\n        if ((((((uint)piVar25 & 0x400) != 0) && (piVar22 == (int *)(uint)*pbVar26)) &&\n            (piVar22 != (int *)0xff)) && (iVar3 != 0 || 9 < uVar19)) {\n          piVar23 = (int *)((int)piVar23 - (int)local_104);\n          copy_safe_string_08009768(piVar23,local_110,local_104);\n          if (pbVar26[1] == 0) {\n            piVar22 = (int *)0x0;\n          }\n          else {\n            pbVar26 = pbVar26 + 1;\n            piVar22 = (int *)0x0;\n          }\n        }\n        lVar32 = calculate_result_080011ec(uVar19,iVar3,10,0);\n      } while (lVar32 != 0);\n      piVar24 = local_148;\n      piVar25 = (int *)local_150;\n      ppiVar2 = (int **)local_158;\n      local_158 = (char *)((int)local_168 - (int)piVar23);\n      local_138 = piVar22;\n      local_108 = pbVar26;\n    }\n    else {\n      piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n      iVar8 = iVar3;\n      if (((uint)piVar22 | (uint)piVar16) == 0) {\nLAB_080060a4:\n        if (piVar27 == (int *)0x0) {\n          if (iVar3 == 0) {\n            local_158 = (char *)((uint)piVar25 & 1);\n            if ((int *)local_158 == (int *)0x0) {\n              piVar23 = (int *)(&bStack_2a + 2);\n              piVar25 = piVar21;\n            }\n            else {\n              piVar23 = (int *)(&bStack_2a + 1);\n              local_29 = '0';\n              piVar25 = piVar21;\n            }\n          }\n          else {\n            piVar23 = (int *)(&bStack_2a + 2);\n            piVar25 = piVar21;\n            local_158 = (char *)piVar27;\n          }\n        }\n        else {\n          piVar25 = piVar21;\n          if (iVar3 != 1) goto LAB_08006136;\nLAB_0800698a:\n          local_29 = (char)piVar22 + '0';\n          piVar23 = (int *)(&bStack_2a + 1);\n          local_158 = (char *)0x1;\n          piVar25 = piVar21;\n        }\n      }\n      else {\nLAB_08006130:\n        iVar3 = iVar8;\n        piVar25 = piVar21;\n        if (iVar8 == 1) goto LAB_08006980;\nLAB_08006136:\n        if (iVar3 == 2) {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = (int *)((uint)piVar22 >> 4 | (int)piVar16 << 0x1c);\n            piVar16 = (int *)((uint)piVar16 >> 4);\n            piVar23 = (int *)((int)piVar23 + -1);\n            *(char *)piVar23 = local_11c[(uint)piVar22 & 0xf];\n            piVar22 = piVar21;\n          } while (((uint)piVar21 | (uint)piVar16) != 0);\n        }\n        else {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = piVar23;\n            piVar9 = (int *)((uint)piVar22 >> 3 | (int)piVar16 << 0x1d);\n            piVar16 = (int *)((uint)piVar16 >> 3);\n            iVar3 = ((uint)piVar22 & 7) + 0x30;\n            *(byte *)((int)piVar21 + -1) = (byte)iVar3;\n            piVar23 = (int *)((int)piVar21 + -1);\n            piVar22 = piVar9;\n          } while (((uint)piVar9 | (uint)piVar16) != 0);\n          if ((((uint)piVar25 & 1) != 0) && (iVar3 != 0x30)) {\n            piVar23 = (int *)((int)piVar21 + -2);\n            *(byte *)((int)piVar21 + -2) = 0x30;\n            local_158 = (char *)(&bStack_2a + (2 - (int)piVar23));\n            goto LAB_0800675a;\n          }\n        }\n        local_158 = (char *)(&bStack_2a + (2 - (int)piVar23));\n      }\n    }\nLAB_0800675a:\n    local_148 = (int *)0x0;\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = piVar27;\n    local_168 = (int *)local_158;\n    if ((int)local_158 < (int)piVar27) {\n      local_168 = piVar27;\n    }\n    goto LAB_08006538;\n  }\nLAB_08006216:\n  piVar28 = local_160;\n  if (local_d0 == (int *)0x0) {\nLAB_0800604a:\n    uVar13 = *(ushort *)(local_160 + 3);\n  }\n  else {\n    copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n    uVar13 = *(ushort *)(piVar28 + 3);\n  }\nLAB_0800604e:\n  if ((uVar13 & 0x40) != 0) {\n    local_164 = (byte *)0xffffffff;\n  }\n  return local_164;\nswitchD_08005f58_caseD_6c:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (piVar24 == (int *)0x6c) {\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    piVar25 = (int *)((uint)piVar25 | 0x20);\n    piVar28 = (int *)((int)piVar28 + 1);\n  }\n  else {\n    piVar25 = (int *)((uint)piVar25 | 0x10);\n  }\n  goto LAB_08005f4a;\n  while( true ) {\n    iVar8 = check_comparison_result_08000998((int)uVar33,uVar10,local_124,local_120);\n    if (iVar8 != 0) break;\nLAB_080072ba:\n    piVar16 = param_3;\n    piVar22 = (int *)((int)piVar22 + -1);\n    uVar33 = calculate_bitwise_difference_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x40300000);\n    iVar3 = calculate_signed_divisor_0800119c();\n    uVar34 = calculate_shift_and_mask_080003f4();\n    uVar33 = perform_arithmetic_operation_08000158((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),(int)uVar34,\n                          (int)((ulonglong)uVar34 >> 0x20));\n    uVar10 = (undefined4)((ulonglong)uVar33 >> 0x20);\n    param_3 = (int *)((int)piVar16 + 1);\n    *(char *)piVar16 = pcVar18[iVar3];\n    if (piVar22 == (int *)0xffffffff) break;\n  }\n  piVar23 = local_fc;\n  piVar25 = local_100;\n  piVar27 = local_130;\n  piVar24 = local_134;\n  piVar28 = local_138;\n  ppiVar2 = local_13c;\n  local_13c = (int **)piVar22;\n  local_134 = piVar16;\n  local_150 = uVar33;\n  iVar8 = is_string_terminated_080009e8((int)uVar33,uVar10,0,0x3fe00000);\n  if (iVar8 == 0) {\n    iVar8 = check_comparison_result_08000998((int *)local_150,local_150._4_4_,0,0x3fe00000);\n    if ((iVar8 != 0) && (iVar3 << 0x1f < 0)) goto LAB_0800748a;\n    if (-1 < (int)local_13c) {\n      piVar16 = (int *)((byte *)((int)local_13c + 1) + (int)param_3);\n      piVar22 = param_3;\n      do {\n        param_3 = (int *)((int)piVar22 + 1);\n        *(byte *)piVar22 = 0x30;\n        piVar22 = param_3;\n      } while (piVar16 != param_3);\n    }\n  }\n  else {\nLAB_0800748a:\n    bVar1 = local_158[0xf];\n    bVar7 = *(byte *)piVar16;\n    piVar22 = param_3;\n    local_e0 = local_134;\n    while (bVar1 == bVar7) {\n      *(byte *)((int)piVar22 + -1) = 0x30;\n      bVar7 = *(byte *)((int)local_e0 + -1);\n      piVar22 = local_e0;\n      local_e0 = (int *)((int)local_e0 + -1);\n    }\n    if (bVar7 == 0x39) {\n      bVar7 = local_158[10];\n    }\n    else {\n      bVar7 = bVar7 + 1;\n    }\n    *(byte *)((int)piVar22 + -1) = bVar7;\n  }\n  local_138 = (int *)((int)param_3 - (int)piVar23);\nLAB_08006cb0:\n  local_134 = local_f0;\n  if (local_168 == (int *)0x47) {\n    if (((int)((int)local_f0 + 3) < 0 == SCARRY4((int)local_f0,3)) &&\n       ((int)local_f0 <= (int)piVar27)) {\n      if ((int)local_f0 < (int)local_138) {\n        local_158 = (char *)((int)local_138 + (int)local_118);\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074f8;\n        }\n        local_158 = (char *)((int)local_158 + (1 - (int)local_f0));\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        piVar24 = (int *)0x67;\n      }\n      else {\n        if ((int)piVar25 << 0x1f < 0) {\n          local_158 = (char *)((int)local_f0 + (int)local_118);\n        }\n        else {\n          local_158 = (char *)local_f0;\n        }\n        if (-1 < (int)piVar25 << 0x15) {\n          piVar24 = (int *)0x67;\n          goto LAB_0800754a;\n        }\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074fc;\n        }\n        piVar24 = (int *)0x67;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_080073d6;\n    }\n    piVar24 = (int *)((int)piVar24 + -2);\n    local_168 = (int *)((uint)piVar24 & 0xffffffdf);\nLAB_08006cc4:\n    local_e8 = (char)piVar24;\n    if (local_168 == (int *)0x41) {\n      local_e8 = local_e8 + '\\x0f';\n    }\n    piVar27 = (int *)((int)local_f0 + -1);\n    if ((int)piVar27 < 0) {\n      local_e7 = 0x2d;\n      local_f0 = (int *)(1 - (int)local_f0);\n    }\n    else {\n      local_e7 = 0x2b;\n      local_f0 = piVar27;\n    }\n    if ((int)local_f0 < 10) {\n      if (local_168 == (int *)0x41) {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n      else {\n        local_e6[0] = 0x30;\n        pcVar18 = (char *)((int)&local_e8 + 3);\n      }\n      *pcVar18 = (char)local_f0 + '0';\n      pcVar18 = pcVar18 + 1;\n    }\n    else {\n      pbVar30 = abStack_dc + 3;\n      pbVar26 = pbVar30;\n      do {\n        pbVar5 = pbVar26;\n        piVar22 = (int *)((uint)local_f0 / 10);\n        pbVar5[-1] = (char)local_f0 + (char)piVar22 * -10 + 0x30;\n        pbVar26 = pbVar5 + -1;\n        local_f0 = piVar22;\n      } while ((int *)0x9 < piVar22);\n      uVar19 = (uint)(piVar22 + 0xc) & 0xff;\n      pbVar5[-2] = (byte)uVar19;\n      if (pbVar5 + -2 < pbVar30) {\n        pbVar5 = pbVar26;\n        puVar20 = (undefined *)((int)&local_e8 + 2);\n        while( true ) {\n          *puVar20 = (char)uVar19;\n          if (pbVar30 == pbVar5) break;\n          uVar19 = (uint)*pbVar5;\n          pbVar5 = pbVar5 + 1;\n          puVar20 = puVar20 + 1;\n        }\n        pcVar18 = (char *)(((int)&local_188 * 2 - (int)pbVar26) + 0x152);\n      }\n      else {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n    }\n    local_10c = (int *)(pcVar18 + -(int)&local_e8);\n    local_158 = (char *)((int)local_10c + (int)local_138);\n    if ((1 < (int)local_138) || ((int)piVar25 << 0x1f < 0)) {\n      local_158 = (char *)((int)local_158 + (int)local_118);\n    }\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    piVar25 = (int *)((uint)piVar25 & 0xfffffbff | 0x100);\n    local_f0 = piVar27;\n  }\n  else {\n    if (local_168 != (int *)0x46) goto LAB_08006cc4;\n    if ((int)local_f0 < 1) {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_168 = (int *)0x1;\n        local_158 = (char *)0x1;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)((byte *)((int)local_118 + 1) + (int)piVar27);\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\nLAB_080073d6:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      piVar25 = local_140;\n    }\n    else {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)local_f0;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)((byte *)((int)local_f0 + (int)local_118) + (int)piVar27);\n      }\nLAB_080074f8:\n      if (-1 < (int)piVar25 << 0x15) {\nLAB_0800754a:\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        goto LAB_080073d6;\n      }\nLAB_080074fc:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      uVar19 = (uint)*local_108;\n      while (uVar19 != 0xff) {\n        while( true ) {\n          if ((int)local_134 <= (int)uVar19) goto LAB_08007524;\n          uVar4 = (uint)local_108[1];\n          local_134 = (int *)((int)local_134 - uVar19);\n          if (uVar4 == 0) break;\n          local_108 = local_108 + 1;\n          local_130 = (int *)((int)local_130 + 1);\n          uVar19 = uVar4;\n          if (uVar4 == 0xff) goto LAB_08007524;\n        }\n        local_13c = (int **)((int)local_13c + 1);\n      }\nLAB_08007524:\n      local_158 = (char *)((int)local_158 + (int)local_104 * ((int)local_130 + (int)local_13c));\n      local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      piVar25 = local_140;\n    }\n  }\n  if (local_144 == (int *)0x0) {\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = (int *)0x0;\nLAB_08006538:\n    if (piVar16 != (int *)0x0) goto LAB_0800653e;\n  }\n  else {\n    piVar16 = (int *)0x2d;\n    piVar22 = (int *)0x0;\n    local_f5 = 0x2d;\nLAB_0800653e:\n    local_168 = (int *)((int)local_168 + 1);\n  }\nLAB_08006298:\n  piVar27 = local_160;\n  puVar29 = local_16c;\n  local_150._0_4_ = (int *)((uint)piVar25 & 2);\n  if ((int *)local_150 != (int *)0x0) {\n    local_168 = (int *)((int)local_168 + 2);\n  }\n  local_144 = (int *)((uint)piVar25 & 0x84);\n  if ((local_144 == (int *)0x0) &&\n     (piVar21 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar21)) {\n    if (0x10 < (int)piVar21) {\n      piVar16 = (int *)0x10;\n      local_100 = piVar24;\n      do {\n        piVar9 = piVar21;\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = piVar16;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n          piVar24 = local_100;\n        }\n        else {\n          local_140 = piVar16;\n          iVar3 = copy_and_reallocate_memory_080097cc(puVar29,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = local_140;\n          piVar24 = local_100;\n        }\n        piVar21 = piVar9 + -4;\n        local_100 = piVar24;\n      } while (0x10 < (int)piVar21);\n      piVar21 = piVar9 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar21);\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar21;\n    if ((int)local_d4 < 8) {\n      piVar16 = (int *)(uint)local_f5;\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar16 = (int *)(uint)local_f5;\n    }\n  }\n  if (piVar16 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 1);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f5;\n    ppiVar2[1] = (int *)0x1;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  if ((int *)local_150 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 2);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f4;\n    ppiVar2[1] = (int *)0x2;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  if ((local_144 == (int *)0x80) &&\n     (piVar16 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar16)) {\n    if (0x10 < (int)piVar16) {\n      do {\n        while( true ) {\n          piVar21 = piVar16;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = copy_and_reallocate_memory_080097cc(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = piVar21 + -4;\n          if ((int)(piVar21 + -4) < 0x11) goto LAB_08006882;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar16 = piVar21 + -4;\n      } while (0x10 < (int)(piVar21 + -4));\nLAB_08006882:\n      piVar16 = piVar21 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar16);\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar16;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  piVar22 = (int *)((int)piVar22 - (int)local_158);\n  if (0 < (int)piVar22) {\n    if (0x10 < (int)piVar22) {\n      do {\n        while( true ) {\n          piVar16 = piVar22;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = copy_and_reallocate_memory_080097cc(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar22 = piVar16 + -4;\n          if ((int)(piVar16 + -4) < 0x11) goto LAB_080063d2;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar22 = piVar16 + -4;\n      } while (0x10 < (int)(piVar16 + -4));\nLAB_080063d2:\n      piVar22 = piVar16 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar22);\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar22;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_d0;\n  if (((uint)piVar25 & 0x100) == 0) {\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)local_158);\n    *ppiVar2 = piVar23;\n    ppiVar2[1] = (int *)local_158;\n    if ((int)local_d4 < 8) {\nLAB_0800640e:\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\n    else {\nLAB_08006a20:\n      iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else if ((int)piVar24 < 0x66) {\n    local_158 = (char *)((int)local_d0 + 1);\n    piVar27 = (int *)((int)local_d4 + 1);\n    ppiVar14 = ppiVar2 + 2;\n    local_d0 = (int *)local_158;\n    if (((int)local_138 < 2) && (((uint)piVar25 & 1) == 0)) {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)piVar27 < 8) {\n        local_150._0_4_ = (int *)((int)local_d4 + 2);\n        ppiVar2 = ppiVar2 + 4;\n      }\n      else {\n        local_d4 = piVar27;\n        iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        local_150._0_4_ = (int *)((int)local_d4 + 1);\n        ppiVar14 = local_cc;\n        local_158 = (char *)local_d0;\n        ppiVar2 = local_cc + 2;\n      }\n    }\n    else {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      local_d4 = piVar27;\n      if (7 < (int)piVar27) {\n        iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar14 = local_cc;\n        local_158 = (char *)local_d0;\n      }\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_158 = (char *)((int)local_158 + (int)local_118);\n      *ppiVar14 = local_114;\n      ppiVar14[1] = local_118;\n      local_d0 = (int *)local_158;\n      if ((int)local_d4 < 8) {\n        ppiVar17 = ppiVar14 + 2;\n      }\n      else {\n        iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar17 = local_cc;\n      }\n      piVar24 = local_d4;\n      local_150._0_4_ = (int *)((int)local_d4 + 1);\n      piVar22 = (int *)((int)local_138 + -1);\n      ppiVar11 = ppiVar17 + 2;\n      local_158 = (char *)local_d0;\n      local_144 = (int *)local_150;\n      iVar3 = check_comparison_result_08000998(local_128,local_12c,local_124,local_120);\n      piVar27 = local_160;\n      puVar29 = local_16c;\n      if (iVar3 == 0) {\n        local_158 = (char *)((int)local_158 + (int)piVar22);\n        *ppiVar17 = (int *)((int)piVar23 + 1);\n        ppiVar17[1] = piVar22;\n        local_d0 = (int *)local_158;\n        if ((int)(int *)local_150 < 8) {\n          local_150._0_4_ = (int *)((int)piVar24 + 2);\n          ppiVar14 = ppiVar11;\n          ppiVar2 = ppiVar17 + 4;\n        }\n        else {\nLAB_08006d9c:\n          local_158 = (char *)local_d0;\n          local_d4 = (int *)local_150;\n          iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          local_150._0_4_ = (int *)((int)local_d4 + 1);\n          local_158 = (char *)local_d0;\n          ppiVar14 = local_cc;\n          ppiVar2 = local_cc + 2;\n        }\n      }\n      else {\n        ppiVar14 = ppiVar17;\n        ppiVar2 = ppiVar11;\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)local_158;\n          local_d4 = local_144;\n          if (0x10 < (int)piVar22) {\n            while( true ) {\n              local_d0 = local_d0 + 4;\n              *ppiVar17 = (int *)0x8009f60;\n              ppiVar17[1] = (int *)0x10;\n              if ((int)local_d4 < 8) {\n                ppiVar17 = ppiVar17 + 2;\n              }\n              else {\n                iVar3 = copy_and_reallocate_memory_080097cc(puVar29,piVar27,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar17 = local_cc;\n              }\n              piVar22 = piVar22 + -4;\n              if ((int)piVar22 < 0x11) break;\n              local_d4 = (int *)((int)local_d4 + 1);\n            }\n            local_150._0_4_ = (int *)((int)local_d4 + 1);\n            ppiVar11 = ppiVar17 + 2;\n            local_158 = (char *)local_d0;\n          }\n          *ppiVar17 = (int *)0x8009f60;\n          ppiVar17[1] = piVar22;\n          local_158 = (char *)((int)local_158 + (int)piVar22);\n          local_d0 = (int *)local_158;\n          if (7 < (int)(int *)local_150) goto LAB_08006d9c;\n          local_150._0_4_ = (int *)((int)(int *)local_150 + 1);\n          ppiVar2 = ppiVar11 + 2;\n          ppiVar14 = ppiVar11;\n        }\n      }\n    }\n    ppiVar14[1] = local_10c;\n    local_d0 = (int *)((int)local_158 + (int)local_10c);\n    local_d4 = (int *)local_150;\n    *ppiVar14 = (int *)&local_e8;\n    piVar27 = local_d0;\n    if (7 < (int)(int *)local_150) {\n      iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else {\n    iVar3 = check_comparison_result_08000998(local_128,local_12c,local_124,local_120);\n    if (iVar3 == 0) {\n      if ((int)local_f0 < 1) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)piVar27 + 1);\n        *ppiVar2 = (int *)&DAT_08009f4c;\n        ppiVar2[1] = (int *)0x1;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        if (((local_f0 != (int *)0x0) || (local_138 != (int *)0x0)) ||\n           (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)local_d0 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n          }\n          puVar29 = local_16c;\n          if ((int)local_f0 < 0) {\n            piVar27 = (int *)-(int)local_f0;\n            if ((int)(local_f0 + 4) < 0 != SCARRY4((int)local_f0,0x10)) {\n              do {\n                local_d4 = (int *)((int)local_d4 + 1);\n                local_d0 = local_d0 + 4;\n                *ppiVar2 = (int *)0x8009f60;\n                ppiVar2[1] = (int *)0x10;\n                if ((int)local_d4 < 8) {\n                  ppiVar2 = ppiVar2 + 2;\n                }\n                else {\n                  iVar3 = copy_and_reallocate_memory_080097cc(puVar29,local_160,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  ppiVar2 = local_cc;\n                }\n                piVar27 = piVar27 + -4;\n              } while (0x10 < (int)piVar27);\n            }\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)local_d0 + (int)piVar27);\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = piVar27;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\n          local_d0 = (int *)((int)local_d0 + (int)local_138);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = local_138;\n          goto joined_r0x08006a1c;\n        }\n      }\n      else {\n        piVar24 = local_134;\n        if ((int)local_138 <= (int)local_134) {\n          piVar24 = local_138;\n        }\n        if (0 < (int)piVar24) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar24);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = piVar24;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        piVar22 = local_134;\n        if (-1 < (int)piVar24) {\n          piVar22 = (int *)((int)local_134 - (int)piVar24);\n        }\n        if (0 < (int)piVar22) {\n          for (; 0x10 < (int)piVar22; piVar22 = piVar22 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = piVar27 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_reallocate_memory_080097cc(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n          }\n          local_d4 = (int *)((int)local_d4 + 1);\n          piVar27 = (int *)((int)piVar27 + (int)piVar22);\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar22;\n          local_d0 = piVar27;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar22 = local_104;\n        piVar24 = local_160;\n        puVar29 = local_16c;\n        piVar16 = (int *)((int)local_134 + (int)piVar23);\n        if (((uint)piVar25 & 0x400) != 0) {\n          local_158 = (char *)((int)piVar23 + (int)local_138);\n          pbVar26 = local_108;\n          local_150._0_4_ = piVar28;\n          local_144 = piVar25;\n          local_140 = piVar23;\n          if (local_130 == (int *)0x0) goto LAB_08007176;\nLAB_080070ba:\n          if (local_13c != (int **)0x0) goto LAB_0800717e;\n          pbVar26 = pbVar26 + -1;\n          local_130 = (int *)((int)local_130 + -1);\n          do {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)piVar27 + (int)piVar22);\n            *ppiVar2 = local_110;\n            ppiVar2[1] = piVar22;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_reallocate_memory_080097cc(puVar29,piVar24,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = (int *)(uint)*pbVar26;\n            piVar28 = (int *)((int)local_158 - (int)piVar16);\n            if ((int)piVar27 <= (int)(int *)((int)local_158 - (int)piVar16)) {\n              piVar28 = piVar27;\n            }\n            if (0 < (int)piVar28) {\n              local_d0 = (int *)((int)local_d0 + (int)piVar28);\n              local_d4 = (int *)((int)local_d4 + 1);\n              *ppiVar2 = piVar16;\n              ppiVar2[1] = piVar28;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = copy_and_reallocate_memory_080097cc(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar2 = local_cc;\n                piVar27 = (int *)(uint)*pbVar26;\n              }\n            }\n            piVar25 = piVar27;\n            if (-1 < (int)piVar28) {\n              piVar25 = (int *)((int)piVar27 - (int)piVar28);\n            }\n            if (0 < (int)piVar25) {\n              for (; 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n                while( true ) {\n                  local_d4 = (int *)((int)local_d4 + 1);\n                  local_d0 = local_d0 + 4;\n                  *ppiVar2 = (int *)0x8009f60;\n                  ppiVar2[1] = (int *)0x10;\n                  if ((int)local_d4 < 8) break;\n                  iVar3 = copy_and_reallocate_memory_080097cc(puVar29,piVar24,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  piVar25 = piVar25 + -4;\n                  ppiVar2 = local_cc;\n                  if ((int)piVar25 < 0x11) goto LAB_08007156;\n                }\n                ppiVar2 = ppiVar2 + 2;\n              }\nLAB_08007156:\n              local_d4 = (int *)((int)local_d4 + 1);\n              local_d0 = (int *)((int)local_d0 + (int)piVar25);\n              *ppiVar2 = (int *)0x8009f60;\n              ppiVar2[1] = piVar25;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = copy_and_reallocate_memory_080097cc(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = local_cc;\n              }\n            }\n            piVar16 = (int *)((int)piVar16 + (int)piVar27);\n            piVar27 = local_d0;\n            if (local_130 != (int *)0x0) goto LAB_080070ba;\nLAB_08007176:\n            if (local_13c == (int **)0x0) {\n              piVar23 = local_140;\n              piVar25 = local_144;\n              piVar28 = (int *)local_150;\n              local_108 = pbVar26;\n              if ((int *)((int)local_140 + (int)local_138) <= piVar16) {\n                piVar16 = (int *)((int)local_140 + (int)local_138);\n              }\n              break;\n            }\nLAB_0800717e:\n            local_13c = (int **)((int)local_13c + -1);\n          } while( true );\n        }\n        if (((int)local_f0 < (int)local_138) || (((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)piVar27 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar24 = (int *)((int)local_138 - (int)local_f0);\n        piVar22 = (int *)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16);\n        if ((int)piVar24 <= (int)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16)) {\n          piVar22 = piVar24;\n        }\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar22);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar16;\n          ppiVar2[1] = piVar22;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar24 = (int *)((int)local_138 - (int)local_f0);\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        if (-1 < (int)piVar22) {\n          piVar24 = (int *)((int)piVar24 - (int)piVar22);\n        }\n        if (0 < (int)piVar24) {\n          for (; local_d0 = piVar27, 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_reallocate_memory_080097cc(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n          }\n          goto LAB_08007014;\n        }\n      }\n    }\n    else {\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_d0 = (int *)((int)piVar27 + 1);\n      *ppiVar2 = (int *)&DAT_08009f4c;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)local_d4 < 8) {\n        ppiVar2 = ppiVar2 + 2;\n      }\n      else {\n        iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar2 = local_cc;\n      }\n      if (((int)local_f0 < (int)local_138) || (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)local_118);\n        *ppiVar2 = local_114;\n        ppiVar2[1] = local_118;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        piVar22 = local_160;\n        puVar29 = local_16c;\n        piVar24 = (int *)((int)local_138 + -1);\n        piVar27 = local_d0;\n        if (0 < (int)piVar24) {\n          for (; 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_reallocate_memory_080097cc(puVar29,piVar22,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\nLAB_08007014:\n          local_d0 = (int *)((int)local_d0 + (int)piVar24);\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar24;\njoined_r0x08006a1c:\n          local_d4 = (int *)((int)local_d4 + 1);\n          if (7 < (int)local_d4) goto LAB_08006a20;\n          goto LAB_0800640e;\n        }\n      }\n    }\n  }\n  piVar24 = local_160;\n  puVar29 = local_16c;\n  if ((((uint)piVar25 & 4) != 0) &&\n     (piVar25 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar25)) {\n    for (; local_d0 = piVar27, 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n      while( true ) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = (int *)0x10;\n        if ((int)local_d4 < 8) break;\n        iVar3 = copy_and_reallocate_memory_080097cc(puVar29,piVar24,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        piVar25 = piVar25 + -4;\n        ppiVar2 = local_cc;\n        if ((int)piVar25 < 0x11) goto LAB_0800647a;\n      }\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\nLAB_0800647a:\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar25);\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar25;\n    piVar27 = local_d0;\n    if ((7 < (int)local_d4) &&\n       (iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8), piVar27 = local_d0, iVar3 != 0))\n    goto LAB_0800603e;\n  }\n  piVar24 = local_15c;\n  if ((int)local_15c < (int)local_168) {\n    piVar24 = local_168;\n  }\n  local_164 = local_164 + (int)piVar24;\n  if ((piVar27 == (int *)0x0) || (iVar3 = copy_and_reallocate_memory_080097cc(local_16c,local_160,&local_d8), iVar3 == 0))\n  {\n    local_d4 = (int *)0x0;\n    if (local_148 != (int *)0x0) {\n      initialize_memory_management_080088ec(local_16c,local_148);\n    }\n    ppiVar2 = local_cc;\nLAB_0800620e:\n    bVar1 = *(byte *)piVar28;\n    param_3 = piVar28;\n    goto joined_r0x08005ef2;\n  }\nLAB_0800603e:\n  if (local_148 != (int *)0x0) {\n    initialize_memory_management_080088ec(local_16c,local_148);\n  }\n  goto LAB_0800604a;\nswitchD_08005f58_caseD_31:\n  local_15c = (int *)0x0;\n  piVar16 = piVar24 + -0xc;\n  piVar22 = piVar28;\n  do {\n    piVar28 = (int *)((int)piVar22 + 1);\n    piVar24 = (int *)(uint)*(byte *)piVar22;\n    local_15c = (int *)((int)piVar16 + (int)local_15c * 10);\n    piVar16 = piVar24 + -0xc;\n    piVar22 = piVar28;\n  } while (piVar16 < (int *)0xa);\n  goto LAB_08005f4e;\nswitchD_08005f58_caseD_20:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (local_f5 == 0) {\n    local_f5 = 0x20;\n  }\n  goto LAB_08005f4a;\n}\n\n",
            "renaming": {
                "FUN_08005e9c": "FUNC_08005e9c"
            },
            "calling": [
                "FUN_08005dfc"
            ],
            "called": [
                "FUN_080004c8",
                "FUN_08005e40",
                "FUN_0800119c",
                "FUN_080011ec",
                "FUN_080009c0",
                "FUN_08008ad4",
                "FUN_080003f4",
                "FUN_08000998",
                "FUN_08001170",
                "FUN_08008af8",
                "FUN_08000158",
                "FUN_08009768",
                "FUN_080009e8",
                "FUN_0800901c",
                "FUN_080009ac",
                "FUN_080097cc",
                "FUN_080096e0",
                "FUN_080088ec",
                "FUN_080079e8"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078a0": {
            "entrypoint": "0x080078a0",
            "current_name": "FUNC_080078a0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080078a4) */\n\nvoid FUNC_080078a0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080078a0": "FUNC_080078a0"
            },
            "calling": [
                "FUN_08005d20"
            ],
            "called": [
                "FUN_080098c0"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078c0": {
            "entrypoint": "0x080078c0",
            "current_name": "calculate_division_080078c0",
            "code": "\nuint calculateDivision_080078c0(int numerator,int denominator)\n\n{\n  uint temp1;\n  uint *ptrNumeratorIter;\n  int carry;\n  int denominatorLength;\n  int index;\n  uint quotient;\n  uint *ptrDenominator;\n  uint *ptrNumerator;\n  uint *ptrLastDenominator;\n  uint temp2;\n  uint *ptrDenominatorIter;\n  uint *ptrNextDenominator;\n  \n  denominatorLength = *(int *)(denominator + 0x10);\n  if (*(int *)(numerator + 0x10) < denominatorLength) {\n    return 0;\n  }\n  index = denominatorLength + -1;\n  ptrDenominator = (uint *)(denominator + 0x14);\n  ptrNumerator = (uint *)(numerator + 0x14);\n  quotient = ptrNumerator[index] / (ptrDenominator[index] + 1);\n  ptrLastDenominator = ptrDenominator + index;\n  if (quotient != 0) {\n    temp1 = 0;\n    carry = 0;\n    ptrNumeratorIter = ptrNumerator;\n    ptrDenominatorIter = ptrDenominator;\n    do {\n      ptrNextDenominator = ptrDenominatorIter + 1;\n      temp1 = quotient * (*ptrDenominatorIter & 0xffff) + temp1;\n      temp2 = quotient * (*ptrDenominatorIter >> 0x10) + (temp1 >> 0x10);\n      temp1 = (carry - (temp1 & 0xffff)) + (*ptrNumeratorIter & 0xffff);\n      carry = ((*ptrNumeratorIter >> 0x10) - (temp2 & 0xffff)) + ((int)temp1 >> 0x10);\n      *ptrNumeratorIter = temp1 & 0xffff | carry * 0x10000;\n      carry = carry >> 0x10;\n      temp1 = temp2 >> 0x10;\n      ptrNumeratorIter = ptrNumeratorIter + 1;\n      ptrDenominatorIter = ptrNextDenominator;\n    } while (ptrNextDenominator <= ptrLastDenominator);\n    if (ptrNumerator[index] == 0) {\n      if ((ptrNumerator < ptrNumerator + denominatorLength + -2) && (ptrNumerator[denominatorLength + -2] == 0)) {\n        ptrNumeratorIter = ptrNumerator + denominatorLength + -3;\n        do {\n          index = index + -1;\n          if (ptrNumeratorIter <= ptrNumerator) break;\n          temp1 = *ptrNumeratorIter;\n          ptrNumeratorIter = ptrNumeratorIter + -1;\n        } while (temp1 == 0);\n      }\n      *(int *)(numerator + 0x10) = index;\n    }\n  }\n  denominatorLength = compare_arrays_080094f8();\n  if (-1 < denominatorLength) {\n    denominatorLength = 0;\n    quotient = quotient + 1;\n    ptrNumeratorIter = ptrNumerator;\n    do {\n      ptrDenominatorIter = ptrDenominator + 1;\n      temp1 = (denominatorLength - (*ptrDenominator & 0xffff)) + (*ptrNumeratorIter & 0xffff);\n      denominatorLength = ((*ptrNumeratorIter >> 0x10) - (*ptrDenominator >> 0x10)) + ((int)temp1 >> 0x10);\n      *ptrNumeratorIter = temp1 & 0xffff | denominatorLength * 0x10000;\n      denominatorLength = denominatorLength >> 0x10;\n      ptrNumeratorIter = ptrNumeratorIter + 1;\n      ptrDenominator = ptrDenominatorIter;\n    } while (ptrDenominatorIter <= ptrLastDenominator);\n    if (ptrNumerator[index] == 0) {\n      if ((ptrNumerator < ptrNumerator + index + -1) && (ptrNumerator[index + -1] == 0)) {\n        ptrDenominator = ptrNumerator + index + -2;\n        do {\n          index = index + -1;\n          if (ptrDenominator <= ptrNumerator) break;\n          temp1 = *ptrDenominator;\n          ptrDenominator = ptrDenominator + -1;\n        } while (temp1 == 0);\n      }\n      *(int *)(numerator + 0x10) = index;\n    }\n  }\n  return quotient;\n}\n\n",
            "renaming": {
                "FUN_080078c0": "calculate_division_080078c0",
                "param_1": "numerator",
                "param_2": "denominator",
                "iVar4": "denominatorLength",
                "iVar5": "index",
                "puVar7": "ptrDenominator",
                "puVar8": "ptrNumerator",
                "uVar6": "quotient",
                "puVar9": "ptrLastDenominator",
                "uVar1": "temp1",
                "iVar3": "carry",
                "puVar2": "ptrNumeratorIter",
                "puVar11": "ptrDenominatorIter",
                "puVar12": "ptrNextDenominator",
                "uVar10": "temp2"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080094f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080079e8": {
            "entrypoint": "0x080079e8",
            "current_name": "formatted_float_to_string_080079e8",
            "code": "\nchar * formattedFloatToString_080079e8(int value,undefined4 param2,uint significantBits,uint exponent,uint flags,\n                   uint precision,int *errorCode,uint *flag,char **result)\n\n{\n  bool isNegative;\n  bool isZeroOrInfinity;\n  bool needsRounding;\n  char digit;\n  byte isLessThanOne;\n  undefined4 bits;\n  int compareResult;\n  int result;\n  int result;\n  char *pcVar10;\n  uint tempResult;\n  undefined4 param1;\n  undefined4 param2;\n  int roundingShift;\n  int decimalDigits;\n  undefined4 quotient;\n  uint absExponent;\n  uint absExponent;\n  int shift;\n  char *pcVar20;\n  char *pcVar21;\n  undefined4 *puVar22;\n  undefined4 quotient;\n  int tempResult;\n  bool isZeroOrInfinity5;\n  undefined8 tempResult;\n  undefined8 quotient;\n  undefined8 tempResult;\n  uint formattedResult;\n  uint absExponent;\n  uint errorCode;\n  int shift;\n  uint numDigits;\n  int shiftAmount;\n  int shiftAmount;\n  uint trailingZeros;\n  uint digit;\n  uint tempResult;\n  uint minDigits;\n  uint minDigits;\n  int trailingZeros;\n  int parsedDigits [2];\n  \n  roundingShift = *(int *)(value + 0x40);\n  if (roundingShift != 0) {\n    absExponent = *(uint *)(value + 0x44);\n    *(uint *)(roundingShift + 4) = absExponent;\n    *(int *)(roundingShift + 8) = 1 << (absExponent & 0xff);\n    update_pointer_0800910c(value,roundingShift);\n    *(undefined4 *)(value + 0x40) = 0;\n  }\n  isZeroOrInfinity5 = (int)exponent < 0;\n  absExponent = exponent;\n  if (isZeroOrInfinity5) {\n    absExponent = exponent & 0x7fffffff;\n  }\n  *flag = (uint)isZeroOrInfinity5;\n  absExponent = exponent;\n  if (isZeroOrInfinity5) {\n    absExponent = absExponent;\n  }\n  absExponent = absExponent;\n  if ((~absExponent & 0x7ff00000) == 0) {\n    *errorCode = 9999;\n    if ((significantBits == 0) && ((absExponent & 0xfffff) == 0)) {\n      pcVar10 = \"Infinity\";\n      if (result == (char **)0x0) {\n        return pcVar10;\n      }\n      pcVar21 = \"\";\n    }\n    else {\n      pcVar10 = \"NaN\";\n      if (result == (char **)0x0) {\n        return pcVar10;\n      }\n      pcVar21 = \"\";\n    }\n    *result = pcVar21;\n    return pcVar10;\n  }\n  tempResult = check_comparison_result_08000998(significantBits,absExponent,0,0);\n  if ((int)tempResult != 0) {\n    *errorCode = 1;\n    if (result != (char **)0x0) {\n      *result = \"\";\n      return \"0\";\n    }\n    return \"0\";\n  }\n  bits = decode_and_count_bits_08009630(value,(int)((ulonglong)tempResult >> 0x20),significantBits,absExponent,parsedDigits,&trailingZeros)\n  ;\n  roundingShift = trailingZeros;\n  if (absExponent >> 0x14 == 0) {\n    shift = parsedDigits[0] + trailingZeros;\n    decimalDigits = shift + 0x432;\n    if (decimalDigits < 0x21) {\n      absExponent = significantBits << (0x20U - decimalDigits & 0xff);\n    }\n    else {\n      absExponent = significantBits >> (shift + 0x412U & 0xff) | absExponent << (0x40U - decimalDigits & 0xff);\n    }\n    tempResult = reversed_shift_080003d4(absExponent);\n    shift = shift + -1;\n    isZeroOrInfinity5 = true;\n    tempResult = (int)((ulonglong)tempResult >> 0x20) + 0xfe100000;\n    absExponent = (uint)tempResult;\n  }\n  else {\n    shift = (absExponent >> 0x14) - 0x3ff;\n    tempResult = absExponent & 0xfffff | 0x3ff00000;\n    isZeroOrInfinity5 = false;\n    absExponent = significantBits;\n  }\n  tempResult = perform_arithmetic_operation_08000158(absExponent,tempResult,0,0x3ff80000);\n  tempResult = calculate_bitwise_difference_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0x636f4361,0x3fd287a7);\n  tempResult = perform_unsigned_division_0800015c((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0x8b60c8b3,0x3fc68a28);\n  quotient = calculate_shift_and_mask_080003f4(shift);\n  quotient = calculate_bitwise_difference_080004c8((int)quotient,(int)((ulonglong)quotient >> 0x20),0x509f79fb,0x3fd34413);\n  tempResult = perform_unsigned_division_0800015c((int)tempResult,(int)((ulonglong)tempResult >> 0x20),(int)quotient,\n                        (int)((ulonglong)quotient >> 0x20));\n  param2 = (undefined4)((ulonglong)tempResult >> 0x20);\n  errorCode = calculate_signed_divisor_0800119c();\n  decimalDigits = check_if_string_is_null_terminated_080009ac((int)tempResult,param2,0,0);\n  if (decimalDigits != 0) {\n    quotient = calculate_shift_and_mask_080003f4(errorCode);\n    decimalDigits = check_comparison_result_08000998((int)quotient,(int)((ulonglong)quotient >> 0x20),(int)tempResult,param2);\n    if (decimalDigits == 0) {\n      errorCode = errorCode - 1;\n    }\n  }\n  if (errorCode < 0x17) {\n    decimalDigits = is_string_terminated_080009e8(*(undefined4 *)(&DAT_08009fa8 + errorCode * 8),\n                          *(undefined4 *)(&DAT_08009fac + errorCode * 8),significantBits,absExponent);\n    if (decimalDigits == 0) {\n      isZeroOrInfinity = false;\n    }\n    else {\n      errorCode = errorCode - 1;\n      isZeroOrInfinity = false;\n    }\n  }\n  else {\n    isZeroOrInfinity = true;\n  }\n  decimalDigits = (roundingShift - shift) + -1;\n  if (decimalDigits < 0) {\n    shift = 1 - (roundingShift - shift);\n    decimalDigits = 0;\n  }\n  else {\n    shift = 0;\n  }\n  if ((int)errorCode < 0) {\n    trailingZeros = 0;\n    shift = shift - errorCode;\n    shiftAmount = -errorCode;\n  }\n  else {\n    decimalDigits = decimalDigits + errorCode;\n    trailingZeros = errorCode;\n    shiftAmount = 0;\n  }\n  if (9 < flags) {\n    minDigits = 0xffffffff;\n    isNegative = true;\n    numDigits = 0xffffffff;\n    needsRounding = true;\n    flags = 0;\n    precision = 0;\n    goto LAB_08007c24;\n  }\n  isNegative = (int)flags < 6;\n  if (!isNegative) {\n    flags = flags - 4;\n  }\n  switch(flags) {\n  case 2:\n    needsRounding = false;\n    break;\n  case 3:\n    needsRounding = false;\n    goto LAB_08008300;\n  case 4:\n    needsRounding = true;\n    break;\n  case 5:\n    needsRounding = true;\nLAB_08008300:\n    minDigits = errorCode + precision;\n    numDigits = minDigits + 1;\n    absExponent = numDigits;\n    if ((int)numDigits < 1) {\n      absExponent = 1;\n    }\n    goto LAB_08008314;\n  default:\n    *(undefined4 *)(value + 0x44) = 0;\n    pcVar10 = (char *)allocate_and_initialize_array_080090c0(value,0);\n    minDigits = 0xffffffff;\n    numDigits = 0xffffffff;\n    precision = 0;\n    *(char **)(value + 0x40) = pcVar10;\n    needsRounding = true;\n    goto LAB_08007e36;\n  }\n  if ((int)precision < 1) {\n    minDigits = 1;\n    precision = 1;\n    numDigits = 1;\nLAB_08007c24:\n    *(undefined4 *)(value + 0x44) = 0;\n    tempResult = minDigits;\n  }\n  else {\n    minDigits = precision;\n    numDigits = precision;\n    absExponent = precision;\nLAB_08008314:\n    *(undefined4 *)(value + 0x44) = 0;\n    tempResult = numDigits;\n    if (0x17 < (int)absExponent) {\n      shift = 4;\n      roundingShift = 1;\n      do {\n        compareResult = roundingShift;\n        shift = shift * 2;\n        roundingShift = compareResult + 1;\n      } while (shift + 0x14U <= absExponent);\n      *(int *)(value + 0x44) = compareResult;\n    }\n  }\n  pcVar10 = (char *)allocate_and_initialize_array_080090c0(value);\n  *(char **)(value + 0x40) = pcVar10;\n  if ((tempResult < 0xf) && (isNegative)) {\n    if ((int)errorCode < 1) {\n      if (errorCode == 0) {\n        roundingShift = 2;\n        formattedResult = significantBits;\n      }\n      else {\n        roundingShift = (-errorCode & 0xf) * 8;\n        tempResult = calculate_bitwise_difference_080004c8(significantBits,absExponent,*(undefined4 *)(&DAT_08009fa8 + roundingShift),\n                              *(undefined4 *)(&DAT_08009fac + roundingShift));\n        absExponent = (uint)((ulonglong)tempResult >> 0x20);\n        formattedResult = (uint)tempResult;\n        shift = (int)-errorCode >> 4;\n        if (shift == 0) {\n          roundingShift = 2;\n        }\n        else {\n          isNegative = false;\n          roundingShift = 2;\n          puVar22 = &DAT_08009f80;\n          do {\n            if (shift << 0x1f < 0) {\n              tempResult = calculate_bitwise_difference_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),*puVar22,puVar22[1]\n                                   );\n              isNegative = true;\n              roundingShift = roundingShift + 1;\n            }\n            shift = shift >> 1;\n            puVar22 = puVar22 + 2;\n          } while (shift != 0);\n          if (isNegative) {\n            formattedResult = (uint)tempResult;\n            absExponent = (uint)((ulonglong)tempResult >> 0x20);\n          }\n        }\n      }\n    }\n    else {\n      absExponent = (int)errorCode >> 4;\n      quotient = *(undefined8 *)(&DAT_08009fa8 + (errorCode & 0xf) * 8);\n      tempResult = *(undefined8 *)(&DAT_08009fa8 + (errorCode & 0xf) * 8);\n      if ((int)(absExponent << 0x1b) < 0) {\n        tempResult = calculate_floating_point_0800071c(significantBits,absExponent,0x7f73bf3c,0x75154fdd);\n        tempResult = (uint)((ulonglong)tempResult >> 0x20);\n        digit = (uint)tempResult;\n        roundingShift = 3;\n        absExponent = absExponent & 0xf;\n      }\n      else {\n        roundingShift = 2;\n        tempResult = absExponent;\n        digit = significantBits;\n      }\n      if (absExponent != 0) {\n        puVar22 = &DAT_08009f80;\n        do {\n          if ((int)(absExponent << 0x1f) < 0) {\n            tempResult = calculate_bitwise_difference_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),*puVar22,puVar22[1]);\n            roundingShift = roundingShift + 1;\n          }\n          absExponent = (int)absExponent >> 1;\n          puVar22 = puVar22 + 2;\n          quotient = tempResult;\n        } while (absExponent != 0);\n      }\n      absExponent = (uint)((ulonglong)quotient >> 0x20);\n      formattedResult = (uint)quotient;\n      tempResult = calculate_floating_point_0800071c(digit,tempResult,formattedResult,absExponent);\n      formattedResult = (uint)tempResult;\n      absExponent = (uint)((ulonglong)tempResult >> 0x20);\n    }\n    tempResult = CONCAT44(absExponent,formattedResult);\n    if ((isZeroOrInfinity) && (shift = check_if_string_is_null_terminated_080009ac(formattedResult,absExponent,0,0x3ff00000), shift != 0)) {\n      if (numDigits == 0) {\n        tempResult = calculate_shift_and_mask_080003f4(roundingShift);\n        tempResult = calculate_bitwise_difference_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),formattedResult,absExponent);\n        tempResult = perform_unsigned_division_0800015c((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0,0x401c0000);\n        param2 = (undefined4)tempResult;\n        roundingShift = (int)((ulonglong)tempResult >> 0x20) + -0x3400000;\n        goto LAB_0800852e;\n      }\n      if (0 < (int)minDigits) {\n        tempResult = calculate_bitwise_difference_080004c8(formattedResult,absExponent,0,0x40240000);\n        quotient = calculate_shift_and_mask_080003f4(roundingShift + 1);\n        quotient = calculate_bitwise_difference_080004c8((int)quotient,(int)((ulonglong)quotient >> 0x20),(int)tempResult,\n                              (int)((ulonglong)tempResult >> 0x20));\n        quotient = perform_unsigned_division_0800015c((int)quotient,(int)((ulonglong)quotient >> 0x20),0,0x401c0000);\n        param2 = (undefined4)quotient;\n        digit = minDigits;\n        minDigits = errorCode - 1;\n        roundingShift = (int)((ulonglong)quotient >> 0x20) + -0x3400000;\n        goto LAB_08007cfa;\n      }\n      goto LAB_08007e36;\n    }\n    quotient = calculate_shift_and_mask_080003f4(roundingShift);\n    quotient = calculate_bitwise_difference_080004c8((int)quotient,(int)((ulonglong)quotient >> 0x20),formattedResult,absExponent);\n    quotient = perform_unsigned_division_0800015c((int)quotient,(int)((ulonglong)quotient >> 0x20),0,0x401c0000);\n    param2 = (undefined4)quotient;\n    roundingShift = (int)((ulonglong)quotient >> 0x20) + -0x3400000;\n    if (numDigits != 0) {\n      minDigits = errorCode;\n      digit = numDigits;\nLAB_08007cfa:\n      absExponent = (uint)((ulonglong)tempResult >> 0x20);\n      formattedResult = (uint)tempResult;\n      digit = calculate_signed_divisor_0800119c(formattedResult,absExponent);\n      digit = digit + '0';\n      quotient = (&DAT_08009fa0)[digit * 2];\n      param1 = (&DAT_08009fa4)[digit * 2];\n      tempResult = calculate_shift_and_mask_080003f4();\n      tempResult = perform_arithmetic_operation_08000158(formattedResult,absExponent,(int)tempResult,(int)((ulonglong)tempResult >> 0x20));\n      quotient = (undefined4)((ulonglong)tempResult >> 0x20);\n      pcVar21 = pcVar10 + 1;\n      if (needsRounding) {\n        quotient = calculate_floating_point_0800071c(0,0x3fe00000,quotient,param1);\n        quotient = perform_arithmetic_operation_08000158((int)quotient,(int)((ulonglong)quotient >> 0x20),param2,roundingShift);\n        param2 = (undefined4)((ulonglong)quotient >> 0x20);\n        *pcVar10 = digit;\n        roundingShift = is_string_terminated_080009e8((int)quotient,param2,(int)tempResult,quotient);\n        if (roundingShift != 0) {\nLAB_08008784:\n          errorCode = minDigits;\n          goto LAB_08008294;\n        }\n        tempResult = perform_arithmetic_operation_08000158(0,0x3ff00000,(int)tempResult,quotient);\n        roundingShift = is_string_terminated_080009e8((int)quotient,param2,(int)tempResult,(int)((ulonglong)tempResult >> 0x20));\n        if (roundingShift == 0) {\n          if (digit != 1) {\n            pcVar20 = pcVar21;\n            do {\n              quotient = calculate_bitwise_difference_080004c8((int)quotient,(int)((ulonglong)quotient >> 0x20),0,0x40240000);\n              param2 = (undefined4)((ulonglong)quotient >> 0x20);\n              tempResult = calculate_bitwise_difference_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0,0x40240000);\n              digit = calculate_signed_divisor_0800119c();\n              tempResult = calculate_shift_and_mask_080003f4();\n              tempResult = perform_arithmetic_operation_08000158((int)tempResult,(int)((ulonglong)tempResult >> 0x20),(int)tempResult,\n                                    (int)((ulonglong)tempResult >> 0x20));\n              quotient = (undefined4)((ulonglong)tempResult >> 0x20);\n              digit = digit + '0';\n              pcVar21 = pcVar20 + 1;\n              *pcVar20 = digit;\n              roundingShift = check_if_string_is_null_terminated_080009ac((int)tempResult,quotient,(int)quotient,param2);\n              if (roundingShift != 0) {\n                errorCode = minDigits;\n                goto LAB_08008294;\n              }\n              tempResult = perform_arithmetic_operation_08000158(0,0x3ff00000,(int)tempResult,quotient);\n              roundingShift = check_if_string_is_null_terminated_080009ac((int)tempResult,(int)((ulonglong)tempResult >> 0x20),(int)quotient,param2)\n              ;\n              if (roundingShift != 0) goto LAB_08008798;\n              pcVar20 = pcVar21;\n            } while (pcVar21 != pcVar10 + digit);\n          }\n          goto LAB_08007e36;\n        }\nLAB_08008798:\n        errorCode = minDigits;\n      }\n      else {\n        quotient = calculate_bitwise_difference_080004c8(param2,roundingShift,quotient,param1);\n        param2 = (undefined4)((ulonglong)quotient >> 0x20);\n        *pcVar10 = digit;\n        if (digit != 1) {\n          pcVar20 = pcVar21;\n          do {\n            tempResult = calculate_bitwise_difference_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0,0x40240000);\n            digit = calculate_signed_divisor_0800119c();\n            tempResult = calculate_shift_and_mask_080003f4();\n            tempResult = perform_arithmetic_operation_08000158((int)tempResult,(int)((ulonglong)tempResult >> 0x20),(int)tempResult,\n                                  (int)((ulonglong)tempResult >> 0x20));\n            pcVar21 = pcVar20 + 1;\n            *pcVar20 = digit + '0';\n            pcVar20 = pcVar21;\n          } while (pcVar21 != pcVar10 + digit);\n        }\n        quotient = (undefined4)((ulonglong)tempResult >> 0x20);\n        tempResult = perform_unsigned_division_0800015c((int)quotient,param2,0,0x3fe00000);\n        roundingShift = check_if_string_is_null_terminated_080009ac((int)tempResult,(int)((ulonglong)tempResult >> 0x20),(int)tempResult,quotient);\n        if (roundingShift == 0) {\n          quotient = perform_arithmetic_operation_08000158(0,0x3fe00000,(int)quotient,param2);\n          roundingShift = is_string_terminated_080009e8((int)quotient,(int)((ulonglong)quotient >> 0x20),(int)tempResult,quotient);\n          pcVar20 = pcVar21;\n          if (roundingShift == 0) goto LAB_08007e36;\n          do {\n            pcVar21 = pcVar20;\n            pcVar20 = pcVar21 + -1;\n          } while (pcVar21[-1] == '0');\n          goto LAB_08008784;\n        }\n        errorCode = minDigits;\n        digit = pcVar21[-1];\n      }\n      goto LAB_08007f7c;\n    }\nLAB_0800852e:\n    tempResult = perform_arithmetic_operation_08000158(formattedResult,absExponent,0,0x40140000);\n    quotient = (undefined4)((ulonglong)tempResult >> 0x20);\n    shift = is_string_terminated_080009e8((int)tempResult,quotient,param2,roundingShift);\n    if (shift == 0) {\n      roundingShift = check_if_string_is_null_terminated_080009ac((int)tempResult,quotient,param2,roundingShift + -0x80000000);\n      if (roundingShift == 0) goto LAB_08007e36;\n      shift = 0;\n      roundingShift = 0;\n      pcVar21 = pcVar10;\n      goto LAB_080084f0;\n    }\n    decimalDigits = 0;\n    compareResult = 0;\nLAB_08008406:\n    *pcVar10 = '1';\n    errorCode = errorCode + 1;\n    pcVar21 = pcVar10 + 1;\n    shift = compareResult;\n    roundingShift = decimalDigits;\nLAB_08008416:\n    update_pointer_0800910c(value,roundingShift);\n    if (shift == 0) goto LAB_08008294;\n  }\n  else {\nLAB_08007e36:\n    pcVar21 = pcVar10;\n    if ((-1 < parsedDigits[0]) && ((int)errorCode < 0xf)) {\n      param2 = *(undefined4 *)(&DAT_08009fa8 + errorCode * 8);\n      quotient = *(undefined4 *)(&DAT_08009fac + errorCode * 8);\n      if ((-1 < (int)precision) || (0 < (int)numDigits)) {\n        calculate_floating_point_0800071c(significantBits,absExponent,param2,quotient);\n        isLessThanOne = calculate_signed_divisor_0800119c();\n        tempResult = calculate_shift_and_mask_080003f4();\n        tempResult = calculate_bitwise_difference_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),param2,quotient);\n        tempResult = perform_arithmetic_operation_08000158(significantBits,absExponent,(int)tempResult,(int)((ulonglong)tempResult >> 0x20));\n        *pcVar10 = isLessThanOne + 0x30;\n        pcVar21 = pcVar10 + 1;\n        if (numDigits != 1) {\n          tempResult = calculate_bitwise_difference_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0,0x40240000);\n          roundingShift = check_comparison_result_08000998((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0,0);\n          while (roundingShift == 0) {\n            quotient = (undefined4)((ulonglong)tempResult >> 0x20);\n            calculate_floating_point_0800071c((int)tempResult,quotient,param2,quotient);\n            isLessThanOne = calculate_signed_divisor_0800119c();\n            quotient = calculate_shift_and_mask_080003f4();\n            quotient = calculate_bitwise_difference_080004c8((int)quotient,(int)((ulonglong)quotient >> 0x20),param2,quotient);\n            tempResult = perform_arithmetic_operation_08000158((int)tempResult,quotient,(int)quotient,(int)((ulonglong)quotient >> 0x20));\n            pcVar20 = pcVar21 + 1;\n            *pcVar21 = isLessThanOne + 0x30;\n            pcVar21 = pcVar20;\n            if (numDigits == (int)pcVar20 - (int)pcVar10) goto LAB_08007f3a;\n            tempResult = calculate_bitwise_difference_080004c8((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0,0x40240000);\n            roundingShift = check_comparison_result_08000998((int)tempResult,(int)((ulonglong)tempResult >> 0x20),0,0);\n          }\n          goto LAB_08008294;\n        }\nLAB_08007f3a:\n        tempResult = perform_unsigned_division_0800015c((int)tempResult,(int)((ulonglong)tempResult >> 0x20));\n        quotient = (undefined4)((ulonglong)tempResult >> 0x20);\n        roundingShift = is_string_terminated_080009e8((int)tempResult,quotient,param2,quotient);\n        if ((roundingShift == 0) &&\n           ((roundingShift = check_comparison_result_08000998((int)tempResult,quotient,param2,quotient), roundingShift == 0 ||\n            ((isLessThanOne & 1) == 0)))) goto LAB_08008294;\n        digit = pcVar21[-1];\nLAB_08007f7c:\n        while (pcVar20 = pcVar21 + -1, digit == '9') {\n          if (pcVar10 == pcVar20) {\n            *pcVar10 = '0';\n            digit = pcVar21[-1];\n            errorCode = errorCode + 1;\n            pcVar20 = pcVar10;\n            break;\n          }\n          digit = pcVar21[-2];\n          pcVar21 = pcVar20;\n        }\n        *pcVar20 = digit + '\\x01';\n        goto LAB_08008294;\n      }\n      if (numDigits == 0) {\n        tempResult = calculate_bitwise_difference_080004c8(param2,quotient,0,0x40140000);\n        result = check_condition_and_return_result_080009d4((int)tempResult,(int)((ulonglong)tempResult >> 0x20),significantBits,absExponent);\n        shift = 0;\n        decimalDigits = 0;\n        compareResult = 0;\n        roundingShift = 0;\n        if (result == 0) goto LAB_08008406;\n      }\n      else {\n        shift = 0;\n        roundingShift = 0;\n      }\nLAB_080084f0:\n      errorCode = ~precision;\n      pcVar10 = pcVar21;\n      goto LAB_08008416;\n    }\n    roundingShift = shiftAmount;\n    if (needsRounding) {\n      if ((int)flags < 2) {\n        if (isZeroOrInfinity5) {\n          shiftAmount = shift;\n          shift = shift + parsedDigits[0] + 0x433;\n          decimalDigits = decimalDigits + parsedDigits[0] + 0x433;\n        }\n        else {\n          shiftAmount = shift;\n          shift = shift + (0x36 - trailingZeros);\n          decimalDigits = decimalDigits + (0x36 - trailingZeros);\n        }\n      }\n      else {\n        shift = numDigits - 1;\n        if (shiftAmount < shift) {\n          trailingZeros = trailingZeros + (shift - shiftAmount);\n          roundingShift = 0;\n          shiftAmount = shift;\n        }\n        else {\n          roundingShift = shiftAmount - shift;\n        }\n        if ((int)numDigits < 0) {\n          shiftAmount = shift - numDigits;\n        }\n        else {\n          decimalDigits = decimalDigits + numDigits;\n          shiftAmount = shift;\n          shift = shift + numDigits;\n        }\n      }\n      shift = initialize_array_08009244(value,1);\n    }\n    else {\n      shiftAmount = shift;\n      shift = 0;\n    }\n    if ((0 < shiftAmount) && (0 < decimalDigits)) {\n      compareResult = shiftAmount;\n      if (decimalDigits <= shiftAmount) {\n        compareResult = decimalDigits;\n      }\n      decimalDigits = decimalDigits - compareResult;\n      shift = shift - compareResult;\n      shiftAmount = shiftAmount - compareResult;\n    }\n    if (shiftAmount != 0) {\n      if (needsRounding) {\n        param2 = bits;\n        if (roundingShift != 0) {\n          shift = calculate_checksum_080093a4(value,shift,roundingShift);\n          param2 = initialize_and_compute_08009258(value,shift,bits);\n          update_pointer_0800910c(value,bits);\n          bits = param2;\n          if (shiftAmount - roundingShift == 0) goto LAB_08008062;\n        }\n        bits = calculate_checksum_080093a4(value,param2,shiftAmount - roundingShift);\n      }\n      else {\n        bits = calculate_checksum_080093a4(value,bits,shiftAmount);\n      }\n    }\nLAB_08008062:\n    roundingShift = initialize_array_08009244(value,1);\n    if (trailingZeros == 0) {\n      if (((int)flags < 2) && (significantBits == 0)) {\nLAB_0800835a:\n        if ((absExponent & 0xfffff) == 0) {\n          absExponent = absExponent & 0x7ff00000;\n          if (absExponent != 0) {\n            decimalDigits = decimalDigits + 1;\n            shift = shift + 1;\n            absExponent = 1;\n          }\n        }\n        else {\n          absExponent = 0;\n        }\n        isZeroOrInfinity5 = trailingZeros != 0;\n        absExponent = significantBits;\n        trailingZeros = absExponent;\n        if (isZeroOrInfinity5) goto LAB_080082d4;\n      }\n      compareResult = 1;\n    }\n    else {\n      tempResult = calculate_checksum_080093a4(value,roundingShift);\n      roundingShift = (int)tempResult;\n      if (((int)flags < 2) && (significantBits == 0)) goto LAB_0800835a;\n      trailingZeros = 0;\n      absExponent = (uint)((ulonglong)tempResult >> 0x20);\nLAB_080082d4:\n      compareResult = find_most_significant_bit_080091a4(*(undefined4 *)(roundingShift + *(int *)(roundingShift + 0x10) * 4 + 0x10),absExponent);\n      compareResult = 0x20 - compareResult;\n    }\n    absExponent = compareResult + decimalDigits & 0x1f;\n    if (absExponent == 0) {\n      compareResult = 0x1c;\nLAB_08008096:\n      decimalDigits = decimalDigits + compareResult;\n      shift = shift + compareResult;\n      shiftAmount = shiftAmount + compareResult;\n    }\n    else {\n      if (4 < (int)(0x20 - absExponent)) {\n        compareResult = 0x1c - absExponent;\n        goto LAB_08008096;\n      }\n      if (0x20 - absExponent != 4) {\n        compareResult = 0x3c - absExponent;\n        goto LAB_08008096;\n      }\n    }\n    if (0 < shift) {\n      bits = initialize_and_copy_array_08009444(value,bits,shift);\n    }\n    if (0 < decimalDigits) {\n      roundingShift = initialize_and_copy_array_08009444(value,roundingShift,decimalDigits);\n    }\n    pcVar20 = pcVar10;\n    if ((isZeroOrInfinity) && (decimalDigits = compare_arrays_080094f8(bits,roundingShift), decimalDigits < 0)) {\n      errorCode = errorCode - 1;\n      bits = calculate_checksum_08009120(value,bits,10,0);\n      if (needsRounding) {\n        shift = calculate_checksum_08009120(value,shift,10,0);\n        if ((0 < (int)minDigits) || ((int)flags < 3)) {\n          numDigits = minDigits;\n          goto LAB_080080de;\n        }\n      }\n      else if ((0 < (int)minDigits) || ((int)flags < 3)) {\n        numDigits = minDigits;\n        goto LAB_0800820a;\n      }\n      numDigits = minDigits;\nLAB_080084e8:\n      if (numDigits == 0) {\n        decimalDigits = calculate_checksum_08009120(value,roundingShift,5);\n        result = compare_arrays_080094f8(bits,decimalDigits);\n        compareResult = shift;\n        roundingShift = decimalDigits;\n        if (0 < result) goto LAB_08008406;\n      }\n      goto LAB_080084f0;\n    }\n    if (((int)numDigits < 1) && (2 < (int)flags)) goto LAB_080084e8;\n    if (needsRounding) {\nLAB_080080de:\n      formattedResult = shift;\n      if (0 < shiftAmount) {\n        formattedResult = initialize_and_copy_array_08009444(value,shift,shiftAmount);\n      }\n      shift = formattedResult;\n      if (trailingZeros != 0) {\n        shift = allocate_and_initialize_array_080090c0(value,*(undefined4 *)(formattedResult + 4));\n        copy_memory_08001084(shift + 0xc,formattedResult + 0xc,(*(int *)(formattedResult + 0x10) + 2) * 4);\n        shift = initialize_and_copy_array_08009444(value,shift,1);\n      }\nLAB_08008108:\n      decimalDigits = calculate_division_080078c0(bits,roundingShift);\n      compareResult = compare_arrays_080094f8(bits,formattedResult);\n      result = compare_and_allocate_08009530(value,roundingShift,shift);\n      tempResult = decimalDigits + 0x30;\n      if (*(int *)(result + 0xc) == 0) {\n        result = compare_arrays_080094f8(bits);\n        update_pointer_0800910c(value,result);\n        if ((result != 0) || (flags != 0)) goto LAB_0800815a;\n        if ((significantBits & 1) != 0) {\n          result = 0;\n          goto LAB_0800815a;\n        }\n        if (tempResult != 0x39) {\n          if (0 < compareResult) goto LAB_0800874c;\n          goto LAB_080085a4;\n        }\nLAB_08008752:\n        pcVar21 = pcVar20 + 1;\n        digit = '9';\n        *pcVar20 = '9';\n        goto LAB_08008268;\n      }\n      update_pointer_0800910c(value,result);\n      result = 1;\nLAB_0800815a:\n      if ((compareResult < 0) || (((compareResult == 0 && (flags == 0)) && ((significantBits & 1) == 0)))) {\n        if (0 < result) {\n          bits = initialize_and_copy_array_08009444(value,bits,1);\n          compareResult = compare_arrays_080094f8(bits,roundingShift);\n          if ((0 < compareResult) || ((compareResult == 0 && (decimalDigits << 0x1f < 0)))) {\n            if (tempResult == 0x39) goto LAB_08008752;\nLAB_0800874c:\n            tempResult = decimalDigits + 0x31;\n          }\n        }\nLAB_080085a4:\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)tempResult;\n        goto LAB_08008274;\n      }\n      pcVar21 = pcVar20 + 1;\n      if (0 < result) {\n        if (tempResult == 0x39) goto LAB_08008752;\n        *pcVar20 = (char)decimalDigits + '1';\n        goto LAB_08008274;\n      }\n      *pcVar20 = (char)tempResult;\n      if (pcVar10 + (numDigits - 1) != pcVar20) {\n        bits = calculate_checksum_08009120(value,bits,10,0);\n        pcVar20 = pcVar21;\n        if (formattedResult == shift) {\n          formattedResult = calculate_checksum_08009120(value,formattedResult,10,0);\n          shift = formattedResult;\n        }\n        else {\n          formattedResult = calculate_checksum_08009120(value,formattedResult,10,0);\n          shift = calculate_checksum_08009120(value,shift,10,0);\n        }\n        goto LAB_08008108;\n      }\n    }\n    else {\nLAB_0800820a:\n      while( true ) {\n        tempResult = calculate_division_080078c0(bits,roundingShift);\n        tempResult = tempResult + 0x30;\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)tempResult;\n        if ((int)numDigits <= (int)pcVar21 - (int)pcVar10) break;\n        bits = calculate_checksum_08009120(value,bits,10,0);\n        pcVar20 = pcVar21;\n      }\n      formattedResult = 0;\n    }\n    bits = initialize_and_copy_array_08009444(value,bits,1);\n    decimalDigits = compare_arrays_080094f8(bits,roundingShift);\n    digit = pcVar21[-1];\n    if ((0 < decimalDigits) || ((decimalDigits == 0 && (tempResult << 0x1f < 0)))) {\nLAB_08008268:\n      do {\n        pcVar20 = pcVar21 + -1;\n        if (digit != '9') goto code_r0x08008270;\n        if (pcVar10 == pcVar20) {\n          *pcVar10 = '1';\n          errorCode = errorCode + 1;\n          goto LAB_08008274;\n        }\n        digit = pcVar21[-2];\n        pcVar21 = pcVar20;\n      } while( true );\n    }\n    while (digit == '0') {\n      digit = pcVar21[-2];\n      pcVar21 = pcVar21 + -1;\n    }\nLAB_08008274:\n    update_pointer_0800910c(value,roundingShift);\n    if (shift == 0) goto LAB_08008294;\n    if ((formattedResult != 0) && (formattedResult != shift)) {\n      update_pointer_0800910c(value);\n    }\n  }\n  update_pointer_0800910c(value,shift);\nLAB_08008294:\n  update_pointer_0800910c(value,bits);\n  *pcVar21 = '\\0';\n  *errorCode = errorCode + 1;\n  if (result == (char **)0x0) {\n    return pcVar10;\n  }\n  *result = pcVar21;\n  return pcVar10;\ncode_r0x08008270:\n  *pcVar20 = digit + '\\x01';\n  goto LAB_08008274;\n}\n\n",
            "renaming": {
                "FUN_080079e8": "formatted_float_to_string_080079e8",
                "param_1": "value",
                "param_2": "param2",
                "param_3": "significantBits",
                "param_4": "exponent",
                "param_5": "flags",
                "param_6": "precision",
                "param_7": "errorCode",
                "param_8": "flag",
                "param_9": "result",
                "bVar1": "isNegative",
                "bVar2": "isZeroOrInfinity",
                "bVar3": "needsRounding",
                "cVar4": "digit",
                "bVar5": "isLessThanOne",
                "uVar6": "bits",
                "iVar7": "compareResult",
                "iVar8": "result",
                "iVar9": "result",
                "iVar14": "roundingShift",
                "iVar15": "decimalDigits",
                "iVar19": "shift",
                "iVar24": "tempResult",
                "uVar11": "tempResult",
                "uVar12": "param1",
                "uVar13": "param2",
                "uVar16": "quotient",
                "uVar17": "absExponent",
                "uVar18": "absExponent",
                "uVar23": "quotient",
                "uVar26": "tempResult",
                "uVar27": "quotient",
                "uVar28": "tempResult",
                "local_80": "formattedResult",
                "local_7c": "absExponent",
                "local_74": "errorCode",
                "local_70": "shift",
                "local_68": "numDigits",
                "local_60": "shiftAmount",
                "local_5c": "shiftAmount",
                "local_58": "trailingZeros",
                "local_48": "digit",
                "uStack_44": "tempResult",
                "local_38": "minDigits",
                "local_34": "minDigits",
                "local_30": "trailingZeros",
                "local_2c": "parsedDigits"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_080009d4",
                "FUN_080004c8",
                "FUN_08009244",
                "FUN_08009530",
                "FUN_08009630",
                "FUN_0800119c",
                "FUN_080091a4",
                "FUN_080090c0",
                "FUN_0800015c",
                "FUN_080003f4",
                "FUN_08000998",
                "FUN_080094f8",
                "FUN_08000158",
                "FUN_08009120",
                "FUN_080009e8",
                "FUN_080093a4",
                "FUN_080078c0",
                "FUN_080003d4",
                "FUN_080009ac",
                "FUN_0800910c",
                "FUN_08001084",
                "FUN_08009258",
                "FUN_08009444",
                "FUN_0800071c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800884c": {
            "entrypoint": "0x0800884c",
            "current_name": "initialize_data_0800884c",
            "code": "\nundefined4 initialize_data_0800884c(undefined4 data_ptr,int param_value)\n\n{\n  int result_1;\n  int result_2;\n  uint masked_value;\n  \n  initialize_data_0800884c_080090a8();\n  masked_value = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  result_2 = ((0xfef - param_value) + masked_value & 0xfffff000) - 0x1000;\n  if (0xfff < result_2) {\n    result_1 = initialize_and_check_08009744(data_ptr,0);\n    if (result_1 == DAT_20000454 + masked_value) {\n      result_1 = initialize_and_check_08009744(data_ptr,-result_2);\n      if (result_1 != -1) {\n        DAT_20000a14 = DAT_20000a14 - result_2;\n        *(uint *)(DAT_20000454 + 4) = masked_value - result_2 | 1;\n        initialize_data_0800884c_structures_080090b4(data_ptr);\n        return 1;\n      }\n      result_2 = initialize_and_check_08009744(data_ptr,0);\n      if (0xf < result_2 - DAT_20000454) {\n        DAT_20000a14 = result_2 - DAT_20000854;\n        *(uint *)(DAT_20000454 + 4) = result_2 - DAT_20000454 | 1;\n      }\n    }\n  }\n  initialize_data_0800884c_structures_080090b4(data_ptr);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800884c": "initialize_data_0800884c",
                "param_1": "data_ptr",
                "param_2": "param_value",
                "iVar1": "result_1",
                "iVar2": "result_2",
                "uVar3": "masked_value"
            },
            "calling": [
                "FUN_080088ec"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_08009744",
                "FUN_080090b4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080088ec": {
            "entrypoint": "0x080088ec",
            "current_name": "initialize_memory_management_080088ec",
            "code": "\nvoid initialize_memory_management_080088ec(undefined4 param,int size,undefined4 paramPtr1,undefined4 paramPtr2)\n\n{\n  int index;\n  uint *blockPtr;\n  uint *nextBlockPtr;\n  undefined *tempPtr1;\n  uint sizeAligned;\n  uint blockSize;\n  undefined *prevBlockPtr;\n  undefined *tempPtr2;\n  undefined4 *dataStructuresPtr;\n  int i;\n  uint flag;\n  uint temp;\n  \n  if (size == 0) {\n    return;\n  }\n  initializeData();\n  flag = *(uint *)(size + -4);\n  blockPtr = (uint *)(size + -8);\n  sizeAligned = flag & 0xfffffffe;\n  nextBlockPtr = (uint *)((int)blockPtr + sizeAligned);\n  blockSize = nextBlockPtr[1] & 0xfffffffc;\n  if (DAT_20000454 == nextBlockPtr) {\n    sizeAligned = sizeAligned + blockSize;\n    if ((flag & 1) == 0) {\n      blockPtr = (uint *)((int)blockPtr - *(int *)(size + -8));\n      blockSize = blockPtr[2];\n      flag = blockPtr[3];\n      sizeAligned = sizeAligned + *(int *)(size + -8);\n      *(uint *)(blockSize + 0xc) = flag;\n      *(uint *)(flag + 8) = blockSize;\n    }\n    blockSize = DAT_20000858;\n    blockPtr[1] = sizeAligned | 1;\n    DAT_20000454 = blockPtr;\n    if (blockSize <= sizeAligned) {\n      initialize_data_0800884c(param,DAT_20000a44);\n    }\nLAB_080089f0:\n    initializeDataStructures(param);\n    return;\n  }\n  nextBlockPtr[1] = blockSize;\n  if ((flag & 1) == 0) {\n    blockPtr = (uint *)((int)blockPtr - *(int *)(size + -8));\n    dataStructuresPtr = (undefined4 *)blockPtr[2];\n    sizeAligned = sizeAligned + *(int *)(size + -8);\n    flag = *(uint *)((int)nextBlockPtr + blockSize + 4) & 1;\n    if ((uint **)dataStructuresPtr == &DAT_20000454) {\n      if (flag == 0) {\n        flag = nextBlockPtr[2];\n        temp = nextBlockPtr[3];\n        sizeAligned = sizeAligned + blockSize;\n        *(uint *)(flag + 0xc) = temp;\n        *(uint *)(temp + 8) = flag;\n        blockPtr[1] = sizeAligned | 1;\n        *(uint *)((int)blockPtr + sizeAligned) = sizeAligned;\n      }\n      else {\n        blockPtr[1] = sizeAligned | 1;\n        *nextBlockPtr = sizeAligned;\n      }\n      goto LAB_080089f0;\n    }\n    temp = blockPtr[3];\n    dataStructuresPtr[3] = temp;\n    *(undefined4 **)(temp + 8) = dataStructuresPtr;\n  }\n  else {\n    flag = *(uint *)((int)nextBlockPtr + blockSize + 4) & 1;\n  }\n  if (flag == 0) {\n    dataStructuresPtr = (undefined4 *)nextBlockPtr[2];\n    sizeAligned = sizeAligned + blockSize;\n    if ((uint **)dataStructuresPtr == &DAT_20000454) {\n      DAT_2000045c = blockPtr;\n      DAT_20000460 = blockPtr;\n      blockPtr[2] = (uint)&DAT_20000454;\n      blockPtr[3] = (uint)&DAT_20000454;\n      blockPtr[1] = sizeAligned | 1;\n      *(uint *)((int)blockPtr + sizeAligned) = sizeAligned;\n      goto LAB_080089f0;\n    }\n    blockSize = nextBlockPtr[3];\n    dataStructuresPtr[3] = blockSize;\n    *(undefined4 **)(blockSize + 8) = dataStructuresPtr;\n    blockPtr[1] = sizeAligned | 1;\n    *(uint *)((int)blockPtr + sizeAligned) = sizeAligned;\n  }\n  else {\n    blockPtr[1] = sizeAligned | 1;\n    *(uint *)((int)blockPtr + sizeAligned) = sizeAligned;\n  }\n  if (sizeAligned < 0x200) {\n    i = (sizeAligned >> 3) + 1;\n    sizeAligned = 1 << ((int)(sizeAligned >> 3) >> 2 & 0xffU) | (uint)DAT_20000450;\n    blockSize = *(uint *)(&DAT_2000044c + i * 8);\n    blockPtr[2] = blockSize;\n    blockPtr[3] = (uint)(&DAT_20000444 + i * 8);\n    DAT_20000450 = (undefined *)sizeAligned;\n    *(uint **)(&DAT_2000044c + i * 8) = blockPtr;\n    *(uint **)(blockSize + 0xc) = blockPtr;\n    initializeDataStructures(param,blockPtr,sizeAligned,paramPtr2);\n    return;\n  }\n  blockSize = sizeAligned >> 9;\n  if (blockSize < 5) {\n    i = ((sizeAligned >> 6) + 0x39) * 8;\n    index = (sizeAligned >> 6) + 0x38;\n  }\n  else if (blockSize < 0x15) {\n    i = (blockSize + 0x5c) * 8;\n    index = blockSize + 0x5b;\n  }\n  else if (blockSize < 0x55) {\n    i = ((sizeAligned >> 0xc) + 0x6f) * 8;\n    index = (sizeAligned >> 0xc) + 0x6e;\n  }\n  else if (blockSize < 0x155) {\n    i = ((sizeAligned >> 0xf) + 0x78) * 8;\n    index = (sizeAligned >> 0xf) + 0x77;\n  }\n  else if (blockSize < 0x555) {\n    i = ((sizeAligned >> 0x12) + 0x7d) * 8;\n    index = (sizeAligned >> 0x12) + 0x7c;\n  }\n  else {\n    i = 0x3f8;\n    index = 0x7e;\n  }\n  tempPtr1 = *(undefined **)(&DAT_2000044c + i);\n  prevBlockPtr = &DAT_20000444 + i;\n  if (prevBlockPtr == tempPtr1) {\n    tempPtr1 = (undefined *)(1 << (index >> 2 & 0xffU) | (uint)DAT_20000450);\n    tempPtr2 = prevBlockPtr;\n    DAT_20000450 = tempPtr1;\n  }\n  else {\n    do {\n      tempPtr2 = tempPtr1;\n      if ((*(uint *)(tempPtr1 + 4) & 0xfffffffc) <= sizeAligned) break;\n      tempPtr1 = *(undefined **)(tempPtr1 + 8);\n      tempPtr2 = prevBlockPtr;\n    } while (prevBlockPtr != tempPtr1);\n    prevBlockPtr = *(undefined **)(tempPtr2 + 0xc);\n  }\n  blockPtr[2] = (uint)tempPtr2;\n  blockPtr[3] = (uint)prevBlockPtr;\n  *(uint **)(prevBlockPtr + 8) = blockPtr;\n  *(uint **)(tempPtr2 + 0xc) = blockPtr;\n  initializeDataStructures(param,blockPtr,tempPtr1,paramPtr2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080088ec": "initialize_memory_management_080088ec",
                "param_1": "param",
                "param_2": "size",
                "param_3": "paramPtr1",
                "param_4": "paramPtr2",
                "iVar1": "index",
                "puVar2": "blockPtr",
                "puVar3": "nextBlockPtr",
                "puVar4": "tempPtr1",
                "uVar5": "sizeAligned",
                "uVar6": "blockSize",
                "puVar7": "prevBlockPtr",
                "puVar8": "tempPtr2",
                "puVar9": "dataStructuresPtr",
                "iVar10": "i",
                "uVar11": "flag",
                "uVar12": "temp",
                "initialize_data_080090a8": "initializeData",
                "initialize_data_structures_080090b4": "initializeDataStructures"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_08009adc",
                "FUN_080097cc",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_080090b4",
                "FUN_0800884c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ad4": {
            "entrypoint": "0x08008ad4",
            "current_name": "get_base_offset_08008ad4",
            "code": "\nint getBaseOffset_08008ad4(void)\n\n{\n  int baseOffset;\n  \n  baseOffset = *(int *)(DAT_2000001c + 0x34);\n  if (baseOffset == 0) {\n    baseOffset = 0x2000085c;\n  }\n  return baseOffset + 0xf0;\n}\n\n",
            "renaming": {
                "FUN_08008ad4": "get_base_offset_08008ad4",
                "iVar1": "baseOffset"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008af0": {
            "entrypoint": "0x08008af0",
            "current_name": "FUNC_08008af0",
            "code": "\nvoid FUNC_08008af0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af0": "FUNC_08008af0"
            },
            "calling": [
                "FUN_080090a8",
                "FUN_080098c0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af4": {
            "entrypoint": "0x08008af4",
            "current_name": "FUNC_08008af4",
            "code": "\nvoid FUNC_08008af4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af4": "FUNC_08008af4"
            },
            "calling": [
                "FUN_080098c0",
                "FUN_080090b4"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af8": {
            "entrypoint": "0x08008af8",
            "current_name": "allocate_memory_08008af8",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocate_memory_08008af8(undefined4 *buffer,uint size)\n\n{\n  undefined *ptr;\n  uint temp1;\n  uint temp2;\n  int index;\n  undefined *ptr1;\n  uint temp3;\n  uint temp4;\n  undefined4 *ptr2;\n  undefined *ptr3;\n  undefined *ptr4;\n  int *result;\n  uint temp5;\n  uint temp6;\n  int index2;\n  undefined4 *ptr5;\n  undefined4 *ptr6;\n  \n  temp5 = size + 0xb;\n  if (temp5 < 0x17) {\n    if (0x10 < size) goto LAB_08008c7a;\n    initialize_data_080090a8();\n    temp6 = 0x10;\n    index = 0x18;\n    temp5 = 2;\nLAB_08008b18:\n    ptr4 = *(undefined **)((int)&DAT_20000450 + index);\n    if ((ptr4 != &DAT_20000444 + index) ||\n       (ptr4 = *(undefined **)((int)&DAT_20000458 + index), &DAT_2000044c + index != ptr4)) {\n      index = *(int *)(ptr4 + 0xc);\n      ptr1 = ptr4 + (*(uint *)(ptr4 + 4) & 0xfffffffc);\n      temp5 = *(uint *)(ptr1 + 4);\nLAB_08008b34:\n      index2 = *(int *)(ptr4 + 8);\n      *(int *)(index2 + 0xc) = index;\n      *(int *)(index + 8) = index2;\n      *(uint *)(ptr1 + 4) = temp5 | 1;\n      initialize_data_structures_080090b4(buffer);\n      return (int *)(ptr4 + 8);\n    }\n    temp5 = temp5 + 2;\n  }\n  else {\n    temp6 = temp5 & 0xfffffff8;\n    if (((int)temp6 < 0) || (temp6 < size)) {\nLAB_08008c7a:\n      *buffer = 0xc;\n      return (int *)0x0;\n    }\n    initialize_data_080090a8();\n    if (temp6 < 0x1f8) {\n      temp5 = temp5 >> 3;\n      index = temp6 + 8;\n      goto LAB_08008b18;\n    }\n    temp1 = temp5 >> 9;\n    if (temp1 == 0) {\n      index = 0x200;\n      temp3 = 0x40;\n      temp1 = 0x3f;\n    }\n    else if (temp1 < 5) {\n      temp3 = (temp5 >> 6) + 0x39;\n      temp1 = (temp5 >> 6) + 0x38;\n      index = temp3 * 8;\n    }\n    else if (temp1 < 0x15) {\n      temp3 = temp1 + 0x5c;\n      temp1 = temp1 + 0x5b;\n      index = temp3 * 8;\n    }\n    else if (temp1 < 0x55) {\n      temp3 = (temp5 >> 0xc) + 0x6f;\n      temp1 = (temp5 >> 0xc) + 0x6e;\n      index = temp3 * 8;\n    }\n    else if (temp1 < 0x155) {\n      temp3 = (temp5 >> 0xf) + 0x78;\n      temp1 = (temp5 >> 0xf) + 0x77;\n      index = temp3 * 8;\n    }\n    else if (temp1 < 0x555) {\n      temp3 = (temp5 >> 0x12) + 0x7d;\n      temp1 = (temp5 >> 0x12) + 0x7c;\n      index = temp3 * 8;\n    }\n    else {\n      index = 0x3f8;\n      temp3 = 0x7f;\n      temp1 = 0x7e;\n    }\n    for (ptr4 = *(undefined **)((int)&DAT_20000450 + index); temp5 = temp3,\n        &DAT_20000444 + index != ptr4; ptr4 = *(undefined **)(ptr4 + 0xc)) {\n      index2 = (*(uint *)(ptr4 + 4) & 0xfffffffc) - temp6;\n      temp5 = temp1;\n      if (0xf < index2) break;\n      if (-1 < index2) {\n        ptr1 = ptr4 + (*(uint *)(ptr4 + 4) & 0xfffffffc);\n        temp5 = *(uint *)(ptr1 + 4);\n        index = *(int *)(ptr4 + 0xc);\n        goto LAB_08008b34;\n      }\n    }\n  }\n  ptr5 = DAT_2000045c;\n  if ((undefined **)DAT_2000045c == &DAT_20000454) {\n    temp3 = 1 << ((int)temp5 >> 2 & 0xffU);\n    temp1 = DAT_20000450;\n    if (temp3 <= DAT_20000450) goto LAB_08008c06;\n  }\n  else {\n    temp3 = DAT_2000045c[1];\n    temp4 = temp3 & 0xfffffffc;\n    temp1 = temp4 - temp6;\n    if (0xf < (int)temp1) {\n      ptr6 = (undefined4 *)(temp6 + (int)DAT_2000045c);\n      DAT_2000045c[1] = temp6 | 1;\n      DAT_2000045c = ptr6;\n      DAT_20000460 = ptr6;\n      ptr6[2] = &DAT_20000454;\n      ptr6[3] = &DAT_20000454;\n      ptr6[1] = temp1 | 1;\n      *(uint *)((int)ptr5 + temp4) = temp1;\n      initialize_data_structures_080090b4(buffer);\n      return ptr5 + 2;\n    }\n    DAT_2000045c = &DAT_20000454;\n    DAT_20000460 = &DAT_20000454;\n    if (-1 < (int)temp1) {\n      *(uint *)((int)ptr5 + temp4 + 4) = *(uint *)((int)ptr5 + temp4 + 4) | 1;\n      initialize_data_structures_080090b4(buffer);\n      return ptr5 + 2;\n    }\n    if (temp4 < 0x200) {\n      index = (temp3 >> 3) + 1;\n      index2 = *(int *)(&DAT_2000044c + index * 8);\n      temp1 = 1 << ((int)(temp3 >> 3) >> 2 & 0xffU) | DAT_20000450;\n      ptr5[2] = index2;\n      ptr5[3] = &DAT_20000444 + index * 8;\n      DAT_20000450 = temp1;\n      *(undefined4 **)(&DAT_2000044c + index * 8) = ptr5;\n      *(undefined4 **)(index2 + 0xc) = ptr5;\n    }\n    else {\n      temp1 = temp3 >> 9;\n      if (temp1 < 5) {\n        index = ((temp3 >> 6) + 0x39) * 8;\n        index2 = (temp3 >> 6) + 0x38;\n      }\n      else if (temp1 < 0x15) {\n        index = (temp1 + 0x5c) * 8;\n        index2 = temp1 + 0x5b;\n      }\n      else if (temp1 < 0x55) {\n        index = ((temp3 >> 0xc) + 0x6f) * 8;\n        index2 = (temp3 >> 0xc) + 0x6e;\n      }\n      else if (temp1 < 0x155) {\n        index = ((temp3 >> 0xf) + 0x78) * 8;\n        index2 = (temp3 >> 0xf) + 0x77;\n      }\n      else if (temp1 < 0x555) {\n        index = ((temp3 >> 0x12) + 0x7d) * 8;\n        index2 = (temp3 >> 0x12) + 0x7c;\n      }\n      else {\n        index = 0x3f8;\n        index2 = 0x7e;\n      }\n      ptr4 = *(undefined **)(&DAT_2000044c + index);\n      ptr1 = &DAT_20000444 + index;\n      if (ptr1 == ptr4) {\n        DAT_20000450 = 1 << (index2 >> 2 & 0xffU) | DAT_20000450;\n      }\n      else {\n        do {\n          if ((*(uint *)(ptr4 + 4) & 0xfffffffc) <= temp4) break;\n          ptr4 = *(undefined **)(ptr4 + 8);\n        } while (ptr1 != ptr4);\n        ptr1 = *(undefined **)(ptr4 + 0xc);\n      }\n      temp1 = DAT_20000450;\n      ptr5[2] = ptr4;\n      ptr5[3] = ptr1;\n      *(undefined4 **)(ptr1 + 8) = ptr5;\n      *(undefined4 **)(ptr4 + 0xc) = ptr5;\n    }\n    temp3 = 1 << ((int)temp5 >> 2 & 0xffU);\n    if (temp3 <= temp1) {\nLAB_08008c06:\n      if ((temp3 & temp1) == 0) {\n        temp5 = temp5 & 0xfffffffc;\n        do {\n          temp3 = temp3 << 1;\n          temp5 = temp5 + 4;\n        } while ((temp3 & temp1) == 0);\n      }\n      do {\n        ptr6 = (undefined4 *)(&DAT_2000044c + temp5 * 8);\n        temp1 = temp5;\n        ptr5 = ptr6;\n        do {\n          for (ptr2 = (undefined4 *)ptr5[3]; ptr5 != ptr2;\n              ptr2 = (undefined4 *)ptr2[3]) {\n            temp4 = ptr2[1] & 0xfffffffc;\n            temp2 = temp4 - temp6;\n            if (0xf < (int)temp2) {\n              index2 = ptr2[2];\n              index = ptr2[3];\n              ptr5 = (undefined4 *)(temp6 + (int)ptr2);\n              ptr2[1] = temp6 | 1;\n              *(int *)(index2 + 0xc) = index;\n              *(int *)(index + 8) = index2;\n              DAT_2000045c = ptr5;\n              DAT_20000460 = ptr5;\n              ptr5[2] = &DAT_20000454;\n              ptr5[3] = &DAT_20000454;\n              ptr5[1] = temp2 | 1;\n              *(uint *)((int)ptr2 + temp4) = temp2;\n              initialize_data_structures_080090b4(buffer);\n              return ptr2 + 2;\n            }\n            if (-1 < (int)temp2) {\n              index = ptr2[3];\n              index2 = ptr2[2];\n              *(uint *)((int)ptr2 + temp4 + 4) = *(uint *)((int)ptr2 + temp4 + 4) | 1;\n              *(int *)(index2 + 0xc) = index;\n              *(int *)(index + 8) = index2;\n              initialize_data_structures_080090b4(buffer);\n              return ptr2 + 2;\n            }\n          }\n          temp1 = temp1 + 1;\n          ptr5 = ptr5 + 2;\n        } while ((temp1 & 3) != 0);\n        do {\n          temp4 = temp5 & 3;\n          ptr5 = ptr6 + -2;\n          temp5 = temp5 - 1;\n          if (temp4 == 0) {\n            DAT_20000450 = DAT_20000450 & ~temp3;\n            break;\n          }\n          ptr6 = (undefined4 *)*ptr6;\n        } while (ptr6 == ptr5);\n        temp3 = temp3 * 2;\n        if ((DAT_20000450 <= temp3 && temp3 - DAT_20000450 != 0) || (temp5 = temp1, temp3 == 0))\n        break;\n        for (; (temp3 & DAT_20000450) == 0; temp3 = temp3 << 1) {\n          temp5 = temp5 + 4;\n        }\n      } while( true );\n    }\n  }\n  ptr4 = DAT_20000454;\n  temp5 = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  if ((temp6 <= temp5) && (temp1 = temp5 - temp6, 0xf < (int)temp1)) goto LAB_08008dac;\n  if (DAT_20000854 == (undefined *)0xffffffff) {\n    temp1 = temp6 + DAT_20000a44 + 0x10;\n  }\n  else {\n    temp1 = temp6 + DAT_20000a44 + 0x100f & 0xfffff000;\n  }\n  ptr1 = (undefined *)initialize_and_check_08009744(buffer,temp1);\n  if (ptr1 == (undefined *)0xffffffff) {\nLAB_08008ed8:\n    temp5 = *(uint *)(DAT_20000454 + 4);\n  }\n  else {\n    ptr = ptr4 + temp5;\n    if (ptr < ptr1 || ptr == ptr1) {\n      ptr3 = DAT_20000a14 + temp1;\n      if ((ptr != ptr1) || (((uint)ptr & 0xfff) != 0)) goto LAB_08008d02;\n      DAT_20000a14 = ptr3;\n      *(uint *)(DAT_20000454 + 4) = temp5 + temp1 | 1;\n    }\n    else {\n      if (ptr4 != &DAT_2000044c) goto LAB_08008ed8;\nLAB_08008d02:\n      DAT_20000a14 = DAT_20000a14 + temp1;\n      ptr3 = ptr1;\n      if (DAT_20000854 != (undefined *)0xffffffff) {\n        DAT_20000a14 = DAT_20000a14 + ((int)ptr1 - (int)ptr);\n        ptr3 = DAT_20000854;\n      }\n      DAT_20000854 = ptr3;\n      temp3 = (uint)ptr1 & 7;\n      if (temp3 == 0) {\n        index = 0x1000;\n      }\n      else {\n        ptr1 = ptr1 + (8 - temp3);\n        index = 0x1008 - temp3;\n      }\n      index = index - ((uint)(ptr1 + temp1) & 0xfff);\n      index2 = initialize_and_check_08009744(buffer,index);\n      if (index2 == -1) {\n        temp1 = 1;\n        index = 0;\n      }\n      else {\n        temp1 = (index2 - (int)ptr1) + index | 1;\n      }\n      ptr3 = DAT_20000a14 + index;\n      DAT_20000454 = ptr1;\n      DAT_20000a14 = ptr3;\n      *(uint *)(ptr1 + 4) = temp1;\n      if (ptr4 != &DAT_2000044c) {\n        if (temp5 < 0x10) {\n          *(undefined4 *)(ptr1 + 4) = 1;\n          goto LAB_08008eee;\n        }\n        temp5 = temp5 - 0xc & 0xfffffff8;\n        *(uint *)(ptr4 + 4) = *(uint *)(ptr4 + 4) & 1 | temp5;\n        *(undefined4 *)(ptr4 + temp5 + 4) = 5;\n        *(undefined4 *)(ptr4 + temp5 + 8) = 5;\n        if (0xf < temp5) {\n          initialize_memory_management_080088ec(buffer,ptr4 + 8);\n          ptr3 = DAT_20000a14;\n        }\n      }\n    }\n    if (DAT_20000a3c < ptr3) {\n      DAT_20000a3c = ptr3;\n    }\n    temp5 = *(uint *)(DAT_20000454 + 4);\n    if (DAT_20000a40 < ptr3) {\n      DAT_20000a40 = ptr3;\n    }\n  }\n  temp1 = (temp5 & 0xfffffffc) - temp6;\n  if ((temp6 <= (temp5 & 0xfffffffc)) && (0xf < (int)temp1)) {\nLAB_08008dac:\n    ptr4 = DAT_20000454 + temp6;\n    *(uint *)(DAT_20000454 + 4) = temp6 | 1;\n    result = (int *)(DAT_20000454 + 8);\n    DAT_20000454 = ptr4;\n    *(uint *)(ptr4 + 4) = temp1 | 1;\n    initialize_data_structures_080090b4(buffer);\n    return result;\n  }\nLAB_08008eee:\n  initialize_data_structures_080090b4(buffer);\n  return (int *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08008af8": "allocate_memory_08008af8",
                "param_1": "buffer",
                "param_2": "size",
                "puVar1": "ptr",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "iVar4": "index",
                "puVar5": "ptr1",
                "uVar6": "temp3",
                "uVar7": "temp4",
                "puVar8": "ptr2",
                "puVar9": "ptr3",
                "puVar10": "ptr4",
                "piVar11": "result",
                "uVar12": "temp5",
                "uVar13": "temp6",
                "iVar14": "index2",
                "puVar15": "ptr5",
                "puVar16": "ptr6"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_08009adc",
                "FUN_080097cc",
                "FUN_08009980"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_08009744",
                "FUN_080090b4",
                "FUN_080088ec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800901c": {
            "entrypoint": "0x0800901c",
            "current_name": "find_first_match_0800901c",
            "code": "\nuint * find_first_match_0800901c(uint *input_array,uint search_value,uint array_length)\n\n{\n  uint xor_result;\n  uint concatenated_value;\n  uint *current_pointer;\n  uint search_byte;\n  bool is_array_empty;\n  \n  search_byte = search_value & 0xff;\n  if (((uint)input_array & 3) == 0) {\nLAB_0800904a:\n    if (3 < array_length) {\n      concatenated_value = (search_value & 0xff) << 8 | search_byte;\n      current_pointer = input_array;\n      do {\n        xor_result = *current_pointer ^ (concatenated_value | concatenated_value << 0x10);\n        input_array = current_pointer + 1;\n        if ((xor_result + 0xfefefeff & ~xor_result & 0x80808080) != 0) goto LAB_08009050;\n        array_length = array_length - 4;\n        current_pointer = input_array;\n      } while (3 < array_length);\n    }\n    current_pointer = input_array;\n    if (array_length == 0) {\n      input_array = (uint *)0x0;\n    }\n    else {\nLAB_08009050:\n      input_array = current_pointer;\n      if (*(byte *)input_array != search_byte) {\n        current_pointer = (uint *)(array_length + (int)input_array);\n        do {\n          input_array = (uint *)((int)input_array + 1);\n          if (current_pointer == input_array) goto LAB_0800906c;\n        } while (*(byte *)input_array != search_byte);\n      }\n    }\n  }\n  else {\n    concatenated_value = array_length - 1;\n    if (array_length == 0) {\nLAB_0800906c:\n      input_array = (uint *)0x0;\n    }\n    else if (*(byte *)input_array != search_byte) {\n      current_pointer = (uint *)((int)input_array + 1);\n      do {\n        input_array = current_pointer;\n        array_length = concatenated_value;\n        if (((uint)input_array & 3) == 0) goto LAB_0800904a;\n        is_array_empty = concatenated_value == 0;\n        concatenated_value = concatenated_value - 1;\n        if (is_array_empty) goto LAB_0800906c;\n        current_pointer = (uint *)((int)input_array + 1);\n      } while (*(byte *)input_array != search_byte);\n    }\n  }\n  return input_array;\n}\n\n",
            "renaming": {
                "FUN_0800901c": "find_first_match_0800901c",
                "param_1": "input_array",
                "param_2": "search_value",
                "param_3": "array_length",
                "uVar1": "xor_result",
                "uVar2": "concatenated_value",
                "puVar3": "current_pointer",
                "uVar4": "search_byte",
                "bVar5": "is_array_empty"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090a8": {
            "entrypoint": "0x080090a8",
            "current_name": "initialize_data_080090a8",
            "code": "\nvoid initializeData_080090a8(void)\n\n{\n  FUNC_08008af0(&DAT_20000bfc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090a8": "initialize_data_080090a8"
            },
            "calling": [
                "FUN_08009adc",
                "FUN_080088ec",
                "FUN_0800884c",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_08008af0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090b4": {
            "entrypoint": "0x080090b4",
            "current_name": "initialize_data_structures_080090b4",
            "code": "\nvoid initializeDataStructures_080090b4(void)\n\n{\n  FUNC_08008af4(&DAT_20000bfc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090b4": "initialize_data_structures_080090b4"
            },
            "calling": [
                "FUN_08009adc",
                "FUN_080088ec",
                "FUN_0800884c",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_08008af4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090c0": {
            "entrypoint": "0x080090c0",
            "current_name": "allocate_and_initialize_array_080090c0",
            "code": "\nundefined4 * allocateAndInitializeArray_080090c0(int arrayAddress,uint index)\n\n{\n  undefined4 *arrayPointer;\n  int arrayOffset;\n  \n  arrayOffset = *(int *)(arrayAddress + 0x4c);\n  if (arrayOffset == 0) {\n    arrayOffset = allocate_and_initialize_array_08009980(arrayAddress,4,0x21);\n    *(int *)(arrayAddress + 0x4c) = arrayOffset;\n    if (arrayOffset == 0) {\n      return (undefined4 *)0x0;\n    }\n  }\n  arrayPointer = *(undefined4 **)(arrayOffset + index * 4);\n  if (arrayPointer == (undefined4 *)0x0) {\n    arrayOffset = 1 << (index & 0xff);\n    arrayPointer = (undefined4 *)allocate_and_initialize_array_08009980(arrayAddress,1,(arrayOffset + 5) * 4);\n    if (arrayPointer == (undefined4 *)0x0) {\n      return (undefined4 *)0x0;\n    }\n    arrayPointer[1] = index;\n    arrayPointer[2] = arrayOffset;\n  }\n  else {\n    *(undefined4 *)(arrayOffset + index * 4) = *arrayPointer;\n  }\n  arrayPointer[3] = 0;\n  arrayPointer[4] = 0;\n  return arrayPointer;\n}\n\n",
            "renaming": {
                "FUN_080090c0": "allocate_and_initialize_array_080090c0",
                "param_1": "arrayAddress",
                "param_2": "index",
                "puVar1": "arrayPointer",
                "iVar2": "arrayOffset"
            },
            "calling": [
                "FUN_08009244",
                "FUN_08009530",
                "FUN_08009630",
                "FUN_08009120",
                "FUN_080093a4",
                "FUN_08009258",
                "FUN_08009444",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08009980"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800910c": {
            "entrypoint": "0x0800910c",
            "current_name": "update_pointer_0800910c",
            "code": "\nvoid updatePointer_0800910c(int baseAddress,undefined4 *pointerToUpdate)\n\n{\n  int offset;\n  \n  if (pointerToUpdate != (undefined4 *)0x0) {\n    offset = *(int *)(baseAddress + 0x4c);\n    *pointerToUpdate = *(undefined4 *)(offset + pointerToUpdate[1] * 4);\n    *(undefined4 **)(offset + pointerToUpdate[1] * 4) = pointerToUpdate;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800910c": "update_pointer_0800910c",
                "param_1": "baseAddress",
                "param_2": "pointerToUpdate",
                "iVar1": "offset"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009120": {
            "entrypoint": "0x08009120",
            "current_name": "calculate_checksum_08009120",
            "code": "\nundefined4 * calculateChecksum_08009120(int size,undefined4 *data,int multiplier,uint checksum)\n\n{\n  undefined4 *result;\n  uint temp;\n  int numElements;\n  uint *currentElement;\n  int iterationCount;\n  \n  iterationCount = 0;\n  numElements = data[4];\n  currentElement = data + 5;\n  do {\n    iterationCount = iterationCount + 1;\n    checksum = multiplier * (*currentElement & 0xffff) + checksum;\n    temp = multiplier * (*currentElement >> 0x10) + (checksum >> 0x10);\n    *currentElement = (checksum & 0xffff) + temp * 0x10000;\n    checksum = temp >> 0x10;\n    currentElement = currentElement + 1;\n  } while (iterationCount < numElements);\n  result = data;\n  if (checksum != 0) {\n    if ((int)data[2] <= numElements) {\n      result = (undefined4 *)allocate_and_initialize_array_080090c0(size,data[1] + 1);\n      copy_memory_08001084(result + 3,data + 3,(data[4] + 2) * 4);\n      iterationCount = *(int *)(size + 0x4c);\n      *data = *(undefined4 *)(iterationCount + data[1] * 4);\n      *(undefined4 **)(iterationCount + data[1] * 4) = data;\n    }\n    result[numElements + 5] = checksum;\n    result[4] = numElements + 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009120": "calculate_checksum_08009120",
                "param_1": "size",
                "param_2": "data",
                "param_3": "multiplier",
                "param_4": "checksum",
                "puVar1": "result",
                "uVar2": "temp",
                "iVar3": "numElements",
                "puVar4": "currentElement",
                "iVar5": "iterationCount"
            },
            "calling": [
                "FUN_080093a4",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08001084",
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091a4": {
            "entrypoint": "0x080091a4",
            "current_name": "find_most_significant_bit_080091a4",
            "code": "\nint find_most_significant_bit_080091a4(uint number)\n\n{\n  int bit_position;\n  \n  if ((number & 0xffff0000) == 0) {\n    number = number << 0x10;\n    bit_position = 0x10;\n  }\n  else {\n    bit_position = 0;\n  }\n  if ((number & 0xff000000) == 0) {\n    number = number << 8;\n    bit_position = bit_position + 8;\n  }\n  if ((number & 0xf0000000) == 0) {\n    number = number << 4;\n    bit_position = bit_position + 4;\n  }\n  if ((number & 0xc0000000) == 0) {\n    number = number << 2;\n    bit_position = bit_position + 2;\n  }\n  if (-1 < (int)number) {\n    if ((int)(number << 1) < 0) {\n      return bit_position + 1;\n    }\n    bit_position = 0x20;\n  }\n  return bit_position;\n}\n\n",
            "renaming": {
                "FUN_080091a4": "find_most_significant_bit_080091a4",
                "param_1": "number",
                "iVar1": "bit_position"
            },
            "calling": [
                "FUN_08009630",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091e4": {
            "entrypoint": "0x080091e4",
            "current_name": "count_trailing_zeros_080091e4",
            "code": "\nint countTrailingZeros_080091e4(uint *number)\n\n{\n  int trailingZeros;\n  uint temp;\n  \n  temp = *number;\n  if ((temp & 7) == 0) {\n    if ((temp & 0xffff) == 0) {\n      temp = temp >> 0x10;\n      trailingZeros = 0x10;\n    }\n    else {\n      trailingZeros = 0;\n    }\n    if ((temp & 0xff) == 0) {\n      temp = temp >> 8;\n      trailingZeros = trailingZeros + 8;\n    }\n    if ((temp & 0xf) == 0) {\n      temp = temp >> 4;\n      trailingZeros = trailingZeros + 4;\n    }\n    if ((temp & 3) == 0) {\n      temp = temp >> 2;\n      trailingZeros = trailingZeros + 2;\n    }\n    if (-1 < (int)(temp << 0x1f)) {\n      temp = temp >> 1;\n      if (temp == 0) {\n        return 0x20;\n      }\n      trailingZeros = trailingZeros + 1;\n    }\n    *number = temp;\n    return trailingZeros;\n  }\n  if ((int)(temp << 0x1f) < 0) {\n    return 0;\n  }\n  if (-1 < (int)(temp << 0x1e)) {\n    *number = temp >> 2;\n    return 2;\n  }\n  *number = temp >> 1;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080091e4": "count_trailing_zeros_080091e4",
                "param_1": "number",
                "iVar1": "trailingZeros",
                "uVar2": "temp"
            },
            "calling": [
                "FUN_08009630"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009244": {
            "entrypoint": "0x08009244",
            "current_name": "initialize_array_08009244",
            "code": "\nvoid initializeArray_08009244(undefined4 source,undefined4 value)\n\n{\n  int arrayPtr;\n  \n  arrayPtr = allocate_and_initialize_array_080090c0(source,1);\n  *(undefined4 *)(arrayPtr + 0x10) = 1;\n  *(undefined4 *)(arrayPtr + 0x14) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009244": "initialize_array_08009244",
                "param_1": "source",
                "param_2": "value",
                "iVar1": "arrayPtr"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009258": {
            "entrypoint": "0x08009258",
            "current_name": "initialize_and_compute_08009258",
            "code": "\nvoid initializeAndCompute_08009258(undefined4 input,int arraySize1,int arraySize2)\n\n{\n  uint *ptr1;\n  uint *ptr2;\n  int numIterations;\n  uint tempVar1;\n  uint *array1;\n  uint tempVar2;\n  uint *ptr3;\n  uint tempVar3;\n  int size1;\n  int size2;\n  uint tempVar4;\n  int var1;\n  int var2;\n  uint *array2;\n  uint *tempArray;\n  uint *ptr4;\n  uint *ptr5;\n  uint *ptr6;\n  \n  var1 = *(int *)(arraySize1 + 0x10);\n  size1 = *(int *)(arraySize2 + 0x10);\n  size2 = size1;\n  var2 = arraySize1;\n  if (var1 < size1) {\n    size2 = var1;\n    var1 = size1;\n    var2 = arraySize2;\n    arraySize2 = arraySize1;\n  }\n  size1 = var1 + size2;\n  numIterations = *(int *)(var2 + 4);\n  if (*(int *)(var2 + 8) < size1) {\n    numIterations = numIterations + 1;\n  }\n  numIterations = allocate_and_initialize_array_080090c0(input,numIterations);\n  ptr6 = (uint *)(numIterations + 0x14);\n  ptr5 = ptr6 + size1;\n  for (array1 = ptr6; array1 < ptr5; array1 = array1 + 1) {\n    *array1 = 0;\n  }\n  tempVar2 = arraySize2 + 0x14;\n  tempVar4 = tempVar2 + size2 * 4;\n  array1 = (uint *)(var2 + 0x14);\n  if (tempVar2 < tempVar4) {\n    ptr3 = (uint *)(tempVar2 + ((tempVar4 - arraySize2) - 0x15 & 0xfffffffc));\n    ptr4 = (uint *)(arraySize2 + 0x10);\n    do {\n      while( true ) {\n        ptr4 = ptr4 + 1;\n        tempVar2 = *ptr4 & 0xffff;\n        if (tempVar2 != 0) break;\n        tempVar2 = *ptr4 >> 0x10;\n        if (tempVar2 == 0) goto LAB_080092d2;\nLAB_0800932c:\n        tempVar3 = *ptr6;\n        tempVar1 = 0;\n        ptr1 = array1;\n        array2 = ptr6;\n        tempVar4 = tempVar3;\n        do {\n          tempArray = array2;\n          tempVar1 = tempVar1 + tempVar2 * *(ushort *)ptr1 + (tempVar4 >> 0x10);\n          *tempArray = tempVar3 & 0xffff | tempVar1 * 0x10000;\n          ptr2 = ptr1 + 1;\n          tempVar4 = tempArray[1];\n          tempVar3 = tempVar2 * (*ptr1 >> 0x10) + (tempVar4 & 0xffff) + (tempVar1 >> 0x10);\n          tempVar1 = tempVar3 >> 0x10;\n          ptr1 = ptr2;\n          array2 = tempArray + 1;\n        } while (ptr2 < array1 + var1);\n        tempArray[1] = tempVar3;\n        ptr6 = ptr6 + 1;\n        if (ptr3 == ptr4) goto LAB_0800937a;\n      }\n      tempVar4 = 0;\n      ptr1 = ptr6;\n      array2 = array1;\n      do {\n        ptr2 = ptr1;\n        tempArray = array2 + 1;\n        tempVar3 = tempVar2 * (*array2 & 0xffff) + (*ptr2 & 0xffff) + tempVar4;\n        tempVar1 = tempVar2 * (*array2 >> 0x10) + (*ptr2 >> 0x10) + (tempVar3 >> 0x10);\n        tempVar4 = tempVar1 >> 0x10;\n        *ptr2 = tempVar3 & 0xffff | tempVar1 * 0x10000;\n        ptr1 = ptr2 + 1;\n        array2 = tempArray;\n      } while (tempArray < array1 + var1);\n      ptr2[1] = tempVar4;\n      tempVar2 = *ptr4 >> 0x10;\n      if (tempVar2 != 0) goto LAB_0800932c;\nLAB_080092d2:\n      ptr6 = ptr6 + 1;\n    } while (ptr3 != ptr4);\n  }\nLAB_0800937a:\n  if (0 < size1) {\n    tempVar2 = ptr5[-1];\n    ptr5 = ptr5 + -1;\n    while ((tempVar2 == 0 && (size1 = size1 + -1, size1 != 0))) {\n      ptr5 = ptr5 + -1;\n      tempVar2 = *ptr5;\n    }\n  }\n  *(int *)(numIterations + 0x10) = size1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009258": "initialize_and_compute_08009258",
                "param_1": "input",
                "param_2": "arraySize1",
                "param_3": "arraySize2",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "iVar3": "numIterations",
                "uVar4": "tempVar1",
                "puVar5": "array1",
                "uVar6": "tempVar2",
                "puVar7": "ptr3",
                "uVar8": "tempVar3",
                "iVar9": "size1",
                "iVar10": "size2",
                "uVar11": "tempVar4",
                "iVar12": "var1",
                "iVar13": "var2",
                "puVar14": "array2",
                "puVar15": "tempArray",
                "puVar16": "ptr4",
                "puVar17": "ptr5",
                "puVar18": "ptr6"
            },
            "calling": [
                "FUN_080093a4",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080093a4": {
            "entrypoint": "0x080093a4",
            "current_name": "calculate_checksum_080093a4",
            "code": "\nundefined4 * calculate_checksum_080093a4(int array_address,undefined4 *array,uint array_length)\n\n{\n  int index;\n  int num_iterations;\n  undefined4 *current_element;\n  undefined4 *array_ptr;\n  \n  if ((array_length & 3) != 0) {\n    array = (undefined4 *)\n              calculate_checksum_080093a4_08009120(array_address,array,*(undefined4 *)(&DAT_0800a070 + ((array_length & 3) - 1) * 4),\n                           0);\n  }\n  num_iterations = (int)array_length >> 2;\n  if (num_iterations != 0) {\n    array_ptr = *(undefined4 **)(array_address + 0x48);\n    if (array_ptr == (undefined4 *)0x0) {\n      array_ptr = (undefined4 *)allocate_and_initialize_array_080090c0(array_address,1);\n      array_ptr[4] = 1;\n      array_ptr[5] = 0x271;\n      *(undefined4 **)(array_address + 0x48) = array_ptr;\n      *array_ptr = 0;\n    }\n    current_element = array;\n    if (num_iterations << 0x1f < 0) goto LAB_080093d2;\nLAB_080093c4:\n    num_iterations = num_iterations >> 1;\n    current_element = array_ptr;\n    if (num_iterations != 0) {\n      while( true ) {\n        array_ptr = (undefined4 *)*current_element;\n        if (array_ptr == (undefined4 *)0x0) {\n          array_ptr = (undefined4 *)initialize_and_compute_08009258(array_address,current_element,current_element);\n          *current_element = array_ptr;\n          *array_ptr = 0;\n        }\n        current_element = array;\n        if (-1 < num_iterations << 0x1f) break;\nLAB_080093d2:\n        array = (undefined4 *)initialize_and_compute_08009258(array_address,current_element,array_ptr);\n        if (current_element == (undefined4 *)0x0) break;\n        index = *(int *)(array_address + 0x4c);\n        num_iterations = num_iterations >> 1;\n        *current_element = *(undefined4 *)(index + current_element[1] * 4);\n        *(undefined4 **)(index + current_element[1] * 4) = current_element;\n        current_element = array_ptr;\n        if (num_iterations == 0) {\n          return array;\n        }\n      }\n      goto LAB_080093c4;\n    }\n  }\n  return array;\n}\n\n",
            "renaming": {
                "FUN_080093a4": "calculate_checksum_080093a4",
                "param_1": "array_address",
                "param_2": "array",
                "param_3": "array_length",
                "iVar1": "index",
                "iVar2": "num_iterations",
                "puVar3": "current_element",
                "puVar4": "array_ptr"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08009120",
                "FUN_08009258",
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009444": {
            "entrypoint": "0x08009444",
            "current_name": "initialize_and_copy_array_08009444",
            "code": "\nvoid initializeAndCopyArray_08009444(int array,undefined4 *params,uint size)\n\n{\n  int tempVar1;\n  int tempVar2;\n  int tempVar3;\n  undefined4 tempVar4;\n  int indexVar1;\n  int indexVar2;\n  uint *destPtr;\n  uint *srcPtr;\n  uint *tempPtr2;\n  uint *endPtr2;\n  int shiftCount;\n  int newSize;\n  uint carry;\n  uint *tempPtr1;\n  \n  indexVar1 = params[4];\n  shiftCount = (int)size >> 5;\n  newSize = shiftCount + indexVar1 + 1;\n  tempVar3 = params[1];\n  tempVar2 = params[2];\n  if ((int)params[2] < newSize) {\n    do {\n      indexVar2 = tempVar2 * 2;\n      tempVar1 = tempVar2 * -2;\n      tempVar3 = tempVar3 + 1;\n      tempVar2 = indexVar2;\n    } while (newSize != indexVar2 && newSize + tempVar1 < 0 == SBORROW4(newSize,indexVar2));\n  }\n  tempVar2 = allocate_and_initialize_array_080090c0(array,tempVar3);\n  destPtr = (uint *)(tempVar2 + 0x14);\n  if (0 < shiftCount) {\n    endPtr2 = destPtr + shiftCount;\n    srcPtr = destPtr;\n    do {\n      tempPtr1 = srcPtr + 1;\n      *srcPtr = 0;\n      destPtr = endPtr2;\n      srcPtr = tempPtr1;\n    } while (tempPtr1 != endPtr2);\n  }\n  tempVar3 = params[4];\n  srcPtr = params + 5;\n  size = size & 0x1f;\n  if (size == 0) {\n    destPtr = destPtr + -1;\n    endPtr2 = srcPtr;\n    do {\n      tempPtr1 = endPtr2 + 1;\n      destPtr = destPtr + 1;\n      *destPtr = *endPtr2;\n      endPtr2 = tempPtr1;\n    } while (tempPtr1 < srcPtr + tempVar3);\n  }\n  else {\n    carry = 0;\n    endPtr2 = srcPtr;\n    do {\n      tempPtr1 = destPtr;\n      *tempPtr1 = *endPtr2 << size | carry;\n      tempPtr2 = endPtr2 + 1;\n      carry = *endPtr2 >> (0x20 - size & 0xff);\n      destPtr = tempPtr1 + 1;\n      endPtr2 = tempPtr2;\n    } while (tempPtr2 < srcPtr + tempVar3);\n    tempPtr1[1] = carry;\n    if (carry != 0) {\n      newSize = shiftCount + indexVar1 + 2;\n    }\n  }\n  indexVar1 = *(int *)(array + 0x4c);\n  tempVar3 = params[1];\n  tempVar4 = *(undefined4 *)(indexVar1 + tempVar3 * 4);\n  *(int *)(tempVar2 + 0x10) = newSize + -1;\n  *params = tempVar4;\n  *(undefined4 **)(indexVar1 + tempVar3 * 4) = params;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009444": "initialize_and_copy_array_08009444",
                "param_1": "array",
                "param_2": "params",
                "param_3": "size",
                "iVar1": "tempVar1",
                "iVar2": "tempVar2",
                "iVar3": "tempVar3",
                "uVar4": "tempVar4",
                "iVar5": "indexVar1",
                "iVar6": "indexVar2",
                "puVar7": "destPtr",
                "puVar8": "srcPtr",
                "puVar9": "tempPtr1",
                "puVar10": "tempPtr2",
                "puVar11": "endPtr2",
                "iVar12": "shiftCount",
                "iVar13": "newSize",
                "uVar14": "carry"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080094f8": {
            "entrypoint": "0x080094f8",
            "current_name": "compare_arrays_080094f8",
            "code": "\nint compareArrays_080094f8(int array1,int array2)\n\n{\n  int diffSize;\n  uint *currentElement2;\n  int array2Size;\n  uint *currentElement1;\n  \n  array2Size = *(int *)(array2 + 0x10);\n  diffSize = *(int *)(array1 + 0x10) - array2Size;\n  if (diffSize == 0) {\n    currentElement2 = (uint *)(array2 + 0x14 + array2Size * 4);\n    currentElement1 = (uint *)(array1 + 0x14) + array2Size;\n    do {\n      currentElement1 = currentElement1 + -1;\n      currentElement2 = currentElement2 + -1;\n      if (*currentElement1 != *currentElement2) {\n        if (*currentElement2 <= *currentElement1) {\n          return 1;\n        }\n        return -1;\n      }\n    } while ((uint *)(array1 + 0x14) < currentElement1);\n  }\n  return diffSize;\n}\n\n",
            "renaming": {
                "FUN_080094f8": "compare_arrays_080094f8",
                "param_1": "array1",
                "param_2": "array2",
                "iVar1": "diffSize",
                "iVar3": "array2Size",
                "puVar2": "currentElement2",
                "puVar4": "currentElement1"
            },
            "calling": [
                "FUN_080078c0",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009530": {
            "entrypoint": "0x08009530",
            "current_name": "compare_and_allocate_08009530",
            "code": "\nvoid compareAndAllocate_08009530(undefined4 input_size,uint *array_1,uint *array_2,undefined4 unknown_param)\n\n{\n  int result;\n  uint *array_2_field4;\n  uint array_1_field4;\n  uint value;\n  undefined4 isAllocated;\n  uint *result_field14;\n  uint *current_array1;\n  uint *current_array2;\n  uint *temp_ptr2;\n  uint *array1_field5;\n  int carry;\n  uint *array2_field5;\n  uint array1_field4;\n  uint *temp_ptr;\n  \n  array_2_field4 = (uint *)array_2[4];\n  array1_field5 = array_1 + 5;\n  array2_field5 = array_2 + 5;\n  current_array1 = array1_field5;\n  current_array2 = array_1;\n  if ((uint *)array_1[4] == array_2_field4) {\n    result_field14 = array1_field5 + (int)array_2_field4;\n    array_2_field4 = array2_field5 + (int)array_2_field4;\n    while( true ) {\n      result_field14 = result_field14 + -1;\n      array_2_field4 = array_2_field4 + -1;\n      if (*result_field14 != *array_2_field4) break;\n      if (result_field14 <= array1_field5) {\n        carry = allocate_and_initialize_array_080090c0(input_size,0,result_field14,array_2_field4,unknown_param);\n        *(undefined4 *)(carry + 0x10) = 1;\n        *(undefined4 *)(carry + 0x14) = 0;\n        return;\n      }\n    }\n    isAllocated = 0;\n    if (*array_2_field4 <= *result_field14) goto LAB_08009578;\n  }\n  else if (-1 < (int)(uint *)array_1[4] - (int)array_2_field4) {\n    isAllocated = 0;\n    result_field14 = array_2;\n    goto LAB_08009578;\n  }\n  isAllocated = 1;\n  result_field14 = array1_field5;\n  array_2_field4 = array_1;\n  current_array1 = array2_field5;\n  current_array2 = array_2;\n  array_2 = array_1;\n  array2_field5 = array1_field5;\nLAB_08009578:\n  result = allocate_and_initialize_array_080090c0(input_size,current_array2[1],result_field14,array_2_field4,unknown_param);\n  carry = 0;\n  array1_field4 = current_array2[4];\n  array_1_field4 = array_2[4];\n  *(undefined4 *)(result + 0xc) = isAllocated;\n  array1_field5 = current_array1 + array1_field4;\n  array_2_field4 = (uint *)(result + 0x14);\n  current_array2 = array2_field5;\n  do {\n    temp_ptr = current_array1 + 1;\n    temp_ptr2 = current_array2 + 1;\n    value = ((*current_array1 & 0xffff) + carry) - (*current_array2 & 0xffff);\n    carry = ((*current_array1 >> 0x10) - (*current_array2 >> 0x10)) + ((int)value >> 0x10);\n    value = value & 0xffff | carry * 0x10000;\n    result_field14 = array_2_field4 + 1;\n    *array_2_field4 = value;\n    carry = carry >> 0x10;\n    array_2_field4 = result_field14;\n    current_array1 = temp_ptr;\n    current_array2 = temp_ptr2;\n  } while (temp_ptr2 < array2_field5 + array_1_field4);\n  array_2_field4 = temp_ptr;\n  current_array1 = result_field14;\n  if (temp_ptr < array1_field5) {\n    do {\n      current_array2 = array_2_field4 + 1;\n      array_1_field4 = (*array_2_field4 & 0xffff) + carry;\n      carry = ((int)array_1_field4 >> 0x10) + (*array_2_field4 >> 0x10);\n      value = array_1_field4 & 0xffff | carry * 0x10000;\n      *current_array1 = value;\n      carry = carry >> 0x10;\n      array_2_field4 = current_array2;\n      current_array1 = current_array1 + 1;\n    } while (current_array2 < array1_field5);\n    result_field14 = (uint *)((int)result_field14 + ((int)array1_field5 + ~(uint)temp_ptr & 0xfffffffc) + 4);\n  }\n  result_field14 = result_field14 + -1;\n  while (value == 0) {\n    result_field14 = result_field14 + -1;\n    array1_field4 = array1_field4 - 1;\n    value = *result_field14;\n  }\n  *(uint *)(result + 0x10) = array1_field4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009530": "compare_and_allocate_08009530",
                "param_1": "input_size",
                "param_2": "array_1",
                "param_3": "array_2",
                "param_4": "unknown_param",
                "iVar1": "result",
                "puVar2": "array_2_field4",
                "uVar3": "array_1_field4",
                "uVar4": "value",
                "uVar5": "isAllocated",
                "puVar6": "result_field14",
                "puVar7": "current_array1",
                "puVar8": "temp_ptr",
                "puVar9": "current_array2",
                "puVar10": "temp_ptr2",
                "puVar11": "array1_field5",
                "iVar12": "carry",
                "puVar13": "array2_field5",
                "uVar14": "array1_field4"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009630": {
            "entrypoint": "0x08009630",
            "current_name": "decode_and_count_bits_08009630",
            "code": "\nint decode_and_count_bits_08009630(undefined4 input_1,undefined4 input_2,uint param_3,uint param_4,int *output_1,\n                int *output_2)\n\n{\n  int array_ptr;\n  uint trailing_zeroes;\n  int count;\n  int type;\n  uint shifted_bits;\n  uint shift_amount;\n  undefined8 msb;\n  uint temp_1;\n  uint temp_2;\n  \n  array_ptr = allocate_and_initialize_array_080090c0(input_1,1);\n  shift_amount = (param_4 << 1) >> 0x15;\n  temp_2 = param_4 & 0xfffff;\n  if (shift_amount != 0) {\n    temp_2 = temp_2 | 0x100000;\n  }\n  if (param_3 == 0) {\n    count = count_trailing_zeros_080091e4(&temp_2);\n    type = 1;\n    trailing_zeroes = count + 0x20;\n    *(undefined4 *)(array_ptr + 0x10) = 1;\n    *(uint *)(array_ptr + 0x14) = temp_2;\n  }\n  else {\n    temp_1 = param_3;\n    trailing_zeroes = count_trailing_zeros_080091e4(&temp_1);\n    if (trailing_zeroes == 0) {\n      *(uint *)(array_ptr + 0x14) = temp_1;\n    }\n    else {\n      shifted_bits = temp_2 << (0x20 - trailing_zeroes & 0xff);\n      temp_2 = temp_2 >> (trailing_zeroes & 0xff);\n      *(uint *)(array_ptr + 0x14) = shifted_bits | temp_1;\n    }\n    if (temp_2 == 0) {\n      type = 1;\n    }\n    else {\n      type = 2;\n    }\n    *(uint *)(array_ptr + 0x18) = temp_2;\n    *(int *)(array_ptr + 0x10) = type;\n  }\n  if (shift_amount == 0) {\n    *output_1 = trailing_zeroes - 0x432;\n    msb = find_most_significant_bit_080091a4(*(undefined4 *)(array_ptr + type * 4 + 0x10));\n    *output_2 = (int)((ulonglong)msb >> 0x20) * 0x20 - (int)msb;\n    return array_ptr;\n  }\n  *output_1 = (shift_amount - 0x433) + trailing_zeroes;\n  *output_2 = 0x35 - trailing_zeroes;\n  return array_ptr;\n}\n\n",
            "renaming": {
                "FUN_08009630": "decode_and_count_bits_08009630",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_5": "output_1",
                "param_6": "output_2",
                "iVar1": "array_ptr",
                "uVar2": "trailing_zeroes",
                "iVar3": "count",
                "iVar4": "type",
                "uVar5": "shifted_bits",
                "uVar6": "shift_amount",
                "uVar7": "msb",
                "local_20": "temp_1",
                "local_1c": "temp_2"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080091e4",
                "FUN_080091a4",
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080096e0": {
            "entrypoint": "0x080096e0",
            "current_name": "calculate_float_difference_080096e0",
            "code": "\nundefined8 calculate_float_difference_080096e0(uint input_float_1,uint input_float_2,int *output_integer_ptr,undefined4 constant_value)\n\n{\n  int loop_count;\n  uint input_float_2_absolute;\n  undefined8 combined_float_value;\n  \n  combined_float_value = CONCAT44(input_float_2,input_float_1);\n  loop_count = 0;\n  input_float_2_absolute = input_float_2 & 0x7fffffff;\n  *output_integer_ptr = 0;\n  if ((input_float_2_absolute < 0x7ff00000) && ((input_float_2_absolute | input_float_1) != 0)) {\n    if (input_float_2_absolute < 0x100000) {\n      combined_float_value = calculate_bitwise_difference_080004c8(input_float_1,input_float_2,0,0x43500000,constant_value);\n      loop_count = -0x36;\n      input_float_2_absolute = (uint)((ulonglong)combined_float_value >> 0x20) & 0x7fffffff;\n    }\n    input_float_1 = (uint)combined_float_value;\n    input_float_2 = (uint)((ulonglong)combined_float_value >> 0x20) & 0x800fffff | 0x3fe00000;\n    *output_integer_ptr = ((int)input_float_2_absolute >> 0x14) + -0x3fe + loop_count;\n  }\n  return CONCAT44(input_float_2,input_float_1);\n}\n\n",
            "renaming": {
                "FUN_080096e0": "calculate_float_difference_080096e0",
                "param_1": "input_float_1",
                "param_2": "input_float_2",
                "param_3": "output_integer_ptr",
                "param_4": "constant_value",
                "iVar1": "loop_count",
                "uVar2": "input_float_2_absolute",
                "uVar3": "combined_float_value"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_080004c8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009744": {
            "entrypoint": "0x08009744",
            "current_name": "initialize_and_check_08009744",
            "code": "\nvoid initialize_and_check_08009744(int *result,undefined4 value)\n\n{\n  int initResult;\n  \n  DAT_20000c10 = 0;\n  initResult = initialize_data_08005728(value);\n  if ((initResult == -1) && (DAT_20000c10 != 0)) {\n    *result = DAT_20000c10;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009744": "initialize_and_check_08009744",
                "param_1": "result",
                "param_2": "value",
                "iVar1": "initResult"
            },
            "calling": [
                "FUN_0800884c",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_08005728"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009768": {
            "entrypoint": "0x08009768",
            "current_name": "copy_safe_string_08009768",
            "code": "\nvoid copySafeString_08009768(uint *destination,uint *source,uint size)\n\n{\n  char currentChar;\n  uint *curSource;\n  uint *curDest;\n  uint currentWord;\n  \n  if (((((uint)destination | (uint)source) & 3) == 0) &&\n     (curDest = destination, curSource = source, 3 < size)) {\n    do {\n      source = curSource + 1;\n      currentWord = *curSource;\n      destination = curDest;\n      if ((currentWord + 0xfefefeff & ~currentWord & 0x80808080) != 0) goto LAB_0800979c;\n      size = size - 4;\n      destination = curDest + 1;\n      *curDest = currentWord;\n      curDest = destination;\n      curSource = source;\n    } while (3 < size);\n  }\n  curSource = source;\n  if (size != 0) {\nLAB_0800979c:\n    currentChar = *(char *)curSource;\n    *(char *)destination = currentChar;\n    while( true ) {\n      destination = (uint *)((int)destination + 1);\n      size = size - 1;\n      if (currentChar == '\\0') break;\n      if (size == 0) {\n        return;\n      }\n      curSource = (uint *)((int)curSource + 1);\n      currentChar = *(char *)curSource;\n      *(char *)destination = currentChar;\n    }\n    if (size != 0) {\n      curSource = destination;\n      do {\n        curDest = (uint *)((int)curSource + 1);\n        *(char *)curSource = '\\0';\n        curSource = curDest;\n      } while (curDest != (uint *)(size + (int)destination));\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009768": "copy_safe_string_08009768",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "size",
                "cVar1": "currentChar",
                "puVar2": "curSource",
                "puVar3": "curDest",
                "uVar4": "currentWord"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080097cc": {
            "entrypoint": "0x080097cc",
            "current_name": "copy_and_reallocate_memory_080097cc",
            "code": "\nundefined4 copy_and_reallocate_memory_080097cc(undefined4 *dest_ptr,int *src_ptr,int *counter_ptr)\n\n{\n  int dest_index;\n  uint src_length;\n  int new_allocation;\n  int src_start_index;\n  uint new_length;\n  uint src_copy_length;\n  undefined4 *current_src_ptr;\n  undefined4 *next_src_ptr;\n  undefined4 src_value;\n  \n  if (counter_ptr[2] != 0) {\n    dest_index = *src_ptr;\n    new_length = src_ptr[2];\n    next_src_ptr = (undefined4 *)*counter_ptr;\n    do {\n      do {\n        current_src_ptr = next_src_ptr + 2;\n        src_value = *next_src_ptr;\n        src_copy_length = next_src_ptr[1];\n        next_src_ptr = current_src_ptr;\n      } while (src_copy_length == 0);\n      src_length = src_copy_length;\n      if ((new_length <= src_copy_length) && (src_length = new_length, (*(ushort *)(src_ptr + 3) & 0x480) != 0)) {\n        src_start_index = dest_index - src_ptr[4];\n        new_length = (src_ptr[5] * 3) / 2;\n        src_length = src_copy_length + 1 + src_start_index;\n        if (new_length < src_length) {\n          new_length = src_length;\n        }\n        if ((int)((uint)*(ushort *)(src_ptr + 3) << 0x15) < 0) {\n          new_allocation = allocate_memory(dest_ptr,new_length);\n          if (new_allocation == 0) {\nhandle_error:\n            *dest_ptr = 0xc;\n            *(ushort *)(src_ptr + 3) = *(ushort *)(src_ptr + 3) | 0x40;\n            counter_ptr[1] = 0;\n            counter_ptr[2] = 0;\n            return 0xffffffff;\n          }\n          copy_memory(new_allocation,src_ptr[4],src_start_index);\n          *(ushort *)(src_ptr + 3) = *(ushort *)(src_ptr + 3) & 0xfb7f | 0x80;\n        }\n        else {\n          new_allocation = allocate_or_initialize_memory(dest_ptr);\n          if (new_allocation == 0) {\n            initialize_memory_management(dest_ptr,src_ptr[4]);\n            goto handle_error;\n          }\n        }\n        dest_index = new_allocation + src_start_index;\n        src_ptr[5] = new_length;\n        src_ptr[4] = new_allocation;\n        *src_ptr = dest_index;\n        src_ptr[2] = new_length - src_start_index;\n        src_length = src_copy_length;\n      }\n      copy_memory_extra(dest_index,src_value,src_length);\n      src_start_index = counter_ptr[2];\n      new_length = src_ptr[2] - src_length;\n      dest_index = *src_ptr + src_length;\n      src_ptr[2] = new_length;\n      *src_ptr = dest_index;\n      counter_ptr[2] = src_start_index - src_copy_length;\n    } while (src_start_index - src_copy_length != 0);\n  }\n  counter_ptr[1] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080097cc": "copy_and_reallocate_memory_080097cc",
                "param_1": "dest_ptr",
                "param_2": "src_ptr",
                "param_3": "counter_ptr",
                "iVar1": "dest_index",
                "uVar2": "src_length",
                "iVar3": "new_allocation",
                "iVar4": "src_start_index",
                "uVar5": "new_length",
                "uVar6": "src_copy_length",
                "puVar7": "current_src_ptr",
                "puVar8": "next_src_ptr",
                "uVar9": "src_value",
                "allocate_memory_08008af8": "allocate_memory",
                "copy_memory_08001084": "copy_memory",
                "allocate_or_initialize_memory_08009adc": "allocate_or_initialize_memory",
                "initialize_memory_management_080088ec": "initialize_memory_management",
                "copy_memory_08009a18": "copy_memory_extra",
                "LAB_08009896": "handle_error"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_08009a18",
                "FUN_08001084",
                "FUN_08009adc",
                "FUN_080088ec",
                "FUN_08008af8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080098c0": {
            "entrypoint": "0x080098c0",
            "current_name": "update_data_080098c0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08009906) */\n/* WARNING: Removing unreachable block (ram,0x08009912) */\n\nundefined4 updateData_080098c0(int dataFlag,undefined4 newValue,undefined4 paramA,undefined4 paramB)\n\n{\n  undefined *dataPtr;\n  undefined4 returnValue;\n  uint bitMask;\n  uint dataCount;\n  \n  FUNC_08008af0(DAT_20000448);\n  if (DAT_20000168 == (undefined *)0x0) {\n    DAT_20000168 = &DAT_2000016c;\n  }\n  dataPtr = DAT_20000168;\n  dataCount = *(uint *)(DAT_20000168 + 4);\n  if ((int)dataCount < 0x20) {\n    if (dataFlag != 0) {\n      *(undefined4 *)(DAT_20000168 + dataCount * 4 + 0x88) = paramA;\n      bitMask = 1 << (dataCount & 0xff);\n      *(uint *)(dataPtr + 0x188) = *(uint *)(dataPtr + 0x188) | bitMask;\n      *(undefined4 *)(dataPtr + dataCount * 4 + 0x108) = paramB;\n      if (dataFlag == 2) {\n        *(uint *)(dataPtr + 0x18c) = bitMask | *(uint *)(dataPtr + 0x18c);\n      }\n    }\n    *(uint *)(dataPtr + 4) = dataCount + 1;\n    returnValue = DAT_20000448;\n    *(undefined4 *)(dataPtr + (dataCount + 2) * 4) = newValue;\n    FUNC_08008af4(returnValue);\n    returnValue = 0;\n  }\n  else {\n    FUNC_08008af4(DAT_20000448);\n    returnValue = 0xffffffff;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080098c0": "update_data_080098c0",
                "param_1": "dataFlag",
                "param_2": "newValue",
                "param_3": "paramA",
                "param_4": "paramB",
                "puVar1": "dataPtr",
                "uVar2": "returnValue",
                "uVar3": "bitMask",
                "uVar4": "dataCount"
            },
            "calling": [
                "FUN_080078a0"
            ],
            "called": [
                "FUN_08008af4",
                "FUN_08008af0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009980": {
            "entrypoint": "0x08009980",
            "current_name": "allocate_and_initialize_array_08009980",
            "code": "\nundefined4 * allocate_and_initialize_array_08009980(undefined4 size,int rows,int cols)\n\n{\n  undefined4 *array;\n  uint size_aligned;\n  undefined4 *array_end;\n  \n  array = (undefined4 *)allocate_memory_08008af8(size,cols * rows);\n  if (array == (undefined4 *)0x0) {\n    return (undefined4 *)0x0;\n  }\n  size_aligned = (array[-1] & 0xfffffffc) - 4;\n  if (size_aligned < 0x25) {\n    array_end = array;\n    if (0x13 < size_aligned) {\n      *array = 0;\n      array[1] = 0;\n      if (0x1b < size_aligned) {\n        array[2] = 0;\n        array[3] = 0;\n        if (size_aligned == 0x24) {\n          array[4] = 0;\n          array[5] = 0;\n          array_end = array + 6;\n        }\n        else {\n          array_end = array + 4;\n        }\n        *array_end = 0;\n        array_end[1] = 0;\n        array_end[2] = 0;\n        return array;\n      }\n      array_end = array + 2;\n    }\n    *array_end = 0;\n    array_end[1] = 0;\n    array_end[2] = 0;\n    return array;\n  }\n  memset_with_offset_08005d68(array,0);\n  return array;\n}\n\n",
            "renaming": {
                "FUN_08009980": "allocate_and_initialize_array_08009980",
                "param_1": "size",
                "param_2": "rows",
                "param_3": "cols",
                "puVar1": "array",
                "uVar2": "size_aligned",
                "puVar3": "array_end"
            },
            "calling": [
                "FUN_080090c0"
            ],
            "called": [
                "FUN_08005d68",
                "FUN_08008af8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009a18": {
            "entrypoint": "0x08009a18",
            "current_name": "copy_memory_08009a18",
            "code": "\nvoid copyMemory_08009a18(undefined4 *source,undefined4 *destination,uint size)\n\n{\n  undefined4 *dest_ptr;\n  undefined4 *source_ptr;\n  int iteration;\n  undefined *dest_end;\n  undefined4 *temp_ptr;\n  uint temp_size;\n  uint size_dma;\n  \n  if ((destination < source) && (source_ptr = (undefined4 *)((int)destination + size), source < source_ptr)) {\n    dest_end = (undefined *)((int)source + size);\n    if (size != 0) {\n      do {\n        source_ptr = (undefined4 *)((int)source_ptr + -1);\n        dest_end = dest_end + -1;\n        *dest_end = *(undefined *)source_ptr;\n      } while (destination != source_ptr);\n    }\n  }\n  else {\n    size_dma = size;\n    if (0xf < size) {\n      if ((((uint)source | (uint)destination) & 3) != 0) goto copy_loop;\n      source_ptr = destination + 4;\n      dest_ptr = source + 4;\n      do {\n        temp_ptr = source_ptr + 4;\n        dest_ptr[-4] = source_ptr[-4];\n        dest_ptr[-3] = source_ptr[-3];\n        dest_ptr[-2] = source_ptr[-2];\n        dest_ptr[-1] = source_ptr[-1];\n        source_ptr = temp_ptr;\n        dest_ptr = dest_ptr + 4;\n      } while (temp_ptr != (undefined4 *)((int)destination + (size - 0x10 & 0xfffffff0) + 0x20));\n      iteration = (size - 0x10 >> 4) + 1;\n      size_dma = size & 0xf;\n      destination = destination + iteration * 4;\n      source = source + iteration * 4;\n      if (3 < size_dma) {\n        source_ptr = source + -1;\n        temp_size = size_dma;\n        dest_ptr = destination;\n        do {\n          temp_size = temp_size - 4;\n          source_ptr = source_ptr + 1;\n          *source_ptr = *dest_ptr;\n          dest_ptr = dest_ptr + 1;\n        } while (3 < temp_size);\n        iteration = (size_dma - 4 & 0xfffffffc) + 4;\n        source = (undefined4 *)((int)source + iteration);\n        destination = (undefined4 *)((int)destination + iteration);\n        size_dma = size & 3;\n      }\n    }\n    size = size_dma;\n    if (size_dma != 0) {\ncopy_loop:\n      dest_end = (undefined *)((int)source + -1);\n      source_ptr = destination;\n      do {\n        dest_ptr = (undefined4 *)((int)source_ptr + 1);\n        dest_end = dest_end + 1;\n        *dest_end = *(undefined *)source_ptr;\n        source_ptr = dest_ptr;\n      } while (dest_ptr != (undefined4 *)(size + (int)destination));\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009a18": "copy_memory_08009a18",
                "param_1": "source",
                "param_2": "destination",
                "param_3": "size",
                "puVar1": "dest_ptr",
                "puVar2": "source_ptr",
                "iVar3": "iteration",
                "puVar4": "dest_end",
                "puVar5": "temp_ptr",
                "uVar6": "temp_size",
                "uVar7": "size_dma",
                "LAB_08009abc": "copy_loop"
            },
            "calling": [
                "FUN_08009adc",
                "FUN_080097cc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009adc": {
            "entrypoint": "0x08009adc",
            "current_name": "allocate_or_initialize_memory_08009adc",
            "code": "\nint * allocate_or_initialize_memory_08009adc(undefined4 *memory_pointer,int *existing_data,uint data_size)\n\n{\n  int *new_memory_pointer;\n  int temp_variable_1;\n  int *temp_variable_2;\n  uint temp_variable_3;\n  int temp_variable_4;\n  uint size_and_flag;\n  int *temp_variable_5;\n  uint aligned_size;\n  uint aligned_size_minus_4;\n  uint temp_variable_6;\n  int end_of_existing_data;\n  \n  if (existing_data == (int *)0x0) {\n    temp_variable_2 = (int *)allocate_memory(memory_pointer,data_size);\n    return temp_variable_2;\n  }\n  initialize_data();\n  size_and_flag = existing_data[-1];\n  aligned_size_minus_4 = size_and_flag & 0xfffffffc;\n  temp_variable_2 = existing_data + -2;\n  if (data_size + 0xb < 0x17) {\n    aligned_size = 0x10;\n  }\n  else {\n    aligned_size = data_size + 0xb & 0xfffffff8;\n    if ((int)aligned_size < 0) goto LAB_08009b8e;\n  }\n  if (aligned_size < data_size) {\nLAB_08009b8e:\n    *memory_pointer = 0xc;\n    return (int *)0x0;\n  }\n  end_of_existing_data = (int)temp_variable_2 + aligned_size_minus_4;\n  temp_variable_6 = aligned_size_minus_4;\n  if ((int)aligned_size_minus_4 < (int)aligned_size) {\n    if (DAT_20000454 == end_of_existing_data) {\n      end_of_existing_data = (*(uint *)(DAT_20000454 + 4) & 0xfffffffc) + aligned_size_minus_4;\n      if ((int)(aligned_size + 0x10) <= end_of_existing_data) {\n        DAT_20000454 = (int)temp_variable_2 + aligned_size;\n        *(uint *)(DAT_20000454 + 4) = end_of_existing_data - aligned_size | 1;\n        existing_data[-1] = aligned_size | existing_data[-1] & 1U;\n        initialize_data_structures(memory_pointer);\n        return existing_data;\n      }\n      if (-1 < (int)(size_and_flag << 0x1f)) {\n        new_memory_pointer = (int *)((int)temp_variable_2 - existing_data[-2]);\n        size_and_flag = new_memory_pointer[1] & 0xfffffffc;\n        if ((int)(aligned_size + 0x10) <= (int)(end_of_existing_data + size_and_flag)) {\n          temp_variable_4 = new_memory_pointer[3];\n          temp_variable_2 = new_memory_pointer + 2;\n          temp_variable_1 = *temp_variable_2;\n          aligned_size_minus_4 = aligned_size_minus_4 - 4;\n          *(int *)(temp_variable_1 + 0xc) = temp_variable_4;\n          *(int *)(temp_variable_4 + 8) = temp_variable_1;\n          if (aligned_size_minus_4 < 0x25) {\n            temp_variable_1 = *existing_data;\n            temp_variable_5 = temp_variable_2;\n            if (0x13 < aligned_size_minus_4) {\n              new_memory_pointer[2] = temp_variable_1;\n              new_memory_pointer[3] = existing_data[1];\n              temp_variable_1 = existing_data[2];\n              if (aligned_size_minus_4 < 0x1c) {\n                existing_data = existing_data + 2;\n                temp_variable_5 = new_memory_pointer + 4;\n              }\n              else {\n                new_memory_pointer[4] = temp_variable_1;\n                new_memory_pointer[5] = existing_data[3];\n                temp_variable_1 = existing_data[4];\n                if (aligned_size_minus_4 == 0x24) {\n                  new_memory_pointer[6] = temp_variable_1;\n                  new_memory_pointer[7] = existing_data[5];\n                  temp_variable_1 = existing_data[6];\n                  existing_data = existing_data + 6;\n                  temp_variable_5 = new_memory_pointer + 8;\n                }\n                else {\n                  existing_data = existing_data + 4;\n                  temp_variable_5 = new_memory_pointer + 6;\n                }\n              }\n            }\n            *temp_variable_5 = temp_variable_1;\n            temp_variable_5[1] = existing_data[1];\n            temp_variable_5[2] = existing_data[2];\n          }\n          else {\n            copy_memory(temp_variable_2,existing_data);\n          }\n          DAT_20000454 = (int)new_memory_pointer + aligned_size;\n          *(uint *)(DAT_20000454 + 4) = (end_of_existing_data + size_and_flag) - aligned_size | 1;\n          new_memory_pointer[1] = aligned_size | new_memory_pointer[1] & 1U;\n          initialize_data_structures(memory_pointer);\n          return temp_variable_2;\n        }\nLAB_08009bb0:\n        temp_variable_6 = aligned_size_minus_4 + size_and_flag;\n        if ((int)aligned_size <= (int)temp_variable_6) {\n          temp_variable_4 = new_memory_pointer[3];\n          temp_variable_5 = new_memory_pointer + 2;\n          temp_variable_1 = *temp_variable_5;\n          *(int *)(temp_variable_1 + 0xc) = temp_variable_4;\n          end_of_existing_data = (int)new_memory_pointer + temp_variable_6;\n          *(int *)(temp_variable_4 + 8) = temp_variable_1;\n          temp_variable_2 = new_memory_pointer;\n          if (aligned_size_minus_4 - 4 < 0x25) goto LAB_08009bd0;\nLAB_08009d4c:\n          copy_memory(temp_variable_5,existing_data);\n          existing_data = temp_variable_5;\n          goto LAB_08009c00;\n        }\n      }\n    }\n    else {\n      if (-1 < *(int *)((*(uint *)(end_of_existing_data + 4) & 0xfffffffe) + end_of_existing_data + 4) << 0x1f) {\n        temp_variable_3 = *(uint *)(end_of_existing_data + 4) & 0xfffffffc;\n        temp_variable_6 = aligned_size_minus_4 + temp_variable_3;\n        if ((int)temp_variable_6 < (int)aligned_size) {\n          if ((int)(size_and_flag << 0x1f) < 0) goto LAB_08009b36;\n          new_memory_pointer = (int *)((int)temp_variable_2 - existing_data[-2]);\n          size_and_flag = new_memory_pointer[1] & 0xfffffffc;\n          temp_variable_6 = temp_variable_3 + size_and_flag + aligned_size_minus_4;\n          if ((int)temp_variable_6 < (int)aligned_size) goto LAB_08009bb0;\n          temp_variable_1 = *(int *)(end_of_existing_data + 8);\n          end_of_existing_data = *(int *)(end_of_existing_data + 0xc);\n          *(int *)(temp_variable_1 + 0xc) = end_of_existing_data;\n          *(int *)(end_of_existing_data + 8) = temp_variable_1;\n          temp_variable_5 = new_memory_pointer + 2;\n          temp_variable_1 = *temp_variable_5;\n          temp_variable_4 = new_memory_pointer[3];\n          *(int *)(temp_variable_1 + 0xc) = temp_variable_4;\n          end_of_existing_data = (int)new_memory_pointer + temp_variable_6;\n          *(int *)(temp_variable_4 + 8) = temp_variable_1;\n          temp_variable_2 = new_memory_pointer;\n          if (0x24 < aligned_size_minus_4 - 4) goto LAB_08009d4c;\nLAB_08009bd0:\n          aligned_size_minus_4 = aligned_size_minus_4 - 4;\n          temp_variable_1 = *existing_data;\n          new_memory_pointer = temp_variable_5;\n          if (0x13 < aligned_size_minus_4) {\n            temp_variable_2[2] = temp_variable_1;\n            temp_variable_2[3] = existing_data[1];\n            temp_variable_1 = existing_data[2];\n            if (aligned_size_minus_4 < 0x1c) {\n              existing_data = existing_data + 2;\n              new_memory_pointer = temp_variable_2 + 4;\n            }\n            else {\n              temp_variable_2[4] = temp_variable_1;\n              temp_variable_2[5] = existing_data[3];\n              temp_variable_1 = existing_data[4];\n              if (aligned_size_minus_4 == 0x24) {\n                temp_variable_2[6] = temp_variable_1;\n                temp_variable_2[7] = existing_data[5];\n                temp_variable_1 = existing_data[6];\n                existing_data = existing_data + 6;\n                new_memory_pointer = temp_variable_2 + 8;\n              }\n              else {\n                existing_data = existing_data + 4;\n                new_memory_pointer = temp_variable_2 + 6;\n              }\n            }\n          }\n          *new_memory_pointer = temp_variable_1;\n          new_memory_pointer[1] = existing_data[1];\n          new_memory_pointer[2] = existing_data[2];\n          existing_data = temp_variable_5;\n        }\n        else {\n          temp_variable_1 = *(int *)(end_of_existing_data + 8);\n          temp_variable_4 = *(int *)(end_of_existing_data + 0xc);\n          *(int *)(temp_variable_1 + 0xc) = temp_variable_4;\n          end_of_existing_data = (int)temp_variable_2 + temp_variable_6;\n          *(int *)(temp_variable_4 + 8) = temp_variable_1;\n        }\n        goto LAB_08009c00;\n      }\n      if (-1 < (int)(size_and_flag << 0x1f)) {\n        new_memory_pointer = (int *)((int)temp_variable_2 - existing_data[-2]);\n        size_and_flag = new_memory_pointer[1] & 0xfffffffc;\n        goto LAB_08009bb0;\n      }\n    }\nLAB_08009b36:\n    new_memory_pointer = (int *)allocate_memory(memory_pointer,data_size);\n    if (new_memory_pointer != (int *)0x0) {\n      if ((int *)((existing_data[-1] & 0xfffffffeU) + (int)temp_variable_2) == new_memory_pointer + -2) {\n        temp_variable_6 = aligned_size_minus_4 + (new_memory_pointer[-1] & 0xfffffffcU);\n        end_of_existing_data = (int)temp_variable_2 + temp_variable_6;\n        goto LAB_08009c00;\n      }\n      aligned_size_minus_4 = aligned_size_minus_4 - 4;\n      if (aligned_size_minus_4 < 0x25) {\n        end_of_existing_data = *existing_data;\n        temp_variable_2 = existing_data;\n        temp_variable_5 = new_memory_pointer;\n        if (0x13 < aligned_size_minus_4) {\n          *new_memory_pointer = end_of_existing_data;\n          new_memory_pointer[1] = existing_data[1];\n          if (aligned_size_minus_4 < 0x1c) {\n            end_of_existing_data = existing_data[2];\n            temp_variable_2 = existing_data + 2;\n            temp_variable_5 = new_memory_pointer + 2;\n          }\n          else {\n            new_memory_pointer[2] = existing_data[2];\n            new_memory_pointer[3] = existing_data[3];\n            if (aligned_size_minus_4 == 0x24) {\n              new_memory_pointer[4] = existing_data[4];\n              new_memory_pointer[5] = existing_data[5];\n              end_of_existing_data = existing_data[6];\n              temp_variable_2 = existing_data + 6;\n              temp_variable_5 = new_memory_pointer + 6;\n            }\n            else {\n              end_of_existing_data = existing_data[4];\n              temp_variable_2 = existing_data + 4;\n              temp_variable_5 = new_memory_pointer + 4;\n            }\n          }\n        }\n        *temp_variable_5 = end_of_existing_data;\n        temp_variable_5[1] = temp_variable_2[1];\n        temp_variable_5[2] = temp_variable_2[2];\n      }\n      else {\n        copy_memory(new_memory_pointer,existing_data);\n      }\n      initialize_memory_management(memory_pointer,existing_data);\n    }\n    initialize_data_structures(memory_pointer);\n    existing_data = new_memory_pointer;\n  }\n  else {\nLAB_08009c00:\n    if (temp_variable_6 - aligned_size < 0x10) {\n      temp_variable_2[1] = temp_variable_2[1] & 1U | temp_variable_6;\n      *(uint *)(end_of_existing_data + 4) = *(uint *)(end_of_existing_data + 4) | 1;\n    }\n    else {\n      temp_variable_2[1] = temp_variable_2[1] & 1U | aligned_size;\n      *(uint *)((int)temp_variable_2 + aligned_size + 4) = temp_variable_6 - aligned_size | 1;\n      *(uint *)(end_of_existing_data + 4) = *(uint *)(end_of_existing_data + 4) | 1;\n      initialize_memory_management(memory_pointer,(int)temp_variable_2 + aligned_size + 8);\n    }\n    initialize_data_structures(memory_pointer);\n  }\n  return existing_data;\n}\n\n",
            "renaming": {
                "FUN_08009adc": "allocate_or_initialize_memory_08009adc",
                "param_1": "memory_pointer",
                "param_2": "existing_data",
                "param_3": "data_size",
                "piVar1": "new_memory_pointer",
                "iVar2": "temp_variable_1",
                "piVar3": "temp_variable_2",
                "uVar4": "temp_variable_3",
                "iVar5": "temp_variable_4",
                "uVar6": "size_and_flag",
                "piVar7": "temp_variable_5",
                "uVar8": "aligned_size",
                "uVar9": "aligned_size_minus_4",
                "uVar10": "temp_variable_6",
                "iVar11": "end_of_existing_data",
                "allocate_memory_08008af8": "allocate_memory",
                "initialize_data_080090a8": "initialize_data",
                "initialize_data_structures_080090b4": "initialize_data_structures",
                "copy_memory_08009a18": "copy_memory",
                "initialize_memory_management_080088ec": "initialize_memory_management"
            },
            "calling": [
                "FUN_080097cc"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_08009a18",
                "FUN_080090b4",
                "FUN_080088ec",
                "FUN_08008af8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e68": {
            "entrypoint": "0x08009e68",
            "current_name": "FUNC_08009e68",
            "code": "\nvoid FUNC_08009e68(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e68": "FUNC_08009e68"
            },
            "calling": [
                "FUN_08005d20",
                "FUN_08000134",
                "FUN_08000110"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08009e74": {
            "entrypoint": "0x08009e74",
            "current_name": "FUNC_08009e74",
            "code": "\nvoid FUNC_08009e74(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e74": "FUNC_08009e74"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 158075,
    "layers": [
        [
            "FUN_08000110",
            "FUN_08000134",
            "FUN_08000158",
            "FUN_0800015c",
            "FUN_080003d4",
            "FUN_080003f4",
            "FUN_08000418",
            "FUN_080006a4",
            "FUN_0800088a",
            "FUN_080008fc",
            "FUN_080009fc",
            "FUN_08000aa4",
            "FUN_08000aa8",
            "FUN_08000c08",
            "FUN_08000c10",
            "FUN_08000cb8",
            "FUN_08000e20",
            "FUN_08000f68",
            "FUN_08001044",
            "FUN_08001084",
            "FUN_08001170",
            "FUN_0800119c",
            "FUN_0800121c",
            "FUN_0800157c",
            "FUN_080015a0",
            "FUN_080015b4",
            "FUN_080015fc",
            "FUN_08001618",
            "FUN_0800166c",
            "FUN_0800177c",
            "FUN_080017c4",
            "FUN_08001a80",
            "FUN_08002d3c",
            "FUN_08003440",
            "FUN_08003504",
            "FUN_08003568",
            "FUN_0800360c",
            "FUN_08003c94",
            "FUN_08003d60",
            "FUN_08003e38",
            "FUN_08003f18",
            "FUN_08003ff8",
            "FUN_080040a0",
            "FUN_08004104",
            "FUN_0800416a",
            "FUN_080041a8",
            "FUN_080041ea",
            "FUN_0800422e",
            "FUN_080042de",
            "FUN_08004e6c",
            "FUN_08005674",
            "FUN_08005780",
            "FUN_08005d14",
            "FUN_08005d20",
            "FUN_08005d68",
            "FUN_08005dfc",
            "FUN_08005e40",
            "FUN_08008ad4",
            "FUN_0800901c",
            "FUN_080090a8",
            "FUN_080090b4",
            "FUN_0800910c",
            "FUN_080091a4",
            "FUN_080091e4",
            "FUN_080094f8",
            "FUN_08009768",
            "FUN_080098c0",
            "FUN_08009a18"
        ],
        [
            "FUN_080004c8",
            "FUN_0800071c",
            "FUN_08000988",
            "FUN_08000fd0",
            "FUN_080011ec",
            "FUN_080016d0",
            "FUN_08001714",
            "FUN_0800172a",
            "FUN_08002ad8",
            "FUN_08002bb4",
            "FUN_08002c2e",
            "FUN_08002ca8",
            "FUN_08002d98",
            "FUN_08003518",
            "FUN_08003540",
            "FUN_080035a4",
            "FUN_08003640",
            "FUN_080036a8",
            "FUN_08003908",
            "FUN_08003a94",
            "FUN_08004436",
            "FUN_08004ae0",
            "FUN_08004e74",
            "FUN_08004f2c",
            "FUN_08004f60",
            "FUN_080055f4",
            "FUN_08005680",
            "FUN_08005728",
            "FUN_080078c0"
        ],
        [
            "FUN_08000978",
            "FUN_08000998",
            "FUN_080009ac",
            "FUN_080009c0",
            "FUN_08000fc8",
            "FUN_08000ff4",
            "FUN_08001762",
            "FUN_08001ab0",
            "FUN_08002640",
            "FUN_080027f4",
            "FUN_080046ec",
            "FUN_08004f3c",
            "FUN_080053b0",
            "FUN_08005500",
            "FUN_080096e0",
            "FUN_08009744"
        ],
        [
            "FUN_080009d4",
            "FUN_080009e8",
            "FUN_08001030",
            "FUN_0800151c",
            "FUN_08001ccc",
            "FUN_08001f6c",
            "FUN_0800438a",
            "FUN_08005348",
            "FUN_0800884c"
        ],
        [
            "FUN_080014f0",
            "FUN_08003260",
            "FUN_08004ea4",
            "FUN_08004ee8",
            "FUN_08005598",
            "FUN_080059f0",
            "FUN_080088ec"
        ],
        [
            "FUN_080052a0",
            "thunk_FUN_08005838",
            "FUN_08005838",
            "FUN_08008af8"
        ],
        [
            "FUN_08004bd8",
            "FUN_08004d78",
            "FUN_08009980",
            "FUN_08009adc"
        ],
        [
            "FUN_080049cc",
            "FUN_08004f78",
            "FUN_080090c0",
            "FUN_080097cc"
        ],
        [
            "FUN_080017b4",
            "FUN_080036f8",
            "FUN_0800491c",
            "FUN_08009120",
            "FUN_08009244",
            "FUN_08009258",
            "FUN_08009444",
            "FUN_08009530",
            "FUN_08009630"
        ],
        [
            "FUN_08005224",
            "FUN_08005704",
            "FUN_08005714",
            "FUN_080093a4"
        ],
        [
            "FUN_080079e8"
        ]
    ],
    "locked_functions": []
}