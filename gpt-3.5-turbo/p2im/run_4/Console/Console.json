{
    "functions": {
        "FUN_000026c0": {
            "renaming": {
                "FUN_000026c0": "clearFlagsAndSetToZero_000026c0",
                "PTR_DAT_000026d4": "pointerToData",
                "clear_flags_00002910": "clearFlags"
            },
            "code": "void clearFlagsAndSetToZero_000026c0(void)\n{\n  clearFlags();\n  *(undefined4 *)PTR_DAT_000026d4 = 0;\n  return;\n}",
            "called": [
                "FUN_00002910"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "clearFlagsAndSetToZero_000026c0"
        },
        "FUN_00004bd0": {
            "renaming": {
                "FUN_00004bd0": "allocate_memory_00004bd0",
                "param_1": "out_size",
                "param_2": "size_to_allocate",
                "param_3": "arg3",
                "param_4": "arg4",
                "puVar1": "unused_pointer",
                "uVar2": "unused",
                "puVar3": "current_block_ptr",
                "iVar4": "unused",
                "uVar5": "block_size",
                "puVar6": "previous_block_ptr",
                "uVar7": "ret_val",
                "PTR_DAT_00004c80": "unused_pointer_1",
                "PTR_DAT_00004c7c": "memory_blocks_list"
            },
            "code": "uint allocate_memory_00004bd0(uint *out_size, uint size_to_allocate, uint arg3, uint arg4)\\n\\\n{\\n\\\n  uint *current_block_ptr;\\n\\\n  uint block_size;\\n\\\n  uint *previous_block_ptr;\\n\\\n  uint aligned_size_to_allocate;\\n\\\n  uint ret_val = 0;\\n\\\n  \\n\\\n  aligned_size_to_allocate = (size_to_allocate + 3) & 0xFFFFFFFC;\\n\\\n  aligned_size_to_allocate += 8;\\n\\\n  if (aligned_size_to_allocate < 0xC) {\\n\\\n    aligned_size_to_allocate = 0xC;\\n\\\n  }\\n\\\n  if (aligned_size_to_allocate >= 0 && aligned_size_to_allocate >= size_to_allocate) {\\n\\\n    do_nothing_with_pointer_00005790();\\n\\\n    current_block_ptr = *(uint **)PTR_DAT_00004c7c;\\n\\\n    previous_block_ptr = *(uint **)PTR_DAT_00004c7c;\\n\\\n    while (current_block_ptr != NULL) {\\n\\\n      block_size = *current_block_ptr;\\n\\\n      if (block_size >= aligned_size_to_allocate) {\\n\\\n        if (block_size > aligned_size_to_allocate + 0xB) {\\n\\\n          *current_block_ptr = block_size - aligned_size_to_allocate;\\n\\\n          current_block_ptr = (uint *)((int)current_block_ptr + *current_block_ptr);\\n\\\n          *current_block_ptr = aligned_size_to_allocate;\\n\\\n        }\\n\\\n        if (previous_block_ptr == current_block_ptr) {\\n\\\n          *(uint **)PTR_DAT_00004c7c = (uint *)(current_block_ptr[1]);\\n\\\n        }\\n\\\n        else {\\n\\\n          previous_block_ptr[1] = current_block_ptr[1];\\n\\\n        }\\n\\\n        ret_val = (int)current_block_ptr + 8;\\n\\\n        break;\\n\\\n      }\\n\\\n      previous_block_ptr = current_block_ptr;\\n\\\n      current_block_ptr = (uint *)(current_block_ptr[1]);\\n\\\n    }\\n\\\n    if (ret_val == 0) {\\n\\\n      ret_val = validate_memory_access_00000428(out_size, 0, previous_block_ptr, 0, arg4);\\n\\\n      *(uint **)PTR_DAT_00004c80 = ret_val;\\n\\\n    }\\n\\\n    else {\\n\\\n      do_nothing_with_pointer_0000579c(out_size);\\n\\\n    }\\n\\\n    if (ret_val != 0) {\\n\\\n      block_size = (int)current_block_ptr + 0xB;\\n\\\n      block_size = block_size & 0xFFFFFFF8;\\n\\\n      if (block_size > (int)(current_block_ptr + 1)) {\\n\\\n        *(uint *)(block_size + (int)current_block_ptr + 4) = block_size - (int)(current_block_ptr + 1);\\n\\\n      }\\n\\\n      ret_val = block_size;\\n\\\n    }\\n\\\n  }\\n\\\n  *out_size = ret_val;\\n\\\n  if (ret_val == 0) {\\n\\\n    *out_size = 0xC;\\n\\\n  }\\n\\\n  return ret_val;\\n\\\n}",
            "called": [
                "FUN_0000579c",
                "FUN_00005790",
                "FUN_00000428"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004bd0",
            "calling": [
                "FUN_000068f0",
                "FUN_00005700",
                "FUN_00004248",
                "FUN_00005100",
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "allocate_memory_00004bd0"
        },
        "FUN_00000794": {
            "renaming": {
                "FUN_00000794": "create_stack_frame_00000794",
                "extraout_r1": "extraout_return",
                "iVar1": "frame_length",
                "puVar2": "frame_pointer",
                "uVar3": "frame_start",
                "iStack_1c": "i",
                "iStack_18": "i",
                "piStack_14": "frame_pointer"
            },
            "code": "int * create_stack_frame_00000794(void)\n{\n  int extraout_return;\n  int frame_length;\n  uint frame_start;\n  int *frame_pointer;\n  \n  check_interrupts_enabled();\n  \n  // Write a zero to the current stack frame\n  *(int *)(iRam000007d0 + *psRam000007cc * 4) = 0;\n  \n  // Decrement the stack pointer\n  *piRam000007d4 = *piRam000007d4 - 1;\n  \n  // Update or remove an element from the stack\n  update_or_remove_element_00000698(*puRam000007d8, 0);\n  \n  // Reset the stack pointer\n  puRam000007d8 = 0;\n  \n  // Run the interrupt handler\n  run_interrupt_handler();\n  \n  // Calculate the start of the new frame\n  frame_start = ((uint)puRam000007d8 + frame_length) & 0xfffffffc;\n  \n  // Set the frame pointer\n  frame_pointer = (int *)(frame_start - 4);\n  \n  // Write a magic number to the frame pointer\n  *frame_pointer = 0x77777777;\n  \n  // Check if the frame pointer is not 8-byte aligned\n  if (((uint)frame_pointer & 7) != 0) {\n    frame_pointer = (int *)(frame_start - 8);\n    *frame_pointer = 0x88888888;\n  }\n  \n  // Write the length of the frame\n  frame_pointer[-1] = 0x1000000;\n  \n  // Write the frame length shifted by 13 bits\n  frame_pointer[-2] = frame_length << 0xd;\n  \n  // Write a data value\n  frame_pointer[-3] = DAT_000008b4;\n  \n  // Write a zero to the previous frame pointer\n  frame_pointer = frame_pointer - 4;\n  *frame_pointer = 0;\n  \n  // Write the values 3, 2, 1 to the stack\n  for (int i = 3; i > 0; i--) {\n    frame_pointer = frame_pointer - 1;\n    *frame_pointer = i;\n  }\n  \n  // Write the value of extraout_return to the stack\n  frame_pointer = frame_pointer - 1;\n  *frame_pointer = extraout_return;\n  \n  // Write the values 11, 10, 9, 8, 7, 6, 5, 4 to the stack\n  for (int i = 0xb; i > 3; i--) {\n    frame_pointer = frame_pointer - 1;\n    *frame_pointer = i;\n  }\n  \n  // Write a sentinel value to the stack\n  frame_pointer[-1] = -3;\n  \n  return frame_pointer - 1;\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000930",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000794",
            "calling": [],
            "imported": false,
            "current_name": "create_stack_frame_00000794"
        },
        "FUN_000064bc": {
            "renaming": {
                "FUN_000064bc": "process_data_000064bc",
                "param_1": "param_1",
                "param_2": "param_2",
                "param_3": "param_3",
                "param_4": "param_4",
                "puVar1": "config",
                "iVar2": "status",
                "uVar3": "remaining_bytes",
                "ppbVar4": "input_buffer",
                "pbVar5": "current_byte",
                "unaff_r6": "output_byte",
                "pbVar6": "unaff_r6",
                "iVar7": "processed_bytes"
            },
            "code": "int process_data_000064bc(uint32_t param_1, uint32_t *param_2, uint8_t **param_3, uint32_t *param_4) {\n  uint8_t *current_byte;\n  uint8_t *output_byte;\n  uint8_t *unaff_r6;\n  uint32_t remaining_bytes;\n  uint32_t status;\n  uint8_t *input_buffer;\n  uint32_t *config;\n  uint32_t processed_bytes;\n  \n  if (param_2[2] == 0) {\n    if (param_2[6] == 0) {\n      status = 1;\n    }\n    else {\n      status = 0xffffffff;\n    }\n    param_2[2] = status;\n  }\n  config = PTR_DAT_00006568;\n  if (-1 < (int32_t)(*param_2 << 0x1b)) {\n    input_buffer = *param_4;\n    *param_4 = input_buffer + 1;\n    unaff_r6 = *input_buffer;\n  }\n  processed_bytes = 0;\n  do {\n    remaining_bytes = param_2[6];\n    if (remaining_bytes != 0) {\n      if (remaining_bytes == 1) {\n        if (*(char *)(param_2[5] + (uint32_t)**param_3) == '\\0') {\n          if (processed_bytes == 0) {\n            return 1;\n          }\n          goto LAB_0000654a;\n        }\n      }\n      else if ((remaining_bytes == 2) && ((int32_t)((uint32_t)(byte)config[**param_3] << 0x1c) < 0)) {\n        goto LAB_0000654a;\n      }\n    }\n    output_byte = unaff_r6;\n    if (-1 < (int32_t)(*param_2 << 0x1b)) {\n      output_byte = unaff_r6 + 1;\n      *unaff_r6 = **param_3;\n    }\n    current_byte = param_3[1];\n    *param_3 = *param_3 + 1;\n    remaining_bytes = param_2[2] - 1;\n    param_3[1] = current_byte + -1;\n    processed_bytes = processed_bytes + 1;\n    param_2[2] = remaining_bytes;\n    unaff_r6 = output_byte;\n    if ((remaining_bytes == 0) || (((int32_t)(current_byte + -1) < 1 && ((status = (*(code *)param_2[0x60])(param_1,param_3,remaining_bytes,(code *)param_2[0x60],param_4), status != 0)))) {\n      goto LAB_0000654a;\n    }\n  } while(true);\n  \nLAB_0000654a:\n  if (((*param_2 & 0x10) == 0) && (param_2[3] = param_2[3] + 1, param_2[6] != 0)) {\n    *unaff_r6 = 0;\n  }\n  param_2[4] = processed_bytes + param_2[4];\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000064bc",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "process_data_000064bc"
        },
        "FUN_00002970": {
            "renaming": {
                "FUN_00002970": "clear_interrupt_flag_00002970",
                "DAT_00002990": "flag_base_address"
            },
            "code": "void clear_interrupt_flag_00002970(void)\n{\n  uint32_t* flag_ptr = (uint32_t*)(DAT_00002990 + 0x14);\n  *flag_ptr &= ~(1 << 4);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002970",
            "calling": [
                "FUN_000026e4"
            ],
            "imported": false,
            "current_name": "clear_interrupt_flag_00002970"
        },
        "FUN_00000dc0": {
            "renaming": {
                "FUN_00000dc0": "check_interrupts_enabled_00000dc0",
                "check_irq_interrupts_enabled_00000cc0": "check_irq_interrupts_enabled"
            },
            "code": "void check_interrupts_enabled_00000dc0(void)\n{\n  check_irq_interrupts_enabled();\n  return;\n}",
            "called": [
                "FUN_00000cc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dc0",
            "calling": [],
            "imported": false,
            "current_name": "check_interrupts_enabled_00000dc0"
        },
        "FUN_00000d0c": {
            "renaming": {
                "FUN_00000d0c": "enable_irq_interrupts_if_privileged_00000d0c",
                "param_1": "privilege_level",
                "bVar1": "is_privileged"
            },
            "code": "void enable_irq_interrupts_if_privileged_00000d0c(uint privilege_level) {\n  bool is_privileged = (bool)isCurrentModePrivileged();\n  if (is_privileged) {\n    enableIRQinterrupts((privilege_level & 1) == 1);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d0c",
            "calling": [
                "FUN_000010d4",
                "FUN_000024bc",
                "FUN_00002434",
                "FUN_00001c84",
                "FUN_00000428"
            ],
            "imported": false,
            "current_name": "enable_irq_interrupts_if_privileged_00000d0c"
        },
        "FUN_00003d94": {
            "renaming": {
                "FUN_00003d94": "execute_function_00003d94",
                "param_1": "function_ptr",
                "param_2": "arg2",
                "uVar1": "result"
            },
            "code": "int execute_function_00003d94(int function_ptr, int arg1, int arg2) {\n  int result;\n  if (function_ptr == 0) {\n    result = -19;\n  }\n  else {\n    result = (**(function_ptr + 0x4))(arg1, arg2);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d94",
            "calling": [
                "FUN_0000305c"
            ],
            "imported": false,
            "current_name": "execute_function_00003d94"
        },
        "FUN_0000579c": {
            "renaming": {
                "FUN_0000579c": "do_nothing_with_pointer_0000579c",
                "PTR_DAT_000057a4": "PTR_data",
                "do_nothing_000045ec": "do_nothing"
            },
            "code": "void do_nothing_with_pointer_0000579c(void)\n{\n  do_nothing(PTR_DAT_000057a4);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000579c",
            "calling": [
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_0000579c"
        },
        "FUN_000015d0": {
            "renaming": {
                "FUN_000015d0": "copy_data_to_memory_000015d0",
                "param_1": "offset",
                "param_2": "source_address",
                "param_3": "data_size",
                "iVar1": "memory_address",
                "local_c": "i"
            },
            "code": "void copy_data_to_memory_000015d0(int offset, int source_address, uint32_t data_size)\n{\n  int memory_address = *(int *)(PTR_DAT_00001624 + offset * 0x20);\n  for (uint32_t i = 0; i < data_size; i++) {\n    do {\n    } while (-1 < *(char *)(memory_address + 4));\n    *(undefined *)(memory_address + 7) = *(undefined *)(i + source_address);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000015d0",
            "calling": [
                "FUN_00000e38"
            ],
            "imported": false,
            "current_name": "copy_data_to_memory_000015d0"
        },
        "FUN_00005e68": {
            "renaming": {
                "FUN_00005e68": "parse_string_and_call_function_00005e68",
                "param_1": "string_start",
                "param_2": "string_end",
                "param_3": "arg1",
                "param_4": "arg2",
                "local_80": "function_arg1",
                "local_7c": "string_end_ptr",
                "local_74": "string_constants",
                "local_72": "constant_neg1",
                "local_70": "function_arg1",
                "local_6c": "string_end_ptr",
                "local_5c": "string_constants",
                "local_4c": "constant_zero",
                "local_38": "constant_zero",
                "uStack_8": "function_arg2",
                "uStack_4": "function_arg3"
            },
            "code": "void parse_string_and_call_function_00005e68(void* string_start, void* string_end, void* arg1, void* arg2)\n{\n    void* current_string_char = string_start;\n    void* function_arg1 = string_start;\n    void* function_arg2 = arg1;\n    void* function_arg3 = arg2;\n    void* string_end_ptr = find_end_of_string();\n    void* string_constants = PTR_LAB_00004dea_1_00005eb4;\n    void* constant_zero = 0;\n    void* constant_neg1 = -1;\n    void* string_length = string_end - string_start;\n\n    FUNC_000061cc(*DAT_00005eb8, &function_arg1, function_arg2, function_arg3);\n}\n",
            "called": [
                "FUN_00005ecc",
                "FUN_000061cc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e68",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "parse_string_and_call_function_00005e68"
        },
        "FUN_00000dcc": {
            "renaming": {
                "FUN_00000dcc": "set_data_00000dcc",
                "DAT_00000df0": "data_ptr"
            },
            "code": "void set_data_00000dcc(void)\n{\n  int* DAT_00000df0 = DAT_00000df0;\n  DAT_00000df0[7] = 0xc520;\n  DAT_00000df0[7] = 0xd928;\n  *DAT_00000df0 = 0xd2;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dcc",
            "calling": [
                "FUN_00000db0"
            ],
            "imported": false,
            "current_name": "set_data_00000dcc"
        },
        "FUN_0000285c": {
            "renaming": {
                "FUN_0000285c": "set_flag_and_store_data_0000285c",
                "param_1": "data",
                "puVar1": "data_ptr"
            },
            "code": "void set_flag_and_store_data_0000285c(undefined4 data){\n    undefined4 *data_ptr;\n    data_ptr = DAT_00002890;\n    data_ptr[5] &= 0xffffffef;\n    *data_ptr = data;\n    data_ptr[5] |= 0x10;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000285c",
            "calling": [
                "FUN_00002600"
            ],
            "imported": false,
            "current_name": "set_flag_and_store_data_0000285c"
        },
        "FUN_00000e58": {
            "renaming": {
                "FUN_00000e58": "wait_for_interrupt_00000e58",
                "check_interrupts_enabled_00000cd0": "check_interrupts_enabled"
            },
            "code": "void wait_for_interrupt_00000e58(void)\n{\n  check_interrupts_enabled();\n  while(true)\n  {\n    // Do nothing, just wait for an interrupt\n  }\n}",
            "called": [
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e58",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "wait_for_interrupt_00000e58"
        },
        "FUN_00001778": {
            "renaming": {
                "FUN_00001778": "set_bit_00001778",
                "DAT_000017d0": "data",
                "DAT_000017d8": "result",
                "set_result_to_zero_00001710": "set_result_to_zero"
            },
            "code": "void set_bit_00001778(byte* DAT_000017d0, int bit_position) {\n  byte mask = 0x20;\n  byte* target_byte = DAT_000017d0 + 1;\n  *target_byte = (*target_byte & 0xCF) | mask;\n  set_DAT_000017d8_to_zero(DAT_000017d0 + 8, 2);\n}\n",
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001778",
            "calling": [
                "FUN_000019c0",
                "FUN_0000191c"
            ],
            "imported": false,
            "current_name": "set_bit_00001778"
        },
        "FUN_000026d8": {
            "renaming": {
                "FUN_000026d8": "set_flag_and_return_000026d8",
                "set_flag_on_0000294c": "set_flag"
            },
            "code": "void set_flag_and_return_000026d8(void)\n{\n  set_flag();\n  return;\n}",
            "called": [
                "FUN_0000294c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026d8",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "set_flag_and_return_000026d8"
        },
        "FUN_00000566": {
            "renaming": {
                "FUN_00000566": "get_leading_zero_bits_count_00000566",
                "param_1": "value",
                "bVar1": "byte_4",
                "bVar2": "byte_1",
                "bVar3": "byte_2",
                "bVar4": "byte_3",
                "uVar5": "count"
            },
            "code": "uint32_t get_leading_zero_bits_count_00000566(uint32_t value)\n{\n    uint32_t count = 0;\n    while (value)\n    {\n        count++;\n        value >>= 1;\n    }\n    return 32 - count;\n}\n\nuint32_t count_leading_zeroes(uint32_t value)\n{\n    if (value == 0)\n    {\n        return 32;\n    }\n    return get_leading_zero_bits_count_00000566(value);\n}\n\nuint32_t get_leading_zero_bits_count_00000566(uint32_t param_1)\n{\n    uint8_t byte_1 = (uint8_t)param_1;\n    uint8_t byte_2 = (uint8_t)(param_1 >> 8);\n    uint8_t byte_3 = (uint8_t)(param_1 >> 16);\n    uint8_t byte_4 = (uint8_t)(param_1 >> 24);\n    uint32_t value = ((byte_1 & 1) << 24 | (byte_1 & 2) << 21 | (byte_1 & 4) << 18 | (byte_1 & 8) << 15 | (byte_1 & 16) << 12 | (byte_1 & 32) << 9 | (byte_1 & 64) << 6 | (byte_1 & 128) << 3) | ((byte_2 & 1) << 16 | (byte_2 & 2) << 13 | (byte_2 & 4) << 10 | (byte_2 & 8) << 7 | (byte_2 & 16) << 4 | (byte_2 & 32) << 1 | (byte_2 & 64) >> 2 | (byte_2 & 128) >> 5) | ((byte_3 & 1) << 8 | (byte_3 & 2) << 5 | (byte_3 & 4) << 2 | (byte_3 & 8) >> 1 | (byte_3 & 16) >> 4 | (byte_3 & 32) >> 7 | (byte_3 & 64) >> 10 | (byte_3 & 128) >> 13) | ((byte_4 & 1) | (byte_4 & 2) >> 3 | (byte_4 & 4) >> 6 | (byte_4 & 8) >> 9 | (byte_4 & 16) >> 12 | (byte_4 & 32) >> 15 | (byte_4 & 64) >> 18 | (byte_4 & 128) >> 21);\n    return count_leading_zeroes(value);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000566",
            "calling": [
                "FUN_00000610"
            ],
            "imported": false,
            "current_name": "get_leading_zero_bits_count_00000566"
        },
        "FUN_00001d08": {
            "renaming": {
                "FUN_00001d08": "calculate_offset_00001d08",
                "param_1": "address",
                "param_2": "index",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int calculate_offset_00001d08(uint32_t address, int index) {\n    uint32_t masked_address = address & 0xf0000000;\n    uint32_t lower_bits = address & 0xfffff;\n    uint32_t shifted_lower_bits = lower_bits << 5;\n    int offset = (index * 4) + masked_address + shifted_lower_bits + 0x2000000;\n    return offset;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d08",
            "calling": [
                "FUN_00001d3a"
            ],
            "imported": false,
            "current_name": "calculate_offset_00001d08"
        },
        "FUN_000031fc": {
            "renaming": {
                "FUN_000031fc": "calculate_result_000031fc",
                "param_1": "input_value",
                "param_2": "input_limit",
                "param_3": "initial_value",
                "iVar2": "limit_value",
                "bVar1": "limit_byte",
                "iVar3": "result_value"
            },
            "code": "int calculate_result_000031fc(int input_value, int input_limit, int initial_value)\n{\n  int limit_value = input_limit;\n  if (input_limit < 3) {\n    limit_value = 1;\n  }\n  byte limit_byte = (byte)limit_value;\n  if (2 < input_limit) {\n    limit_byte = 0;\n  }\n  input_value = input_value - (uint)limit_byte;\n  int result_value = input_value;\n  if (input_value < 0) {\n    result_value = input_value + 3;\n  }\n  result_value = (((result_value >> 2) + input_value) - (int)((longlong)PTR_DAT_00003280 * (longlong)input_value >> 0x25)) + (int)((longlong)PTR_DAT_00003280 * (longlong)input_value >> 0x27) + *(int *)(PTR_DAT_00003284 + (input_limit + -1) * 4) + initial_value;\n  return result_value + (((int)((ulonglong)((longlong)PTR_DAT_00003288 * (longlong)result_value) >> 0x20) + result_value >> 2) - (result_value >> 0x1f)) * -7;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031fc",
            "calling": [
                "FUN_0000328c"
            ],
            "imported": false,
            "current_name": "calculate_result_000031fc"
        },
        "FUN_000016ec": {
            "renaming": {
                "FUN_000016ec": "set_result_to_one_000016ec",
                "param_1": "input1",
                "param_2": "input2",
                "puVar1": "result_pointer"
            },
            "code": "void set_result_to_one_000016ec(int input1, char input2) {\n  undefined *result_pointer;\n  result_pointer = (undefined *)calculate_result(input1, input2);\n  *result_pointer = 1;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016ec",
            "calling": [
                "FUN_00001a18",
                "FUN_00001778",
                "FUN_00001a3c",
                "FUN_0000182c",
                "FUN_00001a60"
            ],
            "imported": false,
            "current_name": "set_result_to_one_000016ec"
        },
        "FUN_00005100": {
            "renaming": {
                "FUN_00005100": "FUNC_00005100"
            },
            "code": "\nvoid FUNC_00005100(void)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined4 *puVar3;\n  undefined4 uVar4;\n  int iVar5;\n  char *pcVar6;\n  int iVar7;\n  int iVar8;\n  char cVar9;\n  char *pcVar10;\n  bool bVar11;\n  ushort *puVar12;\n  int *piVar13;\n  ushort *puVar14;\n  int *piVar15;\n  ushort local_3c;\n  ushort local_3a;\n  ushort local_38;\n  ushort local_36;\n  ushort local_34;\n  ushort local_32;\n  int local_30;\n  char *local_2c [2];\n  \n  uVar4 = *DAT_00005108;\n  iVar5 = get_data_000056b0();\n  puVar1 = PTR_DAT_000053d8;\n  pcVar6 = (char *)find_key_value_pair_000056a0(uVar4,PTR_DAT_000053d4);\n  puVar2 = PTR_DAT_000053e0;\n  if (pcVar6 == (char *)0x0) {\n    *(undefined4 *)PTR_DAT_000053dc = 0;\n    *(undefined4 *)PTR_DAT_000053e4 = 0;\n    puVar3 = DAT_000053e8;\n    uVar4 = *(undefined4 *)puVar1;\n    *DAT_000053e8 = puVar2;\n    puVar3[1] = puVar2;\n    insert_node_to_list_00005780(uVar4);\n    *(undefined4 *)puVar1 = 0;\n  }\n  else if ((*(int *)puVar1 == 0) || (iVar7 = compare_byte_arrays_00004e52(), iVar7 != 0)) {\n    insert_node_to_list_00005780(*(undefined4 *)puVar1);\n    iVar7 = find_end_of_string_00005ecc(pcVar6);\n    iVar7 = allocate_memory_00004bd0(uVar4,iVar7 + 1);\n    *(int *)puVar1 = iVar7;\n    if (iVar7 != 0) {\n      copy_string_00005ebc(iVar7,pcVar6);\n    }\n    if (*pcVar6 == ':') {\n      pcVar6 = pcVar6 + 1;\n    }\n    iVar7 = parse_string_and_call_function_00005e68(pcVar6,PTR_s__10__0_9_____n_000053f0,PTR_DAT_000053ec,&local_30);\n    if (0 < iVar7) {\n      pcVar10 = pcVar6 + local_30;\n      if (pcVar6[local_30] == '-') {\n        pcVar10 = pcVar10 + 1;\n        iVar7 = -1;\n      }\n      else {\n        if (pcVar6[local_30] == '+') {\n          pcVar10 = pcVar10 + 1;\n        }\n        iVar7 = 1;\n      }\n      local_3a = 0;\n      local_38 = 0;\n      puVar12 = &local_3a;\n      piVar13 = &local_30;\n      puVar14 = &local_38;\n      piVar15 = &local_30;\n      iVar8 = parse_string_and_call_function_00005e68(pcVar10,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a,\n                           &local_30,&local_38,&local_30);\n      puVar1 = PTR_DAT_00005400;\n      if (0 < iVar8) {\n        *(uint *)(iVar5 + 0x28) =\n             ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar7;\n        puVar3 = DAT_000053e8;\n        *DAT_000053e8 = PTR_DAT_000053ec;\n        pcVar10 = pcVar10 + local_30;\n        iVar7 = parse_string_and_call_function_00005e68(pcVar10,PTR_s__10__0_9_____n_000053f0,puVar1,&local_30,puVar12,piVar13,\n                             puVar14,piVar15);\n        if (iVar7 < 1) {\n          puVar3[1] = *puVar3;\n          *(undefined4 *)PTR_DAT_000053dc = *(undefined4 *)(iVar5 + 0x28);\n          *(undefined4 *)PTR_DAT_000053e4 = 0;\n        }\n        else {\n          puVar3[1] = puVar1;\n          pcVar6 = pcVar10 + local_30;\n          if (pcVar10[local_30] == '-') {\n            pcVar6 = pcVar6 + 1;\n            iVar7 = -1;\n          }\n          else {\n            if (pcVar10[local_30] == '+') {\n              pcVar6 = pcVar6 + 1;\n            }\n            iVar7 = 1;\n          }\n          local_3c = 0;\n          local_3a = 0;\n          local_38 = 0;\n          local_30 = 0;\n          iVar8 = parse_string_and_call_function_00005e68(pcVar6,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a\n                               ,&local_30,&local_38,&local_30);\n          if (iVar8 < 1) {\n            iVar7 = *(int *)(iVar5 + 0x28) + -0xe10;\n          }\n          else {\n            iVar7 = ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar7;\n          }\n          *(int *)(iVar5 + 0x50) = iVar7;\n          pcVar6 = pcVar6 + local_30;\n          bVar11 = false;\n          iVar7 = iVar5;\n          while( true ) {\n            if (*pcVar6 == ',') {\n              pcVar6 = pcVar6 + 1;\n            }\n            cVar9 = *pcVar6;\n            if (cVar9 == 'M') {\n              iVar8 = parse_string_and_call_function_00005e68(pcVar6,PTR_s_M_hu_n__hu_n__hu_n_000053f8,&local_36,&local_30,\n                                   &local_34,&local_30,&local_32,&local_30);\n              if (iVar8 != 3) {\n                return;\n              }\n              if (0xb < local_36 - 1) {\n                return;\n              }\n              if (4 < local_34 - 1) {\n                return;\n              }\n              if (6 < local_32) {\n                return;\n              }\n              *(uint *)(iVar7 + 0xc) = (uint)local_36;\n              *(uint *)(iVar7 + 0x10) = (uint)local_34;\n              *(undefined *)(iVar7 + 8) = 0x4d;\n              *(uint *)(iVar7 + 0x14) = (uint)local_32;\n              pcVar10 = pcVar6 + local_30;\n            }\n            else {\n              if (cVar9 == 'J') {\n                pcVar6 = pcVar6 + 1;\n              }\n              else {\n                cVar9 = 'D';\n              }\n              local_32 = parseUnsignedInt_00005fd8(pcVar6,local_2c,10);\n              pcVar10 = local_2c[0];\n              if (local_2c[0] == pcVar6) {\n                if (bVar11) {\n                  *(undefined *)(iVar5 + 0x30) = 0x4d;\n                  *(undefined4 *)(iVar5 + 0x34) = 0xb;\n                  *(undefined4 *)(iVar5 + 0x38) = 1;\n                  *(undefined4 *)(iVar5 + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(iVar5 + 8) = 0x4d;\n                  *(undefined4 *)(iVar5 + 0xc) = 3;\n                  *(undefined4 *)(iVar5 + 0x10) = 2;\n                  *(undefined4 *)(iVar5 + 0x14) = 0;\n                }\n              }\n              else {\n                *(char *)(iVar7 + 8) = cVar9;\n                *(uint *)(iVar7 + 0x14) = (uint)local_32;\n              }\n            }\n            local_3c = 2;\n            local_3a = 0;\n            local_38 = 0;\n            local_30 = 0;\n            if (*pcVar10 == '/') {\n              parse_string_and_call_function_00005e68(pcVar10,PTR_DAT_000053fc,&local_3c,&local_30,&local_3a,&local_30,\n                           &local_38,&local_30);\n            }\n            *(uint *)(iVar7 + 0x18) =\n                 (uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38;\n            iVar7 = iVar7 + 0x28;\n            pcVar6 = pcVar10 + local_30;\n            if (bVar11) break;\n            bVar11 = true;\n          }\n          calculate_week_number_for_year_00004f98(*(undefined4 *)(iVar5 + 4));\n          iVar7 = *(int *)(iVar5 + 0x28);\n          *(int *)PTR_DAT_000053dc = iVar7;\n          iVar7 = *(int *)(iVar5 + 0x50) - iVar7;\n          if (iVar7 != 0) {\n            iVar7 = 1;\n          }\n          *(int *)PTR_DAT_000053e4 = iVar7;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00005ecc",
                "FUN_00005e68",
                "FUN_00005ebc",
                "FUN_00004e52",
                "FUN_000056a0",
                "FUN_00005780",
                "FUN_00004f98",
                "FUN_000056b0",
                "FUN_00004bd0",
                "FUN_00005fd8"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00005100",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "FUNC_00005100"
        },
        "FUN_00005584": {
            "renaming": {
                "FUN_00005584": "divide_and_remainder_00005584",
                "param_1": "output",
                "param_2": "dividend",
                "param_3": "divisor",
                "uVar1": "remainder",
                "uVar2": "quotient"
            },
            "code": "void divide_and_remainder_00005584(uint *output, uint dividend, uint divisor)\n{\n  uint quotient;\n  uint remainder;\n  quotient = dividend / divisor;\n  remainder = dividend % divisor;\n  if ((int)dividend < 0) {\n    if (0 < (int)remainder) {\n      quotient = quotient - 1;\n      remainder = remainder + divisor;\n    }\n  }\n  else if ((int)remainder < 0) {\n    quotient = quotient + 1;\n    remainder = remainder - divisor;\n  }\n  *output = quotient;\n  output[1] = remainder;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005584",
            "calling": [
                "FUN_00004634"
            ],
            "imported": false,
            "current_name": "divide_and_remainder_00005584"
        },
        "FUN_00004248": {
            "renaming": {
                "FUN_00004248": "allocate_and_initialize_array_00004248",
                "param_1": "memory_block",
                "param_2": "array_size",
                "puVar1": "array_pointer",
                "iVar2": "array_offset"
            },
            "code": "undefined4* allocate_and_initialize_array_00004248(undefined4 memory_block, int array_size)\n{\n  undefined4* array_pointer;\n  int array_offset = (array_size - 1) * 0x68;\n  array_pointer = (undefined4*)allocate_memory_00004bd0(memory_block, array_offset + 0x74);\n  if (array_pointer != (undefined4*)0x0) {\n    *array_pointer = 0;\n    array_pointer[1] = array_size;\n    array_pointer[2] = array_pointer + 3;\n    fill_array_with_value_00004622(array_pointer + 3, 0, array_offset + 0x68);\n  }\n  return array_pointer;\n}",
            "called": [
                "FUN_00004bd0",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004248",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_array_00004248"
        },
        "FUN_00001da2": {
            "renaming": {
                "FUN_00001da2": "getBitsFromRight_00001da2",
                "param_1": "input",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "ushort getBitsFromRight_00001da2(ushort input, int numBits) {\n    ushort shifted = input >> (numBits - 1);\n    return shifted & ((1 << numBits) - 1);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001da2",
            "calling": [
                "FUN_00001f80",
                "FUN_00001ddc"
            ],
            "imported": false,
            "current_name": "getBitsFromRight_00001da2"
        },
        "FUN_00001ec4": {
            "renaming": {
                "FUN_00001ec4": "update_data_with_bits_at_index_00001ec4",
                "param_1": "index",
                "param_2": "num_bits",
                "uVar1": "bits",
                "get_bits_00001e0c": "get_bits",
                "update_data_at_index_00001e44": "update_data_at_index"
            },
            "code": "void update_data_with_bits_at_index_00001ec4(int index, int num_bits)\n{\n  int bits = get_bits(index, num_bits);\n  update_data_at_index(index, num_bits, bits);\n  return;\n}",
            "called": [
                "FUN_00001e44",
                "FUN_00001e0c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ec4",
            "calling": [
                "FUN_00001f80"
            ],
            "imported": false,
            "current_name": "update_data_with_bits_at_index_00001ec4"
        },
        "FUN_00002744": {
            "renaming": {
                "FUN_00002744": "update_data_00002744",
                "param_1": "data",
                "param_2": "value",
                "DAT_00002790": "data_array_ptr",
                "DAT_00002794": "data_array_ptr_2"
            },
            "code": "void update_data_00002744(byte data, uint16_t value) {\n  if (data < 0) {\n    *(char *)((data & 0xf) + DAT_00002790 + 0x14) = (char)((value & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)data + DAT_00002794 + 0x300) = (char)((value & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002744",
            "calling": [
                "FUN_00002894"
            ],
            "imported": false,
            "current_name": "update_data_00002744"
        },
        "FUN_00002624": {
            "renaming": {
                "FUN_00002624": "convert_seconds_to_date_time_00002624",
                "param_1": "seconds",
                "local_10": "first_matching_byte",
                "uStack_c": "zero",
                "find_first_matching_byte_0000281c": "find_first_matching_byte",
                "convert_seconds_to_date_time_0000443c": "convert_seconds_to_date_time"
            },
            "code": "int convert_seconds_to_date_time_00002624(unsigned int* matching_byte, unsigned int seconds) {\n  unsigned int first_matching_byte = find_first_matching_byte();\n  unsigned int zero = 0;\n  convert_seconds_to_date_time_00002624(&first_matching_byte, seconds);\n  return 0;\n}",
            "called": [
                "FUN_0000443c",
                "FUN_0000281c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002624",
            "calling": [
                "FUN_00003444"
            ],
            "imported": false,
            "current_name": "convert_seconds_to_date_time_00002624"
        },
        "FUN_00001e0c": {
            "renaming": {
                "FUN_00001e0c": "get_bits_00001e0c",
                "param_1": "index",
                "param_2": "num",
                "PTR_DAT_00001e40": "ptr_data"
            },
            "code": "uint get_bits_00001e0c(uint index, uint num)\n{\n    uint* ptr = (uint*)(PTR_DAT_00001e40 + (((int)num >> 3) + index * 4) * 4);\n    uint shift = (num & 7) << 2;\n    return (*ptr >> shift) & 0xf;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e0c",
            "calling": [
                "FUN_00002028",
                "FUN_00001ec4"
            ],
            "imported": false,
            "current_name": "get_bits_00001e0c"
        },
        "FUN_00000ef8": {
            "renaming": {
                "FUN_00000ef8": "do_nothing_00000ef8"
            },
            "code": "\nvoid do_nothing_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ef8",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "do_nothing_00000ef8"
        },
        "FUN_000041d0": {
            "renaming": {
                "FUN_000041d0": "process_data_000041d0",
                "param_1": "data",
                "pcVar1": "callback_function",
                "iVar2": "count",
                "piVar5": "data_structure_ptr",
                "uVar7": "result",
                "iVar6": "next_structure_ptr",
                "iVar8": "current_offset",
                "puVar9": "data_ptr",
                "uVar3": "callback_result",
                "iVar4": "function_arg_4"
            },
            "code": "uint process_data_000041d0(int data, undefined4 param_2, undefined4 param_3)\n{\n  code *callback_function;\n  int count;\n  uint result;\n  int current_offset;\n  int *data_structure_ptr;\n  int next_structure_ptr;\n  uint callback_result;\n  int function_arg_4;\n  undefined *data_ptr;\n  \n  callback_function = DAT_000041ec;\n  if (data == 0) {\n    count = *(int *)PTR_DAT_000041e8;\n    data_structure_ptr = (int *)(count + 0x48);\n    result = 0;\n    data_ptr = PTR_DAT_000041e8;\n    do {\n      current_offset = data_structure_ptr[1];\n      next_structure_ptr = data_structure_ptr[2];\n      while (current_offset = current_offset + -1, -1 < current_offset) {\n        if ((1 < *(ushort *)(next_structure_ptr + 0xc)) && (function_arg_4 = *(short *)(next_structure_ptr + 0xe) + 1, function_arg_4 != 0)) {\n          callback_result = (*callback_function)(count, next_structure_ptr, param_3, function_arg_4, data_ptr);\n          result = result | callback_result;\n        }\n        next_structure_ptr = next_structure_ptr + 0x68;\n      }\n      data_structure_ptr = (int *)*data_structure_ptr;\n    } while (data_structure_ptr != (int *)0x0);\n    return result;\n  }\n  result = decode_and_do_nothing_00004158(*DAT_000041f0, data);\n  return result;\n}",
            "called": [
                "FUN_00004158"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041d0",
            "calling": [
                "FUN_00002e48"
            ],
            "imported": false,
            "current_name": "process_data_000041d0"
        },
        "FUN_0000459c": {
            "renaming": {
                "FUN_0000459c": "executeFunctionsInPointers_0000459c",
                "PTR_DAT_000045d4": "startPointer",
                "PTR_DAT_000045d8": "endPointer",
                "PTR_DAT_000045dc": "startPointer2",
                "PTR_DAT_000045e0": "endPointer2",
                "iVar3": "numFunctions",
                "ppcVar4": "functionPointers",
                "iVar5": "i",
                "puVar1": "unusedPointer1",
                "puVar2": "unusedPointer2"
            },
            "code": "void executeFunctionsInPointers_0000459c()\n{\n    undefined *PTR_DAT_000045d4 = PTR_DAT_000045d4;\n    undefined *PTR_DAT_000045d8 = PTR_DAT_000045d8;\n    int numFunctions = (int)PTR_DAT_000045d8 - (int)PTR_DAT_000045d4;\n    code **functionPointers = (code **)PTR_DAT_000045d4;\n    for (int i = 0; i < numFunctions / 4; i++) {\n        (**functionPointers)();\n        functionPointers++;\n    }\n    initializeLinkedListAndUpdateArray_00000410();\n    PTR_DAT_000045d4 = PTR_DAT_000045dc;\n    PTR_DAT_000045d8 = PTR_DAT_000045e0;\n    numFunctions = (int)PTR_DAT_000045d8 - (int)PTR_DAT_000045d4;\n    functionPointers = (code **)PTR_DAT_000045d4;\n    for (int i = 0; i < numFunctions / 4; i++) {\n        (**functionPointers)();\n        functionPointers++;\n    }\n}",
            "called": [
                "FUN_00000410"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000459c",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "executeFunctionsInPointers_0000459c"
        },
        "FUN_000014c4": {
            "renaming": {
                "FUN_000014c4": "set_bit_in_integer_array_000014c4",
                "param_1": "array_index",
                "param_2": "divisor",
                "pbVar1": "byte_array",
                "uVar2": "byte_array_length",
                "uVar3": "quotient"
            },
            "code": "void set_bit_in_integer_array_000014c4(int array_index) {\n    byte *byte_array = *(byte **)(PTR_DAT_000015cc + array_index * 0x20);\n    uint byte_array_length = *(uint *)(PTR_DAT_000015cc + array_index * 0x20 + 4);\n    byte_array[3] &= 0xf3;\n    byte_array[2] = PTR_DAT_000015cc[array_index * 0x20 + 0x1d];\n    uint quotient = byte_array_length / (param_2 << 4);\n    *byte_array = (byte)(quotient >> 8) & 0x1f;\n    byte_array[1] = (byte)quotient;\n    byte_array[10] = (byte)((byte_array_length << 2) / param_2 + 1 >> 1) & 0x1f;\n    byte_array[0x10] |= 0x88;\n    if ((byte_array[0x10] & 0x70) == 0) {\n        byte_array[0x13] = 0;\n    }\n    else {\n        byte_array[0x13] = (char)(2 << (byte_array[0x10] >> 4 & 7)) - 1;\n    }\n    byte_array[0x15] = 1;\n    byte_array[0x11] = 0xc0;\n    byte_array[3] |= 0x2c;\n    set_bit_in_integer_array_000014c4_00001318((int)(char)PTR_DAT_000015cc[array_index * 0x20 + 0x14]);\n}",
            "called": [
                "FUN_00001318"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000014c4",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "set_bit_in_integer_array_000014c4"
        },
        "FUN_00004b34": {
            "renaming": {
                "FUN_00004b34": "insert_node_00004b34",
                "param_1": "errorCode",
                "param_2": "node",
                "param_3": "nodeSize",
                "param_4": "head",
                "puVar1": "ptr",
                "piVar2": "currNode",
                "extraout_r1": "prevNode",
                "ppiVar3": "prevNodePtr",
                "ppiVar4": "currNodePtr",
                "ppiVar5": "nextNodePtr",
                "ppiVar6": "nodePtr",
                "bVar7": "isHead",
                "PTR_DAT_00004bcc": "headPtr"
            },
            "code": "void insert_node_00004b34(int* errorCode, int* node, int nodeSize, int* head) {\n    if (nodeSize == 0) {\n        return;\n    }\n    int** nodePtr = (int**)(node + nodeSize - sizeof(int*));\n    if (*nodePtr < 0) {\n        nodePtr = (int**)((int)nodePtr + **nodePtr);\n    }\n    do_nothing_with_pointer_00005790();\n    int** PTR_DAT_00004bcc = *(int***)PTR_DAT_00004bcc;\n    if (PTR_DAT_00004bcc == NULL) {\n        nodePtr[1] = NULL;\n        *(int***)PTR_DAT_00004bcc = nodePtr;\n        int** prevNodePtr = (int**)extraout_r1;\n        int** currNodePtr = (int**)PTR_DAT_00004bcc;\n    } else if (nodePtr < PTR_DAT_00004bcc) {\n        int** currNodePtr = *nodePtr;\n        int** nextNodePtr = (int**)((int)nodePtr + (int)currNodePtr);\n        bool isHead = PTR_DAT_00004bcc == nextNodePtr;\n        if (isHead) {\n            nextNodePtr = (int**)*PTR_DAT_00004bcc;\n            PTR_DAT_00004bcc = (int**)PTR_DAT_00004bcc[1];\n        }\n        nodePtr[1] = (int*)PTR_DAT_00004bcc;\n        if (isHead) {\n            nextNodePtr = (int**)((int)nextNodePtr + (int)currNodePtr);\n            *nodePtr = (int*)nextNodePtr;\n        }\n        *(int***)PTR_DAT_00004bcc = nodePtr;\n        int** prevNodePtr = NULL;\n    } else {\n        int** currNodePtr = PTR_DAT_00004bcc;\n        int** nextNodePtr;\n        do {\n            nextNodePtr = (int**)currNodePtr[1];\n            if (nextNodePtr == NULL) break;\n        } while (nextNodePtr <= nodePtr);\n        int** prevNodePtr = (int**)*currNodePtr;\n        if ((int**)((int)currNodePtr + (int)prevNodePtr) == nodePtr) {\n            prevNodePtr = (int**)((int)prevNodePtr + (int)*nodePtr);\n            *currNodePtr = (int*)prevNodePtr;\n            if (nextNodePtr == (int**)((int)currNodePtr + (int)prevNodePtr)) {\n                int* nextNode = *nextNodePtr;\n                currNodePtr[1] = nextNodePtr[1];\n                prevNodePtr = (int**)((int)prevNodePtr + (int)nextNode);\n                *currNodePtr = (int*)prevNodePtr;\n            }\n        } else if (nodePtr < (int**)((int)currNodePtr + (int)prevNodePtr)) {\n            *errorCode = 12;\n        } else {\n            int** nextNodePtr = (int**)((int)nodePtr + (int)*nodePtr);\n            bool isNextHead = PTR_DAT_00004bcc == nextNodePtr;\n            if (isNextHead) {\n                nextNodePtr = (int**)*PTR_DAT_00004bcc;\n                PTR_DAT_00004bcc = (int**)PTR_DAT_00004bcc[1];\n            }\n            nodePtr[1] = (int*)PTR_DAT_00004bcc;\n            if (isNextHead) {\n                nextNodePtr = (int**)((int)nextNodePtr + (int)*nodePtr);\n                *nodePtr = (int*)nextNodePtr;\n            }\n            prevNodePtr = (int**)nodePtr[1];\n            currNodePtr[1] = (int*)nodePtr;\n        }\n    }\n    do_nothing_with_pointer_0000579c(errorCode, prevNodePtr, currNodePtr, head);\n    return;\n}",
            "called": [
                "FUN_0000579c",
                "FUN_00005790"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004b34",
            "calling": [
                "FUN_0000404c",
                "FUN_00005780",
                "FUN_000060cc",
                "FUN_000054a8",
                "FUN_00006768",
                "FUN_00006192"
            ],
            "imported": false,
            "current_name": "insert_node_00004b34"
        },
        "FUN_000004f2": {
            "renaming": {
                "FUN_000004f2": "set_param_to_19_000004f2",
                "*param_1": "*param_pointer"
            },
            "code": "int set_param_to_19_000004f2(int *param_pointer)\n{\n  int new_value = 19;\n  *param_pointer = new_value;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004f2",
            "calling": [
                "FUN_00004e26",
                "FUN_00004dee"
            ],
            "imported": false,
            "current_name": "set_param_to_19_000004f2"
        },
        "FUN_00004e66": {
            "renaming": {
                "FUN_00004e66": "compare_strings_00004e66",
                "param_1": "string1",
                "param_2": "string1_len",
                "param_3": "string2",
                "pbVar1": "char1_ptr",
                "pbVar2": "char2_ptr",
                "uVar3": "current_char"
            },
            "code": "int compare_strings_00004e66(byte *string1, int string1_len, byte *string2)\n{\n  byte *char1_ptr;\n  byte *char2_ptr;\n  uint8_t current_char;\n  \n  if (string2 != 0) {\n    char2_ptr = (byte *)(string1 + -1);\n    char1_ptr = string1;\n    do {\n      current_char = (uint8_t)*char1_ptr;\n      char2_ptr = char2_ptr + 1;\n      if ((current_char != *char2_ptr) || (char1_ptr + 1 == string1 + string1_len)) break;\n      char1_ptr = char1_ptr + 1;\n    } while (current_char != 0);\n    string1_len = current_char - *char2_ptr;\n  }\n  return string1_len;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e66",
            "calling": [
                "FUN_00003524",
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "compare_strings_00004e66"
        },
        "FUN_00005ecc": {
            "renaming": {
                "FUN_00005ecc": "find_end_of_string_00005ecc",
                "param_1": "input_string",
                "pcVar3": "current_ptr",
                "pcVar2": "next_ptr",
                "cVar1": "current_char"
            },
            "code": "char* find_end_of_string_00005ecc(char* input_string) {\n  char current_char;\n  char* current_ptr = input_string;\n  do {\n    current_ptr++;\n    current_char = *current_ptr;\n  } while (current_char != '\\0');\n  return current_ptr + (-1 - (int)input_string);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ecc",
            "calling": [
                "FUN_00005e68",
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "find_end_of_string_00005ecc"
        },
        "FUN_0000129c": {
            "renaming": {
                "FUN_0000129c": "handle_interrupt_on_flag_change_0000129c",
                "param_1": "flag"
            },
            "code": "void handle_interrupt_on_flag_change_0000129c(uint32_t flag) {\n  handle_interrupt_00002434(flag, 1);\n  return;\n}",
            "called": [
                "FUN_00002434"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000129c",
            "calling": [
                "FUN_000012e2"
            ],
            "imported": false,
            "current_name": "handle_interrupt_on_flag_change_0000129c"
        },
        "FUN_00001628": {
            "renaming": {
                "FUN_00001628": "check_and_call_function_00001628",
                "param_1": "index",
                "PTR_DAT_00001680": "data_ptr",
                "PTR_DAT_00001684": "func_ptr",
                "*(byte *)(*(int *)(PTR_DAT_00001680 + param_1 * 0x20) + 4)": "flag_ptr",
                "*(int *)(PTR_DAT_00001684 + param_1 * 8)": "func_ptr",
                "(*(code **)(PTR_DAT_00001684 + param_1 * 8))": "(*func_ptr)",
                "*(undefined4 *)(PTR_DAT_00001684 + param_1 * 8 + 4)": "arg_ptr",
                "*(undefined *)(*(int *)(PTR_DAT_00001680 + param_1 * 0x20) + 7)": "char_ptr"
            },
            "code": "void check_and_call_function_00001628(int index)\n{\n  int* PTR_DAT_00001680 = *(int *)(PTR_DAT_00001680 + index * 0x20);\n  int* PTR_DAT_00001684 = *(int *)(PTR_DAT_00001684 + index * 8);\n  byte* *(byte *)(*(int *)(PTR_DAT_00001680 + param_1 * 0x20) + 4) = (byte*)(PTR_DAT_00001680 + 4);\n  int* *(undefined4 *)(PTR_DAT_00001684 + param_1 * 8 + 4) = (int*)(PTR_DAT_00001684 + index * 8 + 4);\n  char* *(undefined *)(*(int *)(PTR_DAT_00001680 + param_1 * 0x20) + 7) = (char*)(PTR_DAT_00001680 + 7);\n  \n  if ((**(byte *)(*(int *)(PTR_DAT_00001680 + param_1 * 0x20) + 4) & 0x20) && (*PTR_DAT_00001684 != 0)) {\n    (**(code **)(PTR_DAT_00001684 + index * 8))(**(undefined4 *)(PTR_DAT_00001684 + param_1 * 8 + 4), **(undefined *)(*(int *)(PTR_DAT_00001680 + param_1 * 0x20) + 7));\n  }\n  check_flag_and_set_00001348();\n  return;\n}",
            "called": [
                "FUN_00001348"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001628",
            "calling": [
                "FUN_00001688"
            ],
            "imported": false,
            "current_name": "check_and_call_function_00001628"
        },
        "FUN_00001748": {
            "renaming": {
                "FUN_00001748": "set_param_1_00001748",
                "param_1": "new_param",
                "*(byte *)(DAT_00001774 + 3)": "data",
                "*(byte *)(DAT_00001774 + 3) & 0x1f": "0x1f",
                "DAT_00001774": "PTR_DATA"
            },
            "code": "void set_param_1_00001748(byte new_param){\n    byte* *(byte *)(DAT_00001774 + 3) = (byte*)(DAT_00001774 + 3);\n    byte old_val = **(byte *)(DAT_00001774 + 3);\n    byte masked_new_val = new_param | (old_val & *(byte *)(DAT_00001774 + 3) & 0x1f);\n    **(byte *)(DAT_00001774 + 3) = masked_new_val;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001748",
            "calling": [
                "FUN_000019c0",
                "FUN_00001bb8",
                "FUN_00001960",
                "FUN_0000191c",
                "FUN_000018bc"
            ],
            "imported": false,
            "current_name": "set_param_1_00001748"
        },
        "FUN_0000294c": {
            "renaming": {
                "FUN_0000294c": "set_flag_on_0000294c",
                "DAT_0000296c": "data_ptr",
                "PTR_": "ptr_",
                "DAT_": "data_"
            },
            "code": "void set_flag_on_0000294c(uint32_t* DAT_0000296c) {\n    uint32_t* flag_ptr = DAT_0000296c + 0x14;\n    *flag_ptr |= 0x10;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000294c",
            "calling": [
                "FUN_000027b0",
                "FUN_000026d8"
            ],
            "imported": false,
            "current_name": "set_flag_on_0000294c"
        },
        "FUN_00005790": {
            "renaming": {
                "FUN_00005790": "do_nothing_with_pointer_00005790",
                "PTR_DAT_00005798": "PTR_DATA"
            },
            "code": "void do_nothing_with_pointer_00005790(void)\n{\n  do_nothing(PTR_DAT_00005798);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005790",
            "calling": [
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_00005790"
        },
        "FUN_00000534": {
            "renaming": {
                "FUN_00000534": "is_param_valid_00000534",
                "param_1": "param_array",
                "param_2": "param_length",
                "uVar1": "is_valid"
            },
            "code": "int is_param_valid_00000534(int *param_array, int param_length) {\n    int is_valid = 0;\n    if (param_length == 0 || param_length == 1 || param_length == 2) {\n        is_valid = 1;\n    }\n    *param_array = 0;\n    return is_valid;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000534",
            "calling": [
                "FUN_00005700"
            ],
            "imported": false,
            "current_name": "is_param_valid_00000534"
        },
        "FUN_000017dc": {
            "renaming": {
                "FUN_000017dc": "calculateResultAndReturn_000017dc",
                "DAT_00001820": "resultPointer",
                "DAT_00001824": "flagPointer",
                "DAT_00001828": "dataPointer"
            },
            "code": "void calculateResultAndReturn_000017dc() {\n    set_calculated_result_to_one_and_return_000016c8(DAT_00001820, 29);\n    if ((*(uint *)(DAT_00001824 + 0x10) & 0x100) == 0) {\n        *(undefined4 *)(DAT_00001824 + 0x10) = 0x104;\n    }\n    *DAT_00001828 = *DAT_00001828 & 0xfff3ffff | 0x80000;\n    return;\n}",
            "called": [
                "FUN_000016c8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000017dc",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "calculateResultAndReturn_000017dc"
        },
        "FUN_00000410": {
            "renaming": {
                "FUN_00000410": "initializeLinkedListAndUpdateArray_00000410",
                "initializeLinkedListAndUpdateArray_00000df4": "initialize_linked_list"
            },
            "code": "void initializeLinkedListAndUpdateArray_00000410() {\n  initialize_linked_list();\n  return;\n}",
            "called": [
                "FUN_00000df4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000410",
            "calling": [
                "FUN_0000459c"
            ],
            "imported": false,
            "current_name": "initializeLinkedListAndUpdateArray_00000410"
        },
        "FUN_000005ca": {
            "renaming": {
                "FUN_000005ca": "remove_first_element_from_list_000005ca",
                "param_1": "list_ptr",
                "puVar1": "first_element_ptr"
            },
            "code": "undefined4* remove_first_element_from_list_000005ca(int* list_ptr) {\n  undefined4* first_element_ptr;\n  if (*list_ptr == 0) {\n    first_element_ptr = NULL;\n  }\n  else {\n    first_element_ptr = *(undefined4**)*list_ptr;\n    if (first_element_ptr == (undefined4*)*list_ptr) {\n      *list_ptr = 0;\n    }\n    else {\n      *(undefined4*)*list_ptr = *first_element_ptr;\n    }\n  }\n  return first_element_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000005ca",
            "calling": [
                "FUN_00000698"
            ],
            "imported": false,
            "current_name": "remove_first_element_from_list_000005ca"
        },
        "FUN_00005ff8": {
            "renaming": {
                "FUN_00005ff8": "do_nothing_with_data_00005ff8",
                "DAT_00006000": "DAT_DATA"
            },
            "code": "void do_nothing_with_data_00005ff8(void)\n{\n  do_nothing(DAT_00006000);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ff8",
            "calling": [
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "do_nothing_with_data_00005ff8"
        },
        "FUN_00002714": {
            "renaming": {
                "FUN_00002714": "set_bit_in_array_00002714",
                "param_1": "bit_index",
                "DAT_00002740": "array_ptr",
                "uint": "uint32_t",
                "int": "int32_t",
                "char": "int8_t",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "void set_bit_in_array_00002714(uint8_t bit_index)\n{\n    uint32_t* DAT_00002740 = (uint32_t*)(DAT_00002740 + ((uint32_t)bit_index >> 5) * 4);\n    uint32_t bit_mask = 1 << (bit_index & 0x1f);\n    *DAT_00002740 = bit_mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002714",
            "calling": [
                "FUN_00002894"
            ],
            "imported": false,
            "current_name": "set_bit_in_array_00002714"
        },
        "FUN_000020e0": {
            "renaming": {
                "FUN_000020e0": "execute_check_on_data_000020e0",
                "DAT_000020f0": "PTR_data",
                "check_and_execute_00002028": "check_and_execute_data"
            },
            "code": "void execute_check_on_data_000020e0(void)\n{\n  check_and_execute_data(DAT_000020f0, 2);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020e0",
            "calling": [],
            "imported": false,
            "current_name": "execute_check_on_data_000020e0"
        },
        "FUN_00005fec": {
            "renaming": {
                "FUN_00005fec": "do_nothing_and_return_00005fec",
                "DAT_00005ff4": "DAT_input",
                "do_nothing_000045e8": "do_nothing"
            },
            "code": "void do_nothing_and_return_00005fec(void)\n{\n  do_nothing(DAT_00005ff4);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fec",
            "calling": [
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "do_nothing_and_return_00005fec"
        },
        "FUN_00004f84": {
            "renaming": {
                "FUN_00004f84": "convert_string_to_integer_00004f84",
                "param_1": "string",
                "param_2": "remaining_string",
                "param_3": "base",
                "uVar1": "digit_value",
                "uVar2": "current_char_value",
                "uVar3": "is_current_char_negative",
                "uVar4": "current_digit_value",
                "uVar5": "comparison_result",
                "uVar6": "max_result_value",
                "uVar7": "current_divisor",
                "iVar5": "comparison_flag",
                "pbVar8": "previous_char_pointer",
                "pbVar9": "current_char_pointer"
            },
            "code": "uint convert_string_to_integer_00004f84(byte *string, byte **remaining_string, uint base) {\n  uint digit_value;\n  uint is_negative = 0;\n  uint result = 0;\n  uint max_value = UINT_MAX / base;\n  uint digit_count = 0;\n  byte *current_char = string;\n  while (*current_char != '\\0') {\n    if (digit_count == 0 && *current_char == '-') {\n      is_negative = 1;\n    } else if (digit_count == 0 && *current_char == '+') {\n      // Do nothing\n    } else {\n      if (*current_char >= '0' && *current_char <= '9') {\n        digit_value = *current_char - '0';\n      } else if (*current_char >= 'a' && *current_char <= 'z') {\n        digit_value = *current_char - 'a' + 10;\n      } else if (*current_char >= 'A' && *current_char <= 'Z') {\n        digit_value = *current_char - 'A' + 10;\n      } else {\n        break;\n      }\n      if (digit_value >= base) {\n        break;\n      }\n      if (result > max_value || (result == max_value && digit_value > UINT_MAX % base)) {\n        return 0;\n      }\n      result = result * base + digit_value;\n      digit_count++;\n    }\n    current_char++;\n  }\n  if (digit_count == 0) {\n    return 0;\n  }\n  if (remaining_string != NULL) {\n    *remaining_string = current_char;\n  }\n  if (is_negative) {\n    return -result;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f84",
            "calling": [
                "FUN_0000328c",
                "FUN_00004042"
            ],
            "imported": false,
            "current_name": "convert_string_to_integer_00004f84"
        },
        "FUN_000028f0": {
            "renaming": {
                "FUN_000028f0": "get_dat_value_plus_one_000028f0",
                "DAT_0000290c": "data_pointer"
            },
            "code": "int get_dat_value_plus_one_000028f0(void)\n{\n  int* DAT_0000290c = (int*)(DAT_0000290c + 8);\n  int data_value = *DAT_0000290c;\n  int result = data_value + 1;\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000028f0",
            "calling": [
                "FUN_00002690"
            ],
            "imported": false,
            "current_name": "get_dat_value_plus_one_000028f0"
        },
        "FUN_00004f98": {
            "renaming": {
                "FUN_00004f98": "calculate_week_number_for_year_00004f98",
                "param_1": "year",
                "puVar1": "data",
                "uVar2": "result",
                "uVar3": "leap_years",
                "iVar4": "days_in_month",
                "puVar5": "current_date",
                "iVar6": "days_since_1900",
                "uVar7": "day_of_week",
                "iVar8": "jan_1_day_of_week",
                "iVar9": "days_until_first_thursday",
                "uVar10": "days_until_week_1",
                "y": "current_year",
                "m": "current_month",
                "week_1_start_day": "4"
            },
            "code": "uint32_t calculate_week_number_for_year_00004f98(uint32_t year) {\n    uint32_t leap_years = year / 4 - year / 100 + year / 400;\n    return leap_years;\n}\n\nuint32_t calculate_days_in_month(uint32_t year, uint32_t month) {\n    uint32_t days_in_month[] = {31, 28 + (year % 4 == 0 && year % 100 != 0) || year % 400 == 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    return days_in_month[month - 1];\n}\n\nuint32_t calculate_day_of_week(uint32_t year, uint32_t month, uint32_t day) {\n    uint32_t t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};\n    year -= month < 3;\n    return (year + year / 4 - year / 100 + year / 400 + t[month - 1] + day) % 7;\n}\n\nuint32_t calculate_days_since_1900(uint32_t year, uint32_t month, uint32_t day) {\n    uint32_t days_since_1900 = 0;\n    for (uint32_t y = 1900; y < year; y++) {\n        days_since_1900 += 365 + (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;\n    }\n    for (uint32_t m = 1; m < month; m++) {\n        days_since_1900 += calculate_days_in_month(year, m);\n    }\n    days_since_1900 += day - 1;\n    return days_since_1900;\n}\n\nuint32_t calculate_week_number(uint32_t year, uint32_t month, uint32_t day) {\n    uint32_t days_since_1900 = calculate_days_since_1900(year, month, day);\n    uint32_t day_of_week = calculate_day_of_week(year, month, day);\n    uint32_t jan_1_day_of_week = calculate_day_of_week(year, 1, 1);\n    uint32_t days_until_first_thursday = (day_of_week < 4) ? 4 - day_of_week : 11 - day_of_week;\n    uint32_t days_until_week_1 = days_until_first_thursday + 7 * (week_1_start_day - 1);\n    if (days_until_week_1 > days_since_1900) {\n        return 0;\n    }\n    uint32_t week_number = (days_since_1900 - days_until_week_1) / 7 + 1;\n    return week_number;\n}\n\nuint32_t calculate_week_number_for_date(uint32_t year, uint32_t month, uint32_t day) {\n    if (month == 12 && day >= 29) {\n        uint32_t days_in_week_1_of_next_year = calculate_days_since_1900(year + 1, 1, 1) - calculate_day_of_week(year + 1, 1, 1) + 1;\n        if (day >= days_in_week_1_of_next_year) {\n            return 1;\n        }\n        year++;\n    }\n    uint32_t week_number = calculate_week_number(year, month, day);\n    if (week_number == 0) {\n        uint32_t days_in_week_52_or_53 = calculate_days_since_1900(year, 12, 31) - calculate_days_since_1900(year, 12, 24) + 1;\n        if (day >= 31 - days_in_week_52_or_53) {\n            return 1;\n        }\n        return 52 + (calculate_day_of_week(year, 12, 31) < 4);\n    }\n    return week_number;\n}\n\nuint32_t calculate_week_number_for_year_00004f98(uint32_t year) {\n    uint32_t days_in_year = calculate_days_since_1900(year + 1, 1, 1) - calculate_days_since_1900(year, 1, 1);\n    uint32_t days_in_week_1 = calculate_days_in_month(year, 1) - calculate_day_of_week(year, 1, 1) + 1;\n    if (days_in_week_1 >= 4) {\n        return 1;\n    }\n    uint32_t days_in_week_52_or_53 = calculate_days_since_1900(year, 12, 31) - calculate_days_since_1900(year, 12, 24) + 1;\n    if (days_in_week_52_or_53 >= 4) {\n        return 52 + (calculate_day_of_week(year, 12, 31) < 4);\n    }\n    return calculate_week_number_for_date(year, 12, 24);\n}\n\nuint32_t calculate_week_number_for_year_00004f98(uint32_t year) {\n    uint32_t result = 0;\n    if (year >= 1950 && year <= 2049) {\n        uint32_t week_number = calculate_week_number_for_year_00004f98(year);\n        uint32_t *data = (uint32_t *)0x000056b0;\n        data[1] = year;\n        data[8] = week_number;\n        data[9] = (week_number >> 31) & 1;\n        result = 1;\n    }\n    return result;\n}",
            "called": [
                "FUN_000056b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f98",
            "calling": [
                "FUN_00005100",
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "calculate_week_number_for_year_00004f98"
        },
        "FUN_00004dee": {
            "renaming": {
                "FUN_00004dee": "process_data_and_copy_to_dest_00004dee",
                "param_1": "dest",
                "param_2": "data",
                "param_3": "size",
                "param_4": "flag",
                "uVar1": "result"
            },
            "code": "int process_data_and_copy_to_dest_00004dee(int dest, int data, int size, int flag) {\n  int result;\n  \n  if ((int)((uint16_t)*(uint16_t *)(data + 0xc) << 0x17) < 0) {\n    set_dest_to_data_19_000004f2(dest,(int)*(int16_t *)(data + 0xe),0,2);\n  }\n  *(uint16_t *)(data + 0xc) = *(uint16_t *)(data + 0xc) & 0xefff;\n  result = copy_data_to_dest_00000e38(dest, size);\n  return result;\n}",
            "called": [
                "FUN_00000e38",
                "FUN_000004f2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dee",
            "calling": [],
            "imported": false,
            "current_name": "process_data_and_copy_to_dest_00004dee"
        },
        "FUN_00000fec": {
            "renaming": {
                "FUN_00000fec": "initialize_array_and_set_length_to_power_of_two_00000fec",
                "param_1": "array",
                "param_2": "length",
                "PTR_s_FAILED_ASSERTION__00001030": "FAILED_ASSERTION"
            },
            "code": "void initialize_array_and_set_length_to_power_of_two_00000fec(uint32_t *array, uint32_t length) {\n  if ((length & (length - 1)) != 0) {\n    initialize_and_execute(3, PTR_s_FAILED_ASSERTION__00001030);\n  }\n  array[0] = 0;\n  array[1] = 0;\n  array[2] = length - 1;\n  return;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000fec",
            "calling": [
                "FUN_000010d4"
            ],
            "imported": false,
            "current_name": "initialize_array_and_set_length_to_power_of_two_00000fec"
        },
        "FUN_00000428": {
            "renaming": {
                "FUN_00000428": "validate_memory_access_00000428",
                "param_1": "result",
                "param_2": "offset",
                "uVar1": "interrupts_enabled",
                "local_c": "rel_array"
            },
            "code": "uint32_t validate_memory_access_00000428(uint32_t *result, int32_t offset)\n{\n  uint32_t interrupts_enabled = check_interrupts_enabled();\n  uint32_t rel_array = *(uint32_t *)PTR_Elf32_Rel_ARRAY_00000484;\n  if ((DAT_00000488 < (uint32_t)(offset + *(int32_t *)PTR_Elf32_Rel_ARRAY_00000484)) || ((uint32_t)(offset + *(int32_t *)PTR_Elf32_Rel_ARRAY_00000484) < DAT_0000048c)) {\n    *result = 0xc;\n    rel_array = 0xffffffff;\n  }\n  else {\n    *(int32_t *)PTR_Elf32_Rel_ARRAY_00000484 = offset + *(int32_t *)PTR_Elf32_Rel_ARRAY_00000484;\n  }\n  enable_irq_interrupts_if_privileged(interrupts_enabled);\n  return rel_array;\n}",
            "called": [
                "FUN_00000d0c",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000428",
            "calling": [
                "FUN_00004bd0"
            ],
            "imported": false,
            "current_name": "validate_memory_access_00000428"
        },
        "FUN_000039e8": {
            "renaming": {
                "FUN_000039e8": "get_class_000039e8",
                "param_1": "class_char",
                "puVar1": "class_ptr"
            },
            "code": "#define UNKNOWN_CLASS PTR_s_CLASS_UNKNOWN_00003d20\n#define ANY_CLASS PTR_s_CLASS_ANY_00003d1c\n#define SERVO_CLASS PTR_s_ACT_SERVO_00003ccc\n#define MOTOR_CLASS PTR_s_ACT_MOTOR_00003cd0\n#define SWITCH_CLASS PTR_s_ACT_SWITCH_00003cd4\n#define DIMMER_CLASS PTR_s_ACT_DIMMER_00003cd8\n#define ANY_SENSE PTR_s_SENSE_ANY_00003cdc\n#define BUTTON_SENSE PTR_s_SENSE_BTN_00003ce0\n#define TEMPERATURE_SENSE PTR_s_SENSE_TEMP_00003ce4\n#define HUMIDITY_SENSE PTR_s_SENSE_HUM_00003ce8\n#define LIGHT_SENSE PTR_s_SENSE_LIGHT_00003cec\n#define ACCELEROMETER_SENSE PTR_s_SENSE_ACCEL_00003cf0\n#define MAGNETOMETER_SENSE PTR_s_SENSE_MAG_00003cf4\n#define GYROSCOPE_SENSE PTR_s_SENSE_GYRO_00003cf8\n#define COLOR_SENSE PTR_s_SENSE_COLOR_00003cfc\n#define PRESSURE_SENSE PTR_s_SENSE_PRESS_00003d00\n#define ANALOG_SENSE PTR_s_SENSE_ANALOG_00003d04\n#define UV_SENSE PTR_s_SENSE_UV_00003d08\n#define OBJECT_TEMPERATURE_SENSE PTR_s_SENSE_OBJTEMP_00003d0c\n#define PULSE_COUNT_SENSE PTR_s_SENSE_PULSE_COUNT_00003d10\n#define DISTANCE_SENSE PTR_s_SENSE_DISTANCE_00003d14\n#define CO2_SENSE PTR_s_SENSE_CO2_00003d18\n\nundefined * get_class_000039e8(char class_char)\n{\n    undefined *class_ptr = UNKNOWN_CLASS;\n    switch(class_char)\n    {\n        case '\\0':\n            class_ptr = DAT_00003cc0;\n            break;\n        case '@':\n            class_ptr = DAT_00003cc4;\n            break;\n        case 'B':\n            class_ptr = DAT_00003cc8;\n            break;\n        case 'C':\n            class_ptr = SERVO_CLASS;\n            break;\n        case 'D':\n            class_ptr = MOTOR_CLASS;\n            break;\n        case 'E':\n            class_ptr = SWITCH_CLASS;\n            break;\n        case 'F':\n            class_ptr = DIMMER_CLASS;\n            break;\n        case -0x80:\n            class_ptr = ANY_SENSE;\n            break;\n        case -0x7f:\n            class_ptr = BUTTON_SENSE;\n            break;\n        case -0x7e:\n            class_ptr = TEMPERATURE_SENSE;\n            break;\n        case -0x7d:\n            class_ptr = HUMIDITY_SENSE;\n            break;\n        case -0x7c:\n            class_ptr = LIGHT_SENSE;\n            break;\n        case -0x7b:\n            class_ptr = ACCELEROMETER_SENSE;\n            break;\n        case -0x7a:\n            class_ptr = MAGNETOMETER_SENSE;\n            break;\n        case -0x79:\n            class_ptr = GYROSCOPE_SENSE;\n            break;\n        case -0x78:\n            class_ptr = COLOR_SENSE;\n            break;\n        case -0x77:\n            class_ptr = PRESSURE_SENSE;\n            break;\n        case -0x76:\n            class_ptr = ANALOG_SENSE;\n            break;\n        case -0x75:\n            class_ptr = UV_SENSE;\n            break;\n        case -0x74:\n            class_ptr = OBJECT_TEMPERATURE_SENSE;\n            break;\n        case -0x73:\n            class_ptr = PULSE_COUNT_SENSE;\n            break;\n        case -0x72:\n            class_ptr = DISTANCE_SENSE;\n            break;\n        case -0x71:\n            class_ptr = CO2_SENSE;\n            break;\n        default:\n            if (class_char == -1)\n            {\n                return ANY_CLASS;\n            }\n            break;\n    }\n    return class_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000039e8",
            "calling": [
                "FUN_00002f74",
                "FUN_00002ecc"
            ],
            "imported": false,
            "current_name": "get_class_000039e8"
        },
        "FUN_00000e38": {
            "renaming": {
                "FUN_00000e38": "copy_data_to_dest_00000e38",
                "param_1": "dest_start_pos",
                "param_2": "src_data",
                "copy_data_to_memory_000015d0": "memcpy",
                "return": "src_data"
            },
            "code": "int copy_data_to_dest_00000e38(int dest_start_pos, int* src_data, int data_size)\n{\n    memcpy(dest_start_pos, src_data, data_size);\n    return *src_data;\n}",
            "called": [
                "FUN_000015d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e38",
            "calling": [
                "FUN_00004dee"
            ],
            "imported": false,
            "current_name": "copy_data_to_dest_00000e38"
        },
        "FUN_00002294": {
            "renaming": {
                "FUN_00002294": "is_difference_equal_to_third_parameter_00002294",
                "param_1": "pointer_to_parameters",
                "iVar2": "difference",
                "bVar3": "is_equal",
                "uVar1": "return_value",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "bool is_difference_equal_to_third_parameter_00002294(int param_1)\n{\n  int difference = *(int *)(param_1 + 0xc) - *(int *)(param_1 + 8);\n  int third_parameter = *(int *)(param_1 + 4);\n  bool is_equal = difference == third_parameter;\n  if (is_equal) {\n    return true;\n  }\n  else {\n    return false;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002294",
            "calling": [
                "FUN_00002364"
            ],
            "imported": false,
            "current_name": "is_difference_equal_to_third_parameter_00002294"
        },
        "FUN_00003e9e": {
            "renaming": {
                "FUN_00003e9e": "convert_to_string_00003e9e",
                "param_1": "input",
                "param_2": "length",
                "param_3": "output_buffer",
                "uVar1": "result"
            },
            "code": "string convert_to_string_00003e9e(int input, int length, int output_buffer) {\n  string result;\n  result = convert_to_string_00003e9e_implementation(input, length, output_buffer);\n  return result;\n}",
            "called": [
                "FUN_00003ec4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e9e",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "convert_to_string_00003e9e"
        },
        "FUN_00003378": {
            "renaming": {
                "FUN_00003378": "calculate_result_00003378",
                "param_1": "parameters",
                "PTR_s__04i__02i__02i__02i__02i__02i_000033bc": "PTR_something_000033bc",
                "param_1[5]": "parameters[5]",
                "param_1[4]": "parameters[4]",
                "param_1[3]": "parameters[3]",
                "param_1[2]": "parameters[2]",
                "param_1[1]": "parameters[1]",
                "*param_1": "*parameters"
            },
            "code": "int calculate_result_00003378(int *parameters) {\n  int offset = 0x76c;\n  int length = parameters[4] + 1;\n  int param3 = parameters[3];\n  int param2 = parameters[2];\n  int param1 = parameters[1];\n  int param0 = *parameters;\n  calculate_something(PTR_s__04i__02i__02i__02i__02i__02i_000033bc, offset, length, param3, param2, param1, param0);\n  return 0;\n}",
            "called": [
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003378",
            "calling": [
                "FUN_00003444",
                "FUN_000033c0"
            ],
            "imported": false,
            "current_name": "calculate_result_00003378",
            "code_backup": "\nundefined4 FUN_00003378(undefined4 *param_1)\n\n{\n  FUNC_00004c84(PTR_s__04i__02i__02i__02i__02i__02i_000033bc,param_1[5] + 0x76c,param_1[4] + 1,\n               param_1[3],param_1[2],param_1[1],*param_1);\n  return 0;\n}\n\n"
        },
        "FUN_00006768": {
            "renaming": {
                "FUN_00006768": "process_data_00006768",
                "param_1": "input_data",
                "param_2": "output_data",
                "param_3": "param_3",
                "param_4": "param_4",
                "uVar1": "flags",
                "iVar2": "ret_val",
                "uVar3": "val_1",
                "uVar4": "val_2",
                "uVar5": "val_3",
                "initialize_arrays_000042a4": "initialize_arrays",
                "PTR_DAT_00006868": "ptr_dat_1",
                "PTR_DAT_0000686c": "ptr_dat_2",
                "PTR_DAT_00006870": "ptr_dat_3",
                "insert_node_00004b34": "insert_node",
                "decode_and_do_nothing_00004158": "decode_and_do_nothing",
                "allocate_memory_and_set_flag_00005700": "allocate_memory_and_set_flag",
                "PTR_DAT_00006874": "ptr_dat_4",
                "PTR_LAB_00006754_1_00006878": "ptr_lab_1"
            },
            "code": "int process_data_00006768(uint32_t *input_data, uint32_t *output_data, uint32_t param_3, uint32_t param_4)\n{\n  uint16_t flags;\n  int ret_val;\n  uint32_t val_1, val_2, val_3, val_4, val_5, val_6, val_7, val_8, val_9, val_10;\n\n  if ((input_data != NULL) && (input_data[6] == 0)) {\n    initialize_arrays();\n  }\n\n  if (output_data == (uint32_t *)PTR_DAT_00006868) {\n    output_data = (uint32_t *)input_data[1];\n  }\n  else if (output_data == (uint32_t *)PTR_DAT_0000686c) {\n    output_data = (uint32_t *)input_data[2];\n  }\n  else if (output_data == (uint32_t *)PTR_DAT_00006870) {\n    output_data = (uint32_t *)input_data[3];\n  }\n\n  val_1 = *(uint16_t *)(output_data + 3);\n  output_data[1] = 0;\n  val_2 = (uint32_t)*(uint16_t *)(output_data + 3);\n\n  if ((int)(val_2 << 0x1a) < 0) {\n    return 0xffffffff;\n  }\n\n  if ((int)(val_2 << 0x1d) < 0) {\n    if ((uint32_t *)output_data[0xd] != NULL) {\n      if ((uint32_t *)output_data[0xd] != output_data + 0x11) {\n        insert_node_00004b34(input_data);\n      }\n      output_data[1] = output_data[0x10];\n      output_data[0xd] = 0;\n\n      if (output_data[0x10] != 0) {\n        *output_data = output_data[0xf];\n        return 0;\n      }\n    }\n  }\n  else {\n    if (-1 < (int)(val_2 << 0x1b)) {\n      *input_data = 9;\n      flags = val_1 | 0x40;\n      goto LAB_000067b8;\n    }\n\n    if ((int)(val_2 << 0x1c) < 0) {\n      ret_val = decode_and_do_nothing(input_data, output_data, val_2 << 0x1c, val_2, param_4);\n\n      if (ret_val != 0) {\n        return 0xffffffff;\n      }\n\n      output_data[2] = 0;\n      *(uint16_t *)(output_data + 3) = *(uint16_t *)(output_data + 3) & 0xfff7;\n      output_data[6] = 0;\n    }\n\n    *(uint16_t *)(output_data + 3) = *(uint16_t *)(output_data + 3) | 4;\n  }\n\n  if (output_data[4] == 0) {\n    allocate_memory_and_set_flag_00005700(input_data, output_data);\n  }\n\n  flags = *(uint16_t *)(output_data + 3);\n  val_3 = *(uint32_t *)(output_data + 4);\n  *output_data = val_3;\n\n  ret_val = (*(code *)output_data[9])(input_data, output_data[8], val_3, output_data[5]);\n  output_data[1] = ret_val;\n\n  if (0 < ret_val) {\n    return 0;\n  }\n\n  flags = *(uint16_t *)(output_data + 3);\n\n  if (ret_val != 0) {\n    val_3 = 0;\n  }\n  else {\n    flags = flags | 0x20;\n  }\n\nLAB_000067b8:\n  *(uint16_t *)(output_data + 3) = flags;\n  return 0xffffffff;\n}",
            "called": [
                "FUN_0000404c",
                "FUN_00005700",
                "FUN_000043a0",
                "FUN_00004158",
                "FUN_00004b34",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006768",
            "calling": [
                "FUN_00005e10"
            ],
            "imported": false,
            "current_name": "process_data_00006768"
        },
        "FUN_00000db0": {
            "renaming": {
                "FUN_00000db0": "initialize_data_and_memory_00000db0",
                "set_data_00000dcc": "set_data",
                "clear_memory_00000d9c": "clear_memory"
            },
            "code": "void initialize_data_and_memory_00000db0(void)\n{\n  set_data();\n  clear_memory();\n  return;\n}",
            "called": [
                "FUN_00000dcc",
                "FUN_00000d9c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000db0",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "initialize_data_and_memory_00000db0"
        },
        "FUN_00002600": {
            "renaming": {
                "FUN_00002600": "process_data_and_set_flag_00002600",
                "param_1": "data",
                "uVar1": "processed_data",
                "FUNC_000047e4": "process_data",
                "set_flag_and_store_data_0000285c": "set_flag_and_store_data"
            },
            "code": "int process_data_and_set_flag_00002600(int data) {\n  int processed_data = process_data(data);\n  set_flag_and_store_data(processed_data);\n  return 0;\n}",
            "called": [
                "FUN_0000285c",
                "FUN_000047e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002600",
            "calling": [
                "FUN_00003478"
            ],
            "imported": false,
            "current_name": "process_data_and_set_flag_00002600"
        },
        "FUN_00003810": {
            "renaming": {
                "FUN_00003810": "get_label_for_parameter_value_00003810",
                "param_1": "parameter_value",
                "puVar1": "label_ptr"
            },
            "code": "undefined* get_label_for_parameter_value_00003810(undefined parameter_value) {\n    undefined* label_ptr = PTR_LAB_00003914;\n    switch(parameter_value) {\n        case 2:\n            label_ptr = PTR_LAB_000038cc;\n            break;\n        case 3:\n            label_ptr = PTR_LAB_000038d0;\n            break;\n        case 4:\n            label_ptr = PTR_LAB_000038d4;\n            break;\n        case 5:\n            label_ptr = PTR_LAB_000038d8;\n            break;\n        case 6:\n            label_ptr = PTR_LAB_000038dc;\n            break;\n        case 7:\n            label_ptr = PTR_LAB_000038e0;\n            break;\n        case 8:\n            label_ptr = PTR_LAB_000038e4;\n            break;\n        case 9:\n            label_ptr = PTR_LAB_000038e8;\n            break;\n        case 10:\n            label_ptr = PTR_LAB_000038ec;\n            break;\n        case 0xb:\n            label_ptr = PTR_LAB_000038f0;\n            break;\n        case 0xc:\n            label_ptr = PTR_LAB_000038f4;\n            break;\n        case 0xd:\n            label_ptr = PTR_LAB_000038f8;\n            break;\n        case 0xe:\n            label_ptr = PTR_LAB_000038fc;\n            break;\n        case 0xf:\n            label_ptr = PTR_LAB_00003900;\n            break;\n        case 0x10:\n            label_ptr = PTR_LAB_00003904;\n            break;\n        case 0x11:\n            label_ptr = PTR_LAB_0000390c;\n            break;\n        case 0x13:\n            label_ptr = PTR_LAB_00003910;\n            break;\n        case 0x15:\n            label_ptr = PTR_LAB_00003908;\n    }\n    return label_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003810",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "get_label_for_parameter_value_00003810"
        },
        "FUN_00000ed8": {
            "renaming": {
                "FUN_00000ed8": "execute_function_with_pointer_00000ed8",
                "PTR_DAT_00000ef4": "PTR_FUNCTION_POINTER",
                "in_lr": "current_lr",
                "FUNC_00004c84": "execute_function_with_pointer_and_lr"
            },
            "code": "void execute_function_with_pointer_00000ed8(void)\n{\n  undefined4 current_lr;\n  execute_function_with_pointer_00000ed8_and_lr(PTR_DAT_00000ef4, current_lr);\n  return;\n}",
            "called": [
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ed8",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "execute_function_with_pointer_00000ed8",
            "code_backup": "\nvoid FUN_00000ed8(void)\n\n{\n  undefined4 in_lr;\n  \n  FUNC_00004c84(PTR_DAT_00000ef4,in_lr);\n  return;\n}\n\n"
        },
        "FUN_000031e0": {
            "renaming": {
                "FUN_000031e0": "playAlarm_000031e0",
                "FUNC_00004db8": "ringAlarm",
                "PTR_s_The_alarm_rang_000031f8": "s_The_alarm_rang"
            },
            "code": "void playAlarm_000031e0(void)\n{\n  ringAlarm(PTR_s_The_alarm_rang_000031f8);\n  return;\n}",
            "called": [
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031e0",
            "calling": [],
            "imported": false,
            "current_name": "playAlarm_000031e0",
            "code_backup": "\nvoid FUN_000031e0(void)\n\n{\n  FUNC_00004db8(PTR_s_The_alarm_rang_000031f8);\n  return;\n}\n\n"
        },
        "FUN_000020f4": {
            "renaming": {
                "FUN_000020f4": "execute_check_000020f4",
                "DAT_00002104": "PTR_function_pointer",
                "check_and_execute_00002028": "check_and_execute"
            },
            "code": "void execute_check_000020f4(void)\n{\n  check_and_execute(DAT_00002104, 3);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020f4",
            "calling": [],
            "imported": false,
            "current_name": "execute_check_000020f4"
        },
        "FUN_0000687c": {
            "renaming": {
                "FUN_0000687c": "replace_chars_0000687c",
                "param_1": "length",
                "param_2": "input_string",
                "pbVar1": "output_string",
                "uVar2": "range_end_index",
                "iVar3": "i",
                "uVar4": "current_char",
                "uVar5": "range_start_index",
                "uVar6": "range_end_char",
                "bVar7": "is_replacing"
            },
            "code": "byte* replace_chars_0000687c(int length, byte* input_string) {\n    byte* output_string;\n    byte current_char;\n    uint start_index = 0;\n    bool is_replacing = false;\n    bool is_start_of_range = false;\n    uint range_start_index = 0;\n    uint range_end_index = 0;\n    for (int i = 0; i < length; i++) {\n        current_char = input_string[i];\n        if (current_char == '^' && i == 0) {\n            is_replacing = true;\n            continue;\n        }\n        if (is_replacing) {\n            if (is_start_of_range) {\n                if (current_char == ']') {\n                    is_start_of_range = false;\n                    output_string[range_start_index] = input_string[i - 1];\n                    for (uint j = range_start_index + 1; j < range_end_index; j++) {\n                        output_string[j] = !output_string[j - 1];\n                    }\n                    range_start_index = 0;\n                    range_end_index = 0;\n                    continue;\n                }\n            }\n            else {\n                if (current_char == '-') {\n                    is_start_of_range = true;\n                    range_start_index = start_index + (uint)input_string[i - 1];\n                    range_end_index = (uint)input_string[i + 1];\n                    i++;\n                    continue;\n                }\n                else if (current_char == ']') {\n                    is_replacing = false;\n                    continue;\n                }\n            }\n            output_string[start_index + (uint)current_char] = !output_string[start_index];\n        }\n        else {\n            output_string[start_index] = current_char;\n        }\n        start_index++;\n    }\n    return output_string;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000687c",
            "calling": [
                "FUN_0000656c",
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "replace_chars_0000687c"
        },
        "FUN_00005edc": {
            "renaming": {
                "FUN_00005edc": "parse_uint_00005edc",
                "param_1": "result",
                "param_2": "str",
                "param_3": "endptr",
                "param_4": "base",
                "uVar1": "value",
                "uVar2": "digit",
                "bVar3": "sign",
                "iVar4": "status",
                "uVar5": "temp",
                "uVar6": "max_value",
                "pbVar7": "ptr",
                "pbVar8": "next_ptr"
            },
            "code": "uint parse_uint_00005edc(undefined4 *result, byte *str, byte **endptr, uint base) {\n  uint digit;\n  uint value = 0;\n  int sign = 1;\n  uint max_value = UINT_MAX / base;\n  byte *ptr = str;\n\n  while (isspace(*ptr)) {\n    ptr++;\n  }\n\n  if (*ptr == '-') {\n    sign = -1;\n    ptr++;\n  } else if (*ptr == '+') {\n    ptr++;\n  }\n\n  if (base == 0) {\n    if (*ptr == '0') {\n      base = 8;\n    } else {\n      base = 10;\n    }\n  } else if (base == 16 && *ptr == '0' && (ptr[1] == 'x' || ptr[1] == 'X')) {\n    ptr += 2;\n  }\n\n  while (isalnum(*ptr)) {\n    if (isdigit(*ptr)) {\n      digit = *ptr - '0';\n    } else if (isupper(*ptr)) {\n      digit = *ptr - 'A' + 10;\n    } else {\n      digit = *ptr - 'a' + 10;\n    }\n\n    if (digit >= base) {\n      break;\n    }\n\n    if (value > max_value || (value == max_value && digit > UINT_MAX % base)) {\n      *result = sign == -1 ? 0 : UINT_MAX;\n      if (endptr == NULL) {\n        return UINT_MAX;\n      }\n      break;\n    }\n\n    value = value * base + digit;\n    ptr++;\n  }\n\n  if (endptr != NULL) {\n    *endptr = ptr;\n  }\n\n  return sign * value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005edc",
            "calling": [
                "FUN_00005fd8"
            ],
            "imported": false,
            "current_name": "parse_uint_00005edc"
        },
        "FUN_00001eea": {
            "renaming": {
                "FUN_00001eea": "set_bits_and_value_at_offset_00001eea",
                "param_1": "offset",
                "param_2": "value",
                "uVar1": "lower_six_bits",
                "iVar2": "masked_value",
                "iVar3": "lower_six_bits_2"
            },
            "code": "int set_bits_and_value_at_offset_00001eea(unsigned short offset, unsigned char value) {\n  uint32_t masked_value = get_masked_value(offset);\n  uint32_t *bits = (uint32_t *)(masked_value + 0x14);\n  uint8_t lower_six_bits = extract_lower_six_bits(offset);\n  if (value < 0) {\n    *bits |= 1 << (lower_six_bits & 0xff);\n  }\n  else {\n    *bits &= ~(1 << (lower_six_bits & 0xff));\n  }\n  uint32_t *param_address = (uint32_t *)convert_param_to_address(offset);\n  uint8_t lower_six_bits_2 = extract_lower_six_bits(offset);\n  *(param_address + lower_six_bits_2) = value & 0x23 | 0x100;\n  return 0;\n}",
            "called": [
                "FUN_00001f80",
                "FUN_00001d80",
                "FUN_00001dc0",
                "FUN_00001d5e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001eea",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "set_bits_and_value_at_offset_00001eea"
        },
        "FUN_000023a4": {
            "renaming": {
                "FUN_000023a4": "execute_commands_000023a4",
                "uVar1": "result",
                "auStack_88": "input_buffer",
                "check_software_interrupt_000023d0": "check_software_interrupt",
                "FUNC_00004db8": "initialize_memory",
                "process_input_and_execute_commands_00002e6c": "process_input_and_execute_commands",
                "software_interrupt": "trigger_software_interrupt",
                "0x3f": "0x3f"
            },
            "code": "int execute_commands_000023a4() {\n  int result;\n  char input_buffer[128];\n\n  check_software_interrupt_000023d0(0);\n  FUNC_00004db8(uRam000023c4);\n  result = process_input_and_execute_commands_000023a4(0, input_buffer, 0x80);\n  software_interrupt(0x3f);\n  return result;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_000023d0",
                "FUN_00002e6c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023a4",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "execute_commands_000023a4"
        },
        "FUN_0000240c": {
            "renaming": {
                "FUN_0000240c": "getNextNodeValue_0000240c",
                "param_1": "currentNodePtr",
                "puVar1": "nextNodePtr"
            },
            "code": "undefined4* getNextNodeValue_0000240c(undefined4* currentNodePtr) {\n    undefined4* nextNodePtr = (undefined4*)*currentNodePtr;\n    if (nextNodePtr != (undefined4*)0x0) {\n        *currentNodePtr = *nextNodePtr;\n    }\n    return nextNodePtr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000240c",
            "calling": [
                "FUN_000024bc"
            ],
            "imported": false,
            "current_name": "getNextNodeValue_0000240c"
        },
        "FUN_00004280": {
            "renaming": {
                "FUN_00004280": "do_nothing_with_pointer_00004280",
                "PTR_DAT_00004288": "PTR_pointer"
            },
            "code": "void do_nothing_with_pointer_00004280(void)\n{\n  do_nothing(PTR_DAT_00004288);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004280",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_00004280"
        },
        "FUN_00001448": {
            "renaming": {
                "FUN_00001448": "checkAndUpdateValues_00001448",
                "param_1": "index",
                "value1": "offset1",
                "value2": "offset2",
                "value3": "bitsAndValue1",
                "value4": "bitsAndValueOffset1",
                "value5": "bitsAndValue2",
                "value6": "bitsAndValueOffset2"
            },
            "code": "void checkAndUpdateValues_00001448(int index)\n{\n    short value1 = *(short *)(PTR_DAT_000014c0 + index * 0x20 + 8);\n    short value2 = *(short *)(PTR_DAT_000014c0 + index * 0x20 + 10);\n    if (value1 != -1) {\n        undefined2 value3 = *(undefined2 *)(PTR_DAT_000014c0 + index * 0x20 + 8);\n        undefined4 value4 = *(undefined4 *)(PTR_DAT_000014c0 + index * 0x20 + 0xc);\n        setBitsAndValueAtOffset_00001f80(value3, value4);\n    }\n    if (value2 != -1) {\n        undefined2 value5 = *(undefined2 *)(PTR_DAT_000014c0 + index * 0x20 + 10);\n        undefined4 value6 = *(undefined4 *)(PTR_DAT_000014c0 + index * 0x20 + 0x10);\n        setBitsAndValueAtOffset_00001f80(value5, value6);\n    }\n    return;\n}",
            "called": [
                "FUN_00001f80"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001448",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "checkAndUpdateValues_00001448"
        },
        "FUN_00001688": {
            "renaming": {
                "FUN_00001688": "call_function_with_zero_arg_00001688",
                "check_and_call_function_00001628": "check_and_call_function"
            },
            "code": "void call_function_with_zero_arg_00001688(void)\n{\n  check_and_call_function(0);\n  return;\n}",
            "called": [
                "FUN_00001628"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001688",
            "calling": [],
            "imported": false,
            "current_name": "call_function_with_zero_arg_00001688"
        },
        "FUN_00004042": {
            "renaming": {
                "FUN_00004042": "convert_string_to_integer_00004042",
                "param_1": "string_to_convert"
            },
            "code": "void convert_string_to_integer_00004042(char* string_to_convert) {\n  convert_string_to_integer_00004042_00004f84(string_to_convert, 0, 10);\n  return;\n}",
            "called": [
                "FUN_00004f84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004042",
            "calling": [
                "FUN_0000305c",
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "convert_string_to_integer_00004042"
        },
        "FUN_00000cf0": {
            "renaming": {
                "FUN_00000cf0": "is_interrupt_enabled_00000cf0",
                "uVar2": "is_irq_enabled",
                "bVar1": "is_privileged_mode"
            },
            "code": "bool is_interrupt_enabled_00000cf0(void)\n{\n  bool is_privileged_mode = (bool)isCurrentModePrivileged();\n  bool is_irq_enabled = false;\n  if (is_privileged_mode) {\n    is_irq_enabled = isIRQinterruptsEnabled();\n  }\n  return is_irq_enabled;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cf0",
            "calling": [
                "FUN_00000930"
            ],
            "imported": false,
            "current_name": "is_interrupt_enabled_00000cf0"
        },
        "FUN_00000f8c": {
            "renaming": {
                "FUN_00000f8c": "allocate_and_initialize_memory_00000f8c",
                "puRam00000fd4": "heap_start_address",
                "uRam00000fd8": "heap_end_address",
                "allocate_memory_000010d4": "allocate_memory",
                "puRam00000fe0": "heap_start_address",
                "uRam00000fe4": "heap_end_address",
                "uRam00000fe8": "memory_location",
                "run_interrupt_handler_00000930": "run_interrupt_handler",
                "PTR_s_FAILED_ASSERTION__00001030": "FAILED_ASSERTION_MSG",
                "uVar1": "interrupt_handler_result",
                "puVar2": "memory_location",
                "iStack_24": "stack_variable",
                "piStack_20": "stack_pointer"
            },
            "code": "void allocate_and_initialize_memory_00000f8c(void)\n{\n  check_interrupts_enabled();\n  uint32_t heap_start = *heap_start_address;\n  uint32_t heap_end = heap_start_address;\n  allocate_memory(heap_end, 0x100, 0xf, 0xc);\n  heap_start = *heap_end_address;\n  heap_end = heap_end_address;\n  allocate_memory(heap_end, 0x600, 7);\n  uint32_t interrupt_handler_result = run_interrupt_handler_00000930();\n  uint32_t highest_bit_set = interrupt_handler_result >> 0x1e;\n  uint32_t *memory_location = (uint32_t *)(0xc * 0x100);\n  int stack_variable = (0xc >> 0x1d) << 0x11;\n  int *stack_pointer = &stack_variable;\n  if ((highest_bit_set & (highest_bit_set - 1)) != 0) {\n    initialize_and_execute(3, PTR_s_FAILED_ASSERTION__00001030);\n  }\n  *memory_location = 0;\n  memory_location[1] = 0;\n  memory_location[2] = highest_bit_set - 1;\n  return;\n}",
            "called": [
                "FUN_000010d4",
                "FUN_00000930",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f8c",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_memory_00000f8c"
        },
        "FUN_00002894": {
            "renaming": {
                "FUN_00002894": "update_data_and_set_bit_00002894",
                "param_1": "data",
                "param_2": "value",
                "param_3": "mask",
                "iVar1": "data_info",
                "*(uint *)(DAT_000028e8 + 0x1c)": "control_reg",
                "*(int *)(iVar1 + 8)": "data_ptr",
                "PTR_DAT_000028ec": "data_mask_ptr"
            },
            "code": "void update_data_and_set_bit_00002894(int data, int value, int mask) {\n  int data_info = DAT_000028e8;\n  uint* *(uint *)(DAT_000028e8 + 0x1c) = (uint*)(data_info + 0x1c);\n  **(uint *)(DAT_000028e8 + 0x1c) = **(uint *)(DAT_000028e8 + 0x1c) & ~mask;\n  int* data_ptr = (int*)(data_info + 8);\n  *data_ptr = value - 1;\n  *(uint*)PTR_DAT_000028ec = data;\n  *(uint*)(PTR_DAT_000028ec + 4) = mask;\n  **(uint *)(DAT_000028e8 + 0x1c) = **(uint *)(DAT_000028e8 + 0x1c) | mask;\n  update_data_00002744(data, value);\n  set_bit_in_array_00002714(data);\n}",
            "called": [
                "FUN_00002744",
                "FUN_00002714"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002894",
            "calling": [
                "FUN_00002654"
            ],
            "imported": false,
            "current_name": "update_data_and_set_bit_00002894"
        },
        "FUN_00004158": {
            "renaming": {
                "FUN_00004158": "decode_and_do_nothing_00004158",
                "param_1": "input_param",
                "param_2": "data_param",
                "uVar1": "result",
                "PTR_DAT_000041c4": "ptr_dat_1",
                "PTR_DAT_000041c8": "ptr_dat_2",
                "PTR_DAT_000041cc": "ptr_dat_3",
                "ptr1": "data_ptr",
                "ptr2": "short_ptr",
                "ptr3": "int_ptr"
            },
            "code": "int decode_and_do_nothing_00004158(int input_param, undefined *data_param) {\n  int result;\n  int *ptr1 = (int *)(data_param + 0x10);\n  if (*ptr1 != 0) {\n    if ((input_param != 0) && (*(int *)(input_param + 0x18) == 0)) {\n      call_function_000042a4();\n    }\n    if (data_param == PTR_DAT_000041c4) {\n      data_param = *(undefined **)(input_param + 4);\n    }\n    else if (data_param == PTR_DAT_000041c8) {\n      data_param = *(undefined **)(input_param + 8);\n    }\n    else if (data_param == PTR_DAT_000041cc) {\n      data_param = *(undefined **)(input_param + 0xc);\n    }\n    short *ptr2 = (short *)(data_param + 0xc);\n    if (*ptr2 != 0) {\n      int *ptr3 = (int *)(data_param + 100);\n      if ((*ptr3 < 0) && (*ptr2 < 0)) {\n        do_nothing_000045e8(*(int *)(data_param + 0x58));\n      }\n      result = decode_0000404c(input_param, data_param);\n      if (*ptr3 < 0) {\n        return result;\n      }\n      if (*ptr2 < 0) {\n        do_nothing_000045ec(*(int *)(data_param + 0x58));\n        return result;\n      }\n    }\n  }\n  return 0;\n}",
            "called": [
                "FUN_0000404c",
                "FUN_000045e8",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004158",
            "calling": [
                "FUN_00005404",
                "FUN_00006768",
                "FUN_000041d0"
            ],
            "imported": false,
            "current_name": "decode_and_do_nothing_00004158",
            "code_backup": "\nundefined4 FUN_00004158(int param_1,undefined *param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (*(int *)(param_2 + 0x10) != 0) {\n    if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n      FUNC_000042a4();\n    }\n    if (param_2 == PTR_DAT_000041c4) {\n      param_2 = *(undefined **)(param_1 + 4);\n    }\n    else if (param_2 == PTR_DAT_000041c8) {\n      param_2 = *(undefined **)(param_1 + 8);\n    }\n    else if (param_2 == PTR_DAT_000041cc) {\n      param_2 = *(undefined **)(param_1 + 0xc);\n    }\n    if (*(short *)(param_2 + 0xc) != 0) {\n      if ((-1 < *(int *)(param_2 + 100) << 0x1f) && (-1 < (int)*(short *)(param_2 + 0xc) << 0x16)) {\n        do_nothing_000045e8(*(undefined4 *)(param_2 + 0x58));\n      }\n      uVar1 = decode_0000404c(param_1,param_2);\n      if (*(int *)(param_2 + 100) << 0x1f < 0) {\n        return uVar1;\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x16) < 0) {\n        return uVar1;\n      }\n      do_nothing_000045ec(*(undefined4 *)(param_2 + 0x58));\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n"
        },
        "FUN_00002654": {
            "renaming": {
                "FUN_00002654": "execute_and_update_data_00002654",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "uVar1": "result"
            },
            "code": "int execute_and_update_data_00002654(int input1, int input2, int input3) {\n  int result = FUNC_000047e4(input1);\n  *(int *)PTR_DAT_00002688 = input2;\n  update_data_and_set_bit_00002894(result, PTR_execute_function_if_not_null_000026f0_1_0000268c, input3);\n  return 0;\n}",
            "called": [
                "FUN_00002894",
                "FUN_000047e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002654",
            "calling": [
                "FUN_000033f4"
            ],
            "imported": false,
            "current_name": "execute_and_update_data_00002654"
        },
        "FUN_00002538": {
            "renaming": {
                "FUN_00002538": "decode_byte_and_store_00002538",
                "param_1": "byte_to_decode",
                "param_2": "decoded_value",
                "DAT_00002584": "decoded_data_location_1",
                "DAT_00002588": "decoded_data_location_2"
            },
            "code": "void decode_byte_and_store_00002538(byte byte_to_decode, uint decoded_value) {\n  if (byte_to_decode < 0) {\n    char* decoded_location = (char*)((byte_to_decode & 0xf) + DAT_00002584 + 0x14);\n    *decoded_location = (char)((decoded_value & 0xff) << 4);\n  }\n  else {\n    char* decoded_location = (char*)((char)byte_to_decode + DAT_00002588 + 0x300);\n    *decoded_location = (char)((decoded_value & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002538",
            "calling": [
                "FUN_0000258c"
            ],
            "imported": false,
            "current_name": "decode_byte_and_store_00002538"
        },
        "FUN_00004c84": {
            "renaming": {
                "FUN_00004c84": "initialize_data_00004c84",
                "param_1": "input_param_1",
                "param_2": "input_param_2",
                "param_3": "input_param_3",
                "param_4": "input_param_4",
                "iVar1": "data_ptr",
                "uVar2": "param_1_copy",
                "uStack_c": "param_2_copy",
                "uStack_8": "param_3_copy",
                "uStack_4": "param_4_copy",
                "DAT_00004cb0": "DAT_data_ptr",
                "FUNC_000042a4": "cleanup_data",
                "FUNC_000057f8": "process_data"
            },
            "code": "void initialize_data_00004c84(undefined4 param_1, undefined4 param_2, undefined4 param_3, undefined4 param_4)\n{\n  int* data_ptr = *DAT_00004cb0;\n  undefined4 param_1_copy = param_1;\n  undefined4 param_2_copy = param_2;\n  undefined4 param_3_copy = param_3;\n  undefined4 param_4_copy = param_4;\n  \n  if ((data_ptr != 0) && (*(int *)(data_ptr + 0x18) == 0)) {\n    cleanup_data(data_ptr);\n  }\n  \n  FUNC_000057f8(data_ptr, *(undefined4 *)(data_ptr + 8), param_1_copy, &param_2_copy, param_1_copy, &param_3_copy);\n  return;\n}",
            "called": [
                "FUN_000057f8",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004c84",
            "calling": [
                "FUN_00002b10",
                "FUN_00002a88",
                "FUN_00000f04",
                "FUN_00002ecc",
                "FUN_00002fe0",
                "FUN_0000316c",
                "FUN_00003694",
                "FUN_00003378",
                "FUN_00002f74",
                "FUN_0000305c",
                "FUN_00003524",
                "FUN_0000211c",
                "FUN_00000ed8"
            ],
            "imported": false,
            "current_name": "initialize_data_00004c84",
            "code_backup": "\nvoid FUN_00004c84(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  iVar1 = *DAT_00004cb0;\n  uVar2 = param_1;\n  uStack_c = param_2;\n  uStack_8 = param_3;\n  uStack_4 = param_4;\n  if ((iVar1 != 0) && (*(int *)(iVar1 + 0x18) == 0)) {\n    FUNC_000042a4(iVar1);\n  }\n  FUNC_000057f8(iVar1,*(undefined4 *)(iVar1 + 8),param_1,&uStack_c,uVar2,&uStack_c);\n  return;\n}\n\n"
        },
        "FUN_0000305c": {
            "renaming": {
                "FUN_0000305c": "write_data_to_device_0000305c",
                "param_1": "num_args",
                "param_2": "args",
                "uVar1": "data_element",
                "auStack_20": "data_array",
                "local_18": "num_data_elements",
                "local_14": "device_index",
                "local_10": "device_id",
                "local_c": "device_writable"
            },
            "code": "void write_data_to_device_0000305c(int num_args, undefined4 *args)\n{\n  undefined2 data_array[4];\n  uint num_data_elements;\n  int device_index;\n  undefined4 device_id;\n  int device_writable;\n  \n  if (num_args < 4) {\n    initialize_data(PTR_s_usage___s__s__device_id___value_0_00003154,*args,args[1]);\n  }\n  else {\n    device_id = convert_string_to_integer_00004042(args[2]);\n    device_index = find_nth_element_00003d24(device_id);\n    if (device_index == 0) {\n      FUNC_00004db8(PTR_s_error__undefined_device_given_00003158);\n    }\n    else {\n      fill_array_with_value_00004622(data_array,0,8);\n      if (5 < num_args) {\n        num_args = 6;\n      }\n      num_data_elements = num_args - 3;\n      for (device_writable = 0; device_writable < (int)num_data_elements; device_writable++) {\n        data_array[device_writable] = convert_string_to_integer_00004042(args[device_writable + 3]);\n      }\n      initialize_data(PTR_s_Writing_to_device___i____s_0000315c,device_id,*(undefined4 *)(device_index + 8));\n      display_data_object_00003694(data_array,num_data_elements & 0xff);\n      device_writable = execute_function_00003d94(device_index,data_array);\n      if ((int)device_writable < 1) {\n        if (device_writable == -0x86) {\n          initialize_data(PTR_s_error__device___i_is_not_writabl_00003160,device_id);\n        }\n        else {\n          initialize_data(PTR_s_error__failure_to_write_to_devic_00003164,device_id);\n        }\n      }\n      else {\n        initialize_data(PTR_s_data_successfully_written_to_dev_00003168,device_id);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_00003d94",
                "FUN_00003d24",
                "FUN_00003694",
                "FUN_00004042",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000305c",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "write_data_to_device_0000305c"
        },
        "FUN_000012b4": {
            "renaming": {
                "FUN_000012b4": "update_array_and_process_linked_list_000012b4",
                "param_1": "array_index",
                "param_2": "data",
                "uVar1": "result",
                "update_array_00002364": "update_array",
                "processLinkedList_000024bc": "process_linked_list"
            },
            "code": "int update_array_and_process_linked_list_000012b4(int array_index, char data){\n  int updated_index = array_index + 4;\n  int result = update_array(updated_index, data);\n  process_linked_list(array_index);\n  return result;\n}",
            "called": [
                "FUN_000024bc",
                "FUN_00002364"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012b4",
            "calling": [],
            "imported": false,
            "current_name": "update_array_and_process_linked_list_000012b4"
        },
        "FUN_00005b34": {
            "renaming": {
                "FUN_00005b34": "FUNC_00005b34"
            },
            "code": "\ncode * FUNC_00005b34(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5\n                   )\n\n{\n  bool bVar1;\n  byte bVar2;\n  undefined *puVar3;\n  int iVar4;\n  code *pcVar5;\n  int iVar6;\n  undefined *puVar7;\n  uint uVar8;\n  uint *puVar9;\n  uint uVar10;\n  uint **ppuVar11;\n  uint uVar12;\n  undefined *puVar13;\n  code *local_24;\n  \n  puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n  bVar2 = *(byte *)(param_2 + 6);\n  puVar7 = (undefined *)((int)param_2 + 0x43);\n  local_24 = param_4;\n  if (0x78 < bVar2) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)param_2 + 0x42) = bVar2;\nLAB_00005bdc:\n    puVar7 = (undefined *)((int)param_2 + 0x42);\n    uVar8 = 1;\nLAB_00005d28:\n    param_2[4] = uVar8;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (bVar2 < 99) {\n    if (bVar2 == 0) goto LAB_00005d06;\n    if (bVar2 == 0x58) {\n      *(undefined *)((int)param_2 + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(bVar2) {\n  case 99:\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    *(char *)((int)param_2 + 0x42) = (char)uVar8;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    uVar10 = *param_2;\n    puVar9 = *param_5;\n    if ((int)(uVar10 << 0x18) < 0) {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n    }\n    else {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n      if ((uVar10 & 0x40) != 0) {\n        uVar8 = (uint)(short)uVar8;\n      }\n    }\n    if ((int)uVar8 < 0) {\n      uVar8 = -uVar8;\n      *(undefined *)((int)param_2 + 0x43) = 0x2d;\n    }\n    uVar10 = 10;\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    ppuVar11 = (uint **)*param_5;\n    uVar10 = *param_2;\n    uVar8 = param_2[5];\n    *param_5 = (uint *)(ppuVar11 + 1);\n    puVar9 = *ppuVar11;\n    if (((int)(uVar10 << 0x18) < 0) || (-1 < (int)(uVar10 << 0x19))) {\n      *puVar9 = uVar8;\n    }\n    else {\n      *(short *)puVar9 = (short)uVar8;\n    }\nLAB_00005d06:\n    param_2[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    puVar9 = *param_5;\n    uVar8 = *param_2;\n    *param_5 = puVar9 + 1;\n    if (((int)(uVar8 << 0x18) < 0) || (-1 < (int)(uVar8 << 0x19))) {\n      uVar8 = *puVar9;\n    }\n    else {\n      uVar8 = (uint)*(ushort *)puVar9;\n    }\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    if (bVar2 == 0x6f) {\n      uVar10 = 8;\n    }\n    else {\n      uVar10 = 10;\n    }\n    break;\n  case 0x70:\n    *param_2 = *param_2 | 0x20;\n  case 0x78:\n    puVar3 = PTR_s_0123456789abcdef_00005d7c;\n    *(undefined *)((int)param_2 + 0x45) = 0x78;\nLAB_00005ca8:\n    uVar10 = *param_2;\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    if ((-1 < (int)(uVar10 << 0x18)) && ((int)(uVar10 << 0x19) < 0)) {\n      uVar8 = uVar8 & 0xffff;\n    }\n    if ((int)(uVar10 << 0x1f) < 0) {\n      *param_2 = uVar10 | 0x20;\n    }\n    if (uVar8 == 0) {\n      *param_2 = *param_2 & 0xffffffdf;\n    }\n    uVar10 = 0x10;\n    break;\n  case 0x73:\n    puVar9 = *param_5;\n    *param_5 = puVar9 + 1;\n    puVar7 = (undefined *)*puVar9;\n    iVar4 = find_byte_sequence_00006010(puVar7,0,param_2[1],puVar9,param_1,param_2,param_3);\n    if (iVar4 != 0) {\n      param_2[1] = iVar4 - (int)puVar7;\n    }\n    uVar8 = param_2[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)param_2 + 0x43) = 0;\nLAB_00005c36:\n  uVar12 = param_2[1];\n  param_2[2] = uVar12;\n  if (-1 < (int)uVar12) {\n    *param_2 = *param_2 & 0xfffffffb;\n  }\n  puVar13 = puVar7;\n  if ((uVar8 != 0) || (uVar12 != 0)) {\n    do {\n      puVar13 = puVar13 + -1;\n      *puVar13 = puVar3[uVar8 - uVar10 * (uVar8 / uVar10)];\n      bVar1 = uVar10 <= uVar8;\n      uVar8 = uVar8 / uVar10;\n    } while (bVar1);\n  }\n  if (((uVar10 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4])) {\n    puVar13[-1] = 0x30;\n    puVar13 = puVar13 + -1;\n  }\n  param_2[4] = (int)puVar7 - (int)puVar13;\n  puVar7 = puVar13;\nLAB_00005c84:\n  iVar4 = decode_00005a58(param_1,param_2,&local_24,param_3,param_4);\n  if ((iVar4 == -1) || (iVar4 = (*param_4)(param_1,param_3,puVar7,param_2[4]), iVar4 == -1)) {\nLAB_00005c98:\n    pcVar5 = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar4 = 0; iVar4 < (int)(param_2[3] - (int)local_24); iVar4 = iVar4 + 1) {\n        iVar6 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar6 == -1) goto LAB_00005c98;\n      }\n    }\n    pcVar5 = (code *)param_2[3];\n    if ((int)(code *)param_2[3] < (int)local_24) {\n      pcVar5 = local_24;\n    }\n  }\n  return pcVar5;\n}\n\n",
            "called": [
                "FUN_00006010",
                "FUN_00005a58"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00005b34",
            "calling": [
                "FUN_000057f8"
            ],
            "imported": false,
            "current_name": "FUNC_00005b34"
        },
        "FUN_0000058e": {
            "renaming": {
                "FUN_0000058e": "update_linked_list_0000058e",
                "param_1": "head",
                "param_2": "new_node",
                "*param_1": "*head",
                "*param_2": "*new_node"
            },
            "code": "void update_linked_list_0000058e(int *head, undefined4 *new_node) {\n  if (*head == 0) {\n    *new_node = new_node;\n  }\n  else {\n    *new_node = *(undefined4 *)*head;\n    *(undefined4 **) *head = new_node;\n  }\n  *head = (int)new_node;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000058e",
            "calling": [
                "FUN_00000698"
            ],
            "imported": false,
            "current_name": "update_linked_list_0000058e"
        },
        "FUN_0000656c": {
            "renaming": {
                "FUN_0000656c": "FUNC_0000656c"
            },
            "code": "\nundefined4 FUNC_0000656c(undefined4 param_1,uint *param_2,byte **param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  code *pcVar3;\n  uint uVar4;\n  byte *pbVar5;\n  uint uVar6;\n  undefined4 *puVar7;\n  uint *puVar8;\n  uint *puVar9;\n  uint *puVar10;\n  int unaff_r9;\n  int iVar11;\n  undefined4 local_34 [4];\n  \n  local_34[0] = *(undefined4 *)PTR_PTR_DAT_00006744;\n  local_34[1] = *(undefined4 *)(PTR_PTR_DAT_00006744 + 4);\n  local_34[2] = *(undefined4 *)(PTR_PTR_DAT_00006744 + 8);\n  pcVar3 = (code *)PTR_LAB_00004f80_1_0000674c;\n  if (param_2[6] != 3) {\n    pcVar3 = (code *)PTR_LAB_00005fd4_1_00006748;\n  }\n  uVar6 = param_2[2];\n  uVar4 = uVar6 - 1;\n  if (0x15c < uVar4) {\n    unaff_r9 = uVar6 - 0x15d;\n    uVar6 = 0x15d;\n  }\n  if (0x15c < uVar4) {\n    param_2[2] = uVar6;\n  }\n  puVar10 = param_2 + 7;\n  if (uVar4 < 0x15d) {\n    unaff_r9 = 0;\n  }\n  *param_2 = *param_2 | 0xd00;\n  iVar11 = 0;\n  puVar9 = puVar10;\n  do {\n    iVar1 = find_byte_sequence_00006010(local_34[iVar11],**param_3,2);\n    if (iVar1 != 0) {\n      if (iVar11 == 1) {\n        if (param_2[1] == 0) {\n          param_2[1] = 8;\n          *param_2 = *param_2 | 0x200;\n        }\n        uVar4 = *param_2 & 0xfffffaff;\nLAB_000065f4:\n        *param_2 = uVar4;\n      }\n      else if (iVar11 == 2) {\n        if ((*param_2 & 0x600) != 0x200) goto LAB_00006624;\n        param_2[1] = 0x10;\n        uVar4 = *param_2 | 0x100;\n        goto LAB_000065f4;\n      }\n      uVar4 = param_2[2];\n      param_2[2] = uVar4 - 1;\n      if (uVar4 != 0) {\n        pbVar5 = *param_3;\n        *param_3 = pbVar5 + 1;\n        puVar8 = (uint *)((int)puVar9 + 1);\n        *(byte *)puVar9 = *pbVar5;\n        pbVar5 = param_3[1];\n        param_3[1] = pbVar5 + -1;\n        puVar9 = puVar8;\n        if (((int)(pbVar5 + -1) < 1) &&\n           (iVar1 = (*(code *)param_2[0x60])(param_1,param_3), iVar1 != 0)) {\n          iVar11 = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    iVar11 = iVar11 + 1;\n  } while (iVar11 != 3);\n  if (param_2[1] == 0) {\n    param_2[1] = 10;\n  }\n  replace_chars_0000687c(param_2[5],(int)PTR_DAT_00006750 - param_2[1]);\n  iVar11 = 0;\n  while( true ) {\n    puVar8 = puVar9;\n    if (param_2[2] == 0) break;\n    pbVar5 = *param_3;\n    uVar4 = (uint)*pbVar5;\n    if (*(char *)(param_2[5] + uVar4) == '\\0') break;\n    if ((uVar4 == 0x30) && ((int)(*param_2 << 0x14) < 0)) {\n      iVar11 = iVar11 + 1;\n      if (unaff_r9 != 0) {\n        unaff_r9 = unaff_r9 + -1;\n        param_2[2] = param_2[2] + 1;\n      }\n    }\n    else {\n      *param_2 = *param_2 & 0xfffff6ff;\n      puVar8 = (uint *)((int)puVar9 + 1);\n      *(byte *)puVar9 = *pbVar5;\n    }\n    pbVar5 = param_3[1];\n    param_3[1] = pbVar5 + -1;\n    if ((int)(pbVar5 + -1) < 1) {\n      iVar1 = (*(code *)param_2[0x60])(param_1,param_3);\n      if (iVar1 != 0) break;\n    }\n    else {\n      *param_3 = *param_3 + 1;\n    }\n    param_2[2] = param_2[2] - 1;\n    puVar9 = puVar8;\n  }\nLAB_000066ca:\n  if ((int)(*param_2 << 0x17) < 0) {\n    if (puVar10 < puVar8) {\n      (*(code *)param_2[0x5f])(param_1,*(byte *)((int)puVar8 + -1),param_3);\n      puVar8 = (uint *)((int)puVar8 + -1);\n    }\n    if (puVar8 == puVar10) {\n      return 1;\n    }\n  }\n  if ((*param_2 & 0x10) == 0) {\n    *(byte *)puVar8 = 0;\n    uVar2 = (*pcVar3)(param_1,puVar10,0,param_2[1]);\n    puVar7 = (undefined4 *)*param_4;\n    uVar4 = *param_2;\n    *param_4 = puVar7 + 1;\n    puVar7 = (undefined4 *)*puVar7;\n    if ((uVar4 & 0x20) == 0) {\n      if ((int)(uVar4 << 0x1f) < 0) {\n        *(short *)puVar7 = (short)uVar2;\n      }\n      else {\n        *puVar7 = uVar2;\n      }\n    }\n    else {\n      *puVar7 = uVar2;\n    }\n    param_2[3] = param_2[3] + 1;\n  }\n  param_2[4] = (uint)((int)puVar8 + param_2[4] + (iVar11 - (int)puVar10));\n  return 0;\n}\n\n",
            "called": [
                "FUN_0000687c",
                "FUN_00006010"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0000656c",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "FUNC_0000656c"
        },
        "FUN_000025f4": {
            "renaming": {
                "FUN_000025f4": "initialize_system_and_return_000025f4",
                "initialize_system_000027b0": "initialize_system"
            },
            "code": "void initialize_system_and_return_000025f4(void)\n{\n  initialize_system();\n  return;\n}",
            "called": [
                "FUN_000027b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000025f4",
            "calling": [
                "FUN_00002396"
            ],
            "imported": false,
            "current_name": "initialize_system_and_return_000025f4"
        },
        "FUN_00001ddc": {
            "renaming": {
                "FUN_00001ddc": "extract_bits_and_set_value_at_offset_00001ddc",
                "param_1": "bits",
                "cVar1": "extracted_bits"
            },
            "code": "void extract_bits_and_set_value_at_offset_00001ddc(unsigned short bits) {\n  char extracted_bits = get_bits_from_right(bits);\n  set_value_at_calculated_offset(DAT_00001e08, extracted_bits + 9);\n  return;\n}",
            "called": [
                "FUN_00001d3a",
                "FUN_00001da2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ddc",
            "calling": [
                "FUN_00001f80"
            ],
            "imported": false,
            "current_name": "extract_bits_and_set_value_at_offset_00001ddc"
        },
        "FUN_00002ecc": {
            "renaming": {
                "FUN_00002ecc": "read_data_from_device_and_display_00002ecc",
                "param_1": "device_address",
                "param_2": "data_size",
                "uVar1": "class_name",
                "uVar2": "data_address",
                "auStack_1c": "data_buffer",
                "local_14": "execute_result"
            },
            "code": "void read_data_from_device_and_display_00002ecc(uint32_t device_address, int data_size) {\n  uint32_t data_buffer[2];\n  uint32_t execute_result = execute_function_00003d64(data_size, data_buffer);\n  if ((int)execute_result < 1) {\n    initialize_data_00004c84(PTR_s_error__failed_to_read_from_devic_00002f28, device_address);\n  }\n  else {\n    uint32_t data_address = *(uint32_t *)(data_size + 8);\n    uint8_t data_class = *(uint8_t *)(*(int *)(data_size + 0xc) + 8);\n    uint32_t class_name = get_class_000039e8(data_class);\n    initialize_data_00004c84(PTR_s_Reading_from___i___s__s__00002f2c, device_address, data_address, class_name);\n    display_data_object_00003694((uint8_t*)data_buffer, execute_result & 0xff);\n  }\n  return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00003d64",
                "FUN_000039e8",
                "FUN_00003694"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002ecc",
            "calling": [
                "FUN_00002fe0",
                "FUN_00002f30"
            ],
            "imported": false,
            "current_name": "read_data_from_device_and_display_00002ecc"
        },
        "FUN_00000d76": {
            "renaming": {
                "FUN_00000d76": "clear_memory_at_offset_00000d76",
                "param_1": "base_address",
                "param_2": "offset",
                "puVar1": "memory_location",
                "*puVar1": "*memory_location"
            },
            "code": "void clear_memory_at_offset_00000d76(void* base_address, unsigned int offset) {\n  undefined4* memory_location = (undefined4*)calculate_offset(base_address, offset);\n  *memory_location = 0;\n  return;\n}",
            "called": [
                "FUN_00000d44"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d76",
            "calling": [
                "FUN_00000d9c"
            ],
            "imported": false,
            "current_name": "clear_memory_at_offset_00000d76"
        },
        "FUN_000057a8": {
            "renaming": {
                "FUN_000057a8": "process_input_000057a8",
                "param_1": "previous_input",
                "param_2": "current_input",
                "param_3": "input_buffer",
                "iVar1": "buffer_length",
                "puVar2": "current_position",
                "process_data_00005404": "process_data"
            },
            "code": "int process_input_000057a8(int previous_input, int current_input, int *input_buffer)\n{\n  int buffer_length = input_buffer[2] - 1;\n  input_buffer[2] = buffer_length;\n  if ((buffer_length < 0) && ((buffer_length < (int)input_buffer[6] || (current_input == 10)))) {\n    int processed_data = process_data();\n    return processed_data;\n  }\n  undefined *current_position = (undefined *)*input_buffer;\n  *input_buffer = current_position + 1;\n  *current_position = (char)current_input;\n  return current_input;\n}",
            "called": [
                "FUN_00005404"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057a8",
            "calling": [
                "FUN_000057d2"
            ],
            "imported": false,
            "current_name": "process_input_000057a8"
        },
        "FUN_00001696": {
            "renaming": {
                "FUN_00001696": "calculate_result_00001696",
                "param_1": "input_value",
                "param_2": "multiplier"
            },
            "code": "int calculate_result_00001696(uint32_t input_value, int multiplier) {\n    uint32_t masked_input = input_value & 0xf0000000;\n    uint32_t shifted_input = (input_value & 0xfffff) << 5;\n    int result = (multiplier * 4) + masked_input + shifted_input + 0x2000000;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001696",
            "calling": [
                "FUN_000016ec",
                "FUN_000016c8",
                "FUN_00001710"
            ],
            "imported": false,
            "current_name": "calculate_result_00001696"
        },
        "FUN_000008b8": {
            "renaming": {
                "FUN_000008b8": "count_elf32_relocations_000008b8",
                "local_c": "current_relocation"
            },
            "code": "int count_elf32_relocations_000008b8() {\n  int *current_relocation = (int *)PTR_DAT_000008f4;\n  while (*current_relocation == DAT_000008f8 && current_relocation < PTR_Elf32_Rel_ARRAY_000008fc) {\n    current_relocation++;\n  }\n  return ((int)PTR_Elf32_Rel_ARRAY_000008fc - (int)current_relocation) / 4 * 4;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000008b8",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "count_elf32_relocations_000008b8"
        },
        "FUN_000024bc": {
            "renaming": {
                "FUN_000024bc": "processLinkedList_000024bc",
                "param_1": "listHead",
                "uVar1": "exceptionFlag",
                "uVar2": "interruptsEnabled",
                "iVar3": "nodeValue",
                "check_interrupts_enabled_00000cd0": "checkInterruptsEnabled",
                "enable_irq_interrupts_if_privileged_00000d0c": "enableIrqInterruptsIfPrivileged",
                "getNextNodeValue_0000240c": "getNextNodeValue",
                "update_or_remove_element_00000698": "updateOrRemoveElement",
                "check_exception_and_set_flag_if_needed_00000738": "checkExceptionAndSetFlagIfNeeded"
            },
            "code": "void processLinkedList_000024bc(int *listHead) {\n    bool interruptsEnabled = checkInterruptsEnabled();\n    if (*listHead == 0) {\n        enableIrqInterruptsIfPrivileged(interruptsEnabled);\n    }\n    else if (*listHead == -1) {\n        *listHead = 0;\n        enableIrqInterruptsIfPrivileged(interruptsEnabled);\n    }\n    else {\n        int nodeValue = getNextNodeValue(listHead);\n        updateOrRemoveElement(nodeValue - 8, 10);\n        if (*listHead == 0) {\n            *listHead = -1;\n        }\n        char exceptionFlag = *(char *)(nodeValue - 3);\n        enableIrqInterruptsIfPrivileged(interruptsEnabled);\n        checkExceptionAndSetFlagIfNeeded(exceptionFlag);\n    }\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000d0c",
                "FUN_0000240c",
                "FUN_00000cd0",
                "FUN_00000738"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000024bc",
            "calling": [
                "FUN_000012b4"
            ],
            "imported": false,
            "current_name": "processLinkedList_000024bc"
        },
        "FUN_00000490": {
            "renaming": {
                "FUN_00000490": "find_first_non_matching_pointer_index_00000490",
                "param_1": "pointer_array",
                "param_2": "array_length",
                "param_3": "target_array",
                "param_4": "target_length",
                "uVar1": "index"
            },
            "code": "int find_first_non_matching_pointer_index_00000490(int *pointer_array, int array_length, int *target_array, int target_length) {\n  int index = 0;\n  while (index < array_length && index < target_length && pointer_array[index] == target_array[index]) {\n    index++;\n  }\n  return index;\n}",
            "called": [
                "FUN_00000e14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000490",
            "calling": [
                "FUN_00004dc8"
            ],
            "imported": false,
            "current_name": "find_first_non_matching_pointer_index_00000490"
        },
        "FUN_0000091c": {
            "renaming": {
                "FUN_0000091c": "get_pointer_data_0000091c",
                "PTR_DAT_0000092c": "pointer_data"
            },
            "code": "const char* get_pointer_data_0000091c(void)\n{\n  return PTR_DAT_0000092c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000091c",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "get_pointer_data_0000091c"
        },
        "FUN_00001f80": {
            "renaming": {
                "FUN_00001f80": "setBitsAndValueAtOffset_00001f80",
                "param_1": "bitField",
                "param_2": "value",
                "iVar1": "address",
                "iVar2": "index",
                "uVar3": "bits",
                "uVar4": "bitIndex",
                "uVar5": "oldValue",
                "extract_bits_and_set_value_at_offset_00001ddc": "N/A",
                "convertParamToAddress_00001d5e": "convertParamToAddress",
                "extract_lower_6_bits_00001dc0": "extractLower6Bits",
                "getBitsFromRight_00001da2": "getBitsFromRight",
                "update_data_with_bits_at_index_00001ec4": "updateDataWithBitsAtIndex"
            },
            "code": "void setBitsAndValueAtOffset_00001f80(uint16_t bitField, uint32_t value) {\n  uint32_t* address = (uint32_t*)convertParamToAddress(bitField);\n  uint8_t index = extractLower6Bits(bitField);\n  uint32_t oldValue = *(address + index);\n  *(address + index) = value;\n  if ((oldValue & 0xf0000) != 0) {\n    uint32_t bits = getBitsFromRight(bitField);\n    uint8_t bitIndex = extractLower6Bits(bitField);\n    updateDataWithBitsAtIndex(bits, bitIndex);\n  }\n  return;\n}",
            "called": [
                "FUN_00001dc0",
                "FUN_00001ddc",
                "FUN_00001ec4",
                "FUN_00001d5e",
                "FUN_00001da2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001f80",
            "calling": [
                "FUN_00001448",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "setBitsAndValueAtOffset_00001f80"
        },
        "FUN_00000e64": {
            "renaming": {
                "FUN_00000e64": "set_bits_and_execute_instructions_00000e64",
                "DAT_00000ed0": "insert_offset",
                "DAT_00000ed4": "data_address"
            },
            "code": "void set_bits_and_execute_instructions_00000e64(void)\n{\n  uint32_t* insert_address = find_and_insert_00001034 + DAT_00000ed0 + 4;\n  *insert_address = *insert_address | 0x200;\n  uint32_t* DAT_00000ed4 = DAT_00000ed4 + 0x48;\n  *DAT_00000ed4 = *DAT_00000ed4 & 0xfefff8ff;\n  initialize_and_execute_instructions_00001274();\n  set_bits_and_value_at_offset_00001eea(0x2056,0x80);\n  set_bits_and_value_at_offset_00001eea(0x511a,0x80);\n  set_bits_and_value_at_offset_00001eea(0x2055,0x80);\n  set_bit_at_position_00001ff6(0x2056);\n  set_bit_at_position_00001ff6(0x511a);\n  set_bit_at_position_00001ff6(0x2055);\n  return;\n}",
            "called": [
                "FUN_00001ff6",
                "FUN_00001eea",
                "FUN_00001274"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e64",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "set_bits_and_execute_instructions_00000e64"
        },
        "FUN_000026e4": {
            "renaming": {
                "FUN_000026e4": "clearInterruptFlag_000026e4"
            },
            "code": "void clearInterruptFlag_000026e4(void)\n{\n  clear_interrupt_flag_00002970();\n  return;\n}",
            "called": [
                "FUN_00002970"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026e4",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "clearInterruptFlag_000026e4"
        },
        "FUN_00000d44": {
            "renaming": {
                "FUN_00000d44": "calculate_offset_00000d44",
                "param_1": "base_address",
                "param_2": "offset",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int calculate_offset_00000d44(uint32_t base_address, int offset) {\n    uint32_t high_bits = base_address & 0xf0000000;\n    uint32_t low_bits = base_address & 0xfffff;\n    uint32_t shifted_low_bits = low_bits << 5;\n    int result = offset * 4 + high_bits + shifted_low_bits + 0x2000000;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d44",
            "calling": [
                "FUN_00000d76"
            ],
            "imported": false,
            "current_name": "calculate_offset_00000d44"
        },
        "FUN_00000698": {
            "renaming": {
                "FUN_00000698": "update_or_remove_element_00000698",
                "param_1": "element_index",
                "param_2": "new_element_value",
                "PTR_DAT_00000730": "linked_list_pointer",
                "PTR_DAT_00000734": "bitmask_pointer"
            },
            "code": "void update_or_remove_element_00000698(int element_index, uint8_t new_element_value) {\n  if (new_element_value < 9) {\n    uint8_t current_element_value = *(uint8_t *)(element_index + 4);\n    if ((current_element_value > 8) && (remove_first_element_from_list(PTR_DAT_00000730 + (uint)*(uint8_t *)(element_index + 5) * 4), *(int *)(PTR_DAT_00000730 + (uint)*(uint8_t *)(element_index + 5) * 4) == 0)) {\n      *(uint *)PTR_DAT_00000734 = *(uint *)PTR_DAT_00000734 & ~(1 << *(int8_t *)(element_index + 5));\n    }\n  }\n  else if (*(uint8_t *)(element_index + 4) < 9) {\n    update_linked_list(PTR_DAT_00000730 + (uint)*(uint8_t *)(element_index + 5) * 4, element_index + 8);\n    *(uint *)PTR_DAT_00000734 = *(uint *)PTR_DAT_00000734 | 1 << *(int8_t *)(element_index + 5);\n  }\n  *(uint8_t *)(element_index + 4) = (uint8_t)new_element_value;\n  return;\n}",
            "called": [
                "FUN_000005ca",
                "FUN_0000058e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000698",
            "calling": [
                "FUN_000010d4",
                "FUN_00000794",
                "FUN_000024bc",
                "FUN_00002434"
            ],
            "imported": false,
            "current_name": "update_or_remove_element_00000698"
        },
        "FUN_00000cd0": {
            "renaming": {
                "FUN_00000cd0": "check_interrupts_enabled_00000cd0",
                "uVar2": "are_interrupts_enabled",
                "bVar1": "is_privileged_mode",
                "isCurrentModePrivileged": "isCurrentModePrivileged",
                "isIRQinterruptsEnabled": "isIRQinterruptsEnabled",
                "disableIRQinterrupts": "disableIRQinterrupts"
            },
            "code": "bool is_privileged_mode = check_interrupts_enabled_00000cd0();\nbool are_interrupts_enabled = false;\nif (is_privileged_mode) {\n  are_interrupts_enabled = isIRQinterruptsEnabled();\n}\ndisableIRQinterrupts();\nreturn are_interrupts_enabled;",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cd0",
            "calling": [
                "FUN_000010d4",
                "FUN_00000f8c",
                "FUN_00000794",
                "FUN_00000f04",
                "FUN_000024bc",
                "FUN_00002434",
                "FUN_00000e58",
                "FUN_00001c84",
                "FUN_00000428"
            ],
            "imported": false,
            "current_name": "check_interrupts_enabled_00000cd0"
        },
        "FUN_00000cc0": {
            "renaming": {
                "FUN_00000cc0": "check_irq_interrupts_enabled_00000cc0",
                "uVar2": "irq_interrupts_enabled",
                "bVar1": "is_privileged_mode"
            },
            "code": "int check_irq_interrupts_enabled_00000cc0(void)\n{\n  bool is_privileged_mode = (bool)isCurrentModePrivileged();\n  int irq_interrupts_enabled = 0;\n  if (is_privileged_mode) {\n    irq_interrupts_enabled = isIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return irq_interrupts_enabled;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cc0",
            "calling": [
                "FUN_00000dc0"
            ],
            "imported": false,
            "current_name": "check_irq_interrupts_enabled_00000cc0"
        },
        "FUN_00002994": {
            "renaming": {
                "FUN_00002994": "check_and_call_functions_00002994",
                "DAT_000029f8": "data"
            },
            "code": "void check_and_call_functions_00002994(void)\n{\n  int DAT_000029f8 = DAT_000029f8;\n  if (((*(uint *)(DAT_000029f8 + 0x14) & 4) != 0) && (*(int *)PTR_DAT_000029fc != 0)) {\n    *(uint *)(DAT_000029f8 + 0x1c) &= 0xfffffffb;\n    (**(code **)PTR_DAT_000029fc)(*(undefined4 *)(PTR_DAT_000029fc + 4));\n  }\n  if (((*(uint *)(DAT_000029f8 + 0x14) & 2) != 0) && (*(int *)(PTR_DAT_000029fc + 8) != 0)) {\n    (**(code **)(PTR_DAT_000029fc + 8))(*(undefined4 *)(PTR_DAT_000029fc + 0xc));\n  }\n  check_flag_and_set_00002798();\n  return;\n}",
            "called": [
                "FUN_00002798"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002994",
            "calling": [],
            "imported": false,
            "current_name": "check_and_call_functions_00002994"
        },
        "FUN_00000d2a": {
            "renaming": {
                "FUN_00000d2a": "get_current_exception_number_if_privileged_mode_00000d2a",
                "bVar1": "is_privileged_mode",
                "uVar2": "current_exception_number"
            },
            "code": "uint get_current_exception_number_if_privileged_mode_00000d2a() {\n  bool is_privileged_mode = (bool)isCurrentModePrivileged();\n  uint current_exception_number = 0;\n  if (is_privileged_mode) {\n    current_exception_number = getCurrentExceptionNumber() & 0x1f;\n  }\n  return current_exception_number;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d2a",
            "calling": [
                "FUN_00000738"
            ],
            "imported": false,
            "current_name": "get_current_exception_number_if_privileged_mode_00000d2a"
        },
        "FUN_00001ff6": {
            "renaming": {
                "FUN_00001ff6": "set_bit_at_position_00001ff6",
                "param_1": "param",
                "uVar1": "lower_6_bits",
                "iVar2": "masked_value"
            },
            "code": "void set_bit_at_position_00001ff6(uint8_t bit_position)\n{\n  uint8_t lower_6_bits = extract_lower_6_bits(param);\n  int masked_value = get_masked_value(param);\n  *(int *)(masked_value + 4) = 1 << (lower_6_bits & 0xff);\n  return;\n}",
            "called": [
                "FUN_00001d80",
                "FUN_00001dc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ff6",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "set_bit_at_position_00001ff6"
        },
        "FUN_000013b8": {
            "renaming": {
                "FUN_000013b8": "setValueAndCheck_000013b8",
                "param_1": "index",
                "param_2": "valueToSet",
                "param_3": "bitToSet",
                "param_4": "dataPtr",
                "uVar1": "result",
                "PTR_s_FAILED_ASSERTION__0000143c": "assertionMessagePtr",
                "PTR_DAT_00001440": "dataPtr",
                "checkAndUpdateValues_00001448": "checkAndUpdateValues",
                "set_calculated_address_to_one_00001392": "setCalculatedAddressToOne",
                "PTR_DAT_00001444": "dataPtr",
                "set_bit_in_integer_array_000014c4": "setBitInIntegerArray"
            },
            "code": "int setValueAndCheck_000013b8(int index, int valueToSet, int bitToSet, int *PTR_DAT_00001440, char *PTR_s_FAILED_ASSERTION__0000143c) {\n    int result = -1;\n    if (index != 0) {\n        initializeAndExecute(3, PTR_s_FAILED_ASSERTION__0000143c);\n    }\n    *(PTR_DAT_00001440 + index * 2) = valueToSet;\n    *(PTR_DAT_00001440 + index * 2 + 1) = bitToSet;\n    checkAndUpdateValues_00001448(index, PTR_DAT_00001440);\n    set_calculated_address_to_one_00001392(*(PTR_DAT_00001440 + index * 32 + 6), *(PTR_DAT_00001440 + index * 32 + 7));\n    if (*(PTR_DAT_00001440 + index * 32 + 7) == 0) {\n        set_bit_in_integer_array_000014c4(index, result);\n        result = 0;\n    }\n    else {\n        result = -1;\n    }\n    return result;\n}",
            "called": [
                "FUN_00001392",
                "FUN_00000f04",
                "FUN_000014c4",
                "FUN_00001448"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000013b8",
            "calling": [
                "FUN_00000df4"
            ],
            "imported": false,
            "current_name": "setValueAndCheck_000013b8"
        },
        "FUN_00002a88": {
            "renaming": {
                "FUN_00002a88": "print_command_descriptions_00002a88",
                "param_1": "command_descriptions",
                "local_18": "command_pointers",
                "local_10": "i",
                "local_c": "current_command",
                "PTR_s___20s__s_00002b04": "command_description_format",
                "PTR_s_Command_00002b00": "command_name_format",
                "PTR_s_Description_00002afc": "command_description_title",
                "PTR_s__________________________________00002b08": "reboot_command_description",
                "PTR_PTR_s_reboot_00002b0c": "reboot_command_pointer"
            },
            "code": "void print_command_descriptions_00002a88(int *command_descriptions)\n{\n  int *current_command;\n  int **reboot_command = (int **)PTR_PTR_s_reboot_00002b0c;\n  initialize_data_00004c84(PTR_s___20s__s_00002b04,PTR_s_Command_00002b00,PTR_s_Description_00002afc);\n  FUNC_00004db8(PTR_s__________________________________00002b08);\n  for (uint i = 0; i < 2; i++) {\n    current_command = (int *)command_descriptions[i];\n    if (current_command != (int *)0x0) {\n      while (*current_command != 0) {\n        initialize_data_00004c84(PTR_s___20s__s_00002b04,*current_command,current_command[1]);\n        current_command = current_command + 3;\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a88",
            "calling": [
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "print_command_descriptions_00002a88",
            "code_backup": "\nvoid FUN_00002a88(int *param_1)\n\n{\n  int *local_18 [2];\n  uint local_10;\n  int *local_c;\n  \n  FUNC_00004c84(PTR_s___20s__s_00002b04,PTR_s_Command_00002b00,PTR_s_Description_00002afc);\n  FUNC_00004db8(PTR_s__________________________________00002b08);\n  local_18[0] = param_1;\n  local_18[1] = (int *)PTR_PTR_s_reboot_00002b0c;\n  for (local_10 = 0; local_10 < 2; local_10 = local_10 + 1) {\n    local_c = local_18[local_10];\n    if (local_c != (int *)0x0) {\n      for (; *local_c != 0; local_c = local_c + 3) {\n        FUNC_00004c84(PTR_s___20s__s_00002b04,*local_c,local_c[1]);\n      }\n    }\n  }\n  return;\n}\n\n"
        },
        "FUN_00002f30": {
            "renaming": {
                "FUN_00002f30": "read_and_display_data_from_device_00002f30",
                "local_10": "device_index",
                "local_c": "device_data_ptr"
            },
            "code": "void read_and_display_data_from_device_00002f30(void)\n{\n  int device_index = 0;\n  undefined4 *device_data_ptr = *(undefined4 **)PTR_DAT_00002f6c;\n  for (; device_data_ptr != (undefined4 *)0x0; device_data_ptr = (undefined4 *)*device_data_ptr) {\n    read_data_from_device_and_display_00002ecc(device_index, device_data_ptr);\n    FUNC_00004db8(PTR_DAT_00002f70);\n    device_index++;\n  }\n  return;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00002ecc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f30",
            "calling": [
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "read_and_display_data_from_device_00002f30"
        },
        "FUN_00001e44": {
            "renaming": {
                "FUN_00001e44": "update_data_at_index_00001e44",
                "param_1": "index",
                "param_2": "bit_offset",
                "param_3": "data",
                "iVar1": "byte_offset",
                "PTR_DAT_00001ec0": "data_ptr"
            },
            "code": "void update_data_at_index_00001e44(uint32_t index, uint32_t bit_offset, uint32_t data) {\n    uint32_t* PTR_DAT_00001ec0 = (uint32_t*)PTR_DAT_00001ec0;\n    uint32_t index_offset = index * 4;\n    uint32_t byte_offset = bit_offset >> 3;\n    uint32_t bit_shift = (bit_offset & 7) << 2;\n    uint32_t mask = ~(0xf << bit_shift);\n    PTR_DAT_00001ec0[index_offset + byte_offset] &= mask;\n    PTR_DAT_00001ec0[index_offset + byte_offset] |= (data << bit_shift);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e44",
            "calling": [
                "FUN_00001ec4"
            ],
            "imported": false,
            "current_name": "update_data_at_index_00001e44"
        },
        "FUN_00001318": {
            "renaming": {
                "FUN_00001318": "set_bit_in_integer_array_00001318",
                "param_1": "bit_index",
                "PTR_DAT_00001344": "array_ptr",
                "DAT_00001344": "array_data"
            },
            "code": "void set_bit_in_integer_array_00001318(byte bit_index) {\n    int* PTR_DAT_00001344 = (int*)(DAT_00001344 + ((uint)(int)(char)bit_index >> 5) * 4);\n    int bit_mask = 1 << (bit_index & 0x1f);\n    *PTR_DAT_00001344 = bit_mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001318",
            "calling": [
                "FUN_000014c4"
            ],
            "imported": false,
            "current_name": "set_bit_in_integer_array_00001318"
        },
        "FUN_00000900": {
            "renaming": {
                "FUN_00000900": "get_main_stack_pointer_00000900",
                "uVar1": "main_stack_pointer"
            },
            "code": "uint32_t get_main_stack_pointer_00000900(void)\n{\n  uint32_t main_stack_pointer;\n  main_stack_pointer = getMainStackPointer();\n  return main_stack_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000900",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "get_main_stack_pointer_00000900"
        },
        "FUN_00004274": {
            "renaming": {
                "FUN_00004274": "do_nothing_with_pointer_00004274",
                "PTR_DAT_0000427c": "PTR_pointer"
            },
            "code": "void do_nothing_with_pointer_00004274(void)\n{\n  do_nothing(PTR_DAT_0000427c);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004274",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_00004274"
        },
        "FUN_00002fe0": {
            "renaming": {
                "FUN_00002fe0": "process_device_data_00002fe0",
                "param_1": "argc",
                "param_2": "argv",
                "iVar1": "device_index",
                "uVar2": "device_id",
                "initialize_data_00004c84": "initialize_device_data",
                "PTR_s_usage___s__s__device_id__all_00003050": "PTR_s_device_data_usage",
                "compare_byte_arrays_00004e52": "compare_device_id",
                "PTR_DAT_00003054": "PTR_default_device_id",
                "read_and_display_data_from_device_00002f30": "read_and_display_device_data",
                "convert_string_to_integer_00004042": "atoi",
                "find_nth_element_00003d24": "find_device_index",
                "FUNC_00004db8": "print_error",
                "PTR_s_error__undefined_device_id_given_00003058": "PTR_error_undefined_device_id_given",
                "read_data_from_device_and_display_00002ecc": "read_and_display_device_data"
            },
            "code": "void process_device_data_00002fe0(int argc, char** argv) {\n  int num_args = argc - 1;\n  if (num_args < 2) {\n    initialize_device_data(PTR_s_usage___s__s__device_id__all_00003050, *argv, argv[1]);\n  }\n  else {\n    int device_id = convert_string_to_integer_00004042(argv[2]);\n    int device_index = find_nth_element_00003d24(device_id);\n    if (device_index == 0) {\n      FUNC_00004db8(PTR_s_error__undefined_device_id_given_00003058);\n    }\n    else if (compare_byte_arrays_00004e52(argv[2], PTR_DAT_00003054) == 0) {\n      read_and_display_device_data();\n    }\n    else {\n      read_and_display_device_data(device_id, device_index);\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_00004e52",
                "FUN_00002ecc",
                "FUN_00002f30",
                "FUN_00003d24",
                "FUN_00004042"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002fe0",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "process_device_data_00002fe0"
        },
        "FUN_00001dc0": {
            "renaming": {
                "FUN_00001dc0": "extract_lower_6_bits_00001dc0",
                "param_1": "input_num"
            },
            "code": "ushort extract_lower_6_bits_00001dc0(ushort input_num) {\n    ushort lower_6_bits = input_num & 0x3f;\n    return lower_6_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001dc0",
            "calling": [
                "FUN_00001f80",
                "FUN_00001ff6",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "extract_lower_6_bits_00001dc0"
        },
        "FUN_00000df4": {
            "renaming": {
                "FUN_00000df4": "initializeLinkedListAndUpdateArray_00000df4",
                "setValueAndCheck_000013b8": "setValueAndCheck",
                "PTR_update_array_and_process_linked_list_000012b4_1_00000e10": "updateLinkedListAndProcessArray",
                "DAT_00000e0c": "dataList"
            },
            "code": "void initializeLinkedListAndUpdateArray_00000df4(void)\n{\n  int initialValue = 0;\n  int arrayValue = 0x1c200;\n  setValueAndCheck(initialValue, arrayValue, PTR_update_array_and_process_linked_list_000012b4_1_00000e10, DAT_00000e0c);\n  return;\n}",
            "called": [
                "FUN_000013b8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000df4",
            "calling": [
                "FUN_00000410"
            ],
            "imported": false,
            "current_name": "initializeLinkedListAndUpdateArray_00000df4"
        },
        "FUN_00002400": {
            "renaming": {
                "FUN_00002400": "do_nothing_00002400"
            },
            "code": "\nvoid do_nothing_00002400(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002400",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "do_nothing_00002400"
        },
        "FUN_00002eb4": {
            "renaming": {
                "FUN_00002eb4": "print_relocation_info_and_return_zero_00002eb4"
            },
            "code": "int print_relocation_info_and_return_zero_00002eb4(void)\n{\n  print_relocation_info();\n  return 0;\n}",
            "called": [
                "FUN_0000211c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002eb4",
            "calling": [],
            "imported": false,
            "current_name": "print_relocation_info_and_return_zero_00002eb4"
        },
        "FUN_0000328c": {
            "renaming": {
                "FUN_0000328c": "parse_input_and_calculate_results_0000328c",
                "*param_1": "input_string",
                "*param_2": "input_array",
                "local_10": "string_index",
                "local_a": "parsed_integer"
            },
            "code": "int parse_input_and_calculate_results_0000328c(int *input_array, char *input_string)\n{\n  int string_index = 0;\n  int parsed_integer;\n\n  parsed_integer = convert_string_to_integer(input_string, &string_index, 10);\n  input_array[5] = parsed_integer - 0x76c;\n\n  parsed_integer = convert_string_to_integer(input_string + string_index + 1, &string_index, 10);\n  input_array[4] = parsed_integer - 1;\n\n  parsed_integer = convert_string_to_integer(input_string + string_index + 1, &string_index, 10);\n  input_array[3] = parsed_integer;\n\n  parsed_integer = convert_string_to_integer(input_string + string_index + 1, &string_index, 10);\n  input_array[2] = parsed_integer;\n\n  parsed_integer = convert_string_to_integer(input_string + string_index + 1, &string_index, 10);\n  input_array[1] = parsed_integer;\n\n  parsed_integer = convert_string_to_integer(input_string + string_index + 1, &string_index, 10);\n  input_array[0] = parsed_integer;\n\n  int result = calculate_result(input_array[5] + 0x76c, input_array[4] + 1, input_array[3]);\n  input_array[6] = result;\n  input_array[8] = -1;\n  return 0;\n}",
            "called": [
                "FUN_00004f84",
                "FUN_000031fc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000328c",
            "calling": [
                "FUN_000033f4",
                "FUN_00003478"
            ],
            "imported": false,
            "current_name": "parse_input_and_calculate_results_0000328c"
        },
        "FUN_000041f4": {
            "renaming": {
                "FUN_000041f4": "initialize_values_000041f4",
                "param_1": "memory_address",
                "param_2": "value_1",
                "param_3": "value_2",
                "puVar1": "pointer_1"
            },
            "code": "void initialize_values_000041f4(undefined4 *memory_address, undefined2 value_1, undefined2 value_2)\n{\n  undefined *pointer_1;\n  \n  *memory_address = 0;\n  memory_address[1] = 0;\n  memory_address[2] = 0;\n  memory_address[3] = 0;\n  memory_address[4] = 0;\n  *(undefined2 *)(memory_address + 6) = value_1;\n  memory_address[25] = 0;\n  *(undefined2 *)((int)memory_address + 0xe) = value_2;\n  memory_address[5] = 0;\n  fill_array_with_value(memory_address + 23, 0, 8);\n  memory_address[9] = PTR_find_first_non_matching_pointer_index_and_update_00004dc8_1_0000422c;\n  memory_address[10] = DAT_00004230;\n  memory_address[11] = PTR_set_param_and_update_status_00004e26_1_00004234;\n  pointer_1 = PTR_LAB_00004e4a_1_00004238;\n  memory_address[8] = memory_address;\n  memory_address[12] = pointer_1;\n  return;\n}",
            "called": [
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041f4",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "initialize_values_000041f4"
        },
        "FUN_0000316c": {
            "renaming": {
                "FUN_0000316c": "handle_device_request_0000316c",
                "param_1": "device_count",
                "param_2": "request",
                "iVar1": "comparison_result",
                "print_devices_00002f74": "print_devices",
                "compare_byte_arrays_00004e52": "compare_byte_arrays",
                "process_device_data_00002fe0": "process_device_data",
                "write_data_to_device_0000305c": "write_data_to_device",
                "initialize_data_00004c84": "initialize_data",
                "PTR_DAT_000031d4": "PTR_DAT_device_data",
                "PTR_s_write_000031d8": "PTR_s_write",
                "PTR_s_usage___s_read_write_000031dc": "PTR_s_usage___s_read_write"
            },
            "code": "int handle_device_request_0000316c(int device_count, undefined4 *request) {\n  int comparison_result;\n  if (device_count < 2) {\n    print_devices();\n  }\n  else {\n    comparison_result = compare_byte_arrays_00004e52(request[1], PTR_DAT_000031d4);\n    if (comparison_result == 0) {\n      process_device_data(device_count, request);\n    }\n    else {\n      comparison_result = compare_byte_arrays_00004e52(request[1], PTR_s_write_000031d8_000031d8);\n      if (comparison_result == 0) {\n        write_data_to_device(device_count, request);\n      }\n      else {\n        initialize_data(PTR_s_usage___s_read_write_000031dc_000031dc, *request);\n      }\n    }\n  }\n  return 0;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00002f74",
                "FUN_0000305c",
                "FUN_00004e52",
                "FUN_00002fe0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000316c",
            "calling": [],
            "imported": false,
            "current_name": "handle_device_request_0000316c"
        },
        "FUN_000026f0": {
            "renaming": {
                "FUN_000026f0": "execute_function_if_not_null_000026f0",
                "param_1": "function_ptr",
                "PTR_DAT_00002710": "function_ptr",
                "**code": "function_pointer",
                "PTR_": "function_ptr or data_ptr",
                "DAT_": "data_ptr"
            },
            "code": "void execute_function_if_not_null_000026f0(int* PTR_DAT_00002710){\n                      if (*PTR_DAT_00002710 != 0) {\n                        (**(void (**)())PTR_DAT_00002710)();\n                      }\n                    }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026f0",
            "calling": [],
            "imported": false,
            "current_name": "execute_function_if_not_null_000026f0"
        },
        "FUN_000057d2": {
            "renaming": {
                "FUN_000057d2": "process_input_and_return_result_000057d2",
                "param_1": "input_param_1",
                "param_2": "input_param_2",
                "param_3": "input_string",
                "param_4": "input_string_length",
                "puVar2": "string_end",
                "iVar1": "result"
            },
            "code": "int process_input_and_return_result_000057d2(int input_param_1, int input_param_2, char *input_string, int input_string_length) {\n  int result = 0;\n  char *string_end = input_string + input_string_length;\n  while (input_string != string_end) {\n    if (result == -1) {\n      return -1;\n    }\n    result = process_input_000057a8(input_param_1, *input_string, input_param_2, input_string_length, result);\n    input_string++;\n  }\n  return result;\n}",
            "called": [
                "FUN_000057a8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057d2",
            "calling": [
                "FUN_000057f8"
            ],
            "imported": false,
            "current_name": "process_input_and_return_result_000057d2"
        },
        "FUN_000056b8": {
            "renaming": {
                "FUN_000056b8": "check_value_and_set_flag_000056b8",
                "param_1": "value",
                "param_2": "param_offset",
                "param_3": "flag_ptr",
                "param_4": "result_ptr",
                "iVar1": "set_value_result",
                "uVar2": "flag_value",
                "auStack_68": "flag_value_buf",
                "local_64": "temp_result"
            },
            "code": "int check_value_and_set_flag_000056b8(int value, int param_offset, int *flag_ptr, uint *result_ptr) {\n    int set_value_result;\n    uint flag_value;\n    if (*(short *)(param_offset + 0xe) < 0 || (set_value_result = set_param_value_to_19_00000514(value, (int)*(short *)(param_offset + 0xe), &flag_value), set_value_result < 0)) {\n        *result_ptr = 0;\n        if ((int)((uint)*(ushort *)(param_offset + 0xc) << 0x18) < 0) {\n            flag_value = 0x40;\n        }\n    } else {\n        *result_ptr = (uint)((flag_value & 0xf000) == 0x2000);\n    }\n    *flag_ptr = flag_value;\n    return 0;\n}",
            "called": [
                "FUN_00000514"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b8",
            "calling": [
                "FUN_00005700"
            ],
            "imported": false,
            "current_name": "check_value_and_set_flag_000056b8"
        },
        "FUN_00001a18": {
            "renaming": {
                "FUN_00001a18": "initialize_and_set_result_to_one_00001a18",
                "DAT_00001a34": "result",
                "initializeResult_00001734": "initialize_result",
                "PTR_DAT_00001a38": "ptr"
            },
            "code": "void initialize_and_set_result_to_one_00001a18(void)\n{\n  set_DAT_00001a34_to_one(DAT_00001a34, 1);\n  initialize_DAT_00001a34();\n  *PTR_DAT_00001a38 = 4;\n  return;\n}",
            "called": [
                "FUN_00001734",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a18",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initialize_and_set_result_to_one_00001a18"
        },
        "FUN_00000d9c": {
            "renaming": {
                "FUN_00000d9c": "clear_memory_00000d9c",
                "DAT_00000dac": "data_pointer",
                "clear_memory_at_offset_00000d76": "clear_memory_at_offset"
            },
            "code": "void clear_memory_00000d9c(void)\n{\n    clear_memory_00000d9c_at_offset(DAT_00000dac, 0);\n    return;\n}",
            "called": [
                "FUN_00000d76"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d9c",
            "calling": [
                "FUN_00000db0"
            ],
            "imported": false,
            "current_name": "clear_memory_00000d9c"
        },
        "FUN_00003ff4": {
            "renaming": {
                "FUN_00003ff4": "copy_and_fill_00003ff4",
                "param_1": "start_index",
                "param_2": "end_index",
                "param_3": "array_length",
                "param_4": "fill_value",
                "uVar1": "new_end_index"
            },
            "code": "uint copy_and_fill_00003ff4(uint start_index, uint end_index, uint array_length, undefined fill_value) {\n  uint new_end_index = end_index;\n  if ((end_index < array_length) && (start_index != 0)) {\n    reverse_copy((array_length - end_index) + start_index, start_index, end_index);\n    fill_array_with_value(start_index, fill_value, array_length - end_index);\n  }\n  return new_end_index;\n}",
            "called": [
                "FUN_000045ee",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ff4",
            "calling": [
                "FUN_00003ec4"
            ],
            "imported": false,
            "current_name": "copy_and_fill_00003ff4"
        },
        "FUN_00004634": {
            "renaming": {
                "FUN_00004634": "FUNC_00004634"
            },
            "code": "\nvoid FUNC_00004634(uint *param_1,uint param_2,undefined4 param_3)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  bool bVar6;\n  uint *local_20;\n  uint local_1c;\n  undefined4 uStack_18;\n  \n  local_20 = param_1;\n  local_1c = param_2;\n  uStack_18 = param_3;\n  if (0x3b < *param_1) {\n    divide_and_remainder_00005584(&local_20,*param_1,0x3c);\n    uVar3 = param_1[1] + (int)local_20;\n    param_1[1] = uVar3;\n    if ((int)local_1c < 0) {\n      uVar3 = uVar3 - 1;\n      *param_1 = local_1c + 0x3c;\n    }\n    else {\n      *param_1 = local_1c;\n    }\n    if ((int)local_1c < 0) {\n      param_1[1] = uVar3;\n    }\n  }\n  if (0x3b < param_1[1]) {\n    divide_and_remainder_00005584(&local_20,param_1[1],0x3c);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[2] + (int)local_20;\n    param_1[2] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x3c;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar4;\n    }\n  }\n  if (0x17 < param_1[2]) {\n    divide_and_remainder_00005584(&local_20,param_1[2],0x18);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[3] + (int)local_20;\n    param_1[3] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x18;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[3] = uVar4;\n    }\n  }\n  if (0xb < param_1[4]) {\n    divide_and_remainder_00005584(&local_20,param_1[4],0xc);\n    bVar6 = (int)local_1c < 0;\n    uVar3 = param_1[5] + (int)local_20;\n    param_1[5] = uVar3;\n    if (bVar6) {\n      local_1c = local_1c + 0xc;\n      uVar3 = uVar3 - 1;\n    }\n    if (!bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[5] = uVar3;\n    }\n  }\n  puVar1 = PTR_DAT_000047e0;\n  uVar3 = param_1[5];\n  if ((uVar3 & 3) == 0) {\n    if (uVar3 == (uVar3 / 100) * 100) {\n      if ((uVar3 + 0x76c) % 400 == 0) {\n        iVar5 = 0x1d;\n      }\n      else {\n        iVar5 = 0x1c;\n      }\n    }\n    else {\n      iVar5 = 0x1d;\n    }\n  }\n  else {\n    iVar5 = 0x1c;\n  }\n  if ((int)param_1[3] < 1) {\n    while ((int)param_1[3] < 1) {\n      uVar3 = param_1[4];\n      param_1[4] = uVar3 - 1;\n      if (uVar3 - 1 == 0xffffffff) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 - 1;\n        param_1[4] = 0xb;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 == (uVar3 / 100) * 100) {\n            if ((uVar4 + 0x76b) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n      iVar2 = iVar5;\n      if (param_1[4] != 1) {\n        iVar2 = *(int *)(puVar1 + param_1[4] * 4);\n      }\n      param_1[3] = iVar2 + param_1[3];\n    }\n  }\n  else {\n    while( true ) {\n      uVar3 = param_1[4];\n      iVar2 = iVar5;\n      if (uVar3 != 1) {\n        iVar2 = *(int *)(puVar1 + uVar3 * 4);\n      }\n      if ((int)param_1[3] <= iVar2) break;\n      param_1[3] = param_1[3] - iVar2;\n      param_1[4] = uVar3 + 1;\n      if (uVar3 + 1 == 0xc) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 + 1;\n        param_1[4] = 0;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 % 100 == 0) {\n            if ((uVar4 + 0x76d) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00005584"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00004634",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "FUNC_00004634"
        },
        "FUN_00001d5e": {
            "renaming": {
                "FUN_00001d5e": "convertParamToAddress_00001d5e",
                "param_1": "param",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "uint16_t convertParamToAddress_00001d5e(ushort param) {\n\tuint16_t address = (param & 0x7000) | 0x40048000;\n\treturn address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d5e",
            "calling": [
                "FUN_00001f80",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "convertParamToAddress_00001d5e"
        },
        "FUN_0000191c": {
            "renaming": {
                "FUN_0000191c": "set_and_wait_until_bit_set_0000191c",
                "set_bit_00001778": "set_bit_flags",
                "set_param_1_00001748": "set_parameter",
                "*DAT_00001958": "*data_register"
            },
            "code": "void set_and_wait_until_bit_set_0000191c(void)\n{\n    set_bit_flags();\n    set_parameter(0x40);\n    *DAT_00001958 = *DAT_00001958 & 0x3b;\n    while ((data_register[6] & 0xc) != 0);\n    *PTR_DAT_0000195c = 1;\n    return;\n}",
            "called": [
                "FUN_00001778",
                "FUN_00001748"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000191c",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "set_and_wait_until_bit_set_0000191c"
        },
        "FUN_000050f4": {
            "renaming": {
                "FUN_000050f4": "get_data_pointer_000050f4",
                "PTR_DAT_000050fc": "data_pointer"
            },
            "code": "const char* get_data_pointer_000050f4(void)\n{\n  return PTR_DAT_000050fc;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050f4",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "get_data_pointer_000050f4"
        },
        "FUN_00005a58": {
            "renaming": {
                "FUN_00005a58": "decode_00005a58",
                "param_1": "param_1",
                "param_2": "input_buffer",
                "param_3": "output_buffer",
                "param_4": "param_4",
                "param_5": "callback",
                "iVar1": "callback_result",
                "uVar2": "return_value",
                "uVar3": "max_output_size",
                "uVar4": "remaining_size",
                "bVar5": "is_offset_4",
                "input_offset": "input_offset",
                "i": "i",
                "padding": "padding",
                "j": "j"
            },
            "code": "undefined4 decode_00005a58(uint32_t param_1, uint32_t *input_buffer, uint32_t *output_buffer, uint32_t param_4, code *callback)\n{\n  int i = 0;\n  uint32_t max_output_size = input_buffer[4];\n  if (max_output_size < input_buffer[2]) {\n    max_output_size = input_buffer[2];\n  }\n  *output_buffer = max_output_size;\n  if (*(char *)((int)input_buffer + 0x43) != '\\0') {\n    *output_buffer = max_output_size + 1;\n  }\n  if ((int)(*input_buffer << 0x1a) < 0) {\n    *output_buffer += 2;\n  }\n  uint32_t input_offset = *input_buffer & 6;\n  if (input_offset == 0) {\n    for (; (int)input_offset < (int)(input_buffer[3] - *output_buffer); input_offset++) {\n      int callback_result = (*callback)(param_1, param_4, (int)input_buffer + 0x19, 1);\n      if (callback_result == -1) goto LAB_00005afc;\n    }\n  }\n  uint32_t padding = (uint32_t)*(byte *)((int)input_buffer + 0x43);\n  if (padding != 0) {\n    padding = 1;\n  }\n  if ((int)(*input_buffer << 0x1a) < 0) {\n    *(undefined *)((int)input_buffer + padding + 0x43) = 0x30;\n    *(undefined *)((int)input_buffer + padding + 0x44) = *(undefined *)((int)input_buffer + 0x45);\n    padding += 2;\n  }\n  int callback_result = (*callback)(param_1, param_4, (int)input_buffer + 0x43, padding);\n  if (callback_result == -1) {\n    goto LAB_00005afc;\n  }\n  uint32_t remaining_size = input_buffer[3];\n  bool is_offset_4 = (*input_buffer & 6) == 4;\n  if (is_offset_4) {\n    remaining_size = remaining_size - *output_buffer;\n  }\n  if (is_offset_4) {\n    remaining_size = remaining_size & ~((int)remaining_size >> 0x1f);\n  }\n  else {\n    remaining_size = 0;\n  }\n  if (max_output_size < input_buffer[2]) {\n    remaining_size += (input_buffer[2] - input_buffer[4]);\n  }\n  for (uint32_t j = 0; j < remaining_size; j++) {\n    int callback_result = (*callback)(param_1, param_4, (int)input_buffer + 0x1a, 1);\n    if (callback_result == -1) goto LAB_00005afc;\n  }\n  return 0;\n  LAB_00005afc:\n  return 0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005a58",
            "calling": [
                "FUN_00005b34"
            ],
            "imported": false,
            "current_name": "decode_00005a58"
        },
        "FUN_000056b0": {
            "renaming": {
                "FUN_000056b0": "get_data_000056b0",
                "DAT_000056b4": "data"
            },
            "code": "int get_data_000056b0() {\n    return DAT_000056b4;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b0",
            "calling": [
                "FUN_00005100",
                "FUN_00004f98",
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "get_data_000056b0"
        },
        "FUN_00003d24": {
            "renaming": {
                "FUN_00003d24": "find_nth_element_00003d24",
                "param_1": "n",
                "local_c": "current_element",
                "local_10": "element_count"
            },
            "code": "undefined4* find_nth_element_00003d24(int n)\n{\n  undefined4* current_element = *(undefined4**)PTR_DAT_00003d60;\n  int element_count = 0;\n  \n  while (element_count < n && current_element != (undefined4*)0x0)\n  {\n    current_element = (undefined4*)*current_element;\n    element_count++;\n  }\n  \n  return current_element;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d24",
            "calling": [
                "FUN_0000305c",
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "find_nth_element_00003d24"
        },
        "FUN_000060cc": {
            "renaming": {
                "FUN_000060cc": "allocate_and_insert_node_000060cc",
                "param_1": "address",
                "param_2": "start",
                "param_3": "length",
                "param_4": "data",
                "uVar1": "result",
                "uVar2": "calculated_result",
                "insert_node_00004b34": "insert_node",
                "calculate_result_00006964": "calculate_result",
                "allocate_memory_00004bd0": "allocate_memory",
                "copy_string_000060b0": "copy_string"
            },
            "code": "uint allocate_and_insert_node_000060cc(uint address, uint start, uint length, uint data)\n{\n  uint result;\n  uint calculated_result;\n  if (start != 0) {\n    if (length == 0) {\n      insert_node();\n      result = length;\n    }\n    else {\n      calculated_result = calculate_result();\n      result = start;\n      if ((calculated_result < length) && (result = allocate_memory(address, length), result != 0)) {\n        copy_string(result, start, length);\n        insert_node(address, start);\n      }\n    }\n    return result;\n  }\n  result = allocate_memory(address, length, length, data);\n  return result;\n}",
            "called": [
                "FUN_000060b0",
                "FUN_00006964",
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060cc",
            "calling": [
                "FUN_000068f0"
            ],
            "imported": false,
            "current_name": "allocate_and_insert_node_000060cc"
        },
        "FUN_00003dc4": {
            "renaming": {
                "FUN_00003dc4": "count_digits_00003dc4",
                "param_1": "num",
                "param_2": "base",
                "local_20": "remainder",
                "local_14": "digit_ptr",
                "local_10": "base_remainder",
                "local_c": "digit_count"
            },
            "code": "int count_digits_00003dc4(int num, uint base) {\n  uint max_base = DAT_00003e50;\n  uint remainder;\n  char *digit_ptr;\n  int digit_count;\n\n  digit_count = 1;\n  if (max_base < base) {\n    digit_count = 10;\n  }\n  else {\n    for (remainder = 10; remainder <= base; remainder *= 10) {\n      digit_count++;\n    }\n  }\n  if (num != 0) {\n    digit_ptr = (char *)(digit_count + num);\n    remainder = base;\n    do {\n      digit_ptr = digit_ptr - 1;\n      *digit_ptr = (char)remainder + (char)(uint)((ulonglong)DAT_00003e54 * (ulonglong)remainder >> 0x23) * -10 + '0';\n      remainder = (uint)((ulonglong)DAT_00003e54 * (ulonglong)remainder >> 0x23);\n    } while (remainder != 0);\n  }\n  return digit_count;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003dc4",
            "calling": [
                "FUN_00003e58"
            ],
            "imported": false,
            "current_name": "count_digits_00003dc4"
        },
        "FUN_000022be": {
            "renaming": {
                "FUN_000022be": "increment_and_set_value_at_offset_000022be",
                "param_1": "array",
                "param_2": "value",
                "uVar1": "current_offset",
                "target_offset": "target_offset",
                "PTR_DAT_00000008": "array[1]",
                "PTR_DAT_0000000c": "array[3]"
            },
            "code": "void increment_and_set_value_at_offset_000022be(int *array, int offset, int value) {\n  int current_offset = PTR_DAT_0000000c;\n  PTR_DAT_0000000c = current_offset + 1;\n  int target_offset = (current_offset & (PTR_DAT_00000008 - 1U)) + *array;\n  *(int *)(target_offset + offset) = value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022be",
            "calling": [
                "FUN_00002364"
            ],
            "imported": false,
            "current_name": "increment_and_set_value_at_offset_000022be"
        },
        "FUN_00002108": {
            "renaming": {
                "FUN_00002108": "execute_check_00002108",
                "DAT_00002118": "data_pointer",
                "check_and_execute_00002028": "check_and_execute"
            },
            "code": "void execute_check_00002108(void)\n{\n  check_and_execute(DAT_00002118, 4);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002108",
            "calling": [],
            "imported": false,
            "current_name": "execute_check_00002108"
        },
        "FUN_00001d80": {
            "renaming": {
                "FUN_00001d80": "getMaskedValue_00001d80",
                "param_1": "value",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "uint16_t getMaskedValue_00001d80(uint16_t value) {\n    uint16_t maskedValue = value & 0x1c0;\n    uint16_t result = maskedValue | 0x400ff000;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d80",
            "calling": [
                "FUN_00001ff6",
                "FUN_00001eea"
            ],
            "imported": false,
            "current_name": "getMaskedValue_00001d80"
        },
        "FUN_000033c0": {
            "renaming": {
                "FUN_000033c0": "convertSecondsToDateTimeAndCheckAlarm_000033c0",
                "iVar1": "conversionResult",
                "auStack_2c": "alarmData",
                "PTR_s_rtc__error_getting_alarm_000033f0": "PTR_s_rtc_error_getting_alarm",
                "calculate_result_00003378": "calculateResult"
            },
            "code": "bool convertSecondsToDateTimeAndCheckAlarm_000033c0(void)\n{\n  int conversionResult;\n  undefined alarmData[36];\n  \n  conversionResult = convert_seconds_to_date_time_and_get_zero_00002690(alarmData);\n  if (conversionResult != 0) {\n    FUNC_00004db8(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else {\n    calculate_result_00003378(alarmData);\n  }\n  return conversionResult != 0;\n}",
            "called": [
                "FUN_00003378",
                "FUN_00004db8",
                "FUN_00002690"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "convertSecondsToDateTimeAndCheckAlarm_000033c0",
            "code_backup": "\nbool FUN_000033c0(void)\n\n{\n  int iVar1;\n  undefined auStack_2c [36];\n  \n  iVar1 = convert_seconds_to_date_time_and_get_zero_00002690(auStack_2c);\n  if (iVar1 != 0) {\n    FUNC_00004db8(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else {\n    calculate_result_00003378(auStack_2c);\n  }\n  return iVar1 != 0;\n}\n\n"
        },
        "FUN_00002b10": {
            "renaming": {
                "FUN_00002b10": "parse_commands_and_execute_00002b10",
                "param_1": "command_count",
                "param_2": "commands",
                "local_48": "command_ptrs",
                "local_3c": "command_function",
                "local_38": "valid_command_ptrs",
                "local_34": "i",
                "local_2d": "quote_type",
                "local_2c": "shift_char",
                "local_28": "escape_char",
                "local_24": "command_ptr",
                "local_20": "j",
                "local_1c": "escape_count",
                "local_18": "valid_commands",
                "local_14": "current_command"
            },
            "code": "void parse_commands_and_execute_00002b10(uint32_t command_count, char** commands) {\\n  int escape_count = 0;\\n  char* current_command = *commands;\\n  uint32_t valid_commands = 0;\\n  while (*current_command != 0) {\\n    if (*current_command > 0x20) {\\n      if ((*current_command == \"\\\"\") || (*current_command == \"\\\"\")) {\\n        char quote_type = *current_command;\\n        do {\\n          current_command++;\\n          if (*current_command == 0) {\\n            print_error_message(\\\"End of command reached before closing quote.\\\");\\n            return;\\n          }\\n          if (*current_command == \"\\\\\") {\\n            escape_count++;\\n            current_command++;\\n            if (*current_command == 0) {\\n              print_error_message(\\\"End of command reached before closing quote.\\\");\\n              return;\\n            }\\n          }\\n        } while (quote_type != *current_command);\\n        if (*++current_command > 0x20) {\\n          print_error_message(\\\"Invalid command format.\\\");\\n          return;\\n        }\\n      }\\n      else {\\n        do {\\n          if (*current_command == \"\\\\\") {\\n            escape_count++;\\n            current_command++;\\n            if (*current_command == 0) {\\n              print_error_message(\\\"End of command reached before closing quote.\\\");\\n              return;\\n            }\\n          }\\n          current_command++;\\n          if (*current_command == \"\\\"\") {\\n            print_error_message(\\\"Invalid command format.\\\");\\n            return;\\n          }\\n        } while (*current_command > 0x20);\\n      }\\n      valid_commands++;\\n    }\\n    *current_command = 0;\\n    current_command++;\\n  }\\n  if (valid_commands > 0) {\\n    char** valid_command_ptrs = (char**)malloc((valid_commands + 1) * sizeof(char*));\\n    char* current_valid_command = *commands;\\n    for (uint32_t i = 0; i < valid_commands; i++) {\\n      while (*current_valid_command == 0) {\\n        current_valid_command++;\\n      }\\n      if ((*current_valid_command == \"\\\"\") || (*current_valid_command == \"\\\"\")) {\\n        current_valid_command++;\\n      }\\n      valid_command_ptrs[i] = current_valid_command;\\n      while (*current_valid_command != 0) {\\n        current_valid_command++;\\n      }\\n    }\\n    for (char** command_ptr = valid_command_ptrs; (escape_count != 0 && (*command_ptr != NULL)); command_ptr++) {\\n      for (char* escape_char = *command_ptr; *escape_char != \"\\\\\"; escape_char++) {\\n        if (*escape_char == \"\\\\\") {\\n          for (char* shift_char = escape_char; *shift_char != 0; shift_char++) {\\n            *shift_char = *(shift_char + 1);\\n          }\\n          escape_count--;\\n          if (escape_count == 0) {\\n            break;\\n          }\\n        }\\n      }\\n    }\\n    code* command_function = find_command_function(*commands, valid_command_ptrs);\\n    if (command_function == NULL) {\\n      if (compare_strings(*commands, \\\"command_not_found\\\") == 0) {\\n        print_command_descriptions(command_count, commands);\\n      }\\n      else {\\n        initialize_error_message(\\\"Command not found.\\\", *commands);\\n      }\\n    }\\n    else {\\n      (*command_function)(valid_commands, valid_command_ptrs);\\n    }\\n    free(valid_command_ptrs);\\n  }\\n  return;\\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00002a88",
                "FUN_00004db8",
                "FUN_00004e52",
                "FUN_00002a18"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002b10",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "parse_commands_and_execute_00002b10"
        },
        "FUN_00001b10": {
            "renaming": {
                "FUN_00001b10": "execute_instructions_00001b10",
                "param_1": "instruction_count",
                "uVar1": "result",
                "set_default_parameters_000018bc": "set_default_parameters",
                "set_and_wait_until_bit_set_0000191c": "set_and_wait_until_bit_set",
                "initialize_system_00001960": "initialize_system",
                "initialize_and_set_flags_000019c0": "initialize_and_set_flags",
                "initialize_and_set_result_to_one_00001a18": "initialize_and_set_result_to_one",
                "initialize_result_and_set_value_to_five_00001a3c": "initialize_result_and_set_value_to_five",
                "verify_data_transfer_complete_00001a60": "verify_data_transfer_complete",
                "clear_bitmask_and_wait_until_condition_met_00001ad4": "clear_bitmask_and_wait_until_condition_met",
                "PTR_DAT_00001bb4": "instruction_array",
                "PTR_DAT_00001bb0": "instruction_count_ptr"
            },
            "code": "uint32_t execute_instructions_00001b10(uint8_t instruction_count) {\n  uint32_t result;\n  if (instruction_count >= 8) {\n    result = 0xffffffff;\n  }\n  else {\n    uint8_t current_instruction_index = 0;\n    do {\n      uint8_t current_instruction = PTR_DAT_00001bb4[(uint)current_instruction_index + (uint)(byte)*PTR_DAT_00001bb0 * 8];\n      switch(current_instruction) {\n        case 0:\n          set_default_parameters();\n          break;\n        case 1:\n          set_and_wait_until_bit_set();\n          break;\n        case 2:\n          initialize_system();\n          break;\n        case 3:\n          initialize_and_set_flags();\n          break;\n        case 4:\n          initialize_and_set_result_to_one();\n          break;\n        case 5:\n          initialize_result_and_set_value_to_five();\n          break;\n        case 6:\n          verify_data_transfer_complete();\n          break;\n        case 7:\n          clear_bitmask_and_wait_until_condition_met();\n          break;\n        default:\n          return 0xffffffff;\n      }\n      current_instruction_index++;\n    } while (current_instruction_index != *PTR_DAT_00001bb0);\n    result = 0;\n  }\n  return result;\n}",
            "called": [
                "FUN_00001a18",
                "FUN_000019c0",
                "FUN_00001960",
                "FUN_00001ad4",
                "FUN_00001a3c",
                "FUN_0000191c",
                "FUN_000018bc",
                "FUN_00001a60"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001b10",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "execute_instructions_00001b10"
        },
        "FUN_000047e4": {
            "renaming": {
                "FUN_000047e4": "FUNC_000047e4"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\nundefined8 FUNC_000047e4(int *param_1)\n\n{\n  longlong lVar1;\n  longlong lVar2;\n  int *piVar3;\n  uint uVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  int iVar11;\n  uint uVar12;\n  uint uVar13;\n  uint uVar14;\n  uint uVar15;\n  bool bVar16;\n  \n  piVar3 = (int *)get_data_000056b0();\n  FUNC_00004634(param_1);\n  uVar12 = param_1[5];\n  iVar11 = param_1[3] + -1 + *(int *)(PTR_DAT_00004adc + param_1[4] * 4);\n  if (((1 < param_1[4]) && ((uVar12 & 3) == 0)) &&\n     ((uVar12 != (uVar12 / 100) * 100 || (uVar12 + 0x76c == ((uVar12 + 0x76c) / 400) * 400)))) {\n    iVar11 = iVar11 + 1;\n  }\n  param_1[7] = iVar11;\n  if (20000 < (int)&PTR_DAT_00002710 + uVar12) {\n    iVar7 = -1;\n    iVar5 = -1;\n    goto LAB_00004aba;\n  }\n  if ((int)uVar12 < 0x47) {\n    if (uVar12 != 0x46) {\n      for (uVar9 = 0x45; (int)uVar12 < (int)uVar9; uVar9 = uVar9 - 1) {\n        if ((uVar9 & 3) == 0) {\n          if (uVar9 == (uVar9 / 100) * 100) {\n            if ((uVar9 + 0x76c) % 400 == 0) {\n              iVar7 = 0x16e;\n            }\n            else {\n              iVar7 = 0x16d;\n            }\n          }\n          else {\n            iVar7 = 0x16e;\n          }\n        }\n        else {\n          iVar7 = 0x16d;\n        }\n        iVar11 = iVar11 - iVar7;\n      }\n      if ((uVar9 & 3) == 0) {\n        if (uVar12 == (uVar12 / 100) * 100) {\n          iVar7 = 0x16d;\n          if ((uVar12 + 0x76c) % 400 == 0) {\n            iVar7 = 0x16e;\n          }\n        }\n        else {\n          iVar7 = 0x16e;\n        }\n      }\n      else {\n        iVar7 = 0x16d;\n      }\n      iVar11 = iVar11 - iVar7;\n    }\n  }\n  else {\n    uVar9 = 0x46;\n    do {\n      if ((uVar9 & 3) == 0) {\n        if (uVar9 % 100 == 0) {\n          if ((uVar9 + 0x76c) % 400 == 0) {\n            iVar7 = 0x16e;\n          }\n          else {\n            iVar7 = 0x16d;\n          }\n        }\n        else {\n          iVar7 = 0x16e;\n        }\n      }\n      else {\n        iVar7 = 0x16d;\n      }\n      uVar9 = uVar9 + 1;\n      iVar11 = iVar11 + iVar7;\n    } while (uVar12 != uVar9);\n  }\n  lVar1 = (longlong)DAT_00004ae0 * (longlong)iVar11 +\n          (longlong)(param_1[2] * 0xe10 + param_1[1] * 0x3c + *param_1);\n  uVar15 = (uint)lVar1;\n  iVar7 = (int)((ulonglong)lVar1 >> 0x20);\n  get_pointer_data_000050e8();\n  FUNC_00005100();\n  uVar9 = *(uint *)PTR_DAT_00004ae4;\n  if (*(uint *)PTR_DAT_00004ae4 == 0) {\nLAB_00004934:\n    uVar12 = piVar3[10];\n    iVar7 = (uint)lVar1 + uVar12;\n    iVar5 = (int)((ulonglong)lVar1 >> 0x20) +\n            ((int)uVar12 >> 0x1f) + (uint)CARRY4((uint)lVar1,uVar12);\n  }\n  else {\n    uVar14 = param_1[8];\n    uVar13 = uVar14;\n    if (0 < (int)uVar14) {\n      uVar13 = 1;\n    }\n    if ((piVar3[1] == param_1[5] + 0x76c) || (iVar5 = calculate_week_number_for_year_00004f98(), iVar5 != 0)) {\n      uVar10 = piVar3[0x14];\n      uVar4 = piVar3[0x12];\n      uVar8 = piVar3[10];\n      uVar9 = uVar4 - uVar8;\n      iVar5 = (piVar3[0x13] - ((int)uVar8 >> 0x1f)) - (uint)(uVar4 < uVar8);\n      if (((int)((iVar7 - iVar5) - (uint)(uVar15 < uVar9)) < 0 ==\n           (SBORROW4(iVar7,iVar5) != SBORROW4(iVar7 - iVar5,(uint)(uVar15 < uVar9)))) &&\n         (iVar6 = (piVar3[0x13] - ((int)uVar10 >> 0x1f)) - (uint)(uVar4 < uVar10),\n         bVar16 = uVar15 < uVar4 - uVar10,\n         (int)((iVar7 - iVar6) - (uint)bVar16) < 0 !=\n         (SBORROW4(iVar7,iVar6) != SBORROW4(iVar7 - iVar6,(uint)bVar16)))) goto LAB_00004a88;\n      uVar4 = piVar3[8] - uVar10;\n      iVar6 = (piVar3[9] - ((int)uVar10 >> 0x1f)) - (uint)((uint)piVar3[8] < uVar10);\n      if (*piVar3 != 0) {\n        if ((int)((iVar7 - iVar6) - (uint)(uVar15 < uVar4)) < 0 ==\n            (SBORROW4(iVar7,iVar6) != SBORROW4(iVar7 - iVar6,(uint)(uVar15 < uVar4))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        uVar9 = 0;\n        if ((int)uVar14 < 0) goto LAB_00004934;\nLAB_00004a14:\n        uVar15 = uVar13 ^ uVar9;\n        uVar13 = uVar9;\n        if (uVar15 == 1) {\n          if (uVar9 == 0) {\n            iVar7 = uVar10 - uVar8;\n          }\n          else {\n            iVar7 = uVar8 - uVar10;\n          }\n          iVar5 = param_1[3];\n          *param_1 = *param_1 + iVar7;\n          lVar2 = lVar1 + iVar7;\n          FUNC_00004634(param_1);\n          iVar5 = param_1[3] - iVar5;\n          lVar1 = lVar1 + iVar7;\n          if (iVar5 != 0) {\n            if (iVar5 < 2) {\n              if (iVar5 == -2 || iVar5 + 2 < 0 != SCARRY4(iVar5,2)) {\n                iVar5 = 1;\n              }\n            }\n            else {\n              iVar5 = -1;\n            }\n            iVar7 = iVar5 + param_1[7];\n            iVar11 = iVar11 + iVar5;\n            if (iVar7 < 0) {\n              uVar9 = uVar12 - 1;\n              if ((uVar9 & 3) == 0) {\n                if (uVar9 == (uVar9 / 100) * 100) {\n                  iVar7 = 0x16d;\n                  if ((uVar12 + 0x76b) % 400 != 0) {\n                    iVar7 = 0x16c;\n                  }\n                }\n                else {\n                  iVar7 = 0x16d;\n                }\n              }\n              else {\n                iVar7 = 0x16c;\n              }\n            }\n            else {\n              if ((uVar12 & 3) == 0) {\n                if (uVar12 == (uVar12 / 100) * 100) {\n                  iVar5 = 0x16d;\n                  if ((uVar12 + 0x76c) % 400 == 0) {\n                    iVar5 = 0x16e;\n                  }\n                }\n                else {\n                  iVar5 = 0x16e;\n                }\n              }\n              else {\n                iVar5 = 0x16d;\n              }\n              if (iVar5 <= iVar7) {\n                iVar7 = iVar7 - iVar5;\n              }\n            }\n            param_1[7] = iVar7;\n            lVar1 = lVar2;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((iVar7 - iVar6) - (uint)(uVar15 < uVar4)) < 0 !=\n          (SBORROW4(iVar7,iVar6) != SBORROW4(iVar7 - iVar6,(uint)(uVar15 < uVar4)))) {\nLAB_0000491e:\n        if ((int)((iVar7 - iVar5) - (uint)(uVar15 < uVar9)) < 0 ==\n            (SBORROW4(iVar7,iVar5) != SBORROW4(iVar7 - iVar5,(uint)(uVar15 < uVar9))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)uVar14) {\n        uVar9 = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      uVar9 = uVar13;\n      if (uVar13 != 1) goto LAB_00004934;\n    }\n    uVar12 = piVar3[0x14];\n    iVar7 = (uint)lVar1 + uVar12;\n    iVar5 = (int)((ulonglong)lVar1 >> 0x20) +\n            ((int)uVar12 >> 0x1f) + (uint)CARRY4((uint)lVar1,uVar12);\n    uVar9 = 1;\n  }\n  get_data_pointer_000050f4();\n  param_1[8] = uVar9;\n  param_1[6] = (iVar11 + 4U) % 7;\nLAB_00004aba:\n  return CONCAT44(iVar5,iVar7);\n}\n\n",
            "called": [
                "FUN_00004634",
                "FUN_000050e8",
                "FUN_00005100",
                "FUN_00004f98",
                "FUN_000056b0",
                "FUN_000050f4"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000047e4",
            "calling": [
                "FUN_00002600",
                "FUN_00002654"
            ],
            "imported": false,
            "current_name": "FUNC_000047e4"
        },
        "FUN_000023c8": {
            "renaming": {
                "FUN_000023c8": "trigger_software_interrupt_000023c8",
                "0x3f": "SYSTEM_RESET"
            },
            "code": "void trigger_software_interrupt_000023c8(void)\n{\n  software_interrupt(SYSTEM_RESET);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023c8",
            "calling": [
                "FUN_000023d0"
            ],
            "imported": false,
            "current_name": "trigger_software_interrupt_000023c8"
        },
        "FUN_00002e48": {
            "renaming": {
                "FUN_00002e48": "process_input_and_data_00002e48",
                "*(undefined4 *)(*DAT_00002e68 + 8)": "data",
                "0x3e": "input1",
                "0x20": "input2"
            },
            "code": "process_input_and_data_00002e48vprocess_input_and_data_00002e48oprocess_input_and_data_00002e48iprocess_input_and_data_00002e48dprocess_input_and_data_00002e48 process_input_and_data_00002e48pprocess_input_and_data_00002e48rprocess_input_and_data_00002e48oprocess_input_and_data_00002e48cprocess_input_and_data_00002e48eprocess_input_and_data_00002e48sprocess_input_and_data_00002e48sprocess_input_and_data_00002e48_process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48pprocess_input_and_data_00002e48uprocess_input_and_data_00002e48tprocess_input_and_data_00002e48_process_input_and_data_00002e48aprocess_input_and_data_00002e48nprocess_input_and_data_00002e48dprocess_input_and_data_00002e48_process_input_and_data_00002e48*process_input_and_data_00002e48(process_input_and_data_00002e48uprocess_input_and_data_00002e48nprocess_input_and_data_00002e48dprocess_input_and_data_00002e48eprocess_input_and_data_00002e48fprocess_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48eprocess_input_and_data_00002e48dprocess_input_and_data_00002e484process_input_and_data_00002e48 process_input_and_data_00002e48*process_input_and_data_00002e48)process_input_and_data_00002e48(process_input_and_data_00002e48*process_input_and_data_00002e48Dprocess_input_and_data_00002e48Aprocess_input_and_data_00002e48Tprocess_input_and_data_00002e48_process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e482process_input_and_data_00002e48eprocess_input_and_data_00002e486process_input_and_data_00002e488process_input_and_data_00002e48 process_input_and_data_00002e48+process_input_and_data_00002e48 process_input_and_data_00002e488process_input_and_data_00002e48)process_input_and_data_00002e48(process_input_and_data_00002e48vprocess_input_and_data_00002e48oprocess_input_and_data_00002e48iprocess_input_and_data_00002e48dprocess_input_and_data_00002e48)process_input_and_data_00002e48\nprocess_input_and_data_00002e48{process_input_and_data_00002e48\nprocess_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48tprocess_input_and_data_00002e48 process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48pprocess_input_and_data_00002e48uprocess_input_and_data_00002e48tprocess_input_and_data_00002e481process_input_and_data_00002e48 process_input_and_data_00002e48=process_input_and_data_00002e48 process_input_and_data_00002e480process_input_and_data_00002e48xprocess_input_and_data_00002e483process_input_and_data_00002e48eprocess_input_and_data_00002e48;process_input_and_data_00002e48\nprocess_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48tprocess_input_and_data_00002e48 process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48pprocess_input_and_data_00002e48uprocess_input_and_data_00002e48tprocess_input_and_data_00002e482process_input_and_data_00002e48 process_input_and_data_00002e48=process_input_and_data_00002e48 process_input_and_data_00002e480process_input_and_data_00002e48xprocess_input_and_data_00002e482process_input_and_data_00002e480process_input_and_data_00002e48;process_input_and_data_00002e48\nprocess_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48tprocess_input_and_data_00002e48 process_input_and_data_00002e48*process_input_and_data_00002e48(process_input_and_data_00002e48uprocess_input_and_data_00002e48nprocess_input_and_data_00002e48dprocess_input_and_data_00002e48eprocess_input_and_data_00002e48fprocess_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48eprocess_input_and_data_00002e48dprocess_input_and_data_00002e484process_input_and_data_00002e48 process_input_and_data_00002e48*process_input_and_data_00002e48)process_input_and_data_00002e48(process_input_and_data_00002e48*process_input_and_data_00002e48Dprocess_input_and_data_00002e48Aprocess_input_and_data_00002e48Tprocess_input_and_data_00002e48_process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e482process_input_and_data_00002e48eprocess_input_and_data_00002e486process_input_and_data_00002e488process_input_and_data_00002e48 process_input_and_data_00002e48+process_input_and_data_00002e48 process_input_and_data_00002e488process_input_and_data_00002e48)process_input_and_data_00002e48 process_input_and_data_00002e48=process_input_and_data_00002e48 process_input_and_data_00002e48*process_input_and_data_00002e48(process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48tprocess_input_and_data_00002e48 process_input_and_data_00002e48*process_input_and_data_00002e48)process_input_and_data_00002e48(process_input_and_data_00002e48*process_input_and_data_00002e48Dprocess_input_and_data_00002e48Aprocess_input_and_data_00002e48Tprocess_input_and_data_00002e48_process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e482process_input_and_data_00002e48eprocess_input_and_data_00002e486process_input_and_data_00002e488process_input_and_data_00002e48 process_input_and_data_00002e48+process_input_and_data_00002e48 process_input_and_data_00002e488process_input_and_data_00002e48)process_input_and_data_00002e48;process_input_and_data_00002e48\nprocess_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48pprocess_input_and_data_00002e48rprocess_input_and_data_00002e48oprocess_input_and_data_00002e48cprocess_input_and_data_00002e48eprocess_input_and_data_00002e48sprocess_input_and_data_00002e48sprocess_input_and_data_00002e48_process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48pprocess_input_and_data_00002e48uprocess_input_and_data_00002e48tprocess_input_and_data_00002e48_process_input_and_data_00002e48aprocess_input_and_data_00002e48nprocess_input_and_data_00002e48dprocess_input_and_data_00002e48_process_input_and_data_00002e48rprocess_input_and_data_00002e48eprocess_input_and_data_00002e48tprocess_input_and_data_00002e48uprocess_input_and_data_00002e48rprocess_input_and_data_00002e48nprocess_input_and_data_00002e48_process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e482process_input_and_data_00002e48aprocess_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e48(process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48pprocess_input_and_data_00002e48uprocess_input_and_data_00002e48tprocess_input_and_data_00002e481process_input_and_data_00002e48)process_input_and_data_00002e48;process_input_and_data_00002e48\nprocess_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48pprocess_input_and_data_00002e48rprocess_input_and_data_00002e48oprocess_input_and_data_00002e48cprocess_input_and_data_00002e48eprocess_input_and_data_00002e48sprocess_input_and_data_00002e48sprocess_input_and_data_00002e48_process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48pprocess_input_and_data_00002e48uprocess_input_and_data_00002e48tprocess_input_and_data_00002e48_process_input_and_data_00002e48aprocess_input_and_data_00002e48nprocess_input_and_data_00002e48dprocess_input_and_data_00002e48_process_input_and_data_00002e48rprocess_input_and_data_00002e48eprocess_input_and_data_00002e48tprocess_input_and_data_00002e48uprocess_input_and_data_00002e48rprocess_input_and_data_00002e48nprocess_input_and_data_00002e48_process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e482process_input_and_data_00002e48aprocess_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e48(process_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48pprocess_input_and_data_00002e48uprocess_input_and_data_00002e48tprocess_input_and_data_00002e482process_input_and_data_00002e48)process_input_and_data_00002e48;process_input_and_data_00002e48\nprocess_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48pprocess_input_and_data_00002e48rprocess_input_and_data_00002e48oprocess_input_and_data_00002e48cprocess_input_and_data_00002e48eprocess_input_and_data_00002e48sprocess_input_and_data_00002e48sprocess_input_and_data_00002e48_process_input_and_data_00002e48*process_input_and_data_00002e48(process_input_and_data_00002e48uprocess_input_and_data_00002e48nprocess_input_and_data_00002e48dprocess_input_and_data_00002e48eprocess_input_and_data_00002e48fprocess_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48eprocess_input_and_data_00002e48dprocess_input_and_data_00002e484process_input_and_data_00002e48 process_input_and_data_00002e48*process_input_and_data_00002e48)process_input_and_data_00002e48(process_input_and_data_00002e48*process_input_and_data_00002e48Dprocess_input_and_data_00002e48Aprocess_input_and_data_00002e48Tprocess_input_and_data_00002e48_process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e482process_input_and_data_00002e48eprocess_input_and_data_00002e486process_input_and_data_00002e488process_input_and_data_00002e48 process_input_and_data_00002e48+process_input_and_data_00002e48 process_input_and_data_00002e488process_input_and_data_00002e48)process_input_and_data_00002e48_process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e484process_input_and_data_00002e481process_input_and_data_00002e48dprocess_input_and_data_00002e480process_input_and_data_00002e48(process_input_and_data_00002e48*process_input_and_data_00002e48(process_input_and_data_00002e48uprocess_input_and_data_00002e48nprocess_input_and_data_00002e48dprocess_input_and_data_00002e48eprocess_input_and_data_00002e48fprocess_input_and_data_00002e48iprocess_input_and_data_00002e48nprocess_input_and_data_00002e48eprocess_input_and_data_00002e48dprocess_input_and_data_00002e484process_input_and_data_00002e48 process_input_and_data_00002e48*process_input_and_data_00002e48)process_input_and_data_00002e48(process_input_and_data_00002e48*process_input_and_data_00002e48Dprocess_input_and_data_00002e48Aprocess_input_and_data_00002e48Tprocess_input_and_data_00002e48_process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e480process_input_and_data_00002e482process_input_and_data_00002e48eprocess_input_and_data_00002e486process_input_and_data_00002e488process_input_and_data_00002e48 process_input_and_data_00002e48+process_input_and_data_00002e48 process_input_and_data_00002e488process_input_and_data_00002e48)process_input_and_data_00002e48)process_input_and_data_00002e48;process_input_and_data_00002e48\nprocess_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48 process_input_and_data_00002e48rprocess_input_and_data_00002e48eprocess_input_and_data_00002e48tprocess_input_and_data_00002e48uprocess_input_and_data_00002e48rprocess_input_and_data_00002e48nprocess_input_and_data_00002e48;process_input_and_data_00002e48\nprocess_input_and_data_00002e48}process_input_and_data_00002e48",
            "called": [
                "FUN_00002a00",
                "FUN_000041d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e48",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "process_input_and_data_00002e48"
        },
        "FUN_00000930": {
            "renaming": {
                "FUN_00000930": "run_interrupt_handler_00000930",
                "is_interrupt_enabled_00000cf0": "check_interrupt_status",
                "software_interrupt": "trigger_interrupt"
            },
            "code": "void run_interrupt_handler_00000930(void)\n{\n  bool is_interrupt_enabled = check_interrupt_status();\n  trigger_interrupt(1);\n  while(true) {\n    // Do nothing block with infinite loop\n  }\n}",
            "called": [
                "FUN_00000cf0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000930",
            "calling": [
                "FUN_00000f8c",
                "FUN_00000794"
            ],
            "imported": false,
            "current_name": "run_interrupt_handler_00000930"
        },
        "FUN_00001348": {
            "renaming": {
                "FUN_00001348": "check_flag_and_set_00001348",
                "PTR_DAT_0000135c": "flag_ptr",
                "set_flag_on_0000093c": "set_flag"
            },
            "code": "void check_flag_and_set_00001348(void)\n{\n  int* PTR_DAT_0000135c = (int*)PTR_DAT_0000135c;\n  if (*PTR_DAT_0000135c != 0)\n  {\n    set_flag_on_0000093c();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001348",
            "calling": [
                "FUN_00001628"
            ],
            "imported": false,
            "current_name": "check_flag_and_set_00001348"
        },
        "FUN_00001d3a": {
            "renaming": {
                "FUN_00001d3a": "set_value_at_calculated_offset_00001d3a",
                "param_1": "base_address",
                "param_2": "offset",
                "puVar1": "value_pointer"
            },
            "code": "void set_value_at_calculated_offset_00001d3a(int base_address, int offset) {\n  int* value_pointer;\n  value_pointer = (int*)calculate_offset(base_address, offset);\n  *value_pointer = 1;\n  return;\n}",
            "called": [
                "FUN_00001d08"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d3a",
            "calling": [
                "FUN_00001ddc"
            ],
            "imported": false,
            "current_name": "set_value_at_calculated_offset_00001d3a"
        },
        "FUN_00002434": {
            "renaming": {
                "FUN_00002434": "handle_interrupt_00002434",
                "param_1": "interrupt_flag",
                "param_2": "interrupt_type",
                "uVar1": "interrupts_enabled",
                "iVar2": "irq_list_head"
            },
            "code": "int handle_interrupt_00002434(int *interrupt_flag, int interrupt_type) {\n    int irq_list_head;\n    int interrupt_handled = 0;\n    int interrupts_enabled = check_interrupts_enabled_00000cd0();\n\n    if (*interrupt_flag == 0) {\n        *interrupt_flag = -1;\n        enable_irq_interrupts_if_privileged_00000d0c(interrupts_enabled);\n        interrupt_handled = 1;\n    }\n    else if (interrupt_type == 0) {\n        enable_irq_interrupts_if_privileged_00000d0c(interrupts_enabled);\n        interrupt_handled = 0;\n    }\n    else {\n        irq_list_head = *(int *)PTR_DAT_000024b8;\n        update_or_remove_element_00000698(irq_list_head, 2);\n        if (*interrupt_flag == -1) {\n            *interrupt_flag = irq_list_head + 8;\n            *(int *)*interrupt_flag = 0;\n        }\n        else {\n            find_and_insert_00001034(interrupt_flag, irq_list_head);\n        }\n        enable_irq_interrupts_if_privileged_00000d0c(interrupts_enabled);\n        set_flag_on_0000093c();\n        interrupt_handled = 1;\n    }\n    return interrupt_handled;\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000d0c",
                "FUN_0000093c",
                "FUN_00001034",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002434",
            "calling": [
                "FUN_0000129c"
            ],
            "imported": false,
            "current_name": "handle_interrupt_00002434"
        },
        "FUN_00005700": {
            "renaming": {
                "FUN_00005700": "allocate_memory_and_set_flag_00005700",
                "param_1": "memory_address",
                "param_2": "memory_block",
                "uVar1": "flag_value",
                "iVar2": "allocated_memory_size",
                "local_18": "allocated_memory_size",
                "local_14": "local_memory_block"
            },
            "code": "void allocate_memory_and_set_flag_00005700(int memory_address, int *memory_block) {\n    ushort flag_value;\n    int allocated_memory_size;\n    int new_memory_address;\n    int *local_memory_block;\n\n    if (-1 < (int)((uint)*(ushort *)(memory_block + 3) << 0x1e)) {\n        local_memory_block = memory_block;\n        flag_value = check_value_and_set_flag(memory_address, memory_block, &allocated_memory_size, &local_memory_block);\n        new_memory_address = allocate_memory(memory_address, allocated_memory_size);\n        if (new_memory_address != 0) {\n            *(undefined **)(memory_address + 0x28) = PTR_DAT_0000577c;\n            *memory_block = new_memory_address;\n            *(ushort *)(memory_block + 3) = *(ushort *)(memory_block + 3) | 0x80;\n            memory_block[5] = allocated_memory_size;\n            memory_block[4] = new_memory_address;\n            if ((local_memory_block != (int *)0x0) && is_parameter_valid(memory_address, (int)*(short *)((int)memory_block + 0xe))) {\n                *(ushort *)(memory_block + 3) = *(ushort *)(memory_block + 3) & 0xfffc | 1;\n            }\n            *(ushort *)(memory_block + 3) = flag_value | *(ushort *)(memory_block + 3);\n            return;\n        }\n        if ((int)(short)*(ushort *)(memory_block + 3) << 0x16 < 0) {\n            return;\n        }\n        *(ushort *)(memory_block + 3) = *(ushort *)(memory_block + 3) & 0xfffc | 2;\n    }\n    *memory_block = (int)memory_block + 0x47;\n    memory_block[4] = (int)memory_block + 0x47;\n    memory_block[5] = 1;\n    return;\n}",
            "called": [
                "FUN_00000534",
                "FUN_00004bd0",
                "FUN_000056b8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005700",
            "calling": [
                "FUN_000054a8",
                "FUN_00006768"
            ],
            "imported": false,
            "current_name": "allocate_memory_and_set_flag_00005700"
        },
        "FUN_00002798": {
            "renaming": {
                "FUN_00002798": "check_flag_and_set_00002798",
                "PTR_DAT_000027ac": "flag_ptr",
                "set_flag_on_0000093c": "set_flag",
                "*PTR_DAT_000027ac": "*flag_ptr"
            },
            "code": "void check_flag_and_set_00002798() {\n  int* PTR_DAT_000027ac = (int*)PTR_DAT_000027ac;\n  if (*PTR_DAT_000027ac != 0) {\n    set_flag_on_0000093c();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002798",
            "calling": [
                "FUN_00002994"
            ],
            "imported": false,
            "current_name": "check_flag_and_set_00002798"
        },
        "FUN_00003524": {
            "renaming": {
                "FUN_00003524": "process_rtc_command_00003524",
                "param_1": "num_params",
                "param_2": "command",
                "iVar1": "comparison_result",
                "uVar2": "return_value",
                "initialize_rtc_commands_000034c0": "initialize_rtc_commands",
                "compare_strings_00004e66": "compare_strings",
                "PTR_s_poweron_00003638": "PTR_s_poweron",
                "set_flag_and_return_000026d8": "set_interrupt_flag_and_return",
                "PTR_s_poweroff_0000363c": "PTR_s_poweroff",
                "clearInterruptFlag_000026e4": "clear_interrupt_flag",
                "PTR_s_clearalarm_00003640": "PTR_s_clearalarm",
                "clearFlagsAndSetToZero_000026c0": "clear_flags_and_set_to_zero",
                "PTR_s_getalarm_00003644": "PTR_s_getalarm",
                "convertSecondsToDateTimeAndCheckAlarm_000033c0": "convert_seconds_to_date_time_and_check_alarm",
                "PTR_s_setalarm_00003648": "PTR_s_setalarm",
                "parse_input_and_calculate_results_and_execute_000033f4": "parse_input_and_calculate_results_and_execute",
                "PTR_s_gettime_0000364c": "PTR_s_gettime",
                "is_time_conversion_successful_00003444": "is_time_conversion_successful",
                "PTR_s_settime_00003650": "PTR_s_settime",
                "FUNC_00004c84": "print_unknown_command_or_missing_param_error",
                "PTR_s_unknown_command_or_missing_param_00003654": "PTR_s_unknown_command_or_missing_param",
                "calculate_and_process_input_results_00003478": "calculate_and_process_input_results"
            },
            "code": "int process_rtc_command_00003524(int num_params, int command)\n{\n  int comparison_result;\n  int return_value;\n\n  if (num_params < 2) {\n    initialize_rtc_commands_000034c0();\n    return_value = 1;\n  }\n  else {\n    comparison_result = compare_strings_00004e66(command + 4, PTR_s_poweron_00003638_00003638, 7);\n    if (comparison_result == 0) {\n      set_flag_and_return_000026d8();\n    }\n    else {\n      comparison_result = compare_strings_00004e66(command + 4, PTR_s_poweroff_0000363c_0000363c, 8);\n      if (comparison_result == 0) {\n        clearInterruptFlag_000026e4();\n      }\n      else {\n        comparison_result = compare_strings_00004e66(command + 4, PTR_s_clearalarm_00003640_00003640, 8);\n        if (comparison_result == 0) {\n          clearFlagsAndSetToZero_000026c0();\n        }\n        else {\n          comparison_result = compare_strings_00004e66(command + 4, PTR_s_getalarm_00003644_00003644, 8);\n          if (comparison_result == 0) {\n            convertSecondsToDateTimeAndCheckAlarm_000033c0();\n          }\n          else {\n            comparison_result = compare_strings_00004e66(command + 4, PTR_s_setalarm_00003648_00003648, 8);\n            if ((comparison_result == 0) && (num_params == 4)) {\n              parse_input_and_calculate_results_and_execute_000033f4(command + 8);\n            }\n            else {\n              comparison_result = compare_strings_00004e66(command + 4, PTR_s_gettime_0000364c_0000364c, 7);\n              if (comparison_result == 0) {\n                is_time_conversion_successful_00003444();\n              }\n              else {\n                comparison_result = compare_strings_00004e66(command + 4, PTR_s_settime_00003650_00003650, 7);\n                if ((comparison_result != 0) || (num_params != 4)) {\n                  initialize_data_00004c84(PTR_s_unknown_command_or_missing_param_00003654_00003654, command + 4);\n                  initialize_rtc_commands_000034c0();\n                  return 1;\n                }\n                calculate_and_process_input_results_00003478(command + 8);\n              }\n            }\n          }\n        }\n      }\n    }\n    return_value = 0;\n  }\n  return return_value;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_000026c0",
                "FUN_00003478",
                "FUN_000033f4",
                "FUN_000026d8",
                "FUN_00003444",
                "FUN_00004e66",
                "FUN_000034c0",
                "FUN_000033c0",
                "FUN_000026e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003524",
            "calling": [],
            "imported": false,
            "current_name": "process_rtc_command_00003524",
            "code_backup": "\nundefined4 FUN_00003524(int param_1,int param_2)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  \n  if (param_1 < 2) {\n    initialize_rtc_commands_000034c0();\n    uVar2 = 1;\n  }\n  else {\n    iVar1 = compare_strings_00004e66(*(undefined4 *)(param_2 + 4),PTR_s_poweron_00003638,7);\n    if (iVar1 == 0) {\n      set_flag_and_return_000026d8();\n    }\n    else {\n      iVar1 = compare_strings_00004e66(*(undefined4 *)(param_2 + 4),PTR_s_poweroff_0000363c,8);\n      if (iVar1 == 0) {\n        clearInterruptFlag_000026e4();\n      }\n      else {\n        iVar1 = compare_strings_00004e66(*(undefined4 *)(param_2 + 4),PTR_s_clearalarm_00003640,8);\n        if (iVar1 == 0) {\n          clearFlagsAndSetToZero_000026c0();\n        }\n        else {\n          iVar1 = compare_strings_00004e66(*(undefined4 *)(param_2 + 4),PTR_s_getalarm_00003644,8);\n          if (iVar1 == 0) {\n            convertSecondsToDateTimeAndCheckAlarm_000033c0();\n          }\n          else {\n            iVar1 = compare_strings_00004e66(*(undefined4 *)(param_2 + 4),PTR_s_setalarm_00003648,8);\n            if ((iVar1 == 0) && (param_1 == 4)) {\n              parse_input_and_calculate_results_and_execute_000033f4(param_2 + 8);\n            }\n            else {\n              iVar1 = compare_strings_00004e66(*(undefined4 *)(param_2 + 4),PTR_s_gettime_0000364c,7);\n              if (iVar1 == 0) {\n                is_time_conversion_successful_00003444();\n              }\n              else {\n                iVar1 = compare_strings_00004e66(*(undefined4 *)(param_2 + 4),PTR_s_settime_00003650,7);\n                if ((iVar1 != 0) || (param_1 != 4)) {\n                  FUNC_00004c84(PTR_s_unknown_command_or_missing_param_00003654,\n                               *(undefined4 *)(param_2 + 4));\n                  initialize_rtc_commands_000034c0();\n                  return 1;\n                }\n                calculate_and_process_input_results_00003478(param_2 + 8);\n              }\n            }\n          }\n        }\n      }\n    }\n    uVar2 = 0;\n  }\n  return uVar2;\n}\n\n"
        },
        "FUN_00001bb8": {
            "renaming": {
                "FUN_00001bb8": "check_and_set_values_00001bb8",
                "DAT_00001c74": "status",
                "DAT_00001c78": "output_array_1",
                "DAT_00001c7c": "output_array_2",
                "PTR_DAT_00001c80": "output_array_3",
                "set_result_to_zero_00001710": "set_result_to_zero",
                "set_param_1_00001748": "set_parameter_1"
            },
            "code": "void check_and_set_values_00001bb8(void)\n{\n    if ((DAT_00001c74[1] & 2) != 0) {\n        set_result_to_zero(DAT_00001c78, 1);\n    }\n    if ((DAT_00001c74[5] & 0x40) != 0) {\n        if ((*DAT_00001c74 & 0xc0) == 0) {\n            *DAT_00001c74 = *DAT_00001c74 & 0x3f | 0x80;\n            while ((DAT_00001c74[6] & 0xc) != 8);\n        }\n        set_result_to_zero(DAT_00001c7c, 6);\n        while ((DAT_00001c74[6] & 0x20) != 0);\n    }\n    set_parameter_1(0);\n    *DAT_00001c74 = *DAT_00001c74 & 0x3b | 4;\n    while ((DAT_00001c74[6] & 0x10) == 0);\n    while ((DAT_00001c74[6] & 0xc) != 0);\n    *PTR_DAT_00001c80 = 0;\n    return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001bb8",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "check_and_set_values_00001bb8"
        },
        "FUN_0000428c": {
            "renaming": {
                "FUN_0000428c": "do_nothing_with_data_0000428c",
                "DAT_00004294": "DAT_data"
            },
            "code": "void do_nothing_with_data_0000428c(void)\n{\n  do_nothing_with_data_0000428c(DAT_00004294);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000428c",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "do_nothing_with_data_0000428c"
        },
        "FUN_0000404c": {
            "renaming": {
                "FUN_0000404c": "decode_0000404c",
                "param_1": "input_buffer",
                "param_2": "decode_params",
                "iVar1": "decode_result",
                "piVar2": "decode_node_pointer",
                "uVar3": "decode_block_size_bits",
                "uVar4": "decode_block_type",
                "iVar5": "decode_block_size_diff",
                "pcVar6": "decode_function_pointer",
                "iVar7": "decode_current_offset",
                "uVar8": "decode_original_input_buffer",
                "bVar9": "decode_use_second_block_size",
                "decode_loop_counter": "decode_loop_counter",
                "decode_block_size": "decode_block_size_to_use",
                "decode_second_block": "decode_second_block",
                "decode_error": "decode_error"
            },
            "code": "int decode_0000404c(uint *input_buffer, int *decode_0000404c_params) {\n  int decode_0000404c_result = 0;\n  int decode_0000404c_loop_counter = 0;\n  int decode_0000404c_block_size = 0;\n  bool decode_0000404c_second_block = false;\n  bool decode_0000404c_error = false;\n  uint decode_0000404c_block_type = *(ushort *)(decode_0000404c_params + 3);\n  uint decode_0000404c_block_size_bits = (uint)decode_0000404c_block_type;\n  if ((int)(decode_0000404c_block_size_bits << 0x1c) < 0) {\n    int decode_0000404c_block_size_diff = decode_0000404c_params[4];\n    if (decode_0000404c_block_size_diff != 0) {\n      int decode_0000404c_block_size_bits_shifted = decode_0000404c_block_size_bits << 0x1e;\n      bool decode_0000404c_use_second_block_size = decode_0000404c_block_size_bits_shifted == 0;\n      int decode_0000404c_current_offset = *decode_0000404c_params;\n      int decode_0000404c_block_size_to_use = decode_0000404c_use_second_block_size ? decode_0000404c_params[5] : decode_0000404c_block_size_diff;\n      *decode_0000404c_params = decode_0000404c_block_size_diff;\n      if (!decode_0000404c_use_second_block_size) {\n        decode_0000404c_block_size_to_use = 0;\n      }\n      decode_0000404c_params[2] = decode_0000404c_block_size_to_use;\n      for (decode_0000404c_loop_counter = decode_0000404c_current_offset - decode_0000404c_block_size_diff; decode_0000404c_loop_counter > 0; decode_0000404c_loop_counter = decode_0000404c_loop_counter - decode_0000404c_block_size_to_use) {\n        decode_0000404c_block_size_to_use = (*(code *)decode_0000404c_params[10])(input_buffer, decode_0000404c_params[8], decode_0000404c_block_size_diff, decode_0000404c_loop_counter);\n        if (decode_0000404c_block_size_to_use < 1) {\n          *(ushort *)(decode_0000404c_params + 3) = decode_0000404c_block_type | 0x40;\n          return -1;\n        }\n        decode_0000404c_block_size_diff = decode_0000404c_block_size_diff + decode_0000404c_block_size_to_use;\n      }\n    }\n  }\n  else {\n    if ((decode_0000404c_params[1] < 1) && (decode_0000404c_params[16] < 1)) {\n      return 0;\n    }\n    code *decode_0000404c_function_pointer = (code *)decode_0000404c_params[11];\n    if (decode_0000404c_function_pointer == (code *)0x0) {\n      return 0;\n    }\n    uint decode_0000404c_original_input_buffer = *input_buffer;\n    *input_buffer = 0;\n    if ((decode_0000404c_block_type & 0x1000) == 0) {\n      decode_0000404c_block_size = (*decode_0000404c_function_pointer)(input_buffer, decode_0000404c_params[8], decode_0000404c_block_size_bits & 0x1000, 1);\n      if ((decode_0000404c_block_size == -1) && (*input_buffer != 0)) {\n        if ((*input_buffer == 0x1d) || (*input_buffer == 0x16)) {\n          *input_buffer = decode_0000404c_original_input_buffer;\n          return 0;\n        }\n        decode_0000404c_block_type = *(ushort *)(decode_0000404c_params + 3);\n        decode_0000404c_error = true;\n        goto DECODE_ERROR;\n      }\n    }\n    else {\n      decode_0000404c_block_size = decode_0000404c_params[21];\n    }\n    if (((int)((uint)*(ushort *)(decode_0000404c_params + 3) << 0x1d) < 0) && (decode_0000404c_params[13] != 0)) {\n      int decode_0000404c_block_size_diff = decode_0000404c_block_size - decode_0000404c_params[1];\n      if (decode_0000404c_params[13] != 0) {\n        decode_0000404c_block_size_diff = decode_0000404c_block_size_diff - decode_0000404c_params[16];\n      }\n      decode_0000404c_block_size = (*(code *)decode_0000404c_params[11])(input_buffer, decode_0000404c_params[8], decode_0000404c_block_size_diff, 0);\n    }\n    decode_0000404c_block_type = *(ushort *)(decode_0000404c_params + 3);\n    if ((decode_0000404c_block_size == -1) && ((0x1d < *input_buffer) || (-1 < (int)((DAT_00004154 >> (*input_buffer & 0xff)) << 0x1f))))) {\n      decode_0000404c_error = true;\n      goto DECODE_ERROR;\n    }\n    decode_0000404c_params[1] = 0;\n    *decode_0000404c_params = decode_0000404c_params[4];\n    if (((int)((uint)decode_0000404c_block_type << 0x13) < 0) && ((decode_0000404c_block_size != -1) || (*input_buffer == 0))) {\n      decode_0000404c_params[21] = decode_0000404c_block_size;\n    }\n    int *decode_0000404c_node_pointer = (int *)decode_0000404c_params[13];\n    *input_buffer = decode_0000404c_original_input_buffer;\n    if (decode_0000404c_node_pointer != (int *)0x0) {\n      if (decode_0000404c_node_pointer != decode_0000404c_params + 17) {\n        insert_node_00004b34(input_buffer);\n      }\n      decode_0000404c_params[13] = 0;\n      return 0;\n    }\n  }\n  return 0;\n  DECODE_ERROR:\n  *(ushort *)(decode_0000404c_params + 3) = decode_0000404c_block_type | 0x40;\n  return decode_0000404c_block_size;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000404c",
            "calling": [
                "FUN_00004158",
                "FUN_00006768"
            ],
            "imported": false,
            "current_name": "decode_0000404c"
        },
        "FUN_00002f74": {
            "renaming": {
                "FUN_00002f74": "print_devices_00002f74",
                "local_18": "device_count",
                "local_14": "device_list",
                "uVar1": "device_address",
                "get_class_000039e8": "get_device_class",
                "FUNC_00004c84": "print_device_info"
            },
            "code": "void print_devices_00002f74(void)\n{\n  undefined4 device_address;\n  int device_count = 0;\n  undefined4 *device_list = *(undefined4 **)PTR_DAT_00002fd0;\n  if (device_list == (undefined4 *)0x0) {\n    print_message(PTR_s_No_devices_found_00002fd8);\n  }\n  else {\n    print_message(PTR_s_ID_Class_Name_00002fd4);\n  }\n  for (; device_list != (undefined4 *)0x0; device_list = (undefined4 *)*device_list) {\n    device_address = get_class_000039e8(*(undefined *)(device_list[3] + 8));\n    initialize_data_00004c84(PTR_s___i__s__s_00002fdc, device_count, device_address, device_list[2]);\n    device_count++;\n  }\n  return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_000039e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f74",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "print_devices_00002f74",
            "code_backup": "\nvoid FUN_00002f74(void)\n\n{\n  undefined4 uVar1;\n  int local_18;\n  undefined4 *local_14;\n  \n  local_14 = *(undefined4 **)PTR_DAT_00002fd0;\n  local_18 = 0;\n  if (local_14 == (undefined4 *)0x0) {\n    FUNC_00004db8(PTR_s_No_devices_found_00002fd8);\n  }\n  else {\n    FUNC_00004db8(PTR_s_ID_Class_Name_00002fd4);\n  }\n  for (; local_14 != (undefined4 *)0x0; local_14 = (undefined4 *)*local_14) {\n    uVar1 = get_class_000039e8(*(undefined *)(local_14[3] + 8));\n    FUNC_00004c84(PTR_s___i__s__s_00002fdc,local_18,uVar1,local_14[2]);\n    local_18 = local_18 + 1;\n  }\n  return;\n}\n\n"
        },
        "FUN_000010a0": {
            "renaming": {
                "FUN_000010a0": "calculate_distance_000010a0",
                "param_1": "ptr_param_1",
                "local_c": "ptr_current"
            },
            "code": "int calculate_distance_000010a0(int *ptr_param_1)\n{\n  int *ptr_current = ptr_param_1;\n  while ((int *)*ptr_current == ptr_current)\n  {\n    ptr_current++;\n  }\n  return (int)ptr_current - (int)ptr_param_1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010a0",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "calculate_distance_000010a0"
        },
        "FUN_000012e2": {
            "renaming": {
                "FUN_000012e2": "find_first_non_matching_pointer_000012e2",
                "param_1": "ptr_array",
                "param_2": "val1",
                "param_3": "val2",
                "iVar1": "index",
                "find_first_non_matching_pointer_0000231c": "find_first_non_matching_pointer",
                "handle_interrupt_on_flag_change_0000129c": "handle_interrupt_on_flag_change"
            },
            "code": "int find_first_non_matching_pointer_000012e2(int ptr_array, unsigned int val1, unsigned int val2)\n{\n  int index = 0;\n  while( find_first_non_matching_pointer_000012e2_0000231c(ptr_array + 4, val1, val2) == 0 )\n  {\n    handle_interrupt_on_flag_change(ptr_array);\n  }\n  index = find_first_non_matching_pointer_000012e2_0000231c(ptr_array + 4, val1, val2);\n  return index;\n}",
            "called": [
                "FUN_0000129c",
                "FUN_0000231c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012e2",
            "calling": [
                "FUN_00000e14"
            ],
            "imported": false,
            "current_name": "find_first_non_matching_pointer_000012e2"
        },
        "FUN_000056a0": {
            "renaming": {
                "FUN_000056a0": "find_key_value_pair_000056a0",
                "param_1": "key",
                "param_2": "value",
                "param_3": "stack_c",
                "param_4": "stack_d",
                "uStack_c": "temp_stack_c",
                "uStack_8": "temp_stack_d"
            },
            "code": "void find_key_value_pair_000056a0(undefined4 key, undefined4 value, undefined4* stack_c, undefined4 stack_d, undefined4 stack_e)\n{\n  undefined4 temp_stack_c;\n  undefined4 temp_stack_d;\n  temp_stack_c = value;\n  temp_stack_d = stack_d;\n  find_key_value_pair_000056a0_0000562c(key, value, &temp_stack_c, stack_e, key);\n  return;\n}",
            "called": [
                "FUN_0000562c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056a0",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "find_key_value_pair_000056a0"
        },
        "FUN_0000231c": {
            "renaming": {
                "FUN_0000231c": "find_first_non_matching_pointer_0000231c",
                "param_1": "pointer",
                "param_2": "buffer",
                "param_3": "buffer_length",
                "uVar1": "new_value",
                "iVar2": "pointer_match",
                "local_20": "buffer_ptr",
                "local_14": "remaining_buffer_length"
            },
            "code": "int find_first_non_matching_pointer_0000231c(int pointer, unsigned char *buffer, int buffer_length) {\n  unsigned char new_value;\n  int pointer_match;\n  unsigned char *buffer_ptr;\n  int remaining_buffer_length;\n  buffer_ptr = buffer;\n  remaining_buffer_length = buffer_length;\n  while (remaining_buffer_length != 0 && (pointer_match = is_pointer_equal(pointer)) == 0) {\n    new_value = increment_value(pointer);\n    *buffer_ptr = new_value;\n    remaining_buffer_length--;\n    buffer_ptr++;\n  }\n  return buffer_length - remaining_buffer_length;\n}",
            "called": [
                "FUN_000022f0",
                "FUN_00002270"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000231c",
            "calling": [
                "FUN_000012e2"
            ],
            "imported": false,
            "current_name": "find_first_non_matching_pointer_0000231c"
        },
        "FUN_000061cc": {
            "renaming": {
                "FUN_000061cc": "FUNC_000061cc"
            },
            "code": "\nint FUNC_000061cc(int param_1,byte **param_2,byte *param_3,int **param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  uint uVar6;\n  int **local_2b0;\n  undefined auStack_2ac [256];\n  uint local_1ac;\n  undefined4 local_1a8;\n  uint local_1a4;\n  int local_1a0;\n  int local_19c;\n  undefined *local_198;\n  int local_194;\n  undefined *local_30;\n  code *local_2c;\n  \n  puVar2 = PTR_DAT_000064b4;\n  puVar1 = PTR_DAT_000064b0;\n  local_1a0 = 0;\n  local_19c = 0;\n  local_30 = PTR_LAB_00006118_1_000064a8;\n  local_2c = DAT_000064ac;\n  local_2b0 = param_4;\n  local_198 = auStack_2ac;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      uVar6 = (uint)*param_3;\n      if (uVar6 == 0) {\n        return local_1a0;\n      }\n      uVar4 = (byte)puVar1[uVar6] & 8;\n      pbVar5 = param_3 + 1;\n      if ((puVar1[uVar6] & 8) == 0) break;\n      while (((param_3 = pbVar5, 0 < (int)param_2[1] ||\n              (iVar3 = (*local_2c)(param_1,param_2), iVar3 == 0)) &&\n             ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0))) {\n        local_19c = local_19c + 1;\n        param_2[1] = param_2[1] + -1;\n        *param_2 = *param_2 + 1;\n      }\n    }\n    if (uVar6 == 0x25) break;\nLAB_00006352:\n    if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n    goto LAB_00006380;\n    if (**param_2 != uVar6) {\n      return local_1a0;\n    }\n    *param_2 = *param_2 + 1;\n    local_19c = local_19c + 1;\n    param_2[1] = param_2[1] + -1;\n    param_3 = pbVar5;\n  }\n  local_1a4 = uVar4;\n  local_1ac = uVar4;\n  if (param_3[1] == 0x2a) {\n    pbVar5 = param_3 + 2;\n    local_1ac = 0x10;\n  }\n  while( true ) {\n    uVar4 = (uint)*pbVar5;\n    if (9 < uVar4 - 0x30) break;\n    pbVar5 = pbVar5 + 1;\n    local_1a4 = (local_1a4 * 10 + uVar4) - 0x30;\n  }\n  iVar3 = find_byte_sequence_00006010(PTR_DAT_000064b4,uVar4,3);\n  if (iVar3 != 0) {\n    local_1ac = 1 << (iVar3 - (int)puVar2 & 0xffU) | local_1ac;\n    pbVar5 = pbVar5 + 1;\n  }\n  param_3 = pbVar5 + 1;\n  uVar4 = (uint)*pbVar5;\n  if (uVar4 < 0x79) {\n    if (0x57 < uVar4) {\n      switch(uVar4) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        param_3 = (byte *)replace_chars_0000687c(auStack_2ac,param_3);\n        local_1ac = local_1ac | 0x40;\n        local_194 = 1;\n        break;\n      case 99:\n        local_1ac = local_1ac | 0x40;\n        local_194 = 0;\n        break;\n      case 100:\n      case 0x75:\n        local_1a8 = 10;\nLAB_000063a0:\n        if (uVar4 < 0x6f) {\n          local_194 = 3;\n        }\n        else {\n          local_194 = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        local_194 = 5;\n        break;\n      case 0x69:\n        local_1a8 = 0;\n        local_194 = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(local_1ac << 0x1b)) {\n          if ((int)(local_1ac << 0x1f) < 0) {\n            *(short *)*local_2b0 = (short)local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n          else {\n            **local_2b0 = local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        local_1a8 = 8;\n        local_194 = 4;\n        break;\n      case 0x70:\n        local_1ac = local_1ac | 0x20;\n      case 0x58:\n      case 0x78:\n        local_1ac = local_1ac | 0x200;\n        local_1a8 = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        local_194 = 2;\n      }\nLAB_000063ac:\n      if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(local_1ac << 0x19)) {\n        while ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0) {\n          local_19c = local_19c + 1;\n          pbVar5 = param_2[1];\n          param_2[1] = pbVar5 + -1;\n          if ((int)(pbVar5 + -1) < 1) {\n            iVar3 = (*local_2c)(param_1,param_2);\n            if (iVar3 != 0) goto LAB_00006380;\n          }\n          else {\n            *param_2 = *param_2 + 1;\n          }\n        }\n      }\n      if (local_194 < 3) {\n        iVar3 = process_data_000064bc(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else if (local_194 < 5) {\n        iVar3 = FUNC_0000656c(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else {\n        iVar3 = param_1;\n        if (DAT_000064b8 == 0) goto LAB_000061f6;\n      }\n      if (iVar3 == 1) {\n        return local_1a0;\n      }\n      if (iVar3 == 2) {\nLAB_00006380:\n        if (local_1a0 == 0) {\nLAB_00006388:\n          local_1a0 = -1;\n        }\n        else if ((*(ushort *)(param_2 + 3) & 0x40) != 0) {\n          local_1a0 = -1;\n        }\n        return local_1a0;\n      }\n      goto LAB_000061f6;\n    }\n    pbVar5 = param_3;\n    if (uVar4 == 0x25) goto LAB_00006352;\n    if (uVar4 < 0x26) {\n      if (uVar4 != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (uVar4 - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  local_194 = 3;\n  local_1a8 = 10;\n  goto LAB_000063ac;\n}\n\n",
            "called": [
                "FUN_000064bc",
                "FUN_0000687c",
                "FUN_00006010",
                "FUN_0000656c",
                "FUN_00006192"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000061cc",
            "calling": [
                "FUN_00005e68"
            ],
            "imported": false,
            "current_name": "FUNC_000061cc"
        },
        "FUN_00002690": {
            "renaming": {
                "FUN_00002690": "convert_seconds_to_date_time_and_get_zero_00002690",
                "param_1": "seconds",
                "local_10": "dat_value_plus_one",
                "uStack_c": "zero",
                "get_dat_value_plus_one_000028f0": "get_dat_value_plus_one",
                "convert_seconds_to_date_time_0000443c": "convert_seconds_to_date_time"
            },
            "code": "int convert_seconds_to_date_time_and_get_zero_00002690(int seconds){\n  int dat_value_plus_one = get_dat_value_plus_one();\n  int zero = 0;\n  convert_seconds_to_date_time(&dat_value_plus_one, seconds);\n  return zero;\n}",
            "called": [
                "FUN_0000443c",
                "FUN_000028f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002690",
            "calling": [
                "FUN_000033c0"
            ],
            "imported": false,
            "current_name": "convert_seconds_to_date_time_and_get_zero_00002690"
        },
        "FUN_00006010": {
            "renaming": {
                "FUN_00006010": "find_byte_sequence_00006010",
                "param_1": "memory",
                "param_2": "target_byte",
                "param_3": "length",
                "bVar1": "current_byte",
                "cVar2": "is_byte_0",
                "cVar3": "is_byte_1",
                "cVar4": "is_byte_2",
                "cVar5": "is_byte_3",
                "pbVar6": "next_byte",
                "puVar7": "current_word",
                "pbVar8": "result",
                "uVar9": "offset",
                "uVar10": "length_remaining",
                "uVar11": "word_mask",
                "uVar12": "byte_mask",
                "bVar13": "byte_0_matches",
                "bVar14": "byte_1_matches",
                "bVar15": "byte_2_matches",
                "bVar16": "byte_3_matches"
            },
            "code": "byte * find_byte_sequence_00006010(uint *memory, uint target_byte, uint length) {\n    byte *result = NULL;\n    uint *current_word;\n    byte *current_byte;\n    uint target_word = (target_byte << 24) | (target_byte << 16) | (target_byte << 8) | target_byte;\n    uint length_remaining;\n    bool word_matches;\n    bool byte_matches;\n    uint i;\n    if ((int)length < 16) {\n        length_remaining = length;\n        while (length_remaining > 0) {\n            if (*memory == target_byte) {\n                result = (byte *)memory;\n                break;\n            }\n            memory++;\n            length_remaining--;\n        }\n    }\n    else {\n        current_word = (uint *)((int)memory & ~7);\n        length_remaining = length & ~7;\n        while (length_remaining > 0) {\n            word_matches = (*current_word == target_word);\n            byte_matches = false;\n            if (!word_matches) {\n                current_byte = (byte *)current_word;\n                for (i = 0; i < 4; i++) {\n                    if (*current_byte == target_byte) {\n                        byte_matches = true;\n                        break;\n                    }\n                    current_byte++;\n                }\n            }\n            if (word_matches || byte_matches) {\n                result = (byte *)current_word;\n                break;\n            }\n            current_word++;\n            length_remaining -= 4;\n        }\n        length_remaining = length & 7;\n        while (length_remaining > 0) {\n            if (*(byte *)current_word == target_byte) {\n                result = (byte *)current_word;\n                break;\n            }\n            current_word = (uint *)((byte *)current_word + 1);\n            length_remaining--;\n        }\n    }\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006010",
            "calling": [
                "FUN_00005b34",
                "FUN_000057f8",
                "FUN_000061cc",
                "FUN_0000656c"
            ],
            "imported": false,
            "current_name": "find_byte_sequence_00006010"
        },
        "FUN_00001cf0": {
            "renaming": {
                "FUN_00001cf0": "check_flag_status_00001cf0",
                "PTR_DAT_00001d04": "flag_ptr",
                "set_flag_on_0000093c": "set_flag_on"
            },
            "code": "void check_flag_status_00001cf0(void)\n{\n  int* PTR_DAT_00001d04 = (int*)PTR_DAT_00001d04;\n  if (*PTR_DAT_00001d04 != 0) {\n    set_flag_on_0000093c();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001cf0",
            "calling": [
                "FUN_00002028"
            ],
            "imported": false,
            "current_name": "check_flag_status_00001cf0"
        },
        "FUN_00003ec4": {
            "renaming": {
                "FUN_00003ec4": "convert_to_string_00003ec4",
                "param_1": "input",
                "param_2": "output_len",
                "param_3": "decimal_places",
                "iVar1": "quotient_digits",
                "uVar2": "remainder_digits",
                "uVar3": "quotient",
                "local_10": "remainder",
                "local_c": "digit_count"
            },
            "code": "int convert_to_string_00003ec4(const char *input, uint32_t len);\n\nint convert_to_string_00003ec4(char *output, uint32_t output_len, uint32_t value, int32_t decimal_places)\n{\n  int output_index = 0;\n  if (decimal_places + 7 < 0 != SCARRY4(decimal_places, 7)) {\n    initialize_and_execute(3, PTR_s_FAILED_ASSERTION__00003fec);\n  }\n  int digit_count = 0;\n  if (decimal_places == 0) {\n    digit_count = convert_to_string_00003ec4(input, output_len);\n  }\n  else if (decimal_places < 1) {\n    uint32_t divisor = *(uint32_t *)(PTR_DAT_00003ff0 + decimal_places * -4);\n    uint32_t quotient = value / divisor;\n    uint32_t remainder = value - divisor * quotient;\n    if (remainder < 0) {\n      remainder = -remainder;\n    }\n    if ((quotient == 0) && ((int32_t)value < 0)) {\n      if (output != NULL) {\n        *output = '-';\n      }\n      digit_count = 1;\n    }\n    if (output == NULL) {\n      int quotient_digits = convert_to_string_00003ec4(NULL, quotient);\n      digit_count = quotient_digits + 1 + digit_count;\n    }\n    else {\n      int quotient_digits = convert_to_string_00003ec4(output + digit_count, quotient);\n      output_index = digit_count + quotient_digits;\n      digit_count = output_index + 1;\n      output[output_index] = '.';\n      int remainder_digits = convert_to_string_00003ec4(output + digit_count, remainder);\n      copy_and_fill(output + digit_count, remainder_digits, -decimal_places, '0');\n    }\n    digit_count = -decimal_places + digit_count;\n  }\n  else {\n    digit_count = convert_to_string_00003ec4(input, value);\n    if (output != NULL) {\n      fill_array_with_value(output + digit_count, '0', decimal_places);\n    }\n    digit_count = decimal_places + digit_count;\n  }\n  return digit_count;\n}",
            "called": [
                "FUN_00000f04",
                "FUN_00003ff4",
                "FUN_00003e58",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ec4",
            "calling": [
                "FUN_00003e9e"
            ],
            "imported": false,
            "current_name": "convert_to_string_00003ec4"
        },
        "FUN_00001360": {
            "renaming": {
                "FUN_00001360": "calculate_address_00001360",
                "param_1": "address",
                "param_2": "offset"
            },
            "code": "int calculate_address_00001360(uint32_t address, int offset) {\n    uint32_t high_bits = address & 0xf0000000;\n    uint32_t low_bits = address & 0xfffff;\n    int shifted_low_bits = low_bits << 5;\n    int result = (offset * 4) + high_bits + shifted_low_bits + 0x2000000;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001360",
            "calling": [
                "FUN_00001392"
            ],
            "imported": false,
            "current_name": "calculate_address_00001360"
        },
        "FUN_00004622": {
            "renaming": {
                "FUN_00004622": "fill_array_with_value_00004622",
                "param_1": "array",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "end_of_array",
                "*param_1": "*array"
            },
            "code": "void fill_array_with_value_00004622(char* array, char value, int size)\n{\n  char* end_of_array = array + size;\n  for (; array != end_of_array; array++) {\n    *array = value;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004622",
            "calling": [
                "FUN_00003ec4",
                "FUN_0000305c",
                "FUN_00004248",
                "FUN_000041f4",
                "FUN_00003ff4",
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "fill_array_with_value_00004622"
        },
        "FUN_0000093c": {
            "renaming": {
                "FUN_0000093c": "set_flag_on_0000093c",
                "DAT_00000954": "data_ptr",
                "uint": "uint32_t",
                "PTR_": "",
                "DAT_": ""
            },
            "code": "void set_flag_on_0000093c(uint32_t* DAT_00000954)\n{\n  uint32_t* flag_ptr = DAT_00000954 + 1;\n  uint32_t flag_value = *flag_ptr | 0x10000000;\n  *flag_ptr = flag_value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000093c",
            "calling": [
                "FUN_00001cf0",
                "FUN_00002434",
                "FUN_00001348",
                "FUN_00000738",
                "FUN_00002798"
            ],
            "imported": false,
            "current_name": "set_flag_on_0000093c"
        },
        "FUN_00003658": {
            "renaming": {
                "FUN_00003658": "synchronize_data_00003658",
                "DAT_00003680": "data_address",
                "DAT_00003684": "data_value",
                "uint": "unsigned int",
                "data_ptr": "data_pointer",
                "data_value": "current_data_value"
            },
            "code": "void synchronize_data_00003658(void)\n{\n  DataSynchronizationBarrier(0xf);\n  uint* data_ptr = (uint*)(DAT_00003680 + 0xc);\n  uint DAT_00003684 = *data_ptr & 0x700;\n  *data_ptr = DAT_00003684 | DAT_00003684;\n  DataSynchronizationBarrier(0xf);\n  while(true)\n  {\n    // Wait for data synchronization\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003658",
            "calling": [
                "FUN_00003688"
            ],
            "imported": false,
            "current_name": "synchronize_data_00003658"
        },
        "FUN_000019c0": {
            "renaming": {
                "FUN_000019c0": "initialize_and_set_flags_000019c0",
                "set_bit_00001778": "set_bit_flags",
                "set_param_1_00001748": "set_param_value",
                "set_result_to_zero_00001710": "set_result_to_zero",
                "DAT_00001a0c": "result_array",
                "DAT_00001a10": "result_array_flags",
                "PTR_DAT_00001a14": "PTR_DAT",
                "initializeResult_00001734": "initialize_result_array"
            },
            "code": "void initialize_and_set_flags_000019c0(void)\n{\n  set_bit_flags();\n  set_param_value(0x40);\n  set_result_to_zero(DAT_00001a0c,1);\n  *DAT_00001a10 = *DAT_00001a10 & 0x3b | 0x80;\n  do {\n  } while ((DAT_00001a10[6] & 0xc) != 8);\n  initialize_DAT_00001a0c();\n  *PTR_DAT_00001a14_00001a14 = 3;\n  return;\n}",
            "called": [
                "FUN_00001778",
                "FUN_00001748",
                "FUN_00001734",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000019c0",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initialize_and_set_flags_000019c0"
        },
        "FUN_000060b0": {
            "renaming": {
                "FUN_000060b0": "copy_string_000060b0",
                "param_1": "length",
                "param_2": "source_string",
                "param_3": "destination_string",
                "puVar1": "source_ptr",
                "puVar2": "destination_end",
                "puVar3": "destination_ptr"
            },
            "code": "void copy_string_000060b0(int length, undefined *source_string, undefined *destination_string)\n{\n  undefined *source_ptr;\n  undefined *destination_ptr;\n  undefined *destination_end;\n  destination_end = destination_string + length;\n  source_ptr = source_string;\n  destination_ptr = destination_string;\n  while (destination_ptr != destination_end) {\n    *destination_ptr = *source_ptr;\n    source_ptr++;\n    destination_ptr++;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060b0",
            "calling": [
                "FUN_000068f0",
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "copy_string_000060b0"
        },
        "FUN_00006a14": {
            "renaming": {
                "FUN_00006a14": "FUNC_00006a14"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong FUNC_00006a14(uint param_1,uint param_2,uint param_3,uint param_4,uint *param_5)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  uint uVar1;\n  uint *puVar2;\n  uint *puVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  bool bVar11;\n  ulonglong uVar12;\n  \n  if (param_4 == 0) {\n    if (param_2 < param_3) {\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 != 0) {\n        param_3 = param_3 << (uVar4 & 0xff);\n        param_2 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        param_1 = param_1 << (uVar4 & 0xff);\n      }\n      uVar7 = param_3 >> 0x10;\n      uVar9 = param_2 / uVar7;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar7 * uVar9) * 0x10000;\n      uVar1 = uVar9 * (param_3 & 0xffff);\n      uVar6 = uVar9;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar9 = (uVar5 - uVar1) / uVar7;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar7 * uVar9) * 0x10000;\n      uVar7 = uVar9 * (param_3 & 0xffff);\n      uVar1 = uVar9;\n      if (uVar5 <= uVar7 && uVar7 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar7 && uVar7 - uVar5 != 0)) {\n          uVar1 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar7;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n      puVar3 = (uint *)0x0;\n    }\n    else {\n      if (param_3 == 0) {\n                    /* WARNING: Could not recover jumptable at 0x00006abc. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x6abc);\n        uVar12 = (*UNRECOVERED_JUMPTABLE)();\n        return uVar12;\n      }\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 == 0) {\n        param_2 = param_2 - param_3;\n        uVar10 = param_3 >> 0x10;\n        uVar8 = param_3 & 0xffff;\n        puVar3 = (uint *)0x1;\n      }\n      else {\n        param_3 = param_3 << (uVar4 & 0xff);\n        uVar10 = param_3 >> 0x10;\n        uVar6 = param_2 >> (0x20 - uVar4 & 0xff);\n        uVar1 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        uVar5 = uVar6 / uVar10;\n        uVar8 = param_3 & 0xffff;\n        uVar9 = uVar1 >> 0x10 | (uVar6 - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        param_1 = param_1 << (uVar4 & 0xff);\n        uVar6 = uVar5;\n        if (uVar9 <= uVar7 && uVar7 - uVar9 != 0) {\n          bVar11 = CARRY4(param_3,uVar9);\n          uVar9 = param_3 + uVar9;\n          uVar6 = uVar5 - 1;\n          if ((bVar11 == false) && (uVar9 <= uVar7 && uVar7 - uVar9 != 0)) {\n            uVar6 = uVar5 - 2;\n            uVar9 = uVar9 + param_3;\n          }\n        }\n        uVar5 = (uVar9 - uVar7) / uVar10;\n        param_2 = uVar1 & 0xffff | ((uVar9 - uVar7) - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        uVar1 = uVar5;\n        if (param_2 <= uVar7 && uVar7 - param_2 != 0) {\n          bVar11 = CARRY4(param_3,param_2);\n          param_2 = param_3 + param_2;\n          uVar1 = uVar5 - 1;\n          if ((bVar11 == false) && (param_2 <= uVar7 && uVar7 - param_2 != 0)) {\n            uVar1 = uVar5 - 2;\n            param_2 = param_2 + param_3;\n          }\n        }\n        param_2 = param_2 - uVar7;\n        puVar3 = (uint *)(uVar1 | uVar6 << 0x10);\n      }\n      uVar7 = param_2 / uVar10;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar10 * uVar7) * 0x10000;\n      uVar1 = uVar8 * uVar7;\n      uVar6 = uVar7;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar7 = (uVar5 - uVar1) / uVar10;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar10 * uVar7) * 0x10000;\n      uVar8 = uVar8 * uVar7;\n      uVar1 = uVar7;\n      if (uVar5 <= uVar8 && uVar8 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar8 && uVar8 - uVar5 != 0)) {\n          uVar1 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar8;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = uVar5 >> (uVar4 & 0xff);\n      param_5[1] = 0;\n    }\n  }\n  else if (param_2 < param_4) {\n    puVar2 = param_5;\n    puVar3 = param_5;\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n      return 0;\n    }\n  }\n  else {\n    puVar3 = (uint *)count_leading_zeroes(param_4);\n    if (puVar3 != (uint *)0x0) {\n      uVar8 = 0x20 - (int)puVar3;\n      uVar5 = param_3 >> (uVar8 & 0xff) | param_4 << ((uint)puVar3 & 0xff);\n      uVar10 = uVar5 >> 0x10;\n      uVar4 = param_2 >> (uVar8 & 0xff);\n      uVar6 = param_1 >> (uVar8 & 0xff) | param_2 << ((uint)puVar3 & 0xff);\n      uVar7 = uVar4 / uVar10;\n      uVar1 = uVar6 >> 0x10 | (uVar4 - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      param_3 = param_3 << ((uint)puVar3 & 0xff);\n      param_1 = param_1 << ((uint)puVar3 & 0xff);\n      uVar4 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar4 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar4 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar7 = (uVar1 - uVar9) / uVar10;\n      uVar1 = uVar6 & 0xffff | ((uVar1 - uVar9) - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      uVar6 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar6 = uVar6 | uVar4 << 0x10;\n      uVar12 = (ulonglong)uVar6 * (ulonglong)param_3;\n      if (CONCAT44(uVar1 - uVar9,param_1) < uVar12) {\n        uVar12 = uVar12 - CONCAT44(uVar5,param_3);\n        uVar6 = uVar6 - 1;\n      }\n      if (param_5 != (uint *)0x0) {\n        uVar4 = ((uVar1 - uVar9) - (int)(uVar12 >> 0x20)) - (uint)(param_1 < (uint)uVar12);\n        *param_5 = uVar4 << (uVar8 & 0xff) | param_1 - (uint)uVar12 >> ((uint)puVar3 & 0xff);\n        param_5[1] = uVar4 >> ((uint)puVar3 & 0xff);\n      }\n      return (ulonglong)uVar6;\n    }\n    if ((param_4 < param_2) || (puVar2 = puVar3, param_3 <= param_1)) {\n      bVar11 = param_1 < param_3;\n      param_1 = param_1 - param_3;\n      param_2 = (param_2 - param_4) - (uint)bVar11;\n      puVar2 = (uint *)0x1;\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n    }\n  }\n  return CONCAT44(puVar3,puVar2);\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00006a14",
            "calling": [
                "FUN_00006974"
            ],
            "imported": false,
            "current_name": "FUNC_00006a14"
        },
        "FUN_000023d0": {
            "renaming": {
                "FUN_000023d0": "check_software_interrupt_000023d0",
                "param_1": "param",
                "uVar1": "result",
                "PTR_DAT_000023fc": "ptr_data",
                "trigger_software_interrupt_000023c8": "trigger_interrupt"
            },
            "code": "int check_software_interrupt_000023d0(int param) {\n  int* PTR_DAT_000023fc = (int*) PTR_DAT_000023fc;\n  if (*PTR_DAT_000023fc == 0) {\n    return trigger_software_interrupt_000023c8(1, param, 0);\n  }\n  else {\n    return 0;\n  }\n}",
            "called": [
                "FUN_000023c8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023d0",
            "calling": [
                "FUN_000023a4"
            ],
            "imported": false,
            "current_name": "check_software_interrupt_000023d0"
        },
        "FUN_00000a30": {
            "renaming": {
                "FUN_00000a30": "get_stack_pointer_00000a30",
                "in_r3": "frame_pointer",
                "auStack_20": "stack_pointer",
                "initialize_and_execute_00000f04": "initialize_and_execute",
                "uRam00000a3c": "global_variable",
                "PTR_DAT_00000a60": "unknown_pointer"
            },
            "code": "char *get_stack_pointer_00000a30(void)\n{\n  int frame_pointer;\n  char *stack_pointer;\n  initialize_and_execute(4, global_variable);\n  stack_pointer = (char *)&frame_pointer - *(int *)(frame_pointer + 0x4c);\n  return stack_pointer;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a30",
            "calling": [],
            "imported": false,
            "current_name": "get_stack_pointer_00000a30"
        },
        "FUN_000034c0": {
            "renaming": {
                "FUN_000034c0": "initialize_rtc_commands_000034c0",
                "FUNC_00004db8": "initialize_rtc_command",
                "PTR_s_usage__rtc__command___arguments__00003500": "s_usage_rtc_command_arguments_00003500",
                "PTR_s_commands__00003504": "s_commands_00003504",
                "PTR_s__poweron_power_the_interface_on_00003508": "s_poweron_power_the_interface_on_00003508",
                "PTR_s__poweroff_power_the_interface_of_0000350c": "s_poweroff_power_the_interface_of_0000350c",
                "PTR_s__clearalarm_deactivate_the_curre_00003510": "s_clearalarm_deactivate_the_curre_00003510",
                "PTR_s__getalarm_print_the_currently_al_00003514": "s_getalarm_print_the_currently_al_00003514",
                "PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518": "s_setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518",
                "PTR_s__gettime_print_the_current_time_0000351c": "s_gettime_print_the_current_time_0000351c",
                "PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520": "s_settime_YYYY_MM_DD_HH_MM_SS_set_00003520"
            },
            "code": "int initialize_rtc_commands_000034c0(void)\n{\n    initialize_rtc_command(s_usage__rtc__command___arguments__00003500);\n    initialize_rtc_command(s_commands__00003504);\n    initialize_rtc_command(s__poweron_power_the_interface_on_00003508);\n    initialize_rtc_command(s__poweroff_power_the_interface_of_0000350c);\n    initialize_rtc_command(s__clearalarm_deactivate_the_curre_00003510);\n    initialize_rtc_command(s__getalarm_print_the_currently_al_00003514);\n    initialize_rtc_command(s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n    initialize_rtc_command(s__gettime_print_the_current_time_0000351c);\n    initialize_rtc_command(s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n    return 0;\n}\n",
            "called": [
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000034c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "initialize_rtc_commands_000034c0",
            "code_backup": "\nundefined4 FUN_000034c0(void)\n\n{\n  FUNC_00004db8(PTR_s_usage__rtc__command___arguments__00003500);\n  FUNC_00004db8(PTR_s_commands__00003504);\n  FUNC_00004db8(PTR_s__poweron_power_the_interface_on_00003508);\n  FUNC_00004db8(PTR_s__poweroff_power_the_interface_of_0000350c);\n  FUNC_00004db8(PTR_s__clearalarm_deactivate_the_curre_00003510);\n  FUNC_00004db8(PTR_s__getalarm_print_the_currently_al_00003514);\n  FUNC_00004db8(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n  FUNC_00004db8(PTR_s__gettime_print_the_current_time_0000351c);\n  FUNC_00004db8(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n  return 0;\n}\n\n"
        },
        "FUN_000050e8": {
            "renaming": {
                "FUN_000050e8": "get_pointer_data_000050e8",
                "PTR_DAT_000050f0": "pointer_data"
            },
            "code": "const char* get_pointer_data_000050e8() {\n    return PTR_DAT_000050f0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050e8",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "get_pointer_data_000050e8"
        },
        "FUN_000042a4": {
            "renaming": {
                "FUN_000042a4": "initialize_arrays_000042a4",
                "param_1": "array_pointer",
                "uVar1": "initialize_value",
                "iVar2": "current_pointer",
                "bVar3": "is_current_pointer_equal_to_array_pointer"
            },
            "code": "void initialize_arrays_000042a4(int array_pointer){\n    undefined4 initialize_value;\n    int current_pointer;\n    bool is_current_pointer_equal_to_array_pointer;\n  \n    do_nothing_with_data();\n    if (*(int *)(array_pointer + 0x18) == 0) {\n        *(undefined4 *)(array_pointer + 0x48) = 0;\n        *(undefined4 *)(array_pointer + 0x4c) = 0;\n        *(undefined4 *)(array_pointer + 0x50) = 0;\n        current_pointer = *(int *)PTR_DAT_0000430c;\n        *(undefined **)(array_pointer + 0x28) = PTR_DAT_00004310;\n        is_current_pointer_equal_to_array_pointer = current_pointer == array_pointer;\n        if (is_current_pointer_equal_to_array_pointer) {\n            current_pointer = 1;\n        }\n        if (is_current_pointer_equal_to_array_pointer) {\n            *(int *)(array_pointer + 0x18) = current_pointer;\n        }\n        initialize_value = initialize_array_00004314(array_pointer);\n        *(undefined4 *)(array_pointer + 4) = initialize_value;\n        initialize_value = initialize_array_00004314(array_pointer);\n        *(undefined4 *)(array_pointer + 8) = initialize_value;\n        initialize_value = initialize_array_00004314(array_pointer);\n        *(undefined4 *)(array_pointer + 0xc) = initialize_value;\n        initialize_values_000041f4(*(undefined4 *)(array_pointer + 4),4,0);\n        initialize_values_000041f4(*(undefined4 *)(array_pointer + 8),9,1);\n        initialize_values_000041f4(*(undefined4 *)(array_pointer + 0xc),0x12,2);\n        *(undefined4 *)(array_pointer + 0x18) = 1;\n    }\n    do_nothing(DAT_000042a0);\n    return;\n}",
            "called": [
                "FUN_0000428c",
                "FUN_000041f4",
                "FUN_000045ec",
                "FUN_00004314"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000042a4",
            "calling": [
                "FUN_00004c84",
                "FUN_000057f8",
                "FUN_00004db8",
                "FUN_00005404",
                "FUN_00005e10",
                "FUN_000054a8",
                "FUN_00004158",
                "FUN_00006768",
                "FUN_00004418",
                "FUN_00004cb4",
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "initialize_arrays_000042a4"
        },
        "FUN_00000514": {
            "renaming": {
                "FUN_00000514": "set_param_value_to_19_00000514",
                "param_1": "param_value",
                "*param_1": "*param_value"
            },
            "code": "int set_param_value_to_19_00000514(int *param_value)\n{\n  *param_value = 19;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000514",
            "calling": [
                "FUN_000056b8"
            ],
            "imported": false,
            "current_name": "set_param_value_to_19_00000514"
        },
        "FUN_00002e9c": {
            "renaming": {
                "FUN_00002e9c": "synchronize_data_00002e9c"
            },
            "code": "int synchronize_data_00002e9c() {\n  synchronize_data_00002e9c_00003688();\n  return 0;\n}",
            "called": [
                "FUN_00003688"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e9c",
            "calling": [],
            "imported": false,
            "current_name": "synchronize_data_00002e9c"
        },
        "FUN_00001960": {
            "renaming": {
                "FUN_00001960": "initialize_system_00001960",
                "set_param_1_00001748": "set_parameter",
                "set_result_to_zero_00001710": "set_result_to_zero",
                "*DAT_000019b8": "*flag",
                "DAT_000019b4": "data_array",
                "*PTR_DAT_000019bc": "*pointer"
            },
            "code": "void initialize_system_00001960(void)\n{\n  set_parameter(160);\n  set_result_to_zero(DAT_000019b4, 1);\n  *DAT_000019b8 = *DAT_000019b8 & 59 | 68;\n  while ((flag[6] & 12) != 4);\n  while ((flag[6] & 16) == 0);\n  *PTR_DAT_000019bc = 2;\n  return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001960",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initialize_system_00001960"
        },
        "FUN_00000990": {
            "renaming": {
                "FUN_00000990": "do_nothing_00000990"
            },
            "code": "\nvoid do_nothing_00000990(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000990",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "do_nothing_00000990"
        },
        "FUN_00001a3c": {
            "renaming": {
                "FUN_00001a3c": "initialize_result_and_set_value_to_five_00001a3c",
                "DAT_00001a58": "result",
                "PTR_DAT_00001a5c": "ptr_data",
                "initializeResult_00001734": "initialize_result",
                "set_result_to_one_000016ec": "set_result_to_one"
            },
            "code": "void initialize_result_and_set_value_to_five_00001a3c(void)\n{\n  set_DAT_00001a58_to_one(DAT_00001a58, 1);\n  initialize_DAT_00001a58();\n  *PTR_DAT_00001a5c = 5;\n  return;\n}",
            "called": [
                "FUN_00001734",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a3c",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initialize_result_and_set_value_to_five_00001a3c"
        },
        "FUN_000045ee": {
            "renaming": {
                "FUN_000045ee": "reverse_copy_000045ee",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "size",
                "puVar1": "dest_end",
                "puVar2": "src_end"
            },
            "code": "void reverse_copy_000045ee(char *dest, char *src, int size) {\n  char *src_end = src + size;\n  if ((src < dest) && (dest < src_end)) {\n    char *dest_end = dest + size;\n    while (dest_end != dest) {\n      src_end--;\n      dest_end--;\n      *dest_end = *src_end;\n    }\n  }\n  else {\n    src--;\n    for (; src != src_end; src++, dest++) {\n      *dest = *src;\n    }\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ee",
            "calling": [
                "FUN_00003ff4"
            ],
            "imported": false,
            "current_name": "reverse_copy_000045ee"
        },
        "FUN_00005404": {
            "renaming": {
                "FUN_00005404": "process_data_00005404",
                "param_1": "file_descriptor",
                "param_2": "input_value",
                "param_3": "data_array",
                "param_4": "param_4",
                "iVar1": "array_value_1",
                "uVar2": "array_value_2",
                "puVar3": "byte_pointer"
            },
            "code": "uint process_data_00005404(int file_descriptor, uint input_value, int *data_array, undefined4 param_4)\n{\n  int array_value_1;\n  uint array_value_2;\n  undefined *byte_pointer;\n  \n  if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n    initialize_arrays();\n  }\n  if (data_array == (int *)array_pointer_1) {\n    data_array = *(int **)(file_descriptor + 4);\n  }\n  else if (data_array == (int *)array_pointer_2) {\n    data_array = *(int **)(file_descriptor + 8);\n  }\n  else if (data_array == (int *)array_pointer_3) {\n    data_array = *(int **)(file_descriptor + 0xc);\n  }\n  data_array[2] = data_array[6];\n  array_value_2 = (uint)*(ushort *)(data_array + 3);\n  array_value_1 = array_value_2 << 0x1c;\n  if (((array_value_1 < 0) && (array_value_2 = data_array[4], array_value_2 != 0)) ||\n     (array_value_1 = process_data_00005404_000054a8(file_descriptor,data_array,array_value_1,array_value_2,param_4), array_value_1 == 0)) {\n    array_value_1 = *data_array - data_array[4];\n    input_value = input_value & 0xff;\n    if ((array_value_1 < data_array[5]) || (array_value_1 = decode_and_do_nothing(file_descriptor,data_array), array_value_1 == 0)) {\n      data_array[2] = data_array[2] + -1;\n      byte_pointer = (undefined *)*data_array;\n      *data_array = (int)(byte_pointer + 1);\n      *byte_pointer = (char)input_value;\n      if (data_array[5] != array_value_1 + 1) {\n        if (-1 < (int)((uint)*(ushort *)(data_array + 3) << 0x1f)) {\n          return input_value;\n        }\n        if (input_value != 10) {\n          return input_value;\n        }\n      }\n      array_value_1 = decode_and_do_nothing(file_descriptor,data_array);\n      if (array_value_1 == 0) {\n        return input_value;\n      }\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "FUN_000054a8",
                "FUN_00004158",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005404",
            "calling": [
                "FUN_000057a8",
                "FUN_00004db8",
                "FUN_00004cb4"
            ],
            "imported": false,
            "current_name": "process_data_00005404"
        },
        "FUN_00006974": {
            "renaming": {
                "FUN_00006974": "calculate_result_00006974",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "shift_amount",
                "param_4": "remainder",
                "iVar1": "quotient_upper",
                "uVar2": "result",
                "local_8": "local_array"
            },
            "code": "undefined8 calculate_result_00006974(int dividend, int divisor, int shift_amount, int remainder)\n{\n  int quotient_upper, quotient_lower;\n  undefined8 result;\n  if ((remainder == 0) && (shift_amount == 0)) {\n    if (divisor < 0) {\n      dividend = 0;\n      divisor = -0x80000000;\n    }\n    else if (divisor != 0 || dividend != 0) {\n      divisor = 0x7fffffff;\n      dividend = -1;\n    }\n    return CONCAT44(divisor, dividend);\n  }\n  if (divisor < 0) {\n    quotient_upper = -divisor - (uint)(dividend != 0);\n    if (remainder < 0) {\n      result = FUNC_00006a14(-dividend, quotient_upper, -shift_amount, -remainder - (uint)(shift_amount != 0), local_8);\n      return result;\n    }\n    result = FUNC_00006a14(-dividend, quotient_upper, shift_amount, remainder, local_8);\n    return CONCAT44(-(int)((ulonglong)result >> 0x20) - (uint)((int)result != 0), -(int)result);\n  }\n  if (remainder < 0) {\n    result = FUNC_00006a14(dividend, divisor, -shift_amount, -remainder - (uint)(shift_amount != 0), local_8);\n    return CONCAT44(-(int)((ulonglong)result >> 0x20) - (uint)((int)result != 0), -(int)result);\n  }\n  result = FUNC_00006a14();\n  return result;\n}",
            "called": [
                "FUN_00006a14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006974",
            "calling": [
                "FUN_0000443c"
            ],
            "imported": false,
            "current_name": "calculate_result_00006974"
        },
        "FUN_00004314": {
            "renaming": {
                "FUN_00004314": "initialize_array_00004314",
                "param_1": "error_code",
                "piVar1": "array_ptr",
                "piVar2": "sub_array_ptr",
                "iVar3": "array_manager_ptr",
                "ppiVar4": "array_manager",
                "PTR_DAT_00004398": "ARRAY_MANAGER_PTR",
                "ARRAY_SIZE_OFFSET": "0x18",
                "FUNC_000042a4": "initialize_array_manager",
                "ARRAY_MANAGER_OFFSET": "0x48",
                "DAT_0000439c": "ARRAY_VALUE",
                "do_nothing_with_pointer_00004274": "do_nothing_with_pointer",
                "ARRAY_UNUSED": "0x3",
                "ARRAY_SIZE": "0x19",
                "do_nothing_000045e4": "do_nothing",
                "ARRAY_FIRST_ELEMENT": "0x1",
                "ARRAY_SECOND_ELEMENT": "0x2",
                "ARRAY_THIRD_ELEMENT": "0x4",
                "ARRAY_FOURTH_ELEMENT": "0x5",
                "ARRAY": "0x0",
                "ARRAY_FIFTH_ELEMENT": "0x6",
                "fill_array_with_value_00004622": "fill_array_with_value",
                "ARRAY_SIXTH_ELEMENT": "0x7",
                "ARRAY_SEVENTH_ELEMENT": "0xd",
                "ARRAY_EIGHTH_ELEMENT": "0xe",
                "ARRAY_NINTH_ELEMENT": "0x12",
                "ARRAY_TENTH_ELEMENT": "0x13",
                "allocate_and_initialize_array_00004248": "allocate_and_initialize_array",
                "do_nothing_with_pointer_00004280": "do_nothing_with_pointer",
                "*param_1": "error_code",
                "ERROR_CODE": "0xc"
            },
            "code": "int * initialize_array_00004314(int *error_code) {\n  int *array_ptr;\n  int *sub_array_ptr;\n  int array_manager_ptr;\n  int **array_manager;\n  do_nothing_with_pointer_00004274();\n  array_manager_ptr = *(int *)PTR_DAT_00004398;\n  if (*(int *)(array_manager_ptr + ARRAY_SIZE_OFFSET) == 0) {\n    initialize_array_00004314_manager(array_manager_ptr);\n  }\n  array_manager = (int **)(array_manager_ptr + ARRAY_MANAGER_OFFSET);\n  do {\n    sub_array_ptr = array_manager[1];\n    array_ptr = array_manager[2];\n    while (sub_array_ptr = (int *)((int)sub_array_ptr + -1), -1 < (int)sub_array_ptr) {\n      if (*(short *)(array_ptr + ARRAY_UNUSED) == 0) {\n        array_ptr[ARRAY_UNUSED] = DAT_0000439c;\n        array_ptr[ARRAY_SIZE] = 0;\n        do_nothing_000045e4(sub_array_ptr + ARRAY_OFFSET);\n        do_nothing_with_pointer_00004280();\n        array_ptr[ARRAY_FIRST_ELEMENT] = 0;\n        array_ptr[ARRAY_SECOND_ELEMENT] = 0;\n        array_ptr[ARRAY_THIRD_ELEMENT] = 0;\n        array_ptr[ARRAY_FOURTH_ELEMENT] = 0;\n        *array_ptr = 0;\n        array_ptr[ARRAY_FIFTH_ELEMENT] = 0;\n        fill_array_with_value_00004622(array_ptr + ARRAY_SIXTH_ELEMENT,0,8);\n        array_ptr[ARRAY_SEVENTH_ELEMENT] = 0;\n        array_ptr[ARRAY_EIGHTH_ELEMENT] = 0;\n        array_ptr[ARRAY_NINTH_ELEMENT] = 0;\n        array_ptr[ARRAY_TENTH_ELEMENT] = 0;\n        return array_ptr;\n      }\n      array_ptr = array_ptr + ARRAY_OFFSET;\n    }\n    if (*array_manager == (int *)0x0) {\n      sub_array_ptr = (int *)allocate_and_initialize_array_00004314_00004248(error_code,4);\n      *array_manager = sub_array_ptr;\n      if (sub_array_ptr == (int *)0x0) {\n        do_nothing_000045e4_with_pointer();\n        *error_code = ERROR_CODE;\n        return (int *)0x0;\n      }\n    }\n    array_manager = (int **)*array_manager;\n  } while( true );\n}",
            "called": [
                "FUN_000045e4",
                "FUN_00004274",
                "FUN_00004248",
                "FUN_00004280",
                "FUN_00004622",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004314",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "initialize_array_00004314",
            "code_backup": "\nint * FUN_00004314(undefined4 *param_1)\n\n{\n  int *piVar1;\n  int *piVar2;\n  int iVar3;\n  int **ppiVar4;\n  \n  do_nothing_with_pointer_00004274();\n  iVar3 = *(int *)PTR_DAT_00004398;\n  if (*(int *)(iVar3 + 0x18) == 0) {\n    FUNC_000042a4(iVar3);\n  }\n  ppiVar4 = (int **)(iVar3 + 0x48);\n  do {\n    piVar1 = ppiVar4[1];\n    piVar2 = ppiVar4[2];\n    while (piVar1 = (int *)((int)piVar1 + -1), -1 < (int)piVar1) {\n      if (*(short *)(piVar2 + 3) == 0) {\n        piVar2[3] = DAT_0000439c;\n        piVar2[0x19] = 0;\n        do_nothing_000045e4(piVar2 + 0x16);\n        do_nothing_with_pointer_00004280();\n        piVar2[1] = 0;\n        piVar2[2] = 0;\n        piVar2[4] = 0;\n        piVar2[5] = 0;\n        *piVar2 = 0;\n        piVar2[6] = 0;\n        fill_array_with_value_00004622(piVar2 + 0x17,0,8);\n        piVar2[0xd] = 0;\n        piVar2[0xe] = 0;\n        piVar2[0x12] = 0;\n        piVar2[0x13] = 0;\n        return piVar2;\n      }\n      piVar2 = piVar2 + 0x1a;\n    }\n    if (*ppiVar4 == (int *)0x0) {\n      piVar1 = (int *)allocate_and_initialize_array_00004248(param_1,4);\n      *ppiVar4 = piVar1;\n      if (piVar1 == (int *)0x0) {\n        do_nothing_with_pointer_00004280();\n        *param_1 = 0xc;\n        return (int *)0x0;\n      }\n    }\n    ppiVar4 = (int **)*ppiVar4;\n  } while( true );\n}\n\n"
        },
        "FUN_00004dc8": {
            "renaming": {
                "FUN_00004dc8": "find_first_non_matching_pointer_index_and_update_00004dc8",
                "param_1": "pointer_array",
                "param_2": "pointer_array_length",
                "iVar1": "first_non_matching_index",
                "bVar3": "non_matching_found",
                "uVar2": "updated_pointer_index"
            },
            "code": "void find_first_non_matching_pointer_index_and_update_00004dc8(uint32_t* pointer_array, uint32_t pointer_array_length, uint32_t* current_pointer_index) {\n  uint32_t first_non_matching_index = find_first_non_matching_pointer_index(pointer_array, (int)*(short *)(current_pointer_index + 0xe));\n  bool non_matching_found = (first_non_matching_index != pointer_array_length);\n  uint32_t updated_pointer_index = non_matching_found ? *(uint32_t *)(current_pointer_index + 0x54) + first_non_matching_index : *(ushort *)(current_pointer_index + 0xc) & 0xffffefff;\n  if (non_matching_found) {\n    *(uint32_t *)(current_pointer_index + 0x54) = updated_pointer_index;\n  }\n  if (!non_matching_found) {\n    *(short *)(current_pointer_index + 0xc) = (short)updated_pointer_index;\n  }\n}",
            "called": [
                "FUN_00000490"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dc8",
            "calling": [],
            "imported": false,
            "current_name": "find_first_non_matching_pointer_index_and_update_00004dc8"
        },
        "FUN_00005fd8": {
            "renaming": {
                "FUN_00005fd8": "parseUnsignedInt_00005fd8",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "*DAT_00005fe8": "data"
            },
            "code": "void parseUnsignedInt_00005fd8(unsigned int **DAT_00005fe8, unsigned int param1, unsigned int param2, unsigned int param3) {\n  parse_uint_00005edc(**DAT_00005fe8, param1, param2, param3);\n  return;\n}",
            "called": [
                "FUN_00005edc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd8",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "parseUnsignedInt_00005fd8"
        },
        "FUN_00005e10": {
            "renaming": {
                "FUN_00005e10": "read_byte_from_array_00005e10",
                "param_1": "array_address",
                "param_2": "array_pointer",
                "iVar1": "is_initialized",
                "uVar2": "byte_read",
                "pbVar3": "current_byte",
                "initialize_arrays_000042a4": "initialize_arrays",
                "process_data_00006768": "process_data"
            },
            "code": "uint read_byte_from_array_00005e10(int array_address, byte **array_pointer)\n{\n  int is_initialized = *(int *)(array_address + 0x18);\n  uint byte_read = 0xffffffff;\n  byte *current_byte = NULL;\n\n  if (array_address != 0 && is_initialized == 0)\n  {\n    initialize_arrays();\n  }\n\n  if (array_pointer == (byte **)PTR_DAT_00005e5c)\n  {\n    array_pointer = *(byte ***)(array_address + 4);\n  }\n  else if (array_pointer == (byte **)PTR_DAT_00005e60)\n  {\n    array_pointer = *(byte ***)(array_address + 8);\n  }\n  else if (array_pointer == (byte **)PTR_DAT_00005e64)\n  {\n    array_pointer = *(byte ***)(array_address + 0xc);\n  }\n\n  int process_result = process_data(array_address, array_pointer);\n\n  if (process_result == 0)\n  {\n    array_pointer[1] = array_pointer[1] - 1;\n    current_byte = *array_pointer;\n    *array_pointer = current_byte + 1;\n    byte_read = (uint)*current_byte;\n  }\n\n  return byte_read;\n}",
            "called": [
                "FUN_00006768",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e10",
            "calling": [
                "FUN_00004418"
            ],
            "imported": false,
            "current_name": "read_byte_from_array_00005e10"
        },
        "FUN_000033f4": {
            "renaming": {
                "FUN_000033f4": "parse_input_and_calculate_results_and_execute_000033f4",
                "param_1": "input",
                "iVar1": "result",
                "uVar2": "error_code",
                "auStack_2c": "data"
            },
            "code": "int parse_input_and_calculate_results_and_execute_000033f4(int input){\n    int result;\n    int error_code;\n    int data[9];\n    result = parse_input_and_calculate_results_0000328c(input, data);\n    if(result == 0){\n        error_code = execute_and_update_data_00002654(data,PTR_FUN_000031e0_1_0000343c,0);\n        if(error_code == -1){\n            FUNC_00004db8(PTR_s_rtc__error_setting_alarm_00003440);\n            return 1;\n        }\n        else{\n            return 0;\n        }\n    }\n    else{\n        return 1;\n    }\n}",
            "called": [
                "FUN_00002654",
                "FUN_00004db8",
                "FUN_0000328c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033f4",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "parse_input_and_calculate_results_and_execute_000033f4",
            "code_backup": "\nundefined4 FUN_000033f4(undefined4 param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_2c [36];\n  \n  iVar1 = parse_input_and_calculate_results_0000328c(param_1,auStack_2c);\n  if (iVar1 == 0) {\n    iVar1 = execute_and_update_data_00002654(auStack_2c,PTR_FUN_000031e0_1_0000343c,0);\n    if (iVar1 == -1) {\n      FUNC_00004db8(PTR_s_rtc__error_setting_alarm_00003440);\n      uVar2 = 1;\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n"
        },
        "FUN_0000443c": {
            "renaming": {
                "FUN_0000443c": "convert_seconds_to_date_time_0000443c",
                "param_1": "time_in_seconds",
                "param_2": "result_array",
                "iVar1": "days_since_1970",
                "uVar2": "seconds_since_midnight",
                "uVar3": "days_in_month",
                "uVar4": "leap_year_adjustment",
                "uVar5": "century_adjustment",
                "uVar6": "year",
                "uVar7": "month",
                "uVar8": "day_of_week",
                "bVar9": "is_negative",
                "temp": "temp",
                "temp2": "temp2",
                "temp3": "temp3",
                "temp4": "temp4",
                "temp5": "temp5",
                "temp6": "temp6",
                "temp7": "temp7",
                "temp8": "temp8",
                "temp9": "temp9",
                "temp10": "temp10",
                "temp11": "temp11",
                "temp12": "temp12",
                "temp13": "temp13",
                "temp14": "temp14",
                "temp15": "temp15",
                "temp16": "temp16",
                "temp17": "temp17",
                "temp18": "temp18",
                "temp19": "temp19",
                "temp20": "temp20",
                "temp21": "temp21",
                "temp22": "temp22",
                "temp23": "temp23",
                "temp24": "temp24",
                "temp25": "temp25",
                "temp26": "temp26",
                "temp27": "temp27",
                "temp28": "temp28",
                "temp29": "temp29",
                "temp30": "temp30"
            },
            "code": "uint *convert_seconds_to_date_time_0000443c(undefined4 *time_in_seconds, uint *result_array)\n{\n  int days_since_1970;\n  uint seconds_since_midnight;\n  uint leap_year_adjustment;\n  uint century_adjustment;\n  uint year;\n  uint month;\n  uint day;\n  uint day_of_week;\n  uint days_in_month;\n  uint temp;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  uint temp8;\n  uint temp9;\n  uint temp10;\n  uint temp11;\n  uint temp12;\n  uint temp13;\n  uint temp14;\n  uint temp15;\n  uint temp16;\n  uint temp17;\n  uint temp18;\n  uint temp19;\n  uint temp20;\n  uint temp21;\n  uint temp22;\n  uint temp23;\n  uint temp24;\n  uint temp25;\n  uint temp26;\n  uint temp27;\n  uint temp28;\n  uint temp29;\n  uint temp30;\n  \n  days_since_1970 = calculate_days_since_1970(*time_in_seconds, time_in_seconds[1], DAT_0000458c, 0);\n  days_in_month = DAT_0000458c;\n  calculate_days_since_1970(*time_in_seconds, time_in_seconds[1], DAT_0000458c, 0);\n  if (days_in_month < 0) {\n    days_in_month += 0x15180;\n  }\n  if (days_in_month < 0) {\n    seconds_since_midnight = days_since_1970 + 0xafa6b;\n  }\n  else {\n    seconds_since_midnight = days_since_1970 + 0xafa6c;\n  }\n  result_array[2] = days_in_month / 0xe10;\n  result_array[1] = (days_in_month % 0xe10) / 0x3c;\n  *result_array = (days_in_month % 0xe10) % 0x3c;\n  day_of_week = (seconds_since_midnight + 3) % 7;\n  temp = seconds_since_midnight;\n  if (temp < 0) {\n    temp -= 0x23ab0;\n  }\n  temp2 = DAT_00004594 * (temp / DAT_00004590) + seconds_since_midnight;\n  temp3 = ((temp2 / 0x8eac + temp2) - temp2 / 0x5b4) - temp2 / DAT_00004598;\n  temp4 = temp3 / 0x16d;\n  temp5 = (temp4 / 100 - temp3 / 0x5b4) + temp2 + temp4 * -0x16d;\n  temp6 = temp5 * 5 + 2;\n  temp7 = temp6 / 0x99;\n  if (temp6 < 0x5fa) {\n    temp8 = 2;\n  }\n  else {\n    temp8 = -10;\n  }\n  leap_year_adjustment = temp7 + temp8;\n  century_adjustment = (temp / DAT_00004590) * 400 + temp4;\n  if (leap_year_adjustment < 2) {\n    century_adjustment += 1;\n  }\n  if (temp5 < 0x132) {\n    if (((temp4 & 3) == 0) && (temp4 != (temp4 / 100) * 100)) {\n      temp9 = 1;\n    }\n    else {\n      temp9 = count_leading_zeroes(temp4 % 400);\n      temp9 = temp9 >> 5;\n    }\n    day = temp5 + 0x3b + temp9;\n  }\n  else {\n    day = temp5 - 0x132;\n  }\n  result_array[7] = day;\n  result_array[3] = (temp5 + 1) - (temp7 * 0x99 + 2) / 5;\n  result_array[4] = leap_year_adjustment;\n  result_array[5] = century_adjustment - 0x76c;\n  result_array[8] = 0;\n  return result_array;\n}",
            "called": [
                "FUN_00006974"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000443c",
            "calling": [
                "FUN_00002624",
                "FUN_00002690"
            ],
            "imported": false,
            "current_name": "convert_seconds_to_date_time_0000443c"
        },
        "FUN_000027b0": {
            "renaming": {
                "FUN_000027b0": "initialize_system_000027b0",
                "DAT_00002814": "system_data",
                "DAT_00002818": "system_address",
                "puVar1": "system_data",
                "flag_value": "flag_value",
                "set_flag_on_0000294c": "set_system_flag_on"
            },
            "code": "void initialize_system_000027b0(void)\n{\n  uint32_t *DAT_00002814 = DAT_00002814;\n  uint32_t *DAT_00002818 = DAT_00002818;\n  uint32_t flag_value = 0x20000000;\n\n  *(DAT_00002818 + 0x103c) |= flag_value;\n  DAT_00002814[4] = 1;\n  DAT_00002814[4] = 0;\n\n  if ((DAT_00002814[5] & 1) != 0) {\n    *DAT_00002814 = 0;\n  }\n\n  DAT_00002814[4] = 0x104;\n  DAT_00002814[2] = 0xffffff42;\n  DAT_00002814[7] = 0;\n\n  set_system_flag_on();\n  return;\n}",
            "called": [
                "FUN_0000294c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000027b0",
            "calling": [
                "FUN_000025f4"
            ],
            "imported": false,
            "current_name": "initialize_system_000027b0"
        },
        "FUN_00005ebc": {
            "renaming": {
                "FUN_00005ebc": "copy_string_00005ebc",
                "param_1": "destination",
                "param_2": "source",
                "cVar1": "current_character"
            },
            "code": "void copy_string_00005ebc(char *destination, char *source) {\n  char current_character;\n  do {\n    current_character = *source;\n    *destination = current_character;\n    source = source + 1;\n    destination = destination + 1;\n  } while (current_character != '\\0');\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ebc",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "copy_string_00005ebc"
        },
        "FUN_00006192": {
            "renaming": {
                "FUN_00006192": "update_node_00006192",
                "param_1": "data",
                "param_2": "node",
                "PTR_": "",
                "DAT_": "",
                "insert_node_00004b34": "insert_node"
            },
            "code": "int update_node_00006192(int data, int *node) {\n  int *last_node = (int*)node[13];\n  if (last_node != NULL && last_node != node + 17) {\n    insert_node();\n  }\n  node[1] = node[16];\n  node[13] = NULL;\n  if (node[16] != 0) {\n    *node = node[15];\n    return 0;\n  }\n  *node = node[4];\n  node[1] = 0;\n  *(unsigned short *)(node + 6) |= 0x20;\n  return -1;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006192",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "update_node_00006192"
        },
        "FUN_00001734": {
            "renaming": {
                "FUN_00001734": "initializeResult_00001734",
                "set_result_to_zero_00001710": "setAllElementsToZero",
                "DAT_00001744": "array"
            },
            "code": "void initializeResult_00001734(void)\n{\n  setAllElementsToZero(DAT_00001744,6);\n  return;\n}",
            "called": [
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001734",
            "calling": [
                "FUN_000019c0",
                "FUN_00001a18",
                "FUN_00001a3c"
            ],
            "imported": false,
            "current_name": "initializeResult_00001734"
        },
        "FUN_00000e14": {
            "renaming": {
                "FUN_00000e14": "find_first_non_matching_pointer_index_00000e14",
                "param_1": "ptr1",
                "param_2": "ptr2",
                "uVar1": "index",
                "DAT_00000e34": "pointer_list"
            },
            "code": "int find_first_non_matching_pointer_index_00000e14(void* DAT_00000e34, void* ptr1, void* ptr2){\n  int index = 0;\n  while (*(void**)(DAT_00000e34 + index) == ptr1 || *(void**)(DAT_00000e34 + index) == ptr2){\n    index++;\n  }\n  return index;\n}",
            "called": [
                "FUN_000012e2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e14",
            "calling": [
                "FUN_00000490"
            ],
            "imported": false,
            "current_name": "find_first_non_matching_pointer_index_00000e14"
        },
        "FUN_0000281c": {
            "renaming": {
                "FUN_0000281c": "find_first_matching_byte_0000281c",
                "local_10": "count",
                "local_c": "first_byte"
            },
            "code": "int find_first_matching_byte_0000281c(void)\n{\n  int count = 0;\n  int first_byte = *DAT_00002858;\n\n  while (count < 3 && *DAT_00002858 != first_byte)\n  {\n    count++;\n  }\n\n  return *DAT_00002858;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000281c",
            "calling": [
                "FUN_00002624"
            ],
            "imported": false,
            "current_name": "find_first_matching_byte_0000281c"
        },
        "FUN_00002270": {
            "renaming": {
                "FUN_00002270": "is_pointer_equal_00002270",
                "param_1": "pointer_address",
                "uVar1": "is_equal",
                "iVar2": "value_at_pointer",
                "bVar3": "is_equal"
            },
            "code": "bool is_pointer_equal_00002270(int pointer_address) {\n    int value_at_pointer = *(int *)(pointer_address + 0xc);\n    bool is_equal = *(int *)(pointer_address + 8) == value_at_pointer;\n    if (is_equal) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002270",
            "calling": [
                "FUN_0000231c"
            ],
            "imported": false,
            "current_name": "is_pointer_equal_00002270"
        },
        "FUN_00005780": {
            "renaming": {
                "FUN_00005780": "insert_node_to_list_00005780",
                "param_1": "value",
                "*DAT_0000578c": "head",
                "insert_node_00004b34": "insert_node"
            },
            "code": "void insert_node_to_list_00005780(int* *DAT_0000578c, int value){\n insert_node(*DAT_0000578c, value);\n return;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005780",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "insert_node_to_list_00005780"
        },
        "FUN_000020cc": {
            "renaming": {
                "FUN_000020cc": "check_and_execute_function_000020cc",
                "DAT_000020dc": "PTR_function_data",
                "check_and_execute_00002028": "check_and_execute"
            },
            "code": "void check_and_execute_function_000020cc(void)\n{\n  check_and_execute(DAT_000020dc,1);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020cc",
            "calling": [],
            "imported": false,
            "current_name": "check_and_execute_function_000020cc"
        },
        "FUN_00002396": {
            "renaming": {
                "FUN_00002396": "initialize_and_return_00002396",
                "initialize_system_and_return_000025f4": "initialize_system_and_return"
            },
            "code": "void initialize_and_return_00002396(void)\n{\n  initialize_system_and_return_000025f4();\n  return;\n}",
            "called": [
                "FUN_000025f4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002396",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "initialize_and_return_00002396"
        },
        "FUN_00004cb4": {
            "renaming": {
                "FUN_00004cb4": "process_input_00004cb4",
                "param_1": "input_byte",
                "puVar1": "data_array_ptr",
                "uVar2": "data_array_length",
                "puVar3": "data_ptr",
                "unaff_r4": "data_array_init_flag",
                "iVar4": "data_array_index",
                "unaff_r5": "unused_variable"
            },
            "code": "uint process_input_00004cb4(uint input_byte) {\n  uint* data_array_ptr;\n  uint data_array_length;\n  int data_array_init_flag;\n  uint processed_input = input_byte;\n  int data_array_index;\n  \n  data_array_index = *data_array_init_flag;\n  if ((data_array_index != 0) && (*(int *)(data_array_index + 0x18) == 0)) {\n    initialize_data_array(data_array_index);\n  }\n  data_array_ptr = *(uint **)(data_array_index + 8);\n  if ((data_array_index != 0) && (*(int *)(data_array_index + 0x18) == 0)) {\n    initialize_data_array(data_array_index);\n  }\n  if (data_array_ptr == (uint *)data_array_ptr_1) {\n    data_array_ptr = *(uint **)(data_array_index + 4);\n  }\n  else if (data_array_ptr == (uint *)data_array_ptr_2) {\n    data_array_ptr = *(uint **)(data_array_index + 8);\n  }\n  else if (data_array_ptr == (uint *)data_array_ptr_3) {\n    data_array_ptr = *(uint **)(data_array_index + 0xc);\n  }\n  \n  if ((-1 < (int)(data_array_ptr[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(data_array_ptr + 3) << 0x16))) {\n    do_nothing(data_array_ptr[0x16]);\n  }\n  data_array_length = data_array_ptr[2] - 1;\n  data_array_ptr[2] = data_array_length;\n  if (((int)data_array_length < 0) && (((int)data_array_length < (int)data_array_ptr[6] || (processed_input = input_byte & 0xff, processed_input == 10))))\n  {\n    processed_input = process_data(data_array_index, input_byte, data_array_ptr, processed_input);\n  }\n  else {\n    char* data_ptr = (char*)*data_array_ptr;\n    *data_array_ptr = data_ptr + 1;\n    *data_ptr = (char)input_byte;\n    processed_input = input_byte & 0xff;\n  }\n  if ((-1 < (int)(data_array_ptr[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(data_array_ptr + 3) << 0x16))) {\n    do_nothing(data_array_ptr[0x16]);\n  }\n  return processed_input;\n}",
            "called": [
                "FUN_00005404",
                "FUN_000045e8",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cb4",
            "calling": [
                "FUN_00002a00"
            ],
            "imported": false,
            "current_name": "process_input_00004cb4"
        },
        "FUN_00003478": {
            "renaming": {
                "FUN_00003478": "calculate_and_process_input_results_00003478",
                "param_1": "input",
                "iVar1": "parse_result",
                "uVar2": "result",
                "auStack_2c": "data",
                "parse_input_and_calculate_results_0000328c": "parse_input_and_calculate_results",
                "process_data_and_set_flag_00002600": "process_data_and_set_flag",
                "FUNC_00004db8": "print_error"
            },
            "code": "int calculate_and_process_input_results_00003478(undefined4 input)\n{\n  int parse_result;\n  undefined4 data[9];\n  parse_result = parse_input_and_calculate_results(input, data);\n  if (parse_result == 0) {\n    int process_result = process_data_and_set_flag(data);\n    if (process_result == -1) {\n      print_error(PTR_s_rtc__error_setting_time_000034bc);\n      return 1;\n    }\n    else {\n      return 0;\n    }\n  }\n  else {\n    return 1;\n  }\n}",
            "called": [
                "FUN_0000328c",
                "FUN_00002600",
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003478",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "calculate_and_process_input_results_00003478",
            "code_backup": "\nundefined4 FUN_00003478(undefined4 param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_2c [36];\n  \n  iVar1 = parse_input_and_calculate_results_0000328c(param_1,auStack_2c);\n  if (iVar1 == 0) {\n    iVar1 = process_data_and_set_flag_00002600(auStack_2c);\n    if (iVar1 == -1) {\n      FUNC_00004db8(PTR_s_rtc__error_setting_time_000034bc);\n      uVar2 = 1;\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = 1;\n  }\n  return uVar2;\n}\n\n"
        },
        "FUN_00002028": {
            "renaming": {
                "FUN_00002028": "check_and_execute_00002028",
                "param_1": "flag",
                "param_2": "data",
                "iVar1": "bit_position",
                "uVar2": "flag_mask",
                "local_c": "i"
            },
            "code": "void check_and_execute_00002028(uint32_t flag, uint32_t data) {\n  uint32_t flag_mask = *(uint32_t *)(flag + 0xa0);\n  for (uint32_t i = 0; i < 0x20; i++) {\n    if (((flag_mask & 1 << (i & 0xff)) != 0) && ((*(uint32_t *)(flag + i * 4) & 0xf0000) != 0)) {\n      *(uint32_t *)(flag + 0xa0) = 1 << (i & 0xff);\n      uint32_t bit_position = get_bits(data, i);\n      (**(void (**)(void))(PTR_DAT_000020b4 + bit_position * 0xc))(*(uint32_t *)(PTR_DAT_000020b4 + bit_position * 0xc + 4));\n    }\n  }\n  check_flag_status();\n}\n",
            "called": [
                "FUN_00001cf0",
                "FUN_00001e0c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002028",
            "calling": [
                "FUN_000020f4",
                "FUN_000020e0",
                "FUN_000020b8",
                "FUN_000020cc",
                "FUN_00002108"
            ],
            "imported": false,
            "current_name": "check_and_execute_00002028"
        },
        "FUN_000016c8": {
            "renaming": {
                "FUN_000016c8": "set_calculated_result_to_one_and_return_000016c8",
                "param_1": "input_parameter",
                "param_2": "unused_parameter",
                "puVar1": "integer_result_pointer",
                "calculate_result_00001696": "calculate_result",
                "*puVar1": "*integer_result_pointer"
            },
            "code": "void set_calculated_result_to_one_and_return_000016c8(void* result_pointer, undefined input_parameter)\n{\n  void* calculated_result_pointer = calculate_result(input_parameter);\n  int* integer_result_pointer = (int*)result_pointer;\n  *integer_result_pointer = 1;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016c8",
            "calling": [
                "FUN_000017dc"
            ],
            "imported": false,
            "current_name": "set_calculated_result_to_one_and_return_000016c8"
        },
        "FUN_00001a60": {
            "renaming": {
                "FUN_00001a60": "verify_data_transfer_complete_00001a60",
                "DAT_00001ac4": "status_register",
                "DAT_00001ac8": "control_register",
                "DAT_00001acc": "transfer_complete_register",
                "PTR_DAT_00001ad0": "transfer_length_register"
            },
            "code": "void verify_data_transfer_complete_00001a60(void)\n{\n    set_result_to_zero(DAT_00001ac4, 1);\n    *DAT_00001ac8 |= 0x80;\n    while ((DAT_00001ac4[6] & 0xc) != 8);\n    set_result_to_one(DAT_00001acc, 6);\n    while ((DAT_00001ac4[6] & 0x20) == 0);\n    while ((DAT_00001ac4[6] & 0x40) == 0);\n    *PTR_DAT_00001ad0 = 6;\n    return;\n}",
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a60",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "verify_data_transfer_complete_00001a60"
        },
        "FUN_0000099c": {
            "renaming": {
                "FUN_0000099c": "initialize_and_execute_0000099c",
                "uStack_18": "stackVar",
                "local_14": "stackPtr",
                "local_10": "dataPtr",
                "local_c": "relPtr",
                "initialize_data_and_memory_00000db0": "initialize_data_and_memory",
                "PTR_DAT_00000a18": "rel_array_ptr",
                "PTR_Elf32_Rel_ARRAY_00000a20": "rel_array",
                "PTR_DAT_00000a24": "rel_array_end",
                "DAT_00000a1c": "default_value",
                "PTR_DAT_00000a28": "zero_array_ptr",
                "DAT_00000a2c": "zero_array_end",
                "do_nothing_00000990": "do_nothing",
                "set_bits_and_execute_instructions_00000e64": "set_bits_and_execute_instructions",
                "executeFunctionsInPointers_0000459c": "execute_pointers",
                "allocate_and_initialize_memory_00000f8c": "allocate_and_initialize_memory"
            },
            "code": "void initialize_and_execute_0000099c(void)\n{\n  undefined4 stackVar;\n  undefined4 *stackPtr = &stackVar;\n  undefined4 *dataPtr = data_array;\n  initialize_data_and_memory_00000db0();\n  undefined4 *relPtr = PTR_Elf32_Rel_ARRAY_00000a20;\n  while (relPtr < &stackVar) {\n    *relPtr = DAT_00000a1c;\n    relPtr++;\n  }\n  relPtr = PTR_DAT_00000a18;\n  while (relPtr < PTR_DAT_00000a24) {\n    *relPtr = *dataPtr;\n    relPtr++;\n    dataPtr++;\n  }\n  undefined4 *zeroPtr = PTR_DAT_00000a28;\n  while (zeroPtr < DAT_00000a2c) {\n    *zeroPtr = 0;\n    zeroPtr++;\n  }\n  do_nothing_00000990();\n  set_bits_and_execute_instructions();\n  execute_pointers();\n  allocate_and_initialize_memory();\n  return;\n}",
            "called": [
                "FUN_00000f8c",
                "FUN_00000e64",
                "FUN_00000db0",
                "FUN_0000459c",
                "FUN_00000990"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000099c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_and_execute_0000099c"
        },
        "FUN_00002d94": {
            "renaming": {
                "FUN_00002d94": "process_input_and_return_00002d94",
                "param_1": "input_buffer",
                "param_2": "buffer_size",
                "iVar1": "read_byte",
                "bVar2": "is_start_of_buffer",
                "bVar3": "is_start_of_buffer",
                "local_c": "current_char",
                "read_byte_from_array_00004418": "read_byte_from_array"
            },
            "code": "uint process_input_and_return_00002d94(uint8_t *input_buffer, int buffer_size)\n{\n  int read_byte;\n  uint8_t *current_char;\n  bool is_start_of_buffer;\n  uint8_t *buffer_start = input_buffer;\n\n  current_char = input_buffer;\n  while (true) {\n    if (current_char - buffer_start >= buffer_size - 1) {\n      return 0xffffffff;\n    }\n    read_byte = read_byte_from_array();\n    if (read_byte < 0) break;\n    if (read_byte == 0xd || read_byte == 10) {\n      *current_char = 0;\n      process_input_and_return_00002d94(0xd);\n      process_input_and_return_00002d94(10);\n      is_start_of_buffer = current_char == buffer_start;\n      if (is_start_of_buffer) {\n        input_buffer = (uint8_t *)0x1;\n      }\n      return (uint)input_buffer;\n    }\n    if (read_byte == 8 || read_byte == 0x7f) {\n      if (current_char != buffer_start) {\n        current_char--;\n        *current_char = 0;\n        process_input_and_return_00002d94(8);\n        process_input_and_return_00002d94(0x20);\n        process_input_and_return_00002d94(8);\n      }\n    }\n    else {\n      *current_char = (char)read_byte;\n      process_input_and_return_00002d94(read_byte);\n      current_char++;\n    }\n  }\n  return 1;\n}",
            "called": [
                "FUN_00002a00",
                "FUN_00004418"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002d94",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "process_input_and_return_00002d94"
        },
        "FUN_00003918": {
            "renaming": {
                "FUN_00003918": "get_output_00003918",
                "param_1": "input",
                "uVar1": "output"
            },
            "code": "typedef enum { TWO = 2, THREE = 3, SIX = 6, NINE = 9, TWELVE = 12, FIFTEEN = 15, TWO_HUNDRED_FIFTY_THREE = 0xF1, TWO_HUNDRED_FIFTY_SIX = 0xF4, TWO_HUNDRED_FIFTY_SEVEN = 0xF7, TWO_HUNDRED_FIFTY_TEN = 0xFA, TWO_HUNDRED_FIFTY_THIRTEEN = 0xFD } input_t;\n\nuint8_t get_output_00003918(input_t input) {\n    uint8_t output = 0;\n    switch(input) {\n        case TWO:\n            output = 0x68;\n            break;\n        case THREE:\n            output = 0x6b;\n            break;\n        case SIX:\n            output = 0x4d;\n            break;\n        case NINE:\n            output = 0x47;\n            break;\n        case TWELVE:\n            output = 0x54;\n            break;\n        case FIFTEEN:\n            output = 0x50;\n            break;\n        case TWO_HUNDRED_FIFTY_THREE:\n            output = 0x66;\n            break;\n        case TWO_HUNDRED_FIFTY_SIX:\n            output = 0x70;\n            break;\n        case TWO_HUNDRED_FIFTY_SEVEN:\n            output = 0x6e;\n            break;\n        case TWO_HUNDRED_FIFTY_TEN:\n            output = 0x75;\n            break;\n        case TWO_HUNDRED_FIFTY_THIRTEEN:\n            output = 0x6d;\n            break;\n    }\n    return output;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003918",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "get_output_00003918"
        },
        "FUN_00003d64": {
            "renaming": {
                "FUN_00003d64": "execute_function_00003d64",
                "param_1": "function_pointer",
                "param_2": "arg1",
                "uVar1": "result"
            },
            "code": "int execute_function_00003d64(int function_pointer, int arg1)\n{\n  int result;\n  if (function_pointer == 0) {\n    result = -19;\n  }\n  else {\n    result = (***(int (**)(void))(function_pointer + 0xc))(*(int *)(function_pointer + 4), arg1);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d64",
            "calling": [
                "FUN_00002ecc"
            ],
            "imported": false,
            "current_name": "execute_function_00003d64"
        },
        "FUN_00004e52": {
            "renaming": {
                "FUN_00004e52": "compare_byte_arrays_00004e52",
                "param_1": "array1",
                "param_2": "array2",
                "uVar2": "index",
                "bVar1": "current_byte2",
                "bVar3": "arrays_match"
            },
            "code": "int compare_byte_arrays_00004e52(byte *array1, byte *array2) {\n  byte current_byte1;\n  byte current_byte2;\n  uint index = 0;\n  bool arrays_match = true;\n  \n  do {\n    current_byte1 = *array1;\n    current_byte2 = *array2;\n    if (current_byte1 != current_byte2) {\n      arrays_match = false;\n      break;\n    }\n    index++;\n    array1++;\n    array2++;\n  } while (current_byte1 != 0 && current_byte2 != 0);\n  \n  if (arrays_match) {\n    return 0;\n  } else if (current_byte1 == 0) {\n    return -1;\n  } else {\n    return 1;\n  }\n}",
            "called": [
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e52",
            "calling": [
                "FUN_00002b10",
                "FUN_00004e52",
                "FUN_00005100",
                "FUN_00002fe0",
                "FUN_0000316c",
                "FUN_00002a18"
            ],
            "imported": false,
            "current_name": "compare_byte_arrays_00004e52"
        },
        "FUN_000010d4": {
            "renaming": {
                "FUN_000010d4": "allocate_memory_000010d4",
                "param_1": "address",
                "param_2": "size",
                "param_3": "flags",
                "param_4": "param_4",
                "param_5": "param_5",
                "param_6": "param_6",
                "param_7": "param_7",
                "uVar1": "interrupts_enabled",
                "uVar2": "allocated_memory",
                "iVar3": "result",
                "uVar4": "calculated_size",
                "puVar5": "memory_address",
                "local_30": "remaining_size",
                "local_2c": "current_address",
                "local_10": "loop_counter",
                "local_c": "loop_counter_short",
                "local_a": "available_slot",
                "PTR_DAT_0000126c": "pointer_to_array",
                "PTR_DAT_00001270": "pointer_to_counter"
            },
            "code": "int allocate_memory_000010d4(uint address, int size, byte flags, uint param_4, undefined4 param_5, undefined4 param_6, undefined4 param_7)\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  int result;\n  uint uVar4;\n  undefined4 *memory_address;\n  int local_size;\n  uint local_address;\n  uint local_10;\n  short available_slot = 0;\n  short local_8;\n  if (flags < 0x10) {\n    local_size = size;\n    local_address = address;\n    if ((address & 3) != 0) {\n      local_size = 4 - (address & 3);\n      local_address = local_size + address;\n      local_size = size - local_size;\n    }\n    uVar4 = local_size - 0x30U & 0xfffffffc;\n    memory_address = (undefined4 *)(uVar4 + local_address);\n    if ((param_4 & 8) == 0) {\n      *(uint *)local_address = local_address;\n    }\n    else {\n      for (local_10 = local_address; local_10 < uVar4 + local_address; local_10 = local_10 + 4) {\n        *(uint *)local_10 = local_10;\n      }\n    }\n    uVar1 = check_interrupts_enabled();\n    for (local_8 = 1; local_8 < 0x21; local_8 = local_8 + 1) {\n      if (*(int *)(PTR_DAT_0000126c + local_8 * 4) == 0) {\n        available_slot = local_8;\n        break;\n      }\n    }\n    if (available_slot == 0) {\n      enable_irq_interrupts_if_privileged(uVar1);\n      result = -0x8b;\n    }\n    else {\n      *(undefined4 **)(PTR_DAT_0000126c + available_slot * 4) = memory_address;\n      *(short *)((int)memory_address + 6) = available_slot;\n      uVar2 = allocate_memory_000010d4_000007dc(param_5,param_6,local_address,uVar4);\n      *memory_address = uVar2;\n      memory_address[9] = local_address;\n      memory_address[0xb] = size;\n      memory_address[10] = param_7;\n      *(byte *)((int)memory_address + 5) = flags;\n      *(undefined *)(memory_address + 1) = 0;\n      memory_address[2] = 0;\n      memory_address[3] = 0;\n      memory_address[4] = 0;\n      initialize_array_and_set_length_to_power_of_two(memory_address + 5,0);\n      memory_address[8] = 0;\n      *(int *)PTR_DAT_00001270 = *(int *)PTR_DAT_00001270 + 1;\n      if ((param_4 & 1) == 0) {\n        update_or_remove_element(memory_address,10);\n        if ((param_4 & 4) == 0) {\n          enable_irq_interrupts_if_privileged(uVar1);\n          check_exception_and_set_flag_if_needed(flags);\n          return (int)available_slot;\n        }\n      }\n      else {\n        update_or_remove_element(memory_address,1);\n      }\n      enable_irq_interrupts_if_privileged(uVar1);\n      result = (int)available_slot;\n    }\n  }\n  else {\n    result = -0x16;\n  }\n  return result;\n}",
            "called": [
                "FUN_00000698",
                "FUN_00000fec",
                "FUN_00000d0c",
                "FUN_00000cd0",
                "FUN_00000738",
                "FUN_000007dc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010d4",
            "calling": [
                "FUN_00000f8c"
            ],
            "imported": false,
            "current_name": "allocate_memory_000010d4"
        },
        "FUN_000045e4": {
            "renaming": {
                "FUN_000045e4": "do_nothing_000045e4"
            },
            "code": "\nvoid do_nothing_000045e4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e4",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e4"
        },
        "FUN_00000738": {
            "renaming": {
                "FUN_00000738": "check_exception_and_set_flag_if_needed_00000738",
                "param_1": "exception_number",
                "iVar1": "current_exception_number",
                "get_current_exception_number_if_privileged_mode_00000d2a": "get_current_exception_number_if_privileged_mode",
                "set_flag_on_0000093c": "set_flag_on",
                "PTR_DAT_0000078c": "PTR_DAT_exception_data",
                "PTR_DAT_00000790": "PTR_DAT_flag"
            },
            "code": "void check_exception_and_set_flag_if_needed_00000738(ushort exception_number)\n{\n  int current_exception_number = get_current_exception_number_if_privileged_mode();\n  int max_exception_number = *(byte *)(*(int *)PTR_DAT_0000078c + 4);\n  int min_exception_number = *(byte *)(*(int *)PTR_DAT_0000078c + 5);\n  if (max_exception_number < 9 || exception_number < min_exception_number) {\n    if (current_exception_number == 0) {\n      set_flag_on();\n    }\n    else {\n      *(undefined4 *)PTR_DAT_00000790 = 1;\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00000d2a",
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000738",
            "calling": [
                "FUN_000010d4",
                "FUN_000024bc"
            ],
            "imported": false,
            "current_name": "check_exception_and_set_flag_if_needed_00000738"
        },
        "FUN_00003e58": {
            "renaming": {
                "FUN_00003e58": "count_digits_and_sign_00003e58",
                "param_1": "number",
                "param_2": "length",
                "iVar1": "digits_count",
                "local_18": "sign",
                "local_14": "current_digit"
            },
            "code": "int count_digits_and_sign_00003e58(int *number, int length)\n{\n    int sign = 1;\n    int digits_count;\n    int *current_digit = number;\n\n    if (length < 0)\n    {\n        sign = -1;\n        length = -length;\n    }\n\n    if (number != NULL && sign == -1)\n    {\n        *number = '-';\n        current_digit++;\n    }\n\n    digits_count = count_digits(current_digit, length);\n\n    return sign * (digits_count + (number != NULL));\n}",
            "called": [
                "FUN_00003dc4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e58",
            "calling": [
                "FUN_00003ec4"
            ],
            "imported": false,
            "current_name": "count_digits_and_sign_00003e58"
        },
        "FUN_00004e26": {
            "renaming": {
                "FUN_00004e26": "set_param_and_update_status_00004e26",
                "param_1": "device_id",
                "param_2": "param_address",
                "iVar1": "status",
                "uVar2": "current_status",
                "bVar3": "is_status_negative"
            },
            "code": "void set_param_and_update_status_00004e26(int device_id, int param_address)\n{\n  int status;\n  ushort current_status;\n  bool is_status_negative;\n\n  status = set_param_to_19_000004f2(device_id, (int)*(short *)(param_address + 0xe));\n  is_status_negative = status == -1;\n\n  if (is_status_negative) {\n    current_status = *(ushort *)(param_address + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(param_address + 0x54) = status;\n    current_status = *(ushort *)(param_address + 0xc) | 0x1000;\n  }\n\n  *(ushort *)(param_address + 0xc) = current_status;\n}",
            "called": [
                "FUN_000004f2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e26",
            "calling": [],
            "imported": false,
            "current_name": "set_param_and_update_status_00004e26"
        },
        "FUN_000045e8": {
            "renaming": {
                "FUN_000045e8": "do_nothing_000045e8"
            },
            "code": "\nvoid do_nothing_000045e8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e8",
            "calling": [
                "FUN_000057f8",
                "FUN_00005fec",
                "FUN_00004db8",
                "FUN_00005790",
                "FUN_00004274",
                "FUN_0000428c",
                "FUN_00004158",
                "FUN_00004418",
                "FUN_00004cb4"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e8"
        },
        "FUN_000057f8": {
            "renaming": {
                "FUN_000057f8": "FUNC_000057f8"
            },
            "code": "\nint FUNC_000057f8(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  int iVar4;\n  int *piVar5;\n  bool bVar6;\n  byte *pbVar7;\n  int unaff_r7;\n  byte *pbVar8;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 uStack_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    initialize_arrays_000042a4();\n  }\n  if (param_2 == PTR_DAT_00005a38) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR_DAT_00005a3c) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR_DAT_00005a40) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n     (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n    do_nothing_000045e8(*(undefined4 *)(param_2 + 0x58));\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar3 = process_data_000054a8(param_1,param_2), iVar3 != 0)) {\n    if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n       (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n      do_nothing_000045ec(*(undefined4 *)(param_2 + 0x58));\n    }\n    return -1;\n  }\n  puVar1 = PTR_s___0__00005a44;\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar8 = param_3;\n  local_8c = param_4;\nLAB_0000588e:\n  pbVar7 = pbVar8;\n  if (*pbVar7 != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  pbVar8 = pbVar7 + 1;\n  if (*pbVar7 != 0x25) goto LAB_0000588e;\nLAB_0000589a:\n  iVar3 = (int)pbVar7 - (int)param_3;\n  if (iVar3 != 0) {\n    iVar4 = process_input_and_return_result_000057d2(param_1,param_2,param_3,iVar3);\n    if (iVar4 == -1) {\nLAB_00005a06:\n      if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n         (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n        do_nothing_000045ec(*(undefined4 *)(param_2 + 0x58));\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar3;\n  }\n  if (*pbVar7 == 0) goto LAB_00005a06;\n  local_84 = -1;\n  uStack_80 = 0;\n  local_88 = 0;\n  local_7c = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar8 = pbVar7 + 1;\n  while( true ) {\n    pbVar7 = pbVar8 + 1;\n    iVar3 = find_byte_sequence_00006010(PTR_s___0__00005a44,*pbVar8,5);\n    puVar2 = PTR_DAT_00005a54;\n    if (iVar3 == 0) break;\n    local_88 = 1 << (iVar3 - (int)puVar1 & 0xffU) | local_88;\n    pbVar8 = pbVar7;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar8 == 0x2a) {\n    piVar5 = local_8c + 1;\n    local_7c = *local_8c;\n    local_8c = piVar5;\n    if (local_7c < 0) {\n      local_7c = -local_7c;\n      local_88 = local_88 | 2;\n    }\n  }\n  else {\n    bVar6 = false;\n    iVar3 = local_7c;\n    pbVar7 = pbVar8;\n    while( true ) {\n      if (9 < *pbVar7 - 0x30) break;\n      iVar3 = iVar3 * 10 + (*pbVar7 - 0x30);\n      bVar6 = true;\n      pbVar7 = pbVar7 + 1;\n    }\n    if (bVar6) {\n      local_7c = iVar3;\n    }\n  }\n  if (*pbVar7 == 0x2e) {\n    if (pbVar7[1] == 0x2a) {\n      local_84 = *local_8c;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n      pbVar7 = pbVar7 + 2;\n      local_8c = local_8c + 1;\n    }\n    else {\n      bVar6 = false;\n      local_84 = 0;\n      iVar3 = 0;\n      while( true ) {\n        pbVar7 = pbVar7 + 1;\n        if (9 < *pbVar7 - 0x30) break;\n        iVar3 = iVar3 * 10 + (*pbVar7 - 0x30);\n        bVar6 = true;\n      }\n      if (bVar6) {\n        local_84 = iVar3;\n      }\n    }\n  }\n  iVar3 = find_byte_sequence_00006010(PTR_DAT_00005a54,*pbVar7,3);\n  if (iVar3 != 0) {\n    local_88 = local_88 | 0x40 << (iVar3 - (int)puVar2 & 0xffU);\n    pbVar7 = pbVar7 + 1;\n  }\n  param_3 = pbVar7 + 1;\n  local_70 = *pbVar7;\n  iVar3 = find_byte_sequence_00006010(PTR_s_efgEFG_00005a48,local_70,6);\n  if (iVar3 == 0) {\n    iVar3 = FUNC_00005b34(param_1,&local_88,param_2,DAT_00005a50,&local_8c);\n  }\n  else {\n    iVar3 = param_1;\n    if (DAT_00005a4c == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar3 = unaff_r7;\n      goto LAB_000059b4;\n    }\n  }\n  if (iVar3 == -1) goto LAB_00005a06;\nLAB_000059b4:\n  local_74 = local_74 + iVar3;\n  pbVar8 = param_3;\n  unaff_r7 = iVar3;\n  goto LAB_0000588e;\n}\n\n",
            "called": [
                "FUN_00005b34",
                "FUN_00006010",
                "FUN_000045e8",
                "FUN_000054a8",
                "FUN_000045ec",
                "FUN_000042a4",
                "FUN_000057d2"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000057f8",
            "calling": [
                "FUN_00004c84"
            ],
            "imported": false,
            "current_name": "FUNC_000057f8"
        },
        "FUN_000018bc": {
            "renaming": {
                "FUN_000018bc": "set_default_parameters_000018bc",
                "DAT_00001910": "status_register",
                "DAT_00001914": "result_register",
                "DAT_00001918": "result_pointer",
                "set_param_1_00001748": "set_parameter_1",
                "set_result_to_zero_00001710": "set_result_to_zero"
            },
            "code": "void set_default_parameters_000018bc(void)\n{\n    set_parameter_1(160);\n    *DAT_00001910 = (*DAT_00001910 & 59) | 4;\n    set_result_to_zero(DAT_00001914, 1);\n    do {\n    } while ((DAT_00001910[6] & 16) == 0);\n    do {\n    } while ((DAT_00001910[6] & 12) != 0);\n    *DAT_00001918 = 0;\n    return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000018bc",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "set_default_parameters_000018bc"
        },
        "FUN_00000f04": {
            "renaming": {
                "FUN_00000f04": "initialize_and_execute_00000f04",
                "param_1": "input_char",
                "param_2": "input_int",
                "uStack_18": "temp_int",
                "UNRECOVERED_JUMPTABLE": "jump_table",
                "local_10": "temp_int",
                "local_9": "temp_char"
            },
            "code": "void initialize_and_execute_00000f04(char input_char, int input_int) {\n  int flag = *flag_ptr;\n  code *jump_table;\n  int temp_int;\n  char temp_char;\n  \n  temp_int = input_int;\n  temp_char = input_char;\n  if (flag == 0) {\n    *flag_ptr = 1;\n    if (input_char == '\\x03') {\n      execute_function_with_pointer();\n    }\n    initialize_data(uRam00000f50, temp_int);\n    print_relocation_info();\n    initialize_data(uRam00000f54);\n    initialize_data(uRam00000f58);\n  }\n  check_interrupts_enabled();\n  do_nothing();\n  jump_table = (code *)0xf4d;\n  wait_for_interrupt();\n  temp_int = (int)&temp_int + 1;\n  do_nothing();\n  initialize_data(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n  execute_commands();\n  (*jump_table)(0);\n  return;\n}",
            "called": [
                "FUN_00004c84",
                "FUN_0000211c",
                "FUN_00002400",
                "FUN_00000ed8",
                "FUN_00000ef8",
                "FUN_00000cd0",
                "FUN_000023a4",
                "FUN_00000e58"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f04",
            "calling": [
                "FUN_000013b8",
                "FUN_00003ec4",
                "FUN_00000cc0",
                "FUN_00000fec",
                "FUN_00001034",
                "FUN_00000a30"
            ],
            "imported": false,
            "current_name": "initialize_and_execute_00000f04"
        },
        "FUN_00000610": {
            "renaming": {
                "FUN_00000610": "count_leading_zeros_00000610",
                "iVar1": "index",
                "iVar2": "value",
                "uVar3": "result",
                "PTR_DAT_00000684": "PTR_DATA_START",
                "PTR_DAT_00000688": "PTR_DATA_VALUE",
                "PTR_DAT_0000068c": "PTR_DATA_ADDRESS",
                "PTR_DAT_00000690": "PTR_DATA_TABLE",
                "PTR_DAT_00000694": "PTR_DATA_TEMP"
            },
            "code": "int count_leading_zeros_00000610(void)\n{\n  int index;\n  int value;\n  int result = 0;\n  *(int*)PTR_DAT_00000684 = 0;\n  value = *(int*)PTR_DAT_00000688;\n  index = get_leading_zero_bits_count(*(int*)PTR_DAT_0000068c);\n  index = **(int **)(PTR_DAT_00000690 + index * 4);\n  if (value == index + -8) {\n    result = 0;\n  }\n  else {\n    if ((value != 0) && (*(char *)(value + 4) == '\t')) {\n      *(char *)(value + 4) = '\n';\n    }\n    *(char *)(index + -4) = '\t';\n    *(short *)PTR_DAT_00000694 = *(short *)(index + -2);\n    *(int *)PTR_DAT_00000688 = index + -8;\n    result = 1;\n  }\n  return result;\n}",
            "called": [
                "FUN_00000566"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000610",
            "calling": [],
            "imported": false,
            "current_name": "count_leading_zeros_00000610"
        },
        "FUN_00003694": {
            "renaming": {
                "FUN_00003694": "display_data_object_00003694",
                "param_1": "data_object_address",
                "param_2": "data_object_size",
                "uVar1": "data_object_label",
                "cVar2": "output_type",
                "uVar3": "bit_mask",
                "bVar4": "is_bit_set",
                "auStack_18": "stack_buffer",
                "local_10": "string_length",
                "local_a": "output_value",
                "local_9": "data_object_index"
            },
            "code": "void display_data_object_00003694(int data_object_address, byte data_object_size) {\n  undefined4 data_object_label;\n  char output_type;\n  uint bit_mask;\n  bool is_bit_set;\n  undefined stack_buffer[8];\n  int string_length;\n  char output_value;\n  byte data_object_index;\n  if ((data_object_address == 0) || (data_object_size > 3)) {\n    print_error_message(\"Unable to display data object\\n\");\n  }\n  else {\n    initialize_data_object_label(\"Data: \");\n    for (data_object_index = 0; data_object_index < data_object_size; data_object_index++) {\n      if (*(byte *)(data_object_address + 6) < 0x14) {\n        bit_mask = 1 << (uint)*(byte *)(data_object_address + 6);\n        is_bit_set = (bit_mask & DAT_000037ec) != 0;\n        output_type = is_bit_set ? (char)1 : (char)0;\n        if (output_type == 0) {\n          continue;\n        }\n        output_value = 0;\n      }\n      else {\n        output_value = get_output_value((int)*(char *)(data_object_address + 7));\n      }\n      initialize_data_object_label(\"[ \");\n      if (data_object_size < 2) {\n        initialize_data_object_label(\" ]\");\n      }\n      else {\n        initialize_data_object_label(\"[\", (int)data_object_index);\n      }\n      if (output_value == 0) {\n        if (*(char *)(data_object_address + 7) == 0) {\n          initialize_data_object_label((int)*(short *)(data_object_address + (uint)data_object_index * 2));\n        }\n        else if ((*(char *)(data_object_address + 7) + 4 < 0 == SCARRY4((int)*(char *)(data_object_address + 7),4)) && (*(char *)(data_object_address + 7) < 0)) {\n          string_length = convert_to_string(stack_buffer, (int)*(short *)(data_object_address + (uint)data_object_index * 2), (int)*(char *)(data_object_address + 7));\n          stack_buffer[string_length] = 0;\n          initialize_data_object_label(stack_buffer);\n        }\n        else {\n          initialize_data_object_label((int)*(short *)(data_object_address + (uint)data_object_index * 2), (int)*(char *)(data_object_address + 7));\n        }\n      }\n      else {\n        initialize_data_object_label((int)*(short *)(data_object_address + (uint)data_object_index * 2), output_value);\n      }\n      data_object_label = get_label_for_parameter_value(*(undefined *)(data_object_address + 6));\n      initialize_data_object_label(data_object_label);\n    }\n  }\n}",
            "called": [
                "FUN_00004c84",
                "FUN_00004db8",
                "FUN_00003e9e",
                "FUN_00003918",
                "FUN_00003810"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003694",
            "calling": [
                "FUN_0000305c",
                "FUN_00002ecc"
            ],
            "imported": false,
            "current_name": "display_data_object_00003694"
        },
        "FUN_00002364": {
            "renaming": {
                "FUN_00002364": "update_array_00002364",
                "param_1": "array",
                "param_2": "value",
                "iVar1": "is_equal",
                "uVar2": "return_value",
                "is_difference_equal_to_third_parameter_00002294": "is_difference_equal",
                "increment_and_set_value_at_offset_000022be": "update_array"
            },
            "code": "int update_array_00002364(int* array) {\n    int difference = array[1] - array[0];\n    if (difference == array[2]) {\n        return 1;\n    }\n    return 0;\n}\n\n\nunsigned int update_array_00002364(int* array, int value) {\n    if (update_array_00002364(array) == 0) {\n        array[3] = value;\n        array[2]++;\n        return 0;\n    }\n    return 0xffffffff;\n}",
            "called": [
                "FUN_000022be",
                "FUN_00002294"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002364",
            "calling": [
                "FUN_000012b4"
            ],
            "imported": false,
            "current_name": "update_array_00002364"
        },
        "FUN_00001ad4": {
            "renaming": {
                "FUN_00001ad4": "clear_bitmask_and_wait_until_condition_met_00001ad4",
                "DAT_00001b08": "bitmask",
                "PTR_DAT_00001b0c": "ptr"
            },
            "code": "void clear_bitmask_and_wait_until_condition_met_00001ad4(void)\n{\n  unsigned char* DAT_00001b08 = DAT_00001b08;\n  unsigned char condition_mask = 0xc;\n  unsigned char* PTR_DAT_00001b0c = PTR_DAT_00001b0c;\n  *DAT_00001b08 &= 0x3f;\n  while ((*DAT_00001b08 & condition_mask) != condition_mask);\n  *PTR_DAT_00001b0c = 7;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ad4",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "clear_bitmask_and_wait_until_condition_met_00001ad4"
        },
        "FUN_00001274": {
            "renaming": {
                "FUN_00001274": "initialize_and_execute_instructions_00001274",
                "initialize_data_0000258c": "initialize_data",
                "DAT_00001298": "data_pointer",
                "calculate_result_and_execute_instructions_00001c84": "calculate_result_and_execute_instructions",
                "initialize_and_return_00002396": "initialize_and_return"
            },
            "code": "void initialize_and_execute_instructions_00001274(void)\n{\n  initialize_data();\n  *DAT_00001298 = *DAT_00001298 | 0x28;\n  calculate_result_and_execute_instructions();\n  initialize_and_return();\n  return;\n}",
            "called": [
                "FUN_0000258c",
                "FUN_00001c84",
                "FUN_00002396"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001274",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "initialize_and_execute_instructions_00001274"
        },
        "FUN_00002e6c": {
            "renaming": {
                "FUN_00002e6c": "process_input_and_execute_commands_00002e6c",
                "param_1": "command",
                "param_2": "data",
                "param_3": "input",
                "iVar1": "return_code",
                "process_input_and_data_00002e48": "process_input_and_data",
                "process_input_and_return_00002d94": "process_input_and_return",
                "parse_commands_and_execute_00002b10": "parse_commands_and_execute"
            },
            "code": "void process_input_and_execute_commands_00002e6c(int command, int data, int input) {\n  int return_code;\n  process_input_and_data();\n  do {\n    return_code = process_input_and_return(data, input);\n    if (return_code == 0) {\n      parse_commands_and_execute(command, data);\n    }\n    process_input_and_data();\n  } while(true);\n}",
            "called": [
                "FUN_00002d94",
                "FUN_00002b10",
                "FUN_00002e48"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e6c",
            "calling": [
                "FUN_000023a4"
            ],
            "imported": false,
            "current_name": "process_input_and_execute_commands_00002e6c"
        },
        "FUN_00003444": {
            "renaming": {
                "FUN_00003444": "is_time_conversion_successful_00003444",
                "iVar1": "conversion_result",
                "auStack_2c": "time_data",
                "convert_seconds_to_date_time_00002624": "convert_seconds_to_date_time",
                "FUNC_00004db8": "log_error",
                "PTR_s_rtc__error_getting_time_00003474": "error_message",
                "calculate_result_00003378": "calculate_result"
            },
            "code": "bool is_time_conversion_successful_00003444(void)\n{\n  int conversion_result;\n  undefined time_data[36];\n  \n  conversion_result = convert_seconds_to_date_time(time_data);\n  if (conversion_result != 0) {\n    FUNC_00004db8(PTR_s_rtc__error_getting_time_00003474);\n  }\n  else {\n    calculate_result(time_data);\n  }\n  return conversion_result != 0;\n}",
            "called": [
                "FUN_00003378",
                "FUN_00004db8",
                "FUN_00002624"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003444",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "is_time_conversion_successful_00003444",
            "code_backup": "\nbool FUN_00003444(void)\n\n{\n  int iVar1;\n  undefined auStack_2c [36];\n  \n  iVar1 = convert_seconds_to_date_time_00002624(auStack_2c);\n  if (iVar1 != 0) {\n    FUNC_00004db8(PTR_s_rtc__error_getting_time_00003474);\n  }\n  else {\n    calculate_result_00003378(auStack_2c);\n  }\n  return iVar1 != 0;\n}\n\n"
        },
        "FUN_00003688": {
            "renaming": {
                "FUN_00003688": "synchronize_data_00003688",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void synchronize_data_00003688() {\n    synchronize_data_00003688_00003658();\n    return;\n}",
            "called": [
                "FUN_00003658"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003688",
            "calling": [
                "FUN_00002e9c"
            ],
            "imported": false,
            "current_name": "synchronize_data_00003688"
        },
        "FUN_00001392": {
            "renaming": {
                "FUN_00001392": "set_calculated_address_to_one_00001392",
                "param_1": "address",
                "param_2": "value",
                "puVar1": "calculated_address"
            },
            "code": "void set_calculated_address_to_one_00001392(undefined4 address, undefined value)\n{\n  undefined4 *calculated_address = (undefined4 *)calculate_address_00001360(address, value);\n  *calculated_address = 1;\n  return;\n}",
            "called": [
                "FUN_00001360"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001392",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "set_calculated_address_to_one_00001392"
        },
        "FUN_00002910": {
            "renaming": {
                "FUN_00002910": "clear_flags_00002910",
                "DAT_00002944": "data_address",
                "PTR_DAT_00002948": "flag_pointer",
                "iVar1": "data_address",
                "*(uint *)(DAT_00002944 + 0x1c)": "flag_address",
                "*(undefined4 *)(iVar1 + 8)": "data_pointer",
                "*(undefined4 *)PTR_DAT_00002948": "flag_pointer_value1",
                "*(undefined4 *)(PTR_DAT_00002948 + 4)": "flag_pointer_value2"
            },
            "code": "void clear_flags_00002910(void)\n{\n  int DAT_00002944 = DAT_00002944;\n  uint* *(uint *)(DAT_00002944 + 0x1c) = (uint*)(DAT_00002944 + 0x1c);\n  **(uint *)(DAT_00002944 + 0x1c) &= 0xfffffffb;\n  *(undefined4 *)(DAT_00002944 + 8) = 0;\n  *(undefined4 *)PTR_DAT_00002948 = 0;\n  *(undefined4 *)(PTR_DAT_00002948 + 4) = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002910",
            "calling": [
                "FUN_000026c0"
            ],
            "imported": false,
            "current_name": "clear_flags_00002910"
        },
        "FUN_00004418": {
            "renaming": {
                "FUN_00004418": "read_byte_from_array_00004418",
                "uVar1": "byteValue",
                "ppbVar2": "bytePointerArray",
                "pbVar3": "bytePointer",
                "iVar4": "arrayIndex",
                "initialize_arrays_000042a4": "initialize_arrays",
                "PTR_DAT_00005620": "arrayPointerOne",
                "PTR_DAT_00005624": "arrayPointerTwo",
                "PTR_DAT_00005628": "arrayPointerThree",
                "read_byte_from_array_00005e10": "read_byte_from_array"
            },
            "code": "uint read_byte_from_array_00004418(void)\n{\n  uint byteValue;\n  byte ** bytePointerArray;\n  byte * bytePointer;\n  int arrayIndex = *arrayPointer;\n  if ((arrayIndex != 0) && (*(int *)(arrayIndex + 0x18) == 0)) {\n    initialize_arrays(arrayIndex);\n  }\n  bytePointerArray = *(byte ***)(arrayIndex + 4);\n  if ((arrayIndex != 0) && (*(int *)(arrayIndex + 0x18) == 0)) {\n    initialize_arrays(arrayIndex);\n  }\n  if (bytePointerArray == (byte **)PTR_DAT_00005620) {\n    bytePointerArray = *(byte ***)(arrayIndex + 4);\n  }\n  else if (bytePointerArray == (byte **)PTR_DAT_00005624) {\n    bytePointerArray = *(byte ***)(arrayIndex + 8);\n  }\n  else if (bytePointerArray == (byte **)PTR_DAT_00005628) {\n    bytePointerArray = *(byte ***)(arrayIndex + 0xc);\n  }\n  if ((-1 < (int)bytePointerArray[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(bytePointerArray + 3) << 0x16))) {\n    do_nothing(bytePointerArray[0x16]);\n  }\n  bytePointer = bytePointerArray[1];\n  bytePointerArray[1] = bytePointer - 1;\n  if ((int)(bytePointer - 1) < 0) {\n    byteValue = read_byte_from_array_00004418(arrayIndex,bytePointerArray);\n  }\n  else {\n    bytePointer = *bytePointerArray;\n    *bytePointerArray = bytePointer + 1;\n    byteValue = (uint)*bytePointer;\n  }\n  if ((-1 < (int)bytePointerArray[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(bytePointerArray + 3) << 0x16))) {\n    do_nothing(bytePointerArray[0x16]);\n  }\n  return byteValue;\n}\n",
            "called": [
                "FUN_000045e8",
                "FUN_00005e10",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004418",
            "calling": [
                "FUN_00002d94"
            ],
            "imported": false,
            "current_name": "read_byte_from_array_00004418"
        },
        "FUN_0000258c": {
            "renaming": {
                "FUN_0000258c": "initialize_data_0000258c",
                "local_c": "current_byte",
                "decode_byte_and_store_00002538": "decode_and_store_byte"
            },
            "code": "void initialize_data_0000258c(void)\n{\n  uint8_t current_byte;\n  *(uint32_t *)(DAT_000025ec + 8) = DAT_000025f0;\n  decode_and_store_byte(0xfffffffe, 1);\n  decode_and_store_byte(0xfffffffb, 1);\n  for (current_byte = 0; current_byte < 0x66; current_byte++) {\n    decode_and_store_byte((int)(char)current_byte, 1);\n  }\n  *(uint32_t *)(DAT_000025ec + 0x10) |= 0x10;\n  *(uint32_t *)(DAT_000025ec + 0x14) |= 0x200;\n  return;\n}",
            "called": [
                "FUN_00002538"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000258c",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "initialize_data_0000258c"
        },
        "FUN_00002a00": {
            "renaming": {
                "FUN_00002a00": "process_input_and_return_00002a00",
                "param_1": "input"
            },
            "code": "void process_input_and_return_00002a00(undefined4 input){\n  process_input_00004cb4(input);\n  return;\n}",
            "called": [
                "FUN_00004cb4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a00",
            "calling": [
                "FUN_00002d94",
                "FUN_00002e48"
            ],
            "imported": false,
            "current_name": "process_input_and_return_00002a00"
        },
        "FUN_000043a0": {
            "renaming": {
                "FUN_000043a0": "find_and_execute_functions_with_conditions_000043a0",
                "param_1": "base_address",
                "param_2": "function_pointer",
                "piVar2": "pointer_to_functions",
                "iVar3": "function_address",
                "uVar4": "result",
                "iVar5": "function_count",
                "uVar1": "function_result"
            },
            "code": "uint find_and_execute_functions_with_conditions_000043a0(int base_address, code *function_pointer) {\n  uint result = 0;\n  int *pointer_to_functions = (int *)(base_address + 0x48);\n  do {\n    int function_address = pointer_to_functions[2];\n    int function_count = pointer_to_functions[1];\n    while (function_count = function_count - 1, function_count >= 0) {\n      if ((*(ushort *)(function_address + 0xc) > 1) && (*(short *)(function_address + 0xe) != -1)) {\n        uint function_result = (*function_pointer)(function_address);\n        result = result | function_result;\n      }\n      function_address += 0x68;\n    }\n    pointer_to_functions = (int *)*pointer_to_functions;\n  } while (pointer_to_functions != (int *)0x0);\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043a0",
            "calling": [
                "FUN_00006768"
            ],
            "imported": false,
            "current_name": "find_and_execute_functions_with_conditions_000043a0"
        },
        "FUN_0000211c": {
            "renaming": {
                "FUN_0000211c": "print_relocation_info_0000211c",
                "local_40": "relocation_array_ptr",
                "local_3c": "symbol_index",
                "local_38": "section_offset",
                "local_34": "symbol_value",
                "local_30": "relocation_type",
                "local_2c": "relocation",
                "local_28": "main_stack_pointer",
                "local_24": "pointer_data",
                "local_20": "relocation_count",
                "local_1a": "i",
                "local_18": "total_relocation_size",
                "local_14": "total_relocation_distance",
                "FUNC_00004c84": "print_relocation",
                "PTR_s__pid_____21s____9sQ___pri___stac_00002250": "relocation_info_format_string",
                "PTR_DAT_0000224c": "relocation_info_pid",
                "PTR_s_state_00002248": "relocation_info_state",
                "PTR_s______isr_stack______________6i___00002254": "main_stack_info_format_string",
                "DAT_0000225c": "relocation_type_array",
                "PTR_s___3hi_____20s_____8s___1s____3i___00002260": "relocation_format_string",
                "PTR_s___5s___21s__13s_6s__6i___5i__0000226c": "relocation_summary_format_string",
                "PTR_DAT_00002264": "relocation_summary_pid",
                "PTR_DAT_00002268": "relocation_summary_state",
                "calculate_distance_000010a0": "calculate_distance"
            },
            "code": "void print_relocation_info_0000211c()\n{\n  int relocation_count;\n  int total_relocation_distance = 0;\n  int total_relocation_size = 0;\n  uint32_t relocation_type;\n  uint32_t relocation_offset;\n  uint32_t symbol_index;\n  uint32_t symbol_value;\n  uint32_t section_index;\n  uint32_t section_offset;\n  for (int i = 1; i < 0x21; i++) {\n    uint32_t* relocation = *(uint32_t**)(relocation_array_ptr + i * 4);\n    if (relocation != NULL) {\n      relocation_type = (uint32_t)*(uint8_t*)(relocation + 1);\n      symbol_index = relocation[11];\n      symbol_value = relocation[9];\n      section_index = relocation[10];\n      section_offset = relocation[0];\n      relocation_offset = section_offset - calculate_distance(symbol_value);\n      total_relocation_distance += relocation_offset;\n      total_relocation_size += symbol_index;\n      print_relocation(relocation_type, symbol_index, symbol_value, section_index, section_offset, relocation_offset, relocation[0]);\n    }\n  }\n  print_summary(total_relocation_size, total_relocation_distance);\n}\n",
            "called": [
                "FUN_00004c84",
                "FUN_000008b8",
                "FUN_00000900",
                "FUN_000010a0",
                "FUN_0000091c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000211c",
            "calling": [
                "FUN_00000f04",
                "FUN_00002eb4"
            ],
            "imported": false,
            "current_name": "print_relocation_info_0000211c",
            "code_backup": "\nvoid FUN_0000211c(void)\n\n{\n  int iVar1;\n  undefined2 local_40;\n  int local_3c;\n  int local_38;\n  undefined4 local_34;\n  uint local_30;\n  undefined4 *local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  int local_20;\n  short local_1a;\n  int local_18;\n  int local_14;\n  \n  local_40 = 0x515f;\n  local_14 = 0;\n  local_18 = 0;\n  FUNC_00004c84(PTR_s__pid_____21s____9sQ___pri___stac_00002250,PTR_DAT_0000224c,PTR_s_state_00002248\n              );\n  local_20 = count_elf32_relocations_000008b8();\n  local_24 = get_pointer_data_0000091c();\n  local_28 = get_main_stack_pointer_00000900();\n  FUNC_00004c84(PTR_s______isr_stack______________6i___00002254,0x200,local_20,local_24,local_28);\n  local_14 = local_14 + 0x200;\n  if (0 < local_20) {\n    local_18 = local_20 + local_18;\n  }\n  for (local_1a = 1; local_1a < 0x21; local_1a = local_1a + 1) {\n    local_2c = *(undefined4 **)(PTR_DAT_00002258 + local_1a * 4);\n    if (local_2c != (undefined4 *)0x0) {\n      local_30 = (uint)*(byte *)(local_2c + 1);\n      local_34 = *(undefined4 *)(DAT_0000225c + local_30 * 4);\n      local_38 = (int)&local_40 + (uint)(8 < local_30);\n      local_3c = local_2c[0xb];\n      local_14 = local_3c + local_14;\n      iVar1 = calculate_distance_000010a0(local_2c[9]);\n      local_3c = local_3c - iVar1;\n      local_18 = local_3c + local_18;\n      FUNC_00004c84(PTR_s___3hi_____20s_____8s___1s____3i___00002260,\n                   (int)*(short *)((int)local_2c + 6),local_2c[10],local_34,local_38,\n                   *(undefined *)((int)local_2c + 5),local_2c[0xb],local_3c,local_2c[9],*local_2c);\n    }\n  }\n  FUNC_00004c84(PTR_s___5s___21s__13s_6s__6i___5i__0000226c,PTR_DAT_00002264,PTR_DAT_00002268,\n               PTR_DAT_00002264,PTR_DAT_00002264,local_14,local_18);\n  return;\n}\n\n"
        },
        "FUN_0000562c": {
            "renaming": {
                "FUN_0000562c": "find_key_value_pair_0000562c",
                "param_1": "param",
                "param_2": "key",
                "param_3": "index",
                "cVar1": "current_char",
                "ppiVar2": "ptr_to_ptr_to_key_value_pairs",
                "piVar3": "ptr_to_current_key_value_pair",
                "iVar4": "comparison_result",
                "pcVar5": "ptr_to_current_char",
                "piVar6": "ptr_to_current_key",
                "iVar7": "current_index"
            },
            "code": "int find_key_value_pair_0000562c(undefined4 param_1, char *key, int *index) \\n\\\n    { \\n\\\n        char current_char; \\n\\\n        int **ptr_to_ptr_to_key_value_pairs; \\n\\\n        int *ptr_to_current_key_value_pair; \\n\\\n        int current_index; \\n\\\n        char *ptr_to_current_char; \\n\\\n        int *ptr_to_current_key; \\n\\\n        int comparison_result; \\n\\\n        do_nothing_and_return_00005fec(); \\n\\\n        ptr_to_ptr_to_key_value_pairs = DAT_0000569c; \\n\\\n        ptr_to_current_char = key; \\n\\\n        if (*DAT_0000569c != (int *)0x0) \\n\\\n        { \\n\\\n            do \\n\\\n            { \\n\\\n                current_char = *ptr_to_current_char; \\n\\\n                if (current_char == \"\\0\") \\n\\\n                { \\n\\\n                    current_index = (int)ptr_to_current_char - (int)key; \\n\\\n                    ptr_to_current_key_value_pair = *DAT_0000569c; \\n\\\n                    while (true) \\n\\\n                    { \\n\\\n                        ptr_to_current_key = ptr_to_current_key_value_pair; \\n\\\n                        if (*ptr_to_current_key == 0) \\n\\\n                            break; \\n\\\n                        comparison_result = compare_strings_00004e66(*ptr_to_current_key, key, current_index); \\n\\\n                        ptr_to_current_key_value_pair = ptr_to_current_key + 1; \\n\\\n                        if ((comparison_result == 0) && (comparison_result = *ptr_to_current_key, *(char *)(comparison_result + current_index) == \"=\")) \\n\\\n                        { \\n\\\n                            *index = (int)ptr_to_current_key - (int)*ptr_to_ptr_to_key_value_pairs >> 2; \\n\\\n                            do_nothing_with_data_00005ff8(param_1); \\n\\\n                            return comparison_result + current_index + 1; \\n\\\n                        } \\n\\\n                    } \\n\\\n                    break; \\n\\\n                } \\n\\\n                ptr_to_current_char = ptr_to_current_char + 1; \\n\\\n            } while (current_char != \"=\"); \\n\\\n        } \\n\\\n        do_nothing_with_data_00005ff8(param_1); \\n\\\n        return 0; \\n\\\n    }",
            "called": [
                "FUN_00005fec",
                "FUN_00005ff8",
                "FUN_00004e66"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000562c",
            "calling": [
                "FUN_000056a0"
            ],
            "imported": false,
            "current_name": "find_key_value_pair_0000562c"
        },
        "FUN_000020b8": {
            "renaming": {
                "FUN_000020b8": "execute_check_000020b8",
                "DAT_000020c8": "input_data",
                "check_and_execute_00002028": "check_and_execute"
            },
            "code": "void execute_check_000020b8() {\n  check_and_execute(DAT_000020c8,0);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020b8",
            "calling": [],
            "imported": false,
            "current_name": "execute_check_000020b8"
        },
        "FUN_00002a18": {
            "renaming": {
                "FUN_00002a18": "find_value_in_arrays_00002a18",
                "param_1": "search_value",
                "param_2": "value_length",
                "local_18": "arrays_to_search",
                "local_10": "array_index",
                "local_c": "current_array",
                "iVar1": "compare_result"
            },
            "code": "int find_value_in_arrays_00002a18(int *search_value, uint value_length)\n{\n  int compare_result;\n  int *arrays_to_search[2];\n  uint array_index;\n  int *current_array;\n  arrays_to_search[0] = search_value;\n  arrays_to_search[1] = (int *)PTR_PTR_s_reboot_00002a84;\n  array_index = 0;\n  do {\n    if (1 < array_index) {\n      return 0;\n    }\n    current_array = arrays_to_search[array_index];\n    if (current_array != (int *)0x0) {\n      for (; *current_array != 0; current_array = current_array + 3) {\n        compare_result = compare_byte_arrays(*current_array,value_length);\n        if (compare_result == 0) {\n          return current_array[2];\n        }\n      }\n    }\n    array_index = array_index + 1;\n  } while( true );\n}",
            "called": [
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a18",
            "calling": [
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "find_value_in_arrays_00002a18"
        },
        "FUN_000054a8": {
            "renaming": {
                "FUN_000054a8": "process_data_000054a8",
                "*param_1": "*output",
                "*param_2": "*input",
                "uVar1": "flags_1",
                "uVar2": "flags_1_copy",
                "uVar3": "flags_uint",
                "uVar4": "flags_shifted",
                "iVar5": "data",
                "*DAT_00005574": "*data",
                "PTR_DAT_00005578": "ptr_1",
                "PTR_DAT_0000557c": "ptr_2",
                "PTR_DAT_00005580": "ptr_3",
                "FUNC_000042a4": "clear_data",
                "insert_node_00004b34": "insert_node",
                "insert_node": "insert_node",
                "allocate_memory_and_set_flag_00005700": "allocate_memory_and_set_flag",
                "allocate_memory_and_set_flag": "allocate_memory_and_set_flag"
            },
            "code": "uint process_data_000054a8(undefined4 *output, undefined4 *input) {\n  ushort flags = *(ushort *)(input + 3);\n  uint flags_uint = (uint)flags;\n  int data = *DAT_00005574;\n  if (data != 0 && *(int *)(data + 0x18) == 0) {\n    clear_data(data);\n  }\n  if (input == (undefined4 *)PTR_DAT_00005578) {\n    input = *(undefined4 **)(data + 4);\n  }\n  else if (input == (undefined4 *)PTR_DAT_0000557c) {\n    input = *(undefined4 **)(data + 8);\n  }\n  else if (input == (undefined4 *)PTR_DAT_00005580) {\n    input = *(undefined4 **)(data + 0xc);\n  }\n  uint flags_shifted = flags_uint << 0x1c;\n  if (-1 < (int)flags_shifted) {\n    uint flags_shifted_1 = flags_uint << 0x1b;\n    if (-1 < (int)flags_shifted_1) {\n      *output = 9;\n      return 0;\n    }\n    uint flags_shifted_2 = flags_uint << 0x1d;\n    if ((int)flags_shifted_2 < 0) {\n      if ((undefined4 *)input[0xd] != (undefined4 *)0x0 && (undefined4 *)input[0xd] != input + 0x11) {\n        insert_node_00004b34(output);\n      }\n      input[0xd] = 0;\n      *(ushort *)(input + 3) &= 0xffdb;\n      input[1] = 0;\n      *input = input[4];\n    }\n    *(ushort *)(input + 3) |= 8;\n  }\n  if (input[4] == 0 && (flags & 0x280) != 0x200) {\n    allocate_memory_and_set_flag_00005700(output, input);\n  }\n  ushort flags_1 = *(ushort *)(input + 3);\n  uint flags_1_uint = (uint)flags_1;\n  uint flags_1_shifted = flags_1_uint & 1;\n  if ((flags_1 & 1) == 0) {\n    if (-1 < (int)(flags_1_uint << 0x1e)) {\n      flags_1_shifted = input[5];\n    }\n    input[2] = flags_1_shifted;\n  }\n  else {\n    input[2] = 0;\n    input[6] = -input[5];\n  }\n  if (input[4] != 0) {\n    return 0;\n  }\n  if ((flags_1 & 0x80) == 0) {\n    return flags_1_uint & 0x80;\n  }\n  *(ushort *)(input + 3) |= 0x40;\n  return 0xffffffff;\n}",
            "called": [
                "FUN_00005700",
                "FUN_00004b34",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000054a8",
            "calling": [
                "FUN_000057f8",
                "FUN_00004db8",
                "FUN_00005404"
            ],
            "imported": false,
            "current_name": "process_data_000054a8",
            "code_backup": "\nuint FUN_000054a8(undefined4 *param_1,undefined4 *param_2)\n\n{\n  ushort uVar1;\n  ushort uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  \n  iVar5 = *DAT_00005574;\n  if ((iVar5 != 0) && (*(int *)(iVar5 + 0x18) == 0)) {\n    FUNC_000042a4(iVar5);\n  }\n  if (param_2 == (undefined4 *)PTR_DAT_00005578) {\n    param_2 = *(undefined4 **)(iVar5 + 4);\n  }\n  else if (param_2 == (undefined4 *)PTR_DAT_0000557c) {\n    param_2 = *(undefined4 **)(iVar5 + 8);\n  }\n  else if (param_2 == (undefined4 *)PTR_DAT_00005580) {\n    param_2 = *(undefined4 **)(iVar5 + 0xc);\n  }\n  uVar3 = (uint)*(ushort *)(param_2 + 3);\n  uVar2 = *(ushort *)(param_2 + 3);\n  if (-1 < (int)(uVar3 << 0x1c)) {\n    if (-1 < (int)(uVar3 << 0x1b)) {\n      *param_1 = 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(uVar3 << 0x1d) < 0) {\n      if ((undefined4 *)param_2[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)param_2[0xd] != param_2 + 0x11) {\n          insert_node_00004b34(param_1);\n        }\n        param_2[0xd] = 0;\n      }\n      *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) & 0xffdb;\n      param_2[1] = 0;\n      *param_2 = param_2[4];\n    }\n    *(ushort *)(param_2 + 3) = *(ushort *)(param_2 + 3) | 8;\n  }\n  if ((param_2[4] == 0) && ((*(ushort *)(param_2 + 3) & 0x280) != 0x200)) {\n    allocate_memory_and_set_flag_00005700(param_1,param_2);\n  }\n  uVar1 = *(ushort *)(param_2 + 3);\n  uVar3 = (uint)uVar1;\n  uVar2 = *(ushort *)(param_2 + 3);\n  uVar4 = uVar3 & 1;\n  if ((uVar1 & 1) == 0) {\n    if (-1 < (int)(uVar3 << 0x1e)) {\n      uVar4 = param_2[5];\n    }\n    param_2[2] = uVar4;\n  }\n  else {\n    param_2[2] = 0;\n    param_2[6] = -param_2[5];\n  }\n  if (param_2[4] != 0) {\n    return 0;\n  }\n  if ((uVar1 & 0x80) == 0) {\n    return uVar3 & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(param_2 + 3) = uVar2 | 0x40;\n  return 0xffffffff;\n}\n\n"
        },
        "FUN_000007dc": {
            "renaming": {
                "FUN_000007dc": "allocate_memory_000007dc",
                "param_1": "size",
                "param_2": "param_2",
                "param_3": "param_3",
                "param_4": "param_4",
                "local_14": "i",
                "local_10": "j",
                "local_c": "ptr",
                "uVar1": "aligned_size"
            },
            "code": "int * allocate_memory_000007dc(uint32_t size, int param_2, int param_3, int param_4) {\n  uint32_t aligned_size = (param_4 + param_3) & 0xfffffffc;\n  int* ptr = (int*)(aligned_size - sizeof(int));\n  *ptr = 0x77777777;\n  if (((uint32_t)ptr & 7) != 0) {\n    ptr = (int*)(aligned_size - 2*sizeof(int));\n    *ptr = 0x88888888;\n  }\n  ptr[-1] = 0x1000000;\n  ptr[-2] = param_1;\n  ptr[-3] = DAT_000008b4;\n  ptr = ptr - 4;\n  *ptr = 0;\n  for (int i = 3; i > 0; i--) {\n    ptr--;\n    *ptr = i;\n  }\n  ptr--;\n  *ptr = param_2;\n  for (int i = 0xb; i > 3; i--) {\n    ptr--;\n    *ptr = i;\n  }\n  ptr[-1] = -3;\n  return ptr - 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000007dc",
            "calling": [
                "FUN_000010d4"
            ],
            "imported": false,
            "current_name": "allocate_memory_000007dc"
        },
        "FUN_00001710": {
            "renaming": {
                "FUN_00001710": "set_result_to_zero_00001710",
                "param_1": "value",
                "param_2": "character",
                "puVar1": "result_pointer",
                "*puVar1": "*result_pointer",
                "calculate_result_00001696": "calculate_result"
            },
            "code": "void set_result_to_zero_00001710(int value, char character)\n{\n  undefined *result_pointer;\n  result_pointer = (undefined *)calculate_result(value, character);\n  *result_pointer = 0;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001710",
            "calling": [
                "FUN_000019c0",
                "FUN_00001bb8",
                "FUN_00001960",
                "FUN_00001778",
                "FUN_00001734",
                "FUN_0000182c",
                "FUN_000018bc",
                "FUN_00001a60"
            ],
            "imported": false,
            "current_name": "set_result_to_zero_00001710"
        },
        "FUN_000045ec": {
            "renaming": {
                "FUN_000045ec": "do_nothing_000045ec"
            },
            "code": "\nvoid do_nothing_000045ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ec",
            "calling": [
                "FUN_000057f8",
                "FUN_00004db8",
                "FUN_0000579c",
                "FUN_00004158",
                "FUN_00004280",
                "FUN_00005ff8",
                "FUN_00004418",
                "FUN_00004cb4",
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "do_nothing_000045ec"
        },
        "FUN_00001034": {
            "renaming": {
                "FUN_00001034": "find_and_insert_00001034",
                "param_1": "list",
                "param_2": "size",
                "local_1c": "current"
            },
            "code": "void find_and_insert_00001034(int **list, int size) {\n    int **current = list;\n    if (size > 8) {\n        initialize_and_execute(3, FAILED_ASSERTION_MSG);\n    }\n    while (*current != NULL && (*(*current - 3) <= *(list + 5))) {\n        current = (int **)*current;\n    }\n    *(int **)(list + 8) = *current;\n    *current = (int *)(int **)(list + 8);\n    return;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001034",
            "calling": [
                "FUN_00002434"
            ],
            "imported": false,
            "current_name": "find_and_insert_00001034"
        },
        "FUN_00006964": {
            "renaming": {
                "FUN_00006964": "calculate_result_00006964",
                "param_1": "starting_value",
                "param_2": "data_array",
                "iVar1": "index_offset",
                "*(int *)(param_2 + -4)": "starting_value",
                "*(int *)(param_2 + iVar1)": "data_array[index_offset]"
            },
            "code": "int calculate_result_00006964(int starting_value, int* data_array){\n                      int index_offset = starting_value - 4;\n                      if (starting_value < 0) {\n                          index_offset += data_array[index_offset];\n                      }\n                      return index_offset;\n                  }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006964",
            "calling": [
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "calculate_result_00006964"
        },
        "FUN_0000182c": {
            "renaming": {
                "FUN_0000182c": "clear_flags_0000182c",
                "DAT_000018b4": "flag_base_address",
                "DAT_000018b8": "result_base_address",
                "set_result_to_one_000016ec": "set_result_to_one",
                "set_result_to_zero_00001710": "set_result_to_zero"
            },
            "code": "void clear_flags_0000182c(void)\n{\n  byte* flag_ptr = (byte*)(DAT_000018b4 + 8);\n  *flag_ptr &= 0xd0;\n  set_result_to_one(DAT_000018b8, 0);\n  set_result_to_zero(DAT_000018b4, 1);\n  set_result_to_zero(DAT_000018b4, 0);\n  return;\n}",
            "called": [
                "FUN_000016ec",
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000182c",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "clear_flags_0000182c"
        },
        "FUN_00004db8": {
            "renaming": {
                "FUN_00004db8": "FUNC_00004db8"
            },
            "code": "\nundefined4 FUNC_00004db8(int param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  int iVar3;\n  char *pcVar4;\n  char **ppcVar5;\n  undefined4 uVar6;\n  char *pcVar7;\n  \n  iVar3 = *DAT_00004dc4;\n  if ((iVar3 != 0) && (*(int *)(iVar3 + 0x18) == 0)) {\n    initialize_arrays_000042a4();\n  }\n  ppcVar5 = *(char ***)(iVar3 + 8);\n  if (*(int *)(iVar3 + 0x18) == 0) {\n    initialize_arrays_000042a4(iVar3);\n  }\n  if (ppcVar5 == (char **)PTR_DAT_00004dac) {\n    ppcVar5 = *(char ***)(iVar3 + 4);\n  }\n  else if (ppcVar5 == (char **)PTR_DAT_00004db0) {\n    ppcVar5 = *(char ***)(iVar3 + 8);\n  }\n  else if (ppcVar5 == (char **)PTR_DAT_00004db4) {\n    ppcVar5 = *(char ***)(iVar3 + 0xc);\n  }\n  if ((-1 < (int)ppcVar5[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(ppcVar5 + 3) << 0x16))) {\n    do_nothing_000045e8(ppcVar5[0x16]);\n  }\n  if ((((int)((uint)*(ushort *)(ppcVar5 + 3) << 0x1c) < 0) && (ppcVar5[4] != (char *)0x0)) ||\n     (iVar2 = process_data_000054a8(iVar3,ppcVar5), iVar2 == 0)) {\n    pcVar7 = (char *)(param_1 + -1);\n    do {\n      while( true ) {\n        pcVar7 = pcVar7 + 1;\n        cVar1 = *pcVar7;\n        pcVar4 = ppcVar5[2] + -1;\n        ppcVar5[2] = pcVar4;\n        if (cVar1 == '\\0') {\n          if (-1 < (int)pcVar4) {\n            pcVar7 = *ppcVar5;\n            uVar6 = 10;\n            *ppcVar5 = pcVar7 + 1;\n            *pcVar7 = '\\n';\n            goto LAB_00004d64;\n          }\n          iVar3 = process_data_00005404(iVar3,10,ppcVar5);\n          if (iVar3 != -1) {\n            uVar6 = 10;\n            goto LAB_00004d64;\n          }\n          goto LAB_00004d60;\n        }\n        if (((int)pcVar4 < 0) && (((int)pcVar4 < (int)ppcVar5[6] || (cVar1 == '\\n')))) break;\n        pcVar4 = *ppcVar5;\n        *ppcVar5 = pcVar4 + 1;\n        *pcVar4 = cVar1;\n      }\n      iVar2 = process_data_00005404(iVar3,cVar1,ppcVar5);\n    } while (iVar2 != -1);\n  }\nLAB_00004d60:\n  uVar6 = 0xffffffff;\nLAB_00004d64:\n  if ((-1 < (int)ppcVar5[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(ppcVar5 + 3) << 0x16))) {\n    do_nothing_000045ec(ppcVar5[0x16]);\n  }\n  return uVar6;\n}\n\n",
            "called": [
                "FUN_00005404",
                "FUN_000045e8",
                "FUN_000054a8",
                "FUN_000045ec",
                "FUN_000042a4"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00004db8",
            "calling": [
                "FUN_00002b10",
                "FUN_00002a88",
                "FUN_000031e0",
                "FUN_000033f4",
                "FUN_00002fe0",
                "FUN_00002f30",
                "FUN_00003444",
                "FUN_00003694",
                "FUN_000033c0",
                "FUN_00002f74",
                "FUN_0000305c",
                "FUN_00003478",
                "FUN_000023a4",
                "FUN_000034c0"
            ],
            "imported": false,
            "current_name": "FUNC_00004db8"
        },
        "FUN_000022f0": {
            "renaming": {
                "FUN_000022f0": "increment_value_000022f0",
                "param_1": "array",
                "uVar1": "index"
            },
            "code": "undefined increment_value_000022f0(int *array)\n{\n  uint index = array[2];\n  array[2] = index + 1;\n  return *(undefined *)((index & array[1] - 1U) + *array);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022f0",
            "calling": [
                "FUN_0000231c"
            ],
            "imported": false,
            "current_name": "increment_value_000022f0"
        },
        "FUN_00001c84": {
            "renaming": {
                "FUN_00001c84": "calculate_result_and_execute_instructions_00001c84",
                "check_interrupts_enabled_00000cd0": "check_interrupts_enabled",
                "check_and_set_values_00001bb8": "set_default_values",
                "DAT_00001ce8": "data",
                "DAT_00001cec": "data",
                "clear_flags_0000182c": "clear_flags",
                "calculateResultAndReturn_000017dc": "calculate_result",
                "execute_instructions_00001b10": "execute_instructions",
                "enable_irq_interrupts_if_privileged_00000d0c": "enable_irq_interrupts_if_privileged"
            },
            "code": "void calculate_result_and_execute_instructions_00001c84(void)\n{\n  bool interrupts_enabled = check_interrupts_enabled();\n  set_default_values();\n  *(unsigned int *)(DAT_00001ce8 + 0x1044) = 0x220000;\n  DAT_00001ce8[0xc] = 0;\n  *DAT_00001ce8 = *DAT_00001ce8 & 199 | 0x38;\n  DAT_00001ce8[4] = 0x13;\n  DAT_00001ce8[5] = 0;\n  clear_flags();\n  calculate_result();\n  execute_instructions(7);\n  enable_irq_interrupts_if_privileged(interrupts_enabled);\n  return;\n}",
            "called": [
                "FUN_00001bb8",
                "FUN_00000d0c",
                "FUN_00000cd0",
                "FUN_000017dc",
                "FUN_0000182c",
                "FUN_00001b10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001c84",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "calculate_result_and_execute_instructions_00001c84"
        },
        "FUN_000068f0": {
            "renaming": {
                "FUN_000068f0": "allocate_or_insert_node_000068f0",
                "param_1": "requested_size",
                "param_2": "node_pointer",
                "iVar1": "allocated_node",
                "iVar2": "current_size",
                "*(undefined *)(iVar1 + 0x3ff)": "*(undefined *)(allocated_node + 0x3ff)",
                "*(undefined *)(iVar1 + 0x3fe)": "*(undefined *)(allocated_node + 0x3fe)",
                "*(undefined *)(iVar1 + 0x3fd)": "*(undefined *)(node_pointer + 17)",
                "*param_2": "*node_pointer",
                "(int *)param_2[0xd]": "(int *)next_node",
                "param_2 + 0x11": "node_pointer + 17",
                "param_2[0xd]": "node_pointer[13]",
                "param_2[0xe]": "node_pointer[14]",
                "allocate_memory_00004bd0": "allocate_memory",
                "allocate_and_insert_node_000060cc": "allocate_and_insert_node",
                "copy_string_000060b0": "copy_string"
            },
            "code": "undefined4 allocate_or_insert_node_000068f0(undefined4 requested_size, int *node_pointer)\n{\n    int current_size = node_pointer[13];\n    int *next_node = node_pointer + 17;\n    \n    if ((int *)next_node == (node_pointer + 17)) {\n        int allocated_node = allocate_memory(requested_size, 0x400);\n        \n        if (allocated_node != 0) {\n            node_pointer[14] = 0x400;\n            node_pointer[13] = allocated_node;\n            *(undefined *)(allocated_node + 0x3ff) = *(undefined *)((int)node_pointer + 0x46);\n            *(undefined *)(allocated_node + 0x3fe) = *(undefined *)((int)node_pointer + 0x45);\n            *(undefined *)(allocated_node + 0x3fd) = *(undefined *)(node_pointer + 17);\n            *node_pointer = allocated_node + 0x3fd;\n            return 0;\n        }\n    }\n    else {\n        int new_size = current_size << 1;\n        int allocated_node = allocate_and_insert_node(requested_size, (int *)next_node, new_size);\n        \n        if (allocated_node != 0) {\n            copy_string(allocated_node + current_size, allocated_node, current_size);\n            node_pointer[13] = allocated_node;\n            node_pointer[14] = new_size;\n            *node_pointer = allocated_node + current_size;\n            return 0;\n        }\n    }\n    return 0xffffffff;\n}",
            "called": [
                "FUN_000060b0",
                "FUN_000060cc",
                "FUN_00004bd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000068f0",
            "calling": [],
            "imported": false,
            "current_name": "allocate_or_insert_node_000068f0"
        }
    },
    "used_tokens": 185589,
    "layers": [
        [
            "FUN_000064bc",
            "FUN_00002970",
            "FUN_00000d0c",
            "FUN_00003d94",
            "FUN_0000579c",
            "FUN_000015d0",
            "FUN_00000dcc",
            "FUN_0000285c",
            "FUN_00000566",
            "FUN_00001d08",
            "FUN_000031fc",
            "FUN_00005584",
            "FUN_00001da2",
            "FUN_00002744",
            "FUN_00001e0c",
            "FUN_000004f2",
            "FUN_00004e66",
            "FUN_00005ecc",
            "FUN_00001748",
            "FUN_0000294c",
            "FUN_00005790",
            "FUN_00000534",
            "FUN_000005ca",
            "FUN_00005ff8",
            "FUN_00002714",
            "FUN_00005fec",
            "FUN_00004f84",
            "FUN_000028f0",
            "FUN_000039e8",
            "FUN_00002294",
            "FUN_00003810",
            "FUN_0000687c",
            "FUN_00005edc",
            "FUN_0000240c",
            "FUN_00004280",
            "FUN_00000cf0",
            "FUN_00002538",
            "FUN_0000058e",
            "FUN_00001696",
            "FUN_000008b8",
            "FUN_0000091c",
            "FUN_00000d44",
            "FUN_00000cd0",
            "FUN_00000d2a",
            "FUN_00001e44",
            "FUN_00001318",
            "FUN_00000900",
            "FUN_00004274",
            "FUN_00001dc0",
            "FUN_000026f0",
            "FUN_00001d5e",
            "FUN_000050f4",
            "FUN_00005a58",
            "FUN_000056b0",
            "FUN_00003d24",
            "FUN_00003dc4",
            "FUN_000022be",
            "FUN_00001d80",
            "FUN_000023c8",
            "FUN_0000428c",
            "FUN_000010a0",
            "FUN_00006010",
            "FUN_00001360",
            "FUN_00004622",
            "FUN_0000093c",
            "FUN_00003658",
            "FUN_000060b0",
            "FUN_000050e8",
            "FUN_00000514",
            "FUN_000045ee",
            "FUN_00006974",
            "FUN_00005ebc",
            "FUN_0000281c",
            "FUN_00002270",
            "FUN_00003918",
            "FUN_00003d64",
            "FUN_00004e52",
            "FUN_00001ad4",
            "FUN_00002910",
            "FUN_000043a0",
            "FUN_000007dc",
            "FUN_00006964",
            "FUN_000022f0"
        ],
        [
            "FUN_000026c0",
            "FUN_00005e68",
            "FUN_00000e58",
            "FUN_000026d8",
            "FUN_000016ec",
            "FUN_00001ec4",
            "FUN_000014c4",
            "FUN_00004b34",
            "FUN_00004f98",
            "FUN_00000428",
            "FUN_00000e38",
            "FUN_00002600",
            "FUN_00004042",
            "FUN_00002894",
            "FUN_00000d76",
            "FUN_000026e4",
            "FUN_00000698",
            "FUN_00001ff6",
            "FUN_0000328c",
            "FUN_000041f4",
            "FUN_000056b8",
            "FUN_00003ff4",
            "FUN_00000930",
            "FUN_00001348",
            "FUN_00001d3a",
            "FUN_00002798",
            "FUN_0000231c",
            "FUN_00001cf0",
            "FUN_000023d0",
            "FUN_00005fd8",
            "FUN_0000443c",
            "FUN_000027b0",
            "FUN_000016c8",
            "FUN_00000738",
            "FUN_00003e58",
            "FUN_00004e26",
            "FUN_00000610",
            "FUN_00002364",
            "FUN_00003688",
            "FUN_00001392",
            "FUN_0000258c",
            "FUN_0000562c",
            "FUN_00002a18",
            "FUN_00001710"
        ],
        [
            "FUN_00004bd0",
            "FUN_00000794",
            "FUN_00001778",
            "FUN_00002624",
            "FUN_00001628",
            "FUN_000017dc",
            "FUN_00004dee",
            "FUN_00002654",
            "FUN_000025f4",
            "FUN_00001ddc",
            "FUN_000024bc",
            "FUN_00002994",
            "FUN_00000d9c",
            "FUN_00001bb8",
            "FUN_0000404c",
            "FUN_000056a0",
            "FUN_00002690",
            "FUN_00002e9c",
            "FUN_00001960",
            "FUN_00006192",
            "FUN_00001734",
            "FUN_00005780",
            "FUN_00002028",
            "FUN_00001a60",
            "FUN_000018bc",
            "FUN_0000182c"
        ],
        [
            "FUN_00004248",
            "FUN_000020e0",
            "FUN_00000db0",
            "FUN_000020f4",
            "FUN_00001688",
            "FUN_000012b4",
            "FUN_00001f80",
            "FUN_00001a18",
            "FUN_0000191c",
            "FUN_000060cc",
            "FUN_00002108",
            "FUN_00005700",
            "FUN_000019c0",
            "FUN_00001a3c",
            "FUN_000020cc",
            "FUN_00002396",
            "FUN_000020b8"
        ],
        [
            "FUN_00001eea",
            "FUN_00001448",
            "FUN_00001b10",
            "FUN_000068f0"
        ],
        [
            "FUN_00001c84"
        ],
        [
            "FUN_00001274"
        ],
        [
            "FUN_000031e0",
            "FUN_000034c0",
            "FUN_000033f4",
            "FUN_00003478"
        ],
        [
            "FUN_00003378",
            "FUN_00000ed8",
            "FUN_0000211c"
        ],
        [
            "FUN_00002eb4"
        ],
        [
            "FUN_00002a88",
            "FUN_00003524",
            "FUN_00002f74"
        ],
        [
            "FUN_00004158",
            "FUN_00004c84",
            "FUN_00004314",
            "FUN_000054a8"
        ],
        [
            "FUN_000041d0",
            "FUN_00002b10",
            "FUN_000042a4"
        ],
        [
            "FUN_00006768",
            "FUN_00005404"
        ],
        [
            "FUN_000057a8",
            "FUN_00005e10",
            "FUN_00004cb4"
        ],
        [
            "FUN_000057d2",
            "FUN_00004418",
            "FUN_00002a00"
        ],
        [
            "FUN_00002e48",
            "FUN_00002d94"
        ],
        [
            "FUN_00002e6c"
        ],
        [
            "FUN_000023a4"
        ],
        [
            "FUN_00000f04"
        ],
        [
            "FUN_00000fec",
            "FUN_00000cc0",
            "FUN_000013b8",
            "FUN_00003ec4",
            "FUN_00000a30",
            "FUN_00001034"
        ],
        [
            "FUN_00000dc0",
            "FUN_00003e9e",
            "FUN_00000e64",
            "FUN_00000df4",
            "FUN_00002434",
            "FUN_000010d4"
        ],
        [
            "FUN_0000129c",
            "FUN_00000410",
            "FUN_00000f8c",
            "FUN_00003694"
        ],
        [
            "FUN_0000459c",
            "FUN_0000305c",
            "FUN_00002ecc",
            "FUN_000012e2"
        ],
        [
            "FUN_00002f30",
            "FUN_00000e14",
            "FUN_0000099c"
        ],
        [
            "FUN_00000490",
            "FUN_00002fe0"
        ],
        [
            "FUN_0000316c",
            "FUN_00004dc8"
        ]
    ],
    "locked_functions": []
}