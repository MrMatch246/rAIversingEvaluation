{
    "functions": {
        "FUN_000026c0": {
            "renaming": {
                "FUN_000026c0": "clear_rtc_alarm_000026c0",
                "PTR_rtc_callback_000026d4": "rtc_callback_ptr"
            },
            "code": "void clear_rtc_alarm_000026c0(void)\n{\n  rtt_clear_alarm();\n  *(undefined4 *)PTR_rtc_callback_000026d4 = 0;\n  return;\n}",
            "called": [
                "rtt_clear_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026c0",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "clear_rtc_alarm_000026c0"
        },
        "FUN_00004bd0": {
            "renaming": {
                "FUN_00004bd0": "allocate_memory_00004bd0",
                "param_1": "reent",
                "param_2": "size",
                "puVar1": "start_brk",
                "pvVar2": "new_brk",
                "puVar3": "free_list",
                "iVar4": "block_diff",
                "uVar5": "block_size",
                "puVar6": "current_block",
                "uVar7": "aligned_size"
            },
            "code": "uint allocate_memory_00004bd0(_reent *reent, uint size) {\n  undefined *start_brk = PTR___malloc_sbrk_start_00004c80;\n  uint *free_list = *(uint **)PTR___malloc_free_list_00004c7c;\n  uint aligned_size = (size + 3) & 0xfffffffc) + 8;\n  if (aligned_size < 0xc) {\n    aligned_size = 0xc;\n  }\n  if (((int)aligned_size < 0) || (aligned_size < size)) {\n    reent->_errno = 0xc;\n    return 0;\n  }\n  __malloc_lock();\n  uint *current_block = free_list;\n  uint *previous_block = NULL;\n  while (current_block != (uint *)0x0) {\n    uint block_size = *current_block - aligned_size;\n    if (-1 < (int)block_size) {\n      if (0xb < block_size) {\n        *current_block = block_size;\n        uint *new_block = (uint *)((int)current_block + block_size);\n        new_block[0] = aligned_size;\n        new_block[1] = current_block[1];\n        if (previous_block == NULL) {\n          *(uint **)PTR___malloc_free_list_00004c7c = new_block;\n        }\n        else {\n          previous_block[1] = new_block;\n        }\n        __malloc_unlock(reent);\n        return (int)new_block + 0xbU & 0xfffffff8;\n      }\n      uint next_block = current_block[1];\n      if (free_list == current_block) {\n        *(uint **)PTR___malloc_free_list_00004c7c = (uint *)next_block;\n      }\n      if (free_list != current_block) {\n        previous_block[1] = next_block;\n      }\n      __malloc_unlock(reent);\n      return (int)current_block + 0xbU & 0xfffffff8;\n    }\n    previous_block = current_block;\n    current_block = (uint *)current_block[1];\n  }\n  if (*(int *)start_brk == 0) {\n    void *new_brk = _sbrk_r(reent,0);\n    *(void **)start_brk = new_brk;\n  }\n  uint *new_block = (uint *)_sbrk_r(reent,aligned_size);\n  if ((new_block != (uint *)0xffffffff) && ((uint *)((int)new_block + 3U & 0xfffffffc) == new_block || (_sbrk_r(reent,(int)((uint *)((int)new_block + 3U & 0xfffffffc) - (int)new_block)) != (void *)0xffffffff))) {\n    new_block[0] = aligned_size;\n    __malloc_unlock(reent);\n    return (int)new_block + 0xbU & 0xfffffff8;\n  }\n  reent->_errno = 0xc;\n  __malloc_unlock(reent);\n  return 0;\n}",
            "called": [
                "__malloc_unlock",
                "_sbrk_r",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004bd0",
            "calling": [
                "_tzset_unlocked_r",
                "__submore",
                "_realloc_r",
                "__sfmoreglue",
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_00004bd0"
        },
        "FUN_00000794": {
            "renaming": {
                "FUN_00000794": "disable_interrupts_and_remove_thread_from_scheduler_00000794",
                "PTR_sched_threads_000007d0": "scheduler_threads_pointer",
                "PTR_sched_active_pid_000007cc": "scheduler_active_process_id_pointer",
                "PTR_sched_num_threads_000007d4": "scheduler_number_of_threads_pointer",
                "PTR_sched_active_thread_000007d8": "scheduler_active_thread_pointer",
                "cpu_switch_context_exit": "exit_cpu_switch_context",
                "thread_t": "thread_type"
            },
            "code": "void disable_interrupts_and_remove_thread_from_scheduler_00000794(void)\n{\n  irq_disable();\n  int active_pid = *(short *)PTR_sched_active_pid_000007cc;\n  *(undefined4 *)(PTR_sched_threads_000007d0 + active_pid * 4) = 0;\n  int *num_threads = (int *)PTR_sched_num_threads_000007d4;\n  *num_threads = *num_threads - 1;\n  thread_t **active_thread = (thread_t **)PTR_sched_active_thread_000007d8;\n  sched_set_status(*active_thread, 0);\n  *active_thread = NULL;\n  cpu_switch_context_exit();\n}",
            "called": [
                "cpu_switch_context_exit",
                "irq_disable",
                "sched_set_status"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000794",
            "calling": [],
            "imported": false,
            "current_name": "disable_interrupts_and_remove_thread_from_scheduler_00000794"
        },
        "FUN_000064bc": {
            "renaming": {
                "FUN_000064bc": "process_data_000064bc",
                "param_1": "input",
                "param_2": "data",
                "param_3": "buffer",
                "param_4": "counter",
                "puVar1": "pointer",
                "iVar2": "result",
                "uVar3": "mask",
                "ppbVar4": "byte_buffer_pointer",
                "pbVar5": "next_byte",
                "unaff_r6": "current_byte",
                "pbVar6": "new_byte",
                "iVar7": "byte_counter"
            },
            "code": "int process_data_000064bc(int input, uint32_t *data, byte **buffer, int *counter) {\n  byte *current_byte;\n  uint32_t *function_pointer;\n  byte **byte_buffer_pointer;\n  int byte_counter;\n  uint32_t mask = 0x80000000;\n  if (data[2] == 0) {\n    if (data[6] == 0) {\n      mask = 1;\n    }\n    data[2] = mask;\n  }\n  current_byte = NULL;\n  if (-1 < (int)(*data << 0x1b)) {\n    byte_buffer_pointer = (byte **)*counter;\n    *counter = byte_buffer_pointer + 1;\n    current_byte = *byte_buffer_pointer;\n  }\n  byte_counter = 0;\n  do {\n    mask = data[6];\n    if (mask != 0) {\n      if (mask == 1) {\n        if (*(char *)(data[5] + (uint)**buffer) == '\\0') {\n          if (byte_counter == 0) {\n            return 1;\n          }\n          if (((*data & 0x10) == 0) && (data[3] = data[3] + 1, data[6] != 0)) {\n            *current_byte = 0;\n          }\n          data[4] = byte_counter + data[4];\n          return 0;\n        }\n      }\n      else if ((mask != 2) || ((int)((uint)(byte)PTR_DAT_00006568[**buffer] << 0x1c) < 0)) {\n        goto LAB_0000654a;\n      }\n    }\n    if (-1 < (int)(*data << 0x1b)) {\n      current_byte = current_byte + 1;\n      *current_byte = **buffer;\n    }\n    byte_buffer_pointer = *buffer + 1;\n    *buffer = byte_buffer_pointer;\n    mask = data[2] - 1;\n    byte_buffer_pointer = *buffer + -1;\n    byte_counter = byte_counter + 1;\n    data[2] = mask;\n    if ((mask == 0) || (((int)(byte_buffer_pointer) < 1 && ((*(code *)data[0x60])(input, buffer, mask, (code *)data[0x60], counter)) != 0))) {\n      goto LAB_0000654a;\n    }\n  } while (true);\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000064bc",
            "calling": [
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "process_data_000064bc"
        },
        "FUN_00002970": {
            "renaming": {
                "FUN_00002970": "clear_rtt_interrupt_flag_00002970",
                "rtt": "real_time_clock",
                "uint": "uint32_t",
                "DAT_00002990": "data_ptr"
            },
            "code": "void clear_rtt_interrupt_flag_00002970(void)\n{\n  RTC_Type *real_time_clock;\n  uint32_t *DAT_00002990 = (uint32_t *)(DAT_00002990 + 0x14);\n  *DAT_00002990 &= ~(1 << 4);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002970",
            "calling": [
                "rtc_poweroff"
            ],
            "imported": false,
            "current_name": "clear_rtt_interrupt_flag_00002970"
        },
        "FUN_00000dc0": {
            "renaming": {
                "FUN_00000dc0": "execute_default_function_00000dc0"
            },
            "code": "void execute_default_function_00000dc0(void)\n{\n  execute_default_function_00000dc0();\n  return;\n}",
            "called": [
                "dummy_handler_default"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dc0",
            "calling": [],
            "imported": false,
            "current_name": "execute_default_function_00000dc0"
        },
        "FUN_00000ca0": {
            "renaming": {
                "FUN_00000ca0": "handle_usage_fault_00000ca0",
                "PTR_s_USAGE_FAULT_HANDLER_00000cac": "usage_fault_handler"
            },
            "code": "void handle_usage_fault_00000ca0(void)\n{\n    // This function does not return.\n    core_panic(PANIC_USAGE_FAULT, PTR_s_USAGE_FAULT_HANDLER_00000cac);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ca0",
            "calling": [],
            "imported": false,
            "current_name": "handle_usage_fault_00000ca0"
        },
        "FUN_00000d0c": {
            "renaming": {
                "FUN_00000d0c": "enable_irq_interrupts_if_privileged_00000d0c",
                "state": "irq_state",
                "bVar1": "is_privileged_mode",
                "enableIRQinterrupts": "enable_irq_interrupts",
                "DAT_00000008": "IRQ_INTERRUPT_ENABLED"
            },
            "code": "void enable_irq_interrupts_if_privileged_00000d0c(uint state)\n{\n  bool is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    bool is_interrupt_enabled = (state & 1) == 1;\n    enableIRQinterrupts(is_interrupt_enabled);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d0c",
            "calling": [
                "kinetis_mcg_init",
                "_sbrk_r",
                "thread_create",
                "mutex_unlock",
                "_mutex_lock"
            ],
            "imported": false,
            "current_name": "enable_irq_interrupts_if_privileged_00000d0c"
        },
        "FUN_00003d94": {
            "renaming": {
                "FUN_00003d94": "write_sensor_data_00003d94",
                "dev": "sensor",
                "data": "data",
                "iVar1": "status"
            },
            "code": "int write_sensor_data_00003d94(saul_reg_t *sensor, phydat_t *data) {\n  int status;\n  if (sensor == NULL) {\n    status = -19;\n  }\n  else {\n    status = (*sensor->driver->write)(sensor->dev, data);\n  }\n  return status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d94",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "write_sensor_data_00003d94"
        },
        "FUN_0000579c": {
            "renaming": {
                "FUN_0000579c": "release_malloc_recursive_mutex_0000579c",
                "PTR___lock___malloc_recursive_mutex_000057a4": "malloc_recursive_mutex"
            },
            "code": "void release_malloc_recursive_mutex_0000579c()\n{\n  __retarget_lock_release_recursive(PTR___lock___malloc_recursive_mutex_000057a4);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000579c",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "release_malloc_recursive_mutex_0000579c"
        },
        "FUN_000015d0": {
            "renaming": {
                "FUN_000015d0": "send_data_over_uart_000015d0",
                "uart": "uart_number",
                "data": "data_to_send",
                "len": "data_size",
                "iVar1": "uart_config",
                "dev": "UART_Type"
            },
            "code": "void send_data_over_uart_000015d0(uart_t uart, uint8_t *data, size_t len)\n{\n  int uart_config = *(int *)(PTR_uart_config_00001624 + uart * 0x20);\n  UART_Type *dev = (UART_Type *) uart_config;\n  for (size_t i = 0; i < len; i++) {\n    while (-1 < *(char *)(uart_config + 4));\n    *(uint8_t *)(uart_config + 7) = data[i];\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000015d0",
            "calling": [
                "uart_stdio_write"
            ],
            "imported": false,
            "current_name": "send_data_over_uart_000015d0"
        },
        "FUN_00004cdc": {
            "renaming": {
                "FUN_00004cdc": "print_string_00004cdc",
                "param_1": "file_descriptor",
                "param_2": "string",
                "cVar1": "current_char",
                "iVar2": "ret_val",
                "pcVar3": "buffer_end",
                "ppcVar4": "file_ptr_ptr",
                "uVar5": "ret_val",
                "pcVar6": "buffer_ptr",
                "__sinit": "__sinit_r",
                "__swsetup_r": "__swsetup",
                "__swbuf_r": "__swbuf",
                "PTR___sf_fake_stdin_00004dac": "PTR___sf_fake_stdin",
                "PTR___sf_fake_stdout_00004db0": "PTR___sf_fake_stdout",
                "PTR___sf_fake_stderr_00004db4": "PTR___sf_fake_stderr"
            },
            "code": "int print_string_00004cdc(int file_descriptor, char *string) {\n  char current_char;\n  int ret_val;\n  char *buffer_ptr;\n  char **file_ptr_ptr;\n  int is_recursive = (*(int *)(file_descriptor + 0x18) == 0);\n  if (file_ptr_ptr = *(char ***)(file_descriptor + 8), is_recursive) {\n    __sinit(file_descriptor);\n  }\n  if (file_ptr_ptr == (char **)PTR___sf_fake_stdin_00004dac_00004dac) {\n    file_ptr_ptr = *(char ***)(file_descriptor + 4);\n  } else {\n    if (file_ptr_ptr == (char **)PTR___sf_fake_stdout_00004db0_00004db0) {\n      file_ptr_ptr = *(char ***)(file_descriptor + 8);\n    } else {\n      if (file_ptr_ptr == (char **)PTR___sf_fake_stderr_00004db4_00004db4) {\n        file_ptr_ptr = *(char ***)(file_descriptor + 0xc);\n      }\n    }\n  }\n  if ((-1 < (int)file_ptr_ptr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(file_ptr_ptr + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(file_ptr_ptr[0x16]);\n  }\n  if ((((int)((uint)*(ushort *)(file_ptr_ptr + 3) << 0x1c) < 0) && (file_ptr_ptr[4] != (char *)0x0)) || (ret_val = __swsetup_r(file_descriptor, file_ptr_ptr), ret_val == 0)) {\n    buffer_ptr = string - 1;\n    do {\n      while (true) {\n        buffer_ptr = buffer_ptr + 1;\n        current_char = *buffer_ptr;\n        char *buffer_end = file_ptr_ptr[2] + -1;\n        file_ptr_ptr[2] = buffer_end;\n        if (current_char == '\\0') {\n          if (-1 < (int)buffer_end) {\n            buffer_ptr = *file_ptr_ptr;\n            ret_val = 10;\n            *file_ptr_ptr = buffer_ptr + 1;\n            *buffer_ptr = '\\n';\n            goto LAB_00004d64;\n          }\n          ret_val = __swbuf_r(file_descriptor, 10, file_ptr_ptr);\n          if (ret_val != -1) {\n            ret_val = 10;\n            goto LAB_00004d64;\n          }\n          goto LAB_00004d60;\n        }\n        if (((int)buffer_end < 0) && (((int)buffer_end < (int)file_ptr_ptr[6] || (current_char == '\\n')))) {\n          break;\n        }\n        char *buffer_start = *file_ptr_ptr;\n        *file_ptr_ptr = buffer_start + 1;\n        *buffer_start = current_char;\n      }\n      ret_val = __swbuf_r(file_descriptor, current_char, file_ptr_ptr);\n    } while (ret_val != -1);\n  }\nLAB_00004d60:\n  ret_val = -1;\nLAB_00004d64:\n  if ((-1 < (int)file_ptr_ptr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(file_ptr_ptr + 3) << 0x16))) {\n    __retarget_lock_release_recursive(file_ptr_ptr[0x16]);\n  }\n  return ret_val;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__swbuf_r",
                "__swsetup_r",
                "__retarget_lock_release_recursive",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cdc",
            "calling": [
                "puts"
            ],
            "imported": false,
            "current_name": "print_string_00004cdc"
        },
        "FUN_00005e68": {
            "renaming": {
                "FUN_00005e68": "scan_formatted_string_00005e68",
                "__s": "string",
                "__format": "format",
                "iVar1": "result",
                "in_r2": "args",
                "in_r3": "",
                "local_80": "string_ptr",
                "local_7c": "string_length",
                "local_74": "short_dummy",
                "local_72": "short_dummy",
                "local_70": "string_ptr",
                "local_6c": "remaining_length",
                "local_5c": "DAT_00005eb4",
                "local_4c": "",
                "local_38": "",
                "uStack_8": "void_ptr_dummy",
                "uStack_4": "int_ptr_dummy",
                "undefined4": "int_dummy",
                "undefined2": "short_dummy",
                "size_t": "size_t_dummy",
                "char": "char_dummy"
            },
            "code": "int scan_formatted_string_00005e68(char* string, char* format, ...)\n{\n    int result;\n    va_list args;\n    char* string_ptr;\n    char* format_ptr;\n    size_t string_length;\n    size_t remaining_length;\n    short int short_dummy;\n    int int_dummy;\n    float float_dummy;\n    double double_dummy;\n    long double long_double_dummy;\n    void* void_ptr_dummy;\n    size_t size_t_dummy;\n    int* int_ptr_dummy;\n    char char_dummy;\n\n    short_dummy = 0x204;\n    string_ptr = string;\n    format_ptr = format;\n    va_start(args, format);\n    string_length = strlen(string);\n    remaining_length = string_length;\n    int_dummy = DAT_00005eb4;\n    size_t_dummy = 0;\n    void_ptr_dummy = NULL;\n    int_ptr_dummy = NULL;\n    char_dummy = 0;\n\n    result = __ssvfiscanf_r(*(undefined4*)PTR__impure_ptr_00005eb8, &string_ptr, format_ptr, &args);\n    va_end(args);\n    return result;\n}",
            "called": [
                "__ssvfiscanf_r",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e68",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "scan_formatted_string_00005e68"
        },
        "FUN_00000dcc": {
            "renaming": {
                "FUN_00000dcc": "set_values_in_array_00000dcc",
                "DAT_00000df0": "array"
            },
            "code": "void set_values_in_array_00000dcc(void)\n{\n  DAT_00000df0[7] = 0xc520;\n  DAT_00000df0[7] = 0xd928;\n  *DAT_00000df0 = 0xd2;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dcc",
            "calling": [
                "pre_startup"
            ],
            "imported": false,
            "current_name": "set_values_in_array_00000dcc"
        },
        "FUN_0000285c": {
            "renaming": {
                "FUN_0000285c": "set_RTC_counter_0000285c",
                "counter": "new_counter",
                "puVar1": "counter_ptr",
                "rtt": "rtc",
                "DAT_00002890": "original_counter"
            },
            "code": "void set_RTC_counter_0000285c(uint32_t counter)\n{\n  uint32_t *counter_ptr;\n  RTC_Type *rtc;\n  counter_ptr = DAT_00002890;\n  DAT_00002890[5] &= 0xffffffef;\n  *counter_ptr = counter;\n  counter_ptr[5] |= 0x10;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000285c",
            "calling": [
                "rtc_set_time"
            ],
            "imported": false,
            "current_name": "set_RTC_counter_0000285c"
        },
        "FUN_00000e58": {
            "renaming": {
                "FUN_00000e58": "wait_for_interrupt_00000e58",
                "irq_disable": "disable_interrupts"
            },
            "code": "void wait_for_interrupt_00000e58(void)\n{\n  disable_interrupts();\n  while( true )\n  {\n    // Do nothing, just wait for an interrupt\n  }\n}",
            "called": [
                "irq_disable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e58",
            "calling": [
                "core_panic"
            ],
            "imported": false,
            "current_name": "wait_for_interrupt_00000e58"
        },
        "FUN_00001778": {
            "renaming": {
                "FUN_00001778": "set_bit_in_byte_00001778",
                "DAT_000017d0": "data_pointer",
                "DAT_000017d8": "bit_pointer"
            },
            "code": "void set_bit_in_byte_00001778(void)\n{\n    byte* DAT_000017d0 = DAT_000017d0;\n    byte* DAT_000017d8 = DAT_000017d8;\n    byte mask = 0xcf;\n    byte bit = 0x20;\n    *DAT_000017d0 = (*DAT_000017d0 & mask) | bit;\n    bit_clear8(*DAT_000017d8, 0x02);\n    return;\n}",
            "called": [
                "bit_set8",
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001778",
            "calling": [
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_fbe"
            ],
            "imported": false,
            "current_name": "set_bit_in_byte_00001778"
        },
        "FUN_000026d8": {
            "renaming": {
                "FUN_000026d8": "initialize_real_time_trace_000026d8",
                "rtt_poweron": "turn_on_real_time_trace"
            },
            "code": "void initialize_real_time_trace_000026d8(void)\n{\n  turn_on_real_time_trace();\n  return;\n}",
            "called": [
                "rtt_poweron"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026d8",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "initialize_real_time_trace_000026d8"
        },
        "FUN_00000566": {
            "renaming": {
                "FUN_00000566": "leading_zeroes_in_uint_00000566",
                "v": "uint_value",
                "bVar1": "byte1",
                "bVar2": "byte2",
                "bVar3": "byte3",
                "bVar4": "byte4",
                "uVar5": "leading_zeroes_count"
            },
            "code": "uint leading_zeroes_in_uint_00000566(uint v) {\n  uint mask = 0x80000000;\n  uint count = 0;\n\n  for (int i = 0; i < 32; i++) {\n    if ((v & mask) == 0) {\n      count++;\n    } else {\n      break;\n    }\n    mask >>= 1;\n  }\n  if (v == 0) {\n    count = 32;\n  }\n  return count;\n}\n\nuint leading_zeroes_in_uint_00000566(uint v) {\n  byte byte1 = (byte)(v >> 24);\n  byte byte2 = (byte)(v >> 16);\n  byte byte3 = (byte)(v >> 8);\n  byte byte4 = (byte)v;\n\n  uint uVar5 = (leading_zeroes_in_uint_00000566(byte1) << 24) | (leading_zeroes_in_uint_00000566(byte2) << 16) | (leading_zeroes_in_uint_00000566(byte3) << 8) | leading_zeroes_in_uint_00000566(byte4);\n\n  if (v == 0) {\n    uVar5 = 0xffffffff;\n  }\n  return uVar5;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000566",
            "calling": [
                "sched_run"
            ],
            "imported": false,
            "current_name": "leading_zeroes_in_uint_00000566"
        },
        "FUN_00001d08": {
            "renaming": {
                "FUN_00001d08": "calculate_memory_address_00001d08",
                "ptr": "PTR_ptr",
                "bit": "bit_shift",
                "uint": "uint32_t",
                "upper_bits": "upper_bits",
                "lower_bits": "lower_bits",
                "offset": "offset"
            },
            "code": "void * calculate_memory_address_00001d08(void *PTR_ptr, uintptr_t bit_shift) {\n    uint32_t ptr = (uint32_t) PTR_ptr;\n    uint32_t upper_bits = ptr & 0xf0000000;\n    uint32_t lower_bits = ptr & 0xfffff;\n    uint32_t offset = (lower_bits << 5) + 0x2000000;\n    return (void *) (bit_shift * 4 + upper_bits + offset);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d08",
            "calling": [
                "bit_set32"
            ],
            "imported": false,
            "current_name": "calculate_memory_address_00001d08"
        },
        "FUN_000031fc": {
            "renaming": {
                "FUN_000031fc": "calculate_day_of_week_000031fc",
                "year": "input_year",
                "month": "input_month",
                "day": "input_day",
                "bVar1": "is_leap_year_adjustment",
                "iVar2": "month_adjusted",
                "iVar3": "year_adjusted",
                "DAT_00003280": "leap_year_lookup_constant",
                "PTR_t_00003284": "month_lookup_table",
                "month_lookup_index": "month_lookup_index",
                "month_lookup_value": "month_lookup_value",
                "day_of_week": "day_of_week",
                "century": "century",
                "year_in_century": "year_in_century"
            },
            "code": "int calculate_day_of_week_000031fc(int year, int month, int day) {\n    int month_adjusted;\n    if (month < 3) {\n        month_adjusted = 1;\n    } else {\n        month_adjusted = 0;\n    }\n    int year_adjusted = year - month_adjusted;\n    if (year_adjusted < 0) {\n        year_adjusted += 3;\n    }\n    int century = year_adjusted / 100;\n    int year_in_century = year_adjusted % 100;\n    int month_lookup_index = month - 1;\n    int month_lookup_value = *(int *)(PTR_t_00003284 + month_lookup_index * 4);\n    int day_of_week = day + year_in_century + year_in_century / 4 + century / 4 - 2 * century + month_lookup_value;\n    day_of_week = day_of_week % 7;\n    if (day_of_week < 0) {\n        day_of_week += 7;\n    }\n    return day_of_week;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031fc",
            "calling": [
                "_parse_time"
            ],
            "imported": false,
            "current_name": "calculate_day_of_week_000031fc"
        },
        "FUN_000016ec": {
            "renaming": {
                "FUN_000016ec": "set_bit_in_byte_000016ec",
                "ptr": "byte_ptr",
                "bit": "bit_position",
                "puVar1": "bit_ptr"
            },
            "code": "void set_bit_in_byte_000016ec(uint8_t *byte_ptr, uint8_t bit_position) {\n  uint8_t *bit_ptr = (uint8_t *)(0x42000000 + (((uint32_t)byte_ptr - 0x20000000) * 32) + (bit_position * 4));\n  *bit_ptr = 1;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016ec",
            "calling": [
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_blpe",
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_blpi"
            ],
            "imported": false,
            "current_name": "set_bit_in_byte_000016ec"
        },
        "FUN_00004e8c": {
            "renaming": {
                "_strtol_l_isra_0": "convert_string_to_long_int",
                "param_1": "output",
                "param_2": "input_string",
                "param_3": "end_pointer",
                "param_4": "base",
                "uVar1": "current_char_value",
                "uVar2": "current_char_code",
                "uVar3": "is_negative",
                "uVar4": "max_value",
                "iVar5": "has_overflowed",
                "uVar6": "result",
                "uVar7": "threshold",
                "pbVar8": "current_char_pointer",
                "pbVar9": "temp_pointer",
                "FUN_00004e8c": "convert_string_to_long_int_00004e8c"
            },
            "code": "uint convert_string_to_long_int_00004e8c(undefined4 *output, byte *input_string, byte **end_pointer, uint base) {\n  uint current_char_code;\n  uint current_char_value;\n  uint is_negative = 0;\n  uint max_value = (uint)2147483647;\n  uint result = 0;\n  uint threshold = max_value / base;\n  int has_overflowed = 0;\n  byte *current_char_pointer = input_string;\n  \n  while (1) {\n    current_char_code = (uint)*current_char_pointer;\n    if ((PTR_DAT_00004f7c[current_char_code] & 8) != 0) {\n      break;\n    }\n    if (current_char_code == 45) {\n      is_negative = 1;\n      current_char_pointer++;\n      break;\n    }\n    if (current_char_code == 43) {\n      current_char_pointer++;\n      break;\n    }\n    if (base == 0) {\n      base = 10;\n      break;\n    }\n    if (base == 16 && current_char_code == 48 && ((*current_char_pointer + 1) & 0xdf) == 88) {\n      current_char_pointer += 2;\n      break;\n    }\n    if (base == 0) {\n      base = 8;\n    }\n    current_char_pointer++;\n  }\n  while (1) {\n    current_char_code = (uint)*current_char_pointer;\n    if (current_char_code == 0) {\n      break;\n    }\n    current_char_value = (uint)PTR_DAT_00004f7c[current_char_code] & 7;\n    if (current_char_value >= base) {\n      break;\n    }\n    if (result > threshold || (result == threshold && current_char_value > max_value % base)) {\n      has_overflowed = 1;\n      break;\n    }\n    result = result * base + current_char_value;\n    current_char_pointer++;\n  }\n  if (has_overflowed != 0) {\n    *output = 34;\n    result = max_value;\n    if (end_pointer == (byte **)0x0) {\n      return max_value;\n    }\n  }\n  else {\n    if (is_negative != 0) {\n      result = -result;\n    }\n    if (end_pointer == (byte **)0x0) {\n      return result;\n    }\n    if (has_overflowed == 0 && result != 0) {\n      goto LAB_00004f5f;\n    }\n  }\n  current_char_pointer--;\nLAB_00004f5f:\n  *end_pointer = current_char_pointer;\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e8c",
            "calling": [
                "_strtol_r",
                "strtol"
            ],
            "imported": false,
            "current_name": "convert_string_to_long_int_00004e8c"
        },
        "FUN_00005100": {
            "renaming": {
                "FUN_00005100": "call_impure_ptr_function_00005100",
                "PTR__impure_ptr_00005108": "PTR__impure_ptr"
            },
            "code": "void call_impure_ptr_function_00005100(void)\n{\n  call_impure_ptr_function_00005100_r(*(undefined4 *)PTR__impure_ptr_00005108);\n  return;\n}",
            "called": [
                "_tzset_unlocked_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005100",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "call_impure_ptr_function_00005100"
        },
        "FUN_00005584": {
            "renaming": {
                "FUN_00005584_t": "DivisionResult",
                "FUN_00005584": "divide_00005584",
                "__numer": "dividend",
                "__denom": "divisor",
                "in_r2": "abs_divisor",
                "iVar1": "remainder",
                "uVar2": "quotient"
            },
            "code": "typedef struct {\n                          uint32_t quotient;\n                          int32_t remainder;\n                      } DivisionResult;\n                      \n                      DivisionResult divide_00005584(int32_t divide_00005584nd, int32_t divisor) {\n                          uint32_t abs_divide_00005584nd = abs(divide_00005584nd);\n                          uint32_t abs_divisor = abs(divisor);\n                          uint32_t quotient = abs_divide_00005584nd / abs_divisor;\n                          int32_t remainder = abs_divide_00005584nd % abs_divisor;\n                          if ((divide_00005584nd < 0 && divisor > 0) || (divide_00005584nd > 0 && divisor < 0)) {\n                              quotient = -quotient;\n                          }\n                          if (divide_00005584nd < 0 && divisor < 0) {\n                              remainder = -remainder;\n                          }\n                          DivisionResult result = { quotient, remainder };\n                          return result;\n                      }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005584",
            "calling": [
                "validate_structure"
            ],
            "imported": false,
            "current_name": "divide_00005584"
        },
        "FUN_00000cb0": {
            "renaming": {
                "FUN_00000cb0": "debug_monitor_handler_00000cb0",
                "PTR_s_DEBUG_MON_HANDLER_00000cbc": "debug_mon_handler"
            },
            "code": "void debug_monitor_handler_00000cb0(void)\n{\n    core_panic(PANIC_DEBUG_MON, PTR_s_DEBUG_MON_HANDLER_00000cbc);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cb0",
            "calling": [],
            "imported": false,
            "current_name": "debug_monitor_handler_00000cb0"
        },
        "FUN_00004248": {
            "renaming": {
                "FUN_00004248": "malloc_array_00004248",
                "param_1": "size",
                "param_2": "count",
                "puVar1": "array",
                "iVar2": "array_size"
            },
            "code": "_malloc_r malloc_array_00004248(int size, int count)\n{\n    int array_size = (count - 1) * 0x68;\n    int total_size = array_size + 0x74;\n    undefined4 *array = (undefined4 *)_malloc_r(size, total_size);\n    if (array != (undefined4 *)0x0) {\n        *array = 0;\n        array[1] = count;\n        array[2] = array + 3;\n        memset(array + 3, 0, array_size);\n    }\n    return array;\n}",
            "called": [
                "memset",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004248",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "malloc_array_00004248"
        },
        "FUN_00000f5c": {
            "renaming": {
                "FUN_00000f5c": "run_main_00000f5c",
                "PTR_s_main____This_is_RIOT___Version__2_00000f7c": "main_message",
                "auto_init": "auto_initialize",
                "iprintf": "print_message"
            },
            "code": "void * run_main_00000f5c(void *arg)\n{\n  auto_initialize();\n  print_message(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n  main();\n  return (void *)0x0;\n}",
            "called": [
                "iprintf",
                "main",
                "auto_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f5c",
            "calling": [],
            "imported": false,
            "current_name": "run_main_00000f5c"
        },
        "FUN_00001da2": {
            "renaming": {
                "FUN_00001da2": "get_pin_value_00001da2",
                "pin": "gpio_pin",
                "PTR_": "PTR_ (unchanged)",
                "DAT_": "DAT_ (unchanged)"
            },
            "code": "int get_pin_value_00001da2(gpio_t pin) {\n    int shifted_pin = pin >> 6;\n    int masked_pin = shifted_pin & 7;\n    return masked_pin;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001da2",
            "calling": [
                "clk_en",
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "get_pin_value_00001da2"
        },
        "FUN_00001ec4": {
            "renaming": {
                "FUN_00001ec4": "write_context_to_map_00001ec4",
                "port": "port_number",
                "pin": "pin_number",
                "ctx_00": "context_pointer",
                "ctx": "context_value",
                "get_ctx": "get_context_pointer",
                "write_map": "write_to_map"
            },
            "code": "void write_context_to_map_00001ec4(int port_number, int pin_number)\n{\n  int context_value;\n  int context_pointer;\n  context_pointer = get_context_pointer(port_number, pin_number);\n  write_to_map(port_number, pin_number, context_pointer);\n  return;\n}",
            "called": [
                "write_map",
                "get_ctx"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ec4",
            "calling": [
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "write_context_to_map_00001ec4"
        },
        "FUN_00002744": {
            "renaming": {
                "FUN_00002744": "setInterruptPriority_00002744",
                "IRQn": "interrupt_number",
                "priority": "interrupt_priority",
                "DAT_00002790": "nvic_ipr_offset",
                "DAT_00002794": "nvic_ipr_offset_high"
            },
            "code": "void setInterruptPriority_00002744(IRQn_Type IRQn, uint32_t priority) {\n  if (IRQn < DMA0_IRQn) {\n    char* nvic_ipr = (char*)(((byte)IRQn & 0xf) + DAT_00002790 + 0x14);\n    *nvic_ipr = (char)((priority & 0xff) << 4);\n  }\n  else {\n    char* nvic_ipr = (char*)(IRQn + DAT_00002794 + 0x300);\n    *nvic_ipr = (char)((priority & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002744",
            "calling": [
                "rtt_set_alarm"
            ],
            "imported": false,
            "current_name": "setInterruptPriority_00002744"
        },
        "FUN_00002624": {
            "renaming": {
                "FUN_00002624": "convert_rtt_counter_to_gmtime_00002624",
                "time": "result_time",
                "t": "rtt_counter"
            },
            "code": "int convert_rtt_counter_to_gmtime_00002624(tm *result_time)\n{\n  time_t rtt_counter;\n  rtt_counter._0_4_ = rtt_get_counter();\n  rtt_counter._4_4_ = 0;\n  gmtime_r(&rtt_counter, result_time);\n  return 0;\n}\n",
            "called": [
                "rtt_get_counter",
                "gmtime_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002624",
            "calling": [
                "_rtc_gettime"
            ],
            "imported": false,
            "current_name": "convert_rtt_counter_to_gmtime_00002624"
        },
        "FUN_00001e0c": {
            "renaming": {
                "FUN_00001e0c": "get_pin_value_00001e0c",
                "port": "port_num",
                "pin": "pin_num",
                "PTR_isr_map_00001e40": "isr_map_ptr"
            },
            "code": "uint8_t get_pin_value_00001e0c(uint8_t port, uint8_t pin) {\n    uint32_t offset = ((pin >> 3) + port * 4) * 4;\n    uint32_t* ptr = (uint32_t*)(PTR_isr_map_00001e40 + offset);\n    uint32_t value = *ptr >> ((pin & 7U) << 2) & 0xf;\n    return (uint8_t)value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e0c",
            "calling": [
                "ctx_clear",
                "irq_handler"
            ],
            "imported": false,
            "current_name": "get_pin_value_00001e0c"
        },
        "FUN_00000ef8": {
            "renaming": {
                "FUN_00000ef8": "do_nothing_00000ef8"
            },
            "code": "\nvoid do_nothing_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ef8",
            "calling": [
                "core_panic"
            ],
            "imported": false,
            "current_name": "do_nothing_00000ef8"
        },
        "FUN_000041d0": {
            "renaming": {
                "FUN_000041d0": "walk_file_000041d0",
                "__stream": "file_stream",
                "iVar1": "result",
                "PTR__global_impure_ptr_000041e8": "global_impure_ptr",
                "DAT_000041ec": "DAT_000041ec",
                "_FUN_000041d0_r": "_walk_file_r",
                "PTR__impure_ptr_000041f0": "impure_ptr"
            },
            "code": "int walk_file_000041d0(FILE *file_stream) {\n  int result;\n  if (file_stream == NULL) {\n    result = _fwalk_reent(*PTR__global_PTR__impure_ptr_000041f0_000041e8, DAT_000041ec);\n    return result;\n  }\n  result = _walk_file_000041d0_r(*PTR__impure_ptr_000041f0, file_stream);\n  return result;\n}",
            "called": [
                "_fflush_r",
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041d0",
            "calling": [
                "print_prompt",
                "lflush"
            ],
            "imported": false,
            "current_name": "walk_file_000041d0"
        },
        "FUN_0000459c": {
            "renaming": {
                "FUN_0000459c": "initialize_EVP_PKEY_CTX_0000459c",
                "param_1": "pkey_ctx",
                "puVar1": "undefined_pointer_1",
                "puVar2": "undefined_pointer_2",
                "iVar3": "fini_array_size",
                "ppcVar4": "fini_array_start",
                "iVar5": "i",
                "PTR___fini_array_end_000045d8": "DAT___fini_array_end_000045d8",
                "PTR___fini_array_end_000045d4": "DAT___fini_array_end_000045d4",
                "PTR___fini_array_end_000045e0": "DAT___fini_array_end_000045e0",
                "PTR___fini_array_end_000045dc": "DAT___fini_array_end_000045dc"
            },
            "code": "void initialize_EVP_PKEY_CTX_0000459c(EVP_PKEY_CTX *pkey_ctx)\n{\n    int fini_array_size = (int)PTR___fini_array_end_000045d8 - (int)PTR___fini_array_end_000045d4;\n    code **fini_array_start = (code **)PTR___fini_array_end_000045d4;\n    for (int i = 0; i < fini_array_size / 4; i++) {\n        pkey_ctx = (EVP_PKEY_CTX *)(*fini_array_start)();\n        fini_array_start++;\n    }\n    _init(pkey_ctx);\n    code **fini_array_end = (code **)PTR___fini_array_end_000045e0;\n    fini_array_start = (code **)PTR___fini_array_end_000045dc;\n    for (int i = 0; i < (int)fini_array_end - (int)fini_array_start >> 2; i++) {\n        (*(*fini_array_start)())();\n        fini_array_start++;\n    }\n}",
            "called": [
                "_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000459c",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "initialize_EVP_PKEY_CTX_0000459c"
        },
        "FUN_000014c4": {
            "renaming": {
                "FUN_000014c4": "configure_uart_000014c4",
                "uart": "UART_Type",
                "baudrate": "uint32_t",
                "pbVar1": "config_ptr",
                "uVar2": "config_value",
                "uVar3": "ubd",
                "txfifo_size": "txfifo_size",
                "brfa": "brfa",
                "ubd": "ubd",
                "clk": "clk",
                "dev": "dev",
                "PTR_uart_config_000015cc": "uart_config_ptr"
            },
            "code": "void configure_uart_000014c4(UART_Type uart, uint32_t baudrate) {\n  byte *config_ptr;\n  uint32_t config_value;\n  uint8_t txfifo_size;\n  uint8_t brfa;\n  uint16_t ubd;\n  uint32_t clk;\n  UART_Type *dev;\n  \n  config_ptr = *(byte **)(PTR_uart_config_000015cc + uart * 0x20);\n  config_value = *(uint32_t *)(PTR_uart_config_000015cc + uart * 0x20 + 4);\n  config_ptr[3] = config_ptr[3] & 0xf3;\n  config_ptr[2] = PTR_uart_config_000015cc[uart * 0x20 + 0x1d];\n  ubd = config_value / (baudrate << 4);\n  *config_ptr = (byte)(ubd >> 8) & 0x1f;\n  config_ptr[1] = (byte)ubd;\n  config_ptr[10] = (byte)((config_value << 2) / baudrate + 1 >> 1) & 0x1f;\n  config_ptr[0x10] = config_ptr[0x10] | 0x88;\n  if ((config_ptr[0x10] & 0x70) == 0) {\n    config_ptr[0x13] = 0;\n  }\n  else {\n    config_ptr[0x13] = (char)(2 << (config_ptr[0x10] >> 4 & 7)) - 1;\n  }\n  config_ptr[0x15] = 1;\n  config_ptr[0x11] = 0xc0;\n  config_ptr[3] = config_ptr[3] | 0x2c;\n  NVIC_EnableIRQ(PTR_uart_config_000015cc[uart * 0x20 + 0x14]);\n  return;\n}",
            "called": [
                "NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000014c4",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "configure_uart_000014c4"
        },
        "FUN_00004b34": {
            "renaming": {
                "FUN_00004b34": "add_to_malloc_list_00004b34",
                "param_1": "unk1",
                "param_2": "size",
                "param_3": "unk2",
                "param_4": "unk3",
                "puVar1": "malloc_list_ptr",
                "piVar2": "end_ptr",
                "extraout_r1": "unk4",
                "ppiVar3": "unk5",
                "ppiVar4": "prev_ppiVar",
                "ppiVar5": "curr_ppiVar",
                "ppiVar6": "unk6",
                "bVar7": "found"
            },
            "code": "void add_to_malloc_list_00004b34(int* mem_ptr, int size, int* unk1, int* unk2)\n{\n    int **prev_ppiVar = NULL;\n    int **curr_ppiVar = (int **)(size + -4);\n    if (*curr_ppiVar < 0) {\n        curr_ppiVar = (int **)((int)curr_ppiVar + *curr_ppiVar);\n    }\n    __malloc_lock();\n    int **ppiVar5 = *(int ***)PTR___malloc_free_list_00004bcc;\n    while (ppiVar5 != NULL && ppiVar5 <= curr_ppiVar) {\n        prev_ppiVar = ppiVar5;\n        ppiVar5 = (int **)ppiVar5[1];\n    }\n    curr_ppiVar[1] = (int *)ppiVar5;\n    if (prev_ppiVar != NULL) {\n        int **prev_end = (int **)((int)prev_ppiVar + (int)*prev_ppiVar);\n        if (prev_end == curr_ppiVar) {\n            *prev_ppiVar = (int *)(*prev_ppiVar + *curr_ppiVar);\n            if (ppiVar5 == prev_end) {\n                ppiVar5 = (int **)ppiVar5[1];\n                int *piVar2 = *ppiVar5;\n                prev_ppiVar[1] = ppiVar5[1];\n                *prev_ppiVar = (int *)(*prev_ppiVar + piVar2);\n            }\n        }\n        else {\n            prev_ppiVar[1] = (int *)curr_ppiVar;\n        }\n    }\n    else {\n        *(int ***)PTR___malloc_free_list_00004bcc = curr_ppiVar;\n    }\n    __malloc_unlock(unk1, curr_ppiVar, prev_ppiVar, unk2);\n}\n",
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004b34",
            "calling": [
                "__ssrefill_r",
                "_realloc_r",
                "__srefill_r",
                "__sflush_r",
                "free",
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "add_to_malloc_list_00004b34"
        },
        "FUN_000004f2": {
            "renaming": {
                "FUN_000004f2": "file_seek_000004f2",
                "r": "reent",
                "fd": "file_descriptor",
                "pos": "position",
                "dir": "direction"
            },
            "code": "_off_t file_seek_000004f2(_reent *reent, int file_descriptor, _off_t position, int direction) {\n  reent->_errno = 0x13;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004f2",
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "imported": false,
            "current_name": "file_seek_000004f2"
        },
        "FUN_0000423c": {
            "renaming": {
                "FUN_0000423c": "walk_reentrant_functions_0000423c",
                "param_1": "reentrancy_structure",
                "_fwalk_reent": "_walk_reentrant_functions",
                "DAT_00004244": "global_reentrancy_structure"
            },
            "code": "void walk_reentrant_functions_0000423c(void* reentrancy_structure)\n{\n  _fwalk_reent(reentrancy_structure, DAT_00004244);\n  return;\n}",
            "called": [
                "_fwalk_reent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000423c",
            "calling": [],
            "imported": false,
            "current_name": "walk_reentrant_functions_0000423c"
        },
        "FUN_00004e66": {
            "renaming": {
                "FUN_00004e66": "compare_strings_00004e66",
                "__s1": "string1",
                "__s2": "string2",
                "__n": "length",
                "pbVar1": "current_char1",
                "pbVar2": "current_char2",
                "uVar3": "current_char1_value"
            },
            "code": "int compare_strings_00004e66(char* string1, char* string2, size_t length){\n    byte *current_char2;\n    byte *current_char1;\n    uint current_char1_value;\n    uint current_char2_value;\n    current_char2 = (byte *)(string2 + length - 1);\n    current_char1 = (byte *)string1;\n    if (length != 0) {\n        do {\n            current_char1_value = (uint)*current_char1;\n            current_char2_value = (uint)*current_char2;\n            current_char2++;\n            current_char1++;\n            if ((current_char1_value != current_char2_value) || (current_char1 == (byte *)(string1 + length))) {\n                break;\n            }\n        } while (current_char1_value != 0);\n        length = current_char1_value - current_char2_value;\n    }\n    return length;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e66",
            "calling": [
                "_findenv_r",
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "compare_strings_00004e66"
        },
        "FUN_00005ecc": {
            "renaming": {
                "FUN_00005ecc": "length_of_string_00005ecc",
                "__s": "str",
                "pcVar3": "current_ptr",
                "pcVar2": "next_ptr",
                "cVar1": "current_char"
            },
            "code": "size_t length_of_string_00005ecc(char* str) {\n  char current_char;\n  char* current_ptr = str;\n  while (current_char = *current_ptr) {\n    current_ptr++;\n  }\n  return (size_t)(current_ptr - str);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ecc",
            "calling": [
                "_tzset_unlocked_r",
                "siscanf"
            ],
            "imported": false,
            "current_name": "length_of_string_00005ecc"
        },
        "FUN_0000129c": {
            "renaming": {
                "_FUN_0000129c": "lock_mutex",
                "mutex": "mutex",
                "1": "ACQUIRE_MUTEX",
                "FUN_0000129c": "lock_mutex_0000129c"
            },
            "code": "void lock_mutex_0000129c(mutex_t *mutex)\n{\n  acquire_mutex(mutex);\n  return;\n}",
            "called": [
                "_mutex_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000129c",
            "calling": [
                "isrpipe_read"
            ],
            "imported": false,
            "current_name": "lock_mutex_0000129c"
        },
        "FUN_00001628": {
            "renaming": {
                "FUN_00001628": "process_uart_00001628",
                "uart": "uart_t",
                "data": "data",
                "dev": "uart_type",
                "PTR_uart_config_00001680": "PTR_uart_config",
                "PTR_config_00001684": "PTR_config"
            },
            "code": "void process_uart_00001628(uart_t uart) {\n  uint8_t data;\n  UART_Type *uart_type = (UART_Type *)(*(int *)(PTR_uart_config_00001680_00001680 + uart * 0x20));\n  uint8_t *uart_config = (uint8_t *)(uart_type + 4);\n  void **config = (void **)(PTR_config_00001684_00001684 + uart * 8);\n  if ((*uart_config & 0x20) && (*config != NULL)) {\n    ((void (*)(uint32_t, uint8_t))(*config[0]))(config[1], *(uint8_t *)(uart_type + 7));\n  }\n  cortexm_isr_end();\n}\n",
            "called": [
                "cortexm_isr_end"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001628",
            "calling": [
                "isr_uart0_rx_tx"
            ],
            "imported": false,
            "current_name": "process_uart_00001628"
        },
        "FUN_00001748": {
            "renaming": {
                "FUN_00001748": "update_fll_factor_00001748",
                "factor": "new_factor",
                "DAT_00001774": "PTR_DAT_00001774",
                "KINETIS_MCG_FLL_FACTOR_2929": "MASK_KINETIS_MCG_FLL_FACTOR_2929"
            },
            "code": "void update_fll_factor_00001748(kinetis_mcg_fll_t new_factor) {\n    kinetis_mcg_fll_t *fll_factor_ptr = (kinetis_mcg_fll_t *)(DAT_00001774 + 3);\n    kinetis_mcg_fll_t old_factor = *fll_factor_ptr;\n    kinetis_mcg_fll_t mask = ~KINETIS_MCG_FLL_FACTOR_2929;\n    *fll_factor_ptr = (new_factor | (old_factor & mask));\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001748",
            "calling": [
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fbe"
            ],
            "imported": false,
            "current_name": "update_fll_factor_00001748"
        },
        "FUN_0000294c": {
            "renaming": {
                "FUN_0000294c": "set_rtc_time_enabled_flag_0000294c",
                "*rtt": "*rtc",
                "*(uint *)(DAT_0000296c + 0x14)": "*flag"
            },
            "code": "void set_rtc_time_enabled_flag_0000294c(void)\n{\n  RTC_Type *rtc = PTR_0000296c;\n  uint32_t *(uint *)(DAT_0000296c + 0x14) = &(DAT_0000296c + 0x14);\n  *(uint *)(DAT_0000296c + 0x14) |= 0x10;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000294c",
            "calling": [
                "rtt_init",
                "rtc_poweron"
            ],
            "imported": false,
            "current_name": "set_rtc_time_enabled_flag_0000294c"
        },
        "FUN_00005790": {
            "renaming": {
                "FUN_00005790": "acquire_malloc_recursive_mutex_00005790",
                "PTR___lock___malloc_recursive_mutex_00005798": "PTR_malloc_recursive_mutex"
            },
            "code": "void acquire_malloc_recursive_mutex_00005790(void)\n{\n  __retarget_lock_acquire_recursive(PTR___lock___malloc_recursive_mutex_00005798);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005790",
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "acquire_malloc_recursive_mutex_00005790"
        },
        "FUN_00000534": {
            "renaming": {
                "FUN_00000534": "check_standard_io_00000534",
                "r": "reent",
                "fd": "file_descriptor",
                "iVar1": "is_standard_io"
            },
            "code": "int check_standard_io_00000534(_reent *reent, int file_descriptor) {\n  int is_standard_io = 0;\n\n  reent->_errno = 0;\n\n  if (file_descriptor == 0 || file_descriptor == 1 || file_descriptor == 2) {\n    is_standard_io = 1;\n  }\n\n  return is_standard_io;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000534",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_standard_io_00000534"
        },
        "FUN_000017dc": {
            "renaming": {
                "FUN_000017dc": "set_bit_and_check_for_flag_000017dc",
                "DAT_00001820": "bit_array",
                "DAT_00001824": "data_pointer",
                "DAT_00001828": "memory_pointer"
            },
            "code": "void set_bit_and_check_for_flag_000017dc(void)\n{\n  set_bit(DAT_00001820, 0x1d);\n  if ((*(uint *)(DAT_00001824 + 0x10) & 0x100) == 0) {\n    *(uint *)(DAT_00001824 + 0x10) = 0x104;\n  }\n  *DAT_00001828 = (*DAT_00001828 & 0xfff3ffff) | 0x80000;\n  return;\n}",
            "called": [
                "bit_set32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000017dc",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "set_bit_and_check_for_flag_000017dc"
        },
        "FUN_00000410": {
            "renaming": {
                "FUN_00000410": "initialize_EVP_PKEY_CTX_00000410",
                "ctx": "context",
                "uart_stdioFUN_00000410": "initialize_uart_stdio"
            },
            "code": "int initialize_EVP_PKEY_CTX_00000410(EVP_PKEY_CTX *context)\n{\n  initialize_uart_stdio();\n  return (int)context;\n}",
            "called": [
                "uart_stdio_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000410",
            "calling": [
                "__libc_init_array"
            ],
            "imported": false,
            "current_name": "initialize_EVP_PKEY_CTX_00000410"
        },
        "FUN_000005ca": {
            "renaming": {
                "FUN_000005ca": "remove_second_node_000005ca",
                "list": "list_head",
                "plVar1": "second_node",
                "first": "unused_variable",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "clist_node_t* remove_second_node_000005ca(clist_node_t* list)\n{\n    list_node* second_node = list->next;\n    if (second_node == (list_node*)0x0)\n    {\n        return (clist_node_t*)0x0;\n    }\n    list_node* next_node = second_node->next;\n    if (next_node == second_node)\n    {\n        list->next = (list_node*)0x0;\n    }\n    else\n    {\n        list->next->next = next_node;\n    }\n    return second_node;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000005ca",
            "calling": [
                "sched_set_status"
            ],
            "imported": false,
            "current_name": "remove_second_node_000005ca"
        },
        "FUN_000043da": {
            "renaming": {
                "FUN_000043da": "process_data_000043da",
                "param_1": "data_ptr",
                "param_2": "process_func",
                "param_3": "arg1",
                "param_4": "arg2",
                "piVar3": "data_entry_ptr",
                "uVar5": "result",
                "iVar6": "entry_count",
                "iVar4": "entry_ptr",
                "uVar1": "process_result",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "uint process_data_000043da(int data_ptr, code* process_func, undefined4 arg1, undefined4 arg2)\n{\n  uint result = 0;\n  int* data_entry_ptr = (int*)(data_ptr + 0x48);\n  do {\n    int entry_count = data_entry_ptr[1];\n    int entry_ptr = data_entry_ptr[2];\n    while (entry_count-- > 0) {\n      ushort entry_type = *(ushort*)(entry_ptr + 0xc);\n      if (entry_type > 1) {\n        int entry_size = *(short*)(entry_ptr + 0xe) + 1;\n        if (entry_size != 0) {\n          uint process_result = (*process_func)(data_ptr, entry_ptr, arg1, entry_size, arg2);\n          result |= process_result;\n        }\n      }\n      entry_ptr += 0x68;\n    }\n    data_entry_ptr = (int*)*data_entry_ptr;\n  } while (data_entry_ptr != (int*)0x0);\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043da",
            "calling": [
                "_cleanup_r",
                "fflush"
            ],
            "imported": false,
            "current_name": "process_data_000043da"
        },
        "FUN_00005ff8": {
            "renaming": {
                "FUN_00005ff8": "release_recursive_mutex_00005ff8"
            },
            "code": "void release_recursive_mutex_00005ff8(void)\n{\n    __retarget_lock_release_recursive(PTR___lock___env_recursive_mutex_00006000);\n    return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ff8",
            "calling": [
                "_findenv_r"
            ],
            "imported": false,
            "current_name": "release_recursive_mutex_00005ff8"
        },
        "FUN_00006754": {
            "renaming": {
                "FUN_00006754": "flush_file_00006754",
                "param_1": "file",
                "iVar1": "flush_result"
            },
            "code": "int flush_file_00006754(FILE *file) {\n  int flush_result;\n  if ((*(unsigned short *)&file->_IO_read_base & 9) == 9) {\n    flush_result = fflush(file);\n    return flush_result;\n  }\n  return 0;\n}",
            "called": [
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006754",
            "calling": [],
            "imported": false,
            "current_name": "flush_file_00006754"
        },
        "FUN_00002714": {
            "renaming": {
                "FUN_00002714": "set_interrupt_bit_00002714",
                "IRQn": "irq",
                "DAT_00002740": "interrupt_register_base",
                "int": "int",
                "uint": "unsigned int",
                "interrupt_reg": "interrupt_register",
                "bit_position": "interrupt_bit_position",
                "bit_mask": "interrupt_bit_mask"
            },
            "code": "void set_interrupt_bit_00002714(IRQn_Type irq)\n{\n  int* interrupt_reg = (int*)(DAT_00002740 + ((uint)(int)irq >> 5) * 4);\n  int bit_position = irq & 0x1fU;\n  int bit_mask = 1 << bit_position;\n  *interrupt_reg = bit_mask;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002714",
            "calling": [
                "rtt_set_alarm"
            ],
            "imported": false,
            "current_name": "set_interrupt_bit_00002714"
        },
        "FUN_000020e0": {
            "renaming": {
                "FUN_000020e0": "handle_interrupt_000020e0",
                "DAT_000020f0": "interrupt_number",
                "2": "interrupt_number",
                "irq_handler": "irq_handler"
            },
            "code": "void handle_interrupt_000020e0(void)\n{\n  int DAT_000020f0 = 2;\n  irq_handler(DAT_000020f0);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020e0",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_000020e0"
        },
        "FUN_00004f80": {
            "renaming": {
                "FUN_00004f80": "convert_string_to_int_00004f80",
                "param_1": "out_value",
                "param_2": "input_string",
                "param_3": "end_of_parsed_input",
                "param_4": "base",
                "uVar1": "parsed_value",
                "uVar2": "digit_char",
                "uVar3": "char_flags",
                "uVar4": "digit_value",
                "uVar5": "parse_result",
                "uVar6": "max_value",
                "uVar7": "divisor",
                "iVar5": "parse_error",
                "pbVar8": "current_char",
                "pbVar9": "next_char"
            },
            "code": "uint convert_string_to_int_00004f80(undefined4 *out_value, byte *input_string, byte **end_of_parsed_input, uint base)\n{\n  uint parsed_value = 0;\n  uint is_negative = 0;\n  uint is_hex = 0;\n  byte *current_char = input_string;\n\n  // Skip leading whitespace\n  while (*current_char == ' ' || *current_char == '\\t' || *current_char == '\\n' || *current_char == '\\r')\n  {\n    current_char++;\n  }\n\n  // Check for sign\n  if (*current_char == '-')\n  {\n    is_negative = 1;\n    current_char++;\n  }\n  else if (*current_char == '+')\n  {\n    current_char++;\n  }\n\n  // Check for hex prefix\n  if (base == 0)\n  {\n    if (*current_char == '0' && (*(current_char + 1) == 'x' || *(current_char + 1) == 'X'))\n    {\n      is_hex = 1;\n      base = 16;\n      current_char += 2;\n    }\n    else\n    {\n      base = 10;\n    }\n  }\n\n  // Parse digits\n  while (1)\n  {\n    uint digit_value;\n    if (*current_char >= '0' && *current_char <= '9')\n    {\n      digit_value = *current_char - '0';\n    }\n    else if (*current_char >= 'A' && *current_char <= 'Z')\n    {\n      digit_value = *current_char - 'A' + 10;\n    }\n    else if (*current_char >= 'a' && *current_char <= 'z')\n    {\n      digit_value = *current_char - 'a' + 10;\n    }\n    else\n    {\n      break;\n    }\n\n    if (digit_value >= base)\n    {\n      break;\n    }\n\n    if (is_negative)\n    {\n      if (parsed_value < (0x80000000 + digit_value) / base)\n      {\n        *out_value = 0;\n        return 0x7fffffff;\n      }\n      parsed_value = parsed_value * base - digit_value;\n    }\n    else\n    {\n      if (parsed_value > 0x7fffffff / base || parsed_value * base + digit_value < parsed_value)\n      {\n        *out_value = 0xffffffff;\n        return 0x7fffffff;\n      }\n      parsed_value = parsed_value * base + digit_value;\n    }\n\n    current_char++;\n  }\n\n  if (end_of_parsed_input != 0)\n  {\n    *end_of_parsed_input = current_char;\n  }\n\n  if (is_negative)\n  {\n    parsed_value = -parsed_value;\n  }\n\n  *out_value = parsed_value;\n  return 0;\n}",
            "called": [
                "_strtol_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f80",
            "calling": [],
            "imported": false,
            "current_name": "convert_string_to_int_00004f80"
        },
        "FUN_00005fec": {
            "renaming": {
                "FUN_00005fec": "acquire_recursive_lock_00005fec",
                "PTR___lock___env_recursive_mutex_00005ff4": "env_recursive_mutex"
            },
            "code": "void acquire_recursive_lock_00005fec(void)\n{\n  __retarget_lock_acquire_recursive(PTR___lock___env_recursive_mutex_00005ff4);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fec",
            "calling": [
                "_findenv_r"
            ],
            "imported": false,
            "current_name": "acquire_recursive_lock_00005fec"
        },
        "FUN_00004f84": {
            "renaming": {
                "FUN_00004f84": "convertStringToLong_00004f84",
                "__nptr": "inputString",
                "__endptr": "endPtr",
                "__base": "base",
                "lVar1": "result"
            },
            "code": "long convertStringToLong_00004f84(char* inputString, char** endPtr, int base) {\n  long result = strtol(*(undefined4 *)PTR__impure_ptr_00004f94, inputString, endPtr, base);\n  return result;\n}",
            "called": [
                "_strtol_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f84",
            "calling": [
                "atoi",
                "_parse_time"
            ],
            "imported": false,
            "current_name": "convertStringToLong_00004f84"
        },
        "FUN_000028f0": {
            "renaming": {
                "FUN_000028f0": "get_RTC_Type_time_000028f0",
                "rtt": "rtc_type_ptr",
                "DAT_0000290c": "PTR_0000290c"
            },
            "code": "uint32_t get_RTC_Type_time_000028f0(void)\n{\n  RTC_Type *rtc_type_ptr = (RTC_Type *) DAT_0000290c;\n  uint32_t time = *(uint32_t *)(rtc_type_ptr + 8) + 1;\n  return time;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000028f0",
            "calling": [
                "rtc_get_alarm"
            ],
            "imported": false,
            "current_name": "get_RTC_Type_time_000028f0"
        },
        "FUN_00004f98": {
            "renaming": {
                "FUN_00004f98": "calculate_day_of_week_00004f98",
                "param_1": "year",
                "puVar1": "time_zone_info",
                "uVar2": "day_of_week",
                "uVar3": "day_of_year",
                "iVar4": "leap_year_adjustment",
                "puVar5": "calendar_info",
                "iVar6": "month_index",
                "uVar7": "month_length",
                "iVar8": "days_since_jan1",
                "iVar9": "days_since_last_sunday",
                "uVar10": "i",
                "DAT_000050e0": "leap_year_adjustment",
                "PTR___month_lengths_000050e4": "month_lengths"
            },
            "code": "uint calculate_day_of_week_00004f98(uint year)\n{\n  uint *time_zone_info;\n  uint day_of_week;\n  uint day_of_year;\n  uint DAT_000050e0;\n  uint month_index;\n  uint month_length;\n  uint days_since_jan1;\n  uint days_since_last_sunday;\n  uint *calendar_info;\n  uint i;\n  uint total_days_elapsed;\n  time_zone_info = (uint *)__gettzinfo();\n  if (year < 0x7b2) {\n    return 0;\n  }\n  else {\n    DAT_000050e0 = count_leading_zeroes(year % 400);\n    day_of_year = (year - 0x7b2) * 365 + (year - 0x76d) / 0xffffff9c + (year - 0x641) / 400;\n    calendar_info = time_zone_info;\n    for (i = 0; i < 14; i++) {\n      month_index = calendar_info[5];\n      if (month_index == 1) {\n        if ((((year & 3) == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n          month_length = 29;\n        }\n        else {\n          month_length = 28;\n        }\n      }\n      else {\n        month_length = *(int *)(PTR___PTR___month_lengths_000050e4_000050e4 + (month_index - 1) * 4 + ((DAT_000050e0 >> 5) * 0x30) - 4);\n      }\n      days_since_jan1 = day_of_year + calendar_info[6] - 1;\n      days_since_last_sunday = (days_since_jan1 - (days_since_jan1 / 7) * 7) - calendar_info[4];\n      if (days_since_last_sunday < 0) {\n        days_since_last_sunday += 7;\n      }\n      day_of_week = (calendar_info[10] + DAT_000050e0 * day_of_year + calendar_info[8] + days_since_jan1 + days_since_last_sunday) % 7;\n      calendar_info[8] = day_of_week;\n      calendar_info[9] = (int)day_of_week >> 0x1f;\n      calendar_info += 10;\n    }\n    total_days_elapsed = time_zone_info[9] - time_zone_info[0x13] - (uint)(time_zone_info[8] < time_zone_info[0x12]);\n    return (uint)((int)(total_days_elapsed - (total_days_elapsed < 0)) < 0 != ((total_days_elapsed - time_zone_info[0x13]) < 0 != (total_days_elapsed - time_zone_info[0x13] - (uint)(time_zone_info[8] < time_zone_info[0x12])) < 0));\n  }\n}",
            "called": [
                "__gettzinfo"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f98",
            "calling": [
                "mktime",
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "calculate_day_of_week_00004f98"
        },
        "FUN_00004dee": {
            "renaming": {
                "FUN_00004dee": "write_if_offset_positive_00004dee",
                "param_1": "reent_ptr",
                "param_2": "offset_ptr",
                "param_3": "data_ptr",
                "param_4": "data_size",
                "ushort": "uint16_t",
                "int": "int32_t",
                "size_t": "size_t",
                "_lseek_r": "_lseek_r",
                "short": "int16_t",
                "_write_r": "_write_r"
            },
            "code": "void write_if_offset_positive_00004dee(_reent *reent_ptr, int offset_ptr, void *data_ptr, size_t data_size) {\n    uint16_t offset = *(uint16_t *)(offset_ptr + 0xc);\n    if ((int)(offset << 0x17) < 0) {\n        _lseek_r(reent_ptr, *(int16_t *)(offset_ptr + 0xe), 0, 2);\n    }\n    *(uint16_t *)(offset_ptr + 0xc) = offset & 0xefff;\n    _write_r(reent_ptr, *(int16_t *)(offset_ptr + 0xe), data_ptr, data_size);\n}",
            "called": [
                "_lseek_r",
                "_write_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dee",
            "calling": [],
            "imported": false,
            "current_name": "write_if_offset_positive_00004dee"
        },
        "FUN_00000fec": {
            "renaming": {
                "FUN_00000fec": "initialize_circular_buffer_00000fec",
                "cib_t": "circular_buffer_t",
                "size": "uint32_t size",
                "c": "circular_buffer_t c",
                "PTR_assert_crash_message_00001030": "PTR_assert_crash_message_00001030"
            },
            "code": "void initialize_circular_buffer_00000fec(circular_buffer_t *buffer, uint32_t size) {\n  if ((size & (size - 1)) != 0) {\n    core_panic(PANIC_ASSERT_FAIL, PTR_assert_crash_message_00001030);\n  }\n  buffer->read_count = 0;\n  buffer->write_count = 0;\n  buffer->mask = size - 1;\n  return;\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000fec",
            "calling": [
                "thread_create"
            ],
            "imported": false,
            "current_name": "initialize_circular_buffer_00000fec"
        },
        "FUN_00000428": {
            "renaming": {
                "FUN_00000428": "allocate_memory_00000428",
                "r": "reent",
                "incr": "increment",
                "state_00": "disable_interrupts_state",
                "state": "interrupt_state",
                "res": "result",
                "PTR_heap_top_00000484": "PTR_heap_top_00000484",
                "PTR__eram_00000488": "PTR__eram_00000488",
                "PTR__sheap_0000048c": "PTR__sheap_0000048c"
            },
            "code": "void * allocate_memory_00000428(_reent *reent, ptrdiff_t increment)\n{\n  uint disable_interrupts_state;\n  uint interrupt_state;\n  void *result;\n  \n  disable_interrupts_state = disable_interrupts();\n  result = *(void **)PTR_heap_top_00000484;\n  if ((PTR__eram_00000488 < (undefined *)(increment + *(int *)PTR_heap_top_00000484)) ||\n     ((undefined *)(increment + *(int *)PTR_heap_top_00000484) < PTR__sheap_0000048c)) {\n    reent->_errno = 0xc;\n    result = (void *)0xffffffff;\n  }\n  else {\n    *(ptrdiff_t *)PTR_heap_top_00000484 = increment + *(int *)PTR_heap_top_00000484;\n  }\n  restore_interrupts(disable_interrupts_state);\n  return result;\n}",
            "called": [
                "irq_disable",
                "irq_restore"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000428",
            "calling": [
                "_malloc_r"
            ],
            "imported": false,
            "current_name": "allocate_memory_00000428"
        },
        "FUN_000039e8": {
            "renaming": {
                "FUN_000039e8": "getClassDescription_000039e8",
                "class_id": "classId",
                "pcVar1": "description"
            },
            "code": "char * getClassDescription_000039e8(uint8_t classId)\n{\n    char *description = PTR_s_CLASS_UNKNOWN_00003d20;\n    switch(classId) {\n        case '\\0':\n            description = PTR_s_CLASS_UNDEF_00003cc0;\n            break;\n        case '@':\n            description = PTR_s_ACT_ANY_00003cc4;\n            break;\n        case 'B':\n            description = PTR_s_ACT_LED_RGB_00003cc8;\n            break;\n        case 'C':\n            description = PTR_s_ACT_SERVO_00003ccc;\n            break;\n        case 'D':\n            description = PTR_s_ACT_MOTOR_00003cd0;\n            break;\n        case 'E':\n            description = PTR_s_ACT_SWITCH_00003cd4;\n            break;\n        case 'F':\n            description = PTR_s_ACT_DIMMER_00003cd8;\n            break;\n        case 0x80:\n            description = PTR_s_SENSE_ANY_00003cdc;\n            break;\n        case 0x81:\n            description = PTR_s_SENSE_BTN_00003ce0;\n            break;\n        case 0x82:\n            description = PTR_s_SENSE_TEMP_00003ce4;\n            break;\n        case 0x83:\n            description = PTR_s_SENSE_HUM_00003ce8;\n            break;\n        case 0x84:\n            description = PTR_s_SENSE_LIGHT_00003cec;\n            break;\n        case 0x85:\n            description = PTR_s_SENSE_ACCEL_00003cf0;\n            break;\n        case 0x86:\n            description = PTR_s_SENSE_MAG_00003cf4;\n            break;\n        case 0x87:\n            description = PTR_s_SENSE_GYRO_00003cf8;\n            break;\n        case 0x88:\n            description = PTR_s_SENSE_COLOR_00003cfc;\n            break;\n        case 0x89:\n            description = PTR_s_SENSE_PRESS_00003d00;\n            break;\n        case 0x8a:\n            description = PTR_s_SENSE_ANALOG_00003d04;\n            break;\n        case 0x8b:\n            description = PTR_s_SENSE_UV_00003d08;\n            break;\n        case 0x8c:\n            description = PTR_s_SENSE_OBJTEMP_00003d0c;\n            break;\n        case 0x8d:\n            description = PTR_s_SENSE_PULSE_COUNT_00003d10;\n            break;\n        case 0x8e:\n            description = PTR_s_SENSE_DISTANCE_00003d14;\n            break;\n        case 0x8f:\n            description = PTR_s_SENSE_CO2_00003d18;\n            break;\n        case 0xff:\n            description = PTR_s_CLASS_ANY_00003d1c;\n            break;\n        default:\n            break;\n    }\n    return description;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000039e8",
            "calling": [
                "probe",
                "list"
            ],
            "imported": false,
            "current_name": "getClassDescription_000039e8"
        },
        "FUN_00000e38": {
            "renaming": {
                "FUN_00000e38": "write_to_uart_00000e38",
                "buffer": "buffer",
                "len": "buffer_length",
                "uart_write": "uart_write",
                "uint8_t": "uint8_t",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int write_to_uart_00000e38(char *buffer, int buffer_length)\n{\n  uart_write(0, (uint8_t *)buffer, buffer_length);\n  return buffer_length;\n}",
            "called": [
                "uart_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e38",
            "calling": [
                "_write_r"
            ],
            "imported": false,
            "current_name": "write_to_uart_00000e38"
        },
        "FUN_00002294": {
            "renaming": {
                "FUN_00002294": "count_unread_messages_00002294",
                "rb": "ring_buffer",
                "uVar2": "buffer_size",
                "bVar3": "buffer_full",
                "bVar1": "unread_count"
            },
            "code": "uint32_t count_unread_messages_00002294(tsrb_t *ring_buffer) {\n  uint32_t buffer_size = ring_buffer->size;\n  bool buffer_full = (ring_buffer->writes - ring_buffer->reads == buffer_size);\n  if (buffer_full) {\n    buffer_size = 1;\n  }\n  uint8_t unread_count = buffer_full ? 1 : 0;\n  return unread_count;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002294",
            "calling": [
                "tsrb_add_one"
            ],
            "imported": false,
            "current_name": "count_unread_messages_00002294"
        },
        "FUN_00003e9e": {
            "renaming": {
                "FUN_00003e9e": "format_s32_decimal_fixed_point_00003e9e",
                "out": "output_buffer",
                "val": "input_value",
                "fp_digits": "fixed_point_digits",
                "sVar1": "output_size"
            },
            "code": "size_t format_s32_decimal_fixed_point_00003e9e(char *output_buffer, int16_t input_value, int fixed_point_digits) {\n  size_t output_size = fmt_s32_dfp(output_buffer, (int)input_value, fixed_point_digits);\n  return output_size;\n}",
            "called": [
                "fmt_s32_dfp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e9e",
            "calling": [
                "phydat_dump"
            ],
            "imported": false,
            "current_name": "format_s32_decimal_fixed_point_00003e9e"
        },
        "FUN_00003378": {
            "renaming": {
                "FUN_00003378": "print_time_00003378",
                "time": "time_struct",
                "PTR_s__04i__02i__02i__02i__02i__02i_000033bc": "iprintf_format_string",
                "time->tm_year": "year",
                "time->tm_mon": "month",
                "time->tm_mday": "day",
                "time->tm_hour": "hour",
                "time->tm_min": "minute",
                "time->tm_sec": "second"
            },
            "code": "int print_time_00003378(tm *time_struct)\n{\n  int year = time_struct->tm_year + 1900;\n  int month = time_struct->tm_mon + 1;\n  int day = time_struct->tm_mday;\n  int hour = time_struct->tm_hour;\n  int minute = time_struct->tm_min;\n  int second = time_struct->tm_sec;\n  iprintf(\"The current time is: %04d-%02d-%02d %02d:%02d:%02d\", year, month, day, hour, minute, second);\n  return 0;\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003378",
            "calling": [
                "_rtc_getalarm",
                "_rtc_gettime"
            ],
            "imported": false,
            "current_name": "print_time_00003378"
        },
        "FUN_00006768": {
            "renaming": {
                "FUN_00006768": "processFile_00006768",
                "param_1": "filePointer",
                "param_2": "streamPointer",
                "param_3": "fileSize",
                "param_4": "mode",
                "uVar1": "flags",
                "iVar2": "result",
                "uVar3": "bufferLength",
                "uVar4": "fileFlags",
                "uVar5": "fileLength"
            },
            "code": "undefined4 processFile_00006768(undefined4 *filePointer, undefined4 *streamPointer, undefined4 fileSize, undefined4 mode) {\n    undefined2 flags;\n    int result;\n    undefined4 bufferLength;\n    ushort fileFlags;\n    uint fileLength;\n    \n    if ((filePointer != (undefined4 *)0x0) && (filePointer[6] == 0)) {\n        __sinit();\n    }\n    if (streamPointer == (undefined4 *)PTR___sf_fake_stdin_00006868) {\n        streamPointer = (undefined4 *)filePointer[1];\n    }\n    else if (streamPointer == (undefined4 *)PTR___sf_fake_stdout_0000686c) {\n        streamPointer = (undefined4 *)filePointer[2];\n    }\n    else if (streamPointer == (undefined4 *)PTR___sf_fake_stderr_00006870) {\n        streamPointer = (undefined4 *)filePointer[3];\n    }\n    fileFlags = *(ushort *)(streamPointer + 3);\n    streamPointer[1] = 0;\n    fileLength = (uint)*(ushort *)(streamPointer + 3);\n    if ((int)(fileLength << 0x1a) < 0) {\n        return 0xffffffff;\n    }\n    if ((int)(fileLength << 0x1d) < 0) {\n        if ((undefined4 *)streamPointer[0xd] != (undefined4 *)0x0) {\n            if ((undefined4 *)streamPointer[0xd] != streamPointer + 0x11) {\n                _free_r(filePointer);\n            }\n            streamPointer[1] = streamPointer[0x10];\n            streamPointer[0xd] = 0;\n            if (streamPointer[0x10] != 0) {\n                *streamPointer = streamPointer[0xf];\n                return 0;\n            }\n        }\n    }\n    else {\n        if (-1 < (int)(fileLength << 0x1b)) {\n            *filePointer = 9;\n            fileFlags = fileFlags | 0x40;\n            goto LAB_000067b8;\n        }\n        if ((int)(fileLength << 0x1c) < 0) {\n            result = _fflush_r(filePointer, streamPointer, fileLength << 0x1c, fileLength, mode);\n            if (result != 0) {\n                return 0xffffffff;\n            }\n            streamPointer[2] = 0;\n            *(ushort *)(streamPointer + 3) = *(ushort *)(streamPointer + 3) & 0xfff7;\n            streamPointer[6] = 0;\n        }\n        *(ushort *)(streamPointer + 3) = *(ushort *)(streamPointer + 3) | 4;\n    }\n    if (streamPointer[4] == 0) {\n        __smakebuf_r(filePointer, streamPointer);\n    }\n    fileFlags = *(ushort *)(streamPointer + 3);\n    flags = *(undefined2 *)(streamPointer + 3);\n    if ((fileFlags & 3) != 0) {\n        *(undefined2 *)(streamPointer + 3) = 1;\n        _fwalk(*(undefined4 *)PTR__global_impure_ptr_00006874, DAT_00006878);\n        *(undefined2 *)(streamPointer + 3) = flags;\n        if ((fileFlags & 9) == 9) {\n            __sflush_r(filePointer, streamPointer);\n        }\n    }\n    bufferLength = streamPointer[4];\n    *streamPointer = bufferLength;\n    result = (*(code *)streamPointer[9])(filePointer, streamPointer[8], bufferLength, streamPointer[5]);\n    streamPointer[1] = result;\n    if (0 < result) {\n        return 0;\n    }\n    fileFlags = *(ushort *)(streamPointer + 3);\n    if (result != 0) {\n        bufferLength = 0;\n    }\n    else {\n        fileFlags = fileFlags | 0x20;\n    }\n    if (result != 0) {\n        streamPointer[1] = bufferLength;\n        fileFlags = fileFlags | 0x40;\n    }\nLAB_000067b8:\n    *(ushort *)(streamPointer + 3) = fileFlags;\n    return 0xffffffff;\n}",
            "called": [
                "_fwalk",
                "__sflush_r",
                "_free_r",
                "_fflush_r",
                "__smakebuf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006768",
            "calling": [
                "__srget_r"
            ],
            "imported": false,
            "current_name": "processFile_00006768"
        },
        "FUN_00000db0": {
            "renaming": {
                "FUN_00000db0": "disable_watchdog_and_fix_cpu_errata_00000db0",
                "wdog_disable": "disable_watchdog",
                "cpu_errata_fixes": "fix_cpu_errata"
            },
            "code": "void disable_watchdog_and_fix_cpu_errata_00000db0(void)\n{\n  disable_watchdog();\n  fix_cpu_errata();\n  return;\n}",
            "called": [
                "wdog_disable",
                "cpu_errata_fixes"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000db0",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "disable_watchdog_and_fix_cpu_errata_00000db0"
        },
        "FUN_00002600": {
            "renaming": {
                "FUN_00002600": "set_rtt_counter_from_time_00002600",
                "time": "time_in_seconds",
                "counter": "rtt_counter",
                "time_struct": "time_structure"
            },
            "code": "int set_rtt_counter_from_time_00002600(tm *time_struct) {\n  uint32_t counter;\n  time_t time;\n  time = mktime(time_struct);\n  rtt_set_counter(counter);\n  return 0;\n}",
            "called": [
                "rtt_set_counter",
                "mktime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002600",
            "calling": [
                "_rtc_settime"
            ],
            "imported": false,
            "current_name": "set_rtt_counter_from_time_00002600"
        },
        "FUN_00003810": {
            "renaming": {
                "FUN_00003810": "get_unit_name_00003810",
                "unit": "unit_type",
                "pcVar1": "unit_name",
                "PTR_DAT_00003914": "PTR_UNIT_NAME_DEFAULT",
                "PTR_DAT_000038cc": "PTR_UNIT_NAME_1",
                "PTR_DAT_000038d0": "PTR_UNIT_NAME_2",
                "PTR_DAT_000038d4": "PTR_UNIT_NAME_3",
                "PTR_PTR_s_R_000038d8": "PTR_UNIT_NAME_4",
                "PTR_DAT_000038dc": "PTR_UNIT_NAME_5",
                "PTR_DAT_000038e0": "PTR_UNIT_NAME_6",
                "PTR_DAT_000038e4": "PTR_UNIT_NAME_7",
                "PTR_DAT_000038e8": "PTR_UNIT_NAME_8",
                "PTR_DAT_000038ec": "PTR_UNIT_NAME_9",
                "PTR_DAT_000038f0": "PTR_UNIT_NAME_10",
                "PTR_DAT_000038f4": "PTR_UNIT_NAME_11",
                "PTR_DAT_000038f8": "PTR_UNIT_NAME_12",
                "PTR_DAT_000038fc": "PTR_UNIT_NAME_13",
                "PTR_DAT_00003900": "PTR_UNIT_NAME_14",
                "PTR_DAT_00003904": "PTR_UNIT_NAME_15",
                "PTR_DAT_0000390c": "PTR_UNIT_NAME_16",
                "PTR_DAT_00003910": "PTR_UNIT_NAME_17",
                "PTR_DAT_00003908": "PTR_UNIT_NAME_18"
            },
            "code": "char* get_unit_name_00003810(uint8_t unit) {\n  char* unit_name = PTR_DAT_00003914;\n  switch(unit) {\n    case UNIT_TYPE_1:\n      unit_name = PTR_DAT_000038cc;\n      break;\n    case UNIT_TYPE_2:\n      unit_name = PTR_DAT_000038d0;\n      break;\n    case UNIT_TYPE_3:\n      unit_name = PTR_DAT_000038d4;\n      break;\n    case UNIT_TYPE_4:\n      unit_name = PTR_PTR_s_R_000038d8;\n      break;\n    case UNIT_TYPE_5:\n      unit_name = PTR_DAT_000038dc;\n      break;\n    case UNIT_TYPE_6:\n      unit_name = PTR_DAT_000038e0;\n      break;\n    case UNIT_TYPE_7:\n      unit_name = PTR_DAT_000038e4;\n      break;\n    case UNIT_TYPE_8:\n      unit_name = PTR_DAT_000038e8;\n      break;\n    case UNIT_TYPE_9:\n      unit_name = PTR_DAT_000038ec;\n      break;\n    case UNIT_TYPE_10:\n      unit_name = PTR_DAT_000038f0;\n      break;\n    case UNIT_TYPE_11:\n      unit_name = PTR_DAT_000038f4;\n      break;\n    case UNIT_TYPE_12:\n      unit_name = PTR_DAT_000038f8;\n      break;\n    case UNIT_TYPE_13:\n      unit_name = PTR_DAT_000038fc;\n      break;\n    case UNIT_TYPE_14:\n      unit_name = PTR_DAT_00003900;\n      break;\n    case UNIT_TYPE_15:\n      unit_name = PTR_DAT_00003904;\n      break;\n    case UNIT_TYPE_16:\n      unit_name = PTR_DAT_0000390c;\n      break;\n    case UNIT_TYPE_17:\n      unit_name = PTR_DAT_00003910;\n      break;\n    case UNIT_TYPE_18:\n      unit_name = PTR_DAT_00003908;\n      break;\n  }\n  return unit_name;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003810",
            "calling": [
                "phydat_dump"
            ],
            "imported": false,
            "current_name": "get_unit_name_00003810"
        },
        "FUN_0000041c": {
            "renaming": {
                "FUN_0000041c": "do_nothing_0000041c"
            },
            "code": "\nvoid do_nothing_0000041c(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000041c",
            "calling": [],
            "imported": false,
            "current_name": "do_nothing_0000041c"
        },
        "FUN_00000ed8": {
            "renaming": {
                "FUN_00000ed8": "print_lr_value_00000ed8",
                "in_lr": "",
                "lr_ptr": "link_register_ptr",
                "PTR_DAT_00000ef4": "\"Link Register value: %p\\n\""
            },
            "code": "void print_lr_value_00000ed8(void)\n{\n  uint32_t *link_register_ptr;\n  link_register_ptr = (uint32_t *)__builtin_return_address(0);\n  iprintf(PTR_DAT_00000ef4, *link_register_ptr);\n  return;\n}",
            "called": [
                "iprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ed8",
            "calling": [
                "core_panic"
            ],
            "imported": false,
            "current_name": "print_lr_value_00000ed8"
        },
        "FUN_000031e0": {
            "renaming": {
                "FUN_000031e0": "print_alarm_message_000031e0",
                "arg": "message",
                "PTR_s_The_alarm_rang_000031f8": "message"
            },
            "code": "void print_alarm_message_000031e0(void *PTR_s_The_alarm_rang_000031f8)\n{\n  puts(PTR_s_The_alarm_rang_000031f8);\n  return;\n}",
            "called": [
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031e0",
            "calling": [],
            "imported": false,
            "current_name": "print_alarm_message_000031e0"
        },
        "FUN_000004d4": {
            "renaming": {
                "FUN_000004d4": "set_errno_to_0x13_000004d4",
                "r": "reent",
                "fd": "file_descriptor"
            },
            "code": "int set_errno_to_0x13_000004d4(_reent *reent, int file_descriptor) {\n  reent->_errno = 0x13;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004d4",
            "calling": [
                "__sclose"
            ],
            "imported": false,
            "current_name": "set_errno_to_0x13_000004d4"
        },
        "FUN_000020f4": {
            "renaming": {
                "FUN_000020f4": "handle_irq_000020f4",
                "DAT_00002104": "irq_num",
                "3": "priority"
            },
            "code": "void handle_irq_000020f4(void)\n{\n  int DAT_00002104 = DAT_00002104;\n  int priority = 3;\n  irq_handler(DAT_00002104, priority);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020f4",
            "calling": [],
            "imported": false,
            "current_name": "handle_irq_000020f4"
        },
        "FUN_0000687c": {
            "renaming": {
                "FUN_0000687c": "reverse_and_toggle_0000687c",
                "param_1": "length",
                "param_2": "input",
                "pbVar1": "output",
                "uVar2": "next_char",
                "iVar3": "i",
                "uVar4": "current_char",
                "uVar5": "end_char",
                "uVar6": "next_char",
                "bVar7": "toggle"
            },
            "code": "byte * reverse_and_toggle_0000687c(int length, byte *input)\n{\n  byte *output;\n  uint current_char;\n  bool toggle = false;\n  if (*input == 0x5e) {\n    current_char = (uint)input[1];\n    input += 2;\n  }\n  else {\n    current_char = (uint)*input;\n    input++;\n  }\n  for (int i = 0; i < length; i++) {\n    *(bool *)(output + i) = toggle;\n  }\n  if (current_char == 0) {\n    output = input - 1;\n  }\n  else {\n    do {\n      uint end_char = current_char;\n      *(bool *)(output + current_char) = !toggle;\n      input++;\n      while (true) {\n        uint current_char = (uint)input[-1];\n        if (current_char != 0x2d) break;\n        uint next_char = (uint)*input;\n        if ((next_char == 0x5d) || ((int)next_char < (int)end_char)) goto end_loop;\n        for (uint i = end_char + 1; i < next_char; i++) {\n          *(bool *)(output + i) = !toggle;\n        }\n        end_char = next_char - end_char - 1;\n        current_char = end_char + 1;\n        input += 2;\n      }\n      output = input - 1;\n    } while ((current_char != 0x5d) && (output = input - 1, current_char != 0));\n  }\n  return output;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000687c",
            "calling": [
                "_scanf_i",
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "reverse_and_toggle_0000687c"
        },
        "FUN_00004dea": {
            "renaming": {
                "FUN_00004dea": "returnZero_00004dea"
            },
            "code": "int returnZero_00004dea(void) {\n\treturn 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dea",
            "calling": [],
            "imported": false,
            "current_name": "returnZero_00004dea"
        },
        "FUN_00005edc": {
            "renaming": {
                "_strtoul_l_isra_0": "convert_string_to_unsigned_int",
                "param_1": "output",
                "param_2": "input",
                "param_3": "end_pointer",
                "param_4": "base",
                "uVar1": "result",
                "uVar2": "current_char_value",
                "bVar3": "is_hex",
                "iVar4": "parsing_result",
                "uVar5": "parsed_digit",
                "uVar6": "max_value",
                "pbVar7": "current_char_pointer",
                "pbVar8": "next_char_pointer",
                "FUN_00005edc": "convert_string_to_unsigned_int_00005edc"
            },
            "code": "uint convert_string_to_unsigned_int_00005edc(undefined4 *output, byte *input, byte **end_pointer, uint base) {\n  uint current_char_value;\n  uint result = 0;\n  uint max_value = 0xffffffff / base;\n  int is_negative = 0;\n  byte *current_char_pointer = input;\n  while ((PTR_DAT_00005fd0[current_char_value = (uint)*current_char_pointer] & 8) != 0) {\n    current_char_pointer++;\n  }\n  if (current_char_value == 0x2d) {\n    is_negative = 1;\n    current_char_value = (uint)*++current_char_pointer;\n  }\n  else if (current_char_value == 0x2b) {\n    current_char_value = (uint)*++current_char_pointer;\n  }\n  if (base == 0) {\n    if (current_char_value != 0x30) {\n      base = 10;\n      goto parsing_loop;\n    }\n  }\n  else if (base == 0x10 && current_char_value == 0x30 && ((*++current_char_pointer) & 0xdf) == 0x58) {\n    current_char_value = (uint)*++current_char_pointer;\n  }\n  else if (base != 0x10 || current_char_value != 0x30) {\n    parsing_loop:\n    while (1) {\n      current_char_value = (uint)*current_char_pointer;\n      if (current_char_value - 0x30 > 9) {\n        if (current_char_value - 0x41 < 0x1a) {\n          current_char_value -= 0x37;\n        }\n        else {\n          if (current_char_value - 0x61 > 0x19) {\n            break;\n          }\n          current_char_value -= 0x57;\n        }\n      }\n      if (base <= current_char_value) {\n        break;\n      }\n      if (result > max_value || (result == max_value && (int)~(base * max_value) < (int)current_char_value)) {\n        // Overflow occurred\n        *output = 0x22;\n        result = 0xffffffff;\n        if (end_pointer == (byte **)0) {\n          return 0xffffffff;\n        }\n        break;\n      }\n      result = result * base + current_char_value;\n      current_char_pointer++;\n    }\n  }\n  if (is_negative) {\n    result = -result;\n  }\n  if (end_pointer == (byte **)0) {\n    return result;\n  }\n  if (current_char_pointer == input) {\n    // No characters were parsed\n    *end_pointer = input;\n  }\n  else {\n    *end_pointer = current_char_pointer;\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005edc",
            "calling": [
                "_strtoul_r",
                "strtoul"
            ],
            "imported": false,
            "current_name": "convert_string_to_unsigned_int_00005edc"
        },
        "FUN_00001eea": {
            "renaming": {
                "FUN_00001eea": "configure_gpio_pin_00001eea",
                "pin": "gpio_pin",
                "mode": "gpio_mode",
                "uVar1": "pin_number",
                "pGVar2": "gpio_ptr",
                "pPVar3": "port_ptr",
                "iVar4": "pin_index",
                "FUN_00001eea_port": "configure_gpio_pin_port",
                "GPIO_Type": "GPIO_Type",
                "PORT_Type": "PORT_Type",
                "PDDR": "pin_direction_data_register",
                "PCR": "pin_control_register",
                "GPIO_IN": "GPIO_INPUT",
                "pin_num": "gpio_pin_number",
                "byte": "uint8_t"
            },
            "code": "int configure_gpio_pin_00001eea(gpio_t pin, gpio_mode_t mode) {\n  uint32_t pin_number;\n  GPIO_Type *gpio_ptr;\n  PORT_Type *port_ptr;\n  int pin_index;\n  configure_gpio_pin_00001eea_port(pin, 0);\n  if (mode < GPIO_IN) {\n    pin_number = pin_num(pin);\n    gpio_ptr = gpio(pin);\n    gpio_ptr->PDDR |= 1U << (pin_number & 0xFFU);\n  } else {\n    pin_number = pin_num(pin);\n    gpio_ptr = gpio(pin);\n    gpio_ptr->PDDR &= ~(1U << (pin_number & 0xFFU));\n  }\n  port_ptr = port(pin);\n  pin_index = pin_num(pin);\n  port_ptr->PCR[pin_index] = (uint8_t)mode & 0x23U | 0x100U;\n  return 0;\n}",
            "called": [
                "port",
                "gpio",
                "gpio_init_port",
                "pin_num"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001eea",
            "calling": [
                "board_init"
            ],
            "imported": false,
            "current_name": "configure_gpio_pin_00001eea"
        },
        "FUN_000023a4": {
            "renaming": {
                "FUN_000023a4": "run_shell_command_000023a4",
                "line_buf": "command_buffer",
                "startForkserver": "start_fork_server",
                "PTR_s_Welcome_to_RIOT__000023c4": "welcome_message"
            },
            "code": "void run_shell_command_000023a4(void)\n{\n  char command_buffer[128];\n  start_fork_server(0);\n  puts(PTR_s_Welcome_to_RIOT__000023c4);\n  shell_run((shell_command_t *)0x0, command_buffer, 0x80);\n}",
            "called": [
                "shell_run",
                "puts",
                "startForkserver"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023a4",
            "calling": [
                "main_trampoline"
            ],
            "imported": false,
            "current_name": "run_shell_command_000023a4"
        },
        "FUN_0000240c": {
            "renaming": {
                "FUN_0000240c": "remove_first_node_0000240c",
                "list": "head",
                "plVar1": "first_node"
            },
            "code": "list_node_t* remove_first_node_0000240c(list_node_t* head)\n{\n  list_node_t* first_node;\n  first_node = head->next;\n  if (first_node != NULL)\n  {\n    head->next = first_node->next;\n  }\n  return first_node;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000240c",
            "calling": [
                "mutex_unlock"
            ],
            "imported": false,
            "current_name": "remove_first_node_0000240c"
        },
        "FUN_00004280": {
            "renaming": {
                "FUN_00004280": "release_recursive_mutex_00004280",
                "PTR___lock___sfp_recursive_mutex_00004288": "lock"
            },
            "code": "void release_recursive_mutex_00004280(void)\n{\n  __retarget_PTR___lock___sfp_recursive_mutex_00004288_release_recursive(PTR___lock___sfp_recursive_mutex_00004288);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004280",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "release_recursive_mutex_00004280"
        },
        "FUN_00001448": {
            "renaming": {
                "FUN_00001448": "initialize_uart_gpio_00001448",
                "uart": "uart_num",
                "PTR_uart_config_000014c0": "uart_config_ptr",
                "rx_pin": "rx_pin_num",
                "tx_pin": "tx_pin_num",
                "rx_gpio": "rx_gpio_port",
                "rx_config": "rx_gpio_config",
                "tx_gpio": "tx_gpio_port",
                "tx_config": "tx_gpio_config"
            },
            "code": "void initialize_uart_gpio_00001448(uart_t uart) {\n\tshort rx_pin = *(short *)(PTR_uart_config_000014c0 + uart * 0x20 + 8);\n\tshort tx_pin = *(short *)(PTR_uart_config_000014c0 + uart * 0x20 + 10);\n\tif (rx_pin != -1) {\n\t\tgpio_t rx_gpio = *(gpio_t *)(PTR_uart_config_000014c0 + uart * 0x20 + 8);\n\t\tuint32_t rx_config = *(uint32_t *)(PTR_uart_config_000014c0 + uart * 0x20 + 0xc);\n\t\tgpio_init_port(rx_gpio, rx_config);\n\t}\n\tif (tx_pin != -1) {\n\t\tgpio_t tx_gpio = *(gpio_t *)(PTR_uart_config_000014c0 + uart * 0x20 + 10);\n\t\tuint32_t tx_config = *(uint32_t *)(PTR_uart_config_000014c0 + uart * 0x20 + 0x10);\n\t\tgpio_init_port(tx_gpio, tx_config);\n\t}\n}",
            "called": [
                "gpio_init_port"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001448",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_gpio_00001448"
        },
        "FUN_00001688": {
            "renaming": {
                "FUN_00001688": "handle_uart_interrupt_00001688"
            },
            "code": "void handle_uart_interrupt_00001688(void)\n{\n  irq_handler_uart(0);\n  return;\n}",
            "called": [
                "irq_handler_uart"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001688",
            "calling": [],
            "imported": false,
            "current_name": "handle_uart_interrupt_00001688"
        },
        "FUN_00004042": {
            "renaming": {
                "FUN_00004042": "convert_string_to_long_00004042",
                "__nptr": "string_to_convert",
                "lVar1": "converted_number"
            },
            "code": "long convert_string_to_long_00004042(char* string_to_convert) {\n  long converted_number = strtol(string_to_convert, (char **)0x0, 10);\n  return converted_number;\n}",
            "called": [
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004042",
            "calling": [
                "read",
                "write"
            ],
            "imported": false,
            "current_name": "convert_string_to_long_00004042"
        },
        "FUN_00000cf0": {
            "renaming": {
                "FUN_00000cf0": "get_IRQ_interrupts_enabled_status_00000cf0",
                "uVar2": "interrupts_enabled_status",
                "bVar1": "is_privileged_mode",
                "isCurrentModePrivileged": "is_Current_Mode_Privileged",
                "isIRQinterruptsEnabled": "is_IRQ_interrupts_Enabled",
                "result": "N/A"
            },
            "code": "uint get_IRQ_interrupts_enabled_status_00000cf0(void)\n{\n  bool is_privileged_mode;\n  uint interrupts_enabled_status;\n  enable_IRQ_interrupts();\n  interrupts_enabled_status = 0;\n  is_privileged_mode = (bool)is_Current_Mode_Privileged();\n  if (is_privileged_mode) {\n    interrupts_enabled_status = is_IRQ_interrupts_Enabled();\n  }\n  return interrupts_enabled_status;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cf0",
            "calling": [
                "cpu_switch_context_exit"
            ],
            "imported": false,
            "current_name": "get_IRQ_interrupts_enabled_status_00000cf0"
        },
        "FUN_00006cd4": {
            "renaming": {
                "FUN_00006cd4": "do_nothing_00006cd4"
            },
            "code": "\nvoid do_nothing_00006cd4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006cd4",
            "calling": [
                "__aeabi_ldivmod"
            ],
            "imported": false,
            "current_name": "do_nothing_00006cd4"
        },
        "FUN_00000f8c": {
            "renaming": {
                "FUN_00000f8c": "create_idle_and_main_threads_00000f8c",
                "PTR_idle_stack_00000fdc": "idle_stack",
                "PTR_main_stack_00000fe8": "main_stack",
                "PTR_idle_name_00000fd4": "idle_name",
                "PTR_main_name_00000fe0": "main_name",
                "DAT_00000fd8": "idle_thread",
                "DAT_00000fe4": "main_thread"
            },
            "code": "void create_idle_and_main_threads_00000f8c(void)\n{\n    irq_disable();\n    thread_create(PTR_idle_stack_00000fdc, 256, THREAD_PRIORITY_LOW, THREAD_CREATE_WOUT_YIELD, DAT_00000fd8, NULL, PTR_idle_name_00000fd4);\n    thread_create(PTR_main_stack_00000fe8, 1536, THREAD_PRIORITY_NORMAL, THREAD_CREATE_WOUT_YIELD, DAT_00000fe4, NULL, PTR_main_name_00000fe0);\n    cpu_switch_context_exit();\n}",
            "called": [
                "cpu_switch_context_exit",
                "irq_disable",
                "thread_create"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f8c",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "create_idle_and_main_threads_00000f8c"
        },
        "FUN_00002894": {
            "renaming": {
                "FUN_00002894": "set_alarm_00002894",
                "alarm": "alarm_time",
                "cb": "callback",
                "arg": "argument",
                "iVar1": "rtt_address",
                "RTT_Type": "rtt_control_register",
                "PTR_rtt_callback_000028ec": "PTR_rtt_callback_000028ec",
                "RTC_IRQn": "RTC_IRQn"
            },
            "code": "void set_alarm_00002894(uint32_t alarm_time, rtt_callback_t callback, void *argument) {\n  int rtt_address = DAT_000028e8;\n  uint32_t *rtt_control_register = (uint32_t *)(rtt_address + 0x1c);\n  *rtt_control_register &= 0xfffffffb;\n  uint32_t *alarm_register = (uint32_t *)(rtt_address + 8);\n  *alarm_register = alarm_time - 1;\n  *(rtt_callback_t *)PTR_rtt_callback_000028ec = callback;\n  *(void **)(PTR_rtt_callback_000028ec + 4) = argument;\n  *rtt_control_register |= 4;\n  NVIC_SetPriority(RTC_IRQn, 10);\n  NVIC_EnableIRQ(RTC_IRQn);\n  return;\n}",
            "called": [
                "NVIC_SetPriority",
                "NVIC_EnableIRQ"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002894",
            "calling": [
                "rtc_set_alarm"
            ],
            "imported": false,
            "current_name": "set_alarm_00002894"
        },
        "FUN_00004158": {
            "renaming": {
                "FUN_00004158": "flush_buffer_00004158",
                "param_1": "file_descriptor",
                "param_2": "stream_buffer",
                "uVar1": "result"
            },
            "code": "int flush_buffer_00004158(int file_descriptor, char *stream_buffer) {\n    int result;\n    if (*(int *)(stream_buffer + 0x10) != 0) {\n        if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n            __sinit();\n        }\n        if (stream_buffer == PTR___sf_fake_stdin_000041c4) {\n            stream_buffer = *(char **)(file_descriptor + 4);\n        }\n        else if (stream_buffer == PTR___sf_fake_stdout_000041c8) {\n            stream_buffer = *(char **)(file_descriptor + 8);\n        }\n        else if (stream_buffer == PTR___sf_fake_stderr_000041cc) {\n            stream_buffer = *(char **)(file_descriptor + 0xc);\n        }\n        if (*(short *)(stream_buffer + 0xc) != 0) {\n            if ((-1 < *(int *)(stream_buffer + 100) << 0x1f) && (-1 < (int)*(short *)(stream_buffer + 0xc) << 0x16)) {\n                __retarget_lock_acquire_recursive(*(int *)(stream_buffer + 0x58));\n            }\n            result = __sflush_r(file_descriptor, stream_buffer);\n            if (*(int *)(stream_buffer + 100) << 0x1f < 0) {\n                return result;\n            }\n            if ((int)((uint)*(ushort *)(stream_buffer + 0xc) << 0x16) < 0) {\n                return result;\n            }\n            __retarget_lock_release_recursive(*(int *)(stream_buffer + 0x58));\n            return result;\n        }\n    }\n    return 0;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__sflush_r",
                "__retarget_lock_release_recursive",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004158",
            "calling": [
                "__swbuf_r",
                "__srefill_r",
                "fflush"
            ],
            "imported": false,
            "current_name": "flush_buffer_00004158"
        },
        "FUN_00002654": {
            "renaming": {
                "FUN_00002654": "set_rtc_alarm_00002654",
                "time": "alarm_time",
                "cb": "callback",
                "arg": "arg",
                "alarm": "alarm_seconds",
                "t": "time_t"
            },
            "code": "int set_rtc_alarm_00002654(tm *alarm_time, rtc_alarm_cb_t callback, void *arg) {\n  uint32_t alarm_seconds;\n  time_t t;\n  alarm_seconds = mktime((tm *)alarm_time);\n  *(rtc_alarm_cb_t *)PTR_rtc_callback_00002688 = callback;\n  rtt_set_alarm(alarm_seconds, DAT_0000268c, arg);\n  return 0;\n}",
            "called": [
                "mktime",
                "rtt_set_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002654",
            "calling": [
                "_rtc_setalarm"
            ],
            "imported": false,
            "current_name": "set_rtc_alarm_00002654"
        },
        "FUN_00000aa8": {
            "renaming": {
                "FUN_00000aa8": "handle_hard_fault_00000aa8",
                "sp": "stack_pointer",
                "corrupted": "corrupted_stack",
                "exc_return": "exc_return",
                "r4_to_r11_stack": "r4_to_r11_stack",
                "iVar1": "stack_size_left",
                "psr": "psr_register",
                "lr": "lr_register",
                "r12": "r12_register",
                "r3": "r3_register",
                "r2": "r2_register",
                "r1": "r1_register",
                "r0": "r0_register",
                "afsr": "afsr_register",
                "dfsr": "dfsr_register",
                "hfsr": "hfsr_register",
                "cfsr": "cfsr_register",
                "mmfar": "mmfar_register",
                "bfar": "bfar_register",
                "orig_sp": "original_stack_pointer",
                "pc": "program_counter",
                "uVar2": "bfar_value",
                "uVar3": "mmfar_value",
                "uVar4": "cfsr_value",
                "uVar5": "hfsr_value",
                "uVar6": "dfsr_value",
                "uVar7": "afsr_value",
                "uVar8": "r0_register",
                "uVar9": "r1_register",
                "uVar10": "r2_register",
                "uVar11": "r3_register",
                "uVar12": "r12_register",
                "stack_left": "stack_size_left",
                "cfsr_bfar_mask": "cfsr_bfar_mask",
                "cfsr_mmar_mask": "cfsr_mmar_mask",
                "bfar_valid_mask": "bfar_valid_mask",
                "mmar_valid_mask": "mmar_valid_mask"
            },
            "code": "void handle_hard_fault_00000aa8(uint32_t *stack_pointer, uint32_t corrupted_stack, uint32_t exc_return, uint32_t *r4_to_r11_stack)\n{\n  int stack_size_left;\n  uint32_t psr_register;\n  uint32_t lr_register;\n  uint32_t r12_register;\n  uint32_t r3_register;\n  uint32_t r2_register;\n  uint32_t r1_register;\n  uint32_t r0_register;\n  uint32_t afsr_register;\n  uint32_t dfsr_register;\n  uint32_t hfsr_register;\n  uint32_t cfsr_register;\n  uint32_t mmfar_register;\n  uint32_t bfar_register;\n  uint32_t *original_stack_pointer;\n  uint32_t program_counter;\n  uint32_t cfsr_bfar_mask = *(uint *)PTR_CFSR_BFAR_MASK;\n  uint32_t cfsr_mmar_mask = *(uint *)PTR_CFSR_MMAR_MASK;\n  uint32_t bfar_valid_mask = *(uint *)PTR_BFARVALID_MASK;\n  uint32_t mmar_valid_mask = *(uint *)PTR_MMARVALID_MASK;\n\n  uint32_t cfsr_value = *(uint *)(DAT_CFSR_ADDRESS + 0x28);\n  uint32_t hfsr_value = *(uint *)(DAT_CFSR_ADDRESS + 0x2C);\n  uint32_t dfsr_value = *(uint *)(DAT_CFSR_ADDRESS + 0x30);\n  uint32_t afsr_value = *(uint *)(DAT_CFSR_ADDRESS + 0x3C);\n  uint32_t bfar_value = *(uint *)(DAT_CFSR_ADDRESS + 0x38);\n  uint32_t mmar_value = *(uint *)(DAT_CFSR_ADDRESS + 0x34);\n\n  if (*(int *)PTR_ISR_STACK != DAT_ISR_STACK_VALUE)\n  {\n    puts(PTR_ISR_STACK_OVERFLOWED_MESSAGE);\n  }\n  if (corrupted_stack == 0)\n  {\n    r0_register = *stack_pointer;\n    r1_register = stack_pointer[1];\n    r2_register = stack_pointer[2];\n    r3_register = stack_pointer[4];\n    r12_register = stack_pointer[5];\n    program_counter = stack_pointer[6];\n    puts(PTR_CONTEXT_BEFORE_HARDFAULT_MESSAGE);\n    iprintf(PTR_R0_R1_R2_MESSAGE, r0_register, r1_register, r2_register);\n    iprintf(PTR_R12_LR_PC_MESSAGE, r12_register, r3_register, program_counter);\n  }\n  else\n  {\n    puts(PTR_STACK_POINTER_CORRUPTED_MESSAGE);\n  }\n  puts(PTR_FSR_FAR_MESSAGE);\n  iprintf(PTR_CFSR_MESSAGE, cfsr_value);\n  iprintf(PTR_HFSR_MESSAGE, hfsr_value);\n  iprintf(PTR_DFSR_MESSAGE, dfsr_value);\n  iprintf(PTR_AFSR_MESSAGE, afsr_value);\n  if ((cfsr_value & bfar_valid_mask) != 0)\n  {\n    iprintf(PTR_BFAR_MESSAGE, bfar_value);\n  }\n  if ((cfsr_value & mmar_valid_mask) != 0)\n  {\n    iprintf(PTR_MMAR_MESSAGE, mmar_value);\n  }\n  puts(PTR_EXC_RET_MESSAGE);\n  iprintf(PTR_EXC_RET_VALUE_MESSAGE, exc_return);\n  if (corrupted_stack == 0)\n  {\n    puts(PTR_ATTEMPTING_TO_RECONSTRUCT_STATE_MESSAGE);\n    iprintf(PTR_IN_GDB_MESSAGE, program_counter);\n    stack_size_left = _stack_size_left(STACK_SIZE);\n    if (stack_size_left < 0)\n    {\n      iprintf(PTR_ISR_STACK_OVERFLOWED_MESSAGE, -stack_size_left);\n    }\n  }\n  software_bkpt(1);\n  core_panic(PANIC_HARD_FAULT, PTR_HARD_FAULT_HANDLER_MESSAGE);\n}\n",
            "called": [
                "iprintf",
                "puts",
                "core_panic",
                "_stack_size_left"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000aa8",
            "calling": [
                "hard_fault_default"
            ],
            "imported": false,
            "current_name": "handle_hard_fault_00000aa8"
        },
        "FUN_00002538": {
            "renaming": {
                "FUN_00002538": "set_interrupt_priority_00002538",
                "IRQn": "interrupt_number",
                "priority": "priority",
                "DMA0_IRQn": "DMA0_interrupt",
                "interrupt_priority_base_address": "DAT_00002584",
                "interrupt_priority_base_address_offset": "DAT_00002588"
            },
            "code": "void set_interrupt_priority_00002538(IRQn_Type interrupt_number, uint32_t priority) {\n  if (interrupt_number < DMA0_IRQn) {\n    *(char *)(((byte)interrupt_number & 0xf) + interrupt_priority_base_address + 0x14) = (char)((priority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interrupt_number + interrupt_priority_base_address_offset + 0x300) = (char)((priority & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002538",
            "calling": [
                "cortexm_init"
            ],
            "imported": false,
            "current_name": "set_interrupt_priority_00002538"
        },
        "FUN_00004c84": {
            "renaming": {
                "FUN_00004c84": "print_formatted_string_00004c84",
                "__format": "format",
                "in_r1": "arg1",
                "in_r2": "arg2",
                "in_r3": "arg3",
                "iVar1": "file_descriptor",
                "pcVar2": "format_string",
                "uStack_c": "arg1",
                "uStack_8": "arg2",
                "uStack_4": "arg3"
            },
            "code": "int print_formatted_string_00004c84(char* format, ...)\n{\n  int file_descriptor = *(int*)PTR__impure_ptr_00004cb0;\n  char* format_string = format;\n  undefined4 arg1 = in_r1;\n  undefined4 arg2 = in_r2;\n  undefined4 arg3 = in_r3;\n  undefined4 zero = 0;\n  if ((file_descriptor != 0) && (*(int*)(file_descriptor + 0x18) == 0)) {\n    __sinit(file_descriptor);\n  }\n  int result = _vfprintf_r(file_descriptor, *(undefined4*)(file_descriptor + 8), format_string, &arg1, format_string, &arg1);\n  return result;\n}",
            "called": [
                "_vfprintf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004c84",
            "calling": [
                "phydat_dump",
                "_print_time",
                "ps",
                "write",
                "cpu_print_last_instruction",
                "list",
                "main_trampoline",
                "read",
                "print_help",
                "hard_fault_handler",
                "_rtc_handler",
                "core_panic",
                "_saul",
                "handle_input_line",
                "probe"
            ],
            "imported": false,
            "current_name": "print_formatted_string_00004c84"
        },
        "FUN_0000305c": {
            "renaming": {
                "FUN_0000305c": "write_data_to_device_0000305c",
                "argc": "arg_count",
                "argv": "arguments",
                "iVar1": "index",
                "data": "data",
                "dim": "dimension",
                "dev": "device",
                "num": "device_number",
                "i": "i"
            },
            "code": "void write_data_to_device_0000305c(int arg_count, char **arguments)\n{\n    int index;\n    phydat_t data;\n    int dimension;\n    saul_reg_t *device;\n    int device_number;\n    int i;\n\n    if (arg_count < 4) {\n        iprintf(PTR_s_usage___s__s__device_id___value_0_00003154, *arguments, arguments[1]);\n    }\n    else {\n        device_number = atoi(arguments[2]);\n        device = saul_reg_find_nth(device_number);\n        if (device == (saul_reg_t *)0x0) {\n            puts(PTR_s_error__undefined_device_given_00003158);\n        }\n        else {\n            memset(&data, 0, 8);\n            if (arg_count > 5) {\n                arg_count = 6;\n            }\n            dimension = arg_count - 3;\n            for (i = 0; i < dimension; i++) {\n                index = atoi(arguments[i + 3]);\n                data.val[i] = (int16_t)index;\n            }\n            iprintf(PTR_s_Writing_to_device___i____s_0000315c, device_number, device->name);\n            phydat_dump(&data, (uint8_t)dimension);\n            index = saul_reg_write(device, &data);\n            if (index < 1) {\n                if (index == -0x86) {\n                    iprintf(PTR_s_error__device___i_is_not_writabl_00003160, device_number);\n                }\n                else {\n                    iprintf(PTR_s_error__failure_to_write_data_to_device_0000305c_to_devic_00003164, device_number);\n                }\n            }\n            else {\n                iprintf(PTR_s_data_successfully_written_to_dev_00003168, device_number);\n            }\n        }\n    }\n    return;\n}",
            "called": [
                "phydat_dump",
                "saul_reg_find_nth",
                "atoi",
                "iprintf",
                "saul_reg_write",
                "memset",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000305c",
            "calling": [
                "_saul"
            ],
            "imported": false,
            "current_name": "write_data_to_device_0000305c"
        },
        "FUN_000012b4": {
            "renaming": {
                "FUN_000012b4": "add_to_tsrb_and_unlock_mutex_000012b4",
                "isrpipe": "input_isrpipe",
                "c": "new_char",
                "iVar1": "tsrb_add_result",
                "res": "return_value",
                "tsrb_add_one": "add_char_to_tsrb",
                "mutex_unlock": "unlock_mutex"
            },
            "code": "int add_to_tsrb_and_unlock_mutex_000012b4(isrpipe_t *isrpipe, char new_char) {\n  int tsrb_add_result;\n  int return_value;\n  tsrb_add_result = add_char_to_tsrb(&isrpipe->tsrb, new_char);\n  unlock_mutex(&isrpipe->mutex);\n  return_value = tsrb_add_result;\n  return return_value;\n}",
            "called": [
                "tsrb_add_one",
                "mutex_unlock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012b4",
            "calling": [],
            "imported": false,
            "current_name": "add_to_tsrb_and_unlock_mutex_000012b4"
        },
        "FUN_00005b34": {
            "renaming": {
                "FUN_00005b34": "FUNC_00005b34"
            },
            "code": "\ncode * FUNC_00005b34(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  bool bVar1;\n  byte bVar2;\n  undefined *puVar3;\n  int iVar4;\n  code *pcVar5;\n  void *pvVar6;\n  int iVar7;\n  undefined *__s;\n  uint uVar8;\n  uint *puVar9;\n  uint uVar10;\n  uint **ppuVar11;\n  uint uVar12;\n  undefined *puVar13;\n  uint *puVar14;\n  undefined4 uVar15;\n  code *local_24;\n  \n  puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n  bVar2 = *(byte *)(param_2 + 6);\n  __s = (undefined *)((int)param_2 + 0x43);\n  puVar14 = param_2;\n  uVar15 = param_3;\n  local_24 = param_4;\n  if (0x78 < bVar2) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)param_2 + 0x42) = bVar2;\nLAB_00005bdc:\n    __s = (undefined *)((int)param_2 + 0x42);\n    uVar8 = 1;\nLAB_00005d28:\n    param_2[4] = uVar8;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (bVar2 < 99) {\n    if (bVar2 == 0) goto LAB_00005d06;\n    if (bVar2 == 0x58) {\n      *(undefined *)((int)param_2 + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(bVar2) {\n  case 99:\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    *(char *)((int)param_2 + 0x42) = (char)uVar8;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    uVar10 = *param_2;\n    puVar9 = *param_5;\n    if ((int)(uVar10 << 0x18) < 0) {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n    }\n    else {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n      if ((uVar10 & 0x40) != 0) {\n        uVar8 = (uint)(short)uVar8;\n      }\n    }\n    if ((int)uVar8 < 0) {\n      uVar8 = -uVar8;\n      *(undefined *)((int)param_2 + 0x43) = 0x2d;\n    }\n    uVar10 = 10;\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    ppuVar11 = (uint **)*param_5;\n    uVar10 = *param_2;\n    uVar8 = param_2[5];\n    *param_5 = (uint *)(ppuVar11 + 1);\n    puVar9 = *ppuVar11;\n    if (((int)(uVar10 << 0x18) < 0) || (-1 < (int)(uVar10 << 0x19))) {\n      *puVar9 = uVar8;\n    }\n    else {\n      *(short *)puVar9 = (short)uVar8;\n    }\nLAB_00005d06:\n    param_2[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    puVar9 = *param_5;\n    uVar8 = *param_2;\n    *param_5 = puVar9 + 1;\n    if (((int)(uVar8 << 0x18) < 0) || (-1 < (int)(uVar8 << 0x19))) {\n      uVar8 = *puVar9;\n    }\n    else {\n      uVar8 = (uint)*(ushort *)puVar9;\n    }\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    if (bVar2 == 0x6f) {\n      uVar10 = 8;\n    }\n    else {\n      uVar10 = 10;\n    }\n    break;\n  case 0x70:\n    *param_2 = *param_2 | 0x20;\n  case 0x78:\n    puVar3 = PTR_s_0123456789abcdef_00005d7c;\n    *(undefined *)((int)param_2 + 0x45) = 0x78;\nLAB_00005ca8:\n    uVar10 = *param_2;\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    if ((-1 < (int)(uVar10 << 0x18)) && ((int)(uVar10 << 0x19) < 0)) {\n      uVar8 = uVar8 & 0xffff;\n    }\n    if ((int)(uVar10 << 0x1f) < 0) {\n      *param_2 = uVar10 | 0x20;\n    }\n    if (uVar8 == 0) {\n      *param_2 = *param_2 & 0xffffffdf;\n    }\n    uVar10 = 0x10;\n    break;\n  case 0x73:\n    puVar9 = *param_5;\n    *param_5 = puVar9 + 1;\n    __s = (undefined *)*puVar9;\n    pvVar6 = memchr(__s,0,param_2[1]);\n    if (pvVar6 != (void *)0x0) {\n      param_2[1] = (int)pvVar6 - (int)__s;\n    }\n    uVar8 = param_2[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)param_2 + 0x43) = 0;\nLAB_00005c36:\n  uVar12 = param_2[1];\n  param_2[2] = uVar12;\n  if (-1 < (int)uVar12) {\n    *param_2 = *param_2 & 0xfffffffb;\n  }\n  puVar13 = __s;\n  if ((uVar8 != 0) || (uVar12 != 0)) {\n    do {\n      puVar13 = puVar13 + -1;\n      *puVar13 = puVar3[uVar8 - uVar10 * (uVar8 / uVar10)];\n      bVar1 = uVar10 <= uVar8;\n      uVar8 = uVar8 / uVar10;\n    } while (bVar1);\n  }\n  if (((uVar10 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4])) {\n    puVar13[-1] = 0x30;\n    puVar13 = puVar13 + -1;\n  }\n  param_2[4] = (int)__s - (int)puVar13;\n  __s = puVar13;\nLAB_00005c84:\n  iVar4 = _printf_common(param_1,param_2,&local_24,param_3,param_4,puVar14,uVar15);\n  if ((iVar4 == -1) || (iVar4 = (*param_4)(param_1,param_3,__s,param_2[4]), iVar4 == -1)) {\nLAB_00005c98:\n    pcVar5 = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar4 = 0; iVar4 < (int)(param_2[3] - (int)local_24); iVar4 = iVar4 + 1) {\n        iVar7 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar7 == -1) goto LAB_00005c98;\n      }\n    }\n    pcVar5 = (code *)param_2[3];\n    if ((int)(code *)param_2[3] < (int)local_24) {\n      pcVar5 = local_24;\n    }\n  }\n  return pcVar5;\n}\n\n",
            "called": [
                "_printf_common",
                "memchr"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00005b34",
            "calling": [
                "_vfprintf_r"
            ],
            "imported": false,
            "current_name": "FUNC_00005b34"
        },
        "FUN_0000058e": {
            "renaming": {
                "FUN_0000058e": "insert_node_after_0000058e",
                "list": "head",
                "new_node": "new_node",
                "list->next": "head->next",
                "list_node": "clist_node_t",
                "new_node->next": "new_node->next"
            },
            "code": "void insert_node_after_0000058e(clist_node_t *head, clist_node_t *new_node) {\n  if (head->next == NULL) {\n    new_node->next = new_node;\n  }\n  else {\n    new_node->next = head->next;\n    head->next = new_node;\n  }\n  head->next = new_node;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000058e",
            "calling": [
                "sched_set_status"
            ],
            "imported": false,
            "current_name": "insert_node_after_0000058e"
        },
        "FUN_0000656c": {
            "renaming": {
                "FUN_0000656c": "FUNC_0000656c"
            },
            "code": "\nundefined4 FUNC_0000656c(undefined4 param_1,uint *param_2,byte **param_3,undefined4 *param_4)\n\n{\n  void *pvVar1;\n  int iVar2;\n  undefined4 uVar3;\n  code *pcVar4;\n  uint uVar5;\n  byte *pbVar6;\n  uint uVar7;\n  undefined4 *puVar8;\n  uint *puVar9;\n  uint *puVar10;\n  uint *puVar11;\n  int unaff_r9;\n  int iVar12;\n  void *local_34 [4];\n  \n  local_34[0] = *(void **)PTR_PTR_DAT_00006744;\n  local_34[1] = (void *)*(undefined4 *)(PTR_PTR_DAT_00006744 + 4);\n  local_34[2] = (void *)*(undefined4 *)(PTR_PTR_DAT_00006744 + 8);\n  pcVar4 = DAT_0000674c;\n  if (param_2[6] != 3) {\n    pcVar4 = DAT_00006748;\n  }\n  uVar7 = param_2[2];\n  uVar5 = uVar7 - 1;\n  if (0x15c < uVar5) {\n    unaff_r9 = uVar7 - 0x15d;\n    uVar7 = 0x15d;\n  }\n  if (0x15c < uVar5) {\n    param_2[2] = uVar7;\n  }\n  puVar11 = param_2 + 7;\n  if (uVar5 < 0x15d) {\n    unaff_r9 = 0;\n  }\n  *param_2 = *param_2 | 0xd00;\n  iVar12 = 0;\n  puVar10 = puVar11;\n  do {\n    pvVar1 = memchr(local_34[iVar12],(uint)**param_3,2);\n    if (pvVar1 != (void *)0x0) {\n      if (iVar12 == 1) {\n        if (param_2[1] == 0) {\n          param_2[1] = 8;\n          *param_2 = *param_2 | 0x200;\n        }\n        uVar5 = *param_2 & 0xfffffaff;\nLAB_000065f4:\n        *param_2 = uVar5;\n      }\n      else if (iVar12 == 2) {\n        if ((*param_2 & 0x600) != 0x200) goto LAB_00006624;\n        param_2[1] = 0x10;\n        uVar5 = *param_2 | 0x100;\n        goto LAB_000065f4;\n      }\n      uVar5 = param_2[2];\n      param_2[2] = uVar5 - 1;\n      if (uVar5 != 0) {\n        pbVar6 = *param_3;\n        *param_3 = pbVar6 + 1;\n        puVar9 = (uint *)((int)puVar10 + 1);\n        *(byte *)puVar10 = *pbVar6;\n        pbVar6 = param_3[1];\n        param_3[1] = pbVar6 + -1;\n        puVar10 = puVar9;\n        if (((int)(pbVar6 + -1) < 1) &&\n           (iVar2 = (*(code *)param_2[0x60])(param_1,param_3), iVar2 != 0)) {\n          iVar12 = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    iVar12 = iVar12 + 1;\n  } while (iVar12 != 3);\n  if (param_2[1] == 0) {\n    param_2[1] = 10;\n  }\n  __sccl(param_2[5],(int)PTR_DAT_00006750 - param_2[1]);\n  iVar12 = 0;\n  while( true ) {\n    puVar9 = puVar10;\n    if (param_2[2] == 0) break;\n    pbVar6 = *param_3;\n    uVar5 = (uint)*pbVar6;\n    if (*(char *)(param_2[5] + uVar5) == '\\0') break;\n    if ((uVar5 == 0x30) && ((int)(*param_2 << 0x14) < 0)) {\n      iVar12 = iVar12 + 1;\n      if (unaff_r9 != 0) {\n        unaff_r9 = unaff_r9 + -1;\n        param_2[2] = param_2[2] + 1;\n      }\n    }\n    else {\n      *param_2 = *param_2 & 0xfffff6ff;\n      puVar9 = (uint *)((int)puVar10 + 1);\n      *(byte *)puVar10 = *pbVar6;\n    }\n    pbVar6 = param_3[1];\n    param_3[1] = pbVar6 + -1;\n    if ((int)(pbVar6 + -1) < 1) {\n      iVar2 = (*(code *)param_2[0x60])(param_1,param_3);\n      if (iVar2 != 0) break;\n    }\n    else {\n      *param_3 = *param_3 + 1;\n    }\n    param_2[2] = param_2[2] - 1;\n    puVar10 = puVar9;\n  }\nLAB_000066ca:\n  if ((int)(*param_2 << 0x17) < 0) {\n    if (puVar11 < puVar9) {\n      (*(code *)param_2[0x5f])(param_1,*(byte *)((int)puVar9 + -1),param_3);\n      puVar9 = (uint *)((int)puVar9 + -1);\n    }\n    if (puVar9 == puVar11) {\n      return 1;\n    }\n  }\n  if ((*param_2 & 0x10) == 0) {\n    *(byte *)puVar9 = 0;\n    uVar3 = (*pcVar4)(param_1,puVar11,0,param_2[1]);\n    puVar8 = (undefined4 *)*param_4;\n    uVar5 = *param_2;\n    *param_4 = puVar8 + 1;\n    puVar8 = (undefined4 *)*puVar8;\n    if ((uVar5 & 0x20) == 0) {\n      if ((int)(uVar5 << 0x1f) < 0) {\n        *(short *)puVar8 = (short)uVar3;\n      }\n      else {\n        *puVar8 = uVar3;\n      }\n    }\n    else {\n      *puVar8 = uVar3;\n    }\n    param_2[3] = param_2[3] + 1;\n  }\n  param_2[4] = (uint)((int)puVar9 + param_2[4] + (iVar12 - (int)puVar11));\n  return 0;\n}\n\n",
            "called": [
                "__sccl",
                "memchr"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0000656c",
            "calling": [
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "FUNC_0000656c"
        },
        "FUN_000025f4": {
            "renaming": {
                "FUN_000025f4": "initialize_real_time_trace_000025f4",
                "rtt_init": "initialize_rtt"
            },
            "code": "void initialize_real_time_trace_000025f4(void)\n{\n  initialize_rtt();\n  return;\n}",
            "called": [
                "rtt_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000025f4",
            "calling": [
                "periph_init"
            ],
            "imported": false,
            "current_name": "initialize_real_time_trace_000025f4"
        },
        "FUN_00001ddc": {
            "renaming": {
                "FUN_00001ddc": "set_gpio_pin_00001ddc",
                "pin": "gpio_pin",
                "iVar1": "port_number",
                "port_num": "get_port_number",
                "DAT_00001e08": "register_address",
                "bit_set32": "set_bit_in_register"
            },
            "code": "void set_gpio_pin_00001ddc(gpio_t pin) {\n    int port_number = get_port_number(pin);\n    int bit_position = port_number + 9;\n    set_bit_in_register(DAT_00001e08, bit_position);\n    return;\n}",
            "called": [
                "port_num",
                "bit_set32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ddc",
            "calling": [
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_00001ddc"
        },
        "FUN_00002ecc": {
            "renaming": {
                "FUN_00002ecc": "read_sensor_data_00002ecc",
                "num": "sensor_num",
                "dev": "sensor_device",
                "iVar1": "read_result",
                "pcVar2": "driver_type",
                "pcVar3": "device_name",
                "res": "sensor_data",
                "dim": "sensor_data_dim"
            },
            "code": "void read_sensor_data_00002ecc(int sensor_num, saul_reg_t *sensor_device) {\n  int read_result;\n  char *device_name;\n  char *driver_type;\n  phydat_t sensor_data;\n  int sensor_data_dim;\n  read_result = saul_reg_read(sensor_device, &sensor_data);\n  if (read_result < 1) {\n    iprintf(PTR_s_error__failed_to_read_from_device_00002f28, sensor_num);\n  }\n  else {\n    device_name = sensor_device->name;\n    driver_type = saul_class_to_str(sensor_device->driver->type);\n    iprintf(PTR_s_Reading_from___i___s__s__00002f2c, sensor_num, device_name, driver_type);\n    phydat_dump(&sensor_data, (uint8_t)read_result);\n  }\n  return;\n}",
            "called": [
                "phydat_dump",
                "saul_reg_read",
                "iprintf",
                "saul_class_to_str"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002ecc",
            "calling": [
                "read",
                "probe_all"
            ],
            "imported": false,
            "current_name": "read_sensor_data_00002ecc"
        },
        "FUN_00000d76": {
            "renaming": {
                "FUN_00000d76": "clear_bit_00000d76",
                "ptr": "data",
                "bit": "bit_position",
                "puVar1": "bit_address"
            },
            "code": "void clear_bit_00000d76(uint32_t *data, uint8_t bit_position)\n{\n  uint32_t *bit_address = (uint32_t *)(0x42000000 + (((uint32_t)data - 0x20000000) * 32) + (bit_position * 4));\n  *bit_address = 0;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d76",
            "calling": [
                "cpu_errata_fixes"
            ],
            "imported": false,
            "current_name": "clear_bit_00000d76"
        },
        "FUN_000057a8": {
            "renaming": {
                "FUN_000057a8": "write_char_to_buffer_000057a8",
                "param_1": "buffer_start",
                "param_2": "character",
                "param_3": "buffer_info",
                "iVar1": "buffer_size",
                "puVar2": "next_char_ptr"
            },
            "code": "int write_char_to_buffer_000057a8(undefined4 buffer_start, int character, undefined4 *buffer_info){\n  int buffer_size = buffer_info[2] + -1;\n  buffer_info[2] = buffer_size;\n  if ((buffer_size < 0) && ((buffer_size < (int)buffer_info[6] || (character == 10)))) {\n    int error = __swbuf_r();\n    return error;\n  }\n  undefined *next_char_ptr = (undefined *)*buffer_info;\n  *buffer_info = next_char_ptr + 1;\n  *next_char_ptr = (char)character;\n  return character;\n}",
            "called": [
                "__swbuf_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057a8",
            "calling": [
                "__sfputs_r"
            ],
            "imported": false,
            "current_name": "write_char_to_buffer_000057a8"
        },
        "FUN_00004298": {
            "renaming": {
                "FUN_00004298": "release_recursive_mutex_00004298",
                "PTR___lock___sinit_recursive_mutex_000042a0": "sinit_recursive_mutex"
            },
            "code": "void release_recursive_mutex_00004298(void)\n{\n  __retarget_lock_release_recursive(PTR___lock___sinit_recursive_mutex_000042a0);\n  return;\n}",
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004298",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "release_recursive_mutex_00004298"
        },
        "FUN_00001696": {
            "renaming": {
                "FUN_00001696": "calculate_memory_address_00001696",
                "ptr": "ptr",
                "bit": "bit"
            },
            "code": "void* calculate_memory_address_00001696(void* ptr, uintptr_t bit) {\n     uint ptr_int = (uint)ptr;\n     uint high_bits = ptr_int & 0xf0000000;\n     uint low_bits = ptr_int & 0xfffff;\n     uint offset = high_bits | (low_bits << 5) | 0x2000000;\n     return (void*)(bit * 4 + offset);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001696",
            "calling": [
                "bit_set8",
                "bit_clear8",
                "bit_set32"
            ],
            "imported": false,
            "current_name": "calculate_memory_address_00001696"
        },
        "FUN_000008b8": {
            "renaming": {
                "FUN_000008b8": "count_words_in_heap_000008b8",
                "num_used_words": "num_used_words",
                "ptr": "current_ptr",
                "PTR_isr_stack_000008f4": "PTR_isr_stack_000008f4",
                "DAT_000008f8": "DAT_000008f8",
                "PTR_heap_top_000008fc": "PTR_heap_top_000008fc"
            },
            "code": "int count_words_in_heap_000008b8() {\n  ptrdiff_t num_used_words;\n  uint32_t *current_ptr;\n\n  for (current_ptr = (uint32_t *)PTR_isr_stack_000008f4; (*current_ptr == DAT_000008f8 && (current_ptr < PTR_heap_top_000008fc)); current_ptr++) {\n  }\n  return ((int)PTR_heap_top_000008fc - (int)current_ptr >> 2) << 2;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000008b8",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "count_words_in_heap_000008b8"
        },
        "FUN_000024bc": {
            "renaming": {
                "FUN_000024bc": "acquire_mutex_000024bc",
                "mutex": "mutex",
                "state": "irq_state",
                "plVar2": "thread_node",
                "process_priority": "thread_priority",
                "irqstate": "irq_state",
                "__m____": "",
                "next": "",
                "process": "thread",
                "bVar1": "thread_priority"
            },
            "code": "void acquire_mutex_000024bc(mutex_t *mutex)\n{\n  byte thread_priority;\n  uint irq_state;\n  list_node_t *thread_node;\n  thread_t *thread;\n  \n  irq_state = disable_interrupts();\n  if ((mutex->waiting_threads).next == (list_node *)0x0) {\n    restore_interrupts(irq_state);\n  }\n  else if ((mutex->waiting_threads).next == (list_node *)0xffffffff) {\n    (mutex->waiting_threads).next = (list_node *)0x0;\n    restore_interrupts(irq_state);\n  }\n  else {\n    thread_node = list_remove_head(&mutex->waiting_threads);\n    thread = (thread_t *)(thread_node - 2);\n    set_thread_status(thread, THREAD_STATUS_MUTEX_BLOCKED);\n    if ((mutex->waiting_threads).next == (list_node *)0x0) {\n      (mutex->waiting_threads).next = (list_node *)0xffffffff;\n    }\n    thread_priority = *(byte *)((int)&thread_node[-1].next + 1);\n    restore_interrupts(irq_state);\n    switch_threads((ushort)thread_priority);\n  }\n  return;\n}",
            "called": [
                "irq_disable",
                "irq_restore",
                "sched_set_status",
                "list_remove_head",
                "sched_switch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000024bc",
            "calling": [
                "isrpipe_write_one"
            ],
            "imported": false,
            "current_name": "acquire_mutex_000024bc"
        },
        "FUN_00000490": {
            "renaming": {
                "FUN_00000490": "read_from_uart_00000490",
                "r": "reent",
                "fd": "file_descriptor",
                "buffer": "buffer",
                "count": "buffer_size",
                "iVar1": "bytes_read"
            },
            "code": "_ssize_t read_from_uart_00000490(_reent *reent, int file_descriptor, void *buffer, size_t buffer_size) {\\n\\\n  int bytes_read = uart_stdio_read((char *)buffer, buffer_size);\\n\\\n  return bytes_read;\\n\\\n}",
            "called": [
                "uart_stdio_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000490",
            "calling": [
                "__sread"
            ],
            "imported": false,
            "current_name": "read_from_uart_00000490"
        },
        "FUN_0000091c": {
            "renaming": {
                "FUN_0000091c": "get_isr_stack_pointer_0000091c",
                "PTR_isr_stack_0000092c": "isr_stack_pointer"
            },
            "code": "void * get_isr_stack_pointer_0000091c(void)\n{\n  return PTR_isr_stack_0000092c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000091c",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "get_isr_stack_pointer_0000091c"
        },
        "FUN_00005d80": {
            "renaming": {
                "FUN_00005d80": "write_to_stream_00005d80",
                "param_1": "stream",
                "param_2": "character",
                "param_3": "stream_info",
                "iVar1": "buffer_size",
                "puVar2": "buffer_ptr"
            },
            "code": "uint write_to_stream_00005d80(int stream, uint character, undefined4 *stream_info)\n{\n  int buffer_size = stream_info[2] - 1;\n  if ((stream_info[2] < 0) && ((stream_info[2] < (int)stream_info[6] || ((character & 0xff) == 10)))) {\n    character = __swbuf_r(stream, character, stream_info);\n  }\n  else {\n    undefined *buffer_ptr = (undefined *)*stream_info;\n    *stream_info = buffer_ptr + 1;\n    *buffer_ptr = (char)character;\n    character = character & 0xff;\n  }\n  return character;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__swbuf_r",
                "__retarget_lock_release_recursive",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005d80",
            "calling": [
                "putchar"
            ],
            "imported": false,
            "current_name": "write_to_stream_00005d80"
        },
        "FUN_00001f80": {
            "renaming": {
                "FUN_00001f80": "configure_gpio_pin_00001f80",
                "pin": "gpio_pin",
                "pcr": "pcr_value",
                "pPVar1": "port_ptr",
                "iVar2": "pin_number",
                "uVar3": "previous_pcr_value",
                "isr_state": "not_used",
                "clk_en": "enable_clock",
                "port": "get_port",
                "pin_num": "get_pin_number",
                "ctx_clear": "clear_context"
            },
            "code": "void configure_gpio_pin_00001f80(gpio_t gpio_pin, uint32_t pcr_value)\n{\n  PORT_Type *port_ptr;\n  int pin_number;\n  int pin_00;\n  uint32_t previous_pcr_value;\n  \n  enable_clock(gpio_pin);\n  port_ptr = get_port(gpio_pin);\n  pin_number = get_pin_number(gpio_pin);\n  previous_pcr_value = port_ptr->PCR[pin_number];\n  port_ptr->PCR[pin_number] = pcr_value;\n  if ((previous_pcr_value & 0xf0000) != 0) {\n    int port_number = get_port_number(gpio_pin);\n    pin_00 = get_pin_number(gpio_pin);\n    clear_context(port_number, pin_00);\n  }\n  return;\n}",
            "called": [
                "ctx_clear",
                "clk_en",
                "port",
                "port_num",
                "pin_num"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001f80",
            "calling": [
                "gpio_init",
                "uart_init_pins"
            ],
            "imported": false,
            "current_name": "configure_gpio_pin_00001f80"
        },
        "FUN_00000e64": {
            "renaming": {
                "FUN_00000e64": "initialize_cpu_and_gpio_00000e64",
                "DAT_00000ed0": "thread_list_offset",
                "DAT_00000ed4": "gpio1_ptr",
                "PTR_00000008": "uint",
                "PTR_0000000c": "cpu_init",
                "PTR_00000010": "gpio_init",
                "PTR_00000014": "gpio_set",
                "PTR_00000018": "GPIO_OUT"
            },
            "code": "void initialize_cpu_and_gpio_00000e64(void)\n{\n    PTR_00000008* thread_list_ptr = thread_add_to_list + DAT_00000ed0;\n    PTR_00000008* DAT_00000ed4 = DAT_00000ed4 + 0x48;\n\n    *thread_list_ptr |= 0x200;\n    *DAT_00000ed4 &= 0xfefff8ff;\n\n    PTR_0000000c();\n    PTR_00000010(0x2056, PTR_00000018);\n    PTR_00000010(0x511a, PTR_00000018);\n    PTR_00000010(0x2055, PTR_00000018);\n\n    PTR_00000014(0x2056);\n    PTR_00000014(0x511a);\n    PTR_00000014(0x2055);\n}",
            "called": [
                "gpio_set",
                "gpio_init",
                "cpu_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e64",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "initialize_cpu_and_gpio_00000e64"
        },
        "FUN_000026e4": {
            "renaming": {
                "FUN_000026e4": "power_off_rtt_000026e4"
            },
            "code": "void power_off_rtt_000026e4(void)\n{\n  rtt_poweroff();\n  return;\n}",
            "called": [
                "rtt_poweroff"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026e4",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "power_off_rtt_000026e4"
        },
        "FUN_00000d44": {
            "renaming": {
                "FUN_00000d44": "calculate_address_00000d44",
                "ptr": "ptr",
                "bit": "bit"
            },
            "code": "void * calculate_address_00000d44(void *ptr,uintptr_t bit)\n{\n    uint32_t upper_bits = (uint32_t)ptr & 0xf0000000;\n    uint32_t lower_bits = (uint32_t)ptr & 0xfffff;\n    uint32_t address = bit * 4 + (upper_bits | (lower_bits << 5) + 0x2000000);\n    return (void *)address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d44",
            "calling": [
                "bit_clear32"
            ],
            "imported": false,
            "current_name": "calculate_address_00000d44"
        },
        "FUN_00000698": {
            "renaming": {
                "FUN_00000698": "update_process_status_00000698",
                "process": "process",
                "status": "new_status",
                "PTR_sched_runqueues_00000730": "sched_runqueues",
                "PTR_runqueue_bitcache_00000734": "runqueue_bitcache",
                "clist_lpop": "clist_pop_left",
                "clist_rpush": "clist_push_right",
                "rq_entry": "runqueue_entry",
                "NUM_PRIORITIES": "MAX_PRIORITIES"
            },
            "code": "void update_process_status_00000698(thread_t *process, uint new_status) {\\n\\\n  if (new_status < 9) {\\n\\\n    if ((process->status > 8) && (process->priority < NUM_PRIORITIES) && (clist_lpop(&PTR_sched_runqueues_00000730[process->priority])->data == process)) {\\n\\\n      PTR_runqueue_bitcache_00000734 = PTR_runqueue_bitcache_00000734 & ~(1 << process->priority);\\n\\\n    }\\n\\\n  }\\n\\\n  else if (process->status < 9) {\\n\\\n    clist_rpush(&PTR_sched_runqueues_00000730[process->priority], &process->rq_entry);\\n\\\n    PTR_runqueue_bitcache_00000734 = PTR_runqueue_bitcache_00000734 | 1 << process->priority;\\n\\\n  }\\n\\\n  process->status = (uint8_t)new_status;\\n\\\n  return;\\n\\\n}",
            "called": [
                "clist_lpop",
                "clist_rpush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000698",
            "calling": [
                "thread_create",
                "mutex_unlock",
                "sched_task_exit",
                "_mutex_lock"
            ],
            "imported": false,
            "current_name": "update_process_status_00000698"
        },
        "FUN_00000cd0": {
            "renaming": {
                "FUN_00000cd0": "get_IRQ_interrupts_enabled_status_00000cd0",
                "uVar2": "irq_interrupts_enabled",
                "bVar1": "is_privileged_mode",
                "mask": "mask",
                "result": "result"
            },
            "code": "uint get_IRQ_interrupts_enabled_status_00000cd0(void)\n{\n  bool is_privileged_mode = (bool)isCurrentModePrivileged();\n  uint irq_interrupts_enabled = 0;\n  if (is_privileged_mode) {\n    irq_interrupts_enabled = isIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return irq_interrupts_enabled;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cd0",
            "calling": [
                "kinetis_mcg_init",
                "pm_off",
                "_sbrk_r",
                "thread_create",
                "mutex_unlock",
                "sched_task_exit",
                "_mutex_lock",
                "core_panic",
                "kernel_init"
            ],
            "imported": false,
            "current_name": "get_IRQ_interrupts_enabled_status_00000cd0"
        },
        "FUN_00000cc0": {
            "renaming": {
                "FUN_00000cc0": "handle_dummy_handler_00000cc0",
                "PANIC_DUMMY_HANDLER": "panic_dummy_handler",
                "PTR_s_DUMMY_HANDLER_00000ccc": "dummy_handler"
            },
            "code": "void handle_dummy_handler_00000cc0(void)\n{\n    core_panic(PANIC_DUMMY_HANDLER, PTR_s_DUMMY_HANDLER_00000ccc);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cc0",
            "calling": [
                "dummy_handler"
            ],
            "imported": false,
            "current_name": "handle_dummy_handler_00000cc0"
        },
        "FUN_00002994": {
            "renaming": {
                "FUN_00002994": "check_and_execute_rtt_callback_00002994",
                "DAT_000029f8": "data",
                "PTR_rtt_callback_000029fc": "rtt_callback"
            },
            "code": "void check_and_execute_rtt_callback_00002994(void)\n{\n  int DAT_000029f8 = DAT_000029f8;\n  if (((*(uint *)(DAT_000029f8 + 0x14) & 4) != 0) && (*(int *)PTR_PTR_rtt_callback_000029fc_000029fc != 0)) {\n    *(uint *)(DAT_000029f8 + 0x1c) &= 0xfffffffb;\n    (**(code **)PTR_PTR_rtt_callback_000029fc_000029fc)(*(undefined4 *)(PTR_PTR_rtt_callback_000029fc_000029fc + 4));\n  }\n  if (((*(uint *)(DAT_000029f8 + 0x14) & 2) != 0) && (*(int *)(PTR_PTR_rtt_callback_000029fc_000029fc + 8) != 0)) {\n    (**(code **)(PTR_PTR_rtt_callback_000029fc_000029fc + 8))(*(undefined4 *)(PTR_PTR_rtt_callback_000029fc_000029fc + 0xc));\n  }\n  cortexm_isr_end();\n  return;\n}",
            "called": [
                "cortexm_isr_end"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002994",
            "calling": [],
            "imported": false,
            "current_name": "check_and_execute_rtt_callback_00002994"
        },
        "FUN_00000d2a": {
            "renaming": {
                "FUN_00000d2a": "get_current_exception_number_if_privileged_mode_00000d2a",
                "uVar2": "current_exception_number",
                "bVar1": "is_privileged_mode"
            },
            "code": "uint32_t get_current_exception_number_if_privileged_mode_00000d2a() {\n    bool is_privileged_mode = (bool)isCurrentModePrivileged();\n    uint32_t current_exception_number = 0;\n    if (is_privileged_mode) {\n        current_exception_number = getCurrentExceptionNumber() & 0x1f;\n    }\n    return current_exception_number;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d2a",
            "calling": [
                "sched_switch"
            ],
            "imported": false,
            "current_name": "get_current_exception_number_if_privileged_mode_00000d2a"
        },
        "FUN_00001ff6": {
            "renaming": {
                "FUN_00001ff6": "set_gpio_pin_high_00001ff6",
                "pin": "gpio_pin",
                "uVar1": "pin_number",
                "pGVar2": "gpio_ptr"
            },
            "code": "void set_gpio_pin_high_00001ff6(gpio_t pin)\n{\n  uint32_t pin_number = pin_num(pin);\n  GPIO_Type *gpio_ptr = gpio(pin);\n  gpio_ptr->PSOR = 1 << (pin_number & 0xff);\n  return;\n}",
            "called": [
                "gpio",
                "pin_num"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ff6",
            "calling": [
                "board_init"
            ],
            "imported": false,
            "current_name": "set_gpio_pin_high_00001ff6"
        },
        "FUN_000013b8": {
            "renaming": {
                "FUN_000013b8": "initialize_uart_000013b8",
                "uart": "uart_id",
                "baudrate": "baud_rate",
                "rx_cb": "receive_callback",
                "arg": "receive_callback_arg",
                "PTR_config_00001440": "uart_receive_callback",
                "PTR_uart_config_00001444": "uart_config_register",
                "FUN_000013b8_pins": "initialize_uart_pins",
                "bit_set32": "set_bit_in_register"
            },
            "code": "int initialize_uart_000013b8(uart_t uart, uint32_t baudrate, uart_rx_cb_t receive_callback, void *arg) {\\n  int status = 0;\\n  if (uart != 0) {\\n    core_panic(PANIC_ASSERT_FAIL, ASSERT_CRASH_MESSAGE);\\n  }\\n  *PTR_config_00001440 = receive_callback;\\n  *PTR_config_00001440_arg = arg;\\n  initialize_uart_000013b8_pins(0);\\n  set_bit_in_register(*PTR_uart_config_00001444 + 0x18, *(PTR_uart_config_00001444 + 0x1c));\\n  if (*(PTR_uart_config_00001444 + 0x1e) == \"\\0\") {\\n    initialize_uart_000013b8_module(0, baudrate);\\n  }\\n  else {\\n    status = -1;\\n  }\\n  return status;\\n}",
            "called": [
                "uart_init_pins",
                "uart_init_uart",
                "core_panic",
                "bit_set32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000013b8",
            "calling": [
                "uart_stdio_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_000013b8"
        },
        "FUN_00000f80": {
            "renaming": {
                "FUN_00000f80": "infinite_loop_00000f80"
            },
            "code": "void *infinite_loop_00000f80(void *arg)\n{\n  while(true)\n  {\n    // do nothing\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f80",
            "calling": [],
            "imported": false,
            "current_name": "infinite_loop_00000f80"
        },
        "FUN_00002a88": {
            "renaming": {
                "FUN_00002a88": "print_shell_commands_00002a88",
                "command_list": "shell_command_list",
                "command_lists": "command_lists",
                "i": "index",
                "entry": "current_command",
                "PTR_s___20s__s_00002b04": "COMMAND_LABEL",
                "PTR_s_Command_00002b00": "COMMAND_LABEL",
                "PTR_s_Description_00002afc": "DESCRIPTION_LABEL",
                "PTR_s__________________________________00002b08": "SEPARATOR_LABEL",
                "shell_command_t": "shell_command_t",
                "char": "char",
                "PTR__shell_command_list_00002b0c": "SHELL_COMMAND_LIST"
            },
            "code": "void print_shell_commands_00002a88(shell_command_t *command_list)\n{\n    shell_command_t *command_lists[2];\n    uint32_t i;\n    shell_command_t *current_command;\n\n    printf(\"%s %s\\n\", PTR_s___20s__s_00002b04, PTR_s_Description_00002afc);\n    printf(\"%s\\n\", PTR_s__________________________________00002b08);\n\n    command_lists[0] = command_list;\n    command_lists[1] = (shell_command_t *)PTR__shell_command_list_00002b0c;\n\n    for (i = 0; i < 2; i++) {\n        current_command = command_lists[i];\n        if (current_command != (shell_command_t *)0x0) {\n            for (; current_command->name != (char *)0x0; current_command++) {\n                printf(\"%s %s\\n\", current_command->name, current_command->desc);\n            }\n        }\n    }\n    return;\n}",
            "called": [
                "iprintf",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a88",
            "calling": [
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "print_shell_commands_00002a88"
        },
        "FUN_00002f30": {
            "renaming": {
                "FUN_00002f30": "print_saul_devices_00002f30",
                "i": "device_index",
                "dev": "current_device"
            },
            "code": "void print_saul_devices_00002f30(void)\n{\n  int device_index = 0;\n  saul_reg_t *current_device = *(saul_reg_t **)PTR_saul_reg_00002f6c;\n  while (current_device != (saul_reg_t *)0x0) {\n    probe(device_index, current_device);\n    puts(PTR_DAT_00002f70);\n    device_index++;\n    current_device = current_device->next;\n  }\n  return;\n}",
            "called": [
                "puts",
                "probe"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f30",
            "calling": [
                "read"
            ],
            "imported": false,
            "current_name": "print_saul_devices_00002f30"
        },
        "FUN_00001e44": {
            "renaming": {
                "FUN_00001e44": "set_pin_context_00001e44",
                "port": "port_num",
                "pin": "pin_num",
                "ctx": "context",
                "iVar1": "pin_offset",
                "PTR_isr_map_00001ec0": "isr_map",
                "mask": "mask",
                "context_shifted": "context_shifted",
                "pin_entry": "pin_entry"
            },
            "code": "void set_pin_context_00001e44(int port_num, int pin_num, int context) {\n  int pin_offset = pin_num >> 3;\n  uint32_t* PTR_isr_map_00001ec0 = PTR_PTR_isr_map_00001ec0_00001ec0;\n  uint32_t* pin_entry = PTR_isr_map_00001ec0 + (pin_offset + port_num * 4) * 4;\n  uint32_t mask = ~(0xf << ((pin_num & 7U) << 2));\n  uint32_t context_shifted = context << ((pin_num & 7U) << 2);\n  *pin_entry = (*pin_entry & mask) | context_shifted;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e44",
            "calling": [
                "ctx_clear"
            ],
            "imported": false,
            "current_name": "set_pin_context_00001e44"
        },
        "FUN_00001318": {
            "renaming": {
                "FUN_00001318": "set_IRQ_priority_00001318",
                "IRQn": "IRQ_number",
                "DAT_00001344": "IRQ_PRIORITY_REGISTER_BASE_ADDRESS"
            },
            "code": "void set_IRQ_priority_00001318(IRQn_Type IRQn)\n{\n    int* IRQ_priority_register = (int *)(DAT_00001344 + ((uint)(int)IRQn >> 5) * 4);\n    int IRQ_priority_bit_position = IRQn & 0x1fU;\n    int IRQ_priority_bit_mask = 1 << IRQ_priority_bit_position;\n    *IRQ_priority_register = IRQ_priority_bit_mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001318",
            "calling": [
                "uart_init_uart"
            ],
            "imported": false,
            "current_name": "set_IRQ_priority_00001318"
        },
        "FUN_00000900": {
            "renaming": {
                "FUN_00000900": "get_main_stack_pointer_00000900",
                "pvVar1": "main_stack_pointer",
                "result": "N/A",
                "msp": "N/A"
            },
            "code": "\nvoid *get_main_stack_pointer_00000900(void)\n{\n  void *main_stack_pointer;\n  main_stack_pointer = (void *)getMainStackPointer();\n  return main_stack_pointer;\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000900",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "get_main_stack_pointer_00000900"
        },
        "FUN_00004274": {
            "renaming": {
                "FUN_00004274": "acquire_recursive_mutex_00004274",
                "PTR___lock___sfp_recursive_mutex_0000427c": "sfp_recursive_mutex"
            },
            "code": "void acquire_recursive_mutex_00004274(void)\n{\n  __retarget_lock_acquire_recursive(PTR___lock___sfp_recursive_mutex_0000427c);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004274",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "acquire_recursive_mutex_00004274"
        },
        "FUN_00002fe0": {
            "renaming": {
                "FUN_00002fe0": "print_device_info_00002fe0",
                "argc": "num_args",
                "argv": "args",
                "iVar1": "index",
                "dev_00": "device",
                "dev": "all_devices",
                "num": "unused"
            },
            "code": "void print_device_info_00002fe0(int num_args, char **args) {\n  int index;\n  saul_reg_t *device;\n  saul_reg_t *all_devices;\n  \n  if (num_args < 3) {\n    iprintf(PTR_s_usage___s__s__device_id__all_00003050, *args, args[1]);\n  }\n  else {\n    if (strcmp(args[2], PTR_DAT_00003054) == 0) {\n      probe_all();\n    }\n    else {\n      index = atoi(args[2]);\n      device = saul_reg_find_nth(index);\n      if (device == (saul_reg_t *)0x0) {\n        puts(PTR_s_error__undefined_device_id_given_00003058);\n      }\n      else {\n        probe(index, device);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "saul_reg_find_nth",
                "atoi",
                "iprintf",
                "probe_all",
                "strcmp",
                "puts",
                "probe"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002fe0",
            "calling": [
                "_saul"
            ],
            "imported": false,
            "current_name": "print_device_info_00002fe0"
        },
        "FUN_00001dc0": {
            "renaming": {
                "FUN_00001dc0": "get_gpio_pin_number_00001dc0",
                "pin": "gpio_pin",
                "MAX_PIN_NUMBER": "max_pin_number"
            },
            "code": "int get_gpio_pin_number_00001dc0(gpio_t pin) {\n    const int MAX_PIN_NUMBER = 0x3f;\n    return pin & MAX_PIN_NUMBER;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001dc0",
            "calling": [
                "gpio_set",
                "gpio_init",
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "get_gpio_pin_number_00001dc0"
        },
        "FUN_00000df4": {
            "renaming": {
                "FUN_00000df4": "initialize_uart_00000df4",
                "DAT_00000e10": "fifo_size",
                "PTR_uart_stdio_isrpipe_00000e0c": "isr_pipe"
            },
            "code": "void initialize_uart_00000df4(void)\n{\n  int baud_rate = 115200;\n  int uart_num = 0;\n  int DAT_00000e10 = 0x1c200;\n  int PTR_uart_stdio_isrpipe_00000e0c = PTR_uart_stdio_isrpipe_00000e0c;\n  uart_init(uart_num, baud_rate, DAT_00000e10, PTR_uart_stdio_isrpipe_00000e0c);\n  return;\n}",
            "called": [
                "uart_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000df4",
            "calling": [
                "_init"
            ],
            "imported": false,
            "current_name": "initialize_uart_00000df4"
        },
        "FUN_00002400": {
            "renaming": {
                "FUN_00002400": "do_nothing_00002400"
            },
            "code": "\nvoid do_nothing_00002400(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002400",
            "calling": [
                "main_trampoline"
            ],
            "imported": false,
            "current_name": "do_nothing_00002400"
        },
        "FUN_00002eb4": {
            "renaming": {
                "FUN_00002eb4": "print_system_info_00002eb4",
                "argc": "argument_count",
                "argv": "argument_values",
                "ps": "print_system"
            },
            "code": "int print_system_info_00002eb4(int argc,char **argv)\n{\n  print_system();\n  return 0;\n}",
            "called": [
                "ps"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002eb4",
            "calling": [],
            "imported": false,
            "current_name": "print_system_info_00002eb4"
        },
        "FUN_0000328c": {
            "renaming": {
                "FUN_0000328c": "convert_to_tm_0000328c",
                "argv": "input_arguments",
                "time": "output_time",
                "lVar1": "parsed_long",
                "iVar2": "day_of_week",
                "end": "end_pointer",
                "i": "parsed_short"
            },
            "code": "int convert_to_tm_0000328c(char **input_arguments, tm *output_time)\n{\n  long parsed_long;\n  int parsed_integer;\n  char *end_pointer;\n  short parsed_short;\n\n  parsed_long = strtol(*input_arguments, &end_pointer, 10);\n  parsed_short = (short)parsed_long;\n  output_time->tm_year = parsed_short - 1900;\n  parsed_long = strtol(end_pointer + 1, &end_pointer, 10);\n  parsed_short = (short)parsed_long;\n  output_time->tm_mon = parsed_short - 1;\n  parsed_long = strtol(end_pointer + 1, &end_pointer, 10);\n  parsed_short = (short)parsed_long;\n  output_time->tm_mday = (int)parsed_short;\n  parsed_long = strtol(input_arguments[1], &end_pointer, 10);\n  parsed_short = (short)parsed_long;\n  output_time->tm_hour = (int)parsed_short;\n  parsed_long = strtol(end_pointer + 1, &end_pointer, 10);\n  parsed_short = (short)parsed_long;\n  output_time->tm_min = (int)parsed_short;\n  parsed_long = strtol(end_pointer + 1, &end_pointer, 10);\n  parsed_short = (short)parsed_long;\n  output_time->tm_sec = (int)parsed_short;\n  int day_of_week = calculate_day_of_week(output_time->tm_year + 1900, output_time->tm_mon + 1, output_time->tm_mday);\n  output_time->tm_wday = day_of_week;\n  output_time->tm_isdst = -1;\n  return 0;\n}",
            "called": [
                "dow",
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000328c",
            "calling": [
                "_rtc_setalarm",
                "_rtc_settime"
            ],
            "imported": false,
            "current_name": "convert_to_tm_0000328c"
        },
        "FUN_000041f4": {
            "renaming": {
                "FUN_000041f4": "initialize_data_structures_000041f4",
                "param_1": "data_array",
                "param_2": "initial_value_1",
                "param_3": "initial_value_2",
                "DAT_0000422c": "PTR_DAT_0000422c",
                "DAT_00004230": "PTR_DAT_00004230",
                "DAT_00004234": "PTR_DAT_00004234",
                "DAT_00004238": "PTR_DAT_00004238"
            },
            "code": "void initialize_data_structures_000041f4(undefined4 *data_array, undefined2 initial_value_1, undefined2 initial_value_2)\n{\n  \n  data_array[0] = 0;\n  data_array[1] = 0;\n  data_array[4] = 0;\n  data_array[5] = 0;\n  data_array[2] = 0;\n  *(undefined2 *)(data_array + 3) = initial_value_1;\n  data_array[0x19] = 0;\n  *(undefined2 *)((int)data_array + 0xe) = initial_value_2;\n  data_array[6] = 0;\n  memset(data_array + 0x17,0,8);\n  data_array[9] = DAT_0000422c;\n  data_array[10] = DAT_00004230;\n  data_array[0xb] = DAT_00004234;\n  undefined4 uVar1 = DAT_00004238;\n  data_array[8] = data_array;\n  data_array[0xc] = uVar1;\n  return;\n}",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041f4",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "initialize_data_structures_000041f4"
        },
        "FUN_0000316c": {
            "renaming": {
                "FUN_0000316c": "process_command_line_arguments_0000316c",
                "argc": "argument_count",
                "argv": "arguments",
                "iVar1": "comparison_result",
                "list": "list_files",
                "strcmp": "strcmp",
                "PTR_DAT_000031d4": "PTR_DAT_000031d4",
                "read": "read_file",
                "PTR_s_write_000031d8": "PTR_s_write_000031d8",
                "write": "write_file",
                "iprintf": "iprintf",
                "PTR_s_usage___s_read_write_000031dc": "PTR_s_usage___s_read_write_000031dc"
            },
            "code": "int process_command_line_arguments_0000316c(int argument_count, char **arguments)\n{\n  int comparison_result;\n  if (argument_count < 2) {\n    list_files();\n  }\n  else {\n    comparison_result = strcmp(arguments[1], PTR_DAT_000031d4);\n    if (comparison_result == 0) {\n      read_file(argument_count, arguments);\n    }\n    else {\n      comparison_result = strcmp(arguments[1], PTR_s_write_000031d8);\n      if (comparison_result == 0) {\n        write_file(argument_count, arguments);\n      }\n      else {\n        iprintf(PTR_s_usage___s_read_write_000031dc, *arguments);\n      }\n    }\n  }\n  return 0;\n}",
            "called": [
                "read",
                "iprintf",
                "strcmp",
                "write",
                "list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000316c",
            "calling": [],
            "imported": false,
            "current_name": "process_command_line_arguments_0000316c"
        },
        "FUN_000026f0": {
            "renaming": {
                "FUN_000026f0": "run_rtc_callback_000026f0",
                "arg": "data",
                "PTR_rtc_callback_00002710": "callback_ptr",
                "DAT_00002714": "callback_func"
            },
            "code": "void run_rtc_callback_000026f0(void *data) {\n  int *PTR_rtc_callback_00002710 = (int *)PTR_rtc_callback_00002710;\n  if (*PTR_rtc_callback_00002710 != 0) {\n    code *DAT_00002714 = *(code **)(PTR_rtc_callback_00002710);\n    (*DAT_00002714)(data);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026f0",
            "calling": [],
            "imported": false,
            "current_name": "run_rtc_callback_000026f0"
        },
        "FUN_0000510c": {
            "renaming": {
                "FUN_0000510c": "FUNC_0000510c"
            },
            "code": "\nvoid FUNC_0000510c(undefined4 param_1)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  int iVar4;\n  char *pcVar5;\n  void *__ptr;\n  size_t sVar6;\n  char *pcVar7;\n  int iVar8;\n  int iVar9;\n  ulong uVar10;\n  char cVar11;\n  bool bVar12;\n  ushort *puVar13;\n  int *piVar14;\n  ushort *puVar15;\n  int *piVar16;\n  ushort local_3c;\n  ushort local_3a;\n  ushort local_38;\n  ushort local_36;\n  ushort local_34;\n  ushort local_32;\n  int local_30;\n  char *local_2c [2];\n  \n  iVar4 = __gettzinfo();\n  puVar1 = PTR_prev_tzenv_000053d8;\n  pcVar5 = (char *)_getenv_r(param_1,PTR_DAT_000053d4);\n  puVar2 = PTR_LAB_00007a5e_1_000053e0;\n  if (pcVar5 == (char *)0x0) {\n    *(undefined4 *)PTR__timezone_000053dc = 0;\n    *(undefined4 *)PTR__daylight_000053e4 = 0;\n    puVar3 = PTR__tzname_000053e8;\n    __ptr = *(void **)puVar1;\n    *(undefined **)PTR__tzname_000053e8 = puVar2;\n    *(undefined **)(puVar3 + 4) = puVar2;\n    free(__ptr);\n    *(undefined4 *)puVar1 = 0;\n  }\n  else if ((*(char **)puVar1 == (char *)0x0) ||\n          (iVar8 = strcmp(pcVar5,*(char **)puVar1), iVar8 != 0)) {\n    free(*(void **)puVar1);\n    sVar6 = strlen(pcVar5);\n    pcVar7 = (char *)_malloc_r(param_1,sVar6 + 1);\n    *(char **)puVar1 = pcVar7;\n    if (pcVar7 != (char *)0x0) {\n      strcpy(pcVar7,pcVar5);\n    }\n    if (*pcVar5 == ':') {\n      pcVar5 = pcVar5 + 1;\n    }\n    iVar8 = siscanf(pcVar5,PTR_s__10__0_9_____n_000053f0,PTR___tzname_std_000053ec,&local_30);\n    if (0 < iVar8) {\n      pcVar7 = pcVar5 + local_30;\n      if (pcVar5[local_30] == '-') {\n        pcVar7 = pcVar7 + 1;\n        iVar8 = -1;\n      }\n      else {\n        if (pcVar5[local_30] == '+') {\n          pcVar7 = pcVar7 + 1;\n        }\n        iVar8 = 1;\n      }\n      local_3a = 0;\n      local_38 = 0;\n      puVar13 = &local_3a;\n      piVar14 = &local_30;\n      puVar15 = &local_38;\n      piVar16 = &local_30;\n      iVar9 = siscanf(pcVar7,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a,\n                      &local_30,&local_38,&local_30);\n      puVar1 = PTR___tzname_dst_00005400;\n      if (0 < iVar9) {\n        *(uint *)(iVar4 + 0x28) =\n             ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar8;\n        puVar2 = PTR__tzname_000053e8;\n        *(undefined **)PTR__tzname_000053e8 = PTR___tzname_std_000053ec;\n        pcVar7 = pcVar7 + local_30;\n        iVar8 = siscanf(pcVar7,PTR_s__10__0_9_____n_000053f0,puVar1,&local_30,puVar13,piVar14,\n                        puVar15,piVar16);\n        if (iVar8 < 1) {\n          *(undefined4 *)(puVar2 + 4) = *(undefined4 *)puVar2;\n          *(undefined4 *)PTR__timezone_000053dc = *(undefined4 *)(iVar4 + 0x28);\n          *(undefined4 *)PTR__daylight_000053e4 = 0;\n        }\n        else {\n          *(undefined **)(puVar2 + 4) = puVar1;\n          pcVar5 = pcVar7 + local_30;\n          if (pcVar7[local_30] == '-') {\n            pcVar5 = pcVar5 + 1;\n            iVar8 = -1;\n          }\n          else {\n            if (pcVar7[local_30] == '+') {\n              pcVar5 = pcVar5 + 1;\n            }\n            iVar8 = 1;\n          }\n          local_3c = 0;\n          local_3a = 0;\n          local_38 = 0;\n          local_30 = 0;\n          iVar9 = siscanf(pcVar5,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a,\n                          &local_30,&local_38,&local_30);\n          if (iVar9 < 1) {\n            iVar8 = *(int *)(iVar4 + 0x28) + -0xe10;\n          }\n          else {\n            iVar8 = ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar8;\n          }\n          *(int *)(iVar4 + 0x50) = iVar8;\n          pcVar5 = pcVar5 + local_30;\n          bVar12 = false;\n          iVar8 = iVar4;\n          while( true ) {\n            if (*pcVar5 == ',') {\n              pcVar5 = pcVar5 + 1;\n            }\n            cVar11 = *pcVar5;\n            if (cVar11 == 'M') {\n              iVar9 = siscanf(pcVar5,PTR_s_M_hu_n__hu_n__hu_n_000053f8,&local_36,&local_30,&local_34\n                              ,&local_30,&local_32,&local_30);\n              if (iVar9 != 3) {\n                return;\n              }\n              if (0xb < local_36 - 1) {\n                return;\n              }\n              if (4 < local_34 - 1) {\n                return;\n              }\n              if (6 < local_32) {\n                return;\n              }\n              *(uint *)(iVar8 + 0xc) = (uint)local_36;\n              *(uint *)(iVar8 + 0x10) = (uint)local_34;\n              *(undefined *)(iVar8 + 8) = 0x4d;\n              *(uint *)(iVar8 + 0x14) = (uint)local_32;\n              pcVar7 = pcVar5 + local_30;\n            }\n            else {\n              if (cVar11 == 'J') {\n                pcVar5 = pcVar5 + 1;\n              }\n              else {\n                cVar11 = 'D';\n              }\n              uVar10 = strtoul(pcVar5,local_2c,10);\n              local_32 = (ushort)uVar10;\n              pcVar7 = local_2c[0];\n              if (local_2c[0] == pcVar5) {\n                if (bVar12) {\n                  *(undefined *)(iVar4 + 0x30) = 0x4d;\n                  *(undefined4 *)(iVar4 + 0x34) = 0xb;\n                  *(undefined4 *)(iVar4 + 0x38) = 1;\n                  *(undefined4 *)(iVar4 + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(iVar4 + 8) = 0x4d;\n                  *(undefined4 *)(iVar4 + 0xc) = 3;\n                  *(undefined4 *)(iVar4 + 0x10) = 2;\n                  *(undefined4 *)(iVar4 + 0x14) = 0;\n                }\n              }\n              else {\n                *(char *)(iVar8 + 8) = cVar11;\n                *(ulong *)(iVar8 + 0x14) = uVar10 & 0xffff;\n              }\n            }\n            local_3c = 2;\n            local_3a = 0;\n            local_38 = 0;\n            local_30 = 0;\n            if (*pcVar7 == '/') {\n              siscanf(pcVar7,PTR_DAT_000053fc,&local_3c,&local_30,&local_3a,&local_30,&local_38,\n                      &local_30);\n            }\n            *(uint *)(iVar8 + 0x18) =\n                 (uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38;\n            iVar8 = iVar8 + 0x28;\n            pcVar5 = pcVar7 + local_30;\n            if (bVar12) break;\n            bVar12 = true;\n          }\n          __tzcalc_limits(*(undefined4 *)(iVar4 + 4));\n          iVar8 = *(int *)(iVar4 + 0x28);\n          *(int *)PTR__timezone_000053dc = iVar8;\n          iVar8 = *(int *)(iVar4 + 0x50) - iVar8;\n          if (iVar8 != 0) {\n            iVar8 = 1;\n          }\n          *(int *)PTR__daylight_000053e4 = iVar8;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "__gettzinfo",
                "__tzcalc_limits",
                "_getenv_r",
                "strcpy",
                "siscanf",
                "strlen",
                "strcmp",
                "free",
                "_malloc_r",
                "strtoul"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0000510c",
            "calling": [
                "_tzset_unlocked"
            ],
            "imported": false,
            "current_name": "FUNC_0000510c"
        },
        "FUN_000057d2": {
            "renaming": {
                "FUN_000057d2": "write_to_stream_000057d2",
                "param_1": "file_descriptor",
                "param_2": "status",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "iVar1": "result",
                "puVar2": "end_of_buffer",
                "iVar3": "bytes_written"
            },
            "code": "int write_to_stream_000057d2(int file_descriptor, int status, char *buffer, int buffer_size) {\n  int bytes_written = 0;\n  char *end_of_buffer = buffer + buffer_size;\n  while (bytes_written != buffer_size) {\n    if (buffer == end_of_buffer) {\n      return 0;\n    }\n    int result = __sfputc_r(file_descriptor, *buffer, status, buffer_size, bytes_written);\n    bytes_written = result + 1;\n    buffer = buffer + 1;\n  }\n  return bytes_written;\n}",
            "called": [
                "__sfputc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057d2",
            "calling": [
                "_vfprintf_r"
            ],
            "imported": false,
            "current_name": "write_to_stream_000057d2"
        },
        "FUN_00000958": {
            "renaming": {
                "FUN_00000958": "runScheduler_00000958",
                "unaff_r4": "r4",
                "unaff_r5": "r5",
                "unaff_r6": "r6",
                "unaff_r7": "r7",
                "unaff_r8": "r8",
                "unaff_r9": "r9",
                "unaff_r10": "r10",
                "unaff_r11": "r11",
                "in_lr": "lr",
                "PTR_sched_active_thread_00000970": "currentThread",
                "isr_svc": "handleInterrupt",
                "sched_run": "scheduleThreads",
                "UNRECOVERED_JUMPTABLE": "currentThreadFunctionPtr",
                "ppcVar3": "currentThreadStackPointer",
                "bVar1": "isPrivileged"
            },
            "code": "void runScheduler_00000958(void)\n{\n  bool isPrivileged;\n  int processStackPointer;\n  code *PTR_sched_active_thread_00000970Function;\n  code **PTR_sched_active_thread_00000970StackPointer;\n  processStackPointer = getProcessStackPointer();\n  *(undefined4 *)(processStackPointer - 4) = r11;\n  *(undefined4 *)(processStackPointer - 8) = r10;\n  *(undefined4 *)(processStackPointer - 12) = r9;\n  *(undefined4 *)(processStackPointer - 16) = r8;\n  *(undefined4 *)(processStackPointer - 20) = r7;\n  *(undefined4 *)(processStackPointer - 24) = r6;\n  *(undefined4 *)(processStackPointer - 28) = r5;\n  *(undefined4 *)(processStackPointer - 32) = r4;\n  *(undefined4 *)(processStackPointer - 36) = lr;\n  **(int **)PTR_sched_active_thread_00000970 = (int)(undefined4 *)(processStackPointer - 36);\n  isr_svc();\n  sched_run();\n  PTR_sched_active_thread_00000970Function = *(code **)**(undefined4 **)PTR_sched_active_thread_00000970FunctionPtr;\n  PTR_sched_active_thread_00000970StackPointer = (code **)**(undefined4 **)PTR_sched_active_thread_00000970FunctionPtr + 9;\n  isPrivileged = (bool)isCurrentModePrivileged();\n  if (isPrivileged) {\n    setProcessStackPointer(PTR_sched_active_thread_00000970StackPointer);\n  }\n  (*PTR_sched_active_thread_00000970Function)(PTR_sched_active_thread_00000970Function,PTR_sched_active_thread_00000970StackPointer);\n  return;\n}",
            "called": [
                "isr_svc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000958",
            "calling": [],
            "imported": false,
            "current_name": "runScheduler_00000958"
        },
        "FUN_000056b8": {
            "renaming": {
                "FUN_000056b8": "check_file_permission_000056b8",
                "param_1": "reent",
                "param_2": "fd",
                "param_3": "permission",
                "param_4": "error",
                "iVar1": "status",
                "uVar2": "result",
                "sStack_68": "file_stat"
            },
            "code": "int check_file_permission_000056b8(_reent *reent, int fd, uint32_t *permission, uint32_t *error) {\n    int status;\n    uint32_t result;\n    struct stat file_stat;\n\n    if ((*(short *)(fd + 0xe) < 0) || ((status = _fstat_r(reent, (int)*(short *)(fd + 0xe), &file_stat)) < 0)) {\n        *error = 0;\n        if ((int)((uint)*(ushort *)(fd + 0xc) << 0x18) < 0) {\n            result = 0x40;\n            goto LAB_000056f8;\n        }\n    }\n    else {\n        *error = 0;\n        *permission = (uint32_t)((file_stat.st_mode & 0xf000) == 0x2000);\n    }\n    result = 0x400;\n\nLAB_000056f8:\n    *permission = result;\n    return 0;\n}",
            "called": [
                "_fstat_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b8",
            "calling": [
                "__smakebuf_r"
            ],
            "imported": false,
            "current_name": "check_file_permission_000056b8"
        },
        "FUN_00001a18": {
            "renaming": {
                "FUN_00001a18": "set_mode_to_4_00001a18",
                "DAT_00001a34": "byte_to_set_bit_in",
                "kinetis_mcg_disable_pll": "disable_pll",
                "*PTR_current_mode_00001a38": "current_mode_ptr"
            },
            "code": "void set_mode_to_4_00001a18(void)\n{\n  set_bit_in_byte(DAT_00001a34, 0x01);\n  disable_pll();\n  **PTR_current_mode_00001a38 = 4;\n  return;\n}",
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a18",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "set_mode_to_4_00001a18"
        },
        "FUN_00000d9c": {
            "renaming": {
                "FUN_00000d9c": "clear_null_terminator_00000d9c",
                "DAT_00000dac": "data_pointer"
            },
            "code": "void clear_null_terminator_00000d9c(void)\n{\n  bit_clear32(DAT_00000dac, '\\0');\n  return;\n}",
            "called": [
                "bit_clear32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d9c",
            "calling": [
                "pre_startup"
            ],
            "imported": false,
            "current_name": "clear_null_terminator_00000d9c"
        },
        "FUN_00003ff4": {
            "renaming": {
                "FUN_00003ff4": "pad_string_00003ff4",
                "out": "output",
                "in_len": "input_length",
                "pad_len": "padding_length",
                "pad_char": "padding_char",
                "sVar1": "padded_length",
                "n": "not_used"
            },
            "code": "size_t pad_string_00003ff4(char *output, size_t input_length, size_t padding_length, char padding_char) {\n  size_t padded_length = input_length;\n  if ((input_length < padding_length) && (output != NULL)) {\n    memmove(output + (padding_length - input_length), output, input_length);\n    memset(output, (unsigned char) padding_char, padding_length - input_length);\n    padded_length = padding_length;\n  }\n  return padded_length;\n}",
            "called": [
                "memset",
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ff4",
            "calling": [
                "fmt_s32_dfp"
            ],
            "imported": false,
            "current_name": "pad_string_00003ff4"
        },
        "FUN_00004634": {
            "renaming": {
                "FUN_00004634": "FUNC_00004634"
            },
            "code": "\nvoid FUNC_00004634(uint *param_1,uint param_2,undefined4 param_3)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  bool bVar6;\n  uint *local_20;\n  uint local_1c;\n  undefined4 uStack_18;\n  \n  local_20 = param_1;\n  local_1c = param_2;\n  uStack_18 = param_3;\n  if (0x3b < *param_1) {\n    div((int)&local_20,*param_1);\n    uVar3 = param_1[1] + (int)local_20;\n    param_1[1] = uVar3;\n    if ((int)local_1c < 0) {\n      uVar3 = uVar3 - 1;\n      *param_1 = local_1c + 0x3c;\n    }\n    else {\n      *param_1 = local_1c;\n    }\n    if ((int)local_1c < 0) {\n      param_1[1] = uVar3;\n    }\n  }\n  if (0x3b < param_1[1]) {\n    div((int)&local_20,param_1[1]);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[2] + (int)local_20;\n    param_1[2] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x3c;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar4;\n    }\n  }\n  if (0x17 < param_1[2]) {\n    div((int)&local_20,param_1[2]);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[3] + (int)local_20;\n    param_1[3] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x18;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[3] = uVar4;\n    }\n  }\n  if (0xb < param_1[4]) {\n    div((int)&local_20,param_1[4]);\n    bVar6 = (int)local_1c < 0;\n    uVar3 = param_1[5] + (int)local_20;\n    param_1[5] = uVar3;\n    if (bVar6) {\n      local_1c = local_1c + 0xc;\n      uVar3 = uVar3 - 1;\n    }\n    if (!bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[5] = uVar3;\n    }\n  }\n  puVar1 = PTR_DAYS_IN_MONTH_000047e0;\n  uVar3 = param_1[5];\n  if ((uVar3 & 3) == 0) {\n    if (uVar3 == (uVar3 / 100) * 100) {\n      if ((uVar3 + 0x76c) % 400 == 0) {\n        iVar5 = 0x1d;\n      }\n      else {\n        iVar5 = 0x1c;\n      }\n    }\n    else {\n      iVar5 = 0x1d;\n    }\n  }\n  else {\n    iVar5 = 0x1c;\n  }\n  if ((int)param_1[3] < 1) {\n    while ((int)param_1[3] < 1) {\n      uVar3 = param_1[4];\n      param_1[4] = uVar3 - 1;\n      if (uVar3 - 1 == 0xffffffff) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 - 1;\n        param_1[4] = 0xb;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 == (uVar3 / 100) * 100) {\n            if ((uVar4 + 0x76b) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n      iVar2 = iVar5;\n      if (param_1[4] != 1) {\n        iVar2 = *(int *)(puVar1 + param_1[4] * 4);\n      }\n      param_1[3] = iVar2 + param_1[3];\n    }\n  }\n  else {\n    while( true ) {\n      uVar3 = param_1[4];\n      iVar2 = iVar5;\n      if (uVar3 != 1) {\n        iVar2 = *(int *)(puVar1 + uVar3 * 4);\n      }\n      if ((int)param_1[3] <= iVar2) break;\n      param_1[3] = param_1[3] - iVar2;\n      param_1[4] = uVar3 + 1;\n      if (uVar3 + 1 == 0xc) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 + 1;\n        param_1[4] = 0;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 % 100 == 0) {\n            if ((uVar4 + 0x76d) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "div"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00004634",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "FUNC_00004634"
        },
        "FUN_00001d5e": {
            "renaming": {
                "FUN_00001d5e": "get_port_address_00001d5e",
                "pin": "gpio_t pin",
                "PORT_Type": "PORT_Type",
                "PORT_ADDRESS_MASK": "const uint32_t PORT_ADDRESS_MASK",
                "PORT_BASE_ADDRESS": "const uint32_t PORT_BASE_ADDRESS",
                "port_address": "uint32_t port_address"
            },
            "code": "PORT_Type * get_port_address_00001d5e(gpio_t pin)\n{\n  const uint32_t PORT_ADDRESS_MASK = 0x7000;\n  const uint32_t PORT_BASE_ADDRESS = 0x40048000;\n  uint32_t port_address = (pin & PORT_ADDRESS_MASK) | PORT_BASE_ADDRESS;\n  return (PORT_Type *)port_address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d5e",
            "calling": [
                "gpio_init",
                "gpio_init_port"
            ],
            "imported": false,
            "current_name": "get_port_address_00001d5e"
        },
        "FUN_0000191c": {
            "renaming": {
                "FUN_0000191c": "enable_oscillator_and_set_fll_factor_0000191c",
                "*DAT_00001958": "data_reg",
                "KINETIS_MCG_FLL_FACTOR_1920": "FLL_FACTOR_1920",
                "PTR_current_mode_0000195c": "current_mode_ptr"
            },
            "code": "void enable_oscillator_and_set_fll_factor_0000191c(void)\n{\n  enable_oscillator();\n  set_fll_factor(FLL_FACTOR_1920);\n  **DAT_00001958 = **DAT_00001958 & 0x3b;\n  while ((*DAT_00001958[6] & 0xc) != 0);\n  *PTR_current_mode_0000195c = 1;\n  return;\n}",
            "called": [
                "kinetis_mcg_set_fll_factor",
                "kinetis_mcg_enable_osc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000191c",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "enable_oscillator_and_set_fll_factor_0000191c"
        },
        "FUN_000050f4": {
            "renaming": {
                "FUN_000050f4": "release_time_zone_mutex_000050f4",
                "PTR___lock___tz_mutex_000050fc": "time_zone_mutex"
            },
            "code": "void release_time_zone_mutex_000050f4(void)\n{\n  __retarget_lock_release(PTR___lock___tz_mutex_000050fc);\n  return;\n}",
            "called": [
                "__retarget_lock_release"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050f4",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "release_time_zone_mutex_000050f4"
        },
        "FUN_00000c80": {
            "renaming": {
                "FUN_00000c80": "handle_memory_management_exception_00000c80",
                "PTR_s_MEM_MANAGE_HANDLER_00000c8c": "memory_management_handler"
            },
            "code": "void handle_memory_management_exception_00000c80(void)\n{\n    /* WARNING: Subroutine does not return */\n    core_panic(PANIC_MEM_MANAGE, PTR_s_MEM_MANAGE_HANDLER_00000c8c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000c80",
            "calling": [],
            "imported": false,
            "current_name": "handle_memory_management_exception_00000c80"
        },
        "FUN_00000a40": {
            "renaming": {
                "FUN_00000a40": "calculateStackOffset_00000a40",
                "required": "requiredOffset",
                "auStack_18": "stackFrame",
                "sp": "stackPointer"
            },
            "code": "int calculateStackOffset_00000a40(uint32_t required) {\n\tundefined stackFrame[12];\n\tuint32_t *stackPointer;\n\tstackPointer = &stackFrame[0];\n\treturn (int)(stackPointer + (-(int)PTR_isr_stack_00000a60 - required));\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a40",
            "calling": [
                "hard_fault_handler"
            ],
            "imported": false,
            "current_name": "calculateStackOffset_00000a40"
        },
        "FUN_00005a58": {
            "renaming": {
                "FUN_00005a58": "encode_data_00005a58",
                "param_1": "data",
                "param_2": "buffer",
                "param_3": "buffer_size",
                "param_4": "param_4",
                "param_5": "encode_function",
                "iVar1": "i",
                "uVar2": "result",
                "uVar3": "max_buffer_size",
                "uVar4": "buffer_offset",
                "bVar5": "is_buffer_offset_4"
            },
            "code": "undefined4 encode_data_00005a58(undefined4 data, uint *buffer, uint *buffer_size, undefined4 param_4, code *encode_function)\n{\n    int i;\n    undefined4 result;\n    uint max_buffer_size = buffer[4];\n    if ((int)buffer[4] < (int)buffer[2]) {\n        max_buffer_size = buffer[2];\n    }\n    *buffer_size = max_buffer_size;\n    if (*(char *)((int)buffer + 0x43) != '\\0') {\n        *buffer_size = max_buffer_size + 1;\n    }\n    if ((int)(*buffer << 0x1a) < 0) {\n        *buffer_size = *buffer_size + 2;\n    }\n    uint buffer_offset = *buffer & 6;\n    if (buffer_offset == 0) {\n        for (; (int)buffer_offset < (int)(buffer[3] - *buffer_size); buffer_offset = buffer_offset + 1) {\n            i = (*encode_function)(data, param_4, (int)buffer + 0x19, 1);\n            if (i == -1) goto LAB_00005afc;\n        }\n    }\n    buffer_offset = (uint)*(byte *)((int)buffer + 0x43);\n    if (buffer_offset != 0) {\n        buffer_offset = 1;\n    }\n    if ((int)(*buffer << 0x1a) < 0) {\n        *(undefined *)((int)buffer + buffer_offset + 0x43) = 0x30;\n        *(undefined *)((int)buffer + buffer_offset + 0x44) = *(undefined *)((int)buffer + 0x45);\n        buffer_offset = buffer_offset + 2;\n    }\n    i = (*encode_function)(data, param_4, (int)buffer + 0x43, buffer_offset);\n    if (i == -1) {\n        result = 0xffffffff;\n    }\n    else {\n        uint remaining_buffer_size = buffer[3];\n        bool is_buffer_offset_4 = (*buffer & 6) == 4;\n        if (is_buffer_offset_4) {\n            remaining_buffer_size = remaining_buffer_size - *buffer_size;\n        }\n        if (is_buffer_offset_4) {\n            remaining_buffer_size = remaining_buffer_size & ~((int)remaining_buffer_size >> 0x1f);\n        }\n        else {\n            remaining_buffer_size = 0;\n        }\n        if ((int)buffer[4] < (int)buffer[2]) {\n            remaining_buffer_size = remaining_buffer_size + (buffer[2] - buffer[4]);\n        }\n        for (uint j = 0; remaining_buffer_size != j; j = j + 1) {\n            i = (*encode_function)(data, param_4, (int)buffer + 0x1a, 1);\n            if (i == -1) goto LAB_00005afc;\n        }\n        result = 0;\n    }\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005a58",
            "calling": [
                "_printf_i"
            ],
            "imported": false,
            "current_name": "encode_data_00005a58"
        },
        "FUN_000056b0": {
            "renaming": {
                "FUN_000056b0": "getTimeZoneInfo_000056b0",
                "PTR_tzinfo_000056b4": "timeZoneInfoPtr"
            },
            "code": "const char* getTimeZoneInfo_000056b0(void)\n{\n  return PTR_tzinfo_000056b4;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b0",
            "calling": [
                "mktime",
                "__tzcalc_limits",
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "getTimeZoneInfo_000056b0"
        },
        "FUN_00003d24": {
            "renaming": {
                "FUN_00003d24": "get_saul_reg_at_position_00003d24",
                "pos": "position",
                "tmp": "current_saul_reg",
                "i": "current_position"
            },
            "code": "saul_reg_t * get_saul_reg_at_position_00003d24(int position) {\n  int current_position = 0;\n  saul_reg_t *current_saul_reg = *(saul_reg_t **)PTR_saul_reg_00003d60;\n  \n  while (current_position < position && current_saul_reg != (saul_reg_t *)0x0) {\n    current_saul_reg = current_saul_reg->next;\n    current_position++;\n  }\n  \n  return current_saul_reg;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d24",
            "calling": [
                "read",
                "write"
            ],
            "imported": false,
            "current_name": "get_saul_reg_at_position_00003d24"
        },
        "FUN_000060cc": {
            "renaming": {
                "FUN_000060cc": "allocate_memory_000060cc",
                "param_1": "size",
                "param_2": "old_memory",
                "param_3": "new_memory",
                "param_4": "alignment",
                "pvVar1": "new_mem_ptr",
                "pvVar2": "old_mem_ptr"
            },
            "code": "void * allocate_memory_000060cc(unsigned int size, void *old_memory, void *new_memory, unsigned int alignment) {\n    void *new_mem_ptr;\n    void *old_mem_ptr;\n\n    if (old_memory != NULL) {\n        if (new_memory == NULL) {\n            free(old_memory);\n            new_mem_ptr = new_memory;\n        }\n        else {\n            old_mem_ptr = (void *)malloc_usable_size(old_memory);\n            new_mem_ptr = old_memory;\n            if ((old_mem_ptr < new_memory) && (new_mem_ptr = (void *)malloc(size), new_mem_ptr != NULL)) {\n                memcpy(new_mem_ptr, old_memory, (size_t)new_memory);\n                free(old_memory);\n            }\n        }\n        return new_mem_ptr;\n    }\n    new_mem_ptr = (void *)malloc(size);\n    return new_mem_ptr;\n}",
            "called": [
                "_free_r",
                "_malloc_r",
                "memcpy",
                "_malloc_usable_size_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060cc",
            "calling": [
                "__submore"
            ],
            "imported": false,
            "current_name": "allocate_memory_000060cc"
        },
        "FUN_000022be": {
            "renaming": {
                "FUN_000022be": "write_to_ring_buffer_000022be",
                "rb": "ring_buffer",
                "c": "character",
                "uVar1": "current_writes",
                "writes": "next_writes",
                "size": "buffer_size",
                "buf": "ring_buffer->buf"
            },
            "code": "void write_to_ring_buffer_000022be(tsrb_t *ring_buffer, char character){\n                      uint32_t current_writes = ring_buffer->writes;\n                      uint32_t next_writes = current_writes + 1;\n                      ring_buffer->writes = next_writes;\n                      uint32_t buffer_size = ring_buffer->size;\n                      uint32_t index = next_writes & buffer_size - 1;\n                      ring_buffer->buf[index] = character;\n                    }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022be",
            "calling": [
                "tsrb_add_one"
            ],
            "imported": false,
            "current_name": "write_to_ring_buffer_000022be"
        },
        "FUN_00003dc4": {
            "renaming": {
                "FUN_00003dc4": "get_num_digits_00003dc4",
                "out": "output",
                "val": "value",
                "local_20": "remainder",
                "ptr": "digit_ptr",
                "tmp": "base",
                "len": "num_digits"
            },
            "code": "size_t get_num_digits_00003dc4(char *output, uint32_t value) {\n  uint32_t base = 10;\n  char *digit_ptr;\n  uint32_t remainder;\n  size_t num_digits = 1;\n  if (DAT_00003e50 < value) {\n    num_digits = 10;\n  }\n  else {\n    while (base <= value) {\n      num_digits++;\n      base *= 10;\n    }\n  }\n  if (output != (char *)0x0) {\n    digit_ptr = output + num_digits;\n    remainder = value;\n    do {\n      digit_ptr--;\n      *digit_ptr = (char)remainder + (char)(uint)((ulonglong)DAT_00003e54 * (ulonglong)remainder >> 0x23) * -10 + '0';\n      remainder = (uint32_t)((ulonglong)DAT_00003e54 * (ulonglong)remainder >> 0x23);\n    } while (remainder != 0);\n  }\n  return num_digits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003dc4",
            "calling": [
                "fmt_s32_dec"
            ],
            "imported": false,
            "current_name": "get_num_digits_00003dc4"
        },
        "FUN_00002108": {
            "renaming": {
                "FUN_00002108": "handle_interrupt_00002108",
                "DAT_00002118": "interrupt_data"
            },
            "code": "void handle_interrupt_00002108(void)\n{\n  irq_handler(DAT_00002118, 4);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002108",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_00002108"
        },
        "FUN_00000c90": {
            "renaming": {
                "FUN_00000c90": "handle_bus_fault_00000c90",
                "PTR_s_BUS_FAULT_HANDLER_00000c9c": "bus_fault_handler"
            },
            "code": "void handle_bus_fault_00000c90(void)\n{\n    core_panic(PANIC_BUS_FAULT, PTR_s_BUS_FAULT_HANDLER_00000c9c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000c90",
            "calling": [],
            "imported": false,
            "current_name": "handle_bus_fault_00000c90"
        },
        "FUN_00001d80": {
            "renaming": {
                "FUN_00001d80": "get_GPIO_address_from_pin_00001d80",
                "pin": "pin_number",
                "GPIO_Type": "GPIO_struct",
                "GPIO_BASE_ADDRESS": "GPIO_BASE_ADDR",
                "PIN_OFFSET_MASK": "PIN_OFFSET_MASK",
                "pin_offset": "offset",
                "gpio_address": "GPIO_addr"
            },
            "code": "GPIO_Type* get_GPIO_address_from_pin_00001d80(get_GPIO_address_from_pin_00001d80_t pin) {\n    const uint32_t GPIO_BASE_ADDRESS = 0x400ff000;\n    const uint32_t PIN_OFFSET_MASK = 0x1c0;\n    uint32_t pin_offset = pin & PIN_OFFSET_MASK;\n    GPIO_Type* gpio_address = (GPIO_Type*)(pin_offset | GPIO_BASE_ADDRESS);\n    return gpio_address;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d80",
            "calling": [
                "gpio_set",
                "gpio_init"
            ],
            "imported": false,
            "current_name": "get_GPIO_address_from_pin_00001d80"
        },
        "FUN_000033c0": {
            "renaming": {
                "FUN_000033c0": "get_alarm_status_000033c0",
                "iVar1": "alarm_status",
                "t": "current_time",
                "PTR_s_rtc__error_getting_alarm_000033f0": "PTR_s_rtc_error_getting_alarm",
                "_print_time": "print_current_time",
                "uint": "unsigned int"
            },
            "code": "int get_alarm_status_000033c0() {\n  int alarm_status;\n  tm current_time;\n  alarm_status = rtc_get_alarm(&current_time);\n  if (alarm_status != 0) {\n    puts(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else {\n    print_current_time(&current_time);\n  }\n  return (uint)(alarm_status != 0);\n}",
            "called": [
                "rtc_get_alarm",
                "_print_time",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033c0",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "get_alarm_status_000033c0"
        },
        "FUN_00002b10": {
            "renaming": {
                "FUN_00002b10": "parse_shell_command_00002b10",
                "command_list": "command_list",
                "line": "command_line",
                "iVar1": "i",
                "pcVar2": "current_char",
                "local_48": "arg_start",
                "local_44": "current_command",
                "handler": "handler",
                "argv": "args",
                "local_34": "arg_count",
                "quote_char": "quote_char",
                "d": "d",
                "c": "c",
                "arg": "arg",
                "i": "j",
                "contains_esc_seq": "contains_esc_seq",
                "argc": "arg_count",
                "pos": "pos"
            },
            "code": "void parse_shell_command_00002b10(shell_command_t *command_list, char *command_line) {\\n    int i;\\n    char *current_char;\\n    char *arg_start;\\n    shell_command_t *current_command;\\n    shell_command_handler_t handler;\\n    char **args;\\n    uint arg_count;\\n    int contains_esc_seq;\\n    char quote_char;\\n    char *d;\\n    char *c;\\n    char **arg;\\n    uint j;\\n    char *pos;\\n\\n    current_command = command_list;\\n    current_char = command_line;\\n    arg_count = 0;\\n    contains_esc_seq = 0;\\n    pos = command_line;\\n    while (true) {\\n        if (0x20 < (byte)*pos) {\\n            if ((*pos == \"\\\"\") || (*pos == \"\\\"\")) {\\n                quote_char = *pos;\\n                do {\\n                    current_char = pos + 1;\\n                    if (*current_char == \"\\0\") {\\n                        pos = current_char;\\n                        puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\\n                        return;\\n                    }\\n                    if (*current_char == \"\\\\\") {\\n                        contains_esc_seq = contains_esc_seq + 1;\\n                        pos = current_char + 1;\\n                        current_char = pos;\\n                        if (*pos == \"\\0\") {\\n                            puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\\n                            return;\\n                        }\\n                    }\\n                    pos = current_char;\\n                } while (quote_char != *pos);\\n                if (0x20 < (byte)pos[1]) {\\n                    puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\\n                    return;\\n                }\\n            }\\n            else {\\n                do {\\n                    if (*pos == \"\\\\\") {\\n                        contains_esc_seq = contains_esc_seq + 1;\\n                        pos = pos + 1;\\n                        if (*pos == \"\\0\") {\\n                            puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\\n                            return;\\n                        }\\n                    }\\n                    pos = pos + 1;\\n                    if (*pos == 0x22) {\\n                        puts(*(char **)PTR_INCORRECT_QUOTING_00002d88);\\n                        return;\\n                    }\\n                } while (0x20 < (byte)*pos);\\n            }\\n            arg_count = arg_count + 1;\\n        }\\n        if (*pos == \"\\0\") break;\\n        *pos = \"\\0\";\\n        pos = pos + 1;\\n    }\\n    if (arg_count != 0) {\\n        arg_count = arg_count;\\n        args = (char **)(&command_line - ((arg_count + 1) * 4 + 7 & 0xfffffff8));\\n        *(char **)((int)args + arg_count * 4) = (char *)0x0;\\n        pos = command_line;\\n        for (j = 0; j < arg_count; j = j + 1) {\\n            for (; *pos == \"\\0\"; pos = pos + 1) {\\n            }\\n            if ((*pos == \"\\\"\") || (*pos == \"\\\"\")) {\\n                pos = pos + 1;\\n            }\\n            *(char **)((int)args + j * 4) = pos;\\n            for (; *pos != \"\\0\"; pos = pos + 1) {\\n            }\\n        }\\n        for (arg = args; (contains_esc_seq != 0 && (*arg != (char *)0x0)); arg = arg + 1) {\\n            for (c = *arg; *c != \"\\0\"; c = c + 1) {\\n                if (*c == \"\\\\\") {\\n                    for (d = c; *d != \"\\0\"; d = d + 1) {\\n                        *d = d[1];\\n                    }\\n                    contains_esc_seq = contains_esc_seq + -1;\\n                    if (contains_esc_seq == 0) break;\\n                }\\n            }\\n        }\\n        handler = find_command_handler(command_list, *(char **)args);\\n        if (handler == (shell_command_handler_t)0x0) {\\n            i = strcmp(PTR_COMMAND_NOT_FOUND_00002d8c, *(char **)args);\\n            if (i == 0) {\\n                print_help(current_command);\\n            }\\n            else {\\n                iprintf(PTR_COMMAND_NOT_FOUND_00002d90, *(undefined4 *)args);\\n            }\\n        }\\n        else {\\n            (*handler)(arg_count, args);\\n        }\\n    }\\n    return;\\n}",
            "called": [
                "iprintf",
                "find_handler",
                "print_help",
                "strcmp",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002b10",
            "calling": [
                "shell_run"
            ],
            "imported": false,
            "current_name": "parse_shell_command_00002b10"
        },
        "FUN_00001b10": {
            "renaming": {
                "FUN_00001b10": "set_mcg_mode_00001b10",
                "mode": "mcg_mode",
                "PTR_mcg_mode_routing_00001bb4": "mcg_mode_routing",
                "PTR_current_mode_00001bb0": "current_mode",
                "iVar1": "result"
            },
            "code": "int set_mcg_mode_00001b10(kinetis_mcg_mode_t mode) {\n  int result = -1;\n  if (mode < KINETIS_MCG_MODE_NUMOF) {\n    do {\n      uint32_t mode_index = (uint32_t)mode + (uint32_t)(*PTR_current_mode_00001bb0) * 8;\n      switch(PTR_mcg_mode_routing_00001bb4[mode_index])\n      {\n      case 0:\n        kinetis_mcg_set_fei();\n        break;\n      case 1:\n        kinetis_mcg_set_fee();\n        break;\n      case 2:\n        kinetis_mcg_set_fbi();\n        break;\n      case 3:\n        kinetis_mcg_set_fbe();\n        break;\n      case 4:\n        kinetis_mcg_set_blpi();\n        break;\n      case 5:\n        kinetis_mcg_set_blpe();\n        break;\n      case 6:\n        kinetis_mcg_set_pbe();\n        break;\n      case 7:\n        kinetis_mcg_set_pee();\n        break;\n      default:\n        return -1;\n      }\n    } while (mode != *PTR_current_mode_00001bb0);\n    result = 0;\n  }\n  return result;\n}",
            "called": [
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_pee",
                "kinetis_mcg_set_blpe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_blpi"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001b10",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "set_mcg_mode_00001b10"
        },
        "FUN_000047e4": {
            "renaming": {
                "FUN_000047e4": "FUNC_000047e4"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\ntime_t FUNC_000047e4(tm *__tp)\n\n{\n  longlong lVar1;\n  int *piVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  int iVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  uint uVar14;\n  time_t tVar15;\n  bool bVar16;\n  \n  piVar2 = (int *)__gettzinfo();\n  validate_structure(__tp);\n  uVar11 = __tp->tm_year;\n  iVar10 = __tp->tm_mday + -1 + *(int *)(PTR__DAYS_BEFORE_MONTH_00004adc + __tp->tm_mon * 4);\n  if (((1 < __tp->tm_mon) && ((uVar11 & 3) == 0)) &&\n     ((uVar11 != (uVar11 / 100) * 100 || (uVar11 + 0x76c == ((uVar11 + 0x76c) / 400) * 400)))) {\n    iVar10 = iVar10 + 1;\n  }\n  __tp->tm_yday = iVar10;\n  if (20000 < (int)&PTR_rtc_callback_00002710 + uVar11) {\n    return -1;\n  }\n  if ((int)uVar11 < 0x47) {\n    if (uVar11 != 0x46) {\n      for (uVar8 = 0x45; (int)uVar11 < (int)uVar8; uVar8 = uVar8 - 1) {\n        if ((uVar8 & 3) == 0) {\n          if (uVar8 == (uVar8 / 100) * 100) {\n            if ((uVar8 + 0x76c) % 400 == 0) {\n              iVar6 = 0x16e;\n            }\n            else {\n              iVar6 = 0x16d;\n            }\n          }\n          else {\n            iVar6 = 0x16e;\n          }\n        }\n        else {\n          iVar6 = 0x16d;\n        }\n        iVar10 = iVar10 - iVar6;\n      }\n      if ((uVar8 & 3) == 0) {\n        if (uVar11 == (uVar11 / 100) * 100) {\n          iVar6 = 0x16d;\n          if ((uVar11 + 0x76c) % 400 == 0) {\n            iVar6 = 0x16e;\n          }\n        }\n        else {\n          iVar6 = 0x16e;\n        }\n      }\n      else {\n        iVar6 = 0x16d;\n      }\n      iVar10 = iVar10 - iVar6;\n    }\n  }\n  else {\n    uVar8 = 0x46;\n    do {\n      if ((uVar8 & 3) == 0) {\n        if (uVar8 % 100 == 0) {\n          if ((uVar8 + 0x76c) % 400 == 0) {\n            iVar6 = 0x16e;\n          }\n          else {\n            iVar6 = 0x16d;\n          }\n        }\n        else {\n          iVar6 = 0x16e;\n        }\n      }\n      else {\n        iVar6 = 0x16d;\n      }\n      uVar8 = uVar8 + 1;\n      iVar10 = iVar10 + iVar6;\n    } while (uVar11 != uVar8);\n  }\n  lVar1 = (longlong)DAT_00004ae0 * (longlong)iVar10 +\n          (longlong)(__tp->tm_hour * 0xe10 + __tp->tm_min * 0x3c + __tp->tm_sec);\n  uVar14 = (uint)lVar1;\n  iVar6 = (int)((ulonglong)lVar1 >> 0x20);\n  __tz_lock();\n  _tzset_unlocked();\n  uVar8 = *(uint *)PTR__daylight_00004ae4;\n  if (*(uint *)PTR__daylight_00004ae4 == 0) {\nLAB_00004934:\n    tVar15 = uVar14 + piVar2[10];\n  }\n  else {\n    uVar13 = __tp->tm_isdst;\n    uVar12 = uVar13;\n    if (0 < (int)uVar13) {\n      uVar12 = 1;\n    }\n    if ((piVar2[1] == __tp->tm_year + 0x76c) || (iVar4 = __tzcalc_limits(), iVar4 != 0)) {\n      uVar9 = piVar2[0x14];\n      uVar3 = piVar2[0x12];\n      uVar7 = piVar2[10];\n      uVar8 = uVar3 - uVar7;\n      iVar4 = (piVar2[0x13] - ((int)uVar7 >> 0x1f)) - (uint)(uVar3 < uVar7);\n      if (((int)((iVar6 - iVar4) - (uint)(uVar14 < uVar8)) < 0 ==\n           (SBORROW4(iVar6,iVar4) != SBORROW4(iVar6 - iVar4,(uint)(uVar14 < uVar8)))) &&\n         (iVar5 = (piVar2[0x13] - ((int)uVar9 >> 0x1f)) - (uint)(uVar3 < uVar9),\n         bVar16 = uVar14 < uVar3 - uVar9,\n         (int)((iVar6 - iVar5) - (uint)bVar16) < 0 !=\n         (SBORROW4(iVar6,iVar5) != SBORROW4(iVar6 - iVar5,(uint)bVar16)))) goto LAB_00004a88;\n      uVar3 = piVar2[8] - uVar9;\n      iVar5 = (piVar2[9] - ((int)uVar9 >> 0x1f)) - (uint)((uint)piVar2[8] < uVar9);\n      if (*piVar2 != 0) {\n        if ((int)((iVar6 - iVar5) - (uint)(uVar14 < uVar3)) < 0 ==\n            (SBORROW4(iVar6,iVar5) != SBORROW4(iVar6 - iVar5,(uint)(uVar14 < uVar3))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        uVar8 = 0;\n        if ((int)uVar13 < 0) goto LAB_00004934;\nLAB_00004a14:\n        uVar13 = uVar12 ^ uVar8;\n        uVar12 = uVar8;\n        if (uVar13 == 1) {\n          if (uVar8 == 0) {\n            iVar6 = uVar9 - uVar7;\n          }\n          else {\n            iVar6 = uVar7 - uVar9;\n          }\n          iVar4 = __tp->tm_mday;\n          uVar14 = uVar14 + iVar6;\n          __tp->tm_sec = __tp->tm_sec + iVar6;\n          validate_structure(__tp);\n          iVar4 = __tp->tm_mday - iVar4;\n          if (iVar4 != 0) {\n            if (iVar4 < 2) {\n              if (iVar4 == -2 || iVar4 + 2 < 0 != SCARRY4(iVar4,2)) {\n                iVar4 = 1;\n              }\n            }\n            else {\n              iVar4 = -1;\n            }\n            iVar6 = iVar4 + __tp->tm_yday;\n            iVar10 = iVar10 + iVar4;\n            if (iVar6 < 0) {\n              uVar8 = uVar11 - 1;\n              if ((uVar8 & 3) == 0) {\n                if (uVar8 == (uVar8 / 100) * 100) {\n                  iVar6 = 0x16d;\n                  if ((uVar11 + 0x76b) % 400 != 0) {\n                    iVar6 = 0x16c;\n                  }\n                }\n                else {\n                  iVar6 = 0x16d;\n                }\n              }\n              else {\n                iVar6 = 0x16c;\n              }\n            }\n            else {\n              if ((uVar11 & 3) == 0) {\n                if (uVar11 == (uVar11 / 100) * 100) {\n                  iVar4 = 0x16d;\n                  if ((uVar11 + 0x76c) % 400 == 0) {\n                    iVar4 = 0x16e;\n                  }\n                }\n                else {\n                  iVar4 = 0x16e;\n                }\n              }\n              else {\n                iVar4 = 0x16d;\n              }\n              if (iVar4 <= iVar6) {\n                iVar6 = iVar6 - iVar4;\n              }\n            }\n            __tp->tm_yday = iVar6;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((iVar6 - iVar5) - (uint)(uVar14 < uVar3)) < 0 !=\n          (SBORROW4(iVar6,iVar5) != SBORROW4(iVar6 - iVar5,(uint)(uVar14 < uVar3)))) {\nLAB_0000491e:\n        if ((int)((iVar6 - iVar4) - (uint)(uVar14 < uVar8)) < 0 ==\n            (SBORROW4(iVar6,iVar4) != SBORROW4(iVar6 - iVar4,(uint)(uVar14 < uVar8))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)uVar13) {\n        uVar8 = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      uVar8 = uVar12;\n      if (uVar12 != 1) goto LAB_00004934;\n    }\n    tVar15 = uVar14 + piVar2[0x14];\n    uVar8 = 1;\n  }\n  __tz_unlock();\n  __tp->tm_isdst = uVar8;\n  __tp->tm_wday = (iVar10 + 4U) % 7;\n  return tVar15;\n}\n\n",
            "called": [
                "__gettzinfo",
                "__tz_unlock",
                "__tzcalc_limits",
                "validate_structure",
                "__tz_lock",
                "_tzset_unlocked"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000047e4",
            "calling": [
                "rtc_set_time",
                "rtc_set_alarm"
            ],
            "imported": false,
            "current_name": "FUNC_000047e4"
        },
        "FUN_000023c8": {
            "renaming": {
                "FUN_000023c8": "perform_software_interrupt_000023c8",
                "a0": "interrupt_number",
                "a1": "parameter1",
                "a2": "parameter2"
            },
            "code": "uint32_t perform_software_interrupt_000023c8(uint32_t interrupt_number, uint32_t parameter1, int32_t parameter2)\n{\n  software_interrupt(interrupt_number);\n  return parameter1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023c8",
            "calling": [
                "startForkserver"
            ],
            "imported": false,
            "current_name": "perform_software_interrupt_000023c8"
        },
        "FUN_00002e48": {
            "renaming": {
                "FUN_00002e48": "print_greater_than_space_00002e48",
                "PTR__impure_ptr_00002e68": "impure_ptr",
                "*(int *)PTR__impure_ptr_00002e68 + 8": "impure_ptr + 8",
                "FILE": "file_ptr",
                "_putchar": "_putchar",
                "0x3e": "greater_than",
                "0x20": "space"
            },
            "code": "void print_greater_than_space_00002e48(void)\n{\n    int* PTR__impure_ptr_00002e68 = *(int**)PTR__PTR__impure_ptr_00002e68_00002e68;\n    FILE* file_ptr = *(FILE**)(*(int *)PTR__PTR__impure_ptr_00002e68_00002e68 + 8);\n    int greater_than = 62;\n    int space = 32;\n    _putchar(greater_than);\n    _putchar(space);\n    fflush(file_ptr);\n    return;\n}",
            "called": [
                "_putchar",
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e48",
            "calling": [
                "shell_run"
            ],
            "imported": false,
            "current_name": "print_greater_than_space_00002e48"
        },
        "FUN_00000930": {
            "renaming": {
                "FUN_00000930": "enable_interrupt_and_trigger_software_interrupt_00000930",
                "irq_enable": "enable_interrupt",
                "software_interrupt": "trigger_software_interrupt",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void enable_interrupt_and_trigger_software_interrupt_00000930(void)\n{\n  enable_interrupt();\n  trigger_software_interrupt(1);\n  while(true)\n  {\n    // Do nothing block with infinite loop\n  }\n}",
            "called": [
                "irq_enable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000930",
            "calling": [
                "sched_task_exit",
                "kernel_init"
            ],
            "imported": false,
            "current_name": "enable_interrupt_and_trigger_software_interrupt_00000930"
        },
        "FUN_00001348": {
            "renaming": {
                "FUN_00001348": "check_for_context_switch_request_00001348",
                "PTR_sched_context_switch_request_0000135c": "context_switch_request"
            },
            "code": "void check_for_context_switch_request_00001348(void)\n{\n  int *PTR_sched_context_switch_request_0000135c = (int *)PTR_sched_PTR_sched_context_switch_request_0000135c_0000135c;\n  if (*PTR_sched_context_switch_request_0000135c != 0) {\n    thread_yield_higher();\n  }\n  return;\n}",
            "called": [
                "thread_yield_higher"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001348",
            "calling": [
                "irq_handler_uart"
            ],
            "imported": false,
            "current_name": "check_for_context_switch_request_00001348"
        },
        "FUN_00006118": {
            "renaming": {
                "FUN_00006118": "reverse_and_add_char_00006118",
                "param_1": "previous_char",
                "param_2": "current_char",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "iVar1": "index",
                "uVar2": "added_char",
                "uVar3": "buffer_start",
                "short_buffer": "short_buffer",
                "PTR_DAT_00006120": "LAB_00006120"
            },
            "code": "uint reverse_and_add_char_00006118(uint previous_char, uint current_char, uint *buffer, uint buffer_size)\n{\n  int index = 0;\n  uint added_char = current_char;\n  \n  if (current_char == 0xffffffff) {\n    current_char = 0xffffffff;\n  }\n  else {\n    ushort *short_buffer = (ushort *) (buffer + 3);\n    short_buffer[1] = short_buffer[1] & 0xffdf;\n    uint buffer_start = buffer[0];\n    current_char = current_char & 0xff;\n    if (buffer[0xd] == 0) {\n      uint buffer_end = buffer[4];\n      if ((buffer_end != 0) && (buffer_end < buffer_start) && (*(byte *)(buffer_start - 1) == current_char)) {\n        buffer[0xf] = buffer_start;\n        buffer[0x10] = short_buffer[1] + 1;\n        buffer[0xd] = (uint)(buffer + 0x11);\n        buffer[0xe] = 3;\n        *(undefined *)((int)buffer + 0x46) = (char)current_char;\n        buffer[0] = (uint)(undefined *)((int)buffer + 0x46);\n        added_char = 1;\n      }\n      else {\n        buffer[0xf] = buffer_start;\n        buffer[0x10] = short_buffer[1];\n        buffer[0xd] = (uint)(buffer + 0x11);\n        buffer[0xe] = 3;\n        *(undefined *)((int)buffer + 0x46) = (char)current_char;\n        buffer[0] = (uint)(undefined *)((int)buffer + 0x46);\n        added_char = 1;\n      }\n    }\n    else {\n      if ((int)buffer[0xe] <= (int)short_buffer[1]) {\n        index = __submore(previous_char, buffer, short_buffer[1], buffer[0xe], buffer_size);\n        if (index != 0) {\n          current_char = 0xffffffff;\n        }\n        else {\n          buffer_start = buffer[0];\n          added_char = current_char;\n        }\n      }\n      buffer_start = buffer[0];\n      buffer[0] = buffer_start - 1;\n      *(char *)(buffer_start - 1) = (char)current_char;\n      added_char = short_buffer[1] + 1;\n    }\n    short_buffer[1] = added_char;\n  }\n  return current_char;\n}",
            "called": [
                "__submore"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006118",
            "calling": [],
            "imported": false,
            "current_name": "reverse_and_add_char_00006118"
        },
        "FUN_00001d3a": {
            "renaming": {
                "FUN_00001d3a": "set_bit_to_1_00001d3a",
                "ptr": "memory_address",
                "bit": "bit_position",
                "puVar1": "bit_address"
            },
            "code": "void set_bit_to_1_00001d3a(uint32_t *memory_address, uint8_t bit_position)\n{\n  undefined4 *bit_address = (undefined4 *)bitband_addr(memory_address, (uint)bit_position);\n  *bit_address = 1;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d3a",
            "calling": [
                "clk_en"
            ],
            "imported": false,
            "current_name": "set_bit_to_1_00001d3a"
        },
        "FUN_00002434": {
            "renaming": {
                "FUN_00002434": "acquire_mutex_00002434",
                "mutex": "mutex",
                "blocking": "is_blocking",
                "state": "flags",
                "iVar1": "success",
                "process": "current_thread",
                "irqstate": "flags",
                "me": "current_thread"
            },
            "code": "int acquire_mutex_00002434(mutex_t *mutex, int is_blocking) {\n  uint32_t flags;\n  int success;\n  thread_t *current_thread;\n  thread_t *waiting_thread;\n  \n  flags = disable_interrupts();\n  if (mutex->queue.next == NULL) {\n    mutex->queue.next = (list_node *)-1;\n    restore_interrupts(flags);\n    success = 1;\n  }\n  else if (is_blocking == 0) {\n    restore_interrupts(flags);\n    success = 0;\n  }\n  else {\n    current_thread = *(thread_t **)PTR_sched_active_thread_000024b8;\n    set_thread_status(current_thread, THREAD_STATUS_BLOCKED);\n    if (mutex->queue.next == (list_node *)-1) {\n      mutex->queue.next = &current_thread->rq_entry;\n      mutex->queue.next->next = NULL;\n    }\n    else {\n      add_thread_to_list(&mutex->queue, current_thread);\n    }\n    restore_interrupts(flags);\n    yield_to_higher_priority_thread();\n    success = 1;\n  }\n  return success;\n}\n",
            "called": [
                "thread_yield_higher",
                "thread_add_to_list",
                "irq_disable",
                "irq_restore",
                "sched_set_status"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002434",
            "calling": [
                "mutex_lock"
            ],
            "imported": false,
            "current_name": "acquire_mutex_00002434"
        },
        "FUN_00005700": {
            "renaming": {
                "FUN_00005700": "initialize_buffer_00005700",
                "param_1": "reent",
                "param_2": "buffer_ptr",
                "uVar1": "whatbuf_result",
                "iVar2": "malloc_result",
                "local_18": "local_reent",
                "local_14": "local_buffer_ptr"
            },
            "code": "void initialize_buffer_00005700(_reent *reent, int *buffer_ptr) {\n  ushort whatbuf_result;\n  int malloc_result;\n  _reent *local_reent;\n  int *local_buffer_ptr;\n\n  if ((uint)*(ushort *)(buffer_ptr + 3) << 0x1e > 0) {\n    local_reent = reent;\n    local_buffer_ptr = buffer_ptr;\n    whatbuf_result = __swhatbuf_r(reent, buffer_ptr, &local_reent, &local_buffer_ptr);\n    malloc_result = _malloc_r(reent, local_reent);\n    if (malloc_result != 0) {\n      reent->__cleanup = cleanup_handler;\n      *buffer_ptr = malloc_result;\n      *(ushort *)(buffer_ptr + 3) = *(ushort *)(buffer_ptr + 3) | 0x80;\n      buffer_ptr[5] = (int)local_reent;\n      buffer_ptr[4] = malloc_result;\n      if ((local_buffer_ptr != (int *)0x0) && (_isatty_r(reent, (int)*(short *)((int)buffer_ptr + 0xe)) != 0)) {\n        *(ushort *)(buffer_ptr + 3) = *(ushort *)(buffer_ptr + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(buffer_ptr + 3) = whatbuf_result | *(ushort *)(buffer_ptr + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(buffer_ptr + 3) << 0x16 >= 0) {\n      *(ushort *)(buffer_ptr + 3) = *(ushort *)(buffer_ptr + 3) & 0xfffc | 2;\n    }\n    return;\n  }\n  *buffer_ptr = (int)buffer_ptr + 0x47;\n  buffer_ptr[4] = (int)buffer_ptr + 0x47;\n  buffer_ptr[5] = 1;\n  return;\n}\n",
            "called": [
                "__swhatbuf_r",
                "_malloc_r",
                "_isatty_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005700",
            "calling": [
                "__srefill_r",
                "__swsetup_r"
            ],
            "imported": false,
            "current_name": "initialize_buffer_00005700"
        },
        "FUN_00002798": {
            "renaming": {
                "FUN_00002798": "check_for_context_switch_request_00002798",
                "PTR_sched_context_switch_request_000027ac": "sched_context_switch_request_ptr"
            },
            "code": "void check_for_context_switch_request_00002798(void)\n{\n  int* PTR_sched_context_switch_request_000027ac = (int*)PTR_sched_context_switch_request_000027ac;\n  if (*PTR_sched_context_switch_request_000027ac != 0) {\n    thread_yield_higher();\n  }\n  return;\n}",
            "called": [
                "thread_yield_higher"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002798",
            "calling": [
                "isr_rtc"
            ],
            "imported": false,
            "current_name": "check_for_context_switch_request_00002798"
        },
        "FUN_00003524": {
            "renaming": {
                "FUN_00003524": "process_rtc_command_00003524",
                "argc": "argument_count",
                "argv": "arguments",
                "iVar1": "result",
                "_rtc_usage": "print_rtc_usage",
                "PTR_s_poweron_00003638": "command_poweron",
                "rtc_poweron": "power_on_rtc",
                "PTR_s_poweroff_0000363c": "command_poweroff",
                "rtc_poweroff": "power_off_rtc",
                "PTR_s_clearalarm_00003640": "command_clearalarm",
                "rtc_clear_alarm": "clear_rtc_alarm",
                "PTR_s_getalarm_00003644": "command_getalarm",
                "_rtc_getalarm": "get_rtc_alarm",
                "PTR_s_setalarm_00003648": "command_setalarm",
                "_rtc_setalarm": "set_rtc_alarm",
                "PTR_s_gettime_0000364c": "command_gettime",
                "_rtc_gettime": "get_rtc_time",
                "PTR_s_settime_00003650": "command_settime",
                "_rtc_settime": "set_rtc_time",
                "iprintf": "print_unknown_command_or_missing_param"
            },
            "code": "int process_rtc_command_00003524(int argument_count, char **arguments) {\n  int result;\n  if (argument_count < 2) {\n    print_rtc_usage();\n    result = 1;\n  }\n  else {\n    int command_cmp_result = strncmp(arguments[1], PTR_s_poweron_00003638, 7);\n    if (command_cmp_result == 0) {\n      rtc_poweron();\n    }\n    else {\n      command_cmp_result = strncmp(arguments[1], PTR_s_poweroff_0000363c, 8);\n      if (command_cmp_result == 0) {\n        rtc_poweroff();\n      }\n      else {\n        command_cmp_result = strncmp(arguments[1], PTR_s_clearalarm_00003640, 8);\n        if (command_cmp_result == 0) {\n          rtc_clear_alarm();\n        }\n        else {\n          command_cmp_result = strncmp(arguments[1], PTR_s_getalarm_00003644, 8);\n          if (command_cmp_result == 0) {\n            get_rtc_alarm();\n          }\n          else {\n            command_cmp_result = strncmp(arguments[1], PTR_s_setalarm_00003648, 8);\n            if ((command_cmp_result == 0) && (argument_count == 4)) {\n              set_rtc_alarm(arguments + 2);\n            }\n            else {\n              command_cmp_result = strncmp(arguments[1], PTR_s_gettime_0000364c, 7);\n              if (command_cmp_result == 0) {\n                get_rtc_time();\n              }\n              else {\n                command_cmp_result = strncmp(arguments[1], PTR_s_settime_00003650, 7);\n                if ((command_cmp_result != 0) || (argument_count != 4)) {\n                  print_unknown_command_or_missing_param(arguments[1]);\n                  print_rtc_usage();\n                  return 1;\n                }\n                set_rtc_time(arguments + 2);\n              }\n            }\n          }\n        }\n      }\n    }\n    result = 0;\n  }\n  return result;\n}",
            "called": [
                "_rtc_setalarm",
                "rtc_poweroff",
                "_rtc_usage",
                "rtc_clear_alarm",
                "iprintf",
                "_rtc_settime",
                "strncmp",
                "_rtc_getalarm",
                "_rtc_gettime",
                "rtc_poweron"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003524",
            "calling": [],
            "imported": false,
            "current_name": "process_rtc_command_00003524"
        },
        "FUN_00001bb8": {
            "renaming": {
                "FUN_00001bb8": "initialize_system_00001bb8",
                "DAT_00001c74": "system_flags",
                "DAT_00001c78": "system_flags_register",
                "DAT_00001c7c": "system_flags_register",
                "PTR_current_mode_00001c80": "current_mode"
            },
            "code": "void initialize_system_00001bb8(void)\n{\n  if ((DAT_00001c74[1] & 2) != 0) {\n    clear_bit(DAT_00001c78, SYSTEM_FLAG_REGISTER_BIT_1);\n  }\n  if ((DAT_00001c74[5] & 0x40) != 0) {\n    if ((*DAT_00001c74 & 0xc0) == 0) {\n      *DAT_00001c74 = *DAT_00001c74 & 0x3f | 0x80;\n      while ((DAT_00001c74[6] & 0xc) != 8);\n    }\n    clear_bit(DAT_00001c78, SYSTEM_FLAG_REGISTER_BIT_6);\n    while ((DAT_00001c74[6] & 0x20) != 0);\n  }\n  set_fll_factor(KINETIS_MCG_FLL_FACTOR_640);\n  *DAT_00001c74 = *DAT_00001c74 & 0x3b | 4;\n  while ((DAT_00001c74[6] & 0x10) == 0);\n  while ((DAT_00001c74[6] & 0xc) != 0);\n  *PTR_current_mode_00001c80 = SYSTEM_MODE_IDLE;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001bb8",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "initialize_system_00001bb8"
        },
        "FUN_0000428c": {
            "renaming": {
                "FUN_0000428c": "acquireRecursiveLock_0000428c",
                "PTR___lock___sinit_recursive_mutex_00004294": "lock"
            },
            "code": "void acquireRecursiveLock_0000428c(void)\n{\n  __retarget_PTR___lock___sinit_recursive_mutex_00004294_acquire_recursive(PTR___lock___sinit_recursive_mutex_00004294);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000428c",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "acquireRecursiveLock_0000428c"
        },
        "FUN_0000404c": {
            "renaming": {
                "FUN_0000404c": "decode_0000404c",
                "param_1": "input_buffer",
                "param_2": "decode_params",
                "iVar1": "bytes_read",
                "piVar2": "ptr_decode_params",
                "uVar3": "num_bytes_to_read",
                "uVar4": "uVar1",
                "iVar5": "bytes_to_read",
                "pcVar6": "func_ptr",
                "iVar7": "num_bytes_remaining",
                "uVar8": "orig_input_buffer",
                "bVar9": "is_bytes_to_read_zero"
            },
            "code": "int decode_0000404c(uint *input_buffer, int *decode_0000404c_params)\n{\n  int bytes_read = 0;\n  int *ptr_decode_0000404c_params = decode_0000404c_params;\n  uint uVar1 = *(ushort *)(ptr_decode_0000404c_params + 3);\n  uint num_bytes_to_read = (uint)uVar1;\n  if ((int)(num_bytes_to_read << 0x1c) < 0) {\n    int num_bytes_remaining = ptr_decode_0000404c_params[4];\n    if (num_bytes_remaining != 0) {\n      int bytes_to_read = num_bytes_to_read << 0x1e;\n      bool is_bytes_to_read_zero = bytes_to_read == 0;\n      int bytes_read_per_iteration = *ptr_decode_0000404c_params;\n      if (is_bytes_to_read_zero) {\n        bytes_to_read = ptr_decode_0000404c_params[5];\n      }\n      *ptr_decode_0000404c_params = num_bytes_remaining;\n      if (!is_bytes_to_read_zero) {\n        bytes_to_read = 0;\n      }\n      ptr_decode_0000404c_params[2] = bytes_to_read;\n      for (num_bytes_remaining = num_bytes_remaining - num_bytes_to_read; 0 < num_bytes_remaining; num_bytes_remaining = num_bytes_remaining - bytes_to_read) {\n        bytes_to_read = (*(code *)ptr_decode_0000404c_params[10])(input_buffer,ptr_decode_0000404c_params[8],num_bytes_remaining,bytes_read);\n        if (bytes_to_read < 1) {\n          *(ushort *)(ptr_decode_0000404c_params + 3) = *(ushort *)(ptr_decode_0000404c_params + 3) | 0x40;\n          return -1;\n        }\n        bytes_read = bytes_read + bytes_to_read;\n      }\n    }\n  }\n  else {\n    if ((ptr_decode_0000404c_params[1] < 1) && (ptr_decode_0000404c_params[0x10] < 1)) {\n      return 0;\n    }\n    code *func_ptr = (code *)ptr_decode_0000404c_params[0xb];\n    if (func_ptr == (code *)0x0) {\n      return 0;\n    }\n    uint orig_input_buffer = *input_buffer;\n    *input_buffer = 0;\n    if ((uVar1 & 0x1000) == 0) {\n      int bytes_to_read = (*func_ptr)(input_buffer,ptr_decode_0000404c_params[8],num_bytes_to_read & 0x1000,1);\n      if ((bytes_to_read == -1) && (*input_buffer != 0)) {\n        if ((*input_buffer == 0x1d) || (*input_buffer == 0x16)) {\n          *input_buffer = orig_input_buffer;\n          return 0;\n        }\n        uint uVar2 = *(ushort *)(ptr_decode_0000404c_params + 3);\n        *(ushort *)(ptr_decode_0000404c_params + 3) = uVar2 | 0x40;\n        return bytes_to_read;\n      }\n    }\n    else {\n      int bytes_to_read = ptr_decode_0000404c_params[0x15];\n    }\n    if (((int)((uint)*(ushort *)(ptr_decode_0000404c_params + 3) << 0x1d) < 0) && (bytes_to_read = bytes_to_read - ptr_decode_0000404c_params[1], ptr_decode_0000404c_params[0xd] != 0)) {\n      bytes_to_read = bytes_to_read - ptr_decode_0000404c_params[0x10];\n    }\n    bytes_read = (*(code *)ptr_decode_0000404c_params[0xb])(input_buffer,ptr_decode_0000404c_params[8],bytes_to_read,0);\n    uVar1 = *(ushort *)(ptr_decode_0000404c_params + 3);\n    if ((bytes_read == -1) && ((0x1d < *input_buffer || (-1 < (int)((DAT_00004154 >> (*input_buffer & 0xff)) << 0x1f)))) {\n      *(ushort *)(ptr_decode_0000404c_params + 3) = uVar1 | 0x40;\n      return bytes_read;\n    }\n    ptr_decode_0000404c_params[1] = 0;\n    *ptr_decode_0000404c_params = ptr_decode_0000404c_params[4];\n    if (((int)((uint)uVar1 << 0x13) < 0) && ((bytes_read != -1 || (*input_buffer == 0)))) {\n      ptr_decode_0000404c_params[0x15] = bytes_read;\n    }\n    int *ptr_decode_0000404c_params_13 = (int *)ptr_decode_0000404c_params[0xd];\n    *input_buffer = orig_input_buffer;\n    if (ptr_decode_0000404c_params_13 != (int *)0x0) {\n      if (ptr_decode_0000404c_params_13 != ptr_decode_0000404c_params + 0x11) {\n        _free_r(input_buffer);\n      }\n      ptr_decode_0000404c_params[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000404c",
            "calling": [
                "__srefill_r",
                "_fflush_r"
            ],
            "imported": false,
            "current_name": "decode_0000404c"
        },
        "FUN_00002f74": {
            "renaming": {
                "FUN_00002f74": "print_saul_devices_00002f74",
                "dev": "current_device",
                "i": "device_count",
                "pcVar1": "device_type",
                "PTR_saul_reg_00002fd0": "current_device_pointer",
                "PTR_s_No_devices_found_00002fd8": "no_devices_found_message",
                "PTR_s_ID_Class_Name_00002fd4": "device_id_message",
                "saul_class_to_str": "get_device_type_string",
                "saul_reg_t": "saul_device",
                "next": "next_device",
                "name": "device_name",
                "PTR_s___i__s__s_00002fdc": "device_info_message"
            },
            "code": "void print_saul_devices_00002f74(void)\n{\n  saul_reg_t *current_device = *(saul_reg_t **)PTR_saul_reg_00002fd0;\n  int device_count = 0;\n  if (current_device == (saul_reg_t *)0x0) {\n    puts(PTR_s_No_devices_found_00002fd8);\n  }\n  else {\n    puts(PTR_s_ID_Class_Name_00002fd4);\n  }\n  for (; current_device != (saul_reg_t *)0x0; current_device = current_device->next) {\n    char *device_type = saul_class_to_str(current_device->driver->type);\n    char *device_name = current_device->name;\n    iprintf(PTR_s___i__s__s_00002fdc,device_count,device_type,device_name);\n    device_count++;\n  }\n  return;\n}",
            "called": [
                "iprintf",
                "puts",
                "saul_class_to_str"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f74",
            "calling": [
                "_saul"
            ],
            "imported": false,
            "current_name": "print_saul_devices_00002f74"
        },
        "FUN_000010a0": {
            "renaming": {
                "FUN_000010a0": "calculateStackSpace_000010a0",
                "stack": "stackPointer",
                "space_free": "freeSpace",
                "stackp": "currentPointer"
            },
            "code": "uintptr_t calculateStackSpace_000010a0(char *stackPointer) {\n  uintptr_t freeSpace;\n  uintptr_t *currentPointer;\n  \n  for (currentPointer = (uintptr_t *)stackPointer; (uintptr_t *)*currentPointer == currentPointer; currentPointer++) {\n  }\n  return (int)currentPointer - (int)stackPointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010a0",
            "calling": [
                "ps"
            ],
            "imported": false,
            "current_name": "calculateStackSpace_000010a0"
        },
        "FUN_000012e2": {
            "renaming": {
                "FUN_000012e2": "read_from_isrpipe_000012e2",
                "*isrpipe": "*isrpipe",
                "*buffer": "*buffer",
                "count": "count",
                "iVar1": "read_result",
                "res": "mutex_lock_result"
            },
            "code": "int read_from_isrpipe_000012e2(isrpipe_t *isrpipe, char *buffer, size_t count) {\n    int read_result;\n    int mutex_lock_result;\n    \n    while (true) {\n        read_result = tsrb_get(&isrpipe->tsrb, buffer, count);\n        if (read_result != 0) {\n            break;\n        }\n        mutex_lock_result = mutex_lock(&isrpipe->mutex);\n    }\n    return read_result;\n}",
            "called": [
                "mutex_lock",
                "tsrb_get"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012e2",
            "calling": [
                "uart_stdio_read"
            ],
            "imported": false,
            "current_name": "read_from_isrpipe_000012e2"
        },
        "FUN_000056a0": {
            "renaming": {
                "FUN_000056a0": "find_environment_variable_000056a0",
                "param_1": "env_var",
                "param_2": "env_value",
                "param_3": "end_of_env_name",
                "param_4": "unknown_param",
                "uStack_c": "end_of_env_name",
                "uStack_8": "unknown_var",
                "_findenv_r": "getenv"
            },
            "code": "void find_environment_variable_000056a0(const char* env_var, char** env_value) {\n    char* end_of_env_name = strchr(env_var, '=');\n    if (end_of_env_name) {\n        *end_of_env_name = '\\0';\n    }\n    *env_value = getenv(env_var);\n}",
            "called": [
                "_findenv_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056a0",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "find_environment_variable_000056a0"
        },
        "FUN_0000231c": {
            "renaming": {
                "FUN_0000231c": "copy_data_from_buffer_0000231c",
                "*rb": "*ring_buffer",
                "dst": "*destination",
                "n": "num_bytes",
                "cVar1": "next_char",
                "iVar2": "is_ring_buffer_empty",
                "local_20": "destination_ptr",
                "tmp": "bytes_remaining",
                "_pop": "tsrb_pop"
            },
            "code": "int copy_data_from_buffer_0000231c(tsrb_t *ring_buffer, char *destination, size_t num_bytes) {\n  char next_char;\n  int is_ring_buffer_empty;\n  char *destination_ptr = destination;\n  size_t bytes_remaining = num_bytes;\n  while ((bytes_remaining != 0 && (is_ring_buffer_empty = tsrb_empty(ring_buffer), is_ring_buffer_empty == 0))) {\n    next_char = tsrb_pop(ring_buffer);\n    *destination_ptr = next_char;\n    bytes_remaining--;\n    destination_ptr++;\n  }\n  return num_bytes - bytes_remaining;\n}",
            "called": [
                "tsrb_empty",
                "_pop"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000231c",
            "calling": [
                "isrpipe_read"
            ],
            "imported": false,
            "current_name": "copy_data_from_buffer_0000231c"
        },
        "FUN_000061cc": {
            "renaming": {
                "FUN_000061cc": "FUNC_000061cc"
            },
            "code": "\nint FUNC_000061cc(int param_1,byte **param_2,byte *param_3,int **param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  void *pvVar4;\n  uint uVar5;\n  byte *pbVar6;\n  uint uVar7;\n  int **local_2b0;\n  undefined auStack_2ac [256];\n  uint local_1ac;\n  undefined4 local_1a8;\n  uint local_1a4;\n  int local_1a0;\n  int local_19c;\n  undefined *local_198;\n  int local_194;\n  undefined4 local_30;\n  code *local_2c;\n  \n  puVar2 = PTR_DAT_000064b4;\n  puVar1 = PTR_DAT_000064b0;\n  local_1a0 = 0;\n  local_19c = 0;\n  local_30 = DAT_000064a8;\n  local_2c = DAT_000064ac;\n  local_2b0 = param_4;\n  local_198 = auStack_2ac;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      uVar7 = (uint)*param_3;\n      if (uVar7 == 0) {\n        return local_1a0;\n      }\n      uVar5 = (byte)puVar1[uVar7] & 8;\n      pbVar6 = param_3 + 1;\n      if ((puVar1[uVar7] & 8) == 0) break;\n      while (((param_3 = pbVar6, 0 < (int)param_2[1] ||\n              (iVar3 = (*local_2c)(param_1,param_2), iVar3 == 0)) &&\n             ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0))) {\n        local_19c = local_19c + 1;\n        param_2[1] = param_2[1] + -1;\n        *param_2 = *param_2 + 1;\n      }\n    }\n    if (uVar7 == 0x25) break;\nLAB_00006352:\n    if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n    goto LAB_00006380;\n    if (**param_2 != uVar7) {\n      return local_1a0;\n    }\n    *param_2 = *param_2 + 1;\n    local_19c = local_19c + 1;\n    param_2[1] = param_2[1] + -1;\n    param_3 = pbVar6;\n  }\n  local_1a4 = uVar5;\n  local_1ac = uVar5;\n  if (param_3[1] == 0x2a) {\n    pbVar6 = param_3 + 2;\n    local_1ac = 0x10;\n  }\n  while( true ) {\n    uVar5 = (uint)*pbVar6;\n    if (9 < uVar5 - 0x30) break;\n    pbVar6 = pbVar6 + 1;\n    local_1a4 = (local_1a4 * 10 + uVar5) - 0x30;\n  }\n  pvVar4 = memchr(PTR_DAT_000064b4,uVar5,3);\n  if (pvVar4 != (void *)0x0) {\n    local_1ac = 1 << ((int)pvVar4 - (int)puVar2 & 0xffU) | local_1ac;\n    pbVar6 = pbVar6 + 1;\n  }\n  param_3 = pbVar6 + 1;\n  uVar5 = (uint)*pbVar6;\n  if (uVar5 < 0x79) {\n    if (0x57 < uVar5) {\n      switch(uVar5) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        param_3 = (byte *)__sccl(auStack_2ac,param_3);\n        local_1ac = local_1ac | 0x40;\n        local_194 = 1;\n        break;\n      case 99:\n        local_1ac = local_1ac | 0x40;\n        local_194 = 0;\n        break;\n      case 100:\n      case 0x75:\n        local_1a8 = 10;\nLAB_000063a0:\n        if (uVar5 < 0x6f) {\n          local_194 = 3;\n        }\n        else {\n          local_194 = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        local_194 = 5;\n        break;\n      case 0x69:\n        local_1a8 = 0;\n        local_194 = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(local_1ac << 0x1b)) {\n          if ((int)(local_1ac << 0x1f) < 0) {\n            *(short *)*local_2b0 = (short)local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n          else {\n            **local_2b0 = local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        local_1a8 = 8;\n        local_194 = 4;\n        break;\n      case 0x70:\n        local_1ac = local_1ac | 0x20;\n      case 0x58:\n      case 0x78:\n        local_1ac = local_1ac | 0x200;\n        local_1a8 = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        local_194 = 2;\n      }\nLAB_000063ac:\n      if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(local_1ac << 0x19)) {\n        while ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0) {\n          local_19c = local_19c + 1;\n          pbVar6 = param_2[1];\n          param_2[1] = pbVar6 + -1;\n          if ((int)(pbVar6 + -1) < 1) {\n            iVar3 = (*local_2c)(param_1,param_2);\n            if (iVar3 != 0) goto LAB_00006380;\n          }\n          else {\n            *param_2 = *param_2 + 1;\n          }\n        }\n      }\n      if (local_194 < 3) {\n        iVar3 = _scanf_chars(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else if (local_194 < 5) {\n        iVar3 = _scanf_i(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else {\n        iVar3 = param_1;\n        if (DAT_000064b8 == 0) goto LAB_000061f6;\n      }\n      if (iVar3 == 1) {\n        return local_1a0;\n      }\n      if (iVar3 == 2) {\nLAB_00006380:\n        if (local_1a0 == 0) {\nLAB_00006388:\n          local_1a0 = -1;\n        }\n        else if ((*(ushort *)(param_2 + 3) & 0x40) != 0) {\n          local_1a0 = -1;\n        }\n        return local_1a0;\n      }\n      goto LAB_000061f6;\n    }\n    pbVar6 = param_3;\n    if (uVar5 == 0x25) goto LAB_00006352;\n    if (uVar5 < 0x26) {\n      if (uVar5 != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (uVar5 - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  local_194 = 3;\n  local_1a8 = 10;\n  goto LAB_000063ac;\n}\n\n",
            "called": [
                "_scanf_i",
                "__ssrefill_r",
                "__sccl",
                "_scanf_chars",
                "memchr"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000061cc",
            "calling": [
                "siscanf"
            ],
            "imported": false,
            "current_name": "FUNC_000061cc"
        },
        "FUN_00002690": {
            "renaming": {
                "FUN_00002690": "convert_rtt_alarm_to_tm_00002690",
                "time": "current_time",
                "t": "rtt_alarm_time",
                "_0_4_": "first_half_of_time_t",
                "_4_4_": "second_half_of_time_t",
                "gmtime_r": "gmtime_r",
                "time_t": "time_t",
                "&t": "&rtt_alarm_time",
                "tm": "tm",
                "return": "return"
            },
            "code": "int convert_rtt_alarm_to_tm_00002690(tm *current_time)\n{\n  time_t rtt_alarm_time;\n  rtt_alarm_time = rtt_get_alarm();\n  time_t zero_time = 0;\n  gmtime_r(&rtt_alarm_time, current_time);\n  return 0;\n}",
            "called": [
                "gmtime_r",
                "rtt_get_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002690",
            "calling": [
                "_rtc_getalarm"
            ],
            "imported": false,
            "current_name": "convert_rtt_alarm_to_tm_00002690"
        },
        "FUN_00006010": {
            "renaming": {
                "FUN_00006010": "string_search_00006010",
                "__s": "string",
                "__c": "character",
                "__n": "size",
                "bVar1": "byte",
                "cVar2": "char1",
                "cVar3": "char2",
                "cVar4": "char3",
                "cVar5": "char4",
                "pbVar6": "byte_ptr1",
                "puVar7": "uint_ptr",
                "pbVar8": "byte_ptr2",
                "uVar9": "byte_character",
                "uVar10": "alignment_offset",
                "uVar11": "aligned_size",
                "uVar12": "comparison1",
                "uVar13": "comparison2",
                "bVar14": "bool1",
                "bVar15": "bool2",
                "bVar16": "bool3",
                "bVar17": "bool4"
            },
            "code": "void * string_search_00006010(void *string, int character, size_t size)\n{\n  uint8_t *byte_string = (uint8_t*)string;\n  uint8_t byte_character = character & 0xff;\n  if ((int)size < 0x10) {\n    while (size-- > 0) {\n      if (*byte_string++ == byte_character) {\n        return byte_string - 1;\n      }\n    }\n  }\n  else {\n    uint64_t alignment_offset = (uint64_t)byte_string & 7;\n    uint32_t uint32_character = byte_character | byte_character << 8 | byte_character << 16 | byte_character << 24;\n    while (alignment_offset != 0) {\n      if (*byte_string == byte_character) {\n        return byte_string;\n      }\n      byte_string++;\n      size--;\n      if (size == 0) {\n        return NULL;\n      }\n      alignment_offset = (uint64_t)byte_string & 7;\n    }\n    uint64_t *word_string = (uint64_t*)byte_string;\n    uint64_t uint64_character = uint32_character | (uint64_character << 32);\n    size_t aligned_size = size & ~7;\n    while (aligned_size != 0) {\n      uint64_t word = *word_string++ ^ uint64_character;\n      if (((word - 0x0101010101010101) & ~word & 0x8080808080808080) != 0) {\n        uint8_t *byte_word = (uint8_t*)(word_string - 1);\n        while (*byte_word != byte_character) {\n          byte_word++;\n        }\n        return byte_word;\n      }\n      aligned_size -= 8;\n    }\n    byte_string = (uint8_t*)word_string;\n    size &= 7;\n    while (size-- > 0) {\n      if (*byte_string++ == byte_character) {\n        return byte_string - 1;\n      }\n    }\n  }\n  return NULL;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006010",
            "calling": [
                "_scanf_i",
                "__ssvfiscanf_r",
                "_vfprintf_r",
                "_printf_i"
            ],
            "imported": false,
            "current_name": "string_search_00006010"
        },
        "FUN_00001cf0": {
            "renaming": {
                "FUN_00001cf0": "check_context_switch_request_00001cf0",
                "PTR_sched_context_switch_request_00001d04": "sched_ctx_switch_req"
            },
            "code": "void check_context_switch_request_00001cf0(void)\n{\n  int* PTR_sched_context_switch_request_00001d04 = (int*)PTR_sched_context_switch_request_00001d04;\n  if (*PTR_sched_context_switch_request_00001d04 != 0) {\n    thread_yield_higher();\n  }\n  return;\n}",
            "called": [
                "thread_yield_higher"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001cf0",
            "calling": [
                "irq_handler"
            ],
            "imported": false,
            "current_name": "check_context_switch_request_00001cf0"
        },
        "FUN_00003ec4": {
            "renaming": {
                "FUN_00003ec4": "format_float_00003ec4",
                "out": "output_buffer",
                "val": "value",
                "fp_digits": "decimal_places",
                "val_00": "quotient",
                "iVar2": "remainder_length",
                "div_len": "divisor_length",
                "abs": "absolute_value",
                "e": "exponent",
                "div": "remainder",
                "pos": "position",
                "SCARRY4": "SCARRY4",
                "core_panic": "core_panic",
                "PANIC_ASSERT_FAIL": "PANIC_ASSERT_FAIL",
                "PTR_assert_crash_message_00003fec": "PTR_assert_crash_message_00003fec",
                "PTR__tenmap_00003ff0": "PTR__tenmap_00003ff0",
                "fmt_s32_dec": "format_integer",
                "fmt_lpad": "fmt_lpad",
                "memset": "memset"
            },
            "code": "size_t format_float_00003ec4(char *output_buffer, int32_t value, int decimal_places) {\n  size_t position = 0;\n\n  if (decimal_places + 7 < 0 != SCARRY4(decimal_places,7)) {\n    core_panic(PANIC_ASSERT_FAIL, PTR_assert_crash_message_00003fec);\n  }\n\n  if (decimal_places == 0) {\n    position = format_integer(output_buffer, value);\n  }\n  else if (decimal_places < 1) {\n    uint32_t divisor = *(uint32_t *)(PTR__tenmap_00003ff0 + decimal_places * -4);\n    uint32_t quotient = (uint32_t)value / divisor;\n    int32_t remainder = value - divisor * quotient;\n\n    if (remainder < 0) {\n      remainder = -remainder;\n    }\n\n    if ((quotient == 0) && (value < 0)) {\n      if (output_buffer != NULL) {\n        *output_buffer = '-';\n      }\n      position = 1;\n    }\n\n    if (output_buffer == NULL) {\n      size_t quotient_length = format_integer(NULL, quotient);\n      position = quotient_length + 1;\n    }\n    else {\n      size_t quotient_length = format_integer(output_buffer + position, quotient);\n      position += quotient_length;\n\n      *(output_buffer + position) = '.';\n      position++;\n\n      size_t remainder_length = format_integer(output_buffer + position, remainder);\n      fmt_lpad(output_buffer + position, remainder_length, -decimal_places, '0');\n    }\n\n    position = -decimal_places + position;\n  }\n  else {\n    size_t integer_length = format_integer(output_buffer, value);\n    if (output_buffer != NULL) {\n      memset(output_buffer + integer_length, '0', decimal_places);\n    }\n    position = decimal_places + integer_length;\n  }\n\n  return position;\n}",
            "called": [
                "fmt_s32_dec",
                "fmt_lpad",
                "memset",
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ec4",
            "calling": [
                "fmt_s16_dfp"
            ],
            "imported": false,
            "current_name": "format_float_00003ec4"
        },
        "FUN_00001360": {
            "renaming": {
                "FUN_00001360": "calculate_address_offset_00001360",
                "ptr": "ptr",
                "bit": "bit",
                "uint": "uintptr_t",
                "upper_bits": "upper_bits",
                "lower_bits": "lower_bits",
                "offset": "offset"
            },
            "code": "void * calculate_address_offset_00001360(void *ptr, uintptr_t bit) {\n    uintptr_t upper_bits = ((uintptr_t) ptr) & 0xf0000000;\n    uintptr_t lower_bits = ((uintptr_t) ptr) & 0xfffff;\n    uintptr_t offset = (lower_bits << 5) + (bit * 4) + 0x2000000;\n    return (void *) (upper_bits | offset);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001360",
            "calling": [
                "bit_set32"
            ],
            "imported": false,
            "current_name": "calculate_address_offset_00001360"
        },
        "FUN_00004622": {
            "renaming": {
                "FUN_00004622": "fill_memory_with_char_00004622",
                "__s": "memory",
                "__c": "character",
                "__n": "size",
                "puVar1": "pointer"
            },
            "code": "void * fill_memory_with_char_00004622(void *memory, int character, size_t size) {\n  char *pointer;\n  for (pointer = (char *)memory; pointer != (char *)(size + (int)memory); pointer++) {\n    *pointer = (char)character;\n  }\n  return memory;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004622",
            "calling": [
                "std",
                "__sfmoreglue",
                "fmt_s32_dfp",
                "fmt_lpad",
                "__sfp",
                "write"
            ],
            "imported": false,
            "current_name": "fill_memory_with_char_00004622"
        },
        "FUN_0000093c": {
            "renaming": {
                "FUN_0000093c": "set_flag_for_data_0000093c",
                "PTR_DAT_00000954": "data_ptr",
                "uint": "uint32_t",
                "DAT_00000954": "data_start_address"
            },
            "code": "void set_flag_for_data_0000093c(void)\n{\n    uint32_t *PTR_DAT_00000954 = (uint32_t *)(DAT_00000954 + 4);\n    uint32_t flag_value = 0x10000000;\n    *PTR_DAT_00000954 |= flag_value;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000093c",
            "calling": [
                "cortexm_isr_end",
                "_mutex_lock",
                "sched_switch",
                "cortexm_isr_end",
                "cortexm_isr_end"
            ],
            "imported": false,
            "current_name": "set_flag_for_data_0000093c"
        },
        "FUN_00003658": {
            "renaming": {
                "FUN_00003658": "synchronize_data_00003658",
                "DAT_00003680": "PTR_data",
                "DAT_00003684": "data_value",
                "DataSynchronizationBarrier": "synchronize_data_barrier",
                "uint": "unsigned_int",
                "*data_ptr": "data_pointer",
                "data_val": "data_value"
            },
            "code": "void synchronize_data_00003658(void)\n{\n    DataSynchronizationBarrier(0xf);\n    uint* data_ptr = (uint*)(DAT_00003680 + 0xc);\n    uint data_val = DAT_00003684 | (*data_ptr & 0x700);\n    *data_ptr = data_val;\n    DataSynchronizationBarrier(0xf);\n    while(true) {\n        // do nothing\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003658",
            "calling": [
                "pm_reboot"
            ],
            "imported": false,
            "current_name": "synchronize_data_00003658"
        },
        "FUN_000019c0": {
            "renaming": {
                "FUN_000019c0": "enable_oscillator_and_set_fll_factor_000019c0",
                "DAT_00001a0c": "DAT_buffer",
                "DAT_00001a10": "DAT_register",
                "PTR_current_mode_00001a14": "current_mode_ptr",
                "kinetis_mcg_enable_osc": "enable_oscillator",
                "kinetis_mcg_set_fll_factor": "set_fll_factor",
                "KINETIS_MCG_FLL_FACTOR_1920": "FLL_FACTOR_1920",
                "bit_clear8": "clear_bit_in_byte",
                "kinetis_mcg_disable_pll": "disable_pll"
            },
            "code": "void enable_oscillator_and_set_fll_factor_000019c0(void)\n{\n  enable_oscillator();\n  set_fll_factor(FLL_FACTOR_1920);\n  clear_bit_in_byte(DAT_00001a0c, 0x01);\n  *DAT_00001a10 = (*DAT_00001a10 & 0x3b) | 0x80;\n  wait_for_condition();\n  disable_pll();\n  *PTR_current_mode_00001a14 = 3;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_disable_pll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000019c0",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "enable_oscillator_and_set_fll_factor_000019c0"
        },
        "FUN_000060b0": {
            "renaming": {
                "FUN_000060b0": "copy_memory_000060b0",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "puVar1": "destination_ptr",
                "puVar2": "source_end_ptr",
                "puVar3": "destination_end_ptr"
            },
            "code": "void * copy_memory_000060b0(void *destination, const void *source, size_t size)\n{\n    unsigned char *dest = (unsigned char *)destination;\n    const unsigned char *src = (const unsigned char *)source;\n    for (size_t i = 0; i < size; i++) {\n        dest[i] = src[i];\n    }\n    return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060b0",
            "calling": [
                "__submore",
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "copy_memory_000060b0"
        },
        "FUN_00006a14": {
            "renaming": {
                "FUN_00006a14": "FUNC_00006a14"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong FUNC_00006a14(uint param_1,uint param_2,uint param_3,uint param_4,uint *param_5)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  uint uVar1;\n  uint *puVar2;\n  uint *puVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  bool bVar11;\n  ulonglong uVar12;\n  \n  if (param_4 == 0) {\n    if (param_2 < param_3) {\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 != 0) {\n        param_3 = param_3 << (uVar4 & 0xff);\n        param_2 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        param_1 = param_1 << (uVar4 & 0xff);\n      }\n      uVar7 = param_3 >> 0x10;\n      uVar9 = param_2 / uVar7;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar7 * uVar9) * 0x10000;\n      uVar1 = uVar9 * (param_3 & 0xffff);\n      uVar6 = uVar9;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar9 = (uVar5 - uVar1) / uVar7;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar7 * uVar9) * 0x10000;\n      uVar7 = uVar9 * (param_3 & 0xffff);\n      uVar1 = uVar9;\n      if (uVar5 <= uVar7 && uVar7 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar7 && uVar7 - uVar5 != 0)) {\n          uVar1 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar7;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n      puVar3 = (uint *)0x0;\n    }\n    else {\n      if (param_3 == 0) {\n                    /* WARNING: Could not recover jumptable at 0x00006abc. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x6abc);\n        uVar12 = (*UNRECOVERED_JUMPTABLE)();\n        return uVar12;\n      }\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 == 0) {\n        param_2 = param_2 - param_3;\n        uVar10 = param_3 >> 0x10;\n        uVar8 = param_3 & 0xffff;\n        puVar3 = (uint *)0x1;\n      }\n      else {\n        param_3 = param_3 << (uVar4 & 0xff);\n        uVar10 = param_3 >> 0x10;\n        uVar6 = param_2 >> (0x20 - uVar4 & 0xff);\n        uVar1 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        uVar5 = uVar6 / uVar10;\n        uVar8 = param_3 & 0xffff;\n        uVar9 = uVar1 >> 0x10 | (uVar6 - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        param_1 = param_1 << (uVar4 & 0xff);\n        uVar6 = uVar5;\n        if (uVar9 <= uVar7 && uVar7 - uVar9 != 0) {\n          bVar11 = CARRY4(param_3,uVar9);\n          uVar9 = param_3 + uVar9;\n          uVar6 = uVar5 - 1;\n          if ((bVar11 == false) && (uVar9 <= uVar7 && uVar7 - uVar9 != 0)) {\n            uVar6 = uVar5 - 2;\n            uVar9 = uVar9 + param_3;\n          }\n        }\n        uVar5 = (uVar9 - uVar7) / uVar10;\n        param_2 = uVar1 & 0xffff | ((uVar9 - uVar7) - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        uVar1 = uVar5;\n        if (param_2 <= uVar7 && uVar7 - param_2 != 0) {\n          bVar11 = CARRY4(param_3,param_2);\n          param_2 = param_3 + param_2;\n          uVar1 = uVar5 - 1;\n          if ((bVar11 == false) && (param_2 <= uVar7 && uVar7 - param_2 != 0)) {\n            uVar1 = uVar5 - 2;\n            param_2 = param_2 + param_3;\n          }\n        }\n        param_2 = param_2 - uVar7;\n        puVar3 = (uint *)(uVar1 | uVar6 << 0x10);\n      }\n      uVar7 = param_2 / uVar10;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar10 * uVar7) * 0x10000;\n      uVar1 = uVar8 * uVar7;\n      uVar6 = uVar7;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar7 = (uVar5 - uVar1) / uVar10;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar10 * uVar7) * 0x10000;\n      uVar8 = uVar8 * uVar7;\n      uVar1 = uVar7;\n      if (uVar5 <= uVar8 && uVar8 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar8 && uVar8 - uVar5 != 0)) {\n          uVar1 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar8;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = uVar5 >> (uVar4 & 0xff);\n      param_5[1] = 0;\n    }\n  }\n  else if (param_2 < param_4) {\n    puVar2 = param_5;\n    puVar3 = param_5;\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n      return 0;\n    }\n  }\n  else {\n    puVar3 = (uint *)count_leading_zeroes(param_4);\n    if (puVar3 != (uint *)0x0) {\n      uVar8 = 0x20 - (int)puVar3;\n      uVar5 = param_3 >> (uVar8 & 0xff) | param_4 << ((uint)puVar3 & 0xff);\n      uVar10 = uVar5 >> 0x10;\n      uVar4 = param_2 >> (uVar8 & 0xff);\n      uVar6 = param_1 >> (uVar8 & 0xff) | param_2 << ((uint)puVar3 & 0xff);\n      uVar7 = uVar4 / uVar10;\n      uVar1 = uVar6 >> 0x10 | (uVar4 - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      param_3 = param_3 << ((uint)puVar3 & 0xff);\n      param_1 = param_1 << ((uint)puVar3 & 0xff);\n      uVar4 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar4 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar4 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar7 = (uVar1 - uVar9) / uVar10;\n      uVar1 = uVar6 & 0xffff | ((uVar1 - uVar9) - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      uVar6 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar6 = uVar6 | uVar4 << 0x10;\n      uVar12 = (ulonglong)uVar6 * (ulonglong)param_3;\n      if (CONCAT44(uVar1 - uVar9,param_1) < uVar12) {\n        uVar12 = uVar12 - CONCAT44(uVar5,param_3);\n        uVar6 = uVar6 - 1;\n      }\n      if (param_5 != (uint *)0x0) {\n        uVar4 = ((uVar1 - uVar9) - (int)(uVar12 >> 0x20)) - (uint)(param_1 < (uint)uVar12);\n        *param_5 = uVar4 << (uVar8 & 0xff) | param_1 - (uint)uVar12 >> ((uint)puVar3 & 0xff);\n        param_5[1] = uVar4 >> ((uint)puVar3 & 0xff);\n      }\n      return (ulonglong)uVar6;\n    }\n    if ((param_4 < param_2) || (puVar2 = puVar3, param_3 <= param_1)) {\n      bVar11 = param_1 < param_3;\n      param_1 = param_1 - param_3;\n      param_2 = (param_2 - param_4) - (uint)bVar11;\n      puVar2 = (uint *)0x1;\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n    }\n  }\n  return CONCAT44(puVar3,puVar2);\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00006a14",
            "calling": [
                "__aeabi_ldivmod"
            ],
            "imported": false,
            "current_name": "FUNC_00006a14"
        },
        "FUN_000023d0": {
            "renaming": {
                "FUN_000023d0": "getTicks_000023d0",
                "ticks": "inputTicks",
                "uVar1": "result",
                "PTR_noHyperCall_000023fc": "noHyperCallPointer"
            },
            "code": "uint32_t getTicks_000023d0(uint32_t ticks){\n  uint32_t result;\n  if (*(int *)PTR_noHyperCall_000023fc == 0) {\n    result = aflCall(1, ticks, 0);\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}",
            "called": [
                "aflCall"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023d0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "getTicks_000023d0"
        },
        "FUN_00000a30": {
            "renaming": {
                "FUN_00000a30": "handle_NMI_00000a30",
                "PTR_s_NMI_HANDLER_00000a3c": "NMI_HANDLER_MSG"
            },
            "code": "void handle_NMI_00000a30(void)\n{\n    core_panic(PANIC_NMI_HANDLER, PTR_s_NMI_HANDLER_00000a3c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a30",
            "calling": [],
            "imported": false,
            "current_name": "handle_NMI_00000a30"
        },
        "FUN_000034c0": {
            "renaming": {
                "FUN_000034c0": "print_rtc_commands_000034c0",
                "PTR_s_usage__rtc__command___arguments__00003500": "rtc_usage",
                "PTR_s_commands__00003504": "rtc_commands",
                "PTR_s__poweron_power_the_interface_on_00003508": "power_on_interface",
                "PTR_s__poweroff_power_the_interface_of_0000350c": "power_off_interface",
                "PTR_s__clearalarm_deactivate_the_curre_00003510": "deactivate_current_alarm",
                "PTR_s__getalarm_print_the_currently_al_00003514": "print_current_alarm",
                "PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518": "set_alarm",
                "PTR_s__gettime_print_the_current_time_0000351c": "print_current_time",
                "PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520": "set_time"
            },
            "code": "int print_rtc_commands_000034c0(void)\n{\n  puts(PTR_s_usage__rtc__command___arguments__00003500);\n  puts(PTR_s_commands__00003504);\n  puts(PTR_s__poweron_power_the_interface_on_00003508);\n  puts(PTR_s__poweroff_power_the_interface_of_0000350c);\n  puts(PTR_s__clearalarm_deactivate_the_curre_00003510);\n  puts(PTR_s__getalarm_print_the_currently_al_00003514);\n  puts(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n  puts(PTR_s__gettime_print_the_current_time_0000351c);\n  puts(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n  return 0;\n}",
            "called": [
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000034c0",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "print_rtc_commands_000034c0"
        },
        "FUN_000050e8": {
            "renaming": {
                "FUN_000050e8": "acquire_time_zone_lock_000050e8",
                "PTR___lock___tz_mutex_000050f0": "time_zone_mutex"
            },
            "code": "void acquire_time_zone_lock_000050e8(void)\n{\n  __retarget_lock_acquire(PTR___lock___tz_mutex_000050f0);\n  return;\n}",
            "called": [
                "__retarget_lock_acquire"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050e8",
            "calling": [
                "mktime"
            ],
            "imported": false,
            "current_name": "acquire_time_zone_lock_000050e8"
        },
        "FUN_000042a4": {
            "renaming": {
                "FUN_000042a4": "initialize_data_structure_000042a4",
                "param_1": "data_structure",
                "uVar1": "field_value",
                "iVar2": "global_data_structure",
                "bVar3": "is_global_data_structure",
                "*PTR__global_impure_ptr_0000430c": "GLOBAL_REFERENCE_OFFSET",
                "DAT_00004310": "GLOBAL_DATA",
                "FUN_000042a4_lock_acquire": "acquire_lock",
                "FUN_000042a4_lock_release": "release_lock",
                "FIELD_1_OFFSET": "0x48",
                "FIELD_2_OFFSET": "0x4c",
                "FIELD_3_OFFSET": "0x50",
                "FIELD_1_VALUE_OFFSET": "4",
                "FIELD_2_VALUE_OFFSET": "8",
                "FIELD_3_VALUE_OFFSET": "0xc",
                "DATA_FLAG_OFFSET": "0x18"
            },
            "code": "void initialize_data_structure_000042a4(int data_structure)\\n{\\n    acquire_lock();\\n    if (*(int *)(data_structure + DATA_FLAG_OFFSET) == 0) {\\n        // initialize data fields\\n        *(int *)(data_structure + FIELD_1_OFFSET) = 0;\\n        *(int *)(data_structure + FIELD_2_OFFSET) = 0;\\n        *(int *)(data_structure + FIELD_3_OFFSET) = 0;\\n        // set up global reference to data_structure\\n        int global_data_structure = *(int *)*PTR__global_impure_ptr_0000430c;\\n        *(int *)(data_structure + FIELD_4_OFFSET) = DAT_00004310;\\n        bool is_global_data_structure = (global_data_structure == data_structure);\\n        if (is_global_data_structure) {\\n            global_data_structure = 1;\\n        }\\n        if (is_global_data_structure) {\\n            *(int *)(data_structure + DATA_FLAG_OFFSET) = global_data_structure;\\n        }\\n        // initialize data fields with values from function\\n        int field_1_value = get_field_1_value(data_structure);\\n        *(int *)(data_structure + FIELD_1_VALUE_OFFSET) = field_1_value;\\n        int field_2_value = get_field_2_value(data_structure);\\n        *(int *)(data_structure + FIELD_2_VALUE_OFFSET) = field_2_value;\\n        int field_3_value = get_field_3_value(data_structure);\\n        *(int *)(data_structure + FIELD_3_VALUE_OFFSET) = field_3_value;\\n        // set data flag to indicate initialization is complete\\n        *(int *)(data_structure + DATA_FLAG_OFFSET) = 1;\\n    }\\n    release_lock();\\n}",
            "called": [
                "__sinit_lock_acquire",
                "__sinit_lock_release",
                "std",
                "__sfp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000042a4",
            "calling": [
                "__swbuf_r",
                "__srefill_r",
                "_fflush_r",
                "__sfp",
                "_puts_r",
                "getchar",
                "iprintf",
                "putchar",
                "__swsetup_r",
                "_vfprintf_r",
                "__srget_r",
                "_putc_r",
                "_getc_r"
            ],
            "imported": false,
            "current_name": "initialize_data_structure_000042a4"
        },
        "FUN_00000514": {
            "renaming": {
                "FUN_00000514": "set_error_code_00000514",
                "r": "reent",
                "fd": "file_descriptor",
                "st": "file_status"
            },
            "code": "int set_error_code_00000514(_reent *reent, int file_descriptor, stat *file_status)\n{\n  reent->_errno = 0x13;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000514",
            "calling": [
                "__swhatbuf_r"
            ],
            "imported": false,
            "current_name": "set_error_code_00000514"
        },
        "FUN_00002e9c": {
            "renaming": {
                "FUN_00002e9c": "reboot_system_00002e9c",
                "argc": "arg_count",
                "argv": "arguments"
            },
            "code": "int reboot_system_00002e9c(int arg_count, char **arguments)\n{\n  pm_reboot();\n  return 0;\n}",
            "called": [
                "pm_reboot"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e9c",
            "calling": [],
            "imported": false,
            "current_name": "reboot_system_00002e9c"
        },
        "FUN_00001960": {
            "renaming": {
                "FUN_00001960": "setFLLFactorAndClearBit_00001960",
                "DAT_000019b4": "data_1",
                "DAT_000019b8": "data_2",
                "PTR_current_mode_000019bc": "current_mode",
                "KINETIS_MCG_FLL_FACTOR_1464": "FLL_FACTOR_1464",
                "'\\x01'": "BIT_1",
                "0x3b": "BIT_MASK_1",
                "0x44": "BIT_MASK_2",
                "4": "BIT_VALUE_1",
                "0xc": "BIT_MASK_3",
                "0x10": "BIT_MASK_4",
                "2": "MODE_2"
            },
            "code": "void setFLLFactorAndClearBit_00001960(void)\n{\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_1464);\n  bit_clear8(DAT_000019b4, BIT_1);\n  *DAT_000019b8 = (*DAT_000019b8 & BIT_MASK_1) | BIT_MASK_2;\n  while((DAT_000019b8[6] & BIT_MASK_3) != BIT_VALUE_1);\n  while((DAT_000019b8[6] & BIT_MASK_4) == 0);\n  *PTR_current_mode_000019bc = MODE_2;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001960",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "setFLLFactorAndClearBit_00001960"
        },
        "FUN_00000990": {
            "renaming": {
                "FUN_00000990": "do_nothing_00000990"
            },
            "code": "\nvoid do_nothing_00000990(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000990",
            "calling": [
                "reset_handler_default"
            ],
            "imported": false,
            "current_name": "do_nothing_00000990"
        },
        "FUN_00001a3c": {
            "renaming": {
                "FUN_00001a3c": "enable_pll_and_set_mode_to_5_00001a3c",
                "DAT_00001a58": "status_register",
                "PTR_current_mode_00001a5c": "current_mode_ptr"
            },
            "code": "void enable_pll_and_set_mode_to_5_00001a3c(void)\n{\n  set_bit_in_byte(DAT_00001a58, 0x01);\n  disable_pll();\n  *PTR_current_mode_00001a5c = 5;\n  return;\n}",
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a3c",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "enable_pll_and_set_mode_to_5_00001a3c"
        },
        "FUN_000045ee": {
            "renaming": {
                "FUN_000045ee": "reverse_copy_000045ee",
                "__dest": "destination",
                "__src": "source",
                "__n": "num_bytes",
                "puVar1": "destination_ptr",
                "puVar2": "source_ptr"
            },
            "code": "void * reverse_copy_000045ee(void *destination, const void *source, size_t num_bytes) {\n  unsigned char *source_ptr = (unsigned char *)source + num_bytes;\n  if ((source < destination) && (destination < source_ptr)) {\n    unsigned char *destination_ptr = (unsigned char *)destination + num_bytes;\n    while (destination_ptr != (unsigned char *)destination) {\n      source_ptr--;\n      destination_ptr--;\n      *destination_ptr = *source_ptr;\n    }\n  }\n  else {\n    unsigned char *destination_ptr = (unsigned char *)destination - 1;\n    for (; source != source_ptr; source_ptr++) {\n      destination_ptr++;\n      *destination_ptr = *(unsigned char *)source_ptr;\n    }\n  }\n  return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ee",
            "calling": [
                "fmt_lpad"
            ],
            "imported": false,
            "current_name": "reverse_copy_000045ee"
        },
        "FUN_00005404": {
            "renaming": {
                "FUN_00005404": "write_to_stream_00005404",
                "param_1": "file_descriptor",
                "param_2": "character",
                "param_3": "stream_buffer",
                "param_4": "flags",
                "iVar1": "buffer_offset",
                "uVar2": "short_value",
                "puVar3": "buffer_pointer",
                "PTR___sf_fake_stdin_0000549c": "original_stdin",
                "PTR___sf_fake_stdout_000054a0": "original_stdout",
                "PTR___sf_fake_stderr_000054a4": "original_stderr"
            },
            "code": "uint write_to_stream_00005404(int file_descriptor, uint character, int *stream_buffer, undefined4 flags) {\n  int buffer_offset;\n  uint short_value;\n  undefined *buffer_pointer;\n\n  if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream_buffer == (int *)PTR___sf_fake_stdin_0000549c) {\n    stream_buffer = *(int **)(file_descriptor + 4);\n  }\n  else if (stream_buffer == (int *)PTR___sf_fake_stdout_000054a0) {\n    stream_buffer = *(int **)(file_descriptor + 8);\n  }\n  else if (stream_buffer == (int *)PTR___sf_fake_stderr_000054a4) {\n    stream_buffer = *(int **)(file_descriptor + 0xc);\n  }\n  stream_buffer[2] = stream_buffer[6];\n  short_value = (uint)*(ushort *)(stream_buffer + 3);\n  buffer_offset = short_value << 0x1c;\n  if (((buffer_offset < 0) && (short_value = stream_buffer[4], short_value != 0)) || (buffer_offset = __swsetup_r(file_descriptor, stream_buffer, buffer_offset, short_value, flags), buffer_offset == 0)) {\n    buffer_offset = *stream_buffer - stream_buffer[4];\n    character = character & 0xff;\n    if ((buffer_offset < stream_buffer[5]) || (buffer_offset = _fflush_r(file_descriptor, stream_buffer), buffer_offset == 0)) {\n      stream_buffer[2] = stream_buffer[2] + -1;\n      buffer_pointer = (undefined *)*stream_buffer;\n      *stream_buffer = (int)(buffer_pointer + 1);\n      *buffer_pointer = (char)character;\n      if (stream_buffer[5] != buffer_offset + 1) {\n        if (-1 < (int)((uint)*(ushort *)(stream_buffer + 3) << 0x1f)) {\n          return character;\n        }\n        if (character != 10) {\n          return character;\n        }\n      }\n      buffer_offset = _fflush_r(file_descriptor, stream_buffer);\n      if (buffer_offset == 0) {\n        return character;\n      }\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "_fflush_r",
                "__swsetup_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005404",
            "calling": [
                "_puts_r",
                "__sfputc_r",
                "_putc_r"
            ],
            "imported": false,
            "current_name": "write_to_stream_00005404"
        },
        "FUN_00006974": {
            "renaming": {
                "FUN_00006974": "divide_or_remainder_00006974",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "remainder",
                "param_4": "unused",
                "iVar1": "quotient",
                "local_8": "unused"
            },
            "code": "int divide_or_remainder_00006974(int dividend, int divisor, int* remainder)\n{\n  int quotient;\n  if (divisor == 0)\n  {\n    if (dividend < 0)\n    {\n      dividend = 0;\n      divisor = -2147483648;\n    }\n    else if (dividend != 0)\n    {\n      dividend = 2147483647;\n      divisor = -1;\n    }\n    quotient = __aeabi_idiv0(dividend, divisor);\n    return quotient;\n  }\n  if (dividend < 0)\n  {\n    int absolute_dividend = -dividend - (divisor != 0);\n    if (*remainder < 0)\n    {\n      quotient = __udivmoddi4(-divisor, absolute_dividend, -*remainder, -divisor - (int)(-*remainder != 0), remainder);\n      return -quotient;\n    }\n    quotient = __udivmoddi4(-divisor, absolute_dividend, *remainder, divisor, remainder);\n    return -quotient;\n  }\n  if (*remainder < 0)\n  {\n    quotient = __udivmoddi4(dividend, divisor, -*remainder, -divisor - (int)(-*remainder != 0), remainder);\n    return -quotient;\n  }\n  quotient = __udivmoddi4(dividend, divisor, *remainder);\n  return quotient;\n}",
            "called": [
                "__udivmoddi4",
                "__aeabi_idiv0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006974",
            "calling": [
                "gmtime_r"
            ],
            "imported": false,
            "current_name": "divide_or_remainder_00006974"
        },
        "FUN_00004314": {
            "renaming": {
                "FUN_00004314": "find_or_create_int_ptr_array_00004314",
                "param_1": "error_code_ptr",
                "piVar1": "result_ptr",
                "piVar2": "current_ptr",
                "iVar3": "global_ptr",
                "ppiVar4": "array_of_ptrs_ptr"
            },
            "code": "int *find_or_create_int_ptr_array_00004314(undefined4 *error_code_ptr)\n{\n  int *result_ptr;\n  int *current_ptr;\n  int global_ptr;\n  int **array_of_ptrs_ptr;\n  acquire_lock();\n  global_ptr = *(int *)global_impure_ptr;\n  if (*(int *)(global_ptr + 0x18) == 0) {\n    __sinit(global_ptr);\n  }\n  array_of_ptrs_ptr = (int **)(global_ptr + 0x48);\n  do {\n    result_ptr = array_of_ptrs_ptr[1];\n    current_ptr = array_of_ptrs_ptr[2];\n    while (result_ptr = (int *)((int)result_ptr + -1), -1 < (int)result_ptr) {\n      if (*(short *)(current_ptr + 3) == 0) {\n        current_ptr[3] = global_int;\n        current_ptr[0x19] = 0;\n        __retarget_lock_init_recursive(current_ptr + 0x16);\n        release_lock();\n        current_ptr[1] = 0;\n        current_ptr[2] = 0;\n        current_ptr[4] = 0;\n        current_ptr[5] = 0;\n        *current_ptr = 0;\n        current_ptr[6] = 0;\n        memset(current_ptr + 0x17,0,8);\n        current_ptr[0xd] = 0;\n        current_ptr[0xe] = 0;\n        current_ptr[0x12] = 0;\n        current_ptr[0x13] = 0;\n        return current_ptr;\n      }\n      current_ptr = current_ptr + 0x1a;\n    }\n    if (*array_of_ptrs_ptr == (int *)0x0) {\n      result_ptr = (int *)__sfmoreglue(error_code_ptr,4);\n      *array_of_ptrs_ptr = result_ptr;\n      if (result_ptr == (int *)0x0) {\n        release_lock();\n        *error_code_ptr = 0xc;\n        return (int *)0x0;\n      }\n    }\n    array_of_ptrs_ptr = (int **)*array_of_ptrs_ptr;\n  } while( true );\n}",
            "called": [
                "__sfmoreglue",
                "memset",
                "__sfp_lock_release",
                "__retarget_lock_init_recursive",
                "__sfp_lock_acquire",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004314",
            "calling": [
                "__sinit"
            ],
            "imported": false,
            "current_name": "find_or_create_int_ptr_array_00004314"
        },
        "FUN_00005fd4": {
            "renaming": {
                "FUN_00005fd4": "parse_integer_00005fd4",
                "param_1": "result",
                "param_2": "input_string",
                "param_3": "next_char",
                "param_4": "base",
                "uVar1": "digit_value",
                "uVar2": "overflow_check",
                "bVar3": "current_char",
                "iVar4": "is_negative",
                "uVar5": "max_uint_div_base",
                "uVar6": "parsed_value",
                "pbVar7": "next_char_ptr",
                "pbVar8": "input_string_ptr"
            },
            "code": "uint parse_integer_00005fd4(undefined4 *result, byte *input_string, byte **next_char, uint base) {\n  uint digit_value;\n  uint overflow_check;\n  byte current_char;\n  int is_negative = 0;\n  uint max_uint_div_base = 0xffffffff / base;\n  uint parsed_value = 0;\n  byte *next_char_ptr = input_string;\n  do {\n    current_char = *next_char_ptr;\n    next_char_ptr++;\n    digit_value = (uint)current_char;\n    overflow_check = PTR_DAT_00005fd0[digit_value] & 8;\n  } while (overflow_check != 0);\n  if (digit_value == 0x2d) {\n    digit_value = (uint)*next_char_ptr;\n    is_negative = 1;\n    next_char_ptr++;\n  }\n  else if (digit_value == 0x2b) {\n    digit_value = (uint)*next_char_ptr;\n    next_char_ptr++;\n  }\n  if (base == 0) {\n    if (digit_value != 0x30) {\n      base = 10;\n      goto base_assigned;\n    }\n  }\n  else if (base == 0x10 && digit_value == 0x30) {\n    base = 0x10;\n    current_char = *next_char_ptr;\n    next_char_ptr++;\n  }\n  else if (base != 0x10) {\n    base = 8;\n  }\n  base_assigned:\n  while (true) {\n    digit_value = (uint)current_char;\n    if (digit_value - 0x30 > 9) {\n      if (digit_value - 0x41 < 0x1a) {\n        digit_value = digit_value - 0x37;\n      }\n      else {\n        if (digit_value - 0x61 > 0x19) break;\n        digit_value = digit_value - 0x57;\n      }\n    }\n    if (base <= digit_value) break;\n    if (((is_negative < 0) || (max_uint_div_base < parsed_value)) || ((max_uint_div_base == parsed_value && ((int)~(base * max_uint_div_base) < (int)digit_value)))) {\n      is_negative = -1;\n    }\n    else {\n      parsed_value = parsed_value * base + digit_value;\n      is_negative = 1;\n    }\n    current_char = *next_char_ptr;\n    next_char_ptr++;\n  }\n  if (is_negative < 0) {\n    *result = 0x22;\n    parsed_value = 0xffffffff;\n    if (next_char == (byte **)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (overflow_check != 0) {\n      parsed_value = -parsed_value;\n    }\n    if (next_char == (byte **)0x0) {\n      return parsed_value;\n    }\n    if (is_negative != 0) {\n      next_char_ptr--;\n    }\n    if (overflow_check == 0) {\n      next_char_ptr--;\n    }\n  }\n  *next_char = next_char_ptr;\n  return parsed_value;\n}",
            "called": [
                "_strtoul_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd4",
            "calling": [],
            "imported": false,
            "current_name": "parse_integer_00005fd4"
        },
        "FUN_00004dc8": {
            "renaming": {
                "FUN_00004dc8": "read_file_00004dc8",
                "param_1": "reent_ptr",
                "param_2": "file_descriptor",
                "param_3": "buffer",
                "param_4": "buffer_size",
                "_Var1": "read_size",
                "uVar2": "new_file_pointer",
                "bVar3": "read_success"
            },
            "code": "void read_file_00004dc8(_reent *reent_ptr, int file_descriptor, void *buffer, size_t buffer_size) {\n  \n  _ssize_t read_size = _read_r(reent_ptr, (int)*(short *)(file_descriptor + 0xe), buffer, buffer_size);\n  bool read_success = read_size >= 0;\n  \n  if (read_success) {\n    uint new_file_pointer = *(int *)(file_descriptor + 0x54) + read_size;\n    *(uint *)(file_descriptor + 0x54) = new_file_pointer;\n  }\n  else {\n    uint file_pointer = *(ushort *)(file_descriptor + 0xc) & 0xffffefff;\n    *(short *)(file_descriptor + 0xc) = (short)file_pointer;\n  }\n}",
            "called": [
                "_read_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dc8",
            "calling": [],
            "imported": false,
            "current_name": "read_file_00004dc8"
        },
        "FUN_00005fd8": {
            "renaming": {
                "FUN_00005fd8": "convert_string_to_ulong_00005fd8",
                "__nptr": "str",
                "__endptr": "endptr",
                "__base": "base",
                "uVar1": "result"
            },
            "code": "unsigned long convert_string_to_ulong_00005fd8(char *str, char **endptr, int base) {\n  unsigned long result = strtoul(*(unsigned long *)PTR__impure_ptr_00005fe8, str, endptr, base);\n  return result;\n}",
            "called": [
                "_strtoul_l.isra.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd8",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "convert_string_to_ulong_00005fd8"
        },
        "FUN_00005e10": {
            "renaming": {
                "FUN_00005e10": "read_byte_00005e10",
                "param_1": "file_descriptor",
                "param_2": "buffer",
                "iVar1": "refill_result",
                "uVar2": "byte_read",
                "pbVar3": "current_byte"
            },
            "code": "uint read_byte_00005e10(int file_descriptor, byte **buffer) {\n  int refill_result;\n  uint byte_read;\n  byte *current_byte;\n  if ((file_descriptor != 0) && (*(int *)(file_descriptor + 0x18) == 0)) {\n    __sinit();\n  }\n  if (buffer == (byte **)PTR___sf_fake_stdin_00005e5c) {\n    buffer = *(byte ***)(file_descriptor + 4);\n  }\n  else if (buffer == (byte **)PTR___sf_fake_stdout_00005e60) {\n    buffer = *(byte ***)(file_descriptor + 8);\n  }\n  else if (buffer == (byte **)PTR___sf_fake_stderr_00005e64) {\n    buffer = *(byte ***)(file_descriptor + 0xc);\n  }\n  refill_result = __srefill_r(file_descriptor, buffer);\n  if (refill_result == 0) {\n    buffer[1] = buffer[1] + -1;\n    current_byte = *buffer;\n    *buffer = current_byte + 1;\n    byte_read = (uint)*current_byte;\n  }\n  else {\n    byte_read = 0xffffffff;\n  }\n  return byte_read;\n}",
            "called": [
                "__srefill_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e10",
            "calling": [
                "_getc_r"
            ],
            "imported": false,
            "current_name": "read_byte_00005e10"
        },
        "FUN_000033f4": {
            "renaming": {
                "FUN_000033f4": "set_rtc_alarm_000033f4",
                "argv": "arguments",
                "iVar1": "parse_result",
                "now": "time_now",
                "DAT_0000343c": "alarm_data",
                "PTR_s_rtc__error_setting_alarm_00003440": "error_msg_rtc_alarm_set"
            },
            "code": "int set_rtc_alarm_000033f4(char **arguments)\n{\n    int parse_result;\n    tm time_now;\n\n    parse_result = parse_time(arguments, &time_now);\n\n    if (parse_result == 0) {\n        int alarm_set_result = rtc_set_alarm(&time_now, DAT_0000343c, (void *)0x0);\n        if (alarm_set_result == -1) {\n            puts(PTR_s_rtc__error_setting_alarm_00003440);\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    else {\n        return 1;\n    }\n}",
            "called": [
                "_parse_time",
                "puts",
                "rtc_set_alarm"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033f4",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "set_rtc_alarm_000033f4"
        },
        "FUN_0000443c": {
            "renaming": {
                "FUN_0000443c": "convert_time_to_tm_0000443c",
                "__timer": "time",
                "__tp": "time_info",
                "iVar1": "quotient",
                "uVar2": "remainder1",
                "uVar3": "total_days",
                "uVar4": "day_of_week",
                "iVar5": "num_leap_years",
                "uVar6": "year",
                "uVar9": "month",
                "bVar10": "is_negative",
                "tVar7": "seconds",
                "tVar8": "microseconds",
                "DAT_0000458c": "SECONDS_PER_DAY",
                "DAT_00004590": "DAYS_IN_YEAR",
                "DAT_00004594": "DAYS_IN_4_YEARS",
                "DAT_00004598": "DAYS_IN_100_YEARS",
                "count_leading_zeroes": "count_leap_years",
                "DAYS_SINCE_SUNDAY": "0",
                "DAYS_IN_WEEK": "7",
                "SECONDS_PER_DAY_IN_DAYS": "86400",
                "SECONDS_PER_MINUTE": "60",
                "SECONDS_PER_HOUR": "3600",
                "YEARS_FROM_1900_TO_1970": "70",
                "DAYS_FROM_1970_TO_2000": "10957"
            },
            "code": "tm* convert_time_to_tm_0000443c(time_t* time, tm* time_info) {\n    int quotient;\n    uint remainder1, remainder2, total_days, day_of_week, num_leap_years, year, month, day, days_since_jan_1_1970;\n    time_t seconds = time[0];\n    time_t microseconds = time[1];\n    quotient = __aeabi_ldivmod(seconds, microseconds, DAT_0000458c, 0);\n    remainder1 = DAT_0000458c;\n    __aeabi_ldivmod(seconds, microseconds, DAT_0000458c, 0);\n    bool is_negative = (int)remainder1 < 0;\n    if (is_negative) {\n        remainder1 += DAT_0000458c;\n        quotient += DAT_0000458c_IN_DAYS;\n    }\n    day_of_week = (quotient + DAYS_SINCE_SUNDAY) % DAYS_IN_WEEK;\n    total_days = quotient / DAT_0000458c_IN_DAYS;\n    days_since_jan_1_1970 = total_days - DAYS_FROM_1970_TO_2000;\n    num_leap_years = count_leap_years(days_since_jan_1_1970);\n    year = calculate_year(days_since_jan_1_1970, num_leap_years);\n    day = calculate_day(total_days, num_leap_years, year);\n    month = calculate_month(total_days, day, year);\n    time_info->tm_sec = remainder1 % SECONDS_PER_MINUTE;\n    time_info->tm_min = (remainder1 % SECONDS_PER_HOUR) / MINUTES_PER_HOUR;\n    time_info->tm_hour = remainder1 / SECONDS_PER_HOUR;\n    time_info->tm_mday = day;\n    time_info->tm_mon = month;\n    time_info->tm_year = year - YEARS_FROM_1900_TO_1970;\n    time_info->tm_wday = day_of_week;\n    time_info->tm_yday = calculate_day_of_year(month, day, num_leap_years);\n    time_info->tm_isdst = 0;\n    return time_info;\n}",
            "called": [
                "__aeabi_ldivmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000443c",
            "calling": [
                "rtc_get_alarm",
                "rtc_get_time"
            ],
            "imported": false,
            "current_name": "convert_time_to_tm_0000443c"
        },
        "FUN_000027b0": {
            "renaming": {
                "FUN_000027b0": "initialize_RTC_000027b0",
                "puVar1": "RTC_registers"
            },
            "code": "void initialize_RTC_000027b0(void)\n{\n  uint32_t *RTC_registers = RTC_REGISTER_BASE;\n  RTC_registers[0x40F] |= 0x20000000;\n  RTC_registers[4] = 1;\n  RTC_registers[4] = 0;\n  if ((RTC_registers[5] & 1) != 0) {\n    *RTC_registers = 0;\n  }\n  RTC_registers[4] = 0x104;\n  RTC_registers[2] = 0xffffff42;\n  RTC_registers[7] = 0;\n  rtt_poweron();\n  return;\n}",
            "called": [
                "rtt_poweron"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000027b0",
            "calling": [
                "rtc_init"
            ],
            "imported": false,
            "current_name": "initialize_RTC_000027b0"
        },
        "FUN_00005ebc": {
            "renaming": {
                "FUN_00005ebc": "copyString_00005ebc",
                "__dest": "destination",
                "__src": "source",
                "cVar1": "currentCharacter",
                "pcVar2": "destinationPointer"
            },
            "code": "char* copyString_00005ebc(char* destination, char* source) {\n  char currentCharacter;\n  char* destinationPointer = destination;\n  do {\n    currentCharacter = *source;\n    *destinationPointer = currentCharacter;\n    source++;\n    destinationPointer++;\n  } while (currentCharacter != '\\0');\n  return destination;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ebc",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "copyString_00005ebc"
        },
        "FUN_00006192": {
            "renaming": {
                "FUN_00006192": "reset_data_00006192",
                "param_1": "val",
                "param_2": "data",
                "param_2[0xd]": "data[13]",
                "(undefined4 *)0x0": "NULL",
                "param_2 + 0x11": "data + 17",
                "param_2[1]": "data[1]",
                "param_2[0x10]": "data[16]",
                "param_2[0xf]": "data[15]",
                "*param_2": "*data",
                "*param_2 = param_2[4]": "*data = data[4]",
                "*(ushort *)(param_2 + 3)": "*(unsigned short *)(data + 3)"
            },
            "code": "int reset_data_00006192(int val, int *data)\n{\n    int *end_data = (int *)data[13];\n    if (end_data != NULL && end_data != data + 17)\n    {\n        free(end_data);\n    }\n    data[1] = data[16];\n    data[13] = NULL;\n    if (data[16] != 0)\n    {\n        *data = data[15];\n        return 0;\n    }\n    *data = data[4];\n    data[1] = 0;\n    *(unsigned short *)(data + 3) |= 0x20;\n    return -1;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006192",
            "calling": [
                "__ssvfiscanf_r"
            ],
            "imported": false,
            "current_name": "reset_data_00006192"
        },
        "FUN_00001734": {
            "renaming": {
                "FUN_00001734": "clear_bit_at_position_six_in_eighth_byte_of_data_00001734",
                "DAT_00001744": "data_array"
            },
            "code": "void clear_bit_at_position_six_in_eighth_byte_of_data_00001734(void)\n{\n    bit_clear8(DAT_00001744[7], 0x06);\n    return;\n}",
            "called": [
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001734",
            "calling": [
                "kinetis_mcg_set_blpe",
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_blpi"
            ],
            "imported": false,
            "current_name": "clear_bit_at_position_six_in_eighth_byte_of_data_00001734"
        },
        "FUN_00000e14": {
            "renaming": {
                "FUN_00000e14": "read_from_uart_isrpipe_00000e14",
                "buffer": "buffer",
                "count": "count",
                "PTR_uart_stdio_isrpipe_00000e34": "uart_isrpipe",
                "iVar1": "num_bytes_read"
            },
            "code": "int read_from_uart_isrpipe_00000e14(isrpipe_t *PTR_uart_stdio_isrpipe_00000e34, char *buffer, int count)\n{\n  int num_bytes_read = isrpipe_read(PTR_uart_stdio_isrpipe_00000e34, buffer, count);\n  return num_bytes_read;\n}",
            "called": [
                "isrpipe_read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e14",
            "calling": [
                "_read_r"
            ],
            "imported": false,
            "current_name": "read_from_uart_isrpipe_00000e14"
        },
        "FUN_0000281c": {
            "renaming": {
                "FUN_0000281c": "get_RTC_value_0000281c",
                "rtt": "rtc_pointer",
                "i": "loop_counter",
                "t": "rtc_value"
            },
            "code": "uint32_t get_RTC_value_0000281c(void)\n{\n  RTC_Type *rtc_pointer;\n  int i = 0;\n  uint32_t rtc_value;\n  \n  while (i < 3 && (rtc_value = *DAT_00002858) != *DAT_00002858)\n  {\n    i++;\n  }\n  return rtc_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000281c",
            "calling": [
                "rtc_get_time"
            ],
            "imported": false,
            "current_name": "get_RTC_value_0000281c"
        },
        "FUN_00002270": {
            "renaming": {
                "FUN_00002270": "get_writes_count_00002270",
                "rb": "ring_buffer",
                "uVar2": "writes_count",
                "bVar3": "is_reads_count_equal_to_writes_count",
                "bVar1": "result"
            },
            "code": "uint32_t get_writes_count_00002270(tsrb_t *ring_buffer)\n{\n  uint32_t writes_count = ring_buffer->writes;\n  bool is_reads_count_equal_to_writes_count = (ring_buffer->reads == writes_count);\n  if (is_reads_count_equal_to_writes_count) {\n    writes_count = 1;\n  }\n  uint8_t result = (uint8_t)writes_count;\n  if (!is_reads_count_equal_to_writes_count) {\n    result = 0;\n  }\n  return (uint32_t)result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002270",
            "calling": [
                "tsrb_get"
            ],
            "imported": false,
            "current_name": "get_writes_count_00002270"
        },
        "FUN_00005780": {
            "renaming": {
                "FUN_00005780": "process_data_00005780",
                "__ptr": "data_ptr",
                "_FUN_00005780_r": "call_data_processing_function"
            },
            "code": "void process_data_00005780(void *data_ptr)\n{\n  call_data_processing_function(*(undefined4 *)PTR__impure_ptr_0000578c, data_ptr);\n  return;\n}",
            "called": [
                "_free_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005780",
            "calling": [
                "_tzset_unlocked_r"
            ],
            "imported": false,
            "current_name": "process_data_00005780"
        },
        "FUN_000020cc": {
            "renaming": {
                "FUN_000020cc": "handle_interrupt_000020cc",
                "DAT_000020dc": "data_ptr"
            },
            "code": "void handle_interrupt_000020cc(void)\n{\n    irq_handler(DAT_000020dc, 1);\n    return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020cc",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_000020cc"
        },
        "FUN_00002396": {
            "renaming": {
                "FUN_00002396": "initialize_real_time_clock_00002396"
            },
            "code": "void initialize_real_time_clock_00002396(void)\n{\n  rtc_init();\n  return;\n}",
            "called": [
                "rtc_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002396",
            "calling": [
                "cpu_init"
            ],
            "imported": false,
            "current_name": "initialize_real_time_clock_00002396"
        },
        "FUN_00004e4a": {
            "renaming": {
                "FUN_00004e4a": "close_file_00004e4a",
                "param_1": "reent",
                "param_2": "file_descriptor"
            },
            "code": "void close_file_00004e4a(_reent *reent, int file_descriptor) {\n    _close_r(reent, (int)*(short *)(file_descriptor + 0xe));\n    return;\n}",
            "called": [
                "_close_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e4a",
            "calling": [],
            "imported": false,
            "current_name": "close_file_00004e4a"
        },
        "FUN_00004cb4": {
            "renaming": {
                "FUN_00004cb4": "output_char_00004cb4",
                "__c": "character",
                "iVar1": "impure_ptr",
                "in_r3": "in_r3"
            },
            "code": "int output_char_00004cb4(int character) {\n  int impure_ptr = *(int *)PTR__impure_ptr_00004cd8;\n  if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n    __sinit(impure_ptr);\n  }\n  int result = _putc_r(impure_ptr, character, *(undefined4 *)(impure_ptr + 8), in_r3);\n  return result;\n}",
            "called": [
                "_putc_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cb4",
            "calling": [
                "_putchar"
            ],
            "imported": false,
            "current_name": "output_char_00004cb4"
        },
        "FUN_00003478": {
            "renaming": {
                "FUN_00003478": "set_rtc_time_00003478",
                "argv": "time_input",
                "iVar1": "time_parse_result",
                "now": "parsed_time",
                "PTR_s_rtc__error_setting_time_000034bc": "PTR_s_rtc__error_setting_time_000034bc"
            },
            "code": "int set_rtc_time_00003478(char **time_input)\n{\n    int time_parse_result;\n    tm parsed_time;\n    \n    time_parse_result = parse_time_input(time_input, &parsed_time);\n    if (time_parse_result == 0) {\n        int rtc_set_result = rtc_set_time(&parsed_time);\n        if (rtc_set_result == -1) {\n            puts(PTR_s_rtc__error_setting_time_000034bc);\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    else {\n        return 1;\n    }\n}",
            "called": [
                "rtc_set_time",
                "_parse_time",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003478",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "set_rtc_time_00003478"
        },
        "FUN_00002028": {
            "renaming": {
                "FUN_00002028": "handle_interrupts_00002028",
                "port_num": "port_number",
                "iVar1": "context_index",
                "uVar2": "interrupt_status",
                "status": "pin_status",
                "ctx": "context_index",
                "i": "loop_index"
            },
            "code": "void handle_interrupts_00002028(PORT_Type *port, int port_number) {\n  int context_index;\n  uint32_t interrupt_status;\n  uint32_t pin_status;\n\n  interrupt_status = port->ISFR;\n  for (int i = 0; i < 32; i++) {\n    pin_status = (interrupt_status & (1 << i));\n    if (pin_status != 0 && (port->PCR[i] & 0xf0000) != 0) {\n      port->ISFR = (1 << i);\n      context_index = get_context_index(port_number, i);\n      (**(code **)(isr_context_pointer + context_index * 0xc))(*(undefined4 *)(isr_context_pointer + context_index * 0xc + 4));\n    }\n  }\n  end_interrupt();\n}\n",
            "called": [
                "cortexm_isr_end",
                "get_ctx"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002028",
            "calling": [
                "isr_porte",
                "isr_portd",
                "isr_portb",
                "isr_portc",
                "isr_porta"
            ],
            "imported": false,
            "current_name": "handle_interrupts_00002028"
        },
        "FUN_000016c8": {
            "renaming": {
                "FUN_000016c8": "set_bit_in_uint32_000016c8",
                "ptr": "data",
                "bit": "bit_position",
                "puVar1": "bitband_address"
            },
            "code": "void set_bit_in_uint32_000016c8(uint32_t *data, uint8_t bit_position)\n{\n  uint32_t *bitband_address = (uint32_t *)bitband_addr(data, (uint)bit_position);\n  *bitband_address = 1;\n  return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016c8",
            "calling": [
                "kinetis_mcg_init_erclk32k"
            ],
            "imported": false,
            "current_name": "set_bit_in_uint32_000016c8"
        },
        "FUN_00001a60": {
            "renaming": {
                "FUN_00001a60": "set_mode_to_six_00001a60",
                "DAT_00001ac4": "data_register_1",
                "DAT_00001ac8": "data_register_2",
                "DAT_00001acc": "data_register_3",
                "PTR_current_mode_00001ad0": "current_mode_pointer"
            },
            "code": "void set_mode_to_six_00001a60(void)\n{\n    clear_bit(DAT_00001ac4, 0x01);\n    *DAT_00001ac8 = (*DAT_00001ac8 & 0x3f) | 0x80;\n    while((DAT_00001ac8[6] & 0xc) != 8);\n    set_bit(DAT_00001acc, 0x06);\n    while((DAT_00001ac8[6] & 0x20) == 0);\n    while((DAT_00001ac8[6] & 0x40) == 0);\n    *PTR_current_mode_00001ad0 = 6;\n    return;\n}",
            "called": [
                "bit_set8",
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a60",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "set_mode_to_six_00001a60"
        },
        "FUN_000004b2": {
            "renaming": {
                "FUN_000004b2": "write_to_uart_000004b2",
                "r": "reent_ptr",
                "fd": "file_descriptor",
                "data": "data",
                "count": "data_size",
                "iVar1": "write_count"
            },
            "code": "_ssize_t write_to_uart_000004b2(_reent *reent_ptr,int file_descriptor,void *data,size_t data_size){\n                    int write_count;\n                    write_count = uart_stdio_write((char *)data,data_size);\n                    return write_count;\n                  }",
            "called": [
                "uart_stdio_write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004b2",
            "calling": [
                "__swrite"
            ],
            "imported": false,
            "current_name": "write_to_uart_000004b2"
        },
        "FUN_0000099c": {
            "renaming": {
                "FUN_0000099c": "initialize_system_0000099c",
                "uStack_18": "stack_top",
                "top": "stack_top_ptr",
                "PTR__etext_00000a14": "etext",
                "pre_startup": "pre_startup",
                "PTR_isr_stack_00000a18": "isr_stack",
                "DAT_00000a1c": "default_isr_stack_value",
                "PTR_heap_top_00000a20": "heap_top",
                "PTR_sched_num_threads_00000a24": "sched_num_threads",
                "post_startup": "post_startup",
                "board_init": "board_initialize",
                "__libc_init_array": "initialize_standard_library",
                "kernel_init": "kernel_initialize"
            },
            "code": "void initialize_system_0000099c(void)\n{\n  uint32_t stack_top;\n  uint32_t *stack_top_ptr = &stack_top;\n  uint32_t *src = (uint32_t *)PTR__etext_00000a14;\n  uint32_t *dst = (uint32_t *)PTR_isr_stack_00000a18;\n  pre_startup();\n  while (dst < &stack_top) {\n    *dst = DAT_00000a1c;\n    dst++;\n  }\n  dst = (uint32_t *)PTR_heap_top_00000a20;\n  while (dst < PTR_sched_num_threads_00000a24) {\n    *dst = *src;\n    src++;\n    dst++;\n  }\n  dst = (uint32_t *)PTR_sched_num_threads_00000a24;\n  while (dst < sheap) {\n    *dst = 0;\n    dst++;\n  }\n  post_startup();\n  board_initialize();\n  initialize_standard_library();\n  kernel_initialize();\n  return;\n}",
            "called": [
                "pre_startup",
                "board_init",
                "post_startup",
                "kernel_init",
                "__libc_init_array"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000099c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_system_0000099c"
        },
        "FUN_00002d94": {
            "renaming": {
                "FUN_00002d94": "read_input_line_00002d94",
                "buf": "buffer",
                "size": "buffer_size",
                "c_00": "c",
                "line_buf_ptr": "buffer_ptr",
                "bVar1": "is_buffer_empty",
                "bVar2": "is_first_char_of_buffer"
            },
            "code": "int read_input_line_00002d94(char *buffer, size_t buffer_size)\n{\n  int c;\n  char *buffer_ptr;\n  bool is_buffer_empty;\n  bool is_first_char_of_buffer;\n\n  buffer_ptr = buffer;\n  while (true) {\n    if ((int)(buffer_size - 1) <= (int)buffer_ptr - (int)buffer) {\n      return -1;\n    }\n    c = getchar();\n    if (c < 0) break;\n    if ((c == 0xd) || (c == 10)) {\n      *buffer_ptr = '\\0';\n      _putchar(0xd);\n      _putchar(10);\n      is_buffer_empty = buffer_ptr == buffer;\n      if (is_buffer_empty) {\n        buffer = (char *)0x1;\n      }\n      return (uint)buffer;\n    }\n    if ((c == 8) || (c == 0x7f)) {\n      if (buffer_ptr != buffer) {\n        buffer_ptr = buffer_ptr + -1;\n        *buffer_ptr = '\\0';\n        _putchar(8);\n        _putchar(0x20);\n        _putchar(8);\n      }\n    }\n    else {\n      *buffer_ptr = (char)c;\n      _putchar(c);\n      buffer_ptr = buffer_ptr + 1;\n    }\n  }\n  return 1;\n}",
            "called": [
                "getchar",
                "_putchar"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002d94",
            "calling": [
                "shell_run"
            ],
            "imported": false,
            "current_name": "read_input_line_00002d94"
        },
        "FUN_00003918": {
            "renaming": {
                "FUN_00003918": "get_prefix_from_scale_00003918",
                "scale": "scale",
                "cVar1": "prefix",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "char get_prefix_from_scale_00003918(int8_t scale) {\n  char prefix;\n  switch(scale) {\n    case 2:\n      prefix = 'h';\n      break;\n    case 3:\n      prefix = 'k';\n      break;\n    case 6:\n      prefix = 'M';\n      break;\n    case 9:\n      prefix = 'G';\n      break;\n    case 12:\n      prefix = 'T';\n      break;\n    case 15:\n      prefix = 'P';\n      break;\n    case -15:\n      prefix = 'f';\n      break;\n    case -12:\n      prefix = 'p';\n      break;\n    case -9:\n      prefix = 'n';\n      break;\n    case -6:\n      prefix = 'u';\n      break;\n    case -3:\n      prefix = 'm';\n      break;\n    default:\n      prefix = '\\0';\n      break;\n  }\n  return prefix;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003918",
            "calling": [
                "phydat_dump"
            ],
            "imported": false,
            "current_name": "get_prefix_from_scale_00003918"
        },
        "FUN_00003d64": {
            "renaming": {
                "FUN_00003d64": "read_sensor_data_00003d64",
                "dev": "sensor",
                "res": "data",
                "iVar1": "error_code"
            },
            "code": "int read_sensor_data_00003d64(saul_reg_t *sensor, phydat_t *data)\n{\n  int error_code;\n  if (sensor == NULL) {\n    error_code = -19;\n  }\n  else {\n    error_code = (*sensor->driver->read)(sensor->dev, data);\n  }\n  return error_code;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d64",
            "calling": [
                "probe"
            ],
            "imported": false,
            "current_name": "read_sensor_data_00003d64"
        },
        "FUN_00004e52": {
            "renaming": {
                "FUN_00004e52": "compare_strings_00004e52",
                "__s1": "string1",
                "__s2": "string2",
                "bVar1": "current_char2",
                "uVar2": "current_char",
                "bVar3": "is_equal"
            },
            "code": "int compare_strings_00004e52(char *string1, char *string2) {\n  uint8_t current_char;\n  char current_char2;\n  bool is_equal;\n  do {\n    current_char = (uint8_t)*string1;\n    current_char2 = *string2;\n    is_equal = current_char == 1;\n    if (current_char != 0) {\n      is_equal = current_char == current_char2;\n    }\n    string1++;\n    string2++;\n  } while (is_equal);\n  return current_char - current_char2;\n}",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e52",
            "calling": [
                "_tzset_unlocked_r",
                "read",
                "find_handler",
                "strcmp",
                "_saul",
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "compare_strings_00004e52"
        },
        "FUN_000010d4": {
            "renaming": {
                "FUN_000010d4": "create_thread_000010d4",
                "stack": "stack_pointer",
                "stacksize": "stack_size",
                "priority": "priority",
                "flags": "flags",
                "function": "function",
                "arg": "arg",
                "name": "name",
                "state_00": "state",
                "pcVar1": "pc",
                "stack_size": "aligned_stack_size",
                "process": "thread",
                "local_30": "padding",
                "local_2c": "stack_aligned",
                "stackp": "stack_pointer",
                "i": "pid"
            },
            "code": "kernel_pid_t create_thread_000010d4(char *stack, int stack_size, char priority, int flags, thread_task_func_t function, void *arg, char *name)\\n{\\n    uint state;\\n    char *stack_aligned;\\n    uint aligned_stack_size;\\n    thread_t *thread;\\n    uintptr_t *stack_pointer;\\n    uintptr_t *stack_max;\\n    thread_t *current_thread;\\n    uintptr_t misalignment;\\n    int total_stack_size;\\n    kernel_pid_t pid = -1;\\n    if (priority >= 0x10) {\\n        return -0x16;\\n    }\\n    stack_aligned = stack;\\n    if (((uint)stack & 3) != 0) {\\n        int padding = 4 - ((uint)stack & 3);\\n        stack_aligned += padding;\\n        stack_size -= padding;\\n    }\\n    aligned_stack_size = stack_size - 0x30U & 0xfffffffc;\\n    thread = (thread_t *)(aligned_stack_size + (int)stack_aligned);\\n    if ((flags & 8U) == 0) {\\n        *stack_pointer = (uintptr_t)stack_pointer;\\n    } else {\\n        for (stack_pointer = (uintptr_t *)stack_aligned; stack_pointer < (uintptr_t *)(aligned_stack_size + (int)stack_aligned); stack_pointer++) {\\n            *stack_pointer = (uintptr_t)stack_pointer;\\n        }\\n    }\\n    state = irq_disable();\\n    for (pid = 1; pid < 0x21; pid++) {\\n        if (*(int *)(PTR_sched_threads_0000126c + pid * 4) == 0) {\\n            break;\\n        }\\n    }\\n    if (pid == 0x21) {\\n        irq_restore(state);\\n        return -0x8b;\\n    }\\n    *(thread_t **)(PTR_sched_threads_0000126c + pid * 4) = thread;\\n    thread->pid = pid;\\n    thread->sp = thread_stack_init(function, arg, stack_aligned, aligned_stack_size);\\n    thread->stack_start = stack_aligned;\\n    thread->stack_size = stack_size;\\n    thread->name = name;\\n    thread->priority = priority;\\n    thread->status = \"\\0\";\\n    thread->rq_entry.next = (list_node *)0x0;\\n    thread->wait_data = (void *)0x0;\\n    thread->msg_waiters.next = (list_node *)0x0;\\n    cib_init(&thread->msg_queue, 0);\\n    thread->msg_array = (msg_t *)0x0;\\n    *(int *)PTR_sched_num_threads_00001270 = *(int *)PTR_sched_num_threads_00001270 + 1;\\n    if ((flags & 1U) == 0) {\\n        sched_set_status(thread, 10);\\n        if ((flags & 4U) == 0) {\\n            irq_restore(state);\\n            sched_switch((ushort)(byte)priority);\\n            return pid;\\n        }\\n    } else {\\n        sched_set_status(thread, 1);\\n    }\\n    irq_restore(state);\\n    return pid;\\n}",
            "called": [
                "irq_disable",
                "thread_stack_init",
                "cib_init",
                "irq_restore",
                "sched_set_status",
                "sched_switch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010d4",
            "calling": [
                "kernel_init"
            ],
            "imported": false,
            "current_name": "create_thread_000010d4"
        },
        "FUN_000045e4": {
            "renaming": {
                "FUN_000045e4": "do_nothing_000045e4"
            },
            "code": "\nvoid do_nothing_000045e4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e4",
            "calling": [
                "__sfp"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e4"
        },
        "FUN_00000738": {
            "renaming": {
                "FUN_00000738": "check_thread_priority_00000738",
                "other_prio": "other_priority",
                "iVar1": "irq_flag",
                "current_prio": "current_priority",
                "active_thread": "active_thread",
                "on_runqueue": "on_runqueue"
            },
            "code": "void check_thread_priority_00000738(uint16_t other_priority) {\n  int irq_flag;\n  uint16_t current_priority;\n  thread_t *active_thread;\n  int on_runqueue;\n  \n  active_thread = *(thread_t **)PTR_sched_active_thread_0000078c;\n  current_priority = *(byte *)(active_thread + 4);\n  if (current_priority < 9 || other_priority < *(byte *)(active_thread + 5)) {\n    irq_flag = irq_is_in();\n    if (irq_flag == 0) {\n      thread_yield_higher();\n    }\n    else {\n      *(undefined4 *)PTR_sched_context_switch_request_00000790 = 1;\n    }\n  }\n}\n",
            "called": [
                "thread_yield_higher",
                "irq_is_in"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000738",
            "calling": [
                "thread_create",
                "mutex_unlock"
            ],
            "imported": false,
            "current_name": "check_thread_priority_00000738"
        },
        "FUN_000045e6": {
            "renaming": {
                "FUN_000045e6": "do_nothing_000045e6"
            },
            "code": "\nvoid do_nothing_000045e6(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e6",
            "calling": [
                "__tz_lock"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e6"
        },
        "FUN_00003e58": {
            "renaming": {
                "FUN_00003e58": "convert_integer_to_string_00003e58",
                "out": "output_string",
                "val": "input_integer",
                "local_18": "absolute_value",
                "local_14": "string_ptr",
                "negative": "is_negative",
                "sVar1": "string_length"
            },
            "code": "size_t convert_integer_to_string_00003e58(char *output_string, int32_t input_integer)\n{\n    size_t string_length = 0;\n    uint32_t absolute_value = input_integer;\n    char *string_ptr = output_string;\n    uint is_negative = 0;\n\n    if (input_integer < 0) {\n        if (output_string != NULL) {\n            *string_ptr = '-';\n            string_ptr++;\n        }\n        absolute_value = -input_integer;\n        is_negative = 1;\n    }\n\n    string_length = fmt_u32_dec(string_ptr, absolute_value);\n\n    if (is_negative) {\n        string_length++;\n    }\n\n    return string_length;\n}\n",
            "called": [
                "fmt_u32_dec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e58",
            "calling": [
                "fmt_s32_dfp"
            ],
            "imported": false,
            "current_name": "convert_integer_to_string_00003e58"
        },
        "FUN_00004e26": {
            "renaming": {
                "FUN_00004e26": "seek_and_set_offset_00004e26",
                "param_1": "reent",
                "param_2": "file_descriptor",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "new_offset",
                "uVar2": "flags",
                "bVar3": "seek_failed"
            },
            "code": "void seek_and_set_offset_00004e26(_reent *reent, int file_descriptor, _off_t offset, int whence) {\\n\\\n    _off_t new_offset = _lseek_r(reent, *(short *)(file_descriptor + 0xe), offset, whence);\\n\\\n    bool seek_failed = new_offset == -1;\\n\\\n    ushort flags = *(ushort *)(file_descriptor + 0xc);\\n\\\n    if (seek_failed) {\\n\\\n        flags &= 0xefff;\\n\\\n    }\\n\\\n    else {\\n\\\n        *(_off_t *)(file_descriptor + 0x54) = new_offset;\\n\\\n        flags |= 0x1000;\\n\\\n    }\\n\\\n    *(ushort *)(file_descriptor + 0xc) = flags;\\n\\\n}",
            "called": [
                "_lseek_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e26",
            "calling": [],
            "imported": false,
            "current_name": "seek_and_set_offset_00004e26"
        },
        "FUN_00000978": {
            "renaming": {
                "FUN_00000978": "executeActiveThread_00000978",
                "bVar1": "isPrivilegedMode",
                "UNRECOVERED_JUMPTABLE": "jumpTable",
                "ppcVar2": "processStackPointer",
                "PTR_sched_active_thread_0000098c": "activeThreadPointer"
            },
            "code": "void executeActiveThread_00000978(void)\n{\n  bool isPrivilegedMode = (bool)isCurrentModePrivileged();\n  code *jumpTable = *(code **)**(undefined4 **)PTR_sched_active_thread_0000098c;\n  code **processStackPointer = (code **)**(undefined4 **)PTR_sched_active_thread_0000098c + 9;\n  if (isPrivilegedMode) {\n    setProcessStackPointer(processStackPointer);\n  }\n  (*jumpTable)(jumpTable,processStackPointer);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000978",
            "calling": [],
            "imported": false,
            "current_name": "executeActiveThread_00000978"
        },
        "FUN_000045e8": {
            "renaming": {
                "FUN_000045e8": "do_nothing_000045e8"
            },
            "code": "\nvoid do_nothing_000045e8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e8",
            "calling": [
                "_puts_r",
                "__sinit_lock_acquire",
                "_fflush_r",
                "_vfprintf_r",
                "__sfp_lock_acquire",
                "_putc_r",
                "__malloc_lock",
                "__env_lock",
                "_getc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e8"
        },
        "FUN_000057f8": {
            "renaming": {
                "FUN_000057f8": "FUNC_000057f8"
            },
            "code": "\nint FUNC_000057f8(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  bool bVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  int iVar4;\n  int iVar5;\n  void *pvVar6;\n  int *piVar7;\n  byte *pbVar8;\n  int unaff_r7;\n  byte *pbVar9;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 uStack_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    __sinit();\n  }\n  if (param_2 == PTR___sf_fake_stdin_00005a38) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR___sf_fake_stdout_00005a3c) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR___sf_fake_stderr_00005a40) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n     (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n    __retarget_lock_acquire_recursive(*(undefined4 *)(param_2 + 0x58));\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar4 = __swsetup_r(param_1,param_2), iVar4 != 0)) {\n    if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n       (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n      __retarget_lock_release_recursive(*(undefined4 *)(param_2 + 0x58));\n    }\n    return -1;\n  }\n  puVar2 = PTR_s___0__00005a44;\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar9 = param_3;\n  local_8c = param_4;\nLAB_0000588e:\n  pbVar8 = pbVar9;\n  if (*pbVar8 != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  pbVar9 = pbVar8 + 1;\n  if (*pbVar8 != 0x25) goto LAB_0000588e;\nLAB_0000589a:\n  iVar4 = (int)pbVar8 - (int)param_3;\n  if (iVar4 != 0) {\n    iVar5 = __sfputs_r(param_1,param_2,param_3,iVar4);\n    if (iVar5 == -1) {\nLAB_00005a06:\n      if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n         (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n        __retarget_lock_release_recursive(*(undefined4 *)(param_2 + 0x58));\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar4;\n  }\n  if (*pbVar8 == 0) goto LAB_00005a06;\n  local_84 = -1;\n  uStack_80 = 0;\n  local_88 = 0;\n  local_7c = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar9 = pbVar8 + 1;\n  while( true ) {\n    pbVar8 = pbVar9 + 1;\n    pvVar6 = memchr(PTR_s___0__00005a44,(uint)*pbVar9,5);\n    puVar3 = PTR_DAT_00005a54;\n    if (pvVar6 == (void *)0x0) break;\n    local_88 = 1 << ((int)pvVar6 - (int)puVar2 & 0xffU) | local_88;\n    pbVar9 = pbVar8;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar9 == 0x2a) {\n    piVar7 = local_8c + 1;\n    local_7c = *local_8c;\n    local_8c = piVar7;\n    if (local_7c < 0) {\n      local_7c = -local_7c;\n      local_88 = local_88 | 2;\n    }\n  }\n  else {\n    bVar1 = false;\n    iVar4 = local_7c;\n    pbVar8 = pbVar9;\n    while( true ) {\n      if (9 < *pbVar8 - 0x30) break;\n      iVar4 = iVar4 * 10 + (*pbVar8 - 0x30);\n      bVar1 = true;\n      pbVar8 = pbVar8 + 1;\n    }\n    if (bVar1) {\n      local_7c = iVar4;\n    }\n  }\n  if (*pbVar8 == 0x2e) {\n    if (pbVar8[1] == 0x2a) {\n      local_84 = *local_8c;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n      pbVar8 = pbVar8 + 2;\n      local_8c = local_8c + 1;\n    }\n    else {\n      bVar1 = false;\n      local_84 = 0;\n      iVar4 = 0;\n      while( true ) {\n        pbVar8 = pbVar8 + 1;\n        if (9 < *pbVar8 - 0x30) break;\n        iVar4 = iVar4 * 10 + (*pbVar8 - 0x30);\n        bVar1 = true;\n      }\n      if (bVar1) {\n        local_84 = iVar4;\n      }\n    }\n  }\n  pvVar6 = memchr(PTR_DAT_00005a54,(uint)*pbVar8,3);\n  if (pvVar6 != (void *)0x0) {\n    local_88 = local_88 | 0x40 << ((int)pvVar6 - (int)puVar3 & 0xffU);\n    pbVar8 = pbVar8 + 1;\n  }\n  param_3 = pbVar8 + 1;\n  local_70 = *pbVar8;\n  pvVar6 = memchr(PTR_s_efgEFG_00005a48,(uint)local_70,6);\n  if (pvVar6 == (void *)0x0) {\n    iVar4 = _printf_i(param_1,&local_88,param_2,DAT_00005a50,&local_8c);\n  }\n  else {\n    iVar4 = param_1;\n    if (DAT_00005a4c == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar4 = unaff_r7;\n      goto LAB_000059b4;\n    }\n  }\n  if (iVar4 == -1) goto LAB_00005a06;\nLAB_000059b4:\n  local_74 = local_74 + iVar4;\n  pbVar9 = param_3;\n  unaff_r7 = iVar4;\n  goto LAB_0000588e;\n}\n\n",
            "called": [
                "__sfputs_r",
                "__retarget_lock_acquire_recursive",
                "__swsetup_r",
                "memchr",
                "__retarget_lock_release_recursive",
                "_printf_i",
                "__sinit"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000057f8",
            "calling": [
                "iprintf"
            ],
            "imported": false,
            "current_name": "FUNC_000057f8"
        },
        "FUN_000018bc": {
            "renaming": {
                "FUN_000018bc": "initialize_system_clock_000018bc",
                "DAT_00001910": "GPIOC_PDOR",
                "DAT_00001914": "GPIOC_PSOR",
                "PTR_current_mode_00001918": "current_mode",
                "kinetis_mcg_set_fll_factor": "set_fll_factor",
                "KINETIS_MCG_FLL_FACTOR_1464": "FLL_FACTOR_1464",
                "bit_clear8": "clear_bit8"
            },
            "code": "void initialize_system_clock_000018bc(void)\n{\n  set_fll_factor(KINETIS_MCG_FLL_FACTOR_1464);\n  *DAT_00001910 = (*DAT_00001910 & 0x3b) | 4;\n  clear_bit8(DAT_00001910, 0x01);\n  while ((GPIOC_PDIR[6] & 0x10) == 0);\n  while ((GPIOC_PDIR[6] & 0xc) != 0);\n  *PTR_current_mode_00001918 = 0;\n  return;\n}",
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000018bc",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "initialize_system_clock_000018bc"
        },
        "FUN_00000974": {
            "renaming": {
                "FUN_00000974": "run_active_thread_00000974",
                "PTR_sched_active_thread_0000098c": "sched_active_thread_ptr",
                "isCurrentModePrivileged": "is_current_mode_privileged",
                "setProcessStackPointer": "set_process_stack_pointer",
                "bool bVar1": "bool is_privileged_mode",
                "code *UNRECOVERED_JUMPTABLE": "code *active_thread_function_ptr",
                "code **ppcVar2": "code **active_thread_stack_ptr"
            },
            "code": "void run_active_thread_00000974() {\n  bool is_privileged_mode;\n  code *active_thread_function_ptr;\n  code **active_thread_stack_ptr;\n  sched_run();\n  active_thread_function_ptr = *(code **)**(undefined4 **)PTR_sched_active_thread_0000098c;\n  active_thread_stack_ptr = (code **)**(undefined4 **)PTR_sched_active_thread_0000098c + 9;\n  is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    setProcessStackPointer(active_thread_stack_ptr);\n  }\n  (*active_thread_function_ptr)(active_thread_function_ptr, active_thread_stack_ptr);\n  return;\n}",
            "called": [
                "sched_run"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000974",
            "calling": [
                "isr_pendsv"
            ],
            "imported": false,
            "current_name": "run_active_thread_00000974"
        },
        "FUN_00000f04": {
            "renaming": {
                "FUN_00000f04": "kernel_panic_00000f04",
                "crash_code": "crash_type",
                "local_10": "panic_message",
                "local_9": "panic_type",
                "PTR_crashed_00000f4c": "crashed_flag",
                "PANIC_ASSERT_FAIL": "PANIC_ASSERT_FAIL",
                "cpu_print_last_instruction": "cpu_print_last_instruction",
                "iprintf": "iprintf",
                "ps": "ps",
                "PTR_DAT_00000f54": "PTR_DAT_00000f54",
                "irq_disable": "irq_disable",
                "panic_arch": "panic_arch",
                "uStack_14": "uStack_14",
                "pm_off": "pm_off",
                "uStack_18": "uStack_18",
                "auto_init": "auto_init",
                "PTR_s_____RIOT_kernel_panic___s_00000f50": "PTR_s_____RIOT_kernel_panic___s_00000f50",
                "PTR_s_____halted__00000f58": "PTR_s_____halted__00000f58",
                "main": "main"
            },
            "code": "void kernel_panic_00000f04(kernel_panic_00000f04_t crash_type, char *message)\n{\n    int *PTR_crashed_00000f4c = (int *)PTR_crashed_00000f4c;\n    char *panic_message = message;\n    kernel_panic_00000f04_t panic_type = crash_type;\n\n    if (*PTR_crashed_00000f4c == 0) {\n        *PTR_crashed_00000f4c = 1;\n        if (panic_type == PANIC_ASSERT_FAIL) {\n            cpu_print_last_instruction();\n        }\n        iprintf(PTR_s_____RIOT_kernel_panic_00000f04___s_00000f50, panic_message);\n        ps();\n        iprintf(PTR_DAT_00000f54);\n        iprintf(PTR_s_____halted__00000f58);\n    }\n\n    irq_disable();\n    panic_arch();\n    int uStack_14 = 0xf4d;\n    pm_off();\n    int uStack_18 = (int)&uStack_18 + 1;\n    auto_init();\n    iprintf(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n    main();\n    return;\n}",
            "called": [
                "irq_disable",
                "ps",
                "iprintf",
                "pm_off",
                "panic_arch",
                "cpu_print_last_instruction"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f04",
            "calling": [
                "thread_add_to_list",
                "bus_fault_default",
                "cib_init",
                "fmt_s32_dfp",
                "uart_init",
                "mem_manage_default",
                "debug_mon_default",
                "hard_fault_handler",
                "dummy_handler_default",
                "nmi_default",
                "usage_fault_default"
            ],
            "imported": false,
            "current_name": "kernel_panic_00000f04"
        },
        "FUN_00000610": {
            "renaming": {
                "FUN_00000610": "schedule_next_thread_00000610",
                "uVar1": "bit_cache_lsb",
                "iVar2": "active_thread_id",
                "iVar3": "next_thread_id",
                "active_thread": "active_thread",
                "nextrq": "next_rq",
                "__m____": "unused_node",
                "next_thread": "next_thread"
            },
            "code": "int schedule_next_thread_00000610(void)\n{\n  uint32_t bit_cache_lsb;\n  int active_thread_id;\n  int next_thread_id;\n  thread_t *active_thread;\n  clist_node_t *next_rq;\n  thread_t *next_thread;\n  // Clear the context switch request\n  *(uint32_t *)PTR_sched_context_switch_request_00000684 = 0;\n  active_thread_id = *(int *)PTR_sched_active_thread_00000688;\n  bit_cache_lsb = bitarithm_lsb(*(uint32_t *)PTR_runqueue_bitcache_0000068c);\n  next_rq = *(clist_node_t **)(PTR_schedule_next_thread_00000610queues_00000690 + bit_cache_lsb * 4);\n  next_thread_id = **(int **)(next_rq + 4);\n  // If the active thread is the next thread, no need to switch\n  if (active_thread_id == next_thread_id - THREAD_STRUCT_OFFSET) {\n    return 0;\n  }\n  // If active thread is not null and has '\t' priority, set it to '\n'\n  if ((active_thread_id != 0) && (*(char *)(active_thread_id + THREAD_PRIORITY_OFFSET) == '\t')) {\n    *(char *)(active_thread_id + THREAD_PRIORITY_OFFSET) = '\n';\n  }\n  // Set the priority of the next thread to '\t'\n  *(char *)(next_thread_id + THREAD_PRIORITY_OFFSET) = '\t';\n  // Update the active thread and pid\n  *(uint16_t *)PTR_sched_active_pid_00000694 = *(uint16_t *)(next_thread_id + THREAD_PID_OFFSET);\n  *(int *)PTR_sched_active_thread_00000688 = next_thread_id - THREAD_STRUCT_OFFSET;\n  return 1;\n}",
            "called": [
                "bitarithm_lsb"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000610",
            "calling": [
                "isr_svc"
            ],
            "imported": false,
            "current_name": "schedule_next_thread_00000610"
        },
        "FUN_00003694": {
            "renaming": {
                "FUN_00003694": "display_sensor_data_00003694",
                "data": "sensor_data",
                "dim": "dimensions",
                "sVar1": "size",
                "pcVar2": "unit_str",
                "cVar3": "unit_prefix",
                "uVar4": "unit_bitmask",
                "bVar5": "is_bit_set",
                "num": "num_buffer",
                "len": "size",
                "i": "i"
            },
            "code": "void display_sensor_data_00003694(phydat_t *sensor_data, uint8_t dimensions)\n{\n    size_t size;\n    char *unit_str;\n    char unit_prefix;\n    uint8_t i;\n\n    if ((sensor_data == NULL) || (dimensions > 3)) {\n        puts(error_messages[0]);\n    }\n    else {\n        iprintf(\"Data:\\n\");\n        for (i = 0; i < dimensions; i++) {\n            if (sensor_data->unit < 20) {\n                bool is_bit_set = (unit_bitmask & (1 << sensor_data->unit));\n                unit_prefix = (is_bit_set) ? ' ' : 0;\n            }\n            else {\n                unit_prefix = phydat_prefix_from_scale(sensor_data->scale);\n            }\n            iprintf(\"    [%u]: \", i);\n            if (dimensions < 2) {\n                iprintf(\"%d\", sensor_data->val[i]);\n            }\n            else {\n                iprintf(\"%d \", sensor_data->val[i]);\n            }\n            if (unit_prefix == 0) {\n                if (sensor_data->scale == 0) {\n                    iprintf(\"%d\", sensor_data->val[i]);\n                }\n                else if (sensor_data->scale < 0 && (sensor_data->scale + 4 < 0)) {\n                    size = fmt_s16_dfp(num_buffer, sensor_data->val[i], (int)sensor_data->scale);\n                    num_buffer[size] = 0;\n                    iprintf(\"%s\", num_buffer);\n                }\n                else {\n                    iprintf(\"%dE%d\", sensor_data->val[i], (int)sensor_data->scale);\n                }\n            }\n            else {\n                iprintf(\"%d%c\", sensor_data->val[i], unit_prefix);\n            }\n            unit_str = phydat_unit_to_str(sensor_data->unit);\n            iprintf(\" %s\\n\", unit_str);\n        }\n    }\n}\n",
            "called": [
                "fmt_s16_dfp",
                "phydat_unit_to_str",
                "phydat_prefix_from_scale",
                "iprintf",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003694",
            "calling": [
                "write",
                "probe"
            ],
            "imported": false,
            "current_name": "display_sensor_data_00003694"
        },
        "FUN_00002364": {
            "renaming": {
                "FUN_00002364": "is_ring_buffer_full_00002364",
                "rb": "ring_buffer",
                "c": "data",
                "iVar1": "is_full",
                "_push": "push_to_ring_buffer"
            },
            "code": "int is_ring_buffer_full_00002364(tsrb_t *ring_buffer, char data) {\n  int is_full = tsrb_full(ring_buffer);\n  if (is_full == 0) {\n    push_to_ring_buffer(ring_buffer, data);\n    is_full = 0;\n  }\n  else {\n    is_full = -1;\n  }\n  return is_full;\n}",
            "called": [
                "tsrb_full",
                "_push"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002364",
            "calling": [
                "isrpipe_write_one"
            ],
            "imported": false,
            "current_name": "is_ring_buffer_full_00002364"
        },
        "FUN_00001ad4": {
            "renaming": {
                "FUN_00001ad4": "reset_data_00001ad4",
                "DAT_00001b08": "data",
                "PTR_current_mode_00001b0c": "current_mode"
            },
            "code": "void reset_data_00001ad4(void)\n{\n  int* DAT_00001b08 = DAT_00001b08;\n  *DAT_00001b08 &= 0x3f;\n  while ((DAT_00001b08[6] & 0xc) != 0xc);\n  int* PTR_current_mode_00001b0c = PTR_PTR_current_mode_00001b0c_00001b0c;\n  *PTR_current_mode_00001b0c = 7;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ad4",
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "imported": false,
            "current_name": "reset_data_00001ad4"
        },
        "FUN_00001274": {
            "renaming": {
                "FUN_00001274": "initialize_system_00001274",
                "DAT_00001298": "PTR_data_register",
                "PTR_DAT_00001298": "PTR_data_register",
                "cortexm_init": "initialize_cortexm",
                "kinetis_mcg_init": "initialize_kinetis_mcg",
                "periph_init": "initialize_peripherals"
            },
            "code": "void initialize_system_00001274(void)\n{\n  initialize_cortexm();\n  *PTR_DAT_00001298 = *PTR_DAT_00001298 | 0x28;\n  initialize_kinetis_mcg();\n  initialize_peripherals();\n  return;\n}",
            "called": [
                "cortexm_init",
                "kinetis_mcg_init",
                "periph_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001274",
            "calling": [
                "board_init"
            ],
            "imported": false,
            "current_name": "initialize_system_00001274"
        },
        "FUN_00002e6c": {
            "renaming": {
                "FUN_00002e6c": "read_shell_command_00002e6c",
                "shell_commands": "commands",
                "line_buf": "input_buffer",
                "len": "buffer_len",
                "iVar1": "read_result",
                "res": "handle_result",
                "print_prompt": "print_shell_prompt",
                "readline": "read_input_line",
                "handle_input_line": "handle_input_line"
            },
            "code": "void read_shell_command_00002e6c(shell_command_t *commands, char *input_buffer, int buffer_len)\n{\n  int read_result;\n  int handle_result;\n  print_shell_prompt();\n  do {\n    read_result = read_input_line(input_buffer, buffer_len);\n    if (read_result == 0) {\n      handle_result = handle_input_line(commands, input_buffer);\n    }\n    print_shell_prompt();\n  } while(true);\n}",
            "called": [
                "readline",
                "print_prompt",
                "handle_input_line"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e6c",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "read_shell_command_00002e6c"
        },
        "FUN_00003444": {
            "renaming": {
                "FUN_00003444": "get_rtc_time_error_00003444",
                "iVar1": "error_code",
                "t": "current_time",
                "_print_time": "print_current_time"
            },
            "code": "int get_rtc_time_error_00003444(void)\n{\n  int error_code;\n  tm current_time;\n\n  error_code = rtc_get_time(&current_time);\n  if (error_code != 0) {\n    puts(PTR_s_rtc__error_getting_time_00003474);\n  }\n  else {\n    print_current_time(&current_time);\n  }\n  return (uint)(error_code != 0);\n}",
            "called": [
                "_print_time",
                "rtc_get_time",
                "puts"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003444",
            "calling": [
                "_rtc_handler"
            ],
            "imported": false,
            "current_name": "get_rtc_time_error_00003444"
        },
        "FUN_00003688": {
            "renaming": {
                "FUN_00003688": "reset_system_00003688"
            },
            "code": "void reset_system_00003688(void)\n{\n  NVIC_SystemReset();\n  return;\n}",
            "called": [
                "NVIC_SystemReset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003688",
            "calling": [
                "_reboot_handler"
            ],
            "imported": false,
            "current_name": "reset_system_00003688"
        },
        "FUN_00001392": {
            "renaming": {
                "FUN_00001392": "set_bit_00001392",
                "ptr": "ptr",
                "bit": "bit",
                "puVar1": "bit_addr"
            },
            "code": "void set_bit_00001392(uint32_t *ptr, uint8_t bit)\n{\n    uint32_t *bit_addr = (uint32_t *)bitband_addr(ptr, (uint)bit);\n    *bit_addr = 1;\n    return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001392",
            "calling": [
                "uart_init"
            ],
            "imported": false,
            "current_name": "set_bit_00001392"
        },
        "FUN_00002910": {
            "renaming": {
                "FUN_00002910": "clear_rtc_callback_00002910",
                "iVar1": "data_address",
                "rtt": "N/A",
                "DAT_00002944": "data_address_global_var",
                "PTR_rtt_callback_00002948": "rtc_callback_pointer"
            },
            "code": "void clear_rtc_callback_00002910(void)\n{\n  int data_address = DAT_00002944;\n  *(uint *)(data_address + 0x1c) = *(uint *)(data_address + 0x1c) & 0xfffffffb;\n  *(undefined4 *)(data_address + 8) = 0;\n  *(undefined4 *)PTR_rtt_callback_00002948 = 0;\n  *(undefined4 *)(PTR_rtt_callback_00002948 + 4) = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002910",
            "calling": [
                "rtc_clear_alarm"
            ],
            "imported": false,
            "current_name": "clear_rtc_callback_00002910"
        },
        "FUN_00004418": {
            "renaming": {
                "FUN_00004418": "read_char_from_stdin_00004418",
                "iVar1": "impure_ptr",
                "_getc_r": "get_char_from_stdin",
                "PTR__impure_ptr_00004438": "PTR_impure_ptr",
                "__sinit": "initialize_stdio",
                "c": "read_char"
            },
            "code": "int read_char_from_stdin_00004418(void)\n{\n  int impure_ptr = *(int *)PTR__impure_ptr_00004438;\n  if ((impure_ptr != 0) && (*(int *)(impure_ptr + 0x18) == 0)) {\n    __sinit(impure_ptr);\n  }\n  int c = _getc_r(impure_ptr,*(undefined4 *)(impure_ptr + 4));\n  return c;\n}",
            "called": [
                "__sinit",
                "_getc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004418",
            "calling": [
                "readline"
            ],
            "imported": false,
            "current_name": "read_char_from_stdin_00004418"
        },
        "FUN_0000258c": {
            "renaming": {
                "FUN_0000258c": "initialize_interrupt_priorities_0000258c",
                "i": "index",
                "DAT_000025ec": "data_address",
                "DAT_000025f0": "data_value"
            },
            "code": "void initialize_interrupt_priorities_0000258c(void)\n{\n  uint32_t i;\n  *(uint32_t *)(DAT_000025ec + 8) = DAT_000025f0;\n  NVIC_SetPriority(PendSV_IRQn,1);\n  NVIC_SetPriority(SVCall_IRQn,1);\n  for (i = 0; i < 0x66; i++) {\n    NVIC_SetPriority((IRQn_Type)i,1);\n  }\n  *(uint32_t *)(DAT_000025ec + 0x10) |= 0x10;\n  *(uint32_t *)(DAT_000025ec + 0x14) |= 0x200;\n  return;\n}",
            "called": [
                "NVIC_SetPriority"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000258c",
            "calling": [
                "cpu_init"
            ],
            "imported": false,
            "current_name": "initialize_interrupt_priorities_0000258c"
        },
        "FUN_00002a00": {
            "renaming": {
                "FUN_00002a00": "print_character_00002a00",
                "c": "character"
            },
            "code": "void print_character_00002a00(int character)\n{\n  putchar(character);\n  return;\n}",
            "called": [
                "putchar"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a00",
            "calling": [
                "readline",
                "print_prompt"
            ],
            "imported": false,
            "current_name": "print_character_00002a00"
        },
        "FUN_00000a64": {
            "renaming": {
                "FUN_00000a64": "execute_hard_fault_handler_00000a64",
                "sp": "stack_pointer",
                "corrupted": "is_corrupted",
                "unaff_r4": "unaff_r4",
                "unaff_r5": "unaff_r5",
                "unaff_r6": "unaff_r6",
                "unaff_r7": "unaff_r7",
                "unaff_r8": "unaff_r8",
                "unaff_r9": "unaff_r9",
                "unaff_r10": "unaff_r10",
                "unaff_r11": "unaff_r11",
                "in_lr": "in_lr",
                "PTR__eram_00000aa0": "PTR__eram_00000aa0",
                "&stack0x00000000": "&stack0x00000000",
                "DAT_00000a9c": "DAT_00000a9c",
                "register0x00000054": "register0x00000054",
                "PTR_heap_top_00000aa4": "PTR_heap_top_00000aa4",
                "getMainStackPointer()": "getMainStackPointer()",
                "getProcessStackPointer()": "getProcessStackPointer()",
                "hard_fault_handler": "hard_fault_handler"
            },
            "code": "void execute_hard_fault_handler_00000a64(void)\n{\n  uint32_t *main_stack_pointer;\n  uint32_t is_corrupted;\n  uint32_t unaff_r4;\n  undefined4 unaff_r5;\n  undefined4 unaff_r6;\n  undefined4 unaff_r7;\n  undefined4 unaff_r8;\n  undefined4 unaff_r9;\n  undefined4 unaff_r10;\n  undefined4 unaff_r11;\n  uint process_stack_pointer;\n  uint32_t *stack_pointer;\n  if ((PTR__eram_00000aa0 < &stack0x00000000) || (&stack0x00000000 <= DAT_00000a9c)) {\n    is_corrupted = 1;\n    register0x00000054 = (BADSPACEBASE *)PTR_heap_top_00000aa4;\n  }\n  else {\n    is_corrupted = 0;\n  }\n  if ((in_lr & 4) == 0) {\n    main_stack_pointer = (uint32_t *)getMainStackPointer();\n    stack_pointer = main_stack_pointer;\n  }\n  else {\n    process_stack_pointer = getProcessStackPointer();\n    stack_pointer = (uint32_t *)process_stack_pointer;\n  }\n  *(undefined4 *)((int)register0x00000054 + -4) = unaff_r11;\n  *(undefined4 *)((int)register0x00000054 + -8) = unaff_r10;\n  *(undefined4 *)((int)register0x00000054 + -0xc) = unaff_r9;\n  *(undefined4 *)((int)register0x00000054 + -0x10) = unaff_r8;\n  *(undefined4 *)((int)register0x00000054 + -0x14) = unaff_r7;\n  *(undefined4 *)((int)register0x00000054 + -0x18) = unaff_r6;\n  *(undefined4 *)((int)register0x00000054 + -0x1c) = unaff_r5;\n  *(uint32_t *)((int)register0x00000054 + -0x20) = unaff_r4;\n  hard_fault_handler(stack_pointer, is_corrupted, in_lr, (uint32_t *)((int)register0x00000054 + -0x20));\n}\n",
            "called": [
                "hard_fault_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a64",
            "calling": [],
            "imported": false,
            "current_name": "execute_hard_fault_handler_00000a64"
        },
        "FUN_000043a0": {
            "renaming": {
                "FUN_000043a0": "extract_data_from_buffer_000043a0",
                "param_1": "buffer_address",
                "param_2": "data_extractor",
                "piVar2": "current_buffer",
                "uVar1": "extracted_value",
                "iVar3": "data_address",
                "uVar4": "extracted_data",
                "iVar5": "current_entry"
            },
            "code": "uint extract_data_from_buffer_000043a0(int buffer_address, code *data_extractor)\n{\n  uint extracted_data = 0;\n  int *current_buffer = (int *)(buffer_address + 0x48);\n  do {\n    int current_entry = current_buffer[1];\n    int data_address = current_buffer[2];\n    while (current_entry = current_entry + -1, -1 < current_entry) {\n      if ((1 < *(ushort *)(data_address + 0xc)) && (*(short *)(data_address + 0xe) != -1)) {\n        uint extracted_value = (*data_extractor)(data_address);\n        extracted_data = extracted_data | extracted_value;\n      }\n      data_address = data_address + 0x68;\n    }\n    current_buffer = (int *)*current_buffer;\n  } while (current_buffer != (int *)0x0);\n  return extracted_data;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043a0",
            "calling": [
                "__srefill_r"
            ],
            "imported": false,
            "current_name": "extract_data_from_buffer_000043a0"
        },
        "FUN_0000211c": {
            "renaming": {
                "FUN_0000211c": "print_thread_info_0000211c",
                "queued_name": "queued_name",
                "stacksz": "stacksz",
                "queued": "queued",
                "sname": "sname",
                "state": "state",
                "thread_t": "thread",
                "stack_pointer": "stack_pointer",
                "isr_sp": "isr_sp",
                "isr_start": "isr_start",
                "isr_usage": "isr_usage",
                "i": "i",
                "overall_used": "overall_used",
                "overall_stacksz": "overall_stacksz",
                "bVar1": "state",
                "iVar2": "used",
                "pvVar3": "isr_stack_start",
                "pvVar4": "isr_stack_pointer",
                "uVar5": "stack_free",
                "puVar6": "thread",
                "uVar7": "state_name"
            },
            "code": "void print_thread_info_0000211c(void)\n{\n  char queued_name[2] = {0x51, 0x5f};\n  int overall_used = 0;\n  int overall_stacksz = 0x200;\n  kernel_pid_t i;\n  for (i = 1; i < 0x21; i++) {\n    thread_t *thread = *(thread_t **)(sched_threads + i * 4);\n    if (thread != NULL) {\n      byte state = *(byte *)(thread + 1);\n      char *state_name = state_names[state];\n      int stacksz = thread[11];\n      overall_stacksz += stacksz;\n      char *queued = queued_name + (state > 8);\n      uint8_t priority = *(byte *)((int)thread + 5);\n      char *sname = thread[10];\n      char *stack_pointer = thread_measure_stack_free((char *)thread[9]);\n      int used = stacksz - stack_pointer;\n      overall_used += used;\n      printf(\"%3d %-20s %-8s %1s %3d %6d %6d %p %d\\n\",*(short *)((int)thread + 6),sname,state_name,queued,priority,stacksz,used,thread[9],*thread);\n    }\n  }\n  printf(\"%5s %21s %13s %6s %5i %5i\\n\",\"PID\",\"STATE\",\"NAME\",\"Q\",\"Prio\",\"Stack\",\"Used\",\"Free\",\"Total\");\n  printf(\"%5s %21s %13s %6s %5i %5i\\n\",\"---\",\"-----\",\"----\",\"-\",\"----\",\"-----\",\"----\",\"----\",\"-----\");\n  printf(\"%5s %21s %13s %6s %5i %5i\\n\",\"\",\"\",\"\",\"\",\"\",\"%5i\",\"%5i\",\"%5i\",\"%5i\\n\",overall_stacksz,overall_used,overall_stacksz - overall_used);\n}\n",
            "called": [
                "thread_isr_stack_pointer",
                "thread_isr_stack_start",
                "iprintf",
                "thread_isr_stack_usage",
                "thread_measure_stack_free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000211c",
            "calling": [
                "_ps_handler",
                "core_panic"
            ],
            "imported": false,
            "current_name": "print_thread_info_0000211c"
        },
        "FUN_0000562c": {
            "renaming": {
                "FUN_0000562c": "find_environment_variable_0000562c",
                "param_1": "env_lock",
                "param_2": "variable_name",
                "param_3": "index",
                "cVar1": "current_char",
                "puVar2": "env_pointer",
                "ppcVar3": "env_array_pointer",
                "iVar4": "comparison_result",
                "pcVar5": "env_variable_value",
                "ppcVar6": "current_env_variable",
                "__n": "variable_name_length",
                "__env_lock": "env_lock",
                "__env_unlock": "env_unlock"
            },
            "code": "char * find_environment_variable_0000562c(undefined4 env_lock, char *variable_name, int *index)\n{\n  char current_char;\n  undefined *env_pointer;\n  char **env_array_pointer;\n  int comparison_result;\n  char *env_variable_value;\n  char **current_env_variable;\n  size_t variable_name_length;\n  env_lock();\n  env_pointer = PTR_environ_0000569c;\n  env_variable_value = NULL;\n  if (*(char ***)PTR_environ_0000569c != (char **)0x0) {\n    do {\n      current_char = *variable_name;\n      if (current_char == '\\0') {\n        variable_name_length = (int)variable_name - (int)env_variable_value;\n        env_array_pointer = *(char ***)PTR_environ_0000569c;\n        while( true ) {\n          current_env_variable = env_array_pointer;\n          if (*current_env_variable == (char *)0x0) break;\n          comparison_result = strncmp(*current_env_variable,env_variable_value,variable_name_length);\n          env_array_pointer = current_env_variable + 1;\n          if ((comparison_result == 0) && (env_variable_value = *current_env_variable, env_variable_value[variable_name_length] == '=')) {\n            *index = (int)current_env_variable - *(int *)env_pointer >> 2;\n            env_unlock(env_lock);\n            return env_variable_value + variable_name_length + 1;\n          }\n        }\n        break;\n      }\n      variable_name = variable_name + 1;\n    } while (current_char != '=');\n  }\n  env_unlock(env_lock);\n  return NULL;\n}",
            "called": [
                "__env_unlock",
                "strncmp",
                "__env_lock"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000562c",
            "calling": [
                "_getenv_r"
            ],
            "imported": false,
            "current_name": "find_environment_variable_0000562c"
        },
        "FUN_000020b8": {
            "renaming": {
                "FUN_000020b8": "handle_interrupt_000020b8",
                "DAT_000020c8": "interrupt_type"
            },
            "code": "void handle_interrupt_000020b8(void)\n{\n  int DAT_000020c8 = DAT_000020c8;\n  int interrupt_level = 0;\n  irq_handler(DAT_000020c8, interrupt_level);\n  return;\n}",
            "called": [
                "irq_handler"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020b8",
            "calling": [],
            "imported": false,
            "current_name": "handle_interrupt_000020b8"
        },
        "FUN_00002a18": {
            "renaming": {
                "FUN_00002a18": "find_command_handler_00002a18",
                "command_list": "command_list",
                "command": "command",
                "iVar1": "comparison_result",
                "command_lists": "command_lists",
                "i": "index",
                "entry": "current_command_list"
            },
            "code": "typedef struct shell_command {\n  char *name;\n  shell_command_handler_t handler;\n} shell_command_t;\n\ntypedef shell_command_t* command_list_t;\n\nshell_command_handler_t find_command_handler_00002a18(command_list_t command_list, char *command) {\n  shell_command_t *command_lists [2];\n  uint i;\n  shell_command_t *entry;\n  \n  command_lists[0] = command_list;\n  command_lists[1] = (shell_command_t *)PTR__shell_command_list_00002a84;\n  i = 0;\n  do {\n    if (i > 1) {\n      return NULL;\n    }\n    entry = command_lists[i];\n    if (entry != NULL) {\n      for (; entry->name != NULL; entry = entry + 1) {\n        if (strcmp(entry->name,command) == 0) {\n          return entry->handler;\n        }\n      }\n    }\n    i++;\n  } while(true);\n}",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a18",
            "calling": [
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "find_command_handler_00002a18"
        },
        "FUN_000054a8": {
            "renaming": {
                "FUN_000054a8": "processInputAndOutputFiles_000054a8",
                "param_1": "outputStatus",
                "param_2": "ioFile",
                "uVar1": "fileStatus",
                "uVar2": "fileStatusCopy",
                "uVar3": "fileSize",
                "uVar4": "fileValue",
                "iVar5": "impurePtr"
            },
            "code": "uint processInputAndOutputFiles_000054a8(undefined4 *outputStatus, undefined4 *ioFile) {\n  ushort fileStatus;\n  ushort fileStatusCopy;\n  uint fileSize;\n  uint fileValue;\n  int impurePtr;\n  \n  impurePtr = *(int *)PTR__impure_ptr_00005574;\n  if ((impurePtr != 0) && (*(int *)(impurePtr + 0x18) == 0)) {\n    __sinit(impurePtr);\n  }\n  if (ioFile == (undefined4 *)PTR___sf_fake_stdin_00005578) {\n    ioFile = *(undefined4 **)(impurePtr + 4);\n  }\n  else if (ioFile == (undefined4 *)PTR___sf_fake_stdout_0000557c) {\n    ioFile = *(undefined4 **)(impurePtr + 8);\n  }\n  else if (ioFile == (undefined4 *)PTR___sf_fake_stderr_00005580) {\n    ioFile = *(undefined4 **)(impurePtr + 0xc);\n  }\n  fileSize = (uint)*(ushort *)(ioFile + 3);\n  fileStatusCopy = *(ushort *)(ioFile + 3);\n  if (-1 < (int)(fileSize << 0x1c)) {\n    if (-1 < (int)(fileSize << 0x1b)) {\n      *outputStatus = 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(fileSize << 0x1d) < 0) {\n      if ((undefined4 *)ioFile[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)ioFile[0xd] != ioFile + 0x11) {\n          _free_r(outputStatus);\n        }\n        ioFile[0xd] = 0;\n      }\n      *(ushort *)(ioFile + 3) = *(ushort *)(ioFile + 3) & 0xffdb;\n      ioFile[1] = 0;\n      *ioFile = ioFile[4];\n    }\n    *(ushort *)(ioFile + 3) = *(ushort *)(ioFile + 3) | 8;\n  }\n  if ((ioFile[4] == 0) && ((*(ushort *)(ioFile + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(outputStatus, ioFile);\n  }\n  fileStatus = *(ushort *)(ioFile + 3);\n  fileSize = (uint)fileStatus;\n  fileValue = fileSize & 1;\n  if ((fileStatus & 1) == 0) {\n    if (-1 < (int)(fileSize << 0x1e)) {\n      fileValue = ioFile[5];\n    }\n    ioFile[2] = fileValue;\n  }\n  else {\n    ioFile[2] = 0;\n    ioFile[6] = -ioFile[5];\n  }\n  if (ioFile[4] != 0) {\n    return 0;\n  }\n  if ((fileStatus & 0x80) == 0) {\n    return fileSize & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(ioFile + 3) = fileStatusCopy | 0x40;\n  return 0xffffffff;\n}",
            "called": [
                "_free_r",
                "__smakebuf_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000054a8",
            "calling": [
                "_puts_r",
                "__swbuf_r",
                "_vfprintf_r"
            ],
            "imported": false,
            "current_name": "processInputAndOutputFiles_000054a8"
        },
        "FUN_000007dc": {
            "renaming": {
                "FUN_000007dc": "create_thread_stack_000007dc",
                "task_func": "thread_task_func",
                "arg": "thread_arg",
                "stack_start": "thread_stack_start",
                "stack_size": "thread_stack_size",
                "uVar1": "adjusted_stack_size",
                "stk": "stack_pointer",
                "i_1": "counter_1",
                "i": "counter_2"
            },
            "code": "char * create_thread_stack_000007dc(thread_task_func_t task_func, void *arg, void *stack_start, int stack_size)\n{\n    uint32_t *stack_pointer;\n    int i;\n    uint32_t adjusted_stack_size = (uint32_t)stack_size + (uint32_t)stack_start & 0xfffffffc;\n    stack_pointer = (uint32_t *)(adjusted_stack_size - 4);\n    *stack_pointer = 0x77777777;\n    if (((uint32_t)stack_pointer & 7) != 0) {\n        stack_pointer = (uint32_t *)(adjusted_stack_size - 8);\n        *stack_pointer = 0x88888888;\n    }\n    stack_pointer[-1] = 0x1000000;\n    stack_pointer[-2] = (uint32_t)task_func;\n    stack_pointer[-3] = DAT_000008b4;\n    stack_pointer = stack_pointer - 4;\n    *stack_pointer = 0;\n    for (i = 3; i > 0; i--) {\n        stack_pointer--;\n        *stack_pointer = i;\n    }\n    stack_pointer--;\n    *stack_pointer = (uint32_t)arg;\n    for (i = 0xb; i > 3; i--) {\n        stack_pointer--;\n        *stack_pointer = i;\n    }\n    stack_pointer[-1] = 0xfffffffd;\n    return (char *)(stack_pointer - 1);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000007dc",
            "calling": [
                "thread_create"
            ],
            "imported": false,
            "current_name": "create_thread_stack_000007dc"
        },
        "FUN_00001710": {
            "renaming": {
                "FUN_00001710": "clear_bit_00001710",
                "ptr": "data",
                "bit": "bit_position",
                "puVar1": "bit_ptr"
            },
            "code": "void clear_bit_00001710(uint8_t *data, uint8_t bit_position)\n{\n    uint8_t *bit_ptr = (uint8_t *)bitband_addr(data, (uint32_t)bit_position);\n    *bit_ptr = 0;\n    return;\n}",
            "called": [
                "bitband_addr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001710",
            "calling": [
                "kinetis_mcg_set_fei",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_disable_pll",
                "kinetis_mcg_set_fbe"
            ],
            "imported": false,
            "current_name": "clear_bit_00001710"
        },
        "FUN_000045ea": {
            "renaming": {
                "FUN_000045ea": "do_nothing_000045ea"
            },
            "code": "\nvoid do_nothing_000045ea(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ea",
            "calling": [
                "__tz_unlock"
            ],
            "imported": false,
            "current_name": "do_nothing_000045ea"
        },
        "FUN_000045ec": {
            "renaming": {
                "FUN_000045ec": "do_nothing_000045ec"
            },
            "code": "\nvoid do_nothing_000045ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ec",
            "calling": [
                "_puts_r",
                "__sinit_lock_release",
                "__env_unlock",
                "__malloc_unlock",
                "_fflush_r",
                "__sfp_lock_release",
                "_vfprintf_r",
                "_putc_r",
                "_getc_r"
            ],
            "imported": false,
            "current_name": "do_nothing_000045ec"
        },
        "FUN_00001034": {
            "renaming": {
                "FUN_00001034": "insert_thread_in_list_00001034",
                "list_entry": "current_thread",
                "__m____": "temp_node",
                "new_node": "new_node",
                "my_prio": "thread_priority",
                "local_1c": "current_node"
            },
            "code": "void insert_thread_in_list_00001034(list_node_t *list, thread_t *thread)\n{\n  list_node_t *current_node;\n  thread_t *current_thread;\n  clist_node_t *temp_node;\n  list_node_t *new_node;\n  uint16_t thread_priority;\n  \n  if (thread->status < 9) {\n    current_node = list;\n    while ((current_node->next != (list_node_t *)0x0 &&\n           (*(byte *)((int)&current_node->next[-1].next + 1) <= thread->priority))) {\n      current_node = current_node->next;\n    }\n    (thread->rq_entry).next = current_node->next;\n    current_node->next = &thread->rq_entry;\n    return;\n  }\n  core_panic(PANIC_ASSERT_FAIL, PTR_assert_crash_message_0000109c);\n}",
            "called": [
                "core_panic"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001034",
            "calling": [
                "_mutex_lock"
            ],
            "imported": false,
            "current_name": "insert_thread_in_list_00001034"
        },
        "FUN_000055ac": {
            "renaming": {
                "FUN_000055ac": "readNextByte_000055ac",
                "param_1": "stream",
                "param_2": "buffer",
                "uVar1": "byteRead",
                "pbVar2": "currentBytePointer"
            },
            "code": "uint readNextByte_000055ac(int stream, byte **buffer) {\n  uint byteRead;\n  byte *currentBytePointer;\n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (buffer == (byte **)original_stdin_pointer) {\n    buffer = *(byte ***)(stream + 4);\n  }\n  else if (buffer == (byte **)original_stdout_pointer) {\n    buffer = *(byte ***)(stream + 8);\n  }\n  else if (buffer == (byte **)original_stderr_pointer) {\n    buffer = *(byte ***)(stream + 0xc);\n  }\n  if ((-1 < (int)buffer[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(buffer + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(buffer[0x16]);\n  }\n  currentBytePointer = buffer[1];\n  buffer[1] = currentBytePointer - 1;\n  if ((int)(currentBytePointer - 1) < 0) {\n    byteRead = __srget_r(stream, buffer);\n  }\n  else {\n    currentBytePointer = *buffer;\n    *buffer = currentBytePointer + 1;\n    byteRead = (uint)*currentBytePointer;\n  }\n  if ((-1 < (int)buffer[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(buffer + 3) << 0x16))) {\n    __retarget_lock_release_recursive(buffer[0x16]);\n  }\n  return byteRead;\n}",
            "called": [
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive",
                "__srget_r",
                "__sinit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000055ac",
            "calling": [
                "getchar"
            ],
            "imported": false,
            "current_name": "readNextByte_000055ac"
        },
        "FUN_00006964": {
            "renaming": {
                "FUN_00006964": "calculate_value_of_array_element_00006964",
                "param_1": "array_start",
                "param_2": "index",
                "iVar1": "element_index",
                "PTR_": "ptr_to_",
                "DAT_": "data_"
            },
            "code": "int calculate_value_of_array_element_00006964(int array_start, int index){\n                      int element_value;\n                      int* PTR_array_start = (int*)array_start;\n                      int* PTR_index = (int*)index;\n                      int* PTR_element_value = (int*)(&element_value);\n                      \n                      int previous_element_index = *(PTR_index) - 1;\n                      int* PTR_previous_element_value = (int*)(&PTR_array_start[previous_element_index]);\n                      \n                      int is_negative_index = *(PTR_previous_element_value) < 0;\n                      \n                      if(is_negative_index){\n                          int offset = *(PTR_previous_element_value);\n                          PTR_element_value = (int*)(&PTR_array_start[previous_element_index + offset]);\n                      }\n                      else{\n                          PTR_element_value = PTR_previous_element_value;\n                      }\n                      \n                      return *PTR_element_value;\n                    }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006964",
            "calling": [
                "_realloc_r"
            ],
            "imported": false,
            "current_name": "calculate_value_of_array_element_00006964"
        },
        "FUN_0000182c": {
            "renaming": {
                "FUN_0000182c": "clear_bits_and_set_flag_0000182c",
                "tmp": "temp_var"
            },
            "code": "void clear_bits_and_set_flag_0000182c(void)\n{\n  uint8_t temp_var;\n  DAT_000018b4[8] &= 0xd0;\n  bit_set8(DAT_000018b8, 0);\n  bit_clear8(DAT_000018b4, 1);\n  bit_clear8(DAT_000018b4, 0);\n  return;\n}",
            "called": [
                "bit_set8",
                "bit_clear8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000182c",
            "calling": [
                "kinetis_mcg_init"
            ],
            "imported": false,
            "current_name": "clear_bits_and_set_flag_0000182c"
        },
        "FUN_00004db8": {
            "renaming": {
                "FUN_00004db8": "calculate_string_length_00004db8",
                "__s": "string",
                "iVar1": "length",
                "_FUN_00004db8_r": "_calculate_string_length_r"
            },
            "code": "int calculate_string_length_00004db8(char* string) {\n  int length = _calculate_string_length_00004db8_r(*(undefined4 *)PTR__impure_ptr_00004dc4, string);\n  return length;\n}",
            "called": [
                "_puts_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004db8",
            "calling": [
                "phydat_dump",
                "_rtc_setalarm",
                "_rtc_usage",
                "write",
                "list",
                "main",
                "read",
                "print_help",
                "_rtc_settime",
                "probe_all",
                "_rtc_getalarm",
                "_rtc_gettime",
                "hard_fault_handler",
                "_alarm_handler",
                "handle_input_line"
            ],
            "imported": false,
            "current_name": "calculate_string_length_00004db8"
        },
        "FUN_000022f0": {
            "renaming": {
                "FUN_000022f0": "read_from_ring_buffer_000022f0",
                "rb": "ring_buffer",
                "uVar1": "num_reads",
                "reads": "num_reads",
                "buf": "buffer",
                "size": "size"
            },
            "code": "char read_from_ring_buffer_000022f0(tsrb_t *ring_buffer) {\n  uint32_t num_reads = ring_buffer->num_reads;\n  ring_buffer->num_reads = num_reads + 1;\n  uint32_t index = num_reads & (ring_buffer->size - 1);\n  return ring_buffer->buffer[index];\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022f0",
            "calling": [
                "tsrb_get"
            ],
            "imported": false,
            "current_name": "read_from_ring_buffer_000022f0"
        },
        "FUN_00001c84": {
            "renaming": {
                "FUN_00001c84": "initialize_clocks_00001c84",
                "DAT_00001ce8": "PTR_BASE_ADDRESS",
                "DAT_00001cec": "PTR_REGISTER_ADDRESS",
                "disable_interrupts": "irq_disable",
                "set_safe_mode": "kinetis_mcg_set_safe_mode",
                "initialize_mcgirclk": "FUN_00001c84_mcgirclk",
                "initialize_erclk32k": "FUN_00001c84_erclk32k",
                "set_mode": "kinetis_mcg_set_mode",
                "restore_interrupts": "irq_restore"
            },
            "code": "void initialize_clocks_00001c84(void)\n{\n  uint32_t state;\n  uint32_t mask;\n  state = disable_interrupts();\n  set_safe_mode();\n  *(uint32_t *)(DAT_00001ce8 + 0x1044) = 0x220000;\n  DAT_00001cec[0xc] = 0;\n  *DAT_00001cec = *DAT_00001cec & 199 | 0x38;\n  DAT_00001cec[4] = 0x13;\n  DAT_00001cec[5] = 0;\n  initialize_mcgirclk();\n  initialize_erclk32k();\n  set_mode(KINETIS_MCG_MODE_PEE);\n  restore_interrupts(state);\n  return;\n}",
            "called": [
                "kinetis_mcg_init_erclk32k",
                "irq_disable",
                "irq_restore",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_mode"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001c84",
            "calling": [
                "cpu_init"
            ],
            "imported": false,
            "current_name": "initialize_clocks_00001c84"
        },
        "FUN_000068f0": {
            "renaming": {
                "FUN_000068f0": "store_flash_configuration_field_in_memory_000068f0",
                "param_1": "mem_alloc_size",
                "param_2": "memory_ptr",
                "pvVar1": "new_memory_ptr",
                "__n": "flash_config_field",
                "flash_configuration_field": "flash_config_field",
                "PTR_DAT_00000046": "flash_config_field_data_1",
                "PTR_DAT_00000045": "flash_config_field_data_2",
                "PTR_DAT_00000011": "memory_ptr_offset",
                "DAT_00000000": "return_value",
                "PTR_DAT_0000000d": "old_memory_ptr_size",
                "PTR_DAT_0000000e": "flash_config_field_size"
            },
            "code": "undefined4 store_flash_configuration_field_in_memory_000068f0(undefined4 mem_alloc_size, void **memory_ptr)\\n\\\n{\\n\\\n  void *new_memory_ptr;\\n\\\n  void *flash_config_field;\\n\\\n  void *PTR_DAT_0000000d;\\n\\\n  \\n\\\n  if ((void **)memory_ptr[0xd] == memory_ptr + 0x11) {\\n\\\n    new_memory_ptr = (void *)_malloc_r(mem_alloc_size,0x400);\\n\\\n    if (new_memory_ptr != (void *)0x0) {\\n\\\n      flash_config_field = memory_ptr[0xe];\\n\\\n      PTR_DAT_0000000d = memory_ptr[0xd];\\n\\\n      *(undefined *)((int)new_memory_ptr + 0x3ff) = *(undefined *)((int)memory_ptr + 0x46);\\n\\\n      *(undefined *)((int)new_memory_ptr + 0x3fe) = *(undefined *)((int)memory_ptr + 0x45);\\n\\\n      *(undefined *)((int)new_memory_ptr + 0x3fd) = *(undefined *)(memory_ptr + 0x11);\\n\\\n      *memory_ptr = (void *)((int)new_memory_ptr + 0x3fd);\\n\\\n      memory_ptr[0xe] = flash_config_field;\\n\\\n      memory_ptr[0xd] = new_memory_ptr;\\n\\\n      return 0;\\n\\\n    }\\n\\\n  }\\n\\\n  else {\\n\\\n    flash_config_field = memory_ptr[0xe];\\n\\\n    PTR_DAT_0000000d = memory_ptr[0xd];\\n\\\n    new_memory_ptr = (void *)_realloc_r(mem_alloc_size,PTR_DAT_0000000d,(void *)((int)flash_config_field << 1));\\n\\\n    if (new_memory_ptr != (void *)0x0) {\\n\\\n      memcpy((void *)((int)new_memory_ptr + (int)flash_config_field),new_memory_ptr,(size_t)flash_config_field);\\n\\\n      memory_ptr[0xd] = new_memory_ptr;\\n\\\n      memory_ptr[0xe] = (void *)((int)flash_config_field << 1);\\n\\\n      *memory_ptr = (void *)((int)new_memory_ptr + (int)flash_config_field);\\n\\\n      return 0;\\n\\\n    }\\n\\\n  }\\n\\\n  return 0xffffffff;\\n\\\n}",
            "called": [
                "_realloc_r",
                "memcpy",
                "_malloc_r"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000068f0",
            "calling": [
                "_sungetc_r"
            ],
            "imported": false,
            "current_name": "store_flash_configuration_field_in_memory_000068f0"
        }
    },
    "used_tokens": 203357,
    "layers": [
        [
            "FUN_000026c0",
            "FUN_00004bd0",
            "FUN_00000794",
            "FUN_000064bc",
            "FUN_00002970",
            "FUN_00000ca0",
            "FUN_00000d0c",
            "FUN_00003d94",
            "FUN_0000579c",
            "FUN_000015d0",
            "FUN_00004cdc",
            "FUN_00005e68",
            "FUN_00000dcc",
            "FUN_0000285c",
            "FUN_00000e58",
            "FUN_00001778",
            "FUN_000026d8",
            "FUN_00000566",
            "FUN_00001d08",
            "FUN_000031fc",
            "FUN_000016ec",
            "FUN_00004e8c",
            "FUN_00005584",
            "FUN_00000cb0",
            "FUN_00004248",
            "FUN_00000f5c",
            "FUN_00001da2",
            "FUN_00001ec4",
            "FUN_00002744",
            "FUN_00002624",
            "FUN_00001e0c",
            "FUN_0000459c",
            "FUN_000014c4",
            "FUN_00004b34",
            "FUN_000004f2",
            "FUN_0000423c",
            "FUN_00004e66",
            "FUN_00005ecc",
            "FUN_00001628",
            "FUN_00001748",
            "FUN_0000294c",
            "FUN_00005790",
            "FUN_00000534",
            "FUN_000017dc",
            "FUN_000005ca",
            "FUN_000043da",
            "FUN_00005ff8",
            "FUN_00006754",
            "FUN_00002714",
            "FUN_000020e0",
            "FUN_00004f80",
            "FUN_00005fec",
            "FUN_000028f0",
            "FUN_00004f98",
            "FUN_00004dee",
            "FUN_00000fec",
            "FUN_00000428",
            "FUN_000039e8",
            "FUN_00000e38",
            "FUN_00002294",
            "FUN_00003e9e",
            "FUN_00003378",
            "FUN_00006768",
            "FUN_00000db0",
            "FUN_00002600",
            "FUN_00003810",
            "FUN_00000ed8",
            "FUN_000031e0",
            "FUN_000004d4",
            "FUN_000020f4",
            "FUN_0000687c",
            "FUN_00004dea",
            "FUN_00005edc",
            "FUN_000023a4",
            "FUN_0000240c",
            "FUN_00004280",
            "FUN_00001448",
            "FUN_00001688",
            "FUN_00004042",
            "FUN_00000cf0",
            "FUN_00000f8c",
            "FUN_00002894",
            "FUN_00004158",
            "FUN_00002654",
            "FUN_00000aa8",
            "FUN_00002538",
            "FUN_00004c84",
            "FUN_000012b4",
            "FUN_0000058e",
            "FUN_000025f4",
            "FUN_00001ddc",
            "FUN_00002ecc",
            "FUN_00000d76",
            "FUN_000057a8",
            "FUN_00004298",
            "FUN_00001696",
            "FUN_000008b8",
            "FUN_000024bc",
            "FUN_00000490",
            "FUN_0000091c",
            "FUN_00005d80",
            "FUN_00001f80",
            "FUN_00000e64",
            "FUN_000026e4",
            "FUN_00000d44",
            "FUN_00000698",
            "FUN_00000cd0",
            "FUN_00000cc0",
            "FUN_00002994",
            "FUN_00000d2a",
            "FUN_00001ff6",
            "FUN_00000f80",
            "FUN_00002a88",
            "FUN_00002f30",
            "FUN_00001e44",
            "FUN_00001318",
            "FUN_00000900",
            "FUN_00004274",
            "FUN_00002fe0",
            "FUN_00001dc0",
            "FUN_00000df4",
            "FUN_00002eb4",
            "FUN_0000328c",
            "FUN_000041f4",
            "FUN_0000316c",
            "FUN_000026f0",
            "FUN_000057d2",
            "FUN_00000958",
            "FUN_000056b8",
            "FUN_00001a18",
            "FUN_00000d9c",
            "FUN_00003ff4",
            "FUN_00001d5e",
            "FUN_0000191c",
            "FUN_000050f4",
            "FUN_00000c80",
            "FUN_00000a40",
            "FUN_00005a58",
            "FUN_000056b0",
            "FUN_00003d24",
            "FUN_000060cc",
            "FUN_000022be",
            "FUN_00003dc4",
            "FUN_00002108",
            "FUN_00000c90",
            "FUN_00001d80",
            "FUN_000033c0",
            "FUN_00002b10",
            "FUN_00001b10",
            "FUN_000023c8",
            "FUN_00002e48",
            "FUN_00000930",
            "FUN_00001348",
            "FUN_00006118",
            "FUN_00001d3a",
            "FUN_00002434",
            "FUN_00005700",
            "FUN_00002798",
            "FUN_00003524",
            "FUN_00001bb8",
            "FUN_0000428c",
            "FUN_0000404c",
            "FUN_00002f74",
            "FUN_000010a0",
            "FUN_000012e2",
            "FUN_000056a0",
            "FUN_0000231c",
            "FUN_00002690",
            "FUN_00006010",
            "FUN_00001cf0",
            "FUN_00003ec4",
            "FUN_00001360",
            "FUN_00004622",
            "FUN_0000093c",
            "FUN_00003658",
            "FUN_000019c0",
            "FUN_000060b0",
            "FUN_000023d0",
            "FUN_00000a30",
            "FUN_000034c0",
            "FUN_000050e8",
            "FUN_00000514",
            "FUN_00002e9c",
            "FUN_00001960",
            "FUN_00001a3c",
            "FUN_000045ee",
            "FUN_00005404",
            "FUN_00006974",
            "FUN_00005fd4",
            "FUN_00004dc8",
            "FUN_00005e10",
            "FUN_000033f4",
            "FUN_0000443c",
            "FUN_000027b0",
            "FUN_00005ebc",
            "FUN_00006192",
            "FUN_00001734",
            "FUN_00000e14",
            "FUN_0000281c",
            "FUN_00002270",
            "FUN_000020cc",
            "FUN_00002396",
            "FUN_00004e4a",
            "FUN_00004cb4",
            "FUN_00003478",
            "FUN_00002028",
            "FUN_000016c8",
            "FUN_00001a60",
            "FUN_000004b2",
            "FUN_0000099c",
            "FUN_00002d94",
            "FUN_00003918",
            "FUN_00003d64",
            "FUN_00004e52",
            "FUN_000010d4",
            "FUN_00000738",
            "FUN_00003e58",
            "FUN_00004e26",
            "FUN_00000978",
            "FUN_000018bc",
            "FUN_00000974",
            "FUN_00000610",
            "FUN_00003694",
            "FUN_00002364",
            "FUN_00001ad4",
            "FUN_00001274",
            "FUN_00002e6c",
            "FUN_00003444",
            "FUN_00003688",
            "FUN_00001392",
            "FUN_00002910",
            "FUN_00004418",
            "FUN_0000258c",
            "FUN_00002a00",
            "FUN_00000a64",
            "FUN_000043a0",
            "FUN_0000211c",
            "FUN_0000562c",
            "FUN_000020b8",
            "FUN_00002a18",
            "FUN_000054a8",
            "FUN_000007dc",
            "FUN_00001710",
            "FUN_00001034",
            "FUN_000055ac",
            "FUN_00006964",
            "FUN_0000182c",
            "FUN_000022f0",
            "FUN_000068f0"
        ],
        [
            "FUN_00000dc0",
            "FUN_00005100",
            "FUN_000041d0",
            "FUN_0000129c",
            "FUN_00000410",
            "FUN_00004f84",
            "FUN_00001eea",
            "FUN_0000305c",
            "FUN_000013b8",
            "FUN_000042a4",
            "FUN_00004314",
            "FUN_00005fd8",
            "FUN_00005780",
            "FUN_00000f04",
            "FUN_00004db8",
            "FUN_00001c84"
        ]
    ],
    "locked_functions": []
}